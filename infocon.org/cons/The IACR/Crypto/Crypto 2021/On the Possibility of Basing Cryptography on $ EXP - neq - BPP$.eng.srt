1
00:00:01,520 --> 00:00:03,199
hello everyone today i would like to

2
00:00:03,199 --> 00:00:05,200
talk about my work on the possibility of

3
00:00:05,200 --> 00:00:07,520
basing cryptography and actually is not

4
00:00:07,520 --> 00:00:10,080
equal to ppp and this is a joint work

5
00:00:10,080 --> 00:00:12,080
with professor of our past at cornell

6
00:00:12,080 --> 00:00:14,000
tech

7
00:00:14,000 --> 00:00:16,160
so today we're going to talk about the

8
00:00:16,160 --> 00:00:18,480
notion of biofunctions which is what's

9
00:00:18,480 --> 00:00:21,359
proposed by different hammer in 76

10
00:00:21,359 --> 00:00:24,160
when we function is unequivocally the

11
00:00:24,160 --> 00:00:27,760
most central notion in cryptography

12
00:00:27,760 --> 00:00:30,160
and it's well known that while function

13
00:00:30,160 --> 00:00:32,320
is both necessary and sufficient for a

14
00:00:32,320 --> 00:00:33,440
branch of

15
00:00:33,440 --> 00:00:35,680
private key crypto primitives such as

16
00:00:35,680 --> 00:00:37,200
private key encryption superior

17
00:00:37,200 --> 00:00:41,040
generators digital signatures and so on

18
00:00:41,040 --> 00:00:43,600
and we also know that's

19
00:00:43,600 --> 00:00:46,239
public encryption oblivious transfer

20
00:00:46,239 --> 00:00:48,000
would imply the existence of one

21
00:00:48,000 --> 00:00:49,760
functions

22
00:00:49,760 --> 00:00:52,480
so without my function there is really

23
00:00:52,480 --> 00:00:55,680
no non-trivial computational crypto

24
00:00:55,680 --> 00:00:58,480
so we really need one function to exist

25
00:00:58,480 --> 00:01:01,039
however proving the existence of one

26
00:01:01,039 --> 00:01:03,600
function is a very hard problem and

27
00:01:03,600 --> 00:01:06,799
would imply mp is not equal to p

28
00:01:06,799 --> 00:01:08,720
therefore in the absence of a formal

29
00:01:08,720 --> 00:01:11,200
proof people have just come up with

30
00:01:11,200 --> 00:01:12,880
those wave function construction

31
00:01:12,880 --> 00:01:14,320
candidates

32
00:01:14,320 --> 00:01:16,240
which are based on different

33
00:01:16,240 --> 00:01:19,759
computational assumptions including the

34
00:01:19,759 --> 00:01:21,439
the hardness of factoring problem the

35
00:01:21,439 --> 00:01:23,600
hardness of discrete logarithmic problem

36
00:01:23,600 --> 00:01:26,799
and the hardness of lattice problem

37
00:01:26,799 --> 00:01:27,840
however

38
00:01:27,840 --> 00:01:29,600
we know that if we have quantum

39
00:01:29,600 --> 00:01:32,240
computers then the factoring assumption

40
00:01:32,240 --> 00:01:33,200
and the

41
00:01:33,200 --> 00:01:35,439
discrete logarithmic assumption are just

42
00:01:35,439 --> 00:01:37,840
broken and

43
00:01:37,840 --> 00:01:40,159
so we really need to prove the existence

44
00:01:40,159 --> 00:01:42,640
of well function

45
00:01:42,640 --> 00:01:45,520
so in this work we ask can we prove the

46
00:01:45,520 --> 00:01:48,399
existence of male function based on very

47
00:01:48,399 --> 00:01:50,159
weak assumptions about physical

48
00:01:50,159 --> 00:01:51,600
computation

49
00:01:51,600 --> 00:01:54,960
and perhaps the most believable and

50
00:01:54,960 --> 00:01:57,680
it's embarrassing open conjecture is

51
00:01:57,680 --> 00:02:01,200
that x is not equal to vpp

52
00:02:01,200 --> 00:02:03,200
so let us look at looking into this

53
00:02:03,200 --> 00:02:05,680
minimal conjecture

54
00:02:05,680 --> 00:02:08,239
recall that x denotes the class of

55
00:02:08,239 --> 00:02:10,160
action exponential time decidable

56
00:02:10,160 --> 00:02:13,040
languages and we don't know that x is

57
00:02:13,040 --> 00:02:16,239
not equal to sub x so even

58
00:02:16,239 --> 00:02:18,959
a self-exponential time algorithm cannot

59
00:02:18,959 --> 00:02:23,040
emulate exponential time computation and

60
00:02:23,040 --> 00:02:24,400
on the other hand

61
00:02:24,400 --> 00:02:27,120
bpp denotes the class of randomized

62
00:02:27,120 --> 00:02:29,440
polynomial time decidable languages

63
00:02:29,440 --> 00:02:32,000
and it is believed that bpp is equal to

64
00:02:32,000 --> 00:02:32,720
p

65
00:02:32,720 --> 00:02:35,200
in other words the power of randomized

66
00:02:35,200 --> 00:02:37,440
polynomial time algorithms are as

67
00:02:37,440 --> 00:02:38,879
powerful as

68
00:02:38,879 --> 00:02:39,840
the

69
00:02:39,840 --> 00:02:42,800
deterministic polynomial time algorithm

70
00:02:42,800 --> 00:02:43,519
so

71
00:02:43,519 --> 00:02:46,480
our improvement minimum conjecture would

72
00:02:46,480 --> 00:02:49,200
be x is not equal to bpp

73
00:02:49,200 --> 00:02:51,920
informally randomness does not

74
00:02:51,920 --> 00:02:55,840
exponentially speed up computation

75
00:02:55,840 --> 00:02:57,519
and note that it's a really weak

76
00:02:57,519 --> 00:02:59,840
conjunction in the sense that and many

77
00:02:59,840 --> 00:03:01,040
other

78
00:03:01,040 --> 00:03:03,360
assumptions would also imply it

79
00:03:03,360 --> 00:03:06,720
note that if mp is not equal to ppp then

80
00:03:06,720 --> 00:03:09,440
we have x is not equal to p

81
00:03:09,440 --> 00:03:12,800
and if bpp is equal to p then we have

82
00:03:12,800 --> 00:03:15,280
actually is not equal to pvp

83
00:03:15,280 --> 00:03:18,159
furthermore even if we assume randomized

84
00:03:18,159 --> 00:03:20,000
polynomial time algorithm

85
00:03:20,000 --> 00:03:23,680
are are much more much powerful and

86
00:03:23,680 --> 00:03:24,879
even

87
00:03:24,879 --> 00:03:27,599
even if they can emulate sub-exponential

88
00:03:27,599 --> 00:03:28,879
time

89
00:03:28,879 --> 00:03:31,280
computation that would still have x it's

90
00:03:31,280 --> 00:03:33,440
not equal to ppp

91
00:03:33,440 --> 00:03:35,680
so it would be really crazy to assume

92
00:03:35,680 --> 00:03:38,159
that the randomized randomness can speed

93
00:03:38,159 --> 00:03:38,879
up

94
00:03:38,879 --> 00:03:41,760
algorithms exponentially and it's really

95
00:03:41,760 --> 00:03:44,720
an impression that such a conjecture has

96
00:03:44,720 --> 00:03:46,879
not been proven

97
00:03:46,879 --> 00:03:49,760
so this is really weak conjecture

98
00:03:49,760 --> 00:03:52,879
so in this work we ask can we based on

99
00:03:52,879 --> 00:03:55,519
the base the existence of well function

100
00:03:55,519 --> 00:03:59,439
on such a weak conjecture

101
00:03:59,439 --> 00:04:03,040
so we show that there exists a standard

102
00:04:03,040 --> 00:04:07,920
nature computational problem called mktp

103
00:04:07,920 --> 00:04:10,799
such that this if this problem being

104
00:04:10,799 --> 00:04:12,400
hard on average with respect to

105
00:04:12,400 --> 00:04:14,959
two-secondary heuristics is equivalent

106
00:04:14,959 --> 00:04:17,279
to the existence of one function

107
00:04:17,279 --> 00:04:20,160
and also this same problem

108
00:04:20,160 --> 00:04:22,160
being hard on average with respect to

109
00:04:22,160 --> 00:04:24,639
errorless theoretics is equivalent to x

110
00:04:24,639 --> 00:04:26,880
is not equal to bpp

111
00:04:26,880 --> 00:04:31,199
and as we shall see later on this mktp

112
00:04:31,199 --> 00:04:33,520
is really a standard problem related to

113
00:04:33,520 --> 00:04:36,000
commodore capacity and has been studying

114
00:04:36,000 --> 00:04:38,320
since the 60s

115
00:04:38,320 --> 00:04:39,360
and

116
00:04:39,360 --> 00:04:43,120
and the notion of two-sided air and

117
00:04:43,120 --> 00:04:45,919
arrowless abdicates harness are the two

118
00:04:45,919 --> 00:04:48,960
standard notions used in capacity

119
00:04:48,960 --> 00:04:51,040
literatures

120
00:04:51,040 --> 00:04:53,360
so therefore the only gap between the

121
00:04:53,360 --> 00:04:56,080
existence of one function and x is not

122
00:04:56,080 --> 00:04:58,720
equal to bpp is a seemingly minor

123
00:04:58,720 --> 00:05:01,039
technical distinguishing distinction

124
00:05:01,039 --> 00:05:03,600
between two standard notions of average

125
00:05:03,600 --> 00:05:07,600
case hardness for a specific problem

126
00:05:07,600 --> 00:05:08,800
and

127
00:05:08,800 --> 00:05:11,199
to introduce our main theorem let's look

128
00:05:11,199 --> 00:05:14,160
at let us first introduce the notion of

129
00:05:14,160 --> 00:05:16,160
when functions

130
00:05:16,160 --> 00:05:16,880
so

131
00:05:16,880 --> 00:05:19,520
a function f is one way if it's easy to

132
00:05:19,520 --> 00:05:21,759
compute so f should be able to be

133
00:05:21,759 --> 00:05:24,160
computed in polynomial time and f is

134
00:05:24,160 --> 00:05:26,639
hard to invert so no ppt motion can

135
00:05:26,639 --> 00:05:27,919
invert f

136
00:05:27,919 --> 00:05:30,320
and informally given the input x it's

137
00:05:30,320 --> 00:05:33,600
easy to go from x to f f of x but it's

138
00:05:33,600 --> 00:05:36,800
hard to go back to x from the output f

139
00:05:36,800 --> 00:05:38,720
of x

140
00:05:38,720 --> 00:05:41,199
and more formally we say that f is a

141
00:05:41,199 --> 00:05:43,120
very function if

142
00:05:43,120 --> 00:05:46,320
given a random string x of n bits we let

143
00:05:46,320 --> 00:05:48,479
y be f of x

144
00:05:48,479 --> 00:05:49,360
and

145
00:05:49,360 --> 00:05:52,240
for any ppt algorithm a the probability

146
00:05:52,240 --> 00:05:55,440
that a our input y outputs a pre image

147
00:05:55,440 --> 00:05:58,960
of y is at most negligible amounts

148
00:05:58,960 --> 00:05:59,840
and

149
00:05:59,840 --> 00:06:02,160
for standard runway functions

150
00:06:02,160 --> 00:06:05,280
we ask all attackers fail on all input

151
00:06:05,280 --> 00:06:06,720
length n

152
00:06:06,720 --> 00:06:09,360
so here we also consider a notion of

153
00:06:09,360 --> 00:06:12,000
infinity of a value function where the

154
00:06:12,000 --> 00:06:15,120
inversion requirement is relaxed and we

155
00:06:15,120 --> 00:06:18,000
ask or attackers fail on infinitely

156
00:06:18,000 --> 00:06:21,759
often many input lengths n

157
00:06:21,759 --> 00:06:24,639
so therefore our main theorem says that

158
00:06:24,639 --> 00:06:26,479
the existence of infinity overwhelm

159
00:06:26,479 --> 00:06:27,520
functions

160
00:06:27,520 --> 00:06:28,240
is

161
00:06:28,240 --> 00:06:31,600
equivalent to this mkt problem being

162
00:06:31,600 --> 00:06:33,440
hard on average with respect to

163
00:06:33,440 --> 00:06:36,479
two-sided air heuristics and x is not

164
00:06:36,479 --> 00:06:40,000
equal to bpp if and only if mktp is hot

165
00:06:40,000 --> 00:06:42,080
on average with respect to errorless

166
00:06:42,080 --> 00:06:43,919
heuristics

167
00:06:43,919 --> 00:06:44,800
and

168
00:06:44,800 --> 00:06:46,639
here mktp

169
00:06:46,639 --> 00:06:48,880
is the language of pairs of

170
00:06:48,880 --> 00:06:51,440
k comma x comma k having the property

171
00:06:51,440 --> 00:06:54,560
that x have has 11 commodore capacity at

172
00:06:54,560 --> 00:06:56,560
most k

173
00:06:56,560 --> 00:06:58,479
and we mark here that we can also

174
00:06:58,479 --> 00:07:00,720
characterize standard round functions by

175
00:07:00,720 --> 00:07:02,720
considering an almost everywhere notion

176
00:07:02,720 --> 00:07:04,880
of everyday furnace

177
00:07:04,880 --> 00:07:06,479
and let us

178
00:07:06,479 --> 00:07:08,080
introduce the notion of homogeneous

179
00:07:08,080 --> 00:07:10,319
capacity

180
00:07:10,319 --> 00:07:12,479
given the following two strings the

181
00:07:12,479 --> 00:07:14,240
first is like one two three one two

182
00:07:14,240 --> 00:07:16,000
three and so on and the second one is

183
00:07:16,000 --> 00:07:17,680
when there were three something and

184
00:07:17,680 --> 00:07:20,160
something looks random so the question

185
00:07:20,160 --> 00:07:22,720
here is that which of the above strings

186
00:07:22,720 --> 00:07:24,240
is more random

187
00:07:24,240 --> 00:07:26,160
and the notion of komodo capacity

188
00:07:26,160 --> 00:07:29,680
proposed by komovo in 1768

189
00:07:29,680 --> 00:07:31,759
is used to measure the amount of

190
00:07:31,759 --> 00:07:34,319
randomness in a fixed string

191
00:07:34,319 --> 00:07:36,720
so here for any string x we let k of x

192
00:07:36,720 --> 00:07:38,479
denote the length of the shortest

193
00:07:38,479 --> 00:07:40,880
program that outputs x

194
00:07:40,880 --> 00:07:42,880
and more formally we fix the universal

195
00:07:42,880 --> 00:07:44,960
trimester u and we are looking for the

196
00:07:44,960 --> 00:07:46,479
length of the shortest problem high

197
00:07:46,479 --> 00:07:49,680
which consists of m comma w such that u

198
00:07:49,680 --> 00:07:52,240
and input m comma w will output the

199
00:07:52,240 --> 00:07:54,400
string x

200
00:07:54,400 --> 00:07:55,840
and the notion of

201
00:07:55,840 --> 00:07:58,160
capacity has a lot of amazing

202
00:07:58,160 --> 00:08:00,080
applications such as proving godot's

203
00:08:00,080 --> 00:08:02,639
incompletions theorem but unfortunately

204
00:08:02,639 --> 00:08:05,199
it is uncomputable

205
00:08:05,199 --> 00:08:07,919
and we instead look at levin's commodore

206
00:08:07,919 --> 00:08:09,199
capacity

207
00:08:09,199 --> 00:08:12,639
which is proposed by 1173

208
00:08:12,639 --> 00:08:15,840
so we let kt of x to be

209
00:08:15,840 --> 00:08:18,400
the minimum over all programs at output

210
00:08:18,400 --> 00:08:21,680
x of the sum of first the length of the

211
00:08:21,680 --> 00:08:23,680
program pi and the second log the

212
00:08:23,680 --> 00:08:26,400
logarithm of the running time of pi

213
00:08:26,400 --> 00:08:30,000
for example if the machine pi outputs x

214
00:08:30,000 --> 00:08:32,880
within time 2 to the power of n over 10

215
00:08:32,880 --> 00:08:35,519
and the list of machine is at most n

216
00:08:35,519 --> 00:08:36,559
over 10

217
00:08:36,559 --> 00:08:40,159
then ktx is at most and over 10 plus

218
00:08:40,159 --> 00:08:43,599
over 10 which is n over 5.

219
00:08:43,599 --> 00:08:46,000
and the intuition of doing this is that

220
00:08:46,000 --> 00:08:47,920
we charge for the size of the program

221
00:08:47,920 --> 00:08:50,080
and the running time summation is sleep

222
00:08:50,080 --> 00:08:53,040
but we only charge like logarithmically

223
00:08:53,040 --> 00:08:54,880
for running time to capture the

224
00:08:54,880 --> 00:08:57,360
intuition that's polynomial time

225
00:08:57,360 --> 00:09:01,519
computations are relatively cheap

226
00:09:01,519 --> 00:09:03,680
and the key observation here is that the

227
00:09:03,680 --> 00:09:06,959
kt of x is at most list of x plus one

228
00:09:06,959 --> 00:09:08,800
for any string x

229
00:09:08,800 --> 00:09:11,920
so just consider a tree machine where on

230
00:09:11,920 --> 00:09:14,720
its tape it's the we leave the string x

231
00:09:14,720 --> 00:09:17,360
on its tape and the machine itself is

232
00:09:17,360 --> 00:09:19,839
is a machine that holds immediately so

233
00:09:19,839 --> 00:09:22,720
if we run the machine it will terminate

234
00:09:22,720 --> 00:09:25,760
immediately and the output string acts

235
00:09:25,760 --> 00:09:27,040
on its tape

236
00:09:27,040 --> 00:09:29,040
and this machine takes you know constant

237
00:09:29,040 --> 00:09:32,720
time so therefore the kt capacity of x

238
00:09:32,720 --> 00:09:36,560
is at most list of x plus alpha

239
00:09:36,560 --> 00:09:39,920
and here mktp denotes the language is

240
00:09:39,920 --> 00:09:43,120
the language of pairs of x comma k such

241
00:09:43,120 --> 00:09:46,320
that kt of x is at most k

242
00:09:46,320 --> 00:09:49,839
so we note that this mkhp language no

243
00:09:49,839 --> 00:09:52,160
longer seems to be in mp

244
00:09:52,160 --> 00:09:55,279
since here for example this pi will

245
00:09:55,279 --> 00:09:56,640
output x

246
00:09:56,640 --> 00:10:00,160
in time 2 to the power of n over 10 and

247
00:10:00,160 --> 00:10:02,320
we don't know how to verify this in

248
00:10:02,320 --> 00:10:05,519
polynomial time

249
00:10:05,519 --> 00:10:08,000
then let's let us introduce notions of

250
00:10:08,000 --> 00:10:11,200
average hardness used in this work

251
00:10:11,200 --> 00:10:13,120
so we first introduce the notion of

252
00:10:13,120 --> 00:10:15,279
two-sided error here as average case

253
00:10:15,279 --> 00:10:18,320
hardness and we say that the language l

254
00:10:18,320 --> 00:10:21,200
is in hierarchy p if for all polynomial

255
00:10:21,200 --> 00:10:23,839
p there exists a deterministic algorithm

256
00:10:23,839 --> 00:10:27,760
h such as h of x equals l of x with

257
00:10:27,760 --> 00:10:30,320
probability y minus 1 over p of n over

258
00:10:30,320 --> 00:10:34,959
random x and we also consider another

259
00:10:34,959 --> 00:10:35,920
notion

260
00:10:35,920 --> 00:10:38,640
of standard average case hardness

261
00:10:38,640 --> 00:10:42,000
which caused errorless average hardness

262
00:10:42,000 --> 00:10:42,959
and

263
00:10:42,959 --> 00:10:44,800
we notice this is really a standard

264
00:10:44,800 --> 00:10:47,440
notion in capacity theory literature

265
00:10:47,440 --> 00:10:50,240
so we say that a language l is in

266
00:10:50,240 --> 00:10:52,959
average p if for all polynomial p there

267
00:10:52,959 --> 00:10:56,000
exists a deterministic algorithm edge

268
00:10:56,000 --> 00:10:59,839
such that for all inputs x h of x will

269
00:10:59,839 --> 00:11:02,959
output either l of x the correct answer

270
00:11:02,959 --> 00:11:04,640
or bot

271
00:11:04,640 --> 00:11:07,279
and second the probability that h of x

272
00:11:07,279 --> 00:11:08,640
output spots

273
00:11:08,640 --> 00:11:12,160
is at most one over p of m

274
00:11:12,160 --> 00:11:14,720
so these two notions of heuristics that

275
00:11:14,720 --> 00:11:16,160
they both succeed with very high

276
00:11:16,160 --> 00:11:18,800
probability namely y minus one over p of

277
00:11:18,800 --> 00:11:19,600
n

278
00:11:19,600 --> 00:11:21,120
and the difference between these two

279
00:11:21,120 --> 00:11:24,000
notions is that for an

280
00:11:24,000 --> 00:11:26,640
two-sided error heuristic it's it is

281
00:11:26,640 --> 00:11:30,480
unaware of enemy 6 so if h of x outputs

282
00:11:30,480 --> 00:11:34,640
0 it's unclear whether l of x is also 0.

283
00:11:34,640 --> 00:11:37,519
however an errorless heuristic knows it

284
00:11:37,519 --> 00:11:39,839
when making a mistake

285
00:11:39,839 --> 00:11:42,720
so if h of x doesn't output but it is

286
00:11:42,720 --> 00:11:45,760
guaranteed that l of x is equal to h of

287
00:11:45,760 --> 00:11:47,600
x

288
00:11:47,600 --> 00:11:49,519
and in this work

289
00:11:49,519 --> 00:11:52,000
we will consider

290
00:11:52,000 --> 00:11:54,639
the notion of randomized heuristics

291
00:11:54,639 --> 00:11:58,320
and we consider the bb bpp analog of

292
00:11:58,320 --> 00:12:01,120
heuristic p and average p

293
00:12:01,120 --> 00:12:02,880
we have to you know modify the

294
00:12:02,880 --> 00:12:05,200
definition accordingly and the

295
00:12:05,200 --> 00:12:07,279
difference between these two notions

296
00:12:07,279 --> 00:12:10,959
stays the same as we mentioned before

297
00:12:10,959 --> 00:12:13,279
okay so we are ready to present our

298
00:12:13,279 --> 00:12:15,200
material formally

299
00:12:15,200 --> 00:12:17,360
so we first first will show that the

300
00:12:17,360 --> 00:12:19,040
existence of infinite overwhelm

301
00:12:19,040 --> 00:12:22,240
functions is equivalent to mktp is not

302
00:12:22,240 --> 00:12:25,360
in us bpp and

303
00:12:25,360 --> 00:12:28,480
xv is not equal to pvp if and only if

304
00:12:28,480 --> 00:12:32,959
mktp is not inside average bpp

305
00:12:32,959 --> 00:12:33,760
so

306
00:12:33,760 --> 00:12:35,920
we show that spacing when we functions

307
00:12:35,920 --> 00:12:39,519
on x is not equal to ppp boils down to a

308
00:12:39,519 --> 00:12:41,760
seemingly minor technical problem

309
00:12:41,760 --> 00:12:44,320
between two standard notions of evidence

310
00:12:44,320 --> 00:12:45,279
hardness

311
00:12:45,279 --> 00:12:46,160
and

312
00:12:46,160 --> 00:12:49,440
proving mktp is not in average ppp it

313
00:12:49,440 --> 00:12:52,639
implies mktp is not in here as a vpp is

314
00:12:52,639 --> 00:12:55,200
exactly what we need to base infinite

315
00:12:55,200 --> 00:12:57,519
overwhelming function and x is not equal

316
00:12:57,519 --> 00:12:59,839
to pvp

317
00:12:59,839 --> 00:13:02,320
so one may wonder okay what are the

318
00:13:02,320 --> 00:13:04,800
consequences of this implication

319
00:13:04,800 --> 00:13:07,360
so the next theorem tells us that if we

320
00:13:07,360 --> 00:13:10,160
can show mktp is not in average bpp

321
00:13:10,160 --> 00:13:12,959
implies mktp is not in classical dpp

322
00:13:12,959 --> 00:13:15,600
then we prove mp is equal to it's not

323
00:13:15,600 --> 00:13:17,839
equal to p

324
00:13:17,839 --> 00:13:20,160
and there are two ways to interpret this

325
00:13:20,160 --> 00:13:23,360
theorem and the obs pessimistic

326
00:13:23,360 --> 00:13:25,839
interpretation would be that closing

327
00:13:25,839 --> 00:13:29,200
this minor gap will be very hard

328
00:13:29,200 --> 00:13:31,600
and on the other hand the optimistic

329
00:13:31,600 --> 00:13:33,920
interpretation would be that this is a

330
00:13:33,920 --> 00:13:36,560
new algorithmic approach across proving

331
00:13:36,560 --> 00:13:38,800
mp is not equal to p

332
00:13:38,800 --> 00:13:41,920
and so to prove this implication

333
00:13:41,920 --> 00:13:46,480
it's suffice to decide the language mktp

334
00:13:46,480 --> 00:13:49,600
errorlessly on average having a access

335
00:13:49,600 --> 00:13:52,399
to a two-sided error heuristic that's

336
00:13:52,399 --> 00:13:55,040
deciding that decides the same language

337
00:13:55,040 --> 00:13:57,360
so if we can come up such an algorithm

338
00:13:57,360 --> 00:14:00,839
then we prove mp is not equal to

339
00:14:00,839 --> 00:14:02,880
p and

340
00:14:02,880 --> 00:14:06,079
also in the paper we have showed some

341
00:14:06,079 --> 00:14:08,240
other characterizations of bind

342
00:14:08,240 --> 00:14:10,959
functions with additional properties uh

343
00:14:10,959 --> 00:14:14,079
for instance the computability com

344
00:14:14,079 --> 00:14:17,040
computability in log space or unified

345
00:14:17,040 --> 00:14:19,199
and zero using

346
00:14:19,199 --> 00:14:21,199
different other notions of resource

347
00:14:21,199 --> 00:14:23,199
bounded common capacity

348
00:14:23,199 --> 00:14:26,240
and we want to focus on this result in

349
00:14:26,240 --> 00:14:29,040
this talk and we refer

350
00:14:29,040 --> 00:14:30,399
view to the

351
00:14:30,399 --> 00:14:33,360
paper for more details

352
00:14:33,360 --> 00:14:35,199
and let us mention some related work

353
00:14:35,199 --> 00:14:36,160
here

354
00:14:36,160 --> 00:14:39,279
a and at all shows the x completeness of

355
00:14:39,279 --> 00:14:41,680
mktp with respect to p-slash poly

356
00:14:41,680 --> 00:14:42,880
reductions

357
00:14:42,880 --> 00:14:45,279
they show that if x is not in that piece

358
00:14:45,279 --> 00:14:48,399
electrolyte then mktp is not inside p

359
00:14:48,399 --> 00:14:49,680
slash volume

360
00:14:49,680 --> 00:14:51,440
and this will be our start point

361
00:14:51,440 --> 00:14:54,880
starting point for our theorem two

362
00:14:54,880 --> 00:14:57,360
and your n path 20 shows that the

363
00:14:57,360 --> 00:14:59,519
existence of one function is equivalent

364
00:14:59,519 --> 00:15:01,120
to the average case hardness of time

365
00:15:01,120 --> 00:15:03,519
bounded commodore capacity

366
00:15:03,519 --> 00:15:06,560
and this problem is another commodore

367
00:15:06,560 --> 00:15:09,199
compact sterile problem and it is not

368
00:15:09,199 --> 00:15:12,480
known that this problem is x completes

369
00:15:12,480 --> 00:15:13,760
however

370
00:15:13,760 --> 00:15:17,279
what we show today this mktp is x

371
00:15:17,279 --> 00:15:18,560
concludes

372
00:15:18,560 --> 00:15:20,880
and this will be our starting point for

373
00:15:20,880 --> 00:15:23,360
our theorem one

374
00:15:23,360 --> 00:15:25,440
concurrently and independently than

375
00:15:25,440 --> 00:15:27,519
anything terminal also shows an

376
00:15:27,519 --> 00:15:29,600
equivalence between wave functions and

377
00:15:29,600 --> 00:15:33,040
mild f case hardness of mktp

378
00:15:33,040 --> 00:15:33,920
and

379
00:15:33,920 --> 00:15:37,199
more recently leo n pass 20 21 shows

380
00:15:37,199 --> 00:15:39,600
that when it functions is equivalent to

381
00:15:39,600 --> 00:15:41,759
average case hardness of conditional

382
00:15:41,759 --> 00:15:44,720
time bounded commodore capacity problem

383
00:15:44,720 --> 00:15:47,519
and they also show that this problem is

384
00:15:47,519 --> 00:15:49,360
mp complete

385
00:15:49,360 --> 00:15:51,519
taking together while functions

386
00:15:51,519 --> 00:15:53,440
functions can now be characterized

387
00:15:53,440 --> 00:15:56,399
through advocace harness of expert x

388
00:15:56,399 --> 00:15:59,440
complex languages this work and an mp

389
00:15:59,440 --> 00:16:03,880
completes languages lp21

390
00:16:04,079 --> 00:16:05,199
so let us

391
00:16:05,199 --> 00:16:07,519
look into our proof so let's first

392
00:16:07,519 --> 00:16:10,079
present the proof for zero one uh which

393
00:16:10,079 --> 00:16:12,000
states infinity overwhelm functions

394
00:16:12,000 --> 00:16:15,680
exists if and only if mktp is not in

395
00:16:15,680 --> 00:16:18,720
a heuristic vpp

396
00:16:18,720 --> 00:16:21,279
so let's first look at the proof for the

397
00:16:21,279 --> 00:16:24,639
first direction and we want to show that

398
00:16:24,639 --> 00:16:27,920
if mktp is not inside here's a dpp then

399
00:16:27,920 --> 00:16:30,720
infinity often when functions exist

400
00:16:30,720 --> 00:16:33,199
and one may wonder okay why we only

401
00:16:33,199 --> 00:16:35,839
obtain infinite overall functions

402
00:16:35,839 --> 00:16:38,240
it's because the assumption mktp is

403
00:16:38,240 --> 00:16:40,959
nothing relative bpp is only an infinite

404
00:16:40,959 --> 00:16:42,880
notion of average case hardness

405
00:16:42,880 --> 00:16:44,880
and if we start with an almost

406
00:16:44,880 --> 00:16:47,519
everywhere notion of hardness that is

407
00:16:47,519 --> 00:16:50,079
mktp is nothing infinite often heuristic

408
00:16:50,079 --> 00:16:53,040
bpp then we will observe standard wave

409
00:16:53,040 --> 00:16:54,880
functions

410
00:16:54,880 --> 00:16:57,120
so we want to show that when functions

411
00:16:57,120 --> 00:17:00,720
exist assuming mktp is not inside here's

412
00:17:00,720 --> 00:17:02,720
the vpp and

413
00:17:02,720 --> 00:17:04,799
it's weird to know that it's sufficient

414
00:17:04,799 --> 00:17:07,199
to show that the weak infinity overwhelm

415
00:17:07,199 --> 00:17:08,559
function exists

416
00:17:08,559 --> 00:17:10,319
which is a efficiently computable

417
00:17:10,319 --> 00:17:13,359
function f such that no ppt machine can

418
00:17:13,359 --> 00:17:15,760
invert f with probability y minus one

419
00:17:15,760 --> 00:17:18,319
over p of n for all n and some

420
00:17:18,319 --> 00:17:20,480
polynomial p

421
00:17:20,480 --> 00:17:24,319
and by the famous and the famous

422
00:17:24,319 --> 00:17:26,400
hardness amplification lemma says that

423
00:17:26,400 --> 00:17:28,559
if a weak infinite overwhelming function

424
00:17:28,559 --> 00:17:31,200
exists then a what infinite overwhelm

425
00:17:31,200 --> 00:17:32,400
function exists

426
00:17:32,400 --> 00:17:34,480
so we just need to construct a weak wave

427
00:17:34,480 --> 00:17:36,559
function

428
00:17:36,559 --> 00:17:38,000
and

429
00:17:38,000 --> 00:17:40,720
let us show some intuitions for how to

430
00:17:40,720 --> 00:17:43,039
construct a weak one function assuming

431
00:17:43,039 --> 00:17:46,640
the average case hardness of mktp and

432
00:17:46,640 --> 00:17:49,919
we will ignore many important steps

433
00:17:49,919 --> 00:17:51,919
in this proof which makes the proof

434
00:17:51,919 --> 00:17:53,679
really complicated

435
00:17:53,679 --> 00:17:54,640
i

436
00:17:54,640 --> 00:17:57,039
so our idea here is to just highlight

437
00:17:57,039 --> 00:17:59,840
the central id

438
00:17:59,840 --> 00:18:01,840
let's look at our construction

439
00:18:01,840 --> 00:18:04,080
uh we first let c be the constant such

440
00:18:04,080 --> 00:18:07,440
that mk kt of x is at most list l of x

441
00:18:07,440 --> 00:18:09,919
plus c for all string x

442
00:18:09,919 --> 00:18:12,559
and as mentioned before kt of x is at

443
00:18:12,559 --> 00:18:15,600
most lengths of x plus of one and here c

444
00:18:15,600 --> 00:18:18,240
is just the o of one

445
00:18:18,240 --> 00:18:19,760
and we define

446
00:18:19,760 --> 00:18:23,120
a function f on inputs pi prime comma l

447
00:18:23,120 --> 00:18:25,600
where pi prime is a and plus c p string

448
00:18:25,600 --> 00:18:27,840
and l is a log n plus b string as

449
00:18:27,840 --> 00:18:28,799
follows

450
00:18:28,799 --> 00:18:31,200
so the first step is let

451
00:18:31,200 --> 00:18:33,919
pi be the first l base of pi prime

452
00:18:33,919 --> 00:18:36,480
so we truncate the machine pi prime to

453
00:18:36,480 --> 00:18:38,640
the first l bits

454
00:18:38,640 --> 00:18:40,240
and then we let's

455
00:18:40,240 --> 00:18:42,480
we basically interpret this pi as a

456
00:18:42,480 --> 00:18:46,160
machine and we let x be the output of pi

457
00:18:46,160 --> 00:18:48,240
and we let t be the running time of the

458
00:18:48,240 --> 00:18:50,000
machine

459
00:18:50,000 --> 00:18:52,480
and finally the function f will simply

460
00:18:52,480 --> 00:18:54,799
output l plus log t

461
00:18:54,799 --> 00:18:57,039
comma x

462
00:18:57,039 --> 00:18:59,200
and to give some intuition

463
00:18:59,200 --> 00:19:01,440
let's assume for simplicity that

464
00:19:01,440 --> 00:19:03,360
we can inverse the function f with

465
00:19:03,360 --> 00:19:05,360
probability one

466
00:19:05,360 --> 00:19:08,000
and then we can easily decide mktp

467
00:19:08,000 --> 00:19:09,280
and how

468
00:19:09,280 --> 00:19:12,799
and input k x comma k which is to check

469
00:19:12,799 --> 00:19:13,760
whether

470
00:19:13,760 --> 00:19:16,480
there exists a k prime smaller than k

471
00:19:16,480 --> 00:19:18,480
such that the inversion succeeds on k

472
00:19:18,480 --> 00:19:20,000
prime comma x

473
00:19:20,000 --> 00:19:22,320
and if if the inversion succeeds then we

474
00:19:22,320 --> 00:19:25,280
know that the existing machine pi

475
00:19:25,280 --> 00:19:29,039
of length l that outputs x within

476
00:19:29,039 --> 00:19:30,480
t steps

477
00:19:30,480 --> 00:19:34,640
such that l plus log t equals k prime

478
00:19:34,640 --> 00:19:35,520
and

479
00:19:35,520 --> 00:19:37,760
we can and we know that we should output

480
00:19:37,760 --> 00:19:40,000
yes on this instance

481
00:19:40,000 --> 00:19:42,480
so therefore this this function seems to

482
00:19:42,480 --> 00:19:45,600
be weekly one way i however the issue

483
00:19:45,600 --> 00:19:48,240
here is that f requires exponential time

484
00:19:48,240 --> 00:19:49,360
to run

485
00:19:49,360 --> 00:19:51,280
as mentioned before it's possible that

486
00:19:51,280 --> 00:19:53,440
the program that witnesses the kt

487
00:19:53,440 --> 00:19:56,720
capacity of x takes exponential time so

488
00:19:56,720 --> 00:19:58,400
normally here we want to compute the

489
00:19:58,400 --> 00:20:01,840
output of pi it may require exponential

490
00:20:01,840 --> 00:20:03,840
time

491
00:20:03,840 --> 00:20:06,480
so the solution here is to cut off the

492
00:20:06,480 --> 00:20:08,960
machine's running time after polynomial

493
00:20:08,960 --> 00:20:11,919
remaining steps so here we let x be the

494
00:20:11,919 --> 00:20:15,440
output of pi after and to the c steps

495
00:20:15,440 --> 00:20:18,159
and if pi does not hot after and to the

496
00:20:18,159 --> 00:20:22,080
c steps with simply output spots

497
00:20:22,080 --> 00:20:24,960
and to see why this solution works

498
00:20:24,960 --> 00:20:28,159
let's first define some notions

499
00:20:28,159 --> 00:20:30,320
we say that the program pi is a kt

500
00:20:30,320 --> 00:20:32,400
weakness for the string x if pi

501
00:20:32,400 --> 00:20:34,480
generates x in two steps while

502
00:20:34,480 --> 00:20:37,120
minimizing the length of pi plus log t

503
00:20:37,120 --> 00:20:39,840
among all other programs

504
00:20:39,840 --> 00:20:40,640
and

505
00:20:40,640 --> 00:20:43,120
our key observation is that for any

506
00:20:43,120 --> 00:20:46,159
epsilon from 0 to 1 except for for an

507
00:20:46,159 --> 00:20:48,480
external fraction of mb string x

508
00:20:48,480 --> 00:20:51,440
x has kt which is pi with running time

509
00:20:51,440 --> 00:20:55,760
at most of one to over epsilon

510
00:20:55,760 --> 00:20:57,039
so

511
00:20:57,039 --> 00:21:00,240
most strings has have a kt weakness that

512
00:21:00,240 --> 00:21:03,280
has a small running time and to see why

513
00:21:03,280 --> 00:21:06,480
this observation helps just pick abs

514
00:21:06,480 --> 00:21:10,000
note to be 1 over n to the c and we we

515
00:21:10,000 --> 00:21:12,400
know that's exact for n 1 over n to the

516
00:21:12,400 --> 00:21:16,400
c fraction of mb string x and x has k t

517
00:21:16,400 --> 00:21:18,880
witness pi with running time at most

518
00:21:18,880 --> 00:21:20,159
antenna c

519
00:21:20,159 --> 00:21:21,760
so therefore we can just cut off the

520
00:21:21,760 --> 00:21:24,880
running machines running time

521
00:21:24,880 --> 00:21:25,919
and

522
00:21:25,919 --> 00:21:28,720
so why this observation is true

523
00:21:28,720 --> 00:21:31,520
let's see how we prove it

524
00:21:31,520 --> 00:21:33,919
recall that for any string x uh we have

525
00:21:33,919 --> 00:21:36,000
kt of x is that both the length of x

526
00:21:36,000 --> 00:21:37,360
plus one

527
00:21:37,360 --> 00:21:40,000
so for any string x with k k t witness

528
00:21:40,000 --> 00:21:43,679
pi that runs at most uh larger than one

529
00:21:43,679 --> 00:21:45,679
of the absolute depths it's satisfied

530
00:21:45,679 --> 00:21:48,960
that the length of pi plus log one over

531
00:21:48,960 --> 00:21:52,240
epsilon is at most kt of x which is at

532
00:21:52,240 --> 00:21:55,280
most length of x times of one

533
00:21:55,280 --> 00:21:58,240
so therefore the length of pi is at most

534
00:21:58,240 --> 00:22:01,360
m plus of one plus log epsilon

535
00:22:01,360 --> 00:22:03,440
and note that epsilon here is something

536
00:22:03,440 --> 00:22:06,080
smaller than one so this concludes that

537
00:22:06,080 --> 00:22:08,400
there are at most epsilon times two to

538
00:22:08,400 --> 00:22:10,159
the n such programs pi

539
00:22:10,159 --> 00:22:13,919
which concludes our observation

540
00:22:13,919 --> 00:22:16,000
and in the paper we will use this

541
00:22:16,000 --> 00:22:18,799
observation to source to show that f is

542
00:22:18,799 --> 00:22:21,039
indeed a week one function

543
00:22:21,039 --> 00:22:22,960
and the proof will be much more

544
00:22:22,960 --> 00:22:25,200
complicated especially when dealing with

545
00:22:25,200 --> 00:22:26,559
the fact that

546
00:22:26,559 --> 00:22:29,280
we can't the inverter only inverse with

547
00:22:29,280 --> 00:22:32,480
probability when y minus one over p of n

548
00:22:32,480 --> 00:22:34,400
instead of one

549
00:22:34,400 --> 00:22:37,120
and but we can leverage from our

550
00:22:37,120 --> 00:22:39,760
previous work lp 20 to

551
00:22:39,760 --> 00:22:43,039
overcome this barrier

552
00:22:43,280 --> 00:22:44,799
so we have seen

553
00:22:44,799 --> 00:22:45,840
the proof

554
00:22:45,840 --> 00:22:48,480
then next let us talk about the proof

555
00:22:48,480 --> 00:22:50,240
for the other reaction

556
00:22:50,240 --> 00:22:52,240
so we assume infinity overwhelm

557
00:22:52,240 --> 00:22:56,080
functions exist then mktp is not inside

558
00:22:56,080 --> 00:22:57,840
here at vpp

559
00:22:57,840 --> 00:23:01,280
so our higher level idea is as follows

560
00:23:01,280 --> 00:23:03,840
first we use the value function f to

561
00:23:03,840 --> 00:23:06,159
construct a so-called entropy

562
00:23:06,159 --> 00:23:09,280
conditionally entropy preserving prg

563
00:23:09,280 --> 00:23:12,880
and a account ap prg is a prg that has

564
00:23:12,880 --> 00:23:15,280
high channel entropy condition on sound

565
00:23:15,280 --> 00:23:17,120
events

566
00:23:17,120 --> 00:23:20,640
and we can use the mktp heuristic edge

567
00:23:20,640 --> 00:23:23,120
to distinguish the output of prg from

568
00:23:23,120 --> 00:23:25,760
random which is a contradiction

569
00:23:25,760 --> 00:23:27,840
so on uniform string we know that

570
00:23:27,840 --> 00:23:29,520
uniform string has high commodore

571
00:23:29,520 --> 00:23:30,720
capacity

572
00:23:30,720 --> 00:23:33,360
and on pseudo-random string we know that

573
00:23:33,360 --> 00:23:35,360
pseudo-random strings have small

574
00:23:35,360 --> 00:23:38,400
commonwealth capacity in the sense that

575
00:23:38,400 --> 00:23:40,720
to output the string y we only need to

576
00:23:40,720 --> 00:23:43,840
hardwire the seeds of length n and the

577
00:23:43,840 --> 00:23:47,520
program of of prg which causes constant

578
00:23:47,520 --> 00:23:48,480
bits

579
00:23:48,480 --> 00:23:50,159
and the running time of prg is

580
00:23:50,159 --> 00:23:52,000
polynomial and therefore

581
00:23:52,000 --> 00:23:54,880
the kt capacity of y is at most n plus

582
00:23:54,880 --> 00:23:57,520
of log n

583
00:23:57,760 --> 00:24:00,320
and we remark here that g has to have

584
00:24:00,320 --> 00:24:03,039
high entropy to ensure that the oracle

585
00:24:03,039 --> 00:24:06,559
works on pseudorandom strings

586
00:24:07,440 --> 00:24:09,520
so we have seen the proof of thing one

587
00:24:09,520 --> 00:24:12,720
and let's move on to proof for them two

588
00:24:12,720 --> 00:24:15,440
and we want to show that x is not equal

589
00:24:15,440 --> 00:24:18,799
to bpp if and only if mktp is not inside

590
00:24:18,799 --> 00:24:20,960
lgbt

591
00:24:20,960 --> 00:24:24,080
and the trivial direction i is easy to

592
00:24:24,080 --> 00:24:26,720
see now let us focus on the non-trivial

593
00:24:26,720 --> 00:24:27,840
direction

594
00:24:27,840 --> 00:24:30,320
which says that x is not equal to ppp

595
00:24:30,320 --> 00:24:33,760
implies mktp is not in average vp

596
00:24:33,760 --> 00:24:36,000
and this is a non-struct constructive

597
00:24:36,000 --> 00:24:37,520
proof

598
00:24:37,520 --> 00:24:41,760
and our proof of outline is as a follow

599
00:24:41,760 --> 00:24:43,279
so we first use

600
00:24:43,279 --> 00:24:45,840
the results in ampica in piccolo and the

601
00:24:45,840 --> 00:24:49,440
windows and 98 to show that if x is not

602
00:24:49,440 --> 00:24:52,080
equal to bpp then there exists an

603
00:24:52,080 --> 00:24:55,360
inefficient infinity open prgg

604
00:24:55,360 --> 00:24:58,320
and then we prove that if an efficient

605
00:24:58,320 --> 00:25:01,600
io prgg exists then mktp is not in

606
00:25:01,600 --> 00:25:03,360
average bpp

607
00:25:03,360 --> 00:25:06,000
so the way we prove this lemma 4 is

608
00:25:06,000 --> 00:25:08,559
similar to how this this second

609
00:25:08,559 --> 00:25:11,760
direction of the serial one was proven

610
00:25:11,760 --> 00:25:14,640
proof proved but since this prg is not

611
00:25:14,640 --> 00:25:17,520
entry preserving we can only get the

612
00:25:17,520 --> 00:25:21,200
arrowless average case hardness

613
00:25:22,400 --> 00:25:23,520
so we have

614
00:25:23,520 --> 00:25:26,640
so in conclusion today we have seen that

615
00:25:26,640 --> 00:25:28,880
the existence of infinity overwhelmed

616
00:25:28,880 --> 00:25:33,679
functions is equivalent to mktp being a

617
00:25:33,679 --> 00:25:35,360
harder on average with respect to

618
00:25:35,360 --> 00:25:38,799
two-sided error heuristics and x is not

619
00:25:38,799 --> 00:25:41,600
equal to bpp it's equivalent to mktp

620
00:25:41,600 --> 00:25:44,000
being average case hardness with with

621
00:25:44,000 --> 00:25:46,720
respect to errorless heuristic

622
00:25:46,720 --> 00:25:47,919
so

623
00:25:47,919 --> 00:25:50,559
the only gap of spacing for basing

624
00:25:50,559 --> 00:25:52,240
infinity also when functions and

625
00:25:52,240 --> 00:25:54,400
actually is not equal to ppp is the

626
00:25:54,400 --> 00:25:57,520
seemingly minor technical problem

627
00:25:57,520 --> 00:25:59,919
between two standard notions of average

628
00:25:59,919 --> 00:26:03,360
case hardness with respect to this mktp

629
00:26:03,360 --> 00:26:05,600
problem which has been studied since the

630
00:26:05,600 --> 00:26:07,600
70s

631
00:26:07,600 --> 00:26:10,480
however proving these implications

632
00:26:10,480 --> 00:26:13,520
would show that mp is not equal to p

633
00:26:13,520 --> 00:26:16,000
and this gives us a new algorithmic

634
00:26:16,000 --> 00:26:18,000
approach to us proving mp is not equal

635
00:26:18,000 --> 00:26:18,880
to p

636
00:26:18,880 --> 00:26:21,600
so we just need to solve mktp

637
00:26:21,600 --> 00:26:24,400
errorlessly on average having the access

638
00:26:24,400 --> 00:26:27,679
to a two-seated air heuristic

639
00:26:27,679 --> 00:26:32,200
and thank you for your listen

