1
00:00:05,240 --> 00:00:08,580
thank you for the introduction so block

2
00:00:08,580 --> 00:00:10,200
ciphers are building block for many

3
00:00:10,200 --> 00:00:12,150
cryptography constructions such as hash

4
00:00:12,150 --> 00:00:15,560
functions encryption schemes Macs etc

5
00:00:15,560 --> 00:00:18,960
block ciphers take an input a key K and

6
00:00:18,960 --> 00:00:21,510
another input X and outputs a an n bit

7
00:00:21,510 --> 00:00:24,480
output Y block ciphers are keyed

8
00:00:24,480 --> 00:00:27,390
permutation so on a key K a block cipher

9
00:00:27,390 --> 00:00:30,480
would induce a permutation so throughout

10
00:00:30,480 --> 00:00:32,850
this talk I will be considering n bit

11
00:00:32,850 --> 00:00:35,940
keys and bit inputs and outputs there

12
00:00:35,940 --> 00:00:37,560
are two popular approaches to designing

13
00:00:37,560 --> 00:00:39,930
block ciphers one is the faisal network

14
00:00:39,930 --> 00:00:41,820
the other which is the focus of the

15
00:00:41,820 --> 00:00:45,600
stock is key alternating ciphers AES

16
00:00:45,600 --> 00:00:46,950
which is the current block cipher

17
00:00:46,950 --> 00:00:49,739
standard is a key alternating cypher key

18
00:00:49,739 --> 00:00:51,570
alternating ciphers consist of repeated

19
00:00:51,570 --> 00:00:53,070
applications of public round

20
00:00:53,070 --> 00:00:55,260
permutations and I will discuss them in

21
00:00:55,260 --> 00:00:58,530
more detail in a bit so consider this

22
00:00:58,530 --> 00:01:00,360
fire on key alternating cipher that is

23
00:01:00,360 --> 00:01:03,180
shown it is an iterated structure that

24
00:01:03,180 --> 00:01:07,259
takes in a key K a master key K and from

25
00:01:07,259 --> 00:01:09,570
that we can derive round Keys K 0

26
00:01:09,570 --> 00:01:12,479
through K 5 as shown in the figure and

27
00:01:12,479 --> 00:01:16,590
then on an input X we will exert each of

28
00:01:16,590 --> 00:01:18,299
these round keys in a particular round

29
00:01:18,299 --> 00:01:21,479
and then apply a round permutation that

30
00:01:21,479 --> 00:01:23,700
takes in an N bit input and produces an

31
00:01:23,700 --> 00:01:28,590
n bit output more specifically for an

32
00:01:28,590 --> 00:01:33,960
input X compute X 1 as X XOR K 0 K 0 is

33
00:01:33,960 --> 00:01:36,600
the 0th round key and then in the first

34
00:01:36,600 --> 00:01:39,720
round we compute the output of the round

35
00:01:39,720 --> 00:01:45,060
X 2 as P 1 of X 1 XOR with K 1 and so on

36
00:01:45,060 --> 00:01:47,520
and so forth up to round 5 and the

37
00:01:47,520 --> 00:01:49,110
output of this fire round key

38
00:01:49,110 --> 00:01:51,509
alternating cipher is going to be X 6

39
00:01:51,509 --> 00:01:53,960
the output of the fifth round

40
00:01:53,960 --> 00:01:56,939
so in this stock we will consider K

41
00:01:56,939 --> 00:01:58,619
alternating ciphers with trivially

42
00:01:58,619 --> 00:02:00,930
showed you that is all the round keys

43
00:02:00,930 --> 00:02:03,570
are going to be identical so just K and

44
00:02:03,570 --> 00:02:06,150
we will also consider the round

45
00:02:06,150 --> 00:02:08,639
permutations P 1 through P are to be R

46
00:02:08,639 --> 00:02:10,560
and uniform random permutations

47
00:02:10,560 --> 00:02:13,530
independent also independent

48
00:02:13,530 --> 00:02:16,680
permutations so in particular this is

49
00:02:16,680 --> 00:02:17,650
known as the it

50
00:02:17,650 --> 00:02:19,989
Monsoor construction which i VLK showed

51
00:02:19,989 --> 00:02:22,360
you and this is because you can think of

52
00:02:22,360 --> 00:02:24,849
this as just an around version of the

53
00:02:24,849 --> 00:02:27,010
event mansoor cipher which is shown here

54
00:02:27,010 --> 00:02:30,610
for a trivial key show you so the

55
00:02:30,610 --> 00:02:32,049
security of block ciphers is

56
00:02:32,049 --> 00:02:33,519
traditionally considered under the

57
00:02:33,519 --> 00:02:35,430
notion of indistinguishability and

58
00:02:35,430 --> 00:02:37,360
indistinguishability in the ideal world

59
00:02:37,360 --> 00:02:39,640
the distinguisher d-- interacts with a

60
00:02:39,640 --> 00:02:42,190
random permutation P for which it can

61
00:02:42,190 --> 00:02:44,409
ask both forward and backward queries

62
00:02:44,409 --> 00:02:46,540
although I don't depict that explicitly

63
00:02:46,540 --> 00:02:48,879
in the picture and in the real world the

64
00:02:48,879 --> 00:02:50,680
distinguisher D interacts with a block

65
00:02:50,680 --> 00:02:53,349
cipher keyed with a fixed key K that is

66
00:02:53,349 --> 00:02:57,099
uniformly chosen from its key space so

67
00:02:57,099 --> 00:02:59,079
the security of the I am the iterated 11

68
00:02:59,079 --> 00:03:00,579
months of construction can also be

69
00:03:00,579 --> 00:03:01,540
studied under the notion of

70
00:03:01,540 --> 00:03:03,730
indistinguishability again here the

71
00:03:03,730 --> 00:03:05,349
distinguish Rd in the ideal world

72
00:03:05,349 --> 00:03:07,120
interacts with the random permutation P

73
00:03:07,120 --> 00:03:10,060
and in the real world interacts with the

74
00:03:10,060 --> 00:03:12,670
iterative in munzo construction under a

75
00:03:12,670 --> 00:03:16,269
fixed key K since the round permutations

76
00:03:16,269 --> 00:03:17,470
of the territorial months of

77
00:03:17,470 --> 00:03:20,379
construction is public we can also

78
00:03:20,379 --> 00:03:22,180
consider that the distinguish Rd has

79
00:03:22,180 --> 00:03:24,130
access to these public round

80
00:03:24,130 --> 00:03:26,290
permutations that are denoted as P 1

81
00:03:26,290 --> 00:03:31,419
through P R however one can consider the

82
00:03:31,419 --> 00:03:33,040
security of block ciphers under a

83
00:03:33,040 --> 00:03:35,500
stronger notion a notion called in

84
00:03:35,500 --> 00:03:37,030
differentiability proposed by Mauro

85
00:03:37,030 --> 00:03:39,430
Rainer and Holland Stein in this notion

86
00:03:39,430 --> 00:03:41,709
one can ask whether an around block

87
00:03:41,709 --> 00:03:43,959
cipher behaves as an ideal cipher and

88
00:03:43,959 --> 00:03:45,609
are appropriate assumptions on the

89
00:03:45,609 --> 00:03:47,680
underlying primitives so what is an

90
00:03:47,680 --> 00:03:50,379
ideal cipher an ideal ciphers or block

91
00:03:50,379 --> 00:03:53,019
ciphers are said for each key K the

92
00:03:53,019 --> 00:03:55,180
block cipher under key K induces a

93
00:03:55,180 --> 00:03:57,549
uniform random permutation so this is an

94
00:03:57,549 --> 00:03:59,739
idealized notion of a block cipher and

95
00:03:59,739 --> 00:04:03,040
why is this useful block ciphers can be

96
00:04:03,040 --> 00:04:04,389
used in constructions where the

97
00:04:04,389 --> 00:04:06,099
distinguisher can have access to the key

98
00:04:06,099 --> 00:04:08,769
K for example imagine a block cipher

99
00:04:08,769 --> 00:04:10,930
based hash function here the

100
00:04:10,930 --> 00:04:12,639
distinguisher can actually influence a

101
00:04:12,639 --> 00:04:15,069
choice of the key K so for such notions

102
00:04:15,069 --> 00:04:17,829
it is useful to consider whether a block

103
00:04:17,829 --> 00:04:19,690
cipher can behave as an ideal cipher

104
00:04:19,690 --> 00:04:22,510
hundred appropriate assumptions so let's

105
00:04:22,510 --> 00:04:24,430
look at the definition of in

106
00:04:24,430 --> 00:04:25,830
differentiability

107
00:04:25,830 --> 00:04:28,150
particularly in the context of iterated

108
00:04:28,150 --> 00:04:30,400
even once or construction so in the rest

109
00:04:30,400 --> 00:04:31,540
of the talk when I

110
00:04:31,540 --> 00:04:33,550
I am I mean iterative 11 months or

111
00:04:33,550 --> 00:04:35,050
construction of the trivial case to do

112
00:04:35,050 --> 00:04:37,260
that is all the round keys are identical

113
00:04:37,260 --> 00:04:39,940
so in in in differentiability in the

114
00:04:39,940 --> 00:04:41,580
real world the distinguisher d--

115
00:04:41,580 --> 00:04:43,810
interacts with the iterative elements of

116
00:04:43,810 --> 00:04:46,840
construction the I am and the round

117
00:04:46,840 --> 00:04:49,090
permutations P 1 through P R that I'll

118
00:04:49,090 --> 00:04:52,420
collectively denote by P and in the

119
00:04:52,420 --> 00:04:53,950
ideal world the distinguisher D

120
00:04:53,950 --> 00:04:57,070
interacts with an ideal cipher and an

121
00:04:57,070 --> 00:04:59,110
algorithm s known as a simulator that

122
00:04:59,110 --> 00:05:01,000
simulates these round permutations with

123
00:05:01,000 --> 00:05:04,180
access to the ideal cipher so if the

124
00:05:04,180 --> 00:05:06,850
distinguish Rd cannot tell with high

125
00:05:06,850 --> 00:05:08,680
probability which world it is in whether

126
00:05:08,680 --> 00:05:10,270
it's in the real world or in the ideal

127
00:05:10,270 --> 00:05:13,840
world then we say that the I am

128
00:05:13,840 --> 00:05:16,320
construction is in differentiable from

129
00:05:16,320 --> 00:05:19,240
from an ideal cipher in addition it is

130
00:05:19,240 --> 00:05:20,860
important to note that in order to show

131
00:05:20,860 --> 00:05:23,050
this we need to show an efficient

132
00:05:23,050 --> 00:05:26,530
simulator s so the I am construction is

133
00:05:26,530 --> 00:05:28,540
in differentiable from an ideal cipher I

134
00:05:28,540 --> 00:05:31,840
see if an efficient simulator s exists

135
00:05:31,840 --> 00:05:34,420
such that no efficient distinguisher can

136
00:05:34,420 --> 00:05:36,010
distinguish between real and ideal with

137
00:05:36,010 --> 00:05:38,380
high probability not here that the

138
00:05:38,380 --> 00:05:39,820
distinguisher D is information-theoretic

139
00:05:39,820 --> 00:05:42,040
in particular this means that it is

140
00:05:42,040 --> 00:05:43,960
computationally unbounded but we

141
00:05:43,960 --> 00:05:45,340
restrict the number of queries so the

142
00:05:45,340 --> 00:05:47,260
distinguished ID can make to its Oracles

143
00:05:47,260 --> 00:05:49,690
I would also like to emphasize the

144
00:05:49,690 --> 00:05:51,580
distinguisher D can make both forward

145
00:05:51,580 --> 00:05:53,620
and inverse queries to its Oracles to

146
00:05:53,620 --> 00:05:55,690
the ideal cipher and to the wrong

147
00:05:55,690 --> 00:06:00,670
permutations right before I mention how

148
00:06:00,670 --> 00:06:03,490
fire on I traded elements of ciphers in

149
00:06:03,490 --> 00:06:06,190
differentiable from an ideal cipher let

150
00:06:06,190 --> 00:06:08,650
me mention prior work so it is known

151
00:06:08,650 --> 00:06:11,020
that 12 rounds of iterative elements or

152
00:06:11,020 --> 00:06:13,180
construction which a blk shadow is

153
00:06:13,180 --> 00:06:15,760
sufficient to build an ideal cipher this

154
00:06:15,760 --> 00:06:18,280
was worked by lamp and Sauron they also

155
00:06:18,280 --> 00:06:19,780
showed that three rounds are

156
00:06:19,780 --> 00:06:22,810
insufficient in that scenario so in this

157
00:06:22,810 --> 00:06:24,580
work we show that five rounds are

158
00:06:24,580 --> 00:06:26,680
necessary and sufficient in order to do

159
00:06:26,680 --> 00:06:30,400
this we show a fire on proof we show

160
00:06:30,400 --> 00:06:32,680
proof for the fire on a trader elements

161
00:06:32,680 --> 00:06:34,240
or constructions in differentiability

162
00:06:34,240 --> 00:06:36,760
and we show an attack on the four round

163
00:06:36,760 --> 00:06:39,250
construction so in this talk I will not

164
00:06:39,250 --> 00:06:40,720
be able to get into details on the

165
00:06:40,720 --> 00:06:44,050
attack but I would like to mention that

166
00:06:44,050 --> 00:06:45,279
our attack

167
00:06:45,279 --> 00:06:48,519
from previous attacks in that we the

168
00:06:48,519 --> 00:06:51,039
Oracles are not accessed in sequence in

169
00:06:51,039 --> 00:06:54,789
our attack also the in differentiability

170
00:06:54,789 --> 00:06:57,189
of IEM has been considered in another

171
00:06:57,189 --> 00:06:59,679
setting in particular in the idealized

172
00:06:59,679 --> 00:07:02,169
key derivation setting so what we mean

173
00:07:02,169 --> 00:07:05,589
here is that the round keys are derived

174
00:07:05,589 --> 00:07:07,959
through a cryptographic parameter which

175
00:07:07,959 --> 00:07:09,819
is modeled as an ideal primitive and

176
00:07:09,819 --> 00:07:11,559
hence this is known as idealized key

177
00:07:11,559 --> 00:07:13,989
derivation so in that setting it is

178
00:07:13,989 --> 00:07:15,789
known that firearms are sufficient to

179
00:07:15,789 --> 00:07:18,669
build an ideal cipher from the I am

180
00:07:18,669 --> 00:07:20,589
construction this was worked by

181
00:07:20,589 --> 00:07:23,379
andreyeva Bob Bernardo Desmond ink and

182
00:07:23,379 --> 00:07:26,860
steinberger and in recent work by Guin

183
00:07:26,860 --> 00:07:29,079
Lin it is shown that three rounds are in

184
00:07:29,079 --> 00:07:31,239
fact necessary and sufficient to build

185
00:07:31,239 --> 00:07:33,879
an ideal cipher from the I am

186
00:07:33,879 --> 00:07:36,119
construction with idealistic iteration

187
00:07:36,119 --> 00:07:40,209
right so let's look at the proof of in

188
00:07:40,209 --> 00:07:41,889
differentiability for the fire round

189
00:07:41,889 --> 00:07:43,479
I am construction with trivial key

190
00:07:43,479 --> 00:07:46,089
showed you so recall there is a

191
00:07:46,089 --> 00:07:48,369
distinguish Rd that in the ideal world

192
00:07:48,369 --> 00:07:50,739
will interact with the ideal cipher IC

193
00:07:50,739 --> 00:07:53,589
and an algorithm s that simulates the

194
00:07:53,589 --> 00:07:55,719
round permutations with access to the IC

195
00:07:55,719 --> 00:07:58,179
and in the real world D interacts with

196
00:07:58,179 --> 00:07:59,619
the I am construction of the trivial

197
00:07:59,619 --> 00:08:01,269
case ideal and the underlying round

198
00:08:01,269 --> 00:08:03,669
permutations and in order to show in

199
00:08:03,669 --> 00:08:05,739
differentiability of the fire on I am

200
00:08:05,739 --> 00:08:08,199
from an ideal cipher it is sufficient to

201
00:08:08,199 --> 00:08:10,929
show an efficient simulator s such that

202
00:08:10,929 --> 00:08:12,610
no distinguisher D that is

203
00:08:12,610 --> 00:08:14,589
computationally unbounded but can make

204
00:08:14,589 --> 00:08:16,539
limited number of queries to its Oracles

205
00:08:16,539 --> 00:08:18,249
can distinguish between the real and

206
00:08:18,249 --> 00:08:21,729
ideal worlds with high probability right

207
00:08:21,729 --> 00:08:24,369
in order to see how to build a simulator

208
00:08:24,369 --> 00:08:26,829
s for such a setting let's start with a

209
00:08:26,829 --> 00:08:29,259
naive simulator strategy so the role of

210
00:08:29,259 --> 00:08:31,569
the simulator is to simulate these LAN

211
00:08:31,569 --> 00:08:34,000
permutations so let's consider naive

212
00:08:34,000 --> 00:08:37,479
simulator that on query P I of X I so by

213
00:08:37,479 --> 00:08:40,000
P I of X I I mean that the ith row and

214
00:08:40,000 --> 00:08:42,729
permutation P I is queried on an N bit

215
00:08:42,729 --> 00:08:45,670
input X I say this naive simulator just

216
00:08:45,670 --> 00:08:48,009
returns a uniform n bit value as its

217
00:08:48,009 --> 00:08:50,680
output so that's depicted in this

218
00:08:50,680 --> 00:08:53,139
picture the distinguish Rd query

219
00:08:53,139 --> 00:08:56,350
simulator S on P I of X I the simulator

220
00:08:56,350 --> 00:08:57,680
chooses a uniform

221
00:08:57,680 --> 00:09:02,000
value and return status PA of XY so

222
00:09:02,000 --> 00:09:03,470
let's consider a distinguished a

223
00:09:03,470 --> 00:09:06,020
strategy against this naive simulator so

224
00:09:06,020 --> 00:09:07,399
what the simulator is doing is just

225
00:09:07,399 --> 00:09:09,230
returning a uniform and bit value on

226
00:09:09,230 --> 00:09:12,589
queries it has not seen before so again

227
00:09:12,589 --> 00:09:14,390
in the real world the distinguisher d--

228
00:09:14,390 --> 00:09:16,940
interacts with the IEM and the

229
00:09:16,940 --> 00:09:19,130
underlying ground permutations and in

230
00:09:19,130 --> 00:09:21,080
the ideal world interacts with the ideal

231
00:09:21,080 --> 00:09:24,230
cipher and this naive simulator s that

232
00:09:24,230 --> 00:09:25,850
is simulating the round permutations

233
00:09:25,850 --> 00:09:28,640
however all the distinguisher d can see

234
00:09:28,640 --> 00:09:30,320
is that it's interacting with the green

235
00:09:30,320 --> 00:09:32,300
box and a blue box where it doesn't

236
00:09:32,300 --> 00:09:34,310
actually know whether the green box and

237
00:09:34,310 --> 00:09:36,410
the blue box are the IAM and the round

238
00:09:36,410 --> 00:09:38,930
permutations are the ideal cipher and

239
00:09:38,930 --> 00:09:41,270
this naive simulator so let's consider

240
00:09:41,270 --> 00:09:42,920
the following distinguishing strategy

241
00:09:42,920 --> 00:09:45,709
the distinguished OD picks an arbitrary

242
00:09:45,709 --> 00:09:48,470
in bit key K and an arbitrary input

243
00:09:48,470 --> 00:09:52,250
input X queries the green box on K comma

244
00:09:52,250 --> 00:09:56,709
X and obtain some input some output Y

245
00:09:56,709 --> 00:09:59,209
then with the distinguisher D does this

246
00:09:59,209 --> 00:10:01,640
essentially runs the iterated event

247
00:10:01,640 --> 00:10:04,070
month so constructions computation on

248
00:10:04,070 --> 00:10:07,160
this key K comma X using the outputs

249
00:10:07,160 --> 00:10:09,830
provided by the blue box in particular

250
00:10:09,830 --> 00:10:12,410
the distinguisher D first computes X 1

251
00:10:12,410 --> 00:10:16,010
as X XOR K then for I equals 1 to 5

252
00:10:16,010 --> 00:10:18,470
queries the blue box on P I of X I

253
00:10:18,470 --> 00:10:22,040
obtain some output PA of X I computes

254
00:10:22,040 --> 00:10:27,200
the IEMs i drowned output using this

255
00:10:27,200 --> 00:10:30,080
equation shown here x i plus 1 equals

256
00:10:30,080 --> 00:10:33,020
pif x IX okay and so on and so forth

257
00:10:33,020 --> 00:10:36,770
till till the fire rounds then with the

258
00:10:36,770 --> 00:10:39,950
simcha does is a checks if this x 6 that

259
00:10:39,950 --> 00:10:42,260
it obtained by performing the IEM

260
00:10:42,260 --> 00:10:44,630
computation using the blue box matches

261
00:10:44,630 --> 00:10:47,089
the output of the green box matches why

262
00:10:47,089 --> 00:10:50,360
it checks if X 6 equals y so what's

263
00:10:50,360 --> 00:10:51,920
going to happen is that in the real

264
00:10:51,920 --> 00:10:53,480
world when the distinguisher D is

265
00:10:53,480 --> 00:10:55,310
interacting with the I am construction

266
00:10:55,310 --> 00:10:57,320
and its underlying round permutations

267
00:10:57,320 --> 00:11:00,050
this is going to exactly match because

268
00:11:00,050 --> 00:11:02,350
that's how the I am computation even

269
00:11:02,350 --> 00:11:04,790
construction even proceeds with its

270
00:11:04,790 --> 00:11:07,400
computation however in the ideal world

271
00:11:07,400 --> 00:11:09,350
when the distinguisher D is interacting

272
00:11:09,350 --> 00:11:10,880
with the ideal cipher

273
00:11:10,880 --> 00:11:12,650
and it's naive simulator s that just

274
00:11:12,650 --> 00:11:15,530
returns uniform n-bit outputs on its

275
00:11:15,530 --> 00:11:18,140
queries this is not going to hold the

276
00:11:18,140 --> 00:11:19,460
equation is not going to hold with high

277
00:11:19,460 --> 00:11:22,100
probability so this shows a

278
00:11:22,100 --> 00:11:23,720
distinguishing attack against this naive

279
00:11:23,720 --> 00:11:26,690
simulator so what can the simulator do

280
00:11:26,690 --> 00:11:29,030
what can a simulator do to fix this

281
00:11:29,030 --> 00:11:31,880
particular distinguishing strategy the

282
00:11:31,880 --> 00:11:33,380
simulator can do the following the

283
00:11:33,380 --> 00:11:36,200
simulator can try to make the X 6 that

284
00:11:36,200 --> 00:11:38,600
the distinguisher D obtained by

285
00:11:38,600 --> 00:11:40,850
performing the I am computation on K

286
00:11:40,850 --> 00:11:44,060
comma X match the ideal ciphers output

287
00:11:44,060 --> 00:11:46,880
on K comma X how can the simulator do

288
00:11:46,880 --> 00:11:48,860
that notice that the simulator has

289
00:11:48,860 --> 00:11:52,100
access to access to I see the ideal

290
00:11:52,100 --> 00:11:54,800
cipher in this setting so the simulator

291
00:11:54,800 --> 00:11:57,200
can query the ideal cipher I see on this

292
00:11:57,200 --> 00:12:00,860
input K comma X learn the output Y the

293
00:12:00,860 --> 00:12:02,600
ideal cipher would have returned and

294
00:12:02,600 --> 00:12:04,580
then somehow choose the round

295
00:12:04,580 --> 00:12:07,100
permutations outputs that it returns to

296
00:12:07,100 --> 00:12:08,990
the distinguisher such that the

297
00:12:08,990 --> 00:12:10,100
calculation performed by the

298
00:12:10,100 --> 00:12:13,130
distinguisher would lead to X 6 being

299
00:12:13,130 --> 00:12:15,710
equal to Y however note that the

300
00:12:15,710 --> 00:12:17,720
simulator does not have does not know

301
00:12:17,720 --> 00:12:20,300
what K comma X's in particular the

302
00:12:20,300 --> 00:12:22,730
simulator does not get to see the

303
00:12:22,730 --> 00:12:24,470
interactions between a distinguisher and

304
00:12:24,470 --> 00:12:27,410
the ideal cipher so how can a simulator

305
00:12:27,410 --> 00:12:29,780
learn K comma X if the simulator can

306
00:12:29,780 --> 00:12:32,990
learn K comma X maybe as I mentioned it

307
00:12:32,990 --> 00:12:35,510
can query the ideal cipher obtain Y and

308
00:12:35,510 --> 00:12:38,000
choose its round permutation output such

309
00:12:38,000 --> 00:12:39,620
that the distinguishing strategy does

310
00:12:39,620 --> 00:12:41,870
not work anymore so how can I simulate a

311
00:12:41,870 --> 00:12:44,450
LAN K comma X in order to see how let's

312
00:12:44,450 --> 00:12:46,990
sort of unpack the distinguishing step

313
00:12:46,990 --> 00:12:50,000
so this is distinguished of first pick

314
00:12:50,000 --> 00:12:53,540
an arbitrary key K input X queried I see

315
00:12:53,540 --> 00:12:57,050
on K comma X obtain Y then it computed

316
00:12:57,050 --> 00:13:00,560
x1 equals X XOR K and then query the

317
00:13:00,560 --> 00:13:04,700
simulator on p1 of x1 so the bubble on

318
00:13:04,700 --> 00:13:07,790
the on the left just indicates that the

319
00:13:07,790 --> 00:13:09,710
simulator notes that has been queried on

320
00:13:09,710 --> 00:13:14,210
p1 of x1 it still returns say picks a

321
00:13:14,210 --> 00:13:17,240
uniform n bit value y1 a science P 1 of

322
00:13:17,240 --> 00:13:19,100
X 1s y1 and returns star to the

323
00:13:19,100 --> 00:13:22,160
distinguisher the distinguisher then

324
00:13:22,160 --> 00:13:24,089
computes X 2 s P 1 of

325
00:13:24,089 --> 00:13:26,970
x1x all K and queries simulator on P to

326
00:13:26,970 --> 00:13:29,879
affix to the simulator against Easter it

327
00:13:29,879 --> 00:13:31,019
has been queried on the round

328
00:13:31,019 --> 00:13:34,139
permutation P to on in products to again

329
00:13:34,139 --> 00:13:37,110
chooses a uniform in bit value Y to as

330
00:13:37,110 --> 00:13:39,870
its output a science P 2 of X 2 as Y 2

331
00:13:39,870 --> 00:13:42,800
and returns that to the distinguisher

332
00:13:42,800 --> 00:13:47,160
then the distinguisher computes X 3 as P

333
00:13:47,160 --> 00:13:49,709
2 of X 2 XOR K and then queries is

334
00:13:49,709 --> 00:13:53,100
simulated on p3 of X 3 at this point say

335
00:13:53,100 --> 00:13:55,589
the simulator stops it does not actually

336
00:13:55,589 --> 00:13:58,499
pick a uniform in bit value and at this

337
00:13:58,499 --> 00:14:01,439
point of simulator checks if X 1 X 2 and

338
00:14:01,439 --> 00:14:04,680
X 3 can be intermediate values of an IEM

339
00:14:04,680 --> 00:14:08,189
computation so how can the simulator

340
00:14:08,189 --> 00:14:09,720
check if these can be intermediate

341
00:14:09,720 --> 00:14:13,499
values in particular round function run

342
00:14:13,499 --> 00:14:16,649
around output of the I am construction

343
00:14:16,649 --> 00:14:19,620
the simulator can do that by checking if

344
00:14:19,620 --> 00:14:25,459
Y 1 which was p1 of X 1 X or X 2 equals

345
00:14:25,459 --> 00:14:29,550
y 2 which is P 2 of X 2 XOR X 3 this is

346
00:14:29,550 --> 00:14:33,300
going to exactly hold because this comes

347
00:14:33,300 --> 00:14:35,699
from this equation and these two are

348
00:14:35,699 --> 00:14:37,679
going to match the value K the

349
00:14:37,679 --> 00:14:41,189
distinguisher de used to compute the

350
00:14:41,189 --> 00:14:43,939
output of the of the eighth round

351
00:14:43,939 --> 00:14:47,759
so by this manner the the simulator can

352
00:14:47,759 --> 00:14:49,589
check if X 1 through X 3 our

353
00:14:49,589 --> 00:14:51,089
intermediate values of an I am

354
00:14:51,089 --> 00:14:53,610
computation this part of the process is

355
00:14:53,610 --> 00:14:57,360
known as partial chain detection so now

356
00:14:57,360 --> 00:14:58,889
that the simulator has detected this

357
00:14:58,889 --> 00:15:03,089
partial chain on a key K sorry partial

358
00:15:03,089 --> 00:15:06,059
chain comprising X 1 through X 3 what

359
00:15:06,059 --> 00:15:08,339
the simulator can do is now compute what

360
00:15:08,339 --> 00:15:11,490
this K is the simulator can set K to be

361
00:15:11,490 --> 00:15:15,839
oops to be P 1 of X 1 X or X 2 notice

362
00:15:15,839 --> 00:15:17,220
that the simulator knows all these

363
00:15:17,220 --> 00:15:19,230
values either because it has been

364
00:15:19,230 --> 00:15:21,029
queried on those values or because it

365
00:15:21,029 --> 00:15:24,529
actually said those values and then said

366
00:15:24,529 --> 00:15:29,189
K as this as this value and then set X

367
00:15:29,189 --> 00:15:33,509
to be X 1 XOR K now the simulator has

368
00:15:33,509 --> 00:15:35,639
actually learned K comma X the

369
00:15:35,639 --> 00:15:37,090
distinguish are used

370
00:15:37,090 --> 00:15:39,700
so what the simulator can now do is to

371
00:15:39,700 --> 00:15:42,280
take the change starting at X with key K

372
00:15:42,280 --> 00:15:45,270
as I mentioned query the ideal cipher on

373
00:15:45,270 --> 00:15:49,270
K comma X learn why and somehow choose

374
00:15:49,270 --> 00:15:51,730
the round permutation outputs at P I of

375
00:15:51,730 --> 00:15:56,620
X I leads to the distinguishes

376
00:15:56,620 --> 00:15:59,680
computation of the I am on K comma X

377
00:15:59,680 --> 00:16:02,140
matching the ideal ciphers output on K

378
00:16:02,140 --> 00:16:05,320
comma X so let me briefly mention how

379
00:16:05,320 --> 00:16:07,720
the simulator can choose SPI of X I such

380
00:16:07,720 --> 00:16:11,470
that the equation holds so again at this

381
00:16:11,470 --> 00:16:13,540
point the distinguish Rd has query the

382
00:16:13,540 --> 00:16:17,230
simulator on p3 of X 3 the simulator has

383
00:16:17,230 --> 00:16:19,510
not yet returned the value of p3 of X 3

384
00:16:19,510 --> 00:16:22,090
say the simulator still chooses a

385
00:16:22,090 --> 00:16:24,610
uniform in bit value y 3 as its output

386
00:16:24,610 --> 00:16:26,380
but the son returned this is a

387
00:16:26,380 --> 00:16:29,380
distinguisher instead it holds it within

388
00:16:29,380 --> 00:16:32,470
itself and then performs the I am

389
00:16:32,470 --> 00:16:35,260
computation to compute X 4 and stops

390
00:16:35,260 --> 00:16:39,610
there and now it sets X x equals y on

391
00:16:39,610 --> 00:16:43,480
its own compute V Phi equals x 6 x RK

392
00:16:43,480 --> 00:16:46,500
just by rearranging this equation here

393
00:16:46,500 --> 00:16:50,440
joseph a uniform n bit value x phi as

394
00:16:50,440 --> 00:16:53,790
its output for p phi inverse of y phi

395
00:16:53,790 --> 00:16:57,520
and stops again at that point notice

396
00:16:57,520 --> 00:17:01,030
that at this point in the chain every

397
00:17:01,030 --> 00:17:04,690
value at P 1 P 2 P 3 and P Phi have been

398
00:17:04,690 --> 00:17:07,359
set apart from P for what the simulator

399
00:17:07,359 --> 00:17:10,660
can do now is adapt the value of P 4 on

400
00:17:10,660 --> 00:17:13,089
in products for such that this is equal

401
00:17:13,089 --> 00:17:16,210
to X Phi X or K so that it respects this

402
00:17:16,210 --> 00:17:18,490
IEM equation that the distinguisher

403
00:17:18,490 --> 00:17:21,280
would use so this process is known as

404
00:17:21,280 --> 00:17:22,960
preemptive completion where the

405
00:17:22,960 --> 00:17:24,819
simulator is preemptively completing the

406
00:17:24,819 --> 00:17:26,740
chain such that it can answer the

407
00:17:26,740 --> 00:17:28,660
distinguishers queries so the

408
00:17:28,660 --> 00:17:32,140
distinguishes computation the IEM

409
00:17:32,140 --> 00:17:34,230
computation using a simulator will match

410
00:17:34,230 --> 00:17:37,920
the ideal ciphers output on K comma X

411
00:17:37,920 --> 00:17:40,090
right so what does the stick or the

412
00:17:40,090 --> 00:17:41,830
simulator should do is detect the change

413
00:17:41,830 --> 00:17:43,570
starting at X with key K and

414
00:17:43,570 --> 00:17:45,520
preemptively complete the chain such

415
00:17:45,520 --> 00:17:48,400
that X x equals y so this high level

416
00:17:48,400 --> 00:17:50,830
strategy the thwarted that

417
00:17:50,830 --> 00:17:53,830
distinguishing strategy it's in fact the

418
00:17:53,830 --> 00:17:56,080
high-level strategy for an arbitrary

419
00:17:56,080 --> 00:17:58,179
distinguisher the high-level strategy is

420
00:17:58,179 --> 00:17:59,980
to perform partial chain detection and

421
00:17:59,980 --> 00:18:03,480
pre-emptive completion so note here that

422
00:18:03,480 --> 00:18:06,730
the simulator that I showed work against

423
00:18:06,730 --> 00:18:08,440
that particular distinguishing strategy

424
00:18:08,440 --> 00:18:10,630
for a distinguish are asking those

425
00:18:10,630 --> 00:18:12,429
queries X 1 through X 3 in sequence

426
00:18:12,429 --> 00:18:14,860
however an arbitrary distinguisher can

427
00:18:14,860 --> 00:18:16,659
interleave queries can ask whatever

428
00:18:16,659 --> 00:18:19,059
advance in order to work against an

429
00:18:19,059 --> 00:18:21,039
arbitrary distinguisher what the

430
00:18:21,039 --> 00:18:22,750
simulator would do is to take all

431
00:18:22,750 --> 00:18:25,299
partial chains of length 3 that is it

432
00:18:25,299 --> 00:18:28,059
detects parts a comprising of any three

433
00:18:28,059 --> 00:18:29,730
consecutive round permutations for

434
00:18:29,730 --> 00:18:33,789
example if this simulator squared on P 3

435
00:18:33,789 --> 00:18:37,120
the simulator checks against all P 2 of

436
00:18:37,120 --> 00:18:39,429
X 2 values that it has assigned and P 1

437
00:18:39,429 --> 00:18:41,230
of X 1 values here it has assigned and

438
00:18:41,230 --> 00:18:45,690
sees if those from a partial chain

439
00:18:46,049 --> 00:18:49,929
however if the simulator detects on any

440
00:18:49,929 --> 00:18:53,620
3 consecutive round permutations the

441
00:18:53,620 --> 00:18:56,350
simulators efficiency is affected and an

442
00:18:56,350 --> 00:18:58,269
important part of the differentiability

443
00:18:58,269 --> 00:19:00,220
proof is to show that the simulator is

444
00:19:00,220 --> 00:19:02,260
efficient and this is directly related

445
00:19:02,260 --> 00:19:04,299
to the number of partial chains detected

446
00:19:04,299 --> 00:19:09,309
so let's separate the sets of three into

447
00:19:09,309 --> 00:19:12,100
two parts one known as the wraparound

448
00:19:12,100 --> 00:19:14,830
which consists of rounds for Phi 1 and

449
00:19:14,830 --> 00:19:17,409
Phi 1 2 these are exactly those that

450
00:19:17,409 --> 00:19:20,260
wrap around the key all the iterated

451
00:19:20,260 --> 00:19:23,850
elements of construction and these and

452
00:19:23,850 --> 00:19:27,190
detection of such partial chains require

453
00:19:27,190 --> 00:19:30,760
a query to the ideal cipher and these

454
00:19:30,760 --> 00:19:32,889
partial saints that don't wrap around

455
00:19:32,889 --> 00:19:35,260
can be detected by the simulator on its

456
00:19:35,260 --> 00:19:39,250
own without wearing the IC so how can we

457
00:19:39,250 --> 00:19:40,779
prove the efficiency of the simulator

458
00:19:40,779 --> 00:19:42,519
let me just give a high-level overview

459
00:19:42,519 --> 00:19:46,630
of that proof so notice as I mentioned

460
00:19:46,630 --> 00:19:50,740
for the wraparound partial chains these

461
00:19:50,740 --> 00:19:54,130
require an ideal cipher query so such

462
00:19:54,130 --> 00:19:56,200
ideal cipher queries can in fact be

463
00:19:56,200 --> 00:19:58,480
charged to distinguish OD I will not

464
00:19:58,480 --> 00:20:01,630
mention how but since the distinguisher

465
00:20:01,630 --> 00:20:03,000
D is limited in the arm

466
00:20:03,000 --> 00:20:04,710
of queries that can make to its ideal

467
00:20:04,710 --> 00:20:07,410
cipher we claim that at most cue such

468
00:20:07,410 --> 00:20:10,760
change can be detected using these three

469
00:20:10,760 --> 00:20:13,260
using these two sets of three

470
00:20:13,260 --> 00:20:17,070
consecutive rounds however if you look

471
00:20:17,070 --> 00:20:21,690
at these inner inner partially

472
00:20:21,690 --> 00:20:24,780
introductions these do not require an IC

473
00:20:24,780 --> 00:20:30,240
query so let's see how to bound those so

474
00:20:30,240 --> 00:20:34,140
these these reductions would require the

475
00:20:34,140 --> 00:20:36,420
queries at rounds one two and three to

476
00:20:36,420 --> 00:20:40,020
be defined and a query at a particular

477
00:20:40,020 --> 00:20:42,450
round can be defined only due to a

478
00:20:42,450 --> 00:20:44,490
direct distinguish a query so the

479
00:20:44,490 --> 00:20:46,920
distinguisher explicitly querying say p1

480
00:20:46,920 --> 00:20:49,560
or due to preemptive completion of the

481
00:20:49,560 --> 00:20:51,720
simulator so the simulator does

482
00:20:51,720 --> 00:20:53,490
pre-emptive completion when it detects

483
00:20:53,490 --> 00:20:55,320
partial chains and there are two

484
00:20:55,320 --> 00:20:56,910
categories of partial change detection

485
00:20:56,910 --> 00:20:59,430
as I mentioned one is the wraparound

486
00:20:59,430 --> 00:21:03,530
chain and the other is the energetic

487
00:21:03,530 --> 00:21:06,930
inner partial strain detection so notice

488
00:21:06,930 --> 00:21:11,700
for the one two three partial chain it

489
00:21:11,700 --> 00:21:14,370
can be detected either due to a

490
00:21:14,370 --> 00:21:17,220
wraparound partial chain or due to a

491
00:21:17,220 --> 00:21:19,620
three four five chain so at this point

492
00:21:19,620 --> 00:21:22,290
we have a bound on the number of D

493
00:21:22,290 --> 00:21:24,300
queries by just by assumption the

494
00:21:24,300 --> 00:21:26,040
distinguishes limited in the number of

495
00:21:26,040 --> 00:21:28,020
queries it can make to its Oracle's and

496
00:21:28,020 --> 00:21:30,170
we have a bound on the number of

497
00:21:30,170 --> 00:21:33,510
wraparound chains by the argument I

498
00:21:33,510 --> 00:21:36,000
mentioned earlier however we do not have

499
00:21:36,000 --> 00:21:38,400
a bound on the three four five chains

500
00:21:38,400 --> 00:21:41,040
and this seems circular because in order

501
00:21:41,040 --> 00:21:44,040
to bound and in a detect in a partial

502
00:21:44,040 --> 00:21:46,950
chain we need to bound another in a

503
00:21:46,950 --> 00:21:50,040
partial chain however there is something

504
00:21:50,040 --> 00:21:54,140
that comes to our aid which is that the

505
00:21:54,140 --> 00:21:58,050
all of the inner partial chains have the

506
00:21:58,050 --> 00:22:00,480
round three in common so instead of

507
00:22:00,480 --> 00:22:04,020
arguing about the entire set of the of

508
00:22:04,020 --> 00:22:06,870
three rounds in a particular partial sin

509
00:22:06,870 --> 00:22:10,170
detection we can just argue about the

510
00:22:10,170 --> 00:22:12,090
number of queries that get defined in

511
00:22:12,090 --> 00:22:14,340
this particular round in particular in

512
00:22:14,340 --> 00:22:16,440
round three

513
00:22:16,440 --> 00:22:19,860
so again for a query around three to be

514
00:22:19,860 --> 00:22:22,290
defined it can either be due to a

515
00:22:22,290 --> 00:22:24,780
distinguisher query or due to the

516
00:22:24,780 --> 00:22:26,460
pre-emptive completion of a wraparound

517
00:22:26,460 --> 00:22:28,920
chain and it cannot be due to and in a

518
00:22:28,920 --> 00:22:33,090
partial chain given that we argue that a

519
00:22:33,090 --> 00:22:36,000
chain detected at three four five can be

520
00:22:36,000 --> 00:22:38,670
uniquely mapped to a p3 query which we

521
00:22:38,670 --> 00:22:40,890
have a bound for and will distinguish a

522
00:22:40,890 --> 00:22:44,340
query or to a pair of p3 queries so

523
00:22:44,340 --> 00:22:46,650
using this high-level idea we can bound

524
00:22:46,650 --> 00:22:50,550
the efficiency of the simulator so let

525
00:22:50,550 --> 00:22:53,640
me conclude we show that the fire on

526
00:22:53,640 --> 00:22:55,260
iterated even months or with trivial

527
00:22:55,260 --> 00:22:56,790
case our dual is in differentiable from

528
00:22:56,790 --> 00:22:59,700
an ideal cipher in order to show that we

529
00:22:59,700 --> 00:23:01,650
show an efficient simulator s using the

530
00:23:01,650 --> 00:23:05,490
strategy outlined just now such that no

531
00:23:05,490 --> 00:23:07,140
efficient distinguish are making at most

532
00:23:07,140 --> 00:23:09,840
Q queries can distinguish between BL and

533
00:23:09,840 --> 00:23:11,880
I deal with probability Q to the 2l over

534
00:23:11,880 --> 00:23:14,010
to the N where n is the round

535
00:23:14,010 --> 00:23:15,750
permutations input-output size

536
00:23:15,750 --> 00:23:17,660
thank you

537
00:23:17,660 --> 00:23:22,650
[Applause]

