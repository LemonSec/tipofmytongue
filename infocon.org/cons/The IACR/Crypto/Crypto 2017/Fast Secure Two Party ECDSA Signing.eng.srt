1
00:00:04,870 --> 00:00:08,889
okay thank you very much so threshold

2
00:00:08,889 --> 00:00:11,830
cryptography dates back to the late 80s

3
00:00:11,830 --> 00:00:13,510
already and a lot of work done in the

4
00:00:13,510 --> 00:00:16,239
90s and the idea was that you would have

5
00:00:16,239 --> 00:00:18,970
a number of parties sharing a private

6
00:00:18,970 --> 00:00:22,180
key for decryption or for signing and

7
00:00:22,180 --> 00:00:24,160
you would need some authorized subsets

8
00:00:24,160 --> 00:00:25,539
in order to carry out any of the

9
00:00:25,539 --> 00:00:27,779
operation any signing operation or any

10
00:00:27,779 --> 00:00:30,699
decryption operation and there are many

11
00:00:30,699 --> 00:00:32,290
applications for a threshold

12
00:00:32,290 --> 00:00:34,809
cryptography you can think of multi

13
00:00:34,809 --> 00:00:36,880
signatory applications so you want to

14
00:00:36,880 --> 00:00:40,750
have some two out of five people in the

15
00:00:40,750 --> 00:00:42,309
company signing on a cheque or or

16
00:00:42,309 --> 00:00:44,770
something to that effect more recently

17
00:00:44,770 --> 00:00:46,180
there's been a lot of interest in this

18
00:00:46,180 --> 00:00:48,940
to do its application to key protection

19
00:00:48,940 --> 00:00:51,399
so you want to keep your secret key safe

20
00:00:51,399 --> 00:00:53,710
you can either put it in dedicated

21
00:00:53,710 --> 00:00:55,989
hardware but that can be problematic in

22
00:00:55,989 --> 00:00:58,210
many situations so you can split it and

23
00:00:58,210 --> 00:01:00,100
put the different key shares on

24
00:01:00,100 --> 00:01:02,469
different machines protect them with

25
00:01:02,469 --> 00:01:04,269
different operating systems in different

26
00:01:04,269 --> 00:01:05,560
environments different administrators

27
00:01:05,560 --> 00:01:07,509
and make it hard for an attacker to get

28
00:01:07,509 --> 00:01:09,490
to all parts of the key and therefore

29
00:01:09,490 --> 00:01:11,619
keep it safe and this is actually now

30
00:01:11,619 --> 00:01:13,420
being deployed in practice and the

31
00:01:13,420 --> 00:01:16,780
number of startups doing this we know

32
00:01:16,780 --> 00:01:18,550
already from a couple of decades ago

33
00:01:18,550 --> 00:01:22,660
that RSA you know gamma EC is which is

34
00:01:22,660 --> 00:01:25,209
again just a few human snore signatures

35
00:01:25,209 --> 00:01:26,890
all of these can be done very very

36
00:01:26,890 --> 00:01:28,840
efficiently even if you have malicious

37
00:01:28,840 --> 00:01:32,380
adversaries who will run any arbitrary

38
00:01:32,380 --> 00:01:33,940
attack strategy to try and break the

39
00:01:33,940 --> 00:01:36,580
protocol it can be we can protect

40
00:01:36,580 --> 00:01:38,229
against that using very efficient zero

41
00:01:38,229 --> 00:01:39,340
knowledge proof see inside these

42
00:01:39,340 --> 00:01:42,520
protocols and and we and this is really

43
00:01:42,520 --> 00:01:44,319
a solve problem we can do this very very

44
00:01:44,319 --> 00:01:48,759
efficiently in contrast DSA and ECDSA

45
00:01:48,759 --> 00:01:50,410
are very expensive by the way I'm going

46
00:01:50,410 --> 00:01:52,360
to talk about ECDSA but it's exactly the

47
00:01:52,360 --> 00:01:53,979
same for DSA because everything here is

48
00:01:53,979 --> 00:01:56,590
just generic in the group in particular

49
00:01:56,590 --> 00:01:59,140
the best two-party protocol takes

50
00:01:59,140 --> 00:02:01,270
numerous seconds for a single signature

51
00:02:01,270 --> 00:02:03,310
and that's a very significant overhead

52
00:02:03,310 --> 00:02:05,380
and it also has an extremely expensive

53
00:02:05,380 --> 00:02:07,330
key generation protocol so it's

54
00:02:07,330 --> 00:02:09,369
problematic to actually deploy such a

55
00:02:09,369 --> 00:02:11,890
solution the question is why why is

56
00:02:11,890 --> 00:02:14,200
ECDSA so much harder than all of these

57
00:02:14,200 --> 00:02:17,370
other all of these other

58
00:02:17,370 --> 00:02:20,610
protocols or these other encryption and

59
00:02:20,610 --> 00:02:23,430
signing schemes the reason is that it

60
00:02:23,430 --> 00:02:27,810
has this strange or unusual feature that

61
00:02:27,810 --> 00:02:30,420
you have to generate this random value k

62
00:02:30,420 --> 00:02:33,930
and and it's inverse and these have to

63
00:02:33,930 --> 00:02:35,730
be secret and not not known to both

64
00:02:35,730 --> 00:02:38,340
parties and it's actually non-trivial in

65
00:02:38,340 --> 00:02:40,079
multi-party computation to generate

66
00:02:40,079 --> 00:02:43,500
shares of a random value and it's

67
00:02:43,500 --> 00:02:45,030
inverse and that makes it actually very

68
00:02:45,030 --> 00:02:48,150
very difficult so just to elaborate a

69
00:02:48,150 --> 00:02:49,890
little bit now let's compare Schnoor

70
00:02:49,890 --> 00:02:52,200
signing to ECDSA signing or what

71
00:02:52,200 --> 00:02:54,599
happened when we try to naturally make a

72
00:02:54,599 --> 00:02:57,959
two party protocol for these for these

73
00:02:57,959 --> 00:03:00,500
signing schemes so in both of these

74
00:03:00,500 --> 00:03:03,840
signing schemes you choose a random cave

75
00:03:03,840 --> 00:03:05,670
from Z Q where Q is the order of the

76
00:03:05,670 --> 00:03:08,819
group and you compute an elliptic curve

77
00:03:08,819 --> 00:03:10,829
point R which is K times G where G is

78
00:03:10,829 --> 00:03:12,450
the base or generator points of the

79
00:03:12,450 --> 00:03:16,409
curve in Schnoor you then hash the

80
00:03:16,409 --> 00:03:18,930
message together with that point and an

81
00:03:18,930 --> 00:03:19,859
easy do you say you do something

82
00:03:19,859 --> 00:03:22,049
different you take the X portion of the

83
00:03:22,049 --> 00:03:24,209
point which anyway has the bulk of the

84
00:03:24,209 --> 00:03:26,340
entropy and you reduce it mod Q and you

85
00:03:26,340 --> 00:03:28,620
get a small R and now you have something

86
00:03:28,620 --> 00:03:31,590
completely different fish nor you have a

87
00:03:31,590 --> 00:03:34,650
linear equation which is just K minus x

88
00:03:34,650 --> 00:03:37,260
times e and in ECDSA you take the

89
00:03:37,260 --> 00:03:39,180
inverse of K and you multiply it by the

90
00:03:39,180 --> 00:03:40,950
hash of the message plus R times X you

91
00:03:40,950 --> 00:03:43,290
do all that mod Q anyway I put R and s

92
00:03:43,290 --> 00:03:45,269
and snorey I put ena so you can see that

93
00:03:45,269 --> 00:03:46,500
Schnoor the whole way through is just

94
00:03:46,500 --> 00:03:48,569
very linear except for the hash function

95
00:03:48,569 --> 00:03:52,139
whereas ECDSA has this K inverse which

96
00:03:52,139 --> 00:03:54,389
which makes things problematic so let's

97
00:03:54,389 --> 00:03:58,199
do two partition or signing so we have

98
00:03:58,199 --> 00:04:01,049
the secret key X and the natural thing

99
00:04:01,049 --> 00:04:03,180
to do is to have each party hold an

100
00:04:03,180 --> 00:04:05,010
additive share of X so P want to hold X

101
00:04:05,010 --> 00:04:07,769
1 P to hold X 2 and and the sum of the

102
00:04:07,769 --> 00:04:09,780
these is they actually the secret key

103
00:04:09,780 --> 00:04:11,549
and of course they're random under that

104
00:04:11,549 --> 00:04:14,099
constraint you need to choose a random K

105
00:04:14,099 --> 00:04:16,139
well that's also pretty easy P 1 will

106
00:04:16,139 --> 00:04:20,070
choose K 1 P 2 will choose K 2 and and

107
00:04:20,070 --> 00:04:22,919
they can even define a local r1 and r2

108
00:04:22,919 --> 00:04:24,900
value by multiplying that by the point

109
00:04:24,900 --> 00:04:26,849
by the base point and then they can

110
00:04:26,849 --> 00:04:28,440
compute our by simply summing those

111
00:04:28,440 --> 00:04:30,720
together ok so this is very very

112
00:04:30,720 --> 00:04:33,090
easy to do in very efficiently once they

113
00:04:33,090 --> 00:04:35,640
know are they can each locally compute e

114
00:04:35,640 --> 00:04:37,080
because it's a hash of the message and

115
00:04:37,080 --> 00:04:39,570
are and then they need to compute this

116
00:04:39,570 --> 00:04:42,750
final equation this s equation so each

117
00:04:42,750 --> 00:04:45,300
one can again locally do this so p1 will

118
00:04:45,300 --> 00:04:49,260
compute s12 equal K 1 minus x1 times e P

119
00:04:49,260 --> 00:04:51,270
tooth likewise and you just sum those

120
00:04:51,270 --> 00:04:53,040
together and you get the signature so

121
00:04:53,040 --> 00:04:55,260
it's all linear or very nice you have to

122
00:04:55,260 --> 00:04:57,510
add some very basic 0 knowledge first

123
00:04:57,510 --> 00:04:59,430
here but it's very very efficient and

124
00:04:59,430 --> 00:05:01,710
everything works very nicely if you try

125
00:05:01,710 --> 00:05:05,370
to do this in ECDSA everything sort of

126
00:05:05,370 --> 00:05:07,680
messes up at this at the stage of trying

127
00:05:07,680 --> 00:05:09,750
to compute s because of the K University

128
00:05:09,750 --> 00:05:11,880
if you have additive shares of K it's

129
00:05:11,880 --> 00:05:14,220
very hard to compute additive shares of

130
00:05:14,220 --> 00:05:15,540
K inverse and you sort of have this

131
00:05:15,540 --> 00:05:16,560
choice either

132
00:05:16,560 --> 00:05:20,130
we have additive shares and then getting

133
00:05:20,130 --> 00:05:22,290
shares of K universe is hard or maybe

134
00:05:22,290 --> 00:05:24,660
we'll try multiplicative shares but then

135
00:05:24,660 --> 00:05:27,330
combining the different values to get s

136
00:05:27,330 --> 00:05:30,390
is going to also be very hard and so

137
00:05:30,390 --> 00:05:32,760
everything sort of breaks down now in

138
00:05:32,760 --> 00:05:34,919
the the mid-90s there was work on these

139
00:05:34,919 --> 00:05:37,590
for the multi-party setting with an

140
00:05:37,590 --> 00:05:39,390
honest majority done by Langford and

141
00:05:39,390 --> 00:05:41,340
then done by gennaro

142
00:05:41,340 --> 00:05:45,030
yaki Kraft chicken and and rubbing but

143
00:05:45,030 --> 00:05:47,280
I'm gonna focus on the two-party setting

144
00:05:47,280 --> 00:05:49,560
and with in that case obviously there's

145
00:05:49,560 --> 00:05:52,680
no honest majority let's just quickly

146
00:05:52,680 --> 00:05:55,320
rewrite ECDSA and and what I want to

147
00:05:55,320 --> 00:05:57,660
notice is just that there's this s pad

148
00:05:57,660 --> 00:06:01,020
has two separate sub equations the

149
00:06:01,020 --> 00:06:03,090
left-hand red side and the right-hand

150
00:06:03,090 --> 00:06:04,710
purple side and we're going to have to

151
00:06:04,710 --> 00:06:06,030
deal with these separately which is why

152
00:06:06,030 --> 00:06:07,680
I've colored them differently I'm gonna

153
00:06:07,680 --> 00:06:09,090
put that up in the top right hand corner

154
00:06:09,090 --> 00:06:15,360
so you can follow the see the the basic

155
00:06:15,360 --> 00:06:17,010
Sonics game the whole way through so

156
00:06:17,010 --> 00:06:20,550
Mackenzie Ryder were the first 16 years

157
00:06:20,550 --> 00:06:22,140
ago here in crypto were the first to

158
00:06:22,140 --> 00:06:24,479
actually provide a protocol for the

159
00:06:24,479 --> 00:06:26,340
two-party case and their approach was as

160
00:06:26,340 --> 00:06:28,410
follows firstly they said additively

161
00:06:28,410 --> 00:06:29,760
sharing is going to be difficult so

162
00:06:29,760 --> 00:06:32,490
let's not typically share the values so

163
00:06:32,490 --> 00:06:35,310
parties the parties hold X 1 and X 2

164
00:06:35,310 --> 00:06:36,840
which are random under the constraint

165
00:06:36,840 --> 00:06:38,910
that the product of X 1 and X 2 equals x

166
00:06:38,910 --> 00:06:42,450
that's not a problem and since we have

167
00:06:42,450 --> 00:06:44,510
to make this consistent throughout

168
00:06:44,510 --> 00:06:45,980
additively sharing kay their

169
00:06:45,980 --> 00:06:49,400
multiplicative multiplicatively share K

170
00:06:49,400 --> 00:06:52,610
as well so P 1 choose K 1 P 2 K 2 and

171
00:06:52,610 --> 00:06:55,940
and K will be k1 times k2 and then our

172
00:06:55,940 --> 00:06:57,830
of course will be K times G and this is

173
00:06:57,830 --> 00:06:58,880
actually just diffie-hellman key

174
00:06:58,880 --> 00:07:01,760
exchange you can see that P 1 will send

175
00:07:01,760 --> 00:07:04,100
K 1 times G P 2 will send K 2 times G

176
00:07:04,100 --> 00:07:05,960
and they can each locally compute K 1

177
00:07:05,960 --> 00:07:08,510
times K 2 times G so this is actually

178
00:07:08,510 --> 00:07:10,610
very easy to do once they have this

179
00:07:10,610 --> 00:07:14,120
value R that lets them go to the next

180
00:07:14,120 --> 00:07:16,970
step and also since the K the sharing of

181
00:07:16,970 --> 00:07:18,800
K is multiplicative they can each

182
00:07:18,800 --> 00:07:21,290
locally compute an inverse of their

183
00:07:21,290 --> 00:07:23,690
portion of K and now they have shares

184
00:07:23,690 --> 00:07:25,940
also of K inverse so we've solved the

185
00:07:25,940 --> 00:07:27,710
problem of K inverse and everything is

186
00:07:27,710 --> 00:07:28,910
OK

187
00:07:28,910 --> 00:07:31,700
and each can also compute this R which

188
00:07:31,700 --> 00:07:34,010
is our X molecule so what becomes now

189
00:07:34,010 --> 00:07:35,780
difficult what's difficult is computing

190
00:07:35,780 --> 00:07:39,080
s because we don't have additive shares

191
00:07:39,080 --> 00:07:44,090
and this is an air linear or this linear

192
00:07:44,090 --> 00:07:46,520
equation or at least of K inverse but

193
00:07:46,520 --> 00:07:48,470
what they do has have is they have R and

194
00:07:48,470 --> 00:07:51,230
they have shares of both K and X and and

195
00:07:51,230 --> 00:07:53,930
and now what McKenzie writers say is

196
00:07:53,930 --> 00:07:56,120
let's use per year which is additively

197
00:07:56,120 --> 00:07:58,130
homomorphic in order to finish this

198
00:07:58,130 --> 00:08:01,430
computation so P 1 generates a PI air

199
00:08:01,430 --> 00:08:06,050
key pair and can then encrypt each part

200
00:08:06,050 --> 00:08:08,840
of this equation separately using its

201
00:08:08,840 --> 00:08:12,860
own values so P 1 will encrypts K 1

202
00:08:12,860 --> 00:08:14,780
inverse times the hash of the message

203
00:08:14,780 --> 00:08:17,600
which is his portion of the left-hand

204
00:08:17,600 --> 00:08:21,860
side and will also encrypt K 1 inverse

205
00:08:21,860 --> 00:08:23,900
times X 1 times out which is again his

206
00:08:23,900 --> 00:08:25,550
own portion of the right-hand side of

207
00:08:25,550 --> 00:08:27,470
the purple side and we'll send that to

208
00:08:27,470 --> 00:08:30,290
Peter now P 2 can use the additively

209
00:08:30,290 --> 00:08:32,570
homomorphic properties of pi air to

210
00:08:32,570 --> 00:08:36,289
finish the signature how can he do that

211
00:08:36,289 --> 00:08:39,039
Multi can multiply the left-hand side by

212
00:08:39,039 --> 00:08:41,990
its own portion of K 2 inverse and

213
00:08:41,990 --> 00:08:44,120
multiply the right-hand side by each

214
00:08:44,120 --> 00:08:46,640
portion of K 2 inverse times X 2 and

215
00:08:46,640 --> 00:08:48,410
what you now get is you get 2 to

216
00:08:48,410 --> 00:08:50,780
encryptions one is of K inverse times

217
00:08:50,780 --> 00:08:52,910
the hash hash of the message and the

218
00:08:52,910 --> 00:08:55,100
second second ciphertext is an

219
00:08:55,100 --> 00:08:57,560
encryption of K inverse times X times R

220
00:08:57,560 --> 00:08:58,270
and all

221
00:08:58,270 --> 00:09:00,550
- do we just add them together luckily

222
00:09:00,550 --> 00:09:01,600
to add it to be homomorphic encryption

223
00:09:01,600 --> 00:09:03,850
so you can add them together Peter you

224
00:09:03,850 --> 00:09:06,730
can then send that back to p1 who will

225
00:09:06,730 --> 00:09:08,410
decrypt and get the signature so

226
00:09:08,410 --> 00:09:12,670
everything is fine just small caveat you

227
00:09:12,670 --> 00:09:14,320
have just have to add noise because

228
00:09:14,320 --> 00:09:16,780
inside higher encryption you're working

229
00:09:16,780 --> 00:09:19,600
over a large ring you're not working mod

230
00:09:19,600 --> 00:09:21,940
Q so you add noise in order to to

231
00:09:21,940 --> 00:09:24,010
distort any difference here so this

232
00:09:24,010 --> 00:09:26,050
seems very good what's the problem the

233
00:09:26,050 --> 00:09:27,880
problem is that in the case of malicious

234
00:09:27,880 --> 00:09:29,680
adversaries when you want to force the

235
00:09:29,680 --> 00:09:31,390
parties to actually behave honest and do

236
00:09:31,390 --> 00:09:34,150
the correct thing it becomes really

237
00:09:34,150 --> 00:09:36,220
really hard to prove that you're

238
00:09:36,220 --> 00:09:38,440
behaving honestly in particular for one

239
00:09:38,440 --> 00:09:39,610
just one example

240
00:09:39,610 --> 00:09:42,070
p1 needs to prove that the encryptions

241
00:09:42,070 --> 00:09:46,440
that it sends contain k1 inverse now

242
00:09:46,440 --> 00:09:49,780
it's true that K the p2 has some

243
00:09:49,780 --> 00:09:52,240
function of k1 which is R 1 which is k1

244
00:09:52,240 --> 00:09:54,610
times g but doesn't have anything which

245
00:09:54,610 --> 00:09:56,980
is a function of k 1 inverse it's very

246
00:09:56,980 --> 00:09:58,630
very hard it's very unclear how you can

247
00:09:58,630 --> 00:10:00,550
even prove such a relation in efficient

248
00:10:00,550 --> 00:10:02,200
way and actually if you look at the

249
00:10:02,200 --> 00:10:03,790
mackenzie write a paper there's zero

250
00:10:03,790 --> 00:10:06,100
knowledge proof go span about a page and

251
00:10:06,100 --> 00:10:08,620
a half of equations of computations and

252
00:10:08,620 --> 00:10:10,270
exponentiations they have to be proven

253
00:10:10,270 --> 00:10:12,880
and it's an auxilary pi air public key

254
00:10:12,880 --> 00:10:13,960
and there's a whole lot of other things

255
00:10:13,960 --> 00:10:15,940
and it's really really really expensive

256
00:10:15,940 --> 00:10:19,150
to do there's been a number of follow-up

257
00:10:19,150 --> 00:10:21,250
works to McKenzie writer they've all

258
00:10:21,250 --> 00:10:22,960
reduced the cost of these your knowledge

259
00:10:22,960 --> 00:10:24,910
proofs but they're still very very

260
00:10:24,910 --> 00:10:27,130
expensive and there's still a very big

261
00:10:27,130 --> 00:10:29,170
bottleneck because proving that you're

262
00:10:29,170 --> 00:10:30,550
behaving correctly here is very very

263
00:10:30,550 --> 00:10:34,330
difficult so what can we do our approach

264
00:10:34,330 --> 00:10:36,790
is we is to try and remove all of these

265
00:10:36,790 --> 00:10:38,260
expensive to our knowledge proofs you

266
00:10:38,260 --> 00:10:38,770
still have

267
00:10:38,770 --> 00:10:40,000
Sam's your knowledge for it's a very

268
00:10:40,000 --> 00:10:42,880
cheap discrete log by proving that you

269
00:10:42,880 --> 00:10:44,080
know the discrete log of something which

270
00:10:44,080 --> 00:10:45,430
is just actually a local Schnoor

271
00:10:45,430 --> 00:10:46,690
signature so that's really really

272
00:10:46,690 --> 00:10:49,210
efficient and the way that we do this is

273
00:10:49,210 --> 00:10:51,850
we still keep to the mackenzie ryder

274
00:10:51,850 --> 00:10:53,980
paradigm so they have the parties have

275
00:10:53,980 --> 00:10:56,710
multiplicative shares of X but we also

276
00:10:56,710 --> 00:11:00,430
assume that P 2 has an encryption of X 1

277
00:11:00,430 --> 00:11:03,880
under par TP ones player public key so

278
00:11:03,880 --> 00:11:05,530
and we could take care of this during

279
00:11:05,530 --> 00:11:07,330
setup so it's just assumed now now that

280
00:11:07,330 --> 00:11:09,640
P 2 has an encryption of X 1 and knows

281
00:11:09,640 --> 00:11:11,110
that it's a valid encryption of X 1 of

282
00:11:11,110 --> 00:11:12,010
course it doesn't know

283
00:11:12,010 --> 00:11:13,660
inside because the key belongs the

284
00:11:13,660 --> 00:11:16,150
private key belongs to 2p1 we can do

285
00:11:16,150 --> 00:11:17,590
this in the setup and we'll see now this

286
00:11:17,590 --> 00:11:19,390
actually makes everything really really

287
00:11:19,390 --> 00:11:22,570
easy and and that's actually the main

288
00:11:22,570 --> 00:11:24,790
observation of that that of this entire

289
00:11:24,790 --> 00:11:25,360
paper

290
00:11:25,360 --> 00:11:27,550
so the first step you can see the bottom

291
00:11:27,550 --> 00:11:30,490
right in yellow will suit will show what

292
00:11:30,490 --> 00:11:33,010
what I'm talking about there which part

293
00:11:33,010 --> 00:11:34,240
of the signing operation we're talking

294
00:11:34,240 --> 00:11:34,480
about

295
00:11:34,480 --> 00:11:36,820
and as you Mackenzie right of the

296
00:11:36,820 --> 00:11:38,500
parties will run a diffie-hellman key

297
00:11:38,500 --> 00:11:41,800
exchange to generate this value art I

298
00:11:41,800 --> 00:11:43,510
call it a simulator will do for my key

299
00:11:43,510 --> 00:11:44,620
exchange it has some zero knowledge

300
00:11:44,620 --> 00:11:46,510
fruits inside for a discrete log it has

301
00:11:46,510 --> 00:11:48,160
some commitments but it's basically just

302
00:11:48,160 --> 00:11:51,280
a key exchange to compute multiplet of

303
00:11:51,280 --> 00:11:53,860
shares of k and to get R which is k1

304
00:11:53,860 --> 00:11:57,340
times k2 times times G and then again

305
00:11:57,340 --> 00:12:01,090
both parties can locally compute R to be

306
00:12:01,090 --> 00:12:04,180
our x mod Q because they both know now

307
00:12:04,180 --> 00:12:07,330
that the relative elliptic curve Point R

308
00:12:07,330 --> 00:12:10,660
and at and this is very efficient and

309
00:12:10,660 --> 00:12:13,330
very simple what's interesting now is

310
00:12:13,330 --> 00:12:17,140
look at what p2 has p2 has the curved

311
00:12:17,140 --> 00:12:21,070
point R has its shares of of the secret

312
00:12:21,070 --> 00:12:23,980
key so you an end case on X 2 and K 2

313
00:12:23,980 --> 00:12:26,470
always arose has K 2 inverse because

314
00:12:26,470 --> 00:12:29,170
it's it's its own share and it also has

315
00:12:29,170 --> 00:12:31,450
an encryption of x1 and if you look

316
00:12:31,450 --> 00:12:33,070
closely here what you see is that

317
00:12:33,070 --> 00:12:36,460
actually p2 can now work completely by

318
00:12:36,460 --> 00:12:39,010
itself to compute what I call an almost

319
00:12:39,010 --> 00:12:40,990
signature and almost signature is a

320
00:12:40,990 --> 00:12:43,300
signature but instead of having K

321
00:12:43,300 --> 00:12:45,280
inverse there it has K 2 inverse but

322
00:12:45,280 --> 00:12:46,870
everything else is a full signature and

323
00:12:46,870 --> 00:12:48,670
it can do this all by itself without

324
00:12:48,670 --> 00:12:53,050
interacting at all with p1 how p2 can

325
00:12:53,050 --> 00:12:56,290
encrypt K 2 inverse times H of M because

326
00:12:56,290 --> 00:12:58,690
these are values that have nose it can

327
00:12:58,690 --> 00:13:03,850
also encrypt K 2 inverse times R times X

328
00:13:03,850 --> 00:13:06,970
2 times X 1 Y cannot do times X 1

329
00:13:06,970 --> 00:13:08,710
because it has the encryption of x1 to

330
00:13:08,710 --> 00:13:10,480
start with so again it's a scalar

331
00:13:10,480 --> 00:13:12,310
multiplication inside additively home

332
00:13:12,310 --> 00:13:14,860
Orphic encryption if you look at what

333
00:13:14,860 --> 00:13:18,790
this is this is actually a the only

334
00:13:18,790 --> 00:13:19,840
difference between this and a full

335
00:13:19,840 --> 00:13:21,820
signature is that you have to multiply

336
00:13:21,820 --> 00:13:25,240
it by K 1 inverse that's the only

337
00:13:25,240 --> 00:13:25,820
difference but

338
00:13:25,820 --> 00:13:28,730
and in fact not only is that the only

339
00:13:28,730 --> 00:13:30,770
difference this is that means that given

340
00:13:30,770 --> 00:13:32,150
a real signature you can actually even

341
00:13:32,150 --> 00:13:34,400
generate this value yourself p1 could

342
00:13:34,400 --> 00:13:35,450
generate this value itself by

343
00:13:35,450 --> 00:13:38,330
multiplying but by multiplying of a k1

344
00:13:38,330 --> 00:13:40,940
so this value reveals nothing to p1 so

345
00:13:40,940 --> 00:13:42,890
Peter can compute this value by itself

346
00:13:42,890 --> 00:13:45,470
which is an almost signature inside the

347
00:13:45,470 --> 00:13:47,840
encryption and just send the ciphertext

348
00:13:47,840 --> 00:13:52,730
to p1 and p1 as in Mackenzie Rider you

349
00:13:52,730 --> 00:13:54,290
add some noise but we're ignoring that

350
00:13:54,290 --> 00:13:58,250
for now and p1 has the curve point R K 1

351
00:13:58,250 --> 00:14:00,770
x1 and the cipher text of which the

352
00:14:00,770 --> 00:14:02,210
decryption of the almost signature just

353
00:14:02,210 --> 00:14:05,300
decrypts multiplies the almost signature

354
00:14:05,300 --> 00:14:07,100
by k1 inverse and it's finished

355
00:14:07,100 --> 00:14:10,310
it now has has completed the signature

356
00:14:10,310 --> 00:14:12,530
and is almost no interaction and mainly

357
00:14:12,530 --> 00:14:15,620
local work done by the parties what then

358
00:14:15,620 --> 00:14:17,630
Hoddy p1 does is just verify this is a

359
00:14:17,630 --> 00:14:19,160
valid signature and we're completely

360
00:14:19,160 --> 00:14:23,620
finished so it's no longer pages of

361
00:14:23,620 --> 00:14:25,730
complex your knowledge proofs and

362
00:14:25,730 --> 00:14:26,930
actually in practice it's not just

363
00:14:26,930 --> 00:14:28,300
efficiency it's also it's also

364
00:14:28,300 --> 00:14:29,990
simplicity the protocol which is

365
00:14:29,990 --> 00:14:31,250
important if you actually want to deploy

366
00:14:31,250 --> 00:14:33,410
this and and this is a diagram of all

367
00:14:33,410 --> 00:14:34,610
you have a simulator will diffie-hellman

368
00:14:34,610 --> 00:14:38,210
key exchange followed by p2 during local

369
00:14:38,210 --> 00:14:41,150
work sing the cypher text of p1 p1 the

370
00:14:41,150 --> 00:14:43,790
crips and and you're done and multiplies

371
00:14:43,790 --> 00:14:44,810
by K what are you person you're done

372
00:14:44,810 --> 00:14:47,240
questions why is this secure and how is

373
00:14:47,240 --> 00:14:48,710
it suddenly magically solved all the

374
00:14:48,710 --> 00:14:51,260
problems of cheating so in order to

375
00:14:51,260 --> 00:14:53,000
understand that let's look at the

376
00:14:53,000 --> 00:14:55,310
security that it's argued security for

377
00:14:55,310 --> 00:14:57,820
this protocol what happens if p1 is

378
00:14:57,820 --> 00:15:00,290
malicious so p1 is malicious wants to

379
00:15:00,290 --> 00:15:03,500
change the only thing that p1 dance is

380
00:15:03,500 --> 00:15:05,900
participate in the simulator will be

381
00:15:05,900 --> 00:15:08,060
free Hellman key exchange and you can't

382
00:15:08,060 --> 00:15:09,920
cheat in this all you get to do is send

383
00:15:09,920 --> 00:15:13,040
your part of the key exchange and you

384
00:15:13,040 --> 00:15:14,480
have to prove that you know the discrete

385
00:15:14,480 --> 00:15:16,760
log but that's again very easy you can't

386
00:15:16,760 --> 00:15:19,100
cheat this nothing that p1 can do p1

387
00:15:19,100 --> 00:15:21,950
just gets a ciphertext from p2 and the

388
00:15:21,950 --> 00:15:23,480
creeps it multiplies it by something and

389
00:15:23,480 --> 00:15:24,920
outputs it it can multiply it by the

390
00:15:24,920 --> 00:15:26,390
wrong value just means you eat itself

391
00:15:26,390 --> 00:15:27,890
we'll get an invalid signature won't

392
00:15:27,890 --> 00:15:30,200
make any difference whatsoever so p1

393
00:15:30,200 --> 00:15:33,050
ambitious p1 can't do anything and we've

394
00:15:33,050 --> 00:15:34,400
saved all of the zero knowledge proof

395
00:15:34,400 --> 00:15:36,320
that p1 had to send the p2 because

396
00:15:36,320 --> 00:15:38,860
there's nothing that p1 is doing here

397
00:15:38,860 --> 00:15:40,660
what about p2 and that's the interesting

398
00:15:40,660 --> 00:15:43,540
question the the observation here is

399
00:15:43,540 --> 00:15:46,240
that we're not computing a general

400
00:15:46,240 --> 00:15:49,540
secure computation function we're

401
00:15:49,540 --> 00:15:52,270
computing a digital signature and what

402
00:15:52,270 --> 00:15:54,640
that means is that when P so what's the

403
00:15:54,640 --> 00:15:56,649
danger the danger that peter can send an

404
00:15:56,649 --> 00:15:59,350
invalid message to p1 because p2 is

405
00:15:59,350 --> 00:16:01,029
malicious so instead of doing this

406
00:16:01,029 --> 00:16:03,190
correct homomorphic operations p2 could

407
00:16:03,190 --> 00:16:05,260
send something some arbitrary garbage or

408
00:16:05,260 --> 00:16:07,300
something which is incorrect and and and

409
00:16:07,300 --> 00:16:10,209
p1 how can P 1 know the answer is very

410
00:16:10,209 --> 00:16:12,190
simply p1 cannot because the digital

411
00:16:12,190 --> 00:16:14,940
signature scheme so in p1 gets the value

412
00:16:14,940 --> 00:16:17,410
decrypts and multiplies it by K 1

413
00:16:17,410 --> 00:16:19,570
inverse p1 can just check that the

414
00:16:19,570 --> 00:16:22,060
signature is correct and that means that

415
00:16:22,060 --> 00:16:24,010
if p2 tries to cheat it's not going to

416
00:16:24,010 --> 00:16:26,470
help because if it's an incorrect value

417
00:16:26,470 --> 00:16:28,320
p1 will know it's an incorrect value

418
00:16:28,320 --> 00:16:30,610
simply by verifying its signature is

419
00:16:30,610 --> 00:16:33,220
correct and you don't need any 0 in each

420
00:16:33,220 --> 00:16:34,959
box or knowledge proofs anymore because

421
00:16:34,959 --> 00:16:36,700
correctness is valid a just by verifying

422
00:16:36,700 --> 00:16:38,920
the signature and that makes it all very

423
00:16:38,920 --> 00:16:42,730
simple and very very efficient there is

424
00:16:42,730 --> 00:16:44,380
one thing that you might have might be

425
00:16:44,380 --> 00:16:46,180
bothering in if it's not it'll bother

426
00:16:46,180 --> 00:16:49,000
you now once I say it may be p2 can

427
00:16:49,000 --> 00:16:53,080
generate a ciphertext that just knowing

428
00:16:53,080 --> 00:16:55,810
whether the ciphertext actually is a

429
00:16:55,810 --> 00:16:58,420
valid result in a valid signature or not

430
00:16:58,420 --> 00:16:59,770
will reduce will reveal information

431
00:16:59,770 --> 00:17:02,620
about the secret key first you should

432
00:17:02,620 --> 00:17:03,940
know you should notice it can only

433
00:17:03,940 --> 00:17:06,040
reveal a single bit because that's the

434
00:17:06,040 --> 00:17:08,380
only information that there is and this

435
00:17:08,380 --> 00:17:09,939
is indeed a problem so we get around

436
00:17:09,939 --> 00:17:12,339
this in two ways and this is all in the

437
00:17:12,339 --> 00:17:14,679
paper one is by using a game based

438
00:17:14,679 --> 00:17:16,119
definition and in game based definition

439
00:17:16,119 --> 00:17:18,550
you can just simply guess the first

440
00:17:18,550 --> 00:17:20,800
point at which the adversary gives you a

441
00:17:20,800 --> 00:17:22,990
bad signature and then and and

442
00:17:22,990 --> 00:17:25,359
everything goes through and we can also

443
00:17:25,359 --> 00:17:27,130
prove it sit under a full simulation

444
00:17:27,130 --> 00:17:30,750
based definition using a very strange

445
00:17:30,750 --> 00:17:34,000
weird assumption so that's in the paper

446
00:17:34,000 --> 00:17:35,350
as well and if you're into weird

447
00:17:35,350 --> 00:17:36,520
assumptions which seems to be very

448
00:17:36,520 --> 00:17:38,440
popular these days anyway then you could

449
00:17:38,440 --> 00:17:40,809
take that and and be happier but

450
00:17:40,809 --> 00:17:42,309
actually the game based definition I

451
00:17:42,309 --> 00:17:44,800
think is very very convincing noise your

452
00:17:44,800 --> 00:17:46,300
knowledge proofs just using the fact

453
00:17:46,300 --> 00:17:47,590
that it's a signature scheme and you can

454
00:17:47,590 --> 00:17:49,030
verify and everything is OK

455
00:17:49,030 --> 00:17:52,210
what about key generation so

456
00:17:52,210 --> 00:17:55,570
the key generation phase like generating

457
00:17:55,570 --> 00:17:58,419
the multiplicative shares of K does a

458
00:17:58,419 --> 00:18:00,220
simulate a little different key exchange

459
00:18:00,220 --> 00:18:03,340
and that's easy we send X 1 times G X 2

460
00:18:03,340 --> 00:18:05,320
times G and you can each locally compute

461
00:18:05,320 --> 00:18:07,270
the public key which is X 1 times X 2

462
00:18:07,270 --> 00:18:10,000
times G that's very very cheap but

463
00:18:10,000 --> 00:18:13,659
remember we needed to have p1 send an

464
00:18:13,659 --> 00:18:16,720
encryption of x1 to p2 under its own

465
00:18:16,720 --> 00:18:18,850
public key and and p2 has to be sure

466
00:18:18,850 --> 00:18:19,750
this is correct

467
00:18:19,750 --> 00:18:23,770
this is a very crucial point if p2 if p1

468
00:18:23,770 --> 00:18:26,740
sends an incorrect value then when p2

469
00:18:26,740 --> 00:18:28,630
sends back the suffix to p1 it may

470
00:18:28,630 --> 00:18:31,149
reveal information about p2 a secret key

471
00:18:31,149 --> 00:18:32,980
to a malicious p1 so we have to be very

472
00:18:32,980 --> 00:18:33,970
very careful about that

473
00:18:33,970 --> 00:18:37,000
so we construct a very specific zero

474
00:18:37,000 --> 00:18:39,250
knowledge proof to prove this this

475
00:18:39,250 --> 00:18:41,649
statement so this is actually not a

476
00:18:41,649 --> 00:18:43,090
difficult statement to prove because

477
00:18:43,090 --> 00:18:44,830
there are no inverses or anything you

478
00:18:44,830 --> 00:18:48,220
have p p2 actually has X 1 times G

479
00:18:48,220 --> 00:18:50,529
because that's sent in as part of the

480
00:18:50,529 --> 00:18:52,539
iam key exchange and you want to prove

481
00:18:52,539 --> 00:18:54,039
that that's actually the value that's

482
00:18:54,039 --> 00:18:56,260
inside the PI air encryption so it's an

483
00:18:56,260 --> 00:18:57,610
interesting zero knowledge proof because

484
00:18:57,610 --> 00:18:59,919
it bridges between two completely

485
00:18:59,919 --> 00:19:01,690
different worlds you're given an

486
00:19:01,690 --> 00:19:04,720
elliptic curve point x1 times G and you

487
00:19:04,720 --> 00:19:07,059
need to prove that x1 is inside this

488
00:19:07,059 --> 00:19:09,309
prior encryption but it turns out to be

489
00:19:09,309 --> 00:19:11,500
not not so difficult to do not not so

490
00:19:11,500 --> 00:19:13,750
expensive to do that but that's the most

491
00:19:13,750 --> 00:19:16,090
involved part of the entire protocol

492
00:19:16,090 --> 00:19:19,299
that's only done a key generation so

493
00:19:19,299 --> 00:19:20,710
what's the performance of our protocol

494
00:19:20,710 --> 00:19:25,149
we implemented and ran it on Azure with

495
00:19:25,149 --> 00:19:27,309
standard just it's very standard

496
00:19:27,309 --> 00:19:28,809
instances on single core and this is

497
00:19:28,809 --> 00:19:30,570
actually inside a product so it's like a

498
00:19:30,570 --> 00:19:33,370
with a full environment and the parties

499
00:19:33,370 --> 00:19:35,649
communicate over TLS and there are no

500
00:19:35,649 --> 00:19:38,890
shortcuts here and key generation takes

501
00:19:38,890 --> 00:19:41,380
between four point eight and eight and

502
00:19:41,380 --> 00:19:42,850
seven point eight seconds I'll explain

503
00:19:42,850 --> 00:19:45,669
this jump in a second that's done only

504
00:19:45,669 --> 00:19:47,559
once so that's actually very reasonable

505
00:19:47,559 --> 00:19:51,309
and and signing actually takes only tens

506
00:19:51,309 --> 00:19:53,260
of milliseconds you can actually sign a

507
00:19:53,260 --> 00:19:57,130
few hundred ECDSA section signatures a

508
00:19:57,130 --> 00:19:58,870
second using just a single core

509
00:19:58,870 --> 00:20:00,580
obviously if you want higher throughput

510
00:20:00,580 --> 00:20:02,169
then you can simply increase the number

511
00:20:02,169 --> 00:20:04,740
of course latency is what you have here

512
00:20:04,740 --> 00:20:06,160
this is actual

513
00:20:06,160 --> 00:20:07,930
eighty to a hundred times faster than

514
00:20:07,930 --> 00:20:10,690
the previous best protocol so that makes

515
00:20:10,690 --> 00:20:12,400
a very very very difference and in terms

516
00:20:12,400 --> 00:20:13,630
of key generation it's actually

517
00:20:13,630 --> 00:20:15,460
thousands of times faster because the

518
00:20:15,460 --> 00:20:17,520
previous best protocol needed

519
00:20:17,520 --> 00:20:21,070
distributed RSA key generation as part

520
00:20:21,070 --> 00:20:23,050
of the protocol and that's very very

521
00:20:23,050 --> 00:20:26,770
very expensive for in key generation now

522
00:20:26,770 --> 00:20:27,850
why does it jump

523
00:20:27,850 --> 00:20:31,000
why does suddenly the the cost jump when

524
00:20:31,000 --> 00:20:33,550
you go from from the 384-bit curve to

525
00:20:33,550 --> 00:20:35,920
the 521 bit curve the reason is that you

526
00:20:35,920 --> 00:20:38,110
actually need because of this noise that

527
00:20:38,110 --> 00:20:40,240
I mentioned you added you need the prior

528
00:20:40,240 --> 00:20:42,910
key to be at least four times the size

529
00:20:42,910 --> 00:20:47,980
of the group order now we're always

530
00:20:47,980 --> 00:20:51,070
taking 2048-bit payer anyway the modulus

531
00:20:51,070 --> 00:20:52,420
is always going to be that size because

532
00:20:52,420 --> 00:20:54,250
that's the mineral size for security so

533
00:20:54,250 --> 00:20:56,890
for P 256 and P 384 it's it's a 2048-bit

534
00:20:56,890 --> 00:21:00,280
key but at 521 x 4 you have to make it a

535
00:21:00,280 --> 00:21:02,800
little bit bigger but because pi is the

536
00:21:02,800 --> 00:21:04,360
real bottleneck unison so I think image

537
00:21:04,360 --> 00:21:05,980
is making it a little bit bigger 80 bits

538
00:21:05,980 --> 00:21:08,650
bigger actually causes this very big

539
00:21:08,650 --> 00:21:11,230
jump in in in running time especially

540
00:21:11,230 --> 00:21:15,490
for for key generation and and a lot of

541
00:21:15,490 --> 00:21:17,080
work is actually we did a lot of work to

542
00:21:17,080 --> 00:21:19,090
reduce the amount of noise you needed to

543
00:21:19,090 --> 00:21:21,160
add in previous protocols you had to

544
00:21:21,160 --> 00:21:23,020
make it eight times or nine times larger

545
00:21:23,020 --> 00:21:25,030
and that would of course kill everything

546
00:21:25,030 --> 00:21:28,030
and slow it down by a lot so in

547
00:21:28,030 --> 00:21:30,430
conclusion we have a new secure ECDSA

548
00:21:30,430 --> 00:21:32,500
protocol for two parties it's much

549
00:21:32,500 --> 00:21:34,270
simpler than previous protocols because

550
00:21:34,270 --> 00:21:35,380
it doesn't have any of these very

551
00:21:35,380 --> 00:21:36,850
complex there are knowledge per so

552
00:21:36,850 --> 00:21:39,220
distributed RSA key generation and so on

553
00:21:39,220 --> 00:21:40,990
and so forth has efficient key

554
00:21:40,990 --> 00:21:43,270
generation and signing it can run on

555
00:21:43,270 --> 00:21:45,880
services we also it also runs between a

556
00:21:45,880 --> 00:21:47,380
mobile and a server very efficiently

557
00:21:47,380 --> 00:21:49,240
without any problem and it's fast enough

558
00:21:49,240 --> 00:21:50,830
for many applications you could think of

559
00:21:50,830 --> 00:21:53,140
Bitcoin signing if you wanted but key

560
00:21:53,140 --> 00:21:55,840
protection in general and it's fast

561
00:21:55,840 --> 00:21:57,520
enough and works very well in all of

562
00:21:57,520 --> 00:22:00,540
those settings thank you very much

563
00:22:00,540 --> 00:22:02,600
you

