1
00:00:04,860 --> 00:00:06,899
we're trying to construct i/o from

2
00:00:06,899 --> 00:00:08,850
low-degree motors in your map in fact

3
00:00:08,850 --> 00:00:11,639
this is a softer merge between two

4
00:00:11,639 --> 00:00:13,650
papers where in the first paper we

5
00:00:13,650 --> 00:00:16,820
achieve it from five linear maps using

6
00:00:16,820 --> 00:00:20,400
locality v PR g and in a second paper we

7
00:00:20,400 --> 00:00:22,050
in fact a two-front just thrilling

8
00:00:22,050 --> 00:00:24,720
linear map or tri linear map using

9
00:00:24,720 --> 00:00:27,210
localized local PR G's okay I'll tell

10
00:00:27,210 --> 00:00:29,519
you what they are it's the first the

11
00:00:29,519 --> 00:00:30,960
goal here is to construct

12
00:00:30,960 --> 00:00:32,910
indistinguishability of classification

13
00:00:32,910 --> 00:00:35,820
we want to have this type of fat skaters

14
00:00:35,820 --> 00:00:37,949
that can compile circuiting to another

15
00:00:37,949 --> 00:00:40,350
one they have the same functionality but

16
00:00:40,350 --> 00:00:42,150
now the compiled circuit become

17
00:00:42,150 --> 00:00:44,280
unintelligible and here by

18
00:00:44,280 --> 00:00:46,799
unintelligible we mean that the first

19
00:00:46,799 --> 00:00:48,420
case circuit should hide one bit of

20
00:00:48,420 --> 00:00:50,940
information that is which of the

21
00:00:50,940 --> 00:00:53,610
following two equivalent circuit is

22
00:00:53,610 --> 00:00:56,580
being a fast gated by equivalent we mean

23
00:00:56,580 --> 00:00:58,290
that the two circuit shall have the same

24
00:00:58,290 --> 00:01:00,989
size to starways also they shall have

25
00:01:00,989 --> 00:01:03,780
the identical truth table and if that's

26
00:01:03,780 --> 00:01:05,790
the case and we want a fast gated

27
00:01:05,790 --> 00:01:07,320
circuit to be computationally

28
00:01:07,320 --> 00:01:10,230
indistinguishable even though this

29
00:01:10,230 --> 00:01:11,790
notion really hide only one bit of

30
00:01:11,790 --> 00:01:13,970
information it turns out to be extremely

31
00:01:13,970 --> 00:01:17,250
powerful a long line of forecasts shown

32
00:01:17,250 --> 00:01:19,740
that I always edition of some wild

33
00:01:19,740 --> 00:01:21,600
assumption like one way function can

34
00:01:21,600 --> 00:01:24,330
already imply almost all of crypto mania

35
00:01:24,330 --> 00:01:26,850
and beyond and furthermore I seem to

36
00:01:26,850 --> 00:01:29,280
have created a new word of VAS topia

37
00:01:29,280 --> 00:01:31,950
where there are many even more powerful

38
00:01:31,950 --> 00:01:34,530
tool like functional encryption succinct

39
00:01:34,530 --> 00:01:37,680
the gobbling of truly machines etc so

40
00:01:37,680 --> 00:01:39,300
essential question is how can we

41
00:01:39,300 --> 00:01:41,790
construct io and a very successful

42
00:01:41,790 --> 00:01:44,550
paradigm so far is to climb up the

43
00:01:44,550 --> 00:01:47,400
ladder of multi linear maps and at the

44
00:01:47,400 --> 00:01:50,640
bottom of this lab of this ladder are

45
00:01:50,640 --> 00:01:53,640
cyclic groups without always the

46
00:01:53,640 --> 00:01:55,620
bilinear pairing that we all know and

47
00:01:55,620 --> 00:01:57,600
love that we know they have huge

48
00:01:57,600 --> 00:02:01,110
implication in crypto mania when we try

49
00:02:01,110 --> 00:02:04,470
to generalize these cyclic groups to let

50
00:02:04,470 --> 00:02:06,750
them have higher degree pairing and this

51
00:02:06,750 --> 00:02:09,690
will give us multi linear map and multi

52
00:02:09,690 --> 00:02:12,060
linear map or neo bars to do even more

53
00:02:12,060 --> 00:02:14,130
amazing things the simplest exam

54
00:02:14,130 --> 00:02:16,530
hoping that trilinear mob will let us do

55
00:02:16,530 --> 00:02:19,440
full party key exchange and if you turn

56
00:02:19,440 --> 00:02:22,080
the knob of motolinia Verity all the way

57
00:02:22,080 --> 00:02:24,540
up to putting on your degree when you

58
00:02:24,540 --> 00:02:28,110
can IO and a fast opium this is great

59
00:02:28,110 --> 00:02:31,440
the only problem here is that or the

60
00:02:31,440 --> 00:02:33,480
candidate construction of mullet module

61
00:02:33,480 --> 00:02:36,690
in your map so far their security is a

62
00:02:36,690 --> 00:02:38,700
far from what we would like them to have

63
00:02:38,700 --> 00:02:41,600
as demonstrated in multiple attacks

64
00:02:41,600 --> 00:02:44,400
therefore in this work our starting

65
00:02:44,400 --> 00:02:45,960
point is to ask a different question

66
00:02:45,960 --> 00:02:49,110
that is what are the minimum objects

67
00:02:49,110 --> 00:02:51,840
that in fact imply I own what is the

68
00:02:51,840 --> 00:02:53,730
high degree multilinear map they're very

69
00:02:53,730 --> 00:02:56,000
powerful however they're heavy to lift

70
00:02:56,000 --> 00:02:59,130
okay and the hope is that maybe we don't

71
00:02:59,130 --> 00:03:02,850
need it's a full mighty power and as a

72
00:03:02,850 --> 00:03:05,340
wise man once said is that give me a

73
00:03:05,340 --> 00:03:08,040
point to stand and a lever I can lift up

74
00:03:08,040 --> 00:03:10,950
everything the idea here is perhaps we

75
00:03:10,950 --> 00:03:13,080
can lift up those high degree model in

76
00:03:13,080 --> 00:03:15,600
your map using just low degree ones and

77
00:03:15,600 --> 00:03:17,880
in order to do that we'll need the help

78
00:03:17,880 --> 00:03:21,270
of local PR G's which at the surface

79
00:03:21,270 --> 00:03:24,840
seems completely irrelevant and at the

80
00:03:24,840 --> 00:03:27,000
same time we're also trying to seek for

81
00:03:27,000 --> 00:03:28,800
weak assumptions on those multilinear

82
00:03:28,800 --> 00:03:30,780
maps that we can paste the security of

83
00:03:30,780 --> 00:03:34,620
IO on with this paradigm in mind let me

84
00:03:34,620 --> 00:03:36,600
quickly serve it to you the history of

85
00:03:36,600 --> 00:03:38,940
IO construction through the lens of

86
00:03:38,940 --> 00:03:41,670
degree the first generation of

87
00:03:41,670 --> 00:03:43,650
construction always use pre Gnomeo

88
00:03:43,650 --> 00:03:45,510
degree multi linear map or in fact the

89
00:03:45,510 --> 00:03:47,459
stronger variant upgraded encoding

90
00:03:47,459 --> 00:03:49,650
schemes their security are often

91
00:03:49,650 --> 00:03:52,050
analyzed in the ideal model or use the

92
00:03:52,050 --> 00:03:54,390
strong uber assumption with some

93
00:03:54,390 --> 00:03:58,110
exceptions last year that I give the

94
00:03:58,110 --> 00:04:00,390
first construction of IO based on just

95
00:04:00,390 --> 00:04:03,030
constant degree credit encodings with

96
00:04:03,030 --> 00:04:05,010
the same protein H like assumption

97
00:04:05,010 --> 00:04:08,310
called joint sx th and to do that for

98
00:04:08,310 --> 00:04:10,560
the first time the local PRG came into

99
00:04:10,560 --> 00:04:13,470
the picture and in this work in the

100
00:04:13,470 --> 00:04:16,320
first paper we first reduced the

101
00:04:16,320 --> 00:04:18,450
concrete constant degree needed all the

102
00:04:18,450 --> 00:04:21,810
way down to five using a locality v PR g

103
00:04:21,810 --> 00:04:24,000
and also we can the seek

104
00:04:24,000 --> 00:04:26,100
the assumption on the multi linear map

105
00:04:26,100 --> 00:04:29,460
to just a sixth age and the important

106
00:04:29,460 --> 00:04:31,710
feature of this construction is that for

107
00:04:31,710 --> 00:04:33,690
the first time the degree of the multi

108
00:04:33,690 --> 00:04:36,120
linear map depends solely on the

109
00:04:36,120 --> 00:04:38,460
locality of the PRG and they equal

110
00:04:38,460 --> 00:04:40,680
whereas previous construction are not

111
00:04:40,680 --> 00:04:44,310
tight however you know is this tightness

112
00:04:44,310 --> 00:04:46,290
we hit a wall because the located for

113
00:04:46,290 --> 00:04:49,770
PRG simply do not exist and therefore in

114
00:04:49,770 --> 00:04:52,260
the second paper we probably proposed a

115
00:04:52,260 --> 00:04:54,510
new and relaxed notion of locality

116
00:04:54,510 --> 00:04:57,060
called block wise locality and we show

117
00:04:57,060 --> 00:04:59,220
that it's to suffice for constructing IO

118
00:04:59,220 --> 00:05:02,160
and hence give us are you from trial in

119
00:05:02,160 --> 00:05:04,950
your Maps and the block wise localities

120
00:05:04,950 --> 00:05:08,310
3 PR G's and at this point we hit

121
00:05:08,310 --> 00:05:11,490
another wall which is block allocated to

122
00:05:11,490 --> 00:05:13,950
periods unfortunately do not exist and

123
00:05:13,950 --> 00:05:16,560
this bars us from constructing IO from

124
00:05:16,560 --> 00:05:20,070
just by linear maps if I move I want to

125
00:05:20,070 --> 00:05:22,110
mention that the first paper is

126
00:05:22,110 --> 00:05:23,910
concurrent with the work of announced

127
00:05:23,910 --> 00:05:26,310
and shahi the orchestra I'll front

128
00:05:26,310 --> 00:05:28,200
debrief I created encoding schemes

129
00:05:28,200 --> 00:05:31,169
however their security analysis more or

130
00:05:31,169 --> 00:05:33,630
less in the idea model where we only

131
00:05:33,630 --> 00:05:38,610
rely on sx th okay so let me tell you

132
00:05:38,610 --> 00:05:41,130
more formally what we achieve okay so

133
00:05:41,130 --> 00:05:45,120
this object of multi linear map allows

134
00:05:45,120 --> 00:05:47,550
us to really encode the ring elements in

135
00:05:47,550 --> 00:05:49,590
groups by putting them in the exponent

136
00:05:49,590 --> 00:05:51,690
and now we use this bracket notation

137
00:05:51,690 --> 00:05:54,570
here where the element encoded is in the

138
00:05:54,570 --> 00:05:57,180
bracket and the index of the group is in

139
00:05:57,180 --> 00:05:58,370
the lower right corner

140
00:05:58,370 --> 00:06:00,810
such encoding naturally support

141
00:06:00,810 --> 00:06:03,570
homomorphic addition and subtraction and

142
00:06:03,570 --> 00:06:05,970
also allows us to test whether encoding

143
00:06:05,970 --> 00:06:10,140
code 0 or not and the magic is really in

144
00:06:10,140 --> 00:06:12,570
the homomorphic multiplication now we

145
00:06:12,570 --> 00:06:14,460
can take encoding in different groups

146
00:06:14,460 --> 00:06:17,100
and homomorphic we multiply together

147
00:06:17,100 --> 00:06:19,740
encoding the target group of the product

148
00:06:19,740 --> 00:06:22,800
and the degree of the module in your map

149
00:06:22,800 --> 00:06:25,350
is exactly how many encoding is that we

150
00:06:25,350 --> 00:06:27,750
can multiply together in the case of

151
00:06:27,750 --> 00:06:29,790
trial in your map we can multiply

152
00:06:29,790 --> 00:06:32,090
together just three encodings

153
00:06:32,090 --> 00:06:35,370
what about the SX th assumption it's

154
00:06:35,370 --> 00:06:37,289
also racing poets basically

155
00:06:37,289 --> 00:06:39,509
acquiring the basic DTH assumption to

156
00:06:39,509 --> 00:06:41,580
hold in each individual source group

157
00:06:41,580 --> 00:06:45,089
take any source group l we want an

158
00:06:45,089 --> 00:06:47,580
encoding of the TTH type whole a B and a

159
00:06:47,580 --> 00:06:51,089
B to be indistinguishable to encoding of

160
00:06:51,089 --> 00:06:53,369
just random elements and this should

161
00:06:53,369 --> 00:06:55,680
hold even when the generator or source

162
00:06:55,680 --> 00:07:00,149
groups are available okay so the main

163
00:07:00,149 --> 00:07:02,849
theorem in the first paper says that we

164
00:07:02,849 --> 00:07:04,499
can construct a aisle from

165
00:07:04,499 --> 00:07:06,869
sub-exponential a secure sx th

166
00:07:06,869 --> 00:07:09,360
assumption on the greedy model in your

167
00:07:09,360 --> 00:07:12,659
map with the help of a sub exponentially

168
00:07:12,659 --> 00:07:15,809
secure locality dpr g and the

169
00:07:15,809 --> 00:07:19,259
sub-exponential lwe and note that here

170
00:07:19,259 --> 00:07:21,360
the degree of the motolinia map needed

171
00:07:21,360 --> 00:07:24,839
really equals to the locality and the

172
00:07:24,839 --> 00:07:26,789
main theorem in the second paper

173
00:07:26,789 --> 00:07:29,849
basically says we can in fact swap off

174
00:07:29,849 --> 00:07:32,759
this locality DPR G with this weaker

175
00:07:32,759 --> 00:07:36,809
block locality DPR G with these

176
00:07:36,809 --> 00:07:38,879
assumptions now you can just plug in a

177
00:07:38,879 --> 00:07:41,849
locality v PR g to get io from v linear

178
00:07:41,849 --> 00:07:44,580
map plugging a block wise localities 3

179
00:07:44,580 --> 00:07:49,469
PR g to get io from triangle map so what

180
00:07:49,469 --> 00:07:53,039
are those block-wise local PR jeez well

181
00:07:53,039 --> 00:07:56,099
first let us record local PR jeez well

182
00:07:56,099 --> 00:07:58,409
they are now has to expand a seed to a

183
00:07:58,409 --> 00:08:00,240
pseudo random output which is a

184
00:08:00,240 --> 00:08:02,999
pre-nominal a longer and we say a

185
00:08:02,999 --> 00:08:05,430
function has locality L if each

186
00:08:05,430 --> 00:08:07,860
individual alphabet depend on at most

187
00:08:07,860 --> 00:08:10,830
our input bits and there has been a long

188
00:08:10,830 --> 00:08:12,899
line of research studying what is the

189
00:08:12,899 --> 00:08:16,099
lowest locality we need for PR G's

190
00:08:16,099 --> 00:08:19,889
currently for locality 5 we have Canada

191
00:08:19,889 --> 00:08:23,069
construction but for locality for they

192
00:08:23,069 --> 00:08:26,430
do not exist when we go to block wise

193
00:08:26,430 --> 00:08:28,680
locality as the name suggests we're

194
00:08:28,680 --> 00:08:30,779
going to swap each input bit with a

195
00:08:30,779 --> 00:08:33,509
input block restricted to only

196
00:08:33,509 --> 00:08:36,438
containing logarithmic number of bits

197
00:08:36,438 --> 00:08:39,750
now a function has block-wise locality L

198
00:08:39,750 --> 00:08:42,389
if each alphabet depend on only our

199
00:08:42,389 --> 00:08:45,750
input blocks now that such a function

200
00:08:45,750 --> 00:08:48,360
can in fact have very high locality

201
00:08:48,360 --> 00:08:50,850
actual locality but they still has the

202
00:08:50,850 --> 00:08:52,799
special structure of being local way

203
00:08:52,799 --> 00:08:54,929
stories back to the input box and that's

204
00:08:54,929 --> 00:08:59,339
what we can exploit so in the second

205
00:08:59,339 --> 00:09:01,379
paper we get pre the preliminary star

206
00:09:01,379 --> 00:09:04,290
they own block wise local PR G's with

207
00:09:04,290 --> 00:09:06,689
the natural candidate being just used go

208
00:09:06,689 --> 00:09:08,999
where go dragons local function where

209
00:09:08,999 --> 00:09:11,459
input bids are replaced with input

210
00:09:11,459 --> 00:09:15,629
blocks these functions are usually

211
00:09:15,629 --> 00:09:18,959
parameterize dwith bipartite graph there

212
00:09:18,959 --> 00:09:22,319
has exactly degree out and together with

213
00:09:22,319 --> 00:09:24,779
a set of predicates one for each output

214
00:09:24,779 --> 00:09:27,119
bit when you want to evaluate to the

215
00:09:27,119 --> 00:09:29,429
eyes output bill weii you simply take

216
00:09:29,429 --> 00:09:32,369
the eyes predicate and evaluate the only

217
00:09:32,369 --> 00:09:35,160
set of input blocks that correspond to

218
00:09:35,160 --> 00:09:39,049
the neighbor of node I in the graph G

219
00:09:39,049 --> 00:09:41,489
okay so this is a very simple and a

220
00:09:41,489 --> 00:09:43,499
natural construction what can we say

221
00:09:43,499 --> 00:09:45,959
about them it turns out that when the

222
00:09:45,959 --> 00:09:49,350
locality is high enough which is 3 or

223
00:09:49,350 --> 00:09:52,529
above their existence bipartite graph

224
00:09:52,529 --> 00:09:55,679
that have very good expansion and with

225
00:09:55,679 --> 00:09:57,269
this we can show that that there in fact

226
00:09:57,269 --> 00:10:00,299
exists block-wise lucrative three small

227
00:10:00,299 --> 00:10:03,959
bias generator and we can show that this

228
00:10:03,959 --> 00:10:06,709
type of function when you use a suitable

229
00:10:06,709 --> 00:10:10,049
nandi generates predicates they are

230
00:10:10,049 --> 00:10:12,689
assumed already to be one way and the

231
00:10:12,689 --> 00:10:15,059
pseudo-random using non assumption in

232
00:10:15,059 --> 00:10:18,600
the literature of local PR G's and

233
00:10:18,600 --> 00:10:20,999
furthermore we can show some hardness

234
00:10:20,999 --> 00:10:25,519
amplification results this is nice and

235
00:10:25,519 --> 00:10:28,019
suddenly when you go to clockwise

236
00:10:28,019 --> 00:10:31,079
locality equals to two all these

237
00:10:31,079 --> 00:10:33,119
properties go away because they're do

238
00:10:33,119 --> 00:10:36,230
not have we do not have good graph with

239
00:10:36,230 --> 00:10:40,110
good expansion and furthermore it turns

240
00:10:40,110 --> 00:10:43,230
out that two recent work show that such

241
00:10:43,230 --> 00:10:46,889
pure G's do not exist except among a

242
00:10:46,889 --> 00:10:49,529
very very tiny window of expansion that

243
00:10:49,529 --> 00:10:51,480
are not known to be sufficient for

244
00:10:51,480 --> 00:10:55,799
constructing i/o and I do not have much

245
00:10:55,799 --> 00:10:57,569
more time to delve into the block wise

246
00:10:57,569 --> 00:10:59,429
local PRG I think there are very very

247
00:10:59,429 --> 00:11:01,209
natural primitive

248
00:11:01,209 --> 00:11:04,389
deserve more study but in the rest of

249
00:11:04,389 --> 00:11:07,420
the talk our focus on giving you an idea

250
00:11:07,420 --> 00:11:10,360
of how we can construct IO from this

251
00:11:10,360 --> 00:11:13,209
very low degree model in your map with

252
00:11:13,209 --> 00:11:16,800
the help of those block local PR G's and

253
00:11:16,800 --> 00:11:19,569
I will only be able to give you some

254
00:11:19,569 --> 00:11:22,089
flavor or high-level idea of how this is

255
00:11:22,089 --> 00:11:27,129
done okay in order to do so that we will

256
00:11:27,129 --> 00:11:29,350
need to use go through an intermediate

257
00:11:29,350 --> 00:11:31,869
object which is secret key functional

258
00:11:31,869 --> 00:11:34,300
encryption for computing this very

259
00:11:34,300 --> 00:11:36,639
simple computation of only degree D

260
00:11:36,639 --> 00:11:38,949
polynomials and we're needed scheme to

261
00:11:38,949 --> 00:11:40,600
have very good efficiency that were

262
00:11:40,600 --> 00:11:43,480
talked about shortly and for shorter

263
00:11:43,480 --> 00:11:46,929
cordon degree D F&E therefore in the

264
00:11:46,929 --> 00:11:49,329
first step we want to bootstrap from the

265
00:11:49,329 --> 00:11:52,029
greedy EFI over the way to i/o and this

266
00:11:52,029 --> 00:11:53,860
is the place where we need a help of

267
00:11:53,860 --> 00:11:57,309
those PR G's and when we give is the

268
00:11:57,309 --> 00:11:59,410
first tight boots trapping technique

269
00:11:59,410 --> 00:12:01,660
which make sure that the degree of the

270
00:12:01,660 --> 00:12:04,869
efi equals to the locality or the block

271
00:12:04,869 --> 00:12:08,319
locality and the key idea here is

272
00:12:08,319 --> 00:12:12,100
pre-processing and then in the next step

273
00:12:12,100 --> 00:12:14,679
we are implemented those debris Fe that

274
00:12:14,679 --> 00:12:17,350
we need using exactly the greedy model

275
00:12:17,350 --> 00:12:19,869
in your map and here again for the first

276
00:12:19,869 --> 00:12:22,269
time we give a tight affi construction

277
00:12:22,269 --> 00:12:24,129
where the degree of the model in your

278
00:12:24,129 --> 00:12:25,959
map is exactly the degree of the

279
00:12:25,959 --> 00:12:28,389
function we want to compute and the key

280
00:12:28,389 --> 00:12:30,999
idea here is to somehow recursively

281
00:12:30,999 --> 00:12:33,459
compose a very simple primitive

282
00:12:33,459 --> 00:12:35,679
functional encryption that computes only

283
00:12:35,679 --> 00:12:38,319
in the product okay I'll give you some

284
00:12:38,319 --> 00:12:40,360
high-level idea of how each step is done

285
00:12:40,360 --> 00:12:45,189
and let's start with the first so record

286
00:12:45,189 --> 00:12:47,439
a functional encryption are basically

287
00:12:47,439 --> 00:12:49,749
normal encryption scheme but augmented

288
00:12:49,749 --> 00:12:51,819
with this capability of giving partial

289
00:12:51,819 --> 00:12:55,089
decryption keys we can implement we can

290
00:12:55,089 --> 00:12:59,410
encrypt messages as usual but now

291
00:12:59,410 --> 00:13:01,689
additionally we can give out partial

292
00:13:01,689 --> 00:13:03,910
secret key that are associated with some

293
00:13:03,910 --> 00:13:06,910
function or circuit and when decryption

294
00:13:06,910 --> 00:13:09,939
with these partial decryption key what

295
00:13:09,939 --> 00:13:12,339
you get is the output of the functional

296
00:13:12,339 --> 00:13:13,960
circuit evaluate the owner

297
00:13:13,960 --> 00:13:16,030
cryptic message as opposed to the

298
00:13:16,030 --> 00:13:18,790
message yourself and the security

299
00:13:18,790 --> 00:13:22,480
guarantee is that still ciphertex of two

300
00:13:22,480 --> 00:13:24,490
different sets of message should be

301
00:13:24,490 --> 00:13:27,550
indistinguishable even if you are given

302
00:13:27,550 --> 00:13:31,030
with multiple secret keys as long as the

303
00:13:31,030 --> 00:13:33,250
outputs are the same and therefore you

304
00:13:33,250 --> 00:13:38,500
cannot tell just simply by decrypting it

305
00:13:38,500 --> 00:13:40,480
turns out that functional encryption are

306
00:13:40,480 --> 00:13:44,200
intimately connected with Ione as shown

307
00:13:44,200 --> 00:13:46,900
by three elegant work is that give me

308
00:13:46,900 --> 00:13:49,390
one key functional encryption for the

309
00:13:49,390 --> 00:13:52,360
class of NC one computing class of NC 1

310
00:13:52,360 --> 00:13:55,230
function as long as it's compact

311
00:13:55,230 --> 00:13:58,300
we can already construct I'll her

312
00:13:58,300 --> 00:14:00,760
compact means that this heavy scheme

313
00:14:00,760 --> 00:14:03,130
should be mildly efficient that is

314
00:14:03,130 --> 00:14:05,050
encryption algorithm running time

315
00:14:05,050 --> 00:14:07,270
pranaam oohing the message length which

316
00:14:07,270 --> 00:14:09,720
is necessary but also somehow

317
00:14:09,720 --> 00:14:12,610
subliminally in the size of the function

318
00:14:12,610 --> 00:14:16,510
to be computed therefore we really just

319
00:14:16,510 --> 00:14:18,910
need to do bootstrapping of a fee scheme

320
00:14:18,910 --> 00:14:22,210
to go from the greedy Fe to computing a

321
00:14:22,210 --> 00:14:25,210
fee for two to a fee for computing and

322
00:14:25,210 --> 00:14:29,080
c1 functions and here we're needed a

323
00:14:29,080 --> 00:14:31,390
greedy a fee to have really really good

324
00:14:31,390 --> 00:14:33,880
efficiency that is the encryption

325
00:14:33,880 --> 00:14:36,310
algorithm runs just linearly in the

326
00:14:36,310 --> 00:14:38,980
length of the message and completely

327
00:14:38,980 --> 00:14:43,200
independent of the size of the function

328
00:14:43,200 --> 00:14:45,790
alright so how can we do that let's

329
00:14:45,790 --> 00:14:48,490
illustrate the idea with the simple

330
00:14:48,490 --> 00:14:51,310
locality PRG and then later extend to

331
00:14:51,310 --> 00:14:55,480
block wise locality pure G so a natural

332
00:14:55,480 --> 00:14:58,060
idea already appeared in previous work

333
00:14:58,060 --> 00:15:00,880
is to use randomized encoding to reduce

334
00:15:00,880 --> 00:15:04,060
degree what they were enable us to take

335
00:15:04,060 --> 00:15:06,610
ax and c1 function f and represented as

336
00:15:06,610 --> 00:15:10,030
an c0 function denoted as R any of F and

337
00:15:10,030 --> 00:15:12,820
the very useful fact to remember is that

338
00:15:12,820 --> 00:15:15,640
re FF has very small degree can be

339
00:15:15,640 --> 00:15:18,070
computed in degree floor in particular

340
00:15:18,070 --> 00:15:20,410
degree 1 in the input bit and debris 3

341
00:15:20,410 --> 00:15:23,290
in random bits this is great because

342
00:15:23,290 --> 00:15:26,020
then hopefully we can just use the low

343
00:15:26,020 --> 00:15:26,830
degree Fe

344
00:15:26,830 --> 00:15:30,040
compute re of f and we'll be done so

345
00:15:30,040 --> 00:15:34,060
let's see well here in order to encrypt

346
00:15:34,060 --> 00:15:36,520
our ciphertext to encrypt a message at

347
00:15:36,520 --> 00:15:39,040
what we're doing we take the degree D Fe

348
00:15:39,040 --> 00:15:41,560
and encrypt it together with some

349
00:15:41,560 --> 00:15:45,490
randomness and now to give us a quick

350
00:15:45,490 --> 00:15:48,160
key for function f we just need to give

351
00:15:48,160 --> 00:15:50,380
a secret key for a function G that

352
00:15:50,380 --> 00:15:54,280
computes the randomized encoding and the

353
00:15:54,280 --> 00:15:56,260
benefit is that because randomized

354
00:15:56,260 --> 00:15:58,240
encoding can be computed in debrief for

355
00:15:58,240 --> 00:16:02,170
now the degree of that V is just 4 well

356
00:16:02,170 --> 00:16:04,690
of course it cannot be just so easy it

357
00:16:04,690 --> 00:16:06,790
turns out that unfortunately compact

358
00:16:06,790 --> 00:16:10,830
NICs do not hold Y because to encrypt

359
00:16:10,830 --> 00:16:15,100
the input encryption will take time at

360
00:16:15,100 --> 00:16:17,050
least the linear in the input lines

361
00:16:17,050 --> 00:16:19,750
now the input contains the random table

362
00:16:19,750 --> 00:16:21,730
for computing the randomized encoding

363
00:16:21,730 --> 00:16:24,940
which is at least as large as the size

364
00:16:24,940 --> 00:16:27,400
of the function as opposed to be

365
00:16:27,400 --> 00:16:30,340
sublinear okay so we do not have

366
00:16:30,340 --> 00:16:34,120
compactness well to selvedge compactness

367
00:16:34,120 --> 00:16:35,710
and that's why there is to say that I

368
00:16:35,710 --> 00:16:38,500
were not directly encrypt to the random

369
00:16:38,500 --> 00:16:42,040
tip it's on but rather encrypted to the

370
00:16:42,040 --> 00:16:45,100
seed of a PRG so that later on in the

371
00:16:45,100 --> 00:16:47,470
function G it will first take the seed

372
00:16:47,470 --> 00:16:49,750
expanded to see the random output and

373
00:16:49,750 --> 00:16:52,990
then compute the randomized encoding now

374
00:16:52,990 --> 00:16:54,910
believe me with the math is that with

375
00:16:54,910 --> 00:16:56,920
this change now encryption becomes

376
00:16:56,920 --> 00:16:59,980
stably nearly efficient however the

377
00:16:59,980 --> 00:17:01,420
drawback is that the degree of the

378
00:17:01,420 --> 00:17:03,760
functional encryption goes up now you

379
00:17:03,760 --> 00:17:08,290
become 3 times the PRG degree plus 1 why

380
00:17:08,290 --> 00:17:10,900
because Arne has degree 3 in the random

381
00:17:10,900 --> 00:17:13,480
bit and these random bits are now

382
00:17:13,480 --> 00:17:16,900
computed using PR G's and this is only

383
00:17:16,900 --> 00:17:19,720
bounded by 3 times the locality of PR g

384
00:17:19,720 --> 00:17:23,670
plus 1 and this is definitely not tight

385
00:17:23,670 --> 00:17:26,949
to get tight as we boost wrapping our

386
00:17:26,949 --> 00:17:29,260
key idea is to do pre-processing what do

387
00:17:29,260 --> 00:17:31,840
we mean we would like to decompose this

388
00:17:31,840 --> 00:17:34,790
function G into two parts a and

389
00:17:34,790 --> 00:17:37,160
so that a part of the computation

390
00:17:37,160 --> 00:17:39,660
corresponding to function a can already

391
00:17:39,660 --> 00:17:42,090
be done at the encryption time and the

392
00:17:42,090 --> 00:17:43,890
cipher ties encrypts output or function

393
00:17:43,890 --> 00:17:47,070
a and therefore at decryption time we

394
00:17:47,070 --> 00:17:48,660
only need to do the rest of the

395
00:17:48,660 --> 00:17:51,290
computation corresponding to function B

396
00:17:51,290 --> 00:17:53,970
if this can be done then the degree of

397
00:17:53,970 --> 00:17:55,920
functional encryption decreases and

398
00:17:55,920 --> 00:17:57,960
hopefully that will be able to bound a

399
00:17:57,960 --> 00:18:00,750
with the locality of the PRG well the

400
00:18:00,750 --> 00:18:02,640
only constraint is that we must make

401
00:18:02,640 --> 00:18:05,940
sure pre-processing is going to be

402
00:18:05,940 --> 00:18:08,100
compact that is the output of the

403
00:18:08,100 --> 00:18:10,590
function a is the sub linear in the

404
00:18:10,590 --> 00:18:13,200
function size and otherwise you might

405
00:18:13,200 --> 00:18:14,760
well just compute the function G

406
00:18:14,760 --> 00:18:17,850
entirely and you don't need any degree

407
00:18:17,850 --> 00:18:22,050
anymore and the challenge is exactly in

408
00:18:22,050 --> 00:18:24,900
doing pre-processing compactly and let's

409
00:18:24,900 --> 00:18:26,550
see a little bit why this is difficult

410
00:18:26,550 --> 00:18:31,710
to look into the re of F it can be

411
00:18:31,710 --> 00:18:34,050
expanded into a sum of monomials where

412
00:18:34,050 --> 00:18:36,420
each monomial will require multiplying

413
00:18:36,420 --> 00:18:38,720
together three output bits of the PRG

414
00:18:38,720 --> 00:18:41,250
since we're not making an assumption

415
00:18:41,250 --> 00:18:42,990
about the structure of the PRT in the

416
00:18:42,990 --> 00:18:46,700
worst case each output will depend on L

417
00:18:46,700 --> 00:18:50,130
randomly chosen seed elements and let's

418
00:18:50,130 --> 00:18:52,950
pretend that this simply requires

419
00:18:52,950 --> 00:18:54,390
multiplying in those seed element

420
00:18:54,390 --> 00:18:56,370
together and this will be the output bit

421
00:18:56,370 --> 00:18:59,340
this is not really true but really helps

422
00:18:59,340 --> 00:19:02,280
us to see the challenge now to multiply

423
00:19:02,280 --> 00:19:06,060
three PRT output bit is requiring us to

424
00:19:06,060 --> 00:19:09,240
multiply together three times L randomly

425
00:19:09,240 --> 00:19:12,330
chosen seed elements well as you can

426
00:19:12,330 --> 00:19:14,060
intuitively charge is that

427
00:19:14,060 --> 00:19:16,620
multiplication between randomly chosen

428
00:19:16,620 --> 00:19:19,230
elements are very hard to pre-compute

429
00:19:19,230 --> 00:19:21,420
without quickly blowing up the size

430
00:19:21,420 --> 00:19:23,520
because there's not much you can doubt

431
00:19:23,520 --> 00:19:27,210
you can do there's no structure so given

432
00:19:27,210 --> 00:19:29,070
this is difficult we asked the question

433
00:19:29,070 --> 00:19:32,040
what can we pre compute then it reason

434
00:19:32,040 --> 00:19:34,800
why we can't recompute is to multiply

435
00:19:34,800 --> 00:19:37,710
together PRT output bits that depend on

436
00:19:37,710 --> 00:19:41,100
the same random edges but two different

437
00:19:41,100 --> 00:19:45,360
seeds why because now in this huge

438
00:19:45,360 --> 00:19:47,260
product of differences

439
00:19:47,260 --> 00:19:50,200
elements each of the column are in fact

440
00:19:50,200 --> 00:19:53,290
aligned therefore we can pre-compute a

441
00:19:53,290 --> 00:19:56,530
degree three computation between the

442
00:19:56,530 --> 00:19:59,380
same random edges across different seats

443
00:19:59,380 --> 00:20:01,750
and with those pre computed the

444
00:20:01,750 --> 00:20:04,300
monomials we can compute the product of

445
00:20:04,300 --> 00:20:06,880
pure G output using only the locality of

446
00:20:06,880 --> 00:20:10,690
the PRG well it turns out this

447
00:20:10,690 --> 00:20:13,360
observation is enough and with much work

448
00:20:13,360 --> 00:20:15,370
we can massage the function G we want to

449
00:20:15,370 --> 00:20:17,230
compute into this form and therefore

450
00:20:17,230 --> 00:20:19,420
enable pre-processing I don't have time

451
00:20:19,420 --> 00:20:20,980
to go into the details please see the

452
00:20:20,980 --> 00:20:24,130
paper for more detail and now let's just

453
00:20:24,130 --> 00:20:26,590
see that whether this idea also extended

454
00:20:26,590 --> 00:20:28,510
to block locality and a white block

455
00:20:28,510 --> 00:20:31,390
low-cut is enough so the only thing I

456
00:20:31,390 --> 00:20:33,430
change now is that instead of intra bit

457
00:20:33,430 --> 00:20:35,620
we're working with input blocks and the

458
00:20:35,620 --> 00:20:37,780
first difficulty is that each alphabet

459
00:20:37,780 --> 00:20:40,690
itself can no longer be computed by a

460
00:20:40,690 --> 00:20:42,940
low degree or degree error-prone omiyo

461
00:20:42,940 --> 00:20:47,140
is that the degree can be way higher so

462
00:20:47,140 --> 00:20:48,940
the first step of the pre-computation is

463
00:20:48,940 --> 00:20:51,430
that we're just gonna do the brutal way

464
00:20:51,430 --> 00:20:54,370
of compute all the monomials over

465
00:20:54,370 --> 00:20:56,590
elements in each of the block and

466
00:20:56,590 --> 00:20:58,630
luckily because block size are

467
00:20:58,630 --> 00:21:01,150
logarithmic the blow up is controlled

468
00:21:01,150 --> 00:21:03,580
and can be handled and with those

469
00:21:03,580 --> 00:21:06,070
monomials we can now compute each of the

470
00:21:06,070 --> 00:21:08,770
alphabet using a degree L pre-nominal

471
00:21:08,770 --> 00:21:11,770
and now the trick that we just talked

472
00:21:11,770 --> 00:21:15,040
about before with respect to local PRG

473
00:21:15,040 --> 00:21:17,470
come back to apply that we can

474
00:21:17,470 --> 00:21:20,260
pre-compute further the degree three

475
00:21:20,260 --> 00:21:22,510
computation over those pre computed

476
00:21:22,510 --> 00:21:24,960
monomials and never facilitate us

477
00:21:24,960 --> 00:21:28,170
computing the product or PRT outputs

478
00:21:28,170 --> 00:21:31,960
okay with the remaining I don't know how

479
00:21:31,960 --> 00:21:34,780
many minutes and then our try to give

480
00:21:34,780 --> 00:21:37,570
you okay that's enough I'll try to give

481
00:21:37,570 --> 00:21:39,640
you a very high-level flavor how to

482
00:21:39,640 --> 00:21:43,360
construct such degree DfE using exactly

483
00:21:43,360 --> 00:21:47,110
degree deimata linear map let's start

484
00:21:47,110 --> 00:21:49,570
with our thought process or we'll just

485
00:21:49,570 --> 00:21:51,970
only do this or the process that the

486
00:21:51,970 --> 00:21:54,340
only thing I want to compute is a degree

487
00:21:54,340 --> 00:21:58,050
D monomial I want to compute X 1

488
00:21:58,050 --> 00:22:00,570
multiply all the way to X T well

489
00:22:00,570 --> 00:22:05,009
hiding in protects the natural way that

490
00:22:05,009 --> 00:22:06,929
the first thing I am I hear is that well

491
00:22:06,929 --> 00:22:09,659
I have multi linear map let me just

492
00:22:09,659 --> 00:22:12,539
encode this input bits or input elements

493
00:22:12,539 --> 00:22:14,669
using inside the different groups and

494
00:22:14,669 --> 00:22:17,370
the pairing will allow us to compute the

495
00:22:17,370 --> 00:22:20,669
product in the target group and this

496
00:22:20,669 --> 00:22:22,799
world somehow suffice afford the

497
00:22:22,799 --> 00:22:25,200
functionality but security completely

498
00:22:25,200 --> 00:22:27,630
falls apart why because those encodings

499
00:22:27,630 --> 00:22:30,149
really do not hide the input which can

500
00:22:30,149 --> 00:22:32,820
be actually fixed the value in fact we

501
00:22:32,820 --> 00:22:35,549
only assume SX th or multi linear maps

502
00:22:35,549 --> 00:22:37,440
which only give you some security

503
00:22:37,440 --> 00:22:39,389
guarantee when they include the values

504
00:22:39,389 --> 00:22:41,820
are random and this is certainly not

505
00:22:41,820 --> 00:22:44,789
true for input bit so the approach in

506
00:22:44,789 --> 00:22:47,700
previous work is be to have security

507
00:22:47,700 --> 00:22:49,769
we're going to use some they use the

508
00:22:49,769 --> 00:22:51,840
some cryptographic primitive in

509
00:22:51,840 --> 00:22:54,120
particular randomized encoding now they

510
00:22:54,120 --> 00:22:55,679
imagine that instead of forget the

511
00:22:55,679 --> 00:22:57,179
encoding of the input bits you can

512
00:22:57,179 --> 00:22:59,639
encoding of a randomized encoding of

513
00:22:59,639 --> 00:23:02,370
those increments for computing monomial

514
00:23:02,370 --> 00:23:05,700
and then you can simply use pairing to

515
00:23:05,700 --> 00:23:08,490
compute the output the problem now is

516
00:23:08,490 --> 00:23:10,320
how do I get through this randomized

517
00:23:10,320 --> 00:23:12,720
encoding previous work show that it

518
00:23:12,720 --> 00:23:14,100
turns out you collaborated their

519
00:23:14,100 --> 00:23:16,320
structure to just use a simple

520
00:23:16,320 --> 00:23:18,480
functional encryption for computing in a

521
00:23:18,480 --> 00:23:20,669
product to get to this encoding of

522
00:23:20,669 --> 00:23:23,879
randomized encoding the only problem is

523
00:23:23,879 --> 00:23:25,980
that the degree of the multi linear map

524
00:23:25,980 --> 00:23:28,769
over or needed will be two times the

525
00:23:28,769 --> 00:23:31,019
degree of the function as opposed to be

526
00:23:31,019 --> 00:23:34,500
exactly equal so in order to shape of

527
00:23:34,500 --> 00:23:37,350
this degree of two this additional

528
00:23:37,350 --> 00:23:40,379
factor of two we really need to do

529
00:23:40,379 --> 00:23:43,710
computation with every parent we need to

530
00:23:43,710 --> 00:23:45,450
the computation of the function as

531
00:23:45,450 --> 00:23:48,899
opposed to leveraging or computing any

532
00:23:48,899 --> 00:23:51,509
other cryptographic primitive it turns

533
00:23:51,509 --> 00:23:54,299
out that our first and the very naive

534
00:23:54,299 --> 00:23:56,820
intuition is correct except that we're

535
00:23:56,820 --> 00:23:58,769
need to use a better encoding and this

536
00:23:58,769 --> 00:24:01,379
encoding is just a functional encryption

537
00:24:01,379 --> 00:24:04,110
for inner product by recursively

538
00:24:04,110 --> 00:24:07,230
composing it you can implement the first

539
00:24:07,230 --> 00:24:11,340
naive simple idea and there's no degree

540
00:24:11,340 --> 00:24:13,690
waste of degree okay

541
00:24:13,690 --> 00:24:18,490
so let me summarize in this work we with

542
00:24:18,490 --> 00:24:20,650
two papers that and the message is that

543
00:24:20,650 --> 00:24:22,990
we can construct i/o using trilinear

544
00:24:22,990 --> 00:24:26,530
maps and the block wise local localities

545
00:24:26,530 --> 00:24:30,910
through PRG now ahead of us is a very

546
00:24:30,910 --> 00:24:33,130
interesting fork with the question

547
00:24:33,130 --> 00:24:36,030
hanging above the Hadees - there exists

548
00:24:36,030 --> 00:24:39,760
trilinear map or not if they does exist

549
00:24:39,760 --> 00:24:42,580
now we our next destination is Abbas

550
00:24:42,580 --> 00:24:45,970
topia if not then we still live in the

551
00:24:45,970 --> 00:24:49,760
promised land and thank you

552
00:24:49,760 --> 00:24:55,869
[Applause]

