1
00:00:04,840 --> 00:00:07,570
all right so the setting for this talk

2
00:00:07,570 --> 00:00:11,020
is encrypted outsource storage so

3
00:00:11,020 --> 00:00:12,730
imagine you have a clients that has some

4
00:00:12,730 --> 00:00:15,820
key that I've denoted here by k1 and it

5
00:00:15,820 --> 00:00:18,130
encrypts a large volumes of data a bunch

6
00:00:18,130 --> 00:00:21,190
of messages before uploading them some

7
00:00:21,190 --> 00:00:23,680
outsource a storage service perhaps a

8
00:00:23,680 --> 00:00:27,910
cloud service or some backup and because

9
00:00:27,910 --> 00:00:29,020
we're using encryption we're worried

10
00:00:29,020 --> 00:00:30,820
about confidentiality particularly of

11
00:00:30,820 --> 00:00:32,920
our messages and so we don't want to

12
00:00:32,920 --> 00:00:35,440
trust the encryption keys or other

13
00:00:35,440 --> 00:00:36,850
information that can be used to drive

14
00:00:36,850 --> 00:00:39,550
message data to the storage service but

15
00:00:39,550 --> 00:00:40,960
we do you trust the storage service to

16
00:00:40,960 --> 00:00:44,829
store our data for us one thing that we

17
00:00:44,829 --> 00:00:46,059
would like in these settings is the

18
00:00:46,059 --> 00:00:49,750
ability to do key rotation so given our

19
00:00:49,750 --> 00:00:53,290
key k1 we can generate a new key k2 for

20
00:00:53,290 --> 00:00:55,719
a second time period take all of our

21
00:00:55,719 --> 00:00:57,610
ciphertext encrypts under k1 and somehow

22
00:00:57,610 --> 00:01:00,670
convert them to cipher texts which are

23
00:01:00,670 --> 00:01:02,680
encryptions of the messages under the

24
00:01:02,680 --> 00:01:06,940
new key k2 so a key rotation turns out

25
00:01:06,940 --> 00:01:08,890
to be a pretty important property in

26
00:01:08,890 --> 00:01:12,100
practice most pragmatically because

27
00:01:12,100 --> 00:01:14,130
there's a variety of regulatory

28
00:01:14,130 --> 00:01:17,830
regulations that require periodic key

29
00:01:17,830 --> 00:01:20,099
rotations so in the credit card industry

30
00:01:20,099 --> 00:01:23,920
the PCI DSS standard you know requires

31
00:01:23,920 --> 00:01:26,759
this say for encrypting credit card data

32
00:01:26,759 --> 00:01:29,080
more generally you might want this in

33
00:01:29,080 --> 00:01:30,849
the context of post compromise clean up

34
00:01:30,849 --> 00:01:33,700
if k1 was a exfiltrated or you had

35
00:01:33,700 --> 00:01:34,869
concern that it might have been

36
00:01:34,869 --> 00:01:37,000
exfiltrated at some point you'd like to

37
00:01:37,000 --> 00:01:39,429
rotate to new keys and there's plenty of

38
00:01:39,429 --> 00:01:41,410
other good reasons why key rotation is

39
00:01:41,410 --> 00:01:44,649
important so much so that major

40
00:01:44,649 --> 00:01:46,149
companies when they build like

41
00:01:46,149 --> 00:01:48,819
encryption api's for their customers

42
00:01:48,819 --> 00:01:51,130
include key rotation functionality and

43
00:01:51,130 --> 00:01:53,709
workflows specifically to support doing

44
00:01:53,709 --> 00:01:57,729
this efficiently so how do we do a key

45
00:01:57,729 --> 00:01:59,860
rotation well there's a couple obvious

46
00:01:59,860 --> 00:02:01,720
but unsatisfying approaches right the

47
00:02:01,720 --> 00:02:03,340
first and most obvious it's just to send

48
00:02:03,340 --> 00:02:05,410
both keys k1 and k2 up to the storage

49
00:02:05,410 --> 00:02:07,690
service they can decrypt and rip stuff

50
00:02:07,690 --> 00:02:09,520
this isn't satisfying because obviously

51
00:02:09,520 --> 00:02:13,000
we've exposed the keys to a location

52
00:02:13,000 --> 00:02:14,980
where we would like not like it to be

53
00:02:14,980 --> 00:02:17,920
exposed to second trivial approach is

54
00:02:17,920 --> 00:02:18,180
just

55
00:02:18,180 --> 00:02:19,560
download all the ciphertext and do the

56
00:02:19,560 --> 00:02:20,849
ring encryption locally on the client

57
00:02:20,849 --> 00:02:22,530
but there's this obvious performance

58
00:02:22,530 --> 00:02:24,120
concern that if you have large amounts

59
00:02:24,120 --> 00:02:26,280
of data say terabytes of data this is

60
00:02:26,280 --> 00:02:27,659
going to be prohibitively expensive in

61
00:02:27,659 --> 00:02:31,260
terms of performance so in practice what

62
00:02:31,260 --> 00:02:33,569
people do is use what we'll call the

63
00:02:33,569 --> 00:02:35,730
authenticated encryption or a hybrid

64
00:02:35,730 --> 00:02:38,700
approach and that just means that we're

65
00:02:38,700 --> 00:02:40,560
going to have a encryption that's like

66
00:02:40,560 --> 00:02:42,840
two parts right the first part is going

67
00:02:42,840 --> 00:02:45,150
to be an encryption under K one of a

68
00:02:45,150 --> 00:02:48,389
data encryption key that will label as X

69
00:02:48,389 --> 00:02:50,879
and the second portion will be an

70
00:02:50,879 --> 00:02:52,980
encryption of the message under X so

71
00:02:52,980 --> 00:02:54,540
sometimes we refer to these as key

72
00:02:54,540 --> 00:02:55,950
encapsulation mechanisms and data

73
00:02:55,950 --> 00:02:58,049
encapsulation mechanisms or chem Dem

74
00:02:58,049 --> 00:03:01,409
style constructions so this is nice

75
00:03:01,409 --> 00:03:02,969
because when you want to do a rotation

76
00:03:02,969 --> 00:03:05,519
then you can just do a rotation by Rhian

77
00:03:05,519 --> 00:03:08,099
crypting text so you choose a new key k2

78
00:03:08,099 --> 00:03:11,879
you just go fetch this short header this

79
00:03:11,879 --> 00:03:15,209
kem ciphertext C 1 star and then decrypt

80
00:03:15,209 --> 00:03:18,269
that and then ring crypt under the new

81
00:03:18,269 --> 00:03:22,229
key k2 and this is indeed what's being

82
00:03:22,229 --> 00:03:24,690
offered right now by these API as I

83
00:03:24,690 --> 00:03:27,269
mentioned earlier but is ultimately a

84
00:03:27,269 --> 00:03:30,000
little bit unsatisfying in particular

85
00:03:30,000 --> 00:03:32,400
the data encryption key X never changes

86
00:03:32,400 --> 00:03:34,290
and when I first started thinking about

87
00:03:34,290 --> 00:03:35,579
this problem is actually cuz an amazon

88
00:03:35,579 --> 00:03:37,470
engineer came and said hey it's a little

89
00:03:37,470 --> 00:03:38,430
bit weird that we have these key

90
00:03:38,430 --> 00:03:39,959
rotations that aren't actually rotating

91
00:03:39,959 --> 00:03:42,030
all of the secrets underlying the cipher

92
00:03:42,030 --> 00:03:45,389
text so motivated by that same I think

93
00:03:45,389 --> 00:03:46,290
observation

94
00:03:46,290 --> 00:03:48,810
there's a nice prior work by Bonet Louis

95
00:03:48,810 --> 00:03:52,019
Montgomery and Ragan - or I'll refer

96
00:03:52,019 --> 00:03:53,819
them as BLM R and they introduced this

97
00:03:53,819 --> 00:03:55,560
idea of updatable encryption to try to

98
00:03:55,560 --> 00:03:58,319
to achieve this type of key rotation

99
00:03:58,319 --> 00:04:01,319
where all secrets are changed so they

100
00:04:01,319 --> 00:04:03,299
also use a cam dem style construction

101
00:04:03,299 --> 00:04:06,569
where they have a encryption of dem key

102
00:04:06,569 --> 00:04:09,000
under using some kind of standard

103
00:04:09,000 --> 00:04:11,280
symmetric encryption but then the data

104
00:04:11,280 --> 00:04:13,139
encapsulation portion is a little bit

105
00:04:13,139 --> 00:04:15,030
unique they use what's called a key

106
00:04:15,030 --> 00:04:17,459
homomorphic PRG or pseudo-random

107
00:04:17,459 --> 00:04:19,470
generator that has some special

108
00:04:19,470 --> 00:04:24,120
properties so G takes a seed X and maps

109
00:04:24,120 --> 00:04:27,240
it to a group element in a way that has

110
00:04:27,240 --> 00:04:28,060
this additional home

111
00:04:28,060 --> 00:04:30,070
morphism property that you can take G of

112
00:04:30,070 --> 00:04:32,500
X plus G of X prime for some other seed

113
00:04:32,500 --> 00:04:35,290
X Prime and this is equal to G of X XOR

114
00:04:35,290 --> 00:04:38,470
X Prime and in turn you can build these

115
00:04:38,470 --> 00:04:40,600
from key homomorphic prfs and in fact

116
00:04:40,600 --> 00:04:42,639
the BLM our paper was primarily about

117
00:04:42,639 --> 00:04:45,610
how to build a Kehoe morphic PRF in the

118
00:04:45,610 --> 00:04:48,130
standard model and this is the update of

119
00:04:48,130 --> 00:04:49,330
encryption was just like one component

120
00:04:49,330 --> 00:04:52,960
to that much broader paper so do a

121
00:04:52,960 --> 00:04:54,280
rotation now we can do something

122
00:04:54,280 --> 00:04:55,630
interesting which is that you get back

123
00:04:55,630 --> 00:04:57,580
this time to a or C 1 star you can use

124
00:04:57,580 --> 00:04:59,830
that to recover X you can sample a new

125
00:04:59,830 --> 00:05:02,200
data and capsule Kate encapsulation key

126
00:05:02,200 --> 00:05:05,560
X Prime and then send back to the server

127
00:05:05,560 --> 00:05:08,200
now a new header C 2 Star Plus this

128
00:05:08,200 --> 00:05:10,120
Delta token which is the XOR of X x

129
00:05:10,120 --> 00:05:12,790
squared X Prime and the server can then

130
00:05:12,790 --> 00:05:14,620
kind of rotate the data encapsulation

131
00:05:14,620 --> 00:05:17,320
key by adding to the portion of the

132
00:05:17,320 --> 00:05:21,310
ciphertext C 1 this G of Delta and by

133
00:05:21,310 --> 00:05:22,870
applying the home morphism property you

134
00:05:22,870 --> 00:05:26,229
see that C 1 this is plus G of Delta is

135
00:05:26,229 --> 00:05:29,380
indeed equal to G of X prime plus m and

136
00:05:29,380 --> 00:05:30,760
so we've effectively rotated all the

137
00:05:30,760 --> 00:05:34,390
secrets so that's nice refresh is

138
00:05:34,390 --> 00:05:35,770
everything it has low bandwidth cost

139
00:05:35,770 --> 00:05:37,600
because C 1 star and C 2 star and Delta

140
00:05:37,600 --> 00:05:40,479
are compact but it requires quite a

141
00:05:40,479 --> 00:05:41,800
number of exponentiations

142
00:05:41,800 --> 00:05:43,930
because you're using like asymmetric

143
00:05:43,930 --> 00:05:46,539
crypto mechanisms underneath these

144
00:05:46,539 --> 00:05:50,320
keyhole morphic PRG and i should mention

145
00:05:50,320 --> 00:05:52,479
also that they focus primarily on ind

146
00:05:52,479 --> 00:05:54,220
CPA style encryption so they weren't

147
00:05:54,220 --> 00:05:56,410
worried about authentication or C text

148
00:05:56,410 --> 00:05:59,289
and so they were just using ID CPA

149
00:05:59,289 --> 00:06:00,280
encryption for this this will be

150
00:06:00,280 --> 00:06:03,580
important in a few minutes so status

151
00:06:03,580 --> 00:06:08,729
before our work on key rotation is that

152
00:06:08,729 --> 00:06:10,750
we have these naive schemes that are

153
00:06:10,750 --> 00:06:13,570
ultimately unsatisfying we have a scheme

154
00:06:13,570 --> 00:06:15,280
that's used in practice that has had no

155
00:06:15,280 --> 00:06:17,169
formal security analysis and it's not

156
00:06:17,169 --> 00:06:18,970
exactly clear what security is achieves

157
00:06:18,970 --> 00:06:21,910
and in particular it's not really it

158
00:06:21,910 --> 00:06:24,820
wasn't really clear what we forgo by not

159
00:06:24,820 --> 00:06:26,860
having complete rotation like what type

160
00:06:26,860 --> 00:06:30,430
of attacks arise because of this and

161
00:06:30,430 --> 00:06:32,080
then we had this nice work by BLM r15

162
00:06:32,080 --> 00:06:34,720
that targeted chosen plaintext attack

163
00:06:34,720 --> 00:06:37,330
security and they provided a notion of

164
00:06:37,330 --> 00:06:41,260
Ind CPA that lifts ID CPA to this

165
00:06:41,260 --> 00:06:44,830
station setting and also a notion of

166
00:06:44,830 --> 00:06:46,270
ciphertext independence that I won't

167
00:06:46,270 --> 00:06:47,860
come to too much details on but tries to

168
00:06:47,860 --> 00:06:49,180
capture this idea that you're refreshing

169
00:06:49,180 --> 00:06:51,790
all the secrets so we look at this and

170
00:06:51,790 --> 00:06:54,700
saw well one it's clear that we can

171
00:06:54,700 --> 00:06:55,810
probably achieve stronger security

172
00:06:55,810 --> 00:06:57,310
notions than what they are achieving

173
00:06:57,310 --> 00:07:00,250
we've wanted to also treat

174
00:07:00,250 --> 00:07:02,560
authentication so we need in practice

175
00:07:02,560 --> 00:07:04,420
top and key encryption not just ID CPA

176
00:07:04,420 --> 00:07:08,170
security and there was also a subtle bug

177
00:07:08,170 --> 00:07:10,510
in the proof sketch of a bind ECPA from

178
00:07:10,510 --> 00:07:12,880
the BLM ar-15 scheme that I just showed

179
00:07:12,880 --> 00:07:15,090
and so we wanted to fix that as well and

180
00:07:15,090 --> 00:07:17,080
finally there's a question of whether

181
00:07:17,080 --> 00:07:19,090
these schemes that use a kind of more

182
00:07:19,090 --> 00:07:20,290
expensive operations can be made

183
00:07:20,290 --> 00:07:21,940
practical or is this really going to be

184
00:07:21,940 --> 00:07:24,910
too prohibitive in practice so in our

185
00:07:24,910 --> 00:07:27,880
work we give a treatment of a key

186
00:07:27,880 --> 00:07:28,960
rotation for symmetric encryption

187
00:07:28,960 --> 00:07:30,810
including authenticate encryption and

188
00:07:30,810 --> 00:07:32,830
introduced three new security notions

189
00:07:32,830 --> 00:07:34,660
and up by Adi notion that's stronger

190
00:07:34,660 --> 00:07:38,080
than BLM ar-15s a CTX notion that

191
00:07:38,080 --> 00:07:39,310
captures authenticity goals in this

192
00:07:39,310 --> 00:07:42,190
setting and then a so-called re-encrypt

193
00:07:42,190 --> 00:07:44,860
indistinguishability notion that is in

194
00:07:44,860 --> 00:07:47,560
our art belief is this bit more

195
00:07:47,560 --> 00:07:48,520
intuitive than the cipher text

196
00:07:48,520 --> 00:07:50,320
independence notion and it also captures

197
00:07:50,320 --> 00:07:52,990
a much broader class of attacks and then

198
00:07:52,990 --> 00:07:54,550
we use this to analyze both old new

199
00:07:54,550 --> 00:07:56,380
schemes and perhaps most nervously

200
00:07:56,380 --> 00:07:59,830
introduced two new schemes one called

201
00:07:59,830 --> 00:08:01,840
KSS that doesn't achieve up reading

202
00:08:01,840 --> 00:08:03,280
crypt security but is very fast

203
00:08:03,280 --> 00:08:06,340
and another recruit which is a variant

204
00:08:06,340 --> 00:08:08,440
of the BMR scheme that repairs the

205
00:08:08,440 --> 00:08:10,000
issues from before but also extends it

206
00:08:10,000 --> 00:08:13,120
to meet our stronger security goals now

207
00:08:13,120 --> 00:08:15,730
sort of embarrassingly just last week

208
00:08:15,730 --> 00:08:17,950
joseph Yaeger found a bug and some of

209
00:08:17,950 --> 00:08:20,530
our proofs for UPSI text and this

210
00:08:20,530 --> 00:08:24,190
actually invalidates the security of the

211
00:08:24,190 --> 00:08:26,200
schemes for KSS recraft as in the

212
00:08:26,200 --> 00:08:29,200
context of c text as given in the camera

213
00:08:29,200 --> 00:08:31,300
D so that's kind of a bummer but Joseph

214
00:08:31,300 --> 00:08:32,530
is very nice to point this out to us

215
00:08:32,530 --> 00:08:34,809
we've we have fixes for the schemes and

216
00:08:34,809 --> 00:08:36,640
are working on a write-up qualitatively

217
00:08:36,640 --> 00:08:39,809
it shouldn't change the result takeaways

218
00:08:39,809 --> 00:08:42,909
from the paper but we'll be putting that

219
00:08:42,909 --> 00:08:45,640
up on ePrint very shortly and for that

220
00:08:45,640 --> 00:08:49,210
reason I'll be focusing just on the CPA

221
00:08:49,210 --> 00:08:50,580
kind of portions

222
00:08:50,580 --> 00:08:54,420
of our work yeah didn't mean that to be

223
00:08:54,420 --> 00:08:57,050
a joke but I can see why that's funny

224
00:08:57,050 --> 00:09:00,180
and and also because I didn't have time

225
00:09:00,180 --> 00:09:02,190
that's the real reason yeah okay so

226
00:09:02,190 --> 00:09:04,590
we'll go through these each in turn so

227
00:09:04,590 --> 00:09:07,560
to fix some notation an updatable AE

228
00:09:07,560 --> 00:09:10,590
scheme is you know combines the basic

229
00:09:10,590 --> 00:09:12,210
three algorithms that were used to keep

230
00:09:12,210 --> 00:09:14,040
generation encryption/decryption with a

231
00:09:14,040 --> 00:09:16,260
rekey generation algorithm that takes

232
00:09:16,260 --> 00:09:19,230
two keys ki KJ and a ciphertext header

233
00:09:19,230 --> 00:09:22,470
CI star and then generates a new an

234
00:09:22,470 --> 00:09:24,210
update token that can then be in turn

235
00:09:24,210 --> 00:09:26,250
used with a rien krypton algorithm to

236
00:09:26,250 --> 00:09:28,970
rotate the key underlying a ciphertext

237
00:09:28,970 --> 00:09:31,400
and this kind of gives us the the writes

238
00:09:31,400 --> 00:09:34,230
syntax semantics and say this is

239
00:09:34,230 --> 00:09:36,720
building off the BLM our formalization

240
00:09:36,720 --> 00:09:39,060
as well so you can encrypt something you

241
00:09:39,060 --> 00:09:42,600
can generate a rekey token using it use

242
00:09:42,600 --> 00:09:44,490
rien krypton and then successfully

243
00:09:44,490 --> 00:09:47,340
decrypt the resulting ciphertext under

244
00:09:47,340 --> 00:09:49,590
the key to which it was rotated and we

245
00:09:49,590 --> 00:09:51,360
have a formalized correctness conditions

246
00:09:51,360 --> 00:09:54,480
for all this in the paper in terms of

247
00:09:54,480 --> 00:09:56,820
confidentiality introduced a new kind of

248
00:09:56,820 --> 00:09:58,730
class of definitions all based on a

249
00:09:58,730 --> 00:10:01,200
relatively complicated at least looking

250
00:10:01,200 --> 00:10:05,190
a security game called up IND this is a

251
00:10:05,190 --> 00:10:06,210
kind of left or right

252
00:10:06,210 --> 00:10:08,820
indistinguishability notion for chosen

253
00:10:08,820 --> 00:10:12,480
plaintext attacks we generate a bunch of

254
00:10:12,480 --> 00:10:14,400
different keys in fact there's two sets

255
00:10:14,400 --> 00:10:16,050
of keys ones that are going to be

256
00:10:16,050 --> 00:10:17,700
uncompromised and then ones that are

257
00:10:17,700 --> 00:10:19,800
actually explicitly handed over directly

258
00:10:19,800 --> 00:10:22,770
to the attacker and then the goal of the

259
00:10:22,770 --> 00:10:24,840
adversary is to you know query a

260
00:10:24,840 --> 00:10:26,990
challenge lr Oracle here at the bottom

261
00:10:26,990 --> 00:10:30,920
with two messages to one of the

262
00:10:30,920 --> 00:10:33,330
uncompromised keys and get back an

263
00:10:33,330 --> 00:10:34,560
encryption of one of the two messages

264
00:10:34,560 --> 00:10:38,010
chosen at random and try to figure out

265
00:10:38,010 --> 00:10:40,740
what this bit B is the additionally the

266
00:10:40,740 --> 00:10:41,850
adversary has access to all these other

267
00:10:41,850 --> 00:10:43,110
Oracle's like a regular encryption

268
00:10:43,110 --> 00:10:44,730
Oracle get examples of encryptions that

269
00:10:44,730 --> 00:10:46,830
aren't challenging shion's rekey

270
00:10:46,830 --> 00:10:49,830
generation andrey encryptions now it to

271
00:10:49,830 --> 00:10:51,300
be very careful here to avoid trivial

272
00:10:51,300 --> 00:10:54,480
wins right if you query the lr Oracle on

273
00:10:54,480 --> 00:10:56,610
an uncompromised key but then

274
00:10:56,610 --> 00:10:58,710
immediately can go get a rien ssin

275
00:10:58,710 --> 00:11:01,560
of that ciphertext to a compromised key

276
00:11:01,560 --> 00:11:03,210
one of these ones that's handed to the

277
00:11:03,210 --> 00:11:04,230
adversary directly

278
00:11:04,230 --> 00:11:05,340
there's going to be a problem right

279
00:11:05,340 --> 00:11:07,320
you're gonna win trivially so we spent a

280
00:11:07,320 --> 00:11:08,550
lot of time trying to figure out exactly

281
00:11:08,550 --> 00:11:12,180
how to formalize what our valid and

282
00:11:12,180 --> 00:11:14,130
invalid queries that should be allowed

283
00:11:14,130 --> 00:11:16,530
to rekey generally encrypt and so we

284
00:11:16,530 --> 00:11:17,790
give these predicates these invalidity

285
00:11:17,790 --> 00:11:20,250
predicates that define exactly that and

286
00:11:20,250 --> 00:11:21,240
we spend a lot of time trying to make

287
00:11:21,240 --> 00:11:23,160
the most permissive invalidity

288
00:11:23,160 --> 00:11:26,060
predicates that we could come up with

289
00:11:26,060 --> 00:11:28,830
the BL mark competency line ocean

290
00:11:28,830 --> 00:11:30,810
actually ends up being captured in this

291
00:11:30,810 --> 00:11:32,370
framework we just have much stricter

292
00:11:32,370 --> 00:11:34,080
invalidity procedures that rule out any

293
00:11:34,080 --> 00:11:36,140
queries to compromise keys and

294
00:11:36,140 --> 00:11:40,140
additionally doesn't they don't return a

295
00:11:40,140 --> 00:11:43,200
ciphertext header on an invalid Riaan

296
00:11:43,200 --> 00:11:47,130
Krypton query this last thing turns out

297
00:11:47,130 --> 00:11:48,540
to be something that was kind of

298
00:11:48,540 --> 00:11:50,700
interesting to us because it surfaced a

299
00:11:50,700 --> 00:11:52,350
compromised scenario that we hadn't

300
00:11:52,350 --> 00:11:56,160
thought of before and in fact allow

301
00:11:56,160 --> 00:11:57,780
showing that in our model least things

302
00:11:57,780 --> 00:12:00,060
like a hybrid don't even meet this up

303
00:12:00,060 --> 00:12:02,310
ind security notion so let me just go

304
00:12:02,310 --> 00:12:04,410
over that very briefly so remember I

305
00:12:04,410 --> 00:12:06,150
hybrid is just this Camden thing where

306
00:12:06,150 --> 00:12:08,190
we encrypted a dating cap station key X

307
00:12:08,190 --> 00:12:10,290
under our key K and then the message

308
00:12:10,290 --> 00:12:12,930
under X and in this context our

309
00:12:12,930 --> 00:12:16,470
adversary can do the following query the

310
00:12:16,470 --> 00:12:18,600
Left writes Oracle to get a challenge

311
00:12:18,600 --> 00:12:22,110
ciphertext query a Rhian ssin now

312
00:12:22,110 --> 00:12:26,670
to RIA news to a compromised key so T

313
00:12:26,670 --> 00:12:27,990
plus one so this is one of the ones

314
00:12:27,990 --> 00:12:31,380
that's given to the attacker and at this

315
00:12:31,380 --> 00:12:33,090
point the involuted procedure will say

316
00:12:33,090 --> 00:12:34,470
oh this is kind of an invalid query

317
00:12:34,470 --> 00:12:35,910
because you're rotating a challenge

318
00:12:35,910 --> 00:12:38,670
ciphertext to a compromised key but

319
00:12:38,670 --> 00:12:40,680
because we're being very permissive

320
00:12:40,680 --> 00:12:43,290
we're gonna give back the header C in

321
00:12:43,290 --> 00:12:46,500
this case C T plus one star okay but

322
00:12:46,500 --> 00:12:47,970
that's just an encryption under K T plus

323
00:12:47,970 --> 00:12:51,180
one and for this scheme of X and so we

324
00:12:51,180 --> 00:12:52,500
have the key there so we can just

325
00:12:52,500 --> 00:12:55,260
decrypt and get back X and then recover

326
00:12:55,260 --> 00:13:00,630
from C 1 M sub B and win there so the

327
00:13:00,630 --> 00:13:02,940
sense of being sort of perhaps in

328
00:13:02,940 --> 00:13:04,680
practice esoteric compromised setting

329
00:13:04,680 --> 00:13:06,300
because you need a certain combination

330
00:13:06,300 --> 00:13:08,190
of values but it is interesting to us

331
00:13:08,190 --> 00:13:10,110
that this got surfaced from exploring

332
00:13:10,110 --> 00:13:12,210
these definitions formally and it turns

333
00:13:12,210 --> 00:13:14,330
out that we can actually achieve this

334
00:13:14,330 --> 00:13:16,740
security achieve security and avoid

335
00:13:16,740 --> 00:13:17,760
these types of attacks

336
00:13:17,760 --> 00:13:20,210
but I pretty simple change to a hybrid

337
00:13:20,210 --> 00:13:24,090
so the that change is what we call a

338
00:13:24,090 --> 00:13:26,400
chem down with secret sharing the basic

339
00:13:26,400 --> 00:13:29,640
problem with the security in our model

340
00:13:29,640 --> 00:13:32,100
from four is that you if you get this

341
00:13:32,100 --> 00:13:34,020
compromised header header for a

342
00:13:34,020 --> 00:13:35,400
compromised key that's enough to reveal

343
00:13:35,400 --> 00:13:37,110
the data encapsulation key completely

344
00:13:37,110 --> 00:13:40,440
and so what we can do is prevent that by

345
00:13:40,440 --> 00:13:42,390
doing a kind of secret share of the data

346
00:13:42,390 --> 00:13:43,920
encapsulation key across the two

347
00:13:43,920 --> 00:13:46,380
portions of the ciphertext so now we

348
00:13:46,380 --> 00:13:50,280
sample an x and a y we store inside the

349
00:13:50,280 --> 00:13:53,940
key encapsulation an X X or Y and store

350
00:13:53,940 --> 00:13:55,230
Y with the other portion of the

351
00:13:55,230 --> 00:13:57,750
ciphertext and this is just like I said

352
00:13:57,750 --> 00:13:59,490
simple secret sharing scheme when we do

353
00:13:59,490 --> 00:14:02,520
wreaking generation we can get back the

354
00:14:02,520 --> 00:14:05,070
header decrypt it to get back this X or

355
00:14:05,070 --> 00:14:08,040
X X or Y we can sample new Y Prime kind

356
00:14:08,040 --> 00:14:10,890
of refresh the secret share by X or Y

357
00:14:10,890 --> 00:14:13,200
Prime into X sending Y prime as well

358
00:14:13,200 --> 00:14:15,240
over to the storage service and

359
00:14:15,240 --> 00:14:18,480
refreshing on that side as well so it

360
00:14:18,480 --> 00:14:20,790
turns out we can prove that this is a PI

361
00:14:20,790 --> 00:14:22,740
and D secure and it really has a very

362
00:14:22,740 --> 00:14:24,900
small overhead compared to a hybrid it's

363
00:14:24,900 --> 00:14:26,640
just the addition of these small X ORS

364
00:14:26,640 --> 00:14:30,150
that are you know say 128 bits but note

365
00:14:30,150 --> 00:14:32,310
that the data encryption key here is

366
00:14:32,310 --> 00:14:34,320
still never rotated okay so we're still

367
00:14:34,320 --> 00:14:35,670
kind of in the same fundamental place

368
00:14:35,670 --> 00:14:39,840
that X is is never rotated and this begs

369
00:14:39,840 --> 00:14:42,180
the question of what we're giving up

370
00:14:42,180 --> 00:14:44,190
basically by having schemes that say are

371
00:14:44,190 --> 00:14:47,550
just up ind secure and not refreshing

372
00:14:47,550 --> 00:14:50,550
all the secrets underlying ciphertext so

373
00:14:50,550 --> 00:14:51,870
we spent a lot of time trying to figure

374
00:14:51,870 --> 00:14:54,720
out what our interesting attack models

375
00:14:54,720 --> 00:14:56,280
that can take advantage of this lack of

376
00:14:56,280 --> 00:14:58,050
Refresh of the data encapsulation key it

377
00:14:58,050 --> 00:15:00,570
wasn't at all clear to begin with and we

378
00:15:00,570 --> 00:15:02,160
came up with a few different things and

379
00:15:02,160 --> 00:15:03,330
I'll explain just one exfiltration

380
00:15:03,330 --> 00:15:05,280
attack scenario that seems to be

381
00:15:05,280 --> 00:15:08,580
important for this property so imagine

382
00:15:08,580 --> 00:15:09,690
you having a time period one and we'll

383
00:15:09,690 --> 00:15:11,160
just do this in the context a hybrid a

384
00:15:11,160 --> 00:15:13,680
little bit simpler but the same thing

385
00:15:13,680 --> 00:15:16,380
applies to KSS in the first time period

386
00:15:16,380 --> 00:15:18,780
the attackers say compromises both gets

387
00:15:18,780 --> 00:15:20,880
access to both k1 as well as a full

388
00:15:20,880 --> 00:15:23,160
ciphertext and at this point perhaps

389
00:15:23,160 --> 00:15:25,680
because he's under in this time period

390
00:15:25,680 --> 00:15:27,900
some type of constraints about how much

391
00:15:27,900 --> 00:15:29,730
data he can exit rate context will trade

392
00:15:29,730 --> 00:15:31,110
the whole message but you can get out

393
00:15:31,110 --> 00:15:31,590
some small

394
00:15:31,590 --> 00:15:35,100
all secret that allows him to output the

395
00:15:35,100 --> 00:15:38,670
data encapsulation key X and then later

396
00:15:38,670 --> 00:15:40,230
if we do a rotation say cleaning up

397
00:15:40,230 --> 00:15:42,930
after that compromise and moving to a

398
00:15:42,930 --> 00:15:45,660
new key k2 and the average say later on

399
00:15:45,660 --> 00:15:47,640
gets access now just to the cipher text

400
00:15:47,640 --> 00:15:49,650
but not k2 we've done better jobs

401
00:15:49,650 --> 00:15:53,550
securing our key k2 nevertheless this x

402
00:15:53,550 --> 00:15:55,350
value is still enough to recover the

403
00:15:55,350 --> 00:15:56,970
message right because we haven't rotated

404
00:15:56,970 --> 00:16:01,650
that key so this type of we'd like to

405
00:16:01,650 --> 00:16:03,090
have security models that deal with this

406
00:16:03,090 --> 00:16:05,040
type of attacks as well and so we

407
00:16:05,040 --> 00:16:07,050
introduced this reintroduction in

408
00:16:07,050 --> 00:16:09,120
distinguishability notion that speaks to

409
00:16:09,120 --> 00:16:10,970
it and it's basically a strengthening of

410
00:16:10,970 --> 00:16:13,260
or it's stronger than the cipher text in

411
00:16:13,260 --> 00:16:17,070
panis notion from the LMR and I'll just

412
00:16:17,070 --> 00:16:20,850
again give some intuition about why what

413
00:16:20,850 --> 00:16:23,190
did it what it's doing for us so it's

414
00:16:23,190 --> 00:16:26,030
again used using some type of game to

415
00:16:26,030 --> 00:16:28,560
formalize security and instead of having

416
00:16:28,560 --> 00:16:30,930
left-to-right challenge Oracle that you

417
00:16:30,930 --> 00:16:32,580
query to different messages - we're

418
00:16:32,580 --> 00:16:34,080
gonna have a left or right re encryption

419
00:16:34,080 --> 00:16:35,790
Oracle that we can query two different

420
00:16:35,790 --> 00:16:39,480
cipher texts - and the idea is that the

421
00:16:39,480 --> 00:16:41,130
attacker Shenfield tell which of the two

422
00:16:41,130 --> 00:16:42,870
cipher texts was actually Rhian cryptid

423
00:16:42,870 --> 00:16:46,770
okay the intuition for why this is and

424
00:16:46,770 --> 00:16:47,760
we have all the same problems with

425
00:16:47,760 --> 00:16:49,560
invalidity predicates and there's other

426
00:16:49,560 --> 00:16:51,090
Oracle's which I'm not showing here the

427
00:16:51,090 --> 00:16:52,920
rekey generation and re-encrypted

428
00:16:52,920 --> 00:16:56,010
encryption stuff so the intuition is

429
00:16:56,010 --> 00:16:57,510
that basically we want to capture an

430
00:16:57,510 --> 00:17:00,900
idea in in which I don't know if that

431
00:17:00,900 --> 00:17:03,960
was in which the ciphertext basically

432
00:17:03,960 --> 00:17:05,760
from one time period is useless to an

433
00:17:05,760 --> 00:17:08,430
attacker in the next time period and

434
00:17:08,430 --> 00:17:11,280
this captures that because the attacker

435
00:17:11,280 --> 00:17:13,230
can't even tell which ciphertext was

436
00:17:13,230 --> 00:17:17,040
used from one period in the rotation and

437
00:17:17,040 --> 00:17:18,180
in particular it rules out these

438
00:17:18,180 --> 00:17:20,609
exfiltration attacks so the question is

439
00:17:20,609 --> 00:17:22,740
can we then you know achieve both up int

440
00:17:22,740 --> 00:17:24,060
security as well as its uh pre

441
00:17:24,060 --> 00:17:26,520
encryption security and the natural

442
00:17:26,520 --> 00:17:28,680
starting point for that is the BLM our

443
00:17:28,680 --> 00:17:30,150
scheme that uses this key homomorphic

444
00:17:30,150 --> 00:17:32,880
PRG but as I mentioned briefly before

445
00:17:32,880 --> 00:17:35,340
there's a bug in the proof and it turns

446
00:17:35,340 --> 00:17:37,710
out it's not even up ind CPA and this

447
00:17:37,710 --> 00:17:40,140
turns out to be someone easy to fix but

448
00:17:40,140 --> 00:17:41,220
technically it was kind of interesting

449
00:17:41,220 --> 00:17:42,870
understanding this bug so let me go over

450
00:17:42,870 --> 00:17:43,710
it

451
00:17:43,710 --> 00:17:48,000
very quickly so call the BMR schemes

452
00:17:48,000 --> 00:17:51,750
unprovable the BMR schemes secure scheme

453
00:17:51,750 --> 00:17:54,000
is using this cam Demps style thing with

454
00:17:54,000 --> 00:17:56,399
this key homework PRG and this allows

455
00:17:56,399 --> 00:17:59,159
updates by exploiting the homomorphism

456
00:17:59,159 --> 00:18:03,990
properties of the PRG as they put in

457
00:18:03,990 --> 00:18:06,179
their paper basically the theorem that

458
00:18:06,179 --> 00:18:07,649
you know a high level is saying that you

459
00:18:07,649 --> 00:18:12,000
know if e the chem encryption is ind CPA

460
00:18:12,000 --> 00:18:14,700
and Jesus secure PRG then the scheme is

461
00:18:14,700 --> 00:18:18,659
meets this up ind CPA security so it

462
00:18:18,659 --> 00:18:20,610
turns out this is problematic and

463
00:18:20,610 --> 00:18:23,640
particularly because in the security

464
00:18:23,640 --> 00:18:25,399
games both in their paper and in ours

465
00:18:25,399 --> 00:18:27,659
the adversary gets access to rekey

466
00:18:27,659 --> 00:18:30,149
generation Oracle's which means that in

467
00:18:30,149 --> 00:18:32,010
particular they can mount a kind of

468
00:18:32,010 --> 00:18:34,710
chosen ciphertext attack against the

469
00:18:34,710 --> 00:18:38,789
underlying kemon krypton e and so ID CPA

470
00:18:38,789 --> 00:18:41,039
doesn't seem like it should be enough to

471
00:18:41,039 --> 00:18:43,260
prove security so that was easy to

472
00:18:43,260 --> 00:18:44,279
understand but trying to figure out

473
00:18:44,279 --> 00:18:46,140
whether this is actually insecure took a

474
00:18:46,140 --> 00:18:47,880
lot of work and it's that we weren't

475
00:18:47,880 --> 00:18:49,169
able to come up with a direct attack

476
00:18:49,169 --> 00:18:53,549
showing that this is insecure for some

477
00:18:53,549 --> 00:18:55,860
instantiation of e but what we were able

478
00:18:55,860 --> 00:18:58,380
to show as a relativized result that if

479
00:18:58,380 --> 00:19:00,870
you could give a proof of this up ind

480
00:19:00,870 --> 00:19:02,880
CPA security just from the ind CPA

481
00:19:02,880 --> 00:19:05,610
security of e then this would imply a

482
00:19:05,610 --> 00:19:08,070
proof that this particular construction

483
00:19:08,070 --> 00:19:11,909
e is its ind CPA security implies that

484
00:19:11,909 --> 00:19:15,149
it's actually circular secure there's no

485
00:19:15,149 --> 00:19:16,740
long line of work on circular security

486
00:19:16,740 --> 00:19:18,390
and showing like negative results about

487
00:19:18,390 --> 00:19:20,700
ind CPA implying a super clear security

488
00:19:20,700 --> 00:19:22,440
those don't directly apply because we

489
00:19:22,440 --> 00:19:24,240
have a very special form of the conserve

490
00:19:24,240 --> 00:19:26,940
e in our result but nevertheless it

491
00:19:26,940 --> 00:19:27,960
seems like a lot evidence that you're

492
00:19:27,960 --> 00:19:29,059
not gonna be able to prove something

493
00:19:29,059 --> 00:19:35,340
strong here okay so the it's easy to fix

494
00:19:35,340 --> 00:19:36,600
up that one issue because we can replace

495
00:19:36,600 --> 00:19:39,360
int CPA Kem's with an authenticated

496
00:19:39,360 --> 00:19:42,059
encryption scheme and in addition we add

497
00:19:42,059 --> 00:19:44,970
other features to the BLM our scheme to

498
00:19:44,970 --> 00:19:47,850
arrive at this recruit scheme that

499
00:19:47,850 --> 00:19:50,250
achieves our stronger security goals as

500
00:19:50,250 --> 00:19:53,159
well so they using AE

501
00:19:53,159 --> 00:19:55,080
for the CEM prevents this type of

502
00:19:55,080 --> 00:19:56,280
modeling issue that

503
00:19:56,280 --> 00:19:57,990
came up in the proof or the attempt to

504
00:19:57,990 --> 00:20:00,480
prove the previous Bill Maher scheme we

505
00:20:00,480 --> 00:20:02,400
also do the same type of technique as we

506
00:20:02,400 --> 00:20:04,140
did for KSS which is the secret share

507
00:20:04,140 --> 00:20:06,630
the the data encapsulation key across

508
00:20:06,630 --> 00:20:10,140
the two components of the ciphertext and

509
00:20:10,140 --> 00:20:12,240
when we do a refresh we now need to not

510
00:20:12,240 --> 00:20:15,750
only refresh the key X Prime the key X

511
00:20:15,750 --> 00:20:21,300
but also the secret share Y so I won't

512
00:20:21,300 --> 00:20:22,650
go into details but it turns out we can

513
00:20:22,650 --> 00:20:24,120
show that this is both up iodine

514
00:20:24,120 --> 00:20:27,090
upbringing crypt security so in words

515
00:20:27,090 --> 00:20:28,680
this means that we get this stronger

516
00:20:28,680 --> 00:20:31,290
confidentiality even with access these

517
00:20:31,290 --> 00:20:33,240
rekey jan andrey encryption oracles and

518
00:20:33,240 --> 00:20:36,210
that the ciphertext in a similar kind of

519
00:20:36,210 --> 00:20:38,820
attack setting is basically useless sai

520
00:20:38,820 --> 00:20:40,080
protects from one time period under one

521
00:20:40,080 --> 00:20:41,310
key are kind of useless two attackers

522
00:20:41,310 --> 00:20:44,300
moving forward so you get this very full

523
00:20:44,300 --> 00:20:48,480
security so finally the last question

524
00:20:48,480 --> 00:20:50,850
that I had was whether we can make these

525
00:20:50,850 --> 00:20:52,710
things performance enough in practice we

526
00:20:52,710 --> 00:20:56,640
did a bunch of work to implement recruit

527
00:20:56,640 --> 00:21:02,510
in a highly optimized way we used

528
00:21:02,510 --> 00:21:04,380
underlying if the now are pink it's

529
00:21:04,380 --> 00:21:06,960
Rheingold key homomorphic PRF which is

530
00:21:06,960 --> 00:21:09,710
this like random Oracle model

531
00:21:09,710 --> 00:21:12,840
construction that also uses a dd HR

532
00:21:12,840 --> 00:21:15,270
group for that we used a curve two five

533
00:21:15,270 --> 00:21:17,340
five one nine put together this

534
00:21:17,340 --> 00:21:20,220
basically allows us to encrypt element

535
00:21:20,220 --> 00:21:22,530
messages in requiring roughly about L

536
00:21:22,530 --> 00:21:26,250
over 248 exponentiations and rotation

537
00:21:26,250 --> 00:21:28,380
requires about the same so the high

538
00:21:28,380 --> 00:21:30,450
level takeaway is this is by symmetric

539
00:21:30,450 --> 00:21:32,970
encryption standards in cruciate

540
00:21:32,970 --> 00:21:36,090
a nice low and it's about a thousand

541
00:21:36,090 --> 00:21:38,820
times slower than the use of like a SN I

542
00:21:38,820 --> 00:21:40,410
with a s GCM which is what you can

543
00:21:40,410 --> 00:21:43,920
standard I instantiate a hybrid or KSS

544
00:21:43,920 --> 00:21:46,500
with so for short messages this is you

545
00:21:46,500 --> 00:21:49,710
know you can still do this in micro

546
00:21:49,710 --> 00:21:52,080
milliseconds but for large bulk data

547
00:21:52,080 --> 00:21:54,830
this seems prohibitive at this point

548
00:21:54,830 --> 00:21:57,150
it's kind of a cool open question

549
00:21:57,150 --> 00:21:58,320
whether this is kind of fundamental to

550
00:21:58,320 --> 00:21:59,670
get this key rotation property you

551
00:21:59,670 --> 00:22:01,350
really need algebraic properties and we

552
00:22:01,350 --> 00:22:04,920
can prove that you can't do better or

553
00:22:04,920 --> 00:22:06,840
maybe if not then we can come up with

554
00:22:06,840 --> 00:22:09,160
something a bit faster

555
00:22:09,160 --> 00:22:11,200
okay so to summarize we provided a

556
00:22:11,200 --> 00:22:12,880
formal treatment in depth of key

557
00:22:12,880 --> 00:22:15,580
rotation for symmetric encryption we

558
00:22:15,580 --> 00:22:16,780
introduced a bunch of new security

559
00:22:16,780 --> 00:22:18,400
notions that strengthen on the prior

560
00:22:18,400 --> 00:22:22,330
work and investigated these using a

561
00:22:22,330 --> 00:22:26,620
bunch of new and old schemes and the

562
00:22:26,620 --> 00:22:28,690
high-level takeaways those are fast and

563
00:22:28,690 --> 00:22:31,960
the other ones are slow and finally we

564
00:22:31,960 --> 00:22:34,240
have this embarrassing bug in our C text

565
00:22:34,240 --> 00:22:35,950
of proofs and so please stay tuned for

566
00:22:35,950 --> 00:22:38,050
fix to that which will be posting

567
00:22:38,050 --> 00:22:40,320
shortly thank you very much

568
00:22:40,320 --> 00:22:46,020
[Applause]

