1
00:00:05,460 --> 00:00:09,220
hi everyone good morning again so today

2
00:00:09,220 --> 00:00:10,180
I'll be talking about incremental

3
00:00:10,180 --> 00:00:12,790
program mortification and this is joint

4
00:00:12,790 --> 00:00:13,269
work with

5
00:00:13,269 --> 00:00:16,840
badoom company ok so since this is the

6
00:00:16,840 --> 00:00:18,730
first stock in the office concession

7
00:00:18,730 --> 00:00:20,439
maybe I'll start by recalling a little

8
00:00:20,439 --> 00:00:22,360
bit about the notion and the definitions

9
00:00:22,360 --> 00:00:24,940
so the goal of software office keishon

10
00:00:24,940 --> 00:00:26,550
is to make computer programs

11
00:00:26,550 --> 00:00:28,869
unintelligible but without affecting

12
00:00:28,869 --> 00:00:30,789
their functionality so let's say you

13
00:00:30,789 --> 00:00:33,040
have a program P written in your

14
00:00:33,040 --> 00:00:34,870
favorite programming language you would

15
00:00:34,870 --> 00:00:36,820
like to also skate the program so that

16
00:00:36,820 --> 00:00:38,739
this office gated version works just

17
00:00:38,739 --> 00:00:40,420
like the origin one so you could execute

18
00:00:40,420 --> 00:00:42,280
on this office catered words an onion

19
00:00:42,280 --> 00:00:43,840
computer just as you could have executed

20
00:00:43,840 --> 00:00:47,020
orginal program P but I want this office

21
00:00:47,020 --> 00:00:49,570
catered words in to hide the secrets

22
00:00:49,570 --> 00:00:50,890
that were embedded inside the original

23
00:00:50,890 --> 00:00:55,210
program P so defining what this defining

24
00:00:55,210 --> 00:00:56,950
what it means to hide the secrets turns

25
00:00:56,950 --> 00:00:58,930
out to be rather tricky and sort of this

26
00:00:58,930 --> 00:01:01,450
one of the first efforts to define this

27
00:01:01,450 --> 00:01:03,940
formula was done by Baraka Hall who

28
00:01:03,940 --> 00:01:05,590
defined this very natural notion of

29
00:01:05,590 --> 00:01:07,390
obfuscation which they call virtual

30
00:01:07,390 --> 00:01:10,600
black box office kitchen ok so this this

31
00:01:10,600 --> 00:01:13,630
notion roughly says that an office kated

32
00:01:13,630 --> 00:01:17,470
words another program leaks only

33
00:01:17,470 --> 00:01:19,509
whatever could be learned from the

34
00:01:19,509 --> 00:01:21,160
input-output behavior of the program P

35
00:01:21,160 --> 00:01:23,770
in particular if I gave the office cater

36
00:01:23,770 --> 00:01:26,890
program to to an adversary then whatever

37
00:01:26,890 --> 00:01:28,630
he could learn from this office gated

38
00:01:28,630 --> 00:01:30,610
version you could learn the same things

39
00:01:30,610 --> 00:01:33,000
from an Oracle that implements the same

40
00:01:33,000 --> 00:01:36,520
functionality ok this is a very natural

41
00:01:36,520 --> 00:01:39,640
notion that Barack it all define but

42
00:01:39,640 --> 00:01:41,800
unfortunately this turns out to be a bit

43
00:01:41,800 --> 00:01:42,520
too strong

44
00:01:42,520 --> 00:01:46,090
and there are impossibility results

45
00:01:46,090 --> 00:01:48,340
showing that this notion this strong

46
00:01:48,340 --> 00:01:50,830
notion cannot be realized in general so

47
00:01:50,830 --> 00:01:54,250
you cannot arbitrate arbitrary programs

48
00:01:54,250 --> 00:01:57,640
satisfying the security notion there are

49
00:01:57,640 --> 00:02:01,140
positive results too in the case of

50
00:02:01,140 --> 00:02:03,789
restricted restricted programs or

51
00:02:03,789 --> 00:02:05,830
functionality specifically that we know

52
00:02:05,830 --> 00:02:08,380
how to office gate point functions with

53
00:02:08,380 --> 00:02:10,209
VBB security there are some recent

54
00:02:10,209 --> 00:02:12,520
results which achieve such strong

55
00:02:12,520 --> 00:02:16,060
security properties as well one point I

56
00:02:16,060 --> 00:02:19,240
want to mention is that the

57
00:02:19,240 --> 00:02:22,160
that that if you were to restrict to

58
00:02:22,160 --> 00:02:24,530
certain idolize the models in particular

59
00:02:24,530 --> 00:02:29,600
way such as the degenerate multi linear

60
00:02:29,600 --> 00:02:32,300
map model then we can indeed realize VBB

61
00:02:32,300 --> 00:02:36,170
security for for all circuits an

62
00:02:36,170 --> 00:02:38,150
alternate a weaker notion of security

63
00:02:38,150 --> 00:02:41,630
which is which is which is very commonly

64
00:02:41,630 --> 00:02:43,790
used is the indistinguishability our

65
00:02:43,790 --> 00:02:45,050
sophistication notion what this notion

66
00:02:45,050 --> 00:02:47,510
says is that if you have two programs p0

67
00:02:47,510 --> 00:02:50,090
and p1 which are functionally Qin by

68
00:02:50,090 --> 00:02:52,790
which I mean that on every input the two

69
00:02:52,790 --> 00:02:55,070
programs output the same exact output

70
00:02:55,070 --> 00:02:57,200
then if I was to also state one of the

71
00:02:57,200 --> 00:02:59,330
two programs the distributions of the

72
00:02:59,330 --> 00:03:00,709
obfuscation is a computationally

73
00:03:00,709 --> 00:03:03,560
indistinguishable okay

74
00:03:03,560 --> 00:03:06,290
this notion is recently gained a lot of

75
00:03:06,290 --> 00:03:09,650
popularity and we have constructions

76
00:03:09,650 --> 00:03:11,660
general purple construction of our fist

77
00:03:11,660 --> 00:03:13,340
occasion satisfying the security notion

78
00:03:13,340 --> 00:03:17,330
at least plausible candidates it might

79
00:03:17,330 --> 00:03:18,740
seem like you know if I'm trying to

80
00:03:18,740 --> 00:03:20,720
office gate two circuits that already

81
00:03:20,720 --> 00:03:22,519
implement the same functionality what am

82
00:03:22,519 --> 00:03:24,380
I really trying to hide it might seem

83
00:03:24,380 --> 00:03:26,030
like a weak notion but there's been a

84
00:03:26,030 --> 00:03:27,730
long line of work that sort of suggests

85
00:03:27,730 --> 00:03:31,640
that this notion is indeed very is

86
00:03:31,640 --> 00:03:33,769
indeed very powerful and can hide

87
00:03:33,769 --> 00:03:36,019
cryptographic secrets inside programs

88
00:03:36,019 --> 00:03:39,019
and a number of applications are min

89
00:03:39,019 --> 00:03:43,550
demonstrate the strongest formal

90
00:03:43,550 --> 00:03:47,150
justification it comes from this work of

91
00:03:47,150 --> 00:03:49,160
goldwasser and Rockland which says that

92
00:03:49,160 --> 00:03:50,600
this notion of indistinct ability

93
00:03:50,600 --> 00:03:52,640
obfuscation is in fact the best possible

94
00:03:52,640 --> 00:03:54,890
Association in other words whatever this

95
00:03:54,890 --> 00:03:58,370
notion it hides about the program is the

96
00:03:58,370 --> 00:04:01,610
best that you could hope to write okay

97
00:04:01,610 --> 00:04:04,580
so with this background let me move on

98
00:04:04,580 --> 00:04:06,560
to the motivation of our work which is

99
00:04:06,560 --> 00:04:10,370
in the case of software updates so you

100
00:04:10,370 --> 00:04:12,019
know if you have ever used a computer

101
00:04:12,019 --> 00:04:14,390
which which I assume all of you have

102
00:04:14,390 --> 00:04:18,290
then you know you evolve use software

103
00:04:18,290 --> 00:04:21,440
which which got updated and you know

104
00:04:21,440 --> 00:04:22,910
these updates are released for many

105
00:04:22,910 --> 00:04:24,560
reasons for example there might be a bug

106
00:04:24,560 --> 00:04:27,560
in your software that's that's that's

107
00:04:27,560 --> 00:04:29,450
fixed or it could be a security

108
00:04:29,450 --> 00:04:30,650
vulnerability that

109
00:04:30,650 --> 00:04:33,290
this and needs to be patched well you

110
00:04:33,290 --> 00:04:34,880
might have bought a software which comes

111
00:04:34,880 --> 00:04:37,490
with these locked features and you're

112
00:04:37,490 --> 00:04:40,340
trying to you paid to the service to

113
00:04:40,340 --> 00:04:42,860
some service provider to to unlock that

114
00:04:42,860 --> 00:04:44,690
feature or you got the key from from

115
00:04:44,690 --> 00:04:46,729
your friend to unlock that feature and

116
00:04:46,729 --> 00:04:48,199
you're trying to use that feature and

117
00:04:48,199 --> 00:04:51,560
that now needs to be a lot so for each

118
00:04:51,560 --> 00:04:53,990
or any of these features to work there

119
00:04:53,990 --> 00:04:55,970
would need to be a patch or an update

120
00:04:55,970 --> 00:04:57,229
that will need to be applied to the

121
00:04:57,229 --> 00:05:02,389
software that you have and so if we were

122
00:05:02,389 --> 00:05:03,860
doing the same thing in the office cache

123
00:05:03,860 --> 00:05:05,060
that setting so let's say you had the

124
00:05:05,060 --> 00:05:07,610
program that was also skated and I was I

125
00:05:07,610 --> 00:05:10,010
wanted to apply an update what it would

126
00:05:10,010 --> 00:05:13,100
translate into to apply any update be

127
00:05:13,100 --> 00:05:14,780
the person who gave you the software

128
00:05:14,780 --> 00:05:16,580
will actually if you use known

129
00:05:16,580 --> 00:05:19,010
techniques you will have to will have to

130
00:05:19,010 --> 00:05:21,350
generate a fresh copy of the updated

131
00:05:21,350 --> 00:05:23,180
program and give it to you okay

132
00:05:23,180 --> 00:05:25,220
so typically on your computer you would

133
00:05:25,220 --> 00:05:27,169
update when you apply the update it's

134
00:05:27,169 --> 00:05:29,509
applied locally but if you were to use

135
00:05:29,509 --> 00:05:31,310
this in the case of office catered

136
00:05:31,310 --> 00:05:35,510
software you would have the the person

137
00:05:35,510 --> 00:05:36,830
who provided you with the software would

138
00:05:36,830 --> 00:05:38,930
have to reallocate the fresh copy and

139
00:05:38,930 --> 00:05:41,240
give it to you and this is a problem and

140
00:05:41,240 --> 00:05:43,039
this is what we want to sort of change

141
00:05:43,039 --> 00:05:46,639
in this work okay in particular as I

142
00:05:46,639 --> 00:05:48,349
said the updates are typically small

143
00:05:48,349 --> 00:05:52,099
much smaller than the size of the be the

144
00:05:52,099 --> 00:05:53,780
program that you're trying to update and

145
00:05:53,780 --> 00:05:56,060
we want the update time to be

146
00:05:56,060 --> 00:05:58,909
proportional to the time it takes to

147
00:05:58,909 --> 00:06:02,240
update the unassociated program in both

148
00:06:02,240 --> 00:06:03,889
the communication and the computational

149
00:06:03,889 --> 00:06:05,360
cost the guy who is updating his work

150
00:06:05,360 --> 00:06:07,370
should be less the communication that

151
00:06:07,370 --> 00:06:08,900
happens should be small and the amount

152
00:06:08,900 --> 00:06:10,820
of time you spend updating software at

153
00:06:10,820 --> 00:06:12,289
your local end should be small the

154
00:06:12,289 --> 00:06:14,479
office cater software akhirin okay

155
00:06:14,479 --> 00:06:17,120
especially we want this to be

156
00:06:17,120 --> 00:06:20,210
independent of the program size okay

157
00:06:20,210 --> 00:06:23,960
more the low-poly dog factors this is

158
00:06:23,960 --> 00:06:25,490
something this is not completely new

159
00:06:25,490 --> 00:06:27,169
this notion of incremental cryptography

160
00:06:27,169 --> 00:06:29,240
is has been well studied there's a lot

161
00:06:29,240 --> 00:06:32,870
of work on the topic for example in the

162
00:06:32,870 --> 00:06:35,539
setting of hashing digital signatures or

163
00:06:35,539 --> 00:06:37,729
deterministic encryption and then this

164
00:06:37,729 --> 00:06:40,070
is sort of inspired by this this line of

165
00:06:40,070 --> 00:06:43,909
work okay so the key point I want to

166
00:06:43,909 --> 00:06:44,479
drive

167
00:06:44,479 --> 00:06:46,189
and the stark is the definition that

168
00:06:46,189 --> 00:06:49,639
we've provided I'll talk about some of

169
00:06:49,639 --> 00:06:50,900
the constructions that we have towards

170
00:06:50,900 --> 00:06:53,150
the end but so if I really want to drive

171
00:06:53,150 --> 00:06:55,460
across the the definition that we have

172
00:06:55,460 --> 00:06:58,479
so also sort of go over them first

173
00:06:58,479 --> 00:07:01,219
okay so before I can tell you the

174
00:07:01,219 --> 00:07:02,779
definitions I need to sort of have some

175
00:07:02,779 --> 00:07:04,729
modeling on how if we define and update

176
00:07:04,729 --> 00:07:07,069
we define an update you know think of

177
00:07:07,069 --> 00:07:08,389
any program it can be thought of as a

178
00:07:08,389 --> 00:07:11,689
string I'm going to define and update by

179
00:07:11,689 --> 00:07:15,439
a set s or which is a subset of the bit

180
00:07:15,439 --> 00:07:18,740
locations if the program is of size n

181
00:07:18,740 --> 00:07:22,879
it's a subset of 1 to N and for each bit

182
00:07:22,879 --> 00:07:26,089
location in this set s say I we're now

183
00:07:26,089 --> 00:07:28,520
associated with the function fi where

184
00:07:28,520 --> 00:07:30,349
the function fi could be the flip

185
00:07:30,349 --> 00:07:32,300
function where you know you reverse the

186
00:07:32,300 --> 00:07:34,580
bit it's a set function which set it to

187
00:07:34,580 --> 00:07:37,310
1 reset set it to 0 or do nothing okay

188
00:07:37,310 --> 00:07:38,689
in this case you might not have included

189
00:07:38,689 --> 00:07:40,580
it but we you can include it there as

190
00:07:40,580 --> 00:07:42,800
well ok so this is how I'm going to

191
00:07:42,800 --> 00:07:44,749
model and update and note that this way

192
00:07:44,749 --> 00:07:47,389
of modeling and update makes sense for

193
00:07:47,389 --> 00:07:49,999
the an office created program as well as

194
00:07:49,999 --> 00:07:52,249
the office catered words right these are

195
00:07:52,249 --> 00:07:53,689
the bit location I want to change and

196
00:07:53,689 --> 00:07:55,339
this is how I want to change that that's

197
00:07:55,339 --> 00:07:59,360
all this modeling is specifying ok now

198
00:07:59,360 --> 00:08:03,740
let's say I as a as a server have a

199
00:08:03,740 --> 00:08:06,680
program P and I want to give you an

200
00:08:06,680 --> 00:08:08,240
office catered version of this program

201
00:08:08,240 --> 00:08:11,240
off P which I denote by P Prime when I

202
00:08:11,240 --> 00:08:12,800
provide you this office catered version

203
00:08:12,800 --> 00:08:15,110
I'm going to keep an update e locally at

204
00:08:15,110 --> 00:08:17,120
my end will require this update t small

205
00:08:17,120 --> 00:08:19,669
I just want to keep it with me whenever

206
00:08:19,669 --> 00:08:22,249
I want to later update this associated

207
00:08:22,249 --> 00:08:25,069
program that you have I'll get as in an

208
00:08:25,069 --> 00:08:28,180
input a set s which describes the up the

209
00:08:28,180 --> 00:08:31,279
the increment that's being done on the

210
00:08:31,279 --> 00:08:35,029
unassociated program p and i will use an

211
00:08:35,029 --> 00:08:37,159
oracle access to the office kitchen of P

212
00:08:37,159 --> 00:08:37,490
Prime

213
00:08:37,490 --> 00:08:39,860
I didn't I say that it's an Oracle

214
00:08:39,860 --> 00:08:40,880
access because I don't want to touch

215
00:08:40,880 --> 00:08:43,190
every single bit of this office cater

216
00:08:43,190 --> 00:08:45,980
program P Prime I'll use the update key

217
00:08:45,980 --> 00:08:49,420
and output a subset s Prime of the

218
00:08:49,420 --> 00:08:51,139
locations of P Prime

219
00:08:51,139 --> 00:08:53,480
ok along with the associated functions

220
00:08:53,480 --> 00:08:55,339
I'm not going to write the functions

221
00:08:55,339 --> 00:08:57,260
every single time just every time I just

222
00:08:57,260 --> 00:08:57,890
say

223
00:08:57,890 --> 00:09:00,800
and update set s it implicit we also

224
00:09:00,800 --> 00:09:02,240
means there are associated functions

225
00:09:02,240 --> 00:09:05,149
okay so I will generate this set subset

226
00:09:05,149 --> 00:09:07,279
s Prime locally and I set you to send

227
00:09:07,279 --> 00:09:09,320
you the set s Prime and now you can on

228
00:09:09,320 --> 00:09:11,660
your end update the obfuscated program

229
00:09:11,660 --> 00:09:15,170
right so this is how we're going to

230
00:09:15,170 --> 00:09:17,810
model it be the updates that are being

231
00:09:17,810 --> 00:09:20,810
done on office cater programs okay so

232
00:09:20,810 --> 00:09:24,140
what what what is the correctness and

233
00:09:24,140 --> 00:09:26,000
efficiency properties that we want here

234
00:09:26,000 --> 00:09:29,269
the correctness property that we want is

235
00:09:29,269 --> 00:09:33,680
that the obfuscation p1 Prime that's

236
00:09:33,680 --> 00:09:37,100
obtained by you applying the update on

237
00:09:37,100 --> 00:09:40,100
your office kated program implements the

238
00:09:40,100 --> 00:09:42,860
same function as p1 which is the the

239
00:09:42,860 --> 00:09:46,959
updated program on my end okay so in

240
00:09:46,959 --> 00:09:51,560
particular if you have P and P prime is

241
00:09:51,560 --> 00:09:54,170
the obfuscated version of P then after

242
00:09:54,170 --> 00:09:58,450
applying the update s on P if you get p1

243
00:09:58,450 --> 00:10:02,089
and and if you compute the update as I

244
00:10:02,089 --> 00:10:03,709
described on the last slide you got the

245
00:10:03,709 --> 00:10:05,149
set s Prime you could have apply the

246
00:10:05,149 --> 00:10:07,550
update s prime to P prime to get p1

247
00:10:07,550 --> 00:10:10,519
prime then this P 1 prime implements the

248
00:10:10,519 --> 00:10:15,920
the the desired function p1 okay ok and

249
00:10:15,920 --> 00:10:18,050
we want this to work for you know

250
00:10:18,050 --> 00:10:19,699
arbitrary polynomially many updates I

251
00:10:19,699 --> 00:10:22,160
apply an update I found a bug so

252
00:10:22,160 --> 00:10:26,209
software is often it doesn't have one it

253
00:10:26,209 --> 00:10:27,529
doesn't need one update it needs a lot

254
00:10:27,529 --> 00:10:29,630
more updates so I apply an update and I

255
00:10:29,630 --> 00:10:31,250
send the update to you now you're done I

256
00:10:31,250 --> 00:10:33,050
have a next update I want to keep doing

257
00:10:33,050 --> 00:10:35,449
this an arbitrary pollen normally many

258
00:10:35,449 --> 00:10:38,839
times ok and I want that for every

259
00:10:38,839 --> 00:10:42,170
single update that I do the the

260
00:10:42,170 --> 00:10:44,630
computational cost on my end and your

261
00:10:44,630 --> 00:10:47,209
end and the communication cost is

262
00:10:47,209 --> 00:10:50,089
proportional only to Pauline s and the

263
00:10:50,089 --> 00:10:52,490
security parameter ignoring poly log

264
00:10:52,490 --> 00:10:55,610
factors and and it's independent of the

265
00:10:55,610 --> 00:10:57,170
number of updates I provide so if I'm

266
00:10:57,170 --> 00:10:59,360
providing the tenth update it will again

267
00:10:59,360 --> 00:11:01,160
depend only on the number of changes

268
00:11:01,160 --> 00:11:03,290
that I'm making in that step so if I'm

269
00:11:03,290 --> 00:11:05,360
making the first update it changes n

270
00:11:05,360 --> 00:11:07,160
bits then I will send an update that's

271
00:11:07,160 --> 00:11:09,529
proportional to to some polynomial in n

272
00:11:09,529 --> 00:11:11,220
making this second

273
00:11:11,220 --> 00:11:13,350
update which makes far fewer changes

274
00:11:13,350 --> 00:11:16,340
then I only need to communicate

275
00:11:16,340 --> 00:11:18,090
correspondingly fewer number of birds

276
00:11:18,090 --> 00:11:21,570
yeah okay so what about particular

277
00:11:21,570 --> 00:11:24,030
distance now with that modeling in mind

278
00:11:24,030 --> 00:11:27,300
and the sort of definition and the

279
00:11:27,300 --> 00:11:28,560
efficiency properties I want to define

280
00:11:28,560 --> 00:11:30,690
what security are we seeking so there

281
00:11:30,690 --> 00:11:32,070
are several notions of security in

282
00:11:32,070 --> 00:11:34,410
particular to that I'm going to talk

283
00:11:34,410 --> 00:11:37,290
about now let me start with the basic

284
00:11:37,290 --> 00:11:40,350
one okay so the basic iio security which

285
00:11:40,350 --> 00:11:41,850
is stands for incremental

286
00:11:41,850 --> 00:11:44,000
indistinguishable office keishon

287
00:11:44,000 --> 00:11:46,380
security is that if you have two equal

288
00:11:46,380 --> 00:11:48,630
and programs P and Q and you have a

289
00:11:48,630 --> 00:11:51,540
sequence of updates s 1 to s D so these

290
00:11:51,540 --> 00:11:54,000
are unaffiliated programs and I'm going

291
00:11:54,000 --> 00:11:57,540
I could apply the update s 1 to P and

292
00:11:57,540 --> 00:12:00,180
get P 1 and then I still get P 2 and so

293
00:12:00,180 --> 00:12:03,270
on or I could apply these updates to Q 2

294
00:12:03,270 --> 00:12:05,670
get Q 1 and and so on I'm in this case

295
00:12:05,670 --> 00:12:07,470
assuming that the same update is apply

296
00:12:07,470 --> 00:12:08,820
being applied in the two cases

297
00:12:08,820 --> 00:12:10,770
ok so that that's a starting point you

298
00:12:10,770 --> 00:12:13,500
get rid of that later so I'm going to

299
00:12:13,500 --> 00:12:15,000
apply the same update in the two cases

300
00:12:15,000 --> 00:12:18,150
and I require that after every update

301
00:12:18,150 --> 00:12:21,330
the two programs remain functional equal

302
00:12:21,330 --> 00:12:24,720
ok so the functional equivalence

303
00:12:24,720 --> 00:12:30,630
property remains four holds forever in

304
00:12:30,630 --> 00:12:33,870
all in these updates apply then a I

305
00:12:33,870 --> 00:12:36,470
required that if I was to take

306
00:12:36,470 --> 00:12:39,450
associations of these programs then they

307
00:12:39,450 --> 00:12:41,550
together remain computationally

308
00:12:41,550 --> 00:12:43,710
indistinguishable note here that this p1

309
00:12:43,710 --> 00:12:45,960
prime is not a fresh office keishon of

310
00:12:45,960 --> 00:12:48,870
p1 it's also obtained by updating P

311
00:12:48,870 --> 00:12:51,660
prime so this P P P 1 prime will differ

312
00:12:51,660 --> 00:12:54,180
from P Prime in a few number only a few

313
00:12:54,180 --> 00:12:56,790
bit locations so on p2 prime will differ

314
00:12:56,790 --> 00:12:58,589
from p1 Prime in a few bit locations and

315
00:12:58,589 --> 00:13:00,390
so on which will all be proportional

316
00:13:00,390 --> 00:13:02,310
polynomial to the changes that are being

317
00:13:02,310 --> 00:13:04,710
made going from P to P 1 and so on

318
00:13:04,710 --> 00:13:06,630
specifically the size of the set s 1 to

319
00:13:06,630 --> 00:13:10,110
s D ok so this is the basic notion of

320
00:13:10,110 --> 00:13:12,030
security and as I said here we were

321
00:13:12,030 --> 00:13:13,530
restricting ourselves to applying the

322
00:13:13,530 --> 00:13:17,640
same update to into the both program so

323
00:13:17,640 --> 00:13:19,290
this is sort of might seem artificial

324
00:13:19,290 --> 00:13:23,130
because if you have a program you know

325
00:13:23,130 --> 00:13:24,660
to implementation you're probably going

326
00:13:24,660 --> 00:13:26,910
to apply different patches you're now

327
00:13:26,910 --> 00:13:29,040
going to change the same bit location in

328
00:13:29,040 --> 00:13:30,960
the same way and not just in terms of

329
00:13:30,960 --> 00:13:34,530
having a restricted functionality it

330
00:13:34,530 --> 00:13:38,010
also has a security consequences because

331
00:13:38,010 --> 00:13:41,430
if you are applying a patch this

332
00:13:41,430 --> 00:13:44,370
definition will leak the locations that

333
00:13:44,370 --> 00:13:46,290
are being updated we're also in

334
00:13:46,290 --> 00:13:48,810
particularly in what way they are being

335
00:13:48,810 --> 00:13:52,080
updated and that might you know if

336
00:13:52,080 --> 00:13:53,700
you're applying a security patch that

337
00:13:53,700 --> 00:13:55,770
might already leak the vulnerability

338
00:13:55,770 --> 00:13:56,970
that's there and the software that

339
00:13:56,970 --> 00:13:58,950
you're trying to protect which can be

340
00:13:58,950 --> 00:14:02,790
bad as well for against other pieces of

341
00:14:02,790 --> 00:14:04,100
cord out there which have not been

342
00:14:04,100 --> 00:14:07,890
patched so far okay so to account for

343
00:14:07,890 --> 00:14:10,200
that we define a stronger notion of

344
00:14:10,200 --> 00:14:10,740
security

345
00:14:10,740 --> 00:14:13,290
I won't define it formally but sort of

346
00:14:13,290 --> 00:14:14,910
is a very natural extension of what I

347
00:14:14,910 --> 00:14:17,580
define on the previous slide is that we

348
00:14:17,580 --> 00:14:19,530
would like to define a notion where you

349
00:14:19,530 --> 00:14:21,330
can apply a different set of update you

350
00:14:21,330 --> 00:14:23,490
still need functional equal equal and so

351
00:14:23,490 --> 00:14:28,260
if I apply an update to pp1 or 8 or 10

352
00:14:28,260 --> 00:14:30,900
to q1 those updates themselves could be

353
00:14:30,900 --> 00:14:32,520
different but the resulting programs

354
00:14:32,520 --> 00:14:34,440
need to be functionally Qin furthermore

355
00:14:34,440 --> 00:14:36,480
if the updates that I apply are roughly

356
00:14:36,480 --> 00:14:39,600
the same size then we can we want to

357
00:14:39,600 --> 00:14:42,510
argue that the computational

358
00:14:42,510 --> 00:14:43,860
indistinguishability as well on the

359
00:14:43,860 --> 00:14:47,880
slide still holds ok so that's the the

360
00:14:47,880 --> 00:14:50,310
stronger what we call increment private

361
00:14:50,310 --> 00:14:54,590
iio or increment private increment

362
00:14:54,590 --> 00:14:59,160
increment private iio Security notion ok

363
00:14:59,160 --> 00:15:01,680
so the reason why indistinguishable

364
00:15:01,680 --> 00:15:03,900
reification has been that useful is

365
00:15:03,900 --> 00:15:06,510
because this as I mentioned before is

366
00:15:06,510 --> 00:15:08,790
sort of the best possible notion of

367
00:15:08,790 --> 00:15:10,650
obfuscation you could hope for

368
00:15:10,650 --> 00:15:13,800
okay and we wanted to understand what is

369
00:15:13,800 --> 00:15:16,380
the best achievable security in the case

370
00:15:16,380 --> 00:15:20,670
of increment you know incremental

371
00:15:20,670 --> 00:15:22,860
indistinguishable the obfuscation so are

372
00:15:22,860 --> 00:15:24,780
we really achieving that or there is a

373
00:15:24,780 --> 00:15:28,530
gap towards that that goal we define in

374
00:15:28,530 --> 00:15:30,450
the paper again I won't do this formally

375
00:15:30,450 --> 00:15:32,570
in the talk but we define this

376
00:15:32,570 --> 00:15:35,820
incremental best possible efficient it's

377
00:15:35,820 --> 00:15:37,160
sort of analogous to in

378
00:15:37,160 --> 00:15:39,190
the best possible application definition

379
00:15:39,190 --> 00:15:41,690
and we're able to prove that the

380
00:15:41,690 --> 00:15:44,420
increment is sort of an result analogous

381
00:15:44,420 --> 00:15:46,399
to the relationship between IO and best

382
00:15:46,399 --> 00:15:47,990
possible office keishon that the

383
00:15:47,990 --> 00:15:49,790
increment private-eye IO that I just

384
00:15:49,790 --> 00:15:51,199
defined on the previous slide is

385
00:15:51,199 --> 00:15:54,699
actually equivalent with the increment

386
00:15:54,699 --> 00:15:57,500
best possible office station so it sort

387
00:15:57,500 --> 00:16:00,079
of provides some evidence that you know

388
00:16:00,079 --> 00:16:01,699
maybe this is the right definition to

389
00:16:01,699 --> 00:16:06,860
work with and so we we use this

390
00:16:06,860 --> 00:16:08,269
definition and we sort of think that

391
00:16:08,269 --> 00:16:11,029
it's a good one okay okay so now that

392
00:16:11,029 --> 00:16:13,100
you know we have this wherever

393
00:16:13,100 --> 00:16:16,279
definitions and the model in mind let me

394
00:16:16,279 --> 00:16:19,430
tell you our results the first result is

395
00:16:19,430 --> 00:16:20,720
sort of on the negative side note that I

396
00:16:20,720 --> 00:16:23,389
didn't talk about VBB security in the

397
00:16:23,389 --> 00:16:25,879
context of incrementality and the result

398
00:16:25,879 --> 00:16:27,860
for there is again negative and in fact

399
00:16:27,860 --> 00:16:30,829
even for for sort of as simple as point

400
00:16:30,829 --> 00:16:33,230
functions here the problem is that if

401
00:16:33,230 --> 00:16:34,459
you even have a point function

402
00:16:34,459 --> 00:16:37,910
obfuscation and if you're trying to

403
00:16:37,910 --> 00:16:40,129
offer escape a point function and then

404
00:16:40,129 --> 00:16:42,230
later trying to update you know that say

405
00:16:42,230 --> 00:16:43,730
I was trying to office get an n-bit

406
00:16:43,730 --> 00:16:46,550
point function and I want to update n

407
00:16:46,550 --> 00:16:48,410
bits of it or a hundred bits out of it

408
00:16:48,410 --> 00:16:51,829
of all the entire point function then in

409
00:16:51,829 --> 00:16:55,069
this case achieving VBB security is hard

410
00:16:55,069 --> 00:16:57,380
because the size of the update already

411
00:16:57,380 --> 00:17:00,050
leaks the number of locations that I'm

412
00:17:00,050 --> 00:17:02,569
updating the point function so there's

413
00:17:02,569 --> 00:17:04,549
this sort of inherent tension and even

414
00:17:04,549 --> 00:17:07,429
this sort of weaker notion even for this

415
00:17:07,429 --> 00:17:09,530
special functionality of point function

416
00:17:09,530 --> 00:17:11,299
we're not able to achieve any kind of

417
00:17:11,299 --> 00:17:14,419
meaningful incrementality and the issues

418
00:17:14,419 --> 00:17:16,880
are sort of similar to the prior works

419
00:17:16,880 --> 00:17:19,400
on on incremental deterministic public

420
00:17:19,400 --> 00:17:22,280
encryption more specifically we're able

421
00:17:22,280 --> 00:17:25,099
to prove the VBB or vgb obfuscation of

422
00:17:25,099 --> 00:17:26,750
point functions must have an increment

423
00:17:26,750 --> 00:17:30,200
ality which is almost as closest to the

424
00:17:30,200 --> 00:17:33,620
size of the function okay so this was a

425
00:17:33,620 --> 00:17:35,120
sort of a deviation let me come down

426
00:17:35,120 --> 00:17:37,100
come back to the positive results about

427
00:17:37,100 --> 00:17:41,510
the the two notions of incremental off

428
00:17:41,510 --> 00:17:43,400
the station that I define the first

429
00:17:43,400 --> 00:17:45,169
result that we have is sort of for the

430
00:17:45,169 --> 00:17:48,559
basic notion of iio that we have just

431
00:17:48,559 --> 00:17:50,830
give me IO and bunch of other things

432
00:17:50,830 --> 00:17:53,620
like one-way functions you can construct

433
00:17:53,620 --> 00:17:55,899
basic i/o for all programs and you can

434
00:17:55,899 --> 00:17:58,059
have them as circuits tuning machines or

435
00:17:58,059 --> 00:18:01,630
ramp programs we can also upgrade the

436
00:18:01,630 --> 00:18:03,279
security once you have the basic IO you

437
00:18:03,279 --> 00:18:05,169
can upgrade security to incremental

438
00:18:05,169 --> 00:18:06,570
private IO

439
00:18:06,570 --> 00:18:08,679
additionally using oblivious Ram

440
00:18:08,679 --> 00:18:11,409
techniques of both I can Ostrovsky again

441
00:18:11,409 --> 00:18:13,480
this work this result also works for

442
00:18:13,480 --> 00:18:15,299
circuits tuning machines Ram programs

443
00:18:15,299 --> 00:18:18,850
and so this is the the deposit the

444
00:18:18,850 --> 00:18:21,159
results that we have okay okay

445
00:18:21,159 --> 00:18:23,440
so finally you know I don't want to go

446
00:18:23,440 --> 00:18:25,210
into details of it because it gets messy

447
00:18:25,210 --> 00:18:28,139
but just to give you some idea of how

448
00:18:28,139 --> 00:18:30,460
what kind of techniques that we use

449
00:18:30,460 --> 00:18:32,019
especially because I think that they

450
00:18:32,019 --> 00:18:36,429
might be useful in other contexts in

451
00:18:36,429 --> 00:18:37,929
particular they could help simplify

452
00:18:37,929 --> 00:18:39,429
something else that you might be trying

453
00:18:39,429 --> 00:18:41,380
to do so the techniques might be useful

454
00:18:41,380 --> 00:18:45,100
and so the before getting into the

455
00:18:45,100 --> 00:18:49,750
details I want to note that office

456
00:18:49,750 --> 00:18:53,320
keishon inherently is a very non you

457
00:18:53,320 --> 00:18:55,090
know incrementally updatable primitive

458
00:18:55,090 --> 00:18:58,179
so if I want to make it updatable what

459
00:18:58,179 --> 00:19:00,130
I'm going to do is I'm going to separate

460
00:19:00,130 --> 00:19:04,210
the obfuscation part of it with a sort

461
00:19:04,210 --> 00:19:06,070
of a universal circuit office keishon

462
00:19:06,070 --> 00:19:08,200
thing and the program that I want to

463
00:19:08,200 --> 00:19:10,000
office gate separately so I can update

464
00:19:10,000 --> 00:19:14,169
the program incrementally and instead of

465
00:19:14,169 --> 00:19:16,450
the two at execution time can be fitted

466
00:19:16,450 --> 00:19:18,340
together to work so let's see how that

467
00:19:18,340 --> 00:19:21,159
works what I'm going to do this is I'm

468
00:19:21,159 --> 00:19:22,899
going to do this while a general-purpose

469
00:19:22,899 --> 00:19:25,059
obfuscation and a standard public

470
00:19:25,059 --> 00:19:26,700
encryption and I'm going to use a

471
00:19:26,700 --> 00:19:29,080
incremental signature scheme which is

472
00:19:29,080 --> 00:19:30,760
going to be an incremental hashed into

473
00:19:30,760 --> 00:19:32,500
the merkel hash with special properties

474
00:19:32,500 --> 00:19:35,139
and a music proof system but some

475
00:19:35,139 --> 00:19:38,230
properties it's it's special or one

476
00:19:38,230 --> 00:19:40,210
going to sort of detail but just there

477
00:19:40,210 --> 00:19:42,100
are some it will going to serve as sort

478
00:19:42,100 --> 00:19:44,830
of a signature here okay so the

479
00:19:44,830 --> 00:19:46,960
construction idea is it sort of uses the

480
00:19:46,960 --> 00:19:49,269
the two key trick I'm going to think of

481
00:19:49,269 --> 00:19:51,519
the program as a sequence of n bits p1

482
00:19:51,519 --> 00:19:54,010
to PN I'm going to encrypt each bit

483
00:19:54,010 --> 00:19:57,940
twice okay so using two separate public

484
00:19:57,940 --> 00:20:00,370
keys piqué and piqué Prime so E is going

485
00:20:00,370 --> 00:20:01,779
to be the collection of the encryption

486
00:20:01,779 --> 00:20:03,360
little bit of P I under peek

487
00:20:03,360 --> 00:20:04,920
and E prime is going to be the

488
00:20:04,920 --> 00:20:06,990
encryption of the bits of PII again

489
00:20:06,990 --> 00:20:10,049
under public apk from then I'm going to

490
00:20:10,049 --> 00:20:12,360
just hash the two together and I'm going

491
00:20:12,360 --> 00:20:15,420
to sign the root of the hash okay so

492
00:20:15,420 --> 00:20:16,770
this might seem similar to other

493
00:20:16,770 --> 00:20:17,730
construction that you might have

494
00:20:17,730 --> 00:20:19,860
previously seen but the key aspect here

495
00:20:19,860 --> 00:20:21,270
is that this music needs to be

496
00:20:21,270 --> 00:20:23,370
independent of the sizes of these

497
00:20:23,370 --> 00:20:25,440
ciphertexts it needs to be small in

498
00:20:25,440 --> 00:20:27,120
particular it will depend only on the

499
00:20:27,120 --> 00:20:29,820
hash of the lemarchal tree rather than

500
00:20:29,820 --> 00:20:31,230
the entire tree okay

501
00:20:31,230 --> 00:20:34,470
so that's sort of the key difference

502
00:20:34,470 --> 00:20:36,120
from similar things that you might have

503
00:20:36,120 --> 00:20:38,580
seen before and the obfuscation itself

504
00:20:38,580 --> 00:20:40,230
is just going to look at everything that

505
00:20:40,230 --> 00:20:42,240
I generated so far the ciphertext the

506
00:20:42,240 --> 00:20:44,640
hash the tree the signature on the root

507
00:20:44,640 --> 00:20:46,980
of the hash and an obfuscation of this

508
00:20:46,980 --> 00:20:52,309
program g-gee which has the public

509
00:20:52,309 --> 00:20:55,080
parameters for the domestic and the

510
00:20:55,080 --> 00:20:57,390
secret key for the first public key

511
00:20:57,390 --> 00:20:59,880
encryption scheme a hard wire okay and

512
00:20:59,880 --> 00:21:02,460
what this program does it takes

513
00:21:02,460 --> 00:21:04,530
everything is input jacks if everything

514
00:21:04,530 --> 00:21:06,270
was done correctly so it checks whether

515
00:21:06,270 --> 00:21:08,460
the X is the input you're trying to

516
00:21:08,460 --> 00:21:10,020
evaluate or not it checks whether the

517
00:21:10,020 --> 00:21:13,140
Markel hashes with dashes generates a

518
00:21:13,140 --> 00:21:15,450
merkel hash here checks FS is the valid

519
00:21:15,450 --> 00:21:18,600
signature on it with parameters P P and

520
00:21:18,600 --> 00:21:22,770
then if it is a decrypt e using secret

521
00:21:22,770 --> 00:21:25,080
key SK that's hardwired gets P runs p of

522
00:21:25,080 --> 00:21:28,950
x and and there we go note here the key

523
00:21:28,950 --> 00:21:31,380
difference as i pointed earlier is that

524
00:21:31,380 --> 00:21:33,150
the associated program has sort of

525
00:21:33,150 --> 00:21:36,000
nothing to do with the actual program

526
00:21:36,000 --> 00:21:37,380
that we're trying to offer escape which

527
00:21:37,380 --> 00:21:38,910
is a part of these cipher texts and

528
00:21:38,910 --> 00:21:40,830
these ciphertexts can be incrementally

529
00:21:40,830 --> 00:21:44,520
updated okay and and and that's where

530
00:21:44,520 --> 00:21:46,260
the update algorithm comes into play I

531
00:21:46,260 --> 00:21:48,630
have these ciphertext the hash and the

532
00:21:48,630 --> 00:21:52,500
tree to update this o to update this the

533
00:21:52,500 --> 00:21:54,150
cipher text I only need to update the

534
00:21:54,150 --> 00:21:56,910
right locations then change the root to

535
00:21:56,910 --> 00:22:00,120
leaf parts for those locations and sign

536
00:22:00,120 --> 00:22:04,260
the root again okay okay so that's all

537
00:22:04,260 --> 00:22:08,100
the updates like since I'm running close

538
00:22:08,100 --> 00:22:10,380
shot of time I'm not going to go into

539
00:22:10,380 --> 00:22:12,690
details of the proof idea but you can

540
00:22:12,690 --> 00:22:14,250
look at the paper one thing I do want to

541
00:22:14,250 --> 00:22:15,670
mention is that the

542
00:22:15,670 --> 00:22:17,050
function you can't use a gender cash

543
00:22:17,050 --> 00:22:18,820
function we have to use an IO friendly

544
00:22:18,820 --> 00:22:21,220
hash function specifically the somewhere

545
00:22:21,220 --> 00:22:23,500
statistically binding hash ok so just

546
00:22:23,500 --> 00:22:25,330
some proof ideas which you can look at

547
00:22:25,330 --> 00:22:28,450
the paper for that finally I want to say

548
00:22:28,450 --> 00:22:30,310
that you know there is possibility of a

549
00:22:30,310 --> 00:22:33,700
future work here one aspect is that we

550
00:22:33,700 --> 00:22:36,310
only get sick selectively secure notion

551
00:22:36,310 --> 00:22:39,100
of security so in particular the update

552
00:22:39,100 --> 00:22:42,030
sequence needs to be known before

553
00:22:42,030 --> 00:22:44,350
for the indistinguishability cool it

554
00:22:44,350 --> 00:22:45,700
would be interesting to have proved the

555
00:22:45,700 --> 00:22:50,100
the stronger adaptive security notion a

556
00:22:50,100 --> 00:22:53,380
you know we can start consider a you

557
00:22:53,380 --> 00:22:55,060
know specific kinds of updates you could

558
00:22:55,060 --> 00:22:57,550
think of more general updates which

559
00:22:57,550 --> 00:22:59,710
instead of looking at sup let's look at

560
00:22:59,710 --> 00:23:01,480
more general updates which might

561
00:23:01,480 --> 00:23:03,190
increase the size of the program and

562
00:23:03,190 --> 00:23:06,580
things like that finally I want to also

563
00:23:06,580 --> 00:23:09,730
mention a related work on a patchable

564
00:23:09,730 --> 00:23:12,100
office casein by an aunt at all which

565
00:23:12,100 --> 00:23:13,840
also looks at this this issue of

566
00:23:13,840 --> 00:23:17,500
updating software or updating office

567
00:23:17,500 --> 00:23:19,420
catered software but the two directions

568
00:23:19,420 --> 00:23:22,600
are fundamentally different because they

569
00:23:22,600 --> 00:23:25,090
try to reduce they consider a larger

570
00:23:25,090 --> 00:23:28,060
class of updates but the the running

571
00:23:28,060 --> 00:23:30,370
time in their case for the update still

572
00:23:30,370 --> 00:23:34,030
grows with the the size of the program

573
00:23:34,030 --> 00:23:35,830
so they don't reduce the computational

574
00:23:35,830 --> 00:23:38,920
cost on the side of the the recipient

575
00:23:38,920 --> 00:23:41,170
who's trying to update the the

576
00:23:41,170 --> 00:23:43,420
obfuscated program ok so but you can

577
00:23:43,420 --> 00:23:45,250
refer to our or their paper for details

578
00:23:45,250 --> 00:23:48,460
on comparisons and so on ok thanks

579
00:23:48,460 --> 00:23:54,200
[Applause]

