1
00:00:05,759 --> 00:00:07,440
thank you

2
00:00:07,440 --> 00:00:11,120
okay so passwords are one of the most

3
00:00:11,120 --> 00:00:13,440
prevalent forms of authentication which

4
00:00:13,440 --> 00:00:15,440
we use today

5
00:00:15,440 --> 00:00:17,600
so in a traditional password-based

6
00:00:17,600 --> 00:00:19,520
authentication scheme

7
00:00:19,520 --> 00:00:22,400
the user first chooses a password and

8
00:00:22,400 --> 00:00:24,720
registers it with the scheme

9
00:00:24,720 --> 00:00:27,279
so that password is hashed with a slow

10
00:00:27,279 --> 00:00:29,199
sorted hash function

11
00:00:29,199 --> 00:00:32,640
and the resulting digest is stored

12
00:00:32,640 --> 00:00:34,399
so then in the future when the user

13
00:00:34,399 --> 00:00:36,640
wishes to authenticate himself

14
00:00:36,640 --> 00:00:39,600
he re-enters his password the password

15
00:00:39,600 --> 00:00:40,399
is hashed

16
00:00:40,399 --> 00:00:43,440
with the same slow sorted hash and

17
00:00:43,440 --> 00:00:44,480
authentication

18
00:00:44,480 --> 00:00:47,280
is granted if the resulting hash matches

19
00:00:47,280 --> 00:00:49,039
that which is stored

20
00:00:49,039 --> 00:00:50,960
so you can see that if the password is

21
00:00:50,960 --> 00:00:53,120
entered with any kind of small typo

22
00:00:53,120 --> 00:00:57,360
or error then authentication will fail

23
00:00:57,360 --> 00:00:59,920
so throughout this work we model the

24
00:00:59,920 --> 00:01:01,920
slow salted hash function

25
00:01:01,920 --> 00:01:05,040
as a random oracle with some associated

26
00:01:05,040 --> 00:01:05,438
cost

27
00:01:05,438 --> 00:01:08,560
c and this cost is important

28
00:01:08,560 --> 00:01:10,400
because we will measure the run time of

29
00:01:10,400 --> 00:01:11,680
all of our algorithms

30
00:01:11,680 --> 00:01:14,720
and attacks in terms of the number of

31
00:01:14,720 --> 00:01:16,799
slow hash queries which are made since

32
00:01:16,799 --> 00:01:20,080
this will very much be the dominant cost

33
00:01:20,080 --> 00:01:22,159
so in this scheme as written

34
00:01:22,159 --> 00:01:24,320
authentication requires one

35
00:01:24,320 --> 00:01:27,439
slow hash computation so it follows that

36
00:01:27,439 --> 00:01:30,000
if the hashing cost is equal to c

37
00:01:30,000 --> 00:01:31,920
then the runtime of authentication will

38
00:01:31,920 --> 00:01:35,280
be equal to c also

39
00:01:35,280 --> 00:01:37,040
so when it comes to attacks against

40
00:01:37,040 --> 00:01:39,200
these schemes there are two main vectors

41
00:01:39,200 --> 00:01:40,079
that we're interested

42
00:01:40,079 --> 00:01:43,520
in online and offline attacks

43
00:01:43,520 --> 00:01:46,159
so an online attack is when an attacker

44
00:01:46,159 --> 00:01:48,560
attempts to impersonate the user via the

45
00:01:48,560 --> 00:01:51,119
login api of the system

46
00:01:51,119 --> 00:01:53,360
and while this is a very real threat

47
00:01:53,360 --> 00:01:54,960
there are techniques we can use

48
00:01:54,960 --> 00:01:57,439
such as locking the account after a

49
00:01:57,439 --> 00:01:59,439
certain number of incorrect password

50
00:01:59,439 --> 00:02:00,640
submissions

51
00:02:00,640 --> 00:02:02,960
that ensures that the number of guesses

52
00:02:02,960 --> 00:02:04,479
an attacker can make in this

53
00:02:04,479 --> 00:02:08,560
kind of attack can be kept very small

54
00:02:08,560 --> 00:02:11,440
in contrast in an offline attack the

55
00:02:11,440 --> 00:02:13,360
attacker has managed to compromise the

56
00:02:13,360 --> 00:02:14,000
part the

57
00:02:14,000 --> 00:02:16,400
password hash database and tries to

58
00:02:16,400 --> 00:02:19,280
crack the passwords by brute force

59
00:02:19,280 --> 00:02:21,120
and in this setting he can make a huge

60
00:02:21,120 --> 00:02:23,440
number of guesses with the only kind of

61
00:02:23,440 --> 00:02:25,200
limit on this really being the amount of

62
00:02:25,200 --> 00:02:25,760
time

63
00:02:25,760 --> 00:02:29,599
he's willing to invest in this process

64
00:02:29,599 --> 00:02:32,400
so in this work we focus on the offline

65
00:02:32,400 --> 00:02:33,360
case

66
00:02:33,360 --> 00:02:35,440
and there have been many examples of

67
00:02:35,440 --> 00:02:37,680
high-profile password breaches of this

68
00:02:37,680 --> 00:02:38,239
form

69
00:02:38,239 --> 00:02:40,160
that illustrate that this is a very real

70
00:02:40,160 --> 00:02:43,280
threat in practice

71
00:02:43,519 --> 00:02:46,080
so we formalize offline attacks in the

72
00:02:46,080 --> 00:02:47,599
following game

73
00:02:47,599 --> 00:02:51,120
so um we sample a password according to

74
00:02:51,120 --> 00:02:53,200
the password distribution

75
00:02:53,200 --> 00:02:55,280
and this models a user choosing their

76
00:02:55,280 --> 00:02:57,760
password

77
00:02:57,760 --> 00:03:00,480
so that password is then registered with

78
00:03:00,480 --> 00:03:01,519
the scheme

79
00:03:01,519 --> 00:03:04,000
as this results in the production of the

80
00:03:04,000 --> 00:03:06,400
hash digest which we label here with an

81
00:03:06,400 --> 00:03:07,360
h

82
00:03:07,360 --> 00:03:09,920
and depending on the scheme it may also

83
00:03:09,920 --> 00:03:10,400
store

84
00:03:10,400 --> 00:03:12,319
some additional information which we

85
00:03:12,319 --> 00:03:15,280
show here with an s

86
00:03:15,280 --> 00:03:18,239
so the attacker learns the hash digest

87
00:03:18,239 --> 00:03:20,319
and any other stored information

88
00:03:20,319 --> 00:03:22,640
and he tries to recover the password by

89
00:03:22,640 --> 00:03:23,760
brute force

90
00:03:23,760 --> 00:03:25,760
by submitting guesses to the random

91
00:03:25,760 --> 00:03:26,799
oracle

92
00:03:26,799 --> 00:03:29,840
and he wins if the correct password is

93
00:03:29,840 --> 00:03:33,680
amongst the guesses that he submits

94
00:03:33,680 --> 00:03:36,159
so the number of queries he can make is

95
00:03:36,159 --> 00:03:38,720
inherently dictated by the hashing cost

96
00:03:38,720 --> 00:03:41,280
so if the attacker is willing to invest

97
00:03:41,280 --> 00:03:42,239
some time t

98
00:03:42,239 --> 00:03:44,560
in this process and the hashing cost is

99
00:03:44,560 --> 00:03:47,360
equal to c it follows that he can make

100
00:03:47,360 --> 00:03:50,000
q queries within his attack run time

101
00:03:50,000 --> 00:03:53,680
where q is equal to t over c

102
00:03:53,680 --> 00:03:56,080
so we assume conservatively that the

103
00:03:56,080 --> 00:03:57,840
attacker has complete knowledge of the

104
00:03:57,840 --> 00:04:00,720
underlying password distribution

105
00:04:00,720 --> 00:04:02,640
and it's not hard to see that his best

106
00:04:02,640 --> 00:04:05,439
bet is simply going to be to query

107
00:04:05,439 --> 00:04:07,760
the cue most probable passwords

108
00:04:07,760 --> 00:04:09,840
according to the distribution

109
00:04:09,840 --> 00:04:12,400
so his attack success probability is

110
00:04:12,400 --> 00:04:13,439
equal to the weight

111
00:04:13,439 --> 00:04:17,438
of these cue heaviest passwords

112
00:04:17,519 --> 00:04:19,759
so just to kind of recap we've

113
00:04:19,759 --> 00:04:22,079
considered two like key metrics so far

114
00:04:22,079 --> 00:04:24,960
so we have the authentication runtime

115
00:04:24,960 --> 00:04:26,800
and the level of security achieved by

116
00:04:26,800 --> 00:04:28,479
the scheme

117
00:04:28,479 --> 00:04:30,400
and there's an inherent trade-off

118
00:04:30,400 --> 00:04:31,520
between the two

119
00:04:31,520 --> 00:04:34,240
which is represented by the hashing cost

120
00:04:34,240 --> 00:04:35,360
in the sense that

121
00:04:35,360 --> 00:04:37,680
we want the hashing cost c to be large

122
00:04:37,680 --> 00:04:39,520
enough that these offline attacks are

123
00:04:39,520 --> 00:04:40,880
hard

124
00:04:40,880 --> 00:04:42,720
but on the same time we can't take it

125
00:04:42,720 --> 00:04:44,240
too large

126
00:04:44,240 --> 00:04:46,720
it will make um the authentication

127
00:04:46,720 --> 00:04:47,360
runtime

128
00:04:47,360 --> 00:04:49,840
unreasonably slow for a legitimate user

129
00:04:49,840 --> 00:04:51,600
so it's a constant kind of balancing act

130
00:04:51,600 --> 00:04:54,320
between the two

131
00:04:54,320 --> 00:04:55,919
so there's a further metric that we

132
00:04:55,919 --> 00:04:58,479
haven't really spoken about so far

133
00:04:58,479 --> 00:05:01,120
which is usability because in the scheme

134
00:05:01,120 --> 00:05:02,560
i've just described

135
00:05:02,560 --> 00:05:04,639
the user must enter their password

136
00:05:04,639 --> 00:05:08,160
exactly for authentication to succeed

137
00:05:08,160 --> 00:05:10,240
but we know that users make a lot of

138
00:05:10,240 --> 00:05:12,960
typos and this represents a real pain

139
00:05:12,960 --> 00:05:13,520
point

140
00:05:13,520 --> 00:05:16,160
both for users and for the service

141
00:05:16,160 --> 00:05:18,400
providers whose schemes use systems it

142
00:05:18,400 --> 00:05:20,800
keeps them locked out of

143
00:05:20,800 --> 00:05:22,560
so more recently beginning with this

144
00:05:22,560 --> 00:05:25,440
work by chatterjeetal in 2016

145
00:05:25,440 --> 00:05:27,440
there's been a drive to add typo

146
00:05:27,440 --> 00:05:28,720
tolerance to password-based

147
00:05:28,720 --> 00:05:30,479
authentication schemes

148
00:05:30,479 --> 00:05:32,720
so the user may authenticate under a

149
00:05:32,720 --> 00:05:35,759
small set of allowed typos

150
00:05:35,759 --> 00:05:38,160
so to give some context to this they

151
00:05:38,160 --> 00:05:39,280
show in a study

152
00:05:39,280 --> 00:05:42,000
that just five simple typos are

153
00:05:42,000 --> 00:05:44,000
responsible for ten percent of all the

154
00:05:44,000 --> 00:05:45,919
failed login attempts at dropbox

155
00:05:45,919 --> 00:05:47,680
and that's three percent of users turned

156
00:05:47,680 --> 00:05:49,280
away

157
00:05:49,280 --> 00:05:51,919
and they offer an approach called relax

158
00:05:51,919 --> 00:05:52,720
checking

159
00:05:52,720 --> 00:05:54,639
which works well when we're just trying

160
00:05:54,639 --> 00:05:56,800
to correct a small set of typos like

161
00:05:56,800 --> 00:05:57,759
this

162
00:05:57,759 --> 00:05:59,840
but it's not clear how it's security

163
00:05:59,840 --> 00:06:01,840
extends when we wish to correct more

164
00:06:01,840 --> 00:06:03,360
typos

165
00:06:03,360 --> 00:06:04,479
and this is something we really would

166
00:06:04,479 --> 00:06:06,479
like to be able to do because they also

167
00:06:06,479 --> 00:06:08,240
show in their studies that if we could

168
00:06:08,240 --> 00:06:09,039
correct

169
00:06:09,039 --> 00:06:12,080
for example 64 typos

170
00:06:12,080 --> 00:06:14,160
this would allow us to fix half of all

171
00:06:14,160 --> 00:06:15,600
of those failed login attempts at

172
00:06:15,600 --> 00:06:16,560
dropbox

173
00:06:16,560 --> 00:06:18,160
this would be a really significant

174
00:06:18,160 --> 00:06:20,400
increase in usability

175
00:06:20,400 --> 00:06:22,639
so this is the motivation for this work

176
00:06:22,639 --> 00:06:25,039
how can we correct more typos securely

177
00:06:25,039 --> 00:06:28,639
than is possible with relaxed checking

178
00:06:29,120 --> 00:06:30,560
so before we can really talk about

179
00:06:30,560 --> 00:06:33,199
correcting typos um we need to define

180
00:06:33,199 --> 00:06:34,160
what a typo

181
00:06:34,160 --> 00:06:37,600
is so to the password distribution

182
00:06:37,600 --> 00:06:40,800
we associate a typo model so for each

183
00:06:40,800 --> 00:06:43,440
possible typo we define the ball around

184
00:06:43,440 --> 00:06:45,919
the typo to be the set of passwords we

185
00:06:45,919 --> 00:06:48,880
will accept it as a typo of

186
00:06:48,880 --> 00:06:51,199
to give an example of this if the sort

187
00:06:51,199 --> 00:06:53,199
of oddly capitalized string on the left

188
00:06:53,199 --> 00:06:54,639
is a typo

189
00:06:54,639 --> 00:06:56,800
we could for example quickly generate

190
00:06:56,800 --> 00:06:58,560
its ball and this list of candidate

191
00:06:58,560 --> 00:06:59,680
passwords

192
00:06:59,680 --> 00:07:01,840
by applying corrector functions based on

193
00:07:01,840 --> 00:07:04,160
the kind of typos we know users make

194
00:07:04,160 --> 00:07:06,400
so for example applying caps lock and

195
00:07:06,400 --> 00:07:09,280
flipping the case with the first letter

196
00:07:09,280 --> 00:07:11,360
and we will allow authentication under

197
00:07:11,360 --> 00:07:12,560
some typo

198
00:07:12,560 --> 00:07:16,319
if the real password lies in its form

199
00:07:16,319 --> 00:07:18,319
now clearly we have to define this typo

200
00:07:18,319 --> 00:07:20,080
model carefully because

201
00:07:20,080 --> 00:07:22,160
a scheme that just accepts any string in

202
00:07:22,160 --> 00:07:23,520
the place of the password

203
00:07:23,520 --> 00:07:25,520
is going to have very bad online

204
00:07:25,520 --> 00:07:26,960
security

205
00:07:26,960 --> 00:07:28,960
so in the paper we talk about how you

206
00:07:28,960 --> 00:07:30,080
can do this

207
00:07:30,080 --> 00:07:31,919
and going forwards we assume that we

208
00:07:31,919 --> 00:07:33,440
have a good typo model

209
00:07:33,440 --> 00:07:36,319
so online security is taken care of and

210
00:07:36,319 --> 00:07:40,720
we're just focusing on this offline case

211
00:07:40,960 --> 00:07:42,960
so the relaxed checking approach that i

212
00:07:42,960 --> 00:07:45,919
just mentioned is a simple way of adding

213
00:07:45,919 --> 00:07:48,319
typo tolerance onto a password-based

214
00:07:48,319 --> 00:07:50,879
authentication scheme

215
00:07:50,879 --> 00:07:54,000
so registration works just as before and

216
00:07:54,000 --> 00:07:56,479
but now when it comes to authentication

217
00:07:56,479 --> 00:07:58,160
we don't just compare the string which

218
00:07:58,160 --> 00:08:00,560
is entered but we generate the ball of

219
00:08:00,560 --> 00:08:01,199
it

220
00:08:01,199 --> 00:08:03,759
and hash all of the strings in the ball

221
00:08:03,759 --> 00:08:04,879
looking for a match

222
00:08:04,879 --> 00:08:06,879
and the user can authenticate if a match

223
00:08:06,879 --> 00:08:08,000
is found

224
00:08:08,000 --> 00:08:10,160
so you can see in this example that the

225
00:08:10,160 --> 00:08:12,560
user has successfully authenticated

226
00:08:12,560 --> 00:08:14,080
even though they entered their password

227
00:08:14,080 --> 00:08:16,400
with a typo

228
00:08:16,400 --> 00:08:18,800
now this type of tolerance comes at the

229
00:08:18,800 --> 00:08:19,759
cost of doing

230
00:08:19,759 --> 00:08:22,960
a bit more work because now the

231
00:08:22,960 --> 00:08:25,360
amount of slow hash computations

232
00:08:25,360 --> 00:08:26,240
acquired

233
00:08:26,240 --> 00:08:29,120
is equal to the number of the points in

234
00:08:29,120 --> 00:08:30,800
the ball

235
00:08:30,800 --> 00:08:32,958
so it follows that if balls are of size

236
00:08:32,958 --> 00:08:35,440
beta and we want to achieve some runtime

237
00:08:35,440 --> 00:08:38,159
rt we need to set the hashing cost to be

238
00:08:38,159 --> 00:08:39,039
equal to the

239
00:08:39,039 --> 00:08:41,279
time over beta so we're having to use a

240
00:08:41,279 --> 00:08:44,159
faster hashing cost

241
00:08:44,159 --> 00:08:46,399
so as before the best attack is just

242
00:08:46,399 --> 00:08:48,240
going to be to query as many of the most

243
00:08:48,240 --> 00:08:50,080
profitable points as the attacker can

244
00:08:50,080 --> 00:08:52,080
afford in his runtime

245
00:08:52,080 --> 00:08:54,240
but since we're using a hash function

246
00:08:54,240 --> 00:08:56,399
which is b to times faster

247
00:08:56,399 --> 00:08:58,000
it follows that he's going to be able to

248
00:08:58,000 --> 00:09:00,000
try b to times as many points

249
00:09:00,000 --> 00:09:02,080
and we get this increase in the offline

250
00:09:02,080 --> 00:09:05,120
success probability

251
00:09:05,279 --> 00:09:06,880
so this is the question we want to

252
00:09:06,880 --> 00:09:09,120
explore in this work we know we want to

253
00:09:09,120 --> 00:09:11,920
correct more typos to improve usability

254
00:09:11,920 --> 00:09:13,920
but we've relaxed checking this means

255
00:09:13,920 --> 00:09:16,080
using a faster hash function to preserve

256
00:09:16,080 --> 00:09:16,959
the runtime

257
00:09:16,959 --> 00:09:19,519
which then speeds up offline attacks so

258
00:09:19,519 --> 00:09:20,480
you want to see

259
00:09:20,480 --> 00:09:22,560
can we find a way to correct more errors

260
00:09:22,560 --> 00:09:24,800
securely than is possible with relaxed

261
00:09:24,800 --> 00:09:27,040
checking

262
00:09:27,040 --> 00:09:29,680
so to do this we explore the use of

263
00:09:29,680 --> 00:09:31,279
secure sketches

264
00:09:31,279 --> 00:09:34,160
to allow us to correct more errors so

265
00:09:34,160 --> 00:09:36,399
our first contribution is we construct a

266
00:09:36,399 --> 00:09:37,839
new sketch

267
00:09:37,839 --> 00:09:39,680
which has improved which is close to

268
00:09:39,680 --> 00:09:42,080
optimal and has improved security bounds

269
00:09:42,080 --> 00:09:43,360
over the previous best known

270
00:09:43,360 --> 00:09:44,160
construction

271
00:09:44,160 --> 00:09:47,200
from this paper by fuller tile

272
00:09:47,200 --> 00:09:49,600
so we show how to build sketch assisted

273
00:09:49,600 --> 00:09:50,880
checkers

274
00:09:50,880 --> 00:09:53,279
and in order to analyze them we have to

275
00:09:53,279 --> 00:09:55,279
extend sketch security to the setting

276
00:09:55,279 --> 00:09:56,720
where the attacker can make multiple

277
00:09:56,720 --> 00:09:59,040
guesses

278
00:09:59,040 --> 00:10:01,760
we also define a new and kind of more

279
00:10:01,760 --> 00:10:03,519
sophisticated variance of relaxed

280
00:10:03,519 --> 00:10:04,480
checking

281
00:10:04,480 --> 00:10:06,160
and then we develop a framework within

282
00:10:06,160 --> 00:10:08,160
which to compare these approaches

283
00:10:08,160 --> 00:10:10,399
and the results we find are somewhat

284
00:10:10,399 --> 00:10:12,560
surprising in that the seemingly most

285
00:10:12,560 --> 00:10:15,120
rudimentary relaxed checking scheme

286
00:10:15,120 --> 00:10:17,519
turns out to offer a better time

287
00:10:17,519 --> 00:10:19,200
security trade-off than these more

288
00:10:19,200 --> 00:10:20,640
sophisticated schemes

289
00:10:20,640 --> 00:10:22,800
particularly with sketches with the

290
00:10:22,800 --> 00:10:24,880
intuition for this being that

291
00:10:24,880 --> 00:10:27,440
and when we extend sketch security to

292
00:10:27,440 --> 00:10:29,519
consider the multi-gas setting

293
00:10:29,519 --> 00:10:31,760
we find that security often deteriorates

294
00:10:31,760 --> 00:10:35,040
much more quickly than one might expect

295
00:10:35,040 --> 00:10:36,480
let's dig into what this means a bit

296
00:10:36,480 --> 00:10:39,360
more so secure sketches

297
00:10:39,360 --> 00:10:40,880
are designed for settings in which

298
00:10:40,880 --> 00:10:43,680
secrets are measured in a noisy fashion

299
00:10:43,680 --> 00:10:45,440
and we'd like to be able to reconstruct

300
00:10:45,440 --> 00:10:47,600
some secret from some noisy reading of

301
00:10:47,600 --> 00:10:48,959
it

302
00:10:48,959 --> 00:10:51,360
and we're focusing on um the

303
00:10:51,360 --> 00:10:53,360
distribution sensitive setting

304
00:10:53,360 --> 00:10:57,200
in which the distribution and typo model

305
00:10:57,200 --> 00:10:59,200
is known at the time of building the

306
00:10:59,200 --> 00:11:01,839
sketch and this isn't always reasonable

307
00:11:01,839 --> 00:11:04,079
as an assumption but it actually is with

308
00:11:04,079 --> 00:11:06,000
passwords because we have so much good

309
00:11:06,000 --> 00:11:06,560
data

310
00:11:06,560 --> 00:11:09,600
from password leaks we can model these

311
00:11:09,600 --> 00:11:12,480
distributions pretty accurately

312
00:11:12,480 --> 00:11:14,800
so the key idea is that we're going to

313
00:11:14,800 --> 00:11:15,680
store

314
00:11:15,680 --> 00:11:17,200
a little piece of information about the

315
00:11:17,200 --> 00:11:19,600
noisy secret which we call a sketch

316
00:11:19,600 --> 00:11:23,040
to aid this reconstruction process

317
00:11:23,040 --> 00:11:24,959
so we have a sketching algorithm that

318
00:11:24,959 --> 00:11:26,800
takes its input a password

319
00:11:26,800 --> 00:11:29,279
and returns a sketch of that password

320
00:11:29,279 --> 00:11:31,120
and then we have a recovery algorithm

321
00:11:31,120 --> 00:11:33,120
which takes its input a string and a

322
00:11:33,120 --> 00:11:33,920
sketch

323
00:11:33,920 --> 00:11:36,000
and outputs a guess at their password

324
00:11:36,000 --> 00:11:37,440
underlying a sketch

325
00:11:37,440 --> 00:11:40,480
and what we want in terms of security is

326
00:11:40,480 --> 00:11:42,000
a guarantee that if the real

327
00:11:42,000 --> 00:11:44,160
password lies in the ball of the entered

328
00:11:44,160 --> 00:11:45,040
string

329
00:11:45,040 --> 00:11:47,200
then this recovery process will succeed

330
00:11:47,200 --> 00:11:48,880
with probability greater than equal to

331
00:11:48,880 --> 00:11:51,760
one minus delta

332
00:11:51,760 --> 00:11:54,720
so in terms of security we want to make

333
00:11:54,720 --> 00:11:56,079
sure that learning the sketch

334
00:11:56,079 --> 00:11:58,079
does not make it significantly easier to

335
00:11:58,079 --> 00:12:00,399
guess the underlying point

336
00:12:00,399 --> 00:12:03,200
so we model this by sampling a password

337
00:12:03,200 --> 00:12:04,160
sketching it

338
00:12:04,160 --> 00:12:06,959
and we give the attacker a sketch and he

339
00:12:06,959 --> 00:12:09,040
puts out outputs a single guess at the

340
00:12:09,040 --> 00:12:10,399
underlying point

341
00:12:10,399 --> 00:12:12,240
so we measure this in terms of the

342
00:12:12,240 --> 00:12:13,600
average casement entropy

343
00:12:13,600 --> 00:12:15,600
which captures how well an unbounded

344
00:12:15,600 --> 00:12:17,680
attacker can guess the password

345
00:12:17,680 --> 00:12:21,760
given a sketch and a single guess

346
00:12:21,839 --> 00:12:23,839
so in terms of what we can hope for with

347
00:12:23,839 --> 00:12:25,600
sketch security

348
00:12:25,600 --> 00:12:28,480
and filler italian their paper identify

349
00:12:28,480 --> 00:12:29,440
this property

350
00:12:29,440 --> 00:12:31,519
of distributions and typo models called

351
00:12:31,519 --> 00:12:32,959
the fuzzyman entropy

352
00:12:32,959 --> 00:12:35,200
which is kind of like an analogy of min

353
00:12:35,200 --> 00:12:36,079
entropy

354
00:12:36,079 --> 00:12:38,959
but for this the fuzzy setting and they

355
00:12:38,959 --> 00:12:40,959
show that the best possible security a

356
00:12:40,959 --> 00:12:42,160
sketch can achieve

357
00:12:42,160 --> 00:12:44,079
is this top bound of the fuzziness

358
00:12:44,079 --> 00:12:47,519
enthalpy minus log one minus delta

359
00:12:47,519 --> 00:12:49,040
and they give a clever construction

360
00:12:49,040 --> 00:12:51,279
based on universal hash functions

361
00:12:51,279 --> 00:12:53,200
which gets pretty close to the optimal

362
00:12:53,200 --> 00:12:55,279
bound except for the term highlighted in

363
00:12:55,279 --> 00:12:56,560
red

364
00:12:56,560 --> 00:12:58,480
and what we show is that it's possible

365
00:12:58,480 --> 00:13:00,560
to dispense with this problematic term

366
00:13:00,560 --> 00:13:02,639
and get substantially closer to the

367
00:13:02,639 --> 00:13:04,800
theoretical optimal bound with this last

368
00:13:04,800 --> 00:13:05,200
term

369
00:13:05,200 --> 00:13:07,839
shown here and this all the saving of

370
00:13:07,839 --> 00:13:08,480
entropy

371
00:13:08,480 --> 00:13:10,079
is very important especially with

372
00:13:10,079 --> 00:13:12,000
passwords where every bit of entropy

373
00:13:12,000 --> 00:13:14,000
counts

374
00:13:14,000 --> 00:13:15,839
so we call our construction the layer

375
00:13:15,839 --> 00:13:17,200
hiding hash

376
00:13:17,200 --> 00:13:20,160
and it works as follows so we divide the

377
00:13:20,160 --> 00:13:21,600
password distribution

378
00:13:21,600 --> 00:13:24,079
into layers such that points within a

379
00:13:24,079 --> 00:13:27,120
layer are similar in weight

380
00:13:27,120 --> 00:13:29,920
and then we associate to each layer a

381
00:13:29,920 --> 00:13:32,000
family of strongly universal hash

382
00:13:32,000 --> 00:13:33,120
functions

383
00:13:33,120 --> 00:13:35,040
where the output length depends on the

384
00:13:35,040 --> 00:13:36,959
layer in which the point lies

385
00:13:36,959 --> 00:13:39,040
so the more probable the points the

386
00:13:39,040 --> 00:13:40,880
shorter the hash we use to try and leak

387
00:13:40,880 --> 00:13:41,120
in

388
00:13:41,120 --> 00:13:44,320
less information about them so to sketch

389
00:13:44,320 --> 00:13:45,440
a point

390
00:13:45,440 --> 00:13:48,079
we choose a salt and simply hash it with

391
00:13:48,079 --> 00:13:49,920
the hash function from the appropriate

392
00:13:49,920 --> 00:13:51,360
layer

393
00:13:51,360 --> 00:13:53,120
so up to this point we've more or less

394
00:13:53,120 --> 00:13:55,440
described the scheme of fuller etal

395
00:13:55,440 --> 00:13:57,519
they kind of stop and output this

396
00:13:57,519 --> 00:13:59,440
because for their scheme to achieve

397
00:13:59,440 --> 00:14:02,000
achieve correctness they need to

398
00:14:02,000 --> 00:14:04,079
explicitly reveal the layer in which the

399
00:14:04,079 --> 00:14:05,760
point lies

400
00:14:05,760 --> 00:14:07,839
and what we show is that if you use

401
00:14:07,839 --> 00:14:10,160
strongly universal hash functions

402
00:14:10,160 --> 00:14:12,320
and tweak the layering scheme a bit this

403
00:14:12,320 --> 00:14:14,320
is no longer necessary

404
00:14:14,320 --> 00:14:17,120
so we try and hide the layer so we do

405
00:14:17,120 --> 00:14:17,519
this

406
00:14:17,519 --> 00:14:20,240
by padding the sketch up to some fixed

407
00:14:20,240 --> 00:14:22,480
length of random bits

408
00:14:22,480 --> 00:14:24,639
and the upshot of this is that all

409
00:14:24,639 --> 00:14:26,000
sketches now

410
00:14:26,000 --> 00:14:28,240
look the same length regardless of the

411
00:14:28,240 --> 00:14:30,079
layer in which the underlying point

412
00:14:30,079 --> 00:14:32,000
lies and this is where the layer hiding

413
00:14:32,000 --> 00:14:35,680
hash name comes into play

414
00:14:36,720 --> 00:14:38,959
so when it comes to recovery the

415
00:14:38,959 --> 00:14:40,560
recovery algorithm is going to be

416
00:14:40,560 --> 00:14:42,800
presented with something like this

417
00:14:42,800 --> 00:14:45,839
so it has an entered point and a sketch

418
00:14:45,839 --> 00:14:48,480
and it's not obvious immediately what

419
00:14:48,480 --> 00:14:50,560
layer the underlying point lies in and

420
00:14:50,560 --> 00:14:53,440
which hash function we should be using

421
00:14:53,440 --> 00:14:56,240
so to get around this the recovery

422
00:14:56,240 --> 00:14:57,040
algorithm

423
00:14:57,040 --> 00:14:59,040
simply generates the ball of the entered

424
00:14:59,040 --> 00:15:00,079
string

425
00:15:00,079 --> 00:15:02,320
and it hashes all of the points in it

426
00:15:02,320 --> 00:15:04,240
with the appropriate hash function for

427
00:15:04,240 --> 00:15:06,320
the layer in which they lie

428
00:15:06,320 --> 00:15:08,480
and it compares these to the sketch

429
00:15:08,480 --> 00:15:11,120
truncated to the appropriate length

430
00:15:11,120 --> 00:15:13,040
and outputs the first match that it

431
00:15:13,040 --> 00:15:15,199
finds

432
00:15:15,199 --> 00:15:18,240
and we show that the correctness follows

433
00:15:18,240 --> 00:15:18,959
from

434
00:15:18,959 --> 00:15:21,279
the strong universality of the hash and

435
00:15:21,279 --> 00:15:23,600
a careful choice of parameters

436
00:15:23,600 --> 00:15:25,440
and then by not explicitly revealing the

437
00:15:25,440 --> 00:15:27,120
layer in which the point lies

438
00:15:27,120 --> 00:15:29,920
we save these extra bits of entropy and

439
00:15:29,920 --> 00:15:33,040
achieve the claim security bound

440
00:15:33,040 --> 00:15:35,040
so this is great we have a new sketch

441
00:15:35,040 --> 00:15:37,279
which is like closer to optimal

442
00:15:37,279 --> 00:15:40,000
than ever before so we're now going to

443
00:15:40,000 --> 00:15:41,839
use this to build a sketch assisted

444
00:15:41,839 --> 00:15:43,279
checker

445
00:15:43,279 --> 00:15:44,880
and so essentially we're going to

446
00:15:44,880 --> 00:15:47,120
bootstrap a secure sketch

447
00:15:47,120 --> 00:15:49,040
onto the password-based authentication

448
00:15:49,040 --> 00:15:50,720
scheme so now

449
00:15:50,720 --> 00:15:53,360
registration we also run the password

450
00:15:53,360 --> 00:15:55,040
through the sketching algorithm

451
00:15:55,040 --> 00:15:57,120
and we store the sketch along with the

452
00:15:57,120 --> 00:15:59,279
digest

453
00:15:59,279 --> 00:16:02,000
so then authentication in addition to

454
00:16:02,000 --> 00:16:04,160
comparing the entered string

455
00:16:04,160 --> 00:16:06,800
we also run that string in the sketch

456
00:16:06,800 --> 00:16:08,800
through the recovery algorithm

457
00:16:08,800 --> 00:16:10,800
and we test the output of recovery as

458
00:16:10,800 --> 00:16:12,560
well and the user may authenticate if

459
00:16:12,560 --> 00:16:14,079
either matches

460
00:16:14,079 --> 00:16:16,160
so you can see here that even if the

461
00:16:16,160 --> 00:16:18,720
user enters the password with a typo

462
00:16:18,720 --> 00:16:20,880
as long as the recovery algorithm can

463
00:16:20,880 --> 00:16:22,079
correct the typo

464
00:16:22,079 --> 00:16:24,399
he can still authenticate and this does

465
00:16:24,399 --> 00:16:25,839
kind of highlight a

466
00:16:25,839 --> 00:16:28,880
slight drawback of sketches and we have

467
00:16:28,880 --> 00:16:30,959
this delta possibility of error

468
00:16:30,959 --> 00:16:33,279
whereas for the relaxed checking we will

469
00:16:33,279 --> 00:16:36,160
always recover the correct point

470
00:16:36,160 --> 00:16:38,639
but on the upside we're now only having

471
00:16:38,639 --> 00:16:39,519
to use

472
00:16:39,519 --> 00:16:42,240
two of these slow hash computations so

473
00:16:42,240 --> 00:16:43,680
we can use a much slower

474
00:16:43,680 --> 00:16:45,839
a more secure hash function which is

475
00:16:45,839 --> 00:16:48,639
going to be better for security

476
00:16:48,639 --> 00:16:51,680
but this does come at the cost of having

477
00:16:51,680 --> 00:16:52,639
to store

478
00:16:52,639 --> 00:16:54,399
the additional information in the form

479
00:16:54,399 --> 00:16:56,880
of the sketch and the attacker can

480
00:16:56,880 --> 00:16:59,440
use a sketch to streamline their offline

481
00:16:59,440 --> 00:17:01,680
brute force attacks

482
00:17:01,680 --> 00:17:04,559
so to analyze this we extend the sketch

483
00:17:04,559 --> 00:17:07,039
security to the multi-guest setting

484
00:17:07,039 --> 00:17:10,079
um so we define the the cue conditional

485
00:17:10,079 --> 00:17:11,119
main entropy

486
00:17:11,119 --> 00:17:13,039
which captures how well an attacker can

487
00:17:13,039 --> 00:17:15,199
recover the password given the sketch

488
00:17:15,199 --> 00:17:18,400
with q guesses and this is often much

489
00:17:18,400 --> 00:17:19,520
more realistic

490
00:17:19,520 --> 00:17:21,439
but has been kind of overlooked in the

491
00:17:21,439 --> 00:17:23,280
literature

492
00:17:23,280 --> 00:17:25,439
and what we find giving a hint at the

493
00:17:25,439 --> 00:17:27,760
negative result to come with sketches

494
00:17:27,760 --> 00:17:30,559
is that when we take the frs then layer

495
00:17:30,559 --> 00:17:32,480
hiding hash sketches

496
00:17:32,480 --> 00:17:34,480
which are close to optimal in a single

497
00:17:34,480 --> 00:17:35,600
guest case and

498
00:17:35,600 --> 00:17:37,360
analyze them with respect to multiple

499
00:17:37,360 --> 00:17:39,360
guesses the gap between

500
00:17:39,360 --> 00:17:41,440
the theoretical optimal security and

501
00:17:41,440 --> 00:17:44,320
what they achieve

502
00:17:44,840 --> 00:17:46,160
widens

503
00:17:46,160 --> 00:17:49,200
okay so finally we're going to throw

504
00:17:49,200 --> 00:17:52,880
one more um scheme into the mix

505
00:17:52,880 --> 00:17:54,960
which we call popularity proportional

506
00:17:54,960 --> 00:17:57,120
hashing and it's essentially

507
00:17:57,120 --> 00:17:59,919
um relax checking but distribution

508
00:17:59,919 --> 00:18:01,200
sensitive

509
00:18:01,200 --> 00:18:03,840
so we split the distribution into layers

510
00:18:03,840 --> 00:18:05,600
and each layer gets a different hashing

511
00:18:05,600 --> 00:18:07,840
cost so the more probable the points

512
00:18:07,840 --> 00:18:10,400
the longer they get hashed so we recover

513
00:18:10,400 --> 00:18:11,919
by brute force bull search

514
00:18:11,919 --> 00:18:13,679
but we use different hashing costs in

515
00:18:13,679 --> 00:18:16,320
this process

516
00:18:16,960 --> 00:18:19,440
so we have these three schemes just so

517
00:18:19,440 --> 00:18:20,480
just to recap

518
00:18:20,480 --> 00:18:22,640
the simplest is relaxed checking we

519
00:18:22,640 --> 00:18:24,559
recover we correct errors by a brute

520
00:18:24,559 --> 00:18:25,760
force bull search

521
00:18:25,760 --> 00:18:29,039
with a fixed hashing cost we have

522
00:18:29,039 --> 00:18:32,000
pph which is a brute force bull search

523
00:18:32,000 --> 00:18:34,240
but varying hashing costs

524
00:18:34,240 --> 00:18:36,080
and then we have sketch assisted

525
00:18:36,080 --> 00:18:38,080
checking with the layer hiding hash

526
00:18:38,080 --> 00:18:41,120
and the filler tile sketches and we want

527
00:18:41,120 --> 00:18:41,679
to know

528
00:18:41,679 --> 00:18:44,000
which of these schemes offers the best

529
00:18:44,000 --> 00:18:46,720
time security trade-off

530
00:18:46,720 --> 00:18:48,799
so we analyze this in the following

531
00:18:48,799 --> 00:18:49,919
framework

532
00:18:49,919 --> 00:18:52,799
we fix a distribution and typo model

533
00:18:52,799 --> 00:18:54,720
that we want to correct

534
00:18:54,720 --> 00:18:57,280
and then we set the hashing cost so all

535
00:18:57,280 --> 00:18:59,280
the schemes achieve the same

536
00:18:59,280 --> 00:19:02,000
authentication runtime so for example

537
00:19:02,000 --> 00:19:02,480
here

538
00:19:02,480 --> 00:19:04,080
we're going to be using a much faster

539
00:19:04,080 --> 00:19:06,000
hash function for relaxed checking

540
00:19:06,000 --> 00:19:08,880
than we would with the sketches so with

541
00:19:08,880 --> 00:19:10,080
this in place

542
00:19:10,080 --> 00:19:12,320
we then compare the password recovery

543
00:19:12,320 --> 00:19:14,480
security

544
00:19:14,480 --> 00:19:18,000
and what we find is that pph always

545
00:19:18,000 --> 00:19:19,600
offers a better trade-off than sketch

546
00:19:19,600 --> 00:19:21,039
assisted checking

547
00:19:21,039 --> 00:19:23,760
and this holds what regardless of the

548
00:19:23,760 --> 00:19:26,080
underlying distribution

549
00:19:26,080 --> 00:19:28,960
and we further show that not for all

550
00:19:28,960 --> 00:19:30,480
distributions but for many of the kind

551
00:19:30,480 --> 00:19:32,160
of real-world ones we're interested in

552
00:19:32,160 --> 00:19:33,679
such as passwords

553
00:19:33,679 --> 00:19:35,600
it turns out that this seemingly

554
00:19:35,600 --> 00:19:37,280
simplest relaxed checking

555
00:19:37,280 --> 00:19:39,440
actually offers the best trade-off of

556
00:19:39,440 --> 00:19:41,280
all

557
00:19:41,280 --> 00:19:43,200
just to give some quick intuition about

558
00:19:43,200 --> 00:19:44,559
these results

559
00:19:44,559 --> 00:19:47,840
for the first comparison and sketch

560
00:19:47,840 --> 00:19:49,919
security usually focuses on

561
00:19:49,919 --> 00:19:51,360
upper bounds and attack success

562
00:19:51,360 --> 00:19:54,160
probability but to conclusively prove

563
00:19:54,160 --> 00:19:56,400
that pph offers a better trade-off

564
00:19:56,400 --> 00:19:58,160
we want to lower bound the attack

565
00:19:58,160 --> 00:19:59,840
success probability

566
00:19:59,840 --> 00:20:01,679
again this is something that isn't so

567
00:20:01,679 --> 00:20:04,559
often considered in the literature

568
00:20:04,559 --> 00:20:06,799
so to do this in the paper we show how

569
00:20:06,799 --> 00:20:09,200
to reduce the sketch guessing game

570
00:20:09,200 --> 00:20:12,320
to a weighted balls and bins experiment

571
00:20:12,320 --> 00:20:15,039
and from this we extract a lower bound

572
00:20:15,039 --> 00:20:17,039
on the attack success probability

573
00:20:17,039 --> 00:20:19,679
against sketch assisted checking and we

574
00:20:19,679 --> 00:20:20,799
use this to show

575
00:20:20,799 --> 00:20:23,440
that pph always offers a higher level of

576
00:20:23,440 --> 00:20:24,320
security

577
00:20:24,320 --> 00:20:27,200
for the same authentication runtime and

578
00:20:27,200 --> 00:20:28,880
we emphasize that this holds

579
00:20:28,880 --> 00:20:30,240
regardless of the underlying

580
00:20:30,240 --> 00:20:34,720
distribution and the attack runtime

581
00:20:34,720 --> 00:20:36,480
so for our second result it isn't

582
00:20:36,480 --> 00:20:38,480
unconditional in this way

583
00:20:38,480 --> 00:20:40,400
but it does hold for many of the

584
00:20:40,400 --> 00:20:41,840
distributions we'll actually be wanting

585
00:20:41,840 --> 00:20:44,480
to correct in practice

586
00:20:44,480 --> 00:20:48,320
so we proved this by comparing how the

587
00:20:48,320 --> 00:20:50,400
attack success probability

588
00:20:50,400 --> 00:20:53,679
for the schemes grows in relation to

589
00:20:53,679 --> 00:20:55,840
different attack run times

590
00:20:55,840 --> 00:20:58,400
and what we find is that for pph and

591
00:20:58,400 --> 00:20:59,520
sketches

592
00:20:59,520 --> 00:21:01,840
the attack success rate grows linearly

593
00:21:01,840 --> 00:21:04,159
with the runtime

594
00:21:04,159 --> 00:21:05,679
and this is in contrast to relaxed

595
00:21:05,679 --> 00:21:07,919
checking where for small run times we

596
00:21:07,919 --> 00:21:09,919
see quite a dramatic speed up

597
00:21:09,919 --> 00:21:12,799
but then this levels off so at some

598
00:21:12,799 --> 00:21:15,360
point there'll be a crossover point

599
00:21:15,360 --> 00:21:17,280
after which relaxed checking offers a

600
00:21:17,280 --> 00:21:18,960
better trade-off

601
00:21:18,960 --> 00:21:21,360
and what we find is that this crossover

602
00:21:21,360 --> 00:21:22,400
point

603
00:21:22,400 --> 00:21:24,480
often occurs in the attack run times

604
00:21:24,480 --> 00:21:25,760
that we're concerned about

605
00:21:25,760 --> 00:21:27,760
and for passwords and many other

606
00:21:27,760 --> 00:21:29,520
real-world distributions

607
00:21:29,520 --> 00:21:32,000
so and it turns out in these settings

608
00:21:32,000 --> 00:21:33,760
relax checking gives the best trade off

609
00:21:33,760 --> 00:21:36,080
of all

610
00:21:36,640 --> 00:21:39,280
so in conclusion we explore new

611
00:21:39,280 --> 00:21:40,880
techniques to try and correct

612
00:21:40,880 --> 00:21:44,080
more typos securely we especially

613
00:21:44,080 --> 00:21:46,159
look at sketch assisted checking and

614
00:21:46,159 --> 00:21:47,679
construct this new and close to optimal

615
00:21:47,679 --> 00:21:49,520
secure sketch and we build some new

616
00:21:49,520 --> 00:21:50,720
schemes

617
00:21:50,720 --> 00:21:53,440
and we find somewhat surprisingly that

618
00:21:53,440 --> 00:21:55,919
the simplest relax checking approach

619
00:21:55,919 --> 00:21:57,679
actually offers the best trade off of

620
00:21:57,679 --> 00:21:59,360
all either and

621
00:21:59,360 --> 00:22:01,760
in the sketch assisted jerking sense

622
00:22:01,760 --> 00:22:04,159
this is due to the fact that when we

623
00:22:04,159 --> 00:22:06,640
consider sketch security in this

624
00:22:06,640 --> 00:22:08,240
multiple guest setting

625
00:22:08,240 --> 00:22:10,320
we find that security degrades much more

626
00:22:10,320 --> 00:22:13,280
quickly than one might expect

627
00:22:13,280 --> 00:22:15,120
so just as a kind of caveat we're not

628
00:22:15,120 --> 00:22:18,080
saying that secure sketches are useless

629
00:22:18,080 --> 00:22:22,000
our results hold um when a brute

630
00:22:22,000 --> 00:22:25,360
brute force bull search is feasible and

631
00:22:25,360 --> 00:22:27,200
um when we're concerned about

632
00:22:27,200 --> 00:22:28,640
computational

633
00:22:28,640 --> 00:22:31,200
adversaries who are bounded in terms of

634
00:22:31,200 --> 00:22:32,080
the number of

635
00:22:32,080 --> 00:22:34,480
random oracle queries we can make and

636
00:22:34,480 --> 00:22:36,080
furthermore we've considered these

637
00:22:36,080 --> 00:22:38,640
specific sketch constructions

638
00:22:38,640 --> 00:22:41,520
like we conjecture that our results hold

639
00:22:41,520 --> 00:22:42,960
for all sketches

640
00:22:42,960 --> 00:22:44,640
in the sense that any intuition that

641
00:22:44,640 --> 00:22:46,720
allows us to design a better secure

642
00:22:46,720 --> 00:22:47,760
sketch

643
00:22:47,760 --> 00:22:49,360
can be used to design a kind of

644
00:22:49,360 --> 00:22:51,840
analogous relaxed checking type scheme

645
00:22:51,840 --> 00:22:53,039
that will again achieve a better

646
00:22:53,039 --> 00:22:54,799
trade-off but that remains as an

647
00:22:54,799 --> 00:22:57,039
interesting open problem

648
00:22:57,039 --> 00:23:00,080
and more generally um it

649
00:23:00,080 --> 00:23:01,600
would be interesting to explore sketch

650
00:23:01,600 --> 00:23:04,080
security and the multi-gas setting more

651
00:23:04,080 --> 00:23:07,360
and find out is this gap between

652
00:23:07,360 --> 00:23:09,520
optimal and achievable security when the

653
00:23:09,520 --> 00:23:11,360
attacker gets multiple guesses

654
00:23:11,360 --> 00:23:13,919
inherent or can we find a sketch which

655
00:23:13,919 --> 00:23:15,280
is close to optimal

656
00:23:15,280 --> 00:23:18,640
in the multi-guest setting so that's all

657
00:23:18,640 --> 00:23:19,120
for me

658
00:23:19,120 --> 00:23:23,840
thank you for listening

