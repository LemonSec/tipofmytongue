1
00:00:04,860 --> 00:00:08,639
yeah this is a joint work between CWI

2
00:00:08,639 --> 00:00:11,360
and and Google myself a Lieberstein

3
00:00:11,360 --> 00:00:14,639
Pierre Cartman angel booty knee and your

4
00:00:14,639 --> 00:00:18,110
Merrick off and this represents a work

5
00:00:18,110 --> 00:00:20,970
while building upon already research

6
00:00:20,970 --> 00:00:23,130
going back to decades but this

7
00:00:23,130 --> 00:00:25,590
particular piece of work lasted two

8
00:00:25,590 --> 00:00:33,269
years we were 40 or so among this and so

9
00:00:33,269 --> 00:00:35,040
sha-1 is a cryptographic hash function

10
00:00:35,040 --> 00:00:36,809
so it gave take an arbitrary length

11
00:00:36,809 --> 00:00:38,940
input and it's going to compute a sha-1

12
00:00:38,940 --> 00:00:41,790
hash a bit string of hundred 60 bits and

13
00:00:41,790 --> 00:00:43,890
sha-1 was designed to be collision

14
00:00:43,890 --> 00:00:45,449
resistant although even we don't have a

15
00:00:45,449 --> 00:00:49,409
formal definition of collision resistant

16
00:00:49,409 --> 00:00:51,390
there is a informal definition that it

17
00:00:51,390 --> 00:00:53,549
should be infeasible to find different

18
00:00:53,549 --> 00:00:56,729
X&Y that map to the same output and of

19
00:00:56,729 --> 00:00:58,320
course you have the the Bertha research

20
00:00:58,320 --> 00:01:00,420
sorry there's a generic attack cost of

21
00:01:00,420 --> 00:01:02,100
with complexity of our to the power

22
00:01:02,100 --> 00:01:05,970
eighty and now the two most widely

23
00:01:05,970 --> 00:01:07,740
deployed cryptographic hash functions

24
00:01:07,740 --> 00:01:10,230
were md5 and sha-1 the past two decades

25
00:01:10,230 --> 00:01:13,650
and both have been broken initially by a

26
00:01:13,650 --> 00:01:16,200
team that by a professor coming one at

27
00:01:16,200 --> 00:01:20,070
all and defy has been broken practically

28
00:01:20,070 --> 00:01:22,050
there was media were collisions and

29
00:01:22,050 --> 00:01:24,780
sha-1 was broken theoretically and it

30
00:01:24,780 --> 00:01:28,020
really took 12 years to finally find the

31
00:01:28,020 --> 00:01:29,610
person collision luckily we still have

32
00:01:29,610 --> 00:01:32,430
to at least to secure cryptographic hash

33
00:01:32,430 --> 00:01:34,830
function standard shatori that we can

34
00:01:34,830 --> 00:01:38,940
now all migrate to so that collisions

35
00:01:38,940 --> 00:01:41,670
are a problem in in real world has been

36
00:01:41,670 --> 00:01:44,010
already shown quite quite strongly in

37
00:01:44,010 --> 00:01:47,190
two instances namely 2009 when we

38
00:01:47,190 --> 00:01:49,310
created a rogue certification authority

39
00:01:49,310 --> 00:01:52,440
using an md5 so-called chosen prefix

40
00:01:52,440 --> 00:01:54,330
collision attack where he created a

41
00:01:54,330 --> 00:01:56,190
collision between a website certificates

42
00:01:56,190 --> 00:01:58,470
a very just normal one and the rogue

43
00:01:58,470 --> 00:02:00,540
city certificates and we basically got

44
00:02:00,540 --> 00:02:03,360
as an actual see a signature on our

45
00:02:03,360 --> 00:02:06,270
website certificate just by requesting

46
00:02:06,270 --> 00:02:08,610
the normal process an automatic process

47
00:02:08,610 --> 00:02:10,769
and we got our signature and because of

48
00:02:10,769 --> 00:02:12,450
the collision property this signature

49
00:02:12,450 --> 00:02:14,520
was now also valid for a rogue hast if

50
00:02:14,520 --> 00:02:17,610
it's there by suddenly making this valid

51
00:02:17,610 --> 00:02:19,590
difficut and then of course you can

52
00:02:19,590 --> 00:02:22,200
generate on-the-fly certificates for any

53
00:02:22,200 --> 00:02:24,120
secure website and you can do a live

54
00:02:24,120 --> 00:02:26,610
virtually undetectable man-in-the-middle

55
00:02:26,610 --> 00:02:31,680
attack the other instance in 2012 when

56
00:02:31,680 --> 00:02:33,500
there was the super malware flame

57
00:02:33,500 --> 00:02:37,230
targeting in Middle East and it actually

58
00:02:37,230 --> 00:02:39,390
turned out that it's used a fake

59
00:02:39,390 --> 00:02:42,150
signature for Windows updates and again

60
00:02:42,150 --> 00:02:44,610
this was using an md5 chosen prefix

61
00:02:44,610 --> 00:02:46,650
collation in attack and actually instead

62
00:02:46,650 --> 00:02:49,709
of targeting the p ki p ki branch of

63
00:02:49,709 --> 00:02:52,230
microsoft that actually signs windows

64
00:02:52,230 --> 00:02:55,320
updates it actually attacked sort of

65
00:02:55,320 --> 00:02:58,880
know most unknown branch that just

66
00:02:58,880 --> 00:03:02,430
automatically handed out certificates on

67
00:03:02,430 --> 00:03:04,320
the internet if you knew how to ask and

68
00:03:04,320 --> 00:03:06,000
they only created a collision between

69
00:03:06,000 --> 00:03:08,360
two certificates where this was actually

70
00:03:08,360 --> 00:03:12,020
a code signing certificate and any

71
00:03:12,020 --> 00:03:14,750
windows update signed by that would be

72
00:03:14,750 --> 00:03:17,100
accepted by any version of Windows at

73
00:03:17,100 --> 00:03:19,250
that time is of course been fixed now

74
00:03:19,250 --> 00:03:21,540
and of course once you've created these

75
00:03:21,540 --> 00:03:23,670
fake updates they actually spread them

76
00:03:23,670 --> 00:03:25,890
basically on a local network using a

77
00:03:25,890 --> 00:03:28,200
special Windows protocol that you can

78
00:03:28,200 --> 00:03:32,130
push updates and then it's you basically

79
00:03:32,130 --> 00:03:36,720
have infection where you basically can

80
00:03:36,720 --> 00:03:40,920
do nothing against so this is represents

81
00:03:40,920 --> 00:03:43,860
the state of the art on md5 sha-1 crypt

82
00:03:43,860 --> 00:03:46,140
analysis so we have the identical prefix

83
00:03:46,140 --> 00:03:47,820
column and the chosen prefix which is a

84
00:03:47,820 --> 00:03:50,489
more stronger type of attack and the

85
00:03:50,489 --> 00:03:51,690
current state of attack is that we're

86
00:03:51,690 --> 00:03:53,489
basically for md5 we can very quickly

87
00:03:53,489 --> 00:03:55,290
generate collisions in a fraction of a

88
00:03:55,290 --> 00:03:57,450
second chosen prefix collisions are a

89
00:03:57,450 --> 00:04:01,049
bit harder it takes about a day we

90
00:04:01,049 --> 00:04:03,000
finally managed to get a sha-1 collision

91
00:04:03,000 --> 00:04:07,140
that's to the power of 63 on GPU which

92
00:04:07,140 --> 00:04:09,180
is actually relatively speaking more

93
00:04:09,180 --> 00:04:11,070
costly than on CPUs it's slightly higher

94
00:04:11,070 --> 00:04:15,299
and well-chosen prefix equations are

95
00:04:15,299 --> 00:04:18,690
about to the power 7702 also view this

96
00:04:18,690 --> 00:04:22,079
sort of analyte from what's practical

97
00:04:22,079 --> 00:04:24,240
you should also think about the Bitcoin

98
00:04:24,240 --> 00:04:26,760
network that does share to operations

99
00:04:26,760 --> 00:04:29,520
and on a yearly basis the bit

100
00:04:29,520 --> 00:04:32,430
network does to the power 86 share to

101
00:04:32,430 --> 00:04:36,599
cooperations today already says it

102
00:04:36,599 --> 00:04:39,389
basically well 80 bit securities is not

103
00:04:39,389 --> 00:04:40,159
enough

104
00:04:40,159 --> 00:04:46,139
so all these attacks on sha-1 they

105
00:04:46,139 --> 00:04:47,909
really attack the sha-1 compression

106
00:04:47,909 --> 00:04:50,099
function the underlying function that

107
00:04:50,099 --> 00:04:52,169
just processes a 512 bit message block

108
00:04:52,169 --> 00:04:55,199
and updates the internal 160-bit

109
00:04:55,199 --> 00:04:58,229
chaining value well until it will V do

110
00:04:58,229 --> 00:04:59,970
this until the entire message plus some

111
00:04:59,970 --> 00:05:02,190
padding is processed and then the final

112
00:05:02,190 --> 00:05:04,169
chaining value will of course be at the

113
00:05:04,169 --> 00:05:07,050
hash and this pretty much operates like

114
00:05:07,050 --> 00:05:10,319
a block cipher it will linearly expand

115
00:05:10,319 --> 00:05:13,039
the input message block so 512 bits

116
00:05:13,039 --> 00:05:17,370
partitioned 16 words of 32 bits and it

117
00:05:17,370 --> 00:05:19,830
will expand them to 80 words of 32 bits

118
00:05:19,830 --> 00:05:23,069
and then there will be a nonlinear

119
00:05:23,069 --> 00:05:26,090
mixing of the the five word states

120
00:05:26,090 --> 00:05:29,819
basically in 80 rounds where and every

121
00:05:29,819 --> 00:05:32,750
round there's one piece of message used

122
00:05:32,750 --> 00:05:35,430
and I'm finally there's a davis meyer

123
00:05:35,430 --> 00:05:38,370
feed forward to really prevent that the

124
00:05:38,370 --> 00:05:42,750
function is efficiently invertible now

125
00:05:42,750 --> 00:05:44,729
for collision attacks were basically

126
00:05:44,729 --> 00:05:46,800
applying differential copy analysis so

127
00:05:46,800 --> 00:05:48,479
we're going to consider two different

128
00:05:48,479 --> 00:05:49,789
instances of the compression function

129
00:05:49,789 --> 00:05:51,569
side-by-side one for each of the

130
00:05:51,569 --> 00:05:54,509
messages and we're going to analyze the

131
00:05:54,509 --> 00:05:55,830
differences so in particular we're going

132
00:05:55,830 --> 00:05:58,169
to use a differential path which is a

133
00:05:58,169 --> 00:06:00,240
precise description of all the

134
00:06:00,240 --> 00:06:02,009
differences how they propagate through

135
00:06:02,009 --> 00:06:04,259
the compression function and the most

136
00:06:04,259 --> 00:06:05,669
important part of the differential path

137
00:06:05,669 --> 00:06:07,860
so basically last 60 steps because they

138
00:06:07,860 --> 00:06:09,240
really determine most of the attacks

139
00:06:09,240 --> 00:06:11,880
complexity we want them that part to

140
00:06:11,880 --> 00:06:13,409
have the highest success probability

141
00:06:13,409 --> 00:06:16,560
possible and basically as far as as

142
00:06:16,560 --> 00:06:19,440
possible and then once we have this

143
00:06:19,440 --> 00:06:21,060
differential pass what we can do we can

144
00:06:21,060 --> 00:06:23,130
just translate it into a system of

145
00:06:23,130 --> 00:06:25,110
equations and then we can try to solve

146
00:06:25,110 --> 00:06:27,840
this to find the actual m and M Prime

147
00:06:27,840 --> 00:06:33,840
that will be part of our collision now

148
00:06:33,840 --> 00:06:35,699
how to design these terms this

149
00:06:35,699 --> 00:06:37,500
differential pass while Chabon which you

150
00:06:37,500 --> 00:06:38,909
already showed in ninety eight that

151
00:06:38,909 --> 00:06:42,270
basically the way to go for for shall 0

152
00:06:42,270 --> 00:06:43,020
and shall 1

153
00:06:43,020 --> 00:06:45,629
is a disturbance vector and disturbance

154
00:06:45,629 --> 00:06:49,379
vector basically is a vector wherever

155
00:06:49,379 --> 00:06:50,389
you one bit

156
00:06:50,389 --> 00:06:52,860
marks the start of a local collision and

157
00:06:52,860 --> 00:06:54,990
a local collision well at that step at

158
00:06:54,990 --> 00:06:57,030
that bit position a single bit

159
00:06:57,030 --> 00:06:59,280
difference will be introduced and it

160
00:06:59,280 --> 00:07:01,020
will I get directly be canceled in the

161
00:07:01,020 --> 00:07:03,449
next five steps and basically because it

162
00:07:03,449 --> 00:07:05,659
has many 1 bits basically shows which

163
00:07:05,659 --> 00:07:07,530
combination of local collisions you have

164
00:07:07,530 --> 00:07:11,970
to use and the disturbance vector is an

165
00:07:11,970 --> 00:07:14,129
expanded message itself so it conforms

166
00:07:14,129 --> 00:07:16,979
to the linear message expansion of sha-1

167
00:07:16,979 --> 00:07:20,220
and that's why it's actually the unknown

168
00:07:20,220 --> 00:07:22,500
feasible way that's actually compatible

169
00:07:22,500 --> 00:07:27,150
with the message expansion so a lot of

170
00:07:27,150 --> 00:07:28,979
people have looked at it analyzed at

171
00:07:28,979 --> 00:07:31,400
which disturbance vectors are actually

172
00:07:31,400 --> 00:07:36,810
the best ones for for attacks and Steven

173
00:07:36,810 --> 00:07:38,310
Manuel actually showed that basically

174
00:07:38,310 --> 00:07:40,110
all these disturbing sectors that people

175
00:07:40,110 --> 00:07:42,180
have looked at fallen in two classes

176
00:07:42,180 --> 00:07:44,009
that are just shifts and rotates of each

177
00:07:44,009 --> 00:07:46,020
other so we can now easily focus on

178
00:07:46,020 --> 00:07:48,539
analyzing these two classes and each

179
00:07:48,539 --> 00:07:50,729
disturbance vector basically determines

180
00:07:50,729 --> 00:07:52,830
the short difference in a message and

181
00:07:52,830 --> 00:07:56,490
also like I said this single base state

182
00:07:56,490 --> 00:07:58,259
bit difference determines these

183
00:07:58,259 --> 00:08:00,349
positions and but they're still a

184
00:08:00,349 --> 00:08:03,779
variant in design and carry so the

185
00:08:03,779 --> 00:08:05,880
service vector pretty much already lays

186
00:08:05,880 --> 00:08:07,110
the groundwork for the differential

187
00:08:07,110 --> 00:08:08,940
paths right it already dictates many of

188
00:08:08,940 --> 00:08:10,680
the differences you still can just pick

189
00:08:10,680 --> 00:08:15,479
sign and how many carries you want so

190
00:08:15,479 --> 00:08:17,550
we're going to use the same as approach

191
00:08:17,550 --> 00:08:19,860
SS introduced by a by a by one we're

192
00:08:19,860 --> 00:08:21,330
going to use two near collision attacks

193
00:08:21,330 --> 00:08:23,880
right where the first nucleation attack

194
00:08:23,880 --> 00:08:27,300
is going to introduce a difference into

195
00:08:27,300 --> 00:08:29,880
the chaining value and that will then be

196
00:08:29,880 --> 00:08:31,529
present at the start of the second block

197
00:08:31,529 --> 00:08:33,809
and then for the main part we'll

198
00:08:33,809 --> 00:08:35,700
actually use the opposing differences so

199
00:08:35,700 --> 00:08:36,929
we'll end up with a negative difference

200
00:08:36,929 --> 00:08:39,360
here and then the Davis Maya forward

201
00:08:39,360 --> 00:08:41,309
will cancel them both and we have a

202
00:08:41,309 --> 00:08:43,020
collision well the benefit of this

203
00:08:43,020 --> 00:08:44,640
approach is that we don't have any

204
00:08:44,640 --> 00:08:45,899
additional requirement on the

205
00:08:45,899 --> 00:08:47,550
disturbance vector that there should be

206
00:08:47,550 --> 00:08:49,260
zero differences here and then we

207
00:08:49,260 --> 00:08:51,480
basically have we can get better

208
00:08:51,480 --> 00:08:52,890
differential paths with higher success

209
00:08:52,890 --> 00:08:56,610
probability but that does mean that here

210
00:08:56,610 --> 00:08:56,889
in the

211
00:08:56,889 --> 00:08:58,899
sparks that doesn't really follow

212
00:08:58,899 --> 00:09:00,399
disturbance vector we have to manually

213
00:09:00,399 --> 00:09:02,259
connect them well one little it is

214
00:09:02,259 --> 00:09:03,999
completely by hand but now of course we

215
00:09:03,999 --> 00:09:07,089
have actual algorithms that can compute

216
00:09:07,089 --> 00:09:09,100
these these so-called nonlinear

217
00:09:09,100 --> 00:09:10,809
differential paths to connect the

218
00:09:10,809 --> 00:09:12,519
chaining value inputs to the main

219
00:09:12,519 --> 00:09:18,129
differential path so okay yeah we have

220
00:09:18,129 --> 00:09:20,499
our different spots we can translate it

221
00:09:20,499 --> 00:09:22,389
to a system of equations and actually

222
00:09:22,389 --> 00:09:24,009
this is a system of equations that's

223
00:09:24,009 --> 00:09:25,989
only on one compression function which

224
00:09:25,989 --> 00:09:27,579
makes it very convenient we don't have

225
00:09:27,579 --> 00:09:29,499
to compute things on two compression

226
00:09:29,499 --> 00:09:31,419
functions at the same time and the

227
00:09:31,419 --> 00:09:33,040
system of equations when it's fulfilled

228
00:09:33,040 --> 00:09:34,899
basically guarantees that when we apply

229
00:09:34,899 --> 00:09:36,999
the input differences that the

230
00:09:36,999 --> 00:09:38,410
differential path will be exactly

231
00:09:38,410 --> 00:09:41,079
followed and is the system of equations

232
00:09:41,079 --> 00:09:42,639
actually just consists a very simple

233
00:09:42,639 --> 00:09:45,100
equation on message bits involving at

234
00:09:45,100 --> 00:09:47,649
most two message bits and very simple

235
00:09:47,649 --> 00:09:50,109
equations on State bit again involving

236
00:09:50,109 --> 00:09:53,379
at most two bits and then of course we

237
00:09:53,379 --> 00:09:54,850
need going to need to solve them well

238
00:09:54,850 --> 00:09:56,589
actually the first 60 steps are very

239
00:09:56,589 --> 00:09:59,169
easily solved right so in the first 60

240
00:09:59,169 --> 00:10:01,529
steps we have the entire message block

241
00:10:01,529 --> 00:10:03,749
still as freedom and we can just

242
00:10:03,749 --> 00:10:05,919
actually choose the value of the message

243
00:10:05,919 --> 00:10:07,899
block that merely satisfy all state

244
00:10:07,899 --> 00:10:10,869
equations and actually we can also

245
00:10:10,869 --> 00:10:13,269
fulfill all message bit equations

246
00:10:13,269 --> 00:10:15,040
because these are linear message bit

247
00:10:15,040 --> 00:10:17,169
equations over bits they are linearly

248
00:10:17,169 --> 00:10:19,389
derived from the input message block so

249
00:10:19,389 --> 00:10:21,429
we can just map all these equations to

250
00:10:21,429 --> 00:10:23,769
just the first 60 steps and these are

251
00:10:23,769 --> 00:10:27,399
just can also be easily solved but yeah

252
00:10:27,399 --> 00:10:29,049
after the first 60 steps we don't have

253
00:10:29,049 --> 00:10:30,519
any degrees of freedom anymore

254
00:10:30,519 --> 00:10:33,100
so now actually the remaining 64 steps

255
00:10:33,100 --> 00:10:35,949
are completely determined but of course

256
00:10:35,949 --> 00:10:39,009
we can still do smart changes that don't

257
00:10:39,009 --> 00:10:41,679
break any of the equations up to some

258
00:10:41,679 --> 00:10:44,739
point and thereby we can cheaply

259
00:10:44,739 --> 00:10:47,350
generate partial solutions up to some

260
00:10:47,350 --> 00:10:49,449
point and basically enticing the cost of

261
00:10:49,449 --> 00:10:51,759
earlier steps and it still offers quite

262
00:10:51,759 --> 00:10:53,949
significant control over about 30

263
00:10:53,949 --> 00:10:56,410
percent of the steps of Java and then of

264
00:10:56,410 --> 00:10:58,029
course for a remaining part we just have

265
00:10:58,029 --> 00:11:00,309
to generate many many many solutions so

266
00:11:00,309 --> 00:11:03,399
in this case up to step 24 to just

267
00:11:03,399 --> 00:11:05,169
probabilistic ly fulfill the remaining

268
00:11:05,169 --> 00:11:07,689
steps and that's why you see the success

269
00:11:07,689 --> 00:11:09,840
probability of this part is

270
00:11:09,840 --> 00:11:15,450
a crucial to the complexity so this is

271
00:11:15,450 --> 00:11:17,220
the overview of the whole procedure in

272
00:11:17,220 --> 00:11:19,590
in creating such a nucleation attack of

273
00:11:19,590 --> 00:11:21,150
course we first going to have to build

274
00:11:21,150 --> 00:11:24,300
the system of equations we're going to

275
00:11:24,300 --> 00:11:26,670
analyze the disturbance vector look at

276
00:11:26,670 --> 00:11:28,740
optimal differential power for the main

277
00:11:28,740 --> 00:11:32,100
part we have to construct the connecting

278
00:11:32,100 --> 00:11:34,020
parts between the the chaining value and

279
00:11:34,020 --> 00:11:35,970
the main differential path then we're

280
00:11:35,970 --> 00:11:37,470
going to translate it all into attack

281
00:11:37,470 --> 00:11:40,800
relations and actually to speed up the

282
00:11:40,800 --> 00:11:42,240
attack we want to find additional

283
00:11:42,240 --> 00:11:45,150
conditions because we allow actually

284
00:11:45,150 --> 00:11:47,990
multiple disturb differential paths and

285
00:11:47,990 --> 00:11:50,220
so we can actually find additional

286
00:11:50,220 --> 00:11:52,770
conditions that use both message and

287
00:11:52,770 --> 00:11:54,930
state bits and this will give us a

288
00:11:54,930 --> 00:11:57,630
slight speed-up using the earlier board

289
00:11:57,630 --> 00:12:01,950
strategy this is an additional step that

290
00:12:01,950 --> 00:12:04,710
we needed for the second near-collision

291
00:12:04,710 --> 00:12:08,850
attack because it was the the the first

292
00:12:08,850 --> 00:12:10,440
steps of the differential pass was so

293
00:12:10,440 --> 00:12:13,940
heavily over the find just by trying

294
00:12:13,940 --> 00:12:16,350
different variants nonlinear path we

295
00:12:16,350 --> 00:12:17,580
couldn't get around the solvability

296
00:12:17,580 --> 00:12:21,690
problem and we Indians resulted to start

297
00:12:21,690 --> 00:12:23,490
to just find a drop-in replacement of

298
00:12:23,490 --> 00:12:25,890
the first few steps of the differential

299
00:12:25,890 --> 00:12:28,980
path and of course the next step is well

300
00:12:28,980 --> 00:12:30,420
we have the system of equations that

301
00:12:30,420 --> 00:12:33,030
appear ously is now solvable and now we

302
00:12:33,030 --> 00:12:35,730
actually have to find a solution as fast

303
00:12:35,730 --> 00:12:38,850
as possible so of course we have to

304
00:12:38,850 --> 00:12:40,800
analyze in smart changes we can do

305
00:12:40,800 --> 00:12:42,570
they're called boomerangs and neutral

306
00:12:42,570 --> 00:12:44,580
bits and now we're going to of course

307
00:12:44,580 --> 00:12:46,520
have to write the attacker algorithm and

308
00:12:46,520 --> 00:12:48,870
in this case the attack algorithm for

309
00:12:48,870 --> 00:12:50,940
the first 60 steps and like all the

310
00:12:50,940 --> 00:12:52,380
tables all the constants they're just

311
00:12:52,380 --> 00:12:54,060
completely automatically generated

312
00:12:54,060 --> 00:12:56,850
that's very convenient but then the part

313
00:12:56,850 --> 00:12:59,760
where most of the attack complexity is

314
00:12:59,760 --> 00:13:03,390
has to be hand optimized and also hand

315
00:13:03,390 --> 00:13:05,580
implemented and especially for the GPU

316
00:13:05,580 --> 00:13:07,640
that has to be done completely by hand

317
00:13:07,640 --> 00:13:10,080
and then of course just running the

318
00:13:10,080 --> 00:13:13,260
attack since it's such a large-scale

319
00:13:13,260 --> 00:13:17,100
operation is also not not trivial well

320
00:13:17,100 --> 00:13:18,310
in the

321
00:13:18,310 --> 00:13:19,840
you know after I just want to highlight

322
00:13:19,840 --> 00:13:22,360
the three techniques main techniques

323
00:13:22,360 --> 00:13:24,550
that we used namely joint local

324
00:13:24,550 --> 00:13:28,060
collision analysis that basically these

325
00:13:28,060 --> 00:13:29,380
are the techniques that allowed us to

326
00:13:29,380 --> 00:13:31,870
find escalation and GOC a basically

327
00:13:31,870 --> 00:13:33,880
really maximize the success probability

328
00:13:33,880 --> 00:13:36,310
we have for the main differential pass

329
00:13:36,310 --> 00:13:38,910
so really minimizing the complexity I

330
00:13:38,910 --> 00:13:42,540
want to talk about GPU search because

331
00:13:42,540 --> 00:13:45,220
instead of a very expensive search on

332
00:13:45,220 --> 00:13:48,310
CPU it was now much more cost efficient

333
00:13:48,310 --> 00:13:51,100
with a very significant gap and of

334
00:13:51,100 --> 00:13:52,720
course I'll also talk briefly about is

335
00:13:52,720 --> 00:14:00,220
this new part is that so geo CA we

336
00:14:00,220 --> 00:14:02,830
introduced that in in 2013 at your crypt

337
00:14:02,830 --> 00:14:05,170
and instead of just analyzing one

338
00:14:05,170 --> 00:14:06,970
differential path or actually making it

339
00:14:06,970 --> 00:14:09,310
the one optimal differential path we're

340
00:14:09,310 --> 00:14:11,740
going to compute optimal differentials

341
00:14:11,740 --> 00:14:13,570
over the last 60 steps right and the

342
00:14:13,570 --> 00:14:16,510
differential is actually an input-output

343
00:14:16,510 --> 00:14:20,110
tuple where the probability of that

344
00:14:20,110 --> 00:14:22,150
tuple is just computed as a sum over all

345
00:14:22,150 --> 00:14:24,190
possible differential paths that have

346
00:14:24,190 --> 00:14:27,570
this input and output difference so

347
00:14:27,570 --> 00:14:29,830
we're really using the benefit of all

348
00:14:29,830 --> 00:14:31,660
possible variations it's out of just one

349
00:14:31,660 --> 00:14:35,140
single differential path and this this

350
00:14:35,140 --> 00:14:37,390
technique can efficiently compute this

351
00:14:37,390 --> 00:14:39,460
for for sha-1 and it does so it's

352
00:14:39,460 --> 00:14:42,820
roughly right so it computes a set of

353
00:14:42,820 --> 00:14:44,530
different all possible differential

354
00:14:44,530 --> 00:14:46,690
paths of just zero steps then use that

355
00:14:46,690 --> 00:14:50,080
to compute it over one step then over

356
00:14:50,080 --> 00:14:54,100
two steps and so on until we've found is

357
00:14:54,100 --> 00:14:56,700
that we want and we can just immediately

358
00:14:56,700 --> 00:15:00,130
determine these differentials and to do

359
00:15:00,130 --> 00:15:03,610
so it wants to start at a trivial set of

360
00:15:03,610 --> 00:15:05,080
zero different so that's why we split

361
00:15:05,080 --> 00:15:07,500
analysis in independent step intervals

362
00:15:07,500 --> 00:15:10,540
so there's this step interval 33 up to

363
00:15:10,540 --> 00:15:13,510
53 and 53 up to 61 where there's

364
00:15:13,510 --> 00:15:15,190
completely a zero difference in the

365
00:15:15,190 --> 00:15:17,620
state so we start with a zero different

366
00:15:17,620 --> 00:15:19,240
state and we end with a zero difference

367
00:15:19,240 --> 00:15:21,910
in the state and then it's actually very

368
00:15:21,910 --> 00:15:23,380
convenient we can look at these these

369
00:15:23,380 --> 00:15:25,270
topples of input and output difference

370
00:15:25,270 --> 00:15:26,920
well they have to have this zero

371
00:15:26,920 --> 00:15:30,410
difference so the only thing are these

372
00:15:30,410 --> 00:15:33,290
the message difference used to get there

373
00:15:33,290 --> 00:15:34,940
and of course we're just going to select

374
00:15:34,940 --> 00:15:37,459
all these message difference that have

375
00:15:37,459 --> 00:15:40,240
the maximum probability so this

376
00:15:40,240 --> 00:15:42,529
immediate guarantees we have the highly

377
00:15:42,529 --> 00:15:44,540
successful bility and then the next step

378
00:15:44,540 --> 00:15:46,699
is well well then we can also just

379
00:15:46,699 --> 00:15:48,620
derive the minimum amount of equations

380
00:15:48,620 --> 00:15:51,410
that we need to ensure that we get this

381
00:15:51,410 --> 00:15:54,410
highest probability for the last few

382
00:15:54,410 --> 00:15:56,629
steps we know that the starting

383
00:15:56,629 --> 00:15:59,209
difference is zero but at the end we do

384
00:15:59,209 --> 00:16:01,180
have a non zero difference of course

385
00:16:01,180 --> 00:16:03,680
that's what we relaxed with a two-block

386
00:16:03,680 --> 00:16:06,439
approach so now we're going to actually

387
00:16:06,439 --> 00:16:08,600
look at all highest probability output

388
00:16:08,600 --> 00:16:10,009
difference and message difference and

389
00:16:10,009 --> 00:16:12,019
then we're actually going to select all

390
00:16:12,019 --> 00:16:13,430
message differences that have the

391
00:16:13,430 --> 00:16:16,730
largest number of output difference it

392
00:16:16,730 --> 00:16:19,399
basically allows us a factor 6 speed up

393
00:16:19,399 --> 00:16:20,810
for the first nucleation dog because

394
00:16:20,810 --> 00:16:23,509
there we don't care about which output

395
00:16:23,509 --> 00:16:25,490
difference we get initially and but for

396
00:16:25,490 --> 00:16:26,769
the second block we just of course

397
00:16:26,769 --> 00:16:29,449
forced to use the negative difference

398
00:16:29,449 --> 00:16:31,420
negate the difference of the first block

399
00:16:31,420 --> 00:16:34,399
and again we can translate it to a

400
00:16:34,399 --> 00:16:35,990
minimum linear amount of linear

401
00:16:35,990 --> 00:16:38,870
equations so we get again both the high

402
00:16:38,870 --> 00:16:41,209
success probability and the fused

403
00:16:41,209 --> 00:16:46,069
conditions that allowed us although the

404
00:16:46,069 --> 00:16:47,680
first few steps are slightly different

405
00:16:47,680 --> 00:16:51,649
because that's where the speed ups

406
00:16:51,649 --> 00:16:54,139
happened and actually there we want a

407
00:16:54,139 --> 00:16:58,250
fixed differential path up to step 23 so

408
00:16:58,250 --> 00:16:59,420
that we actually get fixed state

409
00:16:59,420 --> 00:17:00,949
conditions that we can use for for

410
00:17:00,949 --> 00:17:03,850
earlier board strategy and also to check

411
00:17:03,850 --> 00:17:06,319
the boomerangs so we're going to

412
00:17:06,319 --> 00:17:08,209
slightly tweak this test statement so

413
00:17:08,209 --> 00:17:09,650
instead of just taking that the

414
00:17:09,650 --> 00:17:13,760
probability of all possible differential

415
00:17:13,760 --> 00:17:15,740
paths we're actually going to set a

416
00:17:15,740 --> 00:17:17,510
fixed part and we're going to take the

417
00:17:17,510 --> 00:17:19,459
maximum over these these fixed

418
00:17:19,459 --> 00:17:23,809
differential pass over the differential

419
00:17:23,809 --> 00:17:26,990
and this really allows us to even with a

420
00:17:26,990 --> 00:17:28,669
fixed difference pass to maximize this

421
00:17:28,669 --> 00:17:30,620
capability and again get all these

422
00:17:30,620 --> 00:17:36,679
conditions that we want so the next part

423
00:17:36,679 --> 00:17:39,440
so after we found this this system of

424
00:17:39,440 --> 00:17:41,390
equations well at least for the second

425
00:17:41,390 --> 00:17:43,730
near-collision attack you ran into this

426
00:17:43,730 --> 00:17:44,360
probe

427
00:17:44,360 --> 00:17:46,590
where the differential path is just

428
00:17:46,590 --> 00:17:48,960
enormous Lee over the find well of

429
00:17:48,960 --> 00:17:50,220
course the first five words are just

430
00:17:50,220 --> 00:17:51,660
directly determined by the chaining

431
00:17:51,660 --> 00:17:54,750
value but then in the words out put it

432
00:17:54,750 --> 00:17:57,470
in the next five steps but we only have

433
00:17:57,470 --> 00:18:00,510
15 priests a bit so 15 degrees of

434
00:18:00,510 --> 00:18:02,700
freedom but besides these these state

435
00:18:02,700 --> 00:18:05,670
equations we still also have mesons

436
00:18:05,670 --> 00:18:07,530
equations that aren't list here and we

437
00:18:07,530 --> 00:18:10,740
have 23 of them so it is directly over

438
00:18:10,740 --> 00:18:12,150
the pint and we don't really expect

439
00:18:12,150 --> 00:18:15,480
there's any solution at all and we tried

440
00:18:15,480 --> 00:18:18,000
various techniques to just try many

441
00:18:18,000 --> 00:18:20,010
variant differential paths

442
00:18:20,010 --> 00:18:21,980
basically with different signing

443
00:18:21,980 --> 00:18:24,540
different conditions to try to find

444
00:18:24,540 --> 00:18:27,150
something that that's solvable and that

445
00:18:27,150 --> 00:18:29,250
it really took too long and we didn't

446
00:18:29,250 --> 00:18:32,640
manage to get around this so finally we

447
00:18:32,640 --> 00:18:35,190
decided to just try to encode it as a

448
00:18:35,190 --> 00:18:39,960
Sat problem right so we created in in

449
00:18:39,960 --> 00:18:41,970
sets equations over to compression

450
00:18:41,970 --> 00:18:44,340
functions we forced the input chaining

451
00:18:44,340 --> 00:18:46,590
values we forced the conditions of the

452
00:18:46,590 --> 00:18:49,290
differential path around step eight and

453
00:18:49,290 --> 00:18:52,080
we forced the linear message equations

454
00:18:52,080 --> 00:18:53,910
over those first eight steps and we just

455
00:18:53,910 --> 00:18:56,790
asked said well just give me a variant

456
00:18:56,790 --> 00:18:58,890
differential path that just fits this

457
00:18:58,890 --> 00:19:01,380
place that I can just put in directly in

458
00:19:01,380 --> 00:19:04,470
as a drop-in replacement path and this

459
00:19:04,470 --> 00:19:06,860
just solved a problem in one hour so

460
00:19:06,860 --> 00:19:12,480
this also shows that we don't this

461
00:19:12,480 --> 00:19:14,940
cannot be efficiently solved so we don't

462
00:19:14,940 --> 00:19:16,530
need any degrees of freedom from the

463
00:19:16,530 --> 00:19:17,880
first near-collision block we don't need

464
00:19:17,880 --> 00:19:20,970
any conditions however complicated on

465
00:19:20,970 --> 00:19:22,800
the output chaining values of the first

466
00:19:22,800 --> 00:19:25,410
manipulation block so that's very

467
00:19:25,410 --> 00:19:31,470
convenient so the reason why it's we

468
00:19:31,470 --> 00:19:33,060
finally may really manage to work is of

469
00:19:33,060 --> 00:19:35,070
course we ran it on GPUs which are much

470
00:19:35,070 --> 00:19:37,740
more cost efficient right so a GPU that

471
00:19:37,740 --> 00:19:41,640
we printed that we looked at DTX 970 has

472
00:19:41,640 --> 00:19:44,580
a 1600 course process now regular CPUs

473
00:19:44,580 --> 00:19:47,670
well I think they're now coming CPUs

474
00:19:47,670 --> 00:19:49,560
with 20 course

475
00:19:49,560 --> 00:19:53,400
but still this is as many more but there

476
00:19:53,400 --> 00:19:55,980
is of course one trick you have to avoid

477
00:19:55,980 --> 00:19:57,570
branching to make efficient use of them

478
00:19:57,570 --> 00:20:00,570
because 32 cores in the GPU are linked

479
00:20:00,570 --> 00:20:02,220
together if they want to execute the

480
00:20:02,220 --> 00:20:03,960
same instruction they're going to do it

481
00:20:03,960 --> 00:20:05,490
at the same time if they want to execute

482
00:20:05,490 --> 00:20:07,350
different instructions then these are

483
00:20:07,350 --> 00:20:10,620
going to be serialized so if they all if

484
00:20:10,620 --> 00:20:12,420
there are 32 different instructions then

485
00:20:12,420 --> 00:20:14,490
it's going to take 32 cycles to execute

486
00:20:14,490 --> 00:20:16,020
them so you really have to avoid

487
00:20:16,020 --> 00:20:17,610
branching to make efficient use of them

488
00:20:17,610 --> 00:20:20,010
well the problem is our collision search

489
00:20:20,010 --> 00:20:22,620
isn't just a Rasha one computation it's

490
00:20:22,620 --> 00:20:24,720
a depth-first research right so at a

491
00:20:24,720 --> 00:20:26,970
certain step we're going to explore all

492
00:20:26,970 --> 00:20:29,190
degrees of freedom we're going to check

493
00:20:29,190 --> 00:20:31,650
if the conditions are met and if so

494
00:20:31,650 --> 00:20:33,600
we're going to go forward if we

495
00:20:33,600 --> 00:20:35,520
exhausted our freedoms we have to

496
00:20:35,520 --> 00:20:41,370
backtrack so this doesn't seem to be

497
00:20:41,370 --> 00:20:44,250
naturally compatible with GPU but still

498
00:20:44,250 --> 00:20:46,830
we have a very efficient framework for

499
00:20:46,830 --> 00:20:49,140
GPU that did allow efficient computation

500
00:20:49,140 --> 00:20:51,050
we just changed the model of how we

501
00:20:51,050 --> 00:20:53,640
worked a problem so actually what we're

502
00:20:53,640 --> 00:20:54,840
going to do is we're going to store

503
00:20:54,840 --> 00:20:57,330
partial solutions up to step in shared

504
00:20:57,330 --> 00:20:58,920
buffers so right so this stores all

505
00:20:58,920 --> 00:21:01,800
partial solutions up to step 26 and then

506
00:21:01,800 --> 00:21:06,300
we can just have every thread of a warp

507
00:21:06,300 --> 00:21:09,420
so so 32 threads would just take each we

508
00:21:09,420 --> 00:21:10,770
take a solution from here that would

509
00:21:10,770 --> 00:21:14,220
execute the same code to extend this to

510
00:21:14,220 --> 00:21:18,600
solutions of 26 every core would try all

511
00:21:18,600 --> 00:21:20,190
degree of freedom and then store the

512
00:21:20,190 --> 00:21:21,960
partial solution and now actually the

513
00:21:21,960 --> 00:21:23,720
only branching that's happening is

514
00:21:23,720 --> 00:21:26,760
whether or not to store an extended

515
00:21:26,760 --> 00:21:29,570
solution into the buffer instead of just

516
00:21:29,570 --> 00:21:31,860
skipping to entire different parts of

517
00:21:31,860 --> 00:21:34,050
the program and of course to really

518
00:21:34,050 --> 00:21:36,150
enforce that first research we have to

519
00:21:36,150 --> 00:21:38,130
enforce that they always first try to

520
00:21:38,130 --> 00:21:41,490
look at the last buffer that has enough

521
00:21:41,490 --> 00:21:46,430
work so if we're going to compare this

522
00:21:46,430 --> 00:21:50,280
GPU with CPU the original work where

523
00:21:50,280 --> 00:21:52,200
this is our attacks based on the from

524
00:21:52,200 --> 00:21:55,160
Newark at 2013 has an theoretical

525
00:21:55,160 --> 00:21:58,980
estimate of ^ 61 and if you consider

526
00:21:58,980 --> 00:22:01,110
that one CPU core does about 2 to power

527
00:22:01,110 --> 00:22:04,020
34 sha-1 operations per hour

528
00:22:04,020 --> 00:22:06,480
then will you end up with an estimate of

529
00:22:06,480 --> 00:22:10,170
15,000 core years whereas if you look at

530
00:22:10,170 --> 00:22:12,780
the gtx card if you look at russia one

531
00:22:12,780 --> 00:22:17,010
operations it's actually ^ 42.3 that

532
00:22:17,010 --> 00:22:20,490
means it would only take 50 GPU years

533
00:22:20,490 --> 00:22:23,490
significantly less at about the same

534
00:22:23,490 --> 00:22:26,190
cost right so one cpu core and one GPU

535
00:22:26,190 --> 00:22:28,820
they're roughly of about the same cost

536
00:22:28,820 --> 00:22:30,690
but unfortunately of course our

537
00:22:30,690 --> 00:22:32,130
collision attack is already showed is

538
00:22:32,130 --> 00:22:35,190
more complex than just Russia one so how

539
00:22:35,190 --> 00:22:36,660
big a factor are we going to lose

540
00:22:36,660 --> 00:22:39,540
relatively to the to the CPU well this

541
00:22:39,540 --> 00:22:41,960
was already analyzed in in previous work

542
00:22:41,960 --> 00:22:45,060
implementing the pre-start collision

543
00:22:45,060 --> 00:22:46,860
attacks for sha-1 and there they showed

544
00:22:46,860 --> 00:22:48,660
well in the collision search we

545
00:22:48,660 --> 00:22:50,790
basically get comparable performance of

546
00:22:50,790 --> 00:22:55,140
^ 41.1 instead of this factor and taking

547
00:22:55,140 --> 00:22:58,490
this with this figure it basically takes

548
00:22:58,490 --> 00:23:03,390
112 core GPU years so if you translate

549
00:23:03,390 --> 00:23:05,370
it then actually this the theoretical

550
00:23:05,370 --> 00:23:07,470
estimate on CPU translate to this

551
00:23:07,470 --> 00:23:10,020
theoretical estimate on GPU right so we

552
00:23:10,020 --> 00:23:12,150
lose a factor of two of efficiency but

553
00:23:12,150 --> 00:23:15,300
to actually gain a practical cost

554
00:23:15,300 --> 00:23:20,820
efficiency or for the overall attack so

555
00:23:20,820 --> 00:23:22,590
this whole attack was run on Google

556
00:23:22,590 --> 00:23:24,600
infrastructure which is a very large

557
00:23:24,600 --> 00:23:26,850
heterogeneous cluster distributed over

558
00:23:26,850 --> 00:23:30,870
the world of different CPUs and GPUs one

559
00:23:30,870 --> 00:23:33,090
of the problem is that was a completely

560
00:23:33,090 --> 00:23:35,310
proprietary both a compile and Jobs's

561
00:23:35,310 --> 00:23:37,140
and I had no knowledge of and could not

562
00:23:37,140 --> 00:23:39,330
get knowledge of so there was basically

563
00:23:39,330 --> 00:23:41,850
we wrote the source code and we handled

564
00:23:41,850 --> 00:23:44,190
to Google and there was this this blind

565
00:23:44,190 --> 00:23:48,030
adaption face-blind for us because did

566
00:23:48,030 --> 00:23:49,530
we didn't know what they were actually

567
00:23:49,530 --> 00:23:51,540
using and what our constraints were

568
00:23:51,540 --> 00:23:53,280
blind from the other direction because

569
00:23:53,280 --> 00:23:55,020
while we voted for ourselves or there

570
00:23:55,020 --> 00:23:57,300
were very few comments and documentation

571
00:23:57,300 --> 00:24:00,450
of the source code but we still with

572
00:24:00,450 --> 00:24:02,940
just some some email contact we really

573
00:24:02,940 --> 00:24:07,470
managed to overcome certain problems one

574
00:24:07,470 --> 00:24:10,120
problem was for instance that in CUDA

575
00:24:10,120 --> 00:24:12,220
development for a GPU development

576
00:24:12,220 --> 00:24:15,640
framework we use we used menaced

577
00:24:15,640 --> 00:24:19,360
variables which really convenient moves

578
00:24:19,360 --> 00:24:21,580
variables between CPU memory and GPU

579
00:24:21,580 --> 00:24:23,830
memory automatically apparently in the

580
00:24:23,830 --> 00:24:25,870
code google's compiled system this

581
00:24:25,870 --> 00:24:28,330
completely works and compiles find if

582
00:24:28,330 --> 00:24:29,890
you actually execute it it doesn't

583
00:24:29,890 --> 00:24:31,600
support managed at all but you don't see

584
00:24:31,600 --> 00:24:34,450
any error so you just have this feature

585
00:24:34,450 --> 00:24:36,820
that seems to work actually doesn't so

586
00:24:36,820 --> 00:24:38,490
trying to figure that out was also a

587
00:24:38,490 --> 00:24:43,690
time-consuming but so of course our

588
00:24:43,690 --> 00:24:45,760
attack consists of two sub attacks right

589
00:24:45,760 --> 00:24:47,380
the first new coalition attack actually

590
00:24:47,380 --> 00:24:49,360
we did this on CPU because we already

591
00:24:49,360 --> 00:24:51,730
had two source code lying about so we

592
00:24:51,730 --> 00:24:55,059
didn't wait for the development time to

593
00:24:55,059 --> 00:24:59,200
build GDP attacks and this was run over

594
00:24:59,200 --> 00:25:03,010
well 100,000 CPU cores over the course

595
00:25:03,010 --> 00:25:04,240
of several weeks and actually we

596
00:25:04,240 --> 00:25:06,399
executed this twice because at the time

597
00:25:06,399 --> 00:25:08,919
we didn't have this sad stab that which

598
00:25:08,919 --> 00:25:11,799
really efficiently solve this this old

599
00:25:11,799 --> 00:25:14,380
find problem and we wanted to have some

600
00:25:14,380 --> 00:25:16,179
degree of freedom and so this is now

601
00:25:16,179 --> 00:25:19,840
completely unnecessary anymore and then

602
00:25:19,840 --> 00:25:21,549
the second near-collision attack which

603
00:25:21,549 --> 00:25:23,649
theoretically is six times as hard is

604
00:25:23,649 --> 00:25:26,860
like the bulk of the computation was run

605
00:25:26,860 --> 00:25:32,649
on various nvidia tesla cards and this

606
00:25:32,649 --> 00:25:35,710
basically translates well to this 114 k

607
00:25:35,710 --> 00:25:39,159
24 years of or 71k 84 years which

608
00:25:39,159 --> 00:25:43,120
actually has more GPU cores and well

609
00:25:43,120 --> 00:25:46,330
this is quite a big number but yeah

610
00:25:46,330 --> 00:25:48,669
google has really a lot of GPUs and

611
00:25:48,669 --> 00:25:52,059
running on at least 3,000 GPUs and

612
00:25:52,059 --> 00:25:53,649
actually just the majority of the

613
00:25:53,649 --> 00:25:55,899
computation just ran an eighth calendar

614
00:25:55,899 --> 00:25:58,000
days which really shows that well it was

615
00:25:58,000 --> 00:26:00,100
two years work but most of it was

616
00:26:00,100 --> 00:26:01,570
development time right the majority of

617
00:26:01,570 --> 00:26:03,789
computation was just an eighth calendar

618
00:26:03,789 --> 00:26:06,130
days really show how practical shall

619
00:26:06,130 --> 00:26:10,929
want collisions are now so yeah this is

620
00:26:10,929 --> 00:26:15,520
our collision 128 bytes too and of

621
00:26:15,520 --> 00:26:17,169
course actually what we want to do is

622
00:26:17,169 --> 00:26:18,850
well not just create a random collision

623
00:26:18,850 --> 00:26:20,260
we wanted to create something meaningful

624
00:26:20,260 --> 00:26:22,179
and actually reusable the sha-1

625
00:26:22,179 --> 00:26:23,090
collision is very

626
00:26:23,090 --> 00:26:24,770
expensive so you want something that can

627
00:26:24,770 --> 00:26:28,400
be reused so we have one collision which

628
00:26:28,400 --> 00:26:30,650
is just a prefix of a PDF file and you

629
00:26:30,650 --> 00:26:33,080
can create infinite full PDF files that

630
00:26:33,080 --> 00:26:36,800
have distinct embedding PDF and the way

631
00:26:36,800 --> 00:26:38,900
it works is basically what we have this

632
00:26:38,900 --> 00:26:41,090
PDF header and JPEG header we start a

633
00:26:41,090 --> 00:26:42,680
JPEG comment and then here in this

634
00:26:42,680 --> 00:26:45,350
orange part we have the sha-1 collision

635
00:26:45,350 --> 00:26:48,410
and there is a difference here and so

636
00:26:48,410 --> 00:26:51,100
this length of the comment fields is

637
00:26:51,100 --> 00:26:55,130
different from this length and so the

638
00:26:55,130 --> 00:26:57,410
JPEG parser will skip over the comments

639
00:26:57,410 --> 00:26:59,360
and we'll start the processing image 1

640
00:26:59,360 --> 00:27:02,210
in this case and in this case it will

641
00:27:02,210 --> 00:27:04,610
jump to this first part and it will be

642
00:27:04,610 --> 00:27:06,350
another JPEG comment of a certain length

643
00:27:06,350 --> 00:27:08,870
basically skipping over image 1 and this

644
00:27:08,870 --> 00:27:11,000
JPEG parser will actually purge image to

645
00:27:11,000 --> 00:27:13,460
and of course the collision is here so

646
00:27:13,460 --> 00:27:15,290
you can plug in whatever image 1 and

647
00:27:15,290 --> 00:27:20,870
image 2 you want and you can actually do

648
00:27:20,870 --> 00:27:22,700
this yourself so this is a link here for

649
00:27:22,700 --> 00:27:24,110
somebody who created the script for you

650
00:27:24,110 --> 00:27:26,660
to just do this for any PDF files that

651
00:27:26,660 --> 00:27:32,870
you want we didn't really expect it to

652
00:27:32,870 --> 00:27:34,190
break something but we did break

653
00:27:34,190 --> 00:27:37,970
something namely subversion repositories

654
00:27:37,970 --> 00:27:39,770
because they were using sha-1 for found

655
00:27:39,770 --> 00:27:42,170
a duplication but they were using md5 to

656
00:27:42,170 --> 00:27:44,120
check if everything was sent correctly

657
00:27:44,120 --> 00:27:46,190
and basically putting a show on

658
00:27:46,190 --> 00:27:47,750
collision in there I just broke the

659
00:27:47,750 --> 00:27:49,580
repository because it could never get

660
00:27:49,580 --> 00:27:51,050
anything staying out of it anymore

661
00:27:51,050 --> 00:27:54,890
that actually validated with md5 so of

662
00:27:54,890 --> 00:27:58,160
course we had some more impact gates

663
00:27:58,160 --> 00:28:00,110
actually started moving away from sha-1

664
00:28:00,110 --> 00:28:04,790
and an actually Google Drive and Gmail

665
00:28:04,790 --> 00:28:06,710
not actively check for Shawanda

666
00:28:06,710 --> 00:28:09,500
collisions and also getting github at

667
00:28:09,500 --> 00:28:12,680
the end of my talk so briefly want to

668
00:28:12,680 --> 00:28:14,360
show show on collision detection

669
00:28:14,360 --> 00:28:16,130
that's a real-time detection for sure

670
00:28:16,130 --> 00:28:18,110
want collisions just a single message so

671
00:28:18,110 --> 00:28:20,030
you don't need to both messages and it's

672
00:28:20,030 --> 00:28:22,400
now actually also the this was used in

673
00:28:22,400 --> 00:28:24,680
getting get up by default in Gmail

674
00:28:24,680 --> 00:28:26,450
Google Drive Microsoft onedrive so

675
00:28:26,450 --> 00:28:28,250
that's very it's very nice right it's a

676
00:28:28,250 --> 00:28:29,960
real time protection against this show

677
00:28:29,960 --> 00:28:34,220
on collision attack so I basically want

678
00:28:34,220 --> 00:28:38,390
to end by my talk here and are there any

679
00:28:38,390 --> 00:28:40,490
questions

680
00:28:40,490 --> 00:28:47,740
[Applause]

