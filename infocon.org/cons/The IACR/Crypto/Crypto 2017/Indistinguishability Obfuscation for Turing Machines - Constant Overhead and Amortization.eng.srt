1
00:00:05,670 --> 00:00:07,800
so let me start with the broad wall for

2
00:00:07,800 --> 00:00:09,780
this talk so we are interested in

3
00:00:09,780 --> 00:00:12,240
developing generic mechanisms to improve

4
00:00:12,240 --> 00:00:14,280
the efficiency of indistinguishable

5
00:00:14,280 --> 00:00:16,139
industry indistinguishability office

6
00:00:16,139 --> 00:00:18,779
kitchen and this is basically motivated

7
00:00:18,779 --> 00:00:20,430
by the fact but that by now we have a

8
00:00:20,430 --> 00:00:22,260
lot of theoretical applications of IO

9
00:00:22,260 --> 00:00:25,289
and the efficiency of all of those

10
00:00:25,289 --> 00:00:27,810
applications basically depend upon the

11
00:00:27,810 --> 00:00:30,029
efficiency of IO and therefore it

12
00:00:30,029 --> 00:00:31,859
motivates the goal of improving the

13
00:00:31,859 --> 00:00:35,160
efficiency of IO in a generic manner so

14
00:00:35,160 --> 00:00:36,690
let me start with a very very brief

15
00:00:36,690 --> 00:00:38,400
overview of the main lines of research

16
00:00:38,400 --> 00:00:41,239
in in indistinguishable deification and

17
00:00:41,239 --> 00:00:43,470
one of the primary lines of research

18
00:00:43,470 --> 00:00:45,150
here is about constructing

19
00:00:45,150 --> 00:00:47,010
indistinguishable deification for

20
00:00:47,010 --> 00:00:49,409
general circuits and by now there's a

21
00:00:49,409 --> 00:00:52,530
lot of work in this area where the main

22
00:00:52,530 --> 00:00:54,000
motivation is to get better and better

23
00:00:54,000 --> 00:00:55,979
security based on weaker and weaker

24
00:00:55,979 --> 00:00:58,559
assumptions okay so while this is still

25
00:00:58,559 --> 00:01:00,479
a very active line of research a

26
00:01:00,479 --> 00:01:02,580
parallel line of research which has been

27
00:01:02,580 --> 00:01:04,739
going on is about improving the

28
00:01:04,739 --> 00:01:06,600
efficiency of IO and here I will just

29
00:01:06,600 --> 00:01:08,850
focus on the line of research which

30
00:01:08,850 --> 00:01:11,970
concentrates on off of getting more

31
00:01:11,970 --> 00:01:13,740
efficient representations of programs

32
00:01:13,740 --> 00:01:17,100
for example Turing machines and for

33
00:01:17,100 --> 00:01:18,480
example starting with the work of the

34
00:01:18,480 --> 00:01:21,180
Transkei at all by now we have some some

35
00:01:21,180 --> 00:01:22,980
schemes that show how to office care

36
00:01:22,980 --> 00:01:25,560
turing machines directly without the

37
00:01:25,560 --> 00:01:27,180
overhead of first transforming them to

38
00:01:27,180 --> 00:01:30,330
circuits by only relying upon IO for

39
00:01:30,330 --> 00:01:32,820
circuits okay and one of the main

40
00:01:32,820 --> 00:01:35,040
advantages of this of these works is

41
00:01:35,040 --> 00:01:37,110
that they achieve power input running

42
00:01:37,110 --> 00:01:38,850
time as opposed to the worst-case

43
00:01:38,850 --> 00:01:41,430
running time on inputs that is inherent

44
00:01:41,430 --> 00:01:46,110
in the circuit model okay one caveat of

45
00:01:46,110 --> 00:01:49,560
these works is that the correctness only

46
00:01:49,560 --> 00:01:51,990
holds for inputs of some a priori

47
00:01:51,990 --> 00:01:56,370
bounded length okay and while in this

48
00:01:56,370 --> 00:01:58,380
talk I'll only focus on IO for Turing

49
00:01:58,380 --> 00:02:00,060
machines let me mention that there are

50
00:02:00,060 --> 00:02:03,330
also lots of important works that extend

51
00:02:03,330 --> 00:02:05,400
these results further to the regime of

52
00:02:05,400 --> 00:02:09,508
office cating Ram programs but here I'll

53
00:02:09,508 --> 00:02:11,610
only talk about Turing machines and in

54
00:02:11,610 --> 00:02:13,650
particular our goal here is to construct

55
00:02:13,650 --> 00:02:15,450
obfuscation of Turing machines with

56
00:02:15,450 --> 00:02:18,300
better efficiency so let me actually

57
00:02:18,300 --> 00:02:19,890
elaborate what I mean by better

58
00:02:19,890 --> 00:02:21,480
efficiency so in particular we are

59
00:02:21,480 --> 00:02:23,970
interested in two problems the first

60
00:02:23,970 --> 00:02:28,140
problem is about size efficiency so we

61
00:02:28,140 --> 00:02:29,940
are interested in comparing the size of

62
00:02:29,940 --> 00:02:31,920
the obfuscated program relative to the

63
00:02:31,920 --> 00:02:34,530
size of the unaffiliated program okay so

64
00:02:34,530 --> 00:02:37,800
if we look at the results so far they

65
00:02:37,800 --> 00:02:39,930
incur polynomial overhead in the size of

66
00:02:39,930 --> 00:02:41,700
the underlying program that is the size

67
00:02:41,700 --> 00:02:43,830
of the office kitchen of some program M

68
00:02:43,830 --> 00:02:45,990
is a polynomial in the security

69
00:02:45,990 --> 00:02:48,210
parameter the size of the program M and

70
00:02:48,210 --> 00:02:51,000
some parameter L which denotes the

71
00:02:51,000 --> 00:02:52,980
length of the D upper bound on the input

72
00:02:52,980 --> 00:02:56,340
length and what we want is the constant

73
00:02:56,340 --> 00:02:58,320
overhead that is we want that the size

74
00:02:58,320 --> 00:03:00,750
of the obfuscated program should only be

75
00:03:00,750 --> 00:03:02,460
constant times the size of the

76
00:03:02,460 --> 00:03:04,920
underlying program M and some additive

77
00:03:04,920 --> 00:03:07,050
overhead in the secretive polynomial

78
00:03:07,050 --> 00:03:08,730
overhead in the security parameter and

79
00:03:08,730 --> 00:03:12,410
again the input length bound L okay and

80
00:03:12,410 --> 00:03:14,670
while we are studying this question for

81
00:03:14,670 --> 00:03:15,720
the case of Turing machines this

82
00:03:15,720 --> 00:03:17,310
question is already quite interesting

83
00:03:17,310 --> 00:03:19,110
for the case of circuits and in that

84
00:03:19,110 --> 00:03:21,120
case the work of baton ski and Baku

85
00:03:21,120 --> 00:03:22,890
nothing actually showed how to resolve

86
00:03:22,890 --> 00:03:26,880
this problem the second problem that we

87
00:03:26,880 --> 00:03:28,440
are interested in is that of

88
00:03:28,440 --> 00:03:30,480
amortization so let me explain what I

89
00:03:30,480 --> 00:03:33,060
mean so let's say that we are given an

90
00:03:33,060 --> 00:03:35,400
indistinguishable D of a skater for

91
00:03:35,400 --> 00:03:37,650
circuits of some fixed a priori fixed

92
00:03:37,650 --> 00:03:40,830
size okay and now somebody comes and

93
00:03:40,830 --> 00:03:42,209
tells us that they want to obfuscate

94
00:03:42,209 --> 00:03:44,190
some polynomial number of Turing

95
00:03:44,190 --> 00:03:45,690
machines where this polynomial could be

96
00:03:45,690 --> 00:03:48,870
arbitrary okay so the question is how

97
00:03:48,870 --> 00:03:50,430
many invocations of the underlying

98
00:03:50,430 --> 00:03:51,780
indistinguishable D of a scalar

99
00:03:51,780 --> 00:03:53,850
do I need to make in order to offer

100
00:03:53,850 --> 00:03:55,920
scale all of these Turing machines in

101
00:03:55,920 --> 00:03:57,840
particular can we have scale all of them

102
00:03:57,840 --> 00:04:01,110
with less than n invocations of the

103
00:04:01,110 --> 00:04:02,459
underlying indistinguishable diverse

104
00:04:02,459 --> 00:04:04,380
character and ideally we want to go as

105
00:04:04,380 --> 00:04:06,480
small as possible yes so that's the

106
00:04:06,480 --> 00:04:11,370
question of amortization okay so before

107
00:04:11,370 --> 00:04:13,230
staring our results let me mention that

108
00:04:13,230 --> 00:04:14,880
if you actually pause for a moment and

109
00:04:14,880 --> 00:04:17,279
think about both of these questions they

110
00:04:17,279 --> 00:04:18,750
will be you'll see you'll see that they

111
00:04:18,750 --> 00:04:20,820
are quite easy to realize if you were

112
00:04:20,820 --> 00:04:22,950
given IO for Turing machines that

113
00:04:22,950 --> 00:04:26,760
supports inputs of unbounded lengths so

114
00:04:26,760 --> 00:04:29,539
you can you can verify this on your own

115
00:04:29,539 --> 00:04:32,220
however presently such iOS

116
00:04:32,220 --> 00:04:34,920
teams are not known from IO for circuits

117
00:04:34,920 --> 00:04:36,990
basically the only way we know how to

118
00:04:36,990 --> 00:04:39,060
achieve alpha Turing machines with

119
00:04:39,060 --> 00:04:41,010
unbounded input lengths are either by

120
00:04:41,010 --> 00:04:43,200
using the stronger notion of differing

121
00:04:43,200 --> 00:04:45,570
input sophistication or a weaker version

122
00:04:45,570 --> 00:04:47,520
of it called public coin differing

123
00:04:47,520 --> 00:04:50,730
inputs office Kishen or another notion

124
00:04:50,730 --> 00:04:53,280
called output compressing randomized and

125
00:04:53,280 --> 00:04:56,400
codings but none of these primitives are

126
00:04:56,400 --> 00:04:58,350
known to be realizable from

127
00:04:58,350 --> 00:05:01,140
indistinguishable deification and our

128
00:05:01,140 --> 00:05:03,900
goal is to build achieve both of these

129
00:05:03,900 --> 00:05:05,670
problems solve both of these problems by

130
00:05:05,670 --> 00:05:08,040
using i/o for circuits okay so that

131
00:05:08,040 --> 00:05:10,350
brings me to our result statement so a

132
00:05:10,350 --> 00:05:12,510
first result is IO for Turing machines

133
00:05:12,510 --> 00:05:14,940
with constant multiplicative overhead

134
00:05:14,940 --> 00:05:19,710
where the constant is simply to the

135
00:05:19,710 --> 00:05:22,200
assumptions are sub exponentially secure

136
00:05:22,200 --> 00:05:25,200
I of a circuit and realizable encryption

137
00:05:25,200 --> 00:05:29,760
scheme the second result is that we

138
00:05:29,760 --> 00:05:31,140
achieve I offer Turing machines with

139
00:05:31,140 --> 00:05:33,510
amortization in fact the best possible

140
00:05:33,510 --> 00:05:36,390
or motorisation where if we want to over

141
00:05:36,390 --> 00:05:37,919
skate some polynomial number of Turing

142
00:05:37,919 --> 00:05:40,350
machines then we can office Kate them

143
00:05:40,350 --> 00:05:43,410
all by only making one invocation to an

144
00:05:43,410 --> 00:05:46,260
i/o for circuits whose size is a priori

145
00:05:46,260 --> 00:05:49,800
fixed okay and the size of the

146
00:05:49,800 --> 00:05:51,720
underlying circuit family only depends

147
00:05:51,720 --> 00:05:54,510
on the security parameter and inputs and

148
00:05:54,510 --> 00:05:56,430
bound L that we assumed for all the

149
00:05:56,430 --> 00:05:59,340
Turing machines okay and the assumptions

150
00:05:59,340 --> 00:06:00,630
in this result are the same as the

151
00:06:00,630 --> 00:06:07,530
previous one okay so let me now go over

152
00:06:07,530 --> 00:06:10,380
some of our techniques and in this talk

153
00:06:10,380 --> 00:06:14,580
I'll primarily focus on the the first

154
00:06:14,580 --> 00:06:16,890
result that is achieving IO with the

155
00:06:16,890 --> 00:06:20,760
constant overhead so towards that let's

156
00:06:20,760 --> 00:06:24,270
first briefly recap how do we build i/o

157
00:06:24,270 --> 00:06:25,950
for Turing machines presently what is

158
00:06:25,950 --> 00:06:27,870
the current template that is followed in

159
00:06:27,870 --> 00:06:31,290
in existing works so these works

160
00:06:31,290 --> 00:06:34,020
basically use two ingredients to build

161
00:06:34,020 --> 00:06:35,910
i/o for Turing machines the first

162
00:06:35,910 --> 00:06:37,770
ingredient is the i/o for circuits a

163
00:06:37,770 --> 00:06:40,140
general-purpose indistinguishability of

164
00:06:40,140 --> 00:06:42,930
a scalar and the second ingredient is a

165
00:06:42,930 --> 00:06:45,660
randomized encoding for Turing machines

166
00:06:45,660 --> 00:06:48,120
and this is really the the hard part of

167
00:06:48,120 --> 00:06:50,070
these constructions I'm not going to

168
00:06:50,070 --> 00:06:51,840
discuss how these things are constructed

169
00:06:51,840 --> 00:06:54,960
but but if we are given both of these

170
00:06:54,960 --> 00:06:56,730
ingredients this is how you can

171
00:06:56,730 --> 00:06:59,430
obfuscate Turing machines so the idea is

172
00:06:59,430 --> 00:07:01,050
as follows suppose we want to offer

173
00:07:01,050 --> 00:07:03,920
skate a Turing machine M then we take

174
00:07:03,920 --> 00:07:06,060
indistinguishability obfuscation for the

175
00:07:06,060 --> 00:07:08,520
following circuit this circuit has the

176
00:07:08,520 --> 00:07:10,770
Machine M hardwired inside it together

177
00:07:10,770 --> 00:07:14,250
with a PRF key yeah upon receiving an

178
00:07:14,250 --> 00:07:16,590
input X for the machine M this

179
00:07:16,590 --> 00:07:17,940
indistinguishability of a skater

180
00:07:17,940 --> 00:07:20,070
internally computes a randomized

181
00:07:20,070 --> 00:07:22,620
encoding of the Machine M together with

182
00:07:22,620 --> 00:07:25,380
the input X and the randomness that it

183
00:07:25,380 --> 00:07:27,000
uses for this computation is derived

184
00:07:27,000 --> 00:07:29,940
from the PRF and then using this

185
00:07:29,940 --> 00:07:31,440
randomness set out it computes and

186
00:07:31,440 --> 00:07:33,750
outputs a fresh randomized encoding of

187
00:07:33,750 --> 00:07:35,700
the machine M together with the input X

188
00:07:35,700 --> 00:07:38,010
and the decoding algorithm is public so

189
00:07:38,010 --> 00:07:40,110
upon receiving this any evaluator can

190
00:07:40,110 --> 00:07:42,360
simply decode and obtain the output M of

191
00:07:42,360 --> 00:07:46,260
X ok so that's the deck event template

192
00:07:46,260 --> 00:07:50,280
so I want to now point out the main

193
00:07:50,280 --> 00:07:52,410
bottlenecks that this template presents

194
00:07:52,410 --> 00:07:54,750
towards achieving the first goal which

195
00:07:54,750 --> 00:07:58,770
is a constant overhead okay so if you

196
00:07:58,770 --> 00:08:01,020
look at this template you'll notice that

197
00:08:01,020 --> 00:08:02,790
the first bottleneck is that since

198
00:08:02,790 --> 00:08:05,130
machine M is already embedded inside the

199
00:08:05,130 --> 00:08:06,930
circuit then if we want to achieve

200
00:08:06,930 --> 00:08:09,030
constant overhead we already need to

201
00:08:09,030 --> 00:08:11,160
start with a circuit office keishon

202
00:08:11,160 --> 00:08:12,750
scheme which achieves constant overhead

203
00:08:12,750 --> 00:08:16,230
okay but an even bigger water link is

204
00:08:16,230 --> 00:08:19,169
that because the encoding algorithm of

205
00:08:19,169 --> 00:08:21,030
the randomized encoding is also embedded

206
00:08:21,030 --> 00:08:23,280
inside the circuit we in fact need even

207
00:08:23,280 --> 00:08:25,350
a even stronger property right we

208
00:08:25,350 --> 00:08:28,770
require that the randomized encoding

209
00:08:28,770 --> 00:08:31,350
scheme is such that that its running

210
00:08:31,350 --> 00:08:33,929
time only incurs a constant overhead in

211
00:08:33,929 --> 00:08:35,760
the size of the Turing machine M and

212
00:08:35,760 --> 00:08:38,729
this is an extremely hard problem to

213
00:08:38,729 --> 00:08:40,679
solve in fact even for classical

214
00:08:40,679 --> 00:08:42,539
primitives such as encryption schemes we

215
00:08:42,539 --> 00:08:44,190
only know how to achieve constant

216
00:08:44,190 --> 00:08:46,590
overhead in running times only using

217
00:08:46,590 --> 00:08:50,130
non-standard assumptions okay so so

218
00:08:50,130 --> 00:08:51,660
these are kind of the main bottlenecks

219
00:08:51,660 --> 00:08:55,500
that one faces when trying to you know

220
00:08:55,500 --> 00:08:57,930
extend this this template towards

221
00:08:57,930 --> 00:08:59,400
achieving our goals

222
00:08:59,400 --> 00:09:01,890
and let me mention one more point that

223
00:09:01,890 --> 00:09:03,810
if you if you look at this template

224
00:09:03,810 --> 00:09:05,790
there's some there's some redundancy

225
00:09:05,790 --> 00:09:08,160
here right the Machine M is basically

226
00:09:08,160 --> 00:09:10,530
encoded every time you want to evaluate

227
00:09:10,530 --> 00:09:12,600
it on its on some input right it would

228
00:09:12,600 --> 00:09:14,760
be nice if we could just bring out the

229
00:09:14,760 --> 00:09:16,290
machine m outside of this office kitchen

230
00:09:16,290 --> 00:09:19,260
and then encoded only once and this is

231
00:09:19,260 --> 00:09:20,760
kind of what we do and it turns out this

232
00:09:20,760 --> 00:09:22,860
is in fact the key to achieving our

233
00:09:22,860 --> 00:09:25,590
goals okay so let me now present our new

234
00:09:25,590 --> 00:09:27,270
template which is kind of the main point

235
00:09:27,270 --> 00:09:30,390
of this work a new template for office

236
00:09:30,390 --> 00:09:32,160
getting turing machines which also turns

237
00:09:32,160 --> 00:09:34,530
out to be very useful for achieving both

238
00:09:34,530 --> 00:09:36,990
our four goals okay so the new template

239
00:09:36,990 --> 00:09:39,270
is as follows in order to obfuscate a

240
00:09:39,270 --> 00:09:41,760
turing machine m we basically use two

241
00:09:41,760 --> 00:09:43,890
ingredients the first ingredient is i/o

242
00:09:43,890 --> 00:09:46,230
for circuits which is as before the

243
00:09:46,230 --> 00:09:47,610
second one i've put a question mark

244
00:09:47,610 --> 00:09:49,980
there because i want to basically derive

245
00:09:49,980 --> 00:09:51,510
what other properties that we would want

246
00:09:51,510 --> 00:09:53,430
from the second ingredient okay

247
00:09:53,430 --> 00:09:56,010
so let's first focus on the i/o for

248
00:09:56,010 --> 00:09:58,920
circuits so we use i/o for circuits to

249
00:09:58,920 --> 00:10:00,480
basically office kate some kind of input

250
00:10:00,480 --> 00:10:02,820
encoder okay which just takes some input

251
00:10:02,820 --> 00:10:05,430
x for the machine m and outputs some

252
00:10:05,430 --> 00:10:07,740
encoding of this input okay and in

253
00:10:07,740 --> 00:10:09,390
particular this input encoder is

254
00:10:09,390 --> 00:10:12,510
independent of the Turing machine M okay

255
00:10:12,510 --> 00:10:14,220
so therefore the eye of our circuits

256
00:10:14,220 --> 00:10:17,120
does not operate on the machine M at all

257
00:10:17,120 --> 00:10:21,570
okay and now if we look together at this

258
00:10:21,570 --> 00:10:24,210
encoding of X and the encoding of the

259
00:10:24,210 --> 00:10:26,310
machine we want this to basically

260
00:10:26,310 --> 00:10:29,280
represent a randomized encoding okay and

261
00:10:29,280 --> 00:10:30,540
because they are encoding encoded

262
00:10:30,540 --> 00:10:32,790
separately this is basically a

263
00:10:32,790 --> 00:10:37,470
decomposable randomized encoding okay

264
00:10:37,470 --> 00:10:39,960
moreover since the machine m is only

265
00:10:39,960 --> 00:10:43,980
encoded once okay over all therefore we

266
00:10:43,980 --> 00:10:45,840
want this randomized encoding to have a

267
00:10:45,840 --> 00:10:47,760
reusability property right that it

268
00:10:47,760 --> 00:10:49,500
should be possible to reuse the encoding

269
00:10:49,500 --> 00:10:52,230
of M many times for evaluating different

270
00:10:52,230 --> 00:10:55,860
inputs yeah and finally we want that we

271
00:10:55,860 --> 00:10:57,680
should be able to construct such a

272
00:10:57,680 --> 00:11:00,150
reusable randomization coding without

273
00:11:00,150 --> 00:11:01,950
using i/o right that's kind of the point

274
00:11:01,950 --> 00:11:05,730
and in order to for example achieve our

275
00:11:05,730 --> 00:11:07,680
first goal of constant overhead we would

276
00:11:07,680 --> 00:11:09,930
want to construct such a reusable

277
00:11:09,930 --> 00:11:12,470
decomposable re with

278
00:11:12,470 --> 00:11:15,170
and overhead yeah so so that turns out

279
00:11:15,170 --> 00:11:17,990
to be the key the key technical

280
00:11:17,990 --> 00:11:22,340
contribution of the work so so in order

281
00:11:22,340 --> 00:11:24,470
to go there let me first elaborate on

282
00:11:24,470 --> 00:11:26,840
this notion the reusable decomposable re

283
00:11:26,840 --> 00:11:29,870
as probably you're familiar when working

284
00:11:29,870 --> 00:11:32,330
with IO we always need to typically

285
00:11:32,330 --> 00:11:35,300
modify the the notions to make them io

286
00:11:35,300 --> 00:11:37,550
friendly okay and this is basically our

287
00:11:37,550 --> 00:11:39,800
first step to formalize a notion of

288
00:11:39,800 --> 00:11:42,260
reusable decomposable re which is

289
00:11:42,260 --> 00:11:45,110
friendly towards IO facilitates security

290
00:11:45,110 --> 00:11:47,290
proofs okay and this is what we call

291
00:11:47,290 --> 00:11:51,590
oblivious evaluation in codings so to

292
00:11:51,590 --> 00:11:52,970
explain this notion let's look at the

293
00:11:52,970 --> 00:11:55,670
setting where we have Alice with input X

294
00:11:55,670 --> 00:11:59,510
and some bit B and we have Bob who has

295
00:11:59,510 --> 00:12:03,290
two machines m0 and m1 and we want that

296
00:12:03,290 --> 00:12:07,700
somehow given some encoding an evaluator

297
00:12:07,700 --> 00:12:10,760
Eve should be able to compute M sub B of

298
00:12:10,760 --> 00:12:16,490
X and we want that the evaluator should

299
00:12:16,490 --> 00:12:18,320
not be able to learn which of the two

300
00:12:18,320 --> 00:12:20,270
machines was used to actually compute

301
00:12:20,270 --> 00:12:24,350
the output C okay so the notion of

302
00:12:24,350 --> 00:12:26,000
oblivious evaluation in coatings

303
00:12:26,000 --> 00:12:28,700
basically results this problem where we

304
00:12:28,700 --> 00:12:30,920
have some kind of setup which is used to

305
00:12:30,920 --> 00:12:32,720
generate some secret key and there the

306
00:12:32,720 --> 00:12:34,490
secret Keys are given to Alison palm

307
00:12:34,490 --> 00:12:36,890
using the secret key Alice can encode

308
00:12:36,890 --> 00:12:38,900
the input X together with the bit B and

309
00:12:38,900 --> 00:12:41,780
Bob can encode the machines m0 and m1

310
00:12:41,780 --> 00:12:45,590
and now when evaluator receives both of

311
00:12:45,590 --> 00:12:47,420
these encoding then we can run some

312
00:12:47,420 --> 00:12:51,950
decoding operation to learn MB of X okay

313
00:12:51,950 --> 00:12:54,500
so here is basically the syntax with

314
00:12:54,500 --> 00:12:57,140
just you know States bit more precisely

315
00:12:57,140 --> 00:12:59,480
what I just said there's a set up

316
00:12:59,480 --> 00:13:01,640
algorithm which outputs a secret key our

317
00:13:01,640 --> 00:13:03,890
tuning machine and coding algorithm an

318
00:13:03,890 --> 00:13:05,780
input encoding algorithm and then

319
00:13:05,780 --> 00:13:08,810
finally the decoding algorithm okay so

320
00:13:08,810 --> 00:13:10,910
this so far is very similar to a

321
00:13:10,910 --> 00:13:13,040
standard reusable randomized encoding

322
00:13:13,040 --> 00:13:14,540
scheme except that you know we are

323
00:13:14,540 --> 00:13:16,280
encoding two machines instead of one and

324
00:13:16,280 --> 00:13:18,410
we are encoding a bit together with the

325
00:13:18,410 --> 00:13:20,480
input right so so far it's not really

326
00:13:20,480 --> 00:13:21,650
much different from a reusable

327
00:13:21,650 --> 00:13:23,930
randomized encoding the main thing that

328
00:13:23,930 --> 00:13:25,250
separates this notion

329
00:13:25,250 --> 00:13:27,920
the existing notion is really these two

330
00:13:27,920 --> 00:13:30,380
algorithms that I'll mentioned but

331
00:13:30,380 --> 00:13:32,000
before that let me just say that the

332
00:13:32,000 --> 00:13:33,440
notion of constant overhead in the

333
00:13:33,440 --> 00:13:35,270
fairing basically means that if you look

334
00:13:35,270 --> 00:13:38,150
at the Turing machine encoding then you

335
00:13:38,150 --> 00:13:40,310
want that the size of this Turing

336
00:13:40,310 --> 00:13:42,650
machine encoding is simply constant

337
00:13:42,650 --> 00:13:44,840
times the size of the machines m0 m1

338
00:13:44,840 --> 00:13:46,940
plus some polynomial in the security

339
00:13:46,940 --> 00:13:50,140
parameter okay so here are the two

340
00:13:50,140 --> 00:13:52,640
algorithms that I was alluding to the

341
00:13:52,640 --> 00:13:56,030
first algorithm is an algorithm that

342
00:13:56,030 --> 00:13:57,800
allows you to compute punctured keys

343
00:13:57,800 --> 00:14:00,350
okay and the keys can be punctured on

344
00:14:00,350 --> 00:14:03,080
any input any point X in the input space

345
00:14:03,080 --> 00:14:07,670
yeah and correctness says that if you

346
00:14:07,670 --> 00:14:09,770
give me a punk a key that is punctured

347
00:14:09,770 --> 00:14:12,200
at point X then you can still use it to

348
00:14:12,200 --> 00:14:14,600
encode any other point in the space okay

349
00:14:14,600 --> 00:14:18,020
with respect to bit zero orbit 1 ok both

350
00:14:18,020 --> 00:14:20,960
of them actually and security property

351
00:14:20,960 --> 00:14:22,580
basically says that even if you are

352
00:14:22,580 --> 00:14:25,610
given this punctured key and then if I

353
00:14:25,610 --> 00:14:28,040
give you an encoding on that puncture

354
00:14:28,040 --> 00:14:31,190
point X with respect to bit 0 or an

355
00:14:31,190 --> 00:14:33,080
encoding of that point X with respect to

356
00:14:33,080 --> 00:14:35,150
bit 1 you cannot decide which one was

357
00:14:35,150 --> 00:14:37,460
given to you ok and even if I give you

358
00:14:37,460 --> 00:14:40,370
some extra information let's ignore that

359
00:14:40,370 --> 00:14:44,089
for now the second auxiliary algorithm

360
00:14:44,089 --> 00:14:46,280
is basically puncturing on the bit

361
00:14:46,280 --> 00:14:49,700
instead of on the input ok so the key

362
00:14:49,700 --> 00:14:51,470
can now also be punctured on the bit and

363
00:14:51,470 --> 00:14:54,140
correctness will say that if I puncture

364
00:14:54,140 --> 00:14:55,880
if I give you a key that is punctuated

365
00:14:55,880 --> 00:14:58,339
bit B then you can use it to encode any

366
00:14:58,339 --> 00:15:02,770
input with respect to bit 1 minus V and

367
00:15:02,770 --> 00:15:05,450
security property will say that if I

368
00:15:05,450 --> 00:15:07,910
give you for example the key puncture

369
00:15:07,910 --> 00:15:10,940
that bit 1 then you cannot distinguish

370
00:15:10,940 --> 00:15:14,210
if I give you an encoding of M 0 M 0 or

371
00:15:14,210 --> 00:15:17,540
M 0 M 1 yeah so because the key that is

372
00:15:17,540 --> 00:15:19,430
punctured at bit 1 you know will not

373
00:15:19,430 --> 00:15:21,770
allow you to in you know compute the

374
00:15:21,770 --> 00:15:23,720
output with respect to the second

375
00:15:23,720 --> 00:15:25,970
machines m0 and m1 therefore you cannot

376
00:15:25,970 --> 00:15:31,480
distinguish okay

377
00:15:31,480 --> 00:15:34,280
so given that notion let's just assume

378
00:15:34,280 --> 00:15:36,760
for now that we know how to construct it

379
00:15:36,760 --> 00:15:38,670
and let's just see how

380
00:15:38,670 --> 00:15:40,080
we can use oblivious evaluation in

381
00:15:40,080 --> 00:15:42,150
coatings to construct IO for Turing

382
00:15:42,150 --> 00:15:45,690
machines with constant overhead so the

383
00:15:45,690 --> 00:15:47,910
construction is quite simple let's say

384
00:15:47,910 --> 00:15:49,470
we want to obfuscate a Turing machine M

385
00:15:49,470 --> 00:15:51,750
then we'll have two ingredients the

386
00:15:51,750 --> 00:15:54,450
first one will be an IO for circuits

387
00:15:54,450 --> 00:15:57,300
where the circuit basically takes any

388
00:15:57,300 --> 00:16:00,420
input X and computes an encoding of that

389
00:16:00,420 --> 00:16:02,940
of that input with respect to the OE

390
00:16:02,940 --> 00:16:05,250
scheme and the second ingredient is

391
00:16:05,250 --> 00:16:07,200
simply Turing machine encoding of the

392
00:16:07,200 --> 00:16:11,060
machine M just repeated twice okay and

393
00:16:11,060 --> 00:16:13,980
the first component is independent of

394
00:16:13,980 --> 00:16:16,320
the machine m and the second component

395
00:16:16,320 --> 00:16:18,390
since we start from a scheme which has

396
00:16:18,390 --> 00:16:20,910
constant overhead therefore the

397
00:16:20,910 --> 00:16:22,740
resulting scheme will also help then

398
00:16:22,740 --> 00:16:24,870
constant overhead so pictorially it

399
00:16:24,870 --> 00:16:26,580
looks like this we start with some input

400
00:16:26,580 --> 00:16:29,250
X and then compute an encoding of X with

401
00:16:29,250 --> 00:16:31,440
respect to the bit 0 and then we take

402
00:16:31,440 --> 00:16:33,480
these two encoding together we decode it

403
00:16:33,480 --> 00:16:38,970
and we get M of X ok and very very

404
00:16:38,970 --> 00:16:40,770
quickly the way we do the security proof

405
00:16:40,770 --> 00:16:42,060
is as follows

406
00:16:42,060 --> 00:16:43,350
so we want to argue in

407
00:16:43,350 --> 00:16:45,570
distinguishability of obfuscation of m0

408
00:16:45,570 --> 00:16:49,020
from office keishon of m1 so the first

409
00:16:49,020 --> 00:16:52,530
step is to simply switch from encoding m

410
00:16:52,530 --> 00:16:56,580
0 m 0 to m0 m1 and here we use the bit

411
00:16:56,580 --> 00:16:59,670
puncturing key then we do the standard

412
00:16:59,670 --> 00:17:02,040
i/o gymnastics you know which people are

413
00:17:02,040 --> 00:17:05,099
familiar with by now namely positional

414
00:17:05,099 --> 00:17:06,960
IO techniques from the works of Gentry

415
00:17:06,960 --> 00:17:09,660
at all where we switch from computing on

416
00:17:09,660 --> 00:17:13,140
m0 to computing on m1 1 input at a time

417
00:17:13,140 --> 00:17:15,569
and here we use the input puncturing key

418
00:17:15,569 --> 00:17:18,450
at the end only and 1 is being used for

419
00:17:18,450 --> 00:17:20,910
computation so now we can switch from m0

420
00:17:20,910 --> 00:17:23,940
m1 to m1 m1 again you think the bit

421
00:17:23,940 --> 00:17:28,650
puncturing key so you know I do not

422
00:17:28,650 --> 00:17:29,940
expect you to understand all this proof

423
00:17:29,940 --> 00:17:31,410
but basically the point was just to show

424
00:17:31,410 --> 00:17:34,230
that the notion of a was you know pretty

425
00:17:34,230 --> 00:17:37,290
much tailored to work with io you know

426
00:17:37,290 --> 00:17:39,510
to facilitate the security proof with IO

427
00:17:39,510 --> 00:17:42,300
it was a natural extension of the notion

428
00:17:42,300 --> 00:17:44,370
of reusable randomization coding to

429
00:17:44,370 --> 00:17:47,730
facilitate the security proof ok and now

430
00:17:47,730 --> 00:17:50,190
let me just briefly go over how we

431
00:17:50,190 --> 00:17:52,590
construct an oblivious evaluation in

432
00:17:52,590 --> 00:17:54,350
coding scheme with the constant overhead

433
00:17:54,350 --> 00:17:57,510
so we follow a two-step approach the

434
00:17:57,510 --> 00:17:59,700
first step is to construct attribute

435
00:17:59,700 --> 00:18:01,740
based encryption for Turing machines

436
00:18:01,740 --> 00:18:05,460
with the constant overhead and the

437
00:18:05,460 --> 00:18:07,830
second step is to then compile it into

438
00:18:07,830 --> 00:18:10,080
an OE scheme while preserving the the

439
00:18:10,080 --> 00:18:12,539
efficiency properties and in fact the

440
00:18:12,539 --> 00:18:13,890
attribute based encryption scheme that

441
00:18:13,890 --> 00:18:16,140
we need is only single key so we only

442
00:18:16,140 --> 00:18:18,480
need security for a single function a

443
00:18:18,480 --> 00:18:21,840
single attribute key and in this talk

444
00:18:21,840 --> 00:18:24,299
I'll just skip the second step just talk

445
00:18:24,299 --> 00:18:25,559
briefly about the first step of

446
00:18:25,559 --> 00:18:28,110
constructing a B scheme for Turing

447
00:18:28,110 --> 00:18:31,440
machines so here is a quick recap of

448
00:18:31,440 --> 00:18:33,149
what are what is an attribute based

449
00:18:33,149 --> 00:18:36,570
encryption scheme there is some set up

450
00:18:36,570 --> 00:18:38,309
algorithm which generates a public key a

451
00:18:38,309 --> 00:18:41,370
master secret key the the encrypter can

452
00:18:41,370 --> 00:18:45,029
encrypt using the public key any any any

453
00:18:45,029 --> 00:18:48,630
message X together with any any label X

454
00:18:48,630 --> 00:18:50,279
together with some secret message and

455
00:18:50,279 --> 00:18:53,700
then the the other entity Bob can use

456
00:18:53,700 --> 00:18:55,679
the master secret key to compute a

457
00:18:55,679 --> 00:18:58,830
secret key tied to some machine m and

458
00:18:58,830 --> 00:19:01,049
then given the secret key and the

459
00:19:01,049 --> 00:19:02,490
ciphertext the evaluator

460
00:19:02,490 --> 00:19:04,980
can learn the message the secret message

461
00:19:04,980 --> 00:19:07,289
only if the evaluation of the machine m

462
00:19:07,289 --> 00:19:12,450
on input X is 1 ok and again the notion

463
00:19:12,450 --> 00:19:13,980
of constant overhead here can be

464
00:19:13,980 --> 00:19:18,779
suitably defined okay so in order to

465
00:19:18,779 --> 00:19:20,490
construct an attribute based encryption

466
00:19:20,490 --> 00:19:22,649
scheme for Turing machines with constant

467
00:19:22,649 --> 00:19:23,010
overhead

468
00:19:23,010 --> 00:19:25,799
our starting point is really this work

469
00:19:25,799 --> 00:19:28,799
of copy light which has driven a lot of

470
00:19:28,799 --> 00:19:31,370
you know subsequent works in this area

471
00:19:31,370 --> 00:19:34,500
and I'll just talk about one of their

472
00:19:34,500 --> 00:19:37,020
main results which is constructing

473
00:19:37,020 --> 00:19:39,299
message hiding and codings if you're not

474
00:19:39,299 --> 00:19:40,950
familiar with the this notion of message

475
00:19:40,950 --> 00:19:42,570
hiding and codings you can just think of

476
00:19:42,570 --> 00:19:44,520
them as very similar to randomized and

477
00:19:44,520 --> 00:19:47,070
codings except that here we encode the

478
00:19:47,070 --> 00:19:50,370
machine m a label X and a secret message

479
00:19:50,370 --> 00:19:53,520
and the evaluator learns the message

480
00:19:53,520 --> 00:20:00,360
only if M of X is equal to 1 ok so at a

481
00:20:00,360 --> 00:20:01,440
high level this is what their

482
00:20:01,440 --> 00:20:03,899
construction looks like so there is some

483
00:20:03,899 --> 00:20:06,330
work tape which is initialized with

484
00:20:06,330 --> 00:20:09,870
input and we construct some storage tree

485
00:20:09,870 --> 00:20:12,269
on top of this work tip using something

486
00:20:12,269 --> 00:20:14,760
called position accumulators you don't

487
00:20:14,760 --> 00:20:17,010
need to know what exactly it is and then

488
00:20:17,010 --> 00:20:19,200
once we have the root then we construct

489
00:20:19,200 --> 00:20:21,360
then we compute a signature on it again

490
00:20:21,360 --> 00:20:22,890
using some IO friendly notion of

491
00:20:22,890 --> 00:20:26,130
signatures okay there is a second

492
00:20:26,130 --> 00:20:28,289
component to this construction which is

493
00:20:28,289 --> 00:20:30,600
an obfuscated next message function of

494
00:20:30,600 --> 00:20:34,890
the Turing machine M that we wanted to

495
00:20:34,890 --> 00:20:37,260
for which we wanted to compute and mhe

496
00:20:37,260 --> 00:20:39,840
and this office kated next message

497
00:20:39,840 --> 00:20:42,419
function also has the message inside it

498
00:20:42,419 --> 00:20:45,299
together with the key pair the key pair

499
00:20:45,299 --> 00:20:47,789
that is used to compute this spirit able

500
00:20:47,789 --> 00:20:51,269
signature on the road and finally there

501
00:20:51,269 --> 00:20:53,909
is also a counter which maintains the

502
00:20:53,909 --> 00:20:55,740
current state and it's initialized to

503
00:20:55,740 --> 00:20:58,769
the zero state and the evaluation works

504
00:20:58,769 --> 00:21:01,529
in a very natural way you start with the

505
00:21:01,529 --> 00:21:03,000
first memory location you know you read

506
00:21:03,000 --> 00:21:05,130
it you take the path from the leaf to

507
00:21:05,130 --> 00:21:06,990
the root the signature on the root and

508
00:21:06,990 --> 00:21:08,909
then you know feed it to the office

509
00:21:08,909 --> 00:21:10,830
kidded program the obfuscated program

510
00:21:10,830 --> 00:21:12,899
will verify everything compute the next

511
00:21:12,899 --> 00:21:15,179
step and then compute the new root and

512
00:21:15,179 --> 00:21:17,039
output it together with a new signature

513
00:21:17,039 --> 00:21:19,590
and then the evaluator can update this

514
00:21:19,590 --> 00:21:21,809
this entire storage tree on its own and

515
00:21:21,809 --> 00:21:24,330
then you know continue this computation

516
00:21:24,330 --> 00:21:26,970
on and on and finally at some point if

517
00:21:26,970 --> 00:21:29,610
it hits the accept state then this

518
00:21:29,610 --> 00:21:31,889
office cated you know program should

519
00:21:31,889 --> 00:21:37,350
output the secret message yeah and the

520
00:21:37,350 --> 00:21:39,029
security proof for this construction is

521
00:21:39,029 --> 00:21:42,690
again you know follows a pattern which

522
00:21:42,690 --> 00:21:45,120
you know people who work in our

523
00:21:45,120 --> 00:21:47,039
literature are familiar with where you

524
00:21:47,039 --> 00:21:49,769
have some sets of hybrids and in the IDE

525
00:21:49,769 --> 00:21:52,559
sets set of the hybrids the computation

526
00:21:52,559 --> 00:21:54,529
of the machine M effects is

527
00:21:54,529 --> 00:21:57,510
authenticated at the Ayad step of the

528
00:21:57,510 --> 00:21:58,919
computation of machine M is

529
00:21:58,919 --> 00:22:01,590
authenticated and nothing else can be

530
00:22:01,590 --> 00:22:06,260
verified by the obfuscated program and

531
00:22:06,260 --> 00:22:09,840
just keep that in mind when I mentioned

532
00:22:09,840 --> 00:22:11,880
the main the main issue in extending

533
00:22:11,880 --> 00:22:13,380
this idea to the a B setting and

534
00:22:13,380 --> 00:22:16,039
basically we have two challenges here

535
00:22:16,039 --> 00:22:19,049
the first challenge is that in machine

536
00:22:19,049 --> 00:22:19,650
hiding and

537
00:22:19,650 --> 00:22:22,830
the machine and the and input X are

538
00:22:22,830 --> 00:22:25,020
encoded together whereas in an attribute

539
00:22:25,020 --> 00:22:27,450
based encryption scheme by definition we

540
00:22:27,450 --> 00:22:29,279
are we are required to encode them

541
00:22:29,279 --> 00:22:32,250
separately the second issue is that

542
00:22:32,250 --> 00:22:34,799
again in a machine hiding encoding the

543
00:22:34,799 --> 00:22:36,600
encoding cannot be reused right it's a

544
00:22:36,600 --> 00:22:39,000
one-time system whereas in an attribute

545
00:22:39,000 --> 00:22:41,309
based encryption scheme it's a reusable

546
00:22:41,309 --> 00:22:44,010
system right so they attribute keys for

547
00:22:44,010 --> 00:22:47,640
a machine can be reused so handling the

548
00:22:47,640 --> 00:22:49,740
first issue of decomposability actually

549
00:22:49,740 --> 00:22:51,809
turns out to be easy there is already a

550
00:22:51,809 --> 00:22:54,149
natural separation in the construction

551
00:22:54,149 --> 00:22:57,809
of of Kapalua at all in that the input X

552
00:22:57,809 --> 00:22:59,909
is encoded separately and the Machine M

553
00:22:59,909 --> 00:23:02,370
is encoded separately the only weird

554
00:23:02,370 --> 00:23:04,980
thing is that the message is actually

555
00:23:04,980 --> 00:23:07,230
encoded with the machine whereas what we

556
00:23:07,230 --> 00:23:08,940
would want is to encode the message

557
00:23:08,940 --> 00:23:12,240
together with the input X right so this

558
00:23:12,240 --> 00:23:14,250
is kind of easy to do let's just flip

559
00:23:14,250 --> 00:23:15,929
the roles of the machine and the input

560
00:23:15,929 --> 00:23:17,940
right by using a universal Turing

561
00:23:17,940 --> 00:23:21,240
machine and now this the work tape will

562
00:23:21,240 --> 00:23:22,950
be initialized with the Turing machine M

563
00:23:22,950 --> 00:23:25,200
and it will correspond to our ami key

564
00:23:25,200 --> 00:23:29,279
and the obfuscated program which has the

565
00:23:29,279 --> 00:23:31,169
input and the message will correspond to

566
00:23:31,169 --> 00:23:32,460
the a B ciphertext

567
00:23:32,460 --> 00:23:35,429
okay so decomposability was easy to deal

568
00:23:35,429 --> 00:23:37,770
with the main challenge actually turns

569
00:23:37,770 --> 00:23:40,169
out to be achieving reusability and I

570
00:23:40,169 --> 00:23:42,390
won't have time to explain too much but

571
00:23:42,390 --> 00:23:44,880
really the main point is that in the

572
00:23:44,880 --> 00:23:47,909
proof of of their construction the point

573
00:23:47,909 --> 00:23:50,580
is that at some point you have to do you

574
00:23:50,580 --> 00:23:52,529
know puncturing right which is kind of

575
00:23:52,529 --> 00:23:54,690
the common step in all I approves and

576
00:23:54,690 --> 00:23:56,549
the way puncturing is done in there

577
00:23:56,549 --> 00:23:58,620
proof is that the verification key for

578
00:23:58,620 --> 00:24:00,419
the signature scheme is punctured in

579
00:24:00,419 --> 00:24:02,490
such a manner that it only authenticates

580
00:24:02,490 --> 00:24:05,610
the IH step of the computation of M of X

581
00:24:05,610 --> 00:24:08,250
and nothing else okay and this is okay

582
00:24:08,250 --> 00:24:10,320
if you were computing just on one input

583
00:24:10,320 --> 00:24:13,320
right however in our case we want to

584
00:24:13,320 --> 00:24:15,600
compute on multiple inputs right so once

585
00:24:15,600 --> 00:24:17,220
you have punctured the verification key

586
00:24:17,220 --> 00:24:19,590
with respect to a single computation it

587
00:24:19,590 --> 00:24:21,299
becomes incompatible with other

588
00:24:21,299 --> 00:24:23,010
computations and therefore it doesn't

589
00:24:23,010 --> 00:24:27,539
quite work anymore and to resolve this

590
00:24:27,539 --> 00:24:29,760
problem we introduce an idea called

591
00:24:29,760 --> 00:24:32,740
sensing signature synchronization

592
00:24:32,740 --> 00:24:34,809
and this is just a quick pictorial

593
00:24:34,809 --> 00:24:36,850
representation of it where basically

594
00:24:36,850 --> 00:24:39,400
what we do is that in each a B

595
00:24:39,400 --> 00:24:41,440
ciphertext we actually use fresh

596
00:24:41,440 --> 00:24:44,710
signature keys so in every cipher text

597
00:24:44,710 --> 00:24:46,690
we use a fresh key pair for this

598
00:24:46,690 --> 00:24:49,750
printable signature scheme whereas the a

599
00:24:49,750 --> 00:24:52,690
B key actually uses some fixed master

600
00:24:52,690 --> 00:24:55,450
signing key to sign the root and now in

601
00:24:55,450 --> 00:24:58,150
order to ensure correctness we have we

602
00:24:58,150 --> 00:25:00,370
in each of the ebee cipher texts we also

603
00:25:00,370 --> 00:25:01,780
provide something that we call the

604
00:25:01,780 --> 00:25:04,000
translator which basically transforms

605
00:25:04,000 --> 00:25:06,429
signatures with respect to the master

606
00:25:06,429 --> 00:25:08,710
signing key into signatures with respect

607
00:25:08,710 --> 00:25:10,750
to the key pair that's embedded inside

608
00:25:10,750 --> 00:25:14,290
the a B ciphertext and I won't mention

609
00:25:14,290 --> 00:25:16,600
how it is actually implemented but this

610
00:25:16,600 --> 00:25:18,700
is really the the main the heart of the

611
00:25:18,700 --> 00:25:22,870
construction and finally how how do we

612
00:25:22,870 --> 00:25:25,030
achieve constant overhead that actually

613
00:25:25,030 --> 00:25:26,890
turns out to be easy once we have done

614
00:25:26,890 --> 00:25:29,230
all this basically the main issue here

615
00:25:29,230 --> 00:25:33,460
is the a B key right and the a B key

616
00:25:33,460 --> 00:25:35,530
consists of this work tape and the

617
00:25:35,530 --> 00:25:37,900
storage tree right and of course this as

618
00:25:37,900 --> 00:25:39,490
such might not have constant overhead

619
00:25:39,490 --> 00:25:42,640
and to to address this point we just

620
00:25:42,640 --> 00:25:44,710
observed that the evaluator actually

621
00:25:44,710 --> 00:25:46,870
does not you know need to store the

622
00:25:46,870 --> 00:25:49,720
storage tree he can just compute the

623
00:25:49,720 --> 00:25:51,610
storage free on its own right and

624
00:25:51,610 --> 00:25:54,100
therefore we can just delete the entire

625
00:25:54,100 --> 00:25:57,040
storage tree right we just have the the

626
00:25:57,040 --> 00:25:59,380
description of the Machine M and the

627
00:25:59,380 --> 00:26:02,140
signature on it right and this is our

628
00:26:02,140 --> 00:26:05,200
new a B key and this can have constant

629
00:26:05,200 --> 00:26:09,920
overhead and that's actually

630
00:26:09,920 --> 00:26:14,969
[Applause]

