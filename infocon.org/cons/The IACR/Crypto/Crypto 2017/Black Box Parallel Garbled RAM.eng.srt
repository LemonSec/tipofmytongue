1
00:00:05,800 --> 00:00:07,840
so I'll be talking about how to garble

2
00:00:07,840 --> 00:00:10,510
RAM programs in the parallel RAM model

3
00:00:10,510 --> 00:00:12,970
and this is done in a fully black box

4
00:00:12,970 --> 00:00:15,280
way depending only on roaming functions

5
00:00:15,280 --> 00:00:17,529
so this is a great work with Rafi

6
00:00:17,529 --> 00:00:21,010
Ostrovsky I'm Steve and what I'll be

7
00:00:21,010 --> 00:00:22,900
doing is I'll just be you know first

8
00:00:22,900 --> 00:00:25,630
motivating the problem and then give you

9
00:00:25,630 --> 00:00:28,539
some reviews and definitions and what we

10
00:00:28,539 --> 00:00:30,640
achieve I'll go into the main

11
00:00:30,640 --> 00:00:34,150
construction then give you a flavor of

12
00:00:34,150 --> 00:00:37,690
the proof and finally conclude so just

13
00:00:37,690 --> 00:00:39,430
to motivate and I think we've seen some

14
00:00:39,430 --> 00:00:41,290
of this already in the previous two

15
00:00:41,290 --> 00:00:44,200
talks well what about you know computing

16
00:00:44,200 --> 00:00:47,079
on encrypted data right if Alice here is

17
00:00:47,079 --> 00:00:48,969
a client and she wants to compute some

18
00:00:48,969 --> 00:00:50,860
some data assume store some data on some

19
00:00:50,860 --> 00:00:55,629
server that Bob holds you know she wants

20
00:00:55,629 --> 00:00:57,250
the server to compute some function f of

21
00:00:57,250 --> 00:01:00,309
X but she doesn't want necessarily the

22
00:01:00,309 --> 00:01:03,250
server to learn what her input what her

23
00:01:03,250 --> 00:01:05,229
input is what her function is what her

24
00:01:05,229 --> 00:01:09,310
data is and this is done on you know

25
00:01:09,310 --> 00:01:10,800
perhaps a really big big server right so

26
00:01:10,800 --> 00:01:13,060
this server can have lots of cores can

27
00:01:13,060 --> 00:01:14,220
execute lots of things in parallel

28
00:01:14,220 --> 00:01:16,869
multi-threaded programs this is looking

29
00:01:16,869 --> 00:01:19,810
at things in the parallel Ram model okay

30
00:01:19,810 --> 00:01:25,539
so what can we do right and so sort of

31
00:01:25,539 --> 00:01:27,009
the the overall motivation is to do

32
00:01:27,009 --> 00:01:30,099
secure Ram computation namely that you

33
00:01:30,099 --> 00:01:31,990
know the secure application allows you

34
00:01:31,990 --> 00:01:33,729
to have persistent memory you can store

35
00:01:33,729 --> 00:01:35,890
things you can retrieve things it stays

36
00:01:35,890 --> 00:01:38,410
there there's a potentially exponential

37
00:01:38,410 --> 00:01:39,880
gap for example you're gonna do binary

38
00:01:39,880 --> 00:01:42,640
search it's a lot quicker then if you

39
00:01:42,640 --> 00:01:45,429
wanted to do using just a big circuit on

40
00:01:45,429 --> 00:01:48,369
everything it could be input dependent

41
00:01:48,369 --> 00:01:50,380
but anytime and furthermore it's also a

42
00:01:50,380 --> 00:01:56,050
natural model for programs okay so the

43
00:01:56,050 --> 00:01:57,399
first sort of generic compiler was

44
00:01:57,399 --> 00:01:59,229
suggested by Ostrovsky and xu and there

45
00:01:59,229 --> 00:02:01,869
was a long line of work on secure around

46
00:02:01,869 --> 00:02:04,030
computation interactive secure

47
00:02:04,030 --> 00:02:06,160
computation was for example a first

48
00:02:06,160 --> 00:02:09,500
implement in this work by Gordon at all

49
00:02:09,500 --> 00:02:12,080
and you know there's been a long line of

50
00:02:12,080 --> 00:02:14,420
workers of securom competition in the

51
00:02:14,420 --> 00:02:16,430
interactive model right but what about

52
00:02:16,430 --> 00:02:19,310
the non interactive model well so in

53
00:02:19,310 --> 00:02:20,420
this work we're going to look at look at

54
00:02:20,420 --> 00:02:22,310
this in the non interactive model and

55
00:02:22,310 --> 00:02:24,800
also make it parallelizable and makes

56
00:02:24,800 --> 00:02:27,500
only use of black box use of some

57
00:02:27,500 --> 00:02:29,560
underlying one-way functions in PRF and

58
00:02:29,560 --> 00:02:32,450
well the reason why you know black box

59
00:02:32,450 --> 00:02:34,160
is traffic is attractive I mean in

60
00:02:34,160 --> 00:02:34,640
addition to

61
00:02:34,640 --> 00:02:37,010
you know black box is the new black is

62
00:02:37,010 --> 00:02:39,440
that if you wanted to implement this

63
00:02:39,440 --> 00:02:42,560
using you know let's say yes you can

64
00:02:42,560 --> 00:02:45,200
leverage hardware IES or you know other

65
00:02:45,200 --> 00:02:48,440
hardware techniques that that makes only

66
00:02:48,440 --> 00:02:49,910
a black box you you don't need to

67
00:02:49,910 --> 00:02:52,820
actually have the underlying code okay

68
00:02:52,820 --> 00:02:55,580
so that's the that's the sort of overall

69
00:02:55,580 --> 00:02:59,180
subject my talk and it's gonna be

70
00:02:59,180 --> 00:03:01,459
there's the ramp program it's black box

71
00:03:01,459 --> 00:03:03,920
it's parallel and we're going to garble

72
00:03:03,920 --> 00:03:08,090
it ok so just give you a couple of quick

73
00:03:08,090 --> 00:03:09,890
reviews and you've seen this in the

74
00:03:09,890 --> 00:03:11,390
previous two talks so I'll just go over

75
00:03:11,390 --> 00:03:15,200
this real quick garbled circuits is a

76
00:03:15,200 --> 00:03:17,870
method of taking a circuit garbling it

77
00:03:17,870 --> 00:03:20,390
into some goblet format C prime you can

78
00:03:20,390 --> 00:03:21,799
take an input you can garble that into

79
00:03:21,799 --> 00:03:24,410
some garbled input X Prime and then you

80
00:03:24,410 --> 00:03:26,239
can have this evaluation algorithm right

81
00:03:26,239 --> 00:03:27,500
and the evaluation algorithm the

82
00:03:27,500 --> 00:03:29,480
correctness property says that if you

83
00:03:29,480 --> 00:03:30,739
evaluate the grubels circuit on the

84
00:03:30,739 --> 00:03:32,480
garbled input you should get the the

85
00:03:32,480 --> 00:03:34,549
same as you as you would get on the the

86
00:03:34,549 --> 00:03:36,620
clear circuit and privacy states that

87
00:03:36,620 --> 00:03:38,930
you should learn nothing else beyond

88
00:03:38,930 --> 00:03:42,709
this okay what about oblivious RAM right

89
00:03:42,709 --> 00:03:44,480
I mean this is the OT and a Ram session

90
00:03:44,480 --> 00:03:45,680
so I shouldn't talk to you a little bit

91
00:03:45,680 --> 00:03:47,299
about oblivious Ram and why it's

92
00:03:47,299 --> 00:03:48,769
important in this context right

93
00:03:48,769 --> 00:03:51,950
oblivious Ram helps you hide the access

94
00:03:51,950 --> 00:03:53,900
pattern of the program and so if you

95
00:03:53,900 --> 00:03:55,850
actually wanted to make sure that the

96
00:03:55,850 --> 00:03:56,959
server doesn't actually learn anything

97
00:03:56,959 --> 00:03:59,060
about your computation right you want to

98
00:03:59,060 --> 00:04:00,620
hide the fact that for example your

99
00:04:00,620 --> 00:04:02,630
program is program is perhaps taking

100
00:04:02,630 --> 00:04:04,730
this secret if branch as opposed to this

101
00:04:04,730 --> 00:04:06,440
else branch right because it this might

102
00:04:06,440 --> 00:04:09,019
be dependent on some secret data weight

103
00:04:09,019 --> 00:04:11,299
so oblivious Ram was introduced by goal

104
00:04:11,299 --> 00:04:13,820
RIKEN Ostrovsky and there has been you

105
00:04:13,820 --> 00:04:15,110
know many many subsequent works in

106
00:04:15,110 --> 00:04:17,720
various different models and basically

107
00:04:17,720 --> 00:04:19,459
what it would it offers you is given a

108
00:04:19,459 --> 00:04:22,130
ram program P you can compile it into a

109
00:04:22,130 --> 00:04:22,620
function

110
00:04:22,620 --> 00:04:24,690
equivalent program P Prime that has

111
00:04:24,690 --> 00:04:28,919
oblivious access pattern and and because

112
00:04:28,919 --> 00:04:30,930
we're looking at parallel of garbled Ram

113
00:04:30,930 --> 00:04:33,360
what about parallel oblivious Ram so in

114
00:04:33,360 --> 00:04:35,669
the parallel RAM model there's been a

115
00:04:35,669 --> 00:04:38,880
couple of works so a TCC last year boil

116
00:04:38,880 --> 00:04:40,560
chung and pass and Chen Lin and to

117
00:04:40,560 --> 00:04:42,690
sorrow talked about you know introducing

118
00:04:42,690 --> 00:04:46,680
parallel oblivious Ram and then a later

119
00:04:46,680 --> 00:04:49,440
last year an Asia crypt documents led at

120
00:04:49,440 --> 00:04:50,370
all

121
00:04:50,370 --> 00:04:53,820
further introduced you know looking at

122
00:04:53,820 --> 00:04:56,000
parallel Ram the network Ram model and

123
00:04:56,000 --> 00:04:59,160
some Alan work by Karthik and

124
00:04:59,160 --> 00:05:02,250
John also sort of looks at improving the

125
00:05:02,250 --> 00:05:04,919
efficiency of parallel oblivious Ram so

126
00:05:04,919 --> 00:05:06,449
you know given that there is such nice

127
00:05:06,449 --> 00:05:08,520
research on parallel oblivious Ram let's

128
00:05:08,520 --> 00:05:11,669
see how to do it not interactively wait

129
00:05:11,669 --> 00:05:14,190
so in the gobble Ram world right so just

130
00:05:14,190 --> 00:05:15,870
the the plain RAM model not necessarily

131
00:05:15,870 --> 00:05:18,330
parallel this was introduced in a work

132
00:05:18,330 --> 00:05:23,130
with Rafi at your crib 2013 there's been

133
00:05:23,130 --> 00:05:24,690
a lot of subsequent works on this area

134
00:05:24,690 --> 00:05:27,900
both in the realm where you're only

135
00:05:27,900 --> 00:05:29,820
assuming minimal assumptions you know

136
00:05:29,820 --> 00:05:32,599
from one-way functions or prfs and also

137
00:05:32,599 --> 00:05:35,450
interesting you know relations to

138
00:05:35,450 --> 00:05:42,360
compactness reusability and i/o and last

139
00:05:42,360 --> 00:05:45,840
year at TCC boiled xiang'er pass also

140
00:05:45,840 --> 00:05:47,820
introduced the notion of parallel gobble

141
00:05:47,820 --> 00:05:48,780
Ram

142
00:05:48,780 --> 00:05:51,150
and they managed to achieve this using

143
00:05:51,150 --> 00:05:54,120
ìbe and and this was done where you

144
00:05:54,120 --> 00:05:55,919
actually have to have the code by be

145
00:05:55,919 --> 00:05:59,130
running inside your circuits so what

146
00:05:59,130 --> 00:06:00,090
we're gonna try to do in this talk is

147
00:06:00,090 --> 00:06:01,830
we're gonna show how to get parallel

148
00:06:01,830 --> 00:06:04,349
bubble Ram using only you know black box

149
00:06:04,349 --> 00:06:09,389
use of any PRF okay so you know what

150
00:06:09,389 --> 00:06:11,460
does parallel bubble Ram what can you do

151
00:06:11,460 --> 00:06:13,919
with it well this is what it looks like

152
00:06:13,919 --> 00:06:15,870
looks very similar to grapple circuits

153
00:06:15,870 --> 00:06:17,820
except now you have some some parallel

154
00:06:17,820 --> 00:06:23,250
Ram program P you have some input I you

155
00:06:23,250 --> 00:06:25,139
have some data that you want to also

156
00:06:25,139 --> 00:06:27,570
grow up with D and they're they're out

157
00:06:27,570 --> 00:06:29,430
there are algorithms that can help you

158
00:06:29,430 --> 00:06:31,800
gobble all these and again you want this

159
00:06:31,800 --> 00:06:33,830
correctness property where you know the

160
00:06:33,830 --> 00:06:35,990
the garbled evaluation map

161
00:06:35,990 --> 00:06:38,330
the plane evaluation and you also want

162
00:06:38,330 --> 00:06:39,800
to have this security property which

163
00:06:39,800 --> 00:06:40,910
which says that you can actually

164
00:06:40,910 --> 00:06:43,300
simulate okay and I'm gonna actually

165
00:06:43,300 --> 00:06:45,889
give you the weaker definition as well

166
00:06:45,889 --> 00:06:48,020
which is that the simulator not only

167
00:06:48,020 --> 00:06:50,539
does it know the the you know security

168
00:06:50,539 --> 00:06:52,039
parameter the size of the database and

169
00:06:52,039 --> 00:06:54,229
the running times of the programs but it

170
00:06:54,229 --> 00:06:55,759
also has the I mean it and of course the

171
00:06:55,759 --> 00:06:57,080
outputs of the programs but it also has

172
00:06:57,080 --> 00:06:58,819
the memory axis right so for full

173
00:06:58,819 --> 00:07:00,020
security you don't want to give it a

174
00:07:00,020 --> 00:07:02,180
memory axis but you know just to make

175
00:07:02,180 --> 00:07:04,789
things similar for this talk let's let's

176
00:07:04,789 --> 00:07:06,560
pretend that you know this team there

177
00:07:06,560 --> 00:07:07,970
you can actually have access to memory

178
00:07:07,970 --> 00:07:10,370
axis and then in the full you know in

179
00:07:10,370 --> 00:07:12,530
the faux construction we actually deny

180
00:07:12,530 --> 00:07:14,720
this from the simulator but the

181
00:07:14,720 --> 00:07:17,389
simulator should in terms of security be

182
00:07:17,389 --> 00:07:20,479
able to generate a simulated garbled

183
00:07:20,479 --> 00:07:23,330
database programs coupled inputs that's

184
00:07:23,330 --> 00:07:25,070
interesting indistinguishable from the

185
00:07:25,070 --> 00:07:30,740
the be real one okay so now that I've

186
00:07:30,740 --> 00:07:32,840
given you the definition let me go ahead

187
00:07:32,840 --> 00:07:34,520
and state our main theorem which is that

188
00:07:34,520 --> 00:07:36,650
you know assuming the existence of a

189
00:07:36,650 --> 00:07:38,509
function there is just a fully black box

190
00:07:38,509 --> 00:07:40,039
so it's black box both in the

191
00:07:40,039 --> 00:07:41,650
construction and in the proof

192
00:07:41,650 --> 00:07:44,990
construction of a processor garbled P

193
00:07:44,990 --> 00:07:48,380
Ram scheme for arbitrary and processor P

194
00:07:48,380 --> 00:07:49,880
REM program so if you have a parallel

195
00:07:49,880 --> 00:07:51,139
program that uses like you know M

196
00:07:51,139 --> 00:07:52,759
processors you can have a garbled

197
00:07:52,759 --> 00:07:53,840
version of it that also uses M

198
00:07:53,840 --> 00:07:57,430
processors and with Polliwog overhead in

199
00:07:57,430 --> 00:08:00,199
the sides of the database as the input

200
00:08:00,199 --> 00:08:02,180
running time the number of processors

201
00:08:02,180 --> 00:08:05,449
and we get this sort of multiplicative

202
00:08:05,449 --> 00:08:07,280
overhead in the sides of the database

203
00:08:07,280 --> 00:08:10,580
you also increase the size of the input

204
00:08:10,580 --> 00:08:12,650
and the running time well and

205
00:08:12,650 --> 00:08:14,630
unfortunately it's not exactly compact

206
00:08:14,630 --> 00:08:17,479
in the garbled program size the gobble

207
00:08:17,479 --> 00:08:18,349
program x is actually gonna be

208
00:08:18,349 --> 00:08:19,849
proportional to the running time I mean

209
00:08:19,849 --> 00:08:21,620
we would love to have a solution which

210
00:08:21,620 --> 00:08:24,110
is actually proportional to the size of

211
00:08:24,110 --> 00:08:25,460
the you know to the size of the program

212
00:08:25,460 --> 00:08:26,599
as opposed to the running time of the

213
00:08:26,599 --> 00:08:28,849
program but but this is what we get in

214
00:08:28,849 --> 00:08:32,839
our construction a little I'll talk

215
00:08:32,839 --> 00:08:33,919
about the open problem of you know how

216
00:08:33,919 --> 00:08:35,510
do we actually get this

217
00:08:35,510 --> 00:08:39,020
you know so quickly okay so now let me

218
00:08:39,020 --> 00:08:41,390
go ahead and jump into the the main

219
00:08:41,390 --> 00:08:43,940
construction okay so the main contractor

220
00:08:43,940 --> 00:08:45,650
overview is let's start with an

221
00:08:45,650 --> 00:08:47,090
arbitrary PRN program and let's show how

222
00:08:47,090 --> 00:08:50,120
to garble it right what I'm gonna do is

223
00:08:50,120 --> 00:08:51,880
I'm gonna actually apply some sort of

224
00:08:51,880 --> 00:08:54,800
oblivious parallel Ram compiler to it

225
00:08:54,800 --> 00:08:55,310
first

226
00:08:55,310 --> 00:08:57,440
that provides uniform access pattern and

227
00:08:57,440 --> 00:08:59,210
I put a uniform star there because we

228
00:08:59,210 --> 00:09:00,890
don't actually need it to be actually

229
00:09:00,890 --> 00:09:02,270
actually uniform but as long as you know

230
00:09:02,270 --> 00:09:05,230
the the the the access pattern can be

231
00:09:05,230 --> 00:09:07,310
bounded using turn off bounds it's it's

232
00:09:07,310 --> 00:09:09,830
all okay so you know you do this

233
00:09:09,830 --> 00:09:11,530
compiler and you get a uniform access

234
00:09:11,530 --> 00:09:15,230
Budhia Spearin program and then what do

235
00:09:15,230 --> 00:09:15,770
you do next

236
00:09:15,770 --> 00:09:19,700
well then we do this garbled street a

237
00:09:19,700 --> 00:09:21,050
garbled tree strategy and I'll talk to

238
00:09:21,050 --> 00:09:22,820
you about you know what this is in just

239
00:09:22,820 --> 00:09:25,700
a bit and using the Scrabble tree

240
00:09:25,700 --> 00:09:27,890
strategy we can get a parallel garbled

241
00:09:27,890 --> 00:09:31,970
Ram right so this is where a lot of the

242
00:09:31,970 --> 00:09:33,560
magic is hiding and so that's where we

243
00:09:33,560 --> 00:09:37,190
focus on for the rest of the talk okay

244
00:09:37,190 --> 00:09:40,160
so as a starting point let's actually

245
00:09:40,160 --> 00:09:41,720
start with this sort of garbled tree

246
00:09:41,720 --> 00:09:45,620
idea and this was used in a couple of

247
00:09:45,620 --> 00:09:47,090
previous papers and actually this has

248
00:09:47,090 --> 00:09:50,120
been quite useful so both in the

249
00:09:50,120 --> 00:09:53,180
previous talk and also in Nico's talk

250
00:09:53,180 --> 00:09:55,250
yesterday you saw you know the

251
00:09:55,250 --> 00:09:57,380
usefulness of having a like a tree of

252
00:09:57,380 --> 00:09:58,700
garbled circuits and then you evaluate

253
00:09:58,700 --> 00:10:01,610
down one of these paths right and it

254
00:10:01,610 --> 00:10:03,080
also has a lot of you know interesting

255
00:10:03,080 --> 00:10:04,970
and expected connections let's say for

256
00:10:04,970 --> 00:10:08,990
example to IDE okay so let's review what

257
00:10:08,990 --> 00:10:11,420
this double tree construction really

258
00:10:11,420 --> 00:10:12,590
looks like and I'll give you the flavor

259
00:10:12,590 --> 00:10:15,170
of it that was introduced in this gll

260
00:10:15,170 --> 00:10:17,000
work okay

261
00:10:17,000 --> 00:10:21,650
so in in this work you had basically in

262
00:10:21,650 --> 00:10:23,180
order to do garbled Ram I just inaudible

263
00:10:23,180 --> 00:10:24,740
parallel Ram this is just cobbled RAM

264
00:10:24,740 --> 00:10:27,200
you have a bunch of you know garbled CPU

265
00:10:27,200 --> 00:10:29,900
steps and you also have garbled memory

266
00:10:29,900 --> 00:10:31,940
but it's organized in this tree fashion

267
00:10:31,940 --> 00:10:33,470
right it's organized in the street

268
00:10:33,470 --> 00:10:35,750
fashion where each node contains a whole

269
00:10:35,750 --> 00:10:39,020
bunch of garbled circuits and these

270
00:10:39,020 --> 00:10:40,310
garbled circuits can talk to each other

271
00:10:40,310 --> 00:10:44,720
alright so basically each circuit in a

272
00:10:44,720 --> 00:10:47,020
node can speak the language of

273
00:10:47,020 --> 00:10:48,970
other you know circuits in this node as

274
00:10:48,970 --> 00:10:51,610
well as a couple of the child circuits

275
00:10:51,610 --> 00:10:54,400
right so if you were did use just you

276
00:10:54,400 --> 00:10:55,840
know one time right if you only wanted

277
00:10:55,840 --> 00:10:58,360
to garble one cpu step right you would

278
00:10:58,360 --> 00:10:59,560
just have a tree and there will be one

279
00:10:59,560 --> 00:11:02,260
circuit for each node and you just go

280
00:11:02,260 --> 00:11:03,850
down one path and then that'll be the

281
00:11:03,850 --> 00:11:05,380
end of it right but if you have multiple

282
00:11:05,380 --> 00:11:08,380
CPU steps you need a you need some way

283
00:11:08,380 --> 00:11:09,610
to link them link these different

284
00:11:09,610 --> 00:11:12,010
multiple CPU steps together and be you

285
00:11:12,010 --> 00:11:13,480
want to make sure that well because you

286
00:11:13,480 --> 00:11:15,010
don't know you don't know a priori which

287
00:11:15,010 --> 00:11:16,960
which path you're going to take you have

288
00:11:16,960 --> 00:11:18,550
to you know stuff enough of these

289
00:11:18,550 --> 00:11:20,800
circuits into each node so that you

290
00:11:20,800 --> 00:11:22,630
don't ever run out right so this is call

291
00:11:22,630 --> 00:11:24,000
like this sort of the overflow problem

292
00:11:24,000 --> 00:11:26,800
right and so basically if you want to

293
00:11:26,800 --> 00:11:28,990
look at the combinatoric sub this you

294
00:11:28,990 --> 00:11:31,030
want to basically connect the I parent

295
00:11:31,030 --> 00:11:33,430
to you know more or less be able to

296
00:11:33,430 --> 00:11:36,250
speak to about I you know half of I

297
00:11:36,250 --> 00:11:39,940
right because if if if you've already

298
00:11:39,940 --> 00:11:42,400
consumed you know i circuits here you

299
00:11:42,400 --> 00:11:43,930
expect half the time you go left and

300
00:11:43,930 --> 00:11:45,250
half the time you go right right because

301
00:11:45,250 --> 00:11:46,540
if you're if you have uniform access

302
00:11:46,540 --> 00:11:47,710
pattern you know half the time you're

303
00:11:47,710 --> 00:11:50,050
left half the time you go right so you

304
00:11:50,050 --> 00:11:52,480
expect to need to speak to about you

305
00:11:52,480 --> 00:11:56,250
know you're roughly I over to the child

306
00:11:56,250 --> 00:12:00,130
but because you know when you throw you

307
00:12:00,130 --> 00:12:01,570
know balls into bins it doesn't always

308
00:12:01,570 --> 00:12:03,640
land you know exactly like this way you

309
00:12:03,640 --> 00:12:05,290
need to have you know a little buffer of

310
00:12:05,290 --> 00:12:06,940
Delta to make sure that you don't run

311
00:12:06,940 --> 00:12:10,090
out okay so that's sort of the you know

312
00:12:10,090 --> 00:12:11,350
the overall sort of you know

313
00:12:11,350 --> 00:12:13,450
combinatorial construction of this

314
00:12:13,450 --> 00:12:15,730
couple tree and lets you sort of see how

315
00:12:15,730 --> 00:12:17,560
we actually go down a path right and so

316
00:12:17,560 --> 00:12:18,730
the circuit logic is actually really

317
00:12:18,730 --> 00:12:22,499
really simple you know if I have some

318
00:12:22,499 --> 00:12:24,479
sum-sum location that i want want to

319
00:12:24,479 --> 00:12:27,629
read like from here well what I do is I

320
00:12:27,629 --> 00:12:30,359
I say alright well this says re I want

321
00:12:30,359 --> 00:12:32,129
to read this location right so it just

322
00:12:32,129 --> 00:12:36,659
has the key for this route and then the

323
00:12:36,659 --> 00:12:39,149
memory location is you know it's encoded

324
00:12:39,149 --> 00:12:41,129
inside as part of the input to the

325
00:12:41,129 --> 00:12:42,689
garbled circuit and all this carbon

326
00:12:42,689 --> 00:12:44,309
sugar does is just says alright well do

327
00:12:44,309 --> 00:12:45,329
I need to go left or do I need to go

328
00:12:45,329 --> 00:12:47,099
right so I just look at the if--but of

329
00:12:47,099 --> 00:12:49,199
the input right so the the the route

330
00:12:49,199 --> 00:12:50,339
looks up the first bit of the input

331
00:12:50,339 --> 00:12:52,259
right and if it's a zero it got left and

332
00:12:52,259 --> 00:12:55,589
it's one icon right and and so on and so

333
00:12:55,589 --> 00:12:57,779
forth so the logic of these circuits are

334
00:12:57,779 --> 00:12:59,879
actually quite simple you just you know

335
00:12:59,879 --> 00:13:01,579
figure out do I need to go left or right

336
00:13:01,579 --> 00:13:03,749
pack up the keys I need to pack up and

337
00:13:03,749 --> 00:13:06,899
pass down to the next circuit okay so

338
00:13:06,899 --> 00:13:09,719
that was the you know that's an overview

339
00:13:09,719 --> 00:13:12,239
of the the gobble Ram scheme of G

340
00:13:12,239 --> 00:13:15,959
although what about you know paralyzing

341
00:13:15,959 --> 00:13:20,819
this right one thing we can do right is

342
00:13:20,819 --> 00:13:23,159
just let's just make all the circuits

343
00:13:23,159 --> 00:13:24,779
like you know wider right if we instead

344
00:13:24,779 --> 00:13:26,369
of reading what a memory location we

345
00:13:26,369 --> 00:13:28,169
want to read em memory location within

346
00:13:28,169 --> 00:13:30,539
once within one step let's make

347
00:13:30,539 --> 00:13:31,619
everything just wider right so here's

348
00:13:31,619 --> 00:13:33,869
here's M CPU circuits I mean they want

349
00:13:33,869 --> 00:13:35,789
to read em locations within one one

350
00:13:35,789 --> 00:13:38,999
single step so you're just widen the

351
00:13:38,999 --> 00:13:40,499
circuits and you know carefully I used

352
00:13:40,499 --> 00:13:42,839
turn-off found to size it off and that

353
00:13:42,839 --> 00:13:44,939
that idea more or less works and I'm

354
00:13:44,939 --> 00:13:46,619
going to sort of detail of like you know

355
00:13:46,619 --> 00:13:47,999
where the subtlety comes in and why

356
00:13:47,999 --> 00:13:52,019
doesn't this exactly work okay so you

357
00:13:52,019 --> 00:13:53,699
know each each CPU has a uniformly

358
00:13:53,699 --> 00:13:56,609
around location then I read these

359
00:13:56,609 --> 00:13:59,519
locations myself collisions but you know

360
00:13:59,519 --> 00:14:01,109
existing works actually show how you can

361
00:14:01,109 --> 00:14:01,739
actually guarantee

362
00:14:01,739 --> 00:14:06,049
um um unique locations reading you know

363
00:14:06,049 --> 00:14:11,129
when you're doing this read okay so here

364
00:14:11,129 --> 00:14:13,139
are the details of doing this in

365
00:14:13,139 --> 00:14:16,220
parallel the route circuit will have

366
00:14:16,220 --> 00:14:19,289
sort of inputs for M keys right so M is

367
00:14:19,289 --> 00:14:21,659
the number of you know parallel CPUs you

368
00:14:21,659 --> 00:14:24,869
have and it's gonna route where it

369
00:14:24,869 --> 00:14:26,239
basically where each of these keys go

370
00:14:26,239 --> 00:14:28,439
right and you'd expect you don't have

371
00:14:28,439 --> 00:14:29,939
them to go left and you expect half of

372
00:14:29,939 --> 00:14:31,379
them to go right and that's great right

373
00:14:31,379 --> 00:14:33,300
I mean so well

374
00:14:33,300 --> 00:14:34,740
let's first use like the stupidest thing

375
00:14:34,740 --> 00:14:36,570
possible right which is just widen every

376
00:14:36,570 --> 00:14:39,360
single circuit by a factor of M right

377
00:14:39,360 --> 00:14:41,310
that certainly will will guarantee that

378
00:14:41,310 --> 00:14:43,080
you'll have enough you know circuit

379
00:14:43,080 --> 00:14:44,550
space to hold all the keys but you know

380
00:14:44,550 --> 00:14:45,810
I mean that's not great right because

381
00:14:45,810 --> 00:14:47,310
this will actually increase the overall

382
00:14:47,310 --> 00:14:49,950
memory size to M times n when we

383
00:14:49,950 --> 00:14:51,060
actually want to look a Polliwog

384
00:14:51,060 --> 00:14:52,680
dependency right so this is this is too

385
00:14:52,680 --> 00:14:56,519
much okay so how about we widen each

386
00:14:56,519 --> 00:14:58,529
circuit by the expected number of keys

387
00:14:58,529 --> 00:15:00,029
that will pass by right because you know

388
00:15:00,029 --> 00:15:02,459
if you're if you're doing this you know

389
00:15:02,459 --> 00:15:04,140
reading left or right you know half of

390
00:15:04,140 --> 00:15:05,640
the hospital bill left half a little go

391
00:15:05,640 --> 00:15:07,890
right and you know that that more or

392
00:15:07,890 --> 00:15:09,990
less works something like that more or

393
00:15:09,990 --> 00:15:12,720
less get you what you want except there

394
00:15:12,720 --> 00:15:14,760
is the subtle interference with the

395
00:15:14,760 --> 00:15:16,440
circuit consumption rate of the

396
00:15:16,440 --> 00:15:19,950
underlying dll scheme so the issue here

397
00:15:19,950 --> 00:15:26,010
is that when you know when the when the

398
00:15:26,010 --> 00:15:28,709
number of parallel processors is you

399
00:15:28,709 --> 00:15:32,300
know comparable to login to poly log n

400
00:15:32,300 --> 00:15:34,260
you're gonna be reading a lot you know

401
00:15:34,260 --> 00:15:35,790
you're gonna be consuming a lot of these

402
00:15:35,790 --> 00:15:38,640
lower circuits and in the original G

403
00:15:38,640 --> 00:15:40,290
yellow construction it wasn't exactly

404
00:15:40,290 --> 00:15:43,380
you know prepared to actually handle all

405
00:15:43,380 --> 00:15:46,500
of these you sort of you know parallel

406
00:15:46,500 --> 00:15:49,470
consumptions okay so we need to actually

407
00:15:49,470 --> 00:15:51,029
be a little bit careful here and

408
00:15:51,029 --> 00:15:52,890
actually use techniques from like you

409
00:15:52,890 --> 00:15:55,440
know occupancy and concentrating pounds

410
00:15:55,440 --> 00:15:57,329
cuz these constraint can bounds to

411
00:15:57,329 --> 00:15:59,940
actually designate a special level where

412
00:15:59,940 --> 00:16:02,339
we actually switched the strategy right

413
00:16:02,339 --> 00:16:04,589
so we can't use this exact strategy

414
00:16:04,589 --> 00:16:05,399
where we just all right you know you

415
00:16:05,399 --> 00:16:08,010
first circuit is of size M these are

416
00:16:08,010 --> 00:16:10,800
size you know mm / - these are mo 4 and

417
00:16:10,800 --> 00:16:13,170
so on like that straight up you just do

418
00:16:13,170 --> 00:16:14,790
it like that that doesn't exactly work

419
00:16:14,790 --> 00:16:17,010
out in terms of the analysis but if you

420
00:16:17,010 --> 00:16:18,800
actually introduced this special level

421
00:16:18,800 --> 00:16:22,140
then things will work out okay so let's

422
00:16:22,140 --> 00:16:23,660
see how we do this sort of carefully

423
00:16:23,660 --> 00:16:25,290
okay

424
00:16:25,290 --> 00:16:27,870
choosing a level so so how do so what

425
00:16:27,870 --> 00:16:29,699
kind of level do I want and basically I

426
00:16:29,699 --> 00:16:31,680
want a level such that within a single

427
00:16:31,680 --> 00:16:36,269
parallel step that when you're doing

428
00:16:36,269 --> 00:16:39,220
these accesses no more than B

429
00:16:39,220 --> 00:16:41,350
access paths will go through a single

430
00:16:41,350 --> 00:16:43,089
node at that level right so let's say

431
00:16:43,089 --> 00:16:45,850
it's this level right what's the

432
00:16:45,850 --> 00:16:49,000
probability that more than capital B of

433
00:16:49,000 --> 00:16:51,010
these access paths will go through

434
00:16:51,010 --> 00:16:53,709
exactly this node right that's some

435
00:16:53,709 --> 00:16:54,700
probability I can bound this probability

436
00:16:54,700 --> 00:16:56,529
and I want that probability to be

437
00:16:56,529 --> 00:16:59,800
negligible and you know obviously if I

438
00:16:59,800 --> 00:17:02,550
choose my level to be like you know

439
00:17:02,550 --> 00:17:04,959
double then of course right I mean it's

440
00:17:04,959 --> 00:17:06,549
gonna be zero because at the lowest

441
00:17:06,549 --> 00:17:07,809
level you know there's only gonna be one

442
00:17:07,809 --> 00:17:10,449
at most one right but I don't want to

443
00:17:10,449 --> 00:17:11,349
choose the lowest oh well I don't

444
00:17:11,349 --> 00:17:12,669
actually I don't want to choose a level

445
00:17:12,669 --> 00:17:14,589
that's that's still high enough that

446
00:17:14,589 --> 00:17:17,410
there are still less than M nodes where

447
00:17:17,410 --> 00:17:19,530
m is the number of parallel processors

448
00:17:19,530 --> 00:17:22,569
and by doing this sort of splitting you

449
00:17:22,569 --> 00:17:24,099
know the the higher levels and the lower

450
00:17:24,099 --> 00:17:26,049
levels this exactly handles this the

451
00:17:26,049 --> 00:17:28,119
subtle issue where M is small versus M

452
00:17:28,119 --> 00:17:31,950
is large compared to this login factor

453
00:17:31,950 --> 00:17:35,770
okay so now that we have this level what

454
00:17:35,770 --> 00:17:39,429
do we do right near the leaves I said

455
00:17:39,429 --> 00:17:41,020
what happens near the leaves well new

456
00:17:41,020 --> 00:17:43,660
leaves we're just going to basically

457
00:17:43,660 --> 00:17:47,520
instantiate one copy of gll per subtree

458
00:17:47,520 --> 00:17:54,400
and what about above the level B well

459
00:17:54,400 --> 00:17:55,660
above that level B we're going to do

460
00:17:55,660 --> 00:17:56,590
that strategy that we were talking about

461
00:17:56,590 --> 00:17:58,570
earlier right where the root has you

462
00:17:58,570 --> 00:18:01,780
know m you know you know sighs mmm keys

463
00:18:01,780 --> 00:18:03,549
and then the next little has M over two

464
00:18:03,549 --> 00:18:05,140
keys and so on and so forth right so

465
00:18:05,140 --> 00:18:07,750
basically you expect you know em over to

466
00:18:07,750 --> 00:18:10,179
the I keys to appear there and again we

467
00:18:10,179 --> 00:18:12,549
need this you know a similar sort of

468
00:18:12,549 --> 00:18:14,770
half plus epsilon factor and plus a

469
00:18:14,770 --> 00:18:16,630
small over overflow buffer queue

470
00:18:16,630 --> 00:18:18,490
basically you know you just added in

471
00:18:18,490 --> 00:18:20,200
these additional factors and and this

472
00:18:20,200 --> 00:18:22,030
can guarantee that the probability that

473
00:18:22,030 --> 00:18:24,730
you're gonna have too many CPUs trying

474
00:18:24,730 --> 00:18:26,380
to read down one path to be also

475
00:18:26,380 --> 00:18:28,870
negligible right so these are the

476
00:18:28,870 --> 00:18:29,950
techniques that were going to use to

477
00:18:29,950 --> 00:18:34,090
avoid this this overflow problem okay so

478
00:18:34,090 --> 00:18:37,030
putting it all together how do we you

479
00:18:37,030 --> 00:18:38,110
know perform wearing these parallel

480
00:18:38,110 --> 00:18:40,870
earrings near the top you activate all

481
00:18:40,870 --> 00:18:43,299
paths in parallel down to the calculated

482
00:18:43,299 --> 00:18:45,280
level right so you gonna you know you're

483
00:18:45,280 --> 00:18:46,720
gonna you know read the top and then

484
00:18:46,720 --> 00:18:47,520
you're gonna

485
00:18:47,520 --> 00:18:49,650
Gouri the to the children and the

486
00:18:49,650 --> 00:18:51,840
grandchildren and so on and so forth and

487
00:18:51,840 --> 00:18:54,330
this goes all the way until the you know

488
00:18:54,330 --> 00:18:56,580
this calculated level and then below

489
00:18:56,580 --> 00:18:59,540
this level you're gonna actually run

490
00:18:59,540 --> 00:19:03,570
sequentially in parallel right and by

491
00:19:03,570 --> 00:19:06,600
that I mean right so each sub crystal so

492
00:19:06,600 --> 00:19:07,560
let's say let's say for example I'm

493
00:19:07,560 --> 00:19:08,730
gonna read these four locations right

494
00:19:08,730 --> 00:19:11,100
these two are within this subtree these

495
00:19:11,100 --> 00:19:14,430
two are within this subtree and so I'm

496
00:19:14,430 --> 00:19:15,660
just gonna do these you know

497
00:19:15,660 --> 00:19:17,490
sequentially in the sense that within

498
00:19:17,490 --> 00:19:18,840
each subtree is sequential right so

499
00:19:18,840 --> 00:19:21,540
first I'm gonna read this one and first

500
00:19:21,540 --> 00:19:22,890
I'm gonna read this one but because

501
00:19:22,890 --> 00:19:25,350
there are less than M sub trees I can do

502
00:19:25,350 --> 00:19:28,800
each sub tree in parallel okay so this

503
00:19:28,800 --> 00:19:31,080
is my you know sort of first parallel

504
00:19:31,080 --> 00:19:33,060
sequential read and the second one is

505
00:19:33,060 --> 00:19:35,910
going to be this other one right so this

506
00:19:35,910 --> 00:19:37,920
other one is going to read these other

507
00:19:37,920 --> 00:19:39,750
two other two locations again it's in

508
00:19:39,750 --> 00:19:42,420
parallel with a across the sub trees but

509
00:19:42,420 --> 00:19:44,390
within each sub tree it's sequential

510
00:19:44,390 --> 00:19:47,790
okay so if you do that then we can

511
00:19:47,790 --> 00:19:51,030
actually get all the keys and still not

512
00:19:51,030 --> 00:19:53,970
run to the problem and everything's

513
00:19:53,970 --> 00:19:54,770
great

514
00:19:54,770 --> 00:19:58,470
okay so let's you know take a look at

515
00:19:58,470 --> 00:20:00,870
you know how this actually sort of works

516
00:20:00,870 --> 00:20:03,450
out and I'll give you a flavor of the

517
00:20:03,450 --> 00:20:06,720
proof sketch okay so building the

518
00:20:06,720 --> 00:20:10,350
simulator the simulator you know for the

519
00:20:10,350 --> 00:20:12,930
the full security gets only the output

520
00:20:12,930 --> 00:20:15,690
the running time of any arbitrary Ram

521
00:20:15,690 --> 00:20:17,730
program and the first thing we're going

522
00:20:17,730 --> 00:20:18,810
to do is we're going to just repeat it

523
00:20:18,810 --> 00:20:20,010
through the oblivious parallel Ram

524
00:20:20,010 --> 00:20:21,930
simulator right and that's going to give

525
00:20:21,930 --> 00:20:25,470
us a simulated memory access output on

526
00:20:25,470 --> 00:20:27,660
running time and now that we have a

527
00:20:27,660 --> 00:20:28,980
simulated member youngt so we can

528
00:20:28,980 --> 00:20:31,770
actually feed this into the the you know

529
00:20:31,770 --> 00:20:34,220
the unprotected memory access simulator

530
00:20:34,220 --> 00:20:36,090
and that's exactly what we're gonna do

531
00:20:36,090 --> 00:20:37,860
so we're gonna actually perform if you

532
00:20:37,860 --> 00:20:38,730
actually need to sort of go into the

533
00:20:38,730 --> 00:20:40,740
details and looking at the paper that

534
00:20:40,740 --> 00:20:41,850
we're gonna perform a sequence of

535
00:20:41,850 --> 00:20:44,400
hybrids similar to GL o where we replace

536
00:20:44,400 --> 00:20:46,260
the garble circuits on the tree with

537
00:20:46,260 --> 00:20:49,740
simulated ones okay so you usually walk

538
00:20:49,740 --> 00:20:51,600
through the sequence of hybrids and you

539
00:20:51,600 --> 00:20:53,550
get the simulated garble tree you get a

540
00:20:53,550 --> 00:20:55,560
simulated memory and now everything

541
00:20:55,560 --> 00:20:57,600
simulated and it's indistinguishable

542
00:20:57,600 --> 00:20:58,440
from

543
00:20:58,440 --> 00:21:02,220
real sort of garbled garbled program in

544
00:21:02,220 --> 00:21:04,169
database okay

545
00:21:04,169 --> 00:21:07,710
well the the key technical point here is

546
00:21:07,710 --> 00:21:10,139
what about the overflow problem right

547
00:21:10,139 --> 00:21:12,090
and this is sort of the the main

548
00:21:12,090 --> 00:21:13,559
combinatorial challenge that we had to

549
00:21:13,559 --> 00:21:17,250
deal with this in this paper and sort of

550
00:21:17,250 --> 00:21:19,289
how do we choose the Vani level B and

551
00:21:19,289 --> 00:21:21,210
how do we analyze you know what's the

552
00:21:21,210 --> 00:21:22,649
actual overhead right because we still

553
00:21:22,649 --> 00:21:24,240
want low overhead but at the same time

554
00:21:24,240 --> 00:21:25,620
we need to choose this level B and and

555
00:21:25,620 --> 00:21:28,139
you know spoiler alert we choose B to be

556
00:21:28,139 --> 00:21:30,360
roughly you know log the number of

557
00:21:30,360 --> 00:21:35,309
processors over C some constant okay so

558
00:21:35,309 --> 00:21:37,350
let me just give you a sketch of you

559
00:21:37,350 --> 00:21:39,120
know what the the combinatoric will look

560
00:21:39,120 --> 00:21:41,669
like so why is the overhead poly log

561
00:21:41,669 --> 00:21:44,009
right because we promised poly log

562
00:21:44,009 --> 00:21:47,340
overhead so let's see what it is on the

563
00:21:47,340 --> 00:21:48,419
top half right

564
00:21:48,419 --> 00:21:50,250
you activate all paths in parallel down

565
00:21:50,250 --> 00:21:53,519
to level B and if you let W I represent

566
00:21:53,519 --> 00:21:55,799
the circuit size you could this equation

567
00:21:55,799 --> 00:21:57,450
and you know this equation basically

568
00:21:57,450 --> 00:21:59,070
comes out of estimating you know what

569
00:21:59,070 --> 00:22:01,559
these w w i's are right the W is there

570
00:22:01,559 --> 00:22:04,950
basically you know M keys times this you

571
00:22:04,950 --> 00:22:09,299
know this factor followed by this you

572
00:22:09,299 --> 00:22:11,129
know additives key buffer factor right

573
00:22:11,129 --> 00:22:14,070
and if you found that you get this bound

574
00:22:14,070 --> 00:22:18,210
where this is you know e to the you know

575
00:22:18,210 --> 00:22:20,700
two times B times epsilon time is this

576
00:22:20,700 --> 00:22:22,980
factor and if you choose right if you

577
00:22:22,980 --> 00:22:24,360
choose B correctly any Beach is epsilon

578
00:22:24,360 --> 00:22:25,950
correctly you can actually take this and

579
00:22:25,950 --> 00:22:28,070
show that this is you know it that good

580
00:22:28,070 --> 00:22:31,289
okay and then what about the ones you

581
00:22:31,289 --> 00:22:33,779
know below this level again right

582
00:22:33,779 --> 00:22:35,789
because each sub tree is being activated

583
00:22:35,789 --> 00:22:37,950
in parallel well what is this or I mean

584
00:22:37,950 --> 00:22:39,659
it's just you know to the bead plus one

585
00:22:39,659 --> 00:22:42,960
times capital B rate which is the number

586
00:22:42,960 --> 00:22:45,870
of actual passage evaluate times the

587
00:22:45,870 --> 00:22:48,029
cost of Geo low but because we chose

588
00:22:48,029 --> 00:22:49,950
this that will be such that the number

589
00:22:49,950 --> 00:22:51,389
of nodes in that level of less than M

590
00:22:51,389 --> 00:22:53,940
you can just assign one processor to do

591
00:22:53,940 --> 00:22:56,870
you know one of these parallel

592
00:22:56,870 --> 00:23:02,460
executions okay great so why won't the

593
00:23:02,460 --> 00:23:03,750
paths overflowed these circuits will me

594
00:23:03,750 --> 00:23:05,759
I sort of give you a flavor of that

595
00:23:05,759 --> 00:23:07,470
during the talk but you know you finally

596
00:23:07,470 --> 00:23:09,809
look the details just check out the

597
00:23:09,809 --> 00:23:11,170
paper

598
00:23:11,170 --> 00:23:15,880
and with that I'll conclude so what are

599
00:23:15,880 --> 00:23:17,080
the open problems here right

600
00:23:17,080 --> 00:23:19,180
one great open problem is you know how

601
00:23:19,180 --> 00:23:20,440
do you get succinctness in the terms of

602
00:23:20,440 --> 00:23:23,200
a program length right so there are

603
00:23:23,200 --> 00:23:25,660
there are you know a long line of works

604
00:23:25,660 --> 00:23:28,300
on succinctness and reusability and i/o

605
00:23:28,300 --> 00:23:30,940
and these are from stronger assumptions

606
00:23:30,940 --> 00:23:32,790
can we get this from weaker assumptions

607
00:23:32,790 --> 00:23:37,630
that's one question and it's like I said

608
00:23:37,630 --> 00:23:39,340
you know I mean that's yeah this is one

609
00:23:39,340 --> 00:23:40,210
of the things you can get from stronger

610
00:23:40,210 --> 00:23:41,230
assumptions but what are some other

611
00:23:41,230 --> 00:23:42,100
things you can get from stronger

612
00:23:42,100 --> 00:23:44,170
assumptions right so if you assume the

613
00:23:44,170 --> 00:23:44,890
company should all diffie-hellman

614
00:23:44,890 --> 00:23:46,720
assumption and you combine you know the

615
00:23:46,720 --> 00:23:48,940
garble tree idea you can get idea like

616
00:23:48,940 --> 00:23:53,770
we saw in Nico's talk yesterday and what

617
00:23:53,770 --> 00:23:55,510
about other distributed models of RAM

618
00:23:55,510 --> 00:23:57,880
computation right you know P Ram is not

619
00:23:57,880 --> 00:23:59,800
the only one there's many other models

620
00:23:59,800 --> 00:24:04,210
what about those okay and just to wrap

621
00:24:04,210 --> 00:24:07,240
up in the top you saw a way to garbled

622
00:24:07,240 --> 00:24:10,270
Ram programs in a black box parallel way

623
00:24:10,270 --> 00:24:12,850
and this allows for non interactive

624
00:24:12,850 --> 00:24:16,000
secure Ram computation in in parallel

625
00:24:16,000 --> 00:24:18,100
all right thanks

626
00:24:18,100 --> 00:24:25,230
[Applause]

