1
00:00:00,240 --> 00:00:02,560
hi i'm linka this talk will cover

2
00:00:02,560 --> 00:00:04,160
material from a paper studying the

3
00:00:04,160 --> 00:00:06,640
messaging protocol of telegram which was

4
00:00:06,640 --> 00:00:08,480
joined work with martin albrecht kenny

5
00:00:08,480 --> 00:00:11,679
patterson and igor stepanov

6
00:00:11,679 --> 00:00:13,679
given the focus of this workshop i will

7
00:00:13,679 --> 00:00:15,519
narrow it down and mainly talk about the

8
00:00:15,519 --> 00:00:18,400
attacks in the paper

9
00:00:18,560 --> 00:00:20,720
so briefly i will first motivate why we

10
00:00:20,720 --> 00:00:22,640
did this work and introduce the protocol

11
00:00:22,640 --> 00:00:24,480
in a less formal way

12
00:00:24,480 --> 00:00:26,480
i will explain the attacks both on the

13
00:00:26,480 --> 00:00:29,039
protocol and the implementation level

14
00:00:29,039 --> 00:00:31,119
and to conclude i will briefly mention

15
00:00:31,119 --> 00:00:32,719
what we learned from the proof side of

16
00:00:32,719 --> 00:00:34,640
the project

17
00:00:34,640 --> 00:00:36,480
telegram has grown in popularity in

18
00:00:36,480 --> 00:00:38,760
recent years claiming to have reached

19
00:00:38,760 --> 00:00:42,079
550 million users last year but that's

20
00:00:42,079 --> 00:00:44,640
only a part of the picture

21
00:00:44,640 --> 00:00:46,079
the thing that makes it especially

22
00:00:46,079 --> 00:00:47,360
interesting is that it gained a

23
00:00:47,360 --> 00:00:49,520
reputation for being a protest app

24
00:00:49,520 --> 00:00:51,039
around the world

25
00:00:51,039 --> 00:00:53,199
it was used for coordinating protests in

26
00:00:53,199 --> 00:00:55,120
hong kong and belarus just to give two

27
00:00:55,120 --> 00:00:56,800
examples

28
00:00:56,800 --> 00:00:58,239
in these protests it was always

29
00:00:58,239 --> 00:01:00,399
described as an encrypted messenger on

30
00:01:00,399 --> 00:01:02,559
power with signal or whatsapp even

31
00:01:02,559 --> 00:01:04,159
though they give very different security

32
00:01:04,159 --> 00:01:07,200
guarantees in practice

33
00:01:07,200 --> 00:01:09,040
the cryptographic protocol securing

34
00:01:09,040 --> 00:01:10,960
telegram is custom-made and does not

35
00:01:10,960 --> 00:01:13,200
follow standard practice

36
00:01:13,200 --> 00:01:15,119
yet it has not received much detailed

37
00:01:15,119 --> 00:01:17,759
study to date

38
00:01:17,759 --> 00:01:19,680
three attacks were described in previous

39
00:01:19,680 --> 00:01:22,560
versions one theoretical and cca attack

40
00:01:22,560 --> 00:01:24,840
and two attacks on

41
00:01:24,840 --> 00:01:26,960
implementations there is also a recent

42
00:01:26,960 --> 00:01:28,880
paper that proved telegram to be secure

43
00:01:28,880 --> 00:01:31,119
in a symbolic setting however it

44
00:01:31,119 --> 00:01:33,280
abstracted away most of the details of

45
00:01:33,280 --> 00:01:36,880
the building blocks of the protocol

46
00:01:36,960 --> 00:01:38,880
further most of the focus on telegram

47
00:01:38,880 --> 00:01:41,119
has been on so-called secret chats which

48
00:01:41,119 --> 00:01:42,640
are supposed to provide end-to-end

49
00:01:42,640 --> 00:01:43,759
encryption

50
00:01:43,759 --> 00:01:45,119
however they have very limited

51
00:01:45,119 --> 00:01:47,040
functionality and seem to not be used

52
00:01:47,040 --> 00:01:48,640
much in practice

53
00:01:48,640 --> 00:01:50,720
so most users are actually using cloud

54
00:01:50,720 --> 00:01:52,799
chats which only secure the client

55
00:01:52,799 --> 00:01:55,119
server links and these are the focus of

56
00:01:55,119 --> 00:01:57,520
our work

57
00:01:57,520 --> 00:02:00,479
so empty proto version 2.0 runs directly

58
00:02:00,479 --> 00:02:03,119
over the transport which is normally tcp

59
00:02:03,119 --> 00:02:05,920
or http

60
00:02:06,880 --> 00:02:08,479
now at a very high level the key

61
00:02:08,479 --> 00:02:10,720
exchange uses a variant of the jp helmet

62
00:02:10,720 --> 00:02:12,080
key exchange

63
00:02:12,080 --> 00:02:15,040
the output of which is a 2048 b value

64
00:02:15,040 --> 00:02:17,360
which is called an auth key

65
00:02:17,360 --> 00:02:19,680
the symmetric channel could be described

66
00:02:19,680 --> 00:02:21,360
as a stateful encrypt and mac

67
00:02:21,360 --> 00:02:22,400
construction

68
00:02:22,400 --> 00:02:25,200
using aes in ige mode which i will get

69
00:02:25,200 --> 00:02:29,440
to later and the heavy use of shatter56

70
00:02:29,440 --> 00:02:31,680
the scheme has a few quirks the most

71
00:02:31,680 --> 00:02:33,519
important one being that the client and

72
00:02:33,519 --> 00:02:36,879
server use different but related keys

73
00:02:36,879 --> 00:02:38,879
and so the direction matters for how a

74
00:02:38,879 --> 00:02:41,840
message is encrypted

75
00:02:41,840 --> 00:02:43,440
and this symmetric channel was the main

76
00:02:43,440 --> 00:02:46,400
focus of our work

77
00:02:46,959 --> 00:02:48,400
i will now go through this in more

78
00:02:48,400 --> 00:02:50,560
detail

79
00:02:50,560 --> 00:02:52,720
we start with the auth key and a plain

80
00:02:52,720 --> 00:02:55,280
text payload

81
00:02:55,280 --> 00:02:57,360
the entire out key is first run through

82
00:02:57,360 --> 00:03:00,000
sha 1 and truncated to compute something

83
00:03:00,000 --> 00:03:01,920
called an auth key id

84
00:03:01,920 --> 00:03:03,840
which just serves as an identifier for

85
00:03:03,840 --> 00:03:06,400
the connection

86
00:03:06,400 --> 00:03:08,879
next a portion of the out key is run

87
00:03:08,879 --> 00:03:10,959
through shutter 56 together with the

88
00:03:10,959 --> 00:03:12,080
payload

89
00:03:12,080 --> 00:03:15,440
in the middle 128 bits form a so-called

90
00:03:15,440 --> 00:03:16,800
message key

91
00:03:16,800 --> 00:03:20,319
which will also serve as a mac

92
00:03:20,480 --> 00:03:22,640
then a different portion of the out key

93
00:03:22,640 --> 00:03:25,280
is used with the message key in two more

94
00:03:25,280 --> 00:03:27,280
shutter 56 calls

95
00:03:27,280 --> 00:03:29,120
and then interleaved to produce a

96
00:03:29,120 --> 00:03:33,200
symmetric encryption key and iv

97
00:03:33,200 --> 00:03:35,280
finally this key and ib are used to

98
00:03:35,280 --> 00:03:37,760
encrypt the payload using aes 256 and

99
00:03:37,760 --> 00:03:40,159
ige mode

100
00:03:40,159 --> 00:03:42,560
and so what is actually sent on the wire

101
00:03:42,560 --> 00:03:45,120
consists of the authkey id message key

102
00:03:45,120 --> 00:03:47,760
and the ciphertext

103
00:03:47,760 --> 00:03:49,440
there's a few things you can notice at

104
00:03:49,440 --> 00:03:50,959
this point

105
00:03:50,959 --> 00:03:52,720
first you see that this is an encrypted

106
00:03:52,720 --> 00:03:54,560
mac construction because the message key

107
00:03:54,560 --> 00:03:56,879
is sent along with the ciphertext and

108
00:03:56,879 --> 00:03:58,879
the receiver must decrypt first before

109
00:03:58,879 --> 00:04:01,040
checking the mac

110
00:04:01,040 --> 00:04:02,560
the second thing is that the derived

111
00:04:02,560 --> 00:04:05,120
encryption key is message specific

112
00:04:05,120 --> 00:04:06,640
because as you see it depends on the

113
00:04:06,640 --> 00:04:08,560
payload through the inclusion of the

114
00:04:08,560 --> 00:04:12,360
message key in the kdf

115
00:04:15,280 --> 00:04:16,798
one thing i didn't show in detail the

116
00:04:16,798 --> 00:04:18,798
first diagram was how the various slices

117
00:04:18,798 --> 00:04:20,959
are taken from the auth key and you can

118
00:04:20,959 --> 00:04:22,240
see it here

119
00:04:22,240 --> 00:04:24,400
so when the client encrypts a message it

120
00:04:24,400 --> 00:04:26,240
uses keys that are mostly overlapping

121
00:04:26,240 --> 00:04:28,479
with the keys that the server uses but

122
00:04:28,479 --> 00:04:31,039
not fully

123
00:04:32,240 --> 00:04:34,000
this is what the actual plain text

124
00:04:34,000 --> 00:04:35,280
payload

125
00:04:35,280 --> 00:04:36,320
looks like

126
00:04:36,320 --> 00:04:38,080
it has a header that is composed of

127
00:04:38,080 --> 00:04:41,199
64-bit or 32-bit fields

128
00:04:41,199 --> 00:04:43,199
and here the first two fields

129
00:04:43,199 --> 00:04:45,280
server sold and session id

130
00:04:45,280 --> 00:04:47,360
are normally unchanged for the duration

131
00:04:47,360 --> 00:04:49,199
of a single session

132
00:04:49,199 --> 00:04:51,280
where the server sold is generated by

133
00:04:51,280 --> 00:04:53,120
the server and the session id is chosen

134
00:04:53,120 --> 00:04:55,280
by the client

135
00:04:55,280 --> 00:04:57,040
the message id here serves as an

136
00:04:57,040 --> 00:05:00,000
identifier for the particular plain text

137
00:05:00,000 --> 00:05:01,759
and it implicitly also includes a

138
00:05:01,759 --> 00:05:03,840
timestamp

139
00:05:03,840 --> 00:05:05,440
the message sequence number is

140
00:05:05,440 --> 00:05:07,600
essentially just a counter of sent

141
00:05:07,600 --> 00:05:10,000
messages and message length stores the

142
00:05:10,000 --> 00:05:12,880
byte length of message data

143
00:05:12,880 --> 00:05:14,880
so here message data contains the actual

144
00:05:14,880 --> 00:05:17,280
request or response which also has a

145
00:05:17,280 --> 00:05:19,919
specific format but we do not model this

146
00:05:19,919 --> 00:05:22,160
and consider message data as our input

147
00:05:22,160 --> 00:05:24,000
message

148
00:05:24,000 --> 00:05:26,400
and finally this is followed by between

149
00:05:26,400 --> 00:05:31,599
12 to 1024 bytes of random padding

150
00:05:32,320 --> 00:05:35,199
to say a bit more about the ig mode

151
00:05:35,199 --> 00:05:37,280
it stands for infinite garble extension

152
00:05:37,280 --> 00:05:39,120
and it was first described by campbell

153
00:05:39,120 --> 00:05:42,199
in 1978.

154
00:05:42,639 --> 00:05:44,720
as you can see from the diagram it's

155
00:05:44,720 --> 00:05:46,320
basically like cbc mode with the

156
00:05:46,320 --> 00:05:48,160
addition of also chaining the plain text

157
00:05:48,160 --> 00:05:50,479
blocks

158
00:05:50,479 --> 00:05:52,160
it was supposed to have infinite error

159
00:05:52,160 --> 00:05:53,840
propagation and therefore provide

160
00:05:53,840 --> 00:05:56,160
integrity but this claim is actually not

161
00:05:56,160 --> 00:05:58,720
true because one can modify a ciphertext

162
00:05:58,720 --> 00:06:00,800
in such a way that it will differ from

163
00:06:00,800 --> 00:06:04,319
the original only in two blocks

164
00:06:04,319 --> 00:06:06,479
however mt proto does not rely on this

165
00:06:06,479 --> 00:06:08,319
property

166
00:06:08,319 --> 00:06:10,000
and because it has message dependent

167
00:06:10,000 --> 00:06:12,560
keys it is essentially only used as a

168
00:06:12,560 --> 00:06:15,360
one-time sag

169
00:06:18,319 --> 00:06:20,240
before going over the attacks i will

170
00:06:20,240 --> 00:06:21,759
quickly set the stage for what we

171
00:06:21,759 --> 00:06:22,960
actually looked at and what the

172
00:06:22,960 --> 00:06:26,080
implications of this are

173
00:06:26,080 --> 00:06:28,319
first to re-emphasize we looked mainly

174
00:06:28,319 --> 00:06:29,759
at the symmetric channel part of the

175
00:06:29,759 --> 00:06:33,120
protocol for encrypting cloud chat

176
00:06:33,120 --> 00:06:34,639
implementation-wise

177
00:06:34,639 --> 00:06:36,800
we looked at three official clients and

178
00:06:36,800 --> 00:06:40,639
that is for android ios and desktop

179
00:06:40,639 --> 00:06:42,720
telegram also provides a cross-platform

180
00:06:42,720 --> 00:06:44,960
library that implements empty project

181
00:06:44,960 --> 00:06:46,639
however the official clients don't make

182
00:06:46,639 --> 00:06:49,039
use of it

183
00:06:49,039 --> 00:06:50,639
further the protocol protocol

184
00:06:50,639 --> 00:06:52,800
implemented across these clients is

185
00:06:52,800 --> 00:06:54,639
roughly similar but not entirely the

186
00:06:54,639 --> 00:06:55,440
same

187
00:06:55,440 --> 00:06:57,199
especially when it comes to details of

188
00:06:57,199 --> 00:07:00,560
how the plain text format is processed

189
00:07:00,560 --> 00:07:02,639
and this also has implications for our

190
00:07:02,639 --> 00:07:05,039
attacks

191
00:07:05,599 --> 00:07:07,280
further there is no clear separation

192
00:07:07,280 --> 00:07:08,880
between the code of the protocol and

193
00:07:08,880 --> 00:07:10,479
application code

194
00:07:10,479 --> 00:07:12,000
but we had to make this cut for our

195
00:07:12,000 --> 00:07:13,759
analysis somewhere so there is

196
00:07:13,759 --> 00:07:15,680
possibility we missed some problematic

197
00:07:15,680 --> 00:07:18,319
interactions

198
00:07:20,479 --> 00:07:21,759
we also looked at the official

199
00:07:21,759 --> 00:07:24,479
documentation for md proto

200
00:07:24,479 --> 00:07:26,479
which was in some cases outdated or

201
00:07:26,479 --> 00:07:28,800
incomplete so it also cannot serve as a

202
00:07:28,800 --> 00:07:32,400
definitive reference for the protocol

203
00:07:32,400 --> 00:07:34,720
finally we invert server behavior from

204
00:07:34,720 --> 00:07:36,720
practical experiments

205
00:07:36,720 --> 00:07:38,800
since telegram has expressed multiple

206
00:07:38,800 --> 00:07:40,479
times that they do not have any plans

207
00:07:40,479 --> 00:07:43,280
for publishing server code

208
00:07:43,280 --> 00:07:44,879
all in all this means that at least at

209
00:07:44,879 --> 00:07:46,879
the time of our study it was not

210
00:07:46,879 --> 00:07:48,720
possible to have a single specification

211
00:07:48,720 --> 00:07:50,240
of this protocol

212
00:07:50,240 --> 00:07:52,080
which had implications mainly for our

213
00:07:52,080 --> 00:07:55,960
modeling part of the work

214
00:07:59,280 --> 00:08:01,039
i will now speak about the two simpler

215
00:08:01,039 --> 00:08:05,120
attacks that exploit payload validation

216
00:08:05,360 --> 00:08:07,759
the first one is message reordering

217
00:08:07,759 --> 00:08:10,080
and the client to server direction

218
00:08:10,080 --> 00:08:11,840
which is due to insufficient checks on

219
00:08:11,840 --> 00:08:13,520
the message id and message sequence

220
00:08:13,520 --> 00:08:14,400
number

221
00:08:14,400 --> 00:08:16,160
which are determined by the sending

222
00:08:16,160 --> 00:08:18,879
order of the messages

223
00:08:18,879 --> 00:08:20,800
this is because the server decides the

224
00:08:20,800 --> 00:08:23,759
final order of messages not based on

225
00:08:23,759 --> 00:08:25,759
these values but based on when it

226
00:08:25,759 --> 00:08:28,879
receives the messages

227
00:08:28,960 --> 00:08:30,479
we confirmed this in practice on the

228
00:08:30,479 --> 00:08:32,719
android client

229
00:08:32,719 --> 00:08:34,559
and it's worth noting that despite what

230
00:08:34,559 --> 00:08:36,880
telegram claims this kind of reordering

231
00:08:36,880 --> 00:08:38,958
is easily preventable

232
00:08:38,958 --> 00:08:41,279
and it's either on the empty proto level

233
00:08:41,279 --> 00:08:44,640
or the application level

234
00:08:45,839 --> 00:08:47,760
the second attack is enabled by the

235
00:08:47,760 --> 00:08:51,200
re-encryption of unacknowledged messages

236
00:08:51,200 --> 00:08:53,040
what this means is that most messages in

237
00:08:53,040 --> 00:08:54,560
telegram require a special

238
00:08:54,560 --> 00:08:58,000
acknowledgement message to be sent back

239
00:08:58,000 --> 00:08:59,519
if they don't get this acknowledgement

240
00:08:59,519 --> 00:09:01,440
within a given time

241
00:09:01,440 --> 00:09:03,519
the messages are re-encrypted using the

242
00:09:03,519 --> 00:09:06,880
same message id and fresh writing

243
00:09:06,880 --> 00:09:08,720
in practice this means that the stateful

244
00:09:08,720 --> 00:09:11,279
scheme is no longer stateful

245
00:09:11,279 --> 00:09:13,120
because all of the plaintext headers are

246
00:09:13,120 --> 00:09:15,519
the same

247
00:09:15,839 --> 00:09:18,080
so we describe an ncpa attack in the

248
00:09:18,080 --> 00:09:20,240
setting where the adversary controls the

249
00:09:20,240 --> 00:09:22,880
randomness which is a strong assumption

250
00:09:22,880 --> 00:09:25,519
but our proofs are also in this setting

251
00:09:25,519 --> 00:09:26,959
and if the stateful scheme works

252
00:09:26,959 --> 00:09:28,800
properly then the randomness should not

253
00:09:28,800 --> 00:09:30,959
be needed

254
00:09:30,959 --> 00:09:32,640
however if you don't give the adversary

255
00:09:32,640 --> 00:09:34,720
this power then this attack requires

256
00:09:34,720 --> 00:09:37,760
around two to the 64 queries because you

257
00:09:37,760 --> 00:09:39,760
will need a mac collision to produce a

258
00:09:39,760 --> 00:09:41,839
message key that will be the same for

259
00:09:41,839 --> 00:09:44,320
two ciphertexts so then it's just a

260
00:09:44,320 --> 00:09:47,360
theoretical attack

261
00:09:49,200 --> 00:09:51,040
now our tags on the implementation

262
00:09:51,040 --> 00:09:54,480
explore timing side channels

263
00:09:56,480 --> 00:09:57,920
first we found an issue during the

264
00:09:57,920 --> 00:09:59,839
processing of a received ciphertext in

265
00:09:59,839 --> 00:10:02,160
various official clients

266
00:10:02,160 --> 00:10:03,760
this was in the message length field

267
00:10:03,760 --> 00:10:05,760
which had certain constraints on it and

268
00:10:05,760 --> 00:10:07,600
these were checked before the mac in the

269
00:10:07,600 --> 00:10:09,600
message key was checked

270
00:10:09,600 --> 00:10:11,839
in both cases telegram returned the same

271
00:10:11,839 --> 00:10:13,920
error but if the message length check

272
00:10:13,920 --> 00:10:17,440
failed it would return early

273
00:10:17,440 --> 00:10:19,120
the actual timing difference was quite

274
00:10:19,120 --> 00:10:21,920
small about three microseconds which was

275
00:10:21,920 --> 00:10:25,760
tested with the endpoint implementation

276
00:10:26,079 --> 00:10:27,839
depending on the client this lets us

277
00:10:27,839 --> 00:10:30,519
recover between age to 32 bits of

278
00:10:30,519 --> 00:10:34,560
128 plaintext block

279
00:10:34,560 --> 00:10:36,480
this attacks is similar to existing

280
00:10:36,480 --> 00:10:39,279
plaintext recovery attacks on ssh

281
00:10:39,279 --> 00:10:41,760
in that the idea is to move a target

282
00:10:41,760 --> 00:10:44,079
ciphertext block to a position where the

283
00:10:44,079 --> 00:10:46,320
underlying plaintext will be interpreted

284
00:10:46,320 --> 00:10:47,920
as a length field

285
00:10:47,920 --> 00:10:49,839
and then use the resulting behavior to

286
00:10:49,839 --> 00:10:51,680
learn something about the target blank

287
00:10:51,680 --> 00:10:53,600
block

288
00:10:53,600 --> 00:10:56,320
what's complicated slightly is ige so we

289
00:10:56,320 --> 00:10:58,079
need to construct valid ciphertext with

290
00:10:58,079 --> 00:11:00,320
our target somehow in the second block

291
00:11:00,320 --> 00:11:03,600
which i will illustrate shortly

292
00:11:03,600 --> 00:11:05,040
and for this to work you also need to

293
00:11:05,040 --> 00:11:08,560
know two other plain text blocks

294
00:11:10,079 --> 00:11:11,680
suppose we have a plain text made up of

295
00:11:11,680 --> 00:11:13,760
four blocks that look like this

296
00:11:13,760 --> 00:11:15,680
so the first two have the header and the

297
00:11:15,680 --> 00:11:17,360
next two have some message that we are

298
00:11:17,360 --> 00:11:20,560
interested in recovering

299
00:11:20,560 --> 00:11:23,040
they are encrypted with ige using a key

300
00:11:23,040 --> 00:11:26,399
and iv derived as shown earlier

301
00:11:26,399 --> 00:11:29,120
the last plain text block is our target

302
00:11:29,120 --> 00:11:31,760
and we further assume that m1 and m3 are

303
00:11:31,760 --> 00:11:33,040
known

304
00:11:33,040 --> 00:11:34,800
for the preceding message block this is

305
00:11:34,800 --> 00:11:36,480
perhaps reasonable

306
00:11:36,480 --> 00:11:39,279
but the header block lies so because the

307
00:11:39,279 --> 00:11:41,120
server result and session id are

308
00:11:41,120 --> 00:11:44,079
effectively secret random values

309
00:11:44,079 --> 00:11:46,640
however these values are the same for

310
00:11:46,640 --> 00:11:49,360
many ciphertexts in the same session

311
00:11:49,360 --> 00:11:51,200
for now assume we have both of these

312
00:11:51,200 --> 00:11:53,600
blocks

313
00:11:53,920 --> 00:11:55,519
what the attacker can deliver to a

314
00:11:55,519 --> 00:11:58,160
client is then the following ciphertext

315
00:11:58,160 --> 00:11:59,920
made up of the first ciphertext block

316
00:11:59,920 --> 00:12:01,200
unchanged

317
00:12:01,200 --> 00:12:02,959
followed by a new block which is the

318
00:12:02,959 --> 00:12:05,279
exor of the target ciphertext block with

319
00:12:05,279 --> 00:12:08,480
the two known plaintext blocks

320
00:12:08,480 --> 00:12:10,000
the claim that decrypts this will

321
00:12:10,000 --> 00:12:13,040
compute the following

322
00:12:13,040 --> 00:12:17,199
we're substituting c star we get this

323
00:12:17,440 --> 00:12:18,959
which recovers

324
00:12:18,959 --> 00:12:21,600
the underlying equation on the left

325
00:12:21,600 --> 00:12:23,360
and so the client will get the target

326
00:12:23,360 --> 00:12:25,920
plaintext block exert with two known

327
00:12:25,920 --> 00:12:28,320
ciphertext blocks

328
00:12:28,320 --> 00:12:30,000
and if the attacker can now leak some

329
00:12:30,000 --> 00:12:31,760
information from the message length

330
00:12:31,760 --> 00:12:32,639
field

331
00:12:32,639 --> 00:12:34,399
they can directly compute bits of the

332
00:12:34,399 --> 00:12:38,360
target plaintext block

333
00:12:40,720 --> 00:12:42,560
the previous attack requires knowledge

334
00:12:42,560 --> 00:12:44,880
of the first two header fields so this

335
00:12:44,880 --> 00:12:47,120
attack attempts to recover one of them

336
00:12:47,120 --> 00:12:49,839
the server sold

337
00:12:49,839 --> 00:12:51,920
the server salt is normally generated by

338
00:12:51,920 --> 00:12:53,920
the server and periodically sent to the

339
00:12:53,920 --> 00:12:54,959
client

340
00:12:54,959 --> 00:12:56,720
but in the connection immediately after

341
00:12:56,720 --> 00:12:59,839
a key exchange this is different

342
00:12:59,839 --> 00:13:01,920
so initially the server sold as derived

343
00:13:01,920 --> 00:13:03,600
from a secret knowledge that is sent by

344
00:13:03,600 --> 00:13:07,680
the client during the key exchange

345
00:13:07,680 --> 00:13:10,000
more precisely the server sort is an

346
00:13:10,000 --> 00:13:11,920
example of a portion of the so-called

347
00:13:11,920 --> 00:13:14,560
new nouns and the server nodes where the

348
00:13:14,560 --> 00:13:18,638
letter is actually sent in plain text

349
00:13:18,800 --> 00:13:21,360
the new nonce is however encrypted using

350
00:13:21,360 --> 00:13:23,920
rsa on a custom padding format that

351
00:13:23,920 --> 00:13:25,600
looks like this

352
00:13:25,600 --> 00:13:28,000
it starts with the sha-1 of the data and

353
00:13:28,000 --> 00:13:30,320
the actual data and finally padding

354
00:13:30,320 --> 00:13:34,800
where the data can be of variable length

355
00:13:34,800 --> 00:13:36,320
and notice that the padding is not

356
00:13:36,320 --> 00:13:38,639
included in the checksum so the server

357
00:13:38,639 --> 00:13:40,880
must parse this before checking and

358
00:13:40,880 --> 00:13:42,880
there is a potential for several timing

359
00:13:42,880 --> 00:13:44,399
side channels depending on what is

360
00:13:44,399 --> 00:13:46,399
checked first

361
00:13:46,399 --> 00:13:48,079
telegram doesn't publish their server

362
00:13:48,079 --> 00:13:50,079
code and we were only able to test what

363
00:13:50,079 --> 00:13:52,320
checks are made not their order

364
00:13:52,320 --> 00:13:54,320
however the developers acknowledged the

365
00:13:54,320 --> 00:13:56,399
attack but did not offer any details on

366
00:13:56,399 --> 00:13:59,680
the server implementation

367
00:14:01,120 --> 00:14:03,199
but first let me walk through the first

368
00:14:03,199 --> 00:14:05,040
three steps of the key exchange in more

369
00:14:05,040 --> 00:14:07,519
detail

370
00:14:07,920 --> 00:14:10,079
assume that the server has an rsa public

371
00:14:10,079 --> 00:14:12,399
key with modulus and prime and exponent

372
00:14:12,399 --> 00:14:13,120
e

373
00:14:13,120 --> 00:14:14,959
the client knows this because it is

374
00:14:14,959 --> 00:14:17,360
shipped with the app

375
00:14:17,360 --> 00:14:20,000
the client generates a random nuns

376
00:14:20,000 --> 00:14:22,560
and sends it over in the clear

377
00:14:22,560 --> 00:14:24,320
the server does the same

378
00:14:24,320 --> 00:14:26,639
but it also generates a number n that is

379
00:14:26,639 --> 00:14:28,160
64 bits

380
00:14:28,160 --> 00:14:31,120
and actually a product of two primes

381
00:14:31,120 --> 00:14:33,120
which is intended as some kind of

382
00:14:33,120 --> 00:14:36,320
proof-of-work mechanism

383
00:14:36,320 --> 00:14:38,800
it sends this over in the clear

384
00:14:38,800 --> 00:14:40,800
alongside other information that is not

385
00:14:40,800 --> 00:14:42,839
relevant to this

386
00:14:42,839 --> 00:14:46,639
exposition the client has to factor n

387
00:14:46,639 --> 00:14:48,560
and then it generates a new nonce which

388
00:14:48,560 --> 00:14:51,360
is supposed to stay secret

389
00:14:51,360 --> 00:14:53,519
and encapsulates it in a string of this

390
00:14:53,519 --> 00:14:55,760
form

391
00:14:56,160 --> 00:14:57,360
where ink

392
00:14:57,360 --> 00:14:59,440
represents just a deterministic encoding

393
00:14:59,440 --> 00:15:02,800
function for variable length integers

394
00:15:02,800 --> 00:15:06,959
and header is a fixed 32-bit value

395
00:15:06,959 --> 00:15:09,199
and so this data is encapsulated in the

396
00:15:09,199 --> 00:15:11,519
custom format i have already shown

397
00:15:11,519 --> 00:15:12,720
earlier

398
00:15:12,720 --> 00:15:14,800
which includes a sha-1 of the data

399
00:15:14,800 --> 00:15:17,760
without the pattern

400
00:15:17,760 --> 00:15:20,079
it does textbook rsa encryption over

401
00:15:20,079 --> 00:15:21,440
this

402
00:15:21,440 --> 00:15:26,000
and sends the ciphertext over

403
00:15:26,000 --> 00:15:27,519
at this point there are many options

404
00:15:27,519 --> 00:15:29,199
depending on what happens on the server

405
00:15:29,199 --> 00:15:30,000
side

406
00:15:30,000 --> 00:15:31,920
knowing that the server has to parse

407
00:15:31,920 --> 00:15:34,560
data before checking the hash

408
00:15:34,560 --> 00:15:36,399
we confirmed that the server did check

409
00:15:36,399 --> 00:15:38,240
the header value

410
00:15:38,240 --> 00:15:40,079
some bounds on the encoding as well as

411
00:15:40,079 --> 00:15:42,000
the values of p and q

412
00:15:42,000 --> 00:15:44,240
we also confirmed that it did not check

413
00:15:44,240 --> 00:15:47,759
the provided value of n for example

414
00:15:47,759 --> 00:15:50,000
and however we could not determine the

415
00:15:50,000 --> 00:15:51,440
order in which these checks were

416
00:15:51,440 --> 00:15:53,120
performed

417
00:15:53,120 --> 00:15:55,279
for this attack we will assume that the

418
00:15:55,279 --> 00:15:57,839
leakage is from the header check but the

419
00:15:57,839 --> 00:15:59,680
paper also discusses other potential

420
00:15:59,680 --> 00:16:02,000
leakage patterns

421
00:16:02,000 --> 00:16:03,680
and you can notice here that in the

422
00:16:03,680 --> 00:16:05,279
plain text format

423
00:16:05,279 --> 00:16:08,399
the attacker already knows all parts of

424
00:16:08,399 --> 00:16:11,360
the message m except for the new nouns

425
00:16:11,360 --> 00:16:15,440
the hash and the random padding

426
00:16:16,480 --> 00:16:18,480
for this exposition suppose the header

427
00:16:18,480 --> 00:16:20,720
check returns earth

428
00:16:20,720 --> 00:16:22,800
if the attacker submits the chosen value

429
00:16:22,800 --> 00:16:25,440
c prime and put in place of the target

430
00:16:25,440 --> 00:16:28,000
it can learn if the 32 bits in the

431
00:16:28,000 --> 00:16:30,399
header position of the decryption of c

432
00:16:30,399 --> 00:16:33,199
prime match the header value which

433
00:16:33,199 --> 00:16:35,680
provides our oracle

434
00:16:35,680 --> 00:16:38,079
and we can use this oracle in a similar

435
00:16:38,079 --> 00:16:40,160
way to black and white as a tag by

436
00:16:40,160 --> 00:16:43,120
choosing c prime to be s i

437
00:16:43,120 --> 00:16:46,399
to e times our target whereas the s i

438
00:16:46,399 --> 00:16:49,759
values are chosen randomly

439
00:16:49,759 --> 00:16:52,000
and the probability of a correct match

440
00:16:52,000 --> 00:16:53,199
here is then

441
00:16:53,199 --> 00:16:56,800
1 over 2 to the 32.

442
00:16:57,120 --> 00:17:00,399
we can rephrase our goal as recovering h

443
00:17:00,399 --> 00:17:03,279
and n prime from a message m of this

444
00:17:03,279 --> 00:17:04,480
form

445
00:17:04,480 --> 00:17:08,799
where h is the unknown hash of data

446
00:17:09,520 --> 00:17:12,000
gamma encompasses all known information

447
00:17:12,000 --> 00:17:15,599
such as the values of p and q

448
00:17:15,919 --> 00:17:18,160
and prime is the new nouns that we want

449
00:17:18,160 --> 00:17:20,799
to recover

450
00:17:21,119 --> 00:17:24,000
and p is the unknown padding

451
00:17:24,000 --> 00:17:26,160
and here we need to recover the value of

452
00:17:26,160 --> 00:17:28,559
h first because it is necessary for

453
00:17:28,559 --> 00:17:32,720
recovering and prime our actual target

454
00:17:32,720 --> 00:17:35,039
and written another way the plain text m

455
00:17:35,039 --> 00:17:36,480
is of this form

456
00:17:36,480 --> 00:17:39,120
where the values l l prime and gamma are

457
00:17:39,120 --> 00:17:42,000
known to the attack

458
00:17:42,480 --> 00:17:44,480
to recover the hash

459
00:17:44,480 --> 00:17:47,039
we first have to find random s i values

460
00:17:47,039 --> 00:17:48,240
such that

461
00:17:48,240 --> 00:17:50,240
m prime the decryption of our chosen

462
00:17:50,240 --> 00:17:52,480
ciphertext as a header match as

463
00:17:52,480 --> 00:17:54,080
explained earlier

464
00:17:54,080 --> 00:17:56,720
but also that sr is sufficiently small

465
00:17:56,720 --> 00:17:58,799
so that the parts of m prime determined

466
00:17:58,799 --> 00:18:01,520
by the new nouns n prime and padding p

467
00:18:01,520 --> 00:18:03,440
don't contribute to the header bits of m

468
00:18:03,440 --> 00:18:04,320
prime

469
00:18:04,320 --> 00:18:06,240
and they can essentially be ignored in

470
00:18:06,240 --> 00:18:08,880
some sense

471
00:18:08,960 --> 00:18:10,640
with this you can construct the lattice

472
00:18:10,640 --> 00:18:12,400
for inequalities of the form shown on

473
00:18:12,400 --> 00:18:14,960
the slide where sigma i is unknown and

474
00:18:14,960 --> 00:18:18,640
ti is derived from known values

475
00:18:18,640 --> 00:18:20,400
and so finding a shortest vector in this

476
00:18:20,400 --> 00:18:22,559
lattice recovers the target hash when

477
00:18:22,559 --> 00:18:25,039
the parameter mu is six

478
00:18:25,039 --> 00:18:27,200
so we need to find six si values that

479
00:18:27,200 --> 00:18:30,160
fit our criteria

480
00:18:30,799 --> 00:18:32,640
next to recover the new nouns the

481
00:18:32,640 --> 00:18:34,400
process is similar

482
00:18:34,400 --> 00:18:36,799
we first have to find random si primes

483
00:18:36,799 --> 00:18:39,120
values such that

484
00:18:39,120 --> 00:18:43,120
again m prime has a header match

485
00:18:43,120 --> 00:18:44,720
and si prime

486
00:18:44,720 --> 00:18:46,480
is small enough to let us ignore the

487
00:18:46,480 --> 00:18:48,799
padding but large enough that the part

488
00:18:48,799 --> 00:18:51,600
of m prime determined by the new nouns

489
00:18:51,600 --> 00:18:53,600
does contribute to the header bits of n

490
00:18:53,600 --> 00:18:55,679
prime because this is the value we want

491
00:18:55,679 --> 00:18:58,240
to recover

492
00:18:58,799 --> 00:19:00,320
and so with this you can construct a

493
00:19:00,320 --> 00:19:03,200
lattice of a similar form where sigma i

494
00:19:03,200 --> 00:19:05,679
prime is unknown and t i prime is

495
00:19:05,679 --> 00:19:08,480
derived from known values but this time

496
00:19:08,480 --> 00:19:12,720
also include the recovered hash h

497
00:19:12,720 --> 00:19:14,400
and finding a shortest vector in this

498
00:19:14,400 --> 00:19:16,960
lattice recovers all but around 4 bits

499
00:19:16,960 --> 00:19:18,240
of n prime

500
00:19:18,240 --> 00:19:22,080
when the parameter mu prime is set to 9.

501
00:19:22,080 --> 00:19:24,160
recovering the rest is simple however

502
00:19:24,160 --> 00:19:26,080
because we can use exhaustive search by

503
00:19:26,080 --> 00:19:28,240
just recomputing the hash and comparing

504
00:19:28,240 --> 00:19:30,640
it with age

505
00:19:30,640 --> 00:19:32,559
overall this attack requires around six

506
00:19:32,559 --> 00:19:35,360
plus six plus nine times two to the 32

507
00:19:35,360 --> 00:19:37,520
queries and a small amount of offline

508
00:19:37,520 --> 00:19:40,160
computation

509
00:19:41,200 --> 00:19:42,960
now i will show the remaining steps in

510
00:19:42,960 --> 00:19:45,280
the key exchange but in less detail only

511
00:19:45,280 --> 00:19:47,200
to see that recovering this new nums

512
00:19:47,200 --> 00:19:48,880
value also actually gives you a man in

513
00:19:48,880 --> 00:19:52,480
the middle on the key exchange

514
00:19:52,480 --> 00:19:54,320
both the client and the server use these

515
00:19:54,320 --> 00:19:56,559
nodes to derive a key and iv for

516
00:19:56,559 --> 00:19:58,240
symmetric encryption

517
00:19:58,240 --> 00:19:59,200
which is

518
00:19:59,200 --> 00:20:01,120
for our purposes just some function that

519
00:20:01,120 --> 00:20:03,919
uses sha-1

520
00:20:03,919 --> 00:20:06,240
this key and iv are used by the server

521
00:20:06,240 --> 00:20:08,159
with ige mode

522
00:20:08,159 --> 00:20:10,720
to encrypt data of this form

523
00:20:10,720 --> 00:20:12,640
which includes a diffie-hellman value g

524
00:20:12,640 --> 00:20:14,400
to the a

525
00:20:14,400 --> 00:20:16,559
the server sends this over

526
00:20:16,559 --> 00:20:18,840
and similarly the client computes its

527
00:20:18,840 --> 00:20:21,600
secret and encrypted in the same format

528
00:20:21,600 --> 00:20:23,679
with ige

529
00:20:23,679 --> 00:20:27,760
with this data and sends it over

530
00:20:27,760 --> 00:20:30,000
both computed the auth key

531
00:20:30,000 --> 00:20:31,919
and additionally another hash value

532
00:20:31,919 --> 00:20:34,799
using xiaomi that depends on both the

533
00:20:34,799 --> 00:20:37,760
neuns and the computed out key

534
00:20:37,760 --> 00:20:40,400
and send it over

535
00:20:40,400 --> 00:20:42,400
so here you can see easily that if we

536
00:20:42,400 --> 00:20:44,720
can recover the new nodes we can

537
00:20:44,720 --> 00:20:47,520
manipulate these ciphertexts as well

538
00:20:47,520 --> 00:20:49,360
however there is only a short time

539
00:20:49,360 --> 00:20:51,360
window of 10 minutes to execute the

540
00:20:51,360 --> 00:20:52,320
attack

541
00:20:52,320 --> 00:20:55,200
because otherwise

542
00:20:55,200 --> 00:20:58,799
afterwards the server forgets the

543
00:21:01,600 --> 00:21:03,760
in exchange of disclosure we disclosed

544
00:21:03,760 --> 00:21:05,440
the results of our analysis to the

545
00:21:05,440 --> 00:21:07,440
telegram developers in april of last

546
00:21:07,440 --> 00:21:08,559
year

547
00:21:08,559 --> 00:21:10,799
which they acknowledged in june and we

548
00:21:10,799 --> 00:21:12,720
agreed to a public disclosure date in

549
00:21:12,720 --> 00:21:14,960
july 90 days after the initial

550
00:21:14,960 --> 00:21:17,039
disclosure

551
00:21:17,039 --> 00:21:18,880
they also awarded a bug bounty for the

552
00:21:18,880 --> 00:21:21,200
timing side channel and for the overall

553
00:21:21,200 --> 00:21:23,360
analysis

554
00:21:23,360 --> 00:21:25,440
during this process we were informed

555
00:21:25,440 --> 00:21:27,440
that they do not do security or bug fix

556
00:21:27,440 --> 00:21:29,360
releases except for immediate

557
00:21:29,360 --> 00:21:31,919
post-release crash fixes

558
00:21:31,919 --> 00:21:34,480
so the vulnerabilities we reported were

559
00:21:34,480 --> 00:21:36,480
supposedly addressed as part of regular

560
00:21:36,480 --> 00:21:37,840
updates

561
00:21:37,840 --> 00:21:39,280
and the versions that include these

562
00:21:39,280 --> 00:21:43,320
fixes are shown on the slides

563
00:21:44,240 --> 00:21:46,320
before i conclude i will briefly mention

564
00:21:46,320 --> 00:21:47,919
some points that came up during the

565
00:21:47,919 --> 00:21:50,159
proof side of this work

566
00:21:50,159 --> 00:21:51,679
first some attacks that we thought were

567
00:21:51,679 --> 00:21:53,360
obvious are not actually possible

568
00:21:53,360 --> 00:21:55,360
against telegram

569
00:21:55,360 --> 00:21:57,440
for example like length extension

570
00:21:57,440 --> 00:21:59,679
attacks on chat 56

571
00:21:59,679 --> 00:22:02,320
these are prevented in multiple ways

572
00:22:02,320 --> 00:22:04,240
either through fixed length inputs and

573
00:22:04,240 --> 00:22:06,159
truncated outputs but also by the

574
00:22:06,159 --> 00:22:09,440
uniqueness of plaintext headers

575
00:22:09,440 --> 00:22:11,440
second although we prove security of the

576
00:22:11,440 --> 00:22:13,039
empty proto channel

577
00:22:13,039 --> 00:22:14,720
our results require assumptions on

578
00:22:14,720 --> 00:22:17,280
checkout 2 the block cipher underlying

579
00:22:17,280 --> 00:22:18,799
chat 56

580
00:22:18,799 --> 00:22:20,480
which are in some cases highly known

581
00:22:20,480 --> 00:22:24,159
standard and not studied before

582
00:22:24,159 --> 00:22:26,640
for example they must behave as a prf

583
00:22:26,640 --> 00:22:28,480
with partial key leakage or unfixed

584
00:22:28,480 --> 00:22:30,960
inputs

585
00:22:31,520 --> 00:22:33,280
thank you for listening if you want to

586
00:22:33,280 --> 00:22:34,720
read more you can check out the full

587
00:22:34,720 --> 00:22:38,840
paper at the link on the slide

