1
00:00:02,399 --> 00:00:04,240
hello everyone my name is yani anchar

2
00:00:04,240 --> 00:00:06,000
and i'm a phd student from the center

3
00:00:06,000 --> 00:00:07,520
for research on cryptography and

4
00:00:07,520 --> 00:00:09,920
security at massage university in

5
00:00:09,920 --> 00:00:11,679
bernard czech republic and i'm

6
00:00:11,679 --> 00:00:13,840
presenting work done with all of these

7
00:00:13,840 --> 00:00:15,920
great people from max black institute

8
00:00:15,920 --> 00:00:18,640
for security and privacy from erisa and

9
00:00:18,640 --> 00:00:20,080
also from the george washington

10
00:00:20,080 --> 00:00:21,439
university

11
00:00:21,439 --> 00:00:24,400
this work was also presented at ieee smp

12
00:00:24,400 --> 00:00:26,080
2022

13
00:00:26,080 --> 00:00:28,320
if you want more details on the paper

14
00:00:28,320 --> 00:00:30,560
supplementary materials go and check out

15
00:00:30,560 --> 00:00:33,520
this link or scan the qr code

16
00:00:33,520 --> 00:00:34,880
and now this work is all about what

17
00:00:34,880 --> 00:00:36,640
cryptographic library developers think

18
00:00:36,640 --> 00:00:38,800
about timing attacks so let's jump right

19
00:00:38,800 --> 00:00:40,320
in and and

20
00:00:40,320 --> 00:00:42,320
go on with timing attacks

21
00:00:42,320 --> 00:00:43,760
timing attacks have been around for a

22
00:00:43,760 --> 00:00:45,760
while they are now more than 25 years

23
00:00:45,760 --> 00:00:49,120
old introduced in this 1996 paper

24
00:00:49,120 --> 00:00:51,680
they're now even uh older than me

25
00:00:51,680 --> 00:00:53,440
and so what happens in a timing attack

26
00:00:53,440 --> 00:00:55,440
is that the duration of an operation

27
00:00:55,440 --> 00:00:57,600
leaks some information about seekers

28
00:00:57,600 --> 00:01:00,000
that are used within this operation

29
00:01:00,000 --> 00:01:01,680
uh for that operation you can imagine

30
00:01:01,680 --> 00:01:03,359
any sort of usually cryptographic

31
00:01:03,359 --> 00:01:04,400
operation

32
00:01:04,400 --> 00:01:05,199
like

33
00:01:05,199 --> 00:01:09,760
like ecdsa signing or or some some rsa

34
00:01:09,760 --> 00:01:12,799
rsa signatures or things like that or

35
00:01:12,799 --> 00:01:16,240
aes encryption and so on and the

36
00:01:16,240 --> 00:01:17,920
if the duration of an operation somehow

37
00:01:17,920 --> 00:01:20,240
depends on secret draft values the

38
00:01:20,240 --> 00:01:22,240
attacker that can measure the duration

39
00:01:22,240 --> 00:01:24,320
can instruct uh information on these

40
00:01:24,320 --> 00:01:25,360
secrets

41
00:01:25,360 --> 00:01:27,920
well why this happens is to mostly due

42
00:01:27,920 --> 00:01:30,240
to branches or memory accesses based on

43
00:01:30,240 --> 00:01:32,640
these secret direct values so we would

44
00:01:32,640 --> 00:01:35,439
have a condition on a secret key bit

45
00:01:35,439 --> 00:01:37,360
encode or you would have

46
00:01:37,360 --> 00:01:39,280
memory access based on some secret there

47
00:01:39,280 --> 00:01:41,520
are values like in a

48
00:01:41,520 --> 00:01:44,159
in a table based a as implementation

49
00:01:44,159 --> 00:01:46,560
or you would have some sort of again a

50
00:01:46,560 --> 00:01:49,360
conditional jump like an uh and scalar

51
00:01:49,360 --> 00:01:51,360
multiplication and electric cryptography

52
00:01:51,360 --> 00:01:53,680
you would do a chunk based on a key bit

53
00:01:53,680 --> 00:01:56,000
but not only due to these two things

54
00:01:56,000 --> 00:01:58,799
that the attacker can can measure but

55
00:01:58,799 --> 00:02:00,560
also due to sometimes variable time

56
00:02:00,560 --> 00:02:02,799
instructions so certain architectures

57
00:02:02,799 --> 00:02:04,960
have instructions that take variable

58
00:02:04,960 --> 00:02:06,880
time depending on the data they are

59
00:02:06,880 --> 00:02:09,679
provided with uh and now very recently

60
00:02:09,679 --> 00:02:11,920
it was also been shown that uh the

61
00:02:11,920 --> 00:02:15,120
frequency scaling the basically the uh

62
00:02:15,120 --> 00:02:17,760
the way the the cpu that is being

63
00:02:17,760 --> 00:02:20,400
executing instructions uh how it changes

64
00:02:20,400 --> 00:02:22,720
its frequency based on based on

65
00:02:22,720 --> 00:02:24,640
some patterns in the data that are

66
00:02:24,640 --> 00:02:26,800
affected to its instructions that can

67
00:02:26,800 --> 00:02:28,160
also leak

68
00:02:28,160 --> 00:02:30,319
information on secrets because it

69
00:02:30,319 --> 00:02:32,879
changes the again the overall duration

70
00:02:32,879 --> 00:02:34,319
of some operation

71
00:02:34,319 --> 00:02:36,400
which the attacker can measure now

72
00:02:36,400 --> 00:02:38,480
what's interesting for for us or for me

73
00:02:38,480 --> 00:02:40,400
specifically about timing attacks is

74
00:02:40,400 --> 00:02:42,879
that they are still around uh with these

75
00:02:42,879 --> 00:02:46,080
recent examples some from 2020 a group

76
00:02:46,080 --> 00:02:49,680
of vulnerabilities in ecdsa signing and

77
00:02:49,680 --> 00:02:52,319
a smart card and several open source

78
00:02:52,319 --> 00:02:55,680
cryptographic libraries and in 2022 uh

79
00:02:55,680 --> 00:02:58,000
the heartbeat vulnerability which shown

80
00:02:58,000 --> 00:03:00,080
that this this frequency

81
00:03:00,080 --> 00:03:02,159
scaling leakage

82
00:03:02,159 --> 00:03:03,840
is also a thing that we need to worry

83
00:03:03,840 --> 00:03:05,599
about

84
00:03:05,599 --> 00:03:07,200
now luckily there's this thing called

85
00:03:07,200 --> 00:03:09,200
the constant time code practice

86
00:03:09,200 --> 00:03:10,959
where you can try and

87
00:03:10,959 --> 00:03:12,400
and

88
00:03:12,400 --> 00:03:14,159
structure your code in in such a way

89
00:03:14,159 --> 00:03:15,840
that you avoid these things that leak

90
00:03:15,840 --> 00:03:17,519
right you avoid branches or memory

91
00:03:17,519 --> 00:03:19,840
accesses based on secretory values you

92
00:03:19,840 --> 00:03:21,680
avoid these well known sort of variable

93
00:03:21,680 --> 00:03:24,239
instructions and you don't you don't

94
00:03:24,239 --> 00:03:27,280
deal with frequency leaks at this moment

95
00:03:27,280 --> 00:03:29,440
but let's just avoid these these main

96
00:03:29,440 --> 00:03:30,400
things

97
00:03:30,400 --> 00:03:33,200
this is an example of uh such a constant

98
00:03:33,200 --> 00:03:34,720
time code example

99
00:03:34,720 --> 00:03:37,200
uh taken from the from the bin secret

100
00:03:37,200 --> 00:03:41,280
paper so a paper from uh about a tool

101
00:03:41,280 --> 00:03:44,000
for verifying constant timeless and this

102
00:03:44,000 --> 00:03:45,760
example is it's a constant time select

103
00:03:45,760 --> 00:03:48,400
right so you have two uh 32-bit unsigned

104
00:03:48,400 --> 00:03:50,560
integers and you want to select in one

105
00:03:50,560 --> 00:03:52,480
selection bit and you want to select

106
00:03:52,480 --> 00:03:54,959
based on that bit a particular integer

107
00:03:54,959 --> 00:03:56,480
and you want to do it constant time

108
00:03:56,480 --> 00:03:58,480
because this bit might be

109
00:03:58,480 --> 00:04:00,480
might be a secret draft value

110
00:04:00,480 --> 00:04:02,640
now this looks uh this code looks nice

111
00:04:02,640 --> 00:04:04,480
and sort of constant time there are no

112
00:04:04,480 --> 00:04:05,599
branches

113
00:04:05,599 --> 00:04:07,280
uh and there's no obvious branches in

114
00:04:07,280 --> 00:04:09,439
this code uh and also there are no

115
00:04:09,439 --> 00:04:11,360
obvious sort of there are no memory

116
00:04:11,360 --> 00:04:13,680
accesses based on

117
00:04:13,680 --> 00:04:15,680
secret direct values

118
00:04:15,680 --> 00:04:18,399
so we should be fine right uh well

119
00:04:18,399 --> 00:04:20,639
if you compile this with uh at the

120
00:04:20,639 --> 00:04:23,120
latest latest clang and and you turn off

121
00:04:23,120 --> 00:04:25,919
optimization so you say optimizations to

122
00:04:25,919 --> 00:04:26,960
zero

123
00:04:26,960 --> 00:04:28,880
you get no conditional jumps the code is

124
00:04:28,880 --> 00:04:31,680
all right nothing bad happens however if

125
00:04:31,680 --> 00:04:33,440
you compile this with

126
00:04:33,440 --> 00:04:35,840
with optimizations turned on

127
00:04:35,840 --> 00:04:38,080
with a recent clang for for this

128
00:04:38,080 --> 00:04:40,639
architecture clangen inserts an

129
00:04:40,639 --> 00:04:42,720
unconditional jump and therefore leaks

130
00:04:42,720 --> 00:04:45,600
the value of this bit uh if you want to

131
00:04:45,600 --> 00:04:48,000
experience this yourself uh scan this qr

132
00:04:48,000 --> 00:04:49,199
code or

133
00:04:49,199 --> 00:04:51,440
there's there is a link there to to the

134
00:04:51,440 --> 00:04:53,680
godbolt compiler explorer

135
00:04:53,680 --> 00:04:55,360
where you will see this code compiled

136
00:04:55,360 --> 00:04:57,280
with these two configurations and you

137
00:04:57,280 --> 00:04:59,919
will see that one contains a jump

138
00:04:59,919 --> 00:05:02,080
based on this bit this is because the

139
00:05:02,080 --> 00:05:03,759
compiler is

140
00:05:03,759 --> 00:05:06,400
sort of intelligent and optimizes this

141
00:05:06,400 --> 00:05:08,400
and notices that what you're trying to

142
00:05:08,400 --> 00:05:09,840
do is just

143
00:05:09,840 --> 00:05:11,680
select one or the other

144
00:05:11,680 --> 00:05:14,240
integer and well obviously this jump is

145
00:05:14,240 --> 00:05:15,919
apparently faster

146
00:05:15,919 --> 00:05:17,520
so what this means is that we have to

147
00:05:17,520 --> 00:05:19,520
verify constant time as we cannot just

148
00:05:19,520 --> 00:05:21,440
rely on this code practice because code

149
00:05:21,440 --> 00:05:23,680
that looks constant time might not end

150
00:05:23,680 --> 00:05:25,520
up being constant time

151
00:05:25,520 --> 00:05:27,440
luckily there are these tools for

152
00:05:27,440 --> 00:05:29,919
verification of constant time-ness

153
00:05:29,919 --> 00:05:32,800
which can do just that right they verify

154
00:05:32,800 --> 00:05:34,080
at some level

155
00:05:34,080 --> 00:05:36,240
some property related to to constant

156
00:05:36,240 --> 00:05:38,880
time is related to the absence of of

157
00:05:38,880 --> 00:05:41,120
timing leaks now they work on very

158
00:05:41,120 --> 00:05:42,000
different

159
00:05:42,000 --> 00:05:43,039
targets

160
00:05:43,039 --> 00:05:45,360
some target the the c or the source

161
00:05:45,360 --> 00:05:48,479
level there is one tool that's for java

162
00:05:48,479 --> 00:05:50,720
so that's the source then

163
00:05:50,720 --> 00:05:53,440
or they target the the some intermediate

164
00:05:53,440 --> 00:05:56,720
representation something like ldm ir uh

165
00:05:56,720 --> 00:05:59,680
but i i bundle both of these together

166
00:05:59,680 --> 00:06:02,160
and what these have these have in common

167
00:06:02,160 --> 00:06:03,919
is that the analysis at the source level

168
00:06:03,919 --> 00:06:05,680
or the ir level is really nice you have

169
00:06:05,680 --> 00:06:07,360
all the information there

170
00:06:07,360 --> 00:06:09,039
however you have this issue that i've

171
00:06:09,039 --> 00:06:11,440
just shown you right uh where you have a

172
00:06:11,440 --> 00:06:13,520
code that supposedly constant time has

173
00:06:13,520 --> 00:06:16,240
no branches on

174
00:06:16,240 --> 00:06:18,240
secret direct values there's no memory

175
00:06:18,240 --> 00:06:20,400
accesses you know no sort of variable

176
00:06:20,400 --> 00:06:22,160
type instructions visible you don't have

177
00:06:22,160 --> 00:06:23,600
instructions on this point you just have

178
00:06:23,600 --> 00:06:26,560
the c code right but then uh with the

179
00:06:26,560 --> 00:06:28,400
compiler selection you actually get a

180
00:06:28,400 --> 00:06:30,880
leaking binary so so

181
00:06:30,880 --> 00:06:33,120
if this analysis happens at the c or

182
00:06:33,120 --> 00:06:35,919
sort of higher level this is still above

183
00:06:35,919 --> 00:06:37,600
where the

184
00:06:37,600 --> 00:06:39,520
optimizations could happen that during

185
00:06:39,520 --> 00:06:41,120
this this constant time looking code

186
00:06:41,120 --> 00:06:43,440
into non-constant time binary

187
00:06:43,440 --> 00:06:46,160
there are also other tools that uh

188
00:06:46,160 --> 00:06:48,000
that have a that have a domain-specific

189
00:06:48,000 --> 00:06:50,240
language uh in this case it's the fact

190
00:06:50,240 --> 00:06:53,680
tool uh which basically you write a code

191
00:06:53,680 --> 00:06:55,280
in this dom in specific language you

192
00:06:55,280 --> 00:06:57,039
annotate it somehow about what are your

193
00:06:57,039 --> 00:06:58,960
secrets and then there is a contrast

194
00:06:58,960 --> 00:07:01,199
formation uh that turns this into

195
00:07:01,199 --> 00:07:03,440
constant time code and then into a

196
00:07:03,440 --> 00:07:05,599
constant time binary however in that

197
00:07:05,599 --> 00:07:08,319
case you will you have to rewrite your

198
00:07:08,319 --> 00:07:10,160
cryptographic code in this specific

199
00:07:10,160 --> 00:07:11,280
language

200
00:07:11,280 --> 00:07:13,280
and there are also other tools for sort

201
00:07:13,280 --> 00:07:14,720
of

202
00:07:14,720 --> 00:07:17,039
generating uh constant time

203
00:07:17,039 --> 00:07:19,360
implementation of crypto but they often

204
00:07:19,360 --> 00:07:21,840
sort of go from uh that's this domain

205
00:07:21,840 --> 00:07:23,680
specific languages

206
00:07:23,680 --> 00:07:25,360
uh and also there are tools that work on

207
00:07:25,360 --> 00:07:27,440
the binary level right so so these you

208
00:07:27,440 --> 00:07:29,680
give them a binary and they somehow

209
00:07:29,680 --> 00:07:32,080
argue whether it's constant time or not

210
00:07:32,080 --> 00:07:33,520
perhaps this binary must have been

211
00:07:33,520 --> 00:07:36,080
created through uh some specific process

212
00:07:36,080 --> 00:07:38,720
but that really depends on the two

213
00:07:38,720 --> 00:07:40,240
uh and it still uses very different

214
00:07:40,240 --> 00:07:41,919
techniques right so

215
00:07:41,919 --> 00:07:44,720
uh quite a large part of these tools uh

216
00:07:44,720 --> 00:07:46,879
use techniques from from formal methods

217
00:07:46,879 --> 00:07:49,280
like uh symbolic execution

218
00:07:49,280 --> 00:07:51,599
uh and so really like uh like formal

219
00:07:51,599 --> 00:07:53,360
methods and then they provide sort of

220
00:07:53,360 --> 00:07:54,960
strong guarantees

221
00:07:54,960 --> 00:07:57,199
well if they finish and if the result is

222
00:07:57,199 --> 00:07:59,840
not unknown they tend to provide strong

223
00:07:59,840 --> 00:08:01,280
guarantees

224
00:08:01,280 --> 00:08:03,039
on the result like whether there is

225
00:08:03,039 --> 00:08:04,319
leakage or

226
00:08:04,319 --> 00:08:06,080
whether there is not

227
00:08:06,080 --> 00:08:08,400
then there are dynamic tools which

228
00:08:08,400 --> 00:08:10,080
usually like run

229
00:08:10,080 --> 00:08:11,840
the run the code with some

230
00:08:11,840 --> 00:08:14,479
instrumentation and then they observe uh

231
00:08:14,479 --> 00:08:16,240
the results of that instrumentation if

232
00:08:16,240 --> 00:08:18,560
there were any conditional jumps if

233
00:08:18,560 --> 00:08:21,199
there are any memory accesses and so on

234
00:08:21,199 --> 00:08:23,039
and finally there are tools based on

235
00:08:23,039 --> 00:08:25,360
statistics which basically run the tool

236
00:08:25,360 --> 00:08:27,520
with many different inputs and time it

237
00:08:27,520 --> 00:08:29,759
as an attacker would and see

238
00:08:29,759 --> 00:08:31,759
statistically if there are any sort of

239
00:08:31,759 --> 00:08:32,958
observable

240
00:08:32,958 --> 00:08:34,159
leaks

241
00:08:34,159 --> 00:08:36,719
you can find all of these tools and more

242
00:08:36,719 --> 00:08:38,640
in the future hopefully tutorials and

243
00:08:38,640 --> 00:08:41,120
guides installation scripts on this

244
00:08:41,120 --> 00:08:44,000
behind this qr code and and on this link

245
00:08:44,000 --> 00:08:47,040
uh where we will try to sort of

246
00:08:47,040 --> 00:08:50,160
um get get this get this info on these

247
00:08:50,160 --> 00:08:53,839
tools and and make these tools as usable

248
00:08:53,839 --> 00:08:55,839
as possible

249
00:08:55,839 --> 00:08:57,920
so right so i've just explained how we

250
00:08:57,920 --> 00:08:59,360
have this constant high code practice

251
00:08:59,360 --> 00:09:01,040
and even if that's not enough in

252
00:09:01,040 --> 00:09:02,720
presence of these these nefarious

253
00:09:02,720 --> 00:09:05,120
optimizing compilers we have these tools

254
00:09:05,120 --> 00:09:07,519
for verification of constant timers

255
00:09:07,519 --> 00:09:09,200
so timing attacks shouldn't really be a

256
00:09:09,200 --> 00:09:11,440
thing right like so why are timing

257
00:09:11,440 --> 00:09:13,360
attacks still ground

258
00:09:13,360 --> 00:09:15,440
uh is it that timing attacks are just

259
00:09:15,440 --> 00:09:16,959
not part of threat models of

260
00:09:16,959 --> 00:09:19,200
cryptographic libraries is it that the

261
00:09:19,200 --> 00:09:20,880
library developers do not know how to

262
00:09:20,880 --> 00:09:23,040
protect against timing attacks

263
00:09:23,040 --> 00:09:25,279
uh is that the developers are unaware of

264
00:09:25,279 --> 00:09:27,440
these tools that could help them or in

265
00:09:27,440 --> 00:09:29,360
general why are the tools not being used

266
00:09:29,360 --> 00:09:31,040
effectively

267
00:09:31,040 --> 00:09:32,560
and these are the questions that well

268
00:09:32,560 --> 00:09:34,839
let's just ask cryptographic library

269
00:09:34,839 --> 00:09:36,800
developers they are the ones that will

270
00:09:36,800 --> 00:09:38,560
know answers to these questions because

271
00:09:38,560 --> 00:09:40,480
they are the ones that would fix these

272
00:09:40,480 --> 00:09:41,920
timing links they are the ones that

273
00:09:41,920 --> 00:09:44,560
would use these tools for verifying

274
00:09:44,560 --> 00:09:46,160
resistance of code against timing

275
00:09:46,160 --> 00:09:47,440
attacks

276
00:09:47,440 --> 00:09:49,279
and this sounds like a great idea and

277
00:09:49,279 --> 00:09:51,440
it's exactly what we did

278
00:09:51,440 --> 00:09:54,160
so we decided to run a survey targeting

279
00:09:54,160 --> 00:09:56,000
open source cryptographic libraries and

280
00:09:56,000 --> 00:09:58,480
their developers we focused on the most

281
00:09:58,480 --> 00:10:00,800
active contributors using the number of

282
00:10:00,800 --> 00:10:02,079
comments

283
00:10:02,079 --> 00:10:04,000
in the end we invited more than 200

284
00:10:04,000 --> 00:10:07,760
developers from 36 libraries and we got

285
00:10:07,760 --> 00:10:11,760
44 vote responses from 27 libraries

286
00:10:11,760 --> 00:10:13,760
for the rest of this talk i will denote

287
00:10:13,760 --> 00:10:16,320
the participants with this person symbol

288
00:10:16,320 --> 00:10:18,720
and the library is participating with

289
00:10:18,720 --> 00:10:20,640
this book symbol

290
00:10:20,640 --> 00:10:22,240
and i must say that this participation

291
00:10:22,240 --> 00:10:24,160
rate is really great and we're really

292
00:10:24,160 --> 00:10:26,320
thankful for our participants because

293
00:10:26,320 --> 00:10:28,240
without them these libraries wouldn't

294
00:10:28,240 --> 00:10:30,839
exist and our research wouldn't exist as

295
00:10:30,839 --> 00:10:33,920
well so we've got many uh popular

296
00:10:33,920 --> 00:10:37,600
libraries such as open ssl libre ssl uh

297
00:10:37,600 --> 00:10:40,320
libgi crypt even some rust ones or

298
00:10:40,320 --> 00:10:43,040
amazon s2m and from these libraries we

299
00:10:43,040 --> 00:10:45,680
feel like we've got d developers that we

300
00:10:45,680 --> 00:10:48,240
wanted to ask so we've got a lot of core

301
00:10:48,240 --> 00:10:50,880
developers maintainers committers we've

302
00:10:50,880 --> 00:10:53,760
got we've got the people that can make

303
00:10:53,760 --> 00:10:55,600
the decisions that influence how these

304
00:10:55,600 --> 00:10:57,279
libraries are developed

305
00:10:57,279 --> 00:10:59,519
and what their posture towards timing

306
00:10:59,519 --> 00:11:02,000
your taxes and if they get fixed and so

307
00:11:02,000 --> 00:11:03,519
on

308
00:11:03,519 --> 00:11:05,760
in our survey we first asked about the

309
00:11:05,760 --> 00:11:07,440
party silicon background uh their

310
00:11:07,440 --> 00:11:09,120
background in cryptography experience

311
00:11:09,120 --> 00:11:11,040
developing cryptographic code and this

312
00:11:11,040 --> 00:11:14,320
this academic slash industry split

313
00:11:14,320 --> 00:11:16,720
next we focused on the library and the

314
00:11:16,720 --> 00:11:18,880
participants role in that library so we

315
00:11:18,880 --> 00:11:20,560
asked them about it about their role

316
00:11:20,560 --> 00:11:22,560
whether they are sort of this commenter

317
00:11:22,560 --> 00:11:24,720
developer and so on and then how the

318
00:11:24,720 --> 00:11:26,720
library makes design decisions uh

319
00:11:26,720 --> 00:11:28,480
whether there is boating or whether

320
00:11:28,480 --> 00:11:31,200
there is some sort of a formal process

321
00:11:31,200 --> 00:11:32,880
next we focused on the library's threat

322
00:11:32,880 --> 00:11:35,040
model with respect to situations

323
00:11:35,040 --> 00:11:37,839
specifically asking about timing attacks

324
00:11:37,839 --> 00:11:39,360
then we asked about timing attack

325
00:11:39,360 --> 00:11:41,120
protections in the library whether there

326
00:11:41,120 --> 00:11:44,000
are any uh and if so which and how were

327
00:11:44,000 --> 00:11:46,000
they introduced

328
00:11:46,000 --> 00:11:48,320
and and finally we asked about whether

329
00:11:48,320 --> 00:11:50,240
there is there is any testing of diamond

330
00:11:50,240 --> 00:11:52,320
attack resistance in the library

331
00:11:52,320 --> 00:11:54,320
and if so how that is done and how or

332
00:11:54,320 --> 00:11:56,399
how often

333
00:11:56,399 --> 00:11:58,160
then we focused on the on the tools and

334
00:11:58,160 --> 00:12:00,000
participants awareness of these tools

335
00:12:00,000 --> 00:12:01,680
for verifying resistance of coding and

336
00:12:01,680 --> 00:12:04,160
stemming attacks uh then we asked about

337
00:12:04,160 --> 00:12:06,079
how they learned about them if they knew

338
00:12:06,079 --> 00:12:07,760
about some of these tools

339
00:12:07,760 --> 00:12:10,000
and we also asked them about experience

340
00:12:10,000 --> 00:12:12,959
using these tools to sort of tell us uh

341
00:12:12,959 --> 00:12:14,000
tell us

342
00:12:14,000 --> 00:12:16,320
how to use these tools

343
00:12:16,320 --> 00:12:19,279
but we suspected that a large part of

344
00:12:19,279 --> 00:12:21,040
our participants wouldn't have

345
00:12:21,040 --> 00:12:22,639
experience using these tools or would

346
00:12:22,639 --> 00:12:24,480
not even know these tools

347
00:12:24,480 --> 00:12:26,399
but we still wanted to get their opinion

348
00:12:26,399 --> 00:12:28,560
so we presented them with properties of

349
00:12:28,560 --> 00:12:30,720
three distinct groups of tools these

350
00:12:30,720 --> 00:12:32,320
groups were dynamic instrumentation

351
00:12:32,320 --> 00:12:34,160
based statistical runtime tests and

352
00:12:34,160 --> 00:12:36,320
formal analysis tools

353
00:12:36,320 --> 00:12:37,760
and the properties we shown them were

354
00:12:37,760 --> 00:12:40,079
basically the requirements of the code

355
00:12:40,079 --> 00:12:41,519
that the tools

356
00:12:41,519 --> 00:12:42,399
need to

357
00:12:42,399 --> 00:12:43,680
need to run

358
00:12:43,680 --> 00:12:46,079
and also the guarantees on the results

359
00:12:46,079 --> 00:12:48,480
that the tool give you

360
00:12:48,480 --> 00:12:50,399
and these these groups of tools are very

361
00:12:50,399 --> 00:12:52,079
different in these in these aspects in

362
00:12:52,079 --> 00:12:54,079
these properties where formal analysis

363
00:12:54,079 --> 00:12:56,320
tools give you great guarantees but also

364
00:12:56,320 --> 00:12:58,480
require kind of lots of annotations on

365
00:12:58,480 --> 00:13:00,720
your code sometimes you require things

366
00:13:00,720 --> 00:13:04,000
like uh like proving loop bounds or or

367
00:13:04,000 --> 00:13:05,040
sort of

368
00:13:05,040 --> 00:13:07,279
have various limitations on on what they

369
00:13:07,279 --> 00:13:08,480
can run

370
00:13:08,480 --> 00:13:10,560
whereas for example statistical runtimes

371
00:13:10,560 --> 00:13:12,399
have very little limitations but also

372
00:13:12,399 --> 00:13:15,440
the guarantees they give you are

373
00:13:15,440 --> 00:13:16,320
are

374
00:13:16,320 --> 00:13:18,800
quite weak are statistical

375
00:13:18,800 --> 00:13:20,800
and might just not catch some leaks that

376
00:13:20,800 --> 00:13:22,959
are that are way too small but still

377
00:13:22,959 --> 00:13:24,639
might be exploitable

378
00:13:24,639 --> 00:13:26,000
and then we asked

379
00:13:26,000 --> 00:13:28,240
our participants about likeliness of use

380
00:13:28,240 --> 00:13:30,240
of these three groups of tools and their

381
00:13:30,240 --> 00:13:32,240
reasoning behind them basically

382
00:13:32,240 --> 00:13:34,160
hypothetically whether they were likely

383
00:13:34,160 --> 00:13:36,720
to use these tombs

384
00:13:36,720 --> 00:13:38,639
and finally we asked our participants

385
00:13:38,639 --> 00:13:40,880
about general thoughts on timing attacks

386
00:13:40,880 --> 00:13:43,120
and on our survey and i must say that

387
00:13:43,120 --> 00:13:46,000
most participants liked our survey

388
00:13:46,000 --> 00:13:47,279
and wanted to

389
00:13:47,279 --> 00:13:49,600
get involved more in the sort of sort of

390
00:13:49,600 --> 00:13:52,480
research and in timing attacks uh which

391
00:13:52,480 --> 00:13:54,560
which made us really happy

392
00:13:54,560 --> 00:13:56,639
now let's get into the results

393
00:13:56,639 --> 00:13:58,959
luckily we found out that developers

394
00:13:58,959 --> 00:14:00,880
know about timing attacks a hundred

395
00:14:00,880 --> 00:14:02,639
percent of our sample knew about timing

396
00:14:02,639 --> 00:14:05,600
attacks though their opinions varied uh

397
00:14:05,600 --> 00:14:07,040
starting from this point hold it that

398
00:14:07,040 --> 00:14:09,519
ended up being in the title of our paper

399
00:14:09,519 --> 00:14:11,920
that timing attacks are not that hard to

400
00:14:11,920 --> 00:14:14,240
mitigate at least with the compilers

401
00:14:14,240 --> 00:14:17,040
this participant is using right now now

402
00:14:17,040 --> 00:14:18,240
i would like to know what these

403
00:14:18,240 --> 00:14:20,560
compilers are and and to know more uh

404
00:14:20,560 --> 00:14:23,760
details about the process of this person

405
00:14:23,760 --> 00:14:26,399
uh sadly that was that was not there

406
00:14:26,399 --> 00:14:29,519
uh but there was this there was this

407
00:14:29,519 --> 00:14:32,320
sort of spectrum of of opinions ranging

408
00:14:32,320 --> 00:14:33,279
from

409
00:14:33,279 --> 00:14:35,360
uh from this strict view on timing

410
00:14:35,360 --> 00:14:37,199
attacks that is totally obvious for

411
00:14:37,199 --> 00:14:38,959
everybody right from the start that

412
00:14:38,959 --> 00:14:41,120
predictions against timing attacks is

413
00:14:41,120 --> 00:14:43,440
necessary to this more skeptical view

414
00:14:43,440 --> 00:14:45,279
that for many cases there aren't enough

415
00:14:45,279 --> 00:14:47,519
real world attacks to justify spending

416
00:14:47,519 --> 00:14:50,079
time on preventing timing links

417
00:14:50,079 --> 00:14:54,000
now however these opinions varied

418
00:14:54,000 --> 00:14:56,480
most libraries considered timing attacks

419
00:14:56,480 --> 00:14:57,279
a

420
00:14:57,279 --> 00:15:00,160
threat in their thread model so 23

421
00:15:00,160 --> 00:15:01,920
libraries did include timing attacks and

422
00:15:01,920 --> 00:15:04,480
their framework two did not include

423
00:15:04,480 --> 00:15:05,920
however these libraries often

424
00:15:05,920 --> 00:15:08,320
differentiated between local remote

425
00:15:08,320 --> 00:15:11,279
attacks with 20 including remote attacks

426
00:15:11,279 --> 00:15:13,519
and 16 including local

427
00:15:13,519 --> 00:15:17,199
um specifically they differentiated

428
00:15:17,199 --> 00:15:19,600
using wording like remote observation is

429
00:15:19,600 --> 00:15:21,839
obviously a bigger issue they gave a

430
00:15:21,839 --> 00:15:24,480
larger priority to remote timing attacks

431
00:15:24,480 --> 00:15:26,480
things that are exploitable over the

432
00:15:26,480 --> 00:15:27,519
network

433
00:15:27,519 --> 00:15:30,320
and and they give less priority to to

434
00:15:30,320 --> 00:15:31,920
sort of local attacks

435
00:15:31,920 --> 00:15:33,839
attacks where you really need the cash

436
00:15:33,839 --> 00:15:36,800
access or or very high precision uh

437
00:15:36,800 --> 00:15:38,560
timings

438
00:15:38,560 --> 00:15:40,399
however their reasoning for

439
00:15:40,399 --> 00:15:42,160
including these uh

440
00:15:42,160 --> 00:15:43,519
these timing attacks are threatening

441
00:15:43,519 --> 00:15:46,000
their fear model uh varied with some

442
00:15:46,000 --> 00:15:48,079
general that timing attacks are relevant

443
00:15:48,079 --> 00:15:49,920
threat because they are through some

444
00:15:49,920 --> 00:15:52,160
more specific uh

445
00:15:52,160 --> 00:15:54,480
telling us about loss of reputation for

446
00:15:54,480 --> 00:15:56,480
example it is never found to be a bug

447
00:15:56,480 --> 00:15:58,240
that a new research paper is talking

448
00:15:58,240 --> 00:16:00,720
about exploiting and some argue that the

449
00:16:00,720 --> 00:16:02,639
target environment of the library is

450
00:16:02,639 --> 00:16:04,800
such that it's exposed to timing attacks

451
00:16:04,800 --> 00:16:08,560
and thus needs to be protected

452
00:16:08,560 --> 00:16:10,880
now even though this

453
00:16:10,880 --> 00:16:12,320
most considered

454
00:16:12,320 --> 00:16:13,600
timing attacks are threatening their

455
00:16:13,600 --> 00:16:15,040
terminal

456
00:16:15,040 --> 00:16:15,839
the

457
00:16:15,839 --> 00:16:18,079
claiming resistance uh

458
00:16:18,079 --> 00:16:20,800
about timing attacks only 13 libraries

459
00:16:20,800 --> 00:16:22,639
cranes full resistance against timing

460
00:16:22,639 --> 00:16:23,680
attacks

461
00:16:23,680 --> 00:16:26,800
but this this this 13 libraries are uh

462
00:16:26,800 --> 00:16:28,800
let's say quite confident in that

463
00:16:28,800 --> 00:16:30,480
uh because for me claiming full

464
00:16:30,480 --> 00:16:32,399
resistance again timing attacks in in

465
00:16:32,399 --> 00:16:34,959
the current let's say knowledge about

466
00:16:34,959 --> 00:16:37,279
what timing index can do and how hard it

467
00:16:37,279 --> 00:16:40,000
is to to protect all the possible sort

468
00:16:40,000 --> 00:16:40,639
of

469
00:16:40,639 --> 00:16:42,560
for all the possible architectures and

470
00:16:42,560 --> 00:16:45,199
implementation configurations and so on

471
00:16:45,199 --> 00:16:46,399
um

472
00:16:46,399 --> 00:16:47,920
to be fully protected against stemming

473
00:16:47,920 --> 00:16:50,720
attacks it's a pretty bold claim however

474
00:16:50,720 --> 00:16:52,079
10 libraries said that they are

475
00:16:52,079 --> 00:16:53,839
partially particularly in stemming

476
00:16:53,839 --> 00:16:54,880
attacks

477
00:16:54,880 --> 00:16:57,120
uh this this partially might however be

478
00:16:57,120 --> 00:16:58,880
sort of an issue from a from a user's

479
00:16:58,880 --> 00:17:00,000
perspective

480
00:17:00,000 --> 00:17:01,759
if you're using a library cryptographic

481
00:17:01,759 --> 00:17:03,120
library that's partially protected

482
00:17:03,120 --> 00:17:05,199
against timing attacks how do you know

483
00:17:05,199 --> 00:17:07,280
which parts that library are protected

484
00:17:07,280 --> 00:17:08,640
and which aren't

485
00:17:08,640 --> 00:17:11,439
uh such that you if you want to use just

486
00:17:11,439 --> 00:17:13,599
just protected parts how you go about

487
00:17:13,599 --> 00:17:15,280
that whether that's something that's

488
00:17:15,280 --> 00:17:16,959
documented whether it's something that

489
00:17:16,959 --> 00:17:19,359
you can sort of enable and what are the

490
00:17:19,359 --> 00:17:21,599
defaults you know if it's enabled or

491
00:17:21,599 --> 00:17:23,679
disabled by default

492
00:17:23,679 --> 00:17:24,799
now

493
00:17:24,799 --> 00:17:27,199
there was also this strong opinion uh

494
00:17:27,199 --> 00:17:28,960
shown that this is just how you write

495
00:17:28,960 --> 00:17:30,640
cryptographic code every other way is

496
00:17:30,640 --> 00:17:32,960
the wrong approach the code should just

497
00:17:32,960 --> 00:17:35,360
be resistant against timing attack

498
00:17:35,360 --> 00:17:37,280
i know surprisingly three libraries

499
00:17:37,280 --> 00:17:39,280
claimed no resistance against timing

500
00:17:39,280 --> 00:17:41,039
attacks

501
00:17:41,039 --> 00:17:43,039
now these libraries are shown various

502
00:17:43,039 --> 00:17:45,840
protection techniques with most choosing

503
00:17:45,840 --> 00:17:47,520
the com what we call the constantine

504
00:17:47,520 --> 00:17:49,120
chord practice what i've described at

505
00:17:49,120 --> 00:17:51,360
the start that conditional branches and

506
00:17:51,360 --> 00:17:53,840
lookups are avoided on secrets

507
00:17:53,840 --> 00:17:56,400
and and sort of with the addition of

508
00:17:56,400 --> 00:17:58,640
some more tricks like uh assembly code

509
00:17:58,640 --> 00:18:01,360
and common tricks which are there to

510
00:18:01,360 --> 00:18:02,880
hope to to prevent compiler

511
00:18:02,880 --> 00:18:04,480
optimizations

512
00:18:04,480 --> 00:18:06,640
however as the the pin segregate paper

513
00:18:06,640 --> 00:18:08,160
has shown

514
00:18:08,160 --> 00:18:10,400
and the tool has shown that well yes

515
00:18:10,400 --> 00:18:12,960
these compilers are

516
00:18:12,960 --> 00:18:14,559
are optimizing are there and they are

517
00:18:14,559 --> 00:18:16,400
quite nefarious with that and they will

518
00:18:16,400 --> 00:18:18,960
sometimes turn constant time looking

519
00:18:18,960 --> 00:18:21,600
code into non-constant type code perhaps

520
00:18:21,600 --> 00:18:23,840
even with these common tricks

521
00:18:23,840 --> 00:18:26,880
so 9 libraries reported using a constant

522
00:18:26,880 --> 00:18:28,880
time algorithm sometimes sometimes there

523
00:18:28,880 --> 00:18:31,039
is a well-known algorithm for something

524
00:18:31,039 --> 00:18:32,000
like

525
00:18:32,000 --> 00:18:34,000
scalar multiplication on the olympic

526
00:18:34,000 --> 00:18:36,080
curve there is the montgomery ladder

527
00:18:36,080 --> 00:18:37,679
which is a well-known constant time

528
00:18:37,679 --> 00:18:38,799
algorithm

529
00:18:38,799 --> 00:18:40,320
and there are other various techniques

530
00:18:40,320 --> 00:18:43,120
reported like blinding slicing assembly

531
00:18:43,120 --> 00:18:46,080
or hardware features like asni and one

532
00:18:46,080 --> 00:18:46,799
more

533
00:18:46,799 --> 00:18:48,240
protection technique that i would like

534
00:18:48,240 --> 00:18:51,120
to point out is our random delays where

535
00:18:51,120 --> 00:18:53,520
one particular library

536
00:18:53,520 --> 00:18:54,720
sort of

537
00:18:54,720 --> 00:18:56,640
expressed that they use random delays in

538
00:18:56,640 --> 00:18:57,440
there

539
00:18:57,440 --> 00:18:59,600
uh in their code as a counter measure

540
00:18:59,600 --> 00:19:01,280
against timing attacks and i must say

541
00:19:01,280 --> 00:19:02,559
that this

542
00:19:02,559 --> 00:19:05,520
is really not a good counter measure uh

543
00:19:05,520 --> 00:19:07,919
with enough samples you can average out

544
00:19:07,919 --> 00:19:09,679
those random delays or perhaps with

545
00:19:09,679 --> 00:19:11,200
local attacks

546
00:19:11,200 --> 00:19:12,880
on the cache you really don't care about

547
00:19:12,880 --> 00:19:15,440
these random delays because you are

548
00:19:15,440 --> 00:19:17,200
you're attacking a different thing so so

549
00:19:17,200 --> 00:19:19,919
i suggest to anyone to to go and try to

550
00:19:19,919 --> 00:19:21,919
find which library it is and perhaps get

551
00:19:21,919 --> 00:19:23,679
an attack or two

552
00:19:23,679 --> 00:19:25,760
on this library with this particular

553
00:19:25,760 --> 00:19:27,520
countermeasure

554
00:19:27,520 --> 00:19:30,000
now let's let's move on to the tools uh

555
00:19:30,000 --> 00:19:31,679
tools for verifying resistance of code

556
00:19:31,679 --> 00:19:32,960
against timing attacks and the

557
00:19:32,960 --> 00:19:36,720
developers knowledge and views on those

558
00:19:36,720 --> 00:19:39,360
what is nice is that 33 developers or

559
00:19:39,360 --> 00:19:41,440
participants heard of at least one two

560
00:19:41,440 --> 00:19:43,360
uh the most well-known tools were ct

561
00:19:43,360 --> 00:19:45,520
grants ct verified memsan

562
00:19:45,520 --> 00:19:48,000
um and and cd garden was so well known

563
00:19:48,000 --> 00:19:49,120
of that or

564
00:19:49,120 --> 00:19:50,400
so simple

565
00:19:50,400 --> 00:19:52,720
uh that some developers independently

566
00:19:52,720 --> 00:19:54,960
came up with the approach and were using

567
00:19:54,960 --> 00:19:56,880
the this ct grant approach before they

568
00:19:56,880 --> 00:19:59,039
knew the tool even existed

569
00:19:59,039 --> 00:20:01,600
so to explain cg grind is really

570
00:20:01,600 --> 00:20:05,600
a a use case of wall grant uh

571
00:20:05,600 --> 00:20:07,360
the tool or let's say the mem check

572
00:20:07,360 --> 00:20:11,199
component of wall grinds the tool

573
00:20:11,360 --> 00:20:14,320
in which you sort of you mark

574
00:20:14,320 --> 00:20:16,400
you mark areas of memory that you

575
00:20:16,400 --> 00:20:17,840
consider secret you mark them

576
00:20:17,840 --> 00:20:20,400
uninitialized and then what wall grind

577
00:20:20,400 --> 00:20:22,880
will do is that during execution wall

578
00:20:22,880 --> 00:20:24,400
grind will trace

579
00:20:24,400 --> 00:20:26,640
how these uninitialized areas of memory

580
00:20:26,640 --> 00:20:28,960
affect other uh certain secret other

581
00:20:28,960 --> 00:20:31,360
derived values right

582
00:20:31,360 --> 00:20:32,559
and this

583
00:20:32,559 --> 00:20:34,400
through this process of shadowing

584
00:20:34,400 --> 00:20:37,200
and if you ever do a conditional jump or

585
00:20:37,200 --> 00:20:38,640
a memory access based on an

586
00:20:38,640 --> 00:20:41,200
uninitialized value uh wallgrind will

587
00:20:41,200 --> 00:20:43,280
tell you that you are doing so justice

588
00:20:43,280 --> 00:20:45,280
just as you do that so you can use all

589
00:20:45,280 --> 00:20:46,159
grind

590
00:20:46,159 --> 00:20:49,120
uh to warn you about conditional jumps

591
00:20:49,120 --> 00:20:52,159
and memory access is based on uh based

592
00:20:52,159 --> 00:20:54,240
on uninitialized values but if you mark

593
00:20:54,240 --> 00:20:56,640
your secrets uninitialized then you can

594
00:20:56,640 --> 00:20:59,200
do so based on secret values

595
00:20:59,200 --> 00:21:00,799
however the most

596
00:21:00,799 --> 00:21:02,799
important result here and on this slide

597
00:21:02,799 --> 00:21:06,480
is that most of these tools were unknown

598
00:21:06,480 --> 00:21:08,159
meaning that apart from these three that

599
00:21:08,159 --> 00:21:09,360
i've shown

600
00:21:09,360 --> 00:21:11,760
out of the 25 that we asked about only

601
00:21:11,760 --> 00:21:14,320
one more tool was known by two people

602
00:21:14,320 --> 00:21:16,559
and the rest were known by one or zero

603
00:21:16,559 --> 00:21:18,000
people

604
00:21:18,000 --> 00:21:20,480
now it is really hard for a tool to be

605
00:21:20,480 --> 00:21:24,080
used or useful to these developers if it

606
00:21:24,080 --> 00:21:26,880
is completely unknown

607
00:21:26,880 --> 00:21:28,880
no one will use a tool if they do not

608
00:21:28,880 --> 00:21:30,960
know about it

609
00:21:30,960 --> 00:21:33,760
and that is somewhat reflected in this

610
00:21:33,760 --> 00:21:36,559
uh in these results where only 19 tried

611
00:21:36,559 --> 00:21:39,679
to use these tools out of the 33

612
00:21:39,679 --> 00:21:42,400
uh but most reported that lack of time

613
00:21:42,400 --> 00:21:44,480
was was the issue that

614
00:21:44,480 --> 00:21:45,840
that they had with the tool they just

615
00:21:45,840 --> 00:21:48,159
didn't have time or or there wasn't

616
00:21:48,159 --> 00:21:50,080
enough priority to for them to use the

617
00:21:50,080 --> 00:21:51,520
tool

618
00:21:51,520 --> 00:21:53,200
to to

619
00:21:53,200 --> 00:21:55,919
to detect possible timing links other

620
00:21:55,919 --> 00:21:57,440
issues that were reported was the

621
00:21:57,440 --> 00:21:59,679
inability of the tool to ignore known

622
00:21:59,679 --> 00:22:02,400
issues so let's say you have a known but

623
00:22:02,400 --> 00:22:05,200
sort of benign leakage in your code

624
00:22:05,200 --> 00:22:06,720
and you want to just ignore that for the

625
00:22:06,720 --> 00:22:08,400
time moment because handling that would

626
00:22:08,400 --> 00:22:10,640
be too expensive but you just want to

627
00:22:10,640 --> 00:22:12,720
sort of analyze these other parts of the

628
00:22:12,720 --> 00:22:15,120
code so some tools cannot properly do

629
00:22:15,120 --> 00:22:16,080
that

630
00:22:16,080 --> 00:22:18,320
and that was what the participants

631
00:22:18,320 --> 00:22:21,280
complained about but also uh it's hard

632
00:22:21,280 --> 00:22:23,360
to use to if it's not maintained you

633
00:22:23,360 --> 00:22:25,360
know where will it be in five years will

634
00:22:25,360 --> 00:22:27,679
it still run still sort of give valid

635
00:22:27,679 --> 00:22:29,840
results and it's really really hard to

636
00:22:29,840 --> 00:22:32,080
use a tool if it's just completely not

637
00:22:32,080 --> 00:22:34,480
available

638
00:22:34,480 --> 00:22:36,640
now that some of the participants are

639
00:22:36,640 --> 00:22:39,120
just outright unlikely to use

640
00:22:39,120 --> 00:22:41,120
some of the tools

641
00:22:41,120 --> 00:22:43,280
when we asked the participants about

642
00:22:43,280 --> 00:22:45,120
their likeliness of use of these three

643
00:22:45,120 --> 00:22:46,880
groups of tools the formal analysis

644
00:22:46,880 --> 00:22:49,280
tools the statistical runtime tests and

645
00:22:49,280 --> 00:22:51,760
the dynamic instrumentation tools based

646
00:22:51,760 --> 00:22:53,840
on our description of what the tools

647
00:22:53,840 --> 00:22:55,919
need to need to run

648
00:22:55,919 --> 00:22:58,000
on the codes the requirements they have

649
00:22:58,000 --> 00:22:59,840
and the sort of level of guarantees that

650
00:22:59,840 --> 00:23:02,400
they provide

651
00:23:02,400 --> 00:23:04,640
we figured out that participants

652
00:23:04,640 --> 00:23:06,720
perceived formal analysis tools as way

653
00:23:06,720 --> 00:23:09,440
too much effort as this one quote puts

654
00:23:09,440 --> 00:23:10,159
it

655
00:23:10,159 --> 00:23:12,240
formal analysis tools are not really

656
00:23:12,240 --> 00:23:15,039
usable by mere mortals yet

657
00:23:15,039 --> 00:23:16,880
whereas for dynamic and statistical

658
00:23:16,880 --> 00:23:19,360
tools participants

659
00:23:19,360 --> 00:23:21,120
saw them as an acceptable trade-off

660
00:23:21,120 --> 00:23:24,559
between effort and guarantees

661
00:23:24,559 --> 00:23:26,559
so with that we've we've identified this

662
00:23:26,559 --> 00:23:28,799
leaky pipeline of developers trying to

663
00:23:28,799 --> 00:23:31,200
use these tools to verify constant

664
00:23:31,200 --> 00:23:33,360
timeless of their code with 44

665
00:23:33,360 --> 00:23:35,520
developers entering and only 17

666
00:23:35,520 --> 00:23:37,440
developers meaningfully using these

667
00:23:37,440 --> 00:23:39,200
tools too to verify the constant

668
00:23:39,200 --> 00:23:41,919
tightness of their cryptographic code

669
00:23:41,919 --> 00:23:43,600
and if you went further

670
00:23:43,600 --> 00:23:44,880
and looked at how many of these

671
00:23:44,880 --> 00:23:47,279
developers use this code in an automated

672
00:23:47,279 --> 00:23:50,480
manner in ci cd in in a sort of complete

673
00:23:50,480 --> 00:23:52,400
way for for the whole

674
00:23:52,400 --> 00:23:54,559
whole aspects of the library such that

675
00:23:54,559 --> 00:23:57,440
if there was uh a new uh new issue that

676
00:23:57,440 --> 00:24:00,159
was introduced it will be caught in time

677
00:24:00,159 --> 00:24:02,240
uh we would get an even lower number

678
00:24:02,240 --> 00:24:04,799
perhaps in the single digits

679
00:24:04,799 --> 00:24:06,799
so what can we do about this what can be

680
00:24:06,799 --> 00:24:07,679
things

681
00:24:07,679 --> 00:24:10,240
well the tool developers should make the

682
00:24:10,240 --> 00:24:12,880
tools more usable the tools first of all

683
00:24:12,880 --> 00:24:14,480
need to be available

684
00:24:14,480 --> 00:24:16,240
uh need to be available somewhere there

685
00:24:16,240 --> 00:24:17,919
need to be source code releases for

686
00:24:17,919 --> 00:24:19,200
these tools

687
00:24:19,200 --> 00:24:21,279
uh it happens way too often that there

688
00:24:21,279 --> 00:24:23,679
is a paper about tool that's that's

689
00:24:23,679 --> 00:24:25,600
published it even gives a name to the

690
00:24:25,600 --> 00:24:26,559
tool

691
00:24:26,559 --> 00:24:28,799
uh but then never releases search card

692
00:24:28,799 --> 00:24:31,120
for the tool it just never ends up ends

693
00:24:31,120 --> 00:24:33,840
up anywhere and no one can ever use it

694
00:24:33,840 --> 00:24:35,679
the tools needs to be on top of that

695
00:24:35,679 --> 00:24:38,240
needs to be easy to install there needs

696
00:24:38,240 --> 00:24:41,200
to be documentation examples and things

697
00:24:41,200 --> 00:24:43,440
of that sort otherwise

698
00:24:43,440 --> 00:24:45,200
the developers will not use these tools

699
00:24:45,200 --> 00:24:48,640
and it's too much time and too confusing

700
00:24:48,640 --> 00:24:50,320
the tools also need to be promoted at

701
00:24:50,320 --> 00:24:52,240
the pre-appropriate venues

702
00:24:52,240 --> 00:24:54,720
so so as we've seen not many developers

703
00:24:54,720 --> 00:24:56,559
really know about

704
00:24:56,559 --> 00:24:58,480
all of the tools that are possible some

705
00:24:58,480 --> 00:25:00,720
tools that might fit their fit their use

706
00:25:00,720 --> 00:25:03,200
case so they need to be promoted where

707
00:25:03,200 --> 00:25:04,400
possible

708
00:25:04,400 --> 00:25:06,240
the cryptographic library developers

709
00:25:06,240 --> 00:25:08,320
should use these tools ideally in an

710
00:25:08,320 --> 00:25:10,000
automated way

711
00:25:10,000 --> 00:25:12,480
ideally included in ci such that any

712
00:25:12,480 --> 00:25:14,960
changes in the codes that include that

713
00:25:14,960 --> 00:25:17,360
introduce an issue are automatically

714
00:25:17,360 --> 00:25:20,240
detected and can be handled

715
00:25:20,240 --> 00:25:22,000
uh developers should also try to

716
00:25:22,000 --> 00:25:24,480
eliminate all timing leaks no matter how

717
00:25:24,480 --> 00:25:26,720
small they might seem as as

718
00:25:26,720 --> 00:25:28,960
the attacks can get better and a leak

719
00:25:28,960 --> 00:25:30,720
that might seem benign can get to be

720
00:25:30,720 --> 00:25:33,279
exploitable in in just in just a few

721
00:25:33,279 --> 00:25:34,480
steps

722
00:25:34,480 --> 00:25:36,240
and also developers

723
00:25:36,240 --> 00:25:39,360
should strive to mark secrets in code

724
00:25:39,360 --> 00:25:41,039
because this is helpful for a lot of the

725
00:25:41,039 --> 00:25:42,480
tools that require this sort of

726
00:25:42,480 --> 00:25:44,880
annotation but also for the for the

727
00:25:44,880 --> 00:25:46,559
users of the library to know what is

728
00:25:46,559 --> 00:25:49,279
secret and what is not

729
00:25:49,279 --> 00:25:51,440
now compiler writers

730
00:25:51,440 --> 00:25:54,320
should add support for secret types

731
00:25:54,320 --> 00:25:56,480
and then do not introduce these these

732
00:25:56,480 --> 00:25:58,159
timing leaks or do not perform

733
00:25:58,159 --> 00:25:59,840
optimizations that might introduce

734
00:25:59,840 --> 00:26:02,960
timing leaks based on these secret types

735
00:26:02,960 --> 00:26:04,960
but in general we think that

736
00:26:04,960 --> 00:26:07,039
that asking for secret types is a sort

737
00:26:07,039 --> 00:26:08,640
of a big ask

738
00:26:08,640 --> 00:26:11,279
but then uh the the sort of first step

739
00:26:11,279 --> 00:26:13,760
towards that is to give more control to

740
00:26:13,760 --> 00:26:15,919
the developers um

741
00:26:15,919 --> 00:26:18,000
to stop introduction of timing these so

742
00:26:18,000 --> 00:26:20,240
more control over the compiler and over

743
00:26:20,240 --> 00:26:22,720
uh over some of its optimization parts

744
00:26:22,720 --> 00:26:25,360
at some points to to make sure that code

745
00:26:25,360 --> 00:26:27,360
that really needs to be constant time

746
00:26:27,360 --> 00:26:29,200
stays constant time even as it's

747
00:26:29,200 --> 00:26:31,760
optimized or compact

748
00:26:31,760 --> 00:26:34,080
and finally standardization bodies

749
00:26:34,080 --> 00:26:36,320
uh so for example nest in the case of

750
00:26:36,320 --> 00:26:38,640
the post quantum

751
00:26:38,640 --> 00:26:41,120
competition these standardization bodies

752
00:26:41,120 --> 00:26:43,279
should encourage submitters to use these

753
00:26:43,279 --> 00:26:44,480
tools

754
00:26:44,480 --> 00:26:46,880
to detect potential timing leaks in

755
00:26:46,880 --> 00:26:48,960
their code and we feel like this

756
00:26:48,960 --> 00:26:50,960
standardization model should require a

757
00:26:50,960 --> 00:26:53,760
constant tank code just outright for all

758
00:26:53,760 --> 00:26:56,080
of their submissions and not just sort

759
00:26:56,080 --> 00:26:57,360
of encourage

760
00:26:57,360 --> 00:26:58,960
[Music]

761
00:26:58,960 --> 00:27:02,480
submissions to be constant time

762
00:27:03,120 --> 00:27:05,520
so we've asked cryptographic library

763
00:27:05,520 --> 00:27:07,200
developers what they think about timing

764
00:27:07,200 --> 00:27:09,679
attacks and we've noted we found out

765
00:27:09,679 --> 00:27:11,279
that they know and care about timing

766
00:27:11,279 --> 00:27:13,600
attacks but they do not know most tools

767
00:27:13,600 --> 00:27:15,919
for verifying constant timeless and they

768
00:27:15,919 --> 00:27:18,320
do not use these tools mostly due to

769
00:27:18,320 --> 00:27:20,960
lack of time we've identified this leaky

770
00:27:20,960 --> 00:27:23,600
pipeline of developers trying to use

771
00:27:23,600 --> 00:27:25,120
these tools for verifying constant

772
00:27:25,120 --> 00:27:27,919
timeless and and failing at doing that

773
00:27:27,919 --> 00:27:30,000
and we've also identified this this

774
00:27:30,000 --> 00:27:32,840
preconceived notion of formal analysis

775
00:27:32,840 --> 00:27:36,159
being just way too much effort for not

776
00:27:36,159 --> 00:27:38,399
much gain

777
00:27:38,399 --> 00:27:40,240
so that that's it for me

778
00:27:40,240 --> 00:27:41,919
thank you for listening if you have one

779
00:27:41,919 --> 00:27:44,000
more information about the paper you can

780
00:27:44,000 --> 00:27:46,480
scan this qr code you can go to this

781
00:27:46,480 --> 00:27:48,960
link for supplementary materials

782
00:27:48,960 --> 00:27:50,559
and you can also

783
00:27:50,559 --> 00:27:53,840
tweet at me

