1
00:00:00,080 --> 00:00:01,439
even though this was such an influential

2
00:00:01,439 --> 00:00:02,560
paper

3
00:00:02,560 --> 00:00:04,400
one of the things i i want to point out

4
00:00:04,400 --> 00:00:07,359
is that um this paper was rejected

5
00:00:07,359 --> 00:00:08,960
and rejected again and again and again

6
00:00:08,960 --> 00:00:10,400
and again and again

7
00:00:10,400 --> 00:00:12,639
uh to the point where go was just like

8
00:00:12,639 --> 00:00:14,719
okay i'm bored i'm done and just posted

9
00:00:14,719 --> 00:00:16,079
on e-print i left it there so it was

10
00:00:16,079 --> 00:00:17,840
never actually published right

11
00:00:17,840 --> 00:00:20,000
um so for those of you who have papers

12
00:00:20,000 --> 00:00:22,000
rejected right that's

13
00:00:22,000 --> 00:00:23,279
this we should tell you that it's

14
00:00:23,279 --> 00:00:24,800
perfectly fine you could have a very

15
00:00:24,800 --> 00:00:26,400
influential paper

16
00:00:26,400 --> 00:00:27,599
um

17
00:00:27,599 --> 00:00:30,400
even if it never gets published and by

18
00:00:30,400 --> 00:00:32,479
the way go was a phd student at the time

19
00:00:32,479 --> 00:00:35,360
when you wrote this paper

20
00:00:36,160 --> 00:00:37,040
um

21
00:00:37,040 --> 00:00:38,800
so

22
00:00:38,800 --> 00:00:40,160
yeah so then what happened is so we were

23
00:00:40,160 --> 00:00:41,520
reading this paper at johns hopkins

24
00:00:41,520 --> 00:00:43,120
that's where i did my phd

25
00:00:43,120 --> 00:00:45,440
and i became interested in the subject

26
00:00:45,440 --> 00:00:48,160
and my phd lab uh reza cormola also got

27
00:00:48,160 --> 00:00:50,719
interested in this and he ended up doing

28
00:00:50,719 --> 00:00:52,320
a summer internship at their labs with

29
00:00:52,320 --> 00:00:53,520
juan garay

30
00:00:53,520 --> 00:00:54,879
and they decided to work on the problem

31
00:00:54,879 --> 00:00:57,199
of multi-user searchable encryption

32
00:00:57,199 --> 00:00:58,800
so they worked on that for the summer

33
00:00:58,800 --> 00:01:00,399
and then reza came back and we talked

34
00:01:00,399 --> 00:01:01,680
about it

35
00:01:01,680 --> 00:01:03,280
um and we kept talking about social

36
00:01:03,280 --> 00:01:05,199
encryption in general and eventually we

37
00:01:05,199 --> 00:01:06,720
decided to collaborate

38
00:01:06,720 --> 00:01:08,720
um and we started working on the problem

39
00:01:08,720 --> 00:01:11,119
uh the three of us and then one was a

40
00:01:11,119 --> 00:01:13,360
good you know uh really good friends

41
00:01:13,360 --> 00:01:15,600
with rafa lasrovsky and he talked to him

42
00:01:15,600 --> 00:01:17,280
about it and rafi got interested rafi

43
00:01:17,280 --> 00:01:18,720
was also working

44
00:01:18,720 --> 00:01:20,240
on the same problem with the public key

45
00:01:20,240 --> 00:01:21,360
version

46
00:01:21,360 --> 00:01:22,960
and decided to work with us and we ended

47
00:01:22,960 --> 00:01:24,880
up writing this paper where we showed

48
00:01:24,880 --> 00:01:26,720
how to solve the problem in optimal time

49
00:01:26,720 --> 00:01:27,520
right

50
00:01:27,520 --> 00:01:29,040
um

51
00:01:29,040 --> 00:01:31,280
so we also while we were working on this

52
00:01:31,280 --> 00:01:33,200
problem we realized that the security

53
00:01:33,200 --> 00:01:34,640
definitions that were available at the

54
00:01:34,640 --> 00:01:37,119
time weren't quite satisfactory and in

55
00:01:37,119 --> 00:01:38,400
particular there was one thing that was

56
00:01:38,400 --> 00:01:39,520
missing which was this notion of

57
00:01:39,520 --> 00:01:41,200
adaptiveness and so we pointed this out

58
00:01:41,200 --> 00:01:42,399
in our paper

59
00:01:42,399 --> 00:01:44,000
um and we also added some additional

60
00:01:44,000 --> 00:01:46,880
security properties of query privacy

61
00:01:46,880 --> 00:01:48,479
and the other thing that we noticed is

62
00:01:48,479 --> 00:01:50,720
that these these constructions leaked

63
00:01:50,720 --> 00:01:52,079
information right there was something

64
00:01:52,079 --> 00:01:53,040
there

65
00:01:53,040 --> 00:01:55,119
that wasn't captured by the by the

66
00:01:55,119 --> 00:01:56,560
security framework

67
00:01:56,560 --> 00:01:58,560
right that the constructions were were

68
00:01:58,560 --> 00:02:00,640
revealing and so we decided right we

69
00:02:00,640 --> 00:02:02,640
made it a point to say okay this leakage

70
00:02:02,640 --> 00:02:03,920
should be explicitly captured in the

71
00:02:03,920 --> 00:02:05,439
security definitions and it should be

72
00:02:05,439 --> 00:02:07,360
clearly stated right and if we can do

73
00:02:07,360 --> 00:02:08,878
that this is going to help the field

74
00:02:08,878 --> 00:02:11,280
because one we have a proper formal way

75
00:02:11,280 --> 00:02:12,879
of describing what the leakage of the

76
00:02:12,879 --> 00:02:15,280
construction is and then we can focus on

77
00:02:15,280 --> 00:02:17,360
that leakage we can try to see if it's

78
00:02:17,360 --> 00:02:19,599
dangerous or not right so we felt that

79
00:02:19,599 --> 00:02:22,480
this would be the first step in actually

80
00:02:22,480 --> 00:02:24,239
being able to think about leakage and

81
00:02:24,239 --> 00:02:26,560
and really uh think about it in a more

82
00:02:26,560 --> 00:02:28,080
formal way

83
00:02:28,080 --> 00:02:28,879
so

84
00:02:28,879 --> 00:02:30,720
we defined or we formally captured the

85
00:02:30,720 --> 00:02:32,800
leakage in this paper

86
00:02:32,800 --> 00:02:35,599
and at the same time um belare boulevard

87
00:02:35,599 --> 00:02:37,280
and o'neil were working on the problem

88
00:02:37,280 --> 00:02:38,400
of search of encryption but from a

89
00:02:38,400 --> 00:02:39,920
different perspective and i actually

90
00:02:39,920 --> 00:02:41,760
think this was adam's first paper right

91
00:02:41,760 --> 00:02:42,879
and

92
00:02:42,879 --> 00:02:44,800
um or at least okay so very nice first

93
00:02:44,800 --> 00:02:46,720
paper but one of his uh one of his first

94
00:02:46,720 --> 00:02:49,040
papers and of course adam went on to you

95
00:02:49,040 --> 00:02:50,959
know having a great career in crypto and

96
00:02:50,959 --> 00:02:52,319
has published a lot of really original

97
00:02:52,319 --> 00:02:53,599
works

98
00:02:53,599 --> 00:02:54,560
um

99
00:02:54,560 --> 00:02:55,840
and in this paper they also gave a

100
00:02:55,840 --> 00:02:58,400
solution that was that was optimal um so

101
00:02:58,400 --> 00:03:01,360
it was it was very very fast

102
00:03:01,360 --> 00:03:04,480
but it had a different leakage profile

103
00:03:04,480 --> 00:03:06,159
than the schemes that we were working on

104
00:03:06,159 --> 00:03:07,840
okay so there was different trade-offs

105
00:03:07,840 --> 00:03:10,640
and this issue of trade-offs between

106
00:03:10,640 --> 00:03:12,640
leakage and efficiency and then we'll

107
00:03:12,640 --> 00:03:14,400
see expressiveness really became kind of

108
00:03:14,400 --> 00:03:15,440
a core

109
00:03:15,440 --> 00:03:16,840
a core element of the

110
00:03:16,840 --> 00:03:20,080
field um so this is another oh yeah and

111
00:03:20,080 --> 00:03:21,519
by the way this paper got rejected at

112
00:03:21,519 --> 00:03:23,200
least four times maybe even more i don't

113
00:03:23,200 --> 00:03:25,679
even remember

114
00:03:27,360 --> 00:03:28,799
so

115
00:03:28,799 --> 00:03:30,799
these were the foundational papers and

116
00:03:30,799 --> 00:03:32,640
at the time really to be honest the

117
00:03:32,640 --> 00:03:34,080
reaction from the community was kind of

118
00:03:34,080 --> 00:03:35,920
like who cares right like this is a toy

119
00:03:35,920 --> 00:03:37,200
problem like

120
00:03:37,200 --> 00:03:39,840
whatever um this is the feedback from

121
00:03:39,840 --> 00:03:41,440
the reviewers and from the community at

122
00:03:41,440 --> 00:03:42,480
large

123
00:03:42,480 --> 00:03:44,319
uh we can solve these problems with aura

124
00:03:44,319 --> 00:03:46,879
with npc so you know this is

125
00:03:46,879 --> 00:03:48,400
trivial right

126
00:03:48,400 --> 00:03:50,080
but for the people that were working on

127
00:03:50,080 --> 00:03:51,760
it right the answer was even though we

128
00:03:51,760 --> 00:03:53,439
had no way to express it but in our mind

129
00:03:53,439 --> 00:03:55,360
we knew that the answer is well sure we

130
00:03:55,360 --> 00:03:57,200
can solve it with these other tools but

131
00:03:57,200 --> 00:03:59,040
what we care about is optimal time

132
00:03:59,040 --> 00:04:01,040
efficiency right optimal time query

133
00:04:01,040 --> 00:04:02,720
complexity and in particular we really

134
00:04:02,720 --> 00:04:04,239
care about concrete efficiency our goal

135
00:04:04,239 --> 00:04:05,680
is to actually have something that runs

136
00:04:05,680 --> 00:04:07,760
for real in that scales right it's not

137
00:04:07,760 --> 00:04:09,599
just to solve the problem

138
00:04:09,599 --> 00:04:11,360
in theory

139
00:04:11,360 --> 00:04:12,959
and so then the next question became

140
00:04:12,959 --> 00:04:14,959
okay well we know how to solve it in

141
00:04:14,959 --> 00:04:17,519
optimal time okay we know we can do that

142
00:04:17,519 --> 00:04:19,519
um but that was for static data sets

143
00:04:19,519 --> 00:04:21,279
right for things that don't change so

144
00:04:21,279 --> 00:04:23,120
then the question became okay can can we

145
00:04:23,120 --> 00:04:25,440
handle dynamic data in optimal time and

146
00:04:25,440 --> 00:04:26,960
this wasn't this wasn't solved at the

147
00:04:26,960 --> 00:04:28,479
time this wasn't this wasn't another

148
00:04:28,479 --> 00:04:30,160
expression at all

149
00:04:30,160 --> 00:04:30,430
um

150
00:04:30,430 --> 00:04:31,520
[Music]

151
00:04:31,520 --> 00:04:32,560
and so

152
00:04:32,560 --> 00:04:34,240
when i was at microsoft research i had

153
00:04:34,240 --> 00:04:37,600
an intern um babis papamantu

154
00:04:37,600 --> 00:04:39,360
who came to work with me

155
00:04:39,360 --> 00:04:40,960
and together with tom roder who was also

156
00:04:40,960 --> 00:04:43,600
at microsoft research we ended up

157
00:04:43,600 --> 00:04:45,360
writing a paper on how to solve or how

158
00:04:45,360 --> 00:04:48,720
to handle dynamic data in optimal time

159
00:04:48,720 --> 00:04:50,720
and uh we also extended extended

160
00:04:50,720 --> 00:04:52,639
security definitions to handle dynamic

161
00:04:52,639 --> 00:04:54,720
data and in particular here one thing to

162
00:04:54,720 --> 00:04:56,400
point out is that so the leakage that

163
00:04:56,400 --> 00:04:58,639
our scheme had was the query quality and

164
00:04:58,639 --> 00:04:59,840
the response identity i won't go into

165
00:04:59,840 --> 00:05:01,440
the details of what that is but you know

166
00:05:01,440 --> 00:05:02,400
fairly

167
00:05:02,400 --> 00:05:03,280
kind of

168
00:05:03,280 --> 00:05:05,840
um this is leakage that occurs in a lot

169
00:05:05,840 --> 00:05:09,840
of schemes but one in particular one uh

170
00:05:09,840 --> 00:05:11,280
leakage that it had is that you could

171
00:05:11,280 --> 00:05:12,880
correlate the updates to the past

172
00:05:12,880 --> 00:05:14,400
queries okay

173
00:05:14,400 --> 00:05:15,680
and

174
00:05:15,680 --> 00:05:17,120
you know we knew this at the time when

175
00:05:17,120 --> 00:05:18,320
we designed the scheme but we didn't

176
00:05:18,320 --> 00:05:20,240
know how to how to get around it

177
00:05:20,240 --> 00:05:22,479
um but we knew this was a limitation and

178
00:05:22,479 --> 00:05:25,039
so then babis went and did his uh his

179
00:05:25,039 --> 00:05:28,720
postdoc at berkeley and he was um

180
00:05:28,720 --> 00:05:29,520
uh

181
00:05:29,520 --> 00:05:31,440
he was there with emil stefanov and

182
00:05:31,440 --> 00:05:33,840
elaine she and they ended up working on

183
00:05:33,840 --> 00:05:35,600
this this very problem and coming up

184
00:05:35,600 --> 00:05:36,800
with a solution

185
00:05:36,800 --> 00:05:38,800
uh that didn't have that particular

186
00:05:38,800 --> 00:05:40,880
leakage right didn't correlate updates

187
00:05:40,880 --> 00:05:42,479
to fast queries and of course the

188
00:05:42,479 --> 00:05:44,320
running time was was higher because you

189
00:05:44,320 --> 00:05:46,479
know you're getting less leakage

190
00:05:46,479 --> 00:05:47,280
um

191
00:05:47,280 --> 00:05:48,960
but at least they could they could show

192
00:05:48,960 --> 00:05:50,320
that it was possible to get rid of that

193
00:05:50,320 --> 00:05:51,680
particular

194
00:05:51,680 --> 00:05:53,039
that particular leakage pattern and they

195
00:05:53,039 --> 00:05:55,520
call this this this additional property

196
00:05:55,520 --> 00:05:57,840
forward privacy

197
00:05:57,840 --> 00:05:58,800
um

198
00:05:58,800 --> 00:06:01,280
and so this was this paper

199
00:06:01,280 --> 00:06:03,919
and then um raphael boss was a phd

200
00:06:03,919 --> 00:06:06,479
student in france at the time looked at

201
00:06:06,479 --> 00:06:09,600
this paper and came up with a really

202
00:06:09,600 --> 00:06:11,840
elegant scheme a really nice scheme that

203
00:06:11,840 --> 00:06:13,919
also achieved for privacy

204
00:06:13,919 --> 00:06:16,720
but in a more efficient way

205
00:06:16,720 --> 00:06:19,600
and this was this was a great result

206
00:06:19,600 --> 00:06:21,600
and um he also showed how to do it based

207
00:06:21,600 --> 00:06:23,280
on travel permutations right which you

208
00:06:23,280 --> 00:06:25,039
can instantiate in different ways so

209
00:06:25,039 --> 00:06:26,880
this was this was a really

210
00:06:26,880 --> 00:06:29,039
um a really nice paper

211
00:06:29,039 --> 00:06:31,039
um another paper i want to point out is

212
00:06:31,039 --> 00:06:33,680
a paper by cashido this was by

213
00:06:33,680 --> 00:06:36,160
folks at ibm research

214
00:06:36,160 --> 00:06:37,199
and

215
00:06:37,199 --> 00:06:39,199
they published a scheme in 2014 which

216
00:06:39,199 --> 00:06:41,280
was an optimal time scheme

217
00:06:41,280 --> 00:06:43,680
um and it could be made for private if

218
00:06:43,680 --> 00:06:48,479
you wanted to uh at the at um if you

219
00:06:48,479 --> 00:06:51,759
added uh some communication complexity

220
00:06:51,759 --> 00:06:53,120
and this is a beautiful paper and in

221
00:06:53,120 --> 00:06:54,960
particular that scheme the schema they

222
00:06:54,960 --> 00:06:56,639
propose in this work i remember when i

223
00:06:56,639 --> 00:06:58,479
first read it i was at msr and we had a

224
00:06:58,479 --> 00:07:00,720
meeting with the crypto group and i was

225
00:07:00,720 --> 00:07:02,319
telling everybody i just read like the

226
00:07:02,319 --> 00:07:03,840
simplest possible encrypted search

227
00:07:03,840 --> 00:07:05,599
scheme the simplest possible scheme but

228
00:07:05,599 --> 00:07:07,120
it does everything that you would want

229
00:07:07,120 --> 00:07:10,000
it's just it's like perfect right and uh

230
00:07:10,000 --> 00:07:12,240
and that's what that scheme was

231
00:07:12,240 --> 00:07:14,000
um so that was also a very influential

232
00:07:14,000 --> 00:07:15,680
paper

233
00:07:15,680 --> 00:07:18,240
and so at this stage the kind of general

234
00:07:18,240 --> 00:07:20,560
consensus or response was okay sure

235
00:07:20,560 --> 00:07:22,560
whatever right like yeah it's fast but

236
00:07:22,560 --> 00:07:24,240
what's with all this leakage right why

237
00:07:24,240 --> 00:07:26,160
don't you just use orap

238
00:07:26,160 --> 00:07:28,000
and of course the answer is that well

239
00:07:28,000 --> 00:07:30,319
oram can be used as is to solve the

240
00:07:30,319 --> 00:07:31,680
problem that's just not how it works

241
00:07:31,680 --> 00:07:33,280
right um

242
00:07:33,280 --> 00:07:35,840
and oram also leaks information it still

243
00:07:35,840 --> 00:07:37,199
does the question is whether this

244
00:07:37,199 --> 00:07:39,120
information is problematic or not what

245
00:07:39,120 --> 00:07:41,360
we showed later on uh more recently is

246
00:07:41,360 --> 00:07:42,160
that

247
00:07:42,160 --> 00:07:43,680
most of the attacks and all of the

248
00:07:43,680 --> 00:07:46,400
attack models that you have for the nano

249
00:07:46,400 --> 00:07:47,440
ram-based solutions there is a

250
00:07:47,440 --> 00:07:48,960
corresponding it's not a formal

251
00:07:48,960 --> 00:07:50,240
statement this is just a heuristic one

252
00:07:50,240 --> 00:07:53,120
right we know of attacks on oram as well

253
00:07:53,120 --> 00:07:53,919
right

254
00:07:53,919 --> 00:07:55,280
so

255
00:07:55,280 --> 00:07:57,680
it's you know the question of whether

256
00:07:57,680 --> 00:07:59,759
you want to incur that extra cost it

257
00:07:59,759 --> 00:08:01,520
kind of depends it depends on on the

258
00:08:01,520 --> 00:08:02,879
situation

259
00:08:02,879 --> 00:08:04,319
and so then the field started asking a

260
00:08:04,319 --> 00:08:05,360
different question which is okay well

261
00:08:05,360 --> 00:08:07,599
can we handle complex queries in optimal

262
00:08:07,599 --> 00:08:09,680
time

263
00:08:09,680 --> 00:08:11,680
and here we have a bunch of papers a lot

264
00:08:11,680 --> 00:08:13,840
of which came out of the iorpa the iopa

265
00:08:13,840 --> 00:08:14,960
challenge

266
00:08:14,960 --> 00:08:16,720
there was a paper by by the folks from

267
00:08:16,720 --> 00:08:18,400
ibm research

268
00:08:18,400 --> 00:08:19,759
which showed how to do conjunctive

269
00:08:19,759 --> 00:08:21,280
queries and

270
00:08:21,280 --> 00:08:23,360
queries in searchable normal form in

271
00:08:23,360 --> 00:08:25,280
sub-linear time

272
00:08:25,280 --> 00:08:27,440
there was the blind seer project from

273
00:08:27,440 --> 00:08:29,680
colombia that showed how to do uh

274
00:08:29,680 --> 00:08:32,159
boolean queries uh so that's conjunction

275
00:08:32,159 --> 00:08:33,519
and disjunction

276
00:08:33,519 --> 00:08:37,039
mixed together as well in sublinear time

277
00:08:37,039 --> 00:08:38,640
and then

278
00:08:38,640 --> 00:08:40,320
my and then i wrote a paper with tariq

279
00:08:40,320 --> 00:08:42,240
this was our first paper uh where we

280
00:08:42,240 --> 00:08:43,839
looked at this problem uh this was our

281
00:08:43,839 --> 00:08:45,600
first paper together where we solved it

282
00:08:45,600 --> 00:08:47,040
in sub linear time with optimal

283
00:08:47,040 --> 00:08:48,959
communication and in one round

284
00:08:48,959 --> 00:08:50,240
and this came out of a visit so

285
00:08:50,240 --> 00:08:52,000
basically i had met tariq um at a

286
00:08:52,000 --> 00:08:53,600
conference in okinawa he was presenting

287
00:08:53,600 --> 00:08:54,959
a poster

288
00:08:54,959 --> 00:08:56,560
and um

289
00:08:56,560 --> 00:08:58,320
and that's how i first met him and you

290
00:08:58,320 --> 00:08:59,680
know i was really impressed with him and

291
00:08:59,680 --> 00:09:01,680
eventually i invited him to visit me at

292
00:09:01,680 --> 00:09:02,959
microsoft research and give a talk and

293
00:09:02,959 --> 00:09:04,000
he came

294
00:09:04,000 --> 00:09:04,880
and

295
00:09:04,880 --> 00:09:06,880
during this was like a two-day visit or

296
00:09:06,880 --> 00:09:08,640
three-day visit and at that point i told

297
00:09:08,640 --> 00:09:10,000
them you know there's this interesting

298
00:09:10,000 --> 00:09:12,240
open problem which is disjunctive

299
00:09:12,240 --> 00:09:13,839
searches this is a problem that at the

300
00:09:13,839 --> 00:09:16,640
time hadn't hadn't really been solved in

301
00:09:16,640 --> 00:09:18,560
in sub-linear time and it was really one

302
00:09:18,560 --> 00:09:21,120
of the harder problems in the field

303
00:09:21,120 --> 00:09:23,680
and in three days he he thought about it

304
00:09:23,680 --> 00:09:25,600
while he was at msr and you know two

305
00:09:25,600 --> 00:09:27,120
days later he came back with a lot of

306
00:09:27,120 --> 00:09:28,480
the ideas that ended up being in this

307
00:09:28,480 --> 00:09:30,800
paper right so this one i was like okay

308
00:09:30,800 --> 00:09:31,680
you know

309
00:09:31,680 --> 00:09:35,440
you have a internship like every summer

310
00:09:35,440 --> 00:09:37,839
you know for the next x amount of years

311
00:09:37,839 --> 00:09:39,279
if you want to come to msr and that's

312
00:09:39,279 --> 00:09:41,680
how we started working together

313
00:09:41,680 --> 00:09:43,040
um

314
00:09:43,040 --> 00:09:44,959
so yeah so these are some of the papers

315
00:09:44,959 --> 00:09:46,800
uh that came out of that

316
00:09:46,800 --> 00:09:48,080
and then of course the next question was

317
00:09:48,080 --> 00:09:51,279
can we do ranges and here again this

318
00:09:51,279 --> 00:09:54,000
blind sear project from colombia

319
00:09:54,000 --> 00:09:54,800
um

320
00:09:54,800 --> 00:09:56,880
came up with a way of doing ranges as

321
00:09:56,880 --> 00:09:58,560
well so they had the boolean curves and

322
00:09:58,560 --> 00:10:01,279
the range queries in sublinear time

323
00:10:01,279 --> 00:10:02,560
there was also

324
00:10:02,560 --> 00:10:03,920
two papers that came out at about the

325
00:10:03,920 --> 00:10:06,480
same time really nice papers one of them

326
00:10:06,480 --> 00:10:09,839
was by uh uh de mer de mercedes at all

327
00:10:09,839 --> 00:10:11,440
and um

328
00:10:11,440 --> 00:10:13,279
the merchants happened to be

329
00:10:13,279 --> 00:10:15,279
uh i think it was at this time or maybe

330
00:10:15,279 --> 00:10:17,120
later he was a student of babis right

331
00:10:17,120 --> 00:10:18,720
the guy that i mentioned in the

332
00:10:18,720 --> 00:10:21,279
beginning that was uh

333
00:10:21,279 --> 00:10:23,120
spent the summer with me at msr so this

334
00:10:23,120 --> 00:10:26,000
is sort of a nice kind of lineage thing

335
00:10:26,000 --> 00:10:27,440
um and so he wrote this really nice

336
00:10:27,440 --> 00:10:29,839
paper these really nice schemes handle

337
00:10:29,839 --> 00:10:31,920
ranges and at the same time the ibm

338
00:10:31,920 --> 00:10:33,440
research team also came up with a way of

339
00:10:33,440 --> 00:10:36,000
doing ranges and substring

340
00:10:36,000 --> 00:10:38,240
and so these were really

341
00:10:38,240 --> 00:10:41,040
some really nice papers as well

342
00:10:41,040 --> 00:10:43,440
um and so then you know people started

343
00:10:43,440 --> 00:10:45,760
getting used to these papers but the

344
00:10:45,760 --> 00:10:47,600
critique was well

345
00:10:47,600 --> 00:10:50,560
you know sure okay it's we we believe

346
00:10:50,560 --> 00:10:53,040
you that it's hard to do you know to not

347
00:10:53,040 --> 00:10:56,000
have to have high performance right real

348
00:10:56,000 --> 00:10:57,279
efficiency

349
00:10:57,279 --> 00:10:59,040
and low leakage okay but what's the

350
00:10:59,040 --> 00:11:00,320
point of these formal leakage profiles

351
00:11:00,320 --> 00:11:01,920
anyways right you guys just write this

352
00:11:01,920 --> 00:11:04,079
leakage sure right like

353
00:11:04,079 --> 00:11:05,440
why are you doing this and who cares

354
00:11:05,440 --> 00:11:07,120
right and the reason is as i mentioned

355
00:11:07,120 --> 00:11:08,560
before is because we want to be precise

356
00:11:08,560 --> 00:11:10,560
about leakage of course we understand

357
00:11:10,560 --> 00:11:11,920
that we want to get rid of leakage it's

358
00:11:11,920 --> 00:11:13,120
not like we're sitting here saying hey

359
00:11:13,120 --> 00:11:15,279
let's leak as much as we can right we

360
00:11:15,279 --> 00:11:16,640
understand this

361
00:11:16,640 --> 00:11:18,640
but we need to find these trade-offs

362
00:11:18,640 --> 00:11:20,160
right we have to have performance and we

363
00:11:20,160 --> 00:11:22,240
want to minimize leakage and we can't do

364
00:11:22,240 --> 00:11:23,920
that unless we have a precise statement

365
00:11:23,920 --> 00:11:25,839
of what the leakage is right and having

366
00:11:25,839 --> 00:11:27,440
this leakage having this precise

367
00:11:27,440 --> 00:11:30,000
statement of leakage also allows us

368
00:11:30,000 --> 00:11:32,240
um to then attack it right so we can see

369
00:11:32,240 --> 00:11:34,160
whether it is damaging in real life or

370
00:11:34,160 --> 00:11:35,279
not

371
00:11:35,279 --> 00:11:36,480
and this is the question that we ask is

372
00:11:36,480 --> 00:11:37,920
can we exploit these leakage profiles in

373
00:11:37,920 --> 00:11:39,519
practice right

374
00:11:39,519 --> 00:11:42,800
and so then there were um

375
00:11:42,800 --> 00:11:46,279
some papers

376
00:12:06,639 --> 00:12:09,639
and

377
00:12:16,959 --> 00:12:18,639
all right let me try and log back into

378
00:12:18,639 --> 00:12:21,639
zoom

379
00:12:32,959 --> 00:12:34,160
okay so i'm going to give this talk with

380
00:12:34,160 --> 00:12:36,560
our slides

381
00:12:36,560 --> 00:12:39,040
i've never done this before

382
00:12:39,040 --> 00:12:41,040
um

383
00:12:41,040 --> 00:12:43,040
but since it's not a technical talk i

384
00:12:43,040 --> 00:12:45,120
could probably pull it off

385
00:12:45,120 --> 00:12:47,839
yeah it's fine so okay all right so

386
00:12:47,839 --> 00:12:49,120
you'll have to just uh look at me

387
00:12:49,120 --> 00:12:51,839
instead of setting the slides um so

388
00:12:51,839 --> 00:12:53,440
right so the question that we started

389
00:12:53,440 --> 00:12:56,000
asking is okay can we you know uh can we

390
00:12:56,000 --> 00:12:58,320
exploit this leakage right

391
00:12:58,320 --> 00:13:00,720
and um and so what happened there is

392
00:13:00,720 --> 00:13:02,639
that there was some papers in particular

393
00:13:02,639 --> 00:13:06,639
one paper by islam kuzu and

394
00:13:07,260 --> 00:13:08,399
[Music]

395
00:13:08,399 --> 00:13:10,000
the ikk paper

396
00:13:10,000 --> 00:13:11,200
there was the first paper to actually

397
00:13:11,200 --> 00:13:13,760
try and exploit leakage okay

398
00:13:13,760 --> 00:13:15,760
and so there's some limitations to this

399
00:13:15,760 --> 00:13:18,639
attack uh it's an attack that i think

400
00:13:18,639 --> 00:13:19,600
maybe

401
00:13:19,600 --> 00:13:21,600
has been taken out of context a lot it's

402
00:13:21,600 --> 00:13:23,279
used probably used to motivate hundreds

403
00:13:23,279 --> 00:13:24,720
and hundreds of papers even though the

404
00:13:24,720 --> 00:13:26,800
way that it's used is technically wrong

405
00:13:26,800 --> 00:13:27,600
but

406
00:13:27,600 --> 00:13:29,760
um but it was an influential it was an

407
00:13:29,760 --> 00:13:31,519
influential paper and showing that okay

408
00:13:31,519 --> 00:13:32,800
maybe there's something that one could

409
00:13:32,800 --> 00:13:34,880
do right and this was followed up by a

410
00:13:34,880 --> 00:13:37,440
paper uh by cash grubbs perry and riston

411
00:13:37,440 --> 00:13:38,320
part

412
00:13:38,320 --> 00:13:39,440
that actually pointed out some of the

413
00:13:39,440 --> 00:13:41,519
limitations of this original paper and

414
00:13:41,519 --> 00:13:44,880
improved on those attacks

415
00:13:44,880 --> 00:13:46,160
and of course here there's a subtlety in

416
00:13:46,160 --> 00:13:47,199
that

417
00:13:47,199 --> 00:13:48,720
the model really matters the assumptions

418
00:13:48,720 --> 00:13:49,920
you make really matters right so for

419
00:13:49,920 --> 00:13:52,160
both of these both of these attacks they

420
00:13:52,160 --> 00:13:54,399
work if you know a large chunk of the

421
00:13:54,399 --> 00:13:56,000
data right you can recover information

422
00:13:56,000 --> 00:13:57,440
about the queries if you know the data

423
00:13:57,440 --> 00:13:58,959
so it's not exactly what people what

424
00:13:58,959 --> 00:14:00,839
people think

425
00:14:00,839 --> 00:14:03,040
um and this was followed up by a paper

426
00:14:03,040 --> 00:14:05,519
by zhang papamanto and katz uh which is

427
00:14:05,519 --> 00:14:06,880
a paper that i

428
00:14:06,880 --> 00:14:08,320
it's a really interesting paper right

429
00:14:08,320 --> 00:14:09,839
that introduces notion of an injection

430
00:14:09,839 --> 00:14:11,680
attack and so this is asking the

431
00:14:11,680 --> 00:14:14,079
question what happens if i can inject if

432
00:14:14,079 --> 00:14:15,920
the adversary can inject data into your

433
00:14:15,920 --> 00:14:17,279
data set and it turns out that you can

434
00:14:17,279 --> 00:14:18,959
actually do some really interesting

435
00:14:18,959 --> 00:14:20,880
things from an attack point of view um

436
00:14:20,880 --> 00:14:22,560
so this was a really

437
00:14:22,560 --> 00:14:24,720
you know a great paper as well

438
00:14:24,720 --> 00:14:27,760
and we followed this up with uh

439
00:14:27,760 --> 00:14:30,000
more attacks

440
00:14:30,000 --> 00:14:31,360
and so

441
00:14:31,360 --> 00:14:33,680
this was on kind of standard keyword

442
00:14:33,680 --> 00:14:35,760
search and then there was a paper

443
00:14:35,760 --> 00:14:40,560
by kolaris collios nissim and o'neil

444
00:14:40,560 --> 00:14:41,839
then another being a very influential

445
00:14:41,839 --> 00:14:43,519
paper where they look at ranges right

446
00:14:43,519 --> 00:14:44,800
they looked at okay well what happens if

447
00:14:44,800 --> 00:14:46,240
you're trying to attack the leakage of

448
00:14:46,240 --> 00:14:47,600
range schemes

449
00:14:47,600 --> 00:14:49,120
um and they showed that you could do

450
00:14:49,120 --> 00:14:50,720
this and they also showed that you could

451
00:14:50,720 --> 00:14:51,680
do it

452
00:14:51,680 --> 00:14:53,600
uh only knowing the volume which was

453
00:14:53,600 --> 00:14:55,440
something that oram leaks as well and

454
00:14:55,440 --> 00:14:56,639
this was quite interesting because it

455
00:14:56,639 --> 00:14:58,560
was kind of saying that oh actually you

456
00:14:58,560 --> 00:15:01,680
could carry out this attack uh even with

457
00:15:01,680 --> 00:15:03,440
orange-based schemes

458
00:15:03,440 --> 00:15:05,519
and it was this was followed up uh by a

459
00:15:05,519 --> 00:15:06,959
series of papers

460
00:15:06,959 --> 00:15:08,720
by uh

461
00:15:08,720 --> 00:15:11,120
mino and patterson and then grubbs

462
00:15:11,120 --> 00:15:12,399
amino and patterson

463
00:15:12,399 --> 00:15:15,519
where they exploited the leakage certain

464
00:15:15,519 --> 00:15:18,480
leakage profiles from range schemes um

465
00:15:18,480 --> 00:15:20,240
and improved on those attacks and there

466
00:15:20,240 --> 00:15:22,000
was a recent paper by

467
00:15:22,000 --> 00:15:24,320
naropolos papamanto and tamasia so a lot

468
00:15:24,320 --> 00:15:26,079
of the attacks that i just mentioned

469
00:15:26,079 --> 00:15:28,320
they relied on on some assumption right

470
00:15:28,320 --> 00:15:29,440
there's always like some assumption

471
00:15:29,440 --> 00:15:31,040
underlying these attacks sometimes it's

472
00:15:31,040 --> 00:15:32,880
that the quer the queries that you make

473
00:15:32,880 --> 00:15:34,639
are distributed uniformly at random or

474
00:15:34,639 --> 00:15:36,560
sometimes that the data is very dense or

475
00:15:36,560 --> 00:15:38,560
there's always like something right

476
00:15:38,560 --> 00:15:40,800
um and this paper by grenada postpartum

477
00:15:40,800 --> 00:15:41,839
and thomas showed that you actually

478
00:15:41,839 --> 00:15:44,480
didn't need uh the assumption of queries

479
00:15:44,480 --> 00:15:47,360
being um sampled uniformly at random

480
00:15:47,360 --> 00:15:48,639
okay and this was actually from a

481
00:15:48,639 --> 00:15:49,839
technical point of view this was really

482
00:15:49,839 --> 00:15:51,279
not revealed

483
00:15:51,279 --> 00:15:52,079
so

484
00:15:52,079 --> 00:15:53,279
uh that was quite an interesting paper

485
00:15:53,279 --> 00:15:55,199
as well yeah i wish i could show you the

486
00:15:55,199 --> 00:15:56,639
papers now but i

487
00:15:56,639 --> 00:15:57,600
can't

488
00:15:57,600 --> 00:15:58,399
um

489
00:15:58,399 --> 00:16:00,560
so then the the kind of you know the

490
00:16:00,560 --> 00:16:03,279
attitude was okay well see like we told

491
00:16:03,279 --> 00:16:05,120
you so right there's all these attacks

492
00:16:05,120 --> 00:16:07,040
right like this is it's not going

493
00:16:07,040 --> 00:16:10,320
anywhere right and so kind of the answer

494
00:16:10,320 --> 00:16:12,160
to that was kind of like yes these

495
00:16:12,160 --> 00:16:13,279
attacks are really interesting we're

496
00:16:13,279 --> 00:16:14,639
learning a lot from doing them and this

497
00:16:14,639 --> 00:16:16,240
is what we need to be doing but they're

498
00:16:16,240 --> 00:16:18,079
not all practical right we have to be

499
00:16:18,079 --> 00:16:19,360
able to distinguish between attacks that

500
00:16:19,360 --> 00:16:20,959
are practical right like crypto analysis

501
00:16:20,959 --> 00:16:22,720
that's practical equipped analysis that

502
00:16:22,720 --> 00:16:24,240
is teaching us something right but it's

503
00:16:24,240 --> 00:16:26,720
not necessarily practical at this time

504
00:16:26,720 --> 00:16:27,839
um

505
00:16:27,839 --> 00:16:29,440
and so then what we decided or what the

506
00:16:29,440 --> 00:16:30,959
community started to think about is well

507
00:16:30,959 --> 00:16:32,480
what happens in the snapshot model right

508
00:16:32,480 --> 00:16:34,720
what happens if you're only getting

509
00:16:34,720 --> 00:16:37,040
access to the encrypted data itself

510
00:16:37,040 --> 00:16:38,399
right without information on the queries

511
00:16:38,399 --> 00:16:40,320
and it turns out this is actually a very

512
00:16:40,320 --> 00:16:42,160
realistic model in particular in

513
00:16:42,160 --> 00:16:44,560
industry

514
00:16:44,720 --> 00:16:47,199
for for a variety of reasons

515
00:16:47,199 --> 00:16:50,720
and so louis and wu looked at this this

516
00:16:50,720 --> 00:16:53,519
uh model the snapshot model and uh

517
00:16:53,519 --> 00:16:54,880
looked up

518
00:16:54,880 --> 00:16:56,720
if you could design order revealing and

519
00:16:56,720 --> 00:16:58,720
order preserving schemes in this model

520
00:16:58,720 --> 00:17:00,320
and they showed how to do that

521
00:17:00,320 --> 00:17:03,440
um grubbs whistling part and shematikov

522
00:17:03,440 --> 00:17:05,439
kind of gave a critique of the snapshot

523
00:17:05,439 --> 00:17:07,359
model for the context of databases where

524
00:17:07,359 --> 00:17:08,400
they said you have to be careful if

525
00:17:08,400 --> 00:17:09,599
you're going to implement these schemes

526
00:17:09,599 --> 00:17:11,599
in a database because databases keep

527
00:17:11,599 --> 00:17:14,319
information around right so you can't

528
00:17:14,319 --> 00:17:15,760
just like think you're just going to

529
00:17:15,760 --> 00:17:17,520
take a snapshot secure scheme and just

530
00:17:17,520 --> 00:17:19,199
dump it into a database that's not gonna

531
00:17:19,199 --> 00:17:20,079
work

532
00:17:20,079 --> 00:17:23,919
um and then uh with tariq and my phd

533
00:17:23,919 --> 00:17:26,319
student gosamjad at the time we

534
00:17:26,319 --> 00:17:27,760
formalized the snapshot model for

535
00:17:27,760 --> 00:17:30,160
structural encryption and

536
00:17:30,160 --> 00:17:31,440
uh

537
00:17:31,440 --> 00:17:32,640
well yeah for uh for structural

538
00:17:32,640 --> 00:17:33,919
encryption and we showed that you could

539
00:17:33,919 --> 00:17:35,280
actually design schemes in a snapshot

540
00:17:35,280 --> 00:17:37,440
model that had no leakage or like almost

541
00:17:37,440 --> 00:17:39,200
no leakage okay so if you're worried

542
00:17:39,200 --> 00:17:40,799
about the snapshot model you actually

543
00:17:40,799 --> 00:17:42,160
have great solutions you have solutions

544
00:17:42,160 --> 00:17:43,679
that are really really fast and have

545
00:17:43,679 --> 00:17:47,360
like little to no leakage okay

546
00:17:48,240 --> 00:17:49,440
um

547
00:17:49,440 --> 00:17:51,440
okay so the response to that was kind of

548
00:17:51,440 --> 00:17:52,720
like or the you know the critic's

549
00:17:52,720 --> 00:17:54,720
response to that was sure

550
00:17:54,720 --> 00:17:56,000
fine but there's still leakage in the

551
00:17:56,000 --> 00:17:57,520
persistent model right what about the

552
00:17:57,520 --> 00:17:59,200
persistent mod

553
00:17:59,200 --> 00:18:00,960
and so the question that we were asking

554
00:18:00,960 --> 00:18:03,600
ourselves at the time with tariq was

555
00:18:03,600 --> 00:18:04,960
okay well

556
00:18:04,960 --> 00:18:05,840
um

557
00:18:05,840 --> 00:18:07,039
yes there's leakage of the persistent

558
00:18:07,039 --> 00:18:09,120
model but you know maybe there's a way

559
00:18:09,120 --> 00:18:10,960
to to remove this leakage maybe there's

560
00:18:10,960 --> 00:18:12,799
a way to suppress this leakage right so

561
00:18:12,799 --> 00:18:14,400
what if i could take a scheme

562
00:18:14,400 --> 00:18:16,400
that has a certain leakage profile what

563
00:18:16,400 --> 00:18:18,160
if i could run it through

564
00:18:18,160 --> 00:18:21,280
a transformation or a compiler and out

565
00:18:21,280 --> 00:18:22,960
and what will come out of it is a new

566
00:18:22,960 --> 00:18:24,640
scheme that is maybe a little bit less

567
00:18:24,640 --> 00:18:26,960
efficient but that doesn't have the same

568
00:18:26,960 --> 00:18:29,200
leakage profile right and so we looked

569
00:18:29,200 --> 00:18:30,720
at this problem

570
00:18:30,720 --> 00:18:32,640
and we showed how to do this for query

571
00:18:32,640 --> 00:18:34,320
equality which is whether two queries

572
00:18:34,320 --> 00:18:35,679
are the same so we showed how to remove

573
00:18:35,679 --> 00:18:36,880
that leakage

574
00:18:36,880 --> 00:18:39,760
um in a paper at crypto in 2018 with

575
00:18:39,760 --> 00:18:40,720
olya

576
00:18:40,720 --> 00:18:42,880
or mako

577
00:18:42,880 --> 00:18:44,720
and we followed that up

578
00:18:44,720 --> 00:18:46,480
with looking at okay is it possible to

579
00:18:46,480 --> 00:18:47,919
suppress volume is it possible to

580
00:18:47,919 --> 00:18:50,240
suppress or to hide the length of a

581
00:18:50,240 --> 00:18:51,679
response right because a lot of schemes

582
00:18:51,679 --> 00:18:53,039
need this information and it turns out

583
00:18:53,039 --> 00:18:55,200
that that specific leakage pattern is

584
00:18:55,200 --> 00:18:56,640
correlated to a bunch of things and it's

585
00:18:56,640 --> 00:18:58,000
very very hard to remove but if you can

586
00:18:58,000 --> 00:19:00,080
remove it you can then remove a bunch of

587
00:19:00,080 --> 00:19:01,520
other stuff as well so it's kind of like

588
00:19:01,520 --> 00:19:04,080
this core piece and so we showed how to

589
00:19:04,080 --> 00:19:07,200
do that um in a paper at eurocrypt in

590
00:19:07,200 --> 00:19:08,720
2019

591
00:19:08,720 --> 00:19:11,120
and then um with my phd student at a

592
00:19:11,120 --> 00:19:13,840
time marilyn george uh we

593
00:19:13,840 --> 00:19:16,160
we followed that up uh so the first

594
00:19:16,160 --> 00:19:18,160
paper was mostly for static structures

595
00:19:18,160 --> 00:19:20,240
and then with marilyn and tarique showed

596
00:19:20,240 --> 00:19:22,840
how to do this for dynamic

597
00:19:22,840 --> 00:19:24,960
structures and then there was this great

598
00:19:24,960 --> 00:19:27,520
paper by uh the google research folks so

599
00:19:27,520 --> 00:19:28,720
this was uh

600
00:19:28,720 --> 00:19:33,600
uh patel persiano yeo and modi

601
00:19:33,600 --> 00:19:35,679
who took this idea of volume hiding and

602
00:19:35,679 --> 00:19:37,760
then showed how to basically suppress

603
00:19:37,760 --> 00:19:39,440
volume um

604
00:19:39,440 --> 00:19:41,440
in basically with like optimal storage

605
00:19:41,440 --> 00:19:43,360
and optimal queries right so it's really

606
00:19:43,360 --> 00:19:45,200
kind of like the right solution

607
00:19:45,200 --> 00:19:48,320
uh the right solution for the problem

608
00:19:48,320 --> 00:19:51,879
this was a great paper

609
00:19:53,600 --> 00:19:55,919
okay so then another

610
00:19:55,919 --> 00:19:58,960
critique that that came about and

611
00:19:58,960 --> 00:20:00,240
actually had this conversation when i

612
00:20:00,240 --> 00:20:02,240
was at microsoft research

613
00:20:02,240 --> 00:20:03,039
with

614
00:20:03,039 --> 00:20:04,559
somebody i won't name

615
00:20:04,559 --> 00:20:06,640
but we had just finished

616
00:20:06,640 --> 00:20:08,400
explaining everything that we could do

617
00:20:08,400 --> 00:20:09,919
it's like we can search on a crypto data

618
00:20:09,919 --> 00:20:11,600
we can do it fast we can do it you know

619
00:20:11,600 --> 00:20:12,640
we can

620
00:20:12,640 --> 00:20:14,000
there's some leakage but we're pretty

621
00:20:14,000 --> 00:20:16,000
confident on on this particular leakage

622
00:20:16,000 --> 00:20:17,360
pattern that we can handle there's

623
00:20:17,360 --> 00:20:19,039
there's snapshot now there's all you

624
00:20:19,039 --> 00:20:20,480
know there's all these things

625
00:20:20,480 --> 00:20:22,320
snapshot wasn't there at the time but

626
00:20:22,320 --> 00:20:24,080
there's all these things and the person

627
00:20:24,080 --> 00:20:25,120
just looked at us after we were done

628
00:20:25,120 --> 00:20:28,240
presenting for an hour and was like

629
00:20:28,240 --> 00:20:31,039
like who cares can you do databases

630
00:20:31,039 --> 00:20:33,919
and we're like what like databases okay

631
00:20:33,919 --> 00:20:36,159
like we just spent an hour trying to

632
00:20:36,159 --> 00:20:37,679
tell you that we could do keyword search

633
00:20:37,679 --> 00:20:38,480
but

634
00:20:38,480 --> 00:20:40,159
um that person that researcher was

635
00:20:40,159 --> 00:20:42,320
really like not impressed at all

636
00:20:42,320 --> 00:20:43,679
but this was a reasonable question to

637
00:20:43,679 --> 00:20:46,240
ask right because databases are really

638
00:20:46,240 --> 00:20:49,120
really really hugely important piece of

639
00:20:49,120 --> 00:20:51,600
our infrastructure um and it is really

640
00:20:51,600 --> 00:20:52,960
kind of like if you think about it it is

641
00:20:52,960 --> 00:20:55,039
probably the most important place where

642
00:20:55,039 --> 00:20:56,559
we can introduce

643
00:20:56,559 --> 00:20:59,039
uh this technology right so

644
00:20:59,039 --> 00:21:02,240
you know so this guy was right um

645
00:21:02,240 --> 00:21:04,159
and there's been you know a lot of

646
00:21:04,159 --> 00:21:05,679
papers on how to integrating

647
00:21:05,679 --> 00:21:07,679
cryptosearch into databases

648
00:21:07,679 --> 00:21:09,200
one paper that was prominent was the

649
00:21:09,200 --> 00:21:10,559
 db paper

650
00:21:10,559 --> 00:21:11,600
um

651
00:21:11,600 --> 00:21:13,440
where they showed how to handle sql uh

652
00:21:13,440 --> 00:21:14,720
using deterministic version order

653
00:21:14,720 --> 00:21:16,720
preserving encryption um and then we had

654
00:21:16,720 --> 00:21:18,320
a follow-up paper that showed that you

655
00:21:18,320 --> 00:21:19,600
know in certain context especially if

656
00:21:19,600 --> 00:21:21,280
you have auxiliary information

657
00:21:21,280 --> 00:21:23,760
you can there are attacks that you can

658
00:21:23,760 --> 00:21:25,840
uh you can mount against this particular

659
00:21:25,840 --> 00:21:27,919
type of design

660
00:21:27,919 --> 00:21:30,000
um and then with with melissa chase we

661
00:21:30,000 --> 00:21:32,159
had to pay for 2010 that uh introduced

662
00:21:32,159 --> 00:21:33,919
the notion of structured encryption and

663
00:21:33,919 --> 00:21:35,760
this is the idea of okay well when we're

664
00:21:35,760 --> 00:21:37,440
doing keyword search on encrypted data

665
00:21:37,440 --> 00:21:39,120
we're focusing on doing search on

666
00:21:39,120 --> 00:21:40,480
documents right

667
00:21:40,480 --> 00:21:43,360
but really the core piece like after

668
00:21:43,360 --> 00:21:45,280
basically the cgko paper right we kind

669
00:21:45,280 --> 00:21:47,280
of realized the core piece

670
00:21:47,280 --> 00:21:48,960
was the wasn't the encrypted documents

671
00:21:48,960 --> 00:21:50,159
you know that's important but it's the

672
00:21:50,159 --> 00:21:51,600
it's a data structure that we're using

673
00:21:51,600 --> 00:21:53,679
in order to speed up that search right

674
00:21:53,679 --> 00:21:55,200
and so the structural encryption paper

675
00:21:55,200 --> 00:21:57,120
was trying to say we should be focusing

676
00:21:57,120 --> 00:21:59,039
on that as as

677
00:21:59,039 --> 00:22:00,480
its own primitive and as a building

678
00:22:00,480 --> 00:22:02,640
block to do other things and this is

679
00:22:02,640 --> 00:22:04,080
important for several reasons one

680
00:22:04,080 --> 00:22:05,120
because this idea of structural

681
00:22:05,120 --> 00:22:06,880
encryption is what allowed us to do it

682
00:22:06,880 --> 00:22:08,960
allowed us it allowed us

683
00:22:08,960 --> 00:22:09,760
to

684
00:22:09,760 --> 00:22:11,520
realize that it was possible to do

685
00:22:11,520 --> 00:22:13,360
leakage suppression right it was through

686
00:22:13,360 --> 00:22:15,840
that notion but the other thing is that

687
00:22:15,840 --> 00:22:17,760
this is what allows us to do databases

688
00:22:17,760 --> 00:22:19,919
right like when once we have the

689
00:22:19,919 --> 00:22:21,360
encrypted data structures that we need

690
00:22:21,360 --> 00:22:22,799
this is what we use in order to build

691
00:22:22,799 --> 00:22:25,600
encrypted antenna database

692
00:22:25,600 --> 00:22:26,799
and so based

693
00:22:26,799 --> 00:22:28,880
on the ideas from the social encryption

694
00:22:28,880 --> 00:22:31,520
paper uh with uh with tariq we came up

695
00:22:31,520 --> 00:22:33,520
with a way of handling a large subset of

696
00:22:33,520 --> 00:22:34,720
sql

697
00:22:34,720 --> 00:22:34,990
um

698
00:22:34,990 --> 00:22:36,720
[Music]

699
00:22:36,720 --> 00:22:37,679
uh

700
00:22:37,679 --> 00:22:39,120
with structural encryption right so

701
00:22:39,120 --> 00:22:41,440
without the leakage profile of

702
00:22:41,440 --> 00:22:42,240
um

703
00:22:42,240 --> 00:22:45,200
of of this of the system like db

704
00:22:45,200 --> 00:22:47,360
and we followed this up uh with stan

705
00:22:47,360 --> 00:22:48,640
shdonik

706
00:22:48,640 --> 00:22:50,000
brown

707
00:22:50,000 --> 00:22:51,039
and

708
00:22:51,039 --> 00:22:52,480
um

709
00:22:52,480 --> 00:22:54,000
and one of my psg students sam at the

710
00:22:54,000 --> 00:22:54,720
time

711
00:22:54,720 --> 00:22:56,880
um where we improved those schemes and

712
00:22:56,880 --> 00:22:59,520
actually built a system uh or a real

713
00:22:59,520 --> 00:23:00,960
world sql

714
00:23:00,960 --> 00:23:04,559
uh encrypted equity database

715
00:23:04,559 --> 00:23:05,600
so

716
00:23:05,600 --> 00:23:08,640
that was basically the database papers

717
00:23:08,640 --> 00:23:10,480
um and so then we can ask okay so what

718
00:23:10,480 --> 00:23:12,480
is the result of all of this work right

719
00:23:12,480 --> 00:23:14,000
and of course i've missed a bunch of

720
00:23:14,000 --> 00:23:15,679
papers and a bunch of

721
00:23:15,679 --> 00:23:16,640
sub

722
00:23:16,640 --> 00:23:18,880
categories right and my apologies if i

723
00:23:18,880 --> 00:23:20,559
didn't mention your paper

724
00:23:20,559 --> 00:23:22,480
it's you know

725
00:23:22,480 --> 00:23:23,919
sure it's a very important paper but i

726
00:23:23,919 --> 00:23:25,280
had to make you know i had to make some

727
00:23:25,280 --> 00:23:27,360
edits i had to make some decisions

728
00:23:27,360 --> 00:23:28,640
um

729
00:23:28,640 --> 00:23:30,320
so what's come out of all of this work

730
00:23:30,320 --> 00:23:31,919
right one of the things that's come out

731
00:23:31,919 --> 00:23:33,679
of it that i think people if you take a

732
00:23:33,679 --> 00:23:34,880
step back that a lot of people don't

733
00:23:34,880 --> 00:23:36,240
realize unless you take a step back is

734
00:23:36,240 --> 00:23:38,159
that we actually have a pretty intricate

735
00:23:38,159 --> 00:23:39,280
and unique

736
00:23:39,280 --> 00:23:42,000
design and analysis framework right so

737
00:23:42,000 --> 00:23:43,520
all of these papers all this work that i

738
00:23:43,520 --> 00:23:45,120
talked about right when you're actually

739
00:23:45,120 --> 00:23:47,440
doing this work now you have a whole

740
00:23:47,440 --> 00:23:49,760
a whole framework to do it you have all

741
00:23:49,760 --> 00:23:51,279
of these design techniques from all

742
00:23:51,279 --> 00:23:52,799
these papers right that you can start

743
00:23:52,799 --> 00:23:54,960
with to start your design and then what

744
00:23:54,960 --> 00:23:56,559
you do is you look at your your you look

745
00:23:56,559 --> 00:23:58,640
at your design and you try to find its

746
00:23:58,640 --> 00:24:00,240
leakage right you

747
00:24:00,240 --> 00:24:01,760
you try to understand okay what location

748
00:24:01,760 --> 00:24:04,000
of this does does this scheme have then

749
00:24:04,000 --> 00:24:05,440
you use the security definitions or the

750
00:24:05,440 --> 00:24:06,559
leakage parameterized security

751
00:24:06,559 --> 00:24:08,559
definitions to prove that your scheme

752
00:24:08,559 --> 00:24:09,919
doesn't leak anything beyond those

753
00:24:09,919 --> 00:24:12,000
specific leakage profiles okay and this

754
00:24:12,000 --> 00:24:13,600
isn't the end result right this isn't

755
00:24:13,600 --> 00:24:16,080
like the ideal situation but it it tells

756
00:24:16,080 --> 00:24:17,679
you something right now you can focus on

757
00:24:17,679 --> 00:24:20,559
leakage profiles okay so now once you

758
00:24:20,559 --> 00:24:21,760
have these leakage once you know what

759
00:24:21,760 --> 00:24:23,520
the leakage profile of your scheme is

760
00:24:23,520 --> 00:24:24,880
you have different choices one thing you

761
00:24:24,880 --> 00:24:26,320
could do is you could do cryptanalysis

762
00:24:26,320 --> 00:24:27,360
right and we have a whole bunch of

763
00:24:27,360 --> 00:24:29,200
results from the cryptanalytic side of

764
00:24:29,200 --> 00:24:30,799
the field that tells us which leakage

765
00:24:30,799 --> 00:24:32,320
profiles are more or less dangerous

766
00:24:32,320 --> 00:24:34,720
right which ones we should avoid etc

767
00:24:34,720 --> 00:24:37,360
you can also use uh leaky suppression

768
00:24:37,360 --> 00:24:39,600
techniques right if if your leakage

769
00:24:39,600 --> 00:24:40,880
profile is one of the ones for which we

770
00:24:40,880 --> 00:24:42,320
have suppression techniques you can use

771
00:24:42,320 --> 00:24:44,400
that right to get rid of that leakage

772
00:24:44,400 --> 00:24:46,240
another thing that you can do this isn't

773
00:24:46,240 --> 00:24:49,520
an upcoming paper uh that um that we're

774
00:24:49,520 --> 00:24:51,840
gonna post soon is that another another

775
00:24:51,840 --> 00:24:53,200
thing that you could actually do is you

776
00:24:53,200 --> 00:24:54,880
could prove that your scheme or you

777
00:24:54,880 --> 00:24:56,640
could prove that your leakage profile is

778
00:24:56,640 --> 00:24:59,840
immune to a certain subclass of attacks

779
00:24:59,840 --> 00:25:02,320
right and again this isn't ideal

780
00:25:02,320 --> 00:25:04,159
but this still tells you something right

781
00:25:04,159 --> 00:25:05,039
and this is something that we've been

782
00:25:05,039 --> 00:25:07,520
able to do for a particular uh for a

783
00:25:07,520 --> 00:25:09,919
particular leakage profile which is

784
00:25:09,919 --> 00:25:12,240
uh and a particular leash profile and a

785
00:25:12,240 --> 00:25:15,200
particular class of attack um

786
00:25:15,200 --> 00:25:17,600
something else that i actually wrote

787
00:25:17,600 --> 00:25:20,400
about in i think it was 2014 but that

788
00:25:20,400 --> 00:25:22,159
nobody really kind of picked up on but i

789
00:25:22,159 --> 00:25:23,679
think is actually

790
00:25:23,679 --> 00:25:27,279
an important tool in our in our toolkit

791
00:25:27,279 --> 00:25:29,760
is rebuilding right so one of the things

792
00:25:29,760 --> 00:25:31,760
that we know from from cryptanalysis

793
00:25:31,760 --> 00:25:33,760
right especially if we have really like

794
00:25:33,760 --> 00:25:36,480
really state-of-the-art analytic results

795
00:25:36,480 --> 00:25:38,720
is that those results tell us that okay

796
00:25:38,720 --> 00:25:40,960
for a particular leakage profile right

797
00:25:40,960 --> 00:25:44,159
there is an attack that can do well if

798
00:25:44,159 --> 00:25:45,360
this attack

799
00:25:45,360 --> 00:25:46,960
um sees

800
00:25:46,960 --> 00:25:49,039
lambda queries right so we know

801
00:25:49,039 --> 00:25:50,720
heuristically that the attack requires a

802
00:25:50,720 --> 00:25:52,559
certain number of quarters to work

803
00:25:52,559 --> 00:25:54,320
now if this is the state of the art and

804
00:25:54,320 --> 00:25:56,000
if we're comfortable with that then one

805
00:25:56,000 --> 00:25:57,360
thing you can do is you can run your

806
00:25:57,360 --> 00:25:59,600
scheme for let's say you know lambda

807
00:25:59,600 --> 00:26:01,279
over two or whatever you feel

808
00:26:01,279 --> 00:26:03,679
comfortable with and then you can take

809
00:26:03,679 --> 00:26:05,200
your encrypted structure and you can

810
00:26:05,200 --> 00:26:06,559
rebuild it

811
00:26:06,559 --> 00:26:08,480
right rebuild the new one

812
00:26:08,480 --> 00:26:10,640
before you get to the lineup and so this

813
00:26:10,640 --> 00:26:12,000
is something i pointed out a long time

814
00:26:12,000 --> 00:26:14,080
ago but at the time

815
00:26:14,080 --> 00:26:16,159
um there was no generic way of

816
00:26:16,159 --> 00:26:17,760
rebuilding an encrypted data structure

817
00:26:17,760 --> 00:26:18,880
right but this is actually a problem

818
00:26:18,880 --> 00:26:21,279
that we solved in a paper unrelated to

819
00:26:21,279 --> 00:26:22,720
this where we actually gave a general

820
00:26:22,720 --> 00:26:24,320
purpose rebuild protocol that you could

821
00:26:24,320 --> 00:26:25,919
use with any encrypted data structure so

822
00:26:25,919 --> 00:26:27,120
this is actually something that we could

823
00:26:27,120 --> 00:26:28,159
use

824
00:26:28,159 --> 00:26:30,480
in practice if we if we wanted to

825
00:26:30,480 --> 00:26:32,080
and this is backed by the cryptanalytic

826
00:26:32,080 --> 00:26:33,600
results right or

827
00:26:33,600 --> 00:26:35,520
um

828
00:26:35,520 --> 00:26:37,360
so yeah so another thing that has come

829
00:26:37,360 --> 00:26:39,039
out of this work besides this i think

830
00:26:39,039 --> 00:26:40,960
this really interesting design framework

831
00:26:40,960 --> 00:26:42,799
and analysis framework which is still

832
00:26:42,799 --> 00:26:44,799
growing by the way there's going to be i

833
00:26:44,799 --> 00:26:45,679
think

834
00:26:45,679 --> 00:26:47,600
a lot of really interesting things

835
00:26:47,600 --> 00:26:49,520
um that are that are going to come out

836
00:26:49,520 --> 00:26:51,520
in the next few years about this

837
00:26:51,520 --> 00:26:53,600
is also we have we built as a community

838
00:26:53,600 --> 00:26:55,840
we have real technology right this is

839
00:26:55,840 --> 00:26:57,840
not just papers these are real systems

840
00:26:57,840 --> 00:26:59,360
and these are real systems that are

841
00:26:59,360 --> 00:27:00,720
deployed at a large scale and that are

842
00:27:00,720 --> 00:27:03,039
protecting real you know real workloads

843
00:27:03,039 --> 00:27:04,960
and i think this is this is a really is

844
00:27:04,960 --> 00:27:06,960
a really big accomplishment

845
00:27:06,960 --> 00:27:08,240
so

846
00:27:08,240 --> 00:27:10,559
in conclusion you know basically what

847
00:27:10,559 --> 00:27:11,919
i'm trying to say is that the field has

848
00:27:11,919 --> 00:27:13,600
come a really long way and it's come a

849
00:27:13,600 --> 00:27:15,840
long way in the face of criticism and

850
00:27:15,840 --> 00:27:18,080
face of pushback and it went from just

851
00:27:18,080 --> 00:27:20,159
an interesting research idea to a real

852
00:27:20,159 --> 00:27:22,240
technology right and this is something

853
00:27:22,240 --> 00:27:24,559
that is doesn't happen very often

854
00:27:24,559 --> 00:27:27,039
um and this was really achieved right by

855
00:27:27,039 --> 00:27:29,279
all the people who wrote these papers

856
00:27:29,279 --> 00:27:30,960
and more

857
00:27:30,960 --> 00:27:32,640
and it was achieved because the people

858
00:27:32,640 --> 00:27:34,320
that wrote all these papers really were

859
00:27:34,320 --> 00:27:36,559
part of the dreamer the dreamer category

860
00:27:36,559 --> 00:27:37,440
right

861
00:27:37,440 --> 00:27:38,960
um these are the people that saw the

862
00:27:38,960 --> 00:27:41,760
long-term vision right they believed in

863
00:27:41,760 --> 00:27:42,880
the idea

864
00:27:42,880 --> 00:27:44,880
of encrypted search um they're the ones

865
00:27:44,880 --> 00:27:47,440
that pursued you know pursued the work

866
00:27:47,440 --> 00:27:49,200
pursued science despite the critics

867
00:27:49,200 --> 00:27:51,200
which is not an easy thing to do

868
00:27:51,200 --> 00:27:54,480
um and they stuck with it right

869
00:27:54,480 --> 00:27:56,320
um and of course there's still a lot

870
00:27:56,320 --> 00:27:57,679
more problems to solve right there's

871
00:27:57,679 --> 00:27:58,880
gonna be there's a ton of problems to

872
00:27:58,880 --> 00:28:01,200
solve there's a ton of things to improve

873
00:28:01,200 --> 00:28:02,399
and there's going to be a lot more

874
00:28:02,399 --> 00:28:04,159
criticism and a lot more pushback right

875
00:28:04,159 --> 00:28:06,480
as we keep going right like that never

876
00:28:06,480 --> 00:28:08,399
that never stops but i guess the point i

877
00:28:08,399 --> 00:28:09,760
want to make is that given the track

878
00:28:09,760 --> 00:28:11,679
record that we've had so far

879
00:28:11,679 --> 00:28:13,039
you know we really need to keep pushing

880
00:28:13,039 --> 00:28:14,399
forward and we really shouldn't get

881
00:28:14,399 --> 00:28:15,760
discouraged right the criticism is

882
00:28:15,760 --> 00:28:17,360
always going to be there but you know

883
00:28:17,360 --> 00:28:19,279
like whatever right like who cares as

884
00:28:19,279 --> 00:28:20,960
long as we're making progress and as

885
00:28:20,960 --> 00:28:22,240
long as we're actually

886
00:28:22,240 --> 00:28:24,000
having real world impact i think that's

887
00:28:24,000 --> 00:28:25,919
really the measure uh the measure of

888
00:28:25,919 --> 00:28:27,200
success

889
00:28:27,200 --> 00:28:29,679
so yeah so that's all i had i think i'm

890
00:28:29,679 --> 00:28:32,559
quite a bit over time

891
00:28:32,559 --> 00:28:34,240
but hopefully we can we can make that up

892
00:28:34,240 --> 00:28:37,640
later in the program

893
00:28:50,559 --> 00:28:52,960
um thank you so much for the uh for the

894
00:28:52,960 --> 00:28:55,840
great presentation um

895
00:28:55,840 --> 00:28:58,960
and uh if any of you have questions

896
00:28:58,960 --> 00:29:02,799
maybe let's take it offline after the uh

897
00:29:02,799 --> 00:29:05,039
in the coffee break because we need the

898
00:29:05,039 --> 00:29:06,240
we are quite

899
00:29:06,240 --> 00:29:07,690
late

900
00:29:07,690 --> 00:29:11,089
[Music]

901
00:29:57,760 --> 00:30:00,760
is

902
00:30:24,640 --> 00:30:27,520
okay so just

903
00:30:32,640 --> 00:30:34,880
hello everybody oh

904
00:30:34,880 --> 00:30:37,200
oh sure sorry so i'm very happy to

905
00:30:37,200 --> 00:30:38,720
introduce uh

906
00:30:38,720 --> 00:30:41,120
sasha baldereva um she's going to tell

907
00:30:41,120 --> 00:30:44,480
us about uh how to think about the

908
00:30:44,480 --> 00:30:46,399
efficiency security tradeoffs when

909
00:30:46,399 --> 00:30:48,559
designing encrypted search protocol and

910
00:30:48,559 --> 00:30:51,039
the floors is yours thank you so much

911
00:30:51,039 --> 00:30:53,200
uh good morning everybody thank you eric

912
00:30:53,200 --> 00:30:54,960
for the introduction

913
00:30:54,960 --> 00:30:56,720
uh so

914
00:30:56,720 --> 00:30:59,679
yes senior asked me to work on my work

915
00:30:59,679 --> 00:31:02,399
on searchable encryption and

916
00:31:02,399 --> 00:31:05,519
just like cenia worked in this field for

917
00:31:05,519 --> 00:31:07,440
a long time

918
00:31:07,440 --> 00:31:09,440
uh and

919
00:31:09,440 --> 00:31:11,440
some parts of my work may be somewhat

920
00:31:11,440 --> 00:31:12,480
similar

921
00:31:12,480 --> 00:31:15,120
uh to his because i guess we went

922
00:31:15,120 --> 00:31:16,320
through this

923
00:31:16,320 --> 00:31:19,760
journey in the development of this field

924
00:31:19,760 --> 00:31:22,000
so let's see

925
00:31:22,000 --> 00:31:24,240
uh

926
00:31:24,720 --> 00:31:27,279
to me uh

927
00:31:27,279 --> 00:31:30,000
the work on sociable encryption is this

928
00:31:30,000 --> 00:31:32,720
pursuit of

929
00:31:32,720 --> 00:31:34,480
the right

930
00:31:34,480 --> 00:31:38,880
trade-offs between security and

931
00:31:38,880 --> 00:31:41,760
functionality and efficiency because

932
00:31:41,760 --> 00:31:44,640
these properties are really at odds uh

933
00:31:44,640 --> 00:31:46,240
with each other for searchable

934
00:31:46,240 --> 00:31:47,600
encryption

935
00:31:47,600 --> 00:31:48,960
and

936
00:31:48,960 --> 00:31:50,640
my work

937
00:31:50,640 --> 00:31:51,919
took me

938
00:31:51,919 --> 00:31:54,720
two different extremes of looking for

939
00:31:54,720 --> 00:31:56,159
this

940
00:31:56,159 --> 00:31:59,519
trade-offs uh over the years and that's

941
00:31:59,519 --> 00:32:00,720
what

942
00:32:00,720 --> 00:32:02,240
i'll talk about

943
00:32:02,240 --> 00:32:05,279
but first let me uh mention very briefly

944
00:32:05,279 --> 00:32:07,519
and i guess most of you know very well

945
00:32:07,519 --> 00:32:09,519
uh what searchable encryption is about

946
00:32:09,519 --> 00:32:10,559
but when

947
00:32:10,559 --> 00:32:13,919
uh i talk about functionality briefly of

948
00:32:13,919 --> 00:32:16,000
course we have a client and usually it's

949
00:32:16,000 --> 00:32:17,360
in the symmetric key setting when the

950
00:32:17,360 --> 00:32:19,600
client has a secret key and the client

951
00:32:19,600 --> 00:32:20,720
wants to

952
00:32:20,720 --> 00:32:23,120
uh outsource

953
00:32:23,120 --> 00:32:26,840
data encrypted in some form to remote uh

954
00:32:26,840 --> 00:32:29,919
cloud storage remote

955
00:32:29,919 --> 00:32:32,559
server and later uh

956
00:32:32,559 --> 00:32:35,200
make queries and get some parts of the

957
00:32:35,200 --> 00:32:38,480
data back and possibly update the data

958
00:32:38,480 --> 00:32:40,399
uh but there is more to this

959
00:32:40,399 --> 00:32:42,000
functionality there are so many

960
00:32:42,000 --> 00:32:43,919
questions what types of queries are

961
00:32:43,919 --> 00:32:46,799
supported is it just exact match search

962
00:32:46,799 --> 00:32:49,679
uh can be range queries uh can be some

963
00:32:49,679 --> 00:32:52,159
similarity queries uh

964
00:32:52,159 --> 00:32:54,799
uh conjunctive queries and so forth uh

965
00:32:54,799 --> 00:32:56,640
is it in the symmetrical public key

966
00:32:56,640 --> 00:32:57,679
setting

967
00:32:57,679 --> 00:32:58,880
uh

968
00:32:58,880 --> 00:32:59,600
can

969
00:32:59,600 --> 00:33:01,600
are allowed to make changes on the

970
00:33:01,600 --> 00:33:04,320
server side uh

971
00:33:04,320 --> 00:33:06,799
are we allowing rounds of interactions

972
00:33:06,799 --> 00:33:09,679
for each query or or not

973
00:33:09,679 --> 00:33:12,159
what about client storage can client do

974
00:33:12,159 --> 00:33:15,760
some pre-processing uh compliant store

975
00:33:15,760 --> 00:33:18,559
uh some data on the side or no

976
00:33:18,559 --> 00:33:21,039
uh are allowed to use secure hardware

977
00:33:21,039 --> 00:33:22,799
i'll be allowed to

978
00:33:22,799 --> 00:33:25,840
split work between multiple servers

979
00:33:25,840 --> 00:33:28,880
um do we need perfect correctness so we

980
00:33:28,880 --> 00:33:31,600
can allow uh

981
00:33:31,600 --> 00:33:33,039
some

982
00:33:33,039 --> 00:33:35,440
false positives for negatives

983
00:33:35,440 --> 00:33:36,480
uh

984
00:33:36,480 --> 00:33:38,080
does the client have to know all the

985
00:33:38,080 --> 00:33:40,240
data in advance so so first there are

986
00:33:40,240 --> 00:33:41,919
many of course issues with the

987
00:33:41,919 --> 00:33:44,320
functionality with the efficiency well

988
00:33:44,320 --> 00:33:46,720
clearly we want to do

989
00:33:46,720 --> 00:33:48,960
uh the faster the better

990
00:33:48,960 --> 00:33:51,200
uh but of course

991
00:33:51,200 --> 00:33:53,039
how fast we can do depends on the

992
00:33:53,039 --> 00:33:56,240
security uh and the functionality and

993
00:33:56,240 --> 00:33:59,360
there are of course many questions uh

994
00:33:59,360 --> 00:34:00,399
what is

995
00:34:00,399 --> 00:34:03,678
suitable efficiency

996
00:34:04,399 --> 00:34:06,480
and with security it's

997
00:34:06,480 --> 00:34:09,199
it's this is more complicated obviously

998
00:34:09,199 --> 00:34:12,159
you could get from uh senior stock

999
00:34:12,159 --> 00:34:16,159
uh but the first thing first uh

1000
00:34:16,159 --> 00:34:18,560
even though the server may be trusted it

1001
00:34:18,560 --> 00:34:21,760
can be subject to compromise therefore

1002
00:34:21,760 --> 00:34:24,960
we want some security against the server

1003
00:34:24,960 --> 00:34:27,440
and the first thing is if

1004
00:34:27,440 --> 00:34:29,119
someone breaks in

1005
00:34:29,119 --> 00:34:29,839
in

1006
00:34:29,839 --> 00:34:32,239
the service and just steals your

1007
00:34:32,239 --> 00:34:35,119
encrypted data so it's reasonable to

1008
00:34:35,119 --> 00:34:38,000
demand that that attacker cannot get

1009
00:34:38,000 --> 00:34:40,399
access to your data right so that's the

1010
00:34:40,399 --> 00:34:43,280
first thing the simplistic thing

1011
00:34:43,280 --> 00:34:46,240
oh sorry

1012
00:34:47,679 --> 00:34:49,839
oh it's a bit shifted but i wanted to

1013
00:34:49,839 --> 00:34:51,918
highlight what does it does it mean to

1014
00:34:51,918 --> 00:34:55,040
obtain information about your data and

1015
00:34:55,040 --> 00:34:57,839
it may be in the simplest one way in a

1016
00:34:57,839 --> 00:34:59,200
sense or

1017
00:34:59,200 --> 00:35:01,440
maybe more in the semantic security

1018
00:35:01,440 --> 00:35:03,839
sense

1019
00:35:04,079 --> 00:35:06,640
and of course there is more than just

1020
00:35:06,640 --> 00:35:08,720
stealing the data there is more than

1021
00:35:08,720 --> 00:35:11,119
that snapshot adversary and that i'll

1022
00:35:11,119 --> 00:35:12,560
mention uh

1023
00:35:12,560 --> 00:35:14,800
uh of course uh

1024
00:35:14,800 --> 00:35:17,040
we have to think about even stronger

1025
00:35:17,040 --> 00:35:18,320
attacks

1026
00:35:18,320 --> 00:35:19,839
so

1027
00:35:19,839 --> 00:35:22,240
in my view i i briefly saying you talked

1028
00:35:22,240 --> 00:35:24,400
about so many uh

1029
00:35:24,400 --> 00:35:28,079
uh so many works and

1030
00:35:28,079 --> 00:35:30,320
for me just to kind of simplify the

1031
00:35:30,320 --> 00:35:33,760
story like my view of where to put what

1032
00:35:33,760 --> 00:35:35,280
so i kind of

1033
00:35:35,280 --> 00:35:36,320
view

1034
00:35:36,320 --> 00:35:39,119
some classes of works on searchable

1035
00:35:39,119 --> 00:35:40,480
encryption

1036
00:35:40,480 --> 00:35:41,280
uh

1037
00:35:41,280 --> 00:35:43,920
if you see this security versus

1038
00:35:43,920 --> 00:35:46,640
efficiency access so

1039
00:35:46,640 --> 00:35:48,000
the

1040
00:35:48,000 --> 00:35:50,960
most efficient and least secure

1041
00:35:50,960 --> 00:35:52,640
will be

1042
00:35:52,640 --> 00:35:54,800
uh what's called property preserving

1043
00:35:54,800 --> 00:35:56,640
encryption to where deterministic

1044
00:35:56,640 --> 00:35:57,920
encryption and all the preserving

1045
00:35:57,920 --> 00:35:59,599
encryptions falls into and i'm going to

1046
00:35:59,599 --> 00:36:01,520
talk about it because that's how i

1047
00:36:01,520 --> 00:36:04,000
started to work on searchable encryption

1048
00:36:04,000 --> 00:36:04,880
uh

1049
00:36:04,880 --> 00:36:06,480
and then

1050
00:36:06,480 --> 00:36:09,839
their works uh

1051
00:36:10,160 --> 00:36:12,880
like encrypted indices uh

1052
00:36:12,880 --> 00:36:15,040
without using your arm techniques like

1053
00:36:15,040 --> 00:36:17,680
the classical works of course molar at

1054
00:36:17,680 --> 00:36:20,240
all and many other schemes that's

1055
00:36:20,240 --> 00:36:22,960
uh also very efficient

1056
00:36:22,960 --> 00:36:26,079
uh more secure but probably again not

1057
00:36:26,079 --> 00:36:28,880
the most secure and then

1058
00:36:28,880 --> 00:36:30,640
i think

1059
00:36:30,640 --> 00:36:33,599
very separate but we we can get very

1060
00:36:33,599 --> 00:36:35,599
very strong security

1061
00:36:35,599 --> 00:36:39,200
if we employ this auram techniques on

1062
00:36:39,200 --> 00:36:41,599
top of what else we know but then of

1063
00:36:41,599 --> 00:36:44,960
course efficiency suffers right so uh

1064
00:36:44,960 --> 00:36:45,760
and

1065
00:36:45,760 --> 00:36:48,000
i started to work with

1066
00:36:48,000 --> 00:36:49,839
something here

1067
00:36:49,839 --> 00:36:51,440
uh and i'll talk

1068
00:36:51,440 --> 00:36:54,960
recently i work on something there and

1069
00:36:54,960 --> 00:36:57,040
i still don't have an answer where's the

1070
00:36:57,040 --> 00:37:00,240
right trade-off and

1071
00:37:00,240 --> 00:37:02,640
and i'm also very eager to hear what

1072
00:37:02,640 --> 00:37:04,640
industry thinks about it and what's used

1073
00:37:04,640 --> 00:37:07,680
there but that's what we all

1074
00:37:07,680 --> 00:37:09,200
trying to do and trying to learn and

1075
00:37:09,200 --> 00:37:10,800
trying to understand

1076
00:37:10,800 --> 00:37:12,640
uh so

1077
00:37:12,640 --> 00:37:15,760
early works and so i started uh

1078
00:37:15,760 --> 00:37:19,200
well i think it was 2005 and adam o'neil

1079
00:37:19,200 --> 00:37:22,720
uh yeah was my student we database

1080
00:37:22,720 --> 00:37:24,880
researchers at georgia tech

1081
00:37:24,880 --> 00:37:27,599
let us know that

1082
00:37:27,599 --> 00:37:28,720
they

1083
00:37:28,720 --> 00:37:31,040
they they want to secure

1084
00:37:31,040 --> 00:37:34,560
their databases and search and

1085
00:37:34,560 --> 00:37:36,720
actually

1086
00:37:36,720 --> 00:37:38,960
some researchers are using something

1087
00:37:38,960 --> 00:37:41,040
what fits immediately

1088
00:37:41,040 --> 00:37:44,320
the goal namely deterministic encryption

1089
00:37:44,320 --> 00:37:46,720
uh because you cannot use randomized

1090
00:37:46,720 --> 00:37:48,160
encryption because then you don't know

1091
00:37:48,160 --> 00:37:50,160
how to query but if it's deterministic

1092
00:37:50,160 --> 00:37:52,160
it's very easy you just re-encrypt

1093
00:37:52,160 --> 00:37:54,560
that's your query and

1094
00:37:54,560 --> 00:37:57,280
the beauty of it that if you encrypt

1095
00:37:57,280 --> 00:37:59,200
your data with deterministic encryption

1096
00:37:59,200 --> 00:38:01,040
then

1097
00:38:01,040 --> 00:38:03,520
you can search already works because you

1098
00:38:03,520 --> 00:38:05,520
don't need any changes on the server

1099
00:38:05,520 --> 00:38:07,440
side the server knew how to search

1100
00:38:07,440 --> 00:38:10,960
before without any security now you just

1101
00:38:10,960 --> 00:38:13,280
send the cipher text and do whatever you

1102
00:38:13,280 --> 00:38:15,280
did before and the server does in this

1103
00:38:15,280 --> 00:38:17,920
thing like before no changes so it's

1104
00:38:17,920 --> 00:38:19,440
really really neat

1105
00:38:19,440 --> 00:38:20,560
uh

1106
00:38:20,560 --> 00:38:21,520
so

1107
00:38:21,520 --> 00:38:23,599
and

1108
00:38:23,599 --> 00:38:25,599
they've been already like mentioning

1109
00:38:25,599 --> 00:38:27,839
this but there was no formal study of

1110
00:38:27,839 --> 00:38:29,040
the security of it because

1111
00:38:29,040 --> 00:38:30,560
cryptographers

1112
00:38:30,560 --> 00:38:33,040
always thought that deterministic

1113
00:38:33,040 --> 00:38:34,800
encryption does not deserve attention

1114
00:38:34,800 --> 00:38:36,720
because it's so weak

1115
00:38:36,720 --> 00:38:38,640
but we thought well they really want to

1116
00:38:38,640 --> 00:38:40,000
use it let's

1117
00:38:40,000 --> 00:38:42,400
pay some attention at least let's uh

1118
00:38:42,400 --> 00:38:44,000
study what's uh

1119
00:38:44,000 --> 00:38:45,359
security

1120
00:38:45,359 --> 00:38:46,880
about it and

1121
00:38:46,880 --> 00:38:50,079
in a similar way so we learned that

1122
00:38:50,079 --> 00:38:52,320
also practitioners

1123
00:38:52,320 --> 00:38:54,720
trying to design order preserving

1124
00:38:54,720 --> 00:38:57,359
deterministic encryption to support

1125
00:38:57,359 --> 00:38:58,960
range queries

1126
00:38:58,960 --> 00:39:02,079
and the game say some same motivation

1127
00:39:02,079 --> 00:39:04,640
if you can sort cipher text

1128
00:39:04,640 --> 00:39:06,480
and they're deterministic then you can

1129
00:39:06,480 --> 00:39:08,800
immediately do range queries you just

1130
00:39:08,800 --> 00:39:10,720
re-encrypt and

1131
00:39:10,720 --> 00:39:12,960
that indicates the range and the server

1132
00:39:12,960 --> 00:39:14,560
does whatever we did before it could

1133
00:39:14,560 --> 00:39:16,400
start before it could index before now

1134
00:39:16,400 --> 00:39:18,720
it can do it on cybertext

1135
00:39:18,720 --> 00:39:21,760
and the same thing we thought okay so

1136
00:39:21,760 --> 00:39:24,240
uh it's an interesting question like

1137
00:39:24,240 --> 00:39:26,640
what is what the preserving encryption

1138
00:39:26,640 --> 00:39:28,160
what what is security about the

1139
00:39:28,160 --> 00:39:31,280
preserving encryption uh

1140
00:39:31,280 --> 00:39:34,000
so let let's do this and that's

1141
00:39:34,000 --> 00:39:35,040
what

1142
00:39:35,040 --> 00:39:36,240
uh

1143
00:39:36,240 --> 00:39:40,480
i uh and my students adam and nate had

1144
00:39:40,480 --> 00:39:42,079
so that's what

1145
00:39:42,079 --> 00:39:43,599
we worked uh

1146
00:39:43,599 --> 00:39:44,720
earlier

1147
00:39:44,720 --> 00:39:45,760
early on

1148
00:39:45,760 --> 00:39:48,240
and so

1149
00:39:50,880 --> 00:39:52,560
yes so efficiency is great that's what i

1150
00:39:52,560 --> 00:39:54,880
was gonna say and functionality is

1151
00:39:54,880 --> 00:39:57,839
fantastic but security security of

1152
00:39:57,839 --> 00:40:02,640
course we knew security is not strong uh

1153
00:40:02,640 --> 00:40:03,680
but

1154
00:40:03,680 --> 00:40:05,200
still it's good to

1155
00:40:05,200 --> 00:40:07,440
at least formally define what security

1156
00:40:07,440 --> 00:40:10,240
can mean for this level of security but

1157
00:40:10,240 --> 00:40:11,920
obviously

1158
00:40:11,920 --> 00:40:14,319
uh deterministic encryption leaks the

1159
00:40:14,319 --> 00:40:17,440
quality of ciphertex kind of by design

1160
00:40:17,440 --> 00:40:18,960
uh but it's leakage you know the

1161
00:40:18,960 --> 00:40:21,040
preserving encryption and addition leaks

1162
00:40:21,040 --> 00:40:22,960
the order of uh

1163
00:40:22,960 --> 00:40:24,880
plain text uh

1164
00:40:24,880 --> 00:40:27,200
again

1165
00:40:27,280 --> 00:40:29,760
doesn't sound very good but at least

1166
00:40:29,760 --> 00:40:31,280
let's study and very briefly i'll

1167
00:40:31,280 --> 00:40:33,680
mention it's deterministic encryption

1168
00:40:33,680 --> 00:40:35,920
it's not that hard to design if you

1169
00:40:35,920 --> 00:40:38,240
think about it and in fact it's nice i

1170
00:40:38,240 --> 00:40:40,480
mean i teach it in uh

1171
00:40:40,480 --> 00:40:42,880
in my course to students who don't know

1172
00:40:42,880 --> 00:40:45,280
much about crypt it's easy to understand

1173
00:40:45,280 --> 00:40:48,240
usually encryption uses randomness

1174
00:40:48,240 --> 00:40:51,440
uh here you don't want it but

1175
00:40:51,440 --> 00:40:55,839
you cannot quite omit it but if you

1176
00:40:55,839 --> 00:40:58,560
somewhat if you use a prf

1177
00:40:58,560 --> 00:41:01,520
or hashing in the public key setting uh

1178
00:41:01,520 --> 00:41:03,359
of the message and use this is the

1179
00:41:03,359 --> 00:41:06,160
randomness uh that will give you

1180
00:41:06,160 --> 00:41:09,200
deterministic encryption and in fact

1181
00:41:09,200 --> 00:41:11,440
if you have a good definition of uh

1182
00:41:11,440 --> 00:41:14,400
deterministic encryption you can prove

1183
00:41:14,400 --> 00:41:18,160
somewhat easily uh that it works

1184
00:41:18,160 --> 00:41:20,640
defining deterministic encryption turns

1185
00:41:20,640 --> 00:41:21,760
out

1186
00:41:21,760 --> 00:41:24,640
is very tricky in the public key setting

1187
00:41:24,640 --> 00:41:25,440
uh

1188
00:41:25,440 --> 00:41:27,520
for some reason but the construction is

1189
00:41:27,520 --> 00:41:29,440
easier uh

1190
00:41:29,440 --> 00:41:30,800
but that paper

1191
00:41:30,800 --> 00:41:33,200
so yeah we're happy with we're getting

1192
00:41:33,200 --> 00:41:36,079
uh test of time award uh at this

1193
00:41:36,079 --> 00:41:37,920
conference for work on deterministic

1194
00:41:37,920 --> 00:41:39,040
encryption

1195
00:41:39,040 --> 00:41:41,520
uh on the public key setting which is

1196
00:41:41,520 --> 00:41:44,240
nice but the construction is

1197
00:41:44,240 --> 00:41:47,359
is very very easy

1198
00:41:47,440 --> 00:41:49,359
um

1199
00:41:49,359 --> 00:41:51,280
so with the preserving encryption and i

1200
00:41:51,280 --> 00:41:52,800
mentioned that just deterministic

1201
00:41:52,800 --> 00:41:55,200
encryption but also plain text

1202
00:41:55,200 --> 00:41:58,000
preserve a sorry ciphertext preserve the

1203
00:41:58,000 --> 00:41:59,359
order of

1204
00:41:59,359 --> 00:42:01,040
the plain text

1205
00:42:01,040 --> 00:42:03,440
so

1206
00:42:03,440 --> 00:42:05,680
the definition is clear

1207
00:42:05,680 --> 00:42:09,280
uh and as i explained that fits so well

1208
00:42:09,280 --> 00:42:11,440
for the purpose of the

1209
00:42:11,440 --> 00:42:14,079
range queries if you wanna don't wanna

1210
00:42:14,079 --> 00:42:16,720
even uh do any changes on the server

1211
00:42:16,720 --> 00:42:18,720
side it just

1212
00:42:18,720 --> 00:42:21,839
fits very very well security though it's

1213
00:42:21,839 --> 00:42:23,520
not

1214
00:42:23,520 --> 00:42:25,520
entirely straightforward how defined

1215
00:42:25,520 --> 00:42:27,920
what is good secure or the preserving

1216
00:42:27,920 --> 00:42:29,359
encryption scheme

1217
00:42:29,359 --> 00:42:31,280
uh you're trying to say that

1218
00:42:31,280 --> 00:42:33,760
nothing but the order is leaked

1219
00:42:33,760 --> 00:42:35,599
uh but

1220
00:42:35,599 --> 00:42:37,280
there are some tricks about this

1221
00:42:37,280 --> 00:42:39,920
definition like it's it doesn't work

1222
00:42:39,920 --> 00:42:42,960
immediately so what we tried in our

1223
00:42:42,960 --> 00:42:46,000
uh first approach we said that

1224
00:42:46,000 --> 00:42:48,400
um order preserving encryption is good

1225
00:42:48,400 --> 00:42:49,800
if it's

1226
00:42:49,800 --> 00:42:52,960
indistinguishable from the ideal object

1227
00:42:52,960 --> 00:42:55,359
being

1228
00:42:55,680 --> 00:42:57,119
see

1229
00:42:57,119 --> 00:43:00,480
oh sorry i don't have uh

1230
00:43:01,839 --> 00:43:04,400
random or the preserving function

1231
00:43:04,400 --> 00:43:06,720
basically uh it's secured for

1232
00:43:06,720 --> 00:43:08,480
pseudorandom

1233
00:43:08,480 --> 00:43:10,960
uh order preserving function

1234
00:43:10,960 --> 00:43:13,680
okay so similar like to the classical

1235
00:43:13,680 --> 00:43:17,040
prf definition but now uh we're working

1236
00:43:17,040 --> 00:43:19,200
with the soda preserving a monotonically

1237
00:43:19,200 --> 00:43:21,920
increasing function

1238
00:43:21,920 --> 00:43:22,880
uh

1239
00:43:22,880 --> 00:43:24,960
and then we thought okay so what about

1240
00:43:24,960 --> 00:43:27,839
the construction and i will briefly i

1241
00:43:27,839 --> 00:43:30,079
will not go in all the details uh but

1242
00:43:30,079 --> 00:43:32,400
will i will give will give you the idea

1243
00:43:32,400 --> 00:43:33,119
how

1244
00:43:33,119 --> 00:43:36,560
uh we constructed uh for the preserving

1245
00:43:36,560 --> 00:43:37,440
scheme

1246
00:43:37,440 --> 00:43:41,920
so we observed that there is a bijection

1247
00:43:41,920 --> 00:43:44,319
between a set of all of the preserving

1248
00:43:44,319 --> 00:43:47,280
functions from a certain domain uh to

1249
00:43:47,280 --> 00:43:49,359
certain range m m

1250
00:43:49,359 --> 00:43:54,000
to the set of m out of n combinations

1251
00:43:54,000 --> 00:43:55,119
right so

1252
00:43:55,119 --> 00:43:58,079
if you see like on the left if you have

1253
00:43:58,079 --> 00:43:59,920
like total number of this points blue

1254
00:43:59,920 --> 00:44:01,599
and yellow but then

1255
00:44:01,599 --> 00:44:04,480
you pick certain number of blue points

1256
00:44:04,480 --> 00:44:06,640
and then place them there it defines

1257
00:44:06,640 --> 00:44:08,560
some of the preserving function

1258
00:44:08,560 --> 00:44:12,480
okay so there is this correlation

1259
00:44:16,160 --> 00:44:18,560
oops

1260
00:44:20,640 --> 00:44:24,319
there are some slides missing

1261
00:44:25,200 --> 00:44:27,520
oh

1262
00:44:28,880 --> 00:44:30,480
sorry uh

1263
00:44:30,480 --> 00:44:33,280
i i don't have time right now i have uh

1264
00:44:33,280 --> 00:44:35,440
a little bit more detail on how i build

1265
00:44:35,440 --> 00:44:37,920
it but okay i'll tell you again without

1266
00:44:37,920 --> 00:44:39,599
the slides that

1267
00:44:39,599 --> 00:44:41,839
uh

1268
00:44:44,000 --> 00:44:46,160
so there is a

1269
00:44:46,160 --> 00:44:47,599
distribution

1270
00:44:47,599 --> 00:44:49,839
uh which

1271
00:44:49,839 --> 00:44:51,280
kind of

1272
00:44:51,280 --> 00:44:55,119
follows what you need uh

1273
00:44:55,280 --> 00:44:57,599
to pick this combinations

1274
00:44:57,599 --> 00:44:58,400
right

1275
00:44:58,400 --> 00:44:59,280
uh

1276
00:44:59,280 --> 00:45:01,839
negative hypergeometric distribution and

1277
00:45:01,839 --> 00:45:03,760
there is an efficient algorithm which

1278
00:45:03,760 --> 00:45:06,319
allows you to sample it and by sampling

1279
00:45:06,319 --> 00:45:10,400
it basically uh well using it we can

1280
00:45:10,400 --> 00:45:12,880
just figure out

1281
00:45:12,880 --> 00:45:16,400
the right numbers which can help us to

1282
00:45:16,400 --> 00:45:18,960
what comes to encrypt each number

1283
00:45:18,960 --> 00:45:20,720
the problem is that of course the

1284
00:45:20,720 --> 00:45:23,200
sampling algorithm is randomized and you

1285
00:45:23,200 --> 00:45:25,760
cannot just call it uh because there

1286
00:45:25,760 --> 00:45:27,040
will be no

1287
00:45:27,040 --> 00:45:29,280
it will not be coherent if you want to

1288
00:45:29,280 --> 00:45:31,359
encrypt different points right because

1289
00:45:31,359 --> 00:45:33,920
it's only like one time

1290
00:45:33,920 --> 00:45:36,960
but if you keep some state

1291
00:45:36,960 --> 00:45:40,560
uh and do it consistently

1292
00:45:40,560 --> 00:45:42,400
then you can do it for example in the

1293
00:45:42,400 --> 00:45:45,280
binary search manner and let's assume

1294
00:45:45,280 --> 00:45:47,040
for now that your state you're

1295
00:45:47,040 --> 00:45:49,520
remembering the randomness used to

1296
00:45:49,520 --> 00:45:50,720
sample

1297
00:45:50,720 --> 00:45:53,440
and basically i just do in the binary

1298
00:45:53,440 --> 00:45:55,839
search manner in order to encrypt any

1299
00:45:55,839 --> 00:45:58,839
point i divide i divide my domain in

1300
00:45:58,839 --> 00:46:02,079
half call that sampling function that

1301
00:46:02,079 --> 00:46:04,880
gives me a ciphertext encryption of the

1302
00:46:04,880 --> 00:46:06,880
middle point

1303
00:46:06,880 --> 00:46:08,240
then

1304
00:46:08,240 --> 00:46:09,760
uh

1305
00:46:09,760 --> 00:46:11,520
depending where

1306
00:46:11,520 --> 00:46:13,920
the point i want to really encrypt

1307
00:46:13,920 --> 00:46:15,599
whether it's to the left or to the right

1308
00:46:15,599 --> 00:46:17,839
i go to the left to the right

1309
00:46:17,839 --> 00:46:21,440
and then i recalculate my new domain and

1310
00:46:21,440 --> 00:46:23,839
range called the sampling again

1311
00:46:23,839 --> 00:46:26,079
remember the randomness

1312
00:46:26,079 --> 00:46:28,160
uh and then basically go go in the

1313
00:46:28,160 --> 00:46:31,119
binary search and next time i use the

1314
00:46:31,119 --> 00:46:33,359
same randomness so this middle point so

1315
00:46:33,359 --> 00:46:35,359
everything will be consistent and

1316
00:46:35,359 --> 00:46:37,520
finally to remove the state of the

1317
00:46:37,520 --> 00:46:40,800
randomness uh you just pretty much use

1318
00:46:40,800 --> 00:46:41,599
uh

1319
00:46:41,599 --> 00:46:44,240
a prf function uh

1320
00:46:44,240 --> 00:46:47,200
and which is very easy and that's why

1321
00:46:47,200 --> 00:46:48,720
that's how you build

1322
00:46:48,720 --> 00:46:49,760
uh

1323
00:46:49,760 --> 00:46:51,359
you know the preserving encryption and

1324
00:46:51,359 --> 00:46:53,839
you can prove it's a secure

1325
00:46:53,839 --> 00:46:56,079
uh

1326
00:46:56,079 --> 00:46:58,560
opera

1327
00:46:58,560 --> 00:47:02,319
and i but of course uh so in i'm so

1328
00:47:02,319 --> 00:47:05,520
sorry i'm missing let me

1329
00:47:06,880 --> 00:47:07,760
ah

1330
00:47:07,760 --> 00:47:09,599
they're probably hidden the slides just

1331
00:47:09,599 --> 00:47:10,880
a few points

1332
00:47:10,880 --> 00:47:12,079
uh

1333
00:47:12,079 --> 00:47:15,119
i'll tell you in words that

1334
00:47:15,119 --> 00:47:17,520
of course security is weak and i

1335
00:47:17,520 --> 00:47:19,520
remember that my student was given a

1336
00:47:19,520 --> 00:47:21,680
talk and i think the script

1337
00:47:21,680 --> 00:47:25,359
uh but one prominent cryptographer likes

1338
00:47:25,359 --> 00:47:27,200
looked at that and i remember he was

1339
00:47:27,200 --> 00:47:29,599
turning to his friend and saying like

1340
00:47:29,599 --> 00:47:31,119
what is that

1341
00:47:31,119 --> 00:47:33,599
because the security is weak

1342
00:47:33,599 --> 00:47:34,720
uh

1343
00:47:34,720 --> 00:47:37,440
water is leaking but it it may be hard

1344
00:47:37,440 --> 00:47:39,839
to assess at first because it seems like

1345
00:47:39,839 --> 00:47:42,079
it's the best you can get

1346
00:47:42,079 --> 00:47:44,640
but in later paper we

1347
00:47:44,640 --> 00:47:46,960
analyze more precisely

1348
00:47:46,960 --> 00:47:47,839
uh

1349
00:47:47,839 --> 00:47:50,160
what security even the ideal object

1350
00:47:50,160 --> 00:47:51,440
online

1351
00:47:51,440 --> 00:47:52,720
random

1352
00:47:52,720 --> 00:47:55,599
order preserving random function

1353
00:47:55,599 --> 00:47:59,119
uh what it gives and it turns out that

1354
00:47:59,119 --> 00:48:02,160
yes that you can get one wayness

1355
00:48:02,160 --> 00:48:05,520
some sort of one awayness yes

1356
00:48:05,520 --> 00:48:08,000
but if you look closer

1357
00:48:08,000 --> 00:48:09,119
any

1358
00:48:09,119 --> 00:48:10,319
uh

1359
00:48:10,319 --> 00:48:11,920
secure

1360
00:48:11,920 --> 00:48:14,000
for the preserving encryption because of

1361
00:48:14,000 --> 00:48:15,760
any random

1362
00:48:15,760 --> 00:48:17,839
or the preserving function licks about

1363
00:48:17,839 --> 00:48:19,680
half of the bits

1364
00:48:19,680 --> 00:48:22,480
right so that's uh

1365
00:48:22,480 --> 00:48:24,240
that's a lot probably it's a lot and

1366
00:48:24,240 --> 00:48:27,200
then the papers also we always said like

1367
00:48:27,200 --> 00:48:30,079
uh we don't recommend the practical use

1368
00:48:30,079 --> 00:48:31,200
of that

1369
00:48:31,200 --> 00:48:34,400
uh before most studies are done

1370
00:48:34,400 --> 00:48:36,960
and in general deterministic encryption

1371
00:48:36,960 --> 00:48:38,800
and all the preserve encryptions

1372
00:48:38,800 --> 00:48:41,680
they are examples of what's called

1373
00:48:41,680 --> 00:48:44,480
property preserving encryption

1374
00:48:44,480 --> 00:48:47,440
uh they were

1375
00:48:47,440 --> 00:48:50,720
that was formalized by panda at all uh

1376
00:48:50,720 --> 00:48:52,400
meaning

1377
00:48:52,400 --> 00:48:54,400
you leak some

1378
00:48:54,400 --> 00:48:58,079
property such as equality such as order

1379
00:48:58,079 --> 00:49:00,480
can be something else can be distance

1380
00:49:00,480 --> 00:49:03,119
can be some notion of similarity and so

1381
00:49:03,119 --> 00:49:04,480
forth

1382
00:49:04,480 --> 00:49:06,800
and of course these schemes very

1383
00:49:06,800 --> 00:49:08,720
naturally fit

1384
00:49:08,720 --> 00:49:11,599
encrypted search because they can leak

1385
00:49:11,599 --> 00:49:14,240
exactly what you need

1386
00:49:14,240 --> 00:49:16,720
to search to work on right whether

1387
00:49:16,720 --> 00:49:20,400
that's it's a quality order and so forth

1388
00:49:20,400 --> 00:49:22,720
um

1389
00:49:23,680 --> 00:49:25,359
and in general by the way for

1390
00:49:25,359 --> 00:49:27,200
deterministic encryption and order

1391
00:49:27,200 --> 00:49:29,839
preserving encryption

1392
00:49:29,839 --> 00:49:31,760
ciphertext immediately leaked this

1393
00:49:31,760 --> 00:49:33,760
property but in general there may be

1394
00:49:33,760 --> 00:49:36,240
some function which takes ciphertext

1395
00:49:36,240 --> 00:49:38,240
somewhat processes them and then the

1396
00:49:38,240 --> 00:49:40,319
property is written

1397
00:49:40,319 --> 00:49:43,319
um

1398
00:49:44,079 --> 00:49:45,520
and

1399
00:49:45,520 --> 00:49:46,559
because

1400
00:49:46,559 --> 00:49:48,720
property pressure encryption fits so

1401
00:49:48,720 --> 00:49:51,200
nicely the functionality of encrypted

1402
00:49:51,200 --> 00:49:52,079
search

1403
00:49:52,079 --> 00:49:53,839
people wanted to

1404
00:49:53,839 --> 00:49:55,280
use them

1405
00:49:55,280 --> 00:49:57,599
and

1406
00:49:57,599 --> 00:50:00,800
the schemes were deployed by at least

1407
00:50:00,800 --> 00:50:05,920
cryptodb and a couple of startups uh

1408
00:50:05,920 --> 00:50:08,079
skyhigh networks used them they were

1409
00:50:08,079 --> 00:50:10,839
implemented in cyphercloud

1410
00:50:10,839 --> 00:50:14,240
and when we learned this i'm not sure we

1411
00:50:14,240 --> 00:50:16,240
were exactly happy we were scared

1412
00:50:16,240 --> 00:50:17,359
because

1413
00:50:17,359 --> 00:50:19,440
that's the

1414
00:50:19,440 --> 00:50:21,200
but they thought like it's still they

1415
00:50:21,200 --> 00:50:23,119
said like it's okay it's okay because

1416
00:50:23,119 --> 00:50:26,000
it's better than nothing

1417
00:50:26,000 --> 00:50:28,400
but are we really sure it's better than

1418
00:50:28,400 --> 00:50:31,520
nothing and it may not be better than uh

1419
00:50:31,520 --> 00:50:33,359
not encrypting data because if you don't

1420
00:50:33,359 --> 00:50:35,760
encrypt you don't expect security

1421
00:50:35,760 --> 00:50:38,240
but they if you phrase it that here we

1422
00:50:38,240 --> 00:50:40,640
use some probable secure which is true

1423
00:50:40,640 --> 00:50:42,400
these are probably secure schemes but

1424
00:50:42,400 --> 00:50:43,839
that really matters under which

1425
00:50:43,839 --> 00:50:45,680
definitions right

1426
00:50:45,680 --> 00:50:47,520
so

1427
00:50:47,520 --> 00:50:49,920
we're probably not so sure it's a good

1428
00:50:49,920 --> 00:50:51,359
idea

1429
00:50:51,359 --> 00:50:54,640
and not surprisingly unsenny mentioned

1430
00:50:54,640 --> 00:50:55,680
uh

1431
00:50:55,680 --> 00:50:57,839
some of this work so maybe all of this

1432
00:50:57,839 --> 00:51:00,640
works and more that of course attacks

1433
00:51:00,640 --> 00:51:01,839
followed

1434
00:51:01,839 --> 00:51:03,839
uh they were not surprising to

1435
00:51:03,839 --> 00:51:05,680
cryptographers

1436
00:51:05,680 --> 00:51:07,359
uh but

1437
00:51:07,359 --> 00:51:10,319
they very clearly showed that

1438
00:51:10,319 --> 00:51:12,480
property-preserved encryption

1439
00:51:12,480 --> 00:51:14,319
leaking this

1440
00:51:14,319 --> 00:51:15,200
uh

1441
00:51:15,200 --> 00:51:18,079
equality patterns and

1442
00:51:18,079 --> 00:51:19,680
like order

1443
00:51:19,680 --> 00:51:20,800
is

1444
00:51:20,800 --> 00:51:22,800
uh is dangerous

1445
00:51:22,800 --> 00:51:25,280
especially if you know some information

1446
00:51:25,280 --> 00:51:27,760
about the distribution of the data then

1447
00:51:27,760 --> 00:51:29,280
the attacks can be

1448
00:51:29,280 --> 00:51:31,520
really devastating and they show that

1449
00:51:31,520 --> 00:51:34,800
for some practical examples maybe

1450
00:51:34,800 --> 00:51:37,119
medical records and so forth you may

1451
00:51:37,119 --> 00:51:38,800
know this distribution and then you

1452
00:51:38,800 --> 00:51:42,720
pretty much can recover the whole data

1453
00:51:42,960 --> 00:51:45,280
and

1454
00:51:45,839 --> 00:51:47,839
why

1455
00:51:47,839 --> 00:51:49,680
uh and of course

1456
00:51:49,680 --> 00:51:51,599
then

1457
00:51:51,599 --> 00:51:52,720
there were

1458
00:51:52,720 --> 00:51:56,000
some atta some papers trying

1459
00:51:56,000 --> 00:51:56,800
uh

1460
00:51:56,800 --> 00:51:58,960
to fix this or maybe

1461
00:51:58,960 --> 00:52:00,960
create a secure schemes when you don't

1462
00:52:00,960 --> 00:52:03,680
know the distribution and some works of

1463
00:52:03,680 --> 00:52:06,319
adam on the distribution hiding work as

1464
00:52:06,319 --> 00:52:09,440
one of this example

1465
00:52:10,960 --> 00:52:11,920
but

1466
00:52:11,920 --> 00:52:14,240
then

1467
00:52:15,200 --> 00:52:17,920
there is now a moving to the next class

1468
00:52:17,920 --> 00:52:19,599
of works i'm not going to talk in much

1469
00:52:19,599 --> 00:52:24,480
detail but then maybe one wayness uh

1470
00:52:24,480 --> 00:52:27,440
is not enough and this it's nice not to

1471
00:52:27,440 --> 00:52:29,440
do any changes on the server side but

1472
00:52:29,440 --> 00:52:32,319
probably we have to at least for the

1473
00:52:32,319 --> 00:52:35,040
semantic security against snap snapshot

1474
00:52:35,040 --> 00:52:38,319
adversary uh that's what

1475
00:52:38,319 --> 00:52:41,520
encrypted index-based schemes

1476
00:52:41,520 --> 00:52:45,520
uh are about and so

1477
00:52:45,520 --> 00:52:47,200
here's just uh

1478
00:52:47,200 --> 00:52:48,960
it's not over it's basically the

1479
00:52:48,960 --> 00:52:51,920
functionality is just the client

1480
00:52:51,920 --> 00:52:55,119
takes the data and process it encrypts

1481
00:52:55,119 --> 00:52:57,680
it creates some sort of encrypted index

1482
00:52:57,680 --> 00:52:58,640
and

1483
00:52:58,640 --> 00:53:01,040
uh send this to the server

1484
00:53:01,040 --> 00:53:01,920
uh

1485
00:53:01,920 --> 00:53:04,400
and for the keyword search

1486
00:53:04,400 --> 00:53:05,280
uh

1487
00:53:05,280 --> 00:53:07,440
there will there is an option uh so if

1488
00:53:07,440 --> 00:53:10,880
we wanna search documents by keywords

1489
00:53:10,880 --> 00:53:13,520
so then

1490
00:53:13,520 --> 00:53:15,440
you can

1491
00:53:15,440 --> 00:53:19,280
create an encrypted multi-map where

1492
00:53:19,280 --> 00:53:21,760
you have keywords and the list of

1493
00:53:21,760 --> 00:53:24,240
document identifiers

1494
00:53:24,240 --> 00:53:27,520
uh that will be the index uh but later

1495
00:53:27,520 --> 00:53:29,599
by the identifiers you can search the

1496
00:53:29,599 --> 00:53:31,040
documents

1497
00:53:31,040 --> 00:53:31,839
and

1498
00:53:31,839 --> 00:53:34,480
there is a

1499
00:53:35,760 --> 00:53:38,559
there are there are numerous

1500
00:53:38,559 --> 00:53:40,480
works uh

1501
00:53:40,480 --> 00:53:42,960
about this encrypted index search and

1502
00:53:42,960 --> 00:53:45,599
senny mentioned many of them uh the

1503
00:53:45,599 --> 00:53:48,559
classical one of court mullet all promo

1504
00:53:48,559 --> 00:53:49,440
six

1505
00:53:49,440 --> 00:53:51,680
and there are other papers and here i

1506
00:53:51,680 --> 00:53:55,119
mentioned cash and others papers for

1507
00:53:55,119 --> 00:53:57,280
uh

1508
00:53:57,280 --> 00:53:58,559
search which

1509
00:53:58,559 --> 00:54:01,680
scales well and for more dynamic schemes

1510
00:54:01,680 --> 00:54:03,520
but there are many many other

1511
00:54:03,520 --> 00:54:05,119
things so

1512
00:54:05,119 --> 00:54:06,880
security and i'm not going to talk about

1513
00:54:06,880 --> 00:54:09,760
the details here uh it just to mention

1514
00:54:09,760 --> 00:54:11,839
that

1515
00:54:12,319 --> 00:54:15,040
security here is better definitely than

1516
00:54:15,040 --> 00:54:17,599
property preserving schemes because

1517
00:54:17,599 --> 00:54:20,000
uh the snapshot adversary who just looks

1518
00:54:20,000 --> 00:54:21,040
at the

1519
00:54:21,040 --> 00:54:22,880
encrypted data

1520
00:54:22,880 --> 00:54:24,559
doesn't learn anything

1521
00:54:24,559 --> 00:54:26,319
which is good

1522
00:54:26,319 --> 00:54:28,160
but again probably we should be

1523
00:54:28,160 --> 00:54:30,800
concerned about strong attacks

1524
00:54:30,800 --> 00:54:35,440
uh but security can be quite good uh and

1525
00:54:35,440 --> 00:54:39,839
the functionality is not bad either

1526
00:54:40,640 --> 00:54:43,280
yeah but security is questionable

1527
00:54:43,280 --> 00:54:44,720
because

1528
00:54:44,720 --> 00:54:47,280
attacks

1529
00:54:47,280 --> 00:54:50,400
exist even for schemes like that

1530
00:54:50,400 --> 00:54:52,720
and the problem is that

1531
00:54:52,720 --> 00:54:53,680
uh

1532
00:54:53,680 --> 00:54:56,480
and i think just because the attackers

1533
00:54:56,480 --> 00:54:58,799
may be able to do more just

1534
00:54:58,799 --> 00:55:01,599
look on the encrypted data because what

1535
00:55:01,599 --> 00:55:03,680
if the the attacker is somewhat more

1536
00:55:03,680 --> 00:55:05,760
active what if the attacker is able to

1537
00:55:05,760 --> 00:55:08,079
see the queries what if the attacker can

1538
00:55:08,079 --> 00:55:10,079
able to see the responses and the

1539
00:55:10,079 --> 00:55:12,000
communication between the client and

1540
00:55:12,000 --> 00:55:13,599
server it's

1541
00:55:13,599 --> 00:55:16,000
it seems reasonable

1542
00:55:16,000 --> 00:55:17,280
and

1543
00:55:17,280 --> 00:55:18,160
the

1544
00:55:18,160 --> 00:55:19,200
attack

1545
00:55:19,200 --> 00:55:21,280
attacks exploited

1546
00:55:21,280 --> 00:55:23,280
what can be leaked and what is leaked by

1547
00:55:23,280 --> 00:55:27,599
most many of encrypted search schemes

1548
00:55:27,599 --> 00:55:32,000
so it may sound natural that

1549
00:55:32,000 --> 00:55:33,680
you can

1550
00:55:33,680 --> 00:55:36,559
see whether the same query repeats

1551
00:55:36,559 --> 00:55:37,520
right

1552
00:55:37,520 --> 00:55:39,280
uh but

1553
00:55:39,280 --> 00:55:41,520
and also it seems natural of course you

1554
00:55:41,520 --> 00:55:43,760
can see which part which ciphertext i

1555
00:55:43,760 --> 00:55:46,160
return for each query what how else

1556
00:55:46,160 --> 00:55:46,960
right

1557
00:55:46,960 --> 00:55:49,359
and of course you can it sounds fine

1558
00:55:49,359 --> 00:55:51,920
that you see the how many ciphertexts

1559
00:55:51,920 --> 00:55:54,640
that returns for each query how else

1560
00:55:54,640 --> 00:55:57,200
uh and this is what i refer to query

1561
00:55:57,200 --> 00:55:59,440
access and volume patterns

1562
00:55:59,440 --> 00:56:02,400
they seem innocuous but there were talks

1563
00:56:02,400 --> 00:56:04,079
showing that from

1564
00:56:04,079 --> 00:56:05,599
seeing just that

1565
00:56:05,599 --> 00:56:08,319
nothing about the data no no particular

1566
00:56:08,319 --> 00:56:11,280
plaintext just seeing those patterns

1567
00:56:11,280 --> 00:56:14,559
you can learn a lot about the data

1568
00:56:14,559 --> 00:56:15,440
okay

1569
00:56:15,440 --> 00:56:16,960
so

1570
00:56:16,960 --> 00:56:19,359
um

1571
00:56:19,839 --> 00:56:21,680
so that shows that it seems like

1572
00:56:21,680 --> 00:56:23,680
snapshot attacks

1573
00:56:23,680 --> 00:56:27,200
security is definitely too weak and we

1574
00:56:27,200 --> 00:56:28,960
probably should be concerned about

1575
00:56:28,960 --> 00:56:31,839
leaking these patterns

1576
00:56:31,839 --> 00:56:34,960
but then what do we do

1577
00:56:37,440 --> 00:56:40,400
and in the recent

1578
00:56:40,400 --> 00:56:41,920
years

1579
00:56:41,920 --> 00:56:44,960
there has been growing interest in

1580
00:56:44,960 --> 00:56:47,119
building something very very secure

1581
00:56:47,119 --> 00:56:50,000
because again we hear about all these

1582
00:56:50,000 --> 00:56:52,000
attacks and

1583
00:56:52,000 --> 00:56:54,960
can we protect against them uh that

1584
00:56:54,960 --> 00:56:57,280
would be more responsible

1585
00:56:57,280 --> 00:56:59,119
and

1586
00:56:59,119 --> 00:57:00,960
there are more to the so there were like

1587
00:57:00,960 --> 00:57:03,839
leakage suppression works when we can we

1588
00:57:03,839 --> 00:57:05,680
know about some leakage and can we

1589
00:57:05,680 --> 00:57:07,040
suppress it

1590
00:57:07,040 --> 00:57:08,000
uh

1591
00:57:08,000 --> 00:57:10,400
also and this is about functionality

1592
00:57:10,400 --> 00:57:13,119
many works are for static databases when

1593
00:57:13,119 --> 00:57:15,280
you take your data encrypt and then you

1594
00:57:15,280 --> 00:57:18,000
query but in practice don't we want to

1595
00:57:18,000 --> 00:57:21,040
add some data delete some data so that's

1596
00:57:21,040 --> 00:57:23,520
dynamic databases and actually that

1597
00:57:23,520 --> 00:57:26,319
affects security you may when you do

1598
00:57:26,319 --> 00:57:30,160
stuff like this updates and so forth uh

1599
00:57:30,160 --> 00:57:33,920
you also there is some security issues

1600
00:57:33,920 --> 00:57:36,000
associated with that

1601
00:57:36,000 --> 00:57:38,079
so

1602
00:57:38,079 --> 00:57:40,400
and that's when actually with the kind

1603
00:57:40,400 --> 00:57:43,040
of help not help or like vision of my

1604
00:57:43,040 --> 00:57:45,599
student attention student at the time

1605
00:57:45,599 --> 00:57:46,960
she graduated

1606
00:57:46,960 --> 00:57:50,559
uh so she was very determined to try to

1607
00:57:50,559 --> 00:57:52,799
pursue to build something with very very

1608
00:57:52,799 --> 00:57:54,400
strong security

1609
00:57:54,400 --> 00:57:57,280
uh because we thought these attacks are

1610
00:57:57,280 --> 00:57:59,680
scary and let's see what we can do to

1611
00:57:59,680 --> 00:58:02,720
avoid this attacks so she really uh kind

1612
00:58:02,720 --> 00:58:04,480
of convinced me

1613
00:58:04,480 --> 00:58:06,960
uh to shift from like something very

1614
00:58:06,960 --> 00:58:09,760
fast and very low security we decided to

1615
00:58:09,760 --> 00:58:11,760
look in the other spectrum how can we

1616
00:58:11,760 --> 00:58:14,400
build something where it's very secure

1617
00:58:14,400 --> 00:58:16,720
probably we cannot expect it to be very

1618
00:58:16,720 --> 00:58:21,040
fast but cannot be reasonably secure and

1619
00:58:21,040 --> 00:58:22,400
i'm not a practitioner

1620
00:58:22,400 --> 00:58:24,720
i don't have a sense of what reasonable

1621
00:58:24,720 --> 00:58:26,880
is probably it's not going to be fast to

1622
00:58:26,880 --> 00:58:29,920
be deployed but still uh something we

1623
00:58:29,920 --> 00:58:32,240
can implement and test and see how it's

1624
00:58:32,240 --> 00:58:33,440
working

1625
00:58:33,440 --> 00:58:35,680
uh so of course we are not the first to

1626
00:58:35,680 --> 00:58:37,680
look at this there were already tons of

1627
00:58:37,680 --> 00:58:40,480
work in this uh very strong building

1628
00:58:40,480 --> 00:58:43,440
very strong security encrypted search

1629
00:58:43,440 --> 00:58:44,960
schemes

1630
00:58:44,960 --> 00:58:46,160
oh okay

1631
00:58:46,160 --> 00:58:46,960
okay

1632
00:58:46,960 --> 00:58:49,280
and

1633
00:58:49,680 --> 00:58:50,880
so but

1634
00:58:50,880 --> 00:58:51,760
some

1635
00:58:51,760 --> 00:58:53,839
most of them use some very strong

1636
00:58:53,839 --> 00:58:56,400
thinking such as oram and stuff we

1637
00:58:56,400 --> 00:58:57,760
thought it's okay

1638
00:58:57,760 --> 00:58:59,359
uh but

1639
00:58:59,359 --> 00:59:01,839
most of them still leaked something and

1640
00:59:01,839 --> 00:59:04,319
we were determined to like avoid the

1641
00:59:04,319 --> 00:59:07,440
leakage there were basically two works

1642
00:59:07,440 --> 00:59:08,400
uh

1643
00:59:08,400 --> 00:59:10,559
for dynamic schemes with very strong

1644
00:59:10,559 --> 00:59:12,880
security where you don't leak query

1645
00:59:12,880 --> 00:59:15,200
access or volume patterns and of course

1646
00:59:15,200 --> 00:59:17,040
hide about the data

1647
00:59:17,040 --> 00:59:18,880
so one is

1648
00:59:18,880 --> 00:59:21,920
uh senior tariq's work uh

1649
00:59:21,920 --> 00:59:22,960
on

1650
00:59:22,960 --> 00:59:25,680
dynamic databases where they

1651
00:59:25,680 --> 00:59:26,880
compile

1652
00:59:26,880 --> 00:59:29,280
and suppress all the leakage

1653
00:59:29,280 --> 00:59:33,359
and another workers sure and all uh it's

1654
00:59:33,359 --> 00:59:34,960
actually baseline it's a very

1655
00:59:34,960 --> 00:59:36,960
straightforward approach it's like what

1656
00:59:36,960 --> 00:59:39,680
about we just on each query you download

1657
00:59:39,680 --> 00:59:43,200
the whole database and do looks

1658
00:59:43,200 --> 00:59:45,359
locally right

1659
00:59:45,359 --> 00:59:47,200
very straightforward

1660
00:59:47,200 --> 00:59:48,880
but secure

1661
00:59:48,880 --> 00:59:49,760
but

1662
00:59:49,760 --> 00:59:51,359
if you want to try to do something it

1663
00:59:51,359 --> 00:59:53,520
should be more efficient than this of

1664
00:59:53,520 --> 00:59:54,799
course right

1665
00:59:54,799 --> 00:59:57,040
so that's what we wanted to do

1666
00:59:57,040 --> 00:59:59,680
uh construct something

1667
00:59:59,680 --> 01:00:02,480
with very very strong security

1668
01:00:02,480 --> 01:00:04,480
and

1669
01:00:04,480 --> 01:00:07,920
most works uh focus on just the first

1670
01:00:07,920 --> 01:00:09,839
stage this encrypted multi-map the

1671
01:00:09,839 --> 01:00:10,880
mapping

1672
01:00:10,880 --> 01:00:12,799
secure mapping

1673
01:00:12,799 --> 01:00:15,359
between the keywords and document

1674
01:00:15,359 --> 01:00:16,880
identifiers

1675
01:00:16,880 --> 01:00:18,720
we think it's very important also to

1676
01:00:18,720 --> 01:00:21,119
focus on the second stage and uh i'll

1677
01:00:21,119 --> 01:00:23,119
let me mention this but now i'm also

1678
01:00:23,119 --> 01:00:26,799
talking about this first stage so

1679
01:00:26,799 --> 01:00:29,359
it's encrypted multi-map that's what

1680
01:00:29,359 --> 01:00:32,400
this uh encrypted index is and we wanted

1681
01:00:32,400 --> 01:00:34,880
to build something with very very strong

1682
01:00:34,880 --> 01:00:37,520
security

1683
01:00:37,680 --> 01:00:39,680
and this is about syntax and i'll just

1684
01:00:39,680 --> 01:00:41,520
give you some ideas i don't have much

1685
01:00:41,520 --> 01:00:43,760
time so you want to encrypt and you want

1686
01:00:43,760 --> 01:00:46,359
access that's just some

1687
01:00:46,359 --> 01:00:49,520
functionality we want for the security

1688
01:00:49,520 --> 01:00:50,400
uh

1689
01:00:50,400 --> 01:00:51,280
we

1690
01:00:51,280 --> 01:00:53,839
adopted the structured encryption

1691
01:00:53,839 --> 01:00:54,839
encryption

1692
01:00:54,839 --> 01:00:57,200
definition uh

1693
01:00:57,200 --> 01:01:00,799
byzanian tariq from 18

1694
01:01:00,799 --> 01:01:01,760
and

1695
01:01:01,760 --> 01:01:04,960
we did model honest by curious adversary

1696
01:01:04,960 --> 01:01:06,960
which is like seems all of the

1697
01:01:06,960 --> 01:01:10,799
oram-based uh works are focusing on

1698
01:01:10,799 --> 01:01:13,040
um

1699
01:01:13,599 --> 01:01:15,839
so oram it's

1700
01:01:15,839 --> 01:01:17,680
basically uh

1701
01:01:17,680 --> 01:01:22,000
oblivious array you cannot you can

1702
01:01:22,000 --> 01:01:24,000
you can have it's an array it's an

1703
01:01:24,000 --> 01:01:25,599
encrypted area you can have oblivious

1704
01:01:25,599 --> 01:01:26,559
access

1705
01:01:26,559 --> 01:01:28,160
uh to it

1706
01:01:28,160 --> 01:01:30,480
and many works use it

1707
01:01:30,480 --> 01:01:33,359
uh and we wanted to use it too

1708
01:01:33,359 --> 01:01:35,200
um

1709
01:01:35,200 --> 01:01:36,799
and

1710
01:01:36,799 --> 01:01:38,799
there are some

1711
01:01:38,799 --> 01:01:41,200
reasonably efficient uh implementations

1712
01:01:41,200 --> 01:01:43,920
so for ramps so that's fine

1713
01:01:43,920 --> 01:01:46,240
um

1714
01:01:46,720 --> 01:01:48,400
so and send you mentioned like you

1715
01:01:48,400 --> 01:01:51,359
cannot easily use oram as this you need

1716
01:01:51,359 --> 01:01:53,280
some tricks because like

1717
01:01:53,280 --> 01:01:56,000
if the client doesn't have much storage

1718
01:01:56,000 --> 01:01:57,520
you cannot store

1719
01:01:57,520 --> 01:02:00,720
relations between the keywords and

1720
01:02:00,720 --> 01:02:03,359
the around blocks

1721
01:02:03,359 --> 01:02:05,280
um

1722
01:02:05,280 --> 01:02:07,520
also there are constructions there are

1723
01:02:07,520 --> 01:02:10,960
ram-based constructions but most of them

1724
01:02:10,960 --> 01:02:12,400
do not

1725
01:02:12,400 --> 01:02:14,559
have volume hiding

1726
01:02:14,559 --> 01:02:16,079
and as i mentioned there were some

1727
01:02:16,079 --> 01:02:18,559
attacks exploiting that and we wanted to

1728
01:02:18,559 --> 01:02:21,039
hide that and

1729
01:02:21,039 --> 01:02:23,599
if you take the existing works

1730
01:02:23,599 --> 01:02:24,559
uh

1731
01:02:24,559 --> 01:02:27,440
for example the seal for example work uh

1732
01:02:27,440 --> 01:02:30,160
if you simply patch to prevent volume

1733
01:02:30,160 --> 01:02:32,319
hiding uh then

1734
01:02:32,319 --> 01:02:34,720
we'll we tried and you see like it's not

1735
01:02:34,720 --> 01:02:37,200
it's gonna be so inefficient it's gonna

1736
01:02:37,200 --> 01:02:39,200
it's not gonna be efficient so

1737
01:02:39,200 --> 01:02:41,680
something something else

1738
01:02:41,680 --> 01:02:43,280
uh was needed

1739
01:02:43,280 --> 01:02:44,799
and

1740
01:02:44,799 --> 01:02:45,599
so

1741
01:02:45,599 --> 01:02:48,799
what we did uh is the following

1742
01:02:48,799 --> 01:02:50,160
um

1743
01:02:50,160 --> 01:02:53,200
maybe i have a picture maybe it will

1744
01:02:53,200 --> 01:02:53,980
show you oh

1745
01:02:53,980 --> 01:02:57,099
[Music]

1746
01:02:57,680 --> 01:03:00,960
sorry okay here uh yeah

1747
01:03:00,960 --> 01:03:02,400
so what we did

1748
01:03:02,400 --> 01:03:04,480
uh is the following

1749
01:03:04,480 --> 01:03:06,640
for

1750
01:03:06,640 --> 01:03:08,559
for each keyword

1751
01:03:08,559 --> 01:03:09,680
uh

1752
01:03:09,680 --> 01:03:10,799
we

1753
01:03:10,799 --> 01:03:11,920
the tuple

1754
01:03:11,920 --> 01:03:15,520
contains the document identifiers

1755
01:03:15,520 --> 01:03:16,720
we

1756
01:03:16,720 --> 01:03:19,280
we pad them to some maximum length of

1757
01:03:19,280 --> 01:03:21,520
that how many maximum number of keyword

1758
01:03:21,520 --> 01:03:23,839
documents can be associated with the

1759
01:03:23,839 --> 01:03:25,039
keyword

1760
01:03:25,039 --> 01:03:26,000
uh

1761
01:03:26,000 --> 01:03:28,640
and for each keyword there is a block in

1762
01:03:28,640 --> 01:03:31,119
our ram we store it on oram

1763
01:03:31,119 --> 01:03:32,160
uh

1764
01:03:32,160 --> 01:03:34,319
then

1765
01:03:34,319 --> 01:03:36,799
you need to know where it's stored right

1766
01:03:36,799 --> 01:03:39,920
so you need to have some mapping as i

1767
01:03:39,920 --> 01:03:42,319
mentioned between your keyword and the

1768
01:03:42,319 --> 01:03:45,119
block identifier in oram

1769
01:03:45,119 --> 01:03:48,079
and we store this in another oblivious

1770
01:03:48,079 --> 01:03:51,039
structure called oblivious dictionary

1771
01:03:51,039 --> 01:03:53,599
okay so and that will store

1772
01:03:53,599 --> 01:03:57,359
uh for a rich kill word it will give you

1773
01:03:57,359 --> 01:03:59,520
orange block identifier and you can

1774
01:03:59,520 --> 01:04:01,200
search

1775
01:04:01,200 --> 01:04:03,680
so it works in principle but if you do

1776
01:04:03,680 --> 01:04:06,240
it like this and it's it's

1777
01:04:06,240 --> 01:04:08,079
somewhat straightforward it's not going

1778
01:04:08,079 --> 01:04:09,520
to be efficient

1779
01:04:09,520 --> 01:04:10,640
and

1780
01:04:10,640 --> 01:04:11,839
because

1781
01:04:11,839 --> 01:04:12,799
most

1782
01:04:12,799 --> 01:04:15,839
auram constructions are recursive uh

1783
01:04:15,839 --> 01:04:17,440
they

1784
01:04:17,440 --> 01:04:18,880
they have this

1785
01:04:18,880 --> 01:04:21,440
notion of a position it's an additional

1786
01:04:21,440 --> 01:04:25,440
mapping uh for the oram and they they

1787
01:04:25,440 --> 01:04:27,599
update and store it recursively on the

1788
01:04:27,599 --> 01:04:29,039
server side

1789
01:04:29,039 --> 01:04:31,359
to optimize we

1790
01:04:31,359 --> 01:04:33,839
take those positions and also store them

1791
01:04:33,839 --> 01:04:36,079
in the oblivious dictionary because we

1792
01:04:36,079 --> 01:04:38,400
have them and it makes things more

1793
01:04:38,400 --> 01:04:40,720
efficient in that we do other

1794
01:04:40,720 --> 01:04:44,319
optimizations uh we kind of do several

1795
01:04:44,319 --> 01:04:47,680
operations at once uh and just make sure

1796
01:04:47,680 --> 01:04:50,160
the existing construction support that

1797
01:04:50,160 --> 01:04:53,920
uh but that's that's basically the idea

1798
01:04:53,920 --> 01:04:55,039
okay

1799
01:04:55,039 --> 01:04:56,480
okay then

1800
01:04:56,480 --> 01:04:59,280
and this is uh

1801
01:04:59,280 --> 01:05:01,440
yet unpublished work kind of work in

1802
01:05:01,440 --> 01:05:03,839
progress that's what i'm uh talking to

1803
01:05:03,839 --> 01:05:06,720
you about and then

1804
01:05:06,720 --> 01:05:08,720
we do

1805
01:05:08,720 --> 01:05:10,119
we have uh

1806
01:05:10,119 --> 01:05:12,880
instantiations and we implemented them

1807
01:05:12,880 --> 01:05:14,880
for all of this for encryption

1808
01:05:14,880 --> 01:05:18,079
dictionary and for the oram ivl three

1809
01:05:18,079 --> 01:05:20,000
and skip list for encryption dictionary

1810
01:05:20,000 --> 01:05:22,960
and we picked patharam for the urum

1811
01:05:22,960 --> 01:05:25,359
and we have variations where we hide the

1812
01:05:25,359 --> 01:05:27,599
operation and where we don't hide that

1813
01:05:27,599 --> 01:05:28,720
duration

1814
01:05:28,720 --> 01:05:31,200
uh it's up for the applications and

1815
01:05:31,200 --> 01:05:33,520
where you don't hide it uh

1816
01:05:33,520 --> 01:05:35,280
and most constructions don't you can be

1817
01:05:35,280 --> 01:05:36,880
more efficient

1818
01:05:36,880 --> 01:05:37,839
um

1819
01:05:37,839 --> 01:05:40,480
and we

1820
01:05:40,720 --> 01:05:41,599
the

1821
01:05:41,599 --> 01:05:43,680
the nice thing is that leakage it's

1822
01:05:43,680 --> 01:05:45,680
basically nothing it's just public

1823
01:05:45,680 --> 01:05:48,480
parameters and the uh kind of the up

1824
01:05:48,480 --> 01:05:51,200
about the sizes of the

1825
01:05:51,200 --> 01:05:54,559
biggest database so we think

1826
01:05:54,559 --> 01:05:57,839
security is nice efficiency of course is

1827
01:05:57,839 --> 01:06:00,319
the question we

1828
01:06:00,319 --> 01:06:03,359
implemented our schemes and compared

1829
01:06:03,359 --> 01:06:05,839
efficiency with the other constructions

1830
01:06:05,839 --> 01:06:08,160
baseline

1831
01:06:08,160 --> 01:06:10,880
and the seniors approach

1832
01:06:10,880 --> 01:06:12,480
and

1833
01:06:12,480 --> 01:06:15,680
it's ours is

1834
01:06:15,680 --> 01:06:18,799
clearly more efficient sometimes

1835
01:06:18,799 --> 01:06:20,960
asymptotically not much but the for the

1836
01:06:20,960 --> 01:06:23,280
concrete parameters it is

1837
01:06:23,280 --> 01:06:25,839
overall it's not super fast even though

1838
01:06:25,839 --> 01:06:28,079
we used on the

1839
01:06:28,079 --> 01:06:29,680
on some

1840
01:06:29,680 --> 01:06:32,319
practical benchmarks databases and run

1841
01:06:32,319 --> 01:06:36,400
and loosen and you can see here some

1842
01:06:36,400 --> 01:06:39,280
uh construction so not

1843
01:06:39,280 --> 01:06:41,760
super fast probably not going to be

1844
01:06:41,760 --> 01:06:43,520
deployed

1845
01:06:43,520 --> 01:06:46,079
right away but

1846
01:06:46,079 --> 01:06:48,720
we still think uh

1847
01:06:48,720 --> 01:06:52,319
yeah we still felt it's something

1848
01:06:52,319 --> 01:06:54,319
reasonable achievement

1849
01:06:54,319 --> 01:06:56,720
and

1850
01:06:57,039 --> 01:07:00,160
to conclude okay yeah to be on time i'll

1851
01:07:00,160 --> 01:07:03,200
just skip to the conclusions what kind

1852
01:07:03,200 --> 01:07:05,839
of we saw from all this

1853
01:07:05,839 --> 01:07:07,280
uh

1854
01:07:07,280 --> 01:07:09,680
series of works we did

1855
01:07:09,680 --> 01:07:12,240
is that

1856
01:07:12,240 --> 01:07:13,680
i do believe property prisoner

1857
01:07:13,680 --> 01:07:16,480
encryption is too weak but it's maybe

1858
01:07:16,480 --> 01:07:18,160
used as a building block and other

1859
01:07:18,160 --> 01:07:20,799
constructions which can strengthen

1860
01:07:20,799 --> 01:07:21,680
uh

1861
01:07:21,680 --> 01:07:23,359
security

1862
01:07:23,359 --> 01:07:25,280
um

1863
01:07:25,280 --> 01:07:27,839
for the encrypted index schemes when you

1864
01:07:27,839 --> 01:07:30,079
leak all these patterns

1865
01:07:30,079 --> 01:07:33,599
also the attacks seem convincing to me i

1866
01:07:33,599 --> 01:07:36,960
don't know how practical they are uh

1867
01:07:36,960 --> 01:07:38,480
in

1868
01:07:38,480 --> 01:07:41,920
in reality in real systems but i'm not

1869
01:07:41,920 --> 01:07:43,440
the one to judge

1870
01:07:43,440 --> 01:07:46,640
or to to say they're fine so

1871
01:07:46,640 --> 01:07:48,880
again

1872
01:07:48,880 --> 01:07:50,000
probably

1873
01:07:50,000 --> 01:07:52,720
too weak but then we do have the schemes

1874
01:07:52,720 --> 01:07:54,640
with minimal leakage but they are too

1875
01:07:54,640 --> 01:07:58,400
slow to uh deployment and so my title

1876
01:07:58,400 --> 01:08:00,640
was looking for the suitable balance

1877
01:08:00,640 --> 01:08:03,039
right the traders between security and

1878
01:08:03,039 --> 01:08:04,720
efficiency

1879
01:08:04,720 --> 01:08:06,559
i don't i still don't have dance i

1880
01:08:06,559 --> 01:08:08,240
worked for like many many years on

1881
01:08:08,240 --> 01:08:10,079
searchable encryption i still don't know

1882
01:08:10,079 --> 01:08:12,079
where the right answer is

1883
01:08:12,079 --> 01:08:13,839
uh

1884
01:08:13,839 --> 01:08:16,319
but it gives us more work

1885
01:08:16,319 --> 01:08:17,600
and i'm still

1886
01:08:17,600 --> 01:08:19,920
more interested to

1887
01:08:19,920 --> 01:08:21,920
learn and work on this and maybe one day

1888
01:08:21,920 --> 01:08:23,198
we will know

1889
01:08:23,198 --> 01:08:25,920
uh volume hiding

1890
01:08:25,920 --> 01:08:27,679
that to

1891
01:08:27,679 --> 01:08:30,238
to achieve it it's very expensive in

1892
01:08:30,238 --> 01:08:32,080
terms of uh

1893
01:08:32,080 --> 01:08:36,238
communication and interactions and

1894
01:08:36,238 --> 01:08:37,439
maybe

1895
01:08:37,439 --> 01:08:39,839
the notions of like some weaker volume

1896
01:08:39,839 --> 01:08:42,158
hiding will be sufficient and then we

1897
01:08:42,158 --> 01:08:43,439
can achieve

1898
01:08:43,439 --> 01:08:44,238
uh

1899
01:08:44,238 --> 01:08:47,198
better security but if we are going this

1900
01:08:47,198 --> 01:08:50,319
way back although allowing some leakage

1901
01:08:50,319 --> 01:08:52,319
then the questions are and send you

1902
01:08:52,319 --> 01:08:54,399
mentioned some work saying like complex

1903
01:08:54,399 --> 01:08:56,399
leakage complex leakage it's very very

1904
01:08:56,399 --> 01:08:58,719
common you have some leakage but it's so

1905
01:08:58,719 --> 01:09:02,158
complex even the authors cannot clearly

1906
01:09:02,158 --> 01:09:04,399
explain what exactly it is yes it's

1907
01:09:04,399 --> 01:09:07,359
mathematical like formula but what

1908
01:09:07,359 --> 01:09:09,600
exactly does it mean

1909
01:09:09,600 --> 01:09:11,600
what are the implications how to assess

1910
01:09:11,600 --> 01:09:14,238
this leakage how to quantify it how to

1911
01:09:14,238 --> 01:09:16,640
express it to practitioners and to the

1912
01:09:16,640 --> 01:09:18,880
public sometimes we ourselves don't

1913
01:09:18,880 --> 01:09:20,238
understand very

1914
01:09:20,238 --> 01:09:22,640
well what exactly does it mean so some

1915
01:09:22,640 --> 01:09:25,040
works and like kind of understanding

1916
01:09:25,040 --> 01:09:26,799
leakage and something very interesting

1917
01:09:26,799 --> 01:09:29,359
like can you prove that's sufficient for

1918
01:09:29,359 --> 01:09:31,040
some attacks that that's very

1919
01:09:31,040 --> 01:09:32,560
interesting like

1920
01:09:32,560 --> 01:09:35,040
how to measure it how

1921
01:09:35,040 --> 01:09:36,719
bad is going to be how to compare you

1922
01:09:36,719 --> 01:09:38,238
have this complex leakage and this

1923
01:09:38,238 --> 01:09:40,719
complex leakage how do you compare it

1924
01:09:40,719 --> 01:09:42,238
um

1925
01:09:42,238 --> 01:09:44,080
and also i mentioned like the second

1926
01:09:44,080 --> 01:09:47,120
stage what if your documents have like

1927
01:09:47,120 --> 01:09:48,880
videos or

1928
01:09:48,880 --> 01:09:50,399
photos or

1929
01:09:50,399 --> 01:09:53,759
so you cannot like

1930
01:09:53,759 --> 01:09:55,679
how do you do it like

1931
01:09:55,679 --> 01:09:57,920
you cannot fit at all in the encrypted

1932
01:09:57,920 --> 01:10:00,800
multi-map then you need the second stage

1933
01:10:00,800 --> 01:10:03,280
and then navid

1934
01:10:03,280 --> 01:10:04,960
in 15

1935
01:10:04,960 --> 01:10:07,199
showed that actually if you want to do

1936
01:10:07,199 --> 01:10:09,920
it in the worst case if you use oram for

1937
01:10:09,920 --> 01:10:12,320
strong security it's going to be less

1938
01:10:12,320 --> 01:10:14,239
efficient than downloading the whole

1939
01:10:14,239 --> 01:10:15,760
database

1940
01:10:15,760 --> 01:10:18,000
then

1941
01:10:18,000 --> 01:10:20,880
how do what do we do then so many many

1942
01:10:20,880 --> 01:10:23,760
questions and uh more questions than

1943
01:10:23,760 --> 01:10:25,600
answers uh

1944
01:10:25,600 --> 01:10:26,880
but

1945
01:10:26,880 --> 01:10:28,719
yeah so let's all

1946
01:10:28,719 --> 01:10:30,400
feel let's all

1947
01:10:30,400 --> 01:10:34,559
try to solve that okay thank you

1948
01:10:39,280 --> 01:10:41,280
kistasha

1949
01:10:41,280 --> 01:10:42,960
hopefully we will still have some coffee

1950
01:10:42,960 --> 01:10:45,040
outside so the the coffee break was

1951
01:10:45,040 --> 01:10:47,760
supposed to be from 10 to 10 20.

1952
01:10:47,760 --> 01:10:52,400
so let's maybe uh meet in 20 minutes and

1953
01:10:52,400 --> 01:10:55,120
the second session will start at 10 40

1954
01:10:55,120 --> 01:10:56,640
and the first talk of the second session

1955
01:10:56,640 --> 01:10:59,840
will be marisa

1956
01:11:03,199 --> 01:11:07,120
turns out wasn't my latest file

1957
01:11:07,280 --> 01:11:12,040
i can just leave what you can deliver

1958
01:11:13,760 --> 01:11:17,640
oh you sure

1959
01:44:01,760 --> 01:44:04,760
uh

1960
01:44:09,280 --> 01:44:13,480
i'm gonna do it

1961
01:44:51,199 --> 01:44:53,599
hello

1962
01:45:01,119 --> 01:45:03,839
apparently not

1963
01:45:05,760 --> 01:45:08,080
go back

1964
01:45:10,080 --> 01:45:13,719
we just um

1965
01:45:23,600 --> 01:45:27,400
hello can you hear me

1966
01:45:31,119 --> 01:45:33,040
we're good

1967
01:45:33,040 --> 01:45:34,000
okay

1968
01:45:34,000 --> 01:45:35,920
we think we're good

1969
01:45:35,920 --> 01:45:37,520
all right

1970
01:45:37,520 --> 01:45:40,159
um oh there's a new message in the chat

1971
01:45:40,159 --> 01:45:45,040
yes we can hear you great okay thank you

1972
01:45:45,040 --> 01:45:46,880
all right so

1973
01:45:46,880 --> 01:45:48,800
attackers can have different goals when

1974
01:45:48,800 --> 01:45:51,040
they exploit this leakage so as i said

1975
01:45:51,040 --> 01:45:52,480
they could target the queries which

1976
01:45:52,480 --> 01:45:53,920
won't be the focus of this talk or they

1977
01:45:53,920 --> 01:45:57,719
could target the data

1978
01:45:59,840 --> 01:46:03,119
and now the clicker doesn't work

1979
01:46:04,800 --> 01:46:07,119
all right

1980
01:46:07,119 --> 01:46:10,799
so the first type of

1981
01:46:10,960 --> 01:46:13,119
goal when

1982
01:46:13,119 --> 01:46:14,719
targeting the data is data

1983
01:46:14,719 --> 01:46:16,719
reconstruction so this is reconstructing

1984
01:46:16,719 --> 01:46:18,639
a map from

1985
01:46:18,639 --> 01:46:20,960
the record ids or the row numbers to

1986
01:46:20,960 --> 01:46:23,440
their value and this could be something

1987
01:46:23,440 --> 01:46:25,119
this could be anything from

1988
01:46:25,119 --> 01:46:27,119
just grouping records together that have

1989
01:46:27,119 --> 01:46:29,600
the same value all the way to exactly

1990
01:46:29,600 --> 01:46:32,080
reconstructing this record id has this

1991
01:46:32,080 --> 01:46:33,840
exact value and there are some in

1992
01:46:33,840 --> 01:46:36,639
between as we'll see

1993
01:46:36,639 --> 01:46:37,840
the second type

1994
01:46:37,840 --> 01:46:40,320
of attacker goal is reconstructing the

1995
01:46:40,320 --> 01:46:41,760
value counts and this is something

1996
01:46:41,760 --> 01:46:44,239
that's possible without

1997
01:46:44,239 --> 01:46:46,320
access pattern leakage so again this

1998
01:46:46,320 --> 01:46:47,920
could range from

1999
01:46:47,920 --> 01:46:50,960
knowing the counts of values but not

2000
01:46:50,960 --> 01:46:53,600
exactly which values they correspond to

2001
01:46:53,600 --> 01:46:55,520
or maybe knowing the counts in order but

2002
01:46:55,520 --> 01:46:57,280
not exactly what values they correspond

2003
01:46:57,280 --> 01:46:59,760
to all the way to knowing exact value

2004
01:46:59,760 --> 01:47:01,040
counts

2005
01:47:01,040 --> 01:47:02,639
and i'll mention briefly here these

2006
01:47:02,639 --> 01:47:04,880
attacks are all up to what we call

2007
01:47:04,880 --> 01:47:07,520
global reflection so this leakage

2008
01:47:07,520 --> 01:47:10,080
doesn't distinguish between values one

2009
01:47:10,080 --> 01:47:11,520
through big n

2010
01:47:11,520 --> 01:47:13,280
relative or compared to

2011
01:47:13,280 --> 01:47:15,440
big n to one so there's always one bit

2012
01:47:15,440 --> 01:47:20,199
of information missing in these attacks

2013
01:47:23,119 --> 01:47:24,719
so let's look at two examples of the

2014
01:47:24,719 --> 01:47:26,560
first class of attacks that are

2015
01:47:26,560 --> 01:47:29,440
reconstructing the data using

2016
01:47:29,440 --> 01:47:31,440
response identifier or access pattern

2017
01:47:31,440 --> 01:47:33,440
leakage the first was mentioned earlier

2018
01:47:33,440 --> 01:47:36,239
by kolaris polios nissim

2019
01:47:36,239 --> 01:47:39,199
and the second is one of mine with um

2020
01:47:39,199 --> 01:47:42,638
grubs nino and patterson

2021
01:47:43,679 --> 01:47:45,840
so the type of leakage kknos access

2022
01:47:45,840 --> 01:47:48,080
pattern attack exploits is response

2023
01:47:48,080 --> 01:47:51,360
identifiers or access pattern and

2024
01:47:51,360 --> 01:47:53,199
there are two steps to the attack each

2025
01:47:53,199 --> 01:47:55,199
of which have different goals

2026
01:47:55,199 --> 01:47:58,560
the first step get order is to

2027
01:47:58,560 --> 01:48:00,560
the goal of the first step

2028
01:48:00,560 --> 01:48:02,159
is to

2029
01:48:02,159 --> 01:48:05,360
obtain ordered data reconstruction

2030
01:48:05,360 --> 01:48:08,400
or exact data reconstruction if the data

2031
01:48:08,400 --> 01:48:10,960
set is dense

2032
01:48:10,960 --> 01:48:12,400
and the second step works even if the

2033
01:48:12,400 --> 01:48:14,080
data set is sparse

2034
01:48:14,080 --> 01:48:17,760
and it targets exact data reconstruction

2035
01:48:17,760 --> 01:48:19,119
there are two main ideas that make this

2036
01:48:19,119 --> 01:48:21,360
attack work the first is that if all

2037
01:48:21,360 --> 01:48:23,760
queries occur at least once then you can

2038
01:48:23,760 --> 01:48:26,560
order the result sets by inclusion

2039
01:48:26,560 --> 01:48:28,400
and the second is that if the query

2040
01:48:28,400 --> 01:48:30,719
distribution is uniform over all

2041
01:48:30,719 --> 01:48:32,960
possible ranges then you can determine

2042
01:48:32,960 --> 01:48:34,320
the values

2043
01:48:34,320 --> 01:48:35,600
by mapping

2044
01:48:35,600 --> 01:48:38,000
by comparing the expected fraction of

2045
01:48:38,000 --> 01:48:40,159
queries

2046
01:48:40,159 --> 01:48:42,960
that match a group of records

2047
01:48:42,960 --> 01:48:44,320
or that match records with a certain

2048
01:48:44,320 --> 01:48:46,239
value to the observed fraction of

2049
01:48:46,239 --> 01:48:50,159
queries that matched a group of records

2050
01:48:50,159 --> 01:48:52,159
so let's look at these two main ideas a

2051
01:48:52,159 --> 01:48:54,800
little more closely so the first if all

2052
01:48:54,800 --> 01:48:56,880
queries occur at least once then result

2053
01:48:56,880 --> 01:48:58,719
sets can be ordered by inclusion to

2054
01:48:58,719 --> 01:49:01,600
determine the order of record values so

2055
01:49:01,600 --> 01:49:03,360
the access pattern attack just looks

2056
01:49:03,360 --> 01:49:06,239
like groups of record identifiers this

2057
01:49:06,239 --> 01:49:07,840
is what the attacker sees this is the

2058
01:49:07,840 --> 01:49:09,679
access pattern leakage

2059
01:49:09,679 --> 01:49:12,320
so it's going to look for the maximal

2060
01:49:12,320 --> 01:49:16,800
proper subset of all record identifiers

2061
01:49:16,800 --> 01:49:18,400
and then it's going to take the

2062
01:49:18,400 --> 01:49:20,560
complement of that and that has to be a

2063
01:49:20,560 --> 01:49:24,320
group of records whose value is 1 or n

2064
01:49:24,320 --> 01:49:26,719
because of what i mentioned before about

2065
01:49:26,719 --> 01:49:29,360
reconstructing data up to reflection

2066
01:49:29,360 --> 01:49:30,960
and then it's going to extend that by

2067
01:49:30,960 --> 01:49:32,560
looking for the next

2068
01:49:32,560 --> 01:49:35,119
smallest set of records we can add

2069
01:49:35,119 --> 01:49:37,360
such that a query was observed having

2070
01:49:37,360 --> 01:49:39,040
that access pattern and it's going to do

2071
01:49:39,040 --> 01:49:41,360
this repeatedly to order the set of

2072
01:49:41,360 --> 01:49:43,839
records

2073
01:49:44,159 --> 01:49:46,080
now the second part of the attack is

2074
01:49:46,080 --> 01:49:48,320
assigning values to these ordered groups

2075
01:49:48,320 --> 01:49:49,599
of records

2076
01:49:49,599 --> 01:49:50,400
so

2077
01:49:50,400 --> 01:49:52,560
given a value we can compute the exact

2078
01:49:52,560 --> 01:49:54,719
probability that for a uniform range

2079
01:49:54,719 --> 01:49:57,360
query distribution a range would match a

2080
01:49:57,360 --> 01:50:00,400
record having that value

2081
01:50:00,400 --> 01:50:02,000
so based on the leakage we simply

2082
01:50:02,000 --> 01:50:03,280
compute

2083
01:50:03,280 --> 01:50:05,280
okay how many of the queries whose

2084
01:50:05,280 --> 01:50:07,920
leakage we observed

2085
01:50:07,920 --> 01:50:08,960
matched

2086
01:50:08,960 --> 01:50:10,480
these records

2087
01:50:10,480 --> 01:50:13,040
and then we map it to

2088
01:50:13,040 --> 01:50:15,760
our expected fraction of queries

2089
01:50:15,760 --> 01:50:17,840
matching a certain value and find the

2090
01:50:17,840 --> 01:50:20,080
closest one and assign that value to the

2091
01:50:20,080 --> 01:50:23,480
group of records

2092
01:50:24,560 --> 01:50:26,239
so here's the whole attack on one slide

2093
01:50:26,239 --> 01:50:28,480
the first part is getting the order

2094
01:50:28,480 --> 01:50:30,960
remember if the data set is dense then

2095
01:50:30,960 --> 01:50:32,400
we're done we achieve exact data

2096
01:50:32,400 --> 01:50:34,560
reconstruction but if it's sparse all we

2097
01:50:34,560 --> 01:50:35,920
do is order

2098
01:50:35,920 --> 01:50:37,440
the records

2099
01:50:37,440 --> 01:50:39,440
and the second part we're using the

2100
01:50:39,440 --> 01:50:41,840
expected fraction of queries matching a

2101
01:50:41,840 --> 01:50:44,960
value and mapping that to the observed

2102
01:50:44,960 --> 01:50:46,719
fraction of queries matching the group

2103
01:50:46,719 --> 01:50:51,400
of records in order to assign it a value

2104
01:50:52,000 --> 01:50:53,920
so the ordered data reconstruction the

2105
01:50:53,920 --> 01:50:55,840
first part of this attack requires

2106
01:50:55,840 --> 01:50:58,320
leakage from all range queries

2107
01:50:58,320 --> 01:51:00,560
and if they're uniformly random

2108
01:51:00,560 --> 01:51:02,560
then by coupon collector bound this is

2109
01:51:02,560 --> 01:51:05,360
just n squared log n where he's expected

2110
01:51:05,360 --> 01:51:07,599
to work the second part of the attack

2111
01:51:07,599 --> 01:51:09,280
requires leakage from even more

2112
01:51:09,280 --> 01:51:10,719
uniformly random queries and they

2113
01:51:10,719 --> 01:51:12,400
absolutely have to be

2114
01:51:12,400 --> 01:51:14,719
uniformly random

2115
01:51:14,719 --> 01:51:16,960
in order for the

2116
01:51:16,960 --> 01:51:19,520
differences in the observed fraction of

2117
01:51:19,520 --> 01:51:20,960
queries that matched each group of

2118
01:51:20,960 --> 01:51:24,320
records to correctly map to the value in

2119
01:51:24,320 --> 01:51:25,280
the

2120
01:51:25,280 --> 01:51:28,320
chart i showed earlier we need about n

2121
01:51:28,320 --> 01:51:30,639
to the fourth login queries so that this

2122
01:51:30,639 --> 01:51:33,360
mapping is always correct

2123
01:51:33,360 --> 01:51:35,679
so this attack achieves a pretty power a

2124
01:51:35,679 --> 01:51:38,000
pretty strong goal but it's kind of

2125
01:51:38,000 --> 01:51:40,159
rigid in the sense that it requires a

2126
01:51:40,159 --> 01:51:42,800
uniform query distribution

2127
01:51:42,800 --> 01:51:44,719
and a lot of queries

2128
01:51:44,719 --> 01:51:46,800
so we may ask what is possible to

2129
01:51:46,800 --> 01:51:48,639
achieve with fewer queries or if we

2130
01:51:48,639 --> 01:51:50,719
target a weaker goal like approximate

2131
01:51:50,719 --> 01:51:53,040
data reconstruction

2132
01:51:53,040 --> 01:51:55,679
so the glmp attack approximate order

2133
01:51:55,679 --> 01:51:58,320
reconstruction does this

2134
01:51:58,320 --> 01:52:00,560
it uses the same kind of leakage

2135
01:52:00,560 --> 01:52:01,840
the access pattern or response

2136
01:52:01,840 --> 01:52:04,400
identifiers and it targets order data

2137
01:52:04,400 --> 01:52:06,480
reconstruction so it puts records into

2138
01:52:06,480 --> 01:52:08,560
groups records whose values are close

2139
01:52:08,560 --> 01:52:11,199
and then orders the groups

2140
01:52:11,199 --> 01:52:12,560
and there are two main ideas that make

2141
01:52:12,560 --> 01:52:14,000
this attack work

2142
01:52:14,000 --> 01:52:16,800
the first is that a pq tree can

2143
01:52:16,800 --> 01:52:18,960
represent a set of orderings on the

2144
01:52:18,960 --> 01:52:21,520
records in terms of their value and can

2145
01:52:21,520 --> 01:52:24,320
be updated with the observed access

2146
01:52:24,320 --> 01:52:26,960
pattern leakage from each query

2147
01:52:26,960 --> 01:52:28,480
and the second point

2148
01:52:28,480 --> 01:52:30,239
is that with enough observed queries

2149
01:52:30,239 --> 01:52:32,239
eventually we'll have a q node at the

2150
01:52:32,239 --> 01:52:34,320
root and the leaves of each of its

2151
01:52:34,320 --> 01:52:36,239
children will correspond to the groups

2152
01:52:36,239 --> 01:52:37,360
of records

2153
01:52:37,360 --> 01:52:39,679
okay so let's look at those two ideas a

2154
01:52:39,679 --> 01:52:41,840
little more closely so

2155
01:52:41,840 --> 01:52:45,679
pq trees are maybe 45 years old and

2156
01:52:45,679 --> 01:52:47,440
before this work they had been used in

2157
01:52:47,440 --> 01:52:49,199
the database setting before by dotrick

2158
01:52:49,199 --> 01:52:50,719
and ravishankar

2159
01:52:50,719 --> 01:52:52,159
but they hadn't been used to try to

2160
01:52:52,159 --> 01:52:54,000
reconstruct values in the database in

2161
01:52:54,000 --> 01:52:56,080
this kind of attack setting

2162
01:52:56,080 --> 01:52:59,040
so a pq tree is just a structure

2163
01:52:59,040 --> 01:53:00,800
and there are two types of internal

2164
01:53:00,800 --> 01:53:03,520
nodes in the tree p nodes and q nodes

2165
01:53:03,520 --> 01:53:05,840
and the children of a p node can be

2166
01:53:05,840 --> 01:53:08,639
reordered in any possible way so if the

2167
01:53:08,639 --> 01:53:10,960
p node has three children then all three

2168
01:53:10,960 --> 01:53:13,440
factorial orderings are possible whereas

2169
01:53:13,440 --> 01:53:15,599
a cue node on the other hand allows only

2170
01:53:15,599 --> 01:53:17,520
two orderings of its children the way

2171
01:53:17,520 --> 01:53:20,719
they're written and the opposite way

2172
01:53:20,719 --> 01:53:23,199
and these nodes in the tree compose in

2173
01:53:23,199 --> 01:53:24,719
the expected way

2174
01:53:24,719 --> 01:53:26,880
so we're going to use a pq tree whose

2175
01:53:26,880 --> 01:53:29,440
leaves correspond to each of the record

2176
01:53:29,440 --> 01:53:31,920
identifiers and then update it with the

2177
01:53:31,920 --> 01:53:33,679
access pattern leakage from each query

2178
01:53:33,679 --> 01:53:34,800
to ensure

2179
01:53:34,800 --> 01:53:36,159
that

2180
01:53:36,159 --> 01:53:39,119
the set of value orderings encoded in

2181
01:53:39,119 --> 01:53:41,280
the pq tree is consistent with the axis

2182
01:53:41,280 --> 01:53:43,040
pattern leakage from

2183
01:53:43,040 --> 01:53:45,920
each query that we see

2184
01:53:46,960 --> 01:53:48,159
sorry

2185
01:53:48,159 --> 01:53:50,400
so at the start our pq tree just looks

2186
01:53:50,400 --> 01:53:51,440
like

2187
01:53:51,440 --> 01:53:54,639
one p node at the root and each record

2188
01:53:54,639 --> 01:53:57,119
or each row in the database is a leaf

2189
01:53:57,119 --> 01:53:59,199
labeled with its identifier not its

2190
01:53:59,199 --> 01:54:00,719
value we know nothing about the values

2191
01:54:00,719 --> 01:54:03,679
initially so as we see queries then we

2192
01:54:03,679 --> 01:54:06,000
update the pq tree using an efficient

2193
01:54:06,000 --> 01:54:06,960
process

2194
01:54:06,960 --> 01:54:09,599
so that it now encodes a smaller set of

2195
01:54:09,599 --> 01:54:11,840
orderings we prune the set of orderings

2196
01:54:11,840 --> 01:54:14,480
allowed by the pq tree so that

2197
01:54:14,480 --> 01:54:17,599
all orderings have those records

2198
01:54:17,599 --> 01:54:19,440
observed in the same query always

2199
01:54:19,440 --> 01:54:20,840
adjacent to one

2200
01:54:20,840 --> 01:54:24,159
another and we can do this repeatedly

2201
01:54:24,159 --> 01:54:25,440
repeatedly

2202
01:54:25,440 --> 01:54:26,800
and eventually

2203
01:54:26,800 --> 01:54:28,719
with enough observed queries there will

2204
01:54:28,719 --> 01:54:31,199
be a q node at or close to the root of

2205
01:54:31,199 --> 01:54:32,239
the tree

2206
01:54:32,239 --> 01:54:34,320
whose children will correspond to these

2207
01:54:34,320 --> 01:54:36,080
groups of records that have similar

2208
01:54:36,080 --> 01:54:37,119
values

2209
01:54:37,119 --> 01:54:39,360
and those are the ordered groups of

2210
01:54:39,360 --> 01:54:43,360
records ordered by value

2211
01:54:44,960 --> 01:54:46,320
and

2212
01:54:46,320 --> 01:54:48,639
each group of records have values that

2213
01:54:48,639 --> 01:54:51,840
are close to one another

2214
01:54:54,239 --> 01:54:55,920
so this algorithm doesn't depend on the

2215
01:54:55,920 --> 01:54:58,239
query distribution it works even if the

2216
01:54:58,239 --> 01:55:00,800
queries aren't exactly chosen uniformly

2217
01:55:00,800 --> 01:55:01,840
at random

2218
01:55:01,840 --> 01:55:04,080
and it's possible to see partial results

2219
01:55:04,080 --> 01:55:07,360
after any number of queries

2220
01:55:07,760 --> 01:55:10,159
the degree of approximate reconstruction

2221
01:55:10,159 --> 01:55:12,639
is quantifiable in the following sense

2222
01:55:12,639 --> 01:55:15,360
so suppose that the query distribution

2223
01:55:15,360 --> 01:55:17,599
is uniform and we want the ordered

2224
01:55:17,599 --> 01:55:20,000
groups of records to have values that

2225
01:55:20,000 --> 01:55:24,080
are no more than epsilon n apart

2226
01:55:24,080 --> 01:55:25,760
so we want all the records in a group to

2227
01:55:25,760 --> 01:55:27,199
have values that are really close

2228
01:55:27,199 --> 01:55:28,320
together

2229
01:55:28,320 --> 01:55:30,159
then there's a kind of a

2230
01:55:30,159 --> 01:55:32,639
scale free property to this attack which

2231
01:55:32,639 --> 01:55:34,560
means that the number of queries we need

2232
01:55:34,560 --> 01:55:36,560
for that to hold with uniformly random

2233
01:55:36,560 --> 01:55:41,199
queries depends only on epsilon not n

2234
01:55:44,159 --> 01:55:44,960
so

2235
01:55:44,960 --> 01:55:47,199
schemes that leak access patterns

2236
01:55:47,199 --> 01:55:48,000
um

2237
01:55:48,000 --> 01:55:50,560
can be uh transformed into schemes that

2238
01:55:50,560 --> 01:55:52,960
lead less so maybe they leak just a

2239
01:55:52,960 --> 01:55:55,199
number of matching queries

2240
01:55:55,199 --> 01:55:57,199
um and next we'll see what's possible to

2241
01:55:57,199 --> 01:55:59,119
do with schemes that leak response

2242
01:55:59,119 --> 01:56:01,199
length or communication volume as it's

2243
01:56:01,199 --> 01:56:03,440
called

2244
01:56:03,920 --> 01:56:06,159
so the two attacks uh we'll look at the

2245
01:56:06,159 --> 01:56:08,480
first is again kkno

2246
01:56:08,480 --> 01:56:11,119
and the second is corneropolis

2247
01:56:11,119 --> 01:56:13,679
papamanthu and tamasiya

2248
01:56:13,679 --> 01:56:16,239
and they use sort of similar ideas

2249
01:56:16,239 --> 01:56:18,718
as we'll see

2250
01:56:19,040 --> 01:56:21,520
so kkno's communication volume attack

2251
01:56:21,520 --> 01:56:23,920
uses response lengths or volumes as a

2252
01:56:23,920 --> 01:56:26,719
leakage that's the leakage it exploits

2253
01:56:26,719 --> 01:56:29,760
it reconstructs exact value counts for

2254
01:56:29,760 --> 01:56:31,920
each possible value from one to begin it

2255
01:56:31,920 --> 01:56:33,920
says how many records in the database

2256
01:56:33,920 --> 01:56:35,760
have this value

2257
01:56:35,760 --> 01:56:38,880
it requires uniformly random queries and

2258
01:56:38,880 --> 01:56:41,360
the leakage from all queries and we'll

2259
01:56:41,360 --> 01:56:43,360
see why

2260
01:56:43,360 --> 01:56:44,800
so the two main ideas that make this

2261
01:56:44,800 --> 01:56:45,920
attack work

2262
01:56:45,920 --> 01:56:47,280
first

2263
01:56:47,280 --> 01:56:49,360
reconstructing value counts is

2264
01:56:49,360 --> 01:56:51,360
equivalent to reconstructing the

2265
01:56:51,360 --> 01:56:54,719
distances between adjacent records in

2266
01:56:54,719 --> 01:56:56,639
the database if they were ordered by

2267
01:56:56,639 --> 01:56:58,239
values

2268
01:56:58,239 --> 01:56:59,440
and second

2269
01:56:59,440 --> 01:57:01,760
knowing the number of distinct ranges

2270
01:57:01,760 --> 01:57:03,679
out of the n times one plus one over two

2271
01:57:03,679 --> 01:57:05,679
possible ranges

2272
01:57:05,679 --> 01:57:07,840
with a given response volume allows

2273
01:57:07,840 --> 01:57:10,000
determining the distances between

2274
01:57:10,000 --> 01:57:12,080
adjacent records if they were ordered by

2275
01:57:12,080 --> 01:57:14,080
value

2276
01:57:14,080 --> 01:57:16,159
so let's look at those two ideas up

2277
01:57:16,159 --> 01:57:17,360
close

2278
01:57:17,360 --> 01:57:19,760
so first that reconstructing

2279
01:57:19,760 --> 01:57:20,960
value counts is equivalent to

2280
01:57:20,960 --> 01:57:22,800
reconstructing distances between values

2281
01:57:22,800 --> 01:57:23,760
of records

2282
01:57:23,760 --> 01:57:25,520
so on the left we have

2283
01:57:25,520 --> 01:57:27,040
um records

2284
01:57:27,040 --> 01:57:29,679
grouped by value

2285
01:57:29,679 --> 01:57:32,560
and on the right we have this

2286
01:57:32,560 --> 01:57:34,480
distance between

2287
01:57:34,480 --> 01:57:37,040
adjacent records if they were grouped by

2288
01:57:37,040 --> 01:57:38,880
value

2289
01:57:38,880 --> 01:57:40,320
so the distance

2290
01:57:40,320 --> 01:57:42,159
d i is the difference between the value

2291
01:57:42,159 --> 01:57:44,320
of the ith record ordered by value with

2292
01:57:44,320 --> 01:57:47,199
repetition and the i minus first record

2293
01:57:47,199 --> 01:57:49,040
you can think of the distance as a

2294
01:57:49,040 --> 01:57:50,080
measure

2295
01:57:50,080 --> 01:57:53,199
of how many possible endpoints there are

2296
01:57:53,199 --> 01:57:55,360
between the values of two records

2297
01:57:55,360 --> 01:57:56,400
so

2298
01:57:56,400 --> 01:57:58,159
how many endpoints can we have so that a

2299
01:57:58,159 --> 01:58:00,000
query matches one of those records but

2300
01:58:00,000 --> 01:58:02,320
not the other if their distance is zero

2301
01:58:02,320 --> 01:58:04,719
then every possible range query has to

2302
01:58:04,719 --> 01:58:06,639
match either both or neither of those

2303
01:58:06,639 --> 01:58:08,880
records but if it's one or more then we

2304
01:58:08,880 --> 01:58:10,719
can squeeze in a query endpoint and have

2305
01:58:10,719 --> 01:58:12,719
a query that matches one record but not

2306
01:58:12,719 --> 01:58:15,040
the other

2307
01:58:19,280 --> 01:58:21,599
the next observation is that knowing the

2308
01:58:21,599 --> 01:58:23,520
number of distinct ranges out of the n

2309
01:58:23,520 --> 01:58:25,199
times one plus one over two

2310
01:58:25,199 --> 01:58:28,080
uh possible ranges with a given response

2311
01:58:28,080 --> 01:58:31,040
volume allows determining distances

2312
01:58:31,040 --> 01:58:33,040
between adjacent records if they were

2313
01:58:33,040 --> 01:58:35,119
ordered by value

2314
01:58:35,119 --> 01:58:37,360
so there are these expressions uh theta

2315
01:58:37,360 --> 01:58:39,199
k for the number of distinct range

2316
01:58:39,199 --> 01:58:41,840
queries with volume k

2317
01:58:41,840 --> 01:58:43,679
and we can write them as a sum of

2318
01:58:43,679 --> 01:58:46,239
products of these distances

2319
01:58:46,239 --> 01:58:48,880
so you can think of this like

2320
01:58:48,880 --> 01:58:51,520
considering in our hypothetical list of

2321
01:58:51,520 --> 01:58:55,840
all records ordered by value okay do uh

2322
01:58:55,840 --> 01:58:59,040
does the record with value v1 and all

2323
01:58:59,040 --> 01:59:00,800
the records up to the record with value

2324
01:59:00,800 --> 01:59:02,960
vk could that be returned by a range

2325
01:59:02,960 --> 01:59:06,560
query how about v2 through vk plus one

2326
01:59:06,560 --> 01:59:09,199
and so on

2327
01:59:11,520 --> 01:59:14,000
so kknow's communication volume attack

2328
01:59:14,000 --> 01:59:16,000
has these three steps so first you

2329
01:59:16,000 --> 01:59:17,679
simply count the number of queries with

2330
01:59:17,679 --> 01:59:20,159
volume k and then scale by the number of

2331
01:59:20,159 --> 01:59:21,920
total possible queries and times episode

2332
01:59:21,920 --> 01:59:23,199
over two and the

2333
01:59:23,199 --> 01:59:23,920
uh

2334
01:59:23,920 --> 01:59:24,960
the um

2335
01:59:24,960 --> 01:59:26,960
number of quarries whose leakage you

2336
01:59:26,960 --> 01:59:28,000
observed

2337
01:59:28,000 --> 01:59:29,760
okay and you round to the nearest

2338
01:59:29,760 --> 01:59:32,080
integer and this is the theta k the

2339
01:59:32,080 --> 01:59:34,080
number of distinct range queries with

2340
01:59:34,080 --> 01:59:35,840
volume k

2341
01:59:35,840 --> 01:59:37,679
and next they observe that you can form

2342
01:59:37,679 --> 01:59:40,000
a polynomial whose coefficients depend

2343
01:59:40,000 --> 01:59:42,960
just on the theta k's

2344
01:59:42,960 --> 01:59:45,599
and factor it into two polynomials whose

2345
01:59:45,599 --> 01:59:48,080
coefficients give you the distance

2346
01:59:48,080 --> 01:59:50,800
values the dis and as we saw earlier

2347
01:59:50,800 --> 01:59:52,400
this is equivalent to reconstructing the

2348
01:59:52,400 --> 01:59:56,480
values of every record in the database

2349
01:59:56,480 --> 01:59:58,480
now step one here works because the

2350
01:59:58,480 --> 02:00:00,880
query distribution is assumed to be

2351
02:00:00,880 --> 02:00:03,440
uniform

2352
02:00:04,800 --> 02:00:07,599
so kkno's communication volume attacks

2353
02:00:07,599 --> 02:00:09,920
attack completely fails if the queries

2354
02:00:09,920 --> 02:00:13,760
aren't sampled uniformly at random

2355
02:00:13,760 --> 02:00:17,440
so it's necessary to observe about

2356
02:00:17,440 --> 02:00:19,760
n to the fourth log n queries in general

2357
02:00:19,760 --> 02:00:20,800
to get

2358
02:00:20,800 --> 02:00:24,400
estimates of theta that will be correct

2359
02:00:24,400 --> 02:00:26,239
and it can give multiple solutions for

2360
02:00:26,239 --> 02:00:28,000
certain data sets so in the polynomial

2361
02:00:28,000 --> 02:00:29,920
factorization step it's possible that it

2362
02:00:29,920 --> 02:00:32,080
factors into more than two polynomials

2363
02:00:32,080 --> 02:00:33,679
and that just means there are multiple

2364
02:00:33,679 --> 02:00:36,080
databases that would have had exactly

2365
02:00:36,080 --> 02:00:39,639
the same leakage

2366
02:00:40,080 --> 02:00:40,960
so

2367
02:00:40,960 --> 02:00:42,480
like we did for the data reconstruction

2368
02:00:42,480 --> 02:00:44,080
attacks now we consider account

2369
02:00:44,080 --> 02:00:46,239
reconstruction attacks attack that

2370
02:00:46,239 --> 02:00:49,119
targets something slightly weaker

2371
02:00:49,119 --> 02:00:52,840
but doesn't require a uniform query

2372
02:00:52,840 --> 02:00:55,920
distribution so the kpt agnostic uh

2373
02:00:55,920 --> 02:00:58,320
parametrized attack it exploits two

2374
02:00:58,320 --> 02:00:59,760
kinds of leakage

2375
02:00:59,760 --> 02:01:02,560
uh query equality also called the token

2376
02:01:02,560 --> 02:01:04,719
or search pattern and the response

2377
02:01:04,719 --> 02:01:06,800
length the volumes that kknos attack

2378
02:01:06,800 --> 02:01:08,639
also exploited

2379
02:01:08,639 --> 02:01:11,119
and it reconstructs approximate value

2380
02:01:11,119 --> 02:01:13,760
counts no longer exact

2381
02:01:13,760 --> 02:01:15,440
and some of the main ideas are the same

2382
02:01:15,440 --> 02:01:17,119
there's this equivalence between

2383
02:01:17,119 --> 02:01:18,480
reconstructing

2384
02:01:18,480 --> 02:01:20,080
distances between values and

2385
02:01:20,080 --> 02:01:21,679
reconstructing

2386
02:01:21,679 --> 02:01:24,159
values

2387
02:01:24,400 --> 02:01:27,119
and again knowing the number of distinct

2388
02:01:27,119 --> 02:01:29,119
ranges with a given response volume

2389
02:01:29,119 --> 02:01:31,199
allows determining distances

2390
02:01:31,199 --> 02:01:33,040
between adjacent records

2391
02:01:33,040 --> 02:01:34,560
and a neat feature of this attack is

2392
02:01:34,560 --> 02:01:37,199
that it can be parametrized by which

2393
02:01:37,199 --> 02:01:39,360
of the n times n plus one over two

2394
02:01:39,360 --> 02:01:41,040
ranges may occur

2395
02:01:41,040 --> 02:01:43,040
if we're targeting this attack to a

2396
02:01:43,040 --> 02:01:47,119
particular encrypted range query scheme

2397
02:01:48,239 --> 02:01:50,159
so the first of the main ideas exactly

2398
02:01:50,159 --> 02:01:52,320
the same as kkno

2399
02:01:52,320 --> 02:01:55,599
if we have distances we can reconstruct

2400
02:01:55,599 --> 02:01:57,440
values that's exactly the same they're

2401
02:01:57,440 --> 02:01:59,119
equivalent oh and i didn't mention

2402
02:01:59,119 --> 02:02:01,360
earlier but to make things work out at

2403
02:02:01,360 --> 02:02:03,280
the endpoints we add these kind of

2404
02:02:03,280 --> 02:02:06,159
synthetic values v sub 0 which is always

2405
02:02:06,159 --> 02:02:08,719
equal to 0 and v sub

2406
02:02:08,719 --> 02:02:10,880
um

2407
02:02:10,880 --> 02:02:12,000
little

2408
02:02:12,000 --> 02:02:14,400
n plus 1

2409
02:02:14,400 --> 02:02:16,239
which is always equal to

2410
02:02:16,239 --> 02:02:19,839
big n plus 1.

2411
02:02:20,719 --> 02:02:22,800
and this is where things start to go

2412
02:02:22,800 --> 02:02:24,800
a little differently than kk and o's

2413
02:02:24,800 --> 02:02:26,320
attack

2414
02:02:26,320 --> 02:02:27,280
so

2415
02:02:27,280 --> 02:02:29,440
the theta k's are estimated differently

2416
02:02:29,440 --> 02:02:32,000
from the leakage in kk and o's attack

2417
02:02:32,000 --> 02:02:34,159
each range was assumed to be queried

2418
02:02:34,159 --> 02:02:35,840
with the same probability we assume that

2419
02:02:35,840 --> 02:02:38,159
the query ranges were uniformly random

2420
02:02:38,159 --> 02:02:40,719
so the number of distinct ranges with

2421
02:02:40,719 --> 02:02:42,880
the given volume is just the number of

2422
02:02:42,880 --> 02:02:45,440
observed ranges with that volume

2423
02:02:45,440 --> 02:02:47,199
this attack on the other hand does not

2424
02:02:47,199 --> 02:02:49,520
assume any particular distribution on

2425
02:02:49,520 --> 02:02:53,040
the quarried ranges but it assumes that

2426
02:02:53,040 --> 02:02:53,760
the

2427
02:02:53,760 --> 02:02:56,000
query equality is leaked and that's how

2428
02:02:56,000 --> 02:03:00,599
we kind of get around this problem

2429
02:03:06,320 --> 02:03:09,119
so the agnostic parameterized attack

2430
02:03:09,119 --> 02:03:11,760
has four main steps so first from each

2431
02:03:11,760 --> 02:03:13,280
query we have

2432
02:03:13,280 --> 02:03:15,360
the leakage of

2433
02:03:15,360 --> 02:03:18,000
query equality and volume of that

2434
02:03:18,000 --> 02:03:21,119
response so we partition based on

2435
02:03:21,119 --> 02:03:23,119
the observed volume

2436
02:03:23,119 --> 02:03:25,360
and then for each volume

2437
02:03:25,360 --> 02:03:27,040
we can count the number of distinct

2438
02:03:27,040 --> 02:03:29,119
queries that had that volume and this

2439
02:03:29,119 --> 02:03:31,599
gives us an estimate of theta k call it

2440
02:03:31,599 --> 02:03:34,480
theta tilde okay and the next step

2441
02:03:34,480 --> 02:03:36,480
is to refine this estimate and there are

2442
02:03:36,480 --> 02:03:37,760
two

2443
02:03:37,760 --> 02:03:39,599
two reasons we need to refine it so the

2444
02:03:39,599 --> 02:03:40,800
first

2445
02:03:40,800 --> 02:03:42,719
is because it's possible that we didn't

2446
02:03:42,719 --> 02:03:43,679
see

2447
02:03:43,679 --> 02:03:45,760
leakage from enough queries to get a

2448
02:03:45,760 --> 02:03:47,119
good estimate

2449
02:03:47,119 --> 02:03:48,320
simply put if we didn't see enough

2450
02:03:48,320 --> 02:03:49,599
queries then there's no way we can

2451
02:03:49,599 --> 02:03:51,360
possibly have seen all of the distinct

2452
02:03:51,360 --> 02:03:52,400
queries

2453
02:03:52,400 --> 02:03:53,920
that would have

2454
02:03:53,920 --> 02:03:55,360
this volume

2455
02:03:55,360 --> 02:03:57,520
so they use support size estimation to

2456
02:03:57,520 --> 02:03:59,280
refine that estimate

2457
02:03:59,280 --> 02:04:02,239
and next they probably probabilistically

2458
02:04:02,239 --> 02:04:06,000
add or remove volumes so that the sum of

2459
02:04:06,000 --> 02:04:08,239
the thetas equals what it should the

2460
02:04:08,239 --> 02:04:10,880
total number of possible ranges that can

2461
02:04:10,880 --> 02:04:12,880
be queried

2462
02:04:12,880 --> 02:04:15,040
and next instead of forming a polynomial

2463
02:04:15,040 --> 02:04:16,400
and factoring it which is good in the

2464
02:04:16,400 --> 02:04:17,920
exact case but not good in the

2465
02:04:17,920 --> 02:04:19,360
approximate case

2466
02:04:19,360 --> 02:04:21,360
they made a constrained optimization

2467
02:04:21,360 --> 02:04:23,360
system where they can solve for the

2468
02:04:23,360 --> 02:04:24,400
distances

2469
02:04:24,400 --> 02:04:27,119
d i's so the objective function

2470
02:04:27,119 --> 02:04:29,920
is a weighted uh squared error okay and

2471
02:04:29,920 --> 02:04:31,520
the weights are

2472
02:04:31,520 --> 02:04:34,480
the number of total queries per volume

2473
02:04:34,480 --> 02:04:35,520
squared

2474
02:04:35,520 --> 02:04:36,800
and the constraints are that the

2475
02:04:36,800 --> 02:04:38,560
distances d i's are

2476
02:04:38,560 --> 02:04:39,920
non-zero

2477
02:04:39,920 --> 02:04:41,599
positive integers

2478
02:04:41,599 --> 02:04:44,560
and that the sum of the dis is equal to

2479
02:04:44,560 --> 02:04:49,800
the number of possible values plus one

2480
02:04:52,719 --> 02:04:54,480
now this attack has parametrized in the

2481
02:04:54,480 --> 02:04:56,639
name and i haven't said much about that

2482
02:04:56,639 --> 02:04:57,360
but

2483
02:04:57,360 --> 02:04:59,119
in a little more detail these are the

2484
02:04:59,119 --> 02:05:00,880
points at which the attack would be

2485
02:05:00,880 --> 02:05:04,320
modified if it's targeting a specific

2486
02:05:04,320 --> 02:05:06,480
encrypted range query scheme that allows

2487
02:05:06,480 --> 02:05:08,000
only certain queries

2488
02:05:08,000 --> 02:05:11,760
so first in step uh 3b the sum of the

2489
02:05:11,760 --> 02:05:14,000
thetas would no longer be

2490
02:05:14,000 --> 02:05:15,760
n times n plus 1 over 2 queries maybe it

2491
02:05:15,760 --> 02:05:17,599
would be less if it's targeting a ranged

2492
02:05:17,599 --> 02:05:19,599
query scheme that doesn't allow you to

2493
02:05:19,599 --> 02:05:21,840
make all possible queries

2494
02:05:21,840 --> 02:05:23,440
and there would also be changes to the

2495
02:05:23,440 --> 02:05:25,520
objective function to reflect the subset

2496
02:05:25,520 --> 02:05:28,400
of ranges that are allowed

2497
02:05:28,400 --> 02:05:29,840
and the types of schemes they had in

2498
02:05:29,840 --> 02:05:30,800
mind

2499
02:05:30,800 --> 02:05:32,560
when they designed this attack are the

2500
02:05:32,560 --> 02:05:34,639
binary tree scheme by favorite all and

2501
02:05:34,639 --> 02:05:36,880
the augmented binary tree scheme by

2502
02:05:36,880 --> 02:05:39,440
demersus

2503
02:05:42,079 --> 02:05:44,960
so kpt's agnostic parameterized attack

2504
02:05:44,960 --> 02:05:48,239
requires the leakage of query equality

2505
02:05:48,239 --> 02:05:50,960
in addition to response volume

2506
02:05:50,960 --> 02:05:52,880
and it's adaptable to specific schemes

2507
02:05:52,880 --> 02:05:54,400
that don't allow all ranges to be

2508
02:05:54,400 --> 02:05:58,000
queried which is very interesting

2509
02:05:59,119 --> 02:06:01,599
so we saw examples of generic attacks

2510
02:06:01,599 --> 02:06:03,360
that apply to any scheme with a

2511
02:06:03,360 --> 02:06:05,840
particular leakage profile we looked at

2512
02:06:05,840 --> 02:06:07,280
reconstructing

2513
02:06:07,280 --> 02:06:09,520
counts of values using volume leakage

2514
02:06:09,520 --> 02:06:11,920
and reconstructing the actual records

2515
02:06:11,920 --> 02:06:14,159
values

2516
02:06:14,159 --> 02:06:16,960
using access pattern leakage

2517
02:06:16,960 --> 02:06:19,360
the tools for designing these algorithms

2518
02:06:19,360 --> 02:06:21,040
and analyzing how many queries are

2519
02:06:21,040 --> 02:06:22,560
required for certain distributions vary

2520
02:06:22,560 --> 02:06:24,400
there are statistical tools like

2521
02:06:24,400 --> 02:06:27,120
support size estimation there are

2522
02:06:27,120 --> 02:06:28,560
[Music]

2523
02:06:28,560 --> 02:06:30,400
optimization techniques

2524
02:06:30,400 --> 02:06:32,719
polynomial factorization there are some

2525
02:06:32,719 --> 02:06:34,320
others i didn't mention that use graph

2526
02:06:34,320 --> 02:06:36,480
theoretic approaches

2527
02:06:36,480 --> 02:06:38,800
um they vary a lot which i think makes

2528
02:06:38,800 --> 02:06:42,079
this area really interesting

2529
02:06:42,079 --> 02:06:43,760
it's also important to take a step back

2530
02:06:43,760 --> 02:06:45,679
and look at the big picture and remember

2531
02:06:45,679 --> 02:06:46,400
that

2532
02:06:46,400 --> 02:06:48,400
what matters in practice isn't the

2533
02:06:48,400 --> 02:06:50,880
leakage profile of just

2534
02:06:50,880 --> 02:06:52,880
the scheme that's going to tell you

2535
02:06:52,880 --> 02:06:55,520
which rows of the database matched but

2536
02:06:55,520 --> 02:06:57,119
we have to look at the leakage profile

2537
02:06:57,119 --> 02:06:59,520
of the whole end-to-end

2538
02:06:59,520 --> 02:07:02,159
implementation of this encrypted range

2539
02:07:02,159 --> 02:07:03,920
scheme

2540
02:07:03,920 --> 02:07:05,360
this is similar to the ideas in the

2541
02:07:05,360 --> 02:07:07,040
paper for

2542
02:07:07,040 --> 02:07:08,239
from

2543
02:07:08,239 --> 02:07:09,440
rethinking searchable symmetric

2544
02:07:09,440 --> 02:07:12,239
encryption

2545
02:07:12,239 --> 02:07:13,199
and

2546
02:07:13,199 --> 02:07:15,520
as someone who's been uh reviewing

2547
02:07:15,520 --> 02:07:17,119
cryptographic code for three years now i

2548
02:07:17,119 --> 02:07:19,199
can tell you that even the most securely

2549
02:07:19,199 --> 02:07:21,280
designed scheme can leak something it

2550
02:07:21,280 --> 02:07:22,639
wasn't meant to

2551
02:07:22,639 --> 02:07:25,119
if it's not implemented securely

2552
02:07:25,119 --> 02:07:26,800
so

2553
02:07:26,800 --> 02:07:28,000
leakage can arise from the

2554
02:07:28,000 --> 02:07:30,400
implementation even if the scheme

2555
02:07:30,400 --> 02:07:32,159
doesn't have a particular leakage

2556
02:07:32,159 --> 02:07:33,280
profile

2557
02:07:33,280 --> 02:07:34,800
and finally just a similar note that

2558
02:07:34,800 --> 02:07:36,320
there's

2559
02:07:36,320 --> 02:07:38,239
a whole nother line of work on

2560
02:07:38,239 --> 02:07:40,239
multi-dimensional range queries which is

2561
02:07:40,239 --> 02:07:41,679
also

2562
02:07:41,679 --> 02:07:43,920
fascinating and i didn't even have time

2563
02:07:43,920 --> 02:07:46,000
to speak about those at all

2564
02:07:46,000 --> 02:07:49,239
thank you

2565
02:07:54,320 --> 02:07:56,880
okay so we have uh i think

2566
02:07:56,880 --> 02:07:58,400
maybe a minute

2567
02:07:58,400 --> 02:08:00,719
left for questions um if anybody has any

2568
02:08:00,719 --> 02:08:03,719
questions

2569
02:08:13,199 --> 02:08:14,400
hello

2570
02:08:14,400 --> 02:08:16,719
could you please give an example of

2571
02:08:16,719 --> 02:08:18,639
leakage from the implementation where

2572
02:08:18,639 --> 02:08:22,840
the scheme was completely secure

2573
02:08:26,239 --> 02:08:27,679
sure thanks for your question uh so

2574
02:08:27,679 --> 02:08:29,360
maybe um

2575
02:08:29,360 --> 02:08:31,840
the returned records are padded with

2576
02:08:31,840 --> 02:08:34,159
fake records so that the the response

2577
02:08:34,159 --> 02:08:36,159
volume doesn't leak but maybe on the

2578
02:08:36,159 --> 02:08:37,520
client side

2579
02:08:37,520 --> 02:08:40,239
um the client does something

2580
02:08:40,239 --> 02:08:41,360
so it

2581
02:08:41,360 --> 02:08:44,000
maybe looks at the response and then

2582
02:08:44,000 --> 02:08:46,000
it i don't know decrypts and immediately

2583
02:08:46,000 --> 02:08:47,360
you can tell it's a fake record so it

2584
02:08:47,360 --> 02:08:50,079
doesn't um keep processing that one so

2585
02:08:50,079 --> 02:08:52,159
maybe through a timing side channel it

2586
02:08:52,159 --> 02:08:53,679
would leak whether

2587
02:08:53,679 --> 02:08:54,480
um

2588
02:08:54,480 --> 02:08:56,719
one of the records returned was fake or

2589
02:08:56,719 --> 02:08:58,960
not and in that way it would be possible

2590
02:08:58,960 --> 02:09:00,960
to determine the actual communication

2591
02:09:00,960 --> 02:09:04,560
volume even if the results were padded

2592
02:09:08,159 --> 02:09:10,719
any other question

2593
02:09:11,599 --> 02:09:15,480
okay all right let's thank the speaker

2594
02:10:07,760 --> 02:10:09,360
all right so our next speaker is kevin

2595
02:10:09,360 --> 02:10:13,119
yeo from google and columbia university

2596
02:10:13,119 --> 02:10:14,960
and he's going to be talking about his

2597
02:10:14,960 --> 02:10:18,079
recent work on volume hiding

2598
02:10:18,079 --> 02:10:20,799
leaky suppression

2599
02:10:25,520 --> 02:10:27,679
you guys hear me all right

2600
02:10:27,679 --> 02:10:29,520
thanks for that questions annie so yes

2601
02:10:29,520 --> 02:10:31,440
uh i'll be talking about volume hiding i

2602
02:10:31,440 --> 02:10:33,280
think one of this work was one of the

2603
02:10:33,280 --> 02:10:36,239
ones that senny alluded to in his intro

2604
02:10:36,239 --> 02:10:38,480
presentation um so this is a joint work

2605
02:10:38,480 --> 02:10:40,480
with three of my collaborators

2606
02:10:40,480 --> 02:10:42,400
sarva patel pinot garciano and modi

2607
02:10:42,400 --> 02:10:43,440
young who are

2608
02:10:43,440 --> 02:10:45,440
all at google at some point during this

2609
02:10:45,440 --> 02:10:46,800
this uh

2610
02:10:46,800 --> 02:10:49,040
work

2611
02:10:49,040 --> 02:10:50,000
all right

2612
02:10:50,000 --> 02:10:50,800
so

2613
02:10:50,800 --> 02:10:52,159
in general i think

2614
02:10:52,159 --> 02:10:53,760
most people here have seen this already

2615
02:10:53,760 --> 02:10:55,920
or if not i'll give you the introduction

2616
02:10:55,920 --> 02:10:57,520
we can consider a data structure called

2617
02:10:57,520 --> 02:10:59,599
plain text multi-maps it's a very simple

2618
02:10:59,599 --> 02:11:01,760
data structure sort of you have keys

2619
02:11:01,760 --> 02:11:03,520
that are associated with values and the

2620
02:11:03,520 --> 02:11:05,119
word multi essentially means that each

2621
02:11:05,119 --> 02:11:06,480
value can have each key can be

2622
02:11:06,480 --> 02:11:09,199
associated to multiple values

2623
02:11:09,199 --> 02:11:10,960
and the standard sort of operations in a

2624
02:11:10,960 --> 02:11:13,040
plain text multi-map are things like you

2625
02:11:13,040 --> 02:11:14,639
get a key ki

2626
02:11:14,639 --> 02:11:16,320
you sort of want to do something to sort

2627
02:11:16,320 --> 02:11:18,239
of retrieve the value bi

2628
02:11:18,239 --> 02:11:19,840
and in general what can be seen like

2629
02:11:19,840 --> 02:11:20,960
let's suppose you did this in the

2630
02:11:20,960 --> 02:11:22,639
standard encrypted search model where

2631
02:11:22,639 --> 02:11:24,079
you outsource the data to some third

2632
02:11:24,079 --> 02:11:26,800
party potentially adversarial

2633
02:11:26,800 --> 02:11:28,320
then the adversary could see some things

2634
02:11:28,320 --> 02:11:30,159
for example it'll see which key was

2635
02:11:30,159 --> 02:11:32,639
being queried it'll also see like

2636
02:11:32,639 --> 02:11:34,800
whatever value was returned and i'll

2637
02:11:34,800 --> 02:11:36,320
caveat here that i'm focusing mainly on

2638
02:11:36,320 --> 02:11:37,760
the static model here so i'm not only

2639
02:11:37,760 --> 02:11:40,560
queries no updates

2640
02:11:40,560 --> 02:11:41,920
all right so

2641
02:11:41,920 --> 02:11:44,079
one way to do this is sort of

2642
02:11:44,079 --> 02:11:45,040
somewhat

2643
02:11:45,040 --> 02:11:47,119
it's it's a little sort of generic a

2644
02:11:47,119 --> 02:11:48,800
little bit simplistic but there's sort

2645
02:11:48,800 --> 02:11:50,639
of a standard way of compiling a plain

2646
02:11:50,639 --> 02:11:52,560
text map it's a so-called encrypted

2647
02:11:52,560 --> 02:11:53,679
multi-map

2648
02:11:53,679 --> 02:11:55,280
and it's not too complicated so at a

2649
02:11:55,280 --> 02:11:57,360
very high level what happens is you sort

2650
02:11:57,360 --> 02:11:59,520
of keep some private key let's say you

2651
02:11:59,520 --> 02:12:01,280
know a shot species key or an aes

2652
02:12:01,280 --> 02:12:03,520
encryption key on the client side

2653
02:12:03,520 --> 02:12:04,960
and when you outsource the data rather

2654
02:12:04,960 --> 02:12:06,560
than outsourcing the data in plain text

2655
02:12:06,560 --> 02:12:08,159
you'll sort of do something simple that

2656
02:12:08,159 --> 02:12:10,159
enables retrieval so

2657
02:12:10,159 --> 02:12:11,760
for example you take all the keys of the

2658
02:12:11,760 --> 02:12:14,000
multi-map and simply hash them

2659
02:12:14,000 --> 02:12:15,599
and then you take all the values and do

2660
02:12:15,599 --> 02:12:18,480
an aes encryption that's probabilistic

2661
02:12:18,480 --> 02:12:19,920
obviously you don't use the same key but

2662
02:12:19,920 --> 02:12:21,440
i'm just sort of being generic here

2663
02:12:21,440 --> 02:12:23,760
making the key sort of uh sort of simple

2664
02:12:23,760 --> 02:12:25,440
to avoid stuff

2665
02:12:25,440 --> 02:12:26,960
but let's suppose again now you want to

2666
02:12:26,960 --> 02:12:29,520
do a query well

2667
02:12:29,520 --> 02:12:31,280
if you get some key ki all you do is

2668
02:12:31,280 --> 02:12:32,960
simply send up the hash and you'll

2669
02:12:32,960 --> 02:12:34,639
retrieve the encrypted value which you

2670
02:12:34,639 --> 02:12:36,800
can decrypt later

2671
02:12:36,800 --> 02:12:38,239
so uh there's been a lot of works on

2672
02:12:38,239 --> 02:12:40,159
multi-maps in fact a lot of you know you

2673
02:12:40,159 --> 02:12:42,000
can look at a multi-map almost as a

2674
02:12:42,000 --> 02:12:43,280
search index

2675
02:12:43,280 --> 02:12:44,880
and sort of at a high level many of

2676
02:12:44,880 --> 02:12:46,560
these many of the papers end up using

2677
02:12:46,560 --> 02:12:48,000
some sort of form of this to be able to

2678
02:12:48,000 --> 02:12:49,440
take the plain text

2679
02:12:49,440 --> 02:12:50,960
multiback into encrypted multi-map of

2680
02:12:50,960 --> 02:12:52,719
course there's many more things on top

2681
02:12:52,719 --> 02:12:54,800
later

2682
02:12:54,800 --> 02:12:56,239
okay so

2683
02:12:56,239 --> 02:12:58,960
why are encrypted multi-maps important

2684
02:12:58,960 --> 02:13:00,239
you can see many reasons it's a very

2685
02:13:00,239 --> 02:13:02,079
generic data structure it can be used

2686
02:13:02,079 --> 02:13:03,760
for a wide range of applications some

2687
02:13:03,760 --> 02:13:05,760
common ones are i mean searching over

2688
02:13:05,760 --> 02:13:07,599
encrypted documents or i think as we'll

2689
02:13:07,599 --> 02:13:09,440
see later you'll be able to do sql

2690
02:13:09,440 --> 02:13:12,719
queries over encrypted databases

2691
02:13:12,719 --> 02:13:14,000
so it's important to study this

2692
02:13:14,000 --> 02:13:15,280
essentially and try to figure out you

2693
02:13:15,280 --> 02:13:16,320
know what's the best we could do in

2694
02:13:16,320 --> 02:13:18,639
terms of efficiency privacy

2695
02:13:18,639 --> 02:13:21,760
functionality et cetera

2696
02:13:21,840 --> 02:13:23,840
so okay i told you a generic way of

2697
02:13:23,840 --> 02:13:25,199
taking sort of a plain text

2698
02:13:25,199 --> 02:13:26,560
multi-mapping converting to an encrypted

2699
02:13:26,560 --> 02:13:28,400
multi-map although maybe it's not

2700
02:13:28,400 --> 02:13:30,079
satisfying in the sense that it's

2701
02:13:30,079 --> 02:13:32,159
there's clearly still some leakage and

2702
02:13:32,159 --> 02:13:34,079
as a you know in the world of research

2703
02:13:34,079 --> 02:13:35,599
our job is to sort of try to identify

2704
02:13:35,599 --> 02:13:38,159
this leakage and sort of suppress it

2705
02:13:38,159 --> 02:13:40,480
so okay uh sort of the what i what we

2706
02:13:40,480 --> 02:13:42,000
call the hash encrypt compiler that i

2707
02:13:42,000 --> 02:13:43,599
showed you earlier

2708
02:13:43,599 --> 02:13:45,599
it takes all the plaintext datas and

2709
02:13:45,599 --> 02:13:47,280
makes them sort of hashed or encrypted

2710
02:13:47,280 --> 02:13:49,040
so the adversary does not see any

2711
02:13:49,040 --> 02:13:51,360
plaintext keys or values anymore which

2712
02:13:51,360 --> 02:13:53,920
is a good start

2713
02:13:54,320 --> 02:13:55,599
but you know what could the adversaries

2714
02:13:55,599 --> 02:13:57,199
see what else could they see and i think

2715
02:13:57,199 --> 02:13:59,280
uh sort of has been named several times

2716
02:13:59,280 --> 02:14:00,800
here but there there are things the

2717
02:14:00,800 --> 02:14:02,960
adversary can't see

2718
02:14:02,960 --> 02:14:05,040
so for example one thing that they can't

2719
02:14:05,040 --> 02:14:07,119
see which we call key quality leakage in

2720
02:14:07,119 --> 02:14:08,480
our paper it's also called i think

2721
02:14:08,480 --> 02:14:11,199
worrying query quality search pattern

2722
02:14:11,199 --> 02:14:13,199
leakage but at a very high level what

2723
02:14:13,199 --> 02:14:14,560
happens is when you send up these sort

2724
02:14:14,560 --> 02:14:15,920
of search tokens you know here the

2725
02:14:15,920 --> 02:14:18,560
search tokens are simply hashes of of

2726
02:14:18,560 --> 02:14:20,480
of the queried key

2727
02:14:20,480 --> 02:14:22,800
you sort of leak information because of

2728
02:14:22,800 --> 02:14:25,040
these hashes have some structure

2729
02:14:25,040 --> 02:14:26,560
and in particular what you can do is

2730
02:14:26,560 --> 02:14:29,280
simply see if any two hashes are equal

2731
02:14:29,280 --> 02:14:30,880
because if two hashes are equal with

2732
02:14:30,880 --> 02:14:32,560
high probability they're for the same

2733
02:14:32,560 --> 02:14:33,520
key

2734
02:14:33,520 --> 02:14:34,639
and you can build up something like a

2735
02:14:34,639 --> 02:14:36,239
matrix where you sort of

2736
02:14:36,239 --> 02:14:38,639
put you know hashes here put the same

2737
02:14:38,639 --> 02:14:40,480
search tokens over there and simply

2738
02:14:40,480 --> 02:14:42,000
build a matrix to see if they're equal

2739
02:14:42,000 --> 02:14:43,920
so for example you know if these two

2740
02:14:43,920 --> 02:14:45,599
aren't equal i'll put a zero

2741
02:14:45,599 --> 02:14:47,119
if these two were equal i put a one and

2742
02:14:47,119 --> 02:14:48,480
i could fill out this whole

2743
02:14:48,480 --> 02:14:50,480
matrix so it's symmetrics i only care

2744
02:14:50,480 --> 02:14:53,199
about one one triangle of it

2745
02:14:53,199 --> 02:14:55,040
but this is sort of one leakage that the

2746
02:14:55,040 --> 02:14:57,599
adversary can't see

2747
02:14:57,599 --> 02:14:59,440
um okay so

2748
02:14:59,440 --> 02:15:01,440
unfortunately specifically for this

2749
02:15:01,440 --> 02:15:02,639
leakage

2750
02:15:02,639 --> 02:15:04,079
it turns out that it might be a little

2751
02:15:04,079 --> 02:15:05,599
tough to actually mitigate so in

2752
02:15:05,599 --> 02:15:06,880
particular

2753
02:15:06,880 --> 02:15:08,560
there is evidence that mitigating key

2754
02:15:08,560 --> 02:15:10,639
equality leakage even slightly in the

2755
02:15:10,639 --> 02:15:11,760
dynamic settings so i'm going to make

2756
02:15:11,760 --> 02:15:14,000
sure i'm copying the dynamic setting is

2757
02:15:14,000 --> 02:15:16,159
actually quite hard and in fact

2758
02:15:16,159 --> 02:15:18,079
uh what you can show is that if you

2759
02:15:18,079 --> 02:15:19,520
mitigate key quality leakage even a

2760
02:15:19,520 --> 02:15:20,639
little bit

2761
02:15:20,639 --> 02:15:22,639
you end up having to sort of pay for it

2762
02:15:22,639 --> 02:15:23,840
with logarithmic overhead which is

2763
02:15:23,840 --> 02:15:25,840
equivalent to orams which you know like

2764
02:15:25,840 --> 02:15:27,360
we said earlier in these talks is

2765
02:15:27,360 --> 02:15:28,560
something we'd like to avoid because

2766
02:15:28,560 --> 02:15:30,239
it's quite expensive

2767
02:15:30,239 --> 02:15:31,920
um so if anyone's interested this is a

2768
02:15:31,920 --> 02:15:34,400
joint work with uh sarvar and pino where

2769
02:15:34,400 --> 02:15:36,239
we actually proved this sort of formally

2770
02:15:36,239 --> 02:15:38,800
um one thing i'll caveat is one way that

2771
02:15:38,800 --> 02:15:41,040
the sort of the community has done this

2772
02:15:41,040 --> 02:15:43,040
in the past is show a tax on leakage

2773
02:15:43,040 --> 02:15:44,719
right where we sort of say hey this

2774
02:15:44,719 --> 02:15:47,199
specific leakage may not be good to may

2775
02:15:47,199 --> 02:15:49,360
not be sufficient for privacy that's not

2776
02:15:49,360 --> 02:15:50,400
what we do here

2777
02:15:50,400 --> 02:15:52,320
here we're actually proving formal uh

2778
02:15:52,320 --> 02:15:54,239
trade-offs where we say look if you want

2779
02:15:54,239 --> 02:15:55,920
to get rid of this privacy you actually

2780
02:15:55,920 --> 02:15:57,679
have to pay it in terms of what are what

2781
02:15:57,679 --> 02:15:59,679
in terms of complexity so these are sort

2782
02:15:59,679 --> 02:16:01,040
of like unconditional lower bounds as

2783
02:16:01,040 --> 02:16:02,239
opposed to lower balance based on

2784
02:16:02,239 --> 02:16:05,040
leakage attacks

2785
02:16:05,040 --> 02:16:06,800
all right so uh going back to the topic

2786
02:16:06,800 --> 02:16:09,280
okay well uh unfortunately key equality

2787
02:16:09,280 --> 02:16:10,639
leakage is something that seems quite

2788
02:16:10,639 --> 02:16:12,880
difficult to mitigate

2789
02:16:12,880 --> 02:16:14,159
maybe we have to live with it but let's

2790
02:16:14,159 --> 02:16:17,199
suppose we have to for now

2791
02:16:17,199 --> 02:16:19,360
um so what else could we mitigate right

2792
02:16:19,360 --> 02:16:20,800
there's other there are other things

2793
02:16:20,800 --> 02:16:22,800
here that the adversary can still see

2794
02:16:22,800 --> 02:16:24,159
that we might want to actually get rid

2795
02:16:24,159 --> 02:16:24,960
of

2796
02:16:24,960 --> 02:16:27,440
and as the beginning of the talk eluded

2797
02:16:27,440 --> 02:16:29,360
it's called volume leakage

2798
02:16:29,360 --> 02:16:30,719
so let's take a look you know there's

2799
02:16:30,719 --> 02:16:33,120
two sides of this uh of the coin of this

2800
02:16:33,120 --> 02:16:35,439
uh querying response so the query we may

2801
02:16:35,439 --> 02:16:36,718
not be able to do much but how about the

2802
02:16:36,718 --> 02:16:37,840
response

2803
02:16:37,840 --> 02:16:39,519
in fact what we're doing is setting an

2804
02:16:39,519 --> 02:16:41,439
encryption of a value tuple right and in

2805
02:16:41,439 --> 02:16:42,718
fact what you can see is that you can

2806
02:16:42,718 --> 02:16:44,558
sort of tell the length right if you did

2807
02:16:44,558 --> 02:16:46,638
this sort of naively i can tell for

2808
02:16:46,638 --> 02:16:48,718
example this vi is shorter than the v2

2809
02:16:48,718 --> 02:16:51,599
just an example i've given

2810
02:16:51,599 --> 02:16:52,959
um and it

2811
02:16:52,959 --> 02:16:54,718
and so let's see what could you do with

2812
02:16:54,718 --> 02:16:56,558
this right so like i mean there's many

2813
02:16:56,558 --> 02:16:58,718
many attacks that sort of exploit this i

2814
02:16:58,718 --> 02:16:59,679
think

2815
02:16:59,679 --> 02:17:01,599
i think in the previous uh talk as well

2816
02:17:01,599 --> 02:17:03,120
it was shown that you could do this and

2817
02:17:03,120 --> 02:17:04,558
they heavily leverage it but the

2818
02:17:04,558 --> 02:17:06,160
simplest example i like to give is sort

2819
02:17:06,160 --> 02:17:07,359
of let's say you know you have these

2820
02:17:07,359 --> 02:17:09,120
value tuples and they sort of associated

2821
02:17:09,120 --> 02:17:11,200
to words that appear in dictionaries

2822
02:17:11,200 --> 02:17:13,200
you could take like a frequency list of

2823
02:17:13,200 --> 02:17:14,959
the wikipedia words

2824
02:17:14,959 --> 02:17:16,799
at a high level sort of map them to

2825
02:17:16,799 --> 02:17:18,318
something that looks like like this

2826
02:17:18,318 --> 02:17:20,240
distribution and sort of start pairing

2827
02:17:20,240 --> 02:17:22,160
them off in a trivial way to see if you

2828
02:17:22,160 --> 02:17:23,760
could if you could see like sort of

2829
02:17:23,760 --> 02:17:24,879
trying to reverse engineer what the

2830
02:17:24,879 --> 02:17:26,799
values mean so maybe mouse is the

2831
02:17:26,799 --> 02:17:29,280
largest one cat is smaller i don't know

2832
02:17:29,280 --> 02:17:30,000
why

2833
02:17:30,000 --> 02:17:31,439
mouse appears more than cat but you know

2834
02:17:31,439 --> 02:17:33,200
this is just a simple example the

2835
02:17:33,200 --> 02:17:35,040
attacks are far more complicated and far

2836
02:17:35,040 --> 02:17:36,799
more intelligent than this but just an

2837
02:17:36,799 --> 02:17:38,398
example of how volume leakage could be

2838
02:17:38,398 --> 02:17:40,638
useful

2839
02:17:40,840 --> 02:17:42,799
intuitively uh like i said yeah there's

2840
02:17:42,799 --> 02:17:44,318
a huge line of works that leverage

2841
02:17:44,318 --> 02:17:45,599
volume hiding or

2842
02:17:45,599 --> 02:17:47,280
the leverage volume leakage right so

2843
02:17:47,280 --> 02:17:48,160
it's

2844
02:17:48,160 --> 02:17:50,160
interesting let's see if we could hide

2845
02:17:50,160 --> 02:17:52,240
volumes in a way to maybe make these

2846
02:17:52,240 --> 02:17:54,558
attacks harder maybe make them obsolete

2847
02:17:54,558 --> 02:17:56,959
or maybe sort of maybe force the

2848
02:17:56,959 --> 02:17:58,718
research to say okay

2849
02:17:58,718 --> 02:18:00,240
this specific attacks don't work but we

2850
02:18:00,240 --> 02:18:02,558
can sort of supplement them without

2851
02:18:02,558 --> 02:18:04,959
volume leakage to still make them work

2852
02:18:04,959 --> 02:18:07,120
so

2853
02:18:07,120 --> 02:18:08,959
all right so this leads to the idea of

2854
02:18:08,959 --> 02:18:10,959
volume hiding multi-maps how could we

2855
02:18:10,959 --> 02:18:12,718
sort of hide the volumes that are leaked

2856
02:18:12,718 --> 02:18:16,318
from the uh to the adversarial server

2857
02:18:16,318 --> 02:18:18,160
so this was actually introduced in the

2858
02:18:18,160 --> 02:18:20,398
seminal work by sunny and tariq i think

2859
02:18:20,398 --> 02:18:22,799
at eurocrypt a couple years ago

2860
02:18:22,799 --> 02:18:24,318
where they essentially formalized this

2861
02:18:24,318 --> 02:18:26,080
notion of trying to hide volumes in a

2862
02:18:26,080 --> 02:18:29,039
multi-map setting

2863
02:18:29,359 --> 02:18:31,920
so okay so look uh i think this paper

2864
02:18:31,920 --> 02:18:33,920
specifically by sunny injury had a whole

2865
02:18:33,920 --> 02:18:35,599
bunch of sort of different constructions

2866
02:18:35,599 --> 02:18:36,879
that were really cool in a variety of

2867
02:18:36,879 --> 02:18:38,558
different ways

2868
02:18:38,558 --> 02:18:40,638
they had both lossy ones and lossless

2869
02:18:40,638 --> 02:18:42,478
ones as well as ones based on some very

2870
02:18:42,478 --> 02:18:44,240
complicated like computational

2871
02:18:44,240 --> 02:18:45,840
assumptions i think the planted densest

2872
02:18:45,840 --> 02:18:48,959
subgraph transform was based on this

2873
02:18:48,959 --> 02:18:50,718
for this specific talk i'll focus on

2874
02:18:50,718 --> 02:18:52,160
their work that only consider sort of

2875
02:18:52,160 --> 02:18:53,920
lossless in the fact that nothing no

2876
02:18:53,920 --> 02:18:56,318
information is lost during queries

2877
02:18:56,318 --> 02:18:57,120
so

2878
02:18:57,120 --> 02:18:58,638
all right how can we do this i mean the

2879
02:18:58,638 --> 02:19:00,000
most simplest approach to trying to

2880
02:19:00,000 --> 02:19:01,920
solve this problem is just naive padding

2881
02:19:01,920 --> 02:19:04,160
right what i'm going to do is i have

2882
02:19:04,160 --> 02:19:06,718
these value tuples i can sort of see the

2883
02:19:06,718 --> 02:19:08,240
maximum maybe i'm okay with getting with

2884
02:19:08,240 --> 02:19:10,080
with the long to leak maximum which i

2885
02:19:10,080 --> 02:19:11,439
think we will be enjoying this entire

2886
02:19:11,439 --> 02:19:12,318
talk

2887
02:19:12,318 --> 02:19:14,558
and i simply just pad you know i take

2888
02:19:14,558 --> 02:19:16,638
all of these dummies and i sort of add

2889
02:19:16,638 --> 02:19:20,718
uh fake encryptions and uh so this works

2890
02:19:20,718 --> 02:19:22,160
right like what would happen now is that

2891
02:19:22,160 --> 02:19:23,920
the the multi-map rather than returning

2892
02:19:23,920 --> 02:19:26,000
the exact tuple of the exact length of

2893
02:19:26,000 --> 02:19:28,160
the values i'll return one corresponding

2894
02:19:28,160 --> 02:19:31,039
to the maximum one

2895
02:19:31,599 --> 02:19:33,519
um the problem is that this isn't very

2896
02:19:33,519 --> 02:19:35,760
efficient so for example let's take a

2897
02:19:35,760 --> 02:19:37,599
multi-map that looks like this where

2898
02:19:37,599 --> 02:19:39,040
most of the entries are really small but

2899
02:19:39,040 --> 02:19:41,280
one is linear in size

2900
02:19:41,280 --> 02:19:43,200
so when you pad this what you end up

2901
02:19:43,200 --> 02:19:45,280
with is essentially quadratic space

2902
02:19:45,280 --> 02:19:46,718
right

2903
02:19:46,718 --> 02:19:48,558
so naive padding it's great for query

2904
02:19:48,558 --> 02:19:50,080
time it's essentially optimal if you

2905
02:19:50,080 --> 02:19:52,319
want to be volume hiding completely you

2906
02:19:52,319 --> 02:19:54,240
sort of have to sort of return

2907
02:19:54,240 --> 02:19:55,840
the query time has to be at least linear

2908
02:19:55,840 --> 02:19:57,680
in the in the size of the maximum volume

2909
02:19:57,680 --> 02:19:59,680
which we don't know by l

2910
02:19:59,680 --> 02:20:01,600
but the worst case storage is quadratic

2911
02:20:01,600 --> 02:20:02,880
which is

2912
02:20:02,880 --> 02:20:06,479
in a sense not very satisfying

2913
02:20:07,120 --> 02:20:08,399
okay so

2914
02:20:08,399 --> 02:20:10,479
to sort of uh solve this problem and

2915
02:20:10,479 --> 02:20:12,080
reduce the

2916
02:20:12,080 --> 02:20:13,680
the storage size

2917
02:20:13,680 --> 02:20:15,200
sunny and chewy came up with this idea

2918
02:20:15,200 --> 02:20:16,720
of mapping based on what are called

2919
02:20:16,720 --> 02:20:18,720
erdogani graphs which are essentially

2920
02:20:18,720 --> 02:20:20,319
just random graphs

2921
02:20:20,319 --> 02:20:22,479
so at a very high level what happens is

2922
02:20:22,479 --> 02:20:23,920
they're sort of you know let's suppose

2923
02:20:23,920 --> 02:20:25,600
now i'm taking these value tuples

2924
02:20:25,600 --> 02:20:26,960
there's four volume tuples each of

2925
02:20:26,960 --> 02:20:28,640
different sizes

2926
02:20:28,640 --> 02:20:29,840
and what they're essentially doing is

2927
02:20:29,840 --> 02:20:31,439
going to map them

2928
02:20:31,439 --> 02:20:33,359
to bins let's call these let's think of

2929
02:20:33,359 --> 02:20:35,600
these bins on the server

2930
02:20:35,600 --> 02:20:37,520
in a way that's sort of defined by erdis

2931
02:20:37,520 --> 02:20:39,200
running graph which essentially at a

2932
02:20:39,200 --> 02:20:42,000
very high level is taking each value

2933
02:20:42,000 --> 02:20:44,160
and sort of randomly assigning it based

2934
02:20:44,160 --> 02:20:45,680
on maybe the output of a pseudo-random

2935
02:20:45,680 --> 02:20:47,280
function right let's say we're using

2936
02:20:47,280 --> 02:20:48,960
sort of randomness

2937
02:20:48,960 --> 02:20:50,399
so you're gonna maybe i took that green

2938
02:20:50,399 --> 02:20:52,399
one this hash functions that essentially

2939
02:20:52,399 --> 02:20:54,640
has to appear at it should go in this

2940
02:20:54,640 --> 02:20:57,280
bin and i throw it in this bin

2941
02:20:57,280 --> 02:20:58,880
and i do it again for the purple ones so

2942
02:20:58,880 --> 02:21:00,640
maybe i said okay that one goes there

2943
02:21:00,640 --> 02:21:02,080
and then you know essentially what i'm

2944
02:21:02,080 --> 02:21:04,080
doing is taking this hash and you know

2945
02:21:04,080 --> 02:21:06,080
appending the count of it and putting it

2946
02:21:06,080 --> 02:21:07,520
into different bins

2947
02:21:07,520 --> 02:21:09,200
so randomly essentially long story short

2948
02:21:09,200 --> 02:21:10,560
we're taking each value independent

2949
02:21:10,560 --> 02:21:11,600
throwing it into a random bin

2950
02:21:11,600 --> 02:21:13,520
independently

2951
02:21:13,520 --> 02:21:16,080
so how can you use this to to do queries

2952
02:21:16,080 --> 02:21:17,520
well let's suppose you wanted to query

2953
02:21:17,520 --> 02:21:20,160
for the purple key

2954
02:21:20,160 --> 02:21:21,760
and you know the maximum volume here is

2955
02:21:21,760 --> 02:21:24,000
four so what i can do essentially is

2956
02:21:24,000 --> 02:21:26,560
compute the pseudo-random functions of

2957
02:21:26,560 --> 02:21:28,800
purple you know all the way to l and i

2958
02:21:28,800 --> 02:21:31,040
know the l locations that sort of

2959
02:21:31,040 --> 02:21:32,560
if this

2960
02:21:32,560 --> 02:21:34,560
if this key had l values

2961
02:21:34,560 --> 02:21:37,280
where all the l values would live

2962
02:21:37,280 --> 02:21:38,720
and sort of what i'm going to do is this

2963
02:21:38,720 --> 02:21:39,840
associates maybe through these four

2964
02:21:39,840 --> 02:21:41,359
because l equals four and i simply

2965
02:21:41,359 --> 02:21:43,359
return the bids

2966
02:21:43,359 --> 02:21:45,200
right i can do the same thing for this

2967
02:21:45,200 --> 02:21:47,280
for this green one as well uh i i show

2968
02:21:47,280 --> 02:21:48,560
you the green one here because of the

2969
02:21:48,560 --> 02:21:51,439
key point is even so the purple one had

2970
02:21:51,439 --> 02:21:53,439
had four values so i return all four

2971
02:21:53,439 --> 02:21:55,120
bins but of course for the green one

2972
02:21:55,120 --> 02:21:56,880
there was only one value but i have to

2973
02:21:56,880 --> 02:21:58,399
be volume hiding i have to make sure

2974
02:21:58,399 --> 02:22:00,560
that i look as if you know i was pouring

2975
02:22:00,560 --> 02:22:01,920
the purple ones so you what you do is

2976
02:22:01,920 --> 02:22:04,399
even if there was one value for green

2977
02:22:04,399 --> 02:22:06,240
you sort of query as if it could have

2978
02:22:06,240 --> 02:22:07,760
had the maximum value in return all of

2979
02:22:07,760 --> 02:22:10,240
the bins

2980
02:22:10,720 --> 02:22:11,600
okay

2981
02:22:11,600 --> 02:22:13,760
so this is this is pretty cool um one

2982
02:22:13,760 --> 02:22:15,680
thing i'll note is actually that you're

2983
02:22:15,680 --> 02:22:17,520
going to have to sort of pad each of the

2984
02:22:17,520 --> 02:22:18,960
bins to the maximum size and this is

2985
02:22:18,960 --> 02:22:20,800
where the this is this is going to be an

2986
02:22:20,800 --> 02:22:22,560
interesting fact

2987
02:22:22,560 --> 02:22:24,319
but what you can actually show is that

2988
02:22:24,319 --> 02:22:26,240
each bin is padded to size like the

2989
02:22:26,240 --> 02:22:27,439
maximum

2990
02:22:27,439 --> 02:22:29,280
size of any bin will be logarithmic and

2991
02:22:29,280 --> 02:22:30,560
this is done through a standard balls

2992
02:22:30,560 --> 02:22:32,880
into bins analysis essentially

2993
02:22:32,880 --> 02:22:34,000
and what that means is each of these

2994
02:22:34,000 --> 02:22:36,479
bins are padded to log in but by

2995
02:22:36,479 --> 02:22:37,840
choosing the bins correctly you can

2996
02:22:37,840 --> 02:22:39,600
ensure that the storage size remains

2997
02:22:39,600 --> 02:22:41,200
linear in a sense you can choose the

2998
02:22:41,200 --> 02:22:42,800
bins i think to be just slightly n over

2999
02:22:42,800 --> 02:22:44,640
login

3000
02:22:44,640 --> 02:22:46,880
so the storage remains order in but the

3001
02:22:46,880 --> 02:22:49,280
query time now is l log n and again just

3002
02:22:49,280 --> 02:22:51,040
to make sure each of these bins are

3003
02:22:51,040 --> 02:22:54,240
padded to log in size

3004
02:22:54,800 --> 02:22:57,200
okay um okay they're padded to log

3005
02:22:57,200 --> 02:23:00,399
inside so we're turning the whole bit

3006
02:23:00,399 --> 02:23:02,319
so okay so this is uh this is good this

3007
02:23:02,319 --> 02:23:03,920
is this is much better than iv padding

3008
02:23:03,920 --> 02:23:05,359
right before the night padding had

3009
02:23:05,359 --> 02:23:07,439
quadratic storage but it had

3010
02:23:07,439 --> 02:23:10,080
perfect uh query complexity

3011
02:23:10,080 --> 02:23:11,840
and now what we what uh this paper by

3012
02:23:11,840 --> 02:23:13,359
signing turkey shows essentially you can

3013
02:23:13,359 --> 02:23:16,160
achieve sort of optimal storage and have

3014
02:23:16,160 --> 02:23:17,760
query time that's still very interesting

3015
02:23:17,760 --> 02:23:19,359
that's login

3016
02:23:19,359 --> 02:23:20,399
but you know

3017
02:23:20,399 --> 02:23:22,000
being a good being a good researcher the

3018
02:23:22,000 --> 02:23:23,920
question is can you do better

3019
02:23:23,920 --> 02:23:25,520
and ideally what you want is something

3020
02:23:25,520 --> 02:23:27,520
like this right you want storage to be

3021
02:23:27,520 --> 02:23:29,680
linear in size and you want the query

3022
02:23:29,680 --> 02:23:33,840
time to be linear in the maximum volume

3023
02:23:34,080 --> 02:23:36,080
so this this ends up to be the the

3024
02:23:36,080 --> 02:23:38,560
construction that we came up with

3025
02:23:38,560 --> 02:23:40,240
so

3026
02:23:40,240 --> 02:23:42,000
uh the main idea essentially is

3027
02:23:42,000 --> 02:23:43,439
leveraging is sort of going back to

3028
02:23:43,439 --> 02:23:45,120
let's say going back here what's

3029
02:23:45,120 --> 02:23:47,680
happening right if you think about it

3030
02:23:47,680 --> 02:23:49,680
very carefully what you're trying to do

3031
02:23:49,680 --> 02:23:50,399
is

3032
02:23:50,399 --> 02:23:51,520
hash

3033
02:23:51,520 --> 02:23:54,000
right you sort of have a multi-map you

3034
02:23:54,000 --> 02:23:55,760
have these all these values and you sort

3035
02:23:55,760 --> 02:23:57,520
of want to hash them in some very

3036
02:23:57,520 --> 02:23:58,960
succinct way

3037
02:23:58,960 --> 02:24:00,720
so you want to use storage that's

3038
02:24:00,720 --> 02:24:03,680
minimal i.e linear in the multi-map

3039
02:24:03,680 --> 02:24:05,120
but you also want to have retrievals

3040
02:24:05,120 --> 02:24:06,800
that are also linear

3041
02:24:06,800 --> 02:24:08,319
right retrievals that are sort of

3042
02:24:08,319 --> 02:24:10,319
constant per value here they're not

3043
02:24:10,319 --> 02:24:12,080
constant per value because of the sort

3044
02:24:12,080 --> 02:24:13,840
of we're using a hashing scheme which is

3045
02:24:13,840 --> 02:24:15,520
just this which is sort of a simplistic

3046
02:24:15,520 --> 02:24:17,680
balls into bits

3047
02:24:17,680 --> 02:24:19,439
so with that key in sight what we can do

3048
02:24:19,439 --> 02:24:20,960
is sort of plug in a better hashing

3049
02:24:20,960 --> 02:24:22,160
function and in particular we're going

3050
02:24:22,160 --> 02:24:23,840
to use something called cuckoo hashing

3051
02:24:23,840 --> 02:24:26,479
with a stash

3052
02:24:27,120 --> 02:24:29,439
in fact you can just use uh to be there

3053
02:24:29,439 --> 02:24:30,479
i'm not going to go into it but the

3054
02:24:30,479 --> 02:24:31,840
reason we have to use the stash is

3055
02:24:31,840 --> 02:24:33,760
because the cuckoo hashing fails with

3056
02:24:33,760 --> 02:24:35,600
following a one over polynomial failure

3057
02:24:35,600 --> 02:24:37,680
probability which can be privacy uh sort

3058
02:24:37,680 --> 02:24:38,720
of leaking

3059
02:24:38,720 --> 02:24:40,240
and if you use a stash you can make that

3060
02:24:40,240 --> 02:24:42,960
you can drive that down to the legend

3061
02:24:42,960 --> 02:24:44,880
okay so let's let's take a look at this

3062
02:24:44,880 --> 02:24:46,160
again now with the lens of sort of

3063
02:24:46,160 --> 02:24:47,120
hashing

3064
02:24:47,120 --> 02:24:49,200
um so how does google hashing work you

3065
02:24:49,200 --> 02:24:50,720
can sort of what happens is you have all

3066
02:24:50,720 --> 02:24:52,160
of these values

3067
02:24:52,160 --> 02:24:53,520
and what you want to do is sort of throw

3068
02:24:53,520 --> 02:24:55,280
them into these uh two different tables

3069
02:24:55,280 --> 02:24:56,640
so you have a table on the top table on

3070
02:24:56,640 --> 02:24:58,240
the bottom and both of them are slightly

3071
02:24:58,240 --> 02:24:59,840
larger than linear

3072
02:24:59,840 --> 02:25:01,520
all right so the total is about two plus

3073
02:25:01,520 --> 02:25:04,000
epsilon n total storage

3074
02:25:04,000 --> 02:25:05,520
and how cuckoo hashing works is sort of

3075
02:25:05,520 --> 02:25:08,080
you take you take a okay i should also

3076
02:25:08,080 --> 02:25:09,760
mention that we have stash so what

3077
02:25:09,760 --> 02:25:11,280
happens is this stash will essentially

3078
02:25:11,280 --> 02:25:13,760
be allowed to sort of store overflows if

3079
02:25:13,760 --> 02:25:15,120
anything doesn't fit into the cuckoo

3080
02:25:15,120 --> 02:25:17,120
hashing scheme for some reason i'm not

3081
02:25:17,120 --> 02:25:18,960
going to get into the theoretical why

3082
02:25:18,960 --> 02:25:20,880
you can sort of throw it into the stash

3083
02:25:20,880 --> 02:25:23,120
essentially just to avoid sort of

3084
02:25:23,120 --> 02:25:26,720
failing to build the the hash table

3085
02:25:26,720 --> 02:25:28,800
so how does kook hashing work so you

3086
02:25:28,800 --> 02:25:31,120
take the first item rather than now only

3087
02:25:31,120 --> 02:25:33,040
sending it to one random entry i'm going

3088
02:25:33,040 --> 02:25:35,359
to send it to two random entries so this

3089
02:25:35,359 --> 02:25:37,520
is based on sort of again

3090
02:25:37,520 --> 02:25:39,040
random function

3091
02:25:39,040 --> 02:25:40,240
and now what i'm going to say is that

3092
02:25:40,240 --> 02:25:42,160
this this specific value can appear in

3093
02:25:42,160 --> 02:25:44,000
either of these two sort of entries or

3094
02:25:44,000 --> 02:25:45,760
the stash

3095
02:25:45,760 --> 02:25:46,880
so when you're doing this at first it

3096
02:25:46,880 --> 02:25:47,840
doesn't really matter which one you put

3097
02:25:47,840 --> 02:25:49,359
it in they're both empty

3098
02:25:49,359 --> 02:25:50,560
and now let's suppose you do this again

3099
02:25:50,560 --> 02:25:51,600
with the next one and there's a

3100
02:25:51,600 --> 02:25:52,640
collision

3101
02:25:52,640 --> 02:25:54,080
right

3102
02:25:54,080 --> 02:25:56,080
so you know the this purple one wants to

3103
02:25:56,080 --> 02:25:57,200
go into the green one or it can go to

3104
02:25:57,200 --> 02:25:58,880
this other one and let's suppose for

3105
02:25:58,880 --> 02:26:00,319
some reason we decided to do it and put

3106
02:26:00,319 --> 02:26:02,240
it put it there what cuckoo hashing

3107
02:26:02,240 --> 02:26:03,680
essentially says is you take the green

3108
02:26:03,680 --> 02:26:04,960
one and sort of

3109
02:26:04,960 --> 02:26:06,319
what it like what i don't know if you

3110
02:26:06,319 --> 02:26:07,359
guys know what a cuckoo bird is they

3111
02:26:07,359 --> 02:26:09,359
sort of switch between nests here you're

3112
02:26:09,359 --> 02:26:10,640
going to switch the value to his other

3113
02:26:10,640 --> 02:26:12,240
option so before it had two options then

3114
02:26:12,240 --> 02:26:13,840
you're going to throw into the other one

3115
02:26:13,840 --> 02:26:15,120
and you sort of repeatedly going to do

3116
02:26:15,120 --> 02:26:17,760
this for each sort of uh

3117
02:26:17,760 --> 02:26:20,640
value in the in the multi-map until you

3118
02:26:20,640 --> 02:26:22,880
get something like like this so you know

3119
02:26:22,880 --> 02:26:24,319
some of the items can also appear into

3120
02:26:24,319 --> 02:26:25,760
the stash and you'll get something like

3121
02:26:25,760 --> 02:26:28,240
this so we're sort of you have these

3122
02:26:28,240 --> 02:26:30,399
tables um you know some of them are

3123
02:26:30,399 --> 02:26:32,160
occupied some of them are empty and the

3124
02:26:32,160 --> 02:26:35,120
rest are in the stash uh so a caviar

3125
02:26:35,120 --> 02:26:37,040
here you're gonna again pad all the

3126
02:26:37,040 --> 02:26:38,399
entries but here we're padding every

3127
02:26:38,399 --> 02:26:40,640
entry to size one because every

3128
02:26:40,640 --> 02:26:44,399
entry can store at most one one item

3129
02:26:45,439 --> 02:26:47,920
um okay so let's suppose you had this

3130
02:26:47,920 --> 02:26:49,359
now this is just a different like this

3131
02:26:49,359 --> 02:26:51,040
sort of doesn't look very different than

3132
02:26:51,040 --> 02:26:52,720
the other picture i had before

3133
02:26:52,720 --> 02:26:54,240
it's instead of having bins that can

3134
02:26:54,240 --> 02:26:56,479
have multiple items now i have sort of

3135
02:26:56,479 --> 02:26:58,960
two two plus epsilon n bins and most of

3136
02:26:58,960 --> 02:27:01,520
them are size one or zero except for the

3137
02:27:01,520 --> 02:27:04,479
stash which should be slightly larger

3138
02:27:04,479 --> 02:27:06,160
now if you want a query for this purple

3139
02:27:06,160 --> 02:27:07,040
uh

3140
02:27:07,040 --> 02:27:09,120
purple key what you can simply do is

3141
02:27:09,120 --> 02:27:12,080
again like before find the 2l entries

3142
02:27:12,080 --> 02:27:13,760
that could contain items for for the

3143
02:27:13,760 --> 02:27:16,080
purple values

3144
02:27:16,080 --> 02:27:18,399
um so this is quite large it's really

3145
02:27:18,399 --> 02:27:19,920
unnecessary in fact you can just replace

3146
02:27:19,920 --> 02:27:21,600
it with a single prf and then use the

3147
02:27:21,600 --> 02:27:23,359
prg on the server side to sort of derive

3148
02:27:23,359 --> 02:27:24,800
the rest

3149
02:27:24,800 --> 02:27:26,319
and then now given this what what the

3150
02:27:26,319 --> 02:27:27,439
what'll happen essentially is that the

3151
02:27:27,439 --> 02:27:29,760
server will simply return these two l

3152
02:27:29,760 --> 02:27:31,280
locations that could contain purple

3153
02:27:31,280 --> 02:27:32,800
items and you don't know there's gonna

3154
02:27:32,800 --> 02:27:34,000
be some sort of

3155
02:27:34,000 --> 02:27:35,600
overlap here so you'll get you'll

3156
02:27:35,600 --> 02:27:37,520
definitely get all the purple items

3157
02:27:37,520 --> 02:27:39,280
but you may get some other items as well

3158
02:27:39,280 --> 02:27:40,720
so you know you're gonna encrypt into

3159
02:27:40,720 --> 02:27:42,319
each of the values what what sort of

3160
02:27:42,319 --> 02:27:43,680
actual key it was to make sure you

3161
02:27:43,680 --> 02:27:46,479
filter those out on the client side

3162
02:27:46,479 --> 02:27:47,760
simultaneously you also have to download

3163
02:27:47,760 --> 02:27:48,880
this dash

3164
02:27:48,880 --> 02:27:50,319
right which is just think of it as a

3165
02:27:50,319 --> 02:27:53,199
much larger bucket

3166
02:27:53,439 --> 02:27:54,240
so

3167
02:27:54,240 --> 02:27:55,840
what ends up happening here if you think

3168
02:27:55,840 --> 02:27:57,280
carefully is now rather than having to

3169
02:27:57,280 --> 02:27:59,200
download l times login

3170
02:27:59,200 --> 02:28:02,160
sort of entries per uh in the past

3171
02:28:02,160 --> 02:28:04,479
now i'm just downloading 2l uh entries

3172
02:28:04,479 --> 02:28:06,160
downloaded plus the stash and the stash

3173
02:28:06,160 --> 02:28:08,720
in general you can prove is omega 1.

3174
02:28:08,720 --> 02:28:10,240
if you choose the stash to be any

3175
02:28:10,240 --> 02:28:12,640
function that's slightly super constant

3176
02:28:12,640 --> 02:28:14,720
asymptotically you can prove that the

3177
02:28:14,720 --> 02:28:18,319
that this works in terms of privacy

3178
02:28:18,880 --> 02:28:19,840
okay

3179
02:28:19,840 --> 02:28:21,680
so in the end this is what we get

3180
02:28:21,680 --> 02:28:23,200
essentially

3181
02:28:23,200 --> 02:28:24,479
so

3182
02:28:24,479 --> 02:28:25,920
uh this sort of match not only does it

3183
02:28:25,920 --> 02:28:28,080
match asymptotically what we wanted in

3184
02:28:28,080 --> 02:28:29,840
fact the constants are really small the

3185
02:28:29,840 --> 02:28:31,520
storage is essentially twice as large as

3186
02:28:31,520 --> 02:28:33,840
the original multi-map

3187
02:28:33,840 --> 02:28:35,520
and the query time is two times the

3188
02:28:35,520 --> 02:28:36,880
maximum volume

3189
02:28:36,880 --> 02:28:38,319
plus the size of the stash which really

3190
02:28:38,319 --> 02:28:40,479
is omega one and i think in practice

3191
02:28:40,479 --> 02:28:41,840
uh from the experiments we ran they're

3192
02:28:41,840 --> 02:28:44,800
almost always zero

3193
02:28:45,600 --> 02:28:47,040
okay

3194
02:28:47,040 --> 02:28:48,560
so all right so that's sort of the

3195
02:28:48,560 --> 02:28:50,160
construction this achieves sort of the

3196
02:28:50,160 --> 02:28:51,840
first question that we had which was

3197
02:28:51,840 --> 02:28:54,319
could we obtain sort of volume hiding in

3198
02:28:54,319 --> 02:28:56,000
and not only asymptotically optimal but

3199
02:28:56,000 --> 02:28:58,960
even concretely optimal almost

3200
02:28:58,960 --> 02:29:00,800
all right so uh you know you're going to

3201
02:29:00,800 --> 02:29:02,080
keep asking questions as a researcher

3202
02:29:02,080 --> 02:29:03,840
we've got to find more papers to write

3203
02:29:03,840 --> 02:29:05,359
so what's the next problem we want to

3204
02:29:05,359 --> 02:29:07,359
work on which was this sort of annoying

3205
02:29:07,359 --> 02:29:09,840
thing which was you know

3206
02:29:09,840 --> 02:29:11,439
it's a little more philosophical almost

3207
02:29:11,439 --> 02:29:12,960
but do we always have to download the

3208
02:29:12,960 --> 02:29:14,640
maximum volume

3209
02:29:14,640 --> 02:29:16,240
right if you wanted to sort of get these

3210
02:29:16,240 --> 02:29:17,680
sort of indistinguishability notions

3211
02:29:17,680 --> 02:29:19,760
this is definitively true right we have

3212
02:29:19,760 --> 02:29:23,640
to make sure that you downl

3213
02:29:29,760 --> 02:29:32,479
volume hiding but could you do something

3214
02:29:32,479 --> 02:29:34,960
better right like in a sense that

3215
02:29:34,960 --> 02:29:37,120
can we consider a slightly weaker notion

3216
02:29:37,120 --> 02:29:39,359
that makes sense i'm not sure we don't

3217
02:29:39,359 --> 02:29:40,960
know if it's completely private that

3218
02:29:40,960 --> 02:29:42,160
makes sense

3219
02:29:42,160 --> 02:29:43,760
but it guarantees you that you can

3220
02:29:43,760 --> 02:29:45,680
download slightly less than l entries on

3221
02:29:45,680 --> 02:29:47,680
average

3222
02:29:47,680 --> 02:29:49,359
and

3223
02:29:49,359 --> 02:29:50,880
okay so that's the question that way

3224
02:29:50,880 --> 02:29:52,000
that we asked like is there a right

3225
02:29:52,000 --> 02:29:53,600
privacy notion for this that at least

3226
02:29:53,600 --> 02:29:54,880
makes sense i'm not sure if it's secure

3227
02:29:54,880 --> 02:29:57,200
but it makes sense

3228
02:29:57,200 --> 02:29:58,479
all right so this is how we came up with

3229
02:29:58,479 --> 02:29:59,760
this idea of differentially private

3230
02:29:59,760 --> 02:30:02,000
volume hiding encrypted multi-maps

3231
02:30:02,000 --> 02:30:05,200
and the inspiration was from actually uh

3232
02:30:05,200 --> 02:30:07,920
so kkno if you saw in the last talk

3233
02:30:07,920 --> 02:30:09,920
they actually they're the paper before

3234
02:30:09,920 --> 02:30:11,439
this was giving attacks on how to do

3235
02:30:11,439 --> 02:30:12,880
encrypted ranges

3236
02:30:12,880 --> 02:30:14,560
and then vice versa they showed some

3237
02:30:14,560 --> 02:30:16,080
sort of ideas of how to actually prevent

3238
02:30:16,080 --> 02:30:17,600
them via differential privacy at least

3239
02:30:17,600 --> 02:30:19,600
their original attacks

3240
02:30:19,600 --> 02:30:21,359
and we're going to use sort of some of

3241
02:30:21,359 --> 02:30:25,359
the ideas here in for volume hiding

3242
02:30:25,600 --> 02:30:27,359
okay so what is differential privacy for

3243
02:30:27,359 --> 02:30:29,680
those who don't know what it essentially

3244
02:30:29,680 --> 02:30:31,600
means is if

3245
02:30:31,600 --> 02:30:33,680
you know if you have two keys and let's

3246
02:30:33,680 --> 02:30:35,840
suppose their volumes are neighboring

3247
02:30:35,840 --> 02:30:37,120
and here when i say neighboring i mean

3248
02:30:37,120 --> 02:30:39,840
the the size of their of their tuples

3249
02:30:39,840 --> 02:30:41,520
is one

3250
02:30:41,520 --> 02:30:43,520
right or at most one

3251
02:30:43,520 --> 02:30:45,600
then what you can do is will try to

3252
02:30:45,600 --> 02:30:48,160
define privacy by this notion which i

3253
02:30:48,160 --> 02:30:49,760
think most people should have seen here

3254
02:30:49,760 --> 02:30:51,840
but if not it looks a bit weird and

3255
02:30:51,840 --> 02:30:53,920
arcane at first but the reason it's

3256
02:30:53,920 --> 02:30:55,040
defined in this way where it's a

3257
02:30:55,040 --> 02:30:56,960
multiplication of e to the epsilon plus

3258
02:30:56,960 --> 02:30:59,120
a delta is simply to be enabled

3259
02:30:59,120 --> 02:31:01,920
composition so the above statement only

3260
02:31:01,920 --> 02:31:04,160
seems to make privacy claims for values

3261
02:31:04,160 --> 02:31:06,000
that differ with one location

3262
02:31:06,000 --> 02:31:07,600
if you use the specific notion you can

3263
02:31:07,600 --> 02:31:08,960
get something called composition which

3264
02:31:08,960 --> 02:31:11,359
guarantees you even guarantees when the

3265
02:31:11,359 --> 02:31:12,800
bat when the value tuples are different

3266
02:31:12,800 --> 02:31:15,040
but by size d and in particular this is

3267
02:31:15,040 --> 02:31:17,120
the okay so you can just make sure that

3268
02:31:17,120 --> 02:31:18,800
sort of you know the d is the epsilon

3269
02:31:18,800 --> 02:31:20,000
multiplied by d and the delta's

3270
02:31:20,000 --> 02:31:21,439
multiplied by d

3271
02:31:21,439 --> 02:31:23,520
i will caveat that this is not the best

3272
02:31:23,520 --> 02:31:25,120
composition theorem this is just an

3273
02:31:25,120 --> 02:31:26,800
example of why we choose to do this and

3274
02:31:26,800 --> 02:31:28,000
if you're going to do composition please

3275
02:31:28,000 --> 02:31:30,960
do something better than this actually

3276
02:31:30,960 --> 02:31:32,240
but regardless this could make sense

3277
02:31:32,240 --> 02:31:33,680
right so intuitively what we're trying

3278
02:31:33,680 --> 02:31:36,720
to say is if the databases look similar

3279
02:31:36,720 --> 02:31:38,000
let's say you have the signature of

3280
02:31:38,000 --> 02:31:39,920
their volumes and the volumes don't

3281
02:31:39,920 --> 02:31:42,080
differ too much potentially you can use

3282
02:31:42,080 --> 02:31:43,120
something like this where you can still

3283
02:31:43,120 --> 02:31:46,080
make guarantees on sort of

3284
02:31:46,080 --> 02:31:47,520
you know if the two databases are close

3285
02:31:47,520 --> 02:31:48,880
you can still dist you can make them

3286
02:31:48,880 --> 02:31:50,319
indistinguishable almost according to

3287
02:31:50,319 --> 02:31:52,880
this notion

3288
02:31:53,359 --> 02:31:55,520
okay so how do we do this uh let's go

3289
02:31:55,520 --> 02:31:57,200
back to our favorite cukuhashi scheme

3290
02:31:57,200 --> 02:31:59,840
remember that everything looks like this

3291
02:31:59,840 --> 02:32:02,080
and if you quarried for a purple item in

3292
02:32:02,080 --> 02:32:03,040
the past

3293
02:32:03,040 --> 02:32:05,040
you would send essentially you would try

3294
02:32:05,040 --> 02:32:08,800
to retrieve all these two element trees

3295
02:32:08,800 --> 02:32:11,520
so the idea is actually quite simple

3296
02:32:11,520 --> 02:32:12,720
rather than going all the way to the

3297
02:32:12,720 --> 02:32:15,680
maximum volume why not simply try to do

3298
02:32:15,680 --> 02:32:17,680
something based on the actual volume of

3299
02:32:17,680 --> 02:32:19,280
the purple key so here when i say lf

3300
02:32:19,280 --> 02:32:21,359
purple i mean what is the actual volume

3301
02:32:21,359 --> 02:32:23,359
of purple

3302
02:32:23,359 --> 02:32:24,560
and this is sort of a basic idea of

3303
02:32:24,560 --> 02:32:25,520
different privacy then you're going to

3304
02:32:25,520 --> 02:32:27,040
try to add some z which we call the

3305
02:32:27,040 --> 02:32:29,600
differential private noise in a sense to

3306
02:32:29,600 --> 02:32:31,600
make sure that all of the sort of keys

3307
02:32:31,600 --> 02:32:33,280
that have values close to the one that's

3308
02:32:33,280 --> 02:32:34,880
purple are all somewhat

3309
02:32:34,880 --> 02:32:37,200
indistinguishable

3310
02:32:37,200 --> 02:32:38,800
so this is exactly what we do actually

3311
02:32:38,800 --> 02:32:40,640
and this is the what kkno had done as

3312
02:32:40,640 --> 02:32:42,080
well

3313
02:32:42,080 --> 02:32:43,520
um

3314
02:32:43,520 --> 02:32:45,439
so there's a small caveat here actually

3315
02:32:45,439 --> 02:32:47,120
that you need to know what the volume of

3316
02:32:47,120 --> 02:32:48,399
purple is now

3317
02:32:48,399 --> 02:32:50,399
we didn't have that in the past

3318
02:32:50,399 --> 02:32:52,479
right before we had essentially all of

3319
02:32:52,479 --> 02:32:54,080
these sort of entries that were being

3320
02:32:54,080 --> 02:32:55,520
downloaded were based on just the key

3321
02:32:55,520 --> 02:32:56,960
that i had arrived

3322
02:32:56,960 --> 02:32:58,800
now i also need to know the actual

3323
02:32:58,800 --> 02:33:01,040
volume of purple

3324
02:33:01,040 --> 02:33:02,640
well for volume for volume hiding

3325
02:33:02,640 --> 02:33:04,160
luckily all volumes are essentially the

3326
02:33:04,160 --> 02:33:06,560
same size so instead of so if i wanted

3327
02:33:06,560 --> 02:33:08,720
to sort of retrieve the counts for any

3328
02:33:08,720 --> 02:33:11,200
or the volume for any sort of key

3329
02:33:11,200 --> 02:33:13,439
i can use a multi-map right i don't need

3330
02:33:13,439 --> 02:33:15,359
to use an i i'm not not a multi-map i

3331
02:33:15,359 --> 02:33:17,120
can just use a map where all the values

3332
02:33:17,120 --> 02:33:18,479
are the same size because the counts are

3333
02:33:18,479 --> 02:33:20,960
the same size so essentially if i want

3334
02:33:20,960 --> 02:33:22,960
to query for purple first i'll do one

3335
02:33:22,960 --> 02:33:24,720
round originally with the server to get

3336
02:33:24,720 --> 02:33:26,319
this l purple plus z which is

3337
02:33:26,319 --> 02:33:28,240
essentially an obfuscated or slightly

3338
02:33:28,240 --> 02:33:30,720
noisy volume of the original

3339
02:33:30,720 --> 02:33:33,280
of the original volume of purple

3340
02:33:33,280 --> 02:33:34,800
and then sort of in the first round i do

3341
02:33:34,800 --> 02:33:36,240
this in the second round i'll do exactly

3342
02:33:36,240 --> 02:33:38,319
what i said before which was

3343
02:33:38,319 --> 02:33:39,200
you know

3344
02:33:39,200 --> 02:33:41,120
perform the cuckoo hashing as is but

3345
02:33:41,120 --> 02:33:42,720
essentially just replace rather than

3346
02:33:42,720 --> 02:33:44,560
going all the way to l go to l at purple

3347
02:33:44,560 --> 02:33:46,840
plus this z

3348
02:33:46,840 --> 02:33:50,000
notion okay um

3349
02:33:50,000 --> 02:33:51,920
so let's say we did all this

3350
02:33:51,920 --> 02:33:53,920
right so yeah here i'm using a trivial

3351
02:33:53,920 --> 02:33:56,720
multi uh trivial encrypted map not even

3352
02:33:56,720 --> 02:33:58,319
a multi-map

3353
02:33:58,319 --> 02:34:00,399
and uh this is because all counts are

3354
02:34:00,399 --> 02:34:02,240
sent all volumes are essentially log log

3355
02:34:02,240 --> 02:34:04,720
n bits

3356
02:34:05,439 --> 02:34:06,880
okay so i'm not going to go through the

3357
02:34:06,880 --> 02:34:08,080
analysis because it's pretty standard

3358
02:34:08,080 --> 02:34:10,000
but how do you choose the z there are

3359
02:34:10,000 --> 02:34:11,280
several ways to do it you could choose

3360
02:34:11,280 --> 02:34:12,880
it from the laplacian or the gaussian

3361
02:34:12,880 --> 02:34:14,399
distribution it's well known how to make

3362
02:34:14,399 --> 02:34:16,720
this differentially private yeah there's

3363
02:34:16,720 --> 02:34:18,479
a slight caveat i need to make sure that

3364
02:34:18,479 --> 02:34:21,600
this z is non-negative because if it's

3365
02:34:21,600 --> 02:34:23,280
negative i get lossy results right so i

3366
02:34:23,280 --> 02:34:24,960
need to make sure that it's at least not

3367
02:34:24,960 --> 02:34:27,439
at least uh greater than equal to zero

3368
02:34:27,439 --> 02:34:28,640
and you can do this by essentially

3369
02:34:28,640 --> 02:34:30,000
taking the laplacian and gaussian and

3370
02:34:30,000 --> 02:34:32,240
shifting it over by some amounts to make

3371
02:34:32,240 --> 02:34:34,080
sure that it doesn't end up going below

3372
02:34:34,080 --> 02:34:36,080
zero except with negligible probability

3373
02:34:36,080 --> 02:34:37,920
and by standard analysis you can quickly

3374
02:34:37,920 --> 02:34:39,760
show that by choosing the shift to be

3375
02:34:39,760 --> 02:34:41,120
about approximately log n this

3376
02:34:41,120 --> 02:34:44,640
guarantees it for you

3377
02:34:44,640 --> 02:34:45,680
all right

3378
02:34:45,680 --> 02:34:48,640
um okay so sort of in the end

3379
02:34:48,640 --> 02:34:50,800
this is the final result sort of

3380
02:34:50,800 --> 02:34:52,479
uh some of these were the results before

3381
02:34:52,479 --> 02:34:54,240
from uh i guess naive padding was not a

3382
02:34:54,240 --> 02:34:56,080
result we knew this from a long time ago

3383
02:34:56,080 --> 02:34:57,600
there were several results from tariq

3384
02:34:57,600 --> 02:34:59,760
and sunny that showed various things i

3385
02:34:59,760 --> 02:35:02,000
think the one i showed you was the

3386
02:35:02,000 --> 02:35:05,120
pseudorandom transform or actually no

3387
02:35:05,120 --> 02:35:07,439
it's a it's the dense subgraph transform

3388
02:35:07,439 --> 02:35:08,960
and then our results essentially improve

3389
02:35:08,960 --> 02:35:11,200
on them in various aspects one is you

3390
02:35:11,200 --> 02:35:13,120
know the original dpi fm which is the

3391
02:35:13,120 --> 02:35:14,399
one i showed you earlier based on cuckoo

3392
02:35:14,399 --> 02:35:16,560
hashing that essentially gets rid of the

3393
02:35:16,560 --> 02:35:18,319
login and the query complexity and in

3394
02:35:18,319 --> 02:35:19,840
fact we can even put well known

3395
02:35:19,840 --> 02:35:22,000
constants in front of everything and

3396
02:35:22,000 --> 02:35:23,120
then the other ones it's differently

3397
02:35:23,120 --> 02:35:24,960
private version which essentially is the

3398
02:35:24,960 --> 02:35:27,200
same thing except that now you can make

3399
02:35:27,200 --> 02:35:29,760
the query complexity to be sort of

3400
02:35:29,760 --> 02:35:31,760
uh on the order of the actual size of

3401
02:35:31,760 --> 02:35:33,680
the key as opposed to this

3402
02:35:33,680 --> 02:35:34,720
i guess one thing i want to note about

3403
02:35:34,720 --> 02:35:36,080
this differentially private version is

3404
02:35:36,080 --> 02:35:38,080
it's really important that you can only

3405
02:35:38,080 --> 02:35:39,439
apply this on databases that look

3406
02:35:39,439 --> 02:35:41,439
similar i think there were attacks by i

3407
02:35:41,439 --> 02:35:43,600
think kershbomb that showed that if the

3408
02:35:43,600 --> 02:35:45,040
databases are far apart obviously

3409
02:35:45,040 --> 02:35:48,399
differential privacy will not work

3410
02:35:49,359 --> 02:35:50,479
all right

3411
02:35:50,479 --> 02:35:52,720
so here's a comparison result of what

3412
02:35:52,720 --> 02:35:55,280
you see for the sort of for

3413
02:35:55,280 --> 02:35:56,880
uh i guess the results return mainly

3414
02:35:56,880 --> 02:35:58,479
comparing differential privacy versus

3415
02:35:58,479 --> 02:36:01,120
the the the fully private version and

3416
02:36:01,120 --> 02:36:02,960
sort of as you expect right for the

3417
02:36:02,960 --> 02:36:05,040
different for the red line essentially

3418
02:36:05,040 --> 02:36:07,120
is the fully essentially the fully

3419
02:36:07,120 --> 02:36:08,399
private uh

3420
02:36:08,399 --> 02:36:10,800
volume hiding it's the response size is

3421
02:36:10,800 --> 02:36:13,040
always constant whereas for the

3422
02:36:13,040 --> 02:36:15,120
differential private version essentially

3423
02:36:15,120 --> 02:36:17,359
the nut you know the the bottom axis

3424
02:36:17,359 --> 02:36:18,560
essentially is telling you what's the

3425
02:36:18,560 --> 02:36:20,399
volume of the query key and you can see

3426
02:36:20,399 --> 02:36:22,080
that the volume actually is sort of

3427
02:36:22,080 --> 02:36:24,399
correlated or essentially linear with

3428
02:36:24,399 --> 02:36:27,040
what you would expect but a stat

3429
02:36:27,040 --> 02:36:29,520
annoying part is at the very end it ends

3430
02:36:29,520 --> 02:36:30,880
up being higher because if we're adding

3431
02:36:30,880 --> 02:36:32,000
this sort of differentially private

3432
02:36:32,000 --> 02:36:33,680
noise which is unexpected and maybe it's

3433
02:36:33,680 --> 02:36:34,640
interesting if you could do something

3434
02:36:34,640 --> 02:36:37,640
there

3435
02:36:38,240 --> 02:36:40,800
um okay so we have experiments showing

3436
02:36:40,800 --> 02:36:42,560
that most of this is really really fast

3437
02:36:42,560 --> 02:36:43,840
um

3438
02:36:43,840 --> 02:36:45,680
the main benefit that we that you can

3439
02:36:45,680 --> 02:36:47,040
sort of see is that if you look at the

3440
02:36:47,040 --> 02:36:49,040
download for the query communication

3441
02:36:49,040 --> 02:36:50,720
because of uh

3442
02:36:50,720 --> 02:36:52,880
the previous then sub graph transform

3443
02:36:52,880 --> 02:36:54,800
how to do download these bud bins of

3444
02:36:54,800 --> 02:36:57,439
size log n and the login the constants

3445
02:36:57,439 --> 02:36:59,280
in front could actually be quite large

3446
02:36:59,280 --> 02:37:01,040
you know you could get orders of like

3447
02:37:01,040 --> 02:37:02,840
kilobytes of results

3448
02:37:02,840 --> 02:37:05,840
returned uh per like per value whereas

3449
02:37:05,840 --> 02:37:07,280
for us we only have

3450
02:37:07,280 --> 02:37:08,640
64 bytes essentially because you're

3451
02:37:08,640 --> 02:37:12,080
returning two per value

3452
02:37:13,520 --> 02:37:14,800
all right so

3453
02:37:14,800 --> 02:37:16,240
this paper is a little old i think it

3454
02:37:16,240 --> 02:37:19,439
was like 2019 2020 when we published it

3455
02:37:19,439 --> 02:37:20,800
and there's been a bunch of follow-up

3456
02:37:20,800 --> 02:37:22,399
works on volume hiding that i highly

3457
02:37:22,399 --> 02:37:25,040
encourage others to go take a look at

3458
02:37:25,040 --> 02:37:27,359
so there's one by uh wang and chao that

3459
02:37:27,359 --> 02:37:28,479
essentially

3460
02:37:28,479 --> 02:37:30,560
improved on our scheme in some sense

3461
02:37:30,560 --> 02:37:31,359
where

3462
02:37:31,359 --> 02:37:32,880
you know we're using cuckoo hashing you

3463
02:37:32,880 --> 02:37:34,560
could instead use another type of

3464
02:37:34,560 --> 02:37:36,479
hashing scheme that's slightly better in

3465
02:37:36,479 --> 02:37:38,000
particular they save on the storage

3466
02:37:38,000 --> 02:37:40,000
space where they

3467
02:37:40,000 --> 02:37:41,439
are able to instead of getting two i

3468
02:37:41,439 --> 02:37:43,120
think they get somewhat like 1.5 or even

3469
02:37:43,120 --> 02:37:44,960
closer to one

3470
02:37:44,960 --> 02:37:46,720
but in exchange it's slightly more

3471
02:37:46,720 --> 02:37:49,040
complicated because here in our query

3472
02:37:49,040 --> 02:37:50,319
all we're doing is simply returning

3473
02:37:50,319 --> 02:37:52,800
responses is simply accessing bins where

3474
02:37:52,800 --> 02:37:53,680
they need to do something called a

3475
02:37:53,680 --> 02:37:56,160
predecessor search which in practice you

3476
02:37:56,160 --> 02:37:58,000
can actually drive down to be very small

3477
02:37:58,000 --> 02:37:59,439
but i don't know in theory you can drive

3478
02:37:59,439 --> 02:38:00,880
down very small asymptotically but in

3479
02:38:00,880 --> 02:38:02,800
practice i think it's about long time

3480
02:38:02,800 --> 02:38:04,960
these are the best constructions so

3481
02:38:04,960 --> 02:38:07,040
they're able to sort of trade off uh the

3482
02:38:07,040 --> 02:38:08,240
query time as opposed to query

3483
02:38:08,240 --> 02:38:10,240
communication

3484
02:38:10,240 --> 02:38:10,960
for

3485
02:38:10,960 --> 02:38:12,399
for down for like pushing down the

3486
02:38:12,399 --> 02:38:14,240
storage space

3487
02:38:14,240 --> 02:38:15,280
um

3488
02:38:15,280 --> 02:38:16,720
so i like all of these results that i

3489
02:38:16,720 --> 02:38:18,479
sort of claimed above were

3490
02:38:18,479 --> 02:38:20,479
basically static i think sunny and shrek

3491
02:38:20,479 --> 02:38:22,000
had some results for volume hiding that

3492
02:38:22,000 --> 02:38:22,680
were

3493
02:38:22,680 --> 02:38:24,720
semi-dynamic i believe which were which

3494
02:38:24,720 --> 02:38:26,880
had some dynamic operations and there's

3495
02:38:26,880 --> 02:38:28,399
been a couple works that followed up

3496
02:38:28,399 --> 02:38:30,000
that sort of show that you can actually

3497
02:38:30,000 --> 02:38:31,439
sort of do this in the volume hiding for

3498
02:38:31,439 --> 02:38:33,439
like dynamic settings

3499
02:38:33,439 --> 02:38:34,399
of course they become far more

3500
02:38:34,399 --> 02:38:36,240
complicated um

3501
02:38:36,240 --> 02:38:37,840
i think there's two works one is from

3502
02:38:37,840 --> 02:38:39,920
our group that we will appear at pets i

3503
02:38:39,920 --> 02:38:42,479
think this year or next year there we

3504
02:38:42,479 --> 02:38:44,479
sort of have to replace the cuckoo

3505
02:38:44,479 --> 02:38:45,680
hashing with a different hashing scheme

3506
02:38:45,680 --> 02:38:47,280
that's sort of uh

3507
02:38:47,280 --> 02:38:48,720
enabled that works for the dynamic

3508
02:38:48,720 --> 02:38:50,399
setting and there we use something like

3509
02:38:50,399 --> 02:38:52,000
it was a result actually

3510
02:38:52,000 --> 02:38:54,080
of sarvar and pino and i's a while ago

3511
02:38:54,080 --> 02:38:55,520
where we showed that you can actually

3512
02:38:55,520 --> 02:38:56,800
build a different hashing scheme that's

3513
02:38:56,800 --> 02:38:58,319
actually that sort of works for this in

3514
02:38:58,319 --> 02:38:59,359
a different setting in the dynamic

3515
02:38:59,359 --> 02:39:00,800
setting

3516
02:39:00,800 --> 02:39:02,000
the other work is actually a little more

3517
02:39:02,000 --> 02:39:03,120
interesting even though they're both

3518
02:39:03,120 --> 02:39:04,800
volume hiding they actually end up

3519
02:39:04,800 --> 02:39:06,640
studying very different settings the

3520
02:39:06,640 --> 02:39:08,319
other one was actually

3521
02:39:08,319 --> 02:39:10,319
aiming to also protect the maximum

3522
02:39:10,319 --> 02:39:11,520
volume

3523
02:39:11,520 --> 02:39:13,280
so there they wanted to say i don't even

3524
02:39:13,280 --> 02:39:15,359
want to tell you what l is you know in

3525
02:39:15,359 --> 02:39:16,960
sort of our constructions we're okay

3526
02:39:16,960 --> 02:39:18,800
with leaking the maximum volume

3527
02:39:18,800 --> 02:39:19,920
and there they show that you can

3528
02:39:19,920 --> 02:39:22,960
actually even sort of hide l but of

3529
02:39:22,960 --> 02:39:24,720
course the cost is very large in fact it

3530
02:39:24,720 --> 02:39:26,240
turns out to hide l you need almost

3531
02:39:26,240 --> 02:39:30,479
linear sort of uh overhead always

3532
02:39:30,800 --> 02:39:32,479
all right uh so i think that's the end

3533
02:39:32,479 --> 02:39:33,680
of my

3534
02:39:33,680 --> 02:39:37,800
thanks and happy to take questions

3535
02:39:40,479 --> 02:39:43,039
any questions

3536
02:39:46,319 --> 02:39:47,680
hey thanks kevin that was really cool

3537
02:39:47,680 --> 02:39:49,840
talk um so i'm curious uh your

3538
02:39:49,840 --> 02:39:52,560
differentially private multi-map um the

3539
02:39:52,560 --> 02:39:54,000
differentially

3540
02:39:54,000 --> 02:39:56,720
private volume hiding one um is this a

3541
02:39:56,720 --> 02:39:58,880
two-round protocol where you first fetch

3542
02:39:58,880 --> 02:40:01,600
the volume and then do the search yeah

3543
02:40:01,600 --> 02:40:03,600
it's two rounds um

3544
02:40:03,600 --> 02:40:07,359
i don't so can't you just do one round

3545
02:40:07,359 --> 02:40:08,399
where you

3546
02:40:08,399 --> 02:40:10,399
sort of send because it seems like what

3547
02:40:10,399 --> 02:40:11,760
you need is sort of to send the

3548
02:40:11,760 --> 02:40:14,160
decryption key that you that you use

3549
02:40:14,160 --> 02:40:15,439
because you're going to end up leaking

3550
02:40:15,439 --> 02:40:17,760
the volume anyway yeah like why can't

3551
02:40:17,760 --> 02:40:19,840
you just uh me in response revealing

3552
02:40:19,840 --> 02:40:20,720
right

3553
02:40:20,720 --> 02:40:22,479
the issue maybe is how you derive the

3554
02:40:22,479 --> 02:40:24,479
search tokens but i it this doesn't seem

3555
02:40:24,479 --> 02:40:26,000
inherent to me so could you use a

3556
02:40:26,000 --> 02:40:28,960
different um like token derivation

3557
02:40:28,960 --> 02:40:30,800
method and then just have a one-round

3558
02:40:30,800 --> 02:40:32,160
protocol where you decrypt and then the

3559
02:40:32,160 --> 02:40:35,040
server kind of um derives the tokens by

3560
02:40:35,040 --> 02:40:36,479
itself

3561
02:40:36,479 --> 02:40:38,160
yeah actually i'm not sure maybe we

3562
02:40:38,160 --> 02:40:39,120
actually did that i don't remember but

3563
02:40:39,120 --> 02:40:40,560
yeah that could work right essentially

3564
02:40:40,560 --> 02:40:43,200
just use there's like a lot of like

3565
02:40:43,200 --> 02:40:44,720
multi-maps or maps that are essentially

3566
02:40:44,720 --> 02:40:46,399
response revealing right sort of yeah

3567
02:40:46,399 --> 02:40:48,560
yeah you sort of could send a prf and

3568
02:40:48,560 --> 02:40:51,040
then you derived the

3569
02:40:51,040 --> 02:40:52,880
decryption key using the pr app yeah

3570
02:40:52,880 --> 02:40:54,640
yeah that could also work as well yeah

3571
02:40:54,640 --> 02:40:55,920
so then you can you could probably get

3572
02:40:55,920 --> 02:40:57,200
into one round

3573
02:40:57,200 --> 02:40:59,359
and actually don't quote me i we may

3574
02:40:59,359 --> 02:41:03,120
have also done that that's gonna forget

3575
02:41:05,200 --> 02:41:07,840
any other questions

3576
02:41:07,840 --> 02:41:09,680
actually i have a question so for the

3577
02:41:09,680 --> 02:41:11,120
differentially private

3578
02:41:11,120 --> 02:41:12,800
volume hiding scheme so you said that it

3579
02:41:12,800 --> 02:41:14,000
um

3580
02:41:14,000 --> 02:41:16,399
the keno paper showed that or at least

3581
02:41:16,399 --> 02:41:17,760
argued that it would protect against

3582
02:41:17,760 --> 02:41:20,560
their specific attack yeah uh does it

3583
02:41:20,560 --> 02:41:22,000
protect against the

3584
02:41:22,000 --> 02:41:22,960
the

3585
02:41:22,960 --> 02:41:25,200
other attacks that came afterwards

3586
02:41:25,200 --> 02:41:28,240
we never analyzed this um

3587
02:41:28,240 --> 02:41:30,479
i guess intuitively like most of these

3588
02:41:30,479 --> 02:41:32,399
hacks it depends on what the input is if

3589
02:41:32,399 --> 02:41:34,080
the inputs satisfy like exactly what

3590
02:41:34,080 --> 02:41:35,359
differential privacy is aiming for

3591
02:41:35,359 --> 02:41:38,080
obviously i don't think so

3592
02:41:38,080 --> 02:41:40,399
now like now the question is how far can

3593
02:41:40,399 --> 02:41:42,479
you go right like how different the

3594
02:41:42,479 --> 02:41:43,760
databases have to be before these

3595
02:41:43,760 --> 02:41:45,279
attacks work and i think that's a very

3596
02:41:45,279 --> 02:41:46,960
interesting question which hasn't been

3597
02:41:46,960 --> 02:41:50,000
explored yet to my knowledge

3598
02:41:50,000 --> 02:41:54,479
um all right so let's think kevin again

3599
02:41:57,359 --> 02:42:00,399
so i guess now we have lunch um one

3600
02:42:00,399 --> 02:42:01,920
announcement is that

3601
02:42:01,920 --> 02:42:03,760
we had a talk the first talk of the

3602
02:42:03,760 --> 02:42:05,359
first session we have to cancel uh the

3603
02:42:05,359 --> 02:42:06,880
speaker couldn't make it

3604
02:42:06,880 --> 02:42:08,640
uh at the last second so lunch is gonna

3605
02:42:08,640 --> 02:42:11,200
be two hours instead of uh an hour and a

3606
02:42:11,200 --> 02:42:14,080
half so i think we'll be back at

3607
02:42:14,080 --> 02:42:16,880
what is your tuesday

3608
02:42:17,120 --> 02:42:19,120
so we'll be back at 1 30

3609
02:42:19,120 --> 02:42:20,880
and we'll update

3610
02:42:20,880 --> 02:42:22,319
the website

3611
02:42:22,319 --> 02:42:25,720
all right thank you

3612
02:42:43,120 --> 02:42:46,120
it's

3613
03:50:32,880 --> 03:50:35,839
check check

3614
03:51:49,760 --> 03:51:53,000
i'm the 135

3615
04:20:19,840 --> 04:20:20,560
so

3616
04:20:20,560 --> 04:20:21,520
i'm

3617
04:20:21,520 --> 04:20:24,000
very happy to introduce uh steve lew

3618
04:20:24,000 --> 04:20:25,680
from

3619
04:20:25,680 --> 04:20:27,840
software technologies

3620
04:20:27,840 --> 04:20:29,840
is going to tell us

3621
04:20:29,840 --> 04:20:30,960
more about

3622
04:20:30,960 --> 04:20:32,720
distributed social symmetric encryption

3623
04:20:32,720 --> 04:20:35,599
thank you thank you steve

3624
04:20:37,439 --> 04:20:38,560
yeah thanks

3625
04:20:38,560 --> 04:20:40,880
thanks for inviting me so hi everyone

3626
04:20:40,880 --> 04:20:43,520
i'm steve liu and i'll talk a bit about

3627
04:20:43,520 --> 04:20:45,520
uh distributed searchable symmetric

3628
04:20:45,520 --> 04:20:47,680
encryption

3629
04:20:47,680 --> 04:20:50,880
all right so first uh what does

3630
04:20:50,880 --> 04:20:53,278
um

3631
04:20:53,920 --> 04:20:55,840
uh what exactly do we mean by

3632
04:20:55,840 --> 04:20:58,560
distributed here right uh

3633
04:20:58,560 --> 04:21:00,319
so i'm not talking about sort of edge

3634
04:21:00,319 --> 04:21:02,479
computing or multiple databases i'm

3635
04:21:02,479 --> 04:21:04,000
really talking about distributed in the

3636
04:21:04,000 --> 04:21:07,600
sense of uh how can more servers

3637
04:21:07,600 --> 04:21:09,279
help with

3638
04:21:09,279 --> 04:21:11,600
sse

3639
04:21:11,600 --> 04:21:13,920
i'll go more into this in just a bit

3640
04:21:13,920 --> 04:21:16,319
uh so sort of the outline of my talk uh

3641
04:21:16,319 --> 04:21:18,640
i'll just give a quick introduction uh

3642
04:21:18,640 --> 04:21:20,319
give some sort of background into how

3643
04:21:20,319 --> 04:21:22,479
this problem came about uh

3644
04:21:22,479 --> 04:21:24,560
talk a bit about uh some of this this

3645
04:21:24,560 --> 04:21:27,520
work that was uh published in ctrsa

3646
04:21:27,520 --> 04:21:29,279
uh some interesting follow-up work after

3647
04:21:29,279 --> 04:21:33,120
that uh and then wrap up

3648
04:21:33,600 --> 04:21:35,920
okay so just for a quick introduction

3649
04:21:35,920 --> 04:21:37,120
right uh

3650
04:21:37,120 --> 04:21:38,080
the

3651
04:21:38,080 --> 04:21:39,120
you know the standard setting of

3652
04:21:39,120 --> 04:21:42,080
surgical symmetric encryption you have a

3653
04:21:42,080 --> 04:21:43,600
database

3654
04:21:43,600 --> 04:21:45,520
owned by someone and they want to maybe

3655
04:21:45,520 --> 04:21:47,680
outsource it into a cloud maybe that's

3656
04:21:47,680 --> 04:21:49,600
not trusted

3657
04:21:49,600 --> 04:21:50,880
and the point is that you know you

3658
04:21:50,880 --> 04:21:52,720
encrypt it in a certain way put it up on

3659
04:21:52,720 --> 04:21:53,760
the cloud

3660
04:21:53,760 --> 04:21:55,520
uh and then later on you might want to

3661
04:21:55,520 --> 04:21:58,560
ask you know questions against

3662
04:21:58,880 --> 04:22:00,000
well

3663
04:22:00,000 --> 04:22:01,439
one thing you might want to ask is well

3664
04:22:01,439 --> 04:22:03,520
what if the query or the person asking

3665
04:22:03,520 --> 04:22:05,199
the question against the database is not

3666
04:22:05,199 --> 04:22:07,199
the same as the the data owner

3667
04:22:07,199 --> 04:22:09,359
right uh in the world of like private

3668
04:22:09,359 --> 04:22:10,800
information retrieval you can think of

3669
04:22:10,800 --> 04:22:12,560
like uh spear right symmetric private

3670
04:22:12,560 --> 04:22:13,920
information retrieval versus standard

3671
04:22:13,920 --> 04:22:14,880
private information information

3672
04:22:14,880 --> 04:22:16,239
retrieval where you actually also want

3673
04:22:16,239 --> 04:22:18,720
to protect the privacy of the database

3674
04:22:18,720 --> 04:22:20,720
from the querier

3675
04:22:20,720 --> 04:22:22,560
okay so how did this problem actually

3676
04:22:22,560 --> 04:22:24,159
come about right so just just a bit of

3677
04:22:24,159 --> 04:22:27,120
context for for this extension right um

3678
04:22:27,120 --> 04:22:29,680
you know for us uh at our company uh

3679
04:22:29,680 --> 04:22:30,720
searching on it and computing on

3680
04:22:30,720 --> 04:22:32,640
encrypted data is very near and dear to

3681
04:22:32,640 --> 04:22:33,359
us

3682
04:22:33,359 --> 04:22:36,000
um you know this company was founded um

3683
04:22:36,000 --> 04:22:38,640
by uh ostrovsky and skith uh based on

3684
04:22:38,640 --> 04:22:42,000
their 2000 crypto 2005 work

3685
04:22:42,000 --> 04:22:42,960
um

3686
04:22:42,960 --> 04:22:43,840
and

3687
04:22:43,840 --> 04:22:46,479
you know uh our founder of rafaelski

3688
04:22:46,479 --> 04:22:48,479
also worked on this sort of uh seminal

3689
04:22:48,479 --> 04:22:51,199
uh work on search metric encryption um

3690
04:22:51,199 --> 04:22:53,760
by uh our hosts uh hamara rafi

3691
04:22:53,760 --> 04:22:56,239
gastrovsky huangaray and cabron

3692
04:22:56,239 --> 04:22:58,080
uh as well and

3693
04:22:58,080 --> 04:22:59,040
the

3694
04:22:59,040 --> 04:23:00,239
thing that actually sort of came up that

3695
04:23:00,239 --> 04:23:02,000
sort of uh brought this question about

3696
04:23:02,000 --> 04:23:02,960
was

3697
04:23:02,960 --> 04:23:05,520
uh you know we're funded uh by you know

3698
04:23:05,520 --> 04:23:08,159
various uh agencies that uh fund this

3699
04:23:08,159 --> 04:23:10,560
kind of research uh and irpa actually

3700
04:23:10,560 --> 04:23:12,159
you know started a series of programs

3701
04:23:12,159 --> 04:23:14,640
asking how can we protect right not just

3702
04:23:14,640 --> 04:23:17,279
the the query from the the you know sort

3703
04:23:17,279 --> 04:23:19,199
of the cloud host in the database but

3704
04:23:19,199 --> 04:23:20,319
also

3705
04:23:20,319 --> 04:23:21,920
how do you protect the data

3706
04:23:21,920 --> 04:23:24,239
from someone asking the query uh against

3707
04:23:24,239 --> 04:23:26,399
unauthorized access

3708
04:23:26,399 --> 04:23:28,399
right uh and so you know towards

3709
04:23:28,399 --> 04:23:31,199
answering this question um you know

3710
04:23:31,199 --> 04:23:33,920
we there is a sort of model that was um

3711
04:23:33,920 --> 04:23:35,920
that sort of was introduced and it works

3712
04:23:35,920 --> 04:23:36,960
something like this right so you have

3713
04:23:36,960 --> 04:23:38,880
this database uh it might look something

3714
04:23:38,880 --> 04:23:41,520
like this uh think of it as just a table

3715
04:23:41,520 --> 04:23:43,359
where you have a bunch of searchable

3716
04:23:43,359 --> 04:23:46,000
attributes and you also have some rich

3717
04:23:46,000 --> 04:23:47,840
data fields some payloads

3718
04:23:47,840 --> 04:23:48,800
um

3719
04:23:48,800 --> 04:23:49,760
and

3720
04:23:49,760 --> 04:23:51,040
what you want to do is you want to take

3721
04:23:51,040 --> 04:23:52,080
this

3722
04:23:52,080 --> 04:23:53,840
you know held by a server

3723
04:23:53,840 --> 04:23:55,359
and there's a client who wants to ask

3724
04:23:55,359 --> 04:23:56,640
questions against it

3725
04:23:56,640 --> 04:23:58,640
and you also have the help

3726
04:23:58,640 --> 04:24:00,640
of an untrusted cloud

3727
04:24:00,640 --> 04:24:02,399
what can you do in this case

3728
04:24:02,399 --> 04:24:04,239
right and the security guarantees that

3729
04:24:04,239 --> 04:24:05,600
we want is that we want to protect the

3730
04:24:05,600 --> 04:24:06,960
privacy of the server holding the

3731
04:24:06,960 --> 04:24:09,199
database both against the cloud and the

3732
04:24:09,199 --> 04:24:11,520
client we want to protect the privacy of

3733
04:24:11,520 --> 04:24:12,880
the client asking the queries so we

3734
04:24:12,880 --> 04:24:14,479
don't want anyone else to sort of learn

3735
04:24:14,479 --> 04:24:16,720
the nature of the queries

3736
04:24:16,720 --> 04:24:19,600
you also want to enforce uh policies

3737
04:24:19,600 --> 04:24:21,120
uh on the queries right you can't just

3738
04:24:21,120 --> 04:24:22,479
ask for anything you have to ask for

3739
04:24:22,479 --> 04:24:23,600
only things that you're allowed to ask

3740
04:24:23,600 --> 04:24:24,720
for

3741
04:24:24,720 --> 04:24:26,640
uh and it should also be you know

3742
04:24:26,640 --> 04:24:28,319
scalable up to you know this certain

3743
04:24:28,319 --> 04:24:30,000
size that um

3744
04:24:30,000 --> 04:24:33,680
that we all sort of thought was real

3745
04:24:33,680 --> 04:24:35,359
okay so

3746
04:24:35,359 --> 04:24:37,199
uh with this in mind let me just sort of

3747
04:24:37,199 --> 04:24:39,760
go into a bit of background here

3748
04:24:39,760 --> 04:24:41,199
right uh

3749
04:24:41,199 --> 04:24:43,680
there are you know sort of related uh

3750
04:24:43,680 --> 04:24:45,520
encrypted search primitives i'll just

3751
04:24:45,520 --> 04:24:47,600
sort of quickly uh you know go over them

3752
04:24:47,600 --> 04:24:49,040
uh there's private information retrieval

3753
04:24:49,040 --> 04:24:50,560
there's oblivious ram

3754
04:24:50,560 --> 04:24:52,239
and then there's sort of uh you know

3755
04:24:52,239 --> 04:24:54,000
this line of work of searchable spectrum

3756
04:24:54,000 --> 04:24:54,960
encryption

3757
04:24:54,960 --> 04:24:55,680
right

3758
04:24:55,680 --> 04:24:57,520
so for private information retrieval

3759
04:24:57,520 --> 04:24:59,760
there it's about i mean the the at the

3760
04:24:59,760 --> 04:25:01,680
most sort of basic level right it's

3761
04:25:01,680 --> 04:25:03,760
about fetching a private index i from an

3762
04:25:03,760 --> 04:25:04,880
array

3763
04:25:04,880 --> 04:25:07,359
uh and sort of the the property there is

3764
04:25:07,359 --> 04:25:08,720
that you're really not leaking anything

3765
04:25:08,720 --> 04:25:10,560
except the size

3766
04:25:10,560 --> 04:25:12,479
um again there's also oblivious ram

3767
04:25:12,479 --> 04:25:14,640
which uh enables you know ram programs

3768
04:25:14,640 --> 04:25:17,120
to be compiled into oblivious ones that

3769
04:25:17,120 --> 04:25:19,840
again you can sort of uh run and it will

3770
04:25:19,840 --> 04:25:21,199
hide access

3771
04:25:21,199 --> 04:25:23,439
access patterns

3772
04:25:23,439 --> 04:25:25,520
uh you know again you know the

3773
04:25:25,520 --> 04:25:26,960
communication is low

3774
04:25:26,960 --> 04:25:29,359
the work uh you know based on a couple

3775
04:25:29,359 --> 04:25:31,199
of very recent advances has shown uh

3776
04:25:31,199 --> 04:25:33,040
matching upper and lower bounds of log

3777
04:25:33,040 --> 04:25:36,080
overhead uh and you know this is also

3778
04:25:36,080 --> 04:25:37,120
sort of based on symmetric key

3779
04:25:37,120 --> 04:25:39,279
operations the leakage again is sort of

3780
04:25:39,279 --> 04:25:41,359
sizes only

3781
04:25:41,359 --> 04:25:43,040
okay but this is still sort of login

3782
04:25:43,040 --> 04:25:44,319
overhead right can we do better than

3783
04:25:44,319 --> 04:25:46,560
that right and so sort of the work

3784
04:25:46,560 --> 04:25:49,439
along these lines is what if we

3785
04:25:49,439 --> 04:25:51,359
allow a little bit of

3786
04:25:51,359 --> 04:25:53,439
metadata

3787
04:25:53,439 --> 04:25:55,120
leakage but

3788
04:25:55,120 --> 04:25:58,239
now the communication and computation

3789
04:25:58,239 --> 04:26:00,399
should be essentially constant

3790
04:26:00,399 --> 04:26:02,399
right um and

3791
04:26:02,399 --> 04:26:04,560
this is uh sort of what this line of

3792
04:26:04,560 --> 04:26:07,279
work to look at um and

3793
04:26:07,279 --> 04:26:08,880
we wanted to ask sort of a question

3794
04:26:08,880 --> 04:26:10,399
along you know this line of work right

3795
04:26:10,399 --> 04:26:12,640
so here i have uh private information

3796
04:26:12,640 --> 04:26:14,239
retrieval i have oblivious ram i have

3797
04:26:14,239 --> 04:26:16,640
sse um and

3798
04:26:16,640 --> 04:26:18,880
it's you know it's quite well known that

3799
04:26:18,880 --> 04:26:20,800
the multi-server model is widely used in

3800
04:26:20,800 --> 04:26:23,439
cryptography um in the setting of you

3801
04:26:23,439 --> 04:26:24,640
know private information retrieval in

3802
04:26:24,640 --> 04:26:26,720
fact tube here actually came before uh

3803
04:26:26,720 --> 04:26:28,000
the computational sort of one server

3804
04:26:28,000 --> 04:26:30,319
appear

3805
04:26:30,319 --> 04:26:31,520
in

3806
04:26:31,520 --> 04:26:33,279
uh you know in sort of more recent

3807
04:26:33,279 --> 04:26:34,800
instantiations you can also use sort of

3808
04:26:34,800 --> 04:26:36,720
distributed point functions uh to

3809
04:26:36,720 --> 04:26:38,800
instantiate this very efficiently

3810
04:26:38,800 --> 04:26:40,560
um

3811
04:26:40,560 --> 04:26:42,960
for oblivious ram there are also

3812
04:26:42,960 --> 04:26:44,720
primitives that work in the distributed

3813
04:26:44,720 --> 04:26:46,640
model where there's two servers

3814
04:26:46,640 --> 04:26:48,159
uh and so this is sort of a natural

3815
04:26:48,159 --> 04:26:49,920
question right we have peer and we have

3816
04:26:49,920 --> 04:26:51,359
sort of multi-server here we have o-ram

3817
04:26:51,359 --> 04:26:54,319
we have multi-server om we have sse

3818
04:26:54,319 --> 04:26:56,720
what can we do about circle encryption

3819
04:26:56,720 --> 04:26:59,279
in the multi-server model

3820
04:26:59,279 --> 04:27:01,600
right uh and this is sort of uh the

3821
04:27:01,600 --> 04:27:03,040
question that came up and and in fact

3822
04:27:03,040 --> 04:27:04,640
right this line of work uh funded by

3823
04:27:04,640 --> 04:27:08,000
sort of uh iarpa uh there is uh you know

3824
04:27:08,000 --> 04:27:09,359
other sort of teams working on this so

3825
04:27:09,359 --> 04:27:11,359
there is sort of the blind seer team uh

3826
04:27:11,359 --> 04:27:13,760
that had uh uh you know their their

3827
04:27:13,760 --> 04:27:15,359
wonderful solution there's the espada

3828
04:27:15,359 --> 04:27:17,600
team um you know sort of

3829
04:27:17,600 --> 04:27:19,920
like the ibm team uh they also had

3830
04:27:19,920 --> 04:27:21,760
another sort of wonderful solution

3831
04:27:21,760 --> 04:27:24,000
these solutions uh essentially operate

3832
04:27:24,000 --> 04:27:25,199
in the more traditional sort of

3833
04:27:25,199 --> 04:27:26,800
outsourced server model right where the

3834
04:27:26,800 --> 04:27:28,640
server will encrypt it in a special way

3835
04:27:28,640 --> 04:27:30,560
outsourcing the cloud uh and then sort

3836
04:27:30,560 --> 04:27:33,040
of go away right so there is even though

3837
04:27:33,040 --> 04:27:34,640
there's sort of the there's the server

3838
04:27:34,640 --> 04:27:36,399
and there's the cloud uh the server kind

3839
04:27:36,399 --> 04:27:38,159
of goes away after the initial setup

3840
04:27:38,159 --> 04:27:40,399
right um

3841
04:27:40,399 --> 04:27:41,760
we wanted to look at more in the

3842
04:27:41,760 --> 04:27:42,880
two-server model right what if the

3843
04:27:42,880 --> 04:27:44,399
server stayed online along with the

3844
04:27:44,399 --> 04:27:45,920
cloud or for example the server can

3845
04:27:45,920 --> 04:27:47,439
upload it into two different clouds

3846
04:27:47,439 --> 04:27:48,239
right

3847
04:27:48,239 --> 04:27:49,920
uh and so

3848
04:27:49,920 --> 04:27:52,479
the work that we looked at uh and was

3849
04:27:52,479 --> 04:27:55,279
sort of later published in ctrsa uh was

3850
04:27:55,279 --> 04:27:56,960
this sort of hybrid scheme between

3851
04:27:56,960 --> 04:27:59,279
circle encryption and peer and oram

3852
04:27:59,279 --> 04:28:01,600
where we actually build a range search

3853
04:28:01,600 --> 04:28:02,880
primitive

3854
04:28:02,880 --> 04:28:05,680
uh that hides access pattern metadata uh

3855
04:28:05,680 --> 04:28:06,720
in this

3856
04:28:06,720 --> 04:28:09,760
two server model

3857
04:28:09,760 --> 04:28:11,279
okay so

3858
04:28:11,279 --> 04:28:12,239
for

3859
04:28:12,239 --> 04:28:15,120
uh you know for this uh

3860
04:28:15,120 --> 04:28:17,120
next part of the talk i will give uh

3861
04:28:17,120 --> 04:28:18,880
just you know sort of a little bit of

3862
04:28:18,880 --> 04:28:21,040
flavor on uh what this construction look

3863
04:28:21,040 --> 04:28:22,880
like um

3864
04:28:22,880 --> 04:28:24,479
and then i'll actually jump into some

3865
04:28:24,479 --> 04:28:25,840
you know additional sort of improvements

3866
04:28:25,840 --> 04:28:27,760
and follow-on work

3867
04:28:27,760 --> 04:28:29,279
okay so

3868
04:28:29,279 --> 04:28:31,439
this uh scheme had a couple of sort of

3869
04:28:31,439 --> 04:28:32,800
features right it features the ability

3870
04:28:32,800 --> 04:28:34,560
to make queries

3871
04:28:34,560 --> 04:28:36,319
uh these queries just look like sql

3872
04:28:36,319 --> 04:28:37,920
queries um

3873
04:28:37,920 --> 04:28:39,359
and in fact we actually did some

3874
04:28:39,359 --> 04:28:40,319
additional work where you can actually

3875
04:28:40,319 --> 04:28:43,760
hook it up to a web service um but at

3876
04:28:43,760 --> 04:28:44,800
the end of the day right this is still

3877
04:28:44,800 --> 04:28:46,800
sort of uh you know even though it looks

3878
04:28:46,800 --> 04:28:48,880
like sql it really is

3879
04:28:48,880 --> 04:28:50,560
asking questions against a single sort

3880
04:28:50,560 --> 04:28:51,920
of denormalized table right you just

3881
04:28:51,920 --> 04:28:53,840
have you know columns and rows

3882
04:28:53,840 --> 04:28:55,920
um in fact it might actually work better

3883
04:28:55,920 --> 04:28:57,279
for nosql settings and we actually

3884
04:28:57,279 --> 04:28:59,120
looked into like hey can we use mongodb

3885
04:28:59,120 --> 04:29:00,479
for this and

3886
04:29:00,479 --> 04:29:03,199
you guys already did it so um you know

3887
04:29:03,199 --> 04:29:05,359
this is uh you know what what these

3888
04:29:05,359 --> 04:29:06,960
queries look like uh we also had some

3889
04:29:06,960 --> 04:29:08,880
sort of other features we wanted to uh

3890
04:29:08,880 --> 04:29:10,560
you know support for this right this

3891
04:29:10,560 --> 04:29:12,560
also looks at the updates right so what

3892
04:29:12,560 --> 04:29:14,720
can we do regarding updates

3893
04:29:14,720 --> 04:29:16,800
uh you can sort of insert things into

3894
04:29:16,800 --> 04:29:17,520
the

3895
04:29:17,520 --> 04:29:19,439
into the database you can delete things

3896
04:29:19,439 --> 04:29:21,279
uh there are also certain policies that

3897
04:29:21,279 --> 04:29:25,040
you can sort of uh set up and enforce

3898
04:29:25,040 --> 04:29:25,920
and

3899
04:29:25,920 --> 04:29:26,800
um

3900
04:29:26,800 --> 04:29:29,359
you know let me just sort of uh

3901
04:29:29,359 --> 04:29:31,120
move past this sort of eye chart here

3902
04:29:31,120 --> 04:29:33,040
but really get into the high level idea

3903
04:29:33,040 --> 04:29:35,760
of how we do this construction right so

3904
04:29:35,760 --> 04:29:37,040
these are the sort of the four things we

3905
04:29:37,040 --> 04:29:38,159
have we have set up we have query we

3906
04:29:38,159 --> 04:29:40,399
have updates we have policies

3907
04:29:40,399 --> 04:29:42,319
um the setup right we're essentially

3908
04:29:42,319 --> 04:29:44,159
building an encrypted index on this

3909
04:29:44,159 --> 04:29:46,159
table right and we build this encrypted

3910
04:29:46,159 --> 04:29:49,600
index uh you know using a b tree um and

3911
04:29:49,600 --> 04:29:51,359
this is what the search will be running

3912
04:29:51,359 --> 04:29:52,720
we're running on

3913
04:29:52,720 --> 04:29:54,960
uh for the query itself this is kind of

3914
04:29:54,960 --> 04:29:57,199
the the guts of the construction

3915
04:29:57,199 --> 04:29:59,040
we use a combination of private

3916
04:29:59,040 --> 04:30:01,439
information retrieval oblivious ram and

3917
04:30:01,439 --> 04:30:03,040
secure complication techniques to sort

3918
04:30:03,040 --> 04:30:05,439
of do this uh index reversal and i'll

3919
04:30:05,439 --> 04:30:07,279
show exactly what i mean by this in just

3920
04:30:07,279 --> 04:30:08,479
a bit

3921
04:30:08,479 --> 04:30:12,159
uh for updates we actually sort of um uh

3922
04:30:12,159 --> 04:30:14,319
looked at it from you know the uh

3923
04:30:14,319 --> 04:30:15,760
the the the

3924
04:30:15,760 --> 04:30:17,279
incremental sense right you have these

3925
04:30:17,279 --> 04:30:18,880
sort of batch updates

3926
04:30:18,880 --> 04:30:21,520
you create a media database that uh

3927
04:30:21,520 --> 04:30:23,199
eventually gets sort of rolled into the

3928
04:30:23,199 --> 04:30:24,159
bigger one

3929
04:30:24,159 --> 04:30:26,239
right and this is sort of in contrast to

3930
04:30:26,239 --> 04:30:28,399
more dynamic ssc schemes right uh

3931
04:30:28,399 --> 04:30:30,399
there's um you know a couple working in

3932
04:30:30,399 --> 04:30:31,680
the area where

3933
04:30:31,680 --> 04:30:34,479
the the ssc scheme directly supports uh

3934
04:30:34,479 --> 04:30:36,239
dynamic sort of inserts and deletes as

3935
04:30:36,239 --> 04:30:38,080
opposed to doing the sort of batch mode

3936
04:30:38,080 --> 04:30:40,560
of uh updates

3937
04:30:40,560 --> 04:30:42,319
okay and then for policy enforcement we

3938
04:30:42,319 --> 04:30:44,399
actually because we use this these

3939
04:30:44,399 --> 04:30:45,600
secure combination techniques to

3940
04:30:45,600 --> 04:30:47,920
traverse the tree uh during these

3941
04:30:47,920 --> 04:30:49,920
computations we also sort of interleave

3942
04:30:49,920 --> 04:30:52,640
the policy enforcement uh into that into

3943
04:30:52,640 --> 04:30:54,720
that portion as well

3944
04:30:54,720 --> 04:30:57,120
okay so let me just give you a a sort of

3945
04:30:57,120 --> 04:30:59,520
a a little taste of what this uh query

3946
04:30:59,520 --> 04:31:02,640
mechanism actually looks like uh and so

3947
04:31:02,640 --> 04:31:03,920
let me just sort of talk about what the

3948
04:31:03,920 --> 04:31:05,600
structure of the setup will be right so

3949
04:31:05,600 --> 04:31:07,040
the structure of the setup right like i

3950
04:31:07,040 --> 04:31:09,439
said uh it looks like a b tree but um

3951
04:31:09,439 --> 04:31:10,800
you know for the sake of exposition i'll

3952
04:31:10,800 --> 04:31:13,279
just look at a binary tree right so

3953
04:31:13,279 --> 04:31:14,560
let's just look at this you know battery

3954
04:31:14,560 --> 04:31:17,600
tree example for uh rangeboard

3955
04:31:17,600 --> 04:31:19,840
okay so here's a binary tree uh it's

3956
04:31:19,840 --> 04:31:23,120
encrypted right um and the point is that

3957
04:31:23,120 --> 04:31:25,279
we can sort of look at it layer by layer

3958
04:31:25,279 --> 04:31:26,399
right if we're going to do a range

3959
04:31:26,399 --> 04:31:28,000
search uh we want to look at the sort of

3960
04:31:28,000 --> 04:31:29,120
you know we want to find like the left

3961
04:31:29,120 --> 04:31:30,960
and right endpoints right so essentially

3962
04:31:30,960 --> 04:31:32,479
you know we want to just traverse this

3963
04:31:32,479 --> 04:31:35,840
tree uh one layer at a time in in an

3964
04:31:35,840 --> 04:31:38,080
oblivious manner right so that no party

3965
04:31:38,080 --> 04:31:40,000
neither the querier nor the cloud or the

3966
04:31:40,000 --> 04:31:43,600
server knows which path is being taken

3967
04:31:43,600 --> 04:31:46,000
right um so let's talk about sort of

3968
04:31:46,000 --> 04:31:48,159
this main traversal technique uh that's

3969
04:31:48,159 --> 04:31:49,920
used in this solution

3970
04:31:49,920 --> 04:31:50,800
okay

3971
04:31:50,800 --> 04:31:53,840
so uh the idea is that we're gonna use

3972
04:31:53,840 --> 04:31:56,080
private information retrieval to fetch

3973
04:31:56,080 --> 04:31:59,199
um particular uh

3974
04:31:59,199 --> 04:32:01,520
uh you know particular nodes at this

3975
04:32:01,520 --> 04:32:03,520
level uh we're gonna use secure

3976
04:32:03,520 --> 04:32:06,080
computation to sort of step down uh and

3977
04:32:06,080 --> 04:32:07,199
then we're gonna

3978
04:32:07,199 --> 04:32:09,760
essentially recurse right and the point

3979
04:32:09,760 --> 04:32:12,239
is that um eventually you might actually

3980
04:32:12,239 --> 04:32:14,000
want to switch from peer to oram just

3981
04:32:14,000 --> 04:32:16,159
due to the overheads and where you want

3982
04:32:16,159 --> 04:32:18,239
to do that switch um you know there is

3983
04:32:18,239 --> 04:32:20,479
the asymptotic answer and then there's

3984
04:32:20,479 --> 04:32:22,479
the practical answer um and i'll talk

3985
04:32:22,479 --> 04:32:23,840
more about sort of the practical answer

3986
04:32:23,840 --> 04:32:25,920
and sort of what we did there

3987
04:32:25,920 --> 04:32:28,399
okay um and the point is that all this

3988
04:32:28,399 --> 04:32:30,399
must be secret at all times because we

3989
04:32:30,399 --> 04:32:32,800
want to sort of um protect this right

3990
04:32:32,800 --> 04:32:34,960
and like i said you know finding where

3991
04:32:34,960 --> 04:32:37,199
where did that trade off uh is is a

3992
04:32:37,199 --> 04:32:38,640
question both in theory and also in

3993
04:32:38,640 --> 04:32:40,560
practice

3994
04:32:40,560 --> 04:32:41,439
okay

3995
04:32:41,439 --> 04:32:44,479
so let's look at uh traversal right

3996
04:32:44,479 --> 04:32:46,720
and i'm going to do this sort of uh

3997
04:32:46,720 --> 04:32:48,720
inductively where first you know i

3998
04:32:48,720 --> 04:32:50,319
assume i'm somewhere into the tree right

3999
04:32:50,319 --> 04:32:51,760
um obviously the first level of

4000
04:32:51,760 --> 04:32:53,279
abduction we're always at the root so

4001
04:32:53,279 --> 04:32:54,319
that's fine

4002
04:32:54,319 --> 04:32:56,319
um and so let's say i'm over here right

4003
04:32:56,319 --> 04:32:58,640
i'm at location uh i'm at branch number

4004
04:32:58,640 --> 04:33:01,199
one right and the recursive assumption

4005
04:33:01,199 --> 04:33:02,640
right sort of the inductive assumption

4006
04:33:02,640 --> 04:33:04,561
is that assume that the the client and

4007
04:33:04,561 --> 04:33:06,958
the servers hold a secret sharing of the

4008
04:33:06,958 --> 04:33:08,320
current location

4009
04:33:08,320 --> 04:33:09,359
on the tree right so the current

4010
04:33:09,359 --> 04:33:12,080
location on the tree here is is one

4011
04:33:12,080 --> 04:33:13,278
and

4012
04:33:13,278 --> 04:33:14,639
whoops

4013
04:33:14,639 --> 04:33:16,160
and

4014
04:33:16,160 --> 04:33:17,759
and this is for example is a secret

4015
04:33:17,759 --> 04:33:19,840
sharing of that

4016
04:33:19,840 --> 04:33:20,719
okay

4017
04:33:20,719 --> 04:33:22,400
um

4018
04:33:22,400 --> 04:33:23,919
so that's the assumption

4019
04:33:23,919 --> 04:33:26,400
so how do we actually operate and fetch

4020
04:33:26,400 --> 04:33:28,879
that for right that encrypted form

4021
04:33:28,879 --> 04:33:31,278
okay so the server will do a virtual

4022
04:33:31,278 --> 04:33:33,199
rotation right it won't actually do the

4023
04:33:33,199 --> 04:33:34,561
rotation but it'll do a virtual rotation

4024
04:33:34,561 --> 04:33:36,240
right it's share is two

4025
04:33:36,240 --> 04:33:38,320
and so in its mind it'll do a virtual

4026
04:33:38,320 --> 04:33:40,561
rotation of this uh this entire layer by

4027
04:33:40,561 --> 04:33:41,680
two

4028
04:33:41,680 --> 04:33:43,359
which will look something like this

4029
04:33:43,359 --> 04:33:44,799
right again virtually it's not actually

4030
04:33:44,799 --> 04:33:45,840
doing it you're just sort of thinking

4031
04:33:45,840 --> 04:33:47,438
about this

4032
04:33:47,438 --> 04:33:48,240
okay

4033
04:33:48,240 --> 04:33:50,480
uh so then after that right

4034
04:33:50,480 --> 04:33:52,719
the client who holds three

4035
04:33:52,719 --> 04:33:54,958
will just use pier to fetch location

4036
04:33:54,958 --> 04:33:55,919
three

4037
04:33:55,919 --> 04:33:57,919
right and this is location three but

4038
04:33:57,919 --> 04:33:59,680
because it's been rotated right this is

4039
04:33:59,680 --> 04:34:01,039
the actual correct value that it wants

4040
04:34:01,039 --> 04:34:03,039
to fetch

4041
04:34:03,039 --> 04:34:04,639
okay but we can't let the client know

4042
04:34:04,639 --> 04:34:06,080
anything about the database right so we

4043
04:34:06,080 --> 04:34:07,278
can't just give it back to the client we

4044
04:34:07,278 --> 04:34:08,799
actually have to mask

4045
04:34:08,799 --> 04:34:10,400
the return result to the client right

4046
04:34:10,400 --> 04:34:12,400
but by r

4047
04:34:12,400 --> 04:34:13,199
okay

4048
04:34:13,199 --> 04:34:15,520
so this is what it'll look like right so

4049
04:34:15,520 --> 04:34:17,118
so now the client has you know four

4050
04:34:17,118 --> 04:34:18,320
masked by r

4051
04:34:18,320 --> 04:34:19,919
the server holds r

4052
04:34:19,919 --> 04:34:21,438
and the next step we want to do is going

4053
04:34:21,438 --> 04:34:22,958
to figure out whether we want to go left

4054
04:34:22,958 --> 04:34:25,199
or right right so we want to say okay

4055
04:34:25,199 --> 04:34:27,359
you know here we're on this tree the

4056
04:34:27,359 --> 04:34:29,680
query is five the note is four uh

4057
04:34:29,680 --> 04:34:30,799
obviously you want to go right in this

4058
04:34:30,799 --> 04:34:32,719
case but uh no one should actually know

4059
04:34:32,719 --> 04:34:35,199
that right so we use actually a

4060
04:34:35,199 --> 04:34:37,680
lightweight securembc to actually do

4061
04:34:37,680 --> 04:34:39,680
this left right computation right so

4062
04:34:39,680 --> 04:34:41,599
here's the query the client has you know

4063
04:34:41,599 --> 04:34:43,919
four masked by r it's also encrypted so

4064
04:34:43,919 --> 04:34:45,359
there's also sort of the decryption

4065
04:34:45,359 --> 04:34:47,520
portion that also needs to happen um and

4066
04:34:47,520 --> 04:34:49,599
then here's the mask r

4067
04:34:49,599 --> 04:34:52,719
and what pops out is um basically a

4068
04:34:52,719 --> 04:34:54,799
secret sharing of whether to go left or

4069
04:34:54,799 --> 04:34:56,480
to go right

4070
04:34:56,480 --> 04:34:57,759
okay so what does that look like in

4071
04:34:57,759 --> 04:35:00,400
place right uh here is sort of the you

4072
04:35:00,400 --> 04:35:01,919
know the completion of the recursive

4073
04:35:01,919 --> 04:35:02,799
step

4074
04:35:02,799 --> 04:35:04,561
um where

4075
04:35:04,561 --> 04:35:07,278
uh we have f

4076
04:35:07,278 --> 04:35:09,599
we run this uh

4077
04:35:09,599 --> 04:35:11,520
secure computation and out pops secret

4078
04:35:11,520 --> 04:35:13,438
shares uh let's say four and seven which

4079
04:35:13,438 --> 04:35:15,759
add up to three mod you know the the

4080
04:35:15,759 --> 04:35:18,560
size of the next layer

4081
04:35:18,879 --> 04:35:20,561
okay so

4082
04:35:20,561 --> 04:35:22,000
that essentially is you know how we

4083
04:35:22,000 --> 04:35:23,759
traverse the tree now of course once you

4084
04:35:23,759 --> 04:35:25,039
get to the bottom there's you know some

4085
04:35:25,039 --> 04:35:26,320
additional work that has to sort of go

4086
04:35:26,320 --> 04:35:29,118
on we have sort of a custom you know

4087
04:35:29,118 --> 04:35:32,000
batch uh fetch protocol that fetches uh

4088
04:35:32,000 --> 04:35:33,759
essentially everything in in a range you

4089
04:35:33,759 --> 04:35:35,039
know i'm left in the right between left

4090
04:35:35,039 --> 04:35:37,438
and right end point um

4091
04:35:37,438 --> 04:35:39,359
i won't go into those details there uh

4092
04:35:39,359 --> 04:35:40,561
instead i'll talk about sort of the

4093
04:35:40,561 --> 04:35:42,080
performance

4094
04:35:42,080 --> 04:35:44,240
uh so one question might be uh if we're

4095
04:35:44,240 --> 04:35:46,000
using pier right if we're using pure you

4096
04:35:46,000 --> 04:35:47,520
know all the way down to the very lower

4097
04:35:47,520 --> 04:35:49,278
levels of the tree isn't that sort of

4098
04:35:49,278 --> 04:35:50,639
linear computation in the size of the

4099
04:35:50,639 --> 04:35:52,000
database

4100
04:35:52,000 --> 04:35:55,359
uh well sort of right uh the thing is we

4101
04:35:55,359 --> 04:35:57,039
only need to traverse over this these

4102
04:35:57,039 --> 04:35:59,039
sort of small indexable data and not

4103
04:35:59,039 --> 04:36:00,400
payloads right so it's not the entire

4104
04:36:00,400 --> 04:36:02,719
database it's really just the indexed uh

4105
04:36:02,719 --> 04:36:04,799
or the the the sort of the index column

4106
04:36:04,799 --> 04:36:06,561
that we're looking at right

4107
04:36:06,561 --> 04:36:07,919
um

4108
04:36:07,919 --> 04:36:10,000
and for concrete numbers right uh you

4109
04:36:10,000 --> 04:36:11,520
know balancing these layer sizes

4110
04:36:11,520 --> 04:36:13,438
actually makes a bigger impact than the

4111
04:36:13,438 --> 04:36:15,520
asymptotics so it turns out that doing

4112
04:36:15,520 --> 04:36:17,840
you know peer even doing sort of uh

4113
04:36:17,840 --> 04:36:19,118
linear work but if it's just a whole

4114
04:36:19,118 --> 04:36:23,038
bunch of xors it's actually not that bad

4115
04:36:23,278 --> 04:36:24,400
um

4116
04:36:24,400 --> 04:36:25,840
you know as part of this program there's

4117
04:36:25,840 --> 04:36:27,919
independent testing by mit lincoln lab

4118
04:36:27,919 --> 04:36:29,438
um and it turns out that you know for

4119
04:36:29,438 --> 04:36:31,359
large queries we're around like five

4120
04:36:31,359 --> 04:36:33,520
like five times slower than my sql

4121
04:36:33,520 --> 04:36:35,680
um for smaller queries the actual

4122
04:36:35,680 --> 04:36:37,278
multiplicative overhead looks large like

4123
04:36:37,278 --> 04:36:39,680
100x but really it's it's it's like 5x

4124
04:36:39,680 --> 04:36:41,520
plus a constant right it's like you know

4125
04:36:41,520 --> 04:36:43,359
like one second right

4126
04:36:43,359 --> 04:36:45,039
um

4127
04:36:45,039 --> 04:36:48,080
so just a couple of charts um so this is

4128
04:36:48,080 --> 04:36:49,919
what it looks like as we sort of scale

4129
04:36:49,919 --> 04:36:50,561
up

4130
04:36:50,561 --> 04:36:51,438
uh

4131
04:36:51,438 --> 04:36:54,639
the size of the query

4132
04:36:54,639 --> 04:36:57,599
right this is all over sort of a a large

4133
04:36:57,599 --> 04:36:59,520
database of the size that i mentioned

4134
04:36:59,520 --> 04:37:03,199
before um so you know basically uh as

4135
04:37:03,199 --> 04:37:04,799
the number of results go up uh so does

4136
04:37:04,799 --> 04:37:07,359
the running time um relative overhead

4137
04:37:07,359 --> 04:37:08,879
right for

4138
04:37:08,879 --> 04:37:10,160
small number for a small number of

4139
04:37:10,160 --> 04:37:12,080
results right we're getting a lot of

4140
04:37:12,080 --> 04:37:14,400
sort of large relative overhead

4141
04:37:14,400 --> 04:37:16,080
but that's again just due to the fixed

4142
04:37:16,080 --> 04:37:18,719
cost of our scheme right um

4143
04:37:18,719 --> 04:37:20,561
perhaps a better chart to look at is

4144
04:37:20,561 --> 04:37:21,520
what if you actually just look at the

4145
04:37:21,520 --> 04:37:23,599
trend right if you look at the trend

4146
04:37:23,599 --> 04:37:26,879
it's actually like you know 5.4 x

4147
04:37:26,879 --> 04:37:29,840
plus like a 0.7 second cost right so

4148
04:37:29,840 --> 04:37:31,278
this point second seven seconds is going

4149
04:37:31,278 --> 04:37:34,160
to dominate for these smaller ones right

4150
04:37:34,160 --> 04:37:37,278
and that's sort of what causes our um

4151
04:37:37,278 --> 04:37:38,799
our head to be so large for small

4152
04:37:38,799 --> 04:37:40,958
queries right but then once you get into

4153
04:37:40,958 --> 04:37:43,359
the larger queries uh this point seven

4154
04:37:43,359 --> 04:37:46,160
you know it kind of gets um uh blended

4155
04:37:46,160 --> 04:37:48,160
out and the the five point four x is

4156
04:37:48,160 --> 04:37:51,039
really the uh uh the the sort of the

4157
04:37:51,039 --> 04:37:52,080
overhead that you're that you're

4158
04:37:52,080 --> 04:37:54,639
actually looking at

4159
04:37:54,719 --> 04:37:55,520
okay

4160
04:37:55,520 --> 04:37:56,790
so um

4161
04:37:56,790 --> 04:37:58,240
[Music]

4162
04:37:58,240 --> 04:38:01,359
that's about it for uh that work um let

4163
04:38:01,359 --> 04:38:02,879
me talk about some sort of interesting

4164
04:38:02,879 --> 04:38:04,879
follow-up work uh that's sort of gone

4165
04:38:04,879 --> 04:38:06,561
since then right

4166
04:38:06,561 --> 04:38:07,599
um

4167
04:38:07,599 --> 04:38:10,719
so as part of darpa brandeis so darpa

4168
04:38:10,719 --> 04:38:12,958
started this project um called brandeis

4169
04:38:12,958 --> 04:38:14,879
it was named after

4170
04:38:14,879 --> 04:38:17,199
justice lewis brandeis who was

4171
04:38:17,199 --> 04:38:18,639
you know who wrote this

4172
04:38:18,639 --> 04:38:20,719
influential piece about privacy back at

4173
04:38:20,719 --> 04:38:22,799
the turn of the

4174
04:38:22,799 --> 04:38:25,759
20th century um and

4175
04:38:25,759 --> 04:38:28,639
that was due to uh it was a reaction it

4176
04:38:28,639 --> 04:38:30,160
was a reactionary piece due to the

4177
04:38:30,160 --> 04:38:32,480
invention of the instant camera not the

4178
04:38:32,480 --> 04:38:34,400
digital camera mind you just the regular

4179
04:38:34,400 --> 04:38:37,118
camera um and

4180
04:38:37,118 --> 04:38:38,958
there's a question of okay well you know

4181
04:38:38,958 --> 04:38:40,400
what can we do about sort of personal

4182
04:38:40,400 --> 04:38:42,320
privacy now that these devices exist

4183
04:38:42,320 --> 04:38:44,480
right um obviously a hundred years later

4184
04:38:44,480 --> 04:38:46,719
um you know these privacy problems have

4185
04:38:46,719 --> 04:38:48,639
only compounded and

4186
04:38:48,639 --> 04:38:51,039
uh darpa brandeis was a sort of a

4187
04:38:51,039 --> 04:38:53,599
multi-disciplinary look into how we can

4188
04:38:53,599 --> 04:38:56,639
address the problem of privacy um our

4189
04:38:56,639 --> 04:38:58,320
approach to that program was from a

4190
04:38:58,320 --> 04:39:00,000
cryptographic standpoint um there are

4191
04:39:00,000 --> 04:39:01,919
many other people doing other sort of

4192
04:39:01,919 --> 04:39:04,000
cool approaches to how we can improve

4193
04:39:04,000 --> 04:39:06,160
privacy

4194
04:39:06,160 --> 04:39:08,240
so our project was called pulsar

4195
04:39:08,240 --> 04:39:10,320
and essentially it's in it's a spiritual

4196
04:39:10,320 --> 04:39:12,000
extension of this work

4197
04:39:12,000 --> 04:39:13,840
where we have this secure and private

4198
04:39:13,840 --> 04:39:16,080
data repository where you have data

4199
04:39:16,080 --> 04:39:17,438
contributors

4200
04:39:17,438 --> 04:39:19,359
you have data analysts

4201
04:39:19,359 --> 04:39:20,639
and you want to have these sort of

4202
04:39:20,639 --> 04:39:21,919
strong guarantees where the data

4203
04:39:21,919 --> 04:39:24,561
contributor can contribute data securely

4204
04:39:24,561 --> 04:39:26,958
and privately and

4205
04:39:26,958 --> 04:39:28,799
attach policies to these

4206
04:39:28,799 --> 04:39:30,400
and attach sort of fine-grained controls

4207
04:39:30,400 --> 04:39:32,719
of how they can be disclosed

4208
04:39:32,719 --> 04:39:34,080
and have that sort of provenance and

4209
04:39:34,080 --> 04:39:35,919
assurance

4210
04:39:35,919 --> 04:39:39,120
on the other end um data analysts right

4211
04:39:39,120 --> 04:39:40,878
want to be able to run these queries but

4212
04:39:40,878 --> 04:39:42,560
not necessarily let the whole world know

4213
04:39:42,560 --> 04:39:44,638
what it is they're researching um and

4214
04:39:44,638 --> 04:39:46,240
these policies also and these queries

4215
04:39:46,240 --> 04:39:47,920
must also be ran in accordance to the

4216
04:39:47,920 --> 04:39:50,399
policies

4217
04:39:50,638 --> 04:39:52,798
um and the point is right because we're

4218
04:39:52,798 --> 04:39:54,400
sort of working in this two server model

4219
04:39:54,400 --> 04:39:57,280
right um a single server compromise is

4220
04:39:57,280 --> 04:39:59,920
also okay right um that's sort of one of

4221
04:39:59,920 --> 04:40:01,920
the one of the benefits of also having

4222
04:40:01,920 --> 04:40:04,000
like a two-server model

4223
04:40:04,000 --> 04:40:06,240
um

4224
04:40:06,320 --> 04:40:08,400
as part of this program you know we we

4225
04:40:08,400 --> 04:40:10,480
were developing this but we also were

4226
04:40:10,480 --> 04:40:12,400
developing the sub-protocols using that

4227
04:40:12,400 --> 04:40:14,718
um uh you know that that construction

4228
04:40:14,718 --> 04:40:16,718
right within that construction we looked

4229
04:40:16,718 --> 04:40:19,040
at sort of private information retrieval

4230
04:40:19,040 --> 04:40:21,200
we looked at oblivious ram

4231
04:40:21,200 --> 04:40:22,718
different ways of instantiating them it

4232
04:40:22,718 --> 04:40:24,240
turns out a lot of the sub protocols

4233
04:40:24,240 --> 04:40:26,718
actually had very interesting and useful

4234
04:40:26,718 --> 04:40:27,600
uh

4235
04:40:27,600 --> 04:40:29,040
applications that we sort of integrated

4236
04:40:29,040 --> 04:40:31,520
with uh inside that program so one of

4237
04:40:31,520 --> 04:40:33,440
them was uh observing sort of general

4238
04:40:33,440 --> 04:40:35,840
trends of behavior and fitness of of

4239
04:40:35,840 --> 04:40:37,840
sailors uh while protecting their

4240
04:40:37,840 --> 04:40:39,360
privacy

4241
04:40:39,360 --> 04:40:41,200
uh another one where we collaborated

4242
04:40:41,200 --> 04:40:44,480
with uc irvine and honeywell where we

4243
04:40:44,480 --> 04:40:47,280
uh sort of uh enabled a space

4244
04:40:47,280 --> 04:40:49,120
utilization monitoring and sort of uh

4245
04:40:49,120 --> 04:40:52,240
power consumption sort of um

4246
04:40:52,240 --> 04:40:53,920
you know building monitoring hvac kind

4247
04:40:53,920 --> 04:40:55,120
of monitoring kind of thing power

4248
04:40:55,120 --> 04:40:56,958
consumption um

4249
04:40:56,958 --> 04:40:58,718
in bren hall that's like the cs building

4250
04:40:58,718 --> 04:41:01,280
of uc irvine

4251
04:41:01,280 --> 04:41:03,440
uh and we're also working with uh the

4252
04:41:03,440 --> 04:41:05,360
the state of virginia in the sort of the

4253
04:41:05,360 --> 04:41:07,440
virginia longitudinal data system where

4254
04:41:07,440 --> 04:41:10,240
we're looking at uh ways to

4255
04:41:10,240 --> 04:41:12,878
compare sensitive student income data

4256
04:41:12,878 --> 04:41:15,920
along with their uh university records

4257
04:41:15,920 --> 04:41:17,840
right uh essentially to build like a

4258
04:41:17,840 --> 04:41:20,160
scorecard or uh um

4259
04:41:20,160 --> 04:41:20,958
you know

4260
04:41:20,958 --> 04:41:23,600
know before you go report um

4261
04:41:23,600 --> 04:41:26,000
so that students can be informed of

4262
04:41:26,000 --> 04:41:27,600
essentially their value of their

4263
04:41:27,600 --> 04:41:29,520
education as they go to these colleges

4264
04:41:29,520 --> 04:41:31,360
right and these were all sort of built

4265
04:41:31,360 --> 04:41:33,040
out from various components and sub

4266
04:41:33,040 --> 04:41:36,560
components uh of of our scheme

4267
04:41:36,560 --> 04:41:38,638
and we continue to work on improvements

4268
04:41:38,638 --> 04:41:39,680
right we continue to work on

4269
04:41:39,680 --> 04:41:41,920
improvements um

4270
04:41:41,920 --> 04:41:44,560
in this area so for example right like i

4271
04:41:44,560 --> 04:41:46,798
said earlier uh that work essentially

4272
04:41:46,798 --> 04:41:48,638
looked at a single table right and it

4273
04:41:48,638 --> 04:41:50,718
worked more like a key value store more

4274
04:41:50,718 --> 04:41:53,040
so than a traditional database um if you

4275
04:41:53,040 --> 04:41:55,200
wanted to do like uh select project join

4276
04:41:55,200 --> 04:41:57,120
union you know more traditional database

4277
04:41:57,120 --> 04:41:59,520
you type things uh what can be done

4278
04:41:59,520 --> 04:42:01,040
right um

4279
04:42:01,040 --> 04:42:02,400
one of the important things there right

4280
04:42:02,400 --> 04:42:04,320
is the the join operation and there you

4281
04:42:04,320 --> 04:42:06,320
really need to sort of be able to bring

4282
04:42:06,320 --> 04:42:09,200
together data sets um and so recent

4283
04:42:09,200 --> 04:42:10,878
improvements in private set intersection

4284
04:42:10,878 --> 04:42:13,360
private set union um secure merge

4285
04:42:13,360 --> 04:42:14,878
protocols

4286
04:42:14,878 --> 04:42:16,798
uh have been sort of um you know very

4287
04:42:16,798 --> 04:42:18,400
instrumental there

4288
04:42:18,400 --> 04:42:19,520
um

4289
04:42:19,520 --> 04:42:21,120
other sub-components right that we

4290
04:42:21,120 --> 04:42:23,360
talked about for example in improving

4291
04:42:23,360 --> 04:42:24,718
private information retrieval or

4292
04:42:24,718 --> 04:42:26,480
improving sort of um

4293
04:42:26,480 --> 04:42:28,798
distributed oblivious ram uh you know

4294
04:42:28,798 --> 04:42:30,080
there's work in that area you know if we

4295
04:42:30,080 --> 04:42:32,160
speed that up that also sort of helps

4296
04:42:32,160 --> 04:42:35,200
our components as well

4297
04:42:35,680 --> 04:42:37,440
if you want to reduce the amount of

4298
04:42:37,440 --> 04:42:39,040
interaction that has to happen between

4299
04:42:39,040 --> 04:42:40,240
the client and servers right because as

4300
04:42:40,240 --> 04:42:41,760
we're traversing down the street right

4301
04:42:41,760 --> 04:42:44,080
there's sort of these interactive rounds

4302
04:42:44,080 --> 04:42:46,160
uh we can also look at uh

4303
04:42:46,160 --> 04:42:48,320
non-interactive

4304
04:42:48,320 --> 04:42:50,958
secure computation uh modes uh such as

4305
04:42:50,958 --> 04:42:53,280
global ram um

4306
04:42:53,280 --> 04:42:54,878
as well as sort of just better or better

4307
04:42:54,878 --> 04:42:56,080
garbage building schemes in general

4308
04:42:56,080 --> 04:42:57,360
right um

4309
04:42:57,360 --> 04:43:00,000
in fact blind sear also looked at uh

4310
04:43:00,000 --> 04:43:02,080
gravel circuits as one of the mechanisms

4311
04:43:02,080 --> 04:43:05,280
for index reversal um

4312
04:43:05,280 --> 04:43:07,440
and so uh you know we also looked at

4313
04:43:07,440 --> 04:43:09,200
sort of how how can we use sort of these

4314
04:43:09,200 --> 04:43:11,600
better garbling schemes as uh you know

4315
04:43:11,600 --> 04:43:13,040
faster ways to traverse the street

4316
04:43:13,040 --> 04:43:14,320
securely

4317
04:43:14,320 --> 04:43:16,958
uh and also let me plug uh this last

4318
04:43:16,958 --> 04:43:18,798
work this is gonna actually be um

4319
04:43:18,798 --> 04:43:22,717
featured in this crypto uh on thursday

4320
04:43:23,120 --> 04:43:26,400
okay so with that i think i will uh wrap

4321
04:43:26,400 --> 04:43:29,760
up so just to give some key takeaways

4322
04:43:29,760 --> 04:43:32,080
um you know we introduced a new uh

4323
04:43:32,080 --> 04:43:34,160
social symmetric encryption scheme uh in

4324
04:43:34,160 --> 04:43:36,400
the two servers semi-auto setting that

4325
04:43:36,400 --> 04:43:38,638
uh enables sort of both data privacy and

4326
04:43:38,638 --> 04:43:41,280
query privacy uh for range queries with

4327
04:43:41,280 --> 04:43:42,560
policies

4328
04:43:42,560 --> 04:43:44,798
right and we were able to do this with

4329
04:43:44,798 --> 04:43:46,320
less leach than traditional sort of

4330
04:43:46,320 --> 04:43:48,638
social encryption schemes by employing

4331
04:43:48,638 --> 04:43:52,240
uh you know peer and oram methods

4332
04:43:52,240 --> 04:43:54,320
uh this was also sort of benchmarked uh

4333
04:43:54,320 --> 04:43:56,480
independently tested and was shown to be

4334
04:43:56,480 --> 04:43:59,040
around you know 5x overhead of of my sql

4335
04:43:59,040 --> 04:44:00,638
and it's scaled up to database you know

4336
04:44:00,638 --> 04:44:02,480
database database and database data set

4337
04:44:02,480 --> 04:44:04,560
sizes of like 100 million records 10

4338
04:44:04,560 --> 04:44:06,718
terabytes

4339
04:44:06,718 --> 04:44:08,400
um and

4340
04:44:08,400 --> 04:44:09,440
you know

4341
04:44:09,440 --> 04:44:10,958
interestingly enough the main protocol

4342
04:44:10,958 --> 04:44:13,600
and sub components have been sort of uh

4343
04:44:13,600 --> 04:44:16,000
you know built out uh further and

4344
04:44:16,000 --> 04:44:17,760
they've um

4345
04:44:17,760 --> 04:44:19,440
you know been fruitful in some cool

4346
04:44:19,440 --> 04:44:22,160
applications um especially with regards

4347
04:44:22,160 --> 04:44:25,680
to being able to join datasets together

4348
04:44:25,680 --> 04:44:27,440
okay and with that i'll conclude so

4349
04:44:27,440 --> 04:44:29,840
thank you

4350
04:44:35,120 --> 04:44:37,600
steve are there any questions

4351
04:44:37,600 --> 04:44:40,840
in the room

4352
04:44:46,080 --> 04:44:48,080
uh thank you for the great talk um is

4353
04:44:48,080 --> 04:44:49,760
there an inherent connection between the

4354
04:44:49,760 --> 04:44:52,000
distributed setting and ensuring

4355
04:44:52,000 --> 04:44:53,680
server-side privacy

4356
04:44:53,680 --> 04:44:55,520
uh like one could also consider server

4357
04:44:55,520 --> 04:44:57,280
side privacy in the case of a single

4358
04:44:57,280 --> 04:44:58,798
server setting right

4359
04:44:58,798 --> 04:45:00,718
yep okay so for the question for those

4360
04:45:00,718 --> 04:45:01,760
out there who might not be able to hear

4361
04:45:01,760 --> 04:45:02,958
this the question was is there an

4362
04:45:02,958 --> 04:45:04,560
inherent connection between the

4363
04:45:04,560 --> 04:45:07,040
distributed setting and server privacy

4364
04:45:07,040 --> 04:45:08,958
right and um

4365
04:45:08,958 --> 04:45:10,798
and and and the answer is no right

4366
04:45:10,798 --> 04:45:11,920
there's no inherent connection there

4367
04:45:11,920 --> 04:45:13,680
right that you can in fact write get

4368
04:45:13,680 --> 04:45:15,680
server side privacy um

4369
04:45:15,680 --> 04:45:17,440
entirely using in the single server

4370
04:45:17,440 --> 04:45:19,920
setting right um so

4371
04:45:19,920 --> 04:45:21,120
there's obviously the works of like you

4372
04:45:21,120 --> 04:45:22,160
know symmetric private information

4373
04:45:22,160 --> 04:45:24,240
retrieval there that gives you

4374
04:45:24,240 --> 04:45:26,798
server privacy um and

4375
04:45:26,798 --> 04:45:28,718
if you look at the works um you know

4376
04:45:28,718 --> 04:45:31,280
blind sir and espada they work in sort

4377
04:45:31,280 --> 04:45:32,480
of the

4378
04:45:32,480 --> 04:45:33,920
outsource server model so it's still

4379
04:45:33,920 --> 04:45:35,600
it's still sort of single server right

4380
04:45:35,600 --> 04:45:37,440
in the sense that the the data owner

4381
04:45:37,440 --> 04:45:38,638
outsources the data and then they

4382
04:45:38,638 --> 04:45:39,840
disappear so it's still kind of one

4383
04:45:39,840 --> 04:45:41,840
server um

4384
04:45:41,840 --> 04:45:43,520
and they're right also you you had this

4385
04:45:43,520 --> 04:45:45,920
property of uh server privacy right um

4386
04:45:45,920 --> 04:45:48,000
and then obviously right uh

4387
04:45:48,000 --> 04:45:50,560
if you just look at sort of uh more

4388
04:45:50,560 --> 04:45:53,920
traditional uh forms of a convention

4389
04:45:53,920 --> 04:45:55,440
symmetric peer

4390
04:45:55,440 --> 04:45:57,520
you know there you also can get server

4391
04:45:57,520 --> 04:45:58,638
privacy as

4392
04:45:58,638 --> 04:46:01,600
in the single server setting

4393
04:46:05,600 --> 04:46:07,200
yeah actually as a follow-up i have a

4394
04:46:07,200 --> 04:46:08,878
question um

4395
04:46:08,878 --> 04:46:10,798
was there like the the intention of

4396
04:46:10,798 --> 04:46:13,040
using two servers is because you you

4397
04:46:13,040 --> 04:46:14,160
wanted to

4398
04:46:14,160 --> 04:46:16,000
uh kind of like benefit from the

4399
04:46:16,000 --> 04:46:17,760
concrete efficiency of the two server

4400
04:46:17,760 --> 04:46:20,798
setting like for example oram is quite

4401
04:46:20,798 --> 04:46:22,400
faster in the two servers you know for

4402
04:46:22,400 --> 04:46:24,718
example peer because it's just using xor

4403
04:46:24,718 --> 04:46:26,320
or something like that was this the

4404
04:46:26,320 --> 04:46:27,600
intention

4405
04:46:27,600 --> 04:46:29,520
like to use to the chooser okay so

4406
04:46:29,520 --> 04:46:32,000
that's exactly right i mean um the the

4407
04:46:32,000 --> 04:46:33,360
question is right why go in the

4408
04:46:33,360 --> 04:46:36,560
two-server setting right um one was in

4409
04:46:36,560 --> 04:46:38,480
in some sense um that was part of the

4410
04:46:38,480 --> 04:46:40,160
problem statement that we we had this

4411
04:46:40,160 --> 04:46:41,840
additional helper server to available to

4412
04:46:41,840 --> 04:46:43,360
us so we said all right well it's there

4413
04:46:43,360 --> 04:46:45,040
uh we can sort of uh make use of it

4414
04:46:45,040 --> 04:46:47,680
right and that's precisely it right that

4415
04:46:47,680 --> 04:46:49,520
given that it's there

4416
04:46:49,520 --> 04:46:51,840
uh we can leverage um

4417
04:46:51,840 --> 04:46:54,958
the multi-server uh setting of uh

4418
04:46:54,958 --> 04:46:56,718
various constructions for example like

4419
04:46:56,718 --> 04:46:58,638
pure where the operations there are much

4420
04:46:58,638 --> 04:47:00,240
faster right there's it's essentially

4421
04:47:00,240 --> 04:47:02,080
just xors as opposed to the single

4422
04:47:02,080 --> 04:47:05,280
server peer setting which um you know

4423
04:47:05,280 --> 04:47:07,920
even modern ones still rely on you know

4424
04:47:07,920 --> 04:47:11,040
sort of heavy um or heavier uh public

4425
04:47:11,040 --> 04:47:14,000
key operations um you know it has since

4426
04:47:14,000 --> 04:47:16,000
been you know sort of more optimized um

4427
04:47:16,000 --> 04:47:17,520
you know i mean back then it was a lot

4428
04:47:17,520 --> 04:47:20,400
slower now it's still slower but um

4429
04:47:20,400 --> 04:47:21,520
you know really

4430
04:47:21,520 --> 04:47:23,360
it it doesn't come close to the two

4431
04:47:23,360 --> 04:47:24,560
surface setting where it's essentially

4432
04:47:24,560 --> 04:47:26,878
just symmetric operation it's it's even

4433
04:47:26,878 --> 04:47:28,000
better than that it's just like xor

4434
04:47:28,000 --> 04:47:29,120
right

4435
04:47:29,120 --> 04:47:31,040
so uh really

4436
04:47:31,040 --> 04:47:33,920
the the the the combination of a we have

4437
04:47:33,920 --> 04:47:35,600
that capability uh given to us in the

4438
04:47:35,600 --> 04:47:37,840
problem statement and b um

4439
04:47:37,840 --> 04:47:39,600
thankfully crypto in in the multi-server

4440
04:47:39,600 --> 04:47:42,000
setting works a lot faster um uh it

4441
04:47:42,000 --> 04:47:45,840
seems like a natural fit for us

4442
04:47:58,560 --> 04:48:01,560
uh

4443
04:48:16,080 --> 04:48:19,200
right yeah i i think you know i mean

4444
04:48:19,200 --> 04:48:21,680
if you look at uh the the line of work

4445
04:48:21,680 --> 04:48:24,080
of like blind seer and um

4446
04:48:24,080 --> 04:48:27,120
of of uh espada right there even though

4447
04:48:27,120 --> 04:48:29,600
they did some pre-processing right uh

4448
04:48:29,600 --> 04:48:32,718
the the online work was uh much lower

4449
04:48:32,718 --> 04:48:34,798
because it is ssc style as opposed to

4450
04:48:34,798 --> 04:48:37,600
pure style right um so pre-processing

4451
04:48:37,600 --> 04:48:38,958
pure right

4452
04:48:38,958 --> 04:48:40,878
i i definitely think that it it sort of

4453
04:48:40,878 --> 04:48:44,240
uh fits the overall kind of um uh you

4454
04:48:44,240 --> 04:48:46,240
know uh theme of

4455
04:48:46,240 --> 04:48:47,040
having you know having these three

4456
04:48:47,040 --> 04:48:49,360
processes in step um and then right

4457
04:48:49,360 --> 04:48:51,280
online you have the ability to get

4458
04:48:51,280 --> 04:48:53,200
sub-linear work like you would in

4459
04:48:53,200 --> 04:48:56,080
something like oh ram right um so i so i

4460
04:48:56,080 --> 04:48:57,280
definitely think that

4461
04:48:57,280 --> 04:48:59,920
if you sort of consider

4462
04:48:59,920 --> 04:49:01,760
uh that as a

4463
04:49:01,760 --> 04:49:03,120
uh

4464
04:49:03,120 --> 04:49:05,760
a very sort of related um

4465
04:49:05,760 --> 04:49:07,360
uh you know

4466
04:49:07,360 --> 04:49:09,440
sub-parallel that can be applied to this

4467
04:49:09,440 --> 04:49:11,120
i would say yes i think the the the

4468
04:49:11,120 --> 04:49:13,200
pre-crossing pure uh

4469
04:49:13,200 --> 04:49:14,560
that definitely kind of fits into the

4470
04:49:14,560 --> 04:49:18,200
overall theme of this

4471
04:49:22,080 --> 04:49:24,480
not i have also another question so in

4472
04:49:24,480 --> 04:49:25,520
in your

4473
04:49:25,520 --> 04:49:28,240
evaluation numbers um so i'm actually

4474
04:49:28,240 --> 04:49:30,718
curious on the setup of your evaluation

4475
04:49:30,718 --> 04:49:34,160
like in the true server was it like in

4476
04:49:34,160 --> 04:49:35,280
the same

4477
04:49:35,280 --> 04:49:37,440
location or were the servers in

4478
04:49:37,440 --> 04:49:39,280
different locations because like

4479
04:49:39,280 --> 04:49:41,200
inherently your scheme is doing some

4480
04:49:41,200 --> 04:49:43,600
interactions so definitely the distance

4481
04:49:43,600 --> 04:49:46,958
between the the two servers uh matter so

4482
04:49:46,958 --> 04:49:48,560
can you tell us a little bit more about

4483
04:49:48,560 --> 04:49:51,280
the setup of the evaluation right uh so

4484
04:49:51,280 --> 04:49:52,958
the question was right how are the

4485
04:49:52,958 --> 04:49:54,638
servers situated during the evaluation

4486
04:49:54,638 --> 04:49:56,718
so i believe what uh mnt lincoln lab did

4487
04:49:56,718 --> 04:49:59,040
was they had this hosted on their

4488
04:49:59,040 --> 04:50:00,798
internal cloud right so all three

4489
04:50:00,798 --> 04:50:02,080
parties were hosted on their internal

4490
04:50:02,080 --> 04:50:03,760
cloud which i presume had a fast

4491
04:50:03,760 --> 04:50:06,480
connection between them

4492
04:50:10,638 --> 04:50:15,079
let's thank the speaker

4493
04:50:21,760 --> 04:50:24,638
we have a coffee break of 20 minutes and

4494
04:50:24,638 --> 04:50:27,680
we will be back at

4495
04:50:28,240 --> 04:50:31,480
2 20.

4496
05:23:38,798 --> 05:23:41,440
six stores um including you know

4497
05:23:41,440 --> 05:23:43,920
potentially complex sub documents so not

4498
05:23:43,920 --> 05:23:45,840
like pdfs or word files or things where

4499
05:23:45,840 --> 05:23:48,000
there's keyword searches obviously a lot

4500
05:23:48,000 --> 05:23:50,160
of the core uh components and data

4501
05:23:50,160 --> 05:23:51,600
structures

4502
05:23:51,600 --> 05:23:55,120
uh are you know are quite similar but uh

4503
05:23:55,120 --> 05:23:57,760
just to sort of paint that picture

4504
05:23:57,760 --> 05:23:59,040
it's a distributed architecture by

4505
05:23:59,040 --> 05:24:00,638
design which means

4506
05:24:00,638 --> 05:24:02,320
that while

4507
05:24:02,320 --> 05:24:04,400
lots and lots of developers have a

4508
05:24:04,400 --> 05:24:05,360
single

4509
05:24:05,360 --> 05:24:07,760
uh copy of on their uh you know on

4510
05:24:07,760 --> 05:24:10,320
their laptops

4511
05:24:10,320 --> 05:24:12,558
it's both

4512
05:24:12,558 --> 05:24:15,040
a standalone system as well as a high

4513
05:24:15,040 --> 05:24:17,040
availability

4514
05:24:17,040 --> 05:24:19,040
distributed system so i'll get into in

4515
05:24:19,040 --> 05:24:20,160
the next slide

4516
05:24:20,160 --> 05:24:21,920
a sense of what that what that looks

4517
05:24:21,920 --> 05:24:24,160
like in industry um

4518
05:24:24,160 --> 05:24:26,558
it's a really big developer community so

4519
05:24:26,558 --> 05:24:28,320
as you can see uh

4520
05:24:28,320 --> 05:24:29,760
over a

4521
05:24:29,760 --> 05:24:32,240
quarter million uh downloads

4522
05:24:32,240 --> 05:24:35,440
very active community forums things on

4523
05:24:35,440 --> 05:24:38,400
stack overflow

4524
05:24:38,400 --> 05:24:40,240
you know really across the web

4525
05:24:40,240 --> 05:24:42,798
one of the things about is

4526
05:24:42,798 --> 05:24:45,600
we support i think around 14 different

4527
05:24:45,600 --> 05:24:47,440
application languages so there's pretty

4528
05:24:47,440 --> 05:24:48,958
much no

4529
05:24:48,958 --> 05:24:50,798
modern programming language that's you

4530
05:24:50,798 --> 05:24:52,160
know there's not applications out there

4531
05:24:52,160 --> 05:24:55,040
for so csharp.net

4532
05:24:55,040 --> 05:24:59,040
on windows on linux python node.js

4533
05:24:59,040 --> 05:25:01,360
java scala

4534
05:25:01,360 --> 05:25:04,558
php ruby um you know the list kind of

4535
05:25:04,558 --> 05:25:07,920
goes on and on every operating system

4536
05:25:07,920 --> 05:25:09,840
under the sun so

4537
05:25:09,840 --> 05:25:11,760
all the flavors and windows all the

4538
05:25:11,760 --> 05:25:14,320
major flavors of the linuxes every

4539
05:25:14,320 --> 05:25:18,320
flavor of debian and red hat and send it

4540
05:25:18,320 --> 05:25:19,680
um

4541
05:25:19,680 --> 05:25:23,280
even uh ibm z series mainframes we have

4542
05:25:23,280 --> 05:25:26,400
some customers that are uh doing uh you

4543
05:25:26,400 --> 05:25:27,280
know

4544
05:25:27,280 --> 05:25:28,400
that have legacy systems in the

4545
05:25:28,400 --> 05:25:30,080
financial world or in healthcare where

4546
05:25:30,080 --> 05:25:31,920
you know there's massive infrastructure

4547
05:25:31,920 --> 05:25:33,920
on on z series

4548
05:25:33,920 --> 05:25:37,120
uh every hardware platform so x86

4549
05:25:37,120 --> 05:25:38,320
uh arm

4550
05:25:38,320 --> 05:25:39,920
uh spark

4551
05:25:39,920 --> 05:25:42,240
as i said the z series as well so it's

4552
05:25:42,240 --> 05:25:43,200
it's a

4553
05:25:43,200 --> 05:25:45,760
really uh you know it's a really rich

4554
05:25:45,760 --> 05:25:48,878
ecosystem our online university um over

4555
05:25:48,878 --> 05:25:50,878
a million and a half students have taken

4556
05:25:50,878 --> 05:25:53,360
classes have signed up everything from

4557
05:25:53,360 --> 05:25:54,958
like the very basic kind of hello world

4558
05:25:54,958 --> 05:25:56,000
stuff to

4559
05:25:56,000 --> 05:25:57,200
uh you know

4560
05:25:57,200 --> 05:25:58,878
some of the much more advanced

4561
05:25:58,878 --> 05:26:01,520
uh like aggregation pipeline analytics

4562
05:26:01,520 --> 05:26:02,320
and

4563
05:26:02,320 --> 05:26:06,240
you know really complex data structures

4564
05:26:06,240 --> 05:26:08,160
one of the things that i found out about

4565
05:26:08,160 --> 05:26:10,958
a year ago is

4566
05:26:11,040 --> 05:26:11,340
in

4567
05:26:11,340 --> 05:26:12,840
[Music]

4568
05:26:12,840 --> 05:26:14,080
india um

4569
05:26:14,080 --> 05:26:16,558
unlike in the states where kind of uh

4570
05:26:16,558 --> 05:26:17,440
you know

4571
05:26:17,440 --> 05:26:19,920
every individual state in the u.s has

4572
05:26:19,920 --> 05:26:21,600
you know sort of their own uh school

4573
05:26:21,600 --> 05:26:23,920
boards and their own kind of curriculum

4574
05:26:23,920 --> 05:26:25,600
that's dictated at that level

4575
05:26:25,600 --> 05:26:27,200
you know sometimes provincial level but

4576
05:26:27,200 --> 05:26:28,958
usually at the state level in india

4577
05:26:28,958 --> 05:26:31,280
there's actually national curricula and

4578
05:26:31,280 --> 05:26:33,440
part of that core guideline is uh

4579
05:26:33,440 --> 05:26:36,400
includes uh nosql databases which a

4580
05:26:36,400 --> 05:26:38,878
component of that is mongodb so

4581
05:26:38,878 --> 05:26:41,760
india in particular has made a really

4582
05:26:41,760 --> 05:26:44,878
deep investment and commitment to

4583
05:26:44,878 --> 05:26:46,320
you know technology

4584
05:26:46,320 --> 05:26:48,080
education for the

4585
05:26:48,080 --> 05:26:51,040
you know for the students

4586
05:26:51,680 --> 05:26:53,920
in addition to the database there's a

4587
05:26:53,920 --> 05:26:57,040
managed database service which is where

4588
05:26:57,040 --> 05:26:59,600
uh the majority of uh the company gets

4589
05:26:59,600 --> 05:27:01,840
its its revenue these days

4590
05:27:01,840 --> 05:27:04,160
we actively today operate about two and

4591
05:27:04,160 --> 05:27:05,840
a half million clusters around the world

4592
05:27:05,840 --> 05:27:07,760
from 200 data centers on every major

4593
05:27:07,760 --> 05:27:09,120
cloud platform

4594
05:27:09,120 --> 05:27:11,920
obviously amazon gcp and azure are the

4595
05:27:11,920 --> 05:27:16,798
popular ones but alibaba uh lots of um

4596
05:27:16,798 --> 05:27:18,480
you know a lot of platforms in europe as

4597
05:27:18,480 --> 05:27:20,718
well

4598
05:27:20,958 --> 05:27:24,080
while a lot of developers will do just a

4599
05:27:24,080 --> 05:27:27,360
very basic uh kind of hello world

4600
05:27:27,360 --> 05:27:29,440
demo or a toy app or something for like

4601
05:27:29,440 --> 05:27:32,558
a really low uh traffic type site we do

4602
05:27:32,558 --> 05:27:36,000
have uh instances in

4603
05:27:36,000 --> 05:27:37,600
in different markets where people will

4604
05:27:37,600 --> 05:27:38,638
run

4605
05:27:38,638 --> 05:27:42,080
on a live current production database

4606
05:27:42,080 --> 05:27:44,878
a single cluster where

4607
05:27:44,878 --> 05:27:46,798
different data bearing nodes exist in

4608
05:27:46,798 --> 05:27:50,320
gcp in azure and aws concurrently and

4609
05:27:50,320 --> 05:27:52,320
multi-charted so we're talking you know

4610
05:27:52,320 --> 05:27:55,280
seven 800 shards across

4611
05:27:55,280 --> 05:27:57,840
uh many hundreds of instances for a

4612
05:27:57,840 --> 05:28:00,480
single database so really you know it's

4613
05:28:00,480 --> 05:28:02,080
kind of a staggering scale

4614
05:28:02,080 --> 05:28:04,160
uh we have a really close partnership

4615
05:28:04,160 --> 05:28:08,320
with let's encrypt for our noted node uh

4616
05:28:08,320 --> 05:28:11,360
authentication and for application to uh

4617
05:28:11,360 --> 05:28:12,480
database

4618
05:28:12,480 --> 05:28:16,160
uh identity uh we generate uh actually i

4619
05:28:16,160 --> 05:28:18,000
think this is in the last year over a

4620
05:28:18,000 --> 05:28:21,280
hundred million uh serves

4621
05:28:21,280 --> 05:28:22,638
financials so

4622
05:28:22,638 --> 05:28:24,080
um

4623
05:28:24,080 --> 05:28:25,440
i think there's this

4624
05:28:25,440 --> 05:28:28,718
notion i think that a lot of people that

4625
05:28:28,718 --> 05:28:30,638
that nosql database is kind of popular

4626
05:28:30,638 --> 05:28:31,600
and

4627
05:28:31,600 --> 05:28:34,320
kind of the tech startup world or like

4628
05:28:34,320 --> 05:28:35,920
for small projects i don't think there's

4629
05:28:35,920 --> 05:28:38,638
quite an appreciation how far this

4630
05:28:38,638 --> 05:28:40,000
type of technology has gotten into the

4631
05:28:40,000 --> 05:28:41,760
enterprise so

4632
05:28:41,760 --> 05:28:43,280
the largest investment banks in the

4633
05:28:43,280 --> 05:28:44,240
world

4634
05:28:44,240 --> 05:28:45,440
the largest

4635
05:28:45,440 --> 05:28:48,320
retail banks payment networks bank to

4636
05:28:48,320 --> 05:28:50,638
make transfer systems treasury systems

4637
05:28:50,638 --> 05:28:52,160
uh payment platforms settlement

4638
05:28:52,160 --> 05:28:54,718
platforms they're running this tech uh

4639
05:28:54,718 --> 05:28:56,160
healthcare the biggest

4640
05:28:56,160 --> 05:28:57,920
uh healthcare companies in the u.s and

4641
05:28:57,920 --> 05:29:00,400
in europe uh are using this as well

4642
05:29:00,400 --> 05:29:03,120
retail tech gaming is one of these

4643
05:29:03,120 --> 05:29:04,718
things that sort of scratched my head

4644
05:29:04,718 --> 05:29:06,558
when i first heard that use case because

4645
05:29:06,558 --> 05:29:08,718
i'm like i'm not personally into gaming

4646
05:29:08,718 --> 05:29:10,798
but that's kind of interesting you know

4647
05:29:10,798 --> 05:29:12,240
we're talking about multi-billion dollar

4648
05:29:12,240 --> 05:29:14,798
franchises like fortnite you know really

4649
05:29:14,798 --> 05:29:17,520
uh you know that are that are generating

4650
05:29:17,520 --> 05:29:19,040
massive amounts of

4651
05:29:19,040 --> 05:29:20,320
revenue and traffic for some of these

4652
05:29:20,320 --> 05:29:23,120
companies uh travel so this is uh hotel

4653
05:29:23,120 --> 05:29:25,440
airlines these are core systems these

4654
05:29:25,440 --> 05:29:26,480
are core

4655
05:29:26,480 --> 05:29:28,840
uh operational systems uh for these

4656
05:29:28,840 --> 05:29:30,798
customers

4657
05:29:30,798 --> 05:29:33,760
i wanted to show a couple slides um that

4658
05:29:33,760 --> 05:29:36,160
we typically present to customers

4659
05:29:36,160 --> 05:29:38,080
not because i think anything here is

4660
05:29:38,080 --> 05:29:40,320
sort of surprising uh to people in this

4661
05:29:40,320 --> 05:29:44,160
room but it's it's worth emphasizing uh

4662
05:29:44,160 --> 05:29:45,600
i think some of the disconnect or some

4663
05:29:45,600 --> 05:29:48,080
of the um what misconceptions in the

4664
05:29:48,080 --> 05:29:50,718
industry and i'm talking even by csos

4665
05:29:50,718 --> 05:29:51,760
and by

4666
05:29:51,760 --> 05:29:55,120
uh sometimes really seasoned uh info uh

4667
05:29:55,120 --> 05:29:57,200
input uh professionals

4668
05:29:57,200 --> 05:30:00,240
so we know that tls is meant to protect

4669
05:30:00,240 --> 05:30:02,638
uh you know eavesdropping

4670
05:30:02,638 --> 05:30:04,160
to an awful lot of people in the world

4671
05:30:04,160 --> 05:30:06,240
including a lot of people who are kind

4672
05:30:06,240 --> 05:30:09,040
of in positions of decision making

4673
05:30:09,040 --> 05:30:10,000
uh

4674
05:30:10,000 --> 05:30:12,718
there's this notion that tls uh has

4675
05:30:12,718 --> 05:30:14,878
something to do with the data that's

4676
05:30:14,878 --> 05:30:19,760
actually in a data store um and

4677
05:30:19,840 --> 05:30:20,798
no

4678
05:30:20,798 --> 05:30:22,798
no quite appreciation of while it's an

4679
05:30:22,798 --> 05:30:24,320
important control it's very limited and

4680
05:30:24,320 --> 05:30:26,400
what its security claims are

4681
05:30:26,400 --> 05:30:29,440
are much uh you know smaller in scope i

4682
05:30:29,440 --> 05:30:31,840
think than what's often understood this

4683
05:30:31,840 --> 05:30:33,440
is particularly true with at rest

4684
05:30:33,440 --> 05:30:34,878
encryption

4685
05:30:34,878 --> 05:30:37,120
i can't tell you how many conversations

4686
05:30:37,120 --> 05:30:38,480
we have with people who should know a

4687
05:30:38,480 --> 05:30:40,558
lot better who have this sort of vague

4688
05:30:40,558 --> 05:30:42,878
mental model that at rest encryption

4689
05:30:42,878 --> 05:30:45,120
protects them from hackers

4690
05:30:45,120 --> 05:30:46,000
meaning

4691
05:30:46,000 --> 05:30:47,680
online attacks meaning criminal black

4692
05:30:47,680 --> 05:30:49,760
hats meaning you know

4693
05:30:49,760 --> 05:30:52,000
interesting active live attacks

4694
05:30:52,000 --> 05:30:52,958
and so

4695
05:30:52,958 --> 05:30:54,480
sometimes we have to gently break it to

4696
05:30:54,480 --> 05:30:56,878
people that you know the you know the

4697
05:30:56,878 --> 05:30:58,320
protections that are reported by whole

4698
05:30:58,320 --> 05:30:59,840
disk encryption

4699
05:30:59,840 --> 05:31:03,120
are really useful when you um you know

4700
05:31:03,120 --> 05:31:05,120
uh terminate an instance in the cloud

4701
05:31:05,120 --> 05:31:07,200
and the next customer comes along or in

4702
05:31:07,200 --> 05:31:09,200
a smaller you know

4703
05:31:09,200 --> 05:31:10,718
like a data center context or something

4704
05:31:10,718 --> 05:31:12,878
like that if a server's retired

4705
05:31:12,878 --> 05:31:14,958
yeah you know it's it's a useful control

4706
05:31:14,958 --> 05:31:16,638
to make sure that you know if a hard

4707
05:31:16,638 --> 05:31:17,680
drive is

4708
05:31:17,680 --> 05:31:18,718
you know

4709
05:31:18,718 --> 05:31:20,320
eventually ends up in a storage room or

4710
05:31:20,320 --> 05:31:21,920
on ebay or craigslist or something then

4711
05:31:21,920 --> 05:31:23,520
you're data protected that's you know

4712
05:31:23,520 --> 05:31:25,120
it's it's a tiny

4713
05:31:25,120 --> 05:31:27,200
it's important control and if it's you

4714
05:31:27,200 --> 05:31:28,638
know in the context of a laptop or like

4715
05:31:28,638 --> 05:31:31,360
developer uh sorry for analysts working

4716
05:31:31,360 --> 05:31:34,000
on say healthcare data if that

4717
05:31:34,000 --> 05:31:36,958
machine is lost or stolen it's it's

4718
05:31:36,958 --> 05:31:38,000
great that it's got whole volume

4719
05:31:38,000 --> 05:31:39,120
encryption right that's an important

4720
05:31:39,120 --> 05:31:41,600
thing but none of those things transfer

4721
05:31:41,600 --> 05:31:42,558
to

4722
05:31:42,558 --> 05:31:44,878
my system's been online for three years

4723
05:31:44,878 --> 05:31:46,558
but i've got at rest encryption so i'm

4724
05:31:46,558 --> 05:31:47,920
good

4725
05:31:47,920 --> 05:31:50,000
there's just not a mental notion i think

4726
05:31:50,000 --> 05:31:51,840
among a lot of people in the security

4727
05:31:51,840 --> 05:31:54,638
world even uh that you know

4728
05:31:54,638 --> 05:31:56,240
where that you know where that

4729
05:31:56,240 --> 05:31:59,120
limitation sort of ends

4730
05:31:59,120 --> 05:32:00,080
um

4731
05:32:00,080 --> 05:32:01,520
with respect to

4732
05:32:01,520 --> 05:32:03,440
uh the the work that we're talking about

4733
05:32:03,440 --> 05:32:04,798
today

4734
05:32:04,798 --> 05:32:06,400
there's also a lot of misunderstanding

4735
05:32:06,400 --> 05:32:08,000
about uh

4736
05:32:08,000 --> 05:32:10,558
you know encryption and use

4737
05:32:10,558 --> 05:32:12,798
from our perspective

4738
05:32:12,798 --> 05:32:14,798
most users and customers care about

4739
05:32:14,798 --> 05:32:17,040
things like insider access right if

4740
05:32:17,040 --> 05:32:19,440
you've got a an hr system

4741
05:32:19,440 --> 05:32:20,958
for example

4742
05:32:20,958 --> 05:32:23,840
uh that has employees uh payroll data or

4743
05:32:23,840 --> 05:32:25,920
their insurance data things like this

4744
05:32:25,920 --> 05:32:28,400
it's true that the dba that administers

4745
05:32:28,400 --> 05:32:30,878
that and backs it up you know does

4746
05:32:30,878 --> 05:32:32,480
patching and things like that

4747
05:32:32,480 --> 05:32:34,240
you know they need access but they

4748
05:32:34,240 --> 05:32:36,240
really need access to your routing

4749
05:32:36,240 --> 05:32:38,320
number and your you know

4750
05:32:38,320 --> 05:32:40,718
your healthcare uh information and the

4751
05:32:40,718 --> 05:32:44,400
answer is probably no and so for

4752
05:32:44,400 --> 05:32:47,040
really the majority of uh companies in

4753
05:32:47,040 --> 05:32:48,480
the world

4754
05:32:48,480 --> 05:32:50,320
there's there's not anything near the

4755
05:32:50,320 --> 05:32:52,558
kind of level of fine grain control and

4756
05:32:52,558 --> 05:32:55,360
and sort of uh separation concerns as as

4757
05:32:55,360 --> 05:32:57,280
you might imagine so we do have a lot of

4758
05:32:57,280 --> 05:33:00,400
customers that are concerned about

4759
05:33:00,400 --> 05:33:02,400
potential insight attacks but also just

4760
05:33:02,400 --> 05:33:05,040
misconfiguration either malicious or

4761
05:33:05,040 --> 05:33:06,878
unintentional and the same with service

4762
05:33:06,878 --> 05:33:09,760
providers right when you're on the cloud

4763
05:33:09,760 --> 05:33:11,360
whoever is

4764
05:33:11,360 --> 05:33:12,480
managing

4765
05:33:12,480 --> 05:33:15,200
a managed database you know

4766
05:33:15,200 --> 05:33:16,000
that

4767
05:33:16,000 --> 05:33:18,240
those people can get access to

4768
05:33:18,240 --> 05:33:19,120
uh

4769
05:33:19,120 --> 05:33:21,440
potential hypervisors could potentially

4770
05:33:21,440 --> 05:33:24,160
you know live memory um can do things

4771
05:33:24,160 --> 05:33:26,718
like process inspection

4772
05:33:26,718 --> 05:33:29,200
and it's it's not only limited to

4773
05:33:29,200 --> 05:33:31,360
uh kind of uh

4774
05:33:31,360 --> 05:33:33,600
traditional adversaries but customers

4775
05:33:33,600 --> 05:33:36,718
are increasingly concerned about um

4776
05:33:36,718 --> 05:33:38,160
sort of uh

4777
05:33:38,160 --> 05:33:39,520
lawful order

4778
05:33:39,520 --> 05:33:41,360
uh seizures and things of this sort it's

4779
05:33:41,360 --> 05:33:43,200
particularly concerning to a lot of

4780
05:33:43,200 --> 05:33:45,040
european customers

4781
05:33:45,040 --> 05:33:46,320
gdpr

4782
05:33:46,320 --> 05:33:49,040
etc there's a notion that when you know

4783
05:33:49,040 --> 05:33:51,120
when i want data destroyed because the

4784
05:33:51,120 --> 05:33:54,000
project's over or a user you know

4785
05:33:54,000 --> 05:33:55,680
discontinues the service we really want

4786
05:33:55,680 --> 05:33:57,120
to end that

4787
05:33:57,120 --> 05:34:00,399
you know in that access

4788
05:34:00,638 --> 05:34:01,920
but

4789
05:34:01,920 --> 05:34:05,040
what you have in most contexts now for

4790
05:34:05,040 --> 05:34:06,080
services

4791
05:34:06,080 --> 05:34:07,600
and

4792
05:34:07,600 --> 05:34:08,718
you know commercial open source

4793
05:34:08,718 --> 05:34:11,120
databases largely is

4794
05:34:11,120 --> 05:34:13,280
this um

4795
05:34:13,280 --> 05:34:15,280
we have really strong administrative

4796
05:34:15,280 --> 05:34:17,760
controls right we people will get in in

4797
05:34:17,760 --> 05:34:19,200
trouble if they get fired they'll go to

4798
05:34:19,200 --> 05:34:20,080
jail

4799
05:34:20,080 --> 05:34:22,240
if they snoop on your data well those

4800
05:34:22,240 --> 05:34:23,920
are good things i guess but they're not

4801
05:34:23,920 --> 05:34:25,280
they're not very convincing to someone

4802
05:34:25,280 --> 05:34:27,680
who's moving uh the kind of money that

4803
05:34:27,680 --> 05:34:29,360
you know a global investment bank is

4804
05:34:29,360 --> 05:34:32,160
moving for example

4805
05:34:32,320 --> 05:34:34,240
so what are some of the use cases uh

4806
05:34:34,240 --> 05:34:35,760
specifically for encrypted search we

4807
05:34:35,760 --> 05:34:38,240
know that uh it's useful obviously to

4808
05:34:38,240 --> 05:34:40,000
have a capability to do

4809
05:34:40,000 --> 05:34:41,280
client-side encryption and then

4810
05:34:41,280 --> 05:34:42,878
encryption itself

4811
05:34:42,878 --> 05:34:43,920
um

4812
05:34:43,920 --> 05:34:45,760
and when we started some of this work

4813
05:34:45,760 --> 05:34:49,120
four years ago there's no shortage of

4814
05:34:49,120 --> 05:34:50,878
um

4815
05:34:50,878 --> 05:34:54,080
you know the platform specific apis uh

4816
05:34:54,080 --> 05:34:55,680
or sorry a software development gets

4817
05:34:55,680 --> 05:34:57,440
sdks that you could plug in

4818
05:34:57,440 --> 05:34:59,120
that would say okay i've got a social

4819
05:34:59,120 --> 05:35:00,400
security number i've got a credit card

4820
05:35:00,400 --> 05:35:01,600
number a mobile phone number some other

4821
05:35:01,600 --> 05:35:02,958
kind of pii

4822
05:35:02,958 --> 05:35:04,558
and i'm going to encrypt that

4823
05:35:04,558 --> 05:35:06,400
sort of a standard conventional way and

4824
05:35:06,400 --> 05:35:07,440
then i'm going to step that into the

4825
05:35:07,440 --> 05:35:08,480
database

4826
05:35:08,480 --> 05:35:09,920
you can do that on every major cloud

4827
05:35:09,920 --> 05:35:12,958
platform you do it on on most of the

4828
05:35:12,958 --> 05:35:14,638
popular databases

4829
05:35:14,638 --> 05:35:16,718
but two things about that one is they're

4830
05:35:16,718 --> 05:35:18,320
an add-on

4831
05:35:18,320 --> 05:35:20,638
and the other is that largely and by and

4832
05:35:20,638 --> 05:35:22,878
large and i don't mean like if there's

4833
05:35:22,878 --> 05:35:25,840
one github repository somewhere one

4834
05:35:25,840 --> 05:35:28,160
uh sort of code sample

4835
05:35:28,160 --> 05:35:30,000
in the academic world i mean like you

4836
05:35:30,000 --> 05:35:33,040
know a really popular in the developer

4837
05:35:33,040 --> 05:35:35,120
ecosystem of being able to end in

4838
05:35:35,120 --> 05:35:36,080
encryption

4839
05:35:36,080 --> 05:35:37,920
largely speaking

4840
05:35:37,920 --> 05:35:39,760
those options are

4841
05:35:39,760 --> 05:35:41,760
i'm going to take a piece you know a

4842
05:35:41,760 --> 05:35:44,000
string or an end to a date i'm going to

4843
05:35:44,000 --> 05:35:46,000
aes encrypted i'm going to step into

4844
05:35:46,000 --> 05:35:47,280
database

4845
05:35:47,280 --> 05:35:48,480
figure out how to get it back out

4846
05:35:48,480 --> 05:35:49,600
because you're not going to search for

4847
05:35:49,600 --> 05:35:52,558
it but know that it's you know it's it's

4848
05:35:52,558 --> 05:35:55,360
reasonably uh more secure than it was if

4849
05:35:55,360 --> 05:35:58,320
it's just plain text

4850
05:35:58,320 --> 05:36:01,040
and you'd be amazed at the homebrew

4851
05:36:01,040 --> 05:36:03,760
solutions that uh even even some large

4852
05:36:03,760 --> 05:36:05,920
healthcare and and bank companies have

4853
05:36:05,920 --> 05:36:08,798
come up with to sort of try to do uh

4854
05:36:08,798 --> 05:36:10,400
encrypted search

4855
05:36:10,400 --> 05:36:12,558
one of the things that i uh didn't quite

4856
05:36:12,558 --> 05:36:14,160
appreciate until the last few years is

4857
05:36:14,160 --> 05:36:15,040
that

4858
05:36:15,040 --> 05:36:16,958
it's just the scope of some

4859
05:36:16,958 --> 05:36:19,440
organization's internal engineering

4860
05:36:19,440 --> 05:36:20,480
resources

4861
05:36:20,480 --> 05:36:21,920
so there is a

4862
05:36:21,920 --> 05:36:24,160
let's say top five uh bank in north

4863
05:36:24,160 --> 05:36:25,680
america

4864
05:36:25,680 --> 05:36:28,160
the bank itself has over 10 000 software

4865
05:36:28,160 --> 05:36:30,718
developers working for bank 10 000

4866
05:36:30,718 --> 05:36:32,958
and so there's an awful lot of smart

4867
05:36:32,958 --> 05:36:34,878
creative motivated people

4868
05:36:34,878 --> 05:36:36,638
none of them are cryptographers by and

4869
05:36:36,638 --> 05:36:37,920
large and

4870
05:36:37,920 --> 05:36:40,878
uh you know all kinds of interesting

4871
05:36:40,878 --> 05:36:42,400
schemes or

4872
05:36:42,400 --> 05:36:45,120
you know techniques have been uh

4873
05:36:45,120 --> 05:36:48,080
units were put in place which are

4874
05:36:48,080 --> 05:36:50,240
frightening to people who have a formal

4875
05:36:50,240 --> 05:36:52,798
background in crypto

4876
05:36:52,798 --> 05:36:54,080
in our case

4877
05:36:54,080 --> 05:36:55,440
we had large customers coming to us

4878
05:36:55,440 --> 05:36:57,280
saying look we've got customer support

4879
05:36:57,280 --> 05:37:00,718
people uh that need to search massive

4880
05:37:00,718 --> 05:37:03,360
databases and there's no need for the

4881
05:37:03,360 --> 05:37:05,280
database to have clear text in fact

4882
05:37:05,280 --> 05:37:06,240
through

4883
05:37:06,240 --> 05:37:08,400
regulatory obligations we can't store

4884
05:37:08,400 --> 05:37:09,760
what's called pans

4885
05:37:09,760 --> 05:37:11,760
payment numbers basically card numbers

4886
05:37:11,760 --> 05:37:14,000
and expiration dates we can't just store

4887
05:37:14,000 --> 05:37:15,360
that in the database

4888
05:37:15,360 --> 05:37:17,840
uh and you know we'd like to be able to

4889
05:37:17,840 --> 05:37:20,400
have customer support agents search by

4890
05:37:20,400 --> 05:37:22,160
uh last four digits of social security

4891
05:37:22,160 --> 05:37:23,840
number for example or part of the

4892
05:37:23,840 --> 05:37:28,080
payment number or uh you know i'm i'm a

4893
05:37:28,080 --> 05:37:30,320
major retail bank and i want to

4894
05:37:30,320 --> 05:37:32,000
look at fraud analysis

4895
05:37:32,000 --> 05:37:32,878
but

4896
05:37:32,878 --> 05:37:35,680
uh you know i

4897
05:37:35,680 --> 05:37:37,520
i just can't have

4898
05:37:37,520 --> 05:37:39,520
this level of information outsourced

4899
05:37:39,520 --> 05:37:41,840
from our own data centers to a third

4900
05:37:41,840 --> 05:37:45,200
party to a cloud provider

4901
05:37:45,360 --> 05:37:47,680
healthcare as well so

4902
05:37:47,680 --> 05:37:48,878
people have

4903
05:37:48,878 --> 05:37:50,480
uh

4904
05:37:50,480 --> 05:37:52,718
you know the the name space for

4905
05:37:52,718 --> 05:37:56,080
uh human beings names is is massive and

4906
05:37:56,080 --> 05:37:58,558
so if you're on the phone with someone

4907
05:37:58,558 --> 05:37:59,440
uh

4908
05:37:59,440 --> 05:38:00,240
and

4909
05:38:00,240 --> 05:38:02,480
you're you're trying to dictate uh you

4910
05:38:02,480 --> 05:38:04,718
know name it turns out this is a

4911
05:38:04,718 --> 05:38:06,718
really big problem that people would

4912
05:38:06,718 --> 05:38:08,878
like to to deal with um

4913
05:38:08,878 --> 05:38:11,840
so that you can do things like uh safely

4914
05:38:11,840 --> 05:38:14,320
store mobile numbers safely store

4915
05:38:14,320 --> 05:38:18,079
uh names and other information

4916
05:38:18,240 --> 05:38:18,958
so

4917
05:38:18,958 --> 05:38:20,558
the

4918
05:38:20,558 --> 05:38:22,878
i'm sort of skipping through uh about

4919
05:38:22,878 --> 05:38:26,878
two years of development uh but

4920
05:38:27,920 --> 05:38:29,680
part of the story is

4921
05:38:29,680 --> 05:38:30,718
um

4922
05:38:30,718 --> 05:38:33,760
we had a technique to do

4923
05:38:33,760 --> 05:38:35,280
randomized encryption in the database

4924
05:38:35,280 --> 05:38:38,320
that zeni and three helped us uh sort of

4925
05:38:38,320 --> 05:38:40,558
think through the uh security properties

4926
05:38:40,558 --> 05:38:41,920
of that we worked with kenny patterson

4927
05:38:41,920 --> 05:38:43,440
and jp amazon

4928
05:38:43,440 --> 05:38:44,558
back in

4929
05:38:44,558 --> 05:38:46,400
2018 2019

4930
05:38:46,400 --> 05:38:49,120
and that was really useful we were well

4931
05:38:49,120 --> 05:38:51,360
aware of some of the limitations of

4932
05:38:51,360 --> 05:38:52,718
property preserving encryption of

4933
05:38:52,718 --> 05:38:54,558
deterministic search and so what we

4934
05:38:54,558 --> 05:38:57,120
wanted to do was to understand well you

4935
05:38:57,120 --> 05:38:58,160
know

4936
05:38:58,160 --> 05:39:00,798
if someone wanted to use

4937
05:39:00,798 --> 05:39:03,760
a high cardinality

4938
05:39:03,760 --> 05:39:05,760
type value like credit card number like

4939
05:39:05,760 --> 05:39:07,520
social security number what what does

4940
05:39:07,520 --> 05:39:08,798
the leakage look like what does that

4941
05:39:08,798 --> 05:39:10,320
mean what what are the actual trade-offs

4942
05:39:10,320 --> 05:39:11,360
and risks

4943
05:39:11,360 --> 05:39:13,760
because as much as we obsess about uh

4944
05:39:13,760 --> 05:39:14,718
the things that we're talking about

4945
05:39:14,718 --> 05:39:16,718
today and and obviously i think they're

4946
05:39:16,718 --> 05:39:18,798
crucially important

4947
05:39:18,798 --> 05:39:19,600
uh

4948
05:39:19,600 --> 05:39:21,440
in in sort of a

4949
05:39:21,440 --> 05:39:24,480
a real risk context they're they're

4950
05:39:24,480 --> 05:39:26,080
they're often much further down the list

4951
05:39:26,080 --> 05:39:26,878
than

4952
05:39:26,878 --> 05:39:28,958
uh what is your application server doing

4953
05:39:28,958 --> 05:39:30,958
right so if you've got a healthcare app

4954
05:39:30,958 --> 05:39:34,718
or a you know web service for mobile api

4955
05:39:34,718 --> 05:39:37,040
you can have the the most elegant high

4956
05:39:37,040 --> 05:39:39,520
performance you know perfect trade-off

4957
05:39:39,520 --> 05:39:41,120
uh schemes on the database side on the

4958
05:39:41,120 --> 05:39:43,200
server side as possible but if the

4959
05:39:43,200 --> 05:39:45,040
application side has

4960
05:39:45,040 --> 05:39:47,680
a really you know

4961
05:39:47,680 --> 05:39:49,920
you know poorly engineered out of date

4962
05:39:49,920 --> 05:39:52,240
you know what python or node library

4963
05:39:52,240 --> 05:39:55,200
that's got known exploits or or a java

4964
05:39:55,200 --> 05:39:57,200
middleware we see this all the time with

4965
05:39:57,200 --> 05:39:59,760
uh you know major financial systems or

4966
05:39:59,760 --> 05:40:00,798
uh

4967
05:40:00,798 --> 05:40:03,200
hr systems where it's like

4968
05:40:03,200 --> 05:40:04,480
you've got to use

4969
05:40:04,480 --> 05:40:06,958
tls1 and some ancient version of java

4970
05:40:06,958 --> 05:40:09,520
that's not even supported anymore uh and

4971
05:40:09,520 --> 05:40:12,320
and those are by the way internet facing

4972
05:40:12,320 --> 05:40:13,280
so

4973
05:40:13,280 --> 05:40:14,638
you know we have to be very careful

4974
05:40:14,638 --> 05:40:17,520
about uh when we speak to to security

4975
05:40:17,520 --> 05:40:19,840
teams about that entire

4976
05:40:19,840 --> 05:40:20,798
kind of

4977
05:40:20,798 --> 05:40:21,920
end-to-end

4978
05:40:21,920 --> 05:40:22,878
uh

4979
05:40:22,878 --> 05:40:24,240
you know uh

4980
05:40:24,240 --> 05:40:26,320
threat surface you know where where do

4981
05:40:26,320 --> 05:40:28,558
you focus things it turns out that a lot

4982
05:40:28,558 --> 05:40:30,000
of the sort of one-on-one things you

4983
05:40:30,000 --> 05:40:31,760
would assume are in place just aren't

4984
05:40:31,760 --> 05:40:33,440
right uh

4985
05:40:33,440 --> 05:40:35,120
you know

4986
05:40:35,120 --> 05:40:36,000
really

4987
05:40:36,000 --> 05:40:38,878
a strict key segregation really um

4988
05:40:38,878 --> 05:40:41,680
strong uh federated identity not using

4989
05:40:41,680 --> 05:40:44,638
long-term uh access tokens for service

4990
05:40:44,638 --> 05:40:46,160
accounts things like this using uh

4991
05:40:46,160 --> 05:40:48,080
short-lived barrier token uh you know

4992
05:40:48,080 --> 05:40:50,638
processions things like this

4993
05:40:50,638 --> 05:40:54,400
we emphasize this uh this technology is

4994
05:40:54,400 --> 05:40:57,040
part of that broader picture right

4995
05:40:57,040 --> 05:40:59,280
because if a really well resourced

4996
05:40:59,280 --> 05:41:00,558
adversary is

4997
05:41:00,558 --> 05:41:01,440
um

4998
05:41:01,440 --> 05:41:03,360
you know out to get

4999
05:41:03,360 --> 05:41:05,360
you know certain data

5000
05:41:05,360 --> 05:41:07,360
often there are many many other ways

5001
05:41:07,360 --> 05:41:09,280
much easier much more trivial to get

5002
05:41:09,280 --> 05:41:10,558
than the kind of things that i think we

5003
05:41:10,558 --> 05:41:14,160
think about sometimes uh here

5004
05:41:14,160 --> 05:41:15,120
we

5005
05:41:15,120 --> 05:41:16,958
worked with

5006
05:41:16,958 --> 05:41:18,160
ceni and

5007
05:41:18,160 --> 05:41:19,920
tariq

5008
05:41:19,920 --> 05:41:22,320
it's probably about a year

5009
05:41:22,320 --> 05:41:25,120
year and a half worth of uh development

5010
05:41:25,120 --> 05:41:26,160
design

5011
05:41:26,160 --> 05:41:28,558
i think there were over

5012
05:41:28,558 --> 05:41:30,958
45 or 50 engineers that worked on this

5013
05:41:30,958 --> 05:41:34,400
over the period of time and remember

5014
05:41:34,400 --> 05:41:36,958
it's not just the core database

5015
05:41:36,958 --> 05:41:39,120
it's not just the queries it's not just

5016
05:41:39,120 --> 05:41:40,878
the crypto piece

5017
05:41:40,878 --> 05:41:43,760
we implemented this in every language

5018
05:41:43,760 --> 05:41:45,280
under the sun on all these different

5019
05:41:45,280 --> 05:41:47,760
operating systems and so there was an

5020
05:41:47,760 --> 05:41:50,320
enormous amount of work

5021
05:41:50,320 --> 05:41:53,360
early on just to make that work with our

5022
05:41:53,360 --> 05:41:55,040
drivers so that so that the end

5023
05:41:55,040 --> 05:41:57,760
developer could say for example insert

5024
05:41:57,760 --> 05:41:58,638
into

5025
05:41:58,638 --> 05:41:59,760
collection

5026
05:41:59,760 --> 05:42:01,440
social security number one to create

5027
05:42:01,440 --> 05:42:04,240
credit card number one two three search

5028
05:42:04,240 --> 05:42:06,320
and they didn't have to call some sdk

5029
05:42:06,320 --> 05:42:07,840
they didn't have to call these complex

5030
05:42:07,840 --> 05:42:09,920
helper functions or things like that

5031
05:42:09,920 --> 05:42:13,120
um that was an enormous amount of work

5032
05:42:13,120 --> 05:42:15,920
but what the innovation was really

5033
05:42:15,920 --> 05:42:16,958
um

5034
05:42:16,958 --> 05:42:19,440
i think it was like the

5035
05:42:19,440 --> 05:42:22,400
i want to say summer of 2018. we had a

5036
05:42:22,400 --> 05:42:25,040
conversation with cindy intrigue

5037
05:42:25,040 --> 05:42:27,120
about some of the work they were doing

5038
05:42:27,120 --> 05:42:28,160
and

5039
05:42:28,160 --> 05:42:30,000
i think a few months earlier we'd sort

5040
05:42:30,000 --> 05:42:31,360
of sketched out some high level

5041
05:42:31,360 --> 05:42:33,840
possibilities of well how could you know

5042
05:42:33,840 --> 05:42:37,680
how could a structured encryption uh

5043
05:42:37,680 --> 05:42:40,240
you know scheme work in the context of

5044
05:42:40,240 --> 05:42:42,718
it should be the database

5045
05:42:42,718 --> 05:42:44,240
and we went through you know a couple

5046
05:42:44,240 --> 05:42:45,520
different scenarios and there was a

5047
05:42:45,520 --> 05:42:47,120
point where i realized

5048
05:42:47,120 --> 05:42:49,280
what we were talking about was

5049
05:42:49,280 --> 05:42:51,120
a model where there's sort of you know

5050
05:42:51,120 --> 05:42:54,160
one client and one database well that's

5051
05:42:54,160 --> 05:42:56,558
not my world right i mean

5052
05:42:56,558 --> 05:42:59,200
except the smallest um you know like a

5053
05:42:59,200 --> 05:43:00,798
blog site or like a really low traffic

5054
05:43:00,798 --> 05:43:02,480
site and there's plenty of those out

5055
05:43:02,480 --> 05:43:04,400
there i guess but that's not my rule my

5056
05:43:04,400 --> 05:43:07,600
world is you've got

5057
05:43:07,600 --> 05:43:09,520
dozens of application servers hitting

5058
05:43:09,520 --> 05:43:11,120
the same back end and you don't just

5059
05:43:11,120 --> 05:43:12,160
have one database you've got a

5060
05:43:12,160 --> 05:43:13,840
distributed database with lots of

5061
05:43:13,840 --> 05:43:16,400
cluster nodes around that you know uh

5062
05:43:16,400 --> 05:43:17,440
you know they're geographically

5063
05:43:17,440 --> 05:43:18,638
distributed

5064
05:43:18,638 --> 05:43:20,558
and

5065
05:43:20,558 --> 05:43:22,000
and and so we were talking and one of

5066
05:43:22,000 --> 05:43:24,558
the things that came up was well

5067
05:43:24,558 --> 05:43:26,240
there is a way to do this so that you've

5068
05:43:26,240 --> 05:43:27,680
got

5069
05:43:27,680 --> 05:43:29,920
an encrypted index or an encrypted cache

5070
05:43:29,920 --> 05:43:33,120
sort of on the application side and i

5071
05:43:33,120 --> 05:43:34,638
remember one of the questions i asked

5072
05:43:34,638 --> 05:43:37,039
was well

5073
05:43:38,000 --> 05:43:40,320
which application because we have

5074
05:43:40,320 --> 05:43:41,840
potentially dozens or hundreds or

5075
05:43:41,840 --> 05:43:44,320
thousands of consumers of this and

5076
05:43:44,320 --> 05:43:45,840
there's you know we sort of thought

5077
05:43:45,840 --> 05:43:47,440
about it for a little bit and and said

5078
05:43:47,440 --> 05:43:48,798
intrigue said well

5079
05:43:48,798 --> 05:43:51,200
we hadn't really thought about

5080
05:43:51,200 --> 05:43:53,200
you know i guess you could just have

5081
05:43:53,200 --> 05:43:55,680
separate caches across different uh you

5082
05:43:55,680 --> 05:43:57,920
know different end tiers and you just

5083
05:43:57,920 --> 05:44:00,000
need to sync those and and this should

5084
05:44:00,000 --> 05:44:02,958
be straightforward and it's like

5085
05:44:03,600 --> 05:44:06,000
developers have a hard enough time with

5086
05:44:06,000 --> 05:44:07,600
the very basics

5087
05:44:07,600 --> 05:44:09,120
trying to make a distributed cache

5088
05:44:09,120 --> 05:44:10,240
system

5089
05:44:10,240 --> 05:44:11,280
across

5090
05:44:11,280 --> 05:44:13,280
an arbitrary number of of consuming

5091
05:44:13,280 --> 05:44:15,040
nodes and

5092
05:44:15,040 --> 05:44:17,520
in a context where by the way networks

5093
05:44:17,520 --> 05:44:19,600
are really flaky network connections die

5094
05:44:19,600 --> 05:44:20,798
session connections die session

5095
05:44:20,798 --> 05:44:23,680
connections die halfway through you have

5096
05:44:23,680 --> 05:44:25,280
yes we have acid transactions in the

5097
05:44:25,280 --> 05:44:27,280
database and so there's certain types of

5098
05:44:27,280 --> 05:44:28,400
things that you can guarantee that

5099
05:44:28,400 --> 05:44:30,558
atomic but other times

5100
05:44:30,558 --> 05:44:31,680
you can imagine there's a whole number

5101
05:44:31,680 --> 05:44:33,760
of operations where it just breaks it's

5102
05:44:33,760 --> 05:44:36,878
just ugly and messy but in any event we

5103
05:44:36,878 --> 05:44:38,718
can't start with model of single

5104
05:44:38,718 --> 05:44:40,400
consumer single database that's just not

5105
05:44:40,400 --> 05:44:41,680
the world

5106
05:44:41,680 --> 05:44:43,280
and so you know we chat a little bit

5107
05:44:43,280 --> 05:44:45,520
more and basically i think six months

5108
05:44:45,520 --> 05:44:48,320
later we were talking again uh

5109
05:44:48,320 --> 05:44:49,920
over coffee

5110
05:44:49,920 --> 05:44:51,840
and tariq sort of casually mentioned oh

5111
05:44:51,840 --> 05:44:53,200
yeah you don't have to do that anymore

5112
05:44:53,200 --> 05:44:55,600
we kind of came up with a

5113
05:44:55,600 --> 05:44:57,280
technique so that's not necessary

5114
05:44:57,280 --> 05:44:59,680
there's a way to store blinded state

5115
05:44:59,680 --> 05:45:02,160
essentially um so that

5116
05:45:02,160 --> 05:45:04,240
it sort of synced automatically

5117
05:45:04,240 --> 05:45:05,440
and

5118
05:45:05,440 --> 05:45:06,798
you know if you've ever made kind of

5119
05:45:06,798 --> 05:45:08,638
like a funny whistle or noise and a dog

5120
05:45:08,638 --> 05:45:09,920
kind of turns its head like this for a

5121
05:45:09,920 --> 05:45:12,080
second that was kind of our response

5122
05:45:12,080 --> 05:45:14,080
like well tell us more about that and so

5123
05:45:14,080 --> 05:45:15,520
they explained their

5124
05:45:15,520 --> 05:45:18,958
you know the technique and

5125
05:45:18,958 --> 05:45:20,798
basically fast forward

5126
05:45:20,798 --> 05:45:22,400
another six or eight months later and

5127
05:45:22,400 --> 05:45:24,558
they were now part of mongodb

5128
05:45:24,558 --> 05:45:27,680
uh and and we're officially uh

5129
05:45:27,680 --> 05:45:30,160
colleagues and co-workers so um you know

5130
05:45:30,160 --> 05:45:31,680
we're just thrilled about that piece of

5131
05:45:31,680 --> 05:45:34,480
it in addition so one of the things that

5132
05:45:34,480 --> 05:45:36,480
was announced uh in june i think some

5133
05:45:36,480 --> 05:45:39,520
people may have missed um

5134
05:45:39,520 --> 05:45:41,840
sending intrigue created an internal uh

5135
05:45:41,840 --> 05:45:43,360
advanced crypto research group inside

5136
05:45:43,360 --> 05:45:45,360
modern dvd so we're you know actively

5137
05:45:45,360 --> 05:45:47,760
recruiting uh other uh beach level

5138
05:45:47,760 --> 05:45:49,120
photographers to

5139
05:45:49,120 --> 05:45:52,240
to join the to join the work

5140
05:45:52,240 --> 05:45:54,400
what we released in january is kind of

5141
05:45:54,400 --> 05:45:56,000
our foundation for it's in public

5142
05:45:56,000 --> 05:45:57,200
preview now

5143
05:45:57,200 --> 05:45:59,120
but fundamentally it has a

5144
05:45:59,120 --> 05:46:01,840
structured encryption uh capability at

5145
05:46:01,840 --> 05:46:03,200
the core of it

5146
05:46:03,200 --> 05:46:06,400
we're supporting equality matches now

5147
05:46:06,400 --> 05:46:08,718
we're in the middle of

5148
05:46:08,718 --> 05:46:11,280
implementing encrypted brain searches

5149
05:46:11,280 --> 05:46:13,920
and then as we've announced publicly

5150
05:46:13,920 --> 05:46:16,400
we're we're also doing prefix

5151
05:46:16,400 --> 05:46:18,718
suffix and uh substring searches over

5152
05:46:18,718 --> 05:46:21,280
the coming months uh again in every

5153
05:46:21,280 --> 05:46:23,200
language every major programming

5154
05:46:23,200 --> 05:46:25,120
language uh

5155
05:46:25,120 --> 05:46:25,920
the

5156
05:46:25,920 --> 05:46:28,320
core uh crypto framework

5157
05:46:28,320 --> 05:46:30,878
is in a c-based library that's all open

5158
05:46:30,878 --> 05:46:32,958
source apache it's on github you can see

5159
05:46:32,958 --> 05:46:35,600
the updates live uh there are some

5160
05:46:35,600 --> 05:46:37,760
components that work uh on server side

5161
05:46:37,760 --> 05:46:40,718
but that source available as well um so

5162
05:46:40,718 --> 05:46:43,760
we're we're thrilled to be able to um

5163
05:46:43,760 --> 05:46:46,320
you know to sort of begin this this

5164
05:46:46,320 --> 05:46:48,240
journey but we've got so much more to go

5165
05:46:48,240 --> 05:46:51,120
um quick kind of summary of of the way

5166
05:46:51,120 --> 05:46:52,878
that we explain this and you'll have to

5167
05:46:52,878 --> 05:46:55,440
forgive me if i'm a little imprecise uh

5168
05:46:55,440 --> 05:46:57,360
by uh formal

5169
05:46:57,360 --> 05:46:59,600
cryptographic standards

5170
05:46:59,600 --> 05:47:03,040
the the the core security model is

5171
05:47:03,040 --> 05:47:05,920
snapshot secure

5172
05:47:05,920 --> 05:47:08,160
customers are concerned about

5173
05:47:08,160 --> 05:47:09,440
dbas

5174
05:47:09,440 --> 05:47:11,280
about assist admins that have root

5175
05:47:11,280 --> 05:47:12,840
access they're concerned about

5176
05:47:12,840 --> 05:47:16,958
uh cloud administrators and providers so

5177
05:47:16,958 --> 05:47:18,400
these are some of the security

5178
05:47:18,400 --> 05:47:20,240
assurances that we can make under the

5179
05:47:20,240 --> 05:47:22,320
scheme

5180
05:47:22,320 --> 05:47:24,558
uh i can i'll let you read this for

5181
05:47:24,558 --> 05:47:25,840
yourself but

5182
05:47:25,840 --> 05:47:27,440
sort of the standard things you would

5183
05:47:27,440 --> 05:47:29,120
expect

5184
05:47:29,120 --> 05:47:33,200
with cca secure on the payloads

5185
05:47:33,200 --> 05:47:36,240
the encrypted indexes are

5186
05:47:36,240 --> 05:47:37,840
the model is

5187
05:47:37,840 --> 05:47:40,240
adaptively multi-snapshot secure so

5188
05:47:40,240 --> 05:47:41,520
multiple

5189
05:47:41,520 --> 05:47:43,120
snapshots

5190
05:47:43,120 --> 05:47:45,360
in succession of

5191
05:47:45,360 --> 05:47:49,520
the encrypted database rnscope

5192
05:47:49,520 --> 05:47:50,400
the

5193
05:47:50,400 --> 05:47:52,480
core message payload so

5194
05:47:52,480 --> 05:47:54,558
like most databases there's i don't know

5195
05:47:54,558 --> 05:47:56,480
like a dozen primitive data structures

5196
05:47:56,480 --> 05:47:58,320
oh sorry

5197
05:47:58,320 --> 05:48:01,200
oh i thought you were raising your hand

5198
05:48:01,200 --> 05:48:04,000
thanks all right um

5199
05:48:04,000 --> 05:48:06,160
yeah so it's an authenticated scheme uh

5200
05:48:06,160 --> 05:48:09,200
pretty standard construction uh we

5201
05:48:09,200 --> 05:48:11,920
have a top level 96 byte key that's uh

5202
05:48:11,920 --> 05:48:14,240
composed of three sub keys

5203
05:48:14,240 --> 05:48:15,360
um

5204
05:48:15,360 --> 05:48:18,958
they're used for uh different uh

5205
05:48:18,958 --> 05:48:22,480
different elements as described here

5206
05:48:23,040 --> 05:48:25,520
key management this is something that i

5207
05:48:25,520 --> 05:48:27,200
think tends to really bore uh

5208
05:48:27,200 --> 05:48:29,520
cryptographers uh it's something that's

5209
05:48:29,520 --> 05:48:30,958
we probably have

5210
05:48:30,958 --> 05:48:33,200
ninety percent of our conversations with

5211
05:48:33,200 --> 05:48:36,080
our customers about because they really

5212
05:48:36,080 --> 05:48:38,638
uh they really really

5213
05:48:38,638 --> 05:48:39,600
want to

5214
05:48:39,600 --> 05:48:42,558
understand who has access to the keys uh

5215
05:48:42,558 --> 05:48:45,040
what those properties are

5216
05:48:45,040 --> 05:48:47,520
uh is their delegation involved right

5217
05:48:47,520 --> 05:48:49,520
because they're

5218
05:48:49,520 --> 05:48:50,958
there there's at least one other

5219
05:48:50,958 --> 05:48:54,320
commercial company that claims to do

5220
05:48:54,320 --> 05:48:55,920
a type of encrypted search but what

5221
05:48:55,920 --> 05:48:59,360
happens is you delegate a key to them

5222
05:48:59,360 --> 05:49:02,000
and they decrypt it in memory but don't

5223
05:49:02,000 --> 05:49:04,400
persist at server-side and so there's

5224
05:49:04,400 --> 05:49:06,878
this sort of waving notion that well we

5225
05:49:06,878 --> 05:49:08,480
can't really access those keys we can't

5226
05:49:08,480 --> 05:49:09,840
really access

5227
05:49:09,840 --> 05:49:11,600
the clear text except it's running in

5228
05:49:11,600 --> 05:49:13,840
clear text on you know

5229
05:49:13,840 --> 05:49:19,040
in in memory and uh you know in in cpu

5230
05:49:19,040 --> 05:49:21,680
that's not you know we think that's

5231
05:49:21,680 --> 05:49:23,200
that's not uh

5232
05:49:23,200 --> 05:49:24,638
we think it's a little disingenuous

5233
05:49:24,638 --> 05:49:25,600
actually

5234
05:49:25,600 --> 05:49:28,080
the database can't ever access the raw

5235
05:49:28,080 --> 05:49:30,080
key material we do use an envelope

5236
05:49:30,080 --> 05:49:31,600
encryption technique to protect the

5237
05:49:31,600 --> 05:49:34,480
field keys the actual individual fields

5238
05:49:34,480 --> 05:49:36,798
of the documents of the json structures

5239
05:49:36,798 --> 05:49:38,958
we store those encrypted on the database

5240
05:49:38,958 --> 05:49:39,920
just for

5241
05:49:39,920 --> 05:49:41,760
latency purposes

5242
05:49:41,760 --> 05:49:43,920
right if you if you've

5243
05:49:43,920 --> 05:49:45,440
done any kind of performance tuning you

5244
05:49:45,440 --> 05:49:46,718
may be aware

5245
05:49:46,718 --> 05:49:49,440
it's extremely expensive to make an

5246
05:49:49,440 --> 05:49:51,120
initial connection to a database right

5247
05:49:51,120 --> 05:49:52,480
you want to be limiting how many of

5248
05:49:52,480 --> 05:49:55,280
those unique and sort of isolated

5249
05:49:55,280 --> 05:49:58,239
connections are possible

5250
05:49:58,558 --> 05:50:00,400
a lot of people

5251
05:50:00,400 --> 05:50:02,400
who strangely

5252
05:50:02,400 --> 05:50:05,040
uh are running critical applications on

5253
05:50:05,040 --> 05:50:06,798
the cloud don't trust the cloud

5254
05:50:06,798 --> 05:50:08,638
providers or at least they want to

5255
05:50:08,638 --> 05:50:09,760
separate

5256
05:50:09,760 --> 05:50:10,638
uh

5257
05:50:10,638 --> 05:50:12,240
you know sort of

5258
05:50:12,240 --> 05:50:14,480
the application side from the

5259
05:50:14,480 --> 05:50:16,638
the database side so we actually have

5260
05:50:16,638 --> 05:50:18,400
customers that are running for example

5261
05:50:18,400 --> 05:50:20,400
uh payloads on aws but the keys are

5262
05:50:20,400 --> 05:50:22,480
managed on gcp or the keys are managed

5263
05:50:22,480 --> 05:50:25,280
on azure or they're some in-house hsm

5264
05:50:25,280 --> 05:50:28,160
uh hash core vaults uh super popular uh

5265
05:50:28,160 --> 05:50:30,480
we do have some banks that

5266
05:50:30,480 --> 05:50:32,718
um they don't trust

5267
05:50:32,718 --> 05:50:34,480
it's a it's an odd threat model but they

5268
05:50:34,480 --> 05:50:35,840
don't trust

5269
05:50:35,840 --> 05:50:38,558
uh their own application stack to

5270
05:50:38,558 --> 05:50:39,600
generate

5271
05:50:39,600 --> 05:50:43,680
uh reasonable uh you know uh

5272
05:50:43,680 --> 05:50:46,000
you know random data to do encryption

5273
05:50:46,000 --> 05:50:47,120
and so

5274
05:50:47,120 --> 05:50:47,840
uh

5275
05:50:47,840 --> 05:50:49,040
they generate

5276
05:50:49,040 --> 05:50:51,120
the key material inside an hsm and then

5277
05:50:51,120 --> 05:50:53,680
supply that to the application

5278
05:50:53,680 --> 05:50:54,958
it's a weird threat model because as i

5279
05:50:54,958 --> 05:50:56,480
said that you supply that to the

5280
05:50:56,480 --> 05:50:59,200
application right um

5281
05:50:59,200 --> 05:51:01,120
and so that's that's supported as well

5282
05:51:01,120 --> 05:51:02,400
and if you're just sort of just

5283
05:51:02,400 --> 05:51:03,760
experimenting and you just have a single

5284
05:51:03,760 --> 05:51:04,798
laptop that's not going to connect to

5285
05:51:04,798 --> 05:51:06,958
the internet you just want to you know

5286
05:51:06,958 --> 05:51:09,600
one apache or an nginx

5287
05:51:09,600 --> 05:51:12,320
or a go process connecting to you know

5288
05:51:12,320 --> 05:51:14,480
single database with just a local key

5289
05:51:14,480 --> 05:51:17,280
you can do that as well

5290
05:51:17,360 --> 05:51:18,798
um

5291
05:51:18,798 --> 05:51:20,878
i think there's probably nothing

5292
05:51:20,878 --> 05:51:22,400
new here

5293
05:51:22,400 --> 05:51:24,080
for people that are

5294
05:51:24,080 --> 05:51:25,360
sort of

5295
05:51:25,360 --> 05:51:27,440
in this world of

5296
05:51:27,440 --> 05:51:29,360
structural encryption around

5297
05:51:29,360 --> 05:51:32,160
for example multi-maps and so forth uh

5298
05:51:32,160 --> 05:51:35,680
we're in the process now of writing uh

5299
05:51:35,680 --> 05:51:37,440
we we call it a technical brief but it's

5300
05:51:37,440 --> 05:51:39,520
somewhere between

5301
05:51:39,520 --> 05:51:41,840
uh

5302
05:51:41,840 --> 05:51:43,680
it's somewhere between

5303
05:51:43,680 --> 05:51:45,280
a formal

5304
05:51:45,280 --> 05:51:48,240
uh description of the the scheme and

5305
05:51:48,240 --> 05:51:50,480
something that's sort of hand wavy and

5306
05:51:50,480 --> 05:51:52,558
like you know

5307
05:51:52,558 --> 05:51:54,480
c-level kind of like

5308
05:51:54,480 --> 05:51:56,160
if you really kind of want to understand

5309
05:51:56,160 --> 05:51:58,000
the the full flow from

5310
05:51:58,000 --> 05:52:01,600
uh application to storage to retrieval

5311
05:52:01,600 --> 05:52:03,200
and

5312
05:52:03,200 --> 05:52:04,400
you know

5313
05:52:04,400 --> 05:52:05,280
how

5314
05:52:05,280 --> 05:52:08,240
uh different keys are derived um how

5315
05:52:08,240 --> 05:52:11,520
they're stored how the indexes work etc

5316
05:52:11,520 --> 05:52:13,120
it turns out that that

5317
05:52:13,120 --> 05:52:15,440
is really really hard it's really really

5318
05:52:15,440 --> 05:52:16,638
hard to make that accessible and

5319
05:52:16,638 --> 05:52:18,718
approachable for developers but i think

5320
05:52:18,718 --> 05:52:21,878
it's crucial

5321
05:52:22,000 --> 05:52:24,160
uh so just quickly this is um sort of

5322
05:52:24,160 --> 05:52:26,400
what it looks like from the

5323
05:52:26,400 --> 05:52:29,440
uh 20 000 foot view if for example you

5324
05:52:29,440 --> 05:52:31,360
insert a social security number the

5325
05:52:31,360 --> 05:52:33,680
application will see that the drivers

5326
05:52:33,680 --> 05:52:35,120
will automatically know well it's this

5327
05:52:35,120 --> 05:52:36,320
particular field has been tagged is

5328
05:52:36,320 --> 05:52:40,320
encrypted we're going to encrypt it uh

5329
05:52:40,320 --> 05:52:43,120
pass it along uh the driver transforms

5330
05:52:43,120 --> 05:52:45,840
that into an encrypted search key

5331
05:52:45,840 --> 05:52:48,718
all the records are stored uh encrypted

5332
05:52:48,718 --> 05:52:51,280
with um

5333
05:52:51,280 --> 05:52:52,638
what's represented here is the same

5334
05:52:52,638 --> 05:52:54,400
social security number in in three

5335
05:52:54,400 --> 05:52:55,760
different uh

5336
05:52:55,760 --> 05:52:56,958
you know three different records is

5337
05:52:56,958 --> 05:52:59,040
stored differently

5338
05:52:59,040 --> 05:53:01,760
uh what this looks like from a dba's

5339
05:53:01,760 --> 05:53:03,360
panel so this is something we call the

5340
05:53:03,360 --> 05:53:05,200
the compass viewer this is looking at an

5341
05:53:05,200 --> 05:53:06,878
individual record this is all

5342
05:53:06,878 --> 05:53:08,958
fake test data

5343
05:53:08,958 --> 05:53:11,760
for uh you know dbas that don't have

5344
05:53:11,760 --> 05:53:13,440
access to the keys but they've got you

5345
05:53:13,440 --> 05:53:15,200
know really high level privilege on the

5346
05:53:15,200 --> 05:53:17,520
database itself they'll just see the

5347
05:53:17,520 --> 05:53:19,040
stars and they dig into that they'll see

5348
05:53:19,040 --> 05:53:21,200
these just you know binary data fields

5349
05:53:21,200 --> 05:53:23,680
that are encrypted

5350
05:53:23,680 --> 05:53:25,120
but if you do have the key and the

5351
05:53:25,120 --> 05:53:27,360
proper credentials then you see

5352
05:53:27,360 --> 05:53:30,958
the entire record for example

5353
05:53:31,200 --> 05:53:33,120
uh storage impact

5354
05:53:33,120 --> 05:53:34,320
uh it's

5355
05:53:34,320 --> 05:53:35,280
you know

5356
05:53:35,280 --> 05:53:38,320
basically two to four times uh what the

5357
05:53:38,320 --> 05:53:40,160
uh plaintext is

5358
05:53:40,160 --> 05:53:42,400
on

5359
05:53:43,840 --> 05:53:47,200
i thought i had the

5360
05:53:47,200 --> 05:53:48,638
speed for the latency performance

5361
05:53:48,638 --> 05:53:50,718
numbers as well so we're still doing

5362
05:53:50,718 --> 05:53:52,080
testing but

5363
05:53:52,080 --> 05:53:53,360
in the order of

5364
05:53:53,360 --> 05:53:55,680
uh 14 to say 20 million documents 20

5365
05:53:55,680 --> 05:53:57,680
million records we're seeing

5366
05:53:57,680 --> 05:53:59,440
sub 10 millisecond response time on

5367
05:53:59,440 --> 05:54:02,638
search so you know really really strong

5368
05:54:02,638 --> 05:54:05,040
really good performance

5369
05:54:05,040 --> 05:54:08,480
uh we built this uh on the uh

5370
05:54:08,480 --> 05:54:10,400
for the application side on every

5371
05:54:10,400 --> 05:54:12,718
platform under the sun including the new

5372
05:54:12,718 --> 05:54:15,520
uh m1 and m2 architectures on mac

5373
05:54:15,520 --> 05:54:17,600
as i said the code is up on github we

5374
05:54:17,600 --> 05:54:20,400
encourage you to take a look

5375
05:54:20,400 --> 05:54:22,480
give us feedback let us know if you

5376
05:54:22,480 --> 05:54:24,798
find anything interesting

5377
05:54:24,798 --> 05:54:26,718
oops

5378
05:54:26,718 --> 05:54:28,558
these are the drivers that are supported

5379
05:54:28,558 --> 05:54:31,200
uh you'll see references sometimes to

5380
05:54:31,200 --> 05:54:33,360
crypt shared and uh client encryption

5381
05:54:33,360 --> 05:54:35,760
for example uh all the docs api specs

5382
05:54:35,760 --> 05:54:37,520
they're all online

5383
05:54:37,520 --> 05:54:38,400
oops

5384
05:54:38,400 --> 05:54:40,240
um

5385
05:54:40,240 --> 05:54:42,718
lots more people on this uh i actually

5386
05:54:42,718 --> 05:54:43,760
should have co-authored this with

5387
05:54:43,760 --> 05:54:46,480
cynthia my uh partnering crime at mommy

5388
05:54:46,480 --> 05:54:47,840
and she's our senior product manager

5389
05:54:47,840 --> 05:54:50,320
that uh was crucially

5390
05:54:50,320 --> 05:54:52,958
uh crucial in in seeing this across the

5391
05:54:52,958 --> 05:54:54,958
finish line

5392
05:54:54,958 --> 05:54:57,840
and just a quick note so

5393
05:54:57,840 --> 05:55:01,040
this is how it all started in 2018 with

5394
05:55:01,040 --> 05:55:03,760
uh me reaching out to sunny and

5395
05:55:03,760 --> 05:55:06,080
this is uh some feedback we got from a

5396
05:55:06,080 --> 05:55:07,200
month ago

5397
05:55:07,200 --> 05:55:08,320
this is a

5398
05:55:08,320 --> 05:55:10,160
obviously for confidentiality we can't

5399
05:55:10,160 --> 05:55:12,558
get into uh particular names but this is

5400
05:55:12,558 --> 05:55:14,000
a company that moves

5401
05:55:14,000 --> 05:55:15,040
um

5402
05:55:15,040 --> 05:55:17,040
around 200 billion dollars a day in

5403
05:55:17,040 --> 05:55:18,240
trading around the world so if you have

5404
05:55:18,240 --> 05:55:19,920
a if you have a us

5405
05:55:19,920 --> 05:55:21,040
credit card

5406
05:55:21,040 --> 05:55:24,400
mx visa mastercard or debit card

5407
05:55:24,400 --> 05:55:25,920
they're pretty much flowing on this

5408
05:55:25,920 --> 05:55:27,600
platform

5409
05:55:27,600 --> 05:55:30,240
so i'll leave it here um we're super

5410
05:55:30,240 --> 05:55:33,040
excited to be able to to roll this out i

5411
05:55:33,040 --> 05:55:35,040
know there's probably tons and tons of

5412
05:55:35,040 --> 05:55:38,000
questions um and we're around so thanks

5413
05:55:38,000 --> 05:55:40,400
so much

5414
05:55:46,080 --> 05:55:48,480
we have time for one question we need to

5415
05:55:48,480 --> 05:55:50,798
um

5416
05:55:54,400 --> 05:55:55,440
thank you

5417
05:55:55,440 --> 05:55:56,558
um

5418
05:55:56,558 --> 05:55:57,600
hey

5419
05:55:57,600 --> 05:55:59,280
so quick question uh

5420
05:55:59,280 --> 05:56:01,760
a feature called automatic encryption

5421
05:56:01,760 --> 05:56:04,480
was not available for the edition if i

5422
05:56:04,480 --> 05:56:06,878
understand correctly why is that

5423
05:56:06,878 --> 05:56:09,680
uh part of the reason for that is um

5424
05:56:09,680 --> 05:56:11,680
is the

5425
05:56:11,680 --> 05:56:14,558
investment that we put into it um it

5426
05:56:14,558 --> 05:56:16,958
turns out that automatic encryption is

5427
05:56:16,958 --> 05:56:18,240
really useful

5428
05:56:18,240 --> 05:56:21,040
for

5429
05:56:21,040 --> 05:56:22,080
sort of

5430
05:56:22,080 --> 05:56:24,000
basic uh

5431
05:56:24,000 --> 05:56:26,320
uh architectures um but if you wanted to

5432
05:56:26,320 --> 05:56:27,600
do things like

5433
05:56:27,600 --> 05:56:28,718
i didn't mention one of the things you

5434
05:56:28,718 --> 05:56:30,878
could do is uh

5435
05:56:30,878 --> 05:56:35,040
a key per field or an application user

5436
05:56:35,040 --> 05:56:36,798
level key so you do

5437
05:56:36,798 --> 05:56:38,160
basically one key is going to be

5438
05:56:38,160 --> 05:56:39,760
protecting all of social security

5439
05:56:39,760 --> 05:56:41,760
numbers or mobile numbers you can also

5440
05:56:41,760 --> 05:56:43,440
make it so that you have a key that we

5441
05:56:43,440 --> 05:56:45,120
generate in the application on your

5442
05:56:45,120 --> 05:56:46,240
behalf

5443
05:56:46,240 --> 05:56:48,000
and if you ever want to leave the

5444
05:56:48,000 --> 05:56:50,320
service we just destroy your keys so

5445
05:56:50,320 --> 05:56:51,760
even if we didn't delete the actual

5446
05:56:51,760 --> 05:56:52,958
records it doesn't matter because the

5447
05:56:52,958 --> 05:56:55,360
data is recoverable in that context you

5448
05:56:55,360 --> 05:56:56,480
actually have to use exclusive

5449
05:56:56,480 --> 05:56:58,638
encryption anyway so

5450
05:56:58,638 --> 05:57:00,798
uh i can't make any

5451
05:57:00,798 --> 05:57:02,798
public promises about where that

5452
05:57:02,798 --> 05:57:04,400
landscape is going to look in a few

5453
05:57:04,400 --> 05:57:06,400
months but uh yeah we've we've had

5454
05:57:06,400 --> 05:57:09,040
several uh we've had several people ask

5455
05:57:09,040 --> 05:57:10,718
about that uh

5456
05:57:10,718 --> 05:57:12,878
the the online service that i mentioned

5457
05:57:12,878 --> 05:57:15,920
atlas it is a pre-service so there's no

5458
05:57:15,920 --> 05:57:17,200
you know if you want to play with it

5459
05:57:17,200 --> 05:57:18,240
there's no credit card or anything like

5460
05:57:18,240 --> 05:57:19,120
that

5461
05:57:19,120 --> 05:57:21,680
it's free forever as they say um but

5462
05:57:21,680 --> 05:57:23,760
it's those are by default even the

5463
05:57:23,760 --> 05:57:27,200
simplest level uh tiers or you know tls

5464
05:57:27,200 --> 05:57:29,680
uh full disk encryption in and

5465
05:57:29,680 --> 05:57:31,760
full access to the entire suite

5466
05:57:31,760 --> 05:57:33,920
of structural encryption or the earlier

5467
05:57:33,920 --> 05:57:35,600
generation one with client side of the

5468
05:57:35,600 --> 05:57:38,840
level encryption

5469
05:57:50,160 --> 05:57:51,440
i'm saying that more advanced

5470
05:57:51,440 --> 05:57:53,520
architectures like the gdpr require the

5471
05:57:53,520 --> 05:57:56,160
explicit encryption um

5472
05:57:56,160 --> 05:57:58,080
that's number one but number two we have

5473
05:57:58,080 --> 05:57:59,920
gotten a lot of feedback saying

5474
05:57:59,920 --> 05:58:02,240
how much more work would it be to just

5475
05:58:02,240 --> 05:58:05,440
open source the um the second piece i

5476
05:58:05,440 --> 05:58:06,638
don't know if we're ever going to open

5477
05:58:06,638 --> 05:58:08,638
source it we may make it free

5478
05:58:08,638 --> 05:58:10,958
part of the thing is what the what is

5479
05:58:10,958 --> 05:58:14,160
behind automatic encryption is

5480
05:58:14,160 --> 05:58:15,760
the entire

5481
05:58:15,760 --> 05:58:18,320
query parsing engine from our course

5482
05:58:18,320 --> 05:58:19,840
it's a it's a

5483
05:58:19,840 --> 05:58:22,718
10 year plus code base of c plus

5484
05:58:22,718 --> 05:58:24,798
that is exactly the same as what's in

5485
05:58:24,798 --> 05:58:28,400
our enterprise product so uh it's likely

5486
05:58:28,400 --> 05:58:30,160
i won't say like it's it's highly

5487
05:58:30,160 --> 05:58:31,760
possible that we can

5488
05:58:31,760 --> 05:58:35,040
we'll drop the uh requirement it but on

5489
05:58:35,040 --> 05:58:36,240
that particular element it doesn't have

5490
05:58:36,240 --> 05:58:37,760
any encryption it's purely a parsing

5491
05:58:37,760 --> 05:58:39,840
thing so there's no keys there's no

5492
05:58:39,840 --> 05:58:41,760
there's no encryption in that one

5493
05:58:41,760 --> 05:58:42,958
component that

5494
05:58:42,958 --> 05:58:44,878
underlies automatic it's strictly a

5495
05:58:44,878 --> 05:58:47,200
query parsing uh technique

5496
05:58:47,200 --> 05:58:51,480
yeah all right so let's thank ken again

5497
05:59:06,558 --> 05:59:07,680
well wait for john i just want to

5498
05:59:07,680 --> 05:59:10,000
mention the technical brief that uh ken

5499
05:59:10,000 --> 05:59:11,600
was talking about so that's a document

5500
05:59:11,600 --> 05:59:13,520
for that's a non-technical document

5501
05:59:13,520 --> 05:59:14,878
right for folks who don't have technical

5502
05:59:14,878 --> 05:59:16,958
background and then there will be uh

5503
05:59:16,958 --> 05:59:19,040
more technical documents

5504
05:59:19,040 --> 05:59:22,440
uh that follow

5505
06:00:56,958 --> 06:00:59,120
all right so the next talk is going to

5506
06:00:59,120 --> 06:01:01,840
be given by john milikan and this is

5507
06:01:01,840 --> 06:01:04,160
uh from metta and this talk is going to

5508
06:01:04,160 --> 06:01:06,480
be about recent work that he's been

5509
06:01:06,480 --> 06:01:09,440
doing on message encryption

5510
06:01:09,440 --> 06:01:10,480
benny

5511
06:01:10,480 --> 06:01:12,080
um

5512
06:01:12,080 --> 06:01:15,280
yeah so uh hi i'm john milliken um

5513
06:01:15,280 --> 06:01:17,120
sonny says from meta's messenger privacy

5514
06:01:17,120 --> 06:01:18,400
team

5515
06:01:18,400 --> 06:01:19,200
um

5516
06:01:19,200 --> 06:01:20,558
and we've been working on end-to-end

5517
06:01:20,558 --> 06:01:22,558
encrypted private messaging for a few

5518
06:01:22,558 --> 06:01:24,400
years now um and i'd like to talk to

5519
06:01:24,400 --> 06:01:26,080
this room about an encrypted database

5520
06:01:26,080 --> 06:01:27,520
protocol called labyrinth that we've

5521
06:01:27,520 --> 06:01:29,920
been designing for it

5522
06:01:29,920 --> 06:01:31,120
this is bleeding edge from our

5523
06:01:31,120 --> 06:01:34,000
perspective um we've just begun user

5524
06:01:34,000 --> 06:01:35,520
testing i think we literally announced

5525
06:01:35,520 --> 06:01:37,440
this two days ago

5526
06:01:37,440 --> 06:01:39,360
and not even for the whole protocol so

5527
06:01:39,360 --> 06:01:40,638
please take

5528
06:01:40,638 --> 06:01:42,958
a lot of this is um

5529
06:01:42,958 --> 06:01:43,840
um

5530
06:01:43,840 --> 06:01:45,760
as a target design rather than perhaps

5531
06:01:45,760 --> 06:01:47,680
exactly what's running at the moment or

5532
06:01:47,680 --> 06:01:48,718
indeed a

5533
06:01:48,718 --> 06:01:50,240
a guarantee that this is how things are

5534
06:01:50,240 --> 06:01:52,080
going to end up um

5535
06:01:52,080 --> 06:01:53,440
we're expecting to get a bunch of

5536
06:01:53,440 --> 06:01:55,600
reliability and scalability uh

5537
06:01:55,600 --> 06:01:57,200
understanding over the next few months

5538
06:01:57,200 --> 06:01:59,440
and uh things very well could could

5539
06:01:59,440 --> 06:02:02,558
change as a result of that

5540
06:02:02,558 --> 06:02:06,160
but with those caveats

5541
06:02:07,200 --> 06:02:10,718
that did not change when it was there we

5542
06:02:10,718 --> 06:02:13,040
are cool so with those caveats said um

5543
06:02:13,040 --> 06:02:15,360
i'll start with a quick recap of the

5544
06:02:15,360 --> 06:02:17,040
background before moving on to our high

5545
06:02:17,040 --> 06:02:19,520
level design goals um and most of this

5546
06:02:19,520 --> 06:02:20,718
presentation is going to focus on a

5547
06:02:20,718 --> 06:02:22,798
walkthrough of roughly how we arrived at

5548
06:02:22,798 --> 06:02:25,040
our technological design um that

5549
06:02:25,040 --> 06:02:26,160
walkthrough is going to go fairly

5550
06:02:26,160 --> 06:02:27,920
quickly but i'll do my best to highlight

5551
06:02:27,920 --> 06:02:29,520
the key points on each slide and

5552
06:02:29,520 --> 06:02:31,040
hopefully a lot of the points are going

5553
06:02:31,040 --> 06:02:33,040
to be very familiar or obvious to this

5554
06:02:33,040 --> 06:02:35,200
room anyway

5555
06:02:35,200 --> 06:02:36,638
and then i'll finish with a quick

5556
06:02:36,638 --> 06:02:38,160
discussion on some of the trade-offs and

5557
06:02:38,160 --> 06:02:40,718
uh summary

5558
06:02:41,360 --> 06:02:43,920
so what's the context for all of this um

5559
06:02:43,920 --> 06:02:46,000
well as i mentioned uh we're working on

5560
06:02:46,000 --> 06:02:47,520
end-to-end encrypting private messages

5561
06:02:47,520 --> 06:02:48,718
sorry i'm just going to talk while that

5562
06:02:48,718 --> 06:02:50,080
waits to update

5563
06:02:50,080 --> 06:02:51,520
um

5564
06:02:51,520 --> 06:02:53,680
and this is a pretty big undertaking as

5565
06:02:53,680 --> 06:02:55,840
it kind of fundamentally modifies the

5566
06:02:55,840 --> 06:02:57,360
underlying architecture on which

5567
06:02:57,360 --> 06:02:59,360
messenger has been built um and the

5568
06:02:59,360 --> 06:03:01,120
constraints that we have to work within

5569
06:03:01,120 --> 06:03:03,440
um like many of these constraints uh

5570
06:03:03,440 --> 06:03:06,000
require us to change the product itself

5571
06:03:06,000 --> 06:03:08,558
um which prevents particular challenges

5572
06:03:08,558 --> 06:03:10,320
as we really don't want to undermine the

5573
06:03:10,320 --> 06:03:12,878
reasons why people find messenger to be

5574
06:03:12,878 --> 06:03:15,840
a useful product in the first place

5575
06:03:15,840 --> 06:03:18,160
and of particular wow that still hasn't

5576
06:03:18,160 --> 06:03:21,638
updated but

5577
06:03:22,160 --> 06:03:24,480
um

5578
06:03:24,958 --> 06:03:27,600
ah there we are

5579
06:03:28,160 --> 06:03:30,638
okay cool um

5580
06:03:30,638 --> 06:03:32,480
yeah so of particular notes um is what

5581
06:03:32,480 --> 06:03:35,040
all of this means for message history um

5582
06:03:35,040 --> 06:03:38,160
an um a mailbox which the server can

5583
06:03:38,160 --> 06:03:40,240
store in plain text as it does today for

5584
06:03:40,240 --> 06:03:42,958
most of our messages um it can be easily

5585
06:03:42,958 --> 06:03:44,878
provided to you on new devices

5586
06:03:44,878 --> 06:03:46,320
authenticated just by logging into your

5587
06:03:46,320 --> 06:03:47,920
facebook accounts

5588
06:03:47,920 --> 06:03:49,280
and this means that people generally

5589
06:03:49,280 --> 06:03:51,280
don't have to worry about message loss

5590
06:03:51,280 --> 06:03:53,520
you can use message messenger seamlessly

5591
06:03:53,520 --> 06:03:56,000
across multiple devices or lose a device

5592
06:03:56,000 --> 06:03:58,080
and not need to worry about losing their

5593
06:03:58,080 --> 06:03:59,680
data

5594
06:03:59,680 --> 06:04:01,120
it also means that your device doesn't

5595
06:04:01,120 --> 06:04:02,718
need to store all of your messages

5596
06:04:02,718 --> 06:04:04,400
instead it can pull down your threads

5597
06:04:04,400 --> 06:04:06,558
and messages on demand

5598
06:04:06,558 --> 06:04:08,878
dynamically loading in more content

5599
06:04:08,878 --> 06:04:11,040
as and when you scroll

5600
06:04:11,040 --> 06:04:13,680
for us this is really important because

5601
06:04:13,680 --> 06:04:15,760
many people use messenger on devices

5602
06:04:15,760 --> 06:04:18,160
with limited storage and we really don't

5603
06:04:18,160 --> 06:04:20,798
want the app to either just not work for

5604
06:04:20,798 --> 06:04:23,040
them or to monopolize their device and

5605
06:04:23,040 --> 06:04:25,920
be a bad citizen

5606
06:04:27,600 --> 06:04:30,320
so all of this motivates a server-side

5607
06:04:30,320 --> 06:04:32,320
encrypted storage mechanism um for

5608
06:04:32,320 --> 06:04:34,558
people's messages um to address these

5609
06:04:34,558 --> 06:04:36,638
limitations and it has a number of goals

5610
06:04:36,638 --> 06:04:39,200
that we wish to achieve um some product

5611
06:04:39,200 --> 06:04:41,920
and some privacy um so first what have

5612
06:04:41,920 --> 06:04:43,440
we built needs to work across multiple

5613
06:04:43,440 --> 06:04:46,000
devices and indeed platforms so somebody

5614
06:04:46,000 --> 06:04:47,920
using messenger on an android phone and

5615
06:04:47,920 --> 06:04:50,878
ipads and microsoft edge or something

5616
06:04:50,878 --> 06:04:52,638
still needs to be able to both save and

5617
06:04:52,638 --> 06:04:56,000
restore all of their messages

5618
06:04:56,000 --> 06:04:58,400
next we need it to operate incrementally

5619
06:04:58,400 --> 06:05:00,240
um so we're talking about efficiently

5620
06:05:00,240 --> 06:05:02,080
saving messages as they arrive in near

5621
06:05:02,080 --> 06:05:03,280
real time

5622
06:05:03,280 --> 06:05:05,360
um and being able to read in specified

5623
06:05:05,360 --> 06:05:08,320
target data um such as for scroll back

5624
06:05:08,320 --> 06:05:10,798
or point queries

5625
06:05:10,798 --> 06:05:13,280
um now on to the pro the privacy goals

5626
06:05:13,280 --> 06:05:14,798
um and these end up being a bit more

5627
06:05:14,798 --> 06:05:16,400
nuanced than i can really convey in one

5628
06:05:16,400 --> 06:05:18,558
slide but i'll give it a go um

5629
06:05:18,558 --> 06:05:21,360
so we want a system that can

5630
06:05:21,360 --> 06:05:23,360
um hide message content from meta this

5631
06:05:23,360 --> 06:05:28,400
is like a core e2e encryption guarantee

5632
06:05:28,718 --> 06:05:30,240
and so we really don't want the message

5633
06:05:30,240 --> 06:05:32,798
storage system to be undermining it

5634
06:05:32,798 --> 06:05:34,798
we also want labyrinths to reveal

5635
06:05:34,798 --> 06:05:37,600
minimal metadata where possible

5636
06:05:37,600 --> 06:05:38,798
these protections take slightly

5637
06:05:38,798 --> 06:05:41,600
different threat models but ultimately

5638
06:05:41,600 --> 06:05:43,520
we really don't want to be seeing

5639
06:05:43,520 --> 06:05:45,200
information that isn't necessary for the

5640
06:05:45,200 --> 06:05:49,360
system's operation wherever possible

5641
06:05:50,400 --> 06:05:51,760
next

5642
06:05:51,760 --> 06:05:55,120
ideally we aim to not even know who owns

5643
06:05:55,120 --> 06:05:57,760
any given piece of data and storage um

5644
06:05:57,760 --> 06:05:59,760
so avoid having a linkage between the

5645
06:05:59,760 --> 06:06:02,240
mailbox and their owner

5646
06:06:02,240 --> 06:06:03,920
then finally we want to support pretty

5647
06:06:03,920 --> 06:06:06,320
granular access control um in the

5648
06:06:06,320 --> 06:06:08,798
context of multi-device operation

5649
06:06:08,798 --> 06:06:10,718
and so to be precise this means for

5650
06:06:10,718 --> 06:06:12,160
example that we need to be able to

5651
06:06:12,160 --> 06:06:14,558
meaningfully revoke devices access um

5652
06:06:14,558 --> 06:06:17,120
cryptographically um once the user is no

5653
06:06:17,120 --> 06:06:19,920
longer using them

5654
06:06:20,840 --> 06:06:24,400
so let's step through this and um i'd

5655
06:06:24,400 --> 06:06:26,558
just clarify that i'm brushing over a

5656
06:06:26,558 --> 06:06:28,718
bunch of the nuance here um

5657
06:06:28,718 --> 06:06:31,360
so um please don't see key reuse and

5658
06:06:31,360 --> 06:06:33,120
think we're just being idiots it's

5659
06:06:33,120 --> 06:06:34,558
possible that we are but hopefully we're

5660
06:06:34,558 --> 06:06:37,200
not

5661
06:06:37,520 --> 06:06:40,320
um so yeah let's start with our goals um

5662
06:06:40,320 --> 06:06:41,520
and uh

5663
06:06:41,520 --> 06:06:42,958
put through the framing of a sort of

5664
06:06:42,958 --> 06:06:45,440
hierarchy of needs uh that's a nice old

5665
06:06:45,440 --> 06:06:47,120
cliche um

5666
06:06:47,120 --> 06:06:49,920
and um yeah so we're starting out we're

5667
06:06:49,920 --> 06:06:51,360
talking about message storage so

5668
06:06:51,360 --> 06:06:53,120
fundamentally it has to function in that

5669
06:06:53,120 --> 06:06:55,840
way um we don't want to just deploy a

5670
06:06:55,840 --> 06:06:57,280
bunch of fun cryptography and it not

5671
06:06:57,280 --> 06:06:58,080
work

5672
06:06:58,080 --> 06:06:59,360
um

5673
06:06:59,360 --> 06:07:00,878
and so this is kind of our starting

5674
06:07:00,878 --> 06:07:02,320
point and it's where

5675
06:07:02,320 --> 06:07:04,240
where messenger exists today it's not an

5676
06:07:04,240 --> 06:07:08,718
encrypted database um but it works um

5677
06:07:08,718 --> 06:07:10,400
and um

5678
06:07:10,400 --> 06:07:13,520
this is the data model that we're really

5679
06:07:13,520 --> 06:07:15,440
working with or an approximation of the

5680
06:07:15,440 --> 06:07:19,200
data model so um the message is stored

5681
06:07:19,200 --> 06:07:22,160
with a mailbox a thread um

5682
06:07:22,160 --> 06:07:24,718
a message id itself timestamps and then

5683
06:07:24,718 --> 06:07:28,080
the actual message data

5684
06:07:29,760 --> 06:07:30,558
but

5685
06:07:30,558 --> 06:07:32,080
as i mentioned there's no there's no

5686
06:07:32,080 --> 06:07:33,840
privacy added there at least no privacy

5687
06:07:33,840 --> 06:07:35,280
from meta

5688
06:07:35,280 --> 06:07:37,600
so let's move on to protecting message

5689
06:07:37,600 --> 06:07:40,480
content from us

5690
06:07:40,480 --> 06:07:41,280
and

5691
06:07:41,280 --> 06:07:43,440
so

5692
06:07:44,798 --> 06:07:48,080
um so yeah our initial candidates um

5693
06:07:48,080 --> 06:07:50,000
just encrypts the messages themselves

5694
06:07:50,000 --> 06:07:52,400
uses a static key associated with that

5695
06:07:52,400 --> 06:07:54,878
one mailbox um

5696
06:07:54,878 --> 06:07:57,280
this is getting us um

5697
06:07:57,280 --> 06:07:59,920
um getting us quite quite a lot already

5698
06:07:59,920 --> 06:08:01,600
given it is now end-to-end encrypted

5699
06:08:01,600 --> 06:08:03,680
protects your most sensitive data but

5700
06:08:03,680 --> 06:08:05,280
it's still linked with the user account

5701
06:08:05,280 --> 06:08:07,840
it doesn't really have access control um

5702
06:08:07,840 --> 06:08:10,400
against old devices and we still have

5703
06:08:10,400 --> 06:08:12,958
our metadata

5704
06:08:12,958 --> 06:08:15,600
but regardless um

5705
06:08:15,600 --> 06:08:18,080
this this is how the database changes in

5706
06:08:18,080 --> 06:08:20,718
in this setting

5707
06:08:21,040 --> 06:08:22,320
um

5708
06:08:22,320 --> 06:08:24,080
now i've talked a lot about metadata but

5709
06:08:24,080 --> 06:08:25,760
before we move on to that let's really

5710
06:08:25,760 --> 06:08:27,280
focus on

5711
06:08:27,280 --> 06:08:29,440
this issue of securing data from old

5712
06:08:29,440 --> 06:08:30,558
devices

5713
06:08:30,558 --> 06:08:32,080
um

5714
06:08:32,080 --> 06:08:33,920
and

5715
06:08:33,920 --> 06:08:35,440
really the the thing is and the

5716
06:08:35,440 --> 06:08:38,240
motivation for this as um in our

5717
06:08:38,240 --> 06:08:39,760
end-to-end encrypted chat messaging

5718
06:08:39,760 --> 06:08:42,638
channel so using the signal protocol we

5719
06:08:42,638 --> 06:08:44,400
we're already doing a lot of this so

5720
06:08:44,400 --> 06:08:45,920
whenever a device is removed we're

5721
06:08:45,920 --> 06:08:49,280
rotating the keys um so if if we're

5722
06:08:49,280 --> 06:08:51,040
undermining that in message storage it

5723
06:08:51,040 --> 06:08:53,120
just feels like we're not not achieving

5724
06:08:53,120 --> 06:08:57,120
where we want to be um overall

5725
06:08:58,798 --> 06:09:00,320
so um

5726
06:09:00,320 --> 06:09:02,958
we want to have key rotation um so let's

5727
06:09:02,958 --> 06:09:05,840
introduce now a notion of epochs so

5728
06:09:05,840 --> 06:09:08,080
these are periods of time within which

5729
06:09:08,080 --> 06:09:10,718
the devices do not change

5730
06:09:10,718 --> 06:09:12,080
um

5731
06:09:12,080 --> 06:09:14,718
so we can now decide to rotate the epoch

5732
06:09:14,718 --> 06:09:16,958
every time a device is removed or indeed

5733
06:09:16,958 --> 06:09:18,958
whenever else we feel like it and then

5734
06:09:18,958 --> 06:09:20,558
that will ensure that messages aren't

5735
06:09:20,558 --> 06:09:23,040
encrypted using keys that are under the

5736
06:09:23,040 --> 06:09:25,120
possession or were once known to an old

5737
06:09:25,120 --> 06:09:26,480
device

5738
06:09:26,480 --> 06:09:28,320
um

5739
06:09:28,320 --> 06:09:30,798
this now effectively um

5740
06:09:30,798 --> 06:09:32,558
introduces quite a bit of complexity as

5741
06:09:32,558 --> 06:09:34,638
we now need to track track devices

5742
06:09:34,638 --> 06:09:35,920
individually

5743
06:09:35,920 --> 06:09:38,480
and track these epochs and the keys

5744
06:09:38,480 --> 06:09:39,280
um

5745
06:09:39,280 --> 06:09:40,160
so

5746
06:09:40,160 --> 06:09:41,200
we're

5747
06:09:41,200 --> 06:09:42,480
well i previously showed you an

5748
06:09:42,480 --> 06:09:44,558
illustration of a mailbox database now

5749
06:09:44,558 --> 06:09:46,480
we're needing to introduce a new one

5750
06:09:46,480 --> 06:09:49,440
which is to store all of this extra data

5751
06:09:49,440 --> 06:09:51,360
which we'll call the meta store the want

5752
06:09:51,360 --> 06:09:52,798
of a better word

5753
06:09:52,798 --> 06:09:53,680
um

5754
06:09:53,680 --> 06:09:54,958
and i'll show you this in a sec i just

5755
06:09:54,958 --> 06:09:56,638
want to caveat that when i say we

5756
06:09:56,638 --> 06:09:57,920
haven't finished rolling out this is

5757
06:09:57,920 --> 06:10:00,080
actually one of those things which

5758
06:10:00,080 --> 06:10:01,840
um

5759
06:10:01,840 --> 06:10:04,320
the the complexity of the epoch relation

5760
06:10:04,320 --> 06:10:06,400
uh epoch rotation and the reliability is

5761
06:10:06,400 --> 06:10:07,840
something we want to do more internal

5762
06:10:07,840 --> 06:10:09,520
testing on than we

5763
06:10:09,520 --> 06:10:14,160
before we start risking users data

5764
06:10:17,200 --> 06:10:18,638
but yeah so

5765
06:10:18,638 --> 06:10:20,718
this is how the mailbox data database

5766
06:10:20,718 --> 06:10:23,040
changes first so it's essentially the

5767
06:10:23,040 --> 06:10:24,320
same on the message side we're just

5768
06:10:24,320 --> 06:10:26,080
encrypting with a different key but now

5769
06:10:26,080 --> 06:10:27,840
we're indicating which epochs are being

5770
06:10:27,840 --> 06:10:30,558
used to encrypt it so that you can

5771
06:10:30,558 --> 06:10:34,480
actually know what key to use

5772
06:10:34,480 --> 06:10:35,440
and then

5773
06:10:35,440 --> 06:10:37,760
more interestingly here we have our meta

5774
06:10:37,760 --> 06:10:39,120
store database

5775
06:10:39,120 --> 06:10:41,680
so first up we have our devices table

5776
06:10:41,680 --> 06:10:44,320
and then this indicates every device and

5777
06:10:44,320 --> 06:10:47,360
alongside a public key

5778
06:10:47,360 --> 06:10:50,000
next up there's this epochs table um

5779
06:10:50,000 --> 06:10:53,040
which at this stage in in the design

5780
06:10:53,040 --> 06:10:54,320
doesn't do much apart from just

5781
06:10:54,320 --> 06:10:56,240
providing the epoch ids

5782
06:10:56,240 --> 06:10:57,200
um

5783
06:10:57,200 --> 06:10:59,360
and then finally there's the epochkeys

5784
06:10:59,360 --> 06:11:01,680
table itself and then this is used for

5785
06:11:01,680 --> 06:11:04,320
distributing epoc keys before between

5786
06:11:04,320 --> 06:11:07,040
devices so each epoch key is

5787
06:11:07,040 --> 06:11:09,440
generated by one device it needs to be

5788
06:11:09,440 --> 06:11:11,040
transmitted to all the others so that

5789
06:11:11,040 --> 06:11:13,440
they know it too and this is how we do

5790
06:11:13,440 --> 06:11:16,080
that transmission um encrypted to the

5791
06:11:16,080 --> 06:11:18,480
public keys and the devices table

5792
06:11:18,480 --> 06:11:20,400
now she's actually worth um calling out

5793
06:11:20,400 --> 06:11:22,160
here that we do actually already have a

5794
06:11:22,160 --> 06:11:24,320
direct device to device end-to-end

5795
06:11:24,320 --> 06:11:26,558
encrypted channel in the signal protocol

5796
06:11:26,558 --> 06:11:28,958
which we're opting not to use here

5797
06:11:28,958 --> 06:11:31,520
um the thing is that in the signal

5798
06:11:31,520 --> 06:11:34,480
protocol um there there can be some

5799
06:11:34,480 --> 06:11:35,920
reliability challenges every now and

5800
06:11:35,920 --> 06:11:37,280
then you're going to need to retry a

5801
06:11:37,280 --> 06:11:39,600
message or something

5802
06:11:39,600 --> 06:11:41,120
that's just not viable when we're

5803
06:11:41,120 --> 06:11:42,718
talking about a storage system

5804
06:11:42,718 --> 06:11:44,240
particularly one that could be used for

5805
06:11:44,240 --> 06:11:46,400
long-term backups and storage because

5806
06:11:46,400 --> 06:11:48,878
you simply cannot assume that there's

5807
06:11:48,878 --> 06:11:50,558
going to be some device there which can

5808
06:11:50,558 --> 06:11:52,080
resend the data

5809
06:11:52,080 --> 06:11:54,558
so um because of that with instead of

5810
06:11:54,558 --> 06:11:56,000
using our existing channel we're using

5811
06:11:56,000 --> 06:11:57,840
something else which is really just

5812
06:11:57,840 --> 06:12:00,160
relying on a direct encryption to to a

5813
06:12:00,160 --> 06:12:02,480
public key well directly it's an hpk

5814
06:12:02,480 --> 06:12:04,798
either

5815
06:12:06,958 --> 06:12:07,840
but

5816
06:12:07,840 --> 06:12:09,600
there is a problem here in that there's

5817
06:12:09,600 --> 06:12:11,520
nothing to stop the provider at the

5818
06:12:11,520 --> 06:12:12,958
moment from just modifying the list of

5819
06:12:12,958 --> 06:12:15,920
devices um so that

5820
06:12:15,920 --> 06:12:17,840
they can get the next epoch so we do

5821
06:12:17,840 --> 06:12:19,280
need some sort of proof of membership

5822
06:12:19,280 --> 06:12:21,440
here

5823
06:12:21,440 --> 06:12:24,718
which we introduce in the epochs table

5824
06:12:24,718 --> 06:12:28,798
just with a series of hmacs um over the

5825
06:12:28,798 --> 06:12:30,958
various devices and and computed with

5826
06:12:30,958 --> 06:12:34,000
that epoch one key

5827
06:12:35,360 --> 06:12:37,280
but we've got a similar challenge

5828
06:12:37,280 --> 06:12:40,558
regarding um epoch creation

5829
06:12:40,558 --> 06:12:42,878
so uh we also don't want the provider to

5830
06:12:42,878 --> 06:12:45,040
be able to just generate their own epoch

5831
06:12:45,040 --> 06:12:46,718
key encrypt it to everyone else's public

5832
06:12:46,718 --> 06:12:49,200
key and then sort of just blindly trust

5833
06:12:49,200 --> 06:12:50,798
it

5834
06:12:50,798 --> 06:12:52,958
so we're modifying our encryption

5835
06:12:52,958 --> 06:12:54,958
operation here to now include a sender

5836
06:12:54,958 --> 06:12:57,760
key and a pre-shared key um

5837
06:12:57,760 --> 06:12:59,440
and

5838
06:12:59,440 --> 06:13:01,280
this um you can see the encryption

5839
06:13:01,280 --> 06:13:02,718
operation is modified it's just a

5840
06:13:02,718 --> 06:13:06,160
modification of the hpk we're using

5841
06:13:06,160 --> 06:13:09,840
um but then to authenticate using um

5842
06:13:09,840 --> 06:13:12,000
data from the previous epoch and the

5843
06:13:12,000 --> 06:13:14,718
actual create

5844
06:13:16,638 --> 06:13:18,240
but

5845
06:13:18,240 --> 06:13:20,958
we also now um it's worth noting that

5846
06:13:20,958 --> 06:13:23,440
the secrecy of each epoch at this point

5847
06:13:23,440 --> 06:13:26,320
is fully dependent on the public key

5848
06:13:26,320 --> 06:13:29,040
cryptography that we're using

5849
06:13:29,040 --> 06:13:30,480
and

5850
06:13:30,480 --> 06:13:32,160
we can do better than that

5851
06:13:32,160 --> 06:13:32,878
so

5852
06:13:32,878 --> 06:13:35,600
we want to make sure that

5853
06:13:35,600 --> 06:13:37,440
even if private keys are compromised for

5854
06:13:37,440 --> 06:13:39,280
example there is still some security

5855
06:13:39,280 --> 06:13:40,080
there

5856
06:13:40,080 --> 06:13:42,080
um and so

5857
06:13:42,080 --> 06:13:44,000
effectively here we just stop directly

5858
06:13:44,000 --> 06:13:46,080
distributing the epoch keys and instead

5859
06:13:46,080 --> 06:13:48,480
just distribute new entropy that gets

5860
06:13:48,480 --> 06:13:52,000
mixed in with the old one

5861
06:13:53,360 --> 06:13:54,480
and

5862
06:13:54,480 --> 06:13:56,480
again this is fairly different from the

5863
06:13:56,480 --> 06:13:58,878
previous slide but we say ebook entropy

5864
06:13:58,878 --> 06:14:01,360
instead of q

5865
06:14:02,000 --> 06:14:04,400
and then this is roughly what it looks

5866
06:14:04,400 --> 06:14:05,840
like this slide really should have been

5867
06:14:05,840 --> 06:14:10,400
a diagram but i realized that too late

5868
06:14:13,840 --> 06:14:14,558
but

5869
06:14:14,558 --> 06:14:17,360
just before we move on from epochs

5870
06:14:17,360 --> 06:14:18,718
i'm just going to note that we've

5871
06:14:18,718 --> 06:14:20,400
actually damaged message recoverability

5872
06:14:20,400 --> 06:14:22,000
here because we're talking about all of

5873
06:14:22,000 --> 06:14:25,520
these um keys changing over time

5874
06:14:25,520 --> 06:14:27,040
but

5875
06:14:27,040 --> 06:14:29,680
if you're some new device which

5876
06:14:29,680 --> 06:14:30,030
um

5877
06:14:30,030 --> 06:14:31,200
[Music]

5878
06:14:31,200 --> 06:14:33,200
only has access to the latest epoch keys

5879
06:14:33,200 --> 06:14:34,320
you're not going to be able to go back

5880
06:14:34,320 --> 06:14:36,638
and decrypt old messages and it's worth

5881
06:14:36,638 --> 06:14:39,120
noting here that this backup system it's

5882
06:14:39,120 --> 06:14:41,200
not intended to be forward secret if you

5883
06:14:41,200 --> 06:14:42,400
if you have access to the latest

5884
06:14:42,400 --> 06:14:43,920
messages you should have access to the

5885
06:14:43,920 --> 06:14:44,958
whole thing

5886
06:14:44,958 --> 06:14:47,440
um but that leads us to a natural

5887
06:14:47,440 --> 06:14:49,120
solution which is effectively to just

5888
06:14:49,120 --> 06:14:52,718
chain epochs and have each epoch store

5889
06:14:52,718 --> 06:14:55,040
um an encrypted version of

5890
06:14:55,040 --> 06:14:57,760
the previous epochs key

5891
06:14:57,760 --> 06:15:01,840
so it's always possible to go back

5892
06:15:03,360 --> 06:15:05,680
but now let's move up the hierarchy away

5893
06:15:05,680 --> 06:15:08,080
from protecting messages and talk a bit

5894
06:15:08,080 --> 06:15:11,440
about the metadata

5895
06:15:11,760 --> 06:15:12,878
so

5896
06:15:12,878 --> 06:15:14,958
the

5897
06:15:14,958 --> 06:15:16,798
the most immediate and obvious metadata

5898
06:15:16,798 --> 06:15:18,878
here are the various identifiers um

5899
06:15:18,878 --> 06:15:20,480
starting with the message and the thread

5900
06:15:20,480 --> 06:15:22,160
identifiers uh so these are very

5901
06:15:22,160 --> 06:15:23,600
meaningful they're shared across if

5902
06:15:23,600 --> 06:15:25,600
they're shared across mailboxes then you

5903
06:15:25,600 --> 06:15:27,600
could indicate from this who is talking

5904
06:15:27,600 --> 06:15:28,718
to whom

5905
06:15:28,718 --> 06:15:30,638
um or at least which mailboxes are

5906
06:15:30,638 --> 06:15:32,000
talking to each other but we can assume

5907
06:15:32,000 --> 06:15:35,200
that a mailbox is effectively a person

5908
06:15:35,200 --> 06:15:36,080
um

5909
06:15:36,080 --> 06:15:38,080
but it's worth noting um we don't

5910
06:15:38,080 --> 06:15:40,160
necessarily need to be uh reading these

5911
06:15:40,160 --> 06:15:41,680
values we don't need them to be

5912
06:15:41,680 --> 06:15:43,200
reversible so

5913
06:15:43,200 --> 06:15:44,798
we'll take technique that we've talked

5914
06:15:44,798 --> 06:15:47,120
about in this room earlier just replace

5915
06:15:47,120 --> 06:15:49,920
them with a prf or specifically an hmac

5916
06:15:49,920 --> 06:15:51,040
version

5917
06:15:51,040 --> 06:15:52,798
so that's

5918
06:15:52,798 --> 06:15:55,280
um they are now obscured these are using

5919
06:15:55,280 --> 06:15:57,040
a master key rather than the epoch key

5920
06:15:57,040 --> 06:15:58,480
because they do need to be consistent

5921
06:15:58,480 --> 06:16:01,040
over time

5922
06:16:01,280 --> 06:16:02,240
but

5923
06:16:02,240 --> 06:16:05,200
more on that in a sec

5924
06:16:06,958 --> 06:16:09,680
next up we have timestamps in the

5925
06:16:09,680 --> 06:16:11,200
database so these are these are

5926
06:16:11,200 --> 06:16:13,760
obviously revealing information directly

5927
06:16:13,760 --> 06:16:16,718
but again we i just mentioned how we we

5928
06:16:16,718 --> 06:16:18,400
prefer not to know which mailboxes are

5929
06:16:18,400 --> 06:16:20,400
talking to which and you could

5930
06:16:20,400 --> 06:16:22,400
potentially use timestamps to correlate

5931
06:16:22,400 --> 06:16:25,040
between mailboxes

5932
06:16:25,040 --> 06:16:29,520
or fingerprint them and still learn that

5933
06:16:29,680 --> 06:16:32,000
but it is however important that we can

5934
06:16:32,000 --> 06:16:34,240
order messages we want to be able to say

5935
06:16:34,240 --> 06:16:36,080
things like give me the latest 20

5936
06:16:36,080 --> 06:16:38,798
messages in this thread or give me x

5937
06:16:38,798 --> 06:16:40,958
messages before this particular message

5938
06:16:40,958 --> 06:16:43,200
id

5939
06:16:43,200 --> 06:16:44,638
so

5940
06:16:44,638 --> 06:16:46,480
standard prf standard encryption aren't

5941
06:16:46,480 --> 06:16:48,718
going to work for us

5942
06:16:48,718 --> 06:16:50,240
so we actually chose to use order

5943
06:16:50,240 --> 06:16:52,558
preserving encryption here um and i know

5944
06:16:52,558 --> 06:16:54,000
we've talked a bit a little earlier

5945
06:16:54,000 --> 06:16:57,600
about how this is weak in many ways um

5946
06:16:57,600 --> 06:16:58,958
for us it made the most sense

5947
06:16:58,958 --> 06:17:01,680
particularly in terms of being able to

5948
06:17:01,680 --> 06:17:04,638
work rapidly get stuff faster out and

5949
06:17:04,638 --> 06:17:06,320
using our existing databases that we

5950
06:17:06,320 --> 06:17:08,718
already know scale and it

5951
06:17:08,718 --> 06:17:10,160
hides the

5952
06:17:10,160 --> 06:17:13,840
uh the most critical data from us

5953
06:17:14,798 --> 06:17:17,920
and so uh now our db has been it looks

5954
06:17:17,920 --> 06:17:21,839
something like this at this stage

5955
06:17:24,718 --> 06:17:26,958
sorry john so um if you're taking

5956
06:17:26,958 --> 06:17:28,638
pictures that's okay i'm not sure but

5957
06:17:28,638 --> 06:17:30,718
yeah can you turn the volume down

5958
06:17:30,718 --> 06:17:31,920
on your phone

5959
06:17:31,920 --> 06:17:33,520
when you take the picture

5960
06:17:33,520 --> 06:17:36,320
great thank you

5961
06:17:36,638 --> 06:17:38,958
cheers

5962
06:17:39,760 --> 06:17:40,718
so

5963
06:17:40,718 --> 06:17:42,400
we're now hiding most of the method the

5964
06:17:42,400 --> 06:17:44,320
data and the metadata in the mailbox

5965
06:17:44,320 --> 06:17:46,400
from the provider but there is still

5966
06:17:46,400 --> 06:17:48,638
some structure in terms of numbers of

5967
06:17:48,638 --> 06:17:50,160
different threads and messages within

5968
06:17:50,160 --> 06:17:52,080
each thread um

5969
06:17:52,080 --> 06:17:53,600
and these are actually really

5970
06:17:53,600 --> 06:17:55,120
challenging to hide from the provider

5971
06:17:55,120 --> 06:17:57,040
while keeping things efficient and

5972
06:17:57,040 --> 06:17:59,600
queryable

5973
06:17:59,920 --> 06:18:02,160
but what we really want to do at this

5974
06:18:02,160 --> 06:18:03,760
point is at least avoid storing it from

5975
06:18:03,760 --> 06:18:06,400
the user accounts sorry avoid storing it

5976
06:18:06,400 --> 06:18:07,920
alongside the user account so you don't

5977
06:18:07,920 --> 06:18:09,920
have that direct linkage

5978
06:18:09,920 --> 06:18:11,600
um and then

5979
06:18:11,600 --> 06:18:13,040
from that structure you can't actually

5980
06:18:13,040 --> 06:18:17,120
really infer much at that point um

5981
06:18:17,120 --> 06:18:18,718
so

5982
06:18:18,718 --> 06:18:20,958
what we then do is we have this meta

5983
06:18:20,958 --> 06:18:22,558
store

5984
06:18:22,558 --> 06:18:25,040
be user linked but the actual mailbox

5985
06:18:25,040 --> 06:18:28,240
becomes completely unlinked

5986
06:18:28,240 --> 06:18:30,160
at this point um there's an obvious

5987
06:18:30,160 --> 06:18:31,680
concern about

5988
06:18:31,680 --> 06:18:34,240
authentication to the mailbox itself

5989
06:18:34,240 --> 06:18:37,600
because it's no longer user linked um

5990
06:18:37,600 --> 06:18:39,440
fortunately at this point

5991
06:18:39,440 --> 06:18:40,958
we can sort of say that if we've got a

5992
06:18:40,958 --> 06:18:43,440
mailbox id going through a prf that can

5993
06:18:43,440 --> 06:18:45,600
be used effectively as a bearer tokens

5994
06:18:45,600 --> 06:18:48,558
like it could be to authenticate to it

5995
06:18:48,558 --> 06:18:50,558
that doesn't protect us against revoked

5996
06:18:50,558 --> 06:18:53,520
devices and i'll get to that in a sec

5997
06:18:53,520 --> 06:18:56,160
but otherwise you can assume that

5998
06:18:56,160 --> 06:18:58,558
nobody else is going to know that

5999
06:18:58,558 --> 06:19:00,558
um

6000
06:19:00,558 --> 06:19:02,160
and i i should actually note as well at

6001
06:19:02,160 --> 06:19:04,478
this point that um storing unlinked from

6002
06:19:04,478 --> 06:19:06,878
the account doesn't necessarily change

6003
06:19:06,878 --> 06:19:08,878
how we're authenticating access at the

6004
06:19:08,878 --> 06:19:10,958
moment of access so

6005
06:19:10,958 --> 06:19:12,798
you may still be user authenticated

6006
06:19:12,798 --> 06:19:14,160
reading from this space which is

6007
06:19:14,160 --> 06:19:17,360
unlinked um our aim here is to to not

6008
06:19:17,360 --> 06:19:20,320
log or persist that linkage but at this

6009
06:19:20,320 --> 06:19:23,200
stage we're not aiming to not know that

6010
06:19:23,200 --> 06:19:27,160
transiently during requests

6011
06:19:29,200 --> 06:19:31,840
and so we achieve all of that just by

6012
06:19:31,840 --> 06:19:36,000
hmacking that mailbox id

6013
06:19:37,600 --> 06:19:39,520
and so that's all of our direct data in

6014
06:19:39,520 --> 06:19:42,080
this database is now encrypted or not

6015
06:19:42,080 --> 06:19:43,120
encrypted

6016
06:19:43,120 --> 06:19:45,360
is now protected or hidden

6017
06:19:45,360 --> 06:19:47,680
um but note that we do still have one

6018
06:19:47,680 --> 06:19:50,320
global identifier here which is the

6019
06:19:50,320 --> 06:19:53,120
epoch ids and these are going to have

6020
06:19:53,120 --> 06:19:55,280
that same problem of providing a linkage

6021
06:19:55,280 --> 06:19:57,680
between the mailbox and the

6022
06:19:57,680 --> 06:20:00,638
user accounts because those epoc ids

6023
06:20:00,638 --> 06:20:03,360
were were in that meta store

6024
06:20:03,360 --> 06:20:06,000
but unlike the other identifiers um

6025
06:20:06,000 --> 06:20:08,400
we um which we need for indexing

6026
06:20:08,400 --> 06:20:09,920
and don't need to reverse this one does

6027
06:20:09,920 --> 06:20:11,440
need to be reversible because its sole

6028
06:20:11,440 --> 06:20:13,520
purpose is to tell us which key do we

6029
06:20:13,520 --> 06:20:15,840
use to decrypt that that's

6030
06:20:15,840 --> 06:20:17,920
message blob

6031
06:20:17,920 --> 06:20:19,920
so for this we introduce a new

6032
06:20:19,920 --> 06:20:21,600
incrementing what we're calling the

6033
06:20:21,600 --> 06:20:24,798
colliding id um so

6034
06:20:24,798 --> 06:20:26,400
the the idea here is that within a

6035
06:20:26,400 --> 06:20:29,040
mailbox it's unique but across mailboxes

6036
06:20:29,040 --> 06:20:31,840
they're not so if you just see hey this

6037
06:20:31,840 --> 06:20:35,040
ebook id is three you don't know whose

6038
06:20:35,040 --> 06:20:39,120
epoch 3 it is it's just somebody's um

6039
06:20:39,120 --> 06:20:40,558
and so there are going to be collisions

6040
06:20:40,558 --> 06:20:43,360
across accounts

6041
06:20:43,360 --> 06:20:44,080
so

6042
06:20:44,080 --> 06:20:45,760
to start with um

6043
06:20:45,760 --> 06:20:47,760
this is we're now needing to add this

6044
06:20:47,760 --> 06:20:50,878
colliding id to the meta store

6045
06:20:50,878 --> 06:20:52,160
this is actually just in the epoch

6046
06:20:52,160 --> 06:20:53,760
metadata so this is telling you about

6047
06:20:53,760 --> 06:20:56,718
the previous epoch

6048
06:20:56,718 --> 06:20:57,760
in theory because we're using

6049
06:20:57,760 --> 06:20:59,120
incrementing integers we could allow

6050
06:20:59,120 --> 06:21:02,878
them to just be inferred directly but

6051
06:21:02,878 --> 06:21:04,320
we didn't want to reduce that level of

6052
06:21:04,320 --> 06:21:06,718
fragility

6053
06:21:06,718 --> 06:21:07,680
um

6054
06:21:07,680 --> 06:21:08,558
and then

6055
06:21:08,558 --> 06:21:12,638
finally um we replace the guide with the

6056
06:21:12,638 --> 06:21:14,798
colliding id here

6057
06:21:14,798 --> 06:21:16,000
and

6058
06:21:16,000 --> 06:21:19,120
this gets to a point where um everything

6059
06:21:19,120 --> 06:21:20,958
in that database is protected so we can

6060
06:21:20,958 --> 06:21:23,680
now look at start uh starting to uh top

6061
06:21:23,680 --> 06:21:25,280
out our pyramid of needs and say we want

6062
06:21:25,280 --> 06:21:29,440
to secure our metadata from old devices

6063
06:21:29,440 --> 06:21:32,478
now this is a bit harder because uh the

6064
06:21:32,478 --> 06:21:35,040
metadata is currently all protected

6065
06:21:35,040 --> 06:21:36,558
using keys that are known to the remote

6066
06:21:36,558 --> 06:21:38,798
devices and we don't get to rotate them

6067
06:21:38,798 --> 06:21:40,240
because we because we're using them to

6068
06:21:40,240 --> 06:21:41,280
index

6069
06:21:41,280 --> 06:21:42,878
um

6070
06:21:42,878 --> 06:21:44,718
so at this point we want to swap out the

6071
06:21:44,718 --> 06:21:46,400
hmac for something else

6072
06:21:46,400 --> 06:21:48,160
um i what we really need is a

6073
06:21:48,160 --> 06:21:50,000
pseudo-random function that revokes

6074
06:21:50,000 --> 06:21:52,400
devices aren't able to compute

6075
06:21:52,400 --> 06:21:54,798
uh we weren't aware of anything that

6076
06:21:54,798 --> 06:21:56,320
currently exists which fulfills this

6077
06:21:56,320 --> 06:21:58,400
need so we invented something that we

6078
06:21:58,400 --> 06:22:00,240
call the oblivious revocable function

6079
06:22:00,240 --> 06:22:03,040
for this purpose

6080
06:22:03,040 --> 06:22:06,400
so to start with we'll um swap out these

6081
06:22:06,400 --> 06:22:07,360
three

6082
06:22:07,360 --> 06:22:10,080
hmac columns for this orf

6083
06:22:10,080 --> 06:22:11,440
um i've actually added an extra

6084
06:22:11,440 --> 06:22:13,680
parameter here for domain separation i'm

6085
06:22:13,680 --> 06:22:17,040
not going to go into that but that'll be

6086
06:22:17,040 --> 06:22:20,400
that'll be covered in our white paper

6087
06:22:21,280 --> 06:22:22,080
so

6088
06:22:22,080 --> 06:22:23,760
how does this work

6089
06:22:23,760 --> 06:22:26,240
well it's a prf that is computed between

6090
06:22:26,240 --> 06:22:27,680
the client and the server instead of

6091
06:22:27,680 --> 06:22:30,638
just just by one like before

6092
06:22:30,638 --> 06:22:31,920
and the goal of this is that the net

6093
06:22:31,920 --> 06:22:33,600
server never learns the inputs for the

6094
06:22:33,600 --> 06:22:35,840
same reasons as before but also that the

6095
06:22:35,840 --> 06:22:38,160
client doesn't learn the output so that

6096
06:22:38,160 --> 06:22:40,160
it can't cache something that can later

6097
06:22:40,160 --> 06:22:43,760
be used to de-anonymize that database

6098
06:22:43,760 --> 06:22:45,920
or that mailbox

6099
06:22:45,920 --> 06:22:49,280
so what we have is every client within a

6100
06:22:49,280 --> 06:22:52,160
mailbox has a different key to the prf

6101
06:22:52,160 --> 06:22:53,040
which is

6102
06:22:53,040 --> 06:22:55,360
associated with a server-side key to

6103
06:22:55,360 --> 06:22:57,600
that prf which is also linked to that

6104
06:22:57,600 --> 06:23:00,160
one client

6105
06:23:00,160 --> 06:23:02,878
between them they're

6106
06:23:02,878 --> 06:23:04,638
the client and server components within

6107
06:23:04,638 --> 06:23:05,840
each mailbox are always going to have

6108
06:23:05,840 --> 06:23:07,840
the overall same output

6109
06:23:07,840 --> 06:23:10,080
but this then allows the server to

6110
06:23:10,080 --> 06:23:11,920
revoke one specific device just by

6111
06:23:11,920 --> 06:23:13,840
deleting its half of the prf

6112
06:23:13,840 --> 06:23:16,000
key

6113
06:23:16,798 --> 06:23:19,120
while all of the other clients will

6114
06:23:19,120 --> 06:23:20,718
still function because the server still

6115
06:23:20,718 --> 06:23:24,120
does have theirs

6116
06:23:24,478 --> 06:23:27,360
so this is essentially um constructed as

6117
06:23:27,360 --> 06:23:29,920
two elliptic curve exponentiations uh

6118
06:23:29,920 --> 06:23:32,080
one computed by the clients one by the

6119
06:23:32,080 --> 06:23:35,120
server um with the hash before and after

6120
06:23:35,120 --> 06:23:38,478
um so so long as the server and client's

6121
06:23:38,478 --> 06:23:41,520
secrets um

6122
06:23:42,558 --> 06:23:44,320
sorry so long as the the server and the

6123
06:23:44,320 --> 06:23:46,320
client secrets product remains constant

6124
06:23:46,320 --> 06:23:48,320
between all of various combinations

6125
06:23:48,320 --> 06:23:49,920
they're going to get the same overall

6126
06:23:49,920 --> 06:23:51,440
output

6127
06:23:51,440 --> 06:23:53,040
and then that's how that's how we

6128
06:23:53,040 --> 06:23:57,680
achieve this consistency with revocation

6129
06:23:58,878 --> 06:24:00,160
but this does mean that we're now going

6130
06:24:00,160 --> 06:24:02,320
to need a server-side component so we're

6131
06:24:02,320 --> 06:24:05,680
adding this extra secret key to the um

6132
06:24:05,680 --> 06:24:08,878
to the meta store database

6133
06:24:11,360 --> 06:24:14,320
and i'll note um this um

6134
06:24:14,320 --> 06:24:16,798
we do have some proofs for this new um

6135
06:24:16,798 --> 06:24:19,120
this orf i uploaded them to the eprint

6136
06:24:19,120 --> 06:24:20,958
there they haven't been accepted yet but

6137
06:24:20,958 --> 06:24:22,878
hopefully they'll be online soon

6138
06:24:22,878 --> 06:24:25,840
for anyone to access

6139
06:24:25,840 --> 06:24:26,638
um

6140
06:24:26,638 --> 06:24:27,840
now it's actually worth exploring the

6141
06:24:27,840 --> 06:24:29,600
threat model a little here

6142
06:24:29,600 --> 06:24:31,360
because

6143
06:24:31,360 --> 06:24:33,520
it's

6144
06:24:33,520 --> 06:24:35,600
people often will ask well you're

6145
06:24:35,600 --> 06:24:37,760
protecting about um against the server

6146
06:24:37,760 --> 06:24:39,200
but you're relying on the server to do

6147
06:24:39,200 --> 06:24:40,878
something so what are you actually

6148
06:24:40,878 --> 06:24:42,240
achieving here

6149
06:24:42,240 --> 06:24:44,080
um

6150
06:24:44,080 --> 06:24:45,920
and and this is this is kind of a valid

6151
06:24:45,920 --> 06:24:47,200
concern because we're talking about an

6152
06:24:47,200 --> 06:24:49,280
attack which only concerns when there is

6153
06:24:49,280 --> 06:24:51,200
collusion which only occurs when there

6154
06:24:51,200 --> 06:24:53,360
is some collusion between um some

6155
06:24:53,360 --> 06:24:55,600
revoked client and the server

6156
06:24:55,600 --> 06:24:57,600
if that collusion doesn't occur then

6157
06:24:57,600 --> 06:24:59,360
keys held by the revoked client aren't

6158
06:24:59,360 --> 06:25:00,958
really relevant

6159
06:25:00,958 --> 06:25:03,280
um

6160
06:25:03,280 --> 06:25:04,080
so

6161
06:25:04,080 --> 06:25:05,520
um

6162
06:25:05,520 --> 06:25:07,200
yeah and what we realized is the key

6163
06:25:07,200 --> 06:25:09,520
question is when that collusion occurs

6164
06:25:09,520 --> 06:25:11,120
so if we look at this what we're calling

6165
06:25:11,120 --> 06:25:13,200
the happy path so we say the server is

6166
06:25:13,200 --> 06:25:15,520
not colluding with the device yet at the

6167
06:25:15,520 --> 06:25:17,280
point the hit is revoked

6168
06:25:17,280 --> 06:25:18,160
then

6169
06:25:18,160 --> 06:25:20,160
actually we achieve our um

6170
06:25:20,160 --> 06:25:21,040
our

6171
06:25:21,040 --> 06:25:23,840
goals anyway so um

6172
06:25:23,840 --> 06:25:25,520
before the device revocation the device

6173
06:25:25,520 --> 06:25:28,878
knows all of the data that's the goal um

6174
06:25:28,878 --> 06:25:31,920
at the moment it loses its access

6175
06:25:31,920 --> 06:25:33,840
um

6176
06:25:33,840 --> 06:25:35,920
after after that all of the metadata in

6177
06:25:35,920 --> 06:25:38,638
this mailbox is protected by the orp and

6178
06:25:38,638 --> 06:25:40,240
it doesn't matter what the server does

6179
06:25:40,240 --> 06:25:44,680
afterwards it can't change that

6180
06:25:45,440 --> 06:25:48,080
now we look at a different scenario so

6181
06:25:48,080 --> 06:25:50,798
the um the scenario where it all seems a

6182
06:25:50,798 --> 06:25:52,798
bit pointless um this is a side part

6183
06:25:52,798 --> 06:25:54,958
where the server is already colluding

6184
06:25:54,958 --> 06:25:58,958
um in this situation um it also

6185
06:25:58,958 --> 06:26:01,280
kind of doesn't matter because if if we

6186
06:26:01,280 --> 06:26:03,520
weren't doing all of the orf stuff

6187
06:26:03,520 --> 06:26:05,600
the metadata would be obviously visible

6188
06:26:05,600 --> 06:26:07,200
to the remote device before it gets

6189
06:26:07,200 --> 06:26:08,320
revoked

6190
06:26:08,320 --> 06:26:09,120
but

6191
06:26:09,120 --> 06:26:11,360
the metadata we're talking about here

6192
06:26:11,360 --> 06:26:14,320
like who is messaging whom at what times

6193
06:26:14,320 --> 06:26:15,760
this is stuff that's all visible to the

6194
06:26:15,760 --> 06:26:18,638
server anyway in the transport um not

6195
06:26:18,638 --> 06:26:21,040
even in the storage mechanism

6196
06:26:21,040 --> 06:26:22,400
um

6197
06:26:22,400 --> 06:26:24,478
so we're talking about in this situation

6198
06:26:24,478 --> 06:26:26,798
no extra data's

6199
06:26:26,798 --> 06:26:29,280
the extra data is kind of irrelevant

6200
06:26:29,280 --> 06:26:33,600
when it comes to this encrypted mailbox

6201
06:26:36,718 --> 06:26:38,080
so um

6202
06:26:38,080 --> 06:26:39,360
here we have

6203
06:26:39,360 --> 06:26:41,680
our final version of the mailbox mess

6204
06:26:41,680 --> 06:26:42,478
store

6205
06:26:42,478 --> 06:26:44,320
tv um this is unchanged from the

6206
06:26:44,320 --> 06:26:47,360
previous slide just without the colors

6207
06:26:47,360 --> 06:26:51,360
and likewise our mailbox db

6208
06:26:52,718 --> 06:26:53,760
um

6209
06:26:53,760 --> 06:26:55,040
something i haven't yet mentioned which

6210
06:26:55,040 --> 06:26:56,878
i should talk about is how we actually

6211
06:26:56,878 --> 06:26:59,120
add devices into this whole system

6212
06:26:59,120 --> 06:27:01,360
um so our approach here is essentially

6213
06:27:01,360 --> 06:27:04,240
to uh just share the most recent set of

6214
06:27:04,240 --> 06:27:05,280
keys

6215
06:27:05,280 --> 06:27:07,040
from a device which is currently in

6216
06:27:07,040 --> 06:27:09,040
roles with the new device

6217
06:27:09,040 --> 06:27:11,200
so that's the mailbox level keys the

6218
06:27:11,200 --> 06:27:13,840
most recent epoch keys and then going

6219
06:27:13,840 --> 06:27:15,840
through that process of enrolling the

6220
06:27:15,840 --> 06:27:19,040
new device in ora

6221
06:27:19,200 --> 06:27:20,958
then if no existing enrolled device is

6222
06:27:20,958 --> 06:27:23,040
available and we do need to support that

6223
06:27:23,040 --> 06:27:24,320
situation we

6224
06:27:24,320 --> 06:27:27,600
we allow users to um essentially bundle

6225
06:27:27,600 --> 06:27:29,360
up this bag of keys that are required

6226
06:27:29,360 --> 06:27:31,440
for enrolling into something that we

6227
06:27:31,440 --> 06:27:33,200
call a virtual device because it behaves

6228
06:27:33,200 --> 06:27:34,958
like a device in the protocol with

6229
06:27:34,958 --> 06:27:37,040
respect to epoc rotation

6230
06:27:37,040 --> 06:27:40,000
um but that all gets um encrypted saved

6231
06:27:40,000 --> 06:27:41,120
to the server

6232
06:27:41,120 --> 06:27:42,478
and then

6233
06:27:42,478 --> 06:27:44,400
the the recovery question is where that

6234
06:27:44,400 --> 06:27:46,798
key goes which i won't go to in into in

6235
06:27:46,798 --> 06:27:49,600
this talk but um we did actually mention

6236
06:27:49,600 --> 06:27:52,080
in our most recent blog post and i can

6237
06:27:52,080 --> 06:27:53,200
talk to talk to people about it

6238
06:27:53,200 --> 06:27:55,600
afterwards

6239
06:27:57,840 --> 06:28:00,080
so let's look at um at some of the

6240
06:28:00,080 --> 06:28:03,920
trade-offs we've made so um first up um

6241
06:28:03,920 --> 06:28:05,680
so message content is the primary thing

6242
06:28:05,680 --> 06:28:06,958
we're trying to protect i've talked a

6243
06:28:06,958 --> 06:28:08,638
lot about metadata but message content

6244
06:28:08,638 --> 06:28:10,878
is the really important bit

6245
06:28:10,878 --> 06:28:11,920
um

6246
06:28:11,920 --> 06:28:13,840
and these aren't getting re-encrypted

6247
06:28:13,840 --> 06:28:16,798
when the epoch rotates um so devices get

6248
06:28:16,798 --> 06:28:19,120
removed the meth the old messages are

6249
06:28:19,120 --> 06:28:20,478
still encrypted under keys that they

6250
06:28:20,478 --> 06:28:22,320
already had access to

6251
06:28:22,320 --> 06:28:25,200
now this is a bit of a trade-off um but

6252
06:28:25,200 --> 06:28:27,280
um these are ultimately devices which

6253
06:28:27,280 --> 06:28:28,958
did have access to that data and could

6254
06:28:28,958 --> 06:28:31,280
already have cached it and

6255
06:28:31,280 --> 06:28:33,680
at the scale we're talking about and

6256
06:28:33,680 --> 06:28:35,920
um but particularly the size of some

6257
06:28:35,920 --> 06:28:37,440
people's mailboxes

6258
06:28:37,440 --> 06:28:39,200
if we were to ask them to download all

6259
06:28:39,200 --> 06:28:40,958
of that data and re-encrypt it it just

6260
06:28:40,958 --> 06:28:43,360
wouldn't um it wouldn't be practical

6261
06:28:43,360 --> 06:28:45,200
we're talking particularly about many

6262
06:28:45,200 --> 06:28:48,638
low-end devices um in the world

6263
06:28:48,638 --> 06:28:50,638
um we do have some thoughts on on how we

6264
06:28:50,638 --> 06:28:52,718
can add some defense in depth actually

6265
06:28:52,718 --> 06:28:55,520
reusing orf in a slightly different way

6266
06:28:55,520 --> 06:28:59,280
um but we're not applying that yet

6267
06:28:59,440 --> 06:29:01,920
next up um

6268
06:29:01,920 --> 06:29:02,638
we

6269
06:29:02,638 --> 06:29:03,840
we're talking about protecting the

6270
06:29:03,840 --> 06:29:05,600
mailbox structure which of my unlinking

6271
06:29:05,600 --> 06:29:08,240
from the account but there is still that

6272
06:29:08,240 --> 06:29:10,478
mailbox structure which is still visible

6273
06:29:10,478 --> 06:29:12,080
there

6274
06:29:12,080 --> 06:29:13,760
so and

6275
06:29:13,760 --> 06:29:15,520
we haven't really been able to protect

6276
06:29:15,520 --> 06:29:18,240
the structure itself overall apart from

6277
06:29:18,240 --> 06:29:20,718
through this unlinking step

6278
06:29:20,718 --> 06:29:22,878
and then finally uh we're using order

6279
06:29:22,878 --> 06:29:24,958
preserving encryption um it's obviously

6280
06:29:24,958 --> 06:29:26,878
weaker than other forms of cryptographic

6281
06:29:26,878 --> 06:29:29,760
protections um and so we're getting

6282
06:29:29,760 --> 06:29:31,920
limited protections of the timestamps

6283
06:29:31,920 --> 06:29:34,320
here um and including against revoked

6284
06:29:34,320 --> 06:29:36,798
devices

6285
06:29:39,040 --> 06:29:39,920
so

6286
06:29:39,920 --> 06:29:43,600
finally um so some of our thoughts on on

6287
06:29:43,600 --> 06:29:45,760
next steps and future work

6288
06:29:45,760 --> 06:29:47,600
so the first one is we need to deploy

6289
06:29:47,600 --> 06:29:49,760
this whole thing at scale um

6290
06:29:49,760 --> 06:29:51,040
we're talking about a really complex

6291
06:29:51,040 --> 06:29:52,080
system

6292
06:29:52,080 --> 06:29:54,878
it's gone through internal testing it's

6293
06:29:54,878 --> 06:29:57,040
just beginning it's public testing

6294
06:29:57,040 --> 06:29:58,478
we don't really know how it's going to

6295
06:29:58,478 --> 06:30:00,958
perform um or if we're going to have

6296
06:30:00,958 --> 06:30:03,760
scalability challenges

6297
06:30:03,760 --> 06:30:05,600
and of course as we're doing this we

6298
06:30:05,600 --> 06:30:07,760
want to fully deploy all this whole

6299
06:30:07,760 --> 06:30:09,200
protocol that i've talked about make

6300
06:30:09,200 --> 06:30:12,878
sure we're deploying epoch rotation um

6301
06:30:12,878 --> 06:30:15,120
this extra um

6302
06:30:15,120 --> 06:30:18,000
reuse of the orf to add defense in depth

6303
06:30:18,000 --> 06:30:18,878
to

6304
06:30:18,878 --> 06:30:22,000
ciphertext etc

6305
06:30:22,000 --> 06:30:23,520
there's still a lot of work for us to do

6306
06:30:23,520 --> 06:30:25,760
in getting this thing productionized

6307
06:30:25,760 --> 06:30:26,958
um

6308
06:30:26,958 --> 06:30:28,798
next up there are

6309
06:30:28,798 --> 06:30:30,638
kind of innate inefficiencies here

6310
06:30:30,638 --> 06:30:32,638
inefficiencies here for example if

6311
06:30:32,638 --> 06:30:34,478
you're using it across multiple devices

6312
06:30:34,478 --> 06:30:35,760
where um

6313
06:30:35,760 --> 06:30:37,360
we're asking you to you'll receive the

6314
06:30:37,360 --> 06:30:38,718
message on all of them and then all of

6315
06:30:38,718 --> 06:30:40,240
those devices are going to upload that

6316
06:30:40,240 --> 06:30:42,080
message um

6317
06:30:42,080 --> 06:30:43,760
how important this is as an issue we

6318
06:30:43,760 --> 06:30:46,558
don't necessarily know yet um but

6319
06:30:46,558 --> 06:30:47,360
um

6320
06:30:47,360 --> 06:30:48,798
there are going to be some

6321
06:30:48,798 --> 06:30:50,558
some clear places where

6322
06:30:50,558 --> 06:30:53,120
we end up wanting to

6323
06:30:53,120 --> 06:30:54,558
make make sure we're operating well at

6324
06:30:54,558 --> 06:30:56,798
scale

6325
06:30:56,798 --> 06:30:58,558
next up i mentioned that we're storing

6326
06:30:58,558 --> 06:31:00,558
things in an unlinked form but

6327
06:31:00,558 --> 06:31:03,360
ultimately as i mentioned requests are

6328
06:31:03,360 --> 06:31:05,600
still user authenticated

6329
06:31:05,600 --> 06:31:07,520
during queries

6330
06:31:07,520 --> 06:31:09,280
and indeed we actually need this to be

6331
06:31:09,280 --> 06:31:12,080
the case because we've got these orf

6332
06:31:12,080 --> 06:31:14,320
keys on the server side and we need to

6333
06:31:14,320 --> 06:31:16,798
be able to use the correct one for the

6334
06:31:16,798 --> 06:31:18,840
device which is accessing

6335
06:31:18,840 --> 06:31:21,600
them but we do want to do better and we

6336
06:31:21,600 --> 06:31:22,798
we have a bit of a sketch of how this

6337
06:31:22,798 --> 06:31:24,798
might happen um i haven't fleshed it out

6338
06:31:24,798 --> 06:31:26,878
yet um

6339
06:31:26,878 --> 06:31:27,600
and

6340
06:31:27,600 --> 06:31:29,840
yeah so improv improving that's

6341
06:31:29,840 --> 06:31:32,000
that authentication getting more greater

6342
06:31:32,000 --> 06:31:36,080
and linkage um would be really good

6343
06:31:36,080 --> 06:31:38,400
and then finally it's actually possible

6344
06:31:38,400 --> 06:31:40,558
that this setting for the oblivious

6345
06:31:40,558 --> 06:31:42,478
revocable function is something that

6346
06:31:42,478 --> 06:31:44,400
could be usefully applied to other

6347
06:31:44,400 --> 06:31:46,320
primitives uh this is something

6348
06:31:46,320 --> 06:31:47,840
essentially we've applied this setting

6349
06:31:47,840 --> 06:31:49,280
to the prf

6350
06:31:49,280 --> 06:31:51,680
um within our current design the most

6351
06:31:51,680 --> 06:31:54,160
obvious place where we um we could we

6352
06:31:54,160 --> 06:31:56,878
could be improving is ope maybe

6353
06:31:56,878 --> 06:31:59,440
similar setting could apply there

6354
06:31:59,440 --> 06:32:02,920
but we don't know

6355
06:32:03,920 --> 06:32:07,120
so yeah to to wrap this up um a

6356
06:32:07,120 --> 06:32:10,478
we're building our e2e mailbox um for

6357
06:32:10,478 --> 06:32:12,320
messenger um it's been in the works for

6358
06:32:12,320 --> 06:32:14,718
a long time really excited to be testing

6359
06:32:14,718 --> 06:32:16,558
it talking about it with you

6360
06:32:16,558 --> 06:32:19,600
um and uh yeah hoping that this is going

6361
06:32:19,600 --> 06:32:21,360
to be a really cool part of our overall

6362
06:32:21,360 --> 06:32:24,558
end-to-end encryption story at meta

6363
06:32:24,558 --> 06:32:25,760
given the long-term nature of the

6364
06:32:25,760 --> 06:32:28,638
storage um we're keen to protect content

6365
06:32:28,638 --> 06:32:31,600
and metadata um even metadata that the

6366
06:32:31,600 --> 06:32:33,840
platform might already observe through

6367
06:32:33,840 --> 06:32:37,200
other um other channels

6368
06:32:38,080 --> 06:32:39,600
and we think that the precise problem

6369
06:32:39,600 --> 06:32:41,360
that we've ended up addressing um

6370
06:32:41,360 --> 06:32:43,760
actually has some novel properties um so

6371
06:32:43,760 --> 06:32:45,360
yeah we're really keen for

6372
06:32:45,360 --> 06:32:47,840
feedback from this community and on our

6373
06:32:47,840 --> 06:32:51,200
approach and how we might do better

6374
06:32:52,320 --> 06:32:57,079
thank you very much and any questions

6375
06:33:00,160 --> 06:33:01,520
okay so we're running a bit behind but

6376
06:33:01,520 --> 06:33:03,920
maybe we have time for one question

6377
06:33:03,920 --> 06:33:08,199
uh maybe i'll go with sincerely

6378
06:33:16,718 --> 06:33:19,600
uh if i heard correctly the message box

6379
06:33:19,600 --> 06:33:22,878
id now becomes a better token

6380
06:33:22,878 --> 06:33:26,638
um yes so the the mailbox id passed

6381
06:33:26,638 --> 06:33:29,520
through the orf um

6382
06:33:29,520 --> 06:33:31,360
effectively is how we're authenticating

6383
06:33:31,360 --> 06:33:33,360
that this user is connecting to the

6384
06:33:33,360 --> 06:33:36,080
correct mailbox so if it leaks

6385
06:33:36,080 --> 06:33:39,120
then you how do you rotate it or

6386
06:33:39,120 --> 06:33:42,000
how do you protect from that

6387
06:33:42,000 --> 06:33:44,558
so at this point um

6388
06:33:44,558 --> 06:33:46,400
because we're using orf rather than the

6389
06:33:46,400 --> 06:33:48,478
hmac um

6390
06:33:48,478 --> 06:33:51,520
and we did have proofs in our orf that

6391
06:33:51,520 --> 06:33:53,040
the server-side

6392
06:33:53,040 --> 06:33:55,920
computation is is a prf itself

6393
06:33:55,920 --> 06:33:58,240
um i think even if the raw value of that

6394
06:33:58,240 --> 06:34:00,638
leaks um you'd have to pre-image that

6395
06:34:00,638 --> 06:34:04,478
prf to be able to um to perform that

6396
06:34:04,478 --> 06:34:06,798
attack

6397
06:34:07,280 --> 06:34:08,718
thanks

6398
06:34:08,718 --> 06:34:10,400
all right so uh in the interest of time

6399
06:34:10,400 --> 06:34:12,080
we're gonna move on to the to the next

6400
06:34:12,080 --> 06:34:16,200
talk uh let's think john again

6401
06:35:21,840 --> 06:35:23,280
all right so our last talk of the day is

6402
06:35:23,280 --> 06:35:25,920
going to be given by uh tariq motas so

6403
06:35:25,920 --> 06:35:27,840
tariq is a

6404
06:35:27,840 --> 06:35:29,840
principal research scientist at mongodb

6405
06:35:29,840 --> 06:35:30,958
and he's going to be telling us about

6406
06:35:30,958 --> 06:35:35,039
mongodb's variable encryption

6407
06:35:42,718 --> 06:35:45,958
yeah perfect

6408
06:35:46,400 --> 06:35:49,120
yeah thanks jennifer for the intro

6409
06:35:49,120 --> 06:35:51,840
so i'm i'm very happy to be here

6410
06:35:51,840 --> 06:35:53,280
uh today to

6411
06:35:53,280 --> 06:35:55,040
uh to tell you a little bit more about

6412
06:35:55,040 --> 06:35:57,040
uh mongodb

6413
06:35:57,040 --> 06:35:58,638
queryable encryption

6414
06:35:58,638 --> 06:36:02,638
so um so as ken mentioned in earlier uh

6415
06:36:02,638 --> 06:36:05,760
in the session um in june mongodb made

6416
06:36:05,760 --> 06:36:08,478
the announcement um that queryable

6417
06:36:08,478 --> 06:36:10,240
encryption will be

6418
06:36:10,240 --> 06:36:11,840
available

6419
06:36:11,840 --> 06:36:14,798
in preview in the 6.0 release and at a

6420
06:36:14,798 --> 06:36:16,878
very high level queryable encryption is

6421
06:36:16,878 --> 06:36:18,240
kind of like a

6422
06:36:18,240 --> 06:36:20,080
technique that allows mongodb customers

6423
06:36:20,080 --> 06:36:21,280
to encrypt

6424
06:36:21,280 --> 06:36:23,040
to query um

6425
06:36:23,040 --> 06:36:24,798
android encryption

6426
06:36:24,798 --> 06:36:26,878
data

6427
06:36:26,878 --> 06:36:29,120
so uh

6428
06:36:29,120 --> 06:36:30,160
koreable encryption once the

6429
06:36:30,160 --> 06:36:31,840
announcement was made really received

6430
06:36:31,840 --> 06:36:35,920
quite a positive uh uh uh was rece was

6431
06:36:35,920 --> 06:36:37,440
received quite positively and we felt

6432
06:36:37,440 --> 06:36:39,200
really that the crypto community there

6433
06:36:39,200 --> 06:36:40,638
is some excitement

6434
06:36:40,638 --> 06:36:42,638
and i'm very happy and excited today to

6435
06:36:42,638 --> 06:36:43,920
share with you a little bit more about

6436
06:36:43,920 --> 06:36:46,400
how queryable encryption works

6437
06:36:46,400 --> 06:36:47,760
and this is something that can also

6438
06:36:47,760 --> 06:36:49,840
touch on so queryable encryption in the

6439
06:36:49,840 --> 06:36:51,840
product as any product

6440
06:36:51,840 --> 06:36:53,280
there are so many

6441
06:36:53,280 --> 06:36:55,680
parts with different cross teams

6442
06:36:55,680 --> 06:36:57,280
so there was of course the

6443
06:36:57,280 --> 06:36:59,760
the product team the crypto team and

6444
06:36:59,760 --> 06:37:02,320
several engineering teams including uh

6445
06:37:02,320 --> 06:37:04,478
but not limited to to server security

6446
06:37:04,478 --> 06:37:06,400
query and drivers and this is really a

6447
06:37:06,400 --> 06:37:07,760
massive massive

6448
06:37:07,760 --> 06:37:10,878
involvement from from around 40 or 50 uh

6449
06:37:10,878 --> 06:37:12,080
engineers

6450
06:37:12,080 --> 06:37:14,320
so for this talk we will be focusing

6451
06:37:14,320 --> 06:37:17,600
more on the crypto crypto piece and in

6452
06:37:17,600 --> 06:37:19,760
particular in this talk we will be

6453
06:37:19,760 --> 06:37:21,680
looking at this

6454
06:37:21,680 --> 06:37:23,600
at this aspect from two different

6455
06:37:23,600 --> 06:37:25,520
questions so the first question

6456
06:37:25,520 --> 06:37:27,200
that we are interested

6457
06:37:27,200 --> 06:37:29,440
in answering is

6458
06:37:29,440 --> 06:37:32,240
what are really the the challenges uh

6459
06:37:32,240 --> 06:37:34,240
signia and i have faced while we were

6460
06:37:34,240 --> 06:37:36,718
designing uh the the encrypted search

6461
06:37:36,718 --> 06:37:38,080
protocol

6462
06:37:38,080 --> 06:37:40,638
technical constraints the design

6463
06:37:40,638 --> 06:37:41,920
requirements

6464
06:37:41,920 --> 06:37:43,360
all of that and

6465
06:37:43,360 --> 06:37:46,240
and actually can touch on some of them

6466
06:37:46,240 --> 06:37:48,400
and the second piece of or second part

6467
06:37:48,400 --> 06:37:50,878
of the talk will be on uh how does it

6468
06:37:50,878 --> 06:37:54,080
work um and hopefully you will have a

6469
06:37:54,080 --> 06:37:56,160
better idea about how it works

6470
06:37:56,160 --> 06:37:59,120
by the end of this uh of this shock

6471
06:37:59,120 --> 06:38:00,240
so

6472
06:38:00,240 --> 06:38:02,478
let's go over uh the the technical

6473
06:38:02,478 --> 06:38:04,958
constraints that we we actually like we

6474
06:38:04,958 --> 06:38:07,520
we were faced with when we were

6475
06:38:07,520 --> 06:38:08,558
actually

6476
06:38:08,558 --> 06:38:09,680
designing

6477
06:38:09,680 --> 06:38:11,280
the the protocol

6478
06:38:11,280 --> 06:38:12,240
so

6479
06:38:12,240 --> 06:38:14,558
most of you like probably know that most

6480
06:38:14,558 --> 06:38:16,320
of the dynamic encrypted search

6481
06:38:16,320 --> 06:38:18,240
protocols

6482
06:38:18,240 --> 06:38:21,600
do require like most of them uh or maybe

6483
06:38:21,600 --> 06:38:23,760
like most most but many of them do

6484
06:38:23,760 --> 06:38:26,160
require states and for those of you who

6485
06:38:26,160 --> 06:38:27,360
don't know what the state is is

6486
06:38:27,360 --> 06:38:29,520
basically like a piece of data that the

6487
06:38:29,520 --> 06:38:31,760
client keeps and it gets updated after

6488
06:38:31,760 --> 06:38:34,000
every kind of like addition or deletions

6489
06:38:34,000 --> 06:38:36,878
and this is really kept at the client

6490
06:38:36,878 --> 06:38:37,920
and

6491
06:38:37,920 --> 06:38:40,240
so well the first concert we were hit

6492
06:38:40,240 --> 06:38:42,798
with no mongodb clients

6493
06:38:42,798 --> 06:38:45,520
must be stateless there is no state

6494
06:38:45,520 --> 06:38:48,240
that we should keep at any point in time

6495
06:38:48,240 --> 06:38:49,440
at the client

6496
06:38:49,440 --> 06:38:50,320
and

6497
06:38:50,320 --> 06:38:51,840
we were really surprised like at the

6498
06:38:51,840 --> 06:38:53,680
very beginning how can we you know

6499
06:38:53,680 --> 06:38:55,280
design something without without the

6500
06:38:55,280 --> 06:38:57,600
state uh especially when it's dynamic

6501
06:38:57,600 --> 06:38:59,040
and we were when we were talking to the

6502
06:38:59,040 --> 06:39:00,798
engineers we get to learn why actually

6503
06:39:00,798 --> 06:39:02,878
this is not something that we can afford

6504
06:39:02,878 --> 06:39:05,200
and one of the reasons is that clients

6505
06:39:05,200 --> 06:39:08,080
cannot persist date they cannot like

6506
06:39:08,080 --> 06:39:11,200
clients are super lightweight uh think

6507
06:39:11,200 --> 06:39:11,920
of

6508
06:39:11,920 --> 06:39:13,600
um that they are running really on

6509
06:39:13,600 --> 06:39:15,680
short-lived kind of like architectures

6510
06:39:15,680 --> 06:39:17,680
think of containers virtual machines

6511
06:39:17,680 --> 06:39:19,120
that they can really turn off at any

6512
06:39:19,120 --> 06:39:20,400
point in time

6513
06:39:20,400 --> 06:39:21,360
and

6514
06:39:21,360 --> 06:39:22,718
and really like if you are thinking

6515
06:39:22,718 --> 06:39:24,638
about kind of like a containers kind of

6516
06:39:24,638 --> 06:39:26,160
like a

6517
06:39:26,160 --> 06:39:27,840
situation

6518
06:39:27,840 --> 06:39:30,638
if they turn off at any expected time or

6519
06:39:30,638 --> 06:39:32,080
they fail

6520
06:39:32,080 --> 06:39:34,400
they won't actually store the data in a

6521
06:39:34,400 --> 06:39:36,638
maybe correct way and we all know that

6522
06:39:36,638 --> 06:39:38,320
if you are just missing some bit of

6523
06:39:38,320 --> 06:39:39,680
information or if you are pushing the

6524
06:39:39,680 --> 06:39:40,798
state in

6525
06:39:40,798 --> 06:39:43,200
in out of sync situation this might lead

6526
06:39:43,200 --> 06:39:45,600
to some really serious correctness but

6527
06:39:45,600 --> 06:39:47,280
also security issues

6528
06:39:47,280 --> 06:39:49,360
so there are really good reasons why

6529
06:39:49,360 --> 06:39:50,798
engineers they are really they were

6530
06:39:50,798 --> 06:39:53,840
really pushing us uh from uh away from

6531
06:39:53,840 --> 06:39:56,638
the from having a stateful uh situation

6532
06:39:56,638 --> 06:39:59,040
so this is one of the first constraints

6533
06:39:59,040 --> 06:40:00,000
we were

6534
06:40:00,000 --> 06:40:03,440
hit with so second constraint

6535
06:40:03,440 --> 06:40:05,120
uh so

6536
06:40:05,120 --> 06:40:07,040
some encrypted search protocols they do

6537
06:40:07,040 --> 06:40:08,958
require interaction and especially the

6538
06:40:08,958 --> 06:40:11,520
oram kind of like based encrypted search

6539
06:40:11,520 --> 06:40:13,680
protocols they do require interaction

6540
06:40:13,680 --> 06:40:15,760
and by interaction what we what we mean

6541
06:40:15,760 --> 06:40:17,440
here is

6542
06:40:17,440 --> 06:40:19,120
you know there are some back and forth

6543
06:40:19,120 --> 06:40:20,558
messages that they are sent between the

6544
06:40:20,558 --> 06:40:22,958
client and the server uh in order to get

6545
06:40:22,958 --> 06:40:24,840
the full the full the

6546
06:40:24,840 --> 06:40:26,958
response and

6547
06:40:26,958 --> 06:40:28,478
you may have already guessed so the

6548
06:40:28,478 --> 06:40:30,240
second concern that we will hit with is

6549
06:40:30,240 --> 06:40:32,958
that the the design

6550
06:40:32,958 --> 06:40:34,798
uh must be

6551
06:40:34,798 --> 06:40:36,240
non-interactive

6552
06:40:36,240 --> 06:40:38,000
and here again there are really good

6553
06:40:38,000 --> 06:40:40,240
reasons for for the second constraints

6554
06:40:40,240 --> 06:40:41,440
and when we were

6555
06:40:41,440 --> 06:40:43,680
talking to the to the engineers so the

6556
06:40:43,680 --> 06:40:45,840
first thing that they brought us i mean

6557
06:40:45,840 --> 06:40:47,760
we probably most of us know that know

6558
06:40:47,760 --> 06:40:49,600
about this but over the public internet

6559
06:40:49,600 --> 06:40:51,760
so this is a database that it's managed

6560
06:40:51,760 --> 06:40:52,840
by cloud

6561
06:40:52,840 --> 06:40:56,000
providers and it may sit really far away

6562
06:40:56,000 --> 06:40:58,638
from you and when we think about this in

6563
06:40:58,638 --> 06:41:01,120
in physical distance and this might be a

6564
06:41:01,120 --> 06:41:02,878
lot in terms of round trips of

6565
06:41:02,878 --> 06:41:04,558
communication so we are talking about

6566
06:41:04,558 --> 06:41:08,160
sometimes 50 100 milliseconds of ping

6567
06:41:08,160 --> 06:41:10,400
and imagine that your protocol is kind

6568
06:41:10,400 --> 06:41:13,440
of like involving 10 or 20 round trips

6569
06:41:13,440 --> 06:41:15,120
we are already talking about two seconds

6570
06:41:15,120 --> 06:41:17,840
or maybe more of just interaction we are

6571
06:41:17,840 --> 06:41:19,680
not even talking about the time to

6572
06:41:19,680 --> 06:41:22,160
process on the server or on the client

6573
06:41:22,160 --> 06:41:24,638
so this is one aspect of why

6574
06:41:24,638 --> 06:41:26,558
interaction wasn't

6575
06:41:26,558 --> 06:41:28,798
uh wasn't great but there are actually

6576
06:41:28,798 --> 06:41:30,080
more to this

6577
06:41:30,080 --> 06:41:32,878
so current drivers and also the query

6578
06:41:32,878 --> 06:41:35,440
execution which is at the at the

6579
06:41:35,440 --> 06:41:37,520
database uh

6580
06:41:37,520 --> 06:41:40,878
it will cost a lot to extend it to make

6581
06:41:40,878 --> 06:41:42,000
sure that

6582
06:41:42,000 --> 06:41:44,160
interaction can be supported and this is

6583
06:41:44,160 --> 06:41:45,680
something it's not something that it's

6584
06:41:45,680 --> 06:41:47,040
really easy to implement we are really

6585
06:41:47,040 --> 06:41:49,280
talking about commercial databases

6586
06:41:49,280 --> 06:41:51,520
asking mention which is available to i

6587
06:41:51,520 --> 06:41:54,000
don't know how many uh developers and

6588
06:41:54,000 --> 06:41:56,478
customers so it will take probably like

6589
06:41:56,478 --> 06:41:58,320
two years plus in order to do it

6590
06:41:58,320 --> 06:42:00,798
correctly so it's very expensive if not

6591
06:42:00,798 --> 06:42:02,878
extremely expensive

6592
06:42:02,878 --> 06:42:06,638
so so this might sound like really kind

6593
06:42:06,638 --> 06:42:07,600
of like

6594
06:42:07,600 --> 06:42:09,680
non-intuitive but

6595
06:42:09,680 --> 06:42:11,680
some actually of the encrypted search

6596
06:42:11,680 --> 06:42:14,558
protocols and especially the recent ones

6597
06:42:14,558 --> 06:42:16,718
they they do introduce what we call

6598
06:42:16,718 --> 06:42:19,440
false positives or false negatives and

6599
06:42:19,440 --> 06:42:20,320
this

6600
06:42:20,320 --> 06:42:22,638
this somehow helps especially to reduce

6601
06:42:22,638 --> 06:42:24,878
leakage and this is something that kind

6602
06:42:24,878 --> 06:42:26,958
of like started to be in more and more

6603
06:42:26,958 --> 06:42:29,040
research papers like to two or three

6604
06:42:29,040 --> 06:42:30,400
years uh

6605
06:42:30,400 --> 06:42:32,638
the last two or three years so guess

6606
06:42:32,638 --> 06:42:35,040
what again so this is this happens to be

6607
06:42:35,040 --> 06:42:38,160
a concert and uh yeah here it's just

6608
06:42:38,160 --> 06:42:40,000
filtering pushing the false positives

6609
06:42:40,000 --> 06:42:41,920
and this is a concept clients cannot

6610
06:42:41,920 --> 06:42:44,080
feature the date and this is really kind

6611
06:42:44,080 --> 06:42:46,000
of like you know you say why like it's

6612
06:42:46,000 --> 06:42:48,558
simple filtering why not can we can't we

6613
06:42:48,558 --> 06:42:51,280
do it on the on the client side

6614
06:42:51,280 --> 06:42:53,040
and again there are really good reasons

6615
06:42:53,040 --> 06:42:54,958
for that and

6616
06:42:54,958 --> 06:42:57,840
the databases do not support filtering

6617
06:42:57,840 --> 06:42:59,680
because it's super expensive to

6618
06:42:59,680 --> 06:43:02,000
implement correctly because it so

6619
06:43:02,000 --> 06:43:03,440
because if you think about a simple

6620
06:43:03,440 --> 06:43:05,840
query uh okay find me some documents and

6621
06:43:05,840 --> 06:43:07,920
then i filter for some uh

6622
06:43:07,920 --> 06:43:10,080
you know some three out of four maybe

6623
06:43:10,080 --> 06:43:11,920
that's that's easy but database is

6624
06:43:11,920 --> 06:43:13,520
really those reports very complex

6625
06:43:13,520 --> 06:43:15,360
queries like imagine a query which is

6626
06:43:15,360 --> 06:43:17,760
like a boolean expression of many

6627
06:43:17,760 --> 06:43:19,920
clauses and then so the clients need to

6628
06:43:19,920 --> 06:43:22,160
parse identify which one do not meet

6629
06:43:22,160 --> 06:43:24,160
which clause and just this advanced

6630
06:43:24,160 --> 06:43:26,160
person it's too hard to implement on the

6631
06:43:26,160 --> 06:43:27,440
client side

6632
06:43:27,440 --> 06:43:29,840
to be generic and to work correctly and

6633
06:43:29,840 --> 06:43:31,520
also like it will add some non-trivial

6634
06:43:31,520 --> 06:43:33,520
computation on the clients so this is

6635
06:43:33,520 --> 06:43:35,360
something that the engineers told us

6636
06:43:35,360 --> 06:43:37,920
look this is no way we can implement

6637
06:43:37,920 --> 06:43:39,120
a post

6638
06:43:39,120 --> 06:43:41,120
filtering at the client side this will

6639
06:43:41,120 --> 06:43:43,600
take a two plus year of implementation

6640
06:43:43,600 --> 06:43:44,638
and this

6641
06:43:44,638 --> 06:43:45,840
speculation

6642
06:43:45,840 --> 06:43:48,638
so so already like three constraints

6643
06:43:48,638 --> 06:43:50,878
those are purely technical so any design

6644
06:43:50,878 --> 06:43:52,638
that we need to come up with

6645
06:43:52,638 --> 06:43:53,920
has to

6646
06:43:53,920 --> 06:43:55,600
fit these three cons

6647
06:43:55,600 --> 06:43:57,360
so now let's switch gears and look at

6648
06:43:57,360 --> 06:43:59,440
the design requirements

6649
06:43:59,440 --> 06:44:02,400
uh of of of the scheme and let's start

6650
06:44:02,400 --> 06:44:04,400
with a part that i call legacy

6651
06:44:04,400 --> 06:44:06,718
friendliness so by legacy friendliness

6652
06:44:06,718 --> 06:44:07,840
here

6653
06:44:07,840 --> 06:44:10,160
i mean

6654
06:44:10,160 --> 06:44:12,400
the the the property or the fact that

6655
06:44:12,400 --> 06:44:14,798
whatever we need to implement needs to

6656
06:44:14,798 --> 06:44:16,798
to have the same guarantees as a

6657
06:44:16,798 --> 06:44:20,080
plaintext database so namely for example

6658
06:44:20,080 --> 06:44:21,920
any encrypted search protocol that we

6659
06:44:21,920 --> 06:44:24,638
need to implement has to

6660
06:44:24,638 --> 06:44:26,320
allow for concurrent

6661
06:44:26,320 --> 06:44:29,840
uh operations concurrent updates ads

6662
06:44:29,840 --> 06:44:32,718
queries and deeds so this is a it's just

6663
06:44:32,718 --> 06:44:34,558
a must like there is no

6664
06:44:34,558 --> 06:44:36,638
customer or developer will will just say

6665
06:44:36,638 --> 06:44:38,478
ah i'm fine losing my concurrent

6666
06:44:38,478 --> 06:44:40,478
accesses that's just not possible

6667
06:44:40,478 --> 06:44:42,400
not possible

6668
06:44:42,400 --> 06:44:43,200
two

6669
06:44:43,200 --> 06:44:47,360
we need to build a scheme that has um

6670
06:44:47,360 --> 06:44:49,040
that maintains actually the same

6671
06:44:49,040 --> 06:44:51,120
correctness guarantees as a plain

6672
06:44:51,120 --> 06:44:53,520
excitability and this actually it might

6673
06:44:53,520 --> 06:44:55,760
seem simple but it's really more nuanced

6674
06:44:55,760 --> 06:44:57,840
than that because what you may think of

6675
06:44:57,840 --> 06:44:59,600
what correctness is

6676
06:44:59,600 --> 06:45:01,360
and and this is really a personal

6677
06:45:01,360 --> 06:45:04,000
experience what what i talked about what

6678
06:45:04,000 --> 06:45:05,840
is correctness actually it might be

6679
06:45:05,840 --> 06:45:07,360
different from what is correctness from

6680
06:45:07,360 --> 06:45:09,520
a plaintext database in some complex

6681
06:45:09,520 --> 06:45:11,760
queries and you really need to feed that

6682
06:45:11,760 --> 06:45:13,520
correctness guarantees and this is

6683
06:45:13,520 --> 06:45:16,000
something that it wasn't uh trivial so

6684
06:45:16,000 --> 06:45:17,840
of course like no false negatives

6685
06:45:17,840 --> 06:45:18,798
because

6686
06:45:18,798 --> 06:45:20,798
the database wants i have you know just

6687
06:45:20,798 --> 06:45:22,320
to maintain correctness you shouldn't

6688
06:45:22,320 --> 06:45:24,718
like say uh here is your response that

6689
06:45:24,718 --> 06:45:27,600
it's missing 150 you know documents or

6690
06:45:27,600 --> 06:45:29,120
something like that that's just not

6691
06:45:29,120 --> 06:45:30,718
possible

6692
06:45:30,718 --> 06:45:31,440
and

6693
06:45:31,440 --> 06:45:32,638
uh three

6694
06:45:32,638 --> 06:45:34,878
so this is really legacy in the sense

6695
06:45:34,878 --> 06:45:36,080
that

6696
06:45:36,080 --> 06:45:38,240
mongodb mongodb is a database that

6697
06:45:38,240 --> 06:45:39,760
already exists and there are so many

6698
06:45:39,760 --> 06:45:41,760
protocols that they are built in it for

6699
06:45:41,760 --> 06:45:43,440
example replication

6700
06:45:43,440 --> 06:45:46,320
charging to scale so our protocol had to

6701
06:45:46,320 --> 06:45:49,040
fit nicely with the existing protocols

6702
06:45:49,040 --> 06:45:51,360
that that we have here so uh our

6703
06:45:51,360 --> 06:45:53,920
protocol needs to to work with

6704
06:45:53,920 --> 06:45:55,920
different replicas sets with sharding

6705
06:45:55,920 --> 06:45:57,600
and so on and so forth but one thing

6706
06:45:57,600 --> 06:45:59,840
that's really uh

6707
06:45:59,840 --> 06:46:01,280
that was interesting from an encrypted

6708
06:46:01,280 --> 06:46:03,360
search perspective is that for example

6709
06:46:03,360 --> 06:46:05,200
the secondaries of mongodb they don't

6710
06:46:05,200 --> 06:46:06,798
support rights

6711
06:46:06,798 --> 06:46:07,680
so

6712
06:46:07,680 --> 06:46:09,600
and you may find be familiar with some

6713
06:46:09,600 --> 06:46:11,840
protocols that they do modify when you

6714
06:46:11,840 --> 06:46:14,478
do our rights or when you do a read so

6715
06:46:14,478 --> 06:46:16,320
for example an oran base like something

6716
06:46:16,320 --> 06:46:18,240
when you just do a read you actually

6717
06:46:18,240 --> 06:46:20,798
write to the structure uh so this is not

6718
06:46:20,798 --> 06:46:22,240
possible

6719
06:46:22,240 --> 06:46:24,080
so

6720
06:46:24,080 --> 06:46:25,840
the second part of design requirement

6721
06:46:25,840 --> 06:46:28,320
this is like we are more familiar with

6722
06:46:28,320 --> 06:46:31,440
which is efficiency we want the design

6723
06:46:31,440 --> 06:46:33,520
to be efficient and by efficient we mean

6724
06:46:33,520 --> 06:46:35,120
sublinear search

6725
06:46:35,120 --> 06:46:36,558
just anything linear is just not

6726
06:46:36,558 --> 06:46:37,680
possible

6727
06:46:37,680 --> 06:46:40,160
we are talking about a database with a

6728
06:46:40,160 --> 06:46:42,080
really high throughput

6729
06:46:42,080 --> 06:46:43,920
queries like just linear is just just

6730
06:46:43,920 --> 06:46:46,558
impossible so sublinear was a was a was

6731
06:46:46,558 --> 06:46:47,600
a you know

6732
06:46:47,600 --> 06:46:49,760
a solid requirement here and of course

6733
06:46:49,760 --> 06:46:51,360
like we want something with minimal

6734
06:46:51,360 --> 06:46:53,200
storage

6735
06:46:53,200 --> 06:46:55,440
uh uh minimal storage over

6736
06:46:55,440 --> 06:46:57,920
and finally like and this is probably

6737
06:46:57,920 --> 06:46:59,440
one of the most

6738
06:46:59,440 --> 06:47:00,878
important kind of like design

6739
06:47:00,878 --> 06:47:03,280
requirements is that like our design

6740
06:47:03,280 --> 06:47:05,280
sorry

6741
06:47:05,280 --> 06:47:07,120
should be secure and have minimal

6742
06:47:07,120 --> 06:47:09,200
leakage in the mulching snapshot model

6743
06:47:09,200 --> 06:47:10,638
and and this is something that can

6744
06:47:10,638 --> 06:47:12,798
mention also in his talk what by

6745
06:47:12,798 --> 06:47:14,320
immediate snapshots what we mean is that

6746
06:47:14,320 --> 06:47:17,120
an adversity that takes multiple snaps

6747
06:47:17,120 --> 06:47:18,958
snapshots over time

6748
06:47:18,958 --> 06:47:19,760
uh

6749
06:47:19,760 --> 06:47:20,798
and

6750
06:47:20,798 --> 06:47:22,400
minimal leakage and we will see like

6751
06:47:22,400 --> 06:47:24,798
what we really mean and how we view a

6752
06:47:24,798 --> 06:47:27,360
minimal leakage later on in this in this

6753
06:47:27,360 --> 06:47:28,958
presentation

6754
06:47:28,958 --> 06:47:29,840
so

6755
06:47:29,840 --> 06:47:31,600
this is really uh one of the most

6756
06:47:31,600 --> 06:47:33,440
standard way of thinking about synthesis

6757
06:47:33,440 --> 06:47:35,600
we have this triangle that you probably

6758
06:47:35,600 --> 06:47:37,600
have seen have seen in many encrypted

6759
06:47:37,600 --> 06:47:39,120
search protocol

6760
06:47:39,120 --> 06:47:40,958
is that we have we need to think about

6761
06:47:40,958 --> 06:47:42,400
expressiveness we need to think about

6762
06:47:42,400 --> 06:47:44,400
efficiency and security but when we go

6763
06:47:44,400 --> 06:47:46,638
to mongodb we have to think about

6764
06:47:46,638 --> 06:47:48,320
much much more than that we have to

6765
06:47:48,320 --> 06:47:50,400
think about technical constraints a

6766
06:47:50,400 --> 06:47:52,240
design requirement and then on top of

6767
06:47:52,240 --> 06:47:54,240
that technical construct so it was like

6768
06:47:54,240 --> 06:47:55,440
so many

6769
06:47:55,440 --> 06:47:56,798
dimension

6770
06:47:56,798 --> 06:47:58,478
dimensions that we had to reason about

6771
06:47:58,478 --> 06:48:00,558
at the same time

6772
06:48:00,558 --> 06:48:03,360
so so from where should we even start uh

6773
06:48:03,360 --> 06:48:06,160
our task was quite hard at the beginning

6774
06:48:06,160 --> 06:48:08,638
just to think about how should we

6775
06:48:08,638 --> 06:48:10,000
approach

6776
06:48:10,000 --> 06:48:12,160
the problem so let's take a step back

6777
06:48:12,160 --> 06:48:13,440
and think about the different

6778
06:48:13,440 --> 06:48:14,958
cryptographic primitives that they can

6779
06:48:14,958 --> 06:48:17,440
allow us to to do

6780
06:48:17,440 --> 06:48:19,440
encrypted search or to implement sorry

6781
06:48:19,440 --> 06:48:21,120
the encrypted search problem

6782
06:48:21,120 --> 06:48:22,558
and

6783
06:48:22,558 --> 06:48:24,478
we have quite a like this this list of

6784
06:48:24,478 --> 06:48:26,638
five that those are the almost standard

6785
06:48:26,638 --> 06:48:28,638
primitives that you may think about

6786
06:48:28,638 --> 06:48:30,718
and we went over them and we started

6787
06:48:30,718 --> 06:48:33,280
saying okay which ones of of these

6788
06:48:33,280 --> 06:48:35,440
primitives actually fit our constraints

6789
06:48:35,440 --> 06:48:37,440
and design requirements so if you think

6790
06:48:37,440 --> 06:48:39,600
about one of our first constraint is

6791
06:48:39,600 --> 06:48:42,478
statelessness so let's forget about aura

6792
06:48:42,478 --> 06:48:44,160
okay so auram is

6793
06:48:44,160 --> 06:48:46,478
stateful and require you know also

6794
06:48:46,478 --> 06:48:48,160
interaction so it's just

6795
06:48:48,160 --> 06:48:50,240
not a great fit unfortunately for for

6796
06:48:50,240 --> 06:48:51,280
our reasons

6797
06:48:51,280 --> 06:48:52,240
then

6798
06:48:52,240 --> 06:48:53,440
efficiency

6799
06:48:53,440 --> 06:48:55,600
so if you want a sublinear search forget

6800
06:48:55,600 --> 06:48:58,718
about fhc and uh functional encryption

6801
06:48:58,718 --> 06:48:59,760
okay

6802
06:48:59,760 --> 06:49:02,160
and then we want something that has

6803
06:49:02,160 --> 06:49:04,638
minimal leakage and does better than ppe

6804
06:49:04,638 --> 06:49:06,958
so really like we we got back to a

6805
06:49:06,958 --> 06:49:10,080
square where we had just to focus on sd

6806
06:49:10,080 --> 06:49:12,638
so let's zoom into ste for a second and

6807
06:49:12,638 --> 06:49:14,160
see

6808
06:49:14,160 --> 06:49:17,440
what do we have in terms of of design

6809
06:49:17,440 --> 06:49:20,478
and papers uh in the last two decades

6810
06:49:20,478 --> 06:49:21,440
so

6811
06:49:21,440 --> 06:49:23,760
so the so this by no means any

6812
06:49:23,760 --> 06:49:25,840
exhaustive lists and this is purely

6813
06:49:25,840 --> 06:49:29,200
focused on on on design those are

6814
06:49:29,200 --> 06:49:31,520
like around 20 papers

6815
06:49:31,520 --> 06:49:33,920
the last the last 20 years

6816
06:49:33,920 --> 06:49:36,400
so okay so this is what we have in the

6817
06:49:36,400 --> 06:49:37,600
literature

6818
06:49:37,600 --> 06:49:38,478
and

6819
06:49:38,478 --> 06:49:40,080
we started thinking also the same

6820
06:49:40,080 --> 06:49:41,760
process like let's go over the technical

6821
06:49:41,760 --> 06:49:43,040
constraints let's go over the design

6822
06:49:43,040 --> 06:49:44,638
requirements and see like which scheme

6823
06:49:44,638 --> 06:49:47,280
actually like can achieve somehow our

6824
06:49:47,280 --> 06:49:49,360
constraints so if you think like already

6825
06:49:49,360 --> 06:49:51,200
like we we remove all of the static

6826
06:49:51,200 --> 06:49:53,440
construction still like many schemes

6827
06:49:53,440 --> 06:49:55,200
that they still they are dynamic in the

6828
06:49:55,200 --> 06:49:56,958
literature which is which is which is

6829
06:49:56,958 --> 06:49:59,040
really good but then

6830
06:49:59,040 --> 06:50:02,638
let's remove stage four constructions so

6831
06:50:02,638 --> 06:50:04,878
we are quite left with i mean there is

6832
06:50:04,878 --> 06:50:08,558
an actual kpr ppr2 which is hidden by by

6833
06:50:08,558 --> 06:50:10,558
the zoom um

6834
06:50:10,558 --> 06:50:11,840
the zumba

6835
06:50:11,840 --> 06:50:14,558
but there are three schemes i mean

6836
06:50:14,558 --> 06:50:16,320
maybe there are probably more but three

6837
06:50:16,320 --> 06:50:18,798
schemes on this on this slide that can

6838
06:50:18,798 --> 06:50:21,200
kind of achieve what we want and then

6839
06:50:21,200 --> 06:50:24,638
non-interaction and we are left with one

6840
06:50:24,638 --> 06:50:26,558
which is hidden somehow

6841
06:50:26,558 --> 06:50:27,440
so

6842
06:50:27,440 --> 06:50:29,040
uh

6843
06:50:29,040 --> 06:50:30,240
so

6844
06:50:30,240 --> 06:50:31,360
and then

6845
06:50:31,360 --> 06:50:33,120
it happens that this scheme that it's

6846
06:50:33,120 --> 06:50:36,000
not hr it's the kp as well uh by by cine

6847
06:50:36,000 --> 06:50:39,360
uh barbason uh tomorrow and um

6848
06:50:39,360 --> 06:50:41,520
and when we analyze the its leakage

6849
06:50:41,520 --> 06:50:43,120
against the mushy snapshots it wasn't

6850
06:50:43,120 --> 06:50:44,558
actually great

6851
06:50:44,558 --> 06:50:47,760
so we were actually at step zero almost

6852
06:50:47,760 --> 06:50:49,920
and we were asking ourselves really can

6853
06:50:49,920 --> 06:50:51,440
we even design such a thing with all of

6854
06:50:51,440 --> 06:50:52,638
these constraints and all of these

6855
06:50:52,638 --> 06:50:54,558
design requirements because they are

6856
06:50:54,558 --> 06:50:57,280
really a lot

6857
06:50:57,760 --> 06:50:59,680
and fortunately the answer is yes this

6858
06:50:59,680 --> 06:51:01,200
is why

6859
06:51:01,200 --> 06:51:03,200
we are here so

6860
06:51:03,200 --> 06:51:05,520
so we designed a scheme called osc for

6861
06:51:05,520 --> 06:51:08,240
outsourced states this is a scheme this

6862
06:51:08,240 --> 06:51:10,558
is a document database encryption scheme

6863
06:51:10,558 --> 06:51:12,160
that meets all of our technical

6864
06:51:12,160 --> 06:51:14,400
constraint and desire requirements it's

6865
06:51:14,400 --> 06:51:16,878
it is stateless non-interactive uh

6866
06:51:16,878 --> 06:51:18,638
doesn't mean any filtering at the client

6867
06:51:18,638 --> 06:51:21,200
side has some linear search ad updates

6868
06:51:21,200 --> 06:51:23,760
and delete time has a very small storage

6869
06:51:23,760 --> 06:51:26,638
overhead and has a provable security

6870
06:51:26,638 --> 06:51:28,878
against the multi snapshot uh adversary

6871
06:51:28,878 --> 06:51:30,798
model with some leakage that i'll i'll

6872
06:51:30,798 --> 06:51:33,840
go over in the um in in in subsequent

6873
06:51:33,840 --> 06:51:35,280
slides

6874
06:51:35,280 --> 06:51:37,280
so let's dive a little little bit deeper

6875
06:51:37,280 --> 06:51:40,240
on this osc let's see how it is built so

6876
06:51:40,240 --> 06:51:43,360
osc is built modular so there is the osc

6877
06:51:43,360 --> 06:51:44,878
which is the document database at the

6878
06:51:44,878 --> 06:51:45,680
top

6879
06:51:45,680 --> 06:51:47,360
and one of the really the main building

6880
06:51:47,360 --> 06:51:49,360
block of ic we call it omega

6881
06:51:49,360 --> 06:51:52,558
so omega p is a stateless concurrent

6882
06:51:52,558 --> 06:51:55,040
non-interactive dynamic machine map

6883
06:51:55,040 --> 06:51:57,680
encryption scheme and itself is built in

6884
06:51:57,680 --> 06:52:00,558
a modular way using four different data

6885
06:52:00,558 --> 06:52:02,320
the data structure encryption scheme the

6886
06:52:02,320 --> 06:52:04,400
first one is what we call sigma m

6887
06:52:04,400 --> 06:52:05,920
which is an addressable multi-map

6888
06:52:05,920 --> 06:52:07,200
encryption scheme

6889
06:52:07,200 --> 06:52:09,120
uh which basically this is where the

6890
06:52:09,120 --> 06:52:11,840
data is stored then we have sigma c

6891
06:52:11,840 --> 06:52:13,840
which is an immutable dictionary

6892
06:52:13,840 --> 06:52:15,600
encryption scheme and this is

6893
06:52:15,600 --> 06:52:17,200
an encryption schema responsible of

6894
06:52:17,200 --> 06:52:19,120
storing some states

6895
06:52:19,120 --> 06:52:21,200
and we have sigma d which is an append

6896
06:52:21,200 --> 06:52:22,878
only which map encryption scheme which

6897
06:52:22,878 --> 06:52:25,520
is responsible of storing some delete

6898
06:52:25,520 --> 06:52:28,638
material and finally we have sigma p

6899
06:52:28,638 --> 06:52:30,638
which is a set encryption scheme that

6900
06:52:30,638 --> 06:52:32,160
stores some information about some

6901
06:52:32,160 --> 06:52:33,520
rebuilt process

6902
06:52:33,520 --> 06:52:36,240
that we call compact

6903
06:52:36,240 --> 06:52:39,360
um so well let's and for for the purpose

6904
06:52:39,360 --> 06:52:40,718
of this talk because of the time

6905
06:52:40,718 --> 06:52:42,638
constraints so i'll be focusing on both

6906
06:52:42,638 --> 06:52:45,200
sigma m and sigmas

6907
06:52:45,200 --> 06:52:46,080
so

6908
06:52:46,080 --> 06:52:48,400
let's so this slide actually like this

6909
06:52:48,400 --> 06:52:51,040
this this diagram it shows one of the

6910
06:52:51,040 --> 06:52:53,120
most standard way so there are ways to

6911
06:52:53,120 --> 06:52:54,718
to encrypt encryption to encryption

6912
06:52:54,718 --> 06:52:56,718
which map and this is uh

6913
06:52:56,718 --> 06:52:58,958
a scheme that depicts uh

6914
06:52:58,958 --> 06:53:02,958
the construction pi based by by cache

6915
06:53:03,440 --> 06:53:05,840
so there is a setup algorithm so for

6916
06:53:05,840 --> 06:53:07,360
those of you who are familiar will

6917
06:53:07,360 --> 06:53:10,400
probably know the construction already

6918
06:53:10,400 --> 06:53:14,240
but but let me go over it

6919
06:53:14,240 --> 06:53:16,000
very quickly so it takes other inputs in

6920
06:53:16,000 --> 06:53:17,680
which you might mix up think of it as an

6921
06:53:17,680 --> 06:53:20,320
inverted index okay it maps labels to a

6922
06:53:20,320 --> 06:53:23,120
triple of values and then the output of

6923
06:53:23,120 --> 06:53:25,360
the setup is a key a state and an

6924
06:53:25,360 --> 06:53:26,878
encrypted multi-map and the encrypted

6925
06:53:26,878 --> 06:53:28,878
mutual map is really adjusted dictionary

6926
06:53:28,878 --> 06:53:31,600
that store that stores encrypted pairs

6927
06:53:31,600 --> 06:53:34,240
and the encrypted pairs here

6928
06:53:34,240 --> 06:53:36,160
i don't know

6929
06:53:36,160 --> 06:53:38,080
yeah and the encrypted the encrypted

6930
06:53:38,080 --> 06:53:39,520
pairs here

6931
06:53:39,520 --> 06:53:42,080
um there are for example here in the in

6932
06:53:42,080 --> 06:53:44,798
the encrypted levels the rprf evaluation

6933
06:53:44,798 --> 06:53:46,638
of some key material which is a function

6934
06:53:46,638 --> 06:53:49,200
of the label so it's not something that

6935
06:53:49,200 --> 06:53:51,360
that is explicit here and some counter

6936
06:53:51,360 --> 06:53:53,680
information so basically the idea is

6937
06:53:53,680 --> 06:53:56,320
that we will have as many pairs

6938
06:53:56,320 --> 06:53:58,878
for example for label one uh

6939
06:53:58,878 --> 06:54:01,520
as the number as the size of the tuple

6940
06:54:01,520 --> 06:54:03,600
and the counter is being incremented for

6941
06:54:03,600 --> 06:54:05,440
every single value so for example v one

6942
06:54:05,440 --> 06:54:07,600
is counter one v three is counter two

6943
06:54:07,600 --> 06:54:10,160
and v four is car is construction and we

6944
06:54:10,160 --> 06:54:12,080
do the same for all of the other labels

6945
06:54:12,080 --> 06:54:13,760
and this is how we build our encrypted

6946
06:54:13,760 --> 06:54:16,000
diction so this is of course a state you

6947
06:54:16,000 --> 06:54:19,200
know a stateful kind of like uh uh

6948
06:54:19,200 --> 06:54:21,600
scheme and we cannot work with it so the

6949
06:54:21,600 --> 06:54:23,040
idea uh

6950
06:54:23,040 --> 06:54:26,638
is to uh to to to encrypt the state like

6951
06:54:26,638 --> 06:54:28,478
this is really the first idea that that

6952
06:54:28,478 --> 06:54:30,000
maybe comes to mind is that check this

6953
06:54:30,000 --> 06:54:32,718
state encrypted on stories at the server

6954
06:54:32,718 --> 06:54:34,718
and you encrypted with exactly the same

6955
06:54:34,718 --> 06:54:37,520
uh encryption uh scheme that you that

6956
06:54:37,520 --> 06:54:39,120
that we have used to encrypt this

6957
06:54:39,120 --> 06:54:41,520
dictionary here and this looks like this

6958
06:54:41,520 --> 06:54:43,440
we have like just three pairs because

6959
06:54:43,440 --> 06:54:45,040
the states actually like i didn't go

6960
06:54:45,040 --> 06:54:46,400
over what is the state the state is

6961
06:54:46,400 --> 06:54:49,520
simply a map or a dictionary that that

6962
06:54:49,520 --> 06:54:52,958
maps the the label to a counter and the

6963
06:54:52,958 --> 06:54:54,478
counter here for example is three

6964
06:54:54,478 --> 06:54:57,680
meaning that label one has three values

6965
06:54:57,680 --> 06:54:59,760
label two has one because label two is

6966
06:54:59,760 --> 06:55:02,000
just mapped to one value and label three

6967
06:55:02,000 --> 06:55:04,798
has uh is mapped to a value equal to two

6968
06:55:04,798 --> 06:55:06,958
because there are two values and then we

6969
06:55:06,958 --> 06:55:08,400
encrypt this stage and we store it at

6970
06:55:08,400 --> 06:55:10,558
the server and the encrypted state is

6971
06:55:10,558 --> 06:55:13,200
really similarly you know built as the

6972
06:55:13,200 --> 06:55:15,440
encrypted dictionary

6973
06:55:15,440 --> 06:55:18,080
so to quit to query is is very simple

6974
06:55:18,080 --> 06:55:20,878
like uh so the get is that you just

6975
06:55:20,878 --> 06:55:23,520
generate some some some derived key from

6976
06:55:23,520 --> 06:55:24,638
the

6977
06:55:24,638 --> 06:55:27,600
for the label uh i i really will go very

6978
06:55:27,600 --> 06:55:29,360
fast over this because it's not really

6979
06:55:29,360 --> 06:55:31,600
important to to to understand the git

6980
06:55:31,600 --> 06:55:34,558
parts um and but what is more

6981
06:55:34,558 --> 06:55:36,240
interesting is the ad parts like in

6982
06:55:36,240 --> 06:55:38,878
order to add

6983
06:55:38,878 --> 06:55:41,680
uh to the to the multi-map

6984
06:55:41,680 --> 06:55:43,360
uh let me go to the to the previous

6985
06:55:43,360 --> 06:55:45,040
slide so in order to add to the mutual

6986
06:55:45,040 --> 06:55:47,280
map let's say a new label value

6987
06:55:47,280 --> 06:55:49,360
so basically what you do let's say that

6988
06:55:49,360 --> 06:55:50,798
we are in this world

6989
06:55:50,798 --> 06:55:52,718
you want to add a label value to this

6990
06:55:52,718 --> 06:55:54,478
label one so basically what you do

6991
06:55:54,478 --> 06:55:56,080
because the state is still at the client

6992
06:55:56,080 --> 06:55:58,718
you just increments this this value here

6993
06:55:58,718 --> 06:56:01,040
three to be four and you just generate

6994
06:56:01,040 --> 06:56:02,878
the the corresponding encrypted label

6995
06:56:02,878 --> 06:56:06,160
and the encryption this is really simple

6996
06:56:06,160 --> 06:56:07,920
and you just because the state is local

6997
06:56:07,920 --> 06:56:10,558
you just have full control on it

6998
06:56:10,558 --> 06:56:13,360
so and this is the details of how the

6999
06:56:13,360 --> 06:56:15,760
the addition is done but now is at the

7000
06:56:15,760 --> 06:56:17,600
server so now we use what we call a

7001
06:56:17,600 --> 06:56:19,520
response revealing scheme where we allow

7002
06:56:19,520 --> 06:56:21,440
the server to increment itself the

7003
06:56:21,440 --> 06:56:25,280
counter and to generate the the the the

7004
06:56:25,280 --> 06:56:26,320
the

7005
06:56:26,320 --> 06:56:28,958
the the the encrypted pair and this is

7006
06:56:28,958 --> 06:56:31,200
what's what's happening here so we give

7007
06:56:31,200 --> 06:56:33,600
the server like some token to reveal the

7008
06:56:33,600 --> 06:56:36,000
content which is three and then it equip

7009
06:56:36,000 --> 06:56:38,958
it increments it and then uh generates

7010
06:56:38,958 --> 06:56:40,478
generates

7011
06:56:40,478 --> 06:56:42,320
so this is like a modification to the

7012
06:56:42,320 --> 06:56:44,718
encrypted search protocol

7013
06:56:44,718 --> 06:56:47,280
that we have seen in the previous slide

7014
06:56:47,280 --> 06:56:49,760
but it has like some notes it has a

7015
06:56:49,760 --> 06:56:51,920
non-trivial flow especially because we

7016
06:56:51,920 --> 06:56:54,958
are we are we we consider images natural

7017
06:56:54,958 --> 06:56:57,600
adversary so and the leakage here is no

7018
06:56:57,600 --> 06:57:00,000
better than dte

7019
06:57:00,000 --> 06:57:02,000
and to see why let me go over this

7020
06:57:02,000 --> 06:57:03,600
example

7021
06:57:03,600 --> 06:57:04,798
so

7022
06:57:04,798 --> 06:57:06,638
like let's just consider the stage this

7023
06:57:06,638 --> 06:57:08,400
is the stage which is encrypted and

7024
06:57:08,400 --> 06:57:10,558
let's say we do an update label one so

7025
06:57:10,558 --> 06:57:12,958
level one because we allow the server to

7026
06:57:12,958 --> 06:57:15,440
increment so because we are revealing

7027
06:57:15,440 --> 06:57:18,160
and the server is incremented so it

7028
06:57:18,160 --> 06:57:20,240
increments here so what happens is that

7029
06:57:20,240 --> 06:57:22,000
the server can build some frequency

7030
06:57:22,000 --> 06:57:23,440
information by because it's a mutually

7031
06:57:23,440 --> 06:57:26,080
snapshot adversary which we are assuming

7032
06:57:26,080 --> 06:57:27,200
in the worst case that it gets the

7033
06:57:27,200 --> 06:57:29,600
snapshots after every single operation

7034
06:57:29,600 --> 06:57:32,080
so here we it will know that it doesn't

7035
06:57:32,080 --> 06:57:33,680
know the label but it knows that there

7036
06:57:33,680 --> 06:57:35,600
is something that has been inserted so

7037
06:57:35,600 --> 06:57:37,440
let's say that the second update

7038
06:57:37,440 --> 06:57:38,558
happened

7039
06:57:38,558 --> 06:57:40,400
for some reason on the same level this

7040
06:57:40,400 --> 06:57:41,600
might happen

7041
06:57:41,600 --> 06:57:43,680
so the server will go and update the

7042
06:57:43,680 --> 06:57:46,080
same and basically touch the same memory

7043
06:57:46,080 --> 06:57:47,200
location

7044
06:57:47,200 --> 06:57:49,360
okay so by the way if we are in the

7045
06:57:49,360 --> 06:57:51,200
single snapshot model the the scheme is

7046
06:57:51,200 --> 06:57:52,878
good but we are not we are considering a

7047
06:57:52,878 --> 06:57:54,798
slightly stronger model which is which

7048
06:57:54,798 --> 06:57:56,400
snapshot so here

7049
06:57:56,400 --> 06:57:58,320
we update this entry

7050
06:57:58,320 --> 06:58:00,160
and the server will know sorry the

7051
06:58:00,160 --> 06:58:02,240
adversary will notice that and we will

7052
06:58:02,240 --> 06:58:04,798
build the second a much better

7053
06:58:04,798 --> 06:58:07,200
understanding of the frequency and so on

7054
06:58:07,200 --> 06:58:09,040
and so forth like for for the third

7055
06:58:09,040 --> 06:58:10,958
update let's see it's for label 2 it

7056
06:58:10,958 --> 06:58:12,558
notices that it touches something

7057
06:58:12,558 --> 06:58:14,558
different so it knows it's for something

7058
06:58:14,558 --> 06:58:15,440
else

7059
06:58:15,440 --> 06:58:17,200
and so on and so forth

7060
06:58:17,200 --> 06:58:19,360
and it builds this histogram

7061
06:58:19,360 --> 06:58:22,240
so this is no better than dc

7062
06:58:22,240 --> 06:58:23,760
of course in the signal snapshots model

7063
06:58:23,760 --> 06:58:25,200
this is very important like there is a

7064
06:58:25,200 --> 06:58:27,920
significant uh it's much better than vce

7065
06:58:27,920 --> 06:58:29,520
but in the mutual snapshots it's not

7066
06:58:29,520 --> 06:58:31,040
especially when we are dealing with

7067
06:58:31,040 --> 06:58:33,120
updates

7068
06:58:33,120 --> 06:58:34,320
so

7069
06:58:34,320 --> 06:58:35,360
um

7070
06:58:35,360 --> 06:58:38,000
so and this is where comes sigma c so

7071
06:58:38,000 --> 06:58:40,718
sigma c is really a data structure or

7072
06:58:40,718 --> 06:58:42,160
this is an encryption scheme that will

7073
06:58:42,160 --> 06:58:45,120
allow us to work around this issue so to

7074
06:58:45,120 --> 06:58:48,000
build an encrypted state that is not

7075
06:58:48,000 --> 06:58:50,000
vulnerable to this kind of leakage like

7076
06:58:50,000 --> 06:58:51,840
it doesn't doesn't really such as the

7077
06:58:51,840 --> 06:58:54,080
same same location so let me go over it

7078
06:58:54,080 --> 06:58:56,080
with an example so imagine that our

7079
06:58:56,080 --> 06:58:57,440
encrypted state that we started with

7080
06:58:57,440 --> 06:58:59,280
like our three first so now when we do

7081
06:58:59,280 --> 06:59:00,958
an update instead of touching the same

7082
06:59:00,958 --> 06:59:05,040
location we will just add an extra pair

7083
06:59:05,040 --> 06:59:06,958
so the server will add an extra pair

7084
06:59:06,958 --> 06:59:08,958
that kind of like encodes where the

7085
06:59:08,958 --> 06:59:11,280
counter is at without touching the same

7086
06:59:11,280 --> 06:59:13,840
location so when we snatch adversary

7087
06:59:13,840 --> 06:59:16,000
we'll get a snapshot okay fine it will

7088
06:59:16,000 --> 06:59:18,798
notice okay now it's from three to four

7089
06:59:18,798 --> 06:59:20,160
uh

7090
06:59:20,160 --> 06:59:22,798
so let's let's see the second update it

7091
06:59:22,798 --> 06:59:24,638
will update again l1

7092
06:59:24,638 --> 06:59:26,478
uh with some value we don't care here

7093
06:59:26,478 --> 06:59:27,680
about the value because we are just

7094
06:59:27,680 --> 06:59:30,400
focusing on the encrypted state and then

7095
06:59:30,400 --> 06:59:32,478
it adds an extra pair

7096
06:59:32,478 --> 06:59:35,040
and so on and so forth

7097
06:59:35,040 --> 06:59:38,000
so here emilio's laptop adversary will

7098
06:59:38,000 --> 06:59:40,798
only learn the number of updates so we

7099
06:59:40,798 --> 06:59:42,478
moved from a situation where the

7100
06:59:42,478 --> 06:59:46,160
adversary has uh an exact clear view of

7101
06:59:46,160 --> 06:59:47,600
the histogram basically all of the

7102
06:59:47,600 --> 06:59:50,798
frequency to a situation where uh the

7103
06:59:50,798 --> 06:59:52,798
adversary will only learn the number of

7104
06:59:52,798 --> 06:59:54,400
updates so here there is a cost of

7105
06:59:54,400 --> 06:59:56,000
obviously you may have already noticed

7106
06:59:56,000 --> 06:59:58,718
the cost which is this increase of

7107
06:59:58,718 --> 07:00:00,878
storage which is linear in the number of

7108
07:00:00,878 --> 07:00:02,958
additions and this course is this course

7109
07:00:02,958 --> 07:00:06,240
is needed in order to avoid this kind of

7110
07:00:06,240 --> 07:00:08,000
leakage that we we covered in the

7111
07:00:08,000 --> 07:00:09,680
previous previous

7112
07:00:09,680 --> 07:00:11,760
so now let's let's move to the to the

7113
07:00:11,760 --> 07:00:12,958
get

7114
07:00:12,958 --> 07:00:15,280
so now our encrypted state is kind of

7115
07:00:15,280 --> 07:00:16,958
like growing and growing and growing and

7116
07:00:16,958 --> 07:00:19,440
as we have seen in order to to make an

7117
07:00:19,440 --> 07:00:21,680
update you need to get the last count in

7118
07:00:21,680 --> 07:00:23,520
order to make a correct update you need

7119
07:00:23,520 --> 07:00:25,280
really to get the last count

7120
07:00:25,280 --> 07:00:27,360
if you don't get the last count it will

7121
07:00:27,360 --> 07:00:29,760
lead to security issues

7122
07:00:29,760 --> 07:00:30,558
so

7123
07:00:30,558 --> 07:00:33,040
one way like it's naive way to do it is

7124
07:00:33,040 --> 07:00:35,520
just to go linearly over all of the

7125
07:00:35,520 --> 07:00:37,920
encrypted state it's just by one two

7126
07:00:37,920 --> 07:00:39,920
three until you find the the last

7127
07:00:39,920 --> 07:00:42,558
counter but this solution is really it's

7128
07:00:42,558 --> 07:00:44,878
too inefficient what if for example you

7129
07:00:44,878 --> 07:00:47,360
have inserted one million label value

7130
07:00:47,360 --> 07:00:48,240
pips

7131
07:00:48,240 --> 07:00:50,320
like where the label is the same so are

7132
07:00:50,320 --> 07:00:52,638
you going one million kind of like hope

7133
07:00:52,638 --> 07:00:56,160
in memory just to find uh the the the

7134
07:00:56,160 --> 07:00:57,600
the last country this is just

7135
07:00:57,600 --> 07:00:58,958
impractical

7136
07:00:58,958 --> 07:01:02,000
uh so but we found a solution that gets

7137
07:01:02,000 --> 07:01:03,760
around that

7138
07:01:03,760 --> 07:01:06,320
and to see how it works like it's this

7139
07:01:06,320 --> 07:01:08,160
is a really rough like you know high

7140
07:01:08,160 --> 07:01:10,958
level idea about how it works and uh

7141
07:01:10,958 --> 07:01:12,400
hopefully like it will get the idea

7142
07:01:12,400 --> 07:01:14,478
across so imagine that we have this

7143
07:01:14,478 --> 07:01:16,718
encrypted state that has seven entries

7144
07:01:16,718 --> 07:01:18,638
one way to view this state is just like

7145
07:01:18,638 --> 07:01:21,440
view it as a line in an x-axis where the

7146
07:01:21,440 --> 07:01:24,000
pairs are actually these circles

7147
07:01:24,000 --> 07:01:24,798
so

7148
07:01:24,798 --> 07:01:27,920
the server when we give the server this

7149
07:01:27,920 --> 07:01:30,400
this this the the token information of

7150
07:01:30,400 --> 07:01:33,120
course it can just go linearly and find

7151
07:01:33,120 --> 07:01:34,558
all of the pairs that they are

7152
07:01:34,558 --> 07:01:36,878
associated to label one that's we don't

7153
07:01:36,878 --> 07:01:39,920
want to do that so another way is that

7154
07:01:39,920 --> 07:01:42,080
um we differentiate between these

7155
07:01:42,080 --> 07:01:44,000
engines so there is different entry and

7156
07:01:44,000 --> 07:01:45,920
there is the entry for l1 but the server

7157
07:01:45,920 --> 07:01:48,000
doesn't know that it doesn't know how to

7158
07:01:48,000 --> 07:01:49,840
differentiate between the entry it's

7159
07:01:49,840 --> 07:01:51,840
still opaque for the serve

7160
07:01:51,840 --> 07:01:52,558
but

7161
07:01:52,558 --> 07:01:54,240
intuitively because we have this

7162
07:01:54,240 --> 07:01:56,638
contiguous kind of like addition

7163
07:01:56,638 --> 07:01:58,798
counters are conscious in the sense one

7164
07:01:58,798 --> 07:02:00,718
this there is definitely a two after one

7165
07:02:00,718 --> 07:02:02,558
and there is definitely a tree after two

7166
07:02:02,558 --> 07:02:04,878
so we build this kind of like continuous

7167
07:02:04,878 --> 07:02:07,680
kind of flying and then we can

7168
07:02:07,680 --> 07:02:09,600
approach the problem differently how

7169
07:02:09,600 --> 07:02:12,718
about doing a binary search here and the

7170
07:02:12,718 --> 07:02:14,400
idea is that now the server considers

7171
07:02:14,400 --> 07:02:17,280
this line as potentially all values for

7172
07:02:17,280 --> 07:02:18,240
l1

7173
07:02:18,240 --> 07:02:20,478
and it will say okay let me try the last

7174
07:02:20,478 --> 07:02:22,958
one is it's for l1

7175
07:02:22,958 --> 07:02:24,558
no it's not

7176
07:02:24,558 --> 07:02:27,200
i will go to the middle yes it is let's

7177
07:02:27,200 --> 07:02:29,600
go to the middle no it's not and then it

7178
07:02:29,600 --> 07:02:31,440
will go to the to the to the correct

7179
07:02:31,440 --> 07:02:33,840
entry doing a binary search so we have

7180
07:02:33,840 --> 07:02:36,320
moved from a linear search to a

7181
07:02:36,320 --> 07:02:38,478
logarithmic search

7182
07:02:38,478 --> 07:02:42,878
um which is which is a big win for us

7183
07:02:43,040 --> 07:02:46,400
so i know as cine mentioned so we are

7184
07:02:46,400 --> 07:02:49,600
running out of time so

7185
07:02:50,000 --> 07:02:51,520
we were not able to cover really a lot

7186
07:02:51,520 --> 07:02:54,000
of things uh because of the 30 minutes

7187
07:02:54,000 --> 07:02:56,000
uh so we didn't talk about how to handle

7188
07:02:56,000 --> 07:02:58,240
concurrency how to perform these

7189
07:02:58,240 --> 07:03:00,240
operations how to perform compaction

7190
07:03:00,240 --> 07:03:01,840
which is like one of the really

7191
07:03:01,840 --> 07:03:03,760
important building block of our design

7192
07:03:03,760 --> 07:03:05,200
which is basically shrinking because the

7193
07:03:05,200 --> 07:03:06,958
idea is that you may have already

7194
07:03:06,958 --> 07:03:09,040
guessed like this encrypted state is

7195
07:03:09,040 --> 07:03:10,878
going big big big with the number of

7196
07:03:10,878 --> 07:03:12,320
additions

7197
07:03:12,320 --> 07:03:14,080
can we shrink it because there are so

7198
07:03:14,080 --> 07:03:16,080
many entries that they are just useless

7199
07:03:16,080 --> 07:03:18,000
and we cannot we won't use them anymore

7200
07:03:18,000 --> 07:03:20,000
in the future and the compaction will

7201
07:03:20,000 --> 07:03:21,520
will solve this problem in the standards

7202
07:03:21,520 --> 07:03:23,280
if we shrink the structure

7203
07:03:23,280 --> 07:03:26,080
um and also like this is probably

7204
07:03:26,080 --> 07:03:28,240
will deserve like a presentation for for

7205
07:03:28,240 --> 07:03:30,798
for its own and

7206
07:03:30,798 --> 07:03:32,878
and i don't know if cindy talks about it

7207
07:03:32,878 --> 07:03:34,478
in the morning but sce there was this

7208
07:03:34,478 --> 07:03:36,558
common wisdom that sde is not used

7209
07:03:36,558 --> 07:03:38,558
cannot be used with legacy databases

7210
07:03:38,558 --> 07:03:40,240
because like you need to build storage

7211
07:03:40,240 --> 07:03:42,400
engine you build everything from scratch

7212
07:03:42,400 --> 07:03:44,638
but we found out in a

7213
07:03:44,638 --> 07:03:46,000
you know couple of years i don't know

7214
07:03:46,000 --> 07:03:48,638
five or six years ago that that's not

7215
07:03:48,638 --> 07:03:50,878
actually true and this notion that we

7216
07:03:50,878 --> 07:03:53,120
found like that can transform any sce

7217
07:03:53,120 --> 07:03:55,840
scheme into something that can work on

7218
07:03:55,840 --> 07:03:57,520
any back end without changing the back

7219
07:03:57,520 --> 07:03:59,360
end and this is something that we call

7220
07:03:59,360 --> 07:04:01,280
immunization so

7221
07:04:01,280 --> 07:04:02,798
if you want to to learn more a little

7222
07:04:02,798 --> 07:04:04,160
bit about it there is a paper that we

7223
07:04:04,160 --> 07:04:06,000
wrote um

7224
07:04:06,000 --> 07:04:08,638
you know 21 that kind of like goes over

7225
07:04:08,638 --> 07:04:09,920
over it

7226
07:04:09,920 --> 07:04:11,760
a little bit

7227
07:04:11,760 --> 07:04:13,840
so about security and this is really an

7228
07:04:13,840 --> 07:04:17,120
important slide so um given the dynamic

7229
07:04:17,120 --> 07:04:18,478
nature and

7230
07:04:18,478 --> 07:04:22,080
complexity modularity of uh of osc

7231
07:04:22,080 --> 07:04:24,160
it was really hard it's it's very tricky

7232
07:04:24,160 --> 07:04:26,160
to think about it it's very complicated

7233
07:04:26,160 --> 07:04:28,000
we saw in the in the morning that

7234
07:04:28,000 --> 07:04:29,680
everybody was kind of like complaining

7235
07:04:29,680 --> 07:04:31,360
about these mathematical equations that

7236
07:04:31,360 --> 07:04:33,280
they are very hard to work and very hard

7237
07:04:33,280 --> 07:04:36,400
to verify and then you know and

7238
07:04:36,400 --> 07:04:38,638
especially when when you are reviewing

7239
07:04:38,638 --> 07:04:41,680
such papers so so we came up with a new

7240
07:04:41,680 --> 07:04:44,000
way how to formally think about leakage

7241
07:04:44,000 --> 07:04:46,000
and using what we call correlation

7242
07:04:46,000 --> 07:04:47,280
graphs this is something that hopefully

7243
07:04:47,280 --> 07:04:49,680
we will be able to put online uh very

7244
07:04:49,680 --> 07:04:52,958
very very very soon so how about leakage

7245
07:04:52,958 --> 07:04:55,440
at a very high level we look this type

7246
07:04:55,440 --> 07:04:57,440
of relic this type of information so for

7247
07:04:57,440 --> 07:04:59,120
example in which snapshots adversely we

7248
07:04:59,120 --> 07:05:00,958
get to know the size of the machine

7249
07:05:00,958 --> 07:05:03,600
basically knowing for example how many

7250
07:05:03,600 --> 07:05:05,520
pairs we have stored in the data it's

7251
07:05:05,520 --> 07:05:07,520
just very hard and very expensive to

7252
07:05:07,520 --> 07:05:09,200
hide this linkage

7253
07:05:09,200 --> 07:05:11,680
we leaked the number of other operations

7254
07:05:11,680 --> 07:05:13,360
like because like we the server will

7255
07:05:13,360 --> 07:05:15,360
know that we are extending it knows that

7256
07:05:15,360 --> 07:05:17,520
we have made some ad operations in them

7257
07:05:17,520 --> 07:05:19,280
number of deleted entries and their

7258
07:05:19,280 --> 07:05:21,600
corresponding insertion chains and also

7259
07:05:21,600 --> 07:05:23,440
we need the size of the support which is

7260
07:05:23,440 --> 07:05:25,200
like this is a consequence of our

7261
07:05:25,200 --> 07:05:27,760
compaction or rebuilt process

7262
07:05:27,760 --> 07:05:29,200
um

7263
07:05:29,200 --> 07:05:32,080
okay so i'm going to conclude uh

7264
07:05:32,080 --> 07:05:33,920
oh i see like this is really important

7265
07:05:33,920 --> 07:05:36,160
for for hopefully for all of you like

7266
07:05:36,160 --> 07:05:37,360
this is

7267
07:05:37,360 --> 07:05:39,680
a two-year plus

7268
07:05:39,680 --> 07:05:41,440
design project because there is the

7269
07:05:41,440 --> 07:05:43,200
mongodb acquisition but there is a lot

7270
07:05:43,200 --> 07:05:45,600
of work that was done also prior

7271
07:05:45,600 --> 07:05:46,878
and uh

7272
07:05:46,878 --> 07:05:48,638
and really like osa wouldn't have been

7273
07:05:48,638 --> 07:05:50,400
possible without the great interaction

7274
07:05:50,400 --> 07:05:52,478
we had with both products and

7275
07:05:52,478 --> 07:05:54,798
engineering team we really learned a lot

7276
07:05:54,798 --> 07:05:57,040
and this is what bring what brings me to

7277
07:05:57,040 --> 07:05:58,958
the to the third knowledge here which is

7278
07:05:58,958 --> 07:06:00,718
we have just discovered like of course

7279
07:06:00,718 --> 07:06:02,320
you may have heard of interaction is not

7280
07:06:02,320 --> 07:06:03,680
something great to have you may have

7281
07:06:03,680 --> 07:06:04,878
heard of states

7282
07:06:04,878 --> 07:06:06,558
that it's not great to have

7283
07:06:06,558 --> 07:06:07,520
but

7284
07:06:07,520 --> 07:06:09,600
no it's just like technical concerns

7285
07:06:09,600 --> 07:06:12,718
that's in in order to deploy some some

7286
07:06:12,718 --> 07:06:14,000
encryption search protocol it's just

7287
07:06:14,000 --> 07:06:16,718
like it's very hard to have these uh in

7288
07:06:16,718 --> 07:06:19,120
place so hopefully this sense of concern

7289
07:06:19,120 --> 07:06:21,440
that challenges hopefully we will we

7290
07:06:21,440 --> 07:06:23,440
will let us as a community think about

7291
07:06:23,440 --> 07:06:25,440
possible like how to design maybe more

7292
07:06:25,440 --> 07:06:27,840
schemes that they can kind of like

7293
07:06:27,840 --> 07:06:29,200
you know come up with protocols that

7294
07:06:29,200 --> 07:06:31,280
they don't have that they fit these

7295
07:06:31,280 --> 07:06:32,958
constraints or at least like a substance

7296
07:06:32,958 --> 07:06:35,120
of them and

7297
07:06:35,120 --> 07:06:37,600
finally the there will be more hopefully

7298
07:06:37,600 --> 07:06:39,520
like we will have the opportunity to

7299
07:06:39,520 --> 07:06:40,958
tell you more as ceri mentioned we will

7300
07:06:40,958 --> 07:06:42,878
have a technical uh document that will

7301
07:06:42,878 --> 07:06:43,680
go

7302
07:06:43,680 --> 07:06:45,760
more into the the construction and the

7303
07:06:45,760 --> 07:06:47,840
details and the security analysis but

7304
07:06:47,840 --> 07:06:49,600
there is also more we will have range

7305
07:06:49,600 --> 07:06:52,160
and substitutes uh hopefully coming

7306
07:06:52,160 --> 07:06:53,600
coming very soon

7307
07:06:53,600 --> 07:06:56,478
so thank you all

7308
07:06:59,840 --> 07:07:01,920
okay so yeah we have time for a few

7309
07:07:01,920 --> 07:07:03,600
questions uh if you need to leave feel

7310
07:07:03,600 --> 07:07:07,600
free to go since we're last time so

7311
07:07:09,920 --> 07:07:10,718
um

7312
07:07:10,718 --> 07:07:13,600
cool talk so first off you mentioned

7313
07:07:13,600 --> 07:07:15,440
that you leaked the deletion history

7314
07:07:15,440 --> 07:07:17,680
does that mean that not backwards

7315
07:07:17,680 --> 07:07:20,080
or is that something you analyze

7316
07:07:20,080 --> 07:07:23,200
your people i couldn't find the paper

7317
07:07:23,200 --> 07:07:24,080
so

7318
07:07:24,080 --> 07:07:26,000
so so there were like there were a

7319
07:07:26,000 --> 07:07:27,440
couple of definitions of backward

7320
07:07:27,440 --> 07:07:29,840
privacy like since the the paper

7321
07:07:29,840 --> 07:07:31,200
there were three types and then there

7322
07:07:31,200 --> 07:07:33,440
are follow-up papers and

7323
07:07:33,440 --> 07:07:35,280
so here it's very important to

7324
07:07:35,280 --> 07:07:36,878
differentiate between what are the

7325
07:07:36,878 --> 07:07:38,240
threat moments right like in the

7326
07:07:38,240 --> 07:07:40,958
backward and forward privacy usually we

7327
07:07:40,958 --> 07:07:42,478
talk about these notions when we are

7328
07:07:42,478 --> 07:07:44,000
dealing with what we call a persistent

7329
07:07:44,000 --> 07:07:45,600
adversary and for those of you who don't

7330
07:07:45,600 --> 07:07:46,878
know persistent adversity is somebody

7331
07:07:46,878 --> 07:07:48,958
who not only gets the structure but also

7332
07:07:48,958 --> 07:07:50,718
gets to see the execution of the queries

7333
07:07:50,718 --> 07:07:52,080
and also the execution of all of the

7334
07:07:52,080 --> 07:07:53,600
other operations here we are in a

7335
07:07:53,600 --> 07:07:55,120
different model right we are in the

7336
07:07:55,120 --> 07:07:58,160
mutual snapshot model where basically

7337
07:07:58,160 --> 07:07:59,120
you know

7338
07:07:59,120 --> 07:08:01,200
the the adversarial view is more

7339
07:08:01,200 --> 07:08:02,320
constrained

7340
07:08:02,320 --> 07:08:03,920
uh and

7341
07:08:03,920 --> 07:08:05,200
of course like there is this notion of

7342
07:08:05,200 --> 07:08:06,638
time because we are dealing with dynamic

7343
07:08:06,638 --> 07:08:09,200
structures and this notion of time we

7344
07:08:09,200 --> 07:08:11,520
can call it whatever we want like maybe

7345
07:08:11,520 --> 07:08:13,680
it's some form of backward privacy maybe

7346
07:08:13,680 --> 07:08:15,520
not so we really didn't spend the time

7347
07:08:15,520 --> 07:08:17,920
to think about how it maps to to

7348
07:08:17,920 --> 07:08:19,440
backward privacy but maybe there is

7349
07:08:19,440 --> 07:08:21,040
something there but probably it's

7350
07:08:21,040 --> 07:08:22,798
different from what whatever we have on

7351
07:08:22,798 --> 07:08:24,400
the persistence model or maybe like some

7352
07:08:24,400 --> 07:08:26,160
variation that we need to think more

7353
07:08:26,160 --> 07:08:28,400
about

7354
07:08:28,878 --> 07:08:30,878
thanks for the talk and congrats on the

7355
07:08:30,878 --> 07:08:33,760
word being deployed i have uh two quick

7356
07:08:33,760 --> 07:08:35,040
questions

7357
07:08:35,040 --> 07:08:36,320
so

7358
07:08:36,320 --> 07:08:38,798
first one um

7359
07:08:38,798 --> 07:08:40,798
from the other talks we

7360
07:08:40,798 --> 07:08:43,520
first of all i i understand perfectly

7361
07:08:43,520 --> 07:08:46,558
that with so many constraints like you

7362
07:08:46,558 --> 07:08:48,798
cannot have the strongest security i'm

7363
07:08:48,798 --> 07:08:51,120
amazed like you could do something

7364
07:08:51,120 --> 07:08:56,160
strong at that level but we know that

7365
07:08:56,160 --> 07:08:58,240
with all the attacks we know which

7366
07:08:58,240 --> 07:09:01,440
exploit like stronger security uh models

7367
07:09:01,440 --> 07:09:03,680
right like access pattern volume pattern

7368
07:09:03,680 --> 07:09:05,520
theory part and search pattern

7369
07:09:05,520 --> 07:09:07,120
like

7370
07:09:07,120 --> 07:09:09,840
do you think such attacks can happen on

7371
07:09:09,840 --> 07:09:13,360
your system or you really think like

7372
07:09:13,360 --> 07:09:15,600
these are too strong for

7373
07:09:15,600 --> 07:09:17,840
the practical settings you have and the

7374
07:09:17,840 --> 07:09:20,080
related question is what are your plans

7375
07:09:20,080 --> 07:09:21,280
to

7376
07:09:21,280 --> 07:09:24,878
explain the security model to general

7377
07:09:24,878 --> 07:09:27,760
public because i don't think

7378
07:09:27,760 --> 07:09:30,638
they know or i don't it's not easy but

7379
07:09:30,638 --> 07:09:33,360
currently i don't think anyone knows

7380
07:09:33,360 --> 07:09:35,360
about these things and

7381
07:09:35,360 --> 07:09:37,120
whether you think they should know and

7382
07:09:37,120 --> 07:09:38,798
how to explain that

7383
07:09:38,798 --> 07:09:41,040
yeah no no these are really two great

7384
07:09:41,040 --> 07:09:43,680
questions and uh let me answer first the

7385
07:09:43,680 --> 07:09:45,120
the first one

7386
07:09:45,120 --> 07:09:47,200
absolutely like as cryptographers we all

7387
07:09:47,200 --> 07:09:49,200
try to have better security guarantees

7388
07:09:49,200 --> 07:09:51,600
and to have like the best like uh we we

7389
07:09:51,600 --> 07:09:54,400
have been working i think since 2018 or

7390
07:09:54,400 --> 07:09:55,760
even before because this is the year of

7391
07:09:55,760 --> 07:09:58,718
publication of our kmo paper on leakage

7392
07:09:58,718 --> 07:10:01,040
suppression and and we all i mean and

7393
07:10:01,040 --> 07:10:02,718
then there is the volume suppression and

7394
07:10:02,718 --> 07:10:04,638
we are still working with the we have

7395
07:10:04,638 --> 07:10:07,040
worked with marilyn on how to suppress

7396
07:10:07,040 --> 07:10:09,200
in the dynamics we know that this these

7397
07:10:09,200 --> 07:10:11,200
are really costly and

7398
07:10:11,200 --> 07:10:13,280
it comes with so many

7399
07:10:13,280 --> 07:10:17,040
so many constraints that that it just

7400
07:10:17,040 --> 07:10:18,958
almost like from at least from our

7401
07:10:18,958 --> 07:10:21,600
experience uh working in the industry so

7402
07:10:21,600 --> 07:10:23,840
far it just don't fit it just don't fit

7403
07:10:23,840 --> 07:10:25,680
to be deployable and

7404
07:10:25,680 --> 07:10:27,040
you know this is something that's

7405
07:10:27,040 --> 07:10:29,520
probably you we want to do in the future

7406
07:10:29,520 --> 07:10:31,440
and this is why we are still doing a lot

7407
07:10:31,440 --> 07:10:33,360
of research in this direction how to

7408
07:10:33,360 --> 07:10:35,520
implement really more efficient leakage

7409
07:10:35,520 --> 07:10:37,760
suppression techniques but right now

7410
07:10:37,760 --> 07:10:39,360
what i can tell you is just like it's

7411
07:10:39,360 --> 07:10:41,280
just impossible so this is one way to

7412
07:10:41,280 --> 07:10:43,520
think about it so about your question

7413
07:10:43,520 --> 07:10:45,360
about like do you think that these

7414
07:10:45,360 --> 07:10:48,878
leakage are not exploitable or

7415
07:10:48,878 --> 07:10:51,200
so this is of course we are not going to

7416
07:10:51,200 --> 07:10:54,080
get to guarantee a full like you know

7417
07:10:54,080 --> 07:10:56,000
kind of like no our system will not be

7418
07:10:56,000 --> 07:10:57,760
so we are very precise on the type of

7419
07:10:57,760 --> 07:11:00,160
adversary that we are claiming security

7420
07:11:00,160 --> 07:11:02,080
against which is the much snapshot model

7421
07:11:02,080 --> 07:11:04,080
so now how it fits into practice and

7422
07:11:04,080 --> 07:11:06,478
this is like with our discussions with

7423
07:11:06,478 --> 07:11:08,798
our you know talented product team and

7424
07:11:08,798 --> 07:11:10,558
the ones that they face with customers

7425
07:11:10,558 --> 07:11:13,520
and we hear what are their concerns and

7426
07:11:13,520 --> 07:11:15,120
so there are so many concerns that

7427
07:11:15,120 --> 07:11:16,958
requirable encryption will fit very

7428
07:11:16,958 --> 07:11:19,600
nicely like due to separation of duties

7429
07:11:19,600 --> 07:11:21,760
like uh the fact that you don't want to

7430
07:11:21,760 --> 07:11:23,520
deal with a rogue dba that has like

7431
07:11:23,520 --> 07:11:26,160
maybe access to the gui just trying to

7432
07:11:26,160 --> 07:11:28,000
learn more and having access to some

7433
07:11:28,000 --> 07:11:30,638
snapshot so definitely like there are so

7434
07:11:30,638 --> 07:11:32,558
many kind of classes of categories that

7435
07:11:32,558 --> 07:11:34,478
we will protect against of course like

7436
07:11:34,478 --> 07:11:36,240
it's not kind of like a silver bullet

7437
07:11:36,240 --> 07:11:38,000
that would solve all of the problem but

7438
07:11:38,000 --> 07:11:40,080
we are definitely thinking seriously

7439
07:11:40,080 --> 07:11:43,040
about how to think how to make this

7440
07:11:43,040 --> 07:11:44,240
leakage suppression technique more

7441
07:11:44,240 --> 07:11:45,200
efficient

7442
07:11:45,200 --> 07:11:46,080
so

7443
07:11:46,080 --> 07:11:48,718
this is you know uh how we how we view

7444
07:11:48,718 --> 07:11:50,240
it to answer your second question this

7445
07:11:50,240 --> 07:11:52,080
is really tough like because like even

7446
07:11:52,080 --> 07:11:54,240
even in our community sometimes it's

7447
07:11:54,240 --> 07:11:56,240
very hard to communicate how we view the

7448
07:11:56,240 --> 07:11:59,520
world and so now extrapolate that to the

7449
07:11:59,520 --> 07:12:02,240
general public yes it's very challenging

7450
07:12:02,240 --> 07:12:04,798
and this is why we really need sometimes

7451
07:12:04,798 --> 07:12:06,400
people who really need to communicate

7452
07:12:06,400 --> 07:12:08,160
with the right people and know how to do

7453
07:12:08,160 --> 07:12:10,558
the translation so our product team is

7454
07:12:10,558 --> 07:12:12,798
doing like a really amazing work to do

7455
07:12:12,798 --> 07:12:14,798
this translation like to hear the

7456
07:12:14,798 --> 07:12:17,440
concerns and kind of like put them in

7457
07:12:17,440 --> 07:12:19,200
english words just to make sure that

7458
07:12:19,200 --> 07:12:21,280
it's understandable but yes definitely

7459
07:12:21,280 --> 07:12:22,718
there is a lot of work also in this

7460
07:12:22,718 --> 07:12:24,320
category as well how to communicate the

7461
07:12:24,320 --> 07:12:26,080
security guarantees how to tell them

7462
07:12:26,080 --> 07:12:28,878
what we achieve to get them to learn and

7463
07:12:28,878 --> 07:12:30,558
some some actually some people they

7464
07:12:30,558 --> 07:12:32,400
really get too technical and they are

7465
07:12:32,400 --> 07:12:34,160
they are really smart people out there

7466
07:12:34,160 --> 07:12:36,240
they really understand sometimes we are

7467
07:12:36,240 --> 07:12:38,478
really surprised like how much details

7468
07:12:38,478 --> 07:12:39,600
they they get

7469
07:12:39,600 --> 07:12:41,760
yeah so there is a lot of work in votes

7470
07:12:41,760 --> 07:12:43,440
yeah

7471
07:12:43,440 --> 07:12:44,878
i just want to just add two quick things

7472
07:12:44,878 --> 07:12:46,400
the attacks that you mentioned are not

7473
07:12:46,400 --> 07:12:48,400
in the snapshot model right so

7474
07:12:48,400 --> 07:12:49,760
they don't apply yeah that's what i'm

7475
07:12:49,760 --> 07:12:53,200
saying so right

7476
07:12:53,200 --> 07:12:54,798
right but not

7477
07:12:54,798 --> 07:12:56,400
in our case

7478
07:12:56,400 --> 07:12:57,440
right but in our case we're worried

7479
07:12:57,440 --> 07:12:59,360
about the multi-snapshot model for

7480
07:12:59,360 --> 07:13:01,440
very specific threats

7481
07:13:01,440 --> 07:13:02,878
that customers are worried about so

7482
07:13:02,878 --> 07:13:07,120
that's sort of that's you know um and uh

7483
07:13:07,120 --> 07:13:08,958
yeah the other just just adding on to

7484
07:13:08,958 --> 07:13:10,080
what you were saying for the second

7485
07:13:10,080 --> 07:13:11,360
question

7486
07:13:11,360 --> 07:13:13,440
um that's really difficult so we will

7487
07:13:13,440 --> 07:13:15,760
have a technical brief that tries to

7488
07:13:15,760 --> 07:13:18,160
convey some things at a high level and

7489
07:13:18,160 --> 07:13:20,080
we also meet with customers right so the

7490
07:13:20,080 --> 07:13:22,080
product team meets with customers and

7491
07:13:22,080 --> 07:13:24,160
tries to explain things and then we also

7492
07:13:24,160 --> 07:13:26,000
get into these meetings as well not with

7493
07:13:26,000 --> 07:13:28,798
all customers but um with some customers

7494
07:13:28,798 --> 07:13:30,320
if they want to hear more

7495
07:13:30,320 --> 07:13:33,280
technical details and try to understand

7496
07:13:33,280 --> 07:13:35,680
the you know the security guarantees

7497
07:13:35,680 --> 07:13:37,040
also

7498
07:13:37,040 --> 07:13:37,840
yeah

7499
07:13:37,840 --> 07:13:39,120
uh yeah maybe if there's another

7500
07:13:39,120 --> 07:13:41,920
question first

7501
07:13:46,958 --> 07:13:50,160
hi tariq thanks for the talk um so your

7502
07:13:50,160 --> 07:13:51,840
the multi-snapshot model assumes that

7503
07:13:51,840 --> 07:13:53,760
there's no query information in the

7504
07:13:53,760 --> 07:13:55,440
snapshot

7505
07:13:55,440 --> 07:13:58,160
yeah so i know where you are getting to

7506
07:13:58,160 --> 07:14:00,240
keep anticipating my question okay yeah

7507
07:14:00,240 --> 07:14:03,200
yeah continue

7508
07:14:03,200 --> 07:14:05,200
oh yeah yeah so i guess well i mean i

7509
07:14:05,200 --> 07:14:07,040
have several questions but like

7510
07:14:07,040 --> 07:14:08,798
what i i guess like my high level

7511
07:14:08,798 --> 07:14:11,520
question is why do you believe that that

7512
07:14:11,520 --> 07:14:13,200
this is a suitable model for a

7513
07:14:13,200 --> 07:14:15,280
compromise of of not just like your

7514
07:14:15,280 --> 07:14:17,920
scheme but like mongodb the system

7515
07:14:17,920 --> 07:14:20,320
um because i like it's not published but

7516
07:14:20,320 --> 07:14:22,320
i did some work looking at mongodb and

7517
07:14:22,320 --> 07:14:24,160
what it logs and what it reveals about

7518
07:14:24,160 --> 07:14:26,080
queries and like it logs like a hell of

7519
07:14:26,080 --> 07:14:27,680
a lot of information

7520
07:14:27,680 --> 07:14:29,280
that and so i just kind of like i'm

7521
07:14:29,280 --> 07:14:31,200
curious like does mongodb plan to take

7522
07:14:31,200 --> 07:14:32,558
any kind of

7523
07:14:32,558 --> 07:14:34,080
hardening counter measures to try to

7524
07:14:34,080 --> 07:14:36,160
reduce what is logged and like in

7525
07:14:36,160 --> 07:14:37,680
general how do you plan to explain to

7526
07:14:37,680 --> 07:14:39,360
customers like

7527
07:14:39,360 --> 07:14:40,718
or like motivate why this model is

7528
07:14:40,718 --> 07:14:41,840
suitable for like the attacks that

7529
07:14:41,840 --> 07:14:43,920
they're concerned about because like

7530
07:14:43,920 --> 07:14:45,200
like for for example you just talked

7531
07:14:45,200 --> 07:14:46,160
about like a rogue database

7532
07:14:46,160 --> 07:14:47,200
administrator but a database

7533
07:14:47,200 --> 07:14:49,040
administrator has access to

7534
07:14:49,040 --> 07:14:50,798
all of the performance information and

7535
07:14:50,798 --> 07:14:52,958
all the statistics that are correlated

7536
07:14:52,958 --> 07:14:55,520
with the queries um so it just seems

7537
07:14:55,520 --> 07:14:57,280
like this isn't like this multi-snapshot

7538
07:14:57,280 --> 07:14:59,120
model is like very it's very difficult

7539
07:14:59,120 --> 07:15:01,280
to imagine how it maps onto a real

7540
07:15:01,280 --> 07:15:02,558
compromise

7541
07:15:02,558 --> 07:15:04,638
yeah no no absolutely like this is this

7542
07:15:04,638 --> 07:15:06,400
is a valid question like this is a valid

7543
07:15:06,400 --> 07:15:08,558
question and we we

7544
07:15:08,558 --> 07:15:10,798
we did a lot of thinking like it's not

7545
07:15:10,798 --> 07:15:12,558
something that you take lightly

7546
07:15:12,558 --> 07:15:15,120
and yes you're right in in that touch

7547
07:15:15,120 --> 07:15:16,798
any database it's not just mongodb there

7548
07:15:16,798 --> 07:15:18,798
is a lot of caching the storage engine

7549
07:15:18,798 --> 07:15:20,878
will have its own caching the os will

7550
07:15:20,878 --> 07:15:22,878
have its own caching the virtual machine

7551
07:15:22,878 --> 07:15:24,878
will have its own caching like you have

7552
07:15:24,878 --> 07:15:27,440
caching at every single uh layer of the

7553
07:15:27,440 --> 07:15:29,200
architecture then you will have the

7554
07:15:29,200 --> 07:15:31,200
memory itself you will have locks you

7555
07:15:31,200 --> 07:15:32,958
will have journal logs you will have all

7556
07:15:32,958 --> 07:15:35,520
of that yes so there is a lot of work

7557
07:15:35,520 --> 07:15:36,958
that we are doing

7558
07:15:36,958 --> 07:15:39,120
two aspects there are two kind of like

7559
07:15:39,120 --> 07:15:41,360
two dimensions uh and this is something

7560
07:15:41,360 --> 07:15:43,120
that we have been thinking already maybe

7561
07:15:43,120 --> 07:15:45,040
two years already so there is the

7562
07:15:45,040 --> 07:15:46,638
heuristic and this is maybe like

7563
07:15:46,638 --> 07:15:48,080
something that you already touched on

7564
07:15:48,080 --> 07:15:49,760
hardening or something like that which

7565
07:15:49,760 --> 07:15:52,958
is basically how to reduce the amount of

7566
07:15:52,958 --> 07:15:55,280
memory that's uh sorry the amount of

7567
07:15:55,280 --> 07:15:57,920
kind of like cash related to the queries

7568
07:15:57,920 --> 07:15:59,920
that it's cash this is something that we

7569
07:15:59,920 --> 07:16:01,360
are starting to do and it's something

7570
07:16:01,360 --> 07:16:03,600
that we really take seriously the second

7571
07:16:03,600 --> 07:16:05,680
direction which is more formal or more

7572
07:16:05,680 --> 07:16:08,718
theoretical which is really modeling

7573
07:16:08,718 --> 07:16:11,680
the information that gets cached and as

7574
07:16:11,680 --> 07:16:13,760
many layers in the database system and

7575
07:16:13,760 --> 07:16:15,520
this of course it's a music it's a

7576
07:16:15,520 --> 07:16:17,120
massive project just getting to

7577
07:16:17,120 --> 07:16:19,600
understand the storage engine and the

7578
07:16:19,600 --> 07:16:21,840
way how it crashes information and how

7579
07:16:21,840 --> 07:16:24,160
it flashes the queries from the cache

7580
07:16:24,160 --> 07:16:26,080
understanding all of the layers and this

7581
07:16:26,080 --> 07:16:27,120
is where

7582
07:16:27,120 --> 07:16:28,718
we are spending a lot of time to think

7583
07:16:28,718 --> 07:16:31,600
about like how to theoretically model

7584
07:16:31,600 --> 07:16:33,680
how caching also we have a much better

7585
07:16:33,680 --> 07:16:35,360
understanding of

7586
07:16:35,360 --> 07:16:37,280
uh of really what's

7587
07:16:37,280 --> 07:16:39,360
what what what's gay what's being

7588
07:16:39,360 --> 07:16:41,760
accessed by for example a more powerful

7589
07:16:41,760 --> 07:16:43,600
adversity like that can get accustomed

7590
07:16:43,600 --> 07:16:47,199
yes it's a valid it's a valid question

7591
07:16:49,200 --> 07:16:51,840
so maybe we'll do

7592
07:16:52,320 --> 07:16:55,478
two more

7593
07:17:07,600 --> 07:17:09,680
so so

7594
07:17:09,680 --> 07:17:11,680
so i think that this is really tricky

7595
07:17:11,680 --> 07:17:13,200
because so i think that's

7596
07:17:13,200 --> 07:17:15,040
correct me if i'm wrong but

7597
07:17:15,040 --> 07:17:16,478
maybe you are thinking about synapses

7598
07:17:16,478 --> 07:17:17,840
other kind of like because it's a word

7599
07:17:17,840 --> 07:17:19,840
that is used also in transaction

7600
07:17:19,840 --> 07:17:20,798
uh

7601
07:17:20,798 --> 07:17:23,280
but but

7602
07:17:24,878 --> 07:17:26,958
right

7603
07:17:26,958 --> 07:17:29,040
oh yeah i see i see so okay so

7604
07:17:29,040 --> 07:17:30,718
definitely like this is a valid question

7605
07:17:30,718 --> 07:17:32,478
so you are saying like me if i'm wrong

7606
07:17:32,478 --> 07:17:36,000
i'm just rephrasing like if i understood

7607
07:17:36,398 --> 07:17:38,080
exactly yeah yeah yeah this is this is

7608
07:17:38,080 --> 07:17:40,240
true like yeah

7609
07:17:40,240 --> 07:17:42,320
yeah yeah no no this is really this is a

7610
07:17:42,320 --> 07:17:45,120
really good question that's

7611
07:17:45,120 --> 07:17:45,520
uh true

7612
07:17:45,520 --> 07:17:48,080
database has some concurrency tools like

7613
07:17:48,080 --> 07:17:49,840
the way how they implement transactions

7614
07:17:49,840 --> 07:17:52,558
so there is the indcc there is like a pc

7615
07:17:52,558 --> 07:17:54,320
mystic locking whatever like there are

7616
07:17:54,320 --> 07:17:57,520
so many ways how to have the acid and

7617
07:17:57,520 --> 07:18:00,000
some ways to do to enforce the

7618
07:18:00,000 --> 07:18:02,320
transactional aspects you need to have a

7619
07:18:02,320 --> 07:18:04,718
rollbacks or stuff like that yes

7620
07:18:04,718 --> 07:18:06,160
definitely like this is definitely one

7621
07:18:06,160 --> 07:18:07,760
part that we are looking at in the

7622
07:18:07,760 --> 07:18:09,200
snapshot like this is definitely we are

7623
07:18:09,200 --> 07:18:13,040
considering it as part of the leak here

7624
07:18:13,040 --> 07:18:16,840
does this answer your questions

7625
07:18:28,000 --> 07:18:31,520
yeah yeah we will have it soon

7626
07:18:31,760 --> 07:18:34,398
and um a follow-up to

7627
07:18:34,398 --> 07:18:35,760
your previous answer and also what

7628
07:18:35,760 --> 07:18:36,878
senior said

7629
07:18:36,878 --> 07:18:40,478
do you have any road map as to

7630
07:18:40,478 --> 07:18:42,798
going towards a more

7631
07:18:42,798 --> 07:18:46,080
well harder uh thread model

7632
07:18:46,080 --> 07:18:48,638
so yeah i don't know how yeah yeah no

7633
07:18:48,638 --> 07:18:49,840
definitely like

7634
07:18:49,840 --> 07:18:51,040
you know

7635
07:18:51,040 --> 07:18:52,798
so

7636
07:18:52,798 --> 07:18:54,958
as as i mentioned earlier this is

7637
07:18:54,958 --> 07:18:56,958
something that it's really fascinating

7638
07:18:56,958 --> 07:18:58,878
to both of us and we really think about

7639
07:18:58,878 --> 07:19:01,520
liquid suppression really seriously so

7640
07:19:01,520 --> 07:19:02,638
uh

7641
07:19:02,638 --> 07:19:05,520
so now we we have our rodents like

7642
07:19:05,520 --> 07:19:08,160
different road maps and and this is

7643
07:19:08,160 --> 07:19:09,840
definitely something that we we are

7644
07:19:09,840 --> 07:19:13,520
keeping a very close eye on

7645
07:19:14,398 --> 07:19:15,600
so

7646
07:19:15,600 --> 07:19:16,638
yeah so maybe

7647
07:19:16,638 --> 07:19:18,478
let me so

7648
07:19:18,478 --> 07:19:20,398
so we're still we're doing the research

7649
07:19:20,398 --> 07:19:21,440
on this right

7650
07:19:21,440 --> 07:19:23,120
it's a research project that's going on

7651
07:19:23,120 --> 07:19:24,240
at mongol

7652
07:19:24,240 --> 07:19:25,600
in the mongol research group that's

7653
07:19:25,600 --> 07:19:27,040
still happening on

7654
07:19:27,040 --> 07:19:29,680
persistent model leakage oppression

7655
07:19:29,680 --> 07:19:31,680
practical leakage suppression

7656
07:19:31,680 --> 07:19:33,120
uh understanding leakage better there's

7657
07:19:33,120 --> 07:19:36,958
a ton of projects that we're doing

7658
07:19:37,120 --> 07:19:39,120
when and how that gets into products is

7659
07:19:39,120 --> 07:19:41,680
a much more complicated discussion that

7660
07:19:41,680 --> 07:19:43,120
has to deal with

7661
07:19:43,120 --> 07:19:45,120
what engineering trade-offs do we want

7662
07:19:45,120 --> 07:19:46,160
to make

7663
07:19:46,160 --> 07:19:47,920
what are customers asking for do

7664
07:19:47,920 --> 07:19:49,520
customers want it

7665
07:19:49,520 --> 07:19:50,958
right like some customers are perfectly

7666
07:19:50,958 --> 07:19:52,798
happy with snapchat they're like this is

7667
07:19:52,798 --> 07:19:54,240
what we need this is what we want we

7668
07:19:54,240 --> 07:19:55,680
don't want more at least not for now

7669
07:19:55,680 --> 07:19:56,638
right so

7670
07:19:56,638 --> 07:19:59,920
these discussions are not led by

7671
07:19:59,920 --> 07:20:02,000
a research paper we say hey we know how

7672
07:20:02,000 --> 07:20:04,080
to do x let's put it in the product

7673
07:20:04,080 --> 07:20:05,760
right they're led more by like what our

7674
07:20:05,760 --> 07:20:08,877
customers asking for

7675
07:20:16,638 --> 07:20:19,040
well we don't make estimates in research

7676
07:20:19,040 --> 07:20:22,000
right what we do is we do the research

7677
07:20:22,000 --> 07:20:24,558
and then uh estimates are made by

7678
07:20:24,558 --> 07:20:26,320
uh the product teams that work with

7679
07:20:26,320 --> 07:20:27,360
customers

7680
07:20:27,360 --> 07:20:28,798
and depending on

7681
07:20:28,798 --> 07:20:31,840
uh what we have available and what

7682
07:20:31,840 --> 07:20:35,200
customers want right depending on what

7683
07:20:35,200 --> 07:20:37,280
can be achieved then we see okay what do

7684
07:20:37,280 --> 07:20:39,280
we want to do right that's that's how it

7685
07:20:39,280 --> 07:20:41,120
that's how it works

7686
07:20:41,120 --> 07:20:42,398
all right yeah but i would just

7687
07:20:42,398 --> 07:20:44,160
definitely add like you know definitely

7688
07:20:44,160 --> 07:20:45,680
more work like if you are interested in

7689
07:20:45,680 --> 07:20:48,398
uk suppression go for it yeah we are

7690
07:20:48,398 --> 07:20:52,080
happy to read more of your world yeah

7691
07:20:52,080 --> 07:20:53,360
all right so i think we'll we'll end

7692
07:20:53,360 --> 07:20:56,798
here let's thank tariq again

7693
07:21:37,200 --> 07:21:39,280
you

