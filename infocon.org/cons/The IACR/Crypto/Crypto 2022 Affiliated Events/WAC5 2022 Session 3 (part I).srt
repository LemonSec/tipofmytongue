1
00:00:00,640 --> 00:00:03,120
hello everyone my name is ying chan and

2
00:00:03,120 --> 00:00:04,640
my name is ricardo

3
00:00:04,640 --> 00:00:06,240
and today we will tell you about a new

4
00:00:06,240 --> 00:00:08,320
class of side channel attacks called

5
00:00:08,320 --> 00:00:10,240
hertzbled

6
00:00:10,240 --> 00:00:12,400
powers side channel attacks and remote

7
00:00:12,400 --> 00:00:15,040
timing attacks used to be two disjoint

8
00:00:15,040 --> 00:00:16,800
classes of attacks

9
00:00:16,800 --> 00:00:18,800
on the one hand we have power sets and

10
00:00:18,800 --> 00:00:21,439
attacks these attacks allow to infer

11
00:00:21,439 --> 00:00:23,199
very small changes in a program's

12
00:00:23,199 --> 00:00:25,599
execution but they require access to

13
00:00:25,599 --> 00:00:27,840
power measurement interfaces

14
00:00:27,840 --> 00:00:29,279
and on the other hand we have remote

15
00:00:29,279 --> 00:00:30,640
timing attacks

16
00:00:30,640 --> 00:00:32,960
these attacks could only detect coarse

17
00:00:32,960 --> 00:00:35,680
grain changes in a program's execution

18
00:00:35,680 --> 00:00:37,760
but they can be performed without access

19
00:00:37,760 --> 00:00:40,640
to any special measurement interface

20
00:00:40,640 --> 00:00:43,280
in this talk we introduce hertzbleed

21
00:00:43,280 --> 00:00:45,039
heart split bridges the gap between

22
00:00:45,039 --> 00:00:47,920
these two disjoint classes of attacks

23
00:00:47,920 --> 00:00:50,480
by allowing to turn power saturn attacks

24
00:00:50,480 --> 00:00:52,800
into remote atomic attacks

25
00:00:52,800 --> 00:00:53,760
this way

26
00:00:53,760 --> 00:00:56,399
hertz bleed makes those changes that up

27
00:00:56,399 --> 00:00:58,719
until today we're only deductible with

28
00:00:58,719 --> 00:01:01,199
power sectional attacks detectable even

29
00:01:01,199 --> 00:01:02,800
with remote timing

30
00:01:02,800 --> 00:01:04,319
and as we will see

31
00:01:04,319 --> 00:01:05,840
this is uh

32
00:01:05,840 --> 00:01:07,840
has real implications security because

33
00:01:07,840 --> 00:01:10,240
it can be for example used to leak

34
00:01:10,240 --> 00:01:13,040
cryptographic keys via remote timing

35
00:01:13,040 --> 00:01:15,280
even from cryptographic implementations

36
00:01:15,280 --> 00:01:18,880
that follow constant time programming

37
00:01:18,880 --> 00:01:20,799
the mechanism that enables this new

38
00:01:20,799 --> 00:01:23,040
class of attacks is dynamic frequency

39
00:01:23,040 --> 00:01:24,080
scaling

40
00:01:24,080 --> 00:01:26,240
also called dbfs

41
00:01:26,240 --> 00:01:28,799
in this presentation we will first tell

42
00:01:28,799 --> 00:01:32,000
you about how and why dvfs leaks on

43
00:01:32,000 --> 00:01:33,680
modern processors

44
00:01:33,680 --> 00:01:36,079
we will then explore how to mount remote

45
00:01:36,079 --> 00:01:37,920
timing attacks on cryptographic

46
00:01:37,920 --> 00:01:39,439
implementations

47
00:01:39,439 --> 00:01:41,520
and then finally we will discuss the

48
00:01:41,520 --> 00:01:43,439
broader implications of herd split to

49
00:01:43,439 --> 00:01:45,600
security

50
00:01:45,600 --> 00:01:48,240
let's start from looking at dvfs on a

51
00:01:48,240 --> 00:01:50,399
modern intel processor

52
00:01:50,399 --> 00:01:52,880
when we run a workload on a modern intel

53
00:01:52,880 --> 00:01:54,720
processor this is what the processor

54
00:01:54,720 --> 00:01:56,399
frequency looks like during the prower

55
00:01:56,399 --> 00:01:58,240
class execution

56
00:01:58,240 --> 00:02:00,159
on the left hand side you can see that

57
00:02:00,159 --> 00:02:02,880
the processor runs at a frequency of 4.5

58
00:02:02,880 --> 00:02:04,399
gigahertz

59
00:02:04,399 --> 00:02:06,320
for a short amount of time

60
00:02:06,320 --> 00:02:09,038
this is what we call the max turbo state

61
00:02:09,038 --> 00:02:10,720
and it allows the processor to have a

62
00:02:10,720 --> 00:02:13,040
boost in performance until the processor

63
00:02:13,040 --> 00:02:15,280
hits a certain thermal limit

64
00:02:15,280 --> 00:02:17,599
after that point the processor runs at

65
00:02:17,599 --> 00:02:20,239
what we call the steady state frequency

66
00:02:20,239 --> 00:02:22,080
the steady state frequency in this case

67
00:02:22,080 --> 00:02:24,879
runs between 3.9 and 4 gigahertz and

68
00:02:24,879 --> 00:02:27,599
can't last until the workload execution

69
00:02:27,599 --> 00:02:29,440
finishes

70
00:02:29,440 --> 00:02:32,080
our analysis focuses on the latter which

71
00:02:32,080 --> 00:02:34,080
is the statistic frequency and in

72
00:02:34,080 --> 00:02:35,280
particular

73
00:02:35,280 --> 00:02:37,360
the key observation of our work is that

74
00:02:37,360 --> 00:02:39,920
steady state frequency depends on power

75
00:02:39,920 --> 00:02:42,000
consumption

76
00:02:42,000 --> 00:02:44,319
for example consider two workloads

77
00:02:44,319 --> 00:02:46,560
workload 1 and workload 2

78
00:02:46,560 --> 00:02:48,400
that normally have different power

79
00:02:48,400 --> 00:02:51,280
consumptions as shown in this diagram

80
00:02:51,280 --> 00:02:53,280
what we observed is that when we run

81
00:02:53,280 --> 00:02:55,680
these two workloads on our processor

82
00:02:55,680 --> 00:02:58,080
at steady state they run at two

83
00:02:58,080 --> 00:03:00,319
different frequencies that reflect their

84
00:03:00,319 --> 00:03:02,560
power consumptions for example in this

85
00:03:02,560 --> 00:03:05,760
case workload 1 that consumes more power

86
00:03:05,760 --> 00:03:07,599
runs at a lower frequency

87
00:03:07,599 --> 00:03:09,519
and this is an important observation

88
00:03:09,519 --> 00:03:12,080
because as we will see it allows to turn

89
00:03:12,080 --> 00:03:14,000
power sectional attacks into timing

90
00:03:14,000 --> 00:03:15,760
attacks

91
00:03:15,760 --> 00:03:16,720
now

92
00:03:16,720 --> 00:03:18,239
power sectional attacks have been known

93
00:03:18,239 --> 00:03:20,879
for a long time and over the past 25

94
00:03:20,879 --> 00:03:22,640
years one thing that we have learned is

95
00:03:22,640 --> 00:03:25,360
that power side channels allow to infer

96
00:03:25,360 --> 00:03:26,879
very small changes in a program's

97
00:03:26,879 --> 00:03:28,799
execution as i said earlier

98
00:03:28,799 --> 00:03:30,640
such as changes in the data being

99
00:03:30,640 --> 00:03:33,519
computed on so it's natural to ask the

100
00:03:33,519 --> 00:03:35,760
question does this frequency side

101
00:03:35,760 --> 00:03:38,000
channel also leak information about the

102
00:03:38,000 --> 00:03:40,000
data being computed on

103
00:03:40,000 --> 00:03:42,080
and to answer this question we

104
00:03:42,080 --> 00:03:44,799
constructed a constant time workload

105
00:03:44,799 --> 00:03:47,440
with a fixed set of instructions

106
00:03:47,440 --> 00:03:49,440
and in this workload we only change the

107
00:03:49,440 --> 00:03:51,440
data values being computed on

108
00:03:51,440 --> 00:03:53,120
namely the input

109
00:03:53,120 --> 00:03:54,000
now

110
00:03:54,000 --> 00:03:56,319
in our workload and just as we know from

111
00:03:56,319 --> 00:03:57,599
prior work

112
00:03:57,599 --> 00:03:59,360
changing the input will cause

113
00:03:59,360 --> 00:04:01,280
differences in power consumption as we

114
00:04:01,280 --> 00:04:03,519
can see in the process in the diagram to

115
00:04:03,519 --> 00:04:04,799
the left

116
00:04:04,799 --> 00:04:06,239
what we observed

117
00:04:06,239 --> 00:04:08,400
is that changing these inputs also

118
00:04:08,400 --> 00:04:10,000
reflects in changes to statistic

119
00:04:10,000 --> 00:04:12,319
frequency on our processor

120
00:04:12,319 --> 00:04:14,799
now from now on we will only talk about

121
00:04:14,799 --> 00:04:16,560
uh steady state frequency that we will

122
00:04:16,560 --> 00:04:18,399
just refer to as frequency

123
00:04:18,399 --> 00:04:19,199
but

124
00:04:19,199 --> 00:04:21,358
for the sake of uh of this

125
00:04:21,358 --> 00:04:23,120
presentation the message that really is

126
00:04:23,120 --> 00:04:25,680
important as we will see is that changes

127
00:04:25,680 --> 00:04:27,759
in the data being computed on by a

128
00:04:27,759 --> 00:04:28,720
program

129
00:04:28,720 --> 00:04:30,639
can reflect to differences in cpu

130
00:04:30,639 --> 00:04:32,960
frequency as you will see this is the

131
00:04:32,960 --> 00:04:34,720
key observation that will allow us to

132
00:04:34,720 --> 00:04:37,280
mount remote timing attacks even on

133
00:04:37,280 --> 00:04:38,880
cryptographic implementations that were

134
00:04:38,880 --> 00:04:40,720
considered secure against standing

135
00:04:40,720 --> 00:04:43,520
attacks up until today

136
00:04:43,520 --> 00:04:45,440
now let me give an example

137
00:04:45,440 --> 00:04:48,320
consider this function sum that computes

138
00:04:48,320 --> 00:04:50,639
the sum of two arguments first and

139
00:04:50,639 --> 00:04:51,600
second

140
00:04:51,600 --> 00:04:53,520
and let's suppose that we

141
00:04:53,520 --> 00:04:55,520
run this function as part of a program

142
00:04:55,520 --> 00:04:57,520
for example a cryptographic program

143
00:04:57,520 --> 00:05:00,240
with two different sets of test inputs

144
00:05:00,240 --> 00:05:03,440
test one and test2

145
00:05:03,440 --> 00:05:05,759
we can ask the question which of the two

146
00:05:05,759 --> 00:05:07,919
tests functions runs at a higher

147
00:05:07,919 --> 00:05:10,919
frequency

148
00:05:11,120 --> 00:05:12,639
so we can think about this function

149
00:05:12,639 --> 00:05:14,320
indeed this question

150
00:05:14,320 --> 00:05:15,360
and

151
00:05:15,360 --> 00:05:16,720
it turns out

152
00:05:16,720 --> 00:05:19,120
that perhaps counterintuitively

153
00:05:19,120 --> 00:05:22,560
test2 runs at higher frequency

154
00:05:22,560 --> 00:05:24,479
the way we were able to answer this

155
00:05:24,479 --> 00:05:26,160
question in our paper

156
00:05:26,160 --> 00:05:27,280
was

157
00:05:27,280 --> 00:05:28,720
and we were able to be able to answer

158
00:05:28,720 --> 00:05:31,280
this question systematically for data is

159
00:05:31,280 --> 00:05:33,199
by constructively constructing a leakage

160
00:05:33,199 --> 00:05:35,600
model and in our paper we construct a

161
00:05:35,600 --> 00:05:38,160
leakage model for the dependency between

162
00:05:38,160 --> 00:05:40,479
data being computed on and power

163
00:05:40,479 --> 00:05:42,720
consumption or frequency on modern intel

164
00:05:42,720 --> 00:05:45,120
processors

165
00:05:45,120 --> 00:05:47,759
we find that there are three important

166
00:05:47,759 --> 00:05:48,800
effects

167
00:05:48,800 --> 00:05:50,840
that are independent and that affect its

168
00:05:50,840 --> 00:05:53,600
dependency the hamming distance effect

169
00:05:53,600 --> 00:05:55,600
the hamming weight effect and the bit

170
00:05:55,600 --> 00:05:57,120
positions

171
00:05:57,120 --> 00:06:00,240
i will now explain each of these effects

172
00:06:00,240 --> 00:06:01,840
and then we will look at a case study

173
00:06:01,840 --> 00:06:03,360
for one of these effects before we turn

174
00:06:03,360 --> 00:06:05,520
into the security implications

175
00:06:05,520 --> 00:06:08,960
let's start from the hamming distance

176
00:06:08,960 --> 00:06:10,720
suppose that during a workload execute

177
00:06:10,720 --> 00:06:13,520
execution we have a computation that

178
00:06:13,520 --> 00:06:15,840
updates the content of a register ax

179
00:06:15,840 --> 00:06:17,759
perhaps due to a shift

180
00:06:17,759 --> 00:06:19,680
as shown in the slide

181
00:06:19,680 --> 00:06:22,000
now when we have this computation

182
00:06:22,000 --> 00:06:24,000
the hamming distance is the number of

183
00:06:24,000 --> 00:06:26,720
bits that flip either from 0 to 1 or

184
00:06:26,720 --> 00:06:29,360
from 1 to 0 during this computation

185
00:06:29,360 --> 00:06:31,840
in this case the number of bit flips is

186
00:06:31,840 --> 00:06:34,000
10 meaning that the hamming distance is

187
00:06:34,000 --> 00:06:35,520
10

188
00:06:35,520 --> 00:06:37,120
on the other hand in the example at the

189
00:06:37,120 --> 00:06:39,600
bottom of this slide we have only six

190
00:06:39,600 --> 00:06:42,000
bits that flip between zero to one or

191
00:06:42,000 --> 00:06:43,680
one to zero meaning that the hamming

192
00:06:43,680 --> 00:06:45,919
distance is six

193
00:06:45,919 --> 00:06:48,479
what we observed on our processors

194
00:06:48,479 --> 00:06:49,919
is that

195
00:06:49,919 --> 00:06:51,680
this feature of the data that is being

196
00:06:51,680 --> 00:06:53,919
computed on namely the hamming distance

197
00:06:53,919 --> 00:06:56,400
does affect frequency and in particular

198
00:06:56,400 --> 00:06:58,319
the lower the hamming distance

199
00:06:58,319 --> 00:06:59,840
the lower the power consumption and

200
00:06:59,840 --> 00:07:02,319
therefore the higher the frequency

201
00:07:02,319 --> 00:07:04,000
and this is an important observation as

202
00:07:04,000 --> 00:07:06,800
we will see for security

203
00:07:06,800 --> 00:07:09,360
the second independent effect that we

204
00:07:09,360 --> 00:07:11,919
observe beyond the humming distance is

205
00:07:11,919 --> 00:07:14,639
the humming great effect

206
00:07:14,639 --> 00:07:17,280
consider during a workload execution

207
00:07:17,280 --> 00:07:18,800
that we have a computation that looks

208
00:07:18,800 --> 00:07:20,000
like this

209
00:07:20,000 --> 00:07:22,240
where it computes on again this register

210
00:07:22,240 --> 00:07:23,360
ax

211
00:07:23,360 --> 00:07:25,360
but the number of bit transitions is

212
00:07:25,360 --> 00:07:26,240
zero

213
00:07:26,240 --> 00:07:27,919
because there are no bits that flip

214
00:07:27,919 --> 00:07:29,599
during this computation

215
00:07:29,599 --> 00:07:31,759
what we found is that the number of bits

216
00:07:31,759 --> 00:07:33,599
that are set to one in this computation

217
00:07:33,599 --> 00:07:35,520
which is called the hamming weight

218
00:07:35,520 --> 00:07:37,919
affects the power consumption and

219
00:07:37,919 --> 00:07:39,199
frequency

220
00:07:39,199 --> 00:07:41,280
as follows so consider in this case we

221
00:07:41,280 --> 00:07:43,039
have a hamming weight of 12

222
00:07:43,039 --> 00:07:45,199
and in the second example where we have

223
00:07:45,199 --> 00:07:48,479
last ones we have a hamming weight of 8.

224
00:07:48,479 --> 00:07:50,800
what we saw is that the lower the

225
00:07:50,800 --> 00:07:52,080
hamming weight

226
00:07:52,080 --> 00:07:54,080
the lower the power consumption

227
00:07:54,080 --> 00:07:55,759
and the higher the frequency

228
00:07:55,759 --> 00:07:57,759
this is important as we will see

229
00:07:57,759 --> 00:07:59,280
because it means that

230
00:07:59,280 --> 00:08:01,039
it will have particularly dangerous

231
00:08:01,039 --> 00:08:03,199
effects for cryptographic software that

232
00:08:03,199 --> 00:08:05,120
runs either

233
00:08:05,120 --> 00:08:06,720
low or high humming weight or having

234
00:08:06,720 --> 00:08:10,960
distance data flows depending on secrets

235
00:08:10,960 --> 00:08:13,199
finally the third independent effect

236
00:08:13,199 --> 00:08:15,120
that we observed is the one of the bit

237
00:08:15,120 --> 00:08:16,240
positions

238
00:08:16,240 --> 00:08:18,080
now what does this mean

239
00:08:18,080 --> 00:08:20,240
let's assume that we have a computation

240
00:08:20,240 --> 00:08:21,680
that looks just the same as the one in

241
00:08:21,680 --> 00:08:23,759
the previous slide where we're computing

242
00:08:23,759 --> 00:08:25,599
on data in this case with the hamming

243
00:08:25,599 --> 00:08:26,879
weight of eight

244
00:08:26,879 --> 00:08:29,520
and the hamming distance is zero

245
00:08:29,520 --> 00:08:32,719
what we observed is that the positions

246
00:08:32,719 --> 00:08:35,760
of ones in these data values does affect

247
00:08:35,760 --> 00:08:37,360
frequency as well

248
00:08:37,360 --> 00:08:39,839
for example in this case we have once in

249
00:08:39,839 --> 00:08:41,120
the most significant bits of this

250
00:08:41,120 --> 00:08:42,880
register a ax

251
00:08:42,880 --> 00:08:45,200
on the other hand in the second example

252
00:08:45,200 --> 00:08:47,440
we have ones in the least significant

253
00:08:47,440 --> 00:08:49,519
bits of this register a ax

254
00:08:49,519 --> 00:08:51,040
both cases have the same hamming

255
00:08:51,040 --> 00:08:53,120
distance and the same having weight

256
00:08:53,120 --> 00:08:54,399
and what we saw

257
00:08:54,399 --> 00:08:56,560
is that the second case consumes less

258
00:08:56,560 --> 00:08:59,200
power and runs at a higher frequency

259
00:08:59,200 --> 00:09:00,720
and this is particularly important to

260
00:09:00,720 --> 00:09:02,560
keep in mind in the future because it

261
00:09:02,560 --> 00:09:03,680
shows that

262
00:09:03,680 --> 00:09:05,760
even if the humming weight and humming

263
00:09:05,760 --> 00:09:07,519
distances are the same

264
00:09:07,519 --> 00:09:10,160
across two different computations

265
00:09:10,160 --> 00:09:11,839
the frequency channel can leak

266
00:09:11,839 --> 00:09:14,720
information about the positions of ones

267
00:09:14,720 --> 00:09:17,200
within data values which is a surprising

268
00:09:17,200 --> 00:09:19,440
observation for modern general purpose

269
00:09:19,440 --> 00:09:21,600
processors

270
00:09:21,600 --> 00:09:23,600
okay now you might be wondering how did

271
00:09:23,600 --> 00:09:25,680
we come to discover this bit positions

272
00:09:25,680 --> 00:09:28,560
effect and also which bit positions

273
00:09:28,560 --> 00:09:30,560
inside data values affect frequency the

274
00:09:30,560 --> 00:09:32,000
most

275
00:09:32,000 --> 00:09:33,920
and to answer these questions let's now

276
00:09:33,920 --> 00:09:35,519
look at a case study

277
00:09:35,519 --> 00:09:39,200
of this bit positions effect

278
00:09:39,360 --> 00:09:41,279
when we were studying the hamming weight

279
00:09:41,279 --> 00:09:42,880
effect so before we even looked at bit

280
00:09:42,880 --> 00:09:44,880
positions we constructed a sender that

281
00:09:44,880 --> 00:09:46,080
looked like this

282
00:09:46,080 --> 00:09:48,399
this is a workload which has an infinite

283
00:09:48,399 --> 00:09:50,480
loop of instructions that look just the

284
00:09:50,480 --> 00:09:52,800
same as the ones on the previous slide

285
00:09:52,800 --> 00:09:54,560
and in this workload we control the

286
00:09:54,560 --> 00:09:56,080
input which is the content of all these

287
00:09:56,080 --> 00:09:57,279
registers

288
00:09:57,279 --> 00:09:58,720
and notice that

289
00:09:58,720 --> 00:10:01,600
by construction in this workload the

290
00:10:01,600 --> 00:10:04,560
hamming distance is always zero and the

291
00:10:04,560 --> 00:10:06,399
hamming weight and the bit positions

292
00:10:06,399 --> 00:10:08,959
purely depend on the input that we chose

293
00:10:08,959 --> 00:10:11,760
so this workload allows us to fine-tune

294
00:10:11,760 --> 00:10:14,079
and to detect the differences

295
00:10:14,079 --> 00:10:16,240
that result from different hamming

296
00:10:16,240 --> 00:10:18,720
weights orbit positions and

297
00:10:18,720 --> 00:10:20,399
in this particular example that i will

298
00:10:20,399 --> 00:10:22,240
describe to you we're going to look at

299
00:10:22,240 --> 00:10:24,959
the effect of different number of ones

300
00:10:24,959 --> 00:10:26,959
in this input

301
00:10:26,959 --> 00:10:29,360
so here is an experiment that we're on

302
00:10:29,360 --> 00:10:31,360
in this experiment we were changing the

303
00:10:31,360 --> 00:10:33,120
number of ones either starting from the

304
00:10:33,120 --> 00:10:35,279
least significant bit or from the most

305
00:10:35,279 --> 00:10:37,200
significant bits

306
00:10:37,200 --> 00:10:39,279
and on the x axis you can see the

307
00:10:39,279 --> 00:10:41,440
hamming weight of this input

308
00:10:41,440 --> 00:10:42,959
meaning the number of ones

309
00:10:42,959 --> 00:10:45,200
and on the y-axis you can see the

310
00:10:45,200 --> 00:10:47,839
average frequency at steady state

311
00:10:47,839 --> 00:10:50,240
now as we discussed earlier

312
00:10:50,240 --> 00:10:52,079
uh first observation that we can make on

313
00:10:52,079 --> 00:10:54,480
this data is that the lower the hamming

314
00:10:54,480 --> 00:10:55,279
weight

315
00:10:55,279 --> 00:10:57,519
the lower the cpu power consumption and

316
00:10:57,519 --> 00:10:59,440
the higher the frequency and this is

317
00:10:59,440 --> 00:11:01,279
important we also show plots with power

318
00:11:01,279 --> 00:11:03,600
consumption in the paper

319
00:11:03,600 --> 00:11:06,720
but an important observation is that

320
00:11:06,720 --> 00:11:08,959
whether we start from the right which is

321
00:11:08,959 --> 00:11:10,399
the least significant bit or from the

322
00:11:10,399 --> 00:11:12,640
left the most significant bit there is a

323
00:11:12,640 --> 00:11:15,440
different slope in this strand

324
00:11:15,440 --> 00:11:17,279
and there is a split in the center

325
00:11:17,279 --> 00:11:19,440
namely this humming weight effect looks

326
00:11:19,440 --> 00:11:22,560
to be non-linear

327
00:11:22,560 --> 00:11:24,480
and to dig deeper into this observation

328
00:11:24,480 --> 00:11:26,320
we decided to run additional experiment

329
00:11:26,320 --> 00:11:28,800
using the same workload but this time

330
00:11:28,800 --> 00:11:31,920
we're setting for each byte either that

331
00:11:31,920 --> 00:11:34,480
byte to be all ones or all zeros

332
00:11:34,480 --> 00:11:36,640
and then for each byte within a 64-bit

333
00:11:36,640 --> 00:11:38,959
register we were computing the delta in

334
00:11:38,959 --> 00:11:39,760
both

335
00:11:39,760 --> 00:11:41,600
power consumption and frequency

336
00:11:41,600 --> 00:11:46,320
to see which bytes had the largest delta

337
00:11:46,320 --> 00:11:48,720
and this is what the results look like

338
00:11:48,720 --> 00:11:50,959
on the x axis you can see that there is

339
00:11:50,959 --> 00:11:53,200
the byte index zero indicating the least

340
00:11:53,200 --> 00:11:55,519
significant byte and seven indicating

341
00:11:55,519 --> 00:11:57,519
the most significant byte and on the

342
00:11:57,519 --> 00:11:59,200
y-axis you can see the delta in

343
00:11:59,200 --> 00:12:02,160
frequency when that byte has set has

344
00:12:02,160 --> 00:12:05,120
been set to all ones versus all zeros

345
00:12:05,120 --> 00:12:07,920
as you can see the cost of having ones

346
00:12:07,920 --> 00:12:08,959
in the

347
00:12:08,959 --> 00:12:11,760
different bytes is non-uniform and in

348
00:12:11,760 --> 00:12:13,600
particular we can see that the cost of

349
00:12:13,600 --> 00:12:14,959
having once in the most significant

350
00:12:14,959 --> 00:12:16,000
bytes

351
00:12:16,000 --> 00:12:17,519
is higher

352
00:12:17,519 --> 00:12:20,079
in terms of power consumption cost and

353
00:12:20,079 --> 00:12:22,160
also like frequency changes than the

354
00:12:22,160 --> 00:12:23,519
cost of having

355
00:12:23,519 --> 00:12:25,920
ones in the least significant bytes

356
00:12:25,920 --> 00:12:28,560
and again this is important as i said

357
00:12:28,560 --> 00:12:31,279
because it shows that it's not just

358
00:12:31,279 --> 00:12:32,560
differences in hamming weight and

359
00:12:32,560 --> 00:12:34,079
hamming distances that can be leaked

360
00:12:34,079 --> 00:12:36,720
through frequency but even more minute

361
00:12:36,720 --> 00:12:38,639
changes such as the ones about the bit

362
00:12:38,639 --> 00:12:40,399
positions

363
00:12:40,399 --> 00:12:42,240
in the paper we also described a lot

364
00:12:42,240 --> 00:12:43,680
more experiments

365
00:12:43,680 --> 00:12:44,560
on the

366
00:12:44,560 --> 00:12:46,480
each of these three independent effects

367
00:12:46,480 --> 00:12:48,480
and we also show that these effects are

368
00:12:48,480 --> 00:12:50,480
additive and independent on modern

369
00:12:50,480 --> 00:12:52,320
processors

370
00:12:52,320 --> 00:12:53,920
but for the sake of this first part of

371
00:12:53,920 --> 00:12:55,040
the dock

372
00:12:55,040 --> 00:12:57,760
the takeaway really is that computing on

373
00:12:57,760 --> 00:13:00,160
data with different power consumptions

374
00:13:00,160 --> 00:13:01,440
with different hamming weights or

375
00:13:01,440 --> 00:13:03,600
hamming distances or bit patterns

376
00:13:03,600 --> 00:13:05,680
depending on secrets can result in

377
00:13:05,680 --> 00:13:07,920
different power consumptions or cpu

378
00:13:07,920 --> 00:13:10,480
frequencies depending on that secrets

379
00:13:10,480 --> 00:13:13,040
and now in the second part of the talk

380
00:13:13,040 --> 00:13:14,880
we will show you how to exploit these

381
00:13:14,880 --> 00:13:16,639
observations to mount remote timing

382
00:13:16,639 --> 00:13:19,279
attacks on cryptography that up until

383
00:13:19,279 --> 00:13:21,120
today was considered secure against

384
00:13:21,120 --> 00:13:23,839
timing attacks

385
00:13:30,079 --> 00:13:30,800
so

386
00:13:30,800 --> 00:13:32,880
in the first first part of the talk we

387
00:13:32,880 --> 00:13:35,040
see the frequency leaks data being

388
00:13:35,040 --> 00:13:36,480
computed on

389
00:13:36,480 --> 00:13:38,800
now we're going to show how to use the

390
00:13:38,800 --> 00:13:40,560
horsepower side channel to launch a

391
00:13:40,560 --> 00:13:42,240
remote timing attack

392
00:13:42,240 --> 00:13:44,240
why can't we even do that the reason is

393
00:13:44,240 --> 00:13:46,560
very simple because frequency and timing

394
00:13:46,560 --> 00:13:49,600
are equivalent to each other

395
00:13:49,600 --> 00:13:52,079
the higher the frequency the shorter the

396
00:13:52,079 --> 00:13:54,320
running time consider a four cycle

397
00:13:54,320 --> 00:13:56,240
program here

398
00:13:56,240 --> 00:13:57,839
the cycle the number of cycles of this

399
00:13:57,839 --> 00:14:00,240
program is fixed it is always four but

400
00:14:00,240 --> 00:14:02,560
when running out more than intel cpus

401
00:14:02,560 --> 00:14:04,880
due to the frequency scaling

402
00:14:04,880 --> 00:14:08,720
the running time might differ

403
00:14:10,560 --> 00:14:12,079
now we're going to show how to use

404
00:14:12,079 --> 00:14:15,199
hurstby to launch remote timing attacks

405
00:14:15,199 --> 00:14:17,920
a post-quantum cryptography scheme

406
00:14:17,920 --> 00:14:20,480
called psych super singular exogenous

407
00:14:20,480 --> 00:14:23,760
key encapsulation scheme

408
00:14:25,199 --> 00:14:27,440
psych is a key encapsulation scheme it

409
00:14:27,440 --> 00:14:29,519
uses public key encryption scheme to

410
00:14:29,519 --> 00:14:31,680
secure a shared key

411
00:14:31,680 --> 00:14:34,079
first it has a key generation algorithm

412
00:14:34,079 --> 00:14:37,519
that published a public key as well as a

413
00:14:37,519 --> 00:14:39,040
private key

414
00:14:39,040 --> 00:14:41,600
then it has encapsulation algorithm that

415
00:14:41,600 --> 00:14:44,399
takes in the public key and outputs a

416
00:14:44,399 --> 00:14:46,720
shared key as well as a ciphertext of

417
00:14:46,720 --> 00:14:49,040
the shared key

418
00:14:49,040 --> 00:14:50,639
in the end it has an encapsulation

419
00:14:50,639 --> 00:14:52,959
algorithm that takes in the secret key

420
00:14:52,959 --> 00:14:55,199
and the ciphertext and output a shared

421
00:14:55,199 --> 00:14:57,040
key

422
00:14:57,040 --> 00:14:59,600
observe that the cipher attack c can

423
00:14:59,600 --> 00:15:01,680
actually come from anyone a malicious

424
00:15:01,680 --> 00:15:05,040
attacker or an honest user so this c

425
00:15:05,040 --> 00:15:07,839
can be anything

426
00:15:10,320 --> 00:15:13,360
psych is a widely studied post quantum

427
00:15:13,360 --> 00:15:16,000
crypto scheme it has production ready

428
00:15:16,000 --> 00:15:18,240
implementation from cloudflare circle

429
00:15:18,240 --> 00:15:21,199
and microsoft pq crypto it is currently

430
00:15:21,199 --> 00:15:23,519
in round four of nist post quantum

431
00:15:23,519 --> 00:15:26,320
crypto competition and it is deployed by

432
00:15:26,320 --> 00:15:30,320
amazon as a hybrid encryption scheme

433
00:15:32,160 --> 00:15:34,560
we found a completely new vulnerability

434
00:15:34,560 --> 00:15:37,600
in psyc that can enable

435
00:15:37,600 --> 00:15:40,880
a malicious attacker to trigger a large

436
00:15:40,880 --> 00:15:43,279
number of computations on zero depending

437
00:15:43,279 --> 00:15:46,720
on a single secret key bit

438
00:15:46,720 --> 00:15:49,399
we're going to explain to you about this

439
00:15:49,399 --> 00:15:53,440
vulnerability from a very high level

440
00:15:53,519 --> 00:15:55,600
suppose you're trying to extract the

441
00:15:55,600 --> 00:16:00,000
first bit of this secret key as k

442
00:16:00,160 --> 00:16:02,800
if the first bit equal to zero

443
00:16:02,800 --> 00:16:05,839
such hub such as a malicious ciphertext

444
00:16:05,839 --> 00:16:08,000
prime coming from the attacker can

445
00:16:08,000 --> 00:16:10,560
trigger the decapsulation algorithm to

446
00:16:10,560 --> 00:16:13,199
output a partial transcript of the

447
00:16:13,199 --> 00:16:16,880
algorithm state look like almost random

448
00:16:16,880 --> 00:16:20,000
however if the first b equals to 1 the

449
00:16:20,000 --> 00:16:22,160
same ciphertext c prime is going to

450
00:16:22,160 --> 00:16:24,160
trigger a partial transcript

451
00:16:24,160 --> 00:16:26,399
looks like r0

452
00:16:26,399 --> 00:16:28,160
from a very high level you can think of

453
00:16:28,160 --> 00:16:32,399
the encapsulation algorithm works as if

454
00:16:32,399 --> 00:16:35,440
a for loop of a equals to a times ri

455
00:16:35,440 --> 00:16:37,199
where the ris are from a random

456
00:16:37,199 --> 00:16:40,560
distribution if for speed equals to zero

457
00:16:40,560 --> 00:16:43,199
whereas if for speed equals to one

458
00:16:43,199 --> 00:16:45,600
somehow a zero jumps in at the very

459
00:16:45,600 --> 00:16:47,600
beginning and once it appears it is

460
00:16:47,600 --> 00:16:50,480
never going to go away

461
00:16:50,480 --> 00:16:51,680
in fact

462
00:16:51,680 --> 00:16:55,279
it will trigger a domino effect

463
00:16:55,279 --> 00:16:59,120
in the decapsulation algorithm of zeros

464
00:16:59,120 --> 00:17:02,320
of course such a not analogy is not what

465
00:17:02,320 --> 00:17:03,839
what is really happening inside the

466
00:17:03,839 --> 00:17:05,599
capsulation algorithm but it helps

467
00:17:05,599 --> 00:17:08,639
understanding the attack

468
00:17:10,559 --> 00:17:12,880
obviously with compared to first b

469
00:17:12,880 --> 00:17:14,959
equals to zero first b equals to one

470
00:17:14,959 --> 00:17:17,199
will create a data flow with low hamming

471
00:17:17,199 --> 00:17:19,119
weight and low hamming distance

472
00:17:19,119 --> 00:17:20,319
so that a

473
00:17:20,319 --> 00:17:22,880
cpu consumes less power runs at a higher

474
00:17:22,880 --> 00:17:25,679
frequency and the program will execute

475
00:17:25,679 --> 00:17:27,520
in shorter run time

476
00:17:27,520 --> 00:17:29,200
due to the hurst side channel that we

477
00:17:29,200 --> 00:17:32,440
just mentioned

478
00:17:32,559 --> 00:17:34,320
now let's look deeper into this psychic

479
00:17:34,320 --> 00:17:37,440
capsulation algorithm

480
00:17:37,440 --> 00:17:39,039
the very first function called by the

481
00:17:39,039 --> 00:17:40,640
decapsulation algorithm is the

482
00:17:40,640 --> 00:17:43,840
three-point ladder function

483
00:17:44,160 --> 00:17:47,440
it takes an m as a static secret key

484
00:17:47,440 --> 00:17:50,720
and a cipher text that contains pq and q

485
00:17:50,720 --> 00:17:53,280
minus p

486
00:17:55,039 --> 00:17:57,039
it has a loop iteration

487
00:17:57,039 --> 00:17:59,360
inside which it calls a subroutine x

488
00:17:59,360 --> 00:18:01,200
double and add where the data flow

489
00:18:01,200 --> 00:18:03,679
depends on the current bit mi as well as

490
00:18:03,679 --> 00:18:06,000
the cipher text

491
00:18:06,000 --> 00:18:07,679
now let's take a deeper loop into the x

492
00:18:07,679 --> 00:18:09,360
double and add because that's where the

493
00:18:09,360 --> 00:18:12,240
vulnerability is

494
00:18:12,559 --> 00:18:14,400
this x double and add function is very

495
00:18:14,400 --> 00:18:16,080
interesting it is actually quasi

496
00:18:16,080 --> 00:18:18,640
complete which means it contains a

497
00:18:18,640 --> 00:18:20,880
corner case

498
00:18:20,880 --> 00:18:23,039
the functionality of this x double and

499
00:18:23,039 --> 00:18:25,840
add is that it takes in uv and w

500
00:18:25,840 --> 00:18:29,919
and outputs 2u and u plus v and w equals

501
00:18:29,919 --> 00:18:33,200
to u minus v however the corner case is

502
00:18:33,200 --> 00:18:34,320
that

503
00:18:34,320 --> 00:18:37,120
if w is one of the two special points

504
00:18:37,120 --> 00:18:39,840
t the point of order 2 or o the point of

505
00:18:39,840 --> 00:18:42,720
infinity this function will output two u

506
00:18:42,720 --> 00:18:44,559
and zero zero

507
00:18:44,559 --> 00:18:46,320
you might wonder what does the zero even

508
00:18:46,320 --> 00:18:47,600
mean

509
00:18:47,600 --> 00:18:50,240
exactly zero zero is meaningless it is

510
00:18:50,240 --> 00:18:52,480
not the point because psych operation

511
00:18:52,480 --> 00:18:56,320
operates with projective coordinates

512
00:18:56,320 --> 00:18:58,240
as we saw previously x double and i

513
00:18:58,240 --> 00:19:00,400
stays inside inside the loop

514
00:19:00,400 --> 00:19:02,000
and the output of which is going to

515
00:19:02,000 --> 00:19:04,160
feedback to x double and add as input

516
00:19:04,160 --> 00:19:06,320
again

517
00:19:06,320 --> 00:19:08,400
when the zero zero got feedback to x

518
00:19:08,400 --> 00:19:11,200
double and add as the input either as u

519
00:19:11,200 --> 00:19:13,120
or v or w

520
00:19:13,120 --> 00:19:15,679
the x double and add will output zero

521
00:19:15,679 --> 00:19:18,240
zero again

522
00:19:18,640 --> 00:19:20,400
let's go back to the three ladder three

523
00:19:20,400 --> 00:19:23,960
point ladder function

524
00:19:25,200 --> 00:19:28,400
suppose we're at iteration i and somehow

525
00:19:28,400 --> 00:19:30,559
we put the t into the x double add

526
00:19:30,559 --> 00:19:32,320
function

527
00:19:32,320 --> 00:19:34,000
as the third input

528
00:19:34,000 --> 00:19:35,679
and this function will give us the

529
00:19:35,679 --> 00:19:38,160
invalid point 0 0 due to the corner case

530
00:19:38,160 --> 00:19:40,559
which is covered

531
00:19:40,559 --> 00:19:43,440
during next iteration i plus 1 this 0

532
00:19:43,440 --> 00:19:45,520
will be passed into the x double add

533
00:19:45,520 --> 00:19:51,160
function either as the third input or

534
00:19:53,440 --> 00:19:55,039
second input but it doesn't matter this

535
00:19:55,039 --> 00:19:58,320
function will operate again

536
00:19:59,600 --> 00:20:00,960
let's recap

537
00:20:00,960 --> 00:20:03,120
all i have said so far is that if a

538
00:20:03,120 --> 00:20:05,520
point t or o can be passed into the x

539
00:20:05,520 --> 00:20:07,039
double dot function

540
00:20:07,039 --> 00:20:08,880
as the third input

541
00:20:08,880 --> 00:20:11,679
this function will give us zero and zero

542
00:20:11,679 --> 00:20:13,919
and this zero zero will be passed into

543
00:20:13,919 --> 00:20:15,760
other parts of the function creates a

544
00:20:15,760 --> 00:20:18,720
domino effect on low hemi weight and low

545
00:20:18,720 --> 00:20:21,039
hamming distance data flow

546
00:20:21,039 --> 00:20:23,360
is it possible for attacker to trigger

547
00:20:23,360 --> 00:20:26,000
a t or o as the third input into the x

548
00:20:26,000 --> 00:20:29,120
double add function in fact yes this

549
00:20:29,120 --> 00:20:31,039
observation leads to an

550
00:20:31,039 --> 00:20:35,640
adaptive chosen ciphertext attack

551
00:20:36,400 --> 00:20:38,000
suppose the attacker knows the secret

552
00:20:38,000 --> 00:20:40,480
key up to beat k minus 1.

553
00:20:40,480 --> 00:20:42,640
it is possible to construct a ciphertext

554
00:20:42,640 --> 00:20:45,760
c prime such that if the next unknown

555
00:20:45,760 --> 00:20:49,919
bit mk does not equal to k minus 1.

556
00:20:49,919 --> 00:20:51,600
the attacker can

557
00:20:51,600 --> 00:20:54,080
trigger t as the third input into x

558
00:20:54,080 --> 00:20:55,679
double net function

559
00:20:55,679 --> 00:20:58,400
and creates a domino effect on zeros

560
00:20:58,400 --> 00:21:00,960
however in the other case such a t will

561
00:21:00,960 --> 00:21:02,960
be put into the x double net function as

562
00:21:02,960 --> 00:21:05,440
the second input so there's no domino

563
00:21:05,440 --> 00:21:08,320
effect on zero

564
00:21:12,960 --> 00:21:15,440
such a dominant effect on zero outside

565
00:21:15,440 --> 00:21:18,400
cannot be exploited by any any other

566
00:21:18,400 --> 00:21:20,880
priors timing side channels

567
00:21:20,880 --> 00:21:22,880
because even though there are large

568
00:21:22,880 --> 00:21:24,880
computations of zeros

569
00:21:24,880 --> 00:21:26,720
the number of cycles the program

570
00:21:26,720 --> 00:21:30,480
executes is secret independent

571
00:21:30,480 --> 00:21:33,200
however as we covered in the first part

572
00:21:33,200 --> 00:21:36,080
of the talk her speed can turn low hemi

573
00:21:36,080 --> 00:21:37,679
weight and low hamming distance data

574
00:21:37,679 --> 00:21:39,679
flow into shorter

575
00:21:39,679 --> 00:21:41,280
program running time

576
00:21:41,280 --> 00:21:42,320
therefore

577
00:21:42,320 --> 00:21:44,880
if mi does not equal to i minus one

578
00:21:44,880 --> 00:21:47,280
there is a domino effect on zeros and

579
00:21:47,280 --> 00:21:49,039
the data flow has low hemi weight and

580
00:21:49,039 --> 00:21:51,440
low hamming distance the cpu consumes

581
00:21:51,440 --> 00:21:53,600
less power the cpu runs at higher

582
00:21:53,600 --> 00:21:55,919
frequency so

583
00:21:55,919 --> 00:21:58,320
the program executes in shorter running

584
00:21:58,320 --> 00:22:00,400
time in the other case

585
00:22:00,400 --> 00:22:02,640
the program executes in longer running

586
00:22:02,640 --> 00:22:04,159
time

587
00:22:04,159 --> 00:22:06,640
we can use such a behavior as the oracle

588
00:22:06,640 --> 00:22:07,360
to

589
00:22:07,360 --> 00:22:10,320
extract the secret key bit by bit

590
00:22:10,320 --> 00:22:12,799
and that's how we design our chosen

591
00:22:12,799 --> 00:22:15,760
ciphertext attack

592
00:22:17,360 --> 00:22:18,960
with targeted two state of our

593
00:22:18,960 --> 00:22:21,520
implementation of psyc the first one is

594
00:22:21,520 --> 00:22:23,679
from california circle written in go the

595
00:22:23,679 --> 00:22:26,000
second one is from microsoft pq crypto

596
00:22:26,000 --> 00:22:28,799
written in c the second one is also nice

597
00:22:28,799 --> 00:22:30,320
post quantum crypto competition

598
00:22:30,320 --> 00:22:32,879
submission

599
00:22:34,559 --> 00:22:37,440
we monitor the cpu power consumption as

600
00:22:37,440 --> 00:22:39,200
well as frequency

601
00:22:39,200 --> 00:22:41,120
we confirm that when running the

602
00:22:41,120 --> 00:22:43,440
calculations with mi does not equal to

603
00:22:43,440 --> 00:22:45,840
mi minus 1 we can trigger the domino

604
00:22:45,840 --> 00:22:49,280
effects and the cpu consumes less power

605
00:22:49,280 --> 00:22:53,158
and runs at higher frequency

606
00:22:54,480 --> 00:22:56,159
in the end we launched a remote timing

607
00:22:56,159 --> 00:22:58,559
attack

608
00:22:58,720 --> 00:23:00,960
we have a malicious attacker who can

609
00:23:00,960 --> 00:23:02,960
construct the ciphertex c prime

610
00:23:02,960 --> 00:23:04,720
according to our adaptive chosen

611
00:23:04,720 --> 00:23:07,679
ciphertext algorithm we have a server

612
00:23:07,679 --> 00:23:10,240
that takes in this cipher text

613
00:23:10,240 --> 00:23:13,120
and encapsulates it using either circle

614
00:23:13,120 --> 00:23:15,919
or picocrypto and sends back

615
00:23:15,919 --> 00:23:18,400
an acknowledgement to confirm the

616
00:23:18,400 --> 00:23:21,360
establishment of a shared key

617
00:23:21,360 --> 00:23:23,200
the malicious attacker inside this case

618
00:23:23,200 --> 00:23:24,880
will only time how long it takes to

619
00:23:24,880 --> 00:23:27,200
finish unconcurrent requests but nothing

620
00:23:27,200 --> 00:23:29,440
else

621
00:23:30,320 --> 00:23:31,679
we're able to

622
00:23:31,679 --> 00:23:33,600
recover circle

623
00:23:33,600 --> 00:23:38,080
full secret key bit by b in 36 hours

624
00:23:38,080 --> 00:23:41,039
we're also able to recover pq crypto

625
00:23:41,039 --> 00:23:44,000
secret key bit by bit in 89 hours

626
00:23:44,000 --> 00:23:46,000
one thing to note here is that the

627
00:23:46,000 --> 00:23:48,799
timing signal is strong for top

628
00:23:48,799 --> 00:23:51,039
secret key bits as well as last secret

629
00:23:51,039 --> 00:23:53,600
key bits the reason is that the domino

630
00:23:53,600 --> 00:23:56,000
effect on zero actually propagates

631
00:23:56,000 --> 00:23:57,919
beyond the three-point letter function

632
00:23:57,919 --> 00:24:02,120
into other parts of the algorithm

633
00:24:06,240 --> 00:24:08,400
such a faulty behavior on psych is

634
00:24:08,400 --> 00:24:10,400
actually acceptable by its own threat

635
00:24:10,400 --> 00:24:11,840
model

636
00:24:11,840 --> 00:24:13,360
however

637
00:24:13,360 --> 00:24:15,600
due to hurt speed it can be remounted it

638
00:24:15,600 --> 00:24:19,840
can be mounted as a remote timing attack

639
00:24:20,640 --> 00:24:23,120
strike is only an example of the power

640
00:24:23,120 --> 00:24:26,159
of hersley now let's talk of let's talk

641
00:24:26,159 --> 00:24:28,799
about the security impact of her speed

642
00:24:28,799 --> 00:24:32,120
young psych

643
00:24:33,120 --> 00:24:36,640
timing attack has been here for 25 years

644
00:24:36,640 --> 00:24:39,440
during this 25 years people have

645
00:24:39,440 --> 00:24:41,200
developed

646
00:24:41,200 --> 00:24:42,960
three different constant time

647
00:24:42,960 --> 00:24:45,760
programming principles to defend against

648
00:24:45,760 --> 00:24:47,679
power to defend against timing side

649
00:24:47,679 --> 00:24:50,400
channel attacks

650
00:24:51,039 --> 00:24:52,960
hercules showed that current practices

651
00:24:52,960 --> 00:24:54,720
for how to write constant time code are

652
00:24:54,720 --> 00:24:56,320
no longer sufficient to guarantee

653
00:24:56,320 --> 00:24:58,480
constant time execution

654
00:24:58,480 --> 00:25:00,720
the reason is that her speed can turn

655
00:25:00,720 --> 00:25:04,640
power leakage into timing leakage

656
00:25:04,799 --> 00:25:07,120
here's another way to think about it

657
00:25:07,120 --> 00:25:09,919
there are three factors that influences

658
00:25:09,919 --> 00:25:12,480
the program execution type instructions

659
00:25:12,480 --> 00:25:15,760
per program cycles per instruction as

660
00:25:15,760 --> 00:25:17,760
well as seconds per cycle

661
00:25:17,760 --> 00:25:20,080
note that the third factor is actually

662
00:25:20,080 --> 00:25:23,120
the inverse of frequency

663
00:25:23,120 --> 00:25:25,520
all previous timing attacks exploit the

664
00:25:25,520 --> 00:25:27,200
first two factors

665
00:25:27,200 --> 00:25:28,880
and all previous constant time

666
00:25:28,880 --> 00:25:31,200
programming principles address the first

667
00:25:31,200 --> 00:25:32,799
two factors

668
00:25:32,799 --> 00:25:34,880
however her speed targets target the

669
00:25:34,880 --> 00:25:37,440
third third one and that's why the

670
00:25:37,440 --> 00:25:39,679
current constant time program principles

671
00:25:39,679 --> 00:25:40,840
are not

672
00:25:40,840 --> 00:25:42,960
insufficient how can we make sure that

673
00:25:42,960 --> 00:25:44,960
frequency variations do not depend on

674
00:25:44,960 --> 00:25:47,039
secrets

675
00:25:47,039 --> 00:25:51,039
now let's look at some mitigation ideas

676
00:25:52,159 --> 00:25:55,039
first we can disable frequency boost

677
00:25:55,039 --> 00:25:57,919
when we are running our experiments with

678
00:25:57,919 --> 00:26:00,080
turbo boost off

679
00:26:00,080 --> 00:26:02,320
we observe the cpu running at base

680
00:26:02,320 --> 00:26:04,240
frequency all the time and we see no

681
00:26:04,240 --> 00:26:07,440
leakage from her speed

682
00:26:07,440 --> 00:26:09,600
however notice that this is only a

683
00:26:09,600 --> 00:26:11,679
mitigation for another defense

684
00:26:11,679 --> 00:26:14,720
and it incurs system-wide performance

685
00:26:14,720 --> 00:26:17,039
cost

686
00:26:17,120 --> 00:26:18,960
second we can mitigate

687
00:26:18,960 --> 00:26:21,760
leakage in the ciphers themselves

688
00:26:21,760 --> 00:26:23,679
for example we can avoid data flows with

689
00:26:23,679 --> 00:26:25,600
largely different hemi weight or having

690
00:26:25,600 --> 00:26:28,320
distance depending on sequence but

691
00:26:28,320 --> 00:26:32,000
consider how large the input space of

692
00:26:32,000 --> 00:26:34,000
any cryptal system is it might be hard

693
00:26:34,000 --> 00:26:36,720
to guarantee this

694
00:26:36,880 --> 00:26:39,440
or we can apply data masking to internal

695
00:26:39,440 --> 00:26:42,240
computations of any program

696
00:26:42,240 --> 00:26:43,919
with reasonably

697
00:26:43,919 --> 00:26:47,360
with hopefully reasonable overhead

698
00:26:47,360 --> 00:26:50,159
so that the dependency between

699
00:26:50,159 --> 00:26:53,840
secret and frequency can be decoupled

700
00:26:53,919 --> 00:26:55,520
with that we would like to conclude our

701
00:26:55,520 --> 00:26:58,480
talk and if if you want to know more

702
00:26:58,480 --> 00:27:00,320
please check our website or ask us

703
00:27:00,320 --> 00:27:04,360
questions thank you

