1
00:00:12,000 --> 00:00:14,000
so welcome back we have the pleasure to

2
00:00:14,000 --> 00:00:16,800
have with ali feldman here with us

3
00:00:16,800 --> 00:00:17,840
he's at

4
00:00:17,840 --> 00:00:18,960
apple

5
00:00:18,960 --> 00:00:21,600
and he works on machine learning and

6
00:00:21,600 --> 00:00:24,720
privacy before that he

7
00:00:24,720 --> 00:00:27,439
did his speech the at harper university

8
00:00:27,439 --> 00:00:30,160
until leslie valiant and

9
00:00:30,160 --> 00:00:33,440
then he also has a lot of experience

10
00:00:33,440 --> 00:00:35,440
at google so he was also google research

11
00:00:35,440 --> 00:00:37,920
and ibm research before joining apple

12
00:00:37,920 --> 00:00:39,760
his work has received a lot of best

13
00:00:39,760 --> 00:00:42,480
paper awards and

14
00:00:42,480 --> 00:00:44,960
other awards for example and his work

15
00:00:44,960 --> 00:00:47,840
received an award in 2021

16
00:00:47,840 --> 00:00:49,200
um

17
00:00:49,200 --> 00:00:51,120
in the casper bowel award for

18
00:00:51,120 --> 00:00:52,559
outstanding research in privacy

19
00:00:52,559 --> 00:00:54,640
enhancing technologies

20
00:00:54,640 --> 00:00:57,039
uh and we're so happy to have him here

21
00:00:57,039 --> 00:00:58,879
so please go ahead

22
00:00:58,879 --> 00:01:00,239
thank you auntie gunny thank you to all

23
00:01:00,239 --> 00:01:02,320
the organizers for inviting me and all

24
00:01:02,320 --> 00:01:04,400
uh all of you are coming i just learned

25
00:01:04,400 --> 00:01:06,880
that i'm lucky that i'm here many people

26
00:01:06,880 --> 00:01:10,320
uh could not but uh i guess you are too

27
00:01:10,320 --> 00:01:13,320
um

28
00:01:16,720 --> 00:01:18,640
i'm going to talk about um

29
00:01:18,640 --> 00:01:21,600
low uh communication algorithm for a

30
00:01:21,600 --> 00:01:23,840
private federated learning that have

31
00:01:23,840 --> 00:01:25,520
optimal uh

32
00:01:25,520 --> 00:01:26,880
accuracy guarantees in the sense that

33
00:01:26,880 --> 00:01:28,320
they'll have the optimal trade-off

34
00:01:28,320 --> 00:01:31,439
between the privacy and utility

35
00:01:31,439 --> 00:01:33,680
uh i would like to encourage you all to

36
00:01:33,680 --> 00:01:35,439
ask questions that some of the parts of

37
00:01:35,439 --> 00:01:36,960
the talk will be a little bit technical

38
00:01:36,960 --> 00:01:37,759
so

39
00:01:37,759 --> 00:01:39,680
i'd rather have you stop just raise the

40
00:01:39,680 --> 00:01:41,759
hand and i'll i might need to repeat

41
00:01:41,759 --> 00:01:44,479
your question

42
00:01:44,479 --> 00:01:45,439
so

43
00:01:45,439 --> 00:01:47,759
let's go so uh let's start with the

44
00:01:47,759 --> 00:01:50,399
basic setup and we'll be looking at

45
00:01:50,399 --> 00:01:53,119
federated data analysis in which we have

46
00:01:53,119 --> 00:01:55,680
uh clients or client devices think of

47
00:01:55,680 --> 00:01:58,880
those phones as wearables or browsers

48
00:01:58,880 --> 00:02:00,960
where each of those devices belongs to a

49
00:02:00,960 --> 00:02:03,600
single user and each user is holding a

50
00:02:03,600 --> 00:02:05,360
data point perspective will assume just

51
00:02:05,360 --> 00:02:07,119
a single one and

52
00:02:07,119 --> 00:02:08,878
there will be n of those users and we'll

53
00:02:08,878 --> 00:02:11,038
denote them x1 for xn

54
00:02:11,038 --> 00:02:13,520
and we'll have a server that wants to

55
00:02:13,520 --> 00:02:15,520
communicate with those devices so as to

56
00:02:15,520 --> 00:02:18,000
perform some kind of data analysis

57
00:02:18,000 --> 00:02:19,760
and it should be clear at this point

58
00:02:19,760 --> 00:02:22,319
that we need a lot of data analysis are

59
00:02:22,319 --> 00:02:24,640
necessary to be able to

60
00:02:24,640 --> 00:02:27,760
provide users with various uh use

61
00:02:27,760 --> 00:02:30,720
useful functionalities for example

62
00:02:30,720 --> 00:02:33,519
we may want to perform some kind of

63
00:02:33,519 --> 00:02:36,000
performance analytics to be able to

64
00:02:36,000 --> 00:02:38,640
improve applications uh we may want to

65
00:02:38,640 --> 00:02:39,760
provide users with some some

66
00:02:39,760 --> 00:02:41,200
recommendations

67
00:02:41,200 --> 00:02:43,200
uh we may want to do speech recognition

68
00:02:43,200 --> 00:02:45,040
for digital assistants

69
00:02:45,040 --> 00:02:46,480
or solve problems such as word

70
00:02:46,480 --> 00:02:48,720
prediction which themselves usually

71
00:02:48,720 --> 00:02:50,319
compose into smaller tasks such as

72
00:02:50,319 --> 00:02:52,640
discovering new type words or training

73
00:02:52,640 --> 00:02:54,879
and training and tuning language models

74
00:02:54,879 --> 00:02:57,280
there's a huge number of possible uh

75
00:02:57,280 --> 00:03:00,000
analysis tasks one or applications one

76
00:03:00,000 --> 00:03:01,680
might want to do

77
00:03:01,680 --> 00:03:04,000
but luckily for us many of those can be

78
00:03:04,000 --> 00:03:06,879
reduced to two relatively simple uh kind

79
00:03:06,879 --> 00:03:09,120
of basic problems and those are

80
00:03:09,120 --> 00:03:11,519
the following the first one is frequency

81
00:03:11,519 --> 00:03:14,159
estimation or uh building a histogram

82
00:03:14,159 --> 00:03:16,560
and this problem we think of each users

83
00:03:16,560 --> 00:03:18,319
as holding an element in the domain

84
00:03:18,319 --> 00:03:21,280
which uh from 1 to k and the goal is

85
00:03:21,280 --> 00:03:23,120
just to estimate the frequency of each

86
00:03:23,120 --> 00:03:24,959
of those k different elements and

87
00:03:24,959 --> 00:03:26,799
frequencies just the number of times it

88
00:03:26,799 --> 00:03:27,760
occurs

89
00:03:27,760 --> 00:03:30,080
uh among all the users

90
00:03:30,080 --> 00:03:31,519
and the error in the setting is

91
00:03:31,519 --> 00:03:33,680
typically there are many notions ways to

92
00:03:33,680 --> 00:03:36,480
define uh the error but uh

93
00:03:36,480 --> 00:03:38,080
a common notion error the one will be

94
00:03:38,080 --> 00:03:39,120
just uh

95
00:03:39,120 --> 00:03:41,200
for concreteness focusing in this work

96
00:03:41,200 --> 00:03:44,640
is the uh sum of squared errors uh uh

97
00:03:44,640 --> 00:03:46,879
over all the k elements of our estimate

98
00:03:46,879 --> 00:03:49,599
of the uh frequency

99
00:03:49,599 --> 00:03:51,120
so uh that's

100
00:03:51,120 --> 00:03:52,720
one important building block and one

101
00:03:52,720 --> 00:03:55,439
which is used for example uh in in more

102
00:03:55,439 --> 00:03:57,920
complicated algorithms such as

103
00:03:57,920 --> 00:03:59,920
finding heavy headers and the other

104
00:03:59,920 --> 00:04:02,080
building block for many uh learning

105
00:04:02,080 --> 00:04:05,200
algorithms is l2 high dimensional mean

106
00:04:05,200 --> 00:04:08,400
estimation and in this problem each user

107
00:04:08,400 --> 00:04:09,519
has a

108
00:04:09,519 --> 00:04:11,519
vector a dimensional vector typically

109
00:04:11,519 --> 00:04:13,280
we'll assume that it says some bounded

110
00:04:13,280 --> 00:04:16,798
norm uh for example normal at most one

111
00:04:16,798 --> 00:04:18,639
and our goal is to just estimate the

112
00:04:18,639 --> 00:04:21,759
mean vector among uh of the vectors held

113
00:04:21,759 --> 00:04:23,360
by the users

114
00:04:23,360 --> 00:04:24,400
and

115
00:04:24,400 --> 00:04:26,080
and here at the estimate as before we'll

116
00:04:26,080 --> 00:04:27,360
be looking at the

117
00:04:27,360 --> 00:04:29,680
minimizing the squared error expected

118
00:04:29,680 --> 00:04:32,240
squared error of our estimate

119
00:04:32,240 --> 00:04:33,520
so

120
00:04:33,520 --> 00:04:35,520
this problem i

121
00:04:35,520 --> 00:04:37,280
imagine most of you recognize is sort of

122
00:04:37,280 --> 00:04:39,840
the basis of gradient descent based

123
00:04:39,840 --> 00:04:42,320
algorithms which are of course the bread

124
00:04:42,320 --> 00:04:45,040
and butter of machine learning today

125
00:04:45,040 --> 00:04:46,479
uh so

126
00:04:46,479 --> 00:04:48,240
uh these are simple problems in one

127
00:04:48,240 --> 00:04:49,919
rejected why can't we just uh solve

128
00:04:49,919 --> 00:04:52,240
those and the answer is simple given

129
00:04:52,240 --> 00:04:54,639
this conference is that

130
00:04:54,639 --> 00:04:56,479
a lot of the data held by devices is

131
00:04:56,479 --> 00:04:58,639
sensitive and

132
00:04:58,639 --> 00:05:00,880
users may not be willing to share it or

133
00:05:00,880 --> 00:05:02,479
it might be not possible to collect that

134
00:05:02,479 --> 00:05:05,120
data if we don't provide users with some

135
00:05:05,120 --> 00:05:07,680
sort of privacy guarantees

136
00:05:07,680 --> 00:05:10,560
and of course preserving privacy is a

137
00:05:10,560 --> 00:05:12,960
complicated a system level problem which

138
00:05:12,960 --> 00:05:15,039
has many ingredients but one ingredient

139
00:05:15,039 --> 00:05:16,880
which is uh which became kind of

140
00:05:16,880 --> 00:05:18,720
important in recent years and one which

141
00:05:18,720 --> 00:05:19,840
has been

142
00:05:19,840 --> 00:05:20,960
uh

143
00:05:20,960 --> 00:05:22,960
first proposed in academia

144
00:05:22,960 --> 00:05:25,199
and now adopted in industry is the use

145
00:05:25,199 --> 00:05:27,680
of uh this local uh differentially

146
00:05:27,680 --> 00:05:29,360
private randomizers

147
00:05:29,360 --> 00:05:31,199
which basically says that

148
00:05:31,199 --> 00:05:34,320
uh will take uh the data and before the

149
00:05:34,320 --> 00:05:36,479
data leaves the device it is randomized

150
00:05:36,479 --> 00:05:38,560
in some way so so as to conceal the sort

151
00:05:38,560 --> 00:05:40,400
of signal and limit the amount of

152
00:05:40,400 --> 00:05:41,680
information that is

153
00:05:41,680 --> 00:05:42,800
uh

154
00:05:42,800 --> 00:05:45,039
will be leaked about the user data and

155
00:05:45,039 --> 00:05:47,120
the idea is not new it in fact it has

156
00:05:47,120 --> 00:05:50,080
been the idea already been used in

157
00:05:50,080 --> 00:05:53,199
for conducting sensitive uh user studies

158
00:05:53,199 --> 00:05:55,759
or surveys uh in social sciences by

159
00:05:55,759 --> 00:05:59,120
wagner in 65 it has been uh discovered

160
00:05:59,120 --> 00:06:01,199
by database community in

161
00:06:01,199 --> 00:06:02,639
2003

162
00:06:02,639 --> 00:06:05,120
and then sort of uh kind of

163
00:06:05,120 --> 00:06:06,720
cast into the language of differential

164
00:06:06,720 --> 00:06:08,720
privacy in this paper of uh

165
00:06:08,720 --> 00:06:12,240
passive sonatan at all in 2008

166
00:06:12,240 --> 00:06:13,360
uh and

167
00:06:13,360 --> 00:06:14,960
more formally i imagine many of you know

168
00:06:14,960 --> 00:06:16,319
the definition it basically says the

169
00:06:16,319 --> 00:06:18,400
following

170
00:06:18,400 --> 00:06:20,880
for any pair of two different uh inputs

171
00:06:20,880 --> 00:06:24,080
that a user might might hold uh the the

172
00:06:24,080 --> 00:06:25,919
output distribution produced by the

173
00:06:25,919 --> 00:06:28,720
randomizer that we run uh on this data

174
00:06:28,720 --> 00:06:30,240
uh these output distributions are

175
00:06:30,240 --> 00:06:31,840
similar and what does it mean to be

176
00:06:31,840 --> 00:06:34,800
similar the ratio of densities

177
00:06:34,800 --> 00:06:38,160
is always at most e to the epsilon uh

178
00:06:38,160 --> 00:06:41,199
where for any for every possible output

179
00:06:41,199 --> 00:06:42,240
element

180
00:06:42,240 --> 00:06:44,000
so effectively one way to think about it

181
00:06:44,000 --> 00:06:44,800
is

182
00:06:44,800 --> 00:06:46,560
is whatever you know about whatever

183
00:06:46,560 --> 00:06:48,319
prior information you have about the

184
00:06:48,319 --> 00:06:49,919
user your posterior information will not

185
00:06:49,919 --> 00:06:52,960
be changed by more than this factor of e

186
00:06:52,960 --> 00:06:53,759
to the

187
00:06:53,759 --> 00:06:56,639
epsilon so the epsilon here as you can

188
00:06:56,639 --> 00:06:58,800
imagine is is the

189
00:06:58,800 --> 00:07:00,560
specific amount which measures the data

190
00:07:00,560 --> 00:07:02,000
prime i see the amount of privacy that

191
00:07:02,000 --> 00:07:04,160
is being provided or uh the amount of

192
00:07:04,160 --> 00:07:06,080
information that that is effect could be

193
00:07:06,080 --> 00:07:09,599
uh leaked and it's a natural question of

194
00:07:09,599 --> 00:07:12,160
as to what this epsilon should be

195
00:07:12,160 --> 00:07:14,639
and for the purposes of this talk will

196
00:07:14,639 --> 00:07:17,440
focus on epsilon being a small constant

197
00:07:17,440 --> 00:07:18,880
which is larger than one but not too

198
00:07:18,880 --> 00:07:21,280
large for example five or ten

199
00:07:21,280 --> 00:07:24,240
and the reason for this choice is that

200
00:07:24,240 --> 00:07:26,000
even though we would ideally like

201
00:07:26,000 --> 00:07:29,039
epsilon to be very small uh having this

202
00:07:29,039 --> 00:07:31,599
kind of privacy guarantee does come at a

203
00:07:31,599 --> 00:07:34,479
cost in utility uh there is an effect on

204
00:07:34,479 --> 00:07:37,199
privacy so the more uh on accuracy the

205
00:07:37,199 --> 00:07:38,880
more privacy you provide the less

206
00:07:38,880 --> 00:07:40,319
accuracy you get

207
00:07:40,319 --> 00:07:42,080
and uh in practice it has been

208
00:07:42,080 --> 00:07:43,840
discovered that to get reasonable

209
00:07:43,840 --> 00:07:46,080
utility you need to take values of

210
00:07:46,080 --> 00:07:48,160
epsilon larger than

211
00:07:48,160 --> 00:07:50,400
uh larger than one

212
00:07:50,400 --> 00:07:52,720
and this might

213
00:07:52,720 --> 00:07:54,319
seem like a

214
00:07:54,319 --> 00:07:56,240
not such a great privacy guarantee in

215
00:07:56,240 --> 00:07:58,000
itself but one way to think about it is

216
00:07:58,000 --> 00:08:00,240
is that only part of the picture it's

217
00:08:00,240 --> 00:08:02,080
only one of the privacy protection one

218
00:08:02,080 --> 00:08:03,280
one gets

219
00:08:03,280 --> 00:08:06,000
uh for example if the system in addition

220
00:08:06,000 --> 00:08:09,599
uh includes a component that shuffles

221
00:08:09,599 --> 00:08:14,400
these uh random reports then privacy

222
00:08:14,400 --> 00:08:15,840
before before the data reaches the

223
00:08:15,840 --> 00:08:18,160
server then the privacy guarantees that

224
00:08:18,160 --> 00:08:19,360
the

225
00:08:19,360 --> 00:08:21,280
one will get for the shuffled reports

226
00:08:21,280 --> 00:08:23,039
will be amplified this is so called

227
00:08:23,039 --> 00:08:26,960
privacy amplification by shuffling uh

228
00:08:26,960 --> 00:08:27,759
and

229
00:08:27,759 --> 00:08:30,000
and this amplification will ensure that

230
00:08:30,000 --> 00:08:31,840
even starting from this relatively not

231
00:08:31,840 --> 00:08:34,559
so small epsilon one can get very strong

232
00:08:34,559 --> 00:08:36,240
privacy guarantees

233
00:08:36,240 --> 00:08:38,240
uh at least if one trusts uh the

234
00:08:38,240 --> 00:08:41,519
shuffler uh and so on so but at the very

235
00:08:41,519 --> 00:08:44,159
least this is one again it's

236
00:08:44,159 --> 00:08:45,040
one

237
00:08:45,040 --> 00:08:46,640
uh type of guarantee that one gets it

238
00:08:46,640 --> 00:08:48,959
whatever whatever leaves the

239
00:08:48,959 --> 00:08:50,720
uh user device

240
00:08:50,720 --> 00:08:53,040
uh will not have uh you will not need

241
00:08:53,040 --> 00:08:54,560
more information than what's guaranteed

242
00:08:54,560 --> 00:08:57,040
by this episode

243
00:08:57,040 --> 00:08:58,720
and to give you a bit of an idea and a

244
00:08:58,720 --> 00:09:00,560
bit of an example of how

245
00:09:00,560 --> 00:09:02,160
one can randomize

246
00:09:02,160 --> 00:09:03,680
data specifically in the context of the

247
00:09:03,680 --> 00:09:05,519
two problems that i've mentioned

248
00:09:05,519 --> 00:09:07,279
uh let me give you two examples of

249
00:09:07,279 --> 00:09:08,560
randomizers

250
00:09:08,560 --> 00:09:10,080
the first one is for frequency

251
00:09:10,080 --> 00:09:13,120
estimation at first it was um

252
00:09:13,120 --> 00:09:14,959
proposed in the context of this rapport

253
00:09:14,959 --> 00:09:17,120
system by arlington atoll which was

254
00:09:17,120 --> 00:09:20,240
deployed by google in 14

255
00:09:20,240 --> 00:09:21,760
and it's the following very simple

256
00:09:21,760 --> 00:09:24,320
randomizer it starts with a okay you're

257
00:09:24,320 --> 00:09:26,640
given an index which is an element

258
00:09:26,640 --> 00:09:29,360
uh from one to k first is the first step

259
00:09:29,360 --> 00:09:31,360
it's converted to one hot encoding which

260
00:09:31,360 --> 00:09:35,040
is just uh uh an indicator vector

261
00:09:35,040 --> 00:09:37,279
of that index which is zero everywhere

262
00:09:37,279 --> 00:09:38,959
except it's one in the position in the

263
00:09:38,959 --> 00:09:41,920
index which is the value of the element

264
00:09:41,920 --> 00:09:43,440
and then uh

265
00:09:43,440 --> 00:09:46,160
the one in that uh encoding is replaced

266
00:09:46,160 --> 00:09:47,440
with the random coin flip with

267
00:09:47,440 --> 00:09:50,320
probability one-half and every zero is

268
00:09:50,320 --> 00:09:52,320
replaced with a random point flip with

269
00:09:52,320 --> 00:09:54,320
the bias one over e to the epsilon plus

270
00:09:54,320 --> 00:09:56,800
one and this replacement is happens

271
00:09:56,800 --> 00:09:58,800
randomly and independently

272
00:09:58,800 --> 00:10:00,560
so simple algorithm is very easy to see

273
00:10:00,560 --> 00:10:02,480
that it satisfies this

274
00:10:02,480 --> 00:10:04,160
epsilon uh different uh local

275
00:10:04,160 --> 00:10:05,360
differential privacy that's one

276
00:10:05,360 --> 00:10:06,399
algorithm

277
00:10:06,399 --> 00:10:07,120
and

278
00:10:07,120 --> 00:10:08,320
here's another

279
00:10:08,320 --> 00:10:10,240
simple example uh for the problem of

280
00:10:10,240 --> 00:10:12,640
mean estimation one way to randomize or

281
00:10:12,640 --> 00:10:15,200
maybe one of the most well-known ones

282
00:10:15,200 --> 00:10:16,320
is to

283
00:10:16,320 --> 00:10:19,279
take your input uh

284
00:10:19,279 --> 00:10:20,640
first you usually need to clip or

285
00:10:20,640 --> 00:10:22,800
project it back to to norm a certain

286
00:10:22,800 --> 00:10:25,839
norm for example norm one to ensure that

287
00:10:25,839 --> 00:10:28,640
it's the input is uh not unbounded and

288
00:10:28,640 --> 00:10:30,640
after that one can just add

289
00:10:30,640 --> 00:10:32,880
uh noise such as the gaussian noise

290
00:10:32,880 --> 00:10:35,200
would be the most commonly used

291
00:10:35,200 --> 00:10:37,760
and for appropriately chosen parameter

292
00:10:37,760 --> 00:10:40,160
sigma it will give privacy guarantees

293
00:10:40,160 --> 00:10:41,440
although it

294
00:10:41,440 --> 00:10:43,120
without modification it only gives

295
00:10:43,120 --> 00:10:45,360
approximate uh differential privacy but

296
00:10:45,360 --> 00:10:47,040
could be modified to give

297
00:10:47,040 --> 00:10:48,880
this pure epsilon differential privacy

298
00:10:48,880 --> 00:10:51,040
in this case

299
00:10:51,040 --> 00:10:54,079
uh so these are two uh simple examples

300
00:10:54,079 --> 00:10:57,279
uh and uh now uh i can tell you a little

301
00:10:57,279 --> 00:10:59,200
bit more about the problem that we're

302
00:10:59,200 --> 00:11:01,200
trying to address in this work

303
00:11:01,200 --> 00:11:03,600
and basically oops

304
00:11:03,600 --> 00:11:05,360
and basically the problem is that the

305
00:11:05,360 --> 00:11:07,200
following state of the art uh or at

306
00:11:07,200 --> 00:11:09,920
least prior to to our work or my work

307
00:11:09,920 --> 00:11:11,360
with several colleagues

308
00:11:11,360 --> 00:11:13,600
uh the state of the art in this area was

309
00:11:13,600 --> 00:11:14,640
the following

310
00:11:14,640 --> 00:11:17,040
one forever for both of these uh basic

311
00:11:17,040 --> 00:11:18,720
problems one would have to do one of

312
00:11:18,720 --> 00:11:21,680
these two compromises the first

313
00:11:21,680 --> 00:11:24,399
would be to use an algorithm which uses

314
00:11:24,399 --> 00:11:26,240
which has communication cost which

315
00:11:26,240 --> 00:11:28,560
scales linearly with the dimension

316
00:11:28,560 --> 00:11:30,959
in the mean estimation problem

317
00:11:30,959 --> 00:11:32,720
or domain size in the frequency

318
00:11:32,720 --> 00:11:34,880
estimation problem or

319
00:11:34,880 --> 00:11:37,040
uh if you wanted to go low communication

320
00:11:37,040 --> 00:11:38,480
wanted to use a low communication

321
00:11:38,480 --> 00:11:41,440
algorithm what one would have a sub

322
00:11:41,440 --> 00:11:44,000
privacy accuracy trade-off

323
00:11:44,000 --> 00:11:46,160
and here sub-optimality

324
00:11:46,160 --> 00:11:48,079
does not mean asymptotic is actually

325
00:11:48,079 --> 00:11:50,639
sub-optimal by a constant factor

326
00:11:50,639 --> 00:11:52,720
typically larger than two which might

327
00:11:52,720 --> 00:11:54,560
not seem like much but in practice it's

328
00:11:54,560 --> 00:11:56,639
in a significant sub-optimality which

329
00:11:56,639 --> 00:11:58,560
affects many downstream

330
00:11:58,560 --> 00:11:59,519
tasks

331
00:11:59,519 --> 00:12:01,440
so definitely something we want to

332
00:12:01,440 --> 00:12:03,760
eliminate

333
00:12:03,760 --> 00:12:05,279
so um

334
00:12:05,279 --> 00:12:06,880
and maybe i should know that this

335
00:12:06,880 --> 00:12:08,880
sub-optimality is

336
00:12:08,880 --> 00:12:11,200
particularly problematic for frequency

337
00:12:11,200 --> 00:12:12,399
estimation because in the frequency

338
00:12:12,399 --> 00:12:13,519
estimation

339
00:12:13,519 --> 00:12:15,360
uh the communication scale linearly with

340
00:12:15,360 --> 00:12:16,959
the entire domain size and the domain

341
00:12:16,959 --> 00:12:19,120
size we do want to make this domain size

342
00:12:19,120 --> 00:12:20,560
to be large

343
00:12:20,560 --> 00:12:23,360
uh and moreover the signal sort of the

344
00:12:23,360 --> 00:12:26,240
index itself only contains log k bits of

345
00:12:26,240 --> 00:12:28,959
information but in order to randomize it

346
00:12:28,959 --> 00:12:30,320
with optimal

347
00:12:30,320 --> 00:12:31,200
uh

348
00:12:31,200 --> 00:12:32,480
privacy utility

349
00:12:32,480 --> 00:12:35,120
tradeoff we had to use algorithms which

350
00:12:35,120 --> 00:12:37,680
sent k bits or something which scales

351
00:12:37,680 --> 00:12:39,120
linearly with k

352
00:12:39,120 --> 00:12:41,120
bits

353
00:12:41,120 --> 00:12:43,360
uh so now this that's the problem and

354
00:12:43,360 --> 00:12:44,560
let me uh

355
00:12:44,560 --> 00:12:46,480
overview the the kind of results that we

356
00:12:46,480 --> 00:12:48,320
have for this um

357
00:12:48,320 --> 00:12:50,320
uh for this problem

358
00:12:50,320 --> 00:12:53,440
so uh the first one is um is in a joint

359
00:12:53,440 --> 00:12:55,519
work with kunal talbar

360
00:12:55,519 --> 00:12:57,200
and the way we describe it

361
00:12:57,200 --> 00:12:58,959
is a general lossless compression of

362
00:12:58,959 --> 00:13:00,639
efficient local differentially private

363
00:13:00,639 --> 00:13:03,120
randomizers but what effectively does it

364
00:13:03,120 --> 00:13:05,200
takes an arbitrarily arbitrary

365
00:13:05,200 --> 00:13:06,880
computationally efficient local

366
00:13:06,880 --> 00:13:09,600
randomizer and replaces and gives a

367
00:13:09,600 --> 00:13:12,320
version of it which is uh has

368
00:13:12,320 --> 00:13:14,560
essentially the same privacy guarantees

369
00:13:14,560 --> 00:13:17,920
essentially uh the same

370
00:13:17,920 --> 00:13:20,000
utility guarantees

371
00:13:20,000 --> 00:13:21,760
but on top of it has very low

372
00:13:21,760 --> 00:13:23,680
communication so it basically uh

373
00:13:23,680 --> 00:13:25,600
replaces your randomizer with a low

374
00:13:25,600 --> 00:13:27,920
communication one and a high level says

375
00:13:27,920 --> 00:13:28,880
that

376
00:13:28,880 --> 00:13:32,160
these communication is not uh at odds

377
00:13:32,160 --> 00:13:33,920
with optimal trade law whenever whatever

378
00:13:33,920 --> 00:13:35,200
trade off you can achieve with high

379
00:13:35,200 --> 00:13:37,600
communication you can also achieve it

380
00:13:37,600 --> 00:13:39,839
with uh low communication

381
00:13:39,839 --> 00:13:42,720
so for this general result uh i'll

382
00:13:42,720 --> 00:13:44,399
describe the general result i also give

383
00:13:44,399 --> 00:13:46,720
some specific application of this result

384
00:13:46,720 --> 00:13:49,360
sort of simpler forms of it which apply

385
00:13:49,360 --> 00:13:51,440
to specifically the problems of

386
00:13:51,440 --> 00:13:53,519
frequency and mean estimation

387
00:13:53,519 --> 00:13:56,320
uh that i've mentioned

388
00:13:56,320 --> 00:13:58,560
so one uh disadvantage of this kind of

389
00:13:58,560 --> 00:14:00,320
direct application is that the algorithm

390
00:14:00,320 --> 00:14:01,199
that we

391
00:14:01,199 --> 00:14:03,600
get it has low communication but it has

392
00:14:03,600 --> 00:14:04,399
not

393
00:14:04,399 --> 00:14:06,639
such great server computing time and we

394
00:14:06,639 --> 00:14:07,519
have a

395
00:14:07,519 --> 00:14:09,279
an algorithm which

396
00:14:09,279 --> 00:14:12,399
uses somewhat related ideas um

397
00:14:12,399 --> 00:14:14,399
uh and it's first enjoyed work with uh

398
00:14:14,399 --> 00:14:17,920
nelson when gwen and also talvar where

399
00:14:17,920 --> 00:14:18,720
we

400
00:14:18,720 --> 00:14:20,240
show that uh

401
00:14:20,240 --> 00:14:22,959
one can also achieve a much better uh

402
00:14:22,959 --> 00:14:25,839
server compute time uh for this for the

403
00:14:25,839 --> 00:14:29,360
problem of uh frequency estimation

404
00:14:29,360 --> 00:14:31,440
uh the situation for the mean estimation

405
00:14:31,440 --> 00:14:33,519
was even less clear there it wasn't even

406
00:14:33,519 --> 00:14:36,079
known what is the optimal or uh

407
00:14:36,079 --> 00:14:38,399
trade-off between uh privacy utility

408
00:14:38,399 --> 00:14:40,720
tradeoff for every epsilon

409
00:14:40,720 --> 00:14:43,199
and in a recent work with hillary and

410
00:14:43,199 --> 00:14:45,360
kunal talvar we

411
00:14:45,360 --> 00:14:47,839
show we we demonstrate that one existing

412
00:14:47,839 --> 00:14:50,399
algorithm uh that has been known for an

413
00:14:50,399 --> 00:14:51,600
appropriate choice the parameter

414
00:14:51,600 --> 00:14:53,839
achieves is the optimal algorithm to

415
00:14:53,839 --> 00:14:56,079
show that this is uh basically we

416
00:14:56,079 --> 00:14:57,360
discovered that

417
00:14:57,360 --> 00:14:59,199
the optimal trade-off

418
00:14:59,199 --> 00:15:00,399
and um

419
00:15:00,399 --> 00:15:02,000
we also give a new algorithm which is

420
00:15:02,000 --> 00:15:03,600
somewhat simpler

421
00:15:03,600 --> 00:15:07,279
than uh the one that was known before

422
00:15:07,279 --> 00:15:10,000
but it is still optimal

423
00:15:10,000 --> 00:15:13,120
uh and finally uh as i mentioned uh

424
00:15:13,120 --> 00:15:15,040
this local privacy guarantees are only

425
00:15:15,040 --> 00:15:17,199
maybe a piece of the whole system

426
00:15:17,199 --> 00:15:19,199
uh i also show that the ideas that we

427
00:15:19,199 --> 00:15:20,480
are using

428
00:15:20,480 --> 00:15:22,160
for this maybe simpler setup of

429
00:15:22,160 --> 00:15:24,720
optimizing just local randomizer can be

430
00:15:24,720 --> 00:15:27,839
used when optimizing uh local randomizer

431
00:15:27,839 --> 00:15:31,440
in a sort of a more complicated uh setup

432
00:15:31,440 --> 00:15:32,959
which

433
00:15:32,959 --> 00:15:35,519
involves secret sharing where we want

434
00:15:35,519 --> 00:15:37,199
well we want to

435
00:15:37,199 --> 00:15:38,720
make sure that the server doesn't

436
00:15:38,720 --> 00:15:41,519
observe the entire all the individual

437
00:15:41,519 --> 00:15:43,440
reports they go through some kind of

438
00:15:43,440 --> 00:15:45,680
secret shared aggregation and we want to

439
00:15:45,680 --> 00:15:48,079
make sure that uh

440
00:15:48,079 --> 00:15:49,920
the low communication protocols that we

441
00:15:49,920 --> 00:15:54,399
design support uh the this

442
00:15:54,399 --> 00:15:56,320
uh secret sharing

443
00:15:56,320 --> 00:15:59,120
so that's uh a high-level overview

444
00:15:59,120 --> 00:16:02,160
uh i'll uh yeah start one by one uh

445
00:16:02,160 --> 00:16:03,519
telling you a little bit more about

446
00:16:03,519 --> 00:16:05,360
those results let me know if you have

447
00:16:05,360 --> 00:16:08,320
any questions so far

448
00:16:08,320 --> 00:16:10,160
great either people are asleep after

449
00:16:10,160 --> 00:16:11,440
lunch or

450
00:16:11,440 --> 00:16:14,320
uh everything is very clear

451
00:16:14,320 --> 00:16:17,279
question yes

452
00:16:17,519 --> 00:16:21,880
yes you just you can just shout it out

453
00:16:26,560 --> 00:16:29,560
uh

454
00:16:42,240 --> 00:16:44,720
uh well that's sort of the

455
00:16:44,720 --> 00:16:46,079
uh

456
00:16:46,079 --> 00:16:48,320
like maybe the one root

457
00:16:48,320 --> 00:16:50,399
issue is that it's harder to design

458
00:16:50,399 --> 00:16:52,959
algorithms that have low communication

459
00:16:52,959 --> 00:16:56,320
and in addition are optimal it's just

460
00:16:56,320 --> 00:16:58,480
uh i think at least in one case we have

461
00:16:58,480 --> 00:17:00,240
discovered an algorithm which could have

462
00:17:00,240 --> 00:17:02,240
been discovered before our general

463
00:17:02,240 --> 00:17:03,680
conversion

464
00:17:03,680 --> 00:17:05,359
or this general

465
00:17:05,359 --> 00:17:06,720
insight but

466
00:17:06,720 --> 00:17:09,839
for whatever reason it hasn't been

467
00:17:09,839 --> 00:17:11,280
where even though people certainly have

468
00:17:11,280 --> 00:17:14,559
tried and i'll discuss in a second

469
00:17:14,559 --> 00:17:16,319
prior work in more detail and our

470
00:17:16,319 --> 00:17:17,359
results

471
00:17:17,359 --> 00:17:19,119
uh in more detail

472
00:17:19,119 --> 00:17:21,359
i don't think there is um

473
00:17:21,359 --> 00:17:23,760
people have realized that uh local

474
00:17:23,760 --> 00:17:25,520
differential privacy

475
00:17:25,520 --> 00:17:27,520
should imply that there because because

476
00:17:27,520 --> 00:17:29,280
effectively very little information is

477
00:17:29,280 --> 00:17:30,400
being leaked

478
00:17:30,400 --> 00:17:32,240
so it shouldn't take too much

479
00:17:32,240 --> 00:17:34,880
communication to to communicate

480
00:17:34,880 --> 00:17:38,640
uh that but and people have had ways to

481
00:17:38,640 --> 00:17:40,240
exploit this

482
00:17:40,240 --> 00:17:42,799
but they either lost in the conversion

483
00:17:42,799 --> 00:17:45,840
they they doubled or sometimes quadruple

484
00:17:45,840 --> 00:17:48,960
the epsilon which kind of ruins things

485
00:17:48,960 --> 00:17:50,480
and there are other issues i mean so

486
00:17:50,480 --> 00:17:52,240
maybe a longer story why

487
00:17:52,240 --> 00:17:54,480
hasn't been it's a good question

488
00:17:54,480 --> 00:17:57,919
i think there is no

489
00:17:57,919 --> 00:17:59,440
nothing fundamentally just

490
00:17:59,440 --> 00:18:01,440
somehow that was the state of the

491
00:18:01,440 --> 00:18:03,360
um area

492
00:18:03,360 --> 00:18:04,880
before we um

493
00:18:04,880 --> 00:18:07,440
started looking at it

494
00:18:07,440 --> 00:18:09,280
anyway so the first result is the

495
00:18:09,280 --> 00:18:11,280
general lossless compression

496
00:18:11,280 --> 00:18:13,280
and let me start by actually describing

497
00:18:13,280 --> 00:18:16,000
you pretty much in full what this uh

498
00:18:16,000 --> 00:18:17,520
result states

499
00:18:17,520 --> 00:18:20,559
so uh we'll start we what we

500
00:18:20,559 --> 00:18:22,799
say is for every epsilon differentially

501
00:18:22,799 --> 00:18:24,799
private computationally efficient local

502
00:18:24,799 --> 00:18:27,679
randomizer uh which maps from x to some

503
00:18:27,679 --> 00:18:29,360
output y

504
00:18:29,360 --> 00:18:31,200
there exists a different epsilon

505
00:18:31,200 --> 00:18:32,960
differential local randomizer which are

506
00:18:32,960 --> 00:18:34,559
prime which will be mapping from x to

507
00:18:34,559 --> 00:18:37,679
some z we should think of this z

508
00:18:37,679 --> 00:18:40,160
as being seeds to some pseudorandom

509
00:18:40,160 --> 00:18:42,160
generator we'll

510
00:18:42,160 --> 00:18:42,960
see

511
00:18:42,960 --> 00:18:45,520
more about it in a second and we'll also

512
00:18:45,520 --> 00:18:47,280
have a certain decode procedure which

513
00:18:47,280 --> 00:18:49,600
maps from z back to y the original

514
00:18:49,600 --> 00:18:51,360
output domain with the following

515
00:18:51,360 --> 00:18:52,880
property

516
00:18:52,880 --> 00:18:54,880
uh so first of all let's note that this

517
00:18:54,880 --> 00:18:56,720
is our prime is still an epsilon

518
00:18:56,720 --> 00:18:58,480
differentially local randomizer so

519
00:18:58,480 --> 00:19:00,480
privacy is preserved

520
00:19:00,480 --> 00:19:02,559
and the property and the other utilities

521
00:19:02,559 --> 00:19:03,919
preserved in the following sense is that

522
00:19:03,919 --> 00:19:06,720
the decoding of the output

523
00:19:06,720 --> 00:19:08,480
of this r prime of x

524
00:19:08,480 --> 00:19:10,320
is computational indistinguishable from

525
00:19:10,320 --> 00:19:12,559
the original randomizer so utility will

526
00:19:12,559 --> 00:19:14,559
be preserved provided that you're doing

527
00:19:14,559 --> 00:19:16,640
computational computationally efficient

528
00:19:16,640 --> 00:19:21,039
post processing on that output

529
00:19:21,200 --> 00:19:24,720
so maybe uh first i should note that

530
00:19:24,720 --> 00:19:26,960
computational efficiency here

531
00:19:26,960 --> 00:19:29,120
is not just computing the

532
00:19:29,120 --> 00:19:31,200
actually sampling from the randomizer it

533
00:19:31,200 --> 00:19:32,559
also involves

534
00:19:32,559 --> 00:19:34,559
uh being able to efficiently estimate

535
00:19:34,559 --> 00:19:36,840
the densities uh

536
00:19:36,840 --> 00:19:38,160
given uh

537
00:19:38,160 --> 00:19:40,640
by this randomizer which is true for the

538
00:19:40,640 --> 00:19:42,320
kind of randomizers we know

539
00:19:42,320 --> 00:19:43,919
but in general it's a somewhat different

540
00:19:43,919 --> 00:19:45,919
requirement uh density estimation and

541
00:19:45,919 --> 00:19:47,840
sampling are different

542
00:19:47,840 --> 00:19:50,000
computational procedures

543
00:19:50,000 --> 00:19:53,440
uh so that's uh that's the result

544
00:19:53,440 --> 00:19:56,640
uh let me uh tell you uh okay so maybe

545
00:19:56,640 --> 00:19:58,960
okay what i didn't say is i said that we

546
00:19:58,960 --> 00:20:02,159
have compressed from uh this y to the

547
00:20:02,159 --> 00:20:05,200
space of seeds and the question is how

548
00:20:05,200 --> 00:20:06,640
long are those seats how much

549
00:20:06,640 --> 00:20:08,720
communication we're actually saving

550
00:20:08,720 --> 00:20:11,120
and so in theory

551
00:20:11,120 --> 00:20:13,039
in this general result

552
00:20:13,039 --> 00:20:16,039
yes

553
00:20:22,400 --> 00:20:25,360
uh yeah x is the space of the user data

554
00:20:25,360 --> 00:20:28,159
y is the space into which you randomize

555
00:20:28,159 --> 00:20:29,120
things

556
00:20:29,120 --> 00:20:31,120
and and then send that report so this is

557
00:20:31,120 --> 00:20:32,640
typically a law or something large for

558
00:20:32,640 --> 00:20:35,760
example again imagine this uh binary uh

559
00:20:35,760 --> 00:20:37,360
this one hot encoding which was

560
00:20:37,360 --> 00:20:39,200
randomized a long space

561
00:20:39,200 --> 00:20:40,400
z

562
00:20:40,400 --> 00:20:42,559
is the kind of this compressed version

563
00:20:42,559 --> 00:20:43,280
or

564
00:20:43,280 --> 00:20:44,960
of the

565
00:20:44,960 --> 00:20:46,080
uh

566
00:20:46,080 --> 00:20:48,799
of this of y and we need to decode from

567
00:20:48,799 --> 00:20:50,480
this compression compressed version back

568
00:20:50,480 --> 00:20:53,120
to the uh original the same domain as as

569
00:20:53,120 --> 00:20:53,919
uh

570
00:20:53,919 --> 00:20:56,880
y was originally so uh

571
00:20:56,880 --> 00:20:59,120
and now i'm discussing the size of this

572
00:20:59,120 --> 00:20:59,840
z

573
00:20:59,840 --> 00:21:02,240
in theory basically it depends the size

574
00:21:02,240 --> 00:21:03,760
it depends on the strength of the

575
00:21:03,760 --> 00:21:05,280
cryptographic assumptions but if you

576
00:21:05,280 --> 00:21:08,799
assume that you have prgs that are

577
00:21:08,799 --> 00:21:10,559
that can fool exponentially large

578
00:21:10,559 --> 00:21:14,159
circuits then the you can always send a

579
00:21:14,159 --> 00:21:15,440
seed

580
00:21:15,440 --> 00:21:17,200
whose length is logarithmic in the

581
00:21:17,200 --> 00:21:19,840
problem size so it's short in practice

582
00:21:19,840 --> 00:21:21,840
it's all you can always send your system

583
00:21:21,840 --> 00:21:25,440
prg of 256 bits and that will be enough

584
00:21:25,440 --> 00:21:27,200
uh and maybe

585
00:21:27,200 --> 00:21:29,520
more importantly is that this is a very

586
00:21:29,520 --> 00:21:31,440
general result but for specific

587
00:21:31,440 --> 00:21:33,200
randomizers we can

588
00:21:33,200 --> 00:21:36,080
uh use simpler unconditional prgs which

589
00:21:36,080 --> 00:21:38,080
are uh tailored to the specific

590
00:21:38,080 --> 00:21:39,520
randomizer we don't have to use a

591
00:21:39,520 --> 00:21:41,280
general prg

592
00:21:41,280 --> 00:21:42,159
uh

593
00:21:42,159 --> 00:21:43,840
general cryptographic prg for specific

594
00:21:43,840 --> 00:21:45,360
problems and that's one of the things

595
00:21:45,360 --> 00:21:47,200
we'll we'll do

596
00:21:47,200 --> 00:21:49,679
for our applications

597
00:21:49,679 --> 00:21:51,440
so uh that's the statement of the result

598
00:21:51,440 --> 00:21:53,200
let me give you a little bit of

599
00:21:53,200 --> 00:21:54,480
intuition

600
00:21:54,480 --> 00:21:55,679
overall

601
00:21:55,679 --> 00:21:57,600
this is not a technical talk but i want

602
00:21:57,600 --> 00:21:59,679
to give you a bit of a sense of

603
00:21:59,679 --> 00:22:01,840
why prg's why

604
00:22:01,840 --> 00:22:03,760
why sort of maybe the part which should

605
00:22:03,760 --> 00:22:04,559
be

606
00:22:04,559 --> 00:22:07,440
looks somewhat mysterious to you is that

607
00:22:07,440 --> 00:22:09,280
differential privacy is information

608
00:22:09,280 --> 00:22:11,200
theoretic guarantee it's completely

609
00:22:11,200 --> 00:22:12,720
non-computational

610
00:22:12,720 --> 00:22:15,039
and we are using some kind of

611
00:22:15,039 --> 00:22:17,360
cryptographic assumption to still

612
00:22:17,360 --> 00:22:19,440
get uh preserve this information

613
00:22:19,440 --> 00:22:21,200
theoretical guarantee we are not

614
00:22:21,200 --> 00:22:22,640
um there are there are versions of

615
00:22:22,640 --> 00:22:23,679
differential privacy which are more

616
00:22:23,679 --> 00:22:25,360
computational but we're still

617
00:22:25,360 --> 00:22:27,440
uh using our

618
00:22:27,440 --> 00:22:29,200
uh

619
00:22:29,200 --> 00:22:31,919
computational assumption to preserve

620
00:22:31,919 --> 00:22:33,919
information theoretical guarantees that

621
00:22:33,919 --> 00:22:35,919
at least some of you should be somewhat

622
00:22:35,919 --> 00:22:38,240
puzzling

623
00:22:38,240 --> 00:22:39,600
so let me give you a bit of intuition

624
00:22:39,600 --> 00:22:41,039
about this result

625
00:22:41,039 --> 00:22:44,159
so here is and i'll do this by

626
00:22:44,159 --> 00:22:46,559
completely describing this uh algorithm

627
00:22:46,559 --> 00:22:48,480
that we're using for

628
00:22:48,480 --> 00:22:49,520
uh

629
00:22:49,520 --> 00:22:51,520
for low communication

630
00:22:51,520 --> 00:22:53,280
uh

631
00:22:53,280 --> 00:22:55,360
version of the same uh this sort of

632
00:22:55,360 --> 00:22:57,760
losslessly compressed version of the

633
00:22:57,760 --> 00:23:00,799
uh original randomizer so okay we are

634
00:23:00,799 --> 00:23:02,400
starting again with this

635
00:23:02,400 --> 00:23:04,720
randomizer r mapping from x to y and

636
00:23:04,720 --> 00:23:06,240
this is we assume that it's efficient

637
00:23:06,240 --> 00:23:08,960
epsilon difference very private

638
00:23:08,960 --> 00:23:11,760
so we will need to fix some sort of uh

639
00:23:11,760 --> 00:23:15,280
reference distribution and for this uh

640
00:23:15,280 --> 00:23:17,360
we will uh pick one of the elements in

641
00:23:17,360 --> 00:23:20,240
the the main arbitrary one say zero

642
00:23:20,240 --> 00:23:22,720
and we'll denote it by x0

643
00:23:22,720 --> 00:23:24,080
and the reference distribution that we

644
00:23:24,080 --> 00:23:26,640
need to fix will be the output

645
00:23:26,640 --> 00:23:28,400
distribution of our randomizer on that

646
00:23:28,400 --> 00:23:30,080
fixed element so there'll just some

647
00:23:30,080 --> 00:23:31,919
fixed distribution we'll denote it by r

648
00:23:31,919 --> 00:23:33,280
of x0

649
00:23:33,280 --> 00:23:34,880
and what is a

650
00:23:34,880 --> 00:23:36,640
and this is the distribution from which

651
00:23:36,640 --> 00:23:38,080
we can sample from this fixed

652
00:23:38,080 --> 00:23:40,159
distribution because we can just apply r

653
00:23:40,159 --> 00:23:40,960
to

654
00:23:40,960 --> 00:23:44,000
uh this element our uh x0 so because we

655
00:23:44,000 --> 00:23:45,919
can sample this uh from this

656
00:23:45,919 --> 00:23:48,080
distribution we can think of

657
00:23:48,080 --> 00:23:50,480
of some algorithm which we will just

658
00:23:50,480 --> 00:23:53,760
denote as uh this algorithm as r0

659
00:23:53,760 --> 00:23:55,760
which sample from the distribution what

660
00:23:55,760 --> 00:23:57,279
is a sampling algorithm is an algorithm

661
00:23:57,279 --> 00:24:00,240
which takes a random uh

662
00:24:00,240 --> 00:24:01,840
binary string random uniform binary

663
00:24:01,840 --> 00:24:03,840
string and outputs an element in the

664
00:24:03,840 --> 00:24:05,360
domain of the distribution right so it's

665
00:24:05,360 --> 00:24:07,279
just a deterministic algorithm which

666
00:24:07,279 --> 00:24:09,679
takes a

667
00:24:09,840 --> 00:24:12,480
boolean string of length t

668
00:24:12,480 --> 00:24:14,480
and if you feed it and outputs an

669
00:24:14,480 --> 00:24:15,760
element and if you feed it random

670
00:24:15,760 --> 00:24:18,480
uniform bits it will output an element

671
00:24:18,480 --> 00:24:20,240
from the output distribution

672
00:24:20,240 --> 00:24:21,279
uh

673
00:24:21,279 --> 00:24:23,520
r of x0 from this reference distribution

674
00:24:23,520 --> 00:24:24,400
okay

675
00:24:24,400 --> 00:24:25,360
now

676
00:24:25,360 --> 00:24:28,159
we have a way to convert bits to output

677
00:24:28,159 --> 00:24:30,000
elements for reference distribution

678
00:24:30,000 --> 00:24:32,880
we'll also need a prg which is something

679
00:24:32,880 --> 00:24:34,799
that so this reference distribution

680
00:24:34,799 --> 00:24:36,080
sampling reference distribution may

681
00:24:36,080 --> 00:24:38,000
require lots of bits

682
00:24:38,000 --> 00:24:40,640
uh we'll also use some kind of prgg

683
00:24:40,640 --> 00:24:42,320
which will take a small number of bits

684
00:24:42,320 --> 00:24:44,480
and create a l

685
00:24:44,480 --> 00:24:46,480
and we'll create a large number of

686
00:24:46,480 --> 00:24:49,440
random bits well pseudo-random bits

687
00:24:49,440 --> 00:24:51,039
so these are the three these are the

688
00:24:51,039 --> 00:24:52,880
ingredients we'll need for the algorithm

689
00:24:52,880 --> 00:24:55,039
i can now describe the algorithm

690
00:24:55,039 --> 00:24:56,640
and it looks the following

691
00:24:56,640 --> 00:24:57,600
in

692
00:24:57,600 --> 00:24:59,600
informally it's basically rejection

693
00:24:59,600 --> 00:25:00,799
sampling so we have this reference

694
00:25:00,799 --> 00:25:02,000
distribution

695
00:25:02,000 --> 00:25:04,000
and differential privacy guarantees that

696
00:25:04,000 --> 00:25:05,679
this reference distribution is not too

697
00:25:05,679 --> 00:25:07,200
far from the

698
00:25:07,200 --> 00:25:08,640
uh any

699
00:25:08,640 --> 00:25:10,640
distribution that we may want to output

700
00:25:10,640 --> 00:25:12,400
when we're given an input element some

701
00:25:12,400 --> 00:25:14,480
input element

702
00:25:14,480 --> 00:25:16,559
so because it's close we can do

703
00:25:16,559 --> 00:25:18,240
rejection something then sample from one

704
00:25:18,240 --> 00:25:20,880
distribution and reject if

705
00:25:20,880 --> 00:25:22,720
they then

706
00:25:22,720 --> 00:25:26,080
if the ratio of densities

707
00:25:26,480 --> 00:25:29,200
whatever by flipping some

708
00:25:29,200 --> 00:25:30,320
um

709
00:25:30,320 --> 00:25:32,320
random variable which is equal to the

710
00:25:32,320 --> 00:25:34,880
roughly the uh ratio of densities we can

711
00:25:34,880 --> 00:25:36,720
do rejection sampling

712
00:25:36,720 --> 00:25:38,960
by using this reference distribution

713
00:25:38,960 --> 00:25:40,559
and the only tweak to

714
00:25:40,559 --> 00:25:43,039
uh that will do to this algorithm is

715
00:25:43,039 --> 00:25:45,679
that uh instead of using this

716
00:25:45,679 --> 00:25:47,279
simple uh

717
00:25:47,279 --> 00:25:49,440
rejection sampling will uh to sample

718
00:25:49,440 --> 00:25:50,799
from the reference distribution we won't

719
00:25:50,799 --> 00:25:53,120
be using the true random bits we'll be

720
00:25:53,120 --> 00:25:55,039
using the pseudorandom bits to sample

721
00:25:55,039 --> 00:25:56,720
from the reference distribution so here

722
00:25:56,720 --> 00:25:58,080
is the description

723
00:25:58,080 --> 00:25:59,200
we have some

724
00:25:59,200 --> 00:26:01,200
parameterized by the pseudorandom

725
00:26:01,200 --> 00:26:02,480
generator g

726
00:26:02,480 --> 00:26:04,880
and failure parameter gamma

727
00:26:04,880 --> 00:26:06,960
we'll have some input element x and this

728
00:26:06,960 --> 00:26:09,039
this is the failure parameter we'll need

729
00:26:09,039 --> 00:26:11,200
to in order to ensure that the failure

730
00:26:11,200 --> 00:26:12,240
probability is small we'll need to

731
00:26:12,240 --> 00:26:13,840
repeat this rejection something many

732
00:26:13,840 --> 00:26:17,279
times specifically that number of times

733
00:26:17,279 --> 00:26:19,679
point for you here's the number of times

734
00:26:19,679 --> 00:26:21,919
and here we just repeat it what we'll do

735
00:26:21,919 --> 00:26:24,880
we'll sample a random seed short seed

736
00:26:24,880 --> 00:26:26,240
will

737
00:26:26,240 --> 00:26:29,039
turn it into a long random sequence

738
00:26:29,039 --> 00:26:30,240
apply

739
00:26:30,240 --> 00:26:32,720
our reference distribution element

740
00:26:32,720 --> 00:26:33,919
creator

741
00:26:33,919 --> 00:26:35,919
generator and then we'll just do

742
00:26:35,919 --> 00:26:37,360
rejection sampling where ejection

743
00:26:37,360 --> 00:26:41,279
sampling is just uh rejects if the ratio

744
00:26:41,279 --> 00:26:43,440
no it doesn't reject sorry it flips with

745
00:26:43,440 --> 00:26:44,960
this bias which is just the ratio of the

746
00:26:44,960 --> 00:26:47,520
density of the desired density to

747
00:26:47,520 --> 00:26:49,120
the density that we of the reference

748
00:26:49,120 --> 00:26:51,200
distribution we'll multiply it by e to

749
00:26:51,200 --> 00:26:52,400
the epsilon

750
00:26:52,400 --> 00:26:54,080
which gives us we know that this value

751
00:26:54,080 --> 00:26:56,400
is at most one everything is

752
00:26:56,400 --> 00:26:58,480
easy to see that it's legal

753
00:26:58,480 --> 00:26:59,360
and

754
00:26:59,360 --> 00:27:02,000
and this is yeah and this works except

755
00:27:02,000 --> 00:27:04,000
we now use the pseudorandom bits instead

756
00:27:04,000 --> 00:27:05,360
of

757
00:27:05,360 --> 00:27:07,679
uh through randomness

758
00:27:07,679 --> 00:27:08,720
the uh

759
00:27:08,720 --> 00:27:10,640
and and and this is yeah that's

760
00:27:10,640 --> 00:27:13,360
basically the uh the algorithm

761
00:27:13,360 --> 00:27:14,159
uh

762
00:27:14,159 --> 00:27:15,440
that

763
00:27:15,440 --> 00:27:16,880
that we get

764
00:27:16,880 --> 00:27:19,440
and maybe the only thing that i uh uh

765
00:27:19,440 --> 00:27:21,039
yeah okay so the other part is the

766
00:27:21,039 --> 00:27:22,640
decoding and the coding is simple one

767
00:27:22,640 --> 00:27:24,559
given a seed you can always convert we

768
00:27:24,559 --> 00:27:26,799
have a way to convert a seed

769
00:27:26,799 --> 00:27:28,000
back to

770
00:27:28,000 --> 00:27:29,039
um

771
00:27:29,039 --> 00:27:30,799
an element in the domain by applying

772
00:27:30,799 --> 00:27:32,640
first expanding the seed into a large

773
00:27:32,640 --> 00:27:33,919
amount of randomness and then applying

774
00:27:33,919 --> 00:27:37,120
our reference distribution generator to

775
00:27:37,120 --> 00:27:39,279
create an element in the

776
00:27:39,279 --> 00:27:40,799
in the domain

777
00:27:40,799 --> 00:27:42,240
now the only sort of issue with this

778
00:27:42,240 --> 00:27:44,240
algorithm is that it

779
00:27:44,240 --> 00:27:45,039
does

780
00:27:45,039 --> 00:27:46,000
runs

781
00:27:46,000 --> 00:27:49,039
does run the sampling in in expectation

782
00:27:49,039 --> 00:27:51,279
e to the epsilon times so we do lose

783
00:27:51,279 --> 00:27:52,880
some something in computational

784
00:27:52,880 --> 00:27:54,480
efficiency here

785
00:27:54,480 --> 00:27:57,039
uh but uh other than that it's uh it's

786
00:27:57,039 --> 00:27:58,399
uh

787
00:27:58,399 --> 00:28:00,240
it's not even that much more complicated

788
00:28:00,240 --> 00:28:02,480
than the original

789
00:28:02,480 --> 00:28:04,480
randomizer

790
00:28:04,480 --> 00:28:06,240
so um

791
00:28:06,240 --> 00:28:08,960
let me just very briefly uh tell you why

792
00:28:08,960 --> 00:28:10,399
this uh

793
00:28:10,399 --> 00:28:11,760
uh

794
00:28:11,760 --> 00:28:14,080
why this works and what sort of

795
00:28:14,080 --> 00:28:15,760
yeah why do we get the guarantees that

796
00:28:15,760 --> 00:28:17,760
we i have mentioned and i won't go into

797
00:28:17,760 --> 00:28:19,760
too many uh details but let me just

798
00:28:19,760 --> 00:28:21,200
mention that

799
00:28:21,200 --> 00:28:23,919
uh that what we

800
00:28:23,919 --> 00:28:25,200
uh

801
00:28:25,200 --> 00:28:26,640
what we basically

802
00:28:26,640 --> 00:28:28,880
uh

803
00:28:28,880 --> 00:28:30,559
do is we we

804
00:28:30,559 --> 00:28:33,520
analyze the conditions under which

805
00:28:33,520 --> 00:28:34,399
uh

806
00:28:34,399 --> 00:28:36,720
the privacy guarantees uh would be

807
00:28:36,720 --> 00:28:40,679
preserved yes

808
00:28:52,000 --> 00:28:54,720
yes yes everything is is discreet kind

809
00:28:54,720 --> 00:28:56,880
of implicitly here because we assume

810
00:28:56,880 --> 00:28:59,279
that you can generate the output element

811
00:28:59,279 --> 00:29:02,960
using a finite number of random bits and

812
00:29:02,960 --> 00:29:04,640
of course you cannot generate an

813
00:29:04,640 --> 00:29:06,320
infinite precision with the random yes

814
00:29:06,320 --> 00:29:09,360
we live in a just implicitly

815
00:29:09,360 --> 00:29:12,720
live in a discrete world

816
00:29:12,720 --> 00:29:14,240
so

817
00:29:14,240 --> 00:29:15,760
to formally

818
00:29:15,760 --> 00:29:18,559
analyze we'll need to look at this again

819
00:29:18,559 --> 00:29:21,039
standard notion of fooling

820
00:29:21,039 --> 00:29:22,799
will

821
00:29:22,799 --> 00:29:26,640
we say that a certain prg uh

822
00:29:26,640 --> 00:29:30,399
fools a family of tests this uh script g

823
00:29:30,399 --> 00:29:32,720
if for every uh and the test is is some

824
00:29:32,720 --> 00:29:34,399
is basically just a boolean function

825
00:29:34,399 --> 00:29:35,760
which takes

826
00:29:35,760 --> 00:29:38,399
uh uh as an input a random string and

827
00:29:38,399 --> 00:29:40,799
tries to tell whether this is a

828
00:29:40,799 --> 00:29:43,600
true randomness or fake randomness so it

829
00:29:43,600 --> 00:29:46,559
out with just a zero one and and the prg

830
00:29:46,559 --> 00:29:48,720
fools the family of these tests if uh

831
00:29:48,720 --> 00:29:50,559
for any test

832
00:29:50,559 --> 00:29:53,039
the difference in the probability

833
00:29:53,039 --> 00:29:54,960
uh that the test accepts on two

834
00:29:54,960 --> 00:29:56,799
randomness versus it except accepting it

835
00:29:56,799 --> 00:29:58,559
on the randomness generated by

836
00:29:58,559 --> 00:30:01,200
the prg is at most beta

837
00:30:01,200 --> 00:30:02,640
and now

838
00:30:02,640 --> 00:30:05,440
what we show is that

839
00:30:05,440 --> 00:30:07,440
for a specific family of distinguishers

840
00:30:07,440 --> 00:30:09,760
which are just basically some sort of

841
00:30:09,760 --> 00:30:11,120
density

842
00:30:11,120 --> 00:30:14,399
ratio estimations uh and the important

843
00:30:14,399 --> 00:30:16,240
part here is

844
00:30:16,240 --> 00:30:18,399
that these are if you can estimate that

845
00:30:18,399 --> 00:30:19,919
is efficiently you can compute those

846
00:30:19,919 --> 00:30:22,559
efficiently

847
00:30:23,760 --> 00:30:25,840
if you have a prg for this particular

848
00:30:25,840 --> 00:30:27,120
family of

849
00:30:27,120 --> 00:30:28,640
distinguishers

850
00:30:28,640 --> 00:30:30,559
then

851
00:30:30,559 --> 00:30:33,200
this algorithm that we have defined its

852
00:30:33,200 --> 00:30:36,240
privacy guarantees are preserved up to

853
00:30:36,240 --> 00:30:37,760
this um

854
00:30:37,760 --> 00:30:41,039
uh up to this two types e to the epsilon

855
00:30:41,039 --> 00:30:42,080
beta

856
00:30:42,080 --> 00:30:45,120
but uh this beta can typically be made

857
00:30:45,120 --> 00:30:47,600
can be made to be exponentially small so

858
00:30:47,600 --> 00:30:49,600
it's effectively means that our privacy

859
00:30:49,600 --> 00:30:51,840
guarantees will be preserved

860
00:30:51,840 --> 00:30:53,360
the um

861
00:30:53,360 --> 00:30:54,799
and the other part is that of course we

862
00:30:54,799 --> 00:30:55,919
also need to

863
00:30:55,919 --> 00:30:58,159
preserve utility but that's uh here it

864
00:30:58,159 --> 00:30:59,279
will be just usual computational

865
00:30:59,279 --> 00:31:00,559
assumptions because we're kind of

866
00:31:00,559 --> 00:31:01,760
effectively just

867
00:31:01,760 --> 00:31:04,080
replacing some random bits with

868
00:31:04,080 --> 00:31:06,640
pseudorandom and and here this is just a

869
00:31:06,640 --> 00:31:09,440
standard analysis

870
00:31:10,080 --> 00:31:12,000
anyway that's uh just to give you a

871
00:31:12,000 --> 00:31:14,000
little bit of intuition about the result

872
00:31:14,000 --> 00:31:17,279
feel free to ask any questions if and if

873
00:31:17,279 --> 00:31:18,640
not uh well

874
00:31:18,640 --> 00:31:20,080
you don't need to

875
00:31:20,080 --> 00:31:21,440
you won't need this result for the rest

876
00:31:21,440 --> 00:31:22,960
of the time

877
00:31:22,960 --> 00:31:24,960
so now let me uh tell you a little bit

878
00:31:24,960 --> 00:31:26,720
about the applications

879
00:31:26,720 --> 00:31:30,000
and before uh going uh abrasion let me

880
00:31:30,000 --> 00:31:31,840
just roughly describe what was the stake

881
00:31:31,840 --> 00:31:34,080
of the art uh before this work for

882
00:31:34,080 --> 00:31:37,120
frequency estimation so first of all the

883
00:31:37,120 --> 00:31:39,440
algorithm that i mentioned rapport

884
00:31:39,440 --> 00:31:41,760
is guard back in 14 we know that its

885
00:31:41,760 --> 00:31:44,399
error is uh actually was later

886
00:31:44,399 --> 00:31:46,640
discovered that this is uh

887
00:31:46,640 --> 00:31:48,960
utility prices trade off is essentially

888
00:31:48,960 --> 00:31:50,000
optimal

889
00:31:50,000 --> 00:31:52,480
and here we even know what this optimal

890
00:31:52,480 --> 00:31:55,440
er error is it has been kind of computed

891
00:31:55,440 --> 00:31:58,320
and proved in uh in more recent work by

892
00:31:58,320 --> 00:32:00,880
ian barge and that's the value of this

893
00:32:00,880 --> 00:32:02,960
error just a function of

894
00:32:02,960 --> 00:32:05,919
whatever n and epsilon and k

895
00:32:05,919 --> 00:32:07,360
uh

896
00:32:07,360 --> 00:32:09,279
the problem with this algorithm is that

897
00:32:09,279 --> 00:32:12,080
it is has communication k

898
00:32:12,080 --> 00:32:14,000
and also an additional problem is that

899
00:32:14,000 --> 00:32:15,840
server compute is high because you need

900
00:32:15,840 --> 00:32:17,120
to basically

901
00:32:17,120 --> 00:32:20,399
add n times k which could be very large

902
00:32:20,399 --> 00:32:22,000
and there is a closely related algorithm

903
00:32:22,000 --> 00:32:23,440
which is uh

904
00:32:23,440 --> 00:32:26,000
referred to as subset selection which is

905
00:32:26,000 --> 00:32:27,200
um

906
00:32:27,200 --> 00:32:29,600
basically uh instead of

907
00:32:29,600 --> 00:32:31,519
independent bits they are

908
00:32:31,519 --> 00:32:32,880
like a set of

909
00:32:32,880 --> 00:32:34,960
fixed size random set of fixed sizes

910
00:32:34,960 --> 00:32:36,000
chosen

911
00:32:36,000 --> 00:32:38,240
and that's uh that algorithm is actually

912
00:32:38,240 --> 00:32:40,159
truly optimal

913
00:32:40,159 --> 00:32:41,519
but and its communication is a little

914
00:32:41,519 --> 00:32:43,600
better but not by much still has high

915
00:32:43,600 --> 00:32:45,760
server compute

916
00:32:45,760 --> 00:32:48,399
for uh a number of algorithms which are

917
00:32:48,399 --> 00:32:50,320
kind of uh were developed in the uh for

918
00:32:50,320 --> 00:32:52,000
the problems heavy hitters

919
00:32:52,000 --> 00:32:54,080
a related problem uh can be shown to

920
00:32:54,080 --> 00:32:55,120
achieve

921
00:32:55,120 --> 00:32:56,480
a

922
00:32:56,480 --> 00:32:58,320
sort of order optimal

923
00:32:58,320 --> 00:33:00,640
error although only when epsilon is at

924
00:33:00,640 --> 00:33:01,840
most one

925
00:33:01,840 --> 00:33:04,559
while having both low communication and

926
00:33:04,559 --> 00:33:07,360
low server compute uh compute so there

927
00:33:07,360 --> 00:33:11,279
and those have been known for a while

928
00:33:11,279 --> 00:33:13,120
as i said the problem is that here order

929
00:33:13,120 --> 00:33:14,000
optimal

930
00:33:14,000 --> 00:33:16,559
often order optimal by

931
00:33:16,559 --> 00:33:18,559
by significant constant

932
00:33:18,559 --> 00:33:20,000
more recently

933
00:33:20,000 --> 00:33:21,200
there have been

934
00:33:21,200 --> 00:33:23,440
two algorithms basically both based on

935
00:33:23,440 --> 00:33:25,360
hadamard transform

936
00:33:25,360 --> 00:33:27,919
uh which achieved border optimal

937
00:33:27,919 --> 00:33:30,720
error for all epsilons

938
00:33:30,720 --> 00:33:33,440
uh have low communication and uh low

939
00:33:33,440 --> 00:33:35,440
server compute but again an order

940
00:33:35,440 --> 00:33:37,519
optimal here is already quite reasonable

941
00:33:37,519 --> 00:33:39,519
it's just within roughly a factor of two

942
00:33:39,519 --> 00:33:41,279
but still not great and maybe i should

943
00:33:41,279 --> 00:33:43,120
mention there is also an algorithm which

944
00:33:43,120 --> 00:33:45,360
is if you allow public randomness there

945
00:33:45,360 --> 00:33:46,799
was an algorithm

946
00:33:46,799 --> 00:33:48,960
uh which is referred to as local hashing

947
00:33:48,960 --> 00:33:50,399
which is optimal at least for some

948
00:33:50,399 --> 00:33:52,640
values of epsilon not all and again

949
00:33:52,640 --> 00:33:53,919
requires

950
00:33:53,919 --> 00:33:56,159
public randomness it has high

951
00:33:56,159 --> 00:33:57,600
server compute

952
00:33:57,600 --> 00:34:01,279
uh but that's roughly the state of dr

953
00:34:01,279 --> 00:34:03,679
so let and let me

954
00:34:03,679 --> 00:34:05,760
show what we can do it

955
00:34:05,760 --> 00:34:08,320
using our ideas so

956
00:34:08,320 --> 00:34:11,280
for this let's very quickly recall this

957
00:34:11,280 --> 00:34:14,719
uh rapport algorithm which converts to

958
00:34:14,719 --> 00:34:17,199
this long vector and then randomizes all

959
00:34:17,199 --> 00:34:19,918
bits independently creating a very long

960
00:34:19,918 --> 00:34:21,839
string of bits

961
00:34:21,839 --> 00:34:23,760
but one relatively uh

962
00:34:23,760 --> 00:34:25,599
simple observation

963
00:34:25,599 --> 00:34:27,918
is that in order to preserve the utility

964
00:34:27,918 --> 00:34:30,639
and privacy of this algorithm all we

965
00:34:30,639 --> 00:34:32,879
need is to make sure that these

966
00:34:32,879 --> 00:34:36,239
bits in this long string are pairwise

967
00:34:36,239 --> 00:34:37,918
independent we don't need them to be

968
00:34:37,918 --> 00:34:39,679
entirely independent we'll have both the

969
00:34:39,679 --> 00:34:41,280
utility and privacy if they're just

970
00:34:41,280 --> 00:34:42,960
pairwise independent

971
00:34:42,960 --> 00:34:43,760
and

972
00:34:43,760 --> 00:34:46,000
pairwise independent strings families

973
00:34:46,000 --> 00:34:48,239
pairwise independent strings don't need

974
00:34:48,239 --> 00:34:50,560
to be uh long we can communicate there

975
00:34:50,560 --> 00:34:52,159
are shorter construction effects

976
00:34:52,159 --> 00:34:53,918
standard in cryptography

977
00:34:53,918 --> 00:34:54,879
um

978
00:34:54,879 --> 00:34:56,159
ways to

979
00:34:56,159 --> 00:34:58,079
to do this i mean only need all we need

980
00:34:58,079 --> 00:35:00,000
is basically just a pairwise independent

981
00:35:00,000 --> 00:35:03,040
and independent family of random strings

982
00:35:03,040 --> 00:35:05,520
with the right biases we need because

983
00:35:05,520 --> 00:35:08,160
these are bernoulli specific biases

984
00:35:08,160 --> 00:35:10,079
and this can be done via standard

985
00:35:10,079 --> 00:35:11,839
construction which is

986
00:35:11,839 --> 00:35:14,160
most standard one is your subspaces of a

987
00:35:14,160 --> 00:35:16,800
vector space or finite field again

988
00:35:16,800 --> 00:35:18,960
you've seen it you know it but if not

989
00:35:18,960 --> 00:35:20,400
it's simple

990
00:35:20,400 --> 00:35:21,280
um

991
00:35:21,280 --> 00:35:23,520
modular arithmetic

992
00:35:23,520 --> 00:35:25,200
uh the sort of the properties of this

993
00:35:25,200 --> 00:35:26,400
algorithms are as following it

994
00:35:26,400 --> 00:35:27,920
communicates roughly

995
00:35:27,920 --> 00:35:29,760
order of epsilon plus log k bits a very

996
00:35:29,760 --> 00:35:31,200
short communication

997
00:35:31,200 --> 00:35:32,320
uh

998
00:35:32,320 --> 00:35:34,400
we can show that it achieves the optimal

999
00:35:34,400 --> 00:35:35,920
privacy utility tradeoff it basically

1000
00:35:35,920 --> 00:35:37,839
follows from general analysis can be

1001
00:35:37,839 --> 00:35:39,440
pulled directly

1002
00:35:39,440 --> 00:35:42,160
and it has the sort of the only

1003
00:35:42,160 --> 00:35:43,440
uh

1004
00:35:43,440 --> 00:35:44,480
thing

1005
00:35:44,480 --> 00:35:45,680
thing which is not so great is the

1006
00:35:45,680 --> 00:35:47,440
running time is

1007
00:35:47,440 --> 00:35:49,839
is is sometimes better than the naive

1008
00:35:49,839 --> 00:35:52,079
rapport algorithm but sometimes not

1009
00:35:52,079 --> 00:35:54,400
basically only better when

1010
00:35:54,400 --> 00:35:59,520
uh k is k squared is uh k is less than

1011
00:35:59,520 --> 00:36:01,119
uh n

1012
00:36:01,119 --> 00:36:05,119
uh so or sorry no when uh k is uh yeah

1013
00:36:05,119 --> 00:36:06,960
less than n so this is the the running

1014
00:36:06,960 --> 00:36:09,920
time so it's it it doesn't always

1015
00:36:09,920 --> 00:36:11,200
improve on the running time of the

1016
00:36:11,200 --> 00:36:13,920
original report and this running time is

1017
00:36:13,920 --> 00:36:15,839
the problem uh issued is what we have

1018
00:36:15,839 --> 00:36:18,480
addressed in uh in a follow-up work

1019
00:36:18,480 --> 00:36:20,160
uh with um

1020
00:36:20,160 --> 00:36:22,240
jelani nelson who in gwen and kunal

1021
00:36:22,240 --> 00:36:23,359
talvar

1022
00:36:23,359 --> 00:36:25,280
and a very let me very briefly describe

1023
00:36:25,280 --> 00:36:27,359
this what we do in this work

1024
00:36:27,359 --> 00:36:28,079
is

1025
00:36:28,079 --> 00:36:31,040
it's a kind of a similar

1026
00:36:31,040 --> 00:36:33,920
idea in the sense that we we do need to

1027
00:36:33,920 --> 00:36:34,960
uh

1028
00:36:34,960 --> 00:36:36,480
create

1029
00:36:36,480 --> 00:36:38,240
a set system with certain properties

1030
00:36:38,240 --> 00:36:40,960
specifically pairwise independence

1031
00:36:40,960 --> 00:36:42,560
and to do this instead of using the sort

1032
00:36:42,560 --> 00:36:43,760
of the standard vector space

1033
00:36:43,760 --> 00:36:45,599
construction we use so-called projective

1034
00:36:45,599 --> 00:36:46,640
spaces

1035
00:36:46,640 --> 00:36:48,720
and a projective space of a vector space

1036
00:36:48,720 --> 00:36:50,400
or a finite field

1037
00:36:50,400 --> 00:36:52,560
is just um

1038
00:36:52,560 --> 00:36:54,640
a space

1039
00:36:54,640 --> 00:36:59,040
in which uh elements that uh that are uh

1040
00:36:59,040 --> 00:37:01,119
each element is a scalar multiple of the

1041
00:37:01,119 --> 00:37:02,880
other are basically equivalent so it's

1042
00:37:02,880 --> 00:37:05,200
basically the set of equivalence classes

1043
00:37:05,200 --> 00:37:08,240
where equivalence is defined by

1044
00:37:08,240 --> 00:37:10,560
multiplying by scalar

1045
00:37:10,560 --> 00:37:12,640
and the sort of t minus two dimensional

1046
00:37:12,640 --> 00:37:15,119
projective spaces are

1047
00:37:15,119 --> 00:37:16,800
form a pairwise independent subsystem

1048
00:37:16,800 --> 00:37:19,200
with the nice properties on top of this

1049
00:37:19,200 --> 00:37:21,200
kind of construction

1050
00:37:21,200 --> 00:37:23,040
we

1051
00:37:23,040 --> 00:37:24,400
use a

1052
00:37:24,400 --> 00:37:26,000
better server-side decoding algorithm

1053
00:37:26,000 --> 00:37:27,599
which is based on

1054
00:37:27,599 --> 00:37:30,960
on dynamic programming and together uh

1055
00:37:30,960 --> 00:37:33,040
this construction gives us an algorithm

1056
00:37:33,040 --> 00:37:35,520
which still has low communication of

1057
00:37:35,520 --> 00:37:37,760
epsilon plus log k bits even better than

1058
00:37:37,760 --> 00:37:40,960
our pi rapport it has still has optimal

1059
00:37:40,960 --> 00:37:43,119
privacy utility trade-off

1060
00:37:43,119 --> 00:37:45,280
and now the server run time

1061
00:37:45,280 --> 00:37:47,920
is on the order of n plus k times e to

1062
00:37:47,920 --> 00:37:49,440
the epsilon low k basically it's much

1063
00:37:49,440 --> 00:37:50,400
better

1064
00:37:50,400 --> 00:37:51,920
it doesn't have this k squared or n

1065
00:37:51,920 --> 00:37:54,640
times k term

1066
00:37:54,640 --> 00:37:56,000
and importantly the algorithm is not

1067
00:37:56,000 --> 00:37:57,680
just

1068
00:37:57,680 --> 00:38:00,800
nice theoretically it actually

1069
00:38:00,800 --> 00:38:02,560
works in practice and let me just

1070
00:38:02,560 --> 00:38:05,599
briefly uh mention it's uh uh

1071
00:38:05,599 --> 00:38:06,800
a little bit about the results of

1072
00:38:06,800 --> 00:38:08,960
simulations so for example for epsilon

1073
00:38:08,960 --> 00:38:10,720
equal to five and

1074
00:38:10,720 --> 00:38:13,599
k being the domain of three thousand it

1075
00:38:13,599 --> 00:38:16,720
is fifty times faster than our pyrapore

1076
00:38:16,720 --> 00:38:19,920
and only five times slower than the best

1077
00:38:19,920 --> 00:38:22,000
the fastest algorithm so far which kind

1078
00:38:22,000 --> 00:38:24,079
of had reasonably good guarantees

1079
00:38:24,079 --> 00:38:25,280
although again not optimal but

1080
00:38:25,280 --> 00:38:27,359
reasonably good guarantee it's uh it's

1081
00:38:27,359 --> 00:38:28,960
relatively easy to implement and the

1082
00:38:28,960 --> 00:38:31,680
code is now publicly available

1083
00:38:31,680 --> 00:38:34,320
here are sub measurements of the error

1084
00:38:34,320 --> 00:38:36,480
and this is a graph of sort of of the

1085
00:38:36,480 --> 00:38:38,400
error as a function of epsilon for

1086
00:38:38,400 --> 00:38:40,079
different epsilons for a specific

1087
00:38:40,079 --> 00:38:42,720
frequency estimation problem some zip

1088
00:38:42,720 --> 00:38:45,520
distribution some domain size this is

1089
00:38:45,520 --> 00:38:47,119
the domain size this is the number of

1090
00:38:47,119 --> 00:38:48,160
users

1091
00:38:48,160 --> 00:38:49,040
the

1092
00:38:49,040 --> 00:38:50,000
uh

1093
00:38:50,000 --> 00:38:52,240
blue line uh and the light blue lines

1094
00:38:52,240 --> 00:38:54,560
are basically this uh the the dark blue

1095
00:38:54,560 --> 00:38:56,720
line is subset selection is the optimal

1096
00:38:56,720 --> 00:38:58,800
algorithm which has high communication

1097
00:38:58,800 --> 00:39:00,640
the light blue line is our algorithm

1098
00:39:00,640 --> 00:39:02,000
which has

1099
00:39:02,000 --> 00:39:04,320
exactly the same error

1100
00:39:04,320 --> 00:39:06,320
but now has low communication and the

1101
00:39:06,320 --> 00:39:08,160
lines above are two

1102
00:39:08,160 --> 00:39:09,920
previous low communication algorithms

1103
00:39:09,920 --> 00:39:12,000
based on hadamard response

1104
00:39:12,000 --> 00:39:12,839
uh

1105
00:39:12,839 --> 00:39:16,160
and they have low low compute but uh the

1106
00:39:16,160 --> 00:39:17,359
error is

1107
00:39:17,359 --> 00:39:18,400
higher

1108
00:39:18,400 --> 00:39:22,000
often by a factor of two or more

1109
00:39:22,000 --> 00:39:23,599
so that's all that i want to say about

1110
00:39:23,599 --> 00:39:25,040
this problem let me now tell you a

1111
00:39:25,040 --> 00:39:27,839
little bit uh about mean estimation and

1112
00:39:27,839 --> 00:39:29,680
this is a problem

1113
00:39:29,680 --> 00:39:31,040
for which we actually know a little bit

1114
00:39:31,040 --> 00:39:33,200
less than uh for frequency estimation in

1115
00:39:33,200 --> 00:39:34,960
this context but

1116
00:39:34,960 --> 00:39:37,839
still we're now no more than

1117
00:39:37,839 --> 00:39:39,520
what we used to know

1118
00:39:39,520 --> 00:39:42,400
so first of all i should note that this

1119
00:39:42,400 --> 00:39:43,520
addition of

1120
00:39:43,520 --> 00:39:45,119
maybe one standard algorithm that has

1121
00:39:45,119 --> 00:39:46,640
been known for a long time is addition

1122
00:39:46,640 --> 00:39:47,520
of

1123
00:39:47,520 --> 00:39:48,560
uh

1124
00:39:48,560 --> 00:39:52,400
laplacian or gaussian noise

1125
00:39:52,400 --> 00:39:56,240
and we know that this algorithm achieves

1126
00:39:56,240 --> 00:39:58,240
order optimal error but its

1127
00:39:58,240 --> 00:39:59,920
communication scales with the dimension

1128
00:39:59,920 --> 00:40:02,320
d and also the uh

1129
00:40:02,320 --> 00:40:04,960
compute is uh high on the server because

1130
00:40:04,960 --> 00:40:06,640
g times n

1131
00:40:06,640 --> 00:40:10,800
uh we have uh sort of the first um

1132
00:40:10,800 --> 00:40:12,079
uh

1133
00:40:12,079 --> 00:40:14,319
algorithm which uh

1134
00:40:14,319 --> 00:40:15,680
maybe could show

1135
00:40:15,680 --> 00:40:17,760
was so so this laplace and gaussian

1136
00:40:17,760 --> 00:40:20,560
noise uh have been proven opt they don't

1137
00:40:20,560 --> 00:40:22,880
achieve the pure epsilon the approximate

1138
00:40:22,880 --> 00:40:24,480
differential privacy so there are some

1139
00:40:24,480 --> 00:40:26,240
additional log factor in that optimality

1140
00:40:26,240 --> 00:40:27,280
result

1141
00:40:27,280 --> 00:40:28,720
to avoid the first algorithm which

1142
00:40:28,720 --> 00:40:30,400
avoids this log factor is this private

1143
00:40:30,400 --> 00:40:33,520
half spaces by uh duchy and others

1144
00:40:33,520 --> 00:40:35,359
uh which shows optimality although only

1145
00:40:35,359 --> 00:40:37,359
for epsilon smaller than one still with

1146
00:40:37,359 --> 00:40:40,160
high communication and

1147
00:40:40,160 --> 00:40:41,680
high communication

1148
00:40:41,680 --> 00:40:44,079
this has been improved to arbitrary

1149
00:40:44,079 --> 00:40:46,079
epsilon to this algorithm referred to as

1150
00:40:46,079 --> 00:40:47,520
preview unit

1151
00:40:47,520 --> 00:40:49,920
uh still high communication

1152
00:40:49,920 --> 00:40:51,440
uh the

1153
00:40:51,440 --> 00:40:53,920
algorithms which uh which do achieve low

1154
00:40:53,920 --> 00:40:55,440
communication

1155
00:40:55,440 --> 00:40:57,200
uh have been proposed based on so-called

1156
00:40:57,200 --> 00:40:59,920
caution representation first for epsilon

1157
00:40:59,920 --> 00:41:01,839
smaller than one in my work with guzman

1158
00:41:01,839 --> 00:41:03,680
and venpala and more recently

1159
00:41:03,680 --> 00:41:05,839
by chen and others

1160
00:41:05,839 --> 00:41:08,880
for arbitrary epsilon and these are the

1161
00:41:08,880 --> 00:41:10,240
first algorithms which achieve low

1162
00:41:10,240 --> 00:41:12,560
communication just epsilon times log to

1163
00:41:12,560 --> 00:41:13,200
d

1164
00:41:13,200 --> 00:41:16,240
and have order optimal uh error

1165
00:41:16,240 --> 00:41:17,520
and at least it wasn't known for any of

1166
00:41:17,520 --> 00:41:20,480
the algorithm weather

1167
00:41:20,480 --> 00:41:21,920
whether any of those

1168
00:41:21,920 --> 00:41:23,200
is actually

1169
00:41:23,200 --> 00:41:25,680
uh optimal although in practice it has

1170
00:41:25,680 --> 00:41:27,680
been known that this pre-unit achieves

1171
00:41:27,680 --> 00:41:29,200
empirically the best

1172
00:41:29,200 --> 00:41:31,359
the best error

1173
00:41:31,359 --> 00:41:34,720
uh and this is the we know we we know

1174
00:41:34,720 --> 00:41:36,480
the order optimal error for this uh

1175
00:41:36,480 --> 00:41:39,440
problem behaves like this

1176
00:41:39,440 --> 00:41:41,040
at least asymptotically

1177
00:41:41,040 --> 00:41:44,079
so here are some uh uh as i said best

1178
00:41:44,079 --> 00:41:46,079
content achieved by preview unit

1179
00:41:46,079 --> 00:41:48,800
uh let me now describe some new results

1180
00:41:48,800 --> 00:41:50,319
for this problem

1181
00:41:50,319 --> 00:41:51,920
and and for this purpose let me first

1182
00:41:51,920 --> 00:41:53,920
tell you how this uh

1183
00:41:53,920 --> 00:41:57,440
prevunit algorithm by baumik and others

1184
00:41:57,440 --> 00:41:59,680
uh works

1185
00:41:59,680 --> 00:42:02,240
and it's an algorithm which is uh which

1186
00:42:02,240 --> 00:42:05,680
again tries to send a vector of norm at

1187
00:42:05,680 --> 00:42:07,200
most one

1188
00:42:07,200 --> 00:42:09,599
uh basically let's imagine norm being

1189
00:42:09,599 --> 00:42:10,480
one

1190
00:42:10,480 --> 00:42:11,760
and it's parameterized by three

1191
00:42:11,760 --> 00:42:13,440
parameters

1192
00:42:13,440 --> 00:42:16,000
uh this r which is a radius a gamma is

1193
00:42:16,000 --> 00:42:17,520
something with some kind of

1194
00:42:17,520 --> 00:42:19,520
offset a little margin

1195
00:42:19,520 --> 00:42:21,680
and some probability p and what it does

1196
00:42:21,680 --> 00:42:24,319
it first of all it samples from

1197
00:42:24,319 --> 00:42:26,720
its support is a ball

1198
00:42:26,720 --> 00:42:30,880
a d dimensional ball of radius r uh it

1199
00:42:30,880 --> 00:42:33,680
samples uh with probability

1200
00:42:33,680 --> 00:42:34,960
uh p

1201
00:42:34,960 --> 00:42:37,440
it samples from this uh spherical

1202
00:42:37,440 --> 00:42:40,000
spherical cap which is defined by by

1203
00:42:40,000 --> 00:42:43,040
moving by this margin gamma away from

1204
00:42:43,040 --> 00:42:45,040
uh from the sort of the

1205
00:42:45,040 --> 00:42:46,720
uh in the direction sorry circle cup in

1206
00:42:46,720 --> 00:42:49,680
the direction of the input vector u

1207
00:42:49,680 --> 00:42:50,640
uh

1208
00:42:50,640 --> 00:42:52,400
uh it samples from the spherical cup so

1209
00:42:52,400 --> 00:42:53,760
it's kind of biased towards the correct

1210
00:42:53,760 --> 00:42:56,079
answer and probability one minus p it

1211
00:42:56,079 --> 00:42:57,119
samples

1212
00:42:57,119 --> 00:42:59,839
uh uniformly from the uh

1213
00:42:59,839 --> 00:43:02,800
complement of this of that spherical cap

1214
00:43:02,800 --> 00:43:04,160
so this is algorithm which has three

1215
00:43:04,160 --> 00:43:07,440
parameters but only because we typically

1216
00:43:07,440 --> 00:43:08,319
want

1217
00:43:08,319 --> 00:43:11,599
this to be unbiased so

1218
00:43:11,599 --> 00:43:13,359
epsilon differential privacy and biases

1219
00:43:13,359 --> 00:43:14,400
create two constraints so there's

1220
00:43:14,400 --> 00:43:17,359
effectively only one uh

1221
00:43:17,359 --> 00:43:20,000
free parameter uh in this algorithm

1222
00:43:20,000 --> 00:43:21,839
and uh what we show is that for an

1223
00:43:21,839 --> 00:43:23,520
appropriate choice of parameters so so

1224
00:43:23,520 --> 00:43:25,280
this algorithm was proposed with a

1225
00:43:25,280 --> 00:43:27,200
specific choice of parameters

1226
00:43:27,200 --> 00:43:28,800
but we showed that there is always a

1227
00:43:28,800 --> 00:43:30,560
choice of parameters for which this

1228
00:43:30,560 --> 00:43:33,119
randomize is optimal and this is joint

1229
00:43:33,119 --> 00:43:34,800
work with hillala c

1230
00:43:34,800 --> 00:43:37,040
and kunal kalvar we show that for every

1231
00:43:37,040 --> 00:43:38,720
epsilon nd there exists a choice of

1232
00:43:38,720 --> 00:43:39,920
parameters

1233
00:43:39,920 --> 00:43:42,400
this this algorithm has the lowest

1234
00:43:42,400 --> 00:43:44,720
variance among all unbiased local

1235
00:43:44,720 --> 00:43:47,200
randomizers

1236
00:43:47,200 --> 00:43:48,000
so

1237
00:43:48,000 --> 00:43:50,400
that's all that i wanted to say about

1238
00:43:50,400 --> 00:43:52,400
this result

1239
00:43:52,400 --> 00:43:54,560
so now that we know what the optimal

1240
00:43:54,560 --> 00:43:56,480
algorithm is we can compress it using

1241
00:43:56,480 --> 00:43:58,560
this generic uh

1242
00:43:58,560 --> 00:44:01,040
technique uh we don't have anything much

1243
00:44:01,040 --> 00:44:02,240
better although there is a version of

1244
00:44:02,240 --> 00:44:04,319
algorithm which can trade off

1245
00:44:04,319 --> 00:44:06,720
the generic scheme with uh trade off

1246
00:44:06,720 --> 00:44:07,920
some of the accuracy for computational

1247
00:44:07,920 --> 00:44:09,599
efficiency we don't want to pay this e

1248
00:44:09,599 --> 00:44:11,440
to the epsilon blow up

1249
00:44:11,440 --> 00:44:13,040
but these are the let me just describe

1250
00:44:13,040 --> 00:44:15,520
the results that uh that this um our

1251
00:44:15,520 --> 00:44:18,640
optimized algorithm achieves empirically

1252
00:44:18,640 --> 00:44:21,040
and and here are the comparisons so this

1253
00:44:21,040 --> 00:44:24,319
uh the the only local communication

1254
00:44:24,319 --> 00:44:26,000
algorithms and

1255
00:44:26,000 --> 00:44:28,640
prior to r is this sqkr by chen and

1256
00:44:28,640 --> 00:44:30,480
others it achieves this is the error

1257
00:44:30,480 --> 00:44:32,560
here's the error is on logarithmic scale

1258
00:44:32,560 --> 00:44:33,440
so the

1259
00:44:33,440 --> 00:44:36,079
this is gap of a factor more than two

1260
00:44:36,079 --> 00:44:38,800
the uh preview unit the original one and

1261
00:44:38,800 --> 00:44:41,280
previous spaces are just this

1262
00:44:41,280 --> 00:44:43,119
red the red one is because it doesn't

1263
00:44:43,119 --> 00:44:45,440
work well for for large epsilon

1264
00:44:45,440 --> 00:44:47,760
the the first

1265
00:44:47,760 --> 00:44:49,760
the original per unit is this black line

1266
00:44:49,760 --> 00:44:53,359
and our optimized version is is this uh

1267
00:44:53,359 --> 00:44:55,280
green one so you can just see that it's

1268
00:44:55,280 --> 00:44:57,280
a significant

1269
00:44:57,280 --> 00:44:58,800
uh improvement

1270
00:44:58,800 --> 00:45:01,440
while having low communication

1271
00:45:01,440 --> 00:45:02,960
and it's again it's uh

1272
00:45:02,960 --> 00:45:04,640
uh i should have mentioned that this is

1273
00:45:04,640 --> 00:45:06,880
a plot of uh

1274
00:45:06,880 --> 00:45:09,920
expected squared error versus epsilon so

1275
00:45:09,920 --> 00:45:12,400
we want to see how it uh behaves

1276
00:45:12,400 --> 00:45:14,640
for this epsilon in this small constant

1277
00:45:14,640 --> 00:45:17,640
range

1278
00:45:18,000 --> 00:45:20,079
okay so that's um

1279
00:45:20,079 --> 00:45:22,400
all that i want to say about the uh mean

1280
00:45:22,400 --> 00:45:23,760
estimation

1281
00:45:23,760 --> 00:45:26,000
uh and as i promised i want to

1282
00:45:26,000 --> 00:45:28,160
briefly tell you a bit about how these

1283
00:45:28,160 --> 00:45:30,160
ideas can be taken

1284
00:45:30,160 --> 00:45:32,160
applied in this sort of more complex

1285
00:45:32,160 --> 00:45:33,839
systems where we have additional privacy

1286
00:45:33,839 --> 00:45:36,640
guarantees beyond just the local privacy

1287
00:45:36,640 --> 00:45:38,720
and specifically we'll be uh

1288
00:45:38,720 --> 00:45:40,480
looking at the setting where

1289
00:45:40,480 --> 00:45:41,760
uh

1290
00:45:41,760 --> 00:45:44,720
we don't want the server to observe the

1291
00:45:44,720 --> 00:45:46,319
individual reports from the users we

1292
00:45:46,319 --> 00:45:48,800
want the server to only observe

1293
00:45:48,800 --> 00:45:52,640
uh the aggregate or sum of the

1294
00:45:52,640 --> 00:45:55,200
of the user reports and

1295
00:45:55,200 --> 00:45:56,960
moreover we don't want

1296
00:45:56,960 --> 00:45:59,119
to trust this aggregation to a single

1297
00:45:59,119 --> 00:46:01,280
server want to do it via secret sharing

1298
00:46:01,280 --> 00:46:03,200
you've heard quite a bit already today

1299
00:46:03,200 --> 00:46:04,800
about secret sharing so i don't need to

1300
00:46:04,800 --> 00:46:05,760
tell you

1301
00:46:05,760 --> 00:46:07,680
uh about its advantages there is there

1302
00:46:07,680 --> 00:46:08,480
is no

1303
00:46:08,480 --> 00:46:11,359
uh single source of trust and

1304
00:46:11,359 --> 00:46:13,200
the the hope is that each in each of

1305
00:46:13,200 --> 00:46:15,280
those uh

1306
00:46:15,280 --> 00:46:17,040
aggregation servers will not

1307
00:46:17,040 --> 00:46:18,960
individually will not gain any

1308
00:46:18,960 --> 00:46:21,359
information at all about user data not

1309
00:46:21,359 --> 00:46:22,960
even

1310
00:46:22,960 --> 00:46:24,960
epsilon differentially private so how

1311
00:46:24,960 --> 00:46:27,200
will it work we'll have

1312
00:46:27,200 --> 00:46:28,880
each randomizer instead of creating a

1313
00:46:28,880 --> 00:46:30,480
single output it will create actually a

1314
00:46:30,480 --> 00:46:32,400
pair of output for simplicity will be

1315
00:46:32,400 --> 00:46:34,160
sector sharing to just two server but it

1316
00:46:34,160 --> 00:46:36,319
extends to more servers

1317
00:46:36,319 --> 00:46:38,000
and possibility will think of this as

1318
00:46:38,000 --> 00:46:40,400
randomizer creating two shares

1319
00:46:40,400 --> 00:46:42,560
and shares the first shares will be

1320
00:46:42,560 --> 00:46:45,040
aggregated by by one server and the

1321
00:46:45,040 --> 00:46:47,040
second shares will be uh aggregated by

1322
00:46:47,040 --> 00:46:49,920
the other server and we want to uh then

1323
00:46:49,920 --> 00:46:51,680
send these aggregates to

1324
00:46:51,680 --> 00:46:53,520
the analyst

1325
00:46:53,520 --> 00:46:55,760
uh in a way that's kind of amplifies

1326
00:46:55,760 --> 00:46:58,240
privacy and we know that aggregation

1327
00:46:58,240 --> 00:47:00,240
will amplify privacy even even just

1328
00:47:00,240 --> 00:47:02,079
shuffling amplifies privacy but

1329
00:47:02,079 --> 00:47:04,000
aggregation it has even better privacy

1330
00:47:04,000 --> 00:47:05,599
amplification

1331
00:47:05,599 --> 00:47:07,440
guarantees

1332
00:47:07,440 --> 00:47:09,680
so uh this looks like a relatively

1333
00:47:09,680 --> 00:47:12,319
complicated setup but it it one can we

1334
00:47:12,319 --> 00:47:15,200
can show that it we can reduce

1335
00:47:15,200 --> 00:47:17,119
uh the

1336
00:47:17,119 --> 00:47:17,920
uh

1337
00:47:17,920 --> 00:47:20,000
the problem of designing local

1338
00:47:20,000 --> 00:47:21,680
randomizers for the setting to the

1339
00:47:21,680 --> 00:47:22,720
following

1340
00:47:22,720 --> 00:47:24,400
uh two randomizes with the following

1341
00:47:24,400 --> 00:47:25,520
properties

1342
00:47:25,520 --> 00:47:27,599
and we'll call it this basically secret

1343
00:47:27,599 --> 00:47:29,599
shared local randomizer

1344
00:47:29,599 --> 00:47:31,200
and it's a randomizer with the following

1345
00:47:31,200 --> 00:47:34,000
property it takes an input element index

1346
00:47:34,000 --> 00:47:35,839
but it produces a pair of values

1347
00:47:35,839 --> 00:47:38,800
basically two secret shares uh and of

1348
00:47:38,800 --> 00:47:39,680
course

1349
00:47:39,680 --> 00:47:40,960
with the following property is that we

1350
00:47:40,960 --> 00:47:42,880
have two decoding uh

1351
00:47:42,880 --> 00:47:44,720
procedurally code one and the code two

1352
00:47:44,720 --> 00:47:46,559
the first one from the first element and

1353
00:47:46,559 --> 00:47:48,400
the second one for the second element

1354
00:47:48,400 --> 00:47:50,160
uh with the following properties that if

1355
00:47:50,160 --> 00:47:51,119
we

1356
00:47:51,119 --> 00:47:54,960
uh take these pairs and um we decode

1357
00:47:54,960 --> 00:47:57,200
them separately and then add up the

1358
00:47:57,200 --> 00:47:58,720
decoding of the shares basically this

1359
00:47:58,720 --> 00:48:00,880
kind of homo homomorphic property we

1360
00:48:00,880 --> 00:48:03,920
decode these shares then the

1361
00:48:03,920 --> 00:48:04,800
this

1362
00:48:04,800 --> 00:48:06,640
sum of these decodings will be a good

1363
00:48:06,640 --> 00:48:08,240
estimate of

1364
00:48:08,240 --> 00:48:10,480
it can be used as an estimate of x which

1365
00:48:10,480 --> 00:48:11,920
typically means that it's its

1366
00:48:11,920 --> 00:48:13,839
expectation is equal to x and has a low

1367
00:48:13,839 --> 00:48:16,160
variance but basically it can it can be

1368
00:48:16,160 --> 00:48:18,480
used to estimate x

1369
00:48:18,480 --> 00:48:21,119
and more importantly the secret sharing

1370
00:48:21,119 --> 00:48:24,640
property is that each share individually

1371
00:48:24,640 --> 00:48:26,720
is information theoretically secure

1372
00:48:26,720 --> 00:48:29,119
maybe one way to to formulate it it has

1373
00:48:29,119 --> 00:48:31,839
zero differential privacy basically uh

1374
00:48:31,839 --> 00:48:34,480
the output distribution on on each of

1375
00:48:34,480 --> 00:48:36,400
those shares and individuals is fixed

1376
00:48:36,400 --> 00:48:39,359
and independent of the input

1377
00:48:39,359 --> 00:48:41,598
yes

1378
00:48:44,720 --> 00:48:46,240
right

1379
00:48:46,240 --> 00:48:48,720
you you could relax these two

1380
00:48:48,720 --> 00:48:50,400
uh so first of all the question is is

1381
00:48:50,400 --> 00:48:52,160
this is this the information uh

1382
00:48:52,160 --> 00:48:53,839
theoretic security

1383
00:48:53,839 --> 00:48:56,400
uh yes it is possible to relax and get

1384
00:48:56,400 --> 00:48:58,720
better guarantees if you relax for

1385
00:48:58,720 --> 00:49:01,040
example this um

1386
00:49:01,040 --> 00:49:02,400
zero differential privacy with some kind

1387
00:49:02,400 --> 00:49:03,599
of computational

1388
00:49:03,599 --> 00:49:05,119
uh security

1389
00:49:05,119 --> 00:49:06,800
uh and

1390
00:49:06,800 --> 00:49:10,400
we have results that uh that do this but

1391
00:49:10,400 --> 00:49:11,760
for simplicity let me start with this

1392
00:49:11,760 --> 00:49:12,960
definition

1393
00:49:12,960 --> 00:49:15,200
uh and for this particular definition we

1394
00:49:15,200 --> 00:49:17,200
show the following result

1395
00:49:17,200 --> 00:49:19,520
is that there exists

1396
00:49:19,520 --> 00:49:20,319
uh

1397
00:49:20,319 --> 00:49:22,400
a private frequency estimator

1398
00:49:22,400 --> 00:49:24,240
uh basically a randomizer for private

1399
00:49:24,240 --> 00:49:26,240
frequency estimation

1400
00:49:26,240 --> 00:49:27,280
which

1401
00:49:27,280 --> 00:49:29,680
communicates

1402
00:49:29,680 --> 00:49:31,119
this uh

1403
00:49:31,119 --> 00:49:33,359
e to the epsilon uh

1404
00:49:33,359 --> 00:49:35,520
uh times log

1405
00:49:35,520 --> 00:49:39,359
two q bits where q is is basically

1406
00:49:39,359 --> 00:49:41,599
um it's a kind of it's not it's a

1407
00:49:41,599 --> 00:49:43,839
security parameter for the aggregation

1408
00:49:43,839 --> 00:49:46,079
server we basically will be doing more

1409
00:49:46,079 --> 00:49:48,559
addition modulo queue and maybe some

1410
00:49:48,559 --> 00:49:50,400
potentially additional verifications

1411
00:49:50,400 --> 00:49:52,640
step making sure that uh that both

1412
00:49:52,640 --> 00:49:53,680
servers have

1413
00:49:53,680 --> 00:49:55,280
obtained the same share

1414
00:49:55,280 --> 00:49:56,800
so there's an additional parameter it's

1415
00:49:56,800 --> 00:49:59,280
not large it's uh but the point is that

1416
00:49:59,280 --> 00:50:00,559
the number of

1417
00:50:00,559 --> 00:50:02,480
bits we'll be sending

1418
00:50:02,480 --> 00:50:04,880
is domain independent it scales as e to

1419
00:50:04,880 --> 00:50:07,599
the epsilon times uh look uh q

1420
00:50:07,599 --> 00:50:09,440
uh and uh

1421
00:50:09,440 --> 00:50:11,200
for comparison

1422
00:50:11,200 --> 00:50:13,119
in the single server setting we could do

1423
00:50:13,119 --> 00:50:15,760
with just away with just epsilon bits i

1424
00:50:15,760 --> 00:50:18,319
should maybe know know that if we

1425
00:50:18,319 --> 00:50:20,880
are willing to

1426
00:50:20,880 --> 00:50:22,960
relax the information theoretic security

1427
00:50:22,960 --> 00:50:23,760
to

1428
00:50:23,760 --> 00:50:25,920
computational security cryptographic

1429
00:50:25,920 --> 00:50:28,800
security then we can also achieve

1430
00:50:28,800 --> 00:50:32,000
epsilon times log to few bits where some

1431
00:50:32,000 --> 00:50:35,359
via somewhat more involved scheme

1432
00:50:35,359 --> 00:50:37,359
so and uh

1433
00:50:37,359 --> 00:50:38,880
again i don't have much time to tell you

1434
00:50:38,880 --> 00:50:40,800
about this algorithm but basically it's

1435
00:50:40,800 --> 00:50:43,520
based on a public coin version of this

1436
00:50:43,520 --> 00:50:45,440
pie report algorithm that i've described

1437
00:50:45,440 --> 00:50:46,319
uh

1438
00:50:46,319 --> 00:50:48,880
pairwise independent rapport

1439
00:50:48,880 --> 00:50:51,359
and what we do is we okay we have a

1440
00:50:51,359 --> 00:50:53,119
public point part which we can kind of

1441
00:50:53,119 --> 00:50:54,400
just um

1442
00:50:54,400 --> 00:50:56,559
send with every message but there is a

1443
00:50:56,559 --> 00:50:59,760
secret uh not basically uh

1444
00:50:59,760 --> 00:51:01,680
the regular message not the one which is

1445
00:51:01,680 --> 00:51:03,119
uses public coins

1446
00:51:03,119 --> 00:51:05,280
uh will send by secret sharing its

1447
00:51:05,280 --> 00:51:07,520
indicator vector that uh because it has

1448
00:51:07,520 --> 00:51:09,920
very short length just epsilon bits we

1449
00:51:09,920 --> 00:51:11,359
can secret share

1450
00:51:11,359 --> 00:51:13,200
an indicator vector we an indicator

1451
00:51:13,200 --> 00:51:14,800
vector is very easy to secret share it's

1452
00:51:14,800 --> 00:51:16,640
just a standard

1453
00:51:16,640 --> 00:51:17,520
uh

1454
00:51:17,520 --> 00:51:20,240
kind of modular secret sharing

1455
00:51:20,240 --> 00:51:22,640
uh and just this algorithm will will

1456
00:51:22,640 --> 00:51:24,000
give us uh

1457
00:51:24,000 --> 00:51:26,319
uh the guarantees that we have promised

1458
00:51:26,319 --> 00:51:28,559
and that's which in practice

1459
00:51:28,559 --> 00:51:30,480
create huge savings in in terms of the

1460
00:51:30,480 --> 00:51:32,559
communication length over the naive uh

1461
00:51:32,559 --> 00:51:34,240
scheme

1462
00:51:34,240 --> 00:51:35,920
uh that's all that i have to say about

1463
00:51:35,920 --> 00:51:37,920
this result let me briefly

1464
00:51:37,920 --> 00:51:40,800
summarize a bit so first of all uh uh

1465
00:51:40,800 --> 00:51:42,000
the main result that i mentioned is

1466
00:51:42,000 --> 00:51:43,599
local differentially private

1467
00:51:43,599 --> 00:51:46,400
privacy by itself implies uh existence

1468
00:51:46,400 --> 00:51:48,079
of low communication protocols with the

1469
00:51:48,079 --> 00:51:49,920
same guarantees it shouldn't be too

1470
00:51:49,920 --> 00:51:52,960
surprising but uh it is still not

1471
00:51:52,960 --> 00:51:54,800
it still takes some effort to actually

1472
00:51:54,800 --> 00:51:57,440
exploit this property in the right way

1473
00:51:57,440 --> 00:51:59,760
uh to preserve both privacy and utility

1474
00:51:59,760 --> 00:52:01,359
and that's what we show

1475
00:52:01,359 --> 00:52:03,680
i've showed that this has a variety of

1476
00:52:03,680 --> 00:52:05,760
very nice applications for some

1477
00:52:05,760 --> 00:52:07,359
fundamental problems such as frequency

1478
00:52:07,359 --> 00:52:10,559
estimation and mean estimation

1479
00:52:10,559 --> 00:52:12,160
there is a

1480
00:52:12,160 --> 00:52:13,920
large number of

1481
00:52:13,920 --> 00:52:15,680
open problems

1482
00:52:15,680 --> 00:52:17,839
even if some problems are open even if

1483
00:52:17,839 --> 00:52:18,960
one

1484
00:52:18,960 --> 00:52:20,880
wasn't requiring this optimal trade-off

1485
00:52:20,880 --> 00:52:22,880
between privacy and accuracy

1486
00:52:22,880 --> 00:52:24,319
even though we do prefer to get this

1487
00:52:24,319 --> 00:52:26,720
optimal trade-off but

1488
00:52:26,720 --> 00:52:30,319
let me mention just a couple uh so one

1489
00:52:30,319 --> 00:52:31,920
is that she is finding this faster

1490
00:52:31,920 --> 00:52:33,760
algorithm for mean estimation which it

1491
00:52:33,760 --> 00:52:35,839
has this optimal accuracy and at the

1492
00:52:35,839 --> 00:52:37,920
same time has low communication such as

1493
00:52:37,920 --> 00:52:40,480
being polynomial in epsilon and log d

1494
00:52:40,480 --> 00:52:42,880
low client running time we want to only

1495
00:52:42,880 --> 00:52:44,640
pay off the time

1496
00:52:44,640 --> 00:52:47,200
on each client and low server processing

1497
00:52:47,200 --> 00:52:49,200
ideally we want to something that scales

1498
00:52:49,200 --> 00:52:52,480
as n plus d not n times d

1499
00:52:52,480 --> 00:52:54,960
and there are many more open problems in

1500
00:52:54,960 --> 00:52:57,920
the secret shared version there even for

1501
00:52:57,920 --> 00:53:01,599
frequency estimation we

1502
00:53:01,599 --> 00:53:03,200
the question of whether one can achieve

1503
00:53:03,200 --> 00:53:05,040
both epsilon bits

1504
00:53:05,040 --> 00:53:06,880
uh with information to get threaded

1505
00:53:06,880 --> 00:53:08,960
security is open and for mean estimation

1506
00:53:08,960 --> 00:53:11,680
there almost everything is open

1507
00:53:11,680 --> 00:53:12,480
uh

1508
00:53:12,480 --> 00:53:13,839
certainly for at least for optimal

1509
00:53:13,839 --> 00:53:15,359
accuracy and suboptimal you can you can

1510
00:53:15,359 --> 00:53:16,640
get with secret sharing and low

1511
00:53:16,640 --> 00:53:17,920
communication

1512
00:53:17,920 --> 00:53:19,440
uh that's all that i have to say thank

1513
00:53:19,440 --> 00:53:20,559
you very much let me know if you have

1514
00:53:20,559 --> 00:53:23,800
any questions

1515
00:53:28,240 --> 00:53:29,359
some reason

1516
00:53:29,359 --> 00:53:32,640
the last slide this wasn't sure

1517
00:53:33,040 --> 00:53:35,040
do you have any questions

1518
00:53:35,040 --> 00:53:38,040
yeah

1519
00:53:48,720 --> 00:53:50,959
oh

1520
00:53:51,359 --> 00:53:56,040
good good good question so for um

1521
00:53:56,480 --> 00:53:58,000
so the question is can we if i

1522
00:53:58,000 --> 00:54:00,640
understand correctly whether we can just

1523
00:54:00,640 --> 00:54:02,160
use a

1524
00:54:02,160 --> 00:54:04,559
original local randomizer and secret

1525
00:54:04,559 --> 00:54:07,599
share its output

1526
00:54:08,000 --> 00:54:09,599
so

1527
00:54:09,599 --> 00:54:10,720
for the

1528
00:54:10,720 --> 00:54:12,800
high communication randomizer such as

1529
00:54:12,800 --> 00:54:15,200
the one in the original rap4 which says

1530
00:54:15,200 --> 00:54:18,319
this sends this uh bit vector it that

1531
00:54:18,319 --> 00:54:20,240
one is easy to secret share we could

1532
00:54:20,240 --> 00:54:21,760
just uh

1533
00:54:21,760 --> 00:54:23,599
we can secret share and

1534
00:54:23,599 --> 00:54:25,280
but the problem is that it will have

1535
00:54:25,280 --> 00:54:27,040
high communication

1536
00:54:27,040 --> 00:54:28,880
for the one that i've described and all

1537
00:54:28,880 --> 00:54:31,599
the ones that i know for local uh uh

1538
00:54:31,599 --> 00:54:33,119
for example the one we

1539
00:54:33,119 --> 00:54:35,680
the one we get in the pyrapore

1540
00:54:35,680 --> 00:54:38,079
we can no longer there is the mapping

1541
00:54:38,079 --> 00:54:39,520
between

1542
00:54:39,520 --> 00:54:42,000
the message that we send

1543
00:54:42,000 --> 00:54:44,960
and it's decoding is non-linear so we

1544
00:54:44,960 --> 00:54:47,839
cannot directly secret share this uh

1545
00:54:47,839 --> 00:54:49,440
this description so we are sending a

1546
00:54:49,440 --> 00:54:50,839
description of pairwise independent

1547
00:54:50,839 --> 00:54:54,240
string by having its number of

1548
00:54:54,240 --> 00:54:56,640
sending its coordinate in this uh

1549
00:54:56,640 --> 00:54:59,440
vector field uh over uh over

1550
00:54:59,440 --> 00:55:01,599
vector space over finite field

1551
00:55:01,599 --> 00:55:04,000
and that one yeah if you like it doesn't

1552
00:55:04,000 --> 00:55:05,280
have this homomorphic property if you

1553
00:55:05,280 --> 00:55:08,319
just secret share that value it will not

1554
00:55:08,319 --> 00:55:09,760
give you anything

1555
00:55:09,760 --> 00:55:10,960
what we

1556
00:55:10,960 --> 00:55:13,040
do is we show that big part of that

1557
00:55:13,040 --> 00:55:15,119
message is actually could be sent

1558
00:55:15,119 --> 00:55:17,520
as public randomness and only a one

1559
00:55:17,520 --> 00:55:21,040
single field element needs to be sent uh

1560
00:55:21,040 --> 00:55:23,119
is kind of data dependent and then we

1561
00:55:23,119 --> 00:55:26,000
secret share an indicator vector for

1562
00:55:26,000 --> 00:55:29,280
that element and then we get sort of

1563
00:55:29,280 --> 00:55:30,319
um

1564
00:55:30,319 --> 00:55:32,000
this homomorphic property that we need

1565
00:55:32,000 --> 00:55:32,799
for

1566
00:55:32,799 --> 00:55:34,000
for this but but that's a very good

1567
00:55:34,000 --> 00:55:35,440
question yeah naive

1568
00:55:35,440 --> 00:55:36,960
there's a reason we need to do this and

1569
00:55:36,960 --> 00:55:39,839
it's because the just directly

1570
00:55:39,839 --> 00:55:41,760
to grid sharing standard randomizers

1571
00:55:41,760 --> 00:55:43,119
will give you either

1572
00:55:43,119 --> 00:55:46,079
uh will give you high communication

1573
00:55:46,079 --> 00:55:49,079
yes

1574
00:55:54,480 --> 00:55:55,839
uh

1575
00:55:55,839 --> 00:55:57,040
that is

1576
00:55:57,040 --> 00:55:59,440
a paper at this point uh and i don't

1577
00:55:59,440 --> 00:56:01,280
think i can comment much more beyond

1578
00:56:01,280 --> 00:56:03,839
that

1579
00:56:18,880 --> 00:56:21,359
yeah very very good question

1580
00:56:21,359 --> 00:56:23,440
again i cannot say how it's justified

1581
00:56:23,440 --> 00:56:27,760
apple but one natural way is to have a

1582
00:56:27,760 --> 00:56:30,559
a different party uh

1583
00:56:30,559 --> 00:56:32,000
basically different company like google

1584
00:56:32,000 --> 00:56:35,920
providing that service just as a

1585
00:56:35,920 --> 00:56:37,920
just in the same way as all like many

1586
00:56:37,920 --> 00:56:40,000
companies use cloud services of other

1587
00:56:40,000 --> 00:56:42,319
companies for example

1588
00:56:42,319 --> 00:56:44,319
company a might be relying on another

1589
00:56:44,319 --> 00:56:47,520
company a or company g to use

1590
00:56:47,520 --> 00:56:48,319
uh

1591
00:56:48,319 --> 00:56:50,960
to use uh to provided services and in

1592
00:56:50,960 --> 00:56:52,480
the same way they can

1593
00:56:52,480 --> 00:56:54,400
uh pay for service which will do this

1594
00:56:54,400 --> 00:56:56,480
aggregation and then and in this way

1595
00:56:56,480 --> 00:56:59,760
ensure non-collusion but in general

1596
00:56:59,760 --> 00:57:01,440
i mean this is the kind of yeah this is

1597
00:57:01,440 --> 00:57:03,839
a universal problem for for secret

1598
00:57:03,839 --> 00:57:04,880
sharing

1599
00:57:04,880 --> 00:57:07,200
uh in general and and then people have

1600
00:57:07,200 --> 00:57:08,880
ways to deal with it and maybe i should

1601
00:57:08,880 --> 00:57:09,839
be asking

1602
00:57:09,839 --> 00:57:11,599
others here how to best

1603
00:57:11,599 --> 00:57:13,760
do it but it

1604
00:57:13,760 --> 00:57:17,200
is a solvable problem

1605
00:57:17,200 --> 00:57:20,439
thank you

1606
00:57:34,799 --> 00:57:37,280
uh yeah so the question is do we get the

1607
00:57:37,280 --> 00:57:39,599
central guarantees yes in a way what we

1608
00:57:39,599 --> 00:57:41,680
get is we call we one way to call this

1609
00:57:41,680 --> 00:57:44,799
private simplification but yes if we can

1610
00:57:44,799 --> 00:57:47,520
from the point of view of the server

1611
00:57:47,520 --> 00:57:49,599
or that only observes

1612
00:57:49,599 --> 00:57:52,079
the sum or aggregate

1613
00:57:52,079 --> 00:57:54,480
uh we get uh

1614
00:57:54,480 --> 00:57:55,839
sort of asymptotically the same

1615
00:57:55,839 --> 00:57:57,760
guarantees as one would get with central

1616
00:57:57,760 --> 00:57:59,680
privacy so basically

1617
00:57:59,680 --> 00:58:03,440
uh yes aggregation allows us to uh

1618
00:58:03,440 --> 00:58:05,119
get to this um

1619
00:58:05,119 --> 00:58:08,119
central

1620
00:58:08,799 --> 00:58:11,040
central dp tradeoff between privacy and

1621
00:58:11,040 --> 00:58:15,359
utility or at least very close to it

1622
00:58:16,480 --> 00:58:19,280
great question thank you

1623
00:58:21,440 --> 00:58:23,119
okay

1624
00:58:23,119 --> 00:58:25,839
i have a final question to ask you yes

1625
00:58:25,839 --> 00:58:28,559
so you're using the secret sanger pros

1626
00:58:28,559 --> 00:58:30,319
if you use the sample model will you

1627
00:58:30,319 --> 00:58:32,720
have some better like

1628
00:58:32,720 --> 00:58:35,119
implications or can it be applicable

1629
00:58:35,119 --> 00:58:38,160
instead of using the secretary so

1630
00:58:38,160 --> 00:58:41,680
um shuffle model um

1631
00:58:41,680 --> 00:58:43,760
would give us strictly weaker guarantees

1632
00:58:43,760 --> 00:58:46,160
because naturally the aggregate

1633
00:58:46,160 --> 00:58:47,599
the aggregate can always be computed

1634
00:58:47,599 --> 00:58:48,960
from shuffling

1635
00:58:48,960 --> 00:58:49,920
like like

1636
00:58:49,920 --> 00:58:51,680
so strictly speaking aggregation always

1637
00:58:51,680 --> 00:58:54,799
has less information but for some

1638
00:58:54,799 --> 00:58:56,319
problems in for example this frequency

1639
00:58:56,319 --> 00:58:57,680
estimation

1640
00:58:57,680 --> 00:58:59,680
uh the difference is not that large

1641
00:58:59,680 --> 00:59:00,720
basically

1642
00:59:00,720 --> 00:59:02,240
essentially the same thing that one

1643
00:59:02,240 --> 00:59:04,240
would get shuffling would already give

1644
00:59:04,240 --> 00:59:04,960
is

1645
00:59:04,960 --> 00:59:06,720
already the same pretty much the same

1646
00:59:06,720 --> 00:59:10,000
guarantees as aggregation so aggregation

1647
00:59:10,000 --> 00:59:11,359
is

1648
00:59:11,359 --> 00:59:13,119
somewhat easier to analyze especially

1649
00:59:13,119 --> 00:59:14,799
for some types of noise there's a

1650
00:59:14,799 --> 00:59:16,559
gaussian noise aggregates very nicely

1651
00:59:16,559 --> 00:59:19,839
into another gaussian noise

1652
00:59:19,920 --> 00:59:22,079
but

1653
00:59:22,720 --> 00:59:24,400
some of these some many of the same

1654
00:59:24,400 --> 00:59:26,079
things can be already achieved just by

1655
00:59:26,079 --> 00:59:27,359
shuffling

1656
00:59:27,359 --> 00:59:29,920
and also again yeah you you also get the

1657
00:59:29,920 --> 00:59:32,319
same type of currency that as long as

1658
00:59:32,319 --> 00:59:35,040
the shuffler does not collude

1659
00:59:35,040 --> 00:59:36,559
uh or at least one of the shufflers you

1660
00:59:36,559 --> 00:59:38,240
can send through many shufflers as long

1661
00:59:38,240 --> 00:59:40,000
as one of the shufflers does not collude

1662
00:59:40,000 --> 00:59:40,880
with the

1663
00:59:40,880 --> 00:59:42,640
with the server will get the privacy

1664
00:59:42,640 --> 00:59:44,240
amplification

1665
00:59:44,240 --> 00:59:47,680
thank you thank you very much thank you

1666
00:59:48,160 --> 00:59:51,879
yes one more question

1667
01:00:05,760 --> 01:00:06,880
uh

1668
01:00:06,880 --> 01:00:07,920
so

1669
01:00:07,920 --> 01:00:09,920
uh very good question does the

1670
01:00:09,920 --> 01:00:11,440
aggregation require

1671
01:00:11,440 --> 01:00:14,160
kind of users who are non-malicious

1672
01:00:14,160 --> 01:00:17,119
themselves that actually depends on on

1673
01:00:17,119 --> 01:00:18,640
on the implementation and there

1674
01:00:18,640 --> 01:00:21,359
certainly are systems like brio by uh

1675
01:00:21,359 --> 01:00:24,799
corigan gibson bonnet that have built-in

1676
01:00:24,799 --> 01:00:25,680
checks

1677
01:00:25,680 --> 01:00:27,680
for making sure that

1678
01:00:27,680 --> 01:00:29,839
we get secret shares

1679
01:00:29,839 --> 01:00:31,839
and they're all within a good the right

1680
01:00:31,839 --> 01:00:34,000
range so that they don't mess up the the

1681
01:00:34,000 --> 01:00:35,440
calculation too much if you send

1682
01:00:35,440 --> 01:00:37,760
something wrong so basically aggregation

1683
01:00:37,760 --> 01:00:39,920
has to be implemented in a clever way

1684
01:00:39,920 --> 01:00:42,480
and again people here know more about it

1685
01:00:42,480 --> 01:00:44,079
i imagine than i do

1686
01:00:44,079 --> 01:00:46,480
but it is possible to build uh build in

1687
01:00:46,480 --> 01:00:48,079
these checks uh

1688
01:00:48,079 --> 01:00:50,400
to make sure that malicious users

1689
01:00:50,400 --> 01:00:53,040
cannot affect the result much even

1690
01:00:53,040 --> 01:00:55,119
though naively implementing just not

1691
01:00:55,119 --> 01:00:56,400
doing any checks

1692
01:00:56,400 --> 01:00:58,720
is obviously very error prone like you

1693
01:00:58,720 --> 01:01:00,880
could would otherwise be able to mess up

1694
01:01:00,880 --> 01:01:03,920
the system quite easily

1695
01:01:07,680 --> 01:01:09,280
thank you so much thank you thank you

1696
01:01:09,280 --> 01:01:11,839
appreciate it

1697
01:01:33,200 --> 01:01:37,078
we're going to be back at 4pm

1698
01:01:59,520 --> 01:02:01,599
you

