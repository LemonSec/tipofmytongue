1
00:00:21,359 --> 00:00:22,800
okay excellent

2
00:00:22,800 --> 00:00:26,320
so the next contributed talk is is

3
00:00:26,320 --> 00:00:28,400
prior plus privacy preserving aggregate

4
00:00:28,400 --> 00:00:30,400
statistics via boolean shares

5
00:00:30,400 --> 00:00:31,920
this is eli who is going to give the

6
00:00:31,920 --> 00:00:35,760
talk and joint work with is surya kevin

7
00:00:35,760 --> 00:00:37,840
raphael ostroski and antiguani thank you

8
00:00:37,840 --> 00:00:40,160
so much

9
00:00:40,480 --> 00:00:41,520
all right thank you so much for the

10
00:00:41,520 --> 00:00:43,840
introduction um and thank you to all the

11
00:00:43,840 --> 00:00:45,840
organizers uh thanks everybody for being

12
00:00:45,840 --> 00:00:47,600
here really excited to

13
00:00:47,600 --> 00:00:49,680
share this work on prio plus with you

14
00:00:49,680 --> 00:00:51,920
guys

15
00:00:52,640 --> 00:00:54,559
so i'm gonna start off by talking about

16
00:00:54,559 --> 00:00:56,399
prio which a lot of you guys might

17
00:00:56,399 --> 00:00:59,440
already know about but trio

18
00:00:59,440 --> 00:01:01,680
is essentially a system that tries to

19
00:01:01,680 --> 00:01:04,000
compute aggregate statistics privately

20
00:01:04,000 --> 00:01:05,040
like a lot of the stuff we've been

21
00:01:05,040 --> 00:01:06,799
talking about today

22
00:01:06,799 --> 00:01:08,560
so these kinds of aggregate statistics

23
00:01:08,560 --> 00:01:10,320
are really important for lots of

24
00:01:10,320 --> 00:01:11,920
different types of organizations

25
00:01:11,920 --> 00:01:14,240
businesses governments schools

26
00:01:14,240 --> 00:01:16,560
um these are some examples that have

27
00:01:16,560 --> 00:01:19,520
actually come into production uh so prio

28
00:01:19,520 --> 00:01:21,119
was used to

29
00:01:21,119 --> 00:01:23,200
see how they it was used for copic

30
00:01:23,200 --> 00:01:24,880
tracking so the cdc wanted to know how

31
00:01:24,880 --> 00:01:26,880
many people in a particular area had

32
00:01:26,880 --> 00:01:28,960
contracted covid which is obviously very

33
00:01:28,960 --> 00:01:31,280
sensitive information

34
00:01:31,280 --> 00:01:33,920
or it's also in production by mozilla

35
00:01:33,920 --> 00:01:36,000
mozilla wants to know you know how many

36
00:01:36,000 --> 00:01:37,600
people receive cookies from a particular

37
00:01:37,600 --> 00:01:40,000
website but all this information is very

38
00:01:40,000 --> 00:01:42,159
private and so we only want to compute

39
00:01:42,159 --> 00:01:43,840
these aggregate statistics without

40
00:01:43,840 --> 00:01:47,520
seeing any individual user data

41
00:01:48,159 --> 00:01:49,360
a lot of the systems that currently

42
00:01:49,360 --> 00:01:51,840
exist just compute that

43
00:01:51,840 --> 00:01:53,360
in the clear you know

44
00:01:53,360 --> 00:01:55,520
this is what google and mozilla

45
00:01:55,520 --> 00:01:57,920
would do for a long time

46
00:01:57,920 --> 00:01:59,119
so prio

47
00:01:59,119 --> 00:02:00,560
aims to compute these aggregate

48
00:02:00,560 --> 00:02:02,960
statistics efficiently without seeing

49
00:02:02,960 --> 00:02:06,079
any sensitive data

50
00:02:06,560 --> 00:02:10,160
and before prio there were some other uh

51
00:02:10,160 --> 00:02:12,080
works that aimed to

52
00:02:12,080 --> 00:02:13,680
achieve this same goal

53
00:02:13,680 --> 00:02:15,599
so we've seen some examples of this

54
00:02:15,599 --> 00:02:16,959
today there was

55
00:02:16,959 --> 00:02:18,800
randomized response systems which

56
00:02:18,800 --> 00:02:20,000
essentially give you differential

57
00:02:20,000 --> 00:02:22,560
privacy guarantees

58
00:02:22,560 --> 00:02:24,959
the issue with the randomized response

59
00:02:24,959 --> 00:02:27,520
systems is the privacy guarantees are

60
00:02:27,520 --> 00:02:28,879
relatively weak you still learn

61
00:02:28,879 --> 00:02:30,959
something about the client's individual

62
00:02:30,959 --> 00:02:32,640
data

63
00:02:32,640 --> 00:02:34,080
you only get an approximation of the

64
00:02:34,080 --> 00:02:35,599
aggregate statistic and there's a

65
00:02:35,599 --> 00:02:37,519
trade-off between the privacy guarantees

66
00:02:37,519 --> 00:02:40,560
and the accuracy of the approximation

67
00:02:40,560 --> 00:02:42,400
but on the bright side you do get this

68
00:02:42,400 --> 00:02:44,720
kind of robustness property in the sense

69
00:02:44,720 --> 00:02:47,440
that if a client misbehaves and they

70
00:02:47,440 --> 00:02:49,360
want to disrupt the statistic being

71
00:02:49,360 --> 00:02:50,400
computed

72
00:02:50,400 --> 00:02:52,400
they can only affect the statistics by

73
00:02:52,400 --> 00:02:56,080
like at most plus or minus one

74
00:02:56,959 --> 00:02:59,280
and for comparison there's also a long

75
00:02:59,280 --> 00:03:00,720
line of work

76
00:03:00,720 --> 00:03:02,239
using a homomorphic secret sharing

77
00:03:02,239 --> 00:03:05,360
approach and prio essentially builds

78
00:03:05,360 --> 00:03:08,159
upon this type of approach

79
00:03:08,159 --> 00:03:10,480
in this case you take your data you

80
00:03:10,480 --> 00:03:11,760
split it between

81
00:03:11,760 --> 00:03:13,680
a few different servers

82
00:03:13,680 --> 00:03:14,640
and

83
00:03:14,640 --> 00:03:17,200
they add up the different secret shares

84
00:03:17,200 --> 00:03:19,519
and eventually combine these aggregated

85
00:03:19,519 --> 00:03:23,120
shares to get the overall statistic

86
00:03:23,120 --> 00:03:24,080
and

87
00:03:24,080 --> 00:03:26,799
this has very strong privacy guarantees

88
00:03:26,799 --> 00:03:28,239
as long as the servers don't collude

89
00:03:28,239 --> 00:03:30,000
with each other nobody learns anything

90
00:03:30,000 --> 00:03:33,680
about any individual users data

91
00:03:33,680 --> 00:03:35,680
and the main issue is that it is not

92
00:03:35,680 --> 00:03:37,920
robust so because the data is secret

93
00:03:37,920 --> 00:03:38,879
shared

94
00:03:38,879 --> 00:03:41,200
you can't actually tell whether a client

95
00:03:41,200 --> 00:03:42,400
is submitting what they're supposed to

96
00:03:42,400 --> 00:03:45,400
submit

97
00:03:46,000 --> 00:03:49,360
so again prio's main goal is to compute

98
00:03:49,360 --> 00:03:52,080
these aggregate statistics but

99
00:03:52,080 --> 00:03:53,519
with all three of these desirable

100
00:03:53,519 --> 00:03:56,480
properties privacy robustness uh and

101
00:03:56,480 --> 00:04:00,518
scalability or efficiency

102
00:04:01,599 --> 00:04:03,680
so just looking ahead a little bit

103
00:04:03,680 --> 00:04:05,439
because i'm here to talk about prio plus

104
00:04:05,439 --> 00:04:07,120
not just bio

105
00:04:07,120 --> 00:04:08,000
uh

106
00:04:08,000 --> 00:04:10,560
what we aim to do on top of prio

107
00:04:10,560 --> 00:04:11,439
is

108
00:04:11,439 --> 00:04:13,519
essentially to re rethink the efficiency

109
00:04:13,519 --> 00:04:16,320
model so a lot of uh the

110
00:04:16,320 --> 00:04:18,399
goals of prio were based on this

111
00:04:18,399 --> 00:04:20,399
scalability metric

112
00:04:20,399 --> 00:04:22,560
so they wanted to achieve

113
00:04:22,560 --> 00:04:24,720
very low server communication

114
00:04:24,720 --> 00:04:25,919
in order to

115
00:04:25,919 --> 00:04:27,600
compute statistics at the scale of like

116
00:04:27,600 --> 00:04:30,720
millions and billions of pieces of data

117
00:04:30,720 --> 00:04:32,320
um and so

118
00:04:32,320 --> 00:04:33,919
the one downside of this kind of

119
00:04:33,919 --> 00:04:36,080
approach is that you introduce a bit of

120
00:04:36,080 --> 00:04:37,919
a burden on the user

121
00:04:37,919 --> 00:04:40,160
at the expense of increasing the quality

122
00:04:40,160 --> 00:04:43,360
of life for the servers and so our idea

123
00:04:43,360 --> 00:04:45,919
was well for these applications where

124
00:04:45,919 --> 00:04:48,240
the user device is very low powered how

125
00:04:48,240 --> 00:04:51,280
can we rethink this protocol to reduce

126
00:04:51,280 --> 00:04:54,239
that burden on the user

127
00:04:54,400 --> 00:04:56,960
and actually as it turns out

128
00:04:56,960 --> 00:04:58,800
just improving things for the user in a

129
00:04:58,800 --> 00:05:00,479
lot of cases ends up improving the

130
00:05:00,479 --> 00:05:02,639
server side cost as well so we'll see

131
00:05:02,639 --> 00:05:05,360
more of that later

132
00:05:05,840 --> 00:05:06,720
so

133
00:05:06,720 --> 00:05:08,160
what does the desired functionality for

134
00:05:08,160 --> 00:05:10,960
pio look like well each client is going

135
00:05:10,960 --> 00:05:14,639
to hold their own private input

136
00:05:14,639 --> 00:05:17,120
and we want to compute some statistics

137
00:05:17,120 --> 00:05:19,199
some function on the combined inputs of

138
00:05:19,199 --> 00:05:21,600
all the users

139
00:05:21,600 --> 00:05:23,520
and the privacy guarantee should be that

140
00:05:23,520 --> 00:05:26,320
nobody servers clients anybody should

141
00:05:26,320 --> 00:05:28,160
learn anything except for possibly the

142
00:05:28,160 --> 00:05:31,199
output of the statistic

143
00:05:31,199 --> 00:05:32,960
and so in this very basic example each

144
00:05:32,960 --> 00:05:35,120
client is just holding a single bit

145
00:05:35,120 --> 00:05:36,560
and we'd like to compute the sum of the

146
00:05:36,560 --> 00:05:39,560
bits

147
00:05:39,919 --> 00:05:41,360
so what does the security model look

148
00:05:41,360 --> 00:05:42,560
like

149
00:05:42,560 --> 00:05:45,360
we've got n different clients and some

150
00:05:45,360 --> 00:05:47,280
you know up to n minus one of them could

151
00:05:47,280 --> 00:05:51,120
potentially be corrupted maliciously

152
00:05:51,120 --> 00:05:54,400
and we've got some number of servers t

153
00:05:54,400 --> 00:05:55,520
and

154
00:05:55,520 --> 00:05:58,639
we in our case we use t equals two uh

155
00:05:58,639 --> 00:06:01,280
all of our methods can be extended to

156
00:06:01,280 --> 00:06:03,520
multiple servers and prio's methods are

157
00:06:03,520 --> 00:06:05,280
also demonstrated in terms of as many

158
00:06:05,280 --> 00:06:07,360
servers as you want but especially for

159
00:06:07,360 --> 00:06:09,440
pictures two servers makes the most of

160
00:06:09,440 --> 00:06:11,520
it

161
00:06:12,560 --> 00:06:15,120
and these servers uh are going to be

162
00:06:15,120 --> 00:06:16,639
semi-honestly corrupted actually that's

163
00:06:16,639 --> 00:06:18,160
a crucial point

164
00:06:18,160 --> 00:06:19,919
neither prio nor prio plus supports

165
00:06:19,919 --> 00:06:22,319
maliciously corrupted servers uh you can

166
00:06:22,319 --> 00:06:23,600
show that

167
00:06:23,600 --> 00:06:25,360
supporting maliciously corrupted servers

168
00:06:25,360 --> 00:06:27,199
comes at a pretty dramatic

169
00:06:27,199 --> 00:06:29,199
performance decrease so

170
00:06:29,199 --> 00:06:31,120
since you can usually trust servers to

171
00:06:31,120 --> 00:06:34,000
you know servers are run by mozilla or

172
00:06:34,000 --> 00:06:35,680
by they're they're much easier to

173
00:06:35,680 --> 00:06:38,000
maintain so it's much more common to

174
00:06:38,000 --> 00:06:39,360
have malicious clients than malicious

175
00:06:39,360 --> 00:06:40,639
servers

176
00:06:40,639 --> 00:06:42,080
but the security properties again that

177
00:06:42,080 --> 00:06:44,319
we want our privacy and robustness so

178
00:06:44,319 --> 00:06:46,000
clients or servers whoever is receiving

179
00:06:46,000 --> 00:06:48,560
the output should only learn the output

180
00:06:48,560 --> 00:06:50,479
which is the statistic

181
00:06:50,479 --> 00:06:52,720
and any malicious client should not be

182
00:06:52,720 --> 00:06:55,520
able to corrupt the output other than

183
00:06:55,520 --> 00:06:56,960
possibly misreporting their private

184
00:06:56,960 --> 00:06:59,440
value so if a client is supposed to be

185
00:06:59,440 --> 00:07:01,120
holding a zero row one

186
00:07:01,120 --> 00:07:02,720
they might be able to lie about whether

187
00:07:02,720 --> 00:07:04,000
they have a zero when they actually have

188
00:07:04,000 --> 00:07:05,759
a one but that should be the worst thing

189
00:07:05,759 --> 00:07:08,240
they can do

190
00:07:08,960 --> 00:07:10,400
and the core building block is additive

191
00:07:10,400 --> 00:07:12,319
secret sharing so i'm sure most people

192
00:07:12,319 --> 00:07:13,680
here know about additive secret sharing

193
00:07:13,680 --> 00:07:15,520
so i'm gonna go a little bit quickly

194
00:07:15,520 --> 00:07:18,240
but the idea is that the person sending

195
00:07:18,240 --> 00:07:20,400
the data has some private input

196
00:07:20,400 --> 00:07:22,240
and they just come up with two random

197
00:07:22,240 --> 00:07:24,639
values that happen to sum up to their

198
00:07:24,639 --> 00:07:26,720
private input and then they can send one

199
00:07:26,720 --> 00:07:29,280
of each of these shares to a server

200
00:07:29,280 --> 00:07:31,759
and the servers can reconstruct the

201
00:07:31,759 --> 00:07:33,440
private value if they hold all of the

202
00:07:33,440 --> 00:07:34,319
shares

203
00:07:34,319 --> 00:07:36,479
but if you only have any strict subset

204
00:07:36,479 --> 00:07:39,758
of the shares it reveals nothing

205
00:07:41,280 --> 00:07:43,440
and so with just this building block we

206
00:07:43,440 --> 00:07:45,680
can look at a very simple scheme that's

207
00:07:45,680 --> 00:07:46,800
been uh

208
00:07:46,800 --> 00:07:48,879
noted a lot in the literature so this is

209
00:07:48,879 --> 00:07:51,280
what most of the very very basic

210
00:07:51,280 --> 00:07:52,800
homomorphic secret sharing approaches

211
00:07:52,800 --> 00:07:54,160
are built off of

212
00:07:54,160 --> 00:07:56,479
and the idea is that the client takes

213
00:07:56,479 --> 00:07:58,800
their private bit and they secret share

214
00:07:58,800 --> 00:08:02,000
it send one secret share to each server

215
00:08:02,000 --> 00:08:04,160
the servers aggregate all of their

216
00:08:04,160 --> 00:08:06,400
shares that they've received together

217
00:08:06,400 --> 00:08:09,680
and then they publish these aggregates

218
00:08:09,680 --> 00:08:11,280
to either the clients if those are the

219
00:08:11,280 --> 00:08:12,240
ones who are trying to learn the

220
00:08:12,240 --> 00:08:15,120
statistic or to the service provider

221
00:08:15,120 --> 00:08:17,199
and the server for that service provider

222
00:08:17,199 --> 00:08:19,680
can simply add these aggregates together

223
00:08:19,680 --> 00:08:22,000
and recollect the statistic which is in

224
00:08:22,000 --> 00:08:24,080
this case just the thumb

225
00:08:24,080 --> 00:08:25,520
and as long as you're working in a large

226
00:08:25,520 --> 00:08:27,520
enough group this returns the sum

227
00:08:27,520 --> 00:08:30,080
precisely

228
00:08:30,800 --> 00:08:34,559
and so the uh obvious problem with this

229
00:08:34,559 --> 00:08:36,799
simple scheme is that it's not robust so

230
00:08:36,799 --> 00:08:37,839
we don't

231
00:08:37,839 --> 00:08:39,839
get the nice quality that a malicious

232
00:08:39,839 --> 00:08:42,399
client should not be able to

233
00:08:42,399 --> 00:08:45,040
disrupt the statistic being computed

234
00:08:45,040 --> 00:08:47,760
so if if our client chooses a thousand

235
00:08:47,760 --> 00:08:50,800
as their private value instead of a 01

236
00:08:50,800 --> 00:08:52,880
they can just secret share this and none

237
00:08:52,880 --> 00:08:56,640
of the servers will be any wiser

238
00:08:56,640 --> 00:08:57,600
and

239
00:08:57,600 --> 00:08:59,200
imagine you're using this for a voting

240
00:08:59,200 --> 00:09:01,200
scheme this is really bad right because

241
00:09:01,200 --> 00:09:02,800
you can vote a thousand times for your

242
00:09:02,800 --> 00:09:05,439
favorite candidate

243
00:09:07,040 --> 00:09:09,680
so the obvious solution here uh

244
00:09:09,680 --> 00:09:12,880
is to use a zero-knowledge proof and so

245
00:09:12,880 --> 00:09:14,480
you know again this is pretty basic but

246
00:09:14,480 --> 00:09:16,560
a zero-knowledge proof is a protocol

247
00:09:16,560 --> 00:09:18,480
between approver and a verifier

248
00:09:18,480 --> 00:09:20,000
where the prover wants to convince the

249
00:09:20,000 --> 00:09:21,839
verifier that some statement is true so

250
00:09:21,839 --> 00:09:24,240
in this case i want to prove that this

251
00:09:24,240 --> 00:09:26,399
secret shared value is either a zero or

252
00:09:26,399 --> 00:09:27,920
a one

253
00:09:27,920 --> 00:09:30,000
and we want to make sure that it's

254
00:09:30,000 --> 00:09:32,800
correct uh if it actually is a zero or a

255
00:09:32,800 --> 00:09:35,519
one the verifier should be convinced

256
00:09:35,519 --> 00:09:37,200
it should be sound so i shouldn't be

257
00:09:37,200 --> 00:09:38,320
able to convince you of something that's

258
00:09:38,320 --> 00:09:39,600
not true

259
00:09:39,600 --> 00:09:41,279
and the zero knowledge property should

260
00:09:41,279 --> 00:09:43,040
guarantee that you don't learn anything

261
00:09:43,040 --> 00:09:44,959
about my input other than the fact that

262
00:09:44,959 --> 00:09:47,920
it's a zero or one

263
00:09:49,040 --> 00:09:51,279
and so if we just apply this as kind of

264
00:09:51,279 --> 00:09:53,440
a band-aid to the previous protocol

265
00:09:53,440 --> 00:09:55,760
then we can achieve robustness right the

266
00:09:55,760 --> 00:09:58,160
client can prove to each of the servers

267
00:09:58,160 --> 00:10:00,560
that their input is in fact in the right

268
00:10:00,560 --> 00:10:01,600
range

269
00:10:01,600 --> 00:10:03,920
and because of the soundness guarantee

270
00:10:03,920 --> 00:10:05,519
any invalid submission will be caught

271
00:10:05,519 --> 00:10:08,240
with overwhelming probability

272
00:10:08,240 --> 00:10:10,320
so by modifying this scheme in a simple

273
00:10:10,320 --> 00:10:12,720
way we get robustness

274
00:10:12,720 --> 00:10:15,120
uh and so the the real you know interest

275
00:10:15,120 --> 00:10:16,800
people have talked about this solution

276
00:10:16,800 --> 00:10:18,399
before the problem in the past is that

277
00:10:18,399 --> 00:10:20,160
zero knowledge proves heavily impacted

278
00:10:20,160 --> 00:10:21,600
scalability

279
00:10:21,600 --> 00:10:23,519
um and so the process of verifying these

280
00:10:23,519 --> 00:10:25,519
zero knowledge proofs on the server side

281
00:10:25,519 --> 00:10:27,760
would take a lot of communication

282
00:10:27,760 --> 00:10:29,360
and it would essentially prevent you

283
00:10:29,360 --> 00:10:31,360
from doing any kind of applications that

284
00:10:31,360 --> 00:10:34,480
scale with these kinds of uh systems and

285
00:10:34,480 --> 00:10:37,839
so prio their main uh novel contribution

286
00:10:37,839 --> 00:10:39,600
is this new kind of zero-knowledge proof

287
00:10:39,600 --> 00:10:41,839
called a snip it's a secret shared

288
00:10:41,839 --> 00:10:43,519
non-interactive proof

289
00:10:43,519 --> 00:10:46,320
um and i'm i don't un unfortunately i

290
00:10:46,320 --> 00:10:47,519
don't have time to go into the details

291
00:10:47,519 --> 00:10:49,200
they're very interesting um they're

292
00:10:49,200 --> 00:10:50,399
based on

293
00:10:50,399 --> 00:10:52,720
a a type of uh probabilistically

294
00:10:52,720 --> 00:10:54,160
checkable proof

295
00:10:54,160 --> 00:10:54,959
but

296
00:10:54,959 --> 00:10:56,320
the core

297
00:10:56,320 --> 00:10:57,839
property is that the server

298
00:10:57,839 --> 00:10:59,839
communication to verify a snip is

299
00:10:59,839 --> 00:11:01,680
constant regardless of the size of the

300
00:11:01,680 --> 00:11:04,880
input so for you know companies running

301
00:11:04,880 --> 00:11:07,040
very high scale applications of these

302
00:11:07,040 --> 00:11:09,120
private aggregate statistics

303
00:11:09,120 --> 00:11:11,360
they don't have to communicate much

304
00:11:11,360 --> 00:11:13,040
between the servers which is usually the

305
00:11:13,040 --> 00:11:14,640
dominant cost because these servers are

306
00:11:14,640 --> 00:11:16,560
housed in different locations and it

307
00:11:16,560 --> 00:11:19,518
just costs a lot of money

308
00:11:20,480 --> 00:11:21,760
now it would be kind of boring if you

309
00:11:21,760 --> 00:11:24,000
could only compute the sum of zeros and

310
00:11:24,000 --> 00:11:26,240
ones so you can actually use the same

311
00:11:26,240 --> 00:11:28,399
setup to do more complex statistics

312
00:11:28,399 --> 00:11:29,680
by using

313
00:11:29,680 --> 00:11:33,920
affine aggregatable encodings or afds

314
00:11:33,920 --> 00:11:36,640
so the idea is if you

315
00:11:36,640 --> 00:11:38,800
take your input and you encode it in a

316
00:11:38,800 --> 00:11:40,399
particular way

317
00:11:40,399 --> 00:11:43,040
then by summing up these encodings of

318
00:11:43,040 --> 00:11:45,680
the inputs you can actually learn

319
00:11:45,680 --> 00:11:48,399
the statistic that you want to compute

320
00:11:48,399 --> 00:11:49,600
so

321
00:11:49,600 --> 00:11:51,760
a canonical example is variance so if

322
00:11:51,760 --> 00:11:53,200
you want to compute the variance of a

323
00:11:53,200 --> 00:11:56,079
set of data one way you can do this is

324
00:11:56,079 --> 00:11:59,200
you can encode your piece of data x as x

325
00:11:59,200 --> 00:12:02,560
comma x squared as a concatenation

326
00:12:02,560 --> 00:12:05,360
and now if you were to sum up all of

327
00:12:05,360 --> 00:12:06,240
these

328
00:12:06,240 --> 00:12:08,639
encoded values you would be able to use

329
00:12:08,639 --> 00:12:10,240
the sum of the x's and the sum of the x

330
00:12:10,240 --> 00:12:13,040
squareds to compute the

331
00:12:13,040 --> 00:12:15,120
expectation of x squared the expectation

332
00:12:15,120 --> 00:12:17,519
of x and compute the variance by taking

333
00:12:17,519 --> 00:12:19,279
the difference

334
00:12:19,279 --> 00:12:20,399
and so

335
00:12:20,399 --> 00:12:22,160
a lot of you know

336
00:12:22,160 --> 00:12:23,680
different statistics can be computed in

337
00:12:23,680 --> 00:12:24,639
this way

338
00:12:24,639 --> 00:12:26,480
uh the statistics supported by prio as

339
00:12:26,480 --> 00:12:28,399
well as prio plus include

340
00:12:28,399 --> 00:12:30,320
variance uh you can even do linear

341
00:12:30,320 --> 00:12:32,240
regression like this that's one of the

342
00:12:32,240 --> 00:12:34,560
cooler properties but

343
00:12:34,560 --> 00:12:37,519
and or maximum minimum

344
00:12:37,519 --> 00:12:40,399
lots of different things

345
00:12:41,600 --> 00:12:43,040
and so again

346
00:12:43,040 --> 00:12:44,880
when we analyze the pros and cons of

347
00:12:44,880 --> 00:12:46,800
pre-owned they are able to achieve

348
00:12:46,800 --> 00:12:48,480
extremely low server communication

349
00:12:48,480 --> 00:12:51,120
constant server communication which is

350
00:12:51,120 --> 00:12:54,240
very nice in a lot of different settings

351
00:12:54,240 --> 00:12:56,480
and but the issue is that on the client

352
00:12:56,480 --> 00:12:58,639
side when they generate these snips

353
00:12:58,639 --> 00:13:00,320
these zero knowledge proofs

354
00:13:00,320 --> 00:13:03,920
the proof size is linear in the size of

355
00:13:03,920 --> 00:13:06,079
your input so if you're you know the

356
00:13:06,079 --> 00:13:07,680
larger your input gets the larger this

357
00:13:07,680 --> 00:13:09,360
proof gets and so the communication

358
00:13:09,360 --> 00:13:10,720
between the client and the servers can

359
00:13:10,720 --> 00:13:12,880
get a bit high

360
00:13:12,880 --> 00:13:14,079
especially when you're using these more

361
00:13:14,079 --> 00:13:15,839
complex encoding

362
00:13:15,839 --> 00:13:17,680
and the client computation to produce

363
00:13:17,680 --> 00:13:18,399
the

364
00:13:18,399 --> 00:13:21,279
proofs is like n log n where n is the

365
00:13:21,279 --> 00:13:23,360
size of the input

366
00:13:23,360 --> 00:13:25,040
so a lot of extra burden is going on the

367
00:13:25,040 --> 00:13:26,639
client to achieve these low server

368
00:13:26,639 --> 00:13:29,519
communication costs

369
00:13:30,480 --> 00:13:32,399
okay so now to talk a little bit more

370
00:13:32,399 --> 00:13:35,839
about preo plus our core idea is

371
00:13:35,839 --> 00:13:38,000
rethinking the efficiency model

372
00:13:38,000 --> 00:13:38,880
so

373
00:13:38,880 --> 00:13:40,959
the original efficiency model is okay we

374
00:13:40,959 --> 00:13:43,360
want to do this at scale with billions

375
00:13:43,360 --> 00:13:45,760
of inputs and so we really need to focus

376
00:13:45,760 --> 00:13:48,399
on minimizing server communication

377
00:13:48,399 --> 00:13:49,279
but

378
00:13:49,279 --> 00:13:51,600
there's a lot of application scenarios

379
00:13:51,600 --> 00:13:52,399
where

380
00:13:52,399 --> 00:13:54,160
maybe communication between the servers

381
00:13:54,160 --> 00:13:56,880
isn't that expensive or maybe you're not

382
00:13:56,880 --> 00:13:59,680
doing it on billions of inputs

383
00:13:59,680 --> 00:14:00,399
but

384
00:14:00,399 --> 00:14:02,079
the devices that you're collecting data

385
00:14:02,079 --> 00:14:04,800
from are actually very weak

386
00:14:04,800 --> 00:14:07,360
uh so especially in the iot setting in

387
00:14:07,360 --> 00:14:09,279
the mobile device setting like i think

388
00:14:09,279 --> 00:14:12,800
heart monitors think parking meters um

389
00:14:12,800 --> 00:14:14,160
you don't have a lot of computational

390
00:14:14,160 --> 00:14:15,760
bandwidth to work with

391
00:14:15,760 --> 00:14:17,600
and so in these kinds of settings how

392
00:14:17,600 --> 00:14:21,440
can we still use the benefits of prio to

393
00:14:21,440 --> 00:14:22,880
collect statistics in a privacy

394
00:14:22,880 --> 00:14:24,160
deserving way

395
00:14:24,160 --> 00:14:25,519
while minimizing the burden on the

396
00:14:25,519 --> 00:14:26,880
client

397
00:14:26,880 --> 00:14:28,560
so that's the main goal that we're

398
00:14:28,560 --> 00:14:31,839
trying to achieve with pureplus

399
00:14:32,560 --> 00:14:34,720
and the core

400
00:14:34,720 --> 00:14:37,120
observation that we use to achieve this

401
00:14:37,120 --> 00:14:38,880
is essentially

402
00:14:38,880 --> 00:14:40,480
trying to reduce the

403
00:14:40,480 --> 00:14:43,040
reliance on zero-knowledge proofs

404
00:14:43,040 --> 00:14:44,959
and so when you actually dig into the

405
00:14:44,959 --> 00:14:47,680
details of how these affine

406
00:14:47,680 --> 00:14:49,680
aggregateable encodings work

407
00:14:49,680 --> 00:14:52,399
uh and what prio is actually proving

408
00:14:52,399 --> 00:14:54,240
with these zero knowledge proofs you

409
00:14:54,240 --> 00:14:57,199
find that a very large portion of the

410
00:14:57,199 --> 00:15:00,320
work is just proving that your input is

411
00:15:00,320 --> 00:15:01,680
the right length

412
00:15:01,680 --> 00:15:04,240
so for some for example the example that

413
00:15:04,240 --> 00:15:05,680
we gave at the beginning

414
00:15:05,680 --> 00:15:07,120
all you're trying to prove is that your

415
00:15:07,120 --> 00:15:10,160
input is either a zero or a one

416
00:15:10,160 --> 00:15:12,079
and you could extend this to a more

417
00:15:12,079 --> 00:15:13,600
general case you know i want to prove my

418
00:15:13,600 --> 00:15:16,160
input is a 8-bit integer or a 16-bit

419
00:15:16,160 --> 00:15:18,160
integer

420
00:15:18,160 --> 00:15:19,440
and so

421
00:15:19,440 --> 00:15:21,199
if all you're trying to do is prove that

422
00:15:21,199 --> 00:15:23,440
your input is some boolean vector of the

423
00:15:23,440 --> 00:15:24,639
right length

424
00:15:24,639 --> 00:15:26,560
uh there's actually a much simpler

425
00:15:26,560 --> 00:15:28,959
method to do this and the key is to use

426
00:15:28,959 --> 00:15:30,320
boolean secret sharing instead of

427
00:15:30,320 --> 00:15:32,240
additive secret sharing or instead of

428
00:15:32,240 --> 00:15:35,040
arithmetic secret sharing i should say

429
00:15:35,040 --> 00:15:36,720
uh so boolean secret sharing is very

430
00:15:36,720 --> 00:15:39,040
similar to arithmetic secret sharing

431
00:15:39,040 --> 00:15:42,240
except you're sharing uh over the domain

432
00:15:42,240 --> 00:15:43,759
of binary strings

433
00:15:43,759 --> 00:15:46,880
and instead of normal addition modulo p

434
00:15:46,880 --> 00:15:49,120
you're using bitwise xor

435
00:15:49,120 --> 00:15:51,440
so in this example on the right you

436
00:15:51,440 --> 00:15:53,199
start off with the

437
00:15:53,199 --> 00:15:56,560
string 1 0 1 1 0 1 and if you take a

438
00:15:56,560 --> 00:15:58,720
close look at these examples taking the

439
00:15:58,720 --> 00:16:02,800
component wise xor gives you the

440
00:16:02,800 --> 00:16:04,959
same result

441
00:16:04,959 --> 00:16:06,560
and so

442
00:16:06,560 --> 00:16:08,160
the cool observation is that if we do

443
00:16:08,160 --> 00:16:10,560
our secret sharing like this then

444
00:16:10,560 --> 00:16:12,560
the work on the server side to verify

445
00:16:12,560 --> 00:16:14,959
that an input is the proper length is

446
00:16:14,959 --> 00:16:17,600
essentially trivial if you get two

447
00:16:17,600 --> 00:16:19,680
shares which are each a single bit

448
00:16:19,680 --> 00:16:21,519
then you know that recombining them will

449
00:16:21,519 --> 00:16:24,320
give you an input which is a single bit

450
00:16:24,320 --> 00:16:25,440
so

451
00:16:25,440 --> 00:16:27,040
for all of these cases where all you

452
00:16:27,040 --> 00:16:28,320
need to do is check the bit length of

453
00:16:28,320 --> 00:16:29,600
the input

454
00:16:29,600 --> 00:16:31,360
there's no proof and there's essentially

455
00:16:31,360 --> 00:16:33,519
no verification it's like

456
00:16:33,519 --> 00:16:36,839
local xors

457
00:16:37,440 --> 00:16:38,880
so this is kind of what that would look

458
00:16:38,880 --> 00:16:40,880
like the servers check that an encoding

459
00:16:40,880 --> 00:16:42,720
is valid by just checking the length of

460
00:16:42,720 --> 00:16:44,320
each share making sure it's the right

461
00:16:44,320 --> 00:16:45,680
number of bits

462
00:16:45,680 --> 00:16:48,079
and then if each of the encodings are

463
00:16:48,079 --> 00:16:49,440
the correct length then they know that

464
00:16:49,440 --> 00:16:51,680
the underlying encoded value is the

465
00:16:51,680 --> 00:16:53,120
correct point i should say each of the

466
00:16:53,120 --> 00:16:54,959
shares in the correct line

467
00:16:54,959 --> 00:16:57,040
uh and even if there's other properties

468
00:16:57,040 --> 00:16:58,880
to check of the encoding

469
00:16:58,880 --> 00:17:00,880
um like for some of these you know in

470
00:17:00,880 --> 00:17:02,880
the variance example it's you need to

471
00:17:02,880 --> 00:17:04,720
check that the first part squared equals

472
00:17:04,720 --> 00:17:06,480
the second part

473
00:17:06,480 --> 00:17:08,959
reducing the size of the proof by no

474
00:17:08,959 --> 00:17:10,480
longer checking the bit length actually

475
00:17:10,480 --> 00:17:12,079
leads to pretty dramatic performance

476
00:17:12,079 --> 00:17:14,559
increases

477
00:17:15,280 --> 00:17:18,559
and for some of these cases we need to

478
00:17:18,559 --> 00:17:20,640
perform share conversion because of the

479
00:17:20,640 --> 00:17:22,880
fact that the servers need to do

480
00:17:22,880 --> 00:17:25,280
aggregation and so in the cases where

481
00:17:25,280 --> 00:17:27,439
aggregation is done very via addition

482
00:17:27,439 --> 00:17:28,799
modulo p

483
00:17:28,799 --> 00:17:30,640
you need to actually convert back to

484
00:17:30,640 --> 00:17:32,960
arithmetic shares in order to aggregate

485
00:17:32,960 --> 00:17:35,120
properly but there's actually a lot of

486
00:17:35,120 --> 00:17:38,160
cases so for and or max and min

487
00:17:38,160 --> 00:17:41,280
the aggregation is done via bitwise xor

488
00:17:41,280 --> 00:17:44,000
so no share conversion is necessary you

489
00:17:44,000 --> 00:17:45,919
just collect check the bit length add

490
00:17:45,919 --> 00:17:49,280
them all up and you're done

491
00:17:51,440 --> 00:17:52,240
so

492
00:17:52,240 --> 00:17:53,760
share conversion i'm going to go through

493
00:17:53,760 --> 00:17:55,760
a little bit quickly

494
00:17:55,760 --> 00:17:58,720
but again we only need share conversion

495
00:17:58,720 --> 00:18:00,400
for some of our statistics

496
00:18:00,400 --> 00:18:01,919
and when we do need to do share

497
00:18:01,919 --> 00:18:03,679
conversion we use a form of correlated

498
00:18:03,679 --> 00:18:05,360
randomness called dobits which are

499
00:18:05,360 --> 00:18:07,360
doubly authenticated bits

500
00:18:07,360 --> 00:18:09,679
and uh these are really useful because

501
00:18:09,679 --> 00:18:11,440
they make for an extremely quick online

502
00:18:11,440 --> 00:18:12,880
phase so even though you're spending

503
00:18:12,880 --> 00:18:15,600
some time to generate these dobits

504
00:18:15,600 --> 00:18:18,400
at like 2 a.m you know on off hours you

505
00:18:18,400 --> 00:18:20,640
get this really snappy online phase once

506
00:18:20,640 --> 00:18:23,280
they're generated

507
00:18:23,360 --> 00:18:25,280
so i'll quickly go over some of the

508
00:18:25,280 --> 00:18:26,720
statistics

509
00:18:26,720 --> 00:18:28,960
that we collected uh we have three basic

510
00:18:28,960 --> 00:18:30,559
classes of protocols depending on the

511
00:18:30,559 --> 00:18:32,320
statistic that we're using

512
00:18:32,320 --> 00:18:33,120
so

513
00:18:33,120 --> 00:18:35,679
for statistics like the sum we have to

514
00:18:35,679 --> 00:18:37,679
perform share conversion but we don't

515
00:18:37,679 --> 00:18:40,640
need any snips no zero knowledge proofs

516
00:18:40,640 --> 00:18:43,039
and then the really snappy protocols

517
00:18:43,039 --> 00:18:44,640
that we have require no share conversion

518
00:18:44,640 --> 00:18:47,919
or snips so that's and or max and min

519
00:18:47,919 --> 00:18:50,559
and the heavier protocols require share

520
00:18:50,559 --> 00:18:52,799
conversion and snips which are variants

521
00:18:52,799 --> 00:18:53,919
in linear aggression so i'm going to

522
00:18:53,919 --> 00:18:57,679
show you guys some statistics for one uh

523
00:18:57,679 --> 00:18:59,840
member of each of these classes

524
00:18:59,840 --> 00:19:01,120
so for some

525
00:19:01,120 --> 00:19:02,720
uh

526
00:19:02,720 --> 00:19:05,039
you'll notice that on a lot of these bar

527
00:19:05,039 --> 00:19:07,679
graphs our bar doesn't actually show up

528
00:19:07,679 --> 00:19:09,760
and so it's usually a good sign

529
00:19:09,760 --> 00:19:12,000
but our encode time is like on the order

530
00:19:12,000 --> 00:19:14,240
of thousands of times better than

531
00:19:14,240 --> 00:19:17,760
both implementations of prio

532
00:19:17,840 --> 00:19:19,200
the client message size is also

533
00:19:19,200 --> 00:19:21,039
dramatically reduced

534
00:19:21,039 --> 00:19:23,039
the server compute time is also

535
00:19:23,039 --> 00:19:24,480
dramatically reduced so this is one of

536
00:19:24,480 --> 00:19:26,000
the nice side effects that we weren't

537
00:19:26,000 --> 00:19:27,760
even aiming for

538
00:19:27,760 --> 00:19:29,520
and the

539
00:19:29,520 --> 00:19:31,280
you know expected downside is server

540
00:19:31,280 --> 00:19:32,640
communication because we're no longer

541
00:19:32,640 --> 00:19:34,160
optimizing for that

542
00:19:34,160 --> 00:19:34,880
but

543
00:19:34,880 --> 00:19:36,799
the online communication of our protocol

544
00:19:36,799 --> 00:19:39,440
is actually significantly better

545
00:19:39,440 --> 00:19:40,240
and

546
00:19:40,240 --> 00:19:42,240
it's really thanks to these dobbits this

547
00:19:42,240 --> 00:19:43,679
offline correlated randomness that we're

548
00:19:43,679 --> 00:19:46,480
able to achieve that

549
00:19:46,880 --> 00:19:49,600
computing the maximum is even better i'm

550
00:19:49,600 --> 00:19:51,200
just going to go quickly because i'm

551
00:19:51,200 --> 00:19:53,120
running out of time i'm sure

552
00:19:53,120 --> 00:19:55,520
uh but this is like our one of our best

553
00:19:55,520 --> 00:19:57,280
protocols and even the server

554
00:19:57,280 --> 00:19:59,280
communication is extremely low and

555
00:19:59,280 --> 00:20:00,960
constant

556
00:20:00,960 --> 00:20:03,039
and then linear regression is our more

557
00:20:03,039 --> 00:20:04,640
uh complex one we require share

558
00:20:04,640 --> 00:20:06,480
conversion and snips but

559
00:20:06,480 --> 00:20:09,679
for all of our uh practical experiments

560
00:20:09,679 --> 00:20:11,280
we're still able to

561
00:20:11,280 --> 00:20:13,679
beat or close to be prio in almost all

562
00:20:13,679 --> 00:20:16,240
aspects except for end-to-end server

563
00:20:16,240 --> 00:20:18,320
communication which obviously includes

564
00:20:18,320 --> 00:20:20,159
the time to generate the correlated

565
00:20:20,159 --> 00:20:22,159
random

566
00:20:22,159 --> 00:20:23,840
and

567
00:20:23,840 --> 00:20:25,039
i'm going to skip through this because

568
00:20:25,039 --> 00:20:27,600
we're running out of time and

569
00:20:27,600 --> 00:20:29,679
go straight to

570
00:20:29,679 --> 00:20:32,159
questions

571
00:20:32,480 --> 00:20:36,480
thanks so much alive for the great job

572
00:20:36,960 --> 00:20:39,440
so i would like to ask the next speaker

573
00:20:39,440 --> 00:20:41,039
to come and in the meantime while we set

574
00:20:41,039 --> 00:20:42,720
it up we can take one quick question if

575
00:20:42,720 --> 00:20:45,360
there is any

576
00:20:45,600 --> 00:20:48,600
yes

577
00:20:54,240 --> 00:20:55,600
yeah so the question is how do we do

578
00:20:55,600 --> 00:20:57,840
share conversion and yeah so we're doing

579
00:20:57,840 --> 00:20:59,600
share conversion on boolean shares to

580
00:20:59,600 --> 00:21:01,679
turn them into arithmetic

581
00:21:01,679 --> 00:21:05,120
and essentially this dobbit is a

582
00:21:05,120 --> 00:21:07,440
single bit that's shared in it's a

583
00:21:07,440 --> 00:21:08,960
random bit shared in both the boolean

584
00:21:08,960 --> 00:21:10,799
and arithmetic setting

585
00:21:10,799 --> 00:21:12,320
and so if you have this piece of

586
00:21:12,320 --> 00:21:14,480
correlated randomness to begin with

587
00:21:14,480 --> 00:21:16,960
you can use it to convert the boolean

588
00:21:16,960 --> 00:21:18,720
representation representation

589
00:21:18,720 --> 00:21:20,799
essentially one bit at a time

590
00:21:20,799 --> 00:21:24,159
and uh the communication is like

591
00:21:24,159 --> 00:21:25,679
one bit per bit that you're trying to

592
00:21:25,679 --> 00:21:27,440
convert so if you're converting an n-bit

593
00:21:27,440 --> 00:21:29,360
integer online you only have to

594
00:21:29,360 --> 00:21:31,440
communicate end bids to convert it as

595
00:21:31,440 --> 00:21:32,799
long as you have this piece of

596
00:21:32,799 --> 00:21:35,280
correlated randomness and actually we're

597
00:21:35,280 --> 00:21:36,960
looking at improvements so we've

598
00:21:36,960 --> 00:21:39,039
recently uh talked with some other

599
00:21:39,039 --> 00:21:40,320
collaborators

600
00:21:40,320 --> 00:21:42,240
uh about a new way to do this where you

601
00:21:42,240 --> 00:21:43,600
might even be able to communicate less

602
00:21:43,600 --> 00:21:46,320
than that online

603
00:21:50,799 --> 00:21:52,720
uh

604
00:21:52,720 --> 00:21:54,240
it's it's a separate multi-party

605
00:21:54,240 --> 00:21:56,080
computation protocol beforehand that

606
00:21:56,080 --> 00:21:58,320
they run offline to generate the dobbits

607
00:21:58,320 --> 00:22:00,400
but it's pretty snappy it doesn't take

608
00:22:00,400 --> 00:22:02,080
very long at all

609
00:22:02,080 --> 00:22:05,080
yes

610
00:22:12,960 --> 00:22:15,919
yes so great question um the question

611
00:22:15,919 --> 00:22:17,360
was when we have to check extra

612
00:22:17,360 --> 00:22:19,120
properties are we using the same methods

613
00:22:19,120 --> 00:22:22,240
as prio and yeah so whenever frio the

614
00:22:22,240 --> 00:22:24,320
snips are really well suited for

615
00:22:24,320 --> 00:22:25,679
verifying especially these like

616
00:22:25,679 --> 00:22:27,760
multiplicative properties so like with

617
00:22:27,760 --> 00:22:29,760
variance checking that x squared equals

618
00:22:29,760 --> 00:22:30,799
x squared

619
00:22:30,799 --> 00:22:32,799
so whenever we have to do more than

620
00:22:32,799 --> 00:22:37,320
length checking we're relying on steps

621
00:22:41,200 --> 00:22:43,440
so actually the cool part is you don't

622
00:22:43,440 --> 00:22:45,120
the question was do you have to verify

623
00:22:45,120 --> 00:22:46,559
the consistency between the boolean

624
00:22:46,559 --> 00:22:48,480
shares and the arithmetic shares as long

625
00:22:48,480 --> 00:22:49,919
as you trust the share conversion

626
00:22:49,919 --> 00:22:51,039
protocol

627
00:22:51,039 --> 00:22:52,960
then whatever you get out of the share

628
00:22:52,960 --> 00:22:54,400
conversion protocol you just run the

629
00:22:54,400 --> 00:22:57,039
snip on that

630
00:22:57,120 --> 00:23:00,399
okay let's thank the speaker again

631
00:23:01,600 --> 00:23:03,520
so now i want to kind of remind the

632
00:23:03,520 --> 00:23:05,039
audience we're going to have the next

633
00:23:05,039 --> 00:23:06,320
talk and there's going to be a shorter

634
00:23:06,320 --> 00:23:07,919
talk at the end there is the first one

635
00:23:07,919 --> 00:23:09,840
that could not take place

636
00:23:09,840 --> 00:23:12,840
soon

