1
00:00:00,080 --> 00:00:02,000
your hash functions

2
00:00:02,000 --> 00:00:05,279
the first talk is entitled

3
00:00:05,279 --> 00:00:07,919
nearly optimal property preserving

4
00:00:07,919 --> 00:00:10,880
hashing by justin holmgren

5
00:00:10,880 --> 00:00:14,000
leon minghao and lakaya tyner

6
00:00:14,000 --> 00:00:15,920
and lakaya will give the talk the kind

7
00:00:15,920 --> 00:00:18,720
of floor is yours

8
00:00:19,600 --> 00:00:21,279
thank you for introduction

9
00:00:21,279 --> 00:00:23,279
um like you said my name is lakaya tyner

10
00:00:23,279 --> 00:00:25,519
and i am presenting on nearly optimal

11
00:00:25,519 --> 00:00:27,519
property preserving hashing

12
00:00:27,519 --> 00:00:29,119
this is again joint work with justin

13
00:00:29,119 --> 00:00:33,599
homegroom minghao liu and daniel wicks

14
00:00:33,840 --> 00:00:35,520
so i'm going to begin by giving you guys

15
00:00:35,520 --> 00:00:37,120
some background on property preserving

16
00:00:37,120 --> 00:00:38,239
hashing

17
00:00:38,239 --> 00:00:39,920
and then go into the coding theory that

18
00:00:39,920 --> 00:00:41,920
we will need for our constructions

19
00:00:41,920 --> 00:00:43,680
and then introduce our constructions and

20
00:00:43,680 --> 00:00:45,840
talk a little bit about bounds

21
00:00:45,840 --> 00:00:47,039
and then i'll end with some open

22
00:00:47,039 --> 00:00:49,440
questions

23
00:00:50,399 --> 00:00:53,199
so what is a property preserving hash

24
00:00:53,199 --> 00:00:55,600
we have this hash function h

25
00:00:55,600 --> 00:00:59,520
which takes as input and n bit string x

26
00:00:59,520 --> 00:01:03,680
and then outputs an inbit string h of x

27
00:01:03,680 --> 00:01:05,199
and then we and then we can consider

28
00:01:05,199 --> 00:01:08,240
some binary property p of x y which is

29
00:01:08,240 --> 00:01:10,159
equal to zero if the property does not

30
00:01:10,159 --> 00:01:13,680
hold and one if the property does hold

31
00:01:13,680 --> 00:01:15,520
and we say that h is a property

32
00:01:15,520 --> 00:01:17,520
preserving hash for this binary property

33
00:01:17,520 --> 00:01:19,040
p

34
00:01:19,040 --> 00:01:22,400
if given h of x and h of y

35
00:01:22,400 --> 00:01:24,479
we're able to determine if p of x y

36
00:01:24,479 --> 00:01:27,479
holds

37
00:01:28,159 --> 00:01:30,159
okay so this n m a property preserving

38
00:01:30,159 --> 00:01:31,680
hash family

39
00:01:31,680 --> 00:01:34,240
for some predicate p

40
00:01:34,240 --> 00:01:35,680
consists of this family of hash

41
00:01:35,680 --> 00:01:37,680
functions curly h

42
00:01:37,680 --> 00:01:38,840
and the following

43
00:01:38,840 --> 00:01:40,560
algorithms

44
00:01:40,560 --> 00:01:42,560
we have our samp algorithm which samples

45
00:01:42,560 --> 00:01:44,720
one such hash function h from that hash

46
00:01:44,720 --> 00:01:46,399
family

47
00:01:46,399 --> 00:01:48,640
and then we have our eval algorithm

48
00:01:48,640 --> 00:01:50,479
which takes as input a description of

49
00:01:50,479 --> 00:01:53,040
the hash function h and then h of x and

50
00:01:53,040 --> 00:01:57,600
h of y and outputs 0 or 1.

51
00:01:58,640 --> 00:02:00,880
additionally we must satisfy

52
00:02:00,880 --> 00:02:03,119
the following properties

53
00:02:03,119 --> 00:02:05,439
we have correctness which basically says

54
00:02:05,439 --> 00:02:09,038
that the probability for any x y chosen

55
00:02:09,038 --> 00:02:11,920
any worst case x y chosen a priori the

56
00:02:11,920 --> 00:02:13,920
probability that the eval algorithm

57
00:02:13,920 --> 00:02:16,000
outputs something different than p of x

58
00:02:16,000 --> 00:02:19,280
y is negligible

59
00:02:19,599 --> 00:02:21,120
if we want our property preserving hash

60
00:02:21,120 --> 00:02:23,360
family to be robust we must also satisfy

61
00:02:23,360 --> 00:02:25,840
this additional property

62
00:02:25,840 --> 00:02:28,160
which says that correctness holds even

63
00:02:28,160 --> 00:02:31,200
when x and y are chosen adaptively by an

64
00:02:31,200 --> 00:02:33,120
adversary who has seen some description

65
00:02:33,120 --> 00:02:37,319
of our hash function h

66
00:02:37,440 --> 00:02:38,640
okay and if you want to understand

67
00:02:38,640 --> 00:02:40,080
better the difference between a

68
00:02:40,080 --> 00:02:41,760
non-robust and a robust property

69
00:02:41,760 --> 00:02:43,440
preserving hash

70
00:02:43,440 --> 00:02:45,120
we can consider the difference between

71
00:02:45,120 --> 00:02:46,640
universal hashing and collision

72
00:02:46,640 --> 00:02:49,040
resistant hashing as it pertains to the

73
00:02:49,040 --> 00:02:51,519
equality predicate

74
00:02:51,519 --> 00:02:53,840
so a universal hash is exactly a

75
00:02:53,840 --> 00:02:56,000
non-robust property preserving hash for

76
00:02:56,000 --> 00:02:57,760
the equality predicate because it

77
00:02:57,760 --> 00:02:59,680
satisfies the correctness

78
00:02:59,680 --> 00:03:02,159
property

79
00:03:02,400 --> 00:03:04,560
okay in a collision resistant hash is

80
00:03:04,560 --> 00:03:06,560
exactly a robust property preserving

81
00:03:06,560 --> 00:03:07,440
hash

82
00:03:07,440 --> 00:03:09,440
for the equality predicate because it

83
00:03:09,440 --> 00:03:14,079
satisfies additional robustness property

84
00:03:15,040 --> 00:03:16,640
okay so why do we care about studying

85
00:03:16,640 --> 00:03:19,440
property preserving hashing

86
00:03:19,440 --> 00:03:21,120
what if we wanted to compare objects

87
00:03:21,120 --> 00:03:22,720
beyond equality

88
00:03:22,720 --> 00:03:24,480
let's say by some similarity metric that

89
00:03:24,480 --> 00:03:27,599
means that we may want to define

90
00:03:27,599 --> 00:03:29,200
apple attempted to do this with their

91
00:03:29,200 --> 00:03:31,840
neurohash application which was intended

92
00:03:31,840 --> 00:03:33,280
to detect

93
00:03:33,280 --> 00:03:36,640
child sexual abuse material on the cloud

94
00:03:36,640 --> 00:03:40,720
unfortunately they had a few issues with

95
00:03:40,720 --> 00:03:43,519
collisions such as these two images

96
00:03:43,519 --> 00:03:45,360
but i think studying robustness or how

97
00:03:45,360 --> 00:03:46,560
to make this

98
00:03:46,560 --> 00:03:48,080
particular application or similar

99
00:03:48,080 --> 00:03:52,000
applications robust is still useful

100
00:03:52,879 --> 00:03:54,080
okay and then property preserving

101
00:03:54,080 --> 00:03:56,000
hashing can also be useful for facial

102
00:03:56,000 --> 00:03:58,159
recognition when determining if two

103
00:03:58,159 --> 00:04:01,840
images are of the same person

104
00:04:02,400 --> 00:04:04,319
in this particular work

105
00:04:04,319 --> 00:04:06,640
to compare objects the property that we

106
00:04:06,640 --> 00:04:09,760
study is the hamming property

107
00:04:09,760 --> 00:04:11,920
which determines if the distance between

108
00:04:11,920 --> 00:04:14,560
these two strings x1 and x2

109
00:04:14,560 --> 00:04:17,199
is less than or equal to some threshold

110
00:04:17,199 --> 00:04:19,358
t

111
00:04:19,358 --> 00:04:20,880
okay and then we also mention this gap

112
00:04:20,880 --> 00:04:22,400
hamming predicate

113
00:04:22,400 --> 00:04:24,639
which determines if that distance is

114
00:04:24,639 --> 00:04:26,880
less than t less than or equal to t

115
00:04:26,880 --> 00:04:28,720
or greater than or equal to this one

116
00:04:28,720 --> 00:04:30,400
plus delta times t

117
00:04:30,400 --> 00:04:33,679
for some constant delta

118
00:04:34,160 --> 00:04:35,280
and the reason that we study this

119
00:04:35,280 --> 00:04:36,800
hamming property

120
00:04:36,800 --> 00:04:38,720
is because it serves as a basic unit of

121
00:04:38,720 --> 00:04:40,320
measure

122
00:04:40,320 --> 00:04:41,919
and it could lead to us understanding

123
00:04:41,919 --> 00:04:44,160
better some more complex metrics in the

124
00:04:44,160 --> 00:04:46,240
future

125
00:04:46,240 --> 00:04:47,919
and in fact it is currently being used

126
00:04:47,919 --> 00:04:50,000
as a common method for measuring the

127
00:04:50,000 --> 00:04:52,080
similarity between feature vectors and

128
00:04:52,080 --> 00:04:55,479
machine learning

129
00:04:56,000 --> 00:04:57,759
okay so this idea of studying the

130
00:04:57,759 --> 00:05:00,320
robustness of property preserving hash

131
00:05:00,320 --> 00:05:02,080
was introduced by boyo levine

132
00:05:02,080 --> 00:05:05,120
vaikuntanathin in 2019

133
00:05:05,120 --> 00:05:06,880
and in this work they introduced two

134
00:05:06,880 --> 00:05:08,320
constructions for the gap hamming

135
00:05:08,320 --> 00:05:09,600
predicate

136
00:05:09,600 --> 00:05:11,840
the first was from standard collision

137
00:05:11,840 --> 00:05:13,280
resistance

138
00:05:13,280 --> 00:05:15,520
and the second was from this the sparse

139
00:05:15,520 --> 00:05:18,479
sis assumption

140
00:05:19,520 --> 00:05:21,120
after we have this

141
00:05:21,120 --> 00:05:23,120
this work by flesh hacker and simkin

142
00:05:23,120 --> 00:05:25,600
which introduced the first exact hamming

143
00:05:25,600 --> 00:05:27,520
property preserving hash construction

144
00:05:27,520 --> 00:05:30,160
that we have and it was introduced or it

145
00:05:30,160 --> 00:05:32,320
was based on this new assumption called

146
00:05:32,320 --> 00:05:34,560
the q strong bilinear discrete log

147
00:05:34,560 --> 00:05:36,080
assumption that was introduced in that

148
00:05:36,080 --> 00:05:39,320
same work

149
00:05:39,440 --> 00:05:42,160
more recently we have this other exact

150
00:05:42,160 --> 00:05:43,680
hemi construction

151
00:05:43,680 --> 00:05:46,160
from flesh heck or larson and simkin

152
00:05:46,160 --> 00:05:47,840
that was based on a more standard

153
00:05:47,840 --> 00:05:50,639
assumption such as sis

154
00:05:50,639 --> 00:05:52,320
so an immediate question that we can ask

155
00:05:52,320 --> 00:05:53,840
after this

156
00:05:53,840 --> 00:05:56,639
is can we get some better compression on

157
00:05:56,639 --> 00:05:58,960
the output size of m

158
00:05:58,960 --> 00:06:00,800
and can we get a construction for exact

159
00:06:00,800 --> 00:06:04,639
hamming on some more minimal

160
00:06:04,840 --> 00:06:07,039
assumptions the answer to that as we

161
00:06:07,039 --> 00:06:08,720
show in this work is yes we can do both

162
00:06:08,720 --> 00:06:10,639
of those things so in this work we

163
00:06:10,639 --> 00:06:12,639
present two constructions for the exact

164
00:06:12,639 --> 00:06:15,600
hamming predicate the first based on sis

165
00:06:15,600 --> 00:06:17,199
or discrete log

166
00:06:17,199 --> 00:06:18,960
and the second based on standard

167
00:06:18,960 --> 00:06:21,840
collision resistance

168
00:06:22,000 --> 00:06:23,759
okay and the output size of our first

169
00:06:23,759 --> 00:06:25,919
robust construction is approximately

170
00:06:25,919 --> 00:06:28,000
equal to h of t over n

171
00:06:28,000 --> 00:06:30,160
times n where this h of t over n

172
00:06:30,160 --> 00:06:32,240
function is shannon entropy

173
00:06:32,240 --> 00:06:34,000
and this is strictly less than the

174
00:06:34,000 --> 00:06:35,440
output size

175
00:06:35,440 --> 00:06:37,520
achieved by prior works

176
00:06:37,520 --> 00:06:39,600
and in our work we prove a lower bound

177
00:06:39,600 --> 00:06:41,680
that shows that this output is actually

178
00:06:41,680 --> 00:06:43,600
optimal

179
00:06:43,600 --> 00:06:45,520
okay and then we also get optimality

180
00:06:45,520 --> 00:06:47,039
from standard collision resistance for

181
00:06:47,039 --> 00:06:50,240
our exact hamming construction

182
00:06:51,919 --> 00:06:53,199
for the remainder of this talk again

183
00:06:53,199 --> 00:06:55,199
i'll go over some

184
00:06:55,199 --> 00:06:56,720
some concepts from coding theory that we

185
00:06:56,720 --> 00:06:59,039
will need and then move on to explaining

186
00:06:59,039 --> 00:07:02,199
our constructions

187
00:07:02,479 --> 00:07:04,160
so the first thing from coding theory

188
00:07:04,160 --> 00:07:06,479
that we will need is this nkq error

189
00:07:06,479 --> 00:07:08,560
correcting code

190
00:07:08,560 --> 00:07:11,759
which is defined by this matrix g

191
00:07:11,759 --> 00:07:13,759
if we multiply this matrix g by some

192
00:07:13,759 --> 00:07:15,680
message m that means let me wait that we

193
00:07:15,680 --> 00:07:17,039
may want to

194
00:07:17,039 --> 00:07:21,199
transmit we get a code word c

195
00:07:21,280 --> 00:07:24,080
and the hope is that if some error were

196
00:07:24,080 --> 00:07:25,919
to actually be um were to actually be

197
00:07:25,919 --> 00:07:27,919
inflicted on this code where c during

198
00:07:27,919 --> 00:07:29,599
transmission

199
00:07:29,599 --> 00:07:31,199
depending on the number of errors we'd

200
00:07:31,199 --> 00:07:33,440
be able to successfully recover this

201
00:07:33,440 --> 00:07:35,520
code word c

202
00:07:35,520 --> 00:07:36,960
in order to do that

203
00:07:36,960 --> 00:07:39,680
we need this parity check matrix p over

204
00:07:39,680 --> 00:07:41,199
f q as well

205
00:07:41,199 --> 00:07:43,280
which has this special property

206
00:07:43,280 --> 00:07:45,919
that p times any code word is equal to

207
00:07:45,919 --> 00:07:48,878
the zero vector

208
00:07:49,039 --> 00:07:51,280
okay an a process for recovering any

209
00:07:51,280 --> 00:07:53,120
error that may be that may have occurred

210
00:07:53,120 --> 00:07:55,039
during transmission is known as syndrome

211
00:07:55,039 --> 00:07:56,639
decoding which we'll be using in our

212
00:07:56,639 --> 00:07:58,319
constructions

213
00:07:58,319 --> 00:08:00,319
okay so let x equal

214
00:08:00,319 --> 00:08:02,400
c plus some error vector e

215
00:08:02,400 --> 00:08:04,319
then given the syndrome x

216
00:08:04,319 --> 00:08:07,360
given the syndrome s equals p times x

217
00:08:07,360 --> 00:08:09,280
we can successfully recover

218
00:08:09,280 --> 00:08:11,360
the error vector e such that this

219
00:08:11,360 --> 00:08:13,360
hamming weight of the error vector is

220
00:08:13,360 --> 00:08:16,319
less than or equal to t

221
00:08:16,639 --> 00:08:18,879
okay and then doing some substitution we

222
00:08:18,879 --> 00:08:20,960
can also notice that that syndrome is

223
00:08:20,960 --> 00:08:23,520
equal to p times that error vector e

224
00:08:23,520 --> 00:08:25,599
and using this fact we will be able to

225
00:08:25,599 --> 00:08:28,878
to recover our error vector

226
00:08:29,039 --> 00:08:30,479
syndrome listed coding is a similar

227
00:08:30,479 --> 00:08:31,840
process

228
00:08:31,840 --> 00:08:33,760
codes that are syndrome less decodable

229
00:08:33,760 --> 00:08:36,799
are able to handle more error

230
00:08:36,799 --> 00:08:38,159
the difference between this and syndrome

231
00:08:38,159 --> 00:08:39,839
decoding is instead of recovering a

232
00:08:39,839 --> 00:08:42,399
unique error vector e we recover a list

233
00:08:42,399 --> 00:08:44,720
of possible error vectors such that the

234
00:08:44,720 --> 00:08:48,720
size of that list is polynomial in n

235
00:08:50,800 --> 00:08:54,240
okay and a common metric for efficiency

236
00:08:54,240 --> 00:08:56,480
for our error correcting codes is this

237
00:08:56,480 --> 00:08:58,880
rate which is a ratio between the size

238
00:08:58,880 --> 00:09:00,959
of our message m and the size of our

239
00:09:00,959 --> 00:09:03,680
code word n

240
00:09:04,399 --> 00:09:06,480
and we have this hemingbound that kinda

241
00:09:06,480 --> 00:09:09,760
describes the so ideally we want this

242
00:09:09,760 --> 00:09:12,080
rate to be as close to one as possible

243
00:09:12,080 --> 00:09:14,080
but we have this hamming bound that kind

244
00:09:14,080 --> 00:09:15,760
of describes how close the one we can

245
00:09:15,760 --> 00:09:17,920
ever hope to achieve

246
00:09:17,920 --> 00:09:20,320
so it says that r is equal to one minus

247
00:09:20,320 --> 00:09:22,880
h of t over t over n where again this h

248
00:09:22,880 --> 00:09:25,200
function is shannon entropy

249
00:09:25,200 --> 00:09:27,279
and this is optimal

250
00:09:27,279 --> 00:09:29,040
unfortunately we only have inefficient

251
00:09:29,040 --> 00:09:30,720
codes that meet that meets this hamming

252
00:09:30,720 --> 00:09:32,080
bound

253
00:09:32,080 --> 00:09:34,880
efficiently we meet this slightly weaker

254
00:09:34,880 --> 00:09:37,440
block zio block bound

255
00:09:37,440 --> 00:09:40,320
which is equal to 1 minus which says

256
00:09:40,320 --> 00:09:42,959
that the rate is equal to 1 minus hbz

257
00:09:42,959 --> 00:09:45,680
where this hbz term is slightly larger

258
00:09:45,680 --> 00:09:49,319
than shannon entropy

259
00:09:50,000 --> 00:09:51,519
okay so let's move on into our first

260
00:09:51,519 --> 00:09:53,440
construction which is again a non-robust

261
00:09:53,440 --> 00:09:55,440
construction for the hamming predicate

262
00:09:55,440 --> 00:09:58,800
that uses syndrome decoding

263
00:09:58,800 --> 00:10:01,600
let's remind ourselves of hamming

264
00:10:01,600 --> 00:10:04,320
we have this distance between x1 and x2

265
00:10:04,320 --> 00:10:06,720
which is equal to the hamming weight of

266
00:10:06,720 --> 00:10:10,160
x1 xor x2

267
00:10:10,160 --> 00:10:12,320
and hamming is equal to 1 if that

268
00:10:12,320 --> 00:10:14,560
distance is less than or equal to t

269
00:10:14,560 --> 00:10:18,199
and 0 otherwise

270
00:10:19,040 --> 00:10:20,880
we will also be utilizing a universal

271
00:10:20,880 --> 00:10:22,959
hash function for this construction

272
00:10:22,959 --> 00:10:25,839
of the form h of x is equal to a times x

273
00:10:25,839 --> 00:10:31,040
for some make for some matrix x over z2

274
00:10:31,120 --> 00:10:32,720
and this satisfies this universal

275
00:10:32,720 --> 00:10:34,959
property which says that for every x1

276
00:10:34,959 --> 00:10:37,600
not equal to x2 the probability that the

277
00:10:37,600 --> 00:10:40,399
hashes of those two inputs are equal

278
00:10:40,399 --> 00:10:42,160
is less than or equal to two to the

279
00:10:42,160 --> 00:10:44,719
minus m

280
00:10:45,120 --> 00:10:47,040
additionally this hash function

281
00:10:47,040 --> 00:10:49,680
satisfies this homomorphic property

282
00:10:49,680 --> 00:10:52,320
which states that a times x1 minus a

283
00:10:52,320 --> 00:10:53,839
times x2

284
00:10:53,839 --> 00:10:57,519
is equal to a times quantity x1 minus x2

285
00:10:57,519 --> 00:10:59,200
and this is the useful property that we

286
00:10:59,200 --> 00:11:02,480
will need in our constructions

287
00:11:03,120 --> 00:11:04,160
okay

288
00:11:04,160 --> 00:11:06,240
our n m a non-robust property preserving

289
00:11:06,240 --> 00:11:10,320
hash for hash family for hamming

290
00:11:10,320 --> 00:11:12,560
let p be the parity check matrix of an

291
00:11:12,560 --> 00:11:14,800
nk2 code

292
00:11:14,800 --> 00:11:16,959
we sample our hash function h

293
00:11:16,959 --> 00:11:19,040
and our matrix a

294
00:11:19,040 --> 00:11:20,240
such that

295
00:11:20,240 --> 00:11:23,360
h of x is defined by p times x and a

296
00:11:23,360 --> 00:11:25,920
times x

297
00:11:27,200 --> 00:11:29,519
in order to evaluate this

298
00:11:29,519 --> 00:11:32,399
we let h of x1 and h of x2 be defined as

299
00:11:32,399 --> 00:11:34,800
follows

300
00:11:34,800 --> 00:11:36,240
and then we compute the difference

301
00:11:36,240 --> 00:11:38,640
between those two those two syndromes

302
00:11:38,640 --> 00:11:40,839
px1 and

303
00:11:40,839 --> 00:11:44,640
px2 we run syndrome list decoding

304
00:11:44,640 --> 00:11:46,240
to get our list of possible error

305
00:11:46,240 --> 00:11:47,279
vectors

306
00:11:47,279 --> 00:11:49,839
such that for every e i in that list p

307
00:11:49,839 --> 00:11:52,959
of e i is equal to p times x1 minus p

308
00:11:52,959 --> 00:11:54,240
times x2

309
00:11:54,240 --> 00:11:55,760
and the cam and weight of those of each

310
00:11:55,760 --> 00:11:57,360
of those vectors is less than or equal

311
00:11:57,360 --> 00:11:59,600
to t

312
00:12:00,560 --> 00:12:02,480
okay and then if there exists an i in

313
00:12:02,480 --> 00:12:04,160
that list such that

314
00:12:04,160 --> 00:12:06,560
a times ei is equal to a times quantity

315
00:12:06,560 --> 00:12:08,959
x1 minus x2

316
00:12:08,959 --> 00:12:10,800
then we output one

317
00:12:10,800 --> 00:12:12,639
otherwise we output zero

318
00:12:12,639 --> 00:12:14,800
and the intuition behind this is we're

319
00:12:14,800 --> 00:12:16,160
treating the difference between those

320
00:12:16,160 --> 00:12:18,800
two vectors x1 and x2 as the error that

321
00:12:18,800 --> 00:12:20,639
we're trying to recover and so we run

322
00:12:20,639 --> 00:12:22,399
center decoding to get a possible list

323
00:12:22,399 --> 00:12:25,040
of those errors and we confirm if there

324
00:12:25,040 --> 00:12:25,839
does

325
00:12:25,839 --> 00:12:28,000
exist such an ei in that list that

326
00:12:28,000 --> 00:12:30,240
satisfies this relationship

327
00:12:30,240 --> 00:12:33,680
if that is true then we can output one

328
00:12:33,680 --> 00:12:36,079
and this basically reiterates

329
00:12:36,079 --> 00:12:37,440
we know that security or correctness

330
00:12:37,440 --> 00:12:40,800
holds because if x1 and x2 are close

331
00:12:40,800 --> 00:12:44,240
meaning if e i is indeed less if e is

332
00:12:44,240 --> 00:12:46,880
indeed equal to x1 minus x2

333
00:12:46,880 --> 00:12:47,680
um

334
00:12:47,680 --> 00:12:51,120
then we will find that e on the list

335
00:12:51,279 --> 00:12:53,279
if the difference between x1 and x2 is

336
00:12:53,279 --> 00:12:54,639
greater than t

337
00:12:54,639 --> 00:12:56,399
then for every ei in that list that we

338
00:12:56,399 --> 00:12:58,399
recover

339
00:12:58,399 --> 00:13:01,279
a times e i will not be equal to x a

340
00:13:01,279 --> 00:13:05,560
times x1 minus a times x2

341
00:13:06,399 --> 00:13:08,079
we also define a couple corollaries in

342
00:13:08,079 --> 00:13:10,399
this work that define the upper bounds

343
00:13:10,399 --> 00:13:13,200
for the size of our output m equals to n

344
00:13:13,200 --> 00:13:15,360
minus 1 plus lambda

345
00:13:15,360 --> 00:13:17,440
and this is for this is using an nk2

346
00:13:17,440 --> 00:13:19,680
linear error correcting code that can

347
00:13:19,680 --> 00:13:21,920
efficiently list the code that can list

348
00:13:21,920 --> 00:13:24,959
decode up to t errors

349
00:13:24,959 --> 00:13:26,639
as i mentioned previously we only have

350
00:13:26,639 --> 00:13:28,399
inefficient codes to meet this optimal

351
00:13:28,399 --> 00:13:29,680
hamming bound

352
00:13:29,680 --> 00:13:32,240
to get our output size equal to

353
00:13:32,240 --> 00:13:36,000
shannon entropy time n plus lambda

354
00:13:36,000 --> 00:13:38,880
if you want efficiency um

355
00:13:38,880 --> 00:13:40,800
we have codes to meet this again with

356
00:13:40,800 --> 00:13:42,959
this slightly weaker black zia block

357
00:13:42,959 --> 00:13:44,160
bound

358
00:13:44,160 --> 00:13:45,279
it's not too far off from the

359
00:13:45,279 --> 00:13:47,279
hemmingbound but there is a bit of a

360
00:13:47,279 --> 00:13:50,000
difference a little bit small difference

361
00:13:50,000 --> 00:13:51,839
okay and here's the appetizer for that

362
00:13:51,839 --> 00:13:54,320
for using those codes

363
00:13:54,320 --> 00:13:56,560
we can get a non-trivial compression for

364
00:13:56,560 --> 00:13:59,839
up to a constant distance of t equal to

365
00:13:59,839 --> 00:14:02,399
big o of n

366
00:14:02,399 --> 00:14:04,320
and we can upper bound the size of our

367
00:14:04,320 --> 00:14:06,240
output

368
00:14:06,240 --> 00:14:09,519
m equals to o big o of t log n plus

369
00:14:09,519 --> 00:14:10,720
lambda

370
00:14:10,720 --> 00:14:11,680
but for

371
00:14:11,680 --> 00:14:13,279
large t

372
00:14:13,279 --> 00:14:15,199
our block zeibler bound allows us to do

373
00:14:15,199 --> 00:14:18,240
even better because the the log input or

374
00:14:18,240 --> 00:14:20,079
the log n term in that

375
00:14:20,079 --> 00:14:23,599
output size actually disappears

376
00:14:25,519 --> 00:14:26,880
okay here's our first robust

377
00:14:26,880 --> 00:14:29,199
construction for hamming

378
00:14:29,199 --> 00:14:30,959
this construction basically shows how to

379
00:14:30,959 --> 00:14:33,279
take our non-robust construction and

380
00:14:33,279 --> 00:14:34,880
make it into a robust construction so

381
00:14:34,880 --> 00:14:36,320
they're really similar

382
00:14:36,320 --> 00:14:37,600
but they do have a key difference which

383
00:14:37,600 --> 00:14:40,320
i will explain

384
00:14:41,279 --> 00:14:43,040
instead of using that universal hash

385
00:14:43,040 --> 00:14:44,800
function that i mentioned earlier i'm

386
00:14:44,800 --> 00:14:47,199
going to replace that by a uni by a

387
00:14:47,199 --> 00:14:48,639
collision a homomorphic collision

388
00:14:48,639 --> 00:14:51,680
resistant hash function

389
00:14:51,920 --> 00:14:53,279
and the two constructions that we

390
00:14:53,279 --> 00:14:55,120
currently have for homomorphic collision

391
00:14:55,120 --> 00:14:57,040
resistant hash functions are

392
00:14:57,040 --> 00:14:59,519
from discrete log from pedersen and from

393
00:14:59,519 --> 00:15:02,880
sis from itai

394
00:15:03,600 --> 00:15:04,720
okay even with this change we're

395
00:15:04,720 --> 00:15:06,240
essentially able to achieve the same

396
00:15:06,240 --> 00:15:07,760
compression as our non-robust

397
00:15:07,760 --> 00:15:10,760
construction

398
00:15:12,079 --> 00:15:13,760
okay here's our second robust

399
00:15:13,760 --> 00:15:15,519
construction for hamming

400
00:15:15,519 --> 00:15:17,120
this is based on standard collision

401
00:15:17,120 --> 00:15:20,240
resistance and we show how to take a gap

402
00:15:20,240 --> 00:15:22,000
hamming property preserving hash from

403
00:15:22,000 --> 00:15:24,880
the blv paper that first bov paper

404
00:15:24,880 --> 00:15:26,639
and how to amplify it and make it into

405
00:15:26,639 --> 00:15:28,880
an exact hamming predicate or an exact

406
00:15:28,880 --> 00:15:30,880
handling property preserving hash for

407
00:15:30,880 --> 00:15:33,279
hamming

408
00:15:34,000 --> 00:15:35,360
so let's remind ourselves of the gap

409
00:15:35,360 --> 00:15:38,000
handling predicate

410
00:15:38,000 --> 00:15:41,120
let d of x1 two again equal to

411
00:15:41,120 --> 00:15:44,639
the hamming weight of x one x or x two

412
00:15:44,639 --> 00:15:46,959
and then gap hamming is equal to one

413
00:15:46,959 --> 00:15:48,639
if that distance is less than or equal

414
00:15:48,639 --> 00:15:49,440
to t

415
00:15:49,440 --> 00:15:50,720
equal to zero

416
00:15:50,720 --> 00:15:52,399
if that distance is greater than or

417
00:15:52,399 --> 00:15:55,040
equal to one plus delta times t

418
00:15:55,040 --> 00:15:58,160
and by otherwise

419
00:16:00,079 --> 00:16:02,320
okay so an nm robust property preserving

420
00:16:02,320 --> 00:16:04,079
hash for handing

421
00:16:04,079 --> 00:16:06,240
let hgap be that robust property

422
00:16:06,240 --> 00:16:08,399
preserving hash for gap hamming

423
00:16:08,399 --> 00:16:11,279
from the blv19 paper

424
00:16:11,279 --> 00:16:13,839
and then similarly as before let p equal

425
00:16:13,839 --> 00:16:16,880
this pretty check matrix for this nk2

426
00:16:16,880 --> 00:16:18,560
error correcting code that can

427
00:16:18,560 --> 00:16:21,279
efficiently decode up to one plus delta

428
00:16:21,279 --> 00:16:24,160
times t errors

429
00:16:24,240 --> 00:16:26,079
we sample our hash function

430
00:16:26,079 --> 00:16:30,000
such that h of x is defined by p times x

431
00:16:30,000 --> 00:16:31,440
in this h

432
00:16:31,440 --> 00:16:34,079
gap of x

433
00:16:35,600 --> 00:16:37,600
in order to evaluate

434
00:16:37,600 --> 00:16:40,320
let y one and y two be defined as

435
00:16:40,320 --> 00:16:42,000
following

436
00:16:42,000 --> 00:16:43,759
we again compute the difference between

437
00:16:43,759 --> 00:16:46,399
those two syndromes p of x one p times x

438
00:16:46,399 --> 00:16:48,720
one minus p times x two

439
00:16:48,720 --> 00:16:51,279
for incentive decoding

440
00:16:51,279 --> 00:16:54,560
to retrieve a unique error vector e such

441
00:16:54,560 --> 00:16:57,759
that p times e is equal to p times x one

442
00:16:57,759 --> 00:16:59,920
x or p times x two

443
00:16:59,920 --> 00:17:01,279
and the hamming weight of the error

444
00:17:01,279 --> 00:17:03,040
vector is less than or equal to one plus

445
00:17:03,040 --> 00:17:05,839
delta times t

446
00:17:06,079 --> 00:17:08,559
and then we perform two checks

447
00:17:08,559 --> 00:17:10,079
we output one

448
00:17:10,079 --> 00:17:12,319
if and only if our first check

449
00:17:12,319 --> 00:17:14,559
which is the output of the eval gaap

450
00:17:14,559 --> 00:17:17,119
function or the ebay eval gap algorithm

451
00:17:17,119 --> 00:17:19,520
from that bov construction if that is

452
00:17:19,520 --> 00:17:21,039
equal to one

453
00:17:21,039 --> 00:17:22,799
and the hamming weight of our error

454
00:17:22,799 --> 00:17:26,240
vector e is less than or equal to t

455
00:17:26,240 --> 00:17:28,079
then we output one

456
00:17:28,079 --> 00:17:29,840
otherwise we output zero

457
00:17:29,840 --> 00:17:32,559
and the intuition behind this is this

458
00:17:32,559 --> 00:17:34,480
eval gap

459
00:17:34,480 --> 00:17:36,799
or the output of this eval gap algorithm

460
00:17:36,799 --> 00:17:38,720
will tell us whether or not

461
00:17:38,720 --> 00:17:39,679
our

462
00:17:39,679 --> 00:17:41,840
hamming weight is greater than or less

463
00:17:41,840 --> 00:17:43,440
less than or equal to one plus delta

464
00:17:43,440 --> 00:17:44,480
times t

465
00:17:44,480 --> 00:17:46,240
if that is indeed the fat if that is

466
00:17:46,240 --> 00:17:47,760
indeed true

467
00:17:47,760 --> 00:17:49,600
then we only need to worry about whether

468
00:17:49,600 --> 00:17:51,360
or not that hamming weight falls or the

469
00:17:51,360 --> 00:17:54,320
hemi distance falls in between that gap

470
00:17:54,320 --> 00:17:55,840
so the second check

471
00:17:55,840 --> 00:17:57,840
to make sure that the hamming weight of

472
00:17:57,840 --> 00:18:00,400
that error vector e is less than t we'll

473
00:18:00,400 --> 00:18:02,960
catch that

474
00:18:04,720 --> 00:18:07,200
in this work we also study a new notion

475
00:18:07,200 --> 00:18:09,200
of randomized robust property preserving

476
00:18:09,200 --> 00:18:11,360
hash or r2p2

477
00:18:11,360 --> 00:18:13,679
for the hamming predicate

478
00:18:13,679 --> 00:18:16,000
and we're able to achieve a information

479
00:18:16,000 --> 00:18:18,880
theoretic construction as opposed to our

480
00:18:18,880 --> 00:18:21,120
deterministic ran our deterministic

481
00:18:21,120 --> 00:18:23,039
robust constructions which require at

482
00:18:23,039 --> 00:18:27,400
least standard collision resistance

483
00:18:28,160 --> 00:18:29,440
okay to give you guys an overview of

484
00:18:29,440 --> 00:18:31,039
this construction

485
00:18:31,039 --> 00:18:33,520
h of x is computed using a randomized

486
00:18:33,520 --> 00:18:35,760
process

487
00:18:35,760 --> 00:18:37,840
and then an adversary a can choose our

488
00:18:37,840 --> 00:18:39,679
worst case x and y after seeing a

489
00:18:39,679 --> 00:18:41,280
description of h

490
00:18:41,280 --> 00:18:42,720
and then succeeds

491
00:18:42,720 --> 00:18:44,320
if eval outputs something different than

492
00:18:44,320 --> 00:18:45,840
p of x y

493
00:18:45,840 --> 00:18:47,280
and something that's important to note

494
00:18:47,280 --> 00:18:49,200
with this particular construction or

495
00:18:49,200 --> 00:18:51,520
this particular notion of randomized

496
00:18:51,520 --> 00:18:53,520
robust property preserving hash

497
00:18:53,520 --> 00:18:55,840
with our deterministic constructions an

498
00:18:55,840 --> 00:18:57,520
adversary is able to see is able to

499
00:18:57,520 --> 00:19:00,240
choose x and then see the output of x of

500
00:19:00,240 --> 00:19:03,280
h of x and then choose y

501
00:19:03,280 --> 00:19:05,039
in this case

502
00:19:05,039 --> 00:19:06,799
that's not true

503
00:19:06,799 --> 00:19:08,240
because of the adversary is able to see

504
00:19:08,240 --> 00:19:11,120
the output of x of h of x they can learn

505
00:19:11,120 --> 00:19:12,640
some knowledge about the randomness that

506
00:19:12,640 --> 00:19:15,200
was used to compute

507
00:19:15,200 --> 00:19:17,760
the output of the hash on x

508
00:19:17,760 --> 00:19:21,520
and then in some way choose a bad y that

509
00:19:21,520 --> 00:19:25,559
will enable it to break secured

510
00:19:27,440 --> 00:19:29,520
okay for our construction

511
00:19:29,520 --> 00:19:31,919
we get this information theoretic r2p2

512
00:19:31,919 --> 00:19:34,480
hash for equality from prior works

513
00:19:34,480 --> 00:19:36,480
which is able to achieve an output size

514
00:19:36,480 --> 00:19:40,400
of o of square root lamp square root n

515
00:19:40,400 --> 00:19:41,760
in this work

516
00:19:41,760 --> 00:19:44,080
again we are able to

517
00:19:44,080 --> 00:19:46,320
produce an information theoretic r2 p2

518
00:19:46,320 --> 00:19:48,799
hash for the hamming predicate

519
00:19:48,799 --> 00:19:50,960
that achieves an output size of big go

520
00:19:50,960 --> 00:19:53,840
of square root lambda n plus f of t n

521
00:19:53,840 --> 00:19:56,400
where this f of t n is equal to shannon

522
00:19:56,400 --> 00:19:59,360
entropy times n

523
00:20:00,400 --> 00:20:02,559
we noticed right in this paper

524
00:20:02,559 --> 00:20:04,000
that we're able to

525
00:20:04,000 --> 00:20:06,400
use cinnamon coding plus a homomorphic

526
00:20:06,400 --> 00:20:09,440
universal hash to get a robust property

527
00:20:09,440 --> 00:20:11,440
preserving hash for hamming

528
00:20:11,440 --> 00:20:12,960
and then similarly

529
00:20:12,960 --> 00:20:14,960
we use center decoding plus the

530
00:20:14,960 --> 00:20:17,280
homomorphic r2p2 hash

531
00:20:17,280 --> 00:20:20,640
to get r2p2 hash for equality to get an

532
00:20:20,640 --> 00:20:23,919
r2p2 hash for hamming

533
00:20:24,880 --> 00:20:27,679
okay and again we get this equality r2p2

534
00:20:27,679 --> 00:20:31,120
hash from priorworks

535
00:20:31,760 --> 00:20:33,039
in summary

536
00:20:33,039 --> 00:20:36,000
this work produces or introduces one

537
00:20:36,000 --> 00:20:37,679
non-robust property preserving hash for

538
00:20:37,679 --> 00:20:38,640
hamming

539
00:20:38,640 --> 00:20:40,559
and then two robust property preserving

540
00:20:40,559 --> 00:20:42,559
hashes for hamming

541
00:20:42,559 --> 00:20:44,080
our constructions are conceptually

542
00:20:44,080 --> 00:20:45,919
simpler than those introduced by prior

543
00:20:45,919 --> 00:20:49,039
works and we're able to achieve a

544
00:20:49,039 --> 00:20:51,360
better compression under minimal

545
00:20:51,360 --> 00:20:53,120
assumptions

546
00:20:53,120 --> 00:20:55,200
and we also study this new notion of

547
00:20:55,200 --> 00:20:57,039
randomized robust property preserving

548
00:20:57,039 --> 00:20:59,760
hash for hamming

549
00:20:59,760 --> 00:21:01,440
and we are able to introduce an

550
00:21:01,440 --> 00:21:03,600
information theoretic construction and

551
00:21:03,600 --> 00:21:06,879
achieve optimal parameters

552
00:21:06,960 --> 00:21:08,320
the open question that i would like to

553
00:21:08,320 --> 00:21:10,720
leave you all with

554
00:21:10,720 --> 00:21:13,840
so for our robust exact and gap

555
00:21:13,840 --> 00:21:15,760
constructions we can show that we can

556
00:21:15,760 --> 00:21:17,440
actually achieve

557
00:21:17,440 --> 00:21:20,640
an output size of m equals to h that

558
00:21:20,640 --> 00:21:22,799
shannon entropy minus little of one

559
00:21:22,799 --> 00:21:25,520
times n plus lambda

560
00:21:25,520 --> 00:21:27,360
and this essentially matches

561
00:21:27,360 --> 00:21:30,400
for the non-robust exact parameters but

562
00:21:30,400 --> 00:21:32,960
we don't know how to do any better for

563
00:21:32,960 --> 00:21:34,960
the gak for the for the gap hamming

564
00:21:34,960 --> 00:21:37,280
construction as opposed to the exact

565
00:21:37,280 --> 00:21:39,760
timing construction

566
00:21:39,760 --> 00:21:42,799
there's this work by kor in 2000 that

567
00:21:42,799 --> 00:21:45,200
says that indeed for the non-robust gap

568
00:21:45,200 --> 00:21:47,120
construction or for non-robust gap

569
00:21:47,120 --> 00:21:48,880
constructions we can achieve an even

570
00:21:48,880 --> 00:21:50,720
smaller output size

571
00:21:50,720 --> 00:21:54,720
of m equals to o of lambda

572
00:21:54,720 --> 00:21:56,080
so our

573
00:21:56,080 --> 00:21:58,240
final for our final open question is can

574
00:21:58,240 --> 00:22:00,880
we achieve a similar output in our

575
00:22:00,880 --> 00:22:04,640
robust gap constructions

576
00:22:05,760 --> 00:22:09,240
thanks for listening

577
00:22:14,880 --> 00:22:16,799
we have time for a quick question i

578
00:22:16,799 --> 00:22:20,320
don't see a question on the zoom but um

579
00:22:20,320 --> 00:22:21,840
people in the audience have a question

580
00:22:21,840 --> 00:22:23,679
please line up to one of the mics on the

581
00:22:23,679 --> 00:22:27,159
left or the right

582
00:22:34,159 --> 00:22:36,159
so to keep ourselves on time let's thank

583
00:22:36,159 --> 00:22:40,200
lakaya again and

584
00:22:42,960 --> 00:22:46,840
move on to the next talk

585
00:22:58,080 --> 00:22:59,760
see no questions on the zoom but people

586
00:22:59,760 --> 00:23:03,039
on the zoom are also clapping

587
00:23:03,520 --> 00:23:07,440
the next talk is entitled uh collision

588
00:23:07,440 --> 00:23:09,200
resistance from multi-collision

589
00:23:09,200 --> 00:23:10,720
resistance

590
00:23:10,720 --> 00:23:15,200
by ron rothblum and preschoons nalini

591
00:23:15,200 --> 00:23:18,880
vasudevan and um ron rothbloom will give

592
00:23:18,880 --> 00:23:23,799
the talk momentarily yeah sure

593
00:23:26,159 --> 00:23:29,559
take your time

594
00:23:53,760 --> 00:23:55,440
see the slides already on zoom but not

595
00:23:55,440 --> 00:23:58,320
just here in the room

596
00:23:59,360 --> 00:24:01,840
there we go okay round the floor is

597
00:24:01,840 --> 00:24:04,400
yours

598
00:24:04,400 --> 00:24:06,640
uh thanks for the introduction uh let me

599
00:24:06,640 --> 00:24:08,480
repeat it a couple of minutes ago so the

600
00:24:08,480 --> 00:24:09,600
talk is titled multiple engine

601
00:24:09,600 --> 00:24:11,360
resistance uh from multiplication

602
00:24:11,360 --> 00:24:13,360
resistance to collision resistance and

603
00:24:13,360 --> 00:24:16,240
this is a joint work with uh prashant so

604
00:24:16,240 --> 00:24:17,200
divine

605
00:24:17,200 --> 00:24:19,200
um so this talk is about

606
00:24:19,200 --> 00:24:21,279
sort of two different security notions

607
00:24:21,279 --> 00:24:24,000
for hash functions and uh what i think

608
00:24:24,000 --> 00:24:25,520
is somewhat surprising relation between

609
00:24:25,520 --> 00:24:28,159
them um so the first one or maybe the

610
00:24:28,159 --> 00:24:29,760
the second one on the slide is that of

611
00:24:29,760 --> 00:24:31,360
collision resistance which is a property

612
00:24:31,360 --> 00:24:33,360
that i assume all of you are familiar

613
00:24:33,360 --> 00:24:35,840
with very central notion in cryptography

614
00:24:35,840 --> 00:24:36,720
and the other one is called

615
00:24:36,720 --> 00:24:38,720
multi-collision resistance which i think

616
00:24:38,720 --> 00:24:40,640
uh many of you are familiar or otherwise

617
00:24:40,640 --> 00:24:42,799
can guess but let's maybe start off by

618
00:24:42,799 --> 00:24:44,840
sort of defining these

619
00:24:44,840 --> 00:24:47,679
notions so collision resistance hashing

620
00:24:47,679 --> 00:24:50,159
is a you know ubiquitous ubiquitous in

621
00:24:50,159 --> 00:24:52,799
cryptography these are hash functions

622
00:24:52,799 --> 00:24:54,960
that are compressing or shrinking

623
00:24:54,960 --> 00:24:56,640
which means that you know they have a

624
00:24:56,640 --> 00:24:58,000
lot of collisions

625
00:24:58,000 --> 00:25:00,480
but nevertheless um we conjecture that

626
00:25:00,480 --> 00:25:02,799
it is computationally hard to find

627
00:25:02,799 --> 00:25:05,120
collisions in these hash functions and

628
00:25:05,120 --> 00:25:07,360
these are uh extremely prevalent both in

629
00:25:07,360 --> 00:25:10,880
the theory and practice of cryptography

630
00:25:10,880 --> 00:25:13,039
so that's collision resistant hashing

631
00:25:13,039 --> 00:25:15,200
uh recent line of work has studied a

632
00:25:15,200 --> 00:25:16,960
relaxation of this notion something

633
00:25:16,960 --> 00:25:18,720
that's called multi-collision resistant

634
00:25:18,720 --> 00:25:21,039
hashing which kind of uh comes to

635
00:25:21,039 --> 00:25:23,200
address the following question suppose

636
00:25:23,200 --> 00:25:25,440
you have a hash function in which it's

637
00:25:25,440 --> 00:25:27,520
possible to find pairwise collisions but

638
00:25:27,520 --> 00:25:29,279
maybe it's hard to find three-way

639
00:25:29,279 --> 00:25:31,600
collisions so three differing inputs

640
00:25:31,600 --> 00:25:33,919
that all collide on the same output

641
00:25:33,919 --> 00:25:35,840
okay so that would be three

642
00:25:35,840 --> 00:25:37,200
multi-collision resistant hash function

643
00:25:37,200 --> 00:25:39,120
or three m crh

644
00:25:39,120 --> 00:25:40,640
okay it's a relaxation it's a weaker

645
00:25:40,640 --> 00:25:42,960
security property than crh and the

646
00:25:42,960 --> 00:25:44,159
question is you know

647
00:25:44,159 --> 00:25:45,600
what is it good for how does it relate

648
00:25:45,600 --> 00:25:46,559
to other properties that we're

649
00:25:46,559 --> 00:25:47,600
interested in

650
00:25:47,600 --> 00:25:48,960
so let me be a little bit formal about

651
00:25:48,960 --> 00:25:51,600
the setup so first of all um so susan

652
00:25:51,600 --> 00:25:53,039
talked yesterday about keyless

653
00:25:53,039 --> 00:25:54,720
multi-collision resistant hashing here

654
00:25:54,720 --> 00:25:56,400
we're going to be talking about keyed

655
00:25:56,400 --> 00:25:58,400
hash functions which is the more

656
00:25:58,400 --> 00:25:59,760
uh at least in the theory of

657
00:25:59,760 --> 00:26:01,600
cryptography it's the more mainstream or

658
00:26:01,600 --> 00:26:03,679
traditional notion so we're looking at a

659
00:26:03,679 --> 00:26:05,600
collection of hash functions

660
00:26:05,600 --> 00:26:07,919
so this mcrh notion is parameterized by

661
00:26:07,919 --> 00:26:10,720
two parameters t and l both are integers

662
00:26:10,720 --> 00:26:12,240
so we have our hash function that i

663
00:26:12,240 --> 00:26:13,360
think of it our collection of hash

664
00:26:13,360 --> 00:26:16,559
functions mapping n bits to n minus l

665
00:26:16,559 --> 00:26:18,880
bits so as the level of shrinkage that

666
00:26:18,880 --> 00:26:19,840
you have

667
00:26:19,840 --> 00:26:21,600
or compression

668
00:26:21,600 --> 00:26:23,520
and what we want from this collection of

669
00:26:23,520 --> 00:26:24,400
hash functions

670
00:26:24,400 --> 00:26:26,799
is a that it's efficiently computable

671
00:26:26,799 --> 00:26:29,039
and b the security property says that if

672
00:26:29,039 --> 00:26:30,480
you look at any you know bounded

673
00:26:30,480 --> 00:26:32,799
adversary pandoma size adversary

674
00:26:32,799 --> 00:26:34,400
if you sample a hash function from the

675
00:26:34,400 --> 00:26:36,400
collection at random and you give the

676
00:26:36,400 --> 00:26:38,320
adversary a description of this hash

677
00:26:38,320 --> 00:26:40,000
function the adversary basically won't

678
00:26:40,000 --> 00:26:42,559
be able to find a two-way collision so a

679
00:26:42,559 --> 00:26:44,240
set of t elements

680
00:26:44,240 --> 00:26:46,880
so i said x that all collide on the same

681
00:26:46,880 --> 00:26:48,000
output

682
00:26:48,000 --> 00:26:49,120
okay so

683
00:26:49,120 --> 00:26:51,200
different way of writing that

684
00:26:51,200 --> 00:26:53,279
so that is multi-collision resistance

685
00:26:53,279 --> 00:26:55,440
and just you know as a sanity check

686
00:26:55,440 --> 00:26:56,640
note that

687
00:26:56,640 --> 00:26:58,799
if you're if you take uh t to be equal

688
00:26:58,799 --> 00:27:01,440
to two and out of b equal one you get so

689
00:27:01,440 --> 00:27:03,600
this two one mcrh so this would be an

690
00:27:03,600 --> 00:27:05,760
mclh in which it's hard to find pairwise

691
00:27:05,760 --> 00:27:08,240
collisions like a crh with one bit of

692
00:27:08,240 --> 00:27:10,559
compression but we know that with with

693
00:27:10,559 --> 00:27:12,799
crh if you have one bit of compression

694
00:27:12,799 --> 00:27:14,080
you can basically get any level of

695
00:27:14,080 --> 00:27:16,720
compression that you want by composition

696
00:27:16,720 --> 00:27:18,880
this uh turned out to be quite different

697
00:27:18,880 --> 00:27:21,360
when you're talking about tmcrh

698
00:27:21,360 --> 00:27:23,919
okay so composition if you start having

699
00:27:23,919 --> 00:27:25,200
uh talking about more than pairwise

700
00:27:25,200 --> 00:27:27,360
collisions then composition doesn't work

701
00:27:27,360 --> 00:27:28,559
very well straightforward there are

702
00:27:28,559 --> 00:27:30,799
fancier ways but they all increase the

703
00:27:30,799 --> 00:27:32,080
parameter t

704
00:27:32,080 --> 00:27:33,360
okay so you have to be careful about

705
00:27:33,360 --> 00:27:34,880
both the amount of collision that you're

706
00:27:34,880 --> 00:27:38,480
interested in and the level of shrinkage

707
00:27:38,480 --> 00:27:39,679
okay so

708
00:27:39,679 --> 00:27:41,520
we have this notion and now we can ask

709
00:27:41,520 --> 00:27:42,720
ourselves you know how are these two

710
00:27:42,720 --> 00:27:44,159
notions related

711
00:27:44,159 --> 00:27:46,480
obviously mch is a relaxation but

712
00:27:46,480 --> 00:27:48,799
to what extent

713
00:27:48,799 --> 00:27:49,840
so

714
00:27:49,840 --> 00:27:51,600
i think having studied this notion for a

715
00:27:51,600 --> 00:27:53,200
couple of years now it really looks like

716
00:27:53,200 --> 00:27:55,840
this notion of mcrh is uh significantly

717
00:27:55,840 --> 00:27:58,720
weaker okay and even this just this very

718
00:27:58,720 --> 00:28:00,640
basic composition property is sort of

719
00:28:00,640 --> 00:28:02,080
evidence to that it seems like a

720
00:28:02,080 --> 00:28:05,360
qualitatively uh weaker property

721
00:28:05,360 --> 00:28:08,000
but somewhat surprisingly nevertheless

722
00:28:08,000 --> 00:28:09,520
for many of the key applications that we

723
00:28:09,520 --> 00:28:11,120
have for crh

724
00:28:11,120 --> 00:28:12,880
uh certainly in theory then we can also

725
00:28:12,880 --> 00:28:16,080
do it using mcrh okay so two notable

726
00:28:16,080 --> 00:28:18,000
examples so if you look at constant

727
00:28:18,000 --> 00:28:20,000
rounds statistically hiding commitments

728
00:28:20,000 --> 00:28:22,559
uh work by komogowski and oran and uh

729
00:28:22,559 --> 00:28:25,600
yogev and concurrent work um

730
00:28:25,600 --> 00:28:27,919
by uh joint work with berman degwacker

731
00:28:27,919 --> 00:28:29,840
and uh vasudevan

732
00:28:29,840 --> 00:28:33,279
we showed that mcrah suffice for this

733
00:28:33,279 --> 00:28:35,279
likewise if you're trying to to build

734
00:28:35,279 --> 00:28:37,360
succinct arguments and some some uh

735
00:28:37,360 --> 00:28:39,200
something another killian's result you

736
00:28:39,200 --> 00:28:41,440
can also relax instead of using crh you

737
00:28:41,440 --> 00:28:44,159
can use mcrh shown in the same work by

738
00:28:44,159 --> 00:28:46,720
uh common godzilla and also by bhitansky

739
00:28:46,720 --> 00:28:48,320
client penance

740
00:28:48,320 --> 00:28:49,840
so we see that for many of the

741
00:28:49,840 --> 00:28:51,120
applications

742
00:28:51,120 --> 00:28:52,799
mcrh suffice but it still leaves the

743
00:28:52,799 --> 00:28:54,159
question of you know

744
00:28:54,159 --> 00:28:55,600
how how does the power of these two

745
00:28:55,600 --> 00:28:57,440
objects relate

746
00:28:57,440 --> 00:28:59,279
and what we show in these works is that

747
00:28:59,279 --> 00:29:02,000
actually in in some regimes you can go

748
00:29:02,000 --> 00:29:04,399
from this seemingly weaker notion and

749
00:29:04,399 --> 00:29:06,159
get a full sort of uh

750
00:29:06,159 --> 00:29:07,520
get a crh

751
00:29:07,520 --> 00:29:08,799
okay

752
00:29:08,799 --> 00:29:10,080
so let me sort of tell you what the

753
00:29:10,080 --> 00:29:12,559
results are so the first main result we

754
00:29:12,559 --> 00:29:13,600
consider

755
00:29:13,600 --> 00:29:15,840
three-way mcrae so it's hard to find

756
00:29:15,840 --> 00:29:17,840
three-way collisions and we're assuming

757
00:29:17,840 --> 00:29:19,200
that the amp series that we start off

758
00:29:19,200 --> 00:29:20,960
with oops

759
00:29:20,960 --> 00:29:23,279
has a shrinkage factor which is slightly

760
00:29:23,279 --> 00:29:25,600
more than uh than half so you're

761
00:29:25,600 --> 00:29:27,120
outputting slightly less than half of

762
00:29:27,120 --> 00:29:28,720
the input size

763
00:29:28,720 --> 00:29:31,279
and if you give me such an mcrh then

764
00:29:31,279 --> 00:29:33,520
we're able to show that a crh

765
00:29:33,520 --> 00:29:35,039
standard collision resistant hash

766
00:29:35,039 --> 00:29:37,520
function exists up to some asterisks uh

767
00:29:37,520 --> 00:29:40,159
of up there which i will explain in five

768
00:29:40,159 --> 00:29:42,399
or six slides

769
00:29:42,399 --> 00:29:44,159
okay so we can do something interesting

770
00:29:44,159 --> 00:29:46,799
with three mcrh next question to ask is

771
00:29:46,799 --> 00:29:48,159
what about four

772
00:29:48,159 --> 00:29:50,399
um so for mcrh we can also do something

773
00:29:50,399 --> 00:29:52,480
similar but we need the form create to

774
00:29:52,480 --> 00:29:55,600
have a better shrinkage so it takes

775
00:29:55,600 --> 00:29:58,159
maybe n bits to and over six bits

776
00:29:58,159 --> 00:29:59,200
okay

777
00:29:59,200 --> 00:30:01,120
and if you give me such an mch i can

778
00:30:01,120 --> 00:30:04,240
once again construct the crh

779
00:30:04,240 --> 00:30:05,760
okay so we've managed to handle four

780
00:30:05,760 --> 00:30:07,840
what about five so unfortunately for

781
00:30:07,840 --> 00:30:09,120
five we don't know how to do this so if

782
00:30:09,120 --> 00:30:10,880
you give me a five-way mcoh it's hard to

783
00:30:10,880 --> 00:30:13,120
find five-way collisions

784
00:30:13,120 --> 00:30:14,799
uh with any level of shrinkage even if

785
00:30:14,799 --> 00:30:16,480
you're opening polylogged bits let's say

786
00:30:16,480 --> 00:30:19,440
i don't know how to get similar results

787
00:30:19,440 --> 00:30:21,200
okay which was uh quite annoying we'll

788
00:30:21,200 --> 00:30:23,039
get back to towards dan

789
00:30:23,039 --> 00:30:24,880
uh what we do know how to show is if you

790
00:30:24,880 --> 00:30:27,520
give me any t l m c rh

791
00:30:27,520 --> 00:30:29,279
then we can construct from that a t

792
00:30:29,279 --> 00:30:32,080
prime l prime of c rh where t prime is

793
00:30:32,080 --> 00:30:34,559
less than t so we've reduced the size of

794
00:30:34,559 --> 00:30:37,360
collisions but l prime is larger than l

795
00:30:37,360 --> 00:30:40,000
so we pay in terms of the shrinkage

796
00:30:40,000 --> 00:30:42,159
and the exact uh

797
00:30:42,159 --> 00:30:44,320
parameters for which it works are

798
00:30:44,320 --> 00:30:46,399
a horrible equation that i did not want

799
00:30:46,399 --> 00:30:48,320
to put on the slide it's based on list

800
00:30:48,320 --> 00:30:49,520
decoding balance for read settlement

801
00:30:49,520 --> 00:30:52,000
codes but just as an example to keep so

802
00:30:52,000 --> 00:30:53,520
that you can think of so if you start

803
00:30:53,520 --> 00:30:55,200
off with an mcrh in which it's hard to

804
00:30:55,200 --> 00:30:55,919
find

805
00:30:55,919 --> 00:30:57,919
collisions of size 100 and the

806
00:30:57,919 --> 00:31:00,080
compression is to like uh

807
00:31:00,080 --> 00:31:01,440
you know 10

808
00:31:01,440 --> 00:31:03,600
then we can build from that uh hash

809
00:31:03,600 --> 00:31:04,960
function in which it's hard to find

810
00:31:04,960 --> 00:31:06,720
collisions of size 50 but the

811
00:31:06,720 --> 00:31:10,159
compression is now only to 40

812
00:31:10,159 --> 00:31:12,240
okay

813
00:31:12,240 --> 00:31:13,919
so uh before telling you about how we do

814
00:31:13,919 --> 00:31:15,679
this let me mention some prior work so

815
00:31:15,679 --> 00:31:17,360
the first work that i am aware of that

816
00:31:17,360 --> 00:31:18,159
looked at this notion of

817
00:31:18,159 --> 00:31:20,080
multi-collisions is a work of the jew

818
00:31:20,080 --> 00:31:22,799
which is more kind of practice oriented

819
00:31:22,799 --> 00:31:25,360
and on the theory side the first book is

820
00:31:25,360 --> 00:31:27,519
by komargotsky in the orangev who showed

821
00:31:27,519 --> 00:31:30,159
a connection of this notion of mcrh to a

822
00:31:30,159 --> 00:31:31,840
sort of ramsay-style computational

823
00:31:31,840 --> 00:31:33,919
problem that we're looking at

824
00:31:33,919 --> 00:31:35,840
um after that ironically enough there

825
00:31:35,840 --> 00:31:38,399
was a three-way collision of papers uh

826
00:31:38,399 --> 00:31:39,919
studying mcrh

827
00:31:39,919 --> 00:31:42,480
so uh i already mentioned i guess the

828
00:31:42,480 --> 00:31:44,720
obvious of all of these

829
00:31:44,720 --> 00:31:47,200
and more a little bit more recently

830
00:31:47,200 --> 00:31:49,760
komogoti and you give uh

831
00:31:49,760 --> 00:31:51,279
gave a construction showing how to go

832
00:31:51,279 --> 00:31:53,279
from mcrh

833
00:31:53,279 --> 00:31:55,279
into a notion called distributional

834
00:31:55,279 --> 00:31:57,360
collision-resistant hashing which is a

835
00:31:57,360 --> 00:31:59,200
different sort of relaxation of

836
00:31:59,200 --> 00:32:00,960
collision resistance so

837
00:32:00,960 --> 00:32:03,120
it's basically saying that it may be a

838
00:32:03,120 --> 00:32:05,519
hard it may be easy to find worst case

839
00:32:05,519 --> 00:32:07,279
collisions but it should be hard to find

840
00:32:07,279 --> 00:32:09,360
sort of random collisions

841
00:32:09,360 --> 00:32:11,360
okay so different relaxation but this

842
00:32:11,360 --> 00:32:13,519
well this uh work is the sort of

843
00:32:13,519 --> 00:32:14,880
inspiration or starting point for our

844
00:32:14,880 --> 00:32:16,640
work

845
00:32:16,640 --> 00:32:18,000
okay so let me tell you a little bit

846
00:32:18,000 --> 00:32:20,480
about uh how we do this and let me start

847
00:32:20,480 --> 00:32:22,559
with a sort of bird's eye view of how

848
00:32:22,559 --> 00:32:26,080
it's done and even more basically let's

849
00:32:26,080 --> 00:32:28,159
the technique here is uh sort of i think

850
00:32:28,159 --> 00:32:29,840
very different than from what is common

851
00:32:29,840 --> 00:32:31,519
in cryptography so let me start by

852
00:32:31,519 --> 00:32:33,360
describing what is common and how we

853
00:32:33,360 --> 00:32:34,399
differ

854
00:32:34,399 --> 00:32:36,080
so usually in crypto the way if you want

855
00:32:36,080 --> 00:32:37,679
to move from one cryptographic primitive

856
00:32:37,679 --> 00:32:39,519
to another the way it's done is is the

857
00:32:39,519 --> 00:32:41,279
following so you're trying to move from

858
00:32:41,279 --> 00:32:42,960
uh a to b

859
00:32:42,960 --> 00:32:45,279
so you know you take a you throw in some

860
00:32:45,279 --> 00:32:47,519
algebra specifically some combinatorics

861
00:32:47,519 --> 00:32:49,679
you take you you get the result b and

862
00:32:49,679 --> 00:32:52,799
usually b uses the construction uses a

863
00:32:52,799 --> 00:32:54,240
as some sort of black box just using it

864
00:32:54,240 --> 00:32:56,000
as a subroutine

865
00:32:56,000 --> 00:32:57,760
so that's sort of what you you typically

866
00:32:57,760 --> 00:33:00,240
do and then how do you argue security

867
00:33:00,240 --> 00:33:02,000
you assume

868
00:33:02,000 --> 00:33:04,399
the existence of this red adversary

869
00:33:04,399 --> 00:33:06,000
uh for b

870
00:33:06,000 --> 00:33:07,760
and you use it to construct this green

871
00:33:07,760 --> 00:33:10,399
uh alien adversary for a

872
00:33:10,399 --> 00:33:12,000
and usually

873
00:33:12,000 --> 00:33:13,840
the green adversary will use the red

874
00:33:13,840 --> 00:33:16,399
adversary um as a black box as well and

875
00:33:16,399 --> 00:33:18,480
probably also use uh the construction

876
00:33:18,480 --> 00:33:21,039
the primitive a itself as a black box

877
00:33:21,039 --> 00:33:23,039
so construction that satisfies sort of

878
00:33:23,039 --> 00:33:24,320
this picture is called the fully black

879
00:33:24,320 --> 00:33:25,760
box construction

880
00:33:25,760 --> 00:33:27,679
and if you think about it a very like

881
00:33:27,679 --> 00:33:29,600
very very large majority of construction

882
00:33:29,600 --> 00:33:32,080
and crypto fall into this framework

883
00:33:32,080 --> 00:33:33,120
but here we're going to be doing

884
00:33:33,120 --> 00:33:34,399
something different

885
00:33:34,399 --> 00:33:35,440
okay

886
00:33:35,440 --> 00:33:38,640
so uh here's what we do or like kind of

887
00:33:38,640 --> 00:33:40,480
a bird's-eye view

888
00:33:40,480 --> 00:33:42,640
so we start off with an mcrh

889
00:33:42,640 --> 00:33:44,640
right so it's hard to find a large

890
00:33:44,640 --> 00:33:46,240
conditions

891
00:33:46,240 --> 00:33:49,679
first step we construct a candidate crh

892
00:33:49,679 --> 00:33:51,840
what do i mean by candidates crh a

893
00:33:51,840 --> 00:33:53,679
candidate see rage so either it is a crh

894
00:33:53,679 --> 00:33:56,559
or it is not two options if it is great

895
00:33:56,559 --> 00:33:57,919
we are done

896
00:33:57,919 --> 00:33:59,360
so the more interesting aspect is what

897
00:33:59,360 --> 00:34:01,120
if it is not an uh

898
00:34:01,120 --> 00:34:02,559
not a ch

899
00:34:02,559 --> 00:34:04,240
if it is not a ch there exists an

900
00:34:04,240 --> 00:34:07,799
adversary right

901
00:34:07,919 --> 00:34:10,159
so there's an adversary and what we do

902
00:34:10,159 --> 00:34:12,159
is actually use this adversary in the

903
00:34:12,159 --> 00:34:14,239
construction in order to build a

904
00:34:14,239 --> 00:34:16,879
different crh

905
00:34:16,879 --> 00:34:18,399
okay

906
00:34:18,399 --> 00:34:20,560
so the adversary itself is used inside

907
00:34:20,560 --> 00:34:22,159
the construction not not just inside the

908
00:34:22,159 --> 00:34:24,079
security reduction

909
00:34:24,079 --> 00:34:26,079
um and yeah and so

910
00:34:26,079 --> 00:34:27,679
uh the adversary is used also as a black

911
00:34:27,679 --> 00:34:29,359
box what makes this construction none

912
00:34:29,359 --> 00:34:32,560
back box is that the adversary uh

913
00:34:32,560 --> 00:34:34,079
that we have in the middle might be

914
00:34:34,079 --> 00:34:36,159
using the mcrh in a non-black box way

915
00:34:36,159 --> 00:34:38,719
and we inherit that

916
00:34:38,719 --> 00:34:40,079
okay so this is kind of the the high

917
00:34:40,079 --> 00:34:42,480
level view of the construction and this

918
00:34:42,480 --> 00:34:45,599
proof strategy has some repercussions

919
00:34:45,599 --> 00:34:46,480
so

920
00:34:46,480 --> 00:34:48,399
first of all it's uh it's not

921
00:34:48,399 --> 00:34:50,000
constructive right so if you come and

922
00:34:50,000 --> 00:34:52,079
tell me that you have an mcrh

923
00:34:52,079 --> 00:34:53,520
and you give me you know you give me the

924
00:34:53,520 --> 00:34:56,000
code i will not be able to tell you

925
00:34:56,000 --> 00:34:56,800
you know

926
00:34:56,800 --> 00:34:58,720
here is my crh i can prove to you that

927
00:34:58,720 --> 00:35:00,960
one exists but i cannot specify what it

928
00:35:00,960 --> 00:35:01,760
is

929
00:35:01,760 --> 00:35:02,960
and the reason is you know i have this

930
00:35:02,960 --> 00:35:05,040
candidate crh and maybe that works but

931
00:35:05,040 --> 00:35:06,400
if it doesn't then there's an attack and

932
00:35:06,400 --> 00:35:08,400
i don't know what it is that specifies

933
00:35:08,400 --> 00:35:10,320
my actual series

934
00:35:10,320 --> 00:35:12,400
okay so it's uh it's non-constructive i

935
00:35:12,400 --> 00:35:14,400
can prove that a crh exists but i cannot

936
00:35:14,400 --> 00:35:16,640
sort of point it out to you so that's

937
00:35:16,640 --> 00:35:20,079
one one uh uh issue the second is that

938
00:35:20,079 --> 00:35:22,480
the construction is non-uniform so

939
00:35:22,480 --> 00:35:24,079
recall that usually in cryptography we

940
00:35:24,079 --> 00:35:26,160
model adversaries as non-uniform

941
00:35:26,160 --> 00:35:28,160
circuits and because we are using the

942
00:35:28,160 --> 00:35:30,400
adversary sort of constructively

943
00:35:30,400 --> 00:35:32,480
we inherit the non-uniformity so our

944
00:35:32,480 --> 00:35:35,040
construction itself would be non-uniform

945
00:35:35,040 --> 00:35:36,320
if we're talking about uniform

946
00:35:36,320 --> 00:35:39,520
adversaries then this would go away

947
00:35:39,520 --> 00:35:42,880
um and lastly and uh kind of uh more

948
00:35:42,880 --> 00:35:45,599
technical points because an adversary

949
00:35:45,599 --> 00:35:47,440
you know a typical adversary in crypto

950
00:35:47,440 --> 00:35:49,680
is only required to successfully break

951
00:35:49,680 --> 00:35:52,000
the primitive on infinitely many input

952
00:35:52,000 --> 00:35:54,160
lengths now our construction will only

953
00:35:54,160 --> 00:35:57,680
work on on infinitely many input maps

954
00:35:57,680 --> 00:36:00,640
so we only get infinitely often security

955
00:36:00,640 --> 00:36:02,240
so uh just going back to the result

956
00:36:02,240 --> 00:36:04,400
slide what this asterisk was actually

957
00:36:04,400 --> 00:36:07,359
hiding is that the the crh that we get

958
00:36:07,359 --> 00:36:09,680
is only infinitely often secure and it's

959
00:36:09,680 --> 00:36:11,680
non-uniform

960
00:36:11,680 --> 00:36:14,160
okay so that's uh sort of the high level

961
00:36:14,160 --> 00:36:15,839
that was the bird's eye view let's go uh

962
00:36:15,839 --> 00:36:18,079
sort of the worms i uh level

963
00:36:18,079 --> 00:36:20,240
uh kind of briefly

964
00:36:20,240 --> 00:36:22,079
so i will focus only on the first result

965
00:36:22,079 --> 00:36:24,560
going from three mcoh to crh

966
00:36:24,560 --> 00:36:27,200
so suppose we start off with a 3mcrh

967
00:36:27,200 --> 00:36:30,000
that has this compression factor of l

968
00:36:30,000 --> 00:36:31,599
um we're in addition going to be using

969
00:36:31,599 --> 00:36:32,960
some other

970
00:36:32,960 --> 00:36:35,760
non-cryptographic hash function family g

971
00:36:35,760 --> 00:36:37,680
same input length

972
00:36:37,680 --> 00:36:39,760
and we'll construct a new hash function

973
00:36:39,760 --> 00:36:42,079
family f so g is non-cryptographic it's

974
00:36:42,079 --> 00:36:43,599
based on some algebra or something but

975
00:36:43,599 --> 00:36:45,520
don't worry about it yet we construct

976
00:36:45,520 --> 00:36:47,440
the hash function family f which

977
00:36:47,440 --> 00:36:49,119
basically just consists of the

978
00:36:49,119 --> 00:36:51,599
concatenation of h of x remember h is

979
00:36:51,599 --> 00:36:55,839
the mcrh so h of x comma g of x

980
00:36:55,839 --> 00:36:57,839
okay this is a new hash function family

981
00:36:57,839 --> 00:37:00,640
that we constructed we call it f

982
00:37:00,640 --> 00:37:02,640
and now we ask ourselves you know is f

983
00:37:02,640 --> 00:37:04,560
uh crh

984
00:37:04,560 --> 00:37:06,640
and you know either yes or no if yes

985
00:37:06,640 --> 00:37:08,960
great we can go home so the more

986
00:37:08,960 --> 00:37:10,720
interesting uh

987
00:37:10,720 --> 00:37:11,599
um

988
00:37:11,599 --> 00:37:13,200
answer is when is it when it's when it

989
00:37:13,200 --> 00:37:16,000
is not an uh crh which means that there

990
00:37:16,000 --> 00:37:18,079
is an adversary that breaks it right so

991
00:37:18,079 --> 00:37:19,599
f is playing this role of the candidate

992
00:37:19,599 --> 00:37:20,880
crh

993
00:37:20,880 --> 00:37:23,520
so we have an adversary that breaks f

994
00:37:23,520 --> 00:37:25,040
which basically means that given you

995
00:37:25,040 --> 00:37:26,160
know description of h and the

996
00:37:26,160 --> 00:37:28,240
description of g our adversary is able

997
00:37:28,240 --> 00:37:30,320
to find a pair of distinct inputs that

998
00:37:30,320 --> 00:37:33,440
collide both under h and under g

999
00:37:33,440 --> 00:37:36,320
that's what our adversary does

1000
00:37:36,320 --> 00:37:38,000
and you know for simplicity for this

1001
00:37:38,000 --> 00:37:39,760
talk let's think of the adversary a as

1002
00:37:39,760 --> 00:37:41,520
working on all input links and working

1003
00:37:41,520 --> 00:37:43,920
with probability one handling imperfect

1004
00:37:43,920 --> 00:37:45,760
adversaries requires some additional

1005
00:37:45,760 --> 00:37:47,440
ideas but i won't have time to cover

1006
00:37:47,440 --> 00:37:49,280
that so adversary always works for this

1007
00:37:49,280 --> 00:37:51,200
talk

1008
00:37:51,200 --> 00:37:53,280
okay so here's sort of a naive attempt

1009
00:37:53,280 --> 00:37:55,599
to find use a to find larger collisions

1010
00:37:55,599 --> 00:37:58,320
for uh for for h

1011
00:37:58,320 --> 00:38:00,400
so let's run we're given description of

1012
00:38:00,400 --> 00:38:02,880
h let's run a on some particular choice

1013
00:38:02,880 --> 00:38:07,200
of g we get a collision under uh h

1014
00:38:07,200 --> 00:38:09,359
and now let's run a again using the same

1015
00:38:09,359 --> 00:38:12,000
h but with a different g and that gives

1016
00:38:12,000 --> 00:38:14,800
us a different maybe collision under h

1017
00:38:14,800 --> 00:38:16,640
so that's pretty good we have two sort

1018
00:38:16,640 --> 00:38:18,720
of two collisions we'd like to combine

1019
00:38:18,720 --> 00:38:19,520
them

1020
00:38:19,520 --> 00:38:21,359
so what we basically want is to try to

1021
00:38:21,359 --> 00:38:23,520
find g and g prime so that these two

1022
00:38:23,520 --> 00:38:25,680
pairs collide basically that h of x one

1023
00:38:25,680 --> 00:38:29,760
is equal uh equal to h of x one prime

1024
00:38:29,760 --> 00:38:31,040
and

1025
00:38:31,040 --> 00:38:32,640
you know if you if we are able to find

1026
00:38:32,640 --> 00:38:34,240
such a pair g and g prime then we

1027
00:38:34,240 --> 00:38:37,280
violated the security of h intuitively

1028
00:38:37,280 --> 00:38:38,560
so which means that it should be hard to

1029
00:38:38,560 --> 00:38:40,880
find such g and g prime

1030
00:38:40,880 --> 00:38:42,480
but that means it so we're saying that

1031
00:38:42,480 --> 00:38:43,920
it's hard to find a pair of distinct

1032
00:38:43,920 --> 00:38:46,480
inputs that form a collision so that

1033
00:38:46,480 --> 00:38:48,480
kind of indicates that a itself is

1034
00:38:48,480 --> 00:38:51,359
collision resistant

1035
00:38:51,839 --> 00:38:52,800
okay so

1036
00:38:52,800 --> 00:38:54,320
going into a little bit more detail

1037
00:38:54,320 --> 00:38:56,000
we're going to construct

1038
00:38:56,000 --> 00:38:57,359
using the insecurity of the candidate

1039
00:38:57,359 --> 00:38:59,599
crh we're going to build the crh

1040
00:38:59,599 --> 00:39:02,720
which just works as follow so its domain

1041
00:39:02,720 --> 00:39:03,599
is the

1042
00:39:03,599 --> 00:39:05,760
hash function family g

1043
00:39:05,760 --> 00:39:08,880
and its output is again n minus l bits

1044
00:39:08,880 --> 00:39:11,520
and what we do is just on input little g

1045
00:39:11,520 --> 00:39:13,599
description of a hash function we run

1046
00:39:13,599 --> 00:39:16,000
our adversary get a collision under h

1047
00:39:16,000 --> 00:39:19,200
and output the value of this collision

1048
00:39:19,200 --> 00:39:21,040
okay so this is this is and i claim that

1049
00:39:21,040 --> 00:39:23,440
this is an actual ch honest about coh

1050
00:39:23,440 --> 00:39:26,079
with asterisks

1051
00:39:26,480 --> 00:39:27,920
so let's let's assume that it's that

1052
00:39:27,920 --> 00:39:29,599
it's broken right assume that there is

1053
00:39:29,599 --> 00:39:32,000
an attacker that violates security that

1054
00:39:32,000 --> 00:39:34,320
means that given h this adversary can

1055
00:39:34,320 --> 00:39:36,880
find distinct g and g prime

1056
00:39:36,880 --> 00:39:39,680
for the former collision under this uh

1057
00:39:39,680 --> 00:39:41,280
f sub a this new hash function that

1058
00:39:41,280 --> 00:39:42,800
we've constructed

1059
00:39:42,800 --> 00:39:44,480
so what can we say about this this

1060
00:39:44,480 --> 00:39:46,240
collision that was found

1061
00:39:46,240 --> 00:39:48,160
so you know it's just parsing you know

1062
00:39:48,160 --> 00:39:49,200
if i

1063
00:39:49,200 --> 00:39:51,359
run a on input g i get this collision x1

1064
00:39:51,359 --> 00:39:54,240
x2 it's a collision for the original

1065
00:39:54,240 --> 00:39:56,000
first candidate that we have and when

1066
00:39:56,000 --> 00:39:58,160
running a on input g prime we get a

1067
00:39:58,160 --> 00:40:00,720
different collision x1 prime x2 prime

1068
00:40:00,720 --> 00:40:02,800
and what do we know about these guys so

1069
00:40:02,800 --> 00:40:04,160
because they are collision under the

1070
00:40:04,160 --> 00:40:05,440
original f

1071
00:40:05,440 --> 00:40:07,280
it means you know x1 is different from

1072
00:40:07,280 --> 00:40:11,280
x2 but it collides under both h and g

1073
00:40:11,280 --> 00:40:13,440
and we know that the same the same holds

1074
00:40:13,440 --> 00:40:16,160
for the x one prime and x two prime

1075
00:40:16,160 --> 00:40:19,040
but because we have uh the collision

1076
00:40:19,040 --> 00:40:21,359
under f sub a then we know that h of x

1077
00:40:21,359 --> 00:40:24,640
one is equal to h of x one prime

1078
00:40:24,640 --> 00:40:26,880
okay so we seem to be in fantastic shape

1079
00:40:26,880 --> 00:40:28,720
because we found the four-way collision

1080
00:40:28,720 --> 00:40:29,920
right

1081
00:40:29,920 --> 00:40:31,760
we have that h of x one is equal to h of

1082
00:40:31,760 --> 00:40:33,839
x two equal to x h of x one prime equal

1083
00:40:33,839 --> 00:40:36,000
to h of x two prime

1084
00:40:36,000 --> 00:40:37,200
but should be somewhat suspicious

1085
00:40:37,200 --> 00:40:38,560
because we haven't used any property of

1086
00:40:38,560 --> 00:40:40,079
g yet

1087
00:40:40,079 --> 00:40:41,599
right so the catch is that no one

1088
00:40:41,599 --> 00:40:43,599
guarantees that these four inputs are

1089
00:40:43,599 --> 00:40:44,880
distinct

1090
00:40:44,880 --> 00:40:46,400
for all we know it could be the case for

1091
00:40:46,400 --> 00:40:48,800
example that x1 is equal to x1 prime and

1092
00:40:48,800 --> 00:40:50,960
x2 is equal to x2 prime which is a

1093
00:40:50,960 --> 00:40:53,920
problem we need for them to be distinct

1094
00:40:53,920 --> 00:40:56,560
so looking a little bit more closely

1095
00:40:56,560 --> 00:40:58,160
now notice the property that we have we

1096
00:40:58,160 --> 00:41:00,480
know that g is different from g prime

1097
00:41:00,480 --> 00:41:02,319
but we have a collision

1098
00:41:02,319 --> 00:41:06,000
of both x1 and x2 under g and x1 prime

1099
00:41:06,000 --> 00:41:08,800
and x2 prime under g

1100
00:41:08,800 --> 00:41:11,280
what if we could design our function or

1101
00:41:11,280 --> 00:41:12,960
our function class g

1102
00:41:12,960 --> 00:41:16,000
so that for every distinct pair of x1

1103
00:41:16,000 --> 00:41:19,119
and x2 so for every you know x1 2

1104
00:41:19,119 --> 00:41:21,680
x1 x2 versus x1 prime x2 prime

1105
00:41:21,680 --> 00:41:24,560
there is at most one function g so that

1106
00:41:24,560 --> 00:41:26,640
they forms a collision so that x1 and x2

1107
00:41:26,640 --> 00:41:28,720
are collision under g

1108
00:41:28,720 --> 00:41:31,200
if we could have this property then we

1109
00:41:31,200 --> 00:41:32,720
could never have sort of this case that

1110
00:41:32,720 --> 00:41:34,640
we're worried about

1111
00:41:34,640 --> 00:41:37,520
so the functions g would guarantee this

1112
00:41:37,520 --> 00:41:39,040
so we just need to design g to have this

1113
00:41:39,040 --> 00:41:41,359
property and staring at this property

1114
00:41:41,359 --> 00:41:43,119
for enough time it seems a little bit

1115
00:41:43,119 --> 00:41:45,440
reminiscent of you know stuff from i

1116
00:41:45,440 --> 00:41:47,040
don't know elementary school

1117
00:41:47,040 --> 00:41:47,760
so

1118
00:41:47,760 --> 00:41:49,119
we have this property that if you look

1119
00:41:49,119 --> 00:41:51,200
at any two distinct lines they can

1120
00:41:51,200 --> 00:41:54,640
collide on at most one point

1121
00:41:54,720 --> 00:41:56,720
right so uh

1122
00:41:56,720 --> 00:41:58,720
that is uh the way that we so the way

1123
00:41:58,720 --> 00:42:00,560
that we will design g

1124
00:42:00,560 --> 00:42:06,000
is to take the input x or the pair x1 x2

1125
00:42:06,000 --> 00:42:08,800
um we will view it as lines

1126
00:42:08,800 --> 00:42:10,160
the hash function g will be sort of

1127
00:42:10,160 --> 00:42:12,400
parameterized by a point on the line

1128
00:42:12,400 --> 00:42:14,560
and the evaluation of g on the line is

1129
00:42:14,560 --> 00:42:16,640
outputting the value um on the on the

1130
00:42:16,640 --> 00:42:18,720
line

1131
00:42:18,720 --> 00:42:19,839
okay

1132
00:42:19,839 --> 00:42:22,480
um how am i doing on time

1133
00:42:22,480 --> 00:42:24,240
um you have five minutes five minutes

1134
00:42:24,240 --> 00:42:25,359
okay i mean

1135
00:42:25,359 --> 00:42:26,880
you're standing in between the people

1136
00:42:26,880 --> 00:42:28,560
here in london yeah exactly so i won't

1137
00:42:28,560 --> 00:42:30,560
go into more details

1138
00:42:30,560 --> 00:42:32,800
yeah yeah yeah yeah so i won't go uh as

1139
00:42:32,800 --> 00:42:33,920
i'm standing between you and lunch i

1140
00:42:33,920 --> 00:42:36,240
won't go into more detail but basically

1141
00:42:36,240 --> 00:42:37,680
uh an extension of this you know

1142
00:42:37,680 --> 00:42:39,680
geometric factor finite fields is what

1143
00:42:39,680 --> 00:42:40,960
we use in order to design our hash

1144
00:42:40,960 --> 00:42:42,720
function g and that is how we can

1145
00:42:42,720 --> 00:42:44,319
guarantee that you get at least a

1146
00:42:44,319 --> 00:42:46,800
three-way collision

1147
00:42:46,800 --> 00:42:47,680
okay

1148
00:42:47,680 --> 00:42:50,160
so sort of to just to to

1149
00:42:50,160 --> 00:42:52,000
summarize again the main results we show

1150
00:42:52,000 --> 00:42:54,560
that in in these regimes we can use the

1151
00:42:54,560 --> 00:42:57,520
existence of uh mcrh to get series the

1152
00:42:57,520 --> 00:42:59,920
collision resistant hashing uh with this

1153
00:42:59,920 --> 00:43:02,240
asterisk let me mention maybe just that

1154
00:43:02,240 --> 00:43:04,720
uh for the mo for the general result

1155
00:43:04,720 --> 00:43:06,400
instead of using the lines we use low

1156
00:43:06,400 --> 00:43:08,000
degree polynomials

1157
00:43:08,000 --> 00:43:09,920
and interestingly the property that we

1158
00:43:09,920 --> 00:43:11,680
need from the degree polynomials is

1159
00:43:11,680 --> 00:43:13,200
there is sort of balance on their

1160
00:43:13,200 --> 00:43:15,119
combinatorial dis decoding

1161
00:43:15,119 --> 00:43:17,119
um that's for the sort of more general

1162
00:43:17,119 --> 00:43:19,119
result

1163
00:43:19,119 --> 00:43:20,640
so let me conclude with some open

1164
00:43:20,640 --> 00:43:23,200
questions so you know one thing that

1165
00:43:23,200 --> 00:43:24,640
would be great is to get rid of some of

1166
00:43:24,640 --> 00:43:26,160
these some of these at least annoying

1167
00:43:26,160 --> 00:43:28,319
qualifier so the

1168
00:43:28,319 --> 00:43:29,760
maybe something that it's tempting to do

1169
00:43:29,760 --> 00:43:31,680
is try to get rid of the infinitely

1170
00:43:31,680 --> 00:43:33,760
often by some idea or maybe the fact

1171
00:43:33,760 --> 00:43:35,200
that it's non-constructive something you

1172
00:43:35,200 --> 00:43:37,839
might try to do is try to use a combiner

1173
00:43:37,839 --> 00:43:40,640
or universal construction uh we tried we

1174
00:43:40,640 --> 00:43:42,640
failed but you are encouraged to try as

1175
00:43:42,640 --> 00:43:43,599
well

1176
00:43:43,599 --> 00:43:44,560
um

1177
00:43:44,560 --> 00:43:46,480
as previously mentioned if we start off

1178
00:43:46,480 --> 00:43:48,960
with a five way mcrh we don't have to go

1179
00:43:48,960 --> 00:43:51,359
to to crh we can go to

1180
00:43:51,359 --> 00:43:53,520
i forget whether either four or three

1181
00:43:53,520 --> 00:43:55,200
but we can't sort of go on all the way

1182
00:43:55,200 --> 00:43:57,359
down to a c rh so getting something for

1183
00:43:57,359 --> 00:43:59,599
five would be fantastic after we do that

1184
00:43:59,599 --> 00:44:01,520
we try to handle larger constants and

1185
00:44:01,520 --> 00:44:03,119
eventually even super constant values of

1186
00:44:03,119 --> 00:44:05,200
t that'll be great

1187
00:44:05,200 --> 00:44:07,760
um another thing that's interesting is

1188
00:44:07,760 --> 00:44:08,640
whether

1189
00:44:08,640 --> 00:44:10,640
this uh none these black but non-black

1190
00:44:10,640 --> 00:44:13,040
box techniques are inherent so there was

1191
00:44:13,040 --> 00:44:14,240
uh

1192
00:44:14,240 --> 00:44:15,200
uh

1193
00:44:15,200 --> 00:44:17,680
a result back by uh kamagoti noor and

1194
00:44:17,680 --> 00:44:20,560
yugev that uh sort of showed this but a

1195
00:44:20,560 --> 00:44:22,800
gap was found by bhitansky and dagworker

1196
00:44:22,800 --> 00:44:24,240
so currently we don't know a black box

1197
00:44:24,240 --> 00:44:26,079
separation and we nice sort of

1198
00:44:26,079 --> 00:44:27,440
understand the picture of whether

1199
00:44:27,440 --> 00:44:30,400
non-black box techniques are necessary

1200
00:44:30,400 --> 00:44:32,000
um and the last two are a little bit

1201
00:44:32,000 --> 00:44:34,319
more out there so you know it seems like

1202
00:44:34,319 --> 00:44:36,400
a strange but powerful this in our

1203
00:44:36,400 --> 00:44:38,400
context technique can it be used in

1204
00:44:38,400 --> 00:44:39,520
other settings

1205
00:44:39,520 --> 00:44:41,920
one place in which you know would be

1206
00:44:41,920 --> 00:44:44,000
very tempting to try is to you know

1207
00:44:44,000 --> 00:44:46,079
resolve this uh huge open problem of

1208
00:44:46,079 --> 00:44:47,760
getting collision resistant hashing just

1209
00:44:47,760 --> 00:44:49,760
based on one wayness

1210
00:44:49,760 --> 00:44:51,520
but it looks like our technique is not

1211
00:44:51,520 --> 00:44:54,000
sufficiently strong because all of us

1212
00:44:54,000 --> 00:44:56,240
this technique sort of relativizes

1213
00:44:56,240 --> 00:44:58,400
so the type of oracle separation that

1214
00:44:58,400 --> 00:45:00,640
simon gives also rules out this kind of

1215
00:45:00,640 --> 00:45:02,240
proof technique

1216
00:45:02,240 --> 00:45:03,280
um

1217
00:45:03,280 --> 00:45:05,760
so yeah i think i'll conclude here and

1218
00:45:05,760 --> 00:45:07,760
happy to take any questions

1219
00:45:07,760 --> 00:45:10,720
okay thank you ron

1220
00:45:16,160 --> 00:45:18,160
so we have a few minutes for questions

1221
00:45:18,160 --> 00:45:19,839
please line up to one of the two

1222
00:45:19,839 --> 00:45:23,040
microphones in the audience

1223
00:45:24,880 --> 00:45:27,839
i do not see any questions on so comment

1224
00:45:27,839 --> 00:45:31,000
over here

1225
00:45:32,079 --> 00:45:34,000
okay i think we have a first question

1226
00:45:34,000 --> 00:45:36,400
yeah uh thanks for the talk

1227
00:45:36,400 --> 00:45:39,040
um i wanted to ask about the l parameter

1228
00:45:39,040 --> 00:45:42,160
so basically you showed that uh for

1229
00:45:42,160 --> 00:45:43,760
three collisions

1230
00:45:43,760 --> 00:45:45,680
uh you need something that outputs you

1231
00:45:45,680 --> 00:45:46,800
need a collision you need a hash

1232
00:45:46,800 --> 00:45:48,640
function that outputs less than half of

1233
00:45:48,640 --> 00:45:50,800
the bits right so is this like is there

1234
00:45:50,800 --> 00:45:52,560
a bound on this can we yeah for

1235
00:45:52,560 --> 00:45:53,520
something better okay so our

1236
00:45:53,520 --> 00:45:55,760
construction needs needs this property

1237
00:45:55,760 --> 00:45:57,839
but moreover it's sort of it's related

1238
00:45:57,839 --> 00:45:59,760
to the so if you try to follow our

1239
00:45:59,760 --> 00:46:01,760
technique um

1240
00:46:01,760 --> 00:46:04,640
exactly and try to uh build a better

1241
00:46:04,640 --> 00:46:07,040
function uh class at g

1242
00:46:07,040 --> 00:46:08,400
then you will not be able to you'll be

1243
00:46:08,400 --> 00:46:10,319
sort of our technique the limit to n

1244
00:46:10,319 --> 00:46:12,640
over two is inherent in the technique so

1245
00:46:12,640 --> 00:46:14,480
even if you try some other uh

1246
00:46:14,480 --> 00:46:16,960
this is a simple so relatively simple

1247
00:46:16,960 --> 00:46:18,800
lower bound based on uh the singleton

1248
00:46:18,800 --> 00:46:20,880
bound it shows that if you try to follow

1249
00:46:20,880 --> 00:46:23,359
this approach then uh n over two is

1250
00:46:23,359 --> 00:46:25,839
necessary

1251
00:46:27,119 --> 00:46:29,839
thanks i think if kenny has a question

1252
00:46:29,839 --> 00:46:31,760
yeah maybe you alluded to it but i guess

1253
00:46:31,760 --> 00:46:33,200
for collision resistance you have kind

1254
00:46:33,200 --> 00:46:34,880
of the main extension once you can try

1255
00:46:34,880 --> 00:46:37,440
to compute by one you know like say one

1256
00:46:37,440 --> 00:46:39,839
bit you can save more so here i can see

1257
00:46:39,839 --> 00:46:41,680
that miracle

1258
00:46:41,680 --> 00:46:44,640
has trouble uh hasn't been started yes

1259
00:46:44,640 --> 00:46:46,480
it has and there's a very nice result by

1260
00:46:46,480 --> 00:46:48,800
near and over and yeah showing so they

1261
00:46:48,800 --> 00:46:50,319
were looking sort of more on merkle

1262
00:46:50,319 --> 00:46:51,200
trees

1263
00:46:51,200 --> 00:46:52,160
and

1264
00:46:52,160 --> 00:46:55,119
navy would sort of blow up exponentially

1265
00:46:55,119 --> 00:46:57,200
and i think uh or more than explanation

1266
00:46:57,200 --> 00:46:59,119
and i think uh in the results it blows

1267
00:46:59,119 --> 00:47:00,960
up only exponentially in the depth which

1268
00:47:00,960 --> 00:47:02,560
is not too bad

1269
00:47:02,560 --> 00:47:04,319
um so there's so you're saying that uh

1270
00:47:04,319 --> 00:47:06,079
result but somehow you cannot there are

1271
00:47:06,079 --> 00:47:08,160
there are results but you you pay you

1272
00:47:08,160 --> 00:47:09,760
you pay less than what the eave payment

1273
00:47:09,760 --> 00:47:10,880
would be you pay in terms of like the

1274
00:47:10,880 --> 00:47:12,079
parameter t

1275
00:47:12,079 --> 00:47:15,119
so they change yeah so t increases but

1276
00:47:15,119 --> 00:47:16,960
not as bad as you would you would like

1277
00:47:16,960 --> 00:47:19,119
uh nate we think

1278
00:47:19,119 --> 00:47:20,960
yeah so and this is what i mean so

1279
00:47:20,960 --> 00:47:22,480
you're saying but there is also your

1280
00:47:22,480 --> 00:47:24,559
play with both e and l it's just right

1281
00:47:24,559 --> 00:47:26,000
so that's what you try to sort of do a

1282
00:47:26,000 --> 00:47:28,079
zig zaggy thing where but at least for

1283
00:47:28,079 --> 00:47:29,839
like four five it doesn't work you tried

1284
00:47:29,839 --> 00:47:32,240
obviously and it doesn't work um and

1285
00:47:32,240 --> 00:47:34,079
more generally which we tried to combine

1286
00:47:34,079 --> 00:47:35,839
to do sort of a zigzaggy thing and we

1287
00:47:35,839 --> 00:47:38,000
weren't able to so the loss that you get

1288
00:47:38,000 --> 00:47:40,319
from one is not covered by the other

1289
00:47:40,319 --> 00:47:42,240
but like in terms of

1290
00:47:42,240 --> 00:47:44,240
you know kind of preserving pe some who

1291
00:47:44,240 --> 00:47:46,079
is not natural natural thing right seems

1292
00:47:46,079 --> 00:47:47,359
to change i have no idea how to do

1293
00:47:47,359 --> 00:47:48,400
something that preserves tea it's a

1294
00:47:48,400 --> 00:47:50,960
great question

1295
00:47:51,520 --> 00:47:54,000
yeah any any other questions

1296
00:47:54,000 --> 00:47:55,440
actually like i had a quick question so

1297
00:47:55,440 --> 00:47:56,800
i'm trying to see the intuition here a

1298
00:47:56,800 --> 00:47:59,040
little bit right so um

1299
00:47:59,040 --> 00:48:02,480
if it's easy to find a collision for an

1300
00:48:02,480 --> 00:48:04,240
iterated hash functions then it's easy

1301
00:48:04,240 --> 00:48:05,680
to find

1302
00:48:05,680 --> 00:48:07,040
multi-collisions as well that's this

1303
00:48:07,040 --> 00:48:09,520
result of uh zhu that you mentioned

1304
00:48:09,520 --> 00:48:12,160
so what's the the intuition here i i

1305
00:48:12,160 --> 00:48:14,559
guess um if you say it's easy to find

1306
00:48:14,559 --> 00:48:15,760
collisions but difficult to find

1307
00:48:15,760 --> 00:48:17,280
multi-collisions we're not looking at

1308
00:48:17,280 --> 00:48:19,040
iterated hatches then

1309
00:48:19,040 --> 00:48:21,200
so i think i think somewhat we're not

1310
00:48:21,200 --> 00:48:22,480
looking at iterated hash functions we're

1311
00:48:22,480 --> 00:48:24,880
looking into sort of abstract setting

1312
00:48:24,880 --> 00:48:25,760
um

1313
00:48:25,760 --> 00:48:27,359
and i think it's somewhat different

1314
00:48:27,359 --> 00:48:28,640
because we're saying you know we're

1315
00:48:28,640 --> 00:48:30,160
giving some particular candidate

1316
00:48:30,160 --> 00:48:31,920
collision like candidate closing

1317
00:48:31,920 --> 00:48:33,280
resistance hash function and we're

1318
00:48:33,280 --> 00:48:35,040
saying if it is easy to find collisions

1319
00:48:35,040 --> 00:48:36,720
there it's not that it's easy to find

1320
00:48:36,720 --> 00:48:38,319
multi-collisions with but on the

1321
00:48:38,319 --> 00:48:40,160
contrary we're going to take that attack

1322
00:48:40,160 --> 00:48:41,520
and use that tact to build something

1323
00:48:41,520 --> 00:48:43,520
else that is secure

1324
00:48:43,520 --> 00:48:44,400
um

1325
00:48:44,400 --> 00:48:46,480
so yeah

1326
00:48:46,480 --> 00:48:49,520
yeah and thanks yeah

1327
00:48:49,520 --> 00:48:50,400
um

1328
00:48:50,400 --> 00:48:52,800
i guess

1329
00:48:52,880 --> 00:48:54,880
this is a good time to wrap up the

1330
00:48:54,880 --> 00:48:59,960
session and let's uh thank all speakers

