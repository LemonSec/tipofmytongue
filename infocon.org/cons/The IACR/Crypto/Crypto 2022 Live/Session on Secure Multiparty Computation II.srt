1
00:00:01,040 --> 00:00:04,080
okay recording

2
00:00:07,120 --> 00:00:09,280
okay welcome to the second

3
00:00:09,280 --> 00:00:11,120
secure multi-part computation session

4
00:00:11,120 --> 00:00:13,200
we're gonna start with the first talk

5
00:00:13,200 --> 00:00:16,160
on soft spoken ot quieter oat extension

6
00:00:16,160 --> 00:00:18,960
from small field silent vector oily in

7
00:00:18,960 --> 00:00:21,840
the mini crypt model from lens roy

8
00:00:21,840 --> 00:00:24,880
so let's you can start

9
00:00:28,240 --> 00:00:30,720
i'd like to discuss soft spoken ot a new

10
00:00:30,720 --> 00:00:33,839
ot extension technique

11
00:00:33,920 --> 00:00:35,600
so in a one of two

12
00:00:35,600 --> 00:00:37,360
uh ot

13
00:00:37,360 --> 00:00:39,920
um there are two messages m0 and m1

14
00:00:39,920 --> 00:00:41,600
chosen by a sender

15
00:00:41,600 --> 00:00:44,480
the receiver picks which message mx star

16
00:00:44,480 --> 00:00:46,320
that it wants

17
00:00:46,320 --> 00:00:48,000
but

18
00:00:48,000 --> 00:00:49,360
and it must learn nothing about the

19
00:00:49,360 --> 00:00:50,399
other message

20
00:00:50,399 --> 00:00:52,160
and the sender must not learn which

21
00:00:52,160 --> 00:00:55,038
message was chosen

22
00:00:55,199 --> 00:00:57,360
however i'll be focusing more on random

23
00:00:57,360 --> 00:01:00,079
oblivious transfer where the

24
00:01:00,079 --> 00:01:02,399
messages and the choice bit are chosen

25
00:01:02,399 --> 00:01:05,438
by the protocol itself randomly

26
00:01:05,438 --> 00:01:07,360
and given as outputs instead

27
00:01:07,360 --> 00:01:09,200
so that means it's just some correlated

28
00:01:09,200 --> 00:01:11,760
randomness that is randomized that's

29
00:01:11,760 --> 00:01:13,360
correlated according to the rules of the

30
00:01:13,360 --> 00:01:15,119
ot protocol

31
00:01:15,119 --> 00:01:17,520
so an ot extension what we want to do is

32
00:01:17,520 --> 00:01:19,840
to take a small number of these random

33
00:01:19,840 --> 00:01:22,320
oblivious transfers random

34
00:01:22,320 --> 00:01:23,360
random

35
00:01:23,360 --> 00:01:25,520
we call them base one of two ots and

36
00:01:25,520 --> 00:01:27,280
turn them efficiently into as many

37
00:01:27,280 --> 00:01:30,799
extended ots as you want

38
00:01:32,479 --> 00:01:34,880
uh finally there's also like we can

39
00:01:34,880 --> 00:01:36,159
consider

40
00:01:36,159 --> 00:01:39,600
and choose one ot like n one of no t

41
00:01:39,600 --> 00:01:42,399
where you choose out of n messages um a

42
00:01:42,399 --> 00:01:43,840
sauce book energy supports this but i

43
00:01:43,840 --> 00:01:46,960
will uh skip that for the talk

44
00:01:46,960 --> 00:01:48,000
so okay

45
00:01:48,000 --> 00:01:50,799
um there's also some uh one last kind of

46
00:01:50,799 --> 00:01:51,600
ot

47
00:01:51,600 --> 00:01:53,920
consider all but one oblivious transfer

48
00:01:53,920 --> 00:01:56,320
so for just two ots it just means that

49
00:01:56,320 --> 00:01:58,399
we are choosing the ot we don't want

50
00:01:58,399 --> 00:01:59,920
rather than though t we do want the

51
00:01:59,920 --> 00:02:01,200
message we don't want to receive rather

52
00:02:01,200 --> 00:02:03,119
than the message you do want to receive

53
00:02:03,119 --> 00:02:05,280
um so it makes no difference like glass

54
00:02:05,280 --> 00:02:07,520
half empty or half full like pick the

55
00:02:07,520 --> 00:02:08,800
one you want when you don't it doesn't

56
00:02:08,800 --> 00:02:10,000
make any difference

57
00:02:10,000 --> 00:02:12,319
but uh that's where the general uh

58
00:02:12,319 --> 00:02:14,319
that's what's different about soft pokey

59
00:02:14,319 --> 00:02:16,879
is that once you go to all but one ot

60
00:02:16,879 --> 00:02:19,440
you can um

61
00:02:19,440 --> 00:02:21,280
uh you pick one message you don't

62
00:02:21,280 --> 00:02:24,160
receive out of n of them and you learn

63
00:02:24,160 --> 00:02:25,920
all the uh the receiver picks one

64
00:02:25,920 --> 00:02:27,760
message it doesn't want to receive or

65
00:02:27,760 --> 00:02:31,599
and learns all the other messages so m0

66
00:02:31,599 --> 00:02:34,959
up to mn excluding m delta

67
00:02:34,959 --> 00:02:37,519
um so we follow silent ot and using a

68
00:02:37,519 --> 00:02:39,680
punctuable prf to generate efficiently

69
00:02:39,680 --> 00:02:42,480
all the uh these one all but one ots so

70
00:02:42,480 --> 00:02:45,440
these will be our base cities

71
00:02:45,440 --> 00:02:47,519
all right so that that's the types of

72
00:02:47,519 --> 00:02:48,879
things we use to

73
00:02:48,879 --> 00:02:51,840
base the protocol on then um

74
00:02:51,840 --> 00:02:54,080
internally what um

75
00:02:54,080 --> 00:02:55,840
all ot extension protocols generate they

76
00:02:55,840 --> 00:02:58,159
generate a correlation

77
00:02:58,159 --> 00:03:00,800
call subfield vector only

78
00:03:00,800 --> 00:03:02,720
so it's built up to that starting with

79
00:03:02,720 --> 00:03:05,440
just um ole

80
00:03:05,440 --> 00:03:07,840
so an oblivious transfer oh sorry

81
00:03:07,840 --> 00:03:10,000
oblivious linear evaluation or ole the

82
00:03:10,000 --> 00:03:12,400
sender learns some linear function

83
00:03:12,400 --> 00:03:14,720
f of x equals ux plus v

84
00:03:14,720 --> 00:03:16,720
so they learn the coefficients uv and

85
00:03:16,720 --> 00:03:18,400
then the receiver learns

86
00:03:18,400 --> 00:03:21,760
the evaluation of f at a random point

87
00:03:21,760 --> 00:03:24,159
delta

88
00:03:24,959 --> 00:03:27,360
as well as learning that point delta

89
00:03:27,360 --> 00:03:29,840
so equivalently they learn secret shares

90
00:03:29,840 --> 00:03:33,360
of the product u times delta

91
00:03:33,360 --> 00:03:35,200
um so the structure then is that you

92
00:03:35,200 --> 00:03:37,440
have two entries in this finite field f

93
00:03:37,440 --> 00:03:40,159
they get multiplied

94
00:03:40,159 --> 00:03:43,360
um then next is there's subfield only so

95
00:03:43,360 --> 00:03:44,720
that means that

96
00:03:44,720 --> 00:03:46,879
w v and delta

97
00:03:46,879 --> 00:03:49,519
are in a bigger field whereas u is still

98
00:03:49,519 --> 00:03:51,200
like just a single bit let's say if

99
00:03:51,200 --> 00:03:52,879
that's the subfield

100
00:03:52,879 --> 00:03:53,920
um

101
00:03:53,920 --> 00:03:55,680
and so that uh if that's the case that's

102
00:03:55,680 --> 00:03:58,400
called a subfield only or another way of

103
00:03:58,400 --> 00:04:01,120
looking at it if you view the the

104
00:04:01,120 --> 00:04:03,360
larger field as being like a row vector

105
00:04:03,360 --> 00:04:06,080
then it's uh a single entry times the

106
00:04:06,080 --> 00:04:09,040
whole row vector

107
00:04:09,040 --> 00:04:10,239
sorry

108
00:04:10,239 --> 00:04:12,319
the product of a single entry u times

109
00:04:12,319 --> 00:04:13,680
the whole row vector delta is what they

110
00:04:13,680 --> 00:04:15,599
get secret shears of

111
00:04:15,599 --> 00:04:17,839
then there's vector only which is so the

112
00:04:17,839 --> 00:04:20,560
other way around w v and u become

113
00:04:20,560 --> 00:04:21,519
vectors

114
00:04:21,519 --> 00:04:23,759
and they get multiplied by the same uh

115
00:04:23,759 --> 00:04:25,199
the same delta gets multiplied by all

116
00:04:25,199 --> 00:04:26,320
entries

117
00:04:26,320 --> 00:04:28,960
and then finally there is sub uh

118
00:04:28,960 --> 00:04:31,919
subfield vol some fueled vectorially

119
00:04:31,919 --> 00:04:34,000
where um it can be viewed as like an

120
00:04:34,000 --> 00:04:36,720
outer product each uh entry and u gets

121
00:04:36,720 --> 00:04:38,560
multiplied in each entry of delta to get

122
00:04:38,560 --> 00:04:40,880
these matrices w in view or equivalent

123
00:04:40,880 --> 00:04:42,880
again there it could be just larger

124
00:04:42,880 --> 00:04:46,159
members of a larger smaller field

125
00:04:46,400 --> 00:04:50,960
so uh comparison um how uh suspecting

126
00:04:50,960 --> 00:04:52,880
let's see how spoken ot fits in the main

127
00:04:52,880 --> 00:04:54,840
classes of ot

128
00:04:54,840 --> 00:04:57,440
extensions so the first main category is

129
00:04:57,440 --> 00:04:59,919
the similar ot extension of ikmp and the

130
00:04:59,919 --> 00:05:03,039
protocols that expired so ikmp requires

131
00:05:03,039 --> 00:05:04,080
only

132
00:05:04,080 --> 00:05:06,400
a correlation robust hash function

133
00:05:06,400 --> 00:05:08,000
which is metric key

134
00:05:08,000 --> 00:05:09,600
assumption

135
00:05:09,600 --> 00:05:10,960
and it's also computationally very

136
00:05:10,960 --> 00:05:14,080
efficient however it sends two uh lambda

137
00:05:14,080 --> 00:05:16,320
bits for every ot you generate and in

138
00:05:16,320 --> 00:05:18,479
many applications your communication is

139
00:05:18,479 --> 00:05:19,280
very

140
00:05:19,280 --> 00:05:22,320
costly so a costly

141
00:05:22,320 --> 00:05:24,479
resource and so uh that may be a

142
00:05:24,479 --> 00:05:26,080
bottleneck

143
00:05:26,080 --> 00:05:27,919
so the main alternative has been um

144
00:05:27,919 --> 00:05:29,360
silent ot

145
00:05:29,360 --> 00:05:32,639
uh which is a fairly recent result that

146
00:05:32,639 --> 00:05:34,320
they um

147
00:05:34,320 --> 00:05:37,120
they use a learning parody noise

148
00:05:37,120 --> 00:05:38,880
assumption and are able to get the

149
00:05:38,880 --> 00:05:41,199
communication cost down to

150
00:05:41,199 --> 00:05:43,440
as low as lambda times log of the number

151
00:05:43,440 --> 00:05:44,800
of ots you get

152
00:05:44,800 --> 00:05:47,120
nothing speaking

153
00:05:47,120 --> 00:05:48,800
and

154
00:05:48,800 --> 00:05:50,560
however this

155
00:05:50,560 --> 00:05:53,120
sorry this also uh get they also have

156
00:05:53,120 --> 00:05:56,240
additional capabilities they can um

157
00:05:56,240 --> 00:05:58,240
uh generate a bunch of ots through

158
00:05:58,240 --> 00:06:00,479
silence pre-processing ahead of time but

159
00:06:00,479 --> 00:06:02,400
i will be focusing just on like the

160
00:06:02,400 --> 00:06:03,919
overall cost without considering

161
00:06:03,919 --> 00:06:05,759
pre-processing

162
00:06:05,759 --> 00:06:06,800
their

163
00:06:06,800 --> 00:06:09,280
main drawback comes from this the

164
00:06:09,280 --> 00:06:12,319
computation they need to compute the

165
00:06:12,319 --> 00:06:16,639
syndrome for some uh large linear code

166
00:06:16,639 --> 00:06:18,479
and that typically requires some like

167
00:06:18,479 --> 00:06:20,960
complicated memory access pattern and

168
00:06:20,960 --> 00:06:23,440
possibly like solving linear systems

169
00:06:23,440 --> 00:06:25,360
um

170
00:06:25,360 --> 00:06:26,720
so uh

171
00:06:26,720 --> 00:06:30,240
silent ot is an attempt to bridge this

172
00:06:30,240 --> 00:06:33,120
gap created between these two ranges of

173
00:06:33,120 --> 00:06:34,800
communication efficiency or computation

174
00:06:34,800 --> 00:06:36,080
efficiency

175
00:06:36,080 --> 00:06:38,400
so it's most similar to ikmp it uses

176
00:06:38,400 --> 00:06:40,720
only a correlation robust hash still

177
00:06:40,720 --> 00:06:41,759
but

178
00:06:41,759 --> 00:06:43,360
it exposes a new

179
00:06:43,360 --> 00:06:46,080
communication computation trade-off

180
00:06:46,080 --> 00:06:47,919
so for any parameter this trade-off

181
00:06:47,919 --> 00:06:50,639
parameter k can take any integer value

182
00:06:50,639 --> 00:06:53,120
um and then the communication

183
00:06:53,120 --> 00:06:55,680
gets reduced by a factor of k

184
00:06:55,680 --> 00:06:58,560
and it comes at the cost of using 2 to

185
00:06:58,560 --> 00:07:00,639
the k divided by 2k

186
00:07:00,639 --> 00:07:03,120
times as much computation in the form of

187
00:07:03,120 --> 00:07:05,199
generated bits from a prg

188
00:07:05,199 --> 00:07:06,960
since prgs can be implemented fairly

189
00:07:06,960 --> 00:07:08,000
efficiency

190
00:07:08,000 --> 00:07:09,919
efficiently using like hardware support

191
00:07:09,919 --> 00:07:11,440
for aes this trade-off is often

192
00:07:11,440 --> 00:07:13,919
beneficial

193
00:07:14,720 --> 00:07:16,880
so continuing the comparison of ikmp

194
00:07:16,880 --> 00:07:18,560
here's an overview of the steps for ot

195
00:07:18,560 --> 00:07:20,720
extension

196
00:07:20,720 --> 00:07:23,120
some um first of all we have our base

197
00:07:23,120 --> 00:07:24,479
ots up here

198
00:07:24,479 --> 00:07:26,400
based one of ortiz of them it requires

199
00:07:26,400 --> 00:07:28,000
lambda or member's security primary

200
00:07:28,000 --> 00:07:30,479
again um

201
00:07:30,479 --> 00:07:33,360
mesotis these are then uh just with some

202
00:07:33,360 --> 00:07:35,199
axors they ca just with some xors they

203
00:07:35,199 --> 00:07:36,800
can be converted into

204
00:07:36,800 --> 00:07:37,840
um

205
00:07:37,840 --> 00:07:41,199
vector oils over f2 so a single bit

206
00:07:41,199 --> 00:07:43,520
you have throw these

207
00:07:43,520 --> 00:07:45,599
next de-randomization you can

208
00:07:45,599 --> 00:07:47,919
de-randomize all the use of these vector

209
00:07:47,919 --> 00:07:50,160
overlays to be the same

210
00:07:50,160 --> 00:07:52,160
once they're de-randomized then you can

211
00:07:52,160 --> 00:07:53,599
stack them all side-by-side to get a

212
00:07:53,599 --> 00:07:56,080
subfield vectorially

213
00:07:56,080 --> 00:07:58,319
then finally if you go and look at the

214
00:07:58,319 --> 00:08:01,199
rows of the resulting correlation

215
00:08:01,199 --> 00:08:02,479
and hash them

216
00:08:02,479 --> 00:08:03,520
you get

217
00:08:03,520 --> 00:08:05,360
output random ojs

218
00:08:05,360 --> 00:08:07,280
and you can get as many as you want

219
00:08:07,280 --> 00:08:08,560
just by getting it

220
00:08:08,560 --> 00:08:12,479
extending it to as many rows as you want

221
00:08:12,479 --> 00:08:14,479
so the only place where there's

222
00:08:14,479 --> 00:08:16,720
communication cost in here like after

223
00:08:16,720 --> 00:08:18,400
the initial setup

224
00:08:18,400 --> 00:08:19,199
is

225
00:08:19,199 --> 00:08:21,759
uh this de-randomization step you have

226
00:08:21,759 --> 00:08:22,560
to

227
00:08:22,560 --> 00:08:24,479
do something to reveal something you

228
00:08:24,479 --> 00:08:25,680
have to reveal some information in order

229
00:08:25,680 --> 00:08:27,360
to make all the use the same

230
00:08:27,360 --> 00:08:30,160
the number of uh for in each ot there is

231
00:08:30,160 --> 00:08:32,479
a whole row you have to reveal so it

232
00:08:32,479 --> 00:08:34,399
tossed lambda bits for ot to

233
00:08:34,399 --> 00:08:36,799
de-randomize

234
00:08:36,799 --> 00:08:38,640
soft-spoken ot

235
00:08:38,640 --> 00:08:40,958
is a similar structure but it starts

236
00:08:40,958 --> 00:08:43,760
instead with these all but one ots

237
00:08:43,760 --> 00:08:46,880
um two to the k uh or two to the k minus

238
00:08:46,880 --> 00:08:48,959
one of two to the kots

239
00:08:48,959 --> 00:08:49,760
um

240
00:08:49,760 --> 00:08:53,040
there's a we have a new um vector o e uh

241
00:08:53,040 --> 00:08:54,959
sub field vector early based on

242
00:08:54,959 --> 00:08:56,320
uh this

243
00:08:56,320 --> 00:08:58,480
um all but one ot

244
00:08:58,480 --> 00:08:59,680
um

245
00:08:59,680 --> 00:09:00,959
that

246
00:09:00,959 --> 00:09:02,959
generalizes the ikmp

247
00:09:02,959 --> 00:09:04,240
vol

248
00:09:04,240 --> 00:09:05,839
and then um

249
00:09:05,839 --> 00:09:07,680
again we do the derandomization and hash

250
00:09:07,680 --> 00:09:09,360
and so on

251
00:09:09,360 --> 00:09:11,120
but the trick is that now

252
00:09:11,120 --> 00:09:11,920
um

253
00:09:11,920 --> 00:09:13,519
there's because each of these is

254
00:09:13,519 --> 00:09:16,080
outputting k bits at a time we only need

255
00:09:16,080 --> 00:09:18,640
to lambda by k of them

256
00:09:18,640 --> 00:09:20,480
and then that means we only need to

257
00:09:20,480 --> 00:09:21,600
divide

258
00:09:21,600 --> 00:09:25,680
derandomize lambda by k bits of

259
00:09:25,680 --> 00:09:26,800
u

260
00:09:26,800 --> 00:09:27,760
every

261
00:09:27,760 --> 00:09:29,920
ot

262
00:09:29,920 --> 00:09:31,760
so reduces the communication by a factor

263
00:09:31,760 --> 00:09:34,000
of k

264
00:09:34,080 --> 00:09:35,600
all right let's see in more detail how

265
00:09:35,600 --> 00:09:37,279
these steps work

266
00:09:37,279 --> 00:09:38,880
um

267
00:09:38,880 --> 00:09:41,120
so in uh the

268
00:09:41,120 --> 00:09:43,760
way you can convert ot into a vole

269
00:09:43,760 --> 00:09:47,040
uh you can xor the bits input bits

270
00:09:47,040 --> 00:09:49,200
uh xor the two messages together and

271
00:09:49,200 --> 00:09:52,399
choose delta v x star

272
00:09:52,399 --> 00:09:53,680
um

273
00:09:53,680 --> 00:09:56,640
and then this this this is uh yeah this

274
00:09:56,640 --> 00:09:58,800
is of old but equivalently we'd write it

275
00:09:58,800 --> 00:10:01,040
in terms of the all but one just to make

276
00:10:01,040 --> 00:10:03,440
it more consistent with this uh spoken

277
00:10:03,440 --> 00:10:07,040
so this is equivalent

278
00:10:07,360 --> 00:10:09,920
so you can see this is a vole because

279
00:10:09,920 --> 00:10:13,360
well either delta is zero in which case

280
00:10:13,360 --> 00:10:16,000
x star is one and then w and v are equal

281
00:10:16,000 --> 00:10:17,200
so it's just

282
00:10:17,200 --> 00:10:19,360
w is m1 is v

283
00:10:19,360 --> 00:10:20,640
or they're

284
00:10:20,640 --> 00:10:22,000
delta is one

285
00:10:22,000 --> 00:10:23,839
um in which case x star is zero and then

286
00:10:23,839 --> 00:10:25,519
they're different by

287
00:10:25,519 --> 00:10:28,959
u they're m zero x r1

288
00:10:28,959 --> 00:10:31,199
um

289
00:10:31,360 --> 00:10:33,200
all right so let's plot what this

290
00:10:33,200 --> 00:10:36,240
computation looks like

291
00:10:36,560 --> 00:10:38,320
all the variables are defined as like

292
00:10:38,320 --> 00:10:40,720
linear functions of the messages

293
00:10:40,720 --> 00:10:43,519
some product of for each

294
00:10:43,519 --> 00:10:45,040
of the two options of the message it's a

295
00:10:45,040 --> 00:10:46,959
product of some value coefficient as a

296
00:10:46,959 --> 00:10:48,560
function of x with that corresponding

297
00:10:48,560 --> 00:10:50,880
message

298
00:10:51,120 --> 00:10:52,320
um

299
00:10:52,320 --> 00:10:54,240
however to make nice diagrams out of

300
00:10:54,240 --> 00:10:55,279
this

301
00:10:55,279 --> 00:10:57,839
we need to make signs so that

302
00:10:57,839 --> 00:10:59,360
and replace addition possibly with

303
00:10:59,360 --> 00:11:00,399
subtraction

304
00:11:00,399 --> 00:11:02,640
in order to make it um use real numbers

305
00:11:02,640 --> 00:11:04,880
like the graph is required it needs um

306
00:11:04,880 --> 00:11:06,800
so i just pick the ones that make the

307
00:11:06,800 --> 00:11:08,320
algebra work out and it doesn't really

308
00:11:08,320 --> 00:11:11,440
matter which you picked

309
00:11:11,519 --> 00:11:13,600
um so you can see that

310
00:11:13,600 --> 00:11:14,959
uh u

311
00:11:14,959 --> 00:11:16,000
is

312
00:11:16,000 --> 00:11:17,440
this linear function

313
00:11:17,440 --> 00:11:19,600
here and uh sorry v is this linear

314
00:11:19,600 --> 00:11:21,279
function here and u is always minus one

315
00:11:21,279 --> 00:11:22,880
times the message

316
00:11:22,880 --> 00:11:25,680
now w is also written as like a linear

317
00:11:25,680 --> 00:11:27,519
function

318
00:11:27,519 --> 00:11:28,399
um

319
00:11:28,399 --> 00:11:31,120
and you can see that its linear function

320
00:11:31,120 --> 00:11:32,720
is always is

321
00:11:32,720 --> 00:11:34,320
zero at delta here so in this example

322
00:11:34,320 --> 00:11:35,760
delta is one

323
00:11:35,760 --> 00:11:38,320
so it is only depends on message zero

324
00:11:38,320 --> 00:11:41,040
not message one

325
00:11:41,040 --> 00:11:44,880
um this is the fact that w has a root at

326
00:11:44,880 --> 00:11:46,000
uh

327
00:11:46,000 --> 00:11:49,680
delta is what lets the receiver compute

328
00:11:49,680 --> 00:11:54,479
w without knowing the message m delta

329
00:11:54,959 --> 00:11:58,160
um finally we get the you can check that

330
00:11:58,160 --> 00:12:00,320
this satisfies the volt correlation

331
00:12:00,320 --> 00:12:02,560
by seeing that

332
00:12:02,560 --> 00:12:04,480
um

333
00:12:04,480 --> 00:12:06,320
by checking they see like uh the

334
00:12:06,320 --> 00:12:08,399
difference between these two lines w and

335
00:12:08,399 --> 00:12:11,680
v is always minus one which is one which

336
00:12:11,680 --> 00:12:15,680
is delta times u which is minus one here

337
00:12:15,680 --> 00:12:17,839
so

338
00:12:17,839 --> 00:12:19,279
that's iknp

339
00:12:19,279 --> 00:12:21,600
now let's see how this works if we make

340
00:12:21,600 --> 00:12:24,160
it use a larger field as a soft spoken

341
00:12:24,160 --> 00:12:26,000
ot

342
00:12:26,000 --> 00:12:27,680
so again these messages are like a

343
00:12:27,680 --> 00:12:29,680
single bit now but

344
00:12:29,680 --> 00:12:31,120
now they're combined in a more

345
00:12:31,120 --> 00:12:32,720
complicated they'll be combined in a

346
00:12:32,720 --> 00:12:34,320
more complicated way

347
00:12:34,320 --> 00:12:36,480
so first of all you

348
00:12:36,480 --> 00:12:39,440
since it was just these sum overall

349
00:12:39,440 --> 00:12:40,720
like you know is the same coefficient

350
00:12:40,720 --> 00:12:42,240
for all of them let's take it to be the

351
00:12:42,240 --> 00:12:43,680
negative the sum of the messages so

352
00:12:43,680 --> 00:12:45,760
minus one the whole way

353
00:12:45,760 --> 00:12:47,200
um

354
00:12:47,200 --> 00:12:48,639
v

355
00:12:48,639 --> 00:12:51,040
zero one that seems like a pattern x

356
00:12:51,040 --> 00:12:53,279
times mx

357
00:12:53,279 --> 00:12:56,000
delta we need a root at x equals delta

358
00:12:56,000 --> 00:12:59,839
so let's make it be x minus delta

359
00:13:01,440 --> 00:13:02,450
and then finally

360
00:13:02,450 --> 00:13:04,160
[Music]

361
00:13:04,160 --> 00:13:04,880
so

362
00:13:04,880 --> 00:13:07,760
in this example delta equals three

363
00:13:07,760 --> 00:13:10,880
uh then finally we can see again that v

364
00:13:10,880 --> 00:13:11,760
uh

365
00:13:11,760 --> 00:13:14,079
w minus v is like minus three which is

366
00:13:14,079 --> 00:13:16,560
the same thing as delta times u because

367
00:13:16,560 --> 00:13:18,839
u is minus one and delta is

368
00:13:18,839 --> 00:13:21,279
three so this is or you can check the

369
00:13:21,279 --> 00:13:22,800
algebra but like this is like a visual

370
00:13:22,800 --> 00:13:26,000
proof of the the vector ole's

371
00:13:26,000 --> 00:13:29,279
um correlation

372
00:13:29,920 --> 00:13:32,000
um so once we have this vector only the

373
00:13:32,000 --> 00:13:34,480
next step is the de-randomization so

374
00:13:34,480 --> 00:13:36,000
it's the randomization is well-known

375
00:13:36,000 --> 00:13:38,079
technique that turns some of the outputs

376
00:13:38,079 --> 00:13:40,560
of the correlated randomness into inputs

377
00:13:40,560 --> 00:13:41,680
instead

378
00:13:41,680 --> 00:13:43,839
so in this case we can use it to control

379
00:13:43,839 --> 00:13:46,399
u from the vole and change it to the u

380
00:13:46,399 --> 00:13:49,600
we want so the sender

381
00:13:49,600 --> 00:13:51,279
computes correction c that's just the

382
00:13:51,279 --> 00:13:52,399
difference from

383
00:13:52,399 --> 00:13:54,160
what it got and what it wanted

384
00:13:54,160 --> 00:13:56,079
and gives it a receiver and then the

385
00:13:56,079 --> 00:13:59,360
receiver multiplies it by delta

386
00:13:59,360 --> 00:14:02,320
in uh in order to correct the

387
00:14:02,320 --> 00:14:05,360
result to make it match

388
00:14:08,720 --> 00:14:11,040
uh so the next step in icanp is to

389
00:14:11,040 --> 00:14:13,040
somehow combine all these

390
00:14:13,040 --> 00:14:14,800
f2

391
00:14:14,800 --> 00:14:18,000
voles into one f2 lambda bowl

392
00:14:18,000 --> 00:14:20,480
so we can write all these out

393
00:14:20,480 --> 00:14:22,399
these separate volt correlations out

394
00:14:22,399 --> 00:14:24,079
here

395
00:14:24,079 --> 00:14:26,079
and we want to we first need to

396
00:14:26,079 --> 00:14:28,160
derandomize all these use

397
00:14:28,160 --> 00:14:31,839
u vectors to be the same

398
00:14:33,360 --> 00:14:35,600
um

399
00:14:35,760 --> 00:14:38,399
yeah so uh so that each entry and u will

400
00:14:38,399 --> 00:14:40,560
only be one bit long so once you do this

401
00:14:40,560 --> 00:14:43,600
it will just be u1 here rather these are

402
00:14:43,600 --> 00:14:45,839
all now the same u vector

403
00:14:45,839 --> 00:14:48,399
then you can stack them all side by side

404
00:14:48,399 --> 00:14:49,360
and get

405
00:14:49,360 --> 00:14:51,120
this outer product structure just like

406
00:14:51,120 --> 00:14:54,250
we wanted for a subfield bowl

407
00:14:54,250 --> 00:14:57,199
[Music]

408
00:14:57,199 --> 00:15:00,160
i saw spoken ot then is very similar but

409
00:15:00,160 --> 00:15:02,079
since now um

410
00:15:02,079 --> 00:15:04,880
these deltas are in a

411
00:15:04,880 --> 00:15:07,440
larger field we can take a smaller

412
00:15:07,440 --> 00:15:08,720
number of them and stack them side by

413
00:15:08,720 --> 00:15:10,839
side together so we only need lambda by

414
00:15:10,839 --> 00:15:13,279
k of them stacked side by side together

415
00:15:13,279 --> 00:15:15,040
and again since u is one bit each that's

416
00:15:15,040 --> 00:15:18,399
lambda by k it's for ot

417
00:15:20,399 --> 00:15:22,079
the final step is the same between the

418
00:15:22,079 --> 00:15:24,399
two protocols the vole outputs are

419
00:15:24,399 --> 00:15:26,959
hashed to get the ot messages so there's

420
00:15:26,959 --> 00:15:28,399
like two cases

421
00:15:28,399 --> 00:15:31,040
um either u which will be the output

422
00:15:31,040 --> 00:15:34,079
choice bit or the ot is zero

423
00:15:34,079 --> 00:15:35,360
in which case

424
00:15:35,360 --> 00:15:40,079
um since v and w uh since uh w equals um

425
00:15:40,079 --> 00:15:43,279
v plus u delta w and v will be equal so

426
00:15:43,279 --> 00:15:46,240
then m x star m zero will be m zero

427
00:15:46,240 --> 00:15:47,680
they'll match

428
00:15:47,680 --> 00:15:50,639
or in the other case u will be one

429
00:15:50,639 --> 00:15:52,000
and then um

430
00:15:52,000 --> 00:15:54,320
the uh these two will be different

431
00:15:54,320 --> 00:15:56,160
they'll be offset by delta from each

432
00:15:56,160 --> 00:15:58,639
other but then w minus delta will be

433
00:15:58,639 --> 00:15:59,759
equal to v

434
00:15:59,759 --> 00:16:02,320
and so m x star when x star is one

435
00:16:02,320 --> 00:16:05,279
matches m one

436
00:16:05,279 --> 00:16:07,600
however there's one uh kind of funny

437
00:16:07,600 --> 00:16:09,759
thing going on here which is that this

438
00:16:09,759 --> 00:16:11,040
is the sender

439
00:16:11,040 --> 00:16:12,639
yeah it was the one who received a

440
00:16:12,639 --> 00:16:13,839
single message and found out which

441
00:16:13,839 --> 00:16:17,440
message so that's because in iknp

442
00:16:17,440 --> 00:16:18,720
um

443
00:16:18,720 --> 00:16:21,040
the parties switch roles when they do ot

444
00:16:21,040 --> 00:16:23,040
extension the base ot sender becomes the

445
00:16:23,040 --> 00:16:25,120
extension roti receiver

446
00:16:25,120 --> 00:16:27,360
so i'm going to continue using sender

447
00:16:27,360 --> 00:16:28,800
and receiver to refer to their roles as

448
00:16:28,800 --> 00:16:32,800
base ots rather than extended ots

449
00:16:33,920 --> 00:16:35,839
all right so that's how uh the

450
00:16:35,839 --> 00:16:38,240
semi-honest ot extension protocols work

451
00:16:38,240 --> 00:16:40,720
soft-spoken ikmp

452
00:16:40,720 --> 00:16:42,160
but um

453
00:16:42,160 --> 00:16:43,360
there's also a question of malicious

454
00:16:43,360 --> 00:16:45,040
security

455
00:16:45,040 --> 00:16:46,399
so so far these protocols are only

456
00:16:46,399 --> 00:16:48,480
actually secure in the semi-honest model

457
00:16:48,480 --> 00:16:50,079
when the base ot

458
00:16:50,079 --> 00:16:50,959
sender

459
00:16:50,959 --> 00:16:52,480
behaves correctly we get the correct

460
00:16:52,480 --> 00:16:55,120
result which is outer uh we get if we

461
00:16:55,120 --> 00:16:57,279
call this like correlation here

462
00:16:57,279 --> 00:16:59,120
we get the correct result it's you know

463
00:16:59,120 --> 00:17:01,680
outer product of u's and deltas

464
00:17:01,680 --> 00:17:03,680
or you can write out with like when u is

465
00:17:03,680 --> 00:17:05,199
one that's delta's in a row and other

466
00:17:05,199 --> 00:17:07,919
rows and zeros

467
00:17:07,919 --> 00:17:10,000
um and there's never any like mix of

468
00:17:10,000 --> 00:17:11,679
like some a row having some deltas and

469
00:17:11,679 --> 00:17:13,119
some node else when you're looking at

470
00:17:13,119 --> 00:17:15,599
like the difference between w and v

471
00:17:15,599 --> 00:17:17,199
so this is what happens ot extender

472
00:17:17,199 --> 00:17:19,039
behaves correctly however if they

473
00:17:19,039 --> 00:17:21,839
de-randomize the use incorrectly

474
00:17:21,839 --> 00:17:23,839
then they could get something else in

475
00:17:23,839 --> 00:17:25,359
particular they could derail something

476
00:17:25,359 --> 00:17:26,559
they can de-randomize them to be

477
00:17:26,559 --> 00:17:27,760
whatever they want they could

478
00:17:27,760 --> 00:17:29,360
re-randomize them to be an identity

479
00:17:29,360 --> 00:17:30,480
matrix

480
00:17:30,480 --> 00:17:32,480
so then um

481
00:17:32,480 --> 00:17:35,120
on the diagonal of this uh

482
00:17:35,120 --> 00:17:37,280
you get like in this sorry the first row

483
00:17:37,280 --> 00:17:38,960
of w minus v only depends on delta one

484
00:17:38,960 --> 00:17:40,640
the second one only depends on delta two

485
00:17:40,640 --> 00:17:43,120
and so on

486
00:17:43,280 --> 00:17:44,799
so what that uh

487
00:17:44,799 --> 00:17:47,039
now the trouble is that if you do this

488
00:17:47,039 --> 00:17:48,080
for

489
00:17:48,080 --> 00:17:49,840
now that you hash it and you use it for

490
00:17:49,840 --> 00:17:52,559
ot extension there's only one bit of

491
00:17:52,559 --> 00:17:53,600
entropy

492
00:17:53,600 --> 00:17:55,679
like if i know if i'm the ot extension

493
00:17:55,679 --> 00:17:57,200
center i know

494
00:17:57,200 --> 00:17:58,320
v

495
00:17:58,320 --> 00:17:59,039
and

496
00:17:59,039 --> 00:18:01,440
w minus v is only depends on on the

497
00:18:01,440 --> 00:18:02,720
first row let's say it only depends on

498
00:18:02,720 --> 00:18:04,640
this one bit delta one so there's only

499
00:18:04,640 --> 00:18:06,240
one bit of an entropy in what the other

500
00:18:06,240 --> 00:18:09,760
party has so if i learn their messages i

501
00:18:09,760 --> 00:18:10,960
can brute force just like two

502
00:18:10,960 --> 00:18:13,679
possibilities to solve for delta one

503
00:18:13,679 --> 00:18:15,200
now i could do that independently for

504
00:18:15,200 --> 00:18:16,720
each row and learn their whole secret

505
00:18:16,720 --> 00:18:19,280
delta and after that i know everything i

506
00:18:19,280 --> 00:18:21,919
need to know to attack every

507
00:18:21,919 --> 00:18:23,919
subsequent ot generated by the ot

508
00:18:23,919 --> 00:18:26,919
extension

509
00:18:29,360 --> 00:18:31,919
so to fix this uh the standard technique

510
00:18:31,919 --> 00:18:34,480
is a consistency check so i'll present a

511
00:18:34,480 --> 00:18:36,400
simplified version of soft spoken zot

512
00:18:36,400 --> 00:18:37,840
the software going to use consistency

513
00:18:37,840 --> 00:18:39,360
check which is similar to the os

514
00:18:39,360 --> 00:18:41,600
consistency check

515
00:18:41,600 --> 00:18:44,320
so the idea is that um

516
00:18:44,320 --> 00:18:46,960
since the

517
00:18:47,120 --> 00:18:48,559
uh sorry a consistency checked part of

518
00:18:48,559 --> 00:18:50,400
the correlation they have is revealed

519
00:18:50,400 --> 00:18:51,919
and checked while the rest is kept

520
00:18:51,919 --> 00:18:53,840
secret

521
00:18:53,840 --> 00:18:56,080
so the idea is that since um the

522
00:18:56,080 --> 00:18:58,640
correlation is preserved by multiplying

523
00:18:58,640 --> 00:19:01,679
on the left by a

524
00:19:01,679 --> 00:19:02,799
matrix

525
00:19:02,799 --> 00:19:04,400
um

526
00:19:04,400 --> 00:19:07,360
the uh you can yes multiplication by a

527
00:19:07,360 --> 00:19:08,880
matrix preserves the subfield volt

528
00:19:08,880 --> 00:19:12,000
correlation the

529
00:19:12,000 --> 00:19:13,679
you can reveal only a piece of the

530
00:19:13,679 --> 00:19:14,960
information to have it check the whole

531
00:19:14,960 --> 00:19:16,559
thing

532
00:19:16,559 --> 00:19:20,240
um so more precisely

533
00:19:21,760 --> 00:19:24,160
the ot extension receiver sorry the base

534
00:19:24,160 --> 00:19:25,679
base ot receiver generates a random

535
00:19:25,679 --> 00:19:27,280
matrix r

536
00:19:27,280 --> 00:19:29,200
which they send to the sender

537
00:19:29,200 --> 00:19:31,840
and the sender computes r times its

538
00:19:31,840 --> 00:19:33,600
inputs and sends them back

539
00:19:33,600 --> 00:19:35,679
now if they're behaving honestly

540
00:19:35,679 --> 00:19:36,559
these

541
00:19:36,559 --> 00:19:39,200
uh the uh the correlation not to hold on

542
00:19:39,200 --> 00:19:40,799
r times these things these consistency

543
00:19:40,799 --> 00:19:42,640
checked versions of v and u

544
00:19:42,640 --> 00:19:44,080
so the

545
00:19:44,080 --> 00:19:46,320
uh the receiver will abort if they do

546
00:19:46,320 --> 00:19:48,080
not match

547
00:19:48,080 --> 00:19:50,480
and then this reveals so if r has s rows

548
00:19:50,480 --> 00:19:52,080
this reveals s rows of information about

549
00:19:52,080 --> 00:19:54,960
uv and w so you burn the last s rows in

550
00:19:54,960 --> 00:19:58,320
order to preserve security

551
00:19:58,880 --> 00:20:00,799
so s controls how likely it is they can

552
00:20:00,799 --> 00:20:02,799
break the scheme

553
00:20:02,799 --> 00:20:04,559
so there are several malicious ot

554
00:20:04,559 --> 00:20:06,320
extensions based on consistency checking

555
00:20:06,320 --> 00:20:08,400
and here's a comparison of soft spoken t

556
00:20:08,400 --> 00:20:09,440
of these

557
00:20:09,440 --> 00:20:11,600
so

558
00:20:11,600 --> 00:20:14,480
to make it apples to apples comparison i

559
00:20:14,480 --> 00:20:15,919
uh these are all

560
00:20:15,919 --> 00:20:18,320
as they're all displayed as like how

561
00:20:18,320 --> 00:20:20,159
they would be if were instantiated for

562
00:20:20,159 --> 00:20:21,840
one of two ot even though some of these

563
00:20:21,840 --> 00:20:23,360
papers are originally for like one of

564
00:20:23,360 --> 00:20:25,120
not

565
00:20:25,120 --> 00:20:27,520
so first of all there's the ot extension

566
00:20:27,520 --> 00:20:30,080
uh the result of uh

567
00:20:30,080 --> 00:20:31,520
ccg

568
00:20:31,520 --> 00:20:33,440
um they are actually the most similar to

569
00:20:33,440 --> 00:20:36,320
soft spoken ot um they just have a we

570
00:20:36,320 --> 00:20:37,760
have a slightly tighter proof than they

571
00:20:37,760 --> 00:20:39,840
do that lets us give a slightly better

572
00:20:39,840 --> 00:20:40,960
bound here

573
00:20:40,960 --> 00:20:42,080
and

574
00:20:42,080 --> 00:20:44,720
uh so you just send half the information

575
00:20:44,720 --> 00:20:46,720
for the consistency check otherwise it's

576
00:20:46,720 --> 00:20:48,720
very simple

577
00:20:48,720 --> 00:20:50,960
um

578
00:20:51,840 --> 00:20:54,640
uh they consist uh because

579
00:20:54,640 --> 00:20:56,720
unfortunately we found some flaws in the

580
00:20:56,720 --> 00:20:57,600
uh

581
00:20:57,600 --> 00:21:00,400
previous work however so for os

582
00:21:00,400 --> 00:21:02,640
um the flaw was just in a proof

583
00:21:02,640 --> 00:21:04,000
um and the special case of the

584
00:21:04,000 --> 00:21:06,480
soft-spoken ots proof applies to os and

585
00:21:06,480 --> 00:21:08,159
so it's still secure

586
00:21:08,159 --> 00:21:09,360
um

587
00:21:09,360 --> 00:21:12,320
we found a couple of attacks on kos

588
00:21:12,320 --> 00:21:13,280
um

589
00:21:13,280 --> 00:21:15,679
they uh one that

590
00:21:15,679 --> 00:21:17,760
only violates an internal dilemma and is

591
00:21:17,760 --> 00:21:20,080
like completely impractical another

592
00:21:20,080 --> 00:21:21,360
that's also

593
00:21:21,360 --> 00:21:22,799
completely impractical but not quite as

594
00:21:22,799 --> 00:21:24,080
impractical

595
00:21:24,080 --> 00:21:25,760
um and actually attacks the protocol

596
00:21:25,760 --> 00:21:28,799
itself but it only um works for a weird

597
00:21:28,799 --> 00:21:30,799
special case where the security

598
00:21:30,799 --> 00:21:34,158
parameter is a multiple of 20.

599
00:21:35,039 --> 00:21:37,760
but finally there's a pss

600
00:21:37,760 --> 00:21:38,960
they

601
00:21:38,960 --> 00:21:40,320
that result was

602
00:21:40,320 --> 00:21:41,570
more flawed

603
00:21:41,570 --> 00:21:43,280
[Music]

604
00:21:43,280 --> 00:21:45,120
and in particular for uh lambda equals

605
00:21:45,120 --> 00:21:46,240
128

606
00:21:46,240 --> 00:21:48,480
we can break pss of probability to the

607
00:21:48,480 --> 00:21:52,159
minus uh sorry 1 over 256 using only 2

608
00:21:52,159 --> 00:21:55,760
to the 18 hash evaluations

609
00:21:56,000 --> 00:21:57,679
so we implemented sas spoken ot in the

610
00:21:57,679 --> 00:22:00,000
libote library and benchmarked it to

611
00:22:00,000 --> 00:22:02,240
compare with leading ot protocols

612
00:22:02,240 --> 00:22:04,799
the parties are each run single threaded

613
00:22:04,799 --> 00:22:06,640
uh with each party on its own core of a

614
00:22:06,640 --> 00:22:07,760
dual core

615
00:22:07,760 --> 00:22:10,000
processor we emulated

616
00:22:10,000 --> 00:22:12,159
network settings of localhost where

617
00:22:12,159 --> 00:22:14,799
bandwidth is unlimited lan which has a

618
00:22:14,799 --> 00:22:16,880
one millisecond latency and one gigabit

619
00:22:16,880 --> 00:22:18,799
connection and when with a 40

620
00:22:18,799 --> 00:22:21,039
millisecond latency and 100 megabits

621
00:22:21,039 --> 00:22:22,480
bandwidth

622
00:22:22,480 --> 00:22:24,320
the times are for generating a 10

623
00:22:24,320 --> 00:22:27,919
million ots so in each column the the

624
00:22:27,919 --> 00:22:30,000
first place is bolded and the second

625
00:22:30,000 --> 00:22:32,080
place is underlined

626
00:22:32,080 --> 00:22:33,919
so in the lan and local host settings

627
00:22:33,919 --> 00:22:36,240
soft spoken ot

628
00:22:36,240 --> 00:22:37,760
is significantly better than the other

629
00:22:37,760 --> 00:22:39,600
protocols

630
00:22:39,600 --> 00:22:41,919
however in the land setting uh soft

631
00:22:41,919 --> 00:22:44,640
spoken ot takes second second place to

632
00:22:44,640 --> 00:22:47,360
uh silver which is a particularly

633
00:22:47,360 --> 00:22:49,919
efficient version of silent ot

634
00:22:49,919 --> 00:22:52,159
the overhead of these version protocols

635
00:22:52,159 --> 00:22:53,760
and which is the secure setting are

636
00:22:53,760 --> 00:22:55,200
fairly low

637
00:22:55,200 --> 00:22:57,760
as you can see

638
00:22:57,840 --> 00:23:01,039
also uh there's a plot of the same data

639
00:23:01,039 --> 00:23:01,919
um

640
00:23:01,919 --> 00:23:03,360
you can see uh

641
00:23:03,360 --> 00:23:05,520
that there's on a log scale of

642
00:23:05,520 --> 00:23:08,080
nanoseconds per ot so say in the land

643
00:23:08,080 --> 00:23:09,840
setting it's a fairly significant

644
00:23:09,840 --> 00:23:12,080
improvement for soft spoken ot but in

645
00:23:12,080 --> 00:23:14,720
the win it's uh a little bit worse it's

646
00:23:14,720 --> 00:23:18,240
a few times worse than silver

647
00:23:19,760 --> 00:23:21,200
all right so thank you for attending my

648
00:23:21,200 --> 00:23:24,559
talk on ot extension

649
00:23:29,520 --> 00:23:30,480
thank you

650
00:23:30,480 --> 00:23:32,320
if you have any questions please come at

651
00:23:32,320 --> 00:23:36,200
the front and the microphones

652
00:23:43,360 --> 00:23:45,200
hi uh thanks for the talk

653
00:23:45,200 --> 00:23:46,320
uh i

654
00:23:46,320 --> 00:23:47,919
just had a question about those uh

655
00:23:47,919 --> 00:23:50,240
graphs that you showed when you were i

656
00:23:50,240 --> 00:23:52,159
think you were explaining like the deer

657
00:23:52,159 --> 00:23:53,840
randomization step or maybe it was the

658
00:23:53,840 --> 00:23:56,000
uh this is the goal

659
00:23:56,000 --> 00:23:57,919
yeah could you could you explain those

660
00:23:57,919 --> 00:24:00,159
graphs

661
00:24:00,159 --> 00:24:03,760
like the the graphs showing lines yeah

662
00:24:03,760 --> 00:24:05,919
uh sure yeah yeah like what was going on

663
00:24:05,919 --> 00:24:07,840
on the previous slide too

664
00:24:07,840 --> 00:24:09,760
so uh this is the

665
00:24:09,760 --> 00:24:11,919
whole graph for the soft spoken ot

666
00:24:11,919 --> 00:24:14,640
um so each of these lines represents

667
00:24:14,640 --> 00:24:15,520
um

668
00:24:15,520 --> 00:24:17,840
the the coefficient of the course of the

669
00:24:17,840 --> 00:24:18,960
message

670
00:24:18,960 --> 00:24:19,840
so

671
00:24:19,840 --> 00:24:23,520
uh like u this value u is calculated as

672
00:24:23,520 --> 00:24:25,679
um the negative the sum of the messages

673
00:24:25,679 --> 00:24:27,520
so that's negative one times each

674
00:24:27,520 --> 00:24:29,919
message okay so you can say each message

675
00:24:29,919 --> 00:24:32,480
goes as a position here and then the

676
00:24:32,480 --> 00:24:33,760
corresponding

677
00:24:33,760 --> 00:24:35,360
y-coordinate is what do you multiply the

678
00:24:35,360 --> 00:24:38,320
message by in order to then sum and get

679
00:24:38,320 --> 00:24:39,279
u

680
00:24:39,279 --> 00:24:41,360
and then for v it's like you multiply

681
00:24:41,360 --> 00:24:42,080
each

682
00:24:42,080 --> 00:24:44,159
by like you know this message three by

683
00:24:44,159 --> 00:24:46,880
three and then sum to get v and so on

684
00:24:46,880 --> 00:24:48,480
um

685
00:24:48,480 --> 00:24:49,520
okay

686
00:24:49,520 --> 00:24:52,880
and then the difference

687
00:24:52,880 --> 00:24:55,600
so the difference v minus w is going to

688
00:24:55,600 --> 00:24:58,159
be the sum of the individual differences

689
00:24:58,159 --> 00:24:59,120
here

690
00:24:59,120 --> 00:25:01,440
so uh the say message two gets

691
00:25:01,440 --> 00:25:04,080
multiplied so in v it gets multiplied by

692
00:25:04,080 --> 00:25:06,320
two and then w gets multiplied by minus

693
00:25:06,320 --> 00:25:08,159
one the difference there is going to be

694
00:25:08,159 --> 00:25:10,000
minus three oh yeah

695
00:25:10,000 --> 00:25:11,760
thank you and it's the same for

696
00:25:11,760 --> 00:25:13,360
everything as you can see

697
00:25:13,360 --> 00:25:15,840
all right

698
00:25:16,400 --> 00:25:17,919
so there's no time for another question

699
00:25:17,919 --> 00:25:21,520
let's thank once again

700
00:25:27,520 --> 00:25:30,480
next we have rex rex are you online can

701
00:25:30,480 --> 00:25:33,360
you start your screen

702
00:25:33,760 --> 00:25:38,279
yes i'm online uh just a second

703
00:25:42,880 --> 00:25:47,360
okay uh do you see my lights

704
00:25:47,840 --> 00:25:51,120
yes and it's recording

705
00:25:51,120 --> 00:25:52,480
okay

706
00:25:52,480 --> 00:25:54,400
so we're moving to the next talk of the

707
00:25:54,400 --> 00:25:57,120
session on maliciously secure massively

708
00:25:57,120 --> 00:25:58,960
parallel computation for all but one

709
00:25:58,960 --> 00:26:00,159
corruptions

710
00:26:00,159 --> 00:26:02,320
from rex fernando

711
00:26:02,320 --> 00:26:04,320
yuval jealous

712
00:26:04,320 --> 00:26:07,120
ilan komakorsky and lenzi and trex is

713
00:26:07,120 --> 00:26:09,600
going to give the talk

714
00:26:09,600 --> 00:26:10,960
okay

715
00:26:10,960 --> 00:26:13,120
just the second

716
00:26:13,120 --> 00:26:15,120
don't start yet we don't see your slides

717
00:26:15,120 --> 00:26:17,600
on the screen

718
00:26:17,600 --> 00:26:19,120
oh really uh

719
00:26:19,120 --> 00:26:21,200
no no you don't have to do anything it's

720
00:26:21,200 --> 00:26:22,880
for the room here

721
00:26:22,880 --> 00:26:25,760
i see okay just let me know when

722
00:26:25,760 --> 00:26:29,080
when you're ready

723
00:27:00,159 --> 00:27:02,080
okay you can start now

724
00:27:02,080 --> 00:27:04,840
okay sounds good uh so thanks for the

725
00:27:04,840 --> 00:27:06,880
introduction uh

726
00:27:06,880 --> 00:27:08,640
like antigone said i'm going to be

727
00:27:08,640 --> 00:27:11,120
talking about how to achieve malicious

728
00:27:11,120 --> 00:27:12,960
security for massively parallel

729
00:27:12,960 --> 00:27:15,360
computations in the setting of all but

730
00:27:15,360 --> 00:27:17,760
one corruptions

731
00:27:17,760 --> 00:27:19,760
and this is joint work with my

732
00:27:19,760 --> 00:27:23,600
co-authors yuval ilan and elaine

733
00:27:23,600 --> 00:27:27,520
so the topic of our work is the type of

734
00:27:27,520 --> 00:27:30,080
like large-scale distributed computation

735
00:27:30,080 --> 00:27:32,080
that happens commonly inside data

736
00:27:32,080 --> 00:27:34,559
centers and so a correct characteristic

737
00:27:34,559 --> 00:27:36,640
of this computation is that the the data

738
00:27:36,640 --> 00:27:40,000
set is is very large and this data set

739
00:27:40,000 --> 00:27:42,000
is distributed among many different

740
00:27:42,000 --> 00:27:44,559
machines and each machine has

741
00:27:44,559 --> 00:27:46,480
a very limited local space in proportion

742
00:27:46,480 --> 00:27:49,279
to the data set and the most like

743
00:27:49,279 --> 00:27:52,240
probably the most famous example of such

744
00:27:52,240 --> 00:27:54,480
a such a distributed algorithm is the

745
00:27:54,480 --> 00:27:56,159
google search algorithm

746
00:27:56,159 --> 00:27:58,000
so the question that that we're

747
00:27:58,000 --> 00:28:00,080
interested in studying is what's

748
00:28:00,080 --> 00:28:02,080
possible in terms of security for these

749
00:28:02,080 --> 00:28:05,120
types of distributed algorithms

750
00:28:05,120 --> 00:28:07,679
so uh we're going to

751
00:28:07,679 --> 00:28:11,120
so so we work in a model which is called

752
00:28:11,120 --> 00:28:13,279
the massively parallel computation model

753
00:28:13,279 --> 00:28:15,919
by the mpc model

754
00:28:15,919 --> 00:28:17,679
and this model has been used by the

755
00:28:17,679 --> 00:28:20,720
algorithms community in many past papers

756
00:28:20,720 --> 00:28:22,320
to study the types of distributed

757
00:28:22,320 --> 00:28:23,840
computation that i was just talking

758
00:28:23,840 --> 00:28:24,799
about

759
00:28:24,799 --> 00:28:26,880
and at a high level the model works as

760
00:28:26,880 --> 00:28:29,279
follows so there's a large input string

761
00:28:29,279 --> 00:28:32,080
and the zip string is divided among many

762
00:28:32,080 --> 00:28:34,080
different machines each with

763
00:28:34,080 --> 00:28:36,960
a local space s that's much smaller than

764
00:28:36,960 --> 00:28:38,799
the input x

765
00:28:38,799 --> 00:28:40,799
and these parties run a protocol and the

766
00:28:40,799 --> 00:28:43,200
output of the protocol is defined to be

767
00:28:43,200 --> 00:28:45,520
the concatenation of the local outputs

768
00:28:45,520 --> 00:28:47,840
of each machine

769
00:28:47,840 --> 00:28:50,640
and so the two main important

770
00:28:50,640 --> 00:28:53,120
constraints that the model imposes are

771
00:28:53,120 --> 00:28:55,120
first that the local space of each

772
00:28:55,120 --> 00:28:57,600
machine s is equal to n to the epsilon

773
00:28:57,600 --> 00:29:00,640
where n is the the input size and

774
00:29:00,640 --> 00:29:02,480
epsilon is some arbitrarily small

775
00:29:02,480 --> 00:29:03,840
constant

776
00:29:03,840 --> 00:29:06,240
and a corollary of this uh this

777
00:29:06,240 --> 00:29:08,399
constraint is that we assume that

778
00:29:08,399 --> 00:29:10,960
communication costs space so this is a

779
00:29:10,960 --> 00:29:12,960
communication bounded model and in

780
00:29:12,960 --> 00:29:16,240
particular there's no broadcast

781
00:29:16,240 --> 00:29:19,679
um so the second constraint is that we

782
00:29:19,679 --> 00:29:21,279
we're going to say a protocol is

783
00:29:21,279 --> 00:29:23,919
efficient in this model if it takes

784
00:29:23,919 --> 00:29:25,919
if the round complexity is small so it

785
00:29:25,919 --> 00:29:27,360
should take long

786
00:29:27,360 --> 00:29:30,639
logarithmic rounds or less

787
00:29:32,399 --> 00:29:35,039
so what the question that we want to ask

788
00:29:35,039 --> 00:29:37,679
in in our work is whether or not it's

789
00:29:37,679 --> 00:29:39,520
possible to achieve security in this

790
00:29:39,520 --> 00:29:41,600
model akin to what classical secure

791
00:29:41,600 --> 00:29:43,840
computation protocols provide so in

792
00:29:43,840 --> 00:29:45,840
classical secure computation

793
00:29:45,840 --> 00:29:47,679
there's you know we assume that some

794
00:29:47,679 --> 00:29:49,360
subset of the pro the parties are

795
00:29:49,360 --> 00:29:50,720
malicious let's say that they're

796
00:29:50,720 --> 00:29:52,960
controlled by a polynomial time

797
00:29:52,960 --> 00:29:56,399
adversary and we want to protect the

798
00:29:56,399 --> 00:29:58,000
honest inputs and outputs from this

799
00:29:58,000 --> 00:30:00,240
adversary we want the adversary not to

800
00:30:00,240 --> 00:30:01,679
be able to learn anything about the

801
00:30:01,679 --> 00:30:03,760
outputs and we don't want the adversary

802
00:30:03,760 --> 00:30:07,120
to be able to tamper with the outputs

803
00:30:07,120 --> 00:30:11,279
and so security is is uh formalized in

804
00:30:11,279 --> 00:30:14,320
this in these classical works by giving

805
00:30:14,320 --> 00:30:16,399
a simulator which uh

806
00:30:16,399 --> 00:30:18,320
does not have direct access to the

807
00:30:18,320 --> 00:30:20,399
honest parties and instead interacts

808
00:30:20,399 --> 00:30:23,360
with an ideal functionality and we say

809
00:30:23,360 --> 00:30:24,799
that

810
00:30:24,799 --> 00:30:26,480
that a protocol is secure if there is

811
00:30:26,480 --> 00:30:29,360
such a simulator that can basically

812
00:30:29,360 --> 00:30:31,679
produce an out an outcome in the ideal

813
00:30:31,679 --> 00:30:33,360
world that's indistinguishable from the

814
00:30:33,360 --> 00:30:36,600
real world

815
00:30:36,960 --> 00:30:39,360
okay so uh

816
00:30:39,360 --> 00:30:41,440
so so like i said the question that we

817
00:30:41,440 --> 00:30:44,399
want to ask is can we uh can we achieve

818
00:30:44,399 --> 00:30:45,360
this

819
00:30:45,360 --> 00:30:48,320
definition of security in our model

820
00:30:48,320 --> 00:30:50,480
um so recall there are two efficiency

821
00:30:50,480 --> 00:30:53,360
requirements uh limited local space for

822
00:30:53,360 --> 00:30:55,360
each machine or each party

823
00:30:55,360 --> 00:30:58,159
and limited rounds

824
00:30:58,159 --> 00:30:59,840
and so the question is can we achieve

825
00:30:59,840 --> 00:31:02,000
security while respecting these

826
00:31:02,000 --> 00:31:05,039
requirements as much as possible

827
00:31:05,039 --> 00:31:08,080
and so the first natural question is uh

828
00:31:08,080 --> 00:31:10,399
that that everyone should ask probably

829
00:31:10,399 --> 00:31:11,440
is that

830
00:31:11,440 --> 00:31:13,360
you know there's a large body of classic

831
00:31:13,360 --> 00:31:15,600
work on classical secure computation and

832
00:31:15,600 --> 00:31:17,919
you know do any of these works apply in

833
00:31:17,919 --> 00:31:19,200
this model

834
00:31:19,200 --> 00:31:20,559
and in general the answer is

835
00:31:20,559 --> 00:31:22,559
unfortunately no because

836
00:31:22,559 --> 00:31:25,600
uh essentially almost all uh previous

837
00:31:25,600 --> 00:31:28,240
work relies on on a simultaneous

838
00:31:28,240 --> 00:31:30,960
broadcast round where in this round

839
00:31:30,960 --> 00:31:33,120
every party sends and receives messages

840
00:31:33,120 --> 00:31:35,840
from every other party

841
00:31:35,840 --> 00:31:38,240
and this so this violates uh the space

842
00:31:38,240 --> 00:31:40,320
constraints for our protocol

843
00:31:40,320 --> 00:31:42,559
and this is actually not surprising

844
00:31:42,559 --> 00:31:44,480
because

845
00:31:44,480 --> 00:31:46,720
most of these previous works give

846
00:31:46,720 --> 00:31:49,200
general purpose compilers for any uh

847
00:31:49,200 --> 00:31:51,039
polynomial time functionality and it's

848
00:31:51,039 --> 00:31:53,519
actually not known whether our this this

849
00:31:53,519 --> 00:31:55,519
massively parallel model captures all of

850
00:31:55,519 --> 00:31:57,679
p

851
00:31:58,159 --> 00:32:00,799
so however there is there there has been

852
00:32:00,799 --> 00:32:03,039
a recent line of work uh that started

853
00:32:03,039 --> 00:32:05,279
the study of secure computation in in

854
00:32:05,279 --> 00:32:07,279
this model starting with the work of

855
00:32:07,279 --> 00:32:09,600
channel in 2020

856
00:32:09,600 --> 00:32:12,320
and uh this work shows that in fact you

857
00:32:12,320 --> 00:32:13,600
can take any

858
00:32:13,600 --> 00:32:14,799
insecure

859
00:32:14,799 --> 00:32:16,559
massively parallel protocol and

860
00:32:16,559 --> 00:32:18,880
transform it into a secure version

861
00:32:18,880 --> 00:32:19,679
with

862
00:32:19,679 --> 00:32:22,159
essentially minimal blow up in the space

863
00:32:22,159 --> 00:32:24,799
in the rounds

864
00:32:25,519 --> 00:32:28,480
and this this protocol this compiler

865
00:32:28,480 --> 00:32:30,320
achieves security in the crs model and

866
00:32:30,320 --> 00:32:34,960
it also achieves uh what's called uh

867
00:32:34,960 --> 00:32:38,240
it also works in in the setting of uh

868
00:32:38,240 --> 00:32:40,480
honest majority where we assume that

869
00:32:40,480 --> 00:32:42,640
like less than approximately one-third

870
00:32:42,640 --> 00:32:46,480
of the parties are are corrupted

871
00:32:46,480 --> 00:32:48,399
so there is uh there was a follow-up

872
00:32:48,399 --> 00:32:51,360
work uh by fernando adel which was able

873
00:32:51,360 --> 00:32:54,559
to provide a compiler that extends to

874
00:32:54,559 --> 00:32:56,320
the dishonest majority case where we

875
00:32:56,320 --> 00:32:58,720
assume where we guarantee security even

876
00:32:58,720 --> 00:32:59,519
if

877
00:32:59,519 --> 00:33:00,399
uh

878
00:33:00,399 --> 00:33:02,640
or there's only one honest party

879
00:33:02,640 --> 00:33:05,360
um but unfortunately this this protocol

880
00:33:05,360 --> 00:33:07,760
was only able to be proven secured

881
00:33:07,760 --> 00:33:09,679
secure and in the much weaker

882
00:33:09,679 --> 00:33:12,080
semi-honest setting where the assumption

883
00:33:12,080 --> 00:33:13,760
is that all parties follow the honest

884
00:33:13,760 --> 00:33:16,559
protocol specification exactly

885
00:33:16,559 --> 00:33:20,080
so it's then like it's an important uh

886
00:33:20,080 --> 00:33:21,279
open question

887
00:33:21,279 --> 00:33:23,519
whether uh or not it's possible to

888
00:33:23,519 --> 00:33:26,000
achieve full malicious security for a

889
00:33:26,000 --> 00:33:28,559
dishonest majority

890
00:33:28,559 --> 00:33:31,120
and so to make uh an even

891
00:33:31,120 --> 00:33:33,519
to make a sort of a more complete

892
00:33:33,519 --> 00:33:34,559
picture

893
00:33:34,559 --> 00:33:37,200
um there's also a an important

894
00:33:37,200 --> 00:33:39,360
definition of security that's in between

895
00:33:39,360 --> 00:33:40,960
these two definitions and that's called

896
00:33:40,960 --> 00:33:43,200
semi-malicious security

897
00:33:43,200 --> 00:33:44,960
and the assumption here is that all

898
00:33:44,960 --> 00:33:48,000
parties follow the honest specification

899
00:33:48,000 --> 00:33:49,279
except that they're allowed to choose

900
00:33:49,279 --> 00:33:51,440
randomness maliciously and the reason

901
00:33:51,440 --> 00:33:53,600
this is important is because it's been

902
00:33:53,600 --> 00:33:55,440
used as a

903
00:33:55,440 --> 00:33:57,200
an important building block

904
00:33:57,200 --> 00:33:59,440
in many classical works in achieving

905
00:33:59,440 --> 00:34:02,159
full malicious security

906
00:34:02,159 --> 00:34:03,120
um

907
00:34:03,120 --> 00:34:05,200
so this is the state of the art prior to

908
00:34:05,200 --> 00:34:07,200
our work and there are these important

909
00:34:07,200 --> 00:34:09,440
questions about whether we can achieve

910
00:34:09,440 --> 00:34:11,440
semi-malicious security or fully

911
00:34:11,440 --> 00:34:13,839
malicious security uh in the setting of

912
00:34:13,839 --> 00:34:16,800
all but one corruptions

913
00:34:16,800 --> 00:34:18,480
and so with that i'm going to state our

914
00:34:18,480 --> 00:34:20,560
results so our first result is an

915
00:34:20,560 --> 00:34:21,918
impossibility

916
00:34:21,918 --> 00:34:25,199
um specifically where we show that

917
00:34:25,199 --> 00:34:27,199
it's impossible to get a general-purpose

918
00:34:27,199 --> 00:34:28,800
compiler

919
00:34:28,800 --> 00:34:30,399
that achieves anything stronger than

920
00:34:30,399 --> 00:34:32,320
semi-honest security in the studying of

921
00:34:32,320 --> 00:34:34,239
all the one corruptions

922
00:34:34,239 --> 00:34:35,520
and this

923
00:34:35,520 --> 00:34:37,359
impossibility result actually applies

924
00:34:37,359 --> 00:34:41,759
regardless of the trusted setup used

925
00:34:42,320 --> 00:34:44,159
and our second result is a malicious

926
00:34:44,159 --> 00:34:45,918
secure compiler that works exactly in

927
00:34:45,918 --> 00:34:47,918
these two settings and so the reason

928
00:34:47,918 --> 00:34:50,079
that we're able to do this is we first

929
00:34:50,079 --> 00:34:51,040
observe

930
00:34:51,040 --> 00:34:53,119
that our impossibility result does not

931
00:34:53,119 --> 00:34:55,280
imply this does not apply to the

932
00:34:55,280 --> 00:34:57,839
programmable random oracle model and so

933
00:34:57,839 --> 00:34:59,040
indeed

934
00:34:59,040 --> 00:35:00,839
our compiler is given in this stronger

935
00:35:00,839 --> 00:35:02,880
model and

936
00:35:02,880 --> 00:35:04,480
we're able to achieve the same

937
00:35:04,480 --> 00:35:06,480
efficiency

938
00:35:06,480 --> 00:35:08,720
efficiency properties as previous work

939
00:35:08,720 --> 00:35:11,599
and the assumptions we rely on are

940
00:35:11,599 --> 00:35:14,079
sustained non-interactive arguments

941
00:35:14,079 --> 00:35:16,079
indistinguishability obfuscation fully

942
00:35:16,079 --> 00:35:18,400
homophobic encryption and the learning

943
00:35:18,400 --> 00:35:21,280
with errors assumption

944
00:35:21,839 --> 00:35:24,160
okay so for the rest of the talk uh i'm

945
00:35:24,160 --> 00:35:26,960
first going to give uh i'm trying to i'm

946
00:35:26,960 --> 00:35:29,280
going to give

947
00:35:29,280 --> 00:35:30,880
i'm going to cover the impossibility

948
00:35:30,880 --> 00:35:33,119
result in a little bit more detail

949
00:35:33,119 --> 00:35:35,119
and then

950
00:35:35,119 --> 00:35:37,440
after that i'm going to give an overview

951
00:35:37,440 --> 00:35:39,040
of the techniques that we use to get

952
00:35:39,040 --> 00:35:41,760
malicious security

953
00:35:41,760 --> 00:35:44,560
okay so first the impossibility result

954
00:35:44,560 --> 00:35:46,800
so this uh this result is heavily

955
00:35:46,800 --> 00:35:49,920
inspired by the work of hubichek and wix

956
00:35:49,920 --> 00:35:51,920
from 2014

957
00:35:51,920 --> 00:35:54,800
and were able to use the techniques and

958
00:35:54,800 --> 00:35:57,040
the ideas in their paper in order to

959
00:35:57,040 --> 00:35:59,440
make the following observation

960
00:35:59,440 --> 00:36:03,040
which applies to any any

961
00:36:03,040 --> 00:36:05,680
any a massively parallel protocol

962
00:36:05,680 --> 00:36:08,240
so if you take any such protocol and you

963
00:36:08,240 --> 00:36:10,880
assume that this protocol provides

964
00:36:10,880 --> 00:36:12,720
either semi-malicious security or

965
00:36:12,720 --> 00:36:14,800
malicious security

966
00:36:14,800 --> 00:36:16,560
then we show that it must be the case

967
00:36:16,560 --> 00:36:18,960
that the communication between

968
00:36:18,960 --> 00:36:21,040
the communication sent from the honest

969
00:36:21,040 --> 00:36:23,760
parties to the malicious parties is at

970
00:36:23,760 --> 00:36:25,839
least as large as the output and in the

971
00:36:25,839 --> 00:36:27,359
most general case that means that it

972
00:36:27,359 --> 00:36:29,040
could be at least as large as the input

973
00:36:29,040 --> 00:36:31,440
as well

974
00:36:32,079 --> 00:36:34,000
and we're able to show this

975
00:36:34,000 --> 00:36:34,880
using

976
00:36:34,880 --> 00:36:38,160
very mild cryptographic assumptions

977
00:36:38,160 --> 00:36:40,480
okay so let's think about uh what this

978
00:36:40,480 --> 00:36:42,160
implies in the case of all but run

979
00:36:42,160 --> 00:36:44,000
corruptions so

980
00:36:44,000 --> 00:36:46,320
now we assume that only party one is

981
00:36:46,320 --> 00:36:49,200
honest and let's try to

982
00:36:49,200 --> 00:36:52,079
let's try to analyze this party's uh

983
00:36:52,079 --> 00:36:54,480
communication complexity so let's assume

984
00:36:54,480 --> 00:36:56,560
that there are q rounds and

985
00:36:56,560 --> 00:36:58,800
um by the by the constraints of the

986
00:36:58,800 --> 00:37:01,440
model we know that party one's total

987
00:37:01,440 --> 00:37:03,280
communication or

988
00:37:03,280 --> 00:37:05,359
party one's communication in each round

989
00:37:05,359 --> 00:37:09,280
is bounded above by its space s and then

990
00:37:09,280 --> 00:37:11,119
uh it follows that the total

991
00:37:11,119 --> 00:37:12,560
communication is

992
00:37:12,560 --> 00:37:15,359
in across all rounds is q times s which

993
00:37:15,359 --> 00:37:17,359
again by the limitations of the model is

994
00:37:17,359 --> 00:37:19,119
much less than n

995
00:37:19,119 --> 00:37:22,480
so this of course uh contradicts the the

996
00:37:22,480 --> 00:37:24,720
lower bound on the communication which i

997
00:37:24,720 --> 00:37:27,359
just described

998
00:37:27,359 --> 00:37:29,760
so this is uh like the very high level

999
00:37:29,760 --> 00:37:31,280
outline of how we achieve our

1000
00:37:31,280 --> 00:37:33,119
impossibility result

1001
00:37:33,119 --> 00:37:34,000
um

1002
00:37:34,000 --> 00:37:36,400
and i don't have time to really go into

1003
00:37:36,400 --> 00:37:38,160
detail about how we show this lower

1004
00:37:38,160 --> 00:37:39,040
bound

1005
00:37:39,040 --> 00:37:41,599
but i'll just say that like the

1006
00:37:41,599 --> 00:37:44,000
the main idea that we use is we use the

1007
00:37:44,000 --> 00:37:46,320
semi malicious stimulate simulator in

1008
00:37:46,320 --> 00:37:48,800
order to compress to efficiently

1009
00:37:48,800 --> 00:37:50,800
compress the output of a pseudorandom

1010
00:37:50,800 --> 00:37:52,640
function

1011
00:37:52,640 --> 00:37:54,320
which which contradicts security of the

1012
00:37:54,320 --> 00:37:56,560
prf

1013
00:37:56,560 --> 00:37:58,720
okay so now i'm going to talk about

1014
00:37:58,720 --> 00:38:00,560
malicious security

1015
00:38:00,560 --> 00:38:03,119
and since the time is limited i'm going

1016
00:38:03,119 --> 00:38:07,119
to focus on a specific sub case of

1017
00:38:07,119 --> 00:38:09,119
massively parallel protocols

1018
00:38:09,119 --> 00:38:11,599
namely those where the space

1019
00:38:11,599 --> 00:38:13,920
uh the size of the output is small

1020
00:38:13,920 --> 00:38:15,839
enough that it can fit on the space of a

1021
00:38:15,839 --> 00:38:18,079
single machine

1022
00:38:18,079 --> 00:38:20,000
and uh

1023
00:38:20,000 --> 00:38:21,520
the like the reason i'm going to do this

1024
00:38:21,520 --> 00:38:23,200
is so that we can talk about our

1025
00:38:23,200 --> 00:38:25,440
techniques without uh like without

1026
00:38:25,440 --> 00:38:27,119
working in the random oracle model and

1027
00:38:27,119 --> 00:38:28,960
having to deal with that and at the very

1028
00:38:28,960 --> 00:38:31,119
end i'll talk briefly about how to

1029
00:38:31,119 --> 00:38:33,680
extend to the general case

1030
00:38:33,680 --> 00:38:36,160
so our high-level strategy is the same

1031
00:38:36,160 --> 00:38:38,720
as many other works we're going to take

1032
00:38:38,720 --> 00:38:41,359
a semi-malicious protocol and use some

1033
00:38:41,359 --> 00:38:43,119
techniques and upgrade it to a malicious

1034
00:38:43,119 --> 00:38:44,240
security

1035
00:38:44,240 --> 00:38:46,480
and it turns out that if we restrict

1036
00:38:46,480 --> 00:38:49,520
ourselves to this small output case

1037
00:38:49,520 --> 00:38:51,839
uh the previous work contains a short

1038
00:38:51,839 --> 00:38:53,599
output compiler

1039
00:38:53,599 --> 00:38:55,680
that works for all bowen corruptions and

1040
00:38:55,680 --> 00:38:58,800
and it's pretty easy to show that this

1041
00:38:58,800 --> 00:39:00,400
actually provides semi-malicious

1042
00:39:00,400 --> 00:39:03,359
security in this setting

1043
00:39:04,000 --> 00:39:06,720
okay so let's first quickly talk about

1044
00:39:06,720 --> 00:39:08,400
like the most common strategy for

1045
00:39:08,400 --> 00:39:10,560
getting malicious security starting with

1046
00:39:10,560 --> 00:39:12,720
the semi-malicious protocol so if you

1047
00:39:12,720 --> 00:39:15,359
have a semi-malicious protocol

1048
00:39:15,359 --> 00:39:17,760
in classical secure computation you can

1049
00:39:17,760 --> 00:39:19,920
upgrade to malicious security by using

1050
00:39:19,920 --> 00:39:21,200
zero knowledge

1051
00:39:21,200 --> 00:39:23,680
so in each round you have every party

1052
00:39:23,680 --> 00:39:24,640
prove

1053
00:39:24,640 --> 00:39:26,720
uh in zero knowledge that it behaved

1054
00:39:26,720 --> 00:39:28,400
honestly

1055
00:39:28,400 --> 00:39:30,400
so let's think about what this what

1056
00:39:30,400 --> 00:39:32,320
happens when we try to use this kind of

1057
00:39:32,320 --> 00:39:34,400
technique in our setting

1058
00:39:34,400 --> 00:39:35,200
um

1059
00:39:35,200 --> 00:39:37,440
so consider a protocol with the

1060
00:39:37,440 --> 00:39:39,119
following communication pattern on the

1061
00:39:39,119 --> 00:39:42,400
slide and let's say that now uh party2

1062
00:39:42,400 --> 00:39:44,960
wants to prove that it acted honestly to

1063
00:39:44,960 --> 00:39:46,720
party one

1064
00:39:46,720 --> 00:39:48,720
um so it's going to try to send a proof

1065
00:39:48,720 --> 00:39:50,000
and the proof is going to be with

1066
00:39:50,000 --> 00:39:52,320
respect to some you know public function

1067
00:39:52,320 --> 00:39:55,040
called the next message function

1068
00:39:55,040 --> 00:39:57,280
and this function takes as input

1069
00:39:57,280 --> 00:39:59,839
the private input and randomness of

1070
00:39:59,839 --> 00:40:02,400
party two along with the transcript of

1071
00:40:02,400 --> 00:40:04,400
the messages that party two has received

1072
00:40:04,400 --> 00:40:05,599
so far

1073
00:40:05,599 --> 00:40:08,319
and it's going to output the the message

1074
00:40:08,319 --> 00:40:10,160
that party2 is supposed to send to party

1075
00:40:10,160 --> 00:40:11,280
one

1076
00:40:11,280 --> 00:40:12,960
and so

1077
00:40:12,960 --> 00:40:14,880
party 2 can send a proof

1078
00:40:14,880 --> 00:40:16,880
with respect to this function that it

1079
00:40:16,880 --> 00:40:18,160
acted honestly

1080
00:40:18,160 --> 00:40:20,400
but the problem is that if we get such a

1081
00:40:20,400 --> 00:40:22,400
proof this actually doesn't tell us very

1082
00:40:22,400 --> 00:40:25,040
much at all because

1083
00:40:25,040 --> 00:40:27,760
it could be that the inputs to this

1084
00:40:27,760 --> 00:40:29,839
function themselves are maliciously

1085
00:40:29,839 --> 00:40:31,839
generated so it could be that you know

1086
00:40:31,839 --> 00:40:33,520
some of the preceding parties sent

1087
00:40:33,520 --> 00:40:35,200
malicious messages

1088
00:40:35,200 --> 00:40:37,440
so what that means is that even if party

1089
00:40:37,440 --> 00:40:40,160
two uh acted honestly party two's my

1090
00:40:40,160 --> 00:40:42,880
message could still be malicious

1091
00:40:42,880 --> 00:40:44,000
um

1092
00:40:44,000 --> 00:40:45,200
and so

1093
00:40:45,200 --> 00:40:46,160
uh

1094
00:40:46,160 --> 00:40:48,480
what we actually would want to prove in

1095
00:40:48,480 --> 00:40:49,839
order to

1096
00:40:49,839 --> 00:40:52,400
prove honest behavior for party 1

1097
00:40:52,400 --> 00:40:53,680
is

1098
00:40:53,680 --> 00:40:55,680
we need to prove that party 2 generated

1099
00:40:55,680 --> 00:40:57,359
their message honestly and that all

1100
00:40:57,359 --> 00:40:59,599
messages that party 2 received have also

1101
00:40:59,599 --> 00:41:02,720
been honestly generated

1102
00:41:03,119 --> 00:41:05,440
so the reason why this isn't a problem

1103
00:41:05,440 --> 00:41:08,160
in classical secure protocols is because

1104
00:41:08,160 --> 00:41:10,400
in classical secure protocols you know

1105
00:41:10,400 --> 00:41:12,480
all parties broadcast zero knowledge

1106
00:41:12,480 --> 00:41:14,240
proofs of honest behavior

1107
00:41:14,240 --> 00:41:16,800
every time they send a message so by the

1108
00:41:16,800 --> 00:41:18,560
time party one has received party

1109
00:41:18,560 --> 00:41:20,480
tooth's message it's also received

1110
00:41:20,480 --> 00:41:22,400
messages from all the preceding parties

1111
00:41:22,400 --> 00:41:24,720
in all previous rounds showing honest

1112
00:41:24,720 --> 00:41:28,160
behavior for all these preceding rounds

1113
00:41:28,160 --> 00:41:29,760
so of course this won't work for us

1114
00:41:29,760 --> 00:41:31,280
because that means that

1115
00:41:31,280 --> 00:41:33,280
party one has to receive order of the

1116
00:41:33,280 --> 00:41:35,040
number of parties

1117
00:41:35,040 --> 00:41:37,359
in communication just to verify

1118
00:41:37,359 --> 00:41:39,040
a single message and so that's like

1119
00:41:39,040 --> 00:41:40,720
entirely too much communication for our

1120
00:41:40,720 --> 00:41:43,118
model

1121
00:41:43,599 --> 00:41:46,000
okay so let's try something different

1122
00:41:46,000 --> 00:41:48,560
let's uh imagine that party 2 has

1123
00:41:48,560 --> 00:41:51,300
received proofs of honest behavior from

1124
00:41:51,300 --> 00:41:52,400
[Music]

1125
00:41:52,400 --> 00:41:55,040
all of its preceding parties

1126
00:41:55,040 --> 00:41:57,280
now what would be really nice is if

1127
00:41:57,280 --> 00:42:00,319
party can sort of recursively compose

1128
00:42:00,319 --> 00:42:02,400
their proof so

1129
00:42:02,400 --> 00:42:04,240
it'd be really nice if they can prove

1130
00:42:04,240 --> 00:42:06,079
the following statement like i generated

1131
00:42:06,079 --> 00:42:08,960
my messages honestly and i have proofs

1132
00:42:08,960 --> 00:42:11,280
i've seen proofs which prove honestly of

1133
00:42:11,280 --> 00:42:13,760
the messages which i received

1134
00:42:13,760 --> 00:42:15,520
so if party one is convinced of this

1135
00:42:15,520 --> 00:42:17,839
statement then party one

1136
00:42:17,839 --> 00:42:19,359
can be convinced of

1137
00:42:19,359 --> 00:42:22,160
the honesty of the message

1138
00:42:22,160 --> 00:42:24,800
um so it turns out there's a particular

1139
00:42:24,800 --> 00:42:27,040
type of zero knowledge argument which is

1140
00:42:27,040 --> 00:42:28,640
very well attuned

1141
00:42:28,640 --> 00:42:30,319
to have this kind of recursive

1142
00:42:30,319 --> 00:42:31,680
composition

1143
00:42:31,680 --> 00:42:34,400
and this is called a zk snark

1144
00:42:34,400 --> 00:42:36,319
and the reason why is because first of

1145
00:42:36,319 --> 00:42:38,480
all it's not interactive which means the

1146
00:42:38,480 --> 00:42:41,040
proofs can be recursively composed

1147
00:42:41,040 --> 00:42:43,280
second is that it's succinct which means

1148
00:42:43,280 --> 00:42:44,880
the proofs don't blow up and size when

1149
00:42:44,880 --> 00:42:47,599
being recursively composed

1150
00:42:47,599 --> 00:42:49,119
and finally it's an argument of

1151
00:42:49,119 --> 00:42:51,200
knowledge which means that soundness of

1152
00:42:51,200 --> 00:42:52,880
the proof is preserved under this

1153
00:42:52,880 --> 00:42:56,960
recursively recursive composition

1154
00:42:57,359 --> 00:42:59,200
but it turns out that there's still a

1155
00:42:59,200 --> 00:43:01,040
problem with this approach and that is

1156
00:43:01,040 --> 00:43:01,839
that

1157
00:43:01,839 --> 00:43:04,560
uh every time you recursively compose a

1158
00:43:04,560 --> 00:43:07,359
snark uh you end up losing

1159
00:43:07,359 --> 00:43:09,119
you end up with an exponential loss of

1160
00:43:09,119 --> 00:43:11,200
security for each layer of recursive

1161
00:43:11,200 --> 00:43:12,800
composition

1162
00:43:12,800 --> 00:43:16,079
so uh in general it's fine to compo to

1163
00:43:16,079 --> 00:43:17,839
recursively compose a constant number of

1164
00:43:17,839 --> 00:43:19,200
times but

1165
00:43:19,200 --> 00:43:20,800
anything much more than that and you

1166
00:43:20,800 --> 00:43:21,839
risk

1167
00:43:21,839 --> 00:43:26,079
losing security of your argument system

1168
00:43:26,079 --> 00:43:27,760
so the main like one of the main

1169
00:43:27,760 --> 00:43:29,760
technical parts of our paper is devoted

1170
00:43:29,760 --> 00:43:32,640
to solving this problem um and so i'm

1171
00:43:32,640 --> 00:43:34,880
going to sort of sketch our solution

1172
00:43:34,880 --> 00:43:38,160
here so let's say that we have a that we

1173
00:43:38,160 --> 00:43:40,079
just finished a semi-malicious round of

1174
00:43:40,079 --> 00:43:41,760
communication

1175
00:43:41,760 --> 00:43:44,720
computation and communication

1176
00:43:44,720 --> 00:43:49,520
and now each of the parties has a state

1177
00:43:49,680 --> 00:43:51,920
which contains some you know secret

1178
00:43:51,920 --> 00:43:54,880
state as well as the messages received

1179
00:43:54,880 --> 00:43:57,760
in this round which we assume are public

1180
00:43:57,760 --> 00:43:58,560
um

1181
00:43:58,560 --> 00:44:01,599
so then after after this the parties are

1182
00:44:01,599 --> 00:44:04,319
going to run a sub-protocol

1183
00:44:04,319 --> 00:44:06,240
which we designed and which we're going

1184
00:44:06,240 --> 00:44:08,079
to call the commit and agree

1185
00:44:08,079 --> 00:44:09,520
sub-protocol

1186
00:44:09,520 --> 00:44:12,240
and after this sub-protocol every party

1187
00:44:12,240 --> 00:44:14,400
is going to have a succinct uh

1188
00:44:14,400 --> 00:44:16,720
commitment to every other

1189
00:44:16,720 --> 00:44:19,040
to the entire to the states of every

1190
00:44:19,040 --> 00:44:20,560
party

1191
00:44:20,560 --> 00:44:22,560
as well as openings for their particular

1192
00:44:22,560 --> 00:44:23,599
state

1193
00:44:23,599 --> 00:44:25,440
uh and addition in addition all the

1194
00:44:25,440 --> 00:44:27,599
parties will agree on this commitment so

1195
00:44:27,599 --> 00:44:29,359
the pro the protocol guarantees

1196
00:44:29,359 --> 00:44:30,880
agreement

1197
00:44:30,880 --> 00:44:31,680
um

1198
00:44:31,680 --> 00:44:33,760
and the tools that we use for this uh

1199
00:44:33,760 --> 00:44:35,119
this sub protocol are standard

1200
00:44:35,119 --> 00:44:37,920
cryptographic tools

1201
00:44:37,920 --> 00:44:41,200
so then once all the parties have these

1202
00:44:41,200 --> 00:44:43,839
commitments to everyone's state the

1203
00:44:43,839 --> 00:44:46,319
parties are going to exchange openings

1204
00:44:46,319 --> 00:44:48,640
so what i mean by that is let's say that

1205
00:44:48,640 --> 00:44:50,720
party one sent a

1206
00:44:50,720 --> 00:44:52,400
a message to party two in the

1207
00:44:52,400 --> 00:44:56,160
semi-malicious uh phase of the round

1208
00:44:56,160 --> 00:44:58,560
then in this opening phase party two is

1209
00:44:58,560 --> 00:45:01,280
going to return an opening that shows

1210
00:45:01,280 --> 00:45:03,760
that party two has recorded party one's

1211
00:45:03,760 --> 00:45:06,960
message in some predetermined position j

1212
00:45:06,960 --> 00:45:10,640
which is fixed by the protocol

1213
00:45:11,040 --> 00:45:13,520
and so all parties do the exchange these

1214
00:45:13,520 --> 00:45:15,119
openings for every message sent in the

1215
00:45:15,119 --> 00:45:18,160
semi-malicious phase

1216
00:45:18,160 --> 00:45:20,800
what that means is that now

1217
00:45:20,800 --> 00:45:24,480
party one can prove on its behavior so

1218
00:45:24,480 --> 00:45:27,440
specifically it can take its state

1219
00:45:27,440 --> 00:45:29,920
and it can also take the state from the

1220
00:45:29,920 --> 00:45:32,000
previous round which is presumably it

1221
00:45:32,000 --> 00:45:33,599
saved

1222
00:45:33,599 --> 00:45:35,040
and then in addition it can take the

1223
00:45:35,040 --> 00:45:36,880
openings for all these messages that

1224
00:45:36,880 --> 00:45:39,119
it's sent in this round

1225
00:45:39,119 --> 00:45:40,960
and then it can compute a proof which

1226
00:45:40,960 --> 00:45:43,119
proves both of the following points

1227
00:45:43,119 --> 00:45:44,160
first

1228
00:45:44,160 --> 00:45:45,119
that

1229
00:45:45,119 --> 00:45:47,440
uh it did anonymous computation in other

1230
00:45:47,440 --> 00:45:50,480
words its state was updated honestly

1231
00:45:50,480 --> 00:45:53,200
and second it it uh it communicated

1232
00:45:53,200 --> 00:45:56,240
honestly so it sent messages that it was

1233
00:45:56,240 --> 00:45:57,839
supposed to to the parties that it was

1234
00:45:57,839 --> 00:46:00,160
supposed to and these parties uh stored

1235
00:46:00,160 --> 00:46:03,839
in those messages honestly

1236
00:46:03,839 --> 00:46:04,880
so then

1237
00:46:04,880 --> 00:46:07,760
we can so we can have each party do this

1238
00:46:07,760 --> 00:46:09,359
uh separately

1239
00:46:09,359 --> 00:46:12,640
and then we end up with uh you know m

1240
00:46:12,640 --> 00:46:15,760
different proofs and verifying the

1241
00:46:15,760 --> 00:46:18,319
honesty of this round now reduces to

1242
00:46:18,319 --> 00:46:20,319
just verifying the conjunction of the

1243
00:46:20,319 --> 00:46:22,560
statements underlying these proofs

1244
00:46:22,560 --> 00:46:25,280
so now we can use recursive composition

1245
00:46:25,280 --> 00:46:27,839
to aggregate all these proofs and and

1246
00:46:27,839 --> 00:46:30,319
produce a single uh

1247
00:46:30,319 --> 00:46:33,040
a single assisting proof and if we use a

1248
00:46:33,040 --> 00:46:34,960
large derivative tree we can achieve

1249
00:46:34,960 --> 00:46:37,760
constant a constant depth uh and which

1250
00:46:37,760 --> 00:46:39,440
means that we only have to use recursive

1251
00:46:39,440 --> 00:46:43,520
composition a constant number of times

1252
00:46:43,520 --> 00:46:46,000
okay so that um so that's a high-level

1253
00:46:46,000 --> 00:46:48,560
sketch of our ideas for short output

1254
00:46:48,560 --> 00:46:49,760
protocols

1255
00:46:49,760 --> 00:46:52,000
um so now let me quickly cover what we

1256
00:46:52,000 --> 00:46:54,640
do in terms of long output protocols

1257
00:46:54,640 --> 00:46:56,720
so uh

1258
00:46:56,720 --> 00:46:58,560
the high level idea is essentially the

1259
00:46:58,560 --> 00:47:00,079
same so we're going to take a

1260
00:47:00,079 --> 00:47:01,920
semi-malicious protocol which we

1261
00:47:01,920 --> 00:47:03,760
designed

1262
00:47:03,760 --> 00:47:05,599
which works for long output protocols

1263
00:47:05,599 --> 00:47:08,240
and this is in the random oracle model

1264
00:47:08,240 --> 00:47:09,200
now

1265
00:47:09,200 --> 00:47:11,599
and i'll refer you to the paper for how

1266
00:47:11,599 --> 00:47:13,599
for exactly how we do this

1267
00:47:13,599 --> 00:47:16,240
and so now what we want to do is we want

1268
00:47:16,240 --> 00:47:18,560
to use the same techniques the same

1269
00:47:18,560 --> 00:47:21,440
techniques to compile this protocol to

1270
00:47:21,440 --> 00:47:22,839
achieve malicious

1271
00:47:22,839 --> 00:47:25,839
security um but there's again there's a

1272
00:47:25,839 --> 00:47:28,880
problem so the problem is that since uh

1273
00:47:28,880 --> 00:47:30,319
so this this

1274
00:47:30,319 --> 00:47:31,920
semi-malicious protocol is now in the

1275
00:47:31,920 --> 00:47:33,599
random oracle model

1276
00:47:33,599 --> 00:47:35,520
which so in general if you want to

1277
00:47:35,520 --> 00:47:36,800
compile

1278
00:47:36,800 --> 00:47:39,280
a semi-malicious protocol in the random

1279
00:47:39,280 --> 00:47:41,599
oracle model to a malicious one

1280
00:47:41,599 --> 00:47:44,079
uh you will have to prove statements

1281
00:47:44,079 --> 00:47:46,720
involving random oracle queries

1282
00:47:46,720 --> 00:47:47,520
and

1283
00:47:47,520 --> 00:47:48,960
in terms of snarks this doesn't like

1284
00:47:48,960 --> 00:47:51,920
this doesn't play well with snarks

1285
00:47:51,920 --> 00:47:54,559
there's no known snark that that

1286
00:47:54,559 --> 00:47:56,880
that works in the setting

1287
00:47:56,880 --> 00:47:58,720
so the way that we end up solving this

1288
00:47:58,720 --> 00:48:00,880
problem is we

1289
00:48:00,880 --> 00:48:03,359
we sort of carefully compile this

1290
00:48:03,359 --> 00:48:05,760
semi-malicious protocol in sort of an ad

1291
00:48:05,760 --> 00:48:09,119
hoc way that's specific to our protocol

1292
00:48:09,119 --> 00:48:10,480
and

1293
00:48:10,480 --> 00:48:13,440
this allows us to

1294
00:48:13,440 --> 00:48:15,040
this allows us to achieve malicious

1295
00:48:15,040 --> 00:48:16,240
security

1296
00:48:16,240 --> 00:48:18,400
without ever com without ever proving

1297
00:48:18,400 --> 00:48:20,400
statements involving random oracle

1298
00:48:20,400 --> 00:48:21,760
queries even though the underlying

1299
00:48:21,760 --> 00:48:25,599
protocol does use the random oracle

1300
00:48:25,680 --> 00:48:28,240
and i'll refer you to the paper for this

1301
00:48:28,240 --> 00:48:31,040
for the details on this

1302
00:48:31,040 --> 00:48:32,240
okay so

1303
00:48:32,240 --> 00:48:33,760
i'll just end by

1304
00:48:33,760 --> 00:48:35,920
putting up a slide that restates our

1305
00:48:35,920 --> 00:48:37,040
results

1306
00:48:37,040 --> 00:48:41,319
so that's all i have thank you

1307
00:48:49,119 --> 00:48:50,800
thanks a lot trex

1308
00:48:50,800 --> 00:48:52,640
if you have any questions please comment

1309
00:48:52,640 --> 00:48:54,640
the front and also from zoom you can ask

1310
00:48:54,640 --> 00:48:57,280
either you can unmute yourself or paste

1311
00:48:57,280 --> 00:49:01,079
your question on the chat

1312
00:49:05,040 --> 00:49:07,280
okay so rex can you think quickly what

1313
00:49:07,280 --> 00:49:09,280
is the exact asymptotic overhead of your

1314
00:49:09,280 --> 00:49:09,930
construction

1315
00:49:09,930 --> 00:49:12,969
[Music]

1316
00:49:13,119 --> 00:49:15,200
uh

1317
00:49:15,200 --> 00:49:17,599
so in turn i mean i i don't know the

1318
00:49:17,599 --> 00:49:19,680
exact constants of anything but

1319
00:49:19,680 --> 00:49:20,559
the

1320
00:49:20,559 --> 00:49:23,359
like in general in terms of the security

1321
00:49:23,359 --> 00:49:26,160
parameter and the input size so we have

1322
00:49:26,160 --> 00:49:26,960
a

1323
00:49:26,960 --> 00:49:29,599
space blow-up that's polynomial in the

1324
00:49:29,599 --> 00:49:31,599
security parameter and independent of

1325
00:49:31,599 --> 00:49:33,200
the input size

1326
00:49:33,200 --> 00:49:35,599
and the round blow up is just constant

1327
00:49:35,599 --> 00:49:37,359
it's a it's a multiplicative constant

1328
00:49:37,359 --> 00:49:38,880
these are both multiplicative constant

1329
00:49:38,880 --> 00:49:40,640
blow-ups

1330
00:49:40,640 --> 00:49:41,680
okay

1331
00:49:41,680 --> 00:49:46,839
thank you so let's thank rex again

1332
00:50:33,599 --> 00:50:37,599
okay so next we have lemons

1333
00:50:37,599 --> 00:50:39,200
correctly

1334
00:50:39,200 --> 00:50:41,599
so lemons dynamic and fluid npc for

1335
00:50:41,599 --> 00:50:44,720
dishonest majority from rahul rashuri

1336
00:50:44,720 --> 00:50:46,559
and peter shaw and peter is going to

1337
00:50:46,559 --> 00:50:47,760
give the talk

1338
00:50:47,760 --> 00:50:49,920
okay thanks for the introduction uh so

1339
00:50:49,920 --> 00:50:51,599
i'm going to talk about lemon which is a

1340
00:50:51,599 --> 00:50:54,000
new dynamic and fluid mpc protocol for

1341
00:50:54,000 --> 00:50:55,839
the dishonest majority setting this is

1342
00:50:55,839 --> 00:50:59,359
joint work with rahul returning

1343
00:51:02,319 --> 00:51:04,480
so

1344
00:51:04,480 --> 00:51:06,319
the slides

1345
00:51:06,319 --> 00:51:09,558
not advancing

1346
00:51:15,359 --> 00:51:16,400
sorry

1347
00:51:16,400 --> 00:51:19,400
um

1348
00:51:22,160 --> 00:51:24,160
oh is it advancing on here oh i just

1349
00:51:24,160 --> 00:51:27,520
can't see the laptop

1350
00:51:31,599 --> 00:51:34,599
right

1351
00:51:37,119 --> 00:51:39,440
um

1352
00:51:40,480 --> 00:51:43,839
okay how many foods

1353
00:51:43,839 --> 00:51:46,640
maybe we can go back to this one though

1354
00:51:46,640 --> 00:51:48,879
yeah

1355
00:51:53,760 --> 00:51:58,480
okay but i think the animations uh

1356
00:51:58,480 --> 00:52:01,280
okay i just can't go back

1357
00:52:01,280 --> 00:52:02,480
yeah

1358
00:52:02,480 --> 00:52:03,280
okay

1359
00:52:03,280 --> 00:52:06,800
yeah that's fine i'll carry on anyway

1360
00:52:06,800 --> 00:52:08,240
okay so we're doing secure multiply

1361
00:52:08,240 --> 00:52:09,760
computation where we have a set of

1362
00:52:09,760 --> 00:52:11,760
parties with some private inputs and

1363
00:52:11,760 --> 00:52:13,200
they want to jointly evaluate some

1364
00:52:13,200 --> 00:52:15,599
function across all their inputs

1365
00:52:15,599 --> 00:52:17,599
and in this case we'll be considering

1366
00:52:17,599 --> 00:52:19,440
the function to be an arithmetic circuit

1367
00:52:19,440 --> 00:52:21,040
over

1368
00:52:21,040 --> 00:52:22,720
the integers modulo p for some large

1369
00:52:22,720 --> 00:52:23,920
prime p

1370
00:52:23,920 --> 00:52:25,760
and working in the dishonest majority

1371
00:52:25,760 --> 00:52:27,920
setting where possibly the majority of

1372
00:52:27,920 --> 00:52:29,359
these parties may be maliciously

1373
00:52:29,359 --> 00:52:32,400
corrupted under control of an adversary

1374
00:52:32,400 --> 00:52:34,079
now normally in npc

1375
00:52:34,079 --> 00:52:36,079
the set of participants is fixed from

1376
00:52:36,079 --> 00:52:37,520
the beginning of time

1377
00:52:37,520 --> 00:52:39,440
but in this case we want to also allow

1378
00:52:39,440 --> 00:52:42,079
potentially dynamic participants so

1379
00:52:42,079 --> 00:52:44,640
parties might drop out and rejoin later

1380
00:52:44,640 --> 00:52:46,960
on during the protocol

1381
00:52:46,960 --> 00:52:48,720
so why might you want to do this

1382
00:52:48,720 --> 00:52:50,720
well firstly allowing dynamic

1383
00:52:50,720 --> 00:52:52,880
participants adds flexibility

1384
00:52:52,880 --> 00:52:54,400
so if the parties are doing a very long

1385
00:52:54,400 --> 00:52:56,559
running and complex computation lasting

1386
00:52:56,559 --> 00:52:59,040
for hours or days then they might not

1387
00:52:59,040 --> 00:53:01,200
want to commit to being online for and

1388
00:53:01,200 --> 00:53:02,400
committing their resources for the

1389
00:53:02,400 --> 00:53:04,400
entirety of the protocol and they may

1390
00:53:04,400 --> 00:53:06,720
need to drop out part way through

1391
00:53:06,720 --> 00:53:08,960
and a second possible motivation

1392
00:53:08,960 --> 00:53:11,520
is actually for security because if the

1393
00:53:11,520 --> 00:53:13,280
adversary cannot predict how parties are

1394
00:53:13,280 --> 00:53:14,960
changing over time during the protocol

1395
00:53:14,960 --> 00:53:16,400
this may even make the protocol harder

1396
00:53:16,400 --> 00:53:18,960
to attack and creates a moving target

1397
00:53:18,960 --> 00:53:20,640
and this is the case for example in the

1398
00:53:20,640 --> 00:53:23,040
yoso line of work so you only speak once

1399
00:53:23,040 --> 00:53:25,119
npc but this is kind of taken to the

1400
00:53:25,119 --> 00:53:26,480
limit and that each party in the

1401
00:53:26,480 --> 00:53:28,720
protocol only joins in to receive and

1402
00:53:28,720 --> 00:53:30,640
send a single message before going

1403
00:53:30,640 --> 00:53:33,040
offline

1404
00:53:33,520 --> 00:53:37,599
so the fluid mpc model is uh this one

1405
00:53:37,599 --> 00:53:40,400
from by chowdhurytel from crypto 2020

1406
00:53:40,400 --> 00:53:43,359
which is what we build on in this paper

1407
00:53:43,359 --> 00:53:45,040
so in their model they have the protocol

1408
00:53:45,040 --> 00:53:47,200
divided into a series of time periods

1409
00:53:47,200 --> 00:53:48,559
called epochs

1410
00:53:48,559 --> 00:53:51,200
where in each epoch we have associated

1411
00:53:51,200 --> 00:53:52,800
with that time period effects committee

1412
00:53:52,800 --> 00:53:54,640
of parties who are running the protocol

1413
00:53:54,640 --> 00:53:56,480
at that time and they're the only ones

1414
00:53:56,480 --> 00:53:58,960
to be online during that ebook

1415
00:53:58,960 --> 00:53:59,839
um

1416
00:53:59,839 --> 00:54:02,319
so outside of the epochs we also have an

1417
00:54:02,319 --> 00:54:04,319
input and output stage where the input

1418
00:54:04,319 --> 00:54:05,920
providing and output receiving parties

1419
00:54:05,920 --> 00:54:07,599
have to be involved

1420
00:54:07,599 --> 00:54:09,599
those are treated separately

1421
00:54:09,599 --> 00:54:10,880
and the security assumption of the

1422
00:54:10,880 --> 00:54:13,359
original fluid npc work is that within

1423
00:54:13,359 --> 00:54:15,119
any given epoch that committee of

1424
00:54:15,119 --> 00:54:16,720
parties always has to have an honest

1425
00:54:16,720 --> 00:54:19,040
majority

1426
00:54:19,040 --> 00:54:20,800
so moving in a bit closer within the

1427
00:54:20,800 --> 00:54:23,920
epoch we have also two distinct phases

1428
00:54:23,920 --> 00:54:26,000
firstly a computation phase where the

1429
00:54:26,000 --> 00:54:27,280
current committee will do some local

1430
00:54:27,280 --> 00:54:29,440
computation potentially also interact

1431
00:54:29,440 --> 00:54:30,800
with each other

1432
00:54:30,800 --> 00:54:33,359
and then secondly handoff phase where

1433
00:54:33,359 --> 00:54:34,559
they at this point have to know the

1434
00:54:34,559 --> 00:54:36,160
identity of the next committee the

1435
00:54:36,160 --> 00:54:38,799
following epoch and will reshare or pass

1436
00:54:38,799 --> 00:54:40,400
on their state to the next committee by

1437
00:54:40,400 --> 00:54:42,400
sending a single message to that part of

1438
00:54:42,400 --> 00:54:45,440
those parties before going offline

1439
00:54:45,440 --> 00:54:47,440
and depending on the number of rounds of

1440
00:54:47,440 --> 00:54:49,359
interaction in the computation phase

1441
00:54:49,359 --> 00:54:50,960
this defines a property known as the

1442
00:54:50,960 --> 00:54:52,960
fluidity of the protocol

1443
00:54:52,960 --> 00:54:55,280
and in the upstream case where there is

1444
00:54:55,280 --> 00:54:57,359
no interaction in the computation phase

1445
00:54:57,359 --> 00:54:59,440
the parties only do local computation

1446
00:54:59,440 --> 00:55:01,119
before handing off their state to the

1447
00:55:01,119 --> 00:55:02,960
next committee this is called a

1448
00:55:02,960 --> 00:55:06,000
maximally fluid protocol

1449
00:55:06,000 --> 00:55:08,480
so the work of calgary ital presented a

1450
00:55:08,480 --> 00:55:10,799
fluid fluid npc protocol in the honest

1451
00:55:10,799 --> 00:55:12,160
majority setting

1452
00:55:12,160 --> 00:55:14,559
with active security with the board

1453
00:55:14,559 --> 00:55:17,200
and their protocol could be maximally

1454
00:55:17,200 --> 00:55:19,280
fluid meaning that in each epoch the

1455
00:55:19,280 --> 00:55:20,799
parties only need to be online for one

1456
00:55:20,799 --> 00:55:23,040
round of interaction uh to hand over

1457
00:55:23,040 --> 00:55:24,319
their state

1458
00:55:24,319 --> 00:55:26,559
and also importantly to obtain an

1459
00:55:26,559 --> 00:55:28,240
efficient protocol you want this to have

1460
00:55:28,240 --> 00:55:30,400
a small state complexity so the size of

1461
00:55:30,400 --> 00:55:31,920
the transfer from one committee to

1462
00:55:31,920 --> 00:55:35,359
another is not too launch

1463
00:55:35,359 --> 00:55:37,520
so in le mans we want to build a similar

1464
00:55:37,520 --> 00:55:39,680
kind of model for the dishonest majority

1465
00:55:39,680 --> 00:55:41,920
setting uh taking fluid npc as an

1466
00:55:41,920 --> 00:55:43,040
inspiration

1467
00:55:43,040 --> 00:55:44,640
but we have to change the model slightly

1468
00:55:44,640 --> 00:55:46,240
to get something that works

1469
00:55:46,240 --> 00:55:48,079
and we're going to add a pre-processing

1470
00:55:48,079 --> 00:55:49,200
phase

1471
00:55:49,200 --> 00:55:51,200
ahead of time to the computation where

1472
00:55:51,200 --> 00:55:53,119
now we'll require that all the parties

1473
00:55:53,119 --> 00:55:55,119
who might be involved at some point

1474
00:55:55,119 --> 00:55:56,640
during the competition of the online

1475
00:55:56,640 --> 00:55:58,160
phase have to be online in the

1476
00:55:58,160 --> 00:55:59,760
pre-processing

1477
00:55:59,760 --> 00:56:01,440
but once that's done then we move to the

1478
00:56:01,440 --> 00:56:02,400
online phase

1479
00:56:02,400 --> 00:56:05,119
where parties can change and dynamically

1480
00:56:05,119 --> 00:56:07,119
evolve across the different epochs as in

1481
00:56:07,119 --> 00:56:09,280
the fluid npc work

1482
00:56:09,280 --> 00:56:12,559
so the only requirement is that

1483
00:56:12,559 --> 00:56:14,559
in each epoch you at some point will

1484
00:56:14,559 --> 00:56:16,079
learn the identity of the parties in the

1485
00:56:16,079 --> 00:56:19,359
next epoch before the end of that phase

1486
00:56:19,359 --> 00:56:21,359
and now for security instead of honest

1487
00:56:21,359 --> 00:56:23,119
majority we just require that each

1488
00:56:23,119 --> 00:56:24,799
committee will have at least one on his

1489
00:56:24,799 --> 00:56:27,119
body

1490
00:56:27,680 --> 00:56:30,079
so in this model we present two main

1491
00:56:30,079 --> 00:56:32,160
protocols which can both be seen as

1492
00:56:32,160 --> 00:56:34,480
variants of the speeds protocol for

1493
00:56:34,480 --> 00:56:36,960
dishonest majority actively skilled npc

1494
00:56:36,960 --> 00:56:39,599
typically with static participants

1495
00:56:39,599 --> 00:56:41,280
now first there's a variant of speeds in

1496
00:56:41,280 --> 00:56:43,359
the dynamics setting where we don't

1497
00:56:43,359 --> 00:56:45,599
quite have full fluidity instead we

1498
00:56:45,599 --> 00:56:47,839
restrict the online phase to always run

1499
00:56:47,839 --> 00:56:49,760
within one single committee

1500
00:56:49,760 --> 00:56:51,119
but this might be a subset of the

1501
00:56:51,119 --> 00:56:52,319
parties who took part in the

1502
00:56:52,319 --> 00:56:53,680
pre-processing

1503
00:56:53,680 --> 00:56:55,200
and this is a more practical line of

1504
00:56:55,200 --> 00:56:57,280
work and can essentially be seen as

1505
00:56:57,280 --> 00:56:59,200
something that allows potential dropouts

1506
00:56:59,200 --> 00:57:00,799
between the pre-processing and the

1507
00:57:00,799 --> 00:57:03,200
online fades in speeds

1508
00:57:03,200 --> 00:57:04,799
uh the second protocol we call fluid

1509
00:57:04,799 --> 00:57:07,200
speeds is more general and allows also

1510
00:57:07,200 --> 00:57:09,280
the online participants to evolve by

1511
00:57:09,280 --> 00:57:10,880
changing the committees across these

1512
00:57:10,880 --> 00:57:14,319
epochs as in fluid mpc

1513
00:57:14,319 --> 00:57:16,000
and both of these protocols are tied

1514
00:57:16,000 --> 00:57:18,000
together by the pre-processing phase

1515
00:57:18,000 --> 00:57:20,720
which is the same in each protocol and

1516
00:57:20,720 --> 00:57:21,680
we have

1517
00:57:21,680 --> 00:57:23,599
what we call a universal pre-processing

1518
00:57:23,599 --> 00:57:25,760
among all of the participants which also

1519
00:57:25,760 --> 00:57:28,079
has a nice silent feature by building on

1520
00:57:28,079 --> 00:57:29,680
recent advances in pseudo-random

1521
00:57:29,680 --> 00:57:32,000
correlation generators

1522
00:57:32,000 --> 00:57:33,920
and the first protocol for dynamic

1523
00:57:33,920 --> 00:57:35,040
speeds

1524
00:57:35,040 --> 00:57:36,960
is also particularly nice because

1525
00:57:36,960 --> 00:57:38,640
because of the silent pre-processing it

1526
00:57:38,640 --> 00:57:40,480
actually has the lowest communication

1527
00:57:40,480 --> 00:57:42,559
of any of the speeds like protocols that

1528
00:57:42,559 --> 00:57:44,559
were previously known including ones

1529
00:57:44,559 --> 00:57:48,319
just supporting static participants

1530
00:57:48,720 --> 00:57:50,160
so going a bit more into this

1531
00:57:50,160 --> 00:57:51,839
pre-processing model

1532
00:57:51,839 --> 00:57:54,240
so the goal of pre-processing an mpc is

1533
00:57:54,240 --> 00:57:55,520
just to output some correlated

1534
00:57:55,520 --> 00:57:57,359
randomness to the parties

1535
00:57:57,359 --> 00:57:58,799
that can be done ahead of time before

1536
00:57:58,799 --> 00:58:00,880
they know the inputs to make the online

1537
00:58:00,880 --> 00:58:03,839
phase of the computation run faster

1538
00:58:03,839 --> 00:58:05,839
and of course the problem with this

1539
00:58:05,839 --> 00:58:07,920
model is that generating large quantity

1540
00:58:07,920 --> 00:58:09,520
of correlated randomness is often very

1541
00:58:09,520 --> 00:58:11,280
expensive requires a large amount of

1542
00:58:11,280 --> 00:58:13,359
communication amongst the parties

1543
00:58:13,359 --> 00:58:16,079
so silent pre-processing is a way of

1544
00:58:16,079 --> 00:58:17,119
compressing this amount of

1545
00:58:17,119 --> 00:58:19,280
pre-processing material to just some

1546
00:58:19,280 --> 00:58:21,200
short correlated seeds

1547
00:58:21,200 --> 00:58:23,040
which can then later be randomly or

1548
00:58:23,040 --> 00:58:25,040
locally expanded to produce a larger

1549
00:58:25,040 --> 00:58:26,960
amount of correlated pseudorandomness

1550
00:58:26,960 --> 00:58:29,280
like multiplication triples

1551
00:58:29,280 --> 00:58:30,480
and these can again be used in the

1552
00:58:30,480 --> 00:58:32,880
online phase as before

1553
00:58:32,880 --> 00:58:35,200
and we do this building on advances in

1554
00:58:35,200 --> 00:58:37,839
pcgs

1555
00:58:37,839 --> 00:58:38,960
so we want to build a silent

1556
00:58:38,960 --> 00:58:41,119
pre-processing phase with this universal

1557
00:58:41,119 --> 00:58:43,839
feature where we will run the protocol

1558
00:58:43,839 --> 00:58:45,599
to generate pre-processing amongst the

1559
00:58:45,599 --> 00:58:47,839
entire set of n parties and then can

1560
00:58:47,839 --> 00:58:50,400
later use this to generate preprocessing

1561
00:58:50,400 --> 00:58:54,480
to any subset of size m on demand

1562
00:58:54,480 --> 00:58:56,799
and just to make this harder and more

1563
00:58:56,799 --> 00:58:58,559
useful i guess we want to require that

1564
00:58:58,559 --> 00:59:00,720
this is done without any interaction

1565
00:59:00,720 --> 00:59:04,160
after the original preprocessing phase

1566
00:59:04,160 --> 00:59:05,920
so the main challenge here is that if

1567
00:59:05,920 --> 00:59:07,440
you think about multiplication triples

1568
00:59:07,440 --> 00:59:09,680
for instance then these normally tied to

1569
00:59:09,680 --> 00:59:11,839
a fixed set of parties uh which you have

1570
00:59:11,839 --> 00:59:13,839
to kind of know ahead of time

1571
00:59:13,839 --> 00:59:16,000
and while there are ways of re-sharing

1572
00:59:16,000 --> 00:59:18,160
correlated randomness from one committee

1573
00:59:18,160 --> 00:59:20,240
to another these are usually interactive

1574
00:59:20,240 --> 00:59:21,280
and quite a large amount of

1575
00:59:21,280 --> 00:59:23,920
communication

1576
00:59:24,079 --> 00:59:25,839
so as a warm-up let me just take you

1577
00:59:25,839 --> 00:59:27,520
through a simple passively secure

1578
00:59:27,520 --> 00:59:29,040
example of how to do this for

1579
00:59:29,040 --> 00:59:31,680
multiplication triples

1580
00:59:31,680 --> 00:59:33,280
so we want to generate beaver triples

1581
00:59:33,280 --> 00:59:35,520
which are the secret shared values abc

1582
00:59:35,520 --> 00:59:37,200
where c is a times b

1583
00:59:37,200 --> 00:59:39,200
and each of these is additively shared

1584
00:59:39,200 --> 00:59:41,839
across n parties um which you can think

1585
00:59:41,839 --> 00:59:43,680
of as the entire set of pre-processing

1586
00:59:43,680 --> 00:59:45,520
parties at this point

1587
00:59:45,520 --> 00:59:48,160
and so rewriting the the product a times

1588
00:59:48,160 --> 00:59:50,880
b here as a summation of pairwise

1589
00:59:50,880 --> 00:59:53,359
products a i times b j

1590
00:59:53,359 --> 00:59:55,119
then we get this sum of n squared of

1591
00:59:55,119 --> 00:59:56,640
these pairwise products

1592
00:59:56,640 --> 00:59:59,119
and notice that if we want to instead

1593
00:59:59,119 --> 01:00:02,319
generate a triple in say a subset of um

1594
01:00:02,319 --> 01:00:04,000
say half of the parties then we just

1595
01:00:04,000 --> 01:00:06,480
need to restrict this summation up to n

1596
01:00:06,480 --> 01:00:08,559
over two instead of up to n

1597
01:00:08,559 --> 01:00:10,960
and then it suffices to just to if we

1598
01:00:10,960 --> 01:00:13,200
have these sharings of pairwise terms we

1599
01:00:13,200 --> 01:00:14,960
can just take the ones we need to

1600
01:00:14,960 --> 01:00:17,119
compute a triple in any subset of the

1601
01:00:17,119 --> 01:00:19,280
original n parties

1602
01:00:19,280 --> 01:00:20,400
so

1603
01:00:20,400 --> 01:00:22,079
we'll start by distributing shares of

1604
01:00:22,079 --> 01:00:24,000
all of these pairwise products among the

1605
01:00:24,000 --> 01:00:25,520
parties

1606
01:00:25,520 --> 01:00:26,960
and

1607
01:00:26,960 --> 01:00:29,359
this allows us to then extract

1608
01:00:29,359 --> 01:00:31,359
one multiplication triple from each of

1609
01:00:31,359 --> 01:00:33,760
these sets of sharings in any chosen

1610
01:00:33,760 --> 01:00:36,160
subset we like dynamically in the online

1611
01:00:36,160 --> 01:00:38,400
phase of the computation

1612
01:00:38,400 --> 01:00:40,640
and to do this silently and with low

1613
01:00:40,640 --> 01:00:43,599
communication we'll be using pcgs

1614
01:00:43,599 --> 01:00:45,280
and note that because each of these

1615
01:00:45,280 --> 01:00:47,520
products is just involving two secret

1616
01:00:47,520 --> 01:00:50,240
shares so ai and bj we only need a

1617
01:00:50,240 --> 01:00:53,359
two-party pcg to generate the sharing

1618
01:00:53,359 --> 01:00:55,200
and thankfully this this can be done

1619
01:00:55,200 --> 01:00:57,119
quite efficiently by using a variant of

1620
01:00:57,119 --> 01:00:58,720
the lpn assumption

1621
01:00:58,720 --> 01:01:00,559
and allows us to

1622
01:01:00,559 --> 01:01:02,559
transfer translate this preprocessing to

1623
01:01:02,559 --> 01:01:05,359
have a silent uh implementation

1624
01:01:05,359 --> 01:01:06,960
the few things we have to take care of

1625
01:01:06,960 --> 01:01:08,799
when actually making this work like

1626
01:01:08,799 --> 01:01:11,760
making sure that these ai and bj terms

1627
01:01:11,760 --> 01:01:14,319
are consistent across different sharings

1628
01:01:14,319 --> 01:01:16,160
but thankfully with a small tweak to the

1629
01:01:16,160 --> 01:01:20,000
underlying pcgs you can make this work

1630
01:01:20,000 --> 01:01:21,680
okay so that's the passively secure

1631
01:01:21,680 --> 01:01:24,079
setting now if we want active security

1632
01:01:24,079 --> 01:01:25,680
we don't just want beaver triples we

1633
01:01:25,680 --> 01:01:28,079
usually use authenticated triples like

1634
01:01:28,079 --> 01:01:29,920
in the speeds protocol where each of

1635
01:01:29,920 --> 01:01:32,640
these values abc is now multiplied with

1636
01:01:32,640 --> 01:01:35,200
a random secret mac key delta

1637
01:01:35,200 --> 01:01:38,240
and again secret shared to the parties

1638
01:01:38,240 --> 01:01:41,359
so this introduces an extra challenge

1639
01:01:41,359 --> 01:01:43,359
but now if you look at the product delta

1640
01:01:43,359 --> 01:01:45,599
times c here and this is going to be a

1641
01:01:45,599 --> 01:01:47,839
degree three term in all these secret

1642
01:01:47,839 --> 01:01:50,559
values delta a and b so if we try to

1643
01:01:50,559 --> 01:01:52,720
apply the same trig by decomposing the

1644
01:01:52,720 --> 01:01:55,440
sum into all of the cross products

1645
01:01:55,440 --> 01:01:57,440
then we've now got n cubed of these

1646
01:01:57,440 --> 01:02:01,280
terms delta i times aj times b k

1647
01:02:01,280 --> 01:02:02,880
for every of these index and this is

1648
01:02:02,880 --> 01:02:04,559
quickly getting really expensive as the

1649
01:02:04,559 --> 01:02:06,880
number of parties increases uh so isn't

1650
01:02:06,880 --> 01:02:08,480
so practical

1651
01:02:08,480 --> 01:02:10,880
um so instead we just take

1652
01:02:10,880 --> 01:02:12,799
i guess the most obvious solution which

1653
01:02:12,799 --> 01:02:14,960
is just to forget about this last term

1654
01:02:14,960 --> 01:02:16,160
of the authenticated multiplication

1655
01:02:16,160 --> 01:02:18,960
triple and see if we can make the online

1656
01:02:18,960 --> 01:02:20,400
phase of the speech protocol work

1657
01:02:20,400 --> 01:02:22,400
without this

1658
01:02:22,400 --> 01:02:24,160
so we'll have this universal

1659
01:02:24,160 --> 01:02:26,720
pre-processing which now puts partially

1660
01:02:26,720 --> 01:02:28,960
authenticated triples without the last

1661
01:02:28,960 --> 01:02:31,119
term where we use this

1662
01:02:31,119 --> 01:02:33,200
passively secure

1663
01:02:33,200 --> 01:02:34,640
degree two approach from the previous

1664
01:02:34,640 --> 01:02:38,480
slide to generate all the other terms

1665
01:02:38,480 --> 01:02:40,720
so putting this together the dynamic

1666
01:02:40,720 --> 01:02:43,119
pre-processing protocol looks something

1667
01:02:43,119 --> 01:02:45,039
or dynamic speeds protocol looks a bit

1668
01:02:45,039 --> 01:02:46,160
like this

1669
01:02:46,160 --> 01:02:48,319
so the pre-processing phase would sample

1670
01:02:48,319 --> 01:02:50,799
these random sharings a and b and then

1671
01:02:50,799 --> 01:02:53,359
distribute all of these uh secret shares

1672
01:02:53,359 --> 01:02:55,280
of uh pairwise products for the

1673
01:02:55,280 --> 01:02:56,640
crossterms

1674
01:02:56,640 --> 01:02:58,559
and then in the online phase when we've

1675
01:02:58,559 --> 01:03:00,480
decided on a committee who wants to use

1676
01:03:00,480 --> 01:03:02,400
some of this pre-processing material

1677
01:03:02,400 --> 01:03:03,920
they can locally extract the right

1678
01:03:03,920 --> 01:03:06,000
shares to obtain this partial

1679
01:03:06,000 --> 01:03:07,760
authenticated triple

1680
01:03:07,760 --> 01:03:10,240
just missing the mac on the seater

1681
01:03:10,240 --> 01:03:12,160
and with a small amount of interaction

1682
01:03:12,160 --> 01:03:14,000
they can

1683
01:03:14,000 --> 01:03:15,760
do some fairly lightweight uh

1684
01:03:15,760 --> 01:03:17,520
computation to add the mac to the c

1685
01:03:17,520 --> 01:03:18,799
value

1686
01:03:18,799 --> 01:03:20,960
and then we'll evaluate the circuit as

1687
01:03:20,960 --> 01:03:22,960
usual and run some consistent

1688
01:03:22,960 --> 01:03:24,319
consistency check at the end of the

1689
01:03:24,319 --> 01:03:25,599
protocol

1690
01:03:25,599 --> 01:03:28,079
and this consistent check is necessary

1691
01:03:28,079 --> 01:03:30,400
because we've now actually added this

1692
01:03:30,400 --> 01:03:32,640
mac to the online phase instead of doing

1693
01:03:32,640 --> 01:03:34,400
it in the preprocessing in a verifiable

1694
01:03:34,400 --> 01:03:36,640
way um so we have to add an extra check

1695
01:03:36,640 --> 01:03:39,119
to make sure that this is done correctly

1696
01:03:39,119 --> 01:03:40,960
and for this we use this randomized

1697
01:03:40,960 --> 01:03:43,200
circuit evaluation procedure from the

1698
01:03:43,200 --> 01:03:46,160
work of charity town

1699
01:03:46,160 --> 01:03:48,480
and so this online phase has got a

1700
01:03:48,480 --> 01:03:49,920
little more work than the standard

1701
01:03:49,920 --> 01:03:51,680
speeds protocol because of the check and

1702
01:03:51,680 --> 01:03:54,240
the extra authentication of c

1703
01:03:54,240 --> 01:03:55,200
um

1704
01:03:55,200 --> 01:03:56,640
so it's around three times more

1705
01:03:56,640 --> 01:03:59,440
communication than previous protocols

1706
01:03:59,440 --> 01:04:00,240
but

1707
01:04:00,240 --> 01:04:02,400
for this cost we do get this dynamic

1708
01:04:02,400 --> 01:04:04,240
feature supporting dropouts after the

1709
01:04:04,240 --> 01:04:05,760
pre-processing phase

1710
01:04:05,760 --> 01:04:07,680
as well as the silent pre-processing

1711
01:04:07,680 --> 01:04:10,799
with very low communication

1712
01:04:11,359 --> 01:04:13,920
okay so that was dynamic speeds and in

1713
01:04:13,920 --> 01:04:16,240
fluid speeds we want to additionally

1714
01:04:16,240 --> 01:04:18,079
support changing committees in the

1715
01:04:18,079 --> 01:04:20,799
online phase

1716
01:04:20,880 --> 01:04:22,640
so here there's a few more challenges we

1717
01:04:22,640 --> 01:04:24,160
have to take care of

1718
01:04:24,160 --> 01:04:26,160
the first of these is the requirement

1719
01:04:26,160 --> 01:04:28,240
that we want a small state complexity

1720
01:04:28,240 --> 01:04:30,000
when transferring the state from one

1721
01:04:30,000 --> 01:04:31,599
committee to another

1722
01:04:31,599 --> 01:04:34,319
uh because the way these uh the speeds

1723
01:04:34,319 --> 01:04:36,400
online protocol that the dynamic online

1724
01:04:36,400 --> 01:04:38,799
protocol works is to have some

1725
01:04:38,799 --> 01:04:40,400
verification checks at the end of the

1726
01:04:40,400 --> 01:04:42,799
protocol which are like batched for the

1727
01:04:42,799 --> 01:04:44,720
entire circuit and that kind of

1728
01:04:44,720 --> 01:04:46,240
inherently requires storing the entire

1729
01:04:46,240 --> 01:04:47,920
state until the end of the protocol

1730
01:04:47,920 --> 01:04:49,200
which wouldn't work in this fluid

1731
01:04:49,200 --> 01:04:50,400
setting

1732
01:04:50,400 --> 01:04:52,559
so instead we propose incremental

1733
01:04:52,559 --> 01:04:54,960
variance of the mag check used in speeds

1734
01:04:54,960 --> 01:04:57,280
and this circuit verification procedure

1735
01:04:57,280 --> 01:04:58,960
to allow this to be done kind of on the

1736
01:04:58,960 --> 01:05:00,799
fly without blowing up the memory

1737
01:05:00,799 --> 01:05:02,160
complexity

1738
01:05:02,160 --> 01:05:04,160
for the fluid setting

1739
01:05:04,160 --> 01:05:06,160
and the second challenge we have

1740
01:05:06,160 --> 01:05:07,280
is that

1741
01:05:07,280 --> 01:05:09,200
because of the nature of the way the

1742
01:05:09,200 --> 01:05:11,280
universal pre-processing works

1743
01:05:11,280 --> 01:05:12,480
is that when you have two different

1744
01:05:12,480 --> 01:05:14,480
committees getting a multiplication

1745
01:05:14,480 --> 01:05:16,480
triple in the online phase then they

1746
01:05:16,480 --> 01:05:18,559
will end up with triples authenticated

1747
01:05:18,559 --> 01:05:20,240
under different mac keys

1748
01:05:20,240 --> 01:05:22,160
so we have an inconsistency between the

1749
01:05:22,160 --> 01:05:23,359
mack keys that are used from one

1750
01:05:23,359 --> 01:05:25,200
committee to the next that means at some

1751
01:05:25,200 --> 01:05:26,799
point this is going to break when you

1752
01:05:26,799 --> 01:05:28,640
try to combine the computations from

1753
01:05:28,640 --> 01:05:30,160
those committees

1754
01:05:30,160 --> 01:05:32,079
uh so to fix this we have to add an

1755
01:05:32,079 --> 01:05:33,440
extra protocol

1756
01:05:33,440 --> 01:05:35,440
to allow switching the mac key from one

1757
01:05:35,440 --> 01:05:37,599
committee to another

1758
01:05:37,599 --> 01:05:40,079
and putting these things together in a

1759
01:05:40,079 --> 01:05:41,839
fairly careful way we can actually

1760
01:05:41,839 --> 01:05:44,160
obtain a maximally fluid multiplication

1761
01:05:44,160 --> 01:05:45,839
protocol

1762
01:05:45,839 --> 01:05:48,319
using this pre-processing where each

1763
01:05:48,319 --> 01:05:50,400
committee in any of the epochs only

1764
01:05:50,400 --> 01:05:52,000
needs to be online for a single round of

1765
01:05:52,000 --> 01:05:54,000
interaction

1766
01:05:54,000 --> 01:05:55,359
okay so i'm not going to go into the

1767
01:05:55,359 --> 01:05:57,599
details of most of this uh but let me

1768
01:05:57,599 --> 01:05:59,440
just say a little bit about this mankey

1769
01:05:59,440 --> 01:06:02,240
switching protocol which we use

1770
01:06:02,240 --> 01:06:04,559
um so recall that the goal is to

1771
01:06:04,559 --> 01:06:06,880
transfer a mac of some secret share

1772
01:06:06,880 --> 01:06:08,079
value x

1773
01:06:08,079 --> 01:06:10,559
from one committee to another uh where

1774
01:06:10,559 --> 01:06:11,920
the starting committee on the left will

1775
01:06:11,920 --> 01:06:13,839
have it authenticated under say a mackie

1776
01:06:13,839 --> 01:06:14,960
delta a

1777
01:06:14,960 --> 01:06:16,720
and the goal is to transfer this to the

1778
01:06:16,720 --> 01:06:19,440
right committee under their key which

1779
01:06:19,440 --> 01:06:21,359
called delta b

1780
01:06:21,359 --> 01:06:23,440
and if you look at this problem it might

1781
01:06:23,440 --> 01:06:25,920
seem kind of impossible to do if we just

1782
01:06:25,920 --> 01:06:28,079
want to do a single round of interaction

1783
01:06:28,079 --> 01:06:29,760
from left to right

1784
01:06:29,760 --> 01:06:31,119
to allow the first committee to go

1785
01:06:31,119 --> 01:06:32,640
immediately offline

1786
01:06:32,640 --> 01:06:33,760
because this committee doesn't know

1787
01:06:33,760 --> 01:06:35,359
anything about delta b how can they

1788
01:06:35,359 --> 01:06:37,200
possibly get the right shares to that

1789
01:06:37,200 --> 01:06:38,640
committee

1790
01:06:38,640 --> 01:06:40,880
but we have a trick of our slave which

1791
01:06:40,880 --> 01:06:42,640
of course is this nice universal

1792
01:06:42,640 --> 01:06:44,240
pre-processing protocol

1793
01:06:44,240 --> 01:06:46,000
and by taking advantage of that in the

1794
01:06:46,000 --> 01:06:47,119
right way

1795
01:06:47,119 --> 01:06:48,720
we can make this work

1796
01:06:48,720 --> 01:06:50,960
um so from the processing the parties

1797
01:06:50,960 --> 01:06:53,119
have shares of their mag keys

1798
01:06:53,119 --> 01:06:55,760
and we will also use a variant of this

1799
01:06:55,760 --> 01:06:57,839
where we can get shares of a random

1800
01:06:57,839 --> 01:06:59,119
value r

1801
01:06:59,119 --> 01:07:01,280
shared amongst the left committee

1802
01:07:01,280 --> 01:07:03,839
together with a mac on this value but

1803
01:07:03,839 --> 01:07:05,920
now under the mag key held by the write

1804
01:07:05,920 --> 01:07:07,599
committee

1805
01:07:07,599 --> 01:07:09,200
the mac here is not actually exactly a

1806
01:07:09,200 --> 01:07:11,039
speeds market slightly different it uses

1807
01:07:11,039 --> 01:07:13,440
pairwise max

1808
01:07:13,440 --> 01:07:15,440
but using a similar trick to generating

1809
01:07:15,440 --> 01:07:17,520
the authenticated triples uh you can

1810
01:07:17,520 --> 01:07:20,559
generate this kind of random mag value

1811
01:07:20,559 --> 01:07:22,400
and once you have this and the online

1812
01:07:22,400 --> 01:07:24,640
phase it's quite easy to transfer x from

1813
01:07:24,640 --> 01:07:27,039
one monk key to the other

1814
01:07:27,039 --> 01:07:28,720
by essentially first resharing the

1815
01:07:28,720 --> 01:07:30,799
shares of x to the next committee and

1816
01:07:30,799 --> 01:07:34,400
then opening x plus r um as a mask and

1817
01:07:34,400 --> 01:07:36,640
some special correction values for the

1818
01:07:36,640 --> 01:07:38,640
max which allows the committee on the

1819
01:07:38,640 --> 01:07:40,000
right hand side to get the correct

1820
01:07:40,000 --> 01:07:41,520
sharings

1821
01:07:41,520 --> 01:07:43,200
so there's a few details hidden under

1822
01:07:43,200 --> 01:07:45,359
the rug there but that's the rough idea

1823
01:07:45,359 --> 01:07:48,480
of what this gets you and how it works

1824
01:07:48,480 --> 01:07:50,640
and that's all i say about the technical

1825
01:07:50,640 --> 01:07:52,799
side i'll just end with a little bit on

1826
01:07:52,799 --> 01:07:55,680
the concrete or asymptotic efficiency of

1827
01:07:55,680 --> 01:07:57,680
this

1828
01:07:57,680 --> 01:07:59,440
so the baseline we look at is the

1829
01:07:59,440 --> 01:08:01,119
classic speeds pre

1830
01:08:01,119 --> 01:08:04,400
uh speeds protocol um with one of its

1831
01:08:04,400 --> 01:08:05,920
variants of preprocessing based on

1832
01:08:05,920 --> 01:08:07,839
homomorphic encryption

1833
01:08:07,839 --> 01:08:09,920
where the main communication cost in the

1834
01:08:09,920 --> 01:08:11,760
online phase is around two field

1835
01:08:11,760 --> 01:08:13,599
elements per party per multiplication

1836
01:08:13,599 --> 01:08:14,640
gate

1837
01:08:14,640 --> 01:08:16,399
while the pre-processing scales linearly

1838
01:08:16,399 --> 01:08:18,080
with both the number of parties

1839
01:08:18,080 --> 01:08:20,319
and the circuit size

1840
01:08:20,319 --> 01:08:23,040
and our dynamic speeds protocol

1841
01:08:23,040 --> 01:08:24,479
vastly reduces the cost of the

1842
01:08:24,479 --> 01:08:27,040
pre-processing to be only logarithmic in

1843
01:08:27,040 --> 01:08:28,640
the size of the circuit by using these

1844
01:08:28,640 --> 01:08:30,238
pcgs

1845
01:08:30,238 --> 01:08:32,000
and because the price we pay is three

1846
01:08:32,000 --> 01:08:34,158
times extra online cost because of the

1847
01:08:34,158 --> 01:08:36,319
extra work we have to do there

1848
01:08:36,319 --> 01:08:38,799
the fluid protocol is a bit less

1849
01:08:38,799 --> 01:08:41,439
efficient the constants depend largely

1850
01:08:41,439 --> 01:08:44,000
on on the fluidity which you want to

1851
01:08:44,000 --> 01:08:45,439
achieve

1852
01:08:45,439 --> 01:08:47,279
but it is at least in the amortized

1853
01:08:47,279 --> 01:08:50,319
sensor constant per multiplication gate

1854
01:08:50,319 --> 01:08:51,920
and the preprocessing is the same as in

1855
01:08:51,920 --> 01:08:54,319
dynamic speeds because uh yeah they're

1856
01:08:54,319 --> 01:08:56,640
identical

1857
01:08:56,640 --> 01:08:59,040
okay okay so that's all i want to say

1858
01:08:59,040 --> 01:09:00,560
i'll just leave this slide up here as a

1859
01:09:00,560 --> 01:09:02,880
quick recap of our main results and if

1860
01:09:02,880 --> 01:09:04,000
you want to see more you can check out

1861
01:09:04,000 --> 01:09:05,600
our paper on e-print thanks for

1862
01:09:05,600 --> 01:09:07,839
listening

1863
01:09:14,640 --> 01:09:16,158
thank you very much for watching

1864
01:09:16,158 --> 01:09:18,799
interesting talk so in the offline phase

1865
01:09:18,799 --> 01:09:21,600
you didn't generate the mac of the c

1866
01:09:21,600 --> 01:09:23,279
instead you do it on online phase i

1867
01:09:23,279 --> 01:09:25,279
wonder whether it can be pushed back to

1868
01:09:25,279 --> 01:09:27,759
the offline base or it's just a matter

1869
01:09:27,759 --> 01:09:30,399
of presenting uh supplemental

1870
01:09:30,399 --> 01:09:32,319
communication cost so so if you're happy

1871
01:09:32,319 --> 01:09:34,080
to allow a linear amount of interaction

1872
01:09:34,080 --> 01:09:37,040
in the offline phase you can do that but

1873
01:09:37,040 --> 01:09:39,679
i don't know how to do that efficiently

1874
01:09:39,679 --> 01:09:41,279
like whilst retaining the sublinear

1875
01:09:41,279 --> 01:09:43,679
property and the preprocessing i see but

1876
01:09:43,679 --> 01:09:46,000
in general it doesn't make more sense

1877
01:09:46,000 --> 01:09:48,640
like push as much as communication costs

1878
01:09:48,640 --> 01:09:51,439
in the office yeah so i guess the

1879
01:09:51,439 --> 01:09:54,238
and we do push we push kind of part of

1880
01:09:54,238 --> 01:09:56,640
the heavy computation work for doing

1881
01:09:56,640 --> 01:09:58,480
that authentication of c

1882
01:09:58,480 --> 01:10:00,000
so the part that's in the online phase

1883
01:10:00,000 --> 01:10:02,239
it's it's some extra communication but

1884
01:10:02,239 --> 01:10:04,320
it's at least it doesn't have any heavy

1885
01:10:04,320 --> 01:10:06,560
crypto on it so it's lightweight in that

1886
01:10:06,560 --> 01:10:07,440
sense

1887
01:10:07,440 --> 01:10:08,640
um so i think it depends on the

1888
01:10:08,640 --> 01:10:09,840
application whether you want to keep

1889
01:10:09,840 --> 01:10:11,199
that in the online phase or push it to

1890
01:10:11,199 --> 01:10:15,639
the offline nice it makes it thank you

1891
01:10:16,800 --> 01:10:18,880
so first thank you for the nice talk um

1892
01:10:18,880 --> 01:10:20,880
and then i have a sort of a speculative

1893
01:10:20,880 --> 01:10:22,640
question um you know having this

1894
01:10:22,640 --> 01:10:24,000
requirement that all the parties be

1895
01:10:24,000 --> 01:10:25,199
there initially

1896
01:10:25,199 --> 01:10:26,560
it you know of course would be nice to

1897
01:10:26,560 --> 01:10:28,719
alleviate that and i'm curious whether

1898
01:10:28,719 --> 01:10:30,239
you think it's more promising to sort of

1899
01:10:30,239 --> 01:10:31,600
throw out authenticated triples

1900
01:10:31,600 --> 01:10:33,440
altogether and then pursue some other

1901
01:10:33,440 --> 01:10:34,320
approach

1902
01:10:34,320 --> 01:10:36,560
or whether you might be able to use the

1903
01:10:36,560 --> 01:10:38,800
pcgs online as new parties enter that

1904
01:10:38,800 --> 01:10:40,480
i've never been seen before

1905
01:10:40,480 --> 01:10:41,760
yeah so

1906
01:10:41,760 --> 01:10:44,880
it's a tricky one um i mean

1907
01:10:44,880 --> 01:10:46,719
the problem is with these pre-processing

1908
01:10:46,719 --> 01:10:49,040
protocols they they're kind of designed

1909
01:10:49,040 --> 01:10:50,560
to generate a very large batch of

1910
01:10:50,560 --> 01:10:53,280
multiplication triples right so if you

1911
01:10:53,280 --> 01:10:54,880
generate that like more online on the

1912
01:10:54,880 --> 01:10:56,800
fly then that committee is going to use

1913
01:10:56,800 --> 01:11:00,159
all of them sure um and maybe a more

1914
01:11:00,159 --> 01:11:01,679
promising approach might be to try to

1915
01:11:01,679 --> 01:11:04,239
design a pcg where you can like reshare

1916
01:11:04,239 --> 01:11:06,560
the seeds from one committee to another

1917
01:11:06,560 --> 01:11:07,920
um

1918
01:11:07,920 --> 01:11:10,719
in some efficient way but so far it

1919
01:11:10,719 --> 01:11:14,400
doesn't look easy well thank you

1920
01:11:14,400 --> 01:11:15,840
oh yeah thank you thank you very much

1921
01:11:15,840 --> 01:11:17,679
for the talk it was a great talk um i

1922
01:11:17,679 --> 01:11:19,199
just wanted to ask uh what do you think

1923
01:11:19,199 --> 01:11:21,760
are the big open questions in this kind

1924
01:11:21,760 --> 01:11:24,480
of like fluid mpc area and like how far

1925
01:11:24,480 --> 01:11:26,080
is it from being used in practice right

1926
01:11:26,080 --> 01:11:27,360
because like the first use that comes to

1927
01:11:27,360 --> 01:11:29,679
my mind is like kind of blockchain npc

1928
01:11:29,679 --> 01:11:31,199
stuff where the users are not always

1929
01:11:31,199 --> 01:11:33,120
assumed to be present like how far are

1930
01:11:33,120 --> 01:11:34,960
we from like being able to actually like

1931
01:11:34,960 --> 01:11:37,280
implement yeah yeah i think that's a

1932
01:11:37,280 --> 01:11:39,679
it's a really interesting question um

1933
01:11:39,679 --> 01:11:41,280
i think there's a

1934
01:11:41,280 --> 01:11:43,520
a bunch of trade-offs like so in the

1935
01:11:43,520 --> 01:11:46,080
fluid npc land at work one thing we

1936
01:11:46,080 --> 01:11:48,880
sacrifice um at least in the honest

1937
01:11:48,880 --> 01:11:50,719
majority setting and to an extent it's

1938
01:11:50,719 --> 01:11:52,800
inherent in dishonest majority is

1939
01:11:52,800 --> 01:11:54,800
getting guaranteed output delivery or

1940
01:11:54,800 --> 01:11:56,239
preventing malicious parties being able

1941
01:11:56,239 --> 01:11:58,320
to abort without any penalty

1942
01:11:58,320 --> 01:12:00,960
um so in the yoso work with the honest

1943
01:12:00,960 --> 01:12:02,480
majority they get guaranteed output

1944
01:12:02,480 --> 01:12:04,400
delivery which i think is very desirable

1945
01:12:04,400 --> 01:12:06,080
in the blockchain setting but the

1946
01:12:06,080 --> 01:12:08,880
protocol is also very impractical

1947
01:12:08,880 --> 01:12:09,920
so there's definitely room for

1948
01:12:09,920 --> 01:12:11,679
improvement with making that practical

1949
01:12:11,679 --> 01:12:15,120
or perhaps um yeah making this uh

1950
01:12:15,120 --> 01:12:16,800
dynamic um

1951
01:12:16,800 --> 01:12:18,960
fluid npc dishonest majority saying more

1952
01:12:18,960 --> 01:12:21,679
robust in some sense maybe identifiable

1953
01:12:21,679 --> 01:12:23,520
or something yeah thank you very much

1954
01:12:23,520 --> 01:12:26,480
sounds good thanks

1955
01:12:33,120 --> 01:12:36,159
i had one more question i'm sorry so can

1956
01:12:36,159 --> 01:12:38,159
you go back in the table so the cost is

1957
01:12:38,159 --> 01:12:39,679
linear right

1958
01:12:39,679 --> 01:12:42,000
in the online phase it's not constant

1959
01:12:42,000 --> 01:12:43,920
can you go back to your table what do

1960
01:12:43,920 --> 01:12:46,880
you mean here with so this is the um

1961
01:12:46,880 --> 01:12:48,840
linear in the circuit size you mean

1962
01:12:48,840 --> 01:12:50,880
yeah so it should be linear right in the

1963
01:12:50,880 --> 01:12:53,679
number of parties yeah okay

1964
01:12:53,679 --> 01:12:55,120
and what happens for example if you

1965
01:12:55,120 --> 01:12:57,520
fully depleted two like how

1966
01:12:57,520 --> 01:12:59,360
the constants are changing what happens

1967
01:12:59,360 --> 01:13:01,120
with once if you increase the fluidity

1968
01:13:01,120 --> 01:13:02,840
let's say you increase it to

1969
01:13:02,840 --> 01:13:04,880
two um

1970
01:13:04,880 --> 01:13:06,320
so i think

1971
01:13:06,320 --> 01:13:08,000
two would

1972
01:13:08,000 --> 01:13:09,760
maybe it would save you a little bit i

1973
01:13:09,760 --> 01:13:10,560
think

1974
01:13:10,560 --> 01:13:12,159
we estimated that once you increase it

1975
01:13:12,159 --> 01:13:13,840
to like three or four

1976
01:13:13,840 --> 01:13:15,679
then the online cost would actually get

1977
01:13:15,679 --> 01:13:19,600
very close to the dynamic speeds cost

1978
01:13:19,600 --> 01:13:21,280
because there's a lot you pay just to

1979
01:13:21,280 --> 01:13:25,120
get that maximum fluidity okay good

1980
01:13:25,120 --> 01:13:27,360
other more questions

1981
01:13:27,360 --> 01:13:31,960
let me check quickly the zoom charts

1982
01:13:38,880 --> 01:13:39,840
okay

1983
01:13:39,840 --> 01:13:41,840
so this is per party right

1984
01:13:41,840 --> 01:13:44,159
yep so in your protocol don't you do

1985
01:13:44,159 --> 01:13:45,120
this

1986
01:13:45,120 --> 01:13:46,719
everyone talks to everyone kind of thing

1987
01:13:46,719 --> 01:13:48,239
yeah yeah so it's actually it's n

1988
01:13:48,239 --> 01:13:51,440
squared because you count the party

1989
01:13:51,440 --> 01:13:53,920
so so the online is

1990
01:13:53,920 --> 01:13:55,280
is per no

1991
01:13:55,280 --> 01:13:57,120
online is the online you don't have to

1992
01:13:57,120 --> 01:13:59,840
talk to everyone

1993
01:14:00,960 --> 01:14:02,719
in

1994
01:14:02,719 --> 01:14:05,280
it's like in in speeds you have the

1995
01:14:05,280 --> 01:14:07,040
the king trick

1996
01:14:07,040 --> 01:14:08,800
um where you sent to one party and then

1997
01:14:08,800 --> 01:14:11,199
they yeah to the rest you can you can

1998
01:14:11,199 --> 01:14:12,800
kind of amortize with like that kind of

1999
01:14:12,800 --> 01:14:16,159
stuff okay thank you

2000
01:14:16,560 --> 01:14:18,719
okay let's thank all the speakers of the

2001
01:14:18,719 --> 01:14:22,440
session and peter again

