1
00:00:00,240 --> 00:00:02,159
topics section

2
00:00:02,159 --> 00:00:05,120
and the first talk is going to be given

3
00:00:05,120 --> 00:00:06,560
by michael

4
00:00:06,560 --> 00:00:08,320
reckley and

5
00:00:08,320 --> 00:00:10,400
it's on uh his

6
00:00:10,400 --> 00:00:12,320
latest work on dynamic

7
00:00:12,320 --> 00:00:14,960
local ssc

8
00:00:14,960 --> 00:00:16,400
thanks for the introduction so i'm going

9
00:00:16,400 --> 00:00:18,160
to talk about sse

10
00:00:18,160 --> 00:00:20,160
and memory efficiency

11
00:00:20,160 --> 00:00:21,439
and yeah there's a strong work with

12
00:00:21,439 --> 00:00:22,880
please new

13
00:00:22,880 --> 00:00:24,560
so first of all i'm going to talk a bit

14
00:00:24,560 --> 00:00:26,000
about search for symmetric encryption

15
00:00:26,000 --> 00:00:27,920
this is unique topics so

16
00:00:27,920 --> 00:00:30,720
um i try to introduce it even for people

17
00:00:30,720 --> 00:00:32,640
that haven't been through the workshop

18
00:00:32,640 --> 00:00:33,520
um

19
00:00:33,520 --> 00:00:35,920
then i will go to uh through like our

20
00:00:35,920 --> 00:00:37,920
main goal so what is memory efficiency

21
00:00:37,920 --> 00:00:39,440
um what do we actually want to construct

22
00:00:39,440 --> 00:00:40,239
here

23
00:00:40,239 --> 00:00:41,920
and then in the end i'll talk about some

24
00:00:41,920 --> 00:00:43,520
of our techniques and the results that

25
00:00:43,520 --> 00:00:45,600
we obtained

26
00:00:45,600 --> 00:00:48,000
so um first of all so what is ssc what

27
00:00:48,000 --> 00:00:49,440
do we actually want to build what do we

28
00:00:49,440 --> 00:00:51,520
use it for so say you have a bunch of

29
00:00:51,520 --> 00:00:54,879
documents like confidential data like

30
00:00:54,879 --> 00:00:56,559
medical records or like emails or

31
00:00:56,559 --> 00:00:58,719
something like this all identified by

32
00:00:58,719 --> 00:01:01,039
some ids and now you want to outsource

33
00:01:01,039 --> 00:01:03,359
them to an untrusted server so how do

34
00:01:03,359 --> 00:01:04,799
you do that well you can just encrypt

35
00:01:04,799 --> 00:01:06,000
everything but

36
00:01:06,000 --> 00:01:08,799
then it's hard to interact with it so

37
00:01:08,799 --> 00:01:11,360
um yeah kind of the goal of sse is to to

38
00:01:11,360 --> 00:01:13,439
like encrypt data outsource it to the

39
00:01:13,439 --> 00:01:15,360
server and still be able to interact

40
00:01:15,360 --> 00:01:18,080
with it for example like sqli queries

41
00:01:18,080 --> 00:01:20,400
and in this work we specifically focus

42
00:01:20,400 --> 00:01:23,920
on keyword queries so um what we kind of

43
00:01:23,920 --> 00:01:25,759
do is we have this reverse index that

44
00:01:25,759 --> 00:01:28,320
kind of is like a pre-computation of of

45
00:01:28,320 --> 00:01:30,479
keyword queries so we have keywords for

46
00:01:30,479 --> 00:01:32,240
example covid and then the identifier

47
00:01:32,240 --> 00:01:33,840
lists here on the right they're

48
00:01:33,840 --> 00:01:36,000
essentially all the keywords all the

49
00:01:36,000 --> 00:01:38,000
documents the identifiers of the

50
00:01:38,000 --> 00:01:40,320
documents that match this keyword and

51
00:01:40,320 --> 00:01:42,159
then our goal so this is represented in

52
00:01:42,159 --> 00:01:44,240
the talk like this and then our goal is

53
00:01:44,240 --> 00:01:46,960
going to be to retrieve these identifier

54
00:01:46,960 --> 00:01:48,640
lists efficiently

55
00:01:48,640 --> 00:01:49,439
um

56
00:01:49,439 --> 00:01:51,119
from the server so answering keyboard

57
00:01:51,119 --> 00:01:52,560
queries essentially

58
00:01:52,560 --> 00:01:55,200
um and for this generally in sse you

59
00:01:55,200 --> 00:01:58,159
encrypt this this this reverse index so

60
00:01:58,159 --> 00:02:00,479
you can think of like the the the reds

61
00:02:00,479 --> 00:02:02,079
or like blue squares you can think of

62
00:02:02,079 --> 00:02:03,600
them as being like an access token that

63
00:02:03,600 --> 00:02:05,439
you supply to like make a query to the

64
00:02:05,439 --> 00:02:07,520
server and then

65
00:02:07,520 --> 00:02:08,330
the um

66
00:02:08,330 --> 00:02:09,598
[Music]

67
00:02:09,598 --> 00:02:11,520
the the these lists with the key those

68
00:02:11,520 --> 00:02:13,120
are encrypted identifiers essentially

69
00:02:13,120 --> 00:02:14,640
and now our goal is to store them on the

70
00:02:14,640 --> 00:02:17,040
server so how can we use that now well

71
00:02:17,040 --> 00:02:18,720
we just encrypt the documents we move

72
00:02:18,720 --> 00:02:20,720
the encrypted server identifiers to the

73
00:02:20,720 --> 00:02:22,959
server and now we can just supply given

74
00:02:22,959 --> 00:02:24,879
the access tokens we can supply search

75
00:02:24,879 --> 00:02:26,560
queries for example where you retrieve

76
00:02:26,560 --> 00:02:28,560
the identifier list that the identifiers

77
00:02:28,560 --> 00:02:29,680
that match

78
00:02:29,680 --> 00:02:31,280
and you can do update queries for

79
00:02:31,280 --> 00:02:33,680
example where you supply an update token

80
00:02:33,680 --> 00:02:35,840
and then you can change the data so this

81
00:02:35,840 --> 00:02:38,000
is a dynamic database whereas if you

82
00:02:38,000 --> 00:02:40,000
don't have this update functionality

83
00:02:40,000 --> 00:02:42,560
it's a static it's like a static sse

84
00:02:42,560 --> 00:02:43,760
scheme

85
00:02:43,760 --> 00:02:45,680
and in this work we're specifically

86
00:02:45,680 --> 00:02:48,080
interested in dynamic sse schemes

87
00:02:48,080 --> 00:02:50,000
where you can kind of adapt the data to

88
00:02:50,000 --> 00:02:51,920
your liking

89
00:02:51,920 --> 00:02:54,480
and of course we're moving confidential

90
00:02:54,480 --> 00:02:56,640
information to the server that we don't

91
00:02:56,640 --> 00:02:58,800
necessarily trust so in the security

92
00:02:58,800 --> 00:03:00,879
model we model it as an honest but

93
00:03:00,879 --> 00:03:02,480
curious adversary

94
00:03:02,480 --> 00:03:04,319
and so the server is interested in our

95
00:03:04,319 --> 00:03:07,120
data he interacts with us we give him

96
00:03:07,120 --> 00:03:08,800
like queries and

97
00:03:08,800 --> 00:03:11,519
encrypt data so we kind of want to show

98
00:03:11,519 --> 00:03:14,239
that he learns nothing except like

99
00:03:14,239 --> 00:03:15,840
minimal information

100
00:03:15,840 --> 00:03:18,080
and this minimal information is usually

101
00:03:18,080 --> 00:03:19,599
captured by

102
00:03:19,599 --> 00:03:21,519
by the leakage so the leakage is

103
00:03:21,519 --> 00:03:23,599
essentially what the server learns

104
00:03:23,599 --> 00:03:25,040
while interacting with that but it's

105
00:03:25,040 --> 00:03:26,480
kind of an upper bound on what the

106
00:03:26,480 --> 00:03:28,239
server can learn

107
00:03:28,239 --> 00:03:29,599
so yeah essentially in the security

108
00:03:29,599 --> 00:03:30,959
model we want to show that the server

109
00:03:30,959 --> 00:03:32,560
learns nothing except the concrete

110
00:03:32,560 --> 00:03:34,640
leakage function that we have

111
00:03:34,640 --> 00:03:36,480
and this essentially allows for

112
00:03:36,480 --> 00:03:37,840
trade-offs of course you of course you

113
00:03:37,840 --> 00:03:40,000
can think of of like

114
00:03:40,000 --> 00:03:42,000
a leakage function that looks like only

115
00:03:42,000 --> 00:03:43,760
like barely nothing or like maybe only

116
00:03:43,760 --> 00:03:45,280
this size that's it

117
00:03:45,280 --> 00:03:47,120
but then actually you run into some

118
00:03:47,120 --> 00:03:48,959
lower bounds and it gets a lot more

119
00:03:48,959 --> 00:03:50,239
inefficient

120
00:03:50,239 --> 00:03:51,599
so in this work we're specifically

121
00:03:51,599 --> 00:03:54,080
concerned about concrete efficiency so

122
00:03:54,080 --> 00:03:57,680
we allow for more standard leakage so in

123
00:03:57,680 --> 00:04:00,159
gold in sse usually what we like at this

124
00:04:00,159 --> 00:04:02,959
point what kind of the community things

125
00:04:02,959 --> 00:04:05,519
is fine leakage for dynamic sse schemes

126
00:04:05,519 --> 00:04:07,439
is usually forward security so here you

127
00:04:07,439 --> 00:04:09,840
leak the database size during setup

128
00:04:09,840 --> 00:04:12,000
then a bunch of stuff doing search like

129
00:04:12,000 --> 00:04:13,760
query pattern access pattern and then

130
00:04:13,760 --> 00:04:15,200
and like volume leakage the number of

131
00:04:15,200 --> 00:04:16,720
matching identifiers

132
00:04:16,720 --> 00:04:18,320
so if you don't know what this is it's

133
00:04:18,320 --> 00:04:20,399
not that important for the talk um and

134
00:04:20,399 --> 00:04:21,918
if you know sse this should be very

135
00:04:21,918 --> 00:04:24,000
familiar and then for update usually you

136
00:04:24,000 --> 00:04:26,479
don't want to leak anything to avoid

137
00:04:26,479 --> 00:04:28,400
certain file injection attacks

138
00:04:28,400 --> 00:04:30,320
so in this work we actually do leak

139
00:04:30,320 --> 00:04:32,479
something in updates so what we do is we

140
00:04:32,479 --> 00:04:34,320
leave the query pattern and the volume

141
00:04:34,320 --> 00:04:35,360
leakage

142
00:04:35,360 --> 00:04:36,320
um

143
00:04:36,320 --> 00:04:39,280
so this might sound a bit weird at first

144
00:04:39,280 --> 00:04:41,759
like why why should this be acceptable

145
00:04:41,759 --> 00:04:42,560
and

146
00:04:42,560 --> 00:04:45,040
essentially if you look at literature

147
00:04:45,040 --> 00:04:46,720
then how can you actually make use of

148
00:04:46,720 --> 00:04:47,919
this leakage where you can do file

149
00:04:47,919 --> 00:04:49,360
injection attacks

150
00:04:49,360 --> 00:04:51,280
but essentially in settings where you

151
00:04:51,280 --> 00:04:53,520
cannot actually inject files

152
00:04:53,520 --> 00:04:55,199
so for example in messages service

153
00:04:55,199 --> 00:04:57,360
messaging services this would be a bit

154
00:04:57,360 --> 00:04:58,880
annoying because there you can clearly

155
00:04:58,880 --> 00:05:00,320
inject messages by just sending a

156
00:05:00,320 --> 00:05:02,800
message but for example in like medical

157
00:05:02,800 --> 00:05:04,960
databases it's a lot harder to inject

158
00:05:04,960 --> 00:05:06,639
files so

159
00:05:06,639 --> 00:05:08,320
we believe that still in these settings

160
00:05:08,320 --> 00:05:10,080
this is still an interesting leakage

161
00:05:10,080 --> 00:05:12,560
pattern and and we try to study

162
00:05:12,560 --> 00:05:14,240
what we can do even though allowing for

163
00:05:14,240 --> 00:05:16,000
a bit more leakage

164
00:05:16,000 --> 00:05:16,880
so

165
00:05:16,880 --> 00:05:19,840
this is kind of uh what we try to do and

166
00:05:19,840 --> 00:05:21,680
yeah of course

167
00:05:21,680 --> 00:05:23,759
kind of the the main theme and ss

168
00:05:23,759 --> 00:05:26,000
usually is to not not leak anything

169
00:05:26,000 --> 00:05:27,919
about unquery keywords and and this

170
00:05:27,919 --> 00:05:29,600
leakage is still fine for that like you

171
00:05:29,600 --> 00:05:31,120
have like at least like these bare

172
00:05:31,120 --> 00:05:34,960
minimum requirements for sse leakage

173
00:05:34,960 --> 00:05:37,840
so um yeah so how do we actually build

174
00:05:37,840 --> 00:05:39,600
sse usually well

175
00:05:39,600 --> 00:05:41,120
you can you have like this encrypted

176
00:05:41,120 --> 00:05:42,800
reverse index so why not just put all

177
00:05:42,800 --> 00:05:44,479
the identifier lists directly

178
00:05:44,479 --> 00:05:46,800
consecutively in memory and call it a

179
00:05:46,800 --> 00:05:48,720
day and then like you essentially have

180
00:05:48,720 --> 00:05:50,320
like the access tokens would just be

181
00:05:50,320 --> 00:05:51,759
pointers for example to the beginning of

182
00:05:51,759 --> 00:05:52,800
the list

183
00:05:52,800 --> 00:05:54,560
well if you just do that consecutively

184
00:05:54,560 --> 00:05:56,080
memory then it's not secure because

185
00:05:56,080 --> 00:05:57,840
clearly the list locations depend on

186
00:05:57,840 --> 00:05:59,680
other lists so they depend on other

187
00:05:59,680 --> 00:06:02,319
keywords which is not what we want so

188
00:06:02,319 --> 00:06:05,039
this is insecure but luckily some smart

189
00:06:05,039 --> 00:06:07,199
people came up with a different solution

190
00:06:07,199 --> 00:06:10,400
where you can just use a hash table so

191
00:06:10,400 --> 00:06:12,400
here the the the access tokens would be

192
00:06:12,400 --> 00:06:15,039
prf evaluations of the keyword then you

193
00:06:15,039 --> 00:06:16,960
store the identified you split up the

194
00:06:16,960 --> 00:06:19,600
lists into the signal identifiers and

195
00:06:19,600 --> 00:06:22,080
then you just store them

196
00:06:22,080 --> 00:06:23,759
like in the hash table on the server and

197
00:06:23,759 --> 00:06:26,240
now because the the locations clearly

198
00:06:26,240 --> 00:06:28,160
only depend on the keyword everything is

199
00:06:28,160 --> 00:06:30,639
independent and we're secure so this

200
00:06:30,639 --> 00:06:32,560
works but now there's this problem that

201
00:06:32,560 --> 00:06:34,800
was identified by cash and tesara in

202
00:06:34,800 --> 00:06:39,039
2000 2014 um essentially now the

203
00:06:39,039 --> 00:06:40,479
retrieval

204
00:06:40,479 --> 00:06:42,479
introduces a bunch of memory like random

205
00:06:42,479 --> 00:06:44,080
memory excesses

206
00:06:44,080 --> 00:06:46,160
and this is problematic for efficiency

207
00:06:46,160 --> 00:06:47,520
of course

208
00:06:47,520 --> 00:06:49,199
um and actually it introduces like a

209
00:06:49,199 --> 00:06:51,520
main bottleneck in sse

210
00:06:51,520 --> 00:06:53,199
if you really care about like concrete

211
00:06:53,199 --> 00:06:54,880
efficiency

212
00:06:54,880 --> 00:06:56,000
so

213
00:06:56,000 --> 00:06:58,000
um what can we do well for this

214
00:06:58,000 --> 00:07:00,160
generally we model the the this

215
00:07:00,160 --> 00:07:01,840
efficiency loss that we have as memory

216
00:07:01,840 --> 00:07:03,199
efficiency

217
00:07:03,199 --> 00:07:05,199
and

218
00:07:05,199 --> 00:07:07,120
generally on hds what we care about is

219
00:07:07,120 --> 00:07:10,080
locality and on ssds what we care about

220
00:07:10,080 --> 00:07:12,479
is page efficiency so

221
00:07:12,479 --> 00:07:13,680
what is that

222
00:07:13,680 --> 00:07:15,759
well for locality what you do is you

223
00:07:15,759 --> 00:07:17,680
look at the server at the server memory

224
00:07:17,680 --> 00:07:21,599
as an array of of um of yeah of

225
00:07:21,599 --> 00:07:24,319
identifiers or like of storage

226
00:07:24,319 --> 00:07:26,960
and then your goal is to essentially for

227
00:07:26,960 --> 00:07:28,800
each query you want to read at most a

228
00:07:28,800 --> 00:07:30,880
constant number of disjoint intervals

229
00:07:30,880 --> 00:07:32,960
this is really what speeds up search on

230
00:07:32,960 --> 00:07:34,240
an hdd

231
00:07:34,240 --> 00:07:37,039
then you want read efficiency

232
00:07:37,039 --> 00:07:38,560
which means you want to read as much

233
00:07:38,560 --> 00:07:40,479
like as little extra data as possible of

234
00:07:40,479 --> 00:07:41,680
course you can just read the entire

235
00:07:41,680 --> 00:07:44,479
database then you're local but yeah it's

236
00:07:44,479 --> 00:07:47,120
really slow so you want to minimize that

237
00:07:47,120 --> 00:07:48,800
and then storage efficiency also makes

238
00:07:48,800 --> 00:07:50,319
sense you of course don't want to store

239
00:07:50,319 --> 00:07:52,400
that much extra data so you want to have

240
00:07:52,400 --> 00:07:54,800
only a constant blow up

241
00:07:54,800 --> 00:07:56,960
of server memory

242
00:07:56,960 --> 00:07:58,319
and then page efficiency is kind of the

243
00:07:58,319 --> 00:08:01,039
equivalent for for ssds so here you want

244
00:08:01,039 --> 00:08:02,560
page efficiency so you want to store the

245
00:08:02,560 --> 00:08:04,800
identifier lists in as little pages as

246
00:08:04,800 --> 00:08:06,479
possible where the server memory is

247
00:08:06,479 --> 00:08:08,319
essentially like now modeled as pages of

248
00:08:08,319 --> 00:08:10,639
memory and then storage efficiencies do

249
00:08:10,639 --> 00:08:12,240
the same so only a constant blow up in

250
00:08:12,240 --> 00:08:14,720
server memory so this is our goal

251
00:08:14,720 --> 00:08:15,840
and

252
00:08:15,840 --> 00:08:17,680
um if we look at the current state of vr

253
00:08:17,680 --> 00:08:19,039
there's some really interesting works

254
00:08:19,039 --> 00:08:21,360
here so for example in as16 they

255
00:08:21,360 --> 00:08:24,560
introduced a really nice framework

256
00:08:24,560 --> 00:08:25,759
um

257
00:08:25,759 --> 00:08:28,319
for for constructing local local sse

258
00:08:28,319 --> 00:08:30,639
schemes um and essentially they they

259
00:08:30,639 --> 00:08:31,919
managed to show that you can actually

260
00:08:31,919 --> 00:08:34,559
get log log and read efficiency where

261
00:08:34,559 --> 00:08:36,719
the rest is all constant so this has

262
00:08:36,719 --> 00:08:39,519
been kind of a groundbreaking work in

263
00:08:39,519 --> 00:08:42,080
this in this field of research and then

264
00:08:42,080 --> 00:08:44,880
um based on that ass 18 even managed to

265
00:08:44,880 --> 00:08:47,600
show like you can get log log log log

266
00:08:47,600 --> 00:08:51,040
log log log n so even better but both of

267
00:08:51,040 --> 00:08:53,519
these have a small caveat where the rest

268
00:08:53,519 --> 00:08:55,360
there's a restriction on the on the long

269
00:08:55,360 --> 00:08:57,680
slits list size and if you add a log you

270
00:08:57,680 --> 00:08:59,200
get a stronger restriction on the

271
00:08:59,200 --> 00:09:01,040
longest list size essentially

272
00:09:01,040 --> 00:09:02,959
and then in dpp18 they showed that

273
00:09:02,959 --> 00:09:04,560
actually if you want sub-logarithmic

274
00:09:04,560 --> 00:09:06,399
efficiency read efficiency

275
00:09:06,399 --> 00:09:08,720
you actually also can get that um

276
00:09:08,720 --> 00:09:10,560
without this condition on the longest

277
00:09:10,560 --> 00:09:12,080
list size so here you have like slightly

278
00:09:12,080 --> 00:09:14,160
sub-logarithmic read efficiency

279
00:09:14,160 --> 00:09:16,480
and then in the page efficiency setting

280
00:09:16,480 --> 00:09:19,040
it's even a bit more uh satisfying we

281
00:09:19,040 --> 00:09:20,839
actually have constant

282
00:09:20,839 --> 00:09:24,160
efficiency with small client logarithmic

283
00:09:24,160 --> 00:09:25,680
client storage

284
00:09:25,680 --> 00:09:26,399
so

285
00:09:26,399 --> 00:09:28,720
this seems like everything is like fine

286
00:09:28,720 --> 00:09:30,480
and happy and everything seems very

287
00:09:30,480 --> 00:09:31,839
efficient

288
00:09:31,839 --> 00:09:33,279
the problem is that these are

289
00:09:33,279 --> 00:09:35,440
exclusively static constructions and all

290
00:09:35,440 --> 00:09:36,959
of them essentially run into like some

291
00:09:36,959 --> 00:09:38,640
problem if you try to like trivially

292
00:09:38,640 --> 00:09:41,279
then like make it dynamic

293
00:09:41,279 --> 00:09:43,200
so the goal of our work is essentially

294
00:09:43,200 --> 00:09:44,399
to make

295
00:09:44,399 --> 00:09:46,399
like to construct dynamic sse schemes

296
00:09:46,399 --> 00:09:47,680
that still have good efficiency

297
00:09:47,680 --> 00:09:50,080
guarantees

298
00:09:50,080 --> 00:09:51,920
and for this we work in the framework

299
00:09:51,920 --> 00:09:54,000
that was kind of introduced in asses

300
00:09:54,000 --> 00:09:56,560
a and s 16.

301
00:09:56,560 --> 00:09:59,120
so um in general what we do is we study

302
00:09:59,120 --> 00:10:01,120
balls into bins problems

303
00:10:01,120 --> 00:10:03,760
so we look at the server memory as bins

304
00:10:03,760 --> 00:10:05,680
and then we just try to see what happens

305
00:10:05,680 --> 00:10:07,600
if we throw weighted balls so these are

306
00:10:07,600 --> 00:10:10,640
the identifier lists add random into

307
00:10:10,640 --> 00:10:12,640
into these bins by a hash function so

308
00:10:12,640 --> 00:10:13,839
intuitively

309
00:10:13,839 --> 00:10:15,839
this directly translates to like a hash

310
00:10:15,839 --> 00:10:19,440
table where we have weighted items so

311
00:10:19,440 --> 00:10:21,440
in the in in like the same sense that

312
00:10:21,440 --> 00:10:23,360
previously this was okay like that

313
00:10:23,360 --> 00:10:25,279
storing items in a hash table was okay

314
00:10:25,279 --> 00:10:27,680
like here also and if we manage to get

315
00:10:27,680 --> 00:10:29,040
good upper bounds

316
00:10:29,040 --> 00:10:30,880
on the maximum a lot of these bins then

317
00:10:30,880 --> 00:10:33,040
we get very good and secure efficient

318
00:10:33,040 --> 00:10:34,640
sse schemes

319
00:10:34,640 --> 00:10:35,600
so

320
00:10:35,600 --> 00:10:37,360
that's kind of the main framework that

321
00:10:37,360 --> 00:10:38,320
we're

322
00:10:38,320 --> 00:10:41,440
like looking at and now um

323
00:10:41,440 --> 00:10:44,320
so so in this work they showed that

324
00:10:44,320 --> 00:10:46,480
if you interpret the bins as pages and

325
00:10:46,480 --> 00:10:48,959
you come up with a good balls into bins

326
00:10:48,959 --> 00:10:51,279
analyzers for waiting items then you get

327
00:10:51,279 --> 00:10:54,079
sse with overview page efficiency so so

328
00:10:54,079 --> 00:10:56,560
you being like really the thing so

329
00:10:56,560 --> 00:10:58,160
really what you're interested in is

330
00:10:58,160 --> 00:11:00,399
upper bounding the bin size

331
00:11:00,399 --> 00:11:03,760
for good efficiency and then in ns16 and

332
00:11:03,760 --> 00:11:06,240
ss16 and they showed that if you

333
00:11:06,240 --> 00:11:08,399
slightly modify your

334
00:11:08,399 --> 00:11:10,160
your bolts into bins

335
00:11:10,160 --> 00:11:11,200
um

336
00:11:11,200 --> 00:11:12,720
the way you throw the balls into bins

337
00:11:12,720 --> 00:11:15,120
essentially then you get um

338
00:11:15,120 --> 00:11:17,600
then you can also get good uh locality

339
00:11:17,600 --> 00:11:19,920
so all one locality and all of you read

340
00:11:19,920 --> 00:11:21,519
efficiency where you use again the upper

341
00:11:21,519 --> 00:11:22,320
bone

342
00:11:22,320 --> 00:11:23,920
um so yeah here essentially you just

343
00:11:23,920 --> 00:11:26,320
like throw your ball into into like a

344
00:11:26,320 --> 00:11:27,920
starting bin and then instead of storing

345
00:11:27,920 --> 00:11:29,360
all of the identifiers in the same bin

346
00:11:29,360 --> 00:11:31,600
you just saw them consecutively

347
00:11:31,600 --> 00:11:33,680
and this is how you get also um like

348
00:11:33,680 --> 00:11:35,600
okay so of course if you have like more

349
00:11:35,600 --> 00:11:37,040
than constant starting positions this

350
00:11:37,040 --> 00:11:38,399
wouldn't be local but if you have

351
00:11:38,399 --> 00:11:40,240
constant starting positions you still

352
00:11:40,240 --> 00:11:43,440
retain good locality so

353
00:11:43,440 --> 00:11:45,360
yeah so that's the framework

354
00:11:45,360 --> 00:11:46,720
um

355
00:11:46,720 --> 00:11:47,680
and

356
00:11:47,680 --> 00:11:49,440
now um

357
00:11:49,440 --> 00:11:51,920
unfortunately all of these like at least

358
00:11:51,920 --> 00:11:53,519
the the the

359
00:11:53,519 --> 00:11:55,440
like um

360
00:11:55,440 --> 00:11:57,360
the the efficient balls into bins

361
00:11:57,360 --> 00:11:59,920
allocation problems run into prob uh

362
00:11:59,920 --> 00:12:02,399
like analyzers run into problem as soon

363
00:12:02,399 --> 00:12:04,560
as we get dynamics so in this work we

364
00:12:04,560 --> 00:12:06,320
revisit two choice which is a very

365
00:12:06,320 --> 00:12:07,760
classical balls and two bins problem

366
00:12:07,760 --> 00:12:09,440
here like we just insert a bunch of

367
00:12:09,440 --> 00:12:11,600
ident items into bins and then if you

368
00:12:11,600 --> 00:12:13,279
want to insert a new item you just

369
00:12:13,279 --> 00:12:15,680
choose two bins as the name suggests add

370
00:12:15,680 --> 00:12:17,920
random and then you insert the item in

371
00:12:17,920 --> 00:12:19,839
the least loaded bin and then you get

372
00:12:19,839 --> 00:12:21,360
all of log log and efficiency and that's

373
00:12:21,360 --> 00:12:22,720
kind of where like in the previous

374
00:12:22,720 --> 00:12:24,720
state-of-the-art constructions you get

375
00:12:24,720 --> 00:12:27,600
this log block and from for example

376
00:12:27,600 --> 00:12:30,320
so this would be nice to have

377
00:12:30,320 --> 00:12:31,200
in like

378
00:12:31,200 --> 00:12:33,040
in a weighted form so if we can

379
00:12:33,040 --> 00:12:34,320
guarantee that even though we insert

380
00:12:34,320 --> 00:12:35,920
weighted items

381
00:12:35,920 --> 00:12:37,040
um

382
00:12:37,040 --> 00:12:38,560
if we can then still guarantee this log

383
00:12:38,560 --> 00:12:40,560
log and then we would be very happy

384
00:12:40,560 --> 00:12:42,560
um unfortunately

385
00:12:42,560 --> 00:12:44,079
um

386
00:12:44,079 --> 00:12:46,480
that's not that trivial actually so so

387
00:12:46,480 --> 00:12:48,480
just showing for plane way to two choice

388
00:12:48,480 --> 00:12:50,560
um that's kind of hard actually and

389
00:12:50,560 --> 00:12:52,480
there are some existing results

390
00:12:52,480 --> 00:12:54,480
um but they're always conditional so

391
00:12:54,480 --> 00:12:56,959
either you require some distributions

392
00:12:56,959 --> 00:12:59,839
um so that's of course uh not sufficient

393
00:12:59,839 --> 00:13:01,760
because the in sse because the attacker

394
00:13:01,760 --> 00:13:03,279
kind of controls the distribution of the

395
00:13:03,279 --> 00:13:04,639
inserted items

396
00:13:04,639 --> 00:13:06,560
and then also pre-sorting which is

397
00:13:06,560 --> 00:13:08,959
perfectly fine for static databases but

398
00:13:08,959 --> 00:13:10,720
as soon as you get something dynamic

399
00:13:10,720 --> 00:13:12,880
this kind of doesn't work either

400
00:13:12,880 --> 00:13:15,040
so our solution to this problem is to

401
00:13:15,040 --> 00:13:17,440
slightly modify the comparison

402
00:13:17,440 --> 00:13:19,040
functionality or like the comparison

403
00:13:19,040 --> 00:13:21,040
choice and two choice

404
00:13:21,040 --> 00:13:23,120
um and then like essentially what we get

405
00:13:23,120 --> 00:13:24,480
is something that behaves almost like

406
00:13:24,480 --> 00:13:26,240
standard two choice

407
00:13:26,240 --> 00:13:29,279
um but we don't require any distribution

408
00:13:29,279 --> 00:13:31,440
assumptions and no pre-sorting so this

409
00:13:31,440 --> 00:13:32,720
works dynamically and that's kind of

410
00:13:32,720 --> 00:13:34,320
what we need in order to instantiate the

411
00:13:34,320 --> 00:13:35,519
framework

412
00:13:35,519 --> 00:13:36,480
um

413
00:13:36,480 --> 00:13:38,000
and we can also show the same tight

414
00:13:38,000 --> 00:13:40,160
upper bound so like oh vlog log n for

415
00:13:40,160 --> 00:13:41,519
for efficiency

416
00:13:41,519 --> 00:13:43,120
and then like just plugging into the

417
00:13:43,120 --> 00:13:44,720
framework we get essentially a dynamic

418
00:13:44,720 --> 00:13:47,360
sse scheme with o tilde of log log n

419
00:13:47,360 --> 00:13:49,360
over p page efficiency

420
00:13:49,360 --> 00:13:52,560
so at least we covered now the um the

421
00:13:52,560 --> 00:13:53,920
page efficient case but what about

422
00:13:53,920 --> 00:13:55,440
locality

423
00:13:55,440 --> 00:13:58,399
and for this essentially we construct

424
00:13:58,399 --> 00:14:00,959
a new transformation so we call it the

425
00:14:00,959 --> 00:14:03,199
generic local transformation that allows

426
00:14:03,199 --> 00:14:04,240
you to

427
00:14:04,240 --> 00:14:06,480
take any page efficient dynamic sse

428
00:14:06,480 --> 00:14:08,800
scheme so here are some kind of like

429
00:14:08,800 --> 00:14:10,000
there are some conditions that i'm not

430
00:14:10,000 --> 00:14:11,680
going to talk about in the case

431
00:14:11,680 --> 00:14:13,760
in the talk but they're not that

432
00:14:13,760 --> 00:14:15,199
that strong and then you can transform

433
00:14:15,199 --> 00:14:18,800
it into a local dynamic ssd scheme

434
00:14:18,800 --> 00:14:20,800
and on a high level what we're doing is

435
00:14:20,800 --> 00:14:24,000
we're using an overflowing sse scheme so

436
00:14:24,000 --> 00:14:26,000
this is the sse scheme in the bottom

437
00:14:26,000 --> 00:14:28,320
that has very good local properties so

438
00:14:28,320 --> 00:14:30,399
good read efficiency good locality good

439
00:14:30,399 --> 00:14:32,800
uh good storage efficiency

440
00:14:32,800 --> 00:14:34,160
um

441
00:14:34,160 --> 00:14:36,800
but uh this scheme we cannot actually

442
00:14:36,800 --> 00:14:38,720
show that it won't overflow and in fact

443
00:14:38,720 --> 00:14:41,199
also maybe i can practice it even even

444
00:14:41,199 --> 00:14:42,480
like in practice it will probably

445
00:14:42,480 --> 00:14:44,639
overflow

446
00:14:44,639 --> 00:14:46,000
and then essentially we deal with the

447
00:14:46,000 --> 00:14:48,079
overflow in another way

448
00:14:48,079 --> 00:14:49,760
and um

449
00:14:49,760 --> 00:14:51,440
actually here we can use page efficient

450
00:14:51,440 --> 00:14:54,000
sse scheme so it turns out that if we

451
00:14:54,000 --> 00:14:56,720
structure the sse schemes in a hierarchy

452
00:14:56,720 --> 00:14:57,519
where

453
00:14:57,519 --> 00:14:59,760
the page size so this is essentially

454
00:14:59,760 --> 00:15:00,639
like

455
00:15:00,639 --> 00:15:02,480
if you if you think about um like the

456
00:15:02,480 --> 00:15:04,560
framework this is kind of the bin size

457
00:15:04,560 --> 00:15:06,399
that we're using

458
00:15:06,399 --> 00:15:07,760
um skate wide

459
00:15:07,760 --> 00:15:10,560
with the upper bound and so if we use if

460
00:15:10,560 --> 00:15:15,279
we if we um instantiate the page size um

461
00:15:15,279 --> 00:15:16,800
with like this powers of two tricks or

462
00:15:16,800 --> 00:15:19,199
exponentially growing and then actually

463
00:15:19,199 --> 00:15:20,720
we can just store the overflowing items

464
00:15:20,720 --> 00:15:22,720
in our page efficient sse schemes and

465
00:15:22,720 --> 00:15:24,839
then get good pay uh like this good page

466
00:15:24,839 --> 00:15:27,199
efficiency then translates to good

467
00:15:27,199 --> 00:15:28,959
locality and good read efficiency

468
00:15:28,959 --> 00:15:30,160
actually

469
00:15:30,160 --> 00:15:32,399
um and yeah this we like the first like

470
00:15:32,399 --> 00:15:33,600
the overflowing sse scheme we

471
00:15:33,600 --> 00:15:34,959
instantiate with a variant of two

472
00:15:34,959 --> 00:15:36,959
dynamic general one a two

473
00:15:36,959 --> 00:15:40,240
two dimensional one choice from ns16 and

474
00:15:40,240 --> 00:15:41,680
the second one with our construction

475
00:15:41,680 --> 00:15:42,959
with the page efficient construction

476
00:15:42,959 --> 00:15:45,759
from layered sse

477
00:15:45,759 --> 00:15:46,720
so

478
00:15:46,720 --> 00:15:48,880
i still have a bit of time to go into at

479
00:15:48,880 --> 00:15:51,360
least some technical details

480
00:15:51,360 --> 00:15:54,240
um so in in a bit more detail what's

481
00:15:54,240 --> 00:15:57,120
happening is we use this like um

482
00:15:57,120 --> 00:15:59,360
we use this this like standard

483
00:15:59,360 --> 00:16:00,720
two-dimensional one-choice technique so

484
00:16:00,720 --> 00:16:02,480
intuitively we choose one bin at random

485
00:16:02,480 --> 00:16:04,320
and then that's the starting position

486
00:16:04,320 --> 00:16:05,680
and then

487
00:16:05,680 --> 00:16:08,639
like from that bin on we just um insert

488
00:16:08,639 --> 00:16:11,120
lists consecutively in the bin as here

489
00:16:11,120 --> 00:16:13,680
and then um what you can show is that

490
00:16:13,680 --> 00:16:14,560
this

491
00:16:14,560 --> 00:16:17,440
like the upper bound here is of log n

492
00:16:17,440 --> 00:16:20,000
so this has already been shown in as16

493
00:16:20,000 --> 00:16:22,079
but now what we do is we use a technique

494
00:16:22,079 --> 00:16:24,639
from asus 18 which is just cutting off

495
00:16:24,639 --> 00:16:27,440
the the bin size at a certain fixed

496
00:16:27,440 --> 00:16:28,560
point

497
00:16:28,560 --> 00:16:30,720
and now we don't have any guarantees

498
00:16:30,720 --> 00:16:32,800
anymore that these bins won't overflow

499
00:16:32,800 --> 00:16:34,800
so we expect there to be some certain

500
00:16:34,800 --> 00:16:37,360
like some type of overflow that we still

501
00:16:37,360 --> 00:16:39,040
have to deal with otherwise with our

502
00:16:39,040 --> 00:16:40,959
page efficient hierarchy

503
00:16:40,959 --> 00:16:43,120
um and kind of the core technical

504
00:16:43,120 --> 00:16:45,120
dilemma here is that the overflow is

505
00:16:45,120 --> 00:16:46,160
actually

506
00:16:46,160 --> 00:16:50,240
upper bounded by off and over polylog n

507
00:16:50,240 --> 00:16:52,079
and this is very interesting because now

508
00:16:52,079 --> 00:16:53,519
even though we have a logarithmic number

509
00:16:53,519 --> 00:16:55,759
of page efficient sse schemes

510
00:16:55,759 --> 00:16:56,560
um

511
00:16:56,560 --> 00:16:58,079
we still get

512
00:16:58,079 --> 00:17:00,160
constant storage efficiency because log

513
00:17:00,160 --> 00:17:04,480
n and the polylog and this cancels out

514
00:17:04,559 --> 00:17:05,050
and then

515
00:17:05,050 --> 00:17:06,400
[Music]

516
00:17:06,400 --> 00:17:08,319
essentially

517
00:17:08,319 --> 00:17:10,160
if you if you insert an item now that is

518
00:17:10,160 --> 00:17:11,760
overflowing for example here the purple

519
00:17:11,760 --> 00:17:13,599
list the new identifier would be

520
00:17:13,599 --> 00:17:15,280
overflowing because the fifth pin is

521
00:17:15,280 --> 00:17:16,480
already full

522
00:17:16,480 --> 00:17:18,640
so what we do is we

523
00:17:18,640 --> 00:17:20,559
um essentially take the next highest

524
00:17:20,559 --> 00:17:23,039
power of two so we we take here for

525
00:17:23,039 --> 00:17:26,000
example the the list size is five so we

526
00:17:26,000 --> 00:17:27,919
would take the next higher power of two

527
00:17:27,919 --> 00:17:29,039
which is eight

528
00:17:29,039 --> 00:17:31,200
and then we store this identifier that

529
00:17:31,200 --> 00:17:32,480
is overflowing

530
00:17:32,480 --> 00:17:35,919
in the in the page efficient sse scheme

531
00:17:35,919 --> 00:17:39,039
that has uh like this page size

532
00:17:39,039 --> 00:17:41,200
um and then essentially it turns out

533
00:17:41,200 --> 00:17:43,760
that all the efficiency guarantees

534
00:17:43,760 --> 00:17:46,080
almost directly translate so we get o

535
00:17:46,080 --> 00:17:48,480
tilde of log log and read efficiency but

536
00:17:48,480 --> 00:17:50,400
here there's the slight caveat

537
00:17:50,400 --> 00:17:52,799
again can't go too much into detail but

538
00:17:52,799 --> 00:17:55,360
again as in the previous constructions

539
00:17:55,360 --> 00:17:58,080
that have like log log read efficiency

540
00:17:58,080 --> 00:17:59,440
we again have a restriction on the

541
00:17:59,440 --> 00:18:02,320
longest list size

542
00:18:02,400 --> 00:18:04,320
okay and this

543
00:18:04,320 --> 00:18:06,000
already um

544
00:18:06,000 --> 00:18:07,600
leads us to the last construction of the

545
00:18:07,600 --> 00:18:10,480
paper which is an unconditioned local

546
00:18:10,480 --> 00:18:13,919
static sse scheme so here the goal is to

547
00:18:13,919 --> 00:18:16,240
like what to see what we can actually do

548
00:18:16,240 --> 00:18:18,480
if we don't have this condition on the

549
00:18:18,480 --> 00:18:20,000
longest uh the restriction on the

550
00:18:20,000 --> 00:18:21,600
longest this size

551
00:18:21,600 --> 00:18:23,440
and there's also already a work that

552
00:18:23,440 --> 00:18:26,720
does this with lo or or vlog 2 to the

553
00:18:26,720 --> 00:18:28,400
2 over three plus epsilon

554
00:18:28,400 --> 00:18:29,919
and read efficiency

555
00:18:29,919 --> 00:18:32,720
um in dpp18

556
00:18:32,720 --> 00:18:35,039
and in this work we kind of revisit that

557
00:18:35,039 --> 00:18:36,080
framework

558
00:18:36,080 --> 00:18:36,880
and

559
00:18:36,880 --> 00:18:38,640
we observe that actually the generic

560
00:18:38,640 --> 00:18:40,320
local transform that i talked about a

561
00:18:40,320 --> 00:18:42,400
few minutes ago actually allows us to

562
00:18:42,400 --> 00:18:43,840
remove the main bottleneck from that

563
00:18:43,840 --> 00:18:46,000
construction

564
00:18:46,000 --> 00:18:48,400
and so for this we first generalize a

565
00:18:48,400 --> 00:18:50,080
local orm that they also introduce in

566
00:18:50,080 --> 00:18:53,039
their paper to more levels of hierarchy

567
00:18:53,039 --> 00:18:56,080
and then we again as in their framework

568
00:18:56,080 --> 00:18:58,000
handle this uh lists with different

569
00:18:58,000 --> 00:19:00,559
sizes by different sse schemes but now

570
00:19:00,559 --> 00:19:02,240
we can actually remove from the small

571
00:19:02,240 --> 00:19:04,000
and medium sized lists we can remove the

572
00:19:04,000 --> 00:19:05,760
main bottleneck while the generic local

573
00:19:05,760 --> 00:19:08,080
transform and then if we use the local

574
00:19:08,080 --> 00:19:10,480
orm again for sorting large lists and

575
00:19:10,480 --> 00:19:12,640
then for huge lists if we proceed the

576
00:19:12,640 --> 00:19:15,280
same way we can actually move this two

577
00:19:15,280 --> 00:19:16,480
over three

578
00:19:16,480 --> 00:19:18,799
in the in the exponent so we get an sse

579
00:19:18,799 --> 00:19:21,440
scheme that is static but still has all

580
00:19:21,440 --> 00:19:23,120
of log to the power epsilon entry

581
00:19:23,120 --> 00:19:24,320
deficiency

582
00:19:24,320 --> 00:19:25,840
um

583
00:19:25,840 --> 00:19:28,160
yeah so these are all the constructions

584
00:19:28,160 --> 00:19:28,500
um

585
00:19:28,500 --> 00:19:30,080
[Music]

586
00:19:30,080 --> 00:19:33,039
of of our paper so

587
00:19:33,039 --> 00:19:35,039
um this brings me already almost to the

588
00:19:35,039 --> 00:19:37,200
end so a small recap of what we did in

589
00:19:37,200 --> 00:19:39,440
this article is we introduced a weighted

590
00:19:39,440 --> 00:19:41,600
variant of two choice which hopefully is

591
00:19:41,600 --> 00:19:43,120
also independent interest because two

592
00:19:43,120 --> 00:19:44,160
choice has a lot of different

593
00:19:44,160 --> 00:19:45,440
applications

594
00:19:45,440 --> 00:19:47,440
um also in the weighted variant

595
00:19:47,440 --> 00:19:48,320
then

596
00:19:48,320 --> 00:19:50,320
we also introduce the first dynamic

597
00:19:50,320 --> 00:19:51,840
memory efficient sse schemes with like

598
00:19:51,840 --> 00:19:54,000
concrete efficiency guarantees

599
00:19:54,000 --> 00:19:56,640
and um yeah this generic local transform

600
00:19:56,640 --> 00:19:57,919
essentially draws a new connection

601
00:19:57,919 --> 00:19:59,760
between page efficient locality into

602
00:19:59,760 --> 00:20:01,600
page efficiency because the inverse

603
00:20:01,600 --> 00:20:03,200
direction has already been drawn like

604
00:20:03,200 --> 00:20:05,120
that's kind of trivial but actually also

605
00:20:05,120 --> 00:20:06,880
from page efficiency you can now also

606
00:20:06,880 --> 00:20:10,080
get certain local schemes

607
00:20:10,080 --> 00:20:12,640
and also um yeah we also choose the best

608
00:20:12,640 --> 00:20:14,320
unconditional scheme by essentially like

609
00:20:14,320 --> 00:20:16,559
revisiting the old framework

610
00:20:16,559 --> 00:20:19,440
so this is what we did in this app

611
00:20:19,440 --> 00:20:21,600
oops

612
00:20:21,600 --> 00:20:23,360
okay

613
00:20:23,360 --> 00:20:25,600
i guess there's no last slide

614
00:20:25,600 --> 00:20:27,039
i just wanted to quickly talk about a

615
00:20:27,039 --> 00:20:28,559
bunch of open problems so i guess i do

616
00:20:28,559 --> 00:20:30,080
it with our slides so the first thing is

617
00:20:30,080 --> 00:20:32,640
we're not forward secure so can we get

618
00:20:32,640 --> 00:20:36,480
forward security second one um that we

619
00:20:36,480 --> 00:20:37,919
we think is very interesting is can we

620
00:20:37,919 --> 00:20:40,640
actually get like a a pure analysis of

621
00:20:40,640 --> 00:20:43,200
two choice so now we kind of

622
00:20:43,200 --> 00:20:45,440
we we have almost two choice but not

623
00:20:45,440 --> 00:20:49,039
really so like it still has similar

624
00:20:49,039 --> 00:20:50,720
like all the properties that we kind of

625
00:20:50,720 --> 00:20:53,760
need for most case use cases but the

626
00:20:53,760 --> 00:20:55,440
question is like can we get something

627
00:20:55,440 --> 00:20:56,799
pure can we get something really

628
00:20:56,799 --> 00:20:59,120
theoretically satisfying um so that's

629
00:20:59,120 --> 00:21:00,799
like a very interesting open question i

630
00:21:00,799 --> 00:21:03,120
think and then the last one is what like

631
00:21:03,120 --> 00:21:04,720
so the there are slower bonds that have

632
00:21:04,720 --> 00:21:07,440
been studied um and some nice works in

633
00:21:07,440 --> 00:21:09,039
the static case but what about the

634
00:21:09,039 --> 00:21:11,200
dynamic case are there still lower bonds

635
00:21:11,200 --> 00:21:13,360
what can we actually achieve

636
00:21:13,360 --> 00:21:15,440
and yeah that's the end of my talk thank

637
00:21:15,440 --> 00:21:16,880
you very much for listening

638
00:21:16,880 --> 00:21:20,120
and yeah

639
00:21:30,960 --> 00:21:32,240
so um

640
00:21:32,240 --> 00:21:34,320
yeah i have a question so your

641
00:21:34,320 --> 00:21:36,000
your transformation

642
00:21:36,000 --> 00:21:38,240
um that goes from page efficient to

643
00:21:38,240 --> 00:21:39,200
local

644
00:21:39,200 --> 00:21:40,640
so i guess i have two questions so one

645
00:21:40,640 --> 00:21:42,960
of them is is it um

646
00:21:42,960 --> 00:21:45,039
does it give you like does it preserve

647
00:21:45,039 --> 00:21:47,360
or does it give you like optimal schemes

648
00:21:47,360 --> 00:21:50,880
uh no in fact so what we show is um

649
00:21:50,880 --> 00:21:53,840
so so because we have this this cutoff

650
00:21:53,840 --> 00:21:55,600
at log log n essentially we preserve

651
00:21:55,600 --> 00:21:58,080
like anything up to log log n but

652
00:21:58,080 --> 00:21:59,600
anything like that is constant for

653
00:21:59,600 --> 00:22:00,880
example we wouldn't preserve that

654
00:22:00,880 --> 00:22:02,400
because we can i mean if we cut off a

655
00:22:02,400 --> 00:22:03,600
constant then we don't have this

656
00:22:03,600 --> 00:22:05,840
overflow guarantee anymore so it only

657
00:22:05,840 --> 00:22:08,320
preserves up to log log n efficiency

658
00:22:08,320 --> 00:22:11,600
um yeah unfortunately um

659
00:22:11,600 --> 00:22:12,799
and

660
00:22:12,799 --> 00:22:14,640
i forget what my second question was uh

661
00:22:14,640 --> 00:22:17,360
it was still related to your uh to your

662
00:22:17,360 --> 00:22:20,240
to your transformation uh yeah so do you

663
00:22:20,240 --> 00:22:21,200
is it

664
00:22:21,200 --> 00:22:22,400
when you

665
00:22:22,400 --> 00:22:24,400
use this transformation can you get

666
00:22:24,400 --> 00:22:26,640
pre-existing schemes

667
00:22:26,640 --> 00:22:28,799
uh like is there basically

668
00:22:28,799 --> 00:22:30,480
a situation where

669
00:22:30,480 --> 00:22:31,919
uh you can see that there were

670
00:22:31,919 --> 00:22:33,760
pre-existing pre-existing local schemes

671
00:22:33,760 --> 00:22:35,120
that happened to be

672
00:22:35,120 --> 00:22:36,240
the result of applying your

673
00:22:36,240 --> 00:22:38,320
transformation to something i

674
00:22:38,320 --> 00:22:40,400
don't think so because page efficient

675
00:22:40,400 --> 00:22:42,400
schemes are kind of new and and this

676
00:22:42,400 --> 00:22:44,720
kind of way of thinking like about page

677
00:22:44,720 --> 00:22:46,799
efficiency i don't think that i

678
00:22:46,799 --> 00:22:48,320
i mean at least to my knowledge there's

679
00:22:48,320 --> 00:22:50,320
nothing that's like concretely

680
00:22:50,320 --> 00:22:52,240
like in this framework

681
00:22:52,240 --> 00:22:53,039
um

682
00:22:53,039 --> 00:22:54,960
yeah just so happens to like retain the

683
00:22:54,960 --> 00:22:57,919
same upper bounds uh like as as in other

684
00:22:57,919 --> 00:22:59,520
local sse schemes

685
00:22:59,520 --> 00:23:01,120
um because again we like in the sports

686
00:23:01,120 --> 00:23:03,679
into ben's framework but but i think the

687
00:23:03,679 --> 00:23:06,080
techniques are are different and i don't

688
00:23:06,080 --> 00:23:08,080
think there's so it's really giving you

689
00:23:08,080 --> 00:23:10,240
very very different constructions than

690
00:23:10,240 --> 00:23:11,760
there are

691
00:23:11,760 --> 00:23:15,520
uh yeah i would say so i mean um

692
00:23:15,520 --> 00:23:17,120
that's also i think what what kind of

693
00:23:17,120 --> 00:23:19,760
enables dynamism um and why like other

694
00:23:19,760 --> 00:23:21,120
constructions are not in here like

695
00:23:21,120 --> 00:23:22,880
inherently dynamic

696
00:23:22,880 --> 00:23:23,919
yeah

697
00:23:23,919 --> 00:23:25,840
thanks very much

698
00:23:25,840 --> 00:23:26,880
all right so let's thank the speaker

699
00:23:26,880 --> 00:23:29,880
again

700
00:23:55,520 --> 00:23:58,080
hi so

701
00:24:00,159 --> 00:24:03,159
yes

702
00:24:15,279 --> 00:24:16,559
all right

703
00:24:16,559 --> 00:24:18,080
so the second talk is going to be given

704
00:24:18,080 --> 00:24:21,360
by victor kolabov from technion and he's

705
00:24:21,360 --> 00:24:22,799
going to be talking about distributed

706
00:24:22,799 --> 00:24:25,918
distributed point functions

707
00:24:26,320 --> 00:24:28,720
uh hi so i'm victor and today i'm going

708
00:24:28,720 --> 00:24:30,000
to talk to you about programmable

709
00:24:30,000 --> 00:24:31,840
distributed point functions and this is

710
00:24:31,840 --> 00:24:34,320
a joint work with great boy liv gilboa

711
00:24:34,320 --> 00:24:35,760
and diwali

712
00:24:35,760 --> 00:24:38,159
so first

713
00:24:38,159 --> 00:24:39,760
talk about

714
00:24:39,760 --> 00:24:41,200
point functions

715
00:24:41,200 --> 00:24:42,960
so point functions are just functions

716
00:24:42,960 --> 00:24:44,720
which can be

717
00:24:44,720 --> 00:24:47,200
non-zero on one spatial point and zero

718
00:24:47,200 --> 00:24:48,799
everywhere else

719
00:24:48,799 --> 00:24:50,559
uh and we

720
00:24:50,559 --> 00:24:52,960
and the output set of this

721
00:24:52,960 --> 00:24:55,200
of the poi functions we assume it's

722
00:24:55,200 --> 00:24:57,120
in a billion group which can be either

723
00:24:57,120 --> 00:24:58,880
finite or infinite

724
00:24:58,880 --> 00:25:01,120
and a distributed point function is just

725
00:25:01,120 --> 00:25:03,039
a way to signature this point function

726
00:25:03,039 --> 00:25:05,200
between two servers in such a way that

727
00:25:05,200 --> 00:25:06,960
it allows for distributed evaluation

728
00:25:06,960 --> 00:25:09,520
such that if we add together the output

729
00:25:09,520 --> 00:25:11,200
shell from the servers we get back the

730
00:25:11,200 --> 00:25:13,360
value of the point function

731
00:25:13,360 --> 00:25:16,000
and the dpf's so these two point

732
00:25:16,000 --> 00:25:17,840
functions are useful in building blocks

733
00:25:17,840 --> 00:25:19,679
for mainly the cryptographic

734
00:25:19,679 --> 00:25:22,159
applications some of them will talk a

735
00:25:22,159 --> 00:25:24,240
bit more about later

736
00:25:24,240 --> 00:25:25,120
and

737
00:25:25,120 --> 00:25:27,120
regarding feasibility so there is a

738
00:25:27,120 --> 00:25:29,279
trivial construction

739
00:25:29,279 --> 00:25:32,159
for a dpf with linear key size by just

740
00:25:32,159 --> 00:25:34,480
signaturing the troop table

741
00:25:34,480 --> 00:25:35,440
of the

742
00:25:35,440 --> 00:25:38,799
dpf so we have the point function

743
00:25:38,799 --> 00:25:40,720
however if we

744
00:25:40,720 --> 00:25:42,320
assume the existence of one way function

745
00:25:42,320 --> 00:25:45,279
there is a dramatically stronger scheme

746
00:25:45,279 --> 00:25:47,840
uh using a dji reconstruction which only

747
00:25:47,840 --> 00:25:51,440
has located in size and actually in some

748
00:25:51,440 --> 00:25:54,400
sense this construction is typing that

749
00:25:54,400 --> 00:25:55,679
dpf

750
00:25:55,679 --> 00:25:58,559
implies one way function

751
00:25:58,559 --> 00:26:00,000
so

752
00:26:00,000 --> 00:26:02,240
this is regarding two servers

753
00:26:02,240 --> 00:26:03,120
uh

754
00:26:03,120 --> 00:26:05,520
some of the applications of dpf also

755
00:26:05,520 --> 00:26:06,559
have

756
00:26:06,559 --> 00:26:08,720
so the applications in the

757
00:26:08,720 --> 00:26:11,600
client server setting with two servers

758
00:26:11,600 --> 00:26:13,840
also have an analogous application in

759
00:26:13,840 --> 00:26:15,279
the client server model in the one

760
00:26:15,279 --> 00:26:16,880
server setting

761
00:26:16,880 --> 00:26:20,000
and there the existing solutions require

762
00:26:20,000 --> 00:26:21,039
a

763
00:26:21,039 --> 00:26:22,640
public key

764
00:26:22,640 --> 00:26:25,440
encryption and the other publicly

765
00:26:25,440 --> 00:26:27,039
assumptions

766
00:26:27,039 --> 00:26:29,360
and in this work this is something we

767
00:26:29,360 --> 00:26:30,880
try to avoid

768
00:26:30,880 --> 00:26:32,880
so

769
00:26:32,880 --> 00:26:34,559
the contributions of our work is first

770
00:26:34,559 --> 00:26:37,360
we define a stronger notion of

771
00:26:37,360 --> 00:26:39,919
vpn which we'll talk about shortly

772
00:26:39,919 --> 00:26:41,120
also

773
00:26:41,120 --> 00:26:42,720
we

774
00:26:42,720 --> 00:26:45,679
introduce a new approach to constructing

775
00:26:45,679 --> 00:26:49,440
dps which does not follow the ggm

776
00:26:49,440 --> 00:26:51,360
the ggm3

777
00:26:51,360 --> 00:26:52,799
construction paradigm at least not

778
00:26:52,799 --> 00:26:55,120
directly and we discussed some

779
00:26:55,120 --> 00:26:58,959
applications of this stronger notion

780
00:26:59,039 --> 00:27:01,200
so

781
00:27:02,320 --> 00:27:03,760
this new notion

782
00:27:03,760 --> 00:27:06,559
we tell programmable dpf and it's

783
00:27:06,559 --> 00:27:08,320
essentially a dpf

784
00:27:08,320 --> 00:27:10,159
with the only exception that the first

785
00:27:10,159 --> 00:27:12,400
key the opening key is just a short

786
00:27:12,400 --> 00:27:14,880
random seed and it can be generated in

787
00:27:14,880 --> 00:27:16,470
an independent way to

788
00:27:16,470 --> 00:27:18,960
[Music]

789
00:27:18,960 --> 00:27:21,120
independent efficient to even the point

790
00:27:21,120 --> 00:27:23,279
function so even

791
00:27:23,279 --> 00:27:25,039
can generate it before knowing what is

792
00:27:25,039 --> 00:27:26,960
the point function

793
00:27:26,960 --> 00:27:28,640
and

794
00:27:28,640 --> 00:27:31,120
the way we call it the reason we call it

795
00:27:31,120 --> 00:27:34,960
for example dpf is because

796
00:27:34,960 --> 00:27:37,200
we say that the second key the unlikely

797
00:27:37,200 --> 00:27:40,159
can be programmed even while

798
00:27:40,159 --> 00:27:42,880
once the offline key is already set so

799
00:27:42,880 --> 00:27:44,799
we're open to suggestions for

800
00:27:44,799 --> 00:27:46,480
for better names

801
00:27:46,480 --> 00:27:48,559
and this can be viewed as a power of 1.5

802
00:27:48,559 --> 00:27:52,080
cellular dpf because the interaction

803
00:27:52,080 --> 00:27:54,559
with the offline server is very limited

804
00:27:54,559 --> 00:27:56,720
in terms of communication and even the

805
00:27:56,720 --> 00:27:58,640
fact that it can be run in some sort of

806
00:27:58,640 --> 00:28:00,399
offline phase

807
00:28:00,399 --> 00:28:01,840
and

808
00:28:01,840 --> 00:28:03,440
in fact this notion

809
00:28:03,440 --> 00:28:04,880
implies

810
00:28:04,880 --> 00:28:08,240
an even stronger notion of uh

811
00:28:08,240 --> 00:28:11,039
reusable dpf where the offline c can be

812
00:28:11,039 --> 00:28:14,720
used over multiple instances of bdf

813
00:28:14,720 --> 00:28:18,240
and the in similar fashion to dpf uh the

814
00:28:18,240 --> 00:28:20,000
pvpfs also

815
00:28:20,000 --> 00:28:21,760
have a table construction with linear

816
00:28:21,760 --> 00:28:24,640
key size by just having the offline key

817
00:28:24,640 --> 00:28:27,520
be the key of pls

818
00:28:27,520 --> 00:28:29,360
and the online key is just the truth

819
00:28:29,360 --> 00:28:30,799
table of the point function minus the

820
00:28:30,799 --> 00:28:33,039
truth table of the period

821
00:28:33,039 --> 00:28:35,760
so our goal in this work was to try and

822
00:28:35,760 --> 00:28:37,760
finish in function with sublinear

823
00:28:37,760 --> 00:28:40,000
precise

824
00:28:40,000 --> 00:28:40,720
so

825
00:28:40,720 --> 00:28:42,480
we first start with a construction with

826
00:28:42,480 --> 00:28:44,720
just one over only one of the poly

827
00:28:44,720 --> 00:28:46,960
biases and this is inspired by the

828
00:28:46,960 --> 00:28:50,240
functional set of programs in kogan

829
00:28:50,240 --> 00:28:53,840
so suppose we draw a pulse into bins

830
00:28:53,840 --> 00:28:55,679
and we count how many

831
00:28:55,679 --> 00:28:57,760
balls we have in each bin

832
00:28:57,760 --> 00:28:59,440
this gives us a histogram and this

833
00:28:59,440 --> 00:29:02,320
histogram corresponds to the truth table

834
00:29:02,320 --> 00:29:04,080
of the offering function chart so we

835
00:29:04,080 --> 00:29:07,039
give it to one of the parties

836
00:29:07,039 --> 00:29:07,919
uh

837
00:29:07,919 --> 00:29:09,679
now once we know what is the point

838
00:29:09,679 --> 00:29:11,520
function we want to share

839
00:29:11,520 --> 00:29:13,039
uh suppose that

840
00:29:13,039 --> 00:29:15,679
as in this example alpha equals seven so

841
00:29:15,679 --> 00:29:17,440
alpha is the special the input of the

842
00:29:17,440 --> 00:29:18,640
point function

843
00:29:18,640 --> 00:29:21,679
then we just remove a one ball from b

844
00:29:21,679 --> 00:29:24,080
number seven and give this a modified

845
00:29:24,080 --> 00:29:26,159
histogram to the other about the other

846
00:29:26,159 --> 00:29:27,440
server

847
00:29:27,440 --> 00:29:29,039
and note that

848
00:29:29,039 --> 00:29:30,399
if we look at the difference between

849
00:29:30,399 --> 00:29:32,640
these histograms over the integers

850
00:29:32,640 --> 00:29:35,120
that this gives us the dba because the

851
00:29:35,120 --> 00:29:37,039
history of the vehicle only on that

852
00:29:37,039 --> 00:29:38,240
special

853
00:29:38,240 --> 00:29:39,679
beam

854
00:29:39,679 --> 00:29:42,080
now histogram descriptions are long but

855
00:29:42,080 --> 00:29:44,399
we can compress them using functional

856
00:29:44,399 --> 00:29:45,760
periods

857
00:29:45,760 --> 00:29:48,080
in similar fashion to the function

858
00:29:48,080 --> 00:29:50,240
gives and covalently

859
00:29:50,240 --> 00:29:53,120
so regarding the privacy of these

860
00:29:53,120 --> 00:29:55,360
contractions so we are throwing embold

861
00:29:55,360 --> 00:29:56,960
into end beats

862
00:29:56,960 --> 00:29:59,120
and we then remove

863
00:29:59,120 --> 00:30:01,440
a random ball from a single beam so in

864
00:30:01,440 --> 00:30:04,080
this example i do alpha 1 or alpha 2 and

865
00:30:04,080 --> 00:30:06,960
we ask what is the

866
00:30:06,960 --> 00:30:08,559
what is the statistical distance between

867
00:30:08,559 --> 00:30:10,559
these two distributions what is the

868
00:30:10,559 --> 00:30:12,799
distribution advantage

869
00:30:12,799 --> 00:30:16,000
um and we show that actually

870
00:30:16,000 --> 00:30:18,000
this can be

871
00:30:18,000 --> 00:30:20,480
bounded from above by the expectation of

872
00:30:20,480 --> 00:30:23,039
all the histograms of some

873
00:30:23,039 --> 00:30:26,960
l1 norm and this l1 norm is

874
00:30:26,960 --> 00:30:29,520
of the difference between uh

875
00:30:29,520 --> 00:30:32,480
some vector to the constant vector where

876
00:30:32,480 --> 00:30:34,880
all entries are just one over n and the

877
00:30:34,880 --> 00:30:37,200
first vector just counts

878
00:30:37,200 --> 00:30:39,520
uh how many what is the percentage of

879
00:30:39,520 --> 00:30:41,840
balls in each beam

880
00:30:41,840 --> 00:30:44,080
and

881
00:30:44,080 --> 00:30:45,600
and

882
00:30:45,600 --> 00:30:49,600
in some sense it's it's the expected the

883
00:30:49,600 --> 00:30:52,080
statistical distance of the

884
00:30:52,080 --> 00:30:54,559
empirical distribution to the

885
00:30:54,559 --> 00:30:57,360
to the actual distribution and

886
00:30:57,360 --> 00:31:00,000
this expression is also useful for us in

887
00:31:00,000 --> 00:31:04,720
showing the computational security

888
00:31:04,720 --> 00:31:06,799
and we also bound it from above from the

889
00:31:06,799 --> 00:31:09,519
base the square root of n over m

890
00:31:09,519 --> 00:31:12,159
and in some sense uh

891
00:31:12,159 --> 00:31:14,640
this is expected because the average

892
00:31:14,640 --> 00:31:17,600
number of balls in each beam is m of n

893
00:31:17,600 --> 00:31:19,279
and the standard deviation in the square

894
00:31:19,279 --> 00:31:21,519
root of that now note

895
00:31:21,519 --> 00:31:22,240
that

896
00:31:22,240 --> 00:31:24,320
this

897
00:31:24,320 --> 00:31:27,519
distinguishing advantage

898
00:31:27,519 --> 00:31:28,720
is neglect

899
00:31:28,720 --> 00:31:31,600
it is not negligible if the m

900
00:31:31,600 --> 00:31:34,399
in end so if we want to stay

901
00:31:34,399 --> 00:31:36,799
efficient in terms of the domain size we

902
00:31:36,799 --> 00:31:38,559
cannot make

903
00:31:38,559 --> 00:31:42,559
the distinction advantage negligible

904
00:31:42,799 --> 00:31:45,360
now to compress

905
00:31:45,360 --> 00:31:49,039
the systems we use the functional prx so

906
00:31:49,039 --> 00:31:51,279
first let's recall what's uh plf

907
00:31:51,279 --> 00:31:53,840
absolutely function it's

908
00:31:53,840 --> 00:31:56,559
essentially a way to

909
00:31:56,559 --> 00:31:59,200
perform an exponential compression of a

910
00:31:59,200 --> 00:32:01,440
random vector

911
00:32:01,440 --> 00:32:02,640
with the

912
00:32:02,640 --> 00:32:04,799
promise that if we create only a

913
00:32:04,799 --> 00:32:07,200
polynomial number of entries

914
00:32:07,200 --> 00:32:09,440
then this looks like a totally random

915
00:32:09,440 --> 00:32:10,720
vector

916
00:32:10,720 --> 00:32:12,840
and actually since in this work we

917
00:32:12,840 --> 00:32:13,760
consider the

918
00:32:13,760 --> 00:32:15,360
small domains

919
00:32:15,360 --> 00:32:16,640
and

920
00:32:16,640 --> 00:32:18,000
we can actually

921
00:32:18,000 --> 00:32:19,600
look at the entire all the entries of

922
00:32:19,600 --> 00:32:21,919
the table

923
00:32:21,919 --> 00:32:24,720
of this vector and the functional parent

924
00:32:24,720 --> 00:32:28,240
is the left of an additional property

925
00:32:28,240 --> 00:32:30,559
the additional algorithms puncture and

926
00:32:30,559 --> 00:32:32,240
function evaluate

927
00:32:32,240 --> 00:32:34,480
so punctual takes the period key and

928
00:32:34,480 --> 00:32:36,480
punches it such that when we perform

929
00:32:36,480 --> 00:32:38,159
evaluation

930
00:32:38,159 --> 00:32:39,440
all the

931
00:32:39,440 --> 00:32:41,279
entries of the tooth table are there

932
00:32:41,279 --> 00:32:43,679
except one special entry that we chose

933
00:32:43,679 --> 00:32:46,480
to puncture so

934
00:32:46,640 --> 00:32:47,440
this

935
00:32:47,440 --> 00:32:50,640
value is hidden and is replaced by some

936
00:32:50,640 --> 00:32:52,080
different symbol

937
00:32:52,080 --> 00:32:55,360
and in typical constructions the key

938
00:32:55,360 --> 00:32:57,519
and the plf key is just a short random

939
00:32:57,519 --> 00:32:59,919
seed and the punctuated key goes like

940
00:32:59,919 --> 00:33:01,919
the security parameter times the

941
00:33:01,919 --> 00:33:04,640
logarithm of the domain size

942
00:33:04,640 --> 00:33:05,840
now how how do we compress the

943
00:33:05,840 --> 00:33:07,760
histograms we can just

944
00:33:07,760 --> 00:33:10,880
use the punctual prx and suppose we

945
00:33:10,880 --> 00:33:13,360
uh take appearance with domain size m

946
00:33:13,360 --> 00:33:16,960
and a range of image size n then we can

947
00:33:16,960 --> 00:33:19,120
view it as throwing emboldens into nbn

948
00:33:19,120 --> 00:33:21,519
so for example if the direct evaluates

949
00:33:21,519 --> 00:33:25,039
to 7 and 22 it means that ball number 22

950
00:33:25,039 --> 00:33:27,519
goes to be number seven

951
00:33:27,519 --> 00:33:29,760
and we can also remove bolts by just

952
00:33:29,760 --> 00:33:31,760
puncturing the corresponding input using

953
00:33:31,760 --> 00:33:33,600
the punctual

954
00:33:33,600 --> 00:33:35,120
property

955
00:33:35,120 --> 00:33:36,080
and the

956
00:33:36,080 --> 00:33:38,640
actually this is the entire construction

957
00:33:38,640 --> 00:33:40,799
for the one of a poorly uh

958
00:33:40,799 --> 00:33:42,640
secure

959
00:33:42,640 --> 00:33:44,399
for example dps

960
00:33:44,399 --> 00:33:46,000
and

961
00:33:46,000 --> 00:33:48,080
so here are illustrated so suppose we

962
00:33:48,080 --> 00:33:49,200
have some

963
00:33:49,200 --> 00:33:50,960
functional direct key

964
00:33:50,960 --> 00:33:52,720
then we give the

965
00:33:52,720 --> 00:33:55,039
offline key

966
00:33:55,039 --> 00:33:57,200
the just the prf key to

967
00:33:57,200 --> 00:34:00,720
one server and once we know the

968
00:34:00,720 --> 00:34:02,399
point function that we want to

969
00:34:02,399 --> 00:34:04,480
distribute

970
00:34:04,480 --> 00:34:06,559
then we generate the

971
00:34:06,559 --> 00:34:09,760
functional prf key and we just remove as

972
00:34:09,760 --> 00:34:11,280
in the statistical example we just

973
00:34:11,280 --> 00:34:14,399
remove one ball from the beam with index

974
00:34:14,399 --> 00:34:15,359
alpha

975
00:34:15,359 --> 00:34:18,320
then the servos just evaluate

976
00:34:18,320 --> 00:34:20,079
this key over all the points they have

977
00:34:20,079 --> 00:34:22,399
access to and count how many boards they

978
00:34:22,399 --> 00:34:24,159
have in each bin and notice that here

979
00:34:24,159 --> 00:34:25,359
again

980
00:34:25,359 --> 00:34:26,719
the difference between these two

981
00:34:26,719 --> 00:34:30,239
histograms gives us a dpf

982
00:34:30,239 --> 00:34:32,000
and in this one we showed that even

983
00:34:32,000 --> 00:34:32,960
though

984
00:34:32,960 --> 00:34:37,359
in the computational setting here uh

985
00:34:37,359 --> 00:34:40,320
the these the online server has access

986
00:34:40,320 --> 00:34:43,839
to a function key and not to a histogram

987
00:34:43,839 --> 00:34:46,560
still the distinction advantage is the

988
00:34:46,560 --> 00:34:49,040
same as the physical experiment up to a

989
00:34:49,040 --> 00:34:50,320
negligible

990
00:34:50,320 --> 00:34:52,480
term in the security parameter

991
00:34:52,480 --> 00:34:53,839
so

992
00:34:53,839 --> 00:34:55,280
this gives us the following result

993
00:34:55,280 --> 00:34:56,879
assuming when we function there is an

994
00:34:56,879 --> 00:34:59,839
excellent pdp for point function with

995
00:34:59,839 --> 00:35:01,359
output group

996
00:35:01,359 --> 00:35:03,520
which is the integers with the directory

997
00:35:03,520 --> 00:35:05,599
key size running time which is the

998
00:35:05,599 --> 00:35:07,760
domain size and running time for

999
00:35:07,760 --> 00:35:10,400
evaluation over the entire domain

1000
00:35:10,400 --> 00:35:11,599
which is

1001
00:35:11,599 --> 00:35:14,000
n over epsilon squared

1002
00:35:14,000 --> 00:35:15,440
now

1003
00:35:15,440 --> 00:35:17,839
note that we do not get an efficient

1004
00:35:17,839 --> 00:35:20,480
algorithm for a single revolution at a

1005
00:35:20,480 --> 00:35:21,839
single point

1006
00:35:21,839 --> 00:35:23,680
uh and

1007
00:35:23,680 --> 00:35:26,640
indeed where for some applications uh it

1008
00:35:26,640 --> 00:35:29,200
is necessary for many others such as

1009
00:35:29,200 --> 00:35:31,280
private i think he suggests

1010
00:35:31,280 --> 00:35:33,920
this is sufficient actually

1011
00:35:33,920 --> 00:35:36,960
this issue is uh inherent to our power

1012
00:35:36,960 --> 00:35:38,880
so we so we don't see an immediate way

1013
00:35:38,880 --> 00:35:40,720
to

1014
00:35:40,720 --> 00:35:43,599
obtain using this approach to obtain an

1015
00:35:43,599 --> 00:35:45,839
evaluation algorithm at the same point

1016
00:35:45,839 --> 00:35:47,040
which is

1017
00:35:47,040 --> 00:35:49,200
efficient

1018
00:35:49,200 --> 00:35:51,200
uh another issue that i alluded to

1019
00:35:51,200 --> 00:35:53,599
earlier is that the security is at most

1020
00:35:53,599 --> 00:35:55,680
one over poly because otherwise the

1021
00:35:55,680 --> 00:35:58,880
running time will not be polynomial

1022
00:35:58,880 --> 00:36:01,359
now while the first uh

1023
00:36:01,359 --> 00:36:02,880
problem is something that is an

1024
00:36:02,880 --> 00:36:05,040
elemental approach the second problem is

1025
00:36:05,040 --> 00:36:07,680
something that we can remedy

1026
00:36:07,680 --> 00:36:10,800
and this we do using the security

1027
00:36:10,800 --> 00:36:12,320
amplification

1028
00:36:12,320 --> 00:36:14,720
so the

1029
00:36:14,720 --> 00:36:17,599
main idea is to obtain

1030
00:36:17,599 --> 00:36:20,000
a shame a sharing of the special input

1031
00:36:20,000 --> 00:36:21,520
alpha into

1032
00:36:21,520 --> 00:36:23,839
a queue shares alpha 1 up to alpha q

1033
00:36:23,839 --> 00:36:27,359
which are sigma wise independent so

1034
00:36:27,359 --> 00:36:29,520
given only sigma or less

1035
00:36:29,520 --> 00:36:31,839
of this no information is revealed about

1036
00:36:31,839 --> 00:36:32,960
alpha

1037
00:36:32,960 --> 00:36:34,800
and the reason this works is due to the

1038
00:36:34,800 --> 00:36:38,000
linearity of the point function so

1039
00:36:38,000 --> 00:36:40,560
in more detail the dpf evaluation of the

1040
00:36:40,560 --> 00:36:43,680
point function f alpha one x boils down

1041
00:36:43,680 --> 00:36:45,359
to distributively computing the inner

1042
00:36:45,359 --> 00:36:48,000
product of the unit vector e x which has

1043
00:36:48,000 --> 00:36:49,680
one

1044
00:36:49,680 --> 00:36:51,440
at the input x

1045
00:36:51,440 --> 00:36:53,760
at the index x with the tools table of

1046
00:36:53,760 --> 00:36:55,680
the point function which which is also

1047
00:36:55,680 --> 00:36:58,720
just a unique vector

1048
00:36:59,839 --> 00:37:02,000
and

1049
00:37:02,400 --> 00:37:04,560
the way we amplify the security is that

1050
00:37:04,560 --> 00:37:07,760
instead we consider q point functions f

1051
00:37:07,760 --> 00:37:10,160
alpha 1 up to f alpha q

1052
00:37:10,160 --> 00:37:12,240
and the corresponding

1053
00:37:12,240 --> 00:37:14,160
locally decodable code

1054
00:37:14,160 --> 00:37:16,240
and we want that the inner product of

1055
00:37:16,240 --> 00:37:18,800
the encoding of the unit vector with the

1056
00:37:18,800 --> 00:37:21,359
sum of the truth tables

1057
00:37:21,359 --> 00:37:23,200
will be the same as the first in

1058
00:37:23,200 --> 00:37:24,480
opponent

1059
00:37:24,480 --> 00:37:27,280
and because it's a locally decodable

1060
00:37:27,280 --> 00:37:28,640
code

1061
00:37:28,640 --> 00:37:31,040
it's a locational code it's essentially

1062
00:37:31,040 --> 00:37:32,160
like we are

1063
00:37:32,160 --> 00:37:33,920
reading queue

1064
00:37:33,920 --> 00:37:36,480
entries from the codeboard to recover

1065
00:37:36,480 --> 00:37:39,760
one entry from the message

1066
00:37:39,760 --> 00:37:42,079
in more detail in this construction

1067
00:37:42,079 --> 00:37:44,240
server 0 receives the

1068
00:37:44,240 --> 00:37:46,160
queue offline keys which can also be

1069
00:37:46,160 --> 00:37:48,480
compressed with single random seed

1070
00:37:48,480 --> 00:37:51,920
and the online server receives the queue

1071
00:37:51,920 --> 00:37:53,680
online keys

1072
00:37:53,680 --> 00:37:56,160
then the servers just compute the inner

1073
00:37:56,160 --> 00:37:57,119
product

1074
00:37:57,119 --> 00:37:58,400
of the

1075
00:37:58,400 --> 00:38:01,359
code they encoded the unit vector e x

1076
00:38:01,359 --> 00:38:03,040
with the sum

1077
00:38:03,040 --> 00:38:05,280
of the two tables of the

1078
00:38:05,280 --> 00:38:06,880
function charts

1079
00:38:06,880 --> 00:38:08,640
and due to linearity

1080
00:38:08,640 --> 00:38:11,280
will recover back the

1081
00:38:11,280 --> 00:38:13,440
inner product expression from the last

1082
00:38:13,440 --> 00:38:16,160
slide and it gives us the point function

1083
00:38:16,160 --> 00:38:18,880
value that we want

1084
00:38:18,880 --> 00:38:20,240
regarding the security of this

1085
00:38:20,240 --> 00:38:21,839
construction

1086
00:38:21,839 --> 00:38:23,280
uh each

1087
00:38:23,280 --> 00:38:25,599
because we start from uh pdpf which is

1088
00:38:25,599 --> 00:38:29,280
not negligibly secure we have that each

1089
00:38:29,280 --> 00:38:31,839
online key reveals some epsilon amount

1090
00:38:31,839 --> 00:38:33,280
of information

1091
00:38:33,280 --> 00:38:35,040
about alpha

1092
00:38:35,040 --> 00:38:37,119
and using a half dilemma we show that

1093
00:38:37,119 --> 00:38:40,079
this is essentially the same as each

1094
00:38:40,079 --> 00:38:42,079
leaking completely

1095
00:38:42,079 --> 00:38:44,640
probability epsilon and not revealing

1096
00:38:44,640 --> 00:38:46,720
anything otherwise

1097
00:38:46,720 --> 00:38:47,680
um

1098
00:38:47,680 --> 00:38:50,800
thus we need at least sigma shares to

1099
00:38:50,800 --> 00:38:52,640
leak to completely break security and

1100
00:38:52,640 --> 00:38:53,920
otherwise

1101
00:38:53,920 --> 00:38:55,280
alpha is hidden

1102
00:38:55,280 --> 00:38:58,880
so using a channel bound this gives us a

1103
00:38:58,880 --> 00:39:02,000
security l which is exponential

1104
00:39:02,000 --> 00:39:02,880
uh

1105
00:39:02,880 --> 00:39:04,960
in sigma when we choose epsilon to be

1106
00:39:04,960 --> 00:39:06,800
one over l cube

1107
00:39:06,800 --> 00:39:09,119
so this means that the computation

1108
00:39:09,119 --> 00:39:13,760
is polynomial in n in l and in q

1109
00:39:13,760 --> 00:39:16,079
so therefore we need to choose the a

1110
00:39:16,079 --> 00:39:19,200
good code a good locational code

1111
00:39:19,200 --> 00:39:20,079
and

1112
00:39:20,079 --> 00:39:21,839
just using a

1113
00:39:21,839 --> 00:39:23,680
read more code we can choose a code

1114
00:39:23,680 --> 00:39:25,839
where l which dominates computation is

1115
00:39:25,839 --> 00:39:28,000
polynomial and

1116
00:39:28,000 --> 00:39:30,240
sigma is political written

1117
00:39:30,240 --> 00:39:31,280
and the

1118
00:39:31,280 --> 00:39:33,200
q which is the number of queries that

1119
00:39:33,200 --> 00:39:35,839
corresponds to the number of online keys

1120
00:39:35,839 --> 00:39:38,000
is also polygonal rhythmic and this

1121
00:39:38,000 --> 00:39:40,240
gives us a assuming only function this

1122
00:39:40,240 --> 00:39:42,640
gives us the pdpf for point functions

1123
00:39:42,640 --> 00:39:44,960
with the body logarithmic key size and

1124
00:39:44,960 --> 00:39:48,640
polynomial running time for gen and eval

1125
00:39:48,640 --> 00:39:51,359
now moving on to applications

1126
00:39:51,359 --> 00:39:53,040
the first application is the small

1127
00:39:53,040 --> 00:39:55,359
domain privacy function with direct so

1128
00:39:55,359 --> 00:39:57,520
recall that a functional prf allows us

1129
00:39:57,520 --> 00:39:58,400
to

1130
00:39:58,400 --> 00:40:01,040
remove a single input from the

1131
00:40:01,040 --> 00:40:04,160
truth table uh of the prf

1132
00:40:04,160 --> 00:40:06,160
and the privately controlled plf allows

1133
00:40:06,160 --> 00:40:08,400
us to instead of having a different

1134
00:40:08,400 --> 00:40:12,000
symbol that have a new random variable

1135
00:40:12,000 --> 00:40:13,520
and in this way

1136
00:40:13,520 --> 00:40:15,839
an adversary which gets the function key

1137
00:40:15,839 --> 00:40:18,880
does not know which key was uh sorry

1138
00:40:18,880 --> 00:40:21,040
which input was a function

1139
00:40:21,040 --> 00:40:23,440
uh ppf's are only known to exist from

1140
00:40:23,440 --> 00:40:26,880
public assumptions but here due to this

1141
00:40:26,880 --> 00:40:28,880
small domain assumption we actually get

1142
00:40:28,880 --> 00:40:30,960
a privacy control

1143
00:40:30,960 --> 00:40:32,960
just from one way functions and this is

1144
00:40:32,960 --> 00:40:35,280
because priority partition parents are

1145
00:40:35,280 --> 00:40:38,800
just pdpx with random meta

1146
00:40:38,800 --> 00:40:40,480
and actually

1147
00:40:40,480 --> 00:40:42,240
this implication also helps in in the

1148
00:40:42,240 --> 00:40:44,400
other direction if we start from

1149
00:40:44,400 --> 00:40:46,480
privately punctuated by rejection

1150
00:40:46,480 --> 00:40:50,079
sampling we can get back the pdpf with

1151
00:40:50,079 --> 00:40:53,200
whatever we want

1152
00:40:53,200 --> 00:40:56,079
another application is distributed gen

1153
00:40:56,079 --> 00:40:58,480
for the peers so here instead of having

1154
00:40:58,480 --> 00:41:01,440
one client holding the description

1155
00:41:01,440 --> 00:41:03,040
of the point function we can have

1156
00:41:03,040 --> 00:41:05,760
multiple clients which follow the secret

1157
00:41:05,760 --> 00:41:07,599
sharing of this point function and they

1158
00:41:07,599 --> 00:41:09,839
want to distribute the key generation

1159
00:41:09,839 --> 00:41:11,440
protocol

1160
00:41:11,440 --> 00:41:13,440
so one way to achieve it is via generic

1161
00:41:13,440 --> 00:41:15,520
npc machinery but this involves

1162
00:41:15,520 --> 00:41:17,839
non-black box npc of cryptographic

1163
00:41:17,839 --> 00:41:21,200
primitives which is expensive and the

1164
00:41:21,200 --> 00:41:23,440
another approach which only makes black

1165
00:41:23,440 --> 00:41:24,560
box use of

1166
00:41:24,560 --> 00:41:27,040
prgs is due to donor and shallot and

1167
00:41:27,040 --> 00:41:29,040
here the number of arms is abolition the

1168
00:41:29,040 --> 00:41:30,880
communication is logarithmic

1169
00:41:30,880 --> 00:41:34,160
and also the distributed generator

1170
00:41:34,160 --> 00:41:34,880
so

1171
00:41:34,880 --> 00:41:36,800
it's an efficient protocol

1172
00:41:36,800 --> 00:41:38,960
so here we also

1173
00:41:38,960 --> 00:41:42,400
want to have a black box energy

1174
00:41:42,400 --> 00:41:43,920
a portable which only makes black box

1175
00:41:43,920 --> 00:41:47,520
use of apigee and we show that

1176
00:41:47,520 --> 00:41:49,920
there is such there is a dpf so it's no

1177
00:41:49,920 --> 00:41:52,079
longer a pdpf there is a dpr which means

1178
00:41:52,079 --> 00:41:54,480
a five round distributed the jump

1179
00:41:54,480 --> 00:41:57,359
protocol and we also want jam to be

1180
00:41:57,359 --> 00:41:58,640
efficient

1181
00:41:58,640 --> 00:42:00,720
and this can be done by just using the

1182
00:42:00,720 --> 00:42:04,240
pdpf for a point function where

1183
00:42:04,240 --> 00:42:06,880
the special input alpha is running so

1184
00:42:06,880 --> 00:42:09,599
if we need to choose alpha then the jail

1185
00:42:09,599 --> 00:42:12,720
time is linear in the domain side but if

1186
00:42:12,720 --> 00:42:14,319
the

1187
00:42:14,319 --> 00:42:16,240
the special input alpha is random then

1188
00:42:16,240 --> 00:42:17,839
we can just uh

1189
00:42:17,839 --> 00:42:19,599
the right time is just for the limit so

1190
00:42:19,599 --> 00:42:21,280
the way

1191
00:42:21,280 --> 00:42:23,440
this gen procedure works is that we

1192
00:42:23,440 --> 00:42:24,720
first compute

1193
00:42:24,720 --> 00:42:27,839
the q and chenille shells of alpha and

1194
00:42:27,839 --> 00:42:29,280
we also sample

1195
00:42:29,280 --> 00:42:32,480
q a ppis keys

1196
00:42:32,480 --> 00:42:35,440
then for each eye from 1 to q we need to

1197
00:42:35,440 --> 00:42:39,280
generate the punctured key at a random

1198
00:42:39,280 --> 00:42:41,680
point

1199
00:42:42,400 --> 00:42:44,560
and we compute the corresponding prf

1200
00:42:44,560 --> 00:42:47,040
output at this random point

1201
00:42:47,040 --> 00:42:48,960
and then we also

1202
00:42:48,960 --> 00:42:51,599
we want to give the servers the offset

1203
00:42:51,599 --> 00:42:52,960
from the

1204
00:42:52,960 --> 00:42:55,680
random point alpha i prime to the actual

1205
00:42:55,680 --> 00:42:57,440
alpha that we want

1206
00:42:57,440 --> 00:43:00,319
so the servers receive

1207
00:43:00,319 --> 00:43:03,040
so the first server receives the

1208
00:43:03,040 --> 00:43:06,000
unfunction the regular pprf keys with

1209
00:43:06,000 --> 00:43:08,400
the offset and the second server the

1210
00:43:08,400 --> 00:43:11,200
server one receives the punctuation

1211
00:43:11,200 --> 00:43:12,480
with the offset

1212
00:43:12,480 --> 00:43:15,599
and this gives us a dpf construction so

1213
00:43:15,599 --> 00:43:17,040
now

1214
00:43:17,040 --> 00:43:19,440
the question we are left with is how to

1215
00:43:19,440 --> 00:43:22,400
how do we distribute this operation

1216
00:43:22,400 --> 00:43:25,440
and as it turns out most steps here are

1217
00:43:25,440 --> 00:43:28,000
actually can be done by generic

1218
00:43:28,000 --> 00:43:31,200
mpc in an efficient way the only two

1219
00:43:31,200 --> 00:43:33,680
problematic steps are the ones which

1220
00:43:33,680 --> 00:43:36,160
involve prg evaluation

1221
00:43:36,160 --> 00:43:39,200
and so let's see how do we deal with

1222
00:43:39,200 --> 00:43:40,880
that so

1223
00:43:40,880 --> 00:43:42,560
for the first step we need to provide

1224
00:43:42,560 --> 00:43:45,119
servers zero and one with the

1225
00:43:45,119 --> 00:43:47,359
unfunctioned and functional prf keys

1226
00:43:47,359 --> 00:43:49,280
respectively at the random

1227
00:43:49,280 --> 00:43:51,440
point x i

1228
00:43:51,440 --> 00:43:52,560
start

1229
00:43:52,560 --> 00:43:54,880
and actually this can be handled by the

1230
00:43:54,880 --> 00:43:56,880
two-round protocols of boilertale and

1231
00:43:56,880 --> 00:43:58,400
shop monitor

1232
00:43:58,400 --> 00:44:00,560
and

1233
00:44:00,960 --> 00:44:02,240
so

1234
00:44:02,240 --> 00:44:04,960
this problem is solved for the other

1235
00:44:04,960 --> 00:44:07,040
step we

1236
00:44:07,040 --> 00:44:08,640
need to provide the servers with

1237
00:44:08,640 --> 00:44:11,280
additive shares of this uh

1238
00:44:11,280 --> 00:44:12,960
a random

1239
00:44:12,960 --> 00:44:15,520
input special input alpha i y

1240
00:44:15,520 --> 00:44:17,680
and we observe that if each server just

1241
00:44:17,680 --> 00:44:20,079
computes the sum of all the prf values

1242
00:44:20,079 --> 00:44:21,599
it has access to

1243
00:44:21,599 --> 00:44:22,480
because

1244
00:44:22,480 --> 00:44:25,520
the point x i star is the only one

1245
00:44:25,520 --> 00:44:26,480
missing

1246
00:44:26,480 --> 00:44:29,200
they differ by precisely

1247
00:44:29,200 --> 00:44:32,079
this alpha i prime

1248
00:44:32,079 --> 00:44:34,640
so in conclusion this gives us a

1249
00:44:34,640 --> 00:44:37,200
standard pair so it's no longer a

1250
00:44:37,200 --> 00:44:39,760
pdpf with a distributed gem protocol

1251
00:44:39,760 --> 00:44:42,079
which makes only blackbox user for kig

1252
00:44:42,079 --> 00:44:43,839
which has five rounds polylogan

1253
00:44:43,839 --> 00:44:46,319
communication and polylogan distributed

1254
00:44:46,319 --> 00:44:47,839
generality

1255
00:44:47,839 --> 00:44:50,480
and we also have more talk about the

1256
00:44:50,480 --> 00:44:52,480
complete efficiency of the scheme in the

1257
00:44:52,480 --> 00:44:54,880
paper

1258
00:44:54,880 --> 00:44:56,240
another

1259
00:44:56,240 --> 00:44:58,160
application is to compress dps

1260
00:44:58,160 --> 00:44:59,440
correlations

1261
00:44:59,440 --> 00:45:02,000
so dps correlations can be locally

1262
00:45:02,000 --> 00:45:03,760
expanded into two table calculations

1263
00:45:03,760 --> 00:45:05,119
which are useful for communication

1264
00:45:05,119 --> 00:45:06,640
efficiency

1265
00:45:06,640 --> 00:45:08,480
and this motivates generating many

1266
00:45:08,480 --> 00:45:12,640
independent instances of radio dps

1267
00:45:13,119 --> 00:45:15,359
and we show that by using

1268
00:45:15,359 --> 00:45:17,359
programmable dps we can do it in the

1269
00:45:17,359 --> 00:45:20,960
so-called trusted offline setting

1270
00:45:20,960 --> 00:45:23,359
so what it means is suppose that alice

1271
00:45:23,359 --> 00:45:24,960
has some secret s

1272
00:45:24,960 --> 00:45:26,560
and she secretly shares this secret

1273
00:45:26,560 --> 00:45:28,960
between herself and bob and then forgets

1274
00:45:28,960 --> 00:45:29,760
him

1275
00:45:29,760 --> 00:45:31,760
now once alice forgets about the

1276
00:45:31,760 --> 00:45:34,079
original secret they have

1277
00:45:34,079 --> 00:45:36,000
a valid

1278
00:45:36,000 --> 00:45:37,839
dpf correlation and they can just

1279
00:45:37,839 --> 00:45:38,960
perform

1280
00:45:38,960 --> 00:45:41,760
a computation

1281
00:45:41,760 --> 00:45:45,040
in the usual manner

1282
00:45:45,440 --> 00:45:48,079
in this way pdpf gives us a way

1283
00:45:48,079 --> 00:45:51,680
to compress many instances of dpf

1284
00:45:51,680 --> 00:45:53,920
without needing to distribute the key

1285
00:45:53,920 --> 00:45:55,119
generation

1286
00:45:55,119 --> 00:45:56,480
protocol

1287
00:45:56,480 --> 00:45:57,280
and

1288
00:45:57,280 --> 00:45:59,200
in more detail the way it is done is

1289
00:45:59,200 --> 00:46:01,280
that suppose that

1290
00:46:01,280 --> 00:46:03,440
alice is given some

1291
00:46:03,440 --> 00:46:06,480
t functions and for efficiency

1292
00:46:06,480 --> 00:46:08,480
this will those would just be random

1293
00:46:08,480 --> 00:46:10,079
point functions

1294
00:46:10,079 --> 00:46:10,960
and

1295
00:46:10,960 --> 00:46:12,800
what else does it generates a random c

1296
00:46:12,800 --> 00:46:14,240
css

1297
00:46:14,240 --> 00:46:17,119
from this scene she computes the key

1298
00:46:17,119 --> 00:46:18,960
offline keys

1299
00:46:18,960 --> 00:46:21,280
then from those kids she computes the

1300
00:46:21,280 --> 00:46:25,119
online keys and also sends the scene

1301
00:46:25,119 --> 00:46:26,560
to bob and they

1302
00:46:26,560 --> 00:46:29,440
say they stole this information

1303
00:46:29,440 --> 00:46:31,760
then alice forgets about s and the

1304
00:46:31,760 --> 00:46:33,839
offline keys

1305
00:46:33,839 --> 00:46:36,480
and this this is the gen phase and for

1306
00:46:36,480 --> 00:46:38,160
the evaluation phase

1307
00:46:38,160 --> 00:46:41,040
both can just compute each

1308
00:46:41,040 --> 00:46:42,800
plenty of each instance from this one

1309
00:46:42,800 --> 00:46:44,000
looks it

1310
00:46:44,000 --> 00:46:47,520
and they both can just perform eval on

1311
00:46:47,520 --> 00:46:51,040
the respective keys

1312
00:46:51,760 --> 00:46:54,000
now

1313
00:46:55,359 --> 00:46:58,960
uh using the an absolute city of pdps

1314
00:46:58,960 --> 00:47:01,839
this gives us a

1315
00:47:01,839 --> 00:47:04,480
a scheme with communication which is the

1316
00:47:04,480 --> 00:47:06,880
ghost just like the length of like the

1317
00:47:06,880 --> 00:47:08,640
security parameter just the length of

1318
00:47:08,640 --> 00:47:11,760
the random c and the storage uh of one

1319
00:47:11,760 --> 00:47:15,119
party is just uh

1320
00:47:15,119 --> 00:47:17,200
t lambda log n

1321
00:47:17,200 --> 00:47:19,440
and if we compare it to the alternatives

1322
00:47:19,440 --> 00:47:21,440
then they have some parameter which is

1323
00:47:21,440 --> 00:47:23,839
exponentially worse so for example for

1324
00:47:23,839 --> 00:47:26,160
standard bpf the communication

1325
00:47:26,160 --> 00:47:28,480
it goes like t and log n

1326
00:47:28,480 --> 00:47:31,440
and in the name by using an apg for the

1327
00:47:31,440 --> 00:47:33,040
same task

1328
00:47:33,040 --> 00:47:35,280
the storage uh weather communication is

1329
00:47:35,280 --> 00:47:37,839
good the storage is linear in tmn which

1330
00:47:37,839 --> 00:47:40,720
is two prohibited

1331
00:47:40,880 --> 00:47:42,640
now um

1332
00:47:42,640 --> 00:47:44,880
regarding concrete efficiency

1333
00:47:44,880 --> 00:47:46,880
we consider a typical aggregation

1334
00:47:46,880 --> 00:47:49,760
scenario where the output group is the

1335
00:47:49,760 --> 00:47:51,520
integers and beta

1336
00:47:51,520 --> 00:47:53,599
is

1337
00:47:53,599 --> 00:47:56,160
either zero or one

1338
00:47:56,160 --> 00:47:58,720
and we assume that we can perform one

1339
00:47:58,720 --> 00:48:00,319
point eight times ten to the power of

1340
00:48:00,319 --> 00:48:02,800
eight plgs per second

1341
00:48:02,800 --> 00:48:04,640
and here are two

1342
00:48:04,640 --> 00:48:06,880
data points from the paper on

1343
00:48:06,880 --> 00:48:09,119
the comparison between

1344
00:48:09,119 --> 00:48:12,319
the native pdpf to our one one of the

1345
00:48:12,319 --> 00:48:15,839
public private pdps construction

1346
00:48:15,839 --> 00:48:18,480
and just to conclude this

1347
00:48:18,480 --> 00:48:20,480
table

1348
00:48:20,480 --> 00:48:22,800
for small domains and small privacy

1349
00:48:22,800 --> 00:48:25,680
levels or moderate ones

1350
00:48:25,680 --> 00:48:27,359
our construction offers the big

1351
00:48:27,359 --> 00:48:30,480
advantage in keysight

1352
00:48:30,720 --> 00:48:32,880
in exchange for a moderate slowdown in

1353
00:48:32,880 --> 00:48:35,119
the gen time and

1354
00:48:35,119 --> 00:48:37,280
somewhat bigger slow down in the eval

1355
00:48:37,280 --> 00:48:38,319
all time

1356
00:48:38,319 --> 00:48:41,040
at the service

1357
00:48:41,119 --> 00:48:43,040
of course if the

1358
00:48:43,040 --> 00:48:45,599
point function is is random then

1359
00:48:45,599 --> 00:48:47,440
actually the gen times

1360
00:48:47,440 --> 00:48:49,200
much more efficient

1361
00:48:49,200 --> 00:48:51,839
and overall we expect

1362
00:48:51,839 --> 00:48:53,839
the pdpf's uh

1363
00:48:53,839 --> 00:48:55,520
this will be construction to be

1364
00:48:55,520 --> 00:48:56,559
attractive

1365
00:48:56,559 --> 00:48:57,760
in applications for the client's

1366
00:48:57,760 --> 00:48:59,839
communication is the most expensive

1367
00:48:59,839 --> 00:49:01,520
result

1368
00:49:01,520 --> 00:49:03,839
so to summarize uh in this work we

1369
00:49:03,839 --> 00:49:06,319
introduce programmable dps which was

1370
00:49:06,319 --> 00:49:08,720
normal notion of vpf

1371
00:49:08,720 --> 00:49:11,359
and we also show a new approach to

1372
00:49:11,359 --> 00:49:13,280
constructing dbs which does not follow

1373
00:49:13,280 --> 00:49:14,559
the ggm

1374
00:49:14,559 --> 00:49:16,640
3 construction paradigm which is

1375
00:49:16,640 --> 00:49:18,079
directly

1376
00:49:18,079 --> 00:49:20,480
we discussed some applications of pdp

1377
00:49:20,480 --> 00:49:22,640
and we also have some open questions for

1378
00:49:22,640 --> 00:49:24,960
example how to achieve better efficiency

1379
00:49:24,960 --> 00:49:26,480
for

1380
00:49:26,480 --> 00:49:28,319
this kind of primitive

1381
00:49:28,319 --> 00:49:31,520
and also how to have an efficient single

1382
00:49:31,520 --> 00:49:34,319
input eval algorithm so this is all a

1383
00:49:34,319 --> 00:49:36,480
thing

1384
00:49:42,960 --> 00:49:45,119
uh so we have time for

1385
00:49:45,119 --> 00:49:48,000
a few questions

1386
00:49:50,640 --> 00:49:52,640
um thank you for the great talk uh could

1387
00:49:52,640 --> 00:49:55,200
you give some intuition for why the

1388
00:49:55,200 --> 00:49:57,680
the first seed is reusable

1389
00:49:57,680 --> 00:49:59,599
because wouldn't you get if you try to

1390
00:49:59,599 --> 00:50:01,119
puncture it in two locations wouldn't

1391
00:50:01,119 --> 00:50:03,280
you get almost the same distribution for

1392
00:50:03,280 --> 00:50:06,400
the other two keys

1393
00:50:09,440 --> 00:50:10,240
so

1394
00:50:10,240 --> 00:50:13,839
it's reusable in the sense that

1395
00:50:14,319 --> 00:50:16,640
it's not like the same construction is

1396
00:50:16,640 --> 00:50:18,640
uh reusable let me get back to this

1397
00:50:18,640 --> 00:50:20,879
slide

1398
00:50:23,920 --> 00:50:28,240
and it might be faster to go directly

1399
00:50:29,839 --> 00:50:32,078
okay

1400
00:50:33,760 --> 00:50:34,559
so

1401
00:50:34,559 --> 00:50:37,520
it's not reusable directly but what we

1402
00:50:37,520 --> 00:50:40,000
can do is that we can give one short

1403
00:50:40,000 --> 00:50:41,200
seed

1404
00:50:41,200 --> 00:50:43,280
to the offline server then

1405
00:50:43,280 --> 00:50:46,480
the offline server can expand this seed

1406
00:50:46,480 --> 00:50:48,800
into multiple other seeds

1407
00:50:48,800 --> 00:50:51,440
and each individual seed will correspond

1408
00:50:51,440 --> 00:50:52,839
to a different

1409
00:50:52,839 --> 00:50:55,440
instance so one look because randomness

1410
00:50:55,440 --> 00:50:56,880
can be compressed

1411
00:50:56,880 --> 00:50:58,160
we

1412
00:50:58,160 --> 00:51:00,640
we immediately get the usability so so i

1413
00:51:00,640 --> 00:51:04,879
hope it makes sense yeah thank you

1414
00:51:06,400 --> 00:51:09,920
um do you have concrete efficiency

1415
00:51:09,920 --> 00:51:12,960
numbers for the amplified dpf like say

1416
00:51:12,960 --> 00:51:17,280
comparing to the security of uh

1417
00:51:17,599 --> 00:51:21,440
standard not so much but where it's not

1418
00:51:21,440 --> 00:51:23,280
so it was not designed to be efficient

1419
00:51:23,280 --> 00:51:25,440
and

1420
00:51:25,839 --> 00:51:29,040
i'm willing to bet that it's not

1421
00:51:29,040 --> 00:51:31,440
just a feasibility result but yes of

1422
00:51:31,440 --> 00:51:33,359
course we would like to have the best of

1423
00:51:33,359 --> 00:51:35,599
both worlds and having

1424
00:51:35,599 --> 00:51:37,440
inspection

1425
00:51:37,440 --> 00:51:40,240
oh wait also you said that uh

1426
00:51:40,240 --> 00:51:43,680
dpf implies a one-way function is that

1427
00:51:43,680 --> 00:51:44,559
uh

1428
00:51:44,559 --> 00:51:46,079
like where could i find that result i

1429
00:51:46,079 --> 00:51:49,119
don't think i saw it in your paper

1430
00:51:49,119 --> 00:51:51,040
um and like would that imply

1431
00:51:51,040 --> 00:51:52,960
impossibility of an information

1432
00:51:52,960 --> 00:51:54,079
theoretic

1433
00:51:54,079 --> 00:51:55,200
dpf

1434
00:51:55,200 --> 00:51:56,800
like at least with like a logarithmic

1435
00:51:56,800 --> 00:51:58,559
key size

1436
00:51:58,559 --> 00:52:01,520
so it's it's just for

1437
00:52:01,520 --> 00:52:03,599
two servers so

1438
00:52:03,599 --> 00:52:05,040
actually information theoretic debate

1439
00:52:05,040 --> 00:52:07,440
for two servers cannot exist because it

1440
00:52:07,440 --> 00:52:10,319
implies to several pir with short

1441
00:52:10,319 --> 00:52:13,200
answers and there's some paper about

1442
00:52:13,200 --> 00:52:15,280
that i don't recall

1443
00:52:15,280 --> 00:52:16,240
the name

1444
00:52:16,240 --> 00:52:19,040
and i also don't recall

1445
00:52:19,040 --> 00:52:21,200
in which paper it appeared

1446
00:52:21,200 --> 00:52:22,319
so

1447
00:52:22,319 --> 00:52:24,800
maybe you can send me an email i'll

1448
00:52:24,800 --> 00:52:26,319
do a quick search and i'll find them

1449
00:52:26,319 --> 00:52:27,599
with

1450
00:52:27,599 --> 00:52:29,760
okay thank you

1451
00:52:29,760 --> 00:52:33,720
all right listening to the speaker again

1452
00:53:24,000 --> 00:53:27,480
let's turn on

1453
00:53:33,680 --> 00:53:36,480
all right um so the third the third talk

1454
00:53:36,480 --> 00:53:38,720
is going to be given by yang do uh from

1455
00:53:38,720 --> 00:53:40,480
university of michigan and he'll be

1456
00:53:40,480 --> 00:53:43,280
speaking about snapshot or ram

1457
00:53:43,280 --> 00:53:45,119
thank you for the introduction

1458
00:53:45,119 --> 00:53:46,720
my name is young du i'm from the

1459
00:53:46,720 --> 00:53:48,720
university of michigan today i will

1460
00:53:48,720 --> 00:53:51,200
present our new oem model the snapshot

1461
00:53:51,200 --> 00:53:53,839
program which has better efficiency for

1462
00:53:53,839 --> 00:53:56,000
short transcript this is joined to work

1463
00:53:56,000 --> 00:53:57,280
with professor daniel genkin and

1464
00:53:57,280 --> 00:54:00,319
professor paul grubs

1465
00:54:00,960 --> 00:54:02,319
before we start i will show you some

1466
00:54:02,319 --> 00:54:03,520
background

1467
00:54:03,520 --> 00:54:05,520
as data breaches becomes more and more

1468
00:54:05,520 --> 00:54:07,280
common today sensitive information

1469
00:54:07,280 --> 00:54:09,440
leakage poses a new threat on all the

1470
00:54:09,440 --> 00:54:11,359
internet users

1471
00:54:11,359 --> 00:54:14,640
a simple way to fix that is we encrypt

1472
00:54:14,640 --> 00:54:17,119
the database

1473
00:54:17,119 --> 00:54:19,200
slot by slot using some strong

1474
00:54:19,200 --> 00:54:20,880
encryption scheme

1475
00:54:20,880 --> 00:54:24,400
however this can only protect the

1476
00:54:24,400 --> 00:54:26,400
data itself but not provide any

1477
00:54:26,400 --> 00:54:28,720
protection on the metadata such as

1478
00:54:28,720 --> 00:54:31,280
access pattern

1479
00:54:31,280 --> 00:54:35,680
to that end oram was introduced

1480
00:54:36,720 --> 00:54:39,520
assume a user wants to write on the

1481
00:54:39,520 --> 00:54:42,160
first address of some untrusted memory

1482
00:54:42,160 --> 00:54:43,839
of size 3

1483
00:54:43,839 --> 00:54:45,599
to prevent the untrusted storage from

1484
00:54:45,599 --> 00:54:47,200
knowing that

1485
00:54:47,200 --> 00:54:49,599
the ad from knowing what the actual

1486
00:54:49,599 --> 00:54:52,640
address the user wants to write on

1487
00:54:52,640 --> 00:54:55,440
what an orm does is to read the first

1488
00:54:55,440 --> 00:54:56,799
address

1489
00:54:56,799 --> 00:54:59,440
decrypt it write the new content in and

1490
00:54:59,440 --> 00:55:01,839
re-encrypt write it back similar thing

1491
00:55:01,839 --> 00:55:03,920
will be done for the

1492
00:55:03,920 --> 00:55:06,559
second and third address

1493
00:55:06,559 --> 00:55:08,960
so in this linear scanning way

1494
00:55:08,960 --> 00:55:11,920
the actual written address from the user

1495
00:55:11,920 --> 00:55:14,480
is hidden

1496
00:55:15,200 --> 00:55:17,599
from now on we will rearrange the

1497
00:55:17,599 --> 00:55:19,359
operations and use this vertical

1498
00:55:19,359 --> 00:55:22,079
notation to denote how o ram compiles

1499
00:55:22,079 --> 00:55:25,680
operation into access pattern

1500
00:55:25,680 --> 00:55:27,760
as orm has developed for more than 30

1501
00:55:27,760 --> 00:55:28,880
years

1502
00:55:28,880 --> 00:55:32,079
there are much better schemes provided

1503
00:55:32,079 --> 00:55:33,920
proposed which has a much better

1504
00:55:33,920 --> 00:55:36,319
efficiency than just linear scanning the

1505
00:55:36,319 --> 00:55:38,799
memory

1506
00:55:38,960 --> 00:55:41,520
however the problem of oram is it is

1507
00:55:41,520 --> 00:55:43,920
neither asymptotically nor concretely

1508
00:55:43,920 --> 00:55:46,160
efficient

1509
00:55:46,160 --> 00:55:48,720
in my previous linear scanning example

1510
00:55:48,720 --> 00:55:50,720
on one operation becomes six new

1511
00:55:50,720 --> 00:55:53,280
operations this means uh six times blow

1512
00:55:53,280 --> 00:55:56,240
up and this kind of

1513
00:55:56,240 --> 00:55:58,640
this kind of bandwidth blow up

1514
00:55:58,640 --> 00:55:59,599
has a

1515
00:55:59,599 --> 00:56:02,400
built-in lower bound which is formula of

1516
00:56:02,400 --> 00:56:04,319
log n

1517
00:56:04,319 --> 00:56:07,520
universe relaxation of the security

1518
00:56:07,520 --> 00:56:09,839
guarantee security requirements doesn't

1519
00:56:09,839 --> 00:56:12,079
work similar lower bound was shown for

1520
00:56:12,079 --> 00:56:14,160
differentially private orem and offline

1521
00:56:14,160 --> 00:56:15,200
overlap

1522
00:56:15,200 --> 00:56:17,680
the letter means the transcript is

1523
00:56:17,680 --> 00:56:20,000
giving advance

1524
00:56:20,000 --> 00:56:22,079
and in practice on each four kilobytes

1525
00:56:22,079 --> 00:56:24,960
block oblivious store uses 179 kilobytes

1526
00:56:24,960 --> 00:56:28,400
bandwidth and password ram using 287

1527
00:56:28,400 --> 00:56:30,480
which means a six time to 70 times

1528
00:56:30,480 --> 00:56:32,720
slowdown

1529
00:56:32,720 --> 00:56:35,119
and other problems like run complexity

1530
00:56:35,119 --> 00:56:38,880
and storage overhead also exist

1531
00:56:39,040 --> 00:56:41,280
now the question becomes how can we

1532
00:56:41,280 --> 00:56:43,359
sidestep the omega slot and lower bound

1533
00:56:43,359 --> 00:56:45,520
while providing a meaningful security

1534
00:56:45,520 --> 00:56:48,079
guarantee for the memory access pattern

1535
00:56:48,079 --> 00:56:51,359
our ti beer is to limit the adversary to

1536
00:56:51,359 --> 00:56:53,599
an observing window

1537
00:56:53,599 --> 00:56:55,839
an observing window just means a sliding

1538
00:56:55,839 --> 00:56:58,720
window such that the adversary can put

1539
00:56:58,720 --> 00:57:00,799
put it wherever it wants

1540
00:57:00,799 --> 00:57:03,200
but and only gets the access pattern

1541
00:57:03,200 --> 00:57:06,240
within this window

1542
00:57:06,240 --> 00:57:08,559
so where does this idea come from we

1543
00:57:08,559 --> 00:57:11,599
begin with the obvious observation that

1544
00:57:11,599 --> 00:57:13,920
adversary access to system is often time

1545
00:57:13,920 --> 00:57:15,680
limited

1546
00:57:15,680 --> 00:57:18,000
after a certain time the adversary will

1547
00:57:18,000 --> 00:57:20,400
be detected and kicked out

1548
00:57:20,400 --> 00:57:22,400
i'll show you two examples the first one

1549
00:57:22,400 --> 00:57:25,280
is in 2021 the horizon data breach

1550
00:57:25,280 --> 00:57:28,799
incident report says roughly 50 of the

1551
00:57:28,799 --> 00:57:31,200
security incident were detected within a

1552
00:57:31,200 --> 00:57:32,720
few days

1553
00:57:32,720 --> 00:57:35,200
and the second one is in february 21st

1554
00:57:35,200 --> 00:57:36,640
hackers from lapses hacker group

1555
00:57:36,640 --> 00:57:38,880
compromised architect system and a

1556
00:57:38,880 --> 00:57:40,799
reason for instagram process

1557
00:57:40,799 --> 00:57:43,440
says that the access period was just 25

1558
00:57:43,440 --> 00:57:45,280
minutes

1559
00:57:45,280 --> 00:57:47,680
with that in mind let's come back to the

1560
00:57:47,680 --> 00:57:49,680
snapshot overall

1561
00:57:49,680 --> 00:57:51,920
we'd like to give a scheme such that the

1562
00:57:51,920 --> 00:57:54,559
ads given the access pattern of any

1563
00:57:54,559 --> 00:57:57,440
fixed window the adversary can learn no

1564
00:57:57,440 --> 00:57:59,200
information about the original

1565
00:57:59,200 --> 00:58:01,839
transcript

1566
00:58:02,079 --> 00:58:04,480
here's a summary of our contribution we

1567
00:58:04,480 --> 00:58:06,480
introduced snapshot oram define the new

1568
00:58:06,480 --> 00:58:08,799
security model we constructed and

1569
00:58:08,799 --> 00:58:13,359
analyzed three snapshot orem schemes

1570
00:58:13,359 --> 00:58:16,319
the current best orm scheme optorama

1571
00:58:16,319 --> 00:58:19,520
uses a constant client storage and a

1572
00:58:19,520 --> 00:58:22,160
logarithm of m bandwidth overhead

1573
00:58:22,160 --> 00:58:23,599
similar result was shown for

1574
00:58:23,599 --> 00:58:25,119
differentially parallel rm but the

1575
00:58:25,119 --> 00:58:28,319
latter has better concrete efficiency

1576
00:58:28,319 --> 00:58:30,559
now comes our

1577
00:58:30,559 --> 00:58:32,799
our snapshot ram schemes the first one

1578
00:58:32,799 --> 00:58:36,160
cqram which uses ofc kind of storage

1579
00:58:36,160 --> 00:58:38,160
here steaming the size of the observing

1580
00:58:38,160 --> 00:58:39,280
window

1581
00:58:39,280 --> 00:58:41,440
and the constant value is overhead

1582
00:58:41,440 --> 00:58:44,240
as we furthermore outsource the constant

1583
00:58:44,240 --> 00:58:46,000
outsource the kind of storage to the

1584
00:58:46,000 --> 00:58:48,480
cloud we can reduce the time storage to

1585
00:58:48,480 --> 00:58:51,440
constant and only introduce a logarithm

1586
00:58:51,440 --> 00:58:53,920
of 3 bandwidth overhead

1587
00:58:53,920 --> 00:58:56,000
we showed that this bandwidth overhead

1588
00:58:56,000 --> 00:58:58,240
is already optimal by giving its lower

1589
00:58:58,240 --> 00:59:00,479
bound

1590
00:59:01,760 --> 00:59:03,920
in the rest of my talk i will show you

1591
00:59:03,920 --> 00:59:05,839
the syntax and security of the snapshot

1592
00:59:05,839 --> 00:59:07,280
orm scheme

1593
00:59:07,280 --> 00:59:12,720
of the snapshot orm and introduce a

1594
00:59:12,720 --> 00:59:15,359
workload snapshot orm which is only

1595
00:59:15,359 --> 00:59:18,640
secure for one operation and increase

1596
00:59:18,640 --> 00:59:20,720
the window size to a general parameter

1597
00:59:20,720 --> 00:59:21,839
ce

1598
00:59:21,839 --> 00:59:23,359
and finally outsource the kind of

1599
00:59:23,359 --> 00:59:25,760
storage to the cloud

1600
00:59:25,760 --> 00:59:29,040
let's get started with the first part

1601
00:59:29,040 --> 00:59:31,599
in the snapshot orem game the adversary

1602
00:59:31,599 --> 00:59:34,160
is given and

1603
00:59:34,160 --> 00:59:37,200
win a windows parameter c and output two

1604
00:59:37,200 --> 00:59:41,118
pairs of database and transcript

1605
00:59:41,920 --> 00:59:44,160
the om will compile the transcript and

1606
00:59:44,160 --> 00:59:44,880
the

1607
00:59:44,880 --> 00:59:47,359
access pattern of last three operations

1608
00:59:47,359 --> 00:59:49,520
is given back to the adversary the

1609
00:59:49,520 --> 00:59:52,799
adversary then distinguish which

1610
00:59:52,799 --> 00:59:54,880
which pair of transcript

1611
00:59:54,880 --> 00:59:57,520
and the database is compiled we claim

1612
00:59:57,520 --> 01:00:00,079
that we fix the windows window at the

1613
01:00:00,079 --> 01:00:02,000
end of the transcript it's without loss

1614
01:00:02,000 --> 01:00:04,640
of generality because the operation in

1615
01:00:04,640 --> 01:00:07,040
the later transcript have has no

1616
01:00:07,040 --> 01:00:09,440
influence on the access pattern before

1617
01:00:09,440 --> 01:00:11,119
that namely

1618
01:00:11,119 --> 01:00:12,079
the

1619
01:00:12,079 --> 01:00:14,400
the operation after the window cannot

1620
01:00:14,400 --> 01:00:16,400
affect the access pattern of the window

1621
01:00:16,400 --> 01:00:19,200
so we can discard the operations after

1622
01:00:19,200 --> 01:00:21,599
the window

1623
01:00:21,599 --> 01:00:24,319
and what the orm does is two procedures

1624
01:00:24,319 --> 01:00:27,760
the first one is initialization on

1625
01:00:27,760 --> 01:00:29,920
the windowsill parameter c and a

1626
01:00:29,920 --> 01:00:31,680
database

1627
01:00:31,680 --> 01:00:34,079
the orm then executes on the transcript

1628
01:00:34,079 --> 01:00:35,839
operation by operation

1629
01:00:35,839 --> 01:00:37,040
and

1630
01:00:37,040 --> 01:00:39,520
outputs the excess pattern of last c

1631
01:00:39,520 --> 01:00:42,520
operation

1632
01:00:44,160 --> 01:00:46,400
now i will give you a one-month warm-up

1633
01:00:46,400 --> 01:00:48,720
scheme which is only for

1634
01:00:48,720 --> 01:00:52,399
only secure for one operation

1635
01:00:53,040 --> 01:00:54,960
on initialization it will shuffle the

1636
01:00:54,960 --> 01:00:57,280
memory using a sampled private

1637
01:00:57,280 --> 01:00:59,920
pseudo-random permutation or prp by

1638
01:00:59,920 --> 01:01:02,640
shuffle we mean the memory content at

1639
01:01:02,640 --> 01:01:06,160
index i will be relocated to index prp

1640
01:01:06,160 --> 01:01:07,280
of i

1641
01:01:07,280 --> 01:01:09,680
and on execution we read the memory

1642
01:01:09,680 --> 01:01:12,960
location prp of x and write it back we

1643
01:01:12,960 --> 01:01:15,520
need both a read and a write to

1644
01:01:15,520 --> 01:01:19,440
hide the actual operation type

1645
01:01:21,119 --> 01:01:23,839
in this example a right one becomes a

1646
01:01:23,839 --> 01:01:26,640
read prp of one and a right prp of one

1647
01:01:26,640 --> 01:01:27,920
and the right three becomes three

1648
01:01:27,920 --> 01:01:31,119
purpose three right pick up your three

1649
01:01:31,119 --> 01:01:33,280
the adversary is given the access

1650
01:01:33,280 --> 01:01:35,680
pattern of the last operation which is

1651
01:01:35,680 --> 01:01:38,240
right three and we claim that this theme

1652
01:01:38,240 --> 01:01:42,160
is one snapshot secure

1653
01:01:42,400 --> 01:01:44,720
because of the security of pseudonym

1654
01:01:44,720 --> 01:01:47,040
random permutation the prps3 is

1655
01:01:47,040 --> 01:01:48,640
indistinguishable from a random

1656
01:01:48,640 --> 01:01:51,520
permutation tile 3 and pi 3 is just a

1657
01:01:51,520 --> 01:01:53,599
random number

1658
01:01:53,599 --> 01:01:56,079
so which means the access pattern can be

1659
01:01:56,079 --> 01:01:58,960
efficiently simulated

1660
01:01:58,960 --> 01:02:00,640
however this scheme doesn't work for a

1661
01:02:00,640 --> 01:02:02,720
window size greater than 2 because if we

1662
01:02:02,720 --> 01:02:04,559
replace the operator the first operation

1663
01:02:04,559 --> 01:02:07,520
by three then the excess pattern of the

1664
01:02:07,520 --> 01:02:11,280
two operations are exactly the same

1665
01:02:11,280 --> 01:02:13,200
this is because the pseudonym random

1666
01:02:13,200 --> 01:02:15,200
permutation reveals repetition in

1667
01:02:15,200 --> 01:02:17,759
transcript

1668
01:02:18,400 --> 01:02:21,839
so how to fix that we come up with our

1669
01:02:21,839 --> 01:02:24,799
cqram scheme

1670
01:02:24,799 --> 01:02:27,280
before before that i will introduce an

1671
01:02:27,280 --> 01:02:29,760
insecure version although it is insecure

1672
01:02:29,760 --> 01:02:31,680
it still provides insights on how to

1673
01:02:31,680 --> 01:02:34,400
build a secure one

1674
01:02:34,400 --> 01:02:36,799
so the problem the previous problem is

1675
01:02:36,799 --> 01:02:39,599
uh repetition of trans of operations in

1676
01:02:39,599 --> 01:02:41,200
the transcript

1677
01:02:41,200 --> 01:02:42,880
so what we does

1678
01:02:42,880 --> 01:02:44,720
so what we do is

1679
01:02:44,720 --> 01:02:47,520
we have a local cache and whenever we

1680
01:02:47,520 --> 01:02:50,480
access our index we put that into the

1681
01:02:50,480 --> 01:02:52,799
local cache and effect from the local

1682
01:02:52,799 --> 01:02:56,880
cache when we access the second time

1683
01:02:57,280 --> 01:03:00,240
and we need to do a fake access to the

1684
01:03:00,240 --> 01:03:01,920
main memory that's why we need to

1685
01:03:01,920 --> 01:03:03,839
shuffle the memory together with two

1686
01:03:03,839 --> 01:03:06,000
c-filler elements using a pseudo-random

1687
01:03:06,000 --> 01:03:07,280
permutation

1688
01:03:07,280 --> 01:03:08,880
by initialization we also need to

1689
01:03:08,880 --> 01:03:11,839
initialize a local mtq

1690
01:03:11,839 --> 01:03:14,839
to maintain a first thing first out data

1691
01:03:14,839 --> 01:03:17,839
structure the execution part is

1692
01:03:17,839 --> 01:03:20,079
has two has two parts the first one is

1693
01:03:20,079 --> 01:03:22,160
check whether x is in the queue or not

1694
01:03:22,160 --> 01:03:24,400
if not we read the shuffle the memory

1695
01:03:24,400 --> 01:03:27,520
location prp of x otherwise we do a

1696
01:03:27,520 --> 01:03:29,520
state read

1697
01:03:29,520 --> 01:03:31,520
and on the second part we check if the

1698
01:03:31,520 --> 01:03:34,640
queue is full if yes we erase the last

1699
01:03:34,640 --> 01:03:36,640
element back to the main memory and

1700
01:03:36,640 --> 01:03:40,319
otherwise we do a fake write

1701
01:03:41,280 --> 01:03:45,200
so in this example of five operations

1702
01:03:45,200 --> 01:03:47,680
the window sizes two that's why we need

1703
01:03:47,680 --> 01:03:49,440
to add two

1704
01:03:49,440 --> 01:03:51,520
b which is four filler elements to the

1705
01:03:51,520 --> 01:03:53,280
main memory

1706
01:03:53,280 --> 01:03:55,280
the table on the right corner shows the

1707
01:03:55,280 --> 01:03:57,680
shows four real elements and four filler

1708
01:03:57,680 --> 01:04:01,280
elements this is before shuffling

1709
01:04:01,280 --> 01:04:05,200
so initially the queue is empty so we

1710
01:04:05,200 --> 01:04:08,319
so we read refresh one directly from the

1711
01:04:08,319 --> 01:04:10,880
main memory that's why we read prp of

1712
01:04:10,880 --> 01:04:13,599
one and since the queue is not full we

1713
01:04:13,599 --> 01:04:16,000
do we don't do eviction so we write a

1714
01:04:16,000 --> 01:04:17,920
filler element file

1715
01:04:17,920 --> 01:04:20,240
so the first read prp of one is the

1716
01:04:20,240 --> 01:04:22,799
fetch part and the second write prp of

1717
01:04:22,799 --> 01:04:24,839
five is the eviction

1718
01:04:24,839 --> 01:04:28,160
part on the second operation

1719
01:04:28,160 --> 01:04:30,720
one is already in the view so we do not

1720
01:04:30,720 --> 01:04:33,039
fetch from the main memory instead we do

1721
01:04:33,039 --> 01:04:35,200
a fake read and since the queue is not

1722
01:04:35,200 --> 01:04:38,640
full we do a fake write

1723
01:04:38,880 --> 01:04:41,200
on the third one since q is nothing in

1724
01:04:41,200 --> 01:04:43,440
the queue so so we fetch two from the

1725
01:04:43,440 --> 01:04:45,920
main memory and we also do a fake write

1726
01:04:45,920 --> 01:04:49,280
because the q is not full

1727
01:04:49,280 --> 01:04:51,200
now on reach three this time the two is

1728
01:04:51,200 --> 01:04:53,680
four so we need to evict one from the

1729
01:04:53,680 --> 01:04:56,240
queue back to the main memory

1730
01:04:56,240 --> 01:04:59,280
so we read three in and average one out

1731
01:04:59,280 --> 01:05:01,599
similarly for the last operation we read

1732
01:05:01,599 --> 01:05:04,000
four n and then right two out

1733
01:05:04,000 --> 01:05:06,240
now if we put all the memory access

1734
01:05:06,240 --> 01:05:09,520
pattern together and let the adversary

1735
01:05:09,520 --> 01:05:11,440
see the access pattern

1736
01:05:11,440 --> 01:05:13,359
the adversary can choose where the

1737
01:05:13,359 --> 01:05:15,280
window is

1738
01:05:15,280 --> 01:05:17,760
and we try to claim that no matter where

1739
01:05:17,760 --> 01:05:20,960
the adversary puts the window the

1740
01:05:20,960 --> 01:05:24,000
four access areas in the window are

1741
01:05:24,000 --> 01:05:26,240
distinct

1742
01:05:26,240 --> 01:05:29,520
however this claim is not

1743
01:05:29,520 --> 01:05:31,680
true for all the transcript

1744
01:05:31,680 --> 01:05:33,359
if the adversary altered the last

1745
01:05:33,359 --> 01:05:36,880
operation it replaced it by a write one

1746
01:05:36,880 --> 01:05:39,119
the re the fetch part of the last

1747
01:05:39,119 --> 01:05:41,760
operation becomes a read prp of one

1748
01:05:41,760 --> 01:05:44,240
which is same as the eviction part of

1749
01:05:44,240 --> 01:05:46,640
the second to last operation this is

1750
01:05:46,640 --> 01:05:48,720
what we call the fetch after right back

1751
01:05:48,720 --> 01:05:50,559
headers

1752
01:05:50,559 --> 01:05:53,760
and to fix that what we need to do is to

1753
01:05:53,760 --> 01:05:55,839
add a second queue to the insecure

1754
01:05:55,839 --> 01:05:56,880
version

1755
01:05:56,880 --> 01:05:58,400
we need to remember the written back

1756
01:05:58,400 --> 01:06:00,960
value for c more operations

1757
01:06:00,960 --> 01:06:03,280
and move the contents from the second

1758
01:06:03,280 --> 01:06:05,039
queue back to the first queue if

1759
01:06:05,039 --> 01:06:07,680
accessed again so the main point is we

1760
01:06:07,680 --> 01:06:09,760
need to fetch the memory content from

1761
01:06:09,760 --> 01:06:12,720
the two queues whenever possible

1762
01:06:12,720 --> 01:06:14,880
now i will give the name of the two

1763
01:06:14,880 --> 01:06:17,359
tools the first one is called write q

1764
01:06:17,359 --> 01:06:19,680
because we perform the actual memory

1765
01:06:19,680 --> 01:06:21,440
operation we modify the contents in the

1766
01:06:21,440 --> 01:06:24,000
right view and the second queue is what

1767
01:06:24,000 --> 01:06:25,760
we call read field because the segment

1768
01:06:25,760 --> 01:06:28,079
here is only for the remember the return

1769
01:06:28,079 --> 01:06:31,359
back value which is read only

1770
01:06:31,359 --> 01:06:32,640
to summarize

1771
01:06:32,640 --> 01:06:34,640
we on the first part we need to check

1772
01:06:34,640 --> 01:06:37,280
whether x is in the red right cube f yes

1773
01:06:37,280 --> 01:06:39,119
we read a field filler

1774
01:06:39,119 --> 01:06:41,280
and if not we check if x is in the read

1775
01:06:41,280 --> 01:06:44,000
view if yes we set x from the read field

1776
01:06:44,000 --> 01:06:46,000
and you are saying read otherwise we

1777
01:06:46,000 --> 01:06:48,960
fetch x directly from the main memory

1778
01:06:48,960 --> 01:06:51,359
on the eviction part we we check whether

1779
01:06:51,359 --> 01:06:53,359
right q is full or not if yes we write

1780
01:06:53,359 --> 01:06:55,760
the last sentence back otherwise we do a

1781
01:06:55,760 --> 01:06:58,000
fake right finally we check with the

1782
01:06:58,000 --> 01:07:00,559
research for not if yes we just

1783
01:07:00,559 --> 01:07:04,000
described the last element

1784
01:07:05,280 --> 01:07:07,599
this example is used to

1785
01:07:07,599 --> 01:07:11,520
show you how the two cues works

1786
01:07:11,520 --> 01:07:14,720
now on write once since the two cubes

1787
01:07:14,720 --> 01:07:17,359
are initially empty so we fetch one from

1788
01:07:17,359 --> 01:07:19,280
the main memory and the right queue is

1789
01:07:19,280 --> 01:07:22,160
not full so we read the so we do a state

1790
01:07:22,160 --> 01:07:26,000
right we access the fifth filler

1791
01:07:26,000 --> 01:07:28,160
and on the second operation one is the

1792
01:07:28,160 --> 01:07:29,839
in the right queue so we do not

1793
01:07:29,839 --> 01:07:32,799
transform the main memory we do a fake

1794
01:07:32,799 --> 01:07:35,119
read and the q is not full we do a fake

1795
01:07:35,119 --> 01:07:37,440
write

1796
01:07:38,400 --> 01:07:40,559
on this read two

1797
01:07:40,559 --> 01:07:43,200
since q is not in the true then we fetch

1798
01:07:43,200 --> 01:07:45,280
two from the main memory we move one to

1799
01:07:45,280 --> 01:07:47,359
the right left two in

1800
01:07:47,359 --> 01:07:50,079
and now the two is not full so we

1801
01:07:50,079 --> 01:07:52,000
do a fake right with your sticky

1802
01:07:52,000 --> 01:07:54,480
eviction

1803
01:07:54,640 --> 01:07:56,559
on route 3

1804
01:07:56,559 --> 01:07:59,359
the now if we fetch 3 to the right 2 the

1805
01:07:59,359 --> 01:08:02,400
red queue becomes 4 so into a vector 1

1806
01:08:02,400 --> 01:08:04,480
to the right 2 and also to the main

1807
01:08:04,480 --> 01:08:05,760
memory

1808
01:08:05,760 --> 01:08:11,240
now we move 2 to the right and read 3a

1809
01:08:11,839 --> 01:08:14,559
on right one this time one is not in the

1810
01:08:14,559 --> 01:08:17,279
right view but it's in the red two so we

1811
01:08:17,279 --> 01:08:20,319
directly move one back back to the right

1812
01:08:20,319 --> 01:08:23,679
queue and do not do a memory access

1813
01:08:23,679 --> 01:08:27,040
of one instead we do a fake read which

1814
01:08:27,040 --> 01:08:28,640
which which is

1815
01:08:28,640 --> 01:08:32,560
which means we need to read filler file

1816
01:08:32,560 --> 01:08:36,080
we move on to the right effect two

1817
01:08:36,080 --> 01:08:38,158
move through to the right and put one

1818
01:08:38,158 --> 01:08:41,120
back to the right two

1819
01:08:42,560 --> 01:08:44,158
on this root four

1820
01:08:44,158 --> 01:08:45,759
four is not in the right field not in

1821
01:08:45,759 --> 01:08:47,759
the root view so we directly fast

1822
01:08:47,759 --> 01:08:49,839
forward from the main memory we need to

1823
01:08:49,839 --> 01:08:52,560
adjust since both the re2 and right qr4

1824
01:08:52,560 --> 01:08:55,439
we need to erase to first average 32

1825
01:08:55,439 --> 01:08:59,520
discharge 1 move 2 to the right fx3

1826
01:08:59,520 --> 01:09:00,479
and

1827
01:09:00,479 --> 01:09:04,479
move one to the right and fetch 4a

1828
01:09:05,040 --> 01:09:07,679
and finally when we reach three three is

1829
01:09:07,679 --> 01:09:08,719
nothing in the right field but in the

1830
01:09:08,719 --> 01:09:10,479
root two so we

1831
01:09:10,479 --> 01:09:12,799
again we move move three from the root

1832
01:09:12,799 --> 01:09:14,960
two back to the right view with the star

1833
01:09:14,960 --> 01:09:18,238
two mostly to the right effect one move

1834
01:09:18,238 --> 01:09:22,399
four to the right and put three back in

1835
01:09:23,279 --> 01:09:24,450
so this time we

1836
01:09:24,450 --> 01:09:25,839
[Music]

1837
01:09:25,839 --> 01:09:27,040
access to

1838
01:09:27,040 --> 01:09:28,880
we evict one and

1839
01:09:28,880 --> 01:09:30,560
read a filler element

1840
01:09:30,560 --> 01:09:33,040
so if you may notice the

1841
01:09:33,040 --> 01:09:36,000
on the right corner the what was labeled

1842
01:09:36,000 --> 01:09:38,399
what is highlighted red is the actual x

1843
01:09:38,399 --> 01:09:39,679
pattern

1844
01:09:39,679 --> 01:09:42,319
if we put the axis pattern together this

1845
01:09:42,319 --> 01:09:44,560
time we can claim that for every two

1846
01:09:44,560 --> 01:09:47,279
adjacent operation that access the four

1847
01:09:47,279 --> 01:09:49,839
addresses are distinct

1848
01:09:49,839 --> 01:09:53,359
and after applying a prp on it

1849
01:09:53,359 --> 01:09:54,719
the

1850
01:09:54,719 --> 01:09:57,040
the the actual the the

1851
01:09:57,040 --> 01:09:58,159
memory

1852
01:09:58,159 --> 01:10:00,159
the the address will be

1853
01:10:00,159 --> 01:10:04,639
different and independently random

1854
01:10:08,960 --> 01:10:11,199
at the end of this part i will show you

1855
01:10:11,199 --> 01:10:12,880
i'll give you the idea of how to

1856
01:10:12,880 --> 01:10:16,960
outsource the two cues into the

1857
01:10:16,960 --> 01:10:19,280
cloud

1858
01:10:19,280 --> 01:10:21,360
so we try to outsource the cloud storage

1859
01:10:21,360 --> 01:10:23,520
but still limit the bandwidth to a

1860
01:10:23,520 --> 01:10:26,480
reasonable size so for the operations on

1861
01:10:26,480 --> 01:10:28,960
the two queues introduced previously we

1862
01:10:28,960 --> 01:10:30,560
need to

1863
01:10:30,560 --> 01:10:32,719
capture two properties the first one is

1864
01:10:32,719 --> 01:10:35,199
the first thing first out instructor and

1865
01:10:35,199 --> 01:10:37,120
also we need to efficiently check

1866
01:10:37,120 --> 01:10:39,520
memberships in the queue

1867
01:10:39,520 --> 01:10:43,120
most importantly obliviousness

1868
01:10:43,120 --> 01:10:45,520
so to satisfy those requirements we

1869
01:10:45,520 --> 01:10:47,520
devised this new data structure called

1870
01:10:47,520 --> 01:10:49,520
oblivious hash queue

1871
01:10:49,520 --> 01:10:52,719
and in our implementation the phqoram

1872
01:10:52,719 --> 01:10:55,360
uses a circular array and an oblivious

1873
01:10:55,360 --> 01:10:57,280
map

1874
01:10:57,280 --> 01:11:00,159
in our student implementation uh qram we

1875
01:11:00,159 --> 01:11:02,480
replace our previous map using our tutu

1876
01:11:02,480 --> 01:11:04,400
google hashing running on top of our

1877
01:11:04,400 --> 01:11:07,040
parameter because of the introduction of

1878
01:11:07,040 --> 01:11:09,280
optorama the

1879
01:11:09,280 --> 01:11:11,840
the bandwidth or the bandwidth overhead

1880
01:11:11,840 --> 01:11:14,560
reduce to logarithm of n but

1881
01:11:14,560 --> 01:11:18,719
the concrete performance will be bad

1882
01:11:20,400 --> 01:11:22,239
if you are interested in that check our

1883
01:11:22,239 --> 01:11:25,879
paper 2022-858

1884
01:11:28,719 --> 01:11:31,199
there are some promising follow-up words

1885
01:11:31,199 --> 01:11:33,199
for example the mo what what happens if

1886
01:11:33,199 --> 01:11:34,800
the adversary can take multiple

1887
01:11:34,800 --> 01:11:36,080
snapshots

1888
01:11:36,080 --> 01:11:39,120
with the minimum number of operations

1889
01:11:39,120 --> 01:11:41,600
between the two snapshots so that the om

1890
01:11:41,600 --> 01:11:45,280
can recover from the compromisation

1891
01:11:45,280 --> 01:11:47,679
and also what can happen if the snapshot

1892
01:11:47,679 --> 01:11:50,159
is taken in between operations for

1893
01:11:50,159 --> 01:11:52,159
example the second half of the right

1894
01:11:52,159 --> 01:11:55,839
three and the first half of read one

1895
01:11:57,360 --> 01:11:58,800
to conclude we start with the

1896
01:11:58,800 --> 01:12:00,960
observation that the adversary access to

1897
01:12:00,960 --> 01:12:02,960
system is time limited

1898
01:12:02,960 --> 01:12:05,679
then we introduce a snapshot all around

1899
01:12:05,679 --> 01:12:08,880
model we give three oran snapshot orem

1900
01:12:08,880 --> 01:12:11,280
schemes we also showed that the

1901
01:12:11,280 --> 01:12:13,120
show the bandwidth server had lower

1902
01:12:13,120 --> 01:12:15,760
bound and our stream is already off it's

1903
01:12:15,760 --> 01:12:17,199
already optimal

1904
01:12:17,199 --> 01:12:18,800
thank you everyone i'm happy to answer

1905
01:12:18,800 --> 01:12:21,800
questions

1906
01:12:28,880 --> 01:12:31,440
um so

1907
01:12:31,440 --> 01:12:33,840
in in the first slides in the motivation

1908
01:12:33,840 --> 01:12:36,000
you mentioned that many attacks many

1909
01:12:36,000 --> 01:12:38,960
breaches last only a few days right so

1910
01:12:38,960 --> 01:12:40,960
um if i understand correctly in accesses

1911
01:12:40,960 --> 01:12:43,280
you have to check both cues to see if

1912
01:12:43,280 --> 01:12:45,520
the entry being accessed is in either of

1913
01:12:45,520 --> 01:12:46,400
them

1914
01:12:46,400 --> 01:12:48,400
so if your

1915
01:12:48,400 --> 01:12:50,960
window has to your queue has to be long

1916
01:12:50,960 --> 01:12:54,640
enough for a few days and you want to um

1917
01:12:54,640 --> 01:12:55,760
be able to

1918
01:12:55,760 --> 01:12:56,960
sustain a ban

1919
01:12:56,960 --> 01:12:58,560
a certain operation per second or

1920
01:12:58,560 --> 01:13:00,800
operation per period of time the queue

1921
01:13:00,800 --> 01:13:02,480
can get fairly large so

1922
01:13:02,480 --> 01:13:06,159
uh can that uh search to find whether uh

1923
01:13:06,159 --> 01:13:08,400
the entry is in either queue become the

1924
01:13:08,400 --> 01:13:10,960
bottleneck

1925
01:13:11,120 --> 01:13:13,520
that's a good question so

1926
01:13:13,520 --> 01:13:16,159
what we claim that the the size of the

1927
01:13:16,159 --> 01:13:18,400
two will be relatively

1928
01:13:18,400 --> 01:13:21,280
short comparing to the size of the

1929
01:13:21,280 --> 01:13:22,560
database

1930
01:13:22,560 --> 01:13:25,199
so the we can we start with the

1931
01:13:25,199 --> 01:13:28,080
motivation that the the

1932
01:13:28,080 --> 01:13:29,760
adversary access to system is time

1933
01:13:29,760 --> 01:13:33,040
limited and this this uh

1934
01:13:33,040 --> 01:13:34,960
compromise time frame is relatively

1935
01:13:34,960 --> 01:13:38,080
short so that the field can be

1936
01:13:38,080 --> 01:13:40,560
short shorter comparing to the size of

1937
01:13:40,560 --> 01:13:42,640
the database so

1938
01:13:42,640 --> 01:13:44,640
that's how we reduce the bandwidth

1939
01:13:44,640 --> 01:13:48,080
overhead thank you thank you

1940
01:13:48,080 --> 01:13:50,719
uh thanks for the talk do you have did

1941
01:13:50,719 --> 01:13:52,640
you have an implementation do you have

1942
01:13:52,640 --> 01:13:54,960
concrete efficiency numbers

1943
01:13:54,960 --> 01:13:56,640
uh no

1944
01:13:56,640 --> 01:13:57,600
okay

1945
01:13:57,600 --> 01:13:58,640
also

1946
01:13:58,640 --> 01:14:01,840
uh i had a i guess a similar question

1947
01:14:01,840 --> 01:14:05,280
um so it seems that

1948
01:14:05,280 --> 01:14:07,280
this approach mainly makes sense when we

1949
01:14:07,280 --> 01:14:09,600
can assume that c the length of the

1950
01:14:09,600 --> 01:14:11,040
queue is small

1951
01:14:11,040 --> 01:14:12,840
so

1952
01:14:12,840 --> 01:14:14,880
uh if

1953
01:14:14,880 --> 01:14:17,199
the length of the like since attacks

1954
01:14:17,199 --> 01:14:19,120
could last for a few days this seems to

1955
01:14:19,120 --> 01:14:21,280
apply more in the model where you have

1956
01:14:21,280 --> 01:14:23,120
an o ram where there are a low number of

1957
01:14:23,120 --> 01:14:24,400
queries

1958
01:14:24,400 --> 01:14:26,960
uh say per hour or

1959
01:14:26,960 --> 01:14:29,440
or you know probably a query per second

1960
01:14:29,440 --> 01:14:30,800
is already a lot

1961
01:14:30,800 --> 01:14:32,880
right but if we have a low number of

1962
01:14:32,880 --> 01:14:35,520
queries then it seems like the

1963
01:14:35,520 --> 01:14:38,080
efficiency of the oram is no longer such

1964
01:14:38,080 --> 01:14:39,199
a problem

1965
01:14:39,199 --> 01:14:41,120
and we could just use

1966
01:14:41,120 --> 01:14:43,600
existing inefficient oram

1967
01:14:43,600 --> 01:14:44,640
um

1968
01:14:44,640 --> 01:14:46,719
so i guess like like what what's your

1969
01:14:46,719 --> 01:14:48,640
take on that like

1970
01:14:48,640 --> 01:14:51,199
why is this model useful given that

1971
01:14:51,199 --> 01:14:53,679
wouldn't seem to work for

1972
01:14:53,679 --> 01:14:56,000
like a high rate of queries but if you

1973
01:14:56,000 --> 01:14:57,920
don't have a high rate of queries then

1974
01:14:57,920 --> 01:15:01,440
there's not much need to optimize

1975
01:15:07,440 --> 01:15:09,520
that's a good question

1976
01:15:09,520 --> 01:15:10,560
so

1977
01:15:10,560 --> 01:15:14,719
what we what we did here is we

1978
01:15:16,320 --> 01:15:17,120
we

1979
01:15:17,120 --> 01:15:19,840
the the motivation of this uh new oem

1980
01:15:19,840 --> 01:15:21,760
scheme is just to

1981
01:15:21,760 --> 01:15:22,880
limit the

1982
01:15:22,880 --> 01:15:26,239
is a place where the adversary access to

1983
01:15:26,239 --> 01:15:27,920
system is uh

1984
01:15:27,920 --> 01:15:31,440
say short time and

1985
01:15:31,520 --> 01:15:35,520
with that we can we indeed actually

1986
01:15:35,520 --> 01:15:37,440
make use of oram

1987
01:15:37,440 --> 01:15:40,000
which is which we use optorama as a

1988
01:15:40,000 --> 01:15:43,679
subroutine of our new snapshot of ram so

1989
01:15:43,679 --> 01:15:45,199
we

1990
01:15:45,199 --> 01:15:46,960
we do not consider the english

1991
01:15:46,960 --> 01:15:49,360
efficiency of that part just the

1992
01:15:49,360 --> 01:15:51,360
what the subroutine

1993
01:15:51,360 --> 01:15:54,320
the our subroutine autorama is have has

1994
01:15:54,320 --> 01:15:55,520
a

1995
01:15:55,520 --> 01:15:57,760
very small size space ce

1996
01:15:57,760 --> 01:16:01,440
so the the english in efficiency can

1997
01:16:01,440 --> 01:16:03,360
like we do not take that into

1998
01:16:03,360 --> 01:16:05,760
consideration

1999
01:16:05,760 --> 01:16:08,880
okay maybe i can follow up with you

2000
01:16:08,880 --> 01:16:10,800
thank you

2001
01:16:10,800 --> 01:16:14,760
all right let's thank the speaker again

2002
01:16:57,440 --> 01:16:59,519
you

