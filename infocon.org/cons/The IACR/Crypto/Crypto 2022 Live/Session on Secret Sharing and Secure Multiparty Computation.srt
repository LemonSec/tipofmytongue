1
00:00:00,000 --> 00:00:02,159
benny applebaum erican cathlon and

2
00:00:02,159 --> 00:00:03,919
alpita patra

3
00:00:03,919 --> 00:00:06,000
and i think eliran is going to give the

4
00:00:06,000 --> 00:00:09,759
talk online correct

5
00:00:09,920 --> 00:00:10,800
yes

6
00:00:10,800 --> 00:00:11,679
right

7
00:00:11,679 --> 00:00:12,960
take it away oh

8
00:00:12,960 --> 00:00:15,440
okay so hi everyone my name is andylan i

9
00:00:15,440 --> 00:00:17,279
present a joint to work with bernie and

10
00:00:17,279 --> 00:00:18,480
delpita

11
00:00:18,480 --> 00:00:19,760
about

12
00:00:19,760 --> 00:00:21,760
the faber relationship and multivariate

13
00:00:21,760 --> 00:00:23,680
file zero knowledge in two rounds

14
00:00:23,680 --> 00:00:24,800
and i will show that if we have an

15
00:00:24,800 --> 00:00:26,240
honest majority then we have a

16
00:00:26,240 --> 00:00:27,920
substitute for non-iterative

17
00:00:27,920 --> 00:00:30,400
zero-knowledge and formic assumptions so

18
00:00:30,400 --> 00:00:31,920
let me start by discussing

19
00:00:31,920 --> 00:00:34,480
multivariation zero knowledge

20
00:00:34,480 --> 00:00:36,719
and as you know in the standard zero

21
00:00:36,719 --> 00:00:38,320
number settings we have one proven one

22
00:00:38,320 --> 00:00:40,480
verifier and required standard

23
00:00:40,480 --> 00:00:41,680
completeness soundness and zero

24
00:00:41,680 --> 00:00:43,920
knowledge properties but in this work we

25
00:00:43,920 --> 00:00:45,280
are interested in the case where there

26
00:00:45,280 --> 00:00:47,280
is one provail wants to prove some

27
00:00:47,280 --> 00:00:48,640
statement in zero knowledge to many

28
00:00:48,640 --> 00:00:51,039
valid files so this can be seen as the

29
00:00:51,039 --> 00:00:53,600
duan to multiple zero knowledge and this

30
00:00:53,600 --> 00:00:55,039
is in fact a common scenario in a

31
00:00:55,039 --> 00:00:56,960
multi-party computation where one party

32
00:00:56,960 --> 00:00:58,879
wants to prove some statement in a zero

33
00:00:58,879 --> 00:01:02,000
knowledge to the rest of the parties

34
00:01:02,000 --> 00:01:03,760
so we follow the framework of a

35
00:01:03,760 --> 00:01:06,560
multi-party computation and we

36
00:01:06,560 --> 00:01:08,479
we use idiom functionality to define a

37
00:01:08,479 --> 00:01:11,040
mvck so this is the ideal functionality

38
00:01:11,040 --> 00:01:13,520
of mvck it is a parameterized variation

39
00:01:13,520 --> 00:01:14,640
now

40
00:01:14,640 --> 00:01:16,560
the approval inputs statement x and the

41
00:01:16,560 --> 00:01:18,159
witness w

42
00:01:18,159 --> 00:01:20,000
and if the relation is satisfied and we

43
00:01:20,000 --> 00:01:22,240
want all the 12s to on the valid files

44
00:01:22,240 --> 00:01:23,840
to know the statement x so the value

45
00:01:23,840 --> 00:01:25,840
files receive the statement x and they

46
00:01:25,840 --> 00:01:27,439
know that the statement x is true and

47
00:01:27,439 --> 00:01:29,360
the proverbial as the corresponding

48
00:01:29,360 --> 00:01:30,960
witness and of course they have no

49
00:01:30,960 --> 00:01:33,920
information about this witness

50
00:01:33,920 --> 00:01:35,680
and otherwise if the donation is not

51
00:01:35,680 --> 00:01:38,000
satisfied then the very files receive a

52
00:01:38,000 --> 00:01:39,439
special symbol that tells them that they

53
00:01:39,439 --> 00:01:41,360
probably will try to cheat okay so this

54
00:01:41,360 --> 00:01:43,439
is the mvck functionality

55
00:01:43,439 --> 00:01:45,439
and we want to implement it so we assume

56
00:01:45,439 --> 00:01:47,439
that the players can communicate over

57
00:01:47,439 --> 00:01:49,119
secure channels and also they have

58
00:01:49,119 --> 00:01:50,960
access to the broadcast channel

59
00:01:50,960 --> 00:01:52,960
and will require full security even

60
00:01:52,960 --> 00:01:54,880
against an active adversary that can

61
00:01:54,880 --> 00:01:56,640
deviate from the protocol

62
00:01:56,640 --> 00:01:58,560
and film security provides a strong

63
00:01:58,560 --> 00:02:00,799
security guarantees including the stone

64
00:02:00,799 --> 00:02:02,240
completeness notion

65
00:02:02,240 --> 00:02:04,240
so the anonymous approval can convince

66
00:02:04,240 --> 00:02:06,000
the honest verifiers that the statement

67
00:02:06,000 --> 00:02:07,040
is true

68
00:02:07,040 --> 00:02:08,878
even if some of the valid files are

69
00:02:08,878 --> 00:02:10,239
corrupt

70
00:02:10,239 --> 00:02:12,400
we also obtain a simulation based zero

71
00:02:12,400 --> 00:02:13,599
knowledge

72
00:02:13,599 --> 00:02:15,360
which means that the corrupt valid files

73
00:02:15,360 --> 00:02:18,080
have no information about the witness

74
00:02:18,080 --> 00:02:19,520
and finally we have sound let's say with

75
00:02:19,520 --> 00:02:20,959
node extraction

76
00:02:20,959 --> 00:02:23,280
which means that a corrupt server cannot

77
00:02:23,280 --> 00:02:25,680
convince the honest value files that the

78
00:02:25,680 --> 00:02:27,840
some firm's statement is true even if

79
00:02:27,840 --> 00:02:29,440
some of the value files are corrupt and

80
00:02:29,440 --> 00:02:31,040
we even have knowledge extraction which

81
00:02:31,040 --> 00:02:33,280
means that if the approval convinces the

82
00:02:33,280 --> 00:02:34,640
valid files

83
00:02:34,640 --> 00:02:36,640
that the statement is stored then we can

84
00:02:36,640 --> 00:02:39,120
extract the witness from the joint view

85
00:02:39,120 --> 00:02:41,680
of the honest valid files

86
00:02:41,680 --> 00:02:44,560
and in this work we we study

87
00:02:44,560 --> 00:02:46,239
the wrong complexity of protocols that

88
00:02:46,239 --> 00:02:48,879
achieve those requirements so we ask how

89
00:02:48,879 --> 00:02:51,280
many rounds are required for mvck and we

90
00:02:51,280 --> 00:02:53,200
will be interested in a tour on protocol

91
00:02:53,200 --> 00:02:55,120
so we asked can we get it to run the mvk

92
00:02:55,120 --> 00:02:57,040
protocol

93
00:02:57,040 --> 00:02:58,800
and it turns out that if we don't have

94
00:02:58,800 --> 00:03:00,720
an honest majority then we cannot have

95
00:03:00,720 --> 00:03:03,120
it to one protocol this follows from the

96
00:03:03,120 --> 00:03:05,360
classic work for a gondola and orlando

97
00:03:05,360 --> 00:03:06,640
and one can show that the two one

98
00:03:06,640 --> 00:03:09,519
protocol exists only for bpp

99
00:03:09,519 --> 00:03:11,599
okay now i do want to mention that if we

100
00:03:11,599 --> 00:03:13,760
have a common random string

101
00:03:13,760 --> 00:03:15,440
then the resistor wants the protocol

102
00:03:15,440 --> 00:03:17,440
form of np this is non-interactive zero

103
00:03:17,440 --> 00:03:19,280
knowledge and you can achieve it either

104
00:03:19,280 --> 00:03:21,120
from a pubmedia assumptions or in the

105
00:03:21,120 --> 00:03:23,120
random working body

106
00:03:23,120 --> 00:03:24,640
but like i said this is not a two-one

107
00:03:24,640 --> 00:03:26,239
protocol and we cannot get a two-one

108
00:03:26,239 --> 00:03:28,959
protocol without honest majority

109
00:03:28,959 --> 00:03:31,040
however if we do advanced majority then

110
00:03:31,040 --> 00:03:33,519
we can get a two-one protocol

111
00:03:33,519 --> 00:03:35,120
so just like before we cannot get a

112
00:03:35,120 --> 00:03:36,560
one-round protocol one-on-one protocol

113
00:03:36,560 --> 00:03:38,319
exists only for bpp but we can get a

114
00:03:38,319 --> 00:03:40,640
two-on-one protocol form of np

115
00:03:40,640 --> 00:03:42,480
and this protocol is implicit in the

116
00:03:42,480 --> 00:03:44,799
work of gotenostrovsky and it requires

117
00:03:44,799 --> 00:03:46,239
pubmed encryption and the

118
00:03:46,239 --> 00:03:48,239
non-interactive zero knowledge

119
00:03:48,239 --> 00:03:49,920
and this protocol actually has this nice

120
00:03:49,920 --> 00:03:51,440
feature that the first round is

121
00:03:51,440 --> 00:03:53,599
independent of the inputs and this means

122
00:03:53,599 --> 00:03:55,280
that the players can execute the first

123
00:03:55,280 --> 00:03:56,959
round even before the prover knows the

124
00:03:56,959 --> 00:03:58,239
statement and the weakness which are

125
00:03:58,239 --> 00:04:01,200
only required for the second one

126
00:04:01,200 --> 00:04:02,959
and but as you can see the assumptions

127
00:04:02,959 --> 00:04:04,319
required for this protocol are

128
00:04:04,319 --> 00:04:05,599
essentially the same assumptions

129
00:04:05,599 --> 00:04:07,200
required for non-interactive zero

130
00:04:07,200 --> 00:04:08,159
knowledge

131
00:04:08,159 --> 00:04:09,760
or maybe even stronger assumptions like

132
00:04:09,760 --> 00:04:11,519
public encryption

133
00:04:11,519 --> 00:04:13,040
and therefore we ask can you use the

134
00:04:13,040 --> 00:04:14,640
fact that we have an honest majority in

135
00:04:14,640 --> 00:04:17,120
order to get rid of linus consumption

136
00:04:17,120 --> 00:04:18,880
and who knows maybe we can even use many

137
00:04:18,880 --> 00:04:21,199
clip-type assumptions

138
00:04:21,199 --> 00:04:22,720
so in this work we show that it is

139
00:04:22,720 --> 00:04:24,479
possible so we assume the existence of

140
00:04:24,479 --> 00:04:26,880
non-interactive commitments and we show

141
00:04:26,880 --> 00:04:28,479
that there existed two around nvck

142
00:04:28,479 --> 00:04:30,160
protocol again with this nice feature of

143
00:04:30,160 --> 00:04:31,759
offline online round

144
00:04:31,759 --> 00:04:33,520
so that if the number of parties is

145
00:04:33,520 --> 00:04:36,160
constant we obtain optimal resiliency

146
00:04:36,160 --> 00:04:37,840
for honest majority this means that the

147
00:04:37,840 --> 00:04:40,240
number of corrupt parties t should be

148
00:04:40,240 --> 00:04:42,000
less than one half the number of parties

149
00:04:42,000 --> 00:04:43,759
then

150
00:04:43,759 --> 00:04:45,600
and otherwise if the number of parties

151
00:04:45,600 --> 00:04:47,600
is larger if it is polynomial then we

152
00:04:47,600 --> 00:04:49,520
obtain almost optimum resiliency which

153
00:04:49,520 --> 00:04:51,199
means the number of corrupt parties t

154
00:04:51,199 --> 00:04:53,520
should be at most let's say 0.499 the

155
00:04:53,520 --> 00:04:55,759
number of parties n this constant can be

156
00:04:55,759 --> 00:04:57,600
any constant orbital and equals to one

157
00:04:57,600 --> 00:04:58,720
half

158
00:04:58,720 --> 00:05:00,400
so those are the results regarding

159
00:05:00,400 --> 00:05:02,080
gamma's decay

160
00:05:02,080 --> 00:05:03,919
and i want to highlight the case of a

161
00:05:03,919 --> 00:05:06,320
one mover and two valid files so this

162
00:05:06,320 --> 00:05:08,560
means that by adding just a single value

163
00:05:08,560 --> 00:05:10,320
file to the standard zero knowledge

164
00:05:10,320 --> 00:05:12,479
settings you can get a two on the

165
00:05:12,479 --> 00:05:13,759
protocol

166
00:05:13,759 --> 00:05:15,759
which that provides full security and

167
00:05:15,759 --> 00:05:18,479
for many clip type assumptions

168
00:05:18,479 --> 00:05:20,400
okay now let me say a few words about

169
00:05:20,400 --> 00:05:22,240
the non-interactive commitments so there

170
00:05:22,240 --> 00:05:23,520
are two kinds of non-interactive

171
00:05:23,520 --> 00:05:25,120
commitments the first one is their

172
00:05:25,120 --> 00:05:27,120
computationally hiding non-interactive

173
00:05:27,120 --> 00:05:29,280
non-iterative commitments

174
00:05:29,280 --> 00:05:31,280
and if we use this kind of commitments

175
00:05:31,280 --> 00:05:33,840
then we also need some kind of security

176
00:05:33,840 --> 00:05:36,400
against an active opening attacks

177
00:05:36,400 --> 00:05:38,800
but those commitments can be constructed

178
00:05:38,800 --> 00:05:40,240
for many clip-type assumptions for

179
00:05:40,240 --> 00:05:41,840
example they can be constructed from

180
00:05:41,840 --> 00:05:43,360
injective one-way function say with

181
00:05:43,360 --> 00:05:45,440
sub-exponential hardness

182
00:05:45,440 --> 00:05:47,120
or even from standard one-way functions

183
00:05:47,120 --> 00:05:48,560
with sub-exponential hardness together

184
00:05:48,560 --> 00:05:50,320
with the common random string or under

185
00:05:50,320 --> 00:05:52,400
some randomization assumptions

186
00:05:52,400 --> 00:05:53,840
okay so again if we use those

187
00:05:53,840 --> 00:05:55,759
commitments that can be obtained for

188
00:05:55,759 --> 00:05:57,520
medical type assumptions

189
00:05:57,520 --> 00:05:59,120
then we obtain the results

190
00:05:59,120 --> 00:06:00,639
that i've just described in the previous

191
00:06:00,639 --> 00:06:02,639
slide

192
00:06:02,639 --> 00:06:04,240
the second kind of commitments of

193
00:06:04,240 --> 00:06:07,199
statistically hiding and if we use this

194
00:06:07,199 --> 00:06:08,639
kind of commitments then we obtain a

195
00:06:08,639 --> 00:06:10,639
protocol that provides a stronger notion

196
00:06:10,639 --> 00:06:12,160
of security which is calling the

197
00:06:12,160 --> 00:06:14,080
everlasting security

198
00:06:14,080 --> 00:06:15,600
so this means that the protocol is

199
00:06:15,600 --> 00:06:17,280
secure against an adversary which is

200
00:06:17,280 --> 00:06:19,199
bounded during the execution but can be

201
00:06:19,199 --> 00:06:21,120
unbounded after the execution of the

202
00:06:21,120 --> 00:06:24,000
protocol okay so evaluating security

203
00:06:24,000 --> 00:06:26,000
can be seen as a security notion in

204
00:06:26,000 --> 00:06:28,240
between computation and security and the

205
00:06:28,240 --> 00:06:31,680
information theoretic security

206
00:06:31,919 --> 00:06:32,880
and the

207
00:06:32,880 --> 00:06:34,240
statistics hiding orientative

208
00:06:34,240 --> 00:06:35,840
commitments can be based on cognition

209
00:06:35,840 --> 00:06:37,600
resistant hash functions so again we get

210
00:06:37,600 --> 00:06:40,080
the mini clip type assumption

211
00:06:40,080 --> 00:06:42,080
there is a small technicality regarding

212
00:06:42,080 --> 00:06:44,240
how we select the hash function

213
00:06:44,240 --> 00:06:46,319
so one option is to use a common random

214
00:06:46,319 --> 00:06:48,000
string to just something's a random hash

215
00:06:48,000 --> 00:06:50,000
function from the family we can also

216
00:06:50,000 --> 00:06:51,440
have an additional offering around in

217
00:06:51,440 --> 00:06:53,280
which the in which details the sample

218
00:06:53,280 --> 00:06:54,720
research function

219
00:06:54,720 --> 00:06:56,400
and finally if that versa is uniform

220
00:06:56,400 --> 00:06:57,840
then the hash function can be fixed and

221
00:06:57,840 --> 00:07:00,400
we don't need the distortions

222
00:07:00,400 --> 00:07:02,560
okay so again the main point if you use

223
00:07:02,560 --> 00:07:04,160
the statistically hiding non-interactive

224
00:07:04,160 --> 00:07:07,199
commitments we obtain evolutive security

225
00:07:07,199 --> 00:07:09,039
now let me mention an application of

226
00:07:09,039 --> 00:07:10,560
mvck

227
00:07:10,560 --> 00:07:12,400
so every sky capture is an important

228
00:07:12,400 --> 00:07:14,319
aspect of a non-interactive zero

229
00:07:14,319 --> 00:07:16,080
knowledge which is the minimum around

230
00:07:16,080 --> 00:07:18,080
complexity okay which means that if we

231
00:07:18,080 --> 00:07:20,080
have an honest majority npck can be seen

232
00:07:20,080 --> 00:07:22,000
as a substitute for non-interactive zero

233
00:07:22,000 --> 00:07:24,400
knowledge where the crs is replaced with

234
00:07:24,400 --> 00:07:26,319
the single offline round and then the

235
00:07:26,319 --> 00:07:28,479
fourth requires only one round and in

236
00:07:28,479 --> 00:07:30,319
addition we also provide uses security

237
00:07:30,319 --> 00:07:31,520
which means that you can use our

238
00:07:31,520 --> 00:07:33,360
envision k protocol in your protocols

239
00:07:33,360 --> 00:07:35,120
instead of risk

240
00:07:35,120 --> 00:07:37,120
and uh finally the main point of course

241
00:07:37,120 --> 00:07:38,720
is that we get all of this from a

242
00:07:38,720 --> 00:07:40,960
minicrypt type assumptions okay so this

243
00:07:40,960 --> 00:07:43,360
was mvck

244
00:07:43,360 --> 00:07:45,199
but in the paper we study a more general

245
00:07:45,199 --> 00:07:47,360
problem calling the very fabian relation

246
00:07:47,360 --> 00:07:48,720
sharing

247
00:07:48,720 --> 00:07:51,120
and so so far we assume that everyone

248
00:07:51,120 --> 00:07:53,039
knows the same statement

249
00:07:53,039 --> 00:07:54,879
but what happens if the statement is

250
00:07:54,879 --> 00:07:56,800
distributed among the valid files okay

251
00:07:56,800 --> 00:07:58,240
so in this scenario the approval knows

252
00:07:58,240 --> 00:07:59,919
only information you know the statement

253
00:07:59,919 --> 00:08:02,160
the weakness and only shares and every

254
00:08:02,160 --> 00:08:04,080
verifier know exactly one share of the

255
00:08:04,080 --> 00:08:05,440
statement and the approval wants to

256
00:08:05,440 --> 00:08:07,199
prove that the shell statement is true

257
00:08:07,199 --> 00:08:09,280
in zero knowledge

258
00:08:09,280 --> 00:08:10,879
so this is the scenario that occurs in a

259
00:08:10,879 --> 00:08:12,639
multi-party computation but also in a

260
00:08:12,639 --> 00:08:14,560
practicing case it's not like a private

261
00:08:14,560 --> 00:08:16,000
data aggregation

262
00:08:16,000 --> 00:08:18,400
in the anonymous communication

263
00:08:18,400 --> 00:08:20,639
and i do want to mention the work of

264
00:08:20,639 --> 00:08:22,479
bonnet boy and corrigan gibbs quinbo and

265
00:08:22,479 --> 00:08:23,440
shy

266
00:08:23,440 --> 00:08:25,840
that initiated the formal study of zero

267
00:08:25,840 --> 00:08:27,759
knowledge proofs over shell data

268
00:08:27,759 --> 00:08:29,360
okay so

269
00:08:29,360 --> 00:08:30,720
this is the zero knowledge proofs of

270
00:08:30,720 --> 00:08:32,320
virtual data and verifiable

271
00:08:32,320 --> 00:08:33,599
relationships can be seen as a

272
00:08:33,599 --> 00:08:35,760
generalization of the scenario where we

273
00:08:35,760 --> 00:08:37,679
consider both the sharing

274
00:08:37,679 --> 00:08:40,000
of the statement x and also the proving

275
00:08:40,000 --> 00:08:41,440
that the statement tax is two at the

276
00:08:41,440 --> 00:08:43,599
same time okay so again we formalize it

277
00:08:43,599 --> 00:08:46,800
by using the idiom functionality

278
00:08:46,800 --> 00:08:48,880
and like i said approval wants to share

279
00:08:48,880 --> 00:08:50,320
the statement text so those are the

280
00:08:50,320 --> 00:08:51,839
shares of the statement tags they have

281
00:08:51,839 --> 00:08:54,000
one shell for each valid file and he

282
00:08:54,000 --> 00:08:55,360
also wants to prove that the shared

283
00:08:55,360 --> 00:08:58,080
statement is true so he inputs a

284
00:08:58,080 --> 00:09:00,480
secret witness and again if the relation

285
00:09:00,480 --> 00:09:02,480
is satisfied then every verifier

286
00:09:02,480 --> 00:09:04,399
receives exactly one shell so every

287
00:09:04,399 --> 00:09:06,480
verifier knows one shell but there's no

288
00:09:06,480 --> 00:09:08,959
information about the other shells or

289
00:09:08,959 --> 00:09:10,720
about the secret weakness

290
00:09:10,720 --> 00:09:12,320
and on the other hand if the relation is

291
00:09:12,320 --> 00:09:14,720
not satisfied then the very first

292
00:09:14,720 --> 00:09:16,640
received special symbol returns them by

293
00:09:16,640 --> 00:09:18,320
the forward title cheat so this is the

294
00:09:18,320 --> 00:09:20,480
vls functionality

295
00:09:20,480 --> 00:09:22,000
and yet we mentioned that the vrs

296
00:09:22,000 --> 00:09:23,680
captures and generalizes several

297
00:09:23,680 --> 00:09:25,680
cryptographic primitives like verifiable

298
00:09:25,680 --> 00:09:27,440
and secret sharing so here for example

299
00:09:27,440 --> 00:09:29,040
we want to share the value

300
00:09:29,040 --> 00:09:30,320
and also prove that the shells

301
00:09:30,320 --> 00:09:31,680
correspond to annoying

302
00:09:31,680 --> 00:09:33,040
degree polynomial

303
00:09:33,040 --> 00:09:35,040
it also captures the pure multicast and

304
00:09:35,040 --> 00:09:36,480
like i said multi verifies zero

305
00:09:36,480 --> 00:09:37,440
knowledge

306
00:09:37,440 --> 00:09:39,200
and it can be seen as a generalization

307
00:09:39,200 --> 00:09:40,800
of zero knowledge proofs of their shared

308
00:09:40,800 --> 00:09:43,120
data

309
00:09:43,360 --> 00:09:44,880
and just like before we are interested

310
00:09:44,880 --> 00:09:46,399
in the case of honest majority and

311
00:09:46,399 --> 00:09:48,320
requires security against an active

312
00:09:48,320 --> 00:09:50,240
adversary and again this implies a

313
00:09:50,240 --> 00:09:52,000
strong completeness notion is simulation

314
00:09:52,000 --> 00:09:53,760
based security and the soundness of

315
00:09:53,760 --> 00:09:55,360
knowledge extraction

316
00:09:55,360 --> 00:09:56,880
and we studied around complexity of

317
00:09:56,880 --> 00:09:58,959
protocol of protocols that achieve those

318
00:09:58,959 --> 00:10:01,120
lgs

319
00:10:01,120 --> 00:10:02,880
so let me tell you what is known about

320
00:10:02,880 --> 00:10:05,760
the round complexity of vrs

321
00:10:05,760 --> 00:10:06,720
so

322
00:10:06,720 --> 00:10:08,399
this is a work in progress again with

323
00:10:08,399 --> 00:10:10,320
bernie and alpina in which we show that

324
00:10:10,320 --> 00:10:12,320
a 2 on the vls with information

325
00:10:12,320 --> 00:10:14,399
theoretic security is impossible ok so

326
00:10:14,399 --> 00:10:16,480
if we want the 21 protocol we cannot get

327
00:10:16,480 --> 00:10:17,360
it

328
00:10:17,360 --> 00:10:19,360
with information theoretic security and

329
00:10:19,360 --> 00:10:20,720
therefore we again consider the

330
00:10:20,720 --> 00:10:22,560
computation and security

331
00:10:22,560 --> 00:10:24,399
but even with computational security the

332
00:10:24,399 --> 00:10:25,839
best upper bound that we have is the

333
00:10:25,839 --> 00:10:28,240
three-run protocol of acgj

334
00:10:28,240 --> 00:10:30,240
so this is in fact a protocol for

335
00:10:30,240 --> 00:10:32,720
general mpc and it requires a public key

336
00:10:32,720 --> 00:10:34,320
encryption and the non-interactive zero

337
00:10:34,320 --> 00:10:36,079
knowledge so this is the best upper

338
00:10:36,079 --> 00:10:37,519
bound that we have

339
00:10:37,519 --> 00:10:39,040
and of course there is another boundary

340
00:10:39,040 --> 00:10:41,040
for one round so one one round vls is

341
00:10:41,040 --> 00:10:42,399
impossible

342
00:10:42,399 --> 00:10:44,000
okay but as you can see the question of

343
00:10:44,000 --> 00:10:47,040
the two round the vrs is open

344
00:10:47,040 --> 00:10:49,279
and we show that we can get it to on vrs

345
00:10:49,279 --> 00:10:51,200
and even from a mini great assumption so

346
00:10:51,200 --> 00:10:52,640
those are essentially the same results

347
00:10:52,640 --> 00:10:54,480
say as for mvck

348
00:10:54,480 --> 00:10:55,680
so we are seeing on interactive

349
00:10:55,680 --> 00:10:57,120
commitments just like before and we

350
00:10:57,120 --> 00:10:59,440
obtain it around vrs protocol

351
00:10:59,440 --> 00:11:00,880
so that if the number of parties is

352
00:11:00,880 --> 00:11:02,320
constant we obtain the optimal

353
00:11:02,320 --> 00:11:05,040
resiliency and otherwise we obtain a

354
00:11:05,040 --> 00:11:06,880
almost optimal residency

355
00:11:06,880 --> 00:11:08,800
okay so those are the results regarding

356
00:11:08,800 --> 00:11:10,160
vrs

357
00:11:10,160 --> 00:11:12,720
and let me mention some applications

358
00:11:12,720 --> 00:11:14,880
so in a follow-up work again with benny

359
00:11:14,880 --> 00:11:17,200
and alpita

360
00:11:17,200 --> 00:11:19,519
we show that we can use the vls protocol

361
00:11:19,519 --> 00:11:21,279
in order to obtain a roundabout a

362
00:11:21,279 --> 00:11:23,040
multi-party computation for miniature

363
00:11:23,040 --> 00:11:24,480
type assumptions

364
00:11:24,480 --> 00:11:26,560
so we show we constructed rearranged

365
00:11:26,560 --> 00:11:28,240
majority protocol that provides full

366
00:11:28,240 --> 00:11:30,640
security and we use the same assumptions

367
00:11:30,640 --> 00:11:32,560
that we use for the vls

368
00:11:32,560 --> 00:11:34,399
and the previous works require public

369
00:11:34,399 --> 00:11:36,160
encryption and the non-interactive zero

370
00:11:36,160 --> 00:11:38,000
knowledge

371
00:11:38,000 --> 00:11:39,600
now there are more applications i do

372
00:11:39,600 --> 00:11:42,480
want to mention that the vrs turns out

373
00:11:42,480 --> 00:11:44,000
to be equivalent to single input

374
00:11:44,000 --> 00:11:45,760
functionalities so those are

375
00:11:45,760 --> 00:11:47,360
functionalities that receive the input

376
00:11:47,360 --> 00:11:49,279
from a single party and then give output

377
00:11:49,279 --> 00:11:51,519
all the parties and one can show that

378
00:11:51,519 --> 00:11:53,279
this to our equivalent

379
00:11:53,279 --> 00:11:55,680
and so another way to think of a result

380
00:11:55,680 --> 00:11:56,720
is that

381
00:11:56,720 --> 00:11:59,200
every single input functionality

382
00:11:59,200 --> 00:12:01,600
can be implemented in two rounds

383
00:12:01,600 --> 00:12:04,160
with full security and for many clip

384
00:12:04,160 --> 00:12:06,160
type assumptions okay so those are the

385
00:12:06,160 --> 00:12:08,800
application applications of mpdk

386
00:12:08,800 --> 00:12:11,120
and now it presents about a represent

387
00:12:11,120 --> 00:12:13,200
part of the proof idea in a simplified

388
00:12:13,200 --> 00:12:14,800
way so i'm making it a strong

389
00:12:14,800 --> 00:12:16,480
simplifying assumption and they assume

390
00:12:16,480 --> 00:12:19,600
that they have nice verifiable signature

391
00:12:19,600 --> 00:12:21,120
so what does it mean i assume that i

392
00:12:21,120 --> 00:12:22,639
have this magic box for really fab and

393
00:12:22,639 --> 00:12:25,600
secret sharing that receives the

394
00:12:25,600 --> 00:12:27,600
secret s from the proverb

395
00:12:27,600 --> 00:12:29,760
it then generates your meal shares of

396
00:12:29,760 --> 00:12:31,440
the shelves that are publicly committed

397
00:12:31,440 --> 00:12:33,120
okay so the functionality samples a

398
00:12:33,120 --> 00:12:34,360
random degree

399
00:12:34,360 --> 00:12:36,480
typography coefficient is the secret

400
00:12:36,480 --> 00:12:39,760
just like in a chameleon and commits to

401
00:12:39,760 --> 00:12:41,760
the chamill shells

402
00:12:41,760 --> 00:12:43,760
and then it gives every verifier an

403
00:12:43,760 --> 00:12:46,240
opening to exactly one commitment okay

404
00:12:46,240 --> 00:12:48,800
so now every verifier knows exactly one

405
00:12:48,800 --> 00:12:49,680
shell

406
00:12:49,680 --> 00:12:50,839
of the secret

407
00:12:50,839 --> 00:12:53,519
s and just like in general secret

408
00:12:53,519 --> 00:12:55,040
sharing you can show the tip nails have

409
00:12:55,040 --> 00:12:56,480
no information about the secret but

410
00:12:56,480 --> 00:12:59,519
thickness one can recover the secret

411
00:12:59,519 --> 00:13:01,120
and i am using the aromamorphic

412
00:13:01,120 --> 00:13:02,480
commitments

413
00:13:02,480 --> 00:13:04,560
which means that this is a secret chain

414
00:13:04,560 --> 00:13:06,079
excuse

415
00:13:06,079 --> 00:13:07,920
and i also want you to notice that the

416
00:13:07,920 --> 00:13:09,839
developers because i'm using commitments

417
00:13:09,839 --> 00:13:11,440
then the verifiers can either open the

418
00:13:11,440 --> 00:13:13,760
correct shell or open in erasure because

419
00:13:13,760 --> 00:13:15,360
their commitments are binding so this

420
00:13:15,360 --> 00:13:17,440
will be important later and finally the

421
00:13:17,440 --> 00:13:19,279
main point is of course that the output

422
00:13:19,279 --> 00:13:22,320
is one found even for a corrupt proverb

423
00:13:22,320 --> 00:13:24,079
okay so this is my simplifying

424
00:13:24,079 --> 00:13:25,680
assumption i assume that they have this

425
00:13:25,680 --> 00:13:27,279
magic box and they assume that they have

426
00:13:27,279 --> 00:13:29,440
homomorphic commitments but of course in

427
00:13:29,440 --> 00:13:31,839
the paper we cannot implement this magic

428
00:13:31,839 --> 00:13:33,360
box in one round and of course the

429
00:13:33,360 --> 00:13:35,279
non-interactive commitments do not are

430
00:13:35,279 --> 00:13:37,760
usually not a homomorphic so we cannot

431
00:13:37,760 --> 00:13:40,000
assume that and much of the technical

432
00:13:40,000 --> 00:13:42,320
meetings in our paper actually devoted

433
00:13:42,320 --> 00:13:43,680
in order to get rid of these two

434
00:13:43,680 --> 00:13:45,519
assumptions okay so making this a

435
00:13:45,519 --> 00:13:48,639
simplifying consumption just for lister

436
00:13:48,639 --> 00:13:50,079
okay now i will show you the health of

437
00:13:50,079 --> 00:13:52,000
the construction which is a protocol for

438
00:13:52,000 --> 00:13:54,000
a triple secret sharing

439
00:13:54,000 --> 00:13:55,680
so this is just a special case of the

440
00:13:55,680 --> 00:13:57,279
refinement secret sharing where the

441
00:13:57,279 --> 00:13:58,959
prover wants to share the tripling a b

442
00:13:58,959 --> 00:14:01,440
and c and also to prove that c is equal

443
00:14:01,440 --> 00:14:03,600
to a b

444
00:14:03,600 --> 00:14:05,279
so formally the approval inputs a clip

445
00:14:05,279 --> 00:14:08,480
and and if c is equal to a b then this

446
00:14:08,480 --> 00:14:10,399
the functionality should generate shells

447
00:14:10,399 --> 00:14:13,040
of a of b and of c by using the same sql

448
00:14:13,040 --> 00:14:16,000
sharing scheme that i've just described

449
00:14:16,000 --> 00:14:18,720
and otherwise if c is not equal to a b

450
00:14:18,720 --> 00:14:20,160
then the verifier should know that the

451
00:14:20,160 --> 00:14:22,079
approval try to cheat okay so this is

452
00:14:22,079 --> 00:14:23,519
the functionality that i want to

453
00:14:23,519 --> 00:14:25,600
implement and i want to a protocol that

454
00:14:25,600 --> 00:14:27,279
implements this functionality in two

455
00:14:27,279 --> 00:14:28,959
rounds

456
00:14:28,959 --> 00:14:30,560
okay so i will start by describing the

457
00:14:30,560 --> 00:14:31,920
three-one protocol and then i will

458
00:14:31,920 --> 00:14:34,000
explain how to reduce one round

459
00:14:34,000 --> 00:14:35,760
so in the first round

460
00:14:35,760 --> 00:14:37,680
the proverb picks random polynomials of

461
00:14:37,680 --> 00:14:39,839
x and v-fx

462
00:14:39,839 --> 00:14:41,839
and they also compute c of x which is f

463
00:14:41,839 --> 00:14:44,240
x and b of times v of x so the definite

464
00:14:44,240 --> 00:14:46,720
coefficient of f of x is the

465
00:14:46,720 --> 00:14:49,120
is the value a the coefficient of b of x

466
00:14:49,120 --> 00:14:50,959
is b and therefore the free coefficient

467
00:14:50,959 --> 00:14:52,480
of c f x is c

468
00:14:52,480 --> 00:14:54,800
and the approval shares the coefficients

469
00:14:54,800 --> 00:14:56,720
of those polynomials

470
00:14:56,720 --> 00:14:58,959
by using the magic box okay so at the

471
00:14:58,959 --> 00:15:00,480
end of the round

472
00:15:00,480 --> 00:15:02,560
on the very first shell for every

473
00:15:02,560 --> 00:15:05,680
coefficient of these polynomials

474
00:15:05,680 --> 00:15:07,839
okay so this is the first bound

475
00:15:07,839 --> 00:15:09,440
so i want you to notice that because a b

476
00:15:09,440 --> 00:15:11,279
and c are just the three coefficients of

477
00:15:11,279 --> 00:15:12,800
these polynomials then they're already

478
00:15:12,800 --> 00:15:14,480
shared and therefore it only remains to

479
00:15:14,480 --> 00:15:16,720
prove that c is equal to a b

480
00:15:16,720 --> 00:15:18,639
so in the second round they let the very

481
00:15:18,639 --> 00:15:20,480
files they broadcast random challenges

482
00:15:20,480 --> 00:15:22,079
those are just random field elements

483
00:15:22,079 --> 00:15:24,079
which are not zero so this is the second

484
00:15:24,079 --> 00:15:25,839
round of the protocol

485
00:15:25,839 --> 00:15:27,360
and in the third round of the protocol

486
00:15:27,360 --> 00:15:28,720
i'm going to very first compute the

487
00:15:28,720 --> 00:15:30,800
values of f and phi we often find c of

488
00:15:30,800 --> 00:15:32,880
and five for every challenge

489
00:15:32,880 --> 00:15:35,440
and we can do it because the afl5 for

490
00:15:35,440 --> 00:15:37,759
example is just an inner function of the

491
00:15:37,759 --> 00:15:40,000
coefficient of the polynomial affects

492
00:15:40,000 --> 00:15:41,600
okay because we have an inner sequel

493
00:15:41,600 --> 00:15:43,600
challenge scheme the verifiers can

494
00:15:43,600 --> 00:15:45,199
compute those commitments to the shell

495
00:15:45,199 --> 00:15:47,440
so far from phi and now every honest

496
00:15:47,440 --> 00:15:49,839
verifier will open the correct value

497
00:15:49,839 --> 00:15:50,800
when the

498
00:15:50,800 --> 00:15:52,399
corrupt value file can either open the

499
00:15:52,399 --> 00:15:54,720
correct value or any region okay so

500
00:15:54,720 --> 00:15:56,079
because i have an honest majority this

501
00:15:56,079 --> 00:15:57,759
guarantees that they have a atmospheric

502
00:15:57,759 --> 00:15:59,519
plus one correct chance

503
00:15:59,519 --> 00:16:01,120
and like i said the co-op parties can

504
00:16:01,120 --> 00:16:02,800
either live in the collection or any

505
00:16:02,800 --> 00:16:04,399
region okay so i have enough shells to

506
00:16:04,399 --> 00:16:07,120
recover af afm fund

507
00:16:07,120 --> 00:16:08,560
so in this way we'll recover those

508
00:16:08,560 --> 00:16:11,279
values and then we verify that c of phi

509
00:16:11,279 --> 00:16:12,800
is equal to f and phi times b of

510
00:16:12,800 --> 00:16:14,079
function

511
00:16:14,079 --> 00:16:15,920
okay so this is the trion protocol you

512
00:16:15,920 --> 00:16:17,759
can see that it has this classic

513
00:16:17,759 --> 00:16:20,079
structure of zero knowledge

514
00:16:20,079 --> 00:16:22,000
where we first commit to some values

515
00:16:22,000 --> 00:16:23,440
then we challenge and then there is a

516
00:16:23,440 --> 00:16:25,680
response

517
00:16:25,680 --> 00:16:27,519
and i want you to notice that we have a

518
00:16:27,519 --> 00:16:29,680
soundness because if c of x is not equal

519
00:16:29,680 --> 00:16:31,279
to f x times p of x then we type

520
00:16:31,279 --> 00:16:33,199
probability c of front five will not be

521
00:16:33,199 --> 00:16:35,759
equal to f function times mu from

522
00:16:35,759 --> 00:16:38,240
and the reason that we have a privacy

523
00:16:38,240 --> 00:16:38,959
here

524
00:16:38,959 --> 00:16:40,880
is that the only thing that adversary

525
00:16:40,880 --> 00:16:43,680
sees is the are those points

526
00:16:43,680 --> 00:16:45,519
and those points reveal no information

527
00:16:45,519 --> 00:16:46,880
about the three coefficients if the

528
00:16:46,880 --> 00:16:48,240
degree of the polynomials is large

529
00:16:48,240 --> 00:16:50,639
enough just making sure your signature

530
00:16:50,639 --> 00:16:52,639
okay so this is our own protocol but

531
00:16:52,639 --> 00:16:54,560
like i said we wanted a two on protocol

532
00:16:54,560 --> 00:16:56,560
so some of you might ask why not use the

533
00:16:56,560 --> 00:16:58,320
fiatum heuristic

534
00:16:58,320 --> 00:17:00,480
and the reason is that i want

535
00:17:00,480 --> 00:17:02,160
to obtain a protocol for minicrypt type

536
00:17:02,160 --> 00:17:03,440
assumptions so we don't want to use the

537
00:17:03,440 --> 00:17:05,039
future heuristic

538
00:17:05,039 --> 00:17:06,319
but having shown that if we have an

539
00:17:06,319 --> 00:17:07,760
honest majority then we actually have a

540
00:17:07,760 --> 00:17:08,959
substitute

541
00:17:08,959 --> 00:17:11,280
for the fiatum heuristic okay so you

542
00:17:11,280 --> 00:17:13,199
know it is a naive approach let's let's

543
00:17:13,199 --> 00:17:14,959
try to generate the challenges at the

544
00:17:14,959 --> 00:17:16,480
same time that the proverb picks the

545
00:17:16,480 --> 00:17:19,119
poem and surface v of x and c of x so

546
00:17:19,119 --> 00:17:21,199
let's try this protocol but it turns out

547
00:17:21,199 --> 00:17:22,720
this protocol is not secure and the

548
00:17:22,720 --> 00:17:24,959
problem is with the russian adversary

549
00:17:24,959 --> 00:17:26,880
so a russian adversary is an adversary

550
00:17:26,880 --> 00:17:29,360
that can first see the messages from the

551
00:17:29,360 --> 00:17:30,880
honest parties and only then send the

552
00:17:30,880 --> 00:17:33,120
messages of the co-op parties

553
00:17:33,120 --> 00:17:35,120
so if the approval is corrupt and

554
00:17:35,120 --> 00:17:36,960
blushing then you can first see the

555
00:17:36,960 --> 00:17:38,880
challenges of the honest parties and

556
00:17:38,880 --> 00:17:41,280
only then pick those polynomials

557
00:17:41,280 --> 00:17:42,799
and this means that you can cheat okay

558
00:17:42,799 --> 00:17:44,160
we will have problem

559
00:17:44,160 --> 00:17:46,880
with the soundness so this protocol is

560
00:17:46,880 --> 00:17:48,160
not secure

561
00:17:48,160 --> 00:17:49,600
but what we will do is actually to

562
00:17:49,600 --> 00:17:51,200
generate the challenges there already in

563
00:17:51,200 --> 00:17:53,120
the first round but in a secret way so

564
00:17:53,120 --> 00:17:54,640
that the approval will not know at least

565
00:17:54,640 --> 00:17:56,080
the one challenge

566
00:17:56,080 --> 00:17:57,280
and then we will use the fact that we

567
00:17:57,280 --> 00:17:58,640
have an honest majority and that the

568
00:17:58,640 --> 00:18:00,400
very files can answer the challenges by

569
00:18:00,400 --> 00:18:02,000
themselves

570
00:18:02,000 --> 00:18:03,919
okay so let's start with the toy version

571
00:18:03,919 --> 00:18:05,760
in which the identity of the co-op

572
00:18:05,760 --> 00:18:07,280
parties is known okay so those are the

573
00:18:07,280 --> 00:18:08,960
very honest value files and they know

574
00:18:08,960 --> 00:18:11,039
that these two are corrupt so just like

575
00:18:11,039 --> 00:18:12,799
before in the first round the pro will

576
00:18:12,799 --> 00:18:14,799
generate generates affects vfx and cfx

577
00:18:14,799 --> 00:18:16,400
and now we also let the honest value

578
00:18:16,400 --> 00:18:18,559
files to generate a secret challenge so

579
00:18:18,559 --> 00:18:20,080
some of one of the very first pixel

580
00:18:20,080 --> 00:18:22,720
random field element and sends it to the

581
00:18:22,720 --> 00:18:24,400
honest value files by using the secure

582
00:18:24,400 --> 00:18:26,240
channels so the adversary has no

583
00:18:26,240 --> 00:18:27,760
information about this challenge alpha

584
00:18:27,760 --> 00:18:29,120
and therefore it is independent of the

585
00:18:29,120 --> 00:18:31,840
polynomials

586
00:18:31,919 --> 00:18:33,840
and in the second round i just select

587
00:18:33,840 --> 00:18:35,520
every honest verifier to reveal its

588
00:18:35,520 --> 00:18:37,440
shells of error function b of function c

589
00:18:37,440 --> 00:18:38,720
or function

590
00:18:38,720 --> 00:18:39,840
okay and because they have an honest

591
00:18:39,840 --> 00:18:41,360
majority i'm guaranteed to have at least

592
00:18:41,360 --> 00:18:43,200
three plus one shells

593
00:18:43,200 --> 00:18:45,120
and therefore we can recover the values

594
00:18:45,120 --> 00:18:46,799
of the airfarm forbidden from fancy

595
00:18:46,799 --> 00:18:48,640
falcified verify that c of alpha is

596
00:18:48,640 --> 00:18:50,880
equal to f alpha times p of five okay so

597
00:18:50,880 --> 00:18:53,039
this toy version is secure

598
00:18:53,039 --> 00:18:54,720
but of course we don't know the identity

599
00:18:54,720 --> 00:18:57,840
of the corrupt parties

600
00:18:58,160 --> 00:19:00,240
so what we do is to consider every set s

601
00:19:00,240 --> 00:19:02,480
of t plus one parties

602
00:19:02,480 --> 00:19:04,960
okay so we consider every such set and

603
00:19:04,960 --> 00:19:06,720
for every such set

604
00:19:06,720 --> 00:19:08,480
in the first time we generate a secret

605
00:19:08,480 --> 00:19:10,400
challenge on forest

606
00:19:10,400 --> 00:19:12,799
and in the second round we require from

607
00:19:12,799 --> 00:19:15,039
the parties to open the shells of

608
00:19:15,039 --> 00:19:16,880
airfarm facebook face and seal from face

609
00:19:16,880 --> 00:19:18,799
just like we did in the toy belgium now

610
00:19:18,799 --> 00:19:20,960
of course most of the sets contain a

611
00:19:20,960 --> 00:19:23,440
corrupt party so they can sabotage each

612
00:19:23,440 --> 00:19:25,200
of these sounds but we are guaranteed

613
00:19:25,200 --> 00:19:26,640
that at least one set contains only

614
00:19:26,640 --> 00:19:28,720
honest parties from which

615
00:19:28,720 --> 00:19:30,400
these two rounds will be executed just

616
00:19:30,400 --> 00:19:32,240
like in the two version and therefore we

617
00:19:32,240 --> 00:19:34,160
have sounds okay so this is the main

618
00:19:34,160 --> 00:19:35,840
idea behind the two on the flipping

619
00:19:35,840 --> 00:19:36,840
secret

620
00:19:36,840 --> 00:19:39,919
sharing now i do want you to notice that

621
00:19:39,919 --> 00:19:42,400
the number of sets is exponential in the

622
00:19:42,400 --> 00:19:43,760
number of parties and therefore this

623
00:19:43,760 --> 00:19:45,679
protocol is only secure for a small

624
00:19:45,679 --> 00:19:47,440
number of parties

625
00:19:47,440 --> 00:19:49,520
i will not be able to talk about the vrs

626
00:19:49,520 --> 00:19:51,600
for many parties but i do want to

627
00:19:51,600 --> 00:19:53,039
mention that we combine two known

628
00:19:53,039 --> 00:19:55,280
techniques from the literature of mpc

629
00:19:55,280 --> 00:19:57,120
and zero knowledge

630
00:19:57,120 --> 00:19:59,200
so we combine mpc in the ed with

631
00:19:59,200 --> 00:20:00,720
virtualization and we show a new

632
00:20:00,720 --> 00:20:03,200
distributed version of mpc india

633
00:20:03,200 --> 00:20:05,039
and we also use virtualization in a

634
00:20:05,039 --> 00:20:06,640
non-preserving way which means that we

635
00:20:06,640 --> 00:20:08,080
take the ferrous for a small number of

636
00:20:08,080 --> 00:20:10,080
parties and we transform it into a vls

637
00:20:10,080 --> 00:20:11,919
for many parties with the same one

638
00:20:11,919 --> 00:20:14,080
complexity as the original protocol and

639
00:20:14,080 --> 00:20:16,159
this is not trivial because usually

640
00:20:16,159 --> 00:20:17,760
virtualization in cures and our drove

641
00:20:17,760 --> 00:20:20,559
the red in the wrong complexity

642
00:20:20,559 --> 00:20:22,159
so let me summarize there we've seen

643
00:20:22,159 --> 00:20:23,840
very fabulous english and sharing in the

644
00:20:23,840 --> 00:20:25,919
monkey very fair zero knowledge we said

645
00:20:25,919 --> 00:20:27,520
that if we have an honest majority then

646
00:20:27,520 --> 00:20:29,440
there exists two on protocol for many

647
00:20:29,440 --> 00:20:31,120
type assumptions and even with this nice

648
00:20:31,120 --> 00:20:33,360
feature of offline online round

649
00:20:33,360 --> 00:20:35,039
we've discussed everlasting security

650
00:20:35,039 --> 00:20:36,799
that we can get from a statistically

651
00:20:36,799 --> 00:20:38,320
hiding commitments

652
00:20:38,320 --> 00:20:40,400
what i didn't talk about is how to get

653
00:20:40,400 --> 00:20:42,400
rid of the simplifying assumptions that

654
00:20:42,400 --> 00:20:43,440
i've made

655
00:20:43,440 --> 00:20:45,280
so in the paper we show protocols that

656
00:20:45,280 --> 00:20:46,720
they provide around deficient in our

657
00:20:46,720 --> 00:20:48,000
operations of the nanomorphic

658
00:20:48,000 --> 00:20:49,440
commitments and they didn't talk about

659
00:20:49,440 --> 00:20:51,600
vls for many parties and there are

660
00:20:51,600 --> 00:20:53,679
several open questions can we get

661
00:20:53,679 --> 00:20:55,679
optimal resiliency for many parties and

662
00:20:55,679 --> 00:20:57,919
can we relax the requirements can we get

663
00:20:57,919 --> 00:20:59,679
rid of the sub-exponential harness and

664
00:20:59,679 --> 00:21:01,600
can we get everlasting security without

665
00:21:01,600 --> 00:21:03,280
the crs and maybe even for money

666
00:21:03,280 --> 00:21:04,400
functions

667
00:21:04,400 --> 00:21:07,760
okay so that's it thank you

668
00:21:12,400 --> 00:21:15,200
thanks thanks for the talking iran

669
00:21:15,200 --> 00:21:18,480
there questions from the audience

670
00:21:18,480 --> 00:21:20,640
um i have one

671
00:21:20,640 --> 00:21:22,320
um maybe while the next speaker is

672
00:21:22,320 --> 00:21:23,760
setting up

673
00:21:23,760 --> 00:21:25,840
um so if you

674
00:21:25,840 --> 00:21:27,120
since you're using broadcast and test

675
00:21:27,120 --> 00:21:28,559
communication also from the verifies to

676
00:21:28,559 --> 00:21:30,720
the approver for the mvck

677
00:21:30,720 --> 00:21:33,600
um can you actually distinguish between

678
00:21:33,600 --> 00:21:34,960
the prover

679
00:21:34,960 --> 00:21:36,480
doing something wrong or some of the

680
00:21:36,480 --> 00:21:38,720
verifiers interfering with the proof

681
00:21:38,720 --> 00:21:42,240
so some kind of identifiability

682
00:21:43,840 --> 00:21:45,760
so no we we have a guaranteed output

683
00:21:45,760 --> 00:21:47,600
delivery so if the approval is honest we

684
00:21:47,600 --> 00:21:49,280
are guaranteed that only the honest

685
00:21:49,280 --> 00:21:50,720
value files will receive the correct

686
00:21:50,720 --> 00:21:52,320
jail so we know that the statement is

687
00:21:52,320 --> 00:21:53,600
true

688
00:21:53,600 --> 00:21:56,240
but uh i mean the approval can do some

689
00:21:56,240 --> 00:21:58,480
wrong things in the protocol but we are

690
00:21:58,480 --> 00:21:59,919
guaranteed that the output will be one

691
00:21:59,919 --> 00:22:01,679
form either the statement is stored it

692
00:22:01,679 --> 00:22:04,080
will be rejected

693
00:22:04,080 --> 00:22:05,200
okay

694
00:22:05,200 --> 00:22:08,880
um other more questions

695
00:22:10,000 --> 00:22:13,039
otherwise let's thank the speaker again

696
00:22:13,039 --> 00:22:15,360
thanks

697
00:22:16,000 --> 00:22:18,720
and the last talk of the session will be

698
00:22:18,720 --> 00:22:20,240
about authenticated gobbling from simple

699
00:22:20,240 --> 00:22:21,600
correlations

700
00:22:21,600 --> 00:22:24,880
by uh samuel dietmer yuvali shy steve

701
00:22:24,880 --> 00:22:28,080
liu and rafa ostrovsky

702
00:22:28,880 --> 00:22:30,480
and

703
00:22:30,480 --> 00:22:34,280
sam will give the talk

704
00:22:56,000 --> 00:22:59,000
um

705
00:23:43,279 --> 00:23:46,279
um

706
00:24:03,120 --> 00:24:05,360
my mic is working and this is in

707
00:24:05,360 --> 00:24:06,480
garbling

708
00:24:06,480 --> 00:24:08,880
from simple correlations

709
00:24:08,880 --> 00:24:10,880
uh

710
00:24:10,880 --> 00:24:11,840
our

711
00:24:11,840 --> 00:24:14,480
goal in this work is concretely

712
00:24:14,480 --> 00:24:16,080
efficient constant round malicious

713
00:24:16,080 --> 00:24:18,799
two-party computation uh built off of

714
00:24:18,799 --> 00:24:20,240
graveled circuits

715
00:24:20,240 --> 00:24:22,000
and we make significant improvements

716
00:24:22,000 --> 00:24:24,000
over the state-of-the-art work based on

717
00:24:24,000 --> 00:24:25,679
authenticated garbling

718
00:24:25,679 --> 00:24:26,559
using

719
00:24:26,559 --> 00:24:28,559
what we call simple kinds of correlated

720
00:24:28,559 --> 00:24:31,520
randomness this means stuff that can be

721
00:24:31,520 --> 00:24:33,200
silently generated with sublinear

722
00:24:33,200 --> 00:24:35,279
communication and concrete efficiency

723
00:24:35,279 --> 00:24:36,080
and

724
00:24:36,080 --> 00:24:38,400
my goals for this talk is to explain

725
00:24:38,400 --> 00:24:40,080
something about why you should care

726
00:24:40,080 --> 00:24:41,679
about this and then something about the

727
00:24:41,679 --> 00:24:42,640
fun

728
00:24:42,640 --> 00:24:44,640
degree nitty gritty details about how it

729
00:24:44,640 --> 00:24:47,840
actually works in that order

730
00:24:47,840 --> 00:24:50,159
but we're going to begin with just plain

731
00:24:50,159 --> 00:24:53,039
old garbled circuits

732
00:24:53,039 --> 00:24:53,760
so

733
00:24:53,760 --> 00:24:55,360
in a garbled circuit

734
00:24:55,360 --> 00:24:56,559
the

735
00:24:56,559 --> 00:24:59,919
plain text wires wa wb and that and

736
00:24:59,919 --> 00:25:03,520
together to form wc are garbled so that

737
00:25:03,520 --> 00:25:06,720
there are wire labels l a zero la1 for

738
00:25:06,720 --> 00:25:09,919
each wire and then a masked bit lambda

739
00:25:09,919 --> 00:25:12,080
unknown to the evaluator so the

740
00:25:12,080 --> 00:25:14,559
evaluator is going to learn this xor of

741
00:25:14,559 --> 00:25:17,039
the true wire value with lambda for

742
00:25:17,039 --> 00:25:18,400
every wire

743
00:25:18,400 --> 00:25:20,159
and the corresponding wider label so you

744
00:25:20,159 --> 00:25:21,840
get the first wire label from an

745
00:25:21,840 --> 00:25:23,279
oblivious transfer

746
00:25:23,279 --> 00:25:25,200
and then from there on out you have this

747
00:25:25,200 --> 00:25:27,360
garbled table which is

748
00:25:27,360 --> 00:25:29,919
uh too small to include on this slide to

749
00:25:29,919 --> 00:25:33,360
get to the next wire value

750
00:25:33,679 --> 00:25:35,120
there has been a lot of progress over

751
00:25:35,120 --> 00:25:36,799
the years on making garbled tables more

752
00:25:36,799 --> 00:25:38,320
efficient

753
00:25:38,320 --> 00:25:39,039
so

754
00:25:39,039 --> 00:25:40,720
there's initially four ciphertext per

755
00:25:40,720 --> 00:25:43,279
gate one per row of the truth table so

756
00:25:43,279 --> 00:25:44,640
they got down to three by making the

757
00:25:44,640 --> 00:25:46,640
first row free

758
00:25:46,640 --> 00:25:47,520
then

759
00:25:47,520 --> 00:25:49,279
you got rid of the xor gates made those

760
00:25:49,279 --> 00:25:51,440
three and then the work the half gates

761
00:25:51,440 --> 00:25:52,880
of zahora it all gives you two

762
00:25:52,880 --> 00:25:55,600
ciphertexts per gate and then i will

763
00:25:55,600 --> 00:25:56,400
mention

764
00:25:56,400 --> 00:25:58,320
this most recent work by ross luke and

765
00:25:58,320 --> 00:26:00,400
roy from last year that gets you down to

766
00:26:00,400 --> 00:26:02,960
1.5 ciphertext so they are still making

767
00:26:02,960 --> 00:26:04,880
progress in this area but our work is

768
00:26:04,880 --> 00:26:06,240
sort of orthogonal to this because

769
00:26:06,240 --> 00:26:08,000
instead of dealing with improving the

770
00:26:08,000 --> 00:26:10,720
semi honest garbling we're interested in

771
00:26:10,720 --> 00:26:12,880
making efficient malicious garbling off

772
00:26:12,880 --> 00:26:15,919
of something on a scarblone

773
00:26:16,880 --> 00:26:18,960
so the reason why malicious garbling is

774
00:26:18,960 --> 00:26:21,039
hard is because in the semi honest

775
00:26:21,039 --> 00:26:22,640
version one party does almost all of the

776
00:26:22,640 --> 00:26:24,320
work they build the garbage circuit from

777
00:26:24,320 --> 00:26:26,080
scratch and so there's a lot of room to

778
00:26:26,080 --> 00:26:27,120
cheat

779
00:26:27,120 --> 00:26:28,799
you can sort of encode any logic you

780
00:26:28,799 --> 00:26:31,120
want into the garble table you can mess

781
00:26:31,120 --> 00:26:32,240
it up in all sorts of ways so the

782
00:26:32,240 --> 00:26:33,440
initial work

783
00:26:33,440 --> 00:26:37,279
to make this secure was to

784
00:26:37,360 --> 00:26:40,000
do a cut and choose kind of technique so

785
00:26:40,000 --> 00:26:42,080
the

786
00:26:42,080 --> 00:26:43,440
garbler generates a whole bunch of

787
00:26:43,440 --> 00:26:44,880
copies of the circuit and the evaluator

788
00:26:44,880 --> 00:26:46,240
gets to open certain ones and check that

789
00:26:46,240 --> 00:26:47,520
they're actually done correctly and then

790
00:26:47,520 --> 00:26:49,279
use the remainder to actually evaluate

791
00:26:49,279 --> 00:26:51,120
the circuit

792
00:26:51,120 --> 00:26:52,480
so

793
00:26:52,480 --> 00:26:54,320
this was gone down to an efficiency of

794
00:26:54,320 --> 00:26:56,720
you know rho times the number of garbled

795
00:26:56,720 --> 00:26:58,559
circuits or row copies of the garble

796
00:26:58,559 --> 00:27:00,400
circuit so with row equals 40 that's 40

797
00:27:00,400 --> 00:27:02,640
times something honest version

798
00:27:02,640 --> 00:27:05,200
and i want to also mention that

799
00:27:05,200 --> 00:27:06,799
later works were also able to make this

800
00:27:06,799 --> 00:27:09,840
protocol non-interactive

801
00:27:10,159 --> 00:27:11,600
so there was a substantial improvement

802
00:27:11,600 --> 00:27:14,080
over those prior works from

803
00:27:14,080 --> 00:27:15,520
weighing it all and later extended by

804
00:27:15,520 --> 00:27:16,960
capstadal

805
00:27:16,960 --> 00:27:18,640
in something called authenticated

806
00:27:18,640 --> 00:27:20,799
garbling and so

807
00:27:20,799 --> 00:27:22,399
the way to think about this is you start

808
00:27:22,399 --> 00:27:24,559
with a garbled circuit and you have some

809
00:27:24,559 --> 00:27:26,320
sort of ot based tool for wire

810
00:27:26,320 --> 00:27:27,840
authentication which gives you constant

811
00:27:27,840 --> 00:27:29,120
round motion secure two-party

812
00:27:29,120 --> 00:27:30,480
computation

813
00:27:30,480 --> 00:27:32,559
and to give some concrete numbers the

814
00:27:32,559 --> 00:27:34,720
cats are the weighing at all protocol

815
00:27:34,720 --> 00:27:36,720
which is built off of free xor

816
00:27:36,720 --> 00:27:38,559
requires only 11 times the cost of semi

817
00:27:38,559 --> 00:27:40,320
honest and

818
00:27:40,320 --> 00:27:42,799
cat said all requires uh about eight

819
00:27:42,799 --> 00:27:44,240
times the cost of stemming on us using

820
00:27:44,240 --> 00:27:46,960
the half gates

821
00:27:46,960 --> 00:27:49,679
and what we do again at a very high

822
00:27:49,679 --> 00:27:52,080
level is we take that ot based machinery

823
00:27:52,080 --> 00:27:53,440
for wire authentication and we swap it

824
00:27:53,440 --> 00:27:54,960
out with what we call simple

825
00:27:54,960 --> 00:27:57,600
correlations

826
00:27:59,360 --> 00:28:00,480
and

827
00:28:00,480 --> 00:28:02,240
i am going to break one of the

828
00:28:02,240 --> 00:28:03,760
fundamental rules of giving a talk and

829
00:28:03,760 --> 00:28:04,960
introduce a whole bunch of notation here

830
00:28:04,960 --> 00:28:06,720
that i'm not going to explain because i

831
00:28:06,720 --> 00:28:08,320
will explain it later but i want to sort

832
00:28:08,320 --> 00:28:10,399
of give some numbers about what's going

833
00:28:10,399 --> 00:28:11,440
on

834
00:28:11,440 --> 00:28:12,240
so

835
00:28:12,240 --> 00:28:13,600
uh

836
00:28:13,600 --> 00:28:15,200
we have our construction which also

837
00:28:15,200 --> 00:28:17,200
works with uh the free xor construction

838
00:28:17,200 --> 00:28:18,559
and the half cake construction although

839
00:28:18,559 --> 00:28:20,960
it does not work with the new slice and

840
00:28:20,960 --> 00:28:22,799
dice techniques so that's sort of

841
00:28:22,799 --> 00:28:24,240
an interesting question we haven't

842
00:28:24,240 --> 00:28:25,919
looked into much yet

843
00:28:25,919 --> 00:28:27,120
uh but

844
00:28:27,120 --> 00:28:28,240
using

845
00:28:28,240 --> 00:28:29,760
those boxes indicate different flavors

846
00:28:29,760 --> 00:28:30,960
of correlated randomness which we'll

847
00:28:30,960 --> 00:28:32,799
describe more but we get down to in the

848
00:28:32,799 --> 00:28:35,919
neighborhood of uh 1.3 or 2.3 times the

849
00:28:35,919 --> 00:28:38,000
cost of a summing on a circuit

850
00:28:38,000 --> 00:28:39,679
and also

851
00:28:39,679 --> 00:28:42,240
using ole randomness we can get down to

852
00:28:42,240 --> 00:28:43,760
eight times the cost of seminars for

853
00:28:43,760 --> 00:28:46,879
non-interactive communication

854
00:28:47,679 --> 00:28:48,480
so

855
00:28:48,480 --> 00:28:50,880
uh this completes the

856
00:28:50,880 --> 00:28:52,480
very short version of the talk so i will

857
00:28:52,480 --> 00:28:53,760
proceed with another copy of the talk

858
00:28:53,760 --> 00:28:55,039
that is longer

859
00:28:55,039 --> 00:28:56,640
and we're gonna start with

860
00:28:56,640 --> 00:28:57,679
talking about what authenticated

861
00:28:57,679 --> 00:28:59,600
garbling is in some detail

862
00:28:59,600 --> 00:29:02,159
and then give you sort of a blueprint

863
00:29:02,159 --> 00:29:05,120
for how all of these constructions work

864
00:29:05,120 --> 00:29:06,240
then

865
00:29:06,240 --> 00:29:08,080
talk about where the simple correlations

866
00:29:08,080 --> 00:29:09,679
actually fit into everything so that's

867
00:29:09,679 --> 00:29:11,679
sort of coming down the road and then

868
00:29:11,679 --> 00:29:13,600
finally we get our hands dirty with just

869
00:29:13,600 --> 00:29:15,360
some of the nitty-gritty stuff which is

870
00:29:15,360 --> 00:29:18,000
hopefully fun

871
00:29:18,559 --> 00:29:19,440
so

872
00:29:19,440 --> 00:29:21,919
back to a semi-honest garbage circuit

873
00:29:21,919 --> 00:29:24,159
this is a way to write the garbled table

874
00:29:24,159 --> 00:29:25,600
so on the right

875
00:29:25,600 --> 00:29:27,039
uh the thing to notice there is that if

876
00:29:27,039 --> 00:29:29,360
you have exactly one of the la values

877
00:29:29,360 --> 00:29:31,679
and one of the lb values

878
00:29:31,679 --> 00:29:33,440
then by

879
00:29:33,440 --> 00:29:36,000
xoring out that hash function you can

880
00:29:36,000 --> 00:29:38,000
open one row

881
00:29:38,000 --> 00:29:40,880
and then recall that uh the lambda

882
00:29:40,880 --> 00:29:44,240
values are the uh

883
00:29:44,240 --> 00:29:46,240
the masks of the wire

884
00:29:46,240 --> 00:29:49,760
and the z values are the

885
00:29:49,760 --> 00:29:53,279
masked values so what the evaluator sees

886
00:29:53,279 --> 00:29:55,760
and so you can just sort of check that

887
00:29:55,760 --> 00:29:57,760
what the event what the true value

888
00:29:57,760 --> 00:29:59,200
should be the

889
00:29:59,200 --> 00:30:02,000
masked value xord with the mask

890
00:30:02,000 --> 00:30:05,679
and that so z 0 0 for example xor with

891
00:30:05,679 --> 00:30:07,520
lambda c should be the true value and

892
00:30:07,520 --> 00:30:09,120
then

893
00:30:09,120 --> 00:30:11,360
lambda a and lambda b should be the true

894
00:30:11,360 --> 00:30:12,640
value if

895
00:30:12,640 --> 00:30:14,480
both of your mass of both of your masked

896
00:30:14,480 --> 00:30:16,480
bits are zero so that's what it looks

897
00:30:16,480 --> 00:30:19,760
like in semi honest land uh also the

898
00:30:19,760 --> 00:30:22,720
horizontal lines are knots which have

899
00:30:22,720 --> 00:30:24,240
moved around on the page so that's

900
00:30:24,240 --> 00:30:25,919
unfortunate but

901
00:30:25,919 --> 00:30:27,840
adds to the fun

902
00:30:27,840 --> 00:30:31,039
um oh this has also moved around so

903
00:30:31,039 --> 00:30:33,039
uh not to scale

904
00:30:33,039 --> 00:30:36,000
on the graph uh

905
00:30:36,000 --> 00:30:37,120
that

906
00:30:37,120 --> 00:30:39,200
that's right that's right garbled slides

907
00:30:39,200 --> 00:30:40,080
so

908
00:30:40,080 --> 00:30:41,520
it's it's a talk mixed with a stand-up

909
00:30:41,520 --> 00:30:42,720
routine guys

910
00:30:42,720 --> 00:30:45,039
um

911
00:30:45,039 --> 00:30:46,640
so

912
00:30:46,640 --> 00:30:48,000
as we've said before the reason

913
00:30:48,000 --> 00:30:49,600
malicious garbling is tricky is because

914
00:30:49,600 --> 00:30:51,440
the gobbler can cheat and just encode

915
00:30:51,440 --> 00:30:52,559
whatever logic they want they can

916
00:30:52,559 --> 00:30:54,720
replace all of these vijays with just

917
00:30:54,720 --> 00:30:57,039
zero zero across the board and then they

918
00:30:57,039 --> 00:30:58,159
can like you know mess with the output

919
00:30:58,159 --> 00:30:59,840
in all sorts of annoying ways

920
00:30:59,840 --> 00:31:00,960
so

921
00:31:00,960 --> 00:31:02,399
one way to fix this which is what

922
00:31:02,399 --> 00:31:03,919
authenticated garbling does is you add

923
00:31:03,919 --> 00:31:05,679
some sort of uh message authentication

924
00:31:05,679 --> 00:31:08,240
code you add like a mac on top of this

925
00:31:08,240 --> 00:31:10,720
uh so that when you open your particular

926
00:31:10,720 --> 00:31:12,880
row you get proof that that row was

927
00:31:12,880 --> 00:31:14,320
garbled correctly

928
00:31:14,320 --> 00:31:16,080
but this introduces a new problem

929
00:31:16,080 --> 00:31:17,440
because now you allow selective a

930
00:31:17,440 --> 00:31:18,720
failure attacks

931
00:31:18,720 --> 00:31:22,799
what this means is that if a just just

932
00:31:22,799 --> 00:31:25,279
uh misgarbles one of the rows

933
00:31:25,279 --> 00:31:26,799
then a is going to learn if you went to

934
00:31:26,799 --> 00:31:28,159
that row

935
00:31:28,159 --> 00:31:29,519
because you're going to abort when you

936
00:31:29,519 --> 00:31:33,200
hit that misgarbled value and so

937
00:31:33,200 --> 00:31:35,039
uh a is gonna learn at least one bit of

938
00:31:35,039 --> 00:31:37,440
your input

939
00:31:37,600 --> 00:31:40,000
so the trick to

940
00:31:40,000 --> 00:31:42,000
blocking this attack is that these

941
00:31:42,000 --> 00:31:44,840
lambda values are now secret

942
00:31:44,840 --> 00:31:46,880
shared among

943
00:31:46,880 --> 00:31:50,000
uh both parties so that both parties

944
00:31:50,000 --> 00:31:51,600
have no idea which row the table

945
00:31:51,600 --> 00:31:53,279
corresponds to which entry

946
00:31:53,279 --> 00:31:56,080
and so that way uh a learns nothing even

947
00:31:56,080 --> 00:31:57,600
if you do abort because

948
00:31:57,600 --> 00:31:59,279
from a's perspective all rows are

949
00:31:59,279 --> 00:32:01,600
identical so if if they burn a row

950
00:32:01,600 --> 00:32:02,880
they're just making the table worse but

951
00:32:02,880 --> 00:32:04,640
not in a way that's going to indicate

952
00:32:04,640 --> 00:32:06,240
anything about b's input

953
00:32:06,240 --> 00:32:08,080
and then the authentication

954
00:32:08,080 --> 00:32:09,679
you have these you know the lambda a

955
00:32:09,679 --> 00:32:11,919
lambda b lambda c values

956
00:32:11,919 --> 00:32:14,320
and if you have additionally lambda a

957
00:32:14,320 --> 00:32:15,679
and lambda b

958
00:32:15,679 --> 00:32:17,120
and authenticated shares of all these

959
00:32:17,120 --> 00:32:20,000
things then together with those values

960
00:32:20,000 --> 00:32:23,360
you can uh you know generate max for

961
00:32:23,360 --> 00:32:25,918
all the rows

962
00:32:26,000 --> 00:32:29,679
so that was an overview of sort of

963
00:32:29,679 --> 00:32:31,120
how the construction works as

964
00:32:31,120 --> 00:32:32,640
understanding going from garbling into

965
00:32:32,640 --> 00:32:34,640
authenticated garbling we're now going

966
00:32:34,640 --> 00:32:37,200
to describe the construction going

967
00:32:37,200 --> 00:32:39,279
uh sort of from low level details up to

968
00:32:39,279 --> 00:32:41,360
garbling uh the following is a terrible

969
00:32:41,360 --> 00:32:45,600
joke i liked this the clip art but uh

970
00:32:45,600 --> 00:32:47,519
it's not a work in progress it is

971
00:32:47,519 --> 00:32:49,279
construction to follow so it's not under

972
00:32:49,279 --> 00:32:50,960
construction it's under

973
00:32:50,960 --> 00:32:52,320
construction

974
00:32:52,320 --> 00:32:54,640
uh this this bad joke inspired by a

975
00:32:54,640 --> 00:32:58,480
jeffrey tambour movie um

976
00:32:58,480 --> 00:33:00,559
so the overall blueprint going from low

977
00:33:00,559 --> 00:33:01,760
level to high level we're going to start

978
00:33:01,760 --> 00:33:03,600
with authenticating bits

979
00:33:03,600 --> 00:33:04,880
and then we're going to authenticate a

980
00:33:04,880 --> 00:33:06,320
very simple kind of circuit a bunch of

981
00:33:06,320 --> 00:33:08,159
parallel and gates

982
00:33:08,159 --> 00:33:09,840
and then we're gonna authenticate

983
00:33:09,840 --> 00:33:11,600
general circus and then go back to

984
00:33:11,600 --> 00:33:14,240
authenticated garbling

985
00:33:14,240 --> 00:33:16,240
so when you authenticate bits

986
00:33:16,240 --> 00:33:17,440
back to our pretty picture of an and

987
00:33:17,440 --> 00:33:18,320
gate

988
00:33:18,320 --> 00:33:19,679
uh

989
00:33:19,679 --> 00:33:22,080
which and luckily the the values are

990
00:33:22,080 --> 00:33:23,519
close to where they're supposed to be

991
00:33:23,519 --> 00:33:26,559
now so we're happy um

992
00:33:26,559 --> 00:33:28,799
you want to authenticate each mask

993
00:33:28,799 --> 00:33:31,600
uh lambda and i've been throwing around

994
00:33:31,600 --> 00:33:32,799
the word authenticated shares and what

995
00:33:32,799 --> 00:33:34,240
we mean specifically is you want shares

996
00:33:34,240 --> 00:33:35,919
of the of the mass of lambda and the

997
00:33:35,919 --> 00:33:37,840
shares of alpha lambda and beta lambda

998
00:33:37,840 --> 00:33:39,679
where alpha is known to a and beta is

999
00:33:39,679 --> 00:33:40,640
known to b

1000
00:33:40,640 --> 00:33:42,559
this means basically you convince can

1001
00:33:42,559 --> 00:33:44,399
convince both a and b of whatever you

1002
00:33:44,399 --> 00:33:45,919
want to about what you're doing with the

1003
00:33:45,919 --> 00:33:48,320
masks

1004
00:33:48,960 --> 00:33:51,120
now for authenticated parallel and you

1005
00:33:51,120 --> 00:33:52,960
have this

1006
00:33:52,960 --> 00:33:54,559
very specialized circuit which is just a

1007
00:33:54,559 --> 00:33:56,320
bunch of and gates in a row

1008
00:33:56,320 --> 00:33:58,880
and so you want these authenticated

1009
00:33:58,880 --> 00:34:00,320
shares of the

1010
00:34:00,320 --> 00:34:02,799
lambda a and lambda b terms but you

1011
00:34:02,799 --> 00:34:05,039
restrict to this case where

1012
00:34:05,039 --> 00:34:08,639
uh you know exactly which aibi

1013
00:34:08,639 --> 00:34:11,199
you know a1 b1 a2 b2 and so on and

1014
00:34:11,199 --> 00:34:12,399
there's no interaction between any of

1015
00:34:12,399 --> 00:34:14,480
the wires still

1016
00:34:14,480 --> 00:34:16,239
this is the most expensive part of the

1017
00:34:16,239 --> 00:34:18,320
construction and

1018
00:34:18,320 --> 00:34:19,440
i mentioned earlier that there are three

1019
00:34:19,440 --> 00:34:20,879
constructions we're not going to

1020
00:34:20,879 --> 00:34:23,760
describe them all in great detail but i

1021
00:34:23,760 --> 00:34:24,639
will say that the way you do

1022
00:34:24,639 --> 00:34:26,000
authenticated parallel and at each of

1023
00:34:26,000 --> 00:34:27,520
the constructions is different and uses

1024
00:34:27,520 --> 00:34:30,159
different randomness

1025
00:34:30,159 --> 00:34:31,760
but once you have the authenticated

1026
00:34:31,760 --> 00:34:33,679
parallel and then you want to compile

1027
00:34:33,679 --> 00:34:35,520
that to authenticated wires and

1028
00:34:35,520 --> 00:34:38,000
authenticated you know and values for

1029
00:34:38,000 --> 00:34:39,918
every for every gate in your real

1030
00:34:39,918 --> 00:34:43,199
circuit so you know now for example wg

1031
00:34:43,199 --> 00:34:44,879
is the end of wc and wf which is

1032
00:34:44,879 --> 00:34:47,119
previously x sort of other values so

1033
00:34:47,119 --> 00:34:48,399
there's so you have to make this sort of

1034
00:34:48,399 --> 00:34:49,839
circuit dependent so you're going to

1035
00:34:49,839 --> 00:34:52,239
require more communication but this is

1036
00:34:52,239 --> 00:34:54,159
actually relatively cheap compared to

1037
00:34:54,159 --> 00:34:55,599
the previous slide once you have the

1038
00:34:55,599 --> 00:34:58,560
parallel hand in place

1039
00:34:59,119 --> 00:35:00,000
and

1040
00:35:00,000 --> 00:35:01,920
once you have all of that you now have

1041
00:35:01,920 --> 00:35:03,680
the authentication of your lambda values

1042
00:35:03,680 --> 00:35:05,599
and we now have a new a new garbled

1043
00:35:05,599 --> 00:35:06,720
slide

1044
00:35:06,720 --> 00:35:08,079
uh so

1045
00:35:08,079 --> 00:35:09,599
neither you nor i can read what this

1046
00:35:09,599 --> 00:35:10,880
says but

1047
00:35:10,880 --> 00:35:13,520
uh all we've changed from the previous

1048
00:35:13,520 --> 00:35:15,280
authenticated the previous semi honest

1049
00:35:15,280 --> 00:35:16,720
garbling is that on the second in the

1050
00:35:16,720 --> 00:35:18,720
garbled table column we've changed the

1051
00:35:18,720 --> 00:35:20,960
zij into sij

1052
00:35:20,960 --> 00:35:23,440
which is a concatenation of

1053
00:35:23,440 --> 00:35:27,599
a's share of zij with a share of beta

1054
00:35:27,599 --> 00:35:29,119
times the ij

1055
00:35:29,119 --> 00:35:30,960
so when

1056
00:35:30,960 --> 00:35:33,359
uh b opens up the row they're going to

1057
00:35:33,359 --> 00:35:34,160
see

1058
00:35:34,160 --> 00:35:36,240
the value z their share of the values

1059
00:35:36,240 --> 00:35:38,400
eij so they can reconstruct zij i think

1060
00:35:38,400 --> 00:35:41,680
i'll also reconstruct beta times the iga

1061
00:35:41,680 --> 00:35:43,040
a doesn't have beta so there's no way

1062
00:35:43,040 --> 00:35:45,280
that ada can so there's no way that a

1063
00:35:45,280 --> 00:35:46,800
can cheat on this authentication without

1064
00:35:46,800 --> 00:35:48,800
knowing beta

1065
00:35:48,800 --> 00:35:50,880
or second ballpoint says there are other

1066
00:35:50,880 --> 00:35:52,240
ways of doing this you can also just

1067
00:35:52,240 --> 00:35:54,480
open the value zij and now authenticate

1068
00:35:54,480 --> 00:35:56,400
till the very end

1069
00:35:56,400 --> 00:35:57,680
because

1070
00:35:57,680 --> 00:36:00,079
once the circuit is done evaluating

1071
00:36:00,079 --> 00:36:02,000
it can't abort anymore so there can't be

1072
00:36:02,000 --> 00:36:03,839
any more selected failure attacks so at

1073
00:36:03,839 --> 00:36:05,520
that point there's no harm in b telling

1074
00:36:05,520 --> 00:36:07,440
a what path they went through

1075
00:36:07,440 --> 00:36:11,160
and then a authenticated

1076
00:36:12,079 --> 00:36:12,960
now

1077
00:36:12,960 --> 00:36:14,960
the talk is titled authenticated garbly

1078
00:36:14,960 --> 00:36:16,640
from simple correlations so i want to

1079
00:36:16,640 --> 00:36:18,640
explain what you can get away with if

1080
00:36:18,640 --> 00:36:20,000
you just sort of allow any correlation

1081
00:36:20,000 --> 00:36:21,280
you want

1082
00:36:21,280 --> 00:36:22,720
so first of all we started with

1083
00:36:22,720 --> 00:36:23,839
authenticated bits and then went to

1084
00:36:23,839 --> 00:36:25,359
authenticated parallel and gates and as

1085
00:36:25,359 --> 00:36:27,040
i said that step was hard

1086
00:36:27,040 --> 00:36:30,240
so you can just skip to that step

1087
00:36:30,240 --> 00:36:32,079
and just generate authenticated parallel

1088
00:36:32,079 --> 00:36:33,680
angles from scratch wouldn't that be

1089
00:36:33,680 --> 00:36:34,800
nice

1090
00:36:34,800 --> 00:36:37,680
well while we're dreaming uh

1091
00:36:37,680 --> 00:36:39,119
garbled circuits are a kind of

1092
00:36:39,119 --> 00:36:41,040
randomness so you could have a

1093
00:36:41,040 --> 00:36:43,359
pseudo-randomness correlation generator

1094
00:36:43,359 --> 00:36:45,680
that just generates garbled circuit and

1095
00:36:45,680 --> 00:36:47,760
also generates you know the

1096
00:36:47,760 --> 00:36:49,119
initial input wires with an

1097
00:36:49,119 --> 00:36:51,119
authentication point of that and then

1098
00:36:51,119 --> 00:36:53,520
you have great communication but

1099
00:36:53,520 --> 00:36:54,880
none of this exists

1100
00:36:54,880 --> 00:36:56,320
or we don't know how to do it

1101
00:36:56,320 --> 00:36:58,880
efficiently and so

1102
00:36:58,880 --> 00:37:00,880
kind of this is where the work lies is

1103
00:37:00,880 --> 00:37:02,640
this is what would be perfect but how do

1104
00:37:02,640 --> 00:37:04,079
we get from what we actually have to

1105
00:37:04,079 --> 00:37:06,560
something like this

1106
00:37:06,560 --> 00:37:08,880
so we have simple correlations instead

1107
00:37:08,880 --> 00:37:10,320
and let me sort of spell out what we do

1108
00:37:10,320 --> 00:37:11,839
have we have basically two kinds of

1109
00:37:11,839 --> 00:37:14,079
randomness we have vector oblivious

1110
00:37:14,079 --> 00:37:16,640
linear evaluation or vol which has been

1111
00:37:16,640 --> 00:37:17,920
studied a great deal in the last five

1112
00:37:17,920 --> 00:37:20,160
years where you take a scalar times a

1113
00:37:20,160 --> 00:37:22,720
vector and you share it

1114
00:37:22,720 --> 00:37:24,320
and then you also have multiplication

1115
00:37:24,320 --> 00:37:25,920
triple type randomness

1116
00:37:25,920 --> 00:37:27,359
multiplication triple type randomness is

1117
00:37:27,359 --> 00:37:29,200
of course not new it goes back to like

1118
00:37:29,200 --> 00:37:32,079
gmw kinds of constructions and beavers

1119
00:37:32,079 --> 00:37:34,880
beaver triples but only recently have we

1120
00:37:34,880 --> 00:37:36,480
been able to generate it concretely

1121
00:37:36,480 --> 00:37:40,000
efficiently using this ring lpn work

1122
00:37:40,000 --> 00:37:42,720
and i'm just going to mention briefly

1123
00:37:42,720 --> 00:37:44,480
that all of these simple correlations

1124
00:37:44,480 --> 00:37:47,040
can sort of be made modular

1125
00:37:47,040 --> 00:37:48,640
you can think of them as using sort of

1126
00:37:48,640 --> 00:37:51,839
correlation calculus which

1127
00:37:51,839 --> 00:37:52,880
allows you to generate a bunch of

1128
00:37:52,880 --> 00:37:55,200
variants of volt type and empty type for

1129
00:37:55,200 --> 00:37:56,240
the constructions that we're going to

1130
00:37:56,240 --> 00:37:58,479
need

1131
00:37:59,520 --> 00:38:00,240
so

1132
00:38:00,240 --> 00:38:02,320
having now given the brief overview of

1133
00:38:02,320 --> 00:38:04,160
what we're doing i'm going to try to get

1134
00:38:04,160 --> 00:38:05,839
into the fun details

1135
00:38:05,839 --> 00:38:08,560
uh there is luckily no joke associated

1136
00:38:08,560 --> 00:38:09,920
with this slide

1137
00:38:09,920 --> 00:38:12,560
but uh i'm going to talk about

1138
00:38:12,560 --> 00:38:14,400
the second construction which is a

1139
00:38:14,400 --> 00:38:16,880
construction that uses uh vector ole

1140
00:38:16,880 --> 00:38:18,560
only to build a uh

1141
00:38:18,560 --> 00:38:21,920
authentication authenticating garbling

1142
00:38:21,920 --> 00:38:23,680
so recall step one is we need

1143
00:38:23,680 --> 00:38:25,760
authenticated share bits and the happy

1144
00:38:25,760 --> 00:38:27,680
news is we get this for free

1145
00:38:27,680 --> 00:38:29,280
basically so

1146
00:38:29,280 --> 00:38:32,320
we need the wire masks lambda

1147
00:38:32,320 --> 00:38:34,079
and we need that the wire mask to be

1148
00:38:34,079 --> 00:38:35,839
shared so we have a vector a held by a

1149
00:38:35,839 --> 00:38:37,680
and a vector b held by b

1150
00:38:37,680 --> 00:38:40,079
so using vector ole

1151
00:38:40,079 --> 00:38:41,760
you can just share

1152
00:38:41,760 --> 00:38:44,640
alpha times b and beta times a

1153
00:38:44,640 --> 00:38:47,680
and now you want shares of alpha times

1154
00:38:47,680 --> 00:38:50,160
lambda so if you take

1155
00:38:50,160 --> 00:38:52,640
a share of alpha times b which they know

1156
00:38:52,640 --> 00:38:54,640
and then alpha times a which they know

1157
00:38:54,640 --> 00:38:56,560
because they know a and they know alpha

1158
00:38:56,560 --> 00:38:58,320
and then b share of alpha times b and

1159
00:38:58,320 --> 00:38:59,520
add it together you get alpha times

1160
00:38:59,520 --> 00:39:01,599
lambda and similarly you now have shares

1161
00:39:01,599 --> 00:39:03,839
of beta times lambda

1162
00:39:03,839 --> 00:39:06,880
and i'll point out here that you want

1163
00:39:06,880 --> 00:39:09,599
a and b to be randomly generated from f2

1164
00:39:09,599 --> 00:39:11,599
but you want the sharing to be over f 2

1165
00:39:11,599 --> 00:39:13,520
to the row or f 2 to the kappa so either

1166
00:39:13,520 --> 00:39:15,280
the statistical or computational

1167
00:39:15,280 --> 00:39:17,200
security parameter so here we're not

1168
00:39:17,200 --> 00:39:18,640
technically using the mole we're using

1169
00:39:18,640 --> 00:39:20,560
subfield volt where

1170
00:39:20,560 --> 00:39:22,320
the vector comes from a subfield of

1171
00:39:22,320 --> 00:39:24,960
where the shares are located at

1172
00:39:24,960 --> 00:39:27,040
and i'll also point out that this is

1173
00:39:27,040 --> 00:39:28,560
sort of what you do for

1174
00:39:28,560 --> 00:39:30,800
every construction is some kind of vole

1175
00:39:30,800 --> 00:39:32,800
magic to sort of get your authenticated

1176
00:39:32,800 --> 00:39:35,200
bits for free

1177
00:39:35,200 --> 00:39:37,520
now authenticated parallel and as i said

1178
00:39:37,520 --> 00:39:39,920
earlier is where it gets tricky

1179
00:39:39,920 --> 00:39:41,040
uh

1180
00:39:41,040 --> 00:39:41,760
so

1181
00:39:41,760 --> 00:39:44,800
the top is some good old classic uh

1182
00:39:44,800 --> 00:39:46,560
distributive property

1183
00:39:46,560 --> 00:39:48,720
if you expand out what lambda i and

1184
00:39:48,720 --> 00:39:49,920
lambda j is which we need to

1185
00:39:49,920 --> 00:39:51,839
authenticate and share

1186
00:39:51,839 --> 00:39:53,599
and we have basically three kinds of

1187
00:39:53,599 --> 00:39:54,720
terms

1188
00:39:54,720 --> 00:39:58,720
ai and a j b i n b j a i and b j so a i

1189
00:39:58,720 --> 00:40:00,960
and a j and b i and b j are basically

1190
00:40:00,960 --> 00:40:02,000
the same

1191
00:40:02,000 --> 00:40:03,040
and

1192
00:40:03,040 --> 00:40:05,280
these are both doable with one new kind

1193
00:40:05,280 --> 00:40:06,480
of machinery that i'm going to throw out

1194
00:40:06,480 --> 00:40:08,960
at the last second so line point zero

1195
00:40:08,960 --> 00:40:12,880
knowledge uh lpzk is one of a family of

1196
00:40:12,880 --> 00:40:15,359
volvo based zero knowledge proofs

1197
00:40:15,359 --> 00:40:17,280
and one of the things that makes these

1198
00:40:17,280 --> 00:40:19,760
things nice is that since they're

1199
00:40:19,760 --> 00:40:21,680
already based on vol they give a very

1200
00:40:21,680 --> 00:40:23,839
natural way to prove things about vole

1201
00:40:23,839 --> 00:40:26,480
so you can prove any relation you want

1202
00:40:26,480 --> 00:40:28,560
on the entries of all and if that

1203
00:40:28,560 --> 00:40:32,079
relation is a load low depth for example

1204
00:40:32,079 --> 00:40:33,920
a bunch of quadratics you can do it

1205
00:40:33,920 --> 00:40:35,520
basically for free

1206
00:40:35,520 --> 00:40:37,839
so

1207
00:40:37,839 --> 00:40:40,079
in addition to the vector beta times a

1208
00:40:40,079 --> 00:40:41,839
you have you also include all the values

1209
00:40:41,839 --> 00:40:43,760
a i and a j

1210
00:40:43,760 --> 00:40:44,720
and

1211
00:40:44,720 --> 00:40:46,560
you can sort of authenticate that those

1212
00:40:46,560 --> 00:40:48,560
satisfy the product relations you want

1213
00:40:48,560 --> 00:40:51,520
for free however you still have the ai

1214
00:40:51,520 --> 00:40:54,000
and bj terms and those you do not get

1215
00:40:54,000 --> 00:40:55,040
for free

1216
00:40:55,040 --> 00:40:59,040
so those are going to require more work

1217
00:40:59,200 --> 00:41:01,440
so we have an idea

1218
00:41:01,440 --> 00:41:03,280
with a question mark which is a spoiler

1219
00:41:03,280 --> 00:41:06,000
for how well this idea is going to work

1220
00:41:06,000 --> 00:41:06,880
so

1221
00:41:06,880 --> 00:41:10,160
uh you want a i and bj times beta

1222
00:41:10,160 --> 00:41:12,319
so you can write it in that form

1223
00:41:12,319 --> 00:41:14,240
and then

1224
00:41:14,240 --> 00:41:18,079
look if so if you take beta bj as your

1225
00:41:18,079 --> 00:41:21,119
scalar in your vol then beta bj is your

1226
00:41:21,119 --> 00:41:23,760
scalar a is a vector and voila you have

1227
00:41:23,760 --> 00:41:26,640
shares of a i times beta bj and you can

1228
00:41:26,640 --> 00:41:27,920
read off all the terms you want for all

1229
00:41:27,920 --> 00:41:29,440
your different and gates

1230
00:41:29,440 --> 00:41:31,680
so

1231
00:41:31,839 --> 00:41:33,200
the nice so i mentioned the little

1232
00:41:33,200 --> 00:41:34,640
correlation calculus that allows you to

1233
00:41:34,640 --> 00:41:35,920
generate a whole bunch of flavors of

1234
00:41:35,920 --> 00:41:38,160
vole this is a flavor called blockable

1235
00:41:38,160 --> 00:41:39,920
and what's nice is we can reuse the

1236
00:41:39,920 --> 00:41:42,000
vector a for free so we don't have to

1237
00:41:42,000 --> 00:41:43,760
send a for all these different instances

1238
00:41:43,760 --> 00:41:45,520
of bowls so that's great

1239
00:41:45,520 --> 00:41:46,880
but

1240
00:41:46,880 --> 00:41:48,400
you may notice that we're doing this for

1241
00:41:48,400 --> 00:41:50,400
every single and gate so we need an

1242
00:41:50,400 --> 00:41:51,760
instance of volt for every single and

1243
00:41:51,760 --> 00:41:54,079
gate so it kind of kills the point of

1244
00:41:54,079 --> 00:41:56,079
having sublinear communication

1245
00:41:56,079 --> 00:41:57,839
per vole when you have a linear numbers

1246
00:41:57,839 --> 00:42:01,440
of mole so this is no good

1247
00:42:01,680 --> 00:42:03,839
so

1248
00:42:04,400 --> 00:42:06,240
okay this slide is mostly readable it's

1249
00:42:06,240 --> 00:42:08,640
great uh so here is the exciting trick

1250
00:42:08,640 --> 00:42:11,119
we do so we want a vector b of wire

1251
00:42:11,119 --> 00:42:12,160
labels

1252
00:42:12,160 --> 00:42:14,400
and we're instead going to generate a

1253
00:42:14,400 --> 00:42:17,599
short vector of that beta star beta star

1254
00:42:17,599 --> 00:42:19,200
one up to beta star l

1255
00:42:19,200 --> 00:42:20,079
and

1256
00:42:20,079 --> 00:42:22,319
expand it with a random matrix

1257
00:42:22,319 --> 00:42:25,680
into a longer vector b star

1258
00:42:25,680 --> 00:42:26,960
so we just take some random linear

1259
00:42:26,960 --> 00:42:28,240
transformation and apply it to the short

1260
00:42:28,240 --> 00:42:30,079
vector

1261
00:42:30,079 --> 00:42:31,520
why do we do this

1262
00:42:31,520 --> 00:42:33,520
well

1263
00:42:33,520 --> 00:42:35,200
every ai and

1264
00:42:35,200 --> 00:42:36,880
bj star term

1265
00:42:36,880 --> 00:42:39,599
so the bj is some matrix times beta so

1266
00:42:39,599 --> 00:42:42,000
it's just a linear combination of terms

1267
00:42:42,000 --> 00:42:43,280
beta star

1268
00:42:43,280 --> 00:42:46,560
so we have a list of ai beta star terms

1269
00:42:46,560 --> 00:42:48,160
to get you each

1270
00:42:48,160 --> 00:42:49,839
you know cross term we need

1271
00:42:49,839 --> 00:42:52,160
and since we only have

1272
00:42:52,160 --> 00:42:54,240
l of them which is a relatively small

1273
00:42:54,240 --> 00:42:55,200
number

1274
00:42:55,200 --> 00:42:57,040
we only need a handful of instances of

1275
00:42:57,040 --> 00:42:58,720
bowl now instead of you know an instance

1276
00:42:58,720 --> 00:43:00,400
of the bowl

1277
00:43:00,400 --> 00:43:02,880
however we just sort of you know cheated

1278
00:43:02,880 --> 00:43:05,280
really badly because

1279
00:43:05,280 --> 00:43:07,119
we used to have n separate bits of

1280
00:43:07,119 --> 00:43:08,880
randomness guarding b's input and now we

1281
00:43:08,880 --> 00:43:11,359
just have log n so

1282
00:43:11,359 --> 00:43:12,880
uh

1283
00:43:12,880 --> 00:43:15,200
how do we get away with that

1284
00:43:15,200 --> 00:43:16,319
we have a whole bunch of relations now

1285
00:43:16,319 --> 00:43:17,760
on the wire labels

1286
00:43:17,760 --> 00:43:19,520
and um

1287
00:43:19,520 --> 00:43:21,200
if we want to be precise and linear

1288
00:43:21,200 --> 00:43:22,800
algebra about it

1289
00:43:22,800 --> 00:43:26,160
for every vector in the co kernel of r

1290
00:43:26,160 --> 00:43:28,400
which is large because it's an n by log

1291
00:43:28,400 --> 00:43:29,760
n matrix

1292
00:43:29,760 --> 00:43:31,119
there's some linear combination of wire

1293
00:43:31,119 --> 00:43:33,599
masks where you have you know v t

1294
00:43:33,599 --> 00:43:35,119
yeah you check the linear algebra vt

1295
00:43:35,119 --> 00:43:37,680
lambda equals v ta plus vtr beta star

1296
00:43:37,680 --> 00:43:40,400
and vt is in the co kernel of r

1297
00:43:40,400 --> 00:43:41,440
so

1298
00:43:41,440 --> 00:43:42,400
uh

1299
00:43:42,400 --> 00:43:44,319
a knows vt lambda

1300
00:43:44,319 --> 00:43:46,480
so a knows a ton of information about

1301
00:43:46,480 --> 00:43:49,839
what's going on in the garbled table

1302
00:43:49,839 --> 00:43:52,160
but remember the reason we cared about a

1303
00:43:52,160 --> 00:43:53,839
uh knowing stuff was because of

1304
00:43:53,839 --> 00:43:56,240
selective failure attacks so

1305
00:43:56,240 --> 00:43:58,880
it is a sort of combinatorial fact you

1306
00:43:58,880 --> 00:44:01,520
can prove with some fancy machinery like

1307
00:44:01,520 --> 00:44:03,680
sterling's formula and

1308
00:44:03,680 --> 00:44:04,960
i think there's a

1309
00:44:04,960 --> 00:44:07,599
markov bound in there or something that

1310
00:44:07,599 --> 00:44:08,480
uh

1311
00:44:08,480 --> 00:44:10,240
when you have

1312
00:44:10,240 --> 00:44:11,040
uh

1313
00:44:11,040 --> 00:44:13,839
what row log n independent columns then

1314
00:44:13,839 --> 00:44:15,520
you're gonna have

1315
00:44:15,520 --> 00:44:16,880
anything in the code kernel has at least

1316
00:44:16,880 --> 00:44:19,520
uh row non-zero entries

1317
00:44:19,520 --> 00:44:23,040
so this means you need at least row row

1318
00:44:23,040 --> 00:44:24,319
labels before you get a linear

1319
00:44:24,319 --> 00:44:25,520
relationship

1320
00:44:25,520 --> 00:44:26,319
so

1321
00:44:26,319 --> 00:44:28,160
if you want to use a selective failure

1322
00:44:28,160 --> 00:44:30,240
attack on something where a actually

1323
00:44:30,240 --> 00:44:31,760
knows the masks

1324
00:44:31,760 --> 00:44:35,200
then a has to corrupt at least row table

1325
00:44:35,200 --> 00:44:37,839
entries in order to get any information

1326
00:44:37,839 --> 00:44:40,400
but if a corrupts row table entries

1327
00:44:40,400 --> 00:44:42,079
then there is a

1328
00:44:42,079 --> 00:44:44,319
uh one minus two to the negative row

1329
00:44:44,319 --> 00:44:47,440
probability that you abort so

1330
00:44:47,440 --> 00:44:48,720
b is it's going to all of the board so

1331
00:44:48,720 --> 00:44:51,839
you still don't get any information

1332
00:44:52,079 --> 00:44:53,520
and so

1333
00:44:53,520 --> 00:44:55,680
uh either a corrupts a few table entries

1334
00:44:55,680 --> 00:44:57,520
and it and it still looks independent or

1335
00:44:57,520 --> 00:44:59,520
a corrupts a lot of table entries

1336
00:44:59,520 --> 00:45:00,960
and you just always important so you

1337
00:45:00,960 --> 00:45:04,240
still get no information

1338
00:45:04,240 --> 00:45:05,440
uh

1339
00:45:05,440 --> 00:45:06,960
i want to

1340
00:45:06,960 --> 00:45:09,280
uh semi-close with this lovely quote by

1341
00:45:09,280 --> 00:45:10,640
mr fermah

1342
00:45:10,640 --> 00:45:13,920
and throw a whole bunch of other things

1343
00:45:13,920 --> 00:45:15,280
that we did not have time to get to in

1344
00:45:15,280 --> 00:45:16,240
this talk

1345
00:45:16,240 --> 00:45:17,280
uh

1346
00:45:17,280 --> 00:45:18,960
so the first construction that actually

1347
00:45:18,960 --> 00:45:20,800
gets our fastest number uses mt type

1348
00:45:20,800 --> 00:45:22,000
randomness

1349
00:45:22,000 --> 00:45:24,319
uh to build the parallel and gates

1350
00:45:24,319 --> 00:45:26,160
uh when we do nisk we can't have any

1351
00:45:26,160 --> 00:45:28,160
back and forth so we do this we can't

1352
00:45:28,160 --> 00:45:30,400
have a vole in both directions so we

1353
00:45:30,400 --> 00:45:33,680
have to use ole

1354
00:45:33,680 --> 00:45:34,720
we have a bunch of different flavors of

1355
00:45:34,720 --> 00:45:37,119
randomness when you use like an alpha in

1356
00:45:37,119 --> 00:45:38,400
one randomness and another randomness

1357
00:45:38,400 --> 00:45:39,280
you have to check that it's the same

1358
00:45:39,280 --> 00:45:42,160
alpha this requires some algebraic

1359
00:45:42,160 --> 00:45:43,520
checking

1360
00:45:43,520 --> 00:45:45,440
uh when you do nisk you need conditional

1361
00:45:45,440 --> 00:45:48,240
to close disclosure of secrets uh

1362
00:45:48,240 --> 00:45:49,440
i didn't know what this was before i

1363
00:45:49,440 --> 00:45:50,960
wrote this paper so i thought it was a

1364
00:45:50,960 --> 00:45:52,560
fun exercise

1365
00:45:52,560 --> 00:45:54,400
to figure out how this works if that

1366
00:45:54,400 --> 00:45:56,079
sounds fun maybe it'll be a fun exercise

1367
00:45:56,079 --> 00:45:58,480
to read

1368
00:45:58,720 --> 00:46:00,560
and then there's this trick we do at

1369
00:46:00,560 --> 00:46:01,920
some point where we build the parallel

1370
00:46:01,920 --> 00:46:03,839
and gates with statistical security

1371
00:46:03,839 --> 00:46:05,359
instead of computational security which

1372
00:46:05,359 --> 00:46:07,520
costs you know a multiple of row instead

1373
00:46:07,520 --> 00:46:08,960
of kappa so save the factor of three

1374
00:46:08,960 --> 00:46:10,000
somewhere

1375
00:46:10,000 --> 00:46:12,160
and then you can cheaply go from

1376
00:46:12,160 --> 00:46:15,440
statistical to computational security

1377
00:46:15,440 --> 00:46:17,359
and additionally

1378
00:46:17,359 --> 00:46:19,839
uh in the authentication step

1379
00:46:19,839 --> 00:46:21,280
we sort of have to mix and match some of

1380
00:46:21,280 --> 00:46:22,800
the tools from weng at all and caps at

1381
00:46:22,800 --> 00:46:24,880
all because some of the tools from cats

1382
00:46:24,880 --> 00:46:26,560
that all involve communication and other

1383
00:46:26,560 --> 00:46:28,720
things so for for various reasons in

1384
00:46:28,720 --> 00:46:30,079
both the vole only construction and the

1385
00:46:30,079 --> 00:46:31,359
misconstruction

1386
00:46:31,359 --> 00:46:32,160
you

1387
00:46:32,160 --> 00:46:33,920
can't uh have this back and forth so you

1388
00:46:33,920 --> 00:46:35,599
have to have a mix of the half gates for

1389
00:46:35,599 --> 00:46:38,400
part of it and the three x or gates for

1390
00:46:38,400 --> 00:46:39,599
so basically it's a half gates for the

1391
00:46:39,599 --> 00:46:41,119
wire label and the free xor for the

1392
00:46:41,119 --> 00:46:42,800
authentication

1393
00:46:42,800 --> 00:46:45,599
and to really close i just want to

1394
00:46:45,599 --> 00:46:48,480
again put our numbers up here and now

1395
00:46:48,480 --> 00:46:50,800
that i've told you about all of this

1396
00:46:50,800 --> 00:46:53,680
vole and speeds and stuff i can give

1397
00:46:53,680 --> 00:46:55,599
the sort of apples to oranges and the

1398
00:46:55,599 --> 00:46:57,680
apples to apples comparison so at the

1399
00:46:57,680 --> 00:47:00,400
top are wang at all and cats dolls

1400
00:47:00,400 --> 00:47:03,119
work built off of ot machinery

1401
00:47:03,119 --> 00:47:05,599
and you can take vole based randomness

1402
00:47:05,599 --> 00:47:07,760
or speed style tricks

1403
00:47:07,760 --> 00:47:08,640
in

1404
00:47:08,640 --> 00:47:10,560
i guess kind of a natural way without a

1405
00:47:10,560 --> 00:47:11,839
lot of thought

1406
00:47:11,839 --> 00:47:13,680
and apply it to their work and you do

1407
00:47:13,680 --> 00:47:15,040
get improvements

1408
00:47:15,040 --> 00:47:15,839
but

1409
00:47:15,839 --> 00:47:17,440
uh and you get you know you can get down

1410
00:47:17,440 --> 00:47:20,079
to as good as 2.5 times the cost of

1411
00:47:20,079 --> 00:47:21,440
semi-honest

1412
00:47:21,440 --> 00:47:23,440
but uh using our more careful

1413
00:47:23,440 --> 00:47:25,680
constructions you can get down to

1414
00:47:25,680 --> 00:47:27,200
uh one point three times something

1415
00:47:27,200 --> 00:47:28,880
honest and

1416
00:47:28,880 --> 00:47:31,520
in the non-aircraft interactive setting

1417
00:47:31,520 --> 00:47:33,440
uh we improve on the prior work by a

1418
00:47:33,440 --> 00:47:35,200
factor of five

1419
00:47:35,200 --> 00:47:38,759
thank you for your attention

1420
00:47:42,559 --> 00:47:44,720
um thanks for the toxin are there

1421
00:47:44,720 --> 00:47:47,200
questions

1422
00:47:47,280 --> 00:47:48,480
um

1423
00:47:48,480 --> 00:47:50,480
maybe i'll torture you with one before a

1424
00:47:50,480 --> 00:47:52,000
coffee break

1425
00:47:52,000 --> 00:47:53,839
this looks nice in terms of reducing the

1426
00:47:53,839 --> 00:47:55,280
communication for everything but these

1427
00:47:55,280 --> 00:47:57,119
wall-based techniques are then a bit

1428
00:47:57,119 --> 00:47:58,960
more computationally heavy than what was

1429
00:47:58,960 --> 00:48:01,760
there before so do you have any ideas of

1430
00:48:01,760 --> 00:48:02,800
how

1431
00:48:02,800 --> 00:48:04,559
expensive this will be in comparison to

1432
00:48:04,559 --> 00:48:06,720
use something that has more

1433
00:48:06,720 --> 00:48:09,359
communication overhead yeah so uh

1434
00:48:09,359 --> 00:48:10,640
there's an estimate in the paper

1435
00:48:10,640 --> 00:48:13,839
basically built on uh

1436
00:48:13,839 --> 00:48:15,119
you know what is the published state of

1437
00:48:15,119 --> 00:48:17,119
the art for how fast volt should be and

1438
00:48:17,119 --> 00:48:18,960
how fast m multiplication triple

1439
00:48:18,960 --> 00:48:20,400
generation should be

1440
00:48:20,400 --> 00:48:22,960
and we say that if you just sort of like

1441
00:48:22,960 --> 00:48:24,640
add up the seconds to generate the

1442
00:48:24,640 --> 00:48:27,280
amount of volt or mt you need that

1443
00:48:27,280 --> 00:48:28,960
are first and third construction so the

1444
00:48:28,960 --> 00:48:30,079
mt construction and the niss

1445
00:48:30,079 --> 00:48:31,280
construction should be compatible with

1446
00:48:31,280 --> 00:48:33,040
state of the art around a million gates

1447
00:48:33,040 --> 00:48:34,559
and the vole only constructions should

1448
00:48:34,559 --> 00:48:37,440
be competitive around 10 million gates

1449
00:48:37,440 --> 00:48:38,319
so

1450
00:48:38,319 --> 00:48:40,640
um

1451
00:48:40,720 --> 00:48:42,160
okay that's the gate number so what

1452
00:48:42,160 --> 00:48:45,520
about what about like at some point

1453
00:48:45,520 --> 00:48:47,680
right if you're if your bandwidth is big

1454
00:48:47,680 --> 00:48:48,880
enough then

1455
00:48:48,880 --> 00:48:50,400
i guess the old constructions might be

1456
00:48:50,400 --> 00:48:53,359
faster or um this is only dependent on

1457
00:48:53,359 --> 00:48:54,960
the number of gates

1458
00:48:54,960 --> 00:48:56,319
uh

1459
00:48:56,319 --> 00:48:58,400
no that's fair yeah so you are dealing

1460
00:48:58,400 --> 00:48:59,200
with

1461
00:48:59,200 --> 00:49:00,480
this is optimizing communication

1462
00:49:00,480 --> 00:49:03,040
complexity so yeah so if you have you

1463
00:49:03,040 --> 00:49:05,440
know a totally local local network

1464
00:49:05,440 --> 00:49:06,880
uh then

1465
00:49:06,880 --> 00:49:08,079
you might not care as much about this

1466
00:49:08,079 --> 00:49:09,520
but so the other advantage here is that

1467
00:49:09,520 --> 00:49:10,880
it's constant round which again is an

1468
00:49:10,880 --> 00:49:12,000
advantage in

1469
00:49:12,000 --> 00:49:13,119
wide area network more than a local

1470
00:49:13,119 --> 00:49:15,040
network okay i guess implementation

1471
00:49:15,040 --> 00:49:17,599
coming soon in the next paper yes okay

1472
00:49:17,599 --> 00:49:19,440
good then uh

1473
00:49:19,440 --> 00:49:21,359
let's thanks sam and all the speakers of

1474
00:49:21,359 --> 00:49:24,000
the first session

1475
00:49:28,319 --> 00:49:31,839
and it's coffee time

