1
00:00:00,080 --> 00:00:01,760
uh aaron tromma

2
00:00:01,760 --> 00:00:05,040
and zu is going to give the talk

3
00:00:05,040 --> 00:00:05,920
um

4
00:00:05,920 --> 00:00:10,200
yeah thank you very much

5
00:00:17,199 --> 00:00:18,080
hello

6
00:00:18,080 --> 00:00:20,800
yeah hi everyone glad to be here uh so

7
00:00:20,800 --> 00:00:22,720
today uh my name is

8
00:00:22,720 --> 00:00:24,400
today i'm going to talk about oblivious

9
00:00:24,400 --> 00:00:26,160
message retrieval it's a joint work with

10
00:00:26,160 --> 00:00:28,400
iran trumper

11
00:00:28,400 --> 00:00:30,480
so let's start with the motivation so we

12
00:00:30,480 --> 00:00:32,558
have four uh anonymous message delivery

13
00:00:32,558 --> 00:00:34,800
systems we have some senders who want to

14
00:00:34,800 --> 00:00:37,520
send some payloads uh to some recipients

15
00:00:37,520 --> 00:00:38,559
uh they will

16
00:00:38,559 --> 00:00:40,239
these payloads can be text messages or

17
00:00:40,239 --> 00:00:42,320
coin transfers and they first

18
00:00:42,320 --> 00:00:43,520
send the message to some central

19
00:00:43,520 --> 00:00:45,680
database in cryptocurrency this central

20
00:00:45,680 --> 00:00:47,440
database is realized by some bulletin

21
00:00:47,440 --> 00:00:49,200
board and in apps like signal or

22
00:00:49,200 --> 00:00:51,120
whatsapp it's a central server

23
00:00:51,120 --> 00:00:53,039
then the recipient wants to retrieve the

24
00:00:53,039 --> 00:00:54,879
messages that are addressed to them

25
00:00:54,879 --> 00:00:57,120
which we call the pertinent messages

26
00:00:57,120 --> 00:00:58,559
there have been lots of work studying

27
00:00:58,559 --> 00:01:00,480
about the sending privacy and building

28
00:01:00,480 --> 00:01:02,640
board privacy but how about recipient

29
00:01:02,640 --> 00:01:04,479
privacy how can a recipient retrieve the

30
00:01:04,479 --> 00:01:06,240
message pertinent messages without

31
00:01:06,240 --> 00:01:10,560
leaking their identity or metadata

32
00:01:11,040 --> 00:01:12,880
one triple solution is that we can

33
00:01:12,880 --> 00:01:14,960
simply let the recipient download the

34
00:01:14,960 --> 00:01:16,640
whole database and distill themselves

35
00:01:16,640 --> 00:01:18,000
locally

36
00:01:18,000 --> 00:01:19,759
but this can be too expensive in both

37
00:01:19,759 --> 00:01:23,119
bandwidth and computation

38
00:01:23,600 --> 00:01:24,799
another solution is that we can

39
00:01:24,799 --> 00:01:26,560
introduce a third party which we call a

40
00:01:26,560 --> 00:01:28,799
detector this detector will hold the

41
00:01:28,799 --> 00:01:30,960
board and help the recipient to distill

42
00:01:30,960 --> 00:01:32,560
and

43
00:01:32,560 --> 00:01:34,479
compress into some digest that contains

44
00:01:34,479 --> 00:01:36,240
the pertinent messages sent back to the

45
00:01:36,240 --> 00:01:38,798
recipient

46
00:01:39,200 --> 00:01:41,920
uh in applications like uh this deal

47
00:01:41,920 --> 00:01:43,920
in applications like zcash they use

48
00:01:43,920 --> 00:01:45,920
distill for scan basically the uh

49
00:01:45,920 --> 00:01:47,920
detector tried to chop the big messages

50
00:01:47,920 --> 00:01:50,240
into smaller messages and then send

51
00:01:50,240 --> 00:01:52,479
smaller messages messages back to to the

52
00:01:52,479 --> 00:01:55,040
recipient the digest size is smaller

53
00:01:55,040 --> 00:01:57,759
than than the bulletin board but still

54
00:01:57,759 --> 00:01:59,920
it's quite large and the digest size is

55
00:01:59,920 --> 00:02:02,640
linear to end

56
00:02:03,280 --> 00:02:05,200
one prior work is called uh fuzzy

57
00:02:05,200 --> 00:02:07,759
message detection it's decoy-based so it

58
00:02:07,759 --> 00:02:10,399
has relatively weak uh privacy guarantee

59
00:02:10,399 --> 00:02:12,800
and uh also the computation and

60
00:02:12,800 --> 00:02:14,720
communication cost are dependent on the

61
00:02:14,720 --> 00:02:16,720
privacy it provides

62
00:02:16,720 --> 00:02:19,200
it also uh requires honor standards and

63
00:02:19,200 --> 00:02:21,520
recipients which will get into a little

64
00:02:21,520 --> 00:02:24,640
bit more detail later

65
00:02:24,640 --> 00:02:26,319
another relative work is called private

66
00:02:26,319 --> 00:02:28,560
signaling it has two constructions the

67
00:02:28,560 --> 00:02:30,400
first construction

68
00:02:30,400 --> 00:02:33,360
requires trusted hardware like intel sgx

69
00:02:33,360 --> 00:02:35,120
and the second construction assumes two

70
00:02:35,120 --> 00:02:37,440
communicating but not including

71
00:02:37,440 --> 00:02:39,680
servers so as you can see that both of

72
00:02:39,680 --> 00:02:41,280
the contract constructions have

73
00:02:41,280 --> 00:02:43,120
relatively strong environmental

74
00:02:43,120 --> 00:02:45,440
assumptions and they also require honest

75
00:02:45,440 --> 00:02:47,840
standards and recipients

76
00:02:47,840 --> 00:02:49,040
our results

77
00:02:49,040 --> 00:02:51,360
we have defined and uh constructed

78
00:02:51,360 --> 00:02:52,959
oblivious message retrieval and

79
00:02:52,959 --> 00:02:54,640
oblivious message detection that is

80
00:02:54,640 --> 00:02:56,720
fully private on the strong security

81
00:02:56,720 --> 00:02:58,959
notions based on fhe plus some

82
00:02:58,959 --> 00:03:01,360
application driven optimizations and

83
00:03:01,360 --> 00:03:03,040
based on our benchmark it's practical

84
00:03:03,040 --> 00:03:06,480
for bitcoin scale applications

85
00:03:07,200 --> 00:03:09,440
our schemes have a clue-based

86
00:03:09,440 --> 00:03:11,360
clue based model uh what do i mean by

87
00:03:11,360 --> 00:03:13,760
that so for some the recipients hold

88
00:03:13,760 --> 00:03:15,760
some secret keys and they use the secret

89
00:03:15,760 --> 00:03:17,760
keys to generate two public keys the

90
00:03:17,760 --> 00:03:19,519
first one is the clue key and the second

91
00:03:19,519 --> 00:03:21,360
one is the detection key the sender will

92
00:03:21,360 --> 00:03:23,280
use the clue key to generate some clue

93
00:03:23,280 --> 00:03:24,720
and then together with the payload they

94
00:03:24,720 --> 00:03:26,319
will put the clue and payload to the

95
00:03:26,319 --> 00:03:27,519
bulletin board

96
00:03:27,519 --> 00:03:28,959
and then

97
00:03:28,959 --> 00:03:30,560
the recipient will send the detection

98
00:03:30,560 --> 00:03:32,560
key to the detector the detector will

99
00:03:32,560 --> 00:03:34,879
use the bulletin board the clues and

100
00:03:34,879 --> 00:03:37,360
payloads together with the detection key

101
00:03:37,360 --> 00:03:39,599
to accumulate and get some digest send

102
00:03:39,599 --> 00:03:41,599
the digest back to the recipient and

103
00:03:41,599 --> 00:03:43,519
then the recipient will process and get

104
00:03:43,519 --> 00:03:45,440
the plaintext payroll back

105
00:03:45,440 --> 00:03:47,200
for the functionalities we call them

106
00:03:47,200 --> 00:03:49,680
oblivious master detection and oblivious

107
00:03:49,680 --> 00:03:52,319
message retrieval uh the detection means

108
00:03:52,319 --> 00:03:54,319
that only the pertinent investors will

109
00:03:54,319 --> 00:03:55,519
be sent back

110
00:03:55,519 --> 00:03:57,200
but for the retrieval the payloads will

111
00:03:57,200 --> 00:03:59,200
be sent back

112
00:03:59,200 --> 00:04:00,879
we mainly have two goals the first one

113
00:04:00,879 --> 00:04:02,799
is that we want the detector to learn

114
00:04:02,799 --> 00:04:04,480
nothing about the recipient it shouldn't

115
00:04:04,480 --> 00:04:06,239
learn which messages are pertinent and

116
00:04:06,239 --> 00:04:08,400
it shouldn't learn uh

117
00:04:08,400 --> 00:04:09,680
furthermore it shouldn't learn who is

118
00:04:09,680 --> 00:04:11,680
doing the retrieval with what keys

119
00:04:11,680 --> 00:04:12,959
our second goal is that we want the

120
00:04:12,959 --> 00:04:15,040
digest size to be much smaller than the

121
00:04:15,040 --> 00:04:16,959
bulletin size ideally it should only be

122
00:04:16,959 --> 00:04:19,199
proportional to the number of

123
00:04:19,199 --> 00:04:21,839
protein messages

124
00:04:21,839 --> 00:04:24,320
so to begin our construction uh let's

125
00:04:24,320 --> 00:04:26,479
start with the simplest one

126
00:04:26,479 --> 00:04:29,040
we begin with uh detection using generic

127
00:04:29,040 --> 00:04:32,000
fhe so now the recipient holds a feg

128
00:04:32,000 --> 00:04:35,680
secret key and an ffg public key

129
00:04:35,680 --> 00:04:37,520
the sender will use the fhe public key

130
00:04:37,520 --> 00:04:40,000
to encrypt l once

131
00:04:40,000 --> 00:04:41,759
and this allows some public parameter to

132
00:04:41,759 --> 00:04:43,520
be fixed later

133
00:04:43,520 --> 00:04:45,360
and then they will put this fh cipher

134
00:04:45,360 --> 00:04:49,040
text on the button as clues

135
00:04:49,120 --> 00:04:51,360
uh and then the detector will use the

136
00:04:51,360 --> 00:04:53,040
exact same iffy cheap

137
00:04:53,040 --> 00:04:53,840
the

138
00:04:53,840 --> 00:04:56,400
the fhe public key from the recipient uh

139
00:04:56,400 --> 00:04:58,560
to do the recruit when i say recrypt i

140
00:04:58,560 --> 00:05:00,560
basically mean that this function this

141
00:05:00,560 --> 00:05:02,639
function tries to homomorphically

142
00:05:02,639 --> 00:05:04,960
decrypt this fhe ciphertext so it's like

143
00:05:04,960 --> 00:05:06,320
bootstrapping in

144
00:05:06,320 --> 00:05:07,120
in

145
00:05:07,120 --> 00:05:09,440
more than fg schemes

146
00:05:09,440 --> 00:05:11,600
and then for the pertinent ones which

147
00:05:11,600 --> 00:05:14,479
are marked in pink

148
00:05:14,479 --> 00:05:16,320
since they are using the same fhe public

149
00:05:16,320 --> 00:05:18,960
key they will be recruited into one as

150
00:05:18,960 --> 00:05:19,759
well

151
00:05:19,759 --> 00:05:21,600
and if we use an end gate we will get

152
00:05:21,600 --> 00:05:23,199
one

153
00:05:23,199 --> 00:05:25,520
and for the important messages uh if we

154
00:05:25,520 --> 00:05:27,199
do recruit since they are using two

155
00:05:27,199 --> 00:05:28,960
different uh public keys and they are

156
00:05:28,960 --> 00:05:30,800
all independently generated uh we will

157
00:05:30,800 --> 00:05:34,240
get uh zeros with probably one over half

158
00:05:34,240 --> 00:05:36,639
oh one over two and if we use an end

159
00:05:36,639 --> 00:05:38,160
gate we will get zero with probability

160
00:05:38,160 --> 00:05:39,520
roughly one

161
00:05:39,520 --> 00:05:41,280
minus two to the negative l this is

162
00:05:41,280 --> 00:05:44,160
where l comes comes comes into play to

163
00:05:44,160 --> 00:05:46,880
reduce the false positive rate

164
00:05:46,880 --> 00:05:48,960
and then uh we call this zero and once

165
00:05:48,960 --> 00:05:51,199
uh pertinency vector they are just

166
00:05:51,199 --> 00:05:53,520
cipher text and if we send back to the

167
00:05:53,520 --> 00:05:56,319
recipient uh the recipient will use the

168
00:05:56,319 --> 00:05:57,840
secret key to decrypt and get the

169
00:05:57,840 --> 00:06:00,400
plaintext payloads

170
00:06:00,400 --> 00:06:03,360
uh as you can see that if we do this the

171
00:06:03,360 --> 00:06:05,440
digest size which is the pretensive

172
00:06:05,440 --> 00:06:08,479
vector pv is still linear again so our

173
00:06:08,479 --> 00:06:10,800
next step is how can we compress this

174
00:06:10,800 --> 00:06:13,360
communication into sublinear

175
00:06:13,360 --> 00:06:15,280
so to compress it we used a very similar

176
00:06:15,280 --> 00:06:17,120
technique as the technique introduced in

177
00:06:17,120 --> 00:06:19,280
a private stream search by ostrovsky and

178
00:06:19,280 --> 00:06:22,319
skate in zero five

179
00:06:22,319 --> 00:06:24,960
first we initialize m uh accumulators

180
00:06:24,960 --> 00:06:26,080
encounters

181
00:06:26,080 --> 00:06:28,319
uh this m is uh should be greater than

182
00:06:28,319 --> 00:06:30,960
uh the number of protein messages

183
00:06:30,960 --> 00:06:32,560
and then what we do is we simply

184
00:06:32,560 --> 00:06:35,440
multiply the indices with the pv we just

185
00:06:35,440 --> 00:06:37,600
computed from our last step

186
00:06:37,600 --> 00:06:39,360
and for the impedance messages we will

187
00:06:39,360 --> 00:06:41,199
get zeros uh and for the printed

188
00:06:41,199 --> 00:06:43,199
messages we will get fvg ciphertext

189
00:06:43,199 --> 00:06:45,840
encrypting the indices

190
00:06:45,840 --> 00:06:48,080
then we randomly assign these results

191
00:06:48,080 --> 00:06:49,599
into one of the accumulators and

192
00:06:49,599 --> 00:06:51,599
counters for the important ones the

193
00:06:51,599 --> 00:06:53,360
counters and accumulators will remain

194
00:06:53,360 --> 00:06:56,160
unchanged and for the pertinent ones the

195
00:06:56,160 --> 00:06:57,759
accumulators will be added by the

196
00:06:57,759 --> 00:06:59,199
indices and the contracts will be

197
00:06:59,199 --> 00:07:01,680
incremented by one

198
00:07:01,680 --> 00:07:03,759
so if we finish all the assignments we

199
00:07:03,759 --> 00:07:05,360
can simply send back all the

200
00:07:05,360 --> 00:07:07,120
accumulators and counters back to the

201
00:07:07,120 --> 00:07:08,960
recipient then the recipient will be

202
00:07:08,960 --> 00:07:11,759
able to decrypt and decode the pertinent

203
00:07:11,759 --> 00:07:14,319
emphasis

204
00:07:14,960 --> 00:07:17,120
uh but as you can see there's one issue

205
00:07:17,120 --> 00:07:19,199
uh there can be collisions so multiple

206
00:07:19,199 --> 00:07:21,520
persons pertinent messages can uh

207
00:07:21,520 --> 00:07:22,960
indices can be assigned to the same

208
00:07:22,960 --> 00:07:25,360
accumulator uh that's when a counter

209
00:07:25,360 --> 00:07:27,520
comes into play uh counter in that case

210
00:07:27,520 --> 00:07:29,120
will be greater than one so it can be

211
00:07:29,120 --> 00:07:30,479
easily detected

212
00:07:30,479 --> 00:07:33,039
and then after detection we can

213
00:07:33,039 --> 00:07:34,880
handle this issue by using repetition

214
00:07:34,880 --> 00:07:36,960
and deduction uh we owe me the details

215
00:07:36,960 --> 00:07:38,639
here we refer the audience to the paper

216
00:07:38,639 --> 00:07:40,800
for more details

217
00:07:40,800 --> 00:07:43,440
and our next step is to change from

218
00:07:43,440 --> 00:07:45,360
detection to retrieval actually there's

219
00:07:45,360 --> 00:07:46,960
one very trivial solution to do the

220
00:07:46,960 --> 00:07:49,120
retrieval is that if we can simply

221
00:07:49,120 --> 00:07:52,000
replace uh this column of indices with

222
00:07:52,000 --> 00:07:54,240
payloads and then we will using the

223
00:07:54,240 --> 00:07:56,080
exact same technique we'll be able to

224
00:07:56,080 --> 00:07:58,479
accomplish the retrieval uh the issue

225
00:07:58,479 --> 00:08:00,639
with that is that the hiding constant

226
00:08:00,639 --> 00:08:02,720
of this techniques is relatively high

227
00:08:02,720 --> 00:08:04,319
and also the

228
00:08:04,319 --> 00:08:06,080
we we generally assume that the payloads

229
00:08:06,080 --> 00:08:08,319
are much larger than the indices so uh

230
00:08:08,319 --> 00:08:09,919
the communication cost in this case will

231
00:08:09,919 --> 00:08:13,039
be uh much larger

232
00:08:13,039 --> 00:08:15,520
to be more efficient we propose a

233
00:08:15,520 --> 00:08:17,440
different coding technique to do the

234
00:08:17,440 --> 00:08:18,720
retrieval

235
00:08:18,720 --> 00:08:21,199
so first as before we compute the

236
00:08:21,199 --> 00:08:23,919
payload multipli multiplied with the pv

237
00:08:23,919 --> 00:08:26,319
and we will get pv for the pertinent

238
00:08:26,319 --> 00:08:28,000
messages and get zeros for the

239
00:08:28,000 --> 00:08:30,560
non-pertinent messages as before

240
00:08:30,560 --> 00:08:32,159
and then uh

241
00:08:32,159 --> 00:08:34,159
instead of assigning them randomly to

242
00:08:34,159 --> 00:08:35,599
some buckets we will generate some

243
00:08:35,599 --> 00:08:37,839
pseudo-random weight matrix this

244
00:08:37,839 --> 00:08:40,640
weight matrix has size began times n and

245
00:08:40,640 --> 00:08:42,159
then

246
00:08:42,159 --> 00:08:45,440
we will get m linear combinations so

247
00:08:45,440 --> 00:08:47,760
this as as long as at least k of them

248
00:08:47,760 --> 00:08:49,040
where case the number of written

249
00:08:49,040 --> 00:08:51,839
messages are linearly independent we

250
00:08:51,839 --> 00:08:53,920
will be able to use gaussian elimination

251
00:08:53,920 --> 00:08:56,480
to resolve and solve all the uh

252
00:08:56,480 --> 00:08:58,000
payloads back

253
00:08:58,000 --> 00:09:00,080
one issue with this uh technique is that

254
00:09:00,080 --> 00:09:02,240
um the compute the detector computation

255
00:09:02,240 --> 00:09:05,120
cost is quite large because the it's for

256
00:09:05,120 --> 00:09:07,600
each message the cost

257
00:09:07,600 --> 00:09:10,160
o n o m little m

258
00:09:10,160 --> 00:09:12,480
so uh to reduce this cost we are trying

259
00:09:12,480 --> 00:09:14,640
to use a sparse random linear coding in

260
00:09:14,640 --> 00:09:16,240
this case the weights uh the weight

261
00:09:16,240 --> 00:09:18,480
matrix will be uh slightly lightweight

262
00:09:18,480 --> 00:09:20,880
so only a limited number of them will be

263
00:09:20,880 --> 00:09:22,640
nonzero

264
00:09:22,640 --> 00:09:24,640
and then after using that the cost per

265
00:09:24,640 --> 00:09:26,080
message will be reduced to quasi

266
00:09:26,080 --> 00:09:28,560
constant

267
00:09:28,959 --> 00:09:31,440
so thus far we have uh com we have

268
00:09:31,440 --> 00:09:34,839
constructed a generic fhe based omd and

269
00:09:34,839 --> 00:09:37,760
omr asymptotically they are efficient

270
00:09:37,760 --> 00:09:39,440
and succinct they have sub-linear

271
00:09:39,440 --> 00:09:40,880
communication costs and quasi-linear

272
00:09:40,880 --> 00:09:43,040
computation cost

273
00:09:43,040 --> 00:09:44,959
however it's still quite impractical

274
00:09:44,959 --> 00:09:47,519
because fhe has a high computational and

275
00:09:47,519 --> 00:09:49,200
communication cost

276
00:09:49,200 --> 00:09:50,959
it can take milliseconds to do the end

277
00:09:50,959 --> 00:09:54,480
gate and it can take kilobytes for

278
00:09:54,480 --> 00:09:57,760
a single efficiency server test

279
00:09:57,920 --> 00:09:58,959
uh to

280
00:09:58,959 --> 00:10:01,040
to make it more practical we introduced

281
00:10:01,040 --> 00:10:02,800
lots of optimizations one key

282
00:10:02,800 --> 00:10:05,120
optimization is that instead of using

283
00:10:05,120 --> 00:10:07,200
efficiency ciphertext as clues we will

284
00:10:07,200 --> 00:10:09,600
use pvw ciphertext exclusive pvw

285
00:10:09,600 --> 00:10:11,920
ciphertext special key is quite similar

286
00:10:11,920 --> 00:10:14,560
to ldp ciphertext it has an a part and

287
00:10:14,560 --> 00:10:17,760
it has ap a b part this b part has l

288
00:10:17,760 --> 00:10:19,920
field elements if we want to encrypt l

289
00:10:19,920 --> 00:10:21,279
bits

290
00:10:21,279 --> 00:10:23,440
the decryption is basically the same as

291
00:10:23,440 --> 00:10:25,839
lwe we first do an inner product and

292
00:10:25,839 --> 00:10:28,160
then we do an addition and do a range

293
00:10:28,160 --> 00:10:32,279
check we will get zero one

294
00:10:33,040 --> 00:10:35,680
uh since we have since we have removed

295
00:10:35,680 --> 00:10:39,200
uh the the use of fg uh as close as

296
00:10:39,200 --> 00:10:41,440
clues we don't we don't actually need

297
00:10:41,440 --> 00:10:43,040
the recruit part

298
00:10:43,040 --> 00:10:45,120
and recrypt or bootstrapping is normally

299
00:10:45,120 --> 00:10:47,920
the most expensive in today's fvg scheme

300
00:10:47,920 --> 00:10:50,079
so we we can just simply remove it and

301
00:10:50,079 --> 00:10:53,040
use a leveled efficiency level hd scheme

302
00:10:53,040 --> 00:10:56,000
for level f3hd scheme we choose a bfd

303
00:10:56,000 --> 00:10:57,839
homomorphic encryption scheme that

304
00:10:57,839 --> 00:10:59,680
supports simply like field operations

305
00:10:59,680 --> 00:11:01,600
basically it means that for a bf3

306
00:11:01,600 --> 00:11:04,399
ciphertext inc it encrypts multiple

307
00:11:04,399 --> 00:11:06,720
field elements uh in one ciphertext and

308
00:11:06,720 --> 00:11:10,160
can be operated at the same time

309
00:11:10,160 --> 00:11:12,560
then we can perform the uh simply like

310
00:11:12,560 --> 00:11:15,200
bfv decryption using using

311
00:11:15,200 --> 00:11:18,160
pfe so the inner product and addition

312
00:11:18,160 --> 00:11:20,800
are relatively friendly to hd schemes

313
00:11:20,800 --> 00:11:22,640
but the range check is slightly more

314
00:11:22,640 --> 00:11:24,480
complicated we will directly use the

315
00:11:24,480 --> 00:11:26,959
results from lcd2

316
00:11:26,959 --> 00:11:28,959
afterwards we'll get a bfv ciphertext

317
00:11:28,959 --> 00:11:30,959
encrypting zero ones which is exactly

318
00:11:30,959 --> 00:11:33,600
the pv we wanted before and then we can

319
00:11:33,600 --> 00:11:35,839
proceed with the uh

320
00:11:35,839 --> 00:11:38,079
proceed with the coding techniques we

321
00:11:38,079 --> 00:11:40,800
have discussed before

322
00:11:40,800 --> 00:11:42,720
so putting everything together we have a

323
00:11:42,720 --> 00:11:46,160
uh hybrid use of pvw encryption and bfe

324
00:11:46,160 --> 00:11:48,399
encryption and basically the the

325
00:11:48,399 --> 00:11:51,279
recipient will have hold pfe public keys

326
00:11:51,279 --> 00:11:53,200
as clue keys and then the sender will

327
00:11:53,200 --> 00:11:54,560
use uh

328
00:11:54,560 --> 00:11:58,959
pvw to encrypt a clue and then uh the

329
00:11:58,959 --> 00:12:01,279
bfv uh public keys will be used as

330
00:12:01,279 --> 00:12:03,680
detection keys the detector will operate

331
00:12:03,680 --> 00:12:06,240
uh all the operations using the bfe

332
00:12:06,240 --> 00:12:09,200
homomorphic encryption and then use the

333
00:12:09,200 --> 00:12:10,880
use the techniques we have discussed

334
00:12:10,880 --> 00:12:13,519
before accumulate and get api cipher

335
00:12:13,519 --> 00:12:15,680
text as digest sent back to the

336
00:12:15,680 --> 00:12:17,600
recipient recipient will simply decrypt

337
00:12:17,600 --> 00:12:19,600
and do a gaussian illumination

338
00:12:19,600 --> 00:12:23,560
to get the plant text payloads

339
00:12:24,240 --> 00:12:26,000
this is actually so far it's quite

340
00:12:26,000 --> 00:12:28,079
practical but still not super practical

341
00:12:28,079 --> 00:12:29,920
therefore we have introduced uh some

342
00:12:29,920 --> 00:12:32,880
other uh additional uh optimizations the

343
00:12:32,880 --> 00:12:35,279
first one is for efficient tailoring we

344
00:12:35,279 --> 00:12:36,880
have uh optimized

345
00:12:36,880 --> 00:12:38,720
ladder of moduli homomorphic operation

346
00:12:38,720 --> 00:12:41,200
scheduling a symmetric bfv encryption

347
00:12:41,200 --> 00:12:43,839
level specific homomorphic rotation keys

348
00:12:43,839 --> 00:12:46,079
and we also have some scheme specific

349
00:12:46,079 --> 00:12:48,160
optimizations for example we have a

350
00:12:48,160 --> 00:12:51,120
tailored branch check so uh this is just

351
00:12:51,120 --> 00:12:53,040
simply to reduce the false positive rate

352
00:12:53,040 --> 00:12:55,680
and to reduce the uh public parameter l

353
00:12:55,680 --> 00:12:57,600
if you remember uh it will reduce the

354
00:12:57,600 --> 00:12:59,279
both the clue size and the computation

355
00:12:59,279 --> 00:13:02,320
cost another uh optimization

356
00:13:02,320 --> 00:13:04,959
technique we used was deterministic wise

357
00:13:04,959 --> 00:13:07,200
index retrieval this is used this is

358
00:13:07,200 --> 00:13:10,240
another way to do the uh to do omd and

359
00:13:10,240 --> 00:13:12,320
um we won't be able to go

360
00:13:12,320 --> 00:13:15,040
through details uh here and um

361
00:13:15,040 --> 00:13:16,959
lastly also lastly we also have some

362
00:13:16,959 --> 00:13:20,000
application uh driven tillering uh like

363
00:13:20,000 --> 00:13:22,000
memory footprint reduction and streaming

364
00:13:22,000 --> 00:13:26,399
updates with low latency finalization uh

365
00:13:26,720 --> 00:13:29,120
okay uh so we have also

366
00:13:29,120 --> 00:13:30,800
observed that the part there are some

367
00:13:30,800 --> 00:13:32,880
attacks that are possible to attack uh

368
00:13:32,880 --> 00:13:35,519
the prior schemes so uh therefore we

369
00:13:35,519 --> 00:13:36,320
have

370
00:13:36,320 --> 00:13:38,240
introduced some strong security notions

371
00:13:38,240 --> 00:13:39,839
defined and trying to make our

372
00:13:39,839 --> 00:13:41,760
construction uh surface and against

373
00:13:41,760 --> 00:13:43,199
those attacks

374
00:13:43,199 --> 00:13:45,199
the first one is the denial of service

375
00:13:45,199 --> 00:13:46,880
attack

376
00:13:46,880 --> 00:13:49,519
so imagine this scenario a sender wants

377
00:13:49,519 --> 00:13:51,519
to overload a recipient it can simply

378
00:13:51,519 --> 00:13:53,199
obtain the clue key from the the

379
00:13:53,199 --> 00:13:55,440
recipient uh generate

380
00:13:55,440 --> 00:13:57,279
thousands of clues uh

381
00:13:57,279 --> 00:13:59,440
and then uh thousands of messages and

382
00:13:59,440 --> 00:14:01,199
put on the bulletin board and then the

383
00:14:01,199 --> 00:14:03,519
detector will detect uh that message

384
00:14:03,519 --> 00:14:05,600
those all those thousands of messages as

385
00:14:05,600 --> 00:14:08,720
pertinent and send back to the recipient

386
00:14:08,720 --> 00:14:10,079
then the recipient will be overloaded

387
00:14:10,079 --> 00:14:12,160
because it has thousands messages this

388
00:14:12,160 --> 00:14:13,920
is kind of inherent and

389
00:14:13,920 --> 00:14:15,920
probably unavoidable for this kind of

390
00:14:15,920 --> 00:14:19,279
applications but it can get worse

391
00:14:19,279 --> 00:14:22,880
if we have a malicious sender who try to

392
00:14:22,880 --> 00:14:25,519
generate a clue that can be detected as

393
00:14:25,519 --> 00:14:27,920
pertinent to every recipient in this

394
00:14:27,920 --> 00:14:29,279
case if they

395
00:14:29,279 --> 00:14:31,360
simply generate a thousands of clues

396
00:14:31,360 --> 00:14:32,959
then all of the recipients will get

397
00:14:32,959 --> 00:14:34,959
overloaded

398
00:14:34,959 --> 00:14:37,360
and uh we have observed that f

399
00:14:37,360 --> 00:14:39,519
priority schemes fmv and ps are both

400
00:14:39,519 --> 00:14:41,680
vulnerable to this kind of tax and we

401
00:14:41,680 --> 00:14:45,519
are trying to mitigate this attack we

402
00:14:45,519 --> 00:14:49,519
do this by introducing a conjecture

403
00:14:49,519 --> 00:14:51,199
so we call this conjunction the snipe

404
00:14:51,199 --> 00:14:54,880
stink high conjecture for lw encryption

405
00:14:54,880 --> 00:14:57,120
suppose we have two pairs of uh reg or

406
00:14:57,120 --> 00:15:00,240
five keys and then the uh the adversary

407
00:15:00,240 --> 00:15:02,560
will try to generate a cipher text that

408
00:15:02,560 --> 00:15:04,320
the cipher text using the both secret

409
00:15:04,320 --> 00:15:06,880
keys will be decrypted into zero that's

410
00:15:06,880 --> 00:15:09,040
why also why we call this snake high

411
00:15:09,040 --> 00:15:11,040
conjecture because two zeros

412
00:15:11,040 --> 00:15:14,560
and of course we require that the a part

413
00:15:14,560 --> 00:15:16,240
of the cipher text to be non-zero so

414
00:15:16,240 --> 00:15:19,920
it's a non-trivial cipher text

415
00:15:19,920 --> 00:15:23,120
then we our question is that is this

416
00:15:23,120 --> 00:15:24,880
possible

417
00:15:24,880 --> 00:15:26,800
well it is trivially possible with

418
00:15:26,800 --> 00:15:29,440
probability one-half of course but how

419
00:15:29,440 --> 00:15:31,839
about with non-negligible probability so

420
00:15:31,839 --> 00:15:33,839
ie with probability uh

421
00:15:33,839 --> 00:15:37,199
half plus non-negligible

422
00:15:37,360 --> 00:15:40,320
our conjecture is that this is invisible

423
00:15:40,320 --> 00:15:42,079
but this is not directly implied by

424
00:15:42,079 --> 00:15:43,920
standard notions like semantic security

425
00:15:43,920 --> 00:15:46,000
or key privacy

426
00:15:46,000 --> 00:15:48,160
for pk schemes like algamal it's really

427
00:15:48,160 --> 00:15:51,279
impossible for non-trivial probabilities

428
00:15:51,279 --> 00:15:53,199
and we have tried to prove this under

429
00:15:53,199 --> 00:15:56,000
sis plus some generalist generalization

430
00:15:56,000 --> 00:15:58,320
of knowledge of knapsack noisy in the

431
00:15:58,320 --> 00:16:01,440
product introduced in bcct 12.

432
00:16:01,440 --> 00:16:02,880
one one

433
00:16:02,880 --> 00:16:04,720
minor thing is that we have also uh

434
00:16:04,720 --> 00:16:08,000
proved that if this holds for the rec

435
00:16:08,000 --> 00:16:10,639
encryption it also holds for the pvw

436
00:16:10,639 --> 00:16:13,040
encryption

437
00:16:13,279 --> 00:16:15,040
another attack is uh

438
00:16:15,040 --> 00:16:17,680
key linkability so given the keys can we

439
00:16:17,680 --> 00:16:19,040
try to find the identity of the

440
00:16:19,040 --> 00:16:20,800
recipients

441
00:16:20,800 --> 00:16:23,199
and we uh two uh two i guess to be

442
00:16:23,199 --> 00:16:24,800
against this uh kind of attack we

443
00:16:24,800 --> 00:16:26,079
defined three notions of key

444
00:16:26,079 --> 00:16:28,000
unlikability the first one is detection

445
00:16:28,000 --> 00:16:30,639
key to detection key key unlikability uh

446
00:16:30,639 --> 00:16:32,160
if a recipient holds two different

447
00:16:32,160 --> 00:16:33,759
detection keys uh it should be

448
00:16:33,759 --> 00:16:35,600
indistinguishable from two different uh

449
00:16:35,600 --> 00:16:37,199
recipients holding two different

450
00:16:37,199 --> 00:16:39,279
detection keys the second one is cookie

451
00:16:39,279 --> 00:16:41,680
to cookie unlikability if we have a

452
00:16:41,680 --> 00:16:43,199
recipient holding two clue keys it

453
00:16:43,199 --> 00:16:45,839
should be indistinguishable from two

454
00:16:45,839 --> 00:16:48,079
two recipients holding two cookies the

455
00:16:48,079 --> 00:16:49,759
last one is cool key to detection key

456
00:16:49,759 --> 00:16:52,240
unlinkability if the detector is holding

457
00:16:52,240 --> 00:16:54,079
some uh detection key it should not be

458
00:16:54,079 --> 00:16:56,320
able to link it back to any of the

459
00:16:56,320 --> 00:16:58,320
cookies

460
00:16:58,320 --> 00:17:00,000
uh both of the prior works are

461
00:17:00,000 --> 00:17:01,600
vulnerable to this attack and we have

462
00:17:01,600 --> 00:17:03,839
defined and achieved this attack prove

463
00:17:03,839 --> 00:17:08,319
this under a standard ring rw assumption

464
00:17:08,319 --> 00:17:09,919
uh lastly due to time constraint i'll

465
00:17:09,919 --> 00:17:12,880
very fast go through the

466
00:17:12,880 --> 00:17:15,679
benchmarks so for the this is only for

467
00:17:15,679 --> 00:17:18,079
detection schemes so as you can see for

468
00:17:18,079 --> 00:17:19,919
detection schemes we have the fastest

469
00:17:19,919 --> 00:17:22,799
runtime for the detector computation

470
00:17:22,799 --> 00:17:25,039
even compared to the sgx based solution

471
00:17:25,039 --> 00:17:28,400
as an npc based solution

472
00:17:28,400 --> 00:17:30,160
this is the retrieval benchmark this is

473
00:17:30,160 --> 00:17:32,640
for retrieval based schemes and as you

474
00:17:32,640 --> 00:17:35,840
can see that we although our runtime is

475
00:17:35,840 --> 00:17:38,720
slower that we we do provide full uh

476
00:17:38,720 --> 00:17:41,280
full privacy and also uh we we do

477
00:17:41,280 --> 00:17:44,840
believe that this runtime is still quite

478
00:17:44,840 --> 00:17:47,840
practical for recipient costs

479
00:17:47,840 --> 00:17:49,520
there are two parts for the recipient

480
00:17:49,520 --> 00:17:51,360
cost the first is the digest size i.e

481
00:17:51,360 --> 00:17:53,120
the communication cost and the second

482
00:17:53,120 --> 00:17:55,360
one is the digest runtime the

483
00:17:55,360 --> 00:17:56,880
receiver ground time

484
00:17:56,880 --> 00:17:58,480
and then

485
00:17:58,480 --> 00:18:01,840
from the figures we can see that as as

486
00:18:01,840 --> 00:18:03,760
if we have large amount of messages our

487
00:18:03,760 --> 00:18:05,919
schemes have a better performance uh

488
00:18:05,919 --> 00:18:07,600
while maintaining the strongest privacy

489
00:18:07,600 --> 00:18:09,840
guarantees and under minimal

490
00:18:09,840 --> 00:18:12,880
environmental assumptions

491
00:18:12,880 --> 00:18:15,280
uh some real world prospects uh based on

492
00:18:15,280 --> 00:18:16,559
our uh

493
00:18:16,559 --> 00:18:19,919
gcp uh instance benchmarks uh we have

494
00:18:19,919 --> 00:18:22,160
seen that the cost is roughly one dollar

495
00:18:22,160 --> 00:18:24,240
per million message scanned and this

496
00:18:24,240 --> 00:18:26,320
means roughly two cents per month for d

497
00:18:26,320 --> 00:18:28,400
cash and roughly one to two dollars per

498
00:18:28,400 --> 00:18:30,960
month for monero

499
00:18:30,960 --> 00:18:33,520
we have also uh some we also have some

500
00:18:33,520 --> 00:18:35,120
integration considerations in the

501
00:18:35,120 --> 00:18:37,120
benchmark we are using the uh pillow

502
00:18:37,120 --> 00:18:39,200
size from zcash which is roughly 600

503
00:18:39,200 --> 00:18:43,120
bytes a kilo 600 bytes and then uh

504
00:18:43,120 --> 00:18:44,960
we also need to consider the clue key

505
00:18:44,960 --> 00:18:46,880
distribution as the cookie needs to be

506
00:18:46,880 --> 00:18:49,600
obtained by the uh by the sender uh

507
00:18:49,600 --> 00:18:52,240
privately so probably need to uh embed

508
00:18:52,240 --> 00:18:54,320
them into the recipient's public address

509
00:18:54,320 --> 00:18:55,200
or shop

510
00:18:55,200 --> 00:18:57,440
from which the clue key can be fetched

511
00:18:57,440 --> 00:18:59,440
for clearing batting our clue is

512
00:18:59,440 --> 00:19:00,880
actually quite large right now it's

513
00:19:00,880 --> 00:19:03,120
roughly one kilobyte and it's quite

514
00:19:03,120 --> 00:19:04,320
close to the

515
00:19:04,320 --> 00:19:06,880
zcash shell the transaction

516
00:19:06,880 --> 00:19:08,400
and we also need to extend the

517
00:19:08,400 --> 00:19:10,559
transaction format to have a dedicated

518
00:19:10,559 --> 00:19:12,880
clue field and some other ways like

519
00:19:12,880 --> 00:19:15,280
operators uh operator field indicator

520
00:19:15,280 --> 00:19:17,280
transactions may also be used

521
00:19:17,280 --> 00:19:20,400
lastly about detection latency so if h

522
00:19:20,400 --> 00:19:22,320
so if a recipient sends a request saying

523
00:19:22,320 --> 00:19:24,000
that i want to review messages they may

524
00:19:24,000 --> 00:19:25,520
need to wait a long time

525
00:19:25,520 --> 00:19:28,080
for it to get back uh to resolve that

526
00:19:28,080 --> 00:19:30,080
problem we introduced the technique

527
00:19:30,080 --> 00:19:32,559
called the streaming updates so that the

528
00:19:32,559 --> 00:19:34,559
the cost will be greatly reduced so that

529
00:19:34,559 --> 00:19:38,080
the wealth wait time is then acceptable

530
00:19:38,080 --> 00:19:40,080
future works uh there's one ongoing

531
00:19:40,080 --> 00:19:42,080
project uh in the ongoing project we

532
00:19:42,080 --> 00:19:44,480
have been able to reduce the uh detector

533
00:19:44,480 --> 00:19:46,640
cost by roughly uh two point times

534
00:19:46,640 --> 00:19:49,200
faster and then uh the the main goal of

535
00:19:49,200 --> 00:19:51,600
that ongoing project is actually to

536
00:19:51,600 --> 00:19:54,559
resolve the group messaging uh so if we

537
00:19:54,559 --> 00:19:56,240
have one message and we have multiple

538
00:19:56,240 --> 00:19:58,080
recipients uh

539
00:19:58,080 --> 00:19:59,760
one trivial way is that we just let the

540
00:19:59,760 --> 00:20:01,919
sender generate multiple

541
00:20:01,919 --> 00:20:03,919
messages at the same time but this can

542
00:20:03,919 --> 00:20:06,240
be quite costly in both storage and

543
00:20:06,240 --> 00:20:08,080
detector time detector long time so we

544
00:20:08,080 --> 00:20:10,000
want to do that more efficiently

545
00:20:10,000 --> 00:20:11,600
another ongoing project is that we are

546
00:20:11,600 --> 00:20:13,200
trying to work with the d cache like

547
00:20:13,200 --> 00:20:15,440
well led team to uh

548
00:20:15,440 --> 00:20:16,559
to

549
00:20:16,559 --> 00:20:18,559
integrate our omr with the lightweight

550
00:20:18,559 --> 00:20:19,360
key

551
00:20:19,360 --> 00:20:20,720
there are also some future directions

552
00:20:20,720 --> 00:20:22,559
like reducing size of clues blue keys

553
00:20:22,559 --> 00:20:24,640
detection keys dos resistance from

554
00:20:24,640 --> 00:20:26,480
standard assumptions and integrity

555
00:20:26,480 --> 00:20:28,320
against uh fully malicious detectors

556
00:20:28,320 --> 00:20:30,320
these are all very interesting

557
00:20:30,320 --> 00:20:33,120
future possible directions and that's my

558
00:20:33,120 --> 00:20:34,720
talk for today thank you all very much

559
00:20:34,720 --> 00:20:37,360
for listening

560
00:20:42,559 --> 00:20:46,640
okay we have time for maybe one or even

561
00:20:46,640 --> 00:20:49,760
two questions um while the next speaker

562
00:20:49,760 --> 00:20:51,919
is setting up

563
00:20:51,919 --> 00:20:54,320
and if there is

564
00:20:54,320 --> 00:20:56,720
no question directly

565
00:20:56,720 --> 00:20:59,039
there may be question from my side so

566
00:20:59,039 --> 00:21:02,000
one of your motivations is to use this

567
00:21:02,000 --> 00:21:05,360
for uh identifying messages in secure

568
00:21:05,360 --> 00:21:08,559
messaging the difference between

569
00:21:08,559 --> 00:21:09,440
these

570
00:21:09,440 --> 00:21:13,039
i would say between these coin based

571
00:21:13,039 --> 00:21:15,360
motivations and messaging is that

572
00:21:15,360 --> 00:21:17,520
usually in these transaction settings

573
00:21:17,520 --> 00:21:19,039
you want to keep these transactions

574
00:21:19,039 --> 00:21:20,799
online and you want to don't want to

575
00:21:20,799 --> 00:21:22,799
delete them but in messaging you're

576
00:21:22,799 --> 00:21:25,120
happy that your delivery server at some

577
00:21:25,120 --> 00:21:26,960
point can remove those messages that

578
00:21:26,960 --> 00:21:29,039
have been delivered and so the question

579
00:21:29,039 --> 00:21:31,280
would be do you have some idea how to

580
00:21:31,280 --> 00:21:32,880
detect those messages that you can

581
00:21:32,880 --> 00:21:36,000
already delete because one of your key

582
00:21:36,000 --> 00:21:39,039
properties of the scheme is that

583
00:21:39,039 --> 00:21:41,919
the detector nor the server knows which

584
00:21:41,919 --> 00:21:43,840
messages actually have been delivered

585
00:21:43,840 --> 00:21:45,600
and which of those were just

586
00:21:45,600 --> 00:21:47,760
shipped to the receiver

587
00:21:47,760 --> 00:21:50,559
yeah it's possible so if we have a

588
00:21:50,559 --> 00:21:52,480
detector that holds the entire database

589
00:21:52,480 --> 00:21:55,200
then it can easily trace back and get

590
00:21:55,200 --> 00:21:57,280
the previous messages that are even like

591
00:21:57,280 --> 00:22:00,080
deleted from the central database but um

592
00:22:00,080 --> 00:22:02,880
so if if the detector doesn't hold that

593
00:22:02,880 --> 00:22:04,159
and then

594
00:22:04,159 --> 00:22:07,200
i don't i don't see an obvious way to do

595
00:22:07,200 --> 00:22:09,360
that

596
00:22:09,520 --> 00:22:12,480
okay thank you thank you can ask a

597
00:22:12,480 --> 00:22:14,240
question ah there's another question

598
00:22:14,240 --> 00:22:17,039
yeah sure hey hi nice talk

599
00:22:17,039 --> 00:22:18,880
uh just a question so you mentioned you

600
00:22:18,880 --> 00:22:20,960
use the sparse linear coding to improve

601
00:22:20,960 --> 00:22:23,360
the efficiency yes do you get provable

602
00:22:23,360 --> 00:22:25,200
guarantees with it for correctness or is

603
00:22:25,200 --> 00:22:28,720
it a heuristic approach uh no we have uh

604
00:22:28,720 --> 00:22:31,039
strict proofs okay

605
00:22:31,039 --> 00:22:32,559
thank you

606
00:22:32,559 --> 00:22:36,240
okay let's thank the speaker again

607
00:22:36,240 --> 00:22:39,400
thank you

608
00:22:41,360 --> 00:22:42,159
and

609
00:22:42,159 --> 00:22:47,760
while alex is setting up i can already

610
00:22:48,480 --> 00:22:50,640
introduce him

611
00:22:50,640 --> 00:22:53,760
and his talk so this uh the next talk is

612
00:22:53,760 --> 00:22:56,400
uh about a paper that was soft merged

613
00:22:56,400 --> 00:22:58,400
with another paper

614
00:22:58,400 --> 00:23:00,480
uh the paper that alex will present

615
00:23:00,480 --> 00:23:01,520
today

616
00:23:01,520 --> 00:23:03,760
has the title a more complete analysis

617
00:23:03,760 --> 00:23:05,919
of the signal double ratchet algorithm

618
00:23:05,919 --> 00:23:10,400
it is joint work by alex beanstalk jaden

619
00:23:10,400 --> 00:23:12,960
fire rose sanjan

620
00:23:12,960 --> 00:23:15,679
pat jay mukherjee and

621
00:23:15,679 --> 00:23:17,600
srinivasan

622
00:23:17,600 --> 00:23:19,440
raghuraman

623
00:23:19,440 --> 00:23:21,280
and the other paper that was soft merged

624
00:23:21,280 --> 00:23:22,240
with it

625
00:23:22,240 --> 00:23:24,559
has the title universally composable

626
00:23:24,559 --> 00:23:27,280
end-to-end secure messaging and it was

627
00:23:27,280 --> 00:23:29,280
written by ron kenneth

628
00:23:29,280 --> 00:23:30,880
jane

629
00:23:30,880 --> 00:23:32,120
marika

630
00:23:32,120 --> 00:23:35,360
swanberg and mayank varya

631
00:23:35,360 --> 00:23:38,159
yes and alex is giving the talk and the

632
00:23:38,159 --> 00:23:40,080
stage is yours okay great yeah thanks

633
00:23:40,080 --> 00:23:42,480
for the introduction so yeah very happy

634
00:23:42,480 --> 00:23:44,960
to be here in my first crypt though um

635
00:23:44,960 --> 00:23:47,360
so yeah let's get started so

636
00:23:47,360 --> 00:23:49,679
yeah what's the signal protocol well of

637
00:23:49,679 --> 00:23:52,240
course it's a secure messaging protocol

638
00:23:52,240 --> 00:23:52,960
for

639
00:23:52,960 --> 00:23:54,559
long-lived sessions

640
00:23:54,559 --> 00:23:56,799
uh that was originally based on the off

641
00:23:56,799 --> 00:23:58,880
the record protocol

642
00:23:58,880 --> 00:24:00,559
and of course it's used by billions of

643
00:24:00,559 --> 00:24:02,880
people you know on the signal app itself

644
00:24:02,880 --> 00:24:05,440
and also many more applications

645
00:24:05,440 --> 00:24:06,880
including some

646
00:24:06,880 --> 00:24:09,120
not even on this slide

647
00:24:09,120 --> 00:24:11,600
okay and also it won the levchin prize

648
00:24:11,600 --> 00:24:13,679
at real world crypto so that's how you

649
00:24:13,679 --> 00:24:17,120
really know it's a practical thing

650
00:24:17,120 --> 00:24:20,080
okay so what's what's the setting for uh

651
00:24:20,080 --> 00:24:21,600
secure messaging

652
00:24:21,600 --> 00:24:23,440
well first of all protocol should be

653
00:24:23,440 --> 00:24:26,480
asynchronous meaning that uh the two

654
00:24:26,480 --> 00:24:29,039
parties involved in the messaging system

655
00:24:29,039 --> 00:24:31,679
uh don't send in set rounds but rather

656
00:24:31,679 --> 00:24:34,559
their communication can overlap some

657
00:24:34,559 --> 00:24:35,600
and also

658
00:24:35,600 --> 00:24:37,600
they may be working over an unreliable

659
00:24:37,600 --> 00:24:38,640
network

660
00:24:38,640 --> 00:24:41,039
meaning that message messages may arrive

661
00:24:41,039 --> 00:24:43,360
arbitrarily out of order or even be

662
00:24:43,360 --> 00:24:45,600
completely lost in the network

663
00:24:45,600 --> 00:24:47,840
and despite this we still want what's

664
00:24:47,840 --> 00:24:50,080
called immediate decryption meaning that

665
00:24:50,080 --> 00:24:52,799
if a receiver gets a cipher text no

666
00:24:52,799 --> 00:24:55,279
matter how much or how out of order it

667
00:24:55,279 --> 00:24:57,200
is they should be able to immediately

668
00:24:57,200 --> 00:24:59,200
decrypt it and place it in the right

669
00:24:59,200 --> 00:25:01,360
spot in the transcript

670
00:25:01,360 --> 00:25:02,960
okay and then also

671
00:25:02,960 --> 00:25:05,440
message loss resilience which means that

672
00:25:05,440 --> 00:25:07,919
if a message is completely lost

673
00:25:07,919 --> 00:25:09,520
then they shouldn't just

674
00:25:09,520 --> 00:25:13,360
kill all functionality of the protocol

675
00:25:13,360 --> 00:25:15,919
okay also parties might be offline for

676
00:25:15,919 --> 00:25:18,000
extended periods for example if they're

677
00:25:18,000 --> 00:25:21,440
uh flying to santa barbara for crypto um

678
00:25:21,440 --> 00:25:23,600
and serv the server should therefore

679
00:25:23,600 --> 00:25:25,039
provide a

680
00:25:25,039 --> 00:25:27,520
mailbox service for parties so that when

681
00:25:27,520 --> 00:25:30,000
they do come back online they can simply

682
00:25:30,000 --> 00:25:32,240
uh download these messages from the

683
00:25:32,240 --> 00:25:33,919
server

684
00:25:33,919 --> 00:25:35,760
okay also uh

685
00:25:35,760 --> 00:25:37,600
protocols are very long-lived they can

686
00:25:37,600 --> 00:25:39,279
last you know 10

687
00:25:39,279 --> 00:25:41,520
10 years something like this so one

688
00:25:41,520 --> 00:25:43,840
might assume that a state leakage could

689
00:25:43,840 --> 00:25:45,520
be likely over the lifetime of the

690
00:25:45,520 --> 00:25:47,039
protocol

691
00:25:47,039 --> 00:25:49,919
and by this i mean sort of a transient

692
00:25:49,919 --> 00:25:53,120
transient snapshot of the state

693
00:25:53,120 --> 00:25:54,960
okay and finally devices could be using

694
00:25:54,960 --> 00:25:57,039
bad randomness

695
00:25:57,039 --> 00:26:00,320
okay so now with all these prop uh

696
00:26:00,320 --> 00:26:01,919
with this setting of secure messaging

697
00:26:01,919 --> 00:26:03,760
what are the security properties that we

698
00:26:03,760 --> 00:26:06,320
want well first and foremost we want end

699
00:26:06,320 --> 00:26:07,760
to end security

700
00:26:07,760 --> 00:26:10,159
meaning that when there is no leakage

701
00:26:10,159 --> 00:26:12,080
these messages should be secure even

702
00:26:12,080 --> 00:26:14,960
from this server sitting in the middle

703
00:26:14,960 --> 00:26:17,360
okay and then when there is a leakage

704
00:26:17,360 --> 00:26:19,679
we want forward security meaning that

705
00:26:19,679 --> 00:26:23,440
past messages uh should re remain secure

706
00:26:23,440 --> 00:26:25,679
even after a leakage

707
00:26:25,679 --> 00:26:27,440
okay and on the flip side we want post

708
00:26:27,440 --> 00:26:29,200
compromise security

709
00:26:29,200 --> 00:26:30,559
meaning that

710
00:26:30,559 --> 00:26:32,960
if a user state is leaked

711
00:26:32,960 --> 00:26:33,919
then

712
00:26:33,919 --> 00:26:35,760
the protocol should sort of naturally

713
00:26:35,760 --> 00:26:39,600
recover so that uh security is regained

714
00:26:39,600 --> 00:26:41,120
at some point

715
00:26:41,120 --> 00:26:44,320
and i say a passive attacker meaning

716
00:26:44,320 --> 00:26:46,799
that uh once the attacker gets the state

717
00:26:46,799 --> 00:26:48,559
it's passive because

718
00:26:48,559 --> 00:26:50,799
otherwise yeah we don't really know what

719
00:26:50,799 --> 00:26:53,279
kind of guarantees we can we can provide

720
00:26:53,279 --> 00:26:55,279
since the attacker can probably just

721
00:26:55,279 --> 00:26:57,919
completely take over everything uh but

722
00:26:57,919 --> 00:27:00,960
we do allow for an uh

723
00:27:00,960 --> 00:27:03,679
attack an active uh adversary when they

724
00:27:03,679 --> 00:27:07,600
don't have these state leakages

725
00:27:07,600 --> 00:27:09,520
okay and then finally we want resilience

726
00:27:09,520 --> 00:27:11,600
against bad randomness meaning that if

727
00:27:11,600 --> 00:27:14,400
there is no leakage then injecting bad

728
00:27:14,400 --> 00:27:15,679
randomness

729
00:27:15,679 --> 00:27:19,200
into the protocol should not hurt

730
00:27:19,200 --> 00:27:21,440
okay and sort of the hard thing

731
00:27:21,440 --> 00:27:24,720
about analyzing signal is that we want

732
00:27:24,720 --> 00:27:28,000
all of these properties simultaneously

733
00:27:28,000 --> 00:27:29,840
including everything that i listed on

734
00:27:29,840 --> 00:27:31,679
the previous slide

735
00:27:31,679 --> 00:27:35,039
uh and so intuitively uh for forward

736
00:27:35,039 --> 00:27:36,799
security what do we do

737
00:27:36,799 --> 00:27:39,200
we just delete keys that

738
00:27:39,200 --> 00:27:41,279
aren't useful anymore

739
00:27:41,279 --> 00:27:44,000
for post compromise security we refresh

740
00:27:44,000 --> 00:27:46,080
keys with a new

741
00:27:46,080 --> 00:27:47,679
randomness

742
00:27:47,679 --> 00:27:49,679
and for resilience against

743
00:27:49,679 --> 00:27:52,480
bad randomness we leverage the security

744
00:27:52,480 --> 00:27:55,919
of old keys in our state

745
00:27:56,000 --> 00:27:57,200
okay so

746
00:27:57,200 --> 00:27:59,840
uh let's quickly talk about prior work

747
00:27:59,840 --> 00:28:03,520
uh first uh in terms of signal

748
00:28:03,520 --> 00:28:05,919
uh there was the first seminal analysis

749
00:28:05,919 --> 00:28:09,360
in 2017 by khan gordon at all

750
00:28:09,360 --> 00:28:11,919
where they analyzed the entire signal

751
00:28:11,919 --> 00:28:14,960
protocol as a sort of multi-stage key

752
00:28:14,960 --> 00:28:16,399
exchange

753
00:28:16,399 --> 00:28:18,320
where the keys that are agreed upon are

754
00:28:18,320 --> 00:28:19,919
the actual keys

755
00:28:19,919 --> 00:28:21,840
being used to encrypt and decrypt each

756
00:28:21,840 --> 00:28:23,520
message

757
00:28:23,520 --> 00:28:25,919
but unfortunately

758
00:28:25,919 --> 00:28:27,840
they did not provide much of an

759
00:28:27,840 --> 00:28:30,320
abstraction of the protocol and also

760
00:28:30,320 --> 00:28:31,679
didn't model

761
00:28:31,679 --> 00:28:35,360
bad randomness nor immediate decryption

762
00:28:35,360 --> 00:28:38,880
and then alan at all in 2019

763
00:28:38,880 --> 00:28:42,159
they did provide this clean abstraction

764
00:28:42,159 --> 00:28:43,919
of the building blocks of the signal

765
00:28:43,919 --> 00:28:48,399
protocol um into uh uh yeah game-based

766
00:28:48,399 --> 00:28:49,600
primitives

767
00:28:49,600 --> 00:28:52,320
um and for our paper we we sort of call

768
00:28:52,320 --> 00:28:54,640
this the gold standard of uh double

769
00:28:54,640 --> 00:28:56,799
ratchet analysis

770
00:28:56,799 --> 00:28:59,200
and yeah i say double ratchet because

771
00:28:59,200 --> 00:29:02,799
actually uh signal can be seen as uh

772
00:29:02,799 --> 00:29:04,720
comprising of two parts

773
00:29:04,720 --> 00:29:06,880
uh first an initial key exchange

774
00:29:06,880 --> 00:29:09,919
protocol that gives the two parties some

775
00:29:09,919 --> 00:29:12,159
shared key material and then sort of the

776
00:29:12,159 --> 00:29:13,440
backbone

777
00:29:13,440 --> 00:29:16,320
messaging component which is called the

778
00:29:16,320 --> 00:29:19,840
double ratchet and this is also

779
00:29:19,840 --> 00:29:22,640
the component that we study in our work

780
00:29:22,640 --> 00:29:25,360
okay and what we notice is that this

781
00:29:25,360 --> 00:29:26,320
19

782
00:29:26,320 --> 00:29:28,880
is sort of incomplete meaning that

783
00:29:28,880 --> 00:29:30,559
some messages that

784
00:29:30,559 --> 00:29:32,960
one might expect security for from the

785
00:29:32,960 --> 00:29:34,480
signal protocol

786
00:29:34,480 --> 00:29:36,720
aren't actually guaranteed security in

787
00:29:36,720 --> 00:29:39,440
the in their analysis

788
00:29:39,440 --> 00:29:42,559
okay and then on on the non-signal side

789
00:29:42,559 --> 00:29:44,559
there were a line of works uh that

790
00:29:44,559 --> 00:29:46,559
basically worked on strengthening the

791
00:29:46,559 --> 00:29:48,320
security properties

792
00:29:48,320 --> 00:29:50,159
of the signal protocol

793
00:29:50,159 --> 00:29:53,039
uh by for example using stronger crypto

794
00:29:53,039 --> 00:29:56,000
primitives or maybe giving up on some uh

795
00:29:56,000 --> 00:29:58,000
efficiency or other

796
00:29:58,000 --> 00:30:01,039
sort of functionality properties

797
00:30:01,039 --> 00:30:04,320
um and yastadol in 2019 studied the

798
00:30:04,320 --> 00:30:07,360
composability of the sort of general

799
00:30:07,360 --> 00:30:09,520
ratcheting technique that's at the core

800
00:30:09,520 --> 00:30:11,039
of a lot of

801
00:30:11,039 --> 00:30:13,360
secure messaging

802
00:30:13,360 --> 00:30:15,360
and finally there is a line of work that

803
00:30:15,360 --> 00:30:17,440
studied the initial key exchange

804
00:30:17,440 --> 00:30:20,080
protocol of signal

805
00:30:20,080 --> 00:30:21,039
both

806
00:30:21,039 --> 00:30:22,559
both in terms of the actual signal

807
00:30:22,559 --> 00:30:25,679
protocol and also extensions uh for

808
00:30:25,679 --> 00:30:30,720
example to uh get post-quantum security

809
00:30:30,880 --> 00:30:33,520
okay so let's talk about uh what what

810
00:30:33,520 --> 00:30:36,080
our results are uh so yeah first of all

811
00:30:36,080 --> 00:30:38,159
again we only study the double ratchet

812
00:30:38,159 --> 00:30:40,720
not the initial key exchange protocol

813
00:30:40,720 --> 00:30:43,840
um and for this we provide a uc based

814
00:30:43,840 --> 00:30:45,919
simulation style definition

815
00:30:45,919 --> 00:30:48,799
uh which captures the security of the of

816
00:30:48,799 --> 00:30:51,840
the double ratchet more tightly than the

817
00:30:51,840 --> 00:30:53,919
prior works

818
00:30:53,919 --> 00:30:56,640
okay and along the way we capture the

819
00:30:56,640 --> 00:30:58,880
building blocks that seem intuitively

820
00:30:58,880 --> 00:31:01,440
necessary for this security

821
00:31:01,440 --> 00:31:03,840
and finally we uncover a minor weakness

822
00:31:03,840 --> 00:31:05,840
of the double ratchet and provide an

823
00:31:05,840 --> 00:31:08,879
efficient fix for it

824
00:31:09,120 --> 00:31:11,039
and so before i

825
00:31:11,039 --> 00:31:13,440
explain our results in more depth i want

826
00:31:13,440 --> 00:31:13,680
to

827
00:31:13,680 --> 00:31:15,039
[Music]

828
00:31:15,039 --> 00:31:17,360
explain the different

829
00:31:17,360 --> 00:31:18,880
techniques and different results that

830
00:31:18,880 --> 00:31:21,679
the soft merge paper has

831
00:31:21,679 --> 00:31:22,640
so

832
00:31:22,640 --> 00:31:24,240
first of all they

833
00:31:24,240 --> 00:31:26,399
model the complete signal protocol in

834
00:31:26,399 --> 00:31:27,919
the uc model

835
00:31:27,919 --> 00:31:30,080
so this includes

836
00:31:30,080 --> 00:31:32,559
the initial key exchange as well along

837
00:31:32,559 --> 00:31:34,399
with uh you know everything that comes

838
00:31:34,399 --> 00:31:36,960
with that so like uh the pki and some

839
00:31:36,960 --> 00:31:38,320
other things

840
00:31:38,320 --> 00:31:41,440
um and also they analyze all of the

841
00:31:41,440 --> 00:31:43,760
building blocks of signal

842
00:31:43,760 --> 00:31:46,640
via additional uc functionalities

843
00:31:46,640 --> 00:31:49,039
whereas we actually

844
00:31:49,039 --> 00:31:51,440
provide game-based definitions for these

845
00:31:51,440 --> 00:31:53,519
building blocks

846
00:31:53,519 --> 00:31:55,360
okay and then finally

847
00:31:55,360 --> 00:31:56,000
in

848
00:31:56,000 --> 00:31:58,960
with slightly weaker security than we

849
00:31:58,960 --> 00:32:02,240
guarantee for the double ratchet uh they

850
00:32:02,240 --> 00:32:05,120
minimize the use of the random oracle

851
00:32:05,120 --> 00:32:08,240
to only what is sort of required

852
00:32:08,240 --> 00:32:10,640
uh for a fully adaptive

853
00:32:10,640 --> 00:32:12,480
adversary

854
00:32:12,480 --> 00:32:15,039
and so specifically uh for

855
00:32:15,039 --> 00:32:16,720
non-committing encryption when for

856
00:32:16,720 --> 00:32:17,840
example

857
00:32:17,840 --> 00:32:20,799
uh the simulator is asked for a cipher

858
00:32:20,799 --> 00:32:22,960
text without knowing the underlying

859
00:32:22,960 --> 00:32:25,039
underlying plain text and then the

860
00:32:25,039 --> 00:32:28,799
receiver uh is corrupted

861
00:32:28,799 --> 00:32:32,000
uh and so in order to do this

862
00:32:32,000 --> 00:32:34,960
uh they provide a novel realization of

863
00:32:34,960 --> 00:32:37,200
the signal root kdf which i'll talk

864
00:32:37,200 --> 00:32:39,600
about in a moment um

865
00:32:39,600 --> 00:32:41,679
in the standard model and

866
00:32:41,679 --> 00:32:42,880
whereas we

867
00:32:42,880 --> 00:32:45,279
resort to using a programmable random

868
00:32:45,279 --> 00:32:47,440
oracle uh where

869
00:32:47,440 --> 00:32:49,760
so the using a random oracle seems

870
00:32:49,760 --> 00:32:50,960
necessary

871
00:32:50,960 --> 00:32:54,240
for our slightly stronger security

872
00:32:54,240 --> 00:32:56,559
uh and then we also use the

873
00:32:56,559 --> 00:32:58,080
programmability

874
00:32:58,080 --> 00:32:59,519
uh because

875
00:32:59,519 --> 00:33:02,000
basically we we wanted to stick as close

876
00:33:02,000 --> 00:33:04,399
uh to the signal the actual signal

877
00:33:04,399 --> 00:33:07,918
specification as possible

878
00:33:08,159 --> 00:33:10,080
okay and so yeah obviously this doesn't

879
00:33:10,080 --> 00:33:12,480
uh do their paper justice so please if

880
00:33:12,480 --> 00:33:14,159
you're interested read their paper or

881
00:33:14,159 --> 00:33:18,080
also uh watch their longer form video uh

882
00:33:18,080 --> 00:33:20,879
on the website

883
00:33:21,039 --> 00:33:24,559
okay so now i'll go over sort of

884
00:33:24,559 --> 00:33:26,159
at a high level how the double ratchet

885
00:33:26,159 --> 00:33:28,480
works and hopefully provide some more

886
00:33:28,480 --> 00:33:31,840
intuitive security properties for you

887
00:33:31,840 --> 00:33:33,760
so as the name suggests the first

888
00:33:33,760 --> 00:33:36,880
component is the public ratchet

889
00:33:36,880 --> 00:33:39,440
which is actually a synchronous protocol

890
00:33:39,440 --> 00:33:42,720
so a round based protocol uh and yeah in

891
00:33:42,720 --> 00:33:45,600
this literature we call rounds epochs

892
00:33:45,600 --> 00:33:48,320
um and yeah i'll show later on how the

893
00:33:48,320 --> 00:33:50,840
complete protocol manages to be

894
00:33:50,840 --> 00:33:52,720
asynchronous

895
00:33:52,720 --> 00:33:55,840
uh okay so let's say alice initiates a

896
00:33:55,840 --> 00:33:57,200
conversation

897
00:33:57,200 --> 00:33:59,039
uh and so actually the first thing that

898
00:33:59,039 --> 00:34:01,279
happens is bob will

899
00:34:01,279 --> 00:34:05,200
upload some public key to the server

900
00:34:05,200 --> 00:34:09,280
g to x0 and then when alice wants to

901
00:34:09,280 --> 00:34:11,040
initiate a conversation

902
00:34:11,040 --> 00:34:14,719
she'll download one of bob's public keys

903
00:34:14,719 --> 00:34:16,320
and then sample

904
00:34:16,320 --> 00:34:19,199
some exponent x1 and derive the shared

905
00:34:19,199 --> 00:34:21,599
diffie-hellman key k1

906
00:34:21,599 --> 00:34:23,359
okay and then

907
00:34:23,359 --> 00:34:26,079
she'll send this g to x1 to bob

908
00:34:26,079 --> 00:34:27,839
he'll of course be able to to do the

909
00:34:27,839 --> 00:34:31,760
same and this k1 will seed what's called

910
00:34:31,760 --> 00:34:34,399
a symmetric ratchet which is what alice

911
00:34:34,399 --> 00:34:36,800
and bob use to actually

912
00:34:36,800 --> 00:34:38,800
symmetrically encrypt and decrypt

913
00:34:38,800 --> 00:34:40,399
messages

914
00:34:40,399 --> 00:34:42,879
and i'll expand on this in in a few

915
00:34:42,879 --> 00:34:44,639
slides

916
00:34:44,639 --> 00:34:47,440
but okay then when bob wants to start a

917
00:34:47,440 --> 00:34:49,760
new epoch he does the same

918
00:34:49,760 --> 00:34:52,639
he samples in x2 and sends it to

919
00:34:52,639 --> 00:34:54,719
alice and we sort of keep going like

920
00:34:54,719 --> 00:34:56,960
this

921
00:34:56,960 --> 00:34:59,520
okay and so first i claim that this

922
00:34:59,520 --> 00:35:02,240
public ratchet provides post-compromise

923
00:35:02,240 --> 00:35:03,440
security

924
00:35:03,440 --> 00:35:05,920
because at this point uh if bob is

925
00:35:05,920 --> 00:35:07,040
corrupted

926
00:35:07,040 --> 00:35:08,400
then of course we know that this

927
00:35:08,400 --> 00:35:10,240
symmetric ratchet number one will be

928
00:35:10,240 --> 00:35:11,680
compromised

929
00:35:11,680 --> 00:35:14,160
but if he has good randomness then this

930
00:35:14,160 --> 00:35:17,839
k2 key should be secure

931
00:35:17,920 --> 00:35:19,520
okay

932
00:35:19,520 --> 00:35:21,040
and then

933
00:35:21,040 --> 00:35:23,119
for forward security

934
00:35:23,119 --> 00:35:24,320
um

935
00:35:24,320 --> 00:35:25,839
once bob

936
00:35:25,839 --> 00:35:27,839
starts this new epoch

937
00:35:27,839 --> 00:35:31,040
he can delete this old key material from

938
00:35:31,040 --> 00:35:32,960
epoch number one

939
00:35:32,960 --> 00:35:35,760
so that even if he's corrupted now this

940
00:35:35,760 --> 00:35:39,359
first ratchet should be secure

941
00:35:40,000 --> 00:35:42,480
okay so actually i swept some details

942
00:35:42,480 --> 00:35:45,200
under the rug so there's a little bit

943
00:35:45,200 --> 00:35:48,000
more going on in the public ratchet

944
00:35:48,000 --> 00:35:51,440
so what happens is that each epoch t

945
00:35:51,440 --> 00:35:54,560
also has this root key sigma t

946
00:35:54,560 --> 00:35:55,280
so

947
00:35:55,280 --> 00:35:57,760
alice and bob both start out with some

948
00:35:57,760 --> 00:35:59,920
sigma zero which is part of the

949
00:35:59,920 --> 00:36:02,640
uh key material that they agree on uh

950
00:36:02,640 --> 00:36:05,520
from the initial key exchange

951
00:36:05,520 --> 00:36:08,000
and when they derive a new

952
00:36:08,000 --> 00:36:10,240
uh defeat helmet key

953
00:36:10,240 --> 00:36:11,119
they

954
00:36:11,119 --> 00:36:13,680
input both into a kdf

955
00:36:13,680 --> 00:36:16,720
which then spits out one the symmetric

956
00:36:16,720 --> 00:36:18,240
ratchet seed

957
00:36:18,240 --> 00:36:20,800
and also a new root key

958
00:36:20,800 --> 00:36:23,680
okay and so then again they they keep

959
00:36:23,680 --> 00:36:25,440
doing this sort of thing

960
00:36:25,440 --> 00:36:28,880
as new diffie-hellman keys come in

961
00:36:28,880 --> 00:36:31,680
okay uh so now

962
00:36:31,680 --> 00:36:34,720
uh i claim that this provides uh

963
00:36:34,720 --> 00:36:36,800
resilience against bad randomness

964
00:36:36,800 --> 00:36:39,680
because even if this newly sampled x2

965
00:36:39,680 --> 00:36:41,760
was you know even completely chosen by

966
00:36:41,760 --> 00:36:43,200
the adversary

967
00:36:43,200 --> 00:36:45,520
uh and so this diffie-hellman shared key

968
00:36:45,520 --> 00:36:47,200
will be insecure

969
00:36:47,200 --> 00:36:49,760
well if there's no leakage before this

970
00:36:49,760 --> 00:36:52,160
then sigma one will be secure and so

971
00:36:52,160 --> 00:36:54,480
then the output of this kdf will be

972
00:36:54,480 --> 00:36:56,880
secure

973
00:36:57,520 --> 00:37:00,000
okay so now finally uh the symmetric

974
00:37:00,000 --> 00:37:02,960
ratchet uh so

975
00:37:02,960 --> 00:37:07,119
uh for each message i in some epoch t

976
00:37:07,119 --> 00:37:10,320
we have a unique chain key ckti

977
00:37:10,320 --> 00:37:13,520
and a unique message key mkti

978
00:37:13,520 --> 00:37:16,960
okay and so this ckt 0 is basically what

979
00:37:16,960 --> 00:37:19,520
i was referring to before as the seed of

980
00:37:19,520 --> 00:37:21,680
each symmetric ratchet

981
00:37:21,680 --> 00:37:24,640
okay and so when alice uh or bob wants

982
00:37:24,640 --> 00:37:26,400
to encrypt or decrypt

983
00:37:26,400 --> 00:37:28,079
a new message

984
00:37:28,079 --> 00:37:30,720
basically they input this to a kdf which

985
00:37:30,720 --> 00:37:32,160
spits out both

986
00:37:32,160 --> 00:37:34,800
a message key mkt1 which they will

987
00:37:34,800 --> 00:37:37,040
actually use to encrypt or decrypt

988
00:37:37,040 --> 00:37:39,200
and also a new chain key

989
00:37:39,200 --> 00:37:40,960
okay and then when they want to do

990
00:37:40,960 --> 00:37:44,480
another message they do the same thing

991
00:37:44,480 --> 00:37:47,440
okay and so this provides forward

992
00:37:47,440 --> 00:37:49,920
secrecy because

993
00:37:49,920 --> 00:37:52,079
after alice or bob is done with these

994
00:37:52,079 --> 00:37:54,720
old keys they can just delete it and so

995
00:37:54,720 --> 00:37:57,839
then a a corrupting adversary

996
00:37:57,839 --> 00:37:59,200
won't be able to get this old

997
00:37:59,200 --> 00:38:01,599
information

998
00:38:01,599 --> 00:38:03,440
and also this metric ratchet is

999
00:38:03,440 --> 00:38:05,040
deterministic

1000
00:38:05,040 --> 00:38:07,200
so actually the adversary will be able

1001
00:38:07,200 --> 00:38:08,720
to get

1002
00:38:08,720 --> 00:38:11,839
all future derivations too

1003
00:38:11,839 --> 00:38:12,720
but

1004
00:38:12,720 --> 00:38:14,880
this is actually still a good thing for

1005
00:38:14,880 --> 00:38:16,720
functionality

1006
00:38:16,720 --> 00:38:19,599
because this is actually what allows uh

1007
00:38:19,599 --> 00:38:22,400
the protocol to be asynchronous

1008
00:38:22,400 --> 00:38:24,640
and that's because um

1009
00:38:24,640 --> 00:38:26,960
uh will asynchronous and also

1010
00:38:26,960 --> 00:38:28,480
achieve this immediate decryption

1011
00:38:28,480 --> 00:38:30,000
property

1012
00:38:30,000 --> 00:38:32,079
and that's because each ciphertext will

1013
00:38:32,079 --> 00:38:34,560
have attached to it the corresponding

1014
00:38:34,560 --> 00:38:38,079
index within the epoch and also the

1015
00:38:38,079 --> 00:38:40,000
public ratchet component component of

1016
00:38:40,000 --> 00:38:41,200
the epoch

1017
00:38:41,200 --> 00:38:42,400
okay so

1018
00:38:42,400 --> 00:38:44,240
yeah this is what provides immediate

1019
00:38:44,240 --> 00:38:46,720
decryption and message loss resilience

1020
00:38:46,720 --> 00:38:48,320
because basically

1021
00:38:48,320 --> 00:38:50,640
if the third message of an epoch comes

1022
00:38:50,640 --> 00:38:52,160
first

1023
00:38:52,160 --> 00:38:55,040
the index will tell the receiver and so

1024
00:38:55,040 --> 00:38:56,640
they can just

1025
00:38:56,640 --> 00:38:59,920
uh jump directly to uh the third message

1026
00:38:59,920 --> 00:39:03,280
key via this kdf

1027
00:39:03,440 --> 00:39:04,640
okay

1028
00:39:04,640 --> 00:39:06,480
so yeah hopefully that provides some

1029
00:39:06,480 --> 00:39:08,640
more intuition on how the double ratchet

1030
00:39:08,640 --> 00:39:09,680
works

1031
00:39:09,680 --> 00:39:13,520
um so now let me briefly say some uh

1032
00:39:13,520 --> 00:39:15,599
some of the security properties of

1033
00:39:15,599 --> 00:39:16,560
signal

1034
00:39:16,560 --> 00:39:19,359
uh that weren't captured by prior works

1035
00:39:19,359 --> 00:39:21,680
uh so specifically in our in our paper

1036
00:39:21,680 --> 00:39:22,800
we found

1037
00:39:22,800 --> 00:39:24,800
six distinct ways in which the prior

1038
00:39:24,800 --> 00:39:25,680
works

1039
00:39:25,680 --> 00:39:27,520
uh didn't capture

1040
00:39:27,520 --> 00:39:29,520
uh signal security

1041
00:39:29,520 --> 00:39:33,200
and for ccd 17 this was

1042
00:39:33,200 --> 00:39:34,400
uh

1043
00:39:34,400 --> 00:39:36,800
no bad randomness and no immediate

1044
00:39:36,800 --> 00:39:38,640
decryption in their modeling

1045
00:39:38,640 --> 00:39:41,920
and for acd-19 uh basically they

1046
00:39:41,920 --> 00:39:44,720
provided only course

1047
00:39:44,720 --> 00:39:46,640
security guarantees surrounding state

1048
00:39:46,640 --> 00:39:47,760
leakages

1049
00:39:47,760 --> 00:39:50,400
so for example some messages sent

1050
00:39:50,400 --> 00:39:51,920
immediately after

1051
00:39:51,920 --> 00:39:55,359
a a state leakage

1052
00:39:55,359 --> 00:39:57,359
didn't have any security guarantees in

1053
00:39:57,359 --> 00:39:59,920
their analysis even though uh these

1054
00:39:59,920 --> 00:40:03,200
messages are secure in signal

1055
00:40:03,200 --> 00:40:05,920
okay and both uh didn't fully capture

1056
00:40:05,920 --> 00:40:08,960
also cca security immediately after a

1057
00:40:08,960 --> 00:40:10,640
leakage

1058
00:40:10,640 --> 00:40:15,279
and for this we we realize that

1059
00:40:15,359 --> 00:40:18,160
the double ratchet intuitively needs

1060
00:40:18,160 --> 00:40:20,720
the strong diffie-hellman assumption

1061
00:40:20,720 --> 00:40:22,800
and the random oracle model along with

1062
00:40:22,800 --> 00:40:25,839
cca secure uh aad

1063
00:40:25,839 --> 00:40:27,760
and this is exactly what we need to

1064
00:40:27,760 --> 00:40:31,440
prove cca security for hashtag so this

1065
00:40:31,440 --> 00:40:34,400
kind of makes sense

1066
00:40:34,560 --> 00:40:37,280
uh and yeah so i want to stress that

1067
00:40:37,280 --> 00:40:39,920
although like both of these works sort

1068
00:40:39,920 --> 00:40:42,079
of uh

1069
00:40:42,079 --> 00:40:44,079
did did things that we're doing in our

1070
00:40:44,079 --> 00:40:45,359
paper

1071
00:40:45,359 --> 00:40:47,920
i i think like our our

1072
00:40:47,920 --> 00:40:50,160
fine-grained modular analysis that sort

1073
00:40:50,160 --> 00:40:52,079
of maybe put their works together in

1074
00:40:52,079 --> 00:40:53,200
some sense

1075
00:40:53,200 --> 00:40:55,359
allowed us to have a deeper

1076
00:40:55,359 --> 00:40:58,079
understanding of the protocol and you

1077
00:40:58,079 --> 00:40:59,680
know understand

1078
00:40:59,680 --> 00:41:01,920
uh for which messages we should expect

1079
00:41:01,920 --> 00:41:03,680
to have security

1080
00:41:03,680 --> 00:41:06,880
and so from this we were able to uncover

1081
00:41:06,880 --> 00:41:10,000
a minor weakness of signal

1082
00:41:10,000 --> 00:41:13,760
and also fix it efficiently

1083
00:41:13,760 --> 00:41:15,440
so now i'll

1084
00:41:15,440 --> 00:41:17,359
discuss this weakness

1085
00:41:17,359 --> 00:41:20,079
so let's say that alice is about to

1086
00:41:20,079 --> 00:41:21,839
start a new epoch

1087
00:41:21,839 --> 00:41:24,720
uh and so she has uh the root key sigma

1088
00:41:24,720 --> 00:41:25,440
t

1089
00:41:25,440 --> 00:41:28,400
along with the public ratchet component

1090
00:41:28,400 --> 00:41:31,839
of bob's last step back g x t minus one

1091
00:41:31,839 --> 00:41:34,319
and so shall sam oh okay sorry so let's

1092
00:41:34,319 --> 00:41:36,800
say now she's uh corrupted

1093
00:41:36,800 --> 00:41:39,839
then uh of course this sigma t

1094
00:41:39,839 --> 00:41:42,160
uh is leaked

1095
00:41:42,160 --> 00:41:42,960
but

1096
00:41:42,960 --> 00:41:45,280
if alice has fresh randomness then again

1097
00:41:45,280 --> 00:41:48,000
we expect security for this new epoch

1098
00:41:48,000 --> 00:41:49,920
because one of the inputs to the kdf

1099
00:41:49,920 --> 00:41:51,760
will be secure

1100
00:41:51,760 --> 00:41:53,440
okay and so then namely all these

1101
00:41:53,440 --> 00:41:55,280
messages in this epoch

1102
00:41:55,280 --> 00:41:58,640
we expect security for

1103
00:41:58,640 --> 00:42:00,960
okay and then if we take away this

1104
00:42:00,960 --> 00:42:02,800
corruption

1105
00:42:02,800 --> 00:42:04,960
alice at this point will have deleted

1106
00:42:04,960 --> 00:42:07,599
all keem old key material so again if

1107
00:42:07,599 --> 00:42:10,079
she was corrupted here we expect forward

1108
00:42:10,079 --> 00:42:11,920
security

1109
00:42:11,920 --> 00:42:13,440
okay so all these messages should be

1110
00:42:13,440 --> 00:42:15,760
secure

1111
00:42:15,760 --> 00:42:17,760
so now bob

1112
00:42:17,760 --> 00:42:20,000
on his side once he receives one of

1113
00:42:20,000 --> 00:42:22,960
these uh epoch t messages

1114
00:42:22,960 --> 00:42:26,079
he of course can also uh

1115
00:42:26,079 --> 00:42:28,319
he of course can also derive this sigma

1116
00:42:28,319 --> 00:42:32,000
t plus one and so then when he wants to

1117
00:42:32,000 --> 00:42:33,119
send a new

1118
00:42:33,119 --> 00:42:35,280
start a new epoch he'll again sample

1119
00:42:35,280 --> 00:42:38,960
this new randomness x t plus one

1120
00:42:38,960 --> 00:42:41,760
and derive this g to the x d x c plus

1121
00:42:41,760 --> 00:42:44,240
one share a diffie-hellman key and

1122
00:42:44,240 --> 00:42:47,119
encrypt in much the same way

1123
00:42:47,119 --> 00:42:48,240
and so

1124
00:42:48,240 --> 00:42:51,280
observe that of course alice still needs

1125
00:42:51,280 --> 00:42:52,960
this xt

1126
00:42:52,960 --> 00:42:55,440
secret exponent to be able to decrypt

1127
00:42:55,440 --> 00:42:56,880
bob's next

1128
00:42:56,880 --> 00:42:58,640
epoch messages

1129
00:42:58,640 --> 00:43:00,800
so in fact also this xt will be

1130
00:43:00,800 --> 00:43:03,359
corrupted

1131
00:43:03,359 --> 00:43:05,359
so now if we put together these two

1132
00:43:05,359 --> 00:43:06,960
corruptions

1133
00:43:06,960 --> 00:43:09,200
uh if alice is both corrupted before

1134
00:43:09,200 --> 00:43:10,880
this epoch starts

1135
00:43:10,880 --> 00:43:12,360
and then also um

1136
00:43:12,360 --> 00:43:13,680
[Music]

1137
00:43:13,680 --> 00:43:16,079
at the end of this epoch but importantly

1138
00:43:16,079 --> 00:43:18,720
before she receives the mess

1139
00:43:18,720 --> 00:43:22,160
any message from bob's next epoch

1140
00:43:22,160 --> 00:43:24,160
uh then

1141
00:43:24,160 --> 00:43:25,839
first of all we get this sigma t

1142
00:43:25,839 --> 00:43:27,280
corrupted

1143
00:43:27,280 --> 00:43:30,400
and also we get this x t corrupted

1144
00:43:30,400 --> 00:43:32,160
and so then all of these messages will

1145
00:43:32,160 --> 00:43:34,960
be insecure

1146
00:43:35,200 --> 00:43:38,160
okay so how do we fix this

1147
00:43:38,160 --> 00:43:41,760
first of all i want to mention that acd

1148
00:43:41,760 --> 00:43:43,359
did actually consider a separate

1149
00:43:43,359 --> 00:43:45,119
security notion

1150
00:43:45,119 --> 00:43:47,599
that did prevent this attack

1151
00:43:47,599 --> 00:43:49,200
but not really

1152
00:43:49,200 --> 00:43:50,720
explicitly

1153
00:43:50,720 --> 00:43:52,800
from their modeling

1154
00:43:52,800 --> 00:43:53,680
and

1155
00:43:53,680 --> 00:43:56,720
also uh they achieve this security with

1156
00:43:56,720 --> 00:43:59,599
an extra group element in communication

1157
00:43:59,599 --> 00:44:00,880
per message

1158
00:44:00,880 --> 00:44:04,560
uh whereas we in our fix uh require no

1159
00:44:04,560 --> 00:44:07,119
additional communication and about the

1160
00:44:07,119 --> 00:44:08,960
same computation

1161
00:44:08,960 --> 00:44:12,640
and we call this the triple ratchet

1162
00:44:12,640 --> 00:44:14,960
and we get security from either the

1163
00:44:14,960 --> 00:44:17,599
random oracle model or a circular

1164
00:44:17,599 --> 00:44:19,920
security of elgamal encryption

1165
00:44:19,920 --> 00:44:22,720
and also uh we get some further security

1166
00:44:22,720 --> 00:44:25,119
properties uh which are kind of complex

1167
00:44:25,119 --> 00:44:26,560
to explain so

1168
00:44:26,560 --> 00:44:28,079
uh yeah look at the paper if you're

1169
00:44:28,079 --> 00:44:29,359
interested

1170
00:44:29,359 --> 00:44:31,280
um and also there are further

1171
00:44:31,280 --> 00:44:33,040
applications to

1172
00:44:33,040 --> 00:44:35,119
this updatable public key encryption

1173
00:44:35,119 --> 00:44:38,880
primitive and secure group messaging

1174
00:44:38,880 --> 00:44:41,040
okay so here's our fix so let's say

1175
00:44:41,040 --> 00:44:43,359
we're in the same scenario alice wants

1176
00:44:43,359 --> 00:44:44,960
to start a new epoch

1177
00:44:44,960 --> 00:44:47,280
so she'll do the same thing she'll

1178
00:44:47,280 --> 00:44:49,119
sample some new

1179
00:44:49,119 --> 00:44:51,920
secret exponent

1180
00:44:51,920 --> 00:44:54,240
and derive this shared diffie-hellman

1181
00:44:54,240 --> 00:44:55,119
key

1182
00:44:55,119 --> 00:44:57,520
and put it through the kdf along with

1183
00:44:57,520 --> 00:45:00,319
the shared root key sigma t

1184
00:45:00,319 --> 00:45:02,480
but now in addition

1185
00:45:02,480 --> 00:45:04,720
we'll output this delta t value from the

1186
00:45:04,720 --> 00:45:06,400
kdf

1187
00:45:06,400 --> 00:45:09,040
and alice will simply use this

1188
00:45:09,040 --> 00:45:10,240
to mask

1189
00:45:10,240 --> 00:45:12,960
her secret key xt

1190
00:45:12,960 --> 00:45:14,880
okay and we call this a mini ratchet of

1191
00:45:14,880 --> 00:45:18,560
the of the diffie-hellman secret key

1192
00:45:18,560 --> 00:45:20,000
okay so

1193
00:45:20,000 --> 00:45:21,280
and and now

1194
00:45:21,280 --> 00:45:23,440
uh after she does this she can of course

1195
00:45:23,440 --> 00:45:27,119
forget x t and delta t

1196
00:45:27,520 --> 00:45:30,400
okay and so yeah she'll send in much the

1197
00:45:30,400 --> 00:45:33,200
same way as before and then when bob

1198
00:45:33,200 --> 00:45:35,119
yeah and delete delete her old keys when

1199
00:45:35,119 --> 00:45:36,880
she when she can

1200
00:45:36,880 --> 00:45:38,560
and then uh

1201
00:45:38,560 --> 00:45:41,760
when bob gets one of these messages

1202
00:45:41,760 --> 00:45:44,079
he'll still be able to

1203
00:45:44,079 --> 00:45:45,280
compute

1204
00:45:45,280 --> 00:45:46,880
uh the kdf

1205
00:45:46,880 --> 00:45:49,760
so he'll still get the sigma t plus one

1206
00:45:49,760 --> 00:45:52,720
and also this delta t value okay and so

1207
00:45:52,720 --> 00:45:55,520
he can namely exponentiate the g to the

1208
00:45:55,520 --> 00:45:58,400
x t that he gets from alice with this

1209
00:45:58,400 --> 00:46:01,359
delta t value and so then when he wants

1210
00:46:01,359 --> 00:46:03,200
to start a new epoch

1211
00:46:03,200 --> 00:46:06,400
he can sample some new xt plus one

1212
00:46:06,400 --> 00:46:09,040
derive this new diffie-hellman shared

1213
00:46:09,040 --> 00:46:11,520
key which alice will also be able to

1214
00:46:11,520 --> 00:46:13,520
compute because she has

1215
00:46:13,520 --> 00:46:16,079
x t delta t in her state now

1216
00:46:16,079 --> 00:46:19,920
uh and send as before

1217
00:46:20,240 --> 00:46:20,600
so

1218
00:46:20,600 --> 00:46:22,079
[Music]

1219
00:46:22,079 --> 00:46:24,319
if we look at the corruption scenario

1220
00:46:24,319 --> 00:46:26,079
from before

1221
00:46:26,079 --> 00:46:27,119
the first

1222
00:46:27,119 --> 00:46:29,680
corruption will give the adversary sigma

1223
00:46:29,680 --> 00:46:31,040
t still

1224
00:46:31,040 --> 00:46:33,680
but the second corruption will only give

1225
00:46:33,680 --> 00:46:36,160
the adverse adversary this x t times

1226
00:46:36,160 --> 00:46:37,680
delta t

1227
00:46:37,680 --> 00:46:39,440
uh and so

1228
00:46:39,440 --> 00:46:42,560
uh this g of x t t-minus one xt should

1229
00:46:42,560 --> 00:46:44,000
still be secure

1230
00:46:44,000 --> 00:46:46,640
and so we we still get security for this

1231
00:46:46,640 --> 00:46:49,040
epoch

1232
00:46:49,440 --> 00:46:52,079
okay so yeah again we we solve this

1233
00:46:52,079 --> 00:46:54,880
issue uh with a technique that allows

1234
00:46:54,880 --> 00:46:57,520
for the same communication

1235
00:46:57,520 --> 00:47:01,440
and just a little bit more computation

1236
00:47:01,680 --> 00:47:04,319
okay and so we're happy

1237
00:47:04,319 --> 00:47:06,560
um and yeah so that's about it i think

1238
00:47:06,560 --> 00:47:09,440
i'm probably running low on time so yeah

1239
00:47:09,440 --> 00:47:12,560
i'll just conclude by saying that um

1240
00:47:12,560 --> 00:47:13,359
yeah

1241
00:47:13,359 --> 00:47:15,200
looking at the security of real-world

1242
00:47:15,200 --> 00:47:17,760
crypto systems can be tough

1243
00:47:17,760 --> 00:47:19,920
but if you work hard enough then you can

1244
00:47:19,920 --> 00:47:22,640
really sort of understand

1245
00:47:22,640 --> 00:47:24,319
more the security properties of the

1246
00:47:24,319 --> 00:47:28,720
protocol and maybe uncover these uh

1247
00:47:28,720 --> 00:47:30,880
sort of weaknesses that that we uncover

1248
00:47:30,880 --> 00:47:32,559
in the paper

1249
00:47:32,559 --> 00:47:36,200
so yeah thank you

1250
00:47:41,520 --> 00:47:44,240
yeah thank you alex for the talk um if

1251
00:47:44,240 --> 00:47:46,880
there are any questions uh yeah please

1252
00:47:46,880 --> 00:47:49,200
come to the microphones

1253
00:47:49,200 --> 00:47:51,280
um

1254
00:47:51,280 --> 00:47:55,280
is this going to be a question yes

1255
00:47:59,040 --> 00:48:00,720
yes thank you for the very nice talk

1256
00:48:00,720 --> 00:48:03,200
this is excellent a question with signal

1257
00:48:03,200 --> 00:48:04,480
as it currently stands in their

1258
00:48:04,480 --> 00:48:06,480
implementation keys are not immediately

1259
00:48:06,480 --> 00:48:08,880
deleted in fact at several epochs later

1260
00:48:08,880 --> 00:48:10,720
that they begin to be deleted

1261
00:48:10,720 --> 00:48:12,800
so how does that affect your security

1262
00:48:12,800 --> 00:48:14,000
model here

1263
00:48:14,000 --> 00:48:15,040
uh

1264
00:48:15,040 --> 00:48:16,960
i mean even

1265
00:48:16,960 --> 00:48:18,640
even when

1266
00:48:18,640 --> 00:48:20,960
they know that the keys are

1267
00:48:20,960 --> 00:48:23,040
useless they still keep them around i

1268
00:48:23,040 --> 00:48:25,040
was ignorant not five epochs

1269
00:48:25,040 --> 00:48:26,480
interesting okay

1270
00:48:26,480 --> 00:48:29,119
i was not completely aware of that uh

1271
00:48:29,119 --> 00:48:31,599
yeah i mean i guess we do assume that

1272
00:48:31,599 --> 00:48:34,079
keys are

1273
00:48:34,079 --> 00:48:36,480
deleted basically once

1274
00:48:36,480 --> 00:48:39,119
the protocol knows that they're

1275
00:48:39,119 --> 00:48:41,920
no longer useful so i mean basically we

1276
00:48:41,920 --> 00:48:44,720
only keep around keys

1277
00:48:44,720 --> 00:48:48,000
if they need to be used for decryption i

1278
00:48:48,000 --> 00:48:49,920
guess that's that's what our security

1279
00:48:49,920 --> 00:48:52,079
model requires

1280
00:48:52,079 --> 00:48:54,079
even if there is um

1281
00:48:54,079 --> 00:48:56,800
keys left around would this gain some

1282
00:48:56,800 --> 00:48:58,720
security

1283
00:48:58,720 --> 00:49:00,720
uh you mean this fixed yeah even if they

1284
00:49:00,720 --> 00:49:04,480
aren't deleted um

1285
00:49:05,119 --> 00:49:06,559
yeah i mean i guess maybe i would need

1286
00:49:06,559 --> 00:49:08,480
to know more about the

1287
00:49:08,480 --> 00:49:10,880
implementation details uh even on the

1288
00:49:10,880 --> 00:49:12,800
sender side you're saying that these

1289
00:49:12,800 --> 00:49:15,440
keys are interesting okay yeah i mean

1290
00:49:15,440 --> 00:49:17,440
it's something to look at more than

1291
00:49:17,440 --> 00:49:21,200
definitely yeah i think i don't yeah

1292
00:49:21,200 --> 00:49:23,440
okay any other question maybe one quick

1293
00:49:23,440 --> 00:49:25,680
question from my side i think one of the

1294
00:49:25,680 --> 00:49:28,400
special parts of both of the papers is

1295
00:49:28,400 --> 00:49:32,079
that you used you see models to analyze

1296
00:49:32,079 --> 00:49:35,040
it and both of the works try to

1297
00:49:35,040 --> 00:49:37,599
analyze signal much more uh precisely

1298
00:49:37,599 --> 00:49:39,760
than what prior work did

1299
00:49:39,760 --> 00:49:42,319
from your experience would you say that

1300
00:49:42,319 --> 00:49:45,280
or was was it the purpose that you used

1301
00:49:45,280 --> 00:49:48,480
uc for that and did it help you to uh

1302
00:49:48,480 --> 00:49:50,960
get a more precise uh understanding of

1303
00:49:50,960 --> 00:49:54,160
signal or what's what was the reason um

1304
00:49:54,160 --> 00:49:55,920
yeah i mean i think it's

1305
00:49:55,920 --> 00:49:58,000
maybe a bit more subjective i mean i

1306
00:49:58,000 --> 00:49:59,680
think originally

1307
00:49:59,680 --> 00:50:00,920
we wanted to

1308
00:50:00,920 --> 00:50:02,240
[Music]

1309
00:50:02,240 --> 00:50:04,000
understand

1310
00:50:04,000 --> 00:50:06,160
the security provided by signal in more

1311
00:50:06,160 --> 00:50:07,520
detail because

1312
00:50:07,520 --> 00:50:10,160
yeah we we thought maybe from the prior

1313
00:50:10,160 --> 00:50:13,520
works we were unsure about certain cases

1314
00:50:13,520 --> 00:50:14,960
um

1315
00:50:14,960 --> 00:50:17,839
i think for uc like

1316
00:50:17,839 --> 00:50:19,680
one thing we wanted was maybe

1317
00:50:19,680 --> 00:50:21,200
composability

1318
00:50:21,200 --> 00:50:23,280
for building secure group messaging and

1319
00:50:23,280 --> 00:50:25,599
other things

1320
00:50:25,599 --> 00:50:27,440
but yeah i mean also one could argue

1321
00:50:27,440 --> 00:50:28,640
that

1322
00:50:28,640 --> 00:50:31,040
when you look at things in sort of the

1323
00:50:31,040 --> 00:50:34,319
simulation based paradigm then

1324
00:50:34,319 --> 00:50:36,319
uh you try to

1325
00:50:36,319 --> 00:50:38,000
maybe consider

1326
00:50:38,000 --> 00:50:41,119
a completely uh unrestricted adversary

1327
00:50:41,119 --> 00:50:42,960
first and maybe

1328
00:50:42,960 --> 00:50:43,760
this

1329
00:50:43,760 --> 00:50:44,880
uh

1330
00:50:44,880 --> 00:50:46,000
lets you

1331
00:50:46,000 --> 00:50:48,480
sort of more closely understand the

1332
00:50:48,480 --> 00:50:50,960
security rather than going like the

1333
00:50:50,960 --> 00:50:52,480
other way around and

1334
00:50:52,480 --> 00:50:53,359
sort of

1335
00:50:53,359 --> 00:50:56,880
uh restricting the adversary first

1336
00:50:56,880 --> 00:50:58,720
okay thank you very much let's speak

1337
00:50:58,720 --> 00:51:02,319
let's thank the speaker again

1338
00:51:05,680 --> 00:51:09,520
and we are already at the last talk for

1339
00:51:09,520 --> 00:51:11,760
this session with the title on the

1340
00:51:11,760 --> 00:51:14,720
insider security of mls and this paper

1341
00:51:14,720 --> 00:51:18,960
is by joel alvin daniel yost and mata ma

1342
00:51:18,960 --> 00:51:20,000
sorry

1343
00:51:20,000 --> 00:51:21,839
moulagic

1344
00:51:21,839 --> 00:51:23,599
the talk is by mata

1345
00:51:23,599 --> 00:51:24,880
yeah thank you

1346
00:51:24,880 --> 00:51:25,920
thank you

1347
00:51:25,920 --> 00:51:28,240
i hope you can hear me yeah

1348
00:51:28,240 --> 00:51:30,160
so the general area that we're

1349
00:51:30,160 --> 00:51:32,079
interested in

1350
00:51:32,079 --> 00:51:35,400
doesn't work

1351
00:51:45,839 --> 00:51:47,520
the general area that we're interested

1352
00:51:47,520 --> 00:51:50,480
in is secure group communication

1353
00:51:50,480 --> 00:51:53,040
sometimes called group ratcheting

1354
00:51:53,040 --> 00:51:55,680
and here the goal is to allow a dynamic

1355
00:51:55,680 --> 00:51:57,359
group of parties to exchange

1356
00:51:57,359 --> 00:51:59,760
confidential data over an insecure

1357
00:51:59,760 --> 00:52:01,440
channel

1358
00:52:01,440 --> 00:52:04,160
so examples are well known from the real

1359
00:52:04,160 --> 00:52:07,040
life this includes secure group chats so

1360
00:52:07,040 --> 00:52:08,559
any application that you use to

1361
00:52:08,559 --> 00:52:10,160
communicate with your friends hopefully

1362
00:52:10,160 --> 00:52:11,440
it's secure and then this is part of

1363
00:52:11,440 --> 00:52:13,599
this landscape but you could also

1364
00:52:13,599 --> 00:52:15,680
imagine secure video calls or secure

1365
00:52:15,680 --> 00:52:17,839
conferences that will all be kind of

1366
00:52:17,839 --> 00:52:20,400
part of this landscape

1367
00:52:20,400 --> 00:52:21,920
you could also think of it as

1368
00:52:21,920 --> 00:52:23,520
generalization

1369
00:52:23,520 --> 00:52:26,559
okay some something similar to two-party

1370
00:52:26,559 --> 00:52:28,960
secure messaging which was the topic of

1371
00:52:28,960 --> 00:52:30,800
the previous talk

1372
00:52:30,800 --> 00:52:34,160
similar thing but for groups

1373
00:52:34,800 --> 00:52:37,680
now the core primitive that enables

1374
00:52:37,680 --> 00:52:39,839
secure group communication is in my

1375
00:52:39,839 --> 00:52:42,240
opinion something called continuous

1376
00:52:42,240 --> 00:52:45,119
group key agreement or cgka

1377
00:52:45,119 --> 00:52:47,119
and here the goal kind of sounds similar

1378
00:52:47,119 --> 00:52:49,520
so it's for a dynamic group of parties

1379
00:52:49,520 --> 00:52:50,400
again

1380
00:52:50,400 --> 00:52:53,760
to exchange a sequence of shared

1381
00:52:53,760 --> 00:52:55,680
symmetric group keys

1382
00:52:55,680 --> 00:52:57,599
so i forgot what it means to say dynamic

1383
00:52:57,599 --> 00:52:59,680
well dynamic means that

1384
00:52:59,680 --> 00:53:01,440
the properties of the group such as you

1385
00:53:01,440 --> 00:53:03,520
can think of the members the set of

1386
00:53:03,520 --> 00:53:04,880
members the

1387
00:53:04,880 --> 00:53:07,119
set of administrators

1388
00:53:07,119 --> 00:53:09,520
etc can change within one session so we

1389
00:53:09,520 --> 00:53:11,359
can add remove members

1390
00:53:11,359 --> 00:53:14,000
okay so in cgka the goal is to exchange

1391
00:53:14,000 --> 00:53:16,400
a sequence of shared group keys

1392
00:53:16,400 --> 00:53:19,280
this means that a cgk protocol will

1393
00:53:19,280 --> 00:53:21,760
create a sequence of e-books

1394
00:53:21,760 --> 00:53:24,400
and an e-book is simply a period of time

1395
00:53:24,400 --> 00:53:26,480
when the group has a fixed set of

1396
00:53:26,480 --> 00:53:28,880
properties so you will have the fixed

1397
00:53:28,880 --> 00:53:31,200
membership for example in epoch 1

1398
00:53:31,200 --> 00:53:33,760
and the cgk protocol will equip

1399
00:53:33,760 --> 00:53:36,640
each epoch with a shared group key known

1400
00:53:36,640 --> 00:53:38,480
to the current group members and only

1401
00:53:38,480 --> 00:53:39,440
those

1402
00:53:39,440 --> 00:53:41,040
so that's the goal to establish these

1403
00:53:41,040 --> 00:53:44,559
keys now at any point in time any group

1404
00:53:44,559 --> 00:53:46,880
member can decide to change

1405
00:53:46,880 --> 00:53:48,480
the properties which means that they

1406
00:53:48,480 --> 00:53:49,920
create a new epoch

1407
00:53:49,920 --> 00:53:51,920
for example if alice decides to remove

1408
00:53:51,920 --> 00:53:52,960
charlie

1409
00:53:52,960 --> 00:53:54,880
she will create a new epoch without

1410
00:53:54,880 --> 00:53:56,880
charlie and with a new key unknown to

1411
00:53:56,880 --> 00:53:59,280
charlie

1412
00:53:59,359 --> 00:54:02,400
then it can continue maybe alice adds

1413
00:54:02,400 --> 00:54:04,480
dave in charlie's place this against

1414
00:54:04,480 --> 00:54:07,040
chris creates a new epoch and another

1415
00:54:07,040 --> 00:54:08,880
thing that can happen can happen is that

1416
00:54:08,880 --> 00:54:11,599
bob for example simply decides to up

1417
00:54:11,599 --> 00:54:13,280
update his secrets because they have

1418
00:54:13,280 --> 00:54:15,520
been lying around for too long

1419
00:54:15,520 --> 00:54:17,440
and so this creates again a new epoch

1420
00:54:17,440 --> 00:54:20,880
with a fresh shirt key

1421
00:54:21,599 --> 00:54:22,400
one

1422
00:54:22,400 --> 00:54:23,200
other

1423
00:54:23,200 --> 00:54:25,040
piece of information that is missing

1424
00:54:25,040 --> 00:54:27,680
from this picture is the pki

1425
00:54:27,680 --> 00:54:30,480
the cgka and secure messaging protocols

1426
00:54:30,480 --> 00:54:33,200
usually work in the pki model

1427
00:54:33,200 --> 00:54:36,319
and so the pki will be used for example

1428
00:54:36,319 --> 00:54:39,440
by alice when she adds a new party dave

1429
00:54:39,440 --> 00:54:42,079
to make sure that the public keys she's

1430
00:54:42,079 --> 00:54:45,119
adding to the group or the public data

1431
00:54:45,119 --> 00:54:46,960
actually belongs to today but not to

1432
00:54:46,960 --> 00:54:48,079
someone else

1433
00:54:48,079 --> 00:54:51,040
and vice versa when dave joins the group

1434
00:54:51,040 --> 00:54:53,119
he will also contact the pki to make

1435
00:54:53,119 --> 00:54:54,880
sure that the person inviting him is

1436
00:54:54,880 --> 00:54:56,640
actually alice and not some malicious

1437
00:54:56,640 --> 00:54:59,118
party

1438
00:54:59,680 --> 00:55:00,480
so

1439
00:55:00,480 --> 00:55:02,079
i hope you can

1440
00:55:02,079 --> 00:55:04,960
imagine how cgka can be used to build

1441
00:55:04,960 --> 00:55:08,000
secure group communication applications

1442
00:55:08,000 --> 00:55:10,880
basically the uh shared secrets key

1443
00:55:10,880 --> 00:55:13,440
which is outputted by cgki can be used

1444
00:55:13,440 --> 00:55:14,480
to

1445
00:55:14,480 --> 00:55:16,799
for example encrypt messages in secure

1446
00:55:16,799 --> 00:55:19,040
messaging in secure chats it can be used

1447
00:55:19,040 --> 00:55:20,799
to encrypt video stream or how to

1448
00:55:20,799 --> 00:55:23,599
authenticate group members so really

1449
00:55:23,599 --> 00:55:25,599
this is kind of simple symmetric

1450
00:55:25,599 --> 00:55:28,000
cryptography um

1451
00:55:28,000 --> 00:55:29,920
and so the core of the problem is

1452
00:55:29,920 --> 00:55:32,720
captured by cgka so cgka is what we're

1453
00:55:32,720 --> 00:55:34,640
going to look at

1454
00:55:34,640 --> 00:55:36,400
in this work and in the rest of this

1455
00:55:36,400 --> 00:55:38,640
talk

1456
00:55:39,040 --> 00:55:41,520
now one more thing

1457
00:55:41,520 --> 00:55:43,119
that i want to

1458
00:55:43,119 --> 00:55:45,359
mention about cgka is that the setting

1459
00:55:45,359 --> 00:55:47,280
is kind of

1460
00:55:47,280 --> 00:55:49,520
very particular for this type of

1461
00:55:49,520 --> 00:55:52,000
protocols it's different than

1462
00:55:52,000 --> 00:55:55,440
for example for tls or

1463
00:55:55,440 --> 00:55:57,440
multi-party computation

1464
00:55:57,440 --> 00:55:58,240
so

1465
00:55:58,240 --> 00:56:00,079
first of all we want to be able to deal

1466
00:56:00,079 --> 00:56:02,000
with thousands of parties groups will be

1467
00:56:02,000 --> 00:56:04,880
huge like 5 000 10 000 people in a group

1468
00:56:04,880 --> 00:56:06,720
for example all employees of an

1469
00:56:06,720 --> 00:56:08,960
organization

1470
00:56:08,960 --> 00:56:10,559
this is much different than for example

1471
00:56:10,559 --> 00:56:12,000
tls

1472
00:56:12,000 --> 00:56:13,520
and so the requirement is that the

1473
00:56:13,520 --> 00:56:15,760
protocol needs to be scalable

1474
00:56:15,760 --> 00:56:17,680
in terms of both communication and

1475
00:56:17,680 --> 00:56:19,760
computational complexity ideally it

1476
00:56:19,760 --> 00:56:23,599
should be sublinear in the group size

1477
00:56:23,599 --> 00:56:26,240
another uh aspect is that parties will

1478
00:56:26,240 --> 00:56:28,319
often be offline this is kind of such

1479
00:56:28,319 --> 00:56:30,720
truth in secure messaging if we have

1480
00:56:30,720 --> 00:56:32,400
five thousand people in a group we

1481
00:56:32,400 --> 00:56:34,319
cannot imagine that they will come all

1482
00:56:34,319 --> 00:56:36,720
come online at the same time to execute

1483
00:56:36,720 --> 00:56:38,319
some sort of interactive protocol we

1484
00:56:38,319 --> 00:56:40,160
cannot wait for this

1485
00:56:40,160 --> 00:56:41,359
and so protocols should be

1486
00:56:41,359 --> 00:56:44,160
non-interactive or some or also called

1487
00:56:44,160 --> 00:56:46,000
asynchronous maybe more often in this

1488
00:56:46,000 --> 00:56:48,000
literature

1489
00:56:48,000 --> 00:56:50,079
which basically means that parties

1490
00:56:50,079 --> 00:56:52,480
communicate via a mailboxing service or

1491
00:56:52,480 --> 00:56:54,160
a dead drop

1492
00:56:54,160 --> 00:56:56,559
service where they can just leave

1493
00:56:56,559 --> 00:56:58,480
messages for each other go offline and

1494
00:56:58,480 --> 00:57:01,040
then any party can take the message from

1495
00:57:01,040 --> 00:57:02,960
the mailbox and continue with the

1496
00:57:02,960 --> 00:57:04,160
protocol

1497
00:57:04,160 --> 00:57:06,319
so if you remember the epochs right the

1498
00:57:06,319 --> 00:57:08,319
only thing that i need to do to create a

1499
00:57:08,319 --> 00:57:11,280
new pop is to create one message put it

1500
00:57:11,280 --> 00:57:13,280
in the mailbox maybe i go offline i

1501
00:57:13,280 --> 00:57:15,520
throw away my phone i go to crypto and

1502
00:57:15,520 --> 00:57:17,119
then other people

1503
00:57:17,119 --> 00:57:19,440
at any time can receive take this

1504
00:57:19,440 --> 00:57:23,359
message out of the mailbox and continue

1505
00:57:23,359 --> 00:57:26,799
and finally we have long-lived sessions

1506
00:57:26,799 --> 00:57:28,720
i don't know about your groups but i

1507
00:57:28,720 --> 00:57:30,880
have groups that live like four

1508
00:57:30,880 --> 00:57:32,640
years on end

1509
00:57:32,640 --> 00:57:34,559
and so we want fine-grained security

1510
00:57:34,559 --> 00:57:36,160
within a session

1511
00:57:36,160 --> 00:57:37,280
so this is

1512
00:57:37,280 --> 00:57:39,760
again different than in tls for example

1513
00:57:39,760 --> 00:57:41,280
where it's just the whole session is

1514
00:57:41,280 --> 00:57:43,599
secure the whole session is insecure

1515
00:57:43,599 --> 00:57:45,440
uh here we want fine print security

1516
00:57:45,440 --> 00:57:47,119
within a session

1517
00:57:47,119 --> 00:57:49,440
uh this can be seen in a picture this is

1518
00:57:49,440 --> 00:57:51,440
the same picture as before

1519
00:57:51,440 --> 00:57:54,079
we basically want that if the state of

1520
00:57:54,079 --> 00:57:57,119
some party in this case bob leaks in

1521
00:57:57,119 --> 00:57:59,440
white and pog

1522
00:57:59,440 --> 00:58:01,440
and then some epochs will be secure will

1523
00:58:01,440 --> 00:58:02,640
be insecure

1524
00:58:02,640 --> 00:58:04,799
well because the key is leaked but some

1525
00:58:04,799 --> 00:58:07,440
epochs remain secure so for example the

1526
00:58:07,440 --> 00:58:09,359
past epochs are secured by a property

1527
00:58:09,359 --> 00:58:11,440
called for forward secrecy

1528
00:58:11,440 --> 00:58:14,720
uh and then after bob replaces his

1529
00:58:14,720 --> 00:58:17,280
secrets by his leaked secrets by fresh

1530
00:58:17,280 --> 00:58:19,680
ones that happens in epoch four we get

1531
00:58:19,680 --> 00:58:21,280
security back this is called post

1532
00:58:21,280 --> 00:58:24,319
compromise security

1533
00:58:24,559 --> 00:58:27,040
so i hope this kind of convinces you

1534
00:58:27,040 --> 00:58:28,480
that um

1535
00:58:28,480 --> 00:58:31,280
cgka is worth studying and kind of shows

1536
00:58:31,280 --> 00:58:34,079
you roughly what what it does so this

1537
00:58:34,079 --> 00:58:36,799
brings me to our contribution

1538
00:58:36,799 --> 00:58:41,280
which actually follows a pattern that

1539
00:58:41,280 --> 00:58:43,760
all of you here are very familiar

1540
00:58:43,760 --> 00:58:46,319
are extreme extremely familiar with we

1541
00:58:46,319 --> 00:58:49,200
take a real world construction in our

1542
00:58:49,200 --> 00:58:50,880
case called itk

1543
00:58:50,880 --> 00:58:54,079
just the name of the protocol

1544
00:58:54,240 --> 00:58:56,400
we take a

1545
00:58:56,400 --> 00:58:59,359
very important primitive in our case gka

1546
00:58:59,359 --> 00:59:01,839
and we prove that the protocol idk is a

1547
00:59:01,839 --> 00:59:04,720
secure cgka in a strong adversarial

1548
00:59:04,720 --> 00:59:06,640
model in our case we call it malicious

1549
00:59:06,640 --> 00:59:07,920
insiders

1550
00:59:07,920 --> 00:59:10,559
so this is a new model it's based on on

1551
00:59:10,559 --> 00:59:12,480
previous models of course

1552
00:59:12,480 --> 00:59:14,640
but it has some nice aspects that

1553
00:59:14,640 --> 00:59:17,440
improve on the previous models and

1554
00:59:17,440 --> 00:59:20,960
give new security guarantees

1555
00:59:21,040 --> 00:59:22,640
so in the rest of this talk i'm going to

1556
00:59:22,640 --> 00:59:25,520
tell you about uh where idk comes from

1557
00:59:25,520 --> 00:59:28,640
and what we prove about it

1558
00:59:28,640 --> 00:59:30,400
except of course life is never that

1559
00:59:30,400 --> 00:59:33,040
simple so in fact in our analysis we

1560
00:59:33,040 --> 00:59:34,559
discovered real attacks against the

1561
00:59:34,559 --> 00:59:35,760
protocol

1562
00:59:35,760 --> 00:59:38,319
as it stood then

1563
00:59:38,319 --> 00:59:40,480
which actually broke it in in reality

1564
00:59:40,480 --> 00:59:42,559
and so we proposed fixes fortunately it

1565
00:59:42,559 --> 00:59:45,920
was easy to fix so now the idk is fixed

1566
00:59:45,920 --> 00:59:47,920
and therefore this is the the result of

1567
00:59:47,920 --> 00:59:50,880
this work the itk is the fixed i2k it's

1568
00:59:50,880 --> 00:59:55,200
a security against malicious insiders

1569
00:59:55,280 --> 00:59:59,280
so now uh where does it cave come from

1570
00:59:59,280 --> 01:00:01,760
it's a part of a protocol called

1571
01:00:01,760 --> 01:00:05,040
messaging layer security or mls

1572
01:00:05,040 --> 01:00:08,720
this is basically a messaging protocol

1573
01:00:08,720 --> 01:00:12,000
it is based on a cgka but it also has a

1574
01:00:12,000 --> 01:00:14,240
functionality really related to

1575
01:00:14,240 --> 01:00:15,440
messaging

1576
01:00:15,440 --> 01:00:18,640
it's an upcoming rfc standards

1577
01:00:18,640 --> 01:00:19,839
and it has

1578
01:00:19,839 --> 01:00:22,079
so it's really a real world protocol

1579
01:00:22,079 --> 01:00:23,920
that will be implemented that is already

1580
01:00:23,920 --> 01:00:26,000
being implemented

1581
01:00:26,000 --> 01:00:26,880
and

1582
01:00:26,880 --> 01:00:28,960
it has lots of nice features i think the

1583
01:00:28,960 --> 01:00:31,520
most important one it has is that it has

1584
01:00:31,520 --> 01:00:34,319
a communication complexity that usually

1585
01:00:34,319 --> 01:00:38,240
scales logarithmically in the group size

1586
01:00:38,240 --> 01:00:40,799
and a disclaimer here usually is not a

1587
01:00:40,799 --> 01:00:42,400
scientific term

1588
01:00:42,400 --> 01:00:44,160
in fact the worst case

1589
01:00:44,160 --> 01:00:47,040
worst case com complexity is linear in

1590
01:00:47,040 --> 01:00:49,040
the group size but there are good

1591
01:00:49,040 --> 01:00:50,559
indications that it will scale

1592
01:00:50,559 --> 01:00:53,520
algorithmically in most of the cases

1593
01:00:53,520 --> 01:00:55,839
so in any case this is a cool protocol

1594
01:00:55,839 --> 01:00:57,359
it's worth to look at it's being

1595
01:00:57,359 --> 01:01:00,079
implemented and used

1596
01:01:00,079 --> 01:01:01,440
now

1597
01:01:01,440 --> 01:01:03,280
itk

1598
01:01:03,280 --> 01:01:06,079
here the name stands for insider secure

1599
01:01:06,079 --> 01:01:09,119
tricom and it's basically the cgka of

1600
01:01:09,119 --> 01:01:11,599
the mls protocol

1601
01:01:11,599 --> 01:01:14,640
it contains those mls components that

1602
01:01:14,640 --> 01:01:16,160
make up its

1603
01:01:16,160 --> 01:01:17,520
hcgk

1604
01:01:17,520 --> 01:01:19,599
so first of all the the most important

1605
01:01:19,599 --> 01:01:22,160
component is tricham this is simply

1606
01:01:22,160 --> 01:01:25,440
mls's name for the core of its gk that's

1607
01:01:25,440 --> 01:01:28,240
why we call it um insert this insider

1608
01:01:28,240 --> 01:01:29,599
secure tricom

1609
01:01:29,599 --> 01:01:31,119
but also other

1610
01:01:31,119 --> 01:01:33,440
mechanisms of mls that are actually

1611
01:01:33,440 --> 01:01:34,880
needed to get the

1612
01:01:34,880 --> 01:01:36,720
right security notion

1613
01:01:36,720 --> 01:01:39,200
of uh for the group keys that that we

1614
01:01:39,200 --> 01:01:40,000
want

1615
01:01:40,000 --> 01:01:41,520
so for example message signing

1616
01:01:41,520 --> 01:01:45,440
transcript hashes various tags etc

1617
01:01:45,440 --> 01:01:46,319
uh

1618
01:01:46,319 --> 01:01:50,400
just this short remark is that we

1619
01:01:50,400 --> 01:01:53,200
isolating these components of mls from

1620
01:01:53,200 --> 01:01:55,920
the rfc specification was not an easy

1621
01:01:55,920 --> 01:01:56,799
task

1622
01:01:56,799 --> 01:01:58,799
uh or maybe less easy than you might

1623
01:01:58,799 --> 01:02:01,280
imagine we went through it we have a

1624
01:02:01,280 --> 01:02:03,440
precise to the code description in of

1625
01:02:03,440 --> 01:02:05,440
idk in the paper so if you're struggling

1626
01:02:05,440 --> 01:02:07,440
with the rfc that might be a resource

1627
01:02:07,440 --> 01:02:09,760
that helps you

1628
01:02:09,760 --> 01:02:10,720
um

1629
01:02:10,720 --> 01:02:12,559
okay so this is all i want to say about

1630
01:02:12,559 --> 01:02:14,559
itk i don't want to say anything about

1631
01:02:14,559 --> 01:02:17,520
how it works it's quite complex you can

1632
01:02:17,520 --> 01:02:20,079
imagine probably i want to tell you in

1633
01:02:20,079 --> 01:02:21,440
the rest of this

1634
01:02:21,440 --> 01:02:23,599
of the stop what we prove about it

1635
01:02:23,599 --> 01:02:25,839
so what is this

1636
01:02:25,839 --> 01:02:28,160
what is the security statement

1637
01:02:28,160 --> 01:02:29,359
in

1638
01:02:29,359 --> 01:02:32,000
at a high level

1639
01:02:32,160 --> 01:02:34,160
so if you want to if we want to define

1640
01:02:34,160 --> 01:02:36,640
security we of course have to start with

1641
01:02:36,640 --> 01:02:38,960
the attacker capabilities

1642
01:02:38,960 --> 01:02:40,160
here uh

1643
01:02:40,160 --> 01:02:42,319
the adversary is super strong first of

1644
01:02:42,319 --> 01:02:44,240
all it can continuously leak the states

1645
01:02:44,240 --> 01:02:45,520
of parties

1646
01:02:45,520 --> 01:02:47,280
recall that we want this

1647
01:02:47,280 --> 01:02:49,200
fine green security where the state can

1648
01:02:49,200 --> 01:02:51,839
leak at one point in time and then maybe

1649
01:02:51,839 --> 01:02:54,079
parties refresh their secrets

1650
01:02:54,079 --> 01:02:56,720
uh end up in a secure state then the

1651
01:02:56,720 --> 01:02:58,720
states leak again and so on so this is

1652
01:02:58,720 --> 01:03:02,400
what continuous means in this case

1653
01:03:02,400 --> 01:03:04,319
further the adversary has full control

1654
01:03:04,319 --> 01:03:06,720
over the network no restrictions

1655
01:03:06,720 --> 01:03:09,200
uh it can even control the pki we don't

1656
01:03:09,200 --> 01:03:11,119
even trust the pki

1657
01:03:11,119 --> 01:03:13,119
and finally it can control randomness

1658
01:03:13,119 --> 01:03:15,520
used by parties so this models bad's

1659
01:03:15,520 --> 01:03:18,720
randomness generators

1660
01:03:19,200 --> 01:03:21,760
this is the adversary now what security

1661
01:03:21,760 --> 01:03:24,640
do we want with this adversary

1662
01:03:24,640 --> 01:03:27,359
in our paper we use the universal

1663
01:03:27,359 --> 01:03:30,240
composability or uc framework by

1664
01:03:30,240 --> 01:03:32,400
connecting and so with this means that

1665
01:03:32,400 --> 01:03:35,039
we define an idea as a gka functionality

1666
01:03:35,039 --> 01:03:36,880
which expresses all the properties that

1667
01:03:36,880 --> 01:03:39,520
a good cgk should have

1668
01:03:39,520 --> 01:03:42,400
except i think it's too complicated for

1669
01:03:42,400 --> 01:03:45,440
this talk so i'm just going to tell you

1670
01:03:45,440 --> 01:03:47,200
about a couple of properties that are

1671
01:03:47,200 --> 01:03:49,440
implied by this definition so first of

1672
01:03:49,440 --> 01:03:51,440
all it captures correctness

1673
01:03:51,440 --> 01:03:54,000
this is what you might expect

1674
01:03:54,000 --> 01:03:56,000
more importantly it captures the

1675
01:03:56,000 --> 01:03:58,000
security properties which is agreement

1676
01:03:58,000 --> 01:04:00,480
on the group stage confidentiality of

1677
01:04:00,480 --> 01:04:04,559
group keys and authenticity of messages

1678
01:04:04,640 --> 01:04:07,440
in a bit more detail

1679
01:04:07,440 --> 01:04:09,839
agreement on the group stage means that

1680
01:04:09,839 --> 01:04:12,799
all members in a given epoch agree on

1681
01:04:12,799 --> 01:04:14,799
the current properties of the group as i

1682
01:04:14,799 --> 01:04:16,319
said they can change dynamically in

1683
01:04:16,319 --> 01:04:18,559
epoch in each epoch they're different

1684
01:04:18,559 --> 01:04:20,559
and so they they have the same set of

1685
01:04:20,559 --> 01:04:23,280
members they know the same group key and

1686
01:04:23,280 --> 01:04:25,680
they also agree on the last epoch which

1687
01:04:25,680 --> 01:04:27,359
by induction means that they agree on

1688
01:04:27,359 --> 01:04:29,280
the whole

1689
01:04:29,280 --> 01:04:31,920
sequence of epochs leading to this given

1690
01:04:31,920 --> 01:04:34,079
one

1691
01:04:34,079 --> 01:04:36,880
really a basic property

1692
01:04:36,880 --> 01:04:40,000
one other thing that has to be here is

1693
01:04:40,000 --> 01:04:42,319
that recall that

1694
01:04:42,319 --> 01:04:45,200
that the cgk protocols

1695
01:04:45,200 --> 01:04:47,359
live in the pki

1696
01:04:47,359 --> 01:04:49,839
model so there is some pki and so the

1697
01:04:49,839 --> 01:04:52,160
members will be identified by some pki

1698
01:04:52,160 --> 01:04:54,480
keys so we also want agreement on that

1699
01:04:54,480 --> 01:04:56,960
right we have some pka identities

1700
01:04:56,960 --> 01:04:58,319
here alice bob and charlie are

1701
01:04:58,319 --> 01:05:00,960
identified by some

1702
01:05:00,960 --> 01:05:03,119
public keys and we want agreement on

1703
01:05:03,119 --> 01:05:04,640
that and this is something we introduced

1704
01:05:04,640 --> 01:05:06,240
in this model so this is new in our

1705
01:05:06,240 --> 01:05:09,119
insider model

1706
01:05:09,119 --> 01:05:10,960
this is agreement now for

1707
01:05:10,960 --> 01:05:13,520
confidentiality this is maybe what you

1708
01:05:13,520 --> 01:05:16,960
might expect even more than agreement

1709
01:05:16,960 --> 01:05:18,880
we want that the group key in a given

1710
01:05:18,880 --> 01:05:22,160
epoch e is indistinguishable from random

1711
01:05:22,160 --> 01:05:23,839
uniformed random string from the point

1712
01:05:23,839 --> 01:05:26,400
of view of the adversary

1713
01:05:26,400 --> 01:05:28,559
of course given corruptions

1714
01:05:28,559 --> 01:05:31,119
this cannot be true in all epochs so we

1715
01:05:31,119 --> 01:05:34,319
will use a predicate here called conf

1716
01:05:34,319 --> 01:05:36,400
which takes an epoch with all its

1717
01:05:36,400 --> 01:05:38,160
properties

1718
01:05:38,160 --> 01:05:40,960
like the set of members the pki keys etc

1719
01:05:40,960 --> 01:05:42,640
and a symbolic representation of

1720
01:05:42,640 --> 01:05:45,359
executions including corruptions

1721
01:05:45,359 --> 01:05:48,319
all epochs that have been created etc

1722
01:05:48,319 --> 01:05:51,760
and it decides if the if authenticity is

1723
01:05:51,760 --> 01:05:54,880
guaranteed in this epoch or not

1724
01:05:54,880 --> 01:05:57,760
so in the picture this is again the same

1725
01:05:57,760 --> 01:05:59,920
picture as before if the state of some

1726
01:05:59,920 --> 01:06:02,000
party leaks in epoch 2

1727
01:06:02,000 --> 01:06:03,920
the predicate will be false in epochs

1728
01:06:03,920 --> 01:06:05,839
two and three this means that the keys

1729
01:06:05,839 --> 01:06:08,319
are arbitrary the adversary chooses them

1730
01:06:08,319 --> 01:06:10,559
but it will be true in epochs one and

1731
01:06:10,559 --> 01:06:11,359
four

1732
01:06:11,359 --> 01:06:14,480
uh meaning that the keys in epoch one

1733
01:06:14,480 --> 01:06:16,799
and four look random and independent

1734
01:06:16,799 --> 01:06:20,160
from the devil's point of view

1735
01:06:20,559 --> 01:06:22,799
so this is a confidentiality and for

1736
01:06:22,799 --> 01:06:24,160
authenticity

1737
01:06:24,160 --> 01:06:25,039
um

1738
01:06:25,039 --> 01:06:26,319
this is again

1739
01:06:26,319 --> 01:06:27,839
probably expected

1740
01:06:27,839 --> 01:06:30,160
it says that the adversary can't

1741
01:06:30,160 --> 01:06:35,118
impersonate a party p in a given epoch

1742
01:06:35,280 --> 01:06:37,520
hopefully for all parties in epochs but

1743
01:06:37,520 --> 01:06:39,200
of course we cannot guarantee this

1744
01:06:39,200 --> 01:06:40,720
during corruptions

1745
01:06:40,720 --> 01:06:43,200
uh due to corruptions so

1746
01:06:43,200 --> 01:06:45,119
we will have an authenticity predicate

1747
01:06:45,119 --> 01:06:47,280
here called out which takes an epoch and

1748
01:06:47,280 --> 01:06:49,440
a party and again a symbolic

1749
01:06:49,440 --> 01:06:51,119
representation of an execution and

1750
01:06:51,119 --> 01:06:54,880
decides if authenticity is guaranteed

1751
01:06:54,880 --> 01:06:57,039
a couple of remarks about these conf and

1752
01:06:57,039 --> 01:06:58,880
health predicates

1753
01:06:58,880 --> 01:07:00,960
is that these are actually parameters of

1754
01:07:00,960 --> 01:07:02,160
the notion

1755
01:07:02,160 --> 01:07:04,480
and so the goal of a protocol designer

1756
01:07:04,480 --> 01:07:06,160
is to get the best content out

1757
01:07:06,160 --> 01:07:09,039
predicates uh possible as they can

1758
01:07:09,039 --> 01:07:10,079
somehow

1759
01:07:10,079 --> 01:07:12,480
so one of our contributions in this work

1760
01:07:12,480 --> 01:07:13,520
is to

1761
01:07:13,520 --> 01:07:15,760
exactly define the predicates for the

1762
01:07:15,760 --> 01:07:18,880
itk protocol

1763
01:07:19,440 --> 01:07:21,599
again to complicate it i won't

1764
01:07:21,599 --> 01:07:23,119
explain them in full detail in this

1765
01:07:23,119 --> 01:07:24,720
paper

1766
01:07:24,720 --> 01:07:27,920
instead what i want to show is uh

1767
01:07:27,920 --> 01:07:30,240
so this concludes the the security

1768
01:07:30,240 --> 01:07:32,000
properties that we want

1769
01:07:32,000 --> 01:07:34,079
i want to show you a couple of examples

1770
01:07:34,079 --> 01:07:36,559
to maybe get you more familiar with how

1771
01:07:36,559 --> 01:07:37,920
it works

1772
01:07:37,920 --> 01:07:38,880
and

1773
01:07:38,880 --> 01:07:42,240
what security we prove for ipk in what

1774
01:07:42,240 --> 01:07:44,720
cases in what scenarios we prosecute

1775
01:07:44,720 --> 01:07:46,480
prove it secure

1776
01:07:46,480 --> 01:07:48,400
so the first special case is about

1777
01:07:48,400 --> 01:07:50,079
injected epochs

1778
01:07:50,079 --> 01:07:52,960
it showcases what an active network

1779
01:07:52,960 --> 01:07:55,280
adversary can do

1780
01:07:55,280 --> 01:07:57,039
so let's say we have an epoch where the

1781
01:07:57,039 --> 01:07:58,640
state of bob leakes

1782
01:07:58,640 --> 01:08:00,559
some some epoch

1783
01:08:00,559 --> 01:08:01,920
in this epoch

1784
01:08:01,920 --> 01:08:03,760
so we will focus on the conf predicates

1785
01:08:03,760 --> 01:08:05,200
now because it doesn't matter which

1786
01:08:05,200 --> 01:08:06,559
predicate it is

1787
01:08:06,559 --> 01:08:07,440
um

1788
01:08:07,440 --> 01:08:09,200
the conf predicate will be false in this

1789
01:08:09,200 --> 01:08:11,760
epoch and now the state of box bob is

1790
01:08:11,760 --> 01:08:13,440
completely leaked to the adversary so

1791
01:08:13,440 --> 01:08:15,839
what the adversary can do

1792
01:08:15,839 --> 01:08:17,759
controlling the network is to come up

1793
01:08:17,759 --> 01:08:19,920
with some random message and inject it

1794
01:08:19,920 --> 01:08:21,759
on bob's behalf right

1795
01:08:21,759 --> 01:08:24,799
and let's say he does that this creates

1796
01:08:24,799 --> 01:08:27,120
a new epoch

1797
01:08:27,120 --> 01:08:29,040
maybe it's

1798
01:08:29,040 --> 01:08:30,399
interpreted as

1799
01:08:30,399 --> 01:08:33,198
after bob updating his his secrets but

1800
01:08:33,198 --> 01:08:35,359
the epoch is completely made up by the

1801
01:08:35,359 --> 01:08:36,839
adversary in his

1802
01:08:36,839 --> 01:08:40,080
head right we cannot say anything about

1803
01:08:40,080 --> 01:08:42,158
it maybe the adversary copy-pasted

1804
01:08:42,158 --> 01:08:44,080
something he saw on the network maybe it

1805
01:08:44,080 --> 01:08:45,520
made up some

1806
01:08:45,520 --> 01:08:47,279
uh some random data

1807
01:08:47,279 --> 01:08:48,319
so again

1808
01:08:48,319 --> 01:08:53,198
yeah the epoch is is completely made up

1809
01:08:53,198 --> 01:08:55,359
and but then the the execution can

1810
01:08:55,359 --> 01:08:57,279
continue right so the adversary injected

1811
01:08:57,279 --> 01:08:59,759
this message to alice and charlie bob

1812
01:08:59,759 --> 01:09:02,880
probably cannot go to the message to the

1813
01:09:02,880 --> 01:09:05,439
epoch created on his behalf but alice

1814
01:09:05,439 --> 01:09:07,839
and charlie are in epoch e plus one and

1815
01:09:07,839 --> 01:09:10,158
so what the what can happen next is that

1816
01:09:10,158 --> 01:09:12,479
alice maybe decides to remove bob maybe

1817
01:09:12,479 --> 01:09:14,880
bob behaves strange she suspects he's

1818
01:09:14,880 --> 01:09:17,120
corrupted so she behave removes sport

1819
01:09:17,120 --> 01:09:19,279
and then we want security back so conf

1820
01:09:19,279 --> 01:09:21,040
becomes true because we have two parties

1821
01:09:21,040 --> 01:09:23,359
with good states and no party with bad

1822
01:09:23,359 --> 01:09:24,319
state

1823
01:09:24,319 --> 01:09:27,120
so this kind of shows that the protocol

1824
01:09:27,120 --> 01:09:28,960
needs to be kind of very resilient

1825
01:09:28,960 --> 01:09:31,759
against these malformed messages we went

1826
01:09:31,759 --> 01:09:33,759
through a body book created completely

1827
01:09:33,759 --> 01:09:35,679
by the adversary and ended up in a good

1828
01:09:35,679 --> 01:09:38,480
epoch afterwards

1829
01:09:38,960 --> 01:09:41,439
this also makes it hard to define

1830
01:09:41,439 --> 01:09:42,560
by the way

1831
01:09:42,560 --> 01:09:44,960
the second example is about detached

1832
01:09:44,960 --> 01:09:46,560
ebooks

1833
01:09:46,560 --> 01:09:49,439
and this showcases what

1834
01:09:49,439 --> 01:09:53,759
our modeling of pki can express

1835
01:09:53,920 --> 01:09:57,520
so let's say again we have an adversary

1836
01:09:57,520 --> 01:09:59,360
who injects a message

1837
01:09:59,360 --> 01:10:01,360
but instead of injecting a message to

1838
01:10:01,360 --> 01:10:03,440
some group members it injects a message

1839
01:10:03,440 --> 01:10:07,679
to a new joining party in this case c so

1840
01:10:07,679 --> 01:10:08,480
on

1841
01:10:08,480 --> 01:10:10,800
on behalf of bob the adversary adds c to

1842
01:10:10,800 --> 01:10:14,239
the group and injects the message to c

1843
01:10:14,239 --> 01:10:15,840
this creates a completely new epoch

1844
01:10:15,840 --> 01:10:17,199
maybe it's completely fake doesn't

1845
01:10:17,199 --> 01:10:18,880
belong anywhere we don't even know what

1846
01:10:18,880 --> 01:10:21,120
epoch was before that because well the

1847
01:10:21,120 --> 01:10:23,040
epoch given epoch doesn't contain all

1848
01:10:23,040 --> 01:10:26,719
the information about all plastic box

1849
01:10:26,719 --> 01:10:29,199
a completely fake epoch

1850
01:10:29,199 --> 01:10:30,800
in this epoch we have

1851
01:10:30,800 --> 01:10:32,719
corrupted bob who invited charlie we

1852
01:10:32,719 --> 01:10:34,719
have honest charlie who joins the group

1853
01:10:34,719 --> 01:10:36,800
and we have alice who we don't really

1854
01:10:36,800 --> 01:10:38,880
know anything about

1855
01:10:38,880 --> 01:10:40,560
and then it can continue as before

1856
01:10:40,560 --> 01:10:42,640
charlie can remove bob

1857
01:10:42,640 --> 01:10:45,120
and then we end up in a new epoch when

1858
01:10:45,120 --> 01:10:47,440
where there is no corrupt bob anymore

1859
01:10:47,440 --> 01:10:49,600
there is an honest charlie but we can't

1860
01:10:49,600 --> 01:10:51,040
really say anything about the counter

1861
01:10:51,040 --> 01:10:52,640
predicate here here in this epoch

1862
01:10:52,640 --> 01:10:55,440
because we don't know what about alice

1863
01:10:55,440 --> 01:10:57,520
is she made up for the adversary or is

1864
01:10:57,520 --> 01:10:58,560
she

1865
01:10:58,560 --> 01:11:00,560
is her state somehow copied from another

1866
01:11:00,560 --> 01:11:02,400
part of the execution where she created

1867
01:11:02,400 --> 01:11:04,159
something we can't say

1868
01:11:04,159 --> 01:11:06,800
so before our modeling of pki in this

1869
01:11:06,800 --> 01:11:08,960
work or we could say well we couldn't

1870
01:11:08,960 --> 01:11:10,880
say anything so con would have to be

1871
01:11:10,880 --> 01:11:12,800
false here

1872
01:11:12,800 --> 01:11:15,600
now with our modeling

1873
01:11:15,600 --> 01:11:17,920
uh we recall that we have the public

1874
01:11:17,920 --> 01:11:19,440
keys

1875
01:11:19,440 --> 01:11:21,280
in each box so we have the public key of

1876
01:11:21,280 --> 01:11:23,280
alice the public key of charlie the

1877
01:11:23,280 --> 01:11:26,320
probably corrupt public here bob and now

1878
01:11:26,320 --> 01:11:28,640
in epoch plus one let's say the public

1879
01:11:28,640 --> 01:11:30,719
key of alice is is honest it's not

1880
01:11:30,719 --> 01:11:33,199
corrupted we keep track of which pki

1881
01:11:33,199 --> 01:11:35,679
keys are injected or

1882
01:11:35,679 --> 01:11:38,400
are created or leaked by the adversary

1883
01:11:38,400 --> 01:11:41,040
let's say this key has not been leaked

1884
01:11:41,040 --> 01:11:41,840
or

1885
01:11:41,840 --> 01:11:45,040
created by the adversary we have bob uh

1886
01:11:45,040 --> 01:11:47,280
with secure key

1887
01:11:47,280 --> 01:11:49,679
and so the guarantee is that the conf

1888
01:11:49,679 --> 01:11:53,120
predicate is true if all pki keys are

1889
01:11:53,120 --> 01:11:54,880
good

1890
01:11:54,880 --> 01:11:57,120
there is a then at the end but uh yes so

1891
01:11:57,120 --> 01:11:59,440
if uh the con conf predicate is true if

1892
01:11:59,440 --> 01:12:01,679
opki keys in a given epoch is good which

1893
01:12:01,679 --> 01:12:04,239
allows us to uh deem this last epoch

1894
01:12:04,239 --> 01:12:06,239
secure while in previous models we

1895
01:12:06,239 --> 01:12:08,320
couldn't say anything about it and so

1896
01:12:08,320 --> 01:12:12,080
this is the guarantee that the fixed idk

1897
01:12:12,080 --> 01:12:14,559
provides

1898
01:12:15,040 --> 01:12:16,320
so

1899
01:12:16,320 --> 01:12:18,960
this which brings me to to the fix and

1900
01:12:18,960 --> 01:12:20,800
again i want to tell you what the fix is

1901
01:12:20,800 --> 01:12:24,080
but the previous itk provided a much

1902
01:12:24,080 --> 01:12:27,280
weaker guarantee in this setting

1903
01:12:27,280 --> 01:12:28,960
which is to say that

1904
01:12:28,960 --> 01:12:31,440
the conf predicate is true if each pki

1905
01:12:31,440 --> 01:12:34,320
key in a given epoch is good

1906
01:12:34,320 --> 01:12:38,480
and is only used in other good epochs

1907
01:12:38,480 --> 01:12:41,440
okay so for example if there is another

1908
01:12:41,440 --> 01:12:42,560
epoch

1909
01:12:42,560 --> 01:12:43,360
where

1910
01:12:43,360 --> 01:12:46,159
alice used

1911
01:12:47,280 --> 01:12:49,120
that should be uh the other way around

1912
01:12:49,120 --> 01:12:50,880
so i think

1913
01:12:50,880 --> 01:12:53,280
yeah whatever so uh

1914
01:12:53,280 --> 01:12:56,239
alice okay yeah that's correct sorry

1915
01:12:56,239 --> 01:12:58,000
so if there is another epoch where there

1916
01:12:58,000 --> 01:13:00,640
is some where alice used her good pki

1917
01:13:00,640 --> 01:13:03,760
key with some other party

1918
01:13:03,760 --> 01:13:05,679
let's say i don't know

1919
01:13:05,679 --> 01:13:09,840
party z who used the pki pk5 and pk5

1920
01:13:09,840 --> 01:13:12,239
turned out to be bad then it doesn't

1921
01:13:12,239 --> 01:13:14,320
matter that alice's key is good we still

1922
01:13:14,320 --> 01:13:16,480
have to deem the the new epoch and

1923
01:13:16,480 --> 01:13:18,480
secure so this is a much weaker

1924
01:13:18,480 --> 01:13:20,719
guarantee and after our fix we get the

1925
01:13:20,719 --> 01:13:22,880
expected guarantee that i said in the

1926
01:13:22,880 --> 01:13:25,520
previous slide

1927
01:13:26,400 --> 01:13:28,239
right so this is this was not captured

1928
01:13:28,239 --> 01:13:29,840
by previous models because they were not

1929
01:13:29,840 --> 01:13:32,560
fine-grained enough

1930
01:13:32,560 --> 01:13:33,440
so

1931
01:13:33,440 --> 01:13:35,280
finally to put it in in a bit of

1932
01:13:35,280 --> 01:13:37,760
perspective uh this is the these are the

1933
01:13:37,760 --> 01:13:40,239
models that have analyzed mls

1934
01:13:40,239 --> 01:13:41,360
first one

1935
01:13:41,360 --> 01:13:43,040
and i think the biggest difference

1936
01:13:43,040 --> 01:13:45,120
between these models is how strong the

1937
01:13:45,120 --> 01:13:47,120
adversary is with respect to being able

1938
01:13:47,120 --> 01:13:49,280
to inject messages or not so the first

1939
01:13:49,280 --> 01:13:52,080
ones is it's passive it makes sense to

1940
01:13:52,080 --> 01:13:53,840
relax the pro the

1941
01:13:53,840 --> 01:13:55,040
um

1942
01:13:55,040 --> 01:13:58,400
model in this first works the adversary

1943
01:13:58,400 --> 01:14:01,600
cannot inject anything

1944
01:14:01,600 --> 01:14:04,320
then we have a semi-active adversary or

1945
01:14:04,320 --> 01:14:06,640
what i'm going to call semi-active here

1946
01:14:06,640 --> 01:14:08,719
the adversary can try to inject messages

1947
01:14:08,719 --> 01:14:10,640
but only when the protocol is supposed

1948
01:14:10,640 --> 01:14:12,800
to defend against it

1949
01:14:12,800 --> 01:14:14,880
so only when the out predicate is false

1950
01:14:14,880 --> 01:14:16,239
which means that these injections

1951
01:14:16,239 --> 01:14:17,360
actually won't happen because the

1952
01:14:17,360 --> 01:14:19,600
protocol protects against them and

1953
01:14:19,600 --> 01:14:21,920
actually both of these special cases

1954
01:14:21,920 --> 01:14:24,480
that i just mentioned are mentioned are

1955
01:14:24,480 --> 01:14:27,840
outside of the semi-active model

1956
01:14:27,840 --> 01:14:29,440
then there is the active model where the

1957
01:14:29,440 --> 01:14:32,239
adversary can inject but there is no pki

1958
01:14:32,239 --> 01:14:34,400
modeling this is the model we use at the

1959
01:14:34,400 --> 01:14:36,719
basis of our work but it hasn't been

1960
01:14:36,719 --> 01:14:39,520
used to analyze idk or mls

1961
01:14:39,520 --> 01:14:41,520
and finally our model where

1962
01:14:41,520 --> 01:14:43,840
the adversary fully controls the network

1963
01:14:43,840 --> 01:14:46,560
can inject messages and uh control the

1964
01:14:46,560 --> 01:14:48,480
pki and we have this finite fine-grained

1965
01:14:48,480 --> 01:14:51,040
currently there are also other works

1966
01:14:51,040 --> 01:14:52,719
which also consider

1967
01:14:52,719 --> 01:14:53,920
similar

1968
01:14:53,920 --> 01:14:56,080
powers of the adversary

1969
01:14:56,080 --> 01:14:58,000
but the first one is symbolic so not

1970
01:14:58,000 --> 01:14:59,679
cryptographic different

1971
01:14:59,679 --> 01:15:01,360
and the second one

1972
01:15:01,360 --> 01:15:03,840
only models key derivations so one small

1973
01:15:03,840 --> 01:15:06,239
part of idk

1974
01:15:06,239 --> 01:15:08,080
to conclude i have a couple of open

1975
01:15:08,080 --> 01:15:09,360
questions

1976
01:15:09,360 --> 01:15:10,719
first of all

1977
01:15:10,719 --> 01:15:12,960
full analysis of mls or battle analysis

1978
01:15:12,960 --> 01:15:14,400
maybe

1979
01:15:14,400 --> 01:15:16,400
we could analyze all features of this

1980
01:15:16,400 --> 01:15:18,320
protocol that we haven't touched

1981
01:15:18,320 --> 01:15:20,400
actually no one from the cryptographic

1982
01:15:20,400 --> 01:15:22,000
community has touched

1983
01:15:22,000 --> 01:15:23,760
that's just session

1984
01:15:23,760 --> 01:15:24,880
external

1985
01:15:24,880 --> 01:15:26,960
pressured keys etc

1986
01:15:26,960 --> 01:15:28,080
uh

1987
01:15:28,080 --> 01:15:29,840
uc security with fully adaptive

1988
01:15:29,840 --> 01:15:32,080
corruptions i said we model using

1989
01:15:32,080 --> 01:15:34,640
security but we restrict the environment

1990
01:15:34,640 --> 01:15:36,400
not to corrupt at certain times because

1991
01:15:36,400 --> 01:15:38,880
we have the commitment problem

1992
01:15:38,880 --> 01:15:41,120
um so non-committing encryption would be

1993
01:15:41,120 --> 01:15:43,120
something that allows to prove policy

1994
01:15:43,120 --> 01:15:44,480
security

1995
01:15:44,480 --> 01:15:46,800
then maybe more properties of mls we

1996
01:15:46,800 --> 01:15:48,719
just analyzed the three that i mentioned

1997
01:15:48,719 --> 01:15:51,520
but maybe you can analyze metadata

1998
01:15:51,520 --> 01:15:54,080
post quantum security as usual it's we

1999
01:15:54,080 --> 01:15:56,640
only have like um

2000
01:15:56,640 --> 01:15:59,679
standard model run sorry random oracle

2001
01:15:59,679 --> 01:16:02,239
model uh not post quantum crews

2002
01:16:02,239 --> 01:16:04,880
uh simpler security analysis both

2003
01:16:04,880 --> 01:16:08,000
defining and and and proving it k secure

2004
01:16:08,000 --> 01:16:09,040
is quite

2005
01:16:09,040 --> 01:16:10,159
um

2006
01:16:10,159 --> 01:16:12,080
involved quite complicated so maybe

2007
01:16:12,080 --> 01:16:13,679
parts of the symbolic analysis could

2008
01:16:13,679 --> 01:16:15,120
help as well

2009
01:16:15,120 --> 01:16:17,360
and then of course as usual more

2010
01:16:17,360 --> 01:16:19,440
efficient protocols

2011
01:16:19,440 --> 01:16:22,960
that concludes my darkness

2012
01:16:28,080 --> 01:16:30,000
yeah since we started with the session

2013
01:16:30,000 --> 01:16:32,000
with five minutes delay inherited from

2014
01:16:32,000 --> 01:16:35,199
the prior one we have maybe uh one half

2015
01:16:35,199 --> 01:16:38,080
minute for question

2016
01:16:38,080 --> 01:16:40,800
and if there is none i don't see any in

2017
01:16:40,800 --> 01:16:43,199
the chat either um maybe a quick

2018
01:16:43,199 --> 01:16:45,840
question um signal still uses pairwise

2019
01:16:45,840 --> 01:16:48,640
channels uh probably also with the goal

2020
01:16:48,640 --> 01:16:52,239
of uh yeah being secure against insiders

2021
01:16:52,239 --> 01:16:54,880
maybe they don't achieve agreement but

2022
01:16:54,880 --> 01:16:57,520
do you have an intuition for

2023
01:16:57,520 --> 01:16:58,640
how

2024
01:16:58,640 --> 01:17:01,600
the two protocols compare to each other

2025
01:17:01,600 --> 01:17:03,920
like you mean signals uh

2026
01:17:03,920 --> 01:17:05,440
way of using

2027
01:17:05,440 --> 01:17:07,120
pairwise channels between each pair of

2028
01:17:07,120 --> 01:17:08,239
group members

2029
01:17:08,239 --> 01:17:09,760
yeah they don't achieve agreement i

2030
01:17:09,760 --> 01:17:12,320
think this is a bit un annoying kind of

2031
01:17:12,320 --> 01:17:14,400
because it's it's a nice property we all

2032
01:17:14,400 --> 01:17:16,320
agree on the current state well in

2033
01:17:16,320 --> 01:17:18,960
signal you have to i guess use some

2034
01:17:18,960 --> 01:17:22,960
um outside methods to um agree on who's

2035
01:17:22,960 --> 01:17:24,719
actually in the group right

2036
01:17:24,719 --> 01:17:26,159
uh they have

2037
01:17:26,159 --> 01:17:28,400
some actually pretty kind of involved

2038
01:17:28,400 --> 01:17:30,239
and cool protocols for that which is

2039
01:17:30,239 --> 01:17:33,280
cool but you have to do this while idk

2040
01:17:33,280 --> 01:17:36,400
gives you that out of the out of the box

2041
01:17:36,400 --> 01:17:38,159
another thing is the communication

2042
01:17:38,159 --> 01:17:39,920
complexity which is obviously linear in

2043
01:17:39,920 --> 01:17:41,360
the double ratchet

2044
01:17:41,360 --> 01:17:43,199
here you have logarithmic or

2045
01:17:43,199 --> 01:17:45,679
optimistically logarithmic that's

2046
01:17:45,679 --> 01:17:46,880
another

2047
01:17:46,880 --> 01:17:49,280
feature you get different security

2048
01:17:49,280 --> 01:17:52,719
predicates how exactly they compare

2049
01:17:52,719 --> 01:17:56,159
um i i can't really say precisely

2050
01:17:56,159 --> 01:17:57,920
yeah maybe then a quick uh second

2051
01:17:57,920 --> 01:18:00,000
question would your model work to

2052
01:18:00,000 --> 01:18:02,239
analyze it like if you

2053
01:18:02,239 --> 01:18:04,000
okay well

2054
01:18:04,000 --> 01:18:05,840
it doesn't achieve agreement so assume

2055
01:18:05,840 --> 01:18:08,640
that we also have some um a mechanism on

2056
01:18:08,640 --> 01:18:10,640
top of these um

2057
01:18:10,640 --> 01:18:12,640
double ratchets that

2058
01:18:12,640 --> 01:18:14,400
that achieves agreement

2059
01:18:14,400 --> 01:18:16,320
then i then the model would be useful

2060
01:18:16,320 --> 01:18:18,480
for that as well okay thank you very

2061
01:18:18,480 --> 01:18:20,560
much let's thank the speaker again and

2062
01:18:20,560 --> 01:18:22,880
that's

2063
01:18:24,800 --> 01:18:27,199
the end of this session and the end of

2064
01:18:27,199 --> 01:18:29,120
all talks today see you at the dinner

2065
01:18:29,120 --> 01:18:32,000
later thank you

2066
01:18:38,640 --> 01:18:41,840
i'm going to close out the room now

