1
00:00:00,080 --> 00:00:01,920
knowledge extractor for three rounds

2
00:00:01,920 --> 00:00:04,240
interactive proofs

3
00:00:04,240 --> 00:00:06,000
let me just quickly get this out this

4
00:00:06,000 --> 00:00:08,560
out of the way

5
00:00:10,160 --> 00:00:11,280
um

6
00:00:11,280 --> 00:00:12,719
so this is nothing new no barrel

7
00:00:12,719 --> 00:00:14,960
repetition also no multi rounds

8
00:00:14,960 --> 00:00:16,160
in there but that's going to be the

9
00:00:16,160 --> 00:00:17,600
basis of our

10
00:00:17,600 --> 00:00:18,960
result

11
00:00:18,960 --> 00:00:21,359
then i will explain what goes wrong when

12
00:00:21,359 --> 00:00:24,400
we try to generalize this approach to

13
00:00:24,400 --> 00:00:26,480
the parallel repetition of these kind of

14
00:00:26,480 --> 00:00:28,880
interactive proofs and then i will

15
00:00:28,880 --> 00:00:30,960
present our solution for these these

16
00:00:30,960 --> 00:00:31,920
issues

17
00:00:31,920 --> 00:00:34,559
first working on the three-round case

18
00:00:34,559 --> 00:00:36,399
and then generalizing further to

19
00:00:36,399 --> 00:00:37,760
multi-round

20
00:00:37,760 --> 00:00:40,079
interactive proofs

21
00:00:40,079 --> 00:00:42,719
so to set the stage let us consider a

22
00:00:42,719 --> 00:00:45,039
relation r which is simply a set of

23
00:00:45,039 --> 00:00:47,039
statement witness pairs so the

24
00:00:47,039 --> 00:00:48,879
statements are typically denoted by x

25
00:00:48,879 --> 00:00:51,039
and the witnesses by w and you can think

26
00:00:51,039 --> 00:00:52,480
of a statement

27
00:00:52,480 --> 00:00:54,559
x for example is a group element and a

28
00:00:54,559 --> 00:00:55,440
witness

29
00:00:55,440 --> 00:00:57,039
would be a discrete logarithm for this

30
00:00:57,039 --> 00:01:00,000
specific group element but

31
00:01:00,000 --> 00:01:02,719
relations can be of any form

32
00:01:02,719 --> 00:01:03,600
and

33
00:01:03,600 --> 00:01:05,840
an interactive proof is a proofer

34
00:01:05,840 --> 00:01:06,720
between

35
00:01:06,720 --> 00:01:08,320
or a protocol between a proofer and a

36
00:01:08,320 --> 00:01:09,760
verifier

37
00:01:09,760 --> 00:01:12,400
they interact for a couple of rounds the

38
00:01:12,400 --> 00:01:14,560
proofer is given as input both the

39
00:01:14,560 --> 00:01:16,159
statement and the witness and the

40
00:01:16,159 --> 00:01:19,280
verifier is only given as input the

41
00:01:19,280 --> 00:01:21,200
statement and at the end of the protocol

42
00:01:21,200 --> 00:01:22,400
at the end of the interactions the

43
00:01:22,400 --> 00:01:23,600
verifier

44
00:01:23,600 --> 00:01:26,400
accepts or rejects the proofer's claim

45
00:01:26,400 --> 00:01:28,479
that it knows a witness

46
00:01:28,479 --> 00:01:29,840
so actually the goal of such an

47
00:01:29,840 --> 00:01:31,920
interactive proof is for the prover to

48
00:01:31,920 --> 00:01:33,759
convince the verifier that it actually

49
00:01:33,759 --> 00:01:35,439
knows a witness for this public

50
00:01:35,439 --> 00:01:37,920
statement x

51
00:01:37,920 --> 00:01:39,680
and in this work we only consider public

52
00:01:39,680 --> 00:01:42,320
coin protocols and uh that basically

53
00:01:42,320 --> 00:01:44,079
means that all of the messages going

54
00:01:44,079 --> 00:01:47,119
from the verifier to the uh proofer are

55
00:01:47,119 --> 00:01:49,360
challenges c one up to c mu which are

56
00:01:49,360 --> 00:01:51,920
sampled uniformly at random from uh

57
00:01:51,920 --> 00:01:53,680
challenge set

58
00:01:53,680 --> 00:01:55,200
and in every round the challenge that

59
00:01:55,200 --> 00:01:57,759
can be different

60
00:01:58,640 --> 00:02:00,479
so these interactive proof of proofs

61
00:02:00,479 --> 00:02:02,000
have a number of desirable security

62
00:02:02,000 --> 00:02:03,439
properties

63
00:02:03,439 --> 00:02:05,280
and we will be focusing on knowledge

64
00:02:05,280 --> 00:02:08,160
sadness informally an interactive proof

65
00:02:08,160 --> 00:02:10,000
is knowledge sound if a dishonest

66
00:02:10,000 --> 00:02:12,879
proofer that does not know witness um

67
00:02:12,879 --> 00:02:15,360
cannot succeed or almost never succeeds

68
00:02:15,360 --> 00:02:17,520
in convincing a verifier

69
00:02:17,520 --> 00:02:19,360
so that's one of the the main properties

70
00:02:19,360 --> 00:02:20,640
that we would like these interactive

71
00:02:20,640 --> 00:02:23,599
proofs to have

72
00:02:23,599 --> 00:02:26,080
more formally knowledge soundness is

73
00:02:26,080 --> 00:02:27,360
defined in terms of a knowledge

74
00:02:27,360 --> 00:02:28,640
extractor

75
00:02:28,640 --> 00:02:31,360
a knowledge extractor is an algorithm

76
00:02:31,360 --> 00:02:33,680
that is given as input as statement x

77
00:02:33,680 --> 00:02:36,080
and blackbox or oracle access to

78
00:02:36,080 --> 00:02:39,360
approver p star attacking the protocol

79
00:02:39,360 --> 00:02:41,040
and the goal of the knowledge extractor

80
00:02:41,040 --> 00:02:42,959
is given this access to the prover to

81
00:02:42,959 --> 00:02:45,440
extract the witness from the prover

82
00:02:45,440 --> 00:02:47,360
and the knowledge extractor should be

83
00:02:47,360 --> 00:02:49,760
efficient and this basically means that

84
00:02:49,760 --> 00:02:51,760
if a prover succeeds with large enough

85
00:02:51,760 --> 00:02:54,160
probability in convincing the verifier

86
00:02:54,160 --> 00:02:56,160
then the knowledge extractor can extract

87
00:02:56,160 --> 00:02:58,560
the witness from this prover therefore

88
00:02:58,560 --> 00:03:01,440
the the proofer must actually know

89
00:03:01,440 --> 00:03:02,800
a witness

90
00:03:02,800 --> 00:03:04,800
so this is the way to formally define

91
00:03:04,800 --> 00:03:06,480
knowledge sadness

92
00:03:06,480 --> 00:03:07,840
and this will also be our work to

93
00:03:07,840 --> 00:03:09,840
construct certain knowledge extractors

94
00:03:09,840 --> 00:03:11,519
for power repetitions of interactive

95
00:03:11,519 --> 00:03:13,440
proofs

96
00:03:13,440 --> 00:03:15,920
um there are a couple of a number of

97
00:03:15,920 --> 00:03:17,680
figures of merits that are of interest

98
00:03:17,680 --> 00:03:20,080
so for example for instance the success

99
00:03:20,080 --> 00:03:22,159
probability of the proof of p-star you

100
00:03:22,159 --> 00:03:23,519
can imagine that if this proofer

101
00:03:23,519 --> 00:03:25,680
succeeds with larger probability it's

102
00:03:25,680 --> 00:03:27,040
going to be easier to extract the

103
00:03:27,040 --> 00:03:29,280
witness out of this prover so this

104
00:03:29,280 --> 00:03:31,920
epsilon denoting the success probability

105
00:03:31,920 --> 00:03:33,760
is going to be an important figure of

106
00:03:33,760 --> 00:03:35,360
merit and then we also have the

107
00:03:35,360 --> 00:03:37,280
knowledge sound escapa

108
00:03:37,280 --> 00:03:39,440
or the knowledge error kappa

109
00:03:39,440 --> 00:03:41,599
which is uh informally the cheating

110
00:03:41,599 --> 00:03:44,879
probability of a dishonest prover

111
00:03:44,879 --> 00:03:46,959
so basically we aim for this knowledge

112
00:03:46,959 --> 00:03:50,879
error to be as small as possible

113
00:03:50,959 --> 00:03:52,959
and so even more formally the standard

114
00:03:52,959 --> 00:03:55,120
definition of knowledge soundness

115
00:03:55,120 --> 00:03:56,959
states that an interactive proof is

116
00:03:56,959 --> 00:03:59,120
knowledge sound if there exists an

117
00:03:59,120 --> 00:04:00,959
extractor with this with exactly these

118
00:04:00,959 --> 00:04:03,439
properties so if the proofer p star

119
00:04:03,439 --> 00:04:05,200
succeeds with large enough probability

120
00:04:05,200 --> 00:04:07,760
so larger than the knowledge error

121
00:04:07,760 --> 00:04:10,000
then the knowledge extractor is capable

122
00:04:10,000 --> 00:04:12,000
of extracting a witness

123
00:04:12,000 --> 00:04:14,560
in a runtime that is inversely

124
00:04:14,560 --> 00:04:18,478
proportional to epsilon minus kappa

125
00:04:19,918 --> 00:04:21,839
so then we have this informal or this

126
00:04:21,839 --> 00:04:23,120
dilemma

127
00:04:23,120 --> 00:04:24,880
that is actually sufficient in our

128
00:04:24,880 --> 00:04:26,960
analysis to only consider deterministic

129
00:04:26,960 --> 00:04:28,639
proof of sp star

130
00:04:28,639 --> 00:04:30,240
it's not completely obvious from the

131
00:04:30,240 --> 00:04:31,919
previous definition but it's relatively

132
00:04:31,919 --> 00:04:34,080
straightforward to to prove that this is

133
00:04:34,080 --> 00:04:36,160
indeed the case and

134
00:04:36,160 --> 00:04:37,840
this will significantly simplify our

135
00:04:37,840 --> 00:04:40,000
analysis so therefore from now on we

136
00:04:40,000 --> 00:04:42,320
will assume the proof of p star to be

137
00:04:42,320 --> 00:04:44,479
deterministic and in particular this

138
00:04:44,479 --> 00:04:46,320
means that the first message of the

139
00:04:46,320 --> 00:04:50,080
proofer will always be the same

140
00:04:53,520 --> 00:04:56,000
so if you are able to prove that an

141
00:04:56,000 --> 00:04:57,040
interactive proof has knowledge

142
00:04:57,040 --> 00:05:00,080
soundness or knowledge error copper

143
00:05:00,080 --> 00:05:02,240
and this kappa is for example one half

144
00:05:02,240 --> 00:05:04,000
that's typically not sufficient in in

145
00:05:04,000 --> 00:05:05,600
practical applications so you want to

146
00:05:05,600 --> 00:05:07,840
reduce the knowledge error down to some

147
00:05:07,840 --> 00:05:09,919
very small value

148
00:05:09,919 --> 00:05:11,759
and there are a couple of ways generic

149
00:05:11,759 --> 00:05:13,280
techniques to do that the first one is

150
00:05:13,280 --> 00:05:15,199
sequential repetition so instead of just

151
00:05:15,199 --> 00:05:16,960
running one invocation of the

152
00:05:16,960 --> 00:05:18,800
interactive proof you can just repeat it

153
00:05:18,800 --> 00:05:22,080
sequentially and this reduces the

154
00:05:22,080 --> 00:05:24,479
knowledge error from kappa down to kappa

155
00:05:24,479 --> 00:05:26,639
to the power t where t is the number of

156
00:05:26,639 --> 00:05:28,639
sequential repetitions this is very

157
00:05:28,639 --> 00:05:30,160
intuitive this was also what you would

158
00:05:30,160 --> 00:05:32,320
expect and this is well known the

159
00:05:32,320 --> 00:05:34,000
downside of this approach is that it

160
00:05:34,000 --> 00:05:36,400
reduces the number of rounds

161
00:05:36,400 --> 00:05:38,240
sorry it increases the the number of

162
00:05:38,240 --> 00:05:40,880
rounds of course

163
00:05:41,039 --> 00:05:43,520
uh an alternative approach is to perform

164
00:05:43,520 --> 00:05:46,479
these repetitions uh in parallel so then

165
00:05:46,479 --> 00:05:48,639
you don't increase the number of rounds

166
00:05:48,639 --> 00:05:50,160
and you can immediately see that what

167
00:05:50,160 --> 00:05:51,600
happens is that the size of the

168
00:05:51,600 --> 00:05:53,919
challenge set increases from end to end

169
00:05:53,919 --> 00:05:56,639
to the power t instead of sending one

170
00:05:56,639 --> 00:06:00,080
challenge um you immediately send or you

171
00:06:00,080 --> 00:06:02,400
send a factor of

172
00:06:02,400 --> 00:06:04,639
t different challenges

173
00:06:04,639 --> 00:06:07,360
each for um one for each of the parallel

174
00:06:07,360 --> 00:06:08,720
invocations

175
00:06:08,720 --> 00:06:10,160
and the hope is also that for this

176
00:06:10,160 --> 00:06:11,759
parallel repetition we would have a

177
00:06:11,759 --> 00:06:13,600
strong knowledge error reduction from

178
00:06:13,600 --> 00:06:16,319
kappa down to copper to the power t well

179
00:06:16,319 --> 00:06:17,840
unfortunately this is not the case and

180
00:06:17,840 --> 00:06:19,280
there are actually a couple of counter

181
00:06:19,280 --> 00:06:22,479
examples that show that

182
00:06:22,479 --> 00:06:24,000
that you cannot attain

183
00:06:24,000 --> 00:06:25,600
such a strong result

184
00:06:25,600 --> 00:06:27,680
in general

185
00:06:27,680 --> 00:06:28,639
when you

186
00:06:28,639 --> 00:06:31,120
restrict for example to public coin

187
00:06:31,120 --> 00:06:32,880
protocols as we are doing in this work

188
00:06:32,880 --> 00:06:35,520
as well then uh there is a strong or

189
00:06:35,520 --> 00:06:37,039
there there is a weak

190
00:06:37,039 --> 00:06:39,440
apparel repetition result that shows it

191
00:06:39,440 --> 00:06:41,360
that parallel repetition reduces the

192
00:06:41,360 --> 00:06:43,199
knowledge error from kappa to copper to

193
00:06:43,199 --> 00:06:45,840
the power t plus this non-negligible

194
00:06:45,840 --> 00:06:47,199
term

195
00:06:47,199 --> 00:06:48,639
and

196
00:06:48,639 --> 00:06:50,560
so the goal of this work is to actually

197
00:06:50,560 --> 00:06:52,720
get rid of this non-negligible term

198
00:06:52,720 --> 00:06:54,000
so to get a

199
00:06:54,000 --> 00:06:56,639
strong parallel repetition result

200
00:06:56,639 --> 00:06:58,240
and

201
00:06:58,240 --> 00:07:00,160
we do this for very rich class of

202
00:07:00,160 --> 00:07:02,639
protocols which are special sound

203
00:07:02,639 --> 00:07:04,479
interactive proofs so for special sound

204
00:07:04,479 --> 00:07:06,080
interactive proofs we actually show that

205
00:07:06,080 --> 00:07:07,759
you do not

206
00:07:07,759 --> 00:07:10,479
get this non-negligible term new and you

207
00:07:10,479 --> 00:07:12,000
get us really get a strong power

208
00:07:12,000 --> 00:07:14,080
repetition result reducing the knowledge

209
00:07:14,080 --> 00:07:17,840
from kappa down to copper to the power t

210
00:07:18,800 --> 00:07:21,039
so what is this special soundness

211
00:07:21,039 --> 00:07:22,720
special soundness is yet another notion

212
00:07:22,720 --> 00:07:24,800
of uh soundness

213
00:07:24,800 --> 00:07:26,319
and it is typically much easier to

214
00:07:26,319 --> 00:07:28,160
handle this notion it's easier to to

215
00:07:28,160 --> 00:07:29,680
prove that an interactive proof is

216
00:07:29,680 --> 00:07:31,360
special sound than to prove that it has

217
00:07:31,360 --> 00:07:34,160
knowledge soundness uh directly

218
00:07:34,160 --> 00:07:37,280
um so the the the easiest case is two

219
00:07:37,280 --> 00:07:39,440
out of n special soundness

220
00:07:39,440 --> 00:07:41,520
so in a three round interactive proof is

221
00:07:41,520 --> 00:07:43,120
two out of n special sound if there

222
00:07:43,120 --> 00:07:45,440
exists an efficient algorithm that takes

223
00:07:45,440 --> 00:07:48,000
this input to colliding transcripts so

224
00:07:48,000 --> 00:07:51,919
here we see a comma c comma z and a c

225
00:07:51,919 --> 00:07:53,759
prime z prime those are protocol

226
00:07:53,759 --> 00:07:55,039
transcripts for these three round

227
00:07:55,039 --> 00:07:56,960
protocols they have the same first

228
00:07:56,960 --> 00:07:59,199
message but a different challenge c and

229
00:07:59,199 --> 00:08:01,919
c prime should be different um and from

230
00:08:01,919 --> 00:08:05,520
these two transcripts we can extract uh

231
00:08:05,520 --> 00:08:07,599
if we can extract a witness from these

232
00:08:07,599 --> 00:08:09,680
two transcripts then efficiently then

233
00:08:09,680 --> 00:08:11,360
the protocol is said to be a two out of

234
00:08:11,360 --> 00:08:13,360
n special sound where n is the size of

235
00:08:13,360 --> 00:08:14,879
the challenge set of this interactive

236
00:08:14,879 --> 00:08:16,720
proof

237
00:08:16,720 --> 00:08:18,639
it is very well known that two out of n

238
00:08:18,639 --> 00:08:20,080
special sounders implies knowledge

239
00:08:20,080 --> 00:08:23,039
soundness with knowledge error one over

240
00:08:23,039 --> 00:08:25,039
and also there are some well-known

241
00:08:25,039 --> 00:08:26,560
generalizations of this notion of

242
00:08:26,560 --> 00:08:28,319
special sound so you can also go to k

243
00:08:28,319 --> 00:08:30,000
special soundness where instead of two

244
00:08:30,000 --> 00:08:32,640
uh transcripts you need k transcripts uh

245
00:08:32,640 --> 00:08:34,559
there uh we see that it implies

246
00:08:34,559 --> 00:08:36,000
knowledge soundness with knowledge error

247
00:08:36,000 --> 00:08:39,919
k minus one over n and there are also

248
00:08:39,919 --> 00:08:41,679
multi-round generalizations of this

249
00:08:41,679 --> 00:08:43,039
notion

250
00:08:43,039 --> 00:08:45,600
of special soundness and we know that

251
00:08:45,600 --> 00:08:47,920
these generalizations also tightly imply

252
00:08:47,920 --> 00:08:50,719
knowledge sadness

253
00:08:51,680 --> 00:08:53,680
so let us look at a very simple

254
00:08:53,680 --> 00:08:55,200
knowledge extractor for three round

255
00:08:55,200 --> 00:08:57,519
interactive proofs

256
00:08:57,519 --> 00:08:58,720
so

257
00:08:58,720 --> 00:09:01,120
let by be such a interactive proof k out

258
00:09:01,120 --> 00:09:03,600
of n special sounds it has three rounds

259
00:09:03,600 --> 00:09:05,519
and let p star be a deterministic

260
00:09:05,519 --> 00:09:08,160
proofer that attacks this protocol and

261
00:09:08,160 --> 00:09:10,399
then pete star can actually be seen as a

262
00:09:10,399 --> 00:09:12,160
deterministic function that takes his

263
00:09:12,160 --> 00:09:14,800
input to challenge c and it outputs a

264
00:09:14,800 --> 00:09:17,200
bit string set so z is basically the

265
00:09:17,200 --> 00:09:19,360
final the third message of the protocol

266
00:09:19,360 --> 00:09:20,560
and

267
00:09:20,560 --> 00:09:22,480
the first message of p star is always

268
00:09:22,480 --> 00:09:24,000
the same it's always a because it's

269
00:09:24,000 --> 00:09:25,760
deterministic proofer

270
00:09:25,760 --> 00:09:26,720
and

271
00:09:26,720 --> 00:09:28,480
a p star is successful of this

272
00:09:28,480 --> 00:09:30,320
transcript a c

273
00:09:30,320 --> 00:09:31,680
comma set

274
00:09:31,680 --> 00:09:34,160
is accepting

275
00:09:34,160 --> 00:09:36,480
so if you look at uh such a proofer in

276
00:09:36,480 --> 00:09:38,560
that manner you can actually summarize

277
00:09:38,560 --> 00:09:41,279
its properties by means of this binary

278
00:09:41,279 --> 00:09:44,240
vector so this zero one factor uh

279
00:09:44,240 --> 00:09:46,399
indexed by the challenges c one up to c

280
00:09:46,399 --> 00:09:49,839
n so a zero entry is actually

281
00:09:49,839 --> 00:09:51,440
corresponds to a challenge for which the

282
00:09:51,440 --> 00:09:53,519
prover fails and a one entry corresponds

283
00:09:53,519 --> 00:09:54,560
to

284
00:09:54,560 --> 00:09:56,080
a challenge for which the prover

285
00:09:56,080 --> 00:09:58,000
succeeds and epsilon the success

286
00:09:58,000 --> 00:10:00,080
probability of the prover is actually

287
00:10:00,080 --> 00:10:02,800
the fraction of one entries in this

288
00:10:02,800 --> 00:10:06,399
matrix or in this vector

289
00:10:06,800 --> 00:10:08,000
so then we have this very simple

290
00:10:08,000 --> 00:10:10,320
extraction algorithm we start by

291
00:10:10,320 --> 00:10:13,120
sampling entries from this vector until

292
00:10:13,120 --> 00:10:15,120
a one entry is found until we have this

293
00:10:15,120 --> 00:10:18,320
first accepting transcript well this

294
00:10:18,320 --> 00:10:20,959
first step takes time expected time one

295
00:10:20,959 --> 00:10:22,560
over epsilon

296
00:10:22,560 --> 00:10:25,040
then we continue we ignore the the entry

297
00:10:25,040 --> 00:10:26,720
that we have already found and we are

298
00:10:26,720 --> 00:10:29,519
going to continue sampling entries until

299
00:10:29,519 --> 00:10:31,760
a second one entry is found

300
00:10:31,760 --> 00:10:34,079
this time this takes expected time at

301
00:10:34,079 --> 00:10:36,480
most one divided by epsilon minus one

302
00:10:36,480 --> 00:10:38,800
over n and the minus one over n appears

303
00:10:38,800 --> 00:10:41,600
because now we have the same um

304
00:10:41,600 --> 00:10:43,680
vector but we have removed one and one

305
00:10:43,680 --> 00:10:45,200
entry out of the factor because that's

306
00:10:45,200 --> 00:10:46,880
the that's the one that we had already

307
00:10:46,880 --> 00:10:48,160
found

308
00:10:48,160 --> 00:10:50,000
we continue in this in that manner and

309
00:10:50,000 --> 00:10:51,920
for the final uh transcript that we need

310
00:10:51,920 --> 00:10:55,120
so the gate transcript it takes time um

311
00:10:55,120 --> 00:10:57,040
expected time at most one over epsilon

312
00:10:57,040 --> 00:11:00,800
minus k minus one over n

313
00:11:00,800 --> 00:11:02,720
all together this

314
00:11:02,720 --> 00:11:05,040
extraction algorithm succeeds

315
00:11:05,040 --> 00:11:07,760
in time at most k divided by epsilon

316
00:11:07,760 --> 00:11:10,160
minus k minus 1 over n so all the steps

317
00:11:10,160 --> 00:11:11,200
combined

318
00:11:11,200 --> 00:11:13,680
and this already shows that the k out of

319
00:11:13,680 --> 00:11:15,519
n special sound interactive proof has

320
00:11:15,519 --> 00:11:17,120
knowledge soundness with knowledge error

321
00:11:17,120 --> 00:11:19,839
k minus 1 over n so um and this

322
00:11:19,839 --> 00:11:21,440
knowledge error this result is actually

323
00:11:21,440 --> 00:11:23,680
tight so this is a very simple

324
00:11:23,680 --> 00:11:25,680
knowledge extractor for three round

325
00:11:25,680 --> 00:11:27,200
interactive proofs with this special

326
00:11:27,200 --> 00:11:30,720
soundness pro property

327
00:11:31,440 --> 00:11:33,279
so let us now try to generalize this

328
00:11:33,279 --> 00:11:35,200
approach to the parallel repetition and

329
00:11:35,200 --> 00:11:38,560
see what goes wrong

330
00:11:39,040 --> 00:11:39,839
so

331
00:11:39,839 --> 00:11:41,600
for simplicity we only consider the

332
00:11:41,600 --> 00:11:43,279
twofold parallel repetition but all of

333
00:11:43,279 --> 00:11:45,040
this also works for

334
00:11:45,040 --> 00:11:47,760
arbitrary t

335
00:11:47,760 --> 00:11:50,560
and now p star is a prover attacking

336
00:11:50,560 --> 00:11:53,200
this twofold parallel repetition

337
00:11:53,200 --> 00:11:54,320
and

338
00:11:54,320 --> 00:11:56,480
if that's the case then we can see p

339
00:11:56,480 --> 00:11:58,880
star it's still deterministic uh we can

340
00:11:58,880 --> 00:12:00,480
see it as a function that takes now as

341
00:12:00,480 --> 00:12:02,240
input two different challenges one for

342
00:12:02,240 --> 00:12:04,000
each of the parallel invocations and it

343
00:12:04,000 --> 00:12:06,560
also outputs two bit string set one and

344
00:12:06,560 --> 00:12:08,399
set two one for each of the parallel

345
00:12:08,399 --> 00:12:11,399
invocations

346
00:12:11,760 --> 00:12:14,079
if you have such a proof of p star then

347
00:12:14,079 --> 00:12:15,839
it is quite easy to construct two

348
00:12:15,839 --> 00:12:18,480
different proofers p1 star and p2 star

349
00:12:18,480 --> 00:12:20,320
that instead of attacking the

350
00:12:20,320 --> 00:12:22,320
two-fold parallel repetition of this

351
00:12:22,320 --> 00:12:25,279
interactive proof they only attack one

352
00:12:25,279 --> 00:12:26,800
invocation of

353
00:12:26,800 --> 00:12:28,079
of pi

354
00:12:28,079 --> 00:12:30,639
um so p1 star for example takes this

355
00:12:30,639 --> 00:12:32,959
input one challenge it samples the

356
00:12:32,959 --> 00:12:35,360
second challenge uniformly at random

357
00:12:35,360 --> 00:12:37,680
then it runs this prover p star that

358
00:12:37,680 --> 00:12:40,639
detects the peril repetition and it

359
00:12:40,639 --> 00:12:43,279
basically ignores the second output of

360
00:12:43,279 --> 00:12:45,279
this proofer p star

361
00:12:45,279 --> 00:12:48,160
so now p1 star is approver attacking

362
00:12:48,160 --> 00:12:50,480
a single invocation of our

363
00:12:50,480 --> 00:12:52,639
original protocol pi and we can do the

364
00:12:52,639 --> 00:12:56,480
same thing for p2 star

365
00:12:57,839 --> 00:13:00,000
note that in this case the proofers p1

366
00:13:00,000 --> 00:13:01,360
star and p2 star are no longer

367
00:13:01,360 --> 00:13:03,120
deterministic we have this randomness so

368
00:13:03,120 --> 00:13:05,440
they have to sample a random challenge

369
00:13:05,440 --> 00:13:07,279
internally

370
00:13:07,279 --> 00:13:08,800
but their first messages are still the

371
00:13:08,800 --> 00:13:10,399
same so

372
00:13:10,399 --> 00:13:12,399
this doesn't give us any

373
00:13:12,399 --> 00:13:14,959
any issues

374
00:13:15,360 --> 00:13:17,600
uh so now let's take another look at the

375
00:13:17,600 --> 00:13:19,680
knowledge extractor so there's now a

376
00:13:19,680 --> 00:13:23,680
very naive approach simple approach that

377
00:13:23,680 --> 00:13:25,920
that that makes sense to apply the

378
00:13:25,920 --> 00:13:28,160
simple knowledge extractor but now on

379
00:13:28,160 --> 00:13:30,720
both uh the proof is p1

380
00:13:30,720 --> 00:13:34,399
and ps2 star

381
00:13:34,399 --> 00:13:37,519
the same analysis every four holes um

382
00:13:37,519 --> 00:13:40,000
even though the provers p1 and p2 star

383
00:13:40,000 --> 00:13:40,800
are not

384
00:13:40,800 --> 00:13:42,480
deterministic

385
00:13:42,480 --> 00:13:44,160
however this approach does not work

386
00:13:44,160 --> 00:13:46,560
because we still get knowledge error k

387
00:13:46,560 --> 00:13:48,720
minus 1 over n while our goal was

388
00:13:48,720 --> 00:13:50,399
actually to reduce to show that this

389
00:13:50,399 --> 00:13:51,760
pair repetition has reduced the

390
00:13:51,760 --> 00:13:53,839
knowledge error down to

391
00:13:53,839 --> 00:13:55,360
k minus 1

392
00:13:55,360 --> 00:13:58,959
squared divided by n squared

393
00:13:59,600 --> 00:14:03,120
so how do we solve this issue

394
00:14:03,120 --> 00:14:05,519
on a very high level uh what we do is we

395
00:14:05,519 --> 00:14:07,360
introduce a new figure of merit so this

396
00:14:07,360 --> 00:14:09,199
far the figure of merit was epsilon the

397
00:14:09,199 --> 00:14:11,360
successful ability of the prover b star

398
00:14:11,360 --> 00:14:13,519
we introduce sort of a punctured

399
00:14:13,519 --> 00:14:16,959
successful ability delta

400
00:14:16,959 --> 00:14:18,720
and we show that the extractors are

401
00:14:18,720 --> 00:14:20,720
exactly the same extracted we do not

402
00:14:20,720 --> 00:14:22,480
modify the extraction approach but this

403
00:14:22,480 --> 00:14:25,440
extractor actually succeeds in time k

404
00:14:25,440 --> 00:14:28,639
divided by delta so now we we just we

405
00:14:28,639 --> 00:14:30,639
just refined the analysis of exactly the

406
00:14:30,639 --> 00:14:33,199
same extractor

407
00:14:33,199 --> 00:14:35,440
and for the parallel repetition

408
00:14:35,440 --> 00:14:38,000
we managed to show that

409
00:14:38,000 --> 00:14:40,399
one of the deltas so we start with a

410
00:14:40,399 --> 00:14:43,199
prover attacking the parallel instance

411
00:14:43,199 --> 00:14:45,360
and from that prover we can get

412
00:14:45,360 --> 00:14:47,199
two different proofers p1 star and p2

413
00:14:47,199 --> 00:14:49,440
star they both have a delta value and we

414
00:14:49,440 --> 00:14:50,959
basically show that one of the two

415
00:14:50,959 --> 00:14:53,519
deltas is large enough so

416
00:14:53,519 --> 00:14:55,279
from there on our strong parallel

417
00:14:55,279 --> 00:14:56,839
repetition result

418
00:14:56,839 --> 00:14:59,600
follows so to go into a little bit more

419
00:14:59,600 --> 00:15:02,079
detail

420
00:15:02,079 --> 00:15:04,160
we so we start with this epsilon and now

421
00:15:04,160 --> 00:15:05,600
we're going to move over to this new

422
00:15:05,600 --> 00:15:08,160
figure of merit delta which is defined

423
00:15:08,160 --> 00:15:09,440
as follows

424
00:15:09,440 --> 00:15:11,920
and what you can see here is that delta

425
00:15:11,920 --> 00:15:12,959
l

426
00:15:12,959 --> 00:15:13,680
of

427
00:15:13,680 --> 00:15:15,279
p star

428
00:15:15,279 --> 00:15:17,760
is this minimum success probability

429
00:15:17,760 --> 00:15:18,959
over

430
00:15:18,959 --> 00:15:21,040
sampling the challenge is c uniformly at

431
00:15:21,040 --> 00:15:24,160
random but outside of this subset s of

432
00:15:24,160 --> 00:15:27,519
size at most l minus one so what we do

433
00:15:27,519 --> 00:15:30,399
is we take a subset s of size l minus

434
00:15:30,399 --> 00:15:32,800
one we remove it from the challenge set

435
00:15:32,800 --> 00:15:34,560
and see what the remaining success

436
00:15:34,560 --> 00:15:36,560
probability of disprover is and then we

437
00:15:36,560 --> 00:15:39,120
minimize over all of these

438
00:15:39,120 --> 00:15:41,040
subsets as so this is sort of a

439
00:15:41,040 --> 00:15:42,880
punctured success probability we remove

440
00:15:42,880 --> 00:15:44,720
a couple of challenges that we will no

441
00:15:44,720 --> 00:15:46,639
longer

442
00:15:46,639 --> 00:15:49,199
consider

443
00:15:49,680 --> 00:15:52,560
and this is actually a very relevant

444
00:15:52,560 --> 00:15:54,160
failure because it's lower bounces

445
00:15:54,160 --> 00:15:55,440
successful ability when you are

446
00:15:55,440 --> 00:15:57,360
rewinding because every time you you

447
00:15:57,360 --> 00:15:58,800
rewind you have removed certain

448
00:15:58,800 --> 00:16:00,880
challenges from the challenge sets that

449
00:16:00,880 --> 00:16:02,480
are no longer useful because you have

450
00:16:02,480 --> 00:16:05,360
already found them

451
00:16:06,000 --> 00:16:07,440
so then we run exactly the same

452
00:16:07,440 --> 00:16:09,440
extractor we only modify the analysis

453
00:16:09,440 --> 00:16:11,440
and we see that for example in the cage

454
00:16:11,440 --> 00:16:12,320
step

455
00:16:12,320 --> 00:16:15,440
um sampling entries until the cage entry

456
00:16:15,440 --> 00:16:17,920
is found takes actually time expected

457
00:16:17,920 --> 00:16:20,839
time at most one over delta k of this v

458
00:16:20,839 --> 00:16:22,880
star and

459
00:16:22,880 --> 00:16:24,480
all together we see that the expected

460
00:16:24,480 --> 00:16:29,360
runtime is at most k divided by delta k

461
00:16:29,360 --> 00:16:30,320
so

462
00:16:30,320 --> 00:16:32,399
again the same knowledge extractor but

463
00:16:32,399 --> 00:16:34,160
the difference a more more refined

464
00:16:34,160 --> 00:16:37,759
analysis thereof

465
00:16:37,759 --> 00:16:40,800
so why is this helpful um it's it's it's

466
00:16:40,800 --> 00:16:42,160
not going to be helpful if you're only

467
00:16:42,160 --> 00:16:43,759
looking at a single invocation of the

468
00:16:43,759 --> 00:16:45,360
interactive proof but it will be helpful

469
00:16:45,360 --> 00:16:47,199
if we look at parallel repetitions

470
00:16:47,199 --> 00:16:49,759
thereof so let again peace star be a

471
00:16:49,759 --> 00:16:51,279
proofer attacking the twofold pair of

472
00:16:51,279 --> 00:16:52,800
repetition

473
00:16:52,800 --> 00:16:55,040
then now we can summarize the behavior

474
00:16:55,040 --> 00:16:58,079
of p star in terms of this matrix uh

475
00:16:58,079 --> 00:17:00,480
indexed by the challenges

476
00:17:00,480 --> 00:17:03,360
so we have c one up to c n and uh so the

477
00:17:03,360 --> 00:17:05,839
columns correspond to the challenges for

478
00:17:05,839 --> 00:17:07,520
the first invocation and the rows

479
00:17:07,520 --> 00:17:08,880
correspond to the challenges for the

480
00:17:08,880 --> 00:17:11,760
second invocation of this uh a parallel

481
00:17:11,760 --> 00:17:13,439
repetition

482
00:17:13,439 --> 00:17:16,400
and a one entry again corresponds to the

483
00:17:16,400 --> 00:17:18,880
proof of succeeding for that specific

484
00:17:18,880 --> 00:17:20,559
pair of challenges that it receives from

485
00:17:20,559 --> 00:17:23,280
the verifier

486
00:17:24,079 --> 00:17:25,039
and

487
00:17:25,039 --> 00:17:27,280
now this is basically uh

488
00:17:27,280 --> 00:17:29,039
let us now consider exactly the same

489
00:17:29,039 --> 00:17:31,520
matrix but without loss of generality we

490
00:17:31,520 --> 00:17:33,039
assume that the

491
00:17:33,039 --> 00:17:37,120
the matrix is sorted so the rows with

492
00:17:37,120 --> 00:17:39,440
the largest number largest fraction of

493
00:17:39,440 --> 00:17:42,320
one entries are at the top and

494
00:17:42,320 --> 00:17:44,640
the columns with the largest fraction of

495
00:17:44,640 --> 00:17:47,679
one entries are on the left hand side

496
00:17:47,679 --> 00:17:49,600
so they are sorted and if we then look

497
00:17:49,600 --> 00:17:50,960
at this matrix

498
00:17:50,960 --> 00:17:53,360
then we can see that this delta k value

499
00:17:53,360 --> 00:17:56,640
of p1 star actually corresponds to the

500
00:17:56,640 --> 00:17:58,480
fraction of one entries in the blue

501
00:17:58,480 --> 00:18:00,720
parts of this matrix because we've

502
00:18:00,720 --> 00:18:03,039
basically punctured we've removed k

503
00:18:03,039 --> 00:18:05,200
minus one

504
00:18:05,200 --> 00:18:06,799
the k minus one challenges with the

505
00:18:06,799 --> 00:18:09,679
largest success probability and we only

506
00:18:09,679 --> 00:18:11,760
consider p1 star so we only consider

507
00:18:11,760 --> 00:18:13,440
like the first

508
00:18:13,440 --> 00:18:16,720
invocation of the

509
00:18:16,720 --> 00:18:19,360
of the the basic protocol

510
00:18:19,360 --> 00:18:21,919
and exactly the same holds for p2 star

511
00:18:21,919 --> 00:18:23,840
but then with respect to the rows so

512
00:18:23,840 --> 00:18:26,640
here we see that the delta k of p2 star

513
00:18:26,640 --> 00:18:28,880
corresponds to the fraction or equals

514
00:18:28,880 --> 00:18:30,640
the fraction of one entries in the red

515
00:18:30,640 --> 00:18:31,760
part

516
00:18:31,760 --> 00:18:35,039
of this this matrix

517
00:18:35,600 --> 00:18:37,280
so if you take another look at this then

518
00:18:37,280 --> 00:18:39,520
you basically see that if you add these

519
00:18:39,520 --> 00:18:41,840
two parts together then the only part

520
00:18:41,840 --> 00:18:44,160
that is not covered is the white

521
00:18:44,160 --> 00:18:45,919
parts on the

522
00:18:45,919 --> 00:18:46,799
left

523
00:18:46,799 --> 00:18:49,679
left hand corner left top

524
00:18:49,679 --> 00:18:52,080
which is of size k minus one by k minus

525
00:18:52,080 --> 00:18:54,640
one so that's the only part so

526
00:18:54,640 --> 00:18:56,320
if you look at this then it's easy to

527
00:18:56,320 --> 00:18:57,280
see that

528
00:18:57,280 --> 00:18:59,280
at the sum of these two delta values the

529
00:18:59,280 --> 00:19:02,400
blue and the red value uh is uh at least

530
00:19:02,400 --> 00:19:04,720
epsilon minus k minus one squared

531
00:19:04,720 --> 00:19:06,559
divided by n squared

532
00:19:06,559 --> 00:19:08,480
where we recall that epsilon is the

533
00:19:08,480 --> 00:19:10,320
fraction of one entries in the entire

534
00:19:10,320 --> 00:19:11,919
matrix

535
00:19:11,919 --> 00:19:14,240
and from that it basically follows that

536
00:19:14,240 --> 00:19:16,240
at least one of the

537
00:19:16,240 --> 00:19:19,280
the two delta values is larger than

538
00:19:19,280 --> 00:19:21,679
epsilon minus k minus 1 squared divided

539
00:19:21,679 --> 00:19:23,360
by n squared

540
00:19:23,360 --> 00:19:24,480
over 2

541
00:19:24,480 --> 00:19:28,799
and from this you immediately get this

542
00:19:28,799 --> 00:19:30,799
parallel repetition result showing that

543
00:19:30,799 --> 00:19:32,320
the parallel repetition has knowledge

544
00:19:32,320 --> 00:19:33,360
error

545
00:19:33,360 --> 00:19:38,559
k minus 1 squared divided by n squared

546
00:19:38,559 --> 00:19:41,360
so the deltas actually allow us to to to

547
00:19:41,360 --> 00:19:44,160
find this relation between uh the the

548
00:19:44,160 --> 00:19:46,720
different deltas of the the two

549
00:19:46,720 --> 00:19:50,320
proofers p1 star and p2 star

550
00:19:50,320 --> 00:19:53,039
so in a bit more general uh it follows

551
00:19:53,039 --> 00:19:55,520
that the default barrel repetition of a

552
00:19:55,520 --> 00:19:57,440
k out of n special sound interactive

553
00:19:57,440 --> 00:19:58,960
proof is a knowledge sound with

554
00:19:58,960 --> 00:20:00,480
knowledge error k minus one to the power

555
00:20:00,480 --> 00:20:04,159
t divided by n to the power t

556
00:20:04,159 --> 00:20:06,000
uh so this is the power there's a strong

557
00:20:06,000 --> 00:20:08,000
peril repetition result for three round

558
00:20:08,000 --> 00:20:09,360
interactive proofs that have this

559
00:20:09,360 --> 00:20:11,120
special soundness property

560
00:20:11,120 --> 00:20:13,919
um let us now see what uh how we can go

561
00:20:13,919 --> 00:20:15,919
to the multi-round setting

562
00:20:15,919 --> 00:20:18,720
so first um there is a natural recursive

563
00:20:18,720 --> 00:20:20,240
strategy to go from three-round

564
00:20:20,240 --> 00:20:22,159
interactive proofs to multi-round

565
00:20:22,159 --> 00:20:24,799
interactive proofs

566
00:20:24,799 --> 00:20:27,120
however if you apply that recursive

567
00:20:27,120 --> 00:20:29,600
strategy to the above extractor so to

568
00:20:29,600 --> 00:20:31,360
the previous extractor

569
00:20:31,360 --> 00:20:32,880
then you will obtain a runtime that

570
00:20:32,880 --> 00:20:34,480
scales exponentially in a number of

571
00:20:34,480 --> 00:20:37,360
rounds so that's not something we want

572
00:20:37,360 --> 00:20:40,240
so what we actually do with the paper

573
00:20:40,240 --> 00:20:42,799
is we construct another extractor which

574
00:20:42,799 --> 00:20:43,919
is slightly

575
00:20:43,919 --> 00:20:45,679
more involved but which has better

576
00:20:45,679 --> 00:20:48,400
properties that make it aminable for

577
00:20:48,400 --> 00:20:50,799
this recursive strategy so we also have

578
00:20:50,799 --> 00:20:53,200
another extractor for three round

579
00:20:53,200 --> 00:20:55,039
interactive proofs that shows exactly

580
00:20:55,039 --> 00:20:56,320
the same result

581
00:20:56,320 --> 00:20:59,200
but that allows you to apply this

582
00:20:59,200 --> 00:21:01,840
recursion this multi-round inversion to

583
00:21:01,840 --> 00:21:04,480
also obtain a strong barrel repetition

584
00:21:04,480 --> 00:21:06,559
result for multi-round interactive

585
00:21:06,559 --> 00:21:08,400
proofs that have this special sadness

586
00:21:08,400 --> 00:21:10,880
property

587
00:21:11,120 --> 00:21:13,039
so to quickly summarize

588
00:21:13,039 --> 00:21:14,559
we introduced a new figure of merit

589
00:21:14,559 --> 00:21:17,120
delta this point success probability

590
00:21:17,120 --> 00:21:18,400
instead of merely looping at the

591
00:21:18,400 --> 00:21:22,559
successful ability epsilon is quite uh

592
00:21:22,559 --> 00:21:24,480
this is immediately gave a strong peril

593
00:21:24,480 --> 00:21:26,320
repetition result for three-round

594
00:21:26,320 --> 00:21:28,159
interactive proofs when we go to the

595
00:21:28,159 --> 00:21:29,760
multi-round setting we still had to make

596
00:21:29,760 --> 00:21:31,919
some adaptations

597
00:21:31,919 --> 00:21:34,799
uh but we we constructed the novel tree

598
00:21:34,799 --> 00:21:36,400
round extractor for that

599
00:21:36,400 --> 00:21:37,760
case as well

600
00:21:37,760 --> 00:21:38,559
um

601
00:21:38,559 --> 00:21:40,720
and then finally all of this also works

602
00:21:40,720 --> 00:21:43,280
for a threshold barrel repetition where

603
00:21:43,280 --> 00:21:47,039
the verifier does not

604
00:21:47,039 --> 00:21:49,039
also accepts if

605
00:21:49,039 --> 00:21:51,280
at least well so k out of and threshold

606
00:21:51,280 --> 00:21:53,520
parallel repetition basically means the

607
00:21:53,520 --> 00:21:55,120
verifier accepts

608
00:21:55,120 --> 00:21:57,760
if at least k of the parallel instances

609
00:21:57,760 --> 00:22:00,080
are accepting so it's not required that

610
00:22:00,080 --> 00:22:01,760
all of them are accepting

611
00:22:01,760 --> 00:22:03,760
and um

612
00:22:03,760 --> 00:22:05,280
or all of these results are actually

613
00:22:05,280 --> 00:22:08,320
tight so that means that uh there is

614
00:22:08,320 --> 00:22:10,720
typically for typical protocols there is

615
00:22:10,720 --> 00:22:13,120
a cheating strategy that succeeds with a

616
00:22:13,120 --> 00:22:15,360
probability copper to the power t so

617
00:22:15,360 --> 00:22:16,799
this knowledge error

618
00:22:16,799 --> 00:22:18,240
which shows that you cannot hope for

619
00:22:18,240 --> 00:22:20,960
anything better

620
00:22:21,570 --> 00:22:22,799
[Music]

621
00:22:22,799 --> 00:22:27,240
this was the final slide thank you

622
00:22:32,559 --> 00:22:34,240
so we have time for a couple of

623
00:22:34,240 --> 00:22:37,240
questions

624
00:22:42,960 --> 00:22:44,480
thanks a lot for the talk maybe if

625
00:22:44,480 --> 00:22:46,000
nobody else wants to ask a question i

626
00:22:46,000 --> 00:22:47,679
will ask one that i fierce a little bit

627
00:22:47,679 --> 00:22:51,200
stupid but okay um so um

628
00:22:51,200 --> 00:22:53,600
they're basically when you argue that

629
00:22:53,600 --> 00:22:56,500
your approach works then you get this

630
00:22:56,500 --> 00:22:57,760
[Music]

631
00:22:57,760 --> 00:22:59,840
this factor of the half

632
00:22:59,840 --> 00:23:03,440
but it also multiplies the epsilon

633
00:23:03,440 --> 00:23:07,679
yeah so why isn't that not a problem

634
00:23:07,679 --> 00:23:09,280
okay let me see maybe go back to your

635
00:23:09,280 --> 00:23:11,120
slide yeah i have to basically have to

636
00:23:11,120 --> 00:23:13,200
go back to the definition

637
00:23:13,200 --> 00:23:14,559
so you have this polynomial in the

638
00:23:14,559 --> 00:23:16,240
definition uh

639
00:23:16,240 --> 00:23:18,720
that can simply absorb this factor one

640
00:23:18,720 --> 00:23:21,720
half

641
00:23:22,240 --> 00:23:23,919
oh because this is only about the run

642
00:23:23,919 --> 00:23:26,400
time not about the success probability

643
00:23:26,400 --> 00:23:28,480
yeah

644
00:23:28,480 --> 00:23:30,960
so let's see

645
00:23:30,960 --> 00:23:32,799
okay then

646
00:23:32,799 --> 00:23:35,120
answers my question

647
00:23:35,120 --> 00:23:38,320
okay very good thanks

648
00:23:38,640 --> 00:23:40,720
i have a question that might also be you

649
00:23:40,720 --> 00:23:42,720
know uh

650
00:23:42,720 --> 00:23:43,679
similar

651
00:23:43,679 --> 00:23:45,919
so what goes wrong if uh instead of

652
00:23:45,919 --> 00:23:48,559
special assignments where any two

653
00:23:48,559 --> 00:23:50,480
transcripts that start the same messages

654
00:23:50,480 --> 00:23:53,760
give you extraction if you require um

655
00:23:53,760 --> 00:23:54,960
the soundness be a little bit more

656
00:23:54,960 --> 00:23:56,799
structured so there's some relationships

657
00:23:56,799 --> 00:23:59,200
between the two c's

658
00:23:59,200 --> 00:24:00,960
what what

659
00:24:00,960 --> 00:24:02,480
does your analysis

660
00:24:02,480 --> 00:24:04,640
like i don't see why why it wouldn't

661
00:24:04,640 --> 00:24:06,000
apply

662
00:24:06,000 --> 00:24:07,600
so um

663
00:24:07,600 --> 00:24:10,799
sorry can you repeat that so you have to

664
00:24:10,799 --> 00:24:13,520
so some you know conceivably

665
00:24:13,520 --> 00:24:16,640
um some extraction strategy would say

666
00:24:16,640 --> 00:24:18,559
in order to extract the witness

667
00:24:18,559 --> 00:24:21,520
i need um two transcripts yeah with the

668
00:24:21,520 --> 00:24:24,799
same a and two different c1 c2 that for

669
00:24:24,799 --> 00:24:27,279
example the c1 and c2 differ by they

670
00:24:27,279 --> 00:24:28,640
have some structure

671
00:24:28,640 --> 00:24:30,720
you know the difference is like a fact a

672
00:24:30,720 --> 00:24:32,720
multiple of two or something like that

673
00:24:32,720 --> 00:24:33,520
so

674
00:24:33,520 --> 00:24:36,000
what what goes wrong in your analysis uh

675
00:24:36,000 --> 00:24:38,320
it might be too complicated

676
00:24:38,320 --> 00:24:41,039
okay so so in general this this works

677
00:24:41,039 --> 00:24:42,320
but uh

678
00:24:42,320 --> 00:24:43,919
this is something where we're actually

679
00:24:43,919 --> 00:24:46,400
working out currently so that's ongoing

680
00:24:46,400 --> 00:24:47,279
work

681
00:24:47,279 --> 00:24:48,400
um

682
00:24:48,400 --> 00:24:50,480
but there might some might be some

683
00:24:50,480 --> 00:24:52,159
construction that you can think of if

684
00:24:52,159 --> 00:24:54,559
there's like really a a a strange

685
00:24:54,559 --> 00:24:56,880
relation between the two that's the the

686
00:24:56,880 --> 00:25:00,159
the runtime actually blows up

687
00:25:00,159 --> 00:25:01,679
too much

688
00:25:01,679 --> 00:25:03,360
so it's case basically so it depends a

689
00:25:03,360 --> 00:25:05,600
little bit on what the relation that you

690
00:25:05,600 --> 00:25:08,080
need exactly is

691
00:25:08,080 --> 00:25:09,679
thanks

692
00:25:09,679 --> 00:25:11,360
thanks for the wonderful talk thank you

693
00:25:11,360 --> 00:25:14,360
speaker

694
00:25:57,840 --> 00:26:00,840
um

695
00:26:17,279 --> 00:26:20,000
all right um

696
00:26:20,000 --> 00:26:21,200
i guess i'll

697
00:26:21,200 --> 00:26:24,520
wait a minute

698
00:26:25,840 --> 00:26:28,559
all right um the next speaker is suzuma

699
00:26:28,559 --> 00:26:30,000
kiyoshima

700
00:26:30,000 --> 00:26:31,760
with a public coin three round zero

701
00:26:31,760 --> 00:26:33,360
knowledge from learning the errors and

702
00:26:33,360 --> 00:26:37,879
keyless multi-collision resistant cash

703
00:26:42,159 --> 00:26:45,039
hi everyone hi everyone i'm kiyoshima

704
00:26:45,039 --> 00:26:47,600
from ntt research and today i'm going to

705
00:26:47,600 --> 00:26:49,360
talk about my recent work about the

706
00:26:49,360 --> 00:26:53,600
public point series of zero drug

707
00:26:53,600 --> 00:26:56,159
so i guess many of the many

708
00:26:56,159 --> 00:26:57,520
many people in this world are already

709
00:26:57,520 --> 00:27:00,000
familiar with the xerology argument so i

710
00:27:00,000 --> 00:27:02,080
just briefly declared that in a zero

711
00:27:02,080 --> 00:27:04,480
large argument a particular can convince

712
00:27:04,480 --> 00:27:06,880
a verifier about the presence about the

713
00:27:06,880 --> 00:27:08,559
correctness of a statement without

714
00:27:08,559 --> 00:27:10,400
repeating anything beyond the fact that

715
00:27:10,400 --> 00:27:12,000
the statement too

716
00:27:12,000 --> 00:27:14,080
and it is called an argument rather than

717
00:27:14,080 --> 00:27:16,720
true because we only cause the soundness

718
00:27:16,720 --> 00:27:21,520
against polynomial time-checking triple

719
00:27:21,520 --> 00:27:24,000
and the focus of this talk is a

720
00:27:24,000 --> 00:27:26,000
three-round construction of zeroni

721
00:27:26,000 --> 00:27:27,200
argument

722
00:27:27,200 --> 00:27:29,279
so as shown in this picture we only

723
00:27:29,279 --> 00:27:31,760
posted a construction where the first

724
00:27:31,760 --> 00:27:34,000
message is sent by the ruler the second

725
00:27:34,000 --> 00:27:35,760
message is sent by the verifier and the

726
00:27:35,760 --> 00:27:39,679
last message is sent by the approval

727
00:27:40,720 --> 00:27:42,640
so syrian construction are interesting

728
00:27:42,640 --> 00:27:44,799
for the ronald argument because

729
00:27:44,799 --> 00:27:47,120
they are optimal in terms of complexity

730
00:27:47,120 --> 00:27:49,279
due to the classical impossibility of

731
00:27:49,279 --> 00:27:51,840
two-round seminars

732
00:27:51,840 --> 00:27:54,720
however unfortunately 300 knowledge is

733
00:27:54,720 --> 00:27:57,360
also hard to obtain and in particular it

734
00:27:57,360 --> 00:27:59,520
is known that three-round zero knowledge

735
00:27:59,520 --> 00:28:03,279
with black box simulation is impossible

736
00:28:03,279 --> 00:28:05,679
so this impossibility means that many of

737
00:28:05,679 --> 00:28:07,200
the well-known techniques about their

738
00:28:07,200 --> 00:28:09,279
own knowledge cannot be used to obtain

739
00:28:09,279 --> 00:28:10,880
three-language knowledge

740
00:28:10,880 --> 00:28:12,960
and because of this difficulty until

741
00:28:12,960 --> 00:28:15,679
recently 3-0 knowledge has been obtained

742
00:28:15,679 --> 00:28:18,399
only under strong unfortunate assumption

743
00:28:18,399 --> 00:28:20,240
such as the knowledge of exponent

744
00:28:20,240 --> 00:28:23,200
assumption or under weaker definition

745
00:28:23,200 --> 00:28:24,960
such as the superpower imagination

746
00:28:24,960 --> 00:28:28,960
security or weak zero knowledge

747
00:28:29,679 --> 00:28:32,000
so this frustrating situation about sri

748
00:28:32,000 --> 00:28:34,000
lanka knowledge has changed recently

749
00:28:34,000 --> 00:28:36,320
because of the recent work by pitansky

750
00:28:36,320 --> 00:28:37,840
karai and the panis

751
00:28:37,840 --> 00:28:40,080
who show that the sri lankan knowledge

752
00:28:40,080 --> 00:28:42,640
can be obtained from cross-polynomial

753
00:28:42,640 --> 00:28:44,559
hardness of the learning with errors

754
00:28:44,559 --> 00:28:45,679
assumption

755
00:28:45,679 --> 00:28:48,480
and slightly superpoint harness of the

756
00:28:48,480 --> 00:28:50,080
keyless marriage originally distance

757
00:28:50,080 --> 00:28:52,559
functions

758
00:28:52,720 --> 00:28:55,760
so clearly lwe is a well-studied very

759
00:28:55,760 --> 00:28:57,600
standard assumption

760
00:28:57,600 --> 00:29:00,080
so what is important about this result

761
00:29:00,080 --> 00:29:01,440
is the assumption about the key

762
00:29:01,440 --> 00:29:04,640
destination collision research functions

763
00:29:04,640 --> 00:29:06,880
so what are keyless molecular geometries

764
00:29:06,880 --> 00:29:09,679
of hash function

765
00:29:09,679 --> 00:29:12,399
so first marriage collision is just a

766
00:29:12,399 --> 00:29:14,640
simple generalization of the standard

767
00:29:14,640 --> 00:29:16,240
notion of collision

768
00:29:16,240 --> 00:29:18,640
and in particular any collision is a top

769
00:29:18,640 --> 00:29:21,520
row of distinct an element that has the

770
00:29:21,520 --> 00:29:23,679
same element

771
00:29:23,679 --> 00:29:26,240
then magical region resistance basically

772
00:29:26,240 --> 00:29:28,080
say that it is hard to find numeric

773
00:29:28,080 --> 00:29:29,200
position

774
00:29:29,200 --> 00:29:31,679
but it is defined for a bit carefully

775
00:29:31,679 --> 00:29:34,000
for qrs hash function so that it is

776
00:29:34,000 --> 00:29:35,679
meaningful even for non-informed

777
00:29:35,679 --> 00:29:38,399
adversaries

778
00:29:38,559 --> 00:29:40,159
and in particular any collision

779
00:29:40,159 --> 00:29:42,880
resistance say that any adversary with

780
00:29:42,880 --> 00:29:46,080
no uniform advice of size s cannot find

781
00:29:46,080 --> 00:29:48,720
any collision for n that is much larger

782
00:29:48,720 --> 00:29:50,480
than s

783
00:29:50,480 --> 00:29:53,279
so basically this definition say that

784
00:29:53,279 --> 00:29:55,440
even knowing from adversary have some

785
00:29:55,440 --> 00:29:57,200
marriage collision as you know each

786
00:29:57,200 --> 00:29:58,399
moment but

787
00:29:58,399 --> 00:30:00,640
they still cannot be find any additional

788
00:30:00,640 --> 00:30:03,360
multicollision of much larger size

789
00:30:03,360 --> 00:30:05,679
so so more simply a small merge

790
00:30:05,679 --> 00:30:07,919
collision is useless to find the big

791
00:30:07,919 --> 00:30:09,279
marriage policy

792
00:30:09,279 --> 00:30:11,279
and for this for this result of beating

793
00:30:11,279 --> 00:30:12,960
schedule it suffices that in the

794
00:30:12,960 --> 00:30:14,960
collision resistance hold for some m

795
00:30:14,960 --> 00:30:17,120
that is a polynomial in the size s of

796
00:30:17,120 --> 00:30:19,678
that muscle

797
00:30:20,399 --> 00:30:22,640
so as you can see here's my journey

798
00:30:22,640 --> 00:30:24,399
distance has a relatively simple

799
00:30:24,399 --> 00:30:27,360
definition and which is false fiber and

800
00:30:27,360 --> 00:30:29,360
it's impossible to assume that the the

801
00:30:29,360 --> 00:30:31,120
other word the keyless hash function

802
00:30:31,120 --> 00:30:33,200
like sure satisfy this notion of much

803
00:30:33,200 --> 00:30:34,960
collision resistance

804
00:30:34,960 --> 00:30:37,600
so basically this without orbital steel

805
00:30:37,600 --> 00:30:39,840
at all can be shown can be viewed as a

806
00:30:39,840 --> 00:30:41,919
result showing that the three-long zero

807
00:30:41,919 --> 00:30:43,679
knowledge can be obtained

808
00:30:43,679 --> 00:30:48,440
from simple forged phi assumptions

809
00:30:50,320 --> 00:30:51,600
then uh

810
00:30:51,600 --> 00:30:54,480
given this result of beta stator

811
00:30:54,480 --> 00:30:56,320
uh in this work we show that the

812
00:30:56,320 --> 00:30:57,840
stability points three language

813
00:30:57,840 --> 00:31:00,559
knowledge can be obtained

814
00:31:00,559 --> 00:31:02,960
from almost the same assumption as the

815
00:31:02,960 --> 00:31:05,519
beta scatter protocol

816
00:31:05,519 --> 00:31:07,840
and in particular we obtain it from

817
00:31:07,840 --> 00:31:10,000
sub-exponential hardness of the learning

818
00:31:10,000 --> 00:31:11,760
with errors assumption

819
00:31:11,760 --> 00:31:14,159
and slightly superpowering hardness of

820
00:31:14,159 --> 00:31:15,840
the key smallest projected energy starch

821
00:31:15,840 --> 00:31:18,840
functions

822
00:31:20,480 --> 00:31:22,720
so require that the azure energy

823
00:31:22,720 --> 00:31:25,279
argument is called public point if the

824
00:31:25,279 --> 00:31:27,679
verifier only sends out some point dose

825
00:31:27,679 --> 00:31:29,120
to the verb

826
00:31:29,120 --> 00:31:31,440
and it outputs it computes the final

827
00:31:31,440 --> 00:31:33,120
output deterministically from the

828
00:31:33,120 --> 00:31:35,678
transcript

829
00:31:35,919 --> 00:31:37,600
so many of the well-known zero-net

830
00:31:37,600 --> 00:31:40,880
protocols such as gmaw and brown have a

831
00:31:40,880 --> 00:31:42,159
public point

832
00:31:42,159 --> 00:31:43,120
but the

833
00:31:43,120 --> 00:31:45,039
the protocol obviously at all that i

834
00:31:45,039 --> 00:31:47,039
explained in the previous slide is not

835
00:31:47,039 --> 00:31:48,320
public point

836
00:31:48,320 --> 00:31:49,039
so

837
00:31:49,039 --> 00:31:50,640
fabric points three and zero knowledge

838
00:31:50,640 --> 00:31:53,200
is a theoretically very natural target

839
00:31:53,200 --> 00:31:55,279
and this result give a positive answer

840
00:31:55,279 --> 00:31:56,480
about this

841
00:31:56,480 --> 00:32:00,200
about this question

842
00:32:00,480 --> 00:32:03,200
and also since our protocol is a public

843
00:32:03,200 --> 00:32:05,840
point it automatically satisfy several

844
00:32:05,840 --> 00:32:08,559
additional use property such as public

845
00:32:08,559 --> 00:32:11,200
verifiability meaning that the anyone

846
00:32:11,200 --> 00:32:13,200
other than verifier can also check

847
00:32:13,200 --> 00:32:16,399
whether a transcript is accepting or not

848
00:32:16,399 --> 00:32:18,559
and it also stops for a dated delegation

849
00:32:18,559 --> 00:32:20,880
about verified secret state since the

850
00:32:20,880 --> 00:32:22,799
verifier doesn't have any secret state

851
00:32:22,799 --> 00:32:26,760
in a public point protocols

852
00:32:28,320 --> 00:32:30,320
finally compared with the sri lankan

853
00:32:30,320 --> 00:32:33,200
knowledge of dansketo our protocol is

854
00:32:33,200 --> 00:32:36,000
fabric point but it is based on slightly

855
00:32:36,000 --> 00:32:37,760
stronger assumption

856
00:32:37,760 --> 00:32:39,600
and in particular it rely on sub

857
00:32:39,600 --> 00:32:42,640
exponential lw where the the private

858
00:32:42,640 --> 00:32:44,399
point construction of britain's gateway

859
00:32:44,399 --> 00:32:46,480
rely on the transformative hardness of

860
00:32:46,480 --> 00:32:49,120
the lwe

861
00:32:49,120 --> 00:32:51,279
so this difference of the assumption

862
00:32:51,279 --> 00:32:54,320
does not seem very significant but still

863
00:32:54,320 --> 00:32:56,080
it is an interesting open question to

864
00:32:56,080 --> 00:32:58,080
cross this gap between public points

865
00:32:58,080 --> 00:33:00,080
reloads our knowledge and private point

866
00:33:00,080 --> 00:33:02,320
one

867
00:33:04,240 --> 00:33:06,559
all right so this is our result so in

868
00:33:06,559 --> 00:33:08,640
the rest of this talk i will explain our

869
00:33:08,640 --> 00:33:11,640
techniques

870
00:33:11,919 --> 00:33:14,320
so basically our 300 knowledge can be

871
00:33:14,320 --> 00:33:16,720
viewed as a public point version of the

872
00:33:16,720 --> 00:33:17,919
private point three thousand zero

873
00:33:17,919 --> 00:33:20,000
knowledge of britain's gateau so let me

874
00:33:20,000 --> 00:33:22,840
first look for how they obtain their

875
00:33:22,840 --> 00:33:26,240
protocols so first they use learning

876
00:33:26,240 --> 00:33:28,159
with error assumptions to obtain a

877
00:33:28,159 --> 00:33:30,080
primitive for the oracle memory

878
00:33:30,080 --> 00:33:32,080
delegation

879
00:33:32,080 --> 00:33:33,679
so the definition of oracle memory

880
00:33:33,679 --> 00:33:35,600
delegation will be will be explained

881
00:33:35,600 --> 00:33:37,760
shortly and at this moment it's a fight

882
00:33:37,760 --> 00:33:39,519
to think that it is a very efficient

883
00:33:39,519 --> 00:33:43,360
version of inductive argument

884
00:33:44,640 --> 00:33:46,399
then they use the oracle memory

885
00:33:46,399 --> 00:33:48,240
delegation with a key decimal

886
00:33:48,240 --> 00:33:50,159
transformation but materials multiple

887
00:33:50,159 --> 00:33:52,080
journalists has function to obtain

888
00:33:52,080 --> 00:33:53,840
another primitive called memory

889
00:33:53,840 --> 00:33:55,840
delegation

890
00:33:55,840 --> 00:33:58,320
and then use it they use it with a

891
00:33:58,320 --> 00:34:00,399
brachial number technique to obtain a

892
00:34:00,399 --> 00:34:03,678
three-long zeronite argument

893
00:34:04,640 --> 00:34:07,919
then uh what is important for our result

894
00:34:07,919 --> 00:34:10,000
is that the oracle memory delegation

895
00:34:10,000 --> 00:34:12,480
that they first obtained is a private

896
00:34:12,480 --> 00:34:14,239
point

897
00:34:14,239 --> 00:34:16,960
and as a result the 3.0 knowledge that

898
00:34:16,960 --> 00:34:18,960
they have obtained from it is also

899
00:34:18,960 --> 00:34:21,599
private file

900
00:34:23,760 --> 00:34:26,239
then uh given this prior approach our

901
00:34:26,239 --> 00:34:28,800
throat is very natural so we first

902
00:34:28,800 --> 00:34:31,280
obtain a local memory delegation public

903
00:34:31,280 --> 00:34:34,079
point of memory delegation from merit b

904
00:34:34,079 --> 00:34:36,719
and then they are used we use it to

905
00:34:36,719 --> 00:34:38,320
obtain a public point zero zero

906
00:34:38,320 --> 00:34:40,560
knowledge

907
00:34:42,399 --> 00:34:44,960
and in this talk we focus on the step of

908
00:34:44,960 --> 00:34:46,800
obtaining public point relative memory

909
00:34:46,800 --> 00:34:48,719
delegation from merger b

910
00:34:48,719 --> 00:34:50,320
and i just note that we can use

911
00:34:50,320 --> 00:34:52,000
basically the same transformation of the

912
00:34:52,000 --> 00:34:53,520
button circuit

913
00:34:53,520 --> 00:34:56,560
to convert our memory delegation to

914
00:34:56,560 --> 00:35:00,000
public point serial knowledge

915
00:35:01,680 --> 00:35:05,119
so uh the goal in this talk is to obtain

916
00:35:05,119 --> 00:35:07,920
oracle memory delegation from lw

917
00:35:07,920 --> 00:35:09,920
so let me first look for

918
00:35:09,920 --> 00:35:13,280
let me first explain what it is

919
00:35:13,280 --> 00:35:16,160
so in order to memory delegation we have

920
00:35:16,160 --> 00:35:18,079
approved on the verifier as in a

921
00:35:18,079 --> 00:35:20,079
standard interactive argument

922
00:35:20,079 --> 00:35:22,000
but instead of the statement we have a

923
00:35:22,000 --> 00:35:25,200
string for the memory

924
00:35:26,400 --> 00:35:27,280
then

925
00:35:27,280 --> 00:35:29,680
the goal of the oracle memory delegation

926
00:35:29,680 --> 00:35:31,839
is that the verifier delegates some

927
00:35:31,839 --> 00:35:34,079
heavy computation on the memory to the

928
00:35:34,079 --> 00:35:36,480
proverb

929
00:35:37,760 --> 00:35:40,000
so in particular the verifier first and

930
00:35:40,000 --> 00:35:42,480
the function to delegate along with the

931
00:35:42,480 --> 00:35:45,599
challenge string to the proverb

932
00:35:45,599 --> 00:35:47,839
and to prove a value is a function on

933
00:35:47,839 --> 00:35:50,560
the memory and send it to the sends

934
00:35:50,560 --> 00:35:52,960
output to the verifier along with the

935
00:35:52,960 --> 00:35:55,440
proof showing that the correct

936
00:35:55,440 --> 00:35:59,720
the output was correctly computed

937
00:36:00,800 --> 00:36:03,280
now uh an important property about

938
00:36:03,280 --> 00:36:05,920
oracle memory delegation is that the

939
00:36:05,920 --> 00:36:08,560
verifier does not receive the whole

940
00:36:08,560 --> 00:36:11,359
input as as input in the clear

941
00:36:11,359 --> 00:36:12,400
and instead

942
00:36:12,400 --> 00:36:14,800
it is only given oracle access to

943
00:36:14,800 --> 00:36:16,720
encoding those memory

944
00:36:16,720 --> 00:36:18,560
and the verifier only makes a small

945
00:36:18,560 --> 00:36:22,078
number query to the encoding

946
00:36:22,320 --> 00:36:24,240
so this means that even when the memory

947
00:36:24,240 --> 00:36:26,720
is very long the verifier can still be

948
00:36:26,720 --> 00:36:29,040
essent because the verifier does not

949
00:36:29,040 --> 00:36:32,160
even read the entire memory

950
00:36:32,160 --> 00:36:34,320
and in this work indeed in this work we

951
00:36:34,320 --> 00:36:35,359
required

952
00:36:35,359 --> 00:36:37,440
that the verifier runs in a fixed

953
00:36:37,440 --> 00:36:40,240
polynomial time even when the memory the

954
00:36:40,240 --> 00:36:42,079
language of memory is suitable in the

955
00:36:42,079 --> 00:36:44,400
mirror

956
00:36:45,920 --> 00:36:47,680
and of course we also have a soundless

957
00:36:47,680 --> 00:36:50,079
requirement which intuitively says that

958
00:36:50,079 --> 00:36:51,920
the very very approval cannot give a

959
00:36:51,920 --> 00:36:55,920
convincing answer for incorrect talk

960
00:36:57,520 --> 00:37:00,560
so now our record is available is to

961
00:37:00,560 --> 00:37:02,560
obtain public point oracle memory

962
00:37:02,560 --> 00:37:05,759
delegation from writer b

963
00:37:06,000 --> 00:37:08,480
and to understand uh

964
00:37:08,480 --> 00:37:10,800
we use another primitive for the fabric

965
00:37:10,800 --> 00:37:12,560
pointer on delegation

966
00:37:12,560 --> 00:37:15,440
which was recently obtained from adobe

967
00:37:15,440 --> 00:37:17,440
in the name of snag for determining

968
00:37:17,440 --> 00:37:19,599
computation in the common random string

969
00:37:19,599 --> 00:37:22,599
model

970
00:37:23,119 --> 00:37:25,520
so in other words our goal our approach

971
00:37:25,520 --> 00:37:26,960
is to the

972
00:37:26,960 --> 00:37:29,119
decent lw based public control on

973
00:37:29,119 --> 00:37:31,520
delegation as a building block to obtain

974
00:37:31,520 --> 00:37:34,640
work to memory derivation

975
00:37:34,640 --> 00:37:36,960
so before i explain our construction let

976
00:37:36,960 --> 00:37:41,200
me explain the building blocks of fields

977
00:37:43,680 --> 00:37:46,480
so the first building blocks that we use

978
00:37:46,480 --> 00:37:49,200
is the public point-to-round delegation

979
00:37:49,200 --> 00:37:53,119
but javaric ali kuran and chan or jkkz

980
00:37:53,119 --> 00:37:55,920
or homogram lombardi and rosbram or

981
00:37:55,920 --> 00:37:58,560
herrera

982
00:37:59,280 --> 00:38:02,480
so the delegation scheme is obtained by

983
00:38:02,480 --> 00:38:04,079
applying the field simulation

984
00:38:04,079 --> 00:38:06,800
transformation to the succinct inductive

985
00:38:06,800 --> 00:38:09,920
proof of the goldberg and rosebrand

986
00:38:09,920 --> 00:38:12,160
and the soundness of the scheme is based

987
00:38:12,160 --> 00:38:14,560
on the sub-expression hardness of the

988
00:38:14,560 --> 00:38:16,480
learning visuals learning with errors

989
00:38:16,480 --> 00:38:18,960
assumptions

990
00:38:18,960 --> 00:38:21,440
and and the important property of the

991
00:38:21,440 --> 00:38:24,240
scheme is that the scheme has basically

992
00:38:24,240 --> 00:38:26,079
the same syntax other

993
00:38:26,079 --> 00:38:28,160
oracle memory delegation

994
00:38:28,160 --> 00:38:29,920
and in particular the verify only need

995
00:38:29,920 --> 00:38:32,160
to read a small part of the encoding of

996
00:38:32,160 --> 00:38:34,720
the memory

997
00:38:35,359 --> 00:38:37,760
and indeed it stand out that because of

998
00:38:37,760 --> 00:38:40,240
this keep a nice property the scheme can

999
00:38:40,240 --> 00:38:42,400
be easily converted to public policy

1000
00:38:42,400 --> 00:38:43,920
memory delegation

1001
00:38:43,920 --> 00:38:46,400
but the problem is that the the scheme

1002
00:38:46,400 --> 00:38:48,240
works only for limited class of

1003
00:38:48,240 --> 00:38:49,680
computation

1004
00:38:49,680 --> 00:38:51,680
and in particular it works only for

1005
00:38:51,680 --> 00:38:54,240
bounded bounded computation with a

1006
00:38:54,240 --> 00:38:58,560
certain form of succinct descriptions

1007
00:38:59,599 --> 00:39:02,480
so what if what we need for our purpose

1008
00:39:02,480 --> 00:39:04,560
is our local memory delegation for all

1009
00:39:04,560 --> 00:39:06,960
resolution supplement computation so

1010
00:39:06,960 --> 00:39:08,800
even though the scheme can be converted

1011
00:39:08,800 --> 00:39:11,359
to organization unfortunately the scheme

1012
00:39:11,359 --> 00:39:15,440
alone is not sufficient for our purpose

1013
00:39:15,440 --> 00:39:17,359
so in this world video we also use

1014
00:39:17,359 --> 00:39:19,680
another building blocks which was

1015
00:39:19,680 --> 00:39:21,280
which is a public pointer on

1016
00:39:21,280 --> 00:39:23,760
regularization of a child fully

1017
00:39:23,760 --> 00:39:28,119
generating or cj

1018
00:39:28,720 --> 00:39:30,880
so this game is based on slightly

1019
00:39:30,880 --> 00:39:32,720
superpower hardness of the learning

1020
00:39:32,720 --> 00:39:35,200
videos assumption when it is used for

1021
00:39:35,200 --> 00:39:37,599
slightly receiver point of computation

1022
00:39:37,599 --> 00:39:40,240
and just like product memory delegation

1023
00:39:40,240 --> 00:39:42,480
the scheme does not require verifier to

1024
00:39:42,480 --> 00:39:45,119
have the entire memory as input

1025
00:39:45,119 --> 00:39:46,640
and in particular the scheme only

1026
00:39:46,640 --> 00:39:49,040
requires that the verifier has a macro

1027
00:39:49,040 --> 00:39:50,640
hash of the memory

1028
00:39:50,640 --> 00:39:53,759
where they have functions

1029
00:39:54,320 --> 00:39:57,839
it's chosen by the verifier

1030
00:40:01,440 --> 00:40:03,680
now a good point of the scheme is that

1031
00:40:03,680 --> 00:40:06,480
the it works for all slightly superb

1032
00:40:06,480 --> 00:40:07,839
computation

1033
00:40:07,839 --> 00:40:10,319
but the problem is that even though the

1034
00:40:10,319 --> 00:40:12,079
scheme does not require the verifier to

1035
00:40:12,079 --> 00:40:14,640
have the entire input still

1036
00:40:14,640 --> 00:40:16,800
it is not clear how the how the scheme

1037
00:40:16,800 --> 00:40:19,920
can be converted or memory delegation

1038
00:40:19,920 --> 00:40:22,079
so in particular the problem is that it

1039
00:40:22,079 --> 00:40:24,240
is not clear how the verifier contains

1040
00:40:24,240 --> 00:40:26,240
the mac flash of the memory in the

1041
00:40:26,240 --> 00:40:28,560
setting of all of the memory delegation

1042
00:40:28,560 --> 00:40:30,240
where the verifier only can only make a

1043
00:40:30,240 --> 00:40:31,599
small number of queries you are

1044
00:40:31,599 --> 00:40:33,040
including those

1045
00:40:33,040 --> 00:40:37,640
m2 encoding of the memory

1046
00:40:38,240 --> 00:40:40,640
so in summary we have a two delegation

1047
00:40:40,640 --> 00:40:42,880
scheme so the first one

1048
00:40:42,880 --> 00:40:44,480
can be converted the organ memory

1049
00:40:44,480 --> 00:40:47,040
delegation easily but it works only for

1050
00:40:47,040 --> 00:40:49,520
a limited class of computation and on

1051
00:40:49,520 --> 00:40:51,359
the other on the other hand the second

1052
00:40:51,359 --> 00:40:53,520
one works for all slightly threatening

1053
00:40:53,520 --> 00:40:56,079
superpoint computation but it cannot be

1054
00:40:56,079 --> 00:40:58,720
converted to oracle memory delays

1055
00:40:58,720 --> 00:41:00,160
so neither of them are wrong it's

1056
00:41:00,160 --> 00:41:03,520
sufficient for up ups

1057
00:41:04,640 --> 00:41:07,440
now uh given this is it

1058
00:41:07,440 --> 00:41:10,480
situation our approach is very natural

1059
00:41:10,480 --> 00:41:12,160
we basically we combine these two

1060
00:41:12,160 --> 00:41:14,880
dedication scheme to obtain

1061
00:41:14,880 --> 00:41:15,760
fabric

1062
00:41:15,760 --> 00:41:17,920
memory delegation for all slightly super

1063
00:41:17,920 --> 00:41:21,240
common computations

1064
00:41:22,079 --> 00:41:24,560
so finally i'm i'm ready to explain our

1065
00:41:24,560 --> 00:41:26,640
construction

1066
00:41:26,640 --> 00:41:28,720
so

1067
00:41:28,720 --> 00:41:30,960
the first step of scheme is that the

1068
00:41:30,960 --> 00:41:34,240
provider uses the delegation of kkkd and

1069
00:41:34,240 --> 00:41:35,359
agera

1070
00:41:35,359 --> 00:41:37,359
to prove the correctness of the macro

1071
00:41:37,359 --> 00:41:40,640
hash computation of the memory

1072
00:41:40,640 --> 00:41:42,720
so in particular the verifiers and the

1073
00:41:42,720 --> 00:41:44,640
hash function along with the challenge

1074
00:41:44,640 --> 00:41:46,480
strings to the proverbial

1075
00:41:46,480 --> 00:41:48,319
and the purple computer marks hash of

1076
00:41:48,319 --> 00:41:51,040
the memory and send it to the verifier

1077
00:41:51,040 --> 00:41:53,119
along with the pro showing that the

1078
00:41:53,119 --> 00:41:57,200
macro hash was correctly computed

1079
00:41:57,760 --> 00:42:00,720
so recall that the delegation of jkd and

1080
00:42:00,720 --> 00:42:03,040
hlr can be converted to oracle

1081
00:42:03,040 --> 00:42:04,880
memorization output memorization

1082
00:42:04,880 --> 00:42:06,560
delegation easily

1083
00:42:06,560 --> 00:42:09,040
so this step over scheme can be done in

1084
00:42:09,040 --> 00:42:12,400
a way that the verifier only have a

1085
00:42:12,400 --> 00:42:13,520
only makes

1086
00:42:13,520 --> 00:42:16,319
oracle query twice encoding of the input

1087
00:42:16,319 --> 00:42:19,440
from encoding of the memory

1088
00:42:19,440 --> 00:42:22,079
and also even though the scheme

1089
00:42:22,079 --> 00:42:24,160
works only for a bounded tip circuit

1090
00:42:24,160 --> 00:42:25,760
with a certain form of succinct

1091
00:42:25,760 --> 00:42:27,040
description

1092
00:42:27,040 --> 00:42:29,280
uh it stands out that the scheme can be

1093
00:42:29,280 --> 00:42:32,800
used for macro hash computation

1094
00:42:32,800 --> 00:42:35,280
so i won't explain the technical detail

1095
00:42:35,280 --> 00:42:37,680
about the rhythm with this but the point

1096
00:42:37,680 --> 00:42:38,560
is that

1097
00:42:38,560 --> 00:42:40,800
simply that microsoft computation can be

1098
00:42:40,800 --> 00:42:43,200
described very succinctly so in

1099
00:42:43,200 --> 00:42:44,800
particular we can obtain a circuit for

1100
00:42:44,800 --> 00:42:47,520
much harsh computation by just combining

1101
00:42:47,520 --> 00:42:49,839
a many copy of small subcircuits that

1102
00:42:49,839 --> 00:42:51,839
compute the

1103
00:42:51,839 --> 00:42:54,560
underlying hash function

1104
00:42:54,560 --> 00:42:56,960
so given this succinct description of

1105
00:42:56,960 --> 00:42:58,720
macro hash computation actually it is

1106
00:42:58,720 --> 00:43:00,800
very easy to observe that

1107
00:43:00,800 --> 00:43:02,720
the delegation scheme of jkkg and the

1108
00:43:02,720 --> 00:43:05,680
general can be used for to rehash macro

1109
00:43:05,680 --> 00:43:08,240
computation

1110
00:43:09,599 --> 00:43:11,920
now the second step of the scheme is

1111
00:43:11,920 --> 00:43:14,160
that the the peripheral uses the

1112
00:43:14,160 --> 00:43:17,359
delegation of cjj to prove arbitrary

1113
00:43:17,359 --> 00:43:19,599
computation on the memory

1114
00:43:19,599 --> 00:43:22,079
so in particular the verifier sends a

1115
00:43:22,079 --> 00:43:23,920
function to delegate along with the

1116
00:43:23,920 --> 00:43:26,000
challenge string to the proverb

1117
00:43:26,000 --> 00:43:27,760
and the purple variety function the

1118
00:43:27,760 --> 00:43:30,640
memory and send it to the verifier along

1119
00:43:30,640 --> 00:43:32,880
with the blue showing that the output

1120
00:43:32,880 --> 00:43:36,160
was correctly computed

1121
00:43:36,480 --> 00:43:38,880
so recall that the cjg delegate scheme

1122
00:43:38,880 --> 00:43:41,119
works for all cyclists upon them super

1123
00:43:41,119 --> 00:43:42,640
punishment computation

1124
00:43:42,640 --> 00:43:44,880
so indeed in our scheme the peripheral

1125
00:43:44,880 --> 00:43:47,280
can use it to prove any arbitrary

1126
00:43:47,280 --> 00:43:50,400
computation on the memory

1127
00:43:50,400 --> 00:43:52,640
and also even though the

1128
00:43:52,640 --> 00:43:55,119
the data delegation scheme requires that

1129
00:43:55,119 --> 00:43:57,200
the verifier have the macro flash of the

1130
00:43:57,200 --> 00:43:58,240
memory

1131
00:43:58,240 --> 00:43:59,200
uh

1132
00:43:59,200 --> 00:44:01,520
we can still use it in your scheme since

1133
00:44:01,520 --> 00:44:03,200
in your scheme the verifier obtained the

1134
00:44:03,200 --> 00:44:07,799
micro first of the memory from the proof

1135
00:44:09,359 --> 00:44:11,839
now basically the soundness of of our

1136
00:44:11,839 --> 00:44:13,839
skin follow very naturally from the

1137
00:44:13,839 --> 00:44:15,839
underlying derivation scheme and in

1138
00:44:15,839 --> 00:44:17,920
particular from the soundness of the cj

1139
00:44:17,920 --> 00:44:20,640
delegation scheme because

1140
00:44:20,640 --> 00:44:22,640
the macro house that verify obtained

1141
00:44:22,640 --> 00:44:24,800
from the proverbial is guaranteed to be

1142
00:44:24,800 --> 00:44:27,520
correct because of the soundness of the

1143
00:44:27,520 --> 00:44:31,920
delegation of the gttc and hr

1144
00:44:32,800 --> 00:44:35,440
so in this way we obtain a public work

1145
00:44:35,440 --> 00:44:38,880
memory delegation from lwe

1146
00:44:38,880 --> 00:44:41,119
and at the state area we can transform

1147
00:44:41,119 --> 00:44:43,520
it to public points relationally several

1148
00:44:43,520 --> 00:44:46,319
knowledge by using uh just known

1149
00:44:46,319 --> 00:44:48,640
transformations

1150
00:44:48,640 --> 00:44:50,400
so in particular people who are familiar

1151
00:44:50,400 --> 00:44:52,319
with barack obama technique and think

1152
00:44:52,319 --> 00:44:53,359
that

1153
00:44:53,359 --> 00:44:55,440
the memory delegations that we obtain

1154
00:44:55,440 --> 00:44:57,920
from oral memory delegation uh can be

1155
00:44:57,920 --> 00:44:59,839
used as a universal argument in biology

1156
00:44:59,839 --> 00:45:02,240
number technique and since the memory

1157
00:45:02,240 --> 00:45:04,480
delegation has only two runs we can

1158
00:45:04,480 --> 00:45:06,640
reduce the barack number second but you

1159
00:45:06,640 --> 00:45:08,160
can reduce around the complexity of

1160
00:45:08,160 --> 00:45:10,240
product zero knowledge to three so we

1161
00:45:10,240 --> 00:45:14,240
can obtain public point zero match

1162
00:45:14,400 --> 00:45:17,520
so in conclusion in this work we show

1163
00:45:17,520 --> 00:45:19,280
that the public points relational

1164
00:45:19,280 --> 00:45:21,760
knowledge can be obtained from a simple

1165
00:45:21,760 --> 00:45:23,520
forged by assumption

1166
00:45:23,520 --> 00:45:25,520
and the particularity can be obtained

1167
00:45:25,520 --> 00:45:27,760
from sub-exponential harness of the

1168
00:45:27,760 --> 00:45:29,680
lining with our lining with errors

1169
00:45:29,680 --> 00:45:30,800
assumption

1170
00:45:30,800 --> 00:45:33,040
and the slightly superpoint hardness of

1171
00:45:33,040 --> 00:45:34,720
the keyless molecule generally this has

1172
00:45:34,720 --> 00:45:37,200
functions

1173
00:45:38,079 --> 00:45:40,160
so an important and interesting open

1174
00:45:40,160 --> 00:45:42,480
question is to weaken the assumption of

1175
00:45:42,480 --> 00:45:43,680
our result

1176
00:45:43,680 --> 00:45:45,280
and in particular weakness assumption

1177
00:45:45,280 --> 00:45:47,480
about aw from

1178
00:45:47,480 --> 00:45:50,240
sub-exponentialness of the lwe to the

1179
00:45:50,240 --> 00:45:52,560
corresponding harness of the little b

1180
00:45:52,560 --> 00:45:54,160
so if we can do this we can close the

1181
00:45:54,160 --> 00:45:56,079
gap between public points reliance of

1182
00:45:56,079 --> 00:45:59,520
knowledge and the private point one

1183
00:45:59,520 --> 00:46:02,480
and another more ambitious open question

1184
00:46:02,480 --> 00:46:05,119
is to obtain serious knowledge from a

1185
00:46:05,119 --> 00:46:07,760
small standard assumption

1186
00:46:07,760 --> 00:46:09,839
so in particular uh curious marriage

1187
00:46:09,839 --> 00:46:11,839
project this has function is a

1188
00:46:11,839 --> 00:46:14,640
relatively new hardware assumption so it

1189
00:46:14,640 --> 00:46:16,560
will be good if we continuously answer

1190
00:46:16,560 --> 00:46:18,800
knowledge from other primitives that are

1191
00:46:18,800 --> 00:46:21,280
more standard than the keyless molecular

1192
00:46:21,280 --> 00:46:23,839
discharge function

1193
00:46:23,839 --> 00:46:26,400
okay and this concludes my talk so thank

1194
00:46:26,400 --> 00:46:29,800
you for again

1195
00:46:46,640 --> 00:46:48,560
um thank you very much for the wonderful

1196
00:46:48,560 --> 00:46:51,280
talk and fantastic result um we have

1197
00:46:51,280 --> 00:46:52,880
time for a question if anybody has a

1198
00:46:52,880 --> 00:46:54,560
question if nobody has a question i have

1199
00:46:54,560 --> 00:46:55,599
a question

1200
00:46:55,599 --> 00:46:57,839
okay i'm going to ask my question

1201
00:46:57,839 --> 00:47:01,040
so my question is in your um road map on

1202
00:47:01,040 --> 00:47:02,800
slide 15

1203
00:47:02,800 --> 00:47:06,240
um what parts of it actually need lwe

1204
00:47:06,240 --> 00:47:08,800
and what parts of it are just general

1205
00:47:08,800 --> 00:47:10,240
enough that if you're given these

1206
00:47:10,240 --> 00:47:11,760
building blocks you can get the same

1207
00:47:11,760 --> 00:47:14,160
result

1208
00:47:17,040 --> 00:47:21,200
on slide 15 why do you need lwe

1209
00:47:22,000 --> 00:47:24,720
so the question is uh

1210
00:47:24,720 --> 00:47:26,880
why we need lwe

1211
00:47:26,880 --> 00:47:28,079
from

1212
00:47:28,079 --> 00:47:29,680
here yeah

1213
00:47:29,680 --> 00:47:30,559
uh

1214
00:47:30,559 --> 00:47:31,599
that's

1215
00:47:31,599 --> 00:47:33,520
because

1216
00:47:33,520 --> 00:47:34,960
we currently

1217
00:47:34,960 --> 00:47:36,559
have only public

1218
00:47:36,559 --> 00:47:38,720
the

1219
00:47:46,240 --> 00:47:48,800
so if you could swap um another

1220
00:47:48,800 --> 00:47:50,160
construction

1221
00:47:50,160 --> 00:47:52,240
of public coin to round oracle memory

1222
00:47:52,240 --> 00:47:53,760
delegation and another construction of

1223
00:47:53,760 --> 00:47:55,680
public coin to run memory delegation

1224
00:47:55,680 --> 00:47:58,000
yeah then then it would so basically

1225
00:47:58,000 --> 00:48:00,480
your trans your transform is general

1226
00:48:00,480 --> 00:48:02,079
it's just that the building blocks need

1227
00:48:02,079 --> 00:48:06,839
lwe yeah okay thanks

1228
00:48:07,440 --> 00:48:11,319
let's thank the speaker again

1229
00:48:34,960 --> 00:48:35,839
okay

1230
00:48:35,839 --> 00:48:38,319
can this mix on cool

1231
00:48:38,319 --> 00:48:40,558
uh

1232
00:48:40,960 --> 00:48:42,400
what

1233
00:48:42,400 --> 00:48:44,880
can i start okay so the next

1234
00:48:44,880 --> 00:48:46,839
the next

1235
00:48:46,839 --> 00:48:50,079
talk the next talk is faster sound or

1236
00:48:50,079 --> 00:48:52,480
succinct arguments and iops

1237
00:48:52,480 --> 00:48:54,720
by justin holmgren and ron roslin and

1238
00:48:54,720 --> 00:48:57,440
justin will give the talk thank you uh

1239
00:48:57,440 --> 00:48:59,040
yeah so

1240
00:48:59,040 --> 00:49:00,720
i thought i should start by

1241
00:49:00,720 --> 00:49:03,839
maybe explaining how to parse the title

1242
00:49:03,839 --> 00:49:06,079
oh

1243
00:49:06,079 --> 00:49:07,359
uh that's

1244
00:49:07,359 --> 00:49:10,000
the wrong version of the slides ugh okay

1245
00:49:10,000 --> 00:49:12,720
well we'll see it'll be fun so we're all

1246
00:49:12,720 --> 00:49:14,640
in the proof system slide proof system

1247
00:49:14,640 --> 00:49:16,400
session i assume we all

1248
00:49:16,400 --> 00:49:18,480
uh love proof systems if not i'll try to

1249
00:49:18,480 --> 00:49:21,520
convince you uh very quickly that you do

1250
00:49:21,520 --> 00:49:22,400
so

1251
00:49:22,400 --> 00:49:24,160
proof systems are this amazing uh

1252
00:49:24,160 --> 00:49:25,760
success story and theoretical computer

1253
00:49:25,760 --> 00:49:27,839
science really amazing um you know it

1254
00:49:27,839 --> 00:49:29,280
started out in the 80s nobody thought

1255
00:49:29,280 --> 00:49:32,079
any of this would be practical but the

1256
00:49:32,079 --> 00:49:34,240
the we kept evolving the notion of a

1257
00:49:34,240 --> 00:49:35,520
proof we started with np proofs

1258
00:49:35,520 --> 00:49:37,040
interactive proofs and then this whole

1259
00:49:37,040 --> 00:49:39,760
thing blossomed and uh they led to other

1260
00:49:39,760 --> 00:49:41,760
related notions that now we think of as

1261
00:49:41,760 --> 00:49:43,280
very central like a fear of mp

1262
00:49:43,280 --> 00:49:46,880
completeness zero knowledge uh pcps

1263
00:49:46,880 --> 00:49:49,920
um so there's this theoretical side of

1264
00:49:49,920 --> 00:49:52,160
proof systems but also i've heard that

1265
00:49:52,160 --> 00:49:54,079
recently they've started to have some

1266
00:49:54,079 --> 00:49:55,839
real world applications i've never

1267
00:49:55,839 --> 00:49:57,200
implemented a proof system in my life

1268
00:49:57,200 --> 00:49:58,800
but i think this person has and he says

1269
00:49:58,800 --> 00:49:59,599
that

1270
00:49:59,599 --> 00:50:01,440
succinct zero knowledge proofs are very

1271
00:50:01,440 --> 00:50:03,760
useful

1272
00:50:04,880 --> 00:50:06,960
however one of the major barriers to

1273
00:50:06,960 --> 00:50:09,200
further

1274
00:50:09,200 --> 00:50:11,599
deployment of proof systems is the

1275
00:50:11,599 --> 00:50:13,359
prover efficiency

1276
00:50:13,359 --> 00:50:14,800
so in practice

1277
00:50:14,800 --> 00:50:17,200
proving is much slower than uh than just

1278
00:50:17,200 --> 00:50:19,200
doing a computation with no proof which

1279
00:50:19,200 --> 00:50:22,160
is the best you can hope for

1280
00:50:22,160 --> 00:50:24,319
and uh so the the natural question of

1281
00:50:24,319 --> 00:50:25,280
like how

1282
00:50:25,280 --> 00:50:27,040
inherent is this gap can proving be as

1283
00:50:27,040 --> 00:50:29,280
fast as computing

1284
00:50:29,280 --> 00:50:30,559
and so we're going to look at pretty

1285
00:50:30,559 --> 00:50:32,720
small factors here and so i want to be

1286
00:50:32,720 --> 00:50:34,240
pretty precise about what computational

1287
00:50:34,240 --> 00:50:37,359
model we're using to measure complexity

1288
00:50:37,359 --> 00:50:39,119
and we're using boolean circuits which i

1289
00:50:39,119 --> 00:50:40,480
think are the

1290
00:50:40,480 --> 00:50:43,280
the best most natural uh computational

1291
00:50:43,280 --> 00:50:45,680
model they're uh

1292
00:50:45,680 --> 00:50:48,319
super just natural i think they very

1293
00:50:48,319 --> 00:50:50,240
closely match the physical cost of

1294
00:50:50,240 --> 00:50:51,680
implementing something in hardware and

1295
00:50:51,680 --> 00:50:52,880
there are a lot of computations that we

1296
00:50:52,880 --> 00:50:54,480
might want to delegate or we want to

1297
00:50:54,480 --> 00:50:56,800
prove stuff about for example uh

1298
00:50:56,800 --> 00:50:58,160
these sort of mini crypt like hash

1299
00:50:58,160 --> 00:51:00,240
functions that are

1300
00:51:00,240 --> 00:51:01,119
uh

1301
00:51:01,119 --> 00:51:04,640
not by default uh nicely arithmetizable

1302
00:51:04,640 --> 00:51:06,160
so that's the alternative to boolean

1303
00:51:06,160 --> 00:51:07,680
circuits that people often study and

1304
00:51:07,680 --> 00:51:09,280
improve systems it's like arithmetic

1305
00:51:09,280 --> 00:51:10,880
circuits over

1306
00:51:10,880 --> 00:51:13,680
larger fields

1307
00:51:14,480 --> 00:51:15,440
so

1308
00:51:15,440 --> 00:51:16,960
when we talk about

1309
00:51:16,960 --> 00:51:18,559
uh the

1310
00:51:18,559 --> 00:51:20,319
the prover complexity in this talk we're

1311
00:51:20,319 --> 00:51:21,680
talking about a cost that's

1312
00:51:21,680 --> 00:51:23,839
parameterized by two inputs so first of

1313
00:51:23,839 --> 00:51:25,520
all there's the size of the circuit that

1314
00:51:25,520 --> 00:51:26,960
you're the

1315
00:51:26,960 --> 00:51:28,800
size of the computation that you're

1316
00:51:28,800 --> 00:51:30,960
trying to uh to prove something about

1317
00:51:30,960 --> 00:51:33,119
and then there's the soundness error the

1318
00:51:33,119 --> 00:51:35,200
probability of verifier accidentally

1319
00:51:35,200 --> 00:51:37,920
accept an incorrect statement and uh

1320
00:51:37,920 --> 00:51:39,599
usually think of the soundness that are

1321
00:51:39,599 --> 00:51:41,440
as exponentially small

1322
00:51:41,440 --> 00:51:43,200
in uh something called a security

1323
00:51:43,200 --> 00:51:44,319
parameter

1324
00:51:44,319 --> 00:51:46,480
and uh the the security parameter is

1325
00:51:46,480 --> 00:51:48,400
usually somewhere in between like the

1326
00:51:48,400 --> 00:51:50,160
log of the size of the computation and

1327
00:51:50,160 --> 00:51:52,800
the and much smaller than and then the

1328
00:51:52,800 --> 00:51:56,160
entire computation than the size

1329
00:51:56,720 --> 00:51:59,599
um so just to survive some of the the

1330
00:51:59,599 --> 00:52:01,760
previous work there was a recent uh

1331
00:52:01,760 --> 00:52:03,520
breakthrough by uh

1332
00:52:03,520 --> 00:52:05,760
renzuri and rothbloom that

1333
00:52:05,760 --> 00:52:07,599
showed how to

1334
00:52:07,599 --> 00:52:09,920
prove the satisfiability of boolean

1335
00:52:09,920 --> 00:52:11,760
circuits with a

1336
00:52:11,760 --> 00:52:13,760
complexity that

1337
00:52:13,760 --> 00:52:15,200
was proportional to the size of the

1338
00:52:15,200 --> 00:52:16,880
circuit and the

1339
00:52:16,880 --> 00:52:18,640
security parameter

1340
00:52:18,640 --> 00:52:19,920
uh

1341
00:52:19,920 --> 00:52:21,680
so this dependency on the security

1342
00:52:21,680 --> 00:52:23,760
parameter comes from uh basically

1343
00:52:23,760 --> 00:52:25,920
parallel repeating the basic protocol

1344
00:52:25,920 --> 00:52:27,520
gives constant soundness error and they

1345
00:52:27,520 --> 00:52:29,359
repeat lambda times so that's where the

1346
00:52:29,359 --> 00:52:31,040
factor of lambda comes from

1347
00:52:31,040 --> 00:52:33,119
on the other hand if we're in a setting

1348
00:52:33,119 --> 00:52:34,240
where the

1349
00:52:34,240 --> 00:52:36,640
the you have an arithmetic circuit over

1350
00:52:36,640 --> 00:52:38,400
a large field so actually bigger than

1351
00:52:38,400 --> 00:52:40,319
what i said but not too much like an

1352
00:52:40,319 --> 00:52:44,400
exponentially large field then you can

1353
00:52:44,400 --> 00:52:46,880
have a proof system in which the provers

1354
00:52:46,880 --> 00:52:48,880
complexity is basically linear in the

1355
00:52:48,880 --> 00:52:51,440
size of the computation

1356
00:52:51,440 --> 00:52:52,319
uh

1357
00:52:52,319 --> 00:52:54,558
and

1358
00:52:54,640 --> 00:52:56,480
uh so yeah in our

1359
00:52:56,480 --> 00:52:59,440
our work we we sort of improve on

1360
00:52:59,440 --> 00:53:01,359
on this we

1361
00:53:01,359 --> 00:53:02,960
reduce the dependency of the security

1362
00:53:02,960 --> 00:53:04,240
parameter from linear to poly

1363
00:53:04,240 --> 00:53:05,520
logarithmic so i guess you can call it

1364
00:53:05,520 --> 00:53:08,160
an exponential improvement if you like

1365
00:53:08,160 --> 00:53:10,079
there's one caveat that this only holds

1366
00:53:10,079 --> 00:53:11,040
for

1367
00:53:11,040 --> 00:53:12,000
nice

1368
00:53:12,000 --> 00:53:16,240
boolean circuits uh which and i'll

1369
00:53:16,240 --> 00:53:18,400
elaborate on what i mean by nice but you

1370
00:53:18,400 --> 00:53:19,760
can think of it as just having some kind

1371
00:53:19,760 --> 00:53:21,520
of repetitive structure

1372
00:53:21,520 --> 00:53:24,640
um oh okay so labrador now okay so here

1373
00:53:24,640 --> 00:53:26,480
are some simple examples first

1374
00:53:26,480 --> 00:53:29,119
um and oh the technical definition that

1375
00:53:29,119 --> 00:53:30,559
we use is kind of messy in full

1376
00:53:30,559 --> 00:53:31,680
generality

1377
00:53:31,680 --> 00:53:33,119
so first of all

1378
00:53:33,119 --> 00:53:36,079
um one type of nice circuit is a circuit

1379
00:53:36,079 --> 00:53:39,520
that has a sort of batch structure so to

1380
00:53:39,520 --> 00:53:41,280
evaluate the circuit you just evaluate

1381
00:53:41,280 --> 00:53:42,960
one circuit many times on different

1382
00:53:42,960 --> 00:53:44,559
parts of the input and then hope they

1383
00:53:44,559 --> 00:53:47,440
all evaluate to one

1384
00:53:48,000 --> 00:53:50,800
another example of what i would call a

1385
00:53:50,800 --> 00:53:53,200
nice circuit is an integrated circuit

1386
00:53:53,200 --> 00:53:54,960
where you apply

1387
00:53:54,960 --> 00:53:59,599
a circuit sequentially to some input so

1388
00:53:59,599 --> 00:54:01,200
feed the output of one iteration into

1389
00:54:01,200 --> 00:54:03,919
the input of the next

1390
00:54:05,040 --> 00:54:06,720
and

1391
00:54:06,720 --> 00:54:09,359
nice is sort of a

1392
00:54:09,359 --> 00:54:11,839
quantitative notion here our basic

1393
00:54:11,839 --> 00:54:13,599
verifier and our like like

1394
00:54:13,599 --> 00:54:14,640
straightforward

1395
00:54:14,640 --> 00:54:15,359
or

1396
00:54:15,359 --> 00:54:17,680
core construction has complexity that's

1397
00:54:17,680 --> 00:54:19,760
proportional to the the sort of repeated

1398
00:54:19,760 --> 00:54:23,119
structure here but it can um

1399
00:54:23,119 --> 00:54:25,040
you can you can compose without a proof

1400
00:54:25,040 --> 00:54:26,319
system to get that down basically as

1401
00:54:26,319 --> 00:54:28,319
much as you want if

1402
00:54:28,319 --> 00:54:30,079
if you're lucky yeah

1403
00:54:30,079 --> 00:54:33,599
um there is a more general definition

1404
00:54:33,599 --> 00:54:35,760
uh

1405
00:54:36,799 --> 00:54:39,119
yeah but i i just won't get into it now

1406
00:54:39,119 --> 00:54:40,799
but i'm happy to talk to you about it

1407
00:54:40,799 --> 00:54:43,440
later if you'd like

1408
00:54:43,440 --> 00:54:45,680
so

1409
00:54:47,119 --> 00:54:49,280
actually i'm just gonna download the new

1410
00:54:49,280 --> 00:54:50,640
slides

1411
00:54:50,640 --> 00:54:52,480
it'll take like one minute and i'll be

1412
00:54:52,480 --> 00:54:55,119
much happier

1413
00:54:58,079 --> 00:55:00,000
yeah i downloaded them before i don't

1414
00:55:00,000 --> 00:55:03,720
know why they uh

1415
00:55:06,000 --> 00:55:09,359
i see actually okay

1416
00:55:10,480 --> 00:55:12,230
oops

1417
00:55:12,230 --> 00:55:15,340
[Music]

1418
00:55:25,760 --> 00:55:27,119
okay well

1419
00:55:27,119 --> 00:55:31,240
i will do it like this

1420
00:55:50,480 --> 00:55:53,280
all right here we go

1421
00:55:53,520 --> 00:55:56,400
sorry about that

1422
00:55:59,760 --> 00:56:02,760
um

1423
00:56:04,880 --> 00:56:06,400
yeah so

1424
00:56:06,400 --> 00:56:09,119
here's a sort of tldr result after all

1425
00:56:09,119 --> 00:56:11,359
interruptions sorry um

1426
00:56:11,359 --> 00:56:13,040
so we got a

1427
00:56:13,040 --> 00:56:14,960
succinct proofs where the prover

1428
00:56:14,960 --> 00:56:18,400
complexity is uh the circuit size times

1429
00:56:18,400 --> 00:56:19,839
the polylog factor in the security

1430
00:56:19,839 --> 00:56:21,280
parameter and i'm not going to talk

1431
00:56:21,280 --> 00:56:22,880
about worry about the additive

1432
00:56:22,880 --> 00:56:24,640
polynomial

1433
00:56:24,640 --> 00:56:26,799
you need to share your screen on zoom oh

1434
00:56:26,799 --> 00:56:30,400
i do yeah and uh and when need i think

1435
00:56:30,400 --> 00:56:32,240
wait are you you're already sharing it

1436
00:56:32,240 --> 00:56:33,760
yeah it's interesting that's weird

1437
00:56:33,760 --> 00:56:35,920
because sharing they just you need to go

1438
00:56:35,920 --> 00:56:38,240
full screen it's the uh arrows that are

1439
00:56:38,240 --> 00:56:40,799
pointing in opposite diagonal directions

1440
00:56:40,799 --> 00:56:42,319
oh yes that's right you're sharing the

1441
00:56:42,319 --> 00:56:44,480
other screen that's right yeah

1442
00:56:44,480 --> 00:56:46,160
you need to share this window instead of

1443
00:56:46,160 --> 00:56:49,359
the other one can you show me what to do

1444
00:56:49,359 --> 00:56:51,440
all right and then go back to you go

1445
00:56:51,440 --> 00:56:55,200
back to zoom back to zoom

1446
00:56:56,480 --> 00:56:57,920
share screen and then share the correct

1447
00:56:57,920 --> 00:57:00,640
slides okay

1448
00:57:02,079 --> 00:57:04,160
all right thank you yeah

1449
00:57:04,160 --> 00:57:07,599
is this okay for people on zoom

1450
00:57:07,599 --> 00:57:08,960
yes

1451
00:57:08,960 --> 00:57:09,839
so

1452
00:57:09,839 --> 00:57:11,440
um

1453
00:57:11,440 --> 00:57:13,280
great so just to put their results in

1454
00:57:13,280 --> 00:57:15,200
context again next to the other

1455
00:57:15,200 --> 00:57:18,160
other results um so

1456
00:57:18,160 --> 00:57:18,880
the

1457
00:57:18,880 --> 00:57:20,000
like the best thing we'd hoped for would

1458
00:57:20,000 --> 00:57:22,559
for this for this polylog to go away and

1459
00:57:22,559 --> 00:57:23,680
just have

1460
00:57:23,680 --> 00:57:27,280
of s plus lambda we don't quite get that

1461
00:57:27,280 --> 00:57:29,599
all right the um so now i'm going to

1462
00:57:29,599 --> 00:57:31,599
talk a little bit about

1463
00:57:31,599 --> 00:57:34,480
uh like what the sort of main lemma is

1464
00:57:34,480 --> 00:57:35,920
in our work

1465
00:57:35,920 --> 00:57:37,200
and it's

1466
00:57:37,200 --> 00:57:39,119
not 100 technology but i think it

1467
00:57:39,119 --> 00:57:41,520
captures the

1468
00:57:41,520 --> 00:57:44,319
new contribution sort of so

1469
00:57:44,319 --> 00:57:45,119
we

1470
00:57:45,119 --> 00:57:47,920
can we show that there's a linear code

1471
00:57:47,920 --> 00:57:49,280
that we can

1472
00:57:49,280 --> 00:57:52,319
encode in uh with

1473
00:57:52,319 --> 00:57:53,760
overhead poly logarithmic in the

1474
00:57:53,760 --> 00:57:55,599
security parameter

1475
00:57:55,599 --> 00:57:58,720
and uh given encodings of three vectors

1476
00:57:58,720 --> 00:58:00,480
x y and z

1477
00:58:00,480 --> 00:58:02,880
you can prove that z is a pointwise

1478
00:58:02,880 --> 00:58:06,000
product of x and y with soundness or two

1479
00:58:06,000 --> 00:58:08,319
to the minus lambda

1480
00:58:08,319 --> 00:58:10,559
and sort of assume here that

1481
00:58:10,559 --> 00:58:13,760
that you're given these encoded vectors

1482
00:58:13,760 --> 00:58:15,359
in the sense that the verifier can make

1483
00:58:15,359 --> 00:58:17,359
whatever random access queries it wants

1484
00:58:17,359 --> 00:58:19,680
to them and it knows that these things

1485
00:58:19,680 --> 00:58:21,119
are properly encoded but it doesn't know

1486
00:58:21,119 --> 00:58:24,880
what the encoded values are

1487
00:58:25,359 --> 00:58:26,400
um

1488
00:58:26,400 --> 00:58:27,680
right so

1489
00:58:27,680 --> 00:58:29,680
that that is that is the

1490
00:58:29,680 --> 00:58:30,880
result

1491
00:58:30,880 --> 00:58:32,240
and now i wanted to sort of delve into

1492
00:58:32,240 --> 00:58:34,319
the techniques a little bit um it's a

1493
00:58:34,319 --> 00:58:36,720
little technical but uh

1494
00:58:36,720 --> 00:58:38,000
so

1495
00:58:38,000 --> 00:58:40,960
uh first i want to sort of say what the

1496
00:58:40,960 --> 00:58:42,480
prerequisites to this revolt are the

1497
00:58:42,480 --> 00:58:44,400
things that we build on let's start with

1498
00:58:44,400 --> 00:58:47,520
the simplest thing we use a small finite

1499
00:58:47,520 --> 00:58:49,839
field so finite field of order security

1500
00:58:49,839 --> 00:58:51,119
parameter

1501
00:58:51,119 --> 00:58:51,839
so

1502
00:58:51,839 --> 00:58:53,359
not the

1503
00:58:53,359 --> 00:58:56,319
exponential dependence

1504
00:58:56,319 --> 00:58:58,079
we build on some

1505
00:58:58,079 --> 00:59:00,319
good error correcting codes

1506
00:59:00,319 --> 00:59:02,000
so in particular

1507
00:59:02,000 --> 00:59:04,079
we'll use two types of codes the first

1508
00:59:04,079 --> 00:59:06,880
is a kind of a heavy hammer from

1509
00:59:06,880 --> 00:59:09,119
uh the previous work of ronzon rothblum

1510
00:59:09,119 --> 00:59:12,240
this past stock which um

1511
00:59:12,240 --> 00:59:14,160
has two salient properties the first is

1512
00:59:14,160 --> 00:59:15,680
that it's a

1513
00:59:15,680 --> 00:59:18,079
linear time encodable and it'll solve

1514
00:59:18,079 --> 00:59:19,680
this task that i wanted to solve this

1515
00:59:19,680 --> 00:59:21,760
pointwise how do i check with a constant

1516
00:59:21,760 --> 00:59:24,720
overhead and constant soundness error so

1517
00:59:24,720 --> 00:59:26,720
um this sort of is

1518
00:59:26,720 --> 00:59:29,200
illustrates that you could get

1519
00:59:29,200 --> 00:59:30,480
uh the

1520
00:59:30,480 --> 00:59:32,079
two to the minus slam the sound is there

1521
00:59:32,079 --> 00:59:33,359
by just repeating but that would kill

1522
00:59:33,359 --> 00:59:35,280
the the constant overhead so we don't

1523
00:59:35,280 --> 00:59:36,480
want to do that but we will still use

1524
00:59:36,480 --> 00:59:39,440
this as part of our solution

1525
00:59:39,440 --> 00:59:41,040
and the second

1526
00:59:41,040 --> 00:59:42,960
uh code which is probably much more

1527
00:59:42,960 --> 00:59:45,119
familiar is just good old read solomon

1528
00:59:45,119 --> 00:59:46,400
codes or

1529
00:59:46,400 --> 00:59:48,559
in more generally multiplication codes

1530
00:59:48,559 --> 00:59:50,319
um and read solomon codes have a nice

1531
00:59:50,319 --> 00:59:51,599
property that they're encodable in

1532
00:59:51,599 --> 00:59:53,359
quasi-linear time

1533
00:59:53,359 --> 00:59:55,359
and um

1534
00:59:55,359 --> 00:59:58,960
using fast fourier transforms

1535
00:59:58,960 --> 01:00:00,799
all right

1536
01:00:00,799 --> 01:00:02,000
so

1537
01:00:02,000 --> 01:00:04,079
this is the last really technical slide

1538
01:00:04,079 --> 01:00:05,920
and i want to talk about how we put

1539
01:00:05,920 --> 01:00:08,400
these ingredients together to get our uh

1540
01:00:08,400 --> 01:00:10,400
dilemma

1541
01:00:10,400 --> 01:00:11,440
so

1542
01:00:11,440 --> 01:00:12,319
um

1543
01:00:12,319 --> 01:00:15,520
the first step is to take these vectors

1544
01:00:15,520 --> 01:00:17,920
that we want to uh prove a pointwise

1545
01:00:17,920 --> 01:00:20,720
product constraint on and uh view them

1546
01:00:20,720 --> 01:00:22,400
as matrices

1547
01:00:22,400 --> 01:00:23,520
um

1548
01:00:23,520 --> 01:00:24,480
and

1549
01:00:24,480 --> 01:00:26,319
we'll our encoding will be sort of left

1550
01:00:26,319 --> 01:00:28,400
and right multiplication by uh these

1551
01:00:28,400 --> 01:00:30,640
different code generator matrices so

1552
01:00:30,640 --> 01:00:32,079
what that looks like

1553
01:00:32,079 --> 01:00:33,280
um

1554
01:00:33,280 --> 01:00:35,839
the the way we view our

1555
01:00:35,839 --> 01:00:38,880
our mess or x as a matrix is

1556
01:00:38,880 --> 01:00:40,559
um

1557
01:00:40,559 --> 01:00:42,720
despite what the the picture would have

1558
01:00:42,720 --> 01:00:44,720
you believe all the matrices here are

1559
01:00:44,720 --> 01:00:48,160
really tall and skinny so um there's

1560
01:00:48,160 --> 01:00:50,079
there's layout constraints so you if you

1561
01:00:50,079 --> 01:00:51,520
i've heard that the camera adds 10

1562
01:00:51,520 --> 01:00:53,599
pounds or something so uh

1563
01:00:53,599 --> 01:00:57,119
anyway so so the the width of x is

1564
01:00:57,119 --> 01:00:59,359
lambda the security parameter and

1565
01:00:59,359 --> 01:01:02,160
the height is um the original

1566
01:01:02,160 --> 01:01:04,960
size divided by that

1567
01:01:04,960 --> 01:01:08,880
and um so we encode all the rows of x

1568
01:01:08,880 --> 01:01:11,280
with a read solomon code that's let's

1569
01:01:11,280 --> 01:01:14,000
write multiplication by uh m and then we

1570
01:01:14,000 --> 01:01:16,559
take each column thereof and encode that

1571
01:01:16,559 --> 01:01:18,720
with the code from rr

1572
01:01:18,720 --> 01:01:20,640
22.

1573
01:01:20,640 --> 01:01:22,640
yeah

1574
01:01:22,640 --> 01:01:25,520
um so this is basically i mean another

1575
01:01:25,520 --> 01:01:26,480
way of saying this is this is a

1576
01:01:26,480 --> 01:01:28,319
two-dimensional tensor code

1577
01:01:28,319 --> 01:01:29,760
um

1578
01:01:29,760 --> 01:01:32,240
and anyway we sort of start with a

1579
01:01:32,240 --> 01:01:34,960
similar encoding of y and z

1580
01:01:34,960 --> 01:01:37,200
and now we want to get to work proving

1581
01:01:37,200 --> 01:01:40,559
that uh that z is

1582
01:01:40,559 --> 01:01:41,680
oh yeah there should be a little box

1583
01:01:41,680 --> 01:01:43,839
it's a z in the same position we're only

1584
01:01:43,839 --> 01:01:45,599
going to prove that z is the appointment

1585
01:01:45,599 --> 01:01:47,760
product of x and y

1586
01:01:47,760 --> 01:01:49,839
um

1587
01:01:49,839 --> 01:01:51,440
so the first thing that we'll have the

1588
01:01:51,440 --> 01:01:54,480
prover do is send a

1589
01:01:54,480 --> 01:01:55,680
matrix that's kind of like halfway

1590
01:01:55,680 --> 01:01:57,359
between uh

1591
01:01:57,359 --> 01:02:00,720
like almost what what uh z hat should be

1592
01:02:00,720 --> 01:02:03,359
uh so they take the top half and do the

1593
01:02:03,359 --> 01:02:04,640
pointwise products

1594
01:02:04,640 --> 01:02:08,160
of x hat and y hat and uh then do a

1595
01:02:08,160 --> 01:02:12,880
column wise encoding with this rr22 code

1596
01:02:12,880 --> 01:02:14,720
um

1597
01:02:14,720 --> 01:02:16,319
and

1598
01:02:16,319 --> 01:02:17,359
you can

1599
01:02:17,359 --> 01:02:18,799
kind of do some consistency checks here

1600
01:02:18,799 --> 01:02:20,799
i don't really want to get into the

1601
01:02:20,799 --> 01:02:22,400
details exactly but

1602
01:02:22,400 --> 01:02:23,280
um

1603
01:02:23,280 --> 01:02:25,760
there's there's

1604
01:02:26,319 --> 01:02:28,640
you first you like you sample a random

1605
01:02:28,640 --> 01:02:31,440
column and you

1606
01:02:31,680 --> 01:02:33,680
check that

1607
01:02:33,680 --> 01:02:35,680
basically you're able to check that

1608
01:02:35,680 --> 01:02:37,119
z tilde

1609
01:02:37,119 --> 01:02:39,119
encodes the point by product of the

1610
01:02:39,119 --> 01:02:41,119
corresponding message parts of x hat and

1611
01:02:41,119 --> 01:02:42,079
y hat

1612
01:02:42,079 --> 01:02:44,480
and um

1613
01:02:44,480 --> 01:02:46,000
the second thing you need to show is

1614
01:02:46,000 --> 01:02:47,760
that what's in z tilde is actually the

1615
01:02:47,760 --> 01:02:49,440
same as what's in z-hat so those are

1616
01:02:49,440 --> 01:02:51,359
under different codes so that's sort of

1617
01:02:51,359 --> 01:02:54,079
a code switching step

1618
01:02:54,079 --> 01:02:55,280
um

1619
01:02:55,280 --> 01:02:56,079
now

1620
01:02:56,079 --> 01:02:58,400
for each for this basic step you just

1621
01:02:58,400 --> 01:03:00,319
get a constant soundless error and i am

1622
01:03:00,319 --> 01:03:01,839
going to suggest that we repeat this

1623
01:03:01,839 --> 01:03:04,240
lambda times to get our to the minus

1624
01:03:04,240 --> 01:03:07,039
lambda sum of zero so why is this not an

1625
01:03:07,039 --> 01:03:09,119
issue like it was in um

1626
01:03:09,119 --> 01:03:11,119
all the previous works so the point is

1627
01:03:11,119 --> 01:03:12,960
that um

1628
01:03:12,960 --> 01:03:15,039
we've reduced to checking a smaller coin

1629
01:03:15,039 --> 01:03:16,400
before we had to check the point-wise

1630
01:03:16,400 --> 01:03:18,559
product of x which was this thing of

1631
01:03:18,559 --> 01:03:21,920
size n but now we're checking uh just

1632
01:03:21,920 --> 01:03:25,119
uh lambda columns which

1633
01:03:25,119 --> 01:03:28,319
like in total have size n so if each one

1634
01:03:28,319 --> 01:03:30,720
of those has a like has a constant

1635
01:03:30,720 --> 01:03:33,359
probability of detecting an error um

1636
01:03:33,359 --> 01:03:35,520
we'll get our two to the minus lambda

1637
01:03:35,520 --> 01:03:37,359
sum is there and our total running time

1638
01:03:37,359 --> 01:03:39,520
will still be o of n

1639
01:03:39,520 --> 01:03:41,680
and the um

1640
01:03:41,680 --> 01:03:43,119
checking the rows here since because

1641
01:03:43,119 --> 01:03:44,319
remember these are actually tall skinny

1642
01:03:44,319 --> 01:03:46,160
matrices checking the random rows is

1643
01:03:46,160 --> 01:03:47,599
really you don't need anything special

1644
01:03:47,599 --> 01:03:48,480
you could just do this directly it

1645
01:03:48,480 --> 01:03:50,480
doesn't cost anything

1646
01:03:50,480 --> 01:03:51,599
all right

1647
01:03:51,599 --> 01:03:52,480
well

1648
01:03:52,480 --> 01:03:54,640
i think i am done with that and uh i

1649
01:03:54,640 --> 01:03:56,319
will propose possible sequels to this

1650
01:03:56,319 --> 01:03:57,359
work

1651
01:03:57,359 --> 01:04:00,160
um so one is as i mentioned earlier in

1652
01:04:00,160 --> 01:04:02,960
the talk to just improve the prover size

1653
01:04:02,960 --> 01:04:04,880
further okay sort of the

1654
01:04:04,880 --> 01:04:06,720
this sort of the best that we can

1655
01:04:06,720 --> 01:04:08,319
imagine now

1656
01:04:08,319 --> 01:04:10,559
um

1657
01:04:10,559 --> 01:04:12,960
one way to do this would be so

1658
01:04:12,960 --> 01:04:15,119
you could you can imagine uh something

1659
01:04:15,119 --> 01:04:16,960
like a read solomon code where the

1660
01:04:16,960 --> 01:04:18,640
encoding is not quasi linear and it's

1661
01:04:18,640 --> 01:04:20,960
just uh linear size if you could do that

1662
01:04:20,960 --> 01:04:22,400
you'd be done you'd get this result and

1663
01:04:22,400 --> 01:04:23,920
i'd be very happy

1664
01:04:23,920 --> 01:04:26,240
but this is an open question in coding

1665
01:04:26,240 --> 01:04:27,440
theory um

1666
01:04:27,440 --> 01:04:29,119
i don't know if it's gotten so much

1667
01:04:29,119 --> 01:04:30,480
attention that you should expect this to

1668
01:04:30,480 --> 01:04:32,960
be an impossible problem to solve but it

1669
01:04:32,960 --> 01:04:35,359
does seem challenging to me

1670
01:04:35,359 --> 01:04:37,839
another uh interesting open question is

1671
01:04:37,839 --> 01:04:39,119
to

1672
01:04:39,119 --> 01:04:41,280
make this whole scheme non-interactive

1673
01:04:41,280 --> 01:04:43,920
or to get any scheme that has a similar

1674
01:04:43,920 --> 01:04:45,200
poly logarithmic security parameter

1675
01:04:45,200 --> 01:04:47,440
overhead uh from a standard assumption

1676
01:04:47,440 --> 01:04:50,160
so right now you can take the scheme and

1677
01:04:50,160 --> 01:04:52,319
if you have shamir plug it with it and

1678
01:04:52,319 --> 01:04:53,680
prove that it's secure in the random

1679
01:04:53,680 --> 01:04:56,559
oracle model i think but um maybe if you

1680
01:04:56,559 --> 01:04:57,599
if you don't like the random oracle

1681
01:04:57,599 --> 01:04:59,200
model you might be interested in doing

1682
01:04:59,200 --> 01:05:01,920
it from a false level

1683
01:05:01,920 --> 01:05:04,000
um finally there is this whole issue of

1684
01:05:04,000 --> 01:05:06,640
the like the nice circuits um

1685
01:05:06,640 --> 01:05:08,559
one could definitely hope to

1686
01:05:08,559 --> 01:05:10,480
uh handle arbitrary boolean circuits

1687
01:05:10,480 --> 01:05:12,319
especially if the verifier is doing some

1688
01:05:12,319 --> 01:05:14,400
pre-processing

1689
01:05:14,400 --> 01:05:16,319
uh and that's the last open question for

1690
01:05:16,319 --> 01:05:17,440
now and

1691
01:05:17,440 --> 01:05:19,119
um

1692
01:05:19,119 --> 01:05:21,440
if you would like to look at

1693
01:05:21,440 --> 01:05:23,920
the nice version of the slides you can

1694
01:05:23,920 --> 01:05:25,200
scan this

1695
01:05:25,200 --> 01:05:27,599
qr code or the paper or you can find it

1696
01:05:27,599 --> 01:05:29,839
on eprint to the website

1697
01:05:29,839 --> 01:05:31,680
all right thanks and it looks like maybe

1698
01:05:31,680 --> 01:05:33,119
there's some questions in the chat or

1699
01:05:33,119 --> 01:05:36,480
maybe complaints about oh okay

1700
01:05:36,480 --> 01:05:37,359
no

1701
01:05:37,359 --> 01:05:39,520
no questions i guess

1702
01:05:39,520 --> 01:05:43,480
any questions in the audience

1703
01:05:55,200 --> 01:05:56,000
oh

1704
01:05:56,000 --> 01:05:59,280
you have a question you have a question

1705
01:05:59,280 --> 01:06:01,200
you have a question hey thanks uh thanks

1706
01:06:01,200 --> 01:06:03,359
that was that was a great talk um

1707
01:06:03,359 --> 01:06:05,440
the question is like can you say some

1708
01:06:05,440 --> 01:06:08,880
more about the way that the uh size of d

1709
01:06:08,880 --> 01:06:11,440
that circuit that was and

1710
01:06:11,440 --> 01:06:13,839
you know sort of the the the thing that

1711
01:06:13,839 --> 01:06:15,599
you use to define the structure how does

1712
01:06:15,599 --> 01:06:16,799
this

1713
01:06:16,799 --> 01:06:18,799
how does this reflect

1714
01:06:18,799 --> 01:06:20,240
uh to the

1715
01:06:20,240 --> 01:06:22,640
final complexity of the proof

1716
01:06:22,640 --> 01:06:24,880
well complexity approved so

1717
01:06:24,880 --> 01:06:26,880
um

1718
01:06:26,880 --> 01:06:29,280
so if we start with uh approved systems

1719
01:06:29,280 --> 01:06:31,599
the verifier look at the only only like

1720
01:06:31,599 --> 01:06:33,440
annoying overhead if the verifier runs

1721
01:06:33,440 --> 01:06:36,079
in time proportion of the d you could

1722
01:06:36,079 --> 01:06:38,640
imagine instead of having the verifier

1723
01:06:38,640 --> 01:06:41,200
actually run it the approver convinces

1724
01:06:41,200 --> 01:06:43,680
the verifier that it would have accepted

1725
01:06:43,680 --> 01:06:47,599
so the provers complexity then is deep

1726
01:06:47,599 --> 01:06:49,680
times some small factor but if d is

1727
01:06:49,680 --> 01:06:51,039
smaller than the whole circuit then

1728
01:06:51,039 --> 01:06:55,920
that's negligible right okay thanks

1729
01:06:57,839 --> 01:07:01,039
any more questions

1730
01:07:01,039 --> 01:07:04,599
thank you very much

1731
01:09:20,399 --> 01:09:22,960
can you hear me yes you can

1732
01:09:22,960 --> 01:09:24,000
um

1733
01:09:24,000 --> 01:09:26,799
i'm supposed to waste one more minute

1734
01:09:26,799 --> 01:09:29,679
uh but i don't have any jokes already so

1735
01:09:29,679 --> 01:09:31,359
no

1736
01:09:31,359 --> 01:09:33,679
yeah so the stock is scheduled to begin

1737
01:09:33,679 --> 01:09:35,198
at 305

1738
01:09:35,198 --> 01:09:37,600
and we uh you know we're going to be

1739
01:09:37,600 --> 01:09:39,600
back on schedule

1740
01:09:39,600 --> 01:09:41,439
because i don't want people to miss it

1741
01:09:41,439 --> 01:09:45,158
because we start early

1742
01:10:02,880 --> 01:10:04,640
i believe it is the session chair's

1743
01:10:04,640 --> 01:10:06,480
responsibility to tell the jokes to pass

1744
01:10:06,480 --> 01:10:08,879
the time

1745
01:10:10,320 --> 01:10:13,199
okay so here's a joke um i lost my voice

1746
01:10:13,199 --> 01:10:17,839
i have laryngitis so i cannot tell jokes

1747
01:10:18,960 --> 01:10:22,320
i i accept your excuse

1748
01:10:22,719 --> 01:10:25,040
okay it's three or five now

1749
01:10:25,040 --> 01:10:26,719
so the next paper is succinct

1750
01:10:26,719 --> 01:10:28,800
interactive oracle proofs applications

1751
01:10:28,800 --> 01:10:31,280
and limitations by shafiq nassar and ron

1752
01:10:31,280 --> 01:10:33,600
rothblum and shafiq will give the talk

1753
01:10:33,600 --> 01:10:35,679
thank you for the introduction and i'd

1754
01:10:35,679 --> 01:10:37,600
like to thank the previous speakers for

1755
01:10:37,600 --> 01:10:39,679
warming you guys up and defining things

1756
01:10:39,679 --> 01:10:41,120
that i don't have to define things

1757
01:10:41,120 --> 01:10:43,040
anymore

1758
01:10:43,040 --> 01:10:44,480
so this talk is about success

1759
01:10:44,480 --> 01:10:46,800
interactive oracle proofs uh so let's

1760
01:10:46,800 --> 01:10:48,560
start by breaking down the title

1761
01:10:48,560 --> 01:10:50,800
understanding what we're talking about

1762
01:10:50,800 --> 01:10:53,199
so uh of course the first click never

1763
01:10:53,199 --> 01:10:55,519
works

1764
01:10:56,400 --> 01:10:57,280
yeah

1765
01:10:57,280 --> 01:11:00,560
so interactive oracle proofs or iops uh

1766
01:11:00,560 --> 01:11:01,679
they're this

1767
01:11:01,679 --> 01:11:04,320
relatively new type of proof system that

1768
01:11:04,320 --> 01:11:06,719
generalizes both traditional interactive

1769
01:11:06,719 --> 01:11:08,960
proofs and probabilistically checkable

1770
01:11:08,960 --> 01:11:11,600
proofs so how do they work we can think

1771
01:11:11,600 --> 01:11:14,400
of them as an interactive proof

1772
01:11:14,400 --> 01:11:16,320
where the verifier only has oracle

1773
01:11:16,320 --> 01:11:18,400
access to the prover messages as opposed

1774
01:11:18,400 --> 01:11:20,800
to the full access that it would get in

1775
01:11:20,800 --> 01:11:22,719
a traditional interactive proof

1776
01:11:22,719 --> 01:11:24,400
or alternatively we can think of it as

1777
01:11:24,400 --> 01:11:27,280
an interactive analog of a pcp so a pcp

1778
01:11:27,280 --> 01:11:29,199
is basically like a round or half around

1779
01:11:29,199 --> 01:11:31,440
iop

1780
01:11:31,440 --> 01:11:34,960
and uh just to give an illustration

1781
01:11:34,960 --> 01:11:37,920
uh we'll be talking about public coin

1782
01:11:37,920 --> 01:11:39,840
interactive oracle proofs so basically

1783
01:11:39,840 --> 01:11:41,600
we have a verifier and approver the

1784
01:11:41,600 --> 01:11:43,840
verifier's messages only consist of

1785
01:11:43,840 --> 01:11:46,320
randomness that it sends publicly to the

1786
01:11:46,320 --> 01:11:49,199
approver and the approver responds with

1787
01:11:49,199 --> 01:11:51,280
those messages

1788
01:11:51,280 --> 01:11:53,520
and this is the interaction phase after

1789
01:11:53,520 --> 01:11:55,280
the interaction phase is done

1790
01:11:55,280 --> 01:11:57,520
uh based on the randomness of the

1791
01:11:57,520 --> 01:11:59,760
verifier the verifier chooses a small

1792
01:11:59,760 --> 01:12:01,520
number of queries

1793
01:12:01,520 --> 01:12:03,600
from the messages that the prover sent

1794
01:12:03,600 --> 01:12:05,120
makes those queries and decides

1795
01:12:05,120 --> 01:12:06,320
accordingly

1796
01:12:06,320 --> 01:12:08,560
so uh we all we have the usual

1797
01:12:08,560 --> 01:12:09,840
requirements of completeness and

1798
01:12:09,840 --> 01:12:11,120
soundness

1799
01:12:11,120 --> 01:12:14,320
and just to establish some notation uh

1800
01:12:14,320 --> 01:12:15,840
when i say communication complexity

1801
01:12:15,840 --> 01:12:17,360
denoted by cc

1802
01:12:17,360 --> 01:12:19,520
uh i'm referring to the total length of

1803
01:12:19,520 --> 01:12:22,080
the proven messages so i'm not counting

1804
01:12:22,080 --> 01:12:24,960
the verifier messages those are counted

1805
01:12:24,960 --> 01:12:27,120
towards the randomness complexity which

1806
01:12:27,120 --> 01:12:28,960
we denote by rc

1807
01:12:28,960 --> 01:12:31,199
and finally the query complexity is the

1808
01:12:31,199 --> 01:12:33,760
number of queries that the fire makes at

1809
01:12:33,760 --> 01:12:36,320
the end

1810
01:12:36,320 --> 01:12:39,600
okay uh so this is an iot

1811
01:12:39,600 --> 01:12:41,120
um

1812
01:12:41,120 --> 01:12:42,719
what are iops good

1813
01:12:42,719 --> 01:12:44,400
what are iops good for uh that's a

1814
01:12:44,400 --> 01:12:47,120
legitimate question and iops have many

1815
01:12:47,120 --> 01:12:49,920
applications so uh from constructing

1816
01:12:49,920 --> 01:12:51,840
succinct arguments to delegation of

1817
01:12:51,840 --> 01:12:53,440
computation even more recently they've

1818
01:12:53,440 --> 01:12:54,880
been used to achieve hardness of

1819
01:12:54,880 --> 01:12:58,080
approximation results so iops are

1820
01:12:58,080 --> 01:13:00,560
very useful they have many applications

1821
01:13:00,560 --> 01:13:01,760
but uh

1822
01:13:01,760 --> 01:13:03,840
before we talk about applications let's

1823
01:13:03,840 --> 01:13:07,360
uh ask an actual question about iops

1824
01:13:07,360 --> 01:13:09,280
so even about pcps when we're talking

1825
01:13:09,280 --> 01:13:11,520
about iop or pcp they basically provide

1826
01:13:11,520 --> 01:13:14,080
a mechanism that allows us to encode a

1827
01:13:14,080 --> 01:13:16,400
witness or computation in a way that

1828
01:13:16,400 --> 01:13:18,480
allows the verifier to

1829
01:13:18,480 --> 01:13:20,080
check or verify

1830
01:13:20,080 --> 01:13:22,400
the correctness of the statement by just

1831
01:13:22,400 --> 01:13:24,960
looking at small number of locations in

1832
01:13:24,960 --> 01:13:26,560
the encoding

1833
01:13:26,560 --> 01:13:27,360
and

1834
01:13:27,360 --> 01:13:29,280
it's a very actual question to ask how

1835
01:13:29,280 --> 01:13:31,440
short can this encoding be

1836
01:13:31,440 --> 01:13:33,040
so if we go back to the original proof

1837
01:13:33,040 --> 01:13:35,199
of the pcp theorem

1838
01:13:35,199 --> 01:13:37,600
there the length of the pcp proof was

1839
01:13:37,600 --> 01:13:39,199
polynomial in t where t is the

1840
01:13:39,199 --> 01:13:40,960
verification time

1841
01:13:40,960 --> 01:13:41,760
and

1842
01:13:41,760 --> 01:13:43,280
many improvements have

1843
01:13:43,280 --> 01:13:44,239
occurred

1844
01:13:44,239 --> 01:13:48,000
since and now we have pcp proofs uh with

1845
01:13:48,000 --> 01:13:51,280
uh it was the quasi-linear

1846
01:13:51,280 --> 01:13:53,040
it was a linear length

1847
01:13:53,040 --> 01:13:54,960
but uh an interesting question here is

1848
01:13:54,960 --> 01:13:56,960
can we get close to the original witness

1849
01:13:56,960 --> 01:13:58,960
that is can the encoding only depend on

1850
01:13:58,960 --> 01:14:00,960
the original witness rather than depend

1851
01:14:00,960 --> 01:14:02,400
on the computation or the verification

1852
01:14:02,400 --> 01:14:04,640
time that we have to do afterwards

1853
01:14:04,640 --> 01:14:06,960
and uh this brings me to the first word

1854
01:14:06,960 --> 01:14:08,960
in the title which is succinct

1855
01:14:08,960 --> 01:14:11,280
so uh a succinct proof basically means a

1856
01:14:11,280 --> 01:14:13,199
short proof namely when we're talking

1857
01:14:13,199 --> 01:14:15,600
about uh np relations

1858
01:14:15,600 --> 01:14:17,840
uh a succinct proof is a proof whose

1859
01:14:17,840 --> 01:14:20,000
length is polynomial in the witness

1860
01:14:20,000 --> 01:14:21,760
rather than the instance

1861
01:14:21,760 --> 01:14:24,320
and why is this good because for typical

1862
01:14:24,320 --> 01:14:26,080
np relations we think of the instance as

1863
01:14:26,080 --> 01:14:28,320
being much larger than the witness so if

1864
01:14:28,320 --> 01:14:29,920
you have a succinct proof then basically

1865
01:14:29,920 --> 01:14:32,239
we have a shorter proof that's good we

1866
01:14:32,239 --> 01:14:35,040
like short stuff we like efficient stuff

1867
01:14:35,040 --> 01:14:38,080
um and again we might ask if there

1868
01:14:38,080 --> 01:14:41,199
exists succinct pcps for all languages

1869
01:14:41,199 --> 01:14:42,560
in np for example

1870
01:14:42,560 --> 01:14:44,159
and unfortunately we know a negative

1871
01:14:44,159 --> 01:14:46,320
result by a fortnight and sentinel they

1872
01:14:46,320 --> 01:14:48,400
showed that under a standard complexity

1873
01:14:48,400 --> 01:14:50,719
assumption there is no succinct pcp for

1874
01:14:50,719 --> 01:14:52,480
sat

1875
01:14:52,480 --> 01:14:53,760
on the other hand

1876
01:14:53,760 --> 01:14:56,400
we know that there's a succinct iop for

1877
01:14:56,400 --> 01:14:57,679
sat in fact we know a couple of

1878
01:14:57,679 --> 01:15:00,000
constructions so first of all let's take

1879
01:15:00,000 --> 01:15:01,840
a minute here to appreciate that

1880
01:15:01,840 --> 01:15:03,199
basically this shows a separation

1881
01:15:03,199 --> 01:15:05,840
between pcps and iops and iop can do

1882
01:15:05,840 --> 01:15:09,360
something that we believe a pcp cannot

1883
01:15:09,360 --> 01:15:11,920
um now let's ask another question we

1884
01:15:11,920 --> 01:15:14,080
have a succinct iop for sat does this

1885
01:15:14,080 --> 01:15:16,080
imply a succinct iop for all np

1886
01:15:16,080 --> 01:15:18,640
relations after all sat is an np

1887
01:15:18,640 --> 01:15:20,880
complete problem so we can reduce any

1888
01:15:20,880 --> 01:15:23,040
other problem to it but

1889
01:15:23,040 --> 01:15:25,920
unfortunately no because reductions do

1890
01:15:25,920 --> 01:15:27,440
not necessarily preserve the witness

1891
01:15:27,440 --> 01:15:29,600
link so even if we do the reduction to

1892
01:15:29,600 --> 01:15:31,040
stats we're losing all succinctness

1893
01:15:31,040 --> 01:15:32,560
because the new witness can depend on

1894
01:15:32,560 --> 01:15:34,159
the original instance instead of just on

1895
01:15:34,159 --> 01:15:35,760
the original witness

1896
01:15:35,760 --> 01:15:37,600
so this leaves the question wide open is

1897
01:15:37,600 --> 01:15:39,920
there a succinct iop for all np

1898
01:15:39,920 --> 01:15:42,400
relations

1899
01:15:43,120 --> 01:15:44,080
now

1900
01:15:44,080 --> 01:15:46,000
the previous slide is supposed to

1901
01:15:46,000 --> 01:15:48,239
motivate the study of succinct iops

1902
01:15:48,239 --> 01:15:49,600
because you know it's an actual question

1903
01:15:49,600 --> 01:15:50,800
it's interesting from a theoretical

1904
01:15:50,800 --> 01:15:52,159
perspective but some people might ask

1905
01:15:52,159 --> 01:15:53,600
about applications

1906
01:15:53,600 --> 01:15:55,440
and like if we look at one of the main

1907
01:15:55,440 --> 01:15:57,679
implications of iops which is

1908
01:15:57,679 --> 01:16:00,239
constructing succinct arguments uh there

1909
01:16:00,239 --> 01:16:02,080
we know that communication complexity is

1910
01:16:02,080 --> 01:16:03,920
not actually the bottleneck because

1911
01:16:03,920 --> 01:16:06,400
we're applying this kilian style miracle

1912
01:16:06,400 --> 01:16:07,679
hashing and

1913
01:16:07,679 --> 01:16:09,520
we eventually compress the communication

1914
01:16:09,520 --> 01:16:11,920
and doesn't really uh do that much

1915
01:16:11,920 --> 01:16:14,480
overhead so even if we improve

1916
01:16:14,480 --> 01:16:16,719
uh the communication complexity and get

1917
01:16:16,719 --> 01:16:18,800
a succinct iop we won't significantly

1918
01:16:18,800 --> 01:16:21,280
improve the succinct arguments so what

1919
01:16:21,280 --> 01:16:23,920
are succinct iops good for so uh this

1920
01:16:23,920 --> 01:16:25,679
brings me back to the title and i'm

1921
01:16:25,679 --> 01:16:27,920
going to show an application

1922
01:16:27,920 --> 01:16:29,840
so this is our first result basically

1923
01:16:29,840 --> 01:16:32,640
showing an application for succinct ieps

1924
01:16:32,640 --> 01:16:35,280
we present a compiler that takes a

1925
01:16:35,280 --> 01:16:38,400
succinct iop and uh transforms it to a

1926
01:16:38,400 --> 01:16:40,400
succinct zero knowledge proof and i have

1927
01:16:40,400 --> 01:16:41,520
to emphasize here that we're talking

1928
01:16:41,520 --> 01:16:43,920
about a proof not an argument so we have

1929
01:16:43,920 --> 01:16:45,360
statistical standards which means that

1930
01:16:45,360 --> 01:16:46,800
soundness holds even against an

1931
01:16:46,800 --> 01:16:49,679
unbounded cheat improver and this is as

1932
01:16:49,679 --> 01:16:52,239
opposed to arguments which is the focus

1933
01:16:52,239 --> 01:16:53,280
of the

1934
01:16:53,280 --> 01:16:56,880
previous work on on iops

1935
01:16:56,880 --> 01:16:59,360
and this compiler only needs the

1936
01:16:59,360 --> 01:17:00,880
assumption or minimal assumption of

1937
01:17:00,880 --> 01:17:02,800
one-way functions so give me a one-way

1938
01:17:02,800 --> 01:17:04,320
function that will give you this

1939
01:17:04,320 --> 01:17:05,760
compiler there's no need to bring in the

1940
01:17:05,760 --> 01:17:07,520
big guns here or any other more

1941
01:17:07,520 --> 01:17:10,480
sophisticated uh uh

1942
01:17:10,480 --> 01:17:12,320
cryptographic assumptions

1943
01:17:12,320 --> 01:17:15,280
so uh this is our first result and you

1944
01:17:15,280 --> 01:17:16,960
know set zero knowledge through so i

1945
01:17:16,960 --> 01:17:18,719
have to just remind you guys what zero

1946
01:17:18,719 --> 01:17:20,400
knowledge proofs are so basically as

1947
01:17:20,400 --> 01:17:21,600
your knowledge proof is an interactive

1948
01:17:21,600 --> 01:17:23,280
proof where the verifier learns nothing

1949
01:17:23,280 --> 01:17:25,040
when interacting with the honest prover

1950
01:17:25,040 --> 01:17:27,280
other than the fact that the instance is

1951
01:17:27,280 --> 01:17:29,520
indeed in the language

1952
01:17:29,520 --> 01:17:31,360
and the state of the arts on succinct

1953
01:17:31,360 --> 01:17:32,640
neural knowledge proofs prior to this

1954
01:17:32,640 --> 01:17:34,719
work is the following assuming

1955
01:17:34,719 --> 01:17:36,000
full-fledged fully homomorphic

1956
01:17:36,000 --> 01:17:38,560
encryption so bringing in the big guns

1957
01:17:38,560 --> 01:17:40,239
we get something that is essentially

1958
01:17:40,239 --> 01:17:42,159
optimal we get a zero knowledge proof

1959
01:17:42,159 --> 01:17:44,159
for all np relations where the

1960
01:17:44,159 --> 01:17:46,800
communication complexity is

1961
01:17:46,800 --> 01:17:48,719
basically the width the length of the

1962
01:17:48,719 --> 01:17:51,520
witness plus some additive

1963
01:17:51,520 --> 01:17:52,880
factor that depends on the security

1964
01:17:52,880 --> 01:17:55,360
parameter lambda

1965
01:17:55,360 --> 01:17:57,040
on the other hand if we're assuming

1966
01:17:57,040 --> 01:17:59,040
one-way functions then we get a

1967
01:17:59,040 --> 01:18:01,280
zero-knowledge proof for

1968
01:18:01,280 --> 01:18:03,840
a sub-class of np relations it can be

1969
01:18:03,840 --> 01:18:06,320
verified in bounded depth and here the

1970
01:18:06,320 --> 01:18:09,360
communication complexity is the proof is

1971
01:18:09,360 --> 01:18:10,719
the witness length

1972
01:18:10,719 --> 01:18:12,640
with a multiplicative factor that

1973
01:18:12,640 --> 01:18:15,280
depends on the uh on the security

1974
01:18:15,280 --> 01:18:16,960
parameter and logarithmically on the

1975
01:18:16,960 --> 01:18:18,880
instance

1976
01:18:18,880 --> 01:18:20,080
um

1977
01:18:20,080 --> 01:18:22,080
so we have this gap here what we have

1978
01:18:22,080 --> 01:18:23,760
with foliomorphic encryption is

1979
01:18:23,760 --> 01:18:25,679
basically azure knowledge proof where

1980
01:18:25,679 --> 01:18:27,520
the communication approaches the witness

1981
01:18:27,520 --> 01:18:30,080
length and here we don't have that still

1982
01:18:30,080 --> 01:18:31,280
it's succinct

1983
01:18:31,280 --> 01:18:33,520
but it's uh it's multiplicative like we

1984
01:18:33,520 --> 01:18:36,480
have a multiplicative factor

1985
01:18:36,480 --> 01:18:38,719
if we take our compiler and we apply it

1986
01:18:38,719 --> 01:18:41,520
to the succinct uh the succinct iop of

1987
01:18:41,520 --> 01:18:44,080
front d and rotlum we get the shortest

1988
01:18:44,080 --> 01:18:46,000
known zero knowledge proofs for bounded

1989
01:18:46,000 --> 01:18:48,080
space np relations under the minimal

1990
01:18:48,080 --> 01:18:50,080
assumption of one-way functions

1991
01:18:50,080 --> 01:18:51,920
so basically what we get is a

1992
01:18:51,920 --> 01:18:53,360
zero-knowledge proof where the

1993
01:18:53,360 --> 01:18:55,520
communication complexity is this thing

1994
01:18:55,520 --> 01:18:58,640
over here which is

1995
01:18:58,640 --> 01:18:59,840
something that approaches the witness

1996
01:18:59,840 --> 01:19:01,040
length

1997
01:19:01,040 --> 01:19:03,760
plus this additive factor that depends

1998
01:19:03,760 --> 01:19:06,080
polynomially on the uh

1999
01:19:06,080 --> 01:19:08,800
on the security parameter and the power

2000
01:19:08,800 --> 01:19:11,199
of the instance but the thing is this

2001
01:19:11,199 --> 01:19:13,280
power can be arbitrarily small so any

2002
01:19:13,280 --> 01:19:15,600
small constant here can be plugged in

2003
01:19:15,600 --> 01:19:18,000
and uh we get uh like

2004
01:19:18,000 --> 01:19:19,600
uh the length of the instance to the

2005
01:19:19,600 --> 01:19:21,760
power of that small constant

2006
01:19:21,760 --> 01:19:24,080
so in a way this is approaching the

2007
01:19:24,080 --> 01:19:25,520
witness length

2008
01:19:25,520 --> 01:19:27,600
uh so this is how our result compares to

2009
01:19:27,600 --> 01:19:29,199
the previous stuff so assuming one of

2010
01:19:29,199 --> 01:19:31,040
the functions we get zero knowledge

2011
01:19:31,040 --> 01:19:33,840
proofs for again about uh

2012
01:19:33,840 --> 01:19:36,560
a subclass of np relations that can be

2013
01:19:36,560 --> 01:19:38,800
verified in small space but we have at

2014
01:19:38,800 --> 01:19:40,719
least something that is approaching the

2015
01:19:40,719 --> 01:19:43,360
witness length

2016
01:19:44,400 --> 01:19:46,400
so hopefully by now i've convinced you

2017
01:19:46,400 --> 01:19:48,880
that succinct iops are cool they're nice

2018
01:19:48,880 --> 01:19:50,880
they're useful we can use them to do

2019
01:19:50,880 --> 01:19:52,000
stuff

2020
01:19:52,000 --> 01:19:53,360
and uh

2021
01:19:53,360 --> 01:19:55,120
it's interesting if we can go now beyond

2022
01:19:55,120 --> 01:19:57,679
bounded space so we know that there is a

2023
01:19:57,679 --> 01:20:00,560
succinct iop for sats for example

2024
01:20:00,560 --> 01:20:03,679
uh or a succinct iop for relations that

2025
01:20:03,679 --> 01:20:07,120
can be verified in in bounded space

2026
01:20:07,120 --> 01:20:09,520
and this implies uh succinct zero

2027
01:20:09,520 --> 01:20:10,960
knowledge proofs and we'd like to get a

2028
01:20:10,960 --> 01:20:13,760
160 knowledge proof for all of np

2029
01:20:13,760 --> 01:20:15,679
uh under the assumption of one-way

2030
01:20:15,679 --> 01:20:16,719
functions

2031
01:20:16,719 --> 01:20:18,560
so this brings us back to the question

2032
01:20:18,560 --> 01:20:22,719
is there a succinct iop for all of np

2033
01:20:22,960 --> 01:20:25,520
and uh

2034
01:20:25,520 --> 01:20:27,120
when we wanted to approach such a

2035
01:20:27,120 --> 01:20:28,719
problem it's good to look at the

2036
01:20:28,719 --> 01:20:30,639
previous results or previous techniques

2037
01:20:30,639 --> 01:20:32,239
and try to apply them here because an

2038
01:20:32,239 --> 01:20:34,480
iop is a generalization of both

2039
01:20:34,480 --> 01:20:36,639
interactive proofs and pcps so maybe we

2040
01:20:36,639 --> 01:20:38,320
can use the limitations or the

2041
01:20:38,320 --> 01:20:40,239
techniques that are applied to those

2042
01:20:40,239 --> 01:20:42,239
things on iops

2043
01:20:42,239 --> 01:20:45,520
and for ips for interactive proofs this

2044
01:20:45,520 --> 01:20:46,800
basically doesn't work because there's

2045
01:20:46,800 --> 01:20:48,400
no such limitation we have a trivial

2046
01:20:48,400 --> 01:20:50,080
succinct interactive proof for all np

2047
01:20:50,080 --> 01:20:51,600
relations we can simply just send the

2048
01:20:51,600 --> 01:20:52,639
witness

2049
01:20:52,639 --> 01:20:54,960
so there's no such limitation

2050
01:20:54,960 --> 01:20:57,440
um if we try to take the fort now

2051
01:20:57,440 --> 01:20:58,800
sentence technique that i talked about

2052
01:20:58,800 --> 01:20:59,760
earlier

2053
01:20:59,760 --> 01:21:02,400
then it also wouldn't work here because

2054
01:21:02,400 --> 01:21:05,280
it rules out succinct pcps for stats but

2055
01:21:05,280 --> 01:21:07,360
we do have a succinct iop for set so at

2056
01:21:07,360 --> 01:21:08,560
least if we want to use that same

2057
01:21:08,560 --> 01:21:10,239
technique as a black box it won't work

2058
01:21:10,239 --> 01:21:11,199
here

2059
01:21:11,199 --> 01:21:15,040
so we need to do something else um

2060
01:21:15,040 --> 01:21:17,199
so this brings me to the second result

2061
01:21:17,199 --> 01:21:18,880
that we have and this is like just the

2062
01:21:18,880 --> 01:21:21,120
short version um

2063
01:21:21,120 --> 01:21:23,920
under a new but reasonable complexity

2064
01:21:23,920 --> 01:21:25,199
conjecture at least i think it's

2065
01:21:25,199 --> 01:21:26,239
reasonable

2066
01:21:26,239 --> 01:21:28,239
uh we prove that there is no succinct

2067
01:21:28,239 --> 01:21:31,840
iop for all of np so there is some

2068
01:21:31,840 --> 01:21:33,920
relation that has no succinct iop under

2069
01:21:33,920 --> 01:21:35,679
this new uh

2070
01:21:35,679 --> 01:21:37,360
complexity conjecture that i'm going to

2071
01:21:37,360 --> 01:21:40,000
talk about in a bit

2072
01:21:40,000 --> 01:21:42,159
uh the main ingredient in proving this

2073
01:21:42,159 --> 01:21:45,360
is again presenting a compiler for iops

2074
01:21:45,360 --> 01:21:47,760
so this compiler takes a succinct iop

2075
01:21:47,760 --> 01:21:49,840
and produces a special sort of algorithm

2076
01:21:49,840 --> 01:21:52,000
that i call uh that we call a small

2077
01:21:52,000 --> 01:21:54,480
space algorithm with uh pre-processing

2078
01:21:54,480 --> 01:21:56,000
so it's basically a pair of algorithms

2079
01:21:56,000 --> 01:21:58,560
a1 and a2 i'll just take a moment to

2080
01:21:58,560 --> 01:22:00,159
explain what that is

2081
01:22:00,159 --> 01:22:03,360
so we say that a language l

2082
01:22:03,360 --> 01:22:06,159
can be decided in s space with t time

2083
01:22:06,159 --> 01:22:08,159
probabilistic pre-processing there

2084
01:22:08,159 --> 01:22:10,800
exists two algorithms a1 the one the

2085
01:22:10,800 --> 01:22:12,320
pre-processing that runs in that time

2086
01:22:12,320 --> 01:22:14,639
and a2 the small space algorithm it can

2087
01:22:14,639 --> 01:22:16,239
decide the language and how does it work

2088
01:22:16,239 --> 01:22:18,320
exactly so we take our input we feed it

2089
01:22:18,320 --> 01:22:20,080
to the pre

2090
01:22:20,080 --> 01:22:21,679
we feed it to the pre-processing

2091
01:22:21,679 --> 01:22:23,520
algorithm

2092
01:22:23,520 --> 01:22:26,560
this gives us an intermediate uh

2093
01:22:26,560 --> 01:22:28,400
instance that we feed to the small space

2094
01:22:28,400 --> 01:22:29,760
algorithm and then the small space

2095
01:22:29,760 --> 01:22:30,800
algorithm

2096
01:22:30,800 --> 01:22:34,159
either accepts or rejects

2097
01:22:34,159 --> 01:22:36,159
so again if we go back to our compiler

2098
01:22:36,159 --> 01:22:39,360
we take a succinct iop and uh we produce

2099
01:22:39,360 --> 01:22:41,120
this sort of algorithm that decides the

2100
01:22:41,120 --> 01:22:43,360
same language that the uh succinct iop

2101
01:22:43,360 --> 01:22:45,520
decides

2102
01:22:45,520 --> 01:22:47,040
and of course we have the regular

2103
01:22:47,040 --> 01:22:48,639
requirements of completeness and

2104
01:22:48,639 --> 01:22:49,840
soundness

2105
01:22:49,840 --> 01:22:51,920
and just to put parameters on this thing

2106
01:22:51,920 --> 01:22:53,920
um so our compiler works as follows if

2107
01:22:53,920 --> 01:22:55,440
you give me an iop that has

2108
01:22:55,440 --> 01:22:56,960
communication cc communication

2109
01:22:56,960 --> 01:22:59,120
complexity cc number of rounds is k

2110
01:22:59,120 --> 01:23:01,120
query complexity is qc

2111
01:23:01,120 --> 01:23:03,040
then the space of the algorithm is

2112
01:23:03,040 --> 01:23:04,159
basically proportionate to the

2113
01:23:04,159 --> 01:23:07,760
communication it's just cc plus k times

2114
01:23:07,760 --> 01:23:09,360
log cc

2115
01:23:09,360 --> 01:23:11,120
and the preprocessing

2116
01:23:11,120 --> 01:23:12,719
depends exponentially on the query

2117
01:23:12,719 --> 01:23:14,639
complexity but that's okay because it's

2118
01:23:14,639 --> 01:23:16,239
an iop and we typically think of the

2119
01:23:16,239 --> 01:23:18,960
query complexity as being very small

2120
01:23:18,960 --> 01:23:21,920
uh polynomially on the on the instance

2121
01:23:21,920 --> 01:23:24,560
that's also okay and we have this thing

2122
01:23:24,560 --> 01:23:25,840
over here this is the most annoying

2123
01:23:25,840 --> 01:23:28,719
thing but it's here uh it's 2 to the k

2124
01:23:28,719 --> 01:23:31,040
log cc

2125
01:23:31,040 --> 01:23:33,040
so we're talking about succinct iops

2126
01:23:33,040 --> 01:23:34,719
let's just try to put some parameters in

2127
01:23:34,719 --> 01:23:36,560
here to try to understand how this thing

2128
01:23:36,560 --> 01:23:38,880
really works so if we have we'll talk

2129
01:23:38,880 --> 01:23:40,560
about succinct iops so the communication

2130
01:23:40,560 --> 01:23:42,320
is polynomial and the length of the

2131
01:23:42,320 --> 01:23:44,719
witness and let's assume that the number

2132
01:23:44,719 --> 01:23:47,520
of rounds is constant and the queries

2133
01:23:47,520 --> 01:23:49,280
are logarithmic

2134
01:23:49,280 --> 01:23:50,719
sorry about the colors by the way uh

2135
01:23:50,719 --> 01:23:53,199
they appeared better on my computer

2136
01:23:53,199 --> 01:23:55,280
so this is uh the rounds is constant and

2137
01:23:55,280 --> 01:23:57,120
the queries are uh

2138
01:23:57,120 --> 01:23:58,159
uh

2139
01:23:58,159 --> 01:24:01,440
logarithmic then we get uh

2140
01:24:01,440 --> 01:24:03,280
the an algorithm that decides l where

2141
01:24:03,280 --> 01:24:05,679
the space is polynomial in the witness

2142
01:24:05,679 --> 01:24:07,520
and the preprocessing time is polynomial

2143
01:24:07,520 --> 01:24:10,000
in the instance

2144
01:24:10,000 --> 01:24:11,360
okay

2145
01:24:11,360 --> 01:24:13,600
um and

2146
01:24:13,600 --> 01:24:15,360
let's think about this sort of algorithm

2147
01:24:15,360 --> 01:24:17,600
for a bit so

2148
01:24:17,600 --> 01:24:19,120
this is supposed to lead to the

2149
01:24:19,120 --> 01:24:20,880
complexity conjecture that we present in

2150
01:24:20,880 --> 01:24:22,080
this paper

2151
01:24:22,080 --> 01:24:24,000
so when i say succinct space it's like

2152
01:24:24,000 --> 01:24:25,920
succinct proof i'm talking about space

2153
01:24:25,920 --> 01:24:27,679
which is polynomial in the witness so it

2154
01:24:27,679 --> 01:24:29,040
only depends on the witness and maybe it

2155
01:24:29,040 --> 01:24:30,719
depends logarithmically on the instance

2156
01:24:30,719 --> 01:24:32,159
as well

2157
01:24:32,159 --> 01:24:34,960
and for example we know that sat can be

2158
01:24:34,960 --> 01:24:36,400
solved in succinct space so when i'm

2159
01:24:36,400 --> 01:24:38,080
talking about that i'm talking about uh

2160
01:24:38,080 --> 01:24:40,560
deciding whether a c and f formula is

2161
01:24:40,560 --> 01:24:43,040
satisfiable or not and this can be done

2162
01:24:43,040 --> 01:24:44,960
in succinct space

2163
01:24:44,960 --> 01:24:46,480
why because we simply need to iterate

2164
01:24:46,480 --> 01:24:48,320
over all of the assignments for each

2165
01:24:48,320 --> 01:24:50,239
such assignment we iterate over all of

2166
01:24:50,239 --> 01:24:52,000
the clauses and verify if they're

2167
01:24:52,000 --> 01:24:54,400
satisfiable or not if they're they're

2168
01:24:54,400 --> 01:24:56,480
satisfied by the assignment or not so

2169
01:24:56,480 --> 01:24:57,840
basically the space that we need here is

2170
01:24:57,840 --> 01:25:00,560
exactly the witness plus a plus log of

2171
01:25:00,560 --> 01:25:02,560
the uh

2172
01:25:02,560 --> 01:25:04,800
of the instance

2173
01:25:04,800 --> 01:25:06,719
on the other hand uh there's a

2174
01:25:06,719 --> 01:25:08,800
generalization of stats called circuit

2175
01:25:08,800 --> 01:25:11,199
sat uh which seems to require more than

2176
01:25:11,199 --> 01:25:13,760
that so just to clarify circuit stats is

2177
01:25:13,760 --> 01:25:15,280
the language of

2178
01:25:15,280 --> 01:25:18,159
uh boolean circuits that are satisfiable

2179
01:25:18,159 --> 01:25:20,320
so uh

2180
01:25:20,320 --> 01:25:22,239
a formula is like a bounded depth

2181
01:25:22,239 --> 01:25:23,440
circuit when we're talking about a

2182
01:25:23,440 --> 01:25:25,840
general circuit it can have

2183
01:25:25,840 --> 01:25:28,080
more depth

2184
01:25:28,080 --> 01:25:31,360
and circuit sat seems to require a space

2185
01:25:31,360 --> 01:25:32,960
which is proportionate to the size of

2186
01:25:32,960 --> 01:25:34,320
the circuit

2187
01:25:34,320 --> 01:25:36,719
not just the witness or the input of the

2188
01:25:36,719 --> 01:25:38,560
circuit or the assignment

2189
01:25:38,560 --> 01:25:39,760
in fact

2190
01:25:39,760 --> 01:25:42,719
just evaluating a circuit on a certain

2191
01:25:42,719 --> 01:25:45,760
input is believed to require space which

2192
01:25:45,760 --> 01:25:48,480
is proportionate to the circuit size

2193
01:25:48,480 --> 01:25:50,719
so now if we go back to the algorithm

2194
01:25:50,719 --> 01:25:52,960
that we got from the succinct iop it

2195
01:25:52,960 --> 01:25:55,280
gives us uh

2196
01:25:55,280 --> 01:25:56,800
probabilistic polynomial time

2197
01:25:56,800 --> 01:25:58,080
pre-processing

2198
01:25:58,080 --> 01:26:00,320
and small space succinct space basically

2199
01:26:00,320 --> 01:26:02,400
oops fixing space

2200
01:26:02,400 --> 01:26:03,360
and

2201
01:26:03,360 --> 01:26:05,600
the question is will this be enough if i

2202
01:26:05,600 --> 01:26:07,920
give you a probabilistic polynomial time

2203
01:26:07,920 --> 01:26:10,800
pre-processing will succinct space be

2204
01:26:10,800 --> 01:26:14,960
sufficient to decide the circuit stats

2205
01:26:14,960 --> 01:26:16,000
now

2206
01:26:16,000 --> 01:26:18,400
let's think about the two extremes

2207
01:26:18,400 --> 01:26:19,840
if we don't do anything in the

2208
01:26:19,840 --> 01:26:21,600
pre-processing and we just try to do all

2209
01:26:21,600 --> 01:26:23,360
of the computation in this succinct

2210
01:26:23,360 --> 01:26:26,000
space then we run into this problem or

2211
01:26:26,000 --> 01:26:27,199
this uh

2212
01:26:27,199 --> 01:26:29,760
conjecture over here

2213
01:26:29,760 --> 01:26:31,280
and on the other hand if we don't do

2214
01:26:31,280 --> 01:26:32,719
anything in small space and try to do

2215
01:26:32,719 --> 01:26:34,320
everything in ppt for in the

2216
01:26:34,320 --> 01:26:37,280
pre-processing uh phase then again

2217
01:26:37,280 --> 01:26:39,440
probably won't work right so i believe

2218
01:26:39,440 --> 01:26:40,560
that no one here believes that we can

2219
01:26:40,560 --> 01:26:43,120
solve an np-complete problem in ppt

2220
01:26:43,120 --> 01:26:45,199
um so the conjecture is just a

2221
01:26:45,199 --> 01:26:46,880
generalization of those two extremes it

2222
01:26:46,880 --> 01:26:48,560
says if i give you both can you do this

2223
01:26:48,560 --> 01:26:50,400
trade-off between time and space and get

2224
01:26:50,400 --> 01:26:52,000
something interesting

2225
01:26:52,000 --> 01:26:53,520
and we conjecture that this is not

2226
01:26:53,520 --> 01:26:54,880
doable

2227
01:26:54,880 --> 01:26:57,679
so our conjecture says that uh if we

2228
01:26:57,679 --> 01:27:00,960
give you a space that is polynomial in

2229
01:27:00,960 --> 01:27:02,400
the assignment

2230
01:27:02,400 --> 01:27:04,480
and uh pre-processing probabilistic

2231
01:27:04,480 --> 01:27:06,960
pre-processing which is polynomial time

2232
01:27:06,960 --> 01:27:09,520
uh in the size of the circuit we still

2233
01:27:09,520 --> 01:27:12,000
can't decide circuit sat

2234
01:27:12,000 --> 01:27:14,719
and given our compiler from before

2235
01:27:14,719 --> 01:27:15,600
we

2236
01:27:15,600 --> 01:27:17,760
conclude that under this conjecture

2237
01:27:17,760 --> 01:27:20,400
there is no constant trial succinct iop

2238
01:27:20,400 --> 01:27:22,560
uh for a circuit sat where the query

2239
01:27:22,560 --> 01:27:24,560
complexity is logarithmic

2240
01:27:24,560 --> 01:27:26,880
and yeah basically the and the number of

2241
01:27:26,880 --> 01:27:29,840
rounds is constant

2242
01:27:29,840 --> 01:27:31,920
so this is the second result that we

2243
01:27:31,920 --> 01:27:32,719
have

2244
01:27:32,719 --> 01:27:34,960
i have a reminder here of the compiler

2245
01:27:34,960 --> 01:27:36,400
uh

2246
01:27:36,400 --> 01:27:39,360
so these are our uh two results so the

2247
01:27:39,360 --> 01:27:41,440
first one is an application

2248
01:27:41,440 --> 01:27:43,520
uh we get zero knowledge proofs from

2249
01:27:43,520 --> 01:27:45,440
succinct iops

2250
01:27:45,440 --> 01:27:46,880
and uh

2251
01:27:46,880 --> 01:27:49,199
the second one is this uh a lower bound

2252
01:27:49,199 --> 01:27:51,040
assuming the new conjecture how much

2253
01:27:51,040 --> 01:27:52,480
time do i have left

2254
01:27:52,480 --> 01:27:54,799
um

2255
01:27:55,440 --> 01:27:57,120
you have you have a lot of time you have

2256
01:27:57,120 --> 01:27:58,960
eight minutes eight minutes with

2257
01:27:58,960 --> 01:28:01,840
questions so yeah i see uh okay i

2258
01:28:01,840 --> 01:28:03,199
thought that this would take the entire

2259
01:28:03,199 --> 01:28:04,400
time here

2260
01:28:04,400 --> 01:28:06,400
um so i can just talk about open

2261
01:28:06,400 --> 01:28:07,760
questions and then maybe i can dive a

2262
01:28:07,760 --> 01:28:10,080
bit a little bit into the techniques uh

2263
01:28:10,080 --> 01:28:12,560
so one of the open questions is can we

2264
01:28:12,560 --> 01:28:15,040
get rid of the uh

2265
01:28:15,040 --> 01:28:17,280
if we go back here

2266
01:28:17,280 --> 01:28:19,040
uh it doesn't let's go back can we get

2267
01:28:19,040 --> 01:28:21,840
rid of this uh of this power of uh the

2268
01:28:21,840 --> 01:28:22,960
instance even though it's like

2269
01:28:22,960 --> 01:28:24,960
arbitrarily small power but still uh

2270
01:28:24,960 --> 01:28:26,480
we'd like to get a truly succinct zero

2271
01:28:26,480 --> 01:28:27,600
knowledge proof and get rid of this

2272
01:28:27,600 --> 01:28:29,840
thing so that's the first question

2273
01:28:29,840 --> 01:28:31,920
um

2274
01:28:31,920 --> 01:28:35,360
the second question is can we get the uh

2275
01:28:35,360 --> 01:28:36,880
the opposite of our compiler so our

2276
01:28:36,880 --> 01:28:38,400
compiler takes a succinct iop and

2277
01:28:38,400 --> 01:28:40,080
converts it to a small space algorithm

2278
01:28:40,080 --> 01:28:42,000
with pre-processing and it would be

2279
01:28:42,000 --> 01:28:44,000
interesting to turn this into an if and

2280
01:28:44,000 --> 01:28:46,239
only if kind of statement so if we have

2281
01:28:46,239 --> 01:28:47,760
a

2282
01:28:47,760 --> 01:28:49,040
small space algorithm with

2283
01:28:49,040 --> 01:28:50,719
pre-processing can we turn that into an

2284
01:28:50,719 --> 01:28:53,040
iop actually we can but the number of

2285
01:28:53,040 --> 01:28:54,080
rounds would

2286
01:28:54,080 --> 01:28:55,600
grow a lot and it would be interesting

2287
01:28:55,600 --> 01:28:57,040
to get the same number of rounds that we

2288
01:28:57,040 --> 01:28:59,120
get in both directions

2289
01:28:59,120 --> 01:29:01,600
and uh another open question is whether

2290
01:29:01,600 --> 01:29:02,639
we can

2291
01:29:02,639 --> 01:29:04,239
base our conjecture on other known

2292
01:29:04,239 --> 01:29:06,000
conjectures or

2293
01:29:06,000 --> 01:29:07,520
give more evidence

2294
01:29:07,520 --> 01:29:09,120
to our conjecture that there's no

2295
01:29:09,120 --> 01:29:11,840
succinct iop for csat or for all np

2296
01:29:11,840 --> 01:29:14,080
relations

2297
01:29:14,080 --> 01:29:16,080
uh

2298
01:29:16,080 --> 01:29:17,679
any questions

2299
01:29:17,679 --> 01:29:18,880
well i have a question can you say more

2300
01:29:18,880 --> 01:29:21,040
about the application i'm sorry can you

2301
01:29:21,040 --> 01:29:23,760
say more about the application of iops

2302
01:29:23,760 --> 01:29:26,080
of succinct iops

2303
01:29:26,080 --> 01:29:27,600
your first result

2304
01:29:27,600 --> 01:29:29,920
yeah uh like uh i can delve into the

2305
01:29:29,920 --> 01:29:31,440
technique of uh

2306
01:29:31,440 --> 01:29:33,679
yeah

2307
01:29:33,679 --> 01:29:37,120
okay so i'm a bit ready uh so how do we

2308
01:29:37,120 --> 01:29:39,920
construct uh uh sex and zero knowledge

2309
01:29:39,920 --> 01:29:42,960
groups from my iops

2310
01:29:44,000 --> 01:29:46,560
um so basically that we're using here

2311
01:29:46,560 --> 01:29:48,480
standard uh uh techniques that were

2312
01:29:48,480 --> 01:29:50,000
known before for interactive proofs and

2313
01:29:50,000 --> 01:29:52,560
we're just uh appropriating them to uh

2314
01:29:52,560 --> 01:29:54,480
to iops so the first technique that we

2315
01:29:54,480 --> 01:29:56,480
use is uh the notarized envelopes

2316
01:29:56,480 --> 01:29:57,520
technique

2317
01:29:57,520 --> 01:29:59,760
so uh basically what it says is that we

2318
01:29:59,760 --> 01:30:02,800
can do an encrypted interaction an

2319
01:30:02,800 --> 01:30:04,719
encrypted version of the interactive

2320
01:30:04,719 --> 01:30:07,280
proof so this this heavily depends on

2321
01:30:07,280 --> 01:30:09,280
the fact that we have a public coin uh

2322
01:30:09,280 --> 01:30:10,400
protocol

2323
01:30:10,400 --> 01:30:13,840
so the approver uh instead of sending

2324
01:30:13,840 --> 01:30:15,760
its messages in the clear it sends a

2325
01:30:15,760 --> 01:30:17,920
commitment of those messages and the

2326
01:30:17,920 --> 01:30:19,840
verifier responds with the public coins

2327
01:30:19,840 --> 01:30:21,199
because it doesn't matter it doesn't

2328
01:30:21,199 --> 01:30:23,199
read the messages before uh replying

2329
01:30:23,199 --> 01:30:24,639
with public coins

2330
01:30:24,639 --> 01:30:27,199
uh and in the end uh we'd like for the

2331
01:30:27,199 --> 01:30:29,040
prover to reveal

2332
01:30:29,040 --> 01:30:31,040
uh

2333
01:30:31,040 --> 01:30:32,560
to reveal its messages so that the

2334
01:30:32,560 --> 01:30:35,040
verifier can decide whether to accept or

2335
01:30:35,040 --> 01:30:37,120
not but instead of doing that we prove

2336
01:30:37,120 --> 01:30:39,199
in zero knowledge that if the approver

2337
01:30:39,199 --> 01:30:42,239
did indeed uh reveal those messages then

2338
01:30:42,239 --> 01:30:45,120
the verifier would accept

2339
01:30:45,120 --> 01:30:47,040
so basically the the np statement that

2340
01:30:47,040 --> 01:30:48,239
we proved at the end is that there

2341
01:30:48,239 --> 01:30:49,840
exists the commitment such that the

2342
01:30:49,840 --> 01:30:51,360
revealed messages would make the vapor

2343
01:30:51,360 --> 01:30:53,440
accept so this is the first uh technique

2344
01:30:53,440 --> 01:30:54,800
that we use here

2345
01:30:54,800 --> 01:30:56,159
uh

2346
01:30:56,159 --> 01:30:57,920
we have like a zero knowledge proof at

2347
01:30:57,920 --> 01:30:59,040
the end

2348
01:30:59,040 --> 01:31:02,080
uh the thing is we can utilize the fact

2349
01:31:02,080 --> 01:31:04,159
uh that we have an iop instead of an

2350
01:31:04,159 --> 01:31:05,520
interactive proof

2351
01:31:05,520 --> 01:31:07,120
and basically what this means is that

2352
01:31:07,120 --> 01:31:08,400
the verifier is interested in just a

2353
01:31:08,400 --> 01:31:11,360
small a small number of the uh

2354
01:31:11,360 --> 01:31:14,800
of the locations and the prover messages

2355
01:31:14,800 --> 01:31:16,560
so the prover doesn't have to reveal

2356
01:31:16,560 --> 01:31:17,679
everything

2357
01:31:17,679 --> 01:31:19,360
uh the statement can only correspond to

2358
01:31:19,360 --> 01:31:21,440
those to the small number of locations

2359
01:31:21,440 --> 01:31:23,440
and approver messages

2360
01:31:23,440 --> 01:31:25,520
so if we use like a commitment with

2361
01:31:25,520 --> 01:31:28,239
local openings then the zero knowledge

2362
01:31:28,239 --> 01:31:32,480
proof at the end can be much shorter

2363
01:31:32,560 --> 01:31:34,719
so uh this is the second thing and

2364
01:31:34,719 --> 01:31:36,880
basically how we use uh

2365
01:31:36,880 --> 01:31:38,480
the kind of commitment that we use is

2366
01:31:38,480 --> 01:31:41,120
just the prf so basically the approver

2367
01:31:41,120 --> 01:31:43,199
at the beginning commits to a pure fc it

2368
01:31:43,199 --> 01:31:45,440
sends it in this box and then uses the

2369
01:31:45,440 --> 01:31:47,679
prf with this seed to uh

2370
01:31:47,679 --> 01:31:49,360
suit the random one-time pad its

2371
01:31:49,360 --> 01:31:52,000
messages and in the end it just uh the

2372
01:31:52,000 --> 01:31:53,840
uh the in statement only depends on the

2373
01:31:53,840 --> 01:31:55,280
seed on this little box that has been

2374
01:31:55,280 --> 01:31:58,239
sent and the specific locations so this

2375
01:31:58,239 --> 01:31:59,600
is the uh

2376
01:31:59,600 --> 01:32:03,440
second improvement we do to the uh

2377
01:32:03,440 --> 01:32:06,239
to the notarized envelopes technique

2378
01:32:06,239 --> 01:32:07,760
and uh

2379
01:32:07,760 --> 01:32:10,000
the final thing is that the final issue

2380
01:32:10,000 --> 01:32:12,239
here is that uh still the verification

2381
01:32:12,239 --> 01:32:14,320
that we need to do depends on the

2382
01:32:14,320 --> 01:32:16,400
statement in x so even if we had

2383
01:32:16,400 --> 01:32:18,080
succinctness at the beginning

2384
01:32:18,080 --> 01:32:20,520
we're losing all of this

2385
01:32:20,520 --> 01:32:22,960
successiveness in the final stage of the

2386
01:32:22,960 --> 01:32:24,320
zero knowledge proof

2387
01:32:24,320 --> 01:32:25,760
because uh verification can be

2388
01:32:25,760 --> 01:32:28,400
polynomial in x

2389
01:32:28,400 --> 01:32:29,679
um

2390
01:32:29,679 --> 01:32:31,120
yeah those should have been here before

2391
01:32:31,120 --> 01:32:32,800
sorry about the transitions

2392
01:32:32,800 --> 01:32:33,760
uh

2393
01:32:33,760 --> 01:32:36,960
so the thing we uh the final piece here

2394
01:32:36,960 --> 01:32:38,239
is uh

2395
01:32:38,239 --> 01:32:40,800
we're looking at non-adaptive iops

2396
01:32:40,800 --> 01:32:43,040
so an adaptive iop is an iop where the

2397
01:32:43,040 --> 01:32:46,159
uh verifier the queries of the verifier

2398
01:32:46,159 --> 01:32:48,159
don't depend on the values of previous

2399
01:32:48,159 --> 01:32:50,400
queries it just depends on the uh on the

2400
01:32:50,400 --> 01:32:52,159
randomness and on the instance itself so

2401
01:32:52,159 --> 01:32:55,360
after that the uh communication phase is

2402
01:32:55,360 --> 01:32:57,280
an interaction phase is done uh the

2403
01:32:57,280 --> 01:32:59,600
verifier just chooses all of the queries

2404
01:32:59,600 --> 01:33:01,679
that it wants to make in the spot and it

2405
01:33:01,679 --> 01:33:03,040
makes those queries and doesn't change

2406
01:33:03,040 --> 01:33:04,320
anything about them so that's the

2407
01:33:04,320 --> 01:33:05,920
unadapted thing

2408
01:33:05,920 --> 01:33:07,520
and uh

2409
01:33:07,520 --> 01:33:10,480
we say that and then on those uh queries

2410
01:33:10,480 --> 01:33:13,280
it applies this sort of predicate

2411
01:33:13,280 --> 01:33:14,880
and just decides accordingly according

2412
01:33:14,880 --> 01:33:17,040
to the value of the predicate

2413
01:33:17,040 --> 01:33:19,360
and we say that the verifier is gamma

2414
01:33:19,360 --> 01:33:21,679
compact if the size of this predicate is

2415
01:33:21,679 --> 01:33:24,000
at most gamma

2416
01:33:24,000 --> 01:33:27,280
uh and it's easy to see here that the

2417
01:33:27,280 --> 01:33:29,760
final uh np proof doesn't have to depend

2418
01:33:29,760 --> 01:33:31,760
on x it only depends on the compactness

2419
01:33:31,760 --> 01:33:33,760
on the size of the predicate because

2420
01:33:33,760 --> 01:33:36,000
once we know the randomness we know x we

2421
01:33:36,000 --> 01:33:38,639
just need to generate this uh predicate

2422
01:33:38,639 --> 01:33:39,679
and

2423
01:33:39,679 --> 01:33:41,440
the statement is whether there exists

2424
01:33:41,440 --> 01:33:42,960
the commitment that would make this

2425
01:33:42,960 --> 01:33:46,719
predicate output one

2426
01:33:46,719 --> 01:33:49,040
so if the iop that we have is very

2427
01:33:49,040 --> 01:33:50,719
compact then the

2428
01:33:50,719 --> 01:33:51,920
zero knowledge proof that we have at the

2429
01:33:51,920 --> 01:33:54,000
end is going to be very small and we

2430
01:33:54,000 --> 01:33:56,639
actually prove that the iop of frontier

2431
01:33:56,639 --> 01:33:58,800
and roadbloom is indeed very compact so

2432
01:33:58,800 --> 01:34:01,040
we get the zero knowledge proof

2433
01:34:01,040 --> 01:34:04,159
to be very very short here

2434
01:34:04,159 --> 01:34:05,520
so these are basically the ingredients

2435
01:34:05,520 --> 01:34:06,639
to approve just your favorite

2436
01:34:06,639 --> 01:34:07,920
zero-knowledge proof for np a

2437
01:34:07,920 --> 01:34:10,000
statistically binding commitment scheme

2438
01:34:10,000 --> 01:34:11,440
and a pseudorandom function and all of

2439
01:34:11,440 --> 01:34:14,159
those we can get from one-way functions

2440
01:34:14,159 --> 01:34:16,159
and that's the protocol but i just i've

2441
01:34:16,159 --> 01:34:19,799
already talked about that

2442
01:34:20,320 --> 01:34:22,000
there's no there's no other thank you

2443
01:34:22,000 --> 01:34:22,880
slide

2444
01:34:22,880 --> 01:34:24,320
so i have to go back to this one but

2445
01:34:24,320 --> 01:34:25,440
thank you

2446
01:34:25,440 --> 01:34:27,919
thanks a lot

2447
01:34:31,679 --> 01:34:34,880
so uh i this is the end of the um well

2448
01:34:34,880 --> 01:34:36,480
actually if you have more questions for

2449
01:34:36,480 --> 01:34:38,560
the speaker since this is the last one

2450
01:34:38,560 --> 01:34:41,040
we can you can still ask but this was

2451
01:34:41,040 --> 01:34:44,840
the last talk go ahead

2452
01:34:48,719 --> 01:34:51,360
nice results great talk um you had a

2453
01:34:51,360 --> 01:34:53,760
slide which said that with fhe we can

2454
01:34:53,760 --> 01:34:56,400
get uh proofs that approach the witness

2455
01:34:56,400 --> 01:34:58,159
length and with one way functions you

2456
01:34:58,159 --> 01:34:59,920
have this annoying additive factor

2457
01:34:59,920 --> 01:35:02,719
floating around i was wondering whether

2458
01:35:02,719 --> 01:35:04,320
some somewhat homomorphic like

2459
01:35:04,320 --> 01:35:06,239
encryption does it give you

2460
01:35:06,239 --> 01:35:08,239
something better

2461
01:35:08,239 --> 01:35:10,400
again so uh what's the question again

2462
01:35:10,400 --> 01:35:12,800
yeah so uh you had a slide

2463
01:35:12,800 --> 01:35:14,800
which said that with fhe

2464
01:35:14,800 --> 01:35:16,320
i'm trying to get there but yeah i can

2465
01:35:16,320 --> 01:35:18,960
ask a question

2466
01:35:22,159 --> 01:35:24,879
why is this slow

2467
01:35:24,960 --> 01:35:27,960
oh

2468
01:35:32,480 --> 01:35:33,280
yeah

2469
01:35:33,280 --> 01:35:34,719
yeah so with the

2470
01:35:34,719 --> 01:35:36,639
fhe you can get these proofs which

2471
01:35:36,639 --> 01:35:38,880
approach approach the witness line yeah

2472
01:35:38,880 --> 01:35:41,280
with one-way functions uh in your result

2473
01:35:41,280 --> 01:35:43,119
you have that annoying

2474
01:35:43,119 --> 01:35:45,360
additive factor right and i was

2475
01:35:45,360 --> 01:35:47,280
wondering whether like some weaker form

2476
01:35:47,280 --> 01:35:49,040
of fhe which is somewhat homomorphic

2477
01:35:49,040 --> 01:35:50,000
encryption

2478
01:35:50,000 --> 01:35:51,360
does that allow you to get something

2479
01:35:51,360 --> 01:35:53,679
better

2480
01:35:53,760 --> 01:35:54,960
i'm not sure i understand the question

2481
01:35:54,960 --> 01:35:57,440
like fhe gives us this

2482
01:35:57,440 --> 01:35:59,760
right so um

2483
01:35:59,760 --> 01:36:01,520
does any weaker form of fhe like

2484
01:36:01,520 --> 01:36:03,520
somewhat homomorphic encryption or i

2485
01:36:03,520 --> 01:36:05,920
just can't

2486
01:36:06,080 --> 01:36:07,600
uh so for example does additive

2487
01:36:07,600 --> 01:36:08,880
homomorphic encryption give you

2488
01:36:08,880 --> 01:36:10,800
something

2489
01:36:10,800 --> 01:36:11,920
that's the word i've been missing the

2490
01:36:11,920 --> 01:36:13,119
whole time

2491
01:36:13,119 --> 01:36:15,280
um i'm not sure i haven't thought about

2492
01:36:15,280 --> 01:36:18,080
it um

2493
01:36:18,639 --> 01:36:20,800
i really don't know okay

2494
01:36:20,800 --> 01:36:22,159
all of that make you repeat the question

2495
01:36:22,159 --> 01:36:24,800
just totally i don't know

2496
01:36:24,800 --> 01:36:25,679
yes

2497
01:36:25,679 --> 01:36:28,000
yeah i was wondering whether you thought

2498
01:36:28,000 --> 01:36:30,480
of maybe basing the impossibility result

2499
01:36:30,480 --> 01:36:32,400
and like some sequential computation

2500
01:36:32,400 --> 01:36:34,320
like say a hash chain even or you know

2501
01:36:34,320 --> 01:36:36,239
in some style in some random oracle

2502
01:36:36,239 --> 01:36:38,400
model right it seems very unlikely that

2503
01:36:38,400 --> 01:36:40,159
for for you know

2504
01:36:40,159 --> 01:36:41,760
i mean a random oracle model it's

2505
01:36:41,760 --> 01:36:43,840
probably impossible that i can get a

2506
01:36:43,840 --> 01:36:47,520
succinct uh pcp iop anything for

2507
01:36:47,520 --> 01:36:49,760
uh say hashtag even though it has a very

2508
01:36:49,760 --> 01:36:51,360
very short witness and even the instance

2509
01:36:51,360 --> 01:36:54,159
is short um have you thought about like

2510
01:36:54,159 --> 01:36:55,360
you know basing it on sequential

2511
01:36:55,360 --> 01:36:57,839
competition

2512
01:37:00,719 --> 01:37:02,480
oh okay so you can actually

2513
01:37:02,480 --> 01:37:05,799
oh interesting

2514
01:37:16,480 --> 01:37:17,840
thank you very much

2515
01:37:17,840 --> 01:37:21,000
and um

