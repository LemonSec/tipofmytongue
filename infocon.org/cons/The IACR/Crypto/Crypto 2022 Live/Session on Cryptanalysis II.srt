1
00:00:00,000 --> 00:00:01,599
those of you who made it back from the

2
00:00:01,599 --> 00:00:02,879
coffee break

3
00:00:02,879 --> 00:00:04,160
and uh

4
00:00:04,160 --> 00:00:05,600
i imagine that some more people will

5
00:00:05,600 --> 00:00:07,440
keep coming in

6
00:00:07,440 --> 00:00:10,080
uh this is a session on crypto analysis

7
00:00:10,080 --> 00:00:12,160
2 which is the best

8
00:00:12,160 --> 00:00:14,639
of crypto and of analysis so

9
00:00:14,639 --> 00:00:17,279
i hope you'll enjoy this session with me

10
00:00:17,279 --> 00:00:19,439
there will be four talks today and uh

11
00:00:19,439 --> 00:00:21,520
the first one is on isogeny based

12
00:00:21,520 --> 00:00:23,600
cryptography which is contrary to some

13
00:00:23,600 --> 00:00:25,199
people's belief not totally broken there

14
00:00:25,199 --> 00:00:26,880
are still things that are believed to be

15
00:00:26,880 --> 00:00:28,320
secure

16
00:00:28,320 --> 00:00:30,400
um and the title is uh accelerating the

17
00:00:30,400 --> 00:00:32,238
delf skull breath algorithm with fast

18
00:00:32,238 --> 00:00:35,280
subfield root detection uh written by

19
00:00:35,280 --> 00:00:38,399
maria santos craig costello josh

20
00:00:38,399 --> 00:00:40,800
and maria will give the talk

21
00:00:40,800 --> 00:00:42,840
thank you uh can everyone hear

22
00:00:42,840 --> 00:00:46,160
me thanks for the introduction so i'm

23
00:00:46,160 --> 00:00:49,120
maria and i'll be talking about

24
00:00:49,120 --> 00:00:50,879
how we accelerated the dell scale

25
00:00:50,879 --> 00:00:53,600
breathe algorithm with fast subfield

26
00:00:53,600 --> 00:00:55,840
root detection

27
00:00:55,840 --> 00:00:58,160
so for us some motivation as to why we

28
00:00:58,160 --> 00:01:00,559
um study this problem

29
00:01:00,559 --> 00:01:01,370
so um

30
00:01:01,370 --> 00:01:02,719
[Music]

31
00:01:02,719 --> 00:01:05,199
the super singular isogeny problem is

32
00:01:05,199 --> 00:01:07,280
the foundational problem in isogenic

33
00:01:07,280 --> 00:01:08,880
based cryptography

34
00:01:08,880 --> 00:01:10,880
and it's conjecture to be post-quantum

35
00:01:10,880 --> 00:01:13,600
secure

36
00:01:13,600 --> 00:01:16,720
so um primitives like ski sign which is

37
00:01:16,720 --> 00:01:19,680
an isogeny based signature scheme and b

38
00:01:19,680 --> 00:01:22,640
side which is a key exchange uh relies

39
00:01:22,640 --> 00:01:24,880
on the difficulty of this problem though

40
00:01:24,880 --> 00:01:27,119
slight caveat that b-side might also be

41
00:01:27,119 --> 00:01:29,680
affected by the new attacks

42
00:01:29,680 --> 00:01:32,000
um and the best-known classical attack

43
00:01:32,000 --> 00:01:34,640
against this isogeny problem

44
00:01:34,640 --> 00:01:38,159
is the del skelbroth algorithm

45
00:01:38,159 --> 00:01:40,880
so our contributions in this paper um

46
00:01:40,880 --> 00:01:44,079
was to implement um and optimize the

47
00:01:44,079 --> 00:01:46,320
dell scale breath algorithm

48
00:01:46,320 --> 00:01:47,119
to

49
00:01:47,119 --> 00:01:50,159
determine its concrete

50
00:01:50,159 --> 00:01:52,079
concrete efficiency

51
00:01:52,079 --> 00:01:54,399
and then we developed an efficient

52
00:01:54,399 --> 00:01:56,880
method to detect whether

53
00:01:56,880 --> 00:01:59,280
a polynomial with coefficients

54
00:01:59,280 --> 00:02:02,560
in some extension field of fp

55
00:02:02,560 --> 00:02:05,520
has a root in the base field

56
00:02:05,520 --> 00:02:08,479
and then using this we improved the dell

57
00:02:08,479 --> 00:02:11,520
scale birth algorithm um

58
00:02:11,520 --> 00:02:14,800
by lowering its concrete complexity

59
00:02:14,800 --> 00:02:16,800
okay so first some some background

60
00:02:16,800 --> 00:02:18,160
information

61
00:02:18,160 --> 00:02:21,599
um so in isogeny basic cryptography we

62
00:02:21,599 --> 00:02:23,840
study elliptic curves

63
00:02:23,840 --> 00:02:27,360
and an elliptic curve is um

64
00:02:27,360 --> 00:02:31,440
a smooth curve given by this equation

65
00:02:31,440 --> 00:02:33,360
where you have y squared equals some

66
00:02:33,360 --> 00:02:35,360
cubic

67
00:02:35,360 --> 00:02:36,640
and a and b

68
00:02:36,640 --> 00:02:38,400
lie in fp squared

69
00:02:38,400 --> 00:02:40,000
and because

70
00:02:40,000 --> 00:02:41,760
we normally use cryptographic size

71
00:02:41,760 --> 00:02:43,599
primes we can assume that p is not two

72
00:02:43,599 --> 00:02:45,360
or three so there are no issues with

73
00:02:45,360 --> 00:02:46,319
that

74
00:02:46,319 --> 00:02:48,239
and then

75
00:02:48,239 --> 00:02:51,280
um we have this condition where

76
00:02:51,280 --> 00:02:52,720
uh 4

77
00:02:52,720 --> 00:02:55,120
a cubed plus 27 b squared is not equal

78
00:02:55,120 --> 00:02:57,360
to 0 but all that means is that our

79
00:02:57,360 --> 00:02:59,519
curve is not singular and behaves nicely

80
00:02:59,519 --> 00:03:01,680
and you have a nice group law on your

81
00:03:01,680 --> 00:03:04,319
elliptic curve

82
00:03:04,319 --> 00:03:05,280
and

83
00:03:05,280 --> 00:03:07,120
for efficiency reasons

84
00:03:07,120 --> 00:03:11,440
we study super singular elliptic curves

85
00:03:11,519 --> 00:03:13,519
and a key

86
00:03:13,519 --> 00:03:14,959
point that we'll be using throughout the

87
00:03:14,959 --> 00:03:17,200
talk is that we can label our elliptic

88
00:03:17,200 --> 00:03:18,560
curves

89
00:03:18,560 --> 00:03:21,280
using what's called the j invariant

90
00:03:21,280 --> 00:03:23,360
and this strain variant

91
00:03:23,360 --> 00:03:25,599
is given by this

92
00:03:25,599 --> 00:03:27,840
equation here which is also why we need

93
00:03:27,840 --> 00:03:29,519
this to not be zero

94
00:03:29,519 --> 00:03:30,840
and

95
00:03:30,840 --> 00:03:33,680
um uh your j invariant lies in fb

96
00:03:33,680 --> 00:03:36,159
squared so given an elliptic curve you

97
00:03:36,159 --> 00:03:38,480
can compute its strain variant and use

98
00:03:38,480 --> 00:03:40,720
it to label your elliptic curve up to

99
00:03:40,720 --> 00:03:43,599
isomorphism

100
00:03:43,680 --> 00:03:47,440
okay so a isogeny is then

101
00:03:47,440 --> 00:03:49,760
if you have two elliptic curves

102
00:03:49,760 --> 00:03:52,000
and you consider a map between them and

103
00:03:52,000 --> 00:03:54,720
isogeny is this map

104
00:03:54,720 --> 00:03:56,879
which should be non-constant and should

105
00:03:56,879 --> 00:03:58,879
send the identity

106
00:03:58,879 --> 00:04:00,799
point on e

107
00:04:00,799 --> 00:04:02,959
to the identity point on your image

108
00:04:02,959 --> 00:04:04,959
curve

109
00:04:04,959 --> 00:04:07,519
um and these properties ensure that our

110
00:04:07,519 --> 00:04:10,640
isogeny is a group homomorphism

111
00:04:10,640 --> 00:04:12,799
um which just means that it interacts

112
00:04:12,799 --> 00:04:14,640
nicely with the group structure on your

113
00:04:14,640 --> 00:04:18,720
elliptic curve so um given two points

114
00:04:18,720 --> 00:04:20,639
on your elliptic curve e if you add them

115
00:04:20,639 --> 00:04:22,800
together and apply the map it's the same

116
00:04:22,800 --> 00:04:25,120
as applying the map on each point and

117
00:04:25,120 --> 00:04:27,199
adding them on the image

118
00:04:27,199 --> 00:04:29,600
um

119
00:04:29,600 --> 00:04:32,240
for all the esogenies that we care about

120
00:04:32,240 --> 00:04:34,560
in isogenic based cryptography

121
00:04:34,560 --> 00:04:36,080
um

122
00:04:36,080 --> 00:04:38,080
we define the degree of our map to just

123
00:04:38,080 --> 00:04:40,800
be the size of its kernel

124
00:04:40,800 --> 00:04:44,240
and then we'll say that um

125
00:04:44,240 --> 00:04:46,800
an isogenetic of degree l

126
00:04:46,800 --> 00:04:49,520
is just an l surgeon

127
00:04:49,520 --> 00:04:50,479
okay

128
00:04:50,479 --> 00:04:52,639
so now i'm ready to define the super

129
00:04:52,639 --> 00:04:55,120
singular isogeny problem

130
00:04:55,120 --> 00:04:58,000
in its most general form it asks us to

131
00:04:58,000 --> 00:05:00,800
find an isogeny between two super

132
00:05:00,800 --> 00:05:02,800
singular elliptic curves

133
00:05:02,800 --> 00:05:06,320
defined over f p squared

134
00:05:06,639 --> 00:05:08,560
uh note that we're not assuming torsion

135
00:05:08,560 --> 00:05:10,400
point information we're not assuming

136
00:05:10,400 --> 00:05:12,960
that we know the degree of the isogeny

137
00:05:12,960 --> 00:05:15,440
or that the starting curve is of any

138
00:05:15,440 --> 00:05:17,919
special form with known endomorphism

139
00:05:17,919 --> 00:05:19,440
ring etcetera

140
00:05:19,440 --> 00:05:22,080
so in particular it's still conjectured

141
00:05:22,080 --> 00:05:24,800
to be post-quantum secure and it's not

142
00:05:24,800 --> 00:05:26,960
affected by any of the attacks um

143
00:05:26,960 --> 00:05:28,960
because they really rely on

144
00:05:28,960 --> 00:05:32,720
these two uh points here

145
00:05:32,720 --> 00:05:34,320
okay

146
00:05:34,320 --> 00:05:36,880
so a nice way to view this isogeny

147
00:05:36,880 --> 00:05:39,039
problem is by viewing it in terms of

148
00:05:39,039 --> 00:05:41,280
finding paths in a graph

149
00:05:41,280 --> 00:05:43,440
so

150
00:05:44,160 --> 00:05:46,720
if you let p be a large prime such that

151
00:05:46,720 --> 00:05:48,639
it doesn't divide the degree of your

152
00:05:48,639 --> 00:05:51,360
isogeny you can define the suprasingular

153
00:05:51,360 --> 00:05:53,120
isogeny graph

154
00:05:53,120 --> 00:05:56,639
where here your nodes are

155
00:05:56,639 --> 00:05:58,479
elliptic curve super singular elliptic

156
00:05:58,479 --> 00:06:01,120
curves and you can label each node by

157
00:06:01,120 --> 00:06:04,000
the j invariant

158
00:06:04,000 --> 00:06:06,560
and then the edges in your lysogenic

159
00:06:06,560 --> 00:06:09,600
graph are just lysosomes

160
00:06:09,600 --> 00:06:11,520
so two nodes in your graph will be

161
00:06:11,520 --> 00:06:13,600
connected by an edge

162
00:06:13,600 --> 00:06:17,680
um if the elliptic curves um

163
00:06:17,680 --> 00:06:21,520
are connected by an l-isogeny

164
00:06:21,520 --> 00:06:23,600
so the properties of this graph that

165
00:06:23,600 --> 00:06:24,800
will be

166
00:06:24,800 --> 00:06:26,319
interesting to us

167
00:06:26,319 --> 00:06:27,680
are that

168
00:06:27,680 --> 00:06:29,919
a random walk of

169
00:06:29,919 --> 00:06:31,600
a short length

170
00:06:31,600 --> 00:06:34,479
so of log p steps is almost as good as

171
00:06:34,479 --> 00:06:36,639
uniformly sampling

172
00:06:36,639 --> 00:06:38,240
a vertex

173
00:06:38,240 --> 00:06:40,720
and this is called

174
00:06:40,720 --> 00:06:42,560
the expander property

175
00:06:42,560 --> 00:06:44,319
and

176
00:06:44,319 --> 00:06:46,319
it intuitively means that there's very

177
00:06:46,319 --> 00:06:48,400
good mixing in the graph which means

178
00:06:48,400 --> 00:06:51,120
that finding a path between two nodes

179
00:06:51,120 --> 00:06:52,000
is

180
00:06:52,000 --> 00:06:54,240
generally quite difficult

181
00:06:54,240 --> 00:06:56,560
and in fact path binding in this graph

182
00:06:56,560 --> 00:06:59,120
is conjecture to be

183
00:06:59,120 --> 00:07:00,639
hard for both classical and quantum

184
00:07:00,639 --> 00:07:03,039
computers

185
00:07:03,039 --> 00:07:04,800
and as i said before

186
00:07:04,800 --> 00:07:07,280
finding a path between two nodes

187
00:07:07,280 --> 00:07:08,880
in your

188
00:07:08,880 --> 00:07:10,319
graph

189
00:07:10,319 --> 00:07:12,400
is the same as finding an isogeny

190
00:07:12,400 --> 00:07:13,840
between

191
00:07:13,840 --> 00:07:16,319
the elliptic curves represented by the j

192
00:07:16,319 --> 00:07:18,960
and variance

193
00:07:18,960 --> 00:07:20,720
and just sort of a point of

194
00:07:20,720 --> 00:07:22,240
clarification

195
00:07:22,240 --> 00:07:25,120
we normally just consider this the set

196
00:07:25,120 --> 00:07:27,759
of vertices and we kind of move in

197
00:07:27,759 --> 00:07:31,360
between the different lysogeny graphs so

198
00:07:31,360 --> 00:07:32,960
sometimes we'll take steps in the two

199
00:07:32,960 --> 00:07:36,960
isogeny graph where we walk

200
00:07:36,960 --> 00:07:38,560
along the edges

201
00:07:38,560 --> 00:07:41,039
represented by two isogenes and then

202
00:07:41,039 --> 00:07:42,639
we'll switch between graphs with

203
00:07:42,639 --> 00:07:45,680
different l's but our node set will

204
00:07:45,680 --> 00:07:48,800
always stay the same

205
00:07:49,919 --> 00:07:52,479
okay so um

206
00:07:52,479 --> 00:07:54,400
sort of a very

207
00:07:54,400 --> 00:07:56,639
special property of this graph is that

208
00:07:56,639 --> 00:07:59,120
there's a sub graph given by

209
00:07:59,120 --> 00:08:02,400
j and variance that are defined over fp

210
00:08:02,400 --> 00:08:05,120
so you have your super singular elliptic

211
00:08:05,120 --> 00:08:06,160
graph

212
00:08:06,160 --> 00:08:08,800
sorry super singular isogeny graph

213
00:08:08,800 --> 00:08:11,520
and most of these are

214
00:08:11,520 --> 00:08:13,440
have jane varence which are defined of

215
00:08:13,440 --> 00:08:15,919
fb squared and these are the ones that

216
00:08:15,919 --> 00:08:17,360
are in white

217
00:08:17,360 --> 00:08:20,160
but there are a subset of these

218
00:08:20,160 --> 00:08:23,280
have j and variant defined over fp

219
00:08:23,280 --> 00:08:26,400
and this sort of defines an fp subgraph

220
00:08:26,400 --> 00:08:27,840
and the paths

221
00:08:27,840 --> 00:08:30,479
in this fp subgraph are a lot easier to

222
00:08:30,479 --> 00:08:33,440
find or comparatively easy to find

223
00:08:33,440 --> 00:08:35,839
whereas finding paths between nodes

224
00:08:35,839 --> 00:08:38,320
defined over fp squared to the nodes

225
00:08:38,320 --> 00:08:40,559
defined at the fp is kind of the

226
00:08:40,559 --> 00:08:43,919
bottleneck like this is um takes

227
00:08:43,919 --> 00:08:45,920
a longer time

228
00:08:45,920 --> 00:08:48,320
so dels and galbraith use this to

229
00:08:48,320 --> 00:08:50,560
develop that algorithm

230
00:08:50,560 --> 00:08:53,120
where they have a start and end node and

231
00:08:53,120 --> 00:08:54,560
these are the elliptic curves you want

232
00:08:54,560 --> 00:08:57,920
to find a misogyny between

233
00:08:58,560 --> 00:09:00,560
and the first step is to find a path

234
00:09:00,560 --> 00:09:01,440
from

235
00:09:01,440 --> 00:09:03,680
your start node to a node defined over

236
00:09:03,680 --> 00:09:04,880
fp

237
00:09:04,880 --> 00:09:06,399
and then you do the same for your end

238
00:09:06,399 --> 00:09:07,680
node

239
00:09:07,680 --> 00:09:10,160
and because of the proportion of nodes

240
00:09:10,160 --> 00:09:12,320
defined over fp squared

241
00:09:12,320 --> 00:09:14,080
and um

242
00:09:14,080 --> 00:09:16,000
and the proportion of of nodes defined

243
00:09:16,000 --> 00:09:19,839
by fp um you can expect to do this in

244
00:09:19,839 --> 00:09:23,200
sort of order of the square root of p

245
00:09:23,200 --> 00:09:25,760
bit operations

246
00:09:25,760 --> 00:09:27,360
and then once you have these two nodes

247
00:09:27,360 --> 00:09:29,360
defined over fp

248
00:09:29,360 --> 00:09:32,399
you can find a path between them

249
00:09:32,399 --> 00:09:34,880
and this will take around order of the

250
00:09:34,880 --> 00:09:36,399
fourth root of p

251
00:09:36,399 --> 00:09:38,080
the operations

252
00:09:38,080 --> 00:09:40,399
um and this is what i mean by it's easy

253
00:09:40,399 --> 00:09:42,000
it's still not easy but it's like

254
00:09:42,000 --> 00:09:44,160
comparatively this first step is the

255
00:09:44,160 --> 00:09:46,080
bottleneck

256
00:09:46,080 --> 00:09:47,920
and then you can just concatenate the

257
00:09:47,920 --> 00:09:51,200
paths and find your path from your start

258
00:09:51,200 --> 00:09:53,920
node to your end node

259
00:09:53,920 --> 00:09:55,519
and um

260
00:09:55,519 --> 00:09:57,600
because the first step is the bottleneck

261
00:09:57,600 --> 00:09:59,920
this is the step that we focus on

262
00:09:59,920 --> 00:10:02,079
and from now on i'll just be talking

263
00:10:02,079 --> 00:10:05,120
about how you can

264
00:10:05,760 --> 00:10:07,760
go from a node in fb square to a node in

265
00:10:07,760 --> 00:10:10,399
fp efficiently

266
00:10:10,399 --> 00:10:11,519
okay

267
00:10:11,519 --> 00:10:13,279
so now how do we take a step in this

268
00:10:13,279 --> 00:10:14,399
graph

269
00:10:14,399 --> 00:10:15,279
um

270
00:10:15,279 --> 00:10:17,360
to take a step in the graph we use

271
00:10:17,360 --> 00:10:19,120
modular polynomials

272
00:10:19,120 --> 00:10:20,560
and these are just

273
00:10:20,560 --> 00:10:22,560
bivariate polynomials with integer

274
00:10:22,560 --> 00:10:24,640
coefficients

275
00:10:24,640 --> 00:10:27,360
and they're symmetric in x and y

276
00:10:27,360 --> 00:10:29,600
and they're of degree nl though the

277
00:10:29,600 --> 00:10:31,440
details don't really matter all that

278
00:10:31,440 --> 00:10:35,200
matters is nl grows as n gro as l grows

279
00:10:35,200 --> 00:10:38,079
and in particular equals l plus one when

280
00:10:38,079 --> 00:10:40,720
l is a prime

281
00:10:40,720 --> 00:10:42,800
and the key point of these modular

282
00:10:42,800 --> 00:10:44,480
polynomials

283
00:10:44,480 --> 00:10:46,640
is that if you evaluate them at two j

284
00:10:46,640 --> 00:10:49,360
invariants it will evaluate to zero if

285
00:10:49,360 --> 00:10:50,720
and only if

286
00:10:50,720 --> 00:10:51,600
um

287
00:10:51,600 --> 00:10:53,760
the elliptic curves represented by these

288
00:10:53,760 --> 00:10:56,399
j invariants are l-isogenous so they're

289
00:10:56,399 --> 00:10:59,600
connected by some l-isogeny

290
00:10:59,600 --> 00:11:01,600
and so if we evaluate our modular

291
00:11:01,600 --> 00:11:04,320
polynomial at j

292
00:11:04,320 --> 00:11:06,240
then we can compute the roots of this

293
00:11:06,240 --> 00:11:08,160
polynomial and these will be the

294
00:11:08,160 --> 00:11:10,720
neighbors of that j invariant in the

295
00:11:10,720 --> 00:11:13,600
lisogna graph

296
00:11:13,600 --> 00:11:15,440
and just a really technical point is

297
00:11:15,440 --> 00:11:17,440
that we can reduce the coefficients of

298
00:11:17,440 --> 00:11:19,519
our modular polynomial

299
00:11:19,519 --> 00:11:22,399
mod p and this ensures that um you know

300
00:11:22,399 --> 00:11:25,920
we have no storage issues

301
00:11:25,920 --> 00:11:26,720
okay

302
00:11:26,720 --> 00:11:29,279
so maybe a bit more clearly what you do

303
00:11:29,279 --> 00:11:31,040
is you store

304
00:11:31,040 --> 00:11:32,800
your current j invariant and your

305
00:11:32,800 --> 00:11:35,519
previous strain variant

306
00:11:35,519 --> 00:11:38,160
you find the roots of your modular

307
00:11:38,160 --> 00:11:40,320
polynomial evaluated at your current j

308
00:11:40,320 --> 00:11:43,440
invariant and then you divide by x minus

309
00:11:43,440 --> 00:11:45,680
your previous germ variant and this

310
00:11:45,680 --> 00:11:47,200
ensures that you don't go back to where

311
00:11:47,200 --> 00:11:48,800
you came from so you don't want to sort

312
00:11:48,800 --> 00:11:52,320
of backtrack in your graph

313
00:11:52,320 --> 00:11:55,920
and then you choose one of these n l

314
00:11:55,920 --> 00:11:57,920
minus one roots

315
00:11:57,920 --> 00:12:00,480
sort of at random and you step onto it

316
00:12:00,480 --> 00:12:03,360
and you continue the process

317
00:12:03,360 --> 00:12:04,720
okay

318
00:12:04,720 --> 00:12:05,600
so

319
00:12:05,600 --> 00:12:07,680
our optimized implementation of the dell

320
00:12:07,680 --> 00:12:11,839
scale breath algorithm um

321
00:12:12,160 --> 00:12:13,839
was used to determine the concrete

322
00:12:13,839 --> 00:12:16,000
complexity of the first bottleneck step

323
00:12:16,000 --> 00:12:18,720
so finding from an fp

324
00:12:18,720 --> 00:12:21,760
squared j invariant finding an fp

325
00:12:21,760 --> 00:12:23,279
subfield node

326
00:12:23,279 --> 00:12:27,200
and we found that

327
00:12:27,200 --> 00:12:30,560
experimentally this was the the concrete

328
00:12:30,560 --> 00:12:32,720
complexity of the algorithm

329
00:12:32,720 --> 00:12:34,720
and just on a high level some of the

330
00:12:34,720 --> 00:12:37,920
optimizations we did was choosing

331
00:12:37,920 --> 00:12:39,600
l to be 2

332
00:12:39,600 --> 00:12:42,240
and this ensured that this polynomial

333
00:12:42,240 --> 00:12:44,399
here was quadratic so it's sort of the

334
00:12:44,399 --> 00:12:46,639
easiest case and you can easily

335
00:12:46,639 --> 00:12:48,720
take square roots

336
00:12:48,720 --> 00:12:50,880
we also

337
00:12:50,880 --> 00:12:53,040
optimize the square root

338
00:12:53,040 --> 00:12:55,440
the procedure to take square roots

339
00:12:55,440 --> 00:12:57,120
and things like that but you can find

340
00:12:57,120 --> 00:12:59,920
more details of that in in our paper

341
00:12:59,920 --> 00:13:01,680
and yeah so we found that the concrete

342
00:13:01,680 --> 00:13:05,040
uh complexity was c times square root p

343
00:13:05,040 --> 00:13:07,360
times the log p factor where c is

344
00:13:07,360 --> 00:13:11,880
between 0.75 and 1.05

345
00:13:12,240 --> 00:13:13,360
okay

346
00:13:13,360 --> 00:13:17,600
so now to go on to the new attack um

347
00:13:17,600 --> 00:13:19,839
we change the first step the subfield

348
00:13:19,839 --> 00:13:21,279
search

349
00:13:21,279 --> 00:13:23,600
and the key observation that we made um

350
00:13:23,600 --> 00:13:26,800
was that each step um

351
00:13:26,800 --> 00:13:29,200
in the two isogeny graph

352
00:13:29,200 --> 00:13:32,320
um you don't you're not interested in

353
00:13:32,320 --> 00:13:34,800
the precise values of the

354
00:13:34,800 --> 00:13:37,360
neighbors and the lysogeny graph you're

355
00:13:37,360 --> 00:13:39,279
only really interested in whether or not

356
00:13:39,279 --> 00:13:41,040
it lies in fp

357
00:13:41,040 --> 00:13:42,240
and so

358
00:13:42,240 --> 00:13:43,839
um

359
00:13:43,839 --> 00:13:45,760
then once you've found a node that lies

360
00:13:45,760 --> 00:13:49,120
in fp you can sort of take the elf route

361
00:13:49,120 --> 00:13:50,000
and

362
00:13:50,000 --> 00:13:51,760
actually find its value

363
00:13:51,760 --> 00:13:53,199
but when you're taking steps in the

364
00:13:53,199 --> 00:13:55,519
graph all you are interested in is

365
00:13:55,519 --> 00:13:58,720
whether it lies in fp or not

366
00:13:58,720 --> 00:14:00,320
and because this is

367
00:14:00,320 --> 00:14:02,399
less information you could hope to do it

368
00:14:02,399 --> 00:14:04,480
more efficiently than computing roots of

369
00:14:04,480 --> 00:14:07,600
your modular polynomial

370
00:14:07,600 --> 00:14:11,440
so as an overview at each step um of the

371
00:14:11,440 --> 00:14:12,880
random walk

372
00:14:12,880 --> 00:14:15,680
super solver will inspect the l-isogeny

373
00:14:15,680 --> 00:14:16,480
graph

374
00:14:16,480 --> 00:14:19,199
using this fast subfield root detection

375
00:14:19,199 --> 00:14:21,199
and it will do this for l in some

376
00:14:21,199 --> 00:14:23,360
carefully chosen set

377
00:14:23,360 --> 00:14:25,680
um

378
00:14:27,839 --> 00:14:30,720
the animation isn't working but uh yeah

379
00:14:30,720 --> 00:14:32,240
you can do this for l in a carefully

380
00:14:32,240 --> 00:14:34,880
chosen set to efficiently detect

381
00:14:34,880 --> 00:14:36,079
um

382
00:14:36,079 --> 00:14:38,320
whether the current j invariant has an

383
00:14:38,320 --> 00:14:41,040
l-isogonist neighbor in fp

384
00:14:41,040 --> 00:14:43,199
and so what you want to do is sort of

385
00:14:43,199 --> 00:14:46,320
scan a larger proportion of the graph so

386
00:14:46,320 --> 00:14:48,160
if you were just looking at l equals 2

387
00:14:48,160 --> 00:14:50,320
and taking steps in the two-esogenic

388
00:14:50,320 --> 00:14:51,360
graph

389
00:14:51,360 --> 00:14:53,199
then this

390
00:14:53,199 --> 00:14:55,360
you would only sort of reveal two of the

391
00:14:55,360 --> 00:14:58,160
neighbors but if you could scan a larger

392
00:14:58,160 --> 00:15:00,800
proportion of the graph for more l in an

393
00:15:00,800 --> 00:15:03,040
efficient way then maybe you could cover

394
00:15:03,040 --> 00:15:04,160
a larger

395
00:15:04,160 --> 00:15:06,720
uh proportion of the graph at each step

396
00:15:06,720 --> 00:15:11,240
and find your fp node faster

397
00:15:12,320 --> 00:15:14,480
okay

398
00:15:14,480 --> 00:15:16,240
so um

399
00:15:16,240 --> 00:15:19,199
yeah our fast field uh sub fast subfield

400
00:15:19,199 --> 00:15:21,360
root detection gives a fast way of

401
00:15:21,360 --> 00:15:23,440
detecting whether

402
00:15:23,440 --> 00:15:25,519
uh you have a root in fp without

403
00:15:25,519 --> 00:15:28,000
actually computing the roots

404
00:15:28,000 --> 00:15:30,800
so this is sort of the key lemma

405
00:15:30,800 --> 00:15:32,720
if you take the

406
00:15:32,720 --> 00:15:35,440
p power for benious map

407
00:15:35,440 --> 00:15:38,240
and all this does is it acts on

408
00:15:38,240 --> 00:15:40,160
a polynomial f by raising the

409
00:15:40,160 --> 00:15:42,959
coefficients to a power of p

410
00:15:42,959 --> 00:15:44,079
um

411
00:15:44,079 --> 00:15:46,800
then if you take the gcd of f and this

412
00:15:46,800 --> 00:15:48,639
map applied to f

413
00:15:48,639 --> 00:15:50,959
it will have degree one if f has a root

414
00:15:50,959 --> 00:15:52,320
in fp

415
00:15:52,320 --> 00:15:55,199
and it will have degree zero uh if f

416
00:15:55,199 --> 00:15:57,839
does not have a root in fp

417
00:15:57,839 --> 00:15:59,920
and you might be wondering what if the

418
00:15:59,920 --> 00:16:02,000
degree is bigger than one

419
00:16:02,000 --> 00:16:04,560
and in our application of this that only

420
00:16:04,560 --> 00:16:06,959
happens sort of negligibly often and so

421
00:16:06,959 --> 00:16:09,279
we can sort of discard this case and not

422
00:16:09,279 --> 00:16:11,519
worry about it in fact we discuss in the

423
00:16:11,519 --> 00:16:13,440
paper that if that is the case it's

424
00:16:13,440 --> 00:16:15,759
actually sort of a win for the krypton

425
00:16:15,759 --> 00:16:17,920
uh analysis and so

426
00:16:17,920 --> 00:16:18,720
um

427
00:16:18,720 --> 00:16:21,360
yeah but we discard the case when the

428
00:16:21,360 --> 00:16:22,959
degree is bigger than one because it

429
00:16:22,959 --> 00:16:26,320
happens negligibly often

430
00:16:26,320 --> 00:16:28,800
um in the paper we also show how to

431
00:16:28,800 --> 00:16:30,800
transform f and

432
00:16:30,800 --> 00:16:32,000
pi of f

433
00:16:32,000 --> 00:16:33,920
which in general have coefficients lying

434
00:16:33,920 --> 00:16:35,759
in fp squared

435
00:16:35,759 --> 00:16:37,279
to give two polynomials with

436
00:16:37,279 --> 00:16:39,360
coefficients lying in fp

437
00:16:39,360 --> 00:16:42,639
that have the same gcd

438
00:16:42,639 --> 00:16:45,199
um and so you can still compute the gcd

439
00:16:45,199 --> 00:16:48,720
here but instead you have j1 and j2

440
00:16:48,720 --> 00:16:50,800
and this means that you can avoid all

441
00:16:50,800 --> 00:16:53,360
multiplications in fp squared

442
00:16:53,360 --> 00:16:55,199
um

443
00:16:55,199 --> 00:16:57,199
and so it makes our detection even more

444
00:16:57,199 --> 00:16:59,519
efficient

445
00:16:59,519 --> 00:17:01,600
so now to discuss

446
00:17:01,600 --> 00:17:04,959
how we choose the list of optimal l's

447
00:17:04,959 --> 00:17:06,640
so

448
00:17:06,640 --> 00:17:08,959
though inspecting the l sergeant graph

449
00:17:08,959 --> 00:17:11,039
using the subfield root detection does

450
00:17:11,039 --> 00:17:14,000
increase the number of multiplications

451
00:17:14,000 --> 00:17:16,079
that you do at each step you are

452
00:17:16,079 --> 00:17:17,599
checking a larger proportion of the

453
00:17:17,599 --> 00:17:18,799
graph

454
00:17:18,799 --> 00:17:20,799
uh i don't think the animation will work

455
00:17:20,799 --> 00:17:22,400
but if you want to see it you can go on

456
00:17:22,400 --> 00:17:24,319
the crypto website

457
00:17:24,319 --> 00:17:27,119
but you can compute a list of optimal

458
00:17:27,119 --> 00:17:29,840
l's which minimizes the ratio

459
00:17:29,840 --> 00:17:32,400
of fp multiplications per

460
00:17:32,400 --> 00:17:35,120
um node revealed

461
00:17:35,120 --> 00:17:36,559
um

462
00:17:36,559 --> 00:17:38,160
yeah

463
00:17:38,160 --> 00:17:41,760
so the key point of this computation is

464
00:17:41,760 --> 00:17:44,960
that it only depends on the prime um

465
00:17:44,960 --> 00:17:47,919
and so finding your list of optimal l's

466
00:17:47,919 --> 00:17:50,320
can all can be done in pre-computation

467
00:17:50,320 --> 00:17:51,440
and then

468
00:17:51,440 --> 00:17:54,880
you can reuse that for every instance um

469
00:17:54,880 --> 00:17:57,440
that you have

470
00:17:57,679 --> 00:17:58,640
okay

471
00:17:58,640 --> 00:18:02,480
so um finally our our results um we ran

472
00:18:02,480 --> 00:18:04,160
a few experiments to compare how

473
00:18:04,160 --> 00:18:07,280
supersolver performs um compared to

474
00:18:07,280 --> 00:18:08,320
silver

475
00:18:08,320 --> 00:18:10,080
and we ran some experiments on small

476
00:18:10,080 --> 00:18:13,200
primes and many j invariants

477
00:18:13,200 --> 00:18:16,160
so supersolver finds a subfield node

478
00:18:16,160 --> 00:18:18,080
with on average half of the fp

479
00:18:18,080 --> 00:18:20,720
multiplications and it visits a lot less

480
00:18:20,720 --> 00:18:21,679
nodes

481
00:18:21,679 --> 00:18:25,840
so taking uh example if we have a 24 bit

482
00:18:25,840 --> 00:18:26,960
prime

483
00:18:26,960 --> 00:18:31,360
we averaged over 5 000 instances um

484
00:18:31,360 --> 00:18:34,200
and we found that silver needs around

485
00:18:34,200 --> 00:18:38,160
113 000 fp multiplications right super

486
00:18:38,160 --> 00:18:41,200
silver only needs around 54 000

487
00:18:41,200 --> 00:18:43,760
and it walks on a lot less nodes and

488
00:18:43,760 --> 00:18:45,840
this is because at each step

489
00:18:45,840 --> 00:18:47,600
you're covering a larger proportion of

490
00:18:47,600 --> 00:18:48,799
the graph

491
00:18:48,799 --> 00:18:50,960
and so you don't need to step as much to

492
00:18:50,960 --> 00:18:52,799
cover um

493
00:18:52,799 --> 00:18:56,000
to cover more nodes

494
00:18:56,000 --> 00:18:58,559
and then we ran some experiments of on

495
00:18:58,559 --> 00:19:00,880
cryptographic size primes

496
00:19:00,880 --> 00:19:03,919
um we ran uh super silver and silver

497
00:19:03,919 --> 00:19:06,559
until the number of fp multiplications

498
00:19:06,559 --> 00:19:08,799
used exceeded 10 to the eight

499
00:19:08,799 --> 00:19:10,559
because you can't actually solve these

500
00:19:10,559 --> 00:19:12,400
instances otherwise it wouldn't be

501
00:19:12,400 --> 00:19:14,880
secure but we ran it until the

502
00:19:14,880 --> 00:19:17,600
multiplications got to 10 to the 8 and

503
00:19:17,600 --> 00:19:19,360
just recorded how many nodes in the

504
00:19:19,360 --> 00:19:21,360
graph are covered

505
00:19:21,360 --> 00:19:23,280
so this is both the nodes that you step

506
00:19:23,280 --> 00:19:25,760
on and the nodes that you scan using

507
00:19:25,760 --> 00:19:28,400
fast subfield root protection

508
00:19:28,400 --> 00:19:31,440
and we found that for 50 bit prime

509
00:19:31,440 --> 00:19:33,760
super solver covers around three to four

510
00:19:33,760 --> 00:19:35,760
times the number of nodes that solver

511
00:19:35,760 --> 00:19:36,640
does

512
00:19:36,640 --> 00:19:39,039
and this advantage grows as the your

513
00:19:39,039 --> 00:19:40,480
prime grows

514
00:19:40,480 --> 00:19:43,280
so for 800 bits super solver covers

515
00:19:43,280 --> 00:19:47,360
around 20 times the number of nodes

516
00:19:47,360 --> 00:19:49,679
and this is uh kind of an interesting

517
00:19:49,679 --> 00:19:52,320
trend that as the prime grows the

518
00:19:52,320 --> 00:19:54,880
advantage of supersolver also grows and

519
00:19:54,880 --> 00:19:56,320
this is because

520
00:19:56,320 --> 00:19:59,679
um taking a step in the graph so um

521
00:19:59,679 --> 00:20:01,760
computing a square root of your modular

522
00:20:01,760 --> 00:20:04,640
polynomial depends on your prime p but

523
00:20:04,640 --> 00:20:06,559
our fast subfield root detection only

524
00:20:06,559 --> 00:20:08,000
depends on l

525
00:20:08,000 --> 00:20:11,039
so as p grows you add more l into this

526
00:20:11,039 --> 00:20:13,360
optimal set of l's

527
00:20:13,360 --> 00:20:15,200
um so you can imagine as p goes to

528
00:20:15,200 --> 00:20:17,360
infinity what you would do is just stay

529
00:20:17,360 --> 00:20:19,440
on the node that you're on and scan the

530
00:20:19,440 --> 00:20:21,440
graph for all l

531
00:20:21,440 --> 00:20:23,280
um

532
00:20:23,280 --> 00:20:25,600
so yeah so finally some conclusions what

533
00:20:25,600 --> 00:20:28,960
does this mean for exogeny-based crypto

534
00:20:28,960 --> 00:20:30,480
we only improve on the concrete

535
00:20:30,480 --> 00:20:32,720
complexity and so the asymptotic

536
00:20:32,720 --> 00:20:35,760
complexity of the problem is unchanged

537
00:20:35,760 --> 00:20:38,640
but it does affect concrete parameters

538
00:20:38,640 --> 00:20:40,640
that will be used for b side and ski

539
00:20:40,640 --> 00:20:41,760
sine

540
00:20:41,760 --> 00:20:43,840
because these have del scale both as the

541
00:20:43,840 --> 00:20:45,120
best attack

542
00:20:45,120 --> 00:20:48,080
again caveat on b side but ski sign this

543
00:20:48,080 --> 00:20:50,559
is definitely the best um

544
00:20:50,559 --> 00:20:52,960
the best attack and so will affect the

545
00:20:52,960 --> 00:20:55,440
concrete parameters that are chosen for

546
00:20:55,440 --> 00:20:56,799
ski sign

547
00:20:56,799 --> 00:20:58,640
and for more details please see our full

548
00:20:58,640 --> 00:21:01,840
paper on eprint

549
00:21:01,840 --> 00:21:04,240
thank you

550
00:21:12,080 --> 00:21:14,640
for this very nice talk

551
00:21:14,640 --> 00:21:16,159
also thanks for staying within the

552
00:21:16,159 --> 00:21:17,919
allotted time so

553
00:21:17,919 --> 00:21:19,600
we're not delaying any further are there

554
00:21:19,600 --> 00:21:22,799
any questions in the audience

555
00:21:27,200 --> 00:21:29,280
um i see one question on zoom by

556
00:21:29,280 --> 00:21:31,679
jonathan levin he's asking could you

557
00:21:31,679 --> 00:21:33,440
elaborate more on the distribution of

558
00:21:33,440 --> 00:21:35,600
curves in the l isogeny graph with j

559
00:21:35,600 --> 00:21:37,840
invariance defined over fp versus fp

560
00:21:37,840 --> 00:21:40,000
squared

561
00:21:40,000 --> 00:21:41,840
so

562
00:21:41,840 --> 00:21:46,000
uh let me just go back to the

563
00:21:47,280 --> 00:21:48,240
sorry

564
00:21:48,240 --> 00:21:50,240
um

565
00:21:50,240 --> 00:21:52,240
yeah so i think this is the photo so

566
00:21:52,240 --> 00:21:54,640
they're around or order of p nodes in

567
00:21:54,640 --> 00:21:57,120
the super singular isogenic graph

568
00:21:57,120 --> 00:21:59,600
um and uh yeah so they're around order

569
00:21:59,600 --> 00:22:03,200
of p that have j invariant in fb squared

570
00:22:03,200 --> 00:22:05,760
and only around order of the square root

571
00:22:05,760 --> 00:22:08,640
of p nodes that have um j invariant and

572
00:22:08,640 --> 00:22:12,240
fp and there's actually sort of like a a

573
00:22:12,240 --> 00:22:14,960
clustering effect i think where the fp

574
00:22:14,960 --> 00:22:17,440
nodes cluster together in the graph

575
00:22:17,440 --> 00:22:18,720
um

576
00:22:18,720 --> 00:22:21,039
uh but yeah this is sort of the

577
00:22:21,039 --> 00:22:22,559
the proportion of

578
00:22:22,559 --> 00:22:24,640
the nodes in the graph and this is how

579
00:22:24,640 --> 00:22:27,360
you can come up with these um

580
00:22:27,360 --> 00:22:28,559
sort of

581
00:22:28,559 --> 00:22:30,960
uh running times of the first step in

582
00:22:30,960 --> 00:22:32,559
the second step

583
00:22:32,559 --> 00:22:34,400
um i don't know if that answers the

584
00:22:34,400 --> 00:22:36,080
question but hopefully it doesn't it

585
00:22:36,080 --> 00:22:38,720
sounds like it might

586
00:22:38,880 --> 00:22:41,120
he says thanks

587
00:22:41,120 --> 00:22:43,360
uh i also have one small question um so

588
00:22:43,360 --> 00:22:45,360
your implementation was done in sage

589
00:22:45,360 --> 00:22:46,880
which at your level of analysis doesn't

590
00:22:46,880 --> 00:22:48,880
matter because you count multiplications

591
00:22:48,880 --> 00:22:50,960
but uh are there any plans to make like

592
00:22:50,960 --> 00:22:53,200
a serious implementation of this in

593
00:22:53,200 --> 00:22:55,919
c or some low-level language

594
00:22:55,919 --> 00:22:58,480
yeah i think um

595
00:22:58,480 --> 00:23:00,960
yeah so our motivation towards the the

596
00:23:00,960 --> 00:23:02,640
sage was again because we only count

597
00:23:02,640 --> 00:23:04,400
multiplications and so you can sort of

598
00:23:04,400 --> 00:23:07,440
convert this into any metric you want um

599
00:23:07,440 --> 00:23:09,600
but i think maybe further down the line

600
00:23:09,600 --> 00:23:11,360
um

601
00:23:11,360 --> 00:23:13,520
there are plans to sort of make this

602
00:23:13,520 --> 00:23:15,520
sort of software that you can use to

603
00:23:15,520 --> 00:23:18,320
determine the security of

604
00:23:18,320 --> 00:23:19,840
schemes which have this is the best

605
00:23:19,840 --> 00:23:21,840
attack in particular i think there are

606
00:23:21,840 --> 00:23:23,679
still some optimizations that can be

607
00:23:23,679 --> 00:23:25,280
done but um

608
00:23:25,280 --> 00:23:27,120
but yeah maybe in the future but for now

609
00:23:27,120 --> 00:23:29,679
it's just just on stage

610
00:23:29,679 --> 00:23:34,760
okay uh thanks again to the speaker

611
00:23:47,279 --> 00:23:48,799
so i guess while they set up the

612
00:23:48,799 --> 00:23:50,880
technology i can start introducing the

613
00:23:50,880 --> 00:23:52,400
next talk

614
00:23:52,400 --> 00:23:54,880
uh this is kind of a change in topic

615
00:23:54,880 --> 00:23:56,320
because it's suddenly about symmetric

616
00:23:56,320 --> 00:23:57,919
cryptography and about side channel

617
00:23:57,919 --> 00:24:00,000
resistance

618
00:24:00,000 --> 00:24:01,360
but

619
00:24:01,360 --> 00:24:02,880
i guess it's still going to be very

620
00:24:02,880 --> 00:24:05,679
interesting um the title of the next

621
00:24:05,679 --> 00:24:07,919
talk is secret can be public

622
00:24:07,919 --> 00:24:10,080
low memory aad mode for high order

623
00:24:10,080 --> 00:24:11,200
masking

624
00:24:11,200 --> 00:24:14,400
authored by yusuke naito yusasaki and

625
00:24:14,400 --> 00:24:16,159
takashi sugawara

626
00:24:16,159 --> 00:24:18,240
and you will give the talk as soon as

627
00:24:18,240 --> 00:24:22,279
they finish setting up the tech

628
00:24:57,600 --> 00:24:59,360
so thank you for introduction so i'm

629
00:24:59,360 --> 00:25:01,919
used to sake from ndt and i'm going to

630
00:25:01,919 --> 00:25:04,960
present our paper

631
00:25:04,960 --> 00:25:07,200
so this slide shows the one page

632
00:25:07,200 --> 00:25:10,000
overview uh so first

633
00:25:10,000 --> 00:25:12,880
we present a new tweak over brock's

634
00:25:12,880 --> 00:25:14,480
cypher cipher-based authenticated

635
00:25:14,480 --> 00:25:17,360
encryption let's associate the data mode

636
00:25:17,360 --> 00:25:20,240
which we call homa

637
00:25:20,240 --> 00:25:23,600
and homer achieves small memory size for

638
00:25:23,600 --> 00:25:26,400
higher order masking hydrogen and

639
00:25:26,400 --> 00:25:28,559
countermeasures

640
00:25:28,559 --> 00:25:30,559
and the interesting feature is we

641
00:25:30,559 --> 00:25:32,640
protect only s over two bits of the

642
00:25:32,640 --> 00:25:36,320
state while we prove its security after

643
00:25:36,320 --> 00:25:38,720
estimates

644
00:25:38,720 --> 00:25:41,200
and this is a mohammed model so to use

645
00:25:41,200 --> 00:25:42,480
it we need

646
00:25:42,480 --> 00:25:44,799
a tweakable broke cipher

647
00:25:44,799 --> 00:25:47,600
and the requirement of the tweak block

648
00:25:47,600 --> 00:25:50,480
cipher is shown here but unfortunately

649
00:25:50,480 --> 00:25:53,440
there is no uh existing tweak of rubric

650
00:25:53,440 --> 00:25:55,440
cipher that supports

651
00:25:55,440 --> 00:25:58,080
uh that supports this configuration so

652
00:25:58,080 --> 00:25:59,840
we need to design

653
00:25:59,840 --> 00:26:04,000
a new skinny-based tvc instance

654
00:26:04,000 --> 00:26:06,400
and the last three we implement a homa

655
00:26:06,400 --> 00:26:10,320
with a skinny ee uh in hardware and the

656
00:26:10,320 --> 00:26:13,600
results show that uh umar

657
00:26:13,600 --> 00:26:16,559
has a slightly bigger memory than the

658
00:26:16,559 --> 00:26:19,200
state of the art if outside the channel

659
00:26:19,200 --> 00:26:21,440
countermeasures i mean maskings are not

660
00:26:21,440 --> 00:26:22,640
implemented

661
00:26:22,640 --> 00:26:26,159
but as long as masking is implemented

662
00:26:26,159 --> 00:26:27,600
and then the homer

663
00:26:27,600 --> 00:26:30,159
uh is smaller than the state of the art

664
00:26:30,159 --> 00:26:33,520
for any protection already

665
00:26:33,520 --> 00:26:35,440
okay so let's start

666
00:26:35,440 --> 00:26:36,840
the standard

667
00:26:36,840 --> 00:26:40,640
part so inside channel analysis uh

668
00:26:40,640 --> 00:26:43,200
besides the standard input output of the

669
00:26:43,200 --> 00:26:44,559
function

670
00:26:44,559 --> 00:26:46,559
the adversary

671
00:26:46,559 --> 00:26:48,559
can learn some information from

672
00:26:48,559 --> 00:26:51,520
implementation features

673
00:26:51,520 --> 00:26:53,919
and the resistance against side channel

674
00:26:53,919 --> 00:26:56,799
analysis is quite important for example

675
00:26:56,799 --> 00:26:59,360
it is considered in the selection of the

676
00:26:59,360 --> 00:27:03,600
future standards by nest

677
00:27:05,200 --> 00:27:07,520
and there were several uh previous

678
00:27:07,520 --> 00:27:09,520
research directions

679
00:27:09,520 --> 00:27:10,480
on

680
00:27:10,480 --> 00:27:15,840
aead with uh masking friendly aed

681
00:27:15,840 --> 00:27:19,360
the first direction is leakage

682
00:27:19,360 --> 00:27:21,840
legends cryptography

683
00:27:21,840 --> 00:27:24,960
those scheme use leak-free component in

684
00:27:24,960 --> 00:27:27,440
a part of computations

685
00:27:27,440 --> 00:27:28,320
and

686
00:27:28,320 --> 00:27:32,159
the usual uh goal is to minimize the use

687
00:27:32,159 --> 00:27:35,440
of such legibly components

688
00:27:35,440 --> 00:27:38,159
so they typically aim at optimizing the

689
00:27:38,159 --> 00:27:41,679
speed and not in the size so the goal is

690
00:27:41,679 --> 00:27:45,120
different from our research

691
00:27:45,120 --> 00:27:47,919
and another topic is like masking

692
00:27:47,919 --> 00:27:49,520
friendly primitive

693
00:27:49,520 --> 00:27:52,159
which is easier to mask

694
00:27:52,159 --> 00:27:54,799
but this is about primitive and uh

695
00:27:54,799 --> 00:27:57,120
nothing special for the mode and the

696
00:27:57,120 --> 00:27:58,799
mode level optimization is not

697
00:27:58,799 --> 00:28:01,520
considered in the primitive proposal so

698
00:28:01,520 --> 00:28:03,200
this direction is also different from

699
00:28:03,200 --> 00:28:04,480
ours

700
00:28:04,480 --> 00:28:07,039
and the last one is of approach which is

701
00:28:07,039 --> 00:28:09,919
low memory aead mode

702
00:28:09,919 --> 00:28:13,120
so in this direction uh we apply

703
00:28:13,120 --> 00:28:14,960
the masking counter measures to all

704
00:28:14,960 --> 00:28:16,960
computations

705
00:28:16,960 --> 00:28:19,919
and we want to minimize the memory size

706
00:28:19,919 --> 00:28:21,840
after the masking so i'm going to

707
00:28:21,840 --> 00:28:24,720
explain the masking

708
00:28:25,279 --> 00:28:27,760
so here uh the model

709
00:28:27,760 --> 00:28:30,480
advisory model in this talk in this

710
00:28:30,480 --> 00:28:34,000
research is a probing model

711
00:28:34,000 --> 00:28:38,320
the adversary probes a wire to get data

712
00:28:38,320 --> 00:28:41,360
moreover we assume that we assume the

713
00:28:41,360 --> 00:28:43,919
worst case scenario i mean the strongest

714
00:28:43,919 --> 00:28:45,600
adversary

715
00:28:45,600 --> 00:28:48,399
and the adversary can get

716
00:28:48,399 --> 00:28:50,480
the full data on the wire

717
00:28:50,480 --> 00:28:52,480
if it is probed

718
00:28:52,480 --> 00:28:55,600
and well our aim is to develop

719
00:28:55,600 --> 00:28:58,480
a construction that is strong even for

720
00:28:58,480 --> 00:29:00,159
this strong

721
00:29:00,159 --> 00:29:02,799
adversary

722
00:29:03,919 --> 00:29:06,720
so how to prevent

723
00:29:06,720 --> 00:29:08,480
this adversary

724
00:29:08,480 --> 00:29:10,320
the popular approach is masking

725
00:29:10,320 --> 00:29:12,320
countermeasures

726
00:29:12,320 --> 00:29:15,520
the input data is encoded to multiple

727
00:29:15,520 --> 00:29:17,760
shares so then

728
00:29:17,760 --> 00:29:20,480
the schema like secret sharing will land

729
00:29:20,480 --> 00:29:21,440
so

730
00:29:21,440 --> 00:29:23,679
the adversary can't get can't recover

731
00:29:23,679 --> 00:29:26,799
the original data even by probing a

732
00:29:26,799 --> 00:29:29,520
single state

733
00:29:32,080 --> 00:29:34,799
more powerful adversary may prove d

734
00:29:34,799 --> 00:29:37,440
wires in the d is greater than one

735
00:29:37,440 --> 00:29:40,240
but even such adversaries can be avoided

736
00:29:40,240 --> 00:29:42,559
and it can be prevented by making more

737
00:29:42,559 --> 00:29:43,760
shares

738
00:29:43,760 --> 00:29:48,240
and this is called high water masking

739
00:29:48,559 --> 00:29:51,279
and this is a research motivation

740
00:29:51,279 --> 00:29:52,080
well

741
00:29:52,080 --> 00:29:54,640
we can apply the uh high order masking

742
00:29:54,640 --> 00:29:57,679
but then the memory overhead is quite

743
00:29:57,679 --> 00:30:00,559
huge because the state is duplicated

744
00:30:00,559 --> 00:30:03,120
into multiple shears

745
00:30:03,120 --> 00:30:05,279
and the deliver masking scheme is called

746
00:30:05,279 --> 00:30:07,360
d personal masking

747
00:30:07,360 --> 00:30:10,559
and this dose encode the state in into d

748
00:30:10,559 --> 00:30:13,520
plus one shears so this means that

749
00:30:13,520 --> 00:30:16,240
after the masking the memory size

750
00:30:16,240 --> 00:30:17,600
increase

751
00:30:17,600 --> 00:30:21,679
uh d plus one times which is quite big

752
00:30:21,679 --> 00:30:23,600
and this is the motivation that we need

753
00:30:23,600 --> 00:30:26,720
a new design that is optimized for high

754
00:30:26,720 --> 00:30:30,159
high order masking

755
00:30:31,520 --> 00:30:35,600
and so first let's discuss the

756
00:30:35,600 --> 00:30:38,080
minimum state size i mean lower round of

757
00:30:38,080 --> 00:30:39,840
the state size

758
00:30:39,840 --> 00:30:42,640
so let s be the target security like is

759
00:30:42,640 --> 00:30:46,720
128 in a real use case

760
00:30:46,880 --> 00:30:49,200
but so we need at least

761
00:30:49,200 --> 00:30:50,799
as bits of the key

762
00:30:50,799 --> 00:30:52,799
and the estimates of the state

763
00:30:52,799 --> 00:30:54,320
well otherwise

764
00:30:54,320 --> 00:30:56,720
the advisory can directly guess the key

765
00:30:56,720 --> 00:30:58,880
or state with complexity less than due

766
00:30:58,880 --> 00:31:00,880
to this so svt security is not

767
00:31:00,880 --> 00:31:03,880
achievable

768
00:31:04,480 --> 00:31:07,039
then we applied the masking on this uh

769
00:31:07,039 --> 00:31:08,720
data flow

770
00:31:08,720 --> 00:31:11,440
so the key is expanded to d plus one

771
00:31:11,440 --> 00:31:14,159
shares and the state is exponents to

772
00:31:14,159 --> 00:31:15,679
depress one shears

773
00:31:15,679 --> 00:31:18,320
so there is a fault law on the memory

774
00:31:18,320 --> 00:31:20,559
side for masking

775
00:31:20,559 --> 00:31:23,519
the the total memory size is at risk the

776
00:31:23,519 --> 00:31:25,120
plus one two f

777
00:31:25,120 --> 00:31:26,880
this

778
00:31:26,880 --> 00:31:28,960
and this is kind of a barrier and in

779
00:31:28,960 --> 00:31:31,519
this research we want uh we break this

780
00:31:31,519 --> 00:31:32,880
value here

781
00:31:32,880 --> 00:31:36,799
the overall ideas here

782
00:31:37,120 --> 00:31:37,919
well

783
00:31:37,919 --> 00:31:40,799
uh we don't do anything on the key

784
00:31:40,799 --> 00:31:43,919
but the state for the state we divide

785
00:31:43,919 --> 00:31:46,399
this exhibit state into

786
00:31:46,399 --> 00:31:49,840
0.5 s of the protected state and the

787
00:31:49,840 --> 00:31:53,200
other half for unprotected state

788
00:31:53,200 --> 00:31:55,919
the unprotected state is well

789
00:31:55,919 --> 00:31:59,039
unprotected so we don't expand the state

790
00:31:59,039 --> 00:32:02,320
size into multiple shares

791
00:32:02,320 --> 00:32:04,480
so by this approach

792
00:32:04,480 --> 00:32:07,679
a sympathetically we achieve d plus 1

793
00:32:07,679 --> 00:32:09,679
times 1.5 s

794
00:32:09,679 --> 00:32:11,360
bit memory

795
00:32:11,360 --> 00:32:13,200
but of course i'm cheating in this

796
00:32:13,200 --> 00:32:14,559
figure because

797
00:32:14,559 --> 00:32:15,360
uh

798
00:32:15,360 --> 00:32:18,080
for this video i'm protected state is

799
00:32:18,080 --> 00:32:20,399
obviously

800
00:32:20,399 --> 00:32:23,439
obviously weak

801
00:32:23,840 --> 00:32:26,799
so to make this bit state we needed to

802
00:32:26,799 --> 00:32:29,279
mix the value from the protected state

803
00:32:29,279 --> 00:32:32,799
and the values from unprotected state

804
00:32:32,799 --> 00:32:34,880
but then we tried then it turned out

805
00:32:34,880 --> 00:32:37,760
that uh this mixture is not like a

806
00:32:37,760 --> 00:32:39,279
simple we

807
00:32:39,279 --> 00:32:41,679
have to carefully devise new operations

808
00:32:41,679 --> 00:32:43,600
to securely mix protected and

809
00:32:43,600 --> 00:32:45,919
unprotected bodies

810
00:32:45,919 --> 00:32:49,440
okay so then i gonna explain how to uh

811
00:32:49,440 --> 00:32:54,159
construct uh this data processing part

812
00:32:54,640 --> 00:32:57,039
so i first uh give you general

813
00:32:57,039 --> 00:32:59,840
description of the uh computation with

814
00:32:59,840 --> 00:33:03,039
protected and unprotected states

815
00:33:03,039 --> 00:33:04,880
so now the start of the protected state

816
00:33:04,880 --> 00:33:07,919
is 0.5 assets and the unprotected states

817
00:33:07,919 --> 00:33:10,799
is 4.5 assets and that those are

818
00:33:10,799 --> 00:33:12,799
processed by some function which we call

819
00:33:12,799 --> 00:33:14,960
data processing function

820
00:33:14,960 --> 00:33:15,840
and

821
00:33:15,840 --> 00:33:18,960
this function also takes associated data

822
00:33:18,960 --> 00:33:22,640
block or message block as input

823
00:33:23,039 --> 00:33:25,600
and first i'd like to show that with the

824
00:33:25,600 --> 00:33:28,000
standard nonce based ae the construction

825
00:33:28,000 --> 00:33:32,559
is generally broken with to the 0.5s

826
00:33:32,559 --> 00:33:35,200
complexity

827
00:33:36,399 --> 00:33:37,760
so uh

828
00:33:37,760 --> 00:33:40,080
the idea is praying with decryption

829
00:33:40,080 --> 00:33:41,440
local

830
00:33:41,440 --> 00:33:43,600
this slide shows the decryption local

831
00:33:43,600 --> 00:33:47,120
data flow for the decryption local

832
00:33:47,360 --> 00:33:50,880
and for any decryption query

833
00:33:50,880 --> 00:33:53,600
unprotected values are linked to the

834
00:33:53,600 --> 00:33:55,919
starter channel advisories even with an

835
00:33:55,919 --> 00:33:57,200
invert dot

836
00:33:57,200 --> 00:34:00,799
so usually if the tag uh the

837
00:34:00,799 --> 00:34:03,279
verification fails then

838
00:34:03,279 --> 00:34:06,880
the scheme doesn't leak any information

839
00:34:06,880 --> 00:34:08,960
but if

840
00:34:08,960 --> 00:34:11,440
the state is unprotected and if you can

841
00:34:11,440 --> 00:34:12,960
probe the buyer

842
00:34:12,960 --> 00:34:16,079
then the side channel adversary can know

843
00:34:16,079 --> 00:34:19,520
the value of the state

844
00:34:19,679 --> 00:34:21,599
so more intuitively

845
00:34:21,599 --> 00:34:24,960
uh the verify then sorry that this it's

846
00:34:24,960 --> 00:34:26,800
it should be very far but verified and

847
00:34:26,800 --> 00:34:28,879
the correct approach

848
00:34:28,879 --> 00:34:32,000
uh can't apply to the solid channel

849
00:34:32,000 --> 00:34:34,800
adversary with unpredicted state so

850
00:34:34,800 --> 00:34:37,679
there uh this is the reason destruction

851
00:34:37,679 --> 00:34:39,440
is very different from the standard

852
00:34:39,440 --> 00:34:42,399
non-space aed

853
00:34:44,159 --> 00:34:46,719
so uh so actually we can write down some

854
00:34:46,719 --> 00:34:48,960
attack procedure uh that breaks secret

855
00:34:48,960 --> 00:34:52,320
innocence whether the 0.5 s bit security

856
00:34:52,320 --> 00:34:53,918
so i don't i don't explain the attack

857
00:34:53,918 --> 00:34:56,560
procedure here but the idea is to

858
00:34:56,560 --> 00:34:59,520
generate a state collision by changing

859
00:34:59,520 --> 00:35:01,359
associated data

860
00:35:01,359 --> 00:35:03,040
and we keep the

861
00:35:03,040 --> 00:35:06,880
message same for all queries

862
00:35:06,880 --> 00:35:07,680
and

863
00:35:07,680 --> 00:35:08,480
well

864
00:35:08,480 --> 00:35:11,200
in the standard scenario i mean the

865
00:35:11,200 --> 00:35:14,000
standard adversary can't detect

866
00:35:14,000 --> 00:35:17,280
occurrence of the collision usually but

867
00:35:17,280 --> 00:35:19,599
for the starter channel adversaries and

868
00:35:19,599 --> 00:35:23,200
if some uh state is unprotected uh they

869
00:35:23,200 --> 00:35:25,520
can protect or they can detect the

870
00:35:25,520 --> 00:35:28,800
collision of the associated data

871
00:35:28,800 --> 00:35:30,560
and so later they can previous

872
00:35:30,560 --> 00:35:32,800
encryption query to generate some

873
00:35:32,800 --> 00:35:35,040
invalid to some uh

874
00:35:35,040 --> 00:35:37,200
attack data

875
00:35:37,200 --> 00:35:39,440
so this is a generic attack so as long

876
00:35:39,440 --> 00:35:40,240
as

877
00:35:40,240 --> 00:35:42,880
uh unprotected state is used uh this

878
00:35:42,880 --> 00:35:46,000
attack works so we need additional

879
00:35:46,000 --> 00:35:49,440
features to prevent this attack

880
00:35:49,440 --> 00:35:52,480
so the idea here is to use

881
00:35:52,480 --> 00:35:55,520
to randomize iv

882
00:35:55,520 --> 00:35:58,720
we force initial value iv to be randomly

883
00:35:58,720 --> 00:36:02,079
determined for each encryption current

884
00:36:02,079 --> 00:36:04,000
then the adversaries can no longer prive

885
00:36:04,000 --> 00:36:05,839
its decryption local before ibiz is

886
00:36:05,839 --> 00:36:07,839
determined so the

887
00:36:07,839 --> 00:36:08,960
attack i

888
00:36:08,960 --> 00:36:10,960
described in the previous page wouldn't

889
00:36:10,960 --> 00:36:13,839
work

890
00:36:13,920 --> 00:36:16,800
so i think this gives you the idea that

891
00:36:16,800 --> 00:36:18,720
the situation for

892
00:36:18,720 --> 00:36:20,400
unprotected state is quite different

893
00:36:20,400 --> 00:36:24,400
from the standard aed schemes

894
00:36:24,880 --> 00:36:28,640
then i step into the construction of the

895
00:36:28,640 --> 00:36:31,520
data processing part

896
00:36:31,520 --> 00:36:33,440
so the scheme is based on tweakable

897
00:36:33,440 --> 00:36:34,800
block cipher

898
00:36:34,800 --> 00:36:38,079
which takes tweak as input and converts

899
00:36:38,079 --> 00:36:41,520
plain text to the cipher text

900
00:36:41,520 --> 00:36:43,280
and this print text cycle text

901
00:36:43,280 --> 00:36:45,920
conversion is directly

902
00:36:45,920 --> 00:36:49,119
updated by using a key so we need

903
00:36:49,119 --> 00:36:51,920
protect it otherwise the key is directly

904
00:36:51,920 --> 00:36:53,359
linked

905
00:36:53,359 --> 00:36:54,560
and this is

906
00:36:54,560 --> 00:36:57,040
quite like suitable for uh

907
00:36:57,040 --> 00:37:00,079
processing protected state of the

908
00:37:00,079 --> 00:37:01,920
of the homer mode

909
00:37:01,920 --> 00:37:04,160
because protected state anyway declines

910
00:37:04,160 --> 00:37:06,320
protection

911
00:37:06,320 --> 00:37:09,200
and the tweak of the ticketbook cipher

912
00:37:09,200 --> 00:37:11,599
is the public value so we don't need

913
00:37:11,599 --> 00:37:15,359
protection because it's public anyway

914
00:37:15,359 --> 00:37:18,640
and uh the unprotected state of homer

915
00:37:18,640 --> 00:37:21,839
can be processed by the

916
00:37:21,839 --> 00:37:23,680
and also other public data such as

917
00:37:23,680 --> 00:37:26,079
non-scanner and the data input can be

918
00:37:26,079 --> 00:37:29,280
processed by the tweak

919
00:37:33,040 --> 00:37:34,000
and

920
00:37:34,000 --> 00:37:36,960
homa applies the protection only for the

921
00:37:36,960 --> 00:37:39,760
plaintext ciphertext conversion

922
00:37:39,760 --> 00:37:43,119
of two equivalent cipher with 0.5 s bit

923
00:37:43,119 --> 00:37:44,800
block

924
00:37:44,800 --> 00:37:47,359
but we want to ensure a smith security

925
00:37:47,359 --> 00:37:48,720
so that means

926
00:37:48,720 --> 00:37:50,480
the construction

927
00:37:50,480 --> 00:37:52,560
requires kind of like a bb but the end

928
00:37:52,560 --> 00:37:56,720
is possibly bound security bbb security

929
00:37:56,720 --> 00:37:58,880
and there's one previous work which

930
00:37:58,880 --> 00:38:01,040
achieves the singular uh

931
00:38:01,040 --> 00:38:03,520
security level which is called the php

932
00:38:03,520 --> 00:38:04,880
plus

933
00:38:04,880 --> 00:38:07,680
and the idea of the pvp press uh may

934
00:38:07,680 --> 00:38:09,920
help us to ensure speed security by

935
00:38:09,920 --> 00:38:12,480
using uh the small

936
00:38:12,480 --> 00:38:14,480
block size dvc

937
00:38:14,480 --> 00:38:17,440
and the diagram the diagram of the pfp

938
00:38:17,440 --> 00:38:20,160
process here

939
00:38:25,599 --> 00:38:29,359
so we have upward 0.5 aspect

940
00:38:29,359 --> 00:38:32,880
state and the bottom 0.5 as with state

941
00:38:32,880 --> 00:38:35,440
the upper state is like sort with data

942
00:38:35,440 --> 00:38:38,800
input and processed by the tvc

943
00:38:38,800 --> 00:38:41,280
the bottom half is never processed by

944
00:38:41,280 --> 00:38:44,640
update by dvc but this will impact to

945
00:38:44,640 --> 00:38:47,280
the uh take a proprietary

946
00:38:47,280 --> 00:38:48,720
via the trick

947
00:38:48,720 --> 00:38:51,680
so this is quite simple

948
00:38:51,680 --> 00:38:54,160
but then

949
00:38:54,640 --> 00:38:57,520
one may think about like leaving this

950
00:38:57,520 --> 00:38:59,200
part unprotected

951
00:38:59,200 --> 00:39:00,400
i mean leaving

952
00:39:00,400 --> 00:39:02,480
uh the bottom half of the pvp press

953
00:39:02,480 --> 00:39:03,839
unprotected

954
00:39:03,839 --> 00:39:06,800
but unfortunately

955
00:39:06,800 --> 00:39:09,280
pvp press is broken if the rower half is

956
00:39:09,280 --> 00:39:10,720
unprotected so

957
00:39:10,720 --> 00:39:13,040
suppose that the rover half is unprofit

958
00:39:13,040 --> 00:39:14,320
that means like a side channel

959
00:39:14,320 --> 00:39:16,720
adversaries can know the value of this

960
00:39:16,720 --> 00:39:18,560
part

961
00:39:18,560 --> 00:39:21,359
so then uh the adversary can learn the

962
00:39:21,359 --> 00:39:24,320
value of a v1 and v2

963
00:39:24,320 --> 00:39:27,440
and because of this computation

964
00:39:27,440 --> 00:39:28,640
uh the

965
00:39:28,640 --> 00:39:31,440
value of v3 is easily computed

966
00:39:31,440 --> 00:39:33,839
but the the value of the v3 is supposed

967
00:39:33,839 --> 00:39:34,800
to be

968
00:39:34,800 --> 00:39:37,200
protected so the construction already

969
00:39:37,200 --> 00:39:39,119
occurs

970
00:39:39,119 --> 00:39:42,160
so we need uh some new constructions

971
00:39:42,160 --> 00:39:45,599
uh to keep protected protected value uh

972
00:39:45,599 --> 00:39:48,160
protected

973
00:39:48,560 --> 00:39:50,400
and so this is the overview of our

974
00:39:50,400 --> 00:39:51,599
construction

975
00:39:51,599 --> 00:39:54,800
so the major difference is we call tvc

976
00:39:54,800 --> 00:39:57,520
twice to process each associated data

977
00:39:57,520 --> 00:39:59,759
block

978
00:40:00,240 --> 00:40:03,680
and a single tvc call generates 0.5 as

979
00:40:03,680 --> 00:40:05,359
with unprotected value

980
00:40:05,359 --> 00:40:07,520
unpredictable value

981
00:40:07,520 --> 00:40:09,760
and the two mix and the whole estimated

982
00:40:09,760 --> 00:40:10,640
state

983
00:40:10,640 --> 00:40:14,078
we need two pvc calls

984
00:40:14,240 --> 00:40:15,359
and

985
00:40:15,359 --> 00:40:17,119
in this construction

986
00:40:17,119 --> 00:40:18,800
we

987
00:40:18,800 --> 00:40:19,920
input

988
00:40:19,920 --> 00:40:21,760
data input

989
00:40:21,760 --> 00:40:24,319
via the tweak

990
00:40:24,319 --> 00:40:27,359
so compared to pvp plus the tweak size

991
00:40:27,359 --> 00:40:28,880
is bigger

992
00:40:28,880 --> 00:40:29,920
that means

993
00:40:29,920 --> 00:40:33,040
uh without any counter measures uh

994
00:40:33,040 --> 00:40:35,920
omar is uh bigger than the state of

995
00:40:35,920 --> 00:40:38,640
zlatan i mean pp plus

996
00:40:38,640 --> 00:40:40,000
but the

997
00:40:40,000 --> 00:40:42,319
size of the protected state is only here

998
00:40:42,319 --> 00:40:44,960
so which is smaller than the vp press

999
00:40:44,960 --> 00:40:48,480
so if you apply the uh masking masking

1000
00:40:48,480 --> 00:40:51,280
implementations then memory size becomes

1001
00:40:51,280 --> 00:40:53,839
smaller

1002
00:40:54,640 --> 00:40:56,400
and this is the construction for the

1003
00:40:56,400 --> 00:40:58,960
encryption part

1004
00:40:58,960 --> 00:41:02,000
we need to call a tvc three times

1005
00:41:02,000 --> 00:41:02,720
to

1006
00:41:02,720 --> 00:41:05,119
process each message block

1007
00:41:05,119 --> 00:41:07,839
and the first ticket for the cipher

1008
00:41:07,839 --> 00:41:11,119
generates a key stream and the other two

1009
00:41:11,119 --> 00:41:13,440
calls makes the state as in the

1010
00:41:13,440 --> 00:41:16,160
associated data

1011
00:41:18,079 --> 00:41:21,119
and the security proof uh was done by

1012
00:41:21,119 --> 00:41:24,160
michael thor yusuke naito

1013
00:41:24,160 --> 00:41:27,200
and this uh summarized some intuition of

1014
00:41:27,200 --> 00:41:28,240
the proof

1015
00:41:28,240 --> 00:41:30,800
uh the assumption is strong tweakable

1016
00:41:30,800 --> 00:41:32,000
plp

1017
00:41:32,000 --> 00:41:33,599
for the underlying thicker products

1018
00:41:33,599 --> 00:41:34,880
cipher

1019
00:41:34,880 --> 00:41:35,760
and

1020
00:41:35,760 --> 00:41:39,760
the result is sbit security

1021
00:41:39,760 --> 00:41:42,640
is with proof of security

1022
00:41:42,640 --> 00:41:44,480
and here is the intuition of

1023
00:41:44,480 --> 00:41:46,240
authenticity

1024
00:41:46,240 --> 00:41:50,319
so for each d5 we ensure that s bit

1025
00:41:50,319 --> 00:41:52,720
unpredictable value is produced by

1026
00:41:52,720 --> 00:41:56,160
iterating the tv sequels

1027
00:41:56,160 --> 00:41:58,240
and the regarding privacy

1028
00:41:58,240 --> 00:42:01,760
uh we ensure independence of each dbc by

1029
00:42:01,760 --> 00:42:04,000
properly assigning the nodes and the

1030
00:42:04,000 --> 00:42:06,400
counter

1031
00:42:07,359 --> 00:42:08,319
okay

1032
00:42:08,319 --> 00:42:12,000
so that's about the mode and we need a

1033
00:42:12,000 --> 00:42:14,319
trick of the box cipher

1034
00:42:14,319 --> 00:42:17,359
and the two achieve 128-bit security

1035
00:42:17,359 --> 00:42:19,520
so homer needs a three-couple box cipher

1036
00:42:19,520 --> 00:42:23,319
with 64-bit rock and 128-bit key and the

1037
00:42:23,319 --> 00:42:26,319
256.9 bits big

1038
00:42:26,319 --> 00:42:28,000
a brook size on the key sides would be

1039
00:42:28,000 --> 00:42:30,400
okay but uh

1040
00:42:30,400 --> 00:42:32,480
the tweak size is a bit

1041
00:42:32,480 --> 00:42:34,640
a bit too large

1042
00:42:34,640 --> 00:42:37,280
and no existing tbc supports those

1043
00:42:37,280 --> 00:42:39,440
parameters

1044
00:42:39,440 --> 00:42:41,599
and moreover for the

1045
00:42:41,599 --> 00:42:44,079
mode i explained that unprotected

1046
00:42:44,079 --> 00:42:46,240
unprotected values and protected

1047
00:42:46,240 --> 00:42:48,160
protected values

1048
00:42:48,160 --> 00:42:52,160
must be mixed must not be mixed in

1049
00:42:52,160 --> 00:42:55,040
and this also applies for the

1050
00:42:55,040 --> 00:42:56,839
inside

1051
00:42:56,839 --> 00:42:58,800
primitive

1052
00:42:58,800 --> 00:43:01,599
and we found that the 3g framework is

1053
00:43:01,599 --> 00:43:04,560
quite useful but the question is can we

1054
00:43:04,560 --> 00:43:06,880
just like extend the previous skinny to

1055
00:43:06,880 --> 00:43:10,079
support more tweaking key but unfrench

1056
00:43:10,079 --> 00:43:12,640
unfortunately

1057
00:43:12,640 --> 00:43:15,040
there is no efficient way to support

1058
00:43:15,040 --> 00:43:18,400
such big tweak

1059
00:43:19,119 --> 00:43:22,480
so we need to make some change

1060
00:43:22,480 --> 00:43:25,040
but the original tweaky framework is

1061
00:43:25,040 --> 00:43:28,079
aimed to support valuable click and key

1062
00:43:28,079 --> 00:43:29,680
sizes

1063
00:43:29,680 --> 00:43:32,560
that this is not important for other

1064
00:43:32,560 --> 00:43:35,520
gold because the key size and two sides

1065
00:43:35,520 --> 00:43:37,040
are fixed

1066
00:43:37,040 --> 00:43:40,079
so we drop this feature

1067
00:43:40,079 --> 00:43:42,720
and we treat uh twig and key as

1068
00:43:42,720 --> 00:43:45,680
independent object

1069
00:43:45,680 --> 00:43:49,119
and then the security is insured by uh

1070
00:43:49,119 --> 00:43:51,920
milt so some automatic tube

1071
00:43:51,920 --> 00:43:54,160
and we also have some uh minor

1072
00:43:54,160 --> 00:43:57,599
improvement about the elastic tweak to

1073
00:43:57,599 --> 00:43:59,760
process three bit tweak for the domain

1074
00:43:59,760 --> 00:44:01,599
separation

1075
00:44:01,599 --> 00:44:03,920
and so this is like a one page overview

1076
00:44:03,920 --> 00:44:06,079
of the run function well i don't explain

1077
00:44:06,079 --> 00:44:08,319
details here but i think this slide

1078
00:44:08,319 --> 00:44:10,800
would be useful if you check the video

1079
00:44:10,800 --> 00:44:14,079
later on the youtube

1080
00:44:14,800 --> 00:44:19,119
then finally we implement uh our designs

1081
00:44:19,119 --> 00:44:20,800
so we evaluate

1082
00:44:20,800 --> 00:44:22,800
asic hardware performance

1083
00:44:22,800 --> 00:44:24,960
with hpc two-star

1084
00:44:24,960 --> 00:44:26,560
masking schemes

1085
00:44:26,560 --> 00:44:30,960
for protection order from zero to five

1086
00:44:30,960 --> 00:44:34,640
and we compare the results with pfv plus

1087
00:44:34,640 --> 00:44:36,560
which is implemented under the same

1088
00:44:36,560 --> 00:44:39,040
implementation policy

1089
00:44:39,040 --> 00:44:43,200
and the implementation results are here

1090
00:44:43,200 --> 00:44:46,720
uh so the numbers in red in the

1091
00:44:46,720 --> 00:44:49,520
in the red square it shows the gate

1092
00:44:49,520 --> 00:44:50,880
equivalence

1093
00:44:50,880 --> 00:44:53,440
of the homer and the php plus

1094
00:44:53,440 --> 00:44:56,160
for each protection order

1095
00:44:56,160 --> 00:44:58,079
the incinerary

1096
00:44:58,079 --> 00:45:00,480
homa's memory size is bigger than pv

1097
00:45:00,480 --> 00:45:03,040
press for implementations without side

1098
00:45:03,040 --> 00:45:04,560
channel protection i mean with that

1099
00:45:04,560 --> 00:45:06,480
masking

1100
00:45:06,480 --> 00:45:07,440
but

1101
00:45:07,440 --> 00:45:10,160
homa is advantageous for any protection

1102
00:45:10,160 --> 00:45:14,480
order d which is bigger than zero

1103
00:45:14,560 --> 00:45:17,280
and this also shows one

1104
00:45:17,280 --> 00:45:19,119
interesting properties one may think

1105
00:45:19,119 --> 00:45:20,400
that

1106
00:45:20,400 --> 00:45:21,520
more

1107
00:45:21,520 --> 00:45:25,200
only was primitive improvement uh

1108
00:45:25,200 --> 00:45:28,720
the memory size can be smaller i mean

1109
00:45:28,720 --> 00:45:29,599
uh

1110
00:45:29,599 --> 00:45:31,920
the mode level optimization may not be

1111
00:45:31,920 --> 00:45:33,440
so useful

1112
00:45:33,440 --> 00:45:35,680
but the answer is no i mean modern level

1113
00:45:35,680 --> 00:45:38,480
uh optimization is quite useful

1114
00:45:38,480 --> 00:45:41,680
and because the improved factor

1115
00:45:41,680 --> 00:45:44,880
for example like a 6884

1116
00:45:44,880 --> 00:45:47,040
versus six two eight three

1117
00:45:47,040 --> 00:45:49,520
is bigger than the xbox size like the

1118
00:45:49,520 --> 00:45:52,800
five or one so that means our results

1119
00:45:52,800 --> 00:45:55,520
can't be reached by improving s-vocs of

1120
00:45:55,520 --> 00:45:58,240
the printer so the mod uh this is a

1121
00:45:58,240 --> 00:46:00,240
quite good evidence that modern level

1122
00:46:00,240 --> 00:46:03,280
optimization is useful

1123
00:46:03,280 --> 00:46:07,200
okay so i'd like to conclude uh my talk

1124
00:46:07,200 --> 00:46:10,240
so we proposed a new tvc based aead mode

1125
00:46:10,240 --> 00:46:13,200
omar which achieves small memory for

1126
00:46:13,200 --> 00:46:15,280
high order masking

1127
00:46:15,280 --> 00:46:17,119
and we implemented

1128
00:46:17,119 --> 00:46:19,280
homer with our new

1129
00:46:19,280 --> 00:46:22,480
tvc instantiation and showed that

1130
00:46:22,480 --> 00:46:25,760
the results performed quite well

1131
00:46:25,760 --> 00:46:26,720
and

1132
00:46:26,720 --> 00:46:28,880
well one possible future work is to

1133
00:46:28,880 --> 00:46:29,839
design

1134
00:46:29,839 --> 00:46:32,720
uh yet another new new modes to ensure

1135
00:46:32,720 --> 00:46:36,400
svt security based on tbc with a smaller

1136
00:46:36,400 --> 00:46:39,280
block size than 0.5 estimates

1137
00:46:39,280 --> 00:46:41,920
but this is not easy because you also

1138
00:46:41,920 --> 00:46:42,960
need to

1139
00:46:42,960 --> 00:46:46,720
develop a specific pvc

1140
00:46:46,720 --> 00:46:47,760
so

1141
00:46:47,760 --> 00:46:48,880
this

1142
00:46:48,880 --> 00:46:51,599
is not an easy task but maybe

1143
00:46:51,599 --> 00:46:54,319
interesting uh interesting challenge

1144
00:46:54,319 --> 00:46:56,640
challenge for the future

1145
00:46:56,640 --> 00:46:58,640
yeah that's about my talk thank you for

1146
00:46:58,640 --> 00:47:01,200
your attention

1147
00:47:06,160 --> 00:47:08,240
thank you for this very interesting and

1148
00:47:08,240 --> 00:47:10,640
clear talk um are there any questions in

1149
00:47:10,640 --> 00:47:13,118
the audience

1150
00:47:13,200 --> 00:47:15,440
we have one minute or something oh yeah

1151
00:47:15,440 --> 00:47:18,400
please use the microphone

1152
00:47:21,280 --> 00:47:24,400
thank you for your presentation

1153
00:47:24,400 --> 00:47:25,920
achieved as this

1154
00:47:25,920 --> 00:47:29,200
security by using two states building

1155
00:47:29,200 --> 00:47:30,160
the

1156
00:47:30,160 --> 00:47:31,920
securities improved when we use the

1157
00:47:31,920 --> 00:47:34,160
border state

1158
00:47:34,160 --> 00:47:36,000
that's alright uh how much is this

1159
00:47:36,000 --> 00:47:38,960
disagreed by did you say two steps

1160
00:47:38,960 --> 00:47:42,079
split security we are using two

1161
00:47:42,079 --> 00:47:43,839
states

1162
00:47:43,839 --> 00:47:47,359
two sorry two bottle states two steps

1163
00:47:47,359 --> 00:47:48,559
tapes

1164
00:47:48,559 --> 00:47:50,240
on two

1165
00:47:50,240 --> 00:47:51,839
0.5

1166
00:47:51,839 --> 00:47:54,960
oh yeah yeah two states yes

1167
00:47:54,960 --> 00:47:57,280
so securities improved when

1168
00:47:57,280 --> 00:48:01,640
you use more taxes

1169
00:48:07,359 --> 00:48:09,760
do you consider changing the entire

1170
00:48:09,760 --> 00:48:11,280
state size i mean

1171
00:48:11,280 --> 00:48:13,040
right or care to build

1172
00:48:13,040 --> 00:48:15,599
security is

1173
00:48:15,599 --> 00:48:17,200
security is

1174
00:48:17,200 --> 00:48:18,720
increased

1175
00:48:18,720 --> 00:48:21,280
i mean by splitting this part into like

1176
00:48:21,280 --> 00:48:23,520
three parts or four parts that you're

1177
00:48:23,520 --> 00:48:25,680
you're asking right

1178
00:48:25,680 --> 00:48:27,919
and

1179
00:48:29,440 --> 00:48:33,200
well as long as the entire state size is

1180
00:48:33,200 --> 00:48:35,440
the

1181
00:48:35,440 --> 00:48:40,480
maximum security you can get is s-pips

1182
00:48:40,480 --> 00:48:42,480
user or

1183
00:48:42,480 --> 00:48:45,040
writer two-speed sign

1184
00:48:45,040 --> 00:48:47,680
people use two speed

1185
00:48:47,680 --> 00:48:49,040
s bit buys

1186
00:48:49,040 --> 00:48:52,079
oh yeah so then so s is like a parameter

1187
00:48:52,079 --> 00:48:54,559
security parameter so if you substitute

1188
00:48:54,559 --> 00:48:56,559
two s into s then

1189
00:48:56,559 --> 00:48:59,440
your security simply becomes assets uh

1190
00:48:59,440 --> 00:49:01,200
two aspects

1191
00:49:01,200 --> 00:49:04,000
thank you okay thank you

1192
00:49:04,000 --> 00:49:05,920
okay so we're out of time for this talk

1193
00:49:05,920 --> 00:49:07,839
i'm afraid so let's thank the speaker

1194
00:49:07,839 --> 00:49:11,160
again and then

1195
00:49:22,880 --> 00:49:25,040
okay while they set up i will introduce

1196
00:49:25,040 --> 00:49:26,800
the next stop this is again on the topic

1197
00:49:26,800 --> 00:49:29,839
of post quantum primitives

1198
00:49:29,839 --> 00:49:31,920
the title is partial key exposure

1199
00:49:31,920 --> 00:49:34,319
attacks on bike rainbow and and true all

1200
00:49:34,319 --> 00:49:36,480
of which are post quantum schemes

1201
00:49:36,480 --> 00:49:38,079
and the speaker who's right here on

1202
00:49:38,079 --> 00:49:39,839
stage is andre essa

1203
00:49:39,839 --> 00:49:41,920
and the papers costed with alexander mai

1204
00:49:41,920 --> 00:49:45,520
javier verbel and wei chengwen

1205
00:49:45,520 --> 00:49:49,000
whenever you're ready

1206
00:50:21,760 --> 00:50:23,680
oh yes hello thank you for the

1207
00:50:23,680 --> 00:50:25,119
introduction

1208
00:50:25,119 --> 00:50:26,880
we were investigating partial key

1209
00:50:26,880 --> 00:50:28,960
exposure attacks on bike rainbow and

1210
00:50:28,960 --> 00:50:31,520
andrew and this is joint world with

1211
00:50:31,520 --> 00:50:33,440
alexander maier javier bell and wei

1212
00:50:33,440 --> 00:50:34,800
changmin

1213
00:50:34,800 --> 00:50:37,760
so in this work we were

1214
00:50:37,760 --> 00:50:40,800
asking the question if post quantum

1215
00:50:40,800 --> 00:50:43,280
candidates are leakage resistant so what

1216
00:50:43,280 --> 00:50:45,680
does this mean in an informal sense if

1217
00:50:45,680 --> 00:50:48,160
you have an n bit secret key

1218
00:50:48,160 --> 00:50:51,119
and l bit of this secret key get leaked

1219
00:50:51,119 --> 00:50:52,480
then we say a scheme is leakage

1220
00:50:52,480 --> 00:50:54,880
resistant if it offers the security of

1221
00:50:54,880 --> 00:50:56,720
an n minus l bit

1222
00:50:56,720 --> 00:50:59,359
key which is somehow the best you might

1223
00:50:59,359 --> 00:51:01,920
hope for and we know from classical

1224
00:51:01,920 --> 00:51:04,319
schemes that like rsa said this is not

1225
00:51:04,319 --> 00:51:05,359
the case

1226
00:51:05,359 --> 00:51:07,040
so why are we asking this for post

1227
00:51:07,040 --> 00:51:08,640
quantum candidates

1228
00:51:08,640 --> 00:51:09,599
because

1229
00:51:09,599 --> 00:51:10,400
the

1230
00:51:10,400 --> 00:51:12,240
best known attacks so far simply

1231
00:51:12,240 --> 00:51:14,000
enumerated missing bits

1232
00:51:14,000 --> 00:51:16,240
and this strongly supports leakage

1233
00:51:16,240 --> 00:51:18,400
resistance belief and

1234
00:51:18,400 --> 00:51:20,400
so these attacks do not exploit any key

1235
00:51:20,400 --> 00:51:22,400
redundancy key structure

1236
00:51:22,400 --> 00:51:24,559
or relations between the public and the

1237
00:51:24,559 --> 00:51:26,160
secret key

1238
00:51:26,160 --> 00:51:28,800
and in this work we give new attacks

1239
00:51:28,800 --> 00:51:30,400
which actually heavily exploits those

1240
00:51:30,400 --> 00:51:31,680
things

1241
00:51:31,680 --> 00:51:33,280
and

1242
00:51:33,280 --> 00:51:36,240
yeah using these new attacks we derive

1243
00:51:36,240 --> 00:51:38,480
bounce on the required leakage

1244
00:51:38,480 --> 00:51:39,200
to

1245
00:51:39,200 --> 00:51:41,040
recover the full key

1246
00:51:41,040 --> 00:51:42,960
so again let me give a brief overview of

1247
00:51:42,960 --> 00:51:45,839
our methodology so first we we model the

1248
00:51:45,839 --> 00:51:47,040
leakage

1249
00:51:47,040 --> 00:51:49,359
that you obtain from some arbitrary side

1250
00:51:49,359 --> 00:51:50,800
channel so how does this leakage look

1251
00:51:50,800 --> 00:51:53,839
like here we differentiate two models

1252
00:51:53,839 --> 00:51:56,000
and then in in each model

1253
00:51:56,000 --> 00:51:57,680
we

1254
00:51:57,680 --> 00:51:59,599
ask first a question for asymptotic

1255
00:51:59,599 --> 00:52:02,160
leakage bonds so here the question is

1256
00:52:02,160 --> 00:52:05,599
how big has the leakage to be to be able

1257
00:52:05,599 --> 00:52:08,079
to recover the secret key in polynomial

1258
00:52:08,079 --> 00:52:09,359
time

1259
00:52:09,359 --> 00:52:11,280
and a more practical question where we

1260
00:52:11,280 --> 00:52:13,520
are interested in recovering the secret

1261
00:52:13,520 --> 00:52:14,319
key

1262
00:52:14,319 --> 00:52:15,119
um

1263
00:52:15,119 --> 00:52:17,520
below some time threshold so let's say

1264
00:52:17,520 --> 00:52:19,920
two to the 60 bit operations so how bit

1265
00:52:19,920 --> 00:52:22,720
big can or has a has a leakage to be to

1266
00:52:22,720 --> 00:52:24,800
be able to to achieve this

1267
00:52:24,800 --> 00:52:26,400
this is basically also the structure of

1268
00:52:26,400 --> 00:52:29,200
the talk so we will define the the model

1269
00:52:29,200 --> 00:52:31,839
and then we will answer these two

1270
00:52:31,839 --> 00:52:33,599
research questions

1271
00:52:33,599 --> 00:52:36,000
but before we dive into

1272
00:52:36,000 --> 00:52:38,000
uh the models let's

1273
00:52:38,000 --> 00:52:40,319
first get some basics on the secret key

1274
00:52:40,319 --> 00:52:42,640
structures of rainbow bike and andrew

1275
00:52:42,640 --> 00:52:43,359
which

1276
00:52:43,359 --> 00:52:45,440
are the three schemes

1277
00:52:45,440 --> 00:52:48,000
exemplary investigated as a multivariate

1278
00:52:48,000 --> 00:52:51,359
uh code base in the lattice based scheme

1279
00:52:51,359 --> 00:52:53,520
so here we keep it very light so i try

1280
00:52:53,520 --> 00:52:56,400
to abstract a lot of things away but uh

1281
00:52:56,400 --> 00:52:57,359
yeah

1282
00:52:57,359 --> 00:52:59,839
in the rainbow case we have this the

1283
00:52:59,839 --> 00:53:01,040
secret key

1284
00:53:01,040 --> 00:53:04,559
is formed as two matrices so two linear

1285
00:53:04,559 --> 00:53:06,880
transformations over fq

1286
00:53:06,880 --> 00:53:08,480
with this structure here so basically

1287
00:53:08,480 --> 00:53:11,520
the secret key is this s prime t one t2

1288
00:53:11,520 --> 00:53:13,119
and t3

1289
00:53:13,119 --> 00:53:16,720
and we show that a single row of s prime

1290
00:53:16,720 --> 00:53:18,880
as well as a constant number of columns

1291
00:53:18,880 --> 00:53:20,160
from t1

1292
00:53:20,160 --> 00:53:22,559
are actually sufficient to

1293
00:53:22,559 --> 00:53:25,280
recover the full secret key so

1294
00:53:25,280 --> 00:53:26,480
if you take this definition of the

1295
00:53:26,480 --> 00:53:28,880
secret key it's uh it inherits a

1296
00:53:28,880 --> 00:53:31,040
quadratic redundancy factor

1297
00:53:31,040 --> 00:53:32,640
which is actually exploited by our

1298
00:53:32,640 --> 00:53:33,920
attacks

1299
00:53:33,920 --> 00:53:37,200
and if we go to the bike's

1300
00:53:37,200 --> 00:53:39,119
bike scheme the secret key is formed as

1301
00:53:39,119 --> 00:53:40,880
a length n

1302
00:53:40,880 --> 00:53:43,359
vector which is quite sparse so it has

1303
00:53:43,359 --> 00:53:45,920
only a few amount of ones sorry here's

1304
00:53:45,920 --> 00:53:47,760
something wrong it doesn't matter so it

1305
00:53:47,760 --> 00:53:50,160
satisfies some uh matrix vector product

1306
00:53:50,160 --> 00:53:52,960
equation a times s is equal to e

1307
00:53:52,960 --> 00:53:54,559
and um

1308
00:53:54,559 --> 00:53:57,839
yeah obviously s or e is a suffice here

1309
00:53:57,839 --> 00:54:00,880
to to recover um the other part so we

1310
00:54:00,880 --> 00:54:03,760
have a linear redundancy vector here

1311
00:54:03,760 --> 00:54:05,680
and last but not least in the entro case

1312
00:54:05,680 --> 00:54:07,599
the secret key might be seen as a

1313
00:54:07,599 --> 00:54:09,680
ternary vector of length

1314
00:54:09,680 --> 00:54:10,640
n

1315
00:54:10,640 --> 00:54:12,400
it fulfills a similar equation as in the

1316
00:54:12,400 --> 00:54:15,119
byte case but note that e is not part of

1317
00:54:15,119 --> 00:54:16,720
the secret key here

1318
00:54:16,720 --> 00:54:19,440
so we have no intrinsic shortcut but

1319
00:54:19,440 --> 00:54:20,480
yeah

1320
00:54:20,480 --> 00:54:22,480
current implementations usually store

1321
00:54:22,480 --> 00:54:23,920
some extra information for for

1322
00:54:23,920 --> 00:54:26,000
efficiency reasons uh so there is some

1323
00:54:26,000 --> 00:54:28,079
redundancy but definitely the least

1324
00:54:28,079 --> 00:54:30,319
redundancy here in the in the intro case

1325
00:54:30,319 --> 00:54:32,319
and we will see that this is also

1326
00:54:32,319 --> 00:54:34,079
reflected by our attacks usually they

1327
00:54:34,079 --> 00:54:36,960
they tend to be uh better the higher the

1328
00:54:36,960 --> 00:54:40,319
redundancy as a rule of thumb

1329
00:54:40,319 --> 00:54:42,720
so our attacks on bike are actually the

1330
00:54:42,720 --> 00:54:44,720
easiest to understand without a lot of

1331
00:54:44,720 --> 00:54:47,440
prior knowledge so i will use them as a

1332
00:54:47,440 --> 00:54:49,520
kind of running example to to give a

1333
00:54:49,520 --> 00:54:50,960
indication how these attacks might look

1334
00:54:50,960 --> 00:54:53,839
like and they

1335
00:54:53,839 --> 00:54:56,000
use a technique called information set

1336
00:54:56,000 --> 00:54:58,240
decoding which

1337
00:54:58,240 --> 00:55:00,079
allows also to recover the bike without

1338
00:55:00,079 --> 00:55:01,280
any

1339
00:55:01,280 --> 00:55:02,799
any leakage of course the attack has a

1340
00:55:02,799 --> 00:55:04,960
high complexity but then we accelerate

1341
00:55:04,960 --> 00:55:08,559
this technique by uh using the leakage

1342
00:55:08,559 --> 00:55:10,799
uh yeah obtained by the by an arbitrary

1343
00:55:10,799 --> 00:55:12,880
side channel and

1344
00:55:12,880 --> 00:55:14,799
interestingly we use the information set

1345
00:55:14,799 --> 00:55:16,319
decoding technique not only in the bike

1346
00:55:16,319 --> 00:55:18,400
case but also as a key ingredient for

1347
00:55:18,400 --> 00:55:20,559
for all three schemes to obtain our

1348
00:55:20,559 --> 00:55:21,599
results

1349
00:55:21,599 --> 00:55:22,480
so

1350
00:55:22,480 --> 00:55:24,319
let us briefly have a look how this

1351
00:55:24,319 --> 00:55:26,480
technique works

1352
00:55:26,480 --> 00:55:28,480
so as we said in the

1353
00:55:28,480 --> 00:55:31,280
in the byte case secret key is a length

1354
00:55:31,280 --> 00:55:32,559
n

1355
00:55:32,559 --> 00:55:34,799
binary vector with which is quite sparse

1356
00:55:34,799 --> 00:55:38,240
sparse uh that it has only a square root

1357
00:55:38,240 --> 00:55:40,480
of n number of one entries in a length n

1358
00:55:40,480 --> 00:55:41,920
vector

1359
00:55:41,920 --> 00:55:44,000
uh and of course it fulfills this uh

1360
00:55:44,000 --> 00:55:45,119
matrix

1361
00:55:45,119 --> 00:55:47,119
vector product relation so we can also

1362
00:55:47,119 --> 00:55:49,440
like append the identity to the left of

1363
00:55:49,440 --> 00:55:52,319
a and then like rewrite it like this

1364
00:55:52,319 --> 00:55:54,880
and we visualize it for now compact like

1365
00:55:54,880 --> 00:55:55,599
this

1366
00:55:55,599 --> 00:55:58,799
matrix times vector is equal to zero

1367
00:55:58,799 --> 00:56:00,319
and uh

1368
00:56:00,319 --> 00:56:02,160
yes then we are interested in in finding

1369
00:56:02,160 --> 00:56:04,640
this vector e s here uh this orange

1370
00:56:04,640 --> 00:56:07,520
vector without any prior knowledge

1371
00:56:07,520 --> 00:56:09,760
so assume for the moment that we would

1372
00:56:09,760 --> 00:56:11,680
know uh n over two

1373
00:56:11,680 --> 00:56:14,000
zero coordinates in this vector that's

1374
00:56:14,000 --> 00:56:15,920
for example here but i just put them in

1375
00:56:15,920 --> 00:56:18,000
the front and in the back for an easier

1376
00:56:18,000 --> 00:56:19,920
illustration but they could distribute

1377
00:56:19,920 --> 00:56:21,920
anywhere over this vector so if we know

1378
00:56:21,920 --> 00:56:24,799
such a such a set of n over two uh zero

1379
00:56:24,799 --> 00:56:26,559
positions then of course these parts of

1380
00:56:26,559 --> 00:56:28,720
the matrix do not play any role you can

1381
00:56:28,720 --> 00:56:30,400
safely discard them

1382
00:56:30,400 --> 00:56:32,720
and so then we are left with a

1383
00:56:32,720 --> 00:56:34,880
square system which we can simply solve

1384
00:56:34,880 --> 00:56:36,799
for a gaussian elimination to recover

1385
00:56:36,799 --> 00:56:39,520
this vector here like includes a zeros

1386
00:56:39,520 --> 00:56:40,880
again and

1387
00:56:40,880 --> 00:56:42,559
as soon as this vector here has weight

1388
00:56:42,559 --> 00:56:43,920
square root of n

1389
00:56:43,920 --> 00:56:45,440
we're done

1390
00:56:45,440 --> 00:56:47,119
but of course this is not necessarily

1391
00:56:47,119 --> 00:56:48,480
the case

1392
00:56:48,480 --> 00:56:49,760
because we

1393
00:56:49,760 --> 00:56:51,520
don't know a priori such as set of n

1394
00:56:51,520 --> 00:56:53,119
over two or zeros so we have to guess

1395
00:56:53,119 --> 00:56:53,839
one

1396
00:56:53,839 --> 00:56:56,160
but of course it is a sparse vector so

1397
00:56:56,160 --> 00:56:57,520
again the guessing probability is quite

1398
00:56:57,520 --> 00:56:58,960
good

1399
00:56:58,960 --> 00:57:01,200
and then yeah if it is not of the

1400
00:57:01,200 --> 00:57:03,119
desired weight we guess a different set

1401
00:57:03,119 --> 00:57:04,319
of zeros

1402
00:57:04,319 --> 00:57:07,119
and until this is of weight square root

1403
00:57:07,119 --> 00:57:09,280
of n and then we recovered the secret

1404
00:57:09,280 --> 00:57:10,799
key

1405
00:57:10,799 --> 00:57:13,520
okay this is uh the basics so now let us

1406
00:57:13,520 --> 00:57:16,559
get into um into the model definition so

1407
00:57:16,559 --> 00:57:17,839
we start with the

1408
00:57:17,839 --> 00:57:19,920
erasure model where

1409
00:57:19,920 --> 00:57:21,760
so so in general we model the secret key

1410
00:57:21,760 --> 00:57:23,680
always as n bits so it doesn't matter

1411
00:57:23,680 --> 00:57:25,359
like even if it's a matrix we can always

1412
00:57:25,359 --> 00:57:27,520
write it as a as a chunk of bits and uh

1413
00:57:27,520 --> 00:57:30,640
we we consider it n bits long

1414
00:57:30,640 --> 00:57:34,720
and in the eraser model uh we

1415
00:57:34,720 --> 00:57:36,640
uh it says error model but the eurasia

1416
00:57:36,640 --> 00:57:38,319
model

1417
00:57:38,319 --> 00:57:40,720
we get a knowledge of an erased key

1418
00:57:40,720 --> 00:57:43,680
where um yeah some some of the bits got

1419
00:57:43,680 --> 00:57:44,720
erased

1420
00:57:44,720 --> 00:57:46,559
indicated by this question mark covered

1421
00:57:46,559 --> 00:57:47,839
areas here

1422
00:57:47,839 --> 00:57:49,760
and they are not known

1423
00:57:49,760 --> 00:57:51,760
but the positions are known and the

1424
00:57:51,760 --> 00:57:53,680
green parts are known as well as the

1425
00:57:53,680 --> 00:57:55,520
positions and they are guaranteed to be

1426
00:57:55,520 --> 00:57:57,040
correct

1427
00:57:57,040 --> 00:57:58,000
and

1428
00:57:58,000 --> 00:58:00,000
yeah zeroes and ones get erased with the

1429
00:58:00,000 --> 00:58:01,760
same probability

1430
00:58:01,760 --> 00:58:03,359
uh yeah

1431
00:58:03,359 --> 00:58:05,680
and now given such a such an erased key

1432
00:58:05,680 --> 00:58:09,040
the question we answered is

1433
00:58:09,040 --> 00:58:11,359
first about the asymptotic balance so

1434
00:58:11,359 --> 00:58:13,440
here we have the different

1435
00:58:13,440 --> 00:58:15,839
schemes and different settings we will

1436
00:58:15,839 --> 00:58:17,280
i will explain in a second what this

1437
00:58:17,280 --> 00:58:18,160
means

1438
00:58:18,160 --> 00:58:20,720
and the question is how many erasures so

1439
00:58:20,720 --> 00:58:22,960
how many question marks can we tolerate

1440
00:58:22,960 --> 00:58:25,599
to still recover the

1441
00:58:25,599 --> 00:58:28,000
them in in polynomial time

1442
00:58:28,000 --> 00:58:29,520
so for example in the in the rainbow

1443
00:58:29,520 --> 00:58:32,319
case if we uh consider the first layer

1444
00:58:32,319 --> 00:58:33,680
just a second then i will explain what

1445
00:58:33,680 --> 00:58:36,960
it is we can tolerate n minus something

1446
00:58:36,960 --> 00:58:38,319
sublinear and

1447
00:58:38,319 --> 00:58:41,920
a number of erasures to still recover it

1448
00:58:41,920 --> 00:58:43,920
so almost everything basically which is

1449
00:58:43,920 --> 00:58:45,440
related to this quadratic redundancy

1450
00:58:45,440 --> 00:58:47,440
factor

1451
00:58:47,440 --> 00:58:51,200
and um yeah so but first if

1452
00:58:51,200 --> 00:58:54,319
we perform a basic enumeration then you

1453
00:58:54,319 --> 00:58:55,280
can only

1454
00:58:55,280 --> 00:58:57,119
tolerate a lock

1455
00:58:57,119 --> 00:58:59,839
and amount of erasures because the

1456
00:58:59,839 --> 00:59:01,920
enumeration comes at a cost of two to

1457
00:59:01,920 --> 00:59:04,319
the number of eurasias which is only

1458
00:59:04,319 --> 00:59:06,559
polynomial if the amount of eurasias is

1459
00:59:06,559 --> 00:59:09,119
logarithmic

1460
00:59:10,000 --> 00:59:11,920
yeah so what is this first layer so the

1461
00:59:11,920 --> 00:59:13,839
first layer is basically if we have this

1462
00:59:13,839 --> 00:59:15,440
definition of the secret key then it

1463
00:59:15,440 --> 00:59:18,960
says s prime t2 and t3 and if you recall

1464
00:59:18,960 --> 00:59:20,319
ward's talk from yesterday it's

1465
00:59:20,319 --> 00:59:22,400
basically this outer layer which is

1466
00:59:22,400 --> 00:59:25,680
added by by a rainbow

1467
00:59:25,680 --> 00:59:28,319
to the uav scheme and the full key

1468
00:59:28,319 --> 00:59:30,799
recovery then requires to also recover

1469
00:59:30,799 --> 00:59:32,480
the the key of this

1470
00:59:32,480 --> 00:59:34,880
smaller uv instance which is left

1471
00:59:34,880 --> 00:59:37,280
and to recover this we can only tolerate

1472
00:59:37,280 --> 00:59:38,960
a square root of n

1473
00:59:38,960 --> 00:59:42,079
erasures on t1

1474
00:59:42,079 --> 00:59:44,880
and here you we already see that

1475
00:59:44,880 --> 00:59:47,359
uv is like inherently more secure

1476
00:59:47,359 --> 00:59:51,520
against our attacks than rainbow is

1477
00:59:51,680 --> 00:59:52,880
yeah and

1478
00:59:52,880 --> 00:59:55,040
yeah and the bike case we we separate

1479
00:59:55,040 --> 00:59:57,280
also two um

1480
00:59:57,280 --> 00:59:58,640
different settings it's a standard and

1481
00:59:58,640 --> 01:00:01,119
the compact setting in the standard

1482
01:00:01,119 --> 01:00:02,559
setting we

1483
01:00:02,559 --> 01:00:04,240
the secret key is represented as a

1484
01:00:04,240 --> 01:00:07,040
sequence of n bits so just as it is

1485
01:00:07,040 --> 01:00:09,760
defined like a low weight and bit vector

1486
01:00:09,760 --> 01:00:12,559
and in the compact setting we have

1487
01:00:12,559 --> 01:00:14,319
we encode the one positions of this

1488
01:00:14,319 --> 01:00:16,079
vector so if you count from the right

1489
01:00:16,079 --> 01:00:19,200
this is a the compact representation of

1490
01:00:19,200 --> 01:00:21,200
this uh vector

1491
01:00:21,200 --> 01:00:23,359
and due to this compression we get a

1492
01:00:23,359 --> 01:00:26,640
slightly lower uh number of tolerator

1493
01:00:26,640 --> 01:00:29,680
tolerable um erasures

1494
01:00:29,680 --> 01:00:31,520
and in the android case we also

1495
01:00:31,520 --> 01:00:33,760
differentiate two two cases uh two

1496
01:00:33,760 --> 01:00:36,319
settings but they matter mostly in a

1497
01:00:36,319 --> 01:00:38,720
practical sense uh so here we have an

1498
01:00:38,720 --> 01:00:41,280
unpacked and a packed representation so

1499
01:00:41,280 --> 01:00:43,599
in the unpacked representation the

1500
01:00:43,599 --> 01:00:45,760
coordinates of the vector are stored via

1501
01:00:45,760 --> 01:00:47,200
two bits each

1502
01:00:47,200 --> 01:00:48,720
which is

1503
01:00:48,720 --> 01:00:50,799
wasting some of the bits so there is an

1504
01:00:50,799 --> 01:00:53,440
an encoding which actually packs a

1505
01:00:53,440 --> 01:00:57,040
certain amount of this into a more dense

1506
01:00:57,040 --> 01:00:59,359
representation

1507
01:00:59,359 --> 01:01:01,680
and in all cases here we basically

1508
01:01:01,680 --> 01:01:03,440
achieve our results by

1509
01:01:03,440 --> 01:01:05,920
first deriving a linear or

1510
01:01:05,920 --> 01:01:07,920
quadratic system due to the public

1511
01:01:07,920 --> 01:01:10,640
private key relations and then given the

1512
01:01:10,640 --> 01:01:12,640
leakage we eliminate variables from

1513
01:01:12,640 --> 01:01:14,079
these systems

1514
01:01:14,079 --> 01:01:15,920
and then we solve it by a version

1515
01:01:15,920 --> 01:01:18,559
elimination or by linearization

1516
01:01:18,559 --> 01:01:20,640
so in the by case let us just quickly

1517
01:01:20,640 --> 01:01:22,799
have a look how this worked

1518
01:01:22,799 --> 01:01:24,960
so as we already uh saw the bike

1519
01:01:24,960 --> 01:01:27,280
secretly fulfills this uh this linear

1520
01:01:27,280 --> 01:01:29,680
relation a times s is equal to e

1521
01:01:29,680 --> 01:01:31,599
and um yeah

1522
01:01:31,599 --> 01:01:33,440
our attack basically simply shows that

1523
01:01:33,440 --> 01:01:34,400
uh

1524
01:01:34,400 --> 01:01:37,280
you don't need to know s or e just any n

1525
01:01:37,280 --> 01:01:40,079
over two uh coordinates surface um

1526
01:01:40,079 --> 01:01:42,000
because uh yeah as long as you have less

1527
01:01:42,000 --> 01:01:44,160
than n over two's question marks you can

1528
01:01:44,160 --> 01:01:47,760
um you have less than one over two um

1529
01:01:47,760 --> 01:01:50,720
unknowns in this in this linear system

1530
01:01:50,720 --> 01:01:52,240
and maybe more interestingly in the

1531
01:01:52,240 --> 01:01:53,599
compact case

1532
01:01:53,599 --> 01:01:55,760
so the compact case as we set it encodes

1533
01:01:55,760 --> 01:01:57,760
uh the one positions of the secret key

1534
01:01:57,760 --> 01:01:59,839
so we have this these blocks of size log

1535
01:01:59,839 --> 01:02:01,839
n which encode one uh index where the

1536
01:02:01,839 --> 01:02:04,160
secret key is one and uh then we have

1537
01:02:04,160 --> 01:02:06,720
square root n of many of them and now

1538
01:02:06,720 --> 01:02:10,000
our attack first enumerates the um

1539
01:02:10,000 --> 01:02:12,079
the erasers per block

1540
01:02:12,079 --> 01:02:13,760
which gives you a list of candidates

1541
01:02:13,760 --> 01:02:15,200
list of candidates where the secret key

1542
01:02:15,200 --> 01:02:16,400
might be one

1543
01:02:16,400 --> 01:02:18,400
and then

1544
01:02:18,400 --> 01:02:19,280
of course

1545
01:02:19,280 --> 01:02:22,160
if something is not appearing among this

1546
01:02:22,160 --> 01:02:23,920
amount among this list then it must be

1547
01:02:23,920 --> 01:02:25,920
zero so that means as long as the list

1548
01:02:25,920 --> 01:02:29,200
is smaller than n over two we uh know n

1549
01:02:29,200 --> 01:02:30,480
over two zero positions and can

1550
01:02:30,480 --> 01:02:33,280
eliminate n over two variables from this

1551
01:02:33,280 --> 01:02:34,559
system

1552
01:02:34,559 --> 01:02:36,880
and can then again solved in

1553
01:02:36,880 --> 01:02:40,400
um yeah so foreign elimination

1554
01:02:40,400 --> 01:02:43,280
exactly um

1555
01:02:43,280 --> 01:02:46,000
yes and uh we we uh let us look into the

1556
01:02:46,000 --> 01:02:47,839
practical bounds so here's a the

1557
01:02:47,839 --> 01:02:50,319
question is um how

1558
01:02:50,319 --> 01:02:52,160
big can the number of erasures be to

1559
01:02:52,160 --> 01:02:54,079
recover below a certain threshold here

1560
01:02:54,079 --> 01:02:55,839
we use 60 bit

1561
01:02:55,839 --> 01:02:57,200
complexity

1562
01:02:57,200 --> 01:02:58,960
for the category one parameter sets in

1563
01:02:58,960 --> 01:03:00,480
this setting here

1564
01:03:00,480 --> 01:03:03,680
um yeah and first if you perform an

1565
01:03:03,680 --> 01:03:07,039
enumeration only then you can recover

1566
01:03:07,039 --> 01:03:09,240
basically less than

1567
01:03:09,240 --> 01:03:12,559
0.01 so so one percent uh erasers you

1568
01:03:12,559 --> 01:03:13,680
can tolerate

1569
01:03:13,680 --> 01:03:15,599
and we see that stills are way higher

1570
01:03:15,599 --> 01:03:18,079
here and again we see the redundancy

1571
01:03:18,079 --> 01:03:19,680
reflected

1572
01:03:19,680 --> 01:03:21,119
unfortunately i don't have the time to

1573
01:03:21,119 --> 01:03:23,440
go into all the details but let me just

1574
01:03:23,440 --> 01:03:25,359
briefly sketch what kind of techniques

1575
01:03:25,359 --> 01:03:28,720
we used to obtain our results so in the

1576
01:03:28,720 --> 01:03:30,960
rainbow case we recover the first layer

1577
01:03:30,960 --> 01:03:31,680
by

1578
01:03:31,680 --> 01:03:33,359
modeling a linear system

1579
01:03:33,359 --> 01:03:35,200
and the second layer by solving a

1580
01:03:35,200 --> 01:03:37,680
quadratic system

1581
01:03:37,680 --> 01:03:39,359
in the by case we use something similar

1582
01:03:39,359 --> 01:03:41,039
as in the in the asymptotic setting what

1583
01:03:41,039 --> 01:03:43,119
we have seen like an accelerated isd

1584
01:03:43,119 --> 01:03:44,960
which is modified to a non-polynomial

1585
01:03:44,960 --> 01:03:48,480
setting um yeah and a

1586
01:03:48,480 --> 01:03:50,559
few practical tweaks

1587
01:03:50,559 --> 01:03:52,000
and in the intro case we use lattice

1588
01:03:52,000 --> 01:03:54,160
reduction where we

1589
01:03:54,160 --> 01:03:57,200
apply some dimension reduction by

1590
01:03:57,200 --> 01:04:00,559
using the known leakage

1591
01:04:00,559 --> 01:04:02,960
so let me let us now briefly cover the

1592
01:04:02,960 --> 01:04:04,160
error model

1593
01:04:04,160 --> 01:04:06,240
so in the in the error model we we get a

1594
01:04:06,240 --> 01:04:07,839
we still have a secret key of n bits and

1595
01:04:07,839 --> 01:04:08,880
we get an

1596
01:04:08,880 --> 01:04:10,640
knowledge of an erroneous

1597
01:04:10,640 --> 01:04:12,720
version of this key

1598
01:04:12,720 --> 01:04:13,839
where

1599
01:04:13,839 --> 01:04:15,359
yeah some bits might be flipped so

1600
01:04:15,359 --> 01:04:17,920
indicated by these orange bits here

1601
01:04:17,920 --> 01:04:19,599
but of course the positions are not

1602
01:04:19,599 --> 01:04:21,119
known it's just too easy to check that

1603
01:04:21,119 --> 01:04:23,680
there are some bits flipped

1604
01:04:23,680 --> 01:04:26,559
and then we differentiate two

1605
01:04:26,559 --> 01:04:28,559
like sub models where we have one

1606
01:04:28,559 --> 01:04:30,720
symmetric model where zero flips to a

1607
01:04:30,720 --> 01:04:32,240
one with the same probability as a one

1608
01:04:32,240 --> 01:04:34,000
flips two to a zero

1609
01:04:34,000 --> 01:04:37,039
and one uh asymmetric model where

1610
01:04:37,039 --> 01:04:38,240
the

1611
01:04:38,240 --> 01:04:39,440
yeah one of the probabilities is very

1612
01:04:39,440 --> 01:04:41,680
small and the other uh is

1613
01:04:41,680 --> 01:04:43,280
yeah ranging

1614
01:04:43,280 --> 01:04:46,079
over different values and

1615
01:04:46,079 --> 01:04:47,599
yeah the asymmetric model and is

1616
01:04:47,599 --> 01:04:49,440
basically motivated by some physical

1617
01:04:49,440 --> 01:04:51,760
observations

1618
01:04:51,760 --> 01:04:54,160
you know yeah let's let's cover uh the

1619
01:04:54,160 --> 01:04:56,240
asymptotic bounce first

1620
01:04:56,240 --> 01:04:58,079
uh so we have again the different

1621
01:04:58,079 --> 01:05:01,119
settings uh and we see how many uh

1622
01:05:01,119 --> 01:05:03,119
how many errors we can tolerate to still

1623
01:05:03,119 --> 01:05:05,839
recover in polynomial time

1624
01:05:05,839 --> 01:05:08,319
again in enumeration approach here would

1625
01:05:08,319 --> 01:05:10,079
only allow for a constant number of

1626
01:05:10,079 --> 01:05:12,079
errors because we don't know the

1627
01:05:12,079 --> 01:05:14,079
position of the errors so the complexity

1628
01:05:14,079 --> 01:05:14,880
is

1629
01:05:14,880 --> 01:05:15,680
n

1630
01:05:15,680 --> 01:05:17,760
and choose the number of errors which is

1631
01:05:17,760 --> 01:05:18,640
only

1632
01:05:18,640 --> 01:05:21,119
um yeah polynomial for for a constant

1633
01:05:21,119 --> 01:05:23,119
amount of errors

1634
01:05:23,119 --> 01:05:25,359
and we see that all attacks basically um

1635
01:05:25,359 --> 01:05:27,599
allow for for more errors to be

1636
01:05:27,599 --> 01:05:29,119
recovered

1637
01:05:29,119 --> 01:05:30,960
and

1638
01:05:30,960 --> 01:05:32,720
yeah maybe most interestingly in the in

1639
01:05:32,720 --> 01:05:34,720
the bike case the compact the compact

1640
01:05:34,720 --> 01:05:36,880
model actually allows to recover uh more

1641
01:05:36,880 --> 01:05:38,960
errors than the standard setting we will

1642
01:05:38,960 --> 01:05:41,200
see in a second why this is the case

1643
01:05:41,200 --> 01:05:43,760
and also technique wise we use

1644
01:05:43,760 --> 01:05:46,319
information set decoding in all cases to

1645
01:05:46,319 --> 01:05:47,920
achieve our results

1646
01:05:47,920 --> 01:05:49,200
the only

1647
01:05:49,200 --> 01:05:51,200
outlier here is the full key recovery in

1648
01:05:51,200 --> 01:05:54,160
the rainbow case where we uh model uh

1649
01:05:54,160 --> 01:05:57,039
yeah we solve a quadratic system uh to

1650
01:05:57,039 --> 01:05:58,480
recover the

1651
01:05:58,480 --> 01:06:01,520
inner uvp

1652
01:06:01,680 --> 01:06:04,400
yeah let's uh cover the text on um on

1653
01:06:04,400 --> 01:06:06,720
bike maybe um so so in the standard

1654
01:06:06,720 --> 01:06:09,039
setting we get this uh erroneous version

1655
01:06:09,039 --> 01:06:11,440
where which is just the n-bit key which

1656
01:06:11,440 --> 01:06:12,240
which

1657
01:06:12,240 --> 01:06:14,000
basically is usually very sparse so it

1658
01:06:14,000 --> 01:06:15,920
only includes only a few

1659
01:06:15,920 --> 01:06:18,400
amount of ones here maybe as a few more

1660
01:06:18,400 --> 01:06:21,280
due to the bit flips that occurred but

1661
01:06:21,280 --> 01:06:23,680
still uh the technique in a nutshell is

1662
01:06:23,680 --> 01:06:26,160
to solve it via isd but sample the zero

1663
01:06:26,160 --> 01:06:28,880
coordinates only from

1664
01:06:28,880 --> 01:06:30,880
from the zeros of this neurons version

1665
01:06:30,880 --> 01:06:32,960
because these are more likely to encode

1666
01:06:32,960 --> 01:06:36,960
real zeros of the secret key

1667
01:06:36,960 --> 01:06:40,079
and uh in the compact case we have again

1668
01:06:40,079 --> 01:06:42,480
this this blocks of size log n and

1669
01:06:42,480 --> 01:06:44,000
square root many of them

1670
01:06:44,000 --> 01:06:45,599
encoding the indices where the secret

1671
01:06:45,599 --> 01:06:49,119
key is one and then we first enumerate

1672
01:06:49,119 --> 01:06:51,839
uh small weight errors on each block to

1673
01:06:51,839 --> 01:06:53,680
get the list of candidates

1674
01:06:53,680 --> 01:06:55,520
and this list of candidates can be seen

1675
01:06:55,520 --> 01:06:58,240
as a list of

1676
01:06:58,240 --> 01:07:00,240
coordinates where the secret key has a

1677
01:07:00,240 --> 01:07:02,880
higher probability to be v1

1678
01:07:02,880 --> 01:07:05,119
so we we solve then by isd but not

1679
01:07:05,119 --> 01:07:07,680
sampling from this list of candidates

1680
01:07:07,680 --> 01:07:09,520
and since we we are able to

1681
01:07:09,520 --> 01:07:11,920
[Music]

1682
01:07:11,920 --> 01:07:14,079
manipulate the size of this list by

1683
01:07:14,079 --> 01:07:16,720
changing the arrow we enumerate we have

1684
01:07:16,720 --> 01:07:18,160
this advantage

1685
01:07:18,160 --> 01:07:21,440
uh sorry we have this advantage in the

1686
01:07:21,440 --> 01:07:22,720
amount of

1687
01:07:22,720 --> 01:07:25,359
errors we can tolerate

1688
01:07:25,359 --> 01:07:28,240
so last but not least let's cover the

1689
01:07:28,240 --> 01:07:30,000
the practical bounce

1690
01:07:30,000 --> 01:07:31,119
on

1691
01:07:31,119 --> 01:07:33,359
in the array in the error model

1692
01:07:33,359 --> 01:07:35,440
so here again we we consider the

1693
01:07:35,440 --> 01:07:37,680
category one parameters for

1694
01:07:37,680 --> 01:07:40,160
for all three schemes

1695
01:07:40,160 --> 01:07:42,240
and we differentiate here the symmetric

1696
01:07:42,240 --> 01:07:45,359
and the asymmetric uh model so in the

1697
01:07:45,359 --> 01:07:47,119
it was isotopic bounds we only consider

1698
01:07:47,119 --> 01:07:48,240
as a

1699
01:07:48,240 --> 01:07:50,240
more difficult symmetric model so where

1700
01:07:50,240 --> 01:07:51,599
one and zero flip with the same

1701
01:07:51,599 --> 01:07:52,799
probability

1702
01:07:52,799 --> 01:07:54,799
and but in the in the practical setting

1703
01:07:54,799 --> 01:07:56,720
it makes a makes it can make a huge

1704
01:07:56,720 --> 01:07:58,160
difference

1705
01:07:58,160 --> 01:08:00,240
so we also consider this asymmetric uh

1706
01:08:00,240 --> 01:08:01,599
model

1707
01:08:01,599 --> 01:08:03,440
and again we we have the threshold of 60

1708
01:08:03,440 --> 01:08:05,440
bit complexity

1709
01:08:05,440 --> 01:08:07,440
and if you consider enumeration effects

1710
01:08:07,440 --> 01:08:09,440
only then usually you can handle

1711
01:08:09,440 --> 01:08:11,680
depending on symmetric or asymmetric uh

1712
01:08:11,680 --> 01:08:13,680
one percent uh to

1713
01:08:13,680 --> 01:08:17,600
0.1 percent in the symmetric model

1714
01:08:17,600 --> 01:08:20,158
and yeah technique wise we we're

1715
01:08:20,158 --> 01:08:22,399
basically quite similar to what we did

1716
01:08:22,399 --> 01:08:23,759
in the

1717
01:08:23,759 --> 01:08:27,839
in the eurasia model here we um

1718
01:08:27,839 --> 01:08:29,920
we used in the maybe in the entry case

1719
01:08:29,920 --> 01:08:32,479
we found that some combinatorial attacks

1720
01:08:32,479 --> 01:08:34,238
actually perform better which were

1721
01:08:34,238 --> 01:08:37,040
recently introduced um and not always a

1722
01:08:37,040 --> 01:08:38,640
latest reduction uh

1723
01:08:38,640 --> 01:08:41,679
is the best choice

1724
01:08:41,679 --> 01:08:42,719
yes so

1725
01:08:42,719 --> 01:08:44,880
uh as a conclusion

1726
01:08:44,880 --> 01:08:48,158
we um give uh non-trivial polynomial

1727
01:08:48,158 --> 01:08:50,000
time key recovery attacks in in all

1728
01:08:50,000 --> 01:08:51,040
cases

1729
01:08:51,040 --> 01:08:54,000
and for the for the practical bonds or

1730
01:08:54,000 --> 01:08:55,520
for the practical setting we find even

1731
01:08:55,520 --> 01:08:57,120
even higher bounds

1732
01:08:57,120 --> 01:08:58,238
and

1733
01:08:58,238 --> 01:08:59,679
actually these these results are

1734
01:08:59,679 --> 01:09:01,359
comparable to what we know about

1735
01:09:01,359 --> 01:09:03,759
classical schemes like rsa

1736
01:09:03,759 --> 01:09:07,279
and so we can safely conclude that

1737
01:09:07,279 --> 01:09:09,679
post-quantum candidates do not per se

1738
01:09:09,679 --> 01:09:12,479
enjoy leakage resistance

1739
01:09:12,479 --> 01:09:14,799
so thank you very much the papers online

1740
01:09:14,799 --> 01:09:16,399
for all the details and i'm happy to

1741
01:09:16,399 --> 01:09:19,639
take questions

1742
01:09:25,679 --> 01:09:28,080
thank you for the nice presentation um

1743
01:09:28,080 --> 01:09:30,158
is there anybody here who has a question

1744
01:09:30,158 --> 01:09:32,158
i see some people oh yeah

1745
01:09:32,158 --> 01:09:34,158
please just go to the microphone i guess

1746
01:09:34,158 --> 01:09:36,879
if that's possible

1747
01:09:43,359 --> 01:09:45,679
all right thanks for the talk uh

1748
01:09:45,679 --> 01:09:46,839
for the

1749
01:09:46,839 --> 01:09:50,560
compressed version of the bike key you

1750
01:09:50,560 --> 01:09:51,679
mentioned

1751
01:09:51,679 --> 01:09:54,560
um that you could do recovery with n

1752
01:09:54,560 --> 01:09:58,640
over 11 erasures where did 11 come from

1753
01:09:58,640 --> 01:10:01,280
seems like kind of a random number yes

1754
01:10:01,280 --> 01:10:04,400
it's true it's it's actually it's um i

1755
01:10:04,400 --> 01:10:05,920
just rounded a little bit to make it

1756
01:10:05,920 --> 01:10:07,600
easier for the slides but uh basically

1757
01:10:07,600 --> 01:10:10,080
you need to uh ensure that the number of

1758
01:10:10,080 --> 01:10:13,280
erasures per block so per

1759
01:10:13,280 --> 01:10:15,760
uh of this lock n blocks that this is

1760
01:10:15,760 --> 01:10:18,960
not too high because we we enumerate the

1761
01:10:18,960 --> 01:10:21,280
erasers there so we just need need to

1762
01:10:21,280 --> 01:10:24,000
ensure that it always stays low enough

1763
01:10:24,000 --> 01:10:25,520
because it is like an exponential blow

1764
01:10:25,520 --> 01:10:27,520
up if you enumerate there so yes

1765
01:10:27,520 --> 01:10:28,960
the amount of candidates you generate

1766
01:10:28,960 --> 01:10:31,280
per block is 2 to the number of erasures

1767
01:10:31,280 --> 01:10:32,320
per block

1768
01:10:32,320 --> 01:10:34,320
so this needs to be

1769
01:10:34,320 --> 01:10:36,800
lower than so that the sum over all of

1770
01:10:36,800 --> 01:10:37,840
them is

1771
01:10:37,840 --> 01:10:39,840
smaller than n over 2.

1772
01:10:39,840 --> 01:10:42,800
and yeah so just it's just the proof

1773
01:10:42,800 --> 01:10:44,400
that yields uh

1774
01:10:44,400 --> 01:10:45,520
like this

1775
01:10:45,520 --> 01:10:49,920
11 there but to to bound it sufficiently

1776
01:10:49,920 --> 01:10:52,320
but in the in practice we see that the

1777
01:10:52,320 --> 01:10:54,400
amount is actually way higher so there's

1778
01:10:54,400 --> 01:10:56,400
a huge gap between what we can prove and

1779
01:10:56,400 --> 01:10:58,800
what we um see in practice and practice

1780
01:10:58,800 --> 01:11:00,960
we can almost recover like 50 percent as

1781
01:11:00,960 --> 01:11:01,920
in the

1782
01:11:01,920 --> 01:11:04,719
um yeah as in the standard case

1783
01:11:04,719 --> 01:11:07,840
is he oh wait thank you

1784
01:11:08,239 --> 01:11:10,799
anyone else

1785
01:11:11,440 --> 01:11:14,719
oh yes i got a question is it assumed

1786
01:11:14,719 --> 01:11:17,520
that we know the positions of uh rightly

1787
01:11:17,520 --> 01:11:19,760
guessed bits

1788
01:11:19,760 --> 01:11:22,000
carry the positions of what

1789
01:11:22,000 --> 01:11:26,840
of bids that are guessed correctly

1790
01:11:27,840 --> 01:11:30,159
sorry so the positions in the erasure

1791
01:11:30,159 --> 01:11:32,080
case we

1792
01:11:32,080 --> 01:11:33,280
so there's the erasure model in the

1793
01:11:33,280 --> 01:11:34,960
error model in the erasure model we we

1794
01:11:34,960 --> 01:11:36,480
know the positions

1795
01:11:36,480 --> 01:11:39,280
of uh these green parts of the secret

1796
01:11:39,280 --> 01:11:41,679
key and this question mark covered and

1797
01:11:41,679 --> 01:11:44,239
you know the value of the the ones which

1798
01:11:44,239 --> 01:11:46,560
were green in the graphic and the ones

1799
01:11:46,560 --> 01:11:47,679
with question marks you don't know the

1800
01:11:47,679 --> 01:11:49,760
value and in the error case you don't

1801
01:11:49,760 --> 01:11:51,040
know the position of the flip bits

1802
01:11:51,040 --> 01:11:52,400
otherwise it would be

1803
01:11:52,400 --> 01:11:57,519
pretty easy oh i see thank you

1804
01:11:59,520 --> 01:12:00,960
okay i guess if there are no more

1805
01:12:00,960 --> 01:12:03,360
questions right now uh we can continue

1806
01:12:03,360 --> 01:12:04,560
with the next talk so thanks to the

1807
01:12:04,560 --> 01:12:07,880
speaker again

1808
01:12:22,320 --> 01:12:24,239
uh as usual while they set up the tech

1809
01:12:24,239 --> 01:12:26,880
stuff i will introduce the next talk

1810
01:12:26,880 --> 01:12:27,840
uh

1811
01:12:27,840 --> 01:12:30,800
this is another talk on post quantum

1812
01:12:30,800 --> 01:12:31,920
permitters

1813
01:12:31,920 --> 01:12:33,920
this title is improving support miners

1814
01:12:33,920 --> 01:12:36,000
ranked attacks with applications to gems

1815
01:12:36,000 --> 01:12:37,760
and rainbow which are two post quantum

1816
01:12:37,760 --> 01:12:38,960
permitters

1817
01:12:38,960 --> 01:12:40,960
and the authors are pierre pio who's

1818
01:12:40,960 --> 01:12:42,640
here and about to give the talk uh

1819
01:12:42,640 --> 01:12:45,199
javier rebel again daniel smithtown ray

1820
01:12:45,199 --> 01:12:48,960
palner uh daniel cabarcas i guess and

1821
01:12:48,960 --> 01:12:51,520
john boehner so please go ahead whenever

1822
01:12:51,520 --> 01:12:54,679
you're ready

1823
01:13:54,080 --> 01:13:55,280
hi

1824
01:13:55,280 --> 01:13:57,520
so i'm pierre from india paris and

1825
01:13:57,520 --> 01:13:58,880
sauber university and i will be

1826
01:13:58,880 --> 01:14:00,719
presenting some

1827
01:14:00,719 --> 01:14:03,679
cryptances on gems and rainbow which

1828
01:14:03,679 --> 01:14:04,719
were like

1829
01:14:04,719 --> 01:14:06,000
former

1830
01:14:06,000 --> 01:14:08,159
round three in his candidates

1831
01:14:08,159 --> 01:14:10,320
and this is joint work with joined by

1832
01:14:10,320 --> 01:14:13,120
now daniel cabarcas ray turner daniel

1833
01:14:13,120 --> 01:14:16,239
smithsonian and javier

1834
01:14:16,560 --> 01:14:17,679
so

1835
01:14:17,679 --> 01:14:20,159
james and rainbow are both multiverse

1836
01:14:20,159 --> 01:14:21,840
signature schemes

1837
01:14:21,840 --> 01:14:24,159
so this means that they rely on

1838
01:14:24,159 --> 01:14:25,760
multivator maps

1839
01:14:25,760 --> 01:14:28,000
so the secret key is some polynomial

1840
01:14:28,000 --> 01:14:30,159
system p

1841
01:14:30,159 --> 01:14:32,640
which looks like a random system so it

1842
01:14:32,640 --> 01:14:34,960
should be hard to invert

1843
01:14:34,960 --> 01:14:37,120
and the secret key is some extra

1844
01:14:37,120 --> 01:14:39,280
information which would allow a

1845
01:14:39,280 --> 01:14:42,560
legitimate user to efficiently find

1846
01:14:42,560 --> 01:14:45,920
premises of p so you start from what i

1847
01:14:45,920 --> 01:14:47,840
call big f which is

1848
01:14:47,840 --> 01:14:49,360
the central map

1849
01:14:49,360 --> 01:14:51,679
it's a polynomial system which is a easy

1850
01:14:51,679 --> 01:14:53,440
to invert this time

1851
01:14:53,440 --> 01:14:56,480
and you also have some linear maps t and

1852
01:14:56,480 --> 01:14:59,040
u so that you have the equality

1853
01:14:59,040 --> 01:15:02,480
p is equal to the composition of t f and

1854
01:15:02,480 --> 01:15:03,840
u

1855
01:15:03,840 --> 01:15:05,280
and basically the main difference

1856
01:15:05,280 --> 01:15:09,360
between gems and rainbow is how this big

1857
01:15:09,360 --> 01:15:11,679
f map is constructed

1858
01:15:11,679 --> 01:15:12,480
so

1859
01:15:12,480 --> 01:15:16,000
james relies on the very old hp

1860
01:15:16,000 --> 01:15:17,360
construction

1861
01:15:17,360 --> 01:15:19,360
and rainbow you have already heard about

1862
01:15:19,360 --> 01:15:22,239
it several times this week it is a

1863
01:15:22,239 --> 01:15:24,480
variance of the oil of the vinegar

1864
01:15:24,480 --> 01:15:27,199
snooter scheme

1865
01:15:28,000 --> 01:15:30,159
so even though those two constructions

1866
01:15:30,159 --> 01:15:32,400
are quite different both schemes are

1867
01:15:32,400 --> 01:15:35,520
vulnerable to what we call wrong attacks

1868
01:15:35,520 --> 01:15:37,360
so a wrong attack

1869
01:15:37,360 --> 01:15:39,280
is a particular type of key recovery

1870
01:15:39,280 --> 01:15:41,760
attack by solving an instance of the

1871
01:15:41,760 --> 01:15:44,000
minimum problem so in meanwhile you are

1872
01:15:44,000 --> 01:15:45,360
given

1873
01:15:45,360 --> 01:15:48,080
a set of public matrices

1874
01:15:48,080 --> 01:15:51,199
m1 to mk which are over f2

1875
01:15:51,199 --> 01:15:54,000
and your goal is to find some wrong

1876
01:15:54,000 --> 01:15:56,640
small d linear combination between these

1877
01:15:56,640 --> 01:15:58,640
matrices

1878
01:15:58,640 --> 01:16:00,480
and here in the more general version of

1879
01:16:00,480 --> 01:16:02,560
the problem it will be really helpful to

1880
01:16:02,560 --> 01:16:03,679
ask

1881
01:16:03,679 --> 01:16:07,040
that these secret entries excise

1882
01:16:07,040 --> 01:16:09,199
lie in a big l which is an extension

1883
01:16:09,199 --> 01:16:12,000
field of fq

1884
01:16:12,640 --> 01:16:15,520
and actually most of the recent progress

1885
01:16:15,520 --> 01:16:18,560
in the cryptolysis on gems on rainbow

1886
01:16:18,560 --> 01:16:21,520
came from improving this type of wrong

1887
01:16:21,520 --> 01:16:22,800
attacks

1888
01:16:22,800 --> 01:16:24,159
you have

1889
01:16:24,159 --> 01:16:26,480
last year at your eclipse the regular

1890
01:16:26,480 --> 01:16:30,080
minimum attack by by balance

1891
01:16:30,080 --> 01:16:32,880
and also an hiv variance and therefore

1892
01:16:32,880 --> 01:16:35,600
on james you had this work by a

1893
01:16:35,600 --> 01:16:38,000
thoroughball jolt ending at crypto last

1894
01:16:38,000 --> 01:16:41,679
year which earned the best paperwork

1895
01:16:41,679 --> 01:16:44,080
and in both cases what they do is that

1896
01:16:44,080 --> 01:16:46,000
they find

1897
01:16:46,000 --> 01:16:48,480
easier mean work instances than the ones

1898
01:16:48,480 --> 01:16:52,320
which are used in former wrong attacks

1899
01:16:53,120 --> 01:16:54,960
so this is not enough to come up of

1900
01:16:54,960 --> 01:16:56,640
course with a complete attack because it

1901
01:16:56,640 --> 01:16:59,600
remains uh to solve the instance whereas

1902
01:16:59,600 --> 01:17:02,560
once you have the meanwhile problem and

1903
01:17:02,560 --> 01:17:04,560
in this area as well there was another

1904
01:17:04,560 --> 01:17:06,159
breakthrough which is called super

1905
01:17:06,159 --> 01:17:08,159
miners which was proposed by bardet

1906
01:17:08,159 --> 01:17:10,000
salon

1907
01:17:10,000 --> 01:17:12,239
and support miners is a new algebraic

1908
01:17:12,239 --> 01:17:14,960
modeling to solve the main one problem

1909
01:17:14,960 --> 01:17:17,679
so to describe it i start from

1910
01:17:17,679 --> 01:17:20,880
m which is the secret wrong b matrix so

1911
01:17:20,880 --> 01:17:22,400
of course you don't know it

1912
01:17:22,400 --> 01:17:24,560
and you write it as a

1913
01:17:24,560 --> 01:17:27,280
product d times c like this where the

1914
01:17:27,280 --> 01:17:28,560
matrix c

1915
01:17:28,560 --> 01:17:31,520
has only zeros

1916
01:17:31,520 --> 01:17:34,560
and from this equality if you take

1917
01:17:34,560 --> 01:17:36,080
your row

1918
01:17:36,080 --> 01:17:37,920
or j of m

1919
01:17:37,920 --> 01:17:40,159
you notice that this row is also in zero

1920
01:17:40,159 --> 01:17:42,000
space of c

1921
01:17:42,000 --> 01:17:44,239
so this means that if i construct this

1922
01:17:44,239 --> 01:17:46,239
matrix like this which is simply you

1923
01:17:46,239 --> 01:17:49,199
stack your row with your matrix c this

1924
01:17:49,199 --> 01:17:51,679
is a matrix with d plus one rows but the

1925
01:17:51,679 --> 01:17:52,640
wrong

1926
01:17:52,640 --> 01:17:55,120
can be at most d

1927
01:17:55,120 --> 01:17:57,120
and then there is a very easy way to

1928
01:17:57,120 --> 01:17:59,600
generate equation is to write that all

1929
01:17:59,600 --> 01:18:02,560
the maximal minors of cj which are of

1930
01:18:02,560 --> 01:18:04,880
size d plus one or zero and you can do

1931
01:18:04,880 --> 01:18:08,239
this for any row index j

1932
01:18:08,239 --> 01:18:10,400
so in this way you get your system q

1933
01:18:10,400 --> 01:18:13,120
which is the support minor system

1934
01:18:13,120 --> 01:18:14,960
and this is clearly a nonlinear system

1935
01:18:14,960 --> 01:18:16,480
because like you have a minor there is

1936
01:18:16,480 --> 01:18:19,600
no reason why the equation only known

1937
01:18:19,600 --> 01:18:21,440
so another way to solve it is to

1938
01:18:21,440 --> 01:18:22,719
linearize

1939
01:18:22,719 --> 01:18:24,800
and of course it will fail if you don't

1940
01:18:24,800 --> 01:18:25,600
have

1941
01:18:25,600 --> 01:18:27,679
enough equations compared to the number

1942
01:18:27,679 --> 01:18:29,040
of monomers

1943
01:18:29,040 --> 01:18:31,040
but in this case you can still try to

1944
01:18:31,040 --> 01:18:34,000
apply what is called excel

1945
01:18:34,000 --> 01:18:36,480
which is like you multiply the equations

1946
01:18:36,480 --> 01:18:38,719
by monomials of higher degree and you

1947
01:18:38,719 --> 01:18:41,120
try to linearize again

1948
01:18:41,120 --> 01:18:43,199
and in both cases in fact you are left

1949
01:18:43,199 --> 01:18:44,159
with

1950
01:18:44,159 --> 01:18:47,679
computing the kernel of some matrix mq

1951
01:18:47,679 --> 01:18:50,080
which is directly related to your

1952
01:18:50,080 --> 01:18:52,559
initial

1953
01:18:52,840 --> 01:18:55,760
system so our first contribution is this

1954
01:18:55,760 --> 01:18:57,520
paper is to propose

1955
01:18:57,520 --> 01:19:00,400
an improved attack on http variants and

1956
01:19:00,400 --> 01:19:03,840
james which is based on this very same

1957
01:19:03,840 --> 01:19:06,159
support minor system

1958
01:19:06,159 --> 01:19:07,920
so before starting i need to give a bit

1959
01:19:07,920 --> 01:19:10,560
of background hfe so this is what we

1960
01:19:10,560 --> 01:19:13,040
call a big field scheme

1961
01:19:13,040 --> 01:19:15,520
so to construct our central map we start

1962
01:19:15,520 --> 01:19:17,920
from fqn which is a

1963
01:19:17,920 --> 01:19:20,400
an extension field and we also use

1964
01:19:20,400 --> 01:19:23,840
phi which is some isomorphism so then we

1965
01:19:23,840 --> 01:19:26,320
go from our initial space to the

1966
01:19:26,320 --> 01:19:29,440
extension field by a player e5

1967
01:19:29,440 --> 01:19:32,000
and then over the big field we have a

1968
01:19:32,000 --> 01:19:35,040
small f which is what i call the hf

1969
01:19:35,040 --> 01:19:36,400
polynomial this is

1970
01:19:36,400 --> 01:19:39,440
a universal polynomial of degree

1971
01:19:39,440 --> 01:19:41,920
big d and essentially this big d is what

1972
01:19:41,920 --> 01:19:45,360
makes the schemes efficient or not

1973
01:19:45,360 --> 01:19:47,440
and then finally you will apply a five

1974
01:19:47,440 --> 01:19:49,520
minus one to go back to your initial

1975
01:19:49,520 --> 01:19:51,679
space so here the important thing is

1976
01:19:51,679 --> 01:19:53,040
that

1977
01:19:53,040 --> 01:19:55,920
your polynomial small f is over the big

1978
01:19:55,920 --> 01:19:58,239
field but your public polynomials are

1979
01:19:58,239 --> 01:20:00,640
over the small team

1980
01:20:00,640 --> 01:20:04,159
and finally gems is what we call an hf

1981
01:20:04,159 --> 01:20:06,800
variant because this is this plane http

1982
01:20:06,800 --> 01:20:08,639
construction to which you add some

1983
01:20:08,639 --> 01:20:11,360
modifiers and so this explains that your

1984
01:20:11,360 --> 01:20:14,239
scheme also has some extra parameters

1985
01:20:14,239 --> 01:20:18,120
a and b

1986
01:20:18,320 --> 01:20:21,520
so actually our uh attack will rely on

1987
01:20:21,520 --> 01:20:23,920
the same minimum problem which was

1988
01:20:23,920 --> 01:20:26,400
introduced by taoital a last year at

1989
01:20:26,400 --> 01:20:29,520
crypto so here the target rank is moldy

1990
01:20:29,520 --> 01:20:32,560
which is the logarithm of the degree of

1991
01:20:32,560 --> 01:20:34,719
the universe polynomial

1992
01:20:34,719 --> 01:20:36,480
and this attack is by

1993
01:20:36,480 --> 01:20:39,600
constructing some matrices over fq which

1994
01:20:39,600 --> 01:20:42,159
are like m1 to mn plus v

1995
01:20:42,159 --> 01:20:44,320
that you can easily generate from the

1996
01:20:44,320 --> 01:20:46,080
public

1997
01:20:46,080 --> 01:20:48,880
and now it turns out that you have some

1998
01:20:48,880 --> 01:20:49,920
wrong

1999
01:20:49,920 --> 01:20:52,320
small d linear combination between these

2000
01:20:52,320 --> 01:20:55,440
matrices but if you take your solution

2001
01:20:55,440 --> 01:20:56,560
vector u

2002
01:20:56,560 --> 01:20:59,520
over the extension field fqn

2003
01:20:59,520 --> 01:21:01,920
and basically from the knowledge of any

2004
01:21:01,920 --> 01:21:04,239
such shoe it will be very easy to

2005
01:21:04,239 --> 01:21:06,080
recover the security of the scheme in

2006
01:21:06,080 --> 01:21:08,960
like polynomial time

2007
01:21:08,960 --> 01:21:10,320
so here's the important thing to

2008
01:21:10,320 --> 01:21:12,080
remember is that your matrices are the

2009
01:21:12,080 --> 01:21:14,719
rfq but as i said the solution is over

2010
01:21:14,719 --> 01:21:16,639
fqn

2011
01:21:16,639 --> 01:21:18,800
and this is really crucial because if

2012
01:21:18,800 --> 01:21:21,520
you have a low rank matrix like this

2013
01:21:21,520 --> 01:21:24,239
if you apply the frobenius map

2014
01:21:24,239 --> 01:21:26,480
x to the x power q on the entries you

2015
01:21:26,480 --> 01:21:28,560
will get another solution

2016
01:21:28,560 --> 01:21:30,800
and basically all the wrong dissolution

2017
01:21:30,800 --> 01:21:33,679
that we expect of this form

2018
01:21:33,679 --> 01:21:36,320
so this means that even if you fix

2019
01:21:36,320 --> 01:21:38,480
one ui variable to one in your system

2020
01:21:38,480 --> 01:21:41,199
you'll still get end solution which is

2021
01:21:41,199 --> 01:21:42,960
huge

2022
01:21:42,960 --> 01:21:44,400
and this means that

2023
01:21:44,400 --> 01:21:46,639
the linearization techniques or xl that

2024
01:21:46,639 --> 01:21:48,239
i mentioned earlier you cannot really

2025
01:21:48,239 --> 01:21:50,400
apply them because this would mean that

2026
01:21:50,400 --> 01:21:52,239
you would have a large kernel in your

2027
01:21:52,239 --> 01:21:54,320
matrix it would be infeasible to recover

2028
01:21:54,320 --> 01:21:57,360
your solution

2029
01:21:57,360 --> 01:21:59,520
and this was a bit an issue because we

2030
01:21:59,520 --> 01:22:01,679
really wanted to apply the support

2031
01:22:01,679 --> 01:22:04,560
minors modeling which is usually

2032
01:22:04,560 --> 01:22:06,719
used to solve minor

2033
01:22:06,719 --> 01:22:08,560
so in fact we'll see that our attack

2034
01:22:08,560 --> 01:22:10,480
will be instead of linearizing a system

2035
01:22:10,480 --> 01:22:11,760
it will be like

2036
01:22:11,760 --> 01:22:14,000
more convenient to see that as a form of

2037
01:22:14,000 --> 01:22:16,159
ground over this computation

2038
01:22:16,159 --> 01:22:18,159
so here we start from this matrix and in

2039
01:22:18,159 --> 01:22:20,239
fact we are going to restrict ourselves

2040
01:22:20,239 --> 01:22:24,639
to only a subset of columns in there

2041
01:22:24,639 --> 01:22:26,320
so also there is a very important

2042
01:22:26,320 --> 01:22:28,480
property of superb minors which was

2043
01:22:28,480 --> 01:22:30,560
already pointed out in the initial paper

2044
01:22:30,560 --> 01:22:31,520
is that

2045
01:22:31,520 --> 01:22:33,679
this system is a bilinear system so in

2046
01:22:33,679 --> 01:22:35,920
fact your set of monomials this one so

2047
01:22:35,920 --> 01:22:37,840
the set of monomers is a very particular

2048
01:22:37,840 --> 01:22:39,520
shape

2049
01:22:39,520 --> 01:22:40,560
and here

2050
01:22:40,560 --> 01:22:41,840
ct

2051
01:22:41,840 --> 01:22:44,719
refers to what to a maximal minor of the

2052
01:22:44,719 --> 01:22:46,880
matrix c so instead of having the

2053
01:22:46,880 --> 01:22:47,920
entries

2054
01:22:47,920 --> 01:22:49,840
of the circuit matrix c as variables

2055
01:22:49,840 --> 01:22:51,360
we'll take

2056
01:22:51,360 --> 01:22:53,600
the the maximal miners and in fact we'll

2057
01:22:53,600 --> 01:22:55,520
see we can see that there is no

2058
01:22:55,520 --> 01:22:58,800
ambiguity by doing that

2059
01:22:59,040 --> 01:23:01,199
and it turns out that in the case of

2060
01:23:01,199 --> 01:23:04,480
gems we have more equations that than

2061
01:23:04,480 --> 01:23:06,960
this number of monomials

2062
01:23:06,960 --> 01:23:08,800
but i said already that it was not

2063
01:23:08,800 --> 01:23:11,520
possible to linearize but still this

2064
01:23:11,520 --> 01:23:13,920
means that all equations cannot be

2065
01:23:13,920 --> 01:23:15,600
linearly independent

2066
01:23:15,600 --> 01:23:17,920
and actually as the number of solutions

2067
01:23:17,920 --> 01:23:19,520
was equal to n

2068
01:23:19,520 --> 01:23:22,080
we assume that the wrong defect in our

2069
01:23:22,080 --> 01:23:24,480
system is also equal to n and basically

2070
01:23:24,480 --> 01:23:28,400
we have this equality for the dimension

2071
01:23:29,120 --> 01:23:32,000
so now we have already seen that in hfe

2072
01:23:32,000 --> 01:23:34,800
i could fix one ui variable to one

2073
01:23:34,800 --> 01:23:37,440
and in fact in in our attack what we do

2074
01:23:37,440 --> 01:23:38,960
is that we have another degree of

2075
01:23:38,960 --> 01:23:41,120
freedom on the other block of variables

2076
01:23:41,120 --> 01:23:42,960
which really comes from

2077
01:23:42,960 --> 01:23:44,480
the structure of the support minor

2078
01:23:44,480 --> 01:23:46,239
system

2079
01:23:46,239 --> 01:23:48,080
and by fixing these two variables we

2080
01:23:48,080 --> 01:23:50,560
notice that our initial set

2081
01:23:50,560 --> 01:23:53,120
of degree two monomials is reduced to

2082
01:23:53,120 --> 01:23:55,840
this one now we have less degree two

2083
01:23:55,840 --> 01:23:58,080
monomials

2084
01:23:58,080 --> 01:24:00,400
and once again we notice that we still

2085
01:24:00,400 --> 01:24:03,440
have an inequality of the same kind

2086
01:24:03,440 --> 01:24:05,199
between the number of equations and the

2087
01:24:05,199 --> 01:24:06,800
number of monomials

2088
01:24:06,800 --> 01:24:08,480
so here this means

2089
01:24:08,480 --> 01:24:11,280
that we are going to kill

2090
01:24:11,280 --> 01:24:14,320
the greater monomials in some equations

2091
01:24:14,320 --> 01:24:16,159
in particular this means that by

2092
01:24:16,159 --> 01:24:18,480
performing gaussian immunization we can

2093
01:24:18,480 --> 01:24:20,239
generate

2094
01:24:20,239 --> 01:24:23,199
a smaller system l which is only made

2095
01:24:23,199 --> 01:24:25,120
of linear equations

2096
01:24:25,120 --> 01:24:26,560
and this is really helpful because

2097
01:24:26,560 --> 01:24:28,560
several times you have seen that each

2098
01:24:28,560 --> 01:24:31,040
time that you have your linear equation

2099
01:24:31,040 --> 01:24:32,320
you can use it

2100
01:24:32,320 --> 01:24:34,560
to remove some variables in your initial

2101
01:24:34,560 --> 01:24:36,960
system

2102
01:24:37,440 --> 01:24:39,199
and here it's even more advantageous

2103
01:24:39,199 --> 01:24:40,080
because

2104
01:24:40,080 --> 01:24:41,360
we analyze

2105
01:24:41,360 --> 01:24:42,239
the

2106
01:24:42,239 --> 01:24:43,120
shape

2107
01:24:43,120 --> 01:24:46,080
of such system l and also we have plenty

2108
01:24:46,080 --> 01:24:47,280
of equations

2109
01:24:47,280 --> 01:24:49,440
so we can make sure that we kill all ct

2110
01:24:49,440 --> 01:24:52,000
variables in our system which will be

2111
01:24:52,000 --> 01:24:54,000
the nasty part

2112
01:24:54,000 --> 01:24:56,560
and by substitution if you substitute

2113
01:24:56,560 --> 01:24:58,880
this linear equations in your initial

2114
01:24:58,880 --> 01:25:00,880
system you can produce

2115
01:25:00,880 --> 01:25:04,159
a second system s which is quadratic

2116
01:25:04,159 --> 01:25:06,080
in the ui variables because i removed

2117
01:25:06,080 --> 01:25:07,679
all the c variables

2118
01:25:07,679 --> 01:25:09,360
and it has a very nice property it is

2119
01:25:09,360 --> 01:25:10,960
very over defined this means that we

2120
01:25:10,960 --> 01:25:14,639
have a lot more equations that variable

2121
01:25:15,440 --> 01:25:18,400
so finally how do we solve this s

2122
01:25:18,400 --> 01:25:19,440
well i

2123
01:25:19,440 --> 01:25:21,440
don't have a more clever way to do that

2124
01:25:21,440 --> 01:25:22,960
applying grouping basis which is

2125
01:25:22,960 --> 01:25:25,120
something really like costly in general

2126
01:25:25,120 --> 01:25:26,400
but here

2127
01:25:26,400 --> 01:25:28,239
since our system once again it's very

2128
01:25:28,239 --> 01:25:29,840
over defined in fact

2129
01:25:29,840 --> 01:25:32,719
we can show that uh the grommet of this

2130
01:25:32,719 --> 01:25:34,480
computation terminates really early

2131
01:25:34,480 --> 01:25:36,639
determinants is degree two so basically

2132
01:25:36,639 --> 01:25:38,080
this means that we don't don't go at

2133
01:25:38,080 --> 01:25:40,560
higher degree

2134
01:25:40,560 --> 01:25:43,760
and we have a small condition here but

2135
01:25:43,760 --> 01:25:44,800
in fact

2136
01:25:44,800 --> 01:25:46,800
it turns out that on the parameter of

2137
01:25:46,800 --> 01:25:48,880
james these conditions is very easy

2138
01:25:48,880 --> 01:25:51,280
limit

2139
01:25:52,159 --> 01:25:54,320
so to sum up our first contribution is

2140
01:25:54,320 --> 01:25:57,280
like we have our type which is first

2141
01:25:57,280 --> 01:26:00,719
we generate this system l by performing

2142
01:26:00,719 --> 01:26:02,719
the gaussian elimination and then we

2143
01:26:02,719 --> 01:26:04,320
have a second step which is the just

2144
01:26:04,320 --> 01:26:06,880
group noises

2145
01:26:06,880 --> 01:26:09,360
but i said that this second step is like

2146
01:26:09,360 --> 01:26:12,639
cheap so in fact it turns out that the

2147
01:26:12,639 --> 01:26:14,400
dominant cost in the attack is the first

2148
01:26:14,400 --> 01:26:16,560
one

2149
01:26:16,560 --> 01:26:18,560
so here you can you have the comparison

2150
01:26:18,560 --> 01:26:20,639
between our attack and the one of taoi

2151
01:26:20,639 --> 01:26:22,400
talon

2152
01:26:22,400 --> 01:26:24,719
so you already see that the initial

2153
01:26:24,719 --> 01:26:27,120
attack was quite efficient on the

2154
01:26:27,120 --> 01:26:28,960
parameters

2155
01:26:28,960 --> 01:26:30,080
but still

2156
01:26:30,080 --> 01:26:31,760
it has been shown that also you could

2157
01:26:31,760 --> 01:26:33,760
repair gems you could still do it you

2158
01:26:33,760 --> 01:26:35,679
could still make it against a digital

2159
01:26:35,679 --> 01:26:37,840
attack

2160
01:26:37,920 --> 01:26:41,040
so also a tarot already proposed to use

2161
01:26:41,040 --> 01:26:43,920
support minor so if you have a

2162
01:26:43,920 --> 01:26:46,239
colon corresponding to this complexity

2163
01:26:46,239 --> 01:26:48,080
but they provide absolutely no

2164
01:26:48,080 --> 01:26:50,400
complexity analysis so this is just a

2165
01:26:50,400 --> 01:26:53,120
pure conjecture

2166
01:26:53,120 --> 01:26:55,520
and you see that our attack first

2167
01:26:55,520 --> 01:26:58,320
we have like a proof of the complexity

2168
01:26:58,320 --> 01:27:01,520
formula and also it's much more powerful

2169
01:27:01,520 --> 01:27:03,440
than the former attacks

2170
01:27:03,440 --> 01:27:06,320
and basically this makes that the atoms

2171
01:27:06,320 --> 01:27:08,800
repair gems which were like immune to

2172
01:27:08,800 --> 01:27:11,280
the attack of serotonin now they are

2173
01:27:11,280 --> 01:27:12,719
broken as well

2174
01:27:12,719 --> 01:27:14,400
and we believe that

2175
01:27:14,400 --> 01:27:17,679
coming up with a an hiv time scheme

2176
01:27:17,679 --> 01:27:20,719
which will resist with to our attack

2177
01:27:20,719 --> 01:27:24,320
would be quite inefficient

2178
01:27:26,480 --> 01:27:29,520
so for our second contribution we are

2179
01:27:29,520 --> 01:27:31,280
not restricted to

2180
01:27:31,280 --> 01:27:32,480
gems

2181
01:27:32,480 --> 01:27:34,719
and hf anymore like here you have to

2182
01:27:34,719 --> 01:27:35,840
imagine

2183
01:27:35,840 --> 01:27:37,679
a random meaning instance that you want

2184
01:27:37,679 --> 01:27:39,520
to solve and we are going to solve it

2185
01:27:39,520 --> 01:27:41,760
using sport miners

2186
01:27:41,760 --> 01:27:43,840
and here what we try to do is trying to

2187
01:27:43,840 --> 01:27:45,280
analyze

2188
01:27:45,280 --> 01:27:47,360
the memory access costs which can occur

2189
01:27:47,360 --> 01:27:51,199
when we perform this kind of attacks

2190
01:27:51,199 --> 01:27:53,440
so the initial motivation for this work

2191
01:27:53,440 --> 01:27:56,080
was rainbow and the rectangular minor

2192
01:27:56,080 --> 01:27:58,560
attack which was presented at fuel crypt

2193
01:27:58,560 --> 01:28:01,760
last year this is a mineral attack

2194
01:28:01,760 --> 01:28:05,199
because this attack clearly breaks

2195
01:28:05,199 --> 01:28:07,120
the parameters of the scheme in the ram

2196
01:28:07,120 --> 01:28:09,280
model so well you don't really care

2197
01:28:09,280 --> 01:28:10,239
about

2198
01:28:10,239 --> 01:28:13,040
all these memory access costs

2199
01:28:13,040 --> 01:28:14,719
but you know it's perfectly legitimate

2200
01:28:14,719 --> 01:28:17,440
to try to include them in the the cost

2201
01:28:17,440 --> 01:28:19,120
of the attack because especially for

2202
01:28:19,120 --> 01:28:21,520
algebraic attacks it's known that it can

2203
01:28:21,520 --> 01:28:23,520
be a bottleneck

2204
01:28:23,520 --> 01:28:25,760
so this is what was done in the red

2205
01:28:25,760 --> 01:28:28,560
rainbow response by the rainbow team

2206
01:28:28,560 --> 01:28:31,760
so in fact they proposed to use the 2d

2207
01:28:31,760 --> 01:28:33,679
nearest neighbor model to analyze this

2208
01:28:33,679 --> 01:28:35,440
cost

2209
01:28:35,440 --> 01:28:37,760
and in fact if they assume

2210
01:28:37,760 --> 01:28:39,840
some randomness

2211
01:28:39,840 --> 01:28:41,760
on the memory access patterns which

2212
01:28:41,760 --> 01:28:43,840
occurred in this attack which they

2213
01:28:43,840 --> 01:28:46,719
showed that the attack by balance

2214
01:28:46,719 --> 01:28:50,239
was above the security level

2215
01:28:50,239 --> 01:28:53,280
and our method was what if this memoir

2216
01:28:53,280 --> 01:28:56,080
excess patterns are not from them like

2217
01:28:56,080 --> 01:28:57,360
is the attack

2218
01:28:57,360 --> 01:28:58,400
really

2219
01:28:58,400 --> 01:29:01,520
a threat against the scheme

2220
01:29:01,520 --> 01:29:04,159
so first i need to explain a bit more

2221
01:29:04,159 --> 01:29:06,000
what is this model

2222
01:29:06,000 --> 01:29:09,360
so initially it comes from the n2 prime

2223
01:29:09,360 --> 01:29:10,639
submissions

2224
01:29:10,639 --> 01:29:13,120
and it is essentially based on energy

2225
01:29:13,120 --> 01:29:14,960
consumption so in this model you your

2226
01:29:14,960 --> 01:29:16,639
memory locations

2227
01:29:16,639 --> 01:29:18,719
are evenly distributed

2228
01:29:18,719 --> 01:29:20,560
over a 2d surface

2229
01:29:20,560 --> 01:29:22,960
and also

2230
01:29:22,960 --> 01:29:26,000
uh this density is limited so this means

2231
01:29:26,000 --> 01:29:29,360
that the main overhead is to uh

2232
01:29:29,360 --> 01:29:31,840
is essentially proportional to the

2233
01:29:31,840 --> 01:29:33,440
distance which is covered by a bit of

2234
01:29:33,440 --> 01:29:35,920
data but you also have to take into

2235
01:29:35,920 --> 01:29:38,159
account a second cost which is the

2236
01:29:38,159 --> 01:29:42,400
distance traveled by memory addresses

2237
01:29:43,520 --> 01:29:45,600
so what sort of computation do we have

2238
01:29:45,600 --> 01:29:47,840
to perform in this kind of attack i

2239
01:29:47,840 --> 01:29:50,560
recall you that we have our matrix mq

2240
01:29:50,560 --> 01:29:52,320
which was associated to the support

2241
01:29:52,320 --> 01:29:54,320
minor system and we want to compute its

2242
01:29:54,320 --> 01:29:55,760
kernel

2243
01:29:55,760 --> 01:29:58,480
so we do that with the widm algorithm

2244
01:29:58,480 --> 01:30:01,679
which is essentially like several matrix

2245
01:30:01,679 --> 01:30:04,159
vector products like this

2246
01:30:04,159 --> 01:30:05,520
and here

2247
01:30:05,520 --> 01:30:08,080
it's a bit counterintuitive but even if

2248
01:30:08,080 --> 01:30:11,280
our matrix mq is large this is not the

2249
01:30:11,280 --> 01:30:13,760
bottleneck of the computation because

2250
01:30:13,760 --> 01:30:15,600
it's also very sparse so in fact we are

2251
01:30:15,600 --> 01:30:16,639
going to

2252
01:30:16,639 --> 01:30:19,679
generate all the entries on the fly and

2253
01:30:19,679 --> 01:30:22,560
we don't need to store the matrix

2254
01:30:22,560 --> 01:30:25,920
however our vector v

2255
01:30:25,920 --> 01:30:27,920
will be stored in memory and it will be

2256
01:30:27,920 --> 01:30:30,080
the most costly part

2257
01:30:30,080 --> 01:30:33,199
to store the coefficients on v and also

2258
01:30:33,199 --> 01:30:36,880
access the coefficient of v each time

2259
01:30:36,880 --> 01:30:40,400
we need them for the computation

2260
01:30:40,560 --> 01:30:43,199
so now to compute our matrix vector

2261
01:30:43,199 --> 01:30:45,199
products in fact it's easily seen to be

2262
01:30:45,199 --> 01:30:48,320
a several row times with product

2263
01:30:48,320 --> 01:30:51,360
and now i will explain how naively you

2264
01:30:51,360 --> 01:30:53,760
compute such a product

2265
01:30:53,760 --> 01:30:55,760
so in fact you have a rule times vector

2266
01:30:55,760 --> 01:30:58,080
product this is the same thing as more

2267
01:30:58,080 --> 01:31:02,960
or less the sum of f q times fq terms

2268
01:31:02,960 --> 01:31:04,320
and each

2269
01:31:04,320 --> 01:31:06,800
non-zero term will correspond to a

2270
01:31:06,800 --> 01:31:09,280
nonzero coefficient in euro

2271
01:31:09,280 --> 01:31:11,440
but you know since your matrix comes

2272
01:31:11,440 --> 01:31:13,679
from an algebraic system in fact

2273
01:31:13,679 --> 01:31:15,760
in non-coefficient

2274
01:31:15,760 --> 01:31:17,600
non-zero coefficients in the row is

2275
01:31:17,600 --> 01:31:19,840
directly related

2276
01:31:19,840 --> 01:31:21,600
to the known coefficients in your

2277
01:31:21,600 --> 01:31:23,600
initial system

2278
01:31:23,600 --> 01:31:26,239
and then for each of these non-zero

2279
01:31:26,239 --> 01:31:28,000
coefficients

2280
01:31:28,000 --> 01:31:30,639
the central processor will have to send

2281
01:31:30,639 --> 01:31:33,199
a read request to the memory locations

2282
01:31:33,199 --> 01:31:36,320
but here the memory is of size the size

2283
01:31:36,320 --> 01:31:38,080
of the vector and the vector is very big

2284
01:31:38,080 --> 01:31:41,040
so this is costly

2285
01:31:42,080 --> 01:31:44,560
so the very high overview of

2286
01:31:44,560 --> 01:31:47,840
approach is uh try to cut this main

2287
01:31:47,840 --> 01:31:50,400
memory into small pieces so we have a

2288
01:31:50,400 --> 01:31:52,400
partition pi like this

2289
01:31:52,400 --> 01:31:54,480
and in fact instead of having

2290
01:31:54,480 --> 01:31:57,120
a central processor which computes

2291
01:31:57,120 --> 01:31:59,920
this four times v product now we have

2292
01:31:59,920 --> 01:32:02,719
a local processor which computes what i

2293
01:32:02,719 --> 01:32:04,880
call a partial sum

2294
01:32:04,880 --> 01:32:07,840
r by i times v by i

2295
01:32:07,840 --> 01:32:10,159
and in fact from these partial sums

2296
01:32:10,159 --> 01:32:11,040
it will

2297
01:32:11,040 --> 01:32:14,000
the only remaining part is to gather

2298
01:32:14,000 --> 01:32:16,480
them by a central accumulator which will

2299
01:32:16,480 --> 01:32:18,320
send them to obtain

2300
01:32:18,320 --> 01:32:20,560
our final product

2301
01:32:20,560 --> 01:32:23,520
so why it's invintageous because first

2302
01:32:23,520 --> 01:32:26,159
using the structure of our system we can

2303
01:32:26,159 --> 01:32:28,800
make that only a small number of

2304
01:32:28,800 --> 01:32:31,120
partitions will be responsible

2305
01:32:31,120 --> 01:32:32,639
for one

2306
01:32:32,639 --> 01:32:34,239
row times three products so this means

2307
01:32:34,239 --> 01:32:37,120
that only a few partial sums need to be

2308
01:32:37,120 --> 01:32:39,360
sent long distance so this is quite we

2309
01:32:39,360 --> 01:32:41,920
try to reduce the cost like this

2310
01:32:41,920 --> 01:32:44,239
another advantage is that even if the

2311
01:32:44,239 --> 01:32:46,239
local processor does exactly the same

2312
01:32:46,239 --> 01:32:47,440
operations

2313
01:32:47,440 --> 01:32:49,840
as the central processor of v4 all the

2314
01:32:49,840 --> 01:32:51,920
operations are done locally so we have

2315
01:32:51,920 --> 01:32:54,480
no extra cost like this

2316
01:32:54,480 --> 01:32:56,560
and also there is another optimization

2317
01:32:56,560 --> 01:32:58,320
which comes from the fact

2318
01:32:58,320 --> 01:33:01,920
that holy ques some equations have no

2319
01:33:01,920 --> 01:33:04,880
same non-zero positions because some

2320
01:33:04,880 --> 01:33:07,280
polynomials have the same monomial

2321
01:33:07,280 --> 01:33:09,199
content

2322
01:33:09,199 --> 01:33:11,600
and so from that this means that the

2323
01:33:11,600 --> 01:33:13,600
memory access patterns

2324
01:33:13,600 --> 01:33:16,239
in your attack will be the same

2325
01:33:16,239 --> 01:33:19,360
so it was quite helpful to group

2326
01:33:19,360 --> 01:33:22,320
all this equation in a batch so that in

2327
01:33:22,320 --> 01:33:25,360
fact each call to the memory of size the

2328
01:33:25,360 --> 01:33:27,520
size of the the element of the partition

2329
01:33:27,520 --> 01:33:30,159
we do it only once per batch

2330
01:33:30,159 --> 01:33:31,679
and similarly

2331
01:33:31,679 --> 01:33:34,800
memory addresses will be sent only once

2332
01:33:34,800 --> 01:33:37,840
per batch

2333
01:33:38,320 --> 01:33:40,000
so there are things that i don't really

2334
01:33:40,000 --> 01:33:43,040
have time to discuss uh the attack uh by

2335
01:33:43,040 --> 01:33:45,760
balance also uses the p equals zero

2336
01:33:45,760 --> 01:33:47,679
equations which are not meanwhile

2337
01:33:47,679 --> 01:33:50,800
equations which are simply equations

2338
01:33:50,800 --> 01:33:52,480
which come from the public key of

2339
01:33:52,480 --> 01:33:54,960
rainbow and we show how to include them

2340
01:33:54,960 --> 01:33:56,719
in the model

2341
01:33:56,719 --> 01:33:58,239
and in fact they are very helpful

2342
01:33:58,239 --> 01:33:59,280
because

2343
01:33:59,280 --> 01:34:00,960
from a memory point of view they are

2344
01:34:00,960 --> 01:34:03,760
only tackled by only one local processor

2345
01:34:03,760 --> 01:34:06,400
so here there is no need to gather the

2346
01:34:06,400 --> 01:34:10,400
partial sums by the central accumulator

2347
01:34:10,400 --> 01:34:13,199
also you may say that here you have

2348
01:34:13,199 --> 01:34:15,360
introduced several processors a bit

2349
01:34:15,360 --> 01:34:17,920
everywhere so maybe there is some extra

2350
01:34:17,920 --> 01:34:19,840
cost maybe you have to think about the

2351
01:34:19,840 --> 01:34:22,080
cost of parallelization parallelization

2352
01:34:22,080 --> 01:34:23,360
etc

2353
01:34:23,360 --> 01:34:25,920
and so if you want uh some of these

2354
01:34:25,920 --> 01:34:28,159
costs are neglected and we discuss about

2355
01:34:28,159 --> 01:34:30,159
that more more in more details in the

2356
01:34:30,159 --> 01:34:33,159
paper

2357
01:34:33,520 --> 01:34:37,440
so finally we can see a bit what it can

2358
01:34:37,440 --> 01:34:40,080
give for the rainbow parameters so here

2359
01:34:40,080 --> 01:34:43,280
you have the complexity of the attack

2360
01:34:43,280 --> 01:34:46,159
if you don't take memory into account so

2361
01:34:46,159 --> 01:34:48,159
in the wrong model you see that indeed

2362
01:34:48,159 --> 01:34:50,320
it's below the security

2363
01:34:50,320 --> 01:34:53,119
and here you have two costs in the 2d

2364
01:34:53,119 --> 01:34:56,159
model so the one is more or less the one

2365
01:34:56,159 --> 01:34:57,199
claimed

2366
01:34:57,199 --> 01:35:01,119
by the response if you have like random

2367
01:35:01,119 --> 01:35:03,119
memory access patterns

2368
01:35:03,119 --> 01:35:05,280
and here is the one obtained with their

2369
01:35:05,280 --> 01:35:07,360
strategies so you see that

2370
01:35:07,360 --> 01:35:10,639
mostly you gain over 20 bits each time

2371
01:35:10,639 --> 01:35:12,960
and hopefully or

2372
01:35:12,960 --> 01:35:15,280
sadly for the designers we go below the

2373
01:35:15,280 --> 01:35:16,880
street target

2374
01:35:16,880 --> 01:35:19,199
so yeah i really don't claim that this

2375
01:35:19,199 --> 01:35:21,679
cost is really accurate

2376
01:35:21,679 --> 01:35:24,960
this is mostly to say that

2377
01:35:24,960 --> 01:35:27,440
we cannot just say that

2378
01:35:27,440 --> 01:35:30,000
the scheme is saved just using like

2379
01:35:30,000 --> 01:35:32,159
memory because this the situation is

2380
01:35:32,159 --> 01:35:34,719
probably in between or maybe like even

2381
01:35:34,719 --> 01:35:36,480
smaller or maybe larger we don't know

2382
01:35:36,480 --> 01:35:38,639
but this is just to point out that

2383
01:35:38,639 --> 01:35:40,840
things are probably more

2384
01:35:40,840 --> 01:35:43,760
complicated and in any case you probably

2385
01:35:43,760 --> 01:35:45,840
know that rainbow now it's broken on a

2386
01:35:45,840 --> 01:35:48,320
laptop so such a speculation is maybe

2387
01:35:48,320 --> 01:35:50,239
not needed for rainbow i don't know

2388
01:35:50,239 --> 01:35:52,639
personally i think it's not needed

2389
01:35:52,639 --> 01:35:54,960
but i want to point out the fact that

2390
01:35:54,960 --> 01:35:57,360
all this analysis is really dependent on

2391
01:35:57,360 --> 01:35:59,920
super minors and not really on rainbow

2392
01:35:59,920 --> 01:36:02,480
so this means that you could apply it to

2393
01:36:02,480 --> 01:36:05,520
other minor attacks which uses a super

2394
01:36:05,520 --> 01:36:07,600
minors as a subroutine and there are

2395
01:36:07,600 --> 01:36:08,880
still like

2396
01:36:08,880 --> 01:36:10,800
constructions which rely on the plain

2397
01:36:10,800 --> 01:36:12,239
mineral problem and which are not

2398
01:36:12,239 --> 01:36:13,360
rainbow

2399
01:36:13,360 --> 01:36:15,600
so thank you for intention and

2400
01:36:15,600 --> 01:36:18,719
i'll be able to answer

2401
01:36:22,960 --> 01:36:24,719
thank you for this very interesting talk

2402
01:36:24,719 --> 01:36:26,800
with plenty of nice results are there

2403
01:36:26,800 --> 01:36:30,480
any questions in the audience here

2404
01:36:33,760 --> 01:36:35,440
okay i also don't see any questions on

2405
01:36:35,440 --> 01:36:37,119
zoom

2406
01:36:37,119 --> 01:36:38,400
i i have one question i'm kind of

2407
01:36:38,400 --> 01:36:40,400
wondering about which is that uh there

2408
01:36:40,400 --> 01:36:42,560
are rumors that maybe

2409
01:36:42,560 --> 01:36:44,719
uh playing uov without the rainbow

2410
01:36:44,719 --> 01:36:46,880
structure will be submitted to the next

2411
01:36:46,880 --> 01:36:47,920
nest call

2412
01:36:47,920 --> 01:36:50,080
um does this analysis impact the

2413
01:36:50,080 --> 01:36:52,000
parameter choices for that or is it just

2414
01:36:52,000 --> 01:36:55,199
not really applicable in fact

2415
01:36:55,199 --> 01:36:57,600
as far as i know i i don't think for the

2416
01:36:57,600 --> 01:36:59,520
moment it's possible but

2417
01:36:59,520 --> 01:37:01,520
i presented what is called wrong attacks

2418
01:37:01,520 --> 01:37:03,520
and so far a wrong attacks are not a

2419
01:37:03,520 --> 01:37:06,560
threat against uob

2420
01:37:06,560 --> 01:37:08,719
uh there is also an interesting scheme

2421
01:37:08,719 --> 01:37:10,400
which is called mayo which is a variant

2422
01:37:10,400 --> 01:37:12,080
of eur maybe it will be submitted i

2423
01:37:12,080 --> 01:37:13,360
don't know

2424
01:37:13,360 --> 01:37:16,560
but so far there is they don't have any

2425
01:37:16,560 --> 01:37:18,960
relationship with wrong attacks

2426
01:37:18,960 --> 01:37:21,199
like the

2427
01:37:21,199 --> 01:37:24,000
schemes based on mineral i was

2428
01:37:24,000 --> 01:37:27,280
mentioning is more like a kind of

2429
01:37:27,280 --> 01:37:29,840
authentication scheme which uses the

2430
01:37:29,840 --> 01:37:32,159
knowledge of the solution of the mineral

2431
01:37:32,159 --> 01:37:35,199
problem to be like knowledge etc so this

2432
01:37:35,199 --> 01:37:37,119
is another kind of it's not signature

2433
01:37:37,119 --> 01:37:38,159
it's not really

2434
01:37:38,159 --> 01:37:40,159
it's a bit different

2435
01:37:40,159 --> 01:37:42,239
okay thank you um

2436
01:37:42,239 --> 01:37:44,239
i guess that ends this session so let's

2437
01:37:44,239 --> 01:37:48,119
first thank the speaker again

2438
01:37:50,719 --> 01:37:52,800
you

