1
00:00:11,920 --> 00:00:14,920
uh

2
00:01:16,960 --> 00:01:19,119
so good morning everyone

3
00:01:19,119 --> 00:01:21,280
welcome to the session about signatures

4
00:01:21,280 --> 00:01:24,479
we have three talks in this session

5
00:01:24,479 --> 00:01:27,600
and um the first speaker or the first uh

6
00:01:27,600 --> 00:01:29,360
presentation is about

7
00:01:29,360 --> 00:01:31,280
locally verifiable signature and key

8
00:01:31,280 --> 00:01:33,520
aggregation this is the joint work of

9
00:01:33,520 --> 00:01:37,360
rishab goyal and we not by kundalini

10
00:01:37,360 --> 00:01:40,400
and rishabh will give the talk

11
00:01:40,400 --> 00:01:42,560
so mark for the introduction uh am i a

12
00:01:42,560 --> 00:01:44,640
little loud or is that okay

13
00:01:44,640 --> 00:01:45,439
okay

14
00:01:45,439 --> 00:01:47,360
it feels a little loud to me

15
00:01:47,360 --> 00:01:50,159
uh yeah so thanks a lot for being here

16
00:01:50,159 --> 00:01:51,759
especially after the drum session it was

17
00:01:51,759 --> 00:01:53,520
a late night and everybody could make it

18
00:01:53,520 --> 00:01:54,720
it's a larger audience than i was

19
00:01:54,720 --> 00:01:55,759
expecting

20
00:01:55,759 --> 00:01:57,200
but okay so today i'm going to tell you

21
00:01:57,200 --> 00:01:58,960
more about locally verifiable signatures

22
00:01:58,960 --> 00:02:00,880
and pre-aggregation

23
00:02:00,880 --> 00:02:02,399
so the starting point of this talk is

24
00:02:02,399 --> 00:02:04,000
digital signatures which we need no

25
00:02:04,000 --> 00:02:05,119
introduction they are one of the most

26
00:02:05,119 --> 00:02:06,719
basic and fundamental building blocks of

27
00:02:06,719 --> 00:02:08,959
cryptography and basically using digital

28
00:02:08,959 --> 00:02:10,479
signatures we can sign messages

29
00:02:10,479 --> 00:02:12,400
digitally such that they cannot be

30
00:02:12,400 --> 00:02:14,080
forged they cannot be faked by anybody

31
00:02:14,080 --> 00:02:15,280
else and they can verify the

32
00:02:15,280 --> 00:02:17,840
authenticity of the underlying message

33
00:02:17,840 --> 00:02:19,840
and there are tons of applications where

34
00:02:19,840 --> 00:02:21,440
digital signatures are used in trying to

35
00:02:21,440 --> 00:02:24,239
create certificates or in blockchains

36
00:02:24,239 --> 00:02:26,080
for authenticated transactions or for

37
00:02:26,080 --> 00:02:28,319
even as simple uh functionality as

38
00:02:28,319 --> 00:02:30,480
trying to visit a web page we rely on

39
00:02:30,480 --> 00:02:32,000
digital signatures

40
00:02:32,000 --> 00:02:33,920
given the ubiquitous nature of digital

41
00:02:33,920 --> 00:02:36,239
signatures and numerous applications

42
00:02:36,239 --> 00:02:37,840
digital signatures have been studied in

43
00:02:37,840 --> 00:02:40,000
various different models one of the most

44
00:02:40,000 --> 00:02:41,920
well-known models of digital signatures

45
00:02:41,920 --> 00:02:43,440
is also called the aggregate signature

46
00:02:43,440 --> 00:02:45,840
model aggregate signatures are special

47
00:02:45,840 --> 00:02:47,519
types of digital signatures which have

48
00:02:47,519 --> 00:02:49,920
one very special property in addition to

49
00:02:49,920 --> 00:02:51,920
generating digital signatures you can

50
00:02:51,920 --> 00:02:54,640
publicly aggregate a bunch of signatures

51
00:02:54,640 --> 00:02:56,560
an unbounded sequence of signatures into

52
00:02:56,560 --> 00:02:58,480
one single short signature

53
00:02:58,480 --> 00:03:00,400
that typically means consider a sequence

54
00:03:00,400 --> 00:03:03,040
of l messages and signature pairs

55
00:03:03,040 --> 00:03:04,480
if this was an aggregate signature

56
00:03:04,480 --> 00:03:06,400
scheme then you can compress all these l

57
00:03:06,400 --> 00:03:08,319
signatures you can aggregate them into

58
00:03:08,319 --> 00:03:10,720
one single short aggregated signature

59
00:03:10,720 --> 00:03:12,720
and the property is that you can verify

60
00:03:12,720 --> 00:03:15,280
you can use this aggregated signature to

61
00:03:15,280 --> 00:03:17,519
verify all the l messages authenticity

62
00:03:17,519 --> 00:03:19,519
of all the error messages at the same

63
00:03:19,519 --> 00:03:20,959
thereby reducing the total space

64
00:03:20,959 --> 00:03:23,200
requirement on the system

65
00:03:23,200 --> 00:03:25,280
and aggregate signatures have seen tons

66
00:03:25,280 --> 00:03:27,200
of applications because they guarantee

67
00:03:27,200 --> 00:03:30,159
unforgeability for all signed messages

68
00:03:30,159 --> 00:03:31,680
even after you sort of perform this

69
00:03:31,680 --> 00:03:33,680
compression and aggregation step and the

70
00:03:33,680 --> 00:03:35,760
applications range from trying to sort

71
00:03:35,760 --> 00:03:38,400
of compress uh certificate chains or

72
00:03:38,400 --> 00:03:41,519
trying to use them in secure bg uh bgp

73
00:03:41,519 --> 00:03:43,599
route attestations or even in trying to

74
00:03:43,599 --> 00:03:45,440
sort of reduce the footprint of digital

75
00:03:45,440 --> 00:03:46,959
component or the cryptographic component

76
00:03:46,959 --> 00:03:48,319
on blockchains

77
00:03:48,319 --> 00:03:50,080
and due to the ever growing nature of

78
00:03:50,080 --> 00:03:51,840
the number of applications aggregate

79
00:03:51,840 --> 00:03:54,080
signatures unlocks it's very interesting

80
00:03:54,080 --> 00:03:55,040
that

81
00:03:55,040 --> 00:03:56,720
and how many different new ways we can

82
00:03:56,720 --> 00:03:58,799
use aggregate signatures

83
00:03:58,799 --> 00:04:00,400
and although aggregate signatures are

84
00:04:00,400 --> 00:04:02,000
like a fantastic object they have been

85
00:04:02,000 --> 00:04:04,480
studied for numerous decades so far

86
00:04:04,480 --> 00:04:06,239
there are many different variants such

87
00:04:06,239 --> 00:04:08,159
as the single message waiting which is

88
00:04:08,159 --> 00:04:09,519
also called multi-signatures the

89
00:04:09,519 --> 00:04:11,360
synchronized aggregate signatures or

90
00:04:11,360 --> 00:04:13,120
sequential aggregate signatures we have

91
00:04:13,120 --> 00:04:14,959
multiple different constructions ranging

92
00:04:14,959 --> 00:04:16,079
from different assumptions such as

93
00:04:16,079 --> 00:04:17,839
pairings factorings multinational maps

94
00:04:17,839 --> 00:04:19,519
obfuscation whatever you like you can

95
00:04:19,519 --> 00:04:21,199
pick that assumption and come up with an

96
00:04:21,199 --> 00:04:22,400
appropriate

97
00:04:22,400 --> 00:04:24,240
aggregate signature signature scheme

98
00:04:24,240 --> 00:04:26,000
with relevant properties

99
00:04:26,000 --> 00:04:28,320
but given this progress there is just

100
00:04:28,320 --> 00:04:30,479
one big caveat that we face while using

101
00:04:30,479 --> 00:04:32,080
aggregate signatures they're a

102
00:04:32,080 --> 00:04:34,160
fascinating object but they have one big

103
00:04:34,160 --> 00:04:35,520
limitation which has not been addressed

104
00:04:35,520 --> 00:04:36,800
so far

105
00:04:36,800 --> 00:04:38,880
the problem is the cost of aggregate

106
00:04:38,880 --> 00:04:41,199
signatures it comes at the core or just

107
00:04:41,199 --> 00:04:42,960
here the aggregate signatures comes at

108
00:04:42,960 --> 00:04:44,800
the cost of verifying or for having a

109
00:04:44,800 --> 00:04:47,199
larger verification time so the verifier

110
00:04:47,199 --> 00:04:49,360
now needs to read the entire list of

111
00:04:49,360 --> 00:04:51,759
messages that it needs to verify

112
00:04:51,759 --> 00:04:53,919
so basically consider this example where

113
00:04:53,919 --> 00:04:55,680
we have these l messages and signatures

114
00:04:55,680 --> 00:04:56,479
pair

115
00:04:56,479 --> 00:04:58,800
and we have this aggregated signature to

116
00:04:58,800 --> 00:05:00,960
verify this aggregated signature you

117
00:05:00,960 --> 00:05:03,039
need the signature but you also need all

118
00:05:03,039 --> 00:05:04,479
the error messages

119
00:05:04,479 --> 00:05:05,919
and it seems kind of intuitive that you

120
00:05:05,919 --> 00:05:07,840
need to have all the elements that you

121
00:05:07,840 --> 00:05:09,520
are trying to verify

122
00:05:09,520 --> 00:05:11,280
but it turns out what's happening is

123
00:05:11,280 --> 00:05:12,800
that the compression that we're getting

124
00:05:12,800 --> 00:05:14,639
in aggregate signatures that's coming at

125
00:05:14,639 --> 00:05:16,800
the cost of a larger verification time

126
00:05:16,800 --> 00:05:18,479
suppose you only want to verify the

127
00:05:18,479 --> 00:05:20,400
authenticity of one particular message

128
00:05:20,400 --> 00:05:22,240
out of those l messages in an aggregated

129
00:05:22,240 --> 00:05:24,240
signature you still need to read all the

130
00:05:24,240 --> 00:05:25,680
elements you still need to run the

131
00:05:25,680 --> 00:05:27,680
verification algorithm on all different

132
00:05:27,680 --> 00:05:30,000
l messages

133
00:05:30,000 --> 00:05:31,520
and the question that we're interested

134
00:05:31,520 --> 00:05:34,080
in this work is can we basically

135
00:05:34,080 --> 00:05:36,400
aggregate signatures without sort of

136
00:05:36,400 --> 00:05:39,039
spending as much time to verify or more

137
00:05:39,039 --> 00:05:40,800
generally is there a much better

138
00:05:40,800 --> 00:05:43,039
space-time trade-off that we can uncover

139
00:05:43,039 --> 00:05:44,400
if we sort of revisit the notion of

140
00:05:44,400 --> 00:05:46,639
aggregate signatures

141
00:05:46,639 --> 00:05:47,360
so

142
00:05:47,360 --> 00:05:49,680
in this one okay so maybe my pointer is

143
00:05:49,680 --> 00:05:51,120
moving a little bit slower so sorry

144
00:05:51,120 --> 00:05:52,560
about that but yeah this was supposed to

145
00:05:52,560 --> 00:05:55,120
be here right now okay so in this work

146
00:05:55,120 --> 00:05:57,120
what we do is that we study this concept

147
00:05:57,120 --> 00:05:58,720
of locally verifiable aggregate

148
00:05:58,720 --> 00:06:00,639
signatures trying to sort of focus on

149
00:06:00,639 --> 00:06:02,080
this problem trying to fill this gap

150
00:06:02,080 --> 00:06:03,759
which has been left open for the longest

151
00:06:03,759 --> 00:06:04,560
time

152
00:06:04,560 --> 00:06:06,319
and to that and we define these locally

153
00:06:06,319 --> 00:06:08,080
verifiable aggregate signatures and the

154
00:06:08,080 --> 00:06:09,759
intuition behind locally verifiable

155
00:06:09,759 --> 00:06:11,919
aggregate signatures is as follows

156
00:06:11,919 --> 00:06:14,880
that the local verifier can basically

157
00:06:14,880 --> 00:06:17,120
verify an aggregated signature just for

158
00:06:17,120 --> 00:06:19,280
a single message it does not read

159
00:06:19,280 --> 00:06:21,840
read the entire list of messages

160
00:06:21,840 --> 00:06:24,319
and how could we possibly formalize that

161
00:06:24,319 --> 00:06:26,000
so let's just look again at the example

162
00:06:26,000 --> 00:06:28,560
of sign and aggregate so one possible

163
00:06:28,560 --> 00:06:30,560
idea could be okay there is a local

164
00:06:30,560 --> 00:06:32,639
verification algorithm in which the

165
00:06:32,639 --> 00:06:34,400
local verification algorithm just takes

166
00:06:34,400 --> 00:06:36,479
this input an aggregated signature and a

167
00:06:36,479 --> 00:06:38,639
single message and it basically outputs

168
00:06:38,639 --> 00:06:40,240
whether the message is a valid message

169
00:06:40,240 --> 00:06:42,880
or not as per this aggregate signature

170
00:06:42,880 --> 00:06:44,639
so this is the dream version it would be

171
00:06:44,639 --> 00:06:45,919
wonderful if we can build this because

172
00:06:45,919 --> 00:06:47,759
then this gives us not only compression

173
00:06:47,759 --> 00:06:50,960
but also very very fast verification

174
00:06:50,960 --> 00:06:51,919
and

175
00:06:51,919 --> 00:06:54,000
it turns out that if we want a local

176
00:06:54,000 --> 00:06:55,680
verification algorithm which only takes

177
00:06:55,680 --> 00:06:57,759
us a single message

178
00:06:57,759 --> 00:06:59,360
then it's quite good but it's too good

179
00:06:59,360 --> 00:07:00,319
to be true

180
00:07:00,319 --> 00:07:02,080
and the reason is that there's a very

181
00:07:02,080 --> 00:07:04,000
simple incompressibility argument which

182
00:07:04,000 --> 00:07:05,919
you can show you can use to show that

183
00:07:05,919 --> 00:07:08,080
this is impossible and the idea is as

184
00:07:08,080 --> 00:07:10,479
follows suppose there is a sequence of n

185
00:07:10,479 --> 00:07:12,720
messages messages could be integers one

186
00:07:12,720 --> 00:07:15,440
through n and a certain subset of these

187
00:07:15,440 --> 00:07:17,440
messages have been signed and have been

188
00:07:17,440 --> 00:07:19,520
aggregated now you only have the

189
00:07:19,520 --> 00:07:21,039
aggregate signature and suppose these

190
00:07:21,039 --> 00:07:22,560
locally verifiable aggregate signatures

191
00:07:22,560 --> 00:07:24,639
only take us and put a message one

192
00:07:24,639 --> 00:07:26,319
particular message so what you can do is

193
00:07:26,319 --> 00:07:27,919
that you can potentially sequence

194
00:07:27,919 --> 00:07:29,919
sequentially sort of just run through

195
00:07:29,919 --> 00:07:32,080
all the possible messages and check

196
00:07:32,080 --> 00:07:33,599
whether that particular message verified

197
00:07:33,599 --> 00:07:36,319
or not so depending upon which messages

198
00:07:36,319 --> 00:07:38,000
it verified for you can extract the

199
00:07:38,000 --> 00:07:40,400
entire list of messages which have been

200
00:07:40,400 --> 00:07:41,759
aggregated

201
00:07:41,759 --> 00:07:43,360
and using this you can basically recover

202
00:07:43,360 --> 00:07:45,680
the entire list from a short signature

203
00:07:45,680 --> 00:07:47,520
the signature does not grow with the

204
00:07:47,520 --> 00:07:49,520
number of uh messages that have been

205
00:07:49,520 --> 00:07:51,360
aggregated so basically sort of just

206
00:07:51,360 --> 00:07:52,560
here gives us that there's an

207
00:07:52,560 --> 00:07:54,400
incompressibility happening and we can't

208
00:07:54,400 --> 00:07:56,160
sort of just build this dream version of

209
00:07:56,160 --> 00:07:58,160
locally verifiable aggregate signatures

210
00:07:58,160 --> 00:07:59,919
so it seems like maybe there was no

211
00:07:59,919 --> 00:08:01,280
actual there was actually no gap

212
00:08:01,280 --> 00:08:02,879
aggregate signatures best thing that we

213
00:08:02,879 --> 00:08:05,199
can hope for but it turns out that if we

214
00:08:05,199 --> 00:08:06,000
sort of

215
00:08:06,000 --> 00:08:08,160
just maybe turn the tables a little bit

216
00:08:08,160 --> 00:08:09,680
or just think about the problem a little

217
00:08:09,680 --> 00:08:11,440
bit different then there is a way to get

218
00:08:11,440 --> 00:08:13,840
the best of both worlds and our idea in

219
00:08:13,840 --> 00:08:15,840
this case to avoid impossibility what

220
00:08:15,840 --> 00:08:17,360
we're going to design we're going to

221
00:08:17,360 --> 00:08:20,000
give the system a special

222
00:08:20,000 --> 00:08:22,080
uh hint generation algorithm to aid the

223
00:08:22,080 --> 00:08:24,319
local verification so the goal is still

224
00:08:24,319 --> 00:08:25,840
to make sure that the local verification

225
00:08:25,840 --> 00:08:27,599
is very efficient it does not grow with

226
00:08:27,599 --> 00:08:29,199
the entire list of messages that you

227
00:08:29,199 --> 00:08:31,120
have aggregated but maybe we can sort of

228
00:08:31,120 --> 00:08:33,120
just here make sure that there isn't

229
00:08:33,120 --> 00:08:34,799
possibly inefficient processing

230
00:08:34,799 --> 00:08:36,399
algorithm in that case you can generate

231
00:08:36,399 --> 00:08:38,479
some small hints and those hints could

232
00:08:38,479 --> 00:08:40,719
be used to aid the local verification

233
00:08:40,719 --> 00:08:43,440
algorithm and what that means is

234
00:08:43,440 --> 00:08:45,680
we again have this aggregate signature

235
00:08:45,680 --> 00:08:47,519
and now there is a local opening

236
00:08:47,519 --> 00:08:50,080
algorithm or a hint generation algorithm

237
00:08:50,080 --> 00:08:52,160
and this algorithm also takes us input a

238
00:08:52,160 --> 00:08:53,760
target message for which you want to

239
00:08:53,760 --> 00:08:56,160
generate a shorthand and the sequence of

240
00:08:56,160 --> 00:08:58,640
all messages and it basically computes a

241
00:08:58,640 --> 00:09:00,800
shorthand which is independent upon the

242
00:09:00,800 --> 00:09:03,040
of the entire list of messages and now

243
00:09:03,040 --> 00:09:04,959
the idea is that you can simply throw

244
00:09:04,959 --> 00:09:06,800
away this particular

245
00:09:06,800 --> 00:09:08,480
list of messages and just given the

246
00:09:08,480 --> 00:09:10,080
target message

247
00:09:10,080 --> 00:09:12,399
uh the aggregate signature as well as a

248
00:09:12,399 --> 00:09:14,080
shorthand you can sort of just run a

249
00:09:14,080 --> 00:09:15,839
special local verification algorithm to

250
00:09:15,839 --> 00:09:17,920
efficiently verify that this particular

251
00:09:17,920 --> 00:09:20,000
aggregate signature contains is a valid

252
00:09:20,000 --> 00:09:22,160
signature for a signature containing the

253
00:09:22,160 --> 00:09:24,719
message m

254
00:09:25,680 --> 00:09:27,440
so just trying to formalize a little bit

255
00:09:27,440 --> 00:09:29,200
further the local verification algorithm

256
00:09:29,200 --> 00:09:30,560
it takes this input this aggregate

257
00:09:30,560 --> 00:09:33,440
signature message m and this hint h and

258
00:09:33,440 --> 00:09:35,040
tells you whether it's invalid or

259
00:09:35,040 --> 00:09:37,120
invalid uh message

260
00:09:37,120 --> 00:09:39,279
and for security it's very important

261
00:09:39,279 --> 00:09:41,440
that we design these signatures such as

262
00:09:41,440 --> 00:09:42,640
such that we can guarantee

263
00:09:42,640 --> 00:09:45,200
unforgivability even when the adversary

264
00:09:45,200 --> 00:09:47,279
can control or can generate arbitrary

265
00:09:47,279 --> 00:09:49,519
hints because we don't want to rely on

266
00:09:49,519 --> 00:09:52,080
who's generating the hint or particular

267
00:09:52,080 --> 00:09:53,360
the local verifier because the local

268
00:09:53,360 --> 00:09:54,880
verifier doesn't even have the entire

269
00:09:54,880 --> 00:09:56,959
time to verify what the messages look

270
00:09:56,959 --> 00:09:58,160
like

271
00:09:58,160 --> 00:09:59,920
so the idea is basically that an

272
00:09:59,920 --> 00:10:01,680
attacker cannot create an aggregate

273
00:10:01,680 --> 00:10:04,800
signature as well as a hint such that it

274
00:10:04,800 --> 00:10:07,680
is a valid uh signature and hint pair

275
00:10:07,680 --> 00:10:09,200
for a particular message that was not

276
00:10:09,200 --> 00:10:11,200
signed by the challenger

277
00:10:11,200 --> 00:10:13,120
and if you don't sort of satisfy this

278
00:10:13,120 --> 00:10:14,320
property then it's insecure if you

279
00:10:14,320 --> 00:10:15,760
satisfy this property then you can sort

280
00:10:15,760 --> 00:10:17,600
of just yeah have this best of both

281
00:10:17,600 --> 00:10:18,640
worlds

282
00:10:18,640 --> 00:10:20,320
but at this point you might be thinking

283
00:10:20,320 --> 00:10:22,800
okay what's really going on we said that

284
00:10:22,800 --> 00:10:24,399
it's kind of impossible but we designed

285
00:10:24,399 --> 00:10:25,760
this local opening algorithm or the

286
00:10:25,760 --> 00:10:28,160
local uh hint generation algorithm that

287
00:10:28,160 --> 00:10:29,519
sort of just tried to aid this

288
00:10:29,519 --> 00:10:31,440
particular primitive locally verifiable

289
00:10:31,440 --> 00:10:33,200
aggregate images but why is it still

290
00:10:33,200 --> 00:10:34,880
interesting why can we sort of just

291
00:10:34,880 --> 00:10:37,120
still use that in many applications so

292
00:10:37,120 --> 00:10:38,640
let me sort of just here run through

293
00:10:38,640 --> 00:10:40,480
some potential applications where we can

294
00:10:40,480 --> 00:10:42,320
actually use the local verification

295
00:10:42,320 --> 00:10:44,160
algorithm as we have designed

296
00:10:44,160 --> 00:10:46,640
so consider the example of uh

297
00:10:46,640 --> 00:10:48,800
certificate transparency logs so

298
00:10:48,800 --> 00:10:50,720
certificate of transparency is just an

299
00:10:50,720 --> 00:10:52,640
internet standard in which we basically

300
00:10:52,640 --> 00:10:54,320
have multiple certificates which are

301
00:10:54,320 --> 00:10:57,120
stored by uh in a certificate log which

302
00:10:57,120 --> 00:10:58,640
which verify the authenticity of

303
00:10:58,640 --> 00:11:00,800
different web pages so in that case

304
00:11:00,800 --> 00:11:03,200
suppose a web browser needs to access

305
00:11:03,200 --> 00:11:05,519
and verify that a particular thing is

306
00:11:05,519 --> 00:11:07,200
valid or not it needs to go to the

307
00:11:07,200 --> 00:11:08,640
certificate transparency log it needs to

308
00:11:08,640 --> 00:11:11,279
verify the authenticity but what happens

309
00:11:11,279 --> 00:11:12,880
is that the certificate transparency log

310
00:11:12,880 --> 00:11:14,959
is pretty big using aggregate signatures

311
00:11:14,959 --> 00:11:17,200
we can compress the entire footprint the

312
00:11:17,200 --> 00:11:18,959
memory footprint that uh the log needs

313
00:11:18,959 --> 00:11:20,000
to keep

314
00:11:20,000 --> 00:11:21,920
but if we use aggregate signatures then

315
00:11:21,920 --> 00:11:24,240
each verifier which is simply basically

316
00:11:24,240 --> 00:11:27,200
a web browser or a particular small in a

317
00:11:27,200 --> 00:11:28,399
very

318
00:11:28,399 --> 00:11:30,720
low level device that needs to read the

319
00:11:30,720 --> 00:11:32,880
entire list of messages to verify that

320
00:11:32,880 --> 00:11:35,120
transparency law but using locally

321
00:11:35,120 --> 00:11:36,880
verifiable aggregate signatures we can

322
00:11:36,880 --> 00:11:39,200
just provide a small hint to the

323
00:11:39,200 --> 00:11:41,600
verifier so we can not only reduce the

324
00:11:41,600 --> 00:11:43,519
footprint on the server but you can also

325
00:11:43,519 --> 00:11:45,519
provide a short hint using which a

326
00:11:45,519 --> 00:11:47,600
verifier can efficiently verify the

327
00:11:47,600 --> 00:11:49,839
validity and we can sort of also sort of

328
00:11:49,839 --> 00:11:51,519
just imagine the same to be happening in

329
00:11:51,519 --> 00:11:54,240
blockchains imagine alice is a tenant

330
00:11:54,240 --> 00:11:56,880
that pays monthly rent to bob and alice

331
00:11:56,880 --> 00:11:59,440
sends some money over block over bitcoin

332
00:11:59,440 --> 00:12:02,000
monthly or whatever the rent is but bob

333
00:12:02,000 --> 00:12:03,200
doesn't want to store all these

334
00:12:03,200 --> 00:12:04,639
different transactions as different

335
00:12:04,639 --> 00:12:06,560
signatures it wants to store all these

336
00:12:06,560 --> 00:12:08,320
aggregate them together and store like

337
00:12:08,320 --> 00:12:10,240
one single aggregated signature in its

338
00:12:10,240 --> 00:12:12,000
particular uh

339
00:12:12,000 --> 00:12:14,240
in its particular wallet but now what

340
00:12:14,240 --> 00:12:17,120
happens is that uh whenever bob wants to

341
00:12:17,120 --> 00:12:18,800
spend this particular aggregate

342
00:12:18,800 --> 00:12:20,560
signature then it has to sort of provide

343
00:12:20,560 --> 00:12:22,639
all the sequence of messages but using

344
00:12:22,639 --> 00:12:24,480
aggregate these local verifiability

345
00:12:24,480 --> 00:12:27,200
property it can just generate a local uh

346
00:12:27,200 --> 00:12:29,279
a hint a short hint using which it can

347
00:12:29,279 --> 00:12:30,560
spend just one of those particular

348
00:12:30,560 --> 00:12:32,560
transactions it does not need to share

349
00:12:32,560 --> 00:12:34,480
all those transactions and it turns out

350
00:12:34,480 --> 00:12:37,200
just having this not only gives us an

351
00:12:37,200 --> 00:12:38,880
efficiency gain but also provides us

352
00:12:38,880 --> 00:12:41,120
some type of privacy guarantee because

353
00:12:41,120 --> 00:12:42,240
when you compress this then the

354
00:12:42,240 --> 00:12:44,160
shorthand is not going to leak all the

355
00:12:44,160 --> 00:12:45,279
information about the remaining

356
00:12:45,279 --> 00:12:47,360
transactions and i can go on and tell

357
00:12:47,360 --> 00:12:49,040
you more about applications through

358
00:12:49,040 --> 00:12:51,200
redactable signatures or even sort of

359
00:12:51,200 --> 00:12:53,040
just a general time space trade-offs

360
00:12:53,040 --> 00:12:54,560
which locally verifiable aggregate

361
00:12:54,560 --> 00:12:56,720
signatures sort of unlock so here is a

362
00:12:56,720 --> 00:12:58,959
table that's also present in the paper

363
00:12:58,959 --> 00:13:01,040
but it basically captures that using

364
00:13:01,040 --> 00:13:02,880
locally verifiable aggregate signatures

365
00:13:02,880 --> 00:13:05,120
we can basically cover the entire spread

366
00:13:05,120 --> 00:13:07,040
spread of what was covered by a banner

367
00:13:07,040 --> 00:13:09,120
of signatures or aggregate signatures or

368
00:13:09,120 --> 00:13:10,880
just using locally verifiable signatures

369
00:13:10,880 --> 00:13:12,560
directly so we can sort of just create

370
00:13:12,560 --> 00:13:15,040
like a very smooth trade-off between the

371
00:13:15,040 --> 00:13:16,639
server space the server time the per

372
00:13:16,639 --> 00:13:18,480
client space or the perk line running

373
00:13:18,480 --> 00:13:20,160
time and how these things can be sort of

374
00:13:20,160 --> 00:13:21,200
just here depending upon your

375
00:13:21,200 --> 00:13:22,480
applications you can choose the

376
00:13:22,480 --> 00:13:24,720
appropriate parameters and make the use

377
00:13:24,720 --> 00:13:28,240
of this particular smooth trade-off

378
00:13:28,720 --> 00:13:30,720
and i want to emphasize before going

379
00:13:30,720 --> 00:13:32,639
forward that all these applications this

380
00:13:32,639 --> 00:13:34,959
still makes sense even if we are working

381
00:13:34,959 --> 00:13:37,600
in a single sinus setting a single sinus

382
00:13:37,600 --> 00:13:38,880
setting for aggregate signatures

383
00:13:38,880 --> 00:13:40,639
basically says that there is a single

384
00:13:40,639 --> 00:13:42,720
party whose whose signatures we are

385
00:13:42,720 --> 00:13:44,160
trying to verify

386
00:13:44,160 --> 00:13:45,519
and the reason we want to or we are

387
00:13:45,519 --> 00:13:47,839
trying to aggregate because uh in for

388
00:13:47,839 --> 00:13:49,680
example in the case of blockchains alice

389
00:13:49,680 --> 00:13:52,399
is sending the payment to bob each month

390
00:13:52,399 --> 00:13:54,160
alice is the same party you still want

391
00:13:54,160 --> 00:13:56,240
to sort of just accumulate aggregate all

392
00:13:56,240 --> 00:13:58,079
the particular uh transactions that

393
00:13:58,079 --> 00:13:59,680
alice has performed

394
00:13:59,680 --> 00:14:01,920
so just trying to study this object in

395
00:14:01,920 --> 00:14:03,600
the single sinus setting is already very

396
00:14:03,600 --> 00:14:05,120
useful because it unlocks even just

397
00:14:05,120 --> 00:14:07,279
these interesting applications

398
00:14:07,279 --> 00:14:08,639
now in the remaining talk i'm going to

399
00:14:08,639 --> 00:14:10,160
sort of just here tell you about the new

400
00:14:10,160 --> 00:14:12,079
constructions and feasible results that

401
00:14:12,079 --> 00:14:13,440
we obtain about

402
00:14:13,440 --> 00:14:15,040
these locally verifiable aggregate

403
00:14:15,040 --> 00:14:17,199
signatures

404
00:14:17,199 --> 00:14:19,199
and the constructions that we obtain are

405
00:14:19,199 --> 00:14:20,880
we obtain certain new practical

406
00:14:20,880 --> 00:14:22,160
constructions

407
00:14:22,160 --> 00:14:24,000
from rsa and

408
00:14:24,000 --> 00:14:26,240
pairing based assumptions and also we

409
00:14:26,240 --> 00:14:28,720
get a feasibility result from snarks

410
00:14:28,720 --> 00:14:30,240
although it's not super efficient it

411
00:14:30,240 --> 00:14:32,480
just tells us that the best possible

412
00:14:32,480 --> 00:14:34,720
version of uh locally verifiable

413
00:14:34,720 --> 00:14:36,560
aggregate signatures is also possible

414
00:14:36,560 --> 00:14:38,399
because the practical constructions that

415
00:14:38,399 --> 00:14:40,320
we obtain they are only in the single

416
00:14:40,320 --> 00:14:42,959
server setting whereas the using snarks

417
00:14:42,959 --> 00:14:44,240
we can show that we can achieve this

418
00:14:44,240 --> 00:14:46,160
general model of locally verifiable

419
00:14:46,160 --> 00:14:48,000
aggregate signatures the only difference

420
00:14:48,000 --> 00:14:49,600
is that in the general model there could

421
00:14:49,600 --> 00:14:51,600
be multiple different users whose

422
00:14:51,600 --> 00:14:53,519
signatures you want to aggregate and you

423
00:14:53,519 --> 00:14:55,120
want to open it at a later point in a

424
00:14:55,120 --> 00:14:56,639
single sinus setting there's a fixed

425
00:14:56,639 --> 00:14:58,399
single sign-in and you want to aggregate

426
00:14:58,399 --> 00:15:00,079
signatures and later open just one of

427
00:15:00,079 --> 00:15:03,040
them or a few of them efficiently

428
00:15:03,040 --> 00:15:05,199
so next let me just here tell you how to

429
00:15:05,199 --> 00:15:06,959
actually design these locally verifiable

430
00:15:06,959 --> 00:15:09,199
aggregate signatures and the focus of

431
00:15:09,199 --> 00:15:11,360
the remaining talk is going to be on the

432
00:15:11,360 --> 00:15:13,120
factoring based signatures

433
00:15:13,120 --> 00:15:15,040
in the single sinus setting and towards

434
00:15:15,040 --> 00:15:16,639
the end i'll quickly mention how we can

435
00:15:16,639 --> 00:15:18,240
use these ideas and the underlying

436
00:15:18,240 --> 00:15:20,480
algebra in a similar way over pairings

437
00:15:20,480 --> 00:15:23,360
as well to unlock the same potential in

438
00:15:23,360 --> 00:15:25,360
or for pairings and how they can sort of

439
00:15:25,360 --> 00:15:27,760
just potentially be used in snarks also

440
00:15:27,760 --> 00:15:29,600
but if uh let's just see if we can get

441
00:15:29,600 --> 00:15:31,600
to stocks or not today

442
00:15:31,600 --> 00:15:34,399
but uh yeah so the starting point of how

443
00:15:34,399 --> 00:15:36,160
to design um

444
00:15:36,160 --> 00:15:37,839
using uh factoring based assumptions how

445
00:15:37,839 --> 00:15:39,600
to design these particular signatures

446
00:15:39,600 --> 00:15:41,519
let's just revisit the most fundamental

447
00:15:41,519 --> 00:15:43,279
object from rs that we know which is the

448
00:15:43,279 --> 00:15:45,759
classical rsa based signature scheme and

449
00:15:45,759 --> 00:15:47,600
the idea is that the verification key

450
00:15:47,600 --> 00:15:49,920
contains an rsa modulus n

451
00:15:49,920 --> 00:15:53,040
and an exponent e a prime exponent e and

452
00:15:53,040 --> 00:15:55,199
a signature on a message m is simply you

453
00:15:55,199 --> 00:15:57,040
hash the message and you take the eth

454
00:15:57,040 --> 00:15:59,360
root of the hashed message to verify you

455
00:15:59,360 --> 00:16:01,680
simply check whether uh the signatures

456
00:16:01,680 --> 00:16:04,000
eith power is the message that you want

457
00:16:04,000 --> 00:16:05,440
to verify

458
00:16:05,440 --> 00:16:07,440
that's just revisiting the classical rss

459
00:16:07,440 --> 00:16:08,800
scheme

460
00:16:08,800 --> 00:16:09,920
and

461
00:16:09,920 --> 00:16:11,600
it turns out although it has not been

462
00:16:11,600 --> 00:16:12,959
formally defined to the best of our

463
00:16:12,959 --> 00:16:14,399
knowledge there is a very simple

464
00:16:14,399 --> 00:16:16,720
folklore way of trying to aggregate

465
00:16:16,720 --> 00:16:18,240
these particular signatures in the

466
00:16:18,240 --> 00:16:20,160
single sinus setting and the idea is

467
00:16:20,160 --> 00:16:21,680
very simple just multiply all these

468
00:16:21,680 --> 00:16:22,800
signatures

469
00:16:22,800 --> 00:16:23,839
and that's going to be your aggregate

470
00:16:23,839 --> 00:16:25,199
signature so suppose you have these

471
00:16:25,199 --> 00:16:27,920
signatures h of m one the e the e f root

472
00:16:27,920 --> 00:16:30,079
of h of m one and the e th root of

473
00:16:30,079 --> 00:16:31,839
picture of m l and all of these things

474
00:16:31,839 --> 00:16:33,120
and you can just multiply all of them

475
00:16:33,120 --> 00:16:35,120
together and the sigma hat is just going

476
00:16:35,120 --> 00:16:36,560
to be the multiplication of all these

477
00:16:36,560 --> 00:16:37,839
elements and that's going to be an

478
00:16:37,839 --> 00:16:40,560
aggregate signature

479
00:16:40,560 --> 00:16:42,160
and now to verify this particular

480
00:16:42,160 --> 00:16:43,519
aggregate signature what you can do is

481
00:16:43,519 --> 00:16:44,959
that you can raise the aggregate

482
00:16:44,959 --> 00:16:47,839
signature sigma hat to the eighth power

483
00:16:47,839 --> 00:16:49,440
and check whether that equals the

484
00:16:49,440 --> 00:16:50,880
product of all the messages that you

485
00:16:50,880 --> 00:16:52,959
want to add that you wish or that you

486
00:16:52,959 --> 00:16:54,240
want to check have been aggregated in

487
00:16:54,240 --> 00:16:56,480
this particular signature

488
00:16:56,480 --> 00:16:58,399
so okay so first step is done we know

489
00:16:58,399 --> 00:17:00,240
how to create single sign and aggregate

490
00:17:00,240 --> 00:17:01,839
signature schemes from rsa based

491
00:17:01,839 --> 00:17:03,680
assumptions now the question is that can

492
00:17:03,680 --> 00:17:06,319
we make this to be locally verifiable

493
00:17:06,319 --> 00:17:08,400
so local verifiably the verifiability

494
00:17:08,400 --> 00:17:10,799
simply says that first we need to create

495
00:17:10,799 --> 00:17:12,559
or we need to understand how we can

496
00:17:12,559 --> 00:17:14,480
create these short hints which will make

497
00:17:14,480 --> 00:17:15,919
sure that the local verification can be

498
00:17:15,919 --> 00:17:16,959
spreader

499
00:17:16,959 --> 00:17:19,439
so to that end an idea is very simple

500
00:17:19,439 --> 00:17:21,039
that to make sure that they can be

501
00:17:21,039 --> 00:17:23,280
locally verified we can sort of create

502
00:17:23,280 --> 00:17:25,439
this as the following hint suppose you

503
00:17:25,439 --> 00:17:27,839
have these l messages m1 up till ml and

504
00:17:27,839 --> 00:17:29,760
there's a target message m that you want

505
00:17:29,760 --> 00:17:31,520
to open this particular signature too

506
00:17:31,520 --> 00:17:33,280
and you want to create a short hint for

507
00:17:33,280 --> 00:17:35,440
it so the hint you can sort of sort of

508
00:17:35,440 --> 00:17:37,200
said to be it could be the product of

509
00:17:37,200 --> 00:17:38,880
all the hashed messages except the

510
00:17:38,880 --> 00:17:40,240
target message

511
00:17:40,240 --> 00:17:41,679
and you can efficiently compute this

512
00:17:41,679 --> 00:17:43,039
because this is just in the base of the

513
00:17:43,039 --> 00:17:44,640
rsm modules

514
00:17:44,640 --> 00:17:46,480
and now the idea is that given this you

515
00:17:46,480 --> 00:17:48,559
can perform this local verification

516
00:17:48,559 --> 00:17:50,480
check to be sigma hat raised to the

517
00:17:50,480 --> 00:17:52,720
power e is equal to v

518
00:17:52,720 --> 00:17:55,360
h the hint times the hash of the target

519
00:17:55,360 --> 00:17:56,880
message and that's how we can

520
00:17:56,880 --> 00:17:58,559
potentially verify

521
00:17:58,559 --> 00:18:00,000
and now everybody must be thinking okay

522
00:18:00,000 --> 00:18:01,520
all is good it seems like by just

523
00:18:01,520 --> 00:18:03,440
performing this pre-processing we can

524
00:18:03,440 --> 00:18:06,000
efficiently make sure that local

525
00:18:06,000 --> 00:18:07,760
verification can be done

526
00:18:07,760 --> 00:18:09,200
but there's a big problem here and the

527
00:18:09,200 --> 00:18:11,679
problem is that this is totally insecure

528
00:18:11,679 --> 00:18:13,679
because the hint can be adversarial the

529
00:18:13,679 --> 00:18:15,440
adversary can create any arbitrary hint

530
00:18:15,440 --> 00:18:16,960
and there is no structure that we are

531
00:18:16,960 --> 00:18:18,320
enforcing or we can even check because

532
00:18:18,320 --> 00:18:20,559
we don't have all the messages that were

533
00:18:20,559 --> 00:18:22,000
signed because the messages are lost

534
00:18:22,000 --> 00:18:24,000
once you sort of just generate this hint

535
00:18:24,000 --> 00:18:25,360
i can't have access those particular

536
00:18:25,360 --> 00:18:27,600
messages because that's the whole point

537
00:18:27,600 --> 00:18:30,480
and for example consider h to be one

538
00:18:30,480 --> 00:18:33,120
over h of m and sigma had to be one

539
00:18:33,120 --> 00:18:35,840
that's basically a valid forgery on this

540
00:18:35,840 --> 00:18:38,160
particular scheme

541
00:18:38,160 --> 00:18:39,760
so it seems like

542
00:18:39,760 --> 00:18:41,679
maybe it's unclear how to sort of

543
00:18:41,679 --> 00:18:43,360
aggregate signatures using this rs

544
00:18:43,360 --> 00:18:46,080
landscape but what can we do

545
00:18:46,080 --> 00:18:48,720
now our observation is that the issue

546
00:18:48,720 --> 00:18:51,200
the issue that we're facing here is that

547
00:18:51,200 --> 00:18:52,720
the hint that we're generating in this

548
00:18:52,720 --> 00:18:55,039
case it's just product of all these hash

549
00:18:55,039 --> 00:18:56,720
value of these messages it's totally

550
00:18:56,720 --> 00:18:58,160
unstructured

551
00:18:58,160 --> 00:19:00,320
and we cannot ensure well-formedness of

552
00:19:00,320 --> 00:19:01,280
the hint

553
00:19:01,280 --> 00:19:03,200
anyhow without sort of just reading

554
00:19:03,200 --> 00:19:05,840
through all the other messages

555
00:19:05,840 --> 00:19:07,760
now how to get around this problem the

556
00:19:07,760 --> 00:19:09,440
idea that we employ is that we're going

557
00:19:09,440 --> 00:19:11,440
to sort of just switch the base and the

558
00:19:11,440 --> 00:19:12,960
exponent we're going to move the

559
00:19:12,960 --> 00:19:14,640
messages to the exponent and sort of

560
00:19:14,640 --> 00:19:16,720
just keep in a way the

561
00:19:16,720 --> 00:19:19,840
the rsa part on the messages rather than

562
00:19:19,840 --> 00:19:22,080
on just like a fixed exponent and what i

563
00:19:22,080 --> 00:19:25,200
mean by that is so consider the phoning

564
00:19:25,200 --> 00:19:27,600
scheme in this the verification keys

565
00:19:27,600 --> 00:19:30,160
contains again an rsa modulus and some

566
00:19:30,160 --> 00:19:31,679
base element g

567
00:19:31,679 --> 00:19:35,200
and a signature now is the h of m root

568
00:19:35,200 --> 00:19:38,799
of g g is part of the verification key

569
00:19:38,799 --> 00:19:40,559
and to verify this particular signature

570
00:19:40,559 --> 00:19:43,039
you just raise this the signature to h

571
00:19:43,039 --> 00:19:45,600
of m and you match it to be the element

572
00:19:45,600 --> 00:19:47,039
g that was present in the digital

573
00:19:47,039 --> 00:19:49,200
signatures and this is basically the

574
00:19:49,200 --> 00:19:53,360
gennaro halevi and rosario's

575
00:19:53,760 --> 00:19:55,200
signature scheme that was sort of

576
00:19:55,200 --> 00:19:57,760
defined in the late 90s and it has been

577
00:19:57,760 --> 00:19:59,679
the basis of many other

578
00:19:59,679 --> 00:20:02,159
uh interesting signature schemes so the

579
00:20:02,159 --> 00:20:04,640
idea is that the structure or the the

580
00:20:04,640 --> 00:20:07,520
inversion is happening on on um it's not

581
00:20:07,520 --> 00:20:09,200
happening on a fixed prime but on a

582
00:20:09,200 --> 00:20:12,240
prime that depends upon the message

583
00:20:12,240 --> 00:20:14,159
now let's see how we can potentially

584
00:20:14,159 --> 00:20:16,720
verify this or locally aggregate this or

585
00:20:16,720 --> 00:20:18,880
simply just aggregate this again if we

586
00:20:18,880 --> 00:20:21,600
have the sequence of messages m1 ml and

587
00:20:21,600 --> 00:20:23,600
their corresponding signatures g raised

588
00:20:23,600 --> 00:20:25,440
to the power 1 over h of m1 up till 1

589
00:20:25,440 --> 00:20:26,799
over h of ml

590
00:20:26,799 --> 00:20:28,400
the idea is that again multiply all of

591
00:20:28,400 --> 00:20:29,840
them that's going to be an aggregate

592
00:20:29,840 --> 00:20:31,280
signature

593
00:20:31,280 --> 00:20:33,280
and to verify this aggregate signature

594
00:20:33,280 --> 00:20:34,799
what you're going to do now is that

595
00:20:34,799 --> 00:20:36,799
you're going to raise sigma hat the

596
00:20:36,799 --> 00:20:38,480
aggregate signature

597
00:20:38,480 --> 00:20:41,120
to all the hashed messages not just one

598
00:20:41,120 --> 00:20:43,200
prime all these particular hash messages

599
00:20:43,200 --> 00:20:46,320
and you're going to check that it equals

600
00:20:46,320 --> 00:20:48,880
a product of l terms and each of these l

601
00:20:48,880 --> 00:20:51,440
terms is itself g raised to the power

602
00:20:51,440 --> 00:20:54,320
all but one particular hash message

603
00:20:54,320 --> 00:20:56,080
so you basically omit one particular

604
00:20:56,080 --> 00:20:58,080
hash message because there is one over h

605
00:20:58,080 --> 00:21:00,080
of m i in that particular right hand

606
00:21:00,080 --> 00:21:03,120
side on the top part

607
00:21:03,120 --> 00:21:04,000
so

608
00:21:04,000 --> 00:21:06,000
seems like hopefully you understand that

609
00:21:06,000 --> 00:21:07,760
completeness of the scheme of this

610
00:21:07,760 --> 00:21:09,840
aggregate signature scheme does follow

611
00:21:09,840 --> 00:21:12,320
now the question remains that can be we

612
00:21:12,320 --> 00:21:14,000
have made this switch we have make sure

613
00:21:14,000 --> 00:21:16,559
that the structure of uh this thing is

614
00:21:16,559 --> 00:21:18,640
switched it's in the exponent can we use

615
00:21:18,640 --> 00:21:19,760
this to make sure that we can come up

616
00:21:19,760 --> 00:21:21,200
with a locally verifiable aggregate

617
00:21:21,200 --> 00:21:22,799
signature can we generate efficient

618
00:21:22,799 --> 00:21:24,400
hints for it

619
00:21:24,400 --> 00:21:27,360
and it turns out yes we actually can so

620
00:21:27,360 --> 00:21:29,120
and yeah i forgot to mention this but

621
00:21:29,120 --> 00:21:30,880
i'm assuming for simplicity that h of m

622
00:21:30,880 --> 00:21:32,880
is always a prime and we can handle this

623
00:21:32,880 --> 00:21:34,400
by sort of very well known techniques

624
00:21:34,400 --> 00:21:36,159
i'll but i'll defer

625
00:21:36,159 --> 00:21:38,240
that to later so let's just see how to

626
00:21:38,240 --> 00:21:39,679
sort of potentially

627
00:21:39,679 --> 00:21:40,640
uh

628
00:21:40,640 --> 00:21:42,240
generate a hint suppose i want to

629
00:21:42,240 --> 00:21:43,760
generate the hint for the first message

630
00:21:43,760 --> 00:21:45,360
m1

631
00:21:45,360 --> 00:21:47,360
now the idea is going to be the verifier

632
00:21:47,360 --> 00:21:49,120
simply checks this particular equation

633
00:21:49,120 --> 00:21:50,880
i'm going to use a notation that h of i

634
00:21:50,880 --> 00:21:53,600
is equal to the hash of the message mi

635
00:21:53,600 --> 00:21:55,200
now i'm going to write the rewrite the

636
00:21:55,200 --> 00:21:57,760
left hand side as all the hash values

637
00:21:57,760 --> 00:21:59,679
except the first hash value so sigma hat

638
00:21:59,679 --> 00:22:02,400
raised to the power h2 h3 up till hl and

639
00:22:02,400 --> 00:22:04,880
h1 on the outside and similarly i'm

640
00:22:04,880 --> 00:22:05,919
going to

641
00:22:05,919 --> 00:22:07,760
divide the right hand side into two

642
00:22:07,760 --> 00:22:10,480
components one that depends upon

643
00:22:10,480 --> 00:22:12,640
that does not depend upon h1 the other

644
00:22:12,640 --> 00:22:14,559
one it depends upon h1 and the remaining

645
00:22:14,559 --> 00:22:16,320
terms

646
00:22:16,320 --> 00:22:18,799
and now the idea is that so for example

647
00:22:18,799 --> 00:22:21,280
consider that uh l is equal to four then

648
00:22:21,280 --> 00:22:22,880
in that case this basically simply means

649
00:22:22,880 --> 00:22:24,400
that the equation is that sigma hat

650
00:22:24,400 --> 00:22:26,880
raised to the power h2 h3 h4

651
00:22:26,880 --> 00:22:29,039
and h1 is equal to be

652
00:22:29,039 --> 00:22:32,799
g times h2 h3 h4 and g times h2 h3 plus

653
00:22:32,799 --> 00:22:35,520
h2h4 h3h4 raised to the power h1 so

654
00:22:35,520 --> 00:22:37,039
that's basically the verification check

655
00:22:37,039 --> 00:22:38,720
that we're performing

656
00:22:38,720 --> 00:22:40,480
now the point is if you sort of just

657
00:22:40,480 --> 00:22:42,880
focus in on these circled components you

658
00:22:42,880 --> 00:22:45,600
look at the product of his here here and

659
00:22:45,600 --> 00:22:47,919
the sum product of h is

660
00:22:47,919 --> 00:22:49,760
then these terms do not depend upon h1

661
00:22:49,760 --> 00:22:51,679
they depend upon the remaining messages

662
00:22:51,679 --> 00:22:53,520
and this is what we can pre-compute and

663
00:22:53,520 --> 00:22:55,280
set it to by our hint because during the

664
00:22:55,280 --> 00:22:56,960
hint generation process we know all the

665
00:22:56,960 --> 00:22:59,360
messages so we can generate these hashes

666
00:22:59,360 --> 00:23:00,559
and we can sort of just perform the

667
00:23:00,559 --> 00:23:03,280
simple arithmetic operation

668
00:23:03,280 --> 00:23:04,880
the idea is that this is basically going

669
00:23:04,880 --> 00:23:06,880
to be a hint for this particular message

670
00:23:06,880 --> 00:23:10,559
m1 now to verify this local or just

671
00:23:10,559 --> 00:23:12,880
verify this particular message for the

672
00:23:12,880 --> 00:23:14,400
aggregate signature you're going to

673
00:23:14,400 --> 00:23:15,679
simply sort of check the following

674
00:23:15,679 --> 00:23:17,600
equation that sigma hat raised to the

675
00:23:17,600 --> 00:23:19,520
power the first element of the

676
00:23:19,520 --> 00:23:20,799
hint value

677
00:23:20,799 --> 00:23:23,919
times h1 is equal to ga times gb raised

678
00:23:23,919 --> 00:23:25,520
to the power h1

679
00:23:25,520 --> 00:23:27,600
that basically substitutes these circle

680
00:23:27,600 --> 00:23:29,120
values with a and b in this particular

681
00:23:29,120 --> 00:23:30,400
equation

682
00:23:30,400 --> 00:23:32,799
so it means that we are able to get

683
00:23:32,799 --> 00:23:33,760
these

684
00:23:33,760 --> 00:23:35,120
simple properties that we can

685
00:23:35,120 --> 00:23:37,760
efficiently verify this

686
00:23:37,760 --> 00:23:39,440
and the intuition behind security is

687
00:23:39,440 --> 00:23:40,880
that

688
00:23:40,880 --> 00:23:42,480
you can simply rewrite the equation on

689
00:23:42,480 --> 00:23:44,240
the right hand side as follows you can

690
00:23:44,240 --> 00:23:46,320
move all the h1 dependent components on

691
00:23:46,320 --> 00:23:47,760
the left side

692
00:23:47,760 --> 00:23:49,440
and you can rewrite it as follows that

693
00:23:49,440 --> 00:23:52,080
sigma hat to the a divided by g b raised

694
00:23:52,080 --> 00:23:54,159
to the power h1 is equal to ga

695
00:23:54,159 --> 00:23:56,480
and it turns out now you basically use

696
00:23:56,480 --> 00:23:58,720
the fact that if adversary finds a

697
00:23:58,720 --> 00:24:00,480
forgery sigma hat such that this is

698
00:24:00,480 --> 00:24:03,600
satisfied then in that case i can use

699
00:24:03,600 --> 00:24:06,159
that to find the h1 root of a known

700
00:24:06,159 --> 00:24:07,679
element because g is like a known

701
00:24:07,679 --> 00:24:09,440
element we can sort of just use some

702
00:24:09,440 --> 00:24:11,200
clever algebra to make sure that we can

703
00:24:11,200 --> 00:24:12,880
sort of just create a forgery out of it

704
00:24:12,880 --> 00:24:14,799
create like the rsa challenge out of

705
00:24:14,799 --> 00:24:16,960
this

706
00:24:17,120 --> 00:24:19,760
so it seems like great

707
00:24:19,760 --> 00:24:21,120
everything seems to work we have

708
00:24:21,120 --> 00:24:22,960
generated hints we have kind of argued

709
00:24:22,960 --> 00:24:24,880
how security might hold

710
00:24:24,880 --> 00:24:26,880
but it turns out if you look a little

711
00:24:26,880 --> 00:24:29,279
more closely then it's very simple but

712
00:24:29,279 --> 00:24:31,279
it's flawed and the reason it's flawed

713
00:24:31,279 --> 00:24:33,679
is that the hints are very large and the

714
00:24:33,679 --> 00:24:36,159
hints are large because uh we don't know

715
00:24:36,159 --> 00:24:38,640
what v of n is and

716
00:24:38,640 --> 00:24:41,440
because v of n guarantees what security

717
00:24:41,440 --> 00:24:43,120
is and fee of n is required to reduce

718
00:24:43,120 --> 00:24:45,760
the elements in the exponent without

719
00:24:45,760 --> 00:24:47,279
knowing p of n we have to compute these

720
00:24:47,279 --> 00:24:49,200
as integers and integers multiplying

721
00:24:49,200 --> 00:24:50,960
these n integers or l integers that's

722
00:24:50,960 --> 00:24:52,960
going to be o of l bits that's pretty

723
00:24:52,960 --> 00:24:54,480
large so it seems like we're back to

724
00:24:54,480 --> 00:24:56,320
square one we perform some processing

725
00:24:56,320 --> 00:24:57,840
but again we could not sort of just

726
00:24:57,840 --> 00:24:59,279
solve this

727
00:24:59,279 --> 00:25:01,600
but to this end sort of just one very

728
00:25:01,600 --> 00:25:03,360
simple trick or just the well-known

729
00:25:03,360 --> 00:25:05,600
chummy's trick came to our savior so

730
00:25:05,600 --> 00:25:07,919
it's just what xiaomi strict says it

731
00:25:07,919 --> 00:25:10,640
says given elements x y alpha and beta

732
00:25:10,640 --> 00:25:12,880
such that x a x to the alpha is equal to

733
00:25:12,880 --> 00:25:14,799
y to the beta and alpha and beta are

734
00:25:14,799 --> 00:25:16,880
co-prime there is a way to efficiently

735
00:25:16,880 --> 00:25:20,400
find the alpha root of y

736
00:25:20,400 --> 00:25:22,480
so now we can use this ramis trick over

737
00:25:22,480 --> 00:25:24,240
here and sort of simply rewrite this

738
00:25:24,240 --> 00:25:26,080
particular equation so that again we can

739
00:25:26,080 --> 00:25:27,840
put h1 related components on the left

740
00:25:27,840 --> 00:25:29,760
hand side h1 independent components on

741
00:25:29,760 --> 00:25:31,520
the right hand side i can say this is

742
00:25:31,520 --> 00:25:33,120
going to be my x

743
00:25:33,120 --> 00:25:35,200
this is going to be my beta that's going

744
00:25:35,200 --> 00:25:37,120
to be the alpha that's going to be the y

745
00:25:37,120 --> 00:25:39,600
so i can generate g raised to the power

746
00:25:39,600 --> 00:25:42,000
1 over h 1 using chemistry in this

747
00:25:42,000 --> 00:25:43,919
particular way

748
00:25:43,919 --> 00:25:46,080
and that's basically my hint

749
00:25:46,080 --> 00:25:48,159
and to verify this particular hint you

750
00:25:48,159 --> 00:25:50,159
can sort of just raise it again to h1

751
00:25:50,159 --> 00:25:51,919
and that's going to be equal to g and if

752
00:25:51,919 --> 00:25:54,840
that's true then you can verify the

753
00:25:54,840 --> 00:25:57,600
signature but if you focus a little more

754
00:25:57,600 --> 00:25:59,279
you might imagine that this you might

755
00:25:59,279 --> 00:26:00,159
sort of just

756
00:26:00,159 --> 00:26:02,640
understand that this particular hint has

757
00:26:02,640 --> 00:26:04,240
a wonderful property that it's not just

758
00:26:04,240 --> 00:26:05,840
a hint that you can use to verify the

759
00:26:05,840 --> 00:26:07,840
hint is actually the signature for this

760
00:26:07,840 --> 00:26:10,080
particular message m1 so it turns out

761
00:26:10,080 --> 00:26:12,000
this scheme has a wonderful property

762
00:26:12,000 --> 00:26:14,640
that not only we can compress signatures

763
00:26:14,640 --> 00:26:16,400
but we can perfectly decompress all the

764
00:26:16,400 --> 00:26:18,080
signatures typically whenever we think

765
00:26:18,080 --> 00:26:19,440
of cryptographic compression we lose

766
00:26:19,440 --> 00:26:21,120
information here we are observing not

767
00:26:21,120 --> 00:26:22,480
only we can compress but we can

768
00:26:22,480 --> 00:26:24,799
perfectly decompress so just really the

769
00:26:24,799 --> 00:26:26,640
magic of number three at play where we

770
00:26:26,640 --> 00:26:28,559
can sort of perform local verification

771
00:26:28,559 --> 00:26:30,000
but also recompute the original

772
00:26:30,000 --> 00:26:32,480
signature entirely

773
00:26:32,480 --> 00:26:34,240
and just trying to sum up quickly about

774
00:26:34,240 --> 00:26:35,919
locally verifiable aggregate signatures

775
00:26:35,919 --> 00:26:37,600
the main technical tool is that we

776
00:26:37,600 --> 00:26:39,360
ensure this well formless can be

777
00:26:39,360 --> 00:26:41,600
automatically performed in the exponent

778
00:26:41,600 --> 00:26:43,760
without uh us doing anything because

779
00:26:43,760 --> 00:26:45,760
some at a very high level happening is

780
00:26:45,760 --> 00:26:47,200
that if you write the chinese remainder

781
00:26:47,200 --> 00:26:49,120
theorem sort of terms in the exponent

782
00:26:49,120 --> 00:26:50,880
then they're going to sort of align very

783
00:26:50,880 --> 00:26:52,240
well and they're not going to intersect

784
00:26:52,240 --> 00:26:54,480
with different terms and that's going to

785
00:26:54,480 --> 00:26:55,840
really help us

786
00:26:55,840 --> 00:26:57,520
but what's very cute about this

787
00:26:57,520 --> 00:26:58,559
construction is that the hinge

788
00:26:58,559 --> 00:27:00,400
generation tells us that we can

789
00:27:00,400 --> 00:27:03,520
perfectly uncompute or create the actual

790
00:27:03,520 --> 00:27:04,720
original signature from aggregate

791
00:27:04,720 --> 00:27:06,720
signatures and this is the number theory

792
00:27:06,720 --> 00:27:09,440
magic at play and uh one thing that i

793
00:27:09,440 --> 00:27:10,799
was sort of just here hiding in the rug

794
00:27:10,799 --> 00:27:13,679
which was this how to sample how to hash

795
00:27:13,679 --> 00:27:15,360
messages in a deterministic way to

796
00:27:15,360 --> 00:27:16,880
primes but we can rely on sort of just

797
00:27:16,880 --> 00:27:18,640
known techniques due to mikali raven and

798
00:27:18,640 --> 00:27:20,320
wadahan and for loops where they sort of

799
00:27:20,320 --> 00:27:21,679
just use these techniques in the

800
00:27:21,679 --> 00:27:22,960
literature of verifiable random

801
00:27:22,960 --> 00:27:24,799
functions but we can use those ideas to

802
00:27:24,799 --> 00:27:26,480
prove security in the static setting or

803
00:27:26,480 --> 00:27:27,679
also in the full security in the

804
00:27:27,679 --> 00:27:29,039
numerical setting

805
00:27:29,039 --> 00:27:30,640
so just trying to summarize we gave new

806
00:27:30,640 --> 00:27:33,200
constructions from rsn pairings and

807
00:27:33,200 --> 00:27:35,120
although i won't have time to tell you

808
00:27:35,120 --> 00:27:37,120
that how to get it from pairings but

809
00:27:37,120 --> 00:27:40,240
there's a kind of interesting uh

810
00:27:40,240 --> 00:27:41,840
comparison or like a juxtaposition that

811
00:27:41,840 --> 00:27:43,360
you can do for these techniques and i'd

812
00:27:43,360 --> 00:27:45,039
be happy to talk about that later but

813
00:27:45,039 --> 00:27:46,559
let me sort of just try to summarize

814
00:27:46,559 --> 00:27:48,640
that in this work we sort of introduced

815
00:27:48,640 --> 00:27:50,080
the concept of local verification for

816
00:27:50,080 --> 00:27:52,159
application signatures circumventing and

817
00:27:52,159 --> 00:27:53,679
defining that there is an impossibility

818
00:27:53,679 --> 00:27:56,000
we can sidestep it and this still lets

819
00:27:56,000 --> 00:27:57,919
us new applications and sort of just

820
00:27:57,919 --> 00:28:00,640
interesting space time tradeoffs

821
00:28:00,640 --> 00:28:02,240
and next we also sort of show how to

822
00:28:02,240 --> 00:28:04,080
develop these new algebraic techniques

823
00:28:04,080 --> 00:28:06,080
which unlock this amazing property about

824
00:28:06,080 --> 00:28:08,000
the rsa signatures which was not known

825
00:28:08,000 --> 00:28:09,840
before that we can not only compress

826
00:28:09,840 --> 00:28:11,440
information but also perfectly

827
00:28:11,440 --> 00:28:13,360
decompress it which seems fascinating to

828
00:28:13,360 --> 00:28:14,640
us it'd be happy to sort of just

829
00:28:14,640 --> 00:28:16,320
understand that why it's real i mean

830
00:28:16,320 --> 00:28:18,080
it's happening the math works out but

831
00:28:18,080 --> 00:28:20,000
it's really it's bizarre and also sort

832
00:28:20,000 --> 00:28:22,559
of just really fun and i forgot to

833
00:28:22,559 --> 00:28:23,520
mention but the painting-based

834
00:28:23,520 --> 00:28:24,880
signatures that we came up with they

835
00:28:24,880 --> 00:28:26,159
also have interesting properties that

836
00:28:26,159 --> 00:28:27,600
the openings are fully public you don't

837
00:28:27,600 --> 00:28:29,360
need the signature even to sort of come

838
00:28:29,360 --> 00:28:30,720
up with the opening it can be performed

839
00:28:30,720 --> 00:28:33,120
in a totally offline phase and we gave a

840
00:28:33,120 --> 00:28:34,880
result about feasibility from starks and

841
00:28:34,880 --> 00:28:36,320
also i didn't get to mention but it's in

842
00:28:36,320 --> 00:28:37,440
the paper and we're happy to talk about

843
00:28:37,440 --> 00:28:39,200
later that we also show that we can

844
00:28:39,200 --> 00:28:41,760
extend the aggregation concept to secret

845
00:28:41,760 --> 00:28:43,600
to encryption systems as well where

846
00:28:43,600 --> 00:28:45,520
multi-user encryption systems

847
00:28:45,520 --> 00:28:47,360
and sort of this sort of just leads to

848
00:28:47,360 --> 00:28:49,200
many interesting questions that can we

849
00:28:49,200 --> 00:28:50,720
come up with more applications of these

850
00:28:50,720 --> 00:28:52,240
algebraic techniques or can we sort of

851
00:28:52,240 --> 00:28:53,679
just here come up with these general

852
00:28:53,679 --> 00:28:55,760
models general model solution for

853
00:28:55,760 --> 00:28:57,760
locally verifiable aggregate signatures

854
00:28:57,760 --> 00:28:59,039
and even can we

855
00:28:59,039 --> 00:29:01,039
study the concept of aggregation beyond

856
00:29:01,039 --> 00:29:02,799
ibe for which we have interesting

857
00:29:02,799 --> 00:29:04,399
results or other non-encryption-based

858
00:29:04,399 --> 00:29:05,360
systems

859
00:29:05,360 --> 00:29:07,520
and yeah so thank you so much and be

860
00:29:07,520 --> 00:29:08,799
happy to take any questions but i think

861
00:29:08,799 --> 00:29:12,760
we are time for questions

862
00:29:15,760 --> 00:29:17,840
so if there's any quick questions please

863
00:29:17,840 --> 00:29:20,640
come up to the front of the microphones

864
00:29:20,640 --> 00:29:22,159
yeah so i guess a quick question i

865
00:29:22,159 --> 00:29:23,840
assume since you didn't call this talk

866
00:29:23,840 --> 00:29:25,440
de-aggregateable signatures the

867
00:29:25,440 --> 00:29:27,760
pairing-based construction isn't as nice

868
00:29:27,760 --> 00:29:29,840
as the rsa construction

869
00:29:29,840 --> 00:29:31,120
do you think it's possible though to

870
00:29:31,120 --> 00:29:32,320
come up with a pairing based system

871
00:29:32,320 --> 00:29:33,440
where you can recover the original

872
00:29:33,440 --> 00:29:35,919
signature

873
00:29:36,480 --> 00:29:38,640
okay so in case uh hopefully everybody

874
00:29:38,640 --> 00:29:40,000
sort of just heard the question it's a

875
00:29:40,000 --> 00:29:42,240
great question can you get uh the

876
00:29:42,240 --> 00:29:43,840
perfect decompression property out of

877
00:29:43,840 --> 00:29:46,159
anything else other than uh factoring

878
00:29:46,159 --> 00:29:47,600
based assumptions i've been thinking

879
00:29:47,600 --> 00:29:49,360
about it i don't know yet i i can't

880
00:29:49,360 --> 00:29:51,120
answer this because i don't know that's

881
00:29:51,120 --> 00:29:52,240
that's the short answer it'd be

882
00:29:52,240 --> 00:29:54,640
wonderful if we can do it uh you can

883
00:29:54,640 --> 00:29:55,919
probably throw a bunch of assumptions

884
00:29:55,919 --> 00:29:57,760
but just purely doing from bilinear maps

885
00:29:57,760 --> 00:29:59,679
i don't see it right away maybe

886
00:29:59,679 --> 00:30:01,039
something could be done that'd be very

887
00:30:01,039 --> 00:30:02,720
fascinating too but i don't know right

888
00:30:02,720 --> 00:30:04,320
now how to do it

889
00:30:04,320 --> 00:30:05,600
thanks yeah thanks for the question

890
00:30:05,600 --> 00:30:08,559
again

891
00:30:08,559 --> 00:30:09,600
you know

892
00:30:09,600 --> 00:30:10,880
i'm a bit puzzled by the

893
00:30:10,880 --> 00:30:12,960
incompressibility argument that you you

894
00:30:12,960 --> 00:30:14,559
presented because when you have a

895
00:30:14,559 --> 00:30:17,039
signature you have many messages for

896
00:30:17,039 --> 00:30:19,120
which the signature is valid in

897
00:30:19,120 --> 00:30:21,200
including the one you're looking for so

898
00:30:21,200 --> 00:30:22,159
in

899
00:30:22,159 --> 00:30:23,919
when you you have exhaustive search you

900
00:30:23,919 --> 00:30:25,520
will find many other messages so it

901
00:30:25,520 --> 00:30:28,240
doesn't really decompress

902
00:30:28,240 --> 00:30:29,840
uh

903
00:30:29,840 --> 00:30:31,039
do you mean the incompressibility

904
00:30:31,039 --> 00:30:33,039
argument is doesn't guarantee that you

905
00:30:33,039 --> 00:30:35,039
can extract all signatures correctly is

906
00:30:35,039 --> 00:30:36,640
that the question so

907
00:30:36,640 --> 00:30:38,480
in the incompressibility argument you

908
00:30:38,480 --> 00:30:40,320
presented you say that from the

909
00:30:40,320 --> 00:30:42,000
aggregate signature

910
00:30:42,000 --> 00:30:43,520
you should be able to

911
00:30:43,520 --> 00:30:45,600
uncompress all the message all the

912
00:30:45,600 --> 00:30:47,360
messages which have been signed by

913
00:30:47,360 --> 00:30:49,200
exhaustive search but if you do so you

914
00:30:49,200 --> 00:30:51,200
will have a much bigger set so you won't

915
00:30:51,200 --> 00:30:52,799
you won't have the original set of

916
00:30:52,799 --> 00:30:54,000
messages

917
00:30:54,000 --> 00:30:57,039
so it's not really decompressing so i

918
00:30:57,039 --> 00:30:59,039
wonder if this argument has been

919
00:30:59,039 --> 00:31:01,919
formally proven that you cannot have any

920
00:31:01,919 --> 00:31:04,320
uh locally verifiable aggregate

921
00:31:04,320 --> 00:31:06,320
signature all right

922
00:31:06,320 --> 00:31:08,080
is there any other stuff okay i

923
00:31:08,080 --> 00:31:09,919
understand the question okay let me uh

924
00:31:09,919 --> 00:31:11,120
please clarify in case i'm not

925
00:31:11,120 --> 00:31:12,000
misunderstanding the question the

926
00:31:12,000 --> 00:31:13,840
question is that typically i'm assuming

927
00:31:13,840 --> 00:31:16,880
that the messages that the the the set

928
00:31:16,880 --> 00:31:18,480
of messages for which we are trying to

929
00:31:18,480 --> 00:31:20,320
sort of just locally aggregate them that

930
00:31:20,320 --> 00:31:21,919
is a priority known and that's a fixed

931
00:31:21,919 --> 00:31:23,919
size set for which you can kind of over

932
00:31:23,919 --> 00:31:25,360
basically do like a brute force search

933
00:31:25,360 --> 00:31:26,880
and so just come up with the this

934
00:31:26,880 --> 00:31:28,480
testing operation but if the message

935
00:31:28,480 --> 00:31:30,240
says exponential size

936
00:31:30,240 --> 00:31:31,840
in that case how to sort of just make

937
00:31:31,840 --> 00:31:32,960
sure that you can potentially sort of

938
00:31:32,960 --> 00:31:34,480
just here follow the same uh

939
00:31:34,480 --> 00:31:35,840
incompressibility argument is that the

940
00:31:35,840 --> 00:31:37,679
question

941
00:31:37,679 --> 00:31:39,519
so i wonder if the argument that you

942
00:31:39,519 --> 00:31:41,440
presented is formally programmed yeah it

943
00:31:41,440 --> 00:31:43,039
is formula one yeah it's in the paper

944
00:31:43,039 --> 00:31:44,559
yeah i'd be happy to talk about it yeah

945
00:31:44,559 --> 00:31:46,399
it is

946
00:31:46,399 --> 00:31:50,399
all right let's thank the speaker again

947
00:31:54,399 --> 00:31:57,600
so next up is a

948
00:31:57,600 --> 00:31:58,720
talk about

949
00:31:58,720 --> 00:32:00,960
multi-model private signatures this is a

950
00:32:00,960 --> 00:32:03,760
work by kawa nugent

951
00:32:03,760 --> 00:32:06,720
willie susilo and women young

952
00:32:06,720 --> 00:32:08,880
and unfortunately the speaker could be

953
00:32:08,880 --> 00:32:11,039
here at scoring

954
00:32:11,039 --> 00:32:13,519
and we're going to run a video of his

955
00:32:13,519 --> 00:32:16,000
presentation and i see

956
00:32:16,000 --> 00:32:19,279
kevin has already set up the video so

957
00:32:19,279 --> 00:32:21,360
i guess i guess kevin you can get it

958
00:32:21,360 --> 00:32:23,760
rolling

959
00:32:25,120 --> 00:32:28,000
hello everyone i am from the university

960
00:32:28,000 --> 00:32:30,000
of wollongong australia

961
00:32:30,000 --> 00:32:32,480
today i am going to talk about new

962
00:32:32,480 --> 00:32:34,960
approach to address the tension between

963
00:32:34,960 --> 00:32:39,039
privacy can you please wait up a second

964
00:32:40,000 --> 00:32:43,840
on zoom can you please hold up thank you

965
00:33:01,600 --> 00:33:03,679
okay now you can return

966
00:33:03,679 --> 00:33:06,000
thank you

967
00:33:07,279 --> 00:33:09,679
hello everyone i am wing from the

968
00:33:09,679 --> 00:33:12,000
university of wollongong australia

969
00:33:12,000 --> 00:33:14,559
today i am going to talk about new

970
00:33:14,559 --> 00:33:17,039
approach to address the tension between

971
00:33:17,039 --> 00:33:20,240
privacy and accountability in multi-user

972
00:33:20,240 --> 00:33:22,399
authentication systems

973
00:33:22,399 --> 00:33:25,200
this is a child work with my colleagues

974
00:33:25,200 --> 00:33:28,799
at the university of wollongong fujungo

975
00:33:28,799 --> 00:33:31,760
willie sushilon and bomin yang

976
00:33:31,760 --> 00:33:34,720
we call our new cryptographic primitive

977
00:33:34,720 --> 00:33:39,440
multimodal private signatures

978
00:33:39,440 --> 00:33:41,600
here in the plan of my talk

979
00:33:41,600 --> 00:33:44,000
first i will discuss several prominent

980
00:33:44,000 --> 00:33:46,799
examples of previous multi-user

981
00:33:46,799 --> 00:33:49,679
signature systems with privacy and

982
00:33:49,679 --> 00:33:51,600
accountability features

983
00:33:51,600 --> 00:33:54,399
and our observation regarding their

984
00:33:54,399 --> 00:33:56,080
shortcomings

985
00:33:56,080 --> 00:33:59,120
then i will demonstrate how our new

986
00:33:59,120 --> 00:34:00,880
primitive can

987
00:34:00,880 --> 00:34:02,399
address these

988
00:34:02,399 --> 00:34:03,919
shortcomings

989
00:34:03,919 --> 00:34:07,200
next i will sketch our definitions and

990
00:34:07,200 --> 00:34:09,760
constructions from multimodal private

991
00:34:09,760 --> 00:34:11,119
signatures

992
00:34:11,119 --> 00:34:13,199
finally i will list

993
00:34:13,199 --> 00:34:15,280
several interesting questions that we

994
00:34:15,280 --> 00:34:18,079
left open

995
00:34:19,040 --> 00:34:21,040
let us first consider the setting of

996
00:34:21,040 --> 00:34:22,960
principle majors

997
00:34:22,960 --> 00:34:24,800
one of the most well-known private

998
00:34:24,800 --> 00:34:27,839
signature systems

999
00:34:28,000 --> 00:34:30,159
we have a group of users

1000
00:34:30,159 --> 00:34:33,359
each user has a secret signing key which

1001
00:34:33,359 --> 00:34:35,760
can be used to sign message

1002
00:34:35,760 --> 00:34:39,359
in an anonymous manner

1003
00:34:39,839 --> 00:34:42,239
here signup

1004
00:34:42,239 --> 00:34:45,440
personal identifiable information id can

1005
00:34:45,440 --> 00:34:49,599
issue a signature on any message

1006
00:34:49,599 --> 00:34:52,079
in a way such that the signature

1007
00:34:52,079 --> 00:34:54,960
verifiers can be convinced that a

1008
00:34:54,960 --> 00:34:58,480
signature was from someone in the group

1009
00:34:58,480 --> 00:35:01,119
but cannot determine who is

1010
00:35:01,119 --> 00:35:03,520
the actual assignment

1011
00:35:03,520 --> 00:35:04,640
here

1012
00:35:04,640 --> 00:35:06,880
green signature provides absolute

1013
00:35:06,880 --> 00:35:09,680
privacy for signers

1014
00:35:09,680 --> 00:35:12,240
absolute anonymity could be a nice

1015
00:35:12,240 --> 00:35:15,200
feature that protects the users in

1016
00:35:15,200 --> 00:35:17,040
certain situations

1017
00:35:17,040 --> 00:35:18,960
such as visual blogging

1018
00:35:18,960 --> 00:35:21,839
however it can also be abused for

1019
00:35:21,839 --> 00:35:25,280
unethical or illegal purposes

1020
00:35:25,280 --> 00:35:26,400
therefore

1021
00:35:26,400 --> 00:35:29,280
it would be desirable to restrict the

1022
00:35:29,280 --> 00:35:32,000
acceptance anonymity of users in ring

1023
00:35:32,000 --> 00:35:33,200
signatures

1024
00:35:33,200 --> 00:35:34,240
in fact

1025
00:35:34,240 --> 00:35:36,960
there have been several attempts such as

1026
00:35:36,960 --> 00:35:39,200
linkable resignations or traceable

1027
00:35:39,200 --> 00:35:40,720
resignations

1028
00:35:40,720 --> 00:35:43,440
however the linking and tracing

1029
00:35:43,440 --> 00:35:45,839
mechanisms in this system

1030
00:35:45,839 --> 00:35:49,760
can only be activated if the signer is

1031
00:35:49,760 --> 00:35:52,880
questions has generated at least two

1032
00:35:52,880 --> 00:35:55,119
signatures

1033
00:35:55,119 --> 00:35:58,400
if a malicious signer only issue one

1034
00:35:58,400 --> 00:36:01,280
controversial signature and then went

1035
00:36:01,280 --> 00:36:03,359
offline forever

1036
00:36:03,359 --> 00:36:07,839
then it can avoid accountability

1037
00:36:07,839 --> 00:36:11,119
it will look for a primitive offering

1038
00:36:11,119 --> 00:36:14,000
both anonymity and accountability

1039
00:36:14,000 --> 00:36:16,560
then the most well-known example is

1040
00:36:16,560 --> 00:36:19,119
group signature

1041
00:36:19,119 --> 00:36:21,760
in group signature we have an opening

1042
00:36:21,760 --> 00:36:23,119
authority

1043
00:36:23,119 --> 00:36:26,400
whose secret can be used to trace any

1044
00:36:26,400 --> 00:36:30,160
very signature and recover the identity

1045
00:36:30,160 --> 00:36:32,320
of the signer

1046
00:36:32,320 --> 00:36:34,800
this authority is supposed to take

1047
00:36:34,800 --> 00:36:38,560
action only in case of disputes

1048
00:36:38,560 --> 00:36:42,320
but wait if zig authority is corrupted

1049
00:36:42,320 --> 00:36:45,760
then it can open all signatures at will

1050
00:36:45,760 --> 00:36:48,800
and in that case there is essentially no

1051
00:36:48,800 --> 00:36:51,359
privacy for users

1052
00:36:51,359 --> 00:36:53,200
there have been several attempts to

1053
00:36:53,200 --> 00:36:55,839
restrict the power of the opening

1054
00:36:55,839 --> 00:36:58,079
authority in group signatures

1055
00:36:58,079 --> 00:37:00,560
such as traceable signatures group

1056
00:37:00,560 --> 00:37:02,800
signatures with message dependent

1057
00:37:02,800 --> 00:37:04,960
opening are accountable facing

1058
00:37:04,960 --> 00:37:06,720
signatures

1059
00:37:06,720 --> 00:37:10,240
however in this system there is always a

1060
00:37:10,240 --> 00:37:12,720
party who can break

1061
00:37:12,720 --> 00:37:16,079
signers privacy without any consent

1062
00:37:16,079 --> 00:37:18,320
so on the one hand we have ring

1063
00:37:18,320 --> 00:37:19,680
signature

1064
00:37:19,680 --> 00:37:22,240
and variants that give too much

1065
00:37:22,240 --> 00:37:24,560
privilege for users

1066
00:37:24,560 --> 00:37:26,240
on the other hand we have group

1067
00:37:26,240 --> 00:37:29,839
signatures and variants that provide too

1068
00:37:29,839 --> 00:37:31,200
much power

1069
00:37:31,200 --> 00:37:33,520
for the authorities

1070
00:37:33,520 --> 00:37:36,160
finding a solution that is reasonably

1071
00:37:36,160 --> 00:37:39,839
fair for more users and have authorities

1072
00:37:39,839 --> 00:37:42,880
a solution that balance privacy and

1073
00:37:42,880 --> 00:37:44,480
accountability

1074
00:37:44,480 --> 00:37:46,560
was a challenging problem

1075
00:37:46,560 --> 00:37:50,119
for a long time

1076
00:37:50,320 --> 00:37:52,800
a new approach towards solving this

1077
00:37:52,800 --> 00:37:55,520
tension was proposed last year at

1078
00:37:55,520 --> 00:37:57,119
eurocrypt

1079
00:37:57,119 --> 00:38:00,000
in a work by libert myself

1080
00:38:00,000 --> 00:38:02,240
with us and jung

1081
00:38:02,240 --> 00:38:05,040
we introduced bifurcated anonymous

1082
00:38:05,040 --> 00:38:08,400
signatures of bias for short which can

1083
00:38:08,400 --> 00:38:11,599
be seen as a hybrid of ringside natures

1084
00:38:11,599 --> 00:38:13,520
and good signatures

1085
00:38:13,520 --> 00:38:15,200
more precisely

1086
00:38:15,200 --> 00:38:17,920
a given bias could be traceable or

1087
00:38:17,920 --> 00:38:19,359
nontraceable

1088
00:38:19,359 --> 00:38:22,800
depending on a predicate big p

1089
00:38:22,800 --> 00:38:27,119
computed by the signer before signing

1090
00:38:30,160 --> 00:38:32,079
if p is is

1091
00:38:32,079 --> 00:38:35,920
zero then the signature is not traceable

1092
00:38:35,920 --> 00:38:37,839
and the authority can learn nothing

1093
00:38:37,839 --> 00:38:42,240
about ali as in ringside nature

1094
00:38:42,640 --> 00:38:45,200
if p is one then the signature is

1095
00:38:45,200 --> 00:38:46,400
traceable

1096
00:38:46,400 --> 00:38:49,040
and the authority can recover id

1097
00:38:49,040 --> 00:38:51,599
as in group signatures

1098
00:38:51,599 --> 00:38:55,119
since the user knows p in advance

1099
00:38:55,119 --> 00:38:57,440
it can control its privacy and

1100
00:38:57,440 --> 00:38:59,599
accountability

1101
00:38:59,599 --> 00:39:02,640
in the traceable case it can decide

1102
00:39:02,640 --> 00:39:06,000
whether to sign the given message or not

1103
00:39:06,000 --> 00:39:07,839
on the other hand

1104
00:39:07,839 --> 00:39:10,480
the authority can also ensure that

1105
00:39:10,480 --> 00:39:13,760
signers of all traceable signatures will

1106
00:39:13,760 --> 00:39:15,839
be kept accountable

1107
00:39:15,839 --> 00:39:16,640
so

1108
00:39:16,640 --> 00:39:17,760
bias

1109
00:39:17,760 --> 00:39:20,960
seems to have provided a nice solution

1110
00:39:20,960 --> 00:39:23,359
to the tension between privacy and

1111
00:39:23,359 --> 00:39:24,720
accountability

1112
00:39:24,720 --> 00:39:26,320
however

1113
00:39:26,320 --> 00:39:29,839
there are still problems

1114
00:39:31,599 --> 00:39:34,960
there is in fact a crucial disadvantage

1115
00:39:34,960 --> 00:39:36,160
of bias

1116
00:39:36,160 --> 00:39:38,880
approved signatures and all similar

1117
00:39:38,880 --> 00:39:40,640
proposals

1118
00:39:40,640 --> 00:39:43,839
we observe that accountability in these

1119
00:39:43,839 --> 00:39:44,960
systems

1120
00:39:44,960 --> 00:39:46,560
is realized

1121
00:39:46,560 --> 00:39:49,760
via a total tracing procedure

1122
00:39:49,760 --> 00:39:52,480
during which the whole identity of the

1123
00:39:52,480 --> 00:39:56,160
trace users must be disclosed to the

1124
00:39:56,160 --> 00:39:58,400
authorities

1125
00:39:58,400 --> 00:40:00,960
this level of accountability

1126
00:40:00,960 --> 00:40:04,800
is indeed a serious violation of users

1127
00:40:04,800 --> 00:40:07,280
privacy

1128
00:40:07,280 --> 00:40:09,520
why privacy

1129
00:40:09,520 --> 00:40:12,319
can be a very complicated notion

1130
00:40:12,319 --> 00:40:15,839
in its previous sense it can be defined

1131
00:40:15,839 --> 00:40:18,880
as the right of an individual

1132
00:40:18,880 --> 00:40:20,319
to control

1133
00:40:20,319 --> 00:40:23,920
which piece of information about herself

1134
00:40:23,920 --> 00:40:28,319
or himself can be disclosed

1135
00:40:28,960 --> 00:40:32,880
furthermore in many real-life situations

1136
00:40:32,880 --> 00:40:35,280
it is not necessarily

1137
00:40:35,280 --> 00:40:38,960
the highest priority for authorities to

1138
00:40:38,960 --> 00:40:42,000
perform a total basing

1139
00:40:42,000 --> 00:40:43,680
for instance

1140
00:40:43,680 --> 00:40:46,640
the authorities could only be interested

1141
00:40:46,640 --> 00:40:48,720
in learning whether

1142
00:40:48,720 --> 00:40:52,800
an anonymous user is over 18 years old

1143
00:40:52,800 --> 00:40:55,920
r works in a given organization

1144
00:40:55,920 --> 00:40:58,960
r lives in a particular area

1145
00:40:58,960 --> 00:41:01,920
r has an annual income exceeding certain

1146
00:41:01,920 --> 00:41:03,119
threshold

1147
00:41:03,119 --> 00:41:05,839
r has been fully vaccinated against

1148
00:41:05,839 --> 00:41:08,319
covet knighting etc

1149
00:41:08,319 --> 00:41:11,119
this observation motivated us to

1150
00:41:11,119 --> 00:41:12,880
consider systems

1151
00:41:12,880 --> 00:41:15,920
in which users and authorities have

1152
00:41:15,920 --> 00:41:17,839
certain agreement

1153
00:41:17,839 --> 00:41:18,880
on which

1154
00:41:18,880 --> 00:41:20,720
piece of information

1155
00:41:20,720 --> 00:41:24,000
can possibly be disclosed for each

1156
00:41:24,000 --> 00:41:26,720
signature

1157
00:41:28,240 --> 00:41:31,040
our proposal can be summarized as

1158
00:41:31,040 --> 00:41:32,319
follows

1159
00:41:32,319 --> 00:41:35,359
when setting up a system we specify a

1160
00:41:35,359 --> 00:41:38,160
list of signing functions and a list of

1161
00:41:38,160 --> 00:41:40,480
k disclosing functions

1162
00:41:40,480 --> 00:41:44,800
denoted by g1 t2 and so on to gk

1163
00:41:44,800 --> 00:41:49,520
where k is a positive integer if user id

1164
00:41:49,520 --> 00:41:52,160
wants to sign message m with respect to

1165
00:41:52,160 --> 00:41:53,920
assigning function f

1166
00:41:53,920 --> 00:41:55,920
then it first computes

1167
00:41:55,920 --> 00:41:59,359
f of m w and id

1168
00:41:59,359 --> 00:42:03,119
where w is an auxiliary information that

1169
00:42:03,119 --> 00:42:05,760
we call a witness

1170
00:42:05,760 --> 00:42:06,960
it serves

1171
00:42:06,960 --> 00:42:08,560
as an evidence

1172
00:42:08,560 --> 00:42:10,640
for the solubility

1173
00:42:10,640 --> 00:42:14,960
of the toggle mw and id

1174
00:42:15,359 --> 00:42:18,319
the value of f is an integer between 0

1175
00:42:18,319 --> 00:42:20,000
and k

1176
00:42:20,000 --> 00:42:21,680
if it is 0

1177
00:42:21,680 --> 00:42:24,000
then m cannot be signed

1178
00:42:24,000 --> 00:42:27,359
and the user aborts

1179
00:42:27,359 --> 00:42:28,800
otherwise

1180
00:42:28,800 --> 00:42:32,240
when f is non-euro the user can generate

1181
00:42:32,240 --> 00:42:35,599
a very signature that is anonymous to

1182
00:42:35,599 --> 00:42:36,720
everyone

1183
00:42:36,720 --> 00:42:40,560
but the opening authority

1184
00:42:41,040 --> 00:42:42,000
so

1185
00:42:42,000 --> 00:42:44,000
what the opening authority can learn

1186
00:42:44,000 --> 00:42:46,240
then

1187
00:42:47,359 --> 00:42:50,000
if x is equal to 1 then it can learn the

1188
00:42:50,000 --> 00:42:52,160
function g 1 of id

1189
00:42:52,160 --> 00:42:55,118
and nothing else

1190
00:42:56,560 --> 00:42:59,680
if f is j for some integer j then it can

1191
00:42:59,680 --> 00:43:03,119
learn the function t j of id and nothing

1192
00:43:03,119 --> 00:43:05,119
else

1193
00:43:05,119 --> 00:43:08,319
the value of f indeed determines which

1194
00:43:08,319 --> 00:43:12,720
disclosing function will be activated

1195
00:43:12,720 --> 00:43:16,160
looking back our proposal captures

1196
00:43:16,160 --> 00:43:19,040
ring signatures group signatures and

1197
00:43:19,040 --> 00:43:22,319
bias as special cases

1198
00:43:22,319 --> 00:43:25,520
ring and group signatures correspond to

1199
00:43:25,520 --> 00:43:29,280
the case of a single disclosing function

1200
00:43:29,280 --> 00:43:32,079
for releasing natures it is the euro

1201
00:43:32,079 --> 00:43:33,440
function

1202
00:43:33,440 --> 00:43:36,640
for group signatures it is the identity

1203
00:43:36,640 --> 00:43:38,400
function

1204
00:43:38,400 --> 00:43:39,599
meanwhile

1205
00:43:39,599 --> 00:43:42,400
bias corresponds to the case of two

1206
00:43:42,400 --> 00:43:44,480
disclosing functions

1207
00:43:44,480 --> 00:43:45,839
the euro

1208
00:43:45,839 --> 00:43:49,920
function and z identity functions

1209
00:43:51,119 --> 00:43:53,280
as an example application

1210
00:43:53,280 --> 00:43:56,160
let us consider a scenario where we have

1211
00:43:56,160 --> 00:43:58,720
anonymous financial transactions

1212
00:43:58,720 --> 00:44:01,440
each has a hidden amount of money such

1213
00:44:01,440 --> 00:44:03,040
as in the privacy preserving

1214
00:44:03,040 --> 00:44:06,240
cryptocurrency system monero

1215
00:44:06,240 --> 00:44:08,880
the authority for instance can regulate

1216
00:44:08,880 --> 00:44:11,440
the system as follows

1217
00:44:11,440 --> 00:44:14,319
when an amount less than 100

1218
00:44:14,319 --> 00:44:16,560
the transaction will be anonymous to

1219
00:44:16,560 --> 00:44:19,760
everyone including the authority

1220
00:44:19,760 --> 00:44:21,280
however

1221
00:44:21,280 --> 00:44:24,240
when the amount is between 100 and 1000

1222
00:44:24,240 --> 00:44:27,200
the authority will be able to learn

1223
00:44:27,200 --> 00:44:29,599
the country of the center

1224
00:44:29,599 --> 00:44:33,119
when the amount is between 1000 and 10

1225
00:44:33,119 --> 00:44:34,640
thousands

1226
00:44:34,640 --> 00:44:37,119
the authority can identify the country

1227
00:44:37,119 --> 00:44:40,960
and the organization of the center

1228
00:44:40,960 --> 00:44:42,000
finally

1229
00:44:42,000 --> 00:44:45,200
for an amount at least 10 thousand

1230
00:44:45,200 --> 00:44:48,000
then the full identity of the center can

1231
00:44:48,000 --> 00:44:49,440
be traced

1232
00:44:49,440 --> 00:44:51,440
in other words we can have a

1233
00:44:51,440 --> 00:44:54,319
fine-grained accountability feature

1234
00:44:54,319 --> 00:44:57,440
depending on the underlying transaction

1235
00:44:57,440 --> 00:44:58,640
amounts

1236
00:44:58,640 --> 00:45:01,200
the authority can learn different pieces

1237
00:45:01,200 --> 00:45:05,520
of information about the center

1238
00:45:05,920 --> 00:45:10,079
now let me summarize our contributions

1239
00:45:10,079 --> 00:45:12,480
first we propose the concept of

1240
00:45:12,480 --> 00:45:16,960
multi-modal private signatures or mps

1241
00:45:16,960 --> 00:45:20,240
which is a new approach for addressing

1242
00:45:20,240 --> 00:45:21,839
the tension between privacy and

1243
00:45:21,839 --> 00:45:24,079
accountability in multi-user signature

1244
00:45:24,079 --> 00:45:25,359
systems

1245
00:45:25,359 --> 00:45:28,800
signatures in mbs are anonymous to

1246
00:45:28,800 --> 00:45:30,240
everyone

1247
00:45:30,240 --> 00:45:32,960
except the opening authority

1248
00:45:32,960 --> 00:45:35,440
who can learn some virtual information

1249
00:45:35,440 --> 00:45:36,480
of

1250
00:45:36,480 --> 00:45:38,319
the user identity

1251
00:45:38,319 --> 00:45:41,680
that piece of information can be defined

1252
00:45:41,680 --> 00:45:44,880
in a flexible and fast manner

1253
00:45:44,880 --> 00:45:49,280
based on a set of disclosing functions

1254
00:45:49,280 --> 00:45:50,640
privacy

1255
00:45:50,640 --> 00:45:54,000
is naturally achieved in nps

1256
00:45:54,000 --> 00:45:56,640
because signer can decide

1257
00:45:56,640 --> 00:45:59,200
which piece of personal information can

1258
00:45:59,200 --> 00:46:01,040
be disclosed

1259
00:46:01,040 --> 00:46:03,680
accountability is also achieved

1260
00:46:03,680 --> 00:46:06,079
since the authority can learn the

1261
00:46:06,079 --> 00:46:10,319
desirable information if needed

1262
00:46:11,520 --> 00:46:14,480
next we provide rigorous definitions for

1263
00:46:14,480 --> 00:46:15,599
mps

1264
00:46:15,599 --> 00:46:17,920
this step is quite exciting and is not

1265
00:46:17,920 --> 00:46:19,760
straight forward at all

1266
00:46:19,760 --> 00:46:22,480
we would like to make our definitions as

1267
00:46:22,480 --> 00:46:24,400
general as possible

1268
00:46:24,400 --> 00:46:26,880
by capturing not only the privacy and

1269
00:46:26,880 --> 00:46:29,760
accountability of green group and biased

1270
00:46:29,760 --> 00:46:30,880
natures

1271
00:46:30,880 --> 00:46:34,880
but also the five grand concerns on who

1272
00:46:34,880 --> 00:46:36,880
can sign which message

1273
00:46:36,880 --> 00:46:40,000
as in attribute-based policy-based and

1274
00:46:40,000 --> 00:46:42,319
functional signatures

1275
00:46:42,319 --> 00:46:45,040
it is also worth highlighting

1276
00:46:45,040 --> 00:46:45,839
that

1277
00:46:45,839 --> 00:46:48,960
the privacy definitions for mps is quite

1278
00:46:48,960 --> 00:46:51,920
involved since we have to address the

1279
00:46:51,920 --> 00:46:52,800
case

1280
00:46:52,800 --> 00:46:54,960
where the opening authority is fully

1281
00:46:54,960 --> 00:46:57,839
corrupted this level of privacy is

1282
00:46:57,839 --> 00:46:59,839
impossible to achieve

1283
00:46:59,839 --> 00:47:03,599
in ordinary root signatures

1284
00:47:03,599 --> 00:47:06,400
we provide a generic and modular

1285
00:47:06,400 --> 00:47:08,720
construction of mbs for arbitrary

1286
00:47:08,720 --> 00:47:10,960
functions based on commonly used

1287
00:47:10,960 --> 00:47:13,119
cryptographic building blocks

1288
00:47:13,119 --> 00:47:15,839
our construction can be instantiated in

1289
00:47:15,839 --> 00:47:18,400
the standard model from pairings

1290
00:47:18,400 --> 00:47:21,359
we also obtain a concrete lattice-based

1291
00:47:21,359 --> 00:47:25,839
construction in the random oracle model

1292
00:47:26,559 --> 00:47:29,280
regarding security of mps will require

1293
00:47:29,280 --> 00:47:31,760
two main properties privacy and

1294
00:47:31,760 --> 00:47:33,359
enforceability

1295
00:47:33,359 --> 00:47:37,280
privacy roughly ensures that each party

1296
00:47:37,280 --> 00:47:38,400
in the system

1297
00:47:38,400 --> 00:47:41,040
can only learn the piece of sinus

1298
00:47:41,040 --> 00:47:44,160
information which designer intends to

1299
00:47:44,160 --> 00:47:46,160
disclose

1300
00:47:46,160 --> 00:47:49,040
there are in fact two notions of privacy

1301
00:47:49,040 --> 00:47:50,839
that we should consider

1302
00:47:50,839 --> 00:47:54,800
first without the oa secret key it

1303
00:47:54,800 --> 00:47:57,599
should be infeasible for everyone to

1304
00:47:57,599 --> 00:47:59,119
learn anything

1305
00:47:59,119 --> 00:48:00,079
about

1306
00:48:00,079 --> 00:48:02,800
designers private information

1307
00:48:02,800 --> 00:48:04,000
second

1308
00:48:04,000 --> 00:48:06,559
even a fully corrupted oa

1309
00:48:06,559 --> 00:48:10,240
can not learn anything beyond the value

1310
00:48:10,240 --> 00:48:12,319
tj of id

1311
00:48:12,319 --> 00:48:13,680
this is

1312
00:48:13,680 --> 00:48:17,440
a very strong requirement indeed

1313
00:48:17,839 --> 00:48:20,640
unfoldability captures several

1314
00:48:20,640 --> 00:48:23,200
requirements first it should be

1315
00:48:23,200 --> 00:48:26,960
infeasible to generate a very signature

1316
00:48:26,960 --> 00:48:29,480
with respect to a turbo

1317
00:48:29,480 --> 00:48:33,599
mwid which is not assignable

1318
00:48:33,599 --> 00:48:36,960
second it should also be invisible to

1319
00:48:36,960 --> 00:48:40,079
mislead the signature opening

1320
00:48:40,079 --> 00:48:43,359
and third no one even a coalition of

1321
00:48:43,359 --> 00:48:46,160
corrupted group manager and

1322
00:48:46,160 --> 00:48:48,400
corrupted opening authority

1323
00:48:48,400 --> 00:48:51,440
can issue signatures on behalf of an

1324
00:48:51,440 --> 00:48:53,040
honest user

1325
00:48:53,040 --> 00:48:55,359
the second and the third requirements

1326
00:48:55,359 --> 00:48:57,839
in fact resemble the notions of full

1327
00:48:57,839 --> 00:49:00,880
traceability and non-flammability in

1328
00:49:00,880 --> 00:49:04,319
dynamic root signatures

1329
00:49:04,960 --> 00:49:07,119
in terms of constructions we obtain a

1330
00:49:07,119 --> 00:49:09,280
generic construction of mps for

1331
00:49:09,280 --> 00:49:11,440
arbitrary science functions and

1332
00:49:11,440 --> 00:49:14,000
arbitrary disclosing functions

1333
00:49:14,000 --> 00:49:16,800
the construction relies on commonly used

1334
00:49:16,800 --> 00:49:18,720
cryptographic building blocks

1335
00:49:18,720 --> 00:49:22,960
namely ordinary resources nature's ccseq

1336
00:49:22,960 --> 00:49:25,119
public inclusion and non-interactive

1337
00:49:25,119 --> 00:49:28,640
neurologic proof for general statements

1338
00:49:28,640 --> 00:49:30,880
as a feasibility result the construction

1339
00:49:30,880 --> 00:49:33,280
can be realized in the standard model

1340
00:49:33,280 --> 00:49:35,040
from parents

1341
00:49:35,040 --> 00:49:38,160
via the growth of slovsky hypo system

1342
00:49:38,160 --> 00:49:40,319
and from lattices via the parker's

1343
00:49:40,319 --> 00:49:44,240
saharan roof system

1344
00:49:44,240 --> 00:49:46,720
our construction follows the

1345
00:49:46,720 --> 00:49:49,280
size and encrypts improved paradigm

1346
00:49:49,280 --> 00:49:51,520
which is typically used for designing

1347
00:49:51,520 --> 00:49:53,520
good signatures

1348
00:49:53,520 --> 00:49:55,119
the group manager

1349
00:49:55,119 --> 00:49:57,440
certified the membership

1350
00:49:57,440 --> 00:50:00,000
by assigning the user's identity

1351
00:50:00,000 --> 00:50:02,319
when issuing a signature the user

1352
00:50:02,319 --> 00:50:03,920
encrypts something

1353
00:50:03,920 --> 00:50:06,319
improves welfareness of ciphertext as

1354
00:50:06,319 --> 00:50:09,040
well as knowledge of a valid membership

1355
00:50:09,040 --> 00:50:11,359
certificate

1356
00:50:11,359 --> 00:50:13,599
note that in group signature user

1357
00:50:13,599 --> 00:50:16,880
typically encrypts its phone identity id

1358
00:50:16,880 --> 00:50:20,079
in bias the ciphertext contains either

1359
00:50:20,079 --> 00:50:22,559
id or euro

1360
00:50:22,559 --> 00:50:24,640
here the main difference

1361
00:50:24,640 --> 00:50:26,880
is that cyber self-attack contains

1362
00:50:26,880 --> 00:50:31,200
exactly what needs to be disclosed

1363
00:50:32,079 --> 00:50:34,319
proven well-formed of such a subject in

1364
00:50:34,319 --> 00:50:36,319
general knowledge is the most important

1365
00:50:36,319 --> 00:50:40,359
step of the construction

1366
00:50:41,040 --> 00:50:43,280
as illustrations we instantiate the

1367
00:50:43,280 --> 00:50:45,440
system with concrete signing and

1368
00:50:45,440 --> 00:50:46,720
disclosing

1369
00:50:46,720 --> 00:50:48,000
functions

1370
00:50:48,000 --> 00:50:50,240
the correct evaluation of which can be

1371
00:50:50,240 --> 00:50:53,119
efficiently proved in your knowledge

1372
00:50:53,119 --> 00:50:55,599
we obtain a parent-based construction in

1373
00:50:55,599 --> 00:50:57,280
the standard model as well as a

1374
00:50:57,280 --> 00:50:58,800
lattice-based scheme in the random

1375
00:50:58,800 --> 00:51:01,440
oracle model that potentially enjoys

1376
00:51:01,440 --> 00:51:04,000
most quantum security

1377
00:51:04,000 --> 00:51:06,079
to be more specific in both

1378
00:51:06,079 --> 00:51:08,400
instantiations we consider the setting

1379
00:51:08,400 --> 00:51:10,800
with a single signing function f and

1380
00:51:10,800 --> 00:51:13,280
four disclosing functions

1381
00:51:13,280 --> 00:51:14,880
we let message m

1382
00:51:14,880 --> 00:51:18,800
be a commitment to witness w and define

1383
00:51:18,800 --> 00:51:20,319
function f

1384
00:51:20,319 --> 00:51:22,720
based on integer ranges

1385
00:51:22,720 --> 00:51:25,040
this is to capture our motivating

1386
00:51:25,040 --> 00:51:27,440
example about anonymous financial

1387
00:51:27,440 --> 00:51:31,119
transactions with hidden amounts

1388
00:51:31,119 --> 00:51:33,200
we also consider this closing function

1389
00:51:33,200 --> 00:51:36,160
as linear transformation

1390
00:51:36,160 --> 00:51:39,040
of id which are sufficient for many

1391
00:51:39,040 --> 00:51:41,759
applications

1392
00:51:42,160 --> 00:51:43,599
the bearing based and let bay

1393
00:51:43,599 --> 00:51:45,680
construction follow the same paradigms

1394
00:51:45,680 --> 00:51:48,240
as the generic consumption but we employ

1395
00:51:48,240 --> 00:51:49,599
some of

1396
00:51:49,599 --> 00:51:50,480
the

1397
00:51:50,480 --> 00:51:52,640
dedicated building blocks for efficiency

1398
00:51:52,640 --> 00:51:54,480
reasons

1399
00:51:54,480 --> 00:51:56,960
specifically the bearing basically

1400
00:51:56,960 --> 00:51:59,200
employs medicine commitment

1401
00:51:59,200 --> 00:52:01,119
a structured preserving signature by

1402
00:52:01,119 --> 00:52:04,720
clintus on the bonnevillian signature

1403
00:52:04,720 --> 00:52:06,800
tap based bke by

1404
00:52:06,800 --> 00:52:10,079
kings and the ghost sahibus

1405
00:52:10,079 --> 00:52:11,920
meanwhile

1406
00:52:11,920 --> 00:52:14,559
the lag-based scheme used the ktx

1407
00:52:14,559 --> 00:52:16,800
commitment a signature scheme with

1408
00:52:16,800 --> 00:52:19,680
efficient protocols by libertarian

1409
00:52:19,680 --> 00:52:24,800
ccseq pke obtained from the gbvib and

1410
00:52:24,800 --> 00:52:27,760
the csk transformation

1411
00:52:27,760 --> 00:52:30,160
and the stern-like neural argument

1412
00:52:30,160 --> 00:52:33,160
systems

1413
00:52:33,280 --> 00:52:34,400
finally

1414
00:52:34,400 --> 00:52:37,680
as the first work on multi-modal private

1415
00:52:37,680 --> 00:52:38,960
signature

1416
00:52:38,960 --> 00:52:42,720
we do not expect to provide a totally

1417
00:52:42,720 --> 00:52:44,960
thorough study of this primitive

1418
00:52:44,960 --> 00:52:47,200
we leave several interesting open

1419
00:52:47,200 --> 00:52:48,960
questions for future

1420
00:52:48,960 --> 00:52:51,040
investigations

1421
00:52:51,040 --> 00:52:52,480
the first question

1422
00:52:52,480 --> 00:52:54,160
is to construct

1423
00:52:54,160 --> 00:52:57,359
practically usable npsc schemes which

1424
00:52:57,359 --> 00:53:00,160
expands expressive signing and scoring

1425
00:53:00,160 --> 00:53:03,279
disclosing functions

1426
00:53:04,079 --> 00:53:07,119
designing efficient mps schemes with

1427
00:53:07,119 --> 00:53:09,599
both quantum security is also a

1428
00:53:09,599 --> 00:53:12,319
fascinating question

1429
00:53:12,319 --> 00:53:15,200
note that our proposed parent based and

1430
00:53:15,200 --> 00:53:18,240
lagged weight consumption

1431
00:53:18,880 --> 00:53:21,599
do capture quite expressive functions

1432
00:53:21,599 --> 00:53:25,040
but are not very efficient

1433
00:53:25,280 --> 00:53:27,680
from the theoretical perspective

1434
00:53:27,680 --> 00:53:30,400
it is worth studying the connections

1435
00:53:30,400 --> 00:53:33,040
between mps and other advanced

1436
00:53:33,040 --> 00:53:34,319
primitives

1437
00:53:34,319 --> 00:53:37,520
like functional encryption

1438
00:53:37,520 --> 00:53:38,720
in fact

1439
00:53:38,720 --> 00:53:41,680
the idea that decryption reveals a

1440
00:53:41,680 --> 00:53:44,240
function of the identity

1441
00:53:44,240 --> 00:53:47,599
is closely related to the spirit of

1442
00:53:47,599 --> 00:53:49,760
functional encryption

1443
00:53:49,760 --> 00:53:51,359
however

1444
00:53:51,359 --> 00:53:54,880
so far we have been unable to obtain a

1445
00:53:54,880 --> 00:53:57,680
conception of mbs based on

1446
00:53:57,680 --> 00:54:00,480
functional encryption

1447
00:54:00,480 --> 00:54:03,359
another appealing question is to equip

1448
00:54:03,359 --> 00:54:05,280
mbs with

1449
00:54:05,280 --> 00:54:08,720
additional functionalities such as

1450
00:54:08,720 --> 00:54:11,200
verifiable opening

1451
00:54:11,200 --> 00:54:15,200
of user revocations

1452
00:54:15,599 --> 00:54:18,800
and let me conclude my presentation here

1453
00:54:18,800 --> 00:54:21,359
thank you for your attention

1454
00:54:21,359 --> 00:54:23,920
i am happy to answer your questions

1455
00:54:23,920 --> 00:54:26,160
either online after the talk

1456
00:54:26,160 --> 00:54:30,399
or via emails thank you

1457
00:54:35,119 --> 00:54:37,920
okay i think q a will be very short in

1458
00:54:37,920 --> 00:54:40,400
case you have any question you can

1459
00:54:40,400 --> 00:54:43,359
contact the authors by email and you i

1460
00:54:43,359 --> 00:54:45,040
guess you are able to find the email in

1461
00:54:45,040 --> 00:54:46,640
the paper

1462
00:54:46,640 --> 00:54:49,680
and send you questions there

1463
00:54:49,680 --> 00:54:51,119
all right

1464
00:54:51,119 --> 00:54:54,319
so this brings us to the final

1465
00:54:54,319 --> 00:54:57,599
presentation of the session

1466
00:55:00,880 --> 00:55:03,760
so the title of the paper is pi cut shoe

1467
00:55:03,760 --> 00:55:06,079
and friends compact blind signatures by

1468
00:55:06,079 --> 00:55:08,240
a parallel instance cutting shoes and

1469
00:55:08,240 --> 00:55:09,280
more

1470
00:55:09,280 --> 00:55:11,680
and this is a paper by rocha tone

1471
00:55:11,680 --> 00:55:13,359
character

1472
00:55:13,359 --> 00:55:18,440
duchenne hanslick julian los angeles

1473
00:55:18,839 --> 00:55:20,559
benedict wagner

1474
00:55:20,559 --> 00:55:22,960
and we have actually two presenters

1475
00:55:22,960 --> 00:55:25,680
benedict and rochaton will present the

1476
00:55:25,680 --> 00:55:28,480
work together

1477
00:55:31,440 --> 00:55:35,079
slides are there

1478
00:55:48,079 --> 00:55:52,680
you can see the slides in zoom as well

1479
00:56:11,520 --> 00:56:13,599
it's like running a video so a quick

1480
00:56:13,599 --> 00:56:15,599
view of the talking in backward

1481
00:56:15,599 --> 00:56:18,079
direction

1482
00:56:20,319 --> 00:56:22,400
now we're good to go

1483
00:56:22,400 --> 00:56:23,599
uh

1484
00:56:23,599 --> 00:56:26,720
hello okay hello um so today uh we're

1485
00:56:26,720 --> 00:56:28,799
gonna present uh pikachu and friends

1486
00:56:28,799 --> 00:56:30,559
come compact line signatures via

1487
00:56:30,559 --> 00:56:32,880
parallel instance cut and shoes and more

1488
00:56:32,880 --> 00:56:35,040
um this work is a joint work with los

1489
00:56:35,040 --> 00:56:38,000
lucian julian anna and benedict

1490
00:56:38,000 --> 00:56:39,839
lucian julian and benedict are from

1491
00:56:39,839 --> 00:56:43,680
cispa and anna and i are from brown

1492
00:56:43,680 --> 00:56:45,440
today the talk is going to be split into

1493
00:56:45,440 --> 00:56:47,119
two parts the first part i will talk

1494
00:56:47,119 --> 00:56:49,280
about in the second part benedict will

1495
00:56:49,280 --> 00:56:50,799
present it

1496
00:56:50,799 --> 00:56:54,559
uh so first uh what are blind signatures

1497
00:56:54,559 --> 00:56:56,400
blind signatures introduced by david

1498
00:56:56,400 --> 00:56:57,599
chom

1499
00:56:57,599 --> 00:56:59,680
there's a cryptographic protocol

1500
00:56:59,680 --> 00:57:02,079
including a signer and a user

1501
00:57:02,079 --> 00:57:04,640
the signer controls the secret key while

1502
00:57:04,640 --> 00:57:06,640
the user has a message that it wants to

1503
00:57:06,640 --> 00:57:08,480
be signed without designer knowing the

1504
00:57:08,480 --> 00:57:10,079
message

1505
00:57:10,079 --> 00:57:11,520
at the end the user will receive a

1506
00:57:11,520 --> 00:57:13,359
signature

1507
00:57:13,359 --> 00:57:15,040
so why do we care about buying

1508
00:57:15,040 --> 00:57:16,240
signatures

1509
00:57:16,240 --> 00:57:18,319
it's because there are applications such

1510
00:57:18,319 --> 00:57:21,040
as unlinkable payment system electronic

1511
00:57:21,040 --> 00:57:23,599
cash also voting

1512
00:57:23,599 --> 00:57:25,520
our goal here is to

1513
00:57:25,520 --> 00:57:27,359
get a blind signature construction that

1514
00:57:27,359 --> 00:57:29,839
have efficient parameters these comes in

1515
00:57:29,839 --> 00:57:33,040
the front the form of

1516
00:57:33,040 --> 00:57:36,240
the signature size and also

1517
00:57:36,240 --> 00:57:39,119
the communication complexity

1518
00:57:39,119 --> 00:57:40,799
so what security

1519
00:57:40,799 --> 00:57:42,240
properties do we want for client

1520
00:57:42,240 --> 00:57:43,839
signatures

1521
00:57:43,839 --> 00:57:45,839
the first one is called blindness

1522
00:57:45,839 --> 00:57:47,280
um

1523
00:57:47,280 --> 00:57:50,480
here um an adversarial signer um when

1524
00:57:50,480 --> 00:57:53,599
interacts with users and even if it at

1525
00:57:53,599 --> 00:57:55,200
the end it sees the message and

1526
00:57:55,200 --> 00:57:56,559
secondary pairs

1527
00:57:56,559 --> 00:57:58,640
designers can still

1528
00:57:58,640 --> 00:58:01,119
can still not um link these message and

1529
00:58:01,119 --> 00:58:03,359
secondary pairs back to which protocol

1530
00:58:03,359 --> 00:58:06,079
execution it was from

1531
00:58:06,079 --> 00:58:08,960
um the second security is

1532
00:58:08,960 --> 00:58:11,359
unforgivability property

1533
00:58:11,359 --> 00:58:13,119
uh in particular uh one more

1534
00:58:13,119 --> 00:58:14,960
enforceability

1535
00:58:14,960 --> 00:58:17,839
um so here we have an adversarial user

1536
00:58:17,839 --> 00:58:20,079
interacting with designer

1537
00:58:20,079 --> 00:58:22,160
um the user can interleave the protocol

1538
00:58:22,160 --> 00:58:25,599
executions as as it wants and then

1539
00:58:25,599 --> 00:58:28,160
after some number of signing sessions is

1540
00:58:28,160 --> 00:58:30,000
completed the user cannot learn more

1541
00:58:30,000 --> 00:58:32,319
than that number of messaging signature

1542
00:58:32,319 --> 00:58:33,359
pairs

1543
00:58:33,359 --> 00:58:35,359
um note here that um

1544
00:58:35,359 --> 00:58:37,760
here you don't want to use a normally

1545
00:58:37,760 --> 00:58:41,359
used unforgivability definition because

1546
00:58:41,359 --> 00:58:43,040
because of the blindness property and

1547
00:58:43,040 --> 00:58:45,440
the challenger does not know

1548
00:58:45,440 --> 00:58:47,760
if a new

1549
00:58:47,760 --> 00:58:50,079
message in signature fair outputted is a

1550
00:58:50,079 --> 00:58:51,839
new one or not

1551
00:58:51,839 --> 00:58:53,119
um

1552
00:58:53,119 --> 00:58:54,079
so

1553
00:58:54,079 --> 00:58:55,839
what is state of the art for blind

1554
00:58:55,839 --> 00:58:57,200
signatures

1555
00:58:57,200 --> 00:58:59,119
in the random oracle model where our

1556
00:58:59,119 --> 00:59:01,599
work is also based on

1557
00:59:01,599 --> 00:59:02,960
there are many of efficient

1558
00:59:02,960 --> 00:59:05,119
constructions

1559
00:59:05,119 --> 00:59:08,160
however some of them uses non-standard

1560
00:59:08,160 --> 00:59:10,079
assumptions such as interactive

1561
00:59:10,079 --> 00:59:13,119
assumptions uh for example one more

1562
00:59:13,119 --> 00:59:15,359
discrete law or something like that

1563
00:59:15,359 --> 00:59:16,400
um

1564
00:59:16,400 --> 00:59:20,079
some others efficient constructions

1565
00:59:20,079 --> 00:59:21,839
does not support polynomial number of

1566
00:59:21,839 --> 00:59:23,119
signatures

1567
00:59:23,119 --> 00:59:26,079
in particular um their security grantee

1568
00:59:26,079 --> 00:59:27,599
only allow

1569
00:59:27,599 --> 00:59:29,440
logarithmic number of signatures to be

1570
00:59:29,440 --> 00:59:31,440
issued

1571
00:59:31,440 --> 00:59:33,839
and there are also works that although

1572
00:59:33,839 --> 00:59:35,920
it's not that efficient but supports

1573
00:59:35,920 --> 00:59:38,799
polynomial number of signatures and also

1574
00:59:38,799 --> 00:59:41,200
uses standard assumptions

1575
00:59:41,200 --> 00:59:43,119
the goal is to find

1576
00:59:43,119 --> 00:59:44,960
a construction that is efficient

1577
00:59:44,960 --> 00:59:47,760
supports polynomial number signatures

1578
00:59:47,760 --> 00:59:50,240
and also um utilizes standard

1579
00:59:50,240 --> 00:59:52,799
assumptions

1580
00:59:53,119 --> 00:59:55,040
and now before we go into uh

1581
00:59:55,040 --> 00:59:58,079
into our um we'll introduce the work

1582
00:59:58,079 --> 01:00:00,559
that our is based on

1583
01:00:00,559 --> 01:00:04,240
we call it the boosting transform

1584
01:00:04,880 --> 01:00:06,720
so from the state-of-the-art slide

1585
01:00:06,720 --> 01:00:08,480
before

1586
01:00:08,480 --> 01:00:10,400
there are these signatures that

1587
01:00:10,400 --> 01:00:11,599
are secure

1588
01:00:11,599 --> 01:00:13,599
only when you

1589
01:00:13,599 --> 01:00:16,799
issue logarithmic number of signatures

1590
01:00:16,799 --> 01:00:19,440
we'll focus on a certain class called

1591
01:00:19,440 --> 01:00:21,280
the linear blind signatures

1592
01:00:21,280 --> 01:00:23,440
which is a three move blind signatures

1593
01:00:23,440 --> 01:00:26,160
as this one

1594
01:00:26,720 --> 01:00:28,960
so from last year ac

1595
01:00:28,960 --> 01:00:32,640
cuts laws in rosenberg uh

1596
01:00:32,640 --> 01:00:34,400
introduced a boosting transform that

1597
01:00:34,400 --> 01:00:36,480
transformed these linear bias signatures

1598
01:00:36,480 --> 01:00:39,280
into one a blind signature that supports

1599
01:00:39,280 --> 01:00:41,119
polynomial number of

1600
01:00:41,119 --> 01:00:43,119
signatures to be issued

1601
01:00:43,119 --> 01:00:45,119
the technique used here is

1602
01:00:45,119 --> 01:00:47,280
one other than cutting choose in the end

1603
01:00:47,280 --> 01:00:49,760
interaction

1604
01:00:49,760 --> 01:00:51,680
um so why does

1605
01:00:51,680 --> 01:00:54,839
so why does this transform work

1606
01:00:54,839 --> 01:00:57,920
um one of the properties of the linear

1607
01:00:57,920 --> 01:01:01,040
blind signature is that

1608
01:01:01,040 --> 01:01:04,480
the reduction or designer can simulate

1609
01:01:04,480 --> 01:01:06,880
the signing protocol without using the

1610
01:01:06,880 --> 01:01:08,160
key

1611
01:01:08,160 --> 01:01:10,000
if it knows the message and randomness

1612
01:01:10,000 --> 01:01:12,240
that the user is using

1613
01:01:12,240 --> 01:01:14,559
and here when you do cut and choose

1614
01:01:14,559 --> 01:01:15,440
um

1615
01:01:15,440 --> 01:01:18,240
the user has to commit the randomness

1616
01:01:18,240 --> 01:01:19,440
and the messages

1617
01:01:19,440 --> 01:01:20,960
that it's going to be using in the

1618
01:01:20,960 --> 01:01:23,920
protocol sends it to the designer and in

1619
01:01:23,920 --> 01:01:26,079
this case in the random oracle model the

1620
01:01:26,079 --> 01:01:27,839
reduction can

1621
01:01:27,839 --> 01:01:30,640
extract these randomness and messages

1622
01:01:30,640 --> 01:01:33,440
from the random oracle and then

1623
01:01:33,440 --> 01:01:35,920
use them to simulate

1624
01:01:35,920 --> 01:01:36,799
the

1625
01:01:36,799 --> 01:01:38,400
signing protocol

1626
01:01:38,400 --> 01:01:40,400
and you might wonder why we have to use

1627
01:01:40,400 --> 01:01:42,480
these it's because the linear blind

1628
01:01:42,480 --> 01:01:46,480
signature only supports logarithmic num

1629
01:01:46,480 --> 01:01:49,119
issue hello hello sorry

1630
01:01:49,119 --> 01:01:50,000
um

1631
01:01:50,000 --> 01:01:52,880
and that means that

1632
01:01:52,880 --> 01:01:55,119
for

1633
01:01:56,079 --> 01:01:59,359
for us for this for the construction to

1634
01:01:59,359 --> 01:02:01,359
support polynomial number of signatures

1635
01:02:01,359 --> 01:02:03,359
um we have to

1636
01:02:03,359 --> 01:02:05,119
a lot of those signatures to be

1637
01:02:05,119 --> 01:02:08,559
outputted in the reduction has to

1638
01:02:08,559 --> 01:02:10,799
come without using the

1639
01:02:10,799 --> 01:02:12,799
secret key

1640
01:02:12,799 --> 01:02:14,640
and here i'll outline what the boosting

1641
01:02:14,640 --> 01:02:16,640
transform does

1642
01:02:16,640 --> 01:02:18,559
in the end interaction designer just

1643
01:02:18,559 --> 01:02:20,400
sends

1644
01:02:20,400 --> 01:02:22,880
a number and saying that here we're

1645
01:02:22,880 --> 01:02:24,240
doing one out of encounter and choose

1646
01:02:24,240 --> 01:02:25,440
the user

1647
01:02:25,440 --> 01:02:27,280
then the user commits its randomness

1648
01:02:27,280 --> 01:02:29,200
sends back to the designer then they

1649
01:02:29,200 --> 01:02:30,640
interact and

1650
01:02:30,640 --> 01:02:32,240
the underlying

1651
01:02:32,240 --> 01:02:35,119
linear blind signature protocol

1652
01:02:35,119 --> 01:02:37,280
and then the signer picks one of these

1653
01:02:37,280 --> 01:02:38,960
and

1654
01:02:38,960 --> 01:02:40,720
protocol execution

1655
01:02:40,720 --> 01:02:43,359
and then the user opens the randomness

1656
01:02:43,359 --> 01:02:45,119
that it commits

1657
01:02:45,119 --> 01:02:48,000
before for all but the selected session

1658
01:02:48,000 --> 01:02:50,960
and then they complete the protocol

1659
01:02:50,960 --> 01:02:51,839
uh

1660
01:02:51,839 --> 01:02:54,799
you can see that there are these steps

1661
01:02:54,799 --> 01:02:56,640
that takes um

1662
01:02:56,640 --> 01:02:58,880
communication complexity with linear

1663
01:02:58,880 --> 01:03:00,720
dependency on n

1664
01:03:00,720 --> 01:03:04,160
and this is um inefficient

1665
01:03:04,160 --> 01:03:07,039
so for our results

1666
01:03:07,039 --> 01:03:09,760
um we use the same technique

1667
01:03:09,760 --> 01:03:12,079
and get the same result as

1668
01:03:12,079 --> 01:03:13,680
the boosting transform but we have a

1669
01:03:13,680 --> 01:03:15,520
communication complexity with

1670
01:03:15,520 --> 01:03:16,960
logarithmic

1671
01:03:16,960 --> 01:03:20,000
dependency on n

1672
01:03:20,400 --> 01:03:21,440
and so

1673
01:03:21,440 --> 01:03:23,760
from the boosting transform what we do

1674
01:03:23,760 --> 01:03:25,359
is that

1675
01:03:25,359 --> 01:03:29,480
these four steps here

1676
01:03:30,559 --> 01:03:31,839
okay

1677
01:03:31,839 --> 01:03:34,160
these four steps here um

1678
01:03:34,160 --> 01:03:36,240
we made changes to them so that the

1679
01:03:36,240 --> 01:03:39,119
communication complexity is reduced

1680
01:03:39,119 --> 01:03:41,280
um for the first one

1681
01:03:41,280 --> 01:03:42,640
we just

1682
01:03:42,640 --> 01:03:44,480
for the end commitments we just commit

1683
01:03:44,480 --> 01:03:46,480
them using a random oracle into one

1684
01:03:46,480 --> 01:03:49,039
commitment and sends them from the users

1685
01:03:49,039 --> 01:03:50,240
designer

1686
01:03:50,240 --> 01:03:52,880
the same is for for these challenges in

1687
01:03:52,880 --> 01:03:54,079
the

1688
01:03:54,079 --> 01:03:56,799
third part here

1689
01:03:56,799 --> 01:03:59,359
and then for the first messages sent

1690
01:03:59,359 --> 01:04:02,319
from the signer to the user

1691
01:04:02,319 --> 01:04:03,280
um

1692
01:04:03,280 --> 01:04:05,760
we have the signer only generate log end

1693
01:04:05,760 --> 01:04:08,079
of them and let the user derive um any

1694
01:04:08,079 --> 01:04:10,400
of them from there

1695
01:04:10,400 --> 01:04:12,240
uh so what about the last step of

1696
01:04:12,240 --> 01:04:16,000
opening the commitment

1697
01:04:16,160 --> 01:04:18,079
um so here

1698
01:04:18,079 --> 01:04:20,559
we use a cryptographic primitive called

1699
01:04:20,559 --> 01:04:23,520
punctuable pseudo random function or ppr

1700
01:04:23,520 --> 01:04:27,839
from sahai and waters in 2014

1701
01:04:28,000 --> 01:04:29,920
here we use the seed and then use the

1702
01:04:29,920 --> 01:04:34,240
pbrf to generate and pseudorandom values

1703
01:04:34,240 --> 01:04:36,400
we can reveal some of these

1704
01:04:36,400 --> 01:04:38,400
and the rest are still hidden

1705
01:04:38,400 --> 01:04:39,359
however

1706
01:04:39,359 --> 01:04:41,920
in random oracle model we can

1707
01:04:41,920 --> 01:04:44,480
uh instantiate the pprfs using the

1708
01:04:44,480 --> 01:04:46,400
random oracle and

1709
01:04:46,400 --> 01:04:49,359
the gtm3 construction and

1710
01:04:49,359 --> 01:04:51,520
when we review the values we can get the

1711
01:04:51,520 --> 01:04:54,000
communication to log n times the number

1712
01:04:54,000 --> 01:04:56,400
of non-revealed values

1713
01:04:56,400 --> 01:04:58,880
and here

1714
01:04:58,960 --> 01:05:00,559
to apply this to the cut and choose

1715
01:05:00,559 --> 01:05:02,960
transform um

1716
01:05:02,960 --> 01:05:05,280
so at first we can use the pbrf to

1717
01:05:05,280 --> 01:05:07,359
generate the randomness

1718
01:05:07,359 --> 01:05:09,680
and since we review all but one of the

1719
01:05:09,680 --> 01:05:12,720
selected sessions

1720
01:05:12,799 --> 01:05:16,480
here um we only have log communication

1721
01:05:16,480 --> 01:05:18,240
and we reduce the communication

1722
01:05:18,240 --> 01:05:20,480
complexity

1723
01:05:20,480 --> 01:05:23,200
and the next part benedict's gonna take

1724
01:05:23,200 --> 01:05:25,439
over

1725
01:05:28,400 --> 01:05:31,440
thanks so uh yeah i will present the

1726
01:05:31,440 --> 01:05:33,599
second part of this talk

1727
01:05:33,599 --> 01:05:34,559
um

1728
01:05:34,559 --> 01:05:36,799
so champ showed you this this generic

1729
01:05:36,799 --> 01:05:39,280
transform that that we have um from a

1730
01:05:39,280 --> 01:05:41,599
logarithmically secure linear blind

1731
01:05:41,599 --> 01:05:43,760
signature scheme to a fully secure blind

1732
01:05:43,760 --> 01:05:46,480
signature scheme and it is efficient in

1733
01:05:46,480 --> 01:05:48,720
terms of signature sizes in fact it was

1734
01:05:48,720 --> 01:05:51,520
before we started and our new version of

1735
01:05:51,520 --> 01:05:53,680
it is now also efficient in terms of

1736
01:05:53,680 --> 01:05:55,359
communication

1737
01:05:55,359 --> 01:05:57,440
the problem is that if we want to put

1738
01:05:57,440 --> 01:05:58,960
this to practice there are still a lot

1739
01:05:58,960 --> 01:06:01,599
of challenges for us to solve

1740
01:06:01,599 --> 01:06:05,200
let me let me show you why so the first

1741
01:06:05,200 --> 01:06:07,599
challenge is okay there's a gigantic

1742
01:06:07,599 --> 01:06:09,599
security loss from the underlying

1743
01:06:09,599 --> 01:06:11,359
assumption to this linear blind

1744
01:06:11,359 --> 01:06:13,760
signature scheme and this is actually

1745
01:06:13,760 --> 01:06:15,920
inherited

1746
01:06:15,920 --> 01:06:18,720
in our fully secure scheme

1747
01:06:18,720 --> 01:06:20,720
okay so the second problem that we have

1748
01:06:20,720 --> 01:06:22,960
is that the concrete communication

1749
01:06:22,960 --> 01:06:24,880
complexity

1750
01:06:24,880 --> 01:06:26,480
while it depends logarithmic on this

1751
01:06:26,480 --> 01:06:29,280
parameter n the coefficient

1752
01:06:29,280 --> 01:06:31,359
associated to this term depends on the

1753
01:06:31,359 --> 01:06:33,440
assumption i will explain why this is

1754
01:06:33,440 --> 01:06:35,280
the case in a minute

1755
01:06:35,280 --> 01:06:37,760
but in combination these two lead to

1756
01:06:37,760 --> 01:06:40,880
very inefficient concrete parameters so

1757
01:06:40,880 --> 01:06:43,280
we did some example calculation for the

1758
01:06:43,280 --> 01:06:45,839
case of version or instantiation and in

1759
01:06:45,839 --> 01:06:48,240
fact if you want to support 2 to the 30

1760
01:06:48,240 --> 01:06:51,599
signatures then you need to use a 12 000

1761
01:06:51,599 --> 01:06:53,599
bit size group which is clearly

1762
01:06:53,599 --> 01:06:55,520
impractical

1763
01:06:55,520 --> 01:06:57,280
okay so

1764
01:06:57,280 --> 01:06:59,440
let's look at this communication in a

1765
01:06:59,440 --> 01:07:01,200
bit more detail

1766
01:07:01,200 --> 01:07:03,520
where do we start from actually it so

1767
01:07:03,520 --> 01:07:05,039
mentioned we start with this linear

1768
01:07:05,039 --> 01:07:06,960
blind signature scheme where we have

1769
01:07:06,960 --> 01:07:09,359
this free message flow we send some r

1770
01:07:09,359 --> 01:07:12,079
get a challenge c send a message s

1771
01:07:12,079 --> 01:07:14,720
and this r is the image of some

1772
01:07:14,720 --> 01:07:16,880
lowercase r under a linear function for

1773
01:07:16,880 --> 01:07:20,240
example exponentiation in a in a cyclic

1774
01:07:20,240 --> 01:07:21,520
group

1775
01:07:21,520 --> 01:07:22,960
and now when we do this boosting

1776
01:07:22,960 --> 01:07:25,520
transform we have to send in our new

1777
01:07:25,520 --> 01:07:28,880
version logarithmic number of these r's

1778
01:07:28,880 --> 01:07:30,880
from the signer to the user

1779
01:07:30,880 --> 01:07:32,079
and

1780
01:07:32,079 --> 01:07:34,160
of course the size of one r depends on

1781
01:07:34,160 --> 01:07:35,520
this option

1782
01:07:35,520 --> 01:07:37,440
okay so this is the problem for our

1783
01:07:37,440 --> 01:07:39,599
communication so why

1784
01:07:39,599 --> 01:07:41,440
don't we just drop this first message

1785
01:07:41,440 --> 01:07:43,440
and go to a two-round scheme

1786
01:07:43,440 --> 01:07:47,440
so in this case we use bls

1787
01:07:47,440 --> 01:07:49,200
you will see why

1788
01:07:49,200 --> 01:07:51,280
in a few slides just trust me now that

1789
01:07:51,280 --> 01:07:53,440
this is a good choice you don't have to

1790
01:07:53,440 --> 01:07:55,200
understand all these details if you

1791
01:07:55,200 --> 01:07:57,440
don't know the scheme already what is

1792
01:07:57,440 --> 01:08:00,480
important for us is that we check

1793
01:08:00,480 --> 01:08:02,400
if we can still apply this boosting

1794
01:08:02,400 --> 01:08:04,559
transform right so for the boosting

1795
01:08:04,559 --> 01:08:06,240
transform we need essentially two

1796
01:08:06,240 --> 01:08:08,559
properties the first one champ already

1797
01:08:08,559 --> 01:08:10,480
mentioned this is

1798
01:08:10,480 --> 01:08:12,319
we call it property star because it's

1799
01:08:12,319 --> 01:08:14,319
important

1800
01:08:14,319 --> 01:08:17,198
you can simulate the signer side without

1801
01:08:17,198 --> 01:08:19,120
having the secret key

1802
01:08:19,120 --> 01:08:21,520
as soon as you know the message and the

1803
01:08:21,520 --> 01:08:22,839
randomness

1804
01:08:22,839 --> 01:08:25,920
okay you can do that by programming the

1805
01:08:25,920 --> 01:08:27,920
random oracle and the second property is

1806
01:08:27,920 --> 01:08:30,399
logarithmic security

1807
01:08:30,399 --> 01:08:33,198
okay so for blind bls we still have the

1808
01:08:33,198 --> 01:08:35,920
first property you can just uh if you

1809
01:08:35,920 --> 01:08:37,920
know the message you can and the alpha

1810
01:08:37,920 --> 01:08:39,839
you can cancel out the alpha and use the

1811
01:08:39,839 --> 01:08:41,600
standard way of

1812
01:08:41,600 --> 01:08:45,198
simulating bls signatures

1813
01:08:45,198 --> 01:08:47,279
okay but the problem is the second

1814
01:08:47,279 --> 01:08:49,520
property because for this scheme if we

1815
01:08:49,520 --> 01:08:51,198
want to rely on non-interactive

1816
01:08:51,198 --> 01:08:53,600
assumptions then we only have key only

1817
01:08:53,600 --> 01:08:56,640
security so to recall in a signature

1818
01:08:56,640 --> 01:08:58,880
scheme key only security means that the

1819
01:08:58,880 --> 01:09:00,719
adversary does not have access to a

1820
01:09:00,719 --> 01:09:02,880
signing oracle

1821
01:09:02,880 --> 01:09:05,520
and only to the public key

1822
01:09:05,520 --> 01:09:06,640
okay

1823
01:09:06,640 --> 01:09:09,040
so um this means that we need to

1824
01:09:09,040 --> 01:09:10,479
understand how we can change our

1825
01:09:10,479 --> 01:09:12,960
boosting transform to support key only

1826
01:09:12,960 --> 01:09:15,198
security right because now it only

1827
01:09:15,198 --> 01:09:17,359
supports logarithmic security

1828
01:09:17,359 --> 01:09:18,799
for that we introduced this new

1829
01:09:18,799 --> 01:09:20,719
technique parallel instance cut and

1830
01:09:20,719 --> 01:09:23,920
choose or for short pikachu

1831
01:09:23,920 --> 01:09:26,238
and to understand it we need to first

1832
01:09:26,238 --> 01:09:27,920
understand how does the original

1833
01:09:27,920 --> 01:09:29,679
boosting transform by cuts loss and

1834
01:09:29,679 --> 01:09:32,000
rosenberg works

1835
01:09:32,000 --> 01:09:34,238
so let me let me tell you that so we

1836
01:09:34,238 --> 01:09:37,198
consider a signer and a user or in a

1837
01:09:37,198 --> 01:09:39,600
security proof assigner oracle and the

1838
01:09:39,600 --> 01:09:42,399
adversary and what they do is they run

1839
01:09:42,399 --> 01:09:45,600
these n sessions of the underlying blind

1840
01:09:45,600 --> 01:09:47,679
signature scheme

1841
01:09:47,679 --> 01:09:51,040
and then one of them is chosen at random

1842
01:09:51,040 --> 01:09:52,799
and this one is completed while the

1843
01:09:52,799 --> 01:09:54,719
other ones are opened and by open i mean

1844
01:09:54,719 --> 01:09:57,040
that the user sends this message and

1845
01:09:57,040 --> 01:09:59,120
randomness that he used that he

1846
01:09:59,120 --> 01:10:00,880
committed to before

1847
01:10:00,880 --> 01:10:02,960
to the signer

1848
01:10:02,960 --> 01:10:04,800
okay so now we will look at these

1849
01:10:04,800 --> 01:10:06,719
sessions and distinguish between

1850
01:10:06,719 --> 01:10:09,600
malformed sessions and honest sessions

1851
01:10:09,600 --> 01:10:11,840
so what is a malformed session by that i

1852
01:10:11,840 --> 01:10:15,280
mean that the adversary

1853
01:10:15,600 --> 01:10:18,000
did not honestly commit to his message

1854
01:10:18,000 --> 01:10:19,679
and randomness or he computed the

1855
01:10:19,679 --> 01:10:22,800
challenge in a in a malicious way

1856
01:10:22,800 --> 01:10:24,800
okay so let's say the adversary mal

1857
01:10:24,800 --> 01:10:27,120
forms two or more

1858
01:10:27,120 --> 01:10:30,000
of these sessions then as he has to open

1859
01:10:30,000 --> 01:10:32,000
all but one of them

1860
01:10:32,000 --> 01:10:34,000
we never need to provide a response

1861
01:10:34,000 --> 01:10:36,400
because the signer will abort right the

1862
01:10:36,400 --> 01:10:39,280
the adversary will get caught

1863
01:10:39,280 --> 01:10:41,280
okay so that's good for our reduction we

1864
01:10:41,280 --> 01:10:42,719
don't need a secret key because we don't

1865
01:10:42,719 --> 01:10:45,280
need to provide a response the second

1866
01:10:45,280 --> 01:10:47,920
good case is where he is just honest he

1867
01:10:47,920 --> 01:10:50,640
commits to all of his randomness and

1868
01:10:50,640 --> 01:10:52,320
messages honestly

1869
01:10:52,320 --> 01:10:54,560
and then we can actually extract using

1870
01:10:54,560 --> 01:10:57,280
the random oracle because we use some

1871
01:10:57,280 --> 01:10:59,360
random oracle-based commitments and then

1872
01:10:59,360 --> 01:11:01,679
use this cool property star because now

1873
01:11:01,679 --> 01:11:03,280
we have the message and the randomness

1874
01:11:03,280 --> 01:11:06,080
to simulate without the secret key

1875
01:11:06,080 --> 01:11:07,120
okay

1876
01:11:07,120 --> 01:11:09,840
the tricky case is if he cheats in

1877
01:11:09,840 --> 01:11:12,640
exactly one session because in this case

1878
01:11:12,640 --> 01:11:14,719
we could hit this session with our cut

1879
01:11:14,719 --> 01:11:16,320
and choose index

1880
01:11:16,320 --> 01:11:18,880
and then we actually

1881
01:11:18,880 --> 01:11:20,960
need to ask the signer oracle of the

1882
01:11:20,960 --> 01:11:23,120
underlying

1883
01:11:23,120 --> 01:11:24,880
line signature scheme because we don't

1884
01:11:24,880 --> 01:11:26,480
have a secret key

1885
01:11:26,480 --> 01:11:28,239
okay so this happens with probability

1886
01:11:28,239 --> 01:11:29,679
one over n

1887
01:11:29,679 --> 01:11:31,440
and let's see what that means for the

1888
01:11:31,440 --> 01:11:33,360
entire experiment

1889
01:11:33,360 --> 01:11:35,920
so in each interaction it happens with

1890
01:11:35,920 --> 01:11:38,239
probability one over n such a successful

1891
01:11:38,239 --> 01:11:40,560
cheat and

1892
01:11:40,560 --> 01:11:43,120
as the the this parameter n grows over

1893
01:11:43,120 --> 01:11:45,760
time we can sum this up and see that the

1894
01:11:45,760 --> 01:11:49,120
expectation of the number of cheats so

1895
01:11:49,120 --> 01:11:50,960
this is also the expected number of

1896
01:11:50,960 --> 01:11:54,080
times we have to call our signing oracle

1897
01:11:54,080 --> 01:11:56,800
of the underlying scheme is logarithmic

1898
01:11:56,800 --> 01:11:57,920
and this is why

1899
01:11:57,920 --> 01:11:59,679
why it works for logarithmically secure

1900
01:11:59,679 --> 01:12:01,840
schemes but keep in mind that we want to

1901
01:12:01,840 --> 01:12:04,400
use it for a key only secure scheme now

1902
01:12:04,400 --> 01:12:06,640
so we are not allowed to query a

1903
01:12:06,640 --> 01:12:09,040
logarithmic number of times we have to

1904
01:12:09,040 --> 01:12:11,520
get this down to zero

1905
01:12:11,520 --> 01:12:13,679
okay so how do we do that our first

1906
01:12:13,679 --> 01:12:16,080
trick is to scale everything right just

1907
01:12:16,080 --> 01:12:19,440
take some constant scale everything um

1908
01:12:19,440 --> 01:12:21,440
and then we the the expectation also

1909
01:12:21,440 --> 01:12:24,000
scales so we get it down to less than

1910
01:12:24,000 --> 01:12:27,199
one this is already good but now for

1911
01:12:27,199 --> 01:12:29,760
security we don't need in expectation

1912
01:12:29,760 --> 01:12:31,520
anything we need it with overwhelming

1913
01:12:31,520 --> 01:12:34,560
probability but the concentration bound

1914
01:12:34,560 --> 01:12:37,040
will only give us a constant probability

1915
01:12:37,040 --> 01:12:39,280
so what can we do we can just repeat

1916
01:12:39,280 --> 01:12:42,239
everything in parallel with independent

1917
01:12:42,239 --> 01:12:45,199
keys and independent randomness

1918
01:12:45,199 --> 01:12:48,560
okay and that means that

1919
01:12:48,560 --> 01:12:50,560
with overwhelming probability there's

1920
01:12:50,560 --> 01:12:53,120
one of these instances one of the keys

1921
01:12:53,120 --> 01:12:54,880
for which in the entire experiment the

1922
01:12:54,880 --> 01:12:57,360
adversary never cheats successfully and

1923
01:12:57,360 --> 01:12:59,440
that means we never need to ask designer

1924
01:12:59,440 --> 01:13:01,679
oracle for this key so what we can do we

1925
01:13:01,679 --> 01:13:04,719
can just guess this this instance i star

1926
01:13:04,719 --> 01:13:07,120
embeds the key of the underlying bls

1927
01:13:07,120 --> 01:13:08,960
blind signature scheme there

1928
01:13:08,960 --> 01:13:11,120
and then um

1929
01:13:11,120 --> 01:13:13,040
we don't need a sign org

1930
01:13:13,040 --> 01:13:17,360
okay so that's good but now you may ask

1931
01:13:17,360 --> 01:13:19,520
this guy he's talking about concrete

1932
01:13:19,520 --> 01:13:21,920
efficiency and now he blows up

1933
01:13:21,920 --> 01:13:24,480
everything by a factor of k

1934
01:13:24,480 --> 01:13:26,560
so this is this seems to be not

1935
01:13:26,560 --> 01:13:27,679
efficient

1936
01:13:27,679 --> 01:13:30,080
and this is why we use

1937
01:13:30,080 --> 01:13:32,640
blind bls actually because for bls we

1938
01:13:32,640 --> 01:13:35,040
can use a lot of techniques from

1939
01:13:35,040 --> 01:13:36,960
aggregation we heard about aggregation

1940
01:13:36,960 --> 01:13:39,280
in the first talk we can aggregate for

1941
01:13:39,280 --> 01:13:41,440
example the responses the signatures and

1942
01:13:41,440 --> 01:13:43,760
so on and essentially this cut and

1943
01:13:43,760 --> 01:13:47,440
choose over multiple instances comes

1944
01:13:47,440 --> 01:13:49,120
almost for free now

1945
01:13:49,120 --> 01:13:50,480
okay

1946
01:13:50,480 --> 01:13:52,480
so that brings me to an overview of our

1947
01:13:52,480 --> 01:13:54,480
concrete schemes we have one concrete

1948
01:13:54,480 --> 01:13:56,480
scheme that i didn't show you which is

1949
01:13:56,480 --> 01:13:58,320
based on the rsa assumption so we

1950
01:13:58,320 --> 01:14:01,040
instantiate this framework from the rsa

1951
01:14:01,040 --> 01:14:03,199
assumption and to improve

1952
01:14:03,199 --> 01:14:06,320
uh the communication and signature sizes

1953
01:14:06,320 --> 01:14:10,400
we use some rsa specific optimizations

1954
01:14:10,400 --> 01:14:12,400
and the second one this is the one i

1955
01:14:12,400 --> 01:14:15,199
explained at a high level is the one

1956
01:14:15,199 --> 01:14:17,679
from the key only secure bls scheme

1957
01:14:17,679 --> 01:14:19,679
which is based on the cdh assumption for

1958
01:14:19,679 --> 01:14:21,840
that we use the parallel instance cut

1959
01:14:21,840 --> 01:14:23,920
and choose technique and these

1960
01:14:23,920 --> 01:14:26,560
aggregation optimizations to get a fully

1961
01:14:26,560 --> 01:14:29,280
secure blind signature scheme

1962
01:14:29,280 --> 01:14:31,840
okay so to wrap up our talk what have we

1963
01:14:31,840 --> 01:14:32,719
learned

1964
01:14:32,719 --> 01:14:35,679
we have uh generic results this is what

1965
01:14:35,679 --> 01:14:37,920
champ showed you where we take this cuts

1966
01:14:37,920 --> 01:14:40,719
lost rosenberg boosting transform and we

1967
01:14:40,719 --> 01:14:42,320
go from

1968
01:14:42,320 --> 01:14:44,239
linear communication in the number of

1969
01:14:44,239 --> 01:14:46,880
interactions to uh

1970
01:14:46,880 --> 01:14:49,679
to logarithmic communication okay

1971
01:14:49,679 --> 01:14:52,320
and then for concrete parameters we

1972
01:14:52,320 --> 01:14:53,760
constructed two

1973
01:14:53,760 --> 01:14:54,719
uh

1974
01:14:54,719 --> 01:14:57,360
two schemes that use these ideas one

1975
01:14:57,360 --> 01:15:00,080
from the rsa one from the cdh assumption

1976
01:15:00,080 --> 01:15:02,800
and we actually take the security loss

1977
01:15:02,800 --> 01:15:05,440
into account to estimate concrete

1978
01:15:05,440 --> 01:15:07,199
parameter sizes

1979
01:15:07,199 --> 01:15:08,159
um

1980
01:15:08,159 --> 01:15:11,120
which i think are rather practical

1981
01:15:11,120 --> 01:15:11,920
okay

1982
01:15:11,920 --> 01:15:12,880
so

1983
01:15:12,880 --> 01:15:16,480
that's it this was fun thank you

1984
01:15:20,800 --> 01:15:23,520
thanks any questions

1985
01:15:23,520 --> 01:15:26,080
please come to the microphone

1986
01:15:26,080 --> 01:15:28,159
hey thank you uh so one quick question

1987
01:15:28,159 --> 01:15:30,640
for your last uh for the evaluation can

1988
01:15:30,640 --> 01:15:31,600
you tell us something have you

1989
01:15:31,600 --> 01:15:33,679
benchmarked the designer performance for

1990
01:15:33,679 --> 01:15:34,800
that

1991
01:15:34,800 --> 01:15:37,840
uh no we actually didn't look at

1992
01:15:37,840 --> 01:15:40,000
computation we only looked at

1993
01:15:40,000 --> 01:15:42,640
communication and signature sizes

1994
01:15:42,640 --> 01:15:44,719
but yeah

1995
01:15:44,719 --> 01:15:46,719
i expect that the signer

1996
01:15:46,719 --> 01:15:51,199
computation is okayish the user

1997
01:15:51,199 --> 01:15:52,719
yeah i mean

1998
01:15:52,719 --> 01:15:54,239
yeah

1999
01:15:54,239 --> 01:15:56,080
so there's still this parameter n right

2000
01:15:56,080 --> 01:15:58,480
right and the computation is still

2001
01:15:58,480 --> 01:16:00,560
linear in this parameter

2002
01:16:00,560 --> 01:16:02,080
right right

2003
01:16:02,080 --> 01:16:04,800
so so does this depend on n and what did

2004
01:16:04,800 --> 01:16:06,159
you set into

2005
01:16:06,159 --> 01:16:07,360
uh

2006
01:16:07,360 --> 01:16:08,800
what what does it depend i mean what is

2007
01:16:08,800 --> 01:16:10,159
a reasonable end you have in mind i

2008
01:16:10,159 --> 01:16:13,440
guess where oh okay so so this this n is

2009
01:16:13,440 --> 01:16:14,560
the it's like

2010
01:16:14,560 --> 01:16:16,560
this the counter that designer increases

2011
01:16:16,560 --> 01:16:18,080
in every interval right but what is a

2012
01:16:18,080 --> 01:16:20,159
reasonable upper bound you'd expect for

2013
01:16:20,159 --> 01:16:22,400
do it which you like oh it's 20 so so

2014
01:16:22,400 --> 01:16:25,280
for these for these sizes we uh we take

2015
01:16:25,280 --> 01:16:28,560
the maximum to be 2 to the

2016
01:16:28,560 --> 01:16:33,320
30. okay yeah thanks

2017
01:16:34,239 --> 01:16:35,679
thanks to both of you for the very

2018
01:16:35,679 --> 01:16:36,880
interesting talk so i have a question

2019
01:16:36,880 --> 01:16:40,000
about this boosting transform so you run

2020
01:16:40,000 --> 01:16:42,560
many instances of this base uh

2021
01:16:42,560 --> 01:16:44,320
blind signature scheme but then you open

2022
01:16:44,320 --> 01:16:46,239
a bunch of them yeah that's a great side

2023
01:16:46,239 --> 01:16:48,320
um and i'm worried that when you open

2024
01:16:48,320 --> 01:16:50,320
one of them it reveals the the client's

2025
01:16:50,320 --> 01:16:51,760
message which is supposed to be kept

2026
01:16:51,760 --> 01:16:53,040
secret so i'm wondering how that is

2027
01:16:53,040 --> 01:16:54,000
resolved

2028
01:16:54,000 --> 01:16:56,159
it's a good question i mean uh

2029
01:16:56,159 --> 01:16:58,640
the the trick is that you instead of

2030
01:16:58,640 --> 01:17:00,239
using the message itself you use

2031
01:17:00,239 --> 01:17:02,320
commitments to the message

2032
01:17:02,320 --> 01:17:04,800
independent commitments in each of these

2033
01:17:04,800 --> 01:17:06,560
instances and then

2034
01:17:06,560 --> 01:17:08,320
this the commitment that you use here is

2035
01:17:08,320 --> 01:17:09,760
not revealed

2036
01:17:09,760 --> 01:17:11,600
and

2037
01:17:11,600 --> 01:17:14,159
and you here you you actually only

2038
01:17:14,159 --> 01:17:16,080
reveal the commitments that go into the

2039
01:17:16,080 --> 01:17:17,840
underlying schemes okay so i should

2040
01:17:17,840 --> 01:17:19,280
think of this as you're doing a blind

2041
01:17:19,280 --> 01:17:22,080
signature on a commitment of a message

2042
01:17:22,080 --> 01:17:23,840
yeah but you can include the commitment

2043
01:17:23,840 --> 01:17:25,520
randomness and the final signature then

2044
01:17:25,520 --> 01:17:26,640
so

2045
01:17:26,640 --> 01:17:30,000
yeah thank you good question

2046
01:17:30,000 --> 01:17:31,040
right

2047
01:17:31,040 --> 01:17:33,360
so i don't see any questions in the zoom

2048
01:17:33,360 --> 01:17:37,040
so let's thank the speakers again

2049
01:17:39,199 --> 01:17:41,199
but this concludes this session now we

2050
01:17:41,199 --> 01:17:43,040
have a short break and the sessions will

2051
01:17:43,040 --> 01:17:46,840
continue at 10 am

