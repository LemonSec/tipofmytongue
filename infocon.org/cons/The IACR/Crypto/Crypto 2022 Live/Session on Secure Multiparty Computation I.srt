1
00:00:00,240 --> 00:00:02,480
and jasper will be giving the talk

2
00:00:02,480 --> 00:00:04,560
um thank you for the introduction

3
00:00:04,560 --> 00:00:05,440
um

4
00:00:05,440 --> 00:00:07,040
i'm glad to be able to introduce uh

5
00:00:07,040 --> 00:00:08,800
today or one of our recent works on

6
00:00:08,800 --> 00:00:09,920
structure aware private sector

7
00:00:09,920 --> 00:00:11,040
intersection

8
00:00:11,040 --> 00:00:12,559
it's a joint work at oregon state

9
00:00:12,559 --> 00:00:14,960
university with my co-authors uh mike

10
00:00:14,960 --> 00:00:17,600
and gayatri

11
00:00:17,600 --> 00:00:18,960
i'm sure most of you are familiar with

12
00:00:18,960 --> 00:00:20,480
the standard privacy intersection

13
00:00:20,480 --> 00:00:22,240
problem you have two parties alice and

14
00:00:22,240 --> 00:00:24,240
bob and they both have a set of discrete

15
00:00:24,240 --> 00:00:25,119
points

16
00:00:25,119 --> 00:00:26,640
and they're interested in learning the

17
00:00:26,640 --> 00:00:28,240
set of items that are common to both the

18
00:00:28,240 --> 00:00:29,439
sets

19
00:00:29,439 --> 00:00:30,640
and you have an additional privacy

20
00:00:30,640 --> 00:00:32,880
constraint that no party should learn

21
00:00:32,880 --> 00:00:35,360
anything other than the expected output

22
00:00:35,360 --> 00:00:37,440
so for example bob should not learn any

23
00:00:37,440 --> 00:00:39,360
of alice's items outside the common

24
00:00:39,360 --> 00:00:40,800
elements

25
00:00:40,800 --> 00:00:42,480
so this problem has been well studied in

26
00:00:42,480 --> 00:00:44,480
the literature so i'll be interested in

27
00:00:44,480 --> 00:00:46,719
a variant of this problem

28
00:00:46,719 --> 00:00:48,879
so let's say alice and bob are visiting

29
00:00:48,879 --> 00:00:50,640
santa barbara to attend crypto for a

30
00:00:50,640 --> 00:00:52,559
week and they visit a number of places

31
00:00:52,559 --> 00:00:54,559
in and around santa barbara

32
00:00:54,559 --> 00:00:55,920
and at the end of this day they're

33
00:00:55,920 --> 00:00:57,520
interested in learning if they were they

34
00:00:57,520 --> 00:00:59,039
had been to any same

35
00:00:59,039 --> 00:01:02,320
locations in the city

36
00:01:03,120 --> 00:01:04,799
so it's unlikely to be the case that

37
00:01:04,799 --> 00:01:06,159
they would have stored the exact same

38
00:01:06,159 --> 00:01:08,240
gps locations for each place they

39
00:01:08,240 --> 00:01:09,360
visited

40
00:01:09,360 --> 00:01:11,200
so what we would need

41
00:01:11,200 --> 00:01:13,680
is some sort of a fuzzy psi protocol

42
00:01:13,680 --> 00:01:15,600
where we want to find points of alice

43
00:01:15,600 --> 00:01:17,520
and bob which are within some distance

44
00:01:17,520 --> 00:01:21,119
delta in some metric space

45
00:01:21,439 --> 00:01:22,479
so one

46
00:01:22,479 --> 00:01:24,640
trivial or another way to do this would

47
00:01:24,640 --> 00:01:27,759
be to re redefine alice's set as all the

48
00:01:27,759 --> 00:01:30,720
points within a delta radius ball

49
00:01:30,720 --> 00:01:33,280
for each of its original gps coordinates

50
00:01:33,280 --> 00:01:35,360
and then we run a plane psa protocol

51
00:01:35,360 --> 00:01:38,000
between alice's expanded set and bob's

52
00:01:38,000 --> 00:01:40,479
discrete points

53
00:01:40,479 --> 00:01:42,320
while that does solve the fuzzy psa

54
00:01:42,320 --> 00:01:44,640
problem it isn't

55
00:01:44,640 --> 00:01:46,799
the most efficient way to do this

56
00:01:46,799 --> 00:01:49,360
because for any traditional psi protocol

57
00:01:49,360 --> 00:01:51,040
the communication complexity is

58
00:01:51,040 --> 00:01:53,040
proportional to the

59
00:01:53,040 --> 00:01:54,720
input party sets

60
00:01:54,720 --> 00:01:56,479
so in this case it will be proportional

61
00:01:56,479 --> 00:01:58,560
to the expanded set of values which can

62
00:01:58,560 --> 00:02:00,960
be considerably larger than the set of

63
00:02:00,960 --> 00:02:04,000
original discrete points

64
00:02:04,000 --> 00:02:05,600
however

65
00:02:05,600 --> 00:02:07,920
you note that here you have a structure

66
00:02:07,920 --> 00:02:10,080
given over one of the party's input sets

67
00:02:10,080 --> 00:02:12,879
what alice holds is delta radius balls

68
00:02:12,879 --> 00:02:14,000
which are

69
00:02:14,000 --> 00:02:15,680
uh yeah which are delta radius balls in

70
00:02:15,680 --> 00:02:17,120
symmetric space

71
00:02:17,120 --> 00:02:18,959
so the question is could you sort of

72
00:02:18,959 --> 00:02:20,879
exploit that advantage to get a more

73
00:02:20,879 --> 00:02:23,840
efficient psi

74
00:02:24,720 --> 00:02:26,640
so in this work we introduce a new

75
00:02:26,640 --> 00:02:28,560
framework for private set intersection

76
00:02:28,560 --> 00:02:30,000
which gives a very practical way to

77
00:02:30,000 --> 00:02:31,760
solve the fuzzy psa problem that i

78
00:02:31,760 --> 00:02:33,840
mentioned earlier

79
00:02:33,840 --> 00:02:36,160
and it's in fact a lot more general you

80
00:02:36,160 --> 00:02:38,959
can actually employ it for doing psi

81
00:02:38,959 --> 00:02:41,280
where uh one of the parties has any

82
00:02:41,280 --> 00:02:43,519
arbitrary given structure and not just a

83
00:02:43,519 --> 00:02:46,239
union of bonds

84
00:02:46,319 --> 00:02:48,080
so in our framework we reduce the

85
00:02:48,080 --> 00:02:50,400
problem of privacy intersection to a new

86
00:02:50,400 --> 00:02:52,400
variant of function secret sharing which

87
00:02:52,400 --> 00:02:55,200
we term as weak emphasis

88
00:02:55,200 --> 00:02:56,800
and we end up reducing the communication

89
00:02:56,800 --> 00:02:58,560
complexity of the protocol to be

90
00:02:58,560 --> 00:03:00,640
proportional to the fss share size of

91
00:03:00,640 --> 00:03:02,560
the structured set

92
00:03:02,560 --> 00:03:04,480
so i'll get to this detail later but for

93
00:03:04,480 --> 00:03:05,599
now you can think of it as the

94
00:03:05,599 --> 00:03:08,000
description size of the structured set

95
00:03:08,000 --> 00:03:09,760
which in this case would be

96
00:03:09,760 --> 00:03:12,080
the center of all the balls

97
00:03:12,080 --> 00:03:14,000
sorry to jump in apparently the slides

98
00:03:14,000 --> 00:03:15,680
are not visible right now during zoom

99
00:03:15,680 --> 00:03:19,000
over zero

100
00:03:20,959 --> 00:03:24,760
yeah i can screen share

101
00:03:42,879 --> 00:03:44,400
i'm not sure how to go full screen in

102
00:03:44,400 --> 00:03:47,799
this um

103
00:03:48,400 --> 00:03:50,560
i believe it's the arrows that are

104
00:03:50,560 --> 00:03:51,760
pointing away from each other the

105
00:03:51,760 --> 00:03:54,798
diagonal arrows

106
00:03:54,879 --> 00:03:59,000
thank you thank you so much

107
00:04:13,280 --> 00:04:14,560
so as i was saying we reduced the

108
00:04:14,560 --> 00:04:15,599
problem of

109
00:04:15,599 --> 00:04:19,440
psi to a variant of fss

110
00:04:23,199 --> 00:04:25,600
and furthermore we introduce new fss

111
00:04:25,600 --> 00:04:27,600
techniques uh where we sort of exploit

112
00:04:27,600 --> 00:04:29,759
this new weak fss definition to give

113
00:04:29,759 --> 00:04:31,840
sort of very efficient uh

114
00:04:31,840 --> 00:04:33,840
secret sharing schemes for union of

115
00:04:33,840 --> 00:04:36,400
geometric balls

116
00:04:36,400 --> 00:04:38,560
so almost all the pc protocols that we

117
00:04:38,560 --> 00:04:40,400
are aware of is based on this opr

118
00:04:40,400 --> 00:04:42,240
paradigm that will introduce soon and

119
00:04:42,240 --> 00:04:43,680
our protocol is sort of based on this

120
00:04:43,680 --> 00:04:44,960
paradigm as well

121
00:04:44,960 --> 00:04:46,639
so in this case you have two parties who

122
00:04:46,639 --> 00:04:48,240
want to compute the private set

123
00:04:48,240 --> 00:04:49,600
intersection

124
00:04:49,600 --> 00:04:51,759
and you run an opr protocol

125
00:04:51,759 --> 00:04:53,680
which takes as input alice's discrete

126
00:04:53,680 --> 00:04:55,440
set

127
00:04:55,440 --> 00:04:57,360
and the oprf protocol outputs a random

128
00:04:57,360 --> 00:04:59,520
function to bob and it outputs the

129
00:04:59,520 --> 00:05:01,759
evaluation of the function on

130
00:05:01,759 --> 00:05:04,479
analysis input points back to values

131
00:05:04,479 --> 00:05:06,479
and this protocol leaks nothing but the

132
00:05:06,479 --> 00:05:08,800
expected output so alice does not learn

133
00:05:08,800 --> 00:05:11,280
the function f and bob does not learn

134
00:05:11,280 --> 00:05:14,800
any of the input points of alice

135
00:05:14,800 --> 00:05:16,880
and essentially now bob can compute this

136
00:05:16,880 --> 00:05:19,360
random function f on its inputs

137
00:05:19,360 --> 00:05:22,320
y1 y2 and so on and send it to alice and

138
00:05:22,320 --> 00:05:23,840
alice can use that to compute the

139
00:05:23,840 --> 00:05:26,400
intersection

140
00:05:26,720 --> 00:05:29,680
and for any typical oprf construction

141
00:05:29,680 --> 00:05:30,720
that you can

142
00:05:30,720 --> 00:05:33,039
use here the communication complexity is

143
00:05:33,039 --> 00:05:34,720
always proportional to

144
00:05:34,720 --> 00:05:37,840
the size of alice's set

145
00:05:37,840 --> 00:05:39,680
our goal would be to design a structure

146
00:05:39,680 --> 00:05:41,199
aware oprf

147
00:05:41,199 --> 00:05:42,880
with the communication there of this opf

148
00:05:42,880 --> 00:05:44,880
protocol is instead proportional to

149
00:05:44,880 --> 00:05:46,800
something like the description size of x

150
00:05:46,800 --> 00:05:48,160
instead of

151
00:05:48,160 --> 00:05:51,560
just its cardinality

152
00:05:52,320 --> 00:05:54,160
so this is how the main protocol would

153
00:05:54,160 --> 00:05:55,520
be structured

154
00:05:55,520 --> 00:05:58,240
so given a weak fss construction for the

155
00:05:58,240 --> 00:06:00,400
structured set of shared size sigma

156
00:06:00,400 --> 00:06:01,759
you can actually design a structure

157
00:06:01,759 --> 00:06:03,120
where opr

158
00:06:03,120 --> 00:06:04,960
which has communication proportional to

159
00:06:04,960 --> 00:06:06,639
lambda times sigma where lambda is the

160
00:06:06,639 --> 00:06:08,479
security parameter

161
00:06:08,479 --> 00:06:10,319
and that gives you a psi protocol as

162
00:06:10,319 --> 00:06:11,759
well with communication that's

163
00:06:11,759 --> 00:06:14,720
proportional to sigma

164
00:06:14,800 --> 00:06:16,639
we did look at the opr paradigm so for

165
00:06:16,639 --> 00:06:18,000
the rest of the talk or at least the

166
00:06:18,000 --> 00:06:20,080
next few slides i'll essentially focus

167
00:06:20,080 --> 00:06:21,919
on how you can exploit this weak

168
00:06:21,919 --> 00:06:24,160
emphasis which i'll define next to get a

169
00:06:24,160 --> 00:06:27,280
structure of your opr

170
00:06:27,600 --> 00:06:29,919
so uh so next we define boolean and

171
00:06:29,919 --> 00:06:31,440
function secret sharing it has two

172
00:06:31,440 --> 00:06:32,400
functions

173
00:06:32,400 --> 00:06:34,400
firstly a share function which takes as

174
00:06:34,400 --> 00:06:37,360
input a set and it outputs two keys with

175
00:06:37,360 --> 00:06:39,120
secret share the set a

176
00:06:39,120 --> 00:06:40,880
so you want each key to hide the input

177
00:06:40,880 --> 00:06:43,039
set a or they should look uniformly at

178
00:06:43,039 --> 00:06:45,759
random individually

179
00:06:45,759 --> 00:06:47,680
and the eval function is such that

180
00:06:47,680 --> 00:06:50,479
whenever your input x is in the set a

181
00:06:50,479 --> 00:06:52,880
you want the evaluation of both the red

182
00:06:52,880 --> 00:06:54,800
and the blue keys on the input x to be

183
00:06:54,800 --> 00:06:55,680
equal

184
00:06:55,680 --> 00:06:57,199
or in other words their exhaust should

185
00:06:57,199 --> 00:06:58,400
be zero

186
00:06:58,400 --> 00:07:00,560
and when x is not in a you want the

187
00:07:00,560 --> 00:07:02,720
evaluations to outputs different bits on

188
00:07:02,720 --> 00:07:04,880
both the keys

189
00:07:04,880 --> 00:07:06,639
um you could have defined you could have

190
00:07:06,639 --> 00:07:08,560
actually inverted zero and one as well

191
00:07:08,560 --> 00:07:10,479
and the entire protocol would still work

192
00:07:10,479 --> 00:07:12,479
but it just helps present the protocol

193
00:07:12,479 --> 00:07:13,599
in a more

194
00:07:13,599 --> 00:07:15,759
simpler way

195
00:07:15,759 --> 00:07:17,840
and for someone who's familiar with fss

196
00:07:17,840 --> 00:07:19,759
this may seem a little jarring because

197
00:07:19,759 --> 00:07:22,000
usually your secret share sets sorry so

198
00:07:22,000 --> 00:07:23,360
usually you secret share functions and

199
00:07:23,360 --> 00:07:24,720
not sets

200
00:07:24,720 --> 00:07:26,800
but you can redefine this in the

201
00:07:26,800 --> 00:07:28,479
original framework as well where the

202
00:07:28,479 --> 00:07:29,919
function is the set membership function

203
00:07:29,919 --> 00:07:32,800
of the city uh but for simplicity we'll

204
00:07:32,800 --> 00:07:35,520
stick to this syntax

205
00:07:35,520 --> 00:07:37,039
so now let's see how

206
00:07:37,039 --> 00:07:39,039
we can use that a function secret

207
00:07:39,039 --> 00:07:40,960
sharing scheme for a structured set to

208
00:07:40,960 --> 00:07:43,120
give an opr

209
00:07:43,120 --> 00:07:45,440
so firstly alice takes its structured

210
00:07:45,440 --> 00:07:48,000
set and it runs the share function

211
00:07:48,000 --> 00:07:49,440
multiple times

212
00:07:49,440 --> 00:07:52,000
uh specifically 128 times in a protocol

213
00:07:52,000 --> 00:07:54,160
and it generates pair of

214
00:07:54,160 --> 00:07:56,240
fss keys

215
00:07:56,240 --> 00:07:57,440
and then we'll run the oblivious

216
00:07:57,440 --> 00:07:59,280
transfer protocol

217
00:07:59,280 --> 00:08:00,800
using which essentially bob can

218
00:08:00,800 --> 00:08:03,199
obliviously select one of these

219
00:08:03,199 --> 00:08:04,319
uh

220
00:08:04,319 --> 00:08:06,639
one of the keys from each pair at random

221
00:08:06,639 --> 00:08:08,639
so s has the selection bit

222
00:08:08,639 --> 00:08:10,960
selection random vector s using which it

223
00:08:10,960 --> 00:08:13,199
selects one of the shares

224
00:08:13,199 --> 00:08:15,919
from each pair

225
00:08:16,560 --> 00:08:19,440
and we defined the opr f function as

226
00:08:19,440 --> 00:08:22,400
follows so bob can essentially

227
00:08:22,400 --> 00:08:24,319
given an input x bob can essentially run

228
00:08:24,319 --> 00:08:27,039
the eval function on the input x given

229
00:08:27,039 --> 00:08:28,800
all of its keys that it received from

230
00:08:28,800 --> 00:08:30,319
the ot protocol

231
00:08:30,319 --> 00:08:32,559
and concatenate those and on the left

232
00:08:32,559 --> 00:08:34,479
hand side you see the shorthand notation

233
00:08:34,479 --> 00:08:35,919
for the concatenation of all the

234
00:08:35,919 --> 00:08:38,159
evaluations

235
00:08:38,159 --> 00:08:39,839
and then you can apply a random oracle

236
00:08:39,839 --> 00:08:41,919
on top of that and that will define as f

237
00:08:41,919 --> 00:08:43,200
of x

238
00:08:43,200 --> 00:08:46,240
so bob can compute f of x on any input x

239
00:08:46,240 --> 00:08:48,160
now let's sort of try to analyze for

240
00:08:48,160 --> 00:08:52,959
which inputs x can alice identify f of x

241
00:08:53,760 --> 00:08:55,920
so when x is in a we know that the

242
00:08:55,920 --> 00:08:57,600
evaluation of the red and blue keys on

243
00:08:57,600 --> 00:09:00,640
the input x are the same

244
00:09:00,640 --> 00:09:02,240
hence in this case

245
00:09:02,240 --> 00:09:04,000
actually you could have computed f of x

246
00:09:04,000 --> 00:09:05,760
by actually running evaluation on just

247
00:09:05,760 --> 00:09:07,200
the blue keys

248
00:09:07,200 --> 00:09:09,120
all of which are known to alice and

249
00:09:09,120 --> 00:09:10,880
alice can essentially compute f of x

250
00:09:10,880 --> 00:09:13,360
when x is in the set a

251
00:09:13,360 --> 00:09:15,040
this is where the clean

252
00:09:15,040 --> 00:09:17,760
notation sort of helps

253
00:09:17,760 --> 00:09:19,760
and notice when x is not in a we know

254
00:09:19,760 --> 00:09:21,680
that the evaluation of the red and blue

255
00:09:21,680 --> 00:09:24,640
keys on the input x would be different

256
00:09:24,640 --> 00:09:26,080
hence in this case

257
00:09:26,080 --> 00:09:27,839
if you try to work out what f of x would

258
00:09:27,839 --> 00:09:30,080
be it turns out to be the evaluation of

259
00:09:30,080 --> 00:09:33,040
all the blue keys on the input x exert

260
00:09:33,040 --> 00:09:35,440
with this random bit vector s that's

261
00:09:35,440 --> 00:09:37,440
only known to bob

262
00:09:37,440 --> 00:09:39,040
and that sort of gives you sufficient

263
00:09:39,040 --> 00:09:41,360
entropy in the input of this random

264
00:09:41,360 --> 00:09:42,640
oracle

265
00:09:42,640 --> 00:09:44,560
such that alice will not be able to

266
00:09:44,560 --> 00:09:46,959
identify this opr f output or in other

267
00:09:46,959 --> 00:09:49,279
words this would look completely random

268
00:09:49,279 --> 00:09:51,440
so that gives the needed security

269
00:09:51,440 --> 00:09:54,080
for the oprf

270
00:09:54,080 --> 00:09:56,800
now if you'll notice um

271
00:09:56,800 --> 00:09:58,080
actually looking at this framework we

272
00:09:58,080 --> 00:09:59,200
sort of noticed that we could actually

273
00:09:59,200 --> 00:10:01,200
relax the fss definition in a couple of

274
00:10:01,200 --> 00:10:04,560
ways and the protocol would still work

275
00:10:04,560 --> 00:10:06,959
so that's what we sort of define as weak

276
00:10:06,959 --> 00:10:08,880
boolean function secret sharing which is

277
00:10:08,880 --> 00:10:11,440
parameterized by p and k

278
00:10:11,440 --> 00:10:13,040
and i'll i'll refer to the original

279
00:10:13,040 --> 00:10:15,200
definition as strong emphasis to just

280
00:10:15,200 --> 00:10:17,360
sort of uh differentiate between both of

281
00:10:17,360 --> 00:10:18,399
them

282
00:10:18,399 --> 00:10:20,240
so the first relaxation is

283
00:10:20,240 --> 00:10:22,320
we allow the evaluation to output

284
00:10:22,320 --> 00:10:24,720
multiple bits instead of just one

285
00:10:24,720 --> 00:10:26,959
so when x is in a again you want the

286
00:10:26,959 --> 00:10:28,800
evaluation of the red and blue keys on

287
00:10:28,800 --> 00:10:30,959
the input x to be equal

288
00:10:30,959 --> 00:10:32,560
and in the case when x is not equal to

289
00:10:32,560 --> 00:10:34,959
it is not in a you want the evaluation

290
00:10:34,959 --> 00:10:37,680
of red and blue keys to be just unequal

291
00:10:37,680 --> 00:10:41,519
or their xor should not be zero to the k

292
00:10:41,760 --> 00:10:44,079
and secondly uh we allow for false

293
00:10:44,079 --> 00:10:45,440
positives

294
00:10:45,440 --> 00:10:47,200
what i mean it what i mean by that in

295
00:10:47,200 --> 00:10:49,440
this context is

296
00:10:49,440 --> 00:10:51,360
when x is not in a

297
00:10:51,360 --> 00:10:54,720
we allow for uh we allow for some

298
00:10:54,720 --> 00:10:56,640
chance for the evaluations to even be

299
00:10:56,640 --> 00:10:59,120
equal so all we want is the evaluation

300
00:10:59,120 --> 00:11:00,800
of red and blue keys

301
00:11:00,800 --> 00:11:02,720
on input x to be different with at least

302
00:11:02,720 --> 00:11:05,120
some probability p it need not be always

303
00:11:05,120 --> 00:11:07,360
true

304
00:11:08,480 --> 00:11:10,240
so the first change is actually it's

305
00:11:10,240 --> 00:11:11,519
easy to see how that would affect the

306
00:11:11,519 --> 00:11:13,519
opr protocol and the protocol would

307
00:11:13,519 --> 00:11:14,640
still work

308
00:11:14,640 --> 00:11:16,560
i'll essentially in my talk focus on

309
00:11:16,560 --> 00:11:17,680
showing how

310
00:11:17,680 --> 00:11:19,839
the false positive probability would

311
00:11:19,839 --> 00:11:23,279
affect our oprf protocol

312
00:11:24,560 --> 00:11:25,920
so yeah we'll sort of just look at the

313
00:11:25,920 --> 00:11:28,399
security of the oprf protocol and just

314
00:11:28,399 --> 00:11:30,079
see how alice

315
00:11:30,079 --> 00:11:32,000
would not be able to identify an element

316
00:11:32,000 --> 00:11:34,079
would not be able to come compute f of x

317
00:11:34,079 --> 00:11:35,920
when x is not in a

318
00:11:35,920 --> 00:11:38,480
so in the strong fss variant

319
00:11:38,480 --> 00:11:40,399
this is how it

320
00:11:40,399 --> 00:11:42,880
f x looks like for x naught in a and due

321
00:11:42,880 --> 00:11:45,760
to the random bit vector s uh f of x

322
00:11:45,760 --> 00:11:48,160
looks completely random

323
00:11:48,160 --> 00:11:50,240
in the weak fss case let's take the

324
00:11:50,240 --> 00:11:53,360
example where p is equal to half

325
00:11:53,360 --> 00:11:56,000
so in this case instead of 128 pair of

326
00:11:56,000 --> 00:11:58,320
fss keys i'll essentially run the ot

327
00:11:58,320 --> 00:12:01,040
protocol 440 times

328
00:12:01,040 --> 00:12:03,120
and the reason is uh running the ot

329
00:12:03,120 --> 00:12:05,680
protocol 440 times ensures me that with

330
00:12:05,680 --> 00:12:07,360
a very high probability

331
00:12:07,360 --> 00:12:09,760
at least 128 pair of those keys would

332
00:12:09,760 --> 00:12:12,720
satisfy this strong fss definition

333
00:12:12,720 --> 00:12:14,800
which in this context means that the red

334
00:12:14,800 --> 00:12:16,720
and the blue keys would evaluate to

335
00:12:16,720 --> 00:12:19,360
different bits

336
00:12:20,560 --> 00:12:23,040
so if you sort of try to rewrite f of x

337
00:12:23,040 --> 00:12:25,680
again in this sort of

338
00:12:25,680 --> 00:12:27,920
in this framework you essentially end up

339
00:12:27,920 --> 00:12:30,639
with uh evaluation of all the blue keys

340
00:12:30,639 --> 00:12:33,200
excerpt by the 440 bit

341
00:12:33,200 --> 00:12:35,839
string which has at least 128 bits of

342
00:12:35,839 --> 00:12:37,200
entropy

343
00:12:37,200 --> 00:12:38,639
and that is sufficient to give you the

344
00:12:38,639 --> 00:12:41,360
oprf security

345
00:12:41,360 --> 00:12:43,760
so there's a trade-off here we

346
00:12:43,760 --> 00:12:45,519
we allow for a false positive and we

347
00:12:45,519 --> 00:12:47,920
ended up increasing the number of ots

348
00:12:47,920 --> 00:12:49,279
so there's this sort of trade-off that

349
00:12:49,279 --> 00:12:50,839
is introduced in a

350
00:12:50,839 --> 00:12:53,440
protocol but that's uh the gist of the

351
00:12:53,440 --> 00:12:56,480
construction essentially

352
00:12:56,480 --> 00:12:58,079
um so once we sort of came up with this

353
00:12:58,079 --> 00:13:00,079
framework we noticed that although we

354
00:13:00,079 --> 00:13:02,000
are interested in just structured sets

355
00:13:02,000 --> 00:13:04,959
we noticed that this sort of

356
00:13:04,959 --> 00:13:06,959
fss and weak efficiency techniques are

357
00:13:06,959 --> 00:13:08,800
sort of present in uh previous psi

358
00:13:08,800 --> 00:13:11,200
constructions as well uh also almost

359
00:13:11,200 --> 00:13:12,720
implicitly

360
00:13:12,720 --> 00:13:15,680
so just to give you one example

361
00:13:15,680 --> 00:13:17,519
uh so okay before that so this is sort

362
00:13:17,519 --> 00:13:19,680
of what uh the framework sort of looks

363
00:13:19,680 --> 00:13:21,600
like you plug in a stronger weak

364
00:13:21,600 --> 00:13:24,000
emphasis into our oprah framework and

365
00:13:24,000 --> 00:13:26,399
you end up with a psa protocol

366
00:13:26,399 --> 00:13:27,920
so i'll show you an example of a weak

367
00:13:27,920 --> 00:13:30,560
emphasis uh which sort of leads gives

368
00:13:30,560 --> 00:13:34,560
you uh one of the previous psa protocols

369
00:13:34,560 --> 00:13:36,880
so this is the weak fss for an arbitrary

370
00:13:36,880 --> 00:13:39,839
set based on blue filters

371
00:13:39,839 --> 00:13:41,519
so you have a set a

372
00:13:41,519 --> 00:13:42,800
and you want to sort of construct weak

373
00:13:42,800 --> 00:13:44,240
fss for that

374
00:13:44,240 --> 00:13:45,440
so you have a

375
00:13:45,440 --> 00:13:47,120
unit vector which will be your bloom

376
00:13:47,120 --> 00:13:49,600
filter and you will essentially have 0

377
00:13:49,600 --> 00:13:51,519
in here which sort of represents set

378
00:13:51,519 --> 00:13:52,880
membership

379
00:13:52,880 --> 00:13:54,720
so to insert an element 4 into this

380
00:13:54,720 --> 00:13:55,920
bloom filter

381
00:13:55,920 --> 00:13:57,360
you essentially hash

382
00:13:57,360 --> 00:13:59,279
the element 4 and make the corresponding

383
00:13:59,279 --> 00:14:00,800
bit 0.

384
00:14:00,800 --> 00:14:02,959
it's a single hash bloom filter

385
00:14:02,959 --> 00:14:05,680
which is really bad but we'll uh do with

386
00:14:05,680 --> 00:14:06,800
that for now

387
00:14:06,800 --> 00:14:08,639
so similarly if you look at bar you can

388
00:14:08,639 --> 00:14:10,320
hash that and make the corresponding bit

389
00:14:10,320 --> 00:14:12,079
zero as well

390
00:14:12,079 --> 00:14:13,680
so you prepare this bloom filter for

391
00:14:13,680 --> 00:14:14,959
your set a

392
00:14:14,959 --> 00:14:16,959
and then you prepare your fss keys as

393
00:14:16,959 --> 00:14:19,120
just exhaust sharings random extra

394
00:14:19,120 --> 00:14:22,800
sharings of this bloom filter

395
00:14:23,120 --> 00:14:25,040
so in this case notice if you want to

396
00:14:25,040 --> 00:14:27,680
evaluate these fss keys on some input

397
00:14:27,680 --> 00:14:30,959
foo let's say which is from the set

398
00:14:30,959 --> 00:14:33,600
you essentially query the fss keys at

399
00:14:33,600 --> 00:14:36,000
hash of 4 and that will be your

400
00:14:36,000 --> 00:14:39,199
evaluation output of pfss

401
00:14:39,199 --> 00:14:40,639
and notice that

402
00:14:40,639 --> 00:14:43,199
in this case since 4 is from the set

403
00:14:43,199 --> 00:14:45,360
the xor of the corresponding fss entries

404
00:14:45,360 --> 00:14:47,199
would give you zero which is what we

405
00:14:47,199 --> 00:14:49,279
need

406
00:14:49,279 --> 00:14:50,959
but it's a really bad bloom filter we

407
00:14:50,959 --> 00:14:53,040
are just using a single hash function

408
00:14:53,040 --> 00:14:54,480
so it could happen that sometimes you

409
00:14:54,480 --> 00:14:56,639
query an element outside the set

410
00:14:56,639 --> 00:14:58,720
and it could still give you a zero

411
00:14:58,720 --> 00:15:00,880
uh as the output of these are of the

412
00:15:00,880 --> 00:15:02,800
evaluations

413
00:15:02,800 --> 00:15:04,880
but that is okay because uh in the bloom

414
00:15:04,880 --> 00:15:06,320
filter you can actually bound to false

415
00:15:06,320 --> 00:15:08,240
positive probability and that actually

416
00:15:08,240 --> 00:15:11,120
corresponds exactly to the weak fss

417
00:15:11,120 --> 00:15:13,440
false positive probability

418
00:15:13,440 --> 00:15:15,519
and what's sort of interesting is

419
00:15:15,519 --> 00:15:17,600
if you plug in this weak emphasis into

420
00:15:17,600 --> 00:15:20,000
our opr framework you end up getting

421
00:15:20,000 --> 00:15:23,839
chase meow crypto 2020 psi protocol

422
00:15:23,839 --> 00:15:25,440
which was sort of interesting for us

423
00:15:25,440 --> 00:15:27,600
because in their original work they

424
00:15:27,600 --> 00:15:29,120
don't sort of explicitly mention bloom

425
00:15:29,120 --> 00:15:31,199
filters and there is the sort of hidden

426
00:15:31,199 --> 00:15:32,079
uh

427
00:15:32,079 --> 00:15:34,079
fss in it

428
00:15:34,079 --> 00:15:35,680
and it's not just their work there are a

429
00:15:35,680 --> 00:15:37,759
number of other psa protocols which has

430
00:15:37,759 --> 00:15:40,800
this implicit weak and strong emphasis

431
00:15:40,800 --> 00:15:43,680
so you can look at iknp from the lens

432
00:15:43,680 --> 00:15:46,000
lens of a strong emphasis as well so if

433
00:15:46,000 --> 00:15:48,240
you do an iknp based psa protocol

434
00:15:48,240 --> 00:15:49,680
there's actually a strong emphasis

435
00:15:49,680 --> 00:15:51,519
hidden within it

436
00:15:51,519 --> 00:15:53,839
another protocol example is parso t from

437
00:15:53,839 --> 00:15:55,360
crypto 2019

438
00:15:55,360 --> 00:15:57,440
so in that as well there is an fs weak

439
00:15:57,440 --> 00:15:59,600
emphasis based on polynomials which when

440
00:15:59,600 --> 00:16:01,279
plugged into our protocol essentially

441
00:16:01,279 --> 00:16:04,000
gives you the sparse so t protocol

442
00:16:04,000 --> 00:16:04,880
uh

443
00:16:04,880 --> 00:16:06,480
so yeah so we sort of noticed that for a

444
00:16:06,480 --> 00:16:08,720
lot of unstructured set based psa

445
00:16:08,720 --> 00:16:11,120
protocols as well our sort of framework

446
00:16:11,120 --> 00:16:14,000
sort of generalizes all of them

447
00:16:14,000 --> 00:16:15,839
but what we're interested in today is

448
00:16:15,839 --> 00:16:17,680
looking at structured sets

449
00:16:17,680 --> 00:16:20,560
can we design efficient weak episodes

450
00:16:20,560 --> 00:16:23,040
for structured sets

451
00:16:23,040 --> 00:16:24,800
and specifically we are interested in

452
00:16:24,800 --> 00:16:26,880
the union of balls

453
00:16:26,880 --> 00:16:28,160
where a ball could look something like

454
00:16:28,160 --> 00:16:30,480
this in an area to know but if you use a

455
00:16:30,480 --> 00:16:32,959
different metric space the it could look

456
00:16:32,959 --> 00:16:35,440
really different so this is an l1 ball

457
00:16:35,440 --> 00:16:37,279
in two dimensions

458
00:16:37,279 --> 00:16:40,160
and this is an l infinity ball

459
00:16:40,160 --> 00:16:41,680
and these are the easier geometric

460
00:16:41,680 --> 00:16:43,839
objects we can deal with using function

461
00:16:43,839 --> 00:16:45,759
secret sharing so we'll stick to this

462
00:16:45,759 --> 00:16:47,600
for the rest of the talk

463
00:16:47,600 --> 00:16:49,279
and l infinity is nothing but just an

464
00:16:49,279 --> 00:16:51,759
intersection of d intervals so those are

465
00:16:51,759 --> 00:16:53,759
sort of easier objects to deal with

466
00:16:53,759 --> 00:16:55,519
but all the ideas that i discuss will

467
00:16:55,519 --> 00:16:57,680
extend to l1 norm as well

468
00:16:57,680 --> 00:16:59,680
which is an intersection of each l one

469
00:16:59,680 --> 00:17:01,120
ball is an intersection of two to the d

470
00:17:01,120 --> 00:17:02,639
minus one intervals

471
00:17:02,639 --> 00:17:04,799
which is exponentially worse but the

472
00:17:04,799 --> 00:17:06,559
ideas would still extend to l1 norm as

473
00:17:06,559 --> 00:17:08,799
well

474
00:17:08,959 --> 00:17:10,559
so before i introduce our weak fss

475
00:17:10,559 --> 00:17:13,039
constructions let's see what does uh

476
00:17:13,039 --> 00:17:14,559
what can strong fss give us from

477
00:17:14,559 --> 00:17:16,959
previous work

478
00:17:16,959 --> 00:17:19,039
so if you look at any l infinity ball

479
00:17:19,039 --> 00:17:20,799
it's an intersection

480
00:17:20,799 --> 00:17:22,400
of intervals

481
00:17:22,400 --> 00:17:24,160
and for intersection of intervals

482
00:17:24,160 --> 00:17:26,480
there's a decision tree based ephesus

483
00:17:26,480 --> 00:17:28,160
which can be used

484
00:17:28,160 --> 00:17:30,320
in the work by boyle kilbou and disha

485
00:17:30,320 --> 00:17:31,039
and

486
00:17:31,039 --> 00:17:33,120
and they get fss key size which is

487
00:17:33,120 --> 00:17:35,280
proportional to b to the d

488
00:17:35,280 --> 00:17:38,240
where b is the number of bits uh in any

489
00:17:38,240 --> 00:17:40,960
coordinate of an input in the domain

490
00:17:40,960 --> 00:17:42,480
but essentially the key point here is

491
00:17:42,480 --> 00:17:43,760
it's exponential in the number of

492
00:17:43,760 --> 00:17:45,360
dimensions

493
00:17:45,360 --> 00:17:48,480
so it's not as efficient

494
00:17:48,480 --> 00:17:50,400
and that's how you sort of handle it get

495
00:17:50,400 --> 00:17:52,160
emphasis for a single ball and for a

496
00:17:52,160 --> 00:17:53,840
union of balls

497
00:17:53,840 --> 00:17:55,919
the idea is given a point you can run

498
00:17:55,919 --> 00:17:58,320
the fss eval on each of the balls and

499
00:17:58,320 --> 00:18:00,880
then add them up and this some technique

500
00:18:00,880 --> 00:18:02,400
works in the case when the balls are

501
00:18:02,400 --> 00:18:03,840
disjoint

502
00:18:03,840 --> 00:18:05,360
and that essentially ends up increasing

503
00:18:05,360 --> 00:18:07,280
your fss share size by the number of

504
00:18:07,280 --> 00:18:09,520
balls and the eval cost by the number of

505
00:18:09,520 --> 00:18:10,720
balls as well

506
00:18:10,720 --> 00:18:12,320
since you need to run

507
00:18:12,320 --> 00:18:14,880
the eval for each point for each ball

508
00:18:14,880 --> 00:18:16,480
given a point

509
00:18:16,480 --> 00:18:18,400
so i'll show an improvement

510
00:18:18,400 --> 00:18:21,039
over both of these cases in the weak fss

511
00:18:21,039 --> 00:18:23,120
scenario where we sort of use the

512
00:18:23,120 --> 00:18:25,120
relaxation of the weak emphasis to

513
00:18:25,120 --> 00:18:29,000
design a more efficient episode

514
00:18:29,520 --> 00:18:30,799
so we introduced a number of weak

515
00:18:30,799 --> 00:18:32,880
efficiency techniques which built on top

516
00:18:32,880 --> 00:18:34,799
of one another and also known strong

517
00:18:34,799 --> 00:18:36,880
emphasis techniques so this is just a

518
00:18:36,880 --> 00:18:38,720
flowchart of all the ideas

519
00:18:38,720 --> 00:18:39,840
in our work

520
00:18:39,840 --> 00:18:42,559
but i'll focus on two ideas uh in this

521
00:18:42,559 --> 00:18:44,480
talk today

522
00:18:44,480 --> 00:18:45,360
and

523
00:18:45,360 --> 00:18:46,799
we believe that we have barely sort of

524
00:18:46,799 --> 00:18:48,480
scratched the surface in terms of

525
00:18:48,480 --> 00:18:51,280
exploring uh in sort of exploiting these

526
00:18:51,280 --> 00:18:53,760
weak emphasis relaxations to designing

527
00:18:53,760 --> 00:18:56,960
efficient uh secret sharing

528
00:18:56,960 --> 00:18:58,640
but the general theme that we've noticed

529
00:18:58,640 --> 00:19:00,160
is that this sort of weak relaxation

530
00:19:00,160 --> 00:19:02,720
will give us uh more efficient function

531
00:19:02,720 --> 00:19:06,000
secret sharing which i'll show you next

532
00:19:06,000 --> 00:19:07,600
so one of the techniques uh which is

533
00:19:07,600 --> 00:19:09,520
really simple but it'll turn out to be

534
00:19:09,520 --> 00:19:12,480
really powerful is the kanka technique

535
00:19:12,480 --> 00:19:14,240
where given a

536
00:19:14,240 --> 00:19:15,840
function secret sharing scheme for two

537
00:19:15,840 --> 00:19:18,160
sets ent our aim is to get a function

538
00:19:18,160 --> 00:19:19,600
secret sharing scheme for the

539
00:19:19,600 --> 00:19:22,159
intersection

540
00:19:22,240 --> 00:19:23,679
so let's say you can secret share two

541
00:19:23,679 --> 00:19:25,039
sets a and b and you have the

542
00:19:25,039 --> 00:19:26,880
corresponding pair of keys

543
00:19:26,880 --> 00:19:28,559
the question is how do you get function

544
00:19:28,559 --> 00:19:30,160
secret sharing scheme for the

545
00:19:30,160 --> 00:19:31,360
intersection

546
00:19:31,360 --> 00:19:33,440
and here we exploit the relaxation that

547
00:19:33,440 --> 00:19:35,360
you can have multiple bits as the output

548
00:19:35,360 --> 00:19:37,039
of the eval

549
00:19:37,039 --> 00:19:39,280
so the very straightforward idea of just

550
00:19:39,280 --> 00:19:41,679
concatenating the evas and treating that

551
00:19:41,679 --> 00:19:45,120
as the evaluation of the intersection

552
00:19:45,120 --> 00:19:47,600
so now notice an element x is in the

553
00:19:47,600 --> 00:19:49,600
intersection of a and b

554
00:19:49,600 --> 00:19:50,880
only if

555
00:19:50,880 --> 00:19:52,559
the evaluations

556
00:19:52,559 --> 00:19:55,120
exert to the bits the bit string zero

557
00:19:55,120 --> 00:19:57,439
zero

558
00:19:58,720 --> 00:20:00,880
and in this case the share size of a

559
00:20:00,880 --> 00:20:02,159
intersection b

560
00:20:02,159 --> 00:20:04,000
is just you having the two keys for the

561
00:20:04,000 --> 00:20:07,120
sets a and b so that's really efficient

562
00:20:07,120 --> 00:20:09,039
and specifically as i mentioned an l

563
00:20:09,039 --> 00:20:10,640
infinity ball is nothing but an

564
00:20:10,640 --> 00:20:12,720
intersection of d intervals so you can

565
00:20:12,720 --> 00:20:14,480
just concatenate the fss for the d

566
00:20:14,480 --> 00:20:15,520
intervals

567
00:20:15,520 --> 00:20:16,960
that actually give you

568
00:20:16,960 --> 00:20:19,440
an fss scheme with share size that's

569
00:20:19,440 --> 00:20:21,919
proportional to the dimension

570
00:20:21,919 --> 00:20:24,159
instead of having it being proportional

571
00:20:24,159 --> 00:20:26,000
to x something b to the t which is

572
00:20:26,000 --> 00:20:28,960
exponential nd so that's a great saving

573
00:20:28,960 --> 00:20:30,559
so very simple technique but it does

574
00:20:30,559 --> 00:20:34,000
help reduce the share size

575
00:20:34,000 --> 00:20:35,520
another technique we introduce is

576
00:20:35,520 --> 00:20:37,840
spatial hashing

577
00:20:37,840 --> 00:20:39,520
where we sort of try to reduce the shape

578
00:20:39,520 --> 00:20:42,080
size and the eval cost when sort of

579
00:20:42,080 --> 00:20:44,400
trying to handle a union of balls

580
00:20:44,400 --> 00:20:45,919
for this talk i'll just sort of focus on

581
00:20:45,919 --> 00:20:47,840
the eval time i'll try to show how you

582
00:20:47,840 --> 00:20:49,280
reduce the e by time from a

583
00:20:49,280 --> 00:20:52,480
multiplicative factor of n

584
00:20:53,440 --> 00:20:55,039
so the idea is

585
00:20:55,039 --> 00:20:57,120
you overlay a grid structure on top of

586
00:20:57,120 --> 00:20:59,600
these l infinity balls where each grid

587
00:20:59,600 --> 00:21:01,760
cell is an l infinity ball as well of

588
00:21:01,760 --> 00:21:04,480
the same radius

589
00:21:04,480 --> 00:21:06,640
and then you essentially mark the cells

590
00:21:06,640 --> 00:21:09,280
uh which intersect with an input ball we

591
00:21:09,280 --> 00:21:11,039
call those active cells

592
00:21:11,039 --> 00:21:13,039
so so that's the shaded region in this

593
00:21:13,039 --> 00:21:14,480
figure

594
00:21:14,480 --> 00:21:16,640
so our goal would be to make sure that

595
00:21:16,640 --> 00:21:18,960
the fss gives the correct output within

596
00:21:18,960 --> 00:21:21,039
the shaded region that's the region sort

597
00:21:21,039 --> 00:21:23,360
of we care about

598
00:21:23,360 --> 00:21:26,240
so the idea is for each grid cell

599
00:21:26,240 --> 00:21:27,919
for each active grid cell we will

600
00:21:27,919 --> 00:21:30,480
prepare grid differences keys that sort

601
00:21:30,480 --> 00:21:33,280
of give correct output within the grid

602
00:21:33,280 --> 00:21:34,880
and if i go step back

603
00:21:34,880 --> 00:21:37,840
notice how within each grid cell at max

604
00:21:37,840 --> 00:21:39,120
a constant number of balls would

605
00:21:39,120 --> 00:21:41,200
intersect in the two dimension case it

606
00:21:41,200 --> 00:21:43,039
would be four

607
00:21:43,039 --> 00:21:44,799
so you can prepare each grid efficiency

608
00:21:44,799 --> 00:21:47,120
by just preparing four fss keys

609
00:21:47,120 --> 00:21:48,159
uh

610
00:21:48,159 --> 00:21:50,960
and that would be your grid efficiency

611
00:21:50,960 --> 00:21:53,840
and your uh fss keys for the union of

612
00:21:53,840 --> 00:21:56,159
pulse would be two polynomials

613
00:21:56,159 --> 00:21:57,280
uh

614
00:21:57,280 --> 00:21:59,840
which uh given a great fsid it should

615
00:21:59,840 --> 00:22:01,760
output the corresponding uh

616
00:22:01,760 --> 00:22:03,919
fss for the grid

617
00:22:03,919 --> 00:22:05,200
so this is what if you sort of

618
00:22:05,200 --> 00:22:08,640
interpolate the two polynomials on

619
00:22:08,640 --> 00:22:12,480
now notice when uh an input x is within

620
00:22:12,480 --> 00:22:14,799
a grid cell within an active grid cell

621
00:22:14,799 --> 00:22:16,880
these polynomials would output the

622
00:22:16,880 --> 00:22:18,480
correct gradient fss and that would give

623
00:22:18,480 --> 00:22:19,919
the correct output

624
00:22:19,919 --> 00:22:21,440
but what about the case if you try to

625
00:22:21,440 --> 00:22:23,919
evaluate this fss on a point in the

626
00:22:23,919 --> 00:22:26,720
non-shaded region so in that case your

627
00:22:26,720 --> 00:22:29,440
polynomials would end up outputting

628
00:22:29,440 --> 00:22:31,919
random pair of strings and here we

629
00:22:31,919 --> 00:22:33,840
exploit the fact that we allow for false

630
00:22:33,840 --> 00:22:35,120
positives

631
00:22:35,120 --> 00:22:37,360
so in that case our fss would output

632
00:22:37,360 --> 00:22:39,600
random bits but we are okay with that

633
00:22:39,600 --> 00:22:41,679
because we allow for false positives so

634
00:22:41,679 --> 00:22:43,679
we sort of really care only about the

635
00:22:43,679 --> 00:22:46,000
shaded region

636
00:22:46,000 --> 00:22:48,640
and notice how we reduce the eval cost

637
00:22:48,640 --> 00:22:49,840
uh

638
00:22:49,840 --> 00:22:52,720
from uh n to just four in this case

639
00:22:52,720 --> 00:22:54,640
because to evaluate a point you just

640
00:22:54,640 --> 00:22:57,200
need to evaluate on input blocks which

641
00:22:57,200 --> 00:22:58,880
are intersecting with the active with

642
00:22:58,880 --> 00:23:01,760
the current grade cell

643
00:23:02,400 --> 00:23:03,919
so just to sort of give you an overview

644
00:23:03,919 --> 00:23:05,840
of our

645
00:23:05,840 --> 00:23:07,679
fss

646
00:23:07,679 --> 00:23:08,960
cos

647
00:23:08,960 --> 00:23:10,720
so in the strong fss case from previous

648
00:23:10,720 --> 00:23:12,799
literature you had shade size which is

649
00:23:12,799 --> 00:23:14,720
exponential in dimension and you had

650
00:23:14,720 --> 00:23:16,559
eval cost which was n times the eval

651
00:23:16,559 --> 00:23:18,799
cost of a single ball

652
00:23:18,799 --> 00:23:21,280
so we ended up reducing the eval cost to

653
00:23:21,280 --> 00:23:23,919
2 to the d

654
00:23:23,919 --> 00:23:25,360
i just looked at the two dimensions but

655
00:23:25,360 --> 00:23:27,360
if you try to generalize it you actually

656
00:23:27,360 --> 00:23:29,760
get a factor of 2 to the t and we reduce

657
00:23:29,760 --> 00:23:31,840
the exponent of

658
00:23:31,840 --> 00:23:33,600
d as well

659
00:23:33,600 --> 00:23:36,320
in share size

660
00:23:36,320 --> 00:23:37,760
while i did not sort of discuss all the

661
00:23:37,760 --> 00:23:39,360
constructions we sort of ended up

662
00:23:39,360 --> 00:23:41,120
reducing the share size even more and

663
00:23:41,120 --> 00:23:42,960
even the eval cost by assuming a

664
00:23:42,960 --> 00:23:45,279
stricter geometry over the input balls

665
00:23:45,279 --> 00:23:46,880
like assuming they are very sort of far

666
00:23:46,880 --> 00:23:49,279
apart relatively

667
00:23:49,279 --> 00:23:51,440
and the overarching theme in our

668
00:23:51,440 --> 00:23:53,600
constructions was that we can exploit

669
00:23:53,600 --> 00:23:56,080
this weak fss relaxations and we can

670
00:23:56,080 --> 00:23:57,840
exploit a stricter geometry with the

671
00:23:57,840 --> 00:23:59,600
input balls to get a more efficient

672
00:23:59,600 --> 00:24:02,080
emphasis

673
00:24:02,320 --> 00:24:04,400
to summarize our results

674
00:24:04,400 --> 00:24:07,039
given a function secret sharing scheme

675
00:24:07,039 --> 00:24:08,400
of size sigma

676
00:24:08,400 --> 00:24:11,039
uh for any structured set you can get an

677
00:24:11,039 --> 00:24:13,600
opr protocol or a psa protocol where the

678
00:24:13,600 --> 00:24:15,440
communication complexity is proportional

679
00:24:15,440 --> 00:24:16,799
to sigma

680
00:24:16,799 --> 00:24:19,279
and we give a lot of simple yet powerful

681
00:24:19,279 --> 00:24:21,120
weak efficacy techniques which sort of

682
00:24:21,120 --> 00:24:22,480
helps us handle

683
00:24:22,480 --> 00:24:25,039
uh helps us optimize uh the emphasis for

684
00:24:25,039 --> 00:24:27,840
union of course

685
00:24:28,720 --> 00:24:30,640
we believe we have sort of failed barely

686
00:24:30,640 --> 00:24:32,080
scratched the surface in terms of

687
00:24:32,080 --> 00:24:33,600
exploring structure away private set

688
00:24:33,600 --> 00:24:34,640
intersection

689
00:24:34,640 --> 00:24:36,159
and there's a lot left to be explored

690
00:24:36,159 --> 00:24:37,919
for anyone interested

691
00:24:37,919 --> 00:24:39,679
so for sort of one of the key questions

692
00:24:39,679 --> 00:24:41,279
is can we make the computations up

693
00:24:41,279 --> 00:24:42,320
linear

694
00:24:42,320 --> 00:24:43,679
so while we sort of focus on the

695
00:24:43,679 --> 00:24:45,360
communication in this work we try to

696
00:24:45,360 --> 00:24:47,120
make this sub linear in the size of the

697
00:24:47,120 --> 00:24:48,559
structured set

698
00:24:48,559 --> 00:24:50,000
if we sort of sort of closely inspect

699
00:24:50,000 --> 00:24:52,320
the protocol our computation

700
00:24:52,320 --> 00:24:54,000
for alice is still sort of linear in the

701
00:24:54,000 --> 00:24:57,120
size of the structured set

702
00:24:57,440 --> 00:24:59,200
uh we exploit the structure in one of

703
00:24:59,200 --> 00:25:00,640
the parties said

704
00:25:00,640 --> 00:25:02,640
could we also assume substructure in the

705
00:25:02,640 --> 00:25:04,640
other party set and sort of exploit that

706
00:25:04,640 --> 00:25:06,799
so that's another question

707
00:25:06,799 --> 00:25:09,120
uh again our framework is restricted to

708
00:25:09,120 --> 00:25:11,440
semi-honest there are some challenges if

709
00:25:11,440 --> 00:25:13,440
you try to sort of translate it into the

710
00:25:13,440 --> 00:25:14,720
malicious setting

711
00:25:14,720 --> 00:25:16,320
um

712
00:25:16,320 --> 00:25:18,240
as you would have noticed all the shape

713
00:25:18,240 --> 00:25:20,000
signs that are showed most of them had

714
00:25:20,000 --> 00:25:22,480
an exponential dependence on dimension

715
00:25:22,480 --> 00:25:24,559
so they don't really scale very well

716
00:25:24,559 --> 00:25:26,799
in higher dimensions um

717
00:25:26,799 --> 00:25:30,320
and it's even worse for l1 metric uh

718
00:25:30,320 --> 00:25:32,000
so yeah can you sort of improve on the

719
00:25:32,000 --> 00:25:34,880
share size as well

720
00:25:35,039 --> 00:25:37,200
finally uh we were inspired by the fuzzy

721
00:25:37,200 --> 00:25:39,279
psi problem so we just looked at union

722
00:25:39,279 --> 00:25:41,440
of balls but you can sort of apply this

723
00:25:41,440 --> 00:25:43,279
framework on any arbitrary structured

724
00:25:43,279 --> 00:25:45,679
set so there's a lot left to be explored

725
00:25:45,679 --> 00:25:47,120
in that sense

726
00:25:47,120 --> 00:25:49,039
thank you and our paper is on april and

727
00:25:49,039 --> 00:25:50,799
sand we just made our implementation

728
00:25:50,799 --> 00:25:54,200
public space

729
00:26:00,240 --> 00:26:01,520
since we're running a bit behind

730
00:26:01,520 --> 00:26:03,440
schedule uh we can take maybe one quick

731
00:26:03,440 --> 00:26:05,520
question while the next uh speaker

732
00:26:05,520 --> 00:26:08,240
slides gets set

733
00:26:08,840 --> 00:26:11,279
up i'll jump in for a quick one then

734
00:26:11,279 --> 00:26:14,640
actually uh so what's the best weak fss

735
00:26:14,640 --> 00:26:17,120
for l2 balls for example

736
00:26:17,120 --> 00:26:19,919
uh i didn't have a slide for that

737
00:26:19,919 --> 00:26:21,919
okay so essentially what you can do is

738
00:26:21,919 --> 00:26:23,520
uh

739
00:26:23,520 --> 00:26:25,840
we can't do exactly two balls so that's

740
00:26:25,840 --> 00:26:28,240
not known but you can approximate uh an

741
00:26:28,240 --> 00:26:30,640
l2 ball by a polyhedron

742
00:26:30,640 --> 00:26:32,559
and depending on how many sides you want

743
00:26:32,559 --> 00:26:34,240
on the polyhedron that increases your

744
00:26:34,240 --> 00:26:35,919
fss complexity

745
00:26:35,919 --> 00:26:37,200
but at the same time you get a closer

746
00:26:37,200 --> 00:26:40,000
approximation to l2 so yeah l2 is sort

747
00:26:40,000 --> 00:26:41,760
of still uh something that we need to

748
00:26:41,760 --> 00:26:44,480
explore in more detail

749
00:26:44,480 --> 00:26:48,760
all right let's thank the speaker again

750
00:26:52,640 --> 00:26:54,960
the next talk will be on two-round mpc

751
00:26:54,960 --> 00:26:57,679
with round collapsing revisited

752
00:26:57,679 --> 00:26:59,679
toward efficient malicious protocols

753
00:26:59,679 --> 00:27:02,400
this is the work of luigi rachel lan and

754
00:27:02,400 --> 00:27:03,919
tian renmu

755
00:27:03,919 --> 00:27:05,919
and tian ren will be giving the talk uh

756
00:27:05,919 --> 00:27:08,480
virtually

757
00:27:09,039 --> 00:27:11,360
oh stands for introduction but that's

758
00:27:11,360 --> 00:27:14,240
the audio works now

759
00:27:18,840 --> 00:27:22,399
um yes yes we do hear you okay cool

760
00:27:22,399 --> 00:27:25,279
thank you yeah welcome to my talk

761
00:27:25,279 --> 00:27:27,919
today i will share uh oh

762
00:27:27,919 --> 00:27:30,320
the camera today i will share our recent

763
00:27:30,320 --> 00:27:33,360
work about the simple and efficient

764
00:27:33,360 --> 00:27:35,200
npc construction

765
00:27:35,200 --> 00:27:37,520
i'm ken liu recently joined peak

766
00:27:37,520 --> 00:27:39,039
university

767
00:27:39,039 --> 00:27:42,880
unfortunately i cannot join you

768
00:27:42,880 --> 00:27:45,600
in person my co-author is rich lin from

769
00:27:45,600 --> 00:27:47,440
the university of washington

770
00:27:47,440 --> 00:27:50,320
a shipyard impressed there

771
00:27:50,320 --> 00:27:53,120
so you all know npc

772
00:27:53,120 --> 00:27:54,640
there are n parties

773
00:27:54,640 --> 00:27:56,720
each has its own input

774
00:27:56,720 --> 00:27:58,880
they talk and they jointly compute the

775
00:27:58,880 --> 00:28:00,480
function

776
00:28:00,480 --> 00:28:03,919
for security any adversary

777
00:28:03,919 --> 00:28:07,120
even if he crafts many parties

778
00:28:07,120 --> 00:28:09,520
to learn nothing beyond the functional

779
00:28:09,520 --> 00:28:11,120
output

780
00:28:11,120 --> 00:28:12,559
okay

781
00:28:12,559 --> 00:28:13,760
so

782
00:28:13,760 --> 00:28:16,399
using mpc in the real world can be very

783
00:28:16,399 --> 00:28:19,120
expensive for many reasons

784
00:28:19,120 --> 00:28:20,240
typically

785
00:28:20,240 --> 00:28:22,240
network is the bottleneck

786
00:28:22,240 --> 00:28:26,720
measured by the communication complexity

787
00:28:26,720 --> 00:28:29,679
latency is also a big issue so right now

788
00:28:29,679 --> 00:28:31,679
when i'm talking to you

789
00:28:31,679 --> 00:28:34,399
there's a network delay about one second

790
00:28:34,399 --> 00:28:37,360
so so if you and i run a protocol of a

791
00:28:37,360 --> 00:28:39,039
few thousand rounds

792
00:28:39,039 --> 00:28:41,760
it will takes an hour

793
00:28:41,760 --> 00:28:44,080
wrong complexity likely to be the

794
00:28:44,080 --> 00:28:46,320
bottleneck especially for computing

795
00:28:46,320 --> 00:28:48,000
small functions

796
00:28:48,000 --> 00:28:50,640
and we know mpc protocols need at least

797
00:28:50,640 --> 00:28:53,039
two run

798
00:28:53,039 --> 00:28:54,399
more

799
00:28:54,399 --> 00:28:56,640
we also want to ensure that the

800
00:28:56,640 --> 00:28:58,399
communication complexity

801
00:28:58,399 --> 00:29:00,799
doesn't blow up too much

802
00:29:00,799 --> 00:29:01,840
so

803
00:29:01,840 --> 00:29:03,679
here's our setting

804
00:29:03,679 --> 00:29:06,320
we stick to two round protocols

805
00:29:06,320 --> 00:29:08,960
the diversity is malicious and corrupts

806
00:29:08,960 --> 00:29:11,279
any number of particles

807
00:29:11,279 --> 00:29:12,960
in this setting

808
00:29:12,960 --> 00:29:14,720
there are already

809
00:29:14,720 --> 00:29:16,399
many place works

810
00:29:16,399 --> 00:29:20,320
they belong to a few approaches

811
00:29:20,320 --> 00:29:21,279
okay

812
00:29:21,279 --> 00:29:23,440
so for example

813
00:29:23,440 --> 00:29:25,919
you can start with a passive secure

814
00:29:25,919 --> 00:29:27,520
two-run protocol

815
00:29:27,520 --> 00:29:30,480
and use this to enforce on this

816
00:29:30,480 --> 00:29:33,520
extraction execution

817
00:29:33,520 --> 00:29:35,279
or

818
00:29:35,279 --> 00:29:37,200
you can use the so-called round

819
00:29:37,200 --> 00:29:39,279
collapsing technique

820
00:29:39,279 --> 00:29:41,600
i won't go into the detail but roughly

821
00:29:41,600 --> 00:29:43,840
speaking you start with a multi-run

822
00:29:43,840 --> 00:29:45,279
protocol

823
00:29:45,279 --> 00:29:48,320
then somehow in two rounds every party

824
00:29:48,320 --> 00:29:51,200
can compute the double circuits of all

825
00:29:51,200 --> 00:29:52,320
the next

826
00:29:52,320 --> 00:29:55,039
message functions of the multirun

827
00:29:55,039 --> 00:29:57,360
protocol

828
00:29:57,360 --> 00:29:59,279
and recently

829
00:29:59,279 --> 00:30:01,200
there is also work

830
00:30:01,200 --> 00:30:02,640
um doing

831
00:30:02,640 --> 00:30:07,760
two runtime pc using the mpc in the head

832
00:30:07,840 --> 00:30:08,640
okay

833
00:30:08,640 --> 00:30:10,480
so for two random matrix protocols there

834
00:30:10,480 --> 00:30:11,440
are there are many works in the

835
00:30:11,440 --> 00:30:13,520
literature and i can only list a few of

836
00:30:13,520 --> 00:30:16,159
them in this page

837
00:30:16,159 --> 00:30:18,640
but existing protocols are not very

838
00:30:18,640 --> 00:30:20,720
efficient

839
00:30:20,720 --> 00:30:23,039
some use very expensive assumptions such

840
00:30:23,039 --> 00:30:25,440
as such as io

841
00:30:25,440 --> 00:30:27,679
or fhe

842
00:30:27,679 --> 00:30:30,240
and some because they make non-black pop

843
00:30:30,240 --> 00:30:32,159
use of assumptions

844
00:30:32,159 --> 00:30:34,640
for example say there's a cryptography

845
00:30:34,640 --> 00:30:37,679
function in the protocol i proved to you

846
00:30:37,679 --> 00:30:39,039
that i

847
00:30:39,039 --> 00:30:40,880
evaluate the function correctly using

848
00:30:40,880 --> 00:30:42,240
this

849
00:30:42,240 --> 00:30:43,760
or say

850
00:30:43,760 --> 00:30:46,080
i use the double circuit of this

851
00:30:46,080 --> 00:30:48,480
cryptography function

852
00:30:48,480 --> 00:30:51,200
such operations are known to be highly

853
00:30:51,200 --> 00:30:53,840
interesting

854
00:30:54,640 --> 00:30:55,919
among the prince work there are two

855
00:30:55,919 --> 00:30:58,799
exceptions gis and ikss

856
00:30:58,799 --> 00:31:01,200
they didn't make non-black use of

857
00:31:01,200 --> 00:31:03,120
assumptions

858
00:31:03,120 --> 00:31:05,600
but their technique in some sense

859
00:31:05,600 --> 00:31:09,120
make not black box use of some other

860
00:31:09,120 --> 00:31:11,039
mpc protocols

861
00:31:11,039 --> 00:31:12,159
and

862
00:31:12,159 --> 00:31:13,279
and the

863
00:31:13,279 --> 00:31:14,080
uh

864
00:31:14,080 --> 00:31:15,679
the other conversion increased the

865
00:31:15,679 --> 00:31:17,039
complexity

866
00:31:17,039 --> 00:31:18,720
at least to me

867
00:31:18,720 --> 00:31:22,720
their protocol seems very complicated

868
00:31:23,279 --> 00:31:24,640
in this work

869
00:31:24,640 --> 00:31:27,919
we aim for an efficient mpc protocol

870
00:31:27,919 --> 00:31:30,880
that is also conceptually simple

871
00:31:30,880 --> 00:31:33,919
all techniques are quite elementary and

872
00:31:33,919 --> 00:31:36,159
we make black box use of

873
00:31:36,159 --> 00:31:38,720
the assumptions

874
00:31:38,720 --> 00:31:41,279
so the model of our protocol

875
00:31:41,279 --> 00:31:44,320
uh we assume correlated randomness

876
00:31:44,320 --> 00:31:48,000
is disputed between every pair of

877
00:31:48,000 --> 00:31:51,840
parties before the particle starts

878
00:31:51,840 --> 00:31:53,200
so

879
00:31:53,200 --> 00:31:55,360
one party receives a1b1 the other

880
00:31:55,360 --> 00:31:58,399
receive a to b2 such that

881
00:31:58,399 --> 00:32:02,960
a1 times b2 equals b1 plus b2

882
00:32:02,960 --> 00:32:03,840
so

883
00:32:03,840 --> 00:32:05,919
this correlated random means it's uh

884
00:32:05,919 --> 00:32:08,640
widely used and can be efficiently

885
00:32:08,640 --> 00:32:10,880
generated and stored because there's the

886
00:32:10,880 --> 00:32:13,600
so-called the pseudo-random correlation

887
00:32:13,600 --> 00:32:14,480
generator

888
00:32:14,480 --> 00:32:16,799
so parties only need to store

889
00:32:16,799 --> 00:32:18,880
some correlated seed

890
00:32:18,880 --> 00:32:20,559
and later in the protocol they can

891
00:32:20,559 --> 00:32:22,880
generate correlated pseudorandomness on

892
00:32:22,880 --> 00:32:23,340
demand

893
00:32:23,340 --> 00:32:24,880
[Music]

894
00:32:24,880 --> 00:32:28,240
we also assume prg random oracle and

895
00:32:28,240 --> 00:32:30,960
broadcast channel the security notion is

896
00:32:30,960 --> 00:32:33,760
security visual board against static

897
00:32:33,760 --> 00:32:36,320
consumption

898
00:32:38,080 --> 00:32:39,200
so

899
00:32:39,200 --> 00:32:42,080
concretely our the the communication

900
00:32:42,080 --> 00:32:44,159
complexity of our protocol is the

901
00:32:44,159 --> 00:32:46,480
circuit size times the good parameter

902
00:32:46,480 --> 00:32:48,559
times thank you

903
00:32:48,559 --> 00:32:50,880
as you can see i didn't

904
00:32:50,880 --> 00:32:51,919
write

905
00:32:51,919 --> 00:32:54,480
the exact number for the complexity of

906
00:32:54,480 --> 00:32:56,080
facebook

907
00:32:56,080 --> 00:32:57,919
for a few reasons

908
00:32:57,919 --> 00:32:59,600
so when they they look more like

909
00:32:59,600 --> 00:33:01,600
feasibility results the conversation

910
00:33:01,600 --> 00:33:03,919
might be on fire

911
00:33:03,919 --> 00:33:06,880
also they convert one mpc protocol to

912
00:33:06,880 --> 00:33:08,399
another

913
00:33:08,399 --> 00:33:10,240
for example gis start with a multiround

914
00:33:10,240 --> 00:33:12,799
protocol and converted surround

915
00:33:12,799 --> 00:33:14,559
but they didn't enforce which protocol

916
00:33:14,559 --> 00:33:16,320
to service

917
00:33:16,320 --> 00:33:19,679
therefore uh it's unclear what's the

918
00:33:19,679 --> 00:33:22,559
complexity of the ending verb

919
00:33:22,559 --> 00:33:25,200
and finally despite what uh starting

920
00:33:25,200 --> 00:33:27,279
protocol you choose

921
00:33:27,279 --> 00:33:29,360
their conversion steps introduce too

922
00:33:29,360 --> 00:33:30,480
much

923
00:33:30,480 --> 00:33:32,480
blood so our protocol is still more

924
00:33:32,480 --> 00:33:34,880
efficient

925
00:33:35,519 --> 00:33:37,600
but okay but in the literature we also

926
00:33:37,600 --> 00:33:40,159
have even more efficient per code

927
00:33:40,159 --> 00:33:42,559
in the constant run sighting and the

928
00:33:42,559 --> 00:33:44,640
many run settings

929
00:33:44,640 --> 00:33:45,919
i guess it's a

930
00:33:45,919 --> 00:33:48,559
big open problem to say whether

931
00:33:48,559 --> 00:33:51,440
how how the run capacity related to the

932
00:33:51,440 --> 00:33:54,480
communication comments

933
00:33:55,279 --> 00:33:57,840
okay now i go to the technical part

934
00:33:57,840 --> 00:34:01,279
first i gave the high level idea of

935
00:34:01,279 --> 00:34:02,880
of our protocol

936
00:34:02,880 --> 00:34:04,960
the most important idea also the

937
00:34:04,960 --> 00:34:07,039
framework is called multi-party

938
00:34:07,039 --> 00:34:09,119
randomized encoding introduced by

939
00:34:09,119 --> 00:34:12,480
aquapon broski and sudbury

940
00:34:12,480 --> 00:34:15,359
so cu want to construct

941
00:34:15,359 --> 00:34:18,159
mpc computing function f

942
00:34:18,159 --> 00:34:22,159
mpie allows you to reduce the tax

943
00:34:22,159 --> 00:34:25,679
to to build mpr uh to to construct mpc

944
00:34:25,679 --> 00:34:27,599
for other functions

945
00:34:27,599 --> 00:34:30,079
so how it works

946
00:34:30,079 --> 00:34:31,679
um

947
00:34:31,679 --> 00:34:34,159
so every party locally people size their

948
00:34:34,159 --> 00:34:35,760
input

949
00:34:35,760 --> 00:34:36,719
and then

950
00:34:36,719 --> 00:34:40,239
they call it function f hat

951
00:34:40,480 --> 00:34:43,119
and after they learn the output of f hat

952
00:34:43,119 --> 00:34:45,650
they locally decode it

953
00:34:45,650 --> 00:34:47,040
[Music]

954
00:34:47,040 --> 00:34:48,960
so as you can see

955
00:34:48,960 --> 00:34:51,599
the um only the the middle part calling

956
00:34:51,599 --> 00:34:53,918
f hat is interactive that but other step

957
00:34:53,918 --> 00:34:56,399
is non-interactive

958
00:34:56,399 --> 00:34:58,880
and this is reduce our work from if you

959
00:34:58,880 --> 00:35:01,440
want to build a tournament perk of f

960
00:35:01,440 --> 00:35:04,960
it suffice to construct the mpre4s

961
00:35:04,960 --> 00:35:08,000
and then construct current protocol for

962
00:35:08,000 --> 00:35:10,720
compute the f hat function

963
00:35:10,720 --> 00:35:12,880
uh throughout this talk we restrict the

964
00:35:12,880 --> 00:35:15,440
f hat function to be a degree to

965
00:35:15,440 --> 00:35:17,359
function

966
00:35:17,359 --> 00:35:19,280
so when apt start to consider this

967
00:35:19,280 --> 00:35:20,960
problem they consider this in the honest

968
00:35:20,960 --> 00:35:23,760
majority set

969
00:35:23,760 --> 00:35:26,800
in a previous work with lean and v

970
00:35:26,800 --> 00:35:29,040
we started the

971
00:35:29,040 --> 00:35:31,680
uh we generate this framework to the

972
00:35:31,680 --> 00:35:33,920
honest minority setting and in this work

973
00:35:33,920 --> 00:35:36,000
we go to the malicious and on its

974
00:35:36,000 --> 00:35:37,890
magnetic section

975
00:35:37,890 --> 00:35:39,280
[Music]

976
00:35:39,280 --> 00:35:42,400
so this is the mpre

977
00:35:42,400 --> 00:35:45,200
in lw when we generate to generalize

978
00:35:45,200 --> 00:35:47,359
this framework to the

979
00:35:47,359 --> 00:35:49,839
honest minority setting we also require

980
00:35:49,839 --> 00:35:52,960
the use of curriculum renderings

981
00:35:52,960 --> 00:35:55,280
so the pre-precision function has the

982
00:35:55,280 --> 00:35:57,280
correlated function has the correlated

983
00:35:57,280 --> 00:35:59,839
randomness as part of the input

984
00:35:59,839 --> 00:36:02,720
so is the mpc function for computing the

985
00:36:02,720 --> 00:36:05,680
degree to f hat

986
00:36:07,520 --> 00:36:09,920
and the communication complexity is

987
00:36:09,920 --> 00:36:12,000
circuit size times perpendicular times

988
00:36:12,000 --> 00:36:14,560
into already

989
00:36:14,560 --> 00:36:16,720
in this work they consider malicious

990
00:36:16,720 --> 00:36:18,240
parties

991
00:36:18,240 --> 00:36:20,079
so there are there are few bad things

992
00:36:20,079 --> 00:36:21,200
might happen

993
00:36:21,200 --> 00:36:23,200
the malicious party can cheat

994
00:36:23,200 --> 00:36:24,640
one thing's like although the major

995
00:36:24,640 --> 00:36:27,839
party receives quality randomness

996
00:36:27,839 --> 00:36:30,079
he might fit something else in the

997
00:36:30,079 --> 00:36:32,480
pre-processing function

998
00:36:32,480 --> 00:36:33,680
second

999
00:36:33,680 --> 00:36:36,240
the malicious party might just

1000
00:36:36,240 --> 00:36:37,920
compute the privatizing function

1001
00:36:37,920 --> 00:36:39,520
incorrectly

1002
00:36:39,520 --> 00:36:40,880
and finally

1003
00:36:40,880 --> 00:36:43,839
we also need to upgrade the mpc protocol

1004
00:36:43,839 --> 00:36:46,160
from seeming malicious to similar

1005
00:36:46,160 --> 00:36:48,720
simulations

1006
00:36:49,680 --> 00:36:50,880
and

1007
00:36:50,880 --> 00:36:53,599
in the rest of this talk i will roughly

1008
00:36:53,599 --> 00:36:55,839
i will briefly go through how we deal

1009
00:36:55,839 --> 00:36:58,000
with this challenge

1010
00:36:58,000 --> 00:37:00,079
well we also okay

1011
00:37:00,079 --> 00:37:02,240
to fix this vulnerabilities

1012
00:37:02,240 --> 00:37:04,640
the we also need to make sure the blow

1013
00:37:04,640 --> 00:37:07,440
up is small so that our communication

1014
00:37:07,440 --> 00:37:09,520
capacity is the same as the parents

1015
00:37:09,520 --> 00:37:12,400
seeming on this part

1016
00:37:12,480 --> 00:37:14,160
so the first one

1017
00:37:14,160 --> 00:37:16,400
we want to ensure that

1018
00:37:16,400 --> 00:37:18,079
the malicious party use the right

1019
00:37:18,079 --> 00:37:20,960
curricular randomness

1020
00:37:20,960 --> 00:37:23,839
of course uh if you think of it uh

1021
00:37:23,839 --> 00:37:26,079
there's nothing can stop the malicious

1022
00:37:26,079 --> 00:37:29,520
party from using wrong quality redness

1023
00:37:29,520 --> 00:37:31,599
the only thing we can hope for is like

1024
00:37:31,599 --> 00:37:34,240
we can hope we can hide the privacy

1025
00:37:34,240 --> 00:37:36,880
information of aunt's party

1026
00:37:36,880 --> 00:37:38,720
when the

1027
00:37:38,720 --> 00:37:40,320
the malicious party make a malicious

1028
00:37:40,320 --> 00:37:41,920
move

1029
00:37:41,920 --> 00:37:43,920
randomly party fits something wrong in

1030
00:37:43,920 --> 00:37:47,359
the in the protocol

1031
00:37:47,359 --> 00:37:50,400
so here is our first attempt say one

1032
00:37:50,400 --> 00:37:51,920
party want to hide his privacy

1033
00:37:51,920 --> 00:37:55,119
information examples randomness are

1034
00:37:55,119 --> 00:37:56,480
and

1035
00:37:56,480 --> 00:37:58,320
let the f hat function output the

1036
00:37:58,320 --> 00:38:00,560
following message

1037
00:38:00,560 --> 00:38:02,480
this message properly hides the

1038
00:38:02,480 --> 00:38:03,760
information

1039
00:38:03,760 --> 00:38:07,040
when there's some relationship

1040
00:38:07,040 --> 00:38:08,960
but the problem is that

1041
00:38:08,960 --> 00:38:11,839
this function is a degree 3 function

1042
00:38:11,839 --> 00:38:14,640
and as we said

1043
00:38:14,640 --> 00:38:16,640
the f hat function has to be a degree 2

1044
00:38:16,640 --> 00:38:19,839
function for the later part

1045
00:38:21,040 --> 00:38:21,839
so

1046
00:38:21,839 --> 00:38:24,560
let me make a difference

1047
00:38:24,560 --> 00:38:26,480
so observe that when there is a

1048
00:38:26,480 --> 00:38:27,839
malicious move

1049
00:38:27,839 --> 00:38:29,839
this matrix is ferment

1050
00:38:29,839 --> 00:38:32,560
if and only

1051
00:38:32,560 --> 00:38:34,240
so therefore

1052
00:38:34,240 --> 00:38:36,480
if you want to honestly want to hide his

1053
00:38:36,480 --> 00:38:38,079
private information he can sample more

1054
00:38:38,079 --> 00:38:39,280
randomness

1055
00:38:39,280 --> 00:38:41,200
and output that matrix time the

1056
00:38:41,200 --> 00:38:43,599
randomness has used that to one time

1057
00:38:43,599 --> 00:38:46,720
head influence

1058
00:38:46,720 --> 00:38:49,119
it's obvious that

1059
00:38:49,119 --> 00:38:51,680
when their simulation smooth

1060
00:38:51,680 --> 00:38:54,640
the information is properly hidden

1061
00:38:54,640 --> 00:38:55,599
but

1062
00:38:55,599 --> 00:38:58,800
okay but here a1 a2

1063
00:38:58,800 --> 00:39:04,320
is leaked which is uh undesired

1064
00:39:04,320 --> 00:39:05,119
now

1065
00:39:05,119 --> 00:39:07,200
with all this opposition observation in

1066
00:39:07,200 --> 00:39:10,000
mind we present uh

1067
00:39:10,000 --> 00:39:12,560
our actual construction

1068
00:39:12,560 --> 00:39:14,720
so first step we need to replace the

1069
00:39:14,720 --> 00:39:16,800
scalar version of the ore correlation

1070
00:39:16,800 --> 00:39:19,040
into the matrix version

1071
00:39:19,040 --> 00:39:20,240
so now a

1072
00:39:20,240 --> 00:39:23,280
a1 a2 becomes vectors and b1 b2 become

1073
00:39:23,280 --> 00:39:28,800
active sql sharing of a1 tensor b2b

1074
00:39:28,800 --> 00:39:31,200
now if you want to hide some information

1075
00:39:31,200 --> 00:39:33,599
you first pick two random vector

1076
00:39:33,599 --> 00:39:36,000
and due to randomness

1077
00:39:36,000 --> 00:39:38,480
you can you can show that this matrix is

1078
00:39:38,480 --> 00:39:40,160
full rank if and only if there's a

1079
00:39:40,160 --> 00:39:43,359
malicious move

1080
00:39:43,359 --> 00:39:45,920
then the rest is similar

1081
00:39:45,920 --> 00:39:48,480
i sample more randomness

1082
00:39:48,480 --> 00:39:50,960
as i've had to output that matrix time

1083
00:39:50,960 --> 00:39:52,960
my new randomness plus my private

1084
00:39:52,960 --> 00:39:55,960
information

1085
00:39:56,560 --> 00:39:57,680
uh

1086
00:39:57,680 --> 00:39:59,760
for the degree

1087
00:39:59,760 --> 00:40:01,680
note that because

1088
00:40:01,680 --> 00:40:06,079
uh v1 v2 and rmr2 are all known by one

1089
00:40:06,079 --> 00:40:07,440
party

1090
00:40:07,440 --> 00:40:10,480
that party can locally multiply them

1091
00:40:10,480 --> 00:40:12,560
and therefore f

1092
00:40:12,560 --> 00:40:13,680
f hat

1093
00:40:13,680 --> 00:40:16,240
output and effectively effectively

1094
00:40:16,240 --> 00:40:19,200
degree two function

1095
00:40:19,359 --> 00:40:20,800
for privacy

1096
00:40:20,800 --> 00:40:22,720
there are some leakage

1097
00:40:22,720 --> 00:40:26,160
but because we have replaced from uh the

1098
00:40:26,160 --> 00:40:27,920
correlated retinas from the scalar

1099
00:40:27,920 --> 00:40:29,680
version to vector version

1100
00:40:29,680 --> 00:40:32,560
we have a one is much longer

1101
00:40:32,560 --> 00:40:35,119
so what all we need is some coordinate

1102
00:40:35,119 --> 00:40:38,079
of a1 it's unlinked so this kind of

1103
00:40:38,079 --> 00:40:40,560
leakage is fine

1104
00:40:40,560 --> 00:40:41,599
uh

1105
00:40:41,599 --> 00:40:43,680
as you might observed

1106
00:40:43,680 --> 00:40:44,800
like uh

1107
00:40:44,800 --> 00:40:46,640
things in these slides

1108
00:40:46,640 --> 00:40:50,000
doesn't look so secure and uh

1109
00:40:50,000 --> 00:40:51,839
and that's right it is just the main

1110
00:40:51,839 --> 00:40:55,440
idea and it can be uh formalized

1111
00:40:55,440 --> 00:40:58,960
also for for uh efficiency like this

1112
00:40:58,960 --> 00:41:01,440
slice also looks it would bring uh like

1113
00:41:01,440 --> 00:41:06,040
a square blow up but actually did

1114
00:41:06,319 --> 00:41:08,480
so for the next one

1115
00:41:08,480 --> 00:41:10,240
we want to ensure that the malicious

1116
00:41:10,240 --> 00:41:14,079
party computer preprocessing functions

1117
00:41:14,079 --> 00:41:16,880
how do we achieve that uh okay

1118
00:41:16,880 --> 00:41:19,119
we just postponed the

1119
00:41:19,119 --> 00:41:22,400
the problem to the next slides

1120
00:41:22,400 --> 00:41:24,319
so we just say okay later when we

1121
00:41:24,319 --> 00:41:26,160
construct the toronto

1122
00:41:26,160 --> 00:41:28,640
npc for computing i've had

1123
00:41:28,640 --> 00:41:32,000
that mpc also ensure the input it's well

1124
00:41:32,000 --> 00:41:33,490
for

1125
00:41:33,490 --> 00:41:34,720
[Music]

1126
00:41:34,720 --> 00:41:37,839
and therefore we call our mpre uh semi

1127
00:41:37,839 --> 00:41:40,079
malicious because uh

1128
00:41:40,079 --> 00:41:42,400
the mpi itself doesn't reinforce the

1129
00:41:42,400 --> 00:41:44,000
pre-processing function to be valid

1130
00:41:44,000 --> 00:41:46,400
correctly the duty is

1131
00:41:46,400 --> 00:41:50,720
strict to the uh mpc part

1132
00:41:50,720 --> 00:41:51,760
okay

1133
00:41:51,760 --> 00:41:53,200
finally

1134
00:41:53,200 --> 00:41:54,560
uh

1135
00:41:54,560 --> 00:41:57,520
how would we construct two run x

1136
00:41:57,520 --> 00:41:59,119
for f hat

1137
00:41:59,119 --> 00:42:02,400
the important observation is that

1138
00:42:02,400 --> 00:42:05,119
the semi-honest uh npc for computing

1139
00:42:05,119 --> 00:42:06,880
i've had in lw

1140
00:42:06,880 --> 00:42:10,480
it's already somewhat maliciously secure

1141
00:42:10,480 --> 00:42:13,680
okay i'll just briefly recap that

1142
00:42:13,680 --> 00:42:16,960
without loss of generality uh in a

1143
00:42:16,960 --> 00:42:19,599
similar honest case you can assume f hat

1144
00:42:19,599 --> 00:42:23,200
is just x one x two plus d one z two

1145
00:42:23,200 --> 00:42:24,000
where

1146
00:42:24,000 --> 00:42:26,880
x one z one caught by one party x two z

1147
00:42:26,880 --> 00:42:30,040
two completed

1148
00:42:30,160 --> 00:42:34,240
so the protocol use quality randomness

1149
00:42:34,400 --> 00:42:36,720
uh in the first round

1150
00:42:36,720 --> 00:42:38,720
okay this is the perk

1151
00:42:38,720 --> 00:42:41,040
uh you don't need to verify it

1152
00:42:41,040 --> 00:42:42,480
it works well

1153
00:42:42,480 --> 00:42:45,680
and it's malicious secure okay it

1154
00:42:45,680 --> 00:42:48,480
actually satisfy a weaker notion of

1155
00:42:48,480 --> 00:42:50,800
security we call it security with auto

1156
00:42:50,800 --> 00:42:54,160
substitution it's very similar to the

1157
00:42:54,160 --> 00:42:56,160
privacy with knowledge of auckland

1158
00:42:56,160 --> 00:42:57,520
support

1159
00:42:57,520 --> 00:42:59,520
and it can be lifted to the standard

1160
00:42:59,520 --> 00:43:01,440
secure sending notion of the predictive

1161
00:43:01,440 --> 00:43:03,839
support

1162
00:43:05,040 --> 00:43:07,520
and in the first round

1163
00:43:07,520 --> 00:43:10,000
note that

1164
00:43:10,160 --> 00:43:12,480
the message c1 c2

1165
00:43:12,480 --> 00:43:15,359
they can be viewed as commitment of two

1166
00:43:15,359 --> 00:43:18,800
parties input a1 x1 and x2

1167
00:43:18,800 --> 00:43:20,800
and they can also the input can be

1168
00:43:20,800 --> 00:43:23,920
easily simulated

1169
00:43:24,560 --> 00:43:25,760
but

1170
00:43:25,760 --> 00:43:28,000
when you go to the malicious setting you

1171
00:43:28,000 --> 00:43:30,560
can no more assume the function is

1172
00:43:30,560 --> 00:43:32,319
that simple

1173
00:43:32,319 --> 00:43:34,240
but still without loss of generality you

1174
00:43:34,240 --> 00:43:36,000
can assume that

1175
00:43:36,000 --> 00:43:37,440
the

1176
00:43:37,440 --> 00:43:39,839
f hat is has a long output but each bit

1177
00:43:39,839 --> 00:43:42,880
of the output looks like x y x two plus

1178
00:43:42,880 --> 00:43:45,200
one z

1179
00:43:46,000 --> 00:43:49,200
so for example you can say another

1180
00:43:49,200 --> 00:43:51,040
a bit of the output is

1181
00:43:51,040 --> 00:43:52,079
x two

1182
00:43:52,079 --> 00:43:55,520
x three plus z2 z3

1183
00:43:55,520 --> 00:43:57,839
and we use the same protocol for

1184
00:43:57,839 --> 00:44:00,319
computing

1185
00:44:02,640 --> 00:44:05,119
what could construct here it's like when

1186
00:44:05,119 --> 00:44:08,560
you simulate this protocol

1187
00:44:08,560 --> 00:44:11,920
you simulate x1 sorry you simulate x2

1188
00:44:11,920 --> 00:44:13,680
from left-hand side of protocol and you

1189
00:44:13,680 --> 00:44:15,520
simulate x2 from the right-hand side

1190
00:44:15,520 --> 00:44:17,200
particle as well

1191
00:44:17,200 --> 00:44:19,520
in a similar case it's fine but in this

1192
00:44:19,520 --> 00:44:24,160
case maybe this x two are different

1193
00:44:24,160 --> 00:44:25,760
so therefore

1194
00:44:25,760 --> 00:44:28,000
we need a way to

1195
00:44:28,000 --> 00:44:30,000
for the for every party to prove that

1196
00:44:30,000 --> 00:44:31,359
okay i fit

1197
00:44:31,359 --> 00:44:36,920
consistent x2 into different extraction

1198
00:44:38,000 --> 00:44:40,560
how would we do that

1199
00:44:40,560 --> 00:44:43,119
similarly in the first step we need to

1200
00:44:43,119 --> 00:44:45,040
replace the

1201
00:44:45,040 --> 00:44:47,119
scalar version of the quantitativeness

1202
00:44:47,119 --> 00:44:48,960
to the matrix versions multiple

1203
00:44:48,960 --> 00:44:51,200
curriculum

1204
00:44:51,200 --> 00:44:54,160
and now because a is longer

1205
00:44:54,160 --> 00:44:56,400
uh in the first round we can send a

1206
00:44:56,400 --> 00:44:58,960
commitment of a longer message

1207
00:44:58,960 --> 00:45:00,960
so we can send x2

1208
00:45:00,960 --> 00:45:02,839
a pad with something

1209
00:45:02,839 --> 00:45:04,960
else okay

1210
00:45:04,960 --> 00:45:08,000
uh although i won't show in this talk

1211
00:45:08,000 --> 00:45:10,240
so some kind of commitment so if you use

1212
00:45:10,240 --> 00:45:12,319
our correlation to commit message it has

1213
00:45:12,319 --> 00:45:14,319
a very nice property that

1214
00:45:14,319 --> 00:45:16,560
it allows you to partially open a

1215
00:45:16,560 --> 00:45:19,680
commitment so for example the other

1216
00:45:19,680 --> 00:45:21,359
party can

1217
00:45:21,359 --> 00:45:24,480
send a vector queue

1218
00:45:24,480 --> 00:45:25,839
and

1219
00:45:25,839 --> 00:45:26,960
then

1220
00:45:26,960 --> 00:45:28,480
this commitment you can open the

1221
00:45:28,480 --> 00:45:30,640
commitment you can open

1222
00:45:30,640 --> 00:45:33,359
a queue cue inner product the

1223
00:45:33,359 --> 00:45:37,119
what's the message behind this company

1224
00:45:37,200 --> 00:45:40,720
so we just use this property

1225
00:45:40,720 --> 00:45:43,920
in the other side as well

1226
00:45:43,920 --> 00:45:45,680
okay

1227
00:45:45,680 --> 00:45:47,280
so

1228
00:45:47,280 --> 00:45:50,560
in this way because q1 and a queue is

1229
00:45:50,560 --> 00:45:52,800
randomly chosen by honest party

1230
00:45:52,800 --> 00:45:54,720
this enforce the potentially malicious

1231
00:45:54,720 --> 00:45:55,760
party

1232
00:45:55,760 --> 00:45:57,680
to commit the same message otherwise it

1233
00:45:57,680 --> 00:45:59,520
recalled

1234
00:45:59,520 --> 00:46:02,000
the problem here is that uh

1235
00:46:02,000 --> 00:46:04,960
this check takes three runs so

1236
00:46:04,960 --> 00:46:07,839
we use the center field xiaomi

1237
00:46:07,839 --> 00:46:09,680
type uh

1238
00:46:09,680 --> 00:46:12,800
uh with uh to convert it to into only

1239
00:46:12,800 --> 00:46:14,800
one right

1240
00:46:14,800 --> 00:46:16,319
fuchsia mirror for future mirror we

1241
00:46:16,319 --> 00:46:19,440
require random work

1242
00:46:20,480 --> 00:46:22,240
[Music]

1243
00:46:22,240 --> 00:46:24,400
so okay so as mentioned

1244
00:46:24,400 --> 00:46:26,640
to prove consistency

1245
00:46:26,640 --> 00:46:29,040
we use a matrix version of the

1246
00:46:29,040 --> 00:46:30,560
criticalness

1247
00:46:30,560 --> 00:46:32,480
we use the idea that

1248
00:46:32,480 --> 00:46:35,520
this commitment can be partially opened

1249
00:46:35,520 --> 00:46:37,920
and be used spiritually

1250
00:46:37,920 --> 00:46:40,480
we also need to have well from this

1251
00:46:40,480 --> 00:46:43,520
hole from this actually the

1252
00:46:43,520 --> 00:46:46,480
uh is it's not covering this talk but

1253
00:46:46,480 --> 00:46:49,040
the idea is very simple you only need to

1254
00:46:49,040 --> 00:46:51,040
combine the above idea

1255
00:46:51,040 --> 00:46:56,040
uh plus the idea of linear proof

1256
00:46:56,240 --> 00:46:59,359
so that's the basic reconstruction we

1257
00:46:59,359 --> 00:47:02,319
make the mpre simulation secure and

1258
00:47:02,319 --> 00:47:04,560
we also make the mpc port for computing

1259
00:47:04,560 --> 00:47:06,720
degree 2 function not only

1260
00:47:06,720 --> 00:47:09,440
maliciously secure but also track

1261
00:47:09,440 --> 00:47:12,400
performance and combining them gives you

1262
00:47:12,400 --> 00:47:17,040
a 200 mpc for computing any functions

1263
00:47:17,040 --> 00:47:18,240
okay

1264
00:47:18,240 --> 00:47:20,640
so this is the

1265
00:47:20,640 --> 00:47:22,640
overview of the talk

1266
00:47:22,640 --> 00:47:24,720
as mentioned that our complexity is

1267
00:47:24,720 --> 00:47:26,319
circuit size times the key parameters

1268
00:47:26,319 --> 00:47:27,760
constantly

1269
00:47:27,760 --> 00:47:30,800
we also actually we also have another uh

1270
00:47:30,800 --> 00:47:31,839
result

1271
00:47:31,839 --> 00:47:34,640
for arithmetic branching program it is a

1272
00:47:34,640 --> 00:47:37,119
little secure and it only make black

1273
00:47:37,119 --> 00:47:41,359
bulk assist to the field

1274
00:47:41,440 --> 00:47:44,079
and our protocol is because it only used

1275
00:47:44,079 --> 00:47:46,960
very simple tricks so the computation

1276
00:47:46,960 --> 00:47:48,640
complexity is roughly the same as the

1277
00:47:48,640 --> 00:47:50,880
communication next

1278
00:47:50,880 --> 00:47:52,559
and that's it

1279
00:47:52,559 --> 00:47:55,440
thank you for listening

1280
00:48:02,480 --> 00:48:04,000
again we can take

1281
00:48:04,000 --> 00:48:05,520
a quick question while the next

1282
00:48:05,520 --> 00:48:08,319
speaker's setting up

1283
00:48:12,000 --> 00:48:15,119
maybe just a brief medic question

1284
00:48:15,119 --> 00:48:17,520
do you have any thoughts about whether

1285
00:48:17,520 --> 00:48:19,359
how far the communication complexity

1286
00:48:19,359 --> 00:48:20,400
could be

1287
00:48:20,400 --> 00:48:23,280
for example n squared or

1288
00:48:23,280 --> 00:48:25,119
even beyond this okay

1289
00:48:25,119 --> 00:48:28,000
uh well yeah we definitely try to push

1290
00:48:28,000 --> 00:48:30,640
it to n square

1291
00:48:30,640 --> 00:48:32,400
refilled uh

1292
00:48:32,400 --> 00:48:34,480
okay so maybe the

1293
00:48:34,480 --> 00:48:36,720
corporation one

1294
00:48:36,720 --> 00:48:37,680
yeah

1295
00:48:37,680 --> 00:48:39,200
so

1296
00:48:39,200 --> 00:48:41,680
of course that's the

1297
00:48:41,680 --> 00:48:44,160
that's the most obvious like open

1298
00:48:44,160 --> 00:48:45,599
question for the

1299
00:48:45,599 --> 00:48:48,839
uh our

1300
00:48:58,240 --> 00:49:02,240
mystery then for you guys to solve

1301
00:49:02,240 --> 00:49:04,559
so let's switch to the to the final talk

1302
00:49:04,559 --> 00:49:06,800
then

1303
00:49:06,960 --> 00:49:08,960
final talk will be on more efficient

1304
00:49:08,960 --> 00:49:11,359
dishonest majority secure computation

1305
00:49:11,359 --> 00:49:14,880
over z2 to the k via wall rings

1306
00:49:14,880 --> 00:49:17,599
this is a joint work of daniel scudero

1307
00:49:17,599 --> 00:49:20,319
michelle ping jing and chen

1308
00:49:20,319 --> 00:49:25,558
yuan and daniel will be the speaker

1309
00:49:39,359 --> 00:49:42,640
hello yeah okay good

1310
00:49:42,640 --> 00:49:46,480
and you have to postpone

1311
00:49:53,599 --> 00:49:55,760
yes thank you so

1312
00:49:55,760 --> 00:49:57,680
i'm going to be

1313
00:49:57,680 --> 00:49:59,760
presenting from my ad packages you will

1314
00:49:59,760 --> 00:50:01,520
apologize the

1315
00:50:01,520 --> 00:50:03,520
the toolbar and so on so thank you so

1316
00:50:03,520 --> 00:50:05,119
much for the introduction i'm happy to

1317
00:50:05,119 --> 00:50:07,599
be here finally after some years of

1318
00:50:07,599 --> 00:50:09,680
virtual conferences and this is going to

1319
00:50:09,680 --> 00:50:10,559
be

1320
00:50:10,559 --> 00:50:12,720
another talk on npc

1321
00:50:12,720 --> 00:50:15,440
i am more concretely mpc over this ring

1322
00:50:15,440 --> 00:50:16,880
that i'm going to explain right now in a

1323
00:50:16,880 --> 00:50:18,480
moment

1324
00:50:18,480 --> 00:50:21,119
right so let's get started with a super

1325
00:50:21,119 --> 00:50:24,000
quick introduction so the setting let's

1326
00:50:24,000 --> 00:50:24,960
start with the setting we're going to

1327
00:50:24,960 --> 00:50:28,400
have n parties that i'm calling p1 up to

1328
00:50:28,400 --> 00:50:30,559
pn and they're going to have private

1329
00:50:30,559 --> 00:50:33,119
inputs x1 up to xn

1330
00:50:33,119 --> 00:50:34,880
and the goal is that they wish to

1331
00:50:34,880 --> 00:50:36,800
compute certain function that i'm

1332
00:50:36,800 --> 00:50:38,480
denoting by f

1333
00:50:38,480 --> 00:50:39,920
and they don't want to use any trusted

1334
00:50:39,920 --> 00:50:42,160
party that's the standard setting when

1335
00:50:42,160 --> 00:50:43,440
we consider secure multi-party

1336
00:50:43,440 --> 00:50:45,359
competition

1337
00:50:45,359 --> 00:50:47,760
and the adversarial

1338
00:50:47,760 --> 00:50:49,200
or the attack that we want to consider

1339
00:50:49,200 --> 00:50:51,280
here we want to consider an adversary

1340
00:50:51,280 --> 00:50:54,240
that actively corrupts corrupt

1341
00:50:54,240 --> 00:50:57,359
n minus one are the end parties so we

1342
00:50:57,359 --> 00:51:00,079
call this also dishonest majority

1343
00:51:00,079 --> 00:51:01,920
because this is in contrast to honest

1344
00:51:01,920 --> 00:51:03,280
majority when the adversary only

1345
00:51:03,280 --> 00:51:06,480
corrupts well a minority of the parties

1346
00:51:06,480 --> 00:51:10,000
and we want that even in that case the

1347
00:51:10,000 --> 00:51:11,920
input of the remaining honest party that

1348
00:51:11,920 --> 00:51:13,839
is only one honest party

1349
00:51:13,839 --> 00:51:15,280
is kept private

1350
00:51:15,280 --> 00:51:17,440
so the key words here are dishonest

1351
00:51:17,440 --> 00:51:19,680
majority and active corruption active

1352
00:51:19,680 --> 00:51:21,760
corruptions are not the case where

1353
00:51:21,760 --> 00:51:23,520
the corrupt parties deviate arbitrarily

1354
00:51:23,520 --> 00:51:26,800
from the protocol specification

1355
00:51:28,319 --> 00:51:29,839
right so

1356
00:51:29,839 --> 00:51:32,000
usually the function f that we want to

1357
00:51:32,000 --> 00:51:33,839
compute it's it's quite common to

1358
00:51:33,839 --> 00:51:36,160
represent it as an arithmetic circuit

1359
00:51:36,160 --> 00:51:38,640
over a certain finite rank arithmetic

1360
00:51:38,640 --> 00:51:41,119
circuit being simply a combination of

1361
00:51:41,119 --> 00:51:44,000
multiplications and additions over say

1362
00:51:44,000 --> 00:51:45,760
the ring

1363
00:51:45,760 --> 00:51:47,760
and what are the typical choices we care

1364
00:51:47,760 --> 00:51:50,160
about when we want to

1365
00:51:50,160 --> 00:51:51,680
do a computation

1366
00:51:51,680 --> 00:51:54,240
we typically choose a ring of this form

1367
00:51:54,240 --> 00:51:57,200
we which is zm which is the integers

1368
00:51:57,200 --> 00:52:00,640
model of some other integer m

1369
00:52:00,640 --> 00:52:02,880
and the reasons why we usually do this

1370
00:52:02,880 --> 00:52:05,040
is because well there are several

1371
00:52:05,040 --> 00:52:06,240
reasons but

1372
00:52:06,240 --> 00:52:08,000
if you if you choose m to be large

1373
00:52:08,000 --> 00:52:10,240
enough you can basically emulate integer

1374
00:52:10,240 --> 00:52:11,920
arithmetic if you want to do sums if you

1375
00:52:11,920 --> 00:52:14,000
want the products over the integers

1376
00:52:14,000 --> 00:52:15,440
you can just compute an upper bound on

1377
00:52:15,440 --> 00:52:16,880
the integers and then choose a modulus

1378
00:52:16,880 --> 00:52:19,760
that is large enough

1379
00:52:19,760 --> 00:52:21,839
and the other reason is that if you

1380
00:52:21,839 --> 00:52:23,920
choose m equal to two you can get

1381
00:52:23,920 --> 00:52:25,599
essentially binary computations so it's

1382
00:52:25,599 --> 00:52:27,200
like boolean

1383
00:52:27,200 --> 00:52:29,839
arithmetic boolean circuits that

1384
00:52:29,839 --> 00:52:31,839
of course have a lot of applications so

1385
00:52:31,839 --> 00:52:33,280
it's very common to use this type of

1386
00:52:33,280 --> 00:52:35,920
rings for mpc

1387
00:52:35,920 --> 00:52:38,800
and finite fields which is what you get

1388
00:52:38,800 --> 00:52:39,760
if you

1389
00:52:39,760 --> 00:52:41,760
choose m to be a prime

1390
00:52:41,760 --> 00:52:44,720
are actually quite common in npcs

1391
00:52:44,720 --> 00:52:46,800
because they are good for protocol

1392
00:52:46,800 --> 00:52:48,160
design

1393
00:52:48,160 --> 00:52:49,280
and the

1394
00:52:49,280 --> 00:52:50,960
most important property that we usually

1395
00:52:50,960 --> 00:52:54,079
use is that every non-zero element turns

1396
00:52:54,079 --> 00:52:55,680
out to be invertible that's what defines

1397
00:52:55,680 --> 00:52:57,680
a field and this property turns out to

1398
00:52:57,680 --> 00:53:00,240
be essential in building protocols at

1399
00:53:00,240 --> 00:53:01,520
least in a lot of actively secure

1400
00:53:01,520 --> 00:53:02,960
protocols this turns out to be an

1401
00:53:02,960 --> 00:53:05,760
important property

1402
00:53:07,040 --> 00:53:09,599
right so an alternative um

1403
00:53:09,599 --> 00:53:11,280
that we've seen in recent years that may

1404
00:53:11,280 --> 00:53:13,359
have certain advantages is not taking a

1405
00:53:13,359 --> 00:53:16,000
prime but taking a power of two

1406
00:53:16,000 --> 00:53:18,079
by the way i want to say that all almost

1407
00:53:18,079 --> 00:53:19,839
everything i would say during all this

1408
00:53:19,839 --> 00:53:22,720
stock it extends naturally if the prime

1409
00:53:22,720 --> 00:53:25,280
is not two p but the case i want to make

1410
00:53:25,280 --> 00:53:27,599
more emphasis on is two

1411
00:53:27,599 --> 00:53:29,440
so it has certain advantages and some of

1412
00:53:29,440 --> 00:53:30,319
them

1413
00:53:30,319 --> 00:53:32,160
we have experienced experimentally in

1414
00:53:32,160 --> 00:53:34,160
some previous work in s p

1415
00:53:34,160 --> 00:53:36,800
and basically the motivation is that

1416
00:53:36,800 --> 00:53:40,079
if you choose k to be for example 32 or

1417
00:53:40,079 --> 00:53:42,880
64 you can get a

1418
00:53:42,880 --> 00:53:44,720
reduction in

1419
00:53:44,720 --> 00:53:46,480
this model like like for free in

1420
00:53:46,480 --> 00:53:48,640
standard computer architecture so that's

1421
00:53:48,640 --> 00:53:49,920
a motivation

1422
00:53:49,920 --> 00:53:51,119
and also

1423
00:53:51,119 --> 00:53:53,359
it turns out that cgdk is in a way more

1424
00:53:53,359 --> 00:53:55,280
compatible with binary computation which

1425
00:53:55,280 --> 00:53:57,680
is very good when it comes to

1426
00:53:57,680 --> 00:53:59,440
doing what we call mixed computation

1427
00:53:59,440 --> 00:54:00,800
sometimes you don't want to stay in the

1428
00:54:00,800 --> 00:54:02,720
arithmetic world you want to jump

1429
00:54:02,720 --> 00:54:04,079
back and forth within arithmetic and

1430
00:54:04,079 --> 00:54:06,160
boolean and these rings turn out to be

1431
00:54:06,160 --> 00:54:08,640
useful for this type of settings

1432
00:54:08,640 --> 00:54:10,800
so that's pretty good but unfortunately

1433
00:54:10,800 --> 00:54:12,720
this ring it has a lot of disadvantages

1434
00:54:12,720 --> 00:54:14,800
with respect to fields specifically when

1435
00:54:14,800 --> 00:54:17,119
it comes to protocol design

1436
00:54:17,119 --> 00:54:19,680
and they mostly come from the fact that

1437
00:54:19,680 --> 00:54:21,920
there are many non-invertible elements

1438
00:54:21,920 --> 00:54:23,119
and in particular there are zero

1439
00:54:23,119 --> 00:54:24,800
divisors so you can see that this

1440
00:54:24,800 --> 00:54:27,119
equation falls in this ring this is 2 to

1441
00:54:27,119 --> 00:54:30,319
the k which is 0 in this ring

1442
00:54:30,319 --> 00:54:31,520
so

1443
00:54:31,520 --> 00:54:33,680
this indeed brings some complications to

1444
00:54:33,680 --> 00:54:34,880
the table when you want to design

1445
00:54:34,880 --> 00:54:38,240
protocols over this ring

1446
00:54:38,240 --> 00:54:39,599
and

1447
00:54:39,599 --> 00:54:42,240
we can see that we have like a massive

1448
00:54:42,240 --> 00:54:43,520
um

1449
00:54:43,520 --> 00:54:45,520
line of works in the direction of doing

1450
00:54:45,520 --> 00:54:47,920
dishonest majority mpc over finite

1451
00:54:47,920 --> 00:54:51,119
fields i'm just listing some

1452
00:54:51,119 --> 00:54:52,880
some of them and all of them basically

1453
00:54:52,880 --> 00:54:55,440
follow a similar structure they use

1454
00:54:55,440 --> 00:54:56,880
additive secret sharing by the way i'm

1455
00:54:56,880 --> 00:54:58,480
talking mostly about secret sharing

1456
00:54:58,480 --> 00:54:59,920
based protocols

1457
00:54:59,920 --> 00:55:01,359
uh of course there are other particles

1458
00:55:01,359 --> 00:55:02,799
you can based on homogeneous encryption

1459
00:55:02,799 --> 00:55:04,400
or global circuits and i'm not

1460
00:55:04,400 --> 00:55:06,400
considering those with of discussion so

1461
00:55:06,400 --> 00:55:08,799
they all use additive secret sharing

1462
00:55:08,799 --> 00:55:10,480
with message authentication codes to

1463
00:55:10,480 --> 00:55:11,760
prevent

1464
00:55:11,760 --> 00:55:13,760
and the online phase in fact

1465
00:55:13,760 --> 00:55:15,520
in all of them look pretty much the same

1466
00:55:15,520 --> 00:55:17,440
it's very similar

1467
00:55:17,440 --> 00:55:18,839
and for multiplication they use

1468
00:55:18,839 --> 00:55:21,520
multiplication triples

1469
00:55:21,599 --> 00:55:22,559
so

1470
00:55:22,559 --> 00:55:25,359
they they use this max and and this max

1471
00:55:25,359 --> 00:55:26,799
they tend to work only over fields

1472
00:55:26,799 --> 00:55:27,839
because they require certain

1473
00:55:27,839 --> 00:55:31,359
invertibility as i was mentioning

1474
00:55:31,359 --> 00:55:33,680
and if you want to extend those works to

1475
00:55:33,680 --> 00:55:35,760
to operate over the ring city to decay

1476
00:55:35,760 --> 00:55:38,720
we have a different line of works that

1477
00:55:38,720 --> 00:55:40,799
use slightly different techniques

1478
00:55:40,799 --> 00:55:43,680
so back in 2018 we introduced

1479
00:55:43,680 --> 00:55:45,119
this work that

1480
00:55:45,119 --> 00:55:48,400
proposed an alternative mac mechanism

1481
00:55:48,400 --> 00:55:49,760
an alternative message authentication

1482
00:55:49,760 --> 00:55:51,599
code and then

1483
00:55:51,599 --> 00:55:54,079
several works afterwards they built on

1484
00:55:54,079 --> 00:55:55,599
top of these to improve the

1485
00:55:55,599 --> 00:55:57,119
communication complexity mostly in the

1486
00:55:57,119 --> 00:55:59,280
pre-processing

1487
00:55:59,280 --> 00:56:01,520
and they all use this idea

1488
00:56:01,520 --> 00:56:04,400
which involves working over a larger

1489
00:56:04,400 --> 00:56:05,359
ring

1490
00:56:05,359 --> 00:56:08,079
so in these protocols we have to move to

1491
00:56:08,079 --> 00:56:09,920
to not an extension rate but a larger

1492
00:56:09,920 --> 00:56:12,000
ring where you take the k bits you have

1493
00:56:12,000 --> 00:56:14,319
and you have to add s bits on top where

1494
00:56:14,319 --> 00:56:16,960
s is going to be the security parameter

1495
00:56:16,960 --> 00:56:19,119
so you have inherent overhead when

1496
00:56:19,119 --> 00:56:22,079
working with this protocol

1497
00:56:22,880 --> 00:56:23,920
right and we're talking about

1498
00:56:23,920 --> 00:56:26,799
computation modulus to the k well

1499
00:56:26,799 --> 00:56:28,960
k equal to 1 is a particular case

1500
00:56:28,960 --> 00:56:31,040
so the case of binary computation

1501
00:56:31,040 --> 00:56:32,240
and you have some protocols that are

1502
00:56:32,240 --> 00:56:33,520
specifically designed for the setting

1503
00:56:33,520 --> 00:56:34,960
i'm just listing some

1504
00:56:34,960 --> 00:56:36,480
and i think

1505
00:56:36,480 --> 00:56:37,680
this one in particular would be

1506
00:56:37,680 --> 00:56:39,440
important for our discussion because it

1507
00:56:39,440 --> 00:56:41,440
turns out that a protocol will also

1508
00:56:41,440 --> 00:56:43,920
apply for k equals one we will also be

1509
00:56:43,920 --> 00:56:45,920
able to improve this recent protocol by

1510
00:56:45,920 --> 00:56:48,640
casco and constant

1511
00:56:48,640 --> 00:56:50,400
right and of course i want to highlight

1512
00:56:50,400 --> 00:56:52,960
that most field based protocols already

1513
00:56:52,960 --> 00:56:55,119
also work over two because that's a

1514
00:56:55,119 --> 00:56:58,160
particular field

1515
00:56:58,160 --> 00:56:59,920
right so there is a lot of work in in

1516
00:56:59,920 --> 00:57:01,680
this direction again npc dishonest

1517
00:57:01,680 --> 00:57:04,480
majority over rings

1518
00:57:04,480 --> 00:57:09,040
and this is exactly where work fits into

1519
00:57:09,200 --> 00:57:11,680
so let me tell you briefly about what

1520
00:57:11,680 --> 00:57:13,280
this work is about

1521
00:57:13,280 --> 00:57:15,280
so we present yet another dishonest

1522
00:57:15,280 --> 00:57:19,920
majority mpc protocol over this ring

1523
00:57:19,920 --> 00:57:21,920
and the features of our protocol is that

1524
00:57:21,920 --> 00:57:24,559
it has a good communication tradeoffs

1525
00:57:24,559 --> 00:57:26,720
with respect to previous works so i say

1526
00:57:26,720 --> 00:57:28,400
good communication trade-offs and not

1527
00:57:28,400 --> 00:57:31,200
just better communication because not in

1528
00:57:31,200 --> 00:57:32,400
all settings we achieve better

1529
00:57:32,400 --> 00:57:34,480
communication i think topically we do

1530
00:57:34,480 --> 00:57:36,240
but depending on the constants sometimes

1531
00:57:36,240 --> 00:57:37,520
we don't but like i'm going to discuss

1532
00:57:37,520 --> 00:57:39,599
this in a moment

1533
00:57:39,599 --> 00:57:41,599
and there are three main technical

1534
00:57:41,599 --> 00:57:43,839
insights i will say in this work

1535
00:57:43,839 --> 00:57:44,640
so

1536
00:57:44,640 --> 00:57:46,799
there is this concept of galwa rings

1537
00:57:46,799 --> 00:57:48,720
which i'm going to explain later

1538
00:57:48,720 --> 00:57:51,280
they pop up in

1539
00:57:51,280 --> 00:57:53,599
in honest majority in pc a lot and this

1540
00:57:53,599 --> 00:57:55,200
is the first time we use it in the

1541
00:57:55,200 --> 00:57:57,200
disconnected majority scenario

1542
00:57:57,200 --> 00:58:00,160
and there is also the concept of reverse

1543
00:58:00,160 --> 00:58:02,400
multiplication friendly embeddings or

1544
00:58:02,400 --> 00:58:05,839
rmfs which again have popped up a lot in

1545
00:58:05,839 --> 00:58:08,000
honest majority and like this is also

1546
00:58:08,000 --> 00:58:09,040
the first time we use them in the

1547
00:58:09,040 --> 00:58:10,480
dishonest majority to explore their

1548
00:58:10,480 --> 00:58:12,000
benefits

1549
00:58:12,000 --> 00:58:13,760
and i'm mentioning that we don't require

1550
00:58:13,760 --> 00:58:15,839
certain green coding rounds so we use

1551
00:58:15,839 --> 00:58:17,280
them in a clever way with respect to

1552
00:58:17,280 --> 00:58:18,640
previous work

1553
00:58:18,640 --> 00:58:20,559
in a more clever way that allows us to

1554
00:58:20,559 --> 00:58:22,559
get better performance at won't be able

1555
00:58:22,559 --> 00:58:24,000
to discuss the details of that but like

1556
00:58:24,000 --> 00:58:26,319
i just wanted to highlight

1557
00:58:26,319 --> 00:58:27,599
and then finally i think this is

1558
00:58:27,599 --> 00:58:29,920
particularly relevant we use so there

1559
00:58:29,920 --> 00:58:31,599
are reverse multiplication plan friendly

1560
00:58:31,599 --> 00:58:34,400
embeddings which are the rmps but prior

1561
00:58:34,400 --> 00:58:36,880
to watermark fees there were the mfps

1562
00:58:36,880 --> 00:58:39,040
which are well known reverse ones i'm

1563
00:58:39,040 --> 00:58:41,040
going to explain the difference later

1564
00:58:41,040 --> 00:58:43,520
and they actually weren't using npc so

1565
00:58:43,520 --> 00:58:46,079
much we do use them

1566
00:58:46,079 --> 00:58:48,240
we find an application for them to

1567
00:58:48,240 --> 00:58:50,720
instantiate oblivious linear evaluation

1568
00:58:50,720 --> 00:58:53,359
over ring extensions so typically all e

1569
00:58:53,359 --> 00:58:56,079
is instantiated over integers modulo 2

1570
00:58:56,079 --> 00:58:58,079
which is called or integers multiple

1571
00:58:58,079 --> 00:59:00,480
prime oriented smaller just decay but

1572
00:59:00,480 --> 00:59:03,839
not over extensions so polynomials so we

1573
00:59:03,839 --> 00:59:06,160
show an application of mphs

1574
00:59:06,160 --> 00:59:06,880
that

1575
00:59:06,880 --> 00:59:09,200
allow us to get oily over ring

1576
00:59:09,200 --> 00:59:10,720
extensions

1577
00:59:10,720 --> 00:59:13,520
while using only over the base ring with

1578
00:59:13,520 --> 00:59:15,119
a communication complexity or with a

1579
00:59:15,119 --> 00:59:16,720
number of falls to the underlying only

1580
00:59:16,720 --> 00:59:18,720
functionality that is not quadratic in

1581
00:59:18,720 --> 00:59:20,640
the extension degree i'm going to get to

1582
00:59:20,640 --> 00:59:23,520
that in a moment

1583
00:59:23,520 --> 00:59:26,000
right so i also want to mention that

1584
00:59:26,000 --> 00:59:27,200
our protocol

1585
00:59:27,200 --> 00:59:29,200
unlike the prior switch to k and

1586
00:59:29,200 --> 00:59:32,559
derivatives also works for k equal to 1.

1587
00:59:32,559 --> 00:59:34,799
not all works do this like for example

1588
00:59:34,799 --> 00:59:36,319
speed2k does not because the

1589
00:59:36,319 --> 00:59:38,480
preprocessing requires k to be at least

1590
00:59:38,480 --> 00:59:40,319
a security parameter which is fine for

1591
00:59:40,319 --> 00:59:41,839
several

1592
00:59:41,839 --> 00:59:45,040
use cases k equals 64 or k equal to 178

1593
00:59:45,040 --> 00:59:47,280
but our work

1594
00:59:47,280 --> 00:59:49,680
also enables the case of k plus one and

1595
00:59:49,680 --> 00:59:51,520
moreover as i will discuss in a moment

1596
00:59:51,520 --> 00:59:54,319
our protocol is general it's like 2k for

1597
00:59:54,319 --> 00:59:57,440
any k and we improve over particles that

1598
00:59:57,440 --> 00:59:59,359
are specifically designed for the case

1599
00:59:59,359 --> 01:00:02,319
of a k plus one

1600
01:00:02,960 --> 01:00:05,200
so let's discuss a little bit the

1601
01:00:05,200 --> 01:00:07,520
communication complexity this big table

1602
01:00:07,520 --> 01:00:09,440
i'm showing here all the communications

1603
01:00:09,440 --> 01:00:10,960
are divided by n

1604
01:00:10,960 --> 01:00:12,640
times n minus one all of them share the

1605
01:00:12,640 --> 01:00:15,119
same factor so let's discuss

1606
01:00:15,119 --> 01:00:16,720
this for now it's the offline phase that

1607
01:00:16,720 --> 01:00:18,480
i'm discussing here

1608
01:00:18,480 --> 01:00:20,960
so let me guide you a little bit

1609
01:00:20,960 --> 01:00:22,000
so we see

1610
01:00:22,000 --> 01:00:23,520
two things i want to show you here first

1611
01:00:23,520 --> 01:00:26,000
our constants are large

1612
01:00:26,000 --> 01:00:28,000
and this is something that that may

1613
01:00:28,000 --> 01:00:30,799
impact your eye a bit but the

1614
01:00:30,799 --> 01:00:31,760
interesting thing at least

1615
01:00:31,760 --> 01:00:33,760
asymptotically is that our offline phase

1616
01:00:33,760 --> 01:00:36,160
with respect to that of speeds to k

1617
01:00:36,160 --> 01:00:38,880
doesn't have an overhead in the security

1618
01:00:38,880 --> 01:00:40,480
parameter s

1619
01:00:40,480 --> 01:00:42,160
so our offline phase is independent of

1620
01:00:42,160 --> 01:00:44,720
the security parameter

1621
01:00:44,720 --> 01:00:48,160
and if we instantiate for example with s

1622
01:00:48,160 --> 01:00:49,680
equal to 64

1623
01:00:49,680 --> 01:00:51,599
well we get this expression so by the

1624
01:00:51,599 --> 01:00:53,280
way you can see that our constant here

1625
01:00:53,280 --> 01:00:55,440
lowers from 8000 to 5000 thousand i'm

1626
01:00:55,440 --> 01:00:57,599
gonna explain why later is because this

1627
01:00:57,599 --> 01:00:59,280
is the worst case constant you can

1628
01:00:59,280 --> 01:01:01,440
choose but in some concrete cases like s

1629
01:01:01,440 --> 01:01:03,359
e equal to 64 turns out we can improve

1630
01:01:03,359 --> 01:01:04,960
the constant

1631
01:01:04,960 --> 01:01:06,160
um

1632
01:01:06,160 --> 01:01:08,079
and and in this case if we choose for

1633
01:01:08,079 --> 01:01:10,960
example k equal to 32 and you do the

1634
01:01:10,960 --> 01:01:12,400
math here

1635
01:01:12,400 --> 01:01:14,480
it turns out that our purple will use

1636
01:01:14,480 --> 01:01:16,960
around 3 4 the communication of speeds

1637
01:01:16,960 --> 01:01:20,079
to k and asymptotically if the security

1638
01:01:20,079 --> 01:01:21,839
parameter increases our improvement will

1639
01:01:21,839 --> 01:01:23,280
be better so that's what i'm saying

1640
01:01:23,280 --> 01:01:24,720
asymptotically

1641
01:01:24,720 --> 01:01:26,720
we have an improvement and for concrete

1642
01:01:26,720 --> 01:01:28,720
contents it depends well on your

1643
01:01:28,720 --> 01:01:30,400
particular scenario

1644
01:01:30,400 --> 01:01:32,960
and for the case of k equal to one where

1645
01:01:32,960 --> 01:01:34,400
we have this work by kaskuda and

1646
01:01:34,400 --> 01:01:36,319
wooderson

1647
01:01:36,319 --> 01:01:39,040
their offline phase it has this number

1648
01:01:39,040 --> 01:01:41,040
of bits in communication l is certain

1649
01:01:41,040 --> 01:01:43,119
parameter that um we'll get into detail

1650
01:01:43,119 --> 01:01:44,480
but like is is proportional to the

1651
01:01:44,480 --> 01:01:46,400
security parameter

1652
01:01:46,400 --> 01:01:49,040
and our communication complexity in this

1653
01:01:49,040 --> 01:01:51,280
case when you instantiate

1654
01:01:51,280 --> 01:01:52,960
right here we secure the parameter is 64

1655
01:01:52,960 --> 01:01:55,039
when you instantiate k equal to one when

1656
01:01:55,039 --> 01:01:56,880
you plot this and put it to one it's

1657
01:01:56,880 --> 01:02:00,480
around half the communication complexity

1658
01:02:00,480 --> 01:02:02,160
so we do have this asymptotic and

1659
01:02:02,160 --> 01:02:04,559
concrete improvements as well

1660
01:02:04,559 --> 01:02:07,680
this is for the offline phase

1661
01:02:07,680 --> 01:02:09,200
uh for the online phase we have a

1662
01:02:09,200 --> 01:02:11,280
similar table now the communication is

1663
01:02:11,280 --> 01:02:12,960
linearly divided by n minus one

1664
01:02:12,960 --> 01:02:15,839
everything is divided by a minus one

1665
01:02:15,839 --> 01:02:16,799
and

1666
01:02:16,799 --> 01:02:20,240
again i the main insight here is that we

1667
01:02:20,240 --> 01:02:22,240
don't need to pay this

1668
01:02:22,240 --> 01:02:24,400
complexity on the security parameter our

1669
01:02:24,400 --> 01:02:26,319
communication complexity is a constant

1670
01:02:26,319 --> 01:02:28,240
smaller constant this time

1671
01:02:28,240 --> 01:02:30,640
that does not depend on s so that's the

1672
01:02:30,640 --> 01:02:32,240
the main insight and again it depends if

1673
01:02:32,240 --> 01:02:33,839
s is very small maybe our protocol

1674
01:02:33,839 --> 01:02:35,359
doesn't benefit you that much but if you

1675
01:02:35,359 --> 01:02:36,960
secure the parameter the statistical

1676
01:02:36,960 --> 01:02:38,640
security parameter is large

1677
01:02:38,640 --> 01:02:40,480
then your protocol will provide some

1678
01:02:40,480 --> 01:02:43,520
benefit so for s equal to 64 for example

1679
01:02:43,520 --> 01:02:45,760
it turns out we can lower the constant

1680
01:02:45,760 --> 01:02:49,520
from 19 uh to roughly 12

1681
01:02:49,520 --> 01:02:52,160
and in this case for example if s is

1682
01:02:52,160 --> 01:02:54,480
equal to 64 and k is 32 so if your

1683
01:02:54,480 --> 01:02:56,960
computation is over 32 bit integers

1684
01:02:56,960 --> 01:02:58,799
we have around the same complexity as

1685
01:02:58,799 --> 01:03:01,200
splits to k but if now you have smaller

1686
01:03:01,200 --> 01:03:04,079
integers then after equal will be almost

1687
01:03:04,079 --> 01:03:06,640
half the communication for black fields

1688
01:03:06,640 --> 01:03:09,359
again it depends on the setting

1689
01:03:09,359 --> 01:03:11,520
and i want to mention here that for

1690
01:03:11,520 --> 01:03:13,520
binary computation

1691
01:03:13,520 --> 01:03:15,039
you can see that our purple has a

1692
01:03:15,039 --> 01:03:17,680
constant for example for 64 bits our

1693
01:03:17,680 --> 01:03:22,279
protocol has a constant of 12.84

1694
01:03:22,720 --> 01:03:24,559
k which if k is equal to one is just

1695
01:03:24,559 --> 01:03:26,960
12.4 because kudo at all is slightly

1696
01:03:26,960 --> 01:03:29,520
smaller but as i hopefully i don't think

1697
01:03:29,520 --> 01:03:30,960
i will be able to discuss this but i

1698
01:03:30,960 --> 01:03:32,400
won't say that our protocol is much

1699
01:03:32,400 --> 01:03:34,720
simpler and it has fewer rounds all of

1700
01:03:34,720 --> 01:03:36,559
them are rounds probably have rounds

1701
01:03:36,559 --> 01:03:37,839
proportional to the depth of the circuit

1702
01:03:37,839 --> 01:03:41,839
but ours is half the amount

1703
01:03:42,839 --> 01:03:45,920
of so with this i think it's about time

1704
01:03:45,920 --> 01:03:47,920
to get to the technical details

1705
01:03:47,920 --> 01:03:51,359
at least a part of them

1706
01:03:51,760 --> 01:03:53,359
so let me start by

1707
01:03:53,359 --> 01:03:55,039
saying what a galwaring is i've been

1708
01:03:55,039 --> 01:03:56,880
mentioning this for a while and i think

1709
01:03:56,880 --> 01:03:58,960
it's useful of course to describe it in

1710
01:03:58,960 --> 01:04:01,599
detail this have popped up already a lot

1711
01:04:01,599 --> 01:04:04,240
in in other settings like distributed

1712
01:04:04,240 --> 01:04:05,920
signals proofs over

1713
01:04:05,920 --> 01:04:08,240
its rings they also appear these type of

1714
01:04:08,240 --> 01:04:10,079
ring extensions or they also print the

1715
01:04:10,079 --> 01:04:11,520
honest majority scenario a lot to

1716
01:04:11,520 --> 01:04:13,440
instantiate some musical sharing they

1717
01:04:13,440 --> 01:04:15,440
have different uses

1718
01:04:15,440 --> 01:04:16,160
so

1719
01:04:16,160 --> 01:04:18,559
a galore ring is nothing more than a

1720
01:04:18,559 --> 01:04:20,480
generalization of a volatile extension

1721
01:04:20,480 --> 01:04:22,880
so it's a degree the extension of of the

1722
01:04:22,880 --> 01:04:24,319
base ring that we're denoting here by

1723
01:04:24,319 --> 01:04:25,599
c20k

1724
01:04:25,599 --> 01:04:27,520
and this is going to be the notation i'm

1725
01:04:27,520 --> 01:04:29,680
going to use onwards r

1726
01:04:29,680 --> 01:04:31,599
for the extension ring

1727
01:04:31,599 --> 01:04:33,680
where it's a quotient ring where f of x

1728
01:04:33,680 --> 01:04:35,599
is the degree the irreducible polynomial

1729
01:04:35,599 --> 01:04:38,240
over c 2 to the k like it's like a field

1730
01:04:38,240 --> 01:04:41,359
extension but like now it's a little bit

1731
01:04:41,359 --> 01:04:42,559
so

1732
01:04:42,559 --> 01:04:44,319
we are the first ones in giving them

1733
01:04:44,319 --> 01:04:45,920
some use in the dishonest setting as i

1734
01:04:45,920 --> 01:04:47,200
was mentioning and

1735
01:04:47,200 --> 01:04:49,839
the main property of these rings that we

1736
01:04:49,839 --> 01:04:51,200
care about

1737
01:04:51,200 --> 01:04:53,760
is is the following so

1738
01:04:53,760 --> 01:04:55,599
i'm there are many ways of describing

1739
01:04:55,599 --> 01:04:57,039
this property but i'm describing like

1740
01:04:57,039 --> 01:04:58,000
this

1741
01:04:58,000 --> 01:04:59,680
and it says the following if you give me

1742
01:04:59,680 --> 01:05:02,160
a uniformly random

1743
01:05:02,160 --> 01:05:04,480
element in the ring outcome

1744
01:05:04,480 --> 01:05:06,160
and you choose whatever you want to

1745
01:05:06,160 --> 01:05:08,240
choose as long as it's independent of

1746
01:05:08,240 --> 01:05:10,640
alpha delta and epsilon in the ring

1747
01:05:10,640 --> 01:05:12,720
where delta is non-zero then the

1748
01:05:12,720 --> 01:05:14,400
probability that this equation is

1749
01:05:14,400 --> 01:05:16,160
satisfied

1750
01:05:16,160 --> 01:05:18,240
is upper bounded by two to the minus the

1751
01:05:18,240 --> 01:05:21,119
degree d is the degree of the extension

1752
01:05:21,119 --> 01:05:23,680
so this way if you choose the degree of

1753
01:05:23,680 --> 01:05:26,880
the extension to be 40 bit like 40 then

1754
01:05:26,880 --> 01:05:28,400
you can get a security statistical

1755
01:05:28,400 --> 01:05:30,319
security of 40 bits because this

1756
01:05:30,319 --> 01:05:32,079
ultimately will be reflected in

1757
01:05:32,079 --> 01:05:34,960
statistical security

1758
01:05:34,960 --> 01:05:36,960
so so that's very good and indeed this

1759
01:05:36,960 --> 01:05:39,119
property as it stands as i'm showing you

1760
01:05:39,119 --> 01:05:40,319
right there you can just go and pick

1761
01:05:40,319 --> 01:05:42,240
your favorite field based protocol and

1762
01:05:42,240 --> 01:05:44,640
pretty much use this

1763
01:05:44,640 --> 01:05:46,319
and this is the property that is

1764
01:05:46,319 --> 01:05:47,520
underlying all those protocols it's not

1765
01:05:47,520 --> 01:05:49,280
even about invertibility of elements is

1766
01:05:49,280 --> 01:05:50,799
that this type of equations hold below

1767
01:05:50,799 --> 01:05:52,240
probability

1768
01:05:52,240 --> 01:05:53,200
and

1769
01:05:53,200 --> 01:05:55,119
by using this property you can get mpc

1770
01:05:55,119 --> 01:05:55,920
over

1771
01:05:55,920 --> 01:05:58,960
r if if it interests you to use mpc or r

1772
01:05:58,960 --> 01:06:00,319
for some reason you can get mpg over r

1773
01:06:00,319 --> 01:06:02,240
by using this property following the

1774
01:06:02,240 --> 01:06:04,240
templates that previous work have done

1775
01:06:04,240 --> 01:06:06,079
the template i'm showing it here at a

1776
01:06:06,079 --> 01:06:08,640
very high level is secret sharing an

1777
01:06:08,640 --> 01:06:10,000
element but of course this time you're

1778
01:06:10,000 --> 01:06:11,599
going to use

1779
01:06:11,599 --> 01:06:12,720
with max and you're going to use it for

1780
01:06:12,720 --> 01:06:14,400
sharing with mac so this is roughly how

1781
01:06:14,400 --> 01:06:16,640
they look i'm also making use of this

1782
01:06:16,640 --> 01:06:17,760
light to introduce introducing notation

1783
01:06:17,760 --> 01:06:19,039
by the way this is going to be angle

1784
01:06:19,039 --> 01:06:20,319
bracket of x is going to be

1785
01:06:20,319 --> 01:06:22,400
authenticated secret shares of a vector

1786
01:06:22,400 --> 01:06:24,480
sorry not a vector of a

1787
01:06:24,480 --> 01:06:26,960
ring element

1788
01:06:26,960 --> 01:06:28,960
i think i want to mute it and

1789
01:06:28,960 --> 01:06:31,680
use them okay so so and and this is

1790
01:06:31,680 --> 01:06:32,799
going to be additive secretion in the

1791
01:06:32,799 --> 01:06:34,880
square brackets so by

1792
01:06:34,880 --> 01:06:36,319
using this type of secret sharing you

1793
01:06:36,319 --> 01:06:37,839
can get additions for free they are

1794
01:06:37,839 --> 01:06:38,799
local

1795
01:06:38,799 --> 01:06:40,799
you can pre-process b or triple for

1796
01:06:40,799 --> 01:06:42,559
multiplication triples for handling

1797
01:06:42,559 --> 01:06:44,480
multiplications which only require

1798
01:06:44,480 --> 01:06:47,119
openings you can use the arcmap

1799
01:06:47,119 --> 01:06:48,960
the algebraic manipulation detection

1800
01:06:48,960 --> 01:06:50,799
code which is basically this sponsor

1801
01:06:50,799 --> 01:06:52,079
name for this thing i'm just describing

1802
01:06:52,079 --> 01:06:52,960
here

1803
01:06:52,960 --> 01:06:55,119
you can use this for verifying that the

1804
01:06:55,119 --> 01:06:57,200
openings are done correctly

1805
01:06:57,200 --> 01:06:59,039
and this is a template automatically

1806
01:06:59,039 --> 01:07:01,359
give you mpc over r

1807
01:07:01,359 --> 01:07:02,880
but we don't care about mpg over r we

1808
01:07:02,880 --> 01:07:05,039
care about npc over c2 to the k which is

1809
01:07:05,039 --> 01:07:06,880
the base rank so

1810
01:07:06,880 --> 01:07:10,400
how do we move from one to the other

1811
01:07:11,039 --> 01:07:13,119
so there's a trivial way of doing it

1812
01:07:13,119 --> 01:07:15,520
which is if you have

1813
01:07:15,520 --> 01:07:17,839
if you notice r is an extension ring

1814
01:07:17,839 --> 01:07:19,280
which basically elements in r are

1815
01:07:19,280 --> 01:07:20,799
polynomials

1816
01:07:20,799 --> 01:07:22,640
of certain bounded degree

1817
01:07:22,640 --> 01:07:24,160
so

1818
01:07:24,160 --> 01:07:26,720
you can obtain npc over the base rank if

1819
01:07:26,720 --> 01:07:29,359
you simply consider constant polynomials

1820
01:07:29,359 --> 01:07:32,240
or in other words a bit more a formal

1821
01:07:32,240 --> 01:07:34,400
the ring city to the k is a sub ring of

1822
01:07:34,400 --> 01:07:36,400
r so if you get mp over r you

1823
01:07:36,400 --> 01:07:39,760
automatically get mpg over c2 to the k

1824
01:07:39,760 --> 01:07:41,280
right so you can just consider them to

1825
01:07:41,280 --> 01:07:42,640
be constant polynomials and you can get

1826
01:07:42,640 --> 01:07:44,160
in pc over r

1827
01:07:44,160 --> 01:07:45,760
or over c2 to the k

1828
01:07:45,760 --> 01:07:47,760
but the problem of this is that this was

1829
01:07:47,760 --> 01:07:49,599
this will be wasteful very wasteful in

1830
01:07:49,599 --> 01:07:51,760
terms of communication we don't want

1831
01:07:51,760 --> 01:07:53,520
this because for every single ring

1832
01:07:53,520 --> 01:07:56,240
element you are considered a very large

1833
01:07:56,240 --> 01:07:58,799
uh field uh for every single base

1834
01:07:58,799 --> 01:07:59,760
running gallon and you're considered a

1835
01:07:59,760 --> 01:08:02,319
very large polynomial

1836
01:08:02,319 --> 01:08:04,319
so to avoid this

1837
01:08:04,319 --> 01:08:06,079
is uh

1838
01:08:06,079 --> 01:08:08,640
rmf's come to the rescue to precisely

1839
01:08:08,640 --> 01:08:10,960
avoid this technical

1840
01:08:10,960 --> 01:08:13,599
so what is an rmrv it's a pair of

1841
01:08:13,599 --> 01:08:15,599
functions that map

1842
01:08:15,599 --> 01:08:18,719
vectors of base string elements

1843
01:08:18,719 --> 01:08:19,439
to

1844
01:08:19,439 --> 01:08:21,279
polynomials so to speak

1845
01:08:21,279 --> 01:08:23,120
and another function that maps them back

1846
01:08:23,120 --> 01:08:25,198
polynomials two vectors

1847
01:08:25,198 --> 01:08:26,960
such that

1848
01:08:26,960 --> 01:08:28,799
this is the main equation we have to to

1849
01:08:28,799 --> 01:08:31,120
to remember it's a basically says if you

1850
01:08:31,120 --> 01:08:33,359
take a vector and map it to a ring

1851
01:08:33,359 --> 01:08:34,319
element

1852
01:08:34,319 --> 01:08:35,520
and you take another vector and map it

1853
01:08:35,520 --> 01:08:37,279
to a ring element and you multiply them

1854
01:08:37,279 --> 01:08:38,960
as ring elements

1855
01:08:38,960 --> 01:08:41,679
and you map them back to vectors

1856
01:08:41,679 --> 01:08:43,600
you get the component wise product this

1857
01:08:43,600 --> 01:08:45,520
is what these a star is an open you get

1858
01:08:45,520 --> 01:08:46,799
the component and y is product of the

1859
01:08:46,799 --> 01:08:49,198
two vectors that's what an rmap is for

1860
01:08:49,198 --> 01:08:51,679
and at a high level what it enables now

1861
01:08:51,679 --> 01:08:54,238
is that a you can do by using

1862
01:08:54,238 --> 01:08:55,759
multiplication over r which is what's

1863
01:08:55,759 --> 01:08:57,359
happening in here

1864
01:08:57,359 --> 01:08:58,880
you can get

1865
01:08:58,880 --> 01:09:00,960
l simultaneous computations over the

1866
01:09:00,960 --> 01:09:02,719
base rank that's what's happening it's

1867
01:09:02,719 --> 01:09:05,198
giving you companies voice product or

1868
01:09:05,198 --> 01:09:07,040
sure product which is essentially many

1869
01:09:07,040 --> 01:09:09,439
parallel computations over l over c

1870
01:09:09,439 --> 01:09:11,198
rookie

1871
01:09:11,198 --> 01:09:13,120
and it turns out that you can choose d

1872
01:09:13,120 --> 01:09:14,158
to be

1873
01:09:14,158 --> 01:09:17,759
a constant a factor of l

1874
01:09:17,759 --> 01:09:20,319
so basically by encoding a constant

1875
01:09:20,319 --> 01:09:22,799
factor larger you take your

1876
01:09:22,799 --> 01:09:24,319
vector and you encode them in a constant

1877
01:09:24,319 --> 01:09:26,960
factor larger a polynomial

1878
01:09:26,960 --> 01:09:29,759
polynomial element you can instantiate

1879
01:09:29,759 --> 01:09:31,120
element wise

1880
01:09:31,120 --> 01:09:34,640
computation over the original vector so

1881
01:09:34,640 --> 01:09:37,359
this is essentially the tool we use

1882
01:09:37,359 --> 01:09:40,560
and if

1883
01:09:40,880 --> 01:09:42,880
i do want to mention

1884
01:09:42,880 --> 01:09:44,560
briefly here the way that we encode

1885
01:09:44,560 --> 01:09:46,080
vectors

1886
01:09:46,080 --> 01:09:47,839
i don't think we need to to worry so

1887
01:09:47,839 --> 01:09:49,279
much about the details i just want to

1888
01:09:49,279 --> 01:09:51,920
mention that you can use rmfps with that

1889
01:09:51,920 --> 01:09:54,400
technique that was proposed uh

1890
01:09:54,400 --> 01:09:56,400
one of our papers in a spotlight all in

1891
01:09:56,400 --> 01:09:57,840
asia last year

1892
01:09:57,840 --> 01:09:59,440
and that was in the honest majority

1893
01:09:59,440 --> 01:10:01,120
setting but here we use it in the

1894
01:10:01,120 --> 01:10:02,719
chinese majority scenario so that's the

1895
01:10:02,719 --> 01:10:04,719
way you will encode elements

1896
01:10:04,719 --> 01:10:06,480
and it turns out that this gives you mpc

1897
01:10:06,480 --> 01:10:08,719
for parallel executions

1898
01:10:08,719 --> 01:10:10,400
the encoding exactly is not relevant for

1899
01:10:10,400 --> 01:10:11,679
the discussion i just want to mention

1900
01:10:11,679 --> 01:10:12,640
that

1901
01:10:12,640 --> 01:10:14,000
that's what we use

1902
01:10:14,000 --> 01:10:16,080
and another fact from that paper which

1903
01:10:16,080 --> 01:10:17,760
can be translated to the dishonest

1904
01:10:17,760 --> 01:10:19,760
majority setting is that

1905
01:10:19,760 --> 01:10:22,239
if you have certain printables it's not

1906
01:10:22,239 --> 01:10:23,760
multiplication triples anymore it's

1907
01:10:23,760 --> 01:10:25,280
going to be a much more complex data

1908
01:10:25,280 --> 01:10:26,640
structure but if you have certain key

1909
01:10:26,640 --> 01:10:27,679
intervals

1910
01:10:27,679 --> 01:10:31,280
which look like this so they are a b

1911
01:10:31,280 --> 01:10:32,880
and then you apply this function that

1912
01:10:32,880 --> 01:10:34,480
turns out to be a mapping that goes from

1913
01:10:34,480 --> 01:10:37,520
r to r so if you apply this function to

1914
01:10:37,520 --> 01:10:39,199
a and this function to b you have you're

1915
01:10:39,199 --> 01:10:40,960
supposed to have sharings of those

1916
01:10:40,960 --> 01:10:42,719
and then sharings of the product of

1917
01:10:42,719 --> 01:10:44,400
these two

1918
01:10:44,400 --> 01:10:46,239
if you have a quintuple that looks like

1919
01:10:46,239 --> 01:10:47,040
this

1920
01:10:47,040 --> 01:10:49,360
you can do a secure multiplication in

1921
01:10:49,360 --> 01:10:52,880
this new encoding or this new parallel

1922
01:10:52,880 --> 01:10:55,520
computation scenario in just one round

1923
01:10:55,520 --> 01:10:57,199
in contrast to previous works that do it

1924
01:10:57,199 --> 01:10:58,719
into routes so

1925
01:10:58,719 --> 01:10:59,840
just want to highlight this is the way

1926
01:10:59,840 --> 01:11:00,960
we do it

1927
01:11:00,960 --> 01:11:03,040
um and it mostly comes from this

1928
01:11:03,040 --> 01:11:04,239
previous work

1929
01:11:04,239 --> 01:11:07,120
so this already kind of gives us npc if

1930
01:11:07,120 --> 01:11:09,360
if you have these skin tables that i'm

1931
01:11:09,360 --> 01:11:12,880
not showing how to get uh and then we

1932
01:11:12,880 --> 01:11:15,280
follow the template and we compute the

1933
01:11:15,280 --> 01:11:16,719
the communication complexity that i

1934
01:11:16,719 --> 01:11:18,880
already described

1935
01:11:18,880 --> 01:11:19,990
okay so

1936
01:11:19,990 --> 01:11:21,760
[Music]

1937
01:11:21,760 --> 01:11:23,600
i think i just wanted to

1938
01:11:23,600 --> 01:11:24,800
i have something to show but like i

1939
01:11:24,800 --> 01:11:26,719
think it's the last thing i want to

1940
01:11:26,719 --> 01:11:29,120
mention is how we get oily

1941
01:11:29,120 --> 01:11:30,480
i'm not mentioning why we need it but it

1942
01:11:30,480 --> 01:11:32,480
turns out we need oily over the

1943
01:11:32,480 --> 01:11:35,199
extension ring

1944
01:11:35,440 --> 01:11:36,800
so a

1945
01:11:36,800 --> 01:11:39,840
in ole is just basically one party has a

1946
01:11:39,840 --> 01:11:42,239
and b and the other one has x they are

1947
01:11:42,239 --> 01:11:44,400
over the extension ring and they want to

1948
01:11:44,400 --> 01:11:45,280
obtain

1949
01:11:45,280 --> 01:11:49,280
y equal to a a times x plus b

1950
01:11:49,840 --> 01:11:51,360
and i'm going with this i'm just going

1951
01:11:51,360 --> 01:11:53,440
to show you the the protocol how we get

1952
01:11:53,440 --> 01:11:54,719
it

1953
01:11:54,719 --> 01:11:57,360
so in the protocol we use mfes it's not

1954
01:11:57,360 --> 01:12:00,880
that our anarchy is mfp so the detail

1955
01:12:00,880 --> 01:12:03,040
the details of an mfp is this is the

1956
01:12:03,040 --> 01:12:05,360
equation it's similar to an rmp but this

1957
01:12:05,360 --> 01:12:08,400
time we map ring elements to vectors

1958
01:12:08,400 --> 01:12:10,880
multiply component-wise vectors and then

1959
01:12:10,880 --> 01:12:14,560
map them back to ring multiplication

1960
01:12:14,560 --> 01:12:17,040
rmfs exist we can construct them sorry

1961
01:12:17,040 --> 01:12:19,040
mfps exist and so on

1962
01:12:19,040 --> 01:12:21,440
and it turns out this is the main slide

1963
01:12:21,440 --> 01:12:22,640
i mentioned this because this may be

1964
01:12:22,640 --> 01:12:23,760
useful in other settings if you're

1965
01:12:23,760 --> 01:12:25,040
interested in using all the over

1966
01:12:25,040 --> 01:12:27,920
extension fields

1967
01:12:28,000 --> 01:12:28,800
so

1968
01:12:28,800 --> 01:12:30,400
anyway what's happening here that you're

1969
01:12:30,400 --> 01:12:33,040
mapping vectors

1970
01:12:33,040 --> 01:12:35,040
you're mapping ring elements to vectors

1971
01:12:35,040 --> 01:12:36,800
doing all the over the vectors mapping

1972
01:12:36,800 --> 01:12:38,880
them back to green diamond for the

1973
01:12:38,880 --> 01:12:40,000
interest of time i don't think i would

1974
01:12:40,000 --> 01:12:42,159
be able to to continue this but

1975
01:12:42,159 --> 01:12:44,000
basically

1976
01:12:44,000 --> 01:12:45,360
um

1977
01:12:45,360 --> 01:12:46,800
this i didn't plan to present this

1978
01:12:46,800 --> 01:12:47,760
anyway

1979
01:12:47,760 --> 01:12:49,440
so

1980
01:12:49,440 --> 01:12:50,800
these are some future directions i would

1981
01:12:50,800 --> 01:12:53,040
like to for you to think about i won't

1982
01:12:53,040 --> 01:12:54,640
listen but like you can find the slides

1983
01:12:54,640 --> 01:12:57,440
online and

1984
01:12:57,440 --> 01:13:02,040
with this i would like to thank you

1985
01:13:07,520 --> 01:13:09,679
all right for interest of making it to

1986
01:13:09,679 --> 01:13:11,360
the invited talking time unfortunately

1987
01:13:11,360 --> 01:13:13,760
there's no time for questions um so

1988
01:13:13,760 --> 01:13:15,280
let's thank all the speakers in this

1989
01:13:15,280 --> 01:13:18,280
session

