1
00:00:00,080 --> 00:00:02,960
knowledge session um everyone the first

2
00:00:02,960 --> 00:00:04,799
talk of the session

3
00:00:04,799 --> 00:00:05,759
is

4
00:00:05,759 --> 00:00:07,440
by tian singh

5
00:00:07,440 --> 00:00:09,440
and it's going to be an orion a zero

6
00:00:09,440 --> 00:00:14,040
knowledge proof with linear prover time

7
00:00:19,520 --> 00:00:22,320
okay thanks chair for the introduction

8
00:00:22,320 --> 00:00:25,119
and i'm teen chancellor from uc berkeley

9
00:00:25,119 --> 00:00:27,439
and i'm going to present oriole

10
00:00:27,439 --> 00:00:29,279
generally proof with linear approval

11
00:00:29,279 --> 00:00:32,000
time this is joined to work with hong

12
00:00:32,000 --> 00:00:35,200
jong and don soon

13
00:00:36,960 --> 00:00:38,559
a general proof

14
00:00:38,559 --> 00:00:40,960
enables approver to

15
00:00:40,960 --> 00:00:43,200
prove some proof some validity of some

16
00:00:43,200 --> 00:00:45,280
statement to the verifier without

17
00:00:45,280 --> 00:00:48,640
nikki's own secret information

18
00:00:48,640 --> 00:00:49,600
and

19
00:00:49,600 --> 00:00:50,879
it mainly

20
00:00:50,879 --> 00:00:53,600
satisfies these three properties

21
00:00:53,600 --> 00:00:57,199
companies sadness and zero knowledge

22
00:00:57,199 --> 00:00:58,879
the accompanies means that honest

23
00:00:58,879 --> 00:01:02,079
proverb can always pass a verification

24
00:01:02,079 --> 00:01:04,400
and soundness means that malicious

25
00:01:04,400 --> 00:01:07,040
approval can only pass verification

26
00:01:07,040 --> 00:01:10,479
with negligible probability

27
00:01:10,479 --> 00:01:12,640
and zero knowledge means that the proof

28
00:01:12,640 --> 00:01:14,479
itself does not need any information

29
00:01:14,479 --> 00:01:17,600
about the secret

30
00:01:19,600 --> 00:01:21,840
and generation proofs actually started

31
00:01:21,840 --> 00:01:22,640
by

32
00:01:22,640 --> 00:01:27,200
government mccarthy and rakov in 1985

33
00:01:27,200 --> 00:01:29,439
and later is followed by kilian and

34
00:01:29,439 --> 00:01:31,280
mikali for

35
00:01:31,280 --> 00:01:32,400
generic

36
00:01:32,400 --> 00:01:34,720
construction

37
00:01:34,720 --> 00:01:36,799
and there are still many

38
00:01:36,799 --> 00:01:40,159
following theoretical works

39
00:01:40,159 --> 00:01:42,240
it's also some of them are also

40
00:01:42,240 --> 00:01:45,600
presented here and since our paper is

41
00:01:45,600 --> 00:01:47,360
mainly focused on a concrete

42
00:01:47,360 --> 00:01:50,479
instantiation so

43
00:01:50,479 --> 00:01:52,640
we will we will for the

44
00:01:52,640 --> 00:01:54,960
rest of work uh the talk we will focus

45
00:01:54,960 --> 00:01:55,920
on this

46
00:01:55,920 --> 00:02:00,159
efficient uh general proof systems

47
00:02:00,719 --> 00:02:02,880
and at 2018

48
00:02:02,880 --> 00:02:05,360
there are many different uh general

49
00:02:05,360 --> 00:02:08,239
proof systems based on bilinear pairing

50
00:02:08,239 --> 00:02:11,200
proposed by these people

51
00:02:11,200 --> 00:02:13,040
and

52
00:02:13,040 --> 00:02:17,360
this works uh may one many focus on

53
00:02:17,360 --> 00:02:19,760
concrete incidentations so they gotta

54
00:02:19,760 --> 00:02:21,120
make out some

55
00:02:21,120 --> 00:02:24,000
trusty setup and all of these works are

56
00:02:24,000 --> 00:02:26,480
actually very fast in practice and some

57
00:02:26,480 --> 00:02:29,920
of them are actually deployed in the

58
00:02:29,920 --> 00:02:32,480
industry

59
00:02:33,200 --> 00:02:34,800
more recently

60
00:02:34,800 --> 00:02:37,360
there are different uh general more

61
00:02:37,360 --> 00:02:39,280
different general proof systems based on

62
00:02:39,280 --> 00:02:40,720
more techniques

63
00:02:40,720 --> 00:02:43,120
such as iop

64
00:02:43,120 --> 00:02:44,400
and

65
00:02:44,400 --> 00:02:45,840
interactive roofs

66
00:02:45,840 --> 00:02:48,000
or

67
00:02:48,000 --> 00:02:51,560
code based proofs

68
00:02:52,239 --> 00:02:54,959
and and npc-based proofs

69
00:02:54,959 --> 00:02:56,480
so

70
00:02:56,480 --> 00:02:58,720
these proofs mainly focus on removing

71
00:02:58,720 --> 00:03:00,080
trusted setup

72
00:03:00,080 --> 00:03:02,159
and have a better scalability of

73
00:03:02,159 --> 00:03:04,640
approval

74
00:03:04,640 --> 00:03:08,080
so what caused the such development of

75
00:03:08,080 --> 00:03:09,519
generality poops

76
00:03:09,519 --> 00:03:11,920
is mainly because there are some

77
00:03:11,920 --> 00:03:13,760
many different

78
00:03:13,760 --> 00:03:16,080
applications of zeolite foods

79
00:03:16,080 --> 00:03:16,840
such

80
00:03:16,840 --> 00:03:19,920
as the application scene

81
00:03:19,920 --> 00:03:22,400
in blockchain it's called dkrobs mainly

82
00:03:22,400 --> 00:03:23,680
focused on

83
00:03:23,680 --> 00:03:26,080
making blockchain more scalable and more

84
00:03:26,080 --> 00:03:28,560
private

85
00:03:29,200 --> 00:03:31,280
and there are some there are many

86
00:03:31,280 --> 00:03:33,760
different startup companies focusing on

87
00:03:33,760 --> 00:03:35,840
these thicker roll-ups which are

88
00:03:35,840 --> 00:03:39,680
spinning of evaluations

89
00:03:41,440 --> 00:03:43,599
and there

90
00:03:43,599 --> 00:03:45,200
still other uh

91
00:03:45,200 --> 00:03:46,959
different

92
00:03:46,959 --> 00:03:48,799
applications

93
00:03:48,799 --> 00:03:50,159
we got

94
00:03:50,159 --> 00:03:51,680
machine learning for

95
00:03:51,680 --> 00:03:53,840
tk machine learning for inference

96
00:03:53,840 --> 00:03:56,080
and technology proof for program

97
00:03:56,080 --> 00:03:57,519
analysis for

98
00:03:57,519 --> 00:03:59,280
secret programs

99
00:03:59,280 --> 00:04:02,319
and more such as dk middle box for

100
00:04:02,319 --> 00:04:05,439
network traffic analysis their call for

101
00:04:05,439 --> 00:04:09,120
jquery oracles and so on

102
00:04:10,480 --> 00:04:12,560
despite all of this the recent

103
00:04:12,560 --> 00:04:14,720
developments however there are still

104
00:04:14,720 --> 00:04:19,120
some challenges on approval overhead

105
00:04:19,120 --> 00:04:21,839
we mainly categorize this

106
00:04:21,839 --> 00:04:23,840
all of these protocols into three

107
00:04:23,840 --> 00:04:25,520
different categories

108
00:04:25,520 --> 00:04:28,000
and for the first one they are based on

109
00:04:28,000 --> 00:04:29,759
fft where

110
00:04:29,759 --> 00:04:32,240
the ffd itself

111
00:04:32,240 --> 00:04:35,840
incurs and not going to blow up

112
00:04:35,840 --> 00:04:37,600
and second category is based on

113
00:04:37,600 --> 00:04:39,759
explanations mainly

114
00:04:39,759 --> 00:04:42,160
multiscale experimentations and such

115
00:04:42,160 --> 00:04:44,560
exponentiation will cause a logarithm

116
00:04:44,560 --> 00:04:46,240
factor too

117
00:04:46,240 --> 00:04:48,960
and there are another line of work where

118
00:04:48,960 --> 00:04:50,400
it does not cause

119
00:04:50,400 --> 00:04:53,280
any uber overhead if you assume that aes

120
00:04:53,280 --> 00:04:56,880
can be done in constant time however

121
00:04:56,880 --> 00:04:58,320
they

122
00:04:58,320 --> 00:05:01,280
they are they are mpc based and

123
00:05:01,280 --> 00:05:02,080
their

124
00:05:02,080 --> 00:05:05,120
proof size is actually linear and

125
00:05:05,120 --> 00:05:09,400
they are not publicly verifiable

126
00:05:12,960 --> 00:05:15,600
there's another line of work where which

127
00:05:15,600 --> 00:05:18,560
they can actually achieve succinct

128
00:05:18,560 --> 00:05:20,639
and scalable proof

129
00:05:20,639 --> 00:05:25,840
it started by the jonathan bruto as 2017

130
00:05:26,000 --> 00:05:28,639
however this works actually they most of

131
00:05:28,639 --> 00:05:30,720
them are theoretical results

132
00:05:30,720 --> 00:05:31,759
and

133
00:05:31,759 --> 00:05:33,360
only gls

134
00:05:33,360 --> 00:05:35,360
21 is

135
00:05:35,360 --> 00:05:38,560
concretely instant shape however this

136
00:05:38,560 --> 00:05:41,039
part this this paper got a sunless

137
00:05:41,039 --> 00:05:43,759
problem the sun is actually is uh one

138
00:05:43,759 --> 00:05:46,240
over party it's not negligible

139
00:05:46,240 --> 00:05:48,400
so

140
00:05:49,600 --> 00:05:51,919
and there there is another line of work

141
00:05:51,919 --> 00:05:54,400
is boolean circuit

142
00:05:54,400 --> 00:05:57,360
which also achieve very efficient linear

143
00:05:57,360 --> 00:05:58,960
time proving

144
00:05:58,960 --> 00:06:01,280
and

145
00:06:05,440 --> 00:06:07,919
however in our work we mainly focus on

146
00:06:07,919 --> 00:06:10,080
arithmetic circuit so

147
00:06:10,080 --> 00:06:12,800
we will continue on on this line of work

148
00:06:12,800 --> 00:06:14,639
astronomical circuit work

149
00:06:14,639 --> 00:06:17,120
and here is our result

150
00:06:17,120 --> 00:06:18,880
so

151
00:06:18,880 --> 00:06:21,440
we propose a new system called orion

152
00:06:21,440 --> 00:06:23,759
and the the approval time is actually

153
00:06:23,759 --> 00:06:26,000
linear here and we achieve

154
00:06:26,000 --> 00:06:29,199
simultaneously we achieve a log square

155
00:06:29,199 --> 00:06:30,800
of proof size

156
00:06:30,800 --> 00:06:34,080
and our sun is improved from one

157
00:06:34,080 --> 00:06:37,120
overpoly to all the way to a negligible

158
00:06:37,120 --> 00:06:39,360
based on a new technique called new

159
00:06:39,360 --> 00:06:42,240
sampling technique

160
00:06:46,479 --> 00:06:48,479
and here is our list of

161
00:06:48,479 --> 00:06:50,560
technical contributions

162
00:06:50,560 --> 00:06:51,680
we

163
00:06:51,680 --> 00:06:54,000
first we build a linear time encoder

164
00:06:54,000 --> 00:06:56,319
bond error credit code based on expander

165
00:06:56,319 --> 00:06:57,520
code

166
00:06:57,520 --> 00:06:59,120
and all previous constructions are

167
00:06:59,120 --> 00:07:01,120
either not practical

168
00:07:01,120 --> 00:07:03,120
or they got a

169
00:07:03,120 --> 00:07:04,720
very huge

170
00:07:04,720 --> 00:07:06,960
non-negligible value probability and

171
00:07:06,960 --> 00:07:10,080
later we build our efficient proof from

172
00:07:10,080 --> 00:07:13,520
our new expander code

173
00:07:13,520 --> 00:07:15,120
based on this uh

174
00:07:15,120 --> 00:07:16,880
so-called

175
00:07:16,880 --> 00:07:18,160
circuit

176
00:07:18,160 --> 00:07:21,280
code switching technique

177
00:07:21,919 --> 00:07:22,880
so

178
00:07:22,880 --> 00:07:24,720
for the rest of the talk we are going to

179
00:07:24,720 --> 00:07:29,080
talk about our technical details

180
00:07:33,680 --> 00:07:37,280
first is the new linear timing codable

181
00:07:37,280 --> 00:07:39,840
error coding code

182
00:07:39,840 --> 00:07:43,440
and so the first question is

183
00:07:43,440 --> 00:07:45,759
why why does xeron improve is related to

184
00:07:45,759 --> 00:07:47,759
the linear timing codable linear uh

185
00:07:47,759 --> 00:07:49,360
arrogant code

186
00:07:49,360 --> 00:07:51,280
sorry why whether this

187
00:07:51,280 --> 00:07:53,280
relative error connection code

188
00:07:53,280 --> 00:07:55,680
so because there are many works

189
00:07:55,680 --> 00:07:56,800
actually

190
00:07:56,800 --> 00:07:58,160
did the following

191
00:07:58,160 --> 00:08:01,120
the three phases first they prior parts

192
00:08:01,120 --> 00:08:04,479
of witness into matrices

193
00:08:04,879 --> 00:08:07,599
and then they use linear time sorry they

194
00:08:07,599 --> 00:08:10,639
use error critical to encode this matrix

195
00:08:10,639 --> 00:08:13,440
both row wise and column wise

196
00:08:13,440 --> 00:08:15,520
and they have that may commit this

197
00:08:15,520 --> 00:08:18,960
matrix using merkle tree

198
00:08:20,160 --> 00:08:23,120
for for query i'm going to

199
00:08:23,120 --> 00:08:26,560
i'm going to show you a query example

200
00:08:26,560 --> 00:08:28,960
for for for query they are going to

201
00:08:28,960 --> 00:08:31,520
first do a random linear combination on

202
00:08:31,520 --> 00:08:32,640
this

203
00:08:32,640 --> 00:08:35,039
row of uh code words

204
00:08:35,039 --> 00:08:37,200
and they are going to check

205
00:08:37,200 --> 00:08:40,159
different uh random columns of this code

206
00:08:40,159 --> 00:08:42,240
words

207
00:08:42,240 --> 00:08:44,320
so why does this work what does this

208
00:08:44,320 --> 00:08:45,760
work because

209
00:08:45,760 --> 00:08:47,760
the error current code got a distance

210
00:08:47,760 --> 00:08:48,959
property

211
00:08:48,959 --> 00:08:51,040
minimum minimum distance property such

212
00:08:51,040 --> 00:08:52,000
that

213
00:08:52,000 --> 00:08:54,560
for every two different

214
00:08:54,560 --> 00:08:56,880
uh co valid code word that the minimum

215
00:08:56,880 --> 00:08:58,800
distance is actually

216
00:08:58,800 --> 00:09:00,480
uh constant so there are constant

217
00:09:00,480 --> 00:09:03,519
fraction of them are different

218
00:09:03,519 --> 00:09:06,640
for malicious prover if they only change

219
00:09:06,640 --> 00:09:10,240
a few entries of the uh of the code so

220
00:09:10,240 --> 00:09:11,920
they're going to get an

221
00:09:11,920 --> 00:09:15,040
invalid aerocratic error code word so it

222
00:09:15,040 --> 00:09:17,680
will be detected afterwards

223
00:09:17,680 --> 00:09:20,640
and if they if the malicious approval

224
00:09:20,640 --> 00:09:23,200
change a lot of them actually they may

225
00:09:23,200 --> 00:09:25,120
convert it into another valid code

226
00:09:25,120 --> 00:09:26,480
however

227
00:09:26,480 --> 00:09:29,600
it may not be consistent with an initial

228
00:09:29,600 --> 00:09:31,360
mercury commitment

229
00:09:31,360 --> 00:09:33,440
so

230
00:09:33,440 --> 00:09:35,760
either way the malicious approval will

231
00:09:35,760 --> 00:09:37,279
be detected

232
00:09:37,279 --> 00:09:38,560
using

233
00:09:38,560 --> 00:09:40,880
based on the general property of the

234
00:09:40,880 --> 00:09:43,920
error question code

235
00:09:44,160 --> 00:09:45,040
so

236
00:09:45,040 --> 00:09:46,560
and there are many

237
00:09:46,560 --> 00:09:48,560
concrete instantiations of this error

238
00:09:48,560 --> 00:09:51,440
correction code such as resumer code

239
00:09:51,440 --> 00:09:53,200
however this resource code actually

240
00:09:53,200 --> 00:09:56,160
requires fft so that's why

241
00:09:56,160 --> 00:09:58,880
it's not scalable in our

242
00:09:58,880 --> 00:10:01,200
case

243
00:10:03,360 --> 00:10:04,399
fortunately

244
00:10:04,399 --> 00:10:06,320
there are many different

245
00:10:06,320 --> 00:10:08,399
uh instantiations of

246
00:10:08,399 --> 00:10:10,800
aerocratic code that is linear timing

247
00:10:10,800 --> 00:10:13,920
codable such as the the code proposed by

248
00:10:13,920 --> 00:10:16,480
the spielman and zucchini shy

249
00:10:16,480 --> 00:10:19,839
and grs plus

250
00:10:20,480 --> 00:10:23,839
this this this arrogant code are all

251
00:10:23,839 --> 00:10:26,800
expander-based codes and next i'm going

252
00:10:26,800 --> 00:10:29,680
to introduce a definition of xmender and

253
00:10:29,680 --> 00:10:33,200
how how does this code encode

254
00:10:33,200 --> 00:10:35,600
so here is an example of

255
00:10:35,600 --> 00:10:37,120
expanded graph

256
00:10:37,120 --> 00:10:39,279
it's a bipartite graph and

257
00:10:39,279 --> 00:10:41,600
all of this code following the following

258
00:10:41,600 --> 00:10:43,440
simple diagram

259
00:10:43,440 --> 00:10:44,800
where you just

260
00:10:44,800 --> 00:10:47,279
for each outputting node you just sum up

261
00:10:47,279 --> 00:10:49,519
the input

262
00:10:49,519 --> 00:10:52,800
according to these edges

263
00:10:56,720 --> 00:10:57,440
so

264
00:10:57,440 --> 00:10:59,839
we conclude that the expander is first

265
00:10:59,839 --> 00:11:01,440
bipartite graph

266
00:11:01,440 --> 00:11:03,279
and it satisfy

267
00:11:03,279 --> 00:11:05,279
some expansion property

268
00:11:05,279 --> 00:11:07,279
for example in this example

269
00:11:07,279 --> 00:11:10,079
if you select randomly select a subset

270
00:11:10,079 --> 00:11:11,360
of

271
00:11:11,360 --> 00:11:13,600
left nodes you're going to expand into a

272
00:11:13,600 --> 00:11:16,000
much larger write node

273
00:11:16,000 --> 00:11:19,200
right right set so

274
00:11:21,440 --> 00:11:23,440
and there are many challenges to

275
00:11:23,440 --> 00:11:27,279
construct this expander code

276
00:11:27,279 --> 00:11:29,519
for example if you try to do some

277
00:11:29,519 --> 00:11:31,279
explicit construction

278
00:11:31,279 --> 00:11:33,680
there is actually a paper from

279
00:11:33,680 --> 00:11:34,640
uh

280
00:11:34,640 --> 00:11:38,720
20 20 20 uh 2002 it said however this

281
00:11:38,720 --> 00:11:41,040
paper got some very large constant

282
00:11:41,040 --> 00:11:43,360
actually two to the maybe 100

283
00:11:43,360 --> 00:11:46,399
constant and this

284
00:11:46,399 --> 00:11:48,000
they require

285
00:11:48,000 --> 00:11:50,240
expander to be super large so the

286
00:11:50,240 --> 00:11:54,240
parameters may not be practical at

287
00:11:54,839 --> 00:11:58,560
all and then there is there is a random

288
00:11:58,560 --> 00:12:00,560
expanded construction

289
00:12:00,560 --> 00:12:02,320
however this random expanded

290
00:12:02,320 --> 00:12:04,800
construction also got some problems

291
00:12:04,800 --> 00:12:06,480
they

292
00:12:06,480 --> 00:12:08,639
the probability of

293
00:12:08,639 --> 00:12:10,480
sampling successfully sampling this

294
00:12:10,480 --> 00:12:12,240
expander is actually

295
00:12:12,240 --> 00:12:15,040
one minus one word party so you got a

296
00:12:15,040 --> 00:12:18,079
failure probability to be manual protein

297
00:12:18,079 --> 00:12:19,120
and

298
00:12:19,120 --> 00:12:21,600
you cannot actually distinguish

299
00:12:21,600 --> 00:12:23,760
uh whether we successfully sampled or

300
00:12:23,760 --> 00:12:26,959
not so it's it's not it's very insecure

301
00:12:26,959 --> 00:12:28,800
to directly use

302
00:12:28,800 --> 00:12:30,160
random

303
00:12:30,160 --> 00:12:31,519
random based

304
00:12:31,519 --> 00:12:34,720
expander generations

305
00:12:36,320 --> 00:12:40,000
to solve this issue we proposed a

306
00:12:40,000 --> 00:12:43,360
new technique to distinguish

307
00:12:43,360 --> 00:12:45,120
between

308
00:12:45,120 --> 00:12:48,240
successfully generated expanders and

309
00:12:48,240 --> 00:12:50,000
failed expanders

310
00:12:50,000 --> 00:12:52,880
so our algorithm is based on the density

311
00:12:52,880 --> 00:12:55,519
sub graph uh algorithm

312
00:12:55,519 --> 00:12:57,680
uh which i will introduce you later why

313
00:12:57,680 --> 00:13:01,199
we use this technique

314
00:13:01,839 --> 00:13:06,079
so our algorithm can improve this random

315
00:13:06,079 --> 00:13:08,240
sun is to

316
00:13:08,240 --> 00:13:11,279
negligible suddenness

317
00:13:13,120 --> 00:13:15,279
so

318
00:13:16,320 --> 00:13:18,480
so now i'm going to introduce why are we

319
00:13:18,480 --> 00:13:21,600
using density subgraph algorithm as our

320
00:13:21,600 --> 00:13:24,720
black box so if you look at a correct

321
00:13:24,720 --> 00:13:27,440
expander here

322
00:13:27,440 --> 00:13:30,480
and you calculate the density it will be

323
00:13:30,480 --> 00:13:34,079
9 over 3 plus 8 where 3 is the size of

324
00:13:34,079 --> 00:13:36,000
left set and

325
00:13:36,000 --> 00:13:38,320
right set is eight so the density

326
00:13:38,320 --> 00:13:41,440
definition is actually number of ages

327
00:13:41,440 --> 00:13:44,560
divided by number of nodes

328
00:13:44,560 --> 00:13:46,880
and if you look at an incorrect expander

329
00:13:46,880 --> 00:13:48,560
for example here

330
00:13:48,560 --> 00:13:50,639
the number of node is actually much much

331
00:13:50,639 --> 00:13:52,800
smaller because the expansion property

332
00:13:52,800 --> 00:13:54,399
is not satisfied

333
00:13:54,399 --> 00:13:58,480
so it will be 6 over 2 plus 3 and you

334
00:13:58,480 --> 00:14:00,639
can notice that the density here is much

335
00:14:00,639 --> 00:14:03,279
smaller than the density in the

336
00:14:03,279 --> 00:14:05,680
incorrect expander

337
00:14:05,680 --> 00:14:06,480
so

338
00:14:06,480 --> 00:14:09,440
based on this intuition you you can

339
00:14:09,440 --> 00:14:12,160
eventually you can find that if it's

340
00:14:12,160 --> 00:14:13,839
actually an expander

341
00:14:13,839 --> 00:14:15,279
you got

342
00:14:15,279 --> 00:14:19,199
a threshold for the density

343
00:14:19,199 --> 00:14:22,079
so if it is expanded the density must be

344
00:14:22,079 --> 00:14:24,560
lower than this value and if it's not

345
00:14:24,560 --> 00:14:26,639
the expander the density must be higher

346
00:14:26,639 --> 00:14:27,839
than this value

347
00:14:27,839 --> 00:14:28,720
so

348
00:14:28,720 --> 00:14:30,880
you can actually distinguish whether

349
00:14:30,880 --> 00:14:33,040
it's expanded or not of just by looking

350
00:14:33,040 --> 00:14:35,519
at the density using using this

351
00:14:35,519 --> 00:14:37,600
algorithm maximum density subgraph

352
00:14:37,600 --> 00:14:40,160
algorithm

353
00:14:41,279 --> 00:14:43,680
and this algorithm can be

354
00:14:43,680 --> 00:14:45,360
can be implemented in

355
00:14:45,360 --> 00:14:47,680
polynomial time it's actually very fast

356
00:14:47,680 --> 00:14:49,199
in practice

357
00:14:49,199 --> 00:14:52,000
and we actually implemented our

358
00:14:52,000 --> 00:14:53,279
tester in

359
00:14:53,279 --> 00:14:58,120
and the code is available on github

360
00:14:58,959 --> 00:15:00,800
and there are some other technical

361
00:15:00,800 --> 00:15:03,120
issues where i'm not i do not have time

362
00:15:03,120 --> 00:15:04,320
to cover

363
00:15:04,320 --> 00:15:05,519
so

364
00:15:05,519 --> 00:15:07,120
there are still

365
00:15:07,120 --> 00:15:09,040
in our paper it's not just trivial

366
00:15:09,040 --> 00:15:10,800
expanders it's actually called nozzle

367
00:15:10,800 --> 00:15:12,720
expander and

368
00:15:12,720 --> 00:15:13,519
to

369
00:15:13,519 --> 00:15:15,920
test this expander we need to

370
00:15:15,920 --> 00:15:19,440
repeatedly subsample the data set

371
00:15:19,440 --> 00:15:22,240
and test whether whether using use

372
00:15:22,240 --> 00:15:23,440
tester whether

373
00:15:23,440 --> 00:15:25,600
there is a dense graph using density

374
00:15:25,600 --> 00:15:27,199
subgraph algorithm

375
00:15:27,199 --> 00:15:29,839
and repeated repeated this process a

376
00:15:29,839 --> 00:15:31,519
sufficient number of times it's actually

377
00:15:31,519 --> 00:15:34,399
unknown times so

378
00:15:34,399 --> 00:15:36,560
then we can conclude that this is a loss

379
00:15:36,560 --> 00:15:39,119
examiner

380
00:15:39,519 --> 00:15:42,480
and we use a rejection sampling to

381
00:15:42,480 --> 00:15:44,639
sample this nozzles vendor

382
00:15:44,639 --> 00:15:46,240
and since the

383
00:15:46,240 --> 00:15:48,880
the original successful ability of if

384
00:15:48,880 --> 00:15:51,680
random random sampling is already high

385
00:15:51,680 --> 00:15:53,120
it's actually one minus one will

386
00:15:53,120 --> 00:15:55,600
probably so the expected running time of

387
00:15:55,600 --> 00:15:57,120
our algorithm

388
00:15:57,120 --> 00:15:58,480
is constant

389
00:15:58,480 --> 00:15:59,519
sorry

390
00:15:59,519 --> 00:16:03,920
expected number of times is constant

391
00:16:07,600 --> 00:16:08,399
yeah

392
00:16:08,399 --> 00:16:09,600
so

393
00:16:09,600 --> 00:16:12,399
now we have expand efficiently expander

394
00:16:12,399 --> 00:16:14,240
and we can use this commander to

395
00:16:14,240 --> 00:16:19,360
construct our linear error current code

396
00:16:19,440 --> 00:16:22,320
so next i will introduce how to

397
00:16:22,320 --> 00:16:24,959
construct a zone proof from this

398
00:16:24,959 --> 00:16:26,480
expander code

399
00:16:26,480 --> 00:16:28,560
plus there is another technique called

400
00:16:28,560 --> 00:16:32,839
code switching from wrong

401
00:16:36,000 --> 00:16:38,639
me remind you about how do we use

402
00:16:38,639 --> 00:16:42,079
expander code to encode first you pass

403
00:16:42,079 --> 00:16:46,319
the witness into a matrix matrix

404
00:16:46,399 --> 00:16:48,480
then you encode the matrix using

405
00:16:48,480 --> 00:16:51,199
expander code so this step will cost you

406
00:16:51,199 --> 00:16:53,519
a linear number of operations due to

407
00:16:53,519 --> 00:16:54,720
like

408
00:16:54,720 --> 00:16:58,560
sorry the encode of the expander code

409
00:17:01,920 --> 00:17:05,280
and this is a commit and encode step

410
00:17:05,280 --> 00:17:07,520
next i will go to the verifying query

411
00:17:07,520 --> 00:17:09,520
step

412
00:17:09,520 --> 00:17:10,240
so

413
00:17:10,240 --> 00:17:12,640
upon a query on

414
00:17:12,640 --> 00:17:16,319
this random value r

415
00:17:16,319 --> 00:17:19,760
you are going to answer this query so

416
00:17:19,760 --> 00:17:21,679
the query is actually an inner product

417
00:17:21,679 --> 00:17:24,000
query so you

418
00:17:24,000 --> 00:17:25,520
you take

419
00:17:25,520 --> 00:17:28,400
the coefficient of this matrix

420
00:17:28,400 --> 00:17:30,799
and your inner product with this r

421
00:17:30,799 --> 00:17:33,360
so this is a definition of y

422
00:17:33,360 --> 00:17:36,320
and we got four different checks

423
00:17:36,320 --> 00:17:38,559
so first check will be

424
00:17:38,559 --> 00:17:41,760
you take a random uh you take a random

425
00:17:41,760 --> 00:17:45,120
column and the inner product is r0

426
00:17:45,120 --> 00:17:47,200
for this check you're going to

427
00:17:47,200 --> 00:17:49,280
if you implement this check naively

428
00:17:49,280 --> 00:17:51,440
you're going to need to transmit the

429
00:17:51,440 --> 00:17:53,760
whole column of the matrix

430
00:17:53,760 --> 00:17:55,919
and for the set for for this check you

431
00:17:55,919 --> 00:17:57,600
are going to

432
00:17:57,600 --> 00:18:01,919
transmit the whole row of the matrix so

433
00:18:01,919 --> 00:18:04,960
basically so basically if you implement

434
00:18:04,960 --> 00:18:06,799
all of these checks naively you are

435
00:18:06,799 --> 00:18:09,440
going to get uh all square to and in

436
00:18:09,440 --> 00:18:11,679
terms of proof size because you need to

437
00:18:11,679 --> 00:18:14,000
at least transmit one row and one column

438
00:18:14,000 --> 00:18:16,720
of the matrix

439
00:18:17,039 --> 00:18:20,160
the cost of the verification is

440
00:18:20,160 --> 00:18:23,919
not satisfiable but fortunately we got

441
00:18:23,919 --> 00:18:26,240
the code switching technique

442
00:18:26,240 --> 00:18:28,080
and

443
00:18:28,080 --> 00:18:30,799
the code switching technique is

444
00:18:30,799 --> 00:18:33,120
you will notice that this is on this old

445
00:18:33,120 --> 00:18:35,280
script file in terms of the instance

446
00:18:35,280 --> 00:18:38,240
size so you can actually recursively

447
00:18:38,240 --> 00:18:40,240
feed the instance into another

448
00:18:40,240 --> 00:18:43,120
genre-proof system based on maybe

449
00:18:43,120 --> 00:18:44,799
realism code

450
00:18:44,799 --> 00:18:47,120
since the size of a

451
00:18:47,120 --> 00:18:48,720
size of the problem is only square

452
00:18:48,720 --> 00:18:50,400
different you can actually

453
00:18:50,400 --> 00:18:53,919
use an organ technique from here

454
00:18:53,919 --> 00:18:54,880
so

455
00:18:54,880 --> 00:18:55,679
you

456
00:18:55,679 --> 00:18:59,520
construct the circuit using uh

457
00:18:59,520 --> 00:19:02,559
the convex circuit here the input is a

458
00:19:02,559 --> 00:19:03,919
message

459
00:19:03,919 --> 00:19:06,320
and you pass it through an encoding

460
00:19:06,320 --> 00:19:09,120
circuit and you finally get this row

461
00:19:09,120 --> 00:19:11,120
sorry is corner

462
00:19:11,120 --> 00:19:12,640
and you

463
00:19:12,640 --> 00:19:14,480
simultaneously do an inner product

464
00:19:14,480 --> 00:19:15,360
circuit

465
00:19:15,360 --> 00:19:17,440
for example if we are doing check one

466
00:19:17,440 --> 00:19:19,360
you can simultaneously your inner part

467
00:19:19,360 --> 00:19:20,559
circuit here

468
00:19:20,559 --> 00:19:24,678
and you got this result

469
00:19:24,720 --> 00:19:27,360
however the output of this

470
00:19:27,360 --> 00:19:29,440
circuit is still large because you still

471
00:19:29,440 --> 00:19:31,679
got a lot of code words where the size

472
00:19:31,679 --> 00:19:34,320
is square different

473
00:19:34,320 --> 00:19:35,520
and you can

474
00:19:35,520 --> 00:19:37,760
but you can you can reduce it by run by

475
00:19:37,760 --> 00:19:40,480
adding a random selector

476
00:19:40,480 --> 00:19:42,320
and you only select

477
00:19:42,320 --> 00:19:45,200
nominal number of uh different entries

478
00:19:45,200 --> 00:19:47,039
in this code world

479
00:19:47,039 --> 00:19:48,960
why that is sufficient because it's an

480
00:19:48,960 --> 00:19:50,400
arrogant code

481
00:19:50,400 --> 00:19:52,160
aircraft code has a minimum distance

482
00:19:52,160 --> 00:19:54,640
property ensures that

483
00:19:54,640 --> 00:19:58,799
if it's it's inconsistent with code

484
00:19:58,799 --> 00:20:01,280
it's the minimum distance between

485
00:20:01,280 --> 00:20:04,000
this correct code and this malicious

486
00:20:04,000 --> 00:20:05,280
code is

487
00:20:05,280 --> 00:20:06,400
constant

488
00:20:06,400 --> 00:20:07,440
sorry the

489
00:20:07,440 --> 00:20:08,640
fraction

490
00:20:08,640 --> 00:20:10,640
there are constant fraction of arrows in

491
00:20:10,640 --> 00:20:12,559
this uh in

492
00:20:12,559 --> 00:20:15,200
this committee rows so

493
00:20:15,200 --> 00:20:17,679
if you randomly sample

494
00:20:17,679 --> 00:20:20,240
number different entries the probability

495
00:20:20,240 --> 00:20:23,280
you hit at least one

496
00:20:23,280 --> 00:20:25,919
inconsistent entry is actually two to

497
00:20:25,919 --> 00:20:27,039
the

498
00:20:27,039 --> 00:20:30,000
minus number

499
00:20:30,000 --> 00:20:31,440
so

500
00:20:31,440 --> 00:20:33,760
you can just check randomly check a

501
00:20:33,760 --> 00:20:35,600
subset of these entries and you get a

502
00:20:35,600 --> 00:20:38,880
very high probability of catching

503
00:20:38,880 --> 00:20:42,480
the malicious program

504
00:20:45,120 --> 00:20:47,200
so after we apply this

505
00:20:47,200 --> 00:20:49,039
the overall

506
00:20:49,039 --> 00:20:51,280
communication complexity is actually log

507
00:20:51,280 --> 00:20:54,640
square and dominated by this

508
00:20:54,640 --> 00:20:57,679
recursive proof

509
00:20:58,000 --> 00:20:59,280
and

510
00:20:59,280 --> 00:21:00,960
now i'm going to show you some

511
00:21:00,960 --> 00:21:03,360
experiments on the system

512
00:21:03,360 --> 00:21:05,039
first is

513
00:21:05,039 --> 00:21:07,360
our polynomial commitment

514
00:21:07,360 --> 00:21:09,919
compared with breakdown

515
00:21:09,919 --> 00:21:10,880
and

516
00:21:10,880 --> 00:21:13,840
if you compare with breakdown we have

517
00:21:13,840 --> 00:21:16,640
comparable prover time notice that

518
00:21:16,640 --> 00:21:19,440
breakdown is grs plus 21 so it's a

519
00:21:19,440 --> 00:21:20,640
reasonable work

520
00:21:20,640 --> 00:21:22,880
and if you compare it with it we got

521
00:21:22,880 --> 00:21:25,360
comparable proof time and our proof size

522
00:21:25,360 --> 00:21:26,640
is actually

523
00:21:26,640 --> 00:21:28,799
much much smaller than them because they

524
00:21:28,799 --> 00:21:30,640
got square to them in terms of proof

525
00:21:30,640 --> 00:21:32,400
size and we only got

526
00:21:32,400 --> 00:21:33,679
a knock square

527
00:21:33,679 --> 00:21:37,039
so there is more than 10 times

528
00:21:37,039 --> 00:21:41,400
difference between our proof size

529
00:21:44,000 --> 00:21:45,840
and for more

530
00:21:45,840 --> 00:21:47,120
comprehensive

531
00:21:47,120 --> 00:21:49,760
comparison in terms of general proof

532
00:21:49,760 --> 00:21:52,559
systems we compare our system with

533
00:21:52,559 --> 00:21:55,120
aurora liquor role and breakdown

534
00:21:55,120 --> 00:21:56,400
and

535
00:21:56,400 --> 00:21:59,039
our proof our proof is one of the

536
00:21:59,039 --> 00:22:01,200
fastest proverbs here

537
00:22:01,200 --> 00:22:04,080
order of magnitude faster than legal and

538
00:22:04,080 --> 00:22:05,280
aurora

539
00:22:05,280 --> 00:22:07,520
and our proof size is actually

540
00:22:07,520 --> 00:22:09,679
uh here so

541
00:22:09,679 --> 00:22:11,600
our proof size is still still much

542
00:22:11,600 --> 00:22:13,600
smaller than other systems

543
00:22:13,600 --> 00:22:18,320
because we got a polylog proof size

544
00:22:20,640 --> 00:22:23,919
and that's all all from my talk

545
00:22:23,919 --> 00:22:26,159
here's a summary so we construct our

546
00:22:26,159 --> 00:22:29,039
system using linear time codable linear

547
00:22:29,039 --> 00:22:30,640
code from expander

548
00:22:30,640 --> 00:22:33,280
and we reduce our proof size from code

549
00:22:33,280 --> 00:22:35,360
switching recursive proof

550
00:22:35,360 --> 00:22:38,559
and here is the code here is our paper

551
00:22:38,559 --> 00:22:41,600
and you can scan the qr code to get get

552
00:22:41,600 --> 00:22:44,159
more information about me

553
00:22:44,159 --> 00:22:45,760
and thank you

554
00:22:45,760 --> 00:22:46,420
any question

555
00:22:46,420 --> 00:22:49,549
[Applause]

556
00:22:52,720 --> 00:22:56,400
we have time for one short question

557
00:22:59,120 --> 00:23:01,200
so let me ask one question so it seems

558
00:23:01,200 --> 00:23:03,440
that your bipartite

559
00:23:03,440 --> 00:23:05,360
graph testing technique is pretty

560
00:23:05,360 --> 00:23:07,600
general so i was

561
00:23:07,600 --> 00:23:09,440
your expander graph technique testing

562
00:23:09,440 --> 00:23:11,520
technique is pretty general so i was

563
00:23:11,520 --> 00:23:13,520
wondering if you plug it in in other

564
00:23:13,520 --> 00:23:15,200
existing xeno knowledge proof systems

565
00:23:15,200 --> 00:23:17,440
could you maybe quickly comment on how

566
00:23:17,440 --> 00:23:19,440
data efficiency would improve

567
00:23:19,440 --> 00:23:21,840
uh sir can repeat you

568
00:23:21,840 --> 00:23:23,919
so i'm saying that your um

569
00:23:23,919 --> 00:23:26,000
like your graph testing technique

570
00:23:26,000 --> 00:23:28,480
um it seems pretty generic but it builds

571
00:23:28,480 --> 00:23:30,240
general and it seems that you can plug

572
00:23:30,240 --> 00:23:32,559
it in in other proof systems

573
00:23:32,559 --> 00:23:35,200
yes um so i was wondering how would you

574
00:23:35,200 --> 00:23:37,600
know if you could comment on how their

575
00:23:37,600 --> 00:23:39,760
efficiency would improve

576
00:23:39,760 --> 00:23:41,520
oh i see so

577
00:23:41,520 --> 00:23:42,880
yeah we can

578
00:23:42,880 --> 00:23:44,720
other so since proof systems are

579
00:23:44,720 --> 00:23:46,320
actually

580
00:23:46,320 --> 00:23:48,080
rely on a higher

581
00:23:48,080 --> 00:23:49,760
higher level

582
00:23:49,760 --> 00:23:51,440
description is actually relying on the

583
00:23:51,440 --> 00:23:53,120
error cleaning code itself

584
00:23:53,120 --> 00:23:55,279
so we can actually apply our aeroclink

585
00:23:55,279 --> 00:23:58,320
code to other systems directly

586
00:23:58,320 --> 00:24:01,440
yeah and we may need the code switching

587
00:24:01,440 --> 00:24:03,760
too because if you directly apply our

588
00:24:03,760 --> 00:24:05,039
graphing code

589
00:24:05,039 --> 00:24:07,679
you need to

590
00:24:08,159 --> 00:24:10,159
this error clean code does not have a

591
00:24:10,159 --> 00:24:12,960
nice property such as multiplicative

592
00:24:12,960 --> 00:24:14,640
property as

593
00:24:14,640 --> 00:24:16,880
the resume code so you still need to do

594
00:24:16,880 --> 00:24:18,880
some other modification modifications to

595
00:24:18,880 --> 00:24:20,000
achieve

596
00:24:20,000 --> 00:24:22,320
succinct proof sites such as

597
00:24:22,320 --> 00:24:24,640
what we did in our paper is called code

598
00:24:24,640 --> 00:24:25,679
switching

599
00:24:25,679 --> 00:24:27,919
yeah

600
00:24:29,600 --> 00:24:33,559
the speaker once again

601
00:26:09,200 --> 00:26:11,279
so our next speaker is leonard brown

602
00:26:11,279 --> 00:26:13,760
from university of oregon and he's going

603
00:26:13,760 --> 00:26:15,919
to talk about efficient vector only and

604
00:26:15,919 --> 00:26:17,760
zero knowledge blues

605
00:26:17,760 --> 00:26:20,559
okay yeah thanks for coming welcome to

606
00:26:20,559 --> 00:26:23,039
my talk on mozzarella uh this is joint

607
00:26:23,039 --> 00:26:24,880
worked with carsten alex and peter or

608
00:26:24,880 --> 00:26:27,520
from awesome university

609
00:26:27,520 --> 00:26:29,200
so we are interested in zero knowledge

610
00:26:29,200 --> 00:26:30,960
boost for arbitrary circuits in this

611
00:26:30,960 --> 00:26:33,279
case arithmetic circuits for rings that

612
00:26:33,279 --> 00:26:35,520
due to the k so the approver has some

613
00:26:35,520 --> 00:26:38,400
input w and it wants to prove and

614
00:26:38,400 --> 00:26:40,480
convince the verifier that

615
00:26:40,480 --> 00:26:41,679
this w

616
00:26:41,679 --> 00:26:44,080
uh fulfills this relation defined by the

617
00:26:44,080 --> 00:26:45,760
circuit so that makes it circuit output

618
00:26:45,760 --> 00:26:47,200
one

619
00:26:47,200 --> 00:26:48,799
we want the usual security properties

620
00:26:48,799 --> 00:26:50,400
such as soundness zero knowledge

621
00:26:50,400 --> 00:26:52,000
completeness

622
00:26:52,000 --> 00:26:53,120
and

623
00:26:53,120 --> 00:26:54,960
the question why are we interested in

624
00:26:54,960 --> 00:26:57,279
this setting that to decay

625
00:26:57,279 --> 00:26:59,840
so we are talking about the numbers or

626
00:26:59,840 --> 00:27:01,840
the integers modulo power of 2 with

627
00:27:01,840 --> 00:27:04,000
normal additional multiplication

628
00:27:04,000 --> 00:27:06,400
other protocols uh often work a lot of

629
00:27:06,400 --> 00:27:08,480
time field but we choose to use this

630
00:27:08,480 --> 00:27:09,919
ring instead

631
00:27:09,919 --> 00:27:11,919
so on the positive side the rings edge

632
00:27:11,919 --> 00:27:14,799
to the k map very well to the data types

633
00:27:14,799 --> 00:27:16,640
register sizes in modern programming

634
00:27:16,640 --> 00:27:18,399
languages and cpus

635
00:27:18,399 --> 00:27:20,640
so that makes it easy to convert

636
00:27:20,640 --> 00:27:22,159
existing programs

637
00:27:22,159 --> 00:27:23,440
to

638
00:27:23,440 --> 00:27:25,039
circuits that we can prove in zero

639
00:27:25,039 --> 00:27:26,880
knowledge or it allows us to reason

640
00:27:26,880 --> 00:27:29,360
about programs in a nicer way

641
00:27:29,360 --> 00:27:31,520
and moreover the implementation can also

642
00:27:31,520 --> 00:27:32,720
that we

643
00:27:32,720 --> 00:27:35,279
get more efficient because we get

644
00:27:35,279 --> 00:27:38,320
essentially reduction modular powers to

645
00:27:38,320 --> 00:27:40,480
almost for free compared to

646
00:27:40,480 --> 00:27:43,039
reduction modular prime

647
00:27:43,039 --> 00:27:45,919
on the downside z2k is not a fiat so we

648
00:27:45,919 --> 00:27:47,760
have zero divisors we can't divide by

649
00:27:47,760 --> 00:27:50,240
any multiple of two and polynomials can

650
00:27:50,240 --> 00:27:53,039
have lots of rules so it's not bounded

651
00:27:53,039 --> 00:27:54,720
anymore by the degree

652
00:27:54,720 --> 00:27:56,960
so that means unfortunately many common

653
00:27:56,960 --> 00:27:58,880
tricks in protocol design don't work

654
00:27:58,880 --> 00:28:00,799
anymore so we have to work around them

655
00:28:00,799 --> 00:28:02,720
the protocols get less efficient the

656
00:28:02,720 --> 00:28:04,320
proofs get more messy

657
00:28:04,320 --> 00:28:06,080
so on one side that just okay is very

658
00:28:06,080 --> 00:28:07,679
nice for the application

659
00:28:07,679 --> 00:28:09,760
and maybe for the implementation but

660
00:28:09,760 --> 00:28:12,559
it's not so nice for the cryptographer

661
00:28:12,559 --> 00:28:13,919
nevertheless

662
00:28:13,919 --> 00:28:15,840
we think it's quite worth it to look at

663
00:28:15,840 --> 00:28:18,159
the setting

664
00:28:18,159 --> 00:28:20,640
coming back to our proof we're using the

665
00:28:20,640 --> 00:28:22,720
commit and proof paradigm where the

666
00:28:22,720 --> 00:28:25,039
prover commits to the circuit inputs uh

667
00:28:25,039 --> 00:28:26,640
some intermediate values in the circuit

668
00:28:26,640 --> 00:28:28,960
and the output then proves that these

669
00:28:28,960 --> 00:28:31,120
consistent error these commitments are

670
00:28:31,120 --> 00:28:32,640
consistent with respect to the circuit

671
00:28:32,640 --> 00:28:34,080
that is computed

672
00:28:34,080 --> 00:28:36,159
and of course that the output commitment

673
00:28:36,159 --> 00:28:38,960
is the desired value one in this case

674
00:28:38,960 --> 00:28:40,320
we're using linearly homomorphic

675
00:28:40,320 --> 00:28:42,000
commitments and this gives us already

676
00:28:42,000 --> 00:28:44,399
zero knowledge for linear functions but

677
00:28:44,399 --> 00:28:46,399
of course we want to have arbitrary

678
00:28:46,399 --> 00:28:48,080
circuits so we combine this with a

679
00:28:48,080 --> 00:28:49,679
multiplication check

680
00:28:49,679 --> 00:28:52,080
given three commitments to values a b

681
00:28:52,080 --> 00:28:54,640
and c we want to prove that the values

682
00:28:54,640 --> 00:28:57,919
in these common commitments are indeed

683
00:28:57,919 --> 00:29:00,000
fulfilled with relation a times b equals

684
00:29:00,000 --> 00:29:01,600
c

685
00:29:01,600 --> 00:29:03,600
so these two steps also correspond to

686
00:29:03,600 --> 00:29:06,320
our contributions first we show how to

687
00:29:06,320 --> 00:29:07,600
more efficiently instantiate the

688
00:29:07,600 --> 00:29:09,760
commitments using vector only so that is

689
00:29:09,760 --> 00:29:12,080
okay and then we give a more efficient

690
00:29:12,080 --> 00:29:13,919
multiplication set a check in the

691
00:29:13,919 --> 00:29:16,240
setting

692
00:29:16,640 --> 00:29:17,440
so

693
00:29:17,440 --> 00:29:19,039
in our zero knowledge setting we have a

694
00:29:19,039 --> 00:29:21,200
designated verifier we have a linear

695
00:29:21,200 --> 00:29:23,360
time proven verifier and also linear

696
00:29:23,360 --> 00:29:25,200
communication in the circuit size now

697
00:29:25,200 --> 00:29:27,360
main goal is that the overhead of

698
00:29:27,360 --> 00:29:29,120
proving the circuit and zero knowledge

699
00:29:29,120 --> 00:29:31,279
should be minimal compared to evaluating

700
00:29:31,279 --> 00:29:33,279
this circuit and plain text

701
00:29:33,279 --> 00:29:36,080
so both with respect to computation and

702
00:29:36,080 --> 00:29:39,730
memory overhead so we want that

703
00:29:39,730 --> 00:29:41,520
[Music]

704
00:29:41,520 --> 00:29:45,039
it should be at lightweight as possible

705
00:29:45,200 --> 00:29:47,200
so how does these commitments look like

706
00:29:47,200 --> 00:29:49,120
if we had a large field then we can just

707
00:29:49,120 --> 00:29:51,039
use information theoretic max over this

708
00:29:51,039 --> 00:29:54,480
field to create these commitments

709
00:29:54,480 --> 00:29:56,960
here the approver holds the value x and

710
00:29:56,960 --> 00:29:59,440
the mac one of this value x whereas the

711
00:29:59,440 --> 00:30:00,880
verifier has

712
00:30:00,880 --> 00:30:04,559
the mac keys where delta is some global

713
00:30:04,559 --> 00:30:06,960
random key and kx is a value specific

714
00:30:06,960 --> 00:30:08,799
key so

715
00:30:08,799 --> 00:30:11,279
due to this format we have

716
00:30:11,279 --> 00:30:12,720
like a linear

717
00:30:12,720 --> 00:30:14,880
homomorphic commitment scheme so we can

718
00:30:14,880 --> 00:30:17,039
just add two commitments get a new one

719
00:30:17,039 --> 00:30:19,520
scale it by constant etc

720
00:30:19,520 --> 00:30:21,440
this method has been used in prior work

721
00:30:21,440 --> 00:30:23,200
for example in mac and cheese then

722
00:30:23,200 --> 00:30:26,640
glassy crypto or in wolverine

723
00:30:26,640 --> 00:30:29,039
and that to decay it's a bit more tricky

724
00:30:29,039 --> 00:30:31,120
we have to

725
00:30:31,120 --> 00:30:31,919
go

726
00:30:31,919 --> 00:30:34,320
go to a larger ring that 2 to the k plus

727
00:30:34,320 --> 00:30:35,200
s

728
00:30:35,200 --> 00:30:36,640
where s depends on the security

729
00:30:36,640 --> 00:30:37,840
parameter

730
00:30:37,840 --> 00:30:39,120
this is due to

731
00:30:39,120 --> 00:30:40,960
we having zero divisors and if we

732
00:30:40,960 --> 00:30:43,600
multiply something by an even number

733
00:30:43,600 --> 00:30:45,919
bits would be cut off and that's bad for

734
00:30:45,919 --> 00:30:47,760
security so we need to work in this

735
00:30:47,760 --> 00:30:50,720
ladder ring but other than that

736
00:30:50,720 --> 00:30:52,399
most of

737
00:30:52,399 --> 00:30:56,399
the the commitments work still the same

738
00:30:56,399 --> 00:30:58,720
note that here we have x tilde as a

739
00:30:58,720 --> 00:31:01,279
representative of x so that

740
00:31:01,279 --> 00:31:03,519
it agrees with x on the lower k bits but

741
00:31:03,519 --> 00:31:05,120
we don't really care what's up in the

742
00:31:05,120 --> 00:31:07,039
other bits

743
00:31:07,039 --> 00:31:08,799
so how do we get these commitments we

744
00:31:08,799 --> 00:31:10,799
use vector oblivious linear evaluation

745
00:31:10,799 --> 00:31:12,080
or vector only

746
00:31:12,080 --> 00:31:14,080
which is a functionality a kind of a

747
00:31:14,080 --> 00:31:16,320
generalization of oblivious transfer

748
00:31:16,320 --> 00:31:18,480
here the prover inputs the value vector

749
00:31:18,480 --> 00:31:21,279
x and the verifier which is like the

750
00:31:21,279 --> 00:31:22,960
receiver and the vector lead particle

751
00:31:22,960 --> 00:31:25,360
inputs a scalar delta and another vector

752
00:31:25,360 --> 00:31:26,399
k

753
00:31:26,399 --> 00:31:28,080
and then the sender which is the

754
00:31:28,080 --> 00:31:31,600
approval gets the mac vector out of it

755
00:31:31,600 --> 00:31:33,600
we can also

756
00:31:33,600 --> 00:31:35,360
look at a slightly different variant

757
00:31:35,360 --> 00:31:37,279
where all these values are sampled

758
00:31:37,279 --> 00:31:39,600
uniformly at random by the functionality

759
00:31:39,600 --> 00:31:42,240
and then we get the chosen input or the

760
00:31:42,240 --> 00:31:44,320
standard chosen input variant just by

761
00:31:44,320 --> 00:31:47,039
sending some correction values

762
00:31:47,039 --> 00:31:49,519
note that here delta is chosen from a

763
00:31:49,519 --> 00:31:50,559
set

764
00:31:50,559 --> 00:31:53,279
that two to the s where s is again

765
00:31:53,279 --> 00:31:56,320
security parameter but the other values

766
00:31:56,320 --> 00:32:00,439
are live in a larger ring

767
00:32:00,559 --> 00:32:03,519
so this how to realize the functionality

768
00:32:03,519 --> 00:32:06,799
is the first part of our paper

769
00:32:06,799 --> 00:32:08,399
and

770
00:32:08,399 --> 00:32:09,919
in the history there are a couple of

771
00:32:09,919 --> 00:32:11,679
different options how you could do this

772
00:32:11,679 --> 00:32:13,279
one thing would be to use oblivious

773
00:32:13,279 --> 00:32:15,440
transfer or homomorphic encryption but

774
00:32:15,440 --> 00:32:17,600
then that would give us a communication

775
00:32:17,600 --> 00:32:20,159
at least in a linear and the length of

776
00:32:20,159 --> 00:32:21,440
the output vector

777
00:32:21,440 --> 00:32:23,360
and with oblivious transfer we would

778
00:32:23,360 --> 00:32:24,640
also need

779
00:32:24,640 --> 00:32:26,799
quadratic communication in the bit size

780
00:32:26,799 --> 00:32:28,960
because we need one ot per bit of the

781
00:32:28,960 --> 00:32:30,159
scalar data

782
00:32:30,159 --> 00:32:34,960
and every ot has like vector size bits

783
00:32:34,960 --> 00:32:36,960
so um

784
00:32:36,960 --> 00:32:39,600
another line of work uses pseudo-random

785
00:32:39,600 --> 00:32:42,480
correlation generators which is defined

786
00:32:42,480 --> 00:32:44,799
for for arbitrary

787
00:32:44,799 --> 00:32:47,200
correlations and there two or more

788
00:32:47,200 --> 00:32:49,840
parties come together and

789
00:32:49,840 --> 00:32:51,279
create a short

790
00:32:51,279 --> 00:32:53,120
seat which then later on can be

791
00:32:53,120 --> 00:32:55,360
non-interactively expanded to a long

792
00:32:55,360 --> 00:32:56,559
correlation

793
00:32:56,559 --> 00:32:58,480
and the important thing here is that the

794
00:32:58,480 --> 00:33:00,320
communication cost is sublinear and the

795
00:33:00,320 --> 00:33:01,840
output vector size

796
00:33:01,840 --> 00:33:03,279
and many of these constructions are

797
00:33:03,279 --> 00:33:05,039
based on the learning parakeet as noise

798
00:33:05,039 --> 00:33:06,159
assumption

799
00:33:06,159 --> 00:33:09,279
however active security for vectoral pcg

800
00:33:09,279 --> 00:33:14,080
pcgs have only achieved a field so far

801
00:33:14,080 --> 00:33:15,840
if you don't consider like generic

802
00:33:15,840 --> 00:33:18,640
multi-party computation approaches

803
00:33:18,640 --> 00:33:20,640
therefore in this work we present an

804
00:33:20,640 --> 00:33:22,640
actively secure vector or e-particle for

805
00:33:22,640 --> 00:33:24,799
the that 2k setting with sublinear

806
00:33:24,799 --> 00:33:27,440
communication

807
00:33:27,919 --> 00:33:30,880
let's take a look at the lpn assumption

808
00:33:30,880 --> 00:33:33,440
so the idea is that we take a short

809
00:33:33,440 --> 00:33:36,240
uniformly random seed then we expand the

810
00:33:36,240 --> 00:33:37,840
siege or encode the seed with the

811
00:33:37,840 --> 00:33:39,600
generating matrix of a random linear

812
00:33:39,600 --> 00:33:40,480
code

813
00:33:40,480 --> 00:33:42,720
we add some sparse error vector on top

814
00:33:42,720 --> 00:33:45,039
where in our case this error vector is a

815
00:33:45,039 --> 00:33:47,200
regular error so it consists of several

816
00:33:47,200 --> 00:33:49,279
blocks and every block has a single

817
00:33:49,279 --> 00:33:50,840
nonzero error

818
00:33:50,840 --> 00:33:54,720
value so this whole thing should look

819
00:33:54,720 --> 00:33:56,880
uniformly random like a long uniformly

820
00:33:56,880 --> 00:33:59,200
written vector given that the random

821
00:33:59,200 --> 00:34:01,120
matrix is public

822
00:34:01,120 --> 00:34:03,039
so this lpn assumption has been studied

823
00:34:03,039 --> 00:34:05,200
for quite a while and it's mostly used

824
00:34:05,200 --> 00:34:06,799
for either

825
00:34:06,799 --> 00:34:09,918
bits or larger fields but here we

826
00:34:09,918 --> 00:34:14,239
consider it over rings that should decay

827
00:34:14,239 --> 00:34:16,800
now how can we use it to

828
00:34:16,800 --> 00:34:20,639
expand a short vector e correlation to a

829
00:34:20,639 --> 00:34:22,159
much longer one

830
00:34:22,159 --> 00:34:24,560
so assume we have a short correlation

831
00:34:24,560 --> 00:34:26,800
let's say we use the t based protocol to

832
00:34:26,800 --> 00:34:29,119
generate this

833
00:34:29,119 --> 00:34:31,119
the costs don't matter that much because

834
00:34:31,119 --> 00:34:33,280
we only have to do it once

835
00:34:33,280 --> 00:34:35,280
so they say we have m of these c

836
00:34:35,280 --> 00:34:37,199
factorials

837
00:34:37,199 --> 00:34:39,520
here in the blue

838
00:34:39,520 --> 00:34:41,280
vector

839
00:34:41,280 --> 00:34:43,918
then we need to generate some this noise

840
00:34:43,918 --> 00:34:46,800
vector so we run a so-called single

841
00:34:46,800 --> 00:34:49,679
point vector e-protocol on smaller sizes

842
00:34:49,679 --> 00:34:51,760
a couple of times one times for each

843
00:34:51,760 --> 00:34:53,440
block in our error vector

844
00:34:53,440 --> 00:34:55,599
and single point vector only means that

845
00:34:55,599 --> 00:34:57,280
the value vector has a signal nonzero

846
00:34:57,280 --> 00:34:59,760
coordinates

847
00:35:00,000 --> 00:35:01,839
so this corresponds to the error in the

848
00:35:01,839 --> 00:35:02,880
rpn

849
00:35:02,880 --> 00:35:05,440
and then by linearity we can apply the

850
00:35:05,440 --> 00:35:07,599
generating matrix add the error on top

851
00:35:07,599 --> 00:35:10,400
and we get a long vectory correlation

852
00:35:10,400 --> 00:35:13,040
out of it and by the lpn assumption this

853
00:35:13,040 --> 00:35:15,680
looks uniformly random

854
00:35:15,680 --> 00:35:17,920
now we need even more vector release we

855
00:35:17,920 --> 00:35:19,280
can just

856
00:35:19,280 --> 00:35:22,240
use up to m uh

857
00:35:22,240 --> 00:35:24,079
of these or

858
00:35:24,079 --> 00:35:25,680
we need to save m of these and then we

859
00:35:25,680 --> 00:35:28,240
can just repeat the process

860
00:35:28,240 --> 00:35:30,720
as long as we want essentially

861
00:35:30,720 --> 00:35:32,720
so this paradigm has been used in recent

862
00:35:32,720 --> 00:35:34,880
works for example in wolverine

863
00:35:34,880 --> 00:35:38,320
and we are also using the

864
00:35:38,320 --> 00:35:40,960
wolverine protocol as a starting point

865
00:35:40,960 --> 00:35:41,760
to

866
00:35:41,760 --> 00:35:43,440
build our single point vectorly for that

867
00:35:43,440 --> 00:35:44,480
to decay

868
00:35:44,480 --> 00:35:46,400
because the single point actually is

869
00:35:46,400 --> 00:35:48,079
really the crucial thing in this whole

870
00:35:48,079 --> 00:35:50,320
expansion step because here we have

871
00:35:50,320 --> 00:35:53,119
actually the output size of the whole

872
00:35:53,119 --> 00:35:54,560
vector like n

873
00:35:54,560 --> 00:35:56,320
and we want to realize this without

874
00:35:56,320 --> 00:35:58,480
having to communicate as much so

875
00:35:58,480 --> 00:36:00,480
essentially we only want to

876
00:36:00,480 --> 00:36:02,480
as a communication cost to depend on the

877
00:36:02,480 --> 00:36:04,240
number of error code units plus maybe

878
00:36:04,240 --> 00:36:07,680
some logarithmic factor in the output

879
00:36:08,160 --> 00:36:11,200
so now like a quick overview how such a

880
00:36:11,200 --> 00:36:14,240
single point vector e protocol can work

881
00:36:14,240 --> 00:36:15,200
so

882
00:36:15,200 --> 00:36:17,280
again we want to have this relation w

883
00:36:17,280 --> 00:36:20,320
equals delta times u plus v where u has

884
00:36:20,320 --> 00:36:23,040
a single non-zero entry beta at position

885
00:36:23,040 --> 00:36:24,960
up

886
00:36:24,960 --> 00:36:27,200
so if we want to distribute some long

887
00:36:27,200 --> 00:36:29,680
random value we usually would use a prg

888
00:36:29,680 --> 00:36:31,119
or prf

889
00:36:31,119 --> 00:36:32,960
now we have two vectors that are almost

890
00:36:32,960 --> 00:36:34,320
the same they differ in only one

891
00:36:34,320 --> 00:36:35,280
variable

892
00:36:35,280 --> 00:36:38,160
so we use a punctured prf here

893
00:36:38,160 --> 00:36:40,880
we can use a build a punctual prf

894
00:36:40,880 --> 00:36:43,200
following the gegm paradigm

895
00:36:43,200 --> 00:36:46,240
um that means we have a short or we have

896
00:36:46,240 --> 00:36:48,640
a normal seat which is the prf key we

897
00:36:48,640 --> 00:36:50,400
have a length doubling

898
00:36:50,400 --> 00:36:52,880
prg and then we can expand the seat in a

899
00:36:52,880 --> 00:36:54,400
two device version

900
00:36:54,400 --> 00:36:56,800
and every path in this tree corresponds

901
00:36:56,800 --> 00:36:59,920
to one evaluation of this prf

902
00:36:59,920 --> 00:37:01,680
now we want to have a puncture pf that

903
00:37:01,680 --> 00:37:02,560
means

904
00:37:02,560 --> 00:37:04,960
whoever gets the puncture p should be

905
00:37:04,960 --> 00:37:07,040
able to evaluate this prf at all

906
00:37:07,040 --> 00:37:09,200
pointless one but one so we want to

907
00:37:09,200 --> 00:37:12,240
remove one of these paths in the tree

908
00:37:12,240 --> 00:37:13,359
and

909
00:37:13,359 --> 00:37:15,760
we can do this by giving this evaluating

910
00:37:15,760 --> 00:37:19,200
party these blue nodes which allows it

911
00:37:19,200 --> 00:37:22,079
to compute all the nodes below them so

912
00:37:22,079 --> 00:37:24,800
that means all the prf outputs except

913
00:37:24,800 --> 00:37:27,839
the punctuation point

914
00:37:28,480 --> 00:37:31,040
um we can realize this by using

915
00:37:31,040 --> 00:37:33,520
oblivious transfer like one ot per level

916
00:37:33,520 --> 00:37:36,240
corresponding to whether this red path

917
00:37:36,240 --> 00:37:37,920
in the tree goes to the left or to the

918
00:37:37,920 --> 00:37:39,520
right

919
00:37:39,520 --> 00:37:42,400
so in our protocol the receiver samples

920
00:37:42,400 --> 00:37:45,200
a prf key then both of them

921
00:37:45,200 --> 00:37:47,599
are torque via updated transfer so that

922
00:37:47,599 --> 00:37:48,880
the sender

923
00:37:48,880 --> 00:37:51,760
selects the punctured prf key at a

924
00:37:51,760 --> 00:37:53,920
position alpha but the receiver does not

925
00:37:53,920 --> 00:37:56,320
burn out

926
00:37:56,400 --> 00:37:59,359
so this can be already used to

927
00:37:59,359 --> 00:38:01,599
define the whole output of the receiver

928
00:38:01,599 --> 00:38:03,920
so we just take v as the output of the

929
00:38:03,920 --> 00:38:07,359
prf for the indices and w is the same

930
00:38:07,359 --> 00:38:09,839
except for position w alpha

931
00:38:09,839 --> 00:38:12,480
so there's one step missing we need to

932
00:38:12,480 --> 00:38:14,800
set this w alpha correctly

933
00:38:14,800 --> 00:38:17,040
here we use another base vector only so

934
00:38:17,040 --> 00:38:19,680
like a previously generated fully and

935
00:38:19,680 --> 00:38:21,040
then the receiver can just send a

936
00:38:21,040 --> 00:38:24,400
correction value that depends on all the

937
00:38:24,400 --> 00:38:25,599
values

938
00:38:25,599 --> 00:38:28,880
vj and the sender just

939
00:38:28,880 --> 00:38:30,720
oh this allows the sender to compute the

940
00:38:30,720 --> 00:38:33,280
missing value uh wife

941
00:38:33,280 --> 00:38:35,280
and this is basically the passively

942
00:38:35,280 --> 00:38:37,040
secure variant of this single point

943
00:38:37,040 --> 00:38:38,560
vector v protocol

944
00:38:38,560 --> 00:38:41,200
however a malicious receiver could

945
00:38:41,200 --> 00:38:43,359
attack in two ways it could

946
00:38:43,359 --> 00:38:46,000
feed inconsistent inputs to the ots

947
00:38:46,000 --> 00:38:48,240
which makes this tree inconsistent and

948
00:38:48,240 --> 00:38:50,960
dependent on what index the standard

949
00:38:50,960 --> 00:38:54,000
shows and that can also send garbage for

950
00:38:54,000 --> 00:38:55,839
this value data

951
00:38:55,839 --> 00:38:58,160
and since both of these values are used

952
00:38:58,160 --> 00:39:00,880
depending on the coordinate alpha that

953
00:39:00,880 --> 00:39:02,880
should be secret

954
00:39:02,880 --> 00:39:05,119
this can lead to leakage later on on the

955
00:39:05,119 --> 00:39:07,040
noise coordinates in the lpn which in

956
00:39:07,040 --> 00:39:10,240
turn could help the approver to solve

957
00:39:10,240 --> 00:39:12,800
the the lpn problem with a higher

958
00:39:12,800 --> 00:39:15,280
probability so we need to prevent both

959
00:39:15,280 --> 00:39:17,680
of these attacks

960
00:39:17,680 --> 00:39:18,960
prior work

961
00:39:18,960 --> 00:39:21,040
such as wolverine uses a

962
00:39:21,040 --> 00:39:23,599
random linear combination in their large

963
00:39:23,599 --> 00:39:24,480
field

964
00:39:24,480 --> 00:39:25,520
to

965
00:39:25,520 --> 00:39:29,200
catch both ways to cheat at once but

966
00:39:29,200 --> 00:39:30,800
random linear combinations over that to

967
00:39:30,800 --> 00:39:33,760
decay are tricky because we again would

968
00:39:33,760 --> 00:39:36,160
have to enlarge the ring by at least as

969
00:39:36,160 --> 00:39:38,800
bits to ensure consistency of the lower

970
00:39:38,800 --> 00:39:39,839
splits

971
00:39:39,839 --> 00:39:42,960
so one iteration that would be fine but

972
00:39:42,960 --> 00:39:44,240
if we want to

973
00:39:44,240 --> 00:39:46,160
iterate this vector the expansion

974
00:39:46,160 --> 00:39:48,960
protocol uh again and again then we

975
00:39:48,960 --> 00:39:50,720
would have to start with a really large

976
00:39:50,720 --> 00:39:53,119
ring that shrinks a bit in every

977
00:39:53,119 --> 00:39:54,640
iteration

978
00:39:54,640 --> 00:39:56,960
so that's a bit annoying so we chose a

979
00:39:56,960 --> 00:39:58,640
different approach

980
00:39:58,640 --> 00:40:00,400
first we use the universal hashing base

981
00:40:00,400 --> 00:40:02,880
trick to ensure consistency of the gtm

982
00:40:02,880 --> 00:40:05,520
tree following like a similar trick from

983
00:40:05,520 --> 00:40:07,280
boiler down

984
00:40:07,280 --> 00:40:10,800
so we add another layer to the gdm tree

985
00:40:10,800 --> 00:40:13,359
now all the left leaves will be our

986
00:40:13,359 --> 00:40:15,520
outputs as before but all the right

987
00:40:15,520 --> 00:40:18,000
leaves we will feed into a hash function

988
00:40:18,000 --> 00:40:19,680
that the sender selects

989
00:40:19,680 --> 00:40:22,000
and the verifier just responds to the

990
00:40:22,000 --> 00:40:23,920
hash and this

991
00:40:23,920 --> 00:40:26,240
makes sure that it cannot

992
00:40:26,240 --> 00:40:29,598
create an inconsistent tree

993
00:40:30,000 --> 00:40:30,880
so

994
00:40:30,880 --> 00:40:32,880
this

995
00:40:32,880 --> 00:40:34,880
prevents attacks against the gtm tree

996
00:40:34,880 --> 00:40:36,240
and for the

997
00:40:36,240 --> 00:40:39,359
second attack vector for the d we use a

998
00:40:39,359 --> 00:40:42,480
binary linear combination after all

999
00:40:42,480 --> 00:40:46,319
however binary coefficients well you can

1000
00:40:46,319 --> 00:40:47,680
guess a single coefficient with

1001
00:40:47,680 --> 00:40:49,359
probability one half

1002
00:40:49,359 --> 00:40:50,800
and if the

1003
00:40:50,800 --> 00:40:52,240
malicious receiver guesses the

1004
00:40:52,240 --> 00:40:54,720
coefficient k alpha then it can be

1005
00:40:54,720 --> 00:40:57,680
effectively bypasses check

1006
00:40:57,680 --> 00:41:01,119
we say okay this is fine but

1007
00:41:01,119 --> 00:41:02,560
we compensate

1008
00:41:02,560 --> 00:41:05,119
for this potential leakage by increasing

1009
00:41:05,119 --> 00:41:07,440
the overall noise rate

1010
00:41:07,440 --> 00:41:09,200
so our

1011
00:41:09,200 --> 00:41:10,960
well ideal single point vectoring

1012
00:41:10,960 --> 00:41:13,599
functionality is not not as ideal as we

1013
00:41:13,599 --> 00:41:15,680
would like but we can compensate for

1014
00:41:15,680 --> 00:41:18,240
this leakage

1015
00:41:18,960 --> 00:41:21,520
okay how can we

1016
00:41:21,520 --> 00:41:23,680
use this vectorly to

1017
00:41:23,680 --> 00:41:25,520
or how can we use these commitments that

1018
00:41:25,520 --> 00:41:27,599
we just created to get zero knowledge to

1019
00:41:27,599 --> 00:41:29,599
arbitrary circuits

1020
00:41:29,599 --> 00:41:31,040
so this check

1021
00:41:31,040 --> 00:41:33,440
we call quark silver it is based on a

1022
00:41:33,440 --> 00:41:36,160
prior work quicksilver and to remind you

1023
00:41:36,160 --> 00:41:37,760
of what we want to do we have three

1024
00:41:37,760 --> 00:41:39,920
commitments a b and c and we want to

1025
00:41:39,920 --> 00:41:43,680
verify that a times b equals c

1026
00:41:43,680 --> 00:41:46,000
so the authors of quicksilver observed

1027
00:41:46,000 --> 00:41:47,920
that if you take the mac equations

1028
00:41:47,920 --> 00:41:50,800
multiply them in a in a clever way then

1029
00:41:50,800 --> 00:41:54,240
you get an equation that is quadratic in

1030
00:41:54,240 --> 00:41:54,960
the

1031
00:41:54,960 --> 00:41:56,400
in the

1032
00:41:56,400 --> 00:41:58,720
verifiers key delta

1033
00:41:58,720 --> 00:42:01,119
and here on the slide all the blue

1034
00:42:01,119 --> 00:42:03,040
values are known by the provers and the

1035
00:42:03,040 --> 00:42:05,599
green values are known by the verifier

1036
00:42:05,599 --> 00:42:06,480
and

1037
00:42:06,480 --> 00:42:08,560
what is important

1038
00:42:08,560 --> 00:42:10,640
if the proof is honest then this first

1039
00:42:10,640 --> 00:42:12,480
coefficient here like the coefficient of

1040
00:42:12,480 --> 00:42:15,119
data squared should be 0 because then c

1041
00:42:15,119 --> 00:42:18,079
is equal to a times b

1042
00:42:18,079 --> 00:42:20,640
however if it tries to

1043
00:42:20,640 --> 00:42:23,119
do something fishy then this might be a

1044
00:42:23,119 --> 00:42:25,280
nonzero value so we have a quadratic

1045
00:42:25,280 --> 00:42:27,839
equation otherwise it's linear

1046
00:42:27,839 --> 00:42:28,640
so

1047
00:42:28,640 --> 00:42:31,040
in a normal way the approver would just

1048
00:42:31,040 --> 00:42:32,880
send these first two values to the

1049
00:42:32,880 --> 00:42:35,359
verifier and then the verifier checks

1050
00:42:35,359 --> 00:42:37,280
this equation

1051
00:42:37,280 --> 00:42:39,520
and if we want to check multiple

1052
00:42:39,520 --> 00:42:41,520
multiplications in a batch we can use

1053
00:42:41,520 --> 00:42:43,520
the random linear combination which is

1054
00:42:43,520 --> 00:42:45,040
fine in this way because we don't have

1055
00:42:45,040 --> 00:42:48,319
to like repeat it over and over

1056
00:42:48,319 --> 00:42:50,880
so what if the proverb tries to cheat

1057
00:42:50,880 --> 00:42:53,440
well essentially cheating corresponds to

1058
00:42:53,440 --> 00:42:55,440
choosing a quadratic polynomial but the

1059
00:42:55,440 --> 00:42:57,680
first coefficient is the the error that

1060
00:42:57,680 --> 00:43:00,000
is induced here so it has to be non-zero

1061
00:43:00,000 --> 00:43:02,160
modulo 2 to the k

1062
00:43:02,160 --> 00:43:04,240
and now the check passes if this

1063
00:43:04,240 --> 00:43:07,280
polynomial has a root at position delta

1064
00:43:07,280 --> 00:43:08,400
since

1065
00:43:08,400 --> 00:43:10,880
delta comes from a very large set this

1066
00:43:10,880 --> 00:43:12,400
should be very unlikely because the

1067
00:43:12,400 --> 00:43:13,599
approver doesn't know anything about

1068
00:43:13,599 --> 00:43:15,440
data

1069
00:43:15,440 --> 00:43:18,000
and yeah as i said the polynomial has

1070
00:43:18,000 --> 00:43:19,839
degree two if the approver tries to

1071
00:43:19,839 --> 00:43:21,040
cheat

1072
00:43:21,040 --> 00:43:23,599
over the field everything is fine we can

1073
00:43:23,599 --> 00:43:26,560
say p has at most two roots so soundness

1074
00:43:26,560 --> 00:43:28,319
arrow is

1075
00:43:28,319 --> 00:43:29,680
2 over q

1076
00:43:29,680 --> 00:43:31,440
which is still negligible

1077
00:43:31,440 --> 00:43:33,680
however in a ring we can have many more

1078
00:43:33,680 --> 00:43:35,760
roots so

1079
00:43:35,760 --> 00:43:37,760
in this particular setting we bounded

1080
00:43:37,760 --> 00:43:39,599
the root number of roots by something

1081
00:43:39,599 --> 00:43:41,359
like 2 to the k

1082
00:43:41,359 --> 00:43:44,480
2 to the s over 2. so the square root of

1083
00:43:44,480 --> 00:43:46,720
all the possible values can be roots in

1084
00:43:46,720 --> 00:43:48,800
the worst case

1085
00:43:48,800 --> 00:43:50,880
hence we need to

1086
00:43:50,880 --> 00:43:52,720
use a larger ring overall and then we

1087
00:43:52,720 --> 00:43:54,800
end up with something like 2 to the k

1088
00:43:54,800 --> 00:43:57,680
plus 2 s plus 2 log s plus 3.

1089
00:43:57,680 --> 00:44:00,480
but overall this is still better than

1090
00:44:00,480 --> 00:44:02,400
previous solutions

1091
00:44:02,400 --> 00:44:06,800
um yeah we have to do it with it i guess

1092
00:44:06,800 --> 00:44:09,040
before i summarize i want to

1093
00:44:09,040 --> 00:44:10,880
leave a few words about the performance

1094
00:44:10,880 --> 00:44:12,640
so we implemented

1095
00:44:12,640 --> 00:44:15,440
this uh both protocols and the swanky

1096
00:44:15,440 --> 00:44:18,800
npc framework and for like 64-bit

1097
00:44:18,800 --> 00:44:21,520
arithmetic 64-bit integers you need to

1098
00:44:21,520 --> 00:44:22,400
work over

1099
00:44:22,400 --> 00:44:23,079
a

1100
00:44:23,079 --> 00:44:24,880
162-bit ring

1101
00:44:24,880 --> 00:44:25,760
to

1102
00:44:25,760 --> 00:44:27,440
ensure that you get

1103
00:44:27,440 --> 00:44:30,560
40 bits of statistical security

1104
00:44:30,560 --> 00:44:32,960
so for large batches and land setting we

1105
00:44:32,960 --> 00:44:33,839
can

1106
00:44:33,839 --> 00:44:36,560
generate roughly 20 million vectors per

1107
00:44:36,560 --> 00:44:38,560
second and then for each vector e we

1108
00:44:38,560 --> 00:44:41,680
have to send about a single

1109
00:44:41,680 --> 00:44:44,160
this gives us a performance very similar

1110
00:44:44,160 --> 00:44:47,359
to wolverine which did essentially the

1111
00:44:47,359 --> 00:44:50,160
same work over fields

1112
00:44:50,160 --> 00:44:51,440
for the quad silver zero knowledge

1113
00:44:51,440 --> 00:44:53,760
protocols we have to send one single

1114
00:44:53,760 --> 00:44:55,839
ring element of this larger ring per

1115
00:44:55,839 --> 00:44:57,920
multiplication because we have to commit

1116
00:44:57,920 --> 00:45:00,880
to the output of the multiplication

1117
00:45:00,880 --> 00:45:03,119
and this gives us a performance of about

1118
00:45:03,119 --> 00:45:05,920
1.3 million multiplications that we can

1119
00:45:05,920 --> 00:45:08,319
check per second

1120
00:45:08,319 --> 00:45:11,760
if we take a look at what performance

1121
00:45:11,760 --> 00:45:14,160
the quicksilver offers achieve then

1122
00:45:14,160 --> 00:45:16,319
their number is about five times larger

1123
00:45:16,319 --> 00:45:19,680
but they they have i think a prime

1124
00:45:19,680 --> 00:45:21,839
of size 61 bits

1125
00:45:21,839 --> 00:45:24,720
which means you can't really uh emulate

1126
00:45:24,720 --> 00:45:27,200
64-bit arithmetic so if you have two

1127
00:45:27,200 --> 00:45:29,440
arbitrary 64-bit numbers the result will

1128
00:45:29,440 --> 00:45:32,560
be 128 bits and then you would have to

1129
00:45:32,560 --> 00:45:34,240
do the reduction

1130
00:45:34,240 --> 00:45:36,800
so to emulate this kind of arithmetic

1131
00:45:36,800 --> 00:45:39,119
you would have to

1132
00:45:39,119 --> 00:45:41,599
use a larger prime which in turn leads

1133
00:45:41,599 --> 00:45:43,920
to more communication and

1134
00:45:43,920 --> 00:45:45,200
more

1135
00:45:45,200 --> 00:45:47,520
expensive arithmetic as we already have

1136
00:45:47,520 --> 00:45:50,240
in our z2k ring

1137
00:45:50,240 --> 00:45:52,319
in contrast to them we don't have to

1138
00:45:52,319 --> 00:45:55,359
care about material reduction modulo 2

1139
00:45:55,359 --> 00:45:57,680
to the 64. it's just

1140
00:45:57,680 --> 00:45:58,839
built in

1141
00:45:58,839 --> 00:46:00,480
natively

1142
00:46:00,480 --> 00:46:03,599
okay to summarize we constructed an

1143
00:46:03,599 --> 00:46:05,520
efficient and practical vector e

1144
00:46:05,520 --> 00:46:07,839
protocol which which acted with active

1145
00:46:07,839 --> 00:46:10,319
security and sublinear communication and

1146
00:46:10,319 --> 00:46:12,079
we only have to send back a single bit

1147
00:46:12,079 --> 00:46:13,200
or a bit more depending on the

1148
00:46:13,200 --> 00:46:14,640
parameters

1149
00:46:14,640 --> 00:46:17,040
moreover we have a new check for

1150
00:46:17,040 --> 00:46:18,720
a verifying

1151
00:46:18,720 --> 00:46:21,680
multiplications module that to decay

1152
00:46:21,680 --> 00:46:22,480
and

1153
00:46:22,480 --> 00:46:24,400
there we only need to send a single ring

1154
00:46:24,400 --> 00:46:26,800
element per multiplications

1155
00:46:26,800 --> 00:46:28,560
but we have still some open questions

1156
00:46:28,560 --> 00:46:30,480
for example

1157
00:46:30,480 --> 00:46:32,800
this larger wing we have to work in can

1158
00:46:32,800 --> 00:46:35,280
we reduce the overhead

1159
00:46:35,280 --> 00:46:36,160
of

1160
00:46:36,160 --> 00:46:38,079
the ring size compared to the cables

1161
00:46:38,079 --> 00:46:41,200
we're actually interested in

1162
00:46:41,280 --> 00:46:42,960
depending on the protocol

1163
00:46:42,960 --> 00:46:45,200
we have to work in larger or smaller

1164
00:46:45,200 --> 00:46:46,800
rings but we always have this kind of

1165
00:46:46,800 --> 00:46:48,640
overhead

1166
00:46:48,640 --> 00:46:51,119
then many recent protocols for fields

1167
00:46:51,119 --> 00:46:54,000
use that fancy polynomial tricks or use

1168
00:46:54,000 --> 00:46:57,200
some some code properties but all these

1169
00:46:57,200 --> 00:46:58,880
or many of these techniques don't work

1170
00:46:58,880 --> 00:47:00,800
anymore for rings so can we get

1171
00:47:00,800 --> 00:47:03,520
something similar efficient in the 2k

1172
00:47:03,520 --> 00:47:05,760
setting

1173
00:47:05,760 --> 00:47:07,359
so if you're interested in more of

1174
00:47:07,359 --> 00:47:09,280
mozzarella take a look at our full

1175
00:47:09,280 --> 00:47:12,000
version or ask us now or later

1176
00:47:12,000 --> 00:47:16,400
and yeah thanks that was it for me

1177
00:47:21,040 --> 00:47:24,520
are there any questions

1178
00:47:26,319 --> 00:47:27,760
if there are no questions let's thank

1179
00:47:27,760 --> 00:47:31,240
the speaker again

1180
00:48:45,760 --> 00:48:48,960
alright so the next talk is by abraham

1181
00:48:48,960 --> 00:48:51,520
kothapali from cmu

1182
00:48:51,520 --> 00:48:53,760
on nova recursive zero knowledge

1183
00:48:53,760 --> 00:48:57,880
arguments from folding systems

1184
00:49:08,160 --> 00:49:10,000
for a new notion known as folding

1185
00:49:10,000 --> 00:49:12,079
schemes oh that's that's better um yeah

1186
00:49:12,079 --> 00:49:13,920
and this is joint work with trina seti

1187
00:49:13,920 --> 00:49:17,440
and iana ziela

1188
00:49:17,440 --> 00:49:20,480
okay so our goal is to design practical

1189
00:49:20,480 --> 00:49:23,440
zk snarks for recursive computation and

1190
00:49:23,440 --> 00:49:24,880
what i mean by this is that we want to

1191
00:49:24,880 --> 00:49:27,119
design a succinct non-interactive

1192
00:49:27,119 --> 00:49:29,440
argument of knowledge that allows us to

1193
00:49:29,440 --> 00:49:31,359
prove that a non-deterministic function

1194
00:49:31,359 --> 00:49:34,240
f applied n times to some initial input

1195
00:49:34,240 --> 00:49:38,240
z zero results in some output c n and i

1196
00:49:38,240 --> 00:49:39,760
say non-deterministic because we want to

1197
00:49:39,760 --> 00:49:42,480
allow f to take additional witnesses

1198
00:49:42,480 --> 00:49:45,119
along the way

1199
00:49:45,119 --> 00:49:47,760
now this can be instantiated to

1200
00:49:47,760 --> 00:49:49,520
derive various cryptographic

1201
00:49:49,520 --> 00:49:52,079
applications and primitives right

1202
00:49:52,079 --> 00:49:54,640
so by just by instantiating f correctly

1203
00:49:54,640 --> 00:49:57,680
we can derive verifiable delay functions

1204
00:49:57,680 --> 00:50:00,079
we can derive zero knowledge verifiable

1205
00:50:00,079 --> 00:50:02,559
virtual machines and we can even derive

1206
00:50:02,559 --> 00:50:04,960
zika roll-ups which allow us to prove

1207
00:50:04,960 --> 00:50:07,760
that many transactions to a blockchain

1208
00:50:07,760 --> 00:50:11,119
are have been updated correctly

1209
00:50:11,119 --> 00:50:12,880
now i hope with these applications i

1210
00:50:12,880 --> 00:50:15,440
sort of intuit that we no longer really

1211
00:50:15,440 --> 00:50:17,280
care only about the theoretical

1212
00:50:17,280 --> 00:50:19,359
properties of recursive proof systems we

1213
00:50:19,359 --> 00:50:21,599
also care about how useful they are in

1214
00:50:21,599 --> 00:50:24,240
practice and how fast we can get them to

1215
00:50:24,240 --> 00:50:28,160
be for real world applications

1216
00:50:28,160 --> 00:50:30,000
now you might think okay well there

1217
00:50:30,000 --> 00:50:32,240
seems to be a naive approach here right

1218
00:50:32,240 --> 00:50:34,960
well we can just take the function f

1219
00:50:34,960 --> 00:50:37,599
apply it to itself uh n times throw it

1220
00:50:37,599 --> 00:50:39,599
all into an arithmetic circuit and then

1221
00:50:39,599 --> 00:50:42,480
just prove that unrolled statement using

1222
00:50:42,480 --> 00:50:45,359
your favorite snark okay

1223
00:50:45,359 --> 00:50:47,920
while this approach nominally works the

1224
00:50:47,920 --> 00:50:50,880
key issue is that this fixes and ahead

1225
00:50:50,880 --> 00:50:52,720
of time which means that for certain

1226
00:50:52,720 --> 00:50:54,880
applications like virtual machines where

1227
00:50:54,880 --> 00:50:56,559
the number of recursive iterations might

1228
00:50:56,559 --> 00:50:59,599
actually depend on the input program

1229
00:50:59,599 --> 00:51:02,079
this actually will not work and moreover

1230
00:51:02,079 --> 00:51:04,000
if we can somehow make it work we still

1231
00:51:04,000 --> 00:51:05,920
have that the approver memory and the

1232
00:51:05,920 --> 00:51:07,680
verifier pre-processing time are

1233
00:51:07,680 --> 00:51:09,599
dependent on n and depending on the

1234
00:51:09,599 --> 00:51:11,280
start that we're using we might even

1235
00:51:11,280 --> 00:51:13,520
have a situation in which the verifier

1236
00:51:13,520 --> 00:51:16,800
time depends on n

1237
00:51:16,800 --> 00:51:19,040
so to get around these issues back in

1238
00:51:19,040 --> 00:51:21,599
2008 valiant introduces this notion of

1239
00:51:21,599 --> 00:51:24,079
incrementally verifiable computation

1240
00:51:24,079 --> 00:51:25,920
the core idea of incrementally

1241
00:51:25,920 --> 00:51:27,760
verifiable computation

1242
00:51:27,760 --> 00:51:30,319
is that well we can write a proof for a

1243
00:51:30,319 --> 00:51:32,480
single iteration of f but then later

1244
00:51:32,480 --> 00:51:34,640
come back and very cheaply update this

1245
00:51:34,640 --> 00:51:37,520
proof over time as we keep incrementing

1246
00:51:37,520 --> 00:51:40,400
the applications of f okay

1247
00:51:40,400 --> 00:51:43,040
and the core challenges of ibc are that

1248
00:51:43,040 --> 00:51:45,119
well we want to be able to arbitrarily

1249
00:51:45,119 --> 00:51:46,800
increment as many times as we want and

1250
00:51:46,800 --> 00:51:49,359
this allows us to recurse indefinitely

1251
00:51:49,359 --> 00:51:50,640
and the second core challenge is we

1252
00:51:50,640 --> 00:51:51,760
actually want to make sure that these

1253
00:51:51,760 --> 00:51:54,720
proofs don't grow in size as we keep

1254
00:51:54,720 --> 00:51:57,359
going okay and these two challenges make

1255
00:51:57,359 --> 00:51:59,839
ivc a difficult primitive to achieve

1256
00:51:59,839 --> 00:52:03,119
both in theory and in practice

1257
00:52:03,119 --> 00:52:06,160
so nova is a built zk snark for

1258
00:52:06,160 --> 00:52:09,520
recursive computation which uses ibc as

1259
00:52:09,520 --> 00:52:12,160
a core building block so specifically

1260
00:52:12,160 --> 00:52:14,240
what we do is that we design a very

1261
00:52:14,240 --> 00:52:17,280
efficient implementation of ibc using

1262
00:52:17,280 --> 00:52:20,480
this new notion of folding schemes okay

1263
00:52:20,480 --> 00:52:22,720
so specifically at a very high level a

1264
00:52:22,720 --> 00:52:24,559
folding scheme allows you to reduce the

1265
00:52:24,559 --> 00:52:26,640
task of checking two instances in a

1266
00:52:26,640 --> 00:52:29,440
relation the task of checking a single

1267
00:52:29,440 --> 00:52:31,119
instance in that relation

1268
00:52:31,119 --> 00:52:33,200
and we show that if you have a folding

1269
00:52:33,200 --> 00:52:35,599
scheme for an mp complete relation then

1270
00:52:35,599 --> 00:52:38,960
you could derive an ibc scheme okay so

1271
00:52:38,960 --> 00:52:40,480
specifically we designed a new

1272
00:52:40,480 --> 00:52:42,800
characterization of np called relaxed

1273
00:52:42,800 --> 00:52:46,559
r1cs which is designed to be very

1274
00:52:46,559 --> 00:52:49,280
quickly and efficiently folded

1275
00:52:49,280 --> 00:52:51,200
now putting all of these techniques

1276
00:52:51,200 --> 00:52:53,520
together we get ibc proofs which are

1277
00:52:53,520 --> 00:52:56,400
linear in the size of the function f

1278
00:52:56,400 --> 00:52:58,640
and they in no way depend on the

1279
00:52:58,640 --> 00:53:00,800
recursion depth n

1280
00:53:00,800 --> 00:53:02,400
but suppose we wanted even more

1281
00:53:02,400 --> 00:53:04,960
efficiency guarantees in practice

1282
00:53:04,960 --> 00:53:07,119
well we then show that we can actually

1283
00:53:07,119 --> 00:53:09,280
add a layer of sickness and zero

1284
00:53:09,280 --> 00:53:11,839
knowledge on top of our ibc proofs so

1285
00:53:11,839 --> 00:53:14,400
specifically what we do is that we first

1286
00:53:14,400 --> 00:53:16,640
design a zk snark

1287
00:53:16,640 --> 00:53:19,040
for relaxed r1cs and then leverage this

1288
00:53:19,040 --> 00:53:21,760
zk snark to design a very efficient

1289
00:53:21,760 --> 00:53:22,640
proof

1290
00:53:22,640 --> 00:53:25,359
that proves the existence of a valid ivc

1291
00:53:25,359 --> 00:53:28,000
proof okay and using these techniques

1292
00:53:28,000 --> 00:53:30,079
we're able to go from proofs that are

1293
00:53:30,079 --> 00:53:32,319
linear in the size of the function f to

1294
00:53:32,319 --> 00:53:34,880
non-incremental uh but very short proofs

1295
00:53:34,880 --> 00:53:36,640
that are logarithmic in the size of the

1296
00:53:36,640 --> 00:53:38,720
function f

1297
00:53:38,720 --> 00:53:40,480
now nova putting everything together

1298
00:53:40,480 --> 00:53:42,319
represents one of the fastest and one of

1299
00:53:42,319 --> 00:53:43,920
the most efficient

1300
00:53:43,920 --> 00:53:46,800
proof systems for recursive computation

1301
00:53:46,800 --> 00:53:48,720
so nova is implemented in rust in about

1302
00:53:48,720 --> 00:53:51,040
6000 lines of code and is available on

1303
00:53:51,040 --> 00:53:54,319
github and if we feature the smallest

1304
00:53:54,319 --> 00:53:55,680
per step private time which is just

1305
00:53:55,680 --> 00:53:57,400
dominated by just two

1306
00:53:57,400 --> 00:54:00,319
multi-exponentiations per recursion step

1307
00:54:00,319 --> 00:54:02,480
and a recursion overhead is also the

1308
00:54:02,480 --> 00:54:04,480
smallest in literature now what i mean

1309
00:54:04,480 --> 00:54:06,400
by recursion overhead is that because of

1310
00:54:06,400 --> 00:54:08,240
how these systems are built we end up

1311
00:54:08,240 --> 00:54:10,720
having to prove the function f as as

1312
00:54:10,720 --> 00:54:12,640
well as a little bit of additional

1313
00:54:12,640 --> 00:54:14,640
overhead and this additional overhead in

1314
00:54:14,640 --> 00:54:17,359
our case per recursive step is just two

1315
00:54:17,359 --> 00:54:20,000
scalar multiplications

1316
00:54:20,000 --> 00:54:22,880
um and finally using our

1317
00:54:22,880 --> 00:54:24,720
proofs and sickness techniques we're

1318
00:54:24,720 --> 00:54:27,119
able to get down the proofs down to

1319
00:54:27,119 --> 00:54:29,119
logarithmic and the size of f and

1320
00:54:29,119 --> 00:54:30,640
roughly if we're able to represent the

1321
00:54:30,640 --> 00:54:32,160
function f in about a million

1322
00:54:32,160 --> 00:54:33,359
constraints

1323
00:54:33,359 --> 00:54:35,520
then we can get proofs that are eight

1324
00:54:35,520 --> 00:54:38,160
kilobytes in size

1325
00:54:38,160 --> 00:54:39,839
so today specifically i'll be talking

1326
00:54:39,839 --> 00:54:41,760
about the theoretical backbone of nova

1327
00:54:41,760 --> 00:54:43,760
so specifically i'll be talking first

1328
00:54:43,760 --> 00:54:45,119
about how

1329
00:54:45,119 --> 00:54:48,000
we can use a folding scheme for np and

1330
00:54:48,000 --> 00:54:50,880
use that to imply an ivc scheme and then

1331
00:54:50,880 --> 00:54:52,319
after that i'll actually go ahead and

1332
00:54:52,319 --> 00:54:54,160
develop a folding scheme for np by

1333
00:54:54,160 --> 00:54:56,799
developing a phone scheme for relaxed

1334
00:54:56,799 --> 00:54:59,440
r1cs

1335
00:54:59,440 --> 00:55:01,760
so before i begin it with our own

1336
00:55:01,760 --> 00:55:03,359
approach to ibc it's important that i

1337
00:55:03,359 --> 00:55:05,200
intuit the original approach to ibc as

1338
00:55:05,200 --> 00:55:07,760
well as more modern approaches to ibc to

1339
00:55:07,760 --> 00:55:11,359
intuit how our solution works okay so

1340
00:55:11,359 --> 00:55:13,280
valiant's original approach to ivc was

1341
00:55:13,280 --> 00:55:15,599
actually very very elegant

1342
00:55:15,599 --> 00:55:18,000
so the core idea is that well

1343
00:55:18,000 --> 00:55:19,839
let's not only prove the function f but

1344
00:55:19,839 --> 00:55:22,559
let's also prove a little bit extra okay

1345
00:55:22,559 --> 00:55:24,400
and let's represent this little bit

1346
00:55:24,400 --> 00:55:25,920
extra on the function f as a large

1347
00:55:25,920 --> 00:55:28,079
circuit f prime okay

1348
00:55:28,079 --> 00:55:29,920
and this little bit extra is going to be

1349
00:55:29,920 --> 00:55:33,520
a snark verifier that verifies that

1350
00:55:33,520 --> 00:55:36,000
there exists a snark that proves all

1351
00:55:36,000 --> 00:55:39,200
prior iterations of the function f prime

1352
00:55:39,200 --> 00:55:40,160
okay

1353
00:55:40,160 --> 00:55:42,640
and then we can say that well to

1354
00:55:42,640 --> 00:55:44,640
increment this proof we can write a new

1355
00:55:44,640 --> 00:55:46,799
proof about this latest circuit okay f

1356
00:55:46,799 --> 00:55:49,920
prime and call that pi i plus one

1357
00:55:49,920 --> 00:55:51,839
now specifically what pi i plus one test

1358
00:55:51,839 --> 00:55:53,599
is attesting to is that well the

1359
00:55:53,599 --> 00:55:55,680
function f was run correctly and also

1360
00:55:55,680 --> 00:55:58,160
there exists a proof of all prior

1361
00:55:58,160 --> 00:56:00,400
iterations of the function f prime

1362
00:56:00,400 --> 00:56:02,559
okay and what this means is that pi plus

1363
00:56:02,559 --> 00:56:05,440
1 really is a proof for i plus 1

1364
00:56:05,440 --> 00:56:07,599
iterations of the function f prime so

1365
00:56:07,599 --> 00:56:09,520
essentially if we have converted a proof

1366
00:56:09,520 --> 00:56:12,640
of i iterations into a proof of i plus 1

1367
00:56:12,640 --> 00:56:14,079
iterations

1368
00:56:14,079 --> 00:56:16,480
now valiance approach is incredibly

1369
00:56:16,480 --> 00:56:18,319
insightful in theory but when we

1370
00:56:18,319 --> 00:56:19,839
actually try to instantiate the pieces

1371
00:56:19,839 --> 00:56:21,839
in practice it turns out that it's quite

1372
00:56:21,839 --> 00:56:25,440
inefficient okay so the core goal when

1373
00:56:25,440 --> 00:56:26,799
we're trying to instantiate these

1374
00:56:26,799 --> 00:56:28,880
objects in practice is that we want to

1375
00:56:28,880 --> 00:56:31,359
make sure that the overhead over the

1376
00:56:31,359 --> 00:56:33,119
original function f

1377
00:56:33,119 --> 00:56:35,520
to derive this function f prime is as

1378
00:56:35,520 --> 00:56:38,319
small as possible okay so bc tv actually

1379
00:56:38,319 --> 00:56:39,839
go through the process of instantiating

1380
00:56:39,839 --> 00:56:42,160
valiance approach using the most

1381
00:56:42,160 --> 00:56:44,559
efficient snarks in practice today which

1382
00:56:44,559 --> 00:56:47,280
are these snarks uh with a constant time

1383
00:56:47,280 --> 00:56:50,000
verifier that rely on pairings but they

1384
00:56:50,000 --> 00:56:51,680
show that to make this even remotely

1385
00:56:51,680 --> 00:56:53,440
possible in valiant setting we actually

1386
00:56:53,440 --> 00:56:56,720
need to use very expensive cycles of

1387
00:56:56,720 --> 00:56:59,440
pairing friendly curves okay

1388
00:56:59,440 --> 00:57:01,680
and also um because these snarks rely on

1389
00:57:01,680 --> 00:57:03,920
a trusted setup the ivc scheme itself

1390
00:57:03,920 --> 00:57:06,880
also inherits this trusted setup

1391
00:57:06,880 --> 00:57:08,319
all right so you might say okay well

1392
00:57:08,319 --> 00:57:09,839
maybe we can get around these efficiency

1393
00:57:09,839 --> 00:57:12,240
issues um by using snarks without

1394
00:57:12,240 --> 00:57:14,480
trusted setup right

1395
00:57:14,480 --> 00:57:16,960
but the core issue here is that those

1396
00:57:16,960 --> 00:57:19,200
snarks actually have verifiers which are

1397
00:57:19,200 --> 00:57:20,799
not constant time they're actually more

1398
00:57:20,799 --> 00:57:22,799
asymptotically expensive and they

1399
00:57:22,799 --> 00:57:25,839
actually incur very large overheads over

1400
00:57:25,839 --> 00:57:28,880
the original function f okay which goes

1401
00:57:28,880 --> 00:57:30,480
against the our goal of trying to

1402
00:57:30,480 --> 00:57:33,280
minimize this additional overhead

1403
00:57:33,280 --> 00:57:35,280
so for the longest time valence approach

1404
00:57:35,280 --> 00:57:37,040
was considered just a theoretical

1405
00:57:37,040 --> 00:57:39,760
interest until very recently in 2019 bow

1406
00:57:39,760 --> 00:57:41,839
green and hopwood introduced a new

1407
00:57:41,839 --> 00:57:44,799
approach okay in which they say well

1408
00:57:44,799 --> 00:57:45,920
let us

1409
00:57:45,920 --> 00:57:49,599
not only uh let us not check the entire

1410
00:57:49,599 --> 00:57:51,440
proof in the circuit okay let's

1411
00:57:51,440 --> 00:57:54,160
specifically only check a very small

1412
00:57:54,160 --> 00:57:56,400
part of it and then defer the rest okay

1413
00:57:56,400 --> 00:57:58,000
and essentially what this allows them to

1414
00:57:58,000 --> 00:58:00,559
do is avoid having to implement a bunch

1415
00:58:00,559 --> 00:58:02,319
of very expensive snack machinery like

1416
00:58:02,319 --> 00:58:04,079
pairings and things like that in the

1417
00:58:04,079 --> 00:58:06,079
circuit okay and this means that they

1418
00:58:06,079 --> 00:58:07,440
avoid

1419
00:58:07,440 --> 00:58:09,200
cycles of pairing friendly curves and

1420
00:58:09,200 --> 00:58:12,079
they also avoid this trusted setup

1421
00:58:12,079 --> 00:58:13,839
so a little bit more into detail what

1422
00:58:13,839 --> 00:58:16,079
they do is that well they design

1423
00:58:16,079 --> 00:58:17,839
something called an accumulator okay

1424
00:58:17,839 --> 00:58:20,400
that allows you to take that proof

1425
00:58:20,400 --> 00:58:22,160
and check a little part of it and then

1426
00:58:22,160 --> 00:58:23,599
defer the rest of it into that

1427
00:58:23,599 --> 00:58:25,440
accumulator so this is accumulator

1428
00:58:25,440 --> 00:58:28,000
doesn't keep growing in size over time

1429
00:58:28,000 --> 00:58:30,319
okay but checking this accumulator is

1430
00:58:30,319 --> 00:58:31,839
equivalent to checking all the proofs

1431
00:58:31,839 --> 00:58:34,240
that were deferred into it

1432
00:58:34,240 --> 00:58:36,799
now to increment this proof or complete

1433
00:58:36,799 --> 00:58:38,400
the recursive cycle essentially what

1434
00:58:38,400 --> 00:58:40,079
they do is they say well we can write a

1435
00:58:40,079 --> 00:58:41,920
new proof which attests to the latest

1436
00:58:41,920 --> 00:58:43,520
execution of f

1437
00:58:43,520 --> 00:58:45,280
and also a test that this accumulator

1438
00:58:45,280 --> 00:58:47,359
was built correctly

1439
00:58:47,359 --> 00:58:49,520
now more recently uh

1440
00:58:49,520 --> 00:58:52,480
buns ksl in mishra and spooner introduce

1441
00:58:52,480 --> 00:58:54,640
a technique where they say well

1442
00:58:54,640 --> 00:58:56,160
this proof doesn't even need to be

1443
00:58:56,160 --> 00:58:58,799
succinct okay and what that does is that

1444
00:58:58,799 --> 00:59:00,799
affords them to

1445
00:59:00,799 --> 00:59:03,040
make it even cheaper in the circuit okay

1446
00:59:03,040 --> 00:59:04,720
their proof machinery is even cheaper

1447
00:59:04,720 --> 00:59:06,799
and they use even less additional gates

1448
00:59:06,799 --> 00:59:09,520
of the original function f

1449
00:59:09,520 --> 00:59:10,319
okay

1450
00:59:10,319 --> 00:59:11,440
um

1451
00:59:11,440 --> 00:59:12,319
so

1452
00:59:12,319 --> 00:59:14,799
these results in general bring us a lot

1453
00:59:14,799 --> 00:59:16,799
closer to practice okay because we're

1454
00:59:16,799 --> 00:59:18,319
really just throwing as much proof

1455
00:59:18,319 --> 00:59:20,640
machinery as possible from the internals

1456
00:59:20,640 --> 00:59:23,520
of the circuit okay but the core issue

1457
00:59:23,520 --> 00:59:25,440
is that well we looked at this and we

1458
00:59:25,440 --> 00:59:26,880
said well

1459
00:59:26,880 --> 00:59:29,119
maybe there's a way to make this even

1460
00:59:29,119 --> 00:59:31,280
cheaper in practice okay

1461
00:59:31,280 --> 00:59:32,480
and

1462
00:59:32,480 --> 00:59:35,359
to to answer that question we said well

1463
00:59:35,359 --> 00:59:37,280
okay where are the costs here and it

1464
00:59:37,280 --> 00:59:38,720
turns out that

1465
00:59:38,720 --> 00:59:39,440
well

1466
00:59:39,440 --> 00:59:41,040
even partially checking this proof in

1467
00:59:41,040 --> 00:59:43,200
some of these uh systems is is quite

1468
00:59:43,200 --> 00:59:46,640
expensive okay and generally even

1469
00:59:46,640 --> 00:59:48,640
generating these proofs is also both

1470
00:59:48,640 --> 00:59:50,640
concretely and even in some cases more

1471
00:59:50,640 --> 00:59:54,079
asymptotically expensive okay so then we

1472
00:59:54,079 --> 00:59:55,440
said okay

1473
00:59:55,440 --> 00:59:57,760
what if we get rid of the proof

1474
00:59:57,760 --> 00:59:59,760
abstraction entirely succinct or

1475
00:59:59,760 --> 01:00:01,520
otherwise just completely get rid of it

1476
01:00:01,520 --> 01:00:03,599
okay and we say

1477
01:00:03,599 --> 01:00:07,040
what if we only talk about claims okay

1478
01:00:07,040 --> 01:00:09,359
so specifically what we want to do is

1479
01:00:09,359 --> 01:00:12,480
say that suppose we had a claim that

1480
01:00:12,480 --> 01:00:13,760
just talks about the correct execution

1481
01:00:13,760 --> 01:00:16,000
of the last instance of f and another

1482
01:00:16,000 --> 01:00:17,520
claim that talks about the correct

1483
01:00:17,520 --> 01:00:19,599
execution of all prior instances of f

1484
01:00:19,599 --> 01:00:20,480
prime

1485
01:00:20,480 --> 01:00:23,760
okay well then suppose we had a magic

1486
01:00:23,760 --> 01:00:25,920
black box that could reduce two claims

1487
01:00:25,920 --> 01:00:27,440
of the same structure

1488
01:00:27,440 --> 01:00:30,400
into a new claim of the same structure

1489
01:00:30,400 --> 01:00:31,280
okay

1490
01:00:31,280 --> 01:00:33,280
now this new claim the same structure

1491
01:00:33,280 --> 01:00:36,400
essentially attests to both prior claims

1492
01:00:36,400 --> 01:00:38,319
okay because checking that is equivalent

1493
01:00:38,319 --> 01:00:39,280
to checking both private claims

1494
01:00:39,280 --> 01:00:41,200
according to this functionality

1495
01:00:41,200 --> 01:00:44,079
then essentially it could be the case

1496
01:00:44,079 --> 01:00:45,760
that checking this new claim is a lot

1497
01:00:45,760 --> 01:00:47,520
cheaper if we just create this just

1498
01:00:47,520 --> 01:00:50,319
right so these claims don't grow in size

1499
01:00:50,319 --> 01:00:52,240
over time and the corresponding

1500
01:00:52,240 --> 01:00:54,319
witnesses for these claims also don't

1501
01:00:54,319 --> 01:00:56,480
grow in size over time

1502
01:00:56,480 --> 01:00:57,440
okay

1503
01:00:57,440 --> 01:00:58,559
and now

1504
01:00:58,559 --> 01:01:00,559
using the analog of prior approaches we

1505
01:01:00,559 --> 01:01:03,599
can also increment this claim by just

1506
01:01:03,599 --> 01:01:05,200
you know writing a new claim about the

1507
01:01:05,200 --> 01:01:07,119
correctness of the latest iteration of

1508
01:01:07,119 --> 01:01:09,119
this computation of prime and together

1509
01:01:09,119 --> 01:01:10,880
we can go from a claim of i iterations

1510
01:01:10,880 --> 01:01:13,200
of f prime into a

1511
01:01:13,200 --> 01:01:16,079
uh claim about i plus one iterations of

1512
01:01:16,079 --> 01:01:17,440
f prime

1513
01:01:17,440 --> 01:01:19,520
okay well now the burning question is

1514
01:01:19,520 --> 01:01:21,520
how do we actually implement this fold

1515
01:01:21,520 --> 01:01:23,599
functionality okay and specifically we

1516
01:01:23,599 --> 01:01:25,839
need to be able to reduce claims

1517
01:01:25,839 --> 01:01:27,359
preserve their size and also make sure

1518
01:01:27,359 --> 01:01:30,079
these claims are powerful enough um to

1519
01:01:30,079 --> 01:01:31,520
capture mp constraints because we

1520
01:01:31,520 --> 01:01:32,960
actually want to capture any arbitrary

1521
01:01:32,960 --> 01:01:35,280
function f prime

1522
01:01:35,280 --> 01:01:38,000
so to do so we actually start with a

1523
01:01:38,000 --> 01:01:40,079
simpler goal and our goal is to say well

1524
01:01:40,079 --> 01:01:42,160
let's just try to derive an interactive

1525
01:01:42,160 --> 01:01:43,760
analog of this first okay and then we

1526
01:01:43,760 --> 01:01:45,200
can maybe use standard techniques to

1527
01:01:45,200 --> 01:01:47,359
compile this down into a non-interactive

1528
01:01:47,359 --> 01:01:50,000
version okay so what we do is we derive

1529
01:01:50,000 --> 01:01:52,559
something called a folding scheme okay

1530
01:01:52,559 --> 01:01:54,880
so folding scheme concretely reduces the

1531
01:01:54,880 --> 01:01:57,599
task of checking two claims u1 and u2

1532
01:01:57,599 --> 01:02:00,000
into the task of checking a new folded

1533
01:02:00,000 --> 01:02:02,559
claim you so syntactically what this

1534
01:02:02,559 --> 01:02:04,160
means is this is going to be interaction

1535
01:02:04,160 --> 01:02:07,200
between approver and a verifier okay in

1536
01:02:07,200 --> 01:02:09,200
which the verify takes as input two

1537
01:02:09,200 --> 01:02:10,880
instances to be checked

1538
01:02:10,880 --> 01:02:12,319
and the approver takes us and put the

1539
01:02:12,319 --> 01:02:14,079
corresponding witnesses now they

1540
01:02:14,079 --> 01:02:16,240
interact a little bit and eventually the

1541
01:02:16,240 --> 01:02:19,280
verifier outputs a new folded instance

1542
01:02:19,280 --> 01:02:21,280
which is satisfied with it says it's

1543
01:02:21,280 --> 01:02:22,480
it's going to be satisfied with bin

1544
01:02:22,480 --> 01:02:23,760
checking in place of the original two

1545
01:02:23,760 --> 01:02:26,960
instances and the approver outputs a new

1546
01:02:26,960 --> 01:02:28,559
forwarded witness which presumably

1547
01:02:28,559 --> 01:02:31,200
satisfies this folded instance

1548
01:02:31,200 --> 01:02:32,160
okay

1549
01:02:32,160 --> 01:02:34,079
so we can derive naturally the

1550
01:02:34,079 --> 01:02:35,760
completeness and soundness properties

1551
01:02:35,760 --> 01:02:37,760
for this okay so specifically

1552
01:02:37,760 --> 01:02:39,680
completeness is that well if the two

1553
01:02:39,680 --> 01:02:41,359
input claims are valid

1554
01:02:41,359 --> 01:02:43,119
then we should have the output claim is

1555
01:02:43,119 --> 01:02:44,640
also valid

1556
01:02:44,640 --> 01:02:46,559
and for knowledge soundness we must have

1557
01:02:46,559 --> 01:02:47,680
that well

1558
01:02:47,680 --> 01:02:50,160
if the approver is able to maliciously

1559
01:02:50,160 --> 01:02:52,960
output a w or a witness that satisfies

1560
01:02:52,960 --> 01:02:55,920
the folded instance then it must have

1561
01:02:55,920 --> 01:02:58,480
known the two input witnesses that

1562
01:02:58,480 --> 01:03:01,440
satisfy the two input statements to the

1563
01:03:01,440 --> 01:03:02,559
verifier

1564
01:03:02,559 --> 01:03:04,319
and one very important piece is that we

1565
01:03:04,319 --> 01:03:06,160
also have a very

1566
01:03:06,160 --> 01:03:08,079
critical efficiency requirement okay

1567
01:03:08,079 --> 01:03:10,319
that is we want the verifiers cost of

1568
01:03:10,319 --> 01:03:12,559
interacting in this folding scheme to be

1569
01:03:12,559 --> 01:03:14,559
significantly less than just directly

1570
01:03:14,559 --> 01:03:16,640
checking these instances

1571
01:03:16,640 --> 01:03:19,920
or even checking one of these instances

1572
01:03:19,920 --> 01:03:22,480
okay and one other key piece that i need

1573
01:03:22,480 --> 01:03:24,400
to mention here is that well

1574
01:03:24,400 --> 01:03:25,680
if we have a folding scheme that is

1575
01:03:25,680 --> 01:03:27,760
public coin that is the verifier only

1576
01:03:27,760 --> 01:03:29,440
sends randomness to the prover then we

1577
01:03:29,440 --> 01:03:31,359
can just use the fiat trimmer transform

1578
01:03:31,359 --> 01:03:34,480
to make it non-interactive okay and now

1579
01:03:34,480 --> 01:03:36,480
putting all the pieces together

1580
01:03:36,480 --> 01:03:38,000
essentially

1581
01:03:38,000 --> 01:03:40,079
if we had a non-interactive folding

1582
01:03:40,079 --> 01:03:42,000
scheme that is powerful enough to encode

1583
01:03:42,000 --> 01:03:45,440
np relations okay then f prime can

1584
01:03:45,440 --> 01:03:48,480
verifiably fold the two claims ui and

1585
01:03:48,480 --> 01:03:52,480
capital ui into a new claim capital u i

1586
01:03:52,480 --> 01:03:53,359
okay

1587
01:03:53,359 --> 01:03:55,359
now you might notice well this isn't

1588
01:03:55,359 --> 01:03:57,520
quite like that fold functionality that

1589
01:03:57,520 --> 01:04:00,160
we had before right because this voting

1590
01:04:00,160 --> 01:04:02,720
verifier actually needs additional hints

1591
01:04:02,720 --> 01:04:06,640
um to fold this uh these claims okay and

1592
01:04:06,640 --> 01:04:07,839
these hints are in the form of the

1593
01:04:07,839 --> 01:04:09,440
transcript from the non-interactive

1594
01:04:09,440 --> 01:04:12,079
folding scheme okay so specifically the

1595
01:04:12,079 --> 01:04:15,280
overall ibc prover along the side runs

1596
01:04:15,280 --> 01:04:17,359
this voting verifier and keeps track of

1597
01:04:17,359 --> 01:04:20,079
the witnesses corresponding to these

1598
01:04:20,079 --> 01:04:21,280
claims

1599
01:04:21,280 --> 01:04:22,480
okay

1600
01:04:22,480 --> 01:04:23,280
so

1601
01:04:23,280 --> 01:04:24,880
it seems that we're getting really close

1602
01:04:24,880 --> 01:04:26,559
to our final construction really like we

1603
01:04:26,559 --> 01:04:29,200
went from ibc uh to requiring just a

1604
01:04:29,200 --> 01:04:31,599
folding scheme for np okay but now how

1605
01:04:31,599 --> 01:04:33,680
do we actually construct a folding

1606
01:04:33,680 --> 01:04:37,440
scheme for np complete relations okay

1607
01:04:37,440 --> 01:04:39,520
well we have many options but we'll

1608
01:04:39,520 --> 01:04:41,920
start with r1cs which is a very elegant

1609
01:04:41,920 --> 01:04:43,760
algebraic way of looking at mp

1610
01:04:43,760 --> 01:04:45,440
constraints okay and we can try to use

1611
01:04:45,440 --> 01:04:47,200
some algebraic properties to very

1612
01:04:47,200 --> 01:04:50,799
cleverly try to fold two r1cs instances

1613
01:04:50,799 --> 01:04:51,680
okay

1614
01:04:51,680 --> 01:04:55,359
um so recall they an r1cs uh statement

1615
01:04:55,359 --> 01:04:57,680
consists of constraint matrices a b and

1616
01:04:57,680 --> 01:05:00,079
c which represent the computation itself

1617
01:05:00,079 --> 01:05:01,839
and the public i o vector x which

1618
01:05:01,839 --> 01:05:03,359
represents the inputs and outputs to the

1619
01:05:03,359 --> 01:05:04,559
computation

1620
01:05:04,559 --> 01:05:07,119
now witness which is the vector which

1621
01:05:07,119 --> 01:05:08,799
might represent the computational trace

1622
01:05:08,799 --> 01:05:12,400
say is satisfying if for a new vector z

1623
01:05:12,400 --> 01:05:16,319
which is equal to w x 1 we have the a z

1624
01:05:16,319 --> 01:05:20,079
times b z is equal to c z now say times

1625
01:05:20,079 --> 01:05:22,079
here to mean the harder product okay

1626
01:05:22,079 --> 01:05:23,520
that means we're doing entry wise

1627
01:05:23,520 --> 01:05:25,680
multiplication and we're checking each

1628
01:05:25,680 --> 01:05:27,039
entry

1629
01:05:27,039 --> 01:05:29,520
okay well now we have this relation

1630
01:05:29,520 --> 01:05:32,400
let's try to fold it okay so suppose the

1631
01:05:32,400 --> 01:05:34,880
verifier takes as input two statements

1632
01:05:34,880 --> 01:05:36,799
with the same computational structure it

1633
01:05:36,799 --> 01:05:39,760
turns out this is enough for ibc okay so

1634
01:05:39,760 --> 01:05:43,280
abc x1 and abc x2

1635
01:05:43,280 --> 01:05:44,799
okay and the prover takes us and put the

1636
01:05:44,799 --> 01:05:47,760
corresponding witnesses w1 and w2

1637
01:05:47,760 --> 01:05:50,079
well we can try to use the bluntest tool

1638
01:05:50,079 --> 01:05:51,520
available to us we can just try to take

1639
01:05:51,520 --> 01:05:53,359
a random linear combination

1640
01:05:53,359 --> 01:05:55,680
so what the verifier does is send over a

1641
01:05:55,680 --> 01:05:57,440
challenge to the approver which is just

1642
01:05:57,440 --> 01:05:59,599
a random field element and together they

1643
01:05:59,599 --> 01:06:01,520
just take a random linear combination of

1644
01:06:01,520 --> 01:06:04,559
the statement x okay and then the the

1645
01:06:04,559 --> 01:06:06,160
prover also takes a random linear

1646
01:06:06,160 --> 01:06:08,400
combination of the witness

1647
01:06:08,400 --> 01:06:10,480
and together they output the new folded

1648
01:06:10,480 --> 01:06:12,319
instance witness pairs

1649
01:06:12,319 --> 01:06:14,160
now the question is well does it satisfy

1650
01:06:14,160 --> 01:06:17,359
completeness that is is a b c x

1651
01:06:17,359 --> 01:06:20,319
satisfied by that new witness w

1652
01:06:20,319 --> 01:06:22,720
okay and it turns out unfortunately it's

1653
01:06:22,720 --> 01:06:24,880
not okay so

1654
01:06:24,880 --> 01:06:28,240
you know letting z be the folded vector

1655
01:06:28,240 --> 01:06:32,079
z that is z1 plus r times z2 okay where

1656
01:06:32,079 --> 01:06:33,119
z1

1657
01:06:33,119 --> 01:06:34,319
is equal to

1658
01:06:34,319 --> 01:06:36,160
w1 x11

1659
01:06:36,160 --> 01:06:39,359
okay we have the az times bz

1660
01:06:39,359 --> 01:06:42,480
is not equal to cz okay and intuitively

1661
01:06:42,480 --> 01:06:44,319
the reason for this is well just

1662
01:06:44,319 --> 01:06:46,559
expanding out cz

1663
01:06:46,559 --> 01:06:48,640
we have that it has this very nice

1664
01:06:48,640 --> 01:06:52,160
purple term and this yellow term okay

1665
01:06:52,160 --> 01:06:52,960
but

1666
01:06:52,960 --> 01:06:55,760
if we try to expand out a z times b z

1667
01:06:55,760 --> 01:06:57,359
because of that harder mark product in

1668
01:06:57,359 --> 01:06:58,240
the middle

1669
01:06:58,240 --> 01:07:00,799
we end up having these annoying cross

1670
01:07:00,799 --> 01:07:03,280
terms highlighted in red

1671
01:07:03,280 --> 01:07:04,240
okay

1672
01:07:04,240 --> 01:07:06,960
so and not only that we have that the

1673
01:07:06,960 --> 01:07:09,839
yellow piece is also scaled by r squared

1674
01:07:09,839 --> 01:07:12,000
instead of just r right so it seems like

1675
01:07:12,000 --> 01:07:13,920
there's no hope of both sides of this

1676
01:07:13,920 --> 01:07:16,880
equation actually to be equal

1677
01:07:16,880 --> 01:07:19,200
okay so our core intuition was to say

1678
01:07:19,200 --> 01:07:23,760
well what if we extend r1cs itself

1679
01:07:23,760 --> 01:07:26,400
just enough that we can sort of handle

1680
01:07:26,400 --> 01:07:28,160
all these additional garbage terms that

1681
01:07:28,160 --> 01:07:31,119
show up okay so what we do is that we

1682
01:07:31,119 --> 01:07:32,319
first

1683
01:07:32,319 --> 01:07:34,319
introduce a new error vector to the

1684
01:07:34,319 --> 01:07:35,839
statement e

1685
01:07:35,839 --> 01:07:38,160
okay which is designed to absorb all

1686
01:07:38,160 --> 01:07:40,319
these additional cross vectors in the

1687
01:07:40,319 --> 01:07:41,280
middle

1688
01:07:41,280 --> 01:07:44,160
okay and then we introduce a scalar u

1689
01:07:44,160 --> 01:07:45,760
which is designed to absorb the

1690
01:07:45,760 --> 01:07:47,839
additional r squared factor at the very

1691
01:07:47,839 --> 01:07:50,799
end okay so specifically we're going to

1692
01:07:50,799 --> 01:07:54,480
define a variant of r1cs called relaxed

1693
01:07:54,480 --> 01:07:57,200
r1cs which is just like in our cs

1694
01:07:57,200 --> 01:07:58,640
statement but additionally contains the

1695
01:07:58,640 --> 01:08:01,359
error vector e and the

1696
01:08:01,359 --> 01:08:04,720
scalar u okay so specifically a witness

1697
01:08:04,720 --> 01:08:06,400
vector w

1698
01:08:06,400 --> 01:08:11,440
is satisfying if for z is equal to w x u

1699
01:08:11,440 --> 01:08:13,039
we have the a z

1700
01:08:13,039 --> 01:08:16,000
times b z is equal to u

1701
01:08:16,000 --> 01:08:17,279
times c z

1702
01:08:17,279 --> 01:08:18,799
plus e

1703
01:08:18,799 --> 01:08:21,198
now it turns out that this statement is

1704
01:08:21,198 --> 01:08:23,279
structured just right so that when you

1705
01:08:23,279 --> 01:08:25,279
take two statements of this form you can

1706
01:08:25,279 --> 01:08:27,679
define a folding operation that allows

1707
01:08:27,679 --> 01:08:30,158
you to get a single statement of this

1708
01:08:30,158 --> 01:08:32,000
form okay and i want to give you some

1709
01:08:32,000 --> 01:08:35,600
intuition for why that's the case

1710
01:08:35,600 --> 01:08:38,399
so specifically we're going to design a

1711
01:08:38,399 --> 01:08:40,719
folding scheme for relaxed star with cs

1712
01:08:40,719 --> 01:08:43,120
which is almost right and i'll fix a few

1713
01:08:43,120 --> 01:08:45,120
caveats here and there in the next slide

1714
01:08:45,120 --> 01:08:46,560
so i only want you to focus on the

1715
01:08:46,560 --> 01:08:48,319
pieces highlighted in yellow which

1716
01:08:48,319 --> 01:08:50,158
represent the changes from the original

1717
01:08:50,158 --> 01:08:53,600
folding scheme for r1cs okay so

1718
01:08:53,600 --> 01:08:55,359
specifically now the verifier also takes

1719
01:08:55,359 --> 01:08:59,040
as input e1 u1 and e2 u2

1720
01:08:59,040 --> 01:08:59,920
okay

1721
01:08:59,920 --> 01:09:00,960
so now

1722
01:09:00,960 --> 01:09:04,000
using its witnesses the prover computes

1723
01:09:04,000 --> 01:09:07,198
all the cross terms okay including these

1724
01:09:07,198 --> 01:09:09,439
new uh u terms that we've introduced

1725
01:09:09,439 --> 01:09:12,080
okay to send over to verifier requesting

1726
01:09:12,080 --> 01:09:14,640
it to encode it into its new error

1727
01:09:14,640 --> 01:09:16,399
vector okay

1728
01:09:16,399 --> 01:09:18,158
and now the verifier sends back a

1729
01:09:18,158 --> 01:09:20,719
challenge and computes u and x in a sort

1730
01:09:20,719 --> 01:09:22,158
of expected way just taking a random

1731
01:09:22,158 --> 01:09:23,679
linear combination

1732
01:09:23,679 --> 01:09:26,080
but now the proven the verifier compute

1733
01:09:26,080 --> 01:09:28,719
the new error vector okay it is computed

1734
01:09:28,719 --> 01:09:29,759
in a way

1735
01:09:29,759 --> 01:09:32,080
that accounts for both the old error

1736
01:09:32,080 --> 01:09:34,238
vectors as well as all the new cross

1737
01:09:34,238 --> 01:09:36,000
terms that we've produced in this

1738
01:09:36,000 --> 01:09:38,640
folding procedure okay and this is

1739
01:09:38,640 --> 01:09:40,560
essentially what allows us to balance

1740
01:09:40,560 --> 01:09:42,799
both sides of the equation

1741
01:09:42,799 --> 01:09:44,640
okay and of course the prover computes

1742
01:09:44,640 --> 01:09:47,198
the witness as expected and together

1743
01:09:47,198 --> 01:09:50,640
they output the new folded instance

1744
01:09:50,640 --> 01:09:52,158
witness pairs

1745
01:09:52,158 --> 01:09:54,320
right so it turns out that we can show

1746
01:09:54,320 --> 01:09:57,440
that this satisfies uh completeness okay

1747
01:09:57,440 --> 01:09:59,760
but we haven't said anything about

1748
01:09:59,760 --> 01:10:03,040
knowledge soundness just yet okay so

1749
01:10:03,040 --> 01:10:05,600
specifically it turns out that well

1750
01:10:05,600 --> 01:10:07,520
after the prover sees the verifier's

1751
01:10:07,520 --> 01:10:09,920
challenge it can try to do some trickery

1752
01:10:09,920 --> 01:10:11,120
to

1753
01:10:11,120 --> 01:10:13,360
try to compute a w that satisfies this

1754
01:10:13,360 --> 01:10:14,800
folded instance

1755
01:10:14,800 --> 01:10:16,719
without even knowing satisfying

1756
01:10:16,719 --> 01:10:20,239
witnesses w1 and w2 for the original two

1757
01:10:20,239 --> 01:10:21,360
instances

1758
01:10:21,360 --> 01:10:22,400
okay

1759
01:10:22,400 --> 01:10:24,640
so essentially that like what this boils

1760
01:10:24,640 --> 01:10:26,159
down to is the verifier can't actually

1761
01:10:26,159 --> 01:10:28,239
enforce that the prover is trying to

1762
01:10:28,239 --> 01:10:30,159
create w as a random linear combination

1763
01:10:30,159 --> 01:10:33,120
of its two inputs w one and w two

1764
01:10:33,120 --> 01:10:34,000
okay

1765
01:10:34,000 --> 01:10:37,840
and the other issue is that well because

1766
01:10:37,840 --> 01:10:38,560
e

1767
01:10:38,560 --> 01:10:40,719
is linear in the size of w just because

1768
01:10:40,719 --> 01:10:42,320
of how these dimensions work out in the

1769
01:10:42,320 --> 01:10:45,040
relaxed carbon cs statement um we have

1770
01:10:45,040 --> 01:10:46,880
that the verifier is not even succinct

1771
01:10:46,880 --> 01:10:48,320
okay so we could have gotten away with

1772
01:10:48,320 --> 01:10:49,679
the privilege of sending with a witness

1773
01:10:49,679 --> 01:10:51,280
and that would have been a more

1774
01:10:51,280 --> 01:10:53,760
efficient voting scheme okay so

1775
01:10:53,760 --> 01:10:56,159
how do we get around both of these

1776
01:10:56,159 --> 01:10:57,199
issues

1777
01:10:57,199 --> 01:10:58,640
right and here

1778
01:10:58,640 --> 01:11:01,440
we introduce uh succinct uh additively

1779
01:11:01,440 --> 01:11:03,600
homomorphic commitments think the

1780
01:11:03,600 --> 01:11:06,000
patterson scheme okay so specifically

1781
01:11:06,000 --> 01:11:07,600
the core idea as well instead of

1782
01:11:07,600 --> 01:11:09,360
throwing um

1783
01:11:09,360 --> 01:11:10,800
instead of exposing the verifier to both

1784
01:11:10,800 --> 01:11:13,199
these error vectors we're just going to

1785
01:11:13,199 --> 01:11:15,679
expose it to commitments to these error

1786
01:11:15,679 --> 01:11:17,360
vectors okay which are succinct and

1787
01:11:17,360 --> 01:11:19,120
small and instead the proof is going to

1788
01:11:19,120 --> 01:11:20,800
hold on to these error vectors in its

1789
01:11:20,800 --> 01:11:24,080
own uh witness okay and moreover we're

1790
01:11:24,080 --> 01:11:25,679
going to allow the verifier in the

1791
01:11:25,679 --> 01:11:27,280
statement to have

1792
01:11:27,280 --> 01:11:29,840
commitments to these two witnesses okay

1793
01:11:29,840 --> 01:11:32,000
and this allows the verifier to force

1794
01:11:32,000 --> 01:11:35,120
the approver to compute the new witness

1795
01:11:35,120 --> 01:11:37,840
as it chooses okay so specifically what

1796
01:11:37,840 --> 01:11:39,920
happens is now the approver just like

1797
01:11:39,920 --> 01:11:41,120
before

1798
01:11:41,120 --> 01:11:42,640
computes the new

1799
01:11:42,640 --> 01:11:45,040
list of cross terms okay but instead of

1800
01:11:45,040 --> 01:11:47,280
sending them directly sends over a

1801
01:11:47,280 --> 01:11:50,000
commitment to these lists of cross terms

1802
01:11:50,000 --> 01:11:51,840
okay and now the verifier sends back a

1803
01:11:51,840 --> 01:11:53,840
challenge they compute x and u as

1804
01:11:53,840 --> 01:11:57,040
expected and then the verifier now

1805
01:11:57,040 --> 01:12:01,120
computes the new commitments to w w bar

1806
01:12:01,120 --> 01:12:02,640
and e bar

1807
01:12:02,640 --> 01:12:05,280
okay and because of the way the verifier

1808
01:12:05,280 --> 01:12:06,640
computes these new commitments taking

1809
01:12:06,640 --> 01:12:09,280
advantage of the additive homomorphisms

1810
01:12:09,280 --> 01:12:12,080
the prover is forced to compute its

1811
01:12:12,080 --> 01:12:15,679
witnesses and its witnesses w and e in

1812
01:12:15,679 --> 01:12:19,040
just the right way okay so together they

1813
01:12:19,040 --> 01:12:21,600
output the new folded instance witness

1814
01:12:21,600 --> 01:12:22,640
pairs

1815
01:12:22,640 --> 01:12:24,400
now in our paper we show that well this

1816
01:12:24,400 --> 01:12:26,480
satisfies completeness and this also

1817
01:12:26,480 --> 01:12:29,760
satisfies knowledge soundness okay and

1818
01:12:29,760 --> 01:12:31,120
moreover

1819
01:12:31,120 --> 01:12:32,719
notice that if that commitment right

1820
01:12:32,719 --> 01:12:35,600
there is zero knowledge or sorry is is

1821
01:12:35,600 --> 01:12:38,080
hiding then we can achieve zero

1822
01:12:38,080 --> 01:12:41,760
knowledge for this scheme right here

1823
01:12:41,760 --> 01:12:43,440
okay so this concludes our entire

1824
01:12:43,440 --> 01:12:45,280
development um we've essentially

1825
01:12:45,280 --> 01:12:47,440
developed a folding scheme for np over

1826
01:12:47,440 --> 01:12:49,280
instances with the same structure

1827
01:12:49,280 --> 01:12:51,040
because we developed a voting scheme for

1828
01:12:51,040 --> 01:12:52,960
relaxed r1cs

1829
01:12:52,960 --> 01:12:55,199
okay so in summary now working bottom up

1830
01:12:55,199 --> 01:12:57,440
essentially what we've done is that we

1831
01:12:57,440 --> 01:13:00,159
designed a folding friendly variant of

1832
01:13:00,159 --> 01:13:03,679
r1cs called relaxed r1cs we then show

1833
01:13:03,679 --> 01:13:05,760
how to develop a folding scheme for

1834
01:13:05,760 --> 01:13:08,080
relaxed iron cs that's highly efficient

1835
01:13:08,080 --> 01:13:10,320
okay and then we use this phoning scheme

1836
01:13:10,320 --> 01:13:13,360
to develop a highly efficient ivc scheme

1837
01:13:13,360 --> 01:13:15,360
and because we cared about making each

1838
01:13:15,360 --> 01:13:18,400
of these steps as practical as possible

1839
01:13:18,400 --> 01:13:20,800
we achieve a recursive zk start with

1840
01:13:20,800 --> 01:13:25,199
state-of-the-art efficiency thank you

1841
01:13:29,600 --> 01:13:33,320
are there any questions

1842
01:13:34,640 --> 01:13:36,480
hi thank you for the great talk yeah i

1843
01:13:36,480 --> 01:13:38,960
have a question so instead of doing the

1844
01:13:38,960 --> 01:13:41,040
ex recursively and sequentially have you

1845
01:13:41,040 --> 01:13:45,040
considered uh doing for example a

1846
01:13:45,040 --> 01:13:47,280
wide version of the computation such as

1847
01:13:47,280 --> 01:13:49,440
the data parallel computation that's why

1848
01:13:49,440 --> 01:13:51,280
this scheme also works do you mean like

1849
01:13:51,280 --> 01:13:53,280
more like tree based recursion yes

1850
01:13:53,280 --> 01:13:55,600
apologies okay yeah so folding actually

1851
01:13:55,600 --> 01:13:57,760
is very specifically designed for this

1852
01:13:57,760 --> 01:14:00,080
straight line path um stuff it turns out

1853
01:14:00,080 --> 01:14:01,520
that when you try to extend folding

1854
01:14:01,520 --> 01:14:03,520
algebraically for

1855
01:14:03,520 --> 01:14:05,199
tree topologies maybe you end up with

1856
01:14:05,199 --> 01:14:07,679
these quadratic blow-ups um there are

1857
01:14:07,679 --> 01:14:08,560
other schemes out there like

1858
01:14:08,560 --> 01:14:09,840
accumulation schemes which might be

1859
01:14:09,840 --> 01:14:11,360
better designed for tree based

1860
01:14:11,360 --> 01:14:12,719
structures

1861
01:14:12,719 --> 01:14:15,040
thank you

1862
01:14:15,040 --> 01:14:18,920
speaker once again

1863
01:15:39,280 --> 01:15:42,159
um the last talk of the session is by zl

1864
01:15:42,159 --> 01:15:45,679
lang from um rice university on a new

1865
01:15:45,679 --> 01:15:47,520
approach to efficient non-malable xero

1866
01:15:47,520 --> 01:15:48,960
knowledge

1867
01:15:48,960 --> 01:15:51,280
hello everyone i'm here to share this

1868
01:15:51,280 --> 01:15:53,840
result let me start with the definition

1869
01:15:53,840 --> 01:15:55,280
for knowledgeable commitment and

1870
01:15:55,280 --> 01:15:57,040
knowledge about your knowledge

1871
01:15:57,040 --> 01:15:59,360
a phenomenal commitment we care about

1872
01:15:59,360 --> 01:16:01,600
the so-called mind middle execution of a

1873
01:16:01,600 --> 01:16:03,840
commitment protocol and

1874
01:16:03,840 --> 01:16:05,679
it has two parallel sessions you can

1875
01:16:05,679 --> 01:16:08,800
think of in this way in the left session

1876
01:16:08,800 --> 01:16:11,600
the honest committer is talking to the

1877
01:16:11,600 --> 01:16:13,280
my in the middle address three the

1878
01:16:13,280 --> 01:16:14,960
honest commenter commit to some message

1879
01:16:14,960 --> 01:16:15,760
m

1880
01:16:15,760 --> 01:16:18,640
and in the red communication the my

1881
01:16:18,640 --> 01:16:20,719
middle adversary plays the role of a

1882
01:16:20,719 --> 01:16:22,960
potentially malicious committer but he's

1883
01:16:22,960 --> 01:16:25,120
talking to an honest receiver

1884
01:16:25,120 --> 01:16:25,920
and

1885
01:16:25,920 --> 01:16:28,400
the goal of nominable commitment is to

1886
01:16:28,400 --> 01:16:30,400
make sure that the value committed by

1887
01:16:30,400 --> 01:16:33,199
the honest committer in the left

1888
01:16:33,199 --> 01:16:35,280
and the value committed by the middle

1889
01:16:35,280 --> 01:16:37,520
address 3 in red these two values should

1890
01:16:37,520 --> 01:16:40,719
be essentially independent

1891
01:16:41,600 --> 01:16:43,120
so

1892
01:16:43,120 --> 01:16:45,120
how do i want to capture this

1893
01:16:45,120 --> 01:16:47,600
requirement formally a

1894
01:16:47,600 --> 01:16:50,159
we will care about two values in the

1895
01:16:50,159 --> 01:16:52,640
main limit execution the first value is

1896
01:16:52,640 --> 01:16:53,840
just the

1897
01:16:53,840 --> 01:16:54,800
a

1898
01:16:54,800 --> 01:16:57,920
in the middle's view uh the second value

1899
01:16:57,920 --> 01:16:59,199
m

1900
01:16:59,199 --> 01:17:00,880
is the value you can think it as the

1901
01:17:00,880 --> 01:17:04,719
value statistically bound in the in the

1902
01:17:04,719 --> 01:17:05,920
in the

1903
01:17:05,920 --> 01:17:08,080
right communication for simplicity let's

1904
01:17:08,080 --> 01:17:10,159
focus on statistical banking scheme for

1905
01:17:10,159 --> 01:17:13,120
now and in this world we care about uh

1906
01:17:13,120 --> 01:17:15,280
the distribution of this tuple we

1907
01:17:15,280 --> 01:17:17,199
compare it with the

1908
01:17:17,199 --> 01:17:19,199
so-called simulation world

1909
01:17:19,199 --> 01:17:22,000
in this world we just replace the whole

1910
01:17:22,000 --> 01:17:24,719
left session by a simulator and this is

1911
01:17:24,719 --> 01:17:26,000
a little bit different from zero

1912
01:17:26,000 --> 01:17:27,920
knowledge this simulator it cannot

1913
01:17:27,920 --> 01:17:30,000
remind the honest receiver because the

1914
01:17:30,000 --> 01:17:32,080
receiver is honest but

1915
01:17:32,080 --> 01:17:33,920
it could run the mind mode sorry

1916
01:17:33,920 --> 01:17:36,480
internally and potentially rebuild him

1917
01:17:36,480 --> 01:17:37,600
so

1918
01:17:37,600 --> 01:17:39,520
well our requirement for this simulator

1919
01:17:39,520 --> 01:17:41,199
is a first line standard we just

1920
01:17:41,199 --> 01:17:42,560
required to be

1921
01:17:42,560 --> 01:17:43,600
efficient

1922
01:17:43,600 --> 01:17:44,640
but

1923
01:17:44,640 --> 01:17:47,120
importantly this simulator doesn't know

1924
01:17:47,120 --> 01:17:48,960
the value m

1925
01:17:48,960 --> 01:17:51,120
which is value committed by the

1926
01:17:51,120 --> 01:17:53,120
on this committee in the middle

1927
01:17:53,120 --> 01:17:54,400
execution

1928
01:17:54,400 --> 01:17:56,400
and we see that the protocol is

1929
01:17:56,400 --> 01:17:57,600
nominable

1930
01:17:57,600 --> 01:17:58,880
if this

1931
01:17:58,880 --> 01:18:00,640
if this simulator

1932
01:18:00,640 --> 01:18:02,880
if there exists such simulator that is

1933
01:18:02,880 --> 01:18:06,400
able to uh output a simulated tuple that

1934
01:18:06,400 --> 01:18:09,360
is indistinguishable from the one

1935
01:18:09,360 --> 01:18:11,840
coming from the minor mid execution so

1936
01:18:11,840 --> 01:18:14,960
here the intuition is the

1937
01:18:14,960 --> 01:18:17,360
what whatever the main middle can do in

1938
01:18:17,360 --> 01:18:19,840
the real world with the help of the left

1939
01:18:19,840 --> 01:18:22,560
honest commuter now can be done by an

1940
01:18:22,560 --> 01:18:24,800
efficient simulator

1941
01:18:24,800 --> 01:18:27,920
in this way the value committed in the

1942
01:18:27,920 --> 01:18:29,120
red session

1943
01:18:29,120 --> 01:18:30,960
should be independent of the value

1944
01:18:30,960 --> 01:18:32,719
committed in the last section because

1945
01:18:32,719 --> 01:18:34,640
this uh simulator doesn't know the exam

1946
01:18:34,640 --> 01:18:35,920
at all

1947
01:18:35,920 --> 01:18:36,640
so

1948
01:18:36,640 --> 01:18:38,560
if i just put the definition in this way

1949
01:18:38,560 --> 01:18:41,280
actually this definition is impossible

1950
01:18:41,280 --> 01:18:44,719
to achieve because there is a very

1951
01:18:44,719 --> 01:18:47,760
trivial but uh hard to deal with attack

1952
01:18:47,760 --> 01:18:51,440
so let's say the main middle just

1953
01:18:51,440 --> 01:18:53,280
relay the message from the left to the

1954
01:18:53,280 --> 01:18:56,159
right without any modification so in

1955
01:18:56,159 --> 01:18:58,560
this setting you can see that the value

1956
01:18:58,560 --> 01:19:00,719
committed in the left m and value

1957
01:19:00,719 --> 01:19:02,239
committed in the red i'm sure that

1958
01:19:02,239 --> 01:19:03,920
they'll be always equal this is a

1959
01:19:03,920 --> 01:19:05,840
non-trivial relation now they are depend

1960
01:19:05,840 --> 01:19:08,640
depending on each other however you will

1961
01:19:08,640 --> 01:19:10,719
never be able to simulate that in the in

1962
01:19:10,719 --> 01:19:12,640
this world because this simulator has no

1963
01:19:12,640 --> 01:19:15,520
information of this m at all so this is

1964
01:19:15,520 --> 01:19:17,360
something like

1965
01:19:17,360 --> 01:19:19,120
i think this is a definitional issue

1966
01:19:19,120 --> 01:19:21,520
like no matter how hard you try as long

1967
01:19:21,520 --> 01:19:23,199
as you said definition as the previous

1968
01:19:23,199 --> 01:19:24,560
one i've shown you you'll never be

1969
01:19:24,560 --> 01:19:26,560
achieving this definition so to deal

1970
01:19:26,560 --> 01:19:28,960
with this issue actually we will only

1971
01:19:28,960 --> 01:19:31,360
focus on something called identity based

1972
01:19:31,360 --> 01:19:33,360
commitment or someone called tech based

1973
01:19:33,360 --> 01:19:34,880
community this coming scheme you can't

1974
01:19:34,880 --> 01:19:37,520
think in this way for every execution of

1975
01:19:37,520 --> 01:19:40,560
the coming scheme there is a

1976
01:19:40,560 --> 01:19:42,800
id or tag integrated in the

1977
01:19:42,800 --> 01:19:45,280
communication so if you want to copy the

1978
01:19:45,280 --> 01:19:47,199
communication just like the trivial

1979
01:19:47,199 --> 01:19:48,960
adversary i described earlier for

1980
01:19:48,960 --> 01:19:51,280
information back and forth then you are

1981
01:19:51,280 --> 01:19:53,199
bound to copy id

1982
01:19:53,199 --> 01:19:55,120
and this can be done like

1983
01:19:55,120 --> 01:19:56,719
if you have one function you can easily

1984
01:19:56,719 --> 01:19:57,679
make a

1985
01:19:57,679 --> 01:20:00,400
a command scheme to be identity based so

1986
01:20:00,400 --> 01:20:02,719
so our initial definition is we focus on

1987
01:20:02,719 --> 01:20:05,040
identity based commitment scheme and we

1988
01:20:05,040 --> 01:20:06,800
only have this requirement

1989
01:20:06,800 --> 01:20:09,600
condition on the left session id and

1990
01:20:09,600 --> 01:20:11,679
rest session id are not the current

1991
01:20:11,679 --> 01:20:12,480
okay

1992
01:20:12,480 --> 01:20:14,080
now with the definition of a number of

1993
01:20:14,080 --> 01:20:15,760
equipment in mind it's now easy to

1994
01:20:15,760 --> 01:20:17,600
understand definition for about zero

1995
01:20:17,600 --> 01:20:19,760
knowledge so instead of considering the

1996
01:20:19,760 --> 01:20:21,760
minimum execution commitment scheme we

1997
01:20:21,760 --> 01:20:23,600
consider that for the

1998
01:20:23,600 --> 01:20:25,920
zero knowledge execution

1999
01:20:25,920 --> 01:20:27,840
again our intuition here is one to make

2000
01:20:27,840 --> 01:20:29,520
the

2001
01:20:29,520 --> 01:20:31,120
last session execution independent of

2002
01:20:31,120 --> 01:20:33,440
the last session so

2003
01:20:33,440 --> 01:20:35,280
what we do here is that we focus on the

2004
01:20:35,280 --> 01:20:37,920
value uh

2005
01:20:37,920 --> 01:20:39,920
this is the final output of the verifier

2006
01:20:39,920 --> 01:20:41,920
is a binary bit indicating if the wi-fi

2007
01:20:41,920 --> 01:20:44,480
accept or not and here we have this

2008
01:20:44,480 --> 01:20:45,920
emulator again the simulator is not

2009
01:20:45,920 --> 01:20:48,080
revolving the verifier but it it could

2010
01:20:48,080 --> 01:20:50,800
internally run the machine m and do some

2011
01:20:50,800 --> 01:20:51,920
uh

2012
01:20:51,920 --> 01:20:55,600
some some tasks to help help him to

2013
01:20:55,600 --> 01:20:57,120
force the verifier

2014
01:20:57,120 --> 01:20:59,120
it's again on this verifier

2015
01:20:59,120 --> 01:21:01,120
to output the b that is uh

2016
01:21:01,120 --> 01:21:03,520
conditionally indistinguishable from the

2017
01:21:03,520 --> 01:21:04,960
real world execution

2018
01:21:04,960 --> 01:21:07,840
the intuition is uh whatever the minor

2019
01:21:07,840 --> 01:21:10,080
middle can do here now it could be done

2020
01:21:10,080 --> 01:21:12,560
by the simulator without the help of the

2021
01:21:12,560 --> 01:21:14,480
of the left on this program so that

2022
01:21:14,480 --> 01:21:16,960
means uh that means uh

2023
01:21:16,960 --> 01:21:19,600
the nightmare s3 cannot prove any

2024
01:21:19,600 --> 01:21:21,679
statement that cannot arrange

2025
01:21:21,679 --> 01:21:23,679
meaning without help of the left

2026
01:21:23,679 --> 01:21:24,880
communication

2027
01:21:24,880 --> 01:21:27,040
that's our those are our definitions and

2028
01:21:27,040 --> 01:21:28,639
before going on i want to say that these

2029
01:21:28,639 --> 01:21:31,600
two notions nominate welcome and zk they

2030
01:21:31,600 --> 01:21:33,760
are pretty useful a number of equipment

2031
01:21:33,760 --> 01:21:36,960
has been helped us to reduce the run

2032
01:21:36,960 --> 01:21:38,960
complexity of mpc

2033
01:21:38,960 --> 01:21:41,199
protocols and also the numerable zero

2034
01:21:41,199 --> 01:21:44,159
knowledge gave us a better concurrently

2035
01:21:44,159 --> 01:21:46,320
secure npc protocols

2036
01:21:46,320 --> 01:21:48,800
so let's look at let's look at the state

2037
01:21:48,800 --> 01:21:50,639
of the arts for

2038
01:21:50,639 --> 01:21:52,320
the other theoretical side things are

2039
01:21:52,320 --> 01:21:55,040
very beautiful a after long-term

2040
01:21:55,040 --> 01:21:57,040
research we eventually get the constant

2041
01:21:57,040 --> 01:21:58,480
run constructions from the minimal

2042
01:21:58,480 --> 01:22:00,960
assumption one functions

2043
01:22:00,960 --> 01:22:04,719
in practice we do have a very efficient

2044
01:22:04,719 --> 01:22:07,040
construction for normal equipment it's a

2045
01:22:07,040 --> 01:22:09,280
bgr v15 protocol

2046
01:22:09,280 --> 01:22:11,600
this is the ccs paper it actually

2047
01:22:11,600 --> 01:22:15,920
implements an earlier result by grv

2048
01:22:15,920 --> 01:22:18,000
it is based on ddh

2049
01:22:18,000 --> 01:22:19,920
it gives you a very fast implementation

2050
01:22:19,920 --> 01:22:22,159
however the situation for non-variable

2051
01:22:22,159 --> 01:22:24,639
zero knowledge is less satisfactory

2052
01:22:24,639 --> 01:22:26,159
there's basically no reported

2053
01:22:26,159 --> 01:22:29,520
implications at all before resort a

2054
01:22:29,520 --> 01:22:30,639
for those who are familiar with the

2055
01:22:30,639 --> 01:22:32,320
literature you may realize that okay

2056
01:22:32,320 --> 01:22:34,159
there is a standard transformation uh

2057
01:22:34,159 --> 01:22:36,400
going from nominal commitment to nominal

2058
01:22:36,400 --> 01:22:38,639
zero knowledge it's simple it's just

2059
01:22:38,639 --> 01:22:40,719
a ask proverb to commit the witness

2060
01:22:40,719 --> 01:22:43,040
using a nominal document and then you

2061
01:22:43,040 --> 01:22:45,440
just use the standard zero knowledge to

2062
01:22:45,440 --> 01:22:47,600
prove that the committed value is indeed

2063
01:22:47,600 --> 01:22:49,760
the value business

2064
01:22:49,760 --> 01:22:52,960
for this protocol uh actually the first

2065
01:22:52,960 --> 01:22:54,960
step is coming down very fast for

2066
01:22:54,960 --> 01:22:58,000
example you just use the pgrv15

2067
01:22:58,000 --> 01:23:00,320
as your underlying implementation but

2068
01:23:00,320 --> 01:23:03,440
the issue happens at the second step

2069
01:23:03,440 --> 01:23:06,480
because you are proving something about

2070
01:23:06,480 --> 01:23:08,880
a non-valuable equipment this number of

2071
01:23:08,880 --> 01:23:11,199
equipment is very complicated it's not

2072
01:23:11,199 --> 01:23:12,080
like

2073
01:23:12,080 --> 01:23:13,760
as small as an hour it has a large

2074
01:23:13,760 --> 01:23:15,600
circuit implementation and if you want

2075
01:23:15,600 --> 01:23:17,600
to do that it takes four reasonable

2076
01:23:17,600 --> 01:23:19,679
parameters it will take more than three

2077
01:23:19,679 --> 01:23:20,880
minutes

2078
01:23:20,880 --> 01:23:22,880
so that's uh basically the current

2079
01:23:22,880 --> 01:23:25,440
situation so

2080
01:23:25,440 --> 01:23:28,000
our result here is we give the first uh

2081
01:23:28,000 --> 01:23:29,199
practical

2082
01:23:29,199 --> 01:23:31,280
enemy key protocol in the play model

2083
01:23:31,280 --> 01:23:33,120
meaning without any sap

2084
01:23:33,120 --> 01:23:35,920
and we only need symmetrical exceptions

2085
01:23:35,920 --> 01:23:38,239
basically one function plus a clean

2086
01:23:38,239 --> 01:23:40,639
recent hash

2087
01:23:40,639 --> 01:23:43,360
also our technique also implies the

2088
01:23:43,360 --> 01:23:44,320
first

2089
01:23:44,320 --> 01:23:46,960
practical number of equivalent

2090
01:23:46,960 --> 01:23:49,040
that is from symmetry consumption only

2091
01:23:49,040 --> 01:23:51,360
this is in contrast to the previous bgrv

2092
01:23:51,360 --> 01:23:53,840
paper i mentioned which is based on ddh

2093
01:23:53,840 --> 01:23:55,360
yeah

2094
01:23:55,360 --> 01:23:57,120
now

2095
01:23:57,120 --> 01:23:58,880
in the following i will talk about our

2096
01:23:58,880 --> 01:24:00,800
techniques and by the time

2097
01:24:00,800 --> 01:24:03,360
by the organization like this we first

2098
01:24:03,360 --> 01:24:05,760
built a i'll first describe a new

2099
01:24:05,760 --> 01:24:07,360
template for nominable zero knowledge

2100
01:24:07,360 --> 01:24:09,120
protocol if you just care about

2101
01:24:09,120 --> 01:24:11,440
impossibility results there are several

2102
01:24:11,440 --> 01:24:13,920
ways to do that but uh we'll show you a

2103
01:24:13,920 --> 01:24:15,840
specific one that has the potential to

2104
01:24:15,840 --> 01:24:17,920
be implemented efficiently

2105
01:24:17,920 --> 01:24:19,600
once you have this template

2106
01:24:19,600 --> 01:24:21,360
we will identify the efficiency

2107
01:24:21,360 --> 01:24:24,159
bottlenecks if you want to implement it

2108
01:24:24,159 --> 01:24:26,239
and then we will

2109
01:24:26,239 --> 01:24:28,159
show some new ideas

2110
01:24:28,159 --> 01:24:28,960
to

2111
01:24:28,960 --> 01:24:30,800
to deal with the bottlenecks and

2112
01:24:30,800 --> 01:24:33,600
eventually get a efficient protocol here

2113
01:24:33,600 --> 01:24:35,600
comes the catch

2114
01:24:35,600 --> 01:24:36,960
we start with the numerable zero

2115
01:24:36,960 --> 01:24:39,040
knowledge protocol but because of the

2116
01:24:39,040 --> 01:24:41,760
new ideas we use to make it efficient

2117
01:24:41,760 --> 01:24:44,320
at the end we lose numerability so we

2118
01:24:44,320 --> 01:24:46,639
all we only managed to prove that it's a

2119
01:24:46,639 --> 01:24:48,639
simulation sound your knowledge i only

2120
01:24:48,639 --> 01:24:51,199
define this notion formally here

2121
01:24:51,199 --> 01:24:53,360
but i just want to mention that

2122
01:24:53,360 --> 01:24:55,840
this is a very useful notion it's

2123
01:24:55,840 --> 01:24:58,400
incomparable to normal ability but

2124
01:24:58,400 --> 01:25:01,440
i would say for 99

2125
01:25:01,440 --> 01:25:04,639
times a as long as the numerable zero

2126
01:25:04,639 --> 01:25:06,159
knowledge works you can't replace

2127
01:25:06,159 --> 01:25:07,600
numerical zero knowledge with simulation

2128
01:25:07,600 --> 01:25:09,520
standard knowledge and it will still

2129
01:25:09,520 --> 01:25:10,560
work

2130
01:25:10,560 --> 01:25:12,719
but but anyway

2131
01:25:12,719 --> 01:25:14,480
as long as you have simulations on all

2132
01:25:14,480 --> 01:25:15,920
these there are standard transformations

2133
01:25:15,920 --> 01:25:17,360
to make it uh

2134
01:25:17,360 --> 01:25:19,199
to give you normal level zk and also

2135
01:25:19,199 --> 01:25:22,400
nominal commitment and uh and preserve

2136
01:25:22,400 --> 01:25:24,880
the free dropping efficiency

2137
01:25:24,880 --> 01:25:26,800
so let me start with this template this

2138
01:25:26,800 --> 01:25:29,120
construction uh actually is a very

2139
01:25:29,120 --> 01:25:30,159
simple

2140
01:25:30,159 --> 01:25:31,600
first uh

2141
01:25:31,600 --> 01:25:34,159
the verifier commit to a random string

2142
01:25:34,159 --> 01:25:36,239
of a length of security parameter use

2143
01:25:36,239 --> 01:25:38,639
the extract for equipment

2144
01:25:38,639 --> 01:25:41,040
next the proverb

2145
01:25:41,040 --> 01:25:43,040
commit to a

2146
01:25:43,040 --> 01:25:46,719
string sigma prime using the enmc emc is

2147
01:25:46,719 --> 01:25:48,719
a basically nominable cleaning scheme

2148
01:25:48,719 --> 01:25:53,040
but it also it is also extractable and

2149
01:25:53,040 --> 01:25:56,560
next uh the verifier will dig meet the

2150
01:25:56,560 --> 01:25:58,880
sigma he committed in the first stage

2151
01:25:58,880 --> 01:26:00,719
and eventually we give a

2152
01:26:00,719 --> 01:26:02,800
statistician w-i-o-k a very

2153
01:26:02,800 --> 01:26:05,199
indistinguishable argument knowledge uh

2154
01:26:05,199 --> 01:26:07,280
where the proper proof that okay i know

2155
01:26:07,280 --> 01:26:09,520
witness of the

2156
01:26:09,520 --> 01:26:12,000
of the statement i'm trying to prove or

2157
01:26:12,000 --> 01:26:14,560
i actually set sigma prime sigma prime

2158
01:26:14,560 --> 01:26:16,080
to be the value of sigma the very far

2159
01:26:16,080 --> 01:26:17,280
committed before

2160
01:26:17,280 --> 01:26:19,440
this paradigm looks i mean everyone

2161
01:26:19,440 --> 01:26:21,440
should be very familiar with this just

2162
01:26:21,440 --> 01:26:23,440
uh looks very familiar similar to

2163
01:26:23,440 --> 01:26:25,120
ferguson

2164
01:26:25,120 --> 01:26:28,400
or fsfs paradigm so the intuition here

2165
01:26:28,400 --> 01:26:31,120
is the verifier setup chapter

2166
01:26:31,120 --> 01:26:32,239
and

2167
01:26:32,239 --> 01:26:34,080
if you are able to learn this sigma

2168
01:26:34,080 --> 01:26:36,800
somehow and commit sigma prime equals

2169
01:26:36,800 --> 01:26:39,040
sigma then you don't need to to do this

2170
01:26:39,040 --> 01:26:40,400
part honestly you don't need to know

2171
01:26:40,400 --> 01:26:42,480
witness you just use the chapter that's

2172
01:26:42,480 --> 01:26:43,920
actually how symmetrical works if you

2173
01:26:43,920 --> 01:26:45,440
want to prove this protocol user

2174
01:26:45,440 --> 01:26:48,480
knowledge but first one is we know that

2175
01:26:48,480 --> 01:26:50,400
a malicious proverb

2176
01:26:50,400 --> 01:26:52,400
will never learn this stigma before the

2177
01:26:52,400 --> 01:26:54,880
verified meet so it's done

2178
01:26:54,880 --> 01:26:57,040
uh we've seen this uh kind of structure

2179
01:26:57,040 --> 01:27:00,400
a lot of times but here are the the the

2180
01:27:00,400 --> 01:27:02,400
main differences for this stage we are

2181
01:27:02,400 --> 01:27:04,239
using the normal level equipment

2182
01:27:04,239 --> 01:27:06,960
and that this is actually what by us

2183
01:27:06,960 --> 01:27:09,040
normal about your knowledge

2184
01:27:09,040 --> 01:27:10,560
so

2185
01:27:10,560 --> 01:27:12,560
i don't want to get your lunch delayed

2186
01:27:12,560 --> 01:27:14,480
so i'll give you one page security proof

2187
01:27:14,480 --> 01:27:16,880
showing many of the intuition uh so

2188
01:27:16,880 --> 01:27:19,360
intuition here is a this is nothing but

2189
01:27:19,360 --> 01:27:20,880
the minor middle execution of our

2190
01:27:20,880 --> 01:27:21,840
protocol

2191
01:27:21,840 --> 01:27:24,080
what we want to show is uh

2192
01:27:24,080 --> 01:27:26,960
the left a direct execution and the left

2193
01:27:26,960 --> 01:27:28,719
execution are independent

2194
01:27:28,719 --> 01:27:31,760
so what we do is we want to make the

2195
01:27:31,760 --> 01:27:33,920
left communication

2196
01:27:33,920 --> 01:27:35,600
independent of the

2197
01:27:35,600 --> 01:27:37,199
awareness

2198
01:27:37,199 --> 01:27:38,639
and we

2199
01:27:38,639 --> 01:27:40,320
meanwhile we make sure that the

2200
01:27:40,320 --> 01:27:42,239
adversary commits the verifier with the

2201
01:27:42,239 --> 01:27:44,560
same probability if we if we manage to

2202
01:27:44,560 --> 01:27:46,400
do this that means a

2203
01:27:46,400 --> 01:27:47,840
red communication

2204
01:27:47,840 --> 01:27:49,600
that means the left communication

2205
01:27:49,600 --> 01:27:52,719
doesn't help at all right so to do that

2206
01:27:52,719 --> 01:27:54,800
we're just doing what you would do for

2207
01:27:54,800 --> 01:27:56,320
uh variation measure knowledge we

2208
01:27:56,320 --> 01:27:59,760
extract the chapter and then

2209
01:27:59,760 --> 01:28:01,440
commit to the chapter instead of all

2210
01:28:01,440 --> 01:28:02,960
your streams

2211
01:28:02,960 --> 01:28:05,360
previously on probably using windows now

2212
01:28:05,360 --> 01:28:07,040
we have a trapdoor we switch that we

2213
01:28:07,040 --> 01:28:08,800
switch to the chapter in this

2214
01:28:08,800 --> 01:28:10,960
so

2215
01:28:10,960 --> 01:28:12,880
there is only like one point i want to

2216
01:28:12,880 --> 01:28:14,480
mention actually

2217
01:28:14,480 --> 01:28:17,679
the only risk for doing so is uh

2218
01:28:17,679 --> 01:28:18,719
we are

2219
01:28:18,719 --> 01:28:21,040
extract capital and commit in commit to

2220
01:28:21,040 --> 01:28:23,920
it in the last session however

2221
01:28:23,920 --> 01:28:25,440
nothing stops the mind in the middle

2222
01:28:25,440 --> 01:28:27,280
adversary to perform the same thing in

2223
01:28:27,280 --> 01:28:29,440
the rest station right

2224
01:28:29,440 --> 01:28:31,280
he could also potentially extract the

2225
01:28:31,280 --> 01:28:32,719
sigma tuber and come into the sigma

2226
01:28:32,719 --> 01:28:33,840
tudor

2227
01:28:33,840 --> 01:28:37,600
if his if he is able to do that

2228
01:28:37,600 --> 01:28:39,840
you cannot say he's using the w to the

2229
01:28:39,840 --> 01:28:41,520
in this stage right

2230
01:28:41,520 --> 01:28:45,040
so but this is actually exactly what the

2231
01:28:45,040 --> 01:28:47,440
a non-valuable commitment captured in

2232
01:28:47,440 --> 01:28:48,800
the second stage

2233
01:28:48,800 --> 01:28:51,199
the nominable equipment definition tells

2234
01:28:51,199 --> 01:28:54,080
us that if we switch the value sigma to

2235
01:28:54,080 --> 01:28:55,600
a sigma prime

2236
01:28:55,600 --> 01:28:56,560
the

2237
01:28:56,560 --> 01:28:58,639
man in the middle cannot switch the

2238
01:28:58,639 --> 01:29:00,800
value he committed here otherwise that

2239
01:29:00,800 --> 01:29:03,040
means his value coming here is dependent

2240
01:29:03,040 --> 01:29:05,920
on the value we commit in the left

2241
01:29:05,920 --> 01:29:08,320
so because of this uh because of the

2242
01:29:08,320 --> 01:29:10,960
numerability of this commitment stage

2243
01:29:10,960 --> 01:29:12,639
actually we can't do this change but my

2244
01:29:12,639 --> 01:29:14,800
middle cannot so here's the probability

2245
01:29:14,800 --> 01:29:16,560
of commissioner bar in the red won't

2246
01:29:16,560 --> 01:29:17,520
change

2247
01:29:17,520 --> 01:29:19,440
so

2248
01:29:19,440 --> 01:29:21,520
now here comes the real meat i will talk

2249
01:29:21,520 --> 01:29:23,040
about how to make this protocol

2250
01:29:23,040 --> 01:29:26,080
efficient if you stare at stare at this

2251
01:29:26,080 --> 01:29:27,440
protocol for a few seconds you'll

2252
01:29:27,440 --> 01:29:28,880
realize that there are only two

2253
01:29:28,880 --> 01:29:31,920
efficiency bottleneck the first one is

2254
01:29:31,920 --> 01:29:34,000
this normal welcome stage and the second

2255
01:29:34,000 --> 01:29:35,280
one is this

2256
01:29:35,280 --> 01:29:37,679
a statistical

2257
01:29:37,679 --> 01:29:38,719
um

2258
01:29:38,719 --> 01:29:40,239
we'll address them one by one we'll

2259
01:29:40,239 --> 01:29:42,639
start with the last stage this protocol

2260
01:29:42,639 --> 01:29:44,400
uh first i want to

2261
01:29:44,400 --> 01:29:46,880
say that you see it has two states uh it

2262
01:29:46,880 --> 01:29:48,320
it's there are composition of two

2263
01:29:48,320 --> 01:29:50,000
statements right but for the first

2264
01:29:50,000 --> 01:29:51,440
statement this is something we have to

2265
01:29:51,440 --> 01:29:53,280
do because at least enormous your

2266
01:29:53,280 --> 01:29:55,199
knowledge is your knowledge

2267
01:29:55,199 --> 01:29:57,920
your goal is to prove uh a statement

2268
01:29:57,920 --> 01:29:59,520
this is the price you have to pay

2269
01:29:59,520 --> 01:30:01,440
however the second part of our statement

2270
01:30:01,440 --> 01:30:02,719
is something

2271
01:30:02,719 --> 01:30:05,199
by us normal ability so we should we

2272
01:30:05,199 --> 01:30:07,679
should we should like uh make his cost

2273
01:30:07,679 --> 01:30:09,199
as small as possible

2274
01:30:09,199 --> 01:30:10,960
so

2275
01:30:10,960 --> 01:30:12,400
the

2276
01:30:12,400 --> 01:30:15,760
naive way to do that is uh okay i just

2277
01:30:15,760 --> 01:30:18,320
uh view this as an mp statement and use

2278
01:30:18,320 --> 01:30:20,800
the state of art faster zero knowledge

2279
01:30:20,800 --> 01:30:22,560
implementation for example the geralt

2280
01:30:22,560 --> 01:30:25,440
protocol by hiv

2281
01:30:25,440 --> 01:30:27,440
this turns out to be slow for the same

2282
01:30:27,440 --> 01:30:30,480
reason because this statement need to

2283
01:30:30,480 --> 01:30:33,360
this statement is actually about the a

2284
01:30:33,360 --> 01:30:35,120
number of equipment which has a large

2285
01:30:35,120 --> 01:30:37,520
subject description so our solution here

2286
01:30:37,520 --> 01:30:39,840
is try to use the old composition

2287
01:30:39,840 --> 01:30:42,239
technique developed for sigma protocols

2288
01:30:42,239 --> 01:30:44,719
originally by cds and t4

2289
01:30:44,719 --> 01:30:46,560
so let me briefly recall definition of

2290
01:30:46,560 --> 01:30:49,120
sigma protocols um

2291
01:30:49,120 --> 01:30:50,400
but now i would just say it's a

2292
01:30:50,400 --> 01:30:52,320
three-round public coin protocol it's

2293
01:30:52,320 --> 01:30:54,560
honestly very very fair your knowledge

2294
01:30:54,560 --> 01:30:57,920
and it's also wi and i know that

2295
01:30:57,920 --> 01:30:59,600
we have actual requirement for example

2296
01:30:59,600 --> 01:31:01,120
special service but it's not that

2297
01:31:01,120 --> 01:31:03,360
important for this talk okay so let's so

2298
01:31:03,360 --> 01:31:04,159
let's

2299
01:31:04,159 --> 01:31:07,760
ignore that for a little while so the

2300
01:31:07,760 --> 01:31:10,480
the the cbs technique is for uh to give

2301
01:31:10,480 --> 01:31:12,159
you an efficient way to prove or

2302
01:31:12,159 --> 01:31:15,600
composition statement of this form so

2303
01:31:15,600 --> 01:31:18,480
if you want to perform this task um the

2304
01:31:18,480 --> 01:31:21,360
naive way is that you just view x or x

2305
01:31:21,360 --> 01:31:23,040
prime as a

2306
01:31:23,040 --> 01:31:24,880
as a single instance and run the

2307
01:31:24,880 --> 01:31:27,360
original protocol right but that that

2308
01:31:27,360 --> 01:31:29,040
could be i mean

2309
01:31:29,040 --> 01:31:30,639
that could be large you need to reduce

2310
01:31:30,639 --> 01:31:33,440
this uh or composition to an empty

2311
01:31:33,440 --> 01:31:35,440
statement and that could blow up the

2312
01:31:35,440 --> 01:31:36,960
size of the statement

2313
01:31:36,960 --> 01:31:37,760
so

2314
01:31:37,760 --> 01:31:39,840
cds is an alternative way to do that it

2315
01:31:39,840 --> 01:31:42,080
basically it allows you to do that with

2316
01:31:42,080 --> 01:31:44,960
a cost of two times the sigma protocol

2317
01:31:44,960 --> 01:31:48,320
for a single statement at the most but

2318
01:31:48,320 --> 01:31:50,000
what what the problem do here is

2319
01:31:50,000 --> 01:31:51,679
actually you can think of this as two

2320
01:31:51,679 --> 01:31:54,639
parallel execution of the zebra protocol

2321
01:31:54,639 --> 01:31:56,320
in for now let's assume this is a

2322
01:31:56,320 --> 01:31:59,199
witness for x to prove this oxygen and

2323
01:31:59,199 --> 01:32:01,440
just need to know one winning thread so

2324
01:32:01,440 --> 01:32:03,920
in the left session the proverb play

2325
01:32:03,920 --> 01:32:06,639
honestly using witness w because he has

2326
01:32:06,639 --> 01:32:09,840
witness w then in the red session the

2327
01:32:09,840 --> 01:32:11,920
proverb is going to use the honest

2328
01:32:11,920 --> 01:32:13,440
verifier simulator

2329
01:32:13,440 --> 01:32:16,719
so to use on this verifier simulator

2330
01:32:16,719 --> 01:32:19,440
so the simulator will want to sample the

2331
01:32:19,440 --> 01:32:21,199
challenge or public point chain string

2332
01:32:21,199 --> 01:32:22,560
right but

2333
01:32:22,560 --> 01:32:25,280
if you just do it naively like meaning

2334
01:32:25,280 --> 01:32:27,520
you ask the verifier to give you

2335
01:32:27,520 --> 01:32:30,080
uh beta and beta prime then you don't

2336
01:32:30,080 --> 01:32:33,120
have you you cannot use the beta prime

2337
01:32:33,120 --> 01:32:35,600
chosen by the verifier so what we what

2338
01:32:35,600 --> 01:32:37,840
should we do now the idea is that we

2339
01:32:37,840 --> 01:32:40,239
just combine these two challenge stream

2340
01:32:40,239 --> 01:32:42,880
beta and bed prime to be a unique stream

2341
01:32:42,880 --> 01:32:44,880
and ask verifier to sample unix stream

2342
01:32:44,880 --> 01:32:46,960
to the program the prover would give

2343
01:32:46,960 --> 01:32:49,920
approval the choice to decompose it as

2344
01:32:49,920 --> 01:32:52,480
an extra of to run streams

2345
01:32:52,480 --> 01:32:55,040
so in this way actually the plural can

2346
01:32:55,040 --> 01:32:57,679
run the simulator for the red session

2347
01:32:57,679 --> 01:33:00,080
first and the respirator will sample

2348
01:33:00,080 --> 01:33:02,159
beta prime and

2349
01:33:02,159 --> 01:33:04,480
you will just use that beta prime as a

2350
01:33:04,480 --> 01:33:06,800
share here and then the remaining share

2351
01:33:06,800 --> 01:33:09,920
beta can be computed as a beta prime x

2352
01:33:09,920 --> 01:33:12,480
or beta hat which is the constraint

2353
01:33:12,480 --> 01:33:14,560
chosen by the verifier and

2354
01:33:14,560 --> 01:33:17,040
in this way you lose control of beta

2355
01:33:17,040 --> 01:33:19,760
but it's okay because beta is a part

2356
01:33:19,760 --> 01:33:21,920
you're gonna beta will be viewed as a

2357
01:33:21,920 --> 01:33:23,679
challenge for the left interaction for

2358
01:33:23,679 --> 01:33:25,120
which you have the witness you can enter

2359
01:33:25,120 --> 01:33:28,000
any change so that's how uh that's how

2360
01:33:28,000 --> 01:33:30,480
this uh or competition idea works

2361
01:33:30,480 --> 01:33:32,480
and as you can see

2362
01:33:32,480 --> 01:33:34,480
the only cost you pay is actually the

2363
01:33:34,480 --> 01:33:35,679
proof for the

2364
01:33:35,679 --> 01:33:37,199
left session for the rest session you

2365
01:33:37,199 --> 01:33:38,880
are in a simulator if you pick some

2366
01:33:38,880 --> 01:33:42,400
particular sigma protocol which has a

2367
01:33:42,400 --> 01:33:44,880
very fast answer for simulator this

2368
01:33:44,880 --> 01:33:46,480
protocol could be very fast

2369
01:33:46,480 --> 01:33:48,800
and that's what we do

2370
01:33:48,800 --> 01:33:51,920
here is our or competition statement and

2371
01:33:51,920 --> 01:33:56,239
uh we will pick see this ligero as our

2372
01:33:56,239 --> 01:33:59,040
underlying sigma protocol and

2373
01:33:59,040 --> 01:34:01,360
implementing this idea

2374
01:34:01,360 --> 01:34:04,000
so your cost will be just the proof for

2375
01:34:04,000 --> 01:34:04,719
a

2376
01:34:04,719 --> 01:34:06,960
a for this the first part of the or

2377
01:34:06,960 --> 01:34:08,480
statement which is something you cannot

2378
01:34:08,480 --> 01:34:09,760
avoid right

2379
01:34:09,760 --> 01:34:12,000
and the simulator okay to give you more

2380
01:34:12,000 --> 01:34:16,800
information the hiv ahie is based on a

2381
01:34:16,800 --> 01:34:18,960
zero knowledge pcp and then follow

2382
01:34:18,960 --> 01:34:21,679
following the the the killian approach

2383
01:34:21,679 --> 01:34:23,199
uh

2384
01:34:23,199 --> 01:34:25,600
for this kind of a pcp based protocol

2385
01:34:25,600 --> 01:34:27,360
it's it's it's slow if you want to

2386
01:34:27,360 --> 01:34:29,760
generate the pcp but it's easy to

2387
01:34:29,760 --> 01:34:31,920
simulate it's nothing but just a random

2388
01:34:31,920 --> 01:34:34,880
openings of a merkle tree path so that's

2389
01:34:34,880 --> 01:34:37,040
very fast

2390
01:34:37,040 --> 01:34:40,000
okay here i want to mention caveat

2391
01:34:40,000 --> 01:34:42,560
what i said it looks very like it sounds

2392
01:34:42,560 --> 01:34:45,280
very good but however legal protocol is

2393
01:34:45,280 --> 01:34:47,199
not a signal protocol the main

2394
01:34:47,199 --> 01:34:49,360
difference is that this sigma protocol

2395
01:34:49,360 --> 01:34:51,199
is three wrong it has basically one

2396
01:34:51,199 --> 01:34:53,760
challenge response slot beta and gamma

2397
01:34:53,760 --> 01:34:56,480
but ligero actually it has two chinese

2398
01:34:56,480 --> 01:34:58,880
stars you can think of fixed alpha then

2399
01:34:58,880 --> 01:35:01,119
beta 1 gamma 1 beta 2 gamma 2. for this

2400
01:35:01,119 --> 01:35:03,440
kind of protocols

2401
01:35:03,440 --> 01:35:05,360
it comes well known that

2402
01:35:05,360 --> 01:35:08,239
this cbs or competition doesn't work

2403
01:35:08,239 --> 01:35:10,239
especially like i think people working

2404
01:35:10,239 --> 01:35:12,719
in signature they will face this problem

2405
01:35:12,719 --> 01:35:14,880
but in this work we do develop the

2406
01:35:14,880 --> 01:35:17,920
method it's kind of general to deal with

2407
01:35:17,920 --> 01:35:20,560
like a multiple change response slot

2408
01:35:20,560 --> 01:35:22,800
protocols uh how do we do our

2409
01:35:22,800 --> 01:35:24,320
combination for them but unfortunately i

2410
01:35:24,320 --> 01:35:25,520
don't have time to talk about that you

2411
01:35:25,520 --> 01:35:27,679
can check our paper for details but

2412
01:35:27,679 --> 01:35:29,760
that's an idea how we make this last

2413
01:35:29,760 --> 01:35:31,280
stage efficient

2414
01:35:31,280 --> 01:35:34,320
let's say or completion next the

2415
01:35:34,320 --> 01:35:36,080
emmc stage

2416
01:35:36,080 --> 01:35:37,760
first i need to open this date and show

2417
01:35:37,760 --> 01:35:39,360
you the structure this is the

2418
01:35:39,360 --> 01:35:42,000
construction by pgrb and you don't need

2419
01:35:42,000 --> 01:35:43,520
to understand what it's doing i just

2420
01:35:43,520 --> 01:35:44,800
want to show you a structure it's

2421
01:35:44,800 --> 01:35:47,119
nothing but the commuter commit to some

2422
01:35:47,119 --> 01:35:50,960
field elements and then the the receiver

2423
01:35:50,960 --> 01:35:52,639
send challenge which is also fuel

2424
01:35:52,639 --> 01:35:55,760
elements and then the commuter uh the

2425
01:35:55,760 --> 01:35:57,600
commuter just a response with again a

2426
01:35:57,600 --> 01:35:58,880
few admins

2427
01:35:58,880 --> 01:36:00,880
finally you prove some inner product

2428
01:36:00,880 --> 01:36:02,800
relationship so

2429
01:36:02,800 --> 01:36:04,719
for this structure

2430
01:36:04,719 --> 01:36:05,760
a

2431
01:36:05,760 --> 01:36:09,360
why pgrb is fast the reason is they pick

2432
01:36:09,360 --> 01:36:11,520
algebra big assumptions and take

2433
01:36:11,520 --> 01:36:12,800
advantage of that for example their

2434
01:36:12,800 --> 01:36:14,719
equipment is some kind of variant of l

2435
01:36:14,719 --> 01:36:16,560
gamma encryption and their zero

2436
01:36:16,560 --> 01:36:19,040
knowledge is uh basically schuner's uh

2437
01:36:19,040 --> 01:36:20,880
identification scheme or not zero

2438
01:36:20,880 --> 01:36:22,320
knowledge so

2439
01:36:22,320 --> 01:36:24,400
these two things go together very well

2440
01:36:24,400 --> 01:36:26,159
so they eventually have a very fast

2441
01:36:26,159 --> 01:36:28,800
implementation but now we are

2442
01:36:28,800 --> 01:36:30,480
like we only want to use magic

2443
01:36:30,480 --> 01:36:32,320
constructions the naive way to do that

2444
01:36:32,320 --> 01:36:34,080
is you just replace all the equipment

2445
01:36:34,080 --> 01:36:36,560
use the aes based command and then you

2446
01:36:36,560 --> 01:36:38,960
use the ligera general process dk to do

2447
01:36:38,960 --> 01:36:40,239
this proof

2448
01:36:40,239 --> 01:36:42,480
again very slow because the

2449
01:36:42,480 --> 01:36:44,560
circuit size is large

2450
01:36:44,560 --> 01:36:45,520
so

2451
01:36:45,520 --> 01:36:46,719
our idea

2452
01:36:46,719 --> 01:36:48,800
here is like we want to reduce the new

2453
01:36:48,800 --> 01:36:50,480
problem to the one we've already solved

2454
01:36:50,480 --> 01:36:52,560
right so we just show how to make this

2455
01:36:52,560 --> 01:36:54,639
part fast by our composition can we

2456
01:36:54,639 --> 01:36:56,800
review the idea here

2457
01:36:56,800 --> 01:36:59,280
at first glance is unclear because uh

2458
01:36:59,280 --> 01:37:01,520
this is not an or statement it's just we

2459
01:37:01,520 --> 01:37:02,960
oh they said we call it proof of

2460
01:37:02,960 --> 01:37:04,400
consistency it's just a zero-knowledge

2461
01:37:04,400 --> 01:37:06,719
proof there's no other thing but

2462
01:37:06,719 --> 01:37:09,440
to review the idea just augment it let's

2463
01:37:09,440 --> 01:37:10,800
say this is a non-valuable kind of

2464
01:37:10,800 --> 01:37:12,560
scheme now

2465
01:37:12,560 --> 01:37:15,520
we additionally give the commuter a

2466
01:37:15,520 --> 01:37:17,840
witness and a sediment pair

2467
01:37:17,840 --> 01:37:20,400
and we modify this zk argument

2468
01:37:20,400 --> 01:37:22,320
to prove the original consistency

2469
01:37:22,320 --> 01:37:24,159
condition and also

2470
01:37:24,159 --> 01:37:25,280
you can

2471
01:37:25,280 --> 01:37:27,280
this or condition you just prove x in

2472
01:37:27,280 --> 01:37:30,400
the language so if if you would give the

2473
01:37:30,400 --> 01:37:32,560
commutator a choice if you have witness

2474
01:37:32,560 --> 01:37:34,560
you don't need to behave honestly here

2475
01:37:34,560 --> 01:37:35,840
you can cheat

2476
01:37:35,840 --> 01:37:39,360
as long as you can use this weakness

2477
01:37:39,360 --> 01:37:41,280
otherwise if you don't have witness you

2478
01:37:41,280 --> 01:37:42,880
just do everything honestly you can

2479
01:37:42,880 --> 01:37:45,280
still finish finish this as the original

2480
01:37:45,280 --> 01:37:46,400
emc

2481
01:37:46,400 --> 01:37:47,600
so

2482
01:37:47,600 --> 01:37:50,080
now i make it a composition so i can use

2483
01:37:50,080 --> 01:37:52,560
the original approach uh

2484
01:37:52,560 --> 01:37:53,440
here

2485
01:37:53,440 --> 01:37:54,880
uh

2486
01:37:54,880 --> 01:37:56,639
as i said before computer has a choice

2487
01:37:56,639 --> 01:37:58,639
right if the statement you are going to

2488
01:37:58,639 --> 01:37:59,440
prove

2489
01:37:59,440 --> 01:38:01,840
is large

2490
01:38:01,840 --> 01:38:04,080
maybe maybe if this statement is even

2491
01:38:04,080 --> 01:38:06,960
larger than the original uh

2492
01:38:06,960 --> 01:38:09,679
consistency condition then you just uh

2493
01:38:09,679 --> 01:38:11,280
actually you don't do this you just

2494
01:38:11,280 --> 01:38:12,800
prove the original consistent

2495
01:38:12,800 --> 01:38:15,119
consistency condition but

2496
01:38:15,119 --> 01:38:18,159
this structure will give you benefit if

2497
01:38:18,159 --> 01:38:19,920
uh the statement you want to prove is

2498
01:38:19,920 --> 01:38:21,040
small

2499
01:38:21,040 --> 01:38:23,119
i uh i mean at least a smaller than the

2500
01:38:23,119 --> 01:38:26,000
original condition now the the the the

2501
01:38:26,000 --> 01:38:28,320
the efficiency of the accommodation will

2502
01:38:28,320 --> 01:38:29,520
will kick in

2503
01:38:29,520 --> 01:38:32,719
okay uh that's like we summarize this as

2504
01:38:32,719 --> 01:38:33,840
a new primitive called the

2505
01:38:33,840 --> 01:38:35,679
instance-based nominal equipment

2506
01:38:35,679 --> 01:38:37,920
instance means this uh statement wins

2507
01:38:37,920 --> 01:38:39,040
pair

2508
01:38:39,040 --> 01:38:43,119
so that's the idea but as i said before

2509
01:38:43,119 --> 01:38:45,360
there's a catch if you do this

2510
01:38:45,360 --> 01:38:47,600
previously this is the nominal equipment

2511
01:38:47,600 --> 01:38:49,280
however now

2512
01:38:49,280 --> 01:38:51,199
if the x is true

2513
01:38:51,199 --> 01:38:53,040
the true statement here

2514
01:38:53,040 --> 01:38:54,880
you don't know if the minor middle

2515
01:38:54,880 --> 01:38:56,560
adversary has witnessed or not however

2516
01:38:56,560 --> 01:38:58,480
as long as the act is true the middle

2517
01:38:58,480 --> 01:39:00,639
expert has the potential to use some

2518
01:39:00,639 --> 01:39:02,480
witness so

2519
01:39:02,480 --> 01:39:03,840
that means this

2520
01:39:03,840 --> 01:39:05,760
nominal equipment may not be performed

2521
01:39:05,760 --> 01:39:08,400
honestly so it may not be nominal at all

2522
01:39:08,400 --> 01:39:10,000
because of that reason we cannot show

2523
01:39:10,000 --> 01:39:12,719
its nominal abortion but we can show

2524
01:39:12,719 --> 01:39:15,600
that this simulation sum

2525
01:39:15,600 --> 01:39:17,840
so what do we get so far the simulation

2526
01:39:17,840 --> 01:39:19,920
from the sun zero knowledge and and i

2527
01:39:19,920 --> 01:39:22,800
said as i said earlier there are uh

2528
01:39:22,800 --> 01:39:25,440
standard transformations to make it a

2529
01:39:25,440 --> 01:39:27,760
about decay and normal bulk and

2530
01:39:27,760 --> 01:39:30,480
you again you don't need to know the how

2531
01:39:30,480 --> 01:39:32,480
it works and why it works i just want to

2532
01:39:32,480 --> 01:39:34,159
we just want to focus on efficiency

2533
01:39:34,159 --> 01:39:37,920
right so bottleneck is the final stage

2534
01:39:37,920 --> 01:39:40,159
how do we solve it it's our statement so

2535
01:39:40,159 --> 01:39:42,480
look same idea at before

2536
01:39:42,480 --> 01:39:44,080
and uh

2537
01:39:44,080 --> 01:39:46,639
yeah here on show some numbers this is

2538
01:39:46,639 --> 01:39:48,159
uh a

2539
01:39:48,159 --> 01:39:50,480
urdu and a nominable our number about

2540
01:39:50,480 --> 01:39:52,880
your money protocol on a

2541
01:39:52,880 --> 01:39:54,440
chart shar250

2542
01:39:54,440 --> 01:39:56,560
sharp256 instance

2543
01:39:56,560 --> 01:39:59,040
and uh this is a normal level equipment

2544
01:39:59,040 --> 01:40:00,960
committing to a single bit

2545
01:40:00,960 --> 01:40:03,440
uh the mental way here is uh we are not

2546
01:40:03,440 --> 01:40:04,480
trying to

2547
01:40:04,480 --> 01:40:05,600
provide a

2548
01:40:05,600 --> 01:40:08,400
off-the-shelf solution i just want to

2549
01:40:08,400 --> 01:40:11,600
show you that uh nominal zero knowledge

2550
01:40:11,600 --> 01:40:13,679
can be within the reach of practical

2551
01:40:13,679 --> 01:40:14,800
competition

2552
01:40:14,800 --> 01:40:17,600
so we didn't try much harder to

2553
01:40:17,600 --> 01:40:20,320
push this number smaller and smaller

2554
01:40:20,320 --> 01:40:24,159
it's just a demonstration concept

2555
01:40:24,159 --> 01:40:25,679
that's all i want to share and i'm happy

2556
01:40:25,679 --> 01:40:28,639
to take questions

2557
01:40:33,440 --> 01:40:37,159
are there any questions

2558
01:40:43,040 --> 01:40:45,440
hey nice talk

2559
01:40:45,440 --> 01:40:47,600
i just want to complement your list of

2560
01:40:47,600 --> 01:40:50,000
references because i didn't see it can

2561
01:40:50,000 --> 01:40:52,239
you hear it

2562
01:40:52,239 --> 01:40:53,440
sorry

2563
01:40:53,440 --> 01:40:55,840
yeah it's good

2564
01:40:55,840 --> 01:40:57,920
so

2565
01:40:57,920 --> 01:41:00,080
euro came 2003

2566
01:41:00,080 --> 01:41:01,440
we had

2567
01:41:01,440 --> 01:41:03,920
something called omega protocols which

2568
01:41:03,920 --> 01:41:06,320
are an extension of sigma protocols

2569
01:41:06,320 --> 01:41:09,920
which achieve no manual zero knowledge

2570
01:41:09,920 --> 01:41:13,199
and they're in the crs model so i see

2571
01:41:13,199 --> 01:41:15,600
but at the time was the first sufficient

2572
01:41:15,600 --> 01:41:19,040
non-modification protocol after clause

2573
01:41:19,040 --> 01:41:20,880
and we use also there are

2574
01:41:20,880 --> 01:41:23,360
composition trick

2575
01:41:23,360 --> 01:41:24,560
and

2576
01:41:24,560 --> 01:41:25,679
yeah

2577
01:41:25,679 --> 01:41:27,760
i see i see um check it out yeah the

2578
01:41:27,760 --> 01:41:29,840
issue is i i know the i know the title

2579
01:41:29,840 --> 01:41:31,760
of your people i never i never read it

2580
01:41:31,760 --> 01:41:33,520
so i will go back and read it and give

2581
01:41:33,520 --> 01:41:35,840
you the uh updated version so by

2582
01:41:35,840 --> 01:41:37,520
efficient we don't mean you know we

2583
01:41:37,520 --> 01:41:39,119
don't want to implement it yeah yeah

2584
01:41:39,119 --> 01:41:40,639
yeah at the time the only thing that was

2585
01:41:40,639 --> 01:41:42,239
available was class

2586
01:41:42,239 --> 01:41:43,440
right so

2587
01:41:43,440 --> 01:41:45,760
i see i see yeah and we also go through

2588
01:41:45,760 --> 01:41:47,440
simulation sounds

2589
01:41:47,440 --> 01:41:49,360
cool

2590
01:41:49,360 --> 01:41:53,199
sure and the the the situation is uh uh

2591
01:41:53,199 --> 01:41:55,119
we are mainly focused on like the play

2592
01:41:55,119 --> 01:41:57,520
model like yours are in the series mode

2593
01:41:57,520 --> 01:41:59,119
but but you already i need to give you

2594
01:41:59,119 --> 01:42:00,400
the reference because

2595
01:42:00,400 --> 01:42:03,040
because i also like a survey all the

2596
01:42:03,040 --> 01:42:05,280
existing constructions in the crs model

2597
01:42:05,280 --> 01:42:07,199
and in the random work model yeah but

2598
01:42:07,199 --> 01:42:08,880
but i just want to mention that you know

2599
01:42:08,880 --> 01:42:11,280
in a crs model if you if you get

2600
01:42:11,280 --> 01:42:14,400
nominable primitives

2601
01:42:14,400 --> 01:42:16,400
it's hard to use when you when you want

2602
01:42:16,400 --> 01:42:18,400
to do composition for example you see

2603
01:42:18,400 --> 01:42:20,960
yeah you need to program crs maybe your

2604
01:42:20,960 --> 01:42:22,719
larger protocol already programmed these

2605
01:42:22,719 --> 01:42:25,199
kind of things yeah but i will i will

2606
01:42:25,199 --> 01:42:28,199
study

2607
01:42:28,880 --> 01:42:32,080
is there any other question

2608
01:42:32,080 --> 01:42:34,320
all right let's thank the speaker again

2609
01:42:34,320 --> 01:42:36,639
thank you

2610
01:42:39,199 --> 01:42:43,239
and this is the end of the session

