1
00:00:00,000 --> 00:00:03,560
country sahind Waters

2
00:00:05,220 --> 00:00:07,799
and the idea there is to have an

3
00:00:07,799 --> 00:00:09,719
encryption scheme where the security is

4
00:00:09,719 --> 00:00:11,880
related to the hardness of of some

5
00:00:11,880 --> 00:00:14,940
problem in NP so more concretely we take

6
00:00:14,940 --> 00:00:17,220
an instance of an NP hard uh not

7
00:00:17,220 --> 00:00:18,779
necessarily anti-heart problem but some

8
00:00:18,779 --> 00:00:21,119
problem in npn we take the verification

9
00:00:21,119 --> 00:00:23,400
algorithm and we would like to encrypt

10
00:00:23,400 --> 00:00:25,500
with this with respect to this algorithm

11
00:00:25,500 --> 00:00:28,019
and then the requirement is that in

12
00:00:28,019 --> 00:00:29,640
order to decrypt you need to have a

13
00:00:29,640 --> 00:00:31,500
valid weight next for the verification

14
00:00:31,500 --> 00:00:34,620
algorithm and for security we want to

15
00:00:34,620 --> 00:00:36,660
guarantee that if there does not exist

16
00:00:36,660 --> 00:00:38,700
any valid witness then it should be

17
00:00:38,700 --> 00:00:40,980
impossible to decrypt

18
00:00:40,980 --> 00:00:44,040
so notice that there is no decryption

19
00:00:44,040 --> 00:00:47,399
key at all uh everything should be

20
00:00:47,399 --> 00:00:50,160
encapsulated inside the ciphertext and

21
00:00:50,160 --> 00:00:52,079
this also means that the encrypter

22
00:00:52,079 --> 00:00:53,640
itself does not know whether there

23
00:00:53,640 --> 00:00:55,500
exists a witness or not because if the

24
00:00:55,500 --> 00:00:57,420
encrypter would know if there exists a

25
00:00:57,420 --> 00:00:59,219
witness then in case there is a witness

26
00:00:59,219 --> 00:01:01,079
he could give the message in the clear

27
00:01:01,079 --> 00:01:03,660
because then it means that uh the the

28
00:01:03,660 --> 00:01:06,260
security requirements holds uh trivially

29
00:01:06,260 --> 00:01:09,900
and if the the encryption that there

30
00:01:09,900 --> 00:01:12,060
does not exist with this then you can

31
00:01:12,060 --> 00:01:14,040
just give nothing because it should be

32
00:01:14,040 --> 00:01:16,820
impossible to decrease

33
00:01:17,479 --> 00:01:21,060
so uh about a year after the notion was

34
00:01:21,060 --> 00:01:24,000
first to death suggested we also had a

35
00:01:24,000 --> 00:01:26,600
construction for multilinear map by uh

36
00:01:26,600 --> 00:01:30,780
so move on to on Zoom they see like the

37
00:01:30,780 --> 00:01:33,500
initial one

38
00:01:34,140 --> 00:01:36,119
I got a message that said that got

39
00:01:36,119 --> 00:01:39,979
disconnected from Zoom oh so

40
00:01:41,820 --> 00:01:46,100
maybe we reshare or

41
00:02:00,119 --> 00:02:02,840
this week

42
00:02:13,620 --> 00:02:16,220
foreign

43
00:02:30,920 --> 00:02:33,920
yeah so the first construction that was

44
00:02:33,920 --> 00:02:37,680
suggested was from multilinear maps and

45
00:02:37,680 --> 00:02:39,360
immediately after that people started to

46
00:02:39,360 --> 00:02:41,099
try and come up with constructions from

47
00:02:41,099 --> 00:02:42,599
standard assumptions and we have two

48
00:02:42,599 --> 00:02:44,940
candidates from lattice from latissas

49
00:02:44,940 --> 00:02:46,620
but we don't know how to analyze the

50
00:02:46,620 --> 00:02:49,200
security at all so we don't have any

51
00:02:49,200 --> 00:02:50,879
sort of security proof even from

52
00:02:50,879 --> 00:02:52,680
non-standard assumptions for those

53
00:02:52,680 --> 00:02:54,959
candidates and of course we can also get

54
00:02:54,959 --> 00:02:58,560
witness encryption from from IO but

55
00:02:58,560 --> 00:03:02,099
we the problem is uh if we use the

56
00:03:02,099 --> 00:03:05,220
standard assumptions in order to get IO

57
00:03:05,220 --> 00:03:06,480
we need to go through a really long

58
00:03:06,480 --> 00:03:09,000
sequence of reductions and we lose the

59
00:03:09,000 --> 00:03:11,099
intuition on the security along the way

60
00:03:11,099 --> 00:03:14,580
so the intuition uh the motivation is to

61
00:03:14,580 --> 00:03:16,260
try and come up with the construction

62
00:03:16,260 --> 00:03:19,920
that we can argue better about why we

63
00:03:19,920 --> 00:03:22,440
believe it to be secure and hopefully to

64
00:03:22,440 --> 00:03:24,659
have some security analysis that we can

65
00:03:24,659 --> 00:03:25,819
better understand

66
00:03:25,819 --> 00:03:29,220
uh and indeed we provide here a new

67
00:03:29,220 --> 00:03:31,260
candidate and in order to analyze its

68
00:03:31,260 --> 00:03:34,680
security we also have a new Assumption

69
00:03:34,680 --> 00:03:37,680
of hardness of a lattice problem and it

70
00:03:37,680 --> 00:03:39,360
turns out that this assumption is not

71
00:03:39,360 --> 00:03:41,280
really new because recently in the last

72
00:03:41,280 --> 00:03:44,819
Europe uh hodeku also came up with a

73
00:03:44,819 --> 00:03:46,319
very similar assumption in order to

74
00:03:46,319 --> 00:03:49,200
construct broadcast inscription from

75
00:03:49,200 --> 00:03:51,900
lattices so we see this as a an

76
00:03:51,900 --> 00:03:53,700
encouraging sign that more people think

77
00:03:53,700 --> 00:03:55,799
that this assumption is reasonable or

78
00:03:55,799 --> 00:03:58,860
what's thinking about

79
00:03:58,860 --> 00:04:01,500
so the computational model that we're

80
00:04:01,500 --> 00:04:03,780
going to use is a branching program so

81
00:04:03,780 --> 00:04:05,780
just to recap a branching program

82
00:04:05,780 --> 00:04:09,000
consists of evaluation level so this

83
00:04:09,000 --> 00:04:11,280
corresponds to the columns in the in the

84
00:04:11,280 --> 00:04:14,640
slides and in each level the the program

85
00:04:14,640 --> 00:04:16,798
can hold one of a few States so this

86
00:04:16,798 --> 00:04:19,320
corresponds to the to the rows in the

87
00:04:19,320 --> 00:04:20,339
drawing

88
00:04:20,339 --> 00:04:23,100
so the program always begins at the

89
00:04:23,100 --> 00:04:24,900
starting state which is some node at the

90
00:04:24,900 --> 00:04:28,860
first level and then uh between each two

91
00:04:28,860 --> 00:04:30,780
consecutive levels there are two

92
00:04:30,780 --> 00:04:33,780
mappings one four zero and one for one

93
00:04:33,780 --> 00:04:36,479
and the program should read the bits of

94
00:04:36,479 --> 00:04:38,880
the input the input should that we want

95
00:04:38,880 --> 00:04:40,139
to evaluate

96
00:04:40,139 --> 00:04:43,080
sorry on the program and according to

97
00:04:43,080 --> 00:04:45,120
that to decide whether to take the

98
00:04:45,120 --> 00:04:47,460
transition that corresponds uh to zero

99
00:04:47,460 --> 00:04:49,320
or to one and

100
00:04:49,320 --> 00:04:52,560
when we apply that we end up with one of

101
00:04:52,560 --> 00:04:54,360
the stats at the output layer and then

102
00:04:54,360 --> 00:04:56,280
this is either defined to be an

103
00:04:56,280 --> 00:04:58,620
accepting state or rejecting state so

104
00:04:58,620 --> 00:05:00,780
this determines whether the branch

105
00:05:00,780 --> 00:05:04,800
program output uh zero or one

106
00:05:04,800 --> 00:05:08,039
and indeed we know that for every uh

107
00:05:08,039 --> 00:05:11,039
function in nc1 we can indeed compute it

108
00:05:11,039 --> 00:05:15,600
by a reasonable size branching program

109
00:05:15,600 --> 00:05:18,600
so now uh suppose that we want to

110
00:05:18,600 --> 00:05:22,080
construct the witness encryption so as I

111
00:05:22,080 --> 00:05:24,060
said at the beginning the encrypter

112
00:05:24,060 --> 00:05:25,500
itself does not know whether there

113
00:05:25,500 --> 00:05:28,259
exists a witness or not so the

114
00:05:28,259 --> 00:05:31,039
encryption must provide the flexibility

115
00:05:31,039 --> 00:05:34,080
to compute the the verification

116
00:05:34,080 --> 00:05:36,419
algorithm on any inputs that the

117
00:05:36,419 --> 00:05:38,220
decrypter wants because the decryptor

118
00:05:38,220 --> 00:05:40,139
should come up with some witness and and

119
00:05:40,139 --> 00:05:42,419
evaluate it and and then crypto does not

120
00:05:42,419 --> 00:05:45,560
know what it is going to be

121
00:05:46,380 --> 00:05:49,560
so here is a very abstract high-level

122
00:05:49,560 --> 00:05:52,400
approach

123
00:05:53,340 --> 00:05:54,919
okay

124
00:05:54,919 --> 00:05:56,479
so

125
00:05:56,479 --> 00:05:58,560
let's generate

126
00:05:58,560 --> 00:06:00,900
two parts of the ciphertext that are

127
00:06:00,900 --> 00:06:02,880
somehow correlated and they should be

128
00:06:02,880 --> 00:06:04,919
combined together so we will be able to

129
00:06:04,919 --> 00:06:07,860
to decrypt them and then we associate

130
00:06:07,860 --> 00:06:09,660
them one of them with the starting State

131
00:06:09,660 --> 00:06:12,900
and another and uh and the second one

132
00:06:12,900 --> 00:06:16,080
with the output States and then for each

133
00:06:16,080 --> 00:06:18,060
level of the branching program we will

134
00:06:18,060 --> 00:06:20,819
provide uh two keys one corresponding to

135
00:06:20,819 --> 00:06:23,400
zero and one corresponding to one and

136
00:06:23,400 --> 00:06:26,580
then ideally the crypto uh assuming that

137
00:06:26,580 --> 00:06:29,340
he knows a valid witness he can choose a

138
00:06:29,340 --> 00:06:33,080
subset of the evaluation case

139
00:06:37,740 --> 00:06:40,340
sorry

140
00:06:40,500 --> 00:06:41,940
you can choose a subset of the

141
00:06:41,940 --> 00:06:43,979
evaluation case and then he finds a path

142
00:06:43,979 --> 00:06:45,900
from the starting ciphertext to the

143
00:06:45,900 --> 00:06:47,460
output ciphertext and we can combine

144
00:06:47,460 --> 00:06:49,680
them and you can decrypt

145
00:06:49,680 --> 00:06:52,560
now what is the problem with that we

146
00:06:52,560 --> 00:06:55,919
provide the the crypto with all of the

147
00:06:55,919 --> 00:06:58,560
evaluation keys and then when we have an

148
00:06:58,560 --> 00:07:02,220
adversary you can choose a subset of the

149
00:07:02,220 --> 00:07:04,800
keys that does not correspond to a real

150
00:07:04,800 --> 00:07:06,539
witness because the branching program

151
00:07:06,539 --> 00:07:09,960
can read each input bit more than once

152
00:07:09,960 --> 00:07:13,460
and we assume that an honest evaluator

153
00:07:13,460 --> 00:07:16,919
if the ice input bit is zero he would

154
00:07:16,919 --> 00:07:18,419
always use the K that corresponds to

155
00:07:18,419 --> 00:07:20,400
zero but an attacker can mix and match

156
00:07:20,400 --> 00:07:22,500
and use sometimes zero and sometimes one

157
00:07:22,500 --> 00:07:24,240
and therefore he would find a path from

158
00:07:24,240 --> 00:07:26,340
the starting of the accepting node even

159
00:07:26,340 --> 00:07:27,900
though it does not correspond to a valid

160
00:07:27,900 --> 00:07:30,138
Witness

161
00:07:31,020 --> 00:07:35,400
so to tackle this problem uh we use an

162
00:07:35,400 --> 00:07:38,180
idea that was suggested by Channel

163
00:07:38,180 --> 00:07:42,060
by channel in the context of um

164
00:07:42,060 --> 00:07:44,400
in this indiscrimishability of

165
00:07:44,400 --> 00:07:46,979
discussion and the idea there is to have

166
00:07:46,979 --> 00:07:49,979
a branching program that can verify that

167
00:07:49,979 --> 00:07:53,099
the input was used consistently and in

168
00:07:53,099 --> 00:07:54,419
order to have such a project program

169
00:07:54,419 --> 00:07:56,879
they Define a generalized notion that is

170
00:07:56,879 --> 00:07:58,879
called a multi-state branching program

171
00:07:58,879 --> 00:08:02,160
and the idea there is that the program

172
00:08:02,160 --> 00:08:05,160
can start in multiple States so instead

173
00:08:05,160 --> 00:08:06,840
of just using a starting node we now

174
00:08:06,840 --> 00:08:08,879
have multiple starting nodes and then

175
00:08:08,879 --> 00:08:11,400
each evaluation step should be applied

176
00:08:11,400 --> 00:08:13,500
on all of the states simultaneously and

177
00:08:13,500 --> 00:08:15,599
then we also end up with multiple output

178
00:08:15,599 --> 00:08:17,879
States so there should be some mapping

179
00:08:17,879 --> 00:08:21,419
that defines uh whether the the output

180
00:08:21,419 --> 00:08:23,520
Vector representation of the entire last

181
00:08:23,520 --> 00:08:25,620
level whether it is accepting or

182
00:08:25,620 --> 00:08:27,060
rejecting

183
00:08:27,060 --> 00:08:30,060
so now when we allow this uh generalized

184
00:08:30,060 --> 00:08:32,399
notion of branching program they do the

185
00:08:32,399 --> 00:08:36,120
following trick for each input bits they

186
00:08:36,120 --> 00:08:38,700
add additional layers to the branching

187
00:08:38,700 --> 00:08:40,380
program that can be thought of as a

188
00:08:40,380 --> 00:08:43,260
memory cell and this memory cells they

189
00:08:43,260 --> 00:08:45,420
memorize for each of the input bits

190
00:08:45,420 --> 00:08:48,420
whether they were already read a zero or

191
00:08:48,420 --> 00:08:50,580
or as one or whether they were

192
00:08:50,580 --> 00:08:53,100
inconsistent and as long as they were

193
00:08:53,100 --> 00:08:56,100
consistent to either zero or one the

194
00:08:56,100 --> 00:08:58,740
this memory cell would accept this

195
00:08:58,740 --> 00:09:01,200
sequence of evaluation but if it was

196
00:09:01,200 --> 00:09:03,000
inconsistent this memory cell would

197
00:09:03,000 --> 00:09:04,380
reject

198
00:09:04,380 --> 00:09:07,740
so now because uh we allow a multi-state

199
00:09:07,740 --> 00:09:10,019
branching program let's see how to

200
00:09:10,019 --> 00:09:12,720
enforce consistency so we start with

201
00:09:12,720 --> 00:09:14,339
just the standard branching program that

202
00:09:14,339 --> 00:09:16,620
computes F and for each of the input

203
00:09:16,620 --> 00:09:19,980
bits we concatenate a memory cell

204
00:09:19,980 --> 00:09:23,160
so now if we compute this matching

205
00:09:23,160 --> 00:09:25,680
program on any sequence

206
00:09:25,680 --> 00:09:30,240
so if the uh the sequence corresponds to

207
00:09:30,240 --> 00:09:33,360
a valid input then all of the memory

208
00:09:33,360 --> 00:09:35,040
cells would accept and then the output

209
00:09:35,040 --> 00:09:37,560
will depend only on the value of f but

210
00:09:37,560 --> 00:09:39,360
if we evaluate it on an inconsistent

211
00:09:39,360 --> 00:09:41,880
input at least one of the memory cells

212
00:09:41,880 --> 00:09:44,600
would reject

213
00:09:46,080 --> 00:09:49,320
okay so now we want to take all of that

214
00:09:49,320 --> 00:09:53,399
and actually uh construct uh witness and

215
00:09:53,399 --> 00:09:55,800
encryption on top of that given those

216
00:09:55,800 --> 00:09:58,560
abstract ideas and for this purpose we

217
00:09:58,560 --> 00:10:00,839
would use uh some variant of ggh

218
00:10:00,839 --> 00:10:05,339
encodings so let me go uh over what are

219
00:10:05,339 --> 00:10:07,680
those encodings so this is a way to

220
00:10:07,680 --> 00:10:11,040
generate instances of lattice problems

221
00:10:11,040 --> 00:10:13,680
according to a structure of a directed

222
00:10:13,680 --> 00:10:16,380
graph so in this examples we have two

223
00:10:16,380 --> 00:10:20,040
nodes and two edges between them and

224
00:10:20,040 --> 00:10:22,560
each node would be associated with some

225
00:10:22,560 --> 00:10:24,899
metrics and each Edge would be

226
00:10:24,899 --> 00:10:29,880
associated with some lwe secrets

227
00:10:29,880 --> 00:10:32,519
and then there is an encoding algorithm

228
00:10:32,519 --> 00:10:36,560
that takes a trapdoor of a source Matrix

229
00:10:36,560 --> 00:10:39,180
and takes the secret of the edge and

230
00:10:39,180 --> 00:10:42,000
takes them the metrics of uh the target

231
00:10:42,000 --> 00:10:44,459
node and computes something that we call

232
00:10:44,459 --> 00:10:47,160
the encoding so those would be the K

233
00:10:47,160 --> 00:10:50,399
matrices and what are those encodings so

234
00:10:50,399 --> 00:10:52,440
they have the property that if we have

235
00:10:52,440 --> 00:10:56,040
LW instance with respect to a we can

236
00:10:56,040 --> 00:10:59,040
apply then coding and it will convert

237
00:10:59,040 --> 00:11:02,160
the instance to be an LW with respect to

238
00:11:02,160 --> 00:11:06,420
B but not only that note that the nwe

239
00:11:06,420 --> 00:11:10,320
secret it tracks which path we chose so

240
00:11:10,320 --> 00:11:12,660
it has this multiplicative factor that

241
00:11:12,660 --> 00:11:15,360
corresponds to the to the secret of of

242
00:11:15,360 --> 00:11:17,760
the edge so depending on whether we

243
00:11:17,760 --> 00:11:22,380
chose to go from A to B with k0 or K1 we

244
00:11:22,380 --> 00:11:24,420
will always end up with LW with respect

245
00:11:24,420 --> 00:11:27,979
to B but the secret would be different

246
00:11:29,040 --> 00:11:32,100
so the idea to use ggh encodings over a

247
00:11:32,100 --> 00:11:34,560
branching program was applied uh many

248
00:11:34,560 --> 00:11:36,300
times before for various applications

249
00:11:36,300 --> 00:11:39,000
and here I will describe the Canadian

250
00:11:39,000 --> 00:11:40,800
chain constraint should run function

251
00:11:40,800 --> 00:11:43,740
because it will be our base case for our

252
00:11:43,740 --> 00:11:45,120
Construction

253
00:11:45,120 --> 00:11:48,300
so every node in the branching program

254
00:11:48,300 --> 00:11:50,639
has some metrics associated with it and

255
00:11:50,639 --> 00:11:52,320
I didn't track it over all of them but

256
00:11:52,320 --> 00:11:55,139
imagine all of them have matrices and I

257
00:11:55,139 --> 00:11:58,620
denote the starting node by a and the

258
00:11:58,620 --> 00:12:01,019
accepting node by B

259
00:12:01,019 --> 00:12:04,620
and now for each evaluation step so

260
00:12:04,620 --> 00:12:06,720
recall that we have uh the mapping for

261
00:12:06,720 --> 00:12:08,760
zero and the mapping and the mapping for

262
00:12:08,760 --> 00:12:11,519
one so for each of those mappings we

263
00:12:11,519 --> 00:12:15,000
will sample an LW secret either s0 or S1

264
00:12:15,000 --> 00:12:17,519
and also uh they will be different for

265
00:12:17,519 --> 00:12:19,800
each level

266
00:12:19,800 --> 00:12:22,620
now in order to encode the branching

267
00:12:22,620 --> 00:12:26,459
program we give LW instance with respect

268
00:12:26,459 --> 00:12:28,380
to the starting note so with respect to

269
00:12:28,380 --> 00:12:31,320
a and in addition for each and every

270
00:12:31,320 --> 00:12:33,839
Edge in the branching program we provide

271
00:12:33,839 --> 00:12:36,720
ggh encoding according to the starting

272
00:12:36,720 --> 00:12:38,820
metrics the secret that corresponds to

273
00:12:38,820 --> 00:12:42,920
this Edge and the target Matrix

274
00:12:43,279 --> 00:12:46,500
so suppose that we have this encoding

275
00:12:46,500 --> 00:12:49,200
and we want to compute it on some path

276
00:12:49,200 --> 00:12:52,980
on the branching program so we can take

277
00:12:52,980 --> 00:12:56,160
the subset of uh the encodings for each

278
00:12:56,160 --> 00:12:59,279
level and multiply them and this will

279
00:12:59,279 --> 00:13:02,880
convert the public Matrix of the LW from

280
00:13:02,880 --> 00:13:05,579
a to the output Matrix so in that case

281
00:13:05,579 --> 00:13:07,079
that we see in the slide the output

282
00:13:07,079 --> 00:13:09,600
Matrix is indeed accepting Matrix B so

283
00:13:09,600 --> 00:13:11,519
we end up with LW with respect to B and

284
00:13:11,519 --> 00:13:14,760
I omit the here the all of the LW errors

285
00:13:14,760 --> 00:13:17,160
so we end up with a library with respect

286
00:13:17,160 --> 00:13:20,760
to B but then the secret term that we

287
00:13:20,760 --> 00:13:23,399
have it memorizes the entire evaluation

288
00:13:23,399 --> 00:13:25,260
sequence that we chose because we have

289
00:13:25,260 --> 00:13:29,339
the multiplications of the S matrices

290
00:13:29,339 --> 00:13:34,380
and indeed uh we know that uh because we

291
00:13:34,380 --> 00:13:37,680
have different uh multiplications of s

292
00:13:37,680 --> 00:13:42,240
values this uh in this inserts enough

293
00:13:42,240 --> 00:13:44,699
entropy to the system so we can treat

294
00:13:44,699 --> 00:13:49,459
these values as as pseudo-random values

295
00:13:49,500 --> 00:13:51,600
so now going back to the multi-step

296
00:13:51,600 --> 00:13:53,940
branching program that verifies the

297
00:13:53,940 --> 00:13:56,040
consistency we would like to somehow

298
00:13:56,040 --> 00:14:00,240
apply a similar construction on that so

299
00:14:00,240 --> 00:14:04,199
similar to before for each starting node

300
00:14:04,199 --> 00:14:05,940
because now we have multiple of them we

301
00:14:05,940 --> 00:14:09,899
will sample some starting Matrix and now

302
00:14:09,899 --> 00:14:12,360
for the output matrices we do something

303
00:14:12,360 --> 00:14:14,519
slightly different so for each memory

304
00:14:14,519 --> 00:14:17,279
cell we sample an independently

305
00:14:17,279 --> 00:14:20,579
uniformly random Matrix bi and we

306
00:14:20,579 --> 00:14:23,279
associate this Matrix with each of the

307
00:14:23,279 --> 00:14:26,519
accepting nodes of each memory cell

308
00:14:26,519 --> 00:14:28,980
and for the the branching program that

309
00:14:28,980 --> 00:14:30,480
computes f

310
00:14:30,480 --> 00:14:34,019
we Define uh the the accepting Matrix to

311
00:14:34,019 --> 00:14:35,699
be the sum of all of the other matrices

312
00:14:35,699 --> 00:14:38,459
so all the output matrices have some

313
00:14:38,459 --> 00:14:41,579
sort of correlation between them but as

314
00:14:41,579 --> 00:14:44,699
long as we miss one of the output

315
00:14:44,699 --> 00:14:48,000
matrices the all of the other ones look

316
00:14:48,000 --> 00:14:50,160
independent and uniformly random so this

317
00:14:50,160 --> 00:14:52,139
is like secret sharing between all of

318
00:14:52,139 --> 00:14:55,160
the accepting nodes

319
00:14:55,920 --> 00:14:58,199
and then in order to encode we give LW

320
00:14:58,199 --> 00:15:00,060
with respect to the starting matrices

321
00:15:00,060 --> 00:15:01,800
and all of the encodings according to

322
00:15:01,800 --> 00:15:05,359
the levels of the branching program

323
00:15:06,060 --> 00:15:09,959
so what is what is the intuition on why

324
00:15:09,959 --> 00:15:12,240
it is supposed to be secure

325
00:15:12,240 --> 00:15:15,839
uh so we know that uh

326
00:15:15,839 --> 00:15:18,600
the adversary can start from any

327
00:15:18,600 --> 00:15:20,880
starting node and can compute any

328
00:15:20,880 --> 00:15:23,459
sequence of his choice and it will end

329
00:15:23,459 --> 00:15:26,220
up with lwe instances with respect to

330
00:15:26,220 --> 00:15:28,500
the output metrics that corresponds to

331
00:15:28,500 --> 00:15:31,259
the to the starting node and the past

332
00:15:31,259 --> 00:15:34,440
that that it took and in the case that

333
00:15:34,440 --> 00:15:36,240
there there does not exist a valid

334
00:15:36,240 --> 00:15:39,360
witness then any sequence that he would

335
00:15:39,360 --> 00:15:43,620
choose either will end up if it is

336
00:15:43,620 --> 00:15:45,480
inconsistent it will end up in a

337
00:15:45,480 --> 00:15:47,220
rejecting state in one of the memory

338
00:15:47,220 --> 00:15:50,339
cells or if it is consistent it will end

339
00:15:50,339 --> 00:15:52,380
up in the rejecting state of the

340
00:15:52,380 --> 00:15:55,500
branching program that computes F so

341
00:15:55,500 --> 00:15:59,519
that does not exist any sequence of s's

342
00:15:59,519 --> 00:16:02,699
that he can choose that would lead him

343
00:16:02,699 --> 00:16:07,079
to lwe instances with respect to all of

344
00:16:07,079 --> 00:16:10,019
the bmets which says and the same lwe

345
00:16:10,019 --> 00:16:14,459
Secret this is the core belief on which

346
00:16:14,459 --> 00:16:18,599
we will build the security analysis

347
00:16:20,160 --> 00:16:22,440
Okay so

348
00:16:22,440 --> 00:16:25,500
now let's say how to analyze uh the

349
00:16:25,500 --> 00:16:27,779
security of such schemes so going back

350
00:16:27,779 --> 00:16:30,899
to a ggh encoding here is how it is

351
00:16:30,899 --> 00:16:32,459
typically done

352
00:16:32,459 --> 00:16:36,839
so usually we have the guarantee that b

353
00:16:36,839 --> 00:16:39,300
is uniform Matrix and therefore LW with

354
00:16:39,300 --> 00:16:41,759
respect to B is hard because we don't

355
00:16:41,759 --> 00:16:43,980
need the trapdoor of B because it

356
00:16:43,980 --> 00:16:47,339
doesn't have any outgoing edges and

357
00:16:47,339 --> 00:16:50,519
because LW with respect to B is hard we

358
00:16:50,519 --> 00:16:52,920
have a way to simulate the encodings

359
00:16:52,920 --> 00:16:55,139
that leads to be

360
00:16:55,139 --> 00:16:58,320
and after we simulate the encodings we

361
00:16:58,320 --> 00:17:01,620
no longer need the trapdoor of a so we

362
00:17:01,620 --> 00:17:03,300
can generate them without the trapdoor

363
00:17:03,300 --> 00:17:04,919
and now because we don't use any more

364
00:17:04,919 --> 00:17:07,919
detractor of a we can generate a also

365
00:17:07,919 --> 00:17:10,679
without a trapdoor and now we also have

366
00:17:10,679 --> 00:17:13,319
the guarantees that's LW with respect to

367
00:17:13,319 --> 00:17:16,079
a is hard and we can apply this argument

368
00:17:16,079 --> 00:17:19,260
again and again if a had predecessors in

369
00:17:19,260 --> 00:17:21,140
this graph

370
00:17:21,140 --> 00:17:24,260
so if we look at the Connecticut

371
00:17:24,260 --> 00:17:27,059
constraint prf that we saw earlier this

372
00:17:27,059 --> 00:17:29,580
is indeed the the kind of analysis that

373
00:17:29,580 --> 00:17:31,919
they perform to to prove the pseudor

374
00:17:31,919 --> 00:17:34,080
randomness of their construction so they

375
00:17:34,080 --> 00:17:36,299
begin with the guarantee that all of the

376
00:17:36,299 --> 00:17:38,340
matrices in the output layers are

377
00:17:38,340 --> 00:17:40,380
uniformly random and therefore LW with

378
00:17:40,380 --> 00:17:43,440
respect to them is hard and then they

379
00:17:43,440 --> 00:17:46,140
can simulate all of the edges that lead

380
00:17:46,140 --> 00:17:48,660
to those matrices and because of that

381
00:17:48,660 --> 00:17:51,120
they can generate the matrices in the

382
00:17:51,120 --> 00:17:53,580
prior level without dropped off so now

383
00:17:53,580 --> 00:17:56,280
we can say that also LW with respect to

384
00:17:56,280 --> 00:17:58,919
them is hard and then we can apply this

385
00:17:58,919 --> 00:18:01,020
again and again and again from the end

386
00:18:01,020 --> 00:18:02,280
to the beginning of the branching

387
00:18:02,280 --> 00:18:04,679
program until eventually the entire

388
00:18:04,679 --> 00:18:07,740
system is

389
00:18:07,740 --> 00:18:11,100
there so now we want to apply a similar

390
00:18:11,100 --> 00:18:12,960
analysis to the multi-state branching

391
00:18:12,960 --> 00:18:16,500
program that we presented earlier

392
00:18:16,500 --> 00:18:18,660
what is the problem

393
00:18:18,660 --> 00:18:22,020
we call that the very first step was the

394
00:18:22,020 --> 00:18:23,880
assumption that LW with respect to all

395
00:18:23,880 --> 00:18:26,340
of the output material says is hard but

396
00:18:26,340 --> 00:18:28,200
now this assumption is not true because

397
00:18:28,200 --> 00:18:30,900
these matrices are correlated in fact if

398
00:18:30,900 --> 00:18:32,700
I had a library with respect to all of

399
00:18:32,700 --> 00:18:34,919
them I could take the sun and it would

400
00:18:34,919 --> 00:18:36,720
result in zero

401
00:18:36,720 --> 00:18:42,320
so I cannot apply the same technique

402
00:18:42,660 --> 00:18:47,640
so in order to tackle that we divide the

403
00:18:47,640 --> 00:18:50,760
security proof to Stu to two steps and

404
00:18:50,760 --> 00:18:52,980
in the middle we'd find a security game

405
00:18:52,980 --> 00:18:56,760
against uh some designated Oracle and

406
00:18:56,760 --> 00:19:01,320
this Oracle exactly emulates uh the

407
00:19:01,320 --> 00:19:04,020
belief that I started earlier so this

408
00:19:04,020 --> 00:19:08,340
Oracle receives as input as a query

409
00:19:08,340 --> 00:19:11,340
some evaluation sequence

410
00:19:11,340 --> 00:19:15,120
and in return it replies with an with LW

411
00:19:15,120 --> 00:19:17,880
instances according to all of the output

412
00:19:17,880 --> 00:19:20,039
matrices that could be reached with this

413
00:19:20,039 --> 00:19:21,900
evaluation sequence

414
00:19:21,900 --> 00:19:25,740
so we have this sequence and for every

415
00:19:25,740 --> 00:19:28,679
uh input bit for which it is consistent

416
00:19:28,679 --> 00:19:31,980
for we can get LW with respect to the

417
00:19:31,980 --> 00:19:35,460
output Matrix B of this memory cell and

418
00:19:35,460 --> 00:19:40,500
in addition if this if this x leads to

419
00:19:40,500 --> 00:19:42,179
the accepting state of the branching

420
00:19:42,179 --> 00:19:44,280
program that computes F we can also get

421
00:19:44,280 --> 00:19:48,000
LW with respect to to it so of course if

422
00:19:48,000 --> 00:19:49,919
there is a valid witness and the

423
00:19:49,919 --> 00:19:52,320
adversary knows it then this assumption

424
00:19:52,320 --> 00:19:57,059
also this game also becomes easy

425
00:19:57,059 --> 00:20:01,200
um so in fact if we assume this game

426
00:20:01,200 --> 00:20:03,720
which is not identical to the

427
00:20:03,720 --> 00:20:05,760
construction but we believe to be

428
00:20:05,760 --> 00:20:07,620
similar to the construction but if we

429
00:20:07,620 --> 00:20:09,480
assume this game we can actually prove

430
00:20:09,480 --> 00:20:12,720
that this game is hard and in order to

431
00:20:12,720 --> 00:20:15,419
prove that we need to use an exponential

432
00:20:15,419 --> 00:20:17,940
number of hybrids but this is a

433
00:20:17,940 --> 00:20:20,880
consistent with similar barriers that

434
00:20:20,880 --> 00:20:23,700
was shown in the construction of witness

435
00:20:23,700 --> 00:20:27,360
encryption from multilinear Maps so this

436
00:20:27,360 --> 00:20:30,120
is actually hints that this is a

437
00:20:30,120 --> 00:20:33,960
reasonable uh way to to analyze that

438
00:20:33,960 --> 00:20:38,760
so we can show that this game is uh is

439
00:20:38,760 --> 00:20:41,159
is hard at least the standard lwa using

440
00:20:41,159 --> 00:20:44,340
exponential number of hybrids and now in

441
00:20:44,340 --> 00:20:46,860
order to show that the construct the

442
00:20:46,860 --> 00:20:48,600
reconstruction with the encodings of the

443
00:20:48,600 --> 00:20:50,880
Multistate branching program in order to

444
00:20:50,880 --> 00:20:53,640
show that uh breaking the witness

445
00:20:53,640 --> 00:20:55,980
encryption is at least as hard as this

446
00:20:55,980 --> 00:20:58,080
game this is where we need to introduce

447
00:20:58,080 --> 00:21:01,860
uh the new assumptions

448
00:21:01,860 --> 00:21:04,799
and the

449
00:21:04,799 --> 00:21:07,580
and the new assumption

450
00:21:07,580 --> 00:21:11,640
very high level what it says is that if

451
00:21:11,640 --> 00:21:14,400
I have a trapdoor sample the best they

452
00:21:14,400 --> 00:21:16,559
can do is just to use it as I'm supposed

453
00:21:16,559 --> 00:21:19,799
to use it so if I have lwa with respect

454
00:21:19,799 --> 00:21:22,500
to a and also some trapped or sample

455
00:21:22,500 --> 00:21:24,900
that leads from A to B

456
00:21:24,900 --> 00:21:27,840
I have the same Advantage as if I would

457
00:21:27,840 --> 00:21:30,539
would as if I would be given directly

458
00:21:30,539 --> 00:21:34,260
nwe with respect to A and B so this is

459
00:21:34,260 --> 00:21:36,840
somewhat like semi honest security of

460
00:21:36,840 --> 00:21:39,240
drop those samples the only thing you

461
00:21:39,240 --> 00:21:42,299
can learn from the trapdoor is is the

462
00:21:42,299 --> 00:21:43,679
same that you could learn if you were

463
00:21:43,679 --> 00:21:46,559
just applying it on on the lwe that that

464
00:21:46,559 --> 00:21:48,780
you were to receive so under this

465
00:21:48,780 --> 00:21:51,780
assumption we can take the construction

466
00:21:51,780 --> 00:21:54,240
of the witness encryption and replace

467
00:21:54,240 --> 00:21:58,020
each of the encodings of the levels with

468
00:21:58,020 --> 00:22:01,080
more matrices of LW that could be

469
00:22:01,080 --> 00:22:03,539
accessed and after we apply it for each

470
00:22:03,539 --> 00:22:06,360
step of the the branching program we end

471
00:22:06,360 --> 00:22:08,580
up with an identical game to the one

472
00:22:08,580 --> 00:22:10,500
that we saw earlier with the Oracle

473
00:22:10,500 --> 00:22:13,220
which we already

474
00:22:13,220 --> 00:22:16,559
proved to be secure under standards LW

475
00:22:16,559 --> 00:22:19,440
so just to sum up we start with the

476
00:22:19,440 --> 00:22:21,960
witness encryption security game we use

477
00:22:21,960 --> 00:22:24,480
the Assumption to show a reduction to

478
00:22:24,480 --> 00:22:27,840
the to the intermediate Oracle game and

479
00:22:27,840 --> 00:22:29,400
then we use exponential number of

480
00:22:29,400 --> 00:22:31,440
hybrids to show that this is as hard as

481
00:22:31,440 --> 00:22:36,620
a standard LW and yeah that's it

482
00:23:01,200 --> 00:23:04,200
foreign

483
00:23:26,120 --> 00:23:27,860
thank you

484
00:23:27,860 --> 00:23:31,020
so we also presented a simplified

485
00:23:31,020 --> 00:23:32,820
scenario independent of the witness

486
00:23:32,820 --> 00:23:36,600
encryption scheme and we showed that if

487
00:23:36,600 --> 00:23:38,159
you can break the Assumption then you

488
00:23:38,159 --> 00:23:41,700
can break this toy example so you can

489
00:23:41,700 --> 00:23:44,460
play with that and better grasp the

490
00:23:44,460 --> 00:23:47,220
intuition but we don't have any

491
00:23:47,220 --> 00:23:48,120
um

492
00:23:48,120 --> 00:23:50,179
formal security

493
00:23:50,179 --> 00:23:53,720
analysis beyond that

494
00:25:34,380 --> 00:25:36,360
can everyone hear me

495
00:25:36,360 --> 00:25:38,039
yes

496
00:25:38,039 --> 00:25:39,900
uh so thanks for the introduction I'm

497
00:25:39,900 --> 00:25:41,659
going to be talking about the

498
00:25:41,659 --> 00:25:43,500
countermeasure for recent attacks

499
00:25:43,500 --> 00:25:46,679
against ins against cks and uh

500
00:25:46,679 --> 00:25:50,179
relatively new security mode

501
00:25:51,260 --> 00:25:55,279
which way do you need to go to advances

502
00:26:01,200 --> 00:26:04,020
so it is a high level I'm hoping to get

503
00:26:04,020 --> 00:26:06,840
through some preliminaries and then the

504
00:26:06,840 --> 00:26:08,400
actual countermeasure that we ended up

505
00:26:08,400 --> 00:26:10,100
having was the second point

506
00:26:10,100 --> 00:26:12,120
for people who aren't as interested in

507
00:26:12,120 --> 00:26:14,760
fhe in particular we use a novel notion

508
00:26:14,760 --> 00:26:16,860
that kind of mixes both computational

509
00:26:16,860 --> 00:26:18,840
and statistical Primitives the notion of

510
00:26:18,840 --> 00:26:20,820
its security that seems well adapted to

511
00:26:20,820 --> 00:26:22,260
this setting it may be useful in other

512
00:26:22,260 --> 00:26:25,200
non-fag settings as well and then if I

513
00:26:25,200 --> 00:26:26,760
have time I'll get some attacks on I

514
00:26:26,760 --> 00:26:27,960
countermeasured the palace I didn't

515
00:26:27,960 --> 00:26:30,539
implement it this countermeasure used a

516
00:26:30,539 --> 00:26:32,880
different correctness notion than uh the

517
00:26:32,880 --> 00:26:34,020
kind of correctness notion that we use

518
00:26:34,020 --> 00:26:37,679
in our uh positive results uh and this

519
00:26:37,679 --> 00:26:39,360
different correctness notion uh leads to

520
00:26:39,360 --> 00:26:41,760
some security issues

521
00:26:41,760 --> 00:26:44,279
can you speak a little louder please yes

522
00:26:44,279 --> 00:26:47,760
uh so uh so fully homomorphic at a high

523
00:26:47,760 --> 00:26:49,919
level it's a crypto system inside to be

524
00:26:49,919 --> 00:26:52,799
fully homomorphic if it admits ways to

525
00:26:52,799 --> 00:26:54,179
compute homomorphic additions and

526
00:26:54,179 --> 00:26:56,279
multiplications so given cyber texts you

527
00:26:56,279 --> 00:26:57,900
can compute encryptions of the sum of

528
00:26:57,900 --> 00:26:59,340
the crypted values and the product to

529
00:26:59,340 --> 00:27:00,980
make crypto values

530
00:27:00,980 --> 00:27:04,559
uh given some products are in Universal

531
00:27:04,559 --> 00:27:06,120
Gates the surprises compute arbitrary

532
00:27:06,120 --> 00:27:08,100
Boolean functions

533
00:27:08,100 --> 00:27:08,880
um and there have been many

534
00:27:08,880 --> 00:27:10,140
constructions of literature this is just

535
00:27:10,140 --> 00:27:12,299
a very very short list

536
00:27:12,299 --> 00:27:14,039
we're primarily going to be focused with

537
00:27:14,039 --> 00:27:17,159
the last member of this list the ckks

538
00:27:17,159 --> 00:27:19,500
cryptosystem which is only approximately

539
00:27:19,500 --> 00:27:22,020
correct in a certain sense

540
00:27:22,020 --> 00:27:23,840
so uh

541
00:27:23,840 --> 00:27:26,580
for a quick example application of FHA

542
00:27:26,580 --> 00:27:28,080
this is going to indicate how this

543
00:27:28,080 --> 00:27:30,360
approximate correctness can lead to some

544
00:27:30,360 --> 00:27:32,399
security issues

545
00:27:32,399 --> 00:27:34,679
a user might encrypt some data and then

546
00:27:34,679 --> 00:27:36,240
send it some server to a homomorphically

547
00:27:36,240 --> 00:27:39,000
compute some function This Server then

548
00:27:39,000 --> 00:27:40,620
would send the result to whoever holds

549
00:27:40,620 --> 00:27:42,360
the secret key who could then decrypt

550
00:27:42,360 --> 00:27:43,200
things

551
00:27:43,200 --> 00:27:45,240
so here the user can passively observe a

552
00:27:45,240 --> 00:27:46,919
couple of things they can observe cyber

553
00:27:46,919 --> 00:27:49,380
texts that are on the wire they can also

554
00:27:49,380 --> 00:27:51,840
Reserve observe the results of common

555
00:27:51,840 --> 00:27:54,059
market computations and potentially even

556
00:27:54,059 --> 00:27:55,500
the behavior of the secret keyholder

557
00:27:55,500 --> 00:27:57,600
after they decrypt the results

558
00:27:57,600 --> 00:28:00,480
so uh Liam matron noticed that for

559
00:28:00,480 --> 00:28:02,340
correct encryption an adversary doesn't

560
00:28:02,340 --> 00:28:03,899
need to observe this last quantity in

561
00:28:03,899 --> 00:28:05,880
fact the Standard ncpa Security game is

562
00:28:05,880 --> 00:28:07,200
undefined with respect to decryption

563
00:28:07,200 --> 00:28:09,779
articles they might as well not exist

564
00:28:09,779 --> 00:28:11,760
um and that's because you can just

565
00:28:11,760 --> 00:28:13,799
simulate this correct answer you know

566
00:28:13,799 --> 00:28:15,960
all the input uh plain text you know

567
00:28:15,960 --> 00:28:18,779
what computation happened so if it's

568
00:28:18,779 --> 00:28:20,460
correct you know the correct answer

569
00:28:20,460 --> 00:28:22,200
uh so you can locally compete with the

570
00:28:22,200 --> 00:28:23,520
decrypted integration should be but for

571
00:28:23,520 --> 00:28:25,620
incorrect encryption this decryption uh

572
00:28:25,620 --> 00:28:26,940
you can't simulate it anymore it might

573
00:28:26,940 --> 00:28:28,559
leak information it's something that

574
00:28:28,559 --> 00:28:30,299
really ought to be considered in the

575
00:28:30,299 --> 00:28:33,000
security game uh at a high level this is

576
00:28:33,000 --> 00:28:35,100
what ncpad security is it's ncpa with

577
00:28:35,100 --> 00:28:36,779
decryption articles this is different

578
00:28:36,779 --> 00:28:39,720
than NCCA security so NCCA security you

579
00:28:39,720 --> 00:28:41,820
can decrypt arbitrary plain texts here

580
00:28:41,820 --> 00:28:43,260
we're saying that you can only decrypt

581
00:28:43,260 --> 00:28:45,120
plain texts that are somehow honestly

582
00:28:45,120 --> 00:28:47,460
generated so you as a user you're

583
00:28:47,460 --> 00:28:49,020
honestly interacting with the fhe

584
00:28:49,020 --> 00:28:51,179
encryption API and you know the

585
00:28:51,179 --> 00:28:53,159
evaluation API and all these things and

586
00:28:53,159 --> 00:28:55,679
somehow you've created a blank uh cyber

587
00:28:55,679 --> 00:28:58,140
text in this way that decrypts and leaks

588
00:28:58,140 --> 00:28:59,520
secret information

589
00:28:59,520 --> 00:29:01,860
and we also need this notion of Q and

590
00:29:01,860 --> 00:29:04,020
CPA D which is where you restrict number

591
00:29:04,020 --> 00:29:05,340
of decryption queries that are allowed

592
00:29:05,340 --> 00:29:07,020
you restrict the amount of leakage that

593
00:29:07,020 --> 00:29:08,460
could potentially happen

594
00:29:08,460 --> 00:29:10,679
so Lee and Machan show in this work they

595
00:29:10,679 --> 00:29:13,620
found that ckks this well-known FHA SCH

596
00:29:13,620 --> 00:29:15,539
scheme is vulnerable to attacks in this

597
00:29:15,539 --> 00:29:18,659
qncpad model so our work is going to be

598
00:29:18,659 --> 00:29:20,760
fixing these attacks

599
00:29:20,760 --> 00:29:22,860
so first why would you want to use

600
00:29:22,860 --> 00:29:24,779
approximately homework encryption or

601
00:29:24,779 --> 00:29:26,700
many applications of fhg are in privacy

602
00:29:26,700 --> 00:29:29,399
preserving machine learning uh here the

603
00:29:29,399 --> 00:29:30,539
computations only really need to be

604
00:29:30,539 --> 00:29:31,620
approximate in the underlying

605
00:29:31,620 --> 00:29:32,760
computational models often floating

606
00:29:32,760 --> 00:29:34,260
Point arithmetic anyway

607
00:29:34,260 --> 00:29:36,779
uh so in the setting cks is particularly

608
00:29:36,779 --> 00:29:38,940
popular it's easy to use for homework

609
00:29:38,940 --> 00:29:40,200
the computations that involve the

610
00:29:40,200 --> 00:29:41,640
approximations of real numbers of

611
00:29:41,640 --> 00:29:42,960
floating Point numbers

612
00:29:42,960 --> 00:29:45,000
uh what is approximately correct your

613
00:29:45,000 --> 00:29:46,080
mean

614
00:29:46,080 --> 00:29:48,840
uh so in the ncpad setting no this

615
00:29:48,840 --> 00:29:50,580
correctness definition directly impacts

616
00:29:50,580 --> 00:29:52,799
the security of the crypto system not

617
00:29:52,799 --> 00:29:55,380
only just the output quality so having a

618
00:29:55,380 --> 00:29:57,360
good formal definition of it really does

619
00:29:57,360 --> 00:29:59,580
matter because an imprecise definition

620
00:29:59,580 --> 00:30:01,440
or an incorrect definition could

621
00:30:01,440 --> 00:30:03,899
directly lead to security issues

622
00:30:03,899 --> 00:30:07,020
so at a high level we think about

623
00:30:07,020 --> 00:30:08,940
correctness in terms of what we call the

624
00:30:08,940 --> 00:30:11,340
plaintext error for this slide this

625
00:30:11,340 --> 00:30:14,580
title so essentially if you're given a

626
00:30:14,580 --> 00:30:16,320
ciphertext that you expect to encrypt

627
00:30:16,320 --> 00:30:18,840
some message M and a secret key the

628
00:30:18,840 --> 00:30:20,340
plaintext error is just the difference

629
00:30:20,340 --> 00:30:22,620
between the decrypted value and the

630
00:30:22,620 --> 00:30:24,299
expected value and then to simplify

631
00:30:24,299 --> 00:30:25,440
things we'll talk about the norm so this

632
00:30:25,440 --> 00:30:27,000
is just a real number

633
00:30:27,000 --> 00:30:29,159
so this will be correct if the plaintext

634
00:30:29,159 --> 00:30:30,899
error is zero this is going to be true

635
00:30:30,899 --> 00:30:33,840
for most fheens that you consider as

636
00:30:33,840 --> 00:30:35,220
long as you bootstrap at the appropriate

637
00:30:35,220 --> 00:30:37,260
times and things like this

638
00:30:37,260 --> 00:30:39,720
we'll call it statically correct if this

639
00:30:39,720 --> 00:30:41,100
plain text error can be bounded by some

640
00:30:41,100 --> 00:30:43,500
public function of the circuit that

641
00:30:43,500 --> 00:30:45,240
you're Computing D and maybe the Norms

642
00:30:45,240 --> 00:30:47,640
of the inputs to the plain texts so this

643
00:30:47,640 --> 00:30:49,679
is we call it static because it's in the

644
00:30:49,679 --> 00:30:51,360
sense of static typing in principle if

645
00:30:51,360 --> 00:30:52,980
you have some compiler for an fhg

646
00:30:52,980 --> 00:30:54,179
program it could compute all these

647
00:30:54,179 --> 00:30:56,700
bounds beforehand and know this without

648
00:30:56,700 --> 00:30:58,260
ever running any of the computation

649
00:30:58,260 --> 00:30:59,820
without generating any Keys any of these

650
00:30:59,820 --> 00:31:00,659
things

651
00:31:00,659 --> 00:31:02,399
uh and then there's this other notion

652
00:31:02,399 --> 00:31:04,200
called dynamically dynamically correct

653
00:31:04,200 --> 00:31:07,320
uh uh which is where this plaintext

654
00:31:07,320 --> 00:31:09,179
error can still be bounded but it's

655
00:31:09,179 --> 00:31:11,519
bounded as a function of the Cyber text

656
00:31:11,519 --> 00:31:13,019
that you want to analyze the error of

657
00:31:13,019 --> 00:31:15,059
and also the secret key uh so this is

658
00:31:15,059 --> 00:31:16,679
really only computable during decryption

659
00:31:16,679 --> 00:31:18,059
and since it's a function of the secret

660
00:31:18,059 --> 00:31:19,559
key it could possibly leak some secret

661
00:31:19,559 --> 00:31:20,640
information

662
00:31:20,640 --> 00:31:23,220
and that'll come up later

663
00:31:23,220 --> 00:31:25,740
so next let's talk about our

664
00:31:25,740 --> 00:31:27,080
countermeasures

665
00:31:27,080 --> 00:31:31,380
to these Q ncpad attacks on ckas

666
00:31:31,380 --> 00:31:34,919
so at a very high level are uh how we

667
00:31:34,919 --> 00:31:36,600
secure things it's kind of how you would

668
00:31:36,600 --> 00:31:37,860
expect and it's how a lot of Library

669
00:31:37,860 --> 00:31:39,299
authors at least preliminarily

670
00:31:39,299 --> 00:31:40,799
implemented things in response to the

671
00:31:40,799 --> 00:31:43,260
attacks so you start with a true

672
00:31:43,260 --> 00:31:46,320
statically correct scheme so by this

673
00:31:46,320 --> 00:31:47,820
what I mean is that you start with a

674
00:31:47,820 --> 00:31:50,100
scheme that has some approximation error

675
00:31:50,100 --> 00:31:52,380
that you can bound then you post process

676
00:31:52,380 --> 00:31:53,640
the description with some notion of

677
00:31:53,640 --> 00:31:55,260
differential privacy in practice most

678
00:31:55,260 --> 00:31:56,880
people use noise flooding some libraries

679
00:31:56,880 --> 00:31:58,019
did slightly different things the

680
00:31:58,019 --> 00:32:00,419
details won't be too important

681
00:32:00,419 --> 00:32:02,220
um we want to use this differentially

682
00:32:02,220 --> 00:32:04,019
private notion so that these true

683
00:32:04,019 --> 00:32:06,720
statically correct uh decryptions are

684
00:32:06,720 --> 00:32:08,880
indistinguishable from a post-process

685
00:32:08,880 --> 00:32:12,299
form of correct decryptions so because

686
00:32:12,299 --> 00:32:13,500
it's statically correct there's a small

687
00:32:13,500 --> 00:32:15,000
amount of error if you can kind of hide

688
00:32:15,000 --> 00:32:16,620
this amount of error and then you can

689
00:32:16,620 --> 00:32:17,880
switch from a world where you have

690
00:32:17,880 --> 00:32:20,220
potentially incorrect encryption to a

691
00:32:20,220 --> 00:32:22,140
world where you have correct encryption

692
00:32:22,140 --> 00:32:23,940
and in this world everything's just much

693
00:32:23,940 --> 00:32:26,100
easier it's known that ncpad security or

694
00:32:26,100 --> 00:32:28,740
qncpd security is equivalent to ncpa

695
00:32:28,740 --> 00:32:31,559
security via correct decryption

696
00:32:31,559 --> 00:32:33,299
so in terms of this high level argument

697
00:32:33,299 --> 00:32:35,340
which directly after the Louis michonto

698
00:32:35,340 --> 00:32:37,200
paper came out it was you know fairly

699
00:32:37,200 --> 00:32:38,940
obvious to do our work is essentially

700
00:32:38,940 --> 00:32:40,980
this General analysis of post-processing

701
00:32:40,980 --> 00:32:42,960
so we have this different uh viewpoint

702
00:32:42,960 --> 00:32:45,419
on uh viewing caption noise flooding is

703
00:32:45,419 --> 00:32:47,100
differential privacy which is somewhat

704
00:32:47,100 --> 00:32:49,200
nice and leads to some possible

705
00:32:49,200 --> 00:32:51,720
generalizations uh but the big thing is

706
00:32:51,720 --> 00:32:53,880
that we give nearly tight balance so we

707
00:32:53,880 --> 00:32:55,500
have a very efficient analysis of

708
00:32:55,500 --> 00:32:57,419
gaussian noise flooding and this

709
00:32:57,419 --> 00:32:59,100
includes giving a novel weakening

710
00:32:59,100 --> 00:33:00,360
concrete security that lets us get even

711
00:33:00,360 --> 00:33:02,820
tighter bounds uh roughly speaking you

712
00:33:02,820 --> 00:33:04,200
can always flood with very large noise

713
00:33:04,200 --> 00:33:05,580
everything will be secure but maybe no

714
00:33:05,580 --> 00:33:07,380
one wants to use the scheme anymore so

715
00:33:07,380 --> 00:33:08,820
our tight bounds are going to show that

716
00:33:08,820 --> 00:33:10,799
you know if you want to evaluate whether

717
00:33:10,799 --> 00:33:12,360
you want to use cks anymore you at least

718
00:33:12,360 --> 00:33:13,919
know the precise right number for how

719
00:33:13,919 --> 00:33:15,840
much noise you have to have

720
00:33:15,840 --> 00:33:18,059
so next let's talk about the notion of

721
00:33:18,059 --> 00:33:19,740
differential privacy we use which we

722
00:33:19,740 --> 00:33:22,200
call Norm kale differential privacy

723
00:33:22,200 --> 00:33:24,899
so it's a family randomized algorithms

724
00:33:24,899 --> 00:33:27,840
along input uh some value it outputs a

725
00:33:27,840 --> 00:33:29,519
distribution over values and it's

726
00:33:29,519 --> 00:33:31,980
indexed by some distance parameter T and

727
00:33:31,980 --> 00:33:33,779
we say that it's this family randomized

728
00:33:33,779 --> 00:33:35,340
algorithms is row KL differentially

729
00:33:35,340 --> 00:33:37,559
private if for any inputs that are

730
00:33:37,559 --> 00:33:39,539
within T distance of each other in

731
00:33:39,539 --> 00:33:43,019
whatever this Norm is uh there's the

732
00:33:43,019 --> 00:33:45,120
kale Divergence Divergence between them

733
00:33:45,120 --> 00:33:47,760
is at most row or between the outputs

734
00:33:47,760 --> 00:33:49,860
that are truly private algorithm uh

735
00:33:49,860 --> 00:33:52,860
outputs this is really a generalization

736
00:33:52,860 --> 00:33:54,299
of what's known as many differential

737
00:33:54,299 --> 00:33:55,679
privacy from the Hamming Norm to General

738
00:33:55,679 --> 00:33:57,779
Norms a lot of the literature and

739
00:33:57,779 --> 00:33:59,279
differential privacy you can view it as

740
00:33:59,279 --> 00:34:01,919
uh one of these uh Norm differential

741
00:34:01,919 --> 00:34:03,360
privacy schemes whatever you want to

742
00:34:03,360 --> 00:34:05,460
call them uh in terms of specifically

743
00:34:05,460 --> 00:34:07,559
the handling

744
00:34:07,559 --> 00:34:09,179
uh here it we should know that it's

745
00:34:09,179 --> 00:34:10,739
vital that are differentially private

746
00:34:10,739 --> 00:34:12,179
mechanism does take us in by this

747
00:34:12,179 --> 00:34:13,980
distance parameter t or standard

748
00:34:13,980 --> 00:34:15,480
differential privacy you can often

749
00:34:15,480 --> 00:34:16,619
implicitly set this to one and

750
00:34:16,619 --> 00:34:18,239
everything works out fine so this is a

751
00:34:18,239 --> 00:34:19,440
slight difference in our setting which

752
00:34:19,440 --> 00:34:21,560
is maybe worth mentioning

753
00:34:21,560 --> 00:34:24,540
uh and next let's talk about about kale

754
00:34:24,540 --> 00:34:26,099
differential private mechanism which is

755
00:34:26,099 --> 00:34:29,040
the main example that most people in who

756
00:34:29,040 --> 00:34:30,179
work on these things will be familiar

757
00:34:30,179 --> 00:34:31,379
with which is the discrete gaussian

758
00:34:31,379 --> 00:34:34,020
mechanism so for some parameter row this

759
00:34:34,020 --> 00:34:36,000
is mechanism that on input some integer

760
00:34:36,000 --> 00:34:39,599
value outputs a gaussian sample uh of a

761
00:34:39,599 --> 00:34:41,579
very particular discrete caption and

762
00:34:41,579 --> 00:34:42,719
this satisfies our notion of

763
00:34:42,719 --> 00:34:45,060
differential privacy it's the example

764
00:34:45,060 --> 00:34:46,320
that we analyze the most and it's the

765
00:34:46,320 --> 00:34:47,399
example that's probably the most well

766
00:34:47,399 --> 00:34:51,060
known both it and also instead of using

767
00:34:51,060 --> 00:34:52,560
gaussian noise you can use bounded

768
00:34:52,560 --> 00:34:54,060
uniform noises is also fairly common

769
00:34:54,060 --> 00:34:57,119
although we don't analyze it as much

770
00:34:57,119 --> 00:34:58,500
um next let's talk about our concrete

771
00:34:58,500 --> 00:35:00,540
notion of security so we use a notion of

772
00:35:00,540 --> 00:35:02,579
bit security due to machancho and Walter

773
00:35:02,579 --> 00:35:05,040
so here are particles had to have C bits

774
00:35:05,040 --> 00:35:06,720
of security and some cryptographic game

775
00:35:06,720 --> 00:35:08,460
if for every adversary there's a very

776
00:35:08,460 --> 00:35:09,960
concrete trade-off between its running

777
00:35:09,960 --> 00:35:12,540
time T of a and its Advantage uh

778
00:35:12,540 --> 00:35:15,359
Advantage shape some G so in particular

779
00:35:15,359 --> 00:35:18,540
disk uh expression is lower bounded by C

780
00:35:18,540 --> 00:35:21,060
so for search games disadvantage takes a

781
00:35:21,060 --> 00:35:22,560
form you probably expect it's just the

782
00:35:22,560 --> 00:35:25,260
success probability of the search of

783
00:35:25,260 --> 00:35:26,579
finding the thing that you're searching

784
00:35:26,579 --> 00:35:29,040
for for decision games in the Metro

785
00:35:29,040 --> 00:35:30,420
Wilder framework it does take a

786
00:35:30,420 --> 00:35:33,780
different uh form I won't copy the exact

787
00:35:33,780 --> 00:35:35,280
form here it's a little bit intricate

788
00:35:35,280 --> 00:35:37,440
but roughly speaking it scales with the

789
00:35:37,440 --> 00:35:38,820
square of the total variation distance

790
00:35:38,820 --> 00:35:40,020
between the two distributions you're

791
00:35:40,020 --> 00:35:42,599
distinguishing whereas uh perhaps the

792
00:35:42,599 --> 00:35:44,700
standard notion of uh Advantage for

793
00:35:44,700 --> 00:35:46,980
decision games this is linear with the

794
00:35:46,980 --> 00:35:48,720
total variation distance so there is a

795
00:35:48,720 --> 00:35:51,540
slight difference here to be wary of but

796
00:35:51,540 --> 00:35:52,920
when John 12 authors suggested this

797
00:35:52,920 --> 00:35:54,599
notion as it resolves several paradoxes

798
00:35:54,599 --> 00:35:56,880
with respect to when you have uh when

799
00:35:56,880 --> 00:35:58,619
you wanted to find pit pit security for

800
00:35:58,619 --> 00:36:00,060
a search primitive or a decision

801
00:36:00,060 --> 00:36:02,160
primitive and you want to expect them to

802
00:36:02,160 --> 00:36:04,579
have similar amounts of bit security and

803
00:36:04,579 --> 00:36:06,780
I suggest you read the magenta Walter

804
00:36:06,780 --> 00:36:09,900
paper for a better motivation

805
00:36:09,900 --> 00:36:12,900
so in terms of all these preliminaries

806
00:36:12,900 --> 00:36:15,000
we can talk about at least to simplify

807
00:36:15,000 --> 00:36:16,859
for now form of our main theorem which

808
00:36:16,859 --> 00:36:18,900
is that if ckks has a very particular

809
00:36:18,900 --> 00:36:21,780
amount of ncpa bit security so C plus

810
00:36:21,780 --> 00:36:24,720
log 2 base 20 log base 2 of 24 where C

811
00:36:24,720 --> 00:36:26,880
is our security parameter then modifying

812
00:36:26,880 --> 00:36:29,040
ctk has to decrypt via Computing this

813
00:36:29,040 --> 00:36:30,780
aforementioned publicly computable bound

814
00:36:30,780 --> 00:36:33,839
on a plain text error and then returning

815
00:36:33,839 --> 00:36:37,320
a modified decryption which uh adds a

816
00:36:37,320 --> 00:36:39,060
very specific amount of gaussian noise

817
00:36:39,060 --> 00:36:42,660
to the decrypted value is C bit q and

818
00:36:42,660 --> 00:36:45,000
cpad is secure

819
00:36:45,000 --> 00:36:46,560
um the way you want to think about this

820
00:36:46,560 --> 00:36:47,760
particular amount of gaussian noise you

821
00:36:47,760 --> 00:36:50,339
had is that it's C over 2 plus a term

822
00:36:50,339 --> 00:36:52,980
that's sublinear and n and q so you

823
00:36:52,980 --> 00:36:54,119
should use it for concrete computations

824
00:36:54,119 --> 00:36:55,460
but it's perhaps not the dominant term

825
00:36:55,460 --> 00:36:58,320
uh plus a constant bit of additional

826
00:36:58,320 --> 00:37:00,359
noise there's this t-squared term that

827
00:37:00,359 --> 00:37:02,400
appears in the variance or the standard

828
00:37:02,400 --> 00:37:03,780
deviation as well

829
00:37:03,780 --> 00:37:05,700
um where this t-squared term measures

830
00:37:05,700 --> 00:37:06,900
the noise that's already in the

831
00:37:06,900 --> 00:37:09,420
ciphertext so we have to add noise on

832
00:37:09,420 --> 00:37:11,579
top of that the amount at least the

833
00:37:11,579 --> 00:37:13,380
highest order determinant is the C over

834
00:37:13,380 --> 00:37:14,820
two

835
00:37:14,820 --> 00:37:17,099
uh there's this natural question okay we

836
00:37:17,099 --> 00:37:18,720
have a countermeasure it introduces C

837
00:37:18,720 --> 00:37:20,460
over two roughly bits of additional

838
00:37:20,460 --> 00:37:22,740
noise uh you can introduce many

839
00:37:22,740 --> 00:37:23,940
countermeasures that make things secure

840
00:37:23,940 --> 00:37:26,280
but do it inefficiently so uh is this C

841
00:37:26,280 --> 00:37:27,960
over two optimal or can it be made lower

842
00:37:27,960 --> 00:37:30,359
the answer that we have is that it can't

843
00:37:30,359 --> 00:37:32,760
be made much lower at least without

844
00:37:32,760 --> 00:37:34,859
using a weaker security definition which

845
00:37:34,859 --> 00:37:36,720
I'll get to eventually

846
00:37:36,720 --> 00:37:38,880
first let's talk about why it can be

847
00:37:38,880 --> 00:37:40,200
made in the floor it's because there's a

848
00:37:40,200 --> 00:37:42,000
matching attack so there's just a very

849
00:37:42,000 --> 00:37:44,520
specific program so here if you see this

850
00:37:44,520 --> 00:37:47,460
G function on uh it looks like five or

851
00:37:47,460 --> 00:37:50,160
ten lines down it computes an inner a

852
00:37:50,160 --> 00:37:52,800
number of inner products roughly there's

853
00:37:52,800 --> 00:37:54,180
a very particular function that you can

854
00:37:54,180 --> 00:37:57,660
analyze that uh shows that using C over

855
00:37:57,660 --> 00:38:00,180
four bits uh is required if you use less

856
00:38:00,180 --> 00:38:01,500
than zero for four bits this will no

857
00:38:01,500 --> 00:38:02,640
longer achieve the concrete security

858
00:38:02,640 --> 00:38:06,599
notion of C bits of ncbad security

859
00:38:06,599 --> 00:38:08,579
um I won't go over the analysis it's in

860
00:38:08,579 --> 00:38:10,200
the paper but it's a it's

861
00:38:10,200 --> 00:38:12,060
straightforward but it's maybe a little

862
00:38:12,060 --> 00:38:13,680
bit tedious to talk about it and talk

863
00:38:13,680 --> 00:38:14,880
like this

864
00:38:14,880 --> 00:38:16,680
so next I'm going to talk about the

865
00:38:16,680 --> 00:38:18,060
mixed computational statistical but

866
00:38:18,060 --> 00:38:19,560
security notion that we use this is

867
00:38:19,560 --> 00:38:20,880
going to be a weakening of the notion of

868
00:38:20,880 --> 00:38:22,859
bit security that we find very useful in

869
00:38:22,859 --> 00:38:25,140
our work and it doesn't seem fhe

870
00:38:25,140 --> 00:38:27,060
specific so it's something that may be

871
00:38:27,060 --> 00:38:28,920
broadly useful when mixing A

872
00:38:28,920 --> 00:38:30,420
computational Primitive and a

873
00:38:30,420 --> 00:38:32,240
statistical primitive

874
00:38:32,240 --> 00:38:35,099
so we call it the notion of Cs bits of

875
00:38:35,099 --> 00:38:37,140
security so particle said to have c s

876
00:38:37,140 --> 00:38:39,000
bits of security and some game G every

877
00:38:39,000 --> 00:38:40,740
adversary either satisfies this first

878
00:38:40,740 --> 00:38:42,780
down this is the same exact bound as in

879
00:38:42,780 --> 00:38:45,839
the c-bit of security uh notion or the

880
00:38:45,839 --> 00:38:48,119
second bound so notice that the second

881
00:38:48,119 --> 00:38:49,680
bound is independent of the running time

882
00:38:49,680 --> 00:38:52,200
of a so in particular we like to uh so

883
00:38:52,200 --> 00:38:54,300
first this notion for S smaller than C

884
00:38:54,300 --> 00:38:56,400
it will be easier to satisfy the c-bit

885
00:38:56,400 --> 00:38:58,140
of security notion just because there's

886
00:38:58,140 --> 00:39:01,500
an additional uh inequality that the

887
00:39:01,500 --> 00:39:04,200
adversary naked says

888
00:39:04,200 --> 00:39:06,119
uh but we view this as capturing

889
00:39:06,119 --> 00:39:08,220
statistical tax as well because the

890
00:39:08,220 --> 00:39:10,140
second bound even if her adversary has

891
00:39:10,140 --> 00:39:11,280
arbitrarily had running baton

892
00:39:11,280 --> 00:39:12,839
exponentially highs double exponentially

893
00:39:12,839 --> 00:39:14,160
High whatever

894
00:39:14,160 --> 00:39:16,380
um it still must satisfy this Advantage

895
00:39:16,380 --> 00:39:17,820
map so kind of even against these

896
00:39:17,820 --> 00:39:19,320
competition and bounded adversaries we

897
00:39:19,320 --> 00:39:20,940
uh this notion is something called great

898
00:39:20,940 --> 00:39:21,900
about them

899
00:39:21,900 --> 00:39:24,599
uh it's worth mentioning that you know

900
00:39:24,599 --> 00:39:27,180
doubly exponentially a time that

901
00:39:27,180 --> 00:39:28,920
adversaries May sometimes have issues

902
00:39:28,920 --> 00:39:30,420
reasoning about precisely what advantage

903
00:39:30,420 --> 00:39:32,040
they can shoot but for the statistical

904
00:39:32,040 --> 00:39:33,660
problems we apply this to often there's

905
00:39:33,660 --> 00:39:36,000
a optimal adversary that's very easy to

906
00:39:36,000 --> 00:39:39,240
describe so you can often either compute

907
00:39:39,240 --> 00:39:40,619
this explicitly or you can get a very

908
00:39:40,619 --> 00:39:41,880
type option

909
00:39:41,880 --> 00:39:43,980
and the whole motivation behind this

910
00:39:43,980 --> 00:39:45,660
definition is that we want to set s

911
00:39:45,660 --> 00:39:48,060
smaller than C if s is larger than the C

912
00:39:48,060 --> 00:39:49,260
you can actually show its equivalent to

913
00:39:49,260 --> 00:39:50,760
C bits of security so you get nothing

914
00:39:50,760 --> 00:39:53,280
new but for S less than C you get a very

915
00:39:53,280 --> 00:39:54,839
controlled weakening of the notion of

916
00:39:54,839 --> 00:39:57,000
bit security that will in terms of the

917
00:39:57,000 --> 00:39:58,859
parameters of our countermeasures will

918
00:39:58,859 --> 00:40:01,440
give us large gains

919
00:40:01,440 --> 00:40:03,180
so we can look at this week you can

920
00:40:03,180 --> 00:40:05,040
graphically uh through the following

921
00:40:05,040 --> 00:40:07,260
graph I plotted the log base 2 of the

922
00:40:07,260 --> 00:40:09,060
running time to the log base 2 of the

923
00:40:09,060 --> 00:40:11,220
inverse advantage of an adversary and

924
00:40:11,220 --> 00:40:13,619
what c-bit security or 128-bit security

925
00:40:13,619 --> 00:40:15,300
means in this situation is that any

926
00:40:15,300 --> 00:40:17,700
adversary runs uh falls into this blue

927
00:40:17,700 --> 00:40:20,160
portion of the graph so there are no

928
00:40:20,160 --> 00:40:22,800
adversaries in this mic portion now if

929
00:40:22,800 --> 00:40:25,319
we weaken this to 128 96 bits of

930
00:40:25,319 --> 00:40:27,000
security what this means now is any

931
00:40:27,000 --> 00:40:28,380
adversary either falls into this

932
00:40:28,380 --> 00:40:30,359
previous blue triangle or into this

933
00:40:30,359 --> 00:40:32,460
lighter blue or cyan triangle that is

934
00:40:32,460 --> 00:40:34,440
new in the upper left corner so there

935
00:40:34,440 --> 00:40:36,900
are more adversaries enabled Allowed by

936
00:40:36,900 --> 00:40:38,940
this definition so it is a weaker

937
00:40:38,940 --> 00:40:40,680
definition but you might notice that all

938
00:40:40,680 --> 00:40:43,380
of the adversaries that we allow have

939
00:40:43,380 --> 00:40:45,359
very small Advantage so in this case

940
00:40:45,359 --> 00:40:47,520
less than two to the minus 96 advantage

941
00:40:47,520 --> 00:40:49,200
or they're not appreciated was already

942
00:40:49,200 --> 00:40:51,660
considered so it's a weakening but it's

943
00:40:51,660 --> 00:40:55,020
in a very controlled way uh which uh and

944
00:40:55,020 --> 00:40:56,819
as I'll show next we'll be able to get

945
00:40:56,819 --> 00:40:59,760
large parameter uh kind of winds from it

946
00:40:59,760 --> 00:41:01,920
so now I'll give a version of the main

947
00:41:01,920 --> 00:41:05,880
theorem in terms of this uh CS security

948
00:41:05,880 --> 00:41:07,920
notion so if again you start with C plus

949
00:41:07,920 --> 00:41:11,579
log base 2 24 bit in CPA secure ckjs

950
00:41:11,579 --> 00:41:14,040
then modifying ckks in the exact same

951
00:41:14,040 --> 00:41:17,460
way uh gives you a CS a bit qncpad

952
00:41:17,460 --> 00:41:20,220
secure scheme so when I say the same way

953
00:41:20,220 --> 00:41:21,900
there's actually one very important

954
00:41:21,900 --> 00:41:24,180
difference here which is the before the

955
00:41:24,180 --> 00:41:26,460
variance of this gaussian had a

956
00:41:26,460 --> 00:41:28,680
parameter that was uh that had a 2 to

957
00:41:28,680 --> 00:41:30,780
the C parameter in it it was exponential

958
00:41:30,780 --> 00:41:33,359
in the computational security parameter

959
00:41:33,359 --> 00:41:36,240
but now it's 2 to the S it's exponential

960
00:41:36,240 --> 00:41:37,800
in the statistical sphere of the

961
00:41:37,800 --> 00:41:40,079
parameter so now instead of saying C

962
00:41:40,079 --> 00:41:42,180
over two bits supplies s over two bits

963
00:41:42,180 --> 00:41:45,780
will surprise uh so this will save us C

964
00:41:45,780 --> 00:41:47,280
minus s over two bits of noise compared

965
00:41:47,280 --> 00:41:49,200
to c-bit security

966
00:41:49,200 --> 00:41:51,480
um which can be quite sizable depending

967
00:41:51,480 --> 00:41:53,040
on how each that has to be so in

968
00:41:53,040 --> 00:41:55,260
particular uh here I have a plot of a

969
00:41:55,260 --> 00:41:56,460
bunch of different values of s and a

970
00:41:56,460 --> 00:41:57,300
bunch of different values of Q

971
00:41:57,300 --> 00:41:59,099
throughout I'm assuming that the lattice

972
00:41:59,099 --> 00:42:01,200
Dimension n is at most 2 to the 15. and

973
00:42:01,200 --> 00:42:03,240
note here that Q is not the lwe modulus

974
00:42:03,240 --> 00:42:04,200
or something like that but it's a bound

975
00:42:04,200 --> 00:42:05,339
to the number of Declaration queries

976
00:42:05,339 --> 00:42:08,700
that are allowed so the top line of this

977
00:42:08,700 --> 00:42:10,980
can be thought of uh it's equivalent to

978
00:42:10,980 --> 00:42:13,079
the notion of c-bit security for 128 so

979
00:42:13,079 --> 00:42:14,480
128 bit security

980
00:42:14,480 --> 00:42:16,740
so you can see that depending on how

981
00:42:16,740 --> 00:42:18,900
aggressively you want to choose s uh say

982
00:42:18,900 --> 00:42:22,200
s equals 80 on here then you can save it

983
00:42:22,200 --> 00:42:24,240
looks like about to 25 bits of security

984
00:42:24,240 --> 00:42:27,119
from the standard notion and this as I

985
00:42:27,119 --> 00:42:28,440
was mentioning before this does enable

986
00:42:28,440 --> 00:42:30,420
new attacks of Advantage 2 to the minus

987
00:42:30,420 --> 00:42:32,700
80. but those are the only new attacks

988
00:42:32,700 --> 00:42:34,140
it enables so it's a very controlled

989
00:42:34,140 --> 00:42:36,480
weakening and we're still able to reduce

990
00:42:36,480 --> 00:42:39,660
our countermeasures uh Noise by some is

991
00:42:39,660 --> 00:42:44,599
that some 25 in that case so uh

992
00:42:44,599 --> 00:42:46,980
There's an actual question we have a

993
00:42:46,980 --> 00:42:49,859
countermeasure for ckks is ckks still a

994
00:42:49,859 --> 00:42:51,420
competitive energy scheme if you use

995
00:42:51,420 --> 00:42:53,280
account measures or maybe there's a

996
00:42:53,280 --> 00:42:54,420
complaint that our countermeasured or

997
00:42:54,420 --> 00:42:57,720
somewhere large uh first I should

998
00:42:57,720 --> 00:42:59,040
mention that you're using this notion of

999
00:42:59,040 --> 00:43:01,380
Cs bits of security you can get uh

1000
00:43:01,380 --> 00:43:03,119
smaller countermeasures which I I

1001
00:43:03,119 --> 00:43:05,099
imagine people want to do in practice

1002
00:43:05,099 --> 00:43:06,900
but really these large countermeasures

1003
00:43:06,900 --> 00:43:08,940
Seem somewhat inherent at least in the

1004
00:43:08,940 --> 00:43:10,740
notion of in the case of c-bit security

1005
00:43:10,740 --> 00:43:13,380
we do have a lower bound so you're going

1006
00:43:13,380 --> 00:43:16,140
to lose roughly C over four at least uh

1007
00:43:16,140 --> 00:43:18,240
bits of precision you start with 128

1008
00:43:18,240 --> 00:43:20,040
bits that's what like you're losing 32

1009
00:43:20,040 --> 00:43:22,319
bits to security secret chaos at least

1010
00:43:22,319 --> 00:43:23,339
in this way

1011
00:43:23,339 --> 00:43:25,619
so there's the natural question okay

1012
00:43:25,619 --> 00:43:28,020
this you know theoretical if you know

1013
00:43:28,020 --> 00:43:29,460
direct formula can just be instantiated

1014
00:43:29,460 --> 00:43:32,040
in practice and it really depends on the

1015
00:43:32,040 --> 00:43:33,960
particular IG Library you're thinking

1016
00:43:33,960 --> 00:43:35,160
about

1017
00:43:35,160 --> 00:43:37,140
um so roughly speaking it'll depend on

1018
00:43:37,140 --> 00:43:39,060
how much Precision they kind of support

1019
00:43:39,060 --> 00:43:40,800
for their computations if you only

1020
00:43:40,800 --> 00:43:42,839
support 64 bits of precision then it

1021
00:43:42,839 --> 00:43:44,280
seems kind of hard to instantiate our

1022
00:43:44,280 --> 00:43:46,680
countermeasure and that reason is that

1023
00:43:46,680 --> 00:43:48,660
if you aggressively choose s so if you

1024
00:43:48,660 --> 00:43:50,880
chose s to be 32 bits then this is

1025
00:43:50,880 --> 00:43:52,740
already costing roughly 25 bits of noise

1026
00:43:52,740 --> 00:43:54,119
which is almost half of this entire

1027
00:43:54,119 --> 00:43:56,339
Precision budget

1028
00:43:56,339 --> 00:43:57,480
um and you still need to fit things like

1029
00:43:57,480 --> 00:43:59,640
the plaintext error and so after doing

1030
00:43:59,640 --> 00:44:01,140
that you probably can't expose an API

1031
00:44:01,140 --> 00:44:02,819
supporting general purpose 32-bit

1032
00:44:02,819 --> 00:44:04,440
computation which you might want to do

1033
00:44:04,440 --> 00:44:07,680
as a library author uh you can maybe do

1034
00:44:07,680 --> 00:44:09,900
uh use our countermeasure for the 64-bit

1035
00:44:09,900 --> 00:44:13,079
Precision cqks libraries uh by

1036
00:44:13,079 --> 00:44:15,000
supporting constrained meaning only 8 or

1037
00:44:15,000 --> 00:44:18,060
32 bits of precision and uh using

1038
00:44:18,060 --> 00:44:19,740
aggressive choices of apps but this is

1039
00:44:19,740 --> 00:44:22,560
maybe not ideal but the number of

1040
00:44:22,560 --> 00:44:24,900
libraries also Implement uh choose to

1041
00:44:24,900 --> 00:44:28,200
use 128 bits of precision and in this

1042
00:44:28,200 --> 00:44:29,640
setting it seems fairly easy to fit our

1043
00:44:29,640 --> 00:44:31,800
counter measure so you can

1044
00:44:31,800 --> 00:44:33,720
conservatively choose s even as high as

1045
00:44:33,720 --> 00:44:35,220
100 and still you very easily support

1046
00:44:35,220 --> 00:44:37,740
32-bit Precision computations

1047
00:44:37,740 --> 00:44:38,880
um this will of course come as some

1048
00:44:38,880 --> 00:44:40,380
overhead this is introducing more error

1049
00:44:40,380 --> 00:44:43,020
so evaluate evaluating that it will be

1050
00:44:43,020 --> 00:44:44,579
its own separate thing but at least for

1051
00:44:44,579 --> 00:44:46,440
implementing our countermeasure for

1052
00:44:46,440 --> 00:44:48,540
128-bit precision cqks libraries it's

1053
00:44:48,540 --> 00:44:51,259
very straightforward

1054
00:44:51,839 --> 00:44:55,380
um next let's talk about the texts on uh

1055
00:44:55,380 --> 00:44:56,760
let's briefly talk about some attacks on

1056
00:44:56,760 --> 00:44:58,020
countermeasures that were introduced in

1057
00:44:58,020 --> 00:44:59,099
Palisade

1058
00:44:59,099 --> 00:45:00,839
so recall that there was a notion of

1059
00:45:00,839 --> 00:45:01,920
dynamic correctness where you could

1060
00:45:01,920 --> 00:45:04,140
bound the plaintext error via something

1061
00:45:04,140 --> 00:45:05,520
computed during decryption so it's

1062
00:45:05,520 --> 00:45:08,160
secret key dependent so you're Republic

1063
00:45:08,160 --> 00:45:10,560
of one of the library maintainers of

1064
00:45:10,560 --> 00:45:12,780
Palisade had a very clever proposal for

1065
00:45:12,780 --> 00:45:15,800
how to do this so roughly

1066
00:45:15,800 --> 00:45:18,780
speaking you uh view the message space

1067
00:45:18,780 --> 00:45:20,460
as some set it's a Cartesian product

1068
00:45:20,460 --> 00:45:22,200
itself and you kind of Reserve half of

1069
00:45:22,200 --> 00:45:25,200
the uh kind of coordinates of it to be

1070
00:45:25,200 --> 00:45:27,420
all zero and you restrict to functions

1071
00:45:27,420 --> 00:45:29,520
that keep this very restricted subset

1072
00:45:29,520 --> 00:45:31,500
and variant so you have this restricted

1073
00:45:31,500 --> 00:45:34,140
message base you work with and then with

1074
00:45:34,140 --> 00:45:35,579
these lot of these coordinates that are

1075
00:45:35,579 --> 00:45:37,500
all zero you can then exactly measure

1076
00:45:37,500 --> 00:45:39,960
the plain text error that occurs in them

1077
00:45:39,960 --> 00:45:42,119
um and then we could take this measured

1078
00:45:42,119 --> 00:45:43,200
plain text error and you can hope to

1079
00:45:43,200 --> 00:45:44,640
generalize it to a measurement of the

1080
00:45:44,640 --> 00:45:46,619
plaintext error of the entire ciphertext

1081
00:45:46,619 --> 00:45:48,839
uh he ran some experiments and it seems

1082
00:45:48,839 --> 00:45:50,460
to work pretty well so there's this

1083
00:45:50,460 --> 00:45:51,720
question okay this will give us a better

1084
00:45:51,720 --> 00:45:53,460
estimate of this plain text error bound

1085
00:45:53,460 --> 00:45:55,619
t uh can this help reduce the total

1086
00:45:55,619 --> 00:45:57,359
noise which is roughly two to this over

1087
00:45:57,359 --> 00:45:58,619
two times t

1088
00:45:58,619 --> 00:46:00,900
and our answer is that no there seems to

1089
00:46:00,900 --> 00:46:03,780
be a tax uh I don't know if I have time

1090
00:46:03,780 --> 00:46:08,579
to go so okay cool so the at a high

1091
00:46:08,579 --> 00:46:09,920
level you can say that for a natural

1092
00:46:09,920 --> 00:46:11,940
dynamically secure Fiji scheme

1093
00:46:11,940 --> 00:46:13,859
post-processing by IDP mechanism is

1094
00:46:13,859 --> 00:46:15,240
either going to be not useful or

1095
00:46:15,240 --> 00:46:18,000
insecure this is a little bit vague what

1096
00:46:18,000 --> 00:46:19,740
I mean so let's clarify things a little

1097
00:46:19,740 --> 00:46:21,960
bit so the way we show this is an attack

1098
00:46:21,960 --> 00:46:23,400
and it's similar to the static setting

1099
00:46:23,400 --> 00:46:24,660
in fact you can use the same exact

1100
00:46:24,660 --> 00:46:25,920
function that we used in the static

1101
00:46:25,920 --> 00:46:27,720
setting or even a simpler one for this

1102
00:46:27,720 --> 00:46:28,760
particular attack

1103
00:46:28,760 --> 00:46:31,920
so you set up computation such that in

1104
00:46:31,920 --> 00:46:33,480
this distinguishability again the left

1105
00:46:33,480 --> 00:46:34,920
and right worlds contain very different

1106
00:46:34,920 --> 00:46:37,560
plain text errors uh this leads to

1107
00:46:37,560 --> 00:46:39,180
different estimates of the plain text

1108
00:46:39,180 --> 00:46:42,260
error being used in the DPF mechanism so

1109
00:46:42,260 --> 00:46:45,540
uh so when we look at these uh

1110
00:46:45,540 --> 00:46:46,619
differentially private output

1111
00:46:46,619 --> 00:46:48,359
distributions one of them will depend on

1112
00:46:48,359 --> 00:46:49,740
T and the other one will end up depend

1113
00:46:49,740 --> 00:46:51,480
on T Prime and there's no reason at all

1114
00:46:51,480 --> 00:46:53,040
to expect this quantity to be small the

1115
00:46:53,040 --> 00:46:55,440
these will induce distributions and it's

1116
00:46:55,440 --> 00:46:57,480
in many plausible situations there will

1117
00:46:57,480 --> 00:46:58,680
be it will be large and you'll be able

1118
00:46:58,680 --> 00:47:00,599
to easily distinguish things

1119
00:47:00,599 --> 00:47:02,460
uh but of course they're going to be

1120
00:47:02,460 --> 00:47:03,660
many situations where it won't be large

1121
00:47:03,660 --> 00:47:05,180
so you do need some non-triviality

1122
00:47:05,180 --> 00:47:08,880
assumptions to say that uh that this

1123
00:47:08,880 --> 00:47:10,619
attack goes through but the

1124
00:47:10,619 --> 00:47:12,359
non-triviality assumptions are going to

1125
00:47:12,359 --> 00:47:14,579
be fairly reasonable so for one thing we

1126
00:47:14,579 --> 00:47:15,900
need Dynamic estimation to accurately

1127
00:47:15,900 --> 00:47:17,460
measure the different sizes of the plane

1128
00:47:17,460 --> 00:47:19,619
to exterior if Dynamic estimation always

1129
00:47:19,619 --> 00:47:21,359
measures the same thing it's kind of the

1130
00:47:21,359 --> 00:47:23,700
same as static estimation and our tactic

1131
00:47:23,700 --> 00:47:25,140
doesn't go through

1132
00:47:25,140 --> 00:47:26,940
and then we also need the DP mechanism

1133
00:47:26,940 --> 00:47:29,400
to use smaller estimates well in a

1134
00:47:29,400 --> 00:47:30,900
certain sense so specifically if it's

1135
00:47:30,900 --> 00:47:32,640
given a smaller estimate needs to Output

1136
00:47:32,640 --> 00:47:35,400
a distribution that has smaller noise uh

1137
00:47:35,400 --> 00:47:37,079
this is kind of the whole point of

1138
00:47:37,079 --> 00:47:38,760
trying to use these Dynamic error

1139
00:47:38,760 --> 00:47:40,440
estimates they have a deep mechanism

1140
00:47:40,440 --> 00:47:42,420
does not do this then there's no point

1141
00:47:42,420 --> 00:47:43,680
trying to optimize this step in the

1142
00:47:43,680 --> 00:47:45,720
first place

1143
00:47:45,720 --> 00:47:49,020
um oh and I didn't include a table of uh

1144
00:47:49,020 --> 00:47:51,900
the specific uh attack we did on

1145
00:47:51,900 --> 00:47:55,680
Palisade but if you take these uh take

1146
00:47:55,680 --> 00:47:57,480
the function that we used previously or

1147
00:47:57,480 --> 00:47:59,040
the simpler function that I've mentioned

1148
00:47:59,040 --> 00:48:00,980
uh you can run in a very simple

1149
00:48:00,980 --> 00:48:04,079
distinguisher you can distinguish uh

1150
00:48:04,079 --> 00:48:05,960
palisade's counter measure

1151
00:48:05,960 --> 00:48:08,420
very easily

1152
00:48:08,420 --> 00:48:11,040
roughly you get the size of the error in

1153
00:48:11,040 --> 00:48:12,180
one world versus the other world is

1154
00:48:12,180 --> 00:48:13,500
there's a tool or there's a magnitude

1155
00:48:13,500 --> 00:48:15,359
difference across a wide range of

1156
00:48:15,359 --> 00:48:17,579
parameters

1157
00:48:17,579 --> 00:48:21,540
so uh next we'll talk about uh briefly

1158
00:48:21,540 --> 00:48:23,040
something that's mostly theoretical

1159
00:48:23,040 --> 00:48:25,740
interest which is uh in the static case

1160
00:48:25,740 --> 00:48:27,839
we were able to take an arbitrary ncpa

1161
00:48:27,839 --> 00:48:30,720
secure statically uh correct FHA scheme

1162
00:48:30,720 --> 00:48:34,380
and transform it into an ncpa d uh

1163
00:48:34,380 --> 00:48:36,720
encryption scheme uh secure encryption

1164
00:48:36,720 --> 00:48:38,940
scheme So based on this last attack I

1165
00:48:38,940 --> 00:48:40,500
actually showed you it seems unlikely to

1166
00:48:40,500 --> 00:48:41,700
be able to do this in the dynamic

1167
00:48:41,700 --> 00:48:43,500
setting but the situation is actually a

1168
00:48:43,500 --> 00:48:46,079
little bit worse so there's there cannot

1169
00:48:46,079 --> 00:48:48,180
be a general theorem that transforms

1170
00:48:48,180 --> 00:48:50,520
ncpa secure dynamically correct fhc

1171
00:48:50,520 --> 00:48:53,040
schemes into really any schemes with any

1172
00:48:53,040 --> 00:48:54,720
notion security there might be specific

1173
00:48:54,720 --> 00:48:55,859
things you can do for a particular

1174
00:48:55,859 --> 00:48:57,059
scheme so this doesn't rule out the

1175
00:48:57,059 --> 00:49:01,140
notion entirely but uh there exists this

1176
00:49:01,140 --> 00:49:02,760
result shows that there can't be

1177
00:49:02,760 --> 00:49:04,200
something in that works in general

1178
00:49:04,200 --> 00:49:06,780
because there is a counter example that

1179
00:49:06,780 --> 00:49:09,619
it is both ncpa secure but

1180
00:49:09,619 --> 00:49:12,000
post-processing the gaussian noise fails

1181
00:49:12,000 --> 00:49:13,559
to achieve even the weakest notion of

1182
00:49:13,559 --> 00:49:15,599
security a kind of a variant of the key

1183
00:49:15,599 --> 00:49:17,160
recovery game but in this with

1184
00:49:17,160 --> 00:49:19,380
decoration purpose model it's worth

1185
00:49:19,380 --> 00:49:21,720
mentioning as I said before this is not

1186
00:49:21,720 --> 00:49:23,700
ckks the scheme that we use for this

1187
00:49:23,700 --> 00:49:27,000
counter example is very artificial uh so

1188
00:49:27,000 --> 00:49:28,800
it's a natural construction and it

1189
00:49:28,800 --> 00:49:30,480
really should just be seen as ruling out

1190
00:49:30,480 --> 00:49:32,460
a generic transformation from ncpa

1191
00:49:32,460 --> 00:49:35,160
secure dynamically correct fhc to a form

1192
00:49:35,160 --> 00:49:36,480
of security that implies the key

1193
00:49:36,480 --> 00:49:38,880
recovery secure

1194
00:49:38,880 --> 00:49:43,440
and with that let's wrap up uh so in our

1195
00:49:43,440 --> 00:49:46,079
paper we established the Q and cpad

1196
00:49:46,079 --> 00:49:48,359
security of ckks by post-processing was

1197
00:49:48,359 --> 00:49:51,000
a form of differential privacy the main

1198
00:49:51,000 --> 00:49:52,319
example the one that I simplify two

1199
00:49:52,319 --> 00:49:54,180
things and this talk is gaussian noise

1200
00:49:54,180 --> 00:49:55,260
but there are many others you could

1201
00:49:55,260 --> 00:49:57,480
investigate as well we found that at

1202
00:49:57,480 --> 00:49:58,859
least with our relaxed notion of

1203
00:49:58,859 --> 00:50:01,140
security CS specific security s over two

1204
00:50:01,140 --> 00:50:04,260
additional bits of noise suffice and we

1205
00:50:04,260 --> 00:50:05,640
have a lower Bound for c-bit security

1206
00:50:05,640 --> 00:50:08,040
which means that this is plausibly tied

1207
00:50:08,040 --> 00:50:10,319
at least so in the case that s is equal

1208
00:50:10,319 --> 00:50:14,040
to C it's tied up to 10.

1209
00:50:14,040 --> 00:50:16,020
um so we concretely analyze things with

1210
00:50:16,020 --> 00:50:18,240
this mix uh we sorry we introduce the

1211
00:50:18,240 --> 00:50:19,319
notion-based security that seems well

1212
00:50:19,319 --> 00:50:21,000
adapted to concrete and analyzing things

1213
00:50:21,000 --> 00:50:23,760
uh that are created from a mixture of

1214
00:50:23,760 --> 00:50:25,260
computational statistical Primitives

1215
00:50:25,260 --> 00:50:27,420
which is likely interesting outside of

1216
00:50:27,420 --> 00:50:31,500
just the realm of FHA uh and as you may

1217
00:50:31,500 --> 00:50:33,540
have seen this inertia CS bit security

1218
00:50:33,540 --> 00:50:35,700
greatly improve our parameters so it

1219
00:50:35,700 --> 00:50:37,140
seems exciting to apply it in other

1220
00:50:37,140 --> 00:50:39,359
domains as well as I was mentioning it's

1221
00:50:39,359 --> 00:50:40,740
no reason to think it's Unique to ig at

1222
00:50:40,740 --> 00:50:43,440
all so we also investigated this Dynamic

1223
00:50:43,440 --> 00:50:45,780
notion of correctness uh where we got

1224
00:50:45,780 --> 00:50:47,760
the methods there are quite interesting

1225
00:50:47,760 --> 00:50:49,440
but our results were broadly negative

1226
00:50:49,440 --> 00:50:52,500
and it does seem that to leverage this

1227
00:50:52,500 --> 00:50:54,720
notion to show some form of security

1228
00:50:54,720 --> 00:50:56,460
you'll have to do very cks specific

1229
00:50:56,460 --> 00:50:57,660
things

1230
00:50:57,660 --> 00:50:59,700
and in particular it does seem unlikely

1231
00:50:59,700 --> 00:51:00,599
to that you'll be able to achieve a

1232
00:51:00,599 --> 00:51:02,339
qncpad security which is perhaps the

1233
00:51:02,339 --> 00:51:03,260
goal

1234
00:51:03,260 --> 00:51:06,000
for some open problems analyzing other

1235
00:51:06,000 --> 00:51:08,480
caldp mechanisms the most obvious thing

1236
00:51:08,480 --> 00:51:10,619
uh there are many candidates from the

1237
00:51:10,619 --> 00:51:12,059
differential privacy literature we just

1238
00:51:12,059 --> 00:51:15,180
stuck with the most basic one initially

1239
00:51:15,180 --> 00:51:16,859
um the perhaps more interesting would be

1240
00:51:16,859 --> 00:51:19,380
General lower bounds especially in this

1241
00:51:19,380 --> 00:51:21,720
weaker notion of security that we went

1242
00:51:21,720 --> 00:51:25,319
over and for non-gaussian mechanisms and

1243
00:51:25,319 --> 00:51:28,859
then our work is only on securing ctks

1244
00:51:28,859 --> 00:51:31,319
through Black Box means you could try to

1245
00:51:31,319 --> 00:51:33,300
modify the internals of cks to achieve

1246
00:51:33,300 --> 00:51:35,099
this notion of security and none of our

1247
00:51:35,099 --> 00:51:37,920
lower bounds none of that would uh apply

1248
00:51:37,920 --> 00:51:41,280
anymore so it's very it seems plausible

1249
00:51:41,280 --> 00:51:42,240
that you could get more efficient

1250
00:51:42,240 --> 00:51:43,920
countermeasures by using specific

1251
00:51:43,920 --> 00:51:45,660
details of cqks and not just treating

1252
00:51:45,660 --> 00:51:47,460
them abstractly as we do

1253
00:51:47,460 --> 00:51:49,859
and this would be another way to

1254
00:51:49,859 --> 00:51:52,500
potentially utilize Dynamic practice

1255
00:51:52,500 --> 00:51:54,920
thanks

1256
00:52:14,400 --> 00:52:16,400
um

1257
00:52:22,680 --> 00:52:25,680
but

1258
00:52:29,540 --> 00:52:32,420
so what is

1259
00:52:32,420 --> 00:52:37,819
somehow different types of performance

1260
00:52:41,460 --> 00:52:43,800
uh all of our results can you please

1261
00:52:43,800 --> 00:52:46,520
repeat the question

1262
00:52:47,220 --> 00:52:49,220
um

1263
00:53:00,380 --> 00:53:02,700
as long as the distance measures itself

1264
00:53:02,700 --> 00:53:05,700
a norm it should carry over uh so that's

1265
00:53:05,700 --> 00:53:07,559
in most settings

1266
00:53:07,559 --> 00:53:09,240
um but yeah it would depend on the

1267
00:53:09,240 --> 00:53:11,720
particulars

1268
00:53:46,740 --> 00:53:48,599
I can't hear the introduction so should

1269
00:53:48,599 --> 00:53:51,380
I just play the video

1270
00:54:10,140 --> 00:54:12,680
foreign

1271
00:54:28,859 --> 00:54:30,720
so let us begin with the notion of

1272
00:54:30,720 --> 00:54:32,579
attribute based in friction so this

1273
00:54:32,579 --> 00:54:33,960
primitive as we know provides

1274
00:54:33,960 --> 00:54:35,400
fine-grained excess control over

1275
00:54:35,400 --> 00:54:37,440
encrypted data where data is encrypted

1276
00:54:37,440 --> 00:54:39,420
with respect to an attitude Edge and the

1277
00:54:39,420 --> 00:54:40,859
keys are generated with respectful

1278
00:54:40,859 --> 00:54:43,380
policy F and then the decryption is

1279
00:54:43,380 --> 00:54:45,540
successful if and only if f x is equals

1280
00:54:45,540 --> 00:54:48,420
to one then in a more General notion of

1281
00:54:48,420 --> 00:54:50,280
dedicate encryption these ciphertext

1282
00:54:50,280 --> 00:54:52,559
sites the attributes as well as long as

1283
00:54:52,559 --> 00:54:54,720
the adversary does not issue any

1284
00:54:54,720 --> 00:54:56,460
decrypting equalities in the security

1285
00:54:56,460 --> 00:54:59,040
table so let us look at the motivation

1286
00:54:59,040 --> 00:55:01,079
behind the work so a starting motivation

1287
00:55:01,079 --> 00:55:03,059
comes from the observation that in many

1288
00:55:03,059 --> 00:55:05,700
real world applications the data

1289
00:55:05,700 --> 00:55:07,559
pertaining to a single entity can in

1290
00:55:07,559 --> 00:55:09,240
fact be distributed across several

1291
00:55:09,240 --> 00:55:11,220
different locations so for example

1292
00:55:11,220 --> 00:55:13,619
consider the following scenario where

1293
00:55:13,619 --> 00:55:15,540
there is a medical researcher who wants

1294
00:55:15,540 --> 00:55:18,680
to study efficacy of certain medicine in

1295
00:55:18,680 --> 00:55:21,420
patients above 65 years of age having

1296
00:55:21,420 --> 00:55:24,780
both obedient asthma so in this scenario

1297
00:55:24,780 --> 00:55:26,280
what uh

1298
00:55:26,280 --> 00:55:29,640
uh we would like to use predicate

1299
00:55:29,640 --> 00:55:32,579
encryption to provide her a controlled

1300
00:55:32,579 --> 00:55:35,880
access to data of only those users uh

1301
00:55:35,880 --> 00:55:38,240
those patients who fall in the said

1302
00:55:38,240 --> 00:55:41,940
category however note that in the in the

1303
00:55:41,940 --> 00:55:45,000
real world the records of a patient can

1304
00:55:45,000 --> 00:55:47,880
be uh can be distributed across

1305
00:55:47,880 --> 00:55:49,799
different departments or centers of the

1306
00:55:49,799 --> 00:55:51,960
hospital and then in such a scenario

1307
00:55:51,960 --> 00:55:54,119
what we would like to have is that each

1308
00:55:54,119 --> 00:55:57,960
department should be able to uh encrypt

1309
00:55:57,960 --> 00:56:01,020
data locally and then the researcher

1310
00:56:01,020 --> 00:56:03,180
should be able to use her key on the

1311
00:56:03,180 --> 00:56:04,859
combination of these independently

1312
00:56:04,859 --> 00:56:07,920
generated psychotics so as to recover

1313
00:56:07,920 --> 00:56:10,619
the underlying data and in general we

1314
00:56:10,619 --> 00:56:13,440
would like to think of a b or B in all

1315
00:56:13,440 --> 00:56:15,839
such setting where the data is generated

1316
00:56:15,839 --> 00:56:17,339
in different location but is

1317
00:56:17,339 --> 00:56:19,260
nevertheless correlated so as to be

1318
00:56:19,260 --> 00:56:21,660
thought of as a single single logical

1319
00:56:21,660 --> 00:56:22,740
unit

1320
00:56:22,740 --> 00:56:26,220
so now we look at the uh

1321
00:56:26,220 --> 00:56:29,040
form a formal definition of k input a b

1322
00:56:29,040 --> 00:56:30,960
note that we are in secret key setting

1323
00:56:30,960 --> 00:56:33,480
meaning that the encryption is also a

1324
00:56:33,480 --> 00:56:35,940
secret operation so there is setup

1325
00:56:35,940 --> 00:56:37,740
algorithm which outputs a master secret

1326
00:56:37,740 --> 00:56:40,140
key msk then the Keygen algorithm takes

1327
00:56:40,140 --> 00:56:43,740
msk as input along with 30 function f

1328
00:56:43,740 --> 00:56:47,460
and then outputs SKF and then encryption

1329
00:56:47,460 --> 00:56:49,740
algorithm for slot I takes as input

1330
00:56:49,740 --> 00:56:51,599
Master secret key and message and

1331
00:56:51,599 --> 00:56:53,760
attributes for slot I and outputs the

1332
00:56:53,760 --> 00:56:56,700
corresponding ciphertext CTI then we

1333
00:56:56,700 --> 00:56:58,559
have decryption algorithm which takes us

1334
00:56:58,559 --> 00:57:00,780
input the decryption key SKF and the

1335
00:57:00,780 --> 00:57:03,299
sample text for all the case rods and

1336
00:57:03,299 --> 00:57:05,579
outputs the underlying messages if and

1337
00:57:05,579 --> 00:57:09,059
only if F of X1 up to x k is equals to 1

1338
00:57:09,059 --> 00:57:11,579
here x 1 x 2 up to x k are the

1339
00:57:11,579 --> 00:57:14,400
attributes in the respective slots and

1340
00:57:14,400 --> 00:57:16,980
then in predicate encryption we uh the

1341
00:57:16,980 --> 00:57:19,380
cipher texts hide the corresponding

1342
00:57:19,380 --> 00:57:21,299
attributes

1343
00:57:21,299 --> 00:57:24,000
for Simplicity we assume that message is

1344
00:57:24,000 --> 00:57:26,579
associated only with short one uh

1345
00:57:26,579 --> 00:57:30,720
ciphertext and uh for for the rest of

1346
00:57:30,720 --> 00:57:33,480
the other slots the uh

1347
00:57:33,480 --> 00:57:35,700
they are basically sort of empty where

1348
00:57:35,700 --> 00:57:38,400
the encryption is done with respect to

1349
00:57:38,400 --> 00:57:42,740
uh attributes only without any message

1350
00:57:42,740 --> 00:57:46,559
and note that this simplification is

1351
00:57:46,559 --> 00:57:48,660
without loss of generality because in

1352
00:57:48,660 --> 00:57:51,480
the otherwise case we can have K

1353
00:57:51,480 --> 00:57:52,760
parallel

1354
00:57:52,760 --> 00:57:55,740
instantiations of the skin

1355
00:57:55,740 --> 00:57:58,200
then we look at the security requirement

1356
00:57:58,200 --> 00:58:00,720
so Suppose there is an adversary having

1357
00:58:00,720 --> 00:58:03,839
uh key with keys with respect to

1358
00:58:03,839 --> 00:58:06,660
function F1 and F2 and different slot

1359
00:58:06,660 --> 00:58:09,720
one and sort to Cipher text then for

1360
00:58:09,720 --> 00:58:12,119
security we want that as long as the

1361
00:58:12,119 --> 00:58:14,160
adversary is not able to perform any

1362
00:58:14,160 --> 00:58:16,140
decryption and what it means is that f

1363
00:58:16,140 --> 00:58:18,839
of x 1 comma X2 is equals to 0 for all

1364
00:58:18,839 --> 00:58:21,420
possible combinations then the

1365
00:58:21,420 --> 00:58:24,299
underlying messages must remain hidden

1366
00:58:24,299 --> 00:58:26,520
then we also Define and consider a

1367
00:58:26,520 --> 00:58:28,500
stronger security motion where we do

1368
00:58:28,500 --> 00:58:31,380
allow decrypting components does that

1369
00:58:31,380 --> 00:58:33,180
now there can be such a combination

1370
00:58:33,180 --> 00:58:35,579
where f of x 1 comma x 2 is equals to 1

1371
00:58:35,579 --> 00:58:37,859
and in such a situation what we want is

1372
00:58:37,859 --> 00:58:40,680
that the adversion must not must not be

1373
00:58:40,680 --> 00:58:42,599
able to learn anything beyond what this

1374
00:58:42,599 --> 00:58:45,059
tree will be written so what it means

1375
00:58:45,059 --> 00:58:48,839
let us look uh at uh at an example for

1376
00:58:48,839 --> 00:58:51,540
this so in the same setting suppose uh

1377
00:58:51,540 --> 00:58:55,200
F1 on X1 comma X2 is equals to 1 and

1378
00:58:55,200 --> 00:58:57,059
then of course the adversary can perform

1379
00:58:57,059 --> 00:58:59,339
the decryption with these two Cipher

1380
00:58:59,339 --> 00:59:03,480
texts so using SK F1 and and can recover

1381
00:59:03,480 --> 00:59:06,420
message M1 but further suppose F star

1382
00:59:06,420 --> 00:59:09,599
with X1 2 comma star is equals to 0

1383
00:59:09,599 --> 00:59:13,440
where star means it can have any value

1384
00:59:13,440 --> 00:59:16,559
then what it means that this ciphertext

1385
00:59:16,559 --> 00:59:18,839
can combine with any other side protects

1386
00:59:18,839 --> 00:59:20,700
the uh the function value on the

1387
00:59:20,700 --> 00:59:23,160
corresponding pair of attributes is

1388
00:59:23,160 --> 00:59:26,760
equals to zero for F1 as well as F2 and

1389
00:59:26,760 --> 00:59:28,740
therefore uh the corresponding message

1390
00:59:28,740 --> 00:59:32,419
M2 must remain hidden

1391
00:59:32,520 --> 00:59:35,940
so uh related works so multi input a B

1392
00:59:35,940 --> 00:59:38,220
and B even though being useful primitive

1393
00:59:38,220 --> 00:59:41,099
have uh have largely been unexplored so

1394
00:59:41,099 --> 00:59:43,740
multi input Abe was introduced by

1395
00:59:43,740 --> 00:59:45,839
Breakers key I tell in the context of

1396
00:59:45,839 --> 00:59:48,119
constructing witness encryption however

1397
00:59:48,119 --> 00:59:49,680
they do not provide a Concrete

1398
00:59:49,680 --> 00:59:52,920
Construction and in case of mip there is

1399
00:59:52,920 --> 00:59:56,160
no reference at all however in the much

1400
00:59:56,160 --> 00:59:58,740
more powerful uh

1401
00:59:58,740 --> 01:00:01,619
primitive of mif this has been studied

1402
01:00:01,619 --> 01:00:03,240
extensively and therefore a natural

1403
01:00:03,240 --> 01:00:05,760
question that arises is that can't we

1404
01:00:05,760 --> 01:00:09,000
simply use mif or miab and MI

1405
01:00:09,000 --> 01:00:12,299
but note that mif construction uses a

1406
01:00:12,299 --> 01:00:14,760
compact Fe along with a generic compiler

1407
01:00:14,760 --> 01:00:17,819
to lift it to multi-input uh

1408
01:00:17,819 --> 01:00:21,359
Fe and even though there has been

1409
01:00:21,359 --> 01:00:23,700
remarkable progress in the in the

1410
01:00:23,700 --> 01:00:26,040
construction of compact Fe these

1411
01:00:26,040 --> 01:00:27,780
constructions are still quite complex

1412
01:00:27,780 --> 01:00:30,119
and are based on multiple assumptions

1413
01:00:30,119 --> 01:00:31,680
anymore

1414
01:00:31,680 --> 01:00:34,260
well what we are looking for is a much

1415
01:00:34,260 --> 01:00:36,680
simpler primitive of All or Nothing

1416
01:00:36,680 --> 01:00:38,700
functionality and therefore we expect

1417
01:00:38,700 --> 01:00:41,400
simpler constructions and in fact in

1418
01:00:41,400 --> 01:00:44,339
case of single input we know that a B

1419
01:00:44,339 --> 01:00:47,099
and B can be constructed using lwb

1420
01:00:47,099 --> 01:00:49,500
rather than going through complex root

1421
01:00:49,500 --> 01:00:52,680
of functional interaction we expect the

1422
01:00:52,680 --> 01:00:55,799
same for the multi-input setting besides

1423
01:00:55,799 --> 01:00:58,440
a direct construction for a b or B can

1424
01:00:58,440 --> 01:01:00,660
provide helpful insights into other

1425
01:01:00,660 --> 01:01:03,720
Primitives like Fitness encryption so

1426
01:01:03,720 --> 01:01:05,660
let us look at the main difficulty in

1427
01:01:05,660 --> 01:01:08,760
constructing multi-input ape so the main

1428
01:01:08,760 --> 01:01:10,980
source of difficulty is to satisfy two

1429
01:01:10,980 --> 01:01:13,140
seemingly contradicted requirements at

1430
01:01:13,140 --> 01:01:15,720
the same time so on the one hand we want

1431
01:01:15,720 --> 01:01:17,760
uh that the different cyber text

1432
01:01:17,760 --> 01:01:19,859
components should be generated

1433
01:01:19,859 --> 01:01:22,619
independently and on the other hand we

1434
01:01:22,619 --> 01:01:24,359
want to be able to combine these

1435
01:01:24,359 --> 01:01:26,339
psychotics in a way that the decryption

1436
01:01:26,339 --> 01:01:28,859
can be performed and if we look at the

1437
01:01:28,859 --> 01:01:31,920
existing constructions for Abe

1438
01:01:31,920 --> 01:01:34,380
the second condition requires that the

1439
01:01:34,380 --> 01:01:36,540
same Randomness should be used in all

1440
01:01:36,540 --> 01:01:39,299
the psychotext components and while the

1441
01:01:39,299 --> 01:01:41,460
first condition by its very nature says

1442
01:01:41,460 --> 01:01:42,780
that the randomness in different

1443
01:01:42,780 --> 01:01:45,599
components are generated independently

1444
01:01:45,599 --> 01:01:47,520
and this is this contradictory

1445
01:01:47,520 --> 01:01:48,960
requirement that makes the construction

1446
01:01:48,960 --> 01:01:52,920
difficult so let us look at the key idea

1447
01:01:52,920 --> 01:01:55,740
behind the results that we get so the

1448
01:01:55,740 --> 01:01:58,619
main Insight in the results that we get

1449
01:01:58,619 --> 01:01:59,880
is the

1450
01:01:59,880 --> 01:02:02,220
observation that the techniques

1451
01:02:02,220 --> 01:02:04,520
developed in context of succinct

1452
01:02:04,520 --> 01:02:08,280
ciphertext policy Abe has have

1453
01:02:08,280 --> 01:02:11,220
surprising relevance in in seemingly

1454
01:02:11,220 --> 01:02:13,500
unrelated setting of multi-input key

1455
01:02:13,500 --> 01:02:16,680
policy kpt and in particular if we look

1456
01:02:16,680 --> 01:02:19,339
at recent constructions of success

1457
01:02:19,339 --> 01:02:23,460
policy ape they exploit uh this nice

1458
01:02:23,460 --> 01:02:26,400
algebraic property of decomposability in

1459
01:02:26,400 --> 01:02:28,400
Bonnie atel's

1460
01:02:28,400 --> 01:02:32,220
key policy Abe scheme and they use this

1461
01:02:32,220 --> 01:02:35,280
decomposability to uh to get

1462
01:02:35,280 --> 01:02:37,680
succinctness in the site for text and

1463
01:02:37,680 --> 01:02:39,539
this decomposability basically means

1464
01:02:39,539 --> 01:02:42,000
that the ciphertext for an attribute to

1465
01:02:42,000 --> 01:02:45,420
expect length L can be decomposed into L

1466
01:02:45,420 --> 01:02:47,819
components where each component encodes

1467
01:02:47,819 --> 01:02:50,039
one bit and these components are then

1468
01:02:50,039 --> 01:02:52,500
tied together using the common

1469
01:02:52,500 --> 01:02:55,260
and now in our case also what we need is

1470
01:02:55,260 --> 01:02:57,299
decomposability but for a completely

1471
01:02:57,299 --> 01:02:59,520
different reason we want decomposability

1472
01:02:59,520 --> 01:03:02,220
so that uh the different components of

1473
01:03:02,220 --> 01:03:03,839
the ciphertext can be generated

1474
01:03:03,839 --> 01:03:06,059
independently and later combined

1475
01:03:06,059 --> 01:03:07,559
together to perform meaningful

1476
01:03:07,559 --> 01:03:10,160
decryption

1477
01:03:10,920 --> 01:03:13,440
so let us first look at the results that

1478
01:03:13,440 --> 01:03:17,280
we have uh we we firstly formalize the

1479
01:03:17,280 --> 01:03:20,160
security definition for miab and nipe

1480
01:03:20,160 --> 01:03:24,240
then in mi ABA regime we have a

1481
01:03:24,240 --> 01:03:27,180
construction for 2ab for nz1 with

1482
01:03:27,180 --> 01:03:29,460
security in general group model then

1483
01:03:29,460 --> 01:03:31,920
another construction for 2ab for nz1

1484
01:03:31,920 --> 01:03:34,260
with security in standard model using

1485
01:03:34,260 --> 01:03:36,839
knowledge assumption and we also have

1486
01:03:36,839 --> 01:03:39,599
heuristic construction for 3ab for nc1

1487
01:03:39,599 --> 01:03:42,480
and 2 a B for p

1488
01:03:42,480 --> 01:03:46,020
and then in mipe it is you'll be a

1489
01:03:46,020 --> 01:03:48,960
construct a generic compiler that lifts

1490
01:03:48,960 --> 01:03:52,140
any K input a B for a constant K to K

1491
01:03:52,140 --> 01:03:54,720
input p e using lockable obfuscation

1492
01:03:54,720 --> 01:03:56,700
note that lockable obfuscation can be

1493
01:03:56,700 --> 01:03:59,160
constructed using

1494
01:03:59,160 --> 01:04:01,740
and then using this compiler over the

1495
01:04:01,740 --> 01:04:03,900
results that we have for multi-input Ave

1496
01:04:03,900 --> 01:04:06,539
we get 2pe for nz1 and heuristic

1497
01:04:06,539 --> 01:04:09,000
constructions for three p e for nc1 and

1498
01:04:09,000 --> 01:04:12,299
2 PE for p in this talk I will be

1499
01:04:12,299 --> 01:04:15,299
presenting the high level idea in the

1500
01:04:15,299 --> 01:04:19,619
construction of 2ab for nc1 and KB to

1501
01:04:19,619 --> 01:04:22,619
kpe compile so let's begin with UAV

1502
01:04:22,619 --> 01:04:25,920
construction for nc1 so so as we talked

1503
01:04:25,920 --> 01:04:28,200
about before that we make use of this

1504
01:04:28,200 --> 01:04:31,559
nice decompressibility property in PGG

1505
01:04:31,559 --> 01:04:36,119
plus kpap so this property basically uh

1506
01:04:36,119 --> 01:04:39,299
says that encryption uh encodes each bit

1507
01:04:39,299 --> 01:04:41,280
of an attribute separately and then

1508
01:04:41,280 --> 01:04:43,440
these encodings are tied together with

1509
01:04:43,440 --> 01:04:46,559
using a common Randomness so basically

1510
01:04:46,559 --> 01:04:48,900
in particular the encryption is scheme

1511
01:04:48,900 --> 01:04:51,420
first to generate a two cross two L

1512
01:04:51,420 --> 01:04:54,900
Matrix with all possible ciphertext

1513
01:04:54,900 --> 01:04:57,000
components ca2l is the length of the

1514
01:04:57,000 --> 01:04:59,400
attribute and then the Cyber text for

1515
01:04:59,400 --> 01:05:02,640
any attribute X you picks the

1516
01:05:02,640 --> 01:05:04,799
corresponding cypertext components based

1517
01:05:04,799 --> 01:05:08,099
on the bit values in X and outputs them

1518
01:05:08,099 --> 01:05:12,059
as part of as as final size for text so

1519
01:05:12,059 --> 01:05:13,980
how is this useful in all settings or

1520
01:05:13,980 --> 01:05:15,960
equal that we want to be able to

1521
01:05:15,960 --> 01:05:17,520
generate different components of the

1522
01:05:17,520 --> 01:05:20,720
ciphertext independently so now using

1523
01:05:20,720 --> 01:05:23,460
decomposability in bgt plus what we do

1524
01:05:23,460 --> 01:05:25,799
we let user one generate the first L

1525
01:05:25,799 --> 01:05:28,980
encodings corresponding to X1 and user 2

1526
01:05:28,980 --> 01:05:31,039
generates next Ln coding is correct

1527
01:05:31,039 --> 01:05:34,740
corresponding to attribute X2

1528
01:05:34,740 --> 01:05:36,839
but we still have not addressed the

1529
01:05:36,839 --> 01:05:39,180
question of same Randomness across these

1530
01:05:39,180 --> 01:05:41,760
encodings

1531
01:05:41,760 --> 01:05:45,020
so one idea can be that can we make this

1532
01:05:45,020 --> 01:05:48,240
Randomness part of msk so that now the

1533
01:05:48,240 --> 01:05:50,940
two users can use the same Randomness

1534
01:05:50,940 --> 01:05:54,180
but for security we want uh these

1535
01:05:54,180 --> 01:05:56,039
Randomness to be freshly sampled and

1536
01:05:56,039 --> 01:05:58,760
therefore this idea does not work

1537
01:05:58,760 --> 01:06:02,280
instead we make use of pairings so let

1538
01:06:02,280 --> 01:06:06,359
us first uh look at the notations so we

1539
01:06:06,359 --> 01:06:08,579
have

1540
01:06:08,579 --> 01:06:11,339
first groups given and G2 and Target

1541
01:06:11,339 --> 01:06:14,160
group GT and the comparing operation is

1542
01:06:14,160 --> 01:06:16,859
given by the following equation and then

1543
01:06:16,859 --> 01:06:18,960
we make use of for the following bracket

1544
01:06:18,960 --> 01:06:21,839
notation where a inside square brackets

1545
01:06:21,839 --> 01:06:24,480
with Z in subscript represents encoding

1546
01:06:24,480 --> 01:06:26,460
of a in group g z

1547
01:06:26,460 --> 01:06:30,240
and now coming to the use of parents so

1548
01:06:30,240 --> 01:06:32,819
now we let user 1 compute ciphertext

1549
01:06:32,819 --> 01:06:35,579
with Randomness V1 and then code it in

1550
01:06:35,579 --> 01:06:37,920
G1 and similarly use it to compute

1551
01:06:37,920 --> 01:06:39,900
ciphertext with Randomness T2 and then

1552
01:06:39,900 --> 01:06:42,420
code it in G2 and now when we pair them

1553
01:06:42,420 --> 01:06:45,960
up we get render a ciphertext components

1554
01:06:45,960 --> 01:06:48,780
with Randomness T1 T2 encoded in group

1555
01:06:48,780 --> 01:06:52,200
GT in particular this is what we do so

1556
01:06:52,200 --> 01:06:55,440
now we have compute all possible BGG

1557
01:06:55,440 --> 01:06:58,500
plus ciphertext components and uh make

1558
01:06:58,500 --> 01:07:00,180
it part of msk

1559
01:07:00,180 --> 01:07:02,880
and then the user one to compute

1560
01:07:02,880 --> 01:07:05,039
ciphertext for slot one for attribute

1561
01:07:05,039 --> 01:07:07,400
let's say X1 is equals to one zero one

1562
01:07:07,400 --> 01:07:10,220
picks up corresponding ciphertext

1563
01:07:10,220 --> 01:07:13,920
components uh randomizes it further with

1564
01:07:13,920 --> 01:07:16,260
fresh Randomness T1 and encodes it in

1565
01:07:16,260 --> 01:07:19,740
group given and outputs this and uh

1566
01:07:19,740 --> 01:07:24,119
similar is done by user user 2 with

1567
01:07:24,119 --> 01:07:26,520
fresh Randomness date and now when we

1568
01:07:26,520 --> 01:07:29,520
pair up the corresponding columns what

1569
01:07:29,520 --> 01:07:31,760
we get is BGG plus

1570
01:07:31,760 --> 01:07:33,900
ciphertext components with fresh

1571
01:07:33,900 --> 01:07:37,079
Randomness D1 T2 encoded in Target group

1572
01:07:37,079 --> 01:07:38,460
GT

1573
01:07:38,460 --> 01:07:40,619
so okay so we are going to step closer

1574
01:07:40,619 --> 01:07:43,140
to the solution but there are still some

1575
01:07:43,140 --> 01:07:45,180
security issues that needs to be handled

1576
01:07:45,180 --> 01:07:47,039
and we need to look at how the

1577
01:07:47,039 --> 01:07:49,579
decryption

1578
01:07:49,740 --> 01:07:52,859
so uh in case of a stronger security the

1579
01:07:52,859 --> 01:07:55,020
detection uh remember we in case of

1580
01:07:55,020 --> 01:07:57,119
secure stronger security we allowed

1581
01:07:57,119 --> 01:07:59,700
decraction and this decryption can

1582
01:07:59,700 --> 01:08:01,740
actually make Randomness in slot two

1583
01:08:01,740 --> 01:08:02,880
site buttons

1584
01:08:02,880 --> 01:08:04,920
in particular we can have following

1585
01:08:04,920 --> 01:08:06,539
scenario where there is an adversary

1586
01:08:06,539 --> 01:08:09,240
having secret key for function f and

1587
01:08:09,240 --> 01:08:12,000
Slot one ciphertext for attributes X1

1588
01:08:12,000 --> 01:08:14,520
and X1 Prime and the slot 2 ciphertext

1589
01:08:14,520 --> 01:08:17,219
for attribute X2 and now suppose F of X1

1590
01:08:17,219 --> 01:08:20,040
Prime comma X2 is equals to 1.

1591
01:08:20,040 --> 01:08:24,420
then the adversary can uh pair up take

1592
01:08:24,420 --> 01:08:27,120
combine these two ciphertexts to perform

1593
01:08:27,120 --> 01:08:30,479
detection and this decryption leaves the

1594
01:08:30,479 --> 01:08:32,939
randomness in in these Cipher text

1595
01:08:32,939 --> 01:08:35,219
components which means basically the

1596
01:08:35,219 --> 01:08:38,279
that CP X2 is now compromised and now

1597
01:08:38,279 --> 01:08:41,460
the adversary can attempt to can pair uh

1598
01:08:41,460 --> 01:08:44,520
take the this combination and note that

1599
01:08:44,520 --> 01:08:47,698
since F of X1 comma X2 is equals to 0 we

1600
01:08:47,698 --> 01:08:50,520
want this message M to be hidden

1601
01:08:50,520 --> 01:08:53,339
but since City X2 is already compromised

1602
01:08:53,339 --> 01:08:56,460
we can no longer argue security of this

1603
01:08:56,460 --> 01:08:58,679
combination of psychotects

1604
01:08:58,679 --> 01:09:02,219
and therefore to handle this this issue

1605
01:09:02,219 --> 01:09:05,759
we uh we basically disconnect this bgt

1606
01:09:05,759 --> 01:09:08,399
plus hypertext components from slot 2.

1607
01:09:08,399 --> 01:09:13,020
and now we let user 1 output BGG Plus

1608
01:09:13,020 --> 01:09:16,080
encodings for Slot 2 as well and user 2

1609
01:09:16,080 --> 01:09:20,339
outputs the uh selector bits forever or

1610
01:09:20,339 --> 01:09:23,059
attribute X

1611
01:09:30,080 --> 01:09:33,600
text components as before but for slot

1612
01:09:33,600 --> 01:09:36,179
two user one does not know the attribute

1613
01:09:36,179 --> 01:09:39,179
X2 and therefore uh what it does is it

1614
01:09:39,179 --> 01:09:42,120
outputs the uh ciphertext components for

1615
01:09:42,120 --> 01:09:46,198
both the plates and user 2 now provides

1616
01:09:46,198 --> 01:09:49,259
the selector bits randomized with fresh

1617
01:09:49,259 --> 01:09:51,658
Randomness T2 and now we see that

1618
01:09:51,658 --> 01:09:54,238
wherever this bit is not 0 we when we

1619
01:09:54,238 --> 01:09:56,699
pair them up we again get the BGG plus

1620
01:09:56,699 --> 01:09:59,580
bit

1621
01:09:59,580 --> 01:10:02,159
so but still there is one more issue

1622
01:10:02,159 --> 01:10:04,440
left that since we are using same

1623
01:10:04,440 --> 01:10:06,600
Randomness for all the bit position and

1624
01:10:06,600 --> 01:10:08,580
in fact this is required for decryption

1625
01:10:08,580 --> 01:10:10,860
the adversary can infect pair of

1626
01:10:10,860 --> 01:10:13,739
non-matching positions so like this and

1627
01:10:13,739 --> 01:10:15,440
uh by

1628
01:10:15,440 --> 01:10:17,420
pairing these

1629
01:10:17,420 --> 01:10:19,739
components the adversary can recover

1630
01:10:19,739 --> 01:10:23,699
encoding of T1 T2 C40 while it should

1631
01:10:23,699 --> 01:10:26,340
not be able to get this value because

1632
01:10:26,340 --> 01:10:29,100
notice that the first bit in X2 is 1

1633
01:10:29,100 --> 01:10:30,480
cannot say

1634
01:10:30,480 --> 01:10:33,480
and to address such kind of attack we

1635
01:10:33,480 --> 01:10:35,820
make use of position wise Randomness and

1636
01:10:35,820 --> 01:10:37,920
D is random opposite position wise

1637
01:10:37,920 --> 01:10:40,380
random values are given as part of msk

1638
01:10:40,380 --> 01:10:42,719
so now uh

1639
01:10:42,719 --> 01:10:45,420
user one uses these random values in the

1640
01:10:45,420 --> 01:10:46,739
numerator

1641
01:10:46,739 --> 01:10:49,260
and user 2 uses these values in the

1642
01:10:49,260 --> 01:10:52,860
denominator and now when the matching

1643
01:10:52,860 --> 01:10:55,679
positions are paired up these values

1644
01:10:55,679 --> 01:10:59,420
cancel out and we again get the bgt plus

1645
01:10:59,420 --> 01:11:02,640
ciphertext components as before but now

1646
01:11:02,640 --> 01:11:04,920
when non-matching positions are paired

1647
01:11:04,920 --> 01:11:06,960
up then these values do not cancel out

1648
01:11:06,960 --> 01:11:09,480
and all that the adversary gets is just

1649
01:11:09,480 --> 01:11:12,300
a randomly and now we can argue Security

1650
01:11:12,300 --> 01:11:14,880
in general group

1651
01:11:14,880 --> 01:11:19,380
so now we come to the decryption part

1652
01:11:19,380 --> 01:11:21,840
so notice that we have this PGG plus

1653
01:11:21,840 --> 01:11:23,820
ciphertext components but these are not

1654
01:11:23,820 --> 01:11:26,580
in plane moreover these are already in

1655
01:11:26,580 --> 01:11:30,420
the Target group and now what uh

1656
01:11:30,420 --> 01:11:32,580
all that we can do is perform some

1657
01:11:32,580 --> 01:11:35,159
linear function on these encodings but

1658
01:11:35,159 --> 01:11:37,140
the good news is that the bgj plus

1659
01:11:37,140 --> 01:11:40,020
decryption is in fact a Twist a process

1660
01:11:40,020 --> 01:11:42,000
where in the first step it performs

1661
01:11:42,000 --> 01:11:44,159
applies a linear function LF on

1662
01:11:44,159 --> 01:11:47,040
different encodings and the result of

1663
01:11:47,040 --> 01:11:50,400
this function is a mess is

1664
01:11:50,400 --> 01:11:52,739
message plus noise which can then be

1665
01:11:52,739 --> 01:11:55,080
rounded off to get the message notice

1666
01:11:55,080 --> 01:11:58,320
that rounding operation is not a linear

1667
01:11:58,320 --> 01:12:00,659
so in our case what we get in the

1668
01:12:00,659 --> 01:12:03,239
exponent is T1 T2 with the message plus

1669
01:12:03,239 --> 01:12:04,800
minus

1670
01:12:04,800 --> 01:12:06,540
and then the question is how do we

1671
01:12:06,540 --> 01:12:09,480
recover message since rounding cannot be

1672
01:12:09,480 --> 01:12:11,219
performed

1673
01:12:11,219 --> 01:12:14,940
so here we uh observe that if this value

1674
01:12:14,940 --> 01:12:17,520
can be polynomially bounded then what we

1675
01:12:17,520 --> 01:12:19,620
can do that we can output the encoding

1676
01:12:19,620 --> 01:12:22,679
of P1 P2 and then by uh brute first

1677
01:12:22,679 --> 01:12:25,679
search we get this value in the pale and

1678
01:12:25,679 --> 01:12:27,960
once we have this value in pin we can do

1679
01:12:27,960 --> 01:12:30,360
rounding and get the message and then

1680
01:12:30,360 --> 01:12:32,520
since we can uh

1681
01:12:32,520 --> 01:12:35,580
bound the noise with a polynomial Bound

1682
01:12:35,580 --> 01:12:39,179
for nc1 class of circuits using

1683
01:12:39,179 --> 01:12:42,000
asymmetry in noise and this completes

1684
01:12:42,000 --> 01:12:44,960
the decryption

1685
01:12:45,120 --> 01:12:47,880
now note that in our construction we

1686
01:12:47,880 --> 01:12:50,219
make use of several techniques from a by

1687
01:12:50,219 --> 01:12:52,860
20 but here we would like to argue that

1688
01:12:52,860 --> 01:12:55,920
these techniques are used in 2ab in a

1689
01:12:55,920 --> 01:12:58,440
completely different setting so let us

1690
01:12:58,440 --> 01:13:00,840
look at some examples so for example use

1691
01:13:00,840 --> 01:13:02,880
of decomposability as we have already

1692
01:13:02,880 --> 01:13:05,340
talked about it that decomposability is

1693
01:13:05,340 --> 01:13:07,800
used in a by 22 provide succinctly

1694
01:13:07,800 --> 01:13:10,620
synthesized vertex well in our case we

1695
01:13:10,620 --> 01:13:13,260
use the composibility to combine two

1696
01:13:13,260 --> 01:13:16,080
independently generated ciphertips so

1697
01:13:16,080 --> 01:13:18,080
that the decryption can be performed

1698
01:13:18,080 --> 01:13:21,659
then use of pairings pairings is used in

1699
01:13:21,659 --> 01:13:25,080
a by 20 for providing Security in

1700
01:13:25,080 --> 01:13:26,540
particular

1701
01:13:26,540 --> 01:13:29,300
a decrypted having a

1702
01:13:29,300 --> 01:13:33,120
decryption key for the net for an

1703
01:13:33,120 --> 01:13:36,600
attribute X should be not be able to

1704
01:13:36,600 --> 01:13:39,000
recover any other Cipher text components

1705
01:13:39,000 --> 01:13:41,460
and this is ensured by using parents and

1706
01:13:41,460 --> 01:13:43,020
in our case we need pairings for

1707
01:13:43,020 --> 01:13:45,840
functionality where we want to uh to

1708
01:13:45,840 --> 01:13:48,000
ensure same Randomness across different

1709
01:13:48,000 --> 01:13:51,239
cycle text components and then similarly

1710
01:13:51,239 --> 01:13:54,000
we have a use of fresh Randomness which

1711
01:13:54,000 --> 01:13:56,460
in case of a by 20 is used to be prevent

1712
01:13:56,460 --> 01:13:58,739
confusion while in August we use it to

1713
01:13:58,739 --> 01:14:02,400
prevent mix and match attack uh via an

1714
01:14:02,400 --> 01:14:04,260
adversary can attempt to take different

1715
01:14:04,260 --> 01:14:06,659
components from different ciphertext and

1716
01:14:06,659 --> 01:14:10,080
try to combine them and do the dish and

1717
01:14:10,080 --> 01:14:11,880
there are landing

1718
01:14:11,880 --> 01:14:15,659
and let us now move to kpe Construction

1719
01:14:15,659 --> 01:14:19,199
so we have this Abe uh to 2ab

1720
01:14:19,199 --> 01:14:21,179
construction using techniques that we

1721
01:14:21,179 --> 01:14:23,880
talked about so the first attempt can be

1722
01:14:23,880 --> 01:14:25,800
can be similarly use an existing

1723
01:14:25,800 --> 01:14:28,020
construction for PE and use similar

1724
01:14:28,020 --> 01:14:30,780
techniques to get to but note that a

1725
01:14:30,780 --> 01:14:32,640
very crucial property that we use in

1726
01:14:32,640 --> 01:14:36,179
case of a b is polynomial noise and this

1727
01:14:36,179 --> 01:14:39,060
condition is not satisfied for PE and

1728
01:14:39,060 --> 01:14:40,739
therefore we cannot hope to go through

1729
01:14:40,739 --> 01:14:42,719
this path at least using the techniques

1730
01:14:42,719 --> 01:14:46,140
that we have instead we make uh take an

1731
01:14:46,140 --> 01:14:49,140
alternate route so um

1732
01:14:49,140 --> 01:14:52,140
give

1733
01:14:57,239 --> 01:15:00,960
a generic compiler to lift any Abe to PE

1734
01:15:00,960 --> 01:15:03,480
using lockable obfuscation

1735
01:15:03,480 --> 01:15:07,620
and there the uh the peace hypertext is

1736
01:15:07,620 --> 01:15:09,659
basically an obfuscation of a function

1737
01:15:09,659 --> 01:15:12,719
which has a corresponding AP psycho text

1738
01:15:12,719 --> 01:15:16,199
hardback so what we do we also uh now

1739
01:15:16,199 --> 01:15:20,280
have a b to 2 Abe we have this and now

1740
01:15:20,280 --> 01:15:23,760
we go from 2ab to 2p using lockable

1741
01:15:23,760 --> 01:15:24,659
office

1742
01:15:24,659 --> 01:15:27,380
but note that in case of multi-input

1743
01:15:27,380 --> 01:15:29,940
setting there are certain challenges

1744
01:15:29,940 --> 01:15:31,679
which are not there in case of single

1745
01:15:31,679 --> 01:15:34,860
input settings so far so for example now

1746
01:15:34,860 --> 01:15:37,860
we need to hide the attributes for both

1747
01:15:37,860 --> 01:15:40,920
the slots so we would want to obfuscate

1748
01:15:40,920 --> 01:15:42,960
both the side protects but then this is

1749
01:15:42,960 --> 01:15:45,960
a problem because because we need

1750
01:15:45,960 --> 01:15:48,179
interaction between these ciphertext to

1751
01:15:48,179 --> 01:15:50,699
perform decryption but if we obfuscate

1752
01:15:50,699 --> 01:15:52,980
them then we don't know how to do that

1753
01:15:52,980 --> 01:15:55,440
so here we make another observation that

1754
01:15:55,440 --> 01:15:57,179
the yellow can support an arbitrary

1755
01:15:57,179 --> 01:15:58,980
circuit and in particular it can support

1756
01:15:58,980 --> 01:16:01,679
its own evaluation circuit and in the

1757
01:16:01,679 --> 01:16:04,260
decryption circuit so now we use nesting

1758
01:16:04,260 --> 01:16:07,140
of ciphertext so basically the function

1759
01:16:07,140 --> 01:16:09,420
for slot one takes as input the

1760
01:16:09,420 --> 01:16:13,260
obfuscated function for Slot 2 and opens

1761
01:16:13,260 --> 01:16:15,980
it inside and then

1762
01:16:15,980 --> 01:16:18,840
Abe decryption can be performed inside

1763
01:16:18,840 --> 01:16:20,760
this option

1764
01:16:20,760 --> 01:16:23,400
and uh and uh

1765
01:16:23,400 --> 01:16:27,900
we we get to this compiler for any Cape

1766
01:16:27,900 --> 01:16:29,699
where K is a constant

1767
01:16:29,699 --> 01:16:31,860
uh however in case of a stronger

1768
01:16:31,860 --> 01:16:34,440
security or compiler box only for K is

1769
01:16:34,440 --> 01:16:36,000
equals to 2.

1770
01:16:36,000 --> 01:16:39,000
uh to summarize so we formalize the

1771
01:16:39,000 --> 01:16:43,020
security notion for miab and MIP then uh

1772
01:16:43,020 --> 01:16:46,199
using the uh this uh

1773
01:16:46,199 --> 01:16:48,920
observation uh

1774
01:16:48,920 --> 01:16:51,960
that the the techniques develop for

1775
01:16:51,960 --> 01:16:55,199
succinct cpabe is related in

1776
01:16:55,199 --> 01:16:58,440
uh unrelated setting of Mi k-p-a-b-e as

1777
01:16:58,440 --> 01:17:00,719
well we get following results we have 2

1778
01:17:00,719 --> 01:17:03,780
a B for nc1 and heuristic constructions

1779
01:17:03,780 --> 01:17:06,480
for 2ab for p and 3 and b for example

1780
01:17:06,480 --> 01:17:10,020
then we have a generic compiler for KB

1781
01:17:10,020 --> 01:17:13,980
to kpe for constant K using Lo and using

1782
01:17:13,980 --> 01:17:16,500
this compiler on the results that we

1783
01:17:16,500 --> 01:17:19,860
have for a b we get 2pe for nc1 and 2pe

1784
01:17:19,860 --> 01:17:23,460
for p and 3p for nc1 these uh these are

1785
01:17:23,460 --> 01:17:25,620
hemostatic heuristic

1786
01:17:25,620 --> 01:17:28,080
and then we have several open questions

1787
01:17:28,080 --> 01:17:31,699
like we would like to have a b to kpe

1788
01:17:31,699 --> 01:17:34,560
compiler for a stronger security as well

1789
01:17:34,560 --> 01:17:37,440
for any constant K right now we have it

1790
01:17:37,440 --> 01:17:40,440
for only K is equals to 2 and then in

1791
01:17:40,440 --> 01:17:44,100
general we would like to have a KB to KP

1792
01:17:44,100 --> 01:17:47,100
compiler for poly K right now we have

1793
01:17:47,100 --> 01:17:50,480
this for constant K and then we

1794
01:17:50,480 --> 01:17:53,460
want to

1795
01:17:53,460 --> 01:17:57,659
provide security proof for a 3ab and 2ab

1796
01:17:57,659 --> 01:17:59,520
for B Etc

1797
01:17:59,520 --> 01:18:02,420
thank you

1798
01:18:10,440 --> 01:18:13,460
any questions

1799
01:18:13,739 --> 01:18:15,300
okay maybe

1800
01:18:15,300 --> 01:18:18,420
come to one of the mics so that the

1801
01:18:18,420 --> 01:18:19,860
people and zoom at least have a chance

1802
01:18:19,860 --> 01:18:22,500
to hear not sure whether it works anyway

1803
01:18:22,500 --> 01:18:24,420
but

1804
01:18:24,420 --> 01:18:27,679
let's give it a try

1805
01:18:28,440 --> 01:18:31,380
okay hello ah thank you for a nice talk

1806
01:18:31,380 --> 01:18:35,820
I wanted to well we had a nice keynote

1807
01:18:35,820 --> 01:18:39,480
here about use cases so uh in in this

1808
01:18:39,480 --> 01:18:41,880
use case how much cooperation do you

1809
01:18:41,880 --> 01:18:44,640
assume between the attribution attribute

1810
01:18:44,640 --> 01:18:47,400
holders do they need to agree on some

1811
01:18:47,400 --> 01:18:51,000
public parameters or can they just uh

1812
01:18:51,000 --> 01:18:53,040
you know

1813
01:18:53,040 --> 01:18:56,219
work how how in how independently do you

1814
01:18:56,219 --> 01:18:59,060
think they should work

1815
01:18:59,760 --> 01:19:02,719
uh

1816
01:19:02,820 --> 01:19:06,380
uh so uh we so suppose in this example

1817
01:19:06,380 --> 01:19:09,960
for example a hospital Administration

1818
01:19:09,960 --> 01:19:12,120
can be same so they are they will be

1819
01:19:12,120 --> 01:19:15,900
using same master key and attributes can

1820
01:19:15,900 --> 01:19:18,420
be independent we don't need the

1821
01:19:18,420 --> 01:19:22,199
attributes to be exchanged and yeah

1822
01:19:22,199 --> 01:19:26,640
so I I hope I got a question

1823
01:19:26,640 --> 01:19:30,000
does that answer the question

1824
01:19:30,000 --> 01:19:31,679
yes um

1825
01:19:31,679 --> 01:19:33,659
uh continuation

1826
01:19:33,659 --> 01:19:36,300
have you if you heard of the concept

1827
01:19:36,300 --> 01:19:39,320
called multi uh multi-authorogic

1828
01:19:39,320 --> 01:19:41,280
attributes-based encryption can you

1829
01:19:41,280 --> 01:19:44,840
compare this to that concept

1830
01:19:44,840 --> 01:19:46,580
sorry

1831
01:19:46,580 --> 01:19:49,380
multi-authority AB

1832
01:19:49,380 --> 01:19:51,860
ility Authority Aba

1833
01:19:51,860 --> 01:19:53,400
[Music]

1834
01:19:53,400 --> 01:19:56,159
okay sorry actually I have I am not well

1835
01:19:56,159 --> 01:19:58,320
familiar with this stuff I'll check it

1836
01:19:58,320 --> 01:19:59,100
out

1837
01:19:59,100 --> 01:20:02,900
okay then it's not about question thanks

1838
01:20:05,520 --> 01:20:08,460
all right so the fourth and final Talk

1839
01:20:08,460 --> 01:20:11,639
of the session will be live again it's

1840
01:20:11,639 --> 01:20:13,980
on formal verification of Sabers public

1841
01:20:13,980 --> 01:20:17,100
encryption scheme in Easy Crypt

1842
01:20:17,100 --> 01:20:20,719
it's trying to work by Matthias Myers

1843
01:20:20,719 --> 01:20:25,679
Andreas Helsing and Pierre is Stroop and

1844
01:20:25,679 --> 01:20:29,480
Matthias will be giving the talk

1845
01:21:03,920 --> 01:21:07,440
all right so hi everyone my name is and

1846
01:21:07,440 --> 01:21:10,260
together with the

1847
01:21:10,260 --> 01:21:14,300
um does this work no

1848
01:21:22,679 --> 01:21:26,040
ah okay so and together with the

1849
01:21:26,040 --> 01:21:27,840
Articles shown on this slide I've worked

1850
01:21:27,840 --> 01:21:29,639
on the formal verification of shape of

1851
01:21:29,639 --> 01:21:31,980
spirogy and custom scheme energy gap

1852
01:21:31,980 --> 01:21:35,100
and first I will provide some context

1853
01:21:35,100 --> 01:21:37,080
and motivation for the work starting

1854
01:21:37,080 --> 01:21:39,719
with a quick pickup of shaver

1855
01:21:39,719 --> 01:21:42,060
so shaver is a collection of post

1856
01:21:42,060 --> 01:21:44,040
Quantum public key cryptographic

1857
01:21:44,040 --> 01:21:47,040
instructions and was recently a finalist

1858
01:21:47,040 --> 01:21:49,199
um in the competition held by nest for

1859
01:21:49,199 --> 01:21:50,639
the standardization of post Quantum

1860
01:21:50,639 --> 01:21:53,340
cryptography now shape of comprises two

1861
01:21:53,340 --> 01:21:55,139
main schemes of Interest being its

1862
01:21:55,139 --> 01:21:57,360
public encrypted scheme and the ski

1863
01:21:57,360 --> 01:21:59,520
encapsulation mechanism and important

1864
01:21:59,520 --> 01:22:01,980
here is that the key encapsulation

1865
01:22:01,980 --> 01:22:05,159
mechanism will shaver is constructed by

1866
01:22:05,159 --> 01:22:07,139
applying a variant of the free Shark

1867
01:22:07,139 --> 01:22:10,380
locomotive transform on speaker which

1868
01:22:10,380 --> 01:22:14,280
means that a properties of shape screen

1869
01:22:14,280 --> 01:22:16,080
captivation mechanism are dependent on

1870
01:22:16,080 --> 01:22:17,520
the properties of stable speaking each

1871
01:22:17,520 --> 01:22:19,139
game when it is relevant for the

1872
01:22:19,139 --> 01:22:20,639
motivation of this work which we'll come

1873
01:22:20,639 --> 01:22:23,280
back to in a bit

1874
01:22:23,280 --> 01:22:25,320
so then for the the other part of the

1875
01:22:25,320 --> 01:22:27,000
context concerns formal verification

1876
01:22:27,000 --> 01:22:29,580
which is an activity that is part of the

1877
01:22:29,580 --> 01:22:31,920
field of computer-aided cryptography and

1878
01:22:31,920 --> 01:22:33,840
this is a field of research that was at

1879
01:22:33,840 --> 01:22:35,400
least partly established due to

1880
01:22:35,400 --> 01:22:37,139
cryptographic instructions and the

1881
01:22:37,139 --> 01:22:39,980
proofs becoming more complex over time

1882
01:22:39,980 --> 01:22:44,100
and this means that the the construction

1883
01:22:44,100 --> 01:22:47,100
and verification of digital Construction

1884
01:22:47,100 --> 01:22:49,440
general proof it's difficult in our

1885
01:22:49,440 --> 01:22:50,820
opponent leading to an increase

1886
01:22:50,820 --> 01:22:54,000
likelihood of faulty designs faulty

1887
01:22:54,000 --> 01:22:56,940
proofs and or implementations

1888
01:22:56,940 --> 01:22:58,679
now the field of computer today at

1889
01:22:58,679 --> 01:23:00,480
cryptography attempts to alleviate these

1890
01:23:00,480 --> 01:23:02,760
issues by leveraging computers in these

1891
01:23:02,760 --> 01:23:03,840
processes

1892
01:23:03,840 --> 01:23:07,380
and thereby reducing the manual the

1893
01:23:07,380 --> 01:23:08,760
complexity of the manual verification

1894
01:23:08,760 --> 01:23:11,460
effort while enforcing consistently high

1895
01:23:11,460 --> 01:23:13,260
level of trigger

1896
01:23:13,260 --> 01:23:16,380
and using computer computers in this way

1897
01:23:16,380 --> 01:23:19,560
essentially replaces touch and pulls by

1898
01:23:19,560 --> 01:23:22,320
the trust and The Trusted Computing base

1899
01:23:22,320 --> 01:23:24,420
which are the tools that you use in

1900
01:23:24,420 --> 01:23:26,400
these processes

1901
01:23:26,400 --> 01:23:28,320
so then while we could have used many

1902
01:23:28,320 --> 01:23:31,560
Tools in this work we opted to easycrypt

1903
01:23:31,560 --> 01:23:33,300
which is a tool specifically designed

1904
01:23:33,300 --> 01:23:36,000
for the form of verification of code

1905
01:23:36,000 --> 01:23:38,340
based gameplay improve while also

1906
01:23:38,340 --> 01:23:39,719
providing features that allow for

1907
01:23:39,719 --> 01:23:41,580
extensive mathematical reasoning and

1908
01:23:41,580 --> 01:23:43,800
introducing modularity

1909
01:23:43,800 --> 01:23:45,360
um in your in the form of verification

1910
01:23:45,360 --> 01:23:49,820
effort which is sharing uh usual

1911
01:23:50,040 --> 01:23:51,600
so then for the purpose and contribution

1912
01:23:51,600 --> 01:23:53,580
of describe so firstly we formally

1913
01:23:53,580 --> 01:23:55,860
verified shapeless public key uh public

1914
01:23:55,860 --> 01:23:57,960
key encryption scheme or more precisely

1915
01:23:57,960 --> 01:24:00,780
we formally verified that this scheme

1916
01:24:00,780 --> 01:24:02,280
possesses the desired security and

1917
01:24:02,280 --> 01:24:04,080
convections properties

1918
01:24:04,080 --> 01:24:07,020
and which should uh should increase the

1919
01:24:07,020 --> 01:24:08,280
confidence we can have and that the

1920
01:24:08,280 --> 01:24:10,620
scheme actually possesses its properties

1921
01:24:10,620 --> 01:24:13,080
and then due to what I said about the

1922
01:24:13,080 --> 01:24:15,179
camps properties being dependent on the

1923
01:24:15,179 --> 01:24:17,100
public and capture schemes properties

1924
01:24:17,100 --> 01:24:18,900
they should buy implications also

1925
01:24:18,900 --> 01:24:21,120
increase the confidence we can have that

1926
01:24:21,120 --> 01:24:23,520
they can possesses the desired security

1927
01:24:23,520 --> 01:24:25,500
economics properties

1928
01:24:25,500 --> 01:24:27,659
and this is an auto assist in making a

1929
01:24:27,659 --> 01:24:29,159
well-informed decision about the

1930
01:24:29,159 --> 01:24:31,080
adoption of stable schemes

1931
01:24:31,080 --> 01:24:34,139
and then secondly we during this or

1932
01:24:34,139 --> 01:24:35,760
throughout this process for verification

1933
01:24:35,760 --> 01:24:37,500
process we attempted to do as many

1934
01:24:37,500 --> 01:24:39,179
things as possible in a genetic and

1935
01:24:39,179 --> 01:24:40,860
reusable manner

1936
01:24:40,860 --> 01:24:42,840
in order to facilitate a potential

1937
01:24:42,840 --> 01:24:45,719
future form of verification efforts in

1938
01:24:45,719 --> 01:24:48,420
easy grip and so in particular we did

1939
01:24:48,420 --> 01:24:50,580
this for polynomial potions bank so we

1940
01:24:50,580 --> 01:24:52,800
defined uh those under properties and

1941
01:24:52,800 --> 01:24:55,139
genetic and reusable way as well as some

1942
01:24:55,139 --> 01:24:57,540
properties on distribution distributions

1943
01:24:57,540 --> 01:25:02,040
of integers and package of polynomials

1944
01:25:02,040 --> 01:25:05,400
so that's it for the um uh context the

1945
01:25:05,400 --> 01:25:07,500
motivation work I will now go into the

1946
01:25:07,500 --> 01:25:11,120
process actual process software

1947
01:25:16,260 --> 01:25:19,500
so as I said the objectives of the the

1948
01:25:19,500 --> 01:25:21,600
work were um to formally verify shape to

1949
01:25:21,600 --> 01:25:23,100
speak each game and in particular is

1950
01:25:23,100 --> 01:25:25,800
security and correctness properties and

1951
01:25:25,800 --> 01:25:27,480
for both of the assume verification of

1952
01:25:27,480 --> 01:25:29,940
these properties we on a high level took

1953
01:25:29,940 --> 01:25:31,199
the shame approach which is the

1954
01:25:31,199 --> 01:25:33,600
following so first we devised a

1955
01:25:33,600 --> 01:25:36,120
handwritten proof that was really that

1956
01:25:36,120 --> 01:25:37,860
was really like detailed and meticulous

1957
01:25:37,860 --> 01:25:39,600
in order to

1958
01:25:39,600 --> 01:25:41,580
um use it properly as a guideline later

1959
01:25:41,580 --> 01:25:43,560
on in the steps that actually used to

1960
01:25:43,560 --> 01:25:45,659
because the the tool actually forces us

1961
01:25:45,659 --> 01:25:48,780
to be really detailed and meticulous

1962
01:25:48,780 --> 01:25:51,800
so then after devising is proof we

1963
01:25:51,800 --> 01:25:54,239
formalized the context and pull steps in

1964
01:25:54,239 --> 01:25:56,100
the tool after which we actually

1965
01:25:56,100 --> 01:25:58,199
formally verify the proof which

1966
01:25:58,199 --> 01:26:00,300
essentially means just executing the

1967
01:26:00,300 --> 01:26:03,000
proof in a tool

1968
01:26:03,000 --> 01:26:05,940
so then for security this first step

1969
01:26:05,940 --> 01:26:07,620
um approximately looked as follows so

1970
01:26:07,620 --> 01:26:10,260
the goal of this of the proof is to

1971
01:26:10,260 --> 01:26:12,540
relate the ncpa security or stable speak

1972
01:26:12,540 --> 01:26:15,000
English game to solving the decisional

1973
01:26:15,000 --> 01:26:17,100
mlwr coupon or module learning with

1974
01:26:17,100 --> 01:26:18,380
running problem

1975
01:26:18,380 --> 01:26:21,120
and we devised the proof by actually

1976
01:26:21,120 --> 01:26:23,940
taking the already existing proof

1977
01:26:23,940 --> 01:26:26,460
um for this and making it more detailed

1978
01:26:26,460 --> 01:26:29,400
and ridiculous as to use it properly be

1979
01:26:29,400 --> 01:26:32,340
able to use it later on in the exception

1980
01:26:32,340 --> 01:26:33,300
tool

1981
01:26:33,300 --> 01:26:35,880
and so what this gave us was a detailed

1982
01:26:35,880 --> 01:26:38,280
code based gameplaying proof that on a

1983
01:26:38,280 --> 01:26:40,139
conceptual level is similar to the

1984
01:26:40,139 --> 01:26:42,960
already accessing proof except for one

1985
01:26:42,960 --> 01:26:45,000
main difference being that instead of

1986
01:26:45,000 --> 01:26:47,760
directly using the module learning with

1987
01:26:47,760 --> 01:26:49,739
routing problem we actually devised to

1988
01:26:49,739 --> 01:26:52,260
custom computational problems called

1989
01:26:52,260 --> 01:26:55,620
gmwr and xmlwr

1990
01:26:55,620 --> 01:26:57,120
um which are really similar and although

1991
01:26:57,120 --> 01:26:59,159
you are the only main difference being

1992
01:26:59,159 --> 01:27:01,739
that instead of uniformly sampling uh

1993
01:27:01,739 --> 01:27:03,060
The Matrix that is used in these

1994
01:27:03,060 --> 01:27:05,340
problems we generated by an efficient

1995
01:27:05,340 --> 01:27:07,440
function Belgian that is also used in

1996
01:27:07,440 --> 01:27:09,120
Shaver

1997
01:27:09,120 --> 01:27:12,060
um yeah to generate those Matrix

1998
01:27:12,060 --> 01:27:14,040
um and then later on we actually relate

1999
01:27:14,040 --> 01:27:17,060
these properties

2000
01:27:17,699 --> 01:27:19,739
channel for doing this is that it

2001
01:27:19,739 --> 01:27:22,620
actually separates concerns a bit in the

2002
01:27:22,620 --> 01:27:24,060
form of verification effort which makes

2003
01:27:24,060 --> 01:27:26,719
it more manageable

2004
01:27:26,719 --> 01:27:28,980
so then after devising hands could

2005
01:27:28,980 --> 01:27:31,139
improved the next step was um to

2006
01:27:31,139 --> 01:27:32,760
formalize the complexion proof steps in

2007
01:27:32,760 --> 01:27:36,060
Easy Clip and with form by formalizing

2008
01:27:36,060 --> 01:27:37,139
context

2009
01:27:37,139 --> 01:27:39,239
um you can think of formalizing

2010
01:27:39,239 --> 01:27:40,440
parameters and corresponding

2011
01:27:40,440 --> 01:27:42,780
requirements uh the used algorithmic

2012
01:27:42,780 --> 01:27:44,639
structures the use functions and

2013
01:27:44,639 --> 01:27:46,679
distributions as well as the scheme

2014
01:27:46,679 --> 01:27:47,580
itself

2015
01:27:47,580 --> 01:27:50,880
so save to speak e-screen and then for

2016
01:27:50,880 --> 01:27:53,100
formalizing the proof steps and the

2017
01:27:53,100 --> 01:27:56,400
necessary artifacts for those one could

2018
01:27:56,400 --> 01:27:59,520
think of formalizing the uh security

2019
01:27:59,520 --> 01:28:01,679
notion harmless assumptions the

2020
01:28:01,679 --> 01:28:03,540
adversary class transaction at first

2021
01:28:03,540 --> 01:28:05,040
which

2022
01:28:05,040 --> 01:28:06,780
um the actual games in the game sequence

2023
01:28:06,780 --> 01:28:09,780
the proof steps from in the in the game

2024
01:28:09,780 --> 01:28:10,800
sequence

2025
01:28:10,800 --> 01:28:12,540
from game to game as well as the

2026
01:28:12,540 --> 01:28:15,060
security down

2027
01:28:15,060 --> 01:28:17,219
and so in this particular proof there

2028
01:28:17,219 --> 01:28:19,800
was essentially two kinds of uh proof

2029
01:28:19,800 --> 01:28:22,380
steps in the game sequence

2030
01:28:22,380 --> 01:28:24,540
um being the first kind being a

2031
01:28:24,540 --> 01:28:26,219
reduction form a computational hardness

2032
01:28:26,219 --> 01:28:28,260
assumption to distinguishing between two

2033
01:28:28,260 --> 01:28:30,480
consecutive games and the second one

2034
01:28:30,480 --> 01:28:33,480
being a production from solving a game

2035
01:28:33,480 --> 01:28:35,460
in the game sequence to solving

2036
01:28:35,460 --> 01:28:38,100
appreciating game and to give an idea of

2037
01:28:38,100 --> 01:28:40,920
how this formalization process works in

2038
01:28:40,920 --> 01:28:43,139
easycrypt I will give an example of

2039
01:28:43,139 --> 01:28:46,800
um the first kind of move step

2040
01:28:46,800 --> 01:28:48,120
um which is actually

2041
01:28:48,120 --> 01:28:50,880
the very first one uh very first step in

2042
01:28:50,880 --> 01:28:52,980
the proof

2043
01:28:52,980 --> 01:28:55,320
so we start off by formalizing the games

2044
01:28:55,320 --> 01:28:57,120
and this is the very first game which

2045
01:28:57,120 --> 01:28:59,460
you call game zero which is actually the

2046
01:28:59,460 --> 01:29:03,000
ncpa game for Sable speakers

2047
01:29:03,000 --> 01:29:05,880
and so starting from the top

2048
01:29:05,880 --> 01:29:08,400
um you can actually see that in uh so

2049
01:29:08,400 --> 01:29:12,179
any EG that we model games as modules

2050
01:29:12,179 --> 01:29:16,320
which are essentially any stateful a

2051
01:29:16,320 --> 01:29:19,440
stateful entity in the system that can

2052
01:29:19,440 --> 01:29:21,719
execute code and

2053
01:29:21,719 --> 01:29:23,760
and perform computations

2054
01:29:23,760 --> 01:29:26,040
and this module is actually

2055
01:29:26,040 --> 01:29:28,380
parameterized on another module called a

2056
01:29:28,380 --> 01:29:32,400
and which is just type up in CPA which

2057
01:29:32,400 --> 01:29:34,280
is a type that represents the class of

2058
01:29:34,280 --> 01:29:36,960
ncpa at first which of course

2059
01:29:36,960 --> 01:29:38,880
corresponds to the fact that the game is

2060
01:29:38,880 --> 01:29:42,420
also parameterized on search and version

2061
01:29:42,420 --> 01:29:44,639
and then the actual code is encapsulated

2062
01:29:44,639 --> 01:29:47,040
in procedure so looking at this actual

2063
01:29:47,040 --> 01:29:48,239
code

2064
01:29:48,239 --> 01:29:49,980
um one can see that after having

2065
01:29:49,980 --> 01:29:51,560
actually formalized all the

2066
01:29:51,560 --> 01:29:53,520
distributions and functions and

2067
01:29:53,520 --> 01:29:55,920
algebraic structures that you need the

2068
01:29:55,920 --> 01:29:58,199
translation of the hand creating game to

2069
01:29:58,199 --> 01:29:59,820
agclips is actually a lot of

2070
01:29:59,820 --> 01:30:02,060
straightforward

2071
01:30:02,060 --> 01:30:05,520
you see the first stage of the ncpa game

2072
01:30:05,520 --> 01:30:07,739
which is key generation and actually

2073
01:30:07,739 --> 01:30:09,060
comparing

2074
01:30:09,060 --> 01:30:11,040
uh the Android one to the formalization

2075
01:30:11,040 --> 01:30:13,560
in each clip you can see that this is

2076
01:30:13,560 --> 01:30:15,840
um really a line by line uh translation

2077
01:30:15,840 --> 01:30:18,000
for example the first line in the end of

2078
01:30:18,000 --> 01:30:20,639
the one we sampler U from uniform

2079
01:30:20,639 --> 01:30:23,460
distribution of a booleans and this

2080
01:30:23,460 --> 01:30:25,800
message exactly the first line in Easy

2081
01:30:25,800 --> 01:30:27,840
Clip and the second line which samples

2082
01:30:27,840 --> 01:30:29,940
sheet this is naturally exactly the

2083
01:30:29,940 --> 01:30:33,060
second line of each left and so forth

2084
01:30:33,060 --> 01:30:35,699
um so Helio line by line translation

2085
01:30:35,699 --> 01:30:38,460
then we have the call to the at first

2086
01:30:38,460 --> 01:30:41,100
read to provide us with two plain text

2087
01:30:41,100 --> 01:30:42,260
which

2088
01:30:42,260 --> 01:30:46,080
translates to the to work again one line

2089
01:30:46,080 --> 01:30:48,420
um just calling the choose procedure of

2090
01:30:48,420 --> 01:30:51,239
the advanced screen which uh gives us

2091
01:30:51,239 --> 01:30:53,340
each plain text

2092
01:30:53,340 --> 01:30:56,400
then again for the uh

2093
01:30:56,400 --> 01:30:59,280
next stage of the ncpa game the

2094
01:30:59,280 --> 01:31:01,679
encryption of the chosen of one of the

2095
01:31:01,679 --> 01:31:05,520
plain text if you uh

2096
01:31:05,520 --> 01:31:07,560
yes again I want a line by line

2097
01:31:07,560 --> 01:31:10,620
translation and if you uh have I believe

2098
01:31:10,620 --> 01:31:13,380
that that these uh distributions and

2099
01:31:13,380 --> 01:31:15,420
functions actually uh properly specified

2100
01:31:15,420 --> 01:31:17,460
this is really just straightforward

2101
01:31:17,460 --> 01:31:19,440
translation

2102
01:31:19,440 --> 01:31:22,020
um and finally we of course ask your

2103
01:31:22,020 --> 01:31:24,060
first three to guess which um

2104
01:31:24,060 --> 01:31:26,760
well planes actually encrypted and then

2105
01:31:26,760 --> 01:31:29,480
in the end return

2106
01:31:30,179 --> 01:31:32,159
to then the second game

2107
01:31:32,159 --> 01:31:34,560
um uh actually only differs from the

2108
01:31:34,560 --> 01:31:36,600
swirls game and uh

2109
01:31:36,600 --> 01:31:39,420
uh in in one place being the computation

2110
01:31:39,420 --> 01:31:42,900
of uh the vector B that you see here in

2111
01:31:42,900 --> 01:31:45,719
this box and game the differentiator

2112
01:31:45,719 --> 01:31:48,179
than game zero

2113
01:31:48,179 --> 01:31:50,940
um actually properly computed by a

2114
01:31:50,940 --> 01:31:53,159
matrix types of product and then that is

2115
01:31:53,159 --> 01:31:56,580
then skilled and the second game uh the

2116
01:31:56,580 --> 01:31:59,760
championship formats uh domain and

2117
01:31:59,760 --> 01:32:02,400
uniformly at random and because of the

2118
01:32:02,400 --> 01:32:03,719
regardless straightforward translation

2119
01:32:03,719 --> 01:32:05,400
from hand with them to Egypt this is

2120
01:32:05,400 --> 01:32:07,020
also exactly like

2121
01:32:07,020 --> 01:32:07,820
um

2122
01:32:07,820 --> 01:32:11,159
this change is also exactly reflected in

2123
01:32:11,159 --> 01:32:12,480
the difference between games and energy

2124
01:32:12,480 --> 01:32:14,520
cut as you can see here because this is

2125
01:32:14,520 --> 01:32:17,659
the only difference between the games

2126
01:32:18,000 --> 01:32:20,219
so then what we want to do is

2127
01:32:20,219 --> 01:32:22,380
um relate distinguishing between these

2128
01:32:22,380 --> 01:32:24,960
games to uh the gmwr computational

2129
01:32:24,960 --> 01:32:28,320
problem that we created so what we have

2130
01:32:28,320 --> 01:32:31,020
to do is formalize this as well

2131
01:32:31,020 --> 01:32:34,500
and which is uh the following so again

2132
01:32:34,500 --> 01:32:36,900
we module again model the game as a

2133
01:32:36,900 --> 01:32:38,580
module

2134
01:32:38,580 --> 01:32:41,400
um but instead of being parameters on in

2135
01:32:41,400 --> 01:32:43,699
CBA especially this time is parameters

2136
01:32:43,699 --> 01:32:46,620
against gmwr which

2137
01:32:46,620 --> 01:32:49,320
you can see by the type there that's of

2138
01:32:49,320 --> 01:32:51,300
gmwr which represents the Clause of the

2139
01:32:51,300 --> 01:32:53,639
two species again gmwr and because it is

2140
01:32:53,639 --> 01:32:54,960
a decisional game

2141
01:32:54,960 --> 01:32:57,300
um it is it takes an argument the

2142
01:32:57,300 --> 01:33:00,060
Boolean argument which is given to the

2143
01:33:00,060 --> 01:33:01,800
main procedure

2144
01:33:01,800 --> 01:33:05,460
and then if you know uh mlwr this might

2145
01:33:05,460 --> 01:33:07,739
seem familiar but what we do first is

2146
01:33:07,739 --> 01:33:11,100
generate a matrix a and secret Factor s

2147
01:33:11,100 --> 01:33:14,159
which here we do instead of uniformly

2148
01:33:14,159 --> 01:33:15,600
randomly sampling as you would do in

2149
01:33:15,600 --> 01:33:19,020
mlwr we do it by generating it via this

2150
01:33:19,020 --> 01:33:21,739
function gen

2151
01:33:23,239 --> 01:33:27,060
then we compute two vectors one is the

2152
01:33:27,060 --> 01:33:28,199
actual

2153
01:33:28,199 --> 01:33:30,600
um computed Factor by The Matrix Factor

2154
01:33:30,600 --> 01:33:31,980
product and then scaling it the other

2155
01:33:31,980 --> 01:33:34,380
one is the randomly samples per one and

2156
01:33:34,380 --> 01:33:36,540
then depending on the value of the U

2157
01:33:36,540 --> 01:33:39,000
that was passed in

2158
01:33:39,000 --> 01:33:41,699
um we give the corresponding input to

2159
01:33:41,699 --> 01:33:46,080
that first skin as ask it to guess which

2160
01:33:46,080 --> 01:33:47,159
um

2161
01:33:47,159 --> 01:33:51,360
uh which B we gave up so b0 B1 on the

2162
01:33:51,360 --> 01:33:54,380
value of U equivalent

2163
01:33:54,659 --> 01:33:57,120
and then the last artifact we need in

2164
01:33:57,120 --> 01:33:58,080
this um

2165
01:33:58,080 --> 01:34:00,600
in this proof step is the reduction of

2166
01:34:00,600 --> 01:34:03,000
33 which takes uh which plays against

2167
01:34:03,000 --> 01:34:07,020
the gmwr game uh given a at first

2168
01:34:07,020 --> 01:34:08,760
against game channel and game one so an

2169
01:34:08,760 --> 01:34:10,320
NCP anniversary

2170
01:34:10,320 --> 01:34:15,139
and it does show by in case it is given

2171
01:34:15,139 --> 01:34:17,699
the actually properly computed B by the

2172
01:34:17,699 --> 01:34:20,880
gmwr game it simulates a game perfectly

2173
01:34:20,880 --> 01:34:23,100
similaged game general for the ncpa

2174
01:34:23,100 --> 01:34:24,540
first thing and in case it's giving the

2175
01:34:24,540 --> 01:34:26,880
randomly sampled be a perfectly similage

2176
01:34:26,880 --> 01:34:28,380
game one

2177
01:34:28,380 --> 01:34:32,280
and and so as you can see again we

2178
01:34:32,280 --> 01:34:33,900
yes okay

2179
01:34:33,900 --> 01:34:37,440
um uh yes the so even the also the

2180
01:34:37,440 --> 01:34:38,940
reduction experience

2181
01:34:38,940 --> 01:34:42,719
uh model as modules and uh this

2182
01:34:42,719 --> 01:34:44,400
direction as firstly is the

2183
01:34:44,400 --> 01:34:47,219
parameterized on um ntp at first three

2184
01:34:47,219 --> 01:34:50,000
as is also educational

2185
01:34:50,480 --> 01:34:53,699
and then as you can see on the top right

2186
01:34:53,699 --> 01:34:54,960
there

2187
01:34:54,960 --> 01:34:57,000
um this collection is first and also

2188
01:34:57,000 --> 01:34:59,400
defined to be of the type of genome that

2189
01:34:59,400 --> 01:35:02,760
we are so meaning it itself a gmwr

2190
01:35:02,760 --> 01:35:03,900
adversely

2191
01:35:03,900 --> 01:35:05,639
you know which then implements the

2192
01:35:05,639 --> 01:35:09,540
functions that the gmwr game goes of

2193
01:35:09,540 --> 01:35:11,280
this first three which in this case you

2194
01:35:11,280 --> 01:35:13,920
get a procedure

2195
01:35:13,920 --> 01:35:14,760
um

2196
01:35:14,760 --> 01:35:16,860
yeah so the rest of the code because it

2197
01:35:16,860 --> 01:35:19,679
perfectly simulates game 011 uh it's the

2198
01:35:19,679 --> 01:35:21,960
same as we already seen before so it

2199
01:35:21,960 --> 01:35:24,179
won't go into details about this one

2200
01:35:24,179 --> 01:35:25,560
and then

2201
01:35:25,560 --> 01:35:27,780
so after having formalized all of this

2202
01:35:27,780 --> 01:35:30,119
we can actually State the statement we

2203
01:35:30,119 --> 01:35:33,600
want to proof about this which is

2204
01:35:33,600 --> 01:35:36,420
um that the extent to which

2205
01:35:36,420 --> 01:35:38,639
um any ntp adverse distinguishes between

2206
01:35:38,639 --> 01:35:41,580
game zero one one is equal to the

2207
01:35:41,580 --> 01:35:43,199
distinguishing advantage of this

2208
01:35:43,199 --> 01:35:46,679
reduction at first three against gmwr

2209
01:35:46,679 --> 01:35:49,800
um which here in handwritten uh parked

2210
01:35:49,800 --> 01:35:52,020
as you can see above is um

2211
01:35:52,020 --> 01:35:54,000
to get an issue in the usual way just

2212
01:35:54,000 --> 01:35:55,320
the absolute difference between the

2213
01:35:55,320 --> 01:35:57,420
success probabilities

2214
01:35:57,420 --> 01:35:59,820
um of the ncpl first being equal to the

2215
01:35:59,820 --> 01:36:02,699
absolute difference of the predictions

2216
01:36:02,699 --> 01:36:04,679
firstly returning one in both cases of

2217
01:36:04,679 --> 01:36:06,840
the GLD VR game

2218
01:36:06,840 --> 01:36:09,239
and actually if you don't know the shin

2219
01:36:09,239 --> 01:36:12,420
daksh uh a bit this even these Lemma

2220
01:36:12,420 --> 01:36:14,760
statements convert to easy Captain are

2221
01:36:14,760 --> 01:36:17,880
quite intuitive manner so for example

2222
01:36:17,880 --> 01:36:19,679
looking at this first term

2223
01:36:19,679 --> 01:36:21,540
we actually have we actually have a term

2224
01:36:21,540 --> 01:36:23,760
by term translation so looking at the

2225
01:36:23,760 --> 01:36:25,619
stress term you see in each camp this is

2226
01:36:25,619 --> 01:36:27,540
uh also it starts with Beyond meaning

2227
01:36:27,540 --> 01:36:29,760
the denoting the probability of whatever

2228
01:36:29,760 --> 01:36:31,619
follows in this in the square brackets

2229
01:36:31,619 --> 01:36:34,860
and then in the square brackets we have

2230
01:36:34,860 --> 01:36:37,679
um two parts separated by a column

2231
01:36:37,679 --> 01:36:40,260
and the first part indicates or the

2232
01:36:40,260 --> 01:36:43,139
nodes the the process we are executing

2233
01:36:43,139 --> 01:36:46,159
while the high path actually denotes the

2234
01:36:46,159 --> 01:36:49,500
expression we are evaluating and so in

2235
01:36:49,500 --> 01:36:52,440
this case we have that we're executing

2236
01:36:52,440 --> 01:36:54,480
the main procedure of game zero when

2237
01:36:54,480 --> 01:36:58,440
given a and a here as an arbitrary NCP

2238
01:36:58,440 --> 01:37:01,500
at first three and the right parts which

2239
01:37:01,500 --> 01:37:03,960
is a special variable that refers to the

2240
01:37:03,960 --> 01:37:06,000
return value of the procedure that we're

2241
01:37:06,000 --> 01:37:07,739
considering

2242
01:37:07,739 --> 01:37:10,619
and this is a Boolean so just you know

2243
01:37:10,619 --> 01:37:13,139
it's saying it has is equal or

2244
01:37:13,139 --> 01:37:15,060
equivalent to saying it as a snow

2245
01:37:15,060 --> 01:37:18,239
and so combining this this BR statement

2246
01:37:18,239 --> 01:37:20,580
here actually author actually says the

2247
01:37:20,580 --> 01:37:22,560
probability of

2248
01:37:22,560 --> 01:37:25,380
um when we execute the main procedure of

2249
01:37:25,380 --> 01:37:28,080
game zero given this after the ntps

2250
01:37:28,080 --> 01:37:31,500
firstly this game returning two which

2251
01:37:31,500 --> 01:37:33,619
then of course precisely matches the

2252
01:37:33,619 --> 01:37:36,600
handwritten term as well and then you

2253
01:37:36,600 --> 01:37:39,179
can actually do this for each still uh

2254
01:37:39,179 --> 01:37:41,460
individually and you can see that this

2255
01:37:41,460 --> 01:37:46,260
statement matches the handling

2256
01:37:46,560 --> 01:37:48,420
so then after

2257
01:37:48,420 --> 01:37:50,940
um formalizing search all of these pool

2258
01:37:50,940 --> 01:37:53,280
steps we actually formally verify the

2259
01:37:53,280 --> 01:37:55,739
these steps these lemons that we

2260
01:37:55,739 --> 01:37:58,320
specified and

2261
01:37:58,320 --> 01:38:00,600
um I can't go into too much detail here

2262
01:38:00,600 --> 01:38:03,060
but on a conceptual level this process

2263
01:38:03,060 --> 01:38:05,520
is a model similar for most of the both

2264
01:38:05,520 --> 01:38:08,340
steps namely you use the built-in

2265
01:38:08,340 --> 01:38:09,960
reasoning principles and logic of Easy

2266
01:38:09,960 --> 01:38:13,500
Clip and potentially shown properties of

2267
01:38:13,500 --> 01:38:15,659
the utilized operations

2268
01:38:15,659 --> 01:38:18,420
and this while conceptually this is the

2269
01:38:18,420 --> 01:38:19,920
same for most of the proof steps this

2270
01:38:19,920 --> 01:38:22,199
can the difficulty of this process can

2271
01:38:22,199 --> 01:38:25,440
range from rather easy to extremely

2272
01:38:25,440 --> 01:38:26,520
difficult

2273
01:38:26,520 --> 01:38:29,400
and for example the uh this and this

2274
01:38:29,400 --> 01:38:32,040
depends on the stuff like the statements

2275
01:38:32,040 --> 01:38:33,360
you actually want to prove the structure

2276
01:38:33,360 --> 01:38:35,580
of the modules you use as well as the

2277
01:38:35,580 --> 01:38:37,020
complexity of the properties of the

2278
01:38:37,020 --> 01:38:38,280
operations

2279
01:38:38,280 --> 01:38:41,699
and for example the proof of dilemma

2280
01:38:41,699 --> 01:38:43,139
I've just shown as an example is

2281
01:38:43,139 --> 01:38:46,260
actually a place where Egypt really

2282
01:38:46,260 --> 01:38:48,420
shines because

2283
01:38:48,420 --> 01:38:50,400
um the application of the built-in logic

2284
01:38:50,400 --> 01:38:52,080
and featuring principles is actually the

2285
01:38:52,080 --> 01:38:54,179
harder straightforward as well as not

2286
01:38:54,179 --> 01:38:57,360
many complex operation properties have

2287
01:38:57,360 --> 01:38:59,780
to be used and proven

2288
01:38:59,780 --> 01:39:03,060
so then after proving all the

2289
01:39:03,060 --> 01:39:04,380
uh

2290
01:39:04,380 --> 01:39:07,619
individual push-up lemmas we formally

2291
01:39:07,619 --> 01:39:09,780
verified the security theorem by using

2292
01:39:09,780 --> 01:39:12,360
them in the same way as you would in a

2293
01:39:12,360 --> 01:39:14,940
handwritten proof

2294
01:39:14,940 --> 01:39:17,760
and then after this whole process the

2295
01:39:17,760 --> 01:39:19,920
manual verification effort is then

2296
01:39:19,920 --> 01:39:21,920
reduced to actually

2297
01:39:21,920 --> 01:39:24,179
verifying the specification and

2298
01:39:24,179 --> 01:39:26,040
statements in Easy script because the

2299
01:39:26,040 --> 01:39:28,020
value of the verification of the actual

2300
01:39:28,020 --> 01:39:30,060
pull steps or the validity of these two

2301
01:39:30,060 --> 01:39:33,659
steps should be handled by the tool

2302
01:39:33,659 --> 01:39:36,960
right and then to make the picture so

2303
01:39:36,960 --> 01:39:39,420
much uh complete this is

2304
01:39:39,420 --> 01:39:41,520
um the actual proof of the Lemma that

2305
01:39:41,520 --> 01:39:44,280
I've just used as an example

2306
01:39:44,280 --> 01:39:46,139
um and again I can't really go into too

2307
01:39:46,139 --> 01:39:47,699
much detail but

2308
01:39:47,699 --> 01:39:49,440
um you can actually see by this proof

2309
01:39:49,440 --> 01:39:52,739
that um you can use the same proof

2310
01:39:52,739 --> 01:39:56,699
structure for energy clip as you can in

2311
01:39:56,699 --> 01:39:59,340
a hands cutting proof because what we do

2312
01:39:59,340 --> 01:40:01,199
in the handwritten proof

2313
01:40:01,199 --> 01:40:05,639
um here is say that both the left hand

2314
01:40:05,639 --> 01:40:07,320
side of the subtractions as well as the

2315
01:40:07,320 --> 01:40:08,639
right hand side of the sections are

2316
01:40:08,639 --> 01:40:11,040
equal and for which then severely

2317
01:40:11,040 --> 01:40:15,380
results at this level statement holds

2318
01:40:15,420 --> 01:40:18,360
um and actually you can see that uh so

2319
01:40:18,360 --> 01:40:21,440
this first line actually changes this

2320
01:40:21,440 --> 01:40:25,440
Lemma into instead of this proving the

2321
01:40:25,440 --> 01:40:27,000
separate equality

2322
01:40:27,000 --> 01:40:28,800
and this first block

2323
01:40:28,800 --> 01:40:31,139
uh may push this first equality between

2324
01:40:31,139 --> 01:40:34,340
these terms in Redboxes and the second

2325
01:40:34,340 --> 01:40:37,980
uh block of uh proof codes proves the

2326
01:40:37,980 --> 01:40:40,980
order equality which formation dilemma

2327
01:40:40,980 --> 01:40:44,400
results or follows

2328
01:40:44,400 --> 01:40:45,540
um then for

2329
01:40:45,540 --> 01:40:47,880
uh correctness I can't go into Xbox

2330
01:40:47,880 --> 01:40:50,340
detail as I did Social Security but on a

2331
01:40:50,340 --> 01:40:52,080
high level what we did is we again

2332
01:40:52,080 --> 01:40:54,179
adjusted then we find the existing

2333
01:40:54,179 --> 01:40:56,820
already existing proof which is a result

2334
01:40:56,820 --> 01:41:00,780
in the proof where we Define the a

2335
01:41:00,780 --> 01:41:02,940
program that models the correctness

2336
01:41:02,940 --> 01:41:05,280
property for say to speak English game

2337
01:41:05,280 --> 01:41:09,500
as well as a program that models the

2338
01:41:09,500 --> 01:41:11,340
correctness computation that is

2339
01:41:11,340 --> 01:41:14,219
performed by Sable script which is the

2340
01:41:14,219 --> 01:41:16,739
secret that is actually used to compute

2341
01:41:16,739 --> 01:41:19,739
sales connectors for different parameter

2342
01:41:19,739 --> 01:41:22,560
sets and then we demonstrate the

2343
01:41:22,560 --> 01:41:25,020
equivalence between these programs

2344
01:41:25,020 --> 01:41:27,060
which then shows that

2345
01:41:27,060 --> 01:41:30,480
a few minutes okay which just shows that

2346
01:41:30,480 --> 01:41:32,580
um shapescript indeed attempts to

2347
01:41:32,580 --> 01:41:35,000
perform the right computation

2348
01:41:35,000 --> 01:41:38,460
's future work and summary

2349
01:41:38,460 --> 01:41:41,820
so for future work one good thing of uh

2350
01:41:41,820 --> 01:41:44,580
formally verifying the

2351
01:41:44,580 --> 01:41:47,760
um transformation is huge to khcf scam

2352
01:41:47,760 --> 01:41:49,560
from shape of each scheme

2353
01:41:49,560 --> 01:41:51,960
which would then give a form of

2354
01:41:51,960 --> 01:41:55,020
verification of the both saver speak ee

2355
01:41:55,020 --> 01:41:58,080
scheme and Sample scan

2356
01:41:58,080 --> 01:42:00,500
um I could also think of constructing

2357
01:42:00,500 --> 01:42:04,560
efficient implementations or uh

2358
01:42:04,560 --> 01:42:06,840
that are then also formally verified to

2359
01:42:06,840 --> 01:42:08,159
be

2360
01:42:08,159 --> 01:42:12,239
um a side Channel secure memory safe and

2361
01:42:12,239 --> 01:42:13,800
functionally connect with a

2362
01:42:13,800 --> 01:42:16,380
specification that has been proven also

2363
01:42:16,380 --> 01:42:18,719
proven secure and correct on a

2364
01:42:18,719 --> 01:42:22,219
specification level such as the

2365
01:42:22,219 --> 01:42:25,800
specification we use in this work

2366
01:42:25,800 --> 01:42:29,219
um then thirdly one could also

2367
01:42:29,219 --> 01:42:33,139
um by using the genetic uh Concepts we

2368
01:42:33,139 --> 01:42:37,320
defined in this work uh formally verify

2369
01:42:37,320 --> 01:42:39,239
further post Quantum letters-based

2370
01:42:39,239 --> 01:42:41,520
cryptography and here I want to say that

2371
01:42:41,520 --> 01:42:43,199
this works actually the first word to

2372
01:42:43,199 --> 01:42:45,300
come out of an effort of the Mojo crypto

2373
01:42:45,300 --> 01:42:47,699
project to formally verify post Quantum

2374
01:42:47,699 --> 01:42:49,260
cryptography as well as implements

2375
01:42:49,260 --> 01:42:51,080
efficient and formally verified

2376
01:42:51,080 --> 01:42:53,580
implementations of such and for more

2377
01:42:53,580 --> 01:42:55,260
information you can go to the website

2378
01:42:55,260 --> 01:42:57,600
that is shown there on the slides

2379
01:42:57,600 --> 01:42:59,219
and then finally

2380
01:42:59,219 --> 01:43:01,260
uh one good thing of further development

2381
01:43:01,260 --> 01:43:02,699
of each could apply for research that

2382
01:43:02,699 --> 01:43:06,139
has to facilitate future

2383
01:43:06,139 --> 01:43:09,840
of cryptography in each eclipse

2384
01:43:09,840 --> 01:43:11,699
then finally some summary and basic

2385
01:43:11,699 --> 01:43:14,280
statistics so what we did is formally

2386
01:43:14,280 --> 01:43:16,199
verify the security and connections of

2387
01:43:16,199 --> 01:43:18,659
cyber security scheme

2388
01:43:18,659 --> 01:43:21,600
um we developed an extended easy club

2389
01:43:21,600 --> 01:43:23,100
libraries in a genetic way as to

2390
01:43:23,100 --> 01:43:25,139
facilitate a future form of verification

2391
01:43:25,139 --> 01:43:26,280
efforts

2392
01:43:26,280 --> 01:43:29,280
and then for people who are interested

2393
01:43:29,280 --> 01:43:31,560
in knowing or getting an indication of

2394
01:43:31,560 --> 01:43:34,739
how much work is such an a form of

2395
01:43:34,739 --> 01:43:36,659
verification Network takes so we spend

2396
01:43:36,659 --> 01:43:38,940
about three to four months on this and

2397
01:43:38,940 --> 01:43:41,639
the eventual output was all pulled

2398
01:43:41,639 --> 01:43:43,440
output at least approximately three

2399
01:43:43,440 --> 01:43:45,239
thousand three thousand lines of code in

2400
01:43:45,239 --> 01:43:46,440
each of them

2401
01:43:46,440 --> 01:43:48,719
and that concludes my talk and if you

2402
01:43:48,719 --> 01:43:50,639
have any questions I would uh

2403
01:43:50,639 --> 01:43:53,600
notification

2404
01:44:00,540 --> 01:44:03,420
okay thank you so I think for the sake

2405
01:44:03,420 --> 01:44:05,820
of time I suggest that we take questions

2406
01:44:05,820 --> 01:44:08,460
offline for the short 10 minute coffee

2407
01:44:08,460 --> 01:44:09,600
break

2408
01:44:09,600 --> 01:44:13,440
and yeah please be back on time for the

2409
01:44:13,440 --> 01:44:14,340
next

2410
01:44:14,340 --> 01:44:18,780
um a session and thank you again

2411
01:44:18,780 --> 01:44:21,320
oh

