1
00:00:00,080 --> 00:00:02,000
analysis session

2
00:00:02,000 --> 00:00:03,679
so the first stock is differential

3
00:00:03,679 --> 00:00:05,440
cryptanalysis in the fixed key model and

4
00:00:05,440 --> 00:00:09,359
the talk is given banned by tim bainer

5
00:00:15,679 --> 00:00:19,119
okay can you hear me yeah

6
00:00:19,520 --> 00:00:21,759
so

7
00:00:21,920 --> 00:00:23,920
like mario just said so this talks about

8
00:00:23,920 --> 00:00:25,840
the friendship groups analysis uh in the

9
00:00:25,840 --> 00:00:27,359
fixed key model

10
00:00:27,359 --> 00:00:29,599
so um

11
00:00:29,599 --> 00:00:31,279
i mean i think the people who go to this

12
00:00:31,279 --> 00:00:32,719
session probably have some idea what

13
00:00:32,719 --> 00:00:34,800
differential crypto analysis is

14
00:00:34,800 --> 00:00:37,200
but it doesn't hurt to just uh quickly

15
00:00:37,200 --> 00:00:40,239
view that so we have a function f i'm

16
00:00:40,239 --> 00:00:42,320
gonna call it and then we'll take an

17
00:00:42,320 --> 00:00:45,120
input x add some difference a to it

18
00:00:45,120 --> 00:00:47,039
and we're going to see if the output

19
00:00:47,039 --> 00:00:49,680
pair has a certain difference b

20
00:00:49,680 --> 00:00:51,920
and ideally we want to find such a pair

21
00:00:51,920 --> 00:00:53,520
of differences that's also called a

22
00:00:53,520 --> 00:00:55,920
differential so that there are many

23
00:00:55,920 --> 00:00:58,559
inputs x so that this kind of difference

24
00:00:58,559 --> 00:00:59,760
equation

25
00:00:59,760 --> 00:01:02,000
holds and then the number of search x

26
00:01:02,000 --> 00:01:03,920
divided by 2 to the n is what we call

27
00:01:03,920 --> 00:01:06,799
the probability of the differential

28
00:01:06,799 --> 00:01:08,799
and so the basic problem that

29
00:01:08,799 --> 00:01:11,200
this paper deals with is how to compute

30
00:01:11,200 --> 00:01:13,280
this probability

31
00:01:13,280 --> 00:01:14,560
so

32
00:01:14,560 --> 00:01:17,119
in general that's pretty difficult but

33
00:01:17,119 --> 00:01:19,360
usually we have some structure

34
00:01:19,360 --> 00:01:20,960
so the structure we have is that our

35
00:01:20,960 --> 00:01:24,240
function is a composition of a number of

36
00:01:24,240 --> 00:01:27,280
much easier functions and

37
00:01:27,280 --> 00:01:29,040
what we then do is we build a sequence

38
00:01:29,040 --> 00:01:30,960
of intermediate differences that's what

39
00:01:30,960 --> 00:01:32,799
we call a characteristic

40
00:01:32,799 --> 00:01:34,720
and what you have is then that the

41
00:01:34,720 --> 00:01:37,040
probability of your differential is the

42
00:01:37,040 --> 00:01:39,520
sum of the probabilities of all the

43
00:01:39,520 --> 00:01:41,840
characteristics

44
00:01:41,840 --> 00:01:42,960
so

45
00:01:42,960 --> 00:01:46,159
that's the first simplification but

46
00:01:46,159 --> 00:01:48,799
um it still leaves open the problem of

47
00:01:48,799 --> 00:01:50,960
how do we actually compute this

48
00:01:50,960 --> 00:01:52,159
these probabilities of the

49
00:01:52,159 --> 00:01:53,600
characteristics

50
00:01:53,600 --> 00:01:55,759
and to do that

51
00:01:55,759 --> 00:01:57,200
people

52
00:01:57,200 --> 00:01:59,920
basically make an assumption which is

53
00:01:59,920 --> 00:02:02,000
that the propagation under each of those

54
00:02:02,000 --> 00:02:03,360
functions fi

55
00:02:03,360 --> 00:02:06,399
can be assumed to be independent which i

56
00:02:06,399 --> 00:02:08,239
mean doesn't really make sense because

57
00:02:08,239 --> 00:02:10,080
all the intermediate values are just

58
00:02:10,080 --> 00:02:12,400
deterministic functions of each other

59
00:02:12,400 --> 00:02:14,319
but you can make that somewhat more

60
00:02:14,319 --> 00:02:16,080
reasonable by saying that

61
00:02:16,080 --> 00:02:17,599
if you add

62
00:02:17,599 --> 00:02:20,319
round keys so uniform random round keys

63
00:02:20,319 --> 00:02:22,480
after each of those functions then the

64
00:02:22,480 --> 00:02:25,040
average probability of a characteristic

65
00:02:25,040 --> 00:02:26,480
can indeed be computed by just

66
00:02:26,480 --> 00:02:28,400
multiplying probabilities

67
00:02:28,400 --> 00:02:30,160
uh but that gives you the average and

68
00:02:30,160 --> 00:02:31,840
you actually want to know more than the

69
00:02:31,840 --> 00:02:34,400
average you want to know i mean ideally

70
00:02:34,400 --> 00:02:36,080
we would actually want to know the fixed

71
00:02:36,080 --> 00:02:37,680
key probability

72
00:02:37,680 --> 00:02:40,400
and so to bridge this gap between the

73
00:02:40,400 --> 00:02:42,720
two uh people have introduced this

74
00:02:42,720 --> 00:02:45,040
hypothesis that for any particular key

75
00:02:45,040 --> 00:02:47,360
the probability is probably close to the

76
00:02:47,360 --> 00:02:49,200
average value and that's so does this

77
00:02:49,200 --> 00:02:51,680
hypothesis of stochastic equivalence

78
00:02:51,680 --> 00:02:54,160
so we can actually try to check if that

79
00:02:54,160 --> 00:02:56,080
makes sense for some examples so here i

80
00:02:56,080 --> 00:02:57,040
take a

81
00:02:57,040 --> 00:03:00,080
differential for six rounds of spec 32

82
00:03:00,080 --> 00:03:01,280
and then

83
00:03:01,280 --> 00:03:03,599
because spec32 has only a 32-bit block

84
00:03:03,599 --> 00:03:05,519
size you can just

85
00:03:05,519 --> 00:03:07,599
experimentally test how many right pairs

86
00:03:07,599 --> 00:03:08,640
there are

87
00:03:08,640 --> 00:03:11,360
and so if the hypothesis of stochastic

88
00:03:11,360 --> 00:03:13,599
equivalence was correct you would expect

89
00:03:13,599 --> 00:03:16,239
that like in near this red line we would

90
00:03:16,239 --> 00:03:18,959
have some kind of peak in this histogram

91
00:03:18,959 --> 00:03:20,720
so most of the keys should give

92
00:03:20,720 --> 00:03:23,200
probability that's close to this

93
00:03:23,200 --> 00:03:24,879
but as you can see that's not really

94
00:03:24,879 --> 00:03:27,200
true so you have lots of different

95
00:03:27,200 --> 00:03:29,599
peaks in there and a lot of things going

96
00:03:29,599 --> 00:03:31,680
on

97
00:03:31,680 --> 00:03:34,239
i think the most important

98
00:03:34,239 --> 00:03:35,519
for practice the most important

99
00:03:35,519 --> 00:03:38,159
conclusion for this is that if you were

100
00:03:38,159 --> 00:03:39,920
to use the average

101
00:03:39,920 --> 00:03:41,599
then this would actually give incorrect

102
00:03:41,599 --> 00:03:43,840
conclusions in this case because for

103
00:03:43,840 --> 00:03:46,239
example let's say you think okay i take

104
00:03:46,239 --> 00:03:48,560
2 to the 13 pairs and then on average

105
00:03:48,560 --> 00:03:50,879
i'd expect one right one

106
00:03:50,879 --> 00:03:52,799
but actually um

107
00:03:52,799 --> 00:03:54,879
there are a bunch of keys for which

108
00:03:54,879 --> 00:03:57,360
that just wouldn't be enough so you'd be

109
00:03:57,360 --> 00:03:58,879
saying that your successful build is

110
00:03:58,879 --> 00:04:02,080
much larger but this is still a moderate

111
00:04:02,080 --> 00:04:04,560
case that can be much worse

112
00:04:04,560 --> 00:04:06,480
and one thing i want to mention here is

113
00:04:06,480 --> 00:04:07,200
that

114
00:04:07,200 --> 00:04:09,280
i've been talking about this average but

115
00:04:09,280 --> 00:04:10,640
i mean actually it's not the average

116
00:04:10,640 --> 00:04:12,159
because the round keys are also not

117
00:04:12,159 --> 00:04:14,640
independent so even if you

118
00:04:14,640 --> 00:04:17,440
just want the average i mean this you

119
00:04:17,440 --> 00:04:18,959
can't just assume that the wrong keys

120
00:04:18,959 --> 00:04:21,040
are independent

121
00:04:21,040 --> 00:04:23,680
so in order to address this this problem

122
00:04:23,680 --> 00:04:25,600
and to kind of explain figures like the

123
00:04:25,600 --> 00:04:28,320
one i just showed

124
00:04:28,320 --> 00:04:30,479
what we introduced in this paper is a

125
00:04:30,479 --> 00:04:32,800
new technique that we call quasi

126
00:04:32,800 --> 00:04:34,720
differential trails so it should really

127
00:04:34,720 --> 00:04:36,160
be called differential trails but

128
00:04:36,160 --> 00:04:40,639
unfortunately the terms already taken

129
00:04:40,639 --> 00:04:42,720
and to get there i'm

130
00:04:42,720 --> 00:04:45,040
i'm going to first introduce some

131
00:04:45,040 --> 00:04:46,560
sort of extension of the different

132
00:04:46,560 --> 00:04:48,639
distribution table and then from there

133
00:04:48,639 --> 00:04:50,479
get those trails

134
00:04:50,479 --> 00:04:51,680
so

135
00:04:51,680 --> 00:04:52,720
um

136
00:04:52,720 --> 00:04:54,720
so these matrices this glass of

137
00:04:54,720 --> 00:04:57,120
differential transition matrices

138
00:04:57,120 --> 00:04:59,440
the way we get them is by applying a

139
00:04:59,440 --> 00:05:01,120
sort of recipe

140
00:05:01,120 --> 00:05:03,520
so the recipe is

141
00:05:03,520 --> 00:05:05,360
what i've introduced in the context of

142
00:05:05,360 --> 00:05:07,600
linear cryptanalysis as the geometric

143
00:05:07,600 --> 00:05:08,560
approach

144
00:05:08,560 --> 00:05:09,520
which

145
00:05:09,520 --> 00:05:10,720
just like

146
00:05:10,720 --> 00:05:12,639
the very basic idea is that you have

147
00:05:12,639 --> 00:05:14,639
some combinatorial problem and you

148
00:05:14,639 --> 00:05:16,880
convert it into a sort of more geometric

149
00:05:16,880 --> 00:05:17,840
problem

150
00:05:17,840 --> 00:05:20,560
um so the combinatorial problem that we

151
00:05:20,560 --> 00:05:22,880
are interested in here is you have a set

152
00:05:22,880 --> 00:05:24,720
so you're going to encrypt these sets

153
00:05:24,720 --> 00:05:26,240
and then you want to determine the size

154
00:05:26,240 --> 00:05:28,080
of the intersection with the set and

155
00:05:28,080 --> 00:05:29,520
some other sets

156
00:05:29,520 --> 00:05:31,680
and you can make this

157
00:05:31,680 --> 00:05:33,520
kind of more geometric by expressing

158
00:05:33,520 --> 00:05:34,800
this this

159
00:05:34,800 --> 00:05:36,479
this intersection size as an inner

160
00:05:36,479 --> 00:05:38,960
product between two vectors

161
00:05:38,960 --> 00:05:40,800
and i mean two vectors are two functions

162
00:05:40,800 --> 00:05:42,800
that's basically the same thing and and

163
00:05:42,800 --> 00:05:44,720
the vectors we consider here are the

164
00:05:44,720 --> 00:05:48,000
indicator functions of sets so um the

165
00:05:48,000 --> 00:05:50,080
indicator function of a set is just zero

166
00:05:50,080 --> 00:05:53,199
everywhere except it's one on the set

167
00:05:53,199 --> 00:05:55,199
so

168
00:05:55,199 --> 00:05:57,039
if we have that so

169
00:05:57,039 --> 00:05:58,479
we were talking about these indicator

170
00:05:58,479 --> 00:06:00,160
functions but we actually want to know

171
00:06:00,160 --> 00:06:02,160
also if you have an indicator function

172
00:06:02,160 --> 00:06:04,240
of a set how does that change if i apply

173
00:06:04,240 --> 00:06:05,440
a function

174
00:06:05,440 --> 00:06:07,360
and that's actually that there's a

175
00:06:07,360 --> 00:06:09,520
linear relation between this

176
00:06:09,520 --> 00:06:13,280
um and um given by some matrix so just

177
00:06:13,280 --> 00:06:15,759
do a matrix vector product and

178
00:06:15,759 --> 00:06:18,080
the the matrix is very easy to define

179
00:06:18,080 --> 00:06:21,600
it's just mapping delta x which is zero

180
00:06:21,600 --> 00:06:24,479
everywhere except it's the value of x

181
00:06:24,479 --> 00:06:26,400
so it's just a vector with a single

182
00:06:26,400 --> 00:06:29,120
non-zero entry to delta f of x

183
00:06:29,120 --> 00:06:31,280
um and so

184
00:06:31,280 --> 00:06:33,039
this is some matrix that gives this

185
00:06:33,039 --> 00:06:35,120
relation the only thing here is we are

186
00:06:35,120 --> 00:06:37,039
working with pairs not just with

187
00:06:37,039 --> 00:06:38,880
individual values so

188
00:06:38,880 --> 00:06:40,639
we need to do the same thing basically

189
00:06:40,639 --> 00:06:42,560
on sets of pairs

190
00:06:42,560 --> 00:06:44,800
but the id is exactly the same you can

191
00:06:44,800 --> 00:06:47,039
build some kind of matrix

192
00:06:47,039 --> 00:06:49,919
and in fact if you are familiar with

193
00:06:49,919 --> 00:06:52,000
tensor products then you'll easily see

194
00:06:52,000 --> 00:06:52,880
that

195
00:06:52,880 --> 00:06:54,560
your matrix or transition matrix for

196
00:06:54,560 --> 00:06:57,199
pairs is just a tensor product

197
00:06:57,199 --> 00:06:59,280
so

198
00:06:59,280 --> 00:07:02,000
um so now we have this transition matrix

199
00:07:02,000 --> 00:07:04,160
for pairs so that's cool

200
00:07:04,160 --> 00:07:06,400
and it really fully describes

201
00:07:06,400 --> 00:07:08,160
propagation of sets of pairs so

202
00:07:08,160 --> 00:07:10,720
theoretically it also describes exactly

203
00:07:10,720 --> 00:07:12,319
the probability of

204
00:07:12,319 --> 00:07:13,599
differentials but

205
00:07:13,599 --> 00:07:15,440
like practically speaking that's i mean

206
00:07:15,440 --> 00:07:17,360
what we've done is completely useless we

207
00:07:17,360 --> 00:07:19,680
just rewrote the problem a bit so to

208
00:07:19,680 --> 00:07:22,160
actually make this into a useful theory

209
00:07:22,160 --> 00:07:23,840
um i'm going to

210
00:07:23,840 --> 00:07:26,000
introduce a change of basis

211
00:07:26,000 --> 00:07:27,120
so

212
00:07:27,120 --> 00:07:29,599
change of basis so the idea is just that

213
00:07:29,599 --> 00:07:31,440
um so let's say you have here a picture

214
00:07:31,440 --> 00:07:33,840
of my co-author and then you do some

215
00:07:33,840 --> 00:07:36,800
linear transformation the blue matrix

216
00:07:36,800 --> 00:07:39,280
uh and then you get some other picture

217
00:07:39,280 --> 00:07:41,759
so this this linear transformation is

218
00:07:41,759 --> 00:07:44,720
represented by this blue matrix

219
00:07:44,720 --> 00:07:47,120
with respect to the blue basis right and

220
00:07:47,120 --> 00:07:48,879
and you get a different matrix if you

221
00:07:48,879 --> 00:07:50,720
choose a different basis

222
00:07:50,720 --> 00:07:51,759
and

223
00:07:51,759 --> 00:07:54,960
um so when when you look at it from the

224
00:07:54,960 --> 00:07:56,639
point of view of the blue basis it's

225
00:07:56,639 --> 00:07:59,039
actually a pretty complicated matrix

226
00:07:59,039 --> 00:08:01,520
but if you choose for example the red

227
00:08:01,520 --> 00:08:02,639
basis

228
00:08:02,639 --> 00:08:04,560
then it suddenly becomes a diagonal

229
00:08:04,560 --> 00:08:07,599
matrix which is much nicer to work with

230
00:08:07,599 --> 00:08:08,720
so

231
00:08:08,720 --> 00:08:10,960
the idea here is actually for choosing

232
00:08:10,960 --> 00:08:14,000
this red bases i chose vector such that

233
00:08:14,000 --> 00:08:16,160
uh so this this vector here so anything

234
00:08:16,160 --> 00:08:17,680
parallel to that will actually be mapped

235
00:08:17,680 --> 00:08:19,120
to itself

236
00:08:19,120 --> 00:08:21,360
and and here this one you know it just

237
00:08:21,360 --> 00:08:24,000
gets flipped right so

238
00:08:24,000 --> 00:08:25,759
that that's why this is this is a

239
00:08:25,759 --> 00:08:27,599
diagonal matrix

240
00:08:27,599 --> 00:08:29,280
so we're going to do the same thing now

241
00:08:29,280 --> 00:08:30,479
let's do this

242
00:08:30,479 --> 00:08:32,640
really big matrix the transition matrix

243
00:08:32,640 --> 00:08:34,000
for pairs

244
00:08:34,000 --> 00:08:35,839
uh and that means we have to choose a

245
00:08:35,839 --> 00:08:37,679
basis of course so how are we going to

246
00:08:37,679 --> 00:08:39,440
choose the basis there are

247
00:08:39,440 --> 00:08:40,640
two

248
00:08:40,640 --> 00:08:41,599
sort of

249
00:08:41,599 --> 00:08:43,519
natural properties that you would want

250
00:08:43,519 --> 00:08:45,279
this basis to have

251
00:08:45,279 --> 00:08:47,279
the first one is that you want to

252
00:08:47,279 --> 00:08:49,680
include the indicator functions of sets

253
00:08:49,680 --> 00:08:51,760
of pairs with a constant difference so

254
00:08:51,760 --> 00:08:55,120
those are these delta a functions and

255
00:08:55,120 --> 00:08:57,279
the reason for that is that this this is

256
00:08:57,279 --> 00:08:58,240
what we use in differential

257
00:08:58,240 --> 00:09:00,399
cryptanalysis right

258
00:09:00,399 --> 00:09:03,360
and then you also want

259
00:09:03,360 --> 00:09:05,040
your basis and this is related to the

260
00:09:05,040 --> 00:09:06,560
whole fixed key thing

261
00:09:06,560 --> 00:09:07,600
to be

262
00:09:07,600 --> 00:09:09,360
so you want everything to behave really

263
00:09:09,360 --> 00:09:11,519
simple when you're going to add keys so

264
00:09:11,519 --> 00:09:13,440
key addition means you're adding to both

265
00:09:13,440 --> 00:09:15,600
halves of the of the pair you're adding

266
00:09:15,600 --> 00:09:17,200
the same constant

267
00:09:17,200 --> 00:09:18,800
so you want it to be a translation in

268
00:09:18,800 --> 00:09:20,399
variant basis

269
00:09:20,399 --> 00:09:22,320
and there is a solution for that so this

270
00:09:22,320 --> 00:09:24,080
is one possible basis

271
00:09:24,080 --> 00:09:26,480
um and there are sort of two to the two

272
00:09:26,480 --> 00:09:28,959
and basis functions and i will index

273
00:09:28,959 --> 00:09:31,760
them by value u and a value a and you

274
00:09:31,760 --> 00:09:33,440
will be called a mask and a the

275
00:09:33,440 --> 00:09:34,720
difference

276
00:09:34,720 --> 00:09:35,519
so

277
00:09:35,519 --> 00:09:37,920
you can immediately see that if you put

278
00:09:37,920 --> 00:09:40,399
u equal to zero so this becomes one then

279
00:09:40,399 --> 00:09:42,240
you get uh

280
00:09:42,240 --> 00:09:44,160
the the functions we wanted to include

281
00:09:44,160 --> 00:09:47,600
so that's good and uh if you're going to

282
00:09:47,600 --> 00:09:49,839
add some something so do this

283
00:09:49,839 --> 00:09:51,279
translation

284
00:09:51,279 --> 00:09:54,160
then because the sky u that's basically

285
00:09:54,160 --> 00:09:57,360
-1 to some linear function of x

286
00:09:57,360 --> 00:09:59,360
so you're just going to get a constant

287
00:09:59,360 --> 00:10:02,000
vector that doesn't depend on x or y

288
00:10:02,000 --> 00:10:03,200
so

289
00:10:03,200 --> 00:10:05,440
uh so we have the the properties we want

290
00:10:05,440 --> 00:10:06,640
that's good

291
00:10:06,640 --> 00:10:08,399
uh and i mean if you are

292
00:10:08,399 --> 00:10:10,640
like more theoretical

293
00:10:10,640 --> 00:10:12,560
then you might wanna like if you wanna

294
00:10:12,560 --> 00:10:13,839
generalize to other groups you might

295
00:10:13,839 --> 00:10:15,760
wanna know this the reason why we use

296
00:10:15,760 --> 00:10:17,600
this particular basis is because this

297
00:10:17,600 --> 00:10:20,320
kind of view is a group character

298
00:10:20,320 --> 00:10:22,640
so now we have this basis and then we

299
00:10:22,640 --> 00:10:25,519
can just do a change of basis on our

300
00:10:25,519 --> 00:10:27,839
transition matrix and that's what

301
00:10:27,839 --> 00:10:29,200
this graphic differential transition

302
00:10:29,200 --> 00:10:30,399
matrix is

303
00:10:30,399 --> 00:10:31,920
so there's nothing more to it but if

304
00:10:31,920 --> 00:10:33,680
you're a practical person you probably

305
00:10:33,680 --> 00:10:35,839
want to know what the actual coordinates

306
00:10:35,839 --> 00:10:38,880
of of the matrix look like now so what

307
00:10:38,880 --> 00:10:40,560
they actually look like is

308
00:10:40,560 --> 00:10:42,480
so i'm going to index the coordinates

309
00:10:42,480 --> 00:10:43,760
that's the first thing i should say by

310
00:10:43,760 --> 00:10:46,240
these most different pairs why because

311
00:10:46,240 --> 00:10:48,000
otherwise i have to number the basis

312
00:10:48,000 --> 00:10:50,079
vectors in an arbitrary way and it seems

313
00:10:50,079 --> 00:10:51,440
a bit

314
00:10:51,440 --> 00:10:52,800
silly to do that

315
00:10:52,800 --> 00:10:55,040
so what you actually have is some

316
00:10:55,040 --> 00:10:56,399
product of the probability of the

317
00:10:56,399 --> 00:10:58,800
differential and then some term which is

318
00:10:58,800 --> 00:11:01,279
two times the probability minus one and

319
00:11:01,279 --> 00:11:02,480
if you are familiar with linear

320
00:11:02,480 --> 00:11:04,000
cryptanalysis that's what we call a

321
00:11:04,000 --> 00:11:05,279
correlation

322
00:11:05,279 --> 00:11:07,440
so here we are actually so this is a

323
00:11:07,440 --> 00:11:09,760
measure let's say of how biased some

324
00:11:09,760 --> 00:11:11,279
expression is so here we're measuring

325
00:11:11,279 --> 00:11:14,000
how biased some linear combination of

326
00:11:14,000 --> 00:11:16,399
inputs and output bitsis

327
00:11:16,399 --> 00:11:19,120
um and we're doing that only for the the

328
00:11:19,120 --> 00:11:21,680
values that satisfy the differential

329
00:11:21,680 --> 00:11:24,640
um so you could say that in a way

330
00:11:24,640 --> 00:11:27,600
this quasi differential thing is just a

331
00:11:27,600 --> 00:11:29,279
sort of linear crypto analysis

332
00:11:29,279 --> 00:11:32,240
restricted to the set of right pairs

333
00:11:32,240 --> 00:11:35,279
so um then we can compute this for

334
00:11:35,279 --> 00:11:37,600
specific s boxes so for example this is

335
00:11:37,600 --> 00:11:40,399
a rectangle s box you have the ddt of

336
00:11:40,399 --> 00:11:42,240
that and then your quasi differential

337
00:11:42,240 --> 00:11:44,560
transition matrix is a kind of zoomed in

338
00:11:44,560 --> 00:11:46,720
version of that so where for every

339
00:11:46,720 --> 00:11:48,480
element of your ddt you would get a

340
00:11:48,480 --> 00:11:49,839
whole sub-matrix of your

341
00:11:49,839 --> 00:11:52,480
quasi-differential transition matrix

342
00:11:52,480 --> 00:11:54,480
and then so the top

343
00:11:54,480 --> 00:11:56,800
left elements in each of those like that

344
00:11:56,800 --> 00:11:59,839
that's going to be uh the probability

345
00:11:59,839 --> 00:12:01,279
of the differential

346
00:12:01,279 --> 00:12:04,399
and then uh if you take um differences

347
00:12:04,399 --> 00:12:06,639
equal to zero you get this correlation

348
00:12:06,639 --> 00:12:08,079
matrix so if you're familiar with linear

349
00:12:08,079 --> 00:12:10,560
grip analysis that's a very important

350
00:12:10,560 --> 00:12:13,199
object there

351
00:12:13,279 --> 00:12:14,399
so

352
00:12:14,399 --> 00:12:17,440
um now we have this matrix

353
00:12:17,440 --> 00:12:19,680
and then we can try to

354
00:12:19,680 --> 00:12:21,839
so i'll show now how we can go from

355
00:12:21,839 --> 00:12:25,279
there to trails so the main property

356
00:12:25,279 --> 00:12:26,800
that we need for that is that if you

357
00:12:26,800 --> 00:12:29,200
have a composition of functions

358
00:12:29,200 --> 00:12:31,200
then the quasi differential transition

359
00:12:31,200 --> 00:12:33,279
matrix is just going to be the product

360
00:12:33,279 --> 00:12:35,200
so the matrix product of a bunch of

361
00:12:35,200 --> 00:12:36,079
these

362
00:12:36,079 --> 00:12:38,800
uh you know for the these functions are

363
00:12:38,800 --> 00:12:40,240
the quasi differential matrices for

364
00:12:40,240 --> 00:12:41,519
those functions

365
00:12:41,519 --> 00:12:43,519
and then you can just take these matrix

366
00:12:43,519 --> 00:12:45,839
products and write out the coordinates

367
00:12:45,839 --> 00:12:48,959
uh just just as a as a sum right so you

368
00:12:48,959 --> 00:12:51,040
get some sum over some products

369
00:12:51,040 --> 00:12:53,200
and then the terms in that sum are what

370
00:12:53,200 --> 00:12:55,200
we call these trails

371
00:12:55,200 --> 00:12:58,480
so there are sequences of pairs of masks

372
00:12:58,480 --> 00:13:00,320
and differences

373
00:13:00,320 --> 00:13:03,519
and uh so then the products here are

374
00:13:03,519 --> 00:13:06,320
what we call the correlation of a trail

375
00:13:06,320 --> 00:13:08,000
and this is useful because the

376
00:13:08,000 --> 00:13:09,920
correlation of trails is usually easy to

377
00:13:09,920 --> 00:13:12,560
compute because your functions if i do

378
00:13:12,560 --> 00:13:14,160
have some structure that makes it easy

379
00:13:14,160 --> 00:13:16,000
to compute this because the differential

380
00:13:16,000 --> 00:13:17,920
transition matrices

381
00:13:17,920 --> 00:13:20,000
and then the interesting part is if we

382
00:13:20,000 --> 00:13:21,680
so if we take

383
00:13:21,680 --> 00:13:24,160
masks equal to zero for both the inputs

384
00:13:24,160 --> 00:13:27,040
and the outputs so then we get on the

385
00:13:27,040 --> 00:13:29,040
left here that's the probability of the

386
00:13:29,040 --> 00:13:30,800
differential and then it shows that the

387
00:13:30,800 --> 00:13:32,800
probability of a differential is exactly

388
00:13:32,800 --> 00:13:35,920
equal to some sum of uh correlations of

389
00:13:35,920 --> 00:13:37,440
a number of trills

390
00:13:37,440 --> 00:13:39,040
and the idea will be that we select the

391
00:13:39,040 --> 00:13:42,959
most important trails and work with them

392
00:13:43,120 --> 00:13:45,440
yeah if you were to

393
00:13:45,440 --> 00:13:47,440
remove all the terms from the sum where

394
00:13:47,440 --> 00:13:48,959
the mask is

395
00:13:48,959 --> 00:13:51,519
non-zero so you keep only masks which

396
00:13:51,519 --> 00:13:52,800
are zero then

397
00:13:52,800 --> 00:13:54,720
you basically get the standard thing we

398
00:13:54,720 --> 00:13:56,240
do so just

399
00:13:56,240 --> 00:13:57,360
summing the probability of

400
00:13:57,360 --> 00:13:58,399
characteristics where those

401
00:13:58,399 --> 00:14:00,800
probabilities are computed by multiply

402
00:14:00,800 --> 00:14:02,320
so but this shows you actually need to

403
00:14:02,320 --> 00:14:05,040
take into account a bit more

404
00:14:05,040 --> 00:14:06,320
so

405
00:14:06,320 --> 00:14:08,000
another thing that you might want to do

406
00:14:08,000 --> 00:14:10,000
so that's for computing probabilities of

407
00:14:10,000 --> 00:14:12,720
differentials so you often also want to

408
00:14:12,720 --> 00:14:14,240
directly compute the probability for a

409
00:14:14,240 --> 00:14:15,680
characteristic

410
00:14:15,680 --> 00:14:17,519
and then you do kind of the obvious

411
00:14:17,519 --> 00:14:19,519
thing so you just sum only over the

412
00:14:19,519 --> 00:14:21,120
masks because the differences are

413
00:14:21,120 --> 00:14:23,519
already fixed in your characteristic

414
00:14:23,519 --> 00:14:26,800
and it's easy to see that this works

415
00:14:26,800 --> 00:14:28,800
like the differential characteristic is

416
00:14:28,800 --> 00:14:30,800
just a differential but for a function

417
00:14:30,800 --> 00:14:33,519
where your intermediate values are also

418
00:14:33,519 --> 00:14:35,680
part of the output so then if you

419
00:14:35,680 --> 00:14:38,000
specify the differences here this

420
00:14:38,000 --> 00:14:40,399
fixes your internal differences if you

421
00:14:40,399 --> 00:14:42,079
specify the masks

422
00:14:42,079 --> 00:14:44,000
so that there's this general rule for

423
00:14:44,000 --> 00:14:45,760
how the masks propagate it's basically

424
00:14:45,760 --> 00:14:47,920
the same as in linear kit analysis then

425
00:14:47,920 --> 00:14:49,600
because this is zero there will be

426
00:14:49,600 --> 00:14:51,600
arbitrary masks before and after your

427
00:14:51,600 --> 00:14:53,120
forking operation

428
00:14:53,120 --> 00:14:54,880
but they have to be equal so you have to

429
00:14:54,880 --> 00:14:56,800
sum over all these trails that's why you

430
00:14:56,800 --> 00:14:58,720
get this result

431
00:14:58,720 --> 00:14:59,680
so

432
00:14:59,680 --> 00:15:01,600
now we have trails

433
00:15:01,600 --> 00:15:02,480
um

434
00:15:02,480 --> 00:15:04,959
so those sequences and then we can try

435
00:15:04,959 --> 00:15:07,360
to use them to actually explain some

436
00:15:07,360 --> 00:15:08,560
phenomena

437
00:15:08,560 --> 00:15:10,480
so um

438
00:15:10,480 --> 00:15:11,519
yeah in

439
00:15:11,519 --> 00:15:12,880
so

440
00:15:12,880 --> 00:15:15,120
first of all if you so you want to find

441
00:15:15,120 --> 00:15:17,279
the best trails because that's i mean

442
00:15:17,279 --> 00:15:19,360
we're going to still do an approximation

443
00:15:19,360 --> 00:15:21,040
where we replace this sum over huge

444
00:15:21,040 --> 00:15:22,800
number of terms which is the sum over a

445
00:15:22,800 --> 00:15:24,160
small number

446
00:15:24,160 --> 00:15:27,839
um and for that um you can use uh some

447
00:15:27,839 --> 00:15:29,600
automated tools in this paper used as

448
00:15:29,600 --> 00:15:31,040
smt modeling

449
00:15:31,040 --> 00:15:34,240
and then um for the small functions you

450
00:15:34,240 --> 00:15:35,920
need some algorithms

451
00:15:35,920 --> 00:15:37,360
to compute to make the quality

452
00:15:37,360 --> 00:15:40,639
differential transition matrices and um

453
00:15:40,639 --> 00:15:43,279
so there are some algorithms that are so

454
00:15:43,279 --> 00:15:44,959
you can compute it in about the same

455
00:15:44,959 --> 00:15:46,160
time as

456
00:15:46,160 --> 00:15:47,920
the size of your matrix so that's pretty

457
00:15:47,920 --> 00:15:49,920
good and for modular additions and

458
00:15:49,920 --> 00:15:53,600
bigger functions we have a formula

459
00:15:53,600 --> 00:15:57,040
and then we apply this to

460
00:15:57,040 --> 00:15:59,839
three ciphers that we chose mostly based

461
00:15:59,839 --> 00:16:02,880
on how easy it is to talk about them

462
00:16:02,880 --> 00:16:04,880
so rectangle where we show the best

463
00:16:04,880 --> 00:16:06,399
attack that's been published doesn't

464
00:16:06,399 --> 00:16:08,560
actually work although you can fix it at

465
00:16:08,560 --> 00:16:09,839
least partially

466
00:16:09,839 --> 00:16:12,240
um then knot that's a hash function in

467
00:16:12,240 --> 00:16:14,480
the lightweight crypto competition there

468
00:16:14,480 --> 00:16:16,000
were some collision attacks proposed on

469
00:16:16,000 --> 00:16:17,040
that but it turns out the

470
00:16:17,040 --> 00:16:19,040
characteristics used in that attack just

471
00:16:19,040 --> 00:16:20,959
have probability zero so you're not

472
00:16:20,959 --> 00:16:22,959
going to find a collision with that and

473
00:16:22,959 --> 00:16:24,800
then we also looked at specs so just

474
00:16:24,800 --> 00:16:27,360
briefly say a bit about specs so

475
00:16:27,360 --> 00:16:29,040
first i want to go back to this example

476
00:16:29,040 --> 00:16:30,959
i showed at the beginning

477
00:16:30,959 --> 00:16:33,040
so here if you do this automated

478
00:16:33,040 --> 00:16:35,279
analysis or even manually if you have a

479
00:16:35,279 --> 00:16:36,480
bit more time

480
00:16:36,480 --> 00:16:39,040
then you'll find there are five

481
00:16:39,040 --> 00:16:40,959
trails which really have a much larger

482
00:16:40,959 --> 00:16:42,399
absolute correlation than the other

483
00:16:42,399 --> 00:16:44,800
trails then if you just take into

484
00:16:44,800 --> 00:16:46,959
account those so there are

485
00:16:46,959 --> 00:16:48,000
three

486
00:16:48,000 --> 00:16:49,759
key bits three linearly independent key

487
00:16:49,759 --> 00:16:51,040
bits this one is just a linear

488
00:16:51,040 --> 00:16:52,240
combination

489
00:16:52,240 --> 00:16:55,519
that uh actually uh can influence this

490
00:16:55,519 --> 00:16:58,240
probability in a significant way and

491
00:16:58,240 --> 00:16:59,440
then you could you know you can just

492
00:16:59,440 --> 00:17:01,360
compute what possible values can that

493
00:17:01,360 --> 00:17:02,560
give

494
00:17:02,560 --> 00:17:04,880
and uh so this is the red lines here and

495
00:17:04,880 --> 00:17:06,959
you can see that it matches those peaks

496
00:17:06,959 --> 00:17:08,880
i mean you can also compute how many

497
00:17:08,880 --> 00:17:10,319
keys there would be in each of those

498
00:17:10,319 --> 00:17:11,599
peaks of course

499
00:17:11,599 --> 00:17:12,720
uh and

500
00:17:12,720 --> 00:17:14,240
so so this

501
00:17:14,240 --> 00:17:16,720
gives a sort of simple model if you want

502
00:17:16,720 --> 00:17:18,400
to improve you just need to take into

503
00:17:18,400 --> 00:17:21,199
account more trails

504
00:17:21,679 --> 00:17:23,039
so

505
00:17:23,039 --> 00:17:25,119
similar to that you can explain some

506
00:17:25,119 --> 00:17:27,439
experiments that were recently published

507
00:17:27,439 --> 00:17:29,679
at sec i think

508
00:17:29,679 --> 00:17:31,360
that's even easier actually that case

509
00:17:31,360 --> 00:17:33,600
there you only have two trails

510
00:17:33,600 --> 00:17:36,480
um and then we also looked at some

511
00:17:36,480 --> 00:17:38,799
actual key recovery attacks

512
00:17:38,799 --> 00:17:41,760
uh so uh yeah basically

513
00:17:41,760 --> 00:17:44,000
the conclusion there is like most of the

514
00:17:44,000 --> 00:17:45,679
key recovery attacks that have been

515
00:17:45,679 --> 00:17:47,840
published only work for like

516
00:17:47,840 --> 00:17:49,760
one in four keys or less with some

517
00:17:49,760 --> 00:17:51,760
exceptions like spec 96 where it only

518
00:17:51,760 --> 00:17:54,080
works for 164 keys

519
00:17:54,080 --> 00:17:57,520
um the positive side to that is that for

520
00:17:57,520 --> 00:17:59,200
the keys for which that they could

521
00:17:59,200 --> 00:18:01,360
actually work you can do with a lot less

522
00:18:01,360 --> 00:18:03,679
data than what's expected

523
00:18:03,679 --> 00:18:04,720
um

524
00:18:04,720 --> 00:18:06,480
i just want to mention that it's not

525
00:18:06,480 --> 00:18:09,280
like i tried to find differentials where

526
00:18:09,280 --> 00:18:10,559
like the

527
00:18:10,559 --> 00:18:12,240
results would like from from the

528
00:18:12,240 --> 00:18:14,720
literature would be wrong or anything so

529
00:18:14,720 --> 00:18:17,200
i expect that if you try uh any attack

530
00:18:17,200 --> 00:18:18,880
that is very likely you'll find that

531
00:18:18,880 --> 00:18:20,080
actually there are

532
00:18:20,080 --> 00:18:22,240
some inconsistencies or some

533
00:18:22,240 --> 00:18:24,720
improvements in some cases

534
00:18:24,720 --> 00:18:27,919
so just to conclude so we've got this

535
00:18:27,919 --> 00:18:30,160
new thing called quasi differential

536
00:18:30,160 --> 00:18:32,080
trails which are constructed from

537
00:18:32,080 --> 00:18:34,960
quasi-differential transition matrices

538
00:18:34,960 --> 00:18:35,919
um

539
00:18:35,919 --> 00:18:36,880
and then

540
00:18:36,880 --> 00:18:38,720
we applied those in the paper to a

541
00:18:38,720 --> 00:18:39,760
number of

542
00:18:39,760 --> 00:18:40,840
attacks

543
00:18:40,840 --> 00:18:43,280
um so we used

544
00:18:43,280 --> 00:18:45,360
smt to find it and we can find the

545
00:18:45,360 --> 00:18:47,120
source code for the

546
00:18:47,120 --> 00:18:50,720
smt tool we have uh at this link

547
00:18:50,720 --> 00:18:52,320
but yeah i think there is a lot of

548
00:18:52,320 --> 00:18:53,840
future work here

549
00:18:53,840 --> 00:18:54,640
so

550
00:18:54,640 --> 00:18:56,640
one thing is that you can just take any

551
00:18:56,640 --> 00:18:57,760
attack

552
00:18:57,760 --> 00:18:58,720
and then

553
00:18:58,720 --> 00:19:00,559
actually try to take into account these

554
00:19:00,559 --> 00:19:02,720
additional trails and see if

555
00:19:02,720 --> 00:19:04,960
the key has a significant effect and my

556
00:19:04,960 --> 00:19:07,440
expectation is that in many cases

557
00:19:07,440 --> 00:19:09,919
that will be a very significant effect

558
00:19:09,919 --> 00:19:12,799
uh there are also uh some

559
00:19:12,799 --> 00:19:14,000
i mean i think it's interesting to

560
00:19:14,000 --> 00:19:16,160
improve these tools because i mean there

561
00:19:16,160 --> 00:19:17,679
are some actual very specific

562
00:19:17,679 --> 00:19:19,760
optimizations that could be done that

563
00:19:19,760 --> 00:19:21,679
because our paper doesn't focus too much

564
00:19:21,679 --> 00:19:24,559
on the automated analysis

565
00:19:24,559 --> 00:19:26,000
and then one last thing i want to

566
00:19:26,000 --> 00:19:27,919
mention is that the limitation of this

567
00:19:27,919 --> 00:19:30,240
method is just the same as in linear

568
00:19:30,240 --> 00:19:32,000
cryptanalysis so this is

569
00:19:32,000 --> 00:19:34,480
a theory where you have trails

570
00:19:34,480 --> 00:19:36,400
but trails don't explain everything

571
00:19:36,400 --> 00:19:37,840
because you can have a large number of

572
00:19:37,840 --> 00:19:39,360
trails

573
00:19:39,360 --> 00:19:41,039
which have a combined effect that's

574
00:19:41,039 --> 00:19:43,600
still very important but for that you

575
00:19:43,600 --> 00:19:46,480
need to go beyond uh

576
00:19:46,480 --> 00:19:49,120
just uh theories with what i call in

577
00:19:49,120 --> 00:19:51,440
this geometric framework one-dimensional

578
00:19:51,440 --> 00:19:54,160
trail so you need to go

579
00:19:54,160 --> 00:19:55,840
further than that

580
00:19:55,840 --> 00:19:57,760
okay that's uh

581
00:19:57,760 --> 00:19:59,440
that's the

582
00:19:59,440 --> 00:20:03,880
that's everything thank you very much

583
00:20:07,919 --> 00:20:10,799
so are there any questions

584
00:20:10,799 --> 00:20:13,360
there is a question in zoom from

585
00:20:13,360 --> 00:20:15,840
michael abramson i'm going to read it he

586
00:20:15,840 --> 00:20:18,400
says have you tried this attack on this

587
00:20:18,400 --> 00:20:19,760
since that is where differentiation

588
00:20:19,760 --> 00:20:21,039
analysis began

589
00:20:21,039 --> 00:20:23,840
so if you try to apply this on this

590
00:20:23,840 --> 00:20:26,080
so in the paper there is an analysis of

591
00:20:26,080 --> 00:20:29,440
the um original characteristic that's

592
00:20:29,440 --> 00:20:32,799
used in the attack uh by bihar shamir

593
00:20:32,799 --> 00:20:34,880
so there's actually i mean it was known

594
00:20:34,880 --> 00:20:36,640
there that there is a quite significant

595
00:20:36,640 --> 00:20:38,400
effects of the key

596
00:20:38,400 --> 00:20:40,559
uh which is actually i mean if you use

597
00:20:40,559 --> 00:20:41,600
so there are actually two

598
00:20:41,600 --> 00:20:43,280
characteristics that are used in the

599
00:20:43,280 --> 00:20:45,919
final attack on ds to compensate for

600
00:20:45,919 --> 00:20:47,039
that kind of

601
00:20:47,039 --> 00:20:48,960
and um

602
00:20:48,960 --> 00:20:51,440
so yeah you can explain that with just

603
00:20:51,440 --> 00:20:53,760
one uh quasi differential trail which is

604
00:20:53,760 --> 00:20:55,760
local to one round so if you iterate

605
00:20:55,760 --> 00:20:57,200
many rounds you you'll get several

606
00:20:57,200 --> 00:20:58,880
copies of that

607
00:20:58,880 --> 00:21:00,799
um

608
00:21:00,799 --> 00:21:03,200
yeah i also checked then if there are in

609
00:21:03,200 --> 00:21:04,559
that case even more who has the

610
00:21:04,559 --> 00:21:06,080
differential trails but it turns out not

611
00:21:06,080 --> 00:21:07,840
to be the case so that's the main effect

612
00:21:07,840 --> 00:21:09,520
there

613
00:21:09,520 --> 00:21:11,360
so but yeah we looked at it

614
00:21:11,360 --> 00:21:12,159
thanks

615
00:21:12,159 --> 00:21:14,880
i have a question maybe a bit naive one

616
00:21:14,880 --> 00:21:16,960
but so in the cases where you found out

617
00:21:16,960 --> 00:21:18,799
that the attacks didn't work or that a

618
00:21:18,799 --> 00:21:22,000
small proportion of the keys

619
00:21:22,000 --> 00:21:23,760
would be the the ones for the attack

620
00:21:23,760 --> 00:21:26,000
work could this give vessels information

621
00:21:26,000 --> 00:21:28,080
on the value of the keys uh when the

622
00:21:28,080 --> 00:21:29,600
attack doesn't work for instance would

623
00:21:29,600 --> 00:21:30,960
could this be

624
00:21:30,960 --> 00:21:33,039
to recover like information

625
00:21:33,039 --> 00:21:34,240
yes

626
00:21:34,240 --> 00:21:36,799
i mean not much but a bit yeah sorry a

627
00:21:36,799 --> 00:21:38,640
little bit of information about the key

628
00:21:38,640 --> 00:21:40,400
yeah and you don't think that it would

629
00:21:40,400 --> 00:21:42,400
be exploited to uh i don't know to learn

630
00:21:42,400 --> 00:21:44,720
monthly

631
00:21:44,720 --> 00:21:47,520
yeah i mean so

632
00:21:47,600 --> 00:21:52,320
it depends because so the it could like

633
00:21:52,640 --> 00:21:54,400
so

634
00:21:54,400 --> 00:21:55,840
in the uh

635
00:21:55,840 --> 00:21:58,080
like for example for these attacks on

636
00:21:58,080 --> 00:21:59,760
specs so let's say you have this thing

637
00:21:59,760 --> 00:22:01,919
where it only works in one over 64 keys

638
00:22:01,919 --> 00:22:03,600
so you find out that

639
00:22:03,600 --> 00:22:06,080
it doesn't work then you know

640
00:22:06,080 --> 00:22:08,400
yeah that is not one of those this is a

641
00:22:08,400 --> 00:22:10,480
you can know exactly what this class of

642
00:22:10,480 --> 00:22:13,360
keys looks like but i mean

643
00:22:13,360 --> 00:22:15,280
those will be internal bits of the key

644
00:22:15,280 --> 00:22:17,520
so that's already less clear if you can

645
00:22:17,520 --> 00:22:19,120
directly use it in a key recovery or

646
00:22:19,120 --> 00:22:20,480
something

647
00:22:20,480 --> 00:22:21,840
but yeah you get a little bit of

648
00:22:21,840 --> 00:22:24,320
information

649
00:22:24,559 --> 00:22:27,679
yeah it doesn't really save the attack

650
00:22:27,679 --> 00:22:29,120
okay

651
00:22:29,120 --> 00:22:31,280
are there any more questions in the in

652
00:22:31,280 --> 00:22:34,158
the room or into

653
00:22:35,360 --> 00:22:37,039
so if there are no more questions then

654
00:22:37,039 --> 00:22:38,559
let's thank team again thank you very

655
00:22:38,559 --> 00:22:41,559
much

656
00:23:12,400 --> 00:23:15,039
and the second talk of this session is

657
00:23:15,039 --> 00:23:16,640
simplified meet in the middle modeling

658
00:23:16,640 --> 00:23:19,440
for permutations new quantum attacks and

659
00:23:19,440 --> 00:23:23,640
the talk is given by andres morton

660
00:23:59,600 --> 00:24:01,840
okay you have a voice yes

661
00:24:01,840 --> 00:24:03,520
thank you for the introduction

662
00:24:03,520 --> 00:24:05,279
um so yeah this is a joint work with

663
00:24:05,279 --> 00:24:07,039
mark sivans and this is going to be

664
00:24:07,039 --> 00:24:08,400
about submitting the middle attacks

665
00:24:08,400 --> 00:24:10,880
modeling permutations and quantum stuff

666
00:24:10,880 --> 00:24:13,200
so i have to unpack a bit here

667
00:24:13,200 --> 00:24:14,400
let's start

668
00:24:14,400 --> 00:24:16,400
with permutations

669
00:24:16,400 --> 00:24:18,240
so cryptographic permutations there is

670
00:24:18,240 --> 00:24:20,000
no key in this presentation there is no

671
00:24:20,000 --> 00:24:21,840
clear at all but we're still going to

672
00:24:21,840 --> 00:24:23,600
try to find a tax on that

673
00:24:23,600 --> 00:24:26,159
and our goal here is to find an input x

674
00:24:26,159 --> 00:24:27,840
which has some relation between the

675
00:24:27,840 --> 00:24:30,240
input x and the output p of x you could

676
00:24:30,240 --> 00:24:31,520
say for example

677
00:24:31,520 --> 00:24:32,960
i want to search a fixed point of this

678
00:24:32,960 --> 00:24:34,720
permutation if there is one and that

679
00:24:34,720 --> 00:24:36,960
means x equal p of x

680
00:24:36,960 --> 00:24:38,559
the way to solve it with the meat in the

681
00:24:38,559 --> 00:24:40,880
middle technique is to

682
00:24:40,880 --> 00:24:42,880
select two subsets of the internal

683
00:24:42,880 --> 00:24:44,559
states of the permutation

684
00:24:44,559 --> 00:24:47,200
one that's going to compute uh forwards

685
00:24:47,200 --> 00:24:48,640
the forward path

686
00:24:48,640 --> 00:24:50,000
and one that we're going to compute

687
00:24:50,000 --> 00:24:52,559
backwards the backward pass

688
00:24:52,559 --> 00:24:54,640
and um we're going to compute them

689
00:24:54,640 --> 00:24:56,400
independently so we take all the

690
00:24:56,400 --> 00:24:59,120
possibilities for this forward states by

691
00:24:59,120 --> 00:25:00,559
all the possibilities for these backward

692
00:25:00,559 --> 00:25:03,039
states you compute independently

693
00:25:03,039 --> 00:25:04,400
and then

694
00:25:04,400 --> 00:25:06,559
there are points at which this

695
00:25:06,559 --> 00:25:08,400
two subsets are going to match to two

696
00:25:08,400 --> 00:25:09,279
meets

697
00:25:09,279 --> 00:25:11,679
and we take all the possibilities all

698
00:25:11,679 --> 00:25:13,440
the pairs

699
00:25:13,440 --> 00:25:14,640
of possibilities which are going to

700
00:25:14,640 --> 00:25:16,640
match in this point

701
00:25:16,640 --> 00:25:19,039
and once we have something that matches

702
00:25:19,039 --> 00:25:20,799
we're going to recompute everything and

703
00:25:20,799 --> 00:25:23,120
to try to see for conditions all

704
00:25:23,120 --> 00:25:24,559
satisfied

705
00:25:24,559 --> 00:25:27,520
of course this works because uh there is

706
00:25:27,520 --> 00:25:29,520
uh this condition here which basically

707
00:25:29,520 --> 00:25:31,919
closes the computer the computational

708
00:25:31,919 --> 00:25:32,720
path

709
00:25:32,720 --> 00:25:34,159
of this permutation

710
00:25:34,159 --> 00:25:36,080
but this is broadly the the idea that we

711
00:25:36,080 --> 00:25:38,000
use

712
00:25:38,000 --> 00:25:40,559
um the application of course is to find

713
00:25:40,559 --> 00:25:42,480
pre-images on hash functions and the

714
00:25:42,480 --> 00:25:45,679
best example for this is haraka 512

715
00:25:45,679 --> 00:25:47,919
one of the permutations that we studied

716
00:25:47,919 --> 00:25:49,520
in in our paper

717
00:25:49,520 --> 00:25:51,039
because saraka is a hash function that

718
00:25:51,039 --> 00:25:52,640
is directly built on top of a

719
00:25:52,640 --> 00:25:53,840
permutation

720
00:25:53,840 --> 00:25:56,240
actually it only hashes inputs of 500

721
00:25:56,240 --> 00:25:57,600
bits

722
00:25:57,600 --> 00:25:59,919
for this version and the way it does it

723
00:25:59,919 --> 00:26:01,520
is simply it has a permutation which

724
00:26:01,520 --> 00:26:03,279
operates on five floor bits

725
00:26:03,279 --> 00:26:05,679
and it exhausts the output permutation

726
00:26:05,679 --> 00:26:06,880
to the input

727
00:26:06,880 --> 00:26:09,760
and then it truncates to 256 bits and

728
00:26:09,760 --> 00:26:11,840
then you have your your hash

729
00:26:11,840 --> 00:26:13,520
so of course finding a pre image of this

730
00:26:13,520 --> 00:26:15,520
for example a primitive zero this is

731
00:26:15,520 --> 00:26:17,200
exactly a meat in the middle problem you

732
00:26:17,200 --> 00:26:19,120
want to find an input x such that

733
00:26:19,120 --> 00:26:21,520
truncation of x equals truncation of p

734
00:26:21,520 --> 00:26:23,039
of x

735
00:26:23,039 --> 00:26:25,200
more generally this is going to happen

736
00:26:25,200 --> 00:26:26,559
when we have a compression function

737
00:26:26,559 --> 00:26:28,159
based on the block cipher

738
00:26:28,159 --> 00:26:31,200
and if we fix the input of the key

739
00:26:31,200 --> 00:26:33,279
inputs because on black cipher you have

740
00:26:33,279 --> 00:26:35,600
not only the input x but also an input

741
00:26:35,600 --> 00:26:38,400
key if you fix that you get permutation

742
00:26:38,400 --> 00:26:39,840
and so you could still apply the same

743
00:26:39,840 --> 00:26:42,240
techniques

744
00:26:42,480 --> 00:26:44,559
why do we care about quantum attacks

745
00:26:44,559 --> 00:26:46,799
well in the case of haraca

746
00:26:46,799 --> 00:26:48,320
actually the hash function has been

747
00:26:48,320 --> 00:26:50,240
explicitly designed to be used in close

748
00:26:50,240 --> 00:26:52,799
quantum digital signature schemes such

749
00:26:52,799 --> 00:26:54,559
as strengths plus

750
00:26:54,559 --> 00:26:56,159
so we're going to care of course about

751
00:26:56,159 --> 00:26:58,320
this classical security but at some

752
00:26:58,320 --> 00:27:00,480
point we have to ask the question of its

753
00:27:00,480 --> 00:27:02,320
quantum security

754
00:27:02,320 --> 00:27:04,720
the classical generic preimage

755
00:27:04,720 --> 00:27:07,039
attack on harika 512 would be in time

756
00:27:07,039 --> 00:27:09,360
for the 256 because you can search

757
00:27:09,360 --> 00:27:10,720
exhaustively

758
00:27:10,720 --> 00:27:12,559
um and we already know since you're

759
00:27:12,559 --> 00:27:15,760
21 uh by a paper by by which add that

760
00:27:15,760 --> 00:27:17,520
there is an attack because you can find

761
00:27:17,520 --> 00:27:20,080
a pre-image using a meat in the middle

762
00:27:20,080 --> 00:27:22,720
uh attack in less than that

763
00:27:22,720 --> 00:27:24,720
but then you could still argue that well

764
00:27:24,720 --> 00:27:27,039
okay there is a classical attack

765
00:27:27,039 --> 00:27:27,760
but

766
00:27:27,760 --> 00:27:29,279
it could still be safe against a

767
00:27:29,279 --> 00:27:31,200
mountain adversary because having a

768
00:27:31,200 --> 00:27:34,080
premature attack in time here to the 240

769
00:27:34,080 --> 00:27:35,360
does that mean that i have a quantum

770
00:27:35,360 --> 00:27:37,600
pre-match attack better than the generic

771
00:27:37,600 --> 00:27:39,919
one generic one is actually quite good

772
00:27:39,919 --> 00:27:41,520
because we have grover's segregated like

773
00:27:41,520 --> 00:27:43,440
modern setting and this one is in time

774
00:27:43,440 --> 00:27:45,279
to d128

775
00:27:45,279 --> 00:27:47,039
so to have a quantum premise attack i

776
00:27:47,039 --> 00:27:48,799
need to do better than that

777
00:27:48,799 --> 00:27:50,399
but actually in our paper we show that

778
00:27:50,399 --> 00:27:51,919
you can also do better than that in the

779
00:27:51,919 --> 00:27:54,320
column setting so you have a premature

780
00:27:54,320 --> 00:27:55,760
attack that runs better than grover

781
00:27:55,760 --> 00:27:59,120
search or higher perfectly

782
00:27:59,600 --> 00:28:00,880
um

783
00:28:00,880 --> 00:28:02,720
now meet in the middle attacks can

784
00:28:02,720 --> 00:28:05,360
become quite complicated um there are

785
00:28:05,360 --> 00:28:06,799
many techniques applicable if you

786
00:28:06,799 --> 00:28:08,880
combine all of this uh it can become

787
00:28:08,880 --> 00:28:10,240
quite difficult

788
00:28:10,240 --> 00:28:12,080
but um

789
00:28:12,080 --> 00:28:13,840
to search for this very complicated

790
00:28:13,840 --> 00:28:14,880
attacks

791
00:28:14,880 --> 00:28:17,679
what we can do now or try to do is to

792
00:28:17,679 --> 00:28:19,360
use an automatic tool

793
00:28:19,360 --> 00:28:21,600
now the idea is you're going to use some

794
00:28:21,600 --> 00:28:23,200
sort of modeling

795
00:28:23,200 --> 00:28:25,279
to to model the space of possible meet

796
00:28:25,279 --> 00:28:27,120
in the middle attacks

797
00:28:27,120 --> 00:28:28,960
and to search for the best one among

798
00:28:28,960 --> 00:28:31,440
them and this was originally proposed at

799
00:28:31,440 --> 00:28:34,000
record 21 in the same paper

800
00:28:34,000 --> 00:28:36,480
where the authors basically modeled the

801
00:28:36,480 --> 00:28:39,039
the ies-like compression functions i'm

802
00:28:39,039 --> 00:28:41,760
going to talk about this a bit later

803
00:28:41,760 --> 00:28:43,360
the idea is simply that you have a

804
00:28:43,360 --> 00:28:45,279
description of all possible forwards and

805
00:28:45,279 --> 00:28:47,760
backward paths which define completely

806
00:28:47,760 --> 00:28:48,880
the attack

807
00:28:48,880 --> 00:28:50,880
and now you try to find the best attack

808
00:28:50,880 --> 00:28:53,440
among all these possibilities

809
00:28:53,440 --> 00:28:54,880
now in this paper

810
00:28:54,880 --> 00:28:57,200
uh the possible backwards and forward

811
00:28:57,200 --> 00:28:59,279
but they were basically defined and

812
00:28:59,279 --> 00:29:02,159
constrained by a set of local rules and

813
00:29:02,159 --> 00:29:03,600
i'm not going to go into this details

814
00:29:03,600 --> 00:29:06,399
because we use a very different

815
00:29:06,399 --> 00:29:07,600
approach

816
00:29:07,600 --> 00:29:10,320
so modern strategy is actually specific

817
00:29:10,320 --> 00:29:12,080
for permutations

818
00:29:12,080 --> 00:29:13,279
so it's not

819
00:29:13,279 --> 00:29:14,399
it's not going to include the key

820
00:29:14,399 --> 00:29:15,840
schedules which was the case in the

821
00:29:15,840 --> 00:29:17,760
previous paper

822
00:29:17,760 --> 00:29:20,080
but it's actually allows to target a bit

823
00:29:20,080 --> 00:29:22,240
more than aes like permutations which is

824
00:29:22,240 --> 00:29:23,919
good

825
00:29:23,919 --> 00:29:25,200
and also

826
00:29:25,200 --> 00:29:26,799
the the model that we get out of it is

827
00:29:26,799 --> 00:29:28,399
actually extremely simple so that i can

828
00:29:28,399 --> 00:29:30,080
hope to present it

829
00:29:30,080 --> 00:29:32,320
uh during this presentation

830
00:29:32,320 --> 00:29:34,559
and um this modeling also includes

831
00:29:34,559 --> 00:29:36,240
quantum meet in the middle attacks hence

832
00:29:36,240 --> 00:29:38,159
the result of haircut that i just talked

833
00:29:38,159 --> 00:29:39,200
about

834
00:29:39,200 --> 00:29:41,279
and of course there are many that can

835
00:29:41,279 --> 00:29:43,440
apply it can be applied we applied it on

836
00:29:43,440 --> 00:29:45,440
many primitives you can select your best

837
00:29:45,440 --> 00:29:47,520
one out of the list but i'm gonna speak

838
00:29:47,520 --> 00:29:51,360
uh specifically about haraka here

839
00:29:51,679 --> 00:29:53,200
okay um

840
00:29:53,200 --> 00:29:54,640
so

841
00:29:54,640 --> 00:29:58,000
now i'm gonna start by explaining how we

842
00:29:58,000 --> 00:30:00,320
abstract out a permutation design

843
00:30:00,320 --> 00:30:02,399
specifically a substitution permutation

844
00:30:02,399 --> 00:30:03,760
network

845
00:30:03,760 --> 00:30:05,919
and and this is going to require first

846
00:30:05,919 --> 00:30:07,279
because the only thing we have to do

847
00:30:07,279 --> 00:30:09,840
here is basically throw away all the

848
00:30:09,840 --> 00:30:11,679
details we don't care about and keep

849
00:30:11,679 --> 00:30:13,039
only the structure the abstract

850
00:30:13,039 --> 00:30:15,760
structure that we need to use

851
00:30:15,760 --> 00:30:17,120
and then i'm going to explain how

852
00:30:17,120 --> 00:30:18,159
exactly

853
00:30:18,159 --> 00:30:19,679
the search is done

854
00:30:19,679 --> 00:30:20,960
on this meet in the middle attack and

855
00:30:20,960 --> 00:30:24,000
how we model this into milp

856
00:30:24,000 --> 00:30:26,159
and finally some examples on harca

857
00:30:26,159 --> 00:30:28,080
factory

858
00:30:28,080 --> 00:30:31,840
okay so we start with permutation design

859
00:30:31,840 --> 00:30:34,240
an spn permutation so a substitution

860
00:30:34,240 --> 00:30:36,559
permutation network it's like an spn

861
00:30:36,559 --> 00:30:39,120
cipher without a key

862
00:30:39,120 --> 00:30:42,399
and so but that's how it's uh usually

863
00:30:42,399 --> 00:30:43,760
it's represented

864
00:30:43,760 --> 00:30:46,480
with a state which is made of a certain

865
00:30:46,480 --> 00:30:48,799
number of sets

866
00:30:48,799 --> 00:30:51,039
let's say b cells of w bits so that will

867
00:30:51,039 --> 00:30:54,000
make a state of w times b bits

868
00:30:54,000 --> 00:30:57,039
and uh the round function operates

869
00:30:57,039 --> 00:30:59,519
with a nonlinear layer which applies as

870
00:30:59,519 --> 00:31:00,720
boxes

871
00:31:00,720 --> 00:31:03,039
independently to all the cells and a

872
00:31:03,039 --> 00:31:05,519
linear layer which applies a

873
00:31:05,519 --> 00:31:07,120
linear function

874
00:31:07,120 --> 00:31:08,000
now

875
00:31:08,000 --> 00:31:09,440
i'm going to

876
00:31:09,440 --> 00:31:11,760
focus on the example of present here

877
00:31:11,760 --> 00:31:13,440
actually this is not present it's a it's

878
00:31:13,440 --> 00:31:15,440
a small present because it had to fit in

879
00:31:15,440 --> 00:31:16,799
the side

880
00:31:16,799 --> 00:31:19,120
but present is actually it takes

881
00:31:19,120 --> 00:31:21,279
actually this uh linear layer which is

882
00:31:21,279 --> 00:31:24,720
the permutation layer um very literally

883
00:31:24,720 --> 00:31:26,480
because the linear layer only permeates

884
00:31:26,480 --> 00:31:29,279
the bits in the states

885
00:31:29,279 --> 00:31:31,679
so uh initially the state has 16 cells

886
00:31:31,679 --> 00:31:34,000
here it's going to have four sets to fit

887
00:31:34,000 --> 00:31:35,120
in my slide

888
00:31:35,120 --> 00:31:37,919
but uh this is the kind of design we'll

889
00:31:37,919 --> 00:31:39,600
we're focusing on

890
00:31:39,600 --> 00:31:41,679
so you have these xbox layers

891
00:31:41,679 --> 00:31:43,600
and during between these box layers it

892
00:31:43,600 --> 00:31:45,600
just permutes bits in the states

893
00:31:45,600 --> 00:31:47,600
but this is nice because you have a very

894
00:31:47,600 --> 00:31:50,559
like this is a graph basically

895
00:31:50,559 --> 00:31:52,159
and you have a very nice representation

896
00:31:52,159 --> 00:31:53,679
for the scheme

897
00:31:53,679 --> 00:31:55,919
unfortunately harakai is not based on

898
00:31:55,919 --> 00:31:56,960
present

899
00:31:56,960 --> 00:31:59,360
it's based on aes so here goes my nice

900
00:31:59,360 --> 00:32:03,440
representation and here comes the aes

901
00:32:03,440 --> 00:32:07,279
um as is basically the i guess the the

902
00:32:07,279 --> 00:32:10,000
most well-known block cipher out there

903
00:32:10,000 --> 00:32:11,760
and this time it has a state which is

904
00:32:11,760 --> 00:32:15,200
represented as a matrix of bytes

905
00:32:15,200 --> 00:32:18,399
so the xboxes operate on the bytes

906
00:32:18,399 --> 00:32:20,720
and the linear layer does two things

907
00:32:20,720 --> 00:32:23,360
first it permutes the bytes

908
00:32:23,360 --> 00:32:24,960
that's the shift flows operation and

909
00:32:24,960 --> 00:32:27,120
then it mixes so it applies a linear

910
00:32:27,120 --> 00:32:30,480
function on the columns of the matrix

911
00:32:30,480 --> 00:32:31,919
now this has nothing to do with my

912
00:32:31,919 --> 00:32:34,080
previous drawing

913
00:32:34,080 --> 00:32:36,559
but actually it does

914
00:32:36,559 --> 00:32:38,559
if i use the following technique

915
00:32:38,559 --> 00:32:41,360
the supers box which basically consists

916
00:32:41,360 --> 00:32:42,880
in putting together

917
00:32:42,880 --> 00:32:44,960
the xbox layer and the mixed columns of

918
00:32:44,960 --> 00:32:46,399
the previous rounds

919
00:32:46,399 --> 00:32:47,840
now i obtain

920
00:32:47,840 --> 00:32:49,120
basically

921
00:32:49,120 --> 00:32:51,679
a biggest box that operates on columns

922
00:32:51,679 --> 00:32:53,760
on 32 bits

923
00:32:53,760 --> 00:32:57,039
and between these layers of supers boxes

924
00:32:57,039 --> 00:32:58,880
the only thing that remains

925
00:32:58,880 --> 00:33:00,880
is the shift rows the permutation of the

926
00:33:00,880 --> 00:33:01,919
bytes

927
00:33:01,919 --> 00:33:04,720
so now i have a layer of surprise boxes

928
00:33:04,720 --> 00:33:07,120
followed by a permutation of bytes

929
00:33:07,120 --> 00:33:10,480
followed by a layer of super boxes etc

930
00:33:10,480 --> 00:33:13,200
so you know in our paper

931
00:33:13,200 --> 00:33:15,279
basically started from the present uh

932
00:33:15,279 --> 00:33:18,960
representation of these permutations and

933
00:33:18,960 --> 00:33:21,279
actually we could then include aes

934
00:33:21,279 --> 00:33:23,200
by basically i mean using the same

935
00:33:23,200 --> 00:33:25,039
representation

936
00:33:25,039 --> 00:33:28,480
so this is why i can focus on these nice

937
00:33:28,480 --> 00:33:29,519
graphs

938
00:33:29,519 --> 00:33:32,240
weighted graphs

939
00:33:32,720 --> 00:33:35,360
okay so now we get to the

940
00:33:35,360 --> 00:33:37,279
abstract representation of this spn

941
00:33:37,279 --> 00:33:38,960
permutation

942
00:33:38,960 --> 00:33:39,919
first of all if there are round

943
00:33:39,919 --> 00:33:41,279
constants there are one constants

944
00:33:41,279 --> 00:33:42,720
usually we just remove them we don't

945
00:33:42,720 --> 00:33:44,320
care about that

946
00:33:44,320 --> 00:33:45,279
and

947
00:33:45,279 --> 00:33:48,240
the x boxes uh of course they're still

948
00:33:48,240 --> 00:33:50,720
here they could be arbitrary functions

949
00:33:50,720 --> 00:33:52,799
we also don't really care

950
00:33:52,799 --> 00:33:55,519
um and we're gonna just i mean

951
00:33:55,519 --> 00:33:56,799
instead of writing the wrong function

952
00:33:56,799 --> 00:33:58,880
we're just gonna replace s box each s

953
00:33:58,880 --> 00:34:01,919
box by this cell here

954
00:34:01,919 --> 00:34:04,559
and we're gonna say that

955
00:34:04,559 --> 00:34:07,120
each cell is basically a small list

956
00:34:07,120 --> 00:34:09,679
which corresponds to the possible values

957
00:34:09,679 --> 00:34:11,599
that this s-box can take

958
00:34:11,599 --> 00:34:13,599
so here this is an s-box of four bits

959
00:34:13,599 --> 00:34:15,199
that's basically four bit inputs and

960
00:34:15,199 --> 00:34:17,119
four bit outputs so there are two to the

961
00:34:17,119 --> 00:34:19,760
four possible values here in this

962
00:34:19,760 --> 00:34:21,440
small list

963
00:34:21,440 --> 00:34:23,440
so now we have all this uh all these

964
00:34:23,440 --> 00:34:24,719
cells in our graph and they are

965
00:34:24,719 --> 00:34:26,960
connected by linear relations

966
00:34:26,960 --> 00:34:28,480
the goal

967
00:34:28,480 --> 00:34:30,560
uh the the thing we're trying to solve

968
00:34:30,560 --> 00:34:32,480
is basically to find an assignment of

969
00:34:32,480 --> 00:34:35,040
values to all these cells that satisfies

970
00:34:35,040 --> 00:34:37,599
all the linear relations in them

971
00:34:37,599 --> 00:34:38,879
and now i have removed practically

972
00:34:38,879 --> 00:34:40,800
everything and i just have a graph that

973
00:34:40,800 --> 00:34:43,040
remains and this is how this is what i

974
00:34:43,040 --> 00:34:44,480
input

975
00:34:44,480 --> 00:34:45,839
through to my code which is going to

976
00:34:45,839 --> 00:34:48,800
find the attack

977
00:34:48,800 --> 00:34:52,240
so now let's find the attack

978
00:34:54,079 --> 00:34:56,239
the we're going to define the following

979
00:34:56,239 --> 00:34:59,280
so this is just a fancy way of of

980
00:34:59,280 --> 00:35:01,760
of saying what i said at the beginning

981
00:35:01,760 --> 00:35:03,440
of this talk actually the meet in the

982
00:35:03,440 --> 00:35:05,280
middle technique is just computing

983
00:35:05,280 --> 00:35:06,880
something forwards computing something

984
00:35:06,880 --> 00:35:08,960
backwards and then trying to merge

985
00:35:08,960 --> 00:35:11,599
to to match uh between the two

986
00:35:11,599 --> 00:35:13,520
so we're going to define this i think we

987
00:35:13,520 --> 00:35:16,560
call it a reduced list it's if you take

988
00:35:16,560 --> 00:35:18,720
a set of cells in the graph there are

989
00:35:18,720 --> 00:35:20,960
some really some relations between them

990
00:35:20,960 --> 00:35:23,200
and you want to find all the assignments

991
00:35:23,200 --> 00:35:25,680
uh to these cells that satisfy other

992
00:35:25,680 --> 00:35:28,000
relations

993
00:35:28,000 --> 00:35:29,359
now the meat in the middle

994
00:35:29,359 --> 00:35:31,280
characteristic the whole attack is

995
00:35:31,280 --> 00:35:33,440
defined only but by three sets of sets

996
00:35:33,440 --> 00:35:35,839
and actually only two the one that

997
00:35:35,839 --> 00:35:38,880
defines the forward computational path

998
00:35:38,880 --> 00:35:40,320
the the one that defines the backward

999
00:35:40,320 --> 00:35:42,839
path and then the union of the

1000
00:35:42,839 --> 00:35:45,119
two there is also a small constraint

1001
00:35:45,119 --> 00:35:47,520
here because for the attack to to to

1002
00:35:47,520 --> 00:35:49,359
actually work the union of the two has

1003
00:35:49,359 --> 00:35:51,920
to cover around in the middle that's

1004
00:35:51,920 --> 00:35:53,920
just technical

1005
00:35:53,920 --> 00:35:55,119
okay

1006
00:35:55,119 --> 00:35:56,880
and what the attack does is simply

1007
00:35:56,880 --> 00:35:58,880
compute the forward path all the

1008
00:35:58,880 --> 00:36:00,560
possibilities for it compute the

1009
00:36:00,560 --> 00:36:02,240
backward path or the possibilities for

1010
00:36:02,240 --> 00:36:04,640
it and then try to match the path so

1011
00:36:04,640 --> 00:36:06,880
compute all the possibilities when you

1012
00:36:06,880 --> 00:36:08,640
take into account the relations between

1013
00:36:08,640 --> 00:36:11,680
the forward and backward sets

1014
00:36:11,680 --> 00:36:13,760
know i need to convince you that

1015
00:36:13,760 --> 00:36:15,760
for any choice of this forward and

1016
00:36:15,760 --> 00:36:17,680
backward sets there exists indeed an

1017
00:36:17,680 --> 00:36:19,599
algorithm that does this

1018
00:36:19,599 --> 00:36:21,599
and that has a time complexity that we

1019
00:36:21,599 --> 00:36:23,440
can compute

1020
00:36:23,440 --> 00:36:26,240
and this is going to be quite simple

1021
00:36:26,240 --> 00:36:29,359
let's uh have a look at the forward list

1022
00:36:29,359 --> 00:36:32,400
um again on my representation of a small

1023
00:36:32,400 --> 00:36:35,440
present like permutation

1024
00:36:35,440 --> 00:36:38,240
the forward list

1025
00:36:38,240 --> 00:36:39,760
is going to repeat it it's going to be

1026
00:36:39,760 --> 00:36:41,839
computed forwards

1027
00:36:41,839 --> 00:36:44,320
and what we do is simply the following i

1028
00:36:44,320 --> 00:36:47,359
arrive here at round zero and i need to

1029
00:36:47,359 --> 00:36:48,160
to

1030
00:36:48,160 --> 00:36:50,000
take a value for this cell

1031
00:36:50,000 --> 00:36:51,440
there are four bits here that i don't

1032
00:36:51,440 --> 00:36:54,000
know because i'm only starting so i take

1033
00:36:54,000 --> 00:36:56,240
four i mean i take four bits

1034
00:36:56,240 --> 00:36:58,400
i guess four bits now i have value for

1035
00:36:58,400 --> 00:36:59,520
this step

1036
00:36:59,520 --> 00:37:01,680
and then i can pass two bits to the next

1037
00:37:01,680 --> 00:37:03,359
cells because there are linear relations

1038
00:37:03,359 --> 00:37:04,640
here

1039
00:37:04,640 --> 00:37:06,320
so that's good i already know two bits

1040
00:37:06,320 --> 00:37:07,440
for the next one

1041
00:37:07,440 --> 00:37:08,880
but i need to

1042
00:37:08,880 --> 00:37:10,960
i mean i'm missing here three plus three

1043
00:37:10,960 --> 00:37:13,359
bits so i take values for them

1044
00:37:13,359 --> 00:37:15,520
and i continue like this round by round

1045
00:37:15,520 --> 00:37:17,760
and then at the end what did i do i

1046
00:37:17,760 --> 00:37:20,400
obtained basically only by guessing bits

1047
00:37:20,400 --> 00:37:22,720
i obtained the valid assignments

1048
00:37:22,720 --> 00:37:23,839
a valid

1049
00:37:23,839 --> 00:37:26,480
choice for the forward path

1050
00:37:26,480 --> 00:37:29,680
and you can see that the total

1051
00:37:29,680 --> 00:37:31,520
number of such valid assignments is

1052
00:37:31,520 --> 00:37:32,640
exactly

1053
00:37:32,640 --> 00:37:35,599
the sum of the weights so number of bits

1054
00:37:35,599 --> 00:37:36,960
of the cells

1055
00:37:36,960 --> 00:37:40,160
minus the sum of the the edges that they

1056
00:37:40,160 --> 00:37:41,440
are in the graph

1057
00:37:41,440 --> 00:37:43,119
in that case it will be 12 so i need to

1058
00:37:43,119 --> 00:37:46,960
guess 12 bits to obtain the value

1059
00:37:46,960 --> 00:37:48,720
that's the forward path

1060
00:37:48,720 --> 00:37:50,400
now for the backward path

1061
00:37:50,400 --> 00:37:52,560
i just do the same slides and i change

1062
00:37:52,560 --> 00:37:53,920
the colors

1063
00:37:53,920 --> 00:37:55,599
uh because we can do exactly the same

1064
00:37:55,599 --> 00:37:58,079
thing but in the other direction

1065
00:37:58,079 --> 00:38:00,800
now we go back uh if we want to find all

1066
00:38:00,800 --> 00:38:03,040
valid assignments for this four cells

1067
00:38:03,040 --> 00:38:05,680
here taking into account the relations

1068
00:38:05,680 --> 00:38:07,920
we just start from the last one and then

1069
00:38:07,920 --> 00:38:10,720
we go backwards round by rounds

1070
00:38:10,720 --> 00:38:13,359
each time guessing what we need

1071
00:38:13,359 --> 00:38:15,440
and of course in the end we can obtain

1072
00:38:15,440 --> 00:38:17,280
like this all the possible also

1073
00:38:17,280 --> 00:38:21,040
possibilities for the backward path

1074
00:38:21,839 --> 00:38:23,839
now we arrive at

1075
00:38:23,839 --> 00:38:25,520
the interesting

1076
00:38:25,520 --> 00:38:27,359
the interesting moment

1077
00:38:27,359 --> 00:38:29,520
the final

1078
00:38:29,520 --> 00:38:32,160
final step in the attack is to compute

1079
00:38:32,160 --> 00:38:34,480
all the posts of backward and forward

1080
00:38:34,480 --> 00:38:36,560
path which are going through to match

1081
00:38:36,560 --> 00:38:38,560
because you see this backwards and this

1082
00:38:38,560 --> 00:38:40,560
forward list here they are seeing each

1083
00:38:40,560 --> 00:38:42,480
other there are linear relations between

1084
00:38:42,480 --> 00:38:45,280
them which are supposed to be satisfied

1085
00:38:45,280 --> 00:38:47,599
so if i put them together here

1086
00:38:47,599 --> 00:38:49,839
in this example i have 12

1087
00:38:49,839 --> 00:38:52,640
bits of linear relations between them

1088
00:38:52,640 --> 00:38:55,119
and fortunately it is possible to

1089
00:38:55,119 --> 00:38:57,839
compute efficiently the list of births

1090
00:38:57,839 --> 00:39:00,079
of this backward and forward values

1091
00:39:00,079 --> 00:39:02,800
satisfying the new linear relations

1092
00:39:02,800 --> 00:39:05,040
that's merging the two lists

1093
00:39:05,040 --> 00:39:07,359
and the merge i mean the list of

1094
00:39:07,359 --> 00:39:10,160
assignments the merge list here is equal

1095
00:39:10,160 --> 00:39:11,280
to the

1096
00:39:11,280 --> 00:39:12,800
size of the forward time stars or

1097
00:39:12,800 --> 00:39:15,520
backwards divided by the amount of

1098
00:39:15,520 --> 00:39:18,880
linear relations that we match

1099
00:39:18,960 --> 00:39:20,160
so

1100
00:39:20,160 --> 00:39:22,640
we have an algorithm for the three i

1101
00:39:22,640 --> 00:39:24,079
mean that completes the meet in the

1102
00:39:24,079 --> 00:39:25,920
middle attack because now we

1103
00:39:25,920 --> 00:39:27,920
can really for each choice would just

1104
00:39:27,920 --> 00:39:30,079
recompute everything and check the rest

1105
00:39:30,079 --> 00:39:31,920
so we have an algorithm and this

1106
00:39:31,920 --> 00:39:34,320
algorithm depends only

1107
00:39:34,320 --> 00:39:37,680
on the sizes of the lists

1108
00:39:37,680 --> 00:39:39,839
and the sizes of the lists depend only

1109
00:39:39,839 --> 00:39:40,720
on

1110
00:39:40,720 --> 00:39:43,200
the choices of cells

1111
00:39:43,200 --> 00:39:46,000
so we have immediately for any choice of

1112
00:39:46,000 --> 00:39:46,960
cells

1113
00:39:46,960 --> 00:39:48,320
even a bad one

1114
00:39:48,320 --> 00:39:50,000
we have an attack

1115
00:39:50,000 --> 00:39:51,599
with a classical time complexity which

1116
00:39:51,599 --> 00:39:54,000
is going to give given by this

1117
00:39:54,000 --> 00:39:55,440
assuming that you first compute the

1118
00:39:55,440 --> 00:39:58,400
forward list and that's afterwards you

1119
00:39:58,400 --> 00:39:59,599
basically go through all the

1120
00:39:59,599 --> 00:40:01,440
possibilities for the backward path

1121
00:40:01,440 --> 00:40:04,079
that's a bit of technical point um and

1122
00:40:04,079 --> 00:40:05,119
in that case you need to store the

1123
00:40:05,119 --> 00:40:07,040
forward list so you have an algorithm

1124
00:40:07,040 --> 00:40:08,839
with these

1125
00:40:08,839 --> 00:40:11,359
complexities that's the classical attack

1126
00:40:11,359 --> 00:40:13,040
for the quantum attack

1127
00:40:13,040 --> 00:40:16,319
well we also have a quantum algorithm um

1128
00:40:16,319 --> 00:40:17,839
i'm not going to go into the details but

1129
00:40:17,839 --> 00:40:20,240
basically the chord algorithm it's it

1130
00:40:20,240 --> 00:40:22,480
looks like what the classical one except

1131
00:40:22,480 --> 00:40:23,280
that

1132
00:40:23,280 --> 00:40:25,920
um in the step when you go through the

1133
00:40:25,920 --> 00:40:27,760
backwards the choices for the backwards

1134
00:40:27,760 --> 00:40:29,839
and merged you can do that with grover

1135
00:40:29,839 --> 00:40:30,720
search

1136
00:40:30,720 --> 00:40:33,040
and so you get this nice uh square root

1137
00:40:33,040 --> 00:40:34,800
time speed up associated to grover

1138
00:40:34,800 --> 00:40:35,760
search

1139
00:40:35,760 --> 00:40:38,480
with some more technical details and the

1140
00:40:38,480 --> 00:40:40,319
quantum memory is also this

1141
00:40:40,319 --> 00:40:42,720
storage of a list

1142
00:40:42,720 --> 00:40:44,240
but what matters here is that i have

1143
00:40:44,240 --> 00:40:46,480
formulas that depend only on the choices

1144
00:40:46,480 --> 00:40:48,880
of backwards and forwards

1145
00:40:48,880 --> 00:40:50,800
so i have a search space all the

1146
00:40:50,800 --> 00:40:52,720
variables for the backwards i put

1147
00:40:52,720 --> 00:40:54,400
boolean variables for backwards and

1148
00:40:54,400 --> 00:40:55,680
forwards

1149
00:40:55,680 --> 00:40:58,800
and from them i can deduce the sizes of

1150
00:40:58,800 --> 00:41:02,079
the lists using only linear inequalities

1151
00:41:02,079 --> 00:41:04,480
and this is a modeling like this is a

1152
00:41:04,480 --> 00:41:05,920
mixed integer linear programming

1153
00:41:05,920 --> 00:41:07,359
basically

1154
00:41:07,359 --> 00:41:09,440
and from them i can deduce my objective

1155
00:41:09,440 --> 00:41:11,440
function which is the complexity of the

1156
00:41:11,440 --> 00:41:13,839
attack

1157
00:41:14,240 --> 00:41:15,920
there are some technical details but i'm

1158
00:41:15,920 --> 00:41:17,680
just quickly

1159
00:41:17,680 --> 00:41:21,440
throwing them here um i i presented a

1160
00:41:21,440 --> 00:41:23,839
very simple version actually to to get

1161
00:41:23,839 --> 00:41:25,760
really nice attacks you need to reduce

1162
00:41:25,760 --> 00:41:28,480
the memory use as much as possible

1163
00:41:28,480 --> 00:41:30,560
and this is done by

1164
00:41:30,560 --> 00:41:32,800
creating some

1165
00:41:32,800 --> 00:41:36,079
global some guesses inside the path

1166
00:41:36,079 --> 00:41:38,960
and they will naturally appear uh this

1167
00:41:38,960 --> 00:41:40,640
is basically precomp you can basically

1168
00:41:40,640 --> 00:41:42,160
pre-compute some matchings between the

1169
00:41:42,160 --> 00:41:44,240
backward and forward path

1170
00:41:44,240 --> 00:41:45,839
something which is also very important

1171
00:41:45,839 --> 00:41:48,400
for aes and also for haraka is that in

1172
00:41:48,400 --> 00:41:49,839
the aes case

1173
00:41:49,839 --> 00:41:51,040
this box

1174
00:41:51,040 --> 00:41:53,920
that uh you see here

1175
00:41:53,920 --> 00:41:55,680
it's actually

1176
00:41:55,680 --> 00:41:56,480
it's

1177
00:41:56,480 --> 00:41:58,000
it's actually a mixed content there is a

1178
00:41:58,000 --> 00:41:59,440
mixed content in there which is a linear

1179
00:41:59,440 --> 00:42:02,319
operation so actually the matching can

1180
00:42:02,319 --> 00:42:04,319
traverse a box even if you don't know

1181
00:42:04,319 --> 00:42:06,720
the value of this precise cell you can

1182
00:42:06,720 --> 00:42:08,319
go through it

1183
00:42:08,319 --> 00:42:10,240
that's really important but again i'm

1184
00:42:10,240 --> 00:42:11,280
not going to

1185
00:42:11,280 --> 00:42:13,359
uh detail that

1186
00:42:13,359 --> 00:42:14,560
okay let's see what this gives for

1187
00:42:14,560 --> 00:42:16,800
hierarchical f51

1188
00:42:16,800 --> 00:42:19,359
so harca 512 as i said is already broken

1189
00:42:19,359 --> 00:42:21,760
from eurocrypt21 actually this attack is

1190
00:42:21,760 --> 00:42:24,560
an attack on an extended version of it

1191
00:42:24,560 --> 00:42:28,079
and it runs in time to day 2014.

1192
00:42:28,079 --> 00:42:29,839
in our paper what we showed that we

1193
00:42:29,839 --> 00:42:31,280
didn't reduce the time complex skill

1194
00:42:31,280 --> 00:42:32,640
this attack but we showed that you could

1195
00:42:32,640 --> 00:42:35,599
reduce the memory complexity from 2d 128

1196
00:42:35,599 --> 00:42:37,839
to this 16.

1197
00:42:37,839 --> 00:42:39,839
now this is actually quite nice when we

1198
00:42:39,839 --> 00:42:41,599
go to the quantum setting

1199
00:42:41,599 --> 00:42:43,359
because if i give you a classical attack

1200
00:42:43,359 --> 00:42:45,440
which has a time to today

1201
00:42:45,440 --> 00:42:47,359
which at this time here at the memory

1202
00:42:47,359 --> 00:42:49,280
today 128

1203
00:42:49,280 --> 00:42:51,839
even if you apply grover search as much

1204
00:42:51,839 --> 00:42:53,040
as you can

1205
00:42:53,040 --> 00:42:54,079
um

1206
00:42:54,079 --> 00:42:55,599
grow resource is not going to reduce it

1207
00:42:55,599 --> 00:42:57,119
can reduce your time complexity

1208
00:42:57,119 --> 00:42:58,560
sometimes but it doesn't reduce your

1209
00:42:58,560 --> 00:43:00,000
memory complexity

1210
00:43:00,000 --> 00:43:02,079
so with this you couldn't hope to obtain

1211
00:43:02,079 --> 00:43:03,359
an attack

1212
00:43:03,359 --> 00:43:06,000
doing better than the quantum generic

1213
00:43:06,000 --> 00:43:07,119
one

1214
00:43:07,119 --> 00:43:09,280
but with the path that we obtained here

1215
00:43:09,280 --> 00:43:10,960
we can basically put a square root

1216
00:43:10,960 --> 00:43:12,800
complexity on the time and we don't have

1217
00:43:12,800 --> 00:43:15,040
this problem anymore and there of course

1218
00:43:15,040 --> 00:43:16,400
it's not exactly a square root and there

1219
00:43:16,400 --> 00:43:17,760
is some uh

1220
00:43:17,760 --> 00:43:19,200
some factor that goes in there but it's

1221
00:43:19,200 --> 00:43:21,119
basically what happens

1222
00:43:21,119 --> 00:43:23,839
i just wanted to talk a bit more of an

1223
00:43:23,839 --> 00:43:26,319
attack on five rounds exactly so just a

1224
00:43:26,319 --> 00:43:28,319
full version which is classical and in

1225
00:43:28,319 --> 00:43:30,720
time to be 224.

1226
00:43:30,720 --> 00:43:32,880
uh by the way this is how it looks like

1227
00:43:32,880 --> 00:43:35,440
um it's kind of a mess right

1228
00:43:35,440 --> 00:43:36,400
so

1229
00:43:36,400 --> 00:43:39,200
that's a representation of hareka as my

1230
00:43:39,200 --> 00:43:41,599
present like uh

1231
00:43:41,599 --> 00:43:44,319
as a present like permutation and

1232
00:43:44,319 --> 00:43:47,040
basically each each of these boxes here

1233
00:43:47,040 --> 00:43:48,720
is is a colon

1234
00:43:48,720 --> 00:43:51,359
and it's a big permutation it's actually

1235
00:43:51,359 --> 00:43:53,920
four aes states so you have like 16

1236
00:43:53,920 --> 00:43:55,119
columns

1237
00:43:55,119 --> 00:43:57,280
and of course there is then an exchange

1238
00:43:57,280 --> 00:43:59,200
of the bias which is a bit a bit messy

1239
00:43:59,200 --> 00:44:00,400
and it doesn't

1240
00:44:00,400 --> 00:44:02,640
print very nicely

1241
00:44:02,640 --> 00:44:04,640
but what matters here is that well the

1242
00:44:04,640 --> 00:44:07,359
path is extremely complicated and i can

1243
00:44:07,359 --> 00:44:08,800
assure you that i wouldn't have found it

1244
00:44:08,800 --> 00:44:10,000
by hand

1245
00:44:10,000 --> 00:44:11,200
it's kind of the point of using

1246
00:44:11,200 --> 00:44:13,440
automatic tools to uh to find this kind

1247
00:44:13,440 --> 00:44:15,520
of thing

1248
00:44:15,520 --> 00:44:17,599
this attack on five rounds uh runs in

1249
00:44:17,599 --> 00:44:19,839
time to date 224. i just wanted to

1250
00:44:19,839 --> 00:44:22,000
mention that

1251
00:44:22,000 --> 00:44:25,760
224 is quite large right as a complexity

1252
00:44:25,760 --> 00:44:27,440
but actually the attack is kind of

1253
00:44:27,440 --> 00:44:28,720
practical

1254
00:44:28,720 --> 00:44:30,880
um

1255
00:44:30,880 --> 00:44:34,319
in a certain sense because

1256
00:44:34,319 --> 00:44:35,760
because uh

1257
00:44:35,760 --> 00:44:38,000
what what you can observe uh is that

1258
00:44:38,000 --> 00:44:40,480
actually it has a very small memory and

1259
00:44:40,480 --> 00:44:42,480
it comes from the fact that

1260
00:44:42,480 --> 00:44:44,400
this full pre-image attack is actually a

1261
00:44:44,400 --> 00:44:46,000
partial pre-image attack that will

1262
00:44:46,000 --> 00:44:47,920
repeat many times

1263
00:44:47,920 --> 00:44:49,520
so instead of going for the full per

1264
00:44:49,520 --> 00:44:51,280
image what you can try to do is to go

1265
00:44:51,280 --> 00:44:53,280
for a threshold per image and this this

1266
00:44:53,280 --> 00:44:55,119
one is going to become practical you can

1267
00:44:55,119 --> 00:44:56,960
really observe it by hand

1268
00:44:56,960 --> 00:45:00,319
so um so what i did here is just uh so

1269
00:45:00,319 --> 00:45:02,880
compute something to to get 64-bit

1270
00:45:02,880 --> 00:45:04,319
partial pre-images instead of having a

1271
00:45:04,319 --> 00:45:07,200
full zero only have 64 bits to zero and

1272
00:45:07,200 --> 00:45:09,359
the attack runs in about time to the 32

1273
00:45:09,359 --> 00:45:12,000
and memory to 32 as well so it can run

1274
00:45:12,000 --> 00:45:13,680
on my laptop not exactly taking a

1275
00:45:13,680 --> 00:45:15,359
weekend a bit less than that

1276
00:45:15,359 --> 00:45:19,119
uh but um yeah this is a bit better than

1277
00:45:19,119 --> 00:45:22,560
doing today 64 computations

1278
00:45:22,560 --> 00:45:25,040
all right so just to conclude um i

1279
00:45:25,040 --> 00:45:27,200
wanted to stress the fact that modeling

1280
00:45:27,200 --> 00:45:28,640
this meeting the amino attacks it gets

1281
00:45:28,640 --> 00:45:30,839
really simple when we face

1282
00:45:30,839 --> 00:45:33,359
permutations and and also that these

1283
00:45:33,359 --> 00:45:34,720
attacks actually perform quite well in

1284
00:45:34,720 --> 00:45:36,640
the quantum setting we got up to a

1285
00:45:36,640 --> 00:45:40,799
quadratic speed up on some some of this

1286
00:45:40,880 --> 00:45:42,880
however of course this approach is

1287
00:45:42,880 --> 00:45:45,040
really tailored for permutations if you

1288
00:45:45,040 --> 00:45:47,119
have other degrees of freedom that come

1289
00:45:47,119 --> 00:45:49,040
from a key schedule it's much more

1290
00:45:49,040 --> 00:45:50,560
difficult and it's an important and

1291
00:45:50,560 --> 00:45:52,160
interesting open question

1292
00:45:52,160 --> 00:45:53,440
so you can find the food version the

1293
00:45:53,440 --> 00:45:55,760
paper only prints and the code on github

1294
00:45:55,760 --> 00:45:59,640
and thank you for attention

1295
00:46:03,680 --> 00:46:05,599
thank you andre are there any questions

1296
00:46:05,599 --> 00:46:08,480
in the room or in zoom

1297
00:46:12,319 --> 00:46:13,760
i have a

1298
00:46:13,760 --> 00:46:15,359
when do you think it would be uh

1299
00:46:15,359 --> 00:46:17,200
possible to adapt the tool to take into

1300
00:46:17,200 --> 00:46:19,680
account bike leaks for instance or even

1301
00:46:19,680 --> 00:46:21,839
the middle for the matching have you had

1302
00:46:21,839 --> 00:46:23,839
a look at that

1303
00:46:23,839 --> 00:46:27,200
so by clicks i don't really know um

1304
00:46:27,200 --> 00:46:29,680
the sieve in the middle

1305
00:46:29,680 --> 00:46:31,200
uh so far i'm getting the impression

1306
00:46:31,200 --> 00:46:34,240
that um it can be somehow

1307
00:46:34,240 --> 00:46:36,480
uh handled i'm working on this at the

1308
00:46:36,480 --> 00:46:38,720
moment so basically the sieve in the

1309
00:46:38,720 --> 00:46:40,960
middle is something where

1310
00:46:40,960 --> 00:46:42,880
uh you're you're attacking a so you're

1311
00:46:42,880 --> 00:46:44,400
doing a key recovery attack right you're

1312
00:46:44,400 --> 00:46:46,319
attacking presents and you're remarking

1313
00:46:46,319 --> 00:46:47,119
that

1314
00:46:47,119 --> 00:46:48,960
um

1315
00:46:48,960 --> 00:46:50,640
if you know if you know multiple edges

1316
00:46:50,640 --> 00:46:52,560
here and multiple edges here like two

1317
00:46:52,560 --> 00:46:54,400
here and three here you can have some

1318
00:46:54,400 --> 00:46:56,560
matching also in the middle i think this

1319
00:46:56,560 --> 00:46:59,119
is more or less um at least partially

1320
00:46:59,119 --> 00:47:01,520
covered uh by making some kind of

1321
00:47:01,520 --> 00:47:03,680
guesses so like

1322
00:47:03,680 --> 00:47:05,599
by um sorry about some kind of guess and

1323
00:47:05,599 --> 00:47:07,599
determine technique which is partially

1324
00:47:07,599 --> 00:47:09,440
covered by this framework

1325
00:47:09,440 --> 00:47:12,000
but i must say that this is uh ongoing

1326
00:47:12,000 --> 00:47:13,599
work

1327
00:47:13,599 --> 00:47:14,480
thanks

1328
00:47:14,480 --> 00:47:17,839
are there any more questions

1329
00:47:19,839 --> 00:47:21,680
okay then if there are no more questions

1330
00:47:21,680 --> 00:47:23,520
let's thank andre again thank you very

1331
00:47:23,520 --> 00:47:25,839
much

1332
00:48:29,760 --> 00:48:32,760
and

1333
00:48:34,240 --> 00:48:36,319
okay thanks so the next talk is

1334
00:48:36,319 --> 00:48:38,240
construction and and the constructing

1335
00:48:38,240 --> 00:48:39,839
intentional weaknesses and symmetric

1336
00:48:39,839 --> 00:48:41,040
ciphers and the talk is given by

1337
00:48:41,040 --> 00:48:44,040
gregoriano

1338
00:48:52,640 --> 00:48:53,910
so this is joint work

1339
00:48:53,910 --> 00:48:55,440
[Music]

1340
00:48:55,440 --> 00:48:57,200
with christopher

1341
00:48:57,200 --> 00:48:59,680
tim and patrick

1342
00:48:59,680 --> 00:49:01,119
so

1343
00:49:01,119 --> 00:49:02,640
as an introduction

1344
00:49:02,640 --> 00:49:04,160
we think that

1345
00:49:04,160 --> 00:49:05,440
backdoors or

1346
00:49:05,440 --> 00:49:07,680
intentional weaknesses which is i think

1347
00:49:07,680 --> 00:49:09,680
overlapping and

1348
00:49:09,680 --> 00:49:10,800
objects

1349
00:49:10,800 --> 00:49:12,160
an interesting

1350
00:49:12,160 --> 00:49:14,839
research problem and an

1351
00:49:14,839 --> 00:49:17,440
interesting topic in many dimensions

1352
00:49:17,440 --> 00:49:19,200
yeah so it's a politically interesting

1353
00:49:19,200 --> 00:49:21,680
it's interesting because we saw these

1354
00:49:21,680 --> 00:49:24,240
things being deployed and

1355
00:49:24,240 --> 00:49:26,559
our main point is it's also interesting

1356
00:49:26,559 --> 00:49:28,400
from an academic view

1357
00:49:28,400 --> 00:49:31,839
and maybe one important disclaimer so we

1358
00:49:31,839 --> 00:49:34,800
think it's bad yeah so and i hope it's

1359
00:49:34,800 --> 00:49:37,200
clear without saying this but i i i

1360
00:49:37,200 --> 00:49:39,359
thought that i better make it clear so

1361
00:49:39,359 --> 00:49:41,520
our main point is not

1362
00:49:41,520 --> 00:49:43,760
to advertise for

1363
00:49:43,760 --> 00:49:45,839
deploying vectors but

1364
00:49:45,839 --> 00:49:48,480
understand and then prevent it

1365
00:49:48,480 --> 00:49:49,920
okay

1366
00:49:49,920 --> 00:49:52,960
so there are many different flavors

1367
00:49:52,960 --> 00:49:56,000
of bacters and they have different

1368
00:49:56,000 --> 00:49:58,079
you can have very different um

1369
00:49:58,079 --> 00:50:00,000
properties and i'm not going to define

1370
00:50:00,000 --> 00:50:01,280
this um

1371
00:50:01,280 --> 00:50:02,800
precisely in

1372
00:50:02,800 --> 00:50:05,280
in the talk but just give you an idea

1373
00:50:05,280 --> 00:50:07,200
what i mean so

1374
00:50:07,200 --> 00:50:09,280
so the the main

1375
00:50:09,280 --> 00:50:10,480
the main

1376
00:50:10,480 --> 00:50:12,480
properties that we were interested in is

1377
00:50:12,480 --> 00:50:14,720
in undetectability which means you will

1378
00:50:14,720 --> 00:50:16,559
not find the vector no otherwise it's

1379
00:50:16,559 --> 00:50:18,720
not a good background

1380
00:50:18,720 --> 00:50:22,000
untraceability um means that if somebody

1381
00:50:22,000 --> 00:50:24,400
uses the vector you're not able to tell

1382
00:50:24,400 --> 00:50:26,960
so that's more the case if

1383
00:50:26,960 --> 00:50:29,119
if you think for a for example of a

1384
00:50:29,119 --> 00:50:31,119
tweakable

1385
00:50:31,119 --> 00:50:33,200
block cipher and maybe there's a special

1386
00:50:33,200 --> 00:50:36,000
tweak which makes the cipher weak

1387
00:50:36,000 --> 00:50:38,079
then even if somebody uses this special

1388
00:50:38,079 --> 00:50:40,079
tweak you shouldn't be able to tell that

1389
00:50:40,079 --> 00:50:42,480
this was the special tweak which made

1390
00:50:42,480 --> 00:50:44,319
the uh

1391
00:50:44,319 --> 00:50:46,319
vector which activated the vector and it

1392
00:50:46,319 --> 00:50:47,839
should be practical

1393
00:50:47,839 --> 00:50:49,520
meaning that if

1394
00:50:49,520 --> 00:50:51,359
you use the vector then you are able to

1395
00:50:51,359 --> 00:50:53,599
practically break the scheme

1396
00:50:53,599 --> 00:50:55,119
otherwise it's not

1397
00:50:55,119 --> 00:50:57,760
much worse and if you actually achieve

1398
00:50:57,760 --> 00:50:58,800
all these

1399
00:50:58,800 --> 00:51:00,480
properties then you basically get a

1400
00:51:00,480 --> 00:51:02,559
public key

1401
00:51:02,559 --> 00:51:04,960
and we don't so we aim at less

1402
00:51:04,960 --> 00:51:06,079
but

1403
00:51:06,079 --> 00:51:07,760
it's interesting

1404
00:51:07,760 --> 00:51:10,319
approach to public health

1405
00:51:10,319 --> 00:51:12,079
okay yeah and what we are not achieving

1406
00:51:12,079 --> 00:51:14,240
maybe i should say you're not see uh

1407
00:51:14,240 --> 00:51:15,599
achieving this untreated uh

1408
00:51:15,599 --> 00:51:18,240
untraceability so our vectors once used

1409
00:51:18,240 --> 00:51:21,118
are kind of revealed

1410
00:51:21,359 --> 00:51:23,520
and we have two in the the paper is two

1411
00:51:23,520 --> 00:51:25,920
two four two contributions uh one is

1412
00:51:25,920 --> 00:51:27,680
deconstructing and there we look at the

1413
00:51:27,680 --> 00:51:30,480
ga1 algorithm i'll briefly recall what

1414
00:51:30,480 --> 00:51:31,440
this is

1415
00:51:31,440 --> 00:51:34,480
and explain how this vector and or maybe

1416
00:51:34,480 --> 00:51:37,119
more intentional and weakness was built

1417
00:51:37,119 --> 00:51:39,760
what we think it has been built

1418
00:51:39,760 --> 00:51:42,800
and we are going to explain ways

1419
00:51:42,800 --> 00:51:44,400
following the malicious framework how

1420
00:51:44,400 --> 00:51:45,520
you can

1421
00:51:45,520 --> 00:51:48,000
actually build nice what i think is nice

1422
00:51:48,000 --> 00:51:50,000
and natural looking

1423
00:51:50,000 --> 00:51:51,680
block cypher tweakable rock surface with

1424
00:51:51,680 --> 00:51:53,040
a backpost

1425
00:51:53,040 --> 00:51:55,119
okay i'll start with

1426
00:51:55,119 --> 00:51:57,520
the the constructive part

1427
00:51:57,520 --> 00:51:58,480
and

1428
00:51:58,480 --> 00:51:59,920
namely

1429
00:51:59,920 --> 00:52:02,079
um how to build speakable block ciphers

1430
00:52:02,079 --> 00:52:04,400
with the vector yeah and this is uh we

1431
00:52:04,400 --> 00:52:06,480
build up on uh work

1432
00:52:06,480 --> 00:52:08,400
on this malicious framework

1433
00:52:08,400 --> 00:52:11,280
uh from crypto 2020

1434
00:52:11,280 --> 00:52:13,839
and there the idea is that it's a trick

1435
00:52:13,839 --> 00:52:16,319
with block cipher and without getting

1436
00:52:16,319 --> 00:52:18,640
any giving any details there there are

1437
00:52:18,640 --> 00:52:21,119
tweaks to a pair of tweaks two specific

1438
00:52:21,119 --> 00:52:23,680
tweaks and if you use them then you will

1439
00:52:23,680 --> 00:52:25,920
find the probability one differential

1440
00:52:25,920 --> 00:52:28,400
and then you can use this to recover the

1441
00:52:28,400 --> 00:52:29,200
key

1442
00:52:29,200 --> 00:52:30,800
so this is the idea

1443
00:52:30,800 --> 00:52:33,119
and it's good in the way that the way

1444
00:52:33,119 --> 00:52:35,280
they do it because they has the tweaks

1445
00:52:35,280 --> 00:52:38,160
it's undetectable so you you will not be

1446
00:52:38,160 --> 00:52:39,280
able to find the backdoor and it's

1447
00:52:39,280 --> 00:52:42,319
practical leading to practical attacks

1448
00:52:42,319 --> 00:52:45,040
uh it has also some

1449
00:52:45,040 --> 00:52:47,119
downsides and this is why we i think

1450
00:52:47,119 --> 00:52:48,880
it's worth looking at

1451
00:52:48,880 --> 00:52:51,440
into it again namely it's very

1452
00:52:51,440 --> 00:52:53,520
non-natural yeah so

1453
00:52:53,520 --> 00:52:55,200
they start with

1454
00:52:55,200 --> 00:52:56,720
these tweaks and basically have to

1455
00:52:56,720 --> 00:52:58,319
modify the round function the linear

1456
00:52:58,319 --> 00:53:00,960
layer of this round function in order to

1457
00:53:00,960 --> 00:53:03,520
to be able to to make sure that this

1458
00:53:03,520 --> 00:53:05,440
differential is probability one so they

1459
00:53:05,440 --> 00:53:07,680
have to basically choose a random linear

1460
00:53:07,680 --> 00:53:08,800
layer

1461
00:53:08,800 --> 00:53:10,960
for the round function for the linear

1462
00:53:10,960 --> 00:53:11,839
layout

1463
00:53:11,839 --> 00:53:13,680
of the cipher and this means you you

1464
00:53:13,680 --> 00:53:16,960
look into low mc in cyphers which is a

1465
00:53:16,960 --> 00:53:19,119
cipher which has its corner to exist but

1466
00:53:19,119 --> 00:53:22,240
it's not the natural and

1467
00:53:22,240 --> 00:53:24,800
general purpose block server

1468
00:53:24,800 --> 00:53:27,599
okay and our idea is basically to to not

1469
00:53:27,599 --> 00:53:29,920
to do the same thing but not build a

1470
00:53:29,920 --> 00:53:31,920
probability one differential attack but

1471
00:53:31,920 --> 00:53:33,200
try to build

1472
00:53:33,200 --> 00:53:34,800
um

1473
00:53:34,800 --> 00:53:36,000
and

1474
00:53:36,000 --> 00:53:37,280
the weakness

1475
00:53:37,280 --> 00:53:41,280
on invariance instead of differentials

1476
00:53:41,280 --> 00:53:43,040
and here is what we do we we have two

1477
00:53:43,040 --> 00:53:44,960
examples one is based on aes and i'm

1478
00:53:44,960 --> 00:53:46,480
only going to explain this one and then

1479
00:53:46,480 --> 00:53:47,599
we have another one which is more

1480
00:53:47,599 --> 00:53:49,280
involved and

1481
00:53:49,280 --> 00:53:50,559
i i

1482
00:53:50,559 --> 00:53:52,000
think it's interesting if you're

1483
00:53:52,000 --> 00:53:53,760
interested you should have a look

1484
00:53:53,760 --> 00:53:55,520
so there's one

1485
00:53:55,520 --> 00:53:57,599
a yes and things and so andre i don't

1486
00:53:57,599 --> 00:54:00,079
have to explain and i hope anyway i

1487
00:54:00,079 --> 00:54:01,920
guess if you not don't know how as works

1488
00:54:01,920 --> 00:54:05,520
then you may be in the wrong session so

1489
00:54:05,520 --> 00:54:07,760
and there's a there's an invariant space

1490
00:54:07,760 --> 00:54:10,240
namely if you take an aes space and you

1491
00:54:10,240 --> 00:54:12,160
you put the first and the third column

1492
00:54:12,160 --> 00:54:14,480
to the same value and the second and the

1493
00:54:14,480 --> 00:54:16,079
fourth columns have the same value then

1494
00:54:16,079 --> 00:54:17,920
this is not going to change through the

1495
00:54:17,920 --> 00:54:19,839
wrong function yeah so if you apply some

1496
00:54:19,839 --> 00:54:21,359
bytes this is clearly not going to

1497
00:54:21,359 --> 00:54:24,079
change if you apply the rows and you

1498
00:54:24,079 --> 00:54:25,680
check carefully check it's not going to

1499
00:54:25,680 --> 00:54:27,200
change and for mixed column it's not

1500
00:54:27,200 --> 00:54:29,040
going to change because if you input the

1501
00:54:29,040 --> 00:54:30,559
same colors i'm going to output the same

1502
00:54:30,559 --> 00:54:31,760
colors

1503
00:54:31,760 --> 00:54:32,559
okay

1504
00:54:32,559 --> 00:54:35,200
and so why is this not breaking a s it's

1505
00:54:35,200 --> 00:54:37,680
not breaking a yes because if you add a

1506
00:54:37,680 --> 00:54:38,480
key

1507
00:54:38,480 --> 00:54:41,040
then automatically this

1508
00:54:41,040 --> 00:54:42,720
is going to be destroyed with super high

1509
00:54:42,720 --> 00:54:45,119
probability yeah for one round it's very

1510
00:54:45,119 --> 00:54:46,960
unlikely and for more rounds it's just

1511
00:54:46,960 --> 00:54:48,960
not going to happen okay so this is why

1512
00:54:48,960 --> 00:54:50,480
yes

1513
00:54:50,480 --> 00:54:52,480
now we wanted to have a weak cipher so

1514
00:54:52,480 --> 00:54:54,960
it's very easy to to get that weak we

1515
00:54:54,960 --> 00:54:57,119
just modify the key scalar so we the

1516
00:54:57,119 --> 00:54:59,119
first change we do is we modify the key

1517
00:54:59,119 --> 00:55:01,680
scattering and

1518
00:55:01,680 --> 00:55:03,520
so you take a key scheduling and i'm not

1519
00:55:03,520 --> 00:55:05,520
going to explain you what exactly we do

1520
00:55:05,520 --> 00:55:07,680
but the main point is you only output

1521
00:55:07,680 --> 00:55:10,160
symmetric um keys

1522
00:55:10,160 --> 00:55:11,599
so you have a

1523
00:55:11,599 --> 00:55:13,280
key so each

1524
00:55:13,280 --> 00:55:15,119
round key is only 64 bits but it doesn't

1525
00:55:15,119 --> 00:55:16,799
matter if you have enough rounds it's

1526
00:55:16,799 --> 00:55:19,440
not not a big issue so also the round

1527
00:55:19,440 --> 00:55:21,520
keys are like the first first column

1528
00:55:21,520 --> 00:55:23,280
equals the third column and the second

1529
00:55:23,280 --> 00:55:25,280
column is equal to the first column

1530
00:55:25,280 --> 00:55:27,040
and with this

1531
00:55:27,040 --> 00:55:29,040
you now get um

1532
00:55:29,040 --> 00:55:31,520
an invariance and weakness which works

1533
00:55:31,520 --> 00:55:33,440
for any number of rounds so this cypher

1534
00:55:33,440 --> 00:55:34,960
is weak i'm just going to explain you

1535
00:55:34,960 --> 00:55:36,960
how to how to use this turn this into a

1536
00:55:36,960 --> 00:55:39,440
key recovery that you can do no

1537
00:55:39,440 --> 00:55:41,520
so you get the weak cycle okay but now

1538
00:55:41,520 --> 00:55:45,200
the problem is we have a big cipher that

1539
00:55:45,200 --> 00:55:47,680
is weak always so we have to make sure

1540
00:55:47,680 --> 00:55:49,520
that it's weak only

1541
00:55:49,520 --> 00:55:52,240
for the tweak the vector that we want to

1542
00:55:52,240 --> 00:55:53,200
um

1543
00:55:53,200 --> 00:55:54,640
to embed

1544
00:55:54,640 --> 00:55:57,680
so the second thing is we add a tweet

1545
00:55:57,680 --> 00:55:59,440
and so there's one thing so you take a

1546
00:55:59,440 --> 00:56:02,640
tweak t0 you fix it you randomly choose

1547
00:56:02,640 --> 00:56:04,400
it and then you hash it and this hashing

1548
00:56:04,400 --> 00:56:06,400
is basically

1549
00:56:06,400 --> 00:56:08,160
the idea in malicious framework how to

1550
00:56:08,160 --> 00:56:09,359
make sure that you cannot find the

1551
00:56:09,359 --> 00:56:10,799
vector

1552
00:56:10,799 --> 00:56:12,799
now you hash it and then you get as an

1553
00:56:12,799 --> 00:56:14,839
output a spring which is just long

1554
00:56:14,839 --> 00:56:18,319
enough so imagine this is

1555
00:56:18,319 --> 00:56:20,160
long enough and then long enough meaning

1556
00:56:20,160 --> 00:56:25,280
that we take for each round we take 64

1557
00:56:25,280 --> 00:56:29,280
yes 64 bits yeah two columns

1558
00:56:29,280 --> 00:56:32,160
of this of this hash as the

1559
00:56:32,160 --> 00:56:34,559
round tweak

1560
00:56:34,559 --> 00:56:37,440
okay and for the for the rest of the the

1561
00:56:37,440 --> 00:56:39,440
remaining columns of the uh round tweak

1562
00:56:39,440 --> 00:56:42,160
is just zero all the time and then

1563
00:56:42,160 --> 00:56:44,240
given uh this this this tweak we're

1564
00:56:44,240 --> 00:56:46,079
going to choose the constants yeah so

1565
00:56:46,079 --> 00:56:47,599
there will be wrong constants like in

1566
00:56:47,599 --> 00:56:49,599
any good cipher there should be wrong

1567
00:56:49,599 --> 00:56:50,960
constants and we choose the wrong

1568
00:56:50,960 --> 00:56:53,839
constant so that the sum of the tweak

1569
00:56:53,839 --> 00:56:57,040
and the wrong constants are symmetrical

1570
00:56:57,040 --> 00:56:59,920
okay so

1571
00:56:59,920 --> 00:57:02,000
what happens is you start with this

1572
00:57:02,000 --> 00:57:03,760
symmetric state you apply all these

1573
00:57:03,760 --> 00:57:05,119
round functions you get the symmetric

1574
00:57:05,119 --> 00:57:07,520
state you add the symmetric key

1575
00:57:07,520 --> 00:57:10,000
you get the symmetric state and now

1576
00:57:10,000 --> 00:57:11,680
comes the

1577
00:57:11,680 --> 00:57:12,880
tweak

1578
00:57:12,880 --> 00:57:14,720
so you take this tweak you hash it and

1579
00:57:14,720 --> 00:57:17,440
because the tweak is t0 this thing is

1580
00:57:17,440 --> 00:57:18,559
symmetric

1581
00:57:18,559 --> 00:57:22,079
and you get uh cipher which is

1582
00:57:22,079 --> 00:57:23,520
which is

1583
00:57:23,520 --> 00:57:25,760
symmetric so it can be broken practical

1584
00:57:25,760 --> 00:57:28,799
for the tweak sorry for the tweak t0 and

1585
00:57:28,799 --> 00:57:30,240
now what happens if you take a different

1586
00:57:30,240 --> 00:57:32,720
tweak if you have a different tweak then

1587
00:57:32,720 --> 00:57:34,319
this is going to not fit to the wrong

1588
00:57:34,319 --> 00:57:36,559
constant now just basically because of

1589
00:57:36,559 --> 00:57:37,920
the hashing you need the random values

1590
00:57:37,920 --> 00:57:39,760
here and so the probability that this

1591
00:57:39,760 --> 00:57:42,000
one is symmetric again it's super small

1592
00:57:42,000 --> 00:57:43,599
and so you get something which is not

1593
00:57:43,599 --> 00:57:47,040
secure which is not um

1594
00:57:47,040 --> 00:57:48,799
weak except

1595
00:57:48,799 --> 00:57:52,160
if you input t0 and nobody knows t0 so

1596
00:57:52,160 --> 00:57:54,319
that's achieves what we want yeah so

1597
00:57:54,319 --> 00:57:56,319
it's undetectable nobody will be able to

1598
00:57:56,319 --> 00:57:57,760
find this t0

1599
00:57:57,760 --> 00:58:00,480
um and it's practical i don't exactly

1600
00:58:00,480 --> 00:58:02,319
explain how it's practical but you see

1601
00:58:02,319 --> 00:58:04,799
that the weakness is strong

1602
00:58:04,799 --> 00:58:06,640
okay

1603
00:58:06,640 --> 00:58:09,280
so this uh maybe it's not

1604
00:58:09,280 --> 00:58:11,040
super surprising

1605
00:58:11,040 --> 00:58:12,960
um we have yeah as i said we have

1606
00:58:12,960 --> 00:58:14,880
something called boom sla

1607
00:58:14,880 --> 00:58:16,640
i'm not even sure i pronounce this

1608
00:58:16,640 --> 00:58:18,960
correctly

1609
00:58:18,960 --> 00:58:21,440
tim's uh

1610
00:58:21,440 --> 00:58:22,720
pointed like this

1611
00:58:22,720 --> 00:58:25,920
and so this i think is so the the aes

1612
00:58:25,920 --> 00:58:27,599
variant everybody will will be able to

1613
00:58:27,599 --> 00:58:30,559
tell so this is foreclosing well-known

1614
00:58:30,559 --> 00:58:33,280
weakness but this one uses um

1615
00:58:33,280 --> 00:58:34,720
a nonlinear invariant over two

1616
00:58:34,720 --> 00:58:36,960
consecutive rounds and it's hard to

1617
00:58:36,960 --> 00:58:39,280
detect how to detect in the sense that

1618
00:58:39,280 --> 00:58:40,960
we don't have automatic tools to find

1619
00:58:40,960 --> 00:58:42,480
these weaknesses yeah maybe we could

1620
00:58:42,480 --> 00:58:44,720
build but for now i mean

1621
00:58:44,720 --> 00:58:47,280
it's really hard to to detect

1622
00:58:47,280 --> 00:58:50,400
so um yeah so the this shows that they

1623
00:58:50,400 --> 00:58:52,880
are known for the uh versions and so the

1624
00:58:52,880 --> 00:58:54,000
same thing

1625
00:58:54,000 --> 00:58:55,280
okay

1626
00:58:55,280 --> 00:58:58,079
so that was for the first part

1627
00:58:58,079 --> 00:59:00,559
and now let me come to the ga1 the

1628
00:59:00,559 --> 00:59:03,060
deconstructing um

1629
00:59:03,060 --> 00:59:04,480
[Music]

1630
00:59:04,480 --> 00:59:06,000
weaknesses

1631
00:59:06,000 --> 00:59:08,480
so ga1 is this no actually it's not this

1632
00:59:08,480 --> 00:59:10,480
because it's for all phones yeah so it's

1633
00:59:10,480 --> 00:59:13,440
uh was used in

1634
00:59:13,440 --> 00:59:15,040
in

1635
00:59:15,040 --> 00:59:16,400
in former

1636
00:59:16,400 --> 00:59:19,119
versions of of

1637
00:59:19,119 --> 00:59:20,960
gpes

1638
00:59:20,960 --> 00:59:24,079
for the data encryption of mobile phones

1639
00:59:24,079 --> 00:59:25,119
okay and

1640
00:59:25,119 --> 00:59:26,799
it is actually a

1641
00:59:26,799 --> 00:59:28,160
stream cipher

1642
00:59:28,160 --> 00:59:30,079
which takes a

1643
00:59:30,079 --> 00:59:33,920
64-bit key and has a 96-bit internal

1644
00:59:33,920 --> 00:59:36,960
state and this was not public but

1645
00:59:36,960 --> 00:59:38,400
at some point

1646
00:59:38,400 --> 00:59:40,640
last year at eurocrypt

1647
00:59:40,640 --> 00:59:42,319
it was published and there was a

1648
00:59:42,319 --> 00:59:43,599
weakness

1649
00:59:43,599 --> 00:59:45,760
i mean it was broken and where how was

1650
00:59:45,760 --> 00:59:49,200
it broken it's broken because if after

1651
00:59:49,200 --> 00:59:51,359
the initialization phase

1652
00:59:51,359 --> 00:59:53,280
and the the joint state of this register

1653
00:59:53,280 --> 00:59:56,720
a and c which together has 64 bits

1654
00:59:56,720 --> 00:59:58,720
so it could have after initialization it

1655
00:59:58,720 --> 01:00:01,119
should have all close to all possible 2

1656
01:00:01,119 --> 01:00:03,440
to the 64 possibilities if you run to

1657
01:00:03,440 --> 01:00:07,040
the possible 264 keys but it doesn't you

1658
01:00:07,040 --> 01:00:09,680
only get 2 to the 40.

1659
01:00:09,680 --> 01:00:12,000
so um and then the attack is super easy

1660
01:00:12,000 --> 01:00:14,400
and you guessed this 2340 and you you

1661
01:00:14,400 --> 01:00:18,240
you compute this and check if it happens

1662
01:00:18,240 --> 01:00:21,599
so this is easy and actually not so hard

1663
01:00:21,599 --> 01:00:24,079
i mean if you to to find this vector i

1664
01:00:24,079 --> 01:00:25,680
don't know it's always like with script

1665
01:00:25,680 --> 01:00:27,119
analysis if you have the right idea it's

1666
01:00:27,119 --> 01:00:29,119
easy so here's only finding this black

1667
01:00:29,119 --> 01:00:30,960
vector is linear algebra now you have to

1668
01:00:30,960 --> 01:00:32,319
compute the kernel of this mapping it's

1669
01:00:32,319 --> 01:00:33,839
not like you have to run to this 2 to

1670
01:00:33,839 --> 01:00:35,280
the 64 to see this because it's all

1671
01:00:35,280 --> 01:00:37,760
linear algebra computing the kernel of a

1672
01:00:37,760 --> 01:00:39,440
matrix is enough to

1673
01:00:39,440 --> 01:00:40,960
to see this attack

1674
01:00:40,960 --> 01:00:43,200
okay so then the next question is

1675
01:00:43,200 --> 01:00:44,480
how did they do it how was this

1676
01:00:44,480 --> 01:00:46,640
constructed is it easy to to find these

1677
01:00:46,640 --> 01:00:48,559
lfsrs

1678
01:00:48,559 --> 01:00:51,119
so is it maybe an intentional weakness

1679
01:00:51,119 --> 01:00:53,680
or it's just unlucky

1680
01:00:53,680 --> 01:00:54,880
and so what

1681
01:00:54,880 --> 01:00:57,760
what the paper last eurocrypt

1682
01:00:57,760 --> 01:01:00,400
did is

1683
01:01:00,400 --> 01:01:02,559
to check how likely this is to happen

1684
01:01:02,559 --> 01:01:05,119
then you can have such a graph so you

1685
01:01:05,119 --> 01:01:06,160
take

1686
01:01:06,160 --> 01:01:08,960
i think one million lfsrs pairs of lfsrs

1687
01:01:08,960 --> 01:01:11,599
of the right dimension and check

1688
01:01:11,599 --> 01:01:13,599
what is the dimension of the

1689
01:01:13,599 --> 01:01:14,799
image of the space or what is the

1690
01:01:14,799 --> 01:01:16,640
dimension of the kernel so this is the

1691
01:01:16,640 --> 01:01:18,559
kernel because if you want this a small

1692
01:01:18,559 --> 01:01:20,720
image you want the large kernel so here

1693
01:01:20,720 --> 01:01:22,720
i

1694
01:01:22,720 --> 01:01:24,960
have on the x-axis the dimension of the

1695
01:01:24,960 --> 01:01:27,200
kernel and for ga1 this is 24. and in

1696
01:01:27,200 --> 01:01:28,799
this one million tries the highest

1697
01:01:28,799 --> 01:01:30,799
kernel that was observed was dimension

1698
01:01:30,799 --> 01:01:31,760
9.

1699
01:01:31,760 --> 01:01:33,599
and if you extrapolate a bit and and

1700
01:01:33,599 --> 01:01:34,799
make a

1701
01:01:34,799 --> 01:01:36,480
reasonable assumption about what's the

1702
01:01:36,480 --> 01:01:39,760
probability and the probability

1703
01:01:39,760 --> 01:01:43,119
or the effort uh to find such a con

1704
01:01:43,119 --> 01:01:46,160
configuration is 2 to the 40 or 2 to the

1705
01:01:46,160 --> 01:01:47,760
50. so that's

1706
01:01:47,760 --> 01:01:50,240
250 times trying elephants computing

1707
01:01:50,240 --> 01:01:53,119
linear algebra and this in the early 90s

1708
01:01:53,119 --> 01:01:56,400
is not possible this is not how they did

1709
01:01:56,400 --> 01:01:58,480
and so there's two things there must be

1710
01:01:58,480 --> 01:02:00,240
a way to construct this and the second

1711
01:02:00,240 --> 01:02:03,119
thing is this was not unlucky so this

1712
01:02:03,119 --> 01:02:06,000
was on purpose

1713
01:02:06,000 --> 01:02:08,240
okay and yeah this is two points the

1714
01:02:08,240 --> 01:02:09,599
question i want to answer is how was

1715
01:02:09,599 --> 01:02:11,920
this constructed so

1716
01:02:11,920 --> 01:02:14,240
we don't know right basically uh

1717
01:02:14,240 --> 01:02:16,319
we have one way to construct this but if

1718
01:02:16,319 --> 01:02:20,240
this is the way they did it who knows

1719
01:02:20,640 --> 01:02:23,520
so we have to look at the initialization

1720
01:02:23,520 --> 01:02:25,119
because this is the thing that makes it

1721
01:02:25,119 --> 01:02:27,680
weak so this is register a and this is

1722
01:02:27,680 --> 01:02:30,319
register c and and this is

1723
01:02:30,319 --> 01:02:32,720
what happens initialization works by

1724
01:02:32,720 --> 01:02:34,480
feeding in the bits of the key

1725
01:02:34,480 --> 01:02:36,960
so super that's how you do it that's how

1726
01:02:36,960 --> 01:02:39,200
everybody would do it so you fit in the

1727
01:02:39,200 --> 01:02:40,880
key and then you clock the register you

1728
01:02:40,880 --> 01:02:42,480
fit in the next bit of the key and you

1729
01:02:42,480 --> 01:02:44,640
clock it and so on and for the for the

1730
01:02:44,640 --> 01:02:46,480
second register you actually start with

1731
01:02:46,480 --> 01:02:47,520
a different

1732
01:02:47,520 --> 01:02:49,440
bit but basically you do the same now

1733
01:02:49,440 --> 01:02:51,440
you fit in the key

1734
01:02:51,440 --> 01:02:53,920
and so what you want you want that this

1735
01:02:53,920 --> 01:02:55,039
the image

1736
01:02:55,039 --> 01:02:57,200
of this linear mapping mapping the

1737
01:02:57,200 --> 01:02:59,920
64-bit key to these two states

1738
01:02:59,920 --> 01:03:01,680
the image is small so you want the last

1739
01:03:01,680 --> 01:03:03,599
curve you want many keys to be mapped to

1740
01:03:03,599 --> 01:03:06,240
zero in both lfsrs zero state here and

1741
01:03:06,240 --> 01:03:07,920
zero state

1742
01:03:07,920 --> 01:03:10,559
okay and just for some notation

1743
01:03:10,559 --> 01:03:11,839
you will have this feedback or the

1744
01:03:11,839 --> 01:03:14,000
characteristic polynomials of this lfsr

1745
01:03:14,000 --> 01:03:16,559
if this is denoted by g then the linear

1746
01:03:16,559 --> 01:03:18,799
mapping describing

1747
01:03:18,799 --> 01:03:21,280
the initialization key goes to initial

1748
01:03:21,280 --> 01:03:24,240
state i denote it by mg okay so what i

1749
01:03:24,240 --> 01:03:26,559
want is i have to look at this linear

1750
01:03:26,559 --> 01:03:29,039
mapping mapping the key s to this state

1751
01:03:29,039 --> 01:03:31,039
and register a and to this state in

1752
01:03:31,039 --> 01:03:35,119
register c and i want this to be 0

1753
01:03:36,160 --> 01:03:38,079
so there's one interesting data already

1754
01:03:38,079 --> 01:03:40,480
said so you start with a different key

1755
01:03:40,480 --> 01:03:41,680
in registers

1756
01:03:41,680 --> 01:03:43,920
different bit in register c yeah so it's

1757
01:03:43,920 --> 01:03:45,520
just shifted

1758
01:03:45,520 --> 01:03:47,119
and i'll explain why this makes a big

1759
01:03:47,119 --> 01:03:49,440
difference

1760
01:03:49,520 --> 01:03:51,520
okay first of all we have to

1761
01:03:51,520 --> 01:03:53,760
rewrite everything in polynomials yeah

1762
01:03:53,760 --> 01:03:56,000
so if you know a bit about lfsr that's

1763
01:03:56,000 --> 01:03:59,200
not super surprising yeah so

1764
01:03:59,200 --> 01:04:01,119
what you what we do you you write down

1765
01:04:01,119 --> 01:04:04,559
this 64-bit key as a degree 60

1766
01:04:04,559 --> 01:04:06,799
a polynomial of degree at most 63 by

1767
01:04:06,799 --> 01:04:09,599
basically just putting the coefficients

1768
01:04:09,599 --> 01:04:12,559
as the key bits no so there's some tiny

1769
01:04:12,559 --> 01:04:14,240
mistake and not mistake but i'm

1770
01:04:14,240 --> 01:04:17,439
simplifying here but yeah

1771
01:04:18,000 --> 01:04:20,000
and then the interesting way why is it a

1772
01:04:20,000 --> 01:04:21,760
good idea to rewrite it like this

1773
01:04:21,760 --> 01:04:23,039
because

1774
01:04:23,039 --> 01:04:25,119
being mapped a key being mapped to zero

1775
01:04:25,119 --> 01:04:26,480
is then equivalent

1776
01:04:26,480 --> 01:04:28,880
to this polynomial

1777
01:04:28,880 --> 01:04:30,400
being the key dependent polynomial the

1778
01:04:30,400 --> 01:04:32,240
key representation the polynomial

1779
01:04:32,240 --> 01:04:34,319
representation of the key is divisible

1780
01:04:34,319 --> 01:04:35,200
by

1781
01:04:35,200 --> 01:04:37,039
um the

1782
01:04:37,039 --> 01:04:37,839
um

1783
01:04:37,839 --> 01:04:39,119
characteristic

1784
01:04:39,119 --> 01:04:41,760
why is this intuitively the intuition is

1785
01:04:41,760 --> 01:04:44,559
that this initialization is nothing else

1786
01:04:44,559 --> 01:04:47,599
than computing this polynomial modulo g

1787
01:04:47,599 --> 01:04:49,599
now you flip a bit and depending on if

1788
01:04:49,599 --> 01:04:51,280
the set or not you're going to add the

1789
01:04:51,280 --> 01:04:54,640
polynomial g so that

1790
01:04:55,359 --> 01:04:57,039
makes sense that this this is like this

1791
01:04:57,039 --> 01:04:59,200
yeah so it's just reducing mod g and so

1792
01:04:59,200 --> 01:05:01,280
if this is reducing mod g then it's zero

1793
01:05:01,280 --> 01:05:03,440
if and only if it's divisible by g

1794
01:05:03,440 --> 01:05:05,039
okay

1795
01:05:05,039 --> 01:05:07,200
so now we want uh

1796
01:05:07,200 --> 01:05:08,880
we're looking at the variant without

1797
01:05:08,880 --> 01:05:10,799
shifting so that's maybe the more

1798
01:05:10,799 --> 01:05:13,200
natural variant which we would design so

1799
01:05:13,200 --> 01:05:15,039
you have register a without shifting and

1800
01:05:15,039 --> 01:05:16,559
register

1801
01:05:16,559 --> 01:05:18,559
c without shifting

1802
01:05:18,559 --> 01:05:20,640
so now you want so this link i just

1803
01:05:20,640 --> 01:05:22,160
explained and what you want is you want

1804
01:05:22,160 --> 01:05:24,319
it to be you want to count the number of

1805
01:05:24,319 --> 01:05:26,720
keys which are mapped to 0 in register a

1806
01:05:26,720 --> 01:05:29,200
and mapped to 0 in register c

1807
01:05:29,200 --> 01:05:31,280
and with this link so it has to be 0 and

1808
01:05:31,280 --> 01:05:33,280
both with the link that means that this

1809
01:05:33,280 --> 01:05:36,160
polynomial p of s is divisible by both

1810
01:05:36,160 --> 01:05:38,640
the error the feedback polynomial of

1811
01:05:38,640 --> 01:05:42,400
lfsr a and the feedback polynomial of

1812
01:05:42,400 --> 01:05:44,400
the second register

1813
01:05:44,400 --> 01:05:47,280
and now because those are primitive and

1814
01:05:47,280 --> 01:05:49,599
different degree if they both divided

1815
01:05:49,599 --> 01:05:51,680
the product is to divide it

1816
01:05:51,680 --> 01:05:54,319
but the product now is the degree 64

1817
01:05:54,319 --> 01:05:56,480
polynomial

1818
01:05:56,480 --> 01:05:58,720
and this has to divide a polynomial of

1819
01:05:58,720 --> 01:06:01,039
degree 63 at most

1820
01:06:01,039 --> 01:06:02,880
so that's not going to work so that's

1821
01:06:02,880 --> 01:06:04,960
only going to work if this polynomial is

1822
01:06:04,960 --> 01:06:06,799
zero so what does it mean if you don't

1823
01:06:06,799 --> 01:06:08,960
have shiftings then the only key which

1824
01:06:08,960 --> 01:06:11,200
is mapped to zero in both states is the

1825
01:06:11,200 --> 01:06:13,200
zero key so that this

1826
01:06:13,200 --> 01:06:15,599
makes a good cipher because it tells you

1827
01:06:15,599 --> 01:06:17,760
that if you do this initialization you

1828
01:06:17,760 --> 01:06:19,200
get

1829
01:06:19,200 --> 01:06:21,359
no entropy loss

1830
01:06:21,359 --> 01:06:24,079
so this this is a nice construction so

1831
01:06:24,079 --> 01:06:25,440
but they didn't do it like this yeah so

1832
01:06:25,440 --> 01:06:27,440
there's the shift and why is the way why

1833
01:06:27,440 --> 01:06:28,319
er

1834
01:06:28,319 --> 01:06:29,599
is the shift

1835
01:06:29,599 --> 01:06:31,440
what is the effect of the shift

1836
01:06:31,440 --> 01:06:34,400
in in this polynomial setup

1837
01:06:34,400 --> 01:06:37,920
so yeah i show the shift again

1838
01:06:37,920 --> 01:06:39,760
so what happens is

1839
01:06:39,760 --> 01:06:41,119
you can think of shifting as the

1840
01:06:41,119 --> 01:06:43,920
polynomial being multiplied by x to the

1841
01:06:43,920 --> 01:06:46,480
32 and then reduced modulo x to the 64

1842
01:06:46,480 --> 01:06:48,799
plus and just wrapped it up and this is

1843
01:06:48,799 --> 01:06:49,839
the ribbon

1844
01:06:49,839 --> 01:06:51,680
and now what you want again you want it

1845
01:06:51,680 --> 01:06:52,799
to be zero

1846
01:06:52,799 --> 01:06:54,720
in the first polynomial and you want the

1847
01:06:54,720 --> 01:06:58,319
shifted key to be zero in in the second

1848
01:06:58,319 --> 01:06:59,599
ellipse

1849
01:06:59,599 --> 01:07:02,319
and now you do again the same conversion

1850
01:07:02,319 --> 01:07:04,400
with with the link i explained to the

1851
01:07:04,400 --> 01:07:06,960
polynomial so now this means that the

1852
01:07:06,960 --> 01:07:08,960
first polynomial has to divide this p of

1853
01:07:08,960 --> 01:07:10,480
s and the second polynomial has to

1854
01:07:10,480 --> 01:07:11,599
divide this

1855
01:07:11,599 --> 01:07:13,599
rotated point

1856
01:07:13,599 --> 01:07:15,680
and now there's no obvious link because

1857
01:07:15,680 --> 01:07:17,920
with respect to factorization this

1858
01:07:17,920 --> 01:07:19,440
polynomial and this probably normally

1859
01:07:19,440 --> 01:07:21,520
they behave independent

1860
01:07:21,520 --> 01:07:23,520
they are not independent but of course

1861
01:07:23,520 --> 01:07:25,760
heuristically and also experimentally

1862
01:07:25,760 --> 01:07:27,760
they behave very independent yeah so the

1863
01:07:27,760 --> 01:07:29,280
visibility of this one and the

1864
01:07:29,280 --> 01:07:31,119
visibility of this one is two different

1865
01:07:31,119 --> 01:07:32,880
things and so there's no contradiction

1866
01:07:32,880 --> 01:07:34,960
anymore so it's possible yeah

1867
01:07:34,960 --> 01:07:35,680
and

1868
01:07:35,680 --> 01:07:37,680
yeah it's a nice

1869
01:07:37,680 --> 01:07:39,039
it's a nice small

1870
01:07:39,039 --> 01:07:42,400
change that makes this

1871
01:07:42,400 --> 01:07:44,960
attack possible this weakness possible

1872
01:07:44,960 --> 01:07:46,799
okay so

1873
01:07:46,799 --> 01:07:47,920
that's important but it still doesn't

1874
01:07:47,920 --> 01:07:49,839
explain how you find those now

1875
01:07:49,839 --> 01:07:51,680
so how do we find we still have to find

1876
01:07:51,680 --> 01:07:54,160
this ga and gc now we know

1877
01:07:54,160 --> 01:07:56,480
how to write this in polynomials and

1878
01:07:56,480 --> 01:07:58,559
so far i didn't explain how to find so

1879
01:07:58,559 --> 01:08:00,799
the idea is you turn the problem around

1880
01:08:00,799 --> 01:08:02,240
instead of trying to find these

1881
01:08:02,240 --> 01:08:04,559
polynomials starting with polynomials

1882
01:08:04,559 --> 01:08:07,200
and trying to factor trying to to see if

1883
01:08:07,200 --> 01:08:09,200
if they have a good polynomial you start

1884
01:08:09,200 --> 01:08:11,280
you're starting with the kernel element

1885
01:08:11,280 --> 01:08:12,880
and and try to find the corresponding

1886
01:08:12,880 --> 01:08:15,760
volume the the feedback polynomials

1887
01:08:15,760 --> 01:08:17,920
yeah so we given p of s we try to

1888
01:08:17,920 --> 01:08:19,120
construct

1889
01:08:19,120 --> 01:08:22,238
uh ga and gb so that this given key is

1890
01:08:22,238 --> 01:08:24,479
mapped to zero

1891
01:08:24,479 --> 01:08:26,479
and that's easy so what you do is you

1892
01:08:26,479 --> 01:08:29,120
take this polynomial ps and this other

1893
01:08:29,120 --> 01:08:31,120
polynomial and just factorize it and you

1894
01:08:31,120 --> 01:08:32,000
hope

1895
01:08:32,000 --> 01:08:35,520
that it has a irreducible a primitive

1896
01:08:35,520 --> 01:08:36,839
factor of the right

1897
01:08:36,839 --> 01:08:40,000
size and why is this a good idea to do

1898
01:08:40,000 --> 01:08:41,279
it like this because

1899
01:08:41,279 --> 01:08:43,359
primitive polynomials are not rare

1900
01:08:43,359 --> 01:08:46,080
so if you pick a random polynomial

1901
01:08:46,080 --> 01:08:47,920
so then that its primitive is not not

1902
01:08:47,920 --> 01:08:49,920
very unlikely okay

1903
01:08:49,920 --> 01:08:51,198
you can write down the formula this

1904
01:08:51,198 --> 01:08:52,880
multiplication here already assumes that

1905
01:08:52,880 --> 01:08:55,679
things behave independently and

1906
01:08:55,679 --> 01:08:57,439
it works i mean we

1907
01:08:57,439 --> 01:08:58,880
did experiments and

1908
01:08:58,880 --> 01:09:00,719
and

1909
01:09:00,719 --> 01:09:02,960
after

1910
01:09:03,359 --> 01:09:05,120
like roughly a thousand tries you're

1911
01:09:05,120 --> 01:09:08,479
done you find this setup that you wanted

1912
01:09:08,479 --> 01:09:09,520
okay

1913
01:09:09,520 --> 01:09:11,520
so now i explained you

1914
01:09:11,520 --> 01:09:13,839
how um you can rewrite everything

1915
01:09:13,839 --> 01:09:16,799
polynomials and how given how you can

1916
01:09:16,799 --> 01:09:18,839
can efficiently find

1917
01:09:18,839 --> 01:09:20,479
um and

1918
01:09:20,479 --> 01:09:21,920
polynomials so that at least you have

1919
01:09:21,920 --> 01:09:23,359
one element in the kernel namely the one

1920
01:09:23,359 --> 01:09:24,799
you started with

1921
01:09:24,799 --> 01:09:26,880
but still we don't want a kernel of

1922
01:09:26,880 --> 01:09:29,679
dimension one which is no clear we want

1923
01:09:29,679 --> 01:09:30,799
the

1924
01:09:30,799 --> 01:09:33,120
kernel of dimension 24. now in the case

1925
01:09:33,120 --> 01:09:36,000
of ga1 and how do you do this you choose

1926
01:09:36,000 --> 01:09:38,799
ps special and basically you make sure

1927
01:09:38,799 --> 01:09:39,759
that

1928
01:09:39,759 --> 01:09:41,759
yeah okay you look in the paper if you

1929
01:09:41,759 --> 01:09:44,799
want to know how to do this so there's a

1930
01:09:44,799 --> 01:09:47,439
a special a choice of p so that if this

1931
01:09:47,439 --> 01:09:49,759
p is in the kernel then you know many

1932
01:09:49,759 --> 01:09:52,080
elements in in the kernel

1933
01:09:52,080 --> 01:09:54,158
rotated variants in base in principle of

1934
01:09:54,158 --> 01:09:57,199
these powers indica okay

1935
01:09:57,199 --> 01:10:00,239
so um and this works yeah so we we

1936
01:10:00,239 --> 01:10:02,239
implemented it super efficient so it

1937
01:10:02,239 --> 01:10:04,880
also was already efficient in the 90s

1938
01:10:04,880 --> 01:10:06,800
and you can check if the kernel the

1939
01:10:06,800 --> 01:10:08,960
excellent kernel of ga1 is of this form

1940
01:10:08,960 --> 01:10:11,360
and it is of this form um

1941
01:10:11,360 --> 01:10:13,360
it's interestingly that you could weaken

1942
01:10:13,360 --> 01:10:15,520
it below 40 bits yeah so now the

1943
01:10:15,520 --> 01:10:17,600
security is 40 bits but you could also

1944
01:10:17,600 --> 01:10:20,239
do with the same setup achieve

1945
01:10:20,239 --> 01:10:22,480
even weaker systems but they didn't do

1946
01:10:22,480 --> 01:10:26,000
it yeah so and this 40 bits is something

1947
01:10:26,000 --> 01:10:28,159
which more or less officially

1948
01:10:28,159 --> 01:10:30,159
was export controller

1949
01:10:30,159 --> 01:10:32,960
in the uh in the eu so it makes sense

1950
01:10:32,960 --> 01:10:34,880
that it's 40 bits

1951
01:10:34,880 --> 01:10:35,760
um

1952
01:10:35,760 --> 01:10:38,080
okay and see all these details are in

1953
01:10:38,080 --> 01:10:39,840
the paper and kind of the correct

1954
01:10:39,840 --> 01:10:41,520
version of all what i said is in the

1955
01:10:41,520 --> 01:10:42,719
paper

1956
01:10:42,719 --> 01:10:45,600
without the simplifications and that's

1957
01:10:45,600 --> 01:10:48,960
all i wanted to say thank you very much

1958
01:10:53,440 --> 01:10:55,120
thanks greg are there any questions in

1959
01:10:55,120 --> 01:10:58,679
the room or in zoom

1960
01:11:05,120 --> 01:11:09,159
okay thanks hello thanks again

1961
01:11:56,400 --> 01:11:58,800
so the last talk of this session is

1962
01:11:58,800 --> 01:12:00,800
siemens algorithm and symmetry crypto

1963
01:12:00,800 --> 01:12:03,120
generalizations and automatized

1964
01:12:03,120 --> 01:12:04,800
applications and the talk is given by

1965
01:12:04,800 --> 01:12:07,120
lucas then

1966
01:12:07,120 --> 01:12:09,280
yeah hello everyone thanks for the

1967
01:12:09,280 --> 01:12:11,280
introduction i just want to add the

1968
01:12:11,280 --> 01:12:13,360
papers joint work with federico canal

1969
01:12:13,360 --> 01:12:15,120
and gregoriana

1970
01:12:15,120 --> 01:12:17,600
and i mean well the paper is titled

1971
01:12:17,600 --> 01:12:19,600
simon's algorithm and symmetric crypto

1972
01:12:19,600 --> 01:12:20,880
so

1973
01:12:20,880 --> 01:12:24,239
um i want to start by explaining what

1974
01:12:24,239 --> 01:12:26,239
simon's algorithm is and simon's

1975
01:12:26,239 --> 01:12:28,400
algorithm is a quantum algorithm that

1976
01:12:28,400 --> 01:12:30,320
solves a rather specific problem namely

1977
01:12:30,320 --> 01:12:32,560
simon's problem and for simon's problem

1978
01:12:32,560 --> 01:12:35,280
you are given a function f that maps n

1979
01:12:35,280 --> 01:12:37,920
bits to envip n bits

1980
01:12:37,920 --> 01:12:39,760
and your promise that the function is

1981
01:12:39,760 --> 01:12:40,960
such that

1982
01:12:40,960 --> 01:12:43,360
there's a secret period s and that means

1983
01:12:43,360 --> 01:12:47,040
that f of x is equal to f of x x or s

1984
01:12:47,040 --> 01:12:48,480
for all x

1985
01:12:48,480 --> 01:12:51,679
for x yeah and now the goal is to to

1986
01:12:51,679 --> 01:12:53,920
find the period s

1987
01:12:53,920 --> 01:12:56,719
and in a classical world you can show

1988
01:12:56,719 --> 01:12:59,440
that you will need at least

1989
01:12:59,440 --> 01:13:02,640
or roughly two to the n over two queries

1990
01:13:02,640 --> 01:13:04,800
to f so that's essentially the

1991
01:13:04,800 --> 01:13:06,560
birthday problem because you have to

1992
01:13:06,560 --> 01:13:08,320
find a collision in it but in the

1993
01:13:08,320 --> 01:13:11,199
quantum world there's simon's algorithm

1994
01:13:11,199 --> 01:13:14,159
and with simon's algorithm you only need

1995
01:13:14,159 --> 01:13:16,880
big o of n quantum queries and then some

1996
01:13:16,880 --> 01:13:21,280
basic linear algebra to to recover s and

1997
01:13:21,280 --> 01:13:23,440
yeah i mean that's that's nice it's an

1998
01:13:23,440 --> 01:13:26,159
exponential speed up but why do why do

1999
01:13:26,159 --> 01:13:28,320
we care about this we as like people who

2000
01:13:28,320 --> 01:13:30,960
are doing symmetric cryptanalysis and

2001
01:13:30,960 --> 01:13:32,800
the reason why we should care

2002
01:13:32,800 --> 01:13:35,120
was essentially given by kuvacaro and

2003
01:13:35,120 --> 01:13:36,239
morin

2004
01:13:36,239 --> 01:13:39,520
first in 2010 where they gave a quantum

2005
01:13:39,520 --> 01:13:41,040
attack based on simon's algorithm

2006
01:13:41,040 --> 01:13:44,239
against sweyan faisal and then in 2012

2007
01:13:44,239 --> 01:13:46,159
they gave one against the evan manzo

2008
01:13:46,159 --> 01:13:48,719
construction and this i want to present

2009
01:13:48,719 --> 01:13:49,920
here

2010
01:13:49,920 --> 01:13:51,920
so for evan mansour

2011
01:13:51,920 --> 01:13:52,640
we

2012
01:13:52,640 --> 01:13:54,560
i mean it's a construction to to

2013
01:13:54,560 --> 01:13:56,800
construct a block cipher and we need

2014
01:13:56,800 --> 01:13:59,800
um

2015
01:14:00,080 --> 01:14:03,920
we need uh two secret keys k0 and k1 and

2016
01:14:03,920 --> 01:14:06,480
one public permutation so everyone knows

2017
01:14:06,480 --> 01:14:08,719
this permutation and that what we do is

2018
01:14:08,719 --> 01:14:12,960
we we simply um add k02 to the input

2019
01:14:12,960 --> 01:14:15,600
then apply our permutation at the other

2020
01:14:15,600 --> 01:14:18,480
key and that's what we need to do to

2021
01:14:18,480 --> 01:14:21,440
compute the the encryption of x

2022
01:14:21,440 --> 01:14:23,199
and in a classical world you you can

2023
01:14:23,199 --> 01:14:26,000
prove that this is a secure block cipher

2024
01:14:26,000 --> 01:14:29,040
but in the quantum world we

2025
01:14:29,040 --> 01:14:31,199
when we consider this function f of x

2026
01:14:31,199 --> 01:14:34,080
which is simply the the encryption of x

2027
01:14:34,080 --> 01:14:35,600
x or the the

2028
01:14:35,600 --> 01:14:36,800
public

2029
01:14:36,800 --> 01:14:38,560
permutation p

2030
01:14:38,560 --> 01:14:40,560
then we will notice that when we when we

2031
01:14:40,560 --> 01:14:43,840
write this out then that we have this p

2032
01:14:43,840 --> 01:14:47,600
of x x or k 0 and then x of p of x

2033
01:14:47,600 --> 01:14:50,719
so this means that if we add k 0 to the

2034
01:14:50,719 --> 01:14:53,840
input then this will be cancelled out

2035
01:14:53,840 --> 01:14:56,960
but k 0 will appear here and that means

2036
01:14:56,960 --> 01:14:58,480
that the output value will not change

2037
01:14:58,480 --> 01:15:00,560
right because it's it's the same as

2038
01:15:00,560 --> 01:15:03,600
before just swapped around

2039
01:15:03,600 --> 01:15:04,719
so

2040
01:15:04,719 --> 01:15:06,960
as i just said then if we have a

2041
01:15:06,960 --> 01:15:09,199
function of this form we can use simon's

2042
01:15:09,199 --> 01:15:11,280
algorithm to the simon's quantum

2043
01:15:11,280 --> 01:15:13,600
algorithm to find k0

2044
01:15:13,600 --> 01:15:16,480
with just a polynomial amount of queries

2045
01:15:16,480 --> 01:15:18,560
to the encryption

2046
01:15:18,560 --> 01:15:20,560
and once we have k0

2047
01:15:20,560 --> 01:15:23,120
finding k1 is is easy and therefore the

2048
01:15:23,120 --> 01:15:26,080
the quantum version of the evan mansour

2049
01:15:26,080 --> 01:15:28,800
construction is is wrong

2050
01:15:28,800 --> 01:15:31,280
okay so that was the motivation for for

2051
01:15:31,280 --> 01:15:32,400
our work

2052
01:15:32,400 --> 01:15:34,400
and now we have two contributions and

2053
01:15:34,400 --> 01:15:36,080
the first is

2054
01:15:36,080 --> 01:15:38,800
an automize or an automatic way to to

2055
01:15:38,800 --> 01:15:40,640
find new applications that means

2056
01:15:40,640 --> 01:15:41,920
essentially to

2057
01:15:41,920 --> 01:15:44,800
to find these periodic functions for for

2058
01:15:44,800 --> 01:15:46,960
other constructions and then our second

2059
01:15:46,960 --> 01:15:48,719
contribution

2060
01:15:48,719 --> 01:15:50,880
is a negative result

2061
01:15:50,880 --> 01:15:53,840
on potential generalizations of simon's

2062
01:15:53,840 --> 01:15:55,199
algorithm

2063
01:15:55,199 --> 01:15:57,440
okay so let's start with the optimized

2064
01:15:57,440 --> 01:15:59,440
applications

2065
01:15:59,440 --> 01:16:00,400
and

2066
01:16:00,400 --> 01:16:02,320
i mean like like i just said

2067
01:16:02,320 --> 01:16:04,560
once we have a periodic function you can

2068
01:16:04,560 --> 01:16:06,719
just use simon's algorithm to to recover

2069
01:16:06,719 --> 01:16:08,560
the period and then you know maybe the

2070
01:16:08,560 --> 01:16:09,840
period is

2071
01:16:09,840 --> 01:16:12,320
uh like just depends on on the secrets

2072
01:16:12,320 --> 01:16:14,480
and can be then used for a distinguisher

2073
01:16:14,480 --> 01:16:16,239
or maybe the period is

2074
01:16:16,239 --> 01:16:17,679
the the

2075
01:16:17,679 --> 01:16:19,600
secret key or something then we can also

2076
01:16:19,600 --> 01:16:22,000
build key recovery attacks and the

2077
01:16:22,000 --> 01:16:23,600
important point is

2078
01:16:23,600 --> 01:16:25,199
that these attacks will be fast in the

2079
01:16:25,199 --> 01:16:27,440
sense that we will only need

2080
01:16:27,440 --> 01:16:29,520
a polynomial amount of quantum queries

2081
01:16:29,520 --> 01:16:31,280
in contrast to let's say grover's

2082
01:16:31,280 --> 01:16:32,719
algorithm where we still need an

2083
01:16:32,719 --> 01:16:35,760
exponential amount of queries

2084
01:16:35,760 --> 01:16:36,719
so

2085
01:16:36,719 --> 01:16:38,480
i mean for for the evan mansour

2086
01:16:38,480 --> 01:16:39,600
construction

2087
01:16:39,600 --> 01:16:41,120
finding this function is quite easy

2088
01:16:41,120 --> 01:16:42,640
because the construction itself is

2089
01:16:42,640 --> 01:16:44,800
rather easy but if you study more

2090
01:16:44,800 --> 01:16:47,040
complex construction it becomes really

2091
01:16:47,040 --> 01:16:48,800
cumbersome and you don't want to do it

2092
01:16:48,800 --> 01:16:50,320
by hand anymore and

2093
01:16:50,320 --> 01:16:51,040
so

2094
01:16:51,040 --> 01:16:52,400
we want to optimize it we want a

2095
01:16:52,400 --> 01:16:54,480
computer to do this for us but

2096
01:16:54,480 --> 01:16:56,480
the question is how can we do this

2097
01:16:56,480 --> 01:16:58,239
and our approach is

2098
01:16:58,239 --> 01:17:00,239
quite simple actually we will just

2099
01:17:00,239 --> 01:17:03,520
enumerate all sensible functions

2100
01:17:03,520 --> 01:17:05,600
and because the devil is in a detail

2101
01:17:05,600 --> 01:17:08,000
what does sensible mean for us sensible

2102
01:17:08,000 --> 01:17:10,320
means that the the periodic function

2103
01:17:10,320 --> 01:17:13,040
somewhat depends on on the construction

2104
01:17:13,040 --> 01:17:14,080
yeah

2105
01:17:14,080 --> 01:17:14,800
so

2106
01:17:14,800 --> 01:17:16,880
i mean for example for the evan manzo

2107
01:17:16,880 --> 01:17:18,880
construction we we use this internal

2108
01:17:18,880 --> 01:17:20,640
permutation p and maybe the the

2109
01:17:20,640 --> 01:17:23,520
encryption itself and then xor that's it

2110
01:17:23,520 --> 01:17:26,159
and then once we have such a function we

2111
01:17:26,159 --> 01:17:28,400
will in instantiate it with a small

2112
01:17:28,400 --> 01:17:30,719
block size say for example four bits or

2113
01:17:30,719 --> 01:17:31,840
something

2114
01:17:31,840 --> 01:17:33,679
and then like checking if there's a

2115
01:17:33,679 --> 01:17:36,719
period is is easy because we can just

2116
01:17:36,719 --> 01:17:38,560
evaluate the function on all the inputs

2117
01:17:38,560 --> 01:17:40,480
and then use a trivial brute force

2118
01:17:40,480 --> 01:17:43,280
approach to see whether there's a period

2119
01:17:43,280 --> 01:17:46,159
and once again the the periodic function

2120
01:17:46,159 --> 01:17:49,360
for the evangel construction or the

2121
01:17:49,360 --> 01:17:50,960
the attack on the evidence construction

2122
01:17:50,960 --> 01:17:52,159
looks like this

2123
01:17:52,159 --> 01:17:55,280
and to to represent such functions

2124
01:17:55,280 --> 01:17:57,760
we we are going to use circuits so

2125
01:17:57,760 --> 01:18:00,239
the circuit for this function would look

2126
01:18:00,239 --> 01:18:02,080
like this so here we have an input and

2127
01:18:02,080 --> 01:18:03,760
then we apply the permutation and the

2128
01:18:03,760 --> 01:18:05,360
encryption and then we exhort this

2129
01:18:05,360 --> 01:18:06,800
together

2130
01:18:06,800 --> 01:18:10,320
okay so let's go into a little details

2131
01:18:10,320 --> 01:18:12,960
there for circuits so this is actually

2132
01:18:12,960 --> 01:18:14,560
the circuit

2133
01:18:14,560 --> 01:18:17,040
or the the circuit representing the

2134
01:18:17,040 --> 01:18:19,440
the function that was used in the attack

2135
01:18:19,440 --> 01:18:23,199
on the furon faisal cipher in 2010 which

2136
01:18:23,199 --> 01:18:25,360
is actually in contrast to the

2137
01:18:25,360 --> 01:18:28,960
one on evan mansur just a distinguisher

2138
01:18:28,960 --> 01:18:30,400
and

2139
01:18:30,400 --> 01:18:33,280
so i want to use this as an example for

2140
01:18:33,280 --> 01:18:34,640
what we

2141
01:18:34,640 --> 01:18:38,000
what we understand the circuits so

2142
01:18:38,000 --> 01:18:40,000
i mean most importantly the circuit is

2143
01:18:40,000 --> 01:18:42,239
essentially just a graph here so a

2144
01:18:42,239 --> 01:18:44,800
directed at cyclic graph

2145
01:18:44,800 --> 01:18:45,920
and

2146
01:18:45,920 --> 01:18:48,640
a subset of the nodes

2147
01:18:48,640 --> 01:18:51,440
is i mean rd input so this is this

2148
01:18:51,440 --> 01:18:53,920
capital x and notice that we here have

2149
01:18:53,920 --> 01:18:56,320
like the the small x is just the

2150
01:18:56,320 --> 01:18:58,000
the input of the function but we can

2151
01:18:58,000 --> 01:19:00,320
also have like constant in in our input

2152
01:19:00,320 --> 01:19:02,560
set so here the the alpha there's an

2153
01:19:02,560 --> 01:19:04,239
alpha zero and an alpha one in the

2154
01:19:04,239 --> 01:19:06,480
attack which are constants and then

2155
01:19:06,480 --> 01:19:08,960
there's an additional input with b

2156
01:19:08,960 --> 01:19:11,440
which essentially switches the

2157
01:19:11,440 --> 01:19:13,679
the um

2158
01:19:13,679 --> 01:19:16,239
the values of these alphas

2159
01:19:16,239 --> 01:19:18,480
okay and then

2160
01:19:18,480 --> 01:19:20,239
other than that for the for the

2161
01:19:20,239 --> 01:19:22,960
non-input nodes the non-input nodes are

2162
01:19:22,960 --> 01:19:26,239
labeled with gate functions so here el

2163
01:19:26,239 --> 01:19:28,320
is the left part of the three-on-five

2164
01:19:28,320 --> 01:19:31,120
cipher so the output of the freon python

2165
01:19:31,120 --> 01:19:33,840
and this is just xo as usual

2166
01:19:33,840 --> 01:19:37,520
and then for i mean for the x or

2167
01:19:37,520 --> 01:19:39,120
the order of inputs of course does not

2168
01:19:39,120 --> 01:19:42,000
matter but for for the encryption

2169
01:19:42,000 --> 01:19:43,600
because it doesn't matter which one is

2170
01:19:43,600 --> 01:19:45,360
the left and the right or the first and

2171
01:19:45,360 --> 01:19:47,280
second input and so we are also going to

2172
01:19:47,280 --> 01:19:49,600
to label the edges to make clear what

2173
01:19:49,600 --> 01:19:51,760
the order of inputs is

2174
01:19:51,760 --> 01:19:54,400
and last but not least we we need some

2175
01:19:54,400 --> 01:19:57,520
some notices actually the the value the

2176
01:19:57,520 --> 01:19:59,679
output value of the function and for

2177
01:19:59,679 --> 01:20:01,920
convenience this will just always be the

2178
01:20:01,920 --> 01:20:04,800
node all down below

2179
01:20:04,800 --> 01:20:05,600
okay

2180
01:20:05,600 --> 01:20:08,159
so then let's consider some examples on

2181
01:20:08,159 --> 01:20:11,280
what an abstract example of a circuit

2182
01:20:11,280 --> 01:20:12,880
and notice

2183
01:20:12,880 --> 01:20:14,320
here

2184
01:20:14,320 --> 01:20:16,000
there's a

2185
01:20:16,000 --> 01:20:18,639
node that is not really used anymore and

2186
01:20:18,639 --> 01:20:21,120
i think intuitively it should be super

2187
01:20:21,120 --> 01:20:22,719
clear that it makes no sense to to

2188
01:20:22,719 --> 01:20:24,960
consider such a circuit because

2189
01:20:24,960 --> 01:20:26,400
i mean if we consider the same circuit

2190
01:20:26,400 --> 01:20:28,639
without this node would compute the same

2191
01:20:28,639 --> 01:20:29,920
function right

2192
01:20:29,920 --> 01:20:32,719
and then there are two other nodes

2193
01:20:32,719 --> 01:20:34,320
both are labeled with g

2194
01:20:34,320 --> 01:20:36,000
g 0 so they both compute the same

2195
01:20:36,000 --> 01:20:37,120
function

2196
01:20:37,120 --> 01:20:37,920
and

2197
01:20:37,920 --> 01:20:40,480
they also have both the same inputs so

2198
01:20:40,480 --> 01:20:42,560
again it makes not really sense to to do

2199
01:20:42,560 --> 01:20:44,800
this like this so we don't want to do

2200
01:20:44,800 --> 01:20:47,840
this and essentially we we say that such

2201
01:20:47,840 --> 01:20:50,320
circuits are then in a non-normal form

2202
01:20:50,320 --> 01:20:51,920
and we only want to consider circuits

2203
01:20:51,920 --> 01:20:53,360
that are normal so

2204
01:20:53,360 --> 01:20:55,840
an example of of an equivalent circuit

2205
01:20:55,840 --> 01:20:58,239
that computes the same function

2206
01:20:58,239 --> 01:21:00,560
would be this and

2207
01:21:00,560 --> 01:21:02,480
thereby we can reduce the number of

2208
01:21:02,480 --> 01:21:04,159
circuits that we actually have to to

2209
01:21:04,159 --> 01:21:07,679
consider and therefore we reduce the the

2210
01:21:07,679 --> 01:21:09,679
runtime of our search

2211
01:21:09,679 --> 01:21:12,800
by quite a lot and

2212
01:21:12,800 --> 01:21:15,360
this is not enough yet so we need even

2213
01:21:15,360 --> 01:21:16,239
more

2214
01:21:16,239 --> 01:21:17,600
restrictions

2215
01:21:17,600 --> 01:21:18,800
and

2216
01:21:18,800 --> 01:21:22,000
to do so i mean we we just say that we

2217
01:21:22,000 --> 01:21:24,480
want to define some rules and the rule

2218
01:21:24,480 --> 01:21:26,719
just takes a circuit as input and then

2219
01:21:26,719 --> 01:21:29,280
output 0 or 1 depending on whether the

2220
01:21:29,280 --> 01:21:31,840
circuit is useful or

2221
01:21:31,840 --> 01:21:33,840
not

2222
01:21:33,840 --> 01:21:38,080
and just some example for such rules

2223
01:21:38,080 --> 01:21:39,280
so

2224
01:21:39,280 --> 01:21:41,360
these rules are more concrete yeah so

2225
01:21:41,360 --> 01:21:43,920
not on on abstract circuits but

2226
01:21:43,920 --> 01:21:46,239
when we for example know that

2227
01:21:46,239 --> 01:21:49,199
the one of the gate functions is x1

2228
01:21:49,199 --> 01:21:51,760
which will always be the case then again

2229
01:21:51,760 --> 01:21:53,440
it makes no sense to consider circuits

2230
01:21:53,440 --> 01:21:55,440
that compute something like a x or a

2231
01:21:55,440 --> 01:21:57,199
because

2232
01:21:57,199 --> 01:21:59,280
oh i mean not only for the output but

2233
01:21:59,280 --> 01:22:01,280
also in an intermediate step

2234
01:22:01,280 --> 01:22:04,159
because when you want to have a zero or

2235
01:22:04,159 --> 01:22:06,159
a constant zero then you can just add it

2236
01:22:06,159 --> 01:22:07,199
as a

2237
01:22:07,199 --> 01:22:09,120
constant to the input nodes

2238
01:22:09,120 --> 01:22:11,600
and also we could restrict the number of

2239
01:22:11,600 --> 01:22:13,280
queries that are actually allowed so we

2240
01:22:13,280 --> 01:22:16,159
could say that the the function that

2241
01:22:16,159 --> 01:22:17,760
i mean the the function we are looking

2242
01:22:17,760 --> 01:22:19,920
for should only query the

2243
01:22:19,920 --> 01:22:21,840
the construction that we are trying to

2244
01:22:21,840 --> 01:22:24,159
attack like only once or only twice

2245
01:22:24,159 --> 01:22:26,639
something but like this

2246
01:22:26,639 --> 01:22:29,440
and of course we can then also say that

2247
01:22:29,440 --> 01:22:32,080
uh the query to a construction should

2248
01:22:32,080 --> 01:22:34,880
depend on on a non-constant input and to

2249
01:22:34,880 --> 01:22:37,120
do so we i mean this would just be like

2250
01:22:37,120 --> 01:22:39,120
a reachability test on the underlying

2251
01:22:39,120 --> 01:22:40,080
graph

2252
01:22:40,080 --> 01:22:42,159
and i mean you could go on like

2253
01:22:42,159 --> 01:22:45,040
essentially you can do whatever you want

2254
01:22:45,040 --> 01:22:47,120
it only has to be efficient and i think

2255
01:22:47,120 --> 01:22:48,800
this is also clear right if you say that

2256
01:22:48,800 --> 01:22:51,280
the rule is that the circuit that you

2257
01:22:51,280 --> 01:22:53,600
have in the end has like a period or

2258
01:22:53,600 --> 01:22:55,520
something or should we

2259
01:22:55,520 --> 01:22:57,199
did what you want to search for of

2260
01:22:57,199 --> 01:22:59,120
course you could define this in theory

2261
01:22:59,120 --> 01:23:01,520
but it makes no sense in practice

2262
01:23:01,520 --> 01:23:02,719
and

2263
01:23:02,719 --> 01:23:05,199
the key point here is that these rules

2264
01:23:05,199 --> 01:23:07,440
are not only checked before we do our

2265
01:23:07,440 --> 01:23:09,760
period test but on all intermediate

2266
01:23:09,760 --> 01:23:11,600
steps so that we can

2267
01:23:11,600 --> 01:23:13,679
i mean if you think about the the whole

2268
01:23:13,679 --> 01:23:17,120
thing as a search tree then we try to

2269
01:23:17,120 --> 01:23:18,639
you know to cut

2270
01:23:18,639 --> 01:23:21,120
as soon as possible like when we go down

2271
01:23:21,120 --> 01:23:23,600
from the wood to and the leaves are the

2272
01:23:23,600 --> 01:23:25,920
the circuits which we actually will test

2273
01:23:25,920 --> 01:23:28,239
for periods we try to cut large parts

2274
01:23:28,239 --> 01:23:29,679
out of the circuit

2275
01:23:29,679 --> 01:23:32,400
and to to give you some numbers

2276
01:23:32,400 --> 01:23:35,280
here is um

2277
01:23:35,280 --> 01:23:37,679
the the search for for foreground files

2278
01:23:37,679 --> 01:23:39,600
so another attack that's what was

2279
01:23:39,600 --> 01:23:41,440
already known before

2280
01:23:41,440 --> 01:23:44,159
and so we first tried to to rediscover

2281
01:23:44,159 --> 01:23:45,760
known attacks to see whether our

2282
01:23:45,760 --> 01:23:47,679
approach would actually work

2283
01:23:47,679 --> 01:23:49,760
and this solid line

2284
01:23:49,760 --> 01:23:52,000
is the number of circuits you would have

2285
01:23:52,000 --> 01:23:53,440
to test if you

2286
01:23:53,440 --> 01:23:54,880
do the uh

2287
01:23:54,880 --> 01:23:57,040
like trivial approach where you don't do

2288
01:23:57,040 --> 01:23:58,239
any

2289
01:23:58,239 --> 01:24:00,960
any of these tests or normalization or

2290
01:24:00,960 --> 01:24:03,199
anything like this and notice that this

2291
01:24:03,199 --> 01:24:05,840
scale is logarithmic so here is already

2292
01:24:05,840 --> 01:24:07,280
2 to the 40.

2293
01:24:07,280 --> 01:24:08,960
so to

2294
01:24:08,960 --> 01:24:12,719
check circuits with no 6 non

2295
01:24:12,719 --> 01:24:14,719
input nodes you would

2296
01:24:14,719 --> 01:24:17,520
need to check two to the 43 circuit so

2297
01:24:17,520 --> 01:24:19,040
that's

2298
01:24:19,040 --> 01:24:20,960
would take a bit longer than in a

2299
01:24:20,960 --> 01:24:24,960
weekend on my laptop at least and

2300
01:24:24,960 --> 01:24:27,440
but what you can do now is

2301
01:24:27,440 --> 01:24:28,320
so

2302
01:24:28,320 --> 01:24:29,280
if you do

2303
01:24:29,280 --> 01:24:30,719
this and we

2304
01:24:30,719 --> 01:24:32,719
define our rules then you only need to

2305
01:24:32,719 --> 01:24:36,639
do like two to the 23 rules and then and

2306
01:24:36,639 --> 01:24:39,120
i mean these rules are easy to check and

2307
01:24:39,120 --> 01:24:41,440
so in the end we only have to test about

2308
01:24:41,440 --> 01:24:45,199
two to the 14 or six and ah no wait it's

2309
01:24:45,199 --> 01:24:45,920
over

2310
01:24:45,920 --> 01:24:47,520
not so important

2311
01:24:47,520 --> 01:24:48,320
but

2312
01:24:48,320 --> 01:24:50,239
what made us is that we can then do all

2313
01:24:50,239 --> 01:24:52,960
these these checks uh in only a couple

2314
01:24:52,960 --> 01:24:54,880
of minutes

2315
01:24:54,880 --> 01:24:55,760
um

2316
01:24:55,760 --> 01:24:57,600
okay so let's

2317
01:24:57,600 --> 01:24:59,760
talk about a specific example so one of

2318
01:24:59,760 --> 01:25:01,120
our new attacks

2319
01:25:01,120 --> 01:25:04,159
is on the forum missy rfk construction

2320
01:25:04,159 --> 01:25:04,880
so

2321
01:25:04,880 --> 01:25:08,239
missy is here um it's kind of similar to

2322
01:25:08,239 --> 01:25:11,120
faisal but the round function is not a

2323
01:25:11,120 --> 01:25:13,199
here in the middle branch but one on the

2324
01:25:13,199 --> 01:25:14,800
side

2325
01:25:14,800 --> 01:25:18,400
and this rfk means that we consider

2326
01:25:18,400 --> 01:25:19,520
uh

2327
01:25:19,520 --> 01:25:21,760
i mean the round function is not a new

2328
01:25:21,760 --> 01:25:24,480
random function in every round but one

2329
01:25:24,480 --> 01:25:27,600
fixed function and then we add a one key

2330
01:25:27,600 --> 01:25:30,560
after we apply the d1 function

2331
01:25:30,560 --> 01:25:32,960
and so the the setup of our search for

2332
01:25:32,960 --> 01:25:36,560
this was that we just had one input node

2333
01:25:36,560 --> 01:25:38,000
which i mean just the input of the

2334
01:25:38,000 --> 01:25:40,960
function and then as gate functions we

2335
01:25:40,960 --> 01:25:41,679
had

2336
01:25:41,679 --> 01:25:43,840
xor and then the left part of the

2337
01:25:43,840 --> 01:25:45,280
encryption and the right part of the

2338
01:25:45,280 --> 01:25:46,560
encryption

2339
01:25:46,560 --> 01:25:49,040
and the the round function and also the

2340
01:25:49,040 --> 01:25:50,639
inverse of the one function so in

2341
01:25:50,639 --> 01:25:53,040
contrast to to physical we know that the

2342
01:25:53,040 --> 01:25:56,080
round function actually is invertible

2343
01:25:56,080 --> 01:25:57,840
and then as rules

2344
01:25:57,840 --> 01:25:59,920
of course we use this this normality so

2345
01:25:59,920 --> 01:26:01,520
that there are no nodes

2346
01:26:01,520 --> 01:26:03,840
that aren't used anymore or there are

2347
01:26:03,840 --> 01:26:05,840
also no nodes that compute essentially

2348
01:26:05,840 --> 01:26:06,960
the same

2349
01:26:06,960 --> 01:26:09,760
and then again also the xors should be

2350
01:26:09,760 --> 01:26:11,520
should be senior i already said that we

2351
01:26:11,520 --> 01:26:13,920
don't want to do like a x or a

2352
01:26:13,920 --> 01:26:16,560
also something like a x or b x or a also

2353
01:26:16,560 --> 01:26:17,840
makes no sense

2354
01:26:17,840 --> 01:26:20,000
and then since we have this f and f

2355
01:26:20,000 --> 01:26:22,800
inverse they also be good

2356
01:26:22,800 --> 01:26:24,480
this could also cancel out we also don't

2357
01:26:24,480 --> 01:26:26,480
want to do something like this

2358
01:26:26,480 --> 01:26:29,600
and one i mean one technicality

2359
01:26:29,600 --> 01:26:30,400
in

2360
01:26:30,400 --> 01:26:33,280
all our gates will take two inputs but

2361
01:26:33,280 --> 01:26:35,600
of course f only takes one input

2362
01:26:35,600 --> 01:26:37,360
and but in our implementation it

2363
01:26:37,360 --> 01:26:38,960
actually has to take two inputs but then

2364
01:26:38,960 --> 01:26:41,040
we just enforce that these inputs are

2365
01:26:41,040 --> 01:26:42,880
the same so in the end it's just one

2366
01:26:42,880 --> 01:26:44,159
input

2367
01:26:44,159 --> 01:26:45,760
okay and

2368
01:26:45,760 --> 01:26:48,239
so again here the trivial approach would

2369
01:26:48,239 --> 01:26:50,320
have been to to test two to the 25

2370
01:26:50,320 --> 01:26:53,040
circuits but with our

2371
01:26:53,040 --> 01:26:54,960
our approach we only need to check two

2372
01:26:54,960 --> 01:26:56,880
to the 18 rules and then

2373
01:26:56,880 --> 01:26:59,679
the the number of circuit that

2374
01:26:59,679 --> 01:27:01,440
let's say survive that have to be

2375
01:27:01,440 --> 01:27:03,679
checked for for periods is only two to

2376
01:27:03,679 --> 01:27:04,880
the twelve

2377
01:27:04,880 --> 01:27:07,760
and what i our search then finds is this

2378
01:27:07,760 --> 01:27:09,600
circuit

2379
01:27:09,600 --> 01:27:11,280
so we

2380
01:27:11,280 --> 01:27:13,280
take the input we apply the round

2381
01:27:13,280 --> 01:27:15,760
function we add the input again and this

2382
01:27:15,760 --> 01:27:18,480
is then the second so the right input

2383
01:27:18,480 --> 01:27:20,880
of one encryption query and the left

2384
01:27:20,880 --> 01:27:23,280
input is just our the input of the

2385
01:27:23,280 --> 01:27:24,800
function

2386
01:27:24,800 --> 01:27:26,000
then we

2387
01:27:26,000 --> 01:27:26,800
we

2388
01:27:26,800 --> 01:27:28,719
add

2389
01:27:28,719 --> 01:27:29,679
the

2390
01:27:29,679 --> 01:27:31,199
outputs

2391
01:27:31,199 --> 01:27:34,400
so the left and the right output and

2392
01:27:34,400 --> 01:27:36,639
we then see or we then can show i mean

2393
01:27:36,639 --> 01:27:38,880
the our implementation then tells you

2394
01:27:38,880 --> 01:27:40,800
that this has a period and then it's

2395
01:27:40,800 --> 01:27:43,360
easy to see or easy to verify that the

2396
01:27:43,360 --> 01:27:45,679
period is actually k0 and that means

2397
01:27:45,679 --> 01:27:48,000
that using simon's quantum

2398
01:27:48,000 --> 01:27:49,920
simon's quantum algorithm you then can

2399
01:27:49,920 --> 01:27:53,120
recover k0 with just a polynomial amount

2400
01:27:53,120 --> 01:27:56,480
of quantum queries to to the missing rf

2401
01:27:56,480 --> 01:27:58,400
uh construction and therefore this is

2402
01:27:58,400 --> 01:28:00,639
also then totally wrong

2403
01:28:00,639 --> 01:28:02,560
in the quantum setting

2404
01:28:02,560 --> 01:28:03,520
so we

2405
01:28:03,520 --> 01:28:05,199
have some more attacks

2406
01:28:05,199 --> 01:28:07,600
and all these constructions as we that

2407
01:28:07,600 --> 01:28:10,000
we studied or that i

2408
01:28:10,000 --> 01:28:14,080
give here were actually already

2409
01:28:14,080 --> 01:28:16,239
studied before but only distinguishers

2410
01:28:16,239 --> 01:28:20,159
were were found and these were actually

2411
01:28:20,159 --> 01:28:22,560
similar to to the

2412
01:28:22,560 --> 01:28:25,040
distinguishing attack by kovacado and

2413
01:28:25,040 --> 01:28:27,360
movie against the three-on-five so with

2414
01:28:27,360 --> 01:28:28,880
like constants

2415
01:28:28,880 --> 01:28:31,360
as input that switch based on on one

2416
01:28:31,360 --> 01:28:34,800
input bit and in contrast to that we

2417
01:28:34,800 --> 01:28:37,040
give key recovery attack so on forward

2418
01:28:37,040 --> 01:28:39,040
miss the fk that's the one i just showed

2419
01:28:39,040 --> 01:28:41,600
also on five won't miss the lfk

2420
01:28:41,600 --> 01:28:44,000
and on four and five four and five fk

2421
01:28:44,000 --> 01:28:45,199
with

2422
01:28:45,199 --> 01:28:47,679
um you know a small

2423
01:28:47,679 --> 01:28:50,080
small thing for the fifo and daddy

2424
01:28:50,080 --> 01:28:52,159
the uh round function must be a

2425
01:28:52,159 --> 01:28:54,639
permutation so invertible which strictly

2426
01:28:54,639 --> 01:28:56,880
speaking must not be the case for faisal

2427
01:28:56,880 --> 01:28:58,000
functions

2428
01:28:58,000 --> 01:29:00,239
and

2429
01:29:01,120 --> 01:29:02,080
one

2430
01:29:02,080 --> 01:29:03,760
one thing about these distinguishers of

2431
01:29:03,760 --> 01:29:06,159
course one could

2432
01:29:06,159 --> 01:29:07,679
you know use them to build key

2433
01:29:07,679 --> 01:29:09,920
recoveries based on for example the

2434
01:29:09,920 --> 01:29:12,480
government simon approach but then again

2435
01:29:12,480 --> 01:29:15,120
the the number of queries one needs is

2436
01:29:15,120 --> 01:29:16,080
not

2437
01:29:16,080 --> 01:29:18,880
not polynomial anymore more but

2438
01:29:18,880 --> 01:29:20,159
exponential

2439
01:29:20,159 --> 01:29:21,040
and

2440
01:29:21,040 --> 01:29:22,320
since we

2441
01:29:22,320 --> 01:29:24,400
only rely on simon's algorithm we only

2442
01:29:24,400 --> 01:29:26,639
need a polynomial amount of credits to

2443
01:29:26,639 --> 01:29:28,560
it

2444
01:29:28,560 --> 01:29:31,440
okay then let me quickly talk about the

2445
01:29:31,440 --> 01:29:33,600
generalization part so about our

2446
01:29:33,600 --> 01:29:35,199
negative result

2447
01:29:35,199 --> 01:29:37,520
and and

2448
01:29:37,520 --> 01:29:40,560
okay so let's first consider the fourier

2449
01:29:40,560 --> 01:29:43,679
transform of a boolean function f

2450
01:29:43,679 --> 01:29:44,880
which is just

2451
01:29:44,880 --> 01:29:47,360
you know the sum of all y

2452
01:29:47,360 --> 01:29:50,159
uh of negative one to the inner product

2453
01:29:50,159 --> 01:29:53,280
of x and y plus the the

2454
01:29:53,280 --> 01:29:56,159
function evaluated evaluated at y

2455
01:29:56,159 --> 01:29:59,520
and we can rewrite this as the the

2456
01:29:59,520 --> 01:30:02,480
matrix product of h0 so the standard

2457
01:30:02,480 --> 01:30:05,760
data matrix which is i mean just the the

2458
01:30:05,760 --> 01:30:08,320
entry at x y is negative one to the

2459
01:30:08,320 --> 01:30:10,960
inner product of x and y

2460
01:30:10,960 --> 01:30:12,480
and

2461
01:30:12,480 --> 01:30:15,520
we multiply this with the vector where

2462
01:30:15,520 --> 01:30:17,840
we just take

2463
01:30:17,840 --> 01:30:21,199
the the function value to to a negative

2464
01:30:21,199 --> 01:30:23,520
or we take negative 1 to the the value

2465
01:30:23,520 --> 01:30:25,920
of the function at this point

2466
01:30:25,920 --> 01:30:28,159
and

2467
01:30:28,159 --> 01:30:29,040
now

2468
01:30:29,040 --> 01:30:29,920
if we

2469
01:30:29,920 --> 01:30:31,600
actually we don't really study simon's

2470
01:30:31,600 --> 01:30:34,080
algorithm but but the bernstein vasirani

2471
01:30:34,080 --> 01:30:36,159
circuit which is

2472
01:30:36,159 --> 01:30:38,560
rather close to simon so it's not a big

2473
01:30:38,560 --> 01:30:41,280
deal but there essentially the circuit

2474
01:30:41,280 --> 01:30:43,280
in the quantum attack

2475
01:30:43,280 --> 01:30:46,080
yields a vector from the

2476
01:30:46,080 --> 01:30:47,440
the span of

2477
01:30:47,440 --> 01:30:50,000
all the points that lead to a non-zero

2478
01:30:50,000 --> 01:30:52,239
for a coefficient

2479
01:30:52,239 --> 01:30:53,840
and now if we

2480
01:30:53,840 --> 01:30:55,840
uh consider a function that is

2481
01:30:55,840 --> 01:30:58,480
essentially as in simon's promise so

2482
01:30:58,480 --> 01:31:00,480
there is a unique period s

2483
01:31:00,480 --> 01:31:02,960
then we would have that uh

2484
01:31:02,960 --> 01:31:04,800
this this vector as such that the inner

2485
01:31:04,800 --> 01:31:08,239
product of the secret period is zero so

2486
01:31:08,239 --> 01:31:10,320
this is why where this comes from why

2487
01:31:10,320 --> 01:31:12,239
this is close to simon

2488
01:31:12,239 --> 01:31:15,199
and now our generalization is that we

2489
01:31:15,199 --> 01:31:17,760
look at i mean like a slightly different

2490
01:31:17,760 --> 01:31:19,280
transform

2491
01:31:19,280 --> 01:31:21,440
where we don't use the the standard

2492
01:31:21,440 --> 01:31:24,639
hadamard matrix anymore but just any

2493
01:31:24,639 --> 01:31:27,280
part of our matrix so just a quick

2494
01:31:27,280 --> 01:31:29,280
reminder hadamard means that the

2495
01:31:29,280 --> 01:31:31,360
transform of the matrix times the matrix

2496
01:31:31,360 --> 01:31:33,600
is the identity and of course the the

2497
01:31:33,600 --> 01:31:36,159
entries are

2498
01:31:36,400 --> 01:31:38,880
negative one two to some function g on

2499
01:31:38,880 --> 01:31:40,320
the base

2500
01:31:40,320 --> 01:31:42,800
that takes its input the entry

2501
01:31:42,800 --> 01:31:44,960
and now the the question network is what

2502
01:31:44,960 --> 01:31:46,080
meaningful

2503
01:31:46,080 --> 01:31:49,040
properties of f we could catch with some

2504
01:31:49,040 --> 01:31:52,560
or such a non-solid hadamard matrix

2505
01:31:52,560 --> 01:31:55,040
and especially we are interested in

2506
01:31:55,040 --> 01:31:56,719
whether we could

2507
01:31:56,719 --> 01:31:58,159
find out something about linear

2508
01:31:58,159 --> 01:31:59,679
invariant properties because in

2509
01:31:59,679 --> 01:32:01,679
symmetric cryptanalysis all the

2510
01:32:01,679 --> 01:32:04,000
properties that are interesting or most

2511
01:32:04,000 --> 01:32:05,840
of them like linearity differential

2512
01:32:05,840 --> 01:32:08,480
uniformity and the algebraic degree

2513
01:32:08,480 --> 01:32:10,800
are all linear and variant and that this

2514
01:32:10,800 --> 01:32:14,239
means that for um

2515
01:32:14,239 --> 01:32:15,840
for any inverter

2516
01:32:15,840 --> 01:32:17,679
invertible matrix a

2517
01:32:17,679 --> 01:32:20,960
f satisfies this property if and only if

2518
01:32:20,960 --> 01:32:22,719
f after a does

2519
01:32:22,719 --> 01:32:26,480
and now our main theorem here is that

2520
01:32:26,480 --> 01:32:28,560
and if for any a

2521
01:32:28,560 --> 01:32:31,280
there exists a b so both invertible

2522
01:32:31,280 --> 01:32:32,800
matrices

2523
01:32:32,800 --> 01:32:35,040
such that for all f's we have that

2524
01:32:35,040 --> 01:32:37,760
this this transform regarding h

2525
01:32:37,760 --> 01:32:40,480
of f after a is the same as the

2526
01:32:40,480 --> 01:32:42,960
transform of f after b

2527
01:32:42,960 --> 01:32:46,639
then h is equivalent to h0 and

2528
01:32:46,639 --> 01:32:48,639
this means that if h is not equivalent

2529
01:32:48,639 --> 01:32:51,280
to h0 then we cannot

2530
01:32:51,280 --> 01:32:52,239
catch

2531
01:32:52,239 --> 01:32:54,239
a linear invariant properties and

2532
01:32:54,239 --> 01:32:55,440
therefore we

2533
01:32:55,440 --> 01:32:57,679
believe that the standard hardware

2534
01:32:57,679 --> 01:32:59,679
matrix is is the way to go if you want

2535
01:32:59,679 --> 01:33:01,120
to study

2536
01:33:01,120 --> 01:33:02,960
or if you want to to

2537
01:33:02,960 --> 01:33:05,840
use this for symmetric cryptanalysis

2538
01:33:05,840 --> 01:33:10,320
okay so let me quickly recap the talk

2539
01:33:10,320 --> 01:33:11,520
so we have

2540
01:33:11,520 --> 01:33:13,920
had two contributions first the

2541
01:33:13,920 --> 01:33:15,440
automatized

2542
01:33:15,440 --> 01:33:16,480
uh

2543
01:33:16,480 --> 01:33:18,639
applications and there we

2544
01:33:18,639 --> 01:33:20,880
developed a way to to automatically

2545
01:33:20,880 --> 01:33:22,400
search for

2546
01:33:22,400 --> 01:33:23,840
quantum attacks based on simon's

2547
01:33:23,840 --> 01:33:25,040
algorithm

2548
01:33:25,040 --> 01:33:28,159
which only take a polynomial amount of

2549
01:33:28,159 --> 01:33:30,960
quantum queries and we use this to

2550
01:33:30,960 --> 01:33:32,800
actually find new attacks against the

2551
01:33:32,800 --> 01:33:35,199
misty and deviser construction and for

2552
01:33:35,199 --> 01:33:37,199
the generalization part we study

2553
01:33:37,199 --> 01:33:39,760
generalizations of simon's algorithm and

2554
01:33:39,760 --> 01:33:42,320
also the fourier transform thereby

2555
01:33:42,320 --> 01:33:44,320
and there we concluded that the standard

2556
01:33:44,320 --> 01:33:47,600
hadamard matrix is the best choice if

2557
01:33:47,600 --> 01:33:49,280
you want to study

2558
01:33:49,280 --> 01:33:51,679
symmetric or properties that are

2559
01:33:51,679 --> 01:33:54,000
relevant for symmetric analysis

2560
01:33:54,000 --> 01:33:56,239
and so if you interested in our work the

2561
01:33:56,239 --> 01:33:58,960
full version is available on eprint and

2562
01:33:58,960 --> 01:34:01,280
sage implementation

2563
01:34:01,280 --> 01:34:03,520
of our code to search for the periods is

2564
01:34:03,520 --> 01:34:04,480
available

2565
01:34:04,480 --> 01:34:06,080
on github and

2566
01:34:06,080 --> 01:34:07,679
if you have any further questions or

2567
01:34:07,679 --> 01:34:10,239
want to contact us then these are our

2568
01:34:10,239 --> 01:34:13,280
mail address and that's it for my site

2569
01:34:13,280 --> 01:34:16,920
and thank you

2570
01:34:20,480 --> 01:34:23,199
so are there any questions for luca

2571
01:34:23,199 --> 01:34:27,040
yes please go to go to the mic please

2572
01:34:27,520 --> 01:34:30,080
and i my computer died so if there are

2573
01:34:30,080 --> 01:34:32,880
any questions in zoom uh please could

2574
01:34:32,880 --> 01:34:34,480
someone let us know

2575
01:34:34,480 --> 01:34:36,320
okay i was just going to ask have you

2576
01:34:36,320 --> 01:34:38,560
looked at any of the hashing like the

2577
01:34:38,560 --> 01:34:40,239
compression function

2578
01:34:40,239 --> 01:34:41,840
kind of structures the things where you

2579
01:34:41,840 --> 01:34:44,239
have the block cipher and then the and

2580
01:34:44,239 --> 01:34:46,400
you're using the the key and feeding

2581
01:34:46,400 --> 01:34:48,560
forward or something like that

2582
01:34:48,560 --> 01:34:51,199
we looked uh also

2583
01:34:51,199 --> 01:34:53,119
for example at hashcount and something

2584
01:34:53,119 --> 01:34:56,880
like this there were also again

2585
01:34:56,880 --> 01:34:59,520
attacks already known which we could

2586
01:34:59,520 --> 01:35:01,199
also rediscover

2587
01:35:01,199 --> 01:35:04,239
and i guess we also i mean we can also

2588
01:35:04,239 --> 01:35:06,080
use essentially the same idea to to

2589
01:35:06,080 --> 01:35:07,840
search for a text based on the

2590
01:35:07,840 --> 01:35:09,360
government simon

2591
01:35:09,360 --> 01:35:11,119
approach and there we also find some

2592
01:35:11,119 --> 01:35:12,880
attacks

2593
01:35:12,880 --> 01:35:15,600
i guess on the permutation based edm

2594
01:35:15,600 --> 01:35:17,360
construction and

2595
01:35:17,360 --> 01:35:19,679
something else i think i just forgot but

2596
01:35:19,679 --> 01:35:20,960
yeah so

2597
01:35:20,960 --> 01:35:22,480
we looked at some construction but i'm

2598
01:35:22,480 --> 01:35:24,320
not sure whether these are actually the

2599
01:35:24,320 --> 01:35:26,560
ones you were talking about but thank

2600
01:35:26,560 --> 01:35:29,199
you

2601
01:35:29,199 --> 01:35:31,679
thank you i i have a question look at

2602
01:35:31,679 --> 01:35:32,639
have you

2603
01:35:32,639 --> 01:35:34,560
had a look or do you think it could be

2604
01:35:34,560 --> 01:35:36,639
adapted your tool in

2605
01:35:36,639 --> 01:35:39,520
some cases uh we do an exoplanet search

2606
01:35:39,520 --> 01:35:40,800
of

2607
01:35:40,800 --> 01:35:43,600
part of the key and then try to find the

2608
01:35:43,600 --> 01:35:46,000
if it applies simon in the

2609
01:35:46,000 --> 01:35:47,679
in the states or combining global

2610
01:35:47,679 --> 01:35:49,199
segment do you think you could detect

2611
01:35:49,199 --> 01:35:51,520
this kind of attacks

2612
01:35:51,520 --> 01:35:53,679
you know like i just said we can i mean

2613
01:35:53,679 --> 01:35:55,679
essentially use the same tool and like

2614
01:35:55,679 --> 01:35:58,800
add another node which is then

2615
01:35:58,800 --> 01:36:00,000
essentially the part where you would

2616
01:36:00,000 --> 01:36:01,440
apply grover

2617
01:36:01,440 --> 01:36:03,920
to do this and yeah you could do this

2618
01:36:03,920 --> 01:36:05,840
but this of course then

2619
01:36:05,840 --> 01:36:08,880
increases the runtime so

2620
01:36:08,880 --> 01:36:13,440
okay thanks are there any more questions

2621
01:36:14,560 --> 01:36:16,800
okay there are no more questions then

2622
01:36:16,800 --> 01:36:18,239
we'll thank you again lucas and all the

2623
01:36:18,239 --> 01:36:21,799
speakers of this session

2624
01:36:24,080 --> 01:36:26,000
think there's a break until half past

2625
01:36:26,000 --> 01:36:28,800
four now right

