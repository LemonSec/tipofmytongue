1
00:00:00,160 --> 00:00:03,679
second session of uh today's program and

2
00:00:03,679 --> 00:00:04,480
uh

3
00:00:04,480 --> 00:00:06,960
topic is uh blockchain

4
00:00:06,960 --> 00:00:08,960
and there are three talks

5
00:00:08,960 --> 00:00:10,639
the first talk being ophelimos

6
00:00:10,639 --> 00:00:12,799
combinatorial optimization via proof of

7
00:00:12,799 --> 00:00:14,000
useful work

8
00:00:14,000 --> 00:00:16,400
matthias fizzy will be giving to talk

9
00:00:16,400 --> 00:00:19,799
please go ahead

10
00:00:36,719 --> 00:00:39,440
okay this is joint work with aguilos

11
00:00:39,440 --> 00:00:42,160
guys um jurgos

12
00:00:42,160 --> 00:00:45,199
banayo tacos

13
00:00:46,239 --> 00:00:47,840
the purpose of a

14
00:00:47,840 --> 00:00:50,719
permission permissionless blockchain is

15
00:00:50,719 --> 00:00:54,000
to maintain a transactional

16
00:00:54,000 --> 00:00:55,840
ledger

17
00:00:55,840 --> 00:00:57,520
by

18
00:00:57,520 --> 00:00:59,600
maintaining an ever growing list of

19
00:00:59,600 --> 00:01:02,320
transactions and we want to achieve that

20
00:01:02,320 --> 00:01:04,239
in a way that public

21
00:01:04,239 --> 00:01:05,760
that maintenance of that ledger is

22
00:01:05,760 --> 00:01:08,720
totally public open to the public

23
00:01:08,720 --> 00:01:10,960
but that now introduces the problem that

24
00:01:10,960 --> 00:01:13,839
the adversary might

25
00:01:14,080 --> 00:01:16,880
execute the so-called civil attack

26
00:01:16,880 --> 00:01:18,560
wherein he

27
00:01:18,560 --> 00:01:20,799
tries to assume many different

28
00:01:20,799 --> 00:01:22,640
identities and try to

29
00:01:22,640 --> 00:01:25,200
overwhelm his power on the system like

30
00:01:25,200 --> 00:01:28,000
that and that's why we introduce a

31
00:01:28,000 --> 00:01:30,880
resource-based lottery

32
00:01:30,880 --> 00:01:33,200
where the participants in this in the

33
00:01:33,200 --> 00:01:36,400
system have to prove possession

34
00:01:36,400 --> 00:01:38,000
of a research

35
00:01:38,000 --> 00:01:40,479
in order to qualify for such a ledger

36
00:01:40,479 --> 00:01:42,640
update

37
00:01:42,640 --> 00:01:45,119
uh the most prominent example of such a

38
00:01:45,119 --> 00:01:48,000
blockchain of course is nakamoto's uh

39
00:01:48,000 --> 00:01:49,600
bitcoin

40
00:01:49,600 --> 00:01:51,360
which is based off

41
00:01:51,360 --> 00:01:53,920
proof on proof of work which is

42
00:01:53,920 --> 00:01:55,280
originally

43
00:01:55,280 --> 00:01:58,320
uh originates from dworken hour and the

44
00:01:58,320 --> 00:02:00,240
term was was

45
00:02:00,240 --> 00:02:04,079
coined by jakobson and jules

46
00:02:04,079 --> 00:02:06,960
and there the idea is that you challenge

47
00:02:06,960 --> 00:02:09,360
a client who wants to do something and

48
00:02:09,360 --> 00:02:12,160
upon that challenge he has to

49
00:02:12,160 --> 00:02:14,480
solve a moderately hard puzzle in order

50
00:02:14,480 --> 00:02:18,080
to qualify to operate on that challenge

51
00:02:18,080 --> 00:02:19,280
now

52
00:02:19,280 --> 00:02:21,520
the drawback of that is that this leads

53
00:02:21,520 --> 00:02:24,080
to energy waste because these proof of

54
00:02:24,080 --> 00:02:25,120
works

55
00:02:25,120 --> 00:02:27,040
serve nothing else than basically

56
00:02:27,040 --> 00:02:29,360
maintaining the ledger

57
00:02:29,360 --> 00:02:30,720
and

58
00:02:30,720 --> 00:02:34,319
even more so the energy waste

59
00:02:34,319 --> 00:02:37,360
that the system basically requires

60
00:02:37,360 --> 00:02:39,760
scales with the security of the system

61
00:02:39,760 --> 00:02:41,519
so the more you want the system to be

62
00:02:41,519 --> 00:02:44,239
secure the more computing power has to

63
00:02:44,239 --> 00:02:46,879
be dedicated to the system

64
00:02:46,879 --> 00:02:49,360
and as of now bitcoin actually has the

65
00:02:49,360 --> 00:02:52,560
carbon footprint of greece

66
00:02:52,560 --> 00:02:54,959
although that pollution has the

67
00:02:54,959 --> 00:02:57,680
advantage that it typically stays in

68
00:02:57,680 --> 00:02:59,599
athens so it doesn't have a global

69
00:02:59,599 --> 00:03:02,000
impact

70
00:03:02,080 --> 00:03:04,400
so but there are alternatives

71
00:03:04,400 --> 00:03:05,200
uh

72
00:03:05,200 --> 00:03:07,760
for that and one of them is uh proof of

73
00:03:07,760 --> 00:03:09,519
space

74
00:03:09,519 --> 00:03:11,440
devised by

75
00:03:11,440 --> 00:03:14,400
uh jambovsky faust kolmogorov and

76
00:03:14,400 --> 00:03:15,599
bietchak

77
00:03:15,599 --> 00:03:17,360
where you just

78
00:03:17,360 --> 00:03:20,000
this resource of computer computing

79
00:03:20,000 --> 00:03:22,000
power against

80
00:03:22,000 --> 00:03:24,080
data storage

81
00:03:24,080 --> 00:03:27,120
another alternative is to apply proof of

82
00:03:27,120 --> 00:03:31,200
stake such as snow white algorand

83
00:03:31,200 --> 00:03:32,959
or aborts

84
00:03:32,959 --> 00:03:33,840
but

85
00:03:33,840 --> 00:03:37,280
such systems are based on different set

86
00:03:37,280 --> 00:03:39,599
of assumptions so the idea of proof of

87
00:03:39,599 --> 00:03:40,560
stake

88
00:03:40,560 --> 00:03:43,360
is that you can execute influence on the

89
00:03:43,360 --> 00:03:44,400
system

90
00:03:44,400 --> 00:03:47,519
depending on the number of coins you you

91
00:03:47,519 --> 00:03:49,120
own in the system

92
00:03:49,120 --> 00:03:51,760
and then the third one is uh proof of

93
00:03:51,760 --> 00:03:53,360
useful work

94
00:03:53,360 --> 00:03:56,080
which this work is about

95
00:03:56,080 --> 00:03:58,239
so what is proof of use will work which

96
00:03:58,239 --> 00:04:01,040
is pro um we just

97
00:04:01,040 --> 00:04:04,000
execute this pro uh proof of work but we

98
00:04:04,000 --> 00:04:05,280
are trying to

99
00:04:05,280 --> 00:04:07,760
repurpose this work for a computation

100
00:04:07,760 --> 00:04:09,120
that is of real

101
00:04:09,120 --> 00:04:10,959
world benefit

102
00:04:10,959 --> 00:04:12,799
so there is previous work on this there

103
00:04:12,799 --> 00:04:16,478
is this prime coin

104
00:04:16,478 --> 00:04:18,720
blockchain by king

105
00:04:18,720 --> 00:04:21,199
which basically consists of or the

106
00:04:21,199 --> 00:04:23,440
useful work that consists of of

107
00:04:23,440 --> 00:04:24,560
computing

108
00:04:24,560 --> 00:04:27,280
new large prime numbers and this

109
00:04:27,280 --> 00:04:30,000
application is maybe not so useful after

110
00:04:30,000 --> 00:04:30,800
all

111
00:04:30,800 --> 00:04:34,000
and also the the protocol is not proven

112
00:04:34,000 --> 00:04:35,199
secure

113
00:04:35,199 --> 00:04:37,680
there is work on resource efficient

114
00:04:37,680 --> 00:04:39,600
mining by zhang

115
00:04:39,600 --> 00:04:40,840
ayal

116
00:04:40,840 --> 00:04:44,320
esgrivar jules and juan vanessa

117
00:04:44,320 --> 00:04:46,400
but this is actually a good solution but

118
00:04:46,400 --> 00:04:49,759
it is based on trustee toddler

119
00:04:49,759 --> 00:04:52,639
and there is a whole line of about

120
00:04:52,639 --> 00:04:55,520
distributed problem solving

121
00:04:55,520 --> 00:04:57,759
but all these works basically work

122
00:04:57,759 --> 00:05:00,479
without the formal analysis and actually

123
00:05:00,479 --> 00:05:02,240
there is a volatile or belief in the

124
00:05:02,240 --> 00:05:04,880
bitcoin community that actually the work

125
00:05:04,880 --> 00:05:08,080
you invest into a proof of

126
00:05:08,080 --> 00:05:08,840
work

127
00:05:08,840 --> 00:05:12,560
system has to be essentially you useless

128
00:05:12,560 --> 00:05:14,880
for anything else in order to achieve

129
00:05:14,880 --> 00:05:15,919
blockchain

130
00:05:15,919 --> 00:05:17,039
security

131
00:05:17,039 --> 00:05:19,199
and basically this this

132
00:05:19,199 --> 00:05:22,160
belief is founded on the fallen

133
00:05:22,160 --> 00:05:24,479
dilemma basically that

134
00:05:24,479 --> 00:05:27,759
if you want the compute the computation

135
00:05:27,759 --> 00:05:29,680
to be truly useful

136
00:05:29,680 --> 00:05:31,280
you'll have to

137
00:05:31,280 --> 00:05:34,240
that means uh using real world problems

138
00:05:34,240 --> 00:05:37,919
um you have to be careful that the gerry

139
00:05:37,919 --> 00:05:39,600
necessary does not inject problem

140
00:05:39,600 --> 00:05:42,160
instances of which he already knows the

141
00:05:42,160 --> 00:05:43,280
solution

142
00:05:43,280 --> 00:05:45,120
and so on the other hand if you want it

143
00:05:45,120 --> 00:05:47,360
to be secure maybe it's better to pose

144
00:05:47,360 --> 00:05:51,600
totally useless pseudorandom instances

145
00:05:51,600 --> 00:05:53,759
we solve this dilemma

146
00:05:53,759 --> 00:05:57,360
by giving a proof of blockchain

147
00:05:57,360 --> 00:06:00,160
protocol which solves

148
00:06:00,160 --> 00:06:03,840
hard optimization problems

149
00:06:04,080 --> 00:06:05,120
and

150
00:06:05,120 --> 00:06:07,120
by that i mean real world client

151
00:06:07,120 --> 00:06:09,360
problems such as

152
00:06:09,360 --> 00:06:11,919
problems in logistics or or scheduling

153
00:06:11,919 --> 00:06:13,680
problems or or

154
00:06:13,680 --> 00:06:16,000
sub solving

155
00:06:16,000 --> 00:06:18,880
we give formal security proof in the

156
00:06:18,880 --> 00:06:20,880
random oracle model

157
00:06:20,880 --> 00:06:22,560
we achieve

158
00:06:22,560 --> 00:06:25,440
up to one half of adversarial computing

159
00:06:25,440 --> 00:06:27,280
power or security against such an

160
00:06:27,280 --> 00:06:29,360
adversary

161
00:06:29,360 --> 00:06:31,919
where we assume the

162
00:06:31,919 --> 00:06:34,479
adversary to be weak in the sense that

163
00:06:34,479 --> 00:06:38,240
he has no speed up computing the useful

164
00:06:38,240 --> 00:06:39,759
computation

165
00:06:39,759 --> 00:06:41,680
in comparison to the the honest

166
00:06:41,680 --> 00:06:43,120
participants

167
00:06:43,120 --> 00:06:45,520
but then the security can downgrade to

168
00:06:45,520 --> 00:06:48,479
one third uh only tolerating one third

169
00:06:48,479 --> 00:06:50,400
of the adversarial computing power

170
00:06:50,400 --> 00:06:52,240
assuming a strong adversary where we

171
00:06:52,240 --> 00:06:54,160
assume that the adversary can basically

172
00:06:54,160 --> 00:06:57,360
compute the useful work for free

173
00:06:57,360 --> 00:07:00,639
and then we also analyze the usefulness

174
00:07:00,639 --> 00:07:03,520
rate of this protocol which by which we

175
00:07:03,520 --> 00:07:06,240
mean the rate of computation a miner

176
00:07:06,240 --> 00:07:08,960
really spends on the useful computation

177
00:07:08,960 --> 00:07:11,919
rather than do do other computations

178
00:07:11,919 --> 00:07:14,560
that may or may not be necessary to to

179
00:07:14,560 --> 00:07:17,360
do to achieve such a proof of useful

180
00:07:17,360 --> 00:07:18,880
work query

181
00:07:18,880 --> 00:07:21,280
and so if the the app the runtime

182
00:07:21,280 --> 00:07:23,680
distribution of the user work algorithm

183
00:07:23,680 --> 00:07:27,360
is uh well distribute well concentrated

184
00:07:27,360 --> 00:07:30,080
around the mean we can actually achieve

185
00:07:30,080 --> 00:07:32,240
usefulness one

186
00:07:32,240 --> 00:07:35,440
um assuming the weak adversary above

187
00:07:35,440 --> 00:07:38,720
that has no speed up for useful work we

188
00:07:38,720 --> 00:07:41,280
achieve roughly one half usefulness for

189
00:07:41,280 --> 00:07:42,880
the same

190
00:07:42,880 --> 00:07:45,599
kind of characteristics we need for the

191
00:07:45,599 --> 00:07:47,280
useful work

192
00:07:47,280 --> 00:07:49,599
algorithm but under us assumption of the

193
00:07:49,599 --> 00:07:51,759
strong adversary that basically does not

194
00:07:51,759 --> 00:07:54,160
compute the useful work

195
00:07:54,160 --> 00:07:56,319
but then i also have to mention that the

196
00:07:56,319 --> 00:07:59,520
usefulness can deteriorate quickly if

197
00:07:59,520 --> 00:08:01,840
you do bad choices of your

198
00:08:01,840 --> 00:08:03,680
useful work

199
00:08:03,680 --> 00:08:06,240
uh algorithm so so so the the right

200
00:08:06,240 --> 00:08:08,319
choice here is is really crucial and we

201
00:08:08,319 --> 00:08:10,000
achieved this without

202
00:08:10,000 --> 00:08:11,120
using

203
00:08:11,120 --> 00:08:13,520
any trusted hardware or third-parties

204
00:08:13,520 --> 00:08:16,159
assumptions

205
00:08:16,800 --> 00:08:18,560
okay

206
00:08:18,560 --> 00:08:21,680
so let me briefly sketch what happens in

207
00:08:21,680 --> 00:08:24,639
pof in in standard proof of work in

208
00:08:24,639 --> 00:08:27,120
bitcoin in order to mine the block you

209
00:08:27,120 --> 00:08:29,120
just

210
00:08:29,120 --> 00:08:31,520
repeatedly try to achieve

211
00:08:31,520 --> 00:08:34,719
to obtain the longest chain of blocks

212
00:08:34,719 --> 00:08:36,958
and then you try to append this along

213
00:08:36,958 --> 00:08:39,440
the chain by a new block you manufacture

214
00:08:39,440 --> 00:08:40,479
yourself

215
00:08:40,479 --> 00:08:43,919
and then you hash this block

216
00:08:44,480 --> 00:08:46,000
you hash this block and then you see

217
00:08:46,000 --> 00:08:47,680
whether the hash value is below a

218
00:08:47,680 --> 00:08:50,480
certain threshold and that will allow

219
00:08:50,480 --> 00:08:52,560
you to publish the block otherwise

220
00:08:52,560 --> 00:08:55,120
you'll just vary a counter in the in the

221
00:08:55,120 --> 00:08:56,160
block

222
00:08:56,160 --> 00:08:58,640
until you hit that hash value below the

223
00:08:58,640 --> 00:08:59,680
target

224
00:08:59,680 --> 00:09:01,920
and then it's an essential observation

225
00:09:01,920 --> 00:09:04,640
here basically for this

226
00:09:04,640 --> 00:09:08,560
work step we apply in this loop is that

227
00:09:08,560 --> 00:09:11,519
that this evaluation in this case of

228
00:09:11,519 --> 00:09:13,600
this hash function

229
00:09:13,600 --> 00:09:15,600
should be relatively fast because

230
00:09:15,600 --> 00:09:17,040
otherwise you'll obtain bad

231
00:09:17,040 --> 00:09:18,880
characteristics of your blockchain

232
00:09:18,880 --> 00:09:22,399
protocol but this now can be offset by

233
00:09:22,399 --> 00:09:26,080
uh by by regulating this threshold such

234
00:09:26,080 --> 00:09:29,680
that you only have a moderately hard

235
00:09:29,680 --> 00:09:31,760
success probability

236
00:09:31,760 --> 00:09:34,959
so when trying to inject our useful work

237
00:09:34,959 --> 00:09:37,680
here now we have to make the following

238
00:09:37,680 --> 00:09:40,320
observation basically we require that

239
00:09:40,320 --> 00:09:41,760
the whole

240
00:09:41,760 --> 00:09:43,920
useful work problem instance we are

241
00:09:43,920 --> 00:09:47,040
working on is non-trivial

242
00:09:47,040 --> 00:09:49,040
and that's because otherwise clients

243
00:09:49,040 --> 00:09:51,200
would not be incentivized to delegate

244
00:09:51,200 --> 00:09:53,040
computation to the blockchain rather

245
00:09:53,040 --> 00:09:55,279
solves them quickly at home

246
00:09:55,279 --> 00:09:56,160
um

247
00:09:56,160 --> 00:09:58,240
and so but in order to keep the

248
00:09:58,240 --> 00:10:00,720
essential property of above that inside

249
00:10:00,720 --> 00:10:03,360
this loop the computation span should

250
00:10:03,360 --> 00:10:05,440
not be too high

251
00:10:05,440 --> 00:10:06,399
um

252
00:10:06,399 --> 00:10:09,519
we actually need a useful work algorithm

253
00:10:09,519 --> 00:10:12,160
that is decomposable in

254
00:10:12,160 --> 00:10:15,360
more or less little uniform steps right

255
00:10:15,360 --> 00:10:19,839
and so what's a good class of algorithms

256
00:10:19,839 --> 00:10:22,160
to fit this useful work

257
00:10:22,160 --> 00:10:24,399
we want to inject here is local

258
00:10:24,399 --> 00:10:25,600
statistic

259
00:10:25,600 --> 00:10:26,880
search

260
00:10:26,880 --> 00:10:29,040
stochastic local search

261
00:10:29,040 --> 00:10:32,480
and so let me briefly sketch this

262
00:10:32,480 --> 00:10:35,519
sls is is applied to computationally

263
00:10:35,519 --> 00:10:37,440
hard optimization problems like

264
00:10:37,440 --> 00:10:39,279
traveling salesmen

265
00:10:39,279 --> 00:10:40,720
for which

266
00:10:40,720 --> 00:10:43,600
efficient deterministic algorithms are

267
00:10:43,600 --> 00:10:44,959
not known

268
00:10:44,959 --> 00:10:47,519
and so how does it work we have this

269
00:10:47,519 --> 00:10:50,959
state space of possible solution

270
00:10:50,959 --> 00:10:53,120
uh we map it to a

271
00:10:53,120 --> 00:10:55,519
objective function judging the quality

272
00:10:55,519 --> 00:10:57,600
of such a solution and then we just

273
00:10:57,600 --> 00:10:59,920
perform a work a random walk in these

274
00:10:59,920 --> 00:11:01,680
states in this

275
00:11:01,680 --> 00:11:03,200
state space

276
00:11:03,200 --> 00:11:05,200
with the goal to find the state that

277
00:11:05,200 --> 00:11:06,560
minimizes the

278
00:11:06,560 --> 00:11:10,000
objective function and we do that by by

279
00:11:10,000 --> 00:11:12,320
repetitive application of the so-called

280
00:11:12,320 --> 00:11:15,440
exploration step that goes to one state

281
00:11:15,440 --> 00:11:17,200
and then explorates

282
00:11:17,200 --> 00:11:19,440
explores the neighborhood of that state

283
00:11:19,440 --> 00:11:22,640
and then the re reveals a new state s

284
00:11:22,640 --> 00:11:26,000
prime and so on and so on and then we're

285
00:11:26,000 --> 00:11:28,560
trying to find find a good solution by

286
00:11:28,560 --> 00:11:31,360
involving some some a certain

287
00:11:31,360 --> 00:11:33,920
termination criteria for the research

288
00:11:33,920 --> 00:11:37,200
maybe let me mention that

289
00:11:37,200 --> 00:11:38,480
that

290
00:11:38,480 --> 00:11:41,279
basil is highly relevant in practice

291
00:11:41,279 --> 00:11:44,480
it's it's used in a lot of real economy

292
00:11:44,480 --> 00:11:46,079
logistics problem

293
00:11:46,079 --> 00:11:48,320
the nfl schedule

294
00:11:48,320 --> 00:11:51,200
sports schedule is is calculated by

295
00:11:51,200 --> 00:11:52,800
using sls

296
00:11:52,800 --> 00:11:56,639
and it's also good for set solving

297
00:11:56,639 --> 00:12:01,360
uh to make our sls fit for our proof of

298
00:12:01,360 --> 00:12:02,639
useful work

299
00:12:02,639 --> 00:12:05,200
uh we transform it in what we call

300
00:12:05,200 --> 00:12:08,320
doubly parallel local search

301
00:12:08,320 --> 00:12:10,399
and that is we when the

302
00:12:10,399 --> 00:12:13,279
problem is initialized we actually

303
00:12:13,279 --> 00:12:16,639
spread it into operating multiple

304
00:12:16,639 --> 00:12:19,920
threads state update threads

305
00:12:19,920 --> 00:12:22,720
in contrast to how it looked before

306
00:12:22,720 --> 00:12:25,760
and that would be that would be

307
00:12:25,760 --> 00:12:28,480
basically one source of uh parallelism

308
00:12:28,480 --> 00:12:30,320
and the reason for that is that we don't

309
00:12:30,320 --> 00:12:31,920
want too many

310
00:12:31,920 --> 00:12:33,279
miners to

311
00:12:33,279 --> 00:12:35,680
try to explore on the same state because

312
00:12:35,680 --> 00:12:37,600
that would cause overhead

313
00:12:37,600 --> 00:12:39,839
and then when you're ready

314
00:12:39,839 --> 00:12:42,880
or when you're trying to update

315
00:12:42,880 --> 00:12:45,040
this sls computation

316
00:12:45,040 --> 00:12:48,720
then inside your your algorithm trying

317
00:12:48,720 --> 00:12:51,760
to find the block you you execute many

318
00:12:51,760 --> 00:12:54,399
instances of the same computation

319
00:12:54,399 --> 00:12:55,519
on

320
00:12:55,519 --> 00:12:58,880
the state you're focusing in on on your

321
00:12:58,880 --> 00:13:01,440
specific

322
00:13:01,440 --> 00:13:02,320
threat

323
00:13:02,320 --> 00:13:04,720
and then from all these

324
00:13:04,720 --> 00:13:06,959
executions you try to pick or you pick

325
00:13:06,959 --> 00:13:08,639
and publish the

326
00:13:08,639 --> 00:13:10,399
the best solution together with your

327
00:13:10,399 --> 00:13:13,360
blogs block and transactions and so this

328
00:13:13,360 --> 00:13:15,760
is the second level of

329
00:13:15,760 --> 00:13:18,839
parallelism we have here

330
00:13:18,839 --> 00:13:20,480
um

331
00:13:20,480 --> 00:13:22,560
yeah and so let me try to give a

332
00:13:22,560 --> 00:13:25,600
stepwise construction that leads

333
00:13:25,600 --> 00:13:29,120
from standard proof of work to our

334
00:13:29,120 --> 00:13:32,240
protocol for proof of useful work

335
00:13:32,240 --> 00:13:34,880
so in standard bitcoin we have this

336
00:13:34,880 --> 00:13:37,600
block we hash against the target t and

337
00:13:37,600 --> 00:13:39,440
then we start wearing the cointer until

338
00:13:39,440 --> 00:13:40,959
we are successful

339
00:13:40,959 --> 00:13:42,880
and as soon as we are below that

340
00:13:42,880 --> 00:13:44,560
threshold t we are allowed to publish

341
00:13:44,560 --> 00:13:46,880
the block

342
00:13:46,880 --> 00:13:48,560
um

343
00:13:48,560 --> 00:13:52,000
yeah um yeah and so in order to inject

344
00:13:52,000 --> 00:13:53,279
this useful

345
00:13:53,279 --> 00:13:55,760
exploration step here we prevent this

346
00:13:55,760 --> 00:13:56,959
hash by

347
00:13:56,959 --> 00:14:00,320
a hash followed by the exploration step

348
00:14:00,320 --> 00:14:02,800
where the purpose of the hash the first

349
00:14:02,800 --> 00:14:06,000
hash is just to provide the seed

350
00:14:06,000 --> 00:14:08,399
for the computation of m

351
00:14:08,399 --> 00:14:11,440
that leads to state s prime and then we

352
00:14:11,440 --> 00:14:12,560
still

353
00:14:12,560 --> 00:14:15,040
hash this state s prime together with

354
00:14:15,040 --> 00:14:16,800
the seed

355
00:14:16,800 --> 00:14:18,240
to

356
00:14:18,240 --> 00:14:20,480
see whether the the

357
00:14:20,480 --> 00:14:21,360
hash

358
00:14:21,360 --> 00:14:23,680
result is below the target

359
00:14:23,680 --> 00:14:26,000
or some target t

360
00:14:26,000 --> 00:14:27,920
and this is important because we want to

361
00:14:27,920 --> 00:14:30,560
decouple block success from basically

362
00:14:30,560 --> 00:14:32,720
from success of finding a good solution

363
00:14:32,720 --> 00:14:35,120
a good state solution

364
00:14:35,120 --> 00:14:37,440
and then so you instead of just hashing

365
00:14:37,440 --> 00:14:40,800
you you you constantly you continuously

366
00:14:40,800 --> 00:14:42,839
repeat this hmh

367
00:14:42,839 --> 00:14:47,040
cycle while keeping the best state

368
00:14:47,040 --> 00:14:49,600
as best you've found so far

369
00:14:49,600 --> 00:14:52,240
and then once you hit that threshold you

370
00:14:52,240 --> 00:14:54,160
publish your block together with the

371
00:14:54,160 --> 00:14:57,360
winning state s prime to prove that you

372
00:14:57,360 --> 00:15:00,880
act as a proof of use work basically and

373
00:15:00,880 --> 00:15:03,360
with this you deliver your best solution

374
00:15:03,360 --> 00:15:06,000
you found which which then will be

375
00:15:06,000 --> 00:15:08,880
used for the sls update

376
00:15:08,880 --> 00:15:10,399
and now we still have a problem with

377
00:15:10,399 --> 00:15:14,240
this because we have a lot of notes

378
00:15:14,240 --> 00:15:16,560
uh in the in the system

379
00:15:16,560 --> 00:15:18,880
and that means we cannot afford that

380
00:15:18,880 --> 00:15:21,199
every node in the system in the system

381
00:15:21,199 --> 00:15:23,760
is going to verify the proof of useful

382
00:15:23,760 --> 00:15:26,639
work by repeating this whole computation

383
00:15:26,639 --> 00:15:29,920
of m because that would cause an in

384
00:15:29,920 --> 00:15:32,720
incredible amount of overhead so what we

385
00:15:32,720 --> 00:15:34,720
do here

386
00:15:34,720 --> 00:15:36,320
oh no sorry

387
00:15:36,320 --> 00:15:38,320
i was i was speaking ahead so we have to

388
00:15:38,320 --> 00:15:41,040
do something different first and that's

389
00:15:41,040 --> 00:15:43,360
we have to define against grinding

390
00:15:43,360 --> 00:15:46,480
attacks so we may have some variance

391
00:15:46,480 --> 00:15:49,839
in in the complexity of computing m

392
00:15:49,839 --> 00:15:52,399
and so what the adversary might

393
00:15:52,399 --> 00:15:55,199
try to do is that if he if he has

394
00:15:55,199 --> 00:15:57,680
computed the first hash he might not

395
00:15:57,680 --> 00:15:59,680
like the seed he got because he now he

396
00:15:59,680 --> 00:16:01,519
knows he now has to

397
00:16:01,519 --> 00:16:03,839
evaluate a very hard instance of the

398
00:16:03,839 --> 00:16:06,079
same computation and so he might

399
00:16:06,079 --> 00:16:08,639
actually grind for easy cherry picking

400
00:16:08,639 --> 00:16:11,040
of m

401
00:16:11,360 --> 00:16:13,040
executions

402
00:16:13,040 --> 00:16:14,000
by

403
00:16:14,000 --> 00:16:16,160
by just repeating the hash and not

404
00:16:16,160 --> 00:16:20,720
actually executing the m computation

405
00:16:20,720 --> 00:16:24,000
um yeah and so for that we actually now

406
00:16:24,000 --> 00:16:25,920
require to

407
00:16:25,920 --> 00:16:29,040
repeat hashing before the useful work

408
00:16:29,040 --> 00:16:30,000
step

409
00:16:30,000 --> 00:16:32,240
until you reach

410
00:16:32,240 --> 00:16:34,000
the hash value be below a certain

411
00:16:34,000 --> 00:16:37,440
threshold t1 and we set the t1

412
00:16:37,440 --> 00:16:39,440
such that the expected number of steps

413
00:16:39,440 --> 00:16:41,519
you have to do in order to be success

414
00:16:41,519 --> 00:16:43,360
successful to

415
00:16:43,360 --> 00:16:46,160
to proceed to the m stage

416
00:16:46,160 --> 00:16:48,000
those steps must be

417
00:16:48,000 --> 00:16:50,639
more than the worst case complexity of a

418
00:16:50,639 --> 00:16:52,000
so there is no

419
00:16:52,000 --> 00:16:54,560
advantage for the adversary in grinding

420
00:16:54,560 --> 00:16:56,720
for for other m

421
00:16:56,720 --> 00:16:59,360
instances

422
00:16:59,680 --> 00:17:01,600
and the observation

423
00:17:01,600 --> 00:17:03,839
here is that this i mean this now

424
00:17:03,839 --> 00:17:06,079
introduces useless work again right

425
00:17:06,079 --> 00:17:08,400
because now you repeat hashing and so

426
00:17:08,400 --> 00:17:10,559
the observation uh here of course is

427
00:17:10,559 --> 00:17:13,199
that this heavily it depends on on how

428
00:17:13,199 --> 00:17:15,359
well formed your your

429
00:17:15,359 --> 00:17:16,160
um

430
00:17:16,160 --> 00:17:20,160
algorithm aim is and that uh

431
00:17:20,160 --> 00:17:21,839
basically the trade-off here is that

432
00:17:21,839 --> 00:17:25,359
less less concentrated the distribution

433
00:17:25,359 --> 00:17:28,799
of runtime executing m is the more you

434
00:17:28,799 --> 00:17:30,840
have to compensate it by

435
00:17:30,840 --> 00:17:33,360
useless fashion

436
00:17:33,360 --> 00:17:35,600
okay now we are here

437
00:17:35,600 --> 00:17:37,280
where i jumped

438
00:17:37,280 --> 00:17:40,320
to before unfortunately and so to

439
00:17:40,320 --> 00:17:43,280
minimize verification time by the by the

440
00:17:43,280 --> 00:17:45,120
other nodes because we have to account

441
00:17:45,120 --> 00:17:47,120
that towards the usefulness of the

442
00:17:47,120 --> 00:17:48,640
system

443
00:17:48,640 --> 00:17:52,080
we now just require successful minus

444
00:17:52,080 --> 00:17:55,039
miner to publish the block not only

445
00:17:55,039 --> 00:17:57,760
together with these witnesses as based

446
00:17:57,760 --> 00:17:59,280
in s prime

447
00:17:59,280 --> 00:18:01,120
but also

448
00:18:01,120 --> 00:18:04,400
both but but also a snark that that he

449
00:18:04,400 --> 00:18:06,880
computed

450
00:18:06,880 --> 00:18:10,559
these s's correctly proved for s prime

451
00:18:10,559 --> 00:18:13,039
to prove that this

452
00:18:13,039 --> 00:18:14,880
indeed constitutes

453
00:18:14,880 --> 00:18:17,039
a proof of his work

454
00:18:17,039 --> 00:18:19,919
and is best to make sure that he cannot

455
00:18:19,919 --> 00:18:21,679
smuggle

456
00:18:21,679 --> 00:18:25,840
any bad update into the into the system

457
00:18:25,840 --> 00:18:28,799
note here that the loss here i i mean

458
00:18:28,799 --> 00:18:30,960
computing the snarks again is

459
00:18:30,960 --> 00:18:34,080
kind of unusual work right note here

460
00:18:34,080 --> 00:18:36,480
that we only publish or compute and

461
00:18:36,480 --> 00:18:39,200
publish two snarks while in the loop

462
00:18:39,200 --> 00:18:42,559
here we we compute many many invocations

463
00:18:42,559 --> 00:18:43,520
of m

464
00:18:43,520 --> 00:18:45,760
so the computation of smart snark will

465
00:18:45,760 --> 00:18:47,360
not substantially

466
00:18:47,360 --> 00:18:48,880
decrease

467
00:18:48,880 --> 00:18:49,600
the

468
00:18:49,600 --> 00:18:52,880
the usefulness

469
00:18:52,880 --> 00:18:55,280
okay so that's the final picture of the

470
00:18:55,280 --> 00:18:57,039
construction

471
00:18:57,039 --> 00:18:58,640
and for the

472
00:18:58,640 --> 00:19:00,720
analysis of this we need to make an

473
00:19:00,720 --> 00:19:02,880
assumption we base it on the on the

474
00:19:02,880 --> 00:19:05,039
following definition which

475
00:19:05,039 --> 00:19:07,679
is we say that the exploration algorithm

476
00:19:07,679 --> 00:19:08,400
m

477
00:19:08,400 --> 00:19:12,240
is w excellent k moderately hard

478
00:19:12,240 --> 00:19:14,240
if the following

479
00:19:14,240 --> 00:19:17,840
holds the the adversary succeeds in the

480
00:19:17,840 --> 00:19:19,120
following

481
00:19:19,120 --> 00:19:21,280
security game with negligible

482
00:19:21,280 --> 00:19:24,320
probability in the security parameter

483
00:19:24,320 --> 00:19:27,520
and his task is to attempt to create

484
00:19:27,520 --> 00:19:30,240
some m in order polynomial of the

485
00:19:30,240 --> 00:19:32,640
security parameter

486
00:19:32,640 --> 00:19:35,760
proof of use of work queries but in time

487
00:19:35,760 --> 00:19:39,280
less than one minus epsilon time m

488
00:19:39,280 --> 00:19:41,679
times w where w is the worst case

489
00:19:41,679 --> 00:19:43,280
complexity of n

490
00:19:43,280 --> 00:19:46,000
so you can see this epsilon here as the

491
00:19:46,000 --> 00:19:48,400
adversary's advantage in computing the

492
00:19:48,400 --> 00:19:49,840
useful work

493
00:19:49,840 --> 00:19:53,200
and so what we do for our analysis we we

494
00:19:53,200 --> 00:19:54,640
assume

495
00:19:54,640 --> 00:19:55,919
that

496
00:19:55,919 --> 00:19:57,440
our m

497
00:19:57,440 --> 00:20:00,880
exploration algorithm m is w epsilon k

498
00:20:00,880 --> 00:20:02,400
moderately hard

499
00:20:02,400 --> 00:20:04,720
and we obtain non-trivial results for

500
00:20:04,720 --> 00:20:07,919
any such epsilon even for epsilon equals

501
00:20:07,919 --> 00:20:10,159
one

502
00:20:11,600 --> 00:20:15,039
okay so we now deal with a slight

503
00:20:15,039 --> 00:20:17,440
difficulty as compared

504
00:20:17,440 --> 00:20:20,080
to standard pow

505
00:20:20,080 --> 00:20:21,200
for the

506
00:20:21,200 --> 00:20:24,400
standard analysis techniques you would

507
00:20:24,400 --> 00:20:26,640
want to apply to such a system

508
00:20:26,640 --> 00:20:28,720
and we observed that

509
00:20:28,720 --> 00:20:29,440
as

510
00:20:29,440 --> 00:20:31,840
pow was totally

511
00:20:31,840 --> 00:20:34,559
pow mining was a totally stateless

512
00:20:34,559 --> 00:20:37,120
process now we are in a state stateful

513
00:20:37,120 --> 00:20:39,200
pro process here

514
00:20:39,200 --> 00:20:40,480
because now

515
00:20:40,480 --> 00:20:44,320
basically the miners operate in this

516
00:20:44,320 --> 00:20:47,280
along this markov chain

517
00:20:47,280 --> 00:20:49,919
depending on on how the thresholds are

518
00:20:49,919 --> 00:20:52,159
set etc

519
00:20:52,159 --> 00:20:54,000
and so

520
00:20:54,000 --> 00:20:55,440
um

521
00:20:55,440 --> 00:20:58,159
this could be harmful because this could

522
00:20:58,159 --> 00:21:00,880
put the miners into correlation

523
00:21:00,880 --> 00:21:03,520
and we cannot afford this because

524
00:21:03,520 --> 00:21:05,280
correlation of mining successes

525
00:21:05,280 --> 00:21:07,280
basically invalidates blockchain

526
00:21:07,280 --> 00:21:09,600
security because basically the honest

527
00:21:09,600 --> 00:21:12,159
parties will interfere with each other

528
00:21:12,159 --> 00:21:15,200
trying to try to make progress updating

529
00:21:15,200 --> 00:21:16,400
the ledge

530
00:21:16,400 --> 00:21:18,240
and so to

531
00:21:18,240 --> 00:21:20,400
and and especially the problem here is

532
00:21:20,400 --> 00:21:21,760
as soon as

533
00:21:21,760 --> 00:21:24,320
a new block is published

534
00:21:24,320 --> 00:21:26,799
everybody would of course by the

535
00:21:26,799 --> 00:21:29,360
standard rule jump back to the pre-hash

536
00:21:29,360 --> 00:21:31,760
state where you start with the hashing

537
00:21:31,760 --> 00:21:34,559
before m and then this would completely

538
00:21:34,559 --> 00:21:37,039
correlate all minors in the system so

539
00:21:37,039 --> 00:21:39,600
this is dangerous to have and for that

540
00:21:39,600 --> 00:21:41,520
we introduced the following rule for

541
00:21:41,520 --> 00:21:44,320
mining and that is basically that you do

542
00:21:44,320 --> 00:21:45,440
not

543
00:21:45,440 --> 00:21:46,240
uh

544
00:21:46,240 --> 00:21:50,480
ask for immediate restarts if you see a

545
00:21:50,480 --> 00:21:53,280
newer longest chain so in standard pow

546
00:21:53,280 --> 00:21:55,600
well as soon as you would see a newer

547
00:21:55,600 --> 00:21:58,080
longer train you would immediately adapt

548
00:21:58,080 --> 00:22:00,400
to that chain and produce a new block

549
00:22:00,400 --> 00:22:03,039
and our rule now here is that you don't

550
00:22:03,039 --> 00:22:05,120
do that immediately but that you

551
00:22:05,120 --> 00:22:06,400
basically

552
00:22:06,400 --> 00:22:10,720
finish your initial your your hm h cycle

553
00:22:10,720 --> 00:22:13,280
you're currently in and then if you fail

554
00:22:13,280 --> 00:22:15,520
here and come back then you you're ready

555
00:22:15,520 --> 00:22:19,760
to adopt the newest longest train

556
00:22:21,360 --> 00:22:24,720
uh the good the good and the good

557
00:22:24,720 --> 00:22:27,360
news here is that basically with respect

558
00:22:27,360 --> 00:22:28,400
to this

559
00:22:28,400 --> 00:22:31,120
markov chain the miners they could they

560
00:22:31,120 --> 00:22:33,919
correlate fast and that

561
00:22:33,919 --> 00:22:36,159
gives us the hope that we can solve or

562
00:22:36,159 --> 00:22:38,880
give the analysis you applying standard

563
00:22:38,880 --> 00:22:42,080
techniques that have already been run

564
00:22:42,080 --> 00:22:43,679
and so we

565
00:22:43,679 --> 00:22:45,840
show that by giving a

566
00:22:45,840 --> 00:22:48,000
simple coupling argument

567
00:22:48,000 --> 00:22:51,919
so we assume that all the miners start

568
00:22:51,919 --> 00:22:55,840
in pre-hash state at the beginning

569
00:22:56,000 --> 00:22:59,600
and and compare it to a system where the

570
00:22:59,600 --> 00:23:02,240
miners are already independently

571
00:23:02,240 --> 00:23:05,200
uh distributed with respect to the

572
00:23:05,200 --> 00:23:06,799
stationary

573
00:23:06,799 --> 00:23:10,159
distribution of that markov chain

574
00:23:10,159 --> 00:23:11,520
and then

575
00:23:11,520 --> 00:23:13,520
we basically

576
00:23:13,520 --> 00:23:16,400
play a gedanken experiment where we let

577
00:23:16,400 --> 00:23:18,559
those

578
00:23:18,559 --> 00:23:21,679
those miners proceed in both systems so

579
00:23:21,679 --> 00:23:24,080
we have the m minus p that that's not in

580
00:23:24,080 --> 00:23:26,640
pre-hash and the s

581
00:23:26,640 --> 00:23:29,760
1 to s m that are independently

582
00:23:29,760 --> 00:23:31,039
distributed

583
00:23:31,039 --> 00:23:35,360
and then we see we just apply one update

584
00:23:35,360 --> 00:23:37,120
according to the markov chain after

585
00:23:37,120 --> 00:23:39,600
another progressing in this state and

586
00:23:39,600 --> 00:23:42,559
then we look at the situation when

587
00:23:42,559 --> 00:23:48,159
a pair of such miners p i and s i meet

588
00:23:48,159 --> 00:23:49,600
in the chain

589
00:23:49,600 --> 00:23:51,760
and then we can observe that since now

590
00:23:51,760 --> 00:23:53,039
they're in the same

591
00:23:53,039 --> 00:23:54,720
chain as the

592
00:23:54,720 --> 00:23:57,279
same state and

593
00:23:57,279 --> 00:23:58,960
are based on the

594
00:23:58,960 --> 00:24:01,520
same update function that they will now

595
00:24:01,520 --> 00:24:03,600
move in sync in the future

596
00:24:03,600 --> 00:24:07,120
and by that we can show that that the

597
00:24:07,120 --> 00:24:08,720
distributions

598
00:24:08,720 --> 00:24:09,919
of those

599
00:24:09,919 --> 00:24:11,760
of those random variables

600
00:24:11,760 --> 00:24:12,960
actually

601
00:24:12,960 --> 00:24:14,960
come together close together

602
00:24:14,960 --> 00:24:16,559
exponentially first

603
00:24:16,559 --> 00:24:19,279
and so we do that by coupling argument

604
00:24:19,279 --> 00:24:21,679
uh assuming

605
00:24:21,679 --> 00:24:22,720
that

606
00:24:22,720 --> 00:24:23,840
um

607
00:24:23,840 --> 00:24:26,799
or or observing that two minors or the

608
00:24:26,799 --> 00:24:29,039
two minors p1 and p

609
00:24:29,039 --> 00:24:32,960
and s1 will actually land within any

610
00:24:32,960 --> 00:24:35,360
period of e-steps we both will land in

611
00:24:35,360 --> 00:24:37,279
the pre-hash state

612
00:24:37,279 --> 00:24:38,080
and

613
00:24:38,080 --> 00:24:40,000
thus we can observe

614
00:24:40,000 --> 00:24:42,480
both particles within these or both

615
00:24:42,480 --> 00:24:44,720
minors within this period e

616
00:24:44,720 --> 00:24:46,799
and then uh

617
00:24:46,799 --> 00:24:49,279
we can look at the first minor that

618
00:24:49,279 --> 00:24:51,679
appears in pre-hash and then the second

619
00:24:51,679 --> 00:24:54,000
minor that appears in pre-hash

620
00:24:54,000 --> 00:24:55,360
and then

621
00:24:55,360 --> 00:24:56,880
as law or

622
00:24:56,880 --> 00:24:59,120
if the first minor that arrives there

623
00:24:59,120 --> 00:25:02,000
stays in pre-hash until the second one

624
00:25:02,000 --> 00:25:04,640
arrives then we have a coupling and and

625
00:25:04,640 --> 00:25:06,159
then both

626
00:25:06,159 --> 00:25:08,799
minors will behave the same

627
00:25:08,799 --> 00:25:11,360
and so we can estimate this

628
00:25:11,360 --> 00:25:12,799
by by

629
00:25:12,799 --> 00:25:16,320
this probability by 1 minus p1 to the e

630
00:25:16,320 --> 00:25:20,480
and assuming a linear snark prover

631
00:25:20,480 --> 00:25:22,159
we we get

632
00:25:22,159 --> 00:25:24,240
together with the condition on p1 we get

633
00:25:24,240 --> 00:25:26,880
that this is larger than 1 minus 1

634
00:25:26,880 --> 00:25:30,559
divided by w to some constant time times

635
00:25:30,559 --> 00:25:32,799
w which is a constant

636
00:25:32,799 --> 00:25:36,159
and now by by a standard argument we we

637
00:25:36,159 --> 00:25:39,120
can conclude that after l e sub steps

638
00:25:39,120 --> 00:25:41,600
the total variation distance between the

639
00:25:41,600 --> 00:25:43,279
distributions

640
00:25:43,279 --> 00:25:44,080
is

641
00:25:44,080 --> 00:25:46,960
uh exponentially slow

642
00:25:46,960 --> 00:25:49,520
uh in this in in

643
00:25:49,520 --> 00:25:51,520
is exponentially

644
00:25:51,520 --> 00:25:53,520
small in

645
00:25:53,520 --> 00:25:55,840
by it

646
00:25:55,840 --> 00:25:56,640
so

647
00:25:56,640 --> 00:25:59,520
this now allows us to analyze uh

648
00:25:59,520 --> 00:26:01,440
blocked uh the the security of the

649
00:26:01,440 --> 00:26:02,640
protocol

650
00:26:02,640 --> 00:26:04,960
by using the fact that the minor states

651
00:26:04,960 --> 00:26:07,279
are close to independent pretty quickly

652
00:26:07,279 --> 00:26:09,279
and so we can adapt the

653
00:26:09,279 --> 00:26:11,520
existing machinery which which i spare

654
00:26:11,520 --> 00:26:13,120
you from but i'll just give you an

655
00:26:13,120 --> 00:26:16,480
intuition here we achieve one-third

656
00:26:16,480 --> 00:26:18,559
of uh security against one-third of

657
00:26:18,559 --> 00:26:21,600
adversarial computing power if the

658
00:26:21,600 --> 00:26:23,840
adversary is strong that he has

659
00:26:23,840 --> 00:26:26,559
advantage one in computing uh the

660
00:26:26,559 --> 00:26:29,919
exploration step in and if we do make a

661
00:26:29,919 --> 00:26:32,480
strong assumption about the adversary

662
00:26:32,480 --> 00:26:34,720
then we can tolerate the same as bitcoin

663
00:26:34,720 --> 00:26:37,279
that's a half half of adversarial

664
00:26:37,279 --> 00:26:38,799
computing power

665
00:26:38,799 --> 00:26:42,320
um and then we also give a

666
00:26:42,320 --> 00:26:46,000
short usefulness intuition so usefulness

667
00:26:46,000 --> 00:26:48,320
u is the rate at which the miners

668
00:26:48,320 --> 00:26:50,080
perform useful

669
00:26:50,080 --> 00:26:53,600
work and if the worst case complexity of

670
00:26:53,600 --> 00:26:56,320
m is the say is roughly the same as the

671
00:26:56,320 --> 00:26:58,159
average complexity of m we have

672
00:26:58,159 --> 00:27:00,400
usefulness one-half because the miners

673
00:27:00,400 --> 00:27:01,919
spend one half

674
00:27:01,919 --> 00:27:03,520
of their time

675
00:27:03,520 --> 00:27:06,240
doing this pre-hash cycle but then if we

676
00:27:06,240 --> 00:27:08,720
add the assumption of a

677
00:27:08,720 --> 00:27:10,720
of a weak adversary that has no

678
00:27:10,720 --> 00:27:13,279
advantage actually usefulness can be one

679
00:27:13,279 --> 00:27:14,960
so let me compute

680
00:27:14,960 --> 00:27:17,279
we devised a proof of useful word

681
00:27:17,279 --> 00:27:19,679
blockchain protocol that allows to solve

682
00:27:19,679 --> 00:27:22,880
real-world client problems

683
00:27:22,880 --> 00:27:24,880
we

684
00:27:24,880 --> 00:27:26,880
analyze the security and random oracle

685
00:27:26,880 --> 00:27:28,159
model

686
00:27:28,159 --> 00:27:30,240
demonstrating that the system tolerates

687
00:27:30,240 --> 00:27:32,399
between one-third and one

688
00:27:32,399 --> 00:27:35,200
half of adversarial computer power the

689
00:27:35,200 --> 00:27:37,520
depending on the assumptions on the

690
00:27:37,520 --> 00:27:40,880
on the adversary and then usefulness can

691
00:27:40,880 --> 00:27:43,919
range between one half and one for

692
00:27:43,919 --> 00:27:44,640
uh

693
00:27:44,640 --> 00:27:46,320
for basically

694
00:27:46,320 --> 00:27:49,440
concentrated exploration algorithms in

695
00:27:49,440 --> 00:27:51,840
and thus we reduce

696
00:27:51,840 --> 00:27:54,240
or would be theoretically at least if

697
00:27:54,240 --> 00:27:56,559
people would adopt this we would be able

698
00:27:56,559 --> 00:27:57,600
to

699
00:27:57,600 --> 00:27:59,520
substantially reduce the pollution

700
00:27:59,520 --> 00:28:03,840
created by proof of work blockchains

701
00:28:05,360 --> 00:28:06,960
yes

702
00:28:06,960 --> 00:28:09,279
all right

703
00:28:12,399 --> 00:28:13,520
okay

704
00:28:13,520 --> 00:28:15,760
we have time for one very quick question

705
00:28:15,760 --> 00:28:18,760
um

706
00:28:31,919 --> 00:28:34,080
yeah so you would basically have a

707
00:28:34,080 --> 00:28:37,440
problem market where clients can post

708
00:28:37,440 --> 00:28:39,200
their instances to the blockchain of

709
00:28:39,200 --> 00:28:41,919
course they must be must conform to

710
00:28:41,919 --> 00:28:43,520
certain rules right

711
00:28:43,520 --> 00:28:47,200
and then you can schedule the the

712
00:28:47,200 --> 00:28:49,919
the mining by maybe picking multiple of

713
00:28:49,919 --> 00:28:52,240
those problems and then of course also

714
00:28:52,240 --> 00:28:54,640
the client can can submit some fees so

715
00:28:54,640 --> 00:28:56,960
you can

716
00:28:57,039 --> 00:28:59,360
drive the incentives also by the by the

717
00:28:59,360 --> 00:29:01,678
fees

718
00:29:02,080 --> 00:29:06,158
okay let's thank uh matthias again

719
00:29:08,080 --> 00:29:09,279
thanks a lot

720
00:29:09,279 --> 00:29:12,399
and uh we're gonna move now to the

721
00:29:12,399 --> 00:29:14,799
second talk of this session

722
00:29:14,799 --> 00:29:18,159
uh the title is practical statistically

723
00:29:18,159 --> 00:29:20,880
sound proofs of exponentiation in any

724
00:29:20,880 --> 00:29:21,679
group

725
00:29:21,679 --> 00:29:23,520
and the speaker will be charlotte

726
00:29:23,520 --> 00:29:24,559
hoffman

727
00:29:24,559 --> 00:29:28,918
whenever c is ready with the microphone

728
00:30:51,919 --> 00:30:54,799
we have no sound

729
00:30:54,880 --> 00:30:57,039
um so i'm charlotte and i'm going to

730
00:30:57,039 --> 00:30:59,039
tell you about practical statistically

731
00:30:59,039 --> 00:31:00,960
sound proofs of exponentiation in any

732
00:31:00,960 --> 00:31:01,840
group

733
00:31:01,840 --> 00:31:03,919
this is joint work with pablo hubercheck

734
00:31:03,919 --> 00:31:06,240
chetan kamat karen klein and christophe

735
00:31:06,240 --> 00:31:08,640
patrick

736
00:31:08,640 --> 00:31:10,159
in the proof of exponentiation we have

737
00:31:10,159 --> 00:31:12,320
approver and a verifier

738
00:31:12,320 --> 00:31:14,399
and they both get this input some tuple

739
00:31:14,399 --> 00:31:17,120
x q t y

740
00:31:17,120 --> 00:31:18,799
and now the prover claims that the

741
00:31:18,799 --> 00:31:21,039
result of the exponentiation x to the q

742
00:31:21,039 --> 00:31:25,360
to the t equals y in some group g

743
00:31:25,360 --> 00:31:26,880
but the verifier doesn't trust the

744
00:31:26,880 --> 00:31:29,200
proverb so how can the verifier

745
00:31:29,200 --> 00:31:30,720
efficiently check that this is actually

746
00:31:30,720 --> 00:31:33,840
the correct result

747
00:31:34,000 --> 00:31:36,240
well if the group order is known

748
00:31:36,240 --> 00:31:38,080
then this is easy the verifier can do

749
00:31:38,080 --> 00:31:40,000
exactly the same as the prover they can

750
00:31:40,000 --> 00:31:42,640
both reduce the exponent modulo the

751
00:31:42,640 --> 00:31:44,960
group order and then com and then raise

752
00:31:44,960 --> 00:31:47,760
x to that value

753
00:31:47,760 --> 00:31:50,000
however if the group order is not known

754
00:31:50,000 --> 00:31:52,000
we don't know any significantly faster

755
00:31:52,000 --> 00:31:54,080
way to compute the result than to

756
00:31:54,080 --> 00:31:57,200
perform t sequential exponentiations

757
00:31:57,200 --> 00:31:59,440
so that's what the prover does

758
00:31:59,440 --> 00:32:01,039
but we want the verifier to be more

759
00:32:01,039 --> 00:32:03,200
efficient than t

760
00:32:03,200 --> 00:32:05,600
and so to this end the prover sends a

761
00:32:05,600 --> 00:32:08,880
proof of exponentiation to the verifier

762
00:32:08,880 --> 00:32:11,200
or p-o-e to prove the correctness of the

763
00:32:11,200 --> 00:32:12,799
result

764
00:32:12,799 --> 00:32:14,320
and here the cost of computing and

765
00:32:14,320 --> 00:32:18,559
verifying the proof is much less than t

766
00:32:18,720 --> 00:32:20,399
now what are the applications of such

767
00:32:20,399 --> 00:32:22,960
poes the most well-known applications

768
00:32:22,960 --> 00:32:25,760
are verifiable delay functions

769
00:32:25,760 --> 00:32:28,320
these are functions that are verifiable

770
00:32:28,320 --> 00:32:29,840
so given a proof everyone can

771
00:32:29,840 --> 00:32:31,919
efficiently and also soundly verify the

772
00:32:31,919 --> 00:32:34,480
correctness of the result

773
00:32:34,480 --> 00:32:36,480
they satisfy the delay property which

774
00:32:36,480 --> 00:32:38,399
means they cannot be computed faster

775
00:32:38,399 --> 00:32:40,799
than a given time parameter t even given

776
00:32:40,799 --> 00:32:42,880
parallelization

777
00:32:42,880 --> 00:32:45,039
and finally their functions so the

778
00:32:45,039 --> 00:32:47,360
output is unique

779
00:32:47,360 --> 00:32:49,440
um vds were first introduced by

780
00:32:49,440 --> 00:32:52,399
bonierdale in 2018 and then shortly

781
00:32:52,399 --> 00:32:54,880
afterwards hitchhike and vesilowski gave

782
00:32:54,880 --> 00:32:57,279
the first practical constructions they

783
00:32:57,279 --> 00:32:59,120
are based on repeated squaring and then

784
00:32:59,120 --> 00:33:02,000
sending poes

785
00:33:02,240 --> 00:33:04,399
another more recent application are time

786
00:33:04,399 --> 00:33:06,240
and space efficient arguments

787
00:33:06,240 --> 00:33:09,360
for np by blockade

788
00:33:09,360 --> 00:33:12,080
here poes are used as building blocks in

789
00:33:12,080 --> 00:33:13,679
constructing polynomial commitment

790
00:33:13,679 --> 00:33:16,080
schemes

791
00:33:17,519 --> 00:33:18,880
all right so this is the plan for the

792
00:33:18,880 --> 00:33:20,000
talk

793
00:33:20,000 --> 00:33:21,200
first we're going to look at some

794
00:33:21,200 --> 00:33:23,039
existing pv constructions and their

795
00:33:23,039 --> 00:33:25,200
properties and then afterwards i give

796
00:33:25,200 --> 00:33:29,360
you a technical overview of our poe

797
00:33:30,320 --> 00:33:32,000
but first i want to define interactive

798
00:33:32,000 --> 00:33:33,679
protocols because all of the proofs

799
00:33:33,679 --> 00:33:36,720
we're going to see will be interactive

800
00:33:36,720 --> 00:33:38,640
so in an interactive protocol again we

801
00:33:38,640 --> 00:33:40,640
have the prover and the verifier they

802
00:33:40,640 --> 00:33:43,120
both get as input some statement x and

803
00:33:43,120 --> 00:33:45,039
an approver also gets the witness or

804
00:33:45,039 --> 00:33:46,720
just more computational power than the

805
00:33:46,720 --> 00:33:48,320
verifier

806
00:33:48,320 --> 00:33:49,360
and then they

807
00:33:49,360 --> 00:33:51,039
engage in some interaction so they send

808
00:33:51,039 --> 00:33:52,960
messages back and forth

809
00:33:52,960 --> 00:33:56,000
and then afterwards the verifier outputs

810
00:33:56,000 --> 00:33:58,399
accept or reject

811
00:33:58,399 --> 00:33:59,919
and we want interactive protocols to

812
00:33:59,919 --> 00:34:02,559
satisfy two properties the first one is

813
00:34:02,559 --> 00:34:05,039
correctness so if the statement is true

814
00:34:05,039 --> 00:34:06,480
we want the verifier to accept with

815
00:34:06,480 --> 00:34:08,399
probability one

816
00:34:08,399 --> 00:34:10,079
the other one is soundness if a

817
00:34:10,079 --> 00:34:12,079
statement is false then the verifier

818
00:34:12,079 --> 00:34:15,679
should reject with high probability

819
00:34:15,918 --> 00:34:17,199
and there are two different notions of

820
00:34:17,199 --> 00:34:18,879
soundness that we consider

821
00:34:18,879 --> 00:34:21,280
the first one is statistical soundness

822
00:34:21,280 --> 00:34:23,359
which means that a potentially cheating

823
00:34:23,359 --> 00:34:24,719
prover

824
00:34:24,719 --> 00:34:27,280
is computationally unbounded

825
00:34:27,280 --> 00:34:28,960
the second one is computational

826
00:34:28,960 --> 00:34:31,040
soundness where the cheat improver can

827
00:34:31,040 --> 00:34:35,599
only perform polynomial computations

828
00:34:35,599 --> 00:34:37,199
now let's look at the queries that are

829
00:34:37,199 --> 00:34:38,879
already existing

830
00:34:38,879 --> 00:34:40,320
note that this is the statement we want

831
00:34:40,320 --> 00:34:44,079
to prove x to the q to the t equals y

832
00:34:44,079 --> 00:34:46,399
so there's wizolovsky's period which is

833
00:34:46,399 --> 00:34:48,719
very short it only consists of one group

834
00:34:48,719 --> 00:34:50,320
element

835
00:34:50,320 --> 00:34:52,399
however soundness is only computational

836
00:34:52,399 --> 00:34:54,000
and it relies on the adaptive root

837
00:34:54,000 --> 00:34:55,918
assumption which is a great novel

838
00:34:55,918 --> 00:34:59,040
assumption and not the word studied

839
00:34:59,040 --> 00:35:01,440
then we have phx protocol

840
00:35:01,440 --> 00:35:03,359
which is a bit longer so here the proof

841
00:35:03,359 --> 00:35:05,680
size is log t

842
00:35:05,680 --> 00:35:07,599
however this poe is statistically sound

843
00:35:07,599 --> 00:35:08,960
in some groups

844
00:35:08,960 --> 00:35:10,640
and in other group it can be

845
00:35:10,640 --> 00:35:12,880
computationally sound

846
00:35:12,880 --> 00:35:15,599
relying on the low order assumption

847
00:35:15,599 --> 00:35:16,880
note that there's a reduction from the

848
00:35:16,880 --> 00:35:18,480
adaptive root assumption to the low

849
00:35:18,480 --> 00:35:20,400
order assumption

850
00:35:20,400 --> 00:35:22,560
so if security of pitcher's protocol is

851
00:35:22,560 --> 00:35:23,920
broken then also soundness of

852
00:35:23,920 --> 00:35:26,160
vesoloski's protocol is broken but not

853
00:35:26,160 --> 00:35:28,320
the other way around

854
00:35:28,320 --> 00:35:30,000
finally there's the construction by

855
00:35:30,000 --> 00:35:32,079
block at eye which can be seen as a

856
00:35:32,079 --> 00:35:34,160
clever parallel repetition of patrick's

857
00:35:34,160 --> 00:35:36,400
protocol

858
00:35:36,400 --> 00:35:38,160
due to this repetition the proof size

859
00:35:38,160 --> 00:35:40,320
increases to lambda times log t group

860
00:35:40,320 --> 00:35:41,680
elements where lambda is some

861
00:35:41,680 --> 00:35:44,800
statistical security parameter

862
00:35:44,800 --> 00:35:46,880
however this pre has the advantage that

863
00:35:46,880 --> 00:35:50,640
it is statistically sound in any group

864
00:35:50,880 --> 00:35:52,640
now our contribution is that we

865
00:35:52,640 --> 00:35:55,839
construct a statistically sound qe that

866
00:35:55,839 --> 00:35:58,160
reduces the proof size of blocket i by

867
00:35:58,160 --> 00:36:00,560
almost one order of magnitude for queue

868
00:36:00,560 --> 00:36:02,240
of a special form

869
00:36:02,240 --> 00:36:03,680
and we will later see that in the

870
00:36:03,680 --> 00:36:05,680
applications we consider

871
00:36:05,680 --> 00:36:07,359
choosing queue of this form is not a

872
00:36:07,359 --> 00:36:09,920
restriction

873
00:36:10,320 --> 00:36:12,480
okay so we have so we have seen that we

874
00:36:12,480 --> 00:36:14,640
can get stronger soundness guarantees by

875
00:36:14,640 --> 00:36:16,720
increasing the proof size so the first

876
00:36:16,720 --> 00:36:19,599
natural question to ask is

877
00:36:19,599 --> 00:36:21,599
uh why don't why do we even care like

878
00:36:21,599 --> 00:36:23,599
why do we need statistics on the scope

879
00:36:23,599 --> 00:36:25,119
periods

880
00:36:25,119 --> 00:36:27,599
and there are several reasons for this

881
00:36:27,599 --> 00:36:30,000
the first one is that in the application

882
00:36:30,000 --> 00:36:31,599
of the polynomial commitments by

883
00:36:31,599 --> 00:36:33,760
blockade

884
00:36:33,760 --> 00:36:35,920
here we need statistically sound pues to

885
00:36:35,920 --> 00:36:37,599
get statistical knowledge soundness of

886
00:36:37,599 --> 00:36:39,680
the commitment

887
00:36:39,680 --> 00:36:41,839
but also in vdfs it can be useful

888
00:36:41,839 --> 00:36:43,680
because if you have statistically some

889
00:36:43,680 --> 00:36:45,920
poe then soundness holds even if the

890
00:36:45,920 --> 00:36:48,160
group order is known by the prover

891
00:36:48,160 --> 00:36:49,760
this is important for example in

892
00:36:49,760 --> 00:36:51,680
settings where the group is sampled by

893
00:36:51,680 --> 00:36:53,599
certain parties because then the parties

894
00:36:53,599 --> 00:36:55,359
know the group order but they still

895
00:36:55,359 --> 00:36:58,880
cannot come up with a false proof

896
00:36:58,880 --> 00:37:00,880
another reason is that if you want to

897
00:37:00,880 --> 00:37:02,720
use the peri and class groups here the

898
00:37:02,720 --> 00:37:04,400
low order assumption is not very well

899
00:37:04,400 --> 00:37:07,520
studied and understood

900
00:37:07,520 --> 00:37:09,280
okay but we have seen that there is

901
00:37:09,280 --> 00:37:12,079
already one very efficient poe which is

902
00:37:12,079 --> 00:37:14,320
sound in some groups this which is p

903
00:37:14,320 --> 00:37:16,320
checks poe

904
00:37:16,320 --> 00:37:18,880
however these groups require safe primes

905
00:37:18,880 --> 00:37:21,280
so you need to sample save prime numbers

906
00:37:21,280 --> 00:37:23,119
and then in a lot of applications you

907
00:37:23,119 --> 00:37:25,040
also need to prove that the modulus is a

908
00:37:25,040 --> 00:37:27,599
product of safe prime numbers and those

909
00:37:27,599 --> 00:37:29,359
two things are very expensive so if you

910
00:37:29,359 --> 00:37:31,520
have a statistically sound poe in any

911
00:37:31,520 --> 00:37:33,119
group then you don't need to do that

912
00:37:33,119 --> 00:37:36,480
work at all

913
00:37:36,480 --> 00:37:38,240
okay so let's start with our technical

914
00:37:38,240 --> 00:37:40,720
overview

915
00:37:41,839 --> 00:37:43,440
first i'm going to show you the poe

916
00:37:43,440 --> 00:37:44,720
construction of block it out because

917
00:37:44,720 --> 00:37:46,320
this is the construction that our work

918
00:37:46,320 --> 00:37:48,240
builds on

919
00:37:48,240 --> 00:37:50,000
and then i will show you our work how we

920
00:37:50,000 --> 00:37:52,960
reduce the complexity

921
00:37:52,960 --> 00:37:55,040
okay let's look at one round of blocky

922
00:37:55,040 --> 00:37:56,560
die

923
00:37:56,560 --> 00:37:58,079
so this is the picture we have already

924
00:37:58,079 --> 00:37:59,359
seen

925
00:37:59,359 --> 00:38:01,920
so let's have a closer look

926
00:38:01,920 --> 00:38:04,480
the proven verify i get as instances

927
00:38:04,480 --> 00:38:07,040
lambda many statements of this form

928
00:38:07,040 --> 00:38:11,440
x i to the q to the t equals y i

929
00:38:11,520 --> 00:38:13,680
and then in the first round

930
00:38:13,680 --> 00:38:16,240
so the first message of the prover is

931
00:38:16,240 --> 00:38:17,599
the prover since lambda many group

932
00:38:17,599 --> 00:38:20,079
elements of this form x i to the q to

933
00:38:20,079 --> 00:38:21,680
the t over 2.

934
00:38:21,680 --> 00:38:23,040
we sometimes call these elements

935
00:38:23,040 --> 00:38:25,359
midpoint because in the exponentiation

936
00:38:25,359 --> 00:38:29,119
they're in the middle of x i and y i

937
00:38:29,119 --> 00:38:30,720
now know that by sending this group

938
00:38:30,720 --> 00:38:32,800
element the approver implicitly splits

939
00:38:32,800 --> 00:38:35,280
up the first claim into two

940
00:38:35,280 --> 00:38:37,760
smaller claims

941
00:38:37,760 --> 00:38:40,079
so one of the claim is that this is that

942
00:38:40,079 --> 00:38:42,000
gi is the correct group element when you

943
00:38:42,000 --> 00:38:44,000
do this exponentiation

944
00:38:44,000 --> 00:38:46,560
and then the second claim is that if you

945
00:38:46,560 --> 00:38:48,160
take the group element and raise it to

946
00:38:48,160 --> 00:38:50,560
the power q to the t over two then you

947
00:38:50,560 --> 00:38:53,680
get um y the element y i which is the

948
00:38:53,680 --> 00:38:57,119
claim of the initial statement

949
00:38:57,119 --> 00:38:59,119
and it is straightforward to show that

950
00:38:59,119 --> 00:39:01,200
if at least one of the initial instances

951
00:39:01,200 --> 00:39:02,240
is wrong

952
00:39:02,240 --> 00:39:04,480
then also one of the two

953
00:39:04,480 --> 00:39:07,920
new um statements is wrong

954
00:39:07,920 --> 00:39:09,760
okay so we have made some progress here

955
00:39:09,760 --> 00:39:11,280
because we have reduced the exponent

956
00:39:11,280 --> 00:39:14,800
from q to the t to q to the t over 2.

957
00:39:14,800 --> 00:39:16,800
however we have also doubled

958
00:39:16,800 --> 00:39:19,040
the number of instances

959
00:39:19,040 --> 00:39:21,119
the number of statements so and because

960
00:39:21,119 --> 00:39:22,640
this protocol

961
00:39:22,640 --> 00:39:25,119
is recursive we cannot afford to double

962
00:39:25,119 --> 00:39:28,640
the number of statements in every round

963
00:39:28,640 --> 00:39:30,640
and so

964
00:39:30,640 --> 00:39:32,079
we need some way

965
00:39:32,079 --> 00:39:34,880
to recombine those two lambda statements

966
00:39:34,880 --> 00:39:37,440
back together into lambda such that if

967
00:39:37,440 --> 00:39:38,640
at least one of the two lambda

968
00:39:38,640 --> 00:39:41,280
statements is wrong also one of the new

969
00:39:41,280 --> 00:39:44,320
lambda statements is wrong

970
00:39:44,320 --> 00:39:45,599
and we will now

971
00:39:45,599 --> 00:39:47,359
take a look at how this is solved in

972
00:39:47,359 --> 00:39:50,000
blockade

973
00:39:51,520 --> 00:39:53,440
so let's say the proof and verifier now

974
00:39:53,440 --> 00:39:55,359
have these two lambda statements of this

975
00:39:55,359 --> 00:39:56,720
form

976
00:39:56,720 --> 00:39:58,480
and the goal is to reduce the number of

977
00:39:58,480 --> 00:40:01,040
statements to lambda

978
00:40:01,040 --> 00:40:02,640
this is done as follows first the

979
00:40:02,640 --> 00:40:04,800
verifier sends a random bit string of

980
00:40:04,800 --> 00:40:07,440
size 2 to the lambda

981
00:40:07,440 --> 00:40:09,359
and then both the verifier and the

982
00:40:09,359 --> 00:40:11,119
prover compute

983
00:40:11,119 --> 00:40:13,599
a random subset product where the

984
00:40:13,599 --> 00:40:15,839
statement is in this product

985
00:40:15,839 --> 00:40:17,760
if and only if the corresponding bit

986
00:40:17,760 --> 00:40:20,480
equals one

987
00:40:22,640 --> 00:40:24,400
and then the first thing we can note is

988
00:40:24,400 --> 00:40:26,000
that if at least one of the initial

989
00:40:26,000 --> 00:40:27,839
statements is wrong then the new

990
00:40:27,839 --> 00:40:29,599
statement is wrong with probability at

991
00:40:29,599 --> 00:40:31,839
least one half

992
00:40:31,839 --> 00:40:33,280
so let's say for example statement

993
00:40:33,280 --> 00:40:35,760
number k is a wrong statement

994
00:40:35,760 --> 00:40:38,000
then the corresponding bit rk will be

995
00:40:38,000 --> 00:40:40,720
equal to one with probability one half

996
00:40:40,720 --> 00:40:43,200
and if it's equal to one the statement

997
00:40:43,200 --> 00:40:45,520
is in the product and then also the new

998
00:40:45,520 --> 00:40:48,079
claim is wrong

999
00:40:48,079 --> 00:40:49,760
now if the proof and verifier repeat

1000
00:40:49,760 --> 00:40:51,359
this process lambda many times with

1001
00:40:51,359 --> 00:40:53,839
different randomness

1002
00:40:53,839 --> 00:40:55,520
then we can say that

1003
00:40:55,520 --> 00:40:56,880
at least one of the new lambda

1004
00:40:56,880 --> 00:40:58,560
statements is wrong with probability at

1005
00:40:58,560 --> 00:41:02,079
least 1 minus 2 to the minus lambda

1006
00:41:02,079 --> 00:41:03,760
and so if we choose lambda to be a

1007
00:41:03,760 --> 00:41:06,079
statistical security parameter then this

1008
00:41:06,079 --> 00:41:08,400
probability is overwhelming and we have

1009
00:41:08,400 --> 00:41:10,720
soundness

1010
00:41:10,720 --> 00:41:12,880
however this is also the reason why the

1011
00:41:12,880 --> 00:41:14,640
proof size increases by this

1012
00:41:14,640 --> 00:41:17,040
multiplicative factor of lambda so the

1013
00:41:17,040 --> 00:41:19,920
goal of our work is to reduce the number

1014
00:41:19,920 --> 00:41:22,160
of repetitions

1015
00:41:22,160 --> 00:41:25,680
that the verify and prover do

1016
00:41:25,680 --> 00:41:27,200
and so let's have a look at the first

1017
00:41:27,200 --> 00:41:29,280
step of our construction

1018
00:41:29,280 --> 00:41:31,599
so recall that um in block at i the

1019
00:41:31,599 --> 00:41:33,359
probability that one new statement is

1020
00:41:33,359 --> 00:41:35,280
wrong

1021
00:41:35,280 --> 00:41:37,440
is lower bounded by one half because for

1022
00:41:37,440 --> 00:41:39,359
example if only one of the instances is

1023
00:41:39,359 --> 00:41:40,880
wrong then it's in the new claim with

1024
00:41:40,880 --> 00:41:42,319
probability one half because the

1025
00:41:42,319 --> 00:41:44,960
randomness is only zero or one

1026
00:41:44,960 --> 00:41:47,440
so a state straightforward idea would be

1027
00:41:47,440 --> 00:41:50,319
to just increase the randomness space

1028
00:41:50,319 --> 00:41:52,319
because then um

1029
00:41:52,319 --> 00:41:53,920
every statement

1030
00:41:53,920 --> 00:41:55,520
contributes to the no product so you

1031
00:41:55,520 --> 00:41:57,440
take statements and raise it and raise

1032
00:41:57,440 --> 00:41:59,200
the statements two small coins and then

1033
00:41:59,200 --> 00:42:01,599
you might apply them all together

1034
00:42:01,599 --> 00:42:03,839
and then you could hope that this

1035
00:42:03,839 --> 00:42:05,760
increases the probability that the new

1036
00:42:05,760 --> 00:42:07,599
statement is wrong

1037
00:42:07,599 --> 00:42:09,920
unfortunately this is not the case

1038
00:42:09,920 --> 00:42:11,760
so the lower bound of this probability

1039
00:42:11,760 --> 00:42:14,640
is still one half

1040
00:42:14,960 --> 00:42:16,640
and why is this

1041
00:42:16,640 --> 00:42:19,599
well this is due to low order elements

1042
00:42:19,599 --> 00:42:22,319
um in the context of vdfs this was first

1043
00:42:22,319 --> 00:42:24,640
described by bonaire dye

1044
00:42:24,640 --> 00:42:27,119
but already in 2000 boyd and pavlovsky

1045
00:42:27,119 --> 00:42:28,079
showed that

1046
00:42:28,079 --> 00:42:30,160
low order elements can mess up random

1047
00:42:30,160 --> 00:42:32,640
batching

1048
00:42:32,800 --> 00:42:35,359
so let's see why let's say in statement

1049
00:42:35,359 --> 00:42:37,280
k the prover cheats with some bad

1050
00:42:37,280 --> 00:42:39,280
element alpha so the prover takes the

1051
00:42:39,280 --> 00:42:41,359
correct claim and then multiplies it by

1052
00:42:41,359 --> 00:42:43,359
a wrong element alpha

1053
00:42:43,359 --> 00:42:45,119
we sometimes call this element the bad

1054
00:42:45,119 --> 00:42:46,400
element

1055
00:42:46,400 --> 00:42:47,760
um

1056
00:42:47,760 --> 00:42:49,680
now if the prover is lucky and the order

1057
00:42:49,680 --> 00:42:52,960
of alpha divides the random coin

1058
00:42:52,960 --> 00:42:54,400
then what happens

1059
00:42:54,400 --> 00:42:56,319
where when both approve and the verifier

1060
00:42:56,319 --> 00:42:58,240
raise the statement to this coin then

1061
00:42:58,240 --> 00:43:00,319
they also raise the bet element to this

1062
00:43:00,319 --> 00:43:02,960
coin so they raise the vet element to a

1063
00:43:02,960 --> 00:43:05,599
multiple of its order which means oh

1064
00:43:05,599 --> 00:43:08,480
sorry which means it just vanishes and

1065
00:43:08,480 --> 00:43:10,160
so the statement you end up with is

1066
00:43:10,160 --> 00:43:12,079
correct

1067
00:43:12,079 --> 00:43:13,599
the probability that the order of alpha

1068
00:43:13,599 --> 00:43:16,480
divides rk is one divided by the order

1069
00:43:16,480 --> 00:43:19,359
of alpha so in the worst case if the

1070
00:43:19,359 --> 00:43:21,839
element only has order two

1071
00:43:21,839 --> 00:43:24,319
we again have the probability one half

1072
00:43:24,319 --> 00:43:26,079
that the new statement actually becomes

1073
00:43:26,079 --> 00:43:28,480
correct

1074
00:43:28,560 --> 00:43:30,319
okay so so far we have not increased the

1075
00:43:30,319 --> 00:43:32,480
probability but we have now seen that we

1076
00:43:32,480 --> 00:43:34,160
only need to take care of the low order

1077
00:43:34,160 --> 00:43:36,240
elements

1078
00:43:36,240 --> 00:43:38,960
so let's look at the okay so let's first

1079
00:43:38,960 --> 00:43:40,480
change the randomness of the protocol

1080
00:43:40,480 --> 00:43:42,160
increase the random space

1081
00:43:42,160 --> 00:43:45,040
and then look at the second step

1082
00:43:45,040 --> 00:43:46,800
now we're going to look at the instances

1083
00:43:46,800 --> 00:43:50,240
that the proof and the verifier get

1084
00:43:51,520 --> 00:43:52,800
so

1085
00:43:52,800 --> 00:43:55,680
for this we define this exponent q

1086
00:43:55,680 --> 00:43:57,520
to be of a special form

1087
00:43:57,520 --> 00:44:00,160
so we let q be the product of all small

1088
00:44:00,160 --> 00:44:04,400
prime numbers up to a certain bound b

1089
00:44:04,400 --> 00:44:06,800
and then we also define a constant as

1090
00:44:06,800 --> 00:44:08,880
log t times log b

1091
00:44:08,880 --> 00:44:10,400
but for the purpose of this talk you can

1092
00:44:10,400 --> 00:44:12,400
always just think of c as being large

1093
00:44:12,400 --> 00:44:14,800
enough

1094
00:44:14,960 --> 00:44:16,560
and now we change the instances that the

1095
00:44:16,560 --> 00:44:18,480
proven the verifier get

1096
00:44:18,480 --> 00:44:19,920
so instead of

1097
00:44:19,920 --> 00:44:21,280
proving

1098
00:44:21,280 --> 00:44:24,319
the claim uh x to the q to the t we now

1099
00:44:24,319 --> 00:44:27,200
change the exponent to q to the t minus

1100
00:44:27,200 --> 00:44:29,359
c

1101
00:44:30,160 --> 00:44:32,640
then we let the approval

1102
00:44:32,640 --> 00:44:33,839
proof these instances in some

1103
00:44:33,839 --> 00:44:35,440
interactive protocol

1104
00:44:35,440 --> 00:44:37,040
that is not really interesting to us

1105
00:44:37,040 --> 00:44:38,319
right now

1106
00:44:38,319 --> 00:44:40,319
and then after this interactive phase

1107
00:44:40,319 --> 00:44:42,240
the verifier performs these final

1108
00:44:42,240 --> 00:44:45,440
exponentiations themselves so for all i

1109
00:44:45,440 --> 00:44:47,119
and lambda

1110
00:44:47,119 --> 00:44:50,560
the verifier takes the claimed result by

1111
00:44:50,560 --> 00:44:53,359
y-i-tilda raises it to the power q to

1112
00:44:53,359 --> 00:44:56,720
the c and then obtains uh the result the

1113
00:44:56,720 --> 00:44:58,480
verifier is actually interested in

1114
00:44:58,480 --> 00:45:00,640
namely y-i which is the result of the

1115
00:45:00,640 --> 00:45:05,040
exponentiation with q to the t

1116
00:45:05,040 --> 00:45:07,839
now why is this happening for us

1117
00:45:07,839 --> 00:45:10,160
again let's assume the approval cheats

1118
00:45:10,160 --> 00:45:12,480
and statement k multiplies the statement

1119
00:45:12,480 --> 00:45:16,400
by with a bad element alpha

1120
00:45:17,280 --> 00:45:21,200
now if this alpha has low order

1121
00:45:21,200 --> 00:45:23,200
then we know now that the order of alpha

1122
00:45:23,200 --> 00:45:24,560
divides

1123
00:45:24,560 --> 00:45:26,319
q to the c

1124
00:45:26,319 --> 00:45:28,079
because this is exactly how we've chosen

1125
00:45:28,079 --> 00:45:30,319
q q is the product of all small prime

1126
00:45:30,319 --> 00:45:32,720
numbers and c is large enough

1127
00:45:32,720 --> 00:45:34,880
so

1128
00:45:34,880 --> 00:45:36,560
so what happens when the verifier

1129
00:45:36,560 --> 00:45:39,280
performs this final exponentiation

1130
00:45:39,280 --> 00:45:40,880
where the verifier raises the bit

1131
00:45:40,880 --> 00:45:42,880
element by q to the c

1132
00:45:42,880 --> 00:45:44,400
and because this is a multiple of its

1133
00:45:44,400 --> 00:45:46,720
order the element vanishes

1134
00:45:46,720 --> 00:45:48,720
and so what the verifier ends up with is

1135
00:45:48,720 --> 00:45:51,440
the correct result y k

1136
00:45:51,440 --> 00:45:53,599
so even if the approver cheats with a

1137
00:45:53,599 --> 00:45:55,359
low order element in this intermediate

1138
00:45:55,359 --> 00:45:57,200
result with the exponent q to the t

1139
00:45:57,200 --> 00:45:58,319
minus c

1140
00:45:58,319 --> 00:46:00,079
the verifier does not care about that

1141
00:46:00,079 --> 00:46:01,760
because all the verifier is interested

1142
00:46:01,760 --> 00:46:04,319
in is the final result with the exponent

1143
00:46:04,319 --> 00:46:06,480
q to the t and this is what the verifier

1144
00:46:06,480 --> 00:46:07,520
gets

1145
00:46:07,520 --> 00:46:09,200
even if the prover cheats with some low

1146
00:46:09,200 --> 00:46:11,919
order elements

1147
00:46:12,000 --> 00:46:13,359
and

1148
00:46:13,359 --> 00:46:15,760
okay yeah so this is the result of the

1149
00:46:15,760 --> 00:46:18,480
exponentiation

1150
00:46:18,480 --> 00:46:20,480
and this allows us to reduce the proof

1151
00:46:20,480 --> 00:46:22,400
size of blocked i

1152
00:46:22,400 --> 00:46:24,640
from lambda times lobster elements to

1153
00:46:24,640 --> 00:46:29,799
lambda times log t divided by log b

1154
00:46:30,000 --> 00:46:32,400
okay so let's recap

1155
00:46:32,400 --> 00:46:34,880
how does our basic protocol look like

1156
00:46:34,880 --> 00:46:37,920
so we define this q of a special form

1157
00:46:37,920 --> 00:46:41,119
and then we change the instances so

1158
00:46:41,119 --> 00:46:43,440
we let the proverb only prove statements

1159
00:46:43,440 --> 00:46:47,359
for exponent q to the t minus c

1160
00:46:47,359 --> 00:46:49,599
then we reduce the number of elements

1161
00:46:49,599 --> 00:46:52,000
and statements to verify our improvers

1162
00:46:52,000 --> 00:46:53,760
they prove

1163
00:46:53,760 --> 00:46:55,040
to row

1164
00:46:55,040 --> 00:46:57,440
which we define as lambda divided by log

1165
00:46:57,440 --> 00:46:58,720
b

1166
00:46:58,720 --> 00:47:00,480
this means that if the prover cheats

1167
00:47:00,480 --> 00:47:02,319
with low order elements

1168
00:47:02,319 --> 00:47:04,240
the verifier might not catch it in the

1169
00:47:04,240 --> 00:47:06,240
interactive phase

1170
00:47:06,240 --> 00:47:08,640
because we have now reduced the number

1171
00:47:08,640 --> 00:47:10,400
of repetitions

1172
00:47:10,400 --> 00:47:12,720
however the verifier then performs the

1173
00:47:12,720 --> 00:47:15,599
final exponentiation and still ends up

1174
00:47:15,599 --> 00:47:17,599
with the true result of the

1175
00:47:17,599 --> 00:47:21,280
exponentiation with q to the t

1176
00:47:21,280 --> 00:47:25,520
okay so um yeah to

1177
00:47:25,520 --> 00:47:28,160
conclude why is the statistical sound

1178
00:47:28,160 --> 00:47:29,760
where

1179
00:47:29,760 --> 00:47:32,319
if the prover cheats with element alpha

1180
00:47:32,319 --> 00:47:34,480
and if the order of alpha divides q to

1181
00:47:34,480 --> 00:47:36,559
the c then the verifier obtains the

1182
00:47:36,559 --> 00:47:39,520
correct result and we're happy

1183
00:47:39,520 --> 00:47:41,680
if the order of alpha does not divide q

1184
00:47:41,680 --> 00:47:44,319
to the c by our definition of q then

1185
00:47:44,319 --> 00:47:46,720
alpha has sufficiently large order and

1186
00:47:46,720 --> 00:47:48,400
so we know that the verifier will reject

1187
00:47:48,400 --> 00:47:50,240
after the interactive phase with high

1188
00:47:50,240 --> 00:47:53,240
probability

1189
00:47:54,400 --> 00:47:56,160
okay now let me say some words on the

1190
00:47:56,160 --> 00:47:59,040
parameters q and b

1191
00:47:59,040 --> 00:48:01,599
because note that if you define q

1192
00:48:01,599 --> 00:48:03,760
like this we let q be the product of all

1193
00:48:03,760 --> 00:48:05,839
small prime numbers then if we increase

1194
00:48:05,839 --> 00:48:07,040
the bond b

1195
00:48:07,040 --> 00:48:10,079
of course q increases exponentially

1196
00:48:10,079 --> 00:48:12,480
so q will be quite large

1197
00:48:12,480 --> 00:48:14,480
however in the application we consider

1198
00:48:14,480 --> 00:48:16,640
this is actually to our advantage

1199
00:48:16,640 --> 00:48:18,960
because in block at i

1200
00:48:18,960 --> 00:48:21,599
you need a very large q to ensure

1201
00:48:21,599 --> 00:48:23,280
soundness of the polynomial commitment

1202
00:48:23,280 --> 00:48:25,440
anyways so in particular q has to be

1203
00:48:25,440 --> 00:48:26,960
much larger than two to the n times

1204
00:48:26,960 --> 00:48:30,400
polylambda where n is the size of the

1205
00:48:30,400 --> 00:48:32,559
input

1206
00:48:32,559 --> 00:48:34,960
also in vdfs you can just if the queue

1207
00:48:34,960 --> 00:48:36,880
is very large then you can just adjust

1208
00:48:36,880 --> 00:48:39,040
the cost of the initial exponentiation

1209
00:48:39,040 --> 00:48:41,599
by adjusting the time parameter t so we

1210
00:48:41,599 --> 00:48:45,599
will then choose t a little bit smaller

1211
00:48:45,920 --> 00:48:49,200
so let's look at an example with numbers

1212
00:48:49,200 --> 00:48:50,720
let's set the statistic security

1213
00:48:50,720 --> 00:48:52,559
parameter to be 80

1214
00:48:52,559 --> 00:48:56,559
and t is 2 to the 32

1215
00:48:56,559 --> 00:48:58,480
and practice and then let's choose the

1216
00:48:58,480 --> 00:49:02,079
bond b to be the prime number 521

1217
00:49:02,079 --> 00:49:03,520
then q is

1218
00:49:03,520 --> 00:49:07,599
approximately of this size 2 to the 703

1219
00:49:07,599 --> 00:49:10,319
and then we can do the computation and

1220
00:49:10,319 --> 00:49:14,960
see that the proof says drops from 655

1221
00:49:14,960 --> 00:49:18,720
to 74 kilobytes

1222
00:49:20,079 --> 00:49:23,040
so to sum up let's look at a comparison

1223
00:49:23,040 --> 00:49:25,119
of the periods that we know

1224
00:49:25,119 --> 00:49:26,240
we're going to look at the cost of

1225
00:49:26,240 --> 00:49:28,720
verifying lambda many peris because this

1226
00:49:28,720 --> 00:49:29,920
is what need what's needed in the

1227
00:49:29,920 --> 00:49:32,480
application of blocked iron

1228
00:49:32,480 --> 00:49:34,640
so we have seen that the theories of

1229
00:49:34,640 --> 00:49:36,319
vasolus can paycheck are very very

1230
00:49:36,319 --> 00:49:38,079
efficient however they are not

1231
00:49:38,079 --> 00:49:40,400
statistically sound in every group

1232
00:49:40,400 --> 00:49:42,319
the first pe that's statistically sound

1233
00:49:42,319 --> 00:49:44,079
in every group is the one by block it

1234
00:49:44,079 --> 00:49:44,880
out

1235
00:49:44,880 --> 00:49:47,040
however the proof size increases to

1236
00:49:47,040 --> 00:49:49,599
lambda times log t

1237
00:49:49,599 --> 00:49:51,839
now we have seen in this talk that with

1238
00:49:51,839 --> 00:49:52,880
our

1239
00:49:52,880 --> 00:49:55,200
basic protocol we can reduce the proof

1240
00:49:55,200 --> 00:49:56,240
size

1241
00:49:56,240 --> 00:50:00,079
to lambda times log t divided by log b

1242
00:50:00,079 --> 00:50:02,480
however what we have not seen is that by

1243
00:50:02,480 --> 00:50:05,440
doing so the verifier phase complexity

1244
00:50:05,440 --> 00:50:06,960
increases because now the final

1245
00:50:06,960 --> 00:50:08,960
exponentiations the verifier has to

1246
00:50:08,960 --> 00:50:12,160
perform are a bit more costly

1247
00:50:12,160 --> 00:50:14,319
however we show in our paper is that we

1248
00:50:14,319 --> 00:50:16,079
can handle this this way

1249
00:50:16,079 --> 00:50:19,359
by recursing on the claims with exponent

1250
00:50:19,359 --> 00:50:21,520
q to the c and then matching claims

1251
00:50:21,520 --> 00:50:22,960
together

1252
00:50:22,960 --> 00:50:25,839
and um yeah doing so we can also reduce

1253
00:50:25,839 --> 00:50:27,680
the verifies complexity

1254
00:50:27,680 --> 00:50:29,440
until it's lower than the one in blocked

1255
00:50:29,440 --> 00:50:31,680
eye

1256
00:50:31,920 --> 00:50:34,960
and yeah this is all i wanted to say

1257
00:50:34,960 --> 00:50:39,160
and now i'm happy to take questions

1258
00:50:44,720 --> 00:50:46,559
all right so we do have time for

1259
00:50:46,559 --> 00:50:48,400
questions yes please go ahead in the

1260
00:50:48,400 --> 00:50:51,400
back

1261
00:50:55,200 --> 00:50:57,520
right

1262
00:51:05,680 --> 00:51:08,960
okay anyways

1263
00:51:08,960 --> 00:51:10,800
okay also repeat the question perhaps

1264
00:51:10,800 --> 00:51:13,200
for the zoom right okay

1265
00:51:13,200 --> 00:51:15,440
so the question was if i can talk more

1266
00:51:15,440 --> 00:51:17,359
about the parameter c and in which cases

1267
00:51:17,359 --> 00:51:19,920
you would choose c bigger in comparison

1268
00:51:19,920 --> 00:51:23,599
to choosing the bound b to be bigger

1269
00:51:23,599 --> 00:51:26,559
so we usually want c to be small

1270
00:51:26,559 --> 00:51:29,200
because of um the final exponentiation

1271
00:51:29,200 --> 00:51:31,040
so c is the number

1272
00:51:31,040 --> 00:51:33,040
um okay so when the verifier computes

1273
00:51:33,040 --> 00:51:35,920
the final exponentiation with q to the c

1274
00:51:35,920 --> 00:51:38,480
it has to perform c exponentiations

1275
00:51:38,480 --> 00:51:40,400
right so we want to choose c as small as

1276
00:51:40,400 --> 00:51:41,920
possible

1277
00:51:41,920 --> 00:51:44,800
however um

1278
00:51:44,800 --> 00:51:46,800
okay what we have not seen here is that

1279
00:51:46,800 --> 00:51:47,760
if you

1280
00:51:47,760 --> 00:51:49,119
if the

1281
00:51:49,119 --> 00:51:50,720
if the order of the bet element is the

1282
00:51:50,720 --> 00:51:52,319
small prime power

1283
00:51:52,319 --> 00:51:54,000
then the prover does not need to get rid

1284
00:51:54,000 --> 00:51:56,240
of this bad element in one go but it can

1285
00:51:56,240 --> 00:51:58,400
just reduce the order of the element in

1286
00:51:58,400 --> 00:52:01,040
every round it can just like yeah lose

1287
00:52:01,040 --> 00:52:03,359
some factors of two for example

1288
00:52:03,359 --> 00:52:06,160
and so this is why we need c to be at

1289
00:52:06,160 --> 00:52:08,319
least this big so at least log t times

1290
00:52:08,319 --> 00:52:11,440
log b such that um

1291
00:52:11,440 --> 00:52:14,160
again the yeah so the

1292
00:52:14,160 --> 00:52:16,160
probability of the bad event which is

1293
00:52:16,160 --> 00:52:18,400
that it loses too many factors of too

1294
00:52:18,400 --> 00:52:23,119
many powers of two is again one over b

1295
00:52:23,119 --> 00:52:25,359
um right so

1296
00:52:25,359 --> 00:52:27,040
yeah you but generally you want to

1297
00:52:27,040 --> 00:52:30,160
choose c is more

1298
00:52:30,480 --> 00:52:32,400
we have time for one more question yeah

1299
00:52:32,400 --> 00:52:35,800
please go ahead

1300
00:52:46,079 --> 00:52:47,119
um

1301
00:52:47,119 --> 00:52:48,400
so

1302
00:52:48,400 --> 00:52:49,920
no the group order does not need to be

1303
00:52:49,920 --> 00:52:52,800
known by anyone however so here we look

1304
00:52:52,800 --> 00:52:54,559
just at the proof of exponentiation

1305
00:52:54,559 --> 00:52:56,160
right and so this is sound even if the

1306
00:52:56,160 --> 00:52:57,920
proof word is known here we don't need

1307
00:52:57,920 --> 00:52:59,760
any assumption of course if you then

1308
00:52:59,760 --> 00:53:01,520
want to use it in a verifiable delay

1309
00:53:01,520 --> 00:53:03,920
function for the delay property you will

1310
00:53:03,920 --> 00:53:05,680
need the assumption that the group order

1311
00:53:05,680 --> 00:53:06,960
is unknown

1312
00:53:06,960 --> 00:53:08,960
but the proof is sound

1313
00:53:08,960 --> 00:53:12,599
statistically sound

1314
00:53:14,480 --> 00:53:15,599
then you

1315
00:53:15,599 --> 00:53:17,520
uh don't have to delay property rights

1316
00:53:17,520 --> 00:53:18,880
but um

1317
00:53:18,880 --> 00:53:20,960
right so this is for vdfs but in the

1318
00:53:20,960 --> 00:53:22,720
application of blocked id you don't you

1319
00:53:22,720 --> 00:53:24,079
don't need the delay property you just

1320
00:53:24,079 --> 00:53:25,200
want to prove a very large

1321
00:53:25,200 --> 00:53:28,200
exponentiation

1322
00:53:29,359 --> 00:53:31,280
okay so let's thank the speaker again

1323
00:53:31,280 --> 00:53:33,599
thank you

1324
00:53:39,119 --> 00:53:42,319
and now we're getting uh ready for the

1325
00:53:42,319 --> 00:53:46,800
third and final talk of this session

1326
00:53:46,800 --> 00:53:48,559
of the blockchain session

1327
00:53:48,559 --> 00:53:50,400
the title

1328
00:53:50,400 --> 00:53:53,920
is formalizing delayed adaptive

1329
00:53:53,920 --> 00:53:55,520
corruptions

1330
00:53:55,520 --> 00:53:56,400
and

1331
00:53:56,400 --> 00:53:59,839
the security of flooding networks

1332
00:53:59,839 --> 00:54:01,760
and the talk will be given by soren

1333
00:54:01,760 --> 00:54:03,359
eller thompson

1334
00:54:03,359 --> 00:54:05,599
who is just setting up now

1335
00:54:05,599 --> 00:54:09,480
his microphone and slides

1336
00:54:49,920 --> 00:54:52,079
right so hi everyone my name is sun

1337
00:54:52,079 --> 00:54:54,160
thompson and i'll be presenting the work

1338
00:54:54,160 --> 00:54:56,160
formalizing delayed adaptive corruptions

1339
00:54:56,160 --> 00:54:58,559
and the security of flooding networks

1340
00:54:58,559 --> 00:55:00,240
so this is joint work with christian

1341
00:55:00,240 --> 00:55:02,799
matt among the audience and my

1342
00:55:02,799 --> 00:55:05,359
supervisor especially

1343
00:55:05,359 --> 00:55:07,920
so since we are at the blockchain

1344
00:55:07,920 --> 00:55:09,440
session of crypto i thought i would

1345
00:55:09,440 --> 00:55:11,760
motivate this work using the example of

1346
00:55:11,760 --> 00:55:15,520
nakamoto style blockchain

1347
00:55:17,920 --> 00:55:18,960
all right

1348
00:55:18,960 --> 00:55:21,920
yeah so macbook style blockchain is a

1349
00:55:21,920 --> 00:55:23,520
type of protocol where a group of

1350
00:55:23,520 --> 00:55:25,599
parties participate in some lottery

1351
00:55:25,599 --> 00:55:27,520
which can be instantiated as proof of

1352
00:55:27,520 --> 00:55:29,040
work proof of space proof of maybe

1353
00:55:29,040 --> 00:55:30,799
useful work

1354
00:55:30,799 --> 00:55:33,280
etc so the way this type of protocol

1355
00:55:33,280 --> 00:55:35,280
works is that parties build the total

1356
00:55:35,280 --> 00:55:37,599
order using this lottery to take turns

1357
00:55:37,599 --> 00:55:38,480
on

1358
00:55:38,480 --> 00:55:40,640
on whom to that are allowed to extend

1359
00:55:40,640 --> 00:55:42,640
this total order

1360
00:55:42,640 --> 00:55:44,799
so for example if alice wins the lottery

1361
00:55:44,799 --> 00:55:46,240
well then she will be the first one to

1362
00:55:46,240 --> 00:55:47,680
extend the order and he can create a

1363
00:55:47,680 --> 00:55:50,400
block with the transactions

1364
00:55:50,400 --> 00:55:52,960
and afterwards if bob now wins the

1365
00:55:52,960 --> 00:55:54,960
lottery well then he can extend the

1366
00:55:54,960 --> 00:55:56,559
current base chain which will be adjust

1367
00:55:56,559 --> 00:55:58,640
alice's block and propagate this block

1368
00:55:58,640 --> 00:56:00,160
to his

1369
00:56:00,160 --> 00:56:02,319
all the other parties in the protocol

1370
00:56:02,319 --> 00:56:04,400
this continues on

1371
00:56:04,400 --> 00:56:06,319
and there will be sort of a long chain

1372
00:56:06,319 --> 00:56:08,799
of order transactions

1373
00:56:08,799 --> 00:56:11,440
however what may happen is that a party

1374
00:56:11,440 --> 00:56:13,520
wins the lottery of two parties wins the

1375
00:56:13,520 --> 00:56:15,359
lottery without knowing about the

1376
00:56:15,359 --> 00:56:17,680
previous extension of the fork of the

1377
00:56:17,680 --> 00:56:19,440
best chain well then we might have a

1378
00:56:19,440 --> 00:56:21,839
fork there's no longer any clear total

1379
00:56:21,839 --> 00:56:23,520
order

1380
00:56:23,520 --> 00:56:25,520
this can also happen sort of maliciously

1381
00:56:25,520 --> 00:56:28,240
if for example mallory an adversary

1382
00:56:28,240 --> 00:56:29,760
chooses to

1383
00:56:29,760 --> 00:56:32,079
extend something that's older than the

1384
00:56:32,079 --> 00:56:34,160
current best chain well then this this

1385
00:56:34,160 --> 00:56:36,319
doesn't create a total order either

1386
00:56:36,319 --> 00:56:37,839
so in order for this type of protocols

1387
00:56:37,839 --> 00:56:40,640
to be secure what we need is that the

1388
00:56:40,640 --> 00:56:43,599
honest parties they outgrow the

1389
00:56:43,599 --> 00:56:45,920
adversarial blocks in particular the

1390
00:56:45,920 --> 00:56:48,799
honest blocks which have sufficient time

1391
00:56:48,799 --> 00:56:50,960
to propagate between parties they need

1392
00:56:50,960 --> 00:56:52,799
to outload the number of blocks created

1393
00:56:52,799 --> 00:56:54,400
by the adversary

1394
00:56:54,400 --> 00:56:56,400
so this actually naturally induces some

1395
00:56:56,400 --> 00:56:57,920
requirements on how we actually

1396
00:56:57,920 --> 00:56:59,839
propagate this block in order for it to

1397
00:56:59,839 --> 00:57:02,160
be secure

1398
00:57:02,160 --> 00:57:04,000
so what is typically done is to assume

1399
00:57:04,000 --> 00:57:05,920
some kind of flooding network which has

1400
00:57:05,920 --> 00:57:09,119
the property that if one party one for

1401
00:57:09,119 --> 00:57:10,640
example wins the right to create the

1402
00:57:10,640 --> 00:57:13,280
block now inputs this block to the

1403
00:57:13,280 --> 00:57:14,720
plotting network

1404
00:57:14,720 --> 00:57:17,200
well then there must be a bound time

1405
00:57:17,200 --> 00:57:20,240
filter such that if the block is input

1406
00:57:20,240 --> 00:57:22,160
at time t then it must be delivered to

1407
00:57:22,160 --> 00:57:24,160
all other honest parties before time t

1408
00:57:24,160 --> 00:57:26,480
plus delta

1409
00:57:26,480 --> 00:57:27,680
and this has

1410
00:57:27,680 --> 00:57:29,280
such functionality has been assumed in

1411
00:57:29,280 --> 00:57:30,400
order to prove

1412
00:57:30,400 --> 00:57:32,799
like motor style blockchain secure

1413
00:57:32,799 --> 00:57:34,559
so this talk is about how to implement

1414
00:57:34,559 --> 00:57:37,200
this functionality

1415
00:57:37,200 --> 00:57:39,599
all right so now let's just look at how

1416
00:57:39,599 --> 00:57:41,440
this functionality is implemented in

1417
00:57:41,440 --> 00:57:42,880
practice

1418
00:57:42,880 --> 00:57:45,280
so again we have the lottery and if p1

1419
00:57:45,280 --> 00:57:46,559
happens to be the winner of the lottery

1420
00:57:46,559 --> 00:57:48,240
and allowed to extend the best chain

1421
00:57:48,240 --> 00:57:51,520
create a block well then what p1 does is

1422
00:57:51,520 --> 00:57:53,280
to send this block out to his

1423
00:57:53,280 --> 00:57:54,799
neighborhood

1424
00:57:54,799 --> 00:57:57,760
and then what this neighbor does is well

1425
00:57:57,760 --> 00:57:59,280
they will send it to their neighbors and

1426
00:57:59,280 --> 00:58:02,160
so on so forth onto all parties now know

1427
00:58:02,160 --> 00:58:03,760
the block

1428
00:58:03,760 --> 00:58:06,160
this work all well and good as long as

1429
00:58:06,160 --> 00:58:08,400
we are analyzing it against a static

1430
00:58:08,400 --> 00:58:09,599
adversary

1431
00:58:09,599 --> 00:58:12,400
however as you will soon see this is not

1432
00:58:12,400 --> 00:58:16,720
ideal is it's an adaptive adversary

1433
00:58:16,960 --> 00:58:18,559
so

1434
00:58:18,559 --> 00:58:20,480
if we are to analyze this situation

1435
00:58:20,480 --> 00:58:22,160
against an adaptive adversary we need to

1436
00:58:22,160 --> 00:58:23,680
make an assumption on the underlying

1437
00:58:23,680 --> 00:58:25,920
channels so we can choose to assume a

1438
00:58:25,920 --> 00:58:28,160
non-atomic message send channel we can

1439
00:58:28,160 --> 00:58:30,160
choose to assume an atomic message

1440
00:58:30,160 --> 00:58:32,480
channel let's first assume a non-atomic

1441
00:58:32,480 --> 00:58:34,240
message says child

1442
00:58:34,240 --> 00:58:36,720
so what so at the moment t1 wins starts

1443
00:58:36,720 --> 00:58:39,119
sending out this block to everyone

1444
00:58:39,119 --> 00:58:40,880
then um

1445
00:58:40,880 --> 00:58:43,200
well that's very immediately learns this

1446
00:58:43,200 --> 00:58:44,720
the message or the block is leaked to

1447
00:58:44,720 --> 00:58:46,480
the adversary and he sees that p1 is

1448
00:58:46,480 --> 00:58:48,240
actually sending this out

1449
00:58:48,240 --> 00:58:50,240
because we're assuming non-atomic

1450
00:58:50,240 --> 00:58:51,920
message sense channels whether an

1451
00:58:51,920 --> 00:58:53,440
adversary is now given the possibility

1452
00:58:53,440 --> 00:58:55,440
to corrupt p1

1453
00:58:55,440 --> 00:58:57,920
and because it's non-atomic well then he

1454
00:58:57,920 --> 00:59:00,079
can actually retract the message thereby

1455
00:59:00,079 --> 00:59:02,000
prevent the delivery of this block to

1456
00:59:02,000 --> 00:59:04,319
the remaining honest parties this makes

1457
00:59:04,319 --> 00:59:06,000
gives an insecure blockchain right

1458
00:59:06,000 --> 00:59:08,960
because now no longer these

1459
00:59:08,960 --> 00:59:10,400
blocks which have sufficient time to

1460
00:59:10,400 --> 00:59:12,960
propagate no longer be sufficient

1461
00:59:12,960 --> 00:59:14,480
managed to outgrow

1462
00:59:14,480 --> 00:59:16,880
an adversary

1463
00:59:16,880 --> 00:59:18,480
of course what you could do is to assume

1464
00:59:18,480 --> 00:59:20,319
atomic message sent instead

1465
00:59:20,319 --> 00:59:22,400
so now that you can no longer do this

1466
00:59:22,400 --> 00:59:24,000
this thing of corrupting the center of

1467
00:59:24,000 --> 00:59:25,599
the message and thereby retracting the

1468
00:59:25,599 --> 00:59:27,760
message which has already been sent

1469
00:59:27,760 --> 00:59:30,480
however what the episode can do is

1470
00:59:30,480 --> 00:59:31,680
instead to corrupt the entire

1471
00:59:31,680 --> 00:59:34,480
neighborhood p1 and thereby prevent

1472
00:59:34,480 --> 00:59:35,839
this message

1473
00:59:35,839 --> 00:59:39,040
so this doesn't work either

1474
00:59:39,359 --> 00:59:40,400
of course

1475
00:59:40,400 --> 00:59:42,160
assuming atomic message sends a sender

1476
00:59:42,160 --> 00:59:44,319
could now send to all parties

1477
00:59:44,319 --> 00:59:46,240
but and this then that which i will not

1478
00:59:46,240 --> 00:59:48,480
have the possibility to to

1479
00:59:48,480 --> 00:59:51,520
adapt uh to corrupt the neighborhood but

1480
00:59:51,520 --> 00:59:52,880
this will also induce quite a heavy

1481
00:59:52,880 --> 00:59:55,280
workload on p1 but therefore this is

1482
00:59:55,280 --> 00:59:57,760
impractical

1483
00:59:57,760 --> 00:59:59,680
in this work what we do is to assume a

1484
00:59:59,680 --> 01:00:01,359
delta delayed episode

1485
01:00:01,359 --> 01:00:04,240
this is a type of adversary where

1486
01:00:04,240 --> 01:00:06,240
once the adversary chooses to corrupt a

1487
01:00:06,240 --> 01:00:08,880
party there will be a time delta

1488
01:00:08,880 --> 01:00:10,559
which will pass until the adversary

1489
01:00:10,559 --> 01:00:12,400
effectively gains control over this

1490
01:00:12,400 --> 01:00:14,640
party

1491
01:00:14,640 --> 01:00:15,520
this is

1492
01:00:15,520 --> 01:00:17,680
not only useful for flooding networks

1493
01:00:17,680 --> 01:00:20,000
but this has also informally been

1494
01:00:20,000 --> 01:00:22,559
considered by passenger or long-lived

1495
01:00:22,559 --> 01:00:24,400
committees

1496
01:00:24,400 --> 01:00:27,200
so let's try to to see how this why this

1497
01:00:27,200 --> 01:00:29,119
gain some intuition for why this helps

1498
01:00:29,119 --> 01:00:30,880
with

1499
01:00:30,880 --> 01:00:32,559
the flooding

1500
01:00:32,559 --> 01:00:34,640
so um

1501
01:00:34,640 --> 01:00:36,160
of course if

1502
01:00:36,160 --> 01:00:38,880
the adversary is delayed for a long time

1503
01:00:38,880 --> 01:00:40,160
longer than the time it takes to

1504
01:00:40,160 --> 01:00:42,240
propagate this message to all parties

1505
01:00:42,240 --> 01:00:43,520
well then it's kind of clear that he

1506
01:00:43,520 --> 01:00:45,440
cannot really interfere

1507
01:00:45,440 --> 01:00:46,880
even though he tries to corrupt because

1508
01:00:46,880 --> 01:00:48,480
the corruption will only be effectuated

1509
01:00:48,480 --> 01:00:50,319
afterwards

1510
01:00:50,319 --> 01:00:52,000
but intuitively you can do kind of

1511
01:00:52,000 --> 01:00:52,880
better

1512
01:00:52,880 --> 01:00:54,480
what we could assume is that the

1513
01:00:54,480 --> 01:00:56,960
adversary is only delayed by the time it

1514
01:00:56,960 --> 01:00:59,280
takes to send through a channel plus the

1515
01:00:59,280 --> 01:01:01,920
time to reason for a channel

1516
01:01:01,920 --> 01:01:04,160
so if we assume this well then at the

1517
01:01:04,160 --> 01:01:05,760
moment

1518
01:01:05,760 --> 01:01:07,359
sender sends out the message that so you

1519
01:01:07,359 --> 01:01:10,319
can now still try to corrupt

1520
01:01:10,319 --> 01:01:11,680
this neighborhood

1521
01:01:11,680 --> 01:01:13,680
but it's kind of too late because it's

1522
01:01:13,680 --> 01:01:15,440
guaranteed that these parties have

1523
01:01:15,440 --> 01:01:17,119
sufficient time to send out to just

1524
01:01:17,119 --> 01:01:19,200
their neighbors thereby

1525
01:01:19,200 --> 01:01:20,720
sort of the message has been propagated

1526
01:01:20,720 --> 01:01:23,200
one layer further

1527
01:01:23,200 --> 01:01:26,559
so this won't really help an adversary

1528
01:01:26,559 --> 01:01:29,200
so in our work we give two main

1529
01:01:29,200 --> 01:01:31,760
contributions first we provide formal

1530
01:01:31,760 --> 01:01:33,599
and provide precise semantics for delta

1531
01:01:33,599 --> 01:01:35,200
delayed adversaries within the uc

1532
01:01:35,200 --> 01:01:36,559
framework

1533
01:01:36,559 --> 01:01:39,119
then we use this um to

1534
01:01:39,119 --> 01:01:40,720
build two instantiations of plotting

1535
01:01:40,720 --> 01:01:42,319
networks that are secure against an

1536
01:01:42,319 --> 01:01:44,480
adaptive adversary delayed for the time

1537
01:01:44,480 --> 01:01:46,319
it takes to send plus the time it takes

1538
01:01:46,319 --> 01:01:48,240
to resend those matching this intuition

1539
01:01:48,240 --> 01:01:50,319
i gave just before

1540
01:01:50,319 --> 01:01:52,799
our first instantiation has a constant

1541
01:01:52,799 --> 01:01:55,119
neighborhood with a logarithmic diameter

1542
01:01:55,119 --> 01:01:57,760
and our second implementation gives a

1543
01:01:57,760 --> 01:01:59,119
square root number of neighbors with

1544
01:01:59,119 --> 01:02:01,599
just a constant diameter

1545
01:02:01,599 --> 01:02:03,359
so let's just jump right into how to

1546
01:02:03,359 --> 01:02:06,799
define delayed adversaries within uc

1547
01:02:06,799 --> 01:02:09,039
so let me first give you a

1548
01:02:09,039 --> 01:02:10,960
quick sketch of a security notion from

1549
01:02:10,960 --> 01:02:11,839
uc

1550
01:02:11,839 --> 01:02:13,440
that is that we have if we have a

1551
01:02:13,440 --> 01:02:16,960
protocol which uses some ideal resource

1552
01:02:16,960 --> 01:02:19,680
well then an experiment set up where an

1553
01:02:19,680 --> 01:02:22,079
adversary is allowed to to

1554
01:02:22,079 --> 01:02:24,160
influence this the execution of this

1555
01:02:24,160 --> 01:02:26,880
protocol using the resource

1556
01:02:26,880 --> 01:02:28,079
then

1557
01:02:28,079 --> 01:02:30,720
an environment is uh can now play with

1558
01:02:30,720 --> 01:02:33,280
this setup we provide inputs to the

1559
01:02:33,280 --> 01:02:35,680
protocol and also

1560
01:02:35,680 --> 01:02:37,520
talk with the adversary

1561
01:02:37,520 --> 01:02:39,280
now the security notion is given by

1562
01:02:39,280 --> 01:02:41,680
defining another experiment where some

1563
01:02:41,680 --> 01:02:43,440
ideal resource if

1564
01:02:43,440 --> 01:02:45,200
this is an ideal specification of the

1565
01:02:45,200 --> 01:02:46,960
actual protocol

1566
01:02:46,960 --> 01:02:49,039
in intact with some dummy parties which

1567
01:02:49,039 --> 01:02:51,520
simply forwards all messages sent from

1568
01:02:51,520 --> 01:02:53,599
um the environment

1569
01:02:53,599 --> 01:02:56,240
and a simulator this simulator can be

1570
01:02:56,240 --> 01:02:58,720
thought of as a translation of the

1571
01:02:58,720 --> 01:03:01,200
attack in the on the real protocol to an

1572
01:03:01,200 --> 01:03:03,920
attack in the ideal on the ideal

1573
01:03:03,920 --> 01:03:05,280
specification

1574
01:03:05,280 --> 01:03:08,160
and then security is giving us that

1575
01:03:08,160 --> 01:03:10,400
for all such adversaries there's exist

1576
01:03:10,400 --> 01:03:12,079
simulator such that no environment can

1577
01:03:12,079 --> 01:03:15,440
distinguish these two experiments

1578
01:03:15,440 --> 01:03:18,400
um so

1579
01:03:18,559 --> 01:03:21,359
what is interesting is how the episode

1580
01:03:21,359 --> 01:03:23,599
can now influence the execution of the

1581
01:03:23,599 --> 01:03:25,440
protocol

1582
01:03:25,440 --> 01:03:27,039
and actually there are no built in

1583
01:03:27,039 --> 01:03:28,720
semantics for this

1584
01:03:28,720 --> 01:03:31,039
this means that each individual machine

1585
01:03:31,039 --> 01:03:34,000
in the protocol determines what to do

1586
01:03:34,000 --> 01:03:36,559
when receiving something on this channel

1587
01:03:36,559 --> 01:03:38,240
from the adversary

1588
01:03:38,240 --> 01:03:40,240
and this is exactly what we tap into

1589
01:03:40,240 --> 01:03:41,920
when we

1590
01:03:41,920 --> 01:03:44,160
when we define our delta delayed

1591
01:03:44,160 --> 01:03:45,760
corruptions in uc

1592
01:03:45,760 --> 01:03:48,000
so what we do is that we wrap each

1593
01:03:48,000 --> 01:03:49,039
machine

1594
01:03:49,039 --> 01:03:51,280
in the protocol with a small rabble

1595
01:03:51,280 --> 01:03:52,559
called shell

1596
01:03:52,559 --> 01:03:54,079
this is now what enforces some

1597
01:03:54,079 --> 01:03:55,680
restrictions on the behavior of each

1598
01:03:55,680 --> 01:03:57,599
individual machine when receiving

1599
01:03:57,599 --> 01:04:00,720
something by from the adversary

1600
01:04:00,720 --> 01:04:03,520
and similarly well um

1601
01:04:03,520 --> 01:04:06,559
how the simulator can now influence

1602
01:04:06,559 --> 01:04:09,599
the ideal resources that is also defined

1603
01:04:09,599 --> 01:04:11,440
that's a part of the ideal specification

1604
01:04:11,440 --> 01:04:13,119
of such protocol

1605
01:04:13,119 --> 01:04:15,119
so that's defined by

1606
01:04:15,119 --> 01:04:17,119
the ideal functionality itself and what

1607
01:04:17,119 --> 01:04:19,200
we do is to wrap ideal functionalities

1608
01:04:19,200 --> 01:04:21,280
in a rather similar to wrapper which we

1609
01:04:21,280 --> 01:04:22,000
use

1610
01:04:22,000 --> 01:04:23,839
for

1611
01:04:23,839 --> 01:04:25,359
parties

1612
01:04:25,359 --> 01:04:27,920
okay so let me now try to tell you what

1613
01:04:27,920 --> 01:04:30,000
these shields does

1614
01:04:30,000 --> 01:04:32,319
oh of course um what

1615
01:04:32,319 --> 01:04:33,760
since we were talking about delays we

1616
01:04:33,760 --> 01:04:35,599
need these shields somehow somehow have

1617
01:04:35,599 --> 01:04:37,119
access to time

1618
01:04:37,119 --> 01:04:39,039
and we use this notion of time from

1619
01:04:39,039 --> 01:04:40,720
tower tardis

1620
01:04:40,720 --> 01:04:42,640
which was by baum david dorsey and

1621
01:04:42,640 --> 01:04:45,599
nelson ix in 2021

1622
01:04:45,599 --> 01:04:47,599
okay so now let's jump into what these

1623
01:04:47,599 --> 01:04:50,240
these shells actually do

1624
01:04:50,240 --> 01:04:51,599
so

1625
01:04:51,599 --> 01:04:54,079
define what we call a delay shell for

1626
01:04:54,079 --> 01:04:56,640
the real world for protocols and this is

1627
01:04:56,640 --> 01:04:58,720
a parameter delta

1628
01:04:58,720 --> 01:05:01,280
so it's a very simple chill so it adds

1629
01:05:01,280 --> 01:05:03,200
three additional commands to to the

1630
01:05:03,200 --> 01:05:05,599
existing code of the protocol

1631
01:05:05,599 --> 01:05:07,760
and the first command is a pre-corrupt

1632
01:05:07,760 --> 01:05:09,440
command and what the shell does is

1633
01:05:09,440 --> 01:05:11,599
simply to note down the time when this

1634
01:05:11,599 --> 01:05:14,240
pre-corruption is received

1635
01:05:14,240 --> 01:05:17,200
then it allows corruption and what shell

1636
01:05:17,200 --> 01:05:18,960
does when receiving a corruption token

1637
01:05:18,960 --> 01:05:20,799
is to simply check if the current time

1638
01:05:20,799 --> 01:05:22,720
is at least delta time after a

1639
01:05:22,720 --> 01:05:25,280
pre-corruption has been received

1640
01:05:25,280 --> 01:05:27,440
that is the case it acts just as a

1641
01:05:27,440 --> 01:05:29,119
byzantine corruption and if that is not

1642
01:05:29,119 --> 01:05:30,880
the case it simply ignores this

1643
01:05:30,880 --> 01:05:33,839
premature corruption input

1644
01:05:33,839 --> 01:05:35,920
and finally provides a command

1645
01:05:35,920 --> 01:05:38,240
initialize which has a parameter tau

1646
01:05:38,240 --> 01:05:39,359
given to it

1647
01:05:39,359 --> 01:05:40,400
and this is

1648
01:05:40,400 --> 01:05:42,400
just a way for the adversary to to be

1649
01:05:42,400 --> 01:05:47,039
able to allow to corrupt parties before

1650
01:05:47,039 --> 01:05:50,640
the protocol execution actually starts

1651
01:05:50,640 --> 01:05:53,680
and actually our uh wrapper for ideal

1652
01:05:53,680 --> 01:05:55,440
functionalities has the exact same

1653
01:05:55,440 --> 01:05:57,119
behavior even though the notation is

1654
01:05:57,119 --> 01:05:58,720
slightly different it's the exact same

1655
01:05:58,720 --> 01:06:00,000
three commands

1656
01:06:00,000 --> 01:06:00,880
um

1657
01:06:00,880 --> 01:06:02,640
and that's that's the delta delayed

1658
01:06:02,640 --> 01:06:05,839
adversaries within uc

1659
01:06:05,839 --> 01:06:08,319
so for this model we are able to prove

1660
01:06:08,319 --> 01:06:10,640
two theorems and the first one is that

1661
01:06:10,640 --> 01:06:12,720
security against a byzantine adversary

1662
01:06:12,720 --> 01:06:14,559
apply security against a serial delayed

1663
01:06:14,559 --> 01:06:16,480
adversary

1664
01:06:16,480 --> 01:06:18,640
second theorem says well security

1665
01:06:18,640 --> 01:06:21,200
against far fast adversary implies

1666
01:06:21,200 --> 01:06:23,760
security against a slow adversary

1667
01:06:23,760 --> 01:06:26,160
this is very intuitive but what these

1668
01:06:26,160 --> 01:06:28,319
two theories allows us to to do is to

1669
01:06:28,319 --> 01:06:30,559
say given a protocol that is secure

1670
01:06:30,559 --> 01:06:33,680
against a byzantine adversary say for

1671
01:06:33,680 --> 01:06:35,520
example a nakamoto-style blockchain

1672
01:06:35,520 --> 01:06:38,000
which assumes a flooding network

1673
01:06:38,000 --> 01:06:39,680
well then we are able to upgrade the

1674
01:06:39,680 --> 01:06:41,280
security to

1675
01:06:41,280 --> 01:06:43,440
a delta delayed adversary and if we are

1676
01:06:43,440 --> 01:06:45,839
then able to prove the flooding network

1677
01:06:45,839 --> 01:06:48,079
secure against the delta delay adversary

1678
01:06:48,079 --> 01:06:49,440
then we will inherit the composition

1679
01:06:49,440 --> 01:06:52,640
theorem from uc and well the entire uh

1680
01:06:52,640 --> 01:06:54,079
composed protocol of this like

1681
01:06:54,079 --> 01:06:56,720
motorcycles style blockchain making use

1682
01:06:56,720 --> 01:06:58,400
of the flooding network will also be

1683
01:06:58,400 --> 01:07:01,839
secure against such adversary

1684
01:07:02,160 --> 01:07:03,839
okay so this is the model let me now

1685
01:07:03,839 --> 01:07:05,760
jump to a simple protocol

1686
01:07:05,760 --> 01:07:08,400
this is called at a relief plot here at

1687
01:07:08,400 --> 01:07:10,559
if rini refers to at the

1688
01:07:10,559 --> 01:07:13,200
grass where each edge

1689
01:07:13,200 --> 01:07:14,960
appears with an independent probability

1690
01:07:14,960 --> 01:07:16,240
row

1691
01:07:16,240 --> 01:07:18,480
and our protocol is

1692
01:07:18,480 --> 01:07:21,119
as simple as these graphs so what the

1693
01:07:21,119 --> 01:07:23,359
protocol says is that once i would like

1694
01:07:23,359 --> 01:07:25,200
to send out a message

1695
01:07:25,200 --> 01:07:27,520
then i forward it to each party with a

1696
01:07:27,520 --> 01:07:29,520
probability row

1697
01:07:29,520 --> 01:07:31,839
so if we have p1 and he wishes to uh

1698
01:07:31,839 --> 01:07:33,280
send out the message

1699
01:07:33,280 --> 01:07:35,039
well then he flips a coin that comes out

1700
01:07:35,039 --> 01:07:37,760
hit with probability row for p2

1701
01:07:37,760 --> 01:07:39,680
and continues to flip a coin for all

1702
01:07:39,680 --> 01:07:41,520
parties and only sends to those parties

1703
01:07:41,520 --> 01:07:43,280
where the

1704
01:07:43,280 --> 01:07:46,799
the coin comes out hits

1705
01:07:46,880 --> 01:07:49,599
so our main results uh stated slightly

1706
01:07:49,599 --> 01:07:51,839
informally is that this protocol er

1707
01:07:51,839 --> 01:07:53,839
flood implements a flooding network

1708
01:07:53,839 --> 01:07:55,680
against an adversary that is delayed for

1709
01:07:55,680 --> 01:07:57,839
the time it takes to send plus the time

1710
01:07:57,839 --> 01:07:59,359
it takes to resend

1711
01:07:59,359 --> 01:08:00,720
this decided with a square with number

1712
01:08:00,720 --> 01:08:02,720
of neighbors and like a diameter of just

1713
01:08:02,720 --> 01:08:03,520
two

1714
01:08:03,520 --> 01:08:04,960
or constant neighborhood and a

1715
01:08:04,960 --> 01:08:06,799
logarithmic diameter

1716
01:08:06,799 --> 01:08:08,880
let me now try to be slightly more

1717
01:08:08,880 --> 01:08:11,039
formal about this

1718
01:08:11,039 --> 01:08:14,160
these theorems this here

1719
01:08:14,160 --> 01:08:16,719
okay so first of all our assumptions

1720
01:08:16,719 --> 01:08:19,040
so what we assume is that we have all

1721
01:08:19,040 --> 01:08:20,880
parties connected by point-to-point

1722
01:08:20,880 --> 01:08:22,158
channels

1723
01:08:22,158 --> 01:08:23,040
and

1724
01:08:23,040 --> 01:08:25,359
this is given by some idealized resource

1725
01:08:25,359 --> 01:08:28,158
which we call message transfer this has

1726
01:08:28,158 --> 01:08:30,080
a parameter sigma and it has a parameter

1727
01:08:30,080 --> 01:08:32,080
delta

1728
01:08:32,080 --> 01:08:33,920
so um the guarantee that these

1729
01:08:33,920 --> 01:08:35,759
point-to-point channels provide is that

1730
01:08:35,759 --> 01:08:39,759
messages input time t they must be

1731
01:08:39,759 --> 01:08:42,238
delivered to the recipient before time t

1732
01:08:42,238 --> 01:08:45,279
plus delta if the sender stays honest

1733
01:08:45,279 --> 01:08:47,759
until sometime t plus sigma

1734
01:08:47,759 --> 01:08:50,238
okay we plot this on the timeline what

1735
01:08:50,238 --> 01:08:52,560
happens is well if some party sends a

1736
01:08:52,560 --> 01:08:54,080
message through the channel the message

1737
01:08:54,080 --> 01:08:57,198
is immediately linked to the adversary

1738
01:08:57,198 --> 01:09:00,000
then there is a small time gap sigma

1739
01:09:00,000 --> 01:09:02,238
where it's possible for the corrupt for

1740
01:09:02,238 --> 01:09:04,319
the adversary to corrupt the party that

1741
01:09:04,319 --> 01:09:06,399
sends the message and thereby retract

1742
01:09:06,399 --> 01:09:08,000
the message and prevent the delivery of

1743
01:09:08,000 --> 01:09:09,679
this message

1744
01:09:09,679 --> 01:09:11,520
but if the episode does not choose to do

1745
01:09:11,520 --> 01:09:13,600
so then it's guaranteed that the message

1746
01:09:13,600 --> 01:09:14,560
will be

1747
01:09:14,560 --> 01:09:18,080
delivered at time t plus delta

1748
01:09:18,080 --> 01:09:19,679
so then we assume a delayed adversary

1749
01:09:19,679 --> 01:09:20,719
naturally

1750
01:09:20,719 --> 01:09:22,560
and we assume that the delay of the

1751
01:09:22,560 --> 01:09:24,000
adversary is

1752
01:09:24,000 --> 01:09:26,640
delta plus sigma so it takes multiple

1753
01:09:26,640 --> 01:09:28,479
sigma times whenever he decides to

1754
01:09:28,479 --> 01:09:30,960
corrupt the party until this adversary

1755
01:09:30,960 --> 01:09:34,080
actually gains control of the party

1756
01:09:34,080 --> 01:09:36,799
with this on the timeline uh well then

1757
01:09:36,799 --> 01:09:39,759
it's ensured that it takes more time

1758
01:09:39,759 --> 01:09:41,279
than t plus

1759
01:09:41,279 --> 01:09:43,759
delta plus sigma until the episode gains

1760
01:09:43,759 --> 01:09:46,000
control this corresponds to this time

1761
01:09:46,000 --> 01:09:47,520
that we had before right that the

1762
01:09:47,520 --> 01:09:49,439
adversary can no longer prevent the

1763
01:09:49,439 --> 01:09:51,040
delivery of

1764
01:09:51,040 --> 01:09:52,880
the message to the neighborhood and

1765
01:09:52,880 --> 01:09:54,800
these neighbors also have precisely

1766
01:09:54,800 --> 01:09:56,640
sufficient time to send

1767
01:09:56,640 --> 01:09:58,000
out the message and cannot be prevented

1768
01:09:58,000 --> 01:10:00,640
in doing so

1769
01:10:01,440 --> 01:10:03,199
okay

1770
01:10:03,199 --> 01:10:05,280
now the functionality that we implement

1771
01:10:05,280 --> 01:10:06,960
called plot

1772
01:10:06,960 --> 01:10:08,640
it has a very simple property any

1773
01:10:08,640 --> 01:10:10,480
message input by an honest party at time

1774
01:10:10,480 --> 01:10:12,159
t must be delivered to all other honest

1775
01:10:12,159 --> 01:10:14,719
parties before time t plus delta prime

1776
01:10:14,719 --> 01:10:16,239
again if you put this on the timeline

1777
01:10:16,239 --> 01:10:18,400
the message is immediately leaked and at

1778
01:10:18,400 --> 01:10:20,159
some later points it's guaranteed that

1779
01:10:20,159 --> 01:10:22,080
the message is delivered

1780
01:10:22,080 --> 01:10:23,760
and here in particular it's worth noting

1781
01:10:23,760 --> 01:10:26,159
that it's no longer this time for

1782
01:10:26,159 --> 01:10:27,520
corruption

1783
01:10:27,520 --> 01:10:29,360
uh to actually corrupt a party and

1784
01:10:29,360 --> 01:10:31,360
prevent the delivery of the message now

1785
01:10:31,360 --> 01:10:33,280
sending is effectively an atomic

1786
01:10:33,280 --> 01:10:34,960
operation

1787
01:10:34,960 --> 01:10:36,400
but it's also worth noting that we

1788
01:10:36,400 --> 01:10:39,520
require it to be an honest party this

1789
01:10:39,520 --> 01:10:41,920
honest is defined as the adversary has

1790
01:10:41,920 --> 01:10:42,840
not even

1791
01:10:42,840 --> 01:10:44,880
pre-corrupted this party that is the

1792
01:10:44,880 --> 01:10:47,360
center of the message

1793
01:10:47,360 --> 01:10:49,520
okay so if we state our main theorem a

1794
01:10:49,520 --> 01:10:50,880
bit more detail

1795
01:10:50,880 --> 01:10:54,159
the protocol er flot with this parameter

1796
01:10:54,159 --> 01:10:56,000
row which describes the probability that

1797
01:10:56,000 --> 01:10:58,480
the coin should come out ahead realize

1798
01:10:58,480 --> 01:11:00,800
the functionality plot

1799
01:11:00,800 --> 01:11:03,760
if we assume channels and the adversary

1800
01:11:03,760 --> 01:11:05,440
that is delayed for sigma plus delta

1801
01:11:05,440 --> 01:11:06,480
time

1802
01:11:06,480 --> 01:11:08,480
and that is either if we instantiate

1803
01:11:08,480 --> 01:11:10,640
this row to be the square root of a

1804
01:11:10,640 --> 01:11:13,120
security parameter over the number of

1805
01:11:13,120 --> 01:11:14,800
parties that are guaranteed to behave

1806
01:11:14,800 --> 01:11:16,080
honest

1807
01:11:16,080 --> 01:11:18,239
this will provide us with a diameter

1808
01:11:18,239 --> 01:11:20,400
that is just two times

1809
01:11:20,400 --> 01:11:22,239
sorry a delirial guarantee that is just

1810
01:11:22,239 --> 01:11:24,239
two times the delirial guarantee of the

1811
01:11:24,239 --> 01:11:27,120
underlying point to point channels

1812
01:11:27,120 --> 01:11:29,120
and it's worth noting that that here in

1813
01:11:29,120 --> 01:11:32,960
this theorem is proven uh for all

1814
01:11:32,960 --> 01:11:34,800
number of honest parties that are

1815
01:11:34,800 --> 01:11:37,920
guaranteed to be honest

1816
01:11:38,480 --> 01:11:40,239
and our second configuration is that we

1817
01:11:40,239 --> 01:11:42,400
just instantiate row to be the security

1818
01:11:42,400 --> 01:11:44,400
parameter for the number of parties that

1819
01:11:44,400 --> 01:11:46,880
are guaranteed to be honest

1820
01:11:46,880 --> 01:11:49,040
and then we achieve this new delirious

1821
01:11:49,040 --> 01:11:53,120
guarantee as which is a

1822
01:11:53,120 --> 01:11:55,280
just a logarithmic factor

1823
01:11:55,280 --> 01:11:57,280
multiplied by the

1824
01:11:57,280 --> 01:12:00,880
the delay on the underlying channels

1825
01:12:01,040 --> 01:12:03,520
okay so in conclusion this work provides

1826
01:12:03,520 --> 01:12:05,360
a formal model for density adversaries

1827
01:12:05,360 --> 01:12:07,120
we provide two instantiations one with a

1828
01:12:07,120 --> 01:12:08,000
constant neighborhood and the

1829
01:12:08,000 --> 01:12:10,239
logarithmic time zone and one with a

1830
01:12:10,239 --> 01:12:11,840
square with neighborhood and a constant

1831
01:12:11,840 --> 01:12:13,360
diameter

1832
01:12:13,360 --> 01:12:16,080
so details can be found on eprint and

1833
01:12:16,080 --> 01:12:17,600
i'm happy to take questions thank you

1834
01:12:17,600 --> 01:12:20,840
for your attention

1835
01:12:26,159 --> 01:12:27,679
all right so we do have time for

1836
01:12:27,679 --> 01:12:30,239
questions

1837
01:12:32,719 --> 01:12:35,719
um

1838
01:12:42,800 --> 01:12:44,640
uh yes i think i can repeat the question

1839
01:12:44,640 --> 01:12:45,440
sorry

1840
01:12:45,440 --> 01:12:47,199
yes so the question is

1841
01:12:47,199 --> 01:12:50,000
uh can the adversary corrupt some a

1842
01:12:50,000 --> 01:12:52,159
pre-corrupt some of the parties even

1843
01:12:52,159 --> 01:12:53,520
before

1844
01:12:53,520 --> 01:12:56,080
the start of the broadcast

1845
01:12:56,080 --> 01:12:57,520
and yes the answer to this question is

1846
01:12:57,520 --> 01:12:58,320
yes

1847
01:12:58,320 --> 01:13:00,080
this is exactly what this initialize

1848
01:13:00,080 --> 01:13:01,040
command

1849
01:13:01,040 --> 01:13:03,760
does that gives the access

1850
01:13:03,760 --> 01:13:06,560
the right to

1851
01:13:06,560 --> 01:13:08,400
to pre-corrupt a certain number of

1852
01:13:08,400 --> 01:13:10,239
parties before the protocol actually

1853
01:13:10,239 --> 01:13:11,920
starts and that's pre-corrupt with the

1854
01:13:11,920 --> 01:13:12,880
time

1855
01:13:12,880 --> 01:13:16,080
decided by the adversary

1856
01:13:17,199 --> 01:13:20,400
we have time for um one more question um

1857
01:13:20,400 --> 01:13:22,639
one

1858
01:13:24,080 --> 01:13:25,199
uh

1859
01:13:25,199 --> 01:13:27,040
no that's okay please the question will

1860
01:13:27,040 --> 01:13:30,840
be repeated please go ahead

1861
01:13:40,080 --> 01:13:43,080
um

1862
01:13:49,679 --> 01:13:51,920
uh so i didn't quite get it

1863
01:13:51,920 --> 01:13:54,960
please repeat the question

1864
01:13:54,960 --> 01:13:58,199
one yeah

1865
01:14:01,760 --> 01:14:04,000
so you mentioned the uh in the neural

1866
01:14:04,000 --> 01:14:06,080
atomic in the non-atomic model right the

1867
01:14:06,080 --> 01:14:07,840
adversary the centers and something the

1868
01:14:07,840 --> 01:14:09,920
adversary corrupts and the message gets

1869
01:14:09,920 --> 01:14:12,080
retracted retracted that's one option it

1870
01:14:12,080 --> 01:14:13,520
doesn't have to

1871
01:14:13,520 --> 01:14:16,239
but that message can still go they can

1872
01:14:16,239 --> 01:14:17,840
cover up the sender and send different

1873
01:14:17,840 --> 01:14:19,040
messages

1874
01:14:19,040 --> 01:14:20,480
do you need

1875
01:14:20,480 --> 01:14:23,759
messages to be retracted

1876
01:14:24,640 --> 01:14:26,239
or just put differently the messages are

1877
01:14:26,239 --> 01:14:27,840
being blocked basically so the adversary

1878
01:14:27,840 --> 01:14:29,120
corrupts

1879
01:14:29,120 --> 01:14:31,120
and then he also delays the message so

1880
01:14:31,120 --> 01:14:32,800
blocks also the message delivery that's

1881
01:14:32,800 --> 01:14:34,560
that's what you mean one right so it's

1882
01:14:34,560 --> 01:14:36,159
basically two things the adversary does

1883
01:14:36,159 --> 01:14:38,320
right that's a

1884
01:14:38,320 --> 01:14:40,960
hurt and seekers paper that introduces

1885
01:14:40,960 --> 01:14:42,800
model right the non-atomic

1886
01:14:42,800 --> 01:14:44,800
corruption model

1887
01:14:44,800 --> 01:14:47,199
and they

1888
01:14:48,560 --> 01:14:50,080
illustrate that with a you know

1889
01:14:50,080 --> 01:14:51,920
classical decentralized agreement

1890
01:14:51,920 --> 01:14:54,480
problem or the centers on something

1891
01:14:54,480 --> 01:14:55,840
but then you know the center gets

1892
01:14:55,840 --> 01:14:58,480
corrupted and then sends something else

1893
01:14:58,480 --> 01:15:02,560
even in that case you violate the

1894
01:15:02,560 --> 01:15:04,000
results so

1895
01:15:04,000 --> 01:15:05,760
question do you need to retract the

1896
01:15:05,760 --> 01:15:07,360
message or you

1897
01:15:07,360 --> 01:15:08,800
don't

1898
01:15:08,800 --> 01:15:11,520
okay so so for the original attack

1899
01:15:11,520 --> 01:15:13,760
we just need to block the message

1900
01:15:13,760 --> 01:15:15,679
uh in the non-atomic we'll set message

1901
01:15:15,679 --> 01:15:17,360
right so now we just need to corrupt

1902
01:15:17,360 --> 01:15:20,320
afterwards and and um

1903
01:15:20,320 --> 01:15:22,239
block the message nothing else has to be

1904
01:15:22,239 --> 01:15:24,640
be sent in order to

1905
01:15:24,640 --> 01:15:26,320
to to make this protocol insecure in

1906
01:15:26,320 --> 01:15:27,520
that model

1907
01:15:27,520 --> 01:15:29,600
and and in our model

1908
01:15:29,600 --> 01:15:31,840
that's what what you're asking of course

1909
01:15:31,840 --> 01:15:33,520
well it is possible for the adversary to

1910
01:15:33,520 --> 01:15:35,360
see that a message is being sent you can

1911
01:15:35,360 --> 01:15:38,080
no longer no longer prevent the delivery

1912
01:15:38,080 --> 01:15:40,000
of this message that is being sent to

1913
01:15:40,000 --> 01:15:42,239
our flooding network but of course what

1914
01:15:42,239 --> 01:15:44,800
he can do is to grab the party that has

1915
01:15:44,800 --> 01:15:46,719
sent the message and send a new message

1916
01:15:46,719 --> 01:15:49,760
be on the behalf of this party

1917
01:15:49,760 --> 01:15:52,880
did that answer your question yeah so

1918
01:15:52,880 --> 01:15:56,560
and then yet another follow-up question

1919
01:15:56,560 --> 01:15:59,040
in a paper with aguilas and others we

1920
01:15:59,040 --> 01:16:00,320
have something called resource

1921
01:16:00,320 --> 01:16:02,320
restricted cryptography

1922
01:16:02,320 --> 01:16:05,360
where we have these wrappers your shells

1923
01:16:05,360 --> 01:16:07,440
that can be customized to prevent

1924
01:16:07,440 --> 01:16:09,120
different things did you are you

1925
01:16:09,120 --> 01:16:12,239
familiar with that word

1926
01:16:13,520 --> 01:16:15,600
yeah

1927
01:16:15,600 --> 01:16:20,080
because you have used the machinery to

1928
01:16:20,080 --> 01:16:22,400
uh

1929
01:16:22,560 --> 01:16:24,560
wrapper shell right the same type of

1930
01:16:24,560 --> 01:16:26,400
thing you parameterize it and then

1931
01:16:26,400 --> 01:16:28,719
blocks delays

1932
01:16:28,719 --> 01:16:30,000
um

1933
01:16:30,000 --> 01:16:31,440
i'm not sure i follow i think we should

1934
01:16:31,440 --> 01:16:35,360
uh discuss uh later is your shell

1935
01:16:35,360 --> 01:16:38,159
right that blocks controls access to a

1936
01:16:38,159 --> 01:16:40,080
resource

1937
01:16:40,080 --> 01:16:42,560
so that's uh we had a formal lesson to

1938
01:16:42,560 --> 01:16:45,360
specify those types of things

1939
01:16:45,360 --> 01:16:47,600
okay yeah i'm not entirely sure what

1940
01:16:47,600 --> 01:16:49,440
direction uh

1941
01:16:49,440 --> 01:16:51,440
maybe let's take this conversation uh

1942
01:16:51,440 --> 01:16:53,280
during the next break that's okay sorry

1943
01:16:53,280 --> 01:16:55,360
and uh because we're almost out of time

1944
01:16:55,360 --> 01:16:59,719
so let's thank the speaker again

1945
01:17:02,080 --> 01:17:04,159
you

