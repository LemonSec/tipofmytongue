1
00:00:00,480 --> 00:00:03,120
uh this session uh is about the cooling

2
00:00:03,120 --> 00:00:04,160
theory

3
00:00:04,160 --> 00:00:07,120
and let's welcome the first talk

4
00:00:07,120 --> 00:00:09,679
uh the topic is um on code and learning

5
00:00:09,679 --> 00:00:11,599
with errors over function fields

6
00:00:11,599 --> 00:00:14,719
by maxie bomba

7
00:00:15,040 --> 00:00:18,080
so uh thank you for the introduction

8
00:00:18,080 --> 00:00:18,960
uh

9
00:00:18,960 --> 00:00:21,119
this is the joint work with alan kubril

10
00:00:21,119 --> 00:00:23,119
and thomas bruce alazar

11
00:00:23,119 --> 00:00:24,160
and

12
00:00:24,160 --> 00:00:26,640
so in this work uh we focus on certain

13
00:00:26,640 --> 00:00:28,400
decision reductions for structured

14
00:00:28,400 --> 00:00:30,560
violence of the decoding problem

15
00:00:30,560 --> 00:00:32,479
more precisely

16
00:00:32,479 --> 00:00:35,120
what we did is we adapted techniques

17
00:00:35,120 --> 00:00:38,320
from ring lwe and module lwe to the

18
00:00:38,320 --> 00:00:40,640
coding theoretic setting using function

19
00:00:40,640 --> 00:00:43,360
fields instead of number fields

20
00:00:43,360 --> 00:00:45,520
this new framework that we call function

21
00:00:45,520 --> 00:00:47,760
field decoding problem enables us to

22
00:00:47,760 --> 00:00:49,920
give the first such decision reductions

23
00:00:49,920 --> 00:00:52,000
for the decoding problem of quasicyclic

24
00:00:52,000 --> 00:00:52,879
codes

25
00:00:52,879 --> 00:00:53,920
and

26
00:00:53,920 --> 00:00:56,879
proves pseudonymous assumptions made

27
00:00:56,879 --> 00:01:00,559
in multi-party computation

28
00:01:00,879 --> 00:01:03,440
but in order to motivate the this work i

29
00:01:03,440 --> 00:01:05,519
will first begin to present the

30
00:01:05,519 --> 00:01:07,680
electronic cryptosystem which dates back

31
00:01:07,680 --> 00:01:09,360
to 2003

32
00:01:09,360 --> 00:01:10,159
and

33
00:01:10,159 --> 00:01:12,560
which is one of the two main paradigms

34
00:01:12,560 --> 00:01:13,439
to

35
00:01:13,439 --> 00:01:15,439
build encryption on codes

36
00:01:15,439 --> 00:01:17,439
and on the ligating problem

37
00:01:17,439 --> 00:01:18,880
and for which certain decision

38
00:01:18,880 --> 00:01:21,520
reductions are um very important to

39
00:01:21,520 --> 00:01:24,399
assess the security

40
00:01:24,640 --> 00:01:28,080
the idea is uh that alice

41
00:01:28,080 --> 00:01:29,040
chooses

42
00:01:29,040 --> 00:01:31,040
a code completely random

43
00:01:31,040 --> 00:01:34,320
for which she knows uh

44
00:01:34,320 --> 00:01:37,920
a short code word in the duo

45
00:01:37,920 --> 00:01:41,280
sk she publishes her random code c and

46
00:01:41,280 --> 00:01:43,840
bob who wants to encrypt one beat

47
00:01:43,840 --> 00:01:47,360
so he will first choose a code word in c

48
00:01:47,360 --> 00:01:49,119
you will choose an error of very small

49
00:01:49,119 --> 00:01:51,439
hamming weight actually the same as

50
00:01:51,439 --> 00:01:54,560
as sk here and if he wants to encrypt

51
00:01:54,560 --> 00:01:55,600
zero

52
00:01:55,600 --> 00:01:58,719
he will send c plus e a noisy codeword

53
00:01:58,719 --> 00:02:00,880
and if he wants to encrypt one he will

54
00:02:00,880 --> 00:02:03,600
send a completely random

55
00:02:03,600 --> 00:02:06,560
vector of length

56
00:02:06,560 --> 00:02:09,199
for decryption uh alice will use the

57
00:02:09,199 --> 00:02:10,878
knowledge of her secret key and she will

58
00:02:10,878 --> 00:02:12,800
take the inner product between uh the

59
00:02:12,800 --> 00:02:14,319
received word and

60
00:02:14,319 --> 00:02:15,760
uh the

61
00:02:15,760 --> 00:02:17,280
secret

62
00:02:17,280 --> 00:02:18,640
and because the secret key is in the

63
00:02:18,640 --> 00:02:21,040
duel uh this

64
00:02:21,040 --> 00:02:21,520
bob when

65
00:02:21,520 --> 00:02:23,200
the equation of zero that is to say when

66
00:02:23,200 --> 00:02:25,920
he sends a c plus e this is nothing else

67
00:02:25,920 --> 00:02:27,599
than the inner product between the

68
00:02:27,599 --> 00:02:30,480
secret key and uh the error and since

69
00:02:30,480 --> 00:02:32,879
both are uh vectors of very small

70
00:02:32,879 --> 00:02:34,800
hamming weights let's just say that lots

71
00:02:34,800 --> 00:02:37,280
of zeros uh this inner product will be

72
00:02:37,280 --> 00:02:39,840
zero with very high probability

73
00:02:39,840 --> 00:02:41,040
on the other hand

74
00:02:41,040 --> 00:02:43,920
uh if bob encrypted one he sent a random

75
00:02:43,920 --> 00:02:46,400
vector uh so that this inner product

76
00:02:46,400 --> 00:02:48,480
will will be a random bit so it will be

77
00:02:48,480 --> 00:02:50,800
zero with probability one half

78
00:02:50,800 --> 00:02:52,480
in other words

79
00:02:52,480 --> 00:02:54,879
the knowledge of the secret key enables

80
00:02:54,879 --> 00:02:57,040
alice to distinguish between a noisy

81
00:02:57,040 --> 00:02:59,840
code word c plus e and a random vector

82
00:02:59,840 --> 00:03:01,680
of length n

83
00:03:01,680 --> 00:03:03,519
this is precisely the

84
00:03:03,519 --> 00:03:06,000
hardness assumption uh to raise the

85
00:03:06,000 --> 00:03:09,200
security of this electronic cryptosystem

86
00:03:09,200 --> 00:03:11,120
and it can be thought as the code based

87
00:03:11,120 --> 00:03:12,800
analogue of the decisional difficult

88
00:03:12,800 --> 00:03:14,560
hypothesis

89
00:03:14,560 --> 00:03:17,360
well let's formalize a little bit

90
00:03:17,360 --> 00:03:19,440
for the decoding problem uh there is the

91
00:03:19,440 --> 00:03:20,800
well-known computational decoding

92
00:03:20,800 --> 00:03:23,040
problem when where you are given a

93
00:03:23,040 --> 00:03:26,319
random code uh represented by a general

94
00:03:26,319 --> 00:03:27,120
to

95
00:03:27,120 --> 00:03:29,120
its basis like

96
00:03:29,120 --> 00:03:31,440
here as a general matrix

97
00:03:31,440 --> 00:03:32,560
and

98
00:03:32,560 --> 00:03:34,319
you are given also noisy code words mg

99
00:03:34,319 --> 00:03:36,480
plus e with some constraint on the air

100
00:03:36,480 --> 00:03:39,200
and you want to recover the message m

101
00:03:39,200 --> 00:03:41,360
but we can also define this a decisional

102
00:03:41,360 --> 00:03:42,239
version

103
00:03:42,239 --> 00:03:45,120
where you are given a random code g

104
00:03:45,120 --> 00:03:46,959
and a vector b which is either

105
00:03:46,959 --> 00:03:50,080
completely random or a noisy quadrant of

106
00:03:50,080 --> 00:03:52,799
the form mg plus e and the goal is to

107
00:03:52,799 --> 00:03:54,959
distinguish between these two cases so

108
00:03:54,959 --> 00:03:55,840
okay

109
00:03:55,840 --> 00:03:59,280
so the second problem might seem to be

110
00:03:59,280 --> 00:04:01,840
slightly easier than the first one

111
00:04:01,840 --> 00:04:04,879
but in fact there is a like a result

112
00:04:04,879 --> 00:04:07,920
from fischer and stern uh in 1996

113
00:04:07,920 --> 00:04:09,360
that proved that basically these two

114
00:04:09,360 --> 00:04:11,680
problems are equivalent

115
00:04:11,680 --> 00:04:12,720
so

116
00:04:12,720 --> 00:04:14,400
what that means is that the electnova

117
00:04:14,400 --> 00:04:17,040
crypto system truly relies uh well the

118
00:04:17,040 --> 00:04:17,839
the

119
00:04:17,839 --> 00:04:20,798
security relies on uh the hardness of

120
00:04:20,798 --> 00:04:22,400
the computational version of the

121
00:04:22,400 --> 00:04:24,560
decoding problem which is a problem that

122
00:04:24,560 --> 00:04:27,600
is uh well understood and studied for

123
00:04:27,600 --> 00:04:31,600
nearly 60 years more than 60.

124
00:04:31,600 --> 00:04:34,560
so okay so far so good we have a crypto

125
00:04:34,560 --> 00:04:37,040
system which is basically secure post

126
00:04:37,040 --> 00:04:38,160
quantum

127
00:04:38,160 --> 00:04:39,120
but

128
00:04:39,120 --> 00:04:41,520
it's not really efficient indeed the

129
00:04:41,520 --> 00:04:43,840
public key is a random code so it's

130
00:04:43,840 --> 00:04:46,400
represented by a random matrix

131
00:04:46,400 --> 00:04:49,199
uh so it's it's very huge uh

132
00:04:49,199 --> 00:04:50,400
it's called attacking the length of the

133
00:04:50,400 --> 00:04:52,479
ciphertext for instance

134
00:04:52,479 --> 00:04:56,400
and also the encryption is pretty slow

135
00:04:56,400 --> 00:04:57,840
so

136
00:04:57,840 --> 00:04:59,840
in order to cope with that

137
00:04:59,840 --> 00:05:02,400
one idea is to add some structure and to

138
00:05:02,400 --> 00:05:04,800
restrict ourselves to random codes but

139
00:05:04,800 --> 00:05:07,280
in a specific

140
00:05:07,280 --> 00:05:08,960
family of codes

141
00:05:08,960 --> 00:05:11,360
for instance uh we can take posi-cyclic

142
00:05:11,360 --> 00:05:13,440
codes uh that that is related that are

143
00:05:13,440 --> 00:05:17,759
codes that have uh bases uh

144
00:05:17,759 --> 00:05:19,680
of the foundation of multiple succulent

145
00:05:19,680 --> 00:05:22,479
blocks like this

146
00:05:22,800 --> 00:05:25,680
and so now in order to publish this

147
00:05:25,680 --> 00:05:27,680
rendered matrix you can only publish its

148
00:05:27,680 --> 00:05:29,840
first row and can deduce everything by

149
00:05:29,840 --> 00:05:31,039
applying this

150
00:05:31,039 --> 00:05:33,360
quasi-cyclic shift

151
00:05:33,360 --> 00:05:35,919
but what exactly codes have also

152
00:05:35,919 --> 00:05:38,479
that's a very interesting property uh

153
00:05:38,479 --> 00:05:41,360
they come with efficiency encoding

154
00:05:41,360 --> 00:05:43,360
uh by the so-called polynomial

155
00:05:43,360 --> 00:05:46,000
representation

156
00:05:46,160 --> 00:05:48,720
the idea is you can represent a vector

157
00:05:48,720 --> 00:05:51,440
of length n as a polynomial of degree

158
00:05:51,440 --> 00:05:54,240
at most n minus one and uh you can also

159
00:05:54,240 --> 00:05:57,759
represent a circular matrix like that by

160
00:05:57,759 --> 00:06:00,080
the polynomial that represents its first

161
00:06:00,080 --> 00:06:01,520
row

162
00:06:01,520 --> 00:06:04,720
and using this formalism uh now the the

163
00:06:04,720 --> 00:06:07,199
matrix vector products uh is nothing

164
00:06:07,199 --> 00:06:09,440
else than the products of polynomials in

165
00:06:09,440 --> 00:06:11,600
the question ring f q of x constrainted

166
00:06:11,600 --> 00:06:14,160
by x to the n minus one

167
00:06:14,160 --> 00:06:17,120
so using this formalism uh if i give you

168
00:06:17,120 --> 00:06:21,199
a general matrix by a multiple succulent

169
00:06:21,199 --> 00:06:23,440
block like this for instance with

170
00:06:23,440 --> 00:06:24,639
the two blocks

171
00:06:24,639 --> 00:06:26,160
and

172
00:06:26,160 --> 00:06:29,039
a vector mshm and now a noisy energy

173
00:06:29,039 --> 00:06:31,680
code of this form will be

174
00:06:31,680 --> 00:06:32,720
the

175
00:06:32,720 --> 00:06:35,759
will be represented by a bunch of noisy

176
00:06:35,759 --> 00:06:38,319
productive polynomials in this question

177
00:06:38,319 --> 00:06:39,600
frame

178
00:06:39,600 --> 00:06:40,720
so

179
00:06:40,720 --> 00:06:44,000
we can translate the decoding problems

180
00:06:44,000 --> 00:06:45,840
uh and we can restrict them to

181
00:06:45,840 --> 00:06:46,720
quasi-cyclic codes and translate

182
00:06:46,720 --> 00:06:48,479
translating using this polynomial

183
00:06:48,479 --> 00:06:50,240
formalism

184
00:06:50,240 --> 00:06:52,319
so now in the search version you are

185
00:06:52,319 --> 00:06:55,120
given a bunch of samples a b where the

186
00:06:55,120 --> 00:06:57,120
collection of the a represents

187
00:06:57,120 --> 00:06:58,319
the random

188
00:06:58,319 --> 00:07:00,240
generator matrix and the collection of

189
00:07:00,240 --> 00:07:03,280
the b are all of the form m a plus e and

190
00:07:03,280 --> 00:07:05,840
presents the noisy code word and the

191
00:07:05,840 --> 00:07:07,599
goal is as usual you want to recover the

192
00:07:07,599 --> 00:07:09,440
message

193
00:07:09,440 --> 00:07:11,360
you can also define a decisionable

194
00:07:11,360 --> 00:07:13,440
version which is a

195
00:07:13,440 --> 00:07:15,039
retranslation of

196
00:07:15,039 --> 00:07:16,639
the previous one we want to distinguish

197
00:07:16,639 --> 00:07:18,800
between two situations

198
00:07:18,800 --> 00:07:21,680
however when you restrict yourself to

199
00:07:21,680 --> 00:07:24,400
such structure codes

200
00:07:24,400 --> 00:07:27,120
there is no reductions between the

201
00:07:27,120 --> 00:07:28,840
decisional version and the circuit

202
00:07:28,840 --> 00:07:31,360
version and uh

203
00:07:31,360 --> 00:07:33,599
however this uh these problems this

204
00:07:33,599 --> 00:07:35,680
structured variance are at the core of

205
00:07:35,680 --> 00:07:37,919
the security of nissa missions such as

206
00:07:37,919 --> 00:07:39,919
the bike or hqc

207
00:07:39,919 --> 00:07:41,759
and this lack of reduction was already

208
00:07:41,759 --> 00:07:44,000
pointed out by nist in the report for

209
00:07:44,000 --> 00:07:46,560
the second round

210
00:07:46,560 --> 00:07:49,440
so uh and this is the the starting point

211
00:07:49,440 --> 00:07:50,400
of

212
00:07:50,400 --> 00:07:52,800
of this work basically

213
00:07:52,800 --> 00:07:56,000
so uh we can wonder well okay how can we

214
00:07:56,000 --> 00:07:58,560
prove such uh such a reduction this is

215
00:07:58,560 --> 00:07:59,680
this is

216
00:07:59,680 --> 00:08:00,639
uh

217
00:08:00,639 --> 00:08:03,680
the idea that we we had is uh okay so

218
00:08:03,680 --> 00:08:05,440
four codes and structure codes we don't

219
00:08:05,440 --> 00:08:07,120
have such reduction

220
00:08:07,120 --> 00:08:10,879
however uh in the case of lexis and

221
00:08:10,879 --> 00:08:13,759
especially for ring lw for instance uh

222
00:08:13,759 --> 00:08:16,400
there exists such decision reductions uh

223
00:08:16,400 --> 00:08:18,560
that use tools from algebraic number

224
00:08:18,560 --> 00:08:19,919
theory such as

225
00:08:19,919 --> 00:08:22,800
ideals in uh number fields and

226
00:08:22,800 --> 00:08:26,800
embeddings and uh and so on uh so we

227
00:08:26,800 --> 00:08:27,919
wanted to do

228
00:08:27,919 --> 00:08:30,240
something quite analog and because we're

229
00:08:30,240 --> 00:08:32,880
using codes which are

230
00:08:32,880 --> 00:08:35,919
like vector spaces in some

231
00:08:35,919 --> 00:08:38,080
positive characteristics

232
00:08:38,080 --> 00:08:38,799
and

233
00:08:38,799 --> 00:08:41,440
we wanted to use instead uh function

234
00:08:41,440 --> 00:08:43,039
fields and

235
00:08:43,039 --> 00:08:46,240
in fact uh what what we can say is that

236
00:08:46,240 --> 00:08:48,480
this uh ring where we can do all the

237
00:08:48,480 --> 00:08:50,800
computations uh this predominant ring

238
00:08:50,800 --> 00:08:53,120
can be actually seen as the portions of

239
00:08:53,120 --> 00:08:55,760
a ring of integers in some function and

240
00:08:55,760 --> 00:08:58,560
i will explain everything later on but

241
00:08:58,560 --> 00:08:59,920
uh

242
00:08:59,920 --> 00:09:02,399
the idea is okay so this uh is very

243
00:09:02,399 --> 00:09:06,240
small it's it doesn't have uh many ideas

244
00:09:06,240 --> 00:09:09,360
but uh okay uh it has a rich arithmetic

245
00:09:09,360 --> 00:09:11,680
structure and uh

246
00:09:11,680 --> 00:09:13,680
to pass from one representation to the

247
00:09:13,680 --> 00:09:16,160
other is just to add a new variable t

248
00:09:16,160 --> 00:09:18,640
and to cancel it uh by quotient

249
00:09:18,640 --> 00:09:19,680
so

250
00:09:19,680 --> 00:09:22,480
we can really see this question as a

251
00:09:22,480 --> 00:09:24,640
question of uh offering of integers in

252
00:09:24,640 --> 00:09:25,920
the function field

253
00:09:25,920 --> 00:09:27,839
and using a number

254
00:09:27,839 --> 00:09:29,680
in deep analogy between number fields

255
00:09:29,680 --> 00:09:32,160
and function fields um

256
00:09:32,160 --> 00:09:33,360
we can

257
00:09:33,360 --> 00:09:35,200
do uh

258
00:09:35,200 --> 00:09:37,040
we can build a reduction this is the

259
00:09:37,040 --> 00:09:39,360
point of it

260
00:09:39,360 --> 00:09:42,720
but first uh before uh presenting our

261
00:09:42,720 --> 00:09:45,839
framework uh i will recall

262
00:09:45,839 --> 00:09:48,320
quickly what's happening for uh

263
00:09:48,320 --> 00:09:52,640
lexis and ring lw in ring lwe which is a

264
00:09:52,640 --> 00:09:55,040
framework introduced by lubaszewski by

265
00:09:55,040 --> 00:09:57,040
catherine regev in

266
00:09:57,040 --> 00:09:59,120
2010

267
00:09:59,120 --> 00:10:00,160
you take

268
00:10:00,160 --> 00:10:02,160
a number field k which is a finite

269
00:10:02,160 --> 00:10:05,440
extension of q

270
00:10:05,440 --> 00:10:06,560
this

271
00:10:06,560 --> 00:10:08,800
this this number field has a ring of

272
00:10:08,800 --> 00:10:11,360
integers which is an extension of the

273
00:10:11,360 --> 00:10:12,880
usual integer set

274
00:10:12,880 --> 00:10:15,839
and you also take a prime element that's

275
00:10:15,839 --> 00:10:16,720
uh

276
00:10:16,720 --> 00:10:18,560
called the prime modulus

277
00:10:18,560 --> 00:10:20,160
which leaves actually in the actual

278
00:10:20,160 --> 00:10:21,760
integers here

279
00:10:21,760 --> 00:10:24,480
uh so in the third version um

280
00:10:24,480 --> 00:10:27,120
you are given a bunch of uh samples of

281
00:10:27,120 --> 00:10:29,040
this form a and b

282
00:10:29,040 --> 00:10:30,640
where b is uh

283
00:10:30,640 --> 00:10:33,519
a times s plus e where s is a common

284
00:10:33,519 --> 00:10:36,560
secret that leaves somewhere and uh e

285
00:10:36,560 --> 00:10:38,000
are

286
00:10:38,000 --> 00:10:41,040
all sampled from a gaussian distribution

287
00:10:41,040 --> 00:10:43,680
and a is taken uniformly at random in

288
00:10:43,680 --> 00:10:46,399
this quotient okay mod q and the goal is

289
00:10:46,399 --> 00:10:48,160
to recover the secrets

290
00:10:48,160 --> 00:10:49,920
and uh as usual you can define the

291
00:10:49,920 --> 00:10:52,720
decisional version

292
00:10:52,720 --> 00:10:54,959
similarly as before

293
00:10:54,959 --> 00:10:55,760
but

294
00:10:55,760 --> 00:10:58,800
in this context and in this

295
00:10:58,800 --> 00:11:01,839
paper by jessica and mageth they uh

296
00:11:01,839 --> 00:11:03,600
introduced a search decision reduction

297
00:11:03,600 --> 00:11:05,200
they had approved that

298
00:11:05,200 --> 00:11:07,680
with some hypothesis on the the number

299
00:11:07,680 --> 00:11:09,600
field they used and some hypothesis on

300
00:11:09,600 --> 00:11:12,640
the on the prime

301
00:11:12,959 --> 00:11:14,160
you can prove that the decisional

302
00:11:14,160 --> 00:11:15,760
version is actually equivalent to the

303
00:11:15,760 --> 00:11:17,040
third version

304
00:11:17,040 --> 00:11:21,519
and uh later on uh in the the uh well in

305
00:11:21,519 --> 00:11:24,160
the the the years that followed uh

306
00:11:24,160 --> 00:11:26,560
this reduction this um

307
00:11:26,560 --> 00:11:28,959
hypothesis has been uh

308
00:11:28,959 --> 00:11:31,360
removed

309
00:11:31,360 --> 00:11:33,040
okay so we have this framework for

310
00:11:33,040 --> 00:11:35,440
number fields uh what about functions

311
00:11:35,440 --> 00:11:37,120
nodes

312
00:11:37,120 --> 00:11:40,000
the ide is as i mentioned earlier there

313
00:11:40,000 --> 00:11:41,279
is a very

314
00:11:41,279 --> 00:11:44,240
old analogy between a number of fields

315
00:11:44,240 --> 00:11:47,200
which are extension finite extension of

316
00:11:47,200 --> 00:11:50,399
the of cure and function fields

317
00:11:50,399 --> 00:11:51,600
which are

318
00:11:51,600 --> 00:11:54,399
okay so finite separable extension of

319
00:11:54,399 --> 00:11:56,399
the field of rational functions with

320
00:11:56,399 --> 00:11:59,839
coefficient in fq and by analogy i mean

321
00:11:59,839 --> 00:12:03,120
that basically many properties and

322
00:12:03,120 --> 00:12:04,959
most of the properties that you can

323
00:12:04,959 --> 00:12:07,680
think about for a number of fields in

324
00:12:07,680 --> 00:12:09,200
characteristic zero

325
00:12:09,200 --> 00:12:11,279
you can find the same properties in

326
00:12:11,279 --> 00:12:13,839
positive characteristic using function

327
00:12:13,839 --> 00:12:17,120
field then the the subject

328
00:12:17,600 --> 00:12:19,120
so

329
00:12:19,120 --> 00:12:20,959
very naturally now that

330
00:12:20,959 --> 00:12:24,160
we have this this analogy

331
00:12:24,160 --> 00:12:27,360
we can define um the our

332
00:12:27,360 --> 00:12:29,600
framework that's uh we call the function

333
00:12:29,600 --> 00:12:32,800
field decoding problem or ffdp

334
00:12:32,800 --> 00:12:34,079
where now

335
00:12:34,079 --> 00:12:36,000
you pick

336
00:12:36,000 --> 00:12:37,440
a function field

337
00:12:37,440 --> 00:12:38,959
just this form

338
00:12:38,959 --> 00:12:41,519
uh you have this ring of integers which

339
00:12:41,519 --> 00:12:42,639
is

340
00:12:42,639 --> 00:12:45,519
an extension of the ring of polynomials

341
00:12:45,519 --> 00:12:48,639
you take a prime modulus which is uh

342
00:12:48,639 --> 00:12:50,639
an irreducible polynomial

343
00:12:50,639 --> 00:12:52,560
in this ground ring

344
00:12:52,560 --> 00:12:54,320
and uh to be

345
00:12:54,320 --> 00:12:56,800
the most general possible uh we also

346
00:12:56,800 --> 00:12:58,959
defined some probability distribution on

347
00:12:58,959 --> 00:13:01,200
the quotient okay mod q

348
00:13:01,200 --> 00:13:03,200
uh which will be the the distribution of

349
00:13:03,200 --> 00:13:04,639
the errors

350
00:13:04,639 --> 00:13:06,639
so now on the third version you are

351
00:13:06,639 --> 00:13:08,880
given a bunch of samples of this form

352
00:13:08,880 --> 00:13:10,639
and you want to recover the message and

353
00:13:10,639 --> 00:13:13,360
the decision version is defined uh

354
00:13:13,360 --> 00:13:15,200
as you

355
00:13:15,200 --> 00:13:16,560
okay so

356
00:13:16,560 --> 00:13:21,279
now we have a very abstract uh problem

357
00:13:21,279 --> 00:13:22,240
uh

358
00:13:22,240 --> 00:13:23,839
what about this

359
00:13:23,839 --> 00:13:26,079
all right before uh like

360
00:13:26,079 --> 00:13:28,000
to be interested in the the decisional

361
00:13:28,000 --> 00:13:29,920
version we can wonder if the search

362
00:13:29,920 --> 00:13:32,160
version is actually hard

363
00:13:32,160 --> 00:13:35,760
and uh what i can say is that

364
00:13:35,760 --> 00:13:38,560
here this problem is parameterized by

365
00:13:38,560 --> 00:13:40,639
the choice of the function field you use

366
00:13:40,639 --> 00:13:43,120
uh the choice of the prime modulus and

367
00:13:43,120 --> 00:13:45,360
the choice of the error distribution

368
00:13:45,360 --> 00:13:46,800
and uh

369
00:13:46,800 --> 00:13:48,639
i mean that's okay if you choose them

370
00:13:48,639 --> 00:13:51,839
carefully so uh what hap what matters is

371
00:13:51,839 --> 00:13:54,079
instantiation if you choose them uh very

372
00:13:54,079 --> 00:13:56,079
carefully for instance you can take this

373
00:13:56,079 --> 00:13:58,399
function field here and uh

374
00:13:58,399 --> 00:14:00,560
the prime model is to be uh here t which

375
00:14:00,560 --> 00:14:02,480
is irreducible obviously

376
00:14:02,480 --> 00:14:04,079
you actually recover

377
00:14:04,079 --> 00:14:06,000
the decoding problem of quasi-cyclic

378
00:14:06,000 --> 00:14:06,959
codes

379
00:14:06,959 --> 00:14:07,920
exactly

380
00:14:07,920 --> 00:14:11,120
so uh with this instantiation

381
00:14:11,120 --> 00:14:12,480
the search version of the function

382
00:14:12,480 --> 00:14:15,440
physically problem is hard because

383
00:14:15,440 --> 00:14:17,120
if because this

384
00:14:17,120 --> 00:14:18,800
was exactly decoding problem is hard and

385
00:14:18,800 --> 00:14:22,800
there are both exactly the same problems

386
00:14:23,360 --> 00:14:24,720
okay uh

387
00:14:24,720 --> 00:14:25,920
so now

388
00:14:25,920 --> 00:14:27,440
we can

389
00:14:27,440 --> 00:14:29,040
basically uh

390
00:14:29,040 --> 00:14:30,800
we are ready to state the main theorem

391
00:14:30,800 --> 00:14:33,279
of uh of the paper

392
00:14:33,279 --> 00:14:34,880
uh if

393
00:14:34,880 --> 00:14:37,279
we have if there is uh

394
00:14:37,279 --> 00:14:39,519
an algebraic hypothesis on the the

395
00:14:39,519 --> 00:14:41,600
function field namely uh we want it to

396
00:14:41,600 --> 00:14:43,920
be galwa and we want its field of

397
00:14:43,920 --> 00:14:46,320
constant to be not too large we won't go

398
00:14:46,320 --> 00:14:47,760
into

399
00:14:47,760 --> 00:14:49,519
detail also

400
00:14:49,519 --> 00:14:50,959
if

401
00:14:50,959 --> 00:14:53,199
the prime modulus

402
00:14:53,199 --> 00:14:55,440
decomposes nicely into this ring of

403
00:14:55,440 --> 00:14:57,199
integers

404
00:14:57,199 --> 00:15:00,480
uh maybe one of the most important if uh

405
00:15:00,480 --> 00:15:02,800
the error distribution is in violence in

406
00:15:02,800 --> 00:15:04,959
the direction of the galva group namely

407
00:15:04,959 --> 00:15:07,519
uh to say that if some element x is

408
00:15:07,519 --> 00:15:10,160
distributed with respect to psi i want

409
00:15:10,160 --> 00:15:14,000
and i take any uh automorphism uh in the

410
00:15:14,000 --> 00:15:16,000
galway group i want sigma of x to be

411
00:15:16,000 --> 00:15:17,760
just to be distributed with respective

412
00:15:17,760 --> 00:15:19,199
high also

413
00:15:19,199 --> 00:15:22,160
then uh we can prove that uh both

414
00:15:22,160 --> 00:15:23,920
decisional and surge version are

415
00:15:23,920 --> 00:15:25,440
equivalent

416
00:15:25,440 --> 00:15:30,480
and actually those three hypotheses are

417
00:15:30,480 --> 00:15:33,440
basically the same as uh what happened

418
00:15:33,440 --> 00:15:35,519
for ring lwe in

419
00:15:35,519 --> 00:15:37,040
in this first paper

420
00:15:37,040 --> 00:15:39,600
and the proof follows

421
00:15:39,600 --> 00:15:41,759
we need to to make some

422
00:15:41,759 --> 00:15:43,680
uh translations some plus in somewhere

423
00:15:43,680 --> 00:15:47,040
but uh basically the the the the proof

424
00:15:47,040 --> 00:15:48,480
uh follows

425
00:15:48,480 --> 00:15:51,040
this paper

426
00:15:51,440 --> 00:15:54,399
okay uh so as i said um

427
00:15:54,399 --> 00:15:56,399
what matters is instantiation so we have

428
00:15:56,399 --> 00:15:59,360
a very generic framework a very abstract

429
00:15:59,360 --> 00:16:02,399
theorem what about instantiations

430
00:16:02,399 --> 00:16:05,360
so uh we need a galway function field uh

431
00:16:05,360 --> 00:16:07,600
we need to understand how

432
00:16:07,600 --> 00:16:08,399
module

433
00:16:08,399 --> 00:16:11,600
prime elements decompose this into

434
00:16:11,600 --> 00:16:14,639
this and we wanted to be able to define

435
00:16:14,639 --> 00:16:16,720
a probability a probability distribution

436
00:16:16,720 --> 00:16:18,399
that is in variance in the direction of

437
00:16:18,399 --> 00:16:19,839
the galway group

438
00:16:19,839 --> 00:16:21,839
so for ring

439
00:16:21,839 --> 00:16:24,160
uh it was proposed initially to use uh

440
00:16:24,160 --> 00:16:25,839
cycloatomic number fields for many

441
00:16:25,839 --> 00:16:28,639
reasons um so okay

442
00:16:28,639 --> 00:16:32,160
uh why don't we do that for uh function

443
00:16:32,160 --> 00:16:33,680
fields also

444
00:16:33,680 --> 00:16:34,480
and

445
00:16:34,480 --> 00:16:38,399
yeah there are many ways to uh define

446
00:16:38,399 --> 00:16:40,639
analog of c photonic fields in the

447
00:16:40,639 --> 00:16:42,959
integration of function fields

448
00:16:42,959 --> 00:16:45,759
uh and there are many basic bad ways and

449
00:16:45,759 --> 00:16:47,759
here i represent

450
00:16:47,759 --> 00:16:49,279
the

451
00:16:49,279 --> 00:16:52,480
the one way that uh gives the the the

452
00:16:52,480 --> 00:16:54,639
best analogy between uh

453
00:16:54,639 --> 00:16:56,880
with sick atomic from a number of fields

454
00:16:56,880 --> 00:16:58,480
and the idea to understand the

455
00:16:58,480 --> 00:17:00,959
constriction is to look at what happened

456
00:17:00,959 --> 00:17:03,360
when we build cycloatomic number fields

457
00:17:03,360 --> 00:17:05,439
synchronomic number fields are

458
00:17:05,439 --> 00:17:08,400
built by adding the roots of unity

459
00:17:08,400 --> 00:17:11,199
to the to queue and very in a very

460
00:17:11,199 --> 00:17:13,520
epidemic way you can say that actually

461
00:17:13,520 --> 00:17:15,919
the roots of unity are the

462
00:17:15,919 --> 00:17:18,480
torsion element of some z module

463
00:17:18,480 --> 00:17:20,240
structure on

464
00:17:20,240 --> 00:17:21,919
the algebraic closure of

465
00:17:21,919 --> 00:17:23,119
q

466
00:17:23,119 --> 00:17:25,439
well we can do the same

467
00:17:25,439 --> 00:17:27,439
by keeping in mind that z is the analog

468
00:17:27,439 --> 00:17:28,240
of

469
00:17:28,240 --> 00:17:30,160
the polynomials you can do the same and

470
00:17:30,160 --> 00:17:33,520
consider a new fqlc module structure on

471
00:17:33,520 --> 00:17:36,799
the algebraic closure of uh

472
00:17:36,799 --> 00:17:39,919
t and we can add the torsion element to

473
00:17:39,919 --> 00:17:42,400
uh to this field

474
00:17:42,400 --> 00:17:45,520
okay to define this this action uh i

475
00:17:45,520 --> 00:17:48,559
will associates to any polynomial in c a

476
00:17:48,559 --> 00:17:52,559
new polynomial uh in bivariate with in

477
00:17:52,559 --> 00:17:54,080
in x now

478
00:17:54,080 --> 00:17:55,280
uh recast

479
00:17:55,280 --> 00:17:57,679
and the division is recursive so

480
00:17:57,679 --> 00:17:58,400
the

481
00:17:58,400 --> 00:18:00,160
bracket of one will be just the

482
00:18:00,160 --> 00:18:01,760
polynomial x

483
00:18:01,760 --> 00:18:04,160
the bracket of c will be defined as x

484
00:18:04,160 --> 00:18:06,320
sub q plus t times x

485
00:18:06,320 --> 00:18:08,240
and i propagate everything by fq

486
00:18:08,240 --> 00:18:10,000
linearity and

487
00:18:10,000 --> 00:18:12,000
i want the bracket of the product to be

488
00:18:12,000 --> 00:18:14,640
the composition of the brackets here

489
00:18:14,640 --> 00:18:18,000
so i give here two examples and uh to

490
00:18:18,000 --> 00:18:20,559
prove that so we can basically compute

491
00:18:20,559 --> 00:18:22,000
such

492
00:18:22,000 --> 00:18:24,640
such kartik's polynomial

493
00:18:24,640 --> 00:18:25,679
and now

494
00:18:25,679 --> 00:18:27,760
the new structure

495
00:18:27,760 --> 00:18:31,600
we can add is is the following i can uh

496
00:18:31,600 --> 00:18:34,000
a polynomial m will acts on the solitary

497
00:18:34,000 --> 00:18:36,480
explorer by just the composition while

498
00:18:36,480 --> 00:18:38,720
the evaluation of the bracket of m on on

499
00:18:38,720 --> 00:18:40,559
this element

500
00:18:40,559 --> 00:18:42,480
and this has a name um

501
00:18:42,480 --> 00:18:44,160
it's called the khalid's module because

502
00:18:44,160 --> 00:18:46,799
it was discovered by uh khalids and uh

503
00:18:46,799 --> 00:18:49,840
student ace in the 1970s

504
00:18:49,840 --> 00:18:52,080
and so now uh

505
00:18:52,080 --> 00:18:54,000
the m torsion elements are fixed in the

506
00:18:54,000 --> 00:18:55,840
polynomial n the m torsion element are

507
00:18:55,840 --> 00:18:58,400
nothing less than the roots of

508
00:18:58,400 --> 00:19:00,000
the the bracket

509
00:19:00,000 --> 00:19:02,640
and adding these m torsion elements will

510
00:19:02,640 --> 00:19:04,640
give uh what i will call now the

511
00:19:04,640 --> 00:19:06,400
secondary function

512
00:19:06,400 --> 00:19:08,640
and they have many uh

513
00:19:08,640 --> 00:19:10,720
like properties but the most important

514
00:19:10,720 --> 00:19:12,880
one is is the following uh it's the

515
00:19:12,880 --> 00:19:14,720
galway extension and the galway group is

516
00:19:14,720 --> 00:19:16,400
easily computed to be

517
00:19:16,400 --> 00:19:19,679
the invertible modular

518
00:19:19,679 --> 00:19:20,640
and

519
00:19:20,640 --> 00:19:23,120
why do i say that there are

520
00:19:23,120 --> 00:19:25,280
very like similar to sql atomic number

521
00:19:25,280 --> 00:19:28,400
fields it's because uh basically many

522
00:19:28,400 --> 00:19:29,760
pro all the properties that you can

523
00:19:29,760 --> 00:19:32,000
think of uh using in the sql atomic

524
00:19:32,000 --> 00:19:34,400
number fields you can have the same by

525
00:19:34,400 --> 00:19:36,480
replacing groups and subgroups by

526
00:19:36,480 --> 00:19:39,200
modules and sub-modules and

527
00:19:39,200 --> 00:19:41,440
for instance here the galway group of

528
00:19:41,440 --> 00:19:43,440
secular atomic number fields was the

529
00:19:43,440 --> 00:19:46,320
invertible module n and now the

530
00:19:46,320 --> 00:19:48,320
galway group of the caliph's extension

531
00:19:48,320 --> 00:19:50,080
or secondary function field is the

532
00:19:50,080 --> 00:19:52,960
invertible modulo m where m is the

533
00:19:52,960 --> 00:19:56,480
defining polynomial of the torsion

534
00:19:56,720 --> 00:19:58,720
okay let's do a

535
00:19:58,720 --> 00:20:00,880
quick simple computation to understand

536
00:20:00,880 --> 00:20:02,799
what's happening

537
00:20:02,799 --> 00:20:05,039
i recall that the bracket of t was x to

538
00:20:05,039 --> 00:20:07,280
the q plus t times x

539
00:20:07,280 --> 00:20:09,200
what about the t torsion the t torsion

540
00:20:09,200 --> 00:20:11,200
is just the roots of this polynomial so

541
00:20:11,200 --> 00:20:14,880
it's zero uh plus all the q minus one

542
00:20:14,880 --> 00:20:16,240
roots of minus

543
00:20:16,240 --> 00:20:18,159
in in in the algebraic chloride make

544
00:20:18,159 --> 00:20:19,200
sense

545
00:20:19,200 --> 00:20:22,400
so i when i add distortion element to uh

546
00:20:22,400 --> 00:20:25,039
to fqft i i have this

547
00:20:25,039 --> 00:20:26,799
function field which is generated by

548
00:20:26,799 --> 00:20:28,960
this polynomial

549
00:20:28,960 --> 00:20:30,960
i can compute the ring of integers which

550
00:20:30,960 --> 00:20:33,600
has this very nice

551
00:20:33,600 --> 00:20:34,559
shape

552
00:20:34,559 --> 00:20:37,280
and i recall that the galway group was

553
00:20:37,280 --> 00:20:39,280
uh the invertible modulo the defining

554
00:20:39,280 --> 00:20:40,880
polynomial of reduction so here it's

555
00:20:40,880 --> 00:20:42,960
just stick and the invertible modulity

556
00:20:42,960 --> 00:20:46,240
are just the non-zero constants

557
00:20:46,240 --> 00:20:48,240
and now i can also uh

558
00:20:48,240 --> 00:20:49,360
look at this

559
00:20:49,360 --> 00:20:52,159
ring of integers and questions it out by

560
00:20:52,159 --> 00:20:54,880
some irreducible modulus t plus one is

561
00:20:54,880 --> 00:20:56,799
obviously irreducible because it's a

562
00:20:56,799 --> 00:20:59,280
degree one and uh this

563
00:20:59,280 --> 00:21:01,440
question is uh

564
00:21:01,440 --> 00:21:04,240
exactly f q of x positioned out by x to

565
00:21:04,240 --> 00:21:07,440
the q minus one minus

566
00:21:07,440 --> 00:21:09,679
right uh

567
00:21:09,679 --> 00:21:11,200
what do i miss here

568
00:21:11,200 --> 00:21:13,600
uh the the only thing that that is left

569
00:21:13,600 --> 00:21:15,200
now is to understand the action of the

570
00:21:15,200 --> 00:21:17,520
gallery

571
00:21:18,240 --> 00:21:19,919
on this question and

572
00:21:19,919 --> 00:21:21,760
as i said the the galway group is the

573
00:21:21,760 --> 00:21:23,600
non-zero constant and actually you can

574
00:21:23,600 --> 00:21:25,600
compute this action on this

575
00:21:25,600 --> 00:21:27,039
on this ring

576
00:21:27,039 --> 00:21:28,240
by

577
00:21:28,240 --> 00:21:30,159
by the following a polynomial in this

578
00:21:30,159 --> 00:21:32,000
world okay so a nonzero constant will

579
00:21:32,000 --> 00:21:34,240
act on the polynomial in the quotient by

580
00:21:34,240 --> 00:21:38,000
just uh the multiplication by uh

581
00:21:38,000 --> 00:21:40,240
by theta here so because theta is

582
00:21:40,240 --> 00:21:42,240
nonzero

583
00:21:42,240 --> 00:21:44,960
it means that uh the action of an of the

584
00:21:44,960 --> 00:21:46,400
non-zero element of the action of the

585
00:21:46,400 --> 00:21:48,799
gallon group here uh will leave in

586
00:21:48,799 --> 00:21:51,200
variance just the hamming support of the

587
00:21:51,200 --> 00:21:53,280
polynomial d

588
00:21:53,280 --> 00:21:56,240
which means that uh any this

589
00:21:56,240 --> 00:21:57,360
error

590
00:21:57,360 --> 00:21:59,600
that any error distribution that depends

591
00:21:59,600 --> 00:22:02,320
only on this on the hamming support

592
00:22:02,320 --> 00:22:04,880
um will be environment under the action

593
00:22:04,880 --> 00:22:07,840
of the gallery so for instance uh the

594
00:22:07,840 --> 00:22:09,120
bernoulli distribution will be

595
00:22:09,120 --> 00:22:10,240
environment under the action of the

596
00:22:10,240 --> 00:22:11,840
caliber group or the uniform

597
00:22:11,840 --> 00:22:14,159
distribution on all word words of

598
00:22:14,159 --> 00:22:15,919
specific weight will be also inclined in

599
00:22:15,919 --> 00:22:18,320
the direction of the galva group

600
00:22:18,320 --> 00:22:19,120
so

601
00:22:19,120 --> 00:22:20,400
all in all

602
00:22:20,400 --> 00:22:23,039
if we plug everything together

603
00:22:23,039 --> 00:22:24,559
what do we have is that

604
00:22:24,559 --> 00:22:27,039
the actually the decision version of the

605
00:22:27,039 --> 00:22:29,760
the decoding problem for codes uh based

606
00:22:29,760 --> 00:22:34,240
on this ring is uh equivalent to uh the

607
00:22:34,240 --> 00:22:35,840
the actual computational version of the

608
00:22:35,840 --> 00:22:38,559
decoding problem

609
00:22:38,720 --> 00:22:41,280
and actually this uh this precise

610
00:22:41,280 --> 00:22:44,080
assumption uh has already been

611
00:22:44,080 --> 00:22:47,280
used uh to design the random correlation

612
00:22:47,280 --> 00:22:50,320
uh in uh security party computation so

613
00:22:50,320 --> 00:22:53,440
they use the hardness of this decisional

614
00:22:53,440 --> 00:22:55,679
version to build their

615
00:22:55,679 --> 00:22:56,880
scheme

616
00:22:56,880 --> 00:22:58,880
and now with this work you can prove

617
00:22:58,880 --> 00:22:59,840
that

618
00:22:59,840 --> 00:23:01,520
well if you have confidence in the

619
00:23:01,520 --> 00:23:03,200
decoding problem of quality cyclic codes

620
00:23:03,200 --> 00:23:04,080
then

621
00:23:04,080 --> 00:23:07,440
well the decision version is hot

622
00:23:07,440 --> 00:23:10,400
okay it can also generalize to uh other

623
00:23:10,400 --> 00:23:11,520
uh

624
00:23:11,520 --> 00:23:14,240
group codes i won't go into detail and

625
00:23:14,240 --> 00:23:18,880
can also apply to several variants of uh

626
00:23:18,880 --> 00:23:22,400
ring lpn and there is also a module

627
00:23:22,400 --> 00:23:25,200
version uh which is uh

628
00:23:25,200 --> 00:23:27,840
well basically just a very natural

629
00:23:27,840 --> 00:23:29,760
generalization when we have everything

630
00:23:29,760 --> 00:23:32,000
here

631
00:23:32,159 --> 00:23:34,840
okay so just to

632
00:23:34,840 --> 00:23:36,720
conclude um

633
00:23:36,720 --> 00:23:40,240
so on the left of this table i uh put

634
00:23:40,240 --> 00:23:41,039
the

635
00:23:41,039 --> 00:23:41,919
some

636
00:23:41,919 --> 00:23:43,919
very interesting and important milestone

637
00:23:43,919 --> 00:23:46,799
uh in the rainwv history

638
00:23:46,799 --> 00:23:49,760
the first one 2010 is the like the first

639
00:23:49,760 --> 00:23:52,400
paper by lebeszewski by caterpillar that

640
00:23:52,400 --> 00:23:54,880
introduced this problem and the first

641
00:23:54,880 --> 00:23:56,799
such decision reduction that used

642
00:23:56,799 --> 00:23:59,919
psychoatomic number fields and a special

643
00:23:59,919 --> 00:24:02,840
aromatic arithmetic hypothesis on the

644
00:24:02,840 --> 00:24:06,720
modulus in this work uh we give an

645
00:24:06,720 --> 00:24:07,919
analog

646
00:24:07,919 --> 00:24:09,679
when we take a function field to be

647
00:24:09,679 --> 00:24:11,039
galwa

648
00:24:11,039 --> 00:24:11,919
and

649
00:24:11,919 --> 00:24:15,200
we take also the same specific

650
00:24:15,200 --> 00:24:17,600
arithmetic hypothesis

651
00:24:17,600 --> 00:24:19,600
but since 2010 there has been

652
00:24:19,600 --> 00:24:21,679
improvements and for instance there is a

653
00:24:21,679 --> 00:24:24,000
paper by longroid stilli

654
00:24:24,000 --> 00:24:26,320
when they removed this

655
00:24:26,320 --> 00:24:28,879
modulus

656
00:24:29,760 --> 00:24:32,559
hypothesis here uh and

657
00:24:32,559 --> 00:24:34,400
more recently and this is maybe the most

658
00:24:34,400 --> 00:24:36,880
important work here uh there is a paper

659
00:24:36,880 --> 00:24:39,919
by uh pai kev and uh stefan davidovitz

660
00:24:39,919 --> 00:24:43,360
here in 2017 and by uh steele valen

661
00:24:43,360 --> 00:24:48,400
ruska in 201 in 2018 uh where they uh

662
00:24:48,400 --> 00:24:50,240
give a completely different framework

663
00:24:50,240 --> 00:24:53,840
called oracle with hidden center problem

664
00:24:53,840 --> 00:24:56,159
so you prove a search to decision

665
00:24:56,159 --> 00:24:57,200
reduction

666
00:24:57,200 --> 00:24:58,840
for any number

667
00:24:58,840 --> 00:25:01,120
field okay and

668
00:25:01,120 --> 00:25:03,760
actually if we could uh extend these

669
00:25:03,760 --> 00:25:06,559
results to any function field it would

670
00:25:06,559 --> 00:25:08,880
apply to codes that are used in the

671
00:25:08,880 --> 00:25:11,200
nissa mission such as a bike in hqc

672
00:25:11,200 --> 00:25:13,200
because we could actually use the

673
00:25:13,200 --> 00:25:15,039
function field that i introduced in the

674
00:25:15,039 --> 00:25:17,520
beginning of this talk and we could have

675
00:25:17,520 --> 00:25:19,520
this search decision reduction for for

676
00:25:19,520 --> 00:25:23,120
those cuts but unfortunately now is uh

677
00:25:23,120 --> 00:25:26,159
it doesn't well it's already useful but

678
00:25:26,159 --> 00:25:28,880
there is still work to do

679
00:25:28,880 --> 00:25:31,279
thank you

680
00:25:37,840 --> 00:25:39,840
why are the next speakers prepared for

681
00:25:39,840 --> 00:25:42,480
the talk uh oh okay

682
00:25:42,480 --> 00:25:43,600
good yeah

683
00:25:43,600 --> 00:25:45,440
go ahead just a quick one thanks for the

684
00:25:45,440 --> 00:25:47,360
nice talk uh can you say something about

685
00:25:47,360 --> 00:25:50,159
the sample complexity of your reduction

686
00:25:50,159 --> 00:25:50,580
um

687
00:25:50,580 --> 00:25:53,200
[Music]

688
00:25:53,200 --> 00:25:55,120
okay uh

689
00:25:55,120 --> 00:25:57,760
so we we can uh well in in the paper

690
00:25:57,760 --> 00:26:00,960
we'll give explicit uh formulas about uh

691
00:26:00,960 --> 00:26:03,679
like the the time complexity here

692
00:26:03,679 --> 00:26:04,260
uh

693
00:26:04,260 --> 00:26:06,320
[Music]

694
00:26:06,320 --> 00:26:08,559
uh

695
00:26:08,880 --> 00:26:11,039
well the the thing is that the the

696
00:26:11,039 --> 00:26:14,720
number of samples uh in uh in in our ffd

697
00:26:14,720 --> 00:26:17,200
problem is uh related to the rate of the

698
00:26:17,200 --> 00:26:19,120
code that are that is uh

699
00:26:19,120 --> 00:26:21,520
underlying because uh well the rate of

700
00:26:21,520 --> 00:26:23,120
the code is basically the inverse of the

701
00:26:23,120 --> 00:26:25,120
number of symbols right

702
00:26:25,120 --> 00:26:26,960
uh so um

703
00:26:26,960 --> 00:26:30,080
[Music]

704
00:26:30,080 --> 00:26:32,639
okay uh

705
00:26:34,880 --> 00:26:38,400
i'm not sure it's the answers or

706
00:26:38,400 --> 00:26:41,760
your question and again

707
00:26:41,760 --> 00:26:45,840
okay we can talk about it later sorry

708
00:26:47,919 --> 00:26:49,840
okay

709
00:26:49,840 --> 00:26:51,279
since we are running a little bit late

710
00:26:51,279 --> 00:26:55,279
let's thank the speaker again

711
00:27:01,679 --> 00:27:04,559
the next next talk is syndrome decoding

712
00:27:04,559 --> 00:27:06,720
in the head shorter signatures from zero

713
00:27:06,720 --> 00:27:09,360
knowledge proofs

714
00:27:09,360 --> 00:27:11,678
by

715
00:27:11,919 --> 00:27:14,400
team board fenero

716
00:27:14,400 --> 00:27:16,159
hope my pronunciation

717
00:27:16,159 --> 00:27:19,159
is

718
00:27:51,200 --> 00:27:53,200
thank you for the introduction

719
00:27:53,200 --> 00:27:55,600
i'm sibo fenay and today i'm going to

720
00:27:55,600 --> 00:27:58,320
present you this challenge work in which

721
00:27:58,320 --> 00:28:01,039
we propose a new code by signature built

722
00:28:01,039 --> 00:28:05,000
from a zero knowledge proof

723
00:28:25,120 --> 00:28:26,399
um

724
00:28:26,399 --> 00:28:28,880
so to design our signature we chose to

725
00:28:28,880 --> 00:28:30,960
focus on the syndrome decoding problem

726
00:28:30,960 --> 00:28:33,120
for a random linear code

727
00:28:33,120 --> 00:28:35,679
this problem consists given a matrix h

728
00:28:35,679 --> 00:28:38,960
and a vector y

729
00:28:41,279 --> 00:28:43,120
a vector y

730
00:28:43,120 --> 00:28:45,440
to find x that we have the linear

731
00:28:45,440 --> 00:28:49,120
relation y equal to x h

732
00:28:49,120 --> 00:28:52,960
h h x and so that the amine weight of x

733
00:28:52,960 --> 00:28:56,480
is less than some bound w

734
00:28:56,480 --> 00:28:58,960
this problem you know is known to be np

735
00:28:58,960 --> 00:29:02,240
hard and its cryptalizing disease is

736
00:29:02,240 --> 00:29:04,320
stable for many years especially for the

737
00:29:04,320 --> 00:29:07,279
binary field

738
00:29:08,159 --> 00:29:10,640
our goal is to bring a zero knowledge

739
00:29:10,640 --> 00:29:13,120
proof of knowledge for this problem

740
00:29:13,120 --> 00:29:15,440
more precisely we want to design a

741
00:29:15,440 --> 00:29:18,080
protocol where approver

742
00:29:18,080 --> 00:29:21,120
want to convince a verifier that

743
00:29:21,120 --> 00:29:22,960
she knows the solution of the syndrome

744
00:29:22,960 --> 00:29:25,919
decoding instance without relieving any

745
00:29:25,919 --> 00:29:30,399
information about the secret itself

746
00:29:32,960 --> 00:29:34,399
to build this

747
00:29:34,399 --> 00:29:36,960
zero knowledge proof we will rely on the

748
00:29:36,960 --> 00:29:41,200
mp68 paradigm introduced in 2007 by this

749
00:29:41,200 --> 00:29:44,559
famous article of stock

750
00:29:44,559 --> 00:29:47,039
this paradigm provides a generic method

751
00:29:47,039 --> 00:29:49,200
to build a zero-knowledge proof using

752
00:29:49,200 --> 00:29:50,960
techniques from secure multi-party

753
00:29:50,960 --> 00:29:53,360
computation

754
00:29:53,360 --> 00:29:54,480
this paradigm

755
00:29:54,480 --> 00:29:57,520
works as follow

756
00:29:58,559 --> 00:30:00,720
we have our secret which satisfies us

757
00:30:00,720 --> 00:30:04,320
both relation we will first share

758
00:30:04,320 --> 00:30:09,120
our secret in n parts and shares x1 xn

759
00:30:09,120 --> 00:30:12,000
so that the sum of the shares are equal

760
00:30:12,000 --> 00:30:14,559
to x

761
00:30:16,399 --> 00:30:19,120
then let us assume that we have a mpc

762
00:30:19,120 --> 00:30:22,480
protocol which take as input the

763
00:30:22,480 --> 00:30:25,679
shares of the sharing of x

764
00:30:25,679 --> 00:30:27,679
and he will

765
00:30:27,679 --> 00:30:28,960
and which

766
00:30:28,960 --> 00:30:30,480
and he will check

767
00:30:30,480 --> 00:30:32,559
that the shared vector

768
00:30:32,559 --> 00:30:35,039
is a solution of a syndrome decoding

769
00:30:35,039 --> 00:30:37,039
instance

770
00:30:37,039 --> 00:30:39,440
we will use this mpc protocol in a

771
00:30:39,440 --> 00:30:43,039
blackboard blackbox manner to build our

772
00:30:43,039 --> 00:30:46,559
zero knowledge protocol

773
00:30:48,720 --> 00:30:51,039
the prover the honest prover who knows

774
00:30:51,039 --> 00:30:54,640
the secret will run this mpc protocol in

775
00:30:54,640 --> 00:30:56,880
her head meaning that it will run the

776
00:30:56,880 --> 00:30:59,279
computation of all the party involved in

777
00:30:59,279 --> 00:31:02,080
the npc protocols

778
00:31:02,080 --> 00:31:04,480
then it will commit

779
00:31:04,480 --> 00:31:07,600
the converso the computation the view of

780
00:31:07,600 --> 00:31:11,039
each party independently

781
00:31:11,039 --> 00:31:14,640
then the verifier will ask to reveal or

782
00:31:14,640 --> 00:31:18,080
the view of all the parties except one

783
00:31:18,080 --> 00:31:21,039
and then we it will check that the

784
00:31:21,039 --> 00:31:25,440
reveal views are consistent between them

785
00:31:25,919 --> 00:31:27,440
a malicious proverb

786
00:31:27,440 --> 00:31:29,840
doesn't know an input sharing so that

787
00:31:29,840 --> 00:31:31,840
the mpc protocol

788
00:31:31,840 --> 00:31:35,120
output acceptor

789
00:31:37,120 --> 00:31:39,120
output accept

790
00:31:39,120 --> 00:31:40,720
so he will need to cheat on the

791
00:31:40,720 --> 00:31:42,880
computation of at least

792
00:31:42,880 --> 00:31:45,120
one party

793
00:31:45,120 --> 00:31:47,360
but it means that the cheating will be

794
00:31:47,360 --> 00:31:50,320
revealed exposed as soon as the verifier

795
00:31:50,320 --> 00:31:52,960
will ask to reveal the view of the

796
00:31:52,960 --> 00:31:55,760
cheating party

797
00:31:58,399 --> 00:32:01,679
here i assume that we had a mpc protocol

798
00:32:01,679 --> 00:32:04,480
that check if a sin if a

799
00:32:04,480 --> 00:32:06,960
vector is a syndrome decoding solution

800
00:32:06,960 --> 00:32:09,279
but in practice we need to design to

801
00:32:09,279 --> 00:32:11,600
choose this mpc protocol

802
00:32:11,600 --> 00:32:13,279
and the performances of the zero

803
00:32:13,279 --> 00:32:15,519
knowledge proof

804
00:32:15,519 --> 00:32:19,440
will highly depend on this protocol

805
00:32:19,840 --> 00:32:22,080
from this slide all the red values are

806
00:32:22,080 --> 00:32:23,360
value which

807
00:32:23,360 --> 00:32:25,279
which contain information about the

808
00:32:25,279 --> 00:32:30,399
secret x so we must never be revealed

809
00:32:30,720 --> 00:32:34,240
we want to design a mpc protocol which

810
00:32:34,240 --> 00:32:37,519
exists both relation

811
00:32:37,519 --> 00:32:39,760
the linear relation is easy to check in

812
00:32:39,760 --> 00:32:41,279
mpc

813
00:32:41,279 --> 00:32:43,919
but it's much harder for the

814
00:32:43,919 --> 00:32:46,960
constraint about the hamming weight

815
00:32:46,960 --> 00:32:49,360
for this reason we'll replace the second

816
00:32:49,360 --> 00:32:51,519
constraint by the bionicle

817
00:32:51,519 --> 00:32:53,440
by unequivalent one involving

818
00:32:53,440 --> 00:32:56,440
polynomials

819
00:32:57,360 --> 00:32:59,600
this new constraint consists to prove

820
00:32:59,600 --> 00:33:02,080
the existence of two polynomials so that

821
00:33:02,080 --> 00:33:05,200
we have the following relation sq eagle

822
00:33:05,200 --> 00:33:07,039
equal to pf

823
00:33:07,039 --> 00:33:09,440
where s is defined such

824
00:33:09,440 --> 00:33:12,640
the evaluation of some public in some

825
00:33:12,640 --> 00:33:13,919
public point

826
00:33:13,919 --> 00:33:16,240
corresponds to the vec the coordinate of

827
00:33:16,240 --> 00:33:18,320
the tested vector

828
00:33:18,320 --> 00:33:20,320
and the polynomial f

829
00:33:20,320 --> 00:33:22,720
is the smallest polynomial which has

830
00:33:22,720 --> 00:33:26,320
four roots or those evaluation point

831
00:33:26,320 --> 00:33:28,640
we add the constraint also that the

832
00:33:28,640 --> 00:33:30,000
degree of

833
00:33:30,000 --> 00:33:31,279
the polynomial

834
00:33:31,279 --> 00:33:33,039
q is

835
00:33:33,039 --> 00:33:35,519
w

836
00:33:37,679 --> 00:33:39,679
let's assume that we have

837
00:33:39,679 --> 00:33:40,720
this

838
00:33:40,720 --> 00:33:43,120
that the this relation on polynomials

839
00:33:43,120 --> 00:33:44,960
are that is satisfied

840
00:33:44,960 --> 00:33:46,559
we will we can deduce the following

841
00:33:46,559 --> 00:33:48,880
statement

842
00:33:48,880 --> 00:33:50,320
when we evaluate

843
00:33:50,320 --> 00:33:53,919
the product qs by the public point to

844
00:33:53,919 --> 00:33:55,360
gamma i

845
00:33:55,360 --> 00:33:58,080
will get 0 because it's

846
00:33:58,080 --> 00:34:01,120
gamma i is a root of f

847
00:34:01,120 --> 00:34:04,720
so either the evaluation of q is 0

848
00:34:04,720 --> 00:34:07,519
or the evaluation of s meaning the

849
00:34:07,519 --> 00:34:10,719
coordinates of x is zero

850
00:34:10,719 --> 00:34:14,000
but since the degree of q is w

851
00:34:14,000 --> 00:34:17,199
the first case can occur at most w times

852
00:34:17,199 --> 00:34:19,599
implying that the rest of the time is

853
00:34:19,599 --> 00:34:22,079
the second case which occur

854
00:34:22,079 --> 00:34:24,719
and so we get directly that the arming

855
00:34:24,719 --> 00:34:27,599
weight of x is less than double y

856
00:34:27,599 --> 00:34:30,000
w

857
00:34:32,320 --> 00:34:34,399
in practice such polynomial q can be

858
00:34:34,399 --> 00:34:37,040
easily built from the secret vector we

859
00:34:37,040 --> 00:34:39,760
just need to take a monique polynomial

860
00:34:39,760 --> 00:34:42,079
of the grid w so that the non-zero

861
00:34:42,079 --> 00:34:46,480
position of x are encoding as roots

862
00:34:46,480 --> 00:34:48,879
then we can deduce the polynomial f

863
00:34:48,879 --> 00:34:50,239
using the

864
00:34:50,239 --> 00:34:53,199
the previous formula since the

865
00:34:53,199 --> 00:34:56,960
f divides the product sq

866
00:34:58,720 --> 00:35:01,040
now that we have the exact statement we

867
00:35:01,040 --> 00:35:03,680
want to prove in the mpc

868
00:35:03,680 --> 00:35:06,240
protocol

869
00:35:06,320 --> 00:35:08,640
we will describe the

870
00:35:08,640 --> 00:35:12,480
the protocol we proposed in our work

871
00:35:12,480 --> 00:35:15,599
we assume that our matrix h is in the

872
00:35:15,599 --> 00:35:17,760
standard form meaning that the right

873
00:35:17,760 --> 00:35:20,400
part of the matrix is the identity

874
00:35:20,400 --> 00:35:22,000
matrix

875
00:35:22,000 --> 00:35:25,839
then if we write the secret x i as x a x

876
00:35:25,839 --> 00:35:29,200
b we get directly this linear relation

877
00:35:29,200 --> 00:35:32,560
between xd and xa

878
00:35:32,880 --> 00:35:37,440
the input of our mpc protocol will be xa

879
00:35:37,440 --> 00:35:40,320
and the polynomial q and p

880
00:35:40,320 --> 00:35:41,359
and

881
00:35:41,359 --> 00:35:43,359
the aim of the protocol will be to check

882
00:35:43,359 --> 00:35:46,720
if x a corresponds to the syndromic

883
00:35:46,720 --> 00:35:49,118
solution

884
00:35:51,119 --> 00:35:52,800
the first step of the

885
00:35:52,800 --> 00:35:55,200
of this is the mpcc protocol

886
00:35:55,200 --> 00:35:57,680
is to recompose the secret

887
00:35:57,680 --> 00:35:58,640
x

888
00:35:58,640 --> 00:36:00,000
using x a

889
00:36:00,000 --> 00:36:04,800
using the previous linear relation

890
00:36:05,680 --> 00:36:06,800
then

891
00:36:06,800 --> 00:36:08,000
we can

892
00:36:08,000 --> 00:36:11,040
build the polynomial s by interpolation

893
00:36:11,040 --> 00:36:14,320
so that's the evaluation of the

894
00:36:14,320 --> 00:36:16,880
polynomial are the coordinates of the

895
00:36:16,880 --> 00:36:19,280
tested vector

896
00:36:19,280 --> 00:36:22,240
in practice it we can easily do that in

897
00:36:22,240 --> 00:36:23,280
mpc

898
00:36:23,280 --> 00:36:25,359
since the interpolation formula is

899
00:36:25,359 --> 00:36:29,520
linear into the secret value

900
00:36:32,400 --> 00:36:34,640
finally we need to check

901
00:36:34,640 --> 00:36:37,440
this the wanted relation on the

902
00:36:37,440 --> 00:36:38,880
polynomial

903
00:36:38,880 --> 00:36:42,800
however checking directly this relation

904
00:36:42,800 --> 00:36:45,200
in mpc cannot be easily

905
00:36:45,200 --> 00:36:47,119
done efficiently

906
00:36:47,119 --> 00:36:49,839
so we will proceed as follow

907
00:36:49,839 --> 00:36:52,800
the parties are involved in the npc pro

908
00:36:52,800 --> 00:36:54,960
in the multiparty computation we'll get

909
00:36:54,960 --> 00:36:58,160
a random point r a common random point r

910
00:36:58,160 --> 00:37:00,079
sample from a

911
00:37:00,079 --> 00:37:01,599
field extension

912
00:37:01,599 --> 00:37:05,920
of the field where leave the polynomials

913
00:37:06,000 --> 00:37:10,000
then we will compute the evaluation of s

914
00:37:10,000 --> 00:37:11,520
q and p

915
00:37:11,520 --> 00:37:15,200
on this in this point r

916
00:37:15,280 --> 00:37:17,599
finally we will use the sacrificing

917
00:37:17,599 --> 00:37:20,800
techniques from the bn20 protocols to

918
00:37:20,800 --> 00:37:23,359
check the wanted relation

919
00:37:23,359 --> 00:37:27,200
evaluating to the point r

920
00:37:28,560 --> 00:37:30,160
that is our

921
00:37:30,160 --> 00:37:33,839
the protocol we we use in the in our

922
00:37:33,839 --> 00:37:35,040
work

923
00:37:35,040 --> 00:37:36,800
let's remark that we don't prove the

924
00:37:36,800 --> 00:37:39,520
constraint on the

925
00:37:39,520 --> 00:37:42,240
on the degree of q

926
00:37:42,240 --> 00:37:46,240
because it's explicitly already done

927
00:37:46,240 --> 00:37:47,680
in practice q

928
00:37:47,680 --> 00:37:48,720
is a

929
00:37:48,720 --> 00:37:50,480
harmonic polynomial meaning that the

930
00:37:50,480 --> 00:37:53,119
leading coefficient of q will be one and

931
00:37:53,119 --> 00:37:55,280
so we don't need to share it's not a

932
00:37:55,280 --> 00:37:58,400
secret so it will be revealed and so we

933
00:37:58,400 --> 00:38:04,440
directly get that the degree of q is w

934
00:38:07,760 --> 00:38:09,359
even if

935
00:38:09,359 --> 00:38:11,920
xa doesn't describe a syndrome this

936
00:38:11,920 --> 00:38:14,000
decoding solution

937
00:38:14,000 --> 00:38:15,680
it can

938
00:38:15,680 --> 00:38:19,040
sometimes the npc protocol will come

939
00:38:19,040 --> 00:38:24,079
can we output accept in two cases

940
00:38:24,079 --> 00:38:26,160
even if we don't have the wanted

941
00:38:26,160 --> 00:38:29,280
relation we can have the equality for a

942
00:38:29,280 --> 00:38:31,760
given point on but this case will occur

943
00:38:31,760 --> 00:38:34,160
with only small probability and this

944
00:38:34,160 --> 00:38:36,400
probability is given by the schwarzepal

945
00:38:36,400 --> 00:38:38,720
level

946
00:38:38,720 --> 00:38:40,640
the second case

947
00:38:40,640 --> 00:38:45,200
is then the bn20 protocol fails to check

948
00:38:45,200 --> 00:38:49,040
the relation and this case occurs only

949
00:38:49,040 --> 00:38:51,040
with small probability

950
00:38:51,040 --> 00:38:53,520
which is one over the size of the field

951
00:38:53,520 --> 00:38:58,759
where is sample the point r

952
00:39:00,079 --> 00:39:02,400
to some to summary about the npc

953
00:39:02,400 --> 00:39:03,599
protocol

954
00:39:03,599 --> 00:39:06,560
we we have a protocol that check is the

955
00:39:06,560 --> 00:39:07,760
input

956
00:39:07,760 --> 00:39:09,680
is a syndrome decoding instance if it's

957
00:39:09,680 --> 00:39:12,400
the case it will always output accept

958
00:39:12,400 --> 00:39:15,119
and if it's not it will reject with high

959
00:39:15,119 --> 00:39:17,760
probability and it will accept with

960
00:39:17,760 --> 00:39:19,760
small probability and this probability

961
00:39:19,760 --> 00:39:22,400
can be deduced for us from the last two

962
00:39:22,400 --> 00:39:26,440
cases of the previous slides

963
00:39:28,560 --> 00:39:30,160
now that we have

964
00:39:30,160 --> 00:39:32,640
the mpc protocol we will use

965
00:39:32,640 --> 00:39:35,440
in our work we can directly apply the

966
00:39:35,440 --> 00:39:38,079
mpcdx paradigm

967
00:39:38,079 --> 00:39:40,000
to to get a zero knowledge proof of

968
00:39:40,000 --> 00:39:41,440
knowledge for the syndrome decoding

969
00:39:41,440 --> 00:39:43,040
problem

970
00:39:43,040 --> 00:39:44,960
the first step of the prover will be to

971
00:39:44,960 --> 00:39:47,200
build the polynomial

972
00:39:47,200 --> 00:39:49,680
the polynomials q and p

973
00:39:49,680 --> 00:39:51,280
then it will

974
00:39:51,280 --> 00:39:53,680
commit the inputs of each party

975
00:39:53,680 --> 00:39:56,640
independently

976
00:39:56,640 --> 00:40:00,160
then the verifier will choose the

977
00:40:00,160 --> 00:40:03,040
the evaluation point r

978
00:40:03,040 --> 00:40:04,640
and we'll send

979
00:40:04,640 --> 00:40:07,200
the evaluation point r to the approver

980
00:40:07,200 --> 00:40:08,720
and now the prover can run the

981
00:40:08,720 --> 00:40:10,319
computation

982
00:40:10,319 --> 00:40:12,480
describe as follow it will run the

983
00:40:12,480 --> 00:40:14,960
computation for all the party

984
00:40:14,960 --> 00:40:17,839
it will send back to the verifier all

985
00:40:17,839 --> 00:40:20,079
the communication broadcast by the

986
00:40:20,079 --> 00:40:21,280
parties

987
00:40:21,280 --> 00:40:24,880
in the subroutine bn20

988
00:40:24,880 --> 00:40:27,200
and finally the verifier will ask to

989
00:40:27,200 --> 00:40:29,920
reveal all the view except one

990
00:40:29,920 --> 00:40:31,920
and we'll check if those few are

991
00:40:31,920 --> 00:40:34,560
consistent

992
00:40:36,960 --> 00:40:39,599
the soundness error of this

993
00:40:39,599 --> 00:40:42,400
protocol meaning the cheating

994
00:40:42,400 --> 00:40:44,880
probability of the prover

995
00:40:44,880 --> 00:40:48,160
is given by this formula where p is the

996
00:40:48,160 --> 00:40:50,160
small priority we saw in the previous

997
00:40:50,160 --> 00:40:51,040
slide

998
00:40:51,040 --> 00:40:52,720
and n is the

999
00:40:52,720 --> 00:40:55,440
number of parties involved in the secure

1000
00:40:55,440 --> 00:40:58,640
multi-party computation

1001
00:41:01,040 --> 00:41:02,960
when the

1002
00:41:02,960 --> 00:41:05,760
when relieving the view of all the party

1003
00:41:05,760 --> 00:41:09,200
except one the prover will need to send

1004
00:41:09,200 --> 00:41:12,880
the inputs of n minus one parties

1005
00:41:12,880 --> 00:41:16,800
in practice the input chair are built as

1006
00:41:16,800 --> 00:41:17,680
follow

1007
00:41:17,680 --> 00:41:20,560
for all the party accepts the last one

1008
00:41:20,560 --> 00:41:21,760
the

1009
00:41:21,760 --> 00:41:24,240
share will be generated from a seed

1010
00:41:24,240 --> 00:41:26,800
using episode random generator

1011
00:41:26,800 --> 00:41:28,160
for the last

1012
00:41:28,160 --> 00:41:31,040
last party the share will be computed so

1013
00:41:31,040 --> 00:41:35,560
that we have the wanted equality

1014
00:41:35,920 --> 00:41:38,160
it means that for all the party except

1015
00:41:38,160 --> 00:41:39,680
the last one now

1016
00:41:39,680 --> 00:41:41,920
the proverb just need to send a

1017
00:41:41,920 --> 00:41:44,560
a seed of lambda bits where lambda is a

1018
00:41:44,560 --> 00:41:46,319
security level

1019
00:41:46,319 --> 00:41:49,280
of our scheme and for the last party the

1020
00:41:49,280 --> 00:41:51,280
power need to send the uncompressed

1021
00:41:51,280 --> 00:41:53,680
shares

1022
00:41:55,200 --> 00:41:56,160
then we

1023
00:41:56,160 --> 00:41:57,760
in the proof we need to add some

1024
00:41:57,760 --> 00:42:00,160
additional elements due to the bn20

1025
00:42:00,160 --> 00:42:02,720
subroutine as a communication broadcast

1026
00:42:02,720 --> 00:42:04,240
by the parties

1027
00:42:04,240 --> 00:42:05,359
and

1028
00:42:05,359 --> 00:42:07,040
finally we can apply develop

1029
00:42:07,040 --> 00:42:10,000
optimization to lower to decrease the

1030
00:42:10,000 --> 00:42:12,319
securities the proof size

1031
00:42:12,319 --> 00:42:13,359
like

1032
00:42:13,359 --> 00:42:16,359
c3

1033
00:42:18,000 --> 00:42:18,960
now

1034
00:42:18,960 --> 00:42:22,400
now we have our zero knowledge proto uh

1035
00:42:22,400 --> 00:42:24,720
our zero knowledge proof of knowledge

1036
00:42:24,720 --> 00:42:26,160
we can apply the fiat chamber

1037
00:42:26,160 --> 00:42:27,440
transformer

1038
00:42:27,440 --> 00:42:30,400
to get our signature schema the idea is

1039
00:42:30,400 --> 00:42:32,480
simply to replace

1040
00:42:32,480 --> 00:42:35,040
the verifier challenge by the output of

1041
00:42:35,040 --> 00:42:38,000
a hash function which take as input the

1042
00:42:38,000 --> 00:42:40,000
message we want to sign

1043
00:42:40,000 --> 00:42:41,359
and the

1044
00:42:41,359 --> 00:42:45,839
data previously sent by the approver

1045
00:42:47,440 --> 00:42:50,160
since we transform a five round zero

1046
00:42:50,160 --> 00:42:52,079
knowledge protocol into a signature

1047
00:42:52,079 --> 00:42:53,359
scheme

1048
00:42:53,359 --> 00:42:55,839
we need to take into account the attack

1049
00:42:55,839 --> 00:42:59,640
of chaos and zaverusha

1050
00:43:00,000 --> 00:43:02,000
we need to take this into a consistent

1051
00:43:02,000 --> 00:43:03,040
attack

1052
00:43:03,040 --> 00:43:05,520
in practice we will

1053
00:43:05,520 --> 00:43:08,079
we will use this attack this formula

1054
00:43:08,079 --> 00:43:11,200
to select our parameter sets for

1055
00:43:11,200 --> 00:43:14,240
our signature scheme

1056
00:43:16,160 --> 00:43:18,880
in our war we propose three parameter

1057
00:43:18,880 --> 00:43:21,640
sets for a security of

1058
00:43:21,640 --> 00:43:23,920
128 bits

1059
00:43:23,920 --> 00:43:27,920
the first one rely on the binary field

1060
00:43:27,920 --> 00:43:28,960
then

1061
00:43:28,960 --> 00:43:30,400
the field

1062
00:43:30,400 --> 00:43:32,960
in which the polynomial sleeves must be

1063
00:43:32,960 --> 00:43:35,200
a field extension of this field

1064
00:43:35,200 --> 00:43:38,720
and both must be have enough point to it

1065
00:43:38,720 --> 00:43:41,440
interpolate the polynomial s so in this

1066
00:43:41,440 --> 00:43:42,560
case

1067
00:43:42,560 --> 00:43:44,079
the

1068
00:43:44,079 --> 00:43:47,359
the field must have at least 2 to 11

1069
00:43:47,359 --> 00:43:49,200
elements

1070
00:43:49,200 --> 00:43:51,839
to add more flexibility and to decrease

1071
00:43:51,839 --> 00:43:53,119
this

1072
00:43:53,119 --> 00:43:56,319
size the size of this field we propose

1073
00:43:56,319 --> 00:44:00,160
we proposed another variant

1074
00:44:00,880 --> 00:44:03,520
it's uh corresponds to a synonym steel

1075
00:44:03,520 --> 00:44:05,839
on the binary field but instead of

1076
00:44:05,839 --> 00:44:08,600
proving a humming weight for all the

1077
00:44:08,600 --> 00:44:10,000
[Music]

1078
00:44:10,000 --> 00:44:12,960
the secret x we will split our secret

1079
00:44:12,960 --> 00:44:15,839
into six chunks and we will prove a

1080
00:44:15,839 --> 00:44:18,400
local humming weight

1081
00:44:18,400 --> 00:44:20,560
this local checkings will decrease the

1082
00:44:20,560 --> 00:44:22,160
security of the syndrome decoding

1083
00:44:22,160 --> 00:44:24,960
instance so and we can

1084
00:44:24,960 --> 00:44:26,560
take bigger

1085
00:44:26,560 --> 00:44:28,640
instances for the syndrome decoding to

1086
00:44:28,640 --> 00:44:32,000
mitigate this security loss

1087
00:44:32,000 --> 00:44:34,160
in with this variant

1088
00:44:34,160 --> 00:44:36,720
the size of the field is now two to

1089
00:44:36,720 --> 00:44:39,759
eight elements

1090
00:44:40,720 --> 00:44:44,319
finally we can directly take a variant

1091
00:44:44,319 --> 00:44:46,400
defined on the syndrome decoding

1092
00:44:46,400 --> 00:44:47,440
instance

1093
00:44:47,440 --> 00:44:50,000
over a larger field so that we have

1094
00:44:50,000 --> 00:44:51,200
directly

1095
00:44:51,200 --> 00:44:52,160
that the

1096
00:44:52,160 --> 00:44:54,319
field for the polynomial is

1097
00:44:54,319 --> 00:44:56,240
the same as the field for the synonym

1098
00:44:56,240 --> 00:44:58,959
coding instance

1099
00:45:00,800 --> 00:45:04,800
here are the performances of our schema

1100
00:45:04,800 --> 00:45:07,760
we propose for each variant we propose

1101
00:45:07,760 --> 00:45:09,440
two trade-offs

1102
00:45:09,440 --> 00:45:11,280
the first one

1103
00:45:11,280 --> 00:45:14,160
will lower the communication cost

1104
00:45:14,160 --> 00:45:15,760
when the second one

1105
00:45:15,760 --> 00:45:17,839
will lower

1106
00:45:17,839 --> 00:45:20,480
run the computational cost meaning the

1107
00:45:20,480 --> 00:45:22,960
running time of the prove the signer and

1108
00:45:22,960 --> 00:45:25,760
the wave fire

1109
00:45:26,480 --> 00:45:29,520
let us compare our scheme with all the

1110
00:45:29,520 --> 00:45:32,000
former signature scheme built from zero

1111
00:45:32,000 --> 00:45:35,040
knowledge proofs

1112
00:45:35,359 --> 00:45:37,920
we can observe that our scheme is

1113
00:45:37,920 --> 00:45:40,240
outperformed all the previous one

1114
00:45:40,240 --> 00:45:43,839
regarding the size of the

1115
00:45:43,839 --> 00:45:46,160
signature

1116
00:45:46,160 --> 00:45:47,790
we are the first scheme which

1117
00:45:47,790 --> 00:45:48,960
[Music]

1118
00:45:48,960 --> 00:45:51,760
we can produce signature we are using

1119
00:45:51,760 --> 00:45:53,200
the last variant

1120
00:45:53,200 --> 00:45:55,760
signature size below the symbolic cup of

1121
00:45:55,760 --> 00:45:58,079
10 kilobytes

1122
00:45:58,079 --> 00:45:59,119
now

1123
00:45:59,119 --> 00:46:01,839
let us compare our scheme with all the

1124
00:46:01,839 --> 00:46:05,839
other codebase signature

1125
00:46:06,880 --> 00:46:07,920
we are

1126
00:46:07,920 --> 00:46:10,079
we are far to have the smallest

1127
00:46:10,079 --> 00:46:12,480
signature size

1128
00:46:12,480 --> 00:46:13,760
however is

1129
00:46:13,760 --> 00:46:15,520
some use case we need to take into

1130
00:46:15,520 --> 00:46:16,720
account the

1131
00:46:16,720 --> 00:46:20,240
size of the publicly because public key

1132
00:46:20,240 --> 00:46:22,319
and if we compare all the schemes

1133
00:46:22,319 --> 00:46:24,560
regarding the sum of the size of the

1134
00:46:24,560 --> 00:46:26,960
public key and the signature

1135
00:46:26,960 --> 00:46:29,839
we outperform all the schemes

1136
00:46:29,839 --> 00:46:32,240
we can produce a

1137
00:46:32,240 --> 00:46:35,280
signature for which some music is below

1138
00:46:35,280 --> 00:46:39,079
than 10 kilobytes

1139
00:46:42,000 --> 00:46:42,880
we

1140
00:46:42,880 --> 00:46:45,680
must we can add that all the the scheme

1141
00:46:45,680 --> 00:46:50,400
most of those most of the scheme use a

1142
00:46:50,400 --> 00:46:52,560
less conservative

1143
00:46:52,560 --> 00:46:54,839
assumption or

1144
00:46:54,839 --> 00:47:00,078
less like a structure problem

1145
00:47:03,920 --> 00:47:05,920
to to conclude them

1146
00:47:05,920 --> 00:47:08,079
in this work we proposed a new code by

1147
00:47:08,079 --> 00:47:10,079
signature built from zero knowledge

1148
00:47:10,079 --> 00:47:11,280
proof

1149
00:47:11,280 --> 00:47:13,680
this signature

1150
00:47:13,680 --> 00:47:14,480
is

1151
00:47:14,480 --> 00:47:15,440
is

1152
00:47:15,440 --> 00:47:17,839
conservative schemes synthesis rely on

1153
00:47:17,839 --> 00:47:20,559
the security of the syndrome decoding

1154
00:47:20,559 --> 00:47:24,400
problem without structure

1155
00:47:24,400 --> 00:47:27,760
it remain competitive regarding the sum

1156
00:47:27,760 --> 00:47:29,520
of the size

1157
00:47:29,520 --> 00:47:32,400
of the signature and the public key

1158
00:47:32,400 --> 00:47:34,960
as future work we plan to optimize the

1159
00:47:34,960 --> 00:47:36,559
implementation

1160
00:47:36,559 --> 00:47:39,520
and we search parameter sets which would

1161
00:47:39,520 --> 00:47:42,079
provide better performances

1162
00:47:42,079 --> 00:47:45,280
thank you for your attention

1163
00:47:51,440 --> 00:47:54,079
any question

1164
00:47:57,920 --> 00:47:58,720
yeah

1165
00:47:58,720 --> 00:47:59,599
so

1166
00:47:59,599 --> 00:48:01,839
a i wonder if this benefits at all from

1167
00:48:01,839 --> 00:48:04,720
pre-processing or like not at all

1168
00:48:04,720 --> 00:48:05,760
can you

1169
00:48:05,760 --> 00:48:07,520
yeah so there are like these serialized

1170
00:48:07,520 --> 00:48:09,440
techniques uh based on npc in the head

1171
00:48:09,440 --> 00:48:10,960
that if you have certain computation

1172
00:48:10,960 --> 00:48:12,559
that you can push to a pre-processing

1173
00:48:12,559 --> 00:48:13,440
phase

1174
00:48:13,440 --> 00:48:15,119
that is independent of the inputs then

1175
00:48:15,119 --> 00:48:17,839
you can get benefits

1176
00:48:17,839 --> 00:48:19,119
i wonder if you

1177
00:48:19,119 --> 00:48:21,520
took it together so you asked to compare

1178
00:48:21,520 --> 00:48:24,720
with work with pre-processing phaser

1179
00:48:24,720 --> 00:48:26,800
now if you can optimize your protocol so

1180
00:48:26,800 --> 00:48:29,119
that there is a load that goes to the

1181
00:48:29,119 --> 00:48:31,440
pre-processing phase and that way you

1182
00:48:31,440 --> 00:48:34,640
can get benefits

1183
00:48:34,640 --> 00:48:37,720
in fact this work we succeed to have a

1184
00:48:37,720 --> 00:48:41,200
smaller signature size using this

1185
00:48:41,200 --> 00:48:43,920
by rephrasing the

1186
00:48:43,920 --> 00:48:45,920
statement we want to prove

1187
00:48:45,920 --> 00:48:47,359
and so

1188
00:48:47,359 --> 00:48:48,559
we cannot

1189
00:48:48,559 --> 00:48:50,480
we cannot apply this technique with all

1190
00:48:50,480 --> 00:48:51,280
the

1191
00:48:51,280 --> 00:48:54,480
problems we want we need to

1192
00:48:54,480 --> 00:48:57,200
see if uh this statement we want to

1193
00:48:57,200 --> 00:48:58,160
check

1194
00:48:58,160 --> 00:49:00,720
this is compatible with this technique

1195
00:49:00,720 --> 00:49:05,439
but it's not a generic technique right

1196
00:49:10,480 --> 00:49:12,880
yep please go ahead

1197
00:49:12,880 --> 00:49:15,359
hi uh thanks for your talk so just have

1198
00:49:15,359 --> 00:49:16,800
a quick question about your concrete

1199
00:49:16,800 --> 00:49:18,559
instantiation so

1200
00:49:18,559 --> 00:49:21,839
do you think that gamma is arbitrary or

1201
00:49:21,839 --> 00:49:25,680
or is there ide like strategy

1202
00:49:25,680 --> 00:49:26,720
so you

1203
00:49:26,720 --> 00:49:29,680
you ask if the gamma is the evaluation

1204
00:49:29,680 --> 00:49:33,119
point can be arbitrary yes it's any

1205
00:49:33,119 --> 00:49:35,200
element field element we

1206
00:49:35,200 --> 00:49:38,160
it's just me it just be distinct it's

1207
00:49:38,160 --> 00:49:39,920
really constrained

1208
00:49:39,920 --> 00:49:42,000
okay thanks

1209
00:49:42,000 --> 00:49:43,599
i also have a question

1210
00:49:43,599 --> 00:49:45,520
uh so i saw in the on like on your

1211
00:49:45,520 --> 00:49:47,920
previous slides like uh like you there

1212
00:49:47,920 --> 00:49:49,599
are some kind of variations on the

1213
00:49:49,599 --> 00:49:52,160
public key and the signatures and you

1214
00:49:52,160 --> 00:49:54,559
are mostly optimizing on the signature

1215
00:49:54,559 --> 00:49:57,920
size like i o would it be feasible to

1216
00:49:57,920 --> 00:49:58,880
actually

1217
00:49:58,880 --> 00:50:00,160
shift

1218
00:50:00,160 --> 00:50:02,240
like um like most of the sites to the

1219
00:50:02,240 --> 00:50:04,000
public team and make the signature very

1220
00:50:04,000 --> 00:50:06,640
very very small like look like a rainbow

1221
00:50:06,640 --> 00:50:07,920
like uh

1222
00:50:07,920 --> 00:50:10,000
stuff will probably be public it's all

1223
00:50:10,000 --> 00:50:11,839
like a wavelet like that kind of stuff

1224
00:50:11,839 --> 00:50:13,359
is actually feasible

1225
00:50:13,359 --> 00:50:17,119
um in fact when we work on

1226
00:50:17,119 --> 00:50:19,599
we transform

1227
00:50:19,599 --> 00:50:21,839
a zero knowledge proof into a signature

1228
00:50:21,839 --> 00:50:24,000
all

1229
00:50:24,160 --> 00:50:27,119
all the scheme get us

1230
00:50:27,119 --> 00:50:29,440
a very short public key because it's

1231
00:50:29,440 --> 00:50:30,880
just a seed

1232
00:50:30,880 --> 00:50:32,960
since the problem is unstructured we can

1233
00:50:32,960 --> 00:50:34,880
just take a seed and so we cannot

1234
00:50:34,880 --> 00:50:37,520
transfer the size into the public key

1235
00:50:37,520 --> 00:50:38,720
it's

1236
00:50:38,720 --> 00:50:41,200
due to the technique of front of your

1237
00:50:41,200 --> 00:50:43,119
chamber of transforming zero knowledge

1238
00:50:43,119 --> 00:50:45,200
book into a signature scheme

1239
00:50:45,200 --> 00:50:49,200
so no we cannot transfer the

1240
00:50:49,200 --> 00:50:51,599
size into the public key size

1241
00:50:51,599 --> 00:50:55,040
uh i see i say thanks

1242
00:50:55,040 --> 00:50:56,559
if we don't have any more questions

1243
00:50:56,559 --> 00:51:00,680
let's thank the speaker again

1244
00:51:28,160 --> 00:51:29,599
the next talk

1245
00:51:29,599 --> 00:51:31,680
is beyond the

1246
00:51:31,680 --> 00:51:35,040
say the corner bound that's possible via

1247
00:51:35,040 --> 00:51:37,920
tab code coding by observation and the

1248
00:51:37,920 --> 00:51:40,480
speaker is

1249
00:51:40,480 --> 00:51:44,359
alexis corp

1250
00:51:56,880 --> 00:51:58,880
hello my name is alexis corb and i will

1251
00:51:58,880 --> 00:52:00,000
be presenting

1252
00:52:00,000 --> 00:52:01,839
one moment please

1253
00:52:01,839 --> 00:52:04,880
my apologies tab coding via obfuscation

1254
00:52:04,880 --> 00:52:07,040
this is joint work of yuval shai paul

1255
00:52:07,040 --> 00:52:09,280
luna mitsuhai

1256
00:52:09,280 --> 00:52:10,960
so we begin by defining the wiretap

1257
00:52:10,960 --> 00:52:12,400
channel which was first introduced by

1258
00:52:12,400 --> 00:52:15,440
weiner in 1975 so in this model ellis

1259
00:52:15,440 --> 00:52:18,000
wishes to send a message m to bob by

1260
00:52:18,000 --> 00:52:20,079
sending an encoding of m across bob's

1261
00:52:20,079 --> 00:52:21,760
channel channel b

1262
00:52:21,760 --> 00:52:24,079
however there exists an eavesdropper eve

1263
00:52:24,079 --> 00:52:25,760
who also receives the encoding across

1264
00:52:25,760 --> 00:52:28,160
her eavesdropping channel channel e so

1265
00:52:28,160 --> 00:52:30,160
alice's goal is to send the message m to

1266
00:52:30,160 --> 00:52:33,760
bob without eve also learning it

1267
00:52:33,760 --> 00:52:35,440
so in this model we consider the case

1268
00:52:35,440 --> 00:52:37,520
where bob's channeled and eaves channels

1269
00:52:37,520 --> 00:52:39,119
are both discrete memory as list

1270
00:52:39,119 --> 00:52:40,160
channels

1271
00:52:40,160 --> 00:52:41,839
so by this we mean that we can define a

1272
00:52:41,839 --> 00:52:43,920
channel as a function which maps every

1273
00:52:43,920 --> 00:52:45,839
input symbol to each output symbol with

1274
00:52:45,839 --> 00:52:47,920
some fixed probability p which is

1275
00:52:47,920 --> 00:52:49,440
dependent on the channel

1276
00:52:49,440 --> 00:52:52,160
so individual inputs are mapped

1277
00:52:52,160 --> 00:52:54,319
independently to outputs based on these

1278
00:52:54,319 --> 00:52:55,520
probabilities

1279
00:52:55,520 --> 00:52:57,119
and furthermore we consider the case

1280
00:52:57,119 --> 00:52:59,280
where the input and output alphabets our

1281
00:52:59,280 --> 00:53:03,000
fixed constant size

1282
00:53:21,520 --> 00:53:24,520
foreign

1283
00:53:34,640 --> 00:53:37,640
nice

1284
00:53:52,480 --> 00:53:56,440
let me just export media

1285
00:54:15,680 --> 00:54:18,680
huh

1286
00:54:35,440 --> 00:54:38,480
okay so oh yeah so in this model we also

1287
00:54:38,480 --> 00:54:40,240
consider the non-interactive setting

1288
00:54:40,240 --> 00:54:41,680
which means that bob cannot send

1289
00:54:41,680 --> 00:54:43,839
messages back to alice and we also

1290
00:54:43,839 --> 00:54:45,520
assume that alice and bob have no shared

1291
00:54:45,520 --> 00:54:47,920
secrets ahead of time

1292
00:54:47,920 --> 00:54:49,200
okay

1293
00:54:49,200 --> 00:54:51,200
so more formally we can define an

1294
00:54:51,200 --> 00:54:52,880
encoding and decoding scheme to be a

1295
00:54:52,880 --> 00:54:54,880
secure wiretap coding scheme for a

1296
00:54:54,880 --> 00:54:56,720
wiretap channel defined by bob's channel

1297
00:54:56,720 --> 00:54:58,799
on each channel if it satisfies two

1298
00:54:58,799 --> 00:55:00,960
properties so our correctness says that

1299
00:55:00,960 --> 00:55:02,799
if you have a single bit message and you

1300
00:55:02,799 --> 00:55:04,480
encode it and then send it across bob's

1301
00:55:04,480 --> 00:55:06,400
channel then the decoding algorithm

1302
00:55:06,400 --> 00:55:08,240
should output the message with high

1303
00:55:08,240 --> 00:55:09,599
probability

1304
00:55:09,599 --> 00:55:12,160
and security says that eve cannot guess

1305
00:55:12,160 --> 00:55:14,079
the message so if you have a random

1306
00:55:14,079 --> 00:55:15,920
single bit message you encode it and you

1307
00:55:15,920 --> 00:55:17,839
send it across eve's channel then the

1308
00:55:17,839 --> 00:55:19,440
probability that the adversary guesses

1309
00:55:19,440 --> 00:55:21,119
the message should be no better than

1310
00:55:21,119 --> 00:55:23,920
one-half plus negligible

1311
00:55:23,920 --> 00:55:25,839
so we can also define this in the

1312
00:55:25,839 --> 00:55:28,240
computational setting so here we require

1313
00:55:28,240 --> 00:55:30,079
that alice bob and eve are all

1314
00:55:30,079 --> 00:55:32,640
computationally efficient so security is

1315
00:55:32,640 --> 00:55:34,880
only against efficient adversaries and

1316
00:55:34,880 --> 00:55:36,400
we require that the encoding and

1317
00:55:36,400 --> 00:55:40,000
decoding schemes are also efficient

1318
00:55:40,000 --> 00:55:41,920
furthermore results do generalize to the

1319
00:55:41,920 --> 00:55:44,319
larger measure spaces so the message

1320
00:55:44,319 --> 00:55:46,000
doesn't have to be a single bit and

1321
00:55:46,000 --> 00:55:48,559
let's let's uh

1322
00:55:48,559 --> 00:55:51,280
talk about rate

1323
00:55:52,000 --> 00:55:54,240
so to sort of characterize this we'll

1324
00:55:54,240 --> 00:55:56,880
just begin with a simple impossibility

1325
00:55:56,880 --> 00:55:59,119
so we note that if eve can perfectly

1326
00:55:59,119 --> 00:56:01,119
stimulate bob's channel then there's no

1327
00:56:01,119 --> 00:56:02,960
hope of having a secure wiretap coding

1328
00:56:02,960 --> 00:56:05,040
scheme and this is because e can

1329
00:56:05,040 --> 00:56:06,480
essentially learn everything that bob

1330
00:56:06,480 --> 00:56:07,520
can learn

1331
00:56:07,520 --> 00:56:09,680
so we can say if channel b if bob's

1332
00:56:09,680 --> 00:56:11,599
channel is a degradation of eve's

1333
00:56:11,599 --> 00:56:13,760
channel if bob's channel can be written

1334
00:56:13,760 --> 00:56:15,520
as the concatenation of eve's channel

1335
00:56:15,520 --> 00:56:17,520
with some other channel channel s

1336
00:56:17,520 --> 00:56:20,160
and so in this case uh eve has bob has

1337
00:56:20,160 --> 00:56:22,240
no advantage over eep so we cannot

1338
00:56:22,240 --> 00:56:23,839
securely send a message to bob without

1339
00:56:23,839 --> 00:56:25,599
eve learning it

1340
00:56:25,599 --> 00:56:27,839
so just as an example of this suppose

1341
00:56:27,839 --> 00:56:30,079
that bob's channel is a binary symmetric

1342
00:56:30,079 --> 00:56:32,400
channel which flips each bit with

1343
00:56:32,400 --> 00:56:35,200
probability p and eve channel is binary

1344
00:56:35,200 --> 00:56:37,359
eraser channel which erases each bit

1345
00:56:37,359 --> 00:56:40,000
with some probability 2p so twice bop's

1346
00:56:40,000 --> 00:56:41,520
flip probability

1347
00:56:41,520 --> 00:56:43,359
in this case eve can simulate bob's

1348
00:56:43,359 --> 00:56:45,839
channel because with roughly 2p erasures

1349
00:56:45,839 --> 00:56:47,760
she can just assign each erasure to a

1350
00:56:47,760 --> 00:56:49,839
random bit roughly half of those will be

1351
00:56:49,839 --> 00:56:51,440
correct so she'll end up with a string

1352
00:56:51,440 --> 00:56:53,839
with about p bit flips and that's

1353
00:56:53,839 --> 00:56:56,000
exactly what bob's channel does

1354
00:56:56,000 --> 00:56:58,720
so this is just a simple example where

1355
00:56:58,720 --> 00:57:00,319
bob's channel is a degradation of each

1356
00:57:00,319 --> 00:57:02,640
channel and in this case wiretap coding

1357
00:57:02,640 --> 00:57:05,040
schemes are impossible

1358
00:57:05,040 --> 00:57:07,200
okay so in light of this result we can

1359
00:57:07,200 --> 00:57:08,720
ask whether it's possible to create a

1360
00:57:08,720 --> 00:57:10,960
secure wiretap coding scheme whenever

1361
00:57:10,960 --> 00:57:12,559
this is not the case

1362
00:57:12,559 --> 00:57:14,640
so can we create a wiretap coding scheme

1363
00:57:14,640 --> 00:57:16,559
whenever channel b is not a degradation

1364
00:57:16,559 --> 00:57:18,079
of channel 8.

1365
00:57:18,079 --> 00:57:19,920
so unfortunately in the information

1366
00:57:19,920 --> 00:57:22,240
theoretic setting the answer is no

1367
00:57:22,240 --> 00:57:24,880
so cesarean corner in 1978 and these are

1368
00:57:24,880 --> 00:57:26,799
the cesarean corner of our title

1369
00:57:26,799 --> 00:57:28,880
uh they show that wiretap coding schemes

1370
00:57:28,880 --> 00:57:31,440
are possible if and only if channel e is

1371
00:57:31,440 --> 00:57:33,839
not less noise than the channel b

1372
00:57:33,839 --> 00:57:35,119
okay so there's a little bit of double

1373
00:57:35,119 --> 00:57:36,799
negative here we say not less noisy

1374
00:57:36,799 --> 00:57:38,960
instead of you know noisier and the

1375
00:57:38,960 --> 00:57:40,319
reason is this is not really a linear

1376
00:57:40,319 --> 00:57:42,319
relationship and in fact two channels

1377
00:57:42,319 --> 00:57:43,839
can both be not less noisy than each

1378
00:57:43,839 --> 00:57:45,440
other and i'll explain this more on the

1379
00:57:45,440 --> 00:57:47,760
next slide

1380
00:57:47,760 --> 00:57:50,079
okay so what does knotless noisy and

1381
00:57:50,079 --> 00:57:52,079
recall this is the case when wiretap

1382
00:57:52,079 --> 00:57:55,040
coding is possible so this kind of looks

1383
00:57:55,040 --> 00:57:57,200
like our diagram from before so we have

1384
00:57:57,200 --> 00:57:58,960
that channel e is not less noise than

1385
00:57:58,960 --> 00:58:00,000
channel b

1386
00:58:00,000 --> 00:58:02,319
if there's some message distribution and

1387
00:58:02,319 --> 00:58:04,079
some single symbol encoding of the

1388
00:58:04,079 --> 00:58:06,559
message distribution such that bob has

1389
00:58:06,559 --> 00:58:08,240
an advantage over eve and learning the

1390
00:58:08,240 --> 00:58:10,720
message m and here by advantage we mean

1391
00:58:10,720 --> 00:58:12,720
that the conditional entropy of the

1392
00:58:12,720 --> 00:58:15,119
message given bob's output y

1393
00:58:15,119 --> 00:58:17,040
is less than the conditional entropy of

1394
00:58:17,040 --> 00:58:19,680
the message given eve's output z

1395
00:58:19,680 --> 00:58:20,720
so

1396
00:58:20,720 --> 00:58:22,559
in this case again the encoding is only

1397
00:58:22,559 --> 00:58:24,799
a single symbol as opposed to alarm

1398
00:58:24,799 --> 00:58:26,880
string and we're defining this advantage

1399
00:58:26,880 --> 00:58:28,880
and conditional entropy

1400
00:58:28,880 --> 00:58:31,599
so one thing to note is that this is a

1401
00:58:31,599 --> 00:58:33,599
bit different from channel capacity so

1402
00:58:33,599 --> 00:58:35,440
channel capacity says you take the best

1403
00:58:35,440 --> 00:58:37,599
input distribution for bob and the best

1404
00:58:37,599 --> 00:58:39,680
input distribution for eve you compare

1405
00:58:39,680 --> 00:58:41,200
the respective rates of information that

1406
00:58:41,200 --> 00:58:43,119
can be sent across both

1407
00:58:43,119 --> 00:58:45,040
in this one we're saying you take a

1408
00:58:45,040 --> 00:58:47,440
common shared distribution x and you see

1409
00:58:47,440 --> 00:58:49,200
if you can create one that favors bob's

1410
00:58:49,200 --> 00:58:51,520
channel over each channel and in general

1411
00:58:51,520 --> 00:58:53,119
this is probably not rate efficient for

1412
00:58:53,119 --> 00:58:54,400
either channel

1413
00:58:54,400 --> 00:58:55,280
um

1414
00:58:55,280 --> 00:58:56,559
and in fact there are some input

1415
00:58:56,559 --> 00:58:58,640
distributions that favor bob's channel

1416
00:58:58,640 --> 00:59:00,079
or maybe there's other ones that favor

1417
00:59:00,079 --> 00:59:02,160
each channel so it can be the case that

1418
00:59:02,160 --> 00:59:03,599
they're both not less noisy than each

1419
00:59:03,599 --> 00:59:04,880
other

1420
00:59:04,880 --> 00:59:06,559
so yeah so all we're asking is there's

1421
00:59:06,559 --> 00:59:08,319
some message scheme some encoding scheme

1422
00:59:08,319 --> 00:59:10,559
that favors bob's channel over eve and

1423
00:59:10,559 --> 00:59:12,000
in fact eve can have higher channel

1424
00:59:12,000 --> 00:59:13,760
capacity than bob and still have this be

1425
00:59:13,760 --> 00:59:15,359
the case

1426
00:59:15,359 --> 00:59:16,400
okay

1427
00:59:16,400 --> 00:59:17,440
so

1428
00:59:17,440 --> 00:59:18,559
um

1429
00:59:18,559 --> 00:59:20,079
just to characterize this a little bit

1430
00:59:20,079 --> 00:59:20,960
more

1431
00:59:20,960 --> 00:59:22,799
the less noisy condition is stronger

1432
00:59:22,799 --> 00:59:24,960
than degraded which means that if bob's

1433
00:59:24,960 --> 00:59:26,559
channel is a degradation of eve's

1434
00:59:26,559 --> 00:59:28,640
channel then eve's channel is less noise

1435
00:59:28,640 --> 00:59:30,400
than above channel and therefore we have

1436
00:59:30,400 --> 00:59:33,200
an information theoretical possibility

1437
00:59:33,200 --> 00:59:35,760
and also on the graph on the right if we

1438
00:59:35,760 --> 00:59:37,920
consider where bob's channels this bsc

1439
00:59:37,920 --> 00:59:40,319
with flip probability p and eve channel

1440
00:59:40,319 --> 00:59:41,839
is a binary ratio channel for ratio

1441
00:59:41,839 --> 00:59:44,000
probability epsilon then this entire

1442
00:59:44,000 --> 00:59:46,720
blue section there is the area where

1443
00:59:46,720 --> 00:59:48,400
it's impossible in the information

1444
00:59:48,400 --> 00:59:49,839
theoretic setting

1445
00:59:49,839 --> 00:59:51,599
and remember if

1446
00:59:51,599 --> 00:59:54,240
the ratio probability is twice the flip

1447
00:59:54,240 --> 00:59:56,480
probability then we have degradation

1448
00:59:56,480 --> 00:59:58,559
which is sort of the x axis and below on

1449
00:59:58,559 --> 01:00:02,000
that graph so as a very specific example

1450
01:00:02,000 --> 01:00:03,760
if bob's channel has a 10 flip

1451
01:00:03,760 --> 01:00:05,760
probability and each channel has a 30

1452
01:00:05,760 --> 01:00:07,599
percent of ratio probability we have

1453
01:00:07,599 --> 01:00:09,680
this information theoretic and possible

1454
01:00:09,680 --> 01:00:11,280
possibility but we do not have

1455
01:00:11,280 --> 01:00:13,359
degradation because the ratio

1456
01:00:13,359 --> 01:00:15,119
probability is more than twice false

1457
01:00:15,119 --> 01:00:17,200
flip probability

1458
01:00:17,200 --> 01:00:18,880
okay so

1459
01:00:18,880 --> 01:00:20,400
uh synesthesis has been very well

1460
01:00:20,400 --> 01:00:21,839
characterized in the information

1461
01:00:21,839 --> 01:00:23,280
theoretic setting

1462
01:00:23,280 --> 01:00:25,280
we can ask whether we can do better

1463
01:00:25,280 --> 01:00:27,359
computationally

1464
01:00:27,359 --> 01:00:29,839
so historically

1465
01:00:29,839 --> 01:00:31,599
yeah so historically in crypto we've

1466
01:00:31,599 --> 01:00:32,960
gotten a lot better results in the

1467
01:00:32,960 --> 01:00:34,799
computational setting compared to the

1468
01:00:34,799 --> 01:00:36,640
information theoretic setting for

1469
01:00:36,640 --> 01:00:39,520
example secure encryption secure npc

1470
01:00:39,520 --> 01:00:41,359
and many many other cases

1471
01:00:41,359 --> 01:00:43,520
and surprisingly even though this was

1472
01:00:43,520 --> 01:00:45,839
introduced by weiner in 1975 which was

1473
01:00:45,839 --> 01:00:47,680
more than 40 years ago

1474
01:00:47,680 --> 01:00:49,040
to our knowledge has only really been

1475
01:00:49,040 --> 01:00:50,559
studied in the information theoretic

1476
01:00:50,559 --> 01:00:52,799
setting in terms of feasibility

1477
01:00:52,799 --> 01:00:54,880
so what we do in this paper is we solve

1478
01:00:54,880 --> 01:00:57,440
this 40 year old open problem and ask

1479
01:00:57,440 --> 01:00:59,440
can we expand the feasibility region of

1480
01:00:59,440 --> 01:01:01,520
these channels in the computational

1481
01:01:01,520 --> 01:01:02,640
setting

1482
01:01:02,640 --> 01:01:05,359
so that is the focus of our paper

1483
01:01:05,359 --> 01:01:06,079
so

1484
01:01:06,079 --> 01:01:07,599
in light of that we'll return back to

1485
01:01:07,599 --> 01:01:09,440
our original question but this time in

1486
01:01:09,440 --> 01:01:11,040
the computational setting

1487
01:01:11,040 --> 01:01:13,520
so we ask can we create a secure wiretap

1488
01:01:13,520 --> 01:01:15,839
coding scheme whenever channel b is not

1489
01:01:15,839 --> 01:01:17,760
a degradation of channel e

1490
01:01:17,760 --> 01:01:19,839
and recall that our simple impossibility

1491
01:01:19,839 --> 01:01:21,839
where eve can simulate bob's channel

1492
01:01:21,839 --> 01:01:23,359
also holds

1493
01:01:23,359 --> 01:01:26,480
in the computational setting

1494
01:01:26,480 --> 01:01:28,799
so in our work we show that yes

1495
01:01:28,799 --> 01:01:30,799
assuming a form of evasive function

1496
01:01:30,799 --> 01:01:33,280
obfuscation then wiretap coding schemes

1497
01:01:33,280 --> 01:01:35,280
are possible if and only if bob's

1498
01:01:35,280 --> 01:01:36,839
channel is not a degradation of each

1499
01:01:36,839 --> 01:01:39,200
channel so in fact this is the best

1500
01:01:39,200 --> 01:01:40,880
possible region we could hope for in the

1501
01:01:40,880 --> 01:01:42,559
computational setting

1502
01:01:42,559 --> 01:01:44,400
and this greatly expands the region from

1503
01:01:44,400 --> 01:01:47,280
the information theoretic setting

1504
01:01:47,280 --> 01:01:49,119
and there's one note actually the only

1505
01:01:49,119 --> 01:01:50,640
computational assumptions we need are

1506
01:01:50,640 --> 01:01:54,000
for this functional obfuscation here

1507
01:01:54,000 --> 01:01:55,200
and in fact

1508
01:01:55,200 --> 01:01:58,839
you can view our scheme

1509
01:02:09,039 --> 01:02:10,640
you can view our scheme in the ideal

1510
01:02:10,640 --> 01:02:12,720
obfuscation model

1511
01:02:12,720 --> 01:02:14,400
in which case our scheme is

1512
01:02:14,400 --> 01:02:16,400
unconditionally secure against unbounded

1513
01:02:16,400 --> 01:02:18,079
adversaries we're only allowed

1514
01:02:18,079 --> 01:02:20,799
polynomially many queries so really our

1515
01:02:20,799 --> 01:02:23,200
computational results are only required

1516
01:02:23,200 --> 01:02:26,598
for this obfuscation

1517
01:02:36,240 --> 01:02:38,079
so let's just go into what sort of

1518
01:02:38,079 --> 01:02:39,920
obfuscation we need

1519
01:02:39,920 --> 01:02:41,760
so we can define a statistically evasive

1520
01:02:41,760 --> 01:02:44,160
circuit

1521
01:02:45,440 --> 01:02:47,200
which is in general a circuit that

1522
01:02:47,200 --> 01:02:49,280
almost always outputs zero

1523
01:02:49,280 --> 01:02:51,039
and for which it's hard to find an input

1524
01:02:51,039 --> 01:02:52,720
on which it outputs one

1525
01:02:52,720 --> 01:02:54,640
so more formally if we have a collection

1526
01:02:54,640 --> 01:02:56,799
of circuits d and we have an auxiliary

1527
01:02:56,799 --> 01:02:59,119
input generator box

1528
01:02:59,119 --> 01:03:00,880
then if you take a random circuit from

1529
01:03:00,880 --> 01:03:02,880
that distribution of circuits and you

1530
01:03:02,880 --> 01:03:04,480
allow the adversary to have oracle

1531
01:03:04,480 --> 01:03:06,400
access to that circuit with polynomially

1532
01:03:06,400 --> 01:03:09,039
many queries along with auxiliary inputs

1533
01:03:09,039 --> 01:03:10,480
then the adversary should not be able to

1534
01:03:10,480 --> 01:03:12,000
find an input on which the circuit

1535
01:03:12,000 --> 01:03:13,200
outputs one

1536
01:03:13,200 --> 01:03:16,160
and these are for unbounded adversaries

1537
01:03:16,160 --> 01:03:17,760
so in our setting

1538
01:03:17,760 --> 01:03:19,359
our class of circuits will be

1539
01:03:19,359 --> 01:03:21,119
generalized fuzzy point functions for

1540
01:03:21,119 --> 01:03:23,520
some random center r and by this we mean

1541
01:03:23,520 --> 01:03:25,680
you pick a random center r and then the

1542
01:03:25,680 --> 01:03:27,839
function will output one if its input is

1543
01:03:27,839 --> 01:03:29,839
close to that center and otherwise it

1544
01:03:29,839 --> 01:03:32,079
will output zero

1545
01:03:32,079 --> 01:03:34,480
and our auxiliary input will be eaves

1546
01:03:34,480 --> 01:03:36,480
channel on the center r

1547
01:03:36,480 --> 01:03:38,640
so in order for this to satisfy this

1548
01:03:38,640 --> 01:03:40,240
definition

1549
01:03:40,240 --> 01:03:41,760
uh we require that even given this

1550
01:03:41,760 --> 01:03:43,680
leakage on the center you still can't

1551
01:03:43,680 --> 01:03:44,799
find something that is close to the

1552
01:03:44,799 --> 01:03:48,319
center for some notion of close

1553
01:03:48,960 --> 01:03:51,200
then for our obfuscation

1554
01:03:51,200 --> 01:03:52,799
we require that

1555
01:03:52,799 --> 01:03:55,680
our obfuscation satisfies two properties

1556
01:03:55,680 --> 01:03:57,760
so correctness says that the obligation

1557
01:03:57,760 --> 01:03:59,680
of the circuit should have the same

1558
01:03:59,680 --> 01:04:01,599
input out behavior as the original

1559
01:04:01,599 --> 01:04:03,520
circuit except with negligible

1560
01:04:03,520 --> 01:04:04,880
probability

1561
01:04:04,880 --> 01:04:06,960
and virtual blackbox security says that

1562
01:04:06,960 --> 01:04:08,559
a simulator should be able to simulate

1563
01:04:08,559 --> 01:04:11,119
the obfuscation given only oracle access

1564
01:04:11,119 --> 01:04:12,480
to the circuit

1565
01:04:12,480 --> 01:04:14,400
so more formally a simulator who's given

1566
01:04:14,400 --> 01:04:16,720
polynomial e-mail queries the circuit

1567
01:04:16,720 --> 01:04:18,880
along with auxiliary input should be

1568
01:04:18,880 --> 01:04:21,119
able to produce an obfuscation that

1569
01:04:21,119 --> 01:04:23,359
pulls a distinguisher

1570
01:04:23,359 --> 01:04:25,039
and in our case because our circuits are

1571
01:04:25,039 --> 01:04:26,960
statistically evasive then actually

1572
01:04:26,960 --> 01:04:28,640
giving the oracle access to the

1573
01:04:28,640 --> 01:04:31,440
simulator does not help very much

1574
01:04:31,440 --> 01:04:32,799
so yeah so what is known about these

1575
01:04:32,799 --> 01:04:33,920
circuits

1576
01:04:33,920 --> 01:04:35,680
there are no known impossibility results

1577
01:04:35,680 --> 01:04:37,359
no because these are statistically

1578
01:04:37,359 --> 01:04:39,680
evasive circuits although there are some

1579
01:04:39,680 --> 01:04:41,280
possibility results for computational

1580
01:04:41,280 --> 01:04:42,559
circuits

1581
01:04:42,559 --> 01:04:44,640
we can also conjecture the io achieves

1582
01:04:44,640 --> 01:04:45,440
this

1583
01:04:45,440 --> 01:04:46,799
because io's the best possible

1584
01:04:46,799 --> 01:04:48,799
obfuscator which means if there exists

1585
01:04:48,799 --> 01:04:50,799
any scheme which achieves this then io

1586
01:04:50,799 --> 01:04:52,240
also does so

1587
01:04:52,240 --> 01:04:53,839
and finally there is a candidate

1588
01:04:53,839 --> 01:04:55,839
construction and a weak multi-linear map

1589
01:04:55,839 --> 01:04:58,559
model that we don't know any tax for

1590
01:04:58,559 --> 01:05:00,319
so assuming this formal obfuscation then

1591
01:05:00,319 --> 01:05:01,920
we have the best possible encoding

1592
01:05:01,920 --> 01:05:04,640
schemes in the computational setting

1593
01:05:04,640 --> 01:05:05,599
okay

1594
01:05:05,599 --> 01:05:08,240
so how do we construct this let us

1595
01:05:08,240 --> 01:05:09,680
return to the example we had before

1596
01:05:09,680 --> 01:05:11,200
which was this little point in the blue

1597
01:05:11,200 --> 01:05:12,160
section

1598
01:05:12,160 --> 01:05:15,200
so recall this is bob's channel is a bsc

1599
01:05:15,200 --> 01:05:17,520
with flip probability 10 percent eve

1600
01:05:17,520 --> 01:05:19,280
channel is a binary ratio channel with a

1601
01:05:19,280 --> 01:05:21,359
ratio probability 30

1602
01:05:21,359 --> 01:05:22,799
and here bob's channel is not a

1603
01:05:22,799 --> 01:05:24,480
degradation of each channel so our

1604
01:05:24,480 --> 01:05:26,559
simple impossibility does not hold

1605
01:05:26,559 --> 01:05:28,319
but uh each channel is less noise than

1606
01:05:28,319 --> 01:05:30,160
the bob's channel so it's information

1607
01:05:30,160 --> 01:05:32,000
theoretically impossible to construct

1608
01:05:32,000 --> 01:05:34,079
such an encoding

1609
01:05:34,079 --> 01:05:36,559
okay so just characterize these channels

1610
01:05:36,559 --> 01:05:38,240
suppose you send a random message r

1611
01:05:38,240 --> 01:05:40,319
across both channels

1612
01:05:40,319 --> 01:05:42,400
then bob should get uh something with 10

1613
01:05:42,400 --> 01:05:44,319
bit flips and they should get something

1614
01:05:44,319 --> 01:05:47,039
with about 30 erasures

1615
01:05:47,039 --> 01:05:49,119
and one thing to note is that because we

1616
01:05:49,119 --> 01:05:50,480
don't have degradation

1617
01:05:50,480 --> 01:05:52,559
it's difficult for eve to try to emulate

1618
01:05:52,559 --> 01:05:54,079
bob's output

1619
01:05:54,079 --> 01:05:56,400
so more specifically if we asked eve to

1620
01:05:56,400 --> 01:05:57,920
try to create something with 10 bit

1621
01:05:57,920 --> 01:06:00,240
flips then eve can't do so because it's

1622
01:06:00,240 --> 01:06:01,760
best strategy is just to assign each

1623
01:06:01,760 --> 01:06:04,160
generation a random bit which gets about

1624
01:06:04,160 --> 01:06:06,160
15 bit flips

1625
01:06:06,160 --> 01:06:08,000
and therefore she can't emulate this 10

1626
01:06:08,000 --> 01:06:09,680
percent flips

1627
01:06:09,680 --> 01:06:11,760
and so actually even though eve has

1628
01:06:11,760 --> 01:06:13,440
higher channel capacity than bob in this

1629
01:06:13,440 --> 01:06:15,520
case and she would know more about r

1630
01:06:15,520 --> 01:06:17,359
with mutual information

1631
01:06:17,359 --> 01:06:18,799
she still gets a different type of

1632
01:06:18,799 --> 01:06:20,640
information and she can't emulate this

1633
01:06:20,640 --> 01:06:22,960
type of information that bob receives

1634
01:06:22,960 --> 01:06:24,319
so this is the key insight that we're

1635
01:06:24,319 --> 01:06:26,480
going to utilize here

1636
01:06:26,480 --> 01:06:27,680
okay so

1637
01:06:27,680 --> 01:06:29,599
in light of this the stair scheme

1638
01:06:29,599 --> 01:06:31,119
recall that alice wishes to send a

1639
01:06:31,119 --> 01:06:32,720
message m to bob

1640
01:06:32,720 --> 01:06:34,480
so first alice will

1641
01:06:34,480 --> 01:06:36,799
choose a uniform random string r and

1642
01:06:36,799 --> 01:06:38,880
send it across both channels

1643
01:06:38,880 --> 01:06:40,880
and then next alice will construct an

1644
01:06:40,880 --> 01:06:42,559
obfuscation this function

1645
01:06:42,559 --> 01:06:44,160
and we can consider her ascending this

1646
01:06:44,160 --> 01:06:46,240
to both alice or bob and eve in the

1647
01:06:46,240 --> 01:06:48,720
clear but really she can use a you know

1648
01:06:48,720 --> 01:06:50,480
encoding scheme for bob's channel and

1649
01:06:50,480 --> 01:06:52,079
send it across bob's channel and we

1650
01:06:52,079 --> 01:06:53,839
don't require security

1651
01:06:53,839 --> 01:06:56,640
um yeah so for this function this

1652
01:06:56,640 --> 01:06:58,079
function is going to have r and m

1653
01:06:58,079 --> 01:07:00,559
hardcoded into it and it will output the

1654
01:07:00,559 --> 01:07:03,280
message if it's input it has about 10

1655
01:07:03,280 --> 01:07:06,079
percent that flips relative to r

1656
01:07:06,079 --> 01:07:07,599
okay so

1657
01:07:07,599 --> 01:07:09,200
why do we have correctness we have

1658
01:07:09,200 --> 01:07:11,280
correctness because bob can simply put

1659
01:07:11,280 --> 01:07:13,760
his input into this obfuscation and

1660
01:07:13,760 --> 01:07:16,160
because it has about 10 bit flips uh the

1661
01:07:16,160 --> 01:07:17,599
function should output them and

1662
01:07:17,599 --> 01:07:19,839
therefore bobbler them

1663
01:07:19,839 --> 01:07:21,359
and then security followed by our

1664
01:07:21,359 --> 01:07:23,839
earlier argument so as we said eve can't

1665
01:07:23,839 --> 01:07:25,920
create inputs for which she has about 10

1666
01:07:25,920 --> 01:07:28,720
percent flip flips to r even given her

1667
01:07:28,720 --> 01:07:30,640
uh leakage re

1668
01:07:30,640 --> 01:07:33,440
and therefore we can argue that

1669
01:07:33,440 --> 01:07:35,680
this function is uh statistically

1670
01:07:35,680 --> 01:07:36,799
invasive

1671
01:07:36,799 --> 01:07:38,480
and therefore our obfuscation will hide

1672
01:07:38,480 --> 01:07:39,920
the value of m because we can replace

1673
01:07:39,920 --> 01:07:41,599
this with a simulator

1674
01:07:41,599 --> 01:07:44,240
so eve learns nothing about m

1675
01:07:44,240 --> 01:07:46,240
and in fact more generally this can work

1676
01:07:46,240 --> 01:07:49,359
for any pair of bsc vec channels in the

1677
01:07:49,359 --> 01:07:51,920
less noisy case

1678
01:07:51,920 --> 01:07:54,000
so this entire blue area we had before

1679
01:07:54,000 --> 01:07:55,839
is now actually possible in the

1680
01:07:55,839 --> 01:07:57,839
computational world assuming this

1681
01:07:57,839 --> 01:08:00,000
obfuscation

1682
01:08:00,000 --> 01:08:02,640
okay but again this is just two channels

1683
01:08:02,640 --> 01:08:04,960
uh bscs and bec's

1684
01:08:04,960 --> 01:08:08,079
what can we do just more generally

1685
01:08:08,079 --> 01:08:08,960
okay

1686
01:08:08,960 --> 01:08:11,039
so more generally uh recall that we

1687
01:08:11,039 --> 01:08:12,400
wanted to create a scheme whenever we

1688
01:08:12,400 --> 01:08:13,599
didn't have the degradation the

1689
01:08:13,599 --> 01:08:15,440
condition so what does that mean when we

1690
01:08:15,440 --> 01:08:17,439
don't have degradation it means that no

1691
01:08:17,439 --> 01:08:19,198
matter what channel s that eve

1692
01:08:19,198 --> 01:08:21,439
candidates to her own channel she can't

1693
01:08:21,439 --> 01:08:23,359
emulate bob's channel which more

1694
01:08:23,359 --> 01:08:24,799
specifically means that there's some

1695
01:08:24,799 --> 01:08:26,640
input symbol x star and some input

1696
01:08:26,640 --> 01:08:29,120
symbol white or output symbol y star

1697
01:08:29,120 --> 01:08:31,198
such that the crossover probability

1698
01:08:31,198 --> 01:08:33,040
between x star and the y star is

1699
01:08:33,040 --> 01:08:35,120
different when you go through channel b

1700
01:08:35,120 --> 01:08:36,560
than if you go through channel e and

1701
01:08:36,560 --> 01:08:39,040
then channel s

1702
01:08:39,040 --> 01:08:41,040
so this is what we'll utilize

1703
01:08:41,040 --> 01:08:41,920
okay

1704
01:08:41,920 --> 01:08:44,080
so our scheme is fairly similar as

1705
01:08:44,080 --> 01:08:46,319
before alice wants to send a message and

1706
01:08:46,319 --> 01:08:48,319
to bob so first she picks a random

1707
01:08:48,319 --> 01:08:49,839
message r and sends it across both

1708
01:08:49,839 --> 01:08:51,279
channels

1709
01:08:51,279 --> 01:08:52,640
then she'll create an obfuscation the

1710
01:08:52,640 --> 01:08:54,238
following function

1711
01:08:54,238 --> 01:08:56,238
the function again has r and m hard

1712
01:08:56,238 --> 01:08:58,960
coded into it and will do it will check

1713
01:08:58,960 --> 01:09:00,880
if every crossover probability is what

1714
01:09:00,880 --> 01:09:02,719
would be expected if you had sent the

1715
01:09:02,719 --> 01:09:04,319
input across

1716
01:09:04,319 --> 01:09:06,158
if you said set r across channel b to

1717
01:09:06,158 --> 01:09:08,799
get the input so we'll check all the x's

1718
01:09:08,799 --> 01:09:10,640
and r's and see how many of those became

1719
01:09:10,640 --> 01:09:13,198
y's and r prime and see okay is this

1720
01:09:13,198 --> 01:09:15,198
ratio would i expect if r prime was

1721
01:09:15,198 --> 01:09:18,799
generated by sending r across channel p

1722
01:09:18,799 --> 01:09:20,560
so it's checking whether our prime it's

1723
01:09:20,560 --> 01:09:22,238
input is sort of a typical value in

1724
01:09:22,238 --> 01:09:24,880
terms of these input output ratios

1725
01:09:24,880 --> 01:09:28,080
from sending r across channel p

1726
01:09:28,080 --> 01:09:29,920
okay so in this case we get correctness

1727
01:09:29,920 --> 01:09:32,080
again because bob simply puts his input

1728
01:09:32,080 --> 01:09:34,399
rb into this obfuscated function and it

1729
01:09:34,399 --> 01:09:35,679
should pass these checks with good

1730
01:09:35,679 --> 01:09:38,399
probability and therefore he gets m

1731
01:09:38,399 --> 01:09:40,640
and then what about security

1732
01:09:40,640 --> 01:09:43,520
so recall that if we said that if eve

1733
01:09:43,520 --> 01:09:45,839
cannot generate inputs to this function

1734
01:09:45,839 --> 01:09:48,880
that cause it to output m or not bot

1735
01:09:48,880 --> 01:09:50,640
then we can sort of replace it with the

1736
01:09:50,640 --> 01:09:52,880
simulator and hide the value of m

1737
01:09:52,880 --> 01:09:55,120
so really what we want to do is say that

1738
01:09:55,120 --> 01:09:57,440
even given r e here leakage you still

1739
01:09:57,440 --> 01:09:59,280
cannot generate any inputs that cause

1740
01:09:59,280 --> 01:10:01,360
this function to output anything but

1741
01:10:01,360 --> 01:10:02,560
bought

1742
01:10:02,560 --> 01:10:04,400
so that's what we're going to look at

1743
01:10:04,400 --> 01:10:06,400
and we first consider restrictive

1744
01:10:06,400 --> 01:10:08,560
setting where the only way eve can

1745
01:10:08,560 --> 01:10:10,560
generate these values is by running her

1746
01:10:10,560 --> 01:10:13,040
input re through a discrete memoryless

1747
01:10:13,040 --> 01:10:14,960
channel channel s

1748
01:10:14,960 --> 01:10:16,960
so suppose it's the case e generates

1749
01:10:16,960 --> 01:10:19,199
these r primes for whatever channel s's

1750
01:10:19,199 --> 01:10:21,199
she likes and then she tries to input

1751
01:10:21,199 --> 01:10:23,520
them the function and cause something to

1752
01:10:23,520 --> 01:10:25,520
output them

1753
01:10:25,520 --> 01:10:27,199
so in this specific scenario we can

1754
01:10:27,199 --> 01:10:29,840
argue security and why is that well

1755
01:10:29,840 --> 01:10:31,920
because channel b is not a degradation

1756
01:10:31,920 --> 01:10:33,040
of channel e

1757
01:10:33,040 --> 01:10:34,800
then there should be some x star y star

1758
01:10:34,800 --> 01:10:36,560
with a different crossover probability

1759
01:10:36,560 --> 01:10:38,719
between r and r prime than what you

1760
01:10:38,719 --> 01:10:39,920
would expect if you set it through

1761
01:10:39,920 --> 01:10:41,360
channel b

1762
01:10:41,360 --> 01:10:43,920
and therefore if you input r prime to

1763
01:10:43,920 --> 01:10:46,080
this equation when it checks for x-star

1764
01:10:46,080 --> 01:10:48,560
and y-star it should notice that the

1765
01:10:48,560 --> 01:10:51,280
crossover probability was different

1766
01:10:51,280 --> 01:10:52,719
and therefore the check will fail and

1767
01:10:52,719 --> 01:10:54,239
i'll put bot

1768
01:10:54,239 --> 01:10:56,480
and as we said earlier if you can't

1769
01:10:56,480 --> 01:10:58,239
create anything that doesn't output bot

1770
01:10:58,239 --> 01:10:59,760
then the obfuscation will hide the value

1771
01:10:59,760 --> 01:11:01,199
of m because you can replace this

1772
01:11:01,199 --> 01:11:03,840
function with a simulated one

1773
01:11:03,840 --> 01:11:05,760
okay but of course eve doesn't have to

1774
01:11:05,760 --> 01:11:08,159
do that you can choose any strategy she

1775
01:11:08,159 --> 01:11:10,239
wants in fact this strategy can look at

1776
01:11:10,239 --> 01:11:12,400
all the bits of re at once and try to

1777
01:11:12,400 --> 01:11:14,320
generate something

1778
01:11:14,320 --> 01:11:17,440
so how do we argue security in this case

1779
01:11:17,440 --> 01:11:19,920
well what we'll do is we show that in

1780
01:11:19,920 --> 01:11:20,880
fact

1781
01:11:20,880 --> 01:11:23,360
using this arbitrary strategy is no

1782
01:11:23,360 --> 01:11:25,120
better really than if you had used a

1783
01:11:25,120 --> 01:11:27,679
discrete memoryless channel of channel s

1784
01:11:27,679 --> 01:11:29,920
so more specifically for any channel or

1785
01:11:29,920 --> 01:11:31,840
any strategy g then there's some

1786
01:11:31,840 --> 01:11:33,440
discrete memoryless channel and some

1787
01:11:33,440 --> 01:11:34,800
polynomial

1788
01:11:34,800 --> 01:11:37,040
such that e's probability of producing

1789
01:11:37,040 --> 01:11:38,880
an input that causes the function output

1790
01:11:38,880 --> 01:11:41,920
m is no more than polynomial times your

1791
01:11:41,920 --> 01:11:44,640
strategy if you use channel s plus some

1792
01:11:44,640 --> 01:11:47,600
usable value so in particular if her

1793
01:11:47,600 --> 01:11:49,920
probability of winning and channel s was

1794
01:11:49,920 --> 01:11:52,000
negligible then e's probability of

1795
01:11:52,000 --> 01:11:54,960
winning with g is also negligible

1796
01:11:54,960 --> 01:11:57,520
and we show this via hybrid argument

1797
01:11:57,520 --> 01:11:59,440
but for the sake of time i won't be able

1798
01:11:59,440 --> 01:12:00,960
to go into that but you can see our

1799
01:12:00,960 --> 01:12:03,440
paper for details

1800
01:12:03,440 --> 01:12:05,520
okay so in conclusion we show that

1801
01:12:05,520 --> 01:12:06,719
assuming this form of function

1802
01:12:06,719 --> 01:12:09,040
obfuscation then wiretap coding schemes

1803
01:12:09,040 --> 01:12:10,880
are possible if and only if bob's

1804
01:12:10,880 --> 01:12:12,400
channel is not a degradation of each

1805
01:12:12,400 --> 01:12:13,360
channel

1806
01:12:13,360 --> 01:12:15,120
so this means that this entire blue

1807
01:12:15,120 --> 01:12:17,120
region of less noisy that was impossible

1808
01:12:17,120 --> 01:12:19,280
in the information theoretic setting is

1809
01:12:19,280 --> 01:12:21,120
now possible in the computational

1810
01:12:21,120 --> 01:12:23,360
setting and we have completely

1811
01:12:23,360 --> 01:12:25,520
characterized the region

1812
01:12:25,520 --> 01:12:27,920
and one nice thing is that degraded

1813
01:12:27,920 --> 01:12:29,600
given two channels is very easy to

1814
01:12:29,600 --> 01:12:31,199
compute you can compute if a channel is

1815
01:12:31,199 --> 01:12:33,360
a degradation or another but in fact

1816
01:12:33,360 --> 01:12:35,840
less noisy just like channel capacity is

1817
01:12:35,840 --> 01:12:38,800
quite difficult to compute

1818
01:12:38,800 --> 01:12:40,159
so it's

1819
01:12:40,159 --> 01:12:42,400
rather difficult to tell if two channels

1820
01:12:42,400 --> 01:12:44,080
have an information theoretic solution

1821
01:12:44,080 --> 01:12:44,960
or not

1822
01:12:44,960 --> 01:12:48,320
but computationally we can easily tell

1823
01:12:48,320 --> 01:12:50,239
and there's a couple extensions again we

1824
01:12:50,239 --> 01:12:51,679
can extend this to general message

1825
01:12:51,679 --> 01:12:53,600
spaces and we can actually get optimal

1826
01:12:53,600 --> 01:12:55,760
rate meaning that we can send messages

1827
01:12:55,760 --> 01:12:57,840
up to the capacity of bob's channel and

1828
01:12:57,840 --> 01:12:59,520
you can do this using standard

1829
01:12:59,520 --> 01:13:00,800
cryptographic techniques in the

1830
01:13:00,800 --> 01:13:02,719
computational setting

1831
01:13:02,719 --> 01:13:04,800
and finally we note that our scheme is a

1832
01:13:04,800 --> 01:13:06,480
universal encoding meaning that the

1833
01:13:06,480 --> 01:13:08,239
encoding only depends on bob's channel

1834
01:13:08,239 --> 01:13:10,400
and not each channel so this is nice

1835
01:13:10,400 --> 01:13:11,920
which because you don't have to really

1836
01:13:11,920 --> 01:13:13,440
know what the adversary's channel is

1837
01:13:13,440 --> 01:13:16,400
exactly in order to get this game

1838
01:13:16,400 --> 01:13:19,839
so thank you

1839
01:13:26,000 --> 01:13:29,320
any question

1840
01:13:33,760 --> 01:13:35,760
so uh thanks for the talk

1841
01:13:35,760 --> 01:13:39,040
i wanted to ask uh if you thought that

1842
01:13:39,040 --> 01:13:41,360
uh obfuscation was

1843
01:13:41,360 --> 01:13:44,159
necessary for this to work or like

1844
01:13:44,159 --> 01:13:46,719
why could this not be possible say just

1845
01:13:46,719 --> 01:13:48,800
using public key

1846
01:13:48,800 --> 01:13:50,640
or or something like that

1847
01:13:50,640 --> 01:13:53,840
yeah that's a good question so uh

1848
01:13:53,840 --> 01:13:56,800
so for one thing uh our setting

1849
01:13:56,800 --> 01:13:58,080
so yeah so if you didn't want to have

1850
01:13:58,080 --> 01:14:00,560
the channels that you actually can't get

1851
01:14:00,560 --> 01:14:02,000
such a scheme because we're talking

1852
01:14:02,000 --> 01:14:04,320
about uni-directional uh

1853
01:14:04,320 --> 01:14:06,000
communication so there's no back and

1854
01:14:06,000 --> 01:14:07,600
forth and there's no shared secrets

1855
01:14:07,600 --> 01:14:09,679
ahead of time so in some sense we do

1856
01:14:09,679 --> 01:14:12,320
need a noisy channel to allow even

1857
01:14:12,320 --> 01:14:14,880
secure messaging to happen but assuming

1858
01:14:14,880 --> 01:14:16,640
that the other question is do you need

1859
01:14:16,640 --> 01:14:18,880
obfuscation uh

1860
01:14:18,880 --> 01:14:20,800
so actually something weaker than this

1861
01:14:20,800 --> 01:14:23,360
obfuscation could suffice um this is

1862
01:14:23,360 --> 01:14:25,040
sort of a more standard definition we

1863
01:14:25,040 --> 01:14:26,960
use but we really sort of just need like

1864
01:14:26,960 --> 01:14:28,640
a one witness and that

1865
01:14:28,640 --> 01:14:30,880
if you send this message across

1866
01:14:30,880 --> 01:14:32,640
then you can't completely recover the

1867
01:14:32,640 --> 01:14:34,000
message because then you could use

1868
01:14:34,000 --> 01:14:37,360
extractor or hardcore bit on the message

1869
01:14:37,360 --> 01:14:38,400
so

1870
01:14:38,400 --> 01:14:41,120
obfuscation is a sufficient

1871
01:14:41,120 --> 01:14:43,280
thing to create this game but you could

1872
01:14:43,280 --> 01:14:44,880
probably propose other things that are a

1873
01:14:44,880 --> 01:14:47,040
little bit weaker and would also satisfy

1874
01:14:47,040 --> 01:14:47,760
this

1875
01:14:47,760 --> 01:14:50,159
oh wait thank you

1876
01:14:50,159 --> 01:14:52,560
there is also a question on zoom

1877
01:14:52,560 --> 01:14:54,880
somebody asked do you require specific

1878
01:14:54,880 --> 01:14:56,640
probability distribution over the

1879
01:14:56,640 --> 01:14:59,120
message space to prove security for

1880
01:14:59,120 --> 01:15:01,199
example the message is uniformly

1881
01:15:01,199 --> 01:15:02,960
distributed

1882
01:15:02,960 --> 01:15:03,840
uh

1883
01:15:03,840 --> 01:15:05,520
okay yeah so

1884
01:15:05,520 --> 01:15:07,840
for our scheme in the general case it's

1885
01:15:07,840 --> 01:15:09,840
just simply a uniform random message

1886
01:15:09,840 --> 01:15:11,440
that we send across

1887
01:15:11,440 --> 01:15:12,800
and

1888
01:15:12,800 --> 01:15:14,880
actually really all we require is that

1889
01:15:14,880 --> 01:15:16,800
the methods you sent across

1890
01:15:16,800 --> 01:15:19,280
it's unpredictable and has the same like

1891
01:15:19,280 --> 01:15:22,640
a large number of each input symbol

1892
01:15:22,640 --> 01:15:23,920
but we don't require a specific

1893
01:15:23,920 --> 01:15:27,360
distribution dependent on the channel

1894
01:15:29,120 --> 01:15:31,760
uh any other question

1895
01:15:31,760 --> 01:15:32,960
if not let's

1896
01:15:32,960 --> 01:15:37,000
thank the speaker again

1897
01:15:41,440 --> 01:15:44,080
uh the next next talk is correlated

1898
01:15:44,080 --> 01:15:46,880
pseudo-randomness from expand accumulate

1899
01:15:46,880 --> 01:15:50,840
code the speaker is

1900
01:15:50,840 --> 01:15:55,080
nicolas rats

1901
01:16:34,560 --> 01:16:37,600
possible to do this

1902
01:16:39,040 --> 01:16:40,960
yeah

1903
01:16:40,960 --> 01:16:42,400
cool all right thank you very much for

1904
01:16:42,400 --> 01:16:43,280
the introduction yeah my name is

1905
01:16:43,280 --> 01:16:44,560
nicholas rash and this is a joint work

1906
01:16:44,560 --> 01:16:46,560
with elect boyle jeff walker

1907
01:16:46,560 --> 01:16:48,960
gilbert

1908
01:16:50,800 --> 01:16:53,040
so this talk um is concerned with a

1909
01:16:53,040 --> 01:16:54,560
correlated randomness or correlated

1910
01:16:54,560 --> 01:16:58,159
pseudorandomness um this board button

1911
01:16:58,159 --> 01:17:01,519
sorry was it this green button

1912
01:17:06,960 --> 01:17:08,800
there we go yes i think that was a

1913
01:17:08,800 --> 01:17:09,840
problem

1914
01:17:09,840 --> 01:17:12,000
great um so this talk is concerned with

1915
01:17:12,000 --> 01:17:13,360
correlated randomness or even correlated

1916
01:17:13,360 --> 01:17:14,800
pseudorandomness and i'd like to start

1917
01:17:14,800 --> 01:17:16,080
off by pointing out that this is

1918
01:17:16,080 --> 01:17:17,360
something that you're all very familiar

1919
01:17:17,360 --> 01:17:19,040
with even from the very first course

1920
01:17:19,040 --> 01:17:20,640
that you maybe took on cryptography

1921
01:17:20,640 --> 01:17:23,120
maybe the second lecture even so alice

1922
01:17:23,120 --> 01:17:24,400
and bob are two friends who wish to

1923
01:17:24,400 --> 01:17:26,159
communicate so alice has the message she

1924
01:17:26,159 --> 01:17:28,000
wants to send to bob but the channel

1925
01:17:28,000 --> 01:17:30,159
might be eve dropped on what can these

1926
01:17:30,159 --> 01:17:31,760
two part two people do well they could

1927
01:17:31,760 --> 01:17:34,159
use a one-time pad to uh you know

1928
01:17:34,159 --> 01:17:36,640
securely encrypt alice's message so how

1929
01:17:36,640 --> 01:17:38,000
should we think about this one-time pad

1930
01:17:38,000 --> 01:17:39,120
i'd like to encourage you to think of

1931
01:17:39,120 --> 01:17:40,080
this as some sort of correlated

1932
01:17:40,080 --> 01:17:41,679
randomness these are two uniformly

1933
01:17:41,679 --> 01:17:43,120
random strings

1934
01:17:43,120 --> 01:17:45,040
marginally uniformly random but together

1935
01:17:45,040 --> 01:17:46,480
they satisfy you know the equality

1936
01:17:46,480 --> 01:17:47,920
correlation

1937
01:17:47,920 --> 01:17:49,360
okay so this is great for you know

1938
01:17:49,360 --> 01:17:51,040
secure communication but we're going to

1939
01:17:51,040 --> 01:17:52,560
deal with a multi-party computation in

1940
01:17:52,560 --> 01:17:54,400
this talk so just to briefly remind you

1941
01:17:54,400 --> 01:17:56,159
all of what this is now we have our two

1942
01:17:56,159 --> 01:17:57,840
friends alice and bob but unfortunately

1943
01:17:57,840 --> 01:17:59,760
they don't trust each other anymore but

1944
01:17:59,760 --> 01:18:01,120
nonetheless they'd like to work together

1945
01:18:01,120 --> 01:18:03,120
to compute some function f which depends

1946
01:18:03,120 --> 01:18:05,040
on their private inputs x and y and we

1947
01:18:05,040 --> 01:18:06,320
want to do this in such a way that

1948
01:18:06,320 --> 01:18:07,840
nothing additional is revealed about the

1949
01:18:07,840 --> 01:18:09,280
private inputs

1950
01:18:09,280 --> 01:18:10,960
so uh just for this talk i'd like you to

1951
01:18:10,960 --> 01:18:13,520
just think of the case of two parties

1952
01:18:13,520 --> 01:18:14,320
okay

1953
01:18:14,320 --> 01:18:16,239
now even though this is maybe seemingly

1954
01:18:16,239 --> 01:18:18,239
a more difficult uh challenge for alice

1955
01:18:18,239 --> 01:18:20,719
and bob to do here um compared to just

1956
01:18:20,719 --> 01:18:22,239
communication it turns out that once we

1957
01:18:22,239 --> 01:18:24,400
have some nice uh shared correlated

1958
01:18:24,400 --> 01:18:26,480
randomness alice and bob can run very

1959
01:18:26,480 --> 01:18:28,719
efficient uh two pc protocols so in

1960
01:18:28,719 --> 01:18:29,920
particular once we have these things

1961
01:18:29,920 --> 01:18:31,520
called oblivious transfer um

1962
01:18:31,520 --> 01:18:33,840
correlations where you know essentially

1963
01:18:33,840 --> 01:18:35,520
alice has some random choice bit which

1964
01:18:35,520 --> 01:18:36,640
you know picks out one of the two

1965
01:18:36,640 --> 01:18:38,880
messages from bob um it turns out that

1966
01:18:38,880 --> 01:18:40,719
we can have very fast um

1967
01:18:40,719 --> 01:18:42,640
protocols for say computing to secure

1968
01:18:42,640 --> 01:18:44,960
and of two bits so i don't want you to

1969
01:18:44,960 --> 01:18:46,960
look too much at the precise um details

1970
01:18:46,960 --> 01:18:48,960
on the slide but the important fact is

1971
01:18:48,960 --> 01:18:50,080
that once we have this correlated

1972
01:18:50,080 --> 01:18:52,640
randomness we can run very very fast mpc

1973
01:18:52,640 --> 01:18:54,000
protocols essentially by going through

1974
01:18:54,000 --> 01:18:55,760
the circuit describing the function that

1975
01:18:55,760 --> 01:18:57,199
alice involved which to compute and

1976
01:18:57,199 --> 01:18:58,880
compute consuming the randomness as

1977
01:18:58,880 --> 01:19:00,880
required so this basically describes the

1978
01:19:00,880 --> 01:19:03,120
mpc with pre-processing framework once

1979
01:19:03,120 --> 01:19:04,400
you know at the start maybe alice and

1980
01:19:04,400 --> 01:19:05,679
bob have to share a lot of correlated

1981
01:19:05,679 --> 01:19:07,440
randomness but once this is done we have

1982
01:19:07,440 --> 01:19:09,360
a very very fast um even information

1983
01:19:09,360 --> 01:19:10,960
theoretically secure

1984
01:19:10,960 --> 01:19:12,640
mpc protocol

1985
01:19:12,640 --> 01:19:14,080
but okay there is of course a drawback

1986
01:19:14,080 --> 01:19:16,080
here what's the problem i mean the

1987
01:19:16,080 --> 01:19:17,360
problem is that we typically need very

1988
01:19:17,360 --> 01:19:19,440
very long random strings and this isn't

1989
01:19:19,440 --> 01:19:20,880
even too surprising i mean this first

1990
01:19:20,880 --> 01:19:22,080
example that i gave you about the one

1991
01:19:22,080 --> 01:19:23,920
time pad you know we know from shannon's

1992
01:19:23,920 --> 01:19:26,000
impossibility results that um we need

1993
01:19:26,000 --> 01:19:27,280
the length of a one-time pad to be at

1994
01:19:27,280 --> 01:19:29,280
least the length of a message but of

1995
01:19:29,280 --> 01:19:30,880
course cryptographers have developed

1996
01:19:30,880 --> 01:19:32,400
already since the 80s great solutions to

1997
01:19:32,400 --> 01:19:34,239
this problem instead of sharing a

1998
01:19:34,239 --> 01:19:36,000
complete one-time pad you might share

1999
01:19:36,000 --> 01:19:37,920
say a seed for a pseudo-random generator

2000
01:19:37,920 --> 01:19:39,440
or even maybe a key for a pseudo-random

2001
01:19:39,440 --> 01:19:40,880
function and then you can just generate

2002
01:19:40,880 --> 01:19:42,320
the pseudorandomness that you need which

2003
01:19:42,320 --> 01:19:43,600
is basically like generating you know

2004
01:19:43,600 --> 01:19:46,000
all the uh correlated one-time pads that

2005
01:19:46,000 --> 01:19:48,880
alison bought me to communicate

2006
01:19:48,880 --> 01:19:51,520
so when it comes to secure computation i

2007
01:19:51,520 --> 01:19:52,880
mean essentially the sort of protocols

2008
01:19:52,880 --> 01:19:54,480
describing on the previous slide would

2009
01:19:54,480 --> 01:19:56,159
require two oblivious transfers per and

2010
01:19:56,159 --> 01:19:58,239
gate and traditionally unfortunately we

2011
01:19:58,239 --> 01:19:59,760
would need a very very long

2012
01:19:59,760 --> 01:20:00,880
pre-processing phase with high

2013
01:20:00,880 --> 01:20:02,480
communication in order to share all this

2014
01:20:02,480 --> 01:20:04,400
correlated randomness but fortunately in

2015
01:20:04,400 --> 01:20:06,000
the last you know six or seven years

2016
01:20:06,000 --> 01:20:07,840
essentially recreating this idea from

2017
01:20:07,840 --> 01:20:09,600
secure computation sorry secure

2018
01:20:09,600 --> 01:20:11,600
communication was used in the secure

2019
01:20:11,600 --> 01:20:13,600
computation framework where we could

2020
01:20:13,600 --> 01:20:15,520
imagine sharing short correlated seeds

2021
01:20:15,520 --> 01:20:16,960
to alice and bob and they can stretch

2022
01:20:16,960 --> 01:20:18,800
them but now generating pseudo-random

2023
01:20:18,800 --> 01:20:20,560
correlations

2024
01:20:20,560 --> 01:20:22,239
okay so let's try to make this a bit

2025
01:20:22,239 --> 01:20:23,360
more precise here so how would a

2026
01:20:23,360 --> 01:20:25,600
pseudorandom correlation generator work

2027
01:20:25,600 --> 01:20:27,360
again we have our friends alice and bob

2028
01:20:27,360 --> 01:20:29,440
and initially we can generate some seeds

2029
01:20:29,440 --> 01:20:30,880
and the point now is that once alice and

2030
01:20:30,880 --> 01:20:32,800
bob had these short seeds they can run

2031
01:20:32,800 --> 01:20:35,280
some extent uh expand algorithm on these

2032
01:20:35,280 --> 01:20:36,960
seeds and now note that this step here

2033
01:20:36,960 --> 01:20:38,560
requires no communication so this is

2034
01:20:38,560 --> 01:20:40,480
just you know them privately expanding

2035
01:20:40,480 --> 01:20:42,320
their own seeds and we just want some

2036
01:20:42,320 --> 01:20:43,679
certain guarantees so first of all you

2037
01:20:43,679 --> 01:20:45,520
should maybe think of you know every

2038
01:20:45,520 --> 01:20:48,159
entry and there and their um expanded

2039
01:20:48,159 --> 01:20:49,440
seeds you know these long strings at the

2040
01:20:49,440 --> 01:20:52,239
bottom here are just like an independent

2041
01:20:52,239 --> 01:20:54,159
ot correlations that they could use when

2042
01:20:54,159 --> 01:20:56,639
running their favorite mpc protocol

2043
01:20:56,639 --> 01:20:58,159
and then we also need that you know each

2044
01:20:58,159 --> 01:20:59,920
of them on their own if you only see one

2045
01:20:59,920 --> 01:21:01,199
of them it looks like a uniformly random

2046
01:21:01,199 --> 01:21:02,480
string just like we had for one time

2047
01:21:02,480 --> 01:21:04,800
pads and the security now is also a bit

2048
01:21:04,800 --> 01:21:06,159
more subtle i'm not going to go into too

2049
01:21:06,159 --> 01:21:07,920
many details but essentially because

2050
01:21:07,920 --> 01:21:09,440
alice and bob don't trust each other you

2051
01:21:09,440 --> 01:21:11,120
need it to be sort of the case that even

2052
01:21:11,120 --> 01:21:12,800
after seeing your own seed

2053
01:21:12,800 --> 01:21:15,440
the other parties um half only looks you

2054
01:21:15,440 --> 01:21:17,199
know pseudorandom up to this correlation

2055
01:21:17,199 --> 01:21:18,960
that you know we're targeting

2056
01:21:18,960 --> 01:21:20,960
okay but that's not um that's more some

2057
01:21:20,960 --> 01:21:22,400
prior work and so this is the sort of

2058
01:21:22,400 --> 01:21:24,239
object that we'll be targeting today

2059
01:21:24,239 --> 01:21:26,320
um but now also just in the same way

2060
01:21:26,320 --> 01:21:27,679
that we could go from pseudorandom

2061
01:21:27,679 --> 01:21:29,120
generators to pseudorandom functions

2062
01:21:29,120 --> 01:21:30,960
when you want you know let's say an

2063
01:21:30,960 --> 01:21:32,560
exponentially long string of you know

2064
01:21:32,560 --> 01:21:34,560
randomness that you can sort of query on

2065
01:21:34,560 --> 01:21:36,719
demand um we can do something similar

2066
01:21:36,719 --> 01:21:37,920
you can ask for something similar with

2067
01:21:37,920 --> 01:21:39,760
these correlations and here it's sort of

2068
01:21:39,760 --> 01:21:41,440
like we you know we would share now some

2069
01:21:41,440 --> 01:21:43,360
correlated keys to alice and bob and

2070
01:21:43,360 --> 01:21:45,840
then whenever they need a new uh

2071
01:21:45,840 --> 01:21:47,440
example of they need a new instance of

2072
01:21:47,440 --> 01:21:49,280
the desired correlation they can run

2073
01:21:49,280 --> 01:21:50,960
some eval function so this could give

2074
01:21:50,960 --> 01:21:52,560
them you know up to

2075
01:21:52,560 --> 01:21:54,639
exponentially many um correlations that

2076
01:21:54,639 --> 01:21:57,280
they could use in the mpc protocol

2077
01:21:57,280 --> 01:21:58,719
and the correctness due to randomness

2078
01:21:58,719 --> 01:22:00,080
and security guarantees are just the

2079
01:22:00,080 --> 01:22:02,480
same so i won't belabor the point

2080
01:22:02,480 --> 01:22:04,400
okay so what do we propose in this work

2081
01:22:04,400 --> 01:22:06,159
well um if we think about the

2082
01:22:06,159 --> 01:22:07,600
pseudo-random genera correlation

2083
01:22:07,600 --> 01:22:09,679
generators um they have the effect that

2084
01:22:09,679 --> 01:22:10,880
all the work is done in the offline

2085
01:22:10,880 --> 01:22:12,000
phase essentially you know we share

2086
01:22:12,000 --> 01:22:13,440
these seeds at the start and then we run

2087
01:22:13,440 --> 01:22:15,440
this expansion protocol and then you

2088
01:22:15,440 --> 01:22:16,239
know

2089
01:22:16,239 --> 01:22:18,080
the sorry this expansion step which is

2090
01:22:18,080 --> 01:22:19,520
silent but then when we're actually

2091
01:22:19,520 --> 01:22:20,960
writing the npc protocol no more work

2092
01:22:20,960 --> 01:22:22,719
needs to be done on the other hand with

2093
01:22:22,719 --> 01:22:24,080
pseudorandom correlation functions all

2094
01:22:24,080 --> 01:22:25,040
the work is essentially done in the

2095
01:22:25,040 --> 01:22:26,480
online phase and this can be a bit of an

2096
01:22:26,480 --> 01:22:28,080
expensive step you know we share these

2097
01:22:28,080 --> 01:22:29,360
keys at the start but every time we need

2098
01:22:29,360 --> 01:22:30,800
a new correlation we have to run this

2099
01:22:30,800 --> 01:22:32,480
eval operation

2100
01:22:32,480 --> 01:22:34,480
and so in this work we propose what we

2101
01:22:34,480 --> 01:22:36,480
call offline online pcgs which are sort

2102
01:22:36,480 --> 01:22:38,480
of a more flexible intermediate point

2103
01:22:38,480 --> 01:22:40,159
between these two objects

2104
01:22:40,159 --> 01:22:41,840
so how would this work now um let's say

2105
01:22:41,840 --> 01:22:44,400
we have offline and online keys

2106
01:22:44,400 --> 01:22:46,880
and um initially alice and bob can you

2107
01:22:46,880 --> 01:22:48,560
know share these share all these keys

2108
01:22:48,560 --> 01:22:50,719
and then run a silent offline step to

2109
01:22:50,719 --> 01:22:52,000
generate what i'll call this offline

2110
01:22:52,000 --> 01:22:53,920
material y a and y b

2111
01:22:53,920 --> 01:22:55,520
and now this offline material in and of

2112
01:22:55,520 --> 01:22:57,679
itself does not actually satisfy the

2113
01:22:57,679 --> 01:22:59,679
desired target correlation but one thing

2114
01:22:59,679 --> 01:23:00,800
that we will guarantee is that it's not

2115
01:23:00,800 --> 01:23:02,320
too long it's not say if we want you

2116
01:23:02,320 --> 01:23:04,239
know 10 million ots maybe this is only

2117
01:23:04,239 --> 01:23:06,320
like 2 million or sorry 20 million uh

2118
01:23:06,320 --> 01:23:08,159
you know long or something like that so

2119
01:23:08,159 --> 01:23:10,480
it's not too much uh too big

2120
01:23:10,480 --> 01:23:13,120
but now when alice and bob need uh you

2121
01:23:13,120 --> 01:23:14,480
know a correlation from the desired

2122
01:23:14,480 --> 01:23:16,239
target correlation they can run a very

2123
01:23:16,239 --> 01:23:18,159
very fast online algorithm in particular

2124
01:23:18,159 --> 01:23:20,080
we'll be targeting algorithms that have

2125
01:23:20,080 --> 01:23:22,000
nice uh locality properties so they

2126
01:23:22,000 --> 01:23:24,000
might only read say like i guess our

2127
01:23:24,000 --> 01:23:25,600
best construction theoretically gets

2128
01:23:25,600 --> 01:23:28,239
like 40 um entries that need to be read

2129
01:23:28,239 --> 01:23:30,560
from the offline material

2130
01:23:30,560 --> 01:23:32,480
okay so this is more efficient than what

2131
01:23:32,480 --> 01:23:35,520
a typical eval operation for a pcf

2132
01:23:35,520 --> 01:23:36,880
okay and again analogous correctness

2133
01:23:36,880 --> 01:23:39,199
suit around this and security guarantees

2134
01:23:39,199 --> 01:23:41,360
great so um our main result our main

2135
01:23:41,360 --> 01:23:43,360
contribution i suppose i should say is a

2136
01:23:43,360 --> 01:23:45,600
construction of an offline online pcg

2137
01:23:45,600 --> 01:23:47,360
from a new class of codes which we term

2138
01:23:47,360 --> 01:23:48,800
expand accumulate codes so if you're

2139
01:23:48,800 --> 01:23:50,480
wondering why this talk appears in the

2140
01:23:50,480 --> 01:23:52,480
coding theory session this is the answer

2141
01:23:52,480 --> 01:23:54,719
um and what are the sort of

2142
01:23:54,719 --> 01:23:56,639
the nice features of our construction

2143
01:23:56,639 --> 01:23:58,480
the offline phase

2144
01:23:58,480 --> 01:23:59,920
it has nice efficiency properties in

2145
01:23:59,920 --> 01:24:01,520
particular it's highly parallelizable

2146
01:24:01,520 --> 01:24:02,880
and also cache friendly hopefully i'll

2147
01:24:02,880 --> 01:24:03,840
be able to convince you of these

2148
01:24:03,840 --> 01:24:06,000
properties as i explain the codes and

2149
01:24:06,000 --> 01:24:07,600
furthermore the online phase has this

2150
01:24:07,600 --> 01:24:10,960
low output locality that i promised

2151
01:24:10,960 --> 01:24:13,600
great so um without any further ado

2152
01:24:13,600 --> 01:24:15,199
allow me to get into a brief discussion

2153
01:24:15,199 --> 01:24:16,960
of how we could hope to construct these

2154
01:24:16,960 --> 01:24:18,400
pseudorandom correlation generators or

2155
01:24:18,400 --> 01:24:20,239
functions or eventually this offline

2156
01:24:20,239 --> 01:24:22,320
online variant

2157
01:24:22,320 --> 01:24:24,080
so uh in order to describe how this

2158
01:24:24,080 --> 01:24:26,000
works it's best if we talk about what's

2159
01:24:26,000 --> 01:24:27,360
called the vector oblivious linear

2160
01:24:27,360 --> 01:24:29,440
evaluation or vole correlation which you

2161
01:24:29,440 --> 01:24:31,360
could just think of as an additive

2162
01:24:31,360 --> 01:24:34,400
secret sharing of a scalar um

2163
01:24:34,400 --> 01:24:36,400
scalar vector product um if you really

2164
01:24:36,400 --> 01:24:38,560
want these ots once you have you know a

2165
01:24:38,560 --> 01:24:39,920
long bole correlation you can get a

2166
01:24:39,920 --> 01:24:41,520
whole bunch of ots with one additional

2167
01:24:41,520 --> 01:24:44,159
hashing step so basically this is a very

2168
01:24:44,159 --> 01:24:45,600
good thing to target

2169
01:24:45,600 --> 01:24:46,400
and

2170
01:24:46,400 --> 01:24:48,320
uh just pictorially um i'd like you to

2171
01:24:48,320 --> 01:24:49,520
courage of you know we want to simulate

2172
01:24:49,520 --> 01:24:51,600
this box which just outputs a vector a

2173
01:24:51,600 --> 01:24:53,440
and c not to alice and a vector b and c

2174
01:24:53,440 --> 01:24:56,000
one to bob sorry a scalar b and a vector

2175
01:24:56,000 --> 01:24:58,480
c one to bob and b times a is equal to c

2176
01:24:58,480 --> 01:25:00,480
not plus c1

2177
01:25:00,480 --> 01:25:01,760
so how can we go about doing this well

2178
01:25:01,760 --> 01:25:03,280
let's consider a certain function this

2179
01:25:03,280 --> 01:25:05,280
is basically um you know i'm just taking

2180
01:25:05,280 --> 01:25:07,280
the vector b times a and i'm rewriting

2181
01:25:07,280 --> 01:25:08,960
it as a function from the integers one

2182
01:25:08,960 --> 01:25:11,040
to n to the field f so nothing fancy is

2183
01:25:11,040 --> 01:25:12,400
going on here

2184
01:25:12,400 --> 01:25:14,320
but we sort of want to additively share

2185
01:25:14,320 --> 01:25:16,239
this object so we could talk about

2186
01:25:16,239 --> 01:25:18,400
trying to additively share this function

2187
01:25:18,400 --> 01:25:20,239
between alice and bob and this brings us

2188
01:25:20,239 --> 01:25:21,679
to the topic of additive function sheet

2189
01:25:21,679 --> 01:25:22,800
of sharing

2190
01:25:22,800 --> 01:25:25,360
which is a well you know a topic that's

2191
01:25:25,360 --> 01:25:27,280
been studied intensively in recent years

2192
01:25:27,280 --> 01:25:29,440
so we want to come up with a way to uh

2193
01:25:29,440 --> 01:25:31,120
design some keys that we can give to

2194
01:25:31,120 --> 01:25:33,679
alex and bob ka and kb

2195
01:25:33,679 --> 01:25:35,280
such that they can both privately

2196
01:25:35,280 --> 01:25:37,360
without any communication run some eval

2197
01:25:37,360 --> 01:25:39,199
operations and then it's guaranteed that

2198
01:25:39,199 --> 01:25:40,960
whenever they run it's a val operation

2199
01:25:40,960 --> 01:25:42,960
on a given input x they get an added

2200
01:25:42,960 --> 01:25:45,840
secret sharing of the function f applied

2201
01:25:45,840 --> 01:25:48,159
uh evaluated at the point x

2202
01:25:48,159 --> 01:25:49,280
okay and now

2203
01:25:49,280 --> 01:25:51,440
sort of a naive or simple solution to

2204
01:25:51,440 --> 01:25:52,960
this problem would be just to say okay

2205
01:25:52,960 --> 01:25:54,800
look at my function and share it you

2206
01:25:54,800 --> 01:25:56,800
know share this truth table

2207
01:25:56,800 --> 01:25:57,760
but we're going to look for something

2208
01:25:57,760 --> 01:25:59,199
much more efficient ideally the key

2209
01:25:59,199 --> 01:26:00,480
should be sort of logarithmic in the

2210
01:26:00,480 --> 01:26:02,080
size of this truth table

2211
01:26:02,080 --> 01:26:04,239
so doing this for general functions is

2212
01:26:04,239 --> 01:26:06,480
is uh you know maybe not doable but we

2213
01:26:06,480 --> 01:26:08,000
can do it for special classes of

2214
01:26:08,000 --> 01:26:09,440
functions so in particular sort of the

2215
01:26:09,440 --> 01:26:10,800
first functions which were study were

2216
01:26:10,800 --> 01:26:12,320
these point functions which are just

2217
01:26:12,320 --> 01:26:14,480
functions that take almost uh one

2218
01:26:14,480 --> 01:26:16,719
non-zero value let's say um and once you

2219
01:26:16,719 --> 01:26:18,480
can sort of do a function that takes

2220
01:26:18,480 --> 01:26:20,159
almost one non-zero value we could also

2221
01:26:20,159 --> 01:26:21,679
say do functions that take almost t

2222
01:26:21,679 --> 01:26:23,840
non-zero values just by blowing up the

2223
01:26:23,840 --> 01:26:25,440
keys by a factor of t say because you

2224
01:26:25,440 --> 01:26:26,639
know we just need t

2225
01:26:26,639 --> 01:26:28,639
sharings of point functions so we can

2226
01:26:28,639 --> 01:26:30,320
basically share functions that take say

2227
01:26:30,320 --> 01:26:31,920
almost t non-zero values where we think

2228
01:26:31,920 --> 01:26:34,480
of t as not being too large

2229
01:26:34,480 --> 01:26:36,159
okay so what does this mean returning to

2230
01:26:36,159 --> 01:26:37,840
the function that we wanted to share if

2231
01:26:37,840 --> 01:26:40,560
so long as this uh vector a was sparse

2232
01:26:40,560 --> 01:26:42,320
that means this function f of x which is

2233
01:26:42,320 --> 01:26:44,719
b times a sub x that will be you know a

2234
01:26:44,719 --> 01:26:45,920
function that takes at most say two

2235
01:26:45,920 --> 01:26:47,920
non-zero values when a is the hamming

2236
01:26:47,920 --> 01:26:49,600
weight of of t

2237
01:26:49,600 --> 01:26:52,719
sorry t is the hamming weight of a

2238
01:26:52,719 --> 01:26:54,880
good uh so this is already um allows us

2239
01:26:54,880 --> 01:26:56,239
to say essentially that we have a way to

2240
01:26:56,239 --> 01:26:58,320
do a sparse volati correlation so i'll

2241
01:26:58,320 --> 01:26:59,920
introduce of some new names here which

2242
01:26:59,920 --> 01:27:01,760
hopefully will be clear in a second but

2243
01:27:01,760 --> 01:27:03,280
basically we can share

2244
01:27:03,280 --> 01:27:04,719
random vectors that satisfy the

2245
01:27:04,719 --> 01:27:06,159
correlation b times e equals c naught

2246
01:27:06,159 --> 01:27:07,760
prime plus c one prime with the

2247
01:27:07,760 --> 01:27:10,159
additional caveat that this vector e is

2248
01:27:10,159 --> 01:27:11,120
sparse

2249
01:27:11,120 --> 01:27:12,880
so how could we hope to convert this

2250
01:27:12,880 --> 01:27:14,639
into a genuine um

2251
01:27:14,639 --> 01:27:16,960
vector ole instance

2252
01:27:16,960 --> 01:27:19,199
well if we have some matrix h which is

2253
01:27:19,199 --> 01:27:21,360
you know some linear compressing map

2254
01:27:21,360 --> 01:27:22,960
let's say and we apply it to all these

2255
01:27:22,960 --> 01:27:24,239
vectors

2256
01:27:24,239 --> 01:27:25,120
then

2257
01:27:25,120 --> 01:27:27,280
uh we'll get some new vectors ac on c1

2258
01:27:27,280 --> 01:27:28,639
and firstly just because of the

2259
01:27:28,639 --> 01:27:30,719
linearity of h we still preserve the

2260
01:27:30,719 --> 01:27:32,880
desired bullet correlation so nothing

2261
01:27:32,880 --> 01:27:35,040
there has gone wrong now the question is

2262
01:27:35,040 --> 01:27:36,960
should we expect that these vectors all

2263
01:27:36,960 --> 01:27:38,480
kind of look pseudo-random up to this

2264
01:27:38,480 --> 01:27:40,400
correlation so in particular the

2265
01:27:40,400 --> 01:27:42,080
non-trivial part here is that this

2266
01:27:42,080 --> 01:27:44,480
vector a up here is the image of a

2267
01:27:44,480 --> 01:27:46,639
sparse vector so why should we expect it

2268
01:27:46,639 --> 01:27:48,800
to be um to look uniform

2269
01:27:48,800 --> 01:27:50,239
fortunately for us there's sort of a you

2270
01:27:50,239 --> 01:27:51,760
know a well-studied assumption i'm

2271
01:27:51,760 --> 01:27:53,360
calling it lpn here learning pairs with

2272
01:27:53,360 --> 01:27:55,040
noise maybe to use some more expressive

2273
01:27:55,040 --> 01:27:56,320
language from the previous talks we

2274
01:27:56,320 --> 01:27:58,159
should say i guess the

2275
01:27:58,159 --> 01:27:59,840
decisional variant of the syndrome

2276
01:27:59,840 --> 01:28:02,639
decoding problem um if you choose h

2277
01:28:02,639 --> 01:28:04,880
uniformly at random this will indeed

2278
01:28:04,880 --> 01:28:06,800
work that this this vector a will look

2279
01:28:06,800 --> 01:28:07,679
you know computationally

2280
01:28:07,679 --> 01:28:09,199
indistinguishable from a uniformly

2281
01:28:09,199 --> 01:28:10,800
random vector

2282
01:28:10,800 --> 01:28:12,400
but we can be a bit greedy here so if

2283
01:28:12,400 --> 01:28:13,920
you recall also from i guess the first

2284
01:28:13,920 --> 01:28:15,280
talk we talked about alex novich's

2285
01:28:15,280 --> 01:28:17,120
construction and how you know uniformly

2286
01:28:17,120 --> 01:28:18,960
random matrix is a bit too much to store

2287
01:28:18,960 --> 01:28:20,159
could we hope to also get some better

2288
01:28:20,159 --> 01:28:21,920
efficiency properties here if we choose

2289
01:28:21,920 --> 01:28:24,159
the matrix h more carefully and indeed a

2290
01:28:24,159 --> 01:28:25,840
certain line of works has been working

2291
01:28:25,840 --> 01:28:28,719
on exactly this question great so this

2292
01:28:28,719 --> 01:28:30,480
brings us to our you know choice of the

2293
01:28:30,480 --> 01:28:32,320
matrix h which leads us to the expand

2294
01:28:32,320 --> 01:28:34,239
accumulate codes

2295
01:28:34,239 --> 01:28:36,239
so after we choose h what we need is

2296
01:28:36,239 --> 01:28:38,639
that when we multiply it by a sparse

2297
01:28:38,639 --> 01:28:40,159
vector a random sparse vector it should

2298
01:28:40,159 --> 01:28:41,520
be computationally indistinguishable

2299
01:28:41,520 --> 01:28:43,040
from uniform you could think of this as

2300
01:28:43,040 --> 01:28:44,320
some sort of you know pseudorandom

2301
01:28:44,320 --> 01:28:46,239
generator type behavior because the

2302
01:28:46,239 --> 01:28:47,920
vector e if it's low weight is sort of a

2303
01:28:47,920 --> 01:28:50,000
low entropy seed that we want to make

2304
01:28:50,000 --> 01:28:52,080
look uniform

2305
01:28:52,080 --> 01:28:53,600
uh so

2306
01:28:53,600 --> 01:28:55,120
if we want this to be as efficiently

2307
01:28:55,120 --> 01:28:56,480
computable as possible

2308
01:28:56,480 --> 01:28:58,719
a very nice solution maybe would be just

2309
01:28:58,719 --> 01:29:01,120
to take h very very sparse

2310
01:29:01,120 --> 01:29:02,960
um say maybe it only has like 10

2311
01:29:02,960 --> 01:29:04,639
non-zeros per row and then you just need

2312
01:29:04,639 --> 01:29:05,679
to do you know

2313
01:29:05,679 --> 01:29:07,360
look up like 10 coordinates in e and sum

2314
01:29:07,360 --> 01:29:08,320
them up

2315
01:29:08,320 --> 01:29:10,080
but unfortunately uh it might not take

2316
01:29:10,080 --> 01:29:11,360
you too long to convince yourself that

2317
01:29:11,360 --> 01:29:12,480
then the problem then was that the

2318
01:29:12,480 --> 01:29:14,320
output of h times e will then also be

2319
01:29:14,320 --> 01:29:16,560
sparse right so if i take a dot product

2320
01:29:16,560 --> 01:29:17,600
between a sparse thing and another

2321
01:29:17,600 --> 01:29:19,199
sparse thing the output is going to be

2322
01:29:19,199 --> 01:29:21,120
biased towards zero so in particular i

2323
01:29:21,120 --> 01:29:23,760
can distinguish it from uniform

2324
01:29:23,760 --> 01:29:25,199
okay but in some sense what we do is

2325
01:29:25,199 --> 01:29:27,360
maybe sort of the simplest trick to sort

2326
01:29:27,360 --> 01:29:29,280
of make this work okay and what do i

2327
01:29:29,280 --> 01:29:30,560
mean in this sense

2328
01:29:30,560 --> 01:29:32,159
um let's again start with the sparse

2329
01:29:32,159 --> 01:29:33,600
matrix and let's look we're going to

2330
01:29:33,600 --> 01:29:35,199
sample it randomly so for concreteness

2331
01:29:35,199 --> 01:29:37,040
think of just you know making each entry

2332
01:29:37,040 --> 01:29:38,639
one with some probability p and we'll

2333
01:29:38,639 --> 01:29:41,199
choose p to be quite small

2334
01:29:41,199 --> 01:29:42,239
um

2335
01:29:42,239 --> 01:29:44,320
so this alone will not work but i'm

2336
01:29:44,320 --> 01:29:45,440
going to write multiply it by some

2337
01:29:45,440 --> 01:29:46,800
matrix that i'll call the accumulator

2338
01:29:46,800 --> 01:29:48,560
matrix okay and this is just a matrix

2339
01:29:48,560 --> 01:29:51,920
with ones on and above the main diagonal

2340
01:29:51,920 --> 01:29:52,960
and then just the product of these two

2341
01:29:52,960 --> 01:29:55,120
matrices will give us this matrix h that

2342
01:29:55,120 --> 01:29:57,280
we wanted and so in some sense we think

2343
01:29:57,280 --> 01:29:58,880
of this sparse matrix as an expansion

2344
01:29:58,880 --> 01:30:00,639
step and then the next uh this next

2345
01:30:00,639 --> 01:30:02,400
makes just a it's the accumulator matrix

2346
01:30:02,400 --> 01:30:04,000
so hence the name expand accumulate

2347
01:30:04,000 --> 01:30:04,960
codes

2348
01:30:04,960 --> 01:30:06,000
and now how should we think about this

2349
01:30:06,000 --> 01:30:08,000
accumulation step well if i put down a

2350
01:30:08,000 --> 01:30:10,480
sparse row in this sparse matrix here

2351
01:30:10,480 --> 01:30:12,400
what happens on the on the generator

2352
01:30:12,400 --> 01:30:13,600
matrix

2353
01:30:13,600 --> 01:30:15,040
basically the corresponding row will be

2354
01:30:15,040 --> 01:30:16,639
sort of a union of intervals where like

2355
01:30:16,639 --> 01:30:19,280
the endpoints are determined by the ones

2356
01:30:19,280 --> 01:30:21,120
in the sparse matrix because essentially

2357
01:30:21,120 --> 01:30:22,480
this accumulator matrix what it's really

2358
01:30:22,480 --> 01:30:24,239
doing when you do like a row multiplied

2359
01:30:24,239 --> 01:30:26,480
by this accumulator matrix it's just um

2360
01:30:26,480 --> 01:30:28,880
doing computing the prefix sum

2361
01:30:28,880 --> 01:30:30,000
right so it's just saying the first

2362
01:30:30,000 --> 01:30:31,840
coordinate is the sum of the first

2363
01:30:31,840 --> 01:30:33,040
coordinates itself the second chord is

2364
01:30:33,040 --> 01:30:34,080
some of the first two things the third

2365
01:30:34,080 --> 01:30:35,199
coordinates and some of the first three

2366
01:30:35,199 --> 01:30:37,280
things all and all this i'm doing modulo

2367
01:30:37,280 --> 01:30:39,920
two just for concreteness

2368
01:30:39,920 --> 01:30:41,040
okay

2369
01:30:41,040 --> 01:30:43,120
so this is the this is exactly how we

2370
01:30:43,120 --> 01:30:45,040
can go and construct our offline online

2371
01:30:45,040 --> 01:30:46,960
pcg from uh

2372
01:30:46,960 --> 01:30:48,480
using these codes

2373
01:30:48,480 --> 01:30:51,440
so just to put put everything together

2374
01:30:51,440 --> 01:30:53,360
so offline we're going to do this

2375
01:30:53,360 --> 01:30:55,520
accumulation step so this is you know

2376
01:30:55,520 --> 01:30:57,360
how we go from the seed which is you

2377
01:30:57,360 --> 01:30:58,800
know being represented by the sparse

2378
01:30:58,800 --> 01:31:00,320
vector here

2379
01:31:00,320 --> 01:31:01,360
we do

2380
01:31:01,360 --> 01:31:02,800
this accumulation step so we just

2381
01:31:02,800 --> 01:31:05,360
compute the prefix sum of this um i

2382
01:31:05,360 --> 01:31:06,880
guess here might be the suffix sum since

2383
01:31:06,880 --> 01:31:08,800
i'm doing it from the column now but any

2384
01:31:08,800 --> 01:31:10,320
case we do a very fast parallelizable

2385
01:31:10,320 --> 01:31:12,320
and cache friendly step so this is all

2386
01:31:12,320 --> 01:31:14,400
done before the protocol begins and then

2387
01:31:14,400 --> 01:31:16,480
when we do this online step

2388
01:31:16,480 --> 01:31:18,080
every time we need a new correlation we

2389
01:31:18,080 --> 01:31:19,520
basically just take one of the rows from

2390
01:31:19,520 --> 01:31:21,120
the sparse matrix and compute the dot

2391
01:31:21,120 --> 01:31:22,960
product with this offline material these

2392
01:31:22,960 --> 01:31:26,639
yas or yb's that we pre-computed

2393
01:31:26,639 --> 01:31:28,480
great so this already explains

2394
01:31:28,480 --> 01:31:30,159
our main construction but it leaves out

2395
01:31:30,159 --> 01:31:31,440
an important detail why should we

2396
01:31:31,440 --> 01:31:33,040
believe that this is computationally

2397
01:31:33,040 --> 01:31:34,639
indistinguishable from uniform why

2398
01:31:34,639 --> 01:31:35,840
should it be that all these bits that we

2399
01:31:35,840 --> 01:31:38,000
get once we do the sparse

2400
01:31:38,000 --> 01:31:40,000
vector multiplied by the accumulated

2401
01:31:40,000 --> 01:31:42,840
error vector that it should look uh

2402
01:31:42,840 --> 01:31:46,719
uniform okay so um in order to answer

2403
01:31:46,719 --> 01:31:48,400
this question you know the ideal thing

2404
01:31:48,400 --> 01:31:49,679
we would like to be able to say you know

2405
01:31:49,679 --> 01:31:51,600
reduce to some well-known problem i mean

2406
01:31:51,600 --> 01:31:52,880
the natural candidate here would be

2407
01:31:52,880 --> 01:31:54,000
something like learning parody with

2408
01:31:54,000 --> 01:31:56,880
noise uh alternatively what we do is

2409
01:31:56,880 --> 01:31:58,639
okay we can't necessarily reduce to this

2410
01:31:58,639 --> 01:32:01,120
known hard problem but we can rule out

2411
01:32:01,120 --> 01:32:03,679
sort of a broad class of attacks so i

2412
01:32:03,679 --> 01:32:05,760
hope i don't um say anything that

2413
01:32:05,760 --> 01:32:07,280
offends anyone too much in this audience

2414
01:32:07,280 --> 01:32:09,120
but i believe that's sort of most of

2415
01:32:09,120 --> 01:32:10,639
almost all of the attacks that would be

2416
01:32:10,639 --> 01:32:12,480
relevant to the sort of setup that we

2417
01:32:12,480 --> 01:32:14,480
have boiled down to this following

2418
01:32:14,480 --> 01:32:15,600
strategy

2419
01:32:15,600 --> 01:32:17,520
where basically you look for some vector

2420
01:32:17,520 --> 01:32:19,520
some row vector now and left multiply it

2421
01:32:19,520 --> 01:32:21,679
by your matrix h so we call the matrix h

2422
01:32:21,679 --> 01:32:23,920
is public so your adversary can look at

2423
01:32:23,920 --> 01:32:25,520
this and find this what i'll call an

2424
01:32:25,520 --> 01:32:27,760
attack vector x and then basically when

2425
01:32:27,760 --> 01:32:29,760
it's given a sample y which is either

2426
01:32:29,760 --> 01:32:31,920
uniformly random or of the form h times

2427
01:32:31,920 --> 01:32:33,840
e it'll just compute this dot product

2428
01:32:33,840 --> 01:32:35,600
and the point now is that if x transpose

2429
01:32:35,600 --> 01:32:37,280
h we're sparse

2430
01:32:37,280 --> 01:32:39,679
then in the case where y is in the form

2431
01:32:39,679 --> 01:32:42,080
h times e then that inner product will

2432
01:32:42,080 --> 01:32:43,440
again be biased towards zero because

2433
01:32:43,440 --> 01:32:45,199
you'll end up with a sparse vector inner

2434
01:32:45,199 --> 01:32:46,960
product with a sparse vector so that

2435
01:32:46,960 --> 01:32:49,199
will be biased towards uh zero but if

2436
01:32:49,199 --> 01:32:51,440
it's uniformly random this will be um

2437
01:32:51,440 --> 01:32:53,600
you know an unbiased bit and so this has

2438
01:32:53,600 --> 01:32:55,760
been termed the linear test framework

2439
01:32:55,760 --> 01:32:57,840
okay so this is these are the sorts of

2440
01:32:57,840 --> 01:33:00,400
of attacks that we're going to rule out

2441
01:33:00,400 --> 01:33:01,920
and so how can we actually do this well

2442
01:33:01,920 --> 01:33:03,280
it turns out which if you think

2443
01:33:03,280 --> 01:33:04,719
carefully about what the what the test

2444
01:33:04,719 --> 01:33:06,400
does all we really need to say is that

2445
01:33:06,400 --> 01:33:07,360
they're no

2446
01:33:07,360 --> 01:33:09,600
low weight non-zero vectors and what

2447
01:33:09,600 --> 01:33:11,040
i'll call a code now the set of all

2448
01:33:11,040 --> 01:33:13,280
elements of the form x transpose h so

2449
01:33:13,280 --> 01:33:14,960
from a coding theoretical perspective

2450
01:33:14,960 --> 01:33:16,719
this is now just a code and we want to

2451
01:33:16,719 --> 01:33:18,560
show that it has good minimum distance

2452
01:33:18,560 --> 01:33:19,840
so this is sort of a classic problem

2453
01:33:19,840 --> 01:33:21,040
from a coding theory perspective

2454
01:33:21,040 --> 01:33:22,719
although for a new class of codes and

2455
01:33:22,719 --> 01:33:24,320
essentially that's um that's exactly

2456
01:33:24,320 --> 01:33:25,440
what we do

2457
01:33:25,440 --> 01:33:27,520
we rule out linear attacks by say just

2458
01:33:27,520 --> 01:33:29,360
to give a sample of the parameters once

2459
01:33:29,360 --> 01:33:32,000
the density is roughly log n over n

2460
01:33:32,000 --> 01:33:34,000
we'll get uh you know linear minimum

2461
01:33:34,000 --> 01:33:37,040
distance with uh inverse polynomial

2462
01:33:37,040 --> 01:33:38,880
inverse polynomial failure probability

2463
01:33:38,880 --> 01:33:39,920
if you're really unhappy with the

2464
01:33:39,920 --> 01:33:41,679
inverse polynomial failure probability

2465
01:33:41,679 --> 01:33:44,080
you could say take log squared n over n

2466
01:33:44,080 --> 01:33:46,080
um but to be perfectly frank we're most

2467
01:33:46,080 --> 01:33:47,199
mostly interested in getting you know

2468
01:33:47,199 --> 01:33:48,800
very good concrete performance so the

2469
01:33:48,800 --> 01:33:50,880
precise you know asymptotic parameters

2470
01:33:50,880 --> 01:33:53,760
um you can play with as you like

2471
01:33:53,760 --> 01:33:54,960
um

2472
01:33:54,960 --> 01:33:57,040
good um so unfortunately i don't think i

2473
01:33:57,040 --> 01:33:58,080
really have time to dive into the

2474
01:33:58,080 --> 01:34:00,000
details of how we prove this if you do

2475
01:34:00,000 --> 01:34:01,360
have any questions on this topic i'd be

2476
01:34:01,360 --> 01:34:02,480
more than happy to answer them later

2477
01:34:02,480 --> 01:34:04,080
offline or of course the details are on

2478
01:34:04,080 --> 01:34:05,040
the paper

2479
01:34:05,040 --> 01:34:07,600
um but now just with um

2480
01:34:07,600 --> 01:34:08,800
my remaining time i'd like to say a bit

2481
01:34:08,800 --> 01:34:10,880
more about the concrete efficiency

2482
01:34:10,880 --> 01:34:12,080
since that is really sort of the goal

2483
01:34:12,080 --> 01:34:14,639
here is to get concretely efficient pcgs

2484
01:34:14,639 --> 01:34:17,040
so in the offline phase um this is these

2485
01:34:17,040 --> 01:34:18,080
are all some estimates but it should

2486
01:34:18,080 --> 01:34:20,080
take about 100 milliseconds to generate

2487
01:34:20,080 --> 01:34:21,679
offline material for about 10 million

2488
01:34:21,679 --> 01:34:23,760
ots and since these prefix sum

2489
01:34:23,760 --> 01:34:25,280
operations are very easily done in

2490
01:34:25,280 --> 01:34:27,120
parallel we can get sort of a factor k

2491
01:34:27,120 --> 01:34:28,960
speed up as soon as k processors are

2492
01:34:28,960 --> 01:34:30,719
available

2493
01:34:30,719 --> 01:34:32,480
okay and now on the online phase so

2494
01:34:32,480 --> 01:34:34,800
theoretically um it seems like you know

2495
01:34:34,800 --> 01:34:36,960
for reasonable parameters 428 bits of

2496
01:34:36,960 --> 01:34:39,199
security it should take about 40 lookups

2497
01:34:39,199 --> 01:34:40,560
so that's basically the density of all

2498
01:34:40,560 --> 01:34:41,920
the rows that we need to do the inner

2499
01:34:41,920 --> 01:34:43,760
product with plus this additional hash

2500
01:34:43,760 --> 01:34:47,199
operation to get the the ots um now if

2501
01:34:47,199 --> 01:34:49,040
we want to be very aggressive you know

2502
01:34:49,040 --> 01:34:50,560
based on some experimental evidence we

2503
01:34:50,560 --> 01:34:51,840
think that it might even be feasible to

2504
01:34:51,840 --> 01:34:53,360
have a much smaller number of lookups

2505
01:34:53,360 --> 01:34:55,760
even seven so the intuition here is that

2506
01:34:55,760 --> 01:34:57,600
okay so for this linear test framework

2507
01:34:57,600 --> 01:34:59,679
basically um the adversary's supposed to

2508
01:34:59,679 --> 01:35:01,119
look at the matrix h then come up with

2509
01:35:01,119 --> 01:35:03,679
this vector this attack vector for which

2510
01:35:03,679 --> 01:35:06,159
x transpose h is sparse

2511
01:35:06,159 --> 01:35:07,920
um in principle though if we just want

2512
01:35:07,920 --> 01:35:09,520
computational security i mean we could

2513
01:35:09,520 --> 01:35:10,880
say that maybe it's hard to find such an

2514
01:35:10,880 --> 01:35:13,199
attack vector and basically uh we don't

2515
01:35:13,199 --> 01:35:14,719
know how to find an attack vector once

2516
01:35:14,719 --> 01:35:17,040
you know the density is say like seven

2517
01:35:17,040 --> 01:35:18,880
okay but this is of course very

2518
01:35:18,880 --> 01:35:20,320
conjectural at this point and i think

2519
01:35:20,320 --> 01:35:21,760
this definitely merits uh further

2520
01:35:21,760 --> 01:35:24,080
cryptanalysis

2521
01:35:24,080 --> 01:35:26,000
okay so just to sort of recap what we

2522
01:35:26,000 --> 01:35:27,760
did here we talked about expand

2523
01:35:27,760 --> 01:35:30,239
accumulate codes which had a highly uh

2524
01:35:30,239 --> 01:35:32,880
highly parallel parallelizable online

2525
01:35:32,880 --> 01:35:35,040
phase sorry offline phase which is also

2526
01:35:35,040 --> 01:35:37,040
cache friendly and also the online phase

2527
01:35:37,040 --> 01:35:39,360
had low output locality and now just to

2528
01:35:39,360 --> 01:35:40,800
compare to some sort of competing

2529
01:35:40,800 --> 01:35:43,040
approaches here there was a recent

2530
01:35:43,040 --> 01:35:44,000
result

2531
01:35:44,000 --> 01:35:45,920
a proposal called silver

2532
01:35:45,920 --> 01:35:46,960
which basically lacks the

2533
01:35:46,960 --> 01:35:49,440
parallelizability of our proposal also

2534
01:35:49,440 --> 01:35:51,440
this um this one didn't really come with

2535
01:35:51,440 --> 01:35:52,880
a theoretical analysis that came with

2536
01:35:52,880 --> 01:35:53,920
you know very rigorous sort of

2537
01:35:53,920 --> 01:35:56,320
experimental analysis but still uh

2538
01:35:56,320 --> 01:35:57,600
doesn't have the theoretical analysis

2539
01:35:57,600 --> 01:35:59,119
that our proposal has there are also

2540
01:35:59,119 --> 01:36:00,320
these codes which are called repeat

2541
01:36:00,320 --> 01:36:01,920
accumulate accumulate codes so they have

2542
01:36:01,920 --> 01:36:03,600
two accumulation steps which sort of

2543
01:36:03,600 --> 01:36:05,600
kills the cache friendliness um so they

2544
01:36:05,600 --> 01:36:07,760
don't have the nice properties that we

2545
01:36:07,760 --> 01:36:09,119
have although i should say that you know

2546
01:36:09,119 --> 01:36:10,560
our construction to expand accumulate

2547
01:36:10,560 --> 01:36:12,320
codes was very much inspired by these

2548
01:36:12,320 --> 01:36:13,760
sorts of codes

2549
01:36:13,760 --> 01:36:15,760
uh so yeah so that's sort of the status

2550
01:36:15,760 --> 01:36:17,520
of things and i guess i don't have too

2551
01:36:17,520 --> 01:36:19,360
much time left and i don't want to keep

2552
01:36:19,360 --> 01:36:21,040
you uh too late especially since this is

2553
01:36:21,040 --> 01:36:23,360
the last session but i'll try to hint at

2554
01:36:23,360 --> 01:36:25,440
some further results because this is uh

2555
01:36:25,440 --> 01:36:26,800
not everything that we do so first of

2556
01:36:26,800 --> 01:36:28,560
all we do also construct a pseudo-random

2557
01:36:28,560 --> 01:36:30,159
correlation functions that was another

2558
01:36:30,159 --> 01:36:32,000
one of our contributions um the real

2559
01:36:32,000 --> 01:36:34,239
challenge here is that basically um

2560
01:36:34,239 --> 01:36:35,440
recall we need to sort of create an

2561
01:36:35,440 --> 01:36:38,000
exponentially long vector of you know of

2562
01:36:38,000 --> 01:36:39,600
correlations that we can access so in

2563
01:36:39,600 --> 01:36:41,600
particular say if this error vector is

2564
01:36:41,600 --> 01:36:43,119
exponentially long we're not going to be

2565
01:36:43,119 --> 01:36:44,480
able to compute this accumulation step

2566
01:36:44,480 --> 01:36:45,760
even storing it

2567
01:36:45,760 --> 01:36:47,600
it's far too expensive

2568
01:36:47,600 --> 01:36:49,280
but what can we do instead well we can

2569
01:36:49,280 --> 01:36:51,119
look at actually what

2570
01:36:51,119 --> 01:36:53,679
a times e looks like and try to directly

2571
01:36:53,679 --> 01:36:55,040
function secret share it instead of

2572
01:36:55,040 --> 01:36:56,960
function secret sharing the vector e we

2573
01:36:56,960 --> 01:36:58,239
can function secret share the

2574
01:36:58,239 --> 01:37:00,719
accumulated vector a times e and now it

2575
01:37:00,719 --> 01:37:02,080
turns out once again you know this is

2576
01:37:02,080 --> 01:37:03,679
some sort of i think it's now suffix sum

2577
01:37:03,679 --> 01:37:05,760
assuming i did make a mistake here um

2578
01:37:05,760 --> 01:37:07,679
you know it's some sort of vector which

2579
01:37:07,679 --> 01:37:09,360
looks like this which we could think of

2580
01:37:09,360 --> 01:37:12,000
some sort of you know interval function

2581
01:37:12,000 --> 01:37:13,440
or a small sum of what i'll call

2582
01:37:13,440 --> 01:37:15,679
comparison functions which are just

2583
01:37:15,679 --> 01:37:17,360
functions that you know take a non-zero

2584
01:37:17,360 --> 01:37:19,280
value below a certain cut off y and then

2585
01:37:19,280 --> 01:37:22,000
our zero above the cutoff y or even you

2586
01:37:22,000 --> 01:37:24,400
know the inverse of that

2587
01:37:24,400 --> 01:37:26,320
and fortunately for us there exists you

2588
01:37:26,320 --> 01:37:27,040
know

2589
01:37:27,040 --> 01:37:28,880
efficient fss schemes for these sorts of

2590
01:37:28,880 --> 01:37:30,400
comparison functions we can actually

2591
01:37:30,400 --> 01:37:32,880
even use a relaxed variant because

2592
01:37:32,880 --> 01:37:34,400
one of the parties i guess alice gets to

2593
01:37:34,400 --> 01:37:36,480
know the value y so this allows it some

2594
01:37:36,480 --> 01:37:38,719
savings but essentially we can um we can

2595
01:37:38,719 --> 01:37:40,400
do some sort of function secret sharing

2596
01:37:40,400 --> 01:37:42,719
to get a to get a full um pcf

2597
01:37:42,719 --> 01:37:45,280
construction and we can even get pcs for

2598
01:37:45,280 --> 01:37:47,600
some other sort of correlations like

2599
01:37:47,600 --> 01:37:49,679
general degree two correlations there we

2600
01:37:49,679 --> 01:37:51,440
need to share kind of two-dimensional

2601
01:37:51,440 --> 01:37:53,040
interval functions so like a product of

2602
01:37:53,040 --> 01:37:55,199
these two comparison functions but in

2603
01:37:55,199 --> 01:37:56,239
any case

2604
01:37:56,239 --> 01:37:57,360
all these details are available in the

2605
01:37:57,360 --> 01:37:58,639
paper

2606
01:37:58,639 --> 01:38:00,000
all right we have one more contribution

2607
01:38:00,000 --> 01:38:02,400
which is very um disjoint and orthogonal

2608
01:38:02,400 --> 01:38:04,239
to everything i said thus far so i'll

2609
01:38:04,239 --> 01:38:06,719
try to briefly hint at it um but this

2610
01:38:06,719 --> 01:38:08,560
might be a bit of you know

2611
01:38:08,560 --> 01:38:11,840
a change in tone um so in this offline

2612
01:38:11,840 --> 01:38:14,239
uh the offline step basically you know

2613
01:38:14,239 --> 01:38:16,000
we do this function secret sharing for

2614
01:38:16,000 --> 01:38:16,880
um

2615
01:38:16,880 --> 01:38:19,040
for this you know vector b times e

2616
01:38:19,040 --> 01:38:20,800
and then we need to expand them out into

2617
01:38:20,800 --> 01:38:22,560
the two additive sharings c naught and c

2618
01:38:22,560 --> 01:38:24,320
one which corresponds to doing some sort

2619
01:38:24,320 --> 01:38:26,639
of eval all operation you know we need

2620
01:38:26,639 --> 01:38:28,400
to evaluate all of the different um

2621
01:38:28,400 --> 01:38:30,719
secret sharings of your function and it

2622
01:38:30,719 --> 01:38:32,400
turns out that these functions all these

2623
01:38:32,400 --> 01:38:34,480
fss schemes are built from punctured prf

2624
01:38:34,480 --> 01:38:36,880
and in order to do this about all step

2625
01:38:36,880 --> 01:38:38,400
um you know hand waving a lot here

2626
01:38:38,400 --> 01:38:39,920
basically the bulk of the work is to

2627
01:38:39,920 --> 01:38:41,920
compute an entire gdm tree so this sort

2628
01:38:41,920 --> 01:38:42,960
of structure where you have the key at

2629
01:38:42,960 --> 01:38:44,560
the top and then you go down the tree

2630
01:38:44,560 --> 01:38:46,639
and the left child is h naught of the

2631
01:38:46,639 --> 01:38:48,320
parent and the right child is h1 of the

2632
01:38:48,320 --> 01:38:50,239
of the parent

2633
01:38:50,239 --> 01:38:52,239
okay so in order to sort of save on hash

2634
01:38:52,239 --> 01:38:54,239
calls we propose the following sort of

2635
01:38:54,239 --> 01:38:56,719
uh sort of modification where instead of

2636
01:38:56,719 --> 01:38:59,600
um doing independent hash calls on both

2637
01:38:59,600 --> 01:39:01,600
the children you could do you could call

2638
01:39:01,600 --> 01:39:03,119
the hash for the left child and then for

2639
01:39:03,119 --> 01:39:04,400
the right child you call the hash again

2640
01:39:04,400 --> 01:39:05,520
on the parent and then you absorb it

2641
01:39:05,520 --> 01:39:07,520
with the value of the parent

2642
01:39:07,520 --> 01:39:09,040
um so

2643
01:39:09,040 --> 01:39:11,280
this will unfortunately not yield a

2644
01:39:11,280 --> 01:39:12,719
genuine punctured prf it's not too

2645
01:39:12,719 --> 01:39:14,480
difficult to see that sort of

2646
01:39:14,480 --> 01:39:15,679
yeah a certain value which is supposed

2647
01:39:15,679 --> 01:39:17,760
to be indistinguishable from uniform is

2648
01:39:17,760 --> 01:39:19,199
distinguishable from uniform but it's

2649
01:39:19,199 --> 01:39:21,280
still unpredictable in a certain sense

2650
01:39:21,280 --> 01:39:22,880
so this already gives us something which

2651
01:39:22,880 --> 01:39:26,159
can be used to say construct pcgs for

2652
01:39:26,159 --> 01:39:28,239
for ots but and if but if you want a

2653
01:39:28,239 --> 01:39:30,800
genuine um punctured prf you just need

2654
01:39:30,800 --> 01:39:32,639
one additional hashing layer so we

2655
01:39:32,639 --> 01:39:33,760
talked sort of a lot about the different

2656
01:39:33,760 --> 01:39:34,880
sort of trade-offs that you could hope

2657
01:39:34,880 --> 01:39:35,760
to do

2658
01:39:35,760 --> 01:39:37,520
in this offline stage in the paper

2659
01:39:37,520 --> 01:39:39,280
including potentially changing the arity

2660
01:39:39,280 --> 01:39:40,880
of the ggm tree if you want some other

2661
01:39:40,880 --> 01:39:43,360
savings but um this is all

2662
01:39:43,360 --> 01:39:44,800
and also i should say this is the

2663
01:39:44,800 --> 01:39:46,000
proposal that sort of works in the

2664
01:39:46,000 --> 01:39:48,159
random oracle model if the ideal cipher

2665
01:39:48,159 --> 01:39:49,840
model we have a proposal with that lack

2666
01:39:49,840 --> 01:39:51,920
some theoretical analysis although for

2667
01:39:51,920 --> 01:39:53,600
the random oracle model we do have

2668
01:39:53,600 --> 01:39:55,360
theoretical analysis

2669
01:39:55,360 --> 01:39:57,119
okay i believe i'm over time so allow me

2670
01:39:57,119 --> 01:39:59,119
to quickly recap so we talked about uh

2671
01:39:59,119 --> 01:40:01,199
generating correlations in particular we

2672
01:40:01,199 --> 01:40:02,560
talked about this sort of volley box

2673
01:40:02,560 --> 01:40:04,480
that we hope to instantiate

2674
01:40:04,480 --> 01:40:06,719
and um the way we both do this was by

2675
01:40:06,719 --> 01:40:09,119
these offline online pcgs this is the

2676
01:40:09,119 --> 01:40:11,360
picture to keep in mind um the sort of

2677
01:40:11,360 --> 01:40:12,880
the special class of codes that allowed

2678
01:40:12,880 --> 01:40:14,000
us to get our construction with these

2679
01:40:14,000 --> 01:40:15,840
expand accumulate codes and we gave some

2680
01:40:15,840 --> 01:40:17,520
sort of theoretical analysis to show

2681
01:40:17,520 --> 01:40:19,520
that they do in some sense

2682
01:40:19,520 --> 01:40:21,040
you know the

2683
01:40:21,040 --> 01:40:23,360
basically provide a prg at least

2684
01:40:23,360 --> 01:40:25,920
according against the class of attacks

2685
01:40:25,920 --> 01:40:27,119
and then we had a few other results that

2686
01:40:27,119 --> 01:40:29,119
i've really sketched at the end all

2687
01:40:29,119 --> 01:40:30,960
right uh thank you very much and oh i

2688
01:40:30,960 --> 01:40:34,920
guess that's the end thank you

2689
01:40:40,000 --> 01:40:42,800
uh any question

2690
01:40:45,199 --> 01:40:47,920
okay uh maybe i can ask a question here

2691
01:40:47,920 --> 01:40:49,840
so you mentioned that in the offline

2692
01:40:49,840 --> 01:40:50,880
phase it

2693
01:40:50,880 --> 01:40:52,719
it is catch friendly and the online

2694
01:40:52,719 --> 01:40:54,719
phase you need to give a random access

2695
01:40:54,719 --> 01:40:56,400
does that mean that

2696
01:40:56,400 --> 01:40:58,320
the output of the offline phase is

2697
01:40:58,320 --> 01:41:00,159
actually something

2698
01:41:00,159 --> 01:41:02,880
linear to the number of voi that you

2699
01:41:02,880 --> 01:41:04,560
need to generate

2700
01:41:04,560 --> 01:41:06,960
uh sorry linear and what linear in the

2701
01:41:06,960 --> 01:41:09,199
number of way that you need to generate

2702
01:41:09,199 --> 01:41:11,440
the the off the online phase the offline

2703
01:41:11,440 --> 01:41:13,040
phase the output of the offline things

2704
01:41:13,040 --> 01:41:14,560
it will be yeah so for the pcg

2705
01:41:14,560 --> 01:41:17,040
construction yeah but basically you can

2706
01:41:17,040 --> 01:41:18,560
you can parallelize a lot of the work

2707
01:41:18,560 --> 01:41:19,600
because essentially you need to

2708
01:41:19,600 --> 01:41:20,639
accumulate

2709
01:41:20,639 --> 01:41:22,639
the vector that you accumulate will be

2710
01:41:22,639 --> 01:41:24,480
sort of linear but the length of it will

2711
01:41:24,480 --> 01:41:26,080
be linear in the number of ots you want

2712
01:41:26,080 --> 01:41:28,800
to generate um i think like maybe like

2713
01:41:28,800 --> 01:41:30,560
five times longer i think is a certain

2714
01:41:30,560 --> 01:41:33,440
proposal we have and then um

2715
01:41:33,440 --> 01:41:35,679
yes from there so once you yeah so that

2716
01:41:35,679 --> 01:41:37,280
step will be um

2717
01:41:37,280 --> 01:41:38,960
linear and the number of these yeah i

2718
01:41:38,960 --> 01:41:41,280
see so so the seed generation is

2719
01:41:41,280 --> 01:41:42,880
probably like a first part of the

2720
01:41:42,880 --> 01:41:45,360
offline phase yeah yeah oh yeah so

2721
01:41:45,360 --> 01:41:46,639
essentially something i was kind of

2722
01:41:46,639 --> 01:41:48,159
skipping was basically you know we

2723
01:41:48,159 --> 01:41:49,760
compressed everything down to short

2724
01:41:49,760 --> 01:41:51,440
seeds you know basically to share the

2725
01:41:51,440 --> 01:41:54,159
keys for the fss and maybe a tiny bit of

2726
01:41:54,159 --> 01:41:56,000
other material but this you can just use

2727
01:41:56,000 --> 01:41:57,760
some sort of inefficient mpc protocol to

2728
01:41:57,760 --> 01:41:59,360
share because it's so small that you

2729
01:41:59,360 --> 01:42:00,880
know even if it's inefficient in the

2730
01:42:00,880 --> 01:42:02,239
size that you the amount of material you

2731
01:42:02,239 --> 01:42:03,840
just share it's so small that it's the

2732
01:42:03,840 --> 01:42:05,920
material yeah or asymptotically

2733
01:42:05,920 --> 01:42:08,480
negligible

2734
01:42:09,440 --> 01:42:12,960
uh any other question

2735
01:42:12,960 --> 01:42:15,040
accept my question

2736
01:42:15,040 --> 01:42:19,199
okay let's uh thank the speaker again

2737
01:42:23,280 --> 01:42:26,000
yeah so so there will be no talk in this

2738
01:42:26,000 --> 01:42:27,199
room

2739
01:42:27,199 --> 01:42:29,119
everything else this afternoon is on the

2740
01:42:29,119 --> 01:42:30,880
other side except the rom session which

2741
01:42:30,880 --> 01:42:33,119
is very

