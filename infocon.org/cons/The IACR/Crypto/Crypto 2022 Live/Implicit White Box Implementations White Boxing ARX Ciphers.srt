1
00:00:11,519 --> 00:00:14,519
wow

2
00:00:17,920 --> 00:00:19,279
okay

3
00:00:19,279 --> 00:00:22,000
so my name is adrian rania and in this

4
00:00:22,000 --> 00:00:24,480
talk i will present inclusive web box

5
00:00:24,480 --> 00:00:27,680
implementation by boxing erxsive which

6
00:00:27,680 --> 00:00:31,519
is a joint work with wakima vocabulary

7
00:00:31,840 --> 00:00:32,880
so

8
00:00:32,880 --> 00:00:34,559
traditionally

9
00:00:34,559 --> 00:00:36,800
in cryptography we design algorithms to

10
00:00:36,800 --> 00:00:38,640
be secure in the blackbox model that

11
00:00:38,640 --> 00:00:40,719
means that we assume that the attacker

12
00:00:40,719 --> 00:00:42,719
can tamper with the input and output of

13
00:00:42,719 --> 00:00:45,200
the algorithms but this is not the case

14
00:00:45,200 --> 00:00:47,440
it's no real-world scenarios

15
00:00:47,440 --> 00:00:49,600
where the attacker can also tamper with

16
00:00:49,600 --> 00:00:51,840
internal information of the primitive

17
00:00:51,840 --> 00:00:54,239
and the worst case scenario is captured

18
00:00:54,239 --> 00:00:56,800
by the ybox model where the attacker is

19
00:00:56,800 --> 00:00:59,120
assumed to have full control on the

20
00:00:59,120 --> 00:01:01,120
device running the cryptocomputation

21
00:01:01,120 --> 00:01:03,520
that means that the bursary can observe

22
00:01:03,520 --> 00:01:05,920
without noise and modify

23
00:01:05,920 --> 00:01:07,920
all intimate values during the execution

24
00:01:07,920 --> 00:01:09,760
of the algorithm

25
00:01:09,760 --> 00:01:11,600
and this for example captures an

26
00:01:11,600 --> 00:01:14,560
attacker that attach a debugger to the

27
00:01:14,560 --> 00:01:17,119
software implementation and then can

28
00:01:17,119 --> 00:01:19,920
intercept consistent calls or read or

29
00:01:19,920 --> 00:01:21,439
tamper with

30
00:01:21,439 --> 00:01:22,960
this window for you

31
00:01:22,960 --> 00:01:25,759
okay perfect

32
00:01:27,600 --> 00:01:28,960
and

33
00:01:28,960 --> 00:01:31,840
values in the memory or in the register

34
00:01:31,840 --> 00:01:34,640
and why box cryptography is the field of

35
00:01:34,640 --> 00:01:36,960
cryptography that studies

36
00:01:36,960 --> 00:01:39,119
catastrophic content measures to secure

37
00:01:39,119 --> 00:01:41,680
software implementation of primitive in

38
00:01:41,680 --> 00:01:44,159
the white box model why bus cryptography

39
00:01:44,159 --> 00:01:47,200
was originally designed for drm and

40
00:01:47,200 --> 00:01:48,960
digital rights management or the

41
00:01:48,960 --> 00:01:51,360
protection of digital media since in

42
00:01:51,360 --> 00:01:52,720
this case

43
00:01:52,720 --> 00:01:54,640
the consumer could be considered in some

44
00:01:54,640 --> 00:01:57,040
cases a malicious endpoint but right now

45
00:01:57,040 --> 00:01:59,439
web scriptural fee is also being used in

46
00:01:59,439 --> 00:02:01,439
other applications such as mobile

47
00:02:01,439 --> 00:02:03,439
payments and in general other

48
00:02:03,439 --> 00:02:06,079
applications where one is deploying a

49
00:02:06,079 --> 00:02:08,479
sensitive traffic implementation in an

50
00:02:08,479 --> 00:02:10,000
untranslated environment

51
00:02:10,000 --> 00:02:12,879
such as a smartphone

52
00:02:12,879 --> 00:02:14,560
and

53
00:02:14,560 --> 00:02:16,480
white box implementation are the

54
00:02:16,480 --> 00:02:18,319
software implementations that are

55
00:02:18,319 --> 00:02:21,440
designed to prevent white voxel attacks

56
00:02:21,440 --> 00:02:24,160
in academia mostly all implementation

57
00:02:24,160 --> 00:02:27,040
are fixed implementations that mean that

58
00:02:27,040 --> 00:02:29,599
the key of the cypher is hidden and hard

59
00:02:29,599 --> 00:02:31,680
code in implementation and is not an

60
00:02:31,680 --> 00:02:33,360
input of it

61
00:02:33,360 --> 00:02:35,599
thus to build a physical implementation

62
00:02:35,599 --> 00:02:38,080
you need a whitebox method or a compiler

63
00:02:38,080 --> 00:02:40,879
that will take the key of the cipher and

64
00:02:40,879 --> 00:02:43,200
also some initial randomness and this

65
00:02:43,200 --> 00:02:45,200
will produce the software implementation

66
00:02:45,200 --> 00:02:47,680
the white box implementation

67
00:02:47,680 --> 00:02:50,640
in academia all weapons implementation

68
00:02:50,640 --> 00:02:53,120
of block ciphers and they have a method

69
00:02:53,120 --> 00:02:55,200
that is a public but that's not the case

70
00:02:55,200 --> 00:02:57,440
in some commercial implementation where

71
00:02:57,440 --> 00:02:59,519
they have a method that is not known and

72
00:02:59,519 --> 00:03:01,920
they rely on the secrecy of the compiler

73
00:03:01,920 --> 00:03:04,080
for the security but in this work we

74
00:03:04,080 --> 00:03:06,239
only focus on academic implementation

75
00:03:06,239 --> 00:03:08,640
where the method is public

76
00:03:08,640 --> 00:03:11,040
a white box attacker can have

77
00:03:11,040 --> 00:03:12,959
different goals this could be for

78
00:03:12,959 --> 00:03:14,480
example extracting the key of the

79
00:03:14,480 --> 00:03:16,640
implementation this could be copying the

80
00:03:16,640 --> 00:03:19,680
implementation to another device or even

81
00:03:19,680 --> 00:03:21,920
getting the decryption function of a web

82
00:03:21,920 --> 00:03:23,599
box implementation of the encryption

83
00:03:23,599 --> 00:03:24,560
function

84
00:03:24,560 --> 00:03:26,400
but here we focus on extraction

85
00:03:26,400 --> 00:03:28,640
resistance that is the minimum goal and

86
00:03:28,640 --> 00:03:31,440
what was representation should achieve

87
00:03:31,440 --> 00:03:33,280
and even achieving this goal is very

88
00:03:33,280 --> 00:03:34,879
ambitious and challenging because for

89
00:03:34,879 --> 00:03:37,200
example this implies that a webhost

90
00:03:37,200 --> 00:03:39,200
implementation should be secure against

91
00:03:39,200 --> 00:03:42,720
all side channels and full attacks

92
00:03:42,720 --> 00:03:45,040
and the first web box implementation of

93
00:03:45,040 --> 00:03:47,440
a block cipher that was proposed was a

94
00:03:47,440 --> 00:03:50,159
weapons implementation of aes by joe and

95
00:03:50,159 --> 00:03:51,200
others

96
00:03:51,200 --> 00:03:53,280
and since then many implementations have

97
00:03:53,280 --> 00:03:55,920
been proposed but mostly all of them are

98
00:03:55,920 --> 00:03:58,000
based on the same idea and now these

99
00:03:58,000 --> 00:04:00,480
implementations are called serial

100
00:04:00,480 --> 00:04:02,400
implementations so the idea of this

101
00:04:02,400 --> 00:04:05,120
implementation is first the cipher is

102
00:04:05,120 --> 00:04:07,439
decomposed into rounds

103
00:04:07,439 --> 00:04:10,640
then in each round we introduce random

104
00:04:10,640 --> 00:04:12,840
permutations that are called wrong

105
00:04:12,840 --> 00:04:16,079
encodings and to cancel the effect of

106
00:04:16,079 --> 00:04:17,440
these encodings

107
00:04:17,440 --> 00:04:19,440
the input and coding of the next round

108
00:04:19,440 --> 00:04:21,680
is chosen as the inverse of the output

109
00:04:21,680 --> 00:04:23,600
encoding of the previous round and this

110
00:04:23,600 --> 00:04:25,840
is done in all rounds

111
00:04:25,840 --> 00:04:28,639
and then the wrong encodings are merged

112
00:04:28,639 --> 00:04:30,880
with the wrong function and this creates

113
00:04:30,880 --> 00:04:33,680
the encode wrong functions

114
00:04:33,680 --> 00:04:35,919
the first and the last encoding are not

115
00:04:35,919 --> 00:04:37,759
cancelled they are called external

116
00:04:37,759 --> 00:04:38,800
encoding

117
00:04:38,800 --> 00:04:40,400
and they introduce some instability

118
00:04:40,400 --> 00:04:41,680
problems because they make the

119
00:04:41,680 --> 00:04:43,520
implementation not functionally

120
00:04:43,520 --> 00:04:45,680
equivalent to the underlying cipher but

121
00:04:45,680 --> 00:04:47,680
they are needed for security and without

122
00:04:47,680 --> 00:04:52,400
the c implementation are easy to break

123
00:04:52,639 --> 00:04:55,199
then to to build a implementation one is

124
00:04:55,199 --> 00:04:56,960
to choose the size of the wrong

125
00:04:56,960 --> 00:04:58,880
encodings and also

126
00:04:58,880 --> 00:05:01,600
to implement the encode rounds in a way

127
00:05:01,600 --> 00:05:03,120
that the ranking material cannot be

128
00:05:03,120 --> 00:05:05,120
extracted

129
00:05:05,120 --> 00:05:06,880
to choose the wrong encoding

130
00:05:06,880 --> 00:05:09,120
implementation they choose small

131
00:05:09,120 --> 00:05:11,680
nonlinear encodings and small

132
00:05:11,680 --> 00:05:13,759
linear functions for example in the

133
00:05:13,759 --> 00:05:16,240
initial ybox as implementation they

134
00:05:16,240 --> 00:05:18,720
chose four bit normal encodings and made

135
00:05:18,720 --> 00:05:20,560
with linear encodings

136
00:05:20,560 --> 00:05:22,720
and to implement the encode rounds the

137
00:05:22,720 --> 00:05:25,360
idea is to decompose the rounds into a

138
00:05:25,360 --> 00:05:27,919
smaller or into smaller operations

139
00:05:27,919 --> 00:05:30,240
represent each operation as a look at

140
00:05:30,240 --> 00:05:33,039
table and then merge the iranian coins

141
00:05:33,039 --> 00:05:34,479
with the look at things and also

142
00:05:34,479 --> 00:05:36,800
introduce some intermediate encodings to

143
00:05:36,800 --> 00:05:39,440
protect the intermediate look at things

144
00:05:39,440 --> 00:05:42,080
so in the end each each round is a

145
00:05:42,080 --> 00:05:44,000
network of look at table and they are

146
00:05:44,000 --> 00:05:47,759
implemented in software like this

147
00:05:47,759 --> 00:05:50,000
the security here the dji is that the

148
00:05:50,000 --> 00:05:52,160
ranking material is hidden in some look

149
00:05:52,160 --> 00:05:54,479
at tables these tables are protected by

150
00:05:54,479 --> 00:05:57,120
roman codings ideally the larger the

151
00:05:57,120 --> 00:05:58,880
encoding is the better for the security

152
00:05:58,880 --> 00:06:00,960
but the encodings need to be small

153
00:06:00,960 --> 00:06:02,400
because they need to match the size of

154
00:06:02,400 --> 00:06:04,240
the lookup table and just look at they

155
00:06:04,240 --> 00:06:06,400
will have exponential size the size of

156
00:06:06,400 --> 00:06:08,319
the encodings is very limited for

157
00:06:08,319 --> 00:06:10,479
example in the initial implementation

158
00:06:10,479 --> 00:06:13,440
they use mainly a bit look at table and

159
00:06:13,440 --> 00:06:15,440
the size of that implementation was

160
00:06:15,440 --> 00:06:18,000
around one megabyte

161
00:06:18,000 --> 00:06:20,240
this initial implementation was broken

162
00:06:20,240 --> 00:06:21,840
and since then many implementations have

163
00:06:21,840 --> 00:06:24,479
been proposed but in the end all of them

164
00:06:24,479 --> 00:06:26,720
have been broken

165
00:06:26,720 --> 00:06:30,080
the only other method that has been

166
00:06:30,080 --> 00:06:31,680
proposed in academia is the

167
00:06:31,680 --> 00:06:33,840
self-equivalence framework that is based

168
00:06:33,840 --> 00:06:35,280
on the idea of

169
00:06:35,280 --> 00:06:37,440
equivalence as if equivalent of a

170
00:06:37,440 --> 00:06:39,919
function

171
00:06:40,319 --> 00:06:42,319
as materials of a function s is a

172
00:06:42,319 --> 00:06:44,400
parallel mutation a and b that when

173
00:06:44,400 --> 00:06:46,479
composed to this function s the same

174
00:06:46,479 --> 00:06:49,280
function is obtained so as for cabling

175
00:06:49,280 --> 00:06:51,360
is a pair of permutation that they

176
00:06:51,360 --> 00:06:53,280
cancel each other following this

177
00:06:53,280 --> 00:06:54,880
cancellation rule

178
00:06:54,880 --> 00:06:57,280
and a self-equipment implementation also

179
00:06:57,280 --> 00:06:59,199
use this idea of and called wrong

180
00:06:59,199 --> 00:07:02,240
functions but here the roman codings are

181
00:07:02,240 --> 00:07:04,960
self-equivalent of the x-box layers and

182
00:07:04,960 --> 00:07:07,280
the wrong columns are not merged with

183
00:07:07,280 --> 00:07:09,199
the whole wrong function but they're

184
00:07:09,199 --> 00:07:11,440
only merged with a fine layer containing

185
00:07:11,440 --> 00:07:13,840
the wrong key material and this creates

186
00:07:13,840 --> 00:07:16,479
the encodifying layers

187
00:07:16,479 --> 00:07:18,400
the advantages of this type of

188
00:07:18,400 --> 00:07:20,400
implementation is that the encode

189
00:07:20,400 --> 00:07:22,639
defined layers can be implemented with a

190
00:07:22,639 --> 00:07:25,599
matrices so no lookup tables are needed

191
00:07:25,599 --> 00:07:26,800
that means that

192
00:07:26,800 --> 00:07:30,000
if the xbox layer or the nonlinear layer

193
00:07:30,000 --> 00:07:32,319
have large self-equivalence then this

194
00:07:32,319 --> 00:07:34,240
type of implementation can use large

195
00:07:34,240 --> 00:07:36,639
importance another advantage is that

196
00:07:36,639 --> 00:07:38,800
previous attacks have shown

197
00:07:38,800 --> 00:07:41,520
that cg implementation can be reduced to

198
00:07:41,520 --> 00:07:43,360
self-equivalence implementation that

199
00:07:43,360 --> 00:07:45,520
means that an attacker could transform

200
00:07:45,520 --> 00:07:47,280
the implementation to a self-equivalence

201
00:07:47,280 --> 00:07:49,440
one but the opposition is not true in

202
00:07:49,440 --> 00:07:50,960
particular if the self-equivalence

203
00:07:50,960 --> 00:07:54,080
implementation is using large importance

204
00:07:54,080 --> 00:07:55,360
the main problem of using

205
00:07:55,360 --> 00:07:57,440
self-equivalence implementation is that

206
00:07:57,440 --> 00:08:00,080
one needs a non-linear layer that has

207
00:08:00,080 --> 00:08:02,639
many and a large self-equivalence and

208
00:08:02,639 --> 00:08:04,800
this is very difficult to find

209
00:08:04,800 --> 00:08:08,160
so in this work we started by finding

210
00:08:08,160 --> 00:08:11,520
such an only linear layer and we decide

211
00:08:11,520 --> 00:08:14,240
to work with the permute modulation

212
00:08:14,240 --> 00:08:15,919
which is simply the modulation that is

213
00:08:15,919 --> 00:08:18,160
turned into permutation by giving to the

214
00:08:18,160 --> 00:08:20,319
output one of the inputs

215
00:08:20,319 --> 00:08:22,240
one of the reasons that we choose this

216
00:08:22,240 --> 00:08:24,720
operation is that quadratic functions

217
00:08:24,720 --> 00:08:26,879
tend to have many self-equivalence and

218
00:08:26,879 --> 00:08:29,199
the modal addition behaves like a

219
00:08:29,199 --> 00:08:31,360
quadratic function in particular the

220
00:08:31,360 --> 00:08:33,919
modal addition is set equivalent to

221
00:08:33,919 --> 00:08:36,399
operatic function and two functions are

222
00:08:36,399 --> 00:08:38,880
said to be synthetic equivalence if you

223
00:08:38,880 --> 00:08:41,360
can take the graph of one function and

224
00:08:41,360 --> 00:08:43,599
get the graph of the other function by

225
00:08:43,599 --> 00:08:46,000
applying an affine transformation

226
00:08:46,000 --> 00:08:47,920
and these equivalents have been used

227
00:08:47,920 --> 00:08:49,360
previously

228
00:08:49,360 --> 00:08:52,480
previously for example to study xboxes

229
00:08:52,480 --> 00:08:54,480
since this is equivalents preserve some

230
00:08:54,480 --> 00:08:56,240
categorical properties like differential

231
00:08:56,240 --> 00:08:58,720
and linear ones but here in this world

232
00:08:58,720 --> 00:09:01,360
we use this equivalence to propose a new

233
00:09:01,360 --> 00:09:03,920
method to find self occurrence and it's

234
00:09:03,920 --> 00:09:06,720
based on the idea of graph photomorphism

235
00:09:06,720 --> 00:09:09,360
a graph automation here we call is just

236
00:09:09,360 --> 00:09:11,279
a fine permutation

237
00:09:11,279 --> 00:09:13,519
that map the graph of a function to the

238
00:09:13,519 --> 00:09:15,360
same graph you can see this as a

239
00:09:15,360 --> 00:09:17,279
self-equivalence of the graph of a

240
00:09:17,279 --> 00:09:20,399
function and the idea of our method is

241
00:09:20,399 --> 00:09:23,120
that if you have a function f that is

242
00:09:23,120 --> 00:09:24,880
this is an equivalent to a function of

243
00:09:24,880 --> 00:09:28,000
law degree g we start by finding a

244
00:09:28,000 --> 00:09:30,080
special subset of graph of the mole

245
00:09:30,080 --> 00:09:32,080
freezing for this function g

246
00:09:32,080 --> 00:09:34,800
and we found this atomizing by solving a

247
00:09:34,800 --> 00:09:36,240
functional equation and since this

248
00:09:36,240 --> 00:09:37,760
function is of low degree this

249
00:09:37,760 --> 00:09:40,000
functional equation is easy to solve and

250
00:09:40,000 --> 00:09:42,480
then we transform the graph atomization

251
00:09:42,480 --> 00:09:44,959
that we found to the self-occurrence of

252
00:09:44,959 --> 00:09:47,360
f by using the system equivalence

253
00:09:47,360 --> 00:09:49,680
between these two functions

254
00:09:49,680 --> 00:09:52,560
we implement this this method in a new

255
00:09:52,560 --> 00:09:54,959
open source tool bulk crypt that also

256
00:09:54,959 --> 00:09:56,959
implements other functionalities related

257
00:09:56,959 --> 00:09:59,360
to vectoriable function related to

258
00:09:59,360 --> 00:10:01,680
self-equivalence a functional equation

259
00:10:01,680 --> 00:10:02,720
so

260
00:10:02,720 --> 00:10:05,120
this tool and the documentation you can

261
00:10:05,120 --> 00:10:08,480
find it in this repository in github

262
00:10:08,480 --> 00:10:10,959
we apply this method to the permute

263
00:10:10,959 --> 00:10:12,640
modular addition

264
00:10:12,640 --> 00:10:15,600
and we found linear affine and affine

265
00:10:15,600 --> 00:10:18,000
quadratic self-equivalence so linear and

266
00:10:18,000 --> 00:10:19,839
a fine self equivalence are parallel

267
00:10:19,839 --> 00:10:22,720
permutation where both are linear or

268
00:10:22,720 --> 00:10:25,040
fine and a fine quadratic is a parallel

269
00:10:25,040 --> 00:10:26,880
permutation where one is fine and the

270
00:10:26,880 --> 00:10:29,680
other one is quadratic

271
00:10:29,680 --> 00:10:31,120
and we found

272
00:10:31,120 --> 00:10:34,640
a self-equivalence up towards 564-bit

273
00:10:34,640 --> 00:10:37,839
diamond input size 128 but later we

274
00:10:37,839 --> 00:10:40,320
optimized this method and we extend this

275
00:10:40,320 --> 00:10:44,560
result up to an input size 512 bit

276
00:10:44,560 --> 00:10:46,560
and we found an exponential number of

277
00:10:46,560 --> 00:10:48,399
such equivalence

278
00:10:48,399 --> 00:10:50,800
but we didn't prove that these are all

279
00:10:50,800 --> 00:10:52,640
the same equivalence so although we

280
00:10:52,640 --> 00:10:54,560
expect that this is the case we leave

281
00:10:54,560 --> 00:10:55,600
this as

282
00:10:55,600 --> 00:10:56,959
an open plot

283
00:10:56,959 --> 00:10:59,839
so now we have a non-linear letter with

284
00:10:59,839 --> 00:11:02,320
many and large surface givens so now we

285
00:11:02,320 --> 00:11:04,079
are ready to build a webos

286
00:11:04,079 --> 00:11:05,360
implementation using these

287
00:11:05,360 --> 00:11:08,320
self-equipments well there is a problem

288
00:11:08,320 --> 00:11:09,279
the problem is that these

289
00:11:09,279 --> 00:11:11,360
self-equivalence are very structural

290
00:11:11,360 --> 00:11:13,519
they are very sparse and this could be a

291
00:11:13,519 --> 00:11:15,519
problem when building a self-equivalent

292
00:11:15,519 --> 00:11:17,360
implementation using these self

293
00:11:17,360 --> 00:11:18,480
agreements

294
00:11:18,480 --> 00:11:21,760
and actually in a later work we built a

295
00:11:21,760 --> 00:11:23,600
workhorse implementation using this

296
00:11:23,600 --> 00:11:25,760
self-equivalence and we broke it because

297
00:11:25,760 --> 00:11:28,800
of this structure that they have so now

298
00:11:28,800 --> 00:11:31,200
we are back to square one even though we

299
00:11:31,200 --> 00:11:32,880
found an online area with these

300
00:11:32,880 --> 00:11:34,320
properties we could not beat the web

301
00:11:34,320 --> 00:11:35,760
experimentation

302
00:11:35,760 --> 00:11:37,760
but later we solved this problem by

303
00:11:37,760 --> 00:11:39,680
proposing a new method the implicit

304
00:11:39,680 --> 00:11:40,959
framework

305
00:11:40,959 --> 00:11:43,279
so the invasive framework is a method to

306
00:11:43,279 --> 00:11:44,560
build whitebox

307
00:11:44,560 --> 00:11:46,800
implementation of block ciphers

308
00:11:46,800 --> 00:11:48,800
that have the following properties

309
00:11:48,800 --> 00:11:51,200
so implicit implementation or also in

310
00:11:51,200 --> 00:11:53,120
code implementation that means that they

311
00:11:53,120 --> 00:11:55,600
use the idea of import rounds and wrong

312
00:11:55,600 --> 00:11:58,240
encodings but here the wrong encodings

313
00:11:58,240 --> 00:12:00,000
are the composition of a fine

314
00:12:00,000 --> 00:12:02,240
permutation and a fine non-linear

315
00:12:02,240 --> 00:12:04,480
self-equivalence i will talk later about

316
00:12:04,480 --> 00:12:06,079
these strong encodings

317
00:12:06,079 --> 00:12:08,639
but by combining these two types we're

318
00:12:08,639 --> 00:12:10,720
able to prevent attacks that break c

319
00:12:10,720 --> 00:12:13,279
implementation and self-equivalence once

320
00:12:13,279 --> 00:12:15,600
and to implement efficiently they encode

321
00:12:15,600 --> 00:12:18,240
wrong functions the idea is to represent

322
00:12:18,240 --> 00:12:22,160
them with system of low degree equations

323
00:12:22,160 --> 00:12:23,440
so to build

324
00:12:23,440 --> 00:12:24,959
the rounds of an impressive

325
00:12:24,959 --> 00:12:27,600
implementation we proceed as follows we

326
00:12:27,600 --> 00:12:30,720
first decompose the cipher into rounds

327
00:12:30,720 --> 00:12:31,920
then

328
00:12:31,920 --> 00:12:33,440
we introduce

329
00:12:33,440 --> 00:12:36,480
uh a five nonlinear self equivalence of

330
00:12:36,480 --> 00:12:38,240
the round where the first element is

331
00:12:38,240 --> 00:12:40,639
fine and the other one is non-linear

332
00:12:40,639 --> 00:12:42,720
since they cancel each other it doesn't

333
00:12:42,720 --> 00:12:45,440
change the input and of a behavior

334
00:12:45,440 --> 00:12:47,360
now we introduce between the output of

335
00:12:47,360 --> 00:12:48,880
the round and the second element of the

336
00:12:48,880 --> 00:12:50,160
strength equivalence and i find

337
00:12:50,160 --> 00:12:52,480
permutation c and its inverse

338
00:12:52,480 --> 00:12:55,200
this also doesn't change the input and a

339
00:12:55,200 --> 00:12:57,279
behavior of the round

340
00:12:57,279 --> 00:12:59,760
and we do this for all rounds and then

341
00:12:59,760 --> 00:13:03,200
merge the wrong function within part of

342
00:13:03,200 --> 00:13:04,639
equivalence and part of the frame

343
00:13:04,639 --> 00:13:07,600
permutation such a way that we split

344
00:13:07,600 --> 00:13:10,320
uh self-equivalence and permutation over

345
00:13:10,320 --> 00:13:12,000
adjacent rounds

346
00:13:12,000 --> 00:13:14,560
and similar as in previous methods we

347
00:13:14,560 --> 00:13:16,880
need external encodings so the first and

348
00:13:16,880 --> 00:13:19,040
the last encodings are not cancelled and

349
00:13:19,040 --> 00:13:22,720
they are needed for security

350
00:13:22,720 --> 00:13:24,639
and we build the

351
00:13:24,639 --> 00:13:27,440
encode rounds in such a way

352
00:13:27,440 --> 00:13:29,440
so that the input encoding can be

353
00:13:29,440 --> 00:13:31,839
non-linear but the important coding is

354
00:13:31,839 --> 00:13:34,320
always a fine and later on i will talk

355
00:13:34,320 --> 00:13:37,440
about this restriction

356
00:13:37,600 --> 00:13:40,639
to even even if the encode runs are a

357
00:13:40,639 --> 00:13:42,480
high degree we can implement it

358
00:13:42,480 --> 00:13:44,639
efficiently by using low degree

359
00:13:44,639 --> 00:13:46,959
quasi-linear and impressive function so

360
00:13:46,959 --> 00:13:49,920
first a function p is an impressive

361
00:13:49,920 --> 00:13:51,600
function of f

362
00:13:51,600 --> 00:13:53,760
if the zeros of this function p

363
00:13:53,760 --> 00:13:56,000
correspond to the points and the image

364
00:13:56,000 --> 00:13:57,120
of f

365
00:13:57,120 --> 00:13:58,639
and high degree functions like the

366
00:13:58,639 --> 00:14:01,279
modular vision has low degree impressive

367
00:14:01,279 --> 00:14:03,519
functions if we have the impressive

368
00:14:03,519 --> 00:14:04,560
function

369
00:14:04,560 --> 00:14:06,959
of a function f we can evaluate it using

370
00:14:06,959 --> 00:14:08,959
the impressive function by taking the

371
00:14:08,959 --> 00:14:10,880
input substituting into the impression

372
00:14:10,880 --> 00:14:13,839
function and solving the the remaining

373
00:14:13,839 --> 00:14:16,720
system for the remaining variable y

374
00:14:16,720 --> 00:14:20,240
and this thing is easy to solve if we

375
00:14:20,240 --> 00:14:21,920
require the implicit function to be

376
00:14:21,920 --> 00:14:23,920
quasilinear which is just saying that

377
00:14:23,920 --> 00:14:26,240
for all inputs we assume that the

378
00:14:26,240 --> 00:14:29,519
remaining system is a fine

379
00:14:29,519 --> 00:14:31,680
so we can have efficient increasing

380
00:14:31,680 --> 00:14:34,639
implementation if we are able to get

381
00:14:34,639 --> 00:14:36,240
low degree quasillini and impression

382
00:14:36,240 --> 00:14:38,720
function of the code runs and for the

383
00:14:38,720 --> 00:14:41,760
permute modulation and we have that this

384
00:14:41,760 --> 00:14:43,440
this this permutation have a

385
00:14:43,440 --> 00:14:45,040
quasi-linear quadratic impressive

386
00:14:45,040 --> 00:14:47,360
function and then in the paper we show a

387
00:14:47,360 --> 00:14:48,800
method

388
00:14:48,800 --> 00:14:50,959
to from the impressive function of the

389
00:14:50,959 --> 00:14:53,360
non-linear layer how to obtain the

390
00:14:53,360 --> 00:14:55,680
present function of the whole encoder

391
00:14:55,680 --> 00:14:58,320
and for this method we require the

392
00:14:58,320 --> 00:14:59,920
previous restriction that the opposite

393
00:14:59,920 --> 00:15:01,839
encoding needs to be a fine

394
00:15:01,839 --> 00:15:03,519
we apply this method to show how to

395
00:15:03,519 --> 00:15:06,000
build impressive implementation of arc

396
00:15:06,000 --> 00:15:08,079
ciphers but this method can be used for

397
00:15:08,079 --> 00:15:10,959
any block cipher as long as one has

398
00:15:10,959 --> 00:15:12,800
a quasilineal implicit function of the

399
00:15:12,800 --> 00:15:15,360
non-linear life

400
00:15:15,360 --> 00:15:18,000
and here in this table you can see the

401
00:15:18,000 --> 00:15:20,880
size and the uh for the

402
00:15:20,880 --> 00:15:22,959
size that one single input

403
00:15:22,959 --> 00:15:24,720
implementation takes

404
00:15:24,720 --> 00:15:26,560
depending on the degree and on the block

405
00:15:26,560 --> 00:15:28,959
size of the cycle so for example for a

406
00:15:28,959 --> 00:15:30,720
cubic impressive function

407
00:15:30,720 --> 00:15:32,880
and for if the block size of the cypher

408
00:15:32,880 --> 00:15:35,519
is 64 bit then each implicit function

409
00:15:35,519 --> 00:15:38,800
will require one and a half a megabyte

410
00:15:38,800 --> 00:15:41,040
but then if we go to higher degrees and

411
00:15:41,040 --> 00:15:42,880
if you take a quarter impressive

412
00:15:42,880 --> 00:15:45,759
function for a 128 bit block

413
00:15:45,759 --> 00:15:49,120
cipher then this will require around

414
00:15:49,120 --> 00:15:50,399
200

415
00:15:50,399 --> 00:15:53,519
megabytes and the degree of an

416
00:15:53,519 --> 00:15:55,519
impressive function depends on the

417
00:15:55,519 --> 00:15:56,959
degree of the impressive function of the

418
00:15:56,959 --> 00:15:59,440
non-linear layer but also on the degree

419
00:15:59,440 --> 00:16:02,000
of the final linear surface equivalence

420
00:16:02,000 --> 00:16:03,360
and for example for the permute

421
00:16:03,360 --> 00:16:06,000
modulation if we use a fine quadratic

422
00:16:06,000 --> 00:16:08,079
self-occurrence that impressive function

423
00:16:08,079 --> 00:16:10,480
will be cubic or quartic but if we only

424
00:16:10,480 --> 00:16:12,480
use a fine encodings the depressive

425
00:16:12,480 --> 00:16:14,880
function will be quadratic

426
00:16:14,880 --> 00:16:16,720
and even though this

427
00:16:16,720 --> 00:16:18,880
the implicit framework might introduce a

428
00:16:18,880 --> 00:16:21,040
significant overhead in particular for

429
00:16:21,040 --> 00:16:22,560
high degrees

430
00:16:22,560 --> 00:16:25,120
this method is the first one that can be

431
00:16:25,120 --> 00:16:27,519
applied to lx ciphers and is also the

432
00:16:27,519 --> 00:16:29,759
first one that can consider practical

433
00:16:29,759 --> 00:16:32,800
implementation with large encodings and

434
00:16:32,800 --> 00:16:34,399
as we will see they are crucial for the

435
00:16:34,399 --> 00:16:36,480
security

436
00:16:36,480 --> 00:16:39,279
so as in previous methods the implicit

437
00:16:39,279 --> 00:16:41,759
framework only charges the security goal

438
00:16:41,759 --> 00:16:43,920
of keystructural resistance that means

439
00:16:43,920 --> 00:16:45,920
that we assume that the attacker is in

440
00:16:45,920 --> 00:16:48,560
possession of an impressive function of

441
00:16:48,560 --> 00:16:51,120
a sorry of an implicit implementation we

442
00:16:51,120 --> 00:16:52,639
assume that the attacker knows the

443
00:16:52,639 --> 00:16:54,480
methods and all the details but doesn't

444
00:16:54,480 --> 00:16:56,480
know the key or the encodings and the

445
00:16:56,480 --> 00:16:58,959
goal of the attacker is to extract the

446
00:16:58,959 --> 00:17:01,360
key from the impressive implementation

447
00:17:01,360 --> 00:17:02,800
and to understand the security of this

448
00:17:02,800 --> 00:17:05,199
method we first consider all known

449
00:17:05,199 --> 00:17:07,919
genetic attacks generic attacks are

450
00:17:07,919 --> 00:17:10,720
those that can be applied to any weapons

451
00:17:10,720 --> 00:17:12,799
implementation of any cipher because

452
00:17:12,799 --> 00:17:14,720
they do not exploit the underlying

453
00:17:14,720 --> 00:17:17,199
properties of the cypher

454
00:17:17,199 --> 00:17:19,199
and we focus on genetic attacks because

455
00:17:19,199 --> 00:17:21,039
sometimes if you break a weighbox

456
00:17:21,039 --> 00:17:23,119
implementation of a particular cipher

457
00:17:23,119 --> 00:17:24,880
that might not say much about the

458
00:17:24,880 --> 00:17:27,199
security of the methods and also because

459
00:17:27,199 --> 00:17:29,200
for example in previous methods like the

460
00:17:29,200 --> 00:17:31,280
seizure framework has been fully broken

461
00:17:31,280 --> 00:17:33,600
with genetic attacks so any new method

462
00:17:33,600 --> 00:17:35,600
that is secure against all non-genetic

463
00:17:35,600 --> 00:17:37,760
attacks is still a significant advance

464
00:17:37,760 --> 00:17:40,000
over the state of the art

465
00:17:40,000 --> 00:17:42,320
and the full analysis is in the paper

466
00:17:42,320 --> 00:17:44,240
but here i will skip to the conclusion

467
00:17:44,240 --> 00:17:45,840
that is that if an impressive

468
00:17:45,840 --> 00:17:47,200
implementation

469
00:17:47,200 --> 00:17:49,360
uses a non-linear important encoding

470
00:17:49,360 --> 00:17:51,840
such as quadratic input encodings or the

471
00:17:51,840 --> 00:17:54,320
non-linearity of the cipher is given by

472
00:17:54,320 --> 00:17:56,799
a large function not the concatenation

473
00:17:56,799 --> 00:17:59,679
of small s boxes then an increasing then

474
00:17:59,679 --> 00:18:02,720
all known genetic attacks fail against

475
00:18:02,720 --> 00:18:05,440
uh this impressive implementation

476
00:18:05,440 --> 00:18:08,320
but this analysis also shows that this

477
00:18:08,320 --> 00:18:10,559
method cannot secure experience ciphers

478
00:18:10,559 --> 00:18:13,360
like aes if one only use a fine

479
00:18:13,360 --> 00:18:16,080
encodings so one will need to to choose

480
00:18:16,080 --> 00:18:18,000
another cipher and choose a large

481
00:18:18,000 --> 00:18:19,440
numerical ledger like the permute

482
00:18:19,440 --> 00:18:22,400
modulation or choose non-linear input

483
00:18:22,400 --> 00:18:24,480
and columns

484
00:18:24,480 --> 00:18:27,200
and previous attacks mainly don't work

485
00:18:27,200 --> 00:18:29,200
against this method because previous

486
00:18:29,200 --> 00:18:31,280
attacks and mainly exploit that

487
00:18:31,280 --> 00:18:34,240
encodings are of small size

488
00:18:34,240 --> 00:18:37,039
so here we also propose a new

489
00:18:37,039 --> 00:18:39,440
genetic attack that is more suitable to

490
00:18:39,440 --> 00:18:41,360
the impressive framework that is based

491
00:18:41,360 --> 00:18:42,880
on the idea of

492
00:18:42,880 --> 00:18:44,720
reducing the impressive implementation

493
00:18:44,720 --> 00:18:47,120
to a self-equivalence one

494
00:18:47,120 --> 00:18:49,120
and since self-experience implementation

495
00:18:49,120 --> 00:18:50,400
are more efficient at increasing

496
00:18:50,400 --> 00:18:52,160
implementation if you can do this

497
00:18:52,160 --> 00:18:54,400
reduction then there is no benefit from

498
00:18:54,400 --> 00:18:56,400
using the press implementation and also

499
00:18:56,400 --> 00:18:58,240
if you can do this reduction all the

500
00:18:58,240 --> 00:19:00,400
attacks that apply to self-achievement

501
00:19:00,400 --> 00:19:02,400
implementation could now be applied to

502
00:19:02,400 --> 00:19:03,919
the implicit one

503
00:19:03,919 --> 00:19:05,760
our attack is based on functional

504
00:19:05,760 --> 00:19:08,400
equation and because we only focus on

505
00:19:08,400 --> 00:19:10,400
the fine encodings these functional

506
00:19:10,400 --> 00:19:12,640
equations are also called a fine

507
00:19:12,640 --> 00:19:15,360
equivalence problems so here the idea is

508
00:19:15,360 --> 00:19:16,880
that you have a function a known

509
00:19:16,880 --> 00:19:18,799
function g as is equal to the

510
00:19:18,799 --> 00:19:21,039
composition of three function and you

511
00:19:21,039 --> 00:19:22,720
know the central map f

512
00:19:22,720 --> 00:19:24,960
but the other the other functions are a

513
00:19:24,960 --> 00:19:27,360
number five permutation and the goal is

514
00:19:27,360 --> 00:19:29,520
to find a solution of this equation a

515
00:19:29,520 --> 00:19:32,080
pair of functions x and y that makes is

516
00:19:32,080 --> 00:19:34,720
partly true

517
00:19:34,960 --> 00:19:37,280
so i won't go to all the details of this

518
00:19:37,280 --> 00:19:39,679
attack but for the attack to succeed the

519
00:19:39,679 --> 00:19:42,080
attacker needs to solve one of these

520
00:19:42,080 --> 00:19:44,320
functional equations for the question if

521
00:19:44,320 --> 00:19:46,400
the in the left side the attacker can

522
00:19:46,400 --> 00:19:48,400
build an applying equivalence problem

523
00:19:48,400 --> 00:19:49,679
involving

524
00:19:49,679 --> 00:19:52,320
then called rounds where the central map

525
00:19:52,320 --> 00:19:54,640
is the wrong function of of the cipher

526
00:19:54,640 --> 00:19:56,000
the advantages

527
00:19:56,000 --> 00:19:57,919
and obviously well the disadvantages of

528
00:19:57,919 --> 00:19:59,280
using this equation is that this

529
00:19:59,280 --> 00:20:01,120
equation can be of high degree and this

530
00:20:01,120 --> 00:20:02,559
is the case for example of the modal

531
00:20:02,559 --> 00:20:04,880
addition and also the attacker only has

532
00:20:04,880 --> 00:20:06,960
blood plato's access to this equation

533
00:20:06,960 --> 00:20:08,640
because the attacker doesn't know the

534
00:20:08,640 --> 00:20:11,200
coefficients involve this equation

535
00:20:11,200 --> 00:20:13,440
the advantages of using this equation is

536
00:20:13,440 --> 00:20:16,000
that if attacker finds any solution then

537
00:20:16,000 --> 00:20:18,320
the attack will succeed

538
00:20:18,320 --> 00:20:20,640
if the decker cannot solve and this

539
00:20:20,640 --> 00:20:22,480
equation attacker could try the

540
00:20:22,480 --> 00:20:24,720
functional equation in the right side

541
00:20:24,720 --> 00:20:26,720
here this equation involves the

542
00:20:26,720 --> 00:20:29,039
impressive function of the code round

543
00:20:29,039 --> 00:20:31,280
where the central map is the impressive

544
00:20:31,280 --> 00:20:33,440
function of the non-linear layer the

545
00:20:33,440 --> 00:20:35,039
advantages of using this equation is

546
00:20:35,039 --> 00:20:37,039
that this equation is usually a flow

547
00:20:37,039 --> 00:20:39,200
degree for example in the case of the

548
00:20:39,200 --> 00:20:42,000
moderation angle encodings this equation

549
00:20:42,000 --> 00:20:43,360
is quadratic

550
00:20:43,360 --> 00:20:46,000
and also the attacker has while access

551
00:20:46,000 --> 00:20:47,360
because attacker knows all the

552
00:20:47,360 --> 00:20:49,840
coefficients involved in this equation

553
00:20:49,840 --> 00:20:51,840
the main problem is that for attacker to

554
00:20:51,840 --> 00:20:54,320
succeed the attacker first needs to find

555
00:20:54,320 --> 00:20:56,720
a solution and then again is to remove

556
00:20:56,720 --> 00:20:58,559
the graph photographers and u

557
00:20:58,559 --> 00:21:00,240
used in the impressive function i did

558
00:21:00,240 --> 00:21:01,840
not talk about this but when building an

559
00:21:01,840 --> 00:21:04,200
impressive function we're also adding a

560
00:21:04,200 --> 00:21:06,640
graphatomorphism that obfuscates the

561
00:21:06,640 --> 00:21:08,080
impressive function of the non-linear

562
00:21:08,080 --> 00:21:10,640
layer this preserves the zeros of the

563
00:21:10,640 --> 00:21:12,799
impressive function so it doesn't change

564
00:21:12,799 --> 00:21:14,720
the important behavior so for the

565
00:21:14,720 --> 00:21:16,880
attacker to succeed they they need to

566
00:21:16,880 --> 00:21:18,960
remove this glass automorphism from the

567
00:21:18,960 --> 00:21:20,080
solution

568
00:21:20,080 --> 00:21:22,640
and we check for the model addition and

569
00:21:22,640 --> 00:21:24,799
we do not found an efficient solution to

570
00:21:24,799 --> 00:21:27,919
solve the left equation and to solve the

571
00:21:27,919 --> 00:21:29,840
right equation that could be possible

572
00:21:29,840 --> 00:21:31,679
but since the number of graph

573
00:21:31,679 --> 00:21:33,360
atomization is exponential for the

574
00:21:33,360 --> 00:21:35,760
modulation we did not find a way to

575
00:21:35,760 --> 00:21:39,919
solve for attacker in this part

576
00:21:40,320 --> 00:21:42,799
or analysis was also a bit

577
00:21:42,799 --> 00:21:44,960
limited for example we only consider a

578
00:21:44,960 --> 00:21:47,120
fine encodings and

579
00:21:47,120 --> 00:21:48,880
the impression framework

580
00:21:48,880 --> 00:21:51,200
it will require future research and more

581
00:21:51,200 --> 00:21:52,799
time to increase the assurance in the

582
00:21:52,799 --> 00:21:55,280
security that it provides and that's why

583
00:21:55,280 --> 00:21:57,520
we're also proposing another open source

584
00:21:57,520 --> 00:22:00,320
tool whitebox areas to easily build

585
00:22:00,320 --> 00:22:02,640
whitebox implementation of eric ciphers

586
00:22:02,640 --> 00:22:04,960
and we hope that with all the examples

587
00:22:04,960 --> 00:22:06,960
that can be generated using this tool

588
00:22:06,960 --> 00:22:09,120
this will encourage further research on

589
00:22:09,120 --> 00:22:10,559
this topic

590
00:22:10,559 --> 00:22:12,799
so with this tool there are many options

591
00:22:12,799 --> 00:22:15,280
that one can choose like the inputs and

592
00:22:15,280 --> 00:22:18,000
block cipher to be and secure the degree

593
00:22:18,000 --> 00:22:20,240
of the encodings where to use external

594
00:22:20,240 --> 00:22:21,919
encodings where to use additional

595
00:22:21,919 --> 00:22:24,720
content measures and you um

596
00:22:24,720 --> 00:22:26,720
all this information you can find in

597
00:22:26,720 --> 00:22:29,840
this repository on github

598
00:22:29,840 --> 00:22:32,559
and finally to conclude

599
00:22:32,559 --> 00:22:35,039
in the design of webos implementation

600
00:22:35,039 --> 00:22:36,799
there hasn't been much progress in the

601
00:22:36,799 --> 00:22:39,440
last year and here we address this

602
00:22:39,440 --> 00:22:41,200
challenging problem by proposing the

603
00:22:41,200 --> 00:22:43,039
impressive framework which is a new

604
00:22:43,039 --> 00:22:45,520
method to build white box implementation

605
00:22:45,520 --> 00:22:47,280
of block cipher

606
00:22:47,280 --> 00:22:49,120
is currently the only method that

607
00:22:49,120 --> 00:22:51,440
prevents all non-generic attack is the

608
00:22:51,440 --> 00:22:53,840
first method that can be applied to

609
00:22:53,840 --> 00:22:56,559
air ciphers and to

610
00:22:56,559 --> 00:22:58,240
generate impressive implementation of

611
00:22:58,240 --> 00:23:00,080
air cipher one need to sample

612
00:23:00,080 --> 00:23:02,000
self-equivalence and graphatomorphism

613
00:23:02,000 --> 00:23:04,000
and that's why we're also proposing a

614
00:23:04,000 --> 00:23:06,240
new method to find self-equipment this

615
00:23:06,240 --> 00:23:08,000
is based on the synthetic equivalence

616
00:23:08,000 --> 00:23:10,320
and we apply for the permutation and

617
00:23:10,320 --> 00:23:12,320
found for the first time the safe

618
00:23:12,320 --> 00:23:14,159
equivalence of this

619
00:23:14,159 --> 00:23:18,320
of this operation this method um

620
00:23:18,320 --> 00:23:20,480
um this method was implemented in the

621
00:23:20,480 --> 00:23:22,640
new open source tool bulk crypt and

622
00:23:22,640 --> 00:23:25,039
we're also proposing another open source

623
00:23:25,039 --> 00:23:27,200
tool to easily build a web box

624
00:23:27,200 --> 00:23:29,919
implementation of eric ciphers the

625
00:23:29,919 --> 00:23:32,159
impression framework is a radical new

626
00:23:32,159 --> 00:23:34,640
method that's why many proper problems

627
00:23:34,640 --> 00:23:36,799
arise and there is a lot of future work

628
00:23:36,799 --> 00:23:39,039
and this includes for example

629
00:23:39,039 --> 00:23:41,600
investigating new genetic attacks or

630
00:23:41,600 --> 00:23:43,600
particular attacks to a specific

631
00:23:43,600 --> 00:23:45,679
implementation considering other

632
00:23:45,679 --> 00:23:47,919
non-linear layers here will only focus

633
00:23:47,919 --> 00:23:50,480
on the moderation but also to study

634
00:23:50,480 --> 00:23:52,720
impressive implementation without

635
00:23:52,720 --> 00:23:54,880
external encodings against some weaker

636
00:23:54,880 --> 00:23:56,080
attacks

637
00:23:56,080 --> 00:23:58,159
and that was all for this talk you can

638
00:23:58,159 --> 00:24:00,000
find more information in the paper thank

639
00:24:00,000 --> 00:24:03,559
you for your time

640
00:24:07,039 --> 00:24:10,039
um

641
00:24:15,350 --> 00:24:18,540
[Music]

642
00:24:20,720 --> 00:24:23,679
yeah i can see the question

643
00:24:25,440 --> 00:24:27,440
so the question is is there a need to

644
00:24:27,440 --> 00:24:29,600
understand reason why your construction

645
00:24:29,600 --> 00:24:31,919
resist gave us attacks like correlation

646
00:24:31,919 --> 00:24:33,120
attacks

647
00:24:33,120 --> 00:24:34,240
where

648
00:24:34,240 --> 00:24:37,360
the the sure answer is that because or

649
00:24:37,360 --> 00:24:39,760
our methods use external encodings and

650
00:24:39,760 --> 00:24:41,520
in particular these external encodings

651
00:24:41,520 --> 00:24:42,640
are given by

652
00:24:42,640 --> 00:24:44,640
a large function another composition of

653
00:24:44,640 --> 00:24:47,840
small s boxes right now no one has found

654
00:24:47,840 --> 00:24:50,799
a way to use english attacks to bypass

655
00:24:50,799 --> 00:24:52,640
these external encodings only in the

656
00:24:52,640 --> 00:24:55,760
case of using small external encodings

657
00:24:55,760 --> 00:24:57,520
so that's why there are no attacks right

658
00:24:57,520 --> 00:25:00,000
now that are being published that can

659
00:25:00,000 --> 00:25:02,159
with great attacks break external

660
00:25:02,159 --> 00:25:04,080
encodings

661
00:25:04,080 --> 00:25:08,120
does this answer your question

662
00:25:19,930 --> 00:25:27,120
[Music]

663
00:25:27,120 --> 00:25:28,559
so

664
00:25:28,559 --> 00:25:30,240
yeah so the question was for a given

665
00:25:30,240 --> 00:25:32,559
non-linear function was it easy to find

666
00:25:32,559 --> 00:25:35,279
self-achievements

667
00:25:37,679 --> 00:25:38,880
so okay

668
00:25:38,880 --> 00:25:41,279
so the total number of self-equivalents

669
00:25:41,279 --> 00:25:42,880
for example in a case that we tried for

670
00:25:42,880 --> 00:25:45,679
the permutation was not possible because

671
00:25:45,679 --> 00:25:48,159
we only found a subset of them

672
00:25:48,159 --> 00:25:50,159
because to solve this functional

673
00:25:50,159 --> 00:25:53,120
equation for large word size we had

674
00:25:53,120 --> 00:25:55,600
first to fix some coefficient in the

675
00:25:55,600 --> 00:25:58,640
system and by doing this we remove some

676
00:25:58,640 --> 00:26:00,400
songs and solutions

677
00:26:00,400 --> 00:26:02,480
but we did some experiments for small

678
00:26:02,480 --> 00:26:04,080
words and word sizes and for the

679
00:26:04,080 --> 00:26:06,240
perimeter relation we were able to find

680
00:26:06,240 --> 00:26:08,000
all of them

681
00:26:08,000 --> 00:26:10,960
and then for another

682
00:26:10,960 --> 00:26:13,279
linear layer if that function

683
00:26:13,279 --> 00:26:16,320
is equivalent to a low degree any

684
00:26:16,320 --> 00:26:18,080
particular quadratic function then you

685
00:26:18,080 --> 00:26:23,240
should be invisible to use this method

686
00:26:27,320 --> 00:26:30,530
[Music]

687
00:26:31,039 --> 00:26:33,520
so i have to say that most methods in

688
00:26:33,520 --> 00:26:35,279
white box have been broken after two or

689
00:26:35,279 --> 00:26:36,880
three years

690
00:26:36,880 --> 00:26:39,840
but so here i'm confident that probably

691
00:26:39,840 --> 00:26:42,480
the method will not be broken but there

692
00:26:42,480 --> 00:26:44,559
could be that strong implementation of a

693
00:26:44,559 --> 00:26:46,640
particular and cipher that will be will

694
00:26:46,640 --> 00:26:49,039
be broken and in particular this method

695
00:26:49,039 --> 00:26:51,360
and for some a fine

696
00:26:51,360 --> 00:26:52,960
of equivalence like a quadratic input

697
00:26:52,960 --> 00:26:55,440
encodings i have some confidence in that

698
00:26:55,440 --> 00:26:59,559
but only time time

699
00:27:26,799 --> 00:27:31,639
the next video is the next talk is

