1
00:00:00,000 --> 00:00:02,220
so good morning so let's

2
00:00:02,220 --> 00:00:04,920
get started

3
00:00:04,920 --> 00:00:07,080
so welcome to the session on latticepage

4
00:00:07,080 --> 00:00:09,120
zero knowledge we'll have three talks uh

5
00:00:09,120 --> 00:00:12,059
this session and the first talk is on

6
00:00:12,059 --> 00:00:13,620
ladder space zero knowledge proofs and

7
00:00:13,620 --> 00:00:15,780
applications shorter simpler and more

8
00:00:15,780 --> 00:00:18,240
General this is a talk by Vadim

9
00:00:18,240 --> 00:00:21,600
lubachevsky conagoon and Maxine francon

10
00:00:21,600 --> 00:00:23,939
and if you have seen the preview talk

11
00:00:23,939 --> 00:00:25,619
this is the one with the rap video so

12
00:00:25,619 --> 00:00:27,960
we're all heavily awaiting your talk so

13
00:00:27,960 --> 00:00:30,680
whenever you're ready

14
00:00:30,960 --> 00:00:33,540
um Mike's like oh it works great so um

15
00:00:33,540 --> 00:00:34,860
thank you very much for the introduction

16
00:00:34,860 --> 00:00:36,180
and thanks everyone for coming this

17
00:00:36,180 --> 00:00:36,960
early

18
00:00:36,960 --> 00:00:39,000
so hi my name is Khan and today I'm

19
00:00:39,000 --> 00:00:40,680
going to talk about lattice base zero

20
00:00:40,680 --> 00:00:43,200
knowledge proofs and applications

21
00:00:43,200 --> 00:00:44,940
okay so um let's start with your

22
00:00:44,940 --> 00:00:46,260
knowledge proofs I guess everyone is

23
00:00:46,260 --> 00:00:48,719
familiar with this concept so we have

24
00:00:48,719 --> 00:00:51,180
some statements like this and we have

25
00:00:51,180 --> 00:00:54,059
two parties the proof and the verifier

26
00:00:54,059 --> 00:00:55,620
and The Proven wants to convince the

27
00:00:55,620 --> 00:00:57,899
verifier that the statement is true

28
00:00:57,899 --> 00:00:59,460
so the proof has the corresponding

29
00:00:59,460 --> 00:01:01,559
witness and they engage in an

30
00:01:01,559 --> 00:01:03,059
interaction where they say messages to

31
00:01:03,059 --> 00:01:04,619
each other where at the end the verify

32
00:01:04,619 --> 00:01:06,600
outputs accept or reject

33
00:01:06,600 --> 00:01:08,640
which means that the verify is either

34
00:01:08,640 --> 00:01:10,260
convinced or not convinced about the

35
00:01:10,260 --> 00:01:12,600
validity of the statement

36
00:01:12,600 --> 00:01:15,540
okay so we have a few properties of zero

37
00:01:15,540 --> 00:01:17,700
knowledge proofs uh such as completeness

38
00:01:17,700 --> 00:01:19,799
which says that if the witness is valid

39
00:01:19,799 --> 00:01:21,540
then for an honest proof of the verify

40
00:01:21,540 --> 00:01:22,680
should accept

41
00:01:22,680 --> 00:01:24,479
then we have soundness which says that

42
00:01:24,479 --> 00:01:26,159
if the witness is invalid then for any

43
00:01:26,159 --> 00:01:28,140
cheating proof of the verifiers should

44
00:01:28,140 --> 00:01:29,159
reject

45
00:01:29,159 --> 00:01:31,020
and last but not least we have zero

46
00:01:31,020 --> 00:01:32,400
knowledge which says that the verify

47
00:01:32,400 --> 00:01:34,200
should learn any information about the

48
00:01:34,200 --> 00:01:36,659
witness from the interaction

49
00:01:36,659 --> 00:01:39,780
okay so um well due to the significant

50
00:01:39,780 --> 00:01:41,880
progress in uh building quantum

51
00:01:41,880 --> 00:01:43,860
computers there has been a tremendous

52
00:01:43,860 --> 00:01:44,939
amount of interest in making

53
00:01:44,939 --> 00:01:47,220
cryptographic Primitives Quantum size

54
00:01:47,220 --> 00:01:49,020
and this is highly evident with the

55
00:01:49,020 --> 00:01:50,520
ongoing this post content competition

56
00:01:50,520 --> 00:01:52,619
where very recently four schemes were

57
00:01:52,619 --> 00:01:54,840
selected by this for standardization

58
00:01:54,840 --> 00:01:56,820
uh out of which three are based on

59
00:01:56,820 --> 00:01:59,880
lattices so why are they interesting uh

60
00:01:59,880 --> 00:02:01,560
well not only do they offer relatively

61
00:02:01,560 --> 00:02:04,079
small sizes but they can be very

62
00:02:04,079 --> 00:02:06,719
efficiently implemented in practice

63
00:02:06,719 --> 00:02:08,780
so it seems that lattices are a natural

64
00:02:08,780 --> 00:02:11,280
candidate for building more privacy

65
00:02:11,280 --> 00:02:13,140
oriented Primitives such as your

66
00:02:13,140 --> 00:02:15,300
knowledge proofs

67
00:02:15,300 --> 00:02:17,280
however if we look at the current state

68
00:02:17,280 --> 00:02:19,140
of the art content saves your knowledge

69
00:02:19,140 --> 00:02:20,879
proofs then the situation is pretty

70
00:02:20,879 --> 00:02:23,459
interesting so we have very nice hash

71
00:02:23,459 --> 00:02:25,860
based proof systems such as liguero

72
00:02:25,860 --> 00:02:27,959
Aurora and fractal where the latter two

73
00:02:27,959 --> 00:02:30,319
achieve uh

74
00:02:30,319 --> 00:02:32,459
logarithmic proof size asymptotically

75
00:02:32,459 --> 00:02:34,800
and completely when they witness size

76
00:02:34,800 --> 00:02:36,300
around is around a million then it's

77
00:02:36,300 --> 00:02:38,340
around 200 kilobytes

78
00:02:38,340 --> 00:02:40,860
however if we look at the the situation

79
00:02:40,860 --> 00:02:42,540
in the latter setting well it's not so

80
00:02:42,540 --> 00:02:45,239
great so okay even though we have a few

81
00:02:45,239 --> 00:02:48,060
nice constructions which are sublimea

82
00:02:48,060 --> 00:02:49,739
um well the best one is the lattice

83
00:02:49,739 --> 00:02:51,900
adaptation of bulletproofs there are

84
00:02:51,900 --> 00:02:54,060
still of theoretical interests and the

85
00:02:54,060 --> 00:02:55,980
main reason is that if one were just to

86
00:02:55,980 --> 00:02:58,019
uh instantiate them with complete

87
00:02:58,019 --> 00:03:00,599
parameters then they could easily reach

88
00:03:00,599 --> 00:03:02,760
tens or hundreds of megabytes for proof

89
00:03:02,760 --> 00:03:03,959
size

90
00:03:03,959 --> 00:03:05,940
however as we can see well in the next

91
00:03:05,940 --> 00:03:08,760
two talks actually that

92
00:03:08,760 --> 00:03:10,440
um it's a very active area of current

93
00:03:10,440 --> 00:03:12,180
research and there are already skins

94
00:03:12,180 --> 00:03:14,280
which can achieve some concrete proof

95
00:03:14,280 --> 00:03:17,040
sizes however we can see that it's still

96
00:03:17,040 --> 00:03:19,019
far to be comparable with the hash based

97
00:03:19,019 --> 00:03:21,620
proof systems

98
00:03:21,840 --> 00:03:23,819
so in terms of the possible research

99
00:03:23,819 --> 00:03:25,260
directions in the lattice world the

100
00:03:25,260 --> 00:03:27,480
first one is pretty clear it's just to

101
00:03:27,480 --> 00:03:29,280
you know construct succinct gear

102
00:03:29,280 --> 00:03:31,500
knowledge proofs from lattices which and

103
00:03:31,500 --> 00:03:33,900
which concretely can uh be comparable

104
00:03:33,900 --> 00:03:36,780
with the hash based constructions

105
00:03:36,780 --> 00:03:39,180
however I would like to introduce you to

106
00:03:39,180 --> 00:03:40,860
like another angle or like another

107
00:03:40,860 --> 00:03:43,620
research Direction which is to focus on

108
00:03:43,620 --> 00:03:45,360
small statements which we call the

109
00:03:45,360 --> 00:03:47,819
interesting statements uh for which we

110
00:03:47,819 --> 00:03:49,680
can construct practically efficient so

111
00:03:49,680 --> 00:03:51,840
asymptotically they they can and will be

112
00:03:51,840 --> 00:03:52,739
linear

113
00:03:52,739 --> 00:03:55,319
in the witness sites uh zero knowledge

114
00:03:55,319 --> 00:03:57,299
proofs which can concretely achieve

115
00:03:57,299 --> 00:03:59,640
small proof sizes let's say less than 50

116
00:03:59,640 --> 00:04:01,439
kilobytes

117
00:04:01,439 --> 00:04:03,180
and so this is what we focus on in this

118
00:04:03,180 --> 00:04:05,360
talk

119
00:04:05,519 --> 00:04:07,140
so what are the interesting statements

120
00:04:07,140 --> 00:04:10,200
well if one were to construct some

121
00:04:10,200 --> 00:04:12,180
privacy oriented primitive from lattices

122
00:04:12,180 --> 00:04:14,040
it makes sense that at some point some

123
00:04:14,040 --> 00:04:16,320
user or some entity will want to prove

124
00:04:16,320 --> 00:04:18,358
knowledge of some short Vector in the

125
00:04:18,358 --> 00:04:20,279
lattice so at the end of the day we

126
00:04:20,279 --> 00:04:22,320
consider statements of the form a s is

127
00:04:22,320 --> 00:04:24,360
equal to U

128
00:04:24,360 --> 00:04:24,900
um

129
00:04:24,900 --> 00:04:27,120
to some equation over submarine R let's

130
00:04:27,120 --> 00:04:28,919
say integers modular Q or some

131
00:04:28,919 --> 00:04:31,740
polynomial ring as usual and then the S

132
00:04:31,740 --> 00:04:33,960
which would be the secret information is

133
00:04:33,960 --> 00:04:35,880
some short Vector so it has either small

134
00:04:35,880 --> 00:04:39,000
Norms small coefficients and so on

135
00:04:39,000 --> 00:04:41,220
okay so this is like here we have some

136
00:04:41,220 --> 00:04:43,380
concrete example which we would call The

137
00:04:43,380 --> 00:04:45,060
Benchmark statement

138
00:04:45,060 --> 00:04:47,940
so prove that as is equal to U

139
00:04:47,940 --> 00:04:50,580
integers modular q q is around 2 to the

140
00:04:50,580 --> 00:04:52,380
32.

141
00:04:52,380 --> 00:04:56,340
um length of s is 2048 and Si's have uh

142
00:04:56,340 --> 00:04:58,620
ternary coefficients

143
00:04:58,620 --> 00:05:01,020
so now if we first look at the hospice

144
00:05:01,020 --> 00:05:03,419
proof systems then the Aurora gets

145
00:05:03,419 --> 00:05:06,120
around 70 kilobytes

146
00:05:06,120 --> 00:05:08,100
then we have the permutation base or

147
00:05:08,100 --> 00:05:10,320
combinatorial proofs where the best one

148
00:05:10,320 --> 00:05:12,660
achieves around 200 kilobytes

149
00:05:12,660 --> 00:05:15,180
and the last group which I call like NTT

150
00:05:15,180 --> 00:05:17,940
CRT packing proofs they already achieve

151
00:05:17,940 --> 00:05:19,680
less than 50 kilobytes

152
00:05:19,680 --> 00:05:21,860
so in the next few minutes I'll try to

153
00:05:21,860 --> 00:05:24,900
get some motivation and discuss

154
00:05:24,900 --> 00:05:26,639
advantages and disadvantages of these

155
00:05:26,639 --> 00:05:29,780
entity packing proofs

156
00:05:29,880 --> 00:05:32,699
okay so we need some uh well technical

157
00:05:32,699 --> 00:05:34,800
overview for that

158
00:05:34,800 --> 00:05:35,400
um

159
00:05:35,400 --> 00:05:37,500
okay so consider the standard polynomial

160
00:05:37,500 --> 00:05:40,740
ring RQ uh z q of X modular x to the D

161
00:05:40,740 --> 00:05:41,759
plus one

162
00:05:41,759 --> 00:05:44,280
where D is a power of two and now we

163
00:05:44,280 --> 00:05:46,380
want Q to be one mod 2D

164
00:05:46,380 --> 00:05:48,900
so why is it interesting because then we

165
00:05:48,900 --> 00:05:51,300
can write x to the D plus one uh write

166
00:05:51,300 --> 00:05:53,280
it as a product of linear terms x minus

167
00:05:53,280 --> 00:05:56,819
R1 x minus R2 Optics minus r d mod Q

168
00:05:56,819 --> 00:05:58,740
and we will call this our eyes roots of

169
00:05:58,740 --> 00:06:00,900
unity

170
00:06:00,900 --> 00:06:02,940
um and now given the polynomial a in our

171
00:06:02,940 --> 00:06:05,280
Q we can Define The Entity of a which

172
00:06:05,280 --> 00:06:07,500
stands for number theoretic transform

173
00:06:07,500 --> 00:06:09,840
we Define entity of a as the vector a

174
00:06:09,840 --> 00:06:12,539
hat which is just evaluations of a in

175
00:06:12,539 --> 00:06:15,479
the roots of unity so a of R1 a of R2 up

176
00:06:15,479 --> 00:06:17,400
to a of r d

177
00:06:17,400 --> 00:06:19,259
so we have a few nice properties of the

178
00:06:19,259 --> 00:06:21,539
entities so the first one is like pretty

179
00:06:21,539 --> 00:06:23,639
simple it's like entity of a plus b is

180
00:06:23,639 --> 00:06:26,340
equal to entity of a plus entity of B

181
00:06:26,340 --> 00:06:28,080
the second one let's say slightly

182
00:06:28,080 --> 00:06:30,479
slightly more interesting is that entity

183
00:06:30,479 --> 00:06:32,880
of a times B over RQ is equal to entity

184
00:06:32,880 --> 00:06:36,120
of a component wise brother entity of B

185
00:06:36,120 --> 00:06:38,759
so the main strength of um using the

186
00:06:38,759 --> 00:06:40,800
entity packing technique is that we can

187
00:06:40,800 --> 00:06:43,380
efficiently prove that coefficients of a

188
00:06:43,380 --> 00:06:46,139
vector lie in some specified some fixed

189
00:06:46,139 --> 00:06:49,020
range so to Showcase this idea suppose

190
00:06:49,020 --> 00:06:51,419
we want we have some Vector s

191
00:06:51,419 --> 00:06:53,039
and we want to prove that it has binary

192
00:06:53,039 --> 00:06:55,139
coefficients

193
00:06:55,139 --> 00:06:57,060
um so the idea is that we can write this

194
00:06:57,060 --> 00:07:00,060
Vector s you know S1 S2 up to SD let's

195
00:07:00,060 --> 00:07:00,840
say

196
00:07:00,840 --> 00:07:03,240
and I can I can find that some the

197
00:07:03,240 --> 00:07:06,000
so-called inverse entity so I can find

198
00:07:06,000 --> 00:07:08,639
the polynomial as check such that entity

199
00:07:08,639 --> 00:07:12,060
of s check is equal to uh to s

200
00:07:12,060 --> 00:07:15,120
and then I can subtract one as well so I

201
00:07:15,120 --> 00:07:17,220
have entity of abstract minus 1 is equal

202
00:07:17,220 --> 00:07:19,860
to the vector S1 minus one as two minus

203
00:07:19,860 --> 00:07:22,199
one up up to SD minus 1.

204
00:07:22,199 --> 00:07:24,419
and now if I multiply these uh these

205
00:07:24,419 --> 00:07:27,419
equations then we see that the um the

206
00:07:27,419 --> 00:07:29,759
vector s is binary coefficients if and

207
00:07:29,759 --> 00:07:31,380
only if the vector on the left hand side

208
00:07:31,380 --> 00:07:33,360
is a zero vector

209
00:07:33,360 --> 00:07:34,800
and on the right hand side we're just

210
00:07:34,800 --> 00:07:36,240
using the homomorphic properties of

211
00:07:36,240 --> 00:07:38,520
entities so we have entity of s check

212
00:07:38,520 --> 00:07:40,860
times let's check minus one

213
00:07:40,860 --> 00:07:43,500
so we actually reduce the problem of

214
00:07:43,500 --> 00:07:46,740
proving the binary to proving well the

215
00:07:46,740 --> 00:07:48,599
product proof so we prove that as check

216
00:07:48,599 --> 00:07:50,160
times this check minus 1 is equal to

217
00:07:50,160 --> 00:07:51,840
zero over R cubed

218
00:07:51,840 --> 00:07:54,539
so how do we do this

219
00:07:54,539 --> 00:07:55,139
um

220
00:07:55,139 --> 00:07:57,360
well we follow the commit and proof

221
00:07:57,360 --> 00:07:59,520
approach so we commit to S check we send

222
00:07:59,520 --> 00:08:00,900
a commitment to S check and then we

223
00:08:00,900 --> 00:08:03,060
prove some relations of

224
00:08:03,060 --> 00:08:06,360
uh as check however here is some caveats

225
00:08:06,360 --> 00:08:07,440
so

226
00:08:07,440 --> 00:08:09,180
even though the vector s had small

227
00:08:09,180 --> 00:08:11,699
coefficients well actually binary the

228
00:08:11,699 --> 00:08:13,379
polynomial as check might have actually

229
00:08:13,379 --> 00:08:15,599
large coefficients so you can't really

230
00:08:15,599 --> 00:08:17,759
use the standard I tie compressing

231
00:08:17,759 --> 00:08:20,580
commitment scheme but instead we need to

232
00:08:20,580 --> 00:08:22,199
use a slightly more advanced commitment

233
00:08:22,199 --> 00:08:24,240
which is the bdlo P homomorphic

234
00:08:24,240 --> 00:08:25,979
commitment

235
00:08:25,979 --> 00:08:29,460
so we committed to it using uh bdlop

236
00:08:29,460 --> 00:08:31,740
and now the idea is that okay I have

237
00:08:31,740 --> 00:08:33,360
some protocol at some point in the

238
00:08:33,360 --> 00:08:34,260
protocol

239
00:08:34,260 --> 00:08:36,179
um the verifier sends some polynomial

240
00:08:36,179 --> 00:08:39,599
Alpha and we send the mass opening as of

241
00:08:39,599 --> 00:08:41,399
a strike which is z equal to Y plus

242
00:08:41,399 --> 00:08:43,320
Alpha as check

243
00:08:43,320 --> 00:08:45,180
um yeah for zero knowledge

244
00:08:45,180 --> 00:08:47,940
and then the verifier can compute Z

245
00:08:47,940 --> 00:08:50,640
times Z minus Alpha so okay so why is it

246
00:08:50,640 --> 00:08:52,740
interesting because if we write this

247
00:08:52,740 --> 00:08:54,660
equation as a quadratic equation of

248
00:08:54,660 --> 00:08:56,940
alpha then the quadratic term is is

249
00:08:56,940 --> 00:08:58,560
literally what we want to prove it's

250
00:08:58,560 --> 00:09:00,839
zero

251
00:09:00,839 --> 00:09:02,760
um so we have this term as check times

252
00:09:02,760 --> 00:09:04,080
as check minus one which is in the

253
00:09:04,080 --> 00:09:06,240
quadratic term so in the end we just

254
00:09:06,240 --> 00:09:07,860
want to prove that the quadratic term in

255
00:09:07,860 --> 00:09:11,600
Z times minus Alpha vanishes

256
00:09:11,880 --> 00:09:16,140
so to do this well we uh we commit to y

257
00:09:16,140 --> 00:09:18,480
then we commit to the constant and to

258
00:09:18,480 --> 00:09:21,360
the linear terms in in Z times the minus

259
00:09:21,360 --> 00:09:22,260
Alpha

260
00:09:22,260 --> 00:09:24,240
then given the challenge Alpha I output

261
00:09:24,240 --> 00:09:27,839
Z equal to Y plus Alpha is check

262
00:09:27,839 --> 00:09:29,459
and then there are two things first we

263
00:09:29,459 --> 00:09:31,680
want to prove that Z is well formed the

264
00:09:31,680 --> 00:09:34,440
Z is indeed y plus Alpha is check and to

265
00:09:34,440 --> 00:09:36,540
do this we use the homomorphic property

266
00:09:36,540 --> 00:09:37,980
of the commitment scheme and prove that

267
00:09:37,980 --> 00:09:40,320
Z minus t y plus Alpha t s is a

268
00:09:40,320 --> 00:09:42,060
commitment to zero

269
00:09:42,060 --> 00:09:43,800
and then the second thing is actually

270
00:09:43,800 --> 00:09:45,600
what we wanted so we want to prove that

271
00:09:45,600 --> 00:09:47,580
the quadratic term in Z times minus

272
00:09:47,580 --> 00:09:48,860
Alpha vanishes

273
00:09:48,860 --> 00:09:51,300
and to do that we prove that Z times

274
00:09:51,300 --> 00:09:54,600
minus Alpha minus t 0 plus Alpha T1 is a

275
00:09:54,600 --> 00:09:56,279
commitment to zero

276
00:09:56,279 --> 00:09:58,380
so this is like a brief overview of the

277
00:09:58,380 --> 00:10:00,779
product proof

278
00:10:00,779 --> 00:10:03,360
so if we want to also prove some

279
00:10:03,360 --> 00:10:05,940
Benchmark relation we also want to prove

280
00:10:05,940 --> 00:10:07,980
the linear stock like some linear

281
00:10:07,980 --> 00:10:12,079
equations so let's say a s is equal to U

282
00:10:12,120 --> 00:10:14,160
um so I'm not going to provide the whole

283
00:10:14,160 --> 00:10:16,200
protocols just like before but take some

284
00:10:16,200 --> 00:10:20,279
intuition so again if the verifier sends

285
00:10:20,279 --> 00:10:22,200
Alpha and we send Z equal to Y plus

286
00:10:22,200 --> 00:10:23,519
Alpha as check

287
00:10:23,519 --> 00:10:25,980
then the key idea is that if Alpha is an

288
00:10:25,980 --> 00:10:28,500
integer then we can apply entities on

289
00:10:28,500 --> 00:10:30,899
both sides to obtain Zep Hub equal to Y

290
00:10:30,899 --> 00:10:33,300
hat plus alpha s and it's going to be S

291
00:10:33,300 --> 00:10:35,700
by construction and then because we have

292
00:10:35,700 --> 00:10:37,320
S on the right hand side we can multiply

293
00:10:37,320 --> 00:10:38,519
by a

294
00:10:38,519 --> 00:10:41,220
and we have a z hat is equal to a y hat

295
00:10:41,220 --> 00:10:42,839
plus Alpha U

296
00:10:42,839 --> 00:10:45,360
so the idea is that the verifier before

297
00:10:45,360 --> 00:10:48,240
sending the alpha uh the the proverb

298
00:10:48,240 --> 00:10:50,820
will send a y hat the verifier sends

299
00:10:50,820 --> 00:10:53,040
Alpha we send the Z and the verify it

300
00:10:53,040 --> 00:10:55,019
just checks that acet hat is equal to a

301
00:10:55,019 --> 00:10:56,940
y hat plus Alpha U

302
00:10:56,940 --> 00:10:58,920
so that's the intuition on the linear

303
00:10:58,920 --> 00:11:00,240
proof

304
00:11:00,240 --> 00:11:02,820
so that's basically the BLS 19 younger

305
00:11:02,820 --> 00:11:05,820
now 19 protocol from crypto19

306
00:11:05,820 --> 00:11:08,519
so what so with uh with this protocol we

307
00:11:08,519 --> 00:11:11,519
can prove uh so the authors proved The

308
00:11:11,519 --> 00:11:14,339
Benchmark equation in less than 400

309
00:11:14,339 --> 00:11:16,200
kilobytes

310
00:11:16,200 --> 00:11:17,760
so what are the bottlenecks of this

311
00:11:17,760 --> 00:11:18,720
approach

312
00:11:18,720 --> 00:11:20,820
so there are a few um yeah there are a

313
00:11:20,820 --> 00:11:22,680
few disadvantages so the first one is

314
00:11:22,680 --> 00:11:24,180
that we have to use the bdlo P

315
00:11:24,180 --> 00:11:26,760
commitment to commit to this S Check and

316
00:11:26,760 --> 00:11:28,440
it is relatively expensive and the

317
00:11:28,440 --> 00:11:30,839
reason is pretty simple because the size

318
00:11:30,839 --> 00:11:32,760
of the commitment is linear to the

319
00:11:32,760 --> 00:11:34,860
message size so if the message is long

320
00:11:34,860 --> 00:11:38,160
then the commitment is long as well

321
00:11:38,160 --> 00:11:40,440
so the second thing is like a more

322
00:11:40,440 --> 00:11:43,440
technical thing so um so in in these

323
00:11:43,440 --> 00:11:45,000
protocols at some point we want to prove

324
00:11:45,000 --> 00:11:47,579
validity of the commitment right so uh

325
00:11:47,579 --> 00:11:49,980
we perform some opening proof and a

326
00:11:49,980 --> 00:11:51,480
standard thing in let's base your

327
00:11:51,480 --> 00:11:53,160
knowledge proofs we need the condition

328
00:11:53,160 --> 00:11:56,160
that for the challenge space to for any

329
00:11:56,160 --> 00:11:58,260
two distinct challenges to be invertible

330
00:11:58,260 --> 00:11:59,940
over the ring

331
00:11:59,940 --> 00:12:02,100
and because we have x to the D plus one

332
00:12:02,100 --> 00:12:04,200
split into the linear terms

333
00:12:04,200 --> 00:12:06,540
um well picking such a space which such

334
00:12:06,540 --> 00:12:09,300
a set which has uh large sizes a bit

335
00:12:09,300 --> 00:12:11,519
challenging so the authors only picked a

336
00:12:11,519 --> 00:12:14,040
set of size 2D so the soundness error is

337
00:12:14,040 --> 00:12:16,939
around 1 over 2D

338
00:12:17,639 --> 00:12:19,800
uh next thing is that the approver had

339
00:12:19,800 --> 00:12:22,500
to send the vector Z and commit to the Y

340
00:12:22,500 --> 00:12:24,420
in the clear which could have the same

341
00:12:24,420 --> 00:12:27,060
length as s so again if s is long then

342
00:12:27,060 --> 00:12:31,019
sending this is also expensive

343
00:12:31,019 --> 00:12:33,420
and lastly well if we want to prove some

344
00:12:33,420 --> 00:12:36,000
degree K equation uh the prover has to

345
00:12:36,000 --> 00:12:38,399
send these K garbage commitments ti so

346
00:12:38,399 --> 00:12:39,959
in the previous slide we have degree 2

347
00:12:39,959 --> 00:12:42,300
equation and the approval had to send t0

348
00:12:42,300 --> 00:12:44,040
and T1

349
00:12:44,040 --> 00:12:47,519
so uh some of these things things got

350
00:12:47,519 --> 00:12:50,339
improved so the first of all we have the

351
00:12:50,339 --> 00:12:52,740
ALS 20 paper where they reduce the

352
00:12:52,740 --> 00:12:54,420
soundness error from 1 over 2D to one

353
00:12:54,420 --> 00:12:55,920
over Q

354
00:12:55,920 --> 00:12:57,839
they proposed a new product proof where

355
00:12:57,839 --> 00:13:00,060
we don't need to send the this Z and

356
00:13:00,060 --> 00:13:02,160
commit to the Y which is nice and also

357
00:13:02,160 --> 00:13:03,779
they reduced the number of garbage terms

358
00:13:03,779 --> 00:13:05,100
by one

359
00:13:05,100 --> 00:13:06,899
however if you still want to prove The

360
00:13:06,899 --> 00:13:08,579
Benchmark equation we still want to do

361
00:13:08,579 --> 00:13:11,279
the linear proof right and for this well

362
00:13:11,279 --> 00:13:12,839
using the previous Technique we will

363
00:13:12,839 --> 00:13:14,399
still need to send the Z and commit to

364
00:13:14,399 --> 00:13:15,540
the Y

365
00:13:15,540 --> 00:13:18,540
so the follow-up follow-up work uh you

366
00:13:18,540 --> 00:13:21,420
understand 20 presents a new linear

367
00:13:21,420 --> 00:13:23,700
proof where we don't need to send the Z

368
00:13:23,700 --> 00:13:26,579
and commit to the Y and by combining ALS

369
00:13:26,579 --> 00:13:29,459
20 with ens 20 we obtain a nice

370
00:13:29,459 --> 00:13:31,560
framework which can prove let's say The

371
00:13:31,560 --> 00:13:33,420
Benchmark statement in less than 50

372
00:13:33,420 --> 00:13:35,519
kilobytes

373
00:13:35,519 --> 00:13:38,820
however okay it's it's nice but what are

374
00:13:38,820 --> 00:13:41,040
the bottlenecks of this technique

375
00:13:41,040 --> 00:13:43,560
well we are still using the bdlop

376
00:13:43,560 --> 00:13:44,820
commitment right

377
00:13:44,820 --> 00:13:46,800
and uh well the soundness error is

378
00:13:46,800 --> 00:13:49,320
around one over Q so the this opening

379
00:13:49,320 --> 00:13:51,000
proof part it needs to be repeated for

380
00:13:51,000 --> 00:13:52,560
some less amplification

381
00:13:52,560 --> 00:13:55,860
and when Q was like 2 to the 32 then

382
00:13:55,860 --> 00:13:57,120
this part would need to be repeated

383
00:13:57,120 --> 00:13:58,980
let's say four times to to achieve

384
00:13:58,980 --> 00:14:00,899
negligible soundness

385
00:14:00,899 --> 00:14:02,880
and we can see that it's all the

386
00:14:02,880 --> 00:14:04,860
consequences of using the entity bagging

387
00:14:04,860 --> 00:14:07,560
technique why well because we wanted to

388
00:14:07,560 --> 00:14:10,199
pack things into the entities we had to

389
00:14:10,199 --> 00:14:12,060
deal with this as check polynomial which

390
00:14:12,060 --> 00:14:14,100
had large coefficients and to commit to

391
00:14:14,100 --> 00:14:16,980
it we had to use the bdlp commitment

392
00:14:16,980 --> 00:14:19,320
and also because we have this x to the D

393
00:14:19,320 --> 00:14:21,480
plus one uh being a product of linear

394
00:14:21,480 --> 00:14:23,519
terms the soundness it will be around 1

395
00:14:23,519 --> 00:14:25,199
over Q

396
00:14:25,199 --> 00:14:27,899
so um well the question is if we can

397
00:14:27,899 --> 00:14:30,420
construct a protocol without using these

398
00:14:30,420 --> 00:14:32,100
entity packing techniques which which

399
00:14:32,100 --> 00:14:35,880
are the limitation of uh of the protocol

400
00:14:35,880 --> 00:14:37,920
so I you could guess that if the answer

401
00:14:37,920 --> 00:14:39,660
was yes then I probably wouldn't be here

402
00:14:39,660 --> 00:14:42,720
so um so here we have the protocol so we

403
00:14:42,720 --> 00:14:45,060
in the paper we present new lattice

404
00:14:45,060 --> 00:14:46,680
based your knowledge framework where we

405
00:14:46,680 --> 00:14:48,420
don't need to rely on the entity packing

406
00:14:48,420 --> 00:14:49,980
technique and this comes with two

407
00:14:49,980 --> 00:14:52,079
immediate consequences so the first one

408
00:14:52,079 --> 00:14:54,540
is like it's one shot so I'm saying

409
00:14:54,540 --> 00:14:56,399
almost so there's like one part of the

410
00:14:56,399 --> 00:14:58,440
protocol where we need to repeat however

411
00:14:58,440 --> 00:15:00,540
for practical instances this doesn't

412
00:15:00,540 --> 00:15:02,220
cost much

413
00:15:02,220 --> 00:15:04,139
and also we can use the compressing

414
00:15:04,139 --> 00:15:06,060
commitment so it's fine for us to commit

415
00:15:06,060 --> 00:15:07,620
to Long vectors as long as they have

416
00:15:07,620 --> 00:15:10,160
small Norm

417
00:15:11,100 --> 00:15:13,380
um so here is the roadmap so the first

418
00:15:13,380 --> 00:15:15,959
thing is we introduced the abdulop

419
00:15:15,959 --> 00:15:18,360
commitment which as the name suggests

420
00:15:18,360 --> 00:15:21,300
combines the itai and bdlo P

421
00:15:21,300 --> 00:15:23,579
so the nice thing of combining these two

422
00:15:23,579 --> 00:15:25,620
is that if you want if you want to

423
00:15:25,620 --> 00:15:27,720
commit to a long Vector with a small

424
00:15:27,720 --> 00:15:29,699
Norm then we can put it in the eye type

425
00:15:29,699 --> 00:15:31,259
part of the commitment scheme so that

426
00:15:31,259 --> 00:15:32,699
it's compressing

427
00:15:32,699 --> 00:15:34,519
however we could see in the previous

428
00:15:34,519 --> 00:15:37,560
slides that sometimes we want to commit

429
00:15:37,560 --> 00:15:39,660
to these garbage terms like the

430
00:15:39,660 --> 00:15:42,120
Intermediate auxiliary uh polynomials

431
00:15:42,120 --> 00:15:44,519
which definitely don't have small Norm

432
00:15:44,519 --> 00:15:46,500
and for those we will commit them in the

433
00:15:46,500 --> 00:15:48,959
in the bdlo P part and because there are

434
00:15:48,959 --> 00:15:50,699
not many of them in practice then it's

435
00:15:50,699 --> 00:15:52,560
uh it's fine

436
00:15:52,560 --> 00:15:54,420
so that's like a nice combination of

437
00:15:54,420 --> 00:15:56,699
these two commitments

438
00:15:56,699 --> 00:15:59,940
so I hope you're still with me so um

439
00:15:59,940 --> 00:16:02,339
so the second thing is the uh proving

440
00:16:02,339 --> 00:16:05,279
quadratic relations over our queue so

441
00:16:05,279 --> 00:16:06,839
suppose

442
00:16:06,839 --> 00:16:09,420
we commit to some long Vector s and we

443
00:16:09,420 --> 00:16:11,100
want to prove that let's say s checked

444
00:16:11,100 --> 00:16:13,320
sorry s transpose s is equal to zero

445
00:16:13,320 --> 00:16:15,300
over our Cube

446
00:16:15,300 --> 00:16:16,139
um

447
00:16:16,139 --> 00:16:18,779
so well to do this well we can simply

448
00:16:18,779 --> 00:16:22,320
adapt the ALS 20 protocol and well you

449
00:16:22,320 --> 00:16:23,759
can just believe that it's it's simple

450
00:16:23,759 --> 00:16:26,519
because in the ALS 20 they deal with

451
00:16:26,519 --> 00:16:28,860
bdlop commitments here we have a video

452
00:16:28,860 --> 00:16:31,500
commitments so um it's pretty similar

453
00:16:31,500 --> 00:16:33,779
however we extend this approach to also

454
00:16:33,779 --> 00:16:35,699
proof quadratic equations which involve

455
00:16:35,699 --> 00:16:38,279
automorphisms so I know it sounds a bit

456
00:16:38,279 --> 00:16:40,320
random for now why why is it an

457
00:16:40,320 --> 00:16:43,079
interesting or useful so so it's instead

458
00:16:43,079 --> 00:16:45,180
of proving like quadratic equations like

459
00:16:45,180 --> 00:16:47,759
s transpose s equal to zero we can prove

460
00:16:47,759 --> 00:16:49,800
that for some public automorphism s

461
00:16:49,800 --> 00:16:52,920
transpose Sigma of s is equal to zero

462
00:16:52,920 --> 00:16:55,259
so but I hope in the next slide it will

463
00:16:55,259 --> 00:16:58,740
be more visible why it's interesting

464
00:16:58,740 --> 00:17:01,380
so the next step is we prove uh inner

465
00:17:01,380 --> 00:17:04,140
products over the queue so uh just first

466
00:17:04,140 --> 00:17:06,000
thing I want to say is that when I say

467
00:17:06,000 --> 00:17:08,220
in the products I mean that so because

468
00:17:08,220 --> 00:17:10,859
these things here are polynomial vectors

469
00:17:10,859 --> 00:17:12,900
when when I say in the products I mean

470
00:17:12,900 --> 00:17:14,699
take the coefficient vectors and do the

471
00:17:14,699 --> 00:17:16,559
inner products on them so the inner

472
00:17:16,559 --> 00:17:19,319
product is over CQ and not R Cube

473
00:17:19,319 --> 00:17:21,299
so suppose I commit to some long Vector

474
00:17:21,299 --> 00:17:22,740
s and I want to prove that the inner

475
00:17:22,740 --> 00:17:24,900
product of s and some public V is equal

476
00:17:24,900 --> 00:17:27,900
to zero or even the inner product of s

477
00:17:27,900 --> 00:17:31,020
with s is equal to something to B

478
00:17:31,020 --> 00:17:34,020
so to do this we use a pretty nice fact

479
00:17:34,020 --> 00:17:35,940
which is uh which has a very simple

480
00:17:35,940 --> 00:17:38,340
proof that there is a nice automorphism

481
00:17:38,340 --> 00:17:41,160
stigma such that for any X and Y the

482
00:17:41,160 --> 00:17:43,140
inner product of X and Y is the constant

483
00:17:43,140 --> 00:17:44,580
coefficient of the polynomial X

484
00:17:44,580 --> 00:17:46,740
transpose Sigma of Y

485
00:17:46,740 --> 00:17:48,960
so we kind of shifted the problem of pro

486
00:17:48,960 --> 00:17:51,000
of solving things of proving things over

487
00:17:51,000 --> 00:17:53,700
execute to proving things of RQ

488
00:17:53,700 --> 00:17:55,620
so for example if I want to prove that

489
00:17:55,620 --> 00:17:57,600
the inner product of X and Y is equal to

490
00:17:57,600 --> 00:17:59,280
zero I just prove that the constant

491
00:17:59,280 --> 00:18:01,380
coefficient of x transpose Sigma of Y is

492
00:18:01,380 --> 00:18:03,059
equal to zero

493
00:18:03,059 --> 00:18:04,679
and then to prove that the constant

494
00:18:04,679 --> 00:18:06,360
coefficient of a polynomial is zero we

495
00:18:06,360 --> 00:18:08,280
can adapt the technique from ens 20

496
00:18:08,280 --> 00:18:10,260
along with the product proof with

497
00:18:10,260 --> 00:18:12,240
automorphisms over RQ

498
00:18:12,240 --> 00:18:15,059
so I I hope it's clear why it's uh why

499
00:18:15,059 --> 00:18:16,559
this product proved with automorphisms

500
00:18:16,559 --> 00:18:18,720
is useful because the polynomial for

501
00:18:18,720 --> 00:18:19,980
which we want to prove the constant

502
00:18:19,980 --> 00:18:21,059
coefficient

503
00:18:21,059 --> 00:18:23,460
contains the automorphisms

504
00:18:23,460 --> 00:18:25,620
so that's that was the main motivation

505
00:18:25,620 --> 00:18:28,140
why we wanted to extend uh these

506
00:18:28,140 --> 00:18:30,419
quadratic equations

507
00:18:30,419 --> 00:18:32,520
okay so we can we know how to prove

508
00:18:32,520 --> 00:18:34,679
equations modular Q that's great we can

509
00:18:34,679 --> 00:18:36,419
prove quadratic equations we can prove

510
00:18:36,419 --> 00:18:40,320
in the products over zq but in this

511
00:18:40,320 --> 00:18:42,120
interest in many interesting statements

512
00:18:42,120 --> 00:18:43,440
there is some part which holds over

513
00:18:43,440 --> 00:18:45,480
integers like we want to prove that the

514
00:18:45,480 --> 00:18:47,220
coefficients are binary or we want to

515
00:18:47,220 --> 00:18:49,679
prove that the norm is something we

516
00:18:49,679 --> 00:18:50,940
don't want to prove that the norm is

517
00:18:50,940 --> 00:18:54,000
less than b mod Q right

518
00:18:54,000 --> 00:18:57,000
um so to this end we we apply

519
00:18:57,000 --> 00:18:59,100
approximate range proofs which in short

520
00:18:59,100 --> 00:19:01,740
allow us to to prove that some Vector

521
00:19:01,740 --> 00:19:04,440
has approximately small coefficients

522
00:19:04,440 --> 00:19:07,679
relative to the proof system modulus Q

523
00:19:07,679 --> 00:19:11,220
so why is it useful well because let's

524
00:19:11,220 --> 00:19:12,900
say if I want to prove that the norm of

525
00:19:12,900 --> 00:19:15,539
s squared is equal to B first I can

526
00:19:15,539 --> 00:19:17,520
prove that the norm of s squared which

527
00:19:17,520 --> 00:19:19,799
is the inner product of s with itself is

528
00:19:19,799 --> 00:19:21,419
equal to B mod Q

529
00:19:21,419 --> 00:19:23,580
and then if I prove that s has

530
00:19:23,580 --> 00:19:25,799
approximately small coefficients Then I

531
00:19:25,799 --> 00:19:27,660
then I show that there is no modular

532
00:19:27,660 --> 00:19:30,299
overflow overflow around so we can

533
00:19:30,299 --> 00:19:32,100
indeed prove that the norm of s squared

534
00:19:32,100 --> 00:19:33,780
is equal to B

535
00:19:33,780 --> 00:19:35,460
so that's how we prove the norms and

536
00:19:35,460 --> 00:19:37,140
also that's how we prove uh that the

537
00:19:37,140 --> 00:19:40,380
vector has binary coefficients

538
00:19:40,380 --> 00:19:42,299
okay and then we just obtain the

539
00:19:42,299 --> 00:19:43,740
framework by combining all these

540
00:19:43,740 --> 00:19:45,900
ingredients

541
00:19:45,900 --> 00:19:48,000
so I don't have much time to uh to

542
00:19:48,000 --> 00:19:50,460
discuss all of the applications but just

543
00:19:50,460 --> 00:19:53,400
like a a simple Benchmark type uh

544
00:19:53,400 --> 00:19:56,280
statement so just

545
00:19:56,280 --> 00:19:57,660
um so proving knowledge of the module

546
00:19:57,660 --> 00:20:00,299
FWE sample so what I mean is you know

547
00:20:00,299 --> 00:20:02,400
prove that you know small s of e such

548
00:20:02,400 --> 00:20:04,980
that A S Plus e is equal to U

549
00:20:04,980 --> 00:20:08,340
H so so thanks to the fact that we don't

550
00:20:08,340 --> 00:20:11,039
use this entity packing techniques uh we

551
00:20:11,039 --> 00:20:13,440
reduce the proof size from uh you know

552
00:20:13,440 --> 00:20:16,620
33 kilobytes to 14 which is a factor of

553
00:20:16,620 --> 00:20:18,659
more than a factor of two

554
00:20:18,659 --> 00:20:20,940
uh so in the paper we also have many

555
00:20:20,940 --> 00:20:22,740
other applications but I think I'm out

556
00:20:22,740 --> 00:20:25,140
of time uh but we have verifiable

557
00:20:25,140 --> 00:20:27,179
encryption group signatures and so on so

558
00:20:27,179 --> 00:20:28,860
we just show how to apply this framework

559
00:20:28,860 --> 00:20:32,340
in uh in constructing uh more advanced

560
00:20:32,340 --> 00:20:33,360
Primitives

561
00:20:33,360 --> 00:20:36,240
so um yeah so I will be happy to discuss

562
00:20:36,240 --> 00:20:39,000
uh the details in person but that's the

563
00:20:39,000 --> 00:20:40,559
end of my slides so thank you very much

564
00:20:40,559 --> 00:20:42,179
for listening

565
00:20:42,179 --> 00:20:44,659
great

566
00:20:47,600 --> 00:20:49,860
so thanks for the very nice talk you

567
00:20:49,860 --> 00:20:52,020
have a couple minutes for questions so

568
00:20:52,020 --> 00:20:53,880
please come up to the podium or chat on

569
00:20:53,880 --> 00:20:56,039
Zoom please can you say something about

570
00:20:56,039 --> 00:20:58,799
what's the interesting statement I mean

571
00:20:58,799 --> 00:21:01,200
most of what you said looks like you can

572
00:21:01,200 --> 00:21:03,480
prove any linear and quadratic relations

573
00:21:03,480 --> 00:21:06,299
on a bunch of variables yeah where does

574
00:21:06,299 --> 00:21:09,179
the uh which is sort of generic where

575
00:21:09,179 --> 00:21:11,340
does the efficiency constraint I mean

576
00:21:11,340 --> 00:21:13,980
what suppose I have an arbitrary system

577
00:21:13,980 --> 00:21:16,140
of linear input articulation what

578
00:21:16,140 --> 00:21:17,760
properties does this thing needs to have

579
00:21:17,760 --> 00:21:20,159
so that it's indeed small and fast and

580
00:21:20,159 --> 00:21:22,980
everything so so we can indeed prove

581
00:21:22,980 --> 00:21:24,720
like linear stuff and quadratic stuff

582
00:21:24,720 --> 00:21:26,700
but the thing is that we don't want to

583
00:21:26,700 --> 00:21:29,159
prove like big statements and the reason

584
00:21:29,159 --> 00:21:31,559
is that the proof system is still the

585
00:21:31,559 --> 00:21:33,360
proof site is still linear in the in the

586
00:21:33,360 --> 00:21:35,880
witness size so uh if you want to prove

587
00:21:35,880 --> 00:21:38,700
like something big like r1cs for like

588
00:21:38,700 --> 00:21:41,340
when I have this uh comparison with uh

589
00:21:41,340 --> 00:21:43,740
other works where the witness size is 2

590
00:21:43,740 --> 00:21:45,720
to the 20 then this could easily reach

591
00:21:45,720 --> 00:21:48,960
like megabytes so uh I I guess it is

592
00:21:48,960 --> 00:21:51,240
kind of generic enough but we we want to

593
00:21:51,240 --> 00:21:53,820
have the statement to be like uh still

594
00:21:53,820 --> 00:21:55,200
kind of small

595
00:21:55,200 --> 00:21:56,700
thing

596
00:21:56,700 --> 00:21:58,100
oh sorry

597
00:21:58,100 --> 00:22:00,360
see a small Witness

598
00:22:00,360 --> 00:22:03,260
yeah sorry

599
00:22:04,980 --> 00:22:07,200
yeah so in the the previous slide but

600
00:22:07,200 --> 00:22:09,179
yeah so here you're comparing this proof

601
00:22:09,179 --> 00:22:11,100
size of these different schemes but so

602
00:22:11,100 --> 00:22:12,480
these are different schemes so arguably

603
00:22:12,480 --> 00:22:14,820
they're using different uh and

604
00:22:14,820 --> 00:22:17,520
parameters in the underlying problems so

605
00:22:17,520 --> 00:22:19,020
I assume this is done for some common

606
00:22:19,020 --> 00:22:22,020
level of security uh

607
00:22:22,020 --> 00:22:24,659
um everything is uh for two to the minus

608
00:22:24,659 --> 00:22:28,460
128 120 okay

609
00:22:28,980 --> 00:22:32,580
oh do we have any more questions

610
00:22:32,580 --> 00:22:36,199
if not let's thank the speaker again

611
00:22:59,340 --> 00:23:01,620
all right so our next talk in this

612
00:23:01,620 --> 00:23:03,960
session is on lattice based snarts

613
00:23:03,960 --> 00:23:06,240
publicly verifiable pre-processing and

614
00:23:06,240 --> 00:23:08,460
recursively composable this is worked by

615
00:23:08,460 --> 00:23:11,400
Martin Albrecht valeriocini Russell Lai

616
00:23:11,400 --> 00:23:14,360
Julio malawota SRI aravadas

617
00:23:14,360 --> 00:23:18,620
and Valerio will give the talk

618
00:23:25,580 --> 00:23:28,500
all right thanks for the instruction but

619
00:23:28,500 --> 00:23:30,539
I said I will talk about latest based

620
00:23:30,539 --> 00:23:32,940
Knox with a bunch of nice properties The

621
00:23:32,940 --> 00:23:35,340
Joint work with the Martin Russell Julio

622
00:23:35,340 --> 00:23:37,380
and Marley

623
00:23:37,380 --> 00:23:38,820
so the structure of the talk is the

624
00:23:38,820 --> 00:23:40,679
following so I will first recall the

625
00:23:40,679 --> 00:23:43,200
definitions of 16 currently argument of

626
00:23:43,200 --> 00:23:45,179
knowledge and better commitments but we

627
00:23:45,179 --> 00:23:46,740
know about them in the literature and

628
00:23:46,740 --> 00:23:48,419
how these two Primitives relate to each

629
00:23:48,419 --> 00:23:50,640
other in particular I will show how we

630
00:23:50,640 --> 00:23:52,679
can compile a vector commitment with

631
00:23:52,679 --> 00:23:55,320
enough properties into a snark

632
00:23:55,320 --> 00:23:57,360
and then in the main part of the talk I

633
00:23:57,360 --> 00:23:59,460
will describe how we obtain a lattice

634
00:23:59,460 --> 00:24:01,140
based Vector commitment which of course

635
00:24:01,140 --> 00:24:03,000
opening two polynomial maps by

636
00:24:03,000 --> 00:24:04,440
translating a pairing-based construction

637
00:24:04,440 --> 00:24:06,539
to the logistat and this way we will

638
00:24:06,539 --> 00:24:10,020
also introduce a new set of assumptions

639
00:24:10,020 --> 00:24:12,779
in in the end I will also mention some

640
00:24:12,779 --> 00:24:15,480
other results that we have in the video

641
00:24:15,480 --> 00:24:17,940
okay so let's start with the first part

642
00:24:17,940 --> 00:24:20,700
to a snark sensor stands for succinct or

643
00:24:20,700 --> 00:24:22,679
interactive argument knowledge and they

644
00:24:22,679 --> 00:24:25,020
are system defined respect to some MP

645
00:24:25,020 --> 00:24:26,520
language level

646
00:24:26,520 --> 00:24:28,799
and that's not for a language L is

647
00:24:28,799 --> 00:24:30,600
defined by three algorithms setup group

648
00:24:30,600 --> 00:24:32,820
and verified and the interface is the

649
00:24:32,820 --> 00:24:34,679
following so we have a communication

650
00:24:34,679 --> 00:24:36,419
between a program and a verifier the

651
00:24:36,419 --> 00:24:38,159
board receives some public parameters by

652
00:24:38,159 --> 00:24:40,380
running the setup algorithm and then

653
00:24:40,380 --> 00:24:41,940
whenever the approver wants to prove to

654
00:24:41,940 --> 00:24:43,620
the verifier that some statement is in

655
00:24:43,620 --> 00:24:45,120
the language using the corresponding

656
00:24:45,120 --> 00:24:47,460
witness is going to run the roof to

657
00:24:47,460 --> 00:24:49,919
obtain some proof pi and the proof pi to

658
00:24:49,919 --> 00:24:51,960
the verifier and then the verifier can

659
00:24:51,960 --> 00:24:53,520
check this proof I against the public

660
00:24:53,520 --> 00:24:55,740
parameters and the statement and decide

661
00:24:55,740 --> 00:24:59,000
whether to accept a reject

662
00:24:59,279 --> 00:25:01,559
um this system required for different

663
00:25:01,559 --> 00:25:03,240
properties so the first one is

664
00:25:03,240 --> 00:25:05,220
completeness so whenever the Tuple

665
00:25:05,220 --> 00:25:06,960
statement weakness used by the boover

666
00:25:06,960 --> 00:25:08,820
actually satisfied the relationship and

667
00:25:08,820 --> 00:25:10,679
in the in the language L then the

668
00:25:10,679 --> 00:25:12,419
verifiers should accept

669
00:25:12,419 --> 00:25:14,100
on the other hand we also require some

670
00:25:14,100 --> 00:25:16,320
pharmaceutical and in our case we

671
00:25:16,320 --> 00:25:17,760
require knowledge sound

672
00:25:17,760 --> 00:25:21,600
so whenever the uh possibly a cheating

673
00:25:21,600 --> 00:25:23,760
proverb makes a very higher accept then

674
00:25:23,760 --> 00:25:26,159
we require that there are six extractor

675
00:25:26,159 --> 00:25:28,140
to extract the witness corresponding to

676
00:25:28,140 --> 00:25:29,460
the statement being proved from such

677
00:25:29,460 --> 00:25:31,380
address

678
00:25:31,380 --> 00:25:33,059
uh these two properties alone are

679
00:25:33,059 --> 00:25:34,679
trivial to achieve by having the prover

680
00:25:34,679 --> 00:25:36,179
just sending the witness to the verifier

681
00:25:36,179 --> 00:25:38,640
what makes the construction non-trivial

682
00:25:38,640 --> 00:25:40,679
are the efficiency requirements that we

683
00:25:40,679 --> 00:25:41,820
require

684
00:25:41,820 --> 00:25:44,100
so the first one uh concerns the

685
00:25:44,100 --> 00:25:45,480
communication between the approver and

686
00:25:45,480 --> 00:25:46,620
the verifier

687
00:25:46,620 --> 00:25:47,580
and

688
00:25:47,580 --> 00:25:49,799
um this is what we call succinctness and

689
00:25:49,799 --> 00:25:51,419
requires that the proof size should be

690
00:25:51,419 --> 00:25:52,860
poly logarithmic in the size of the

691
00:25:52,860 --> 00:25:53,940
statement

692
00:25:53,940 --> 00:25:56,520
and a requirements regarding the runtime

693
00:25:56,520 --> 00:25:57,960
of the verification is what we call

694
00:25:57,960 --> 00:26:00,600
pre-processing you're in an offline

695
00:26:00,600 --> 00:26:03,059
phase the verifier can pre-process the

696
00:26:03,059 --> 00:26:04,799
public parameters depending on the on

697
00:26:04,799 --> 00:26:06,779
the statement being proven and then

698
00:26:06,779 --> 00:26:08,700
using this pre-process public parameters

699
00:26:08,700 --> 00:26:10,500
the runtime of verification should be

700
00:26:10,500 --> 00:26:14,120
fully agreed between the size of this

701
00:26:15,179 --> 00:26:15,720
um

702
00:26:15,720 --> 00:26:18,480
so an overview of the snarks that we

703
00:26:18,480 --> 00:26:20,760
know from the literature if we consider

704
00:26:20,760 --> 00:26:22,260
publicly verifiable snacks for

705
00:26:22,260 --> 00:26:24,840
unstructured languages so circus set and

706
00:26:24,840 --> 00:26:26,880
r1cs for examples

707
00:26:26,880 --> 00:26:28,980
then we see that if we classify all the

708
00:26:28,980 --> 00:26:30,600
construction depending on these three

709
00:26:30,600 --> 00:26:32,760
properties so pre-processing algebraic

710
00:26:32,760 --> 00:26:35,340
and post Quantum whereby algebraic we

711
00:26:35,340 --> 00:26:37,380
mean that the only operation used in the

712
00:26:37,380 --> 00:26:39,120
construction are the algebraic operation

713
00:26:39,120 --> 00:26:41,039
from the underlying mathematical problem

714
00:26:41,039 --> 00:26:43,440
upon which the theme is built

715
00:26:43,440 --> 00:26:45,360
and by post Quantum in a very liberal

716
00:26:45,360 --> 00:26:46,740
sense we mean anything that is not

717
00:26:46,740 --> 00:26:48,900
trigly broken by quantum computers so

718
00:26:48,900 --> 00:26:50,460
anything that is not based on groups for

719
00:26:50,460 --> 00:26:51,480
example

720
00:26:51,480 --> 00:26:52,679
then we see that none of the

721
00:26:52,679 --> 00:26:54,120
construction achieves all these three

722
00:26:54,120 --> 00:26:55,860
properties at the same time

723
00:26:55,860 --> 00:26:58,320
and moreover if you're able to show that

724
00:26:58,320 --> 00:27:00,000
if you're able to construct a snark

725
00:27:00,000 --> 00:27:02,640
which is also a structure preserving to

726
00:27:02,640 --> 00:27:04,860
a snark where the relation check in the

727
00:27:04,860 --> 00:27:06,539
verification is supported by the snack

728
00:27:06,539 --> 00:27:08,880
itself then we get a construction that

729
00:27:08,880 --> 00:27:11,100
is friendly to record decomposition so a

730
00:27:11,100 --> 00:27:12,600
snark where you can improve knowledge of

731
00:27:12,600 --> 00:27:15,799
a snap-proof uh

732
00:27:16,380 --> 00:27:18,720
if we instead focus on lattice business

733
00:27:18,720 --> 00:27:21,240
for MP languages again for our

734
00:27:21,240 --> 00:27:23,039
structured MP languages then we see that

735
00:27:23,039 --> 00:27:24,840
either we achieve public verifiability

736
00:27:24,840 --> 00:27:26,760
or pre-processing

737
00:27:26,760 --> 00:27:28,919
so a natural question is if it's

738
00:27:28,919 --> 00:27:30,960
possible to construct a snark that

739
00:27:30,960 --> 00:27:32,399
achieves all these properties at the

740
00:27:32,399 --> 00:27:34,260
same time so which is post Quantum

741
00:27:34,260 --> 00:27:36,480
secure publicly verifiable reprocessing

742
00:27:36,480 --> 00:27:38,580
algebraic and structure preserving

743
00:27:38,580 --> 00:27:41,640
and this is uh what we achieved in in

744
00:27:41,640 --> 00:27:43,440
this work so we construct a logic space

745
00:27:43,440 --> 00:27:45,659
narc which has all these properties and

746
00:27:45,659 --> 00:27:47,039
therefore as I said is trending to

747
00:27:47,039 --> 00:27:48,600
record decomposition

748
00:27:48,600 --> 00:27:50,760
and surprisingly the mean and all

749
00:27:50,760 --> 00:27:52,380
ingredient to construct such a primitive

750
00:27:52,380 --> 00:27:54,120
is a lattice based Vector commitment

751
00:27:54,120 --> 00:27:56,340
which supports opening to constant

752
00:27:56,340 --> 00:27:58,200
degree multivariate polynomial

753
00:27:58,200 --> 00:27:59,820
and since this primitive is going to

754
00:27:59,820 --> 00:28:01,919
give us a snark which is a very powerful

755
00:28:01,919 --> 00:28:04,200
primitive we're not surprised we would

756
00:28:04,200 --> 00:28:05,640
like to introduce some new but natural

757
00:28:05,640 --> 00:28:07,320
lattice based knowledge and a knowledge

758
00:28:07,320 --> 00:28:09,600
assumption

759
00:28:09,600 --> 00:28:12,480
okay so let's let's now Define what a

760
00:28:12,480 --> 00:28:13,860
better commitment to functional opening

761
00:28:13,860 --> 00:28:14,940
is

762
00:28:14,940 --> 00:28:17,159
so this uh discriminative was introduced

763
00:28:17,159 --> 00:28:19,020
in 2016 and the interface of this

764
00:28:19,020 --> 00:28:20,520
primitive is similar to that of a snark

765
00:28:20,520 --> 00:28:22,080
so again we have interaction between

766
00:28:22,080 --> 00:28:24,120
approver and a verifier they put get

767
00:28:24,120 --> 00:28:25,500
some public parameters by running the

768
00:28:25,500 --> 00:28:26,820
setup algorithm

769
00:28:26,820 --> 00:28:29,100
and now the approver can commit to some

770
00:28:29,100 --> 00:28:30,779
better acts by running the commitment

771
00:28:30,779 --> 00:28:32,880
algorithm and let's send the commitment

772
00:28:32,880 --> 00:28:35,460
to the verifier in another stage then

773
00:28:35,460 --> 00:28:37,740
the Uber can decide to convince the

774
00:28:37,740 --> 00:28:39,720
verifier that the value committed in the

775
00:28:39,720 --> 00:28:42,779
commitment is such that f of x equals y

776
00:28:42,779 --> 00:28:44,940
for some function f supported by the

777
00:28:44,940 --> 00:28:47,640
vector commitment and some image value y

778
00:28:47,640 --> 00:28:49,679
and the approver can do this by running

779
00:28:49,679 --> 00:28:51,840
the by running the opening algorithm to

780
00:28:51,840 --> 00:28:53,940
obtain an opening proof pi and send this

781
00:28:53,940 --> 00:28:56,460
proof pi to the verifier the verifier

782
00:28:56,460 --> 00:28:58,500
can check its profile against the the

783
00:28:58,500 --> 00:29:00,960
Tuple function image FY and The Limited

784
00:29:00,960 --> 00:29:02,880
value account

785
00:29:02,880 --> 00:29:04,980
again this primitive will require a

786
00:29:04,980 --> 00:29:06,840
bunch of properties so the first one is

787
00:29:06,840 --> 00:29:08,760
correctness so we apply that whenever f

788
00:29:08,760 --> 00:29:10,679
of x actually equals y then the verifier

789
00:29:10,679 --> 00:29:11,880
should accept

790
00:29:11,880 --> 00:29:13,679
regarding the security of the of the

791
00:29:13,679 --> 00:29:15,000
Primitive we have three different

792
00:29:15,000 --> 00:29:16,799
properties in ascending order of a

793
00:29:16,799 --> 00:29:19,020
strand so the weakest one is what we

794
00:29:19,020 --> 00:29:21,299
call weak binding and requires that the

795
00:29:21,299 --> 00:29:23,399
proverb should be able to open a

796
00:29:23,399 --> 00:29:25,980
commitment to two different people's FY

797
00:29:25,980 --> 00:29:27,899
and FY Prime with quite different from y

798
00:29:27,899 --> 00:29:28,799
Prime

799
00:29:28,799 --> 00:29:30,779
has a very stronger property is binding

800
00:29:30,779 --> 00:29:32,700
and here we apply that the progression

801
00:29:32,700 --> 00:29:34,200
will be able to prove to open

802
00:29:34,200 --> 00:29:37,140
inconsistent to pull fiyi

803
00:29:37,140 --> 00:29:39,659
and even stronger requirement instead of

804
00:29:39,659 --> 00:29:42,179
extractability and here we replied that

805
00:29:42,179 --> 00:29:44,779
whenever the the Brewer is able to open

806
00:29:44,779 --> 00:29:48,779
a tuple FY then the resist an extractor

807
00:29:48,779 --> 00:29:50,940
that extracts and next such that f of x

808
00:29:50,940 --> 00:29:54,779
equals y and x is in the command

809
00:29:54,779 --> 00:29:56,880
regarding the efficiency requirement we

810
00:29:56,880 --> 00:29:58,700
can ask

811
00:29:58,700 --> 00:30:00,960
something regarding the size of the

812
00:30:00,960 --> 00:30:04,440
commitment and the size of the proof the

813
00:30:04,440 --> 00:30:05,460
first requirement is the world

814
00:30:05,460 --> 00:30:07,320
constantness and requires that both

815
00:30:07,320 --> 00:30:09,000
commitment and proof should be in size

816
00:30:09,000 --> 00:30:12,000
or logarithm in the size of the vector X

817
00:30:12,000 --> 00:30:14,039
that could be linear in the size of the

818
00:30:14,039 --> 00:30:15,840
image value y

819
00:30:15,840 --> 00:30:18,059
and the stronger requirement is what we

820
00:30:18,059 --> 00:30:19,919
call compactness and in this case what

821
00:30:19,919 --> 00:30:21,419
commit on a book should be poly

822
00:30:21,419 --> 00:30:23,640
logarithmic in size in the size of X and

823
00:30:23,640 --> 00:30:24,720
Y

824
00:30:24,720 --> 00:30:27,659
and similar to the snark we have a we

825
00:30:27,659 --> 00:30:29,640
have a properties called pre-processing

826
00:30:29,640 --> 00:30:32,460
with which requires as before that after

827
00:30:32,460 --> 00:30:34,260
pre-processing the public parameters the

828
00:30:34,260 --> 00:30:36,419
verification should be should run in

829
00:30:36,419 --> 00:30:37,980
time poly logarithmic again the size of

830
00:30:37,980 --> 00:30:40,580
X and Y

831
00:30:41,100 --> 00:30:42,720
um what we what do we know about this

832
00:30:42,720 --> 00:30:44,640
discriminative from the literature so

833
00:30:44,640 --> 00:30:46,740
there have been construction supporting

834
00:30:46,740 --> 00:30:49,740
opening to position functions so

835
00:30:49,740 --> 00:30:51,539
functions for f of x equals one of the

836
00:30:51,539 --> 00:30:53,039
entries of X and linear function so

837
00:30:53,039 --> 00:30:55,200
linear combination of the answers of x

838
00:30:55,200 --> 00:30:56,940
and this construction have been

839
00:30:56,940 --> 00:30:59,279
constructed from groups of one on order

840
00:30:59,279 --> 00:31:02,279
and periphany groups regarding the Greek

841
00:31:02,279 --> 00:31:03,779
Quantum Construction

842
00:31:03,779 --> 00:31:05,820
for post Quantum construction we have a

843
00:31:05,820 --> 00:31:08,279
construction from marker trees recently

844
00:31:08,279 --> 00:31:11,100
by Piper total Vector commitment

845
00:31:11,100 --> 00:31:13,620
supporting position openings from the

846
00:31:13,620 --> 00:31:15,480
hardness of sis

847
00:31:15,480 --> 00:31:16,740
however this post Quantum construction

848
00:31:16,740 --> 00:31:18,480
do not satisfy the compartments

849
00:31:18,480 --> 00:31:20,580
requirement that we stated before

850
00:31:20,580 --> 00:31:22,980
so again natural question is is it

851
00:31:22,980 --> 00:31:24,659
possible to construct better commitments

852
00:31:24,659 --> 00:31:26,460
which are post Quantum secure and

853
00:31:26,460 --> 00:31:28,980
compact or which supports opening to

854
00:31:28,980 --> 00:31:30,840
more than linear functions

855
00:31:30,840 --> 00:31:33,299
for example periodic polynomial and why

856
00:31:33,299 --> 00:31:35,760
would that be interesting well if we get

857
00:31:35,760 --> 00:31:37,500
such a vector commitment then we can

858
00:31:37,500 --> 00:31:39,840
compile it into a snap for MP and the

859
00:31:39,840 --> 00:31:42,179
idea is that the satisfiability of a

860
00:31:42,179 --> 00:31:43,799
system of quadratic equation is already

861
00:31:43,799 --> 00:31:45,779
an MP complete language

862
00:31:45,779 --> 00:31:47,279
so this language is defined as follow

863
00:31:47,279 --> 00:31:49,559
the statement would be Drupal FY where f

864
00:31:49,559 --> 00:31:51,659
is some quadratic polynomial map and

865
00:31:51,659 --> 00:31:53,039
then the witness would be an X

866
00:31:53,039 --> 00:31:55,080
Associated f of x equals y

867
00:31:55,080 --> 00:31:57,059
and then if we want to get a snark for

868
00:31:57,059 --> 00:31:58,860
such a language using a better

869
00:31:58,860 --> 00:32:00,480
commitment that supports opening to

870
00:32:00,480 --> 00:32:02,820
these functions the the construction

871
00:32:02,820 --> 00:32:05,159
will be the following so the the setup

872
00:32:05,159 --> 00:32:06,480
will be the same of the better

873
00:32:06,480 --> 00:32:08,519
commitment and then whenever the

874
00:32:08,519 --> 00:32:10,620
approver wants to prove that the Theta

875
00:32:10,620 --> 00:32:12,720
and FY is in the language using the

876
00:32:12,720 --> 00:32:14,580
witness text the proof is going to

877
00:32:14,580 --> 00:32:16,799
commit to X and then directly produce

878
00:32:16,799 --> 00:32:19,260
the opening proof I for the function f

879
00:32:19,260 --> 00:32:21,480
evaluated on X and then send this

880
00:32:21,480 --> 00:32:22,679
commitment together with the proof to

881
00:32:22,679 --> 00:32:24,899
the verifier and then the verifier can

882
00:32:24,899 --> 00:32:28,019
check the validity of this proof uh

883
00:32:28,019 --> 00:32:30,539
using a pre-processing phase offline

884
00:32:30,539 --> 00:32:32,100
Facebook

885
00:32:32,100 --> 00:32:34,620
and then we from this construction we

886
00:32:34,620 --> 00:32:36,000
see that the properties of the snork are

887
00:32:36,000 --> 00:32:37,260
in one-to-one respondents to the

888
00:32:37,260 --> 00:32:39,360
properties of the vector committee so

889
00:32:39,360 --> 00:32:40,440
the correctness of the virtual

890
00:32:40,440 --> 00:32:41,880
commitment implies the completed

891
00:32:41,880 --> 00:32:43,740
substance Arc the expressibility of the

892
00:32:43,740 --> 00:32:45,299
virtual commitment implies the knowledge

893
00:32:45,299 --> 00:32:47,580
soundness of this Arc compactness of the

894
00:32:47,580 --> 00:32:48,960
virtual commitment gives us the

895
00:32:48,960 --> 00:32:50,399
succinctness of the snark and then the

896
00:32:50,399 --> 00:32:51,600
pre-processing of the better commitment

897
00:32:51,600 --> 00:32:53,220
will give us the pre-processing of the

898
00:32:53,220 --> 00:32:55,679
scenario in this way we reduce the the

899
00:32:55,679 --> 00:32:57,840
task of constructing a snark for MP to

900
00:32:57,840 --> 00:32:58,980
that of constructing a virtual

901
00:32:58,980 --> 00:33:00,299
commitment with this uh with this

902
00:33:00,299 --> 00:33:02,100
property

903
00:33:02,100 --> 00:33:04,799
and and then now I will show how we we

904
00:33:04,799 --> 00:33:09,080
did this uh in in our work so the the

905
00:33:09,080 --> 00:33:12,179
roadmap will proceed in in fourth step

906
00:33:12,179 --> 00:33:13,980
uh since I do not have enough time I

907
00:33:13,980 --> 00:33:15,720
will just uh describe the first two step

908
00:33:15,720 --> 00:33:17,640
in detail and mention what we did in the

909
00:33:17,640 --> 00:33:19,320
in the last two

910
00:33:19,320 --> 00:33:21,539
so in the first step we are going to

911
00:33:21,539 --> 00:33:23,519
take a blueprint for constructing Vector

912
00:33:23,519 --> 00:33:25,740
commitments supporting opening to linear

913
00:33:25,740 --> 00:33:28,019
function instantiate this blueprint in

914
00:33:28,019 --> 00:33:29,399
the print setting and then translate

915
00:33:29,399 --> 00:33:31,260
this this construction to the latest

916
00:33:31,260 --> 00:33:33,720
setting while doing so we will also map

917
00:33:33,720 --> 00:33:35,220
the Assumption under which the frame

918
00:33:35,220 --> 00:33:37,559
based construction is uh is proven

919
00:33:37,559 --> 00:33:40,140
secure to the lattice setting and we

920
00:33:40,140 --> 00:33:42,480
will obtain uh some family of new

921
00:33:42,480 --> 00:33:43,740
assumption that we call Hearing in

922
00:33:43,740 --> 00:33:46,980
homogeneous sis or crisis for short

923
00:33:46,980 --> 00:33:48,720
and uh so in this first step we will

924
00:33:48,720 --> 00:33:50,100
obtain a better commitment which

925
00:33:50,100 --> 00:33:51,600
supports opening to linear function

926
00:33:51,600 --> 00:33:54,000
which is weak binding and succinct and

927
00:33:54,000 --> 00:33:55,620
then in each of the following steps we

928
00:33:55,620 --> 00:33:57,240
will improve all three of these

929
00:33:57,240 --> 00:33:58,980
properties till we end up with a better

930
00:33:58,980 --> 00:34:00,539
commitment with the properties that we

931
00:34:00,539 --> 00:34:03,480
required for the com

932
00:34:03,480 --> 00:34:05,340
Okay so

933
00:34:05,340 --> 00:34:07,860
before uh setting the the blueprint

934
00:34:07,860 --> 00:34:10,079
let's um let's set up some notation so

935
00:34:10,079 --> 00:34:11,940
in the pairing mode we will talk about

936
00:34:11,940 --> 00:34:15,300
some second group q1 G2 and GT where G1

937
00:34:15,300 --> 00:34:17,399
G2 will be the the so-called source

938
00:34:17,399 --> 00:34:19,619
group and GT will be the target group it

939
00:34:19,619 --> 00:34:21,540
will be the all the all of them will be

940
00:34:21,540 --> 00:34:24,359
of some primary queue we will use the

941
00:34:24,359 --> 00:34:26,219
NPC notation so that the generator or

942
00:34:26,219 --> 00:34:28,918
group I will be denoted by for bracket

943
00:34:28,918 --> 00:34:32,339
one index by I and in this way we will

944
00:34:32,339 --> 00:34:34,199
denote the group operation additively

945
00:34:34,199 --> 00:34:36,060
within each group and the pairing

946
00:34:36,060 --> 00:34:38,460
operation between uh elements of the

947
00:34:38,460 --> 00:34:41,040
different source group multiply and this

948
00:34:41,040 --> 00:34:43,918
can be also extended to Vector operation

949
00:34:43,918 --> 00:34:45,899
in the last setting we will have some

950
00:34:45,899 --> 00:34:49,020
ring R let me put some Norm so that we

951
00:34:49,020 --> 00:34:50,280
can talk about the shortness of element

952
00:34:50,280 --> 00:34:51,780
in this string

953
00:34:51,780 --> 00:34:54,060
we will fix some prime module skew and

954
00:34:54,060 --> 00:34:58,200
also work with the question bring RQ and

955
00:34:58,200 --> 00:34:59,880
then in the public parameters of the of

956
00:34:59,880 --> 00:35:02,160
the lattice board we will have some wide

957
00:35:02,160 --> 00:35:04,859
random Matrix a and some Target Vector T

958
00:35:04,859 --> 00:35:06,420
of the same height of the of the magic

959
00:35:06,420 --> 00:35:08,520
state

960
00:35:08,520 --> 00:35:11,579
okay so the W print for constructing a

961
00:35:11,579 --> 00:35:13,440
better commitment for linear function

962
00:35:13,440 --> 00:35:15,359
which is simply implicit in the

963
00:35:15,359 --> 00:35:17,579
literature as well is the following so

964
00:35:17,579 --> 00:35:21,720
we will fix some Vector B with length is

965
00:35:21,720 --> 00:35:23,160
the same as the length of the vector

966
00:35:23,160 --> 00:35:24,900
that we want to commit to

967
00:35:24,900 --> 00:35:28,200
and then we will think of the of the of

968
00:35:28,200 --> 00:35:31,619
the entries of the as some formal formal

969
00:35:31,619 --> 00:35:33,780
variables and we will Define polynomials

970
00:35:33,780 --> 00:35:36,660
and monomials over these variables

971
00:35:36,660 --> 00:35:39,359
we will Define some Target monomial and

972
00:35:39,359 --> 00:35:41,040
complement monomial so the target

973
00:35:41,040 --> 00:35:43,680
monomial will be denoted by B bar and in

974
00:35:43,680 --> 00:35:44,940
this example would be just the product

975
00:35:44,940 --> 00:35:48,060
of all the entries of the B for the V

976
00:35:48,060 --> 00:35:50,579
highs and then the complement monomials

977
00:35:50,579 --> 00:35:52,140
would be defined for each eye and

978
00:35:52,140 --> 00:35:54,839
denoted by b i bar and would be

979
00:35:54,839 --> 00:35:57,000
monomials or polynomials such that the I

980
00:35:57,000 --> 00:35:59,339
bar times pi equals Target normal P bar

981
00:35:59,339 --> 00:36:01,440
so in this case the bi bar would be the

982
00:36:01,440 --> 00:36:03,480
product over all J is different from I

983
00:36:03,480 --> 00:36:05,400
or BJs

984
00:36:05,400 --> 00:36:08,099
then we will have to Define some some

985
00:36:08,099 --> 00:36:10,500
encoding of the x that we want to commit

986
00:36:10,500 --> 00:36:12,900
to and the function f that we want to be

987
00:36:12,900 --> 00:36:15,900
able to open to and we will encode this

988
00:36:15,900 --> 00:36:19,200
uh this element as a polynomial P of X

989
00:36:19,200 --> 00:36:20,579
and P of f

990
00:36:20,579 --> 00:36:22,260
where the entities will somehow depend

991
00:36:22,260 --> 00:36:24,960
on X and F and we will evaluate this uh

992
00:36:24,960 --> 00:36:27,960
this polynomial on the variable cell

993
00:36:27,960 --> 00:36:30,300
and the goal of this encoding is such

994
00:36:30,300 --> 00:36:31,859
that when we take the the product of

995
00:36:31,859 --> 00:36:34,020
these two polynomial we are going to get

996
00:36:34,020 --> 00:36:36,300
another polynomial evaluated in B such

997
00:36:36,300 --> 00:36:38,520
that the coefficient of the target

998
00:36:38,520 --> 00:36:41,700
monomial D Bar is exactly f of x and

999
00:36:41,700 --> 00:36:43,560
then all the other across them since we

1000
00:36:43,560 --> 00:36:46,260
are thinking of these variables Vis as a

1001
00:36:46,260 --> 00:36:48,660
formal variables will be not in the span

1002
00:36:48,660 --> 00:36:49,920
of V bar

1003
00:36:49,920 --> 00:36:53,220
so for example we can take the

1004
00:36:53,220 --> 00:36:55,440
the following to encoding so the

1005
00:36:55,440 --> 00:36:57,480
encoding of f would be the linear

1006
00:36:57,480 --> 00:37:01,280
combination with uh of the target

1007
00:37:01,280 --> 00:37:04,020
complement monomial bar by coefficient

1008
00:37:04,020 --> 00:37:06,119
given by the coefficient of F and then

1009
00:37:06,119 --> 00:37:08,400
the encoding of X will be the linear

1010
00:37:08,400 --> 00:37:10,020
combination of the VJs we coefficient

1011
00:37:10,020 --> 00:37:12,540
given by the efficient of X and then

1012
00:37:12,540 --> 00:37:13,980
when we take the problem we exactly

1013
00:37:13,980 --> 00:37:17,000
agreed what we want

1014
00:37:17,040 --> 00:37:20,339
okay so now let's uh um instantiate this

1015
00:37:20,339 --> 00:37:22,400
this blueprint with the with a

1016
00:37:22,400 --> 00:37:25,560
independent word so the um we will

1017
00:37:25,560 --> 00:37:28,140
proceed in-step checking what we need in

1018
00:37:28,140 --> 00:37:29,700
each of the step of the vector

1019
00:37:29,700 --> 00:37:31,619
commitment and add the corresponding

1020
00:37:31,619 --> 00:37:33,359
elements to the public parameters of the

1021
00:37:33,359 --> 00:37:35,040
scheme

1022
00:37:35,040 --> 00:37:37,380
so in the commitment phase the the

1023
00:37:37,380 --> 00:37:39,420
approver is going to commit to the to

1024
00:37:39,420 --> 00:37:41,760
the vector packs using the the encoding

1025
00:37:41,760 --> 00:37:44,579
uh given that by the polynomial P of x

1026
00:37:44,579 --> 00:37:46,680
and so what the probability bias is the

1027
00:37:46,680 --> 00:37:49,320
encoding of this variables vjas so we

1028
00:37:49,320 --> 00:37:50,700
will add this to the public parameters

1029
00:37:50,700 --> 00:37:53,400
and then whenever the the verifier has

1030
00:37:53,400 --> 00:37:56,640
to check the the opening proof you will

1031
00:37:56,640 --> 00:37:58,079
have to compute the encoding of the

1032
00:37:58,079 --> 00:38:00,540
polynomial of the function f so we need

1033
00:38:00,540 --> 00:38:02,339
to give the encoding of the complement

1034
00:38:02,339 --> 00:38:04,920
monomials the VA bar in group two in the

1035
00:38:04,920 --> 00:38:06,359
public parameter so that the verified

1036
00:38:06,359 --> 00:38:07,680
can do that

1037
00:38:07,680 --> 00:38:09,420
and then using the the commitment

1038
00:38:09,420 --> 00:38:11,099
received by the approver

1039
00:38:11,099 --> 00:38:13,440
the the provider will compute the the

1040
00:38:13,440 --> 00:38:15,480
pairing between these two encoding and

1041
00:38:15,480 --> 00:38:16,680
then subtract

1042
00:38:16,680 --> 00:38:19,440
the the claim image value y times the

1043
00:38:19,440 --> 00:38:21,540
target monomial V bar

1044
00:38:21,540 --> 00:38:24,180
and if the if the if f of x actually is

1045
00:38:24,180 --> 00:38:25,920
pi then the difference should be not in

1046
00:38:25,920 --> 00:38:27,240
a spinal B Bar

1047
00:38:27,240 --> 00:38:29,460
and the verifier should be able to check

1048
00:38:29,460 --> 00:38:31,560
that using the proof obtained by the by

1049
00:38:31,560 --> 00:38:33,960
the broker so the proof will be exactly

1050
00:38:33,960 --> 00:38:37,140
what is required to to distract role so

1051
00:38:37,140 --> 00:38:39,599
we need to add also the the encoding

1052
00:38:39,599 --> 00:38:41,400
group two of this cross term in the

1053
00:38:41,400 --> 00:38:43,920
public parameters

1054
00:38:43,920 --> 00:38:46,200
okay so now let's try to translate the

1055
00:38:46,200 --> 00:38:47,880
misconstruction to the lucky setting for

1056
00:38:47,880 --> 00:38:49,680
starting with the public parameters so

1057
00:38:49,680 --> 00:38:50,940
these are the public parameters of the

1058
00:38:50,940 --> 00:38:53,280
print-based construction and then we

1059
00:38:53,280 --> 00:38:54,780
will map the generators of the the group

1060
00:38:54,780 --> 00:38:58,859
into these two uh uniform matrixes a and

1061
00:38:58,859 --> 00:39:00,599
the target Vector t

1062
00:39:00,599 --> 00:39:02,760
we will make all the variables Vijay

1063
00:39:02,760 --> 00:39:05,099
public so that anyone can compute on its

1064
00:39:05,099 --> 00:39:08,579
own uh the target monomial V bar and the

1065
00:39:08,579 --> 00:39:10,740
complement one of the Chas

1066
00:39:10,740 --> 00:39:13,680
and then we will translate the encoding

1067
00:39:13,680 --> 00:39:17,160
of the of the Cross terms AI bar of VJs

1068
00:39:17,160 --> 00:39:18,660
which are needed to compute the opening

1069
00:39:18,660 --> 00:39:21,720
proof into short uh

1070
00:39:21,720 --> 00:39:25,020
um short vectors uij such that a uij is

1071
00:39:25,020 --> 00:39:28,020
equal to VI bar v j times d

1072
00:39:28,020 --> 00:39:30,960
so we we get that the the

1073
00:39:30,960 --> 00:39:33,540
the public parties of the lattice based

1074
00:39:33,540 --> 00:39:35,760
schemes are given by 80 or The BJs and

1075
00:39:35,760 --> 00:39:38,339
these uijs which are short

1076
00:39:38,339 --> 00:39:40,020
vectors

1077
00:39:40,020 --> 00:39:42,599
and then the the construction gets

1078
00:39:42,599 --> 00:39:44,760
translated as follows so the public

1079
00:39:44,760 --> 00:39:47,099
parameters are what I said whenever the

1080
00:39:47,099 --> 00:39:49,859
approver wants to commit to some factor

1081
00:39:49,859 --> 00:39:51,720
x is going to compute the encoding of

1082
00:39:51,720 --> 00:39:54,839
the X of B which is using the linear

1083
00:39:54,839 --> 00:39:56,280
combination and The BJs in the public

1084
00:39:56,280 --> 00:39:58,859
parameter the verifier is going to

1085
00:39:58,859 --> 00:40:00,420
compute during the verification the

1086
00:40:00,420 --> 00:40:02,700
encoding of f using the elements in the

1087
00:40:02,700 --> 00:40:04,859
parameters and the the function path

1088
00:40:04,859 --> 00:40:06,780
then he's going to multiply this to

1089
00:40:06,780 --> 00:40:09,420
encoding and subtract the claim image

1090
00:40:09,420 --> 00:40:12,119
value y times this Vector the target

1091
00:40:12,119 --> 00:40:13,619
Vector P bar

1092
00:40:13,619 --> 00:40:16,560
and again if f of x equals y the

1093
00:40:16,560 --> 00:40:18,480
difference should be not in the spinal B

1094
00:40:18,480 --> 00:40:20,460
bar and this can be checked using the

1095
00:40:20,460 --> 00:40:22,920
proof user computed by the cover

1096
00:40:22,920 --> 00:40:24,960
and the proof computer program is going

1097
00:40:24,960 --> 00:40:26,819
to be just this linear combination of

1098
00:40:26,819 --> 00:40:29,640
this cross term using these vectors in

1099
00:40:29,640 --> 00:40:32,839
the public parameters uh

1100
00:40:33,180 --> 00:40:34,800
now that we have the construction we

1101
00:40:34,800 --> 00:40:36,060
have to also to translate the Assumption

1102
00:40:36,060 --> 00:40:37,920
under which the premise team is proven

1103
00:40:37,920 --> 00:40:40,200
secure to the lattice second so the the

1104
00:40:40,200 --> 00:40:42,180
Assumption under which the frame based

1105
00:40:42,180 --> 00:40:45,300
construction is proven with binding is

1106
00:40:45,300 --> 00:40:47,099
the following so given the elements in

1107
00:40:47,099 --> 00:40:49,200
the public parameters it's hard to find

1108
00:40:49,200 --> 00:40:53,099
the encoding of the target monomial

1109
00:40:53,099 --> 00:40:54,900
and then if we translate this to the

1110
00:40:54,900 --> 00:40:57,420
lattice world we will have that even the

1111
00:40:57,420 --> 00:40:59,220
elements in the public parameter it

1112
00:40:59,220 --> 00:41:00,900
should be hard to find a short per image

1113
00:41:00,900 --> 00:41:04,680
U such that a u equals D Bar times

1114
00:41:04,680 --> 00:41:06,780
however we will have to slightly

1115
00:41:06,780 --> 00:41:08,579
strengthen this this requirement and as

1116
00:41:08,579 --> 00:41:10,140
that is not only hard to find a sharp

1117
00:41:10,140 --> 00:41:12,359
image of P Bar times U but it's hard to

1118
00:41:12,359 --> 00:41:14,220
find a short per image of a small

1119
00:41:14,220 --> 00:41:16,740
multiple of B Bar times t

1120
00:41:16,740 --> 00:41:19,020
and this is a member of a new family of

1121
00:41:19,020 --> 00:41:20,760
assumption that we denoted the caring

1122
00:41:20,760 --> 00:41:23,220
and homogeneous short integer solution

1123
00:41:23,220 --> 00:41:25,380
and why why do we believe that this

1124
00:41:25,380 --> 00:41:27,359
assumption is possible uh so the

1125
00:41:27,359 --> 00:41:30,119
reasoning is as follows basically so

1126
00:41:30,119 --> 00:41:31,560
without the hints given in the public

1127
00:41:31,560 --> 00:41:33,660
parameters the the problem should be as

1128
00:41:33,660 --> 00:41:35,579
hard as arranged sis or ringing

1129
00:41:35,579 --> 00:41:37,740
homogeneous sis so the address is to

1130
00:41:37,740 --> 00:41:40,619
find a short image of a random vector

1131
00:41:40,619 --> 00:41:42,480
and similarly the only way to use the

1132
00:41:42,480 --> 00:41:43,980
ins is to perform short layer

1133
00:41:43,980 --> 00:41:47,099
combination of the ins given but but the

1134
00:41:47,099 --> 00:41:50,040
the vector uh the the image Vector B Bar

1135
00:41:50,040 --> 00:41:51,660
times t for which we have to find a

1136
00:41:51,660 --> 00:41:53,700
sharp image is not in the linear Sun of

1137
00:41:53,700 --> 00:41:56,400
the of the images of the ins given so

1138
00:41:56,400 --> 00:41:58,380
these ins should not help the adversary

1139
00:41:58,380 --> 00:42:01,400
to break the scheme

1140
00:42:01,500 --> 00:42:05,040
uh um now that we translated this

1141
00:42:05,040 --> 00:42:06,660
construction to the to the lattice board

1142
00:42:06,660 --> 00:42:08,520
we can exploit the structure of the of

1143
00:42:08,520 --> 00:42:10,740
the the ring on which we are now working

1144
00:42:10,740 --> 00:42:13,560
to be able to perform more than uh

1145
00:42:13,560 --> 00:42:15,839
opening to linear function and actually

1146
00:42:15,839 --> 00:42:18,420
achieve any polynomial boundary degree

1147
00:42:18,420 --> 00:42:21,599
and why are we restricted to linear

1148
00:42:21,599 --> 00:42:24,180
functions in the brain setting while uh

1149
00:42:24,180 --> 00:42:25,920
so the problem is that whenever the the

1150
00:42:25,920 --> 00:42:27,960
verifier pairs the commitment with the

1151
00:42:27,960 --> 00:42:30,599
encoding of that ends up with some

1152
00:42:30,599 --> 00:42:32,640
elements in the attractive group but the

1153
00:42:32,640 --> 00:42:33,839
only function that you can compute over

1154
00:42:33,839 --> 00:42:36,180
these elements are linear functions

1155
00:42:36,180 --> 00:42:38,160
and so the only functions that the

1156
00:42:38,160 --> 00:42:40,140
scheme can support are linear function

1157
00:42:40,140 --> 00:42:42,480
but now in the lattice setting when we

1158
00:42:42,480 --> 00:42:43,740
uh

1159
00:42:43,740 --> 00:42:45,900
product the the commitment with the with

1160
00:42:45,900 --> 00:42:48,240
encoding your path we still end up in in

1161
00:42:48,240 --> 00:42:51,420
the reading so we can allow ourselves to

1162
00:42:51,420 --> 00:42:53,460
um to open function more than a modern

1163
00:42:53,460 --> 00:42:56,640
year so quadratic for example

1164
00:42:56,640 --> 00:42:58,920
so I will briefly uh talk about the last

1165
00:42:58,920 --> 00:43:02,339
step so once we have a better commitment

1166
00:43:02,339 --> 00:43:04,440
which supports opening to polynomial map

1167
00:43:04,440 --> 00:43:06,960
which is succinct look at extractability

1168
00:43:06,960 --> 00:43:09,420
we have to introduce a a knowledgeable

1169
00:43:09,420 --> 00:43:11,760
version of the process assumption and

1170
00:43:11,760 --> 00:43:13,680
this is basically due to the impossible

1171
00:43:13,680 --> 00:43:16,319
results of

1172
00:43:16,319 --> 00:43:19,260
um ancient weeks which says that you

1173
00:43:19,260 --> 00:43:22,079
cannot get an Adaptive sound snark in a

1174
00:43:22,079 --> 00:43:23,940
plugless way from falsifiable assumption

1175
00:43:23,940 --> 00:43:26,040
so we have to introduce some non-fat

1176
00:43:26,040 --> 00:43:26,940
survival assumption to get

1177
00:43:26,940 --> 00:43:28,980
extractability and then once we have

1178
00:43:28,980 --> 00:43:31,260
extractability we can use an aggregation

1179
00:43:31,260 --> 00:43:33,720
trick that involves um embedding some

1180
00:43:33,720 --> 00:43:35,940
sis instances in the public parameter

1181
00:43:35,940 --> 00:43:37,980
and then whenever the the approver wants

1182
00:43:37,980 --> 00:43:39,900
to wants to prove to the to the verifier

1183
00:43:39,900 --> 00:43:42,540
a bunch of functions instead of proving

1184
00:43:42,540 --> 00:43:44,040
each function on its own it's going to

1185
00:43:44,040 --> 00:43:45,720
compress all this functions using the

1186
00:43:45,720 --> 00:43:48,119
the sis instance and then prove that

1187
00:43:48,119 --> 00:43:50,339
instead and you see the acceptability we

1188
00:43:50,339 --> 00:43:52,160
can get extractability for this uh

1189
00:43:52,160 --> 00:43:56,099
multi-version function of the scheme

1190
00:43:56,099 --> 00:43:59,040
and to conclude the further results that

1191
00:43:59,040 --> 00:44:01,260
we have in in the works we started the

1192
00:44:01,260 --> 00:44:02,940
hardness of this new family of

1193
00:44:02,940 --> 00:44:04,680
assumption that we introduce and in

1194
00:44:04,680 --> 00:44:05,940
particular we showed that there are

1195
00:44:05,940 --> 00:44:07,560
there exists are distances of this new

1196
00:44:07,560 --> 00:44:10,079
familial assumption where this km in

1197
00:44:10,079 --> 00:44:12,180
homogeneous is the module variant of the

1198
00:44:12,180 --> 00:44:14,160
of the version

1199
00:44:14,160 --> 00:44:15,900
and we also study relation between

1200
00:44:15,900 --> 00:44:18,119
different parameter regime for these

1201
00:44:18,119 --> 00:44:20,400
assumptions however I should I should

1202
00:44:20,400 --> 00:44:22,020
notice that none of these reduction

1203
00:44:22,020 --> 00:44:24,000
covers the parameters that we use in our

1204
00:44:24,000 --> 00:44:26,700
skin so actually the scheme relies on a

1205
00:44:26,700 --> 00:44:28,260
new set of assumptions

1206
00:44:28,260 --> 00:44:30,900
and we also discussed some possible

1207
00:44:30,900 --> 00:44:33,000
application of our snark in particular

1208
00:44:33,000 --> 00:44:35,040
since the snacks of course checking a

1209
00:44:35,040 --> 00:44:36,660
linear function and quadratic function

1210
00:44:36,660 --> 00:44:40,160
it natively supports the the

1211
00:44:40,160 --> 00:44:42,119
verification equation of the gbb

1212
00:44:42,119 --> 00:44:44,400
signature and as I said it's also trying

1213
00:44:44,400 --> 00:44:46,260
to to recursive composition even the

1214
00:44:46,260 --> 00:44:47,940
properties that it has

1215
00:44:47,940 --> 00:44:50,640
and with that I conclude that I'm happy

1216
00:44:50,640 --> 00:44:53,180
to take questions

1217
00:44:58,920 --> 00:45:00,960
great thanks for the talk so we have

1218
00:45:00,960 --> 00:45:02,880
time for one or two questions so if you

1219
00:45:02,880 --> 00:45:05,640
have any please come up to the podium

1220
00:45:05,640 --> 00:45:07,800
so I'll start with one question can you

1221
00:45:07,800 --> 00:45:09,420
comment on whether you can extend your

1222
00:45:09,420 --> 00:45:10,680
construction to achieve their own

1223
00:45:10,680 --> 00:45:12,720
knowledge as well

1224
00:45:12,720 --> 00:45:14,700
um yeah we tried

1225
00:45:14,700 --> 00:45:16,980
um kind of still working on it we think

1226
00:45:16,980 --> 00:45:21,319
it's doable but not so easy

1227
00:45:23,280 --> 00:45:26,060
questions yep

1228
00:45:26,060 --> 00:45:28,980
hi so uh thanks for your talk

1229
00:45:28,980 --> 00:45:30,720
um I have a question so

1230
00:45:30,720 --> 00:45:33,660
um what are the challenges to uh how to

1231
00:45:33,660 --> 00:45:35,940
decrease the CRS or like public

1232
00:45:35,940 --> 00:45:38,579
parameters size from quadratic to linear

1233
00:45:38,579 --> 00:45:40,560
because now it's quadratic right yeah

1234
00:45:40,560 --> 00:45:43,260
yeah so the problem is that uh so the

1235
00:45:43,260 --> 00:45:45,240
the parameter size increases financially

1236
00:45:45,240 --> 00:45:47,160
with the degree of the polynomial that

1237
00:45:47,160 --> 00:45:49,619
you want to support but that's why we we

1238
00:45:49,619 --> 00:45:53,119
restrict ourselves to boundary

1239
00:45:54,140 --> 00:45:57,680
okay thanks

1240
00:45:58,319 --> 00:46:00,660
so one more question so I think uh in

1241
00:46:00,660 --> 00:46:02,339
your talk you describe almost a general

1242
00:46:02,339 --> 00:46:04,380
framework for compact for compiling a

1243
00:46:04,380 --> 00:46:05,700
pairing based construction into a

1244
00:46:05,700 --> 00:46:07,440
lattice based one are you able to apply

1245
00:46:07,440 --> 00:46:09,300
your type of techniques to other pairing

1246
00:46:09,300 --> 00:46:10,500
based constructions for which we

1247
00:46:10,500 --> 00:46:11,640
currently don't have ladder space

1248
00:46:11,640 --> 00:46:16,319
analogs uh yeah again we we are kind of

1249
00:46:16,319 --> 00:46:18,839
working on it and I'm not sure if we can

1250
00:46:18,839 --> 00:46:22,440
achieve uh something but we will

1251
00:46:22,440 --> 00:46:24,599
okay sounds good

1252
00:46:24,599 --> 00:46:26,099
all right so if there's no further

1253
00:46:26,099 --> 00:46:29,599
questions let's thank the speaker again

1254
00:47:09,359 --> 00:47:12,300
okay so our final talk in this session

1255
00:47:12,300 --> 00:47:14,520
will be on practical sublinear proofs

1256
00:47:14,520 --> 00:47:17,880
for r1cs from lattices by Khan nguin and

1257
00:47:17,880 --> 00:47:20,099
Gregor sealer and Gregor will be given

1258
00:47:20,099 --> 00:47:22,339
talk

1259
00:47:23,700 --> 00:47:26,760
oh do you hear me yeah perfect

1260
00:47:26,760 --> 00:47:28,500
um yeah thank you very much for the

1261
00:47:28,500 --> 00:47:32,160
introduction I'm Greg rosala and I'm

1262
00:47:32,160 --> 00:47:33,599
going to present a paper together with

1263
00:47:33,599 --> 00:47:37,200
Khan that you will now know and yeah who

1264
00:47:37,200 --> 00:47:39,300
gave the first talk in the in the

1265
00:47:39,300 --> 00:47:40,800
session but of course about a different

1266
00:47:40,800 --> 00:47:42,420
paper

1267
00:47:42,420 --> 00:47:44,160
so now I need to figure out how this

1268
00:47:44,160 --> 00:47:45,059
works

1269
00:47:45,059 --> 00:47:47,940
yeah perfect okay so

1270
00:47:47,940 --> 00:47:49,859
um we have seen a couple of the

1271
00:47:49,859 --> 00:47:51,359
knowledge talks already in this session

1272
00:47:51,359 --> 00:47:53,400
so I don't really have to repeat what

1273
00:47:53,400 --> 00:47:55,740
does your knowledge proof system is

1274
00:47:55,740 --> 00:47:57,240
um just very briefly what I want to say

1275
00:47:57,240 --> 00:47:59,160
is that basically a very common

1276
00:47:59,160 --> 00:48:01,740
structure how proof systems are

1277
00:48:01,740 --> 00:48:03,720
constructed is that one uses the

1278
00:48:03,720 --> 00:48:05,520
commitment scheme to commit to some

1279
00:48:05,520 --> 00:48:07,800
Vector over some finite field let's call

1280
00:48:07,800 --> 00:48:10,800
it s and then somehow the commitment

1281
00:48:10,800 --> 00:48:15,720
scheme I must allow to prove say linear

1282
00:48:15,720 --> 00:48:18,059
and and quadratic relations on the

1283
00:48:18,059 --> 00:48:20,819
vector coefficients and if one has these

1284
00:48:20,819 --> 00:48:22,319
two ingredients then one can actually

1285
00:48:22,319 --> 00:48:25,579
prove that the vector as

1286
00:48:25,579 --> 00:48:28,260
satisfy some arbitrary arithmetic

1287
00:48:28,260 --> 00:48:30,240
circuit and an arithmetic circuit is

1288
00:48:30,240 --> 00:48:32,119
just a circuit where the gates are

1289
00:48:32,119 --> 00:48:34,380
multiplication and addition Gates over

1290
00:48:34,380 --> 00:48:36,900
some finite fields

1291
00:48:36,900 --> 00:48:39,059
um yeah so this is really the setting

1292
00:48:39,059 --> 00:48:41,339
we're interested in in the talk so we

1293
00:48:41,339 --> 00:48:43,079
really want to construct a proof system

1294
00:48:43,079 --> 00:48:45,660
for arbitrary circuits

1295
00:48:45,660 --> 00:48:47,520
um as opposed to maybe the more

1296
00:48:47,520 --> 00:48:49,740
specialized view that that Khan had in

1297
00:48:49,740 --> 00:48:52,800
his talk where where he centered or to

1298
00:48:52,800 --> 00:48:55,740
towards yeah relations or basically

1299
00:48:55,740 --> 00:48:57,660
statements that that are important in

1300
00:48:57,660 --> 00:49:00,319
the letter setting

1301
00:49:00,540 --> 00:49:03,180
um so now if we focus on lattice based

1302
00:49:03,180 --> 00:49:06,119
constructions then Khan has already gone

1303
00:49:06,119 --> 00:49:08,579
into much detail here I just want to

1304
00:49:08,579 --> 00:49:11,460
repeat that there has been quite quite a

1305
00:49:11,460 --> 00:49:13,740
lot of improvements in the last three to

1306
00:49:13,740 --> 00:49:15,000
four years in the construction of

1307
00:49:15,000 --> 00:49:17,460
so-called linear size Pro systems so

1308
00:49:17,460 --> 00:49:19,980
there uh the the proof size scales

1309
00:49:19,980 --> 00:49:21,900
linearly with a with the witness size

1310
00:49:21,900 --> 00:49:23,460
and then if it looks what the proof size

1311
00:49:23,460 --> 00:49:24,900
is for some particular reference

1312
00:49:24,900 --> 00:49:27,240
statement that Khan has also introduced

1313
00:49:27,240 --> 00:49:29,760
then basically the the situation five

1314
00:49:29,760 --> 00:49:32,579
years ago was that yeah the state of the

1315
00:49:32,579 --> 00:49:35,280
art was was a proof size of almost four

1316
00:49:35,280 --> 00:49:38,460
megabytes and then this was improved in

1317
00:49:38,460 --> 00:49:40,680
2019 by a factor of 10 and then another

1318
00:49:40,680 --> 00:49:44,099
factor of 10 in 2020 and 21 and now Khan

1319
00:49:44,099 --> 00:49:45,720
presented essentially the last iteration

1320
00:49:45,720 --> 00:49:47,520
in this development where there's

1321
00:49:47,520 --> 00:49:49,920
another factor of two or so Improvement

1322
00:49:49,920 --> 00:49:54,359
so yeah so this is a stage of linear

1323
00:49:54,359 --> 00:49:56,040
size proof systems and now these linear

1324
00:49:56,040 --> 00:49:58,079
size proof systems there may be somewhat

1325
00:49:58,079 --> 00:50:02,460
surprisingly useful in applications and

1326
00:50:02,460 --> 00:50:04,740
and one very important

1327
00:50:04,740 --> 00:50:06,780
um yeah basically a set of implications

1328
00:50:06,780 --> 00:50:09,180
are privacy preserving cryptographic

1329
00:50:09,180 --> 00:50:10,800
schemes so for example think about a

1330
00:50:10,800 --> 00:50:13,020
group signature scheme in the standard

1331
00:50:13,020 --> 00:50:14,339
construction of a group signature you

1332
00:50:14,339 --> 00:50:16,859
need to prove that you know a signature

1333
00:50:16,859 --> 00:50:19,140
and a linear size system is is really

1334
00:50:19,140 --> 00:50:22,740
good for this and the reason is that one

1335
00:50:22,740 --> 00:50:25,020
can essentially design the underlying

1336
00:50:25,020 --> 00:50:27,960
signature scheme such that the witness

1337
00:50:27,960 --> 00:50:29,760
that when is the proof is so small that

1338
00:50:29,760 --> 00:50:31,260
the linear linear scaling of the proof

1339
00:50:31,260 --> 00:50:33,480
system doesn't matter and when it gets

1340
00:50:33,480 --> 00:50:36,540
nice uh basically schemes a very

1341
00:50:36,540 --> 00:50:39,420
practical sizes in the end but there's a

1342
00:50:39,420 --> 00:50:41,760
there's a big drawback to this because

1343
00:50:41,760 --> 00:50:44,940
one really has to design

1344
00:50:44,940 --> 00:50:47,160
um or use essentially tailor-made

1345
00:50:47,160 --> 00:50:48,960
underlying schemes for this because for

1346
00:50:48,960 --> 00:50:51,240
example uh these signature schemes need

1347
00:50:51,240 --> 00:50:52,920
to be standard model one can't use the

1348
00:50:52,920 --> 00:50:55,140
random Oracle model because proving the

1349
00:50:55,140 --> 00:50:56,339
hash function would result in a

1350
00:50:56,339 --> 00:50:58,740
Witnesses is much too much too big and

1351
00:50:58,740 --> 00:51:00,960
so what ends up with the schemes that

1352
00:51:00,960 --> 00:51:03,599
they wouldn't never be used outside of

1353
00:51:03,599 --> 00:51:07,260
of these privacy preserving schemes so a

1354
00:51:07,260 --> 00:51:08,940
much better situation would be if one

1355
00:51:08,940 --> 00:51:11,040
could just use some some standard

1356
00:51:11,040 --> 00:51:12,720
signature like for example the lithium

1357
00:51:12,720 --> 00:51:14,579
or Falcon that are now coming out of the

1358
00:51:14,579 --> 00:51:17,640
Mist competition and and just basically

1359
00:51:17,640 --> 00:51:19,079
use them as a black box and then maybe

1360
00:51:19,079 --> 00:51:21,599
also Black Box proof system uh that that

1361
00:51:21,599 --> 00:51:25,380
just proves proves these schemes and so

1362
00:51:25,380 --> 00:51:27,780
in this paper this is basically what we

1363
00:51:27,780 --> 00:51:29,339
hope to achieve maybe not already with

1364
00:51:29,339 --> 00:51:31,200
this paper but in the long run that we

1365
00:51:31,200 --> 00:51:32,220
have

1366
00:51:32,220 --> 00:51:34,440
um uh yeah very practical sublinear

1367
00:51:34,440 --> 00:51:35,760
letter space proof system so that we

1368
00:51:35,760 --> 00:51:37,440
don't have to care about about the

1369
00:51:37,440 --> 00:51:39,359
witness size anymore and yeah in this

1370
00:51:39,359 --> 00:51:40,859
paper we make essentially the first step

1371
00:51:40,859 --> 00:51:42,960
into this and that we really have a

1372
00:51:42,960 --> 00:51:44,700
somewhat practical sub-linear life space

1373
00:51:44,700 --> 00:51:47,280
proof system and now the question is

1374
00:51:47,280 --> 00:51:48,599
what happens to all these techniques

1375
00:51:48,599 --> 00:51:51,780
that were developed for uh the linear

1376
00:51:51,780 --> 00:51:53,460
size system and in fact basically

1377
00:51:53,460 --> 00:51:55,200
everything that we have developed for

1378
00:51:55,200 --> 00:51:56,880
the linear size proof systems is going

1379
00:51:56,880 --> 00:51:59,339
to be useful and certainly used in

1380
00:51:59,339 --> 00:52:00,720
basically our scheme now but I think

1381
00:52:00,720 --> 00:52:02,700
also in Future these techniques will be

1382
00:52:02,700 --> 00:52:05,640
useful and also the in science we have

1383
00:52:05,640 --> 00:52:07,079
gained

1384
00:52:07,079 --> 00:52:09,839
okay so I'm now to be to start to be a

1385
00:52:09,839 --> 00:52:11,400
bit more technical

1386
00:52:11,400 --> 00:52:14,099
um so in essentially every lutter space

1387
00:52:14,099 --> 00:52:16,440
your knowledge protocol somewhere at the

1388
00:52:16,440 --> 00:52:19,140
core is what we call an approximate

1389
00:52:19,140 --> 00:52:20,099
proof

1390
00:52:20,099 --> 00:52:22,079
and an approximate proof is the

1391
00:52:22,079 --> 00:52:24,420
following so if one has a lot of space

1392
00:52:24,420 --> 00:52:26,099
commitment and this is nothing else and

1393
00:52:26,099 --> 00:52:28,800
just a linear function a times s where s

1394
00:52:28,800 --> 00:52:31,260
is some Vector that has short Norm so we

1395
00:52:31,260 --> 00:52:34,440
just say that s is short then an

1396
00:52:34,440 --> 00:52:36,180
approximate proof is essentially some

1397
00:52:36,180 --> 00:52:40,319
variant of this signal protocol where

1398
00:52:40,319 --> 00:52:42,480
um yeah the the approver samples are

1399
00:52:42,480 --> 00:52:44,040
masking Vector y commits to it by

1400
00:52:44,040 --> 00:52:46,260
sending a y and then gets a challenge

1401
00:52:46,260 --> 00:52:48,900
from from the from the verifier that is

1402
00:52:48,900 --> 00:52:50,520
a very small polynomial so all the

1403
00:52:50,520 --> 00:52:51,960
coefficients are for example minus one

1404
00:52:51,960 --> 00:52:54,420
zero and one and then the proverb

1405
00:52:54,420 --> 00:52:56,700
replies with what we call a masked

1406
00:52:56,700 --> 00:52:59,099
opening and this is just y plus Cs and

1407
00:52:59,099 --> 00:53:01,079
since everything is small also this this

1408
00:53:01,079 --> 00:53:03,000
mask opening Z will be small so the

1409
00:53:03,000 --> 00:53:04,740
verify I can check that Z is small and

1410
00:53:04,740 --> 00:53:07,260
then also this equation is that it's

1411
00:53:07,260 --> 00:53:09,599
equal to W Plus CT and then this is the

1412
00:53:09,599 --> 00:53:11,040
whole protocol

1413
00:53:11,040 --> 00:53:15,000
um this is sound in that it proves in in

1414
00:53:15,000 --> 00:53:16,559
knowledge of an opening to the

1415
00:53:16,559 --> 00:53:18,119
commitment

1416
00:53:18,119 --> 00:53:19,800
um because it is actually special sound

1417
00:53:19,800 --> 00:53:21,720
so if we have two accepting transcript

1418
00:53:21,720 --> 00:53:23,520
we just subtract the verification

1419
00:53:23,520 --> 00:53:26,339
equation and then we get this or this is

1420
00:53:26,339 --> 00:53:28,819
what I wanted

1421
00:53:29,099 --> 00:53:32,160
um yeah so if we just subtract to a

1422
00:53:32,160 --> 00:53:33,540
verification equation we get this

1423
00:53:33,540 --> 00:53:35,940
equation uh on the bottom of the slides

1424
00:53:35,940 --> 00:53:38,400
or not really at the bottom the c bar T

1425
00:53:38,400 --> 00:53:41,700
equals a times z bar and this is what we

1426
00:53:41,700 --> 00:53:44,220
call an approximate commitment opening

1427
00:53:44,220 --> 00:53:46,859
because compared to the actual kind of

1428
00:53:46,859 --> 00:53:48,540
commitment there's this additional

1429
00:53:48,540 --> 00:53:51,180
factor of c bar and then also this c bar

1430
00:53:51,180 --> 00:53:54,480
this pre-image for a is is much longer

1431
00:53:54,480 --> 00:53:56,579
than S but it turns out that the

1432
00:53:56,579 --> 00:53:59,640
commitment is still binding with respect

1433
00:53:59,640 --> 00:54:01,740
to these approximate openings and

1434
00:54:01,740 --> 00:54:05,040
therefore this is interesting now a

1435
00:54:05,040 --> 00:54:06,780
slightly different Viewpoint that turns

1436
00:54:06,780 --> 00:54:08,640
out to be really useful is what we call

1437
00:54:08,640 --> 00:54:11,579
in week opening so we can actually

1438
00:54:11,579 --> 00:54:15,540
remove this cultivation factor C bar so

1439
00:54:15,540 --> 00:54:17,040
for example a c bar is just invertible

1440
00:54:17,040 --> 00:54:19,140
we can divide through but also if it's

1441
00:54:19,140 --> 00:54:21,420
not invertible we can we can remove this

1442
00:54:21,420 --> 00:54:23,460
by essentially facing together many many

1443
00:54:23,460 --> 00:54:26,160
of such equations and then we actually

1444
00:54:26,160 --> 00:54:29,099
get get a pre-image for T so T is going

1445
00:54:29,099 --> 00:54:32,339
to be H times s star in this s star we

1446
00:54:32,339 --> 00:54:34,619
call the weak opening and Now esther is

1447
00:54:34,619 --> 00:54:36,240
not short anymore but it has a nice

1448
00:54:36,240 --> 00:54:38,099
property that if we multiply by the C by

1449
00:54:38,099 --> 00:54:39,839
that it gets short and something like

1450
00:54:39,839 --> 00:54:42,420
this we call weak opening and the

1451
00:54:42,420 --> 00:54:43,920
Clinton scheme also turns out to be

1452
00:54:43,920 --> 00:54:47,520
binding for this notion

1453
00:54:47,520 --> 00:54:51,059
now this approximate proof is linear

1454
00:54:51,059 --> 00:54:53,940
sized because yeah obviously there's

1455
00:54:53,940 --> 00:54:56,400
this mask opening this Z Vector has the

1456
00:54:56,400 --> 00:54:58,140
same Dimension as s so it's so it's

1457
00:54:58,140 --> 00:55:00,660
linear in the in the size of s

1458
00:55:00,660 --> 00:55:03,119
um so maybe a natural approach to come

1459
00:55:03,119 --> 00:55:05,819
on some or somehow try to to get your

1460
00:55:05,819 --> 00:55:09,299
sublinear scaling is uh that when one

1461
00:55:09,299 --> 00:55:11,400
starts with many commitments so now we

1462
00:55:11,400 --> 00:55:12,960
have many many TI's many such

1463
00:55:12,960 --> 00:55:15,420
commitments and the idea is that we want

1464
00:55:15,420 --> 00:55:17,880
to prove them all at all at once and

1465
00:55:17,880 --> 00:55:20,280
something like this we usually call an

1466
00:55:20,280 --> 00:55:21,960
amortized proof so we hope that we can

1467
00:55:21,960 --> 00:55:23,400
prove them all at once with a small

1468
00:55:23,400 --> 00:55:26,059
total cost and the protocol for this is

1469
00:55:26,059 --> 00:55:28,619
essentially the same as this proximate

1470
00:55:28,619 --> 00:55:30,359
signal protocol

1471
00:55:30,359 --> 00:55:32,460
um and the only difference is that the

1472
00:55:32,460 --> 00:55:35,339
verifier now sends many challenges so C1

1473
00:55:35,339 --> 00:55:38,520
up to c n and then the prover replies

1474
00:55:38,520 --> 00:55:40,200
with what we call the amortized mask

1475
00:55:40,200 --> 00:55:43,020
opening so they see where there are many

1476
00:55:43,020 --> 00:55:45,119
sis and they're all linear combined with

1477
00:55:45,119 --> 00:55:48,240
these random challenges and now this uh

1478
00:55:48,240 --> 00:55:51,059
has nice scaling because the Z still has

1479
00:55:51,059 --> 00:55:53,520
only the length of one of these si in

1480
00:55:53,520 --> 00:55:55,380
dimension but now there are many sis in

1481
00:55:55,380 --> 00:55:57,000
this Z so

1482
00:55:57,000 --> 00:55:58,799
um now we have basically broken the the

1483
00:55:58,799 --> 00:56:01,260
linear scaling this this is also still

1484
00:56:01,260 --> 00:56:03,359
sound for proving commitment openings

1485
00:56:03,359 --> 00:56:06,240
because uh it's slightly more

1486
00:56:06,240 --> 00:56:07,680
complicated but not much so it's not

1487
00:56:07,680 --> 00:56:09,359
special sound anymore but what we can do

1488
00:56:09,359 --> 00:56:11,819
is that for every eye we can essentially

1489
00:56:11,819 --> 00:56:15,240
get two transcripts that only differ in

1490
00:56:15,240 --> 00:56:17,339
in the corresponding CI and then we get

1491
00:56:17,339 --> 00:56:19,200
a week opening for TI and then if you do

1492
00:56:19,200 --> 00:56:20,880
this for all I we get big openings for

1493
00:56:20,880 --> 00:56:22,020
all the ti

1494
00:56:22,020 --> 00:56:24,960
so this is kind of the basic building

1495
00:56:24,960 --> 00:56:27,119
block that we use for our sublinear

1496
00:56:27,119 --> 00:56:29,579
proof system but of course the problem

1497
00:56:29,579 --> 00:56:32,220
we need to solve based on this is that

1498
00:56:32,220 --> 00:56:35,640
we need to be able to prove our linear

1499
00:56:35,640 --> 00:56:37,740
and quadratic relation on on the SI

1500
00:56:37,740 --> 00:56:40,140
vectors and here of course the standard

1501
00:56:40,140 --> 00:56:42,299
approach is that we use this

1502
00:56:42,299 --> 00:56:45,059
um this mask opening Z and for

1503
00:56:45,059 --> 00:56:47,880
essentially every relation that we prove

1504
00:56:47,880 --> 00:56:50,460
or want to prove on one of the S ions we

1505
00:56:50,460 --> 00:56:53,760
just evaluate this relation on Z that we

1506
00:56:53,760 --> 00:56:55,799
view as some some formal polynomial in

1507
00:56:55,799 --> 00:56:58,319
the cios and then what what this gives

1508
00:56:58,319 --> 00:57:00,660
us is is a multivariate polynomial in

1509
00:57:00,660 --> 00:57:02,460
the CI so the proof I can just compute

1510
00:57:02,460 --> 00:57:05,220
this before knowing the CIS and he can

1511
00:57:05,220 --> 00:57:07,260
also commit to all these coefficients in

1512
00:57:07,260 --> 00:57:10,140
this polynomial and then

1513
00:57:10,140 --> 00:57:12,720
um basically in the verification the

1514
00:57:12,720 --> 00:57:16,140
verifier checks that this is equation or

1515
00:57:16,140 --> 00:57:17,819
basically this polynomial evaluated at

1516
00:57:17,819 --> 00:57:20,400
the actual challenges is is correct and

1517
00:57:20,400 --> 00:57:22,200
then this gives some probabilistic proof

1518
00:57:22,200 --> 00:57:23,880
that that

1519
00:57:23,880 --> 00:57:25,500
um yeah so so for example to give some

1520
00:57:25,500 --> 00:57:28,740
some examples so in the case where n is

1521
00:57:28,740 --> 00:57:31,859
equal to so we only have two two secret

1522
00:57:31,859 --> 00:57:34,740
vectors s i and we want to prove the the

1523
00:57:34,740 --> 00:57:37,380
scalar product of S1 with itself we

1524
00:57:37,380 --> 00:57:39,000
would just use the scalar product to

1525
00:57:39,000 --> 00:57:42,740
leave it with itself and get this nice

1526
00:57:42,740 --> 00:57:45,359
quadratic multivari polynomial in two

1527
00:57:45,359 --> 00:57:48,480
challenges and most of these terms are

1528
00:57:48,480 --> 00:57:49,799
not very interesting this is why we

1529
00:57:49,799 --> 00:57:51,780
usually call them garbage terms but the

1530
00:57:51,780 --> 00:57:53,160
highest degree terms turn out to be

1531
00:57:53,160 --> 00:57:54,839
interesting and for example the G4 term

1532
00:57:54,839 --> 00:57:56,880
in this relation which is the term

1533
00:57:56,880 --> 00:57:59,460
corresponding to C1 squared in the

1534
00:57:59,460 --> 00:58:01,079
actual execution will be the scalar

1535
00:58:01,079 --> 00:58:04,079
product of S7 with itself now to use

1536
00:58:04,079 --> 00:58:07,559
this primitive there there are going to

1537
00:58:07,559 --> 00:58:10,799
be two problems in practice so first for

1538
00:58:10,799 --> 00:58:13,200
large n the number of these coefficients

1539
00:58:13,200 --> 00:58:14,760
in this multivariate polynomial is going

1540
00:58:14,760 --> 00:58:16,619
to explode so this is going to be a

1541
00:58:16,619 --> 00:58:19,559
large number of terms and basically in

1542
00:58:19,559 --> 00:58:21,839
the NL in the for analyzing this

1543
00:58:21,839 --> 00:58:24,119
protocol improving in soundness we need

1544
00:58:24,119 --> 00:58:26,220
that in the extraction we can control

1545
00:58:26,220 --> 00:58:28,380
some of the form of the and I will say

1546
00:58:28,380 --> 00:58:31,079
what what I mean by this and and how to

1547
00:58:31,079 --> 00:58:32,700
solve these problems

1548
00:58:32,700 --> 00:58:34,260
so first

1549
00:58:34,260 --> 00:58:35,220
um

1550
00:58:35,220 --> 00:58:37,079
this problem with the number of of

1551
00:58:37,079 --> 00:58:40,559
garbage turns so just to in more detail

1552
00:58:40,559 --> 00:58:42,720
what the problem here is is that if we

1553
00:58:42,720 --> 00:58:44,700
have now if you go from from n equals

1554
00:58:44,700 --> 00:58:47,940
two to some lunch n then are much very

1555
00:58:47,940 --> 00:58:50,220
polynomial will have a quadratic number

1556
00:58:50,220 --> 00:58:52,559
of of garbage terms and they are just

1557
00:58:52,559 --> 00:58:54,180
prohibitively expensive to to send

1558
00:58:54,180 --> 00:58:56,220
document to or whatever

1559
00:58:56,220 --> 00:58:58,920
um so the what we do in the paper to

1560
00:58:58,920 --> 00:59:01,200
about this problem is that we basically

1561
00:59:01,200 --> 00:59:03,359
go from a quadratic number of garbage

1562
00:59:03,359 --> 00:59:05,280
terms to a linear number by using

1563
00:59:05,280 --> 00:59:07,619
interaction and this works in the

1564
00:59:07,619 --> 00:59:10,760
following way so if we look at our

1565
00:59:10,760 --> 00:59:13,079
multivariate polynomial we can write

1566
00:59:13,079 --> 00:59:16,020
this essentially as a sum of universe

1567
00:59:16,020 --> 00:59:18,299
polynomials in the CI so we have a sum

1568
00:59:18,299 --> 00:59:22,140
of universal polynomial fi that uh uh

1569
00:59:22,140 --> 00:59:25,200
yeah polynomials in CI where the ice

1570
00:59:25,200 --> 00:59:27,420
polynomial implicitly depends on

1571
00:59:27,420 --> 00:59:30,540
previous challenges so maybe more

1572
00:59:30,540 --> 00:59:32,160
constructively

1573
00:59:32,160 --> 00:59:35,520
um in this equation this first term if 0

1574
00:59:35,520 --> 00:59:38,220
is just going to be the the constant

1575
00:59:38,220 --> 00:59:39,540
coefficient of our multiparied

1576
00:59:39,540 --> 00:59:42,240
polynomial and then F1 contains all the

1577
00:59:42,240 --> 00:59:45,900
terms that just depend on C1 so this is

1578
00:59:45,900 --> 00:59:47,940
a univariant polynomial in in C1 and

1579
00:59:47,940 --> 00:59:52,020
then more interestingly F2 is the

1580
00:59:52,020 --> 00:59:54,540
polynomial where that contains of all

1581
00:59:54,540 --> 00:59:58,799
the terms of F that depend on C2 but

1582
00:59:58,799 --> 01:00:00,900
maybe also in C1 but we view this

1583
01:00:00,900 --> 01:00:03,000
depends on C1 implicitly so we get to

1584
01:00:03,000 --> 01:00:04,619
Universe polynomial C2 where the

1585
01:00:04,619 --> 01:00:08,280
coefficients depend on C1 and then in a

1586
01:00:08,280 --> 01:00:11,040
2N plus one round protocol what we can

1587
01:00:11,040 --> 01:00:13,260
do is that basically the prover sends

1588
01:00:13,260 --> 01:00:15,480
the polynomial f i before getting the

1589
01:00:15,480 --> 01:00:18,299
terms CI and if you go back to the

1590
01:00:18,299 --> 01:00:20,460
example of this inner product of Z with

1591
01:00:20,460 --> 01:00:21,720
itself

1592
01:00:21,720 --> 01:00:23,280
um what this means is now that we write

1593
01:00:23,280 --> 01:00:26,400
our polynomial in in this form so the

1594
01:00:26,400 --> 01:00:28,880
the this garbage term g0 is now this

1595
01:00:28,880 --> 01:00:32,819
polynomial F0 and so on so and maybe uh

1596
01:00:32,819 --> 01:00:35,339
the most interesting term here is this

1597
01:00:35,339 --> 01:00:37,799
F2 polynomials so this is now a

1598
01:00:37,799 --> 01:00:40,920
univariant polynomial in C2 but the

1599
01:00:40,920 --> 01:00:43,559
coefficient of C2 implicitly depends on

1600
01:00:43,559 --> 01:00:46,680
C1 and in the protocol the the proof of

1601
01:00:46,680 --> 01:00:48,960
first sends all the terms

1602
01:00:48,960 --> 01:00:50,700
um at the beginning that don't depend on

1603
01:00:50,700 --> 01:00:53,339
anything then you get C1 and then he can

1604
01:00:53,339 --> 01:00:56,160
actually compute this G23 term and send

1605
01:00:56,160 --> 01:00:58,680
this together with G5

1606
01:00:58,680 --> 01:01:01,319
um and afterwards hit C2 so already in

1607
01:01:01,319 --> 01:01:02,460
this very

1608
01:01:02,460 --> 01:01:04,980
uh basically degenerate example for n

1609
01:01:04,980 --> 01:01:07,799
equals two we see that we went from uh

1610
01:01:07,799 --> 01:01:09,720
six garbage terms to five so we have

1611
01:01:09,720 --> 01:01:11,460
some reduction here and the intuition

1612
01:01:11,460 --> 01:01:13,859
why this is secure is uh that

1613
01:01:13,859 --> 01:01:16,260
essentially the attack that we need to

1614
01:01:16,260 --> 01:01:17,940
make impossible is that the proofer can

1615
01:01:17,940 --> 01:01:21,540
somehow control the evaluation of the

1616
01:01:21,540 --> 01:01:24,780
final polynomial at the challenge uh

1617
01:01:24,780 --> 01:01:27,420
polynomial the channel yeah coefficients

1618
01:01:27,420 --> 01:01:29,160
or the trans polynomials they are also

1619
01:01:29,160 --> 01:01:30,839
polynomials but in in the underlying

1620
01:01:30,839 --> 01:01:32,099
ring

1621
01:01:32,099 --> 01:01:33,900
um and

1622
01:01:33,900 --> 01:01:36,780
uh yeah so the the reason why he can't

1623
01:01:36,780 --> 01:01:39,480
do this is that basically all these fi

1624
01:01:39,480 --> 01:01:41,520
polynomials they actually multiples of

1625
01:01:41,520 --> 01:01:45,240
CI so by if he if basically he wants to

1626
01:01:45,240 --> 01:01:47,160
introduce some correction there because

1627
01:01:47,160 --> 01:01:48,839
some more early in the protocol he

1628
01:01:48,839 --> 01:01:50,760
didn't achieve what he wanted

1629
01:01:50,760 --> 01:01:52,559
um all these Corrections are going to be

1630
01:01:52,559 --> 01:01:55,079
disturbed by by because because they

1631
01:01:55,079 --> 01:01:57,299
they they get multiplied by by the next

1632
01:01:57,299 --> 01:02:00,180
challenge that the proof I can't control

1633
01:02:00,180 --> 01:02:02,400
okay so this is basically how we solve

1634
01:02:02,400 --> 01:02:04,200
the first problem

1635
01:02:04,200 --> 01:02:05,940
um that there's a quadratic number of

1636
01:02:05,940 --> 01:02:07,500
garbage terms and then there's the

1637
01:02:07,500 --> 01:02:09,420
second problem that in the nla in the

1638
01:02:09,420 --> 01:02:12,240
analysis of of the soundness of this

1639
01:02:12,240 --> 01:02:14,760
polynomial evaluation argument and what

1640
01:02:14,760 --> 01:02:16,200
one needs in the extraction is that

1641
01:02:16,200 --> 01:02:18,599
there can be certain of the form of this

1642
01:02:18,599 --> 01:02:21,420
mask opening Z so what this really means

1643
01:02:21,420 --> 01:02:22,740
is that

1644
01:02:22,740 --> 01:02:25,200
um in the extraction I can prove that in

1645
01:02:25,200 --> 01:02:27,359
essentially almost all transcripts the Z

1646
01:02:27,359 --> 01:02:30,240
will be always of the same form with the

1647
01:02:30,240 --> 01:02:32,099
with the mask everything with the weak

1648
01:02:32,099 --> 01:02:33,720
openings that I have extracted so all

1649
01:02:33,720 --> 01:02:35,640
these SI star together with the week

1650
01:02:35,640 --> 01:02:37,380
opening for the for the masking

1651
01:02:37,380 --> 01:02:39,599
commitment one star and then basically

1652
01:02:39,599 --> 01:02:41,280
the Z only depends on the challenges

1653
01:02:41,280 --> 01:02:42,780
that that

1654
01:02:42,780 --> 01:02:46,200
um that that vary between transcripts

1655
01:02:46,200 --> 01:02:49,619
and so now in the in the non-amerized

1656
01:02:49,619 --> 01:02:51,180
case so where n is equal to one this is

1657
01:02:51,180 --> 01:02:53,280
very easy to prove or relatively easy so

1658
01:02:53,280 --> 01:02:56,339
basically one way to see this is that

1659
01:02:56,339 --> 01:02:58,440
because as one star and there's now only

1660
01:02:58,440 --> 01:03:00,299
as one star is a weak opening we have

1661
01:03:00,299 --> 01:03:03,059
this polynomial c bar that makes S1 star

1662
01:03:03,059 --> 01:03:05,160
short so we can

1663
01:03:05,160 --> 01:03:08,460
um we if we if we take the Z from one

1664
01:03:08,460 --> 01:03:10,680
accepting transcript where basically the

1665
01:03:10,680 --> 01:03:13,680
Y star is defined such that uh the

1666
01:03:13,680 --> 01:03:15,539
equation that we expect is actually true

1667
01:03:15,539 --> 01:03:17,940
and then multiply this by c bar then we

1668
01:03:17,940 --> 01:03:19,799
get this equation here

1669
01:03:19,799 --> 01:03:21,660
um this also works yeah so this equation

1670
01:03:21,660 --> 01:03:22,859
here

1671
01:03:22,859 --> 01:03:24,839
um and then if we multiply by c bar and

1672
01:03:24,839 --> 01:03:27,359
then rearrange this rearrange this a bit

1673
01:03:27,359 --> 01:03:28,680
then on the right hand side we get

1674
01:03:28,680 --> 01:03:30,420
something better small because c bar is

1675
01:03:30,420 --> 01:03:33,180
more Z is small and the C bar makes S1

1676
01:03:33,180 --> 01:03:35,339
small so everything is small and this

1677
01:03:35,339 --> 01:03:37,020
means that y star is actually weak

1678
01:03:37,020 --> 01:03:39,299
opening again for the for the masking

1679
01:03:39,299 --> 01:03:40,799
commitment and therefore the proof is

1680
01:03:40,799 --> 01:03:42,180
committed to trade so and basically all

1681
01:03:42,180 --> 01:03:43,799
accepting transcripts he always has to

1682
01:03:43,799 --> 01:03:46,680
use the same y star now the same same

1683
01:03:46,680 --> 01:03:48,599
argument doesn't really generalize to

1684
01:03:48,599 --> 01:03:49,980
the amortized case because in the

1685
01:03:49,980 --> 01:03:52,200
amortized case we basically individually

1686
01:03:52,200 --> 01:03:55,200
extracted all the sis so we have weak

1687
01:03:55,200 --> 01:03:57,900
openings for all the sis and different c

1688
01:03:57,900 --> 01:04:00,980
bar all the SI so essentially to make

1689
01:04:00,980 --> 01:04:03,599
this right hand side small where there's

1690
01:04:03,599 --> 01:04:06,119
now many terms many sis we would need to

1691
01:04:06,119 --> 01:04:08,579
multiply with many different C bars and

1692
01:04:08,579 --> 01:04:10,079
they would would compose to something

1693
01:04:10,079 --> 01:04:11,640
big so

1694
01:04:11,640 --> 01:04:14,819
um then we we can't argue anymore about

1695
01:04:14,819 --> 01:04:17,460
like spanning this or something so how

1696
01:04:17,460 --> 01:04:19,079
do we solve this

1697
01:04:19,079 --> 01:04:21,839
um it turns out that

1698
01:04:21,839 --> 01:04:24,900
if basically in addition we have some

1699
01:04:24,900 --> 01:04:27,500
protocol that actually proves shortness

1700
01:04:27,500 --> 01:04:30,539
of of the all the SI so for example we

1701
01:04:30,539 --> 01:04:33,599
have some binary proof then basically we

1702
01:04:33,599 --> 01:04:37,160
can use this protocol and reason about

1703
01:04:37,160 --> 01:04:40,079
uh that that yeah where the Z must be

1704
01:04:40,079 --> 01:04:42,720
well formed again and the argument goes

1705
01:04:42,720 --> 01:04:45,359
something like this so

1706
01:04:45,359 --> 01:04:47,160
um yeah so in the extraction what we do

1707
01:04:47,160 --> 01:04:49,440
is we get all these weak openings as I

1708
01:04:49,440 --> 01:04:51,839
star and since there's a binary proof we

1709
01:04:51,839 --> 01:04:53,460
actually expected that they are all

1710
01:04:53,460 --> 01:04:55,559
binary so we can ask ourselves what

1711
01:04:55,559 --> 01:04:57,359
happens if they don't turn out to be

1712
01:04:57,359 --> 01:04:59,220
binary and in this case there's going to

1713
01:04:59,220 --> 01:05:01,319
be some last non-binary Vector so let's

1714
01:05:01,319 --> 01:05:06,420
say this is s i uh zero star and then we

1715
01:05:06,420 --> 01:05:08,760
can essentially restrict to transcripts

1716
01:05:08,760 --> 01:05:11,880
where the first challenges C1 up to CI

1717
01:05:11,880 --> 01:05:14,220
zero minus one are fixed so we only look

1718
01:05:14,220 --> 01:05:15,079
at

1719
01:05:15,079 --> 01:05:17,400
transcripts where all these changes are

1720
01:05:17,400 --> 01:05:19,260
fixed and then let's say in one of these

1721
01:05:19,260 --> 01:05:21,599
transcripts we write z in this form

1722
01:05:21,599 --> 01:05:25,319
where we absorb all the terms c i s i

1723
01:05:25,319 --> 01:05:30,299
star for I smaller than I zero into y

1724
01:05:30,299 --> 01:05:32,220
um then we can actually apply the the

1725
01:05:32,220 --> 01:05:34,200
simple non-amortized argument and just

1726
01:05:34,200 --> 01:05:36,660
multiply by the c bar that makes the s i

1727
01:05:36,660 --> 01:05:38,339
0 small

1728
01:05:38,339 --> 01:05:39,900
um and on the right hand side we get

1729
01:05:39,900 --> 01:05:42,359
something something small again because

1730
01:05:42,359 --> 01:05:45,420
um all the the later terms they are they

1731
01:05:45,420 --> 01:05:47,700
are small by assumption so we said that

1732
01:05:47,700 --> 01:05:50,760
s i0 is the last non-binary Vector

1733
01:05:50,760 --> 01:05:53,039
um and this now implies that y star is a

1734
01:05:53,039 --> 01:05:55,140
weak opening for this linear combination

1735
01:05:55,140 --> 01:05:57,720
of these commitments so again the proof

1736
01:05:57,720 --> 01:06:00,240
is is boundaries in all these

1737
01:06:00,240 --> 01:06:03,240
transcripts with fixed first challenges

1738
01:06:03,240 --> 01:06:05,940
um and the binary proof now basically

1739
01:06:05,940 --> 01:06:07,799
collapses to Binary proofs that the

1740
01:06:07,799 --> 01:06:09,059
binary proof in the in the actual

1741
01:06:09,059 --> 01:06:10,980
protocol is a binary proof for all the

1742
01:06:10,980 --> 01:06:13,319
SI and now collapses to Binary proof for

1743
01:06:13,319 --> 01:06:15,839
all the SI starting from I zero and in

1744
01:06:15,839 --> 01:06:17,339
this protocol the approval only has very

1745
01:06:17,339 --> 01:06:19,319
small success probability because SI 0

1746
01:06:19,319 --> 01:06:21,780
is not it's not binary and so basically

1747
01:06:21,780 --> 01:06:24,720
this case can't can't happen and

1748
01:06:24,720 --> 01:06:26,760
therefore we have well phones

1749
01:06:26,760 --> 01:06:28,200
okay

1750
01:06:28,200 --> 01:06:31,260
um yeah so with this I basically

1751
01:06:31,260 --> 01:06:33,000
finished some some more deep dive into

1752
01:06:33,000 --> 01:06:34,799
some of the techniques but also other

1753
01:06:34,799 --> 01:06:36,780
techniques but yeah um I don't focus on

1754
01:06:36,780 --> 01:06:37,980
them now

1755
01:06:37,980 --> 01:06:40,140
um just want to say that now we use this

1756
01:06:40,140 --> 01:06:43,140
to uh construct a sub-linear proof

1757
01:06:43,140 --> 01:06:46,859
system and there's yeah maybe on a high

1758
01:06:46,859 --> 01:06:48,180
level there's not really much to do

1759
01:06:48,180 --> 01:06:51,240
there because uh if it does start with

1760
01:06:51,240 --> 01:06:54,780
the vector s of Dimension M times n and

1761
01:06:54,780 --> 01:06:57,539
then split this into M vectors of uh

1762
01:06:57,539 --> 01:07:00,420
Dimension n where m is approximate equal

1763
01:07:00,420 --> 01:07:03,059
to n we essentially immediately get a

1764
01:07:03,059 --> 01:07:05,180
square root scaling proof system because

1765
01:07:05,180 --> 01:07:09,780
we now have uh M of these commitments

1766
01:07:09,780 --> 01:07:12,059
but they are constant science they don't

1767
01:07:12,059 --> 01:07:16,440
depend on n and proving them has only

1768
01:07:16,440 --> 01:07:19,079
has only basically length n because this

1769
01:07:19,079 --> 01:07:21,359
must openings only of of the of the

1770
01:07:21,359 --> 01:07:23,520
length or the dimension of the sis which

1771
01:07:23,520 --> 01:07:26,339
I also mentioned n and so since if M

1772
01:07:26,339 --> 01:07:29,640
then uh some with the same then they

1773
01:07:29,640 --> 01:07:31,020
will be the square root of the of the

1774
01:07:31,020 --> 01:07:33,180
product MN which is the the total number

1775
01:07:33,180 --> 01:07:35,039
of coefficients so we can just run this

1776
01:07:35,039 --> 01:07:37,200
amortized to prove as I explained of

1777
01:07:37,200 --> 01:07:39,059
course in the letters was there's only

1778
01:07:39,059 --> 01:07:41,760
like 90 of the work is kind of finding

1779
01:07:41,760 --> 01:07:44,579
parameters and optimizing and the the

1780
01:07:44,579 --> 01:07:46,559
techniques and so on but yeah this gives

1781
01:07:46,559 --> 01:07:48,119
Australian proof system the problem is

1782
01:07:48,119 --> 01:07:49,260
that

1783
01:07:49,260 --> 01:07:52,559
um it will not be very concretely

1784
01:07:52,559 --> 01:07:54,539
interesting because the proof size will

1785
01:07:54,539 --> 01:07:56,940
still be very relatively big and so we

1786
01:07:56,940 --> 01:07:59,339
have a second part in the paper where we

1787
01:07:59,339 --> 01:08:01,619
basically concretely reduce the proof

1788
01:08:01,619 --> 01:08:03,900
size by not directly sending these three

1789
01:08:03,900 --> 01:08:06,660
is but by committing to them in a myrtle

1790
01:08:06,660 --> 01:08:09,539
tree and then we can use these amortized

1791
01:08:09,539 --> 01:08:12,960
proofs basically and and prove uh the

1792
01:08:12,960 --> 01:08:15,839
Merkle tree level by level and some some

1793
01:08:15,839 --> 01:08:18,779
inductive in the inductive way and I'm

1794
01:08:18,779 --> 01:08:20,460
not going to into details basically all

1795
01:08:20,460 --> 01:08:22,859
that I want to say is that if we now

1796
01:08:22,859 --> 01:08:25,979
compare the resulting protocol

1797
01:08:25,979 --> 01:08:28,500
to liguero and the reason why we compare

1798
01:08:28,500 --> 01:08:30,179
to legare is that liguero also has

1799
01:08:30,179 --> 01:08:32,100
square root scaling so by this we can

1800
01:08:32,100 --> 01:08:34,040
essentially argue that our protocol has

1801
01:08:34,040 --> 01:08:36,658
concrete sizes that are very small for a

1802
01:08:36,658 --> 01:08:37,679
squared

1803
01:08:37,679 --> 01:08:40,020
um scaling system then we see that for

1804
01:08:40,020 --> 01:08:44,040
r1cs and with 2 to the 28 constraints so

1805
01:08:44,040 --> 01:08:46,259
you can just think of like two to the 20

1806
01:08:46,259 --> 01:08:49,620
age multiplication Gates then for about

1807
01:08:49,620 --> 01:08:51,299
equal soundness error we get to prove

1808
01:08:51,299 --> 01:08:52,920
size that is about three times smaller

1809
01:08:52,920 --> 01:08:55,560
than than liguero

1810
01:08:55,560 --> 01:08:57,600
and yeah

1811
01:08:57,600 --> 01:09:00,060
I think now at the time I thought oh and

1812
01:09:00,060 --> 01:09:04,159
I'm finished thank you very much and

1813
01:09:08,219 --> 01:09:10,319
great thanks a lot for the thought so we

1814
01:09:10,319 --> 01:09:11,880
have a few minutes for a question so if

1815
01:09:11,880 --> 01:09:13,080
you have any please come up to the

1816
01:09:13,080 --> 01:09:14,279
podium

1817
01:09:14,279 --> 01:09:16,198
so actually we have one on Zoom so maybe

1818
01:09:16,198 --> 01:09:17,819
I will start with that

1819
01:09:17,819 --> 01:09:20,819
so the question is how does R1 CS come

1820
01:09:20,819 --> 01:09:22,439
into play

1821
01:09:22,439 --> 01:09:24,420
yeah so I mean yeah I didn't say

1822
01:09:24,420 --> 01:09:26,219
anything about this so our NCS is

1823
01:09:26,219 --> 01:09:27,658
essentially just a convenient language

1824
01:09:27,658 --> 01:09:30,238
but on the one hand

1825
01:09:30,238 --> 01:09:34,020
uh relatively directly end-cons

1826
01:09:34,020 --> 01:09:35,759
arithmetic circuits and on the other

1827
01:09:35,759 --> 01:09:37,439
hand is very easy to prove because it

1828
01:09:37,439 --> 01:09:40,439
just consists of essentially linear

1829
01:09:40,439 --> 01:09:43,859
linear relations and one very long uh

1830
01:09:43,859 --> 01:09:46,319
like point-based product of two vectors

1831
01:09:46,319 --> 01:09:48,359
so essentially as soon as you can prove

1832
01:09:48,359 --> 01:09:50,640
linear relations and and and productive

1833
01:09:50,640 --> 01:09:52,799
relations you can prove r1cs and yeah

1834
01:09:52,799 --> 01:09:55,500
this is basically it's just for the the

1835
01:09:55,500 --> 01:09:56,880
reason why I want to see as it's

1836
01:09:56,880 --> 01:09:58,800
interesting is that it basically

1837
01:09:58,800 --> 01:10:02,699
provides an API that one can for example

1838
01:10:02,699 --> 01:10:03,679
have

1839
01:10:03,679 --> 01:10:07,020
a good tooling for it for example to

1840
01:10:07,020 --> 01:10:09,000
compile codes into r1cs and then prove

1841
01:10:09,000 --> 01:10:10,860
this with whatever proof system supports

1842
01:10:10,860 --> 01:10:13,140
the language and it's also a convenient

1843
01:10:13,140 --> 01:10:14,520
way to basically

1844
01:10:14,520 --> 01:10:17,280
Compare Food Systems because

1845
01:10:17,280 --> 01:10:20,780
um yeah it's the same language

1846
01:10:22,560 --> 01:10:24,480
uh great talk

1847
01:10:24,480 --> 01:10:26,280
um so I wanted to ask about the the

1848
01:10:26,280 --> 01:10:28,140
round complexity is it also square root

1849
01:10:28,140 --> 01:10:31,920
yeah okay I see yeah so uh if you sorry

1850
01:10:31,920 --> 01:10:34,560
go ahead yeah sorry I I wanted so so the

1851
01:10:34,560 --> 01:10:36,179
reason that I asked to do as a follow-up

1852
01:10:36,179 --> 01:10:39,480
uh so if you were to to try to compress

1853
01:10:39,480 --> 01:10:41,219
the rounds using Fiat Shamir this would

1854
01:10:41,219 --> 01:10:43,320
actually lead to like a big security

1855
01:10:43,320 --> 01:10:45,960
loss yes I'm leading into a security

1856
01:10:45,960 --> 01:10:48,120
loss which is like spared in the in the

1857
01:10:48,120 --> 01:10:50,400
witnesses yeah so there's like if you if

1858
01:10:50,400 --> 01:10:52,320
you're witnesses to the 28 you lose like

1859
01:10:52,320 --> 01:10:54,800
14 bits of saunas yeah because

1860
01:10:54,800 --> 01:10:57,239
uh do you analyze this in the in the

1861
01:10:57,239 --> 01:10:59,159
paper so but essentially so basically

1862
01:10:59,159 --> 01:11:01,860
this is actually why the soundness error

1863
01:11:01,860 --> 01:11:03,840
goes down exactly like this

1864
01:11:03,840 --> 01:11:06,300
um because yeah uh this comes it comes

1865
01:11:06,300 --> 01:11:08,820
exactly from this that this basically

1866
01:11:08,820 --> 01:11:10,620
this interactive first what simple

1867
01:11:10,620 --> 01:11:12,719
argument that we give um basically loses

1868
01:11:12,719 --> 01:11:14,659
one bit of thumb that's in it for every

1869
01:11:14,659 --> 01:11:17,460
additional uh basically power of doing

1870
01:11:17,460 --> 01:11:19,920
the constraints okay thank you

1871
01:11:19,920 --> 01:11:23,159
right so I have one more question so uh

1872
01:11:23,159 --> 01:11:24,780
when you compare to Lee hero how does

1873
01:11:24,780 --> 01:11:26,159
the approver and verifier complexities

1874
01:11:26,159 --> 01:11:27,300
compare because here you're just

1875
01:11:27,300 --> 01:11:29,699
focusing on group sizes

1876
01:11:29,699 --> 01:11:30,500
um

1877
01:11:30,500 --> 01:11:35,580
yes so so yeah both of them are

1878
01:11:35,580 --> 01:11:40,980
so so yeah the verify is not like uh sub

1879
01:11:40,980 --> 01:11:43,140
linear if you if you want this so it's

1880
01:11:43,140 --> 01:11:45,540
it's a linear size verify and also

1881
01:11:45,540 --> 01:11:47,159
um I'm actually not sure asymptotically

1882
01:11:47,159 --> 01:11:49,560
it's probably linear in the

1883
01:11:49,560 --> 01:11:52,260
um by the

1884
01:11:52,260 --> 01:11:55,860
time but

1885
01:11:56,699 --> 01:11:59,219
yeah I I guess what would be more

1886
01:11:59,219 --> 01:12:01,140
interesting is actually a complete a

1887
01:12:01,140 --> 01:12:04,080
concrete runtime of the prover and this

1888
01:12:04,080 --> 01:12:07,560
is one area where we watch what

1889
01:12:07,560 --> 01:12:09,719
motivates us to study lattice based

1890
01:12:09,719 --> 01:12:11,460
improve systems

1891
01:12:11,460 --> 01:12:12,960
um because

1892
01:12:12,960 --> 01:12:16,080
I mean these PCP types with the systems

1893
01:12:16,080 --> 01:12:18,080
for example they have the problem that

1894
01:12:18,080 --> 01:12:21,480
internally they have a very complicated

1895
01:12:21,480 --> 01:12:23,340
computations and large overheads and

1896
01:12:23,340 --> 01:12:25,020
there's a large complete overhead in the

1897
01:12:25,020 --> 01:12:26,100
computation because for example they

1898
01:12:26,100 --> 01:12:29,000
compute and very very long code words

1899
01:12:29,000 --> 01:12:31,560
and we don't really have this in these

1900
01:12:31,560 --> 01:12:32,940
types of flash systems so there's

1901
01:12:32,940 --> 01:12:35,219
essentially hope that concretely they're

1902
01:12:35,219 --> 01:12:37,860
like also for example the ram needed is

1903
01:12:37,860 --> 01:12:42,360
is is is is quite small but yeah

1904
01:12:42,360 --> 01:12:45,780
okay great so that that let's thank the

1905
01:12:45,780 --> 01:12:48,199
speaker again

1906
01:12:51,120 --> 01:12:54,860
right and that concludes the session

