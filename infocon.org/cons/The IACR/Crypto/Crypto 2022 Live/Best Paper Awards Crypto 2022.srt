1
00:00:06,160 --> 00:00:08,399
okay

2
00:00:08,400 --> 00:00:10,000
all right we should begin i think it's

3
00:00:10,000 --> 00:00:11,759
working

4
00:00:11,759 --> 00:00:13,599
so uh you might think that the best part

5
00:00:13,599 --> 00:00:16,320
about being a program chair is dealing

6
00:00:16,320 --> 00:00:19,520
with angry emails or conflicting pc

7
00:00:19,520 --> 00:00:21,600
personalities or trying desperately to

8
00:00:21,600 --> 00:00:24,640
stay on top of 450 plus discussions but

9
00:00:24,640 --> 00:00:26,400
you'd be wrong the best part is actually

10
00:00:26,400 --> 00:00:28,640
getting to help choose the best paper

11
00:00:28,640 --> 00:00:31,840
award winners we had three such papers

12
00:00:31,840 --> 00:00:34,399
this year and this is their session

13
00:00:34,399 --> 00:00:37,280
we had one sort of unqualified best

14
00:00:37,280 --> 00:00:38,960
paper that'll be the first talk and then

15
00:00:38,960 --> 00:00:41,440
we have two best paper awards for papers

16
00:00:41,440 --> 00:00:43,760
by early career researchers

17
00:00:43,760 --> 00:00:45,840
so the first of our three best favorite

18
00:00:45,840 --> 00:00:47,360
award winners today

19
00:00:47,360 --> 00:00:50,079
is batch arguments for np from st and

20
00:00:50,079 --> 00:00:52,399
more sorry uh from standard bilinear

21
00:00:52,399 --> 00:00:54,640
group assumptions by brent waters and

22
00:00:54,640 --> 00:00:57,280
david wu and david will get to talk

23
00:00:57,280 --> 00:00:58,879
great thanks a lot for the introduction

24
00:00:58,879 --> 00:01:00,559
and thanks a lot everyone for coming so

25
00:01:00,559 --> 00:01:02,079
today i'll be telling you about batch

26
00:01:02,079 --> 00:01:03,680
arguments and this is joint work with

27
00:01:03,680 --> 00:01:05,040
brent waters

28
00:01:05,040 --> 00:01:07,520
so in a batch argument for mp a prover

29
00:01:07,520 --> 00:01:10,159
has a collection of mp statements and

30
00:01:10,159 --> 00:01:11,840
his goal is to convince the verifier

31
00:01:11,840 --> 00:01:13,840
that all m of these statements are

32
00:01:13,840 --> 00:01:15,040
indeed true

33
00:01:15,040 --> 00:01:16,799
a natural way that the further prover to

34
00:01:16,799 --> 00:01:19,680
do so is the prover can send over m mp

35
00:01:19,680 --> 00:01:22,000
witnesses one for each statement and

36
00:01:22,000 --> 00:01:23,520
have the verifier check that each

37
00:01:23,520 --> 00:01:26,479
statement witness pair is indeed valid

38
00:01:26,479 --> 00:01:28,320
however a natural question that we might

39
00:01:28,320 --> 00:01:30,880
ask now is can we do better can we have

40
00:01:30,880 --> 00:01:32,479
the approver convince the verifier that

41
00:01:32,479 --> 00:01:34,479
all m statements are true with a proof

42
00:01:34,479 --> 00:01:36,400
whose sides grow sublinearly in the

43
00:01:36,400 --> 00:01:38,079
number of instances and the can the

44
00:01:38,079 --> 00:01:39,759
running time of the verifier similarly

45
00:01:39,759 --> 00:01:42,000
be sublinear in the number of instances

46
00:01:42,000 --> 00:01:43,840
that it needs to check this is the

47
00:01:43,840 --> 00:01:47,200
setting of a batch argument for mp the

48
00:01:47,200 --> 00:01:49,680
goal is to amortize the cost of mp

49
00:01:49,680 --> 00:01:51,680
verification namely we seek a

50
00:01:51,680 --> 00:01:53,680
construction where the size of the proof

51
00:01:53,680 --> 00:01:55,439
grows with the size essentially of a

52
00:01:55,439 --> 00:01:57,360
single instance times something that

53
00:01:57,360 --> 00:01:58,799
grows polynomially in a security

54
00:01:58,799 --> 00:02:00,719
parameter but more importantly

55
00:02:00,719 --> 00:02:02,799
sublinearly and ideally poly

56
00:02:02,799 --> 00:02:04,399
logarithmically with the number of

57
00:02:04,399 --> 00:02:06,799
instances we impose similar efficiency

58
00:02:06,799 --> 00:02:08,800
requirements on a verification time

59
00:02:08,800 --> 00:02:10,479
where essentially the cost of mp

60
00:02:10,479 --> 00:02:12,800
verification for m instances should also

61
00:02:12,800 --> 00:02:14,560
grow sublinearly with the number of

62
00:02:14,560 --> 00:02:17,360
instances being checked

63
00:02:17,360 --> 00:02:19,920
so batch arguments for mp is a special

64
00:02:19,920 --> 00:02:21,440
case of something called a succinct

65
00:02:21,440 --> 00:02:23,599
non-interactive argument or a snark for

66
00:02:23,599 --> 00:02:25,760
np however if we look at existing

67
00:02:25,760 --> 00:02:27,920
constructions of snarks they are either

68
00:02:27,920 --> 00:02:30,080
based on idealized models like the

69
00:02:30,080 --> 00:02:32,480
random oracle model or the algebraic

70
00:02:32,480 --> 00:02:35,280
group model or they're constructed based

71
00:02:35,280 --> 00:02:38,319
on non-standard strong non-falsifiable

72
00:02:38,319 --> 00:02:40,480
and knowledge assumptions or they can be

73
00:02:40,480 --> 00:02:42,720
based on heavy cryptographic machinery

74
00:02:42,720 --> 00:02:44,959
like indistinguishability obfuscation

75
00:02:44,959 --> 00:02:47,519
here we see constructions from a single

76
00:02:47,519 --> 00:02:50,319
standard simple assumption

77
00:02:50,319 --> 00:02:52,239
if we consider the relaxation of snarks

78
00:02:52,239 --> 00:02:54,879
for mp to the setting of batch arguments

79
00:02:54,879 --> 00:02:56,959
then a series of works by shodori jain

80
00:02:56,959 --> 00:02:58,560
and jin have recently showed how to

81
00:02:58,560 --> 00:03:00,640
construct batch arguments for general mp

82
00:03:00,640 --> 00:03:02,000
by leveraging the machinery of

83
00:03:02,000 --> 00:03:04,080
correlation intractable hash functions

84
00:03:04,080 --> 00:03:05,920
which can in turn be instantiated either

85
00:03:05,920 --> 00:03:07,840
from the subexponential ddh assumption

86
00:03:07,840 --> 00:03:10,000
in conjunction with the qr assumption or

87
00:03:10,000 --> 00:03:11,599
more recently from the plane learning

88
00:03:11,599 --> 00:03:13,360
with error's assumption

89
00:03:13,360 --> 00:03:14,879
if we consider the setting of what's

90
00:03:14,879 --> 00:03:16,640
known in the setting of bi-linear maps

91
00:03:16,640 --> 00:03:18,319
we know how to construct batch arguments

92
00:03:18,319 --> 00:03:20,159
based on non-standard but falsifiable

93
00:03:20,159 --> 00:03:23,200
q-type assumptions over bi-linear groups

94
00:03:23,200 --> 00:03:25,040
the focus of this talk is to give a new

95
00:03:25,040 --> 00:03:26,879
construction of non-interactive batch

96
00:03:26,879 --> 00:03:28,720
arguments for general mp that can be

97
00:03:28,720 --> 00:03:30,319
based on standard assumptions over by

98
00:03:30,319 --> 00:03:32,319
linear maps namely we can instantiate

99
00:03:32,319 --> 00:03:34,000
our construction using either the k

100
00:03:34,000 --> 00:03:35,519
linear assumption in the prime order

101
00:03:35,519 --> 00:03:37,120
setting or the subgroup decision

102
00:03:37,120 --> 00:03:38,720
assumption in the composite order

103
00:03:38,720 --> 00:03:40,640
setting but i think the more interesting

104
00:03:40,640 --> 00:03:42,480
and more salient point that i'm going to

105
00:03:42,480 --> 00:03:44,720
make here is that our construction

106
00:03:44,720 --> 00:03:47,040
is very low tech it all does not rely on

107
00:03:47,040 --> 00:03:48,879
heavy cryptographic tools like foreign

108
00:03:48,879 --> 00:03:50,959
interactable hash functions or on

109
00:03:50,959 --> 00:03:52,560
general information theoretic primitives

110
00:03:52,560 --> 00:03:54,720
like probabilistically checkable proofs

111
00:03:54,720 --> 00:03:56,480
it takes a very direct algebraic

112
00:03:56,480 --> 00:03:58,000
approach for constructing batch

113
00:03:58,000 --> 00:03:59,120
arguments

114
00:03:59,120 --> 00:04:01,439
in fact it harkens back to a classic

115
00:04:01,439 --> 00:04:02,560
non-interactive zero knowledge

116
00:04:02,560 --> 00:04:04,720
construction or an easy construction by

117
00:04:04,720 --> 00:04:06,319
grosso strauss against a high that

118
00:04:06,319 --> 00:04:08,080
follows a familiar commit and proof

119
00:04:08,080 --> 00:04:09,200
paradigm

120
00:04:09,200 --> 00:04:12,319
this is what i will show in a talk today

121
00:04:12,319 --> 00:04:14,319
as a corollary of our main construction

122
00:04:14,319 --> 00:04:16,238
we also obtain a ram delegation scheme

123
00:04:16,238 --> 00:04:17,918
otherwise known as a succinct argument

124
00:04:17,918 --> 00:04:20,798
or snark or p with a sublinear size crs

125
00:04:20,798 --> 00:04:22,960
from standard bilinear map assumptions

126
00:04:22,960 --> 00:04:24,160
previously

127
00:04:24,160 --> 00:04:25,520
this was either known from in the

128
00:04:25,520 --> 00:04:27,120
pairing based setting this was either

129
00:04:27,120 --> 00:04:28,400
known from non-standard pairing

130
00:04:28,400 --> 00:04:29,840
assumptions or

131
00:04:29,840 --> 00:04:33,120
required a launch quadratic size crs

132
00:04:33,120 --> 00:04:34,400
another corollary of our main

133
00:04:34,400 --> 00:04:35,759
construction we obtain an aggregate

134
00:04:35,759 --> 00:04:37,440
signature that supports bounded

135
00:04:37,440 --> 00:04:39,280
aggregation from standard assumptions

136
00:04:39,280 --> 00:04:41,600
over by linear maps previously this was

137
00:04:41,600 --> 00:04:44,720
only known in a random oracle model

138
00:04:44,720 --> 00:04:46,000
so now let me tell you a little bit

139
00:04:46,000 --> 00:04:48,080
about how we construct batch arguments

140
00:04:48,080 --> 00:04:51,600
for mp in our new framework we follow a

141
00:04:51,600 --> 00:04:53,840
commit and prove strategy that's common

142
00:04:53,840 --> 00:04:55,440
in the construction and many other kinds

143
00:04:55,440 --> 00:04:57,600
of proof systems yes the second is as

144
00:04:57,600 --> 00:04:59,840
follows suppose you have approver and

145
00:04:59,840 --> 00:05:02,560
approver has a stack of mp statements

146
00:05:02,560 --> 00:05:04,000
and it wants to convince the verifier

147
00:05:04,000 --> 00:05:06,000
that all m of these statements are true

148
00:05:06,000 --> 00:05:07,600
here we're going to work towards the mp

149
00:05:07,600 --> 00:05:09,039
complete language of boolean circuit

150
00:05:09,039 --> 00:05:11,280
satisfiability and for simplicity of

151
00:05:11,280 --> 00:05:12,960
description i'm going to assume that all

152
00:05:12,960 --> 00:05:15,199
of the gates are nand gates

153
00:05:15,199 --> 00:05:17,759
so we have a collection of m circuits

154
00:05:17,759 --> 00:05:19,919
and so essentially what you can see is

155
00:05:19,919 --> 00:05:21,680
that for each of these wires we actually

156
00:05:21,680 --> 00:05:24,639
have a vector of m wire labels one wire

157
00:05:24,639 --> 00:05:27,680
assignment for each uh instance in my

158
00:05:27,680 --> 00:05:28,720
relation

159
00:05:28,720 --> 00:05:30,320
so what the first thing the prover is

160
00:05:30,320 --> 00:05:32,000
going to do is the approver is going to

161
00:05:32,000 --> 00:05:34,160
construct a vector commitment to each of

162
00:05:34,160 --> 00:05:36,720
these wires in the boolean circuit each

163
00:05:36,720 --> 00:05:38,400
each of these vector commitments is a

164
00:05:38,400 --> 00:05:41,759
commitment to m wire assignments m01

165
00:05:41,759 --> 00:05:43,280
values

166
00:05:43,280 --> 00:05:45,280
importantly for our construction we will

167
00:05:45,280 --> 00:05:46,960
require that these vector commitments be

168
00:05:46,960 --> 00:05:49,360
succinct namely the size of a commitment

169
00:05:49,360 --> 00:05:51,120
should scale polynomially in a security

170
00:05:51,120 --> 00:05:52,960
parameter but importantly poly

171
00:05:52,960 --> 00:05:54,320
logarithmically or better yet

172
00:05:54,320 --> 00:05:56,319
independent of the length of the vector

173
00:05:56,319 --> 00:05:58,000
or the number of instances that we are

174
00:05:58,000 --> 00:06:00,639
committing to in our particular case the

175
00:06:00,639 --> 00:06:02,560
length of the commitment will actually

176
00:06:02,560 --> 00:06:04,080
be independent of the number of

177
00:06:04,080 --> 00:06:05,759
instances

178
00:06:05,759 --> 00:06:07,840
now once the approver has committed to

179
00:06:07,840 --> 00:06:09,680
all of these assignments to all of the

180
00:06:09,680 --> 00:06:12,080
wire labels across all of the instances

181
00:06:12,080 --> 00:06:13,840
now the approver has to reveal or

182
00:06:13,840 --> 00:06:15,680
convince the verifier that it actually

183
00:06:15,680 --> 00:06:17,440
committed to valid

184
00:06:17,440 --> 00:06:19,759
inputs so this is going to consist of a

185
00:06:19,759 --> 00:06:22,319
sequence of validity checks first we

186
00:06:22,319 --> 00:06:23,680
have to check that the commitments to

187
00:06:23,680 --> 00:06:25,520
the input wires are actually consistent

188
00:06:25,520 --> 00:06:27,840
with the statements being proved here

189
00:06:27,840 --> 00:06:29,280
this will actually be quite simple in

190
00:06:29,280 --> 00:06:31,039
our construction because the commitments

191
00:06:31,039 --> 00:06:32,880
will actually be deterministic and so

192
00:06:32,880 --> 00:06:34,880
the verifier can simply compute for

193
00:06:34,880 --> 00:06:37,440
itself what those commitments are

194
00:06:37,440 --> 00:06:39,199
next we have to check that each of these

195
00:06:39,199 --> 00:06:41,280
commitments to the wire labels are

196
00:06:41,280 --> 00:06:44,000
actually valid values in the case we're

197
00:06:44,000 --> 00:06:45,360
talking where we are working with

198
00:06:45,360 --> 00:06:46,880
boolean circuits

199
00:06:46,880 --> 00:06:48,960
each of these wire values should be a 0

200
00:06:48,960 --> 00:06:51,120
1 value it should be boolean value so

201
00:06:51,120 --> 00:06:52,960
the wire validity checks will check that

202
00:06:52,960 --> 00:06:54,960
each of these commitments is to a binary

203
00:06:54,960 --> 00:06:56,720
value vector

204
00:06:56,720 --> 00:06:58,479
next we need to check that the wire

205
00:06:58,479 --> 00:07:00,000
values actually respect the gate

206
00:07:00,000 --> 00:07:02,000
constraints namely for each gate in a

207
00:07:02,000 --> 00:07:03,919
boolean circuit the commitments to the

208
00:07:03,919 --> 00:07:06,000
output wires better be the nand gate

209
00:07:06,000 --> 00:07:07,840
applied to the commitments to the input

210
00:07:07,840 --> 00:07:08,800
wires

211
00:07:08,800 --> 00:07:10,720
and finally we need to check that all of

212
00:07:10,720 --> 00:07:13,039
the output wires are indeed one namely

213
00:07:13,039 --> 00:07:15,039
that the circuit accepts on all of the

214
00:07:15,039 --> 00:07:17,039
inputs so these are the four checks that

215
00:07:17,039 --> 00:07:18,080
we will

216
00:07:18,080 --> 00:07:19,120
describe

217
00:07:19,120 --> 00:07:21,520
in our construction and the important

218
00:07:21,520 --> 00:07:23,680
observation that we will leverage in the

219
00:07:23,680 --> 00:07:25,280
construction is that each of these

220
00:07:25,280 --> 00:07:27,039
validity checks can essentially be

221
00:07:27,039 --> 00:07:29,280
encoded as a quadratic polynomial and

222
00:07:29,280 --> 00:07:31,360
thus they can be checked in the exponent

223
00:07:31,360 --> 00:07:33,039
with the help of a pairing that would be

224
00:07:33,039 --> 00:07:34,960
the underlying idea

225
00:07:34,960 --> 00:07:37,039
for our construction

226
00:07:37,039 --> 00:07:38,639
so first let me describe how the

227
00:07:38,639 --> 00:07:40,800
commitments operate here we would simply

228
00:07:40,800 --> 00:07:43,360
use hedersen multi-commitments and for

229
00:07:43,360 --> 00:07:45,120
simplicity of exposition what i'm going

230
00:07:45,120 --> 00:07:46,960
to describe in today's talk is our

231
00:07:46,960 --> 00:07:48,879
construction using composite order by

232
00:07:48,879 --> 00:07:50,319
linear groups

233
00:07:50,319 --> 00:07:52,400
so in particular the group g will be a

234
00:07:52,400 --> 00:07:54,639
group of composite order and for the

235
00:07:54,639 --> 00:07:56,240
first part of this talk everything is

236
00:07:56,240 --> 00:07:58,319
going to work in the subgroup of order p

237
00:07:58,319 --> 00:08:00,080
later on when i talk about the security

238
00:08:00,080 --> 00:08:02,319
analysis we will actually use the full

239
00:08:02,319 --> 00:08:04,080
group but for now everything works in a

240
00:08:04,080 --> 00:08:05,759
subgroup of order p

241
00:08:05,759 --> 00:08:07,759
so just to recall in the patterson

242
00:08:07,759 --> 00:08:09,840
multi-commitment if i want to commit to

243
00:08:09,840 --> 00:08:11,919
a vector of m things this common

244
00:08:11,919 --> 00:08:13,280
reference string is just going to

245
00:08:13,280 --> 00:08:15,759
consist of m random group elements

246
00:08:15,759 --> 00:08:18,960
okay and for uh ease of exposition i'm

247
00:08:18,960 --> 00:08:20,400
going to write this

248
00:08:20,400 --> 00:08:22,800
as the exponents in bracket notation so

249
00:08:22,800 --> 00:08:24,879
this will denote an encoding of this

250
00:08:24,879 --> 00:08:27,440
particular value in the exponent so the

251
00:08:27,440 --> 00:08:29,199
crs this consists of m random group

252
00:08:29,199 --> 00:08:30,479
elements

253
00:08:30,479 --> 00:08:33,440
denoted by these m random exponents

254
00:08:33,440 --> 00:08:35,839
to commit to a particular vector here a

255
00:08:35,839 --> 00:08:37,839
vector of wire assignments we're simply

256
00:08:37,839 --> 00:08:40,159
going to take a subset product of these

257
00:08:40,159 --> 00:08:41,919
group elements so if you look at the

258
00:08:41,919 --> 00:08:43,279
action of what's happening in the

259
00:08:43,279 --> 00:08:45,040
exponent we're basically going to take a

260
00:08:45,040 --> 00:08:46,959
subset sum of

261
00:08:46,959 --> 00:08:48,800
these random exponents so that would be

262
00:08:48,800 --> 00:08:50,000
the commitment

263
00:08:50,000 --> 00:08:52,320
to a vector

264
00:08:52,320 --> 00:08:53,120
so

265
00:08:53,120 --> 00:08:55,279
what remains is to simply show how we

266
00:08:55,279 --> 00:08:57,279
argue that these committed values are

267
00:08:57,279 --> 00:08:59,680
actually correct or actually uh respect

268
00:08:59,680 --> 00:09:01,600
the circuit constraints so here i'm

269
00:09:01,600 --> 00:09:03,279
going to describe how we're going how we

270
00:09:03,279 --> 00:09:06,320
validate that every single wire is a is

271
00:09:06,320 --> 00:09:08,240
a 0 1 value that is actually a

272
00:09:08,240 --> 00:09:10,240
commitment to a boolean labeling of

273
00:09:10,240 --> 00:09:12,399
every circuit in the instance over

274
00:09:12,399 --> 00:09:14,240
across all of the instances

275
00:09:14,240 --> 00:09:16,320
so we can encode this labeling function

276
00:09:16,320 --> 00:09:19,040
as a quadratic predicate namely an input

277
00:09:19,040 --> 00:09:22,000
x is binary value if x squared is equal

278
00:09:22,000 --> 00:09:24,160
to x

279
00:09:24,160 --> 00:09:26,160
so the key idea here is we're going to

280
00:09:26,160 --> 00:09:28,000
now use a pairing to check this carrying

281
00:09:28,000 --> 00:09:30,240
relation or this quadratic relation in

282
00:09:30,240 --> 00:09:32,560
the exponent and just to recall what a

283
00:09:32,560 --> 00:09:34,640
pairing is is an efficiently computable

284
00:09:34,640 --> 00:09:36,560
bi-linear map that essentially gives us

285
00:09:36,560 --> 00:09:39,040
the power to multiply exponents in a

286
00:09:39,040 --> 00:09:40,720
target group this is the property that

287
00:09:40,720 --> 00:09:43,839
we will leverage in our construction

288
00:09:43,839 --> 00:09:45,040
so what we're going to do is the

289
00:09:45,040 --> 00:09:46,640
following we're going to take the

290
00:09:46,640 --> 00:09:48,480
commitments so the subset sum of the

291
00:09:48,480 --> 00:09:50,080
exponents and we're going to pair it

292
00:09:50,080 --> 00:09:51,279
with itself

293
00:09:51,279 --> 00:09:53,200
and then we're going to also consider

294
00:09:53,200 --> 00:09:54,959
the pairing of the commitment with a

295
00:09:54,959 --> 00:09:57,120
commitment to the all ones vector namely

296
00:09:57,120 --> 00:09:59,200
the sum of all of these exponents in the

297
00:09:59,200 --> 00:10:00,480
exponent

298
00:10:00,480 --> 00:10:02,480
okay so these are the two quantities

299
00:10:02,480 --> 00:10:04,399
that we're going to study so let's see

300
00:10:04,399 --> 00:10:06,399
why these two quantities are actually

301
00:10:06,399 --> 00:10:08,959
useful let's first expand the pairing of

302
00:10:08,959 --> 00:10:11,200
the commitment with itself

303
00:10:11,200 --> 00:10:12,880
so when i pair the commitment with

304
00:10:12,880 --> 00:10:15,279
itself the commitment is a subset sum of

305
00:10:15,279 --> 00:10:16,720
exponents

306
00:10:16,720 --> 00:10:18,560
if i pair it with itself i'm simply

307
00:10:18,560 --> 00:10:20,320
going to get this quantity squared so i

308
00:10:20,320 --> 00:10:21,839
can write out expand all of these

309
00:10:21,839 --> 00:10:24,240
components and basically i can decompose

310
00:10:24,240 --> 00:10:27,200
the result into two sets of terms one

311
00:10:27,200 --> 00:10:29,040
set of terms i will call the non-cross

312
00:10:29,040 --> 00:10:31,519
terms these will be the case when i take

313
00:10:31,519 --> 00:10:33,600
the index i here and i multiply with the

314
00:10:33,600 --> 00:10:35,839
component in index i here so the indices

315
00:10:35,839 --> 00:10:37,440
match and i get something of the form

316
00:10:37,440 --> 00:10:40,000
alpha i squared times x i squared

317
00:10:40,000 --> 00:10:42,000
and then i will have a bunch of

318
00:10:42,000 --> 00:10:43,760
frost terms which is basically the

319
00:10:43,760 --> 00:10:46,399
products of an index i on one side and

320
00:10:46,399 --> 00:10:48,800
index j on the other for i not equal j

321
00:10:48,800 --> 00:10:50,560
so it won't matter what these terms are

322
00:10:50,560 --> 00:10:52,399
eventually what we'll focus on is just

323
00:10:52,399 --> 00:10:54,399
the non-cross terms okay so this is the

324
00:10:54,399 --> 00:10:55,839
first

325
00:10:55,839 --> 00:10:57,760
equation that we're going to look at the

326
00:10:57,760 --> 00:10:59,279
second equation is we'll pair the

327
00:10:59,279 --> 00:11:01,680
commitment well with a commitment to the

328
00:11:01,680 --> 00:11:03,600
all one's vector let's see what happens

329
00:11:03,600 --> 00:11:05,760
here something very similar happens

330
00:11:05,760 --> 00:11:07,040
namely here we have a sum of all the

331
00:11:07,040 --> 00:11:08,640
alpha i's here we have a sum of the

332
00:11:08,640 --> 00:11:11,279
alpha i's we can again decompose this

333
00:11:11,279 --> 00:11:13,680
sum or this product into a collection of

334
00:11:13,680 --> 00:11:16,000
non-cross terms and then a collection of

335
00:11:16,000 --> 00:11:19,040
whatever's left namely the cross terms

336
00:11:19,040 --> 00:11:21,200
so here let's just focus our attention

337
00:11:21,200 --> 00:11:23,120
on the non-cross terms what is the

338
00:11:23,120 --> 00:11:24,959
relation that we're hoping to check well

339
00:11:24,959 --> 00:11:27,040
we want to check that for each i

340
00:11:27,040 --> 00:11:29,360
x y squared is equal to x i that means

341
00:11:29,360 --> 00:11:32,480
that x i is a binary value so if x i

342
00:11:32,480 --> 00:11:34,079
squared equals x i observe that these

343
00:11:34,079 --> 00:11:36,399
two expressions are actually identical

344
00:11:36,399 --> 00:11:38,800
so this means that if the prover

345
00:11:38,800 --> 00:11:40,320
did the correct thing namely it

346
00:11:40,320 --> 00:11:42,640
constructed a commitment to a binary

347
00:11:42,640 --> 00:11:44,079
valued vector

348
00:11:44,079 --> 00:11:46,160
these two equations these two relations

349
00:11:46,160 --> 00:11:48,480
here would actually be identically value

350
00:11:48,480 --> 00:11:50,320
modulo some differences in these cross

351
00:11:50,320 --> 00:11:51,200
terms

352
00:11:51,200 --> 00:11:53,120
so how do we complete the check we're

353
00:11:53,120 --> 00:11:55,360
simply going to give the prover the

354
00:11:55,360 --> 00:11:58,000
ability to eliminate the cross terms in

355
00:11:58,000 --> 00:12:00,240
the construction so these two quantities

356
00:12:00,240 --> 00:12:02,000
will be equal except it's some

357
00:12:02,000 --> 00:12:03,920
differences in cross terms what is that

358
00:12:03,920 --> 00:12:06,160
difference well is this expression here

359
00:12:06,160 --> 00:12:08,320
that depends on alpha i alpha j for i

360
00:12:08,320 --> 00:12:09,600
not equal to j

361
00:12:09,600 --> 00:12:11,279
so what we are going to do is we're now

362
00:12:11,279 --> 00:12:12,959
going to augment the common reference

363
00:12:12,959 --> 00:12:15,200
string with a collection of cross terms

364
00:12:15,200 --> 00:12:16,639
we're just simply going to publish

365
00:12:16,639 --> 00:12:19,440
encodings of alpha i times alpha j

366
00:12:19,440 --> 00:12:21,200
so this will be included now as part of

367
00:12:21,200 --> 00:12:23,680
the common reference string and approver

368
00:12:23,680 --> 00:12:24,480
uh

369
00:12:24,480 --> 00:12:26,079
it can take the common reference string

370
00:12:26,079 --> 00:12:29,040
and compute exactly the quantity here to

371
00:12:29,040 --> 00:12:31,440
verify the verifier will take this

372
00:12:31,440 --> 00:12:34,160
element pair it with the generator and

373
00:12:34,160 --> 00:12:36,880
boom it arrived it derives the frost

374
00:12:36,880 --> 00:12:38,959
term that is needed for the verification

375
00:12:38,959 --> 00:12:41,519
relation to check out

376
00:12:41,519 --> 00:12:43,680
so this completes the description of the

377
00:12:43,680 --> 00:12:46,000
verification relation and then we repair

378
00:12:46,000 --> 00:12:47,519
the commitment with itself pair the

379
00:12:47,519 --> 00:12:48,959
commitment to the with the commitment to

380
00:12:48,959 --> 00:12:50,560
the ones vector

381
00:12:50,560 --> 00:12:52,320
b should be equal if the approver was

382
00:12:52,320 --> 00:12:54,160
honest modulo some differences in cross

383
00:12:54,160 --> 00:12:56,000
terms we'll publish the cross terms in

384
00:12:56,000 --> 00:12:57,600
the common reference string so now

385
00:12:57,600 --> 00:12:59,680
approver can provide exactly the terms

386
00:12:59,680 --> 00:13:01,839
needed for the cancellation to occur and

387
00:13:01,839 --> 00:13:03,680
satisfy this relation

388
00:13:03,680 --> 00:13:05,760
so the non-cross terms here are going to

389
00:13:05,760 --> 00:13:07,920
enforce the check that x i squared

390
00:13:07,920 --> 00:13:10,240
equals x i this is the check that every

391
00:13:10,240 --> 00:13:13,279
uh at every component is binary value

392
00:13:13,279 --> 00:13:14,800
and then we have the non-cross terms

393
00:13:14,800 --> 00:13:17,120
that basically correct for this pairing

394
00:13:17,120 --> 00:13:19,839
check relation

395
00:13:19,839 --> 00:13:21,440
we can actually use what i just

396
00:13:21,440 --> 00:13:23,839
described the same general strategy to

397
00:13:23,839 --> 00:13:26,399
enforce the gate constraints so here i'm

398
00:13:26,399 --> 00:13:28,480
just going to give a very high level uh

399
00:13:28,480 --> 00:13:30,959
sketch so our goal is to now show that

400
00:13:30,959 --> 00:13:32,880
if i the commitments to the output wires

401
00:13:32,880 --> 00:13:35,040
of each gate actually respects the gate

402
00:13:35,040 --> 00:13:37,760
constraint on the input values to each

403
00:13:37,760 --> 00:13:40,320
gate so again we can write this as a

404
00:13:40,320 --> 00:13:42,320
quadratic relation namely the output

405
00:13:42,320 --> 00:13:44,160
value should be the nand of the input

406
00:13:44,160 --> 00:13:46,399
values that is exactly saying that the

407
00:13:46,399 --> 00:13:48,240
output value should be one minus the

408
00:13:48,240 --> 00:13:50,000
product of the inputs this is a nand

409
00:13:50,000 --> 00:13:52,480
gate operation this is again a quadratic

410
00:13:52,480 --> 00:13:55,040
relation we can use the exact same

411
00:13:55,040 --> 00:13:57,360
principle that i just described to check

412
00:13:57,360 --> 00:13:59,279
this in the exponent so i'm not going to

413
00:13:59,279 --> 00:14:00,959
go into details here i'll refer to the

414
00:14:00,959 --> 00:14:03,600
paper but it's using exactly the same

415
00:14:03,600 --> 00:14:06,000
underlying mechanism

416
00:14:06,000 --> 00:14:07,199
so this actually completes the

417
00:14:07,199 --> 00:14:09,600
description of the construction so to

418
00:14:09,600 --> 00:14:11,680
construct a batch argument all we do is

419
00:14:11,680 --> 00:14:13,440
the following we

420
00:14:13,440 --> 00:14:15,199
take a look at each of these wires

421
00:14:15,199 --> 00:14:17,120
compute a vector commitment to each of

422
00:14:17,120 --> 00:14:19,519
those wire labels and then we just check

423
00:14:19,519 --> 00:14:20,320
that

424
00:14:20,320 --> 00:14:22,399
each wire and each gate are properly

425
00:14:22,399 --> 00:14:24,800
computed so the size of the commitment

426
00:14:24,800 --> 00:14:26,639
is just a single group element so the

427
00:14:26,639 --> 00:14:28,480
size depends only polynomially in a

428
00:14:28,480 --> 00:14:30,320
security parameter and does not depend

429
00:14:30,320 --> 00:14:32,079
on the number of instances or the length

430
00:14:32,079 --> 00:14:33,360
of the vectors

431
00:14:33,360 --> 00:14:34,880
for each of these wire predicates and

432
00:14:34,880 --> 00:14:37,120
gate predicates again the proof is

433
00:14:37,120 --> 00:14:38,639
basically this sequence of cross terms

434
00:14:38,639 --> 00:14:40,720
that's needed for the cancellation again

435
00:14:40,720 --> 00:14:42,880
one group element each so the overall

436
00:14:42,880 --> 00:14:44,639
proof size only depend on the size of

437
00:14:44,639 --> 00:14:46,480
the circuit times something that depends

438
00:14:46,480 --> 00:14:48,560
on the security parameter completely

439
00:14:48,560 --> 00:14:50,560
independent of the number of instances

440
00:14:50,560 --> 00:14:53,199
that we're checking

441
00:14:53,199 --> 00:14:54,880
so the one thing that i have not

442
00:14:54,880 --> 00:14:56,880
described is whether this is sound right

443
00:14:56,880 --> 00:14:58,000
so hopefully i've convinced you that

444
00:14:58,000 --> 00:14:59,680
this is a complete construction mainly

445
00:14:59,680 --> 00:15:00,639
if you have a sequence of true

446
00:15:00,639 --> 00:15:02,320
statements you can actually the prover

447
00:15:02,320 --> 00:15:04,560
can manage to convince the verifier but

448
00:15:04,560 --> 00:15:06,240
is this sound right does this actually

449
00:15:06,240 --> 00:15:07,760
work

450
00:15:07,760 --> 00:15:09,279
the soundness here will require some

451
00:15:09,279 --> 00:15:10,079
care

452
00:15:10,079 --> 00:15:11,680
so if we come back to the original

453
00:15:11,680 --> 00:15:13,199
construction the commit improved

454
00:15:13,199 --> 00:15:14,720
strategy used to build non-interactive

455
00:15:14,720 --> 00:15:16,720
zero knowledge by growth of strategy and

456
00:15:16,720 --> 00:15:19,279
sahai they had this very similar type of

457
00:15:19,279 --> 00:15:21,440
strategy so how did we how did they

458
00:15:21,440 --> 00:15:24,079
argue soundness in their construction

459
00:15:24,079 --> 00:15:26,560
in their setting they were what they did

460
00:15:26,560 --> 00:15:29,279
was uh they relied on the ability to

461
00:15:29,279 --> 00:15:31,360
program the crs in a way

462
00:15:31,360 --> 00:15:33,920
that it is possible to extract a witness

463
00:15:33,920 --> 00:15:36,000
from the commitment itself and for a

464
00:15:36,000 --> 00:15:37,839
false statement if we have a false empty

465
00:15:37,839 --> 00:15:40,160
statement no witness exists and so this

466
00:15:40,160 --> 00:15:42,079
is sufficient to argue soundness in fact

467
00:15:42,079 --> 00:15:43,440
statistical soundness of the

468
00:15:43,440 --> 00:15:45,120
construction

469
00:15:45,120 --> 00:15:47,759
so can we try to mimic a similar type of

470
00:15:47,759 --> 00:15:50,880
proof strategy in our setting so here we

471
00:15:50,880 --> 00:15:52,800
are going to run into a bit of trouble

472
00:15:52,800 --> 00:15:54,880
the commitments that we use here are

473
00:15:54,880 --> 00:15:56,639
succinct namely we're committing to a

474
00:15:56,639 --> 00:15:58,560
very long vector using a single group

475
00:15:58,560 --> 00:16:00,800
element and so we can't hope at least

476
00:16:00,800 --> 00:16:02,560
not from some kind of non-knowledge

477
00:16:02,560 --> 00:16:05,040
assumption to extract the entire witness

478
00:16:05,040 --> 00:16:07,040
from just a single short commitment so

479
00:16:07,040 --> 00:16:08,639
we need to rely on a slightly different

480
00:16:08,639 --> 00:16:10,720
strategy and here we use something

481
00:16:10,720 --> 00:16:12,800
called local extractability or somewhere

482
00:16:12,800 --> 00:16:14,480
extractability that has featured

483
00:16:14,480 --> 00:16:16,399
prominently in many similar works on

484
00:16:16,399 --> 00:16:18,000
constructing succinct arguments and

485
00:16:18,000 --> 00:16:20,560
batch arguments in recent years

486
00:16:20,560 --> 00:16:23,680
though the idea here is as follows

487
00:16:23,680 --> 00:16:24,959
we will define two different

488
00:16:24,959 --> 00:16:26,720
distributions for the common reference

489
00:16:26,720 --> 00:16:27,920
string

490
00:16:27,920 --> 00:16:29,519
what i will call the normal mode which

491
00:16:29,519 --> 00:16:31,920
is what i just described just having the

492
00:16:31,920 --> 00:16:33,600
random group elements and then the cross

493
00:16:33,600 --> 00:16:34,959
terms

494
00:16:34,959 --> 00:16:36,480
and then there will be a second mode

495
00:16:36,480 --> 00:16:38,320
which we will call the extracting mode

496
00:16:38,320 --> 00:16:39,600
and the extracting mode will have a

497
00:16:39,600 --> 00:16:42,160
special index i associated with it and

498
00:16:42,160 --> 00:16:44,560
it will have the property that

499
00:16:44,560 --> 00:16:47,120
when you sample a crs in the extracting

500
00:16:47,120 --> 00:16:48,000
mode

501
00:16:48,000 --> 00:16:49,759
there will be a trapdoor that will allow

502
00:16:49,759 --> 00:16:51,839
you to take a valid proof and extract

503
00:16:51,839 --> 00:16:53,759
from it a witness but not a witness to

504
00:16:53,759 --> 00:16:55,360
all of the instances we can't hope to do

505
00:16:55,360 --> 00:16:56,399
that because we don't have enough

506
00:16:56,399 --> 00:16:58,480
information it will allow us to extract

507
00:16:58,480 --> 00:17:01,120
a witness for just the i instance so if

508
00:17:01,120 --> 00:17:03,360
the proof verifies i can find a witness

509
00:17:03,360 --> 00:17:06,000
wi such that for the i instance this is

510
00:17:06,000 --> 00:17:08,480
a valid witness

511
00:17:08,480 --> 00:17:10,480
and moreover we will require that the

512
00:17:10,480 --> 00:17:12,079
common reference string in these two

513
00:17:12,079 --> 00:17:14,000
modes are actually computationally

514
00:17:14,000 --> 00:17:15,919
indistinguishable so this is very

515
00:17:15,919 --> 00:17:17,599
similar to notions like dual mode proof

516
00:17:17,599 --> 00:17:19,280
systems or somewhere statistically

517
00:17:19,280 --> 00:17:21,119
binding hash functions very similar

518
00:17:21,119 --> 00:17:22,880
paradigm

519
00:17:22,880 --> 00:17:25,039
and if we can show these two properties

520
00:17:25,039 --> 00:17:27,119
this is sufficient to argue non-adaptive

521
00:17:27,119 --> 00:17:30,080
soundness of the resulting construction

522
00:17:30,080 --> 00:17:32,320
so first i need to tell you how we

523
00:17:32,320 --> 00:17:34,160
sample the crs in these two different

524
00:17:34,160 --> 00:17:36,640
modes the first what i've written here

525
00:17:36,640 --> 00:17:37,919
is the normal mode for the common

526
00:17:37,919 --> 00:17:39,840
reference string just the collection of

527
00:17:39,840 --> 00:17:41,440
random group elements nothing has

528
00:17:41,440 --> 00:17:43,520
changed so far i omitted the cross term

529
00:17:43,520 --> 00:17:45,760
for simplicity

530
00:17:45,760 --> 00:17:48,160
if i want to switch to extracting mode

531
00:17:48,160 --> 00:17:50,400
on a particular index here denoted i

532
00:17:50,400 --> 00:17:52,160
star what i'm going to do is i'm going

533
00:17:52,160 --> 00:17:55,600
to take my crs which has m random group

534
00:17:55,600 --> 00:17:58,160
elements and i'm going to lift element i

535
00:17:58,160 --> 00:18:00,160
star from being in the subgroup to the

536
00:18:00,160 --> 00:18:02,160
full group so far everything i have

537
00:18:02,160 --> 00:18:04,320
described works in a sub proof of order

538
00:18:04,320 --> 00:18:05,200
p

539
00:18:05,200 --> 00:18:06,640
what i'm going to do now

540
00:18:06,640 --> 00:18:08,320
when i want to switch to extracting mode

541
00:18:08,320 --> 00:18:09,600
is i'm going to take that subgroup

542
00:18:09,600 --> 00:18:11,679
component and lift it to the full group

543
00:18:11,679 --> 00:18:13,200
that's the only thing i change in a

544
00:18:13,200 --> 00:18:14,640
common reference string and i define the

545
00:18:14,640 --> 00:18:16,960
cross terms analogous

546
00:18:16,960 --> 00:18:18,799
by the subgroup decision assumption

547
00:18:18,799 --> 00:18:20,880
which basically says a random element in

548
00:18:20,880 --> 00:18:22,480
the subgroup is computationally

549
00:18:22,480 --> 00:18:24,080
indistinguishable from a random element

550
00:18:24,080 --> 00:18:25,760
in the full group of a composite order

551
00:18:25,760 --> 00:18:27,679
group we can argue that these two crs

552
00:18:27,679 --> 00:18:29,039
distributions are actually

553
00:18:29,039 --> 00:18:32,400
computationally indistinguishable

554
00:18:32,400 --> 00:18:33,200
so

555
00:18:33,200 --> 00:18:35,280
how does this help

556
00:18:35,280 --> 00:18:36,799
so the trap door in our construction

557
00:18:36,799 --> 00:18:38,559
will be a generator for the orderq

558
00:18:38,559 --> 00:18:40,559
subgroup and the way that we're going to

559
00:18:40,559 --> 00:18:42,799
extract so suppose i have a commitment

560
00:18:42,799 --> 00:18:44,240
that's commit that's computed with

561
00:18:44,240 --> 00:18:46,320
respect to this new crs where in

562
00:18:46,320 --> 00:18:48,240
position i star i have now switched from

563
00:18:48,240 --> 00:18:50,080
an element of the subgroup to an element

564
00:18:50,080 --> 00:18:51,440
of the full group

565
00:18:51,440 --> 00:18:53,120
the way that we can extract is simply by

566
00:18:53,120 --> 00:18:55,760
projecting into the order q subgroup i'm

567
00:18:55,760 --> 00:18:57,120
going to say that a commitment is a

568
00:18:57,120 --> 00:18:59,840
commitment to zero if its projection or

569
00:18:59,840 --> 00:19:01,679
its component in the order q subgroup is

570
00:19:01,679 --> 00:19:03,919
zero and is a commitment to one if it's

571
00:19:03,919 --> 00:19:05,120
non-zero

572
00:19:05,120 --> 00:19:07,440
so using a pairing i can efficiently uh

573
00:19:07,440 --> 00:19:10,720
to perform this procedure

574
00:19:10,720 --> 00:19:12,720
so what remains to show is that this

575
00:19:12,720 --> 00:19:15,120
actually successfully extracts a witness

576
00:19:15,120 --> 00:19:17,440
for the chosen target

577
00:19:17,440 --> 00:19:19,200
the light i'll just demonstrate it for

578
00:19:19,200 --> 00:19:21,360
the case of the wire validity checks so

579
00:19:21,360 --> 00:19:23,200
consider again the wire validity check

580
00:19:23,200 --> 00:19:24,880
that i described at the earlier on in

581
00:19:24,880 --> 00:19:26,160
this talk i'm going to pair the

582
00:19:26,160 --> 00:19:27,760
commitments with itself share the

583
00:19:27,760 --> 00:19:30,880
commitment with the r1s vector and then

584
00:19:30,880 --> 00:19:32,720
have this final component which is the

585
00:19:32,720 --> 00:19:35,039
cross terms cancellation component

586
00:19:35,039 --> 00:19:37,039
so let's study this equation in more

587
00:19:37,039 --> 00:19:39,280
detail what components does the

588
00:19:39,280 --> 00:19:41,200
adversary control well the adversary

589
00:19:41,200 --> 00:19:42,480
gets to choose the commitment we don't

590
00:19:42,480 --> 00:19:43,919
know how the adversary comes up with the

591
00:19:43,919 --> 00:19:45,919
commitment it cooks them up an arbitrary

592
00:19:45,919 --> 00:19:48,000
group element that's the commitment and

593
00:19:48,000 --> 00:19:50,000
it can also choose this arbitrary

594
00:19:50,000 --> 00:19:53,120
opening or arbitrary proof v for

595
00:19:53,120 --> 00:19:55,039
satisfying the wire validity checks

596
00:19:55,039 --> 00:19:56,640
those components are under the control

597
00:19:56,640 --> 00:19:58,880
of the adversary

598
00:19:58,880 --> 00:20:00,160
what's not under the control of the

599
00:20:00,160 --> 00:20:02,559
adversary however is the generator gp

600
00:20:02,559 --> 00:20:04,400
and this commitment to the all ones

601
00:20:04,400 --> 00:20:06,240
vector these are determined completely

602
00:20:06,240 --> 00:20:07,760
by the common reference string and we

603
00:20:07,760 --> 00:20:09,120
can assume that the common reference

604
00:20:09,120 --> 00:20:11,919
string was honestly generated so

605
00:20:11,919 --> 00:20:13,919
these components are outside the control

606
00:20:13,919 --> 00:20:16,240
of the adversary

607
00:20:16,240 --> 00:20:17,840
the second observation that we will

608
00:20:17,840 --> 00:20:20,320
require is that if this pairing relation

609
00:20:20,320 --> 00:20:22,400
holds because we are operating over a

610
00:20:22,400 --> 00:20:24,480
composite order group right a group of

611
00:20:24,480 --> 00:20:27,039
order p times q by the chinese remainder

612
00:20:27,039 --> 00:20:29,440
theorem if this holds mod n it must in

613
00:20:29,440 --> 00:20:31,600
particular hold in the mod p sub group

614
00:20:31,600 --> 00:20:34,080
and the order q sub group so this

615
00:20:34,080 --> 00:20:36,640
relation holds in order p and the order

616
00:20:36,640 --> 00:20:38,720
q subgroups and we're going to consider

617
00:20:38,720 --> 00:20:42,159
what happens in the order q subgroup

618
00:20:42,159 --> 00:20:44,080
so the final ingredient that we will

619
00:20:44,080 --> 00:20:46,080
need in our soundness analysis

620
00:20:46,080 --> 00:20:47,600
is that if we look at this expression

621
00:20:47,600 --> 00:20:48,480
here

622
00:20:48,480 --> 00:20:50,320
this verification relation has three

623
00:20:50,320 --> 00:20:52,320
pairing products that is computing or

624
00:20:52,320 --> 00:20:54,240
three pairing operations

625
00:20:54,240 --> 00:20:56,480
the final component here we're going to

626
00:20:56,480 --> 00:20:58,240
pair something in the order p subgroup

627
00:20:58,240 --> 00:21:00,080
and something under uh that's controlled

628
00:21:00,080 --> 00:21:01,600
by the adversary

629
00:21:01,600 --> 00:21:03,360
the point is that because we're pairing

630
00:21:03,360 --> 00:21:05,600
with the generator for the order p group

631
00:21:05,600 --> 00:21:07,600
whatever the adversary does completely

632
00:21:07,600 --> 00:21:10,240
vanishes it cannot affect what happens

633
00:21:10,240 --> 00:21:13,120
in order q subgroup so what if we only

634
00:21:13,120 --> 00:21:14,320
analyze what happened with this

635
00:21:14,320 --> 00:21:16,320
verification relation in the order q

636
00:21:16,320 --> 00:21:18,480
subgroup we have basically isolated a

637
00:21:18,480 --> 00:21:21,440
single instance the instance i start so

638
00:21:21,440 --> 00:21:22,480
let's just see

639
00:21:22,480 --> 00:21:25,120
mathematically how that happens so let's

640
00:21:25,120 --> 00:21:27,120
suppose that the commitment is just some

641
00:21:27,120 --> 00:21:28,720
group element has some component in

642
00:21:28,720 --> 00:21:31,200
order p group and the order q group our

643
00:21:31,200 --> 00:21:34,159
adversary can choose this arbitrarily

644
00:21:34,159 --> 00:21:35,840
the complement of the all once has a

645
00:21:35,840 --> 00:21:37,679
particular structure determined by the

646
00:21:37,679 --> 00:21:39,600
crs

647
00:21:39,600 --> 00:21:41,520
so if we consider this relation in the

648
00:21:41,520 --> 00:21:43,600
order q subgroup whatever the adversary

649
00:21:43,600 --> 00:21:45,440
does here has no effect we can just

650
00:21:45,440 --> 00:21:46,720
completely ignore it because it's

651
00:21:46,720 --> 00:21:48,080
projected away

652
00:21:48,080 --> 00:21:49,919
all we're left with is the relationship

653
00:21:49,919 --> 00:21:52,080
here the relation that needs to be

654
00:21:52,080 --> 00:21:55,200
satisfied for this equation to hold is

655
00:21:55,200 --> 00:21:56,960
any order q subgroup whatever the

656
00:21:56,960 --> 00:21:58,400
adversary chose for the commitment

657
00:21:58,400 --> 00:22:00,480
quantity squared must equal whatever the

658
00:22:00,480 --> 00:22:02,480
adversary chose for the commitment times

659
00:22:02,480 --> 00:22:04,799
this honestly chosen value r

660
00:22:04,799 --> 00:22:06,960
this equation has only two solutions

661
00:22:06,960 --> 00:22:09,360
either t is equal to zero in which case

662
00:22:09,360 --> 00:22:12,080
this was a commitment to the bit zero or

663
00:22:12,080 --> 00:22:14,640
p was equal to r which in this case

664
00:22:14,640 --> 00:22:16,159
means that this was a commitment to the

665
00:22:16,159 --> 00:22:17,200
bit 1.

666
00:22:17,200 --> 00:22:19,440
so in this way we have argued that if

667
00:22:19,440 --> 00:22:22,000
the wire validity checks pass then in

668
00:22:22,000 --> 00:22:23,919
the order q group the adversary could

669
00:22:23,919 --> 00:22:25,600
have either committed to zero or

670
00:22:25,600 --> 00:22:27,120
committed to one they must have used the

671
00:22:27,120 --> 00:22:29,200
honest strategy in order to satisfy this

672
00:22:29,200 --> 00:22:30,240
relation

673
00:22:30,240 --> 00:22:31,840
and now by a very similar type of

674
00:22:31,840 --> 00:22:34,880
analysis we can also show that the

675
00:22:34,880 --> 00:22:37,600
extracted bits must also satisfy each of

676
00:22:37,600 --> 00:22:39,919
these gate predicates so by very similar

677
00:22:39,919 --> 00:22:41,760
analysis i won't have time to show the

678
00:22:41,760 --> 00:22:44,000
details here

679
00:22:44,000 --> 00:22:46,320
so this completes the soundness analysis

680
00:22:46,320 --> 00:22:49,200
of our construction and actually gives a

681
00:22:49,200 --> 00:22:52,080
complete batch argument for general mp

682
00:22:52,080 --> 00:22:54,880
so again just to remind you how how the

683
00:22:54,880 --> 00:22:56,960
construction works the approver starts

684
00:22:56,960 --> 00:22:58,720
by committing to all of the wire

685
00:22:58,720 --> 00:23:00,240
assignments across all of the different

686
00:23:00,240 --> 00:23:04,000
instances and then the approver uh gives

687
00:23:04,000 --> 00:23:06,559
a proof that each wire uh each

688
00:23:06,559 --> 00:23:09,039
commitment to the wires are binary value

689
00:23:09,039 --> 00:23:11,679
and that all of them respect the gate

690
00:23:11,679 --> 00:23:12,960
constraints

691
00:23:12,960 --> 00:23:14,799
so this is a commit and prove strategy

692
00:23:14,799 --> 00:23:16,799
for constructing batch arguments

693
00:23:16,799 --> 00:23:18,320
so now let me just tell you a few about

694
00:23:18,320 --> 00:23:20,159
a few extensions to the basic

695
00:23:20,159 --> 00:23:22,559
construction here so so far everything

696
00:23:22,559 --> 00:23:24,640
i've described is a new setting of

697
00:23:24,640 --> 00:23:26,799
composite order groups suppose you want

698
00:23:26,799 --> 00:23:28,799
to work in prime order groups this is

699
00:23:28,799 --> 00:23:30,240
actually

700
00:23:30,240 --> 00:23:32,880
a fairly standard to do the way that we

701
00:23:32,880 --> 00:23:34,320
will do it is we will simulate these

702
00:23:34,320 --> 00:23:37,360
subgroups with subspaces in a prime in a

703
00:23:37,360 --> 00:23:39,840
vector space and this projecting

704
00:23:39,840 --> 00:23:42,000
property we will implement using an

705
00:23:42,000 --> 00:23:44,799
outer product of vectors so using this

706
00:23:44,799 --> 00:23:47,200
we are able to construct

707
00:23:47,200 --> 00:23:49,520
an analog of this construction using

708
00:23:49,520 --> 00:23:51,760
prime order asymmetric groups and we can

709
00:23:51,760 --> 00:23:53,760
base hardness on a standard k linear

710
00:23:53,760 --> 00:23:55,919
assumption for any k and that's at least

711
00:23:55,919 --> 00:23:57,760
one

712
00:23:57,760 --> 00:24:00,720
the second uh thing i want to tell you

713
00:24:00,720 --> 00:24:02,799
is that if we look at the construction

714
00:24:02,799 --> 00:24:04,960
that i've described so far it has a very

715
00:24:04,960 --> 00:24:07,120
long crs right the crs consists of these

716
00:24:07,120 --> 00:24:08,640
random group elements one for each

717
00:24:08,640 --> 00:24:12,000
instance and it also consists of this

718
00:24:12,000 --> 00:24:14,480
giant collection of cross terms right we

719
00:24:14,480 --> 00:24:16,880
need to right now as i written it it's

720
00:24:16,880 --> 00:24:18,960
the side of the crs scales quadratically

721
00:24:18,960 --> 00:24:20,960
with the number of instances it turns

722
00:24:20,960 --> 00:24:23,200
out that we can improve upon this using

723
00:24:23,200 --> 00:24:24,960
a standard recursive composition

724
00:24:24,960 --> 00:24:26,960
strategy some very similar to the one

725
00:24:26,960 --> 00:24:29,440
previously used by collide netanyang we

726
00:24:29,440 --> 00:24:31,919
can actually reduce the size of the crs

727
00:24:31,919 --> 00:24:33,919
from quadratic in a number of instances

728
00:24:33,919 --> 00:24:36,000
to m to the epsilon for any constant

729
00:24:36,000 --> 00:24:37,440
epsilon so you can choose epsilon

730
00:24:37,440 --> 00:24:39,200
however small you want of course we're

731
00:24:39,200 --> 00:24:41,279
going to blow up by a large polynomial

732
00:24:41,279 --> 00:24:42,960
and security parameter but the

733
00:24:42,960 --> 00:24:44,480
dependence on the number of instances

734
00:24:44,480 --> 00:24:46,640
can be an arbitrarily small polynomial

735
00:24:46,640 --> 00:24:49,279
in a number of instances

736
00:24:49,279 --> 00:24:50,320
finally

737
00:24:50,320 --> 00:24:52,559
once we have a new batch argument for mp

738
00:24:52,559 --> 00:24:54,159
we can use it to get

739
00:24:54,159 --> 00:24:57,039
a succinct argument or snark for p or

740
00:24:57,039 --> 00:24:59,039
otherwise called a ram delegation scheme

741
00:24:59,039 --> 00:25:01,039
this essentially is just by plugging

742
00:25:01,039 --> 00:25:02,960
everything in to the previous compiler

743
00:25:02,960 --> 00:25:06,000
budgetary gin and jin so just to recall

744
00:25:06,000 --> 00:25:07,840
in their compiler they show how to start

745
00:25:07,840 --> 00:25:10,000
from a batch argument for mp in

746
00:25:10,000 --> 00:25:11,760
conjunction with a somewhere extractable

747
00:25:11,760 --> 00:25:13,760
commitment this can be used to obtain a

748
00:25:13,760 --> 00:25:16,240
delegation scheme for ram programs our

749
00:25:16,240 --> 00:25:17,919
work we give a new construction of batch

750
00:25:17,919 --> 00:25:19,760
arguments for np

751
00:25:19,760 --> 00:25:22,720
and our techniques essentially also give

752
00:25:22,720 --> 00:25:24,559
us a somewhere extractable commitment it

753
00:25:24,559 --> 00:25:26,640
doesn't follow as a black box but using

754
00:25:26,640 --> 00:25:29,840
the same kinds of uh methodology we're

755
00:25:29,840 --> 00:25:31,360
able to construct this also from

756
00:25:31,360 --> 00:25:33,200
standard pairing based assumptions and

757
00:25:33,200 --> 00:25:35,039
this country and this combination is

758
00:25:35,039 --> 00:25:37,039
sufficient to get a delegation scheme

759
00:25:37,039 --> 00:25:39,520
program programs uh where the size of

760
00:25:39,520 --> 00:25:41,679
the common reference string skills

761
00:25:41,679 --> 00:25:44,159
polynomially or sublinearly with the

762
00:25:44,159 --> 00:25:45,600
number with the running time of the

763
00:25:45,600 --> 00:25:47,600
computation being checked

764
00:25:47,600 --> 00:25:49,440
so previously from pairings this either

765
00:25:49,440 --> 00:25:51,279
relied on non-standard assumptions or

766
00:25:51,279 --> 00:25:54,480
needed a quadratic size crs

767
00:25:54,480 --> 00:25:57,120
okay so to wrap up uh this the focus of

768
00:25:57,120 --> 00:25:59,120
this talk has been on constructing batch

769
00:25:59,120 --> 00:26:01,200
arguments from standard assumptions over

770
00:26:01,200 --> 00:26:03,360
by linear maps and the key feature of

771
00:26:03,360 --> 00:26:05,440
our construction is that it gives a very

772
00:26:05,440 --> 00:26:09,440
direct construction uh direct algebraic

773
00:26:09,440 --> 00:26:11,279
construction of batch arguments and

774
00:26:11,279 --> 00:26:13,360
avoids the heavy cryptographic or

775
00:26:13,360 --> 00:26:15,120
information theoretic tools that have

776
00:26:15,120 --> 00:26:17,600
been commonly used in previous

777
00:26:17,600 --> 00:26:19,200
constructions it gives a direct complete

778
00:26:19,200 --> 00:26:22,159
commit to improve approach for realizing

779
00:26:22,159 --> 00:26:24,159
batch arguments

780
00:26:24,159 --> 00:26:26,080
and at the coral areas we get a ram

781
00:26:26,080 --> 00:26:27,919
delegation scheme we get an aggregate

782
00:26:27,919 --> 00:26:29,679
signature scheme that supports bounded

783
00:26:29,679 --> 00:26:31,919
aggregation in a plane model and with

784
00:26:31,919 --> 00:26:36,360
that i'll conclude thank you very much

785
00:26:42,400 --> 00:26:43,760
so we actually have plenty of time for

786
00:26:43,760 --> 00:26:45,760
questions despite the late start

787
00:26:45,760 --> 00:26:46,480
so

788
00:26:46,480 --> 00:26:49,039
for questions

789
00:26:49,039 --> 00:26:50,480
i encourage you to come down and use the

790
00:26:50,480 --> 00:26:53,840
microphones on the side

791
00:26:54,159 --> 00:26:56,000
maybe while people are waiting i have a

792
00:26:56,000 --> 00:26:57,520
question actually can you uh say a

793
00:26:57,520 --> 00:26:58,799
little something about the split

794
00:26:58,799 --> 00:27:01,440
verification procedure

795
00:27:01,440 --> 00:27:03,600
yeah so the split verification procedure

796
00:27:03,600 --> 00:27:06,880
basically says um you want to you want

797
00:27:06,880 --> 00:27:08,400
to split your verification procedure

798
00:27:08,400 --> 00:27:10,080
into an offline phase and then online

799
00:27:10,080 --> 00:27:11,919
phase so normal verification first of

800
00:27:11,919 --> 00:27:13,840
all will require that the verifier read

801
00:27:13,840 --> 00:27:15,279
all of the statements right because it

802
00:27:15,279 --> 00:27:16,720
needs to check that your proof is

803
00:27:16,720 --> 00:27:18,159
actually valid for a particular set of

804
00:27:18,159 --> 00:27:20,000
statements and that will always grow

805
00:27:20,000 --> 00:27:22,399
linearly with the number of instances so

806
00:27:22,399 --> 00:27:24,399
with split verification what we want is

807
00:27:24,399 --> 00:27:26,240
there's a two phases there's an offline

808
00:27:26,240 --> 00:27:28,799
step and an online step the offline step

809
00:27:28,799 --> 00:27:30,080
is allowed to depend on its full

810
00:27:30,080 --> 00:27:32,480
sequence of statements and if

811
00:27:32,480 --> 00:27:34,799
and it outputs a very short

812
00:27:34,799 --> 00:27:37,039
verification state and online

813
00:27:37,039 --> 00:27:39,039
verification then only needs to read a

814
00:27:39,039 --> 00:27:41,279
short verification state and can scale

815
00:27:41,279 --> 00:27:43,360
sublinearly with the number of instances

816
00:27:43,360 --> 00:27:44,880
and that's actually critical for this

817
00:27:44,880 --> 00:27:46,559
recursive bootstrapping because we want

818
00:27:46,559 --> 00:27:48,559
that the verification algorithm that

819
00:27:48,559 --> 00:27:50,559
we're going to compose with itself to

820
00:27:50,559 --> 00:27:52,640
actually have a verification size that

821
00:27:52,640 --> 00:27:53,840
is much smaller than the number of

822
00:27:53,840 --> 00:27:55,440
instances so that's why we split it into

823
00:27:55,440 --> 00:27:57,200
a pre-computation step and a

824
00:27:57,200 --> 00:27:59,520
post-processing step

825
00:27:59,520 --> 00:28:00,720
okay thank you

826
00:28:00,720 --> 00:28:02,080
questions out we have some no yeah here

827
00:28:02,080 --> 00:28:03,279
in the front

828
00:28:03,279 --> 00:28:05,520
yeah

829
00:28:09,919 --> 00:28:12,919
um

830
00:28:17,520 --> 00:28:20,000
ah so you want to just from quadratic to

831
00:28:20,000 --> 00:28:21,600
linear size cs

832
00:28:21,600 --> 00:28:23,360
yeah so then you only have to

833
00:28:23,360 --> 00:28:25,200
compose once so i think it goes from

834
00:28:25,200 --> 00:28:27,520
lambda to something like lambda squared

835
00:28:27,520 --> 00:28:28,799
yeah i would have to check the concrete

836
00:28:28,799 --> 00:28:30,320
thing i think it basically blows it up

837
00:28:30,320 --> 00:28:34,120
by a quadratic vector

838
00:28:45,679 --> 00:28:47,840
ah so that was just for the

839
00:28:47,840 --> 00:28:50,000
that was i think for the

840
00:28:50,000 --> 00:28:52,000
uh the commitment to the all ones right

841
00:28:52,000 --> 00:28:54,320
so the commitment to the r1s vector uh

842
00:28:54,320 --> 00:28:56,320
in this case in the extracting mode we

843
00:28:56,320 --> 00:28:57,520
had to move from the subgroup to the

844
00:28:57,520 --> 00:28:58,960
full group so it was actually critical

845
00:28:58,960 --> 00:29:01,600
for the soundness analysis that at least

846
00:29:01,600 --> 00:29:03,440
one of the components in the crs

847
00:29:03,440 --> 00:29:05,679
actually has a non-zero component in our

848
00:29:05,679 --> 00:29:07,679
q subgroup but that was needed for the

849
00:29:07,679 --> 00:29:10,159
extraction

850
00:29:10,880 --> 00:29:12,880
why

851
00:29:12,880 --> 00:29:15,360
ah so for the security proof yeah

852
00:29:15,360 --> 00:29:17,200
uh yes so in order to invoke sub-group

853
00:29:17,200 --> 00:29:19,279
decision it says that random element in

854
00:29:19,279 --> 00:29:21,120
the subgroup is indistinguishable from a

855
00:29:21,120 --> 00:29:22,960
random element in a full group so they

856
00:29:22,960 --> 00:29:24,399
you cannot have the random element in a

857
00:29:24,399 --> 00:29:28,719
full group have a one in the g2 subgroup

858
00:29:29,919 --> 00:29:33,039
other questions yes here

859
00:29:37,840 --> 00:29:40,840
yes

860
00:29:44,960 --> 00:29:47,440
that's right

861
00:29:52,960 --> 00:29:54,480
that's right that's right so you have to

862
00:29:54,480 --> 00:29:55,679
be able to repeat

863
00:29:55,679 --> 00:29:57,440
yeah so the question is about adaptive

864
00:29:57,440 --> 00:29:59,039
soundness and can we hope to prove that

865
00:29:59,039 --> 00:30:00,880
from standard assumptions

866
00:30:00,880 --> 00:30:02,640
uh yes so

867
00:30:02,640 --> 00:30:04,559
yes and no so i don't think there's any

868
00:30:04,559 --> 00:30:06,480
barrier to showing a batch argument with

869
00:30:06,480 --> 00:30:08,080
adaptive soundness now if you have a

870
00:30:08,080 --> 00:30:10,000
batch argument of knowledge so you can

871
00:30:10,000 --> 00:30:12,480
actually extract a full witness and it's

872
00:30:12,480 --> 00:30:14,320
adaptively sound that would actually be

873
00:30:14,320 --> 00:30:16,080
sufficient to get an adaptively sound

874
00:30:16,080 --> 00:30:18,559
snark which but then by the gentry wix

875
00:30:18,559 --> 00:30:20,559
separation would mean that we would

876
00:30:20,559 --> 00:30:22,240
likely have to rely on some kind of

877
00:30:22,240 --> 00:30:24,159
non-falsifiable assumption but at least

878
00:30:24,159 --> 00:30:25,679
if we don't require full argument of

879
00:30:25,679 --> 00:30:27,600
knowledge if you just want soundness it

880
00:30:27,600 --> 00:30:29,360
is potentially possible that we can have

881
00:30:29,360 --> 00:30:31,360
fully adaptive soundness i don't think

882
00:30:31,360 --> 00:30:36,039
there's a separation currently though

883
00:30:36,320 --> 00:30:38,080
time for one more question

884
00:30:38,080 --> 00:30:41,080
yeah

885
00:30:48,720 --> 00:30:50,480
yeah so basically that's a great

886
00:30:50,480 --> 00:30:52,000
question so how does the proving time

887
00:30:52,000 --> 00:30:53,919
interact with the sort of this recursive

888
00:30:53,919 --> 00:30:56,000
bootstrapping uh so essentially what

889
00:30:56,000 --> 00:30:57,440
happens is

890
00:30:57,440 --> 00:30:58,399
uh

891
00:30:58,399 --> 00:31:00,399
then each time you recursively compose

892
00:31:00,399 --> 00:31:04,080
it it takes you from a crs of size uh

893
00:31:04,080 --> 00:31:06,000
let's say lambda to square root of

894
00:31:06,000 --> 00:31:08,640
lambda uh and the proving time uh and

895
00:31:08,640 --> 00:31:10,320
the blow up sorry it goes from square

896
00:31:10,320 --> 00:31:12,480
root of m to sorry to m to square root

897
00:31:12,480 --> 00:31:14,559
of m and a flow up in the security

898
00:31:14,559 --> 00:31:16,240
parameter roughly goes from like lambda

899
00:31:16,240 --> 00:31:18,640
to lambda squared uh so basically i

900
00:31:18,640 --> 00:31:21,120
think it would improve it uh you incur a

901
00:31:21,120 --> 00:31:23,200
factor that is quadratic in the security

902
00:31:23,200 --> 00:31:25,279
parameter

903
00:31:25,279 --> 00:31:26,880
yeah so i think for concrete efficiency

904
00:31:26,880 --> 00:31:28,960
purposes it's probably advantageous to

905
00:31:28,960 --> 00:31:30,480
actually just use the base construction

906
00:31:30,480 --> 00:31:32,799
and not use the recursive composition so

907
00:31:32,799 --> 00:31:34,159
the recursive composition i think is

908
00:31:34,159 --> 00:31:35,360
just interesting from a theoretical

909
00:31:35,360 --> 00:31:37,519
feasibility perspective but if you were

910
00:31:37,519 --> 00:31:38,880
to use the construction i would

911
00:31:38,880 --> 00:31:40,399
recommend using the one with the

912
00:31:40,399 --> 00:31:43,518
quadratic size crs

913
00:31:44,960 --> 00:31:46,880
all right with that let's thank david

914
00:31:46,880 --> 00:31:49,919
again great thank you

915
00:31:58,240 --> 00:32:01,840
great thank you

916
00:32:55,840 --> 00:32:57,918
you

917
00:33:21,519 --> 00:33:23,679
all right so the second paper in this

918
00:33:23,679 --> 00:33:26,720
best paper session and our first uh best

919
00:33:26,720 --> 00:33:28,880
paper winner by uh

920
00:33:28,880 --> 00:33:31,360
early career researcher is breaking

921
00:33:31,360 --> 00:33:34,159
rainbow takes a weekend on a laptop

922
00:33:34,159 --> 00:33:36,640
by lord villains and

923
00:33:36,640 --> 00:33:38,000
surprisingly award we'll give the talk

924
00:33:38,000 --> 00:33:39,279
support please

925
00:33:39,279 --> 00:33:41,840
yeah uh so hello everyone yeah i'm

926
00:33:41,840 --> 00:33:44,080
talking about gift chances of rainbow

927
00:33:44,080 --> 00:33:46,559
um so i'll start by explaining what was

928
00:33:46,559 --> 00:33:48,720
rainbow so it's one of the the finalists

929
00:33:48,720 --> 00:33:50,960
in the nist sports quantum competition

930
00:33:50,960 --> 00:33:52,880
for digital signatures

931
00:33:52,880 --> 00:33:54,880
the other two being crystals lithium and

932
00:33:54,880 --> 00:33:56,640
falcon they're based on structured

933
00:33:56,640 --> 00:33:58,559
lattices and rainbow is different is

934
00:33:58,559 --> 00:33:59,919
based on multivariate quadratic

935
00:33:59,919 --> 00:34:01,600
equations

936
00:34:01,600 --> 00:34:03,840
uh yeah it has some some good properties

937
00:34:03,840 --> 00:34:06,559
the the signatures are quite small and

938
00:34:06,559 --> 00:34:08,239
it's as good performance in terms of

939
00:34:08,239 --> 00:34:10,320
signing time and verification time

940
00:34:10,320 --> 00:34:12,639
uh the drawbacks are that the public

941
00:34:12,639 --> 00:34:14,960
keys are quite large and uh yeah as it

942
00:34:14,960 --> 00:34:16,800
turns out that it's not secure so that's

943
00:34:16,800 --> 00:34:18,480
what we'll

944
00:34:18,480 --> 00:34:21,119
talk about today

945
00:34:21,119 --> 00:34:23,520
okay so the history of rainbow uh starts

946
00:34:23,520 --> 00:34:25,599
actually before a rainbow was invented

947
00:34:25,599 --> 00:34:27,760
so it's based on this scheme uh by

948
00:34:27,760 --> 00:34:31,119
pataren uh from 1997 where he invented

949
00:34:31,119 --> 00:34:33,199
the oil and vinegar scheme

950
00:34:33,199 --> 00:34:35,119
but this game had the drawback that the

951
00:34:35,119 --> 00:34:38,159
public keys are quite large so in 2005

952
00:34:38,159 --> 00:34:40,639
ding and schmidt invented this

953
00:34:40,639 --> 00:34:42,560
variant of rainbow that somehow combines

954
00:34:42,560 --> 00:34:44,960
multiple layers of oil and vinegar

955
00:34:44,960 --> 00:34:47,520
to get something with slightly smaller

956
00:34:47,520 --> 00:34:49,520
public keys

957
00:34:49,520 --> 00:34:50,879
and then there was a lot of

958
00:34:50,879 --> 00:34:52,719
cryptanalysis in

959
00:34:52,719 --> 00:34:55,440
right after it was invented but that

960
00:34:55,440 --> 00:34:58,079
dried up pretty quickly uh and i think

961
00:34:58,079 --> 00:34:58,720
in

962
00:34:58,720 --> 00:35:00,400
2008

963
00:35:00,400 --> 00:35:03,520
the last attack was found so and then

964
00:35:03,520 --> 00:35:05,200
there was a long period where nothing

965
00:35:05,200 --> 00:35:06,960
really happened until

966
00:35:06,960 --> 00:35:10,079
um rainbow was entered in the nist

967
00:35:10,079 --> 00:35:11,359
process

968
00:35:11,359 --> 00:35:13,280
and then people started to to look at it

969
00:35:13,280 --> 00:35:14,800
again

970
00:35:14,800 --> 00:35:16,480
there were some

971
00:35:16,480 --> 00:35:19,040
results about mean rank attacks so these

972
00:35:19,040 --> 00:35:20,880
are attacks that reduce a key recovery

973
00:35:20,880 --> 00:35:23,520
on uh rainbow to the min rank problem

974
00:35:23,520 --> 00:35:25,520
which is where you're given

975
00:35:25,520 --> 00:35:27,280
some matrices and the problem is to find

976
00:35:27,280 --> 00:35:28,960
a linear combination of them with with

977
00:35:28,960 --> 00:35:30,960
low rank and there's been some some

978
00:35:30,960 --> 00:35:33,040
improvements in solving this problem

979
00:35:33,040 --> 00:35:35,599
actually uh one of the talks tomorrow is

980
00:35:35,599 --> 00:35:38,720
about uh this this line of work

981
00:35:38,720 --> 00:35:39,920
um

982
00:35:39,920 --> 00:35:43,200
and so so yeah but this is more of uh

983
00:35:43,200 --> 00:35:44,720
yeah the

984
00:35:44,720 --> 00:35:46,240
it's not really a new attack it's just

985
00:35:46,240 --> 00:35:48,160
like the the existing reduction to mean

986
00:35:48,160 --> 00:35:50,240
rank uh got

987
00:35:50,240 --> 00:35:53,040
got more uh efficient as an attack also

988
00:35:53,040 --> 00:35:55,280
there was some new analysis of the

989
00:35:55,280 --> 00:35:58,480
rainbow band separation attack

990
00:35:58,480 --> 00:36:00,320
that showed that the attack was slightly

991
00:36:00,320 --> 00:36:03,359
more powerful than we thought before

992
00:36:03,359 --> 00:36:04,400
um

993
00:36:04,400 --> 00:36:07,200
but yeah all in all there were no really

994
00:36:07,200 --> 00:36:08,560
new

995
00:36:08,560 --> 00:36:10,240
attacks on rainbow

996
00:36:10,240 --> 00:36:11,200
uh

997
00:36:11,200 --> 00:36:12,480
until uh

998
00:36:12,480 --> 00:36:13,920
the third round so it was selected as

999
00:36:13,920 --> 00:36:16,560
one of the finalists but then uh things

1000
00:36:16,560 --> 00:36:18,720
started to go wrong

1001
00:36:18,720 --> 00:36:20,480
so um

1002
00:36:20,480 --> 00:36:22,160
i had a paper at eurocrypt last year

1003
00:36:22,160 --> 00:36:24,240
where i gave like a different

1004
00:36:24,240 --> 00:36:26,960
description of of rainbow so the the

1005
00:36:26,960 --> 00:36:28,640
schemes are completely equivalent it's

1006
00:36:28,640 --> 00:36:31,200
just some different way of looking at it

1007
00:36:31,200 --> 00:36:32,079
which

1008
00:36:32,079 --> 00:36:32,880
is

1009
00:36:32,880 --> 00:36:34,880
yeah it avoids coordinates and changes

1010
00:36:34,880 --> 00:36:36,720
of variables so it's more elegant

1011
00:36:36,720 --> 00:36:38,720
mathematically and it allows you to see

1012
00:36:38,720 --> 00:36:41,280
what's really going on and this allowed

1013
00:36:41,280 --> 00:36:44,000
me to find some some new attacks

1014
00:36:44,000 --> 00:36:46,560
and uh yeah those attacks only reduce

1015
00:36:46,560 --> 00:36:48,720
the security level by 20

1016
00:36:48,720 --> 00:36:50,560
bits of security

1017
00:36:50,560 --> 00:36:53,040
which uh the the rainbow team claimed it

1018
00:36:53,040 --> 00:36:55,119
was they they claimed to have enough

1019
00:36:55,119 --> 00:36:58,000
margin to still meet their their goals

1020
00:36:58,000 --> 00:37:00,320
uh but then in this work i found a much

1021
00:37:00,320 --> 00:37:01,440
more

1022
00:37:01,440 --> 00:37:03,119
efficient attack that can actually break

1023
00:37:03,119 --> 00:37:05,599
the security level one parameters

1024
00:37:05,599 --> 00:37:07,599
in practice

1025
00:37:07,599 --> 00:37:11,040
uh yeah so yeah this is a table with uh

1026
00:37:11,040 --> 00:37:13,359
the estimated bit costs of the of the

1027
00:37:13,359 --> 00:37:14,560
attack

1028
00:37:14,560 --> 00:37:17,119
so as you can see the security level one

1029
00:37:17,119 --> 00:37:19,680
parameters for the second round uh the

1030
00:37:19,680 --> 00:37:20,720
the

1031
00:37:20,720 --> 00:37:21,680
number of

1032
00:37:21,680 --> 00:37:24,400
gates to do the attack is roughly two to

1033
00:37:24,400 --> 00:37:27,839
61 which translates to to one weekend on

1034
00:37:27,839 --> 00:37:29,920
the laptop which is where the the title

1035
00:37:29,920 --> 00:37:32,240
of the paper comes from right but for

1036
00:37:32,240 --> 00:37:34,240
the for the higher security levels

1037
00:37:34,240 --> 00:37:37,359
um yeah the the the cost is still quite

1038
00:37:37,359 --> 00:37:39,440
big so for example two to the

1039
00:37:39,440 --> 00:37:40,680
uh

1040
00:37:40,680 --> 00:37:43,520
131 first security level one from

1041
00:37:43,520 --> 00:37:45,760
security level three of the second round

1042
00:37:45,760 --> 00:37:48,400
uh which is still out of reach of

1043
00:37:48,400 --> 00:37:52,480
laptops and other computers that we have

1044
00:37:52,480 --> 00:37:54,079
okay so uh yeah that was the

1045
00:37:54,079 --> 00:37:56,000
introduction so i'm first going to talk

1046
00:37:56,000 --> 00:37:58,240
about this oil and vinegar scheme uh a

1047
00:37:58,240 --> 00:38:00,000
little bit more because you can't really

1048
00:38:00,000 --> 00:38:02,480
understand rainbow but without knowing

1049
00:38:02,480 --> 00:38:04,560
how the vinegar works then i'll talk

1050
00:38:04,560 --> 00:38:06,640
about rainbow then the attacks and and

1051
00:38:06,640 --> 00:38:08,079
then i'll end

1052
00:38:08,079 --> 00:38:11,119
so um i mentioned it's a multivariate

1053
00:38:11,119 --> 00:38:12,560
crypto system

1054
00:38:12,560 --> 00:38:14,480
um it's based on a multiplayer trap door

1055
00:38:14,480 --> 00:38:16,400
so what's that that's

1056
00:38:16,400 --> 00:38:17,359
yeah just

1057
00:38:17,359 --> 00:38:19,440
a trapdoor function that is

1058
00:38:19,440 --> 00:38:21,760
uh a multivariate quadratic function so

1059
00:38:21,760 --> 00:38:24,400
it's just a bunch of uh quadratic

1060
00:38:24,400 --> 00:38:27,119
polynomials in some variables like like

1061
00:38:27,119 --> 00:38:29,359
this this example is

1062
00:38:29,359 --> 00:38:31,280
a map in three variables with three

1063
00:38:31,280 --> 00:38:34,079
components and

1064
00:38:34,079 --> 00:38:35,760
this is what our trapdoor function is

1065
00:38:35,760 --> 00:38:37,040
gonna look like

1066
00:38:37,040 --> 00:38:39,599
so you can evaluate this function very

1067
00:38:39,599 --> 00:38:42,000
easily you just plug in your values and

1068
00:38:42,000 --> 00:38:43,920
evaluate the function

1069
00:38:43,920 --> 00:38:45,920
and the idea is that this map looks

1070
00:38:45,920 --> 00:38:48,800
random and for random maps

1071
00:38:48,800 --> 00:38:51,040
we believe that finding pre-images is

1072
00:38:51,040 --> 00:38:52,880
hard but actually there's some some

1073
00:38:52,880 --> 00:38:54,400
hidden structure and if you know the

1074
00:38:54,400 --> 00:38:56,400
structure then you can sample pre-images

1075
00:38:56,400 --> 00:38:58,839
for these maps

1076
00:38:58,839 --> 00:39:01,280
efficiently uh and then yeah once you

1077
00:39:01,280 --> 00:39:02,800
have such trapdoors you can just build

1078
00:39:02,800 --> 00:39:05,359
signatures exactly like how rsa

1079
00:39:05,359 --> 00:39:07,520
signatures work so your public key is

1080
00:39:07,520 --> 00:39:09,599
your trader function your secret key is

1081
00:39:09,599 --> 00:39:12,400
this trapdoor information and to sign a

1082
00:39:12,400 --> 00:39:14,480
message you just hash to to your output

1083
00:39:14,480 --> 00:39:15,440
space

1084
00:39:15,440 --> 00:39:17,119
uh and then you

1085
00:39:17,119 --> 00:39:19,040
your signature is a pretty much for this

1086
00:39:19,040 --> 00:39:21,920
uh this hash right so anyone can verify

1087
00:39:21,920 --> 00:39:23,280
if your signature is correct but in

1088
00:39:23,280 --> 00:39:25,280
order to produce a signature you need to

1089
00:39:25,280 --> 00:39:27,839
know this this trapdoor information

1090
00:39:27,839 --> 00:39:30,160
right so this is just exactly how rsa

1091
00:39:30,160 --> 00:39:31,920
signatures work

1092
00:39:31,920 --> 00:39:33,359
but the question is how do we produce

1093
00:39:33,359 --> 00:39:37,520
these these trap door multivariate maps

1094
00:39:37,520 --> 00:39:39,119
and yeah this is

1095
00:39:39,119 --> 00:39:41,040
there's multiple proposals but

1096
00:39:41,040 --> 00:39:43,680
the simplest one is this oil and vinegar

1097
00:39:43,680 --> 00:39:45,839
trap door

1098
00:39:45,839 --> 00:39:48,400
so um the type of structure is very

1099
00:39:48,400 --> 00:39:52,079
simple so it's just a linear subspace o

1100
00:39:52,079 --> 00:39:54,960
and your trapdoor function is just a

1101
00:39:54,960 --> 00:39:56,800
bunch of quadratic polynomials that

1102
00:39:56,800 --> 00:39:59,440
vanish on this space oh right so for

1103
00:39:59,440 --> 00:40:00,960
every vector

1104
00:40:00,960 --> 00:40:03,440
in in our space o p of o is going to be

1105
00:40:03,440 --> 00:40:04,400
zero

1106
00:40:04,400 --> 00:40:07,119
so so that's it so there's no extra

1107
00:40:07,119 --> 00:40:10,160
information to generate such a trapdoor

1108
00:40:10,160 --> 00:40:12,240
function you just first pick your space

1109
00:40:12,240 --> 00:40:14,560
all uniformly firmly at random

1110
00:40:14,560 --> 00:40:16,720
and then you pick your polynomials

1111
00:40:16,720 --> 00:40:18,160
uniformly at random such that they

1112
00:40:18,160 --> 00:40:20,240
vanish on all right so this you can

1113
00:40:20,240 --> 00:40:22,640
which you can do

1114
00:40:22,640 --> 00:40:24,240
so the question is how do you use this

1115
00:40:24,240 --> 00:40:26,400
trapdoor information to actually sample

1116
00:40:26,400 --> 00:40:28,400
uh premature pre-images

1117
00:40:28,400 --> 00:40:30,720
um and before i explain that i need to

1118
00:40:30,720 --> 00:40:33,599
uh introduce this this definition

1119
00:40:33,599 --> 00:40:34,640
so

1120
00:40:34,640 --> 00:40:36,880
if you have our multiplied map p we can

1121
00:40:36,880 --> 00:40:40,000
def define uh differential at some point

1122
00:40:40,000 --> 00:40:40,880
x

1123
00:40:40,880 --> 00:40:42,800
uh i call your d of x and it's just

1124
00:40:42,800 --> 00:40:43,920
defined as

1125
00:40:43,920 --> 00:40:46,400
p of uh

1126
00:40:46,400 --> 00:40:48,640
yeah

1127
00:40:48,880 --> 00:40:51,359
sorry that is p of x plus y minus p of x

1128
00:40:51,359 --> 00:40:52,640
minus p of y

1129
00:40:52,640 --> 00:40:54,560
and yeah you can you can verify very

1130
00:40:54,560 --> 00:40:56,480
easily that this uh this is a linear

1131
00:40:56,480 --> 00:40:59,599
function it's also a linear in the point

1132
00:40:59,599 --> 00:41:00,880
x

1133
00:41:00,880 --> 00:41:04,240
and this is going to be useful uh

1134
00:41:04,240 --> 00:41:05,839
to understand how oil vinegar works but

1135
00:41:05,839 --> 00:41:08,079
also for the attacks

1136
00:41:08,079 --> 00:41:10,800
right so now with this differential how

1137
00:41:10,800 --> 00:41:11,839
does the

1138
00:41:11,839 --> 00:41:14,240
how do you use the the trap door

1139
00:41:14,240 --> 00:41:17,040
so we're given our drive door space o

1140
00:41:17,040 --> 00:41:19,520
and some some output value y and we want

1141
00:41:19,520 --> 00:41:22,000
to find an x so that p of x is equal to

1142
00:41:22,000 --> 00:41:24,720
y the idea is very simple you just first

1143
00:41:24,720 --> 00:41:27,920
pick some uniformly random input v

1144
00:41:27,920 --> 00:41:29,119
p is not going to be a solution of

1145
00:41:29,119 --> 00:41:31,440
course but you can solve for some

1146
00:41:31,440 --> 00:41:34,960
correction term in o so p of v plus o is

1147
00:41:34,960 --> 00:41:37,520
going to be whatever you want it to be

1148
00:41:37,520 --> 00:41:40,640
and it turns out that doing this is just

1149
00:41:40,640 --> 00:41:42,800
a system of linear equations right

1150
00:41:42,800 --> 00:41:44,400
because um

1151
00:41:44,400 --> 00:41:46,720
with our definition of the differential

1152
00:41:46,720 --> 00:41:49,920
we can write p of v plus o as p of v

1153
00:41:49,920 --> 00:41:51,359
plus p of o

1154
00:41:51,359 --> 00:41:53,359
uh plus this differential right if we go

1155
00:41:53,359 --> 00:41:55,520
back to look at the different of this

1156
00:41:55,520 --> 00:41:57,599
definition you just move the p of x and

1157
00:41:57,599 --> 00:41:59,760
p of y to the other side

1158
00:41:59,760 --> 00:42:00,640
and

1159
00:42:00,640 --> 00:42:01,599
now

1160
00:42:01,599 --> 00:42:03,680
the trick is because p vanishes on o we

1161
00:42:03,680 --> 00:42:06,000
can ignore this this middle term and our

1162
00:42:06,000 --> 00:42:07,839
remains is just p of v which is some

1163
00:42:07,839 --> 00:42:09,680
some constant and then some linear

1164
00:42:09,680 --> 00:42:12,000
function of of your o

1165
00:42:12,000 --> 00:42:14,480
right so this is just a linear system of

1166
00:42:14,480 --> 00:42:17,040
uh m equations right because our p has m

1167
00:42:17,040 --> 00:42:19,200
components and we have m degrees of

1168
00:42:19,200 --> 00:42:22,560
freedom namely o can be in this space o

1169
00:42:22,560 --> 00:42:24,319
which has dimension m

1170
00:42:24,319 --> 00:42:26,240
so with large probability this will have

1171
00:42:26,240 --> 00:42:28,079
a solution and then you just

1172
00:42:28,079 --> 00:42:29,599
output as a signature or as your

1173
00:42:29,599 --> 00:42:31,200
pre-image p

1174
00:42:31,200 --> 00:42:34,000
you output v possible right and it can

1175
00:42:34,000 --> 00:42:36,000
happen that your system does not have a

1176
00:42:36,000 --> 00:42:38,079
solution but then you just try again

1177
00:42:38,079 --> 00:42:40,079
uh with a different

1178
00:42:40,079 --> 00:42:42,720
different tree right so this is how oil

1179
00:42:42,720 --> 00:42:44,800
and vinegar works it's i believe a very

1180
00:42:44,800 --> 00:42:45,839
elegant

1181
00:42:45,839 --> 00:42:47,599
scheme that it's

1182
00:42:47,599 --> 00:42:48,960
just

1183
00:42:48,960 --> 00:42:50,960
the only structure is this this subspace

1184
00:42:50,960 --> 00:42:52,880
on which p vanishes

1185
00:42:52,880 --> 00:42:53,920
um

1186
00:42:53,920 --> 00:42:57,119
so yeah that's that's quite nice

1187
00:42:57,119 --> 00:43:00,000
and now how how does rainbow work so

1188
00:43:00,000 --> 00:43:02,319
it's a bit more complicated instead of

1189
00:43:02,319 --> 00:43:05,280
one uh space all we now have two spaces

1190
00:43:05,280 --> 00:43:08,000
so one and o2 and they sit inside inside

1191
00:43:08,000 --> 00:43:10,800
of each other and there's also a space w

1192
00:43:10,800 --> 00:43:13,119
in our output space

1193
00:43:13,119 --> 00:43:14,319
and

1194
00:43:14,319 --> 00:43:17,520
the map p now behaves nicely on these

1195
00:43:17,520 --> 00:43:20,800
subspaces so there's three properties

1196
00:43:20,800 --> 00:43:22,640
namely its sense

1197
00:43:22,640 --> 00:43:24,720
o1 2w

1198
00:43:24,720 --> 00:43:26,480
it vanishes on r2

1199
00:43:26,480 --> 00:43:27,839
and then there's another property

1200
00:43:27,839 --> 00:43:30,000
involving this differential

1201
00:43:30,000 --> 00:43:32,960
uh namely for every point x we want that

1202
00:43:32,960 --> 00:43:37,359
uh the differential at x sends o2 to w

1203
00:43:37,359 --> 00:43:40,400
right this might seem a bit um

1204
00:43:40,400 --> 00:43:42,240
random for now but

1205
00:43:42,240 --> 00:43:44,480
this is what you need to

1206
00:43:44,480 --> 00:43:47,040
to sample pre-images i'm not going to

1207
00:43:47,040 --> 00:43:48,800
explain in detail how it works but

1208
00:43:48,800 --> 00:43:50,319
basically

1209
00:43:50,319 --> 00:43:52,319
you use the oil and vinegar id

1210
00:43:52,319 --> 00:43:54,079
first to sample the image that is

1211
00:43:54,079 --> 00:43:56,480
correct up to a vector in w

1212
00:43:56,480 --> 00:43:59,040
and then you use a oil vinegar id again

1213
00:43:59,040 --> 00:44:00,240
with o2

1214
00:44:00,240 --> 00:44:03,440
to to get a pre image that is correct uh

1215
00:44:03,440 --> 00:44:05,440
exactly

1216
00:44:05,440 --> 00:44:08,160
yeah but that's not too important for us

1217
00:44:08,160 --> 00:44:10,079
right now

1218
00:44:10,079 --> 00:44:11,520
so yeah now

1219
00:44:11,520 --> 00:44:14,079
talk about the attacks

1220
00:44:14,079 --> 00:44:15,359
um so

1221
00:44:15,359 --> 00:44:17,599
yeah we're going to use this uh this

1222
00:44:17,599 --> 00:44:20,079
property that i mentioned before about

1223
00:44:20,079 --> 00:44:21,520
the differential

1224
00:44:21,520 --> 00:44:24,160
so i'll repeat so for every

1225
00:44:24,160 --> 00:44:26,160
vector x if you look at the differential

1226
00:44:26,160 --> 00:44:27,680
at x

1227
00:44:27,680 --> 00:44:30,640
this is a linear map that sends our o2

1228
00:44:30,640 --> 00:44:33,200
space which is one of our spaces in the

1229
00:44:33,200 --> 00:44:36,160
secret key to to w which is another

1230
00:44:36,160 --> 00:44:37,680
space in the

1231
00:44:37,680 --> 00:44:39,119
in a secret key

1232
00:44:39,119 --> 00:44:40,960
so yeah we have a lot of these maps

1233
00:44:40,960 --> 00:44:44,240
which for every x we have a linear map

1234
00:44:44,240 --> 00:44:47,520
that behaves uh on these two subspaces

1235
00:44:47,520 --> 00:44:50,079
and our goal as an attacker is to find

1236
00:44:50,079 --> 00:44:53,119
uh mr find o2

1237
00:44:53,119 --> 00:44:54,079
um

1238
00:44:54,079 --> 00:44:56,960
so the the way i solved this problem in

1239
00:44:56,960 --> 00:44:59,920
my europe paper was to reduce this to to

1240
00:44:59,920 --> 00:45:02,720
a min rank problem uh but actually um

1241
00:45:02,720 --> 00:45:06,079
there's a there's a much easier way

1242
00:45:06,079 --> 00:45:08,560
to to use these differentials

1243
00:45:08,560 --> 00:45:10,720
and that is the observation is that

1244
00:45:10,720 --> 00:45:12,400
these differential are much more likely

1245
00:45:12,400 --> 00:45:14,079
to have kernel vectors

1246
00:45:14,079 --> 00:45:16,839
in uh o2

1247
00:45:16,839 --> 00:45:20,720
so why is that you can just compute the

1248
00:45:20,720 --> 00:45:22,480
the average number of

1249
00:45:22,480 --> 00:45:24,800
nonzero kernel vectors in o2 of these

1250
00:45:24,800 --> 00:45:27,520
differentials and it's uh this quantity

1251
00:45:27,520 --> 00:45:28,800
over there so

1252
00:45:28,800 --> 00:45:31,280
uh size of o2 minus one over the size of

1253
00:45:31,280 --> 00:45:33,839
w so

1254
00:45:33,839 --> 00:45:36,319
why is this this there's a 2 minus 1

1255
00:45:36,319 --> 00:45:38,640
non-zero vectors in o2 and each of them

1256
00:45:38,640 --> 00:45:40,079
has a probability

1257
00:45:40,079 --> 00:45:43,119
of 1 over the size of w of being in the

1258
00:45:43,119 --> 00:45:44,480
kernel right because

1259
00:45:44,480 --> 00:45:46,079
it's image under the differential is

1260
00:45:46,079 --> 00:45:49,280
just a unifor uniformly random vector in

1261
00:45:49,280 --> 00:45:50,560
in w

1262
00:45:50,560 --> 00:45:52,160
so with probability one over the size of

1263
00:45:52,160 --> 00:45:56,160
w will be will be zero right and um

1264
00:45:56,160 --> 00:45:59,040
the the dimension of o2 and w are the

1265
00:45:59,040 --> 00:46:01,280
same so this this uh

1266
00:46:01,280 --> 00:46:03,200
average number of uh

1267
00:46:03,200 --> 00:46:05,760
of nonzero kernel vectors is going to be

1268
00:46:05,760 --> 00:46:08,480
very very close to two one

1269
00:46:08,480 --> 00:46:10,640
and now this is useful to us because we

1270
00:46:10,640 --> 00:46:13,760
want to find these vectors in o2

1271
00:46:13,760 --> 00:46:14,800
that

1272
00:46:14,800 --> 00:46:16,640
now a good way a good place to look for

1273
00:46:16,640 --> 00:46:18,400
them is in the kernels of these these

1274
00:46:18,400 --> 00:46:20,079
differentials

1275
00:46:20,079 --> 00:46:21,040
um

1276
00:46:21,040 --> 00:46:22,720
so yeah i said the average number of

1277
00:46:22,720 --> 00:46:24,720
those vectors is one

1278
00:46:24,720 --> 00:46:26,880
but they come in clusters of size q

1279
00:46:26,880 --> 00:46:28,480
minus one because every time you have

1280
00:46:28,480 --> 00:46:30,079
one kernel vectors then all the

1281
00:46:30,079 --> 00:46:33,040
multiples will also be in the kernel

1282
00:46:33,040 --> 00:46:36,079
so heuristically the the probability of

1283
00:46:36,079 --> 00:46:37,760
getting

1284
00:46:37,760 --> 00:46:39,599
a nonzero vector in this in the kernel

1285
00:46:39,599 --> 00:46:40,960
of the differential

1286
00:46:40,960 --> 00:46:41,760
is

1287
00:46:41,760 --> 00:46:44,000
close to 1 over q minus 1.

1288
00:46:44,000 --> 00:46:46,079
you can have a precise formula but it

1289
00:46:46,079 --> 00:46:47,520
doesn't really matter it's

1290
00:46:47,520 --> 00:46:50,560
close close to this

1291
00:46:50,560 --> 00:46:52,400
so yeah with this observation the attack

1292
00:46:52,400 --> 00:46:53,599
is

1293
00:46:53,599 --> 00:46:55,440
quite straightforward

1294
00:46:55,440 --> 00:46:57,359
so what we're going to do is we just

1295
00:46:57,359 --> 00:47:00,319
guess a random x and then we hope that

1296
00:47:00,319 --> 00:47:02,319
the kernel of our differential

1297
00:47:02,319 --> 00:47:04,400
intersects with our space o2 that we

1298
00:47:04,400 --> 00:47:05,599
want to

1299
00:47:05,599 --> 00:47:06,720
find

1300
00:47:06,720 --> 00:47:09,440
and then that we try to find a vector in

1301
00:47:09,440 --> 00:47:11,839
this intersection if it exists just by

1302
00:47:11,839 --> 00:47:15,040
solving uh this this system so we're

1303
00:47:15,040 --> 00:47:17,520
looking for an o such that d of x sub o

1304
00:47:17,520 --> 00:47:19,839
is equal to zero mainly it's

1305
00:47:19,839 --> 00:47:22,720
the o sits in the in the kernel

1306
00:47:22,720 --> 00:47:25,280
and secondly we want that p of o is

1307
00:47:25,280 --> 00:47:26,720
equal to zero

1308
00:47:26,720 --> 00:47:30,400
uh just because uh p vanishes on on o2

1309
00:47:30,400 --> 00:47:31,280
so that

1310
00:47:31,280 --> 00:47:33,200
that's how we um

1311
00:47:33,200 --> 00:47:35,359
can look for for the o2

1312
00:47:35,359 --> 00:47:36,400
and

1313
00:47:36,400 --> 00:47:39,280
yeah so this is uh nice because the

1314
00:47:39,280 --> 00:47:42,319
first equations that d of x is equal to

1315
00:47:42,319 --> 00:47:44,000
zero those are just linear equations

1316
00:47:44,000 --> 00:47:45,680
right so you can use those linear

1317
00:47:45,680 --> 00:47:48,240
equations to eliminate variables from

1318
00:47:48,240 --> 00:47:50,240
the from the quadratic

1319
00:47:50,240 --> 00:47:52,720
equations p of o is equal to zero

1320
00:47:52,720 --> 00:47:54,960
and this makes the system much smaller

1321
00:47:54,960 --> 00:47:56,000
and

1322
00:47:56,000 --> 00:47:59,040
easier to to solve so you can just use

1323
00:47:59,040 --> 00:48:02,160
existing techniques to to solve uh these

1324
00:48:02,160 --> 00:48:03,599
systems

1325
00:48:03,599 --> 00:48:04,319
and

1326
00:48:04,319 --> 00:48:06,880
uh yeah if you use some implementation

1327
00:48:06,880 --> 00:48:09,440
of the we demon excel algorithm

1328
00:48:09,440 --> 00:48:11,280
then it takes only three hours and a

1329
00:48:11,280 --> 00:48:14,960
half for each uh attempt of solving uh

1330
00:48:14,960 --> 00:48:16,319
these systems

1331
00:48:16,319 --> 00:48:18,319
and on average you need to repeat q

1332
00:48:18,319 --> 00:48:21,119
minus one times and q is equal to 16. so

1333
00:48:21,119 --> 00:48:23,920
we need to repeat 15 times which gives

1334
00:48:23,920 --> 00:48:26,640
an expected runtime of

1335
00:48:26,640 --> 00:48:29,920
53 hours or roughly one weekend if you

1336
00:48:29,920 --> 00:48:31,119
if you

1337
00:48:31,119 --> 00:48:32,559
count friday evenings that's part of the

1338
00:48:32,559 --> 00:48:35,520
weekend then it's this one weekend

1339
00:48:35,520 --> 00:48:37,200
um

1340
00:48:37,200 --> 00:48:40,960
so this is how you find one vector in o2

1341
00:48:40,960 --> 00:48:42,400
and it turns out that once you know one

1342
00:48:42,400 --> 00:48:44,240
vector in o2 then you can recover all

1343
00:48:44,240 --> 00:48:45,359
the

1344
00:48:45,359 --> 00:48:46,400
all the

1345
00:48:46,400 --> 00:48:48,480
other secret key information uh very

1346
00:48:48,480 --> 00:48:49,760
efficiently

1347
00:48:49,760 --> 00:48:52,640
um so yeah how does this work

1348
00:48:52,640 --> 00:48:54,160
um

1349
00:48:54,160 --> 00:48:56,160
now first we have this property of the

1350
00:48:56,160 --> 00:48:58,240
differential so for every x

1351
00:48:58,240 --> 00:49:01,280
we know that d of x support will be in w

1352
00:49:01,280 --> 00:49:04,000
so since we know already a vector in o2

1353
00:49:04,000 --> 00:49:06,480
this gives us many vectors in w so this

1354
00:49:06,480 --> 00:49:10,400
immediately gives you all of w for free

1355
00:49:10,400 --> 00:49:13,119
then once you know w you can just solve

1356
00:49:13,119 --> 00:49:14,319
for all the

1357
00:49:14,319 --> 00:49:19,119
all the vectors uh in o2 that map into w

1358
00:49:19,119 --> 00:49:21,200
uh under these these differentials and

1359
00:49:21,200 --> 00:49:22,640
then you just solve a linear system of

1360
00:49:22,640 --> 00:49:24,000
equations to find

1361
00:49:24,000 --> 00:49:27,040
uh a basis for for o2

1362
00:49:27,040 --> 00:49:28,960
so the only thing we still have to find

1363
00:49:28,960 --> 00:49:31,359
is a one

1364
00:49:31,359 --> 00:49:33,440
and the way you do that is

1365
00:49:33,440 --> 00:49:35,680
you take a quotient by

1366
00:49:35,680 --> 00:49:38,800
o2 on the left hand side and by w on the

1367
00:49:38,800 --> 00:49:41,280
right hand side

1368
00:49:41,280 --> 00:49:43,599
and actually it takes a little

1369
00:49:43,599 --> 00:49:45,839
exercise to prove that this quotient is

1370
00:49:45,839 --> 00:49:48,240
uh well defined or at least that this uh

1371
00:49:48,240 --> 00:49:50,400
this your map p is still well defined on

1372
00:49:50,400 --> 00:49:52,559
the quotient but that's uh

1373
00:49:52,559 --> 00:49:54,000
that's true because

1374
00:49:54,000 --> 00:49:56,240
if you add um some vector in o2 to your

1375
00:49:56,240 --> 00:49:58,400
input your output will change by some

1376
00:49:58,400 --> 00:50:00,960
vector in w that's exactly

1377
00:50:00,960 --> 00:50:03,520
this condition on the differential so

1378
00:50:03,520 --> 00:50:05,440
that means that our quadratic map is

1379
00:50:05,440 --> 00:50:07,440
still well defined from these

1380
00:50:07,440 --> 00:50:09,119
portions

1381
00:50:09,119 --> 00:50:11,839
and then what's left is exactly the an

1382
00:50:11,839 --> 00:50:14,480
oil and vinegar public key like this

1383
00:50:14,480 --> 00:50:16,480
we have some some space and some

1384
00:50:16,480 --> 00:50:18,480
polynomials on them there's a space on

1385
00:50:18,480 --> 00:50:20,160
which they vanish and we want to find

1386
00:50:20,160 --> 00:50:21,920
this space we're going to find

1387
00:50:21,920 --> 00:50:25,760
the quotient of one by o2 so we can just

1388
00:50:25,760 --> 00:50:27,839
use existing attacks on the oil and

1389
00:50:27,839 --> 00:50:29,200
vinegar scheme

1390
00:50:29,200 --> 00:50:31,040
and we can do this because now this is a

1391
00:50:31,040 --> 00:50:34,079
very small oil and vinegar uh public key

1392
00:50:34,079 --> 00:50:36,640
because we quotient it out by two by two

1393
00:50:36,640 --> 00:50:38,319
large spaces

1394
00:50:38,319 --> 00:50:40,079
so yeah you can just use off-the-shelf

1395
00:50:40,079 --> 00:50:42,880
attacks against the oil and vinegar to

1396
00:50:42,880 --> 00:50:46,000
to find uh a one and then you're done

1397
00:50:46,000 --> 00:50:47,440
right then we

1398
00:50:47,440 --> 00:50:52,000
know uh the entire secret key

1399
00:50:52,000 --> 00:50:55,359
uh okay so that's that's it so

1400
00:50:55,359 --> 00:50:57,599
um conclusions are rainbow is not secure

1401
00:50:57,599 --> 00:50:59,760
at least uh the security level one

1402
00:50:59,760 --> 00:51:03,040
parameters you can break in practice

1403
00:51:03,040 --> 00:51:05,680
um it is possible to save the scheme by

1404
00:51:05,680 --> 00:51:08,240
moving to to larger parameters but that

1405
00:51:08,240 --> 00:51:10,240
would be quite expensive like the public

1406
00:51:10,240 --> 00:51:11,440
key would be

1407
00:51:11,440 --> 00:51:14,000
4.4 times larger the secret the

1408
00:51:14,000 --> 00:51:17,119
signatures would be 2.5 times larger and

1409
00:51:17,119 --> 00:51:19,599
the scheme would be five times slower

1410
00:51:19,599 --> 00:51:21,760
and it doesn't really make sense to do

1411
00:51:21,760 --> 00:51:25,760
this because rainbow was like um a more

1412
00:51:25,760 --> 00:51:28,000
complicated version of oil and vinegar

1413
00:51:28,000 --> 00:51:29,839
that was trying to be more efficient but

1414
00:51:29,839 --> 00:51:31,680
now with these attacks it's you're no

1415
00:51:31,680 --> 00:51:32,880
longer more efficient than northern

1416
00:51:32,880 --> 00:51:34,880
vinegar so we should really just move

1417
00:51:34,880 --> 00:51:36,640
back to the oil of energy scheme which

1418
00:51:36,640 --> 00:51:39,280
is much more elegant and older and much

1419
00:51:39,280 --> 00:51:41,680
better understood

1420
00:51:41,680 --> 00:51:43,359
so so yeah in my view

1421
00:51:43,359 --> 00:51:46,160
rainbow is really dead we shouldn't

1422
00:51:46,160 --> 00:51:47,760
try to revive it and make it more

1423
00:51:47,760 --> 00:51:50,240
complicated to to save it again we

1424
00:51:50,240 --> 00:51:51,280
should just

1425
00:51:51,280 --> 00:51:53,040
move back to this very nice and elegant

1426
00:51:53,040 --> 00:51:54,720
oil and vinegar scheme

1427
00:51:54,720 --> 00:51:58,559
and try to understand that one better

1428
00:51:58,559 --> 00:52:03,319
so yeah that's it thank you

1429
00:52:09,680 --> 00:52:12,799
we have any questions

1430
00:52:14,880 --> 00:52:16,319
no questions

1431
00:52:16,319 --> 00:52:17,760
nobody wants to hear about the the

1432
00:52:17,760 --> 00:52:19,760
follow-up paper what breaking rainbow

1433
00:52:19,760 --> 00:52:21,599
takes an hour on a blackberry or

1434
00:52:21,599 --> 00:52:23,839
something

1435
00:52:24,319 --> 00:52:26,640
well as i mentioned i think we should

1436
00:52:26,640 --> 00:52:29,520
stop caring about rainbows so

1437
00:52:29,520 --> 00:52:31,440
if somebody wants to write that paper go

1438
00:52:31,440 --> 00:52:34,319
ahead but that's not going to be

1439
00:52:34,319 --> 00:52:36,079
right in that case let's thank ward

1440
00:52:36,079 --> 00:52:39,079
again

1441
00:54:19,200 --> 00:54:21,440
okay

1442
00:54:21,440 --> 00:54:24,559
so our our final paper of this

1443
00:54:24,559 --> 00:54:26,400
best paper session

1444
00:54:26,400 --> 00:54:29,760
is some easy instances of ideal svp and

1445
00:54:29,760 --> 00:54:32,319
implications on the partial van der man

1446
00:54:32,319 --> 00:54:34,319
knapsack problem

1447
00:54:34,319 --> 00:54:37,760
by uh katharine vogt tyrell khan and

1448
00:54:37,760 --> 00:54:38,880
alice

1449
00:54:38,880 --> 00:54:39,920
marie

1450
00:54:39,920 --> 00:54:43,280
and catherine will give the talk

1451
00:54:43,280 --> 00:54:44,079
yes

1452
00:54:44,079 --> 00:54:46,720
okay thank you for the introduction and

1453
00:54:46,720 --> 00:54:48,799
i'm very honored to receive this award

1454
00:54:48,799 --> 00:54:51,359
together with my co-authors as already

1455
00:54:51,359 --> 00:54:53,680
said gashon analis pelimari both from

1456
00:54:53,680 --> 00:54:55,920
the university of bordeaux

1457
00:54:55,920 --> 00:54:59,119
and so i got in inspired by my own

1458
00:54:59,119 --> 00:55:01,200
little teaser video that i made for the

1459
00:55:01,200 --> 00:55:03,760
conference and i will try to give the

1460
00:55:03,760 --> 00:55:05,280
context and the summary of the

1461
00:55:05,280 --> 00:55:09,680
contributions in form of an analogy

1462
00:55:09,680 --> 00:55:12,480
so using a mathematical problem

1463
00:55:12,480 --> 00:55:14,000
for as a hardness assumption in

1464
00:55:14,000 --> 00:55:15,599
cryptography is a little bit like

1465
00:55:15,599 --> 00:55:18,480
walking on a frozen lake and hoping that

1466
00:55:18,480 --> 00:55:21,040
the ice is thick enough

1467
00:55:21,040 --> 00:55:23,200
and using the yeah and so the shortest

1468
00:55:23,200 --> 00:55:26,319
vector problem is a mathematical problem

1469
00:55:26,319 --> 00:55:28,880
on euclidean lattices and we are pretty

1470
00:55:28,880 --> 00:55:31,200
much yeah we are quite confident that

1471
00:55:31,200 --> 00:55:33,440
the ice is quite thick here

1472
00:55:33,440 --> 00:55:35,200
however if you would

1473
00:55:35,200 --> 00:55:37,440
restrict a problem to so-called ideal

1474
00:55:37,440 --> 00:55:39,760
lattices then past

1475
00:55:39,760 --> 00:55:41,760
works have already shown that there are

1476
00:55:41,760 --> 00:55:44,799
the ice has places where it's not thick

1477
00:55:44,799 --> 00:55:46,960
but actually you have puddles

1478
00:55:46,960 --> 00:55:49,599
and whereas the two puddles on the left

1479
00:55:49,599 --> 00:55:51,440
and the bottom are very

1480
00:55:51,440 --> 00:55:52,960
well

1481
00:55:52,960 --> 00:55:55,599
signed and you know how to verify if an

1482
00:55:55,599 --> 00:55:58,079
instance falls into the puddle or not

1483
00:55:58,079 --> 00:56:00,480
the situation is a bit less clear with

1484
00:56:00,480 --> 00:56:03,040
the puddle on the top right

1485
00:56:03,040 --> 00:56:05,440
and this deals with ideas that have

1486
00:56:05,440 --> 00:56:07,359
additional symmetries

1487
00:56:07,359 --> 00:56:09,760
and so the picture of our first

1488
00:56:09,760 --> 00:56:12,079
contribution is that we enlarge the

1489
00:56:12,079 --> 00:56:14,559
puddle so we make it a little bit bigger

1490
00:56:14,559 --> 00:56:17,280
but i think more importantly we put a

1491
00:56:17,280 --> 00:56:19,680
big warning sign around the puddle so

1492
00:56:19,680 --> 00:56:21,760
that now you can easily verify if a

1493
00:56:21,760 --> 00:56:25,440
given instance falls in it or not

1494
00:56:25,440 --> 00:56:27,200
and so now you can walk safely on the

1495
00:56:27,200 --> 00:56:29,040
frozen lake again

1496
00:56:29,040 --> 00:56:31,440
and the second part of our paper deals

1497
00:56:31,440 --> 00:56:32,960
with the so-called partial volume or

1498
00:56:32,960 --> 00:56:35,119
knapsack problem and without telling you

1499
00:56:35,119 --> 00:56:37,760
know what it is

1500
00:56:37,760 --> 00:56:39,760
exactly you just believe me that it

1501
00:56:39,760 --> 00:56:42,480
defines an ideological problem and we

1502
00:56:42,480 --> 00:56:44,799
have to put this knapsack somewhere on

1503
00:56:44,799 --> 00:56:45,920
the lake

1504
00:56:45,920 --> 00:56:48,640
and depending on what instance you have

1505
00:56:48,640 --> 00:56:50,559
it might be on different places on the

1506
00:56:50,559 --> 00:56:52,960
lake and now comes the second part of

1507
00:56:52,960 --> 00:56:55,760
our like the result is that we show that

1508
00:56:55,760 --> 00:56:57,359
there are specific instances of the

1509
00:56:57,359 --> 00:56:59,440
partial vulnerable knapsack problem such

1510
00:56:59,440 --> 00:57:01,040
that the knapsack

1511
00:57:01,040 --> 00:57:04,160
exactly falls into this larger puddle

1512
00:57:04,160 --> 00:57:05,920
that we've shown and we not only show

1513
00:57:05,920 --> 00:57:07,440
this theoretically but we actually

1514
00:57:07,440 --> 00:57:09,760
implement the algorithm and

1515
00:57:09,760 --> 00:57:11,440
run

1516
00:57:11,440 --> 00:57:13,520
experiments on it

1517
00:57:13,520 --> 00:57:15,839
and so with this image in

1518
00:57:15,839 --> 00:57:16,720
mind

1519
00:57:16,720 --> 00:57:19,359
i will try to lead you through this

1520
00:57:19,359 --> 00:57:21,680
mathematical result so i will first

1521
00:57:21,680 --> 00:57:23,760
explain what exactly are those easy

1522
00:57:23,760 --> 00:57:25,040
instances

1523
00:57:25,040 --> 00:57:27,280
then i will show how we can apply this

1524
00:57:27,280 --> 00:57:29,119
to the partial underneath problem and

1525
00:57:29,119 --> 00:57:31,839
then i will conclude where i clarify a

1526
00:57:31,839 --> 00:57:33,280
little bit the implications of this

1527
00:57:33,280 --> 00:57:36,880
result for lattice-based cryptography

1528
00:57:36,880 --> 00:57:39,359
okay so let's introduce the main

1529
00:57:39,359 --> 00:57:41,359
mathematical object of

1530
00:57:41,359 --> 00:57:43,040
this work

1531
00:57:43,040 --> 00:57:45,680
and euclidean ledges so an eulenian

1532
00:57:45,680 --> 00:57:48,160
lattice of rank n

1533
00:57:48,160 --> 00:57:50,559
is usually described by a basis and then

1534
00:57:50,559 --> 00:57:52,240
the lattice is composed of all the

1535
00:57:52,240 --> 00:57:54,160
linear integer combinations of those

1536
00:57:54,160 --> 00:57:56,400
basis vectors so i have a little picture

1537
00:57:56,400 --> 00:57:58,240
in dimension two you see all the blue

1538
00:57:58,240 --> 00:58:00,000
dots that's the lattice

1539
00:58:00,000 --> 00:58:02,160
and then we associate to a letter is a

1540
00:58:02,160 --> 00:58:04,640
minimum which is the shortest norm of

1541
00:58:04,640 --> 00:58:07,520
any of its non-zero vectors and i think

1542
00:58:07,520 --> 00:58:10,559
here you can see in orange those four

1543
00:58:10,559 --> 00:58:13,040
vectors are shortest vectors

1544
00:58:13,040 --> 00:58:15,040
and then the mathematical problem we are

1545
00:58:15,040 --> 00:58:17,280
looking at is the shortest vector

1546
00:58:17,280 --> 00:58:18,559
problem where we ask for an

1547
00:58:18,559 --> 00:58:21,359
approximation factor gamma to find a

1548
00:58:21,359 --> 00:58:23,920
vector such that the norm is at most a

1549
00:58:23,920 --> 00:58:26,319
gamma factor away from the minimum

1550
00:58:26,319 --> 00:58:29,359
so if we have for instance this violet

1551
00:58:29,359 --> 00:58:31,280
circle here then we have four more

1552
00:58:31,280 --> 00:58:34,079
points that now are short and would

1553
00:58:34,079 --> 00:58:36,160
allow would be a valid solution to this

1554
00:58:36,160 --> 00:58:37,200
problem

1555
00:58:37,200 --> 00:58:39,359
but now the main contracture

1556
00:58:39,359 --> 00:58:41,200
upon which lattice-based cryptography is

1557
00:58:41,200 --> 00:58:44,079
built upon is that there's no polynomial

1558
00:58:44,079 --> 00:58:45,680
time algorithm that solves the shortest

1559
00:58:45,680 --> 00:58:48,160
vector problem um neither on classical

1560
00:58:48,160 --> 00:58:49,200
nor quantum

1561
00:58:49,200 --> 00:58:51,200
quantum computers for polynomial

1562
00:58:51,200 --> 00:58:53,680
approximation factors

1563
00:58:53,680 --> 00:58:57,040
and so in this work we are looking in at

1564
00:58:57,040 --> 00:58:58,480
lattices that have an additional

1565
00:58:58,480 --> 00:59:00,720
structure that comes from algebraic

1566
00:59:00,720 --> 00:59:03,599
number theory so i have to introduce a

1567
00:59:03,599 --> 00:59:05,520
little bit the notions so we have a

1568
00:59:05,520 --> 00:59:09,520
number field uh k which is of degree d

1569
00:59:09,520 --> 00:59:12,480
and okay it's this ring of integers

1570
00:59:12,480 --> 00:59:14,559
and to every number field we can

1571
00:59:14,559 --> 00:59:17,440
associate a canonical embedding sigma

1572
00:59:17,440 --> 00:59:19,680
that takes a field element and maps it

1573
00:59:19,680 --> 00:59:21,040
to the real

1574
00:59:21,040 --> 00:59:24,559
space of dimension d so um yeah

1575
00:59:24,559 --> 00:59:27,280
yeah and then what we can do is we take

1576
00:59:27,280 --> 00:59:29,760
a structure in algebraic number three as

1577
00:59:29,760 --> 00:59:32,240
for instance a module of rank r and then

1578
00:59:32,240 --> 00:59:35,040
map it via this canonical embedding

1579
00:59:35,040 --> 00:59:37,040
to the reals and now we end up in a

1580
00:59:37,040 --> 00:59:39,599
lattice of dimension

1581
00:59:39,599 --> 00:59:41,680
in the space of dimension d times r

1582
00:59:41,680 --> 00:59:43,599
where d is the field degree and r the

1583
00:59:43,599 --> 00:59:46,480
module rank but now this lattice

1584
00:59:46,480 --> 00:59:48,480
inherits the module structure and this

1585
00:59:48,480 --> 00:59:50,720
is what we call a modulators and then we

1586
00:59:50,720 --> 00:59:52,400
can do this of course that's just

1587
00:59:52,400 --> 00:59:54,480
notation so if the rank is one then we

1588
00:59:54,480 --> 00:59:57,440
call this actually a an idea and that's

1589
00:59:57,440 --> 01:00:00,400
why we end up in ideal lattices and then

1590
01:00:00,400 --> 01:00:01,520
if i say

1591
01:00:01,520 --> 01:00:03,520
module show this vector problem or ideal

1592
01:00:03,520 --> 01:00:05,200
shortest vector problem i'm just talking

1593
01:00:05,200 --> 01:00:07,040
about the shortest vector problem i've

1594
01:00:07,040 --> 01:00:09,359
introduced before restricted to module

1595
01:00:09,359 --> 01:00:10,960
or ideal lattices

1596
01:00:10,960 --> 01:00:13,119
and why are people actually looking at

1597
01:00:13,119 --> 01:00:15,200
this quite special variant of this

1598
01:00:15,200 --> 01:00:17,520
problem because it's used as a hardness

1599
01:00:17,520 --> 01:00:19,200
assumption for practicality space

1600
01:00:19,200 --> 01:00:20,559
cryptography

1601
01:00:20,559 --> 01:00:22,480
and so the main question that has

1602
01:00:22,480 --> 01:00:24,720
occupied the community in the last 10

1603
01:00:24,720 --> 01:00:26,960
years or so is

1604
01:00:26,960 --> 01:00:29,280
whether the shortest vector problem

1605
01:00:29,280 --> 01:00:31,440
becomes easier once you restrict it to

1606
01:00:31,440 --> 01:00:34,720
those special modular id lattices

1607
01:00:34,720 --> 01:00:35,440
and

1608
01:00:35,440 --> 01:00:38,960
today i'm focusing on the ideal case and

1609
01:00:38,960 --> 01:00:42,400
for very specific ideas

1610
01:00:42,400 --> 01:00:43,680
and so

1611
01:00:43,680 --> 01:00:45,280
what's the state of the art of

1612
01:00:45,280 --> 01:00:47,359
polynomial solvers for the ideal

1613
01:00:47,359 --> 01:00:49,359
shortest vector problem on specific

1614
01:00:49,359 --> 01:00:51,680
ideas so those are exactly the puddles

1615
01:00:51,680 --> 01:00:53,200
that i had in the picture of the

1616
01:00:53,200 --> 01:00:54,400
introduction

1617
01:00:54,400 --> 01:00:56,160
so the first two works i would like to

1618
01:00:56,160 --> 01:00:59,200
mention are here the karma and

1619
01:00:59,200 --> 01:01:01,520
co-authors paper that solves the

1620
01:01:01,520 --> 01:01:04,000
shortest vector problem for principal

1621
01:01:04,000 --> 01:01:06,240
ideals if the generate if the generator

1622
01:01:06,240 --> 01:01:08,000
is a gaussian

1623
01:01:08,000 --> 01:01:09,839
and a second work so that was the second

1624
01:01:09,839 --> 01:01:12,880
puddle is another work of karma encoders

1625
01:01:12,880 --> 01:01:15,520
that now solves it for all ideas but

1626
01:01:15,520 --> 01:01:17,119
only if the approximation factor is

1627
01:01:17,119 --> 01:01:20,000
super large so sub-exponential

1628
01:01:20,000 --> 01:01:22,000
and so our work is

1629
01:01:22,000 --> 01:01:24,319
built upon those two works that was the

1630
01:01:24,319 --> 01:01:27,440
third puddle and um so the first one is

1631
01:01:27,440 --> 01:01:28,720
due to

1632
01:01:28,720 --> 01:01:31,599
pan and co-authors and they show

1633
01:01:31,599 --> 01:01:32,319
an

1634
01:01:32,319 --> 01:01:34,880
efficient solver for prime ideals that

1635
01:01:34,880 --> 01:01:36,720
have additional symmetries i will

1636
01:01:36,720 --> 01:01:38,079
explain later what i mean with

1637
01:01:38,079 --> 01:01:40,240
symmetries where the approximation

1638
01:01:40,240 --> 01:01:42,160
factor is quite decent with square root

1639
01:01:42,160 --> 01:01:44,240
of the field degree

1640
01:01:44,240 --> 01:01:48,240
and then later porter and co-authors

1641
01:01:48,240 --> 01:01:51,040
improved upon this by now applying this

1642
01:01:51,040 --> 01:01:54,880
to all ideal lattices with symmetries

1643
01:01:54,880 --> 01:01:56,960
but now the approximation factor is much

1644
01:01:56,960 --> 01:01:58,400
harder to grasp

1645
01:01:58,400 --> 01:02:00,799
and in a particular need the prime

1646
01:02:00,799 --> 01:02:03,200
decomposition of the ideal and its

1647
01:02:03,200 --> 01:02:05,920
norm in order to calculate this and it's

1648
01:02:05,920 --> 01:02:08,160
not a it's not very easy

1649
01:02:08,160 --> 01:02:11,359
and so our work now generalize this

1650
01:02:11,359 --> 01:02:14,000
results in several aspects so first we

1651
01:02:14,000 --> 01:02:16,000
are over all number fields

1652
01:02:16,000 --> 01:02:18,079
and then um

1653
01:02:18,079 --> 01:02:19,280
the set

1654
01:02:19,280 --> 01:02:20,799
of our um

1655
01:02:20,799 --> 01:02:22,240
yeah that we cover so that is what i

1656
01:02:22,240 --> 01:02:24,480
meant that we enlarge the puddle is that

1657
01:02:24,480 --> 01:02:26,960
so if we restrict the set of the

1658
01:02:26,960 --> 01:02:28,559
previous work to polynomial

1659
01:02:28,559 --> 01:02:30,559
approximation factor then our set is

1660
01:02:30,559 --> 01:02:32,559
strictly larger and in particular the

1661
01:02:32,559 --> 01:02:34,160
partial van vulnerability problem that

1662
01:02:34,160 --> 01:02:36,960
we will look at later falls into

1663
01:02:36,960 --> 01:02:39,039
only this larger set

1664
01:02:39,039 --> 01:02:40,559
okay and then

1665
01:02:40,559 --> 01:02:43,520
approximation factors are quite decent

1666
01:02:43,520 --> 01:02:44,559
and

1667
01:02:44,559 --> 01:02:46,240
yeah and that's what i said with the

1668
01:02:46,240 --> 01:02:48,480
warning sign so membership in our set

1669
01:02:48,480 --> 01:02:50,480
can be very easily checked

1670
01:02:50,480 --> 01:02:52,319
and i have a little star at the all

1671
01:02:52,319 --> 01:02:54,160
because it's actually not all id letters

1672
01:02:54,160 --> 01:02:55,760
but only those

1673
01:02:55,760 --> 01:02:58,160
whose prime factors are not ramified but

1674
01:02:58,160 --> 01:03:01,680
those are all but finitely many

1675
01:03:01,760 --> 01:03:04,000
okay so now i will there there's a bit

1676
01:03:04,000 --> 01:03:07,039
of math coming now and i will try to

1677
01:03:07,039 --> 01:03:08,880
explain what uh what i mean with

1678
01:03:08,880 --> 01:03:10,160
symmetries

1679
01:03:10,160 --> 01:03:12,960
so we have the number field of degree d

1680
01:03:12,960 --> 01:03:14,240
and we look at the group of

1681
01:03:14,240 --> 01:03:16,000
automorphisms

1682
01:03:16,000 --> 01:03:17,920
and then what we define is this number

1683
01:03:17,920 --> 01:03:20,240
and i that is the number of all the

1684
01:03:20,240 --> 01:03:22,960
automorphisms that fix the ideal as a

1685
01:03:22,960 --> 01:03:24,559
set

1686
01:03:24,559 --> 01:03:25,839
so

1687
01:03:25,839 --> 01:03:27,359
we know that in this group there's the

1688
01:03:27,359 --> 01:03:29,440
identity and the identity always fixes

1689
01:03:29,440 --> 01:03:31,760
the ideal so we know that this number is

1690
01:03:31,760 --> 01:03:33,119
at least one

1691
01:03:33,119 --> 01:03:35,599
but this group has at most d which is

1692
01:03:35,599 --> 01:03:37,680
the field degree elements so we know

1693
01:03:37,680 --> 01:03:41,520
that this number is also at most d

1694
01:03:41,520 --> 01:03:43,680
and now comes this main theory from our

1695
01:03:43,680 --> 01:03:45,839
paper where we show that if we have an

1696
01:03:45,839 --> 01:03:46,880
idea

1697
01:03:46,880 --> 01:03:48,640
whose factors are prime factors are not

1698
01:03:48,640 --> 01:03:50,720
ramified then we have a classical

1699
01:03:50,720 --> 01:03:52,160
algorithm that solves the shortest

1700
01:03:52,160 --> 01:03:54,400
vector problem on this ideal

1701
01:03:54,400 --> 01:03:56,799
in time roughly exponential

1702
01:03:56,799 --> 01:04:00,240
d the field degree over ni times log

1703
01:04:00,240 --> 01:04:01,839
gamma where gamma is the approximation

1704
01:04:01,839 --> 01:04:02,720
factor

1705
01:04:02,720 --> 01:04:05,760
so if this ni is one so the ideal is

1706
01:04:05,760 --> 01:04:08,319
only fixed by the identity then we

1707
01:04:08,319 --> 01:04:10,480
recover an exponential time algorithm

1708
01:04:10,480 --> 01:04:12,400
this is what we have for general

1709
01:04:12,400 --> 01:04:13,920
lattices as well

1710
01:04:13,920 --> 01:04:14,720
but

1711
01:04:14,720 --> 01:04:17,520
if this ni is a fraction of d let's say

1712
01:04:17,520 --> 01:04:18,880
d over 2

1713
01:04:18,880 --> 01:04:21,119
then we recover a polynomial algorithm

1714
01:04:21,119 --> 01:04:24,880
as the here the ni cancels out the d

1715
01:04:24,880 --> 01:04:26,559
and this is exactly what i mean when i

1716
01:04:26,559 --> 01:04:28,960
say that i the the letters has many

1717
01:04:28,960 --> 01:04:30,640
symmetries

1718
01:04:30,640 --> 01:04:33,119
and now of course it's relevant that you

1719
01:04:33,119 --> 01:04:35,839
it's easy to compute this ni

1720
01:04:35,839 --> 01:04:37,839
once you have a description of the ideal

1721
01:04:37,839 --> 01:04:40,319
like basis and a description of the

1722
01:04:40,319 --> 01:04:43,440
group of automorphism

1723
01:04:43,599 --> 01:04:45,599
and i think that's the just the last

1724
01:04:45,599 --> 01:04:47,520
technical slide regarding the first

1725
01:04:47,520 --> 01:04:49,680
contribution is that now i want to like

1726
01:04:49,680 --> 01:04:51,680
give a little bit of an intuition why

1727
01:04:51,680 --> 01:04:53,520
many symmetries help to solve the

1728
01:04:53,520 --> 01:04:56,319
shortest vector problem more easily

1729
01:04:56,319 --> 01:04:59,200
so the ni number that i just gave you is

1730
01:04:59,200 --> 01:05:01,599
actually the size of the decomposition

1731
01:05:01,599 --> 01:05:04,319
group so that's just the same definition

1732
01:05:04,319 --> 01:05:06,000
as what i gave you

1733
01:05:06,000 --> 01:05:07,119
and

1734
01:05:07,119 --> 01:05:09,680
we can look at its fixed field what we

1735
01:05:09,680 --> 01:05:12,880
also call the decomposition field so ki

1736
01:05:12,880 --> 01:05:14,640
and then the main technical lemma in our

1737
01:05:14,640 --> 01:05:16,319
paper is that

1738
01:05:16,319 --> 01:05:18,880
if you have you're given an idea

1739
01:05:18,880 --> 01:05:20,960
then you can intersect it with this

1740
01:05:20,960 --> 01:05:23,839
fixed field the composition field and

1741
01:05:23,839 --> 01:05:25,440
multiply it again with the ring of

1742
01:05:25,440 --> 01:05:28,559
integers to recover your original idea

1743
01:05:28,559 --> 01:05:31,119
and intuitively what that means is that

1744
01:05:31,119 --> 01:05:33,599
if you have a short vector in i then it

1745
01:05:33,599 --> 01:05:35,200
is also

1746
01:05:35,200 --> 01:05:37,839
contained in this smaller set i

1747
01:05:37,839 --> 01:05:40,319
intersected with this fixed tree

1748
01:05:40,319 --> 01:05:42,799
and what this means is that the larger

1749
01:05:42,799 --> 01:05:46,240
your hi so the larger the number ni

1750
01:05:46,240 --> 01:05:48,720
so the more automorphisms fix this field

1751
01:05:48,720 --> 01:05:51,520
at this ideal sorry then the smaller

1752
01:05:51,520 --> 01:05:53,440
becomes the fixed field because that's

1753
01:05:53,440 --> 01:05:54,960
an inverse

1754
01:05:54,960 --> 01:05:56,160
relation

1755
01:05:56,160 --> 01:05:57,920
and then the smaller becomes this

1756
01:05:57,920 --> 01:05:59,599
intersection and the easier it is to

1757
01:05:59,599 --> 01:06:01,039
find short vectors

1758
01:06:01,039 --> 01:06:03,280
so we can go down to a much smaller set

1759
01:06:03,280 --> 01:06:04,960
and then lift it up by multiplying it

1760
01:06:04,960 --> 01:06:06,799
with this ring of integers so that's

1761
01:06:06,799 --> 01:06:09,119
really at the that's the technical uh

1762
01:06:09,119 --> 01:06:11,920
part of this contribution

1763
01:06:11,920 --> 01:06:13,760
okay then let's move on on the partial

1764
01:06:13,760 --> 01:06:15,839
random knapsack problem

1765
01:06:15,839 --> 01:06:17,280
i guess that most of you have never

1766
01:06:17,280 --> 01:06:19,920
heard of it so let me introduce it

1767
01:06:19,920 --> 01:06:21,680
and so we

1768
01:06:21,680 --> 01:06:23,680
stay in our algebraic

1769
01:06:23,680 --> 01:06:25,359
settings so we have the number field of

1770
01:06:25,359 --> 01:06:26,480
degree d

1771
01:06:26,480 --> 01:06:29,680
and now we look at some prime minister q

1772
01:06:29,680 --> 01:06:31,760
such that we know that the ideal

1773
01:06:31,760 --> 01:06:34,079
generated by this number completely

1774
01:06:34,079 --> 01:06:36,720
splits in prime ideals of normal q so we

1775
01:06:36,720 --> 01:06:38,799
have d prime ideas

1776
01:06:38,799 --> 01:06:41,039
and now what we do is we select a subset

1777
01:06:41,039 --> 01:06:43,839
omega of those d prime ideas and just

1778
01:06:43,839 --> 01:06:45,359
look at the

1779
01:06:45,359 --> 01:06:48,400
product of those prime ideas

1780
01:06:48,400 --> 01:06:50,240
okay and now the passion on the knapsack

1781
01:06:50,240 --> 01:06:51,839
problem takes

1782
01:06:51,839 --> 01:06:54,000
as a parameter distribution over this

1783
01:06:54,000 --> 01:06:56,720
ring that only samples element of sure

1784
01:06:56,720 --> 01:06:58,839
no short norm

1785
01:06:58,839 --> 01:07:02,559
and then the problem statement is that

1786
01:07:02,559 --> 01:07:04,079
if we sample an element from this

1787
01:07:04,079 --> 01:07:07,200
distribution and compute the coset e mod

1788
01:07:07,200 --> 01:07:09,920
this special ideal given by those

1789
01:07:09,920 --> 01:07:13,359
factors then the problem asks to find

1790
01:07:13,359 --> 01:07:15,680
and recover this e

1791
01:07:15,680 --> 01:07:17,920
from the support of psi so usually we

1792
01:07:17,920 --> 01:07:19,520
take the parameter such that there's

1793
01:07:19,520 --> 01:07:21,440
only unique solution

1794
01:07:21,440 --> 01:07:23,359
and i didn't really specify how we

1795
01:07:23,359 --> 01:07:25,839
choose this omega and this is also

1796
01:07:25,839 --> 01:07:27,760
because in the literature there are two

1797
01:07:27,760 --> 01:07:30,160
ways of doing it so in the original

1798
01:07:30,160 --> 01:07:33,039
proposal by hofstein and co-authors and

1799
01:07:33,039 --> 01:07:35,359
they did not specify how to choose the

1800
01:07:35,359 --> 01:07:36,480
omega

1801
01:07:36,480 --> 01:07:38,400
besides some constraint on how large it

1802
01:07:38,400 --> 01:07:40,160
should be

1803
01:07:40,160 --> 01:07:42,400
and in particular they kind of suggest

1804
01:07:42,400 --> 01:07:44,559
that you can fix it

1805
01:07:44,559 --> 01:07:45,839
and

1806
01:07:45,839 --> 01:07:48,559
in subsequent works by loo encoders and

1807
01:07:48,559 --> 01:07:50,799
another one i co-authored we actually

1808
01:07:50,799 --> 01:07:53,280
decided to add more entropy and to

1809
01:07:53,280 --> 01:07:57,119
select this omega uniformly adrenal

1810
01:07:57,119 --> 01:07:59,359
okay so now i promised you that this

1811
01:07:59,359 --> 01:08:01,440
partial monomer knapsack problem lies on

1812
01:08:01,440 --> 01:08:03,359
this frozen leg of the shortest vector

1813
01:08:03,359 --> 01:08:04,319
problem

1814
01:08:04,319 --> 01:08:05,200
but

1815
01:08:05,200 --> 01:08:06,720
um it's

1816
01:08:06,720 --> 01:08:08,400
actually not defining a shortest vector

1817
01:08:08,400 --> 01:08:10,480
problem but a related problem that is

1818
01:08:10,480 --> 01:08:12,559
called bounded distance decoding problem

1819
01:08:12,559 --> 01:08:14,960
so i have to introduce that

1820
01:08:14,960 --> 01:08:17,600
over ideas so we are given an ideal and

1821
01:08:17,600 --> 01:08:20,479
i give you what we call a target vector

1822
01:08:20,479 --> 01:08:23,040
and we are promised that it's this it

1823
01:08:23,040 --> 01:08:25,600
can be described as the sum of a vector

1824
01:08:25,600 --> 01:08:28,479
that lies in the letters and some offset

1825
01:08:28,479 --> 01:08:29,198
e

1826
01:08:29,198 --> 01:08:32,000
where we are promised that this offset e

1827
01:08:32,000 --> 01:08:34,319
is of small norm so we know that we have

1828
01:08:34,319 --> 01:08:36,560
a target vector that is somehow close to

1829
01:08:36,560 --> 01:08:37,759
my letters

1830
01:08:37,759 --> 01:08:40,080
and now this bounded distance decoding

1831
01:08:40,080 --> 01:08:42,399
problem asked to recover either the

1832
01:08:42,399 --> 01:08:44,479
offset or the lattice vector that is

1833
01:08:44,479 --> 01:08:46,319
actually equivalent

1834
01:08:46,319 --> 01:08:48,799
and now if we assume that our

1835
01:08:48,799 --> 01:08:50,640
psi distribution from the partial

1836
01:08:50,640 --> 01:08:53,679
venomognessic instance is delta bounded

1837
01:08:53,679 --> 01:08:54,560
then

1838
01:08:54,560 --> 01:08:57,520
having a vector that is the offset e mod

1839
01:08:57,520 --> 01:09:00,399
this special idea is exactly the same as

1840
01:09:00,399 --> 01:09:04,000
writing it like a sum of a lattice point

1841
01:09:04,000 --> 01:09:06,799
and an offset that is bounded by delta

1842
01:09:06,799 --> 01:09:09,040
so it's really like just rewriting

1843
01:09:09,040 --> 01:09:10,560
partial monomer knapsack gives you a

1844
01:09:10,560 --> 01:09:13,359
bounded distance decoding problem

1845
01:09:13,359 --> 01:09:15,198
and of course now the missing puzzle

1846
01:09:15,198 --> 01:09:17,439
piece is that you have to map this

1847
01:09:17,439 --> 01:09:19,600
boundary distance decoding instance to a

1848
01:09:19,600 --> 01:09:21,520
shortest vector instance and here will

1849
01:09:21,520 --> 01:09:23,439
be a bit hand waving because it's

1850
01:09:23,439 --> 01:09:25,920
actually very standard technique and not

1851
01:09:25,920 --> 01:09:28,799
so relevant for this talk and the really

1852
01:09:28,799 --> 01:09:31,839
only important thing is that

1853
01:09:31,839 --> 01:09:34,640
we map an ideal i to some related ideal

1854
01:09:34,640 --> 01:09:37,279
i prime and that

1855
01:09:37,279 --> 01:09:39,198
those have a relation in the sense that

1856
01:09:39,198 --> 01:09:41,600
whenever i has symmetries then i prime

1857
01:09:41,600 --> 01:09:44,319
has also symmetries and vice versa so

1858
01:09:44,319 --> 01:09:46,000
this reduction preserves symmetry

1859
01:09:46,000 --> 01:09:48,479
somehow

1860
01:09:48,479 --> 01:09:49,520
and

1861
01:09:49,520 --> 01:09:52,799
now we can think about how we can attack

1862
01:09:52,799 --> 01:09:54,800
the partial volume and knapsack problem

1863
01:09:54,800 --> 01:09:56,159
so

1864
01:09:56,159 --> 01:09:58,159
whenever we can solve the shortest

1865
01:09:58,159 --> 01:10:00,080
vector problem defined by this special

1866
01:10:00,080 --> 01:10:01,840
idea then we can solve the partial

1867
01:10:01,840 --> 01:10:04,080
random and lapsec problem and it all

1868
01:10:04,080 --> 01:10:06,000
like with all what i've said in the

1869
01:10:06,000 --> 01:10:08,400
first part it comes down to

1870
01:10:08,400 --> 01:10:11,360
when does this ideal has many symmetries

1871
01:10:11,360 --> 01:10:13,440
and now i will

1872
01:10:13,440 --> 01:10:15,520
convince you by doing it from the other

1873
01:10:15,520 --> 01:10:18,719
way i will actually construct specific

1874
01:10:18,719 --> 01:10:20,000
ideals

1875
01:10:20,000 --> 01:10:22,159
for like this of this shape that are

1876
01:10:22,159 --> 01:10:24,239
fixed by many automorphisms so we know

1877
01:10:24,239 --> 01:10:27,360
they have many symmetries

1878
01:10:27,360 --> 01:10:28,960
and i think that's the last

1879
01:10:28,960 --> 01:10:32,080
math equations for this talk

1880
01:10:32,080 --> 01:10:34,640
is that so what we do is we take the

1881
01:10:34,640 --> 01:10:36,560
ideal generated by q

1882
01:10:36,560 --> 01:10:39,199
and fix one of the prime ideas p just

1883
01:10:39,199 --> 01:10:40,400
call it p

1884
01:10:40,400 --> 01:10:42,159
and then we take the subgroup of the

1885
01:10:42,159 --> 01:10:44,480
group of automorphisms age

1886
01:10:44,480 --> 01:10:46,719
and what you need to know and i think

1887
01:10:46,719 --> 01:10:47,840
this is like

1888
01:10:47,840 --> 01:10:49,600
algebra

1889
01:10:49,600 --> 01:10:52,400
two or one i don't know a math course is

1890
01:10:52,400 --> 01:10:55,360
that the automorphisms

1891
01:10:55,360 --> 01:10:58,080
act transitively on those primary deal

1892
01:10:58,080 --> 01:11:00,080
factors so if you apply this

1893
01:11:00,080 --> 01:11:02,560
automotiveness on p you will end up with

1894
01:11:02,560 --> 01:11:04,480
one of those factors you will always

1895
01:11:04,480 --> 01:11:06,159
stay within the set

1896
01:11:06,159 --> 01:11:08,400
so of course if you take a subgroup here

1897
01:11:08,400 --> 01:11:11,040
then this actually defines an index set

1898
01:11:11,040 --> 01:11:12,800
because you're permuting

1899
01:11:12,800 --> 01:11:16,000
within those primary factors and so if

1900
01:11:16,000 --> 01:11:18,320
we define this ideal i

1901
01:11:18,320 --> 01:11:21,199
omega h with respect to the subgroup

1902
01:11:21,199 --> 01:11:22,719
then

1903
01:11:22,719 --> 01:11:25,280
we actually have an idea that is fixed

1904
01:11:25,280 --> 01:11:29,199
by this subgroup by construction

1905
01:11:29,199 --> 01:11:31,520
and of like for example if you take a

1906
01:11:31,520 --> 01:11:33,679
power of two cycle atomic of degree d

1907
01:11:33,679 --> 01:11:36,159
then we can have subgroups of order d

1908
01:11:36,159 --> 01:11:38,719
over two so this is a fraction of the

1909
01:11:38,719 --> 01:11:40,960
very large subgroups

1910
01:11:40,960 --> 01:11:42,560
and yeah

1911
01:11:42,560 --> 01:11:43,360
so

1912
01:11:43,360 --> 01:11:45,040
we so what i

1913
01:11:45,040 --> 01:11:47,440
yeah so we implemented this algorithm

1914
01:11:47,440 --> 01:11:48,239
and

1915
01:11:48,239 --> 01:11:49,840
run experiments on two different

1916
01:11:49,840 --> 01:11:53,280
scenarios so the first scenario is what

1917
01:11:53,280 --> 01:11:55,600
i call a worst case omega so this is

1918
01:11:55,600 --> 01:11:57,760
when the adversary can actually choose

1919
01:11:57,760 --> 01:11:59,760
the omega on their own

1920
01:11:59,760 --> 01:12:02,560
for in a for them adventurous way and of

1921
01:12:02,560 --> 01:12:04,239
course they will choose the omega such

1922
01:12:04,239 --> 01:12:06,400
that is fixed by many automorphisms and

1923
01:12:06,400 --> 01:12:08,560
in this case when we take parameter sets

1924
01:12:08,560 --> 01:12:11,040
from the literature we can solve partial

1925
01:12:11,040 --> 01:12:13,360
venom and knapsack in in a very

1926
01:12:13,360 --> 01:12:15,199
short amount of time

1927
01:12:15,199 --> 01:12:17,040
in the second scenario where the omega

1928
01:12:17,040 --> 01:12:19,360
is sampled uniformly at random

1929
01:12:19,360 --> 01:12:21,679
we cannot do this because with

1930
01:12:21,679 --> 01:12:24,480
very high probability this

1931
01:12:24,480 --> 01:12:26,640
the omega will not be fixed by any

1932
01:12:26,640 --> 01:12:28,960
non-trivial automorphism so there will

1933
01:12:28,960 --> 01:12:31,520
be no symmetries but what we can do in

1934
01:12:31,520 --> 01:12:33,600
the distinguishing attack is that we can

1935
01:12:33,600 --> 01:12:36,480
forget some of the prime ideas so forget

1936
01:12:36,480 --> 01:12:40,000
some of the indie indexes in the in the

1937
01:12:40,000 --> 01:12:41,920
set omica then actually the problem

1938
01:12:41,920 --> 01:12:44,480
becomes a harder problem but we can hope

1939
01:12:44,480 --> 01:12:47,040
for finding at least one symmetry and

1940
01:12:47,040 --> 01:12:48,640
this is what happens with a

1941
01:12:48,640 --> 01:12:51,760
non-negligible probab probability

1942
01:12:51,760 --> 01:12:53,280
and then in this case when we take

1943
01:12:53,280 --> 01:12:55,120
concrete

1944
01:12:55,120 --> 01:12:57,960
parameter sets then we can reduce the

1945
01:12:57,960 --> 01:13:00,880
128-bit security claimed in one of the

1946
01:13:00,880 --> 01:13:03,760
literature to

1947
01:13:03,760 --> 01:13:06,640
so it's quite significant

1948
01:13:06,640 --> 01:13:08,480
and i think that was the last slide and

1949
01:13:08,480 --> 01:13:11,920
i move on now to clarifying what are the

1950
01:13:11,920 --> 01:13:13,520
implications to ladies-based

1951
01:13:13,520 --> 01:13:15,440
cryptography

1952
01:13:15,440 --> 01:13:17,280
so the first thing you might wonder is

1953
01:13:17,280 --> 01:13:19,760
if it's still a wise thing to use the

1954
01:13:19,760 --> 01:13:22,000
ideal shortest vector problem to build

1955
01:13:22,000 --> 01:13:23,440
cryptography

1956
01:13:23,440 --> 01:13:25,280
and i think it's a

1957
01:13:25,280 --> 01:13:26,320
it's a

1958
01:13:26,320 --> 01:13:28,000
complex question but

1959
01:13:28,000 --> 01:13:30,640
we try to give guidelines if you wish to

1960
01:13:30,640 --> 01:13:33,199
do so what we suggested you should

1961
01:13:33,199 --> 01:13:34,159
follow

1962
01:13:34,159 --> 01:13:36,400
and so the first thing we suggest is

1963
01:13:36,400 --> 01:13:38,560
that you check if you can increase your

1964
01:13:38,560 --> 01:13:40,400
rank from one to two

1965
01:13:40,400 --> 01:13:41,840
so that means that you're actually not

1966
01:13:41,840 --> 01:13:43,760
relying on id lattices but on module

1967
01:13:43,760 --> 01:13:45,760
lattices where we have no weaknesses

1968
01:13:45,760 --> 01:13:48,560
nouns or no puddles in the frozen lake

1969
01:13:48,560 --> 01:13:51,679
and if you can't do that then we suggest

1970
01:13:51,679 --> 01:13:54,080
that you use uh and the distribute that

1971
01:13:54,080 --> 01:13:56,000
you select your ideal randomly from a

1972
01:13:56,000 --> 01:13:58,159
distribution where we know that this

1973
01:13:58,159 --> 01:14:00,480
distribution is supported by a what we

1974
01:14:00,480 --> 01:14:02,080
call worst case to average case

1975
01:14:02,080 --> 01:14:03,760
reduction that means that this

1976
01:14:03,760 --> 01:14:05,760
distribution gives you

1977
01:14:05,760 --> 01:14:08,320
a idea lattice that is as hard as

1978
01:14:08,320 --> 01:14:09,679
possible

1979
01:14:09,679 --> 01:14:12,159
if you can't do that then at least avoid

1980
01:14:12,159 --> 01:14:15,360
bad ideas so one class of bad ideas are

1981
01:14:15,360 --> 01:14:17,520
the principal ideas with a gaussian

1982
01:14:17,520 --> 01:14:20,320
generator as in previous work or the

1983
01:14:20,320 --> 01:14:21,840
ideas that we

1984
01:14:21,840 --> 01:14:24,080
worked on in this paper that are fixed

1985
01:14:24,080 --> 01:14:26,640
by non-trivial automorphisms

1986
01:14:26,640 --> 01:14:29,199
and in all cases you should not rely on

1987
01:14:29,199 --> 01:14:31,040
the hardness if the approximation factor

1988
01:14:31,040 --> 01:14:33,600
is too large

1989
01:14:34,400 --> 01:14:36,560
then of course the question is what what

1990
01:14:36,560 --> 01:14:38,640
are the implications of our results on

1991
01:14:38,640 --> 01:14:40,000
cryptography that is based on the

1992
01:14:40,000 --> 01:14:42,159
partial random natsec problem i haven't

1993
01:14:42,159 --> 01:14:44,480
really talked about it but there is a

1994
01:14:44,480 --> 01:14:46,000
signature scheme and an encryption

1995
01:14:46,000 --> 01:14:48,000
scheme and also an aggregate signature

1996
01:14:48,000 --> 01:14:49,040
scheme

1997
01:14:49,040 --> 01:14:51,520
and when we apply our

1998
01:14:51,520 --> 01:14:54,239
yeah so our algorithm actually leads to

1999
01:14:54,239 --> 01:14:57,600
quite severe key recovery and photore

2000
01:14:57,600 --> 01:15:00,719
attacks but only if the omega is

2001
01:15:00,719 --> 01:15:03,040
this specific like very specific design

2002
01:15:03,040 --> 01:15:04,320
choices

2003
01:15:04,320 --> 01:15:06,480
if the omega is random then we can also

2004
01:15:06,480 --> 01:15:08,640
only do those distinguishing attacks

2005
01:15:08,640 --> 01:15:10,480
that half the lattice dimension of the

2006
01:15:10,480 --> 01:15:12,560
attack and of course this can easily be

2007
01:15:12,560 --> 01:15:16,640
mitigated by increasing the parameters

2008
01:15:16,800 --> 01:15:19,199
and last but not least what are the

2009
01:15:19,199 --> 01:15:20,800
implications for lattice-based

2010
01:15:20,800 --> 01:15:22,960
cryptography in general

2011
01:15:22,960 --> 01:15:24,800
i already said it but i want to stress

2012
01:15:24,800 --> 01:15:27,120
it again those attacks are only for very

2013
01:15:27,120 --> 01:15:28,960
specific instances of the ideal shortest

2014
01:15:28,960 --> 01:15:31,360
vector problem and having many

2015
01:15:31,360 --> 01:15:33,280
symmetries seems a very strong

2016
01:15:33,280 --> 01:15:35,600
requirement and very unnatural for id

2017
01:15:35,600 --> 01:15:37,199
ledgers to have

2018
01:15:37,199 --> 01:15:39,280
and so there are no implications to the

2019
01:15:39,280 --> 01:15:41,600
hardness of structured problems like the

2020
01:15:41,600 --> 01:15:43,360
ring shortest integer solution or ring

2021
01:15:43,360 --> 01:15:45,360
learning with errors problem because

2022
01:15:45,360 --> 01:15:47,199
actually they are based on the worst

2023
01:15:47,199 --> 01:15:48,960
case hardness of ideal shortest vector

2024
01:15:48,960 --> 01:15:51,520
problem so you would yeah so they assume

2025
01:15:51,520 --> 01:15:53,840
the hardness of the hardest instance and

2026
01:15:53,840 --> 01:15:56,480
not on specific instances and even if

2027
01:15:56,480 --> 01:15:58,400
you would have so those reductions

2028
01:15:58,400 --> 01:16:00,960
actually only in one direction even if

2029
01:16:00,960 --> 01:16:02,880
you would have a solver even if the lake

2030
01:16:02,880 --> 01:16:05,920
would completely melt for ideal shortest

2031
01:16:05,920 --> 01:16:08,080
vector problem then we don't know how to

2032
01:16:08,080 --> 01:16:10,880
use this to actually solve

2033
01:16:10,880 --> 01:16:12,560
for instance the ring learning reverse

2034
01:16:12,560 --> 01:16:14,320
problem

2035
01:16:14,320 --> 01:16:15,199
and

2036
01:16:15,199 --> 01:16:17,199
even though i did not even talk about it

2037
01:16:17,199 --> 01:16:19,520
just to make it clear that this work has

2038
01:16:19,520 --> 01:16:21,360
absolutely no implications on the module

2039
01:16:21,360 --> 01:16:22,960
learning with errors problem which is

2040
01:16:22,960 --> 01:16:25,120
the underlying hardness assumption of

2041
01:16:25,120 --> 01:16:28,480
miscandidates like dilithium and kyber

2042
01:16:28,480 --> 01:16:30,000
and um

2043
01:16:30,000 --> 01:16:31,920
i think this concludes my talk thank you

2044
01:16:31,920 --> 01:16:35,080
for listening

2045
01:16:41,120 --> 01:16:44,239
do we have any questions

2046
01:16:46,840 --> 01:16:50,000
no i think everyone's hungry so let's

2047
01:16:50,000 --> 01:16:51,760
thank the speaker again and head to

2048
01:16:51,760 --> 01:16:54,760
lunch

