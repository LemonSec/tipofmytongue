1
00:00:00,160 --> 00:00:01,760
uh i am leo

2
00:00:01,760 --> 00:00:04,720
the assistant chair

3
00:00:05,520 --> 00:00:09,120
uh we have three talks in this session

4
00:00:09,120 --> 00:00:11,920
the first talk is on the impossibility

5
00:00:11,920 --> 00:00:14,639
of key agreements from quantum random

6
00:00:14,639 --> 00:00:17,280
oracles

7
00:00:24,240 --> 00:00:26,880
will give a talk

8
00:00:26,880 --> 00:00:29,279
okay thanks for the introduction and

9
00:00:29,279 --> 00:00:31,439
thanks for being here so early

10
00:00:31,439 --> 00:00:33,360
and so today i will be talking about

11
00:00:33,360 --> 00:00:34,960
only impossibility of key agreements

12
00:00:34,960 --> 00:00:37,360
from continental oracles and this is a

13
00:00:37,360 --> 00:00:40,000
joint work with per austrian kamin jong

14
00:00:40,000 --> 00:00:43,120
hao zhong shinfu and mohammad mahmudi

15
00:00:43,120 --> 00:00:45,520
and this is yao ting ling and i'll start

16
00:00:45,520 --> 00:00:49,440
my phd as an barbara this year

17
00:00:51,039 --> 00:00:52,000
okay

18
00:00:52,000 --> 00:00:53,840
so in a classical world

19
00:00:53,840 --> 00:00:55,360
we can do lots of things with random

20
00:00:55,360 --> 00:00:57,520
oracles it is one way and a collision

21
00:00:57,520 --> 00:00:58,640
resistant

22
00:00:58,640 --> 00:01:00,399
and it basically give us private key

23
00:01:00,399 --> 00:01:02,079
cryptography

24
00:01:02,079 --> 00:01:04,239
but an interesting question is that can

25
00:01:04,239 --> 00:01:06,080
we get key agreement or public key

26
00:01:06,080 --> 00:01:09,360
cryptography from an oracles

27
00:01:09,360 --> 00:01:11,040
so key agreement is a two-party

28
00:01:11,040 --> 00:01:12,640
interactive protocol

29
00:01:12,640 --> 00:01:14,400
where alice and bob's goal is to share a

30
00:01:14,400 --> 00:01:17,520
secret key against the eavesdroppers

31
00:01:17,520 --> 00:01:18,960
so they'll start with their private

32
00:01:18,960 --> 00:01:20,640
local randomness

33
00:01:20,640 --> 00:01:23,360
and they can exchange messages

34
00:01:23,360 --> 00:01:27,680
and finally they upload their own keys

35
00:01:27,680 --> 00:01:29,360
and we say a key agreement protocol is

36
00:01:29,360 --> 00:01:31,520
with perfect completeness if they always

37
00:01:31,520 --> 00:01:34,320
output the same key

38
00:01:34,799 --> 00:01:36,799
and the similar work of impact also in

39
00:01:36,799 --> 00:01:39,920
rubish answers this question negatively

40
00:01:39,920 --> 00:01:41,840
they prove that we cannot use random

41
00:01:41,840 --> 00:01:44,240
oracle to get key agreement

42
00:01:44,240 --> 00:01:46,399
but here the render oracle is the only

43
00:01:46,399 --> 00:01:47,520
assumption

44
00:01:47,520 --> 00:01:49,920
or otherwise we can get key agreements

45
00:01:49,920 --> 00:01:53,759
from development or stuff like that

46
00:01:53,759 --> 00:01:56,000
and they prove it by constructing a

47
00:01:56,000 --> 00:02:00,079
polyquery attack for every key agreement

48
00:02:00,079 --> 00:02:02,240
but what if we allow the parties to use

49
00:02:02,240 --> 00:02:05,200
component computation

50
00:02:05,200 --> 00:02:07,600
but if we allow quantum communication

51
00:02:07,600 --> 00:02:10,160
then the bb-84 protocol would give us

52
00:02:10,160 --> 00:02:13,120
unconditional secure key agreements

53
00:02:13,120 --> 00:02:14,879
so what if the communication is still

54
00:02:14,879 --> 00:02:16,560
classical

55
00:02:16,560 --> 00:02:18,319
and we would like to ask the following

56
00:02:18,319 --> 00:02:19,440
question

57
00:02:19,440 --> 00:02:21,200
can quantum computation around the

58
00:02:21,200 --> 00:02:23,120
oracle and the classical communication

59
00:02:23,120 --> 00:02:26,879
together gives us key agreements

60
00:02:26,879 --> 00:02:29,040
and the random oracle model was proposed

61
00:02:29,040 --> 00:02:30,800
by bonnet dell

62
00:02:30,800 --> 00:02:32,879
it is a regular analytical model that

63
00:02:32,879 --> 00:02:34,239
can be queried and answered in

64
00:02:34,239 --> 00:02:36,640
superposition

65
00:02:36,640 --> 00:02:38,720
so here's our main question

66
00:02:38,720 --> 00:02:40,080
can we obtain

67
00:02:40,080 --> 00:02:42,000
a quantum version of impargiazo rudy's

68
00:02:42,000 --> 00:02:43,360
result

69
00:02:43,360 --> 00:02:45,280
and josura mada in the yamakawa as to

70
00:02:45,280 --> 00:02:47,360
the following question

71
00:02:47,360 --> 00:02:49,519
does there exist a key agreement where

72
00:02:49,519 --> 00:02:51,120
else and bob can only do classical

73
00:02:51,120 --> 00:02:53,519
communication but they can perform local

74
00:02:53,519 --> 00:02:55,440
coding computation and make quantum

75
00:02:55,440 --> 00:02:57,360
queries to a random oracle

76
00:02:57,360 --> 00:02:59,360
but every eavesdropper will need a super

77
00:02:59,360 --> 00:03:00,959
polynomial number of queries to find the

78
00:03:00,959 --> 00:03:02,080
key

79
00:03:02,080 --> 00:03:04,480
and actually we do not know the answer

80
00:03:04,480 --> 00:03:07,680
but we have conditional results

81
00:03:07,680 --> 00:03:11,200
so here's an overview of our results

82
00:03:11,200 --> 00:03:13,840
so first when alice is classical and

83
00:03:13,840 --> 00:03:15,120
bob's quantum

84
00:03:15,120 --> 00:03:17,360
we construct an order d square query

85
00:03:17,360 --> 00:03:19,360
attack on every key agreement in the

86
00:03:19,360 --> 00:03:22,080
random quantum oracle model

87
00:03:22,080 --> 00:03:24,720
and next when they are both quantum

88
00:03:24,720 --> 00:03:27,200
we propose a pyramid charge conjecture

89
00:03:27,200 --> 00:03:30,560
which would imply a polyquery attack

90
00:03:30,560 --> 00:03:31,840
and we are able to prove that

91
00:03:31,840 --> 00:03:34,560
conjuncture with word parameter

92
00:03:34,560 --> 00:03:36,879
which will imply an exponential query

93
00:03:36,879 --> 00:03:38,720
attack

94
00:03:38,720 --> 00:03:42,400
and finally we also have a better result

95
00:03:42,400 --> 00:03:44,959
so we found that if the errors and

96
00:03:44,959 --> 00:03:47,040
ambulance contracture is false then

97
00:03:47,040 --> 00:03:49,120
there do exist a key agreement with

98
00:03:49,120 --> 00:03:51,280
imperfect companies that is secured

99
00:03:51,280 --> 00:03:54,239
against classical eavesdropper

100
00:03:54,239 --> 00:03:55,680
and notice that

101
00:03:55,680 --> 00:03:57,599
if we break key agreement in a quantum

102
00:03:57,599 --> 00:03:59,599
render oracle model with public

103
00:03:59,599 --> 00:04:01,360
then it will imply the fully black box

104
00:04:01,360 --> 00:04:03,840
separations

105
00:04:03,840 --> 00:04:05,120
so here's the

106
00:04:05,120 --> 00:04:06,080
plan

107
00:04:06,080 --> 00:04:08,239
so first i will introduce the notion of

108
00:04:08,239 --> 00:04:10,799
playback construction and reduction

109
00:04:10,799 --> 00:04:13,120
and then i'll review an attack in a

110
00:04:13,120 --> 00:04:14,560
classical case

111
00:04:14,560 --> 00:04:16,720
and finally i will tell you our result

112
00:04:16,720 --> 00:04:19,120
in detail

113
00:04:19,120 --> 00:04:21,600
so after years of research and hard work

114
00:04:21,600 --> 00:04:23,199
it seems very hard to construct key

115
00:04:23,199 --> 00:04:25,919
agreement from our functions

116
00:04:25,919 --> 00:04:27,280
so can we instead prove the

117
00:04:27,280 --> 00:04:30,160
impossibility of doing so

118
00:04:30,160 --> 00:04:32,720
but to prove unconditional impossibility

119
00:04:32,720 --> 00:04:34,320
we have to prove first

120
00:04:34,320 --> 00:04:36,400
one-way functions exist which is also

121
00:04:36,400 --> 00:04:38,080
very hard to do it

122
00:04:38,080 --> 00:04:40,320
and we have to prove key agreement does

123
00:04:40,320 --> 00:04:41,280
not

124
00:04:41,280 --> 00:04:42,639
exist

125
00:04:42,639 --> 00:04:45,360
but they seem to exist

126
00:04:45,360 --> 00:04:47,600
so we have to restrict ourselves to some

127
00:04:47,600 --> 00:04:49,919
general and interesting enough framework

128
00:04:49,919 --> 00:04:52,240
so if we can obtain separation result in

129
00:04:52,240 --> 00:04:54,320
that framework they are still useful and

130
00:04:54,320 --> 00:04:57,199
meaningful

131
00:04:57,199 --> 00:04:58,880
and the definition of black box

132
00:04:58,880 --> 00:05:00,880
reduction was first formalized by rain

133
00:05:00,880 --> 00:05:04,080
gold traversing and red hem

134
00:05:04,080 --> 00:05:06,560
so in cryptography most of time the

135
00:05:06,560 --> 00:05:09,280
construction and reduction of black box

136
00:05:09,280 --> 00:05:10,880
so suppose i want to construct a

137
00:05:10,880 --> 00:05:12,080
primitive p

138
00:05:12,080 --> 00:05:14,000
say it's a key agreement by using

139
00:05:14,000 --> 00:05:15,520
another primitive queue

140
00:05:15,520 --> 00:05:17,600
such as a one-way function

141
00:05:17,600 --> 00:05:19,039
then in your construction of the key

142
00:05:19,039 --> 00:05:20,880
agreement you don't really care about

143
00:05:20,880 --> 00:05:22,639
the code of the one-way function you

144
00:05:22,639 --> 00:05:23,919
only care about the input output

145
00:05:23,919 --> 00:05:25,280
behavior of it

146
00:05:25,280 --> 00:05:27,840
that is you only treat it as a black box

147
00:05:27,840 --> 00:05:29,360
or as the oracle

148
00:05:29,360 --> 00:05:31,039
and as long as this box is hard to

149
00:05:31,039 --> 00:05:32,000
invert

150
00:05:32,000 --> 00:05:33,600
your construction of the key agreement

151
00:05:33,600 --> 00:05:36,000
should always work

152
00:05:36,000 --> 00:05:38,560
and similarly the reduction can only use

153
00:05:38,560 --> 00:05:42,800
the adversary of the ballot box as well

154
00:05:43,199 --> 00:05:44,560
and however

155
00:05:44,560 --> 00:05:46,320
the implementation of the one function

156
00:05:46,320 --> 00:05:48,080
and the adversary of the key agreement

157
00:05:48,080 --> 00:05:50,639
could be inefficient since they are

158
00:05:50,639 --> 00:05:52,960
only given as oracles and we only care

159
00:05:52,960 --> 00:05:56,000
about the number of queries

160
00:05:56,400 --> 00:05:57,840
and the first quantum black box

161
00:05:57,840 --> 00:06:00,240
separation result was obtained by

162
00:06:00,240 --> 00:06:02,800
osa mata and yamakawa where they proved

163
00:06:02,800 --> 00:06:03,759
that

164
00:06:03,759 --> 00:06:05,039
one-way permutation and triple

165
00:06:05,039 --> 00:06:06,800
representation does not give you

166
00:06:06,800 --> 00:06:08,720
collision resistance hedge function in a

167
00:06:08,720 --> 00:06:12,000
black box way even in a quantum setting

168
00:06:12,000 --> 00:06:14,800
and in a quantum setting the implant

169
00:06:14,800 --> 00:06:16,240
the implementation now could have

170
00:06:16,240 --> 00:06:18,240
quantum computation power

171
00:06:18,240 --> 00:06:19,919
and they can make quantum queries to the

172
00:06:19,919 --> 00:06:22,400
oracle

173
00:06:22,560 --> 00:06:24,960
and then i'll review an attack on every

174
00:06:24,960 --> 00:06:26,960
key agreement with perfect completeness

175
00:06:26,960 --> 00:06:29,759
in the random oracle model

176
00:06:29,759 --> 00:06:31,840
and this is called the heavy fairy

177
00:06:31,840 --> 00:06:33,919
learning attack which was based on the

178
00:06:33,919 --> 00:06:36,160
work of barrack mahmudi

179
00:06:36,160 --> 00:06:38,160
so suppose edison bob just finished the

180
00:06:38,160 --> 00:06:42,479
protocol and if now since the transcript

181
00:06:42,479 --> 00:06:45,600
ensure first initialize an empty list l

182
00:06:45,600 --> 00:06:48,720
which is a partial function and then

183
00:06:48,720 --> 00:06:50,800
sure compute the distribution over

184
00:06:50,800 --> 00:06:52,720
alice's view in her head

185
00:06:52,720 --> 00:06:54,880
and here alice's view consists of her

186
00:06:54,880 --> 00:06:57,440
randomness the transcript and the set of

187
00:06:57,440 --> 00:06:58,960
query answer pieces that she learned

188
00:06:58,960 --> 00:07:01,039
from the random oracle

189
00:07:01,039 --> 00:07:04,080
and we'll denote it by pa

190
00:07:04,080 --> 00:07:06,639
and we'll use qa to denote the domain of

191
00:07:06,639 --> 00:07:09,360
pa and we will call it the query set of

192
00:07:09,360 --> 00:07:11,759
alice

193
00:07:12,240 --> 00:07:14,160
so whenever there is a point that is

194
00:07:14,160 --> 00:07:16,000
with at least epsilon probability of

195
00:07:16,000 --> 00:07:18,160
being queried by alice

196
00:07:18,160 --> 00:07:21,039
and but not yet in the list

197
00:07:21,039 --> 00:07:22,720
if we'll go ahead and create that point

198
00:07:22,720 --> 00:07:25,280
to a random oracle and get it and get

199
00:07:25,280 --> 00:07:27,120
the answer

200
00:07:27,120 --> 00:07:29,360
ensure update the list by appending this

201
00:07:29,360 --> 00:07:31,599
query answer pair to it

202
00:07:31,599 --> 00:07:33,840
and she will repeat this procedure until

203
00:07:33,840 --> 00:07:35,840
there's no such point

204
00:07:35,840 --> 00:07:37,120
so

205
00:07:37,120 --> 00:07:39,520
if strategy is quite simple she just

206
00:07:39,520 --> 00:07:42,840
keeps asking valuable

207
00:07:42,840 --> 00:07:45,599
queries so when she stops

208
00:07:45,599 --> 00:07:47,440
she'll obtain a distribution over

209
00:07:47,440 --> 00:07:50,080
alice's view such that for every point

210
00:07:50,080 --> 00:07:51,919
outside of the list they are all

211
00:07:51,919 --> 00:07:55,520
unlikely to be queried by alice

212
00:07:55,520 --> 00:07:57,840
and then show a sample effect view for

213
00:07:57,840 --> 00:08:02,719
alice and output the corresponding key

214
00:08:03,280 --> 00:08:05,120
and we can show that

215
00:08:05,120 --> 00:08:07,199
if square complexity would be order d

216
00:08:07,199 --> 00:08:09,280
over epsilon

217
00:08:09,280 --> 00:08:12,800
so with the property of epsilon if

218
00:08:12,800 --> 00:08:15,680
if attacked will be efficient

219
00:08:15,680 --> 00:08:18,160
and also with high probability

220
00:08:18,160 --> 00:08:20,319
alice's query set in the fake view and

221
00:08:20,319 --> 00:08:21,759
the bob's current set in the real

222
00:08:21,759 --> 00:08:24,840
execution will be destroyed outside of

223
00:08:24,840 --> 00:08:28,080
ql so this means

224
00:08:28,080 --> 00:08:30,160
pa plan pb and l

225
00:08:30,160 --> 00:08:33,840
are consistent with each other

226
00:08:33,919 --> 00:08:35,120
so that means

227
00:08:35,120 --> 00:08:37,279
lc's fake view will be consistent with

228
00:08:37,279 --> 00:08:39,760
bob's view

229
00:08:39,760 --> 00:08:41,839
by perfect completeness if we'll find

230
00:08:41,839 --> 00:08:44,640
the alice's key

231
00:08:45,279 --> 00:08:46,959
and it

232
00:08:46,959 --> 00:08:49,839
is really tempting to generalize

233
00:08:49,839 --> 00:08:52,000
our attack into the content setting but

234
00:08:52,000 --> 00:08:54,880
there are some technical issues

235
00:08:54,880 --> 00:08:56,880
so first there are no more well-defined

236
00:08:56,880 --> 00:08:58,880
query sets for alice and bob

237
00:08:58,880 --> 00:09:00,320
because now they can make funding

238
00:09:00,320 --> 00:09:02,080
queries and when they proceed their

239
00:09:02,080 --> 00:09:03,839
computation

240
00:09:03,839 --> 00:09:05,680
their quantum state change so you can

241
00:09:05,680 --> 00:09:07,200
already talk about which point are

242
00:09:07,200 --> 00:09:09,120
queried and which are not they are not

243
00:09:09,120 --> 00:09:11,680
random variables

244
00:09:11,680 --> 00:09:13,040
and next

245
00:09:13,040 --> 00:09:15,760
since quantum algorithm do not have

246
00:09:15,760 --> 00:09:18,800
random tapes is inherently random

247
00:09:18,800 --> 00:09:20,800
so it is not clear how you can condition

248
00:09:20,800 --> 00:09:22,720
on something and inversely sample

249
00:09:22,720 --> 00:09:25,360
someone's view

250
00:09:25,839 --> 00:09:27,360
but the heavy query learning attack

251
00:09:27,360 --> 00:09:29,600
crucially relies on them

252
00:09:29,600 --> 00:09:31,440
so is there a chance of

253
00:09:31,440 --> 00:09:33,040
extending the attack into a quantum

254
00:09:33,040 --> 00:09:36,000
setting

255
00:09:36,000 --> 00:09:38,000
here's our first result

256
00:09:38,000 --> 00:09:39,440
we can break every key agreement

257
00:09:39,440 --> 00:09:42,000
protocol with perfect completeness where

258
00:09:42,000 --> 00:09:44,880
alice is costco at bob's quantum

259
00:09:44,880 --> 00:09:47,040
and if square complexity would be order

260
00:09:47,040 --> 00:09:49,279
d squared

261
00:09:49,279 --> 00:09:50,399
and in fact

262
00:09:50,399 --> 00:09:52,240
the attack is less than

263
00:09:52,240 --> 00:09:55,680
but the analysis is different

264
00:09:56,240 --> 00:09:58,560
so since l is still classical we can

265
00:09:58,560 --> 00:10:00,320
still talk about her query set and we

266
00:10:00,320 --> 00:10:03,680
can initially sample her view

267
00:10:03,680 --> 00:10:05,920
and our proof was inspired by xander's

268
00:10:05,920 --> 00:10:08,720
compressed oracle technique

269
00:10:08,720 --> 00:10:10,560
and here's an overview

270
00:10:10,560 --> 00:10:12,800
so we'll first augment an additional

271
00:10:12,800 --> 00:10:15,040
oracle register that starts from uniform

272
00:10:15,040 --> 00:10:17,680
superposition in a computational basis

273
00:10:17,680 --> 00:10:20,320
which is the zero in a fourier basis

274
00:10:20,320 --> 00:10:22,320
and then we will delay the sampling of

275
00:10:22,320 --> 00:10:24,480
the oracle and keep it and keep it in

276
00:10:24,480 --> 00:10:27,200
superposition

277
00:10:27,200 --> 00:10:29,440
and next we will view the oracle in a

278
00:10:29,440 --> 00:10:30,800
fourier basis

279
00:10:30,800 --> 00:10:33,120
then magic will happen

280
00:10:33,120 --> 00:10:35,360
you will somehow record the queries made

281
00:10:35,360 --> 00:10:38,160
by the algorithm

282
00:10:38,480 --> 00:10:40,079
so in a complete in a computational

283
00:10:40,079 --> 00:10:42,560
basis the oracle register

284
00:10:42,560 --> 00:10:44,959
is true stable but when we flip it

285
00:10:44,959 --> 00:10:47,680
around and view it in the fourier basis

286
00:10:47,680 --> 00:10:50,880
it will become database

287
00:10:50,880 --> 00:10:53,519
and by the size of b we mean the number

288
00:10:53,519 --> 00:10:57,040
of non-zero entries in d

289
00:10:57,120 --> 00:11:00,320
so there's an important observation

290
00:11:00,320 --> 00:11:01,920
the final state of any declaring

291
00:11:01,920 --> 00:11:05,120
algorithm will be of the following form

292
00:11:05,120 --> 00:11:07,279
so here w means

293
00:11:07,279 --> 00:11:10,000
the algorithm's register and h is the

294
00:11:10,000 --> 00:11:11,600
oracle register

295
00:11:11,600 --> 00:11:14,240
by the content of the oracle register

296
00:11:14,240 --> 00:11:19,040
will be databases of size at most b

297
00:11:19,680 --> 00:11:21,839
and furthermore by different measurement

298
00:11:21,839 --> 00:11:24,880
principle all alice's and bob's internal

299
00:11:24,880 --> 00:11:28,399
measurement can be deferred to the end

300
00:11:28,399 --> 00:11:30,800
so given a transcript and the list we

301
00:11:30,800 --> 00:11:32,399
can define the purified view of the

302
00:11:32,399 --> 00:11:35,200
protocol and this is a pure quantum

303
00:11:35,200 --> 00:11:36,240
state

304
00:11:36,240 --> 00:11:37,760
and i'll divide it in the following

305
00:11:37,760 --> 00:11:40,320
operational way

306
00:11:40,320 --> 00:11:42,079
so first we'll run the protocol in

307
00:11:42,079 --> 00:11:44,320
superposition from scratch and without

308
00:11:44,320 --> 00:11:47,200
doing any measurement

309
00:11:47,200 --> 00:11:49,839
and then the purify view will be the

310
00:11:49,839 --> 00:11:51,680
post measurement state corresponding to

311
00:11:51,680 --> 00:11:53,200
tl

312
00:11:53,200 --> 00:11:55,040
so this will be a quantum state with a

313
00:11:55,040 --> 00:11:57,839
bunch of registers

314
00:11:58,160 --> 00:12:00,480
and here a and b are alice and bob's

315
00:12:00,480 --> 00:12:01,920
register

316
00:12:01,920 --> 00:12:04,480
and hql means the oracle register

317
00:12:04,480 --> 00:12:06,959
corresponding to ql

318
00:12:06,959 --> 00:12:08,880
and the edge negate ql

319
00:12:08,880 --> 00:12:10,959
means the oracle register corresponding

320
00:12:10,959 --> 00:12:12,880
a complement of ql

321
00:12:12,880 --> 00:12:16,880
and it also has a transcript register

322
00:12:18,079 --> 00:12:20,320
and without loss of generality we can

323
00:12:20,320 --> 00:12:22,480
assume bob measured all his qubits at

324
00:12:22,480 --> 00:12:24,320
the end

325
00:12:24,320 --> 00:12:26,320
so the measurement outcome b and the

326
00:12:26,320 --> 00:12:28,720
transcript t can be seen as the viewers

327
00:12:28,720 --> 00:12:29,839
of bob

328
00:12:29,839 --> 00:12:31,360
because because they are all the

329
00:12:31,360 --> 00:12:33,200
information that bob can learn during

330
00:12:33,200 --> 00:12:35,839
the protocol

331
00:12:35,920 --> 00:12:39,040
so for every possible outcome a and b

332
00:12:39,040 --> 00:12:42,320
we will consider the following state

333
00:12:42,320 --> 00:12:44,959
and this state is obtained by fixing a

334
00:12:44,959 --> 00:12:47,600
and b in the purified view and leaving

335
00:12:47,600 --> 00:12:48,800
only the

336
00:12:48,800 --> 00:12:50,959
oracle register

337
00:12:50,959 --> 00:12:53,760
and this stage is important because

338
00:12:53,760 --> 00:12:54,880
by measuring this state in a

339
00:12:54,880 --> 00:12:57,120
computational basis it will give you the

340
00:12:57,120 --> 00:12:59,680
oracles that are possible to generate

341
00:12:59,680 --> 00:13:02,079
the outcomes a and b as well as the

342
00:13:02,079 --> 00:13:03,440
transcript t

343
00:13:03,440 --> 00:13:05,519
and at the same time they are consistent

344
00:13:05,519 --> 00:13:08,560
with the list l

345
00:13:08,639 --> 00:13:11,680
and we'll let d max to be the database

346
00:13:11,680 --> 00:13:13,519
that has the most non-zero entries in

347
00:13:13,519 --> 00:13:15,440
this state

348
00:13:15,440 --> 00:13:17,600
and this will be the quantum analog of

349
00:13:17,600 --> 00:13:19,040
the query set

350
00:13:19,040 --> 00:13:22,800
qa union could be minus ql

351
00:13:23,040 --> 00:13:25,440
so in a similar spirit

352
00:13:25,440 --> 00:13:27,600
if alice's current set in the fake view

353
00:13:27,600 --> 00:13:29,519
and bmx are disjoint

354
00:13:29,519 --> 00:13:31,760
then we can show that there will exist a

355
00:13:31,760 --> 00:13:34,079
full oracle that is consistent with the

356
00:13:34,079 --> 00:13:37,920
real execution and errors effect view

357
00:13:37,920 --> 00:13:40,320
so again by perfect completeness if we

358
00:13:40,320 --> 00:13:43,360
will find the alice's key

359
00:13:43,600 --> 00:13:45,519
it will also have a remark

360
00:13:45,519 --> 00:13:47,440
request key itel construct a simple

361
00:13:47,440 --> 00:13:49,360
attack on key agreements with favorite

362
00:13:49,360 --> 00:13:50,720
companies

363
00:13:50,720 --> 00:13:52,959
but so far we do now know whether their

364
00:13:52,959 --> 00:13:55,279
attack can be generalized to this

365
00:13:55,279 --> 00:13:57,680
setting

366
00:13:58,399 --> 00:14:00,079
and next

367
00:14:00,079 --> 00:14:02,480
here's here's our second result

368
00:14:02,480 --> 00:14:04,160
we can conditionally break every key

369
00:14:04,160 --> 00:14:06,320
agreement with perfect companies

370
00:14:06,320 --> 00:14:09,120
when s and bob are both quantum

371
00:14:09,120 --> 00:14:10,079
so

372
00:14:10,079 --> 00:14:12,399
in particular we propose a parametrized

373
00:14:12,399 --> 00:14:14,480
conjecture about low degree and the low

374
00:14:14,480 --> 00:14:16,800
influence polynomials and it will imply

375
00:14:16,800 --> 00:14:19,760
a polyquery attack

376
00:14:19,760 --> 00:14:21,519
and here's how we define

377
00:14:21,519 --> 00:14:23,600
a quantum heavy query

378
00:14:23,600 --> 00:14:26,240
so until intuitively the zero in a

379
00:14:26,240 --> 00:14:28,800
fourier basis somehow reflects the

380
00:14:28,800 --> 00:14:31,360
algorithms ignorance on that entry

381
00:14:31,360 --> 00:14:33,279
because the fourier zero

382
00:14:33,279 --> 00:14:35,360
is uniformly random in a computational

383
00:14:35,360 --> 00:14:36,720
basis

384
00:14:36,720 --> 00:14:38,639
so motivated by this

385
00:14:38,639 --> 00:14:40,480
here's here's how we define a quantum

386
00:14:40,480 --> 00:14:42,880
epsilon heavy query

387
00:14:42,880 --> 00:14:45,519
so for a purify view of the protocol

388
00:14:45,519 --> 00:14:47,600
we say a point in the domain is a

389
00:14:47,600 --> 00:14:49,760
quantum epsilon heavy query

390
00:14:49,760 --> 00:14:51,600
if the following holds

391
00:14:51,600 --> 00:14:53,680
so this this means

392
00:14:53,680 --> 00:14:55,920
pi x is the projection onto the non-zero

393
00:14:55,920 --> 00:14:58,240
elements which acts on the x entry of

394
00:14:58,240 --> 00:14:59,680
the database

395
00:14:59,680 --> 00:15:02,079
so i will translate in words so this

396
00:15:02,079 --> 00:15:02,880
means

397
00:15:02,880 --> 00:15:05,120
the probability of obtaining non-zero

398
00:15:05,120 --> 00:15:07,360
outcomes by measuring the x entry in the

399
00:15:07,360 --> 00:15:11,959
fourier basis is at least epsilon

400
00:15:12,720 --> 00:15:15,600
and then i will introduce our attack

401
00:15:15,600 --> 00:15:17,760
so we'll assume the key is one bit and

402
00:15:17,760 --> 00:15:20,560
it is fine for proving negative result

403
00:15:20,560 --> 00:15:22,480
because if alice and bob cannot even

404
00:15:22,480 --> 00:15:24,399
agree on a bit then of course they

405
00:15:24,399 --> 00:15:26,720
cannot agree on a key

406
00:15:26,720 --> 00:15:29,199
so here's if's attack

407
00:15:29,199 --> 00:15:32,160
should still initialize an empty list

408
00:15:32,160 --> 00:15:33,120
and then

409
00:15:33,120 --> 00:15:35,120
whenever there's a quantum heavy query

410
00:15:35,120 --> 00:15:37,440
that is not yet in the list

411
00:15:37,440 --> 00:15:39,120
if we'll go ahead and create that point

412
00:15:39,120 --> 00:15:41,839
classically and get the answer

413
00:15:41,839 --> 00:15:44,800
and then sure updates the pyramid view

414
00:15:44,800 --> 00:15:47,360
by computing the description of the

415
00:15:47,360 --> 00:15:49,279
post measurement state corresponding to

416
00:15:49,279 --> 00:15:51,920
this query ends up here

417
00:15:51,920 --> 00:15:54,399
and where when there is no such point

418
00:15:54,399 --> 00:15:55,279
sure

419
00:15:55,279 --> 00:15:57,600
sure outputs the more likely key bit in

420
00:15:57,600 --> 00:16:00,399
the purified view

421
00:16:00,800 --> 00:16:03,199
and we can show that if kang if square

422
00:16:03,199 --> 00:16:08,079
complexity would be order d over epsilon

423
00:16:08,079 --> 00:16:10,399
and here's the conjecture that we relied

424
00:16:10,399 --> 00:16:11,120
on

425
00:16:11,120 --> 00:16:12,880
and we call it the polynomial

426
00:16:12,880 --> 00:16:15,440
compatibility conjecture or pcc for

427
00:16:15,440 --> 00:16:16,560
short

428
00:16:16,560 --> 00:16:18,959
so we can just show that there exists an

429
00:16:18,959 --> 00:16:20,720
inverse polynomial delta

430
00:16:20,720 --> 00:16:22,560
such that for any

431
00:16:22,560 --> 00:16:25,040
non-negative integer n and d

432
00:16:25,040 --> 00:16:26,959
and the distributions

433
00:16:26,959 --> 00:16:29,360
f and g over multi-linear multi-linear

434
00:16:29,360 --> 00:16:30,480
polynomials

435
00:16:30,480 --> 00:16:33,680
where each of them are of degree at most

436
00:16:33,680 --> 00:16:34,800
d

437
00:16:34,800 --> 00:16:38,000
and with variables x1 up to xn

438
00:16:38,000 --> 00:16:40,160
where each of them are either plus 1 or

439
00:16:40,160 --> 00:16:42,320
-1

440
00:16:42,320 --> 00:16:45,360
and every polynomial is with unit l2

441
00:16:45,360 --> 00:16:46,720
norm

442
00:16:46,720 --> 00:16:49,680
and furthermore the distribution f and g

443
00:16:49,680 --> 00:16:52,000
satisfy the low average influence

444
00:16:52,000 --> 00:16:53,199
condition

445
00:16:53,199 --> 00:16:56,959
that is for for every coordinate i

446
00:16:56,959 --> 00:16:59,759
the average influence are at most delta

447
00:16:59,759 --> 00:17:01,759
of t

448
00:17:01,759 --> 00:17:02,720
and then

449
00:17:02,720 --> 00:17:04,880
there will exist functions

450
00:17:04,880 --> 00:17:08,079
f and g in a support and an argument x

451
00:17:08,079 --> 00:17:10,799
such that f of x and g of x are both

452
00:17:10,799 --> 00:17:13,039
non-zero

453
00:17:13,039 --> 00:17:15,520
and we can show that this would imply

454
00:17:15,520 --> 00:17:19,559
the success of our attempt

455
00:17:19,760 --> 00:17:21,679
and if it is true

456
00:17:21,679 --> 00:17:25,839
if query complexity would be probably d

457
00:17:25,839 --> 00:17:27,599
but unfortunately

458
00:17:27,599 --> 00:17:29,760
we can only prove this conjecture when

459
00:17:29,760 --> 00:17:31,679
the influences are exponentially small

460
00:17:31,679 --> 00:17:33,200
in b

461
00:17:33,200 --> 00:17:35,039
so if square complexity would be

462
00:17:35,039 --> 00:17:37,919
exponential in b

463
00:17:39,200 --> 00:17:41,440
so here's our third result

464
00:17:41,440 --> 00:17:42,960
we can break every key agreement with

465
00:17:42,960 --> 00:17:45,120
perfect completeness where else and bob

466
00:17:45,120 --> 00:17:47,600
are both quantum and they both

467
00:17:47,600 --> 00:17:51,199
make a constant number of queries

468
00:17:52,240 --> 00:17:53,360
and finally

469
00:17:53,360 --> 00:17:55,280
since our attack only makes classical

470
00:17:55,280 --> 00:17:57,440
queries we study whether we can extend

471
00:17:57,440 --> 00:17:59,280
our attack to the imperfect complaint in

472
00:17:59,280 --> 00:18:00,400
this case

473
00:18:00,400 --> 00:18:02,960
but we have the following barrier result

474
00:18:02,960 --> 00:18:05,200
so we found that if the famous errands

475
00:18:05,200 --> 00:18:07,200
and bonus contracture is false then

476
00:18:07,200 --> 00:18:09,280
there do exist a key agreement with

477
00:18:09,280 --> 00:18:11,520
imperfect companies against classical

478
00:18:11,520 --> 00:18:13,360
eavesdropper

479
00:18:13,360 --> 00:18:14,480
and this means

480
00:18:14,480 --> 00:18:16,799
if we want to obtain the separations

481
00:18:16,799 --> 00:18:18,960
in the imperfect companies case then we

482
00:18:18,960 --> 00:18:21,200
have to either prove a conjecture

483
00:18:21,200 --> 00:18:23,440
or we have to construct an attack that

484
00:18:23,440 --> 00:18:26,559
makes quantum queries

485
00:18:27,120 --> 00:18:30,160
and here are the open problems so first

486
00:18:30,160 --> 00:18:32,320
of course we want to prove or disrupt or

487
00:18:32,320 --> 00:18:34,400
disapprove our conjecture

488
00:18:34,400 --> 00:18:36,000
and perhaps the more interesting one is

489
00:18:36,000 --> 00:18:38,799
that can we construct an attack that

490
00:18:38,799 --> 00:18:40,840
really uses content

491
00:18:40,840 --> 00:18:42,960
queries so maybe we can prove the

492
00:18:42,960 --> 00:18:45,760
impossibility in the imperfect companies

493
00:18:45,760 --> 00:18:48,000
case

494
00:18:48,960 --> 00:18:51,039
and that's all my talk thanks for your

495
00:18:51,039 --> 00:18:54,039
attention

496
00:18:59,280 --> 00:19:01,760
time for question if you have a question

497
00:19:01,760 --> 00:19:05,559
please come to the microphones

498
00:19:18,400 --> 00:19:21,360
okay i have a one i have one question

499
00:19:21,360 --> 00:19:24,640
so this is the impossibility uh

500
00:19:24,640 --> 00:19:26,720
of uh agreement from

501
00:19:26,720 --> 00:19:28,000
uh

502
00:19:28,000 --> 00:19:30,880
quantum random oracles uh or maybe of

503
00:19:30,880 --> 00:19:33,919
one function uh so there are many uh

504
00:19:33,919 --> 00:19:38,000
classical impossibilities out uh like uh

505
00:19:38,000 --> 00:19:40,960
impossible impossibility result of ibe

506
00:19:40,960 --> 00:19:43,360
from pk something like that uh

507
00:19:43,360 --> 00:19:45,440
it is uh

508
00:19:45,440 --> 00:19:48,799
does your technique uh is a technique uh

509
00:19:48,799 --> 00:19:53,679
extend to other setting uh like also

510
00:19:53,679 --> 00:19:55,200
i don't really think about the case of

511
00:19:55,200 --> 00:19:58,400
ibe but we do have to think about the

512
00:19:58,400 --> 00:20:01,200
case of non-interactive commitment and

513
00:20:01,200 --> 00:20:02,400
we found that

514
00:20:02,400 --> 00:20:04,400
maybe we can extend our technique to

515
00:20:04,400 --> 00:20:06,720
that case yeah

516
00:20:06,720 --> 00:20:08,799
next

517
00:20:08,799 --> 00:20:11,918
other questions

518
00:20:14,480 --> 00:20:18,919
we have much time for question

519
00:20:28,240 --> 00:20:29,200
no

520
00:20:29,200 --> 00:20:32,919
okay let's thanks

521
00:20:48,799 --> 00:20:53,360
next talk is online talk

522
00:20:54,320 --> 00:20:55,919
okay so

523
00:20:55,919 --> 00:20:56,799
the

524
00:20:56,799 --> 00:20:59,600
second talk is succinct classical

525
00:20:59,600 --> 00:21:02,400
verification of quantum computation

526
00:21:02,400 --> 00:21:06,480
by james basic yeah thai mankind alex

527
00:21:06,480 --> 00:21:10,640
lombardi per mima julio malbag malabolta

528
00:21:10,640 --> 00:21:14,720
vinod baikon tennison thomas vidiq lisan

529
00:21:14,720 --> 00:21:18,880
and alex will give a talk

530
00:21:20,159 --> 00:21:21,520
we'll start a few minutes early that's

531
00:21:21,520 --> 00:21:23,840
the plan

532
00:21:23,840 --> 00:21:25,039
we can hear you

533
00:21:25,039 --> 00:21:27,200
yes you want me to start now

534
00:21:27,200 --> 00:21:28,159
yep

535
00:21:28,159 --> 00:21:30,159
all right hey everyone uh thanks for

536
00:21:30,159 --> 00:21:32,240
coming thanks for the introduction uh

537
00:21:32,240 --> 00:21:33,760
i'll be presenting joint work with this

538
00:21:33,760 --> 00:21:36,559
very long list of excellent co-authors

539
00:21:36,559 --> 00:21:38,320
so let's get started

540
00:21:38,320 --> 00:21:41,120
uh so the setting for our work is that

541
00:21:41,120 --> 00:21:44,080
of verifiable computation so in this

542
00:21:44,080 --> 00:21:46,559
setting we have some form of computation

543
00:21:46,559 --> 00:21:48,720
which we're representing here by the

544
00:21:48,720 --> 00:21:50,640
problem of deciding whether some string

545
00:21:50,640 --> 00:21:52,960
x is in some language l

546
00:21:52,960 --> 00:21:55,360
uh and in an in our setting we have a

547
00:21:55,360 --> 00:21:57,679
verifier who wants to delegate this

548
00:21:57,679 --> 00:22:00,159
computation to approver

549
00:22:00,159 --> 00:22:02,000
so the prover and verifier exchange some

550
00:22:02,000 --> 00:22:04,240
messages in an interactive protocol and

551
00:22:04,240 --> 00:22:06,000
at the end of the protocol the verifier

552
00:22:06,000 --> 00:22:08,159
is supposed to decide whether or not x

553
00:22:08,159 --> 00:22:09,520
is an l

554
00:22:09,520 --> 00:22:12,000
and in order for such a proof system to

555
00:22:12,000 --> 00:22:13,360
be useful

556
00:22:13,360 --> 00:22:15,760
uh what we're looking for is a protocol

557
00:22:15,760 --> 00:22:18,240
that makes verifying this

558
00:22:18,240 --> 00:22:21,039
property easier than deciding whether x

559
00:22:21,039 --> 00:22:24,400
is an l on your own easier in some sense

560
00:22:24,400 --> 00:22:26,640
so uh

561
00:22:26,640 --> 00:22:28,720
there are two basic properties that you

562
00:22:28,720 --> 00:22:30,799
always want to hold in such a setting uh

563
00:22:30,799 --> 00:22:32,559
the first is completeness which is that

564
00:22:32,559 --> 00:22:34,799
if the statement is true if x is in l

565
00:22:34,799 --> 00:22:36,960
and both parties are honest the verifier

566
00:22:36,960 --> 00:22:38,159
should accept

567
00:22:38,159 --> 00:22:40,159
and the second is soundness which says

568
00:22:40,159 --> 00:22:41,679
that if the statement is false if x is

569
00:22:41,679 --> 00:22:44,400
not an l then no matter what efficient

570
00:22:44,400 --> 00:22:47,280
strategy uh the prover decides to use

571
00:22:47,280 --> 00:22:48,480
they don't have to follow the protocol

572
00:22:48,480 --> 00:22:50,720
no matter what they do uh the verifier

573
00:22:50,720 --> 00:22:52,559
should almost always reject they should

574
00:22:52,559 --> 00:22:55,039
accept only with negligible probability

575
00:22:55,039 --> 00:22:57,679
uh so the soundness that we're talking

576
00:22:57,679 --> 00:23:00,240
about here is only computational uh an

577
00:23:00,240 --> 00:23:01,760
unbounded proofer might be able to cheat

578
00:23:01,760 --> 00:23:04,640
but a bounded prover cannot

579
00:23:04,640 --> 00:23:07,440
uh so this is the uh this is the setting

580
00:23:07,440 --> 00:23:09,919
and classically uh you know this has

581
00:23:09,919 --> 00:23:11,520
been studied for a long time you know

582
00:23:11,520 --> 00:23:13,440
starting from two very influential works

583
00:23:13,440 --> 00:23:15,120
of killian and mackelly

584
00:23:15,120 --> 00:23:16,799
and they constructed what we now call

585
00:23:16,799 --> 00:23:19,760
succinct arguments for np so they showed

586
00:23:19,760 --> 00:23:22,559
that every np language has a very

587
00:23:22,559 --> 00:23:24,960
efficient proof system in the sense that

588
00:23:24,960 --> 00:23:26,720
there is a protocol where the

589
00:23:26,720 --> 00:23:28,080
communication

590
00:23:28,080 --> 00:23:30,880
is poly log t where t is the

591
00:23:30,880 --> 00:23:32,720
non-deterministic verification time for

592
00:23:32,720 --> 00:23:34,080
the language

593
00:23:34,080 --> 00:23:36,080
and the protocols verification time is

594
00:23:36,080 --> 00:23:38,799
again poly log t and also some fixed

595
00:23:38,799 --> 00:23:40,720
polynomial in the input length which is

596
00:23:40,720 --> 00:23:42,400
unavoidable because you need to at least

597
00:23:42,400 --> 00:23:44,080
read the input

598
00:23:44,080 --> 00:23:46,080
so this is basically as efficient as you

599
00:23:46,080 --> 00:23:48,000
could hope for

600
00:23:48,000 --> 00:23:49,440
and

601
00:23:49,440 --> 00:23:51,279
certainly not something that you could

602
00:23:51,279 --> 00:23:53,520
achieve for general np languages with a

603
00:23:53,520 --> 00:23:56,559
statistically sound protocol for example

604
00:23:56,559 --> 00:23:58,880
so this is the classical setting uh but

605
00:23:58,880 --> 00:24:01,279
today we're talking about something

606
00:24:01,279 --> 00:24:04,080
different we're talking about classical

607
00:24:04,080 --> 00:24:06,960
verification for quantum computation so

608
00:24:06,960 --> 00:24:09,600
here the notion of uh

609
00:24:09,600 --> 00:24:12,640
the verification being easier than comp

610
00:24:12,640 --> 00:24:14,640
than computing

611
00:24:14,640 --> 00:24:16,640
is different from just

612
00:24:16,640 --> 00:24:19,760
the question of verification time etc uh

613
00:24:19,760 --> 00:24:20,640
here

614
00:24:20,640 --> 00:24:23,360
uh we're requiring that the verifier is

615
00:24:23,360 --> 00:24:26,080
entirely classical even though deciding

616
00:24:26,080 --> 00:24:28,080
the language requires running a quantum

617
00:24:28,080 --> 00:24:30,159
computer so so in this model the prover

618
00:24:30,159 --> 00:24:32,159
can run a quantum computer the verifier

619
00:24:32,159 --> 00:24:33,360
cannot

620
00:24:33,360 --> 00:24:35,039
and so in particular the protocol

621
00:24:35,039 --> 00:24:37,200
transcript should be entirely classical

622
00:24:37,200 --> 00:24:39,840
and the verification decision should be

623
00:24:39,840 --> 00:24:41,919
uh computable by a classical algorithm

624
00:24:41,919 --> 00:24:44,480
efficient classical algorithm

625
00:24:44,480 --> 00:24:47,520
so so this is the setting for today

626
00:24:47,520 --> 00:24:49,600
uh and this is a highly non-trivial

627
00:24:49,600 --> 00:24:53,520
problem even in the case where uh

628
00:24:53,520 --> 00:24:54,960
where you don't require any form of

629
00:24:54,960 --> 00:24:58,320
succinctness or or uh or time efficiency

630
00:24:58,320 --> 00:25:01,200
uh so in a breakthrough work of mahadev

631
00:25:01,200 --> 00:25:04,799
uh it was shown that this is possible

632
00:25:04,799 --> 00:25:06,640
like that in particular assuming that

633
00:25:06,640 --> 00:25:08,960
the learning with errors problem is hard

634
00:25:08,960 --> 00:25:11,919
even against quantum attacks uh there is

635
00:25:11,919 --> 00:25:15,120
a protocol for classically verifying any

636
00:25:15,120 --> 00:25:18,400
efficient quantum computation

637
00:25:18,400 --> 00:25:19,360
so

638
00:25:19,360 --> 00:25:20,720
given everything that i've said you can

639
00:25:20,720 --> 00:25:21,840
imagine what the question is the

640
00:25:21,840 --> 00:25:24,559
question is can we get the best of both

641
00:25:24,559 --> 00:25:27,120
of the two efficiency guarantees that i

642
00:25:27,120 --> 00:25:30,960
just described can we get a succinct and

643
00:25:30,960 --> 00:25:34,400
easy to verify interactive protocol for

644
00:25:34,400 --> 00:25:37,200
arbitrary quantum computation

645
00:25:37,200 --> 00:25:38,880
and and the answer is that we show that

646
00:25:38,880 --> 00:25:39,919
you can

647
00:25:39,919 --> 00:25:41,679
so in particular we show that assuming

648
00:25:41,679 --> 00:25:43,520
that lwe is

649
00:25:43,520 --> 00:25:45,679
is a post quantum and additionally

650
00:25:45,679 --> 00:25:46,880
assuming the existence of

651
00:25:46,880 --> 00:25:48,720
indistinguishability obfuscation that is

652
00:25:48,720 --> 00:25:51,520
post quantum uh we build succinct

653
00:25:51,520 --> 00:25:53,760
arguments for all quantum computation

654
00:25:53,760 --> 00:25:56,880
and the the result is is quite analogous

655
00:25:56,880 --> 00:26:00,000
to killian macaulay that is for every

656
00:26:00,000 --> 00:26:03,679
language in uh the quantum mer quantum

657
00:26:03,679 --> 00:26:05,600
merlin arthur complexity class which is

658
00:26:05,600 --> 00:26:08,159
the quantum analog of np uh you get a

659
00:26:08,159 --> 00:26:10,559
protocol where the communication is poly

660
00:26:10,559 --> 00:26:12,559
log t where t is the analog of the

661
00:26:12,559 --> 00:26:14,720
non-deterministic verification time

662
00:26:14,720 --> 00:26:16,480
and the protocol verification time is

663
00:26:16,480 --> 00:26:19,440
poly log t and input length

664
00:26:19,440 --> 00:26:23,039
so basically exactly what you would want

665
00:26:23,039 --> 00:26:26,240
uh so in a little more detail uh to

666
00:26:26,240 --> 00:26:28,080
make sure i specify the result carefully

667
00:26:28,080 --> 00:26:31,520
enough uh if the original computation is

668
00:26:31,520 --> 00:26:35,520
in bqp this is the quantum analog of p

669
00:26:35,520 --> 00:26:38,799
i we we get exactly what i just said

670
00:26:38,799 --> 00:26:41,360
uh where the prover is also efficient

671
00:26:41,360 --> 00:26:43,279
the prover runs in bqp

672
00:26:43,279 --> 00:26:46,240
uh when you generalize to qma uh the

673
00:26:46,240 --> 00:26:49,120
prover is also efficient but only given

674
00:26:49,120 --> 00:26:51,520
some polynomial number of copies of the

675
00:26:51,520 --> 00:26:54,080
original witness state

676
00:26:54,080 --> 00:26:56,559
uh and yeah also a lot of protocols in

677
00:26:56,559 --> 00:26:58,400
the quantum setting have this uh have

678
00:26:58,400 --> 00:27:00,240
this drawback and it's an interesting

679
00:27:00,240 --> 00:27:02,000
open question to understand whether this

680
00:27:02,000 --> 00:27:04,799
is necessary

681
00:27:05,120 --> 00:27:07,279
so we have some auxiliary results in

682
00:27:07,279 --> 00:27:09,760
addition to this main result so first of

683
00:27:09,760 --> 00:27:12,559
all uh this qma protocol can be made

684
00:27:12,559 --> 00:27:14,400
zero knowledge if you want so in

685
00:27:14,400 --> 00:27:15,520
addition to all the things that i've

686
00:27:15,520 --> 00:27:17,760
said the verifier even if they cheats

687
00:27:17,760 --> 00:27:18,640
also

688
00:27:18,640 --> 00:27:21,600
still cannot learn anything at all about

689
00:27:21,600 --> 00:27:23,840
uh the qma witness

690
00:27:23,840 --> 00:27:24,799
uh

691
00:27:24,799 --> 00:27:26,799
additionally i

692
00:27:26,799 --> 00:27:29,360
just sort of as a byproduct of how we

693
00:27:29,360 --> 00:27:32,159
construct them uh the protocols can be

694
00:27:32,159 --> 00:27:35,120
made public coin so the verifier sends

695
00:27:35,120 --> 00:27:36,240
just uh

696
00:27:36,240 --> 00:27:38,880
random strings in every round except for

697
00:27:38,880 --> 00:27:40,960
the very first message of the protocol

698
00:27:40,960 --> 00:27:42,640
which is private coin

699
00:27:42,640 --> 00:27:45,760
uh and this means that we can also

700
00:27:45,760 --> 00:27:47,520
compress the protocol into a

701
00:27:47,520 --> 00:27:50,000
non-interactive protocol in the quantum

702
00:27:50,000 --> 00:27:51,279
random oracle model using the

703
00:27:51,279 --> 00:27:53,279
theatrometer heuristic

704
00:27:53,279 --> 00:27:54,240
so

705
00:27:54,240 --> 00:27:56,399
this means that we get a

706
00:27:56,399 --> 00:27:57,600
succinct

707
00:27:57,600 --> 00:27:59,840
or a form of succinct non-interactive

708
00:27:59,840 --> 00:28:03,600
arguments for qma uh where uh like in

709
00:28:03,600 --> 00:28:06,640
the in the quantum random oracle model

710
00:28:06,640 --> 00:28:09,440
so these are our our main results

711
00:28:09,440 --> 00:28:10,240
um

712
00:28:10,240 --> 00:28:11,679
before getting into them i should

713
00:28:11,679 --> 00:28:14,559
mention one one related work besides the

714
00:28:14,559 --> 00:28:17,039
original mahadev construction

715
00:28:17,039 --> 00:28:19,760
there is a result by cheng and yamakawa

716
00:28:19,760 --> 00:28:22,320
from tcc 2020

717
00:28:22,320 --> 00:28:24,640
where they construct also a form of

718
00:28:24,640 --> 00:28:26,480
succinct non-interactive arguments for

719
00:28:26,480 --> 00:28:28,559
quantum computation

720
00:28:28,559 --> 00:28:30,480
but they require

721
00:28:30,480 --> 00:28:31,200
a

722
00:28:31,200 --> 00:28:34,799
very long uh trusted setup phase uh that

723
00:28:34,799 --> 00:28:37,360
generates a long common reference string

724
00:28:37,360 --> 00:28:38,880
for the approver to use along with the

725
00:28:38,880 --> 00:28:41,279
secret verification key for the verifier

726
00:28:41,279 --> 00:28:42,080
uh

727
00:28:42,080 --> 00:28:45,120
and on top of that they also make use of

728
00:28:45,120 --> 00:28:47,840
a hash function similar to uh the hash

729
00:28:47,840 --> 00:28:48,799
function we're using in our

730
00:28:48,799 --> 00:28:51,679
non-interactive protocol uh but

731
00:28:51,679 --> 00:28:54,240
although you analyze security in the

732
00:28:54,240 --> 00:28:56,320
random oracle model in their protocol

733
00:28:56,320 --> 00:28:58,720
the even the honest parties the prover

734
00:28:58,720 --> 00:29:01,039
and the verifier actually

735
00:29:01,039 --> 00:29:04,000
use explicit code uh for the hash

736
00:29:04,000 --> 00:29:06,000
function h and violate the random oracle

737
00:29:06,000 --> 00:29:08,000
models like underlying assumptions so

738
00:29:08,000 --> 00:29:10,480
this is a heuristic construction

739
00:29:10,480 --> 00:29:12,880
uh so on the flip side what we're able

740
00:29:12,880 --> 00:29:15,120
to do in this work is first of all

741
00:29:15,120 --> 00:29:17,440
by allowing interaction we're able to

742
00:29:17,440 --> 00:29:20,080
construct a protocol on the plane model

743
00:29:20,080 --> 00:29:22,399
with no setup whatsoever

744
00:29:22,399 --> 00:29:24,000
and then for the

745
00:29:24,000 --> 00:29:26,320
quote unquote non-interactive protocol i

746
00:29:26,320 --> 00:29:28,080
say quote-unquote because they're still

747
00:29:28,080 --> 00:29:28,960
uh

748
00:29:28,960 --> 00:29:32,080
they're still a short-trusted setup uh

749
00:29:32,080 --> 00:29:33,840
but uh but in the non-interactive

750
00:29:33,840 --> 00:29:37,360
protocol uh we have only uh like uh uh

751
00:29:37,360 --> 00:29:39,520
you know a succinct efficient trusted

752
00:29:39,520 --> 00:29:41,520
setup and then a

753
00:29:41,520 --> 00:29:44,559
random oracle hash function

754
00:29:44,559 --> 00:29:46,640
so so you might ask well what what

755
00:29:46,640 --> 00:29:49,360
changed from two years ago why why

756
00:29:49,360 --> 00:29:51,279
what's enabling us to get a better

757
00:29:51,279 --> 00:29:52,960
result

758
00:29:52,960 --> 00:29:55,279
and there are a couple of

759
00:29:55,279 --> 00:29:57,279
uh like aspects to this but the one i

760
00:29:57,279 --> 00:29:59,520
want to highlight here is that this this

761
00:29:59,520 --> 00:30:02,159
prior work is making essentially generic

762
00:30:02,159 --> 00:30:05,679
usage of the original mahadev

763
00:30:05,679 --> 00:30:07,520
non-succinct protocol and they want to

764
00:30:07,520 --> 00:30:10,480
sort of generically convert it into a

765
00:30:10,480 --> 00:30:12,080
succinct protocol

766
00:30:12,080 --> 00:30:13,919
and there are some there seem to be some

767
00:30:13,919 --> 00:30:16,159
inherent limitations to

768
00:30:16,159 --> 00:30:17,679
you know what you can do if you take an

769
00:30:17,679 --> 00:30:19,840
approach like this and on the flip side

770
00:30:19,840 --> 00:30:22,799
what we do is we look very deep

771
00:30:22,799 --> 00:30:24,960
into this black box and we sort of prove

772
00:30:24,960 --> 00:30:27,279
things from scratch and this

773
00:30:27,279 --> 00:30:29,440
enables us to get these uh these better

774
00:30:29,440 --> 00:30:31,679
results

775
00:30:31,679 --> 00:30:34,559
so uh and so i'll

776
00:30:34,559 --> 00:30:36,320
soon show you a little bit about our

777
00:30:36,320 --> 00:30:38,399
techniques but before going there let me

778
00:30:38,399 --> 00:30:40,000
mention two open problems that i think

779
00:30:40,000 --> 00:30:42,159
would be fun to solve

780
00:30:42,159 --> 00:30:45,039
one is do we need obfuscation can you

781
00:30:45,039 --> 00:30:48,080
rely on lwe alone of course you could do

782
00:30:48,080 --> 00:30:49,279
that if you could build obfuscations

783
00:30:49,279 --> 00:30:50,960
from lwe but let's leave that aside for

784
00:30:50,960 --> 00:30:54,240
a second um so in our paper we managed

785
00:30:54,240 --> 00:30:55,840
to do this

786
00:30:55,840 --> 00:30:58,960
that is avoid obfuscation for the easier

787
00:30:58,960 --> 00:31:01,760
problem of batch verification where the

788
00:31:01,760 --> 00:31:03,600
protocol was succinct only with respect

789
00:31:03,600 --> 00:31:05,200
to the number of instances that you're

790
00:31:05,200 --> 00:31:06,559
batching

791
00:31:06,559 --> 00:31:10,240
but it's open to do this for general qma

792
00:31:10,240 --> 00:31:12,720
or bqp computation

793
00:31:12,720 --> 00:31:13,760
and the second open problem i want to

794
00:31:13,760 --> 00:31:16,799
mention is can we get a protocol that is

795
00:31:16,799 --> 00:31:19,919
publicly verifiable so

796
00:31:19,919 --> 00:31:21,919
all like and this is this is open even

797
00:31:21,919 --> 00:31:24,000
in the uh even in the non-succinct

798
00:31:24,000 --> 00:31:26,559
setting uh all the protocols that we

799
00:31:26,559 --> 00:31:29,200
know uh require the verifier keep some

800
00:31:29,200 --> 00:31:30,960
secret state that they need in order to

801
00:31:30,960 --> 00:31:32,480
make the decision at the end of the

802
00:31:32,480 --> 00:31:33,600
protocol

803
00:31:33,600 --> 00:31:34,399
uh

804
00:31:34,399 --> 00:31:36,799
in our setting it would be nice

805
00:31:36,799 --> 00:31:38,559
it'd be nice to have a publicly

806
00:31:38,559 --> 00:31:40,640
verifiable protocol because then you

807
00:31:40,640 --> 00:31:42,640
would get like a real succinct

808
00:31:42,640 --> 00:31:45,360
non-interactive argument or snark for uh

809
00:31:45,360 --> 00:31:48,080
qma computation which is something that

810
00:31:48,080 --> 00:31:50,000
i imagine you might want and

811
00:31:50,000 --> 00:31:51,200
and that would sort of complete the

812
00:31:51,200 --> 00:31:53,200
picture saying that basically everything

813
00:31:53,200 --> 00:31:55,039
you can do in the classical setting you

814
00:31:55,039 --> 00:31:57,760
can also do in the quantum setting

815
00:31:57,760 --> 00:32:00,480
so here are two nice open problems but

816
00:32:00,480 --> 00:32:01,600
for the rest of the talk i'll give a

817
00:32:01,600 --> 00:32:03,600
sketch of just the main results so just

818
00:32:03,600 --> 00:32:06,880
a succinct uh argument system for

819
00:32:06,880 --> 00:32:09,679
quantum computation

820
00:32:09,679 --> 00:32:11,600
so in a little more detail let me tell

821
00:32:11,600 --> 00:32:13,600
you what we do in this paper

822
00:32:13,600 --> 00:32:16,000
the construction of our protocol can be

823
00:32:16,000 --> 00:32:18,720
broken up into two steps

824
00:32:18,720 --> 00:32:20,960
in the first step which is the main step

825
00:32:20,960 --> 00:32:23,360
we build what i'm calling a laconic

826
00:32:23,360 --> 00:32:25,840
verifier protocol

827
00:32:25,840 --> 00:32:27,519
and by that i just mean that the

828
00:32:27,519 --> 00:32:30,559
verifier to prover communication needs

829
00:32:30,559 --> 00:32:32,399
to be succinct and we've imposed no

830
00:32:32,399 --> 00:32:34,960
further requirements besides this fact

831
00:32:34,960 --> 00:32:37,039
uh and uh so we built such a protocol

832
00:32:37,039 --> 00:32:39,440
from i o and lwe this is the this is the

833
00:32:39,440 --> 00:32:41,600
only place where obfuscation is actually

834
00:32:41,600 --> 00:32:42,799
used

835
00:32:42,799 --> 00:32:45,919
and it's even more localized than that

836
00:32:45,919 --> 00:32:47,919
it's used for a very specific purpose

837
00:32:47,919 --> 00:32:50,240
it's used to come up with some sort of

838
00:32:50,240 --> 00:32:52,720
succinct representation for a large

839
00:32:52,720 --> 00:32:55,279
number of public keys for some public

840
00:32:55,279 --> 00:32:57,679
key scheme so we write down some

841
00:32:57,679 --> 00:32:59,519
primitive that we call succinct batch

842
00:32:59,519 --> 00:33:02,080
key sampling that's uh you know

843
00:33:02,080 --> 00:33:04,240
satisfies the properties that we need in

844
00:33:04,240 --> 00:33:06,000
order to make a security proof go

845
00:33:06,000 --> 00:33:07,919
through and we can so we write down

846
00:33:07,919 --> 00:33:09,919
definition and construction in the paper

847
00:33:09,919 --> 00:33:12,640
and it's but it's quite localized uh and

848
00:33:12,640 --> 00:33:15,039
uh mostly this tool is plugged into a

849
00:33:15,039 --> 00:33:18,159
generic construction uh and then we give

850
00:33:18,159 --> 00:33:19,039
a

851
00:33:19,039 --> 00:33:21,519
new security analysis for uh for this

852
00:33:21,519 --> 00:33:24,640
generic construction of uh classically

853
00:33:24,640 --> 00:33:27,440
verifiable quantum computation uh that

854
00:33:27,440 --> 00:33:29,760
we think is pretty modular and in

855
00:33:29,760 --> 00:33:31,679
particular it generalizes immediately

856
00:33:31,679 --> 00:33:34,000
from the non-succinct to the to the or

857
00:33:34,000 --> 00:33:35,840
the non-laconic verifier to the clonic

858
00:33:35,840 --> 00:33:37,600
verifier setting and we hope the

859
00:33:37,600 --> 00:33:39,279
security analysis will be useful in

860
00:33:39,279 --> 00:33:40,720
other work on

861
00:33:40,720 --> 00:33:43,279
on quantum verification

862
00:33:43,279 --> 00:33:46,159
so this is the main bulk of what we do

863
00:33:46,159 --> 00:33:47,760
the second part to the construction is

864
00:33:47,760 --> 00:33:50,559
that we write down a generic compiler

865
00:33:50,559 --> 00:33:51,519
that

866
00:33:51,519 --> 00:33:54,320
starts with a laconic verifier protocol

867
00:33:54,320 --> 00:33:56,240
it's a public coin laconic verifier

868
00:33:56,240 --> 00:33:57,279
protocol

869
00:33:57,279 --> 00:33:59,760
uh and produces a fully succinct

870
00:33:59,760 --> 00:34:02,080
argument system uh and this uses as a

871
00:34:02,080 --> 00:34:03,679
tool a

872
00:34:03,679 --> 00:34:06,320
strong enough form of post-quantum

873
00:34:06,320 --> 00:34:08,399
succinct arguments for classical

874
00:34:08,399 --> 00:34:09,679
computation

875
00:34:09,679 --> 00:34:12,239
uh which uh some recent work has uh

876
00:34:12,239 --> 00:34:14,480
constructed for us that uh

877
00:34:14,480 --> 00:34:17,520
suffices uh for what we need

878
00:34:17,520 --> 00:34:20,480
so these are the two main steps and i'll

879
00:34:20,480 --> 00:34:22,879
start by sketching the second step

880
00:34:22,879 --> 00:34:24,800
because it's easier

881
00:34:24,800 --> 00:34:27,280
so let's just uh let's think about the

882
00:34:27,280 --> 00:34:30,560
compilation step so imagine that somehow

883
00:34:30,560 --> 00:34:32,639
you were able to construct a protocol

884
00:34:32,639 --> 00:34:34,960
where the verifier was laconic

885
00:34:34,960 --> 00:34:35,760
uh

886
00:34:35,760 --> 00:34:38,239
so as described on the slide and let's

887
00:34:38,239 --> 00:34:40,480
uh so right now we're just

888
00:34:40,480 --> 00:34:41,918
let's just assume that the protocol is

889
00:34:41,918 --> 00:34:43,199
only four messages long it doesn't

890
00:34:43,199 --> 00:34:45,199
really matter what's called alpha one

891
00:34:45,199 --> 00:34:48,399
and alpha two the long potentially long

892
00:34:48,399 --> 00:34:50,079
messages that the prover sends to the

893
00:34:50,079 --> 00:34:52,560
verifier in the protocol

894
00:34:52,560 --> 00:34:55,359
so we would like to convert this into a

895
00:34:55,359 --> 00:34:57,839
fully succinct protocol

896
00:34:57,839 --> 00:34:58,640
i

897
00:34:58,640 --> 00:35:00,800
what i'm about to describe is maybe the

898
00:35:00,800 --> 00:35:03,280
the second thing you would think of

899
00:35:03,280 --> 00:35:05,920
rather than the first thing but uh but

900
00:35:05,920 --> 00:35:06,960
it's uh

901
00:35:06,960 --> 00:35:08,960
it's like a reasonably straightforward

902
00:35:08,960 --> 00:35:10,240
approach

903
00:35:10,240 --> 00:35:12,640
uh so here's here's what you do

904
00:35:12,640 --> 00:35:14,160
uh

905
00:35:14,160 --> 00:35:15,680
every time the approver wants to send

906
00:35:15,680 --> 00:35:17,839
something that's long instead of course

907
00:35:17,839 --> 00:35:19,359
send a hash

908
00:35:19,359 --> 00:35:21,119
of the message instead

909
00:35:21,119 --> 00:35:23,119
so we'll start by running the first two

910
00:35:23,119 --> 00:35:25,520
messages of the uh

911
00:35:25,520 --> 00:35:27,520
of the laconic verifier protocol where

912
00:35:27,520 --> 00:35:29,520
the prover only sends the hash of its

913
00:35:29,520 --> 00:35:30,800
own message

914
00:35:30,800 --> 00:35:32,720
of course now at this point the verifier

915
00:35:32,720 --> 00:35:34,480
doesn't have enough information or the

916
00:35:34,480 --> 00:35:36,240
verifier will not later have enough

917
00:35:36,240 --> 00:35:38,400
information to make a decision

918
00:35:38,400 --> 00:35:39,359
uh

919
00:35:39,359 --> 00:35:40,160
so

920
00:35:40,160 --> 00:35:41,760
uh the verifier is going to need some

921
00:35:41,760 --> 00:35:42,560
help

922
00:35:42,560 --> 00:35:44,800
so at this point and it's crucial that

923
00:35:44,800 --> 00:35:46,240
we do this right now

924
00:35:46,240 --> 00:35:48,480
uh the prover is also going to send a

925
00:35:48,480 --> 00:35:51,200
succinct argument of knowledge of its

926
00:35:51,200 --> 00:35:53,839
message alpha one uh which which means

927
00:35:53,839 --> 00:35:56,480
that uh like uh more formally they send

928
00:35:56,480 --> 00:35:58,160
an argument of knowledge of a hash

929
00:35:58,160 --> 00:36:00,160
inverse of the message that was sent to

930
00:36:00,160 --> 00:36:01,599
the verifier

931
00:36:01,599 --> 00:36:03,520
and i'll explain briefly why it needs to

932
00:36:03,520 --> 00:36:04,720
happen right now but you need to do it

933
00:36:04,720 --> 00:36:05,920
now

934
00:36:05,920 --> 00:36:08,160
so only after

935
00:36:08,160 --> 00:36:10,400
you send this argument of knowledge

936
00:36:10,400 --> 00:36:13,280
the verifier then sends the next message

937
00:36:13,280 --> 00:36:15,119
in the leconic verifier protocol and we

938
00:36:15,119 --> 00:36:17,119
do the same thing the prover hashes its

939
00:36:17,119 --> 00:36:19,440
second message and sends another

940
00:36:19,440 --> 00:36:21,200
argument of knowledge

941
00:36:21,200 --> 00:36:24,079
uh and then after this is done after all

942
00:36:24,079 --> 00:36:25,440
of this has happened

943
00:36:25,440 --> 00:36:26,400
then

944
00:36:26,400 --> 00:36:28,800
the prover sends a third argument of

945
00:36:28,800 --> 00:36:31,520
knowledge uh that they know again

946
00:36:31,520 --> 00:36:35,040
passion versus of its own messages uh in

947
00:36:35,040 --> 00:36:37,280
principle these might be uh different

948
00:36:37,280 --> 00:36:38,720
hash inverses but the collision

949
00:36:38,720 --> 00:36:41,119
resistance of the hash function will

950
00:36:41,119 --> 00:36:43,040
sort of constrain them to actually be

951
00:36:43,040 --> 00:36:45,920
the same hash inverse but uh a priori

952
00:36:45,920 --> 00:36:48,400
they're potentially unrelated and so the

953
00:36:48,400 --> 00:36:49,839
third argument of knowledge says that

954
00:36:49,839 --> 00:36:52,240
that uh that the prover knows two hash

955
00:36:52,240 --> 00:36:54,880
inverses that's together compose a

956
00:36:54,880 --> 00:36:56,960
transcript that the verifier would

957
00:36:56,960 --> 00:36:59,760
accept along with the verifiers two

958
00:36:59,760 --> 00:37:01,520
messages

959
00:37:01,520 --> 00:37:03,760
so this is the structure of at least one

960
00:37:03,760 --> 00:37:07,040
of the versions uh of our compiled uh

961
00:37:07,040 --> 00:37:08,960
succinct argument system

962
00:37:08,960 --> 00:37:11,760
so why am i why am i writing down a

963
00:37:11,760 --> 00:37:13,520
protocol with this structure

964
00:37:13,520 --> 00:37:16,160
uh as opposed to say like just including

965
00:37:16,160 --> 00:37:18,560
one succinct arguments of uh of

966
00:37:18,560 --> 00:37:20,160
knowledge at the end

967
00:37:20,160 --> 00:37:22,240
the reason is

968
00:37:22,240 --> 00:37:24,640
that we need to we want to reduce the

969
00:37:24,640 --> 00:37:28,400
security of the this composed protocol

970
00:37:28,400 --> 00:37:30,480
to the security of the underlying

971
00:37:30,480 --> 00:37:33,119
laconic verifier protocol which means

972
00:37:33,119 --> 00:37:34,960
that in the reduction we need to be able

973
00:37:34,960 --> 00:37:37,040
to produce the prover messages in an

974
00:37:37,040 --> 00:37:39,200
online fashion for the laconic verifier

975
00:37:39,200 --> 00:37:40,640
protocol we need to be able to produce

976
00:37:40,640 --> 00:37:42,160
alpha one

977
00:37:42,160 --> 00:37:46,079
uh without knowing for like uh like a

978
00:37:46,079 --> 00:37:48,720
full transcript of the protocol

979
00:37:48,720 --> 00:37:49,520
and

980
00:37:49,520 --> 00:37:51,599
uh even more importantly

981
00:37:51,599 --> 00:37:54,079
we we need to be able to produce alpha

982
00:37:54,079 --> 00:37:57,440
one without using the verifiers like

983
00:37:57,440 --> 00:37:59,839
internal randomness that might uh

984
00:37:59,839 --> 00:38:02,720
compromise the security of the protocol

985
00:38:02,720 --> 00:38:04,400
this third argument of knowledge at the

986
00:38:04,400 --> 00:38:05,680
bottom is implicitly using the

987
00:38:05,680 --> 00:38:08,880
verifier's internal randomness uh

988
00:38:08,880 --> 00:38:10,560
because the statement the verifier would

989
00:38:10,560 --> 00:38:12,320
accept requires this

990
00:38:12,320 --> 00:38:13,440
uh so

991
00:38:13,440 --> 00:38:14,880
but with this structure there's a

992
00:38:14,880 --> 00:38:16,720
there's a there's a nice security

993
00:38:16,720 --> 00:38:19,040
reduction where we just

994
00:38:19,040 --> 00:38:22,320
sequentially extract alpha 1 from the

995
00:38:22,320 --> 00:38:24,480
first protocol and then extract from the

996
00:38:24,480 --> 00:38:26,800
first sub protocol extract alpha 2 from

997
00:38:26,800 --> 00:38:28,320
the second

998
00:38:28,320 --> 00:38:31,040
and that is how the security reduction

999
00:38:31,040 --> 00:38:33,040
uh works that's how we break the laconic

1000
00:38:33,040 --> 00:38:34,960
verifier protocol given just a breaker

1001
00:38:34,960 --> 00:38:37,200
for the composed protocol

1002
00:38:37,200 --> 00:38:39,680
and the fact that like in order to prove

1003
00:38:39,680 --> 00:38:41,359
that this reduction works you need

1004
00:38:41,359 --> 00:38:43,200
actually a strong form of argument of

1005
00:38:43,200 --> 00:38:46,160
knowledge where it's possible to extract

1006
00:38:46,160 --> 00:38:49,359
these messages alpha 1 and alpha 2

1007
00:38:49,359 --> 00:38:52,320
without disturbing the internal quantum

1008
00:38:52,320 --> 00:38:54,480
state of the adversary breaking this

1009
00:38:54,480 --> 00:38:56,079
larger protocol

1010
00:38:56,079 --> 00:38:57,599
but conveniently

1011
00:38:57,599 --> 00:38:59,359
in a recent work with fermima and nick

1012
00:38:59,359 --> 00:39:01,359
spooner we showed how to build such a

1013
00:39:01,359 --> 00:39:03,119
succinct argument system for np and so

1014
00:39:03,119 --> 00:39:06,400
we can plug it in and we're happy

1015
00:39:06,400 --> 00:39:08,320
uh so that's all i want to say about

1016
00:39:08,320 --> 00:39:09,680
step two

1017
00:39:09,680 --> 00:39:11,599
uh so now let me just say a little bit

1018
00:39:11,599 --> 00:39:13,040
about uh

1019
00:39:13,040 --> 00:39:16,400
about the laconic verifier protocol

1020
00:39:16,400 --> 00:39:17,200
so

1021
00:39:17,200 --> 00:39:19,920
uh skipping over uh quite a few details

1022
00:39:19,920 --> 00:39:22,720
the key step in constructing a

1023
00:39:22,720 --> 00:39:24,240
uh

1024
00:39:24,240 --> 00:39:26,160
quantum verification protocol following

1025
00:39:26,160 --> 00:39:29,440
the blueprint of mahadev is constructing

1026
00:39:29,440 --> 00:39:32,480
what is called a measurements protocol

1027
00:39:32,480 --> 00:39:34,160
so this is a protocol where the prover

1028
00:39:34,160 --> 00:39:36,400
starts with some l qubit quantum state

1029
00:39:36,400 --> 00:39:37,440
psi

1030
00:39:37,440 --> 00:39:40,720
the verifier starts with a string

1031
00:39:40,720 --> 00:39:43,599
an l bit string h which is a choice of

1032
00:39:43,599 --> 00:39:44,720
bases

1033
00:39:44,720 --> 00:39:47,839
and the verifier wants the prover to

1034
00:39:47,839 --> 00:39:49,920
measure its state psi

1035
00:39:49,920 --> 00:39:53,440
in these bases where where like an h i

1036
00:39:53,440 --> 00:39:55,200
equals zero means that the prover should

1037
00:39:55,200 --> 00:39:57,440
measure that qubit in the standard basis

1038
00:39:57,440 --> 00:39:59,040
h i equals one means the prover should

1039
00:39:59,040 --> 00:40:01,040
measure the i qubit in the hadamard

1040
00:40:01,040 --> 00:40:02,000
basis

1041
00:40:02,000 --> 00:40:04,000
uh the verifier wants the prover to make

1042
00:40:04,000 --> 00:40:06,000
these measurements and to report to the

1043
00:40:06,000 --> 00:40:08,560
verifier ideally what these measurement

1044
00:40:08,560 --> 00:40:10,079
outcomes are of course you want this to

1045
00:40:10,079 --> 00:40:12,000
be done in a verifiable way

1046
00:40:12,000 --> 00:40:13,520
and in a little more detail what that

1047
00:40:13,520 --> 00:40:16,560
means or how or how it's uh done is that

1048
00:40:16,560 --> 00:40:18,720
there is a cut and choose aspect to the

1049
00:40:18,720 --> 00:40:19,760
protocol

1050
00:40:19,760 --> 00:40:21,839
so there are two verifier challenges

1051
00:40:21,839 --> 00:40:23,119
zero and one

1052
00:40:23,119 --> 00:40:24,960
when the challenge is zero the verifier

1053
00:40:24,960 --> 00:40:26,400
is performing some sort of spot check

1054
00:40:26,400 --> 00:40:27,760
and it's not actually obtaining an

1055
00:40:27,760 --> 00:40:29,119
output just

1056
00:40:29,119 --> 00:40:30,720
uh just deciding whether or not to

1057
00:40:30,720 --> 00:40:33,200
accept the approver as being reasonable

1058
00:40:33,200 --> 00:40:34,319
or not

1059
00:40:34,319 --> 00:40:37,280
uh and when b equals one the verifier

1060
00:40:37,280 --> 00:40:39,599
actually obtains a measurement outcome

1061
00:40:39,599 --> 00:40:41,680
in the completeness case matching the

1062
00:40:41,680 --> 00:40:43,040
measurement outcomes of the prover's

1063
00:40:43,040 --> 00:40:44,640
initial state psi

1064
00:40:44,640 --> 00:40:46,880
and security says

1065
00:40:46,880 --> 00:40:49,920
that as long as an adversary p star is

1066
00:40:49,920 --> 00:40:52,240
passing this spot check v equals zero

1067
00:40:52,240 --> 00:40:53,920
challenge

1068
00:40:53,920 --> 00:40:57,440
then the distribution of outputs m the

1069
00:40:57,440 --> 00:40:59,920
verifier gets when b equals one is

1070
00:40:59,920 --> 00:41:03,040
computationally indistinguishable from

1071
00:41:03,040 --> 00:41:05,680
the measurement outcomes of some

1072
00:41:05,680 --> 00:41:07,920
l cubit state psi prime like the prover

1073
00:41:07,920 --> 00:41:09,280
in principle might not start with any

1074
00:41:09,280 --> 00:41:10,160
state

1075
00:41:10,160 --> 00:41:13,359
uh at like on the face of it but uh but

1076
00:41:13,359 --> 00:41:16,240
security says that there is some state

1077
00:41:16,240 --> 00:41:18,240
such that what the verifier gets out is

1078
00:41:18,240 --> 00:41:20,400
consistent with measuring psi in

1079
00:41:20,400 --> 00:41:23,839
whatever basis the verifier wants in

1080
00:41:23,839 --> 00:41:26,560
particular this state psi prime is

1081
00:41:26,560 --> 00:41:29,359
independent of the basis h and

1082
00:41:29,359 --> 00:41:31,280
and the indistinguishability should hold

1083
00:41:31,280 --> 00:41:34,800
for every basis choice at once

1084
00:41:34,800 --> 00:41:37,040
so that's the kind of protocol that we

1085
00:41:37,040 --> 00:41:37,920
want

1086
00:41:37,920 --> 00:41:41,040
mahadev constructs

1087
00:41:41,040 --> 00:41:43,040
a non-succinct

1088
00:41:43,040 --> 00:41:45,359
such protocol and the relevant piece of

1089
00:41:45,359 --> 00:41:47,680
information for this talk is what the

1090
00:41:47,680 --> 00:41:50,560
verifier's long first message actually

1091
00:41:50,560 --> 00:41:51,760
looks like

1092
00:41:51,760 --> 00:41:54,720
so what it is is the verifier sends

1093
00:41:54,720 --> 00:41:57,839
l so a large number of independent

1094
00:41:57,839 --> 00:41:59,200
public keys

1095
00:41:59,200 --> 00:42:01,359
for some trapdoor claw free function

1096
00:42:01,359 --> 00:42:02,720
family don't worry too much about what

1097
00:42:02,720 --> 00:42:05,040
the exact primitive is but

1098
00:42:05,040 --> 00:42:07,040
what you should bear in mind is that the

1099
00:42:07,040 --> 00:42:09,440
the primitive has two modes so there are

1100
00:42:09,440 --> 00:42:11,920
two different ways of sampling a key and

1101
00:42:11,920 --> 00:42:13,680
the way that the verifier samples the

1102
00:42:13,680 --> 00:42:17,119
key depends on its basis choice for so

1103
00:42:17,119 --> 00:42:18,319
for each i

1104
00:42:18,319 --> 00:42:23,119
the i public key is in mode h sub i

1105
00:42:23,119 --> 00:42:25,359
uh so this is the structure of the

1106
00:42:25,359 --> 00:42:26,400
protocol

1107
00:42:26,400 --> 00:42:29,040
so we want a succinct or at least a

1108
00:42:29,040 --> 00:42:31,839
verify like a laconic verifier protocol

1109
00:42:31,839 --> 00:42:34,079
uh laconic with respect to the parameter

1110
00:42:34,079 --> 00:42:36,640
l so we want uh like a sublinear and l

1111
00:42:36,640 --> 00:42:38,000
communication

1112
00:42:38,000 --> 00:42:39,680
uh and so first of all this only makes

1113
00:42:39,680 --> 00:42:40,800
sense that there's some succinct

1114
00:42:40,800 --> 00:42:42,400
representation for the string h but

1115
00:42:42,400 --> 00:42:45,040
let's suppose we have it uh

1116
00:42:45,040 --> 00:42:47,119
what we do in this work is we is we

1117
00:42:47,119 --> 00:42:48,880
write down uh

1118
00:42:48,880 --> 00:42:51,359
a way to uh to give a succinct

1119
00:42:51,359 --> 00:42:54,640
representation of l public keys uh we

1120
00:42:54,640 --> 00:42:56,240
call this primitive succinct batch key

1121
00:42:56,240 --> 00:42:57,599
generation we construct constructed from

1122
00:42:57,599 --> 00:42:58,400
i o

1123
00:42:58,400 --> 00:43:00,560
and roughly the security property that

1124
00:43:00,560 --> 00:43:02,960
you need is that given this distinct

1125
00:43:02,960 --> 00:43:05,440
representation for many public keys you

1126
00:43:05,440 --> 00:43:07,760
need that each individual tractor

1127
00:43:07,760 --> 00:43:10,800
clawfree function remains secure

1128
00:43:10,800 --> 00:43:12,880
even if all l minus one of the other

1129
00:43:12,880 --> 00:43:14,240
ones are compromised say that you get

1130
00:43:14,240 --> 00:43:16,000
the secret keys for all l minus one of

1131
00:43:16,000 --> 00:43:17,599
the other ones that's that's the sort of

1132
00:43:17,599 --> 00:43:19,760
security property that you need

1133
00:43:19,760 --> 00:43:21,839
uh and so it's not too hard to write

1134
00:43:21,839 --> 00:43:23,119
down

1135
00:43:23,119 --> 00:43:25,280
uh a protocol

1136
00:43:25,280 --> 00:43:27,440
uh

1137
00:43:27,440 --> 00:43:29,520
like it's not too hard to syntactically

1138
00:43:29,520 --> 00:43:31,760
write down a verify like a leconic

1139
00:43:31,760 --> 00:43:34,240
verifier protocol using this idea the

1140
00:43:34,240 --> 00:43:36,560
tricky part is actually proving that the

1141
00:43:36,560 --> 00:43:38,800
protocol is sound in particular

1142
00:43:38,800 --> 00:43:40,880
soundness doesn't follow from a black

1143
00:43:40,880 --> 00:43:44,079
box use of the hot of 18 results

1144
00:43:44,079 --> 00:43:45,040
uh

1145
00:43:45,040 --> 00:43:46,160
so there have been a lot of works

1146
00:43:46,160 --> 00:43:48,319
building on this uh on this

1147
00:43:48,319 --> 00:43:51,040
on this original protocol but almost all

1148
00:43:51,040 --> 00:43:52,800
of them either use the protocol

1149
00:43:52,800 --> 00:43:55,040
completely as a black box or they say

1150
00:43:55,040 --> 00:43:58,640
okay look at line 157 of the proof and

1151
00:43:58,640 --> 00:44:01,200
line 157 of the proof is still true in

1152
00:44:01,200 --> 00:44:04,079
our setting and so our our protocol is

1153
00:44:04,079 --> 00:44:05,839
also secure

1154
00:44:05,839 --> 00:44:07,680
so if we did that for this paper we

1155
00:44:07,680 --> 00:44:10,000
would like our proof would be like a

1156
00:44:10,000 --> 00:44:12,480
complete monstrosity uh

1157
00:44:12,480 --> 00:44:14,480
because our because our protocol is

1158
00:44:14,480 --> 00:44:16,000
significantly different

1159
00:44:16,000 --> 00:44:19,520
uh from the original protocol uh and so

1160
00:44:19,520 --> 00:44:20,800
instead of taking this approach we write

1161
00:44:20,800 --> 00:44:24,240
down what we uh think is a hopefully

1162
00:44:24,240 --> 00:44:26,400
simpler certainly more modular proof of

1163
00:44:26,400 --> 00:44:28,079
soundness that we hope will be useful in

1164
00:44:28,079 --> 00:44:30,480
other and other works that that

1165
00:44:30,480 --> 00:44:32,800
on quantum verification

1166
00:44:32,800 --> 00:44:34,640
uh and i'll just say a word on this

1167
00:44:34,640 --> 00:44:37,359
soundness proof uh so we

1168
00:44:37,359 --> 00:44:40,319
we start with and expand on uh an

1169
00:44:40,319 --> 00:44:42,880
approach outlined by vitic

1170
00:44:42,880 --> 00:44:44,880
in some unpublished lecture notes uh

1171
00:44:44,880 --> 00:44:46,800
called the operational qubits approach

1172
00:44:46,800 --> 00:44:49,040
we we extend it to prove the strong form

1173
00:44:49,040 --> 00:44:50,880
of security that the measurement

1174
00:44:50,880 --> 00:44:53,119
protocol that i just described is asking

1175
00:44:53,119 --> 00:44:54,240
for

1176
00:44:54,240 --> 00:44:57,280
um so the argument basically goes

1177
00:44:57,280 --> 00:44:58,960
suppose you have a cheating prover

1178
00:44:58,960 --> 00:45:01,280
that's that's working we want to find

1179
00:45:01,280 --> 00:45:03,680
this l cubit state psi prime that's

1180
00:45:03,680 --> 00:45:05,359
consistent with what what the verifier

1181
00:45:05,359 --> 00:45:07,599
gets but what we actually have is just

1182
00:45:07,599 --> 00:45:10,319
the internal state of the prover

1183
00:45:10,319 --> 00:45:13,440
uh and note the prover may be cheating

1184
00:45:13,440 --> 00:45:15,760
the verifier may not be getting outputs

1185
00:45:15,760 --> 00:45:18,079
that are just the measurements of the

1186
00:45:18,079 --> 00:45:20,000
prover state psi in the standard or

1187
00:45:20,000 --> 00:45:21,760
hadamard basis the the prover doesn't

1188
00:45:21,760 --> 00:45:23,599
have to behave in that way

1189
00:45:23,599 --> 00:45:24,400
uh

1190
00:45:24,400 --> 00:45:27,280
so but but we we find a psi prime

1191
00:45:27,280 --> 00:45:28,480
nonetheless

1192
00:45:28,480 --> 00:45:31,440
and we do it as follows we first

1193
00:45:31,440 --> 00:45:33,359
identify

1194
00:45:33,359 --> 00:45:36,079
two l different ways of measuring the

1195
00:45:36,079 --> 00:45:39,440
prover state psi that we call pseudopoly

1196
00:45:39,440 --> 00:45:42,000
observables

1197
00:45:42,000 --> 00:45:44,079
such that when you measure the prover

1198
00:45:44,079 --> 00:45:46,720
state with these observables instead of

1199
00:45:46,720 --> 00:45:49,040
standard and hadamard basis measurements

1200
00:45:49,040 --> 00:45:51,440
uh that those measurement outcomes

1201
00:45:51,440 --> 00:45:53,839
actually match what the verifier gets

1202
00:45:53,839 --> 00:45:55,760
the verifiers output

1203
00:45:55,760 --> 00:45:57,200
so what does it mean these are pseudo

1204
00:45:57,200 --> 00:45:59,040
poly i'm hand waving it here but the

1205
00:45:59,040 --> 00:46:01,599
point is that they should behave like

1206
00:46:01,599 --> 00:46:03,920
standard and hadamard basis measurements

1207
00:46:03,920 --> 00:46:06,000
in the in the way that they commute and

1208
00:46:06,000 --> 00:46:07,680
anti-commute the way they relate to each

1209
00:46:07,680 --> 00:46:09,119
other so in particular you should have

1210
00:46:09,119 --> 00:46:12,319
an uncertainty principle uh between the

1211
00:46:12,319 --> 00:46:14,079
ice

1212
00:46:14,079 --> 00:46:15,839
quote unquote or pseudo standard basis

1213
00:46:15,839 --> 00:46:16,640
measurements and the eighth

1214
00:46:16,640 --> 00:46:18,960
pseudo-hadamard basis measurements

1215
00:46:18,960 --> 00:46:20,160
uh

1216
00:46:20,160 --> 00:46:23,040
so that's like roughly speaking why they

1217
00:46:23,040 --> 00:46:24,800
are like standard and hadamard basis

1218
00:46:24,800 --> 00:46:26,960
measurements uh and given this we then

1219
00:46:26,960 --> 00:46:29,839
extract an actual state psi prime that

1220
00:46:29,839 --> 00:46:31,520
is not that that is not the prover

1221
00:46:31,520 --> 00:46:33,040
states uh

1222
00:46:33,040 --> 00:46:34,800
where like we you know we convert

1223
00:46:34,800 --> 00:46:36,800
pseudopolis to real poly so we extract

1224
00:46:36,800 --> 00:46:38,720
psi prime whose real measurements match

1225
00:46:38,720 --> 00:46:41,599
the pseudo measurements of psi

1226
00:46:41,599 --> 00:46:43,200
and to actually implement this there are

1227
00:46:43,200 --> 00:46:45,599
three questions that you care about

1228
00:46:45,599 --> 00:46:48,640
what are these pseudo poly measurements

1229
00:46:48,640 --> 00:46:50,160
how do you find psi prime and how do you

1230
00:46:50,160 --> 00:46:52,079
show that it works i unfortunately don't

1231
00:46:52,079 --> 00:46:53,760
have time to explain it i'll give like

1232
00:46:53,760 --> 00:46:55,680
one sentence answers to each

1233
00:46:55,680 --> 00:46:57,680
the pseudo-poly measurements you get by

1234
00:46:57,680 --> 00:46:59,599
like pretty syntactically reading off

1235
00:46:59,599 --> 00:47:01,440
how the prover responds

1236
00:47:01,440 --> 00:47:03,920
in the protocol and what's nice is that

1237
00:47:03,920 --> 00:47:05,440
the is that the

1238
00:47:05,440 --> 00:47:07,839
relationships that the the pseudo-poly

1239
00:47:07,839 --> 00:47:10,880
relations between these uh xi's and zi's

1240
00:47:10,880 --> 00:47:13,520
and x i and zj are you can sort of read

1241
00:47:13,520 --> 00:47:15,760
off from the basic security properties

1242
00:47:15,760 --> 00:47:18,560
of the tractor claw free function family

1243
00:47:18,560 --> 00:47:20,400
which is quite nice

1244
00:47:20,400 --> 00:47:22,880
then how do you get psi prime uh its

1245
00:47:22,880 --> 00:47:25,839
outputs by an extractor that pretends

1246
00:47:25,839 --> 00:47:28,480
that these pseudo polys are real polys

1247
00:47:28,480 --> 00:47:31,200
and teleports psi onto a new register

1248
00:47:31,200 --> 00:47:32,960
which is actually l qubits and we treat

1249
00:47:32,960 --> 00:47:35,040
that as the uh

1250
00:47:35,040 --> 00:47:37,280
as the outputs as the as the extracted

1251
00:47:37,280 --> 00:47:39,040
state so the point is that you can write

1252
00:47:39,040 --> 00:47:41,359
down a circuit that does quantum

1253
00:47:41,359 --> 00:47:44,000
teleportation uh in the event that's

1254
00:47:44,000 --> 00:47:47,119
that uh the pseudo polys were real polys

1255
00:47:47,119 --> 00:47:48,480
uh

1256
00:47:48,480 --> 00:47:50,880
as a circuit that uses uh poly x and

1257
00:47:50,880 --> 00:47:53,200
poly z operators and you can replace the

1258
00:47:53,200 --> 00:47:55,440
poly x's and poly z's with the pseudo

1259
00:47:55,440 --> 00:47:57,920
operators and that is how the extractor

1260
00:47:57,920 --> 00:47:58,880
works

1261
00:47:58,880 --> 00:48:00,720
finally the way you show that this state

1262
00:48:00,720 --> 00:48:02,640
actually uh like satisfies the

1263
00:48:02,640 --> 00:48:04,880
properties that you want is by giving a

1264
00:48:04,880 --> 00:48:06,400
physical interpretation of what

1265
00:48:06,400 --> 00:48:08,240
measuring this extracted state actually

1266
00:48:08,240 --> 00:48:10,400
means in terms of the pseudo poly

1267
00:48:10,400 --> 00:48:11,760
measurements and i encourage you to look

1268
00:48:11,760 --> 00:48:13,359
at the technical overview of our paper

1269
00:48:13,359 --> 00:48:15,040
for a for an explanation for how all

1270
00:48:15,040 --> 00:48:17,040
this works uh so that's that's

1271
00:48:17,040 --> 00:48:20,839
everything thanks for listening

1272
00:48:25,680 --> 00:48:26,720
thank you

1273
00:48:26,720 --> 00:48:28,319
thanks alex

1274
00:48:28,319 --> 00:48:30,160
we have

1275
00:48:30,160 --> 00:48:33,119
time for one quick question

1276
00:48:33,119 --> 00:48:34,960
if you have a question please come to

1277
00:48:34,960 --> 00:48:37,359
the microphone

1278
00:48:37,359 --> 00:48:39,839
yeah thank you for the talk uh i was

1279
00:48:39,839 --> 00:48:40,780
unclear about

1280
00:48:40,780 --> 00:48:42,079
[Music]

1281
00:48:42,079 --> 00:48:43,200
what you were

1282
00:48:43,200 --> 00:48:46,000
proving in the argument of knowledge

1283
00:48:46,000 --> 00:48:47,680
which is you prove knowledge of the

1284
00:48:47,680 --> 00:48:49,920
underlying thing alpha

1285
00:48:49,920 --> 00:48:51,440
so what is alpha is it just all the

1286
00:48:51,440 --> 00:48:54,319
messages in the cdqc protocol

1287
00:48:54,319 --> 00:48:56,480
uh yeah yeah so for each for each

1288
00:48:56,480 --> 00:49:00,000
message of the of the protocol with long

1289
00:49:00,000 --> 00:49:01,440
prover messages

1290
00:49:01,440 --> 00:49:03,280
you have the prover hash that message

1291
00:49:03,280 --> 00:49:04,800
and then prove knowledge of a hash

1292
00:49:04,800 --> 00:49:06,079
inverse which

1293
00:49:06,079 --> 00:49:08,079
like uh like i just

1294
00:49:08,079 --> 00:49:09,119
like the first proof of knowledge is

1295
00:49:09,119 --> 00:49:10,800
just i know some string that is a hash

1296
00:49:10,800 --> 00:49:12,880
inverse of the message i just sent you

1297
00:49:12,880 --> 00:49:15,040
later in the third in the third argument

1298
00:49:15,040 --> 00:49:16,559
of knowledge you actually tie that

1299
00:49:16,559 --> 00:49:18,720
together with the uh with the original

1300
00:49:18,720 --> 00:49:20,960
protocol like that there there you prove

1301
00:49:20,960 --> 00:49:22,880
that you know hash inverses

1302
00:49:22,880 --> 00:49:25,680
such that the verifier would accept the

1303
00:49:25,680 --> 00:49:28,000
four message like the the

1304
00:49:28,000 --> 00:49:29,520
the transcripts composed of the

1305
00:49:29,520 --> 00:49:31,440
verifier's own two short messages and

1306
00:49:31,440 --> 00:49:34,640
the provers long messages

1307
00:49:34,640 --> 00:49:37,040
thank you

1308
00:49:37,359 --> 00:49:41,880
let's let's thanks to the speaker again

1309
00:49:45,280 --> 00:49:48,640
the final talk of this session is on

1310
00:49:48,640 --> 00:49:50,960
the feasibility of uncomfortable

1311
00:49:50,960 --> 00:49:54,240
encryption and more by pravanjan nance

1312
00:49:54,240 --> 00:49:56,559
vice party khalil

1313
00:49:56,559 --> 00:49:58,880
sham

1314
00:50:00,640 --> 00:50:05,720
and the chipping is going to speak

1315
00:51:01,920 --> 00:51:05,280
we do not see the slides

1316
00:51:06,839 --> 00:51:08,640
no

1317
00:51:08,640 --> 00:51:10,000
could you say it

1318
00:51:10,000 --> 00:51:12,160
so could you help me

1319
00:51:12,160 --> 00:51:13,040
okay

1320
00:51:13,040 --> 00:51:14,480
great

1321
00:51:14,480 --> 00:51:17,760
okay the slide is uh sure right also it

1322
00:51:17,760 --> 00:51:19,520
should be yeah right

1323
00:51:19,520 --> 00:51:20,400
there

1324
00:51:20,400 --> 00:51:23,040
okay okay great okay let's start it so

1325
00:51:23,040 --> 00:51:25,280
um yeah i'm i'm chipping leo from

1326
00:51:25,280 --> 00:51:28,160
simon's institute so um i will be

1327
00:51:28,160 --> 00:51:29,520
talking about the work on the

1328
00:51:29,520 --> 00:51:31,440
feasibility of unclonable encryption

1329
00:51:31,440 --> 00:51:33,200
more this is a joint work with

1330
00:51:33,200 --> 00:51:36,480
prabhanjan fatih xinji and mark

1331
00:51:36,480 --> 00:51:39,040
so um okay excuse me i'm not seeing the

1332
00:51:39,040 --> 00:51:43,200
slides not seeing the slides um

1333
00:51:43,200 --> 00:51:44,240
could you help

1334
00:51:44,240 --> 00:51:47,640
okay thanks

1335
00:51:59,839 --> 00:52:01,680
that works

1336
00:52:01,680 --> 00:52:04,680
okay

1337
00:52:08,800 --> 00:52:11,040
by the way it's not working

1338
00:52:11,040 --> 00:52:14,558
i cannot go to the next line

1339
00:52:16,000 --> 00:52:19,319
i don't know

1340
00:52:20,160 --> 00:52:22,319
okay anyway i can use the keyboard

1341
00:52:22,319 --> 00:52:23,839
all right

1342
00:52:23,839 --> 00:52:24,720
fine

1343
00:52:24,720 --> 00:52:28,399
okay it's about focus okay

1344
00:52:28,480 --> 00:52:30,800
okay um so let's start it

1345
00:52:30,800 --> 00:52:33,520
um so the work the talk is basically

1346
00:52:33,520 --> 00:52:34,480
about

1347
00:52:34,480 --> 00:52:37,200
taking advantage of the most fundamental

1348
00:52:37,200 --> 00:52:38,079
um

1349
00:52:38,079 --> 00:52:40,000
uh property of quantum information which

1350
00:52:40,000 --> 00:52:42,240
is the no colonies that says if you

1351
00:52:42,240 --> 00:52:43,440
don't know a piece of quantum

1352
00:52:43,440 --> 00:52:45,680
information there's no general quantum

1353
00:52:45,680 --> 00:52:46,880
machine can

1354
00:52:46,880 --> 00:52:48,400
copy the quantum state into two

1355
00:52:48,400 --> 00:52:49,920
identical uh

1356
00:52:49,920 --> 00:52:51,280
copies

1357
00:52:51,280 --> 00:52:52,880
which is impossible

1358
00:52:52,880 --> 00:52:55,760
um so this unclonability of quantum

1359
00:52:55,760 --> 00:52:58,319
information actually brought the the

1360
00:52:58,319 --> 00:53:00,319
whole field which is called which i call

1361
00:53:00,319 --> 00:53:03,760
unclonable uh cryptography so

1362
00:53:03,760 --> 00:53:05,520
uh here's a list of unclonable

1363
00:53:05,520 --> 00:53:07,280
cryptography and you're probably already

1364
00:53:07,280 --> 00:53:09,680
familiar uh with most of them

1365
00:53:09,680 --> 00:53:12,240
uh the first one is the the the starting

1366
00:53:12,240 --> 00:53:13,599
work which is the

1367
00:53:13,599 --> 00:53:15,680
quantum key distribution and also there

1368
00:53:15,680 --> 00:53:16,640
are a

1369
00:53:16,640 --> 00:53:19,119
line of work including quantum money and

1370
00:53:19,119 --> 00:53:21,040
quantum copy protection for a broad

1371
00:53:21,040 --> 00:53:23,040
class of cryptography

1372
00:53:23,040 --> 00:53:26,319
and in this work we will both basically

1373
00:53:26,319 --> 00:53:28,400
consider the most fundamental uh

1374
00:53:28,400 --> 00:53:31,200
unclonable crypto primitive which

1375
00:53:31,200 --> 00:53:33,440
is the unclonable encryption

1376
00:53:33,440 --> 00:53:37,040
so just like the um one-time pad to the

1377
00:53:37,040 --> 00:53:39,040
symmetric key crypto

1378
00:53:39,040 --> 00:53:41,599
which is a one-time symmetric encryption

1379
00:53:41,599 --> 00:53:44,319
we also in this talk we will consider

1380
00:53:44,319 --> 00:53:46,400
the one-time symmetric key unclonable

1381
00:53:46,400 --> 00:53:48,800
encryption which i will uh explain so we

1382
00:53:48,800 --> 00:53:51,359
believe it is the most fundamental and

1383
00:53:51,359 --> 00:53:53,520
important thing we need to understand

1384
00:53:53,520 --> 00:53:56,640
and to um to explore the whole area of

1385
00:53:56,640 --> 00:53:58,720
unclonable cryptography

1386
00:53:58,720 --> 00:54:00,160
right so

1387
00:54:00,160 --> 00:54:03,119
uh let's start by looking at what the

1388
00:54:03,119 --> 00:54:05,920
definition is so the definition

1389
00:54:05,920 --> 00:54:08,000
was first introduced by broadband and

1390
00:54:08,000 --> 00:54:08,839
lord

1391
00:54:08,839 --> 00:54:12,880
so um i mean it is the encryption scheme

1392
00:54:12,880 --> 00:54:14,960
so what extra property issue is

1393
00:54:14,960 --> 00:54:18,640
satisfied um it is the uh which we call

1394
00:54:18,640 --> 00:54:21,359
random message security unclonability

1395
00:54:21,359 --> 00:54:22,559
that says

1396
00:54:22,559 --> 00:54:25,280
assume you have uh uh uh

1397
00:54:25,280 --> 00:54:28,800
wait sorry um assume you have a random

1398
00:54:28,800 --> 00:54:32,079
message and encrypted as a

1399
00:54:32,079 --> 00:54:33,680
encryption and you give the encryption

1400
00:54:33,680 --> 00:54:36,720
to uh adversary which we call uh alice

1401
00:54:36,720 --> 00:54:38,640
which is the adversary who doing the

1402
00:54:38,640 --> 00:54:41,680
splitting attack uh alice getting the

1403
00:54:41,680 --> 00:54:44,400
encryption splitting the message uh the

1404
00:54:44,400 --> 00:54:47,839
the encryption into two uh quantum state

1405
00:54:47,839 --> 00:54:50,319
and later on these two quantum states

1406
00:54:50,319 --> 00:54:53,200
which are handled by bob and charlie who

1407
00:54:53,200 --> 00:54:54,280
are

1408
00:54:54,280 --> 00:54:57,040
non-communicating parties who later

1409
00:54:57,040 --> 00:54:59,359
received the secret key which is for

1410
00:54:59,359 --> 00:55:02,400
them to recover the original message

1411
00:55:02,400 --> 00:55:03,200
and

1412
00:55:03,200 --> 00:55:05,520
the unclonability guarantees that

1413
00:55:05,520 --> 00:55:08,319
there's no way for both bob and charlie

1414
00:55:08,319 --> 00:55:10,240
to independently

1415
00:55:10,240 --> 00:55:12,400
recover the original message even

1416
00:55:12,400 --> 00:55:14,000
they're given the

1417
00:55:14,000 --> 00:55:15,280
secret key

1418
00:55:15,280 --> 00:55:18,079
so the prop the security guarantee says

1419
00:55:18,079 --> 00:55:18,880
that

1420
00:55:18,880 --> 00:55:21,119
the probability of this colluding

1421
00:55:21,119 --> 00:55:23,599
adversary alice bob and charlie

1422
00:55:23,599 --> 00:55:26,480
uh both uh they together independently

1423
00:55:26,480 --> 00:55:29,680
recover the message m prime equals to m

1424
00:55:29,680 --> 00:55:31,760
double prime equals the original message

1425
00:55:31,760 --> 00:55:34,240
n uh the probability will be uh super

1426
00:55:34,240 --> 00:55:37,520
small let's say either uh negligible or

1427
00:55:37,520 --> 00:55:40,720
sub sub exponentially small

1428
00:55:40,720 --> 00:55:43,280
and in their work they can show um the

1429
00:55:43,280 --> 00:55:46,319
probability can be either negligible or

1430
00:55:46,319 --> 00:55:49,760
um sub exponentially small either in the

1431
00:55:49,760 --> 00:55:52,000
information theoretical way or in the

1432
00:55:52,000 --> 00:55:53,760
idealized model which is the quantum

1433
00:55:53,760 --> 00:55:55,839
random oracle mode

1434
00:55:55,839 --> 00:55:58,720
okay so that's the security um called

1435
00:55:58,720 --> 00:56:01,040
random message on clonability

1436
00:56:01,040 --> 00:56:03,280
okay but this is not the ideal security

1437
00:56:03,280 --> 00:56:06,319
we want so here's the issue so

1438
00:56:06,319 --> 00:56:08,240
basically this security doesn't

1439
00:56:08,240 --> 00:56:09,280
guarantee

1440
00:56:09,280 --> 00:56:12,640
uh bob and charlie to learn um

1441
00:56:12,640 --> 00:56:14,880
no information about the message so for

1442
00:56:14,880 --> 00:56:18,319
example um bob and charlie can both

1443
00:56:18,319 --> 00:56:20,160
learn a single bit of the message but

1444
00:56:20,160 --> 00:56:23,280
still doesn't violate uh anything about

1445
00:56:23,280 --> 00:56:26,160
this uh guarantee about the probability

1446
00:56:26,160 --> 00:56:27,920
so here

1447
00:56:27,920 --> 00:56:30,160
they identify the problem and propose

1448
00:56:30,160 --> 00:56:33,119
the following definition which um

1449
00:56:33,119 --> 00:56:35,680
we call it as a cpa style bank

1450
00:56:35,680 --> 00:56:38,079
vulnerability just like when we define

1451
00:56:38,079 --> 00:56:41,680
cpa security in the classical crypto

1452
00:56:41,680 --> 00:56:44,319
so in this setting a pair of message

1453
00:56:44,319 --> 00:56:47,119
which are m0 and m1 are chosen by the

1454
00:56:47,119 --> 00:56:48,559
other version

1455
00:56:48,559 --> 00:56:51,280
so let's say chosen by alice and then

1456
00:56:51,280 --> 00:56:52,880
the challenger

1457
00:56:52,880 --> 00:56:54,079
will

1458
00:56:54,079 --> 00:56:56,799
randomly pick one of the message and

1459
00:56:56,799 --> 00:56:59,599
encrypt and give the encryption to uh

1460
00:56:59,599 --> 00:57:00,720
alice

1461
00:57:00,720 --> 00:57:04,160
and later on alice just do the same

1462
00:57:04,160 --> 00:57:07,359
splitting attack and having um

1463
00:57:07,359 --> 00:57:08,160
two

1464
00:57:08,160 --> 00:57:11,200
independent encryption register to both

1465
00:57:11,200 --> 00:57:12,640
bob and charlie

1466
00:57:12,640 --> 00:57:13,440
and

1467
00:57:13,440 --> 00:57:16,319
the their outcome was to predict which

1468
00:57:16,319 --> 00:57:18,960
message were encrypted under the under

1469
00:57:18,960 --> 00:57:21,760
the original uh quantum cipher text

1470
00:57:21,760 --> 00:57:24,000
all right so the guarantee is the

1471
00:57:24,000 --> 00:57:26,079
probability of both of them

1472
00:57:26,079 --> 00:57:28,720
simultaneously gets the bit correctly

1473
00:57:28,720 --> 00:57:31,280
should be very very close to half

1474
00:57:31,280 --> 00:57:33,520
so that basically says there's no way

1475
00:57:33,520 --> 00:57:36,000
you can

1476
00:57:36,079 --> 00:57:39,200
split the quantum encryption into

1477
00:57:39,200 --> 00:57:41,440
two encryptions in other words this

1478
00:57:41,440 --> 00:57:44,319
quantum ciphertext can only go one of

1479
00:57:44,319 --> 00:57:46,160
these two paths in other words it only

1480
00:57:46,160 --> 00:57:48,640
goes to the upper pass or going to the

1481
00:57:48,640 --> 00:57:50,799
lower path there's no way you can copy

1482
00:57:50,799 --> 00:57:53,440
any meaningful information

1483
00:57:53,440 --> 00:57:55,200
all right so that's the definition we

1484
00:57:55,200 --> 00:57:57,839
call it cpa unknown vote uh

1485
00:57:57,839 --> 00:58:01,359
on cpa style unclean ability

1486
00:58:01,359 --> 00:58:02,240
all right

1487
00:58:02,240 --> 00:58:04,079
so um

1488
00:58:04,079 --> 00:58:05,920
and here's the special case that is when

1489
00:58:05,920 --> 00:58:08,160
the message only uh having length one

1490
00:58:08,160 --> 00:58:10,400
then we don't need to uh let's say let

1491
00:58:10,400 --> 00:58:12,400
alice to choose the message we can just

1492
00:58:12,400 --> 00:58:14,319
focus on the case where m0 equals to

1493
00:58:14,319 --> 00:58:16,240
zero and m1 equal to one and that's the

1494
00:58:16,240 --> 00:58:18,720
case we will consider in the work

1495
00:58:18,720 --> 00:58:19,520
all right

1496
00:58:19,520 --> 00:58:22,319
and and i mean we our work can extend

1497
00:58:22,319 --> 00:58:24,480
the result to arbitrary end but just for

1498
00:58:24,480 --> 00:58:26,640
convenience we focus on the length edge

1499
00:58:26,640 --> 00:58:28,720
meant to be one

1500
00:58:28,720 --> 00:58:30,960
right so um

1501
00:58:30,960 --> 00:58:33,359
okay so let's look at uh what happened

1502
00:58:33,359 --> 00:58:34,839
in the previous work

1503
00:58:34,839 --> 00:58:38,079
so um in broadband word paper they first

1504
00:58:38,079 --> 00:58:40,640
show that it is possible to construct a

1505
00:58:40,640 --> 00:58:42,720
uh scheme which satisfy random message

1506
00:58:42,720 --> 00:58:43,839
security

1507
00:58:43,839 --> 00:58:46,880
just as we uh see either in

1508
00:58:46,880 --> 00:58:48,880
information theoretical way or in the

1509
00:58:48,880 --> 00:58:51,200
random oracle model

1510
00:58:51,200 --> 00:58:53,040
and they identify the problem of the

1511
00:58:53,040 --> 00:58:54,720
definition and they propose a new

1512
00:58:54,720 --> 00:58:55,920
definition

1513
00:58:55,920 --> 00:58:57,839
uh which is the optimum security or the

1514
00:58:57,839 --> 00:58:59,280
cpu security

1515
00:58:59,280 --> 00:59:00,960
uncloneability

1516
00:59:00,960 --> 00:59:03,200
but they don't have find a way to prove

1517
00:59:03,200 --> 00:59:06,079
it um and later on i mean even in the

1518
00:59:06,079 --> 00:59:07,839
quantum random oracle model

1519
00:59:07,839 --> 00:59:11,200
and later on uh imagine schaffner and

1520
00:59:11,200 --> 00:59:13,599
tamaski they show that actually

1521
00:59:13,599 --> 00:59:15,280
in the original

1522
00:59:15,280 --> 00:59:16,559
in the original construction by

1523
00:59:16,559 --> 00:59:18,640
broadband lore there's a technical

1524
00:59:18,640 --> 00:59:20,799
barrier that is uh

1525
00:59:20,799 --> 00:59:23,520
using the the proof technique in the

1526
00:59:23,520 --> 00:59:25,359
broadband lord paper there's no way you

1527
00:59:25,359 --> 00:59:28,079
can show uh the scheme satisfy the

1528
00:59:28,079 --> 00:59:30,640
optimum security in other words it seems

1529
00:59:30,640 --> 00:59:32,480
like a dead end

1530
00:59:32,480 --> 00:59:35,359
so that's all we need about the uh this

1531
00:59:35,359 --> 00:59:37,040
one-time symmetric key unclonable

1532
00:59:37,040 --> 00:59:38,960
encryption

1533
00:59:38,960 --> 00:59:40,559
so in this work we show that it is

1534
00:59:40,559 --> 00:59:42,240
actually possible in the quantum random

1535
00:59:42,240 --> 00:59:43,200
oracle

1536
00:59:43,200 --> 00:59:44,400
model

1537
00:59:44,400 --> 00:59:46,880
so we basically give alternative

1538
00:59:46,880 --> 00:59:48,640
construction which is super super close

1539
00:59:48,640 --> 00:59:49,520
to the

1540
00:59:49,520 --> 00:59:51,760
uh uh the the broadband lord

1541
00:59:51,760 --> 00:59:54,400
construction but there's some caveat and

1542
00:59:54,400 --> 00:59:56,480
we give a new proof and also we take

1543
00:59:56,480 --> 00:59:59,440
advantage of our modification and we can

1544
00:59:59,440 --> 01:00:02,000
show that it this this object is

1545
01:00:02,000 --> 01:00:04,480
actually exists in the in the uh quantum

1546
01:00:04,480 --> 01:00:06,480
random oracle model in other words the

1547
01:00:06,480 --> 01:00:08,880
most the fundamental unclonable crypto

1548
01:00:08,880 --> 01:00:11,040
it actually exists

1549
01:00:11,040 --> 01:00:14,720
right so that's the uh result

1550
01:00:14,720 --> 01:00:16,160
okay

1551
01:00:16,160 --> 01:00:19,119
so um and as i just talked about this is

1552
01:00:19,119 --> 01:00:21,040
our first result that said there's

1553
01:00:21,040 --> 01:00:23,200
exists an unclonable encryption scheme

1554
01:00:23,200 --> 01:00:27,119
with the optimum cpu unplannability

1555
01:00:27,119 --> 01:00:28,480
and we also

1556
01:00:28,480 --> 01:00:30,079
show other results the first result is

1557
01:00:30,079 --> 01:00:33,200
the impossibility result that's um

1558
01:00:33,200 --> 01:00:34,599
says um

1559
01:00:34,599 --> 01:00:37,440
unclonable encryption cannot be both

1560
01:00:37,440 --> 01:00:41,040
information theoretically secure

1561
01:00:41,040 --> 01:00:43,599
and deterministic here deterministic

1562
01:00:43,599 --> 01:00:45,200
basically means the encryption and

1563
01:00:45,200 --> 01:00:49,200
decryption procedure will be uh unitary

1564
01:00:49,200 --> 01:00:50,079
and

1565
01:00:50,079 --> 01:00:53,359
the this is a justification of our first

1566
01:00:53,359 --> 01:00:55,760
result that says either random oracle

1567
01:00:55,760 --> 01:00:58,720
model is necessary or

1568
01:00:58,720 --> 01:01:00,480
our construction is also randomized so

1569
01:01:00,480 --> 01:01:03,040
the randomized structure is also needed

1570
01:01:03,040 --> 01:01:04,799
i mean either the randomized structure

1571
01:01:04,799 --> 01:01:06,880
or the random oracle model is necessary

1572
01:01:06,880 --> 01:01:09,680
to achieve the optimum security

1573
01:01:09,680 --> 01:01:12,079
and also we show uh application to copy

1574
01:01:12,079 --> 01:01:14,880
protection of point functions um this is

1575
01:01:14,880 --> 01:01:17,280
not a this is not a black box reduction

1576
01:01:17,280 --> 01:01:20,160
but we um we basically borrow the proof

1577
01:01:20,160 --> 01:01:22,319
technique from our first result and we

1578
01:01:22,319 --> 01:01:24,480
extend to copy protection for point

1579
01:01:24,480 --> 01:01:27,440
function as our application

1580
01:01:27,440 --> 01:01:29,599
all right so that's uh all the results

1581
01:01:29,599 --> 01:01:31,119
and uh

1582
01:01:31,119 --> 01:01:32,000
let's

1583
01:01:32,000 --> 01:01:34,720
move on to the some somewhat technical

1584
01:01:34,720 --> 01:01:35,839
part

1585
01:01:35,839 --> 01:01:39,440
so here's a roadmap we will first record

1586
01:01:39,440 --> 01:01:41,920
um the construction in broadband and

1587
01:01:41,920 --> 01:01:43,359
lord's work

1588
01:01:43,359 --> 01:01:45,440
and then we will see what what's the

1589
01:01:45,440 --> 01:01:47,280
challenge so i will give you some

1590
01:01:47,280 --> 01:01:49,920
attempt and the attempt is uh of course

1591
01:01:49,920 --> 01:01:51,680
failed because it's called attempt and

1592
01:01:51,680 --> 01:01:53,280
then i will show

1593
01:01:53,280 --> 01:01:56,000
our construction and how we overcome

1594
01:01:56,000 --> 01:01:57,520
this barrier

1595
01:01:57,520 --> 01:01:59,759
okay

1596
01:02:00,079 --> 01:02:02,319
so um let's start by recalling the

1597
01:02:02,319 --> 01:02:03,760
construction in

1598
01:02:03,760 --> 01:02:05,200
in their work

1599
01:02:05,200 --> 01:02:06,400
so we need to

1600
01:02:06,400 --> 01:02:08,799
start with the quantum state which i

1601
01:02:08,799 --> 01:02:10,640
hope most of people are familiar with

1602
01:02:10,640 --> 01:02:13,359
but if you don't you don't need to worry

1603
01:02:13,359 --> 01:02:15,920
so it is called the wizner states

1604
01:02:15,920 --> 01:02:18,480
so you can you can so the witness is a

1605
01:02:18,480 --> 01:02:20,559
quantum state that encodes a classical

1606
01:02:20,559 --> 01:02:21,520
um

1607
01:02:21,520 --> 01:02:23,520
classical message or classical string

1608
01:02:23,520 --> 01:02:26,960
which is the uh m bit x

1609
01:02:26,960 --> 01:02:27,760
so

1610
01:02:27,760 --> 01:02:30,720
and uh basically given x we also have a

1611
01:02:30,720 --> 01:02:32,720
theta you can you can view it as like a

1612
01:02:32,720 --> 01:02:35,359
secret key to encrypt the the classical

1613
01:02:35,359 --> 01:02:37,839
message so given x and the classical

1614
01:02:37,839 --> 01:02:41,680
theta both are classical you can

1615
01:02:41,680 --> 01:02:44,079
generate a quantum c which we call x

1616
01:02:44,079 --> 01:02:46,319
theta so

1617
01:02:46,319 --> 01:02:47,119
and

1618
01:02:47,119 --> 01:02:49,119
also the reverse is also efficient that

1619
01:02:49,119 --> 01:02:51,520
is given the quantum state you can uh

1620
01:02:51,520 --> 01:02:54,319
extract the x from the quantum state

1621
01:02:54,319 --> 01:02:55,839
all right so

1622
01:02:55,839 --> 01:02:56,799
um

1623
01:02:56,799 --> 01:02:59,839
there i i don't want to uh explore about

1624
01:02:59,839 --> 01:03:01,599
the structure but there are like two

1625
01:03:01,599 --> 01:03:04,400
fundamental properties we well use in

1626
01:03:04,400 --> 01:03:06,640
the in the construction and in the proof

1627
01:03:06,640 --> 01:03:08,280
so we i call it

1628
01:03:08,280 --> 01:03:11,039
unpredictability and unclonability so

1629
01:03:11,039 --> 01:03:12,559
let's let's see

1630
01:03:12,559 --> 01:03:14,680
so the first one is called

1631
01:03:14,680 --> 01:03:17,039
unpredictability which says given a

1632
01:03:17,039 --> 01:03:20,400
quantum state which is the bb-84 state

1633
01:03:20,400 --> 01:03:22,960
but without giving an adversary the

1634
01:03:22,960 --> 01:03:23,920
theta

1635
01:03:23,920 --> 01:03:27,920
there's no way to recover the message x

1636
01:03:27,920 --> 01:03:29,680
and the probability of a successful

1637
01:03:29,680 --> 01:03:31,920
guess will be 2 to the minus n in other

1638
01:03:31,920 --> 01:03:34,160
words if the adversary has no

1639
01:03:34,160 --> 01:03:36,559
information about the basis inform about

1640
01:03:36,559 --> 01:03:39,520
the basis then this x to the theta is

1641
01:03:39,520 --> 01:03:43,039
completely hidden for for the adversary

1642
01:03:43,039 --> 01:03:45,839
that's the first thing we will

1643
01:03:45,839 --> 01:03:48,160
use in the proof

1644
01:03:48,160 --> 01:03:50,480
and the second

1645
01:03:50,480 --> 01:03:52,480
property is called unclonability which

1646
01:03:52,480 --> 01:03:54,640
is uh will be heavily used in our

1647
01:03:54,640 --> 01:03:56,799
construction that says

1648
01:03:56,799 --> 01:03:59,039
given a random

1649
01:03:59,039 --> 01:04:00,880
witness state

1650
01:04:00,880 --> 01:04:02,240
there's no way

1651
01:04:02,240 --> 01:04:03,039
to

1652
01:04:03,039 --> 01:04:05,039
do a splitting attack

1653
01:04:05,039 --> 01:04:06,480
such that

1654
01:04:06,480 --> 01:04:08,880
both can recover x

1655
01:04:08,880 --> 01:04:10,640
that is the probability of the

1656
01:04:10,640 --> 01:04:13,280
simultaneous guess such that x prime

1657
01:04:13,280 --> 01:04:15,280
equals to x double prime x to the

1658
01:04:15,280 --> 01:04:18,480
original equals to the original message

1659
01:04:18,480 --> 01:04:19,920
is at most

1660
01:04:19,920 --> 01:04:22,400
uh some exponentially small function

1661
01:04:22,400 --> 01:04:25,280
right so this is um over random choices

1662
01:04:25,280 --> 01:04:28,400
of x and theta so you can already see

1663
01:04:28,400 --> 01:04:32,079
from from here how to construct a a

1664
01:04:32,079 --> 01:04:34,480
candidate of unclonable encryption which

1665
01:04:34,480 --> 01:04:36,640
you simply put your message

1666
01:04:36,640 --> 01:04:39,520
as an x and let your secret key to be

1667
01:04:39,520 --> 01:04:42,640
theta and this is uh very very close to

1668
01:04:42,640 --> 01:04:44,799
the broadband lord's first construction

1669
01:04:44,799 --> 01:04:46,319
the the information theoretical

1670
01:04:46,319 --> 01:04:48,559
construction and they can indeed show

1671
01:04:48,559 --> 01:04:51,920
that it is um

1672
01:04:51,920 --> 01:04:52,640
a

1673
01:04:52,640 --> 01:04:54,640
random it has random message

1674
01:04:54,640 --> 01:04:58,400
unclonability with uh roughly 0.85 to

1675
01:04:58,400 --> 01:05:00,319
the n

1676
01:05:00,319 --> 01:05:01,520
all right

1677
01:05:01,520 --> 01:05:03,760
so

1678
01:05:03,760 --> 01:05:05,200
but however

1679
01:05:05,200 --> 01:05:07,359
if we construct in that way

1680
01:05:07,359 --> 01:05:09,280
there's no way you can

1681
01:05:09,280 --> 01:05:12,160
expect the the optimum security the cpa

1682
01:05:12,160 --> 01:05:14,319
style secured uh security

1683
01:05:14,319 --> 01:05:16,720
because this is the two-bit case we can

1684
01:05:16,720 --> 01:05:18,960
simply look at the two-bit case

1685
01:05:18,960 --> 01:05:19,760
so

1686
01:05:19,760 --> 01:05:20,720
um

1687
01:05:20,720 --> 01:05:24,400
let this um message to be m0 can

1688
01:05:24,400 --> 01:05:26,640
concatenating with m1

1689
01:05:26,640 --> 01:05:28,480
also here there are not two messages

1690
01:05:28,480 --> 01:05:30,160
just two-bit

1691
01:05:30,160 --> 01:05:32,240
and we also um

1692
01:05:32,240 --> 01:05:34,880
be should be aware of this uh wizard

1693
01:05:34,880 --> 01:05:37,200
state is actually a bit by bit

1694
01:05:37,200 --> 01:05:39,599
encryption so you can simply getting

1695
01:05:39,599 --> 01:05:42,079
this quantum state and split the quantum

1696
01:05:42,079 --> 01:05:44,640
state into two registers so what you did

1697
01:05:44,640 --> 01:05:46,480
is okay you send the first qubit

1698
01:05:46,480 --> 01:05:48,160
register to bob

1699
01:05:48,160 --> 01:05:50,640
and you send the second qb register to

1700
01:05:50,640 --> 01:05:51,440
child

1701
01:05:51,440 --> 01:05:53,440
and after receiving theta they both can

1702
01:05:53,440 --> 01:05:56,160
receive they can recover m0 and m1 so in

1703
01:05:56,160 --> 01:05:58,720
this case there's no way you can um

1704
01:05:58,720 --> 01:06:01,599
expect cpu security because

1705
01:06:01,599 --> 01:06:05,359
you can simply choose m to be 0 0 or 1

1706
01:06:05,359 --> 01:06:07,920
1. so bob and charlie can always

1707
01:06:07,920 --> 01:06:10,240
completely recover which messages are

1708
01:06:10,240 --> 01:06:12,480
being encrypted so it's completely

1709
01:06:12,480 --> 01:06:14,400
violated what we want

1710
01:06:14,400 --> 01:06:16,720
so since there's no hope to

1711
01:06:16,720 --> 01:06:20,000
just to directly work with this um

1712
01:06:20,000 --> 01:06:22,640
the game so

1713
01:06:22,640 --> 01:06:24,319
we asked the following question can we

1714
01:06:24,319 --> 01:06:27,280
reduce this cps unknown ability to this

1715
01:06:27,280 --> 01:06:29,280
random message uncountability which we

1716
01:06:29,280 --> 01:06:31,599
already know how to do right

1717
01:06:31,599 --> 01:06:33,440
so for example can we based on an

1718
01:06:33,440 --> 01:06:37,760
extractor uh to extract a single bit and

1719
01:06:37,760 --> 01:06:40,799
use the bit to do the encryption

1720
01:06:40,799 --> 01:06:43,359
here is the attempt so if we can prove a

1721
01:06:43,359 --> 01:06:45,839
theorem statement like this then we can

1722
01:06:45,839 --> 01:06:47,200
have a

1723
01:06:47,200 --> 01:06:49,680
unclonable encryption scheme satisfying

1724
01:06:49,680 --> 01:06:53,359
the cpa secure unknown ability so

1725
01:06:53,359 --> 01:06:56,000
here uh in the game

1726
01:06:56,000 --> 01:06:57,760
bob and charlie are not recovering the

1727
01:06:57,760 --> 01:06:59,839
message but they are recovering a bit

1728
01:06:59,839 --> 01:07:02,480
the bit is actually a

1729
01:07:02,480 --> 01:07:05,440
extractor outcome on the random seed r

1730
01:07:05,440 --> 01:07:08,559
and on the secret x so if we can prove

1731
01:07:08,559 --> 01:07:10,559
there's no way for bob and charlie to

1732
01:07:10,559 --> 01:07:12,559
simultaneously get the outcome of the

1733
01:07:12,559 --> 01:07:15,839
extractor then

1734
01:07:16,079 --> 01:07:18,000
we can we can build an encryption scheme

1735
01:07:18,000 --> 01:07:20,880
like this so the keys will be uh cedar

1736
01:07:20,880 --> 01:07:22,799
and r which are the basis information

1737
01:07:22,799 --> 01:07:25,440
and the seed for the extraction and to

1738
01:07:25,440 --> 01:07:28,799
encrypt you simply output the bb84 state

1739
01:07:28,799 --> 01:07:31,680
together with the message mask with the

1740
01:07:31,680 --> 01:07:34,400
the outcome of the extractor and and we

1741
01:07:34,400 --> 01:07:36,160
know that there's no way you can predict

1742
01:07:36,160 --> 01:07:38,240
simultaneously at least one of the

1743
01:07:38,240 --> 01:07:40,480
message will be completely hidden

1744
01:07:40,480 --> 01:07:41,280
okay

1745
01:07:41,280 --> 01:07:42,640
so but

1746
01:07:42,640 --> 01:07:46,000
this construction this this uh road is

1747
01:07:46,000 --> 01:07:48,480
actually difficult because there there

1748
01:07:48,480 --> 01:07:50,480
are basically two issues but these two

1749
01:07:50,480 --> 01:07:53,359
issues are kind of the same so first of

1750
01:07:53,359 --> 01:07:55,440
all we are considering a non-local game

1751
01:07:55,440 --> 01:07:56,400
so

1752
01:07:56,400 --> 01:07:58,319
the extractor should

1753
01:07:58,319 --> 01:07:59,839
we should do like simultaneous

1754
01:07:59,839 --> 01:08:02,160
extraction so it's actually we don't

1755
01:08:02,160 --> 01:08:04,319
know too much proof technique for this

1756
01:08:04,319 --> 01:08:06,160
and even worse

1757
01:08:06,160 --> 01:08:08,319
because this quantum state are generated

1758
01:08:08,319 --> 01:08:09,599
by the adversary so they can be

1759
01:08:09,599 --> 01:08:11,039
arbitrarily correlated it can be

1760
01:08:11,039 --> 01:08:12,240
arbitrarily

1761
01:08:12,240 --> 01:08:15,359
entangled so it's even uh make this

1762
01:08:15,359 --> 01:08:17,600
approach even worse

1763
01:08:17,600 --> 01:08:19,279
so um

1764
01:08:19,279 --> 01:08:20,799
and and

1765
01:08:20,799 --> 01:08:23,439
indeed in broadband and lord's paper

1766
01:08:23,439 --> 01:08:24,479
they use

1767
01:08:24,479 --> 01:08:26,880
extractor so what they use isn't a

1768
01:08:26,880 --> 01:08:28,479
random oracle you can view a random

1769
01:08:28,479 --> 01:08:32,399
oracle as the way to extract so

1770
01:08:32,399 --> 01:08:34,880
using this the ideal extractor they can

1771
01:08:34,880 --> 01:08:36,000
show that

1772
01:08:36,000 --> 01:08:39,279
the their skin satisfying random message

1773
01:08:39,279 --> 01:08:42,158
unknown ability with probability 9 times

1774
01:08:42,158 --> 01:08:44,000
2 to the minus n

1775
01:08:44,000 --> 01:08:46,080
which is much better than that without

1776
01:08:46,080 --> 01:08:48,560
the random oracle but still it's far

1777
01:08:48,560 --> 01:08:50,319
away from being

1778
01:08:50,319 --> 01:08:51,279
from

1779
01:08:51,279 --> 01:08:54,000
implying the optimum security because to

1780
01:08:54,000 --> 01:08:56,399
achieve optimum security you need this

1781
01:08:56,399 --> 01:08:59,198
random message unclonability to

1782
01:08:59,198 --> 01:09:02,719
uh have probability two to the minus n

1783
01:09:02,719 --> 01:09:04,640
so there's still a nine gap which um

1784
01:09:04,640 --> 01:09:06,479
there's no way to we don't know how to

1785
01:09:06,479 --> 01:09:07,600
fix

1786
01:09:07,600 --> 01:09:10,560
and later on the mentions and chris uh

1787
01:09:10,560 --> 01:09:12,560
schaffener and thomas b they showed that

1788
01:09:12,560 --> 01:09:15,600
the proof technique uh in in this work

1789
01:09:15,600 --> 01:09:18,799
cannot achieve uh the the bond so

1790
01:09:18,799 --> 01:09:21,920
there's no hope to to do that

1791
01:09:21,920 --> 01:09:23,120
okay

1792
01:09:23,120 --> 01:09:24,080
so

1793
01:09:24,080 --> 01:09:28,560
uh that's uh the barrier for extracture

1794
01:09:28,560 --> 01:09:29,600
so

1795
01:09:29,600 --> 01:09:32,238
okay so now let's look at how we handle

1796
01:09:32,238 --> 01:09:34,640
this problem so

1797
01:09:34,640 --> 01:09:37,359
this is our construction so to be honest

1798
01:09:37,359 --> 01:09:39,279
this is not exactly our construction i

1799
01:09:39,279 --> 01:09:40,719
cheated a little bit here this

1800
01:09:40,719 --> 01:09:42,799
construction is indeed the construction

1801
01:09:42,799 --> 01:09:45,759
from a broadband and lord's vapor

1802
01:09:45,759 --> 01:09:46,640
so

1803
01:09:46,640 --> 01:09:48,399
which is using

1804
01:09:48,399 --> 01:09:50,960
the x using hash the random oracle as a

1805
01:09:50,960 --> 01:09:53,920
extractor and you produce one bit and to

1806
01:09:53,920 --> 01:09:55,840
mask the message

1807
01:09:55,840 --> 01:09:58,080
okay but i will show um

1808
01:09:58,080 --> 01:10:00,560
how our proof technique can prove this

1809
01:10:00,560 --> 01:10:04,159
by just doing a simple modification

1810
01:10:04,159 --> 01:10:08,639
so um that's the construction

1811
01:10:08,960 --> 01:10:13,040
you uh have a bb84c you extract x from

1812
01:10:13,040 --> 01:10:15,040
you extract the binary outcome and your

1813
01:10:15,040 --> 01:10:17,679
mask message and to decrypt it's

1814
01:10:17,679 --> 01:10:19,760
simple you um

1815
01:10:19,760 --> 01:10:22,719
you read out the x and you unmask the

1816
01:10:22,719 --> 01:10:24,400
cipher text and you can recover the

1817
01:10:24,400 --> 01:10:25,920
message

1818
01:10:25,920 --> 01:10:27,840
all right so that's the this is the

1819
01:10:27,840 --> 01:10:29,199
proof overview

1820
01:10:29,199 --> 01:10:32,159
so we will first show this cpa security

1821
01:10:32,159 --> 01:10:35,040
and the cpa style unclone ability can be

1822
01:10:35,040 --> 01:10:38,080
reduced to a game we call identical

1823
01:10:38,080 --> 01:10:40,159
reprogram game

1824
01:10:40,159 --> 01:10:42,239
for wizards in the quantum random oracle

1825
01:10:42,239 --> 01:10:43,280
model

1826
01:10:43,280 --> 01:10:45,679
and then this identical is actually

1827
01:10:45,679 --> 01:10:48,480
pretty hard to deal with and we reduce

1828
01:10:48,480 --> 01:10:51,840
that or we relate that to something

1829
01:10:51,840 --> 01:10:54,080
called an independent reprogrammed game

1830
01:10:54,080 --> 01:10:56,239
which is much much easier to handle and

1831
01:10:56,239 --> 01:10:58,159
finally this game can be based on the

1832
01:10:58,159 --> 01:10:59,840
unknown ability

1833
01:10:59,840 --> 01:11:02,320
which we already know uh it's a it's a

1834
01:11:02,320 --> 01:11:04,480
property of the quantum c itself

1835
01:11:04,480 --> 01:11:08,000
and indeed the the reduction here

1836
01:11:08,000 --> 01:11:10,719
does not work uh quite work out so we

1837
01:11:10,719 --> 01:11:13,280
finally replace the quantum state with

1838
01:11:13,280 --> 01:11:15,520
another collection of quantum c and we

1839
01:11:15,520 --> 01:11:18,159
can complete the whole reduction

1840
01:11:18,159 --> 01:11:20,800
so that's the that's the overview

1841
01:11:20,800 --> 01:11:21,600
so

1842
01:11:21,600 --> 01:11:22,400
let's

1843
01:11:22,400 --> 01:11:23,920
start

1844
01:11:23,920 --> 01:11:26,640
looking at the proof sketch so that

1845
01:11:26,640 --> 01:11:29,199
that's the cp like how we define cpa

1846
01:11:29,199 --> 01:11:31,440
style on vulnerability that is you are

1847
01:11:31,440 --> 01:11:34,159
given a cipher text alice trying to

1848
01:11:34,159 --> 01:11:36,880
split and then both theta are revealed

1849
01:11:36,880 --> 01:11:38,880
to bob and charlie and they try to

1850
01:11:38,880 --> 01:11:41,360
recover and the winning condition is

1851
01:11:41,360 --> 01:11:44,080
said to be m equals to m prime equals to

1852
01:11:44,080 --> 01:11:46,080
m double prime so our first

1853
01:11:46,080 --> 01:11:48,719
simplification is we remove the

1854
01:11:48,719 --> 01:11:52,560
the the the message here

1855
01:11:52,560 --> 01:11:53,360
and

1856
01:11:53,360 --> 01:11:56,719
we instead of recovering the message

1857
01:11:56,719 --> 01:11:59,360
now the alice only gets the bb-84 states

1858
01:11:59,360 --> 01:12:01,679
or the business state and the goal is to

1859
01:12:01,679 --> 01:12:03,199
recover the

1860
01:12:03,199 --> 01:12:05,600
outcome on the hash function

1861
01:12:05,600 --> 01:12:08,640
on the the input x so they're actually

1862
01:12:08,640 --> 01:12:10,480
there's very easy reduction you can

1863
01:12:10,480 --> 01:12:12,880
simply remove the message x uh the

1864
01:12:12,880 --> 01:12:15,600
message m easily so that's will uh

1865
01:12:15,600 --> 01:12:17,920
simplify this um the game so we'll

1866
01:12:17,920 --> 01:12:20,159
consider this game if we can prove it we

1867
01:12:20,159 --> 01:12:22,560
prove the cpa unquotability

1868
01:12:22,560 --> 01:12:24,239
all right so

1869
01:12:24,239 --> 01:12:27,760
um next we have the observation that is

1870
01:12:27,760 --> 01:12:30,719
this oracle given to alice can be

1871
01:12:30,719 --> 01:12:32,480
reprogrammed

1872
01:12:32,480 --> 01:12:35,040
so we define an oracle h prime which is

1873
01:12:35,040 --> 01:12:37,600
identical to h except

1874
01:12:37,600 --> 01:12:41,199
the evaluation on h prime the evaluation

1875
01:12:41,199 --> 01:12:43,760
of h prime on x is uniform that is

1876
01:12:43,760 --> 01:12:47,600
completely independent of h and of x so

1877
01:12:47,600 --> 01:12:51,280
why is that true i mean i want to say

1878
01:12:51,280 --> 01:12:53,679
replacing this h prime h with h prime

1879
01:12:53,679 --> 01:12:55,679
doesn't change anything so why is that

1880
01:12:55,679 --> 01:12:57,440
true because

1881
01:12:57,440 --> 01:13:00,640
i know that alice won't be able to query

1882
01:13:00,640 --> 01:13:01,600
h

1883
01:13:01,600 --> 01:13:03,280
on x

1884
01:13:03,280 --> 01:13:06,400
or maybe he can but he can i mean she

1885
01:13:06,400 --> 01:13:08,719
can only query a very negligible amount

1886
01:13:08,719 --> 01:13:11,120
because otherwise you can randomly

1887
01:13:11,120 --> 01:13:14,320
measure alice query and you can recover

1888
01:13:14,320 --> 01:13:16,960
uh the x with high enough probability

1889
01:13:16,960 --> 01:13:18,400
which will violate

1890
01:13:18,400 --> 01:13:20,560
this unpredicted predictability of

1891
01:13:20,560 --> 01:13:22,480
witness state

1892
01:13:22,480 --> 01:13:24,960
so that's how we use the first property

1893
01:13:24,960 --> 01:13:28,080
of research that is we replace this h

1894
01:13:28,080 --> 01:13:31,280
with h prime and we completely unlike

1895
01:13:31,280 --> 01:13:34,239
unrelated this oracle with the other

1896
01:13:34,239 --> 01:13:37,040
oracle given to bob and charlie

1897
01:13:37,040 --> 01:13:40,080
okay so what we do next is we

1898
01:13:40,080 --> 01:13:42,800
simply do a variable renaming so we

1899
01:13:42,800 --> 01:13:45,280
rename this oracle h

1900
01:13:45,280 --> 01:13:48,239
by h prime b that is

1901
01:13:48,239 --> 01:13:50,000
uh

1902
01:13:50,000 --> 01:13:51,280
the h

1903
01:13:51,280 --> 01:13:53,440
prime b will be the same as h prime

1904
01:13:53,440 --> 01:13:57,040
except h prime of x which is the the

1905
01:13:57,040 --> 01:14:00,560
evaluation of x is reprogrammed as b so

1906
01:14:00,560 --> 01:14:03,120
i mean they simply just rename because h

1907
01:14:03,120 --> 01:14:04,480
of x is also

1908
01:14:04,480 --> 01:14:07,040
completely independent and uniformly

1909
01:14:07,040 --> 01:14:10,320
random so we just reprogram that as b

1910
01:14:10,320 --> 01:14:12,880
and the winning condition instead to be

1911
01:14:12,880 --> 01:14:14,960
b equals to b prime equals to b double

1912
01:14:14,960 --> 01:14:18,800
prime so just just rename it okay

1913
01:14:18,800 --> 01:14:22,960
so that will make things uh easier

1914
01:14:22,960 --> 01:14:25,840
so then we can just look at the partial

1915
01:14:25,840 --> 01:14:27,520
view instead of looking at the joint

1916
01:14:27,520 --> 01:14:29,920
view of bob and charlie so

1917
01:14:29,920 --> 01:14:32,480
we know that if bob

1918
01:14:32,480 --> 01:14:34,640
can can recover

1919
01:14:34,640 --> 01:14:37,679
can can we can can guest be with enough

1920
01:14:37,679 --> 01:14:39,920
probability more than half

1921
01:14:39,920 --> 01:14:41,600
here we only consider like one message

1922
01:14:41,600 --> 01:14:43,600
the random oracle only output a single

1923
01:14:43,600 --> 01:14:45,280
bit so if

1924
01:14:45,280 --> 01:14:47,440
bob can recover it with probability more

1925
01:14:47,440 --> 01:14:51,280
than half that means bob must query this

1926
01:14:51,280 --> 01:14:53,760
oracle hb prime

1927
01:14:53,760 --> 01:14:57,760
on x with large fraction with large

1928
01:14:57,760 --> 01:14:59,040
weight

1929
01:14:59,040 --> 01:15:00,960
so in that case

1930
01:15:00,960 --> 01:15:03,280
we can add a random measurement

1931
01:15:03,280 --> 01:15:07,040
over b over bob to doing an extraction

1932
01:15:07,040 --> 01:15:08,880
so in other words this random

1933
01:15:08,880 --> 01:15:11,199
measurement simply just pick a random

1934
01:15:11,199 --> 01:15:14,400
query of bob and just completely measure

1935
01:15:14,400 --> 01:15:15,920
and

1936
01:15:15,920 --> 01:15:18,719
there will be inverse poly chance that

1937
01:15:18,719 --> 01:15:20,640
the outcome

1938
01:15:20,640 --> 01:15:23,040
is equal to b

1939
01:15:23,040 --> 01:15:27,040
okay and similarly um

1940
01:15:27,040 --> 01:15:30,159
if charlie has a succeeding probability

1941
01:15:30,159 --> 01:15:31,760
more than half that means charlie's

1942
01:15:31,760 --> 01:15:35,199
outcome must be uh dependent

1943
01:15:35,199 --> 01:15:38,880
uh of this b so we can also add a random

1944
01:15:38,880 --> 01:15:41,520
measurement and trying to catch the

1945
01:15:41,520 --> 01:15:42,560
query

1946
01:15:42,560 --> 01:15:45,280
charlie made to made on x

1947
01:15:45,280 --> 01:15:47,679
and therefore we also conclude that if

1948
01:15:47,679 --> 01:15:49,520
the probability for charlie is

1949
01:15:49,520 --> 01:15:52,400
significantly more than half then a

1950
01:15:52,400 --> 01:15:55,280
random measurement well-produced inverse

1951
01:15:55,280 --> 01:15:57,840
will produce x-prime equals to x with

1952
01:15:57,840 --> 01:15:59,760
inverse body chance

1953
01:15:59,760 --> 01:16:02,800
so it seems in that situation we can

1954
01:16:02,800 --> 01:16:06,480
both recover from charlie or from bob

1955
01:16:06,480 --> 01:16:08,000
but the question is

1956
01:16:08,000 --> 01:16:10,000
if we add random measurement to both bob

1957
01:16:10,000 --> 01:16:12,000
and charlie can we

1958
01:16:12,000 --> 01:16:14,320
recover them simultaneously still with

1959
01:16:14,320 --> 01:16:16,719
inverse polynomial trends

1960
01:16:16,719 --> 01:16:19,520
and if that is true then we can break

1961
01:16:19,520 --> 01:16:22,000
the unclonability of within state

1962
01:16:22,000 --> 01:16:24,080
because we can simply construct a

1963
01:16:24,080 --> 01:16:26,880
reduction which give x to the theta and

1964
01:16:26,880 --> 01:16:29,040
we can sample the hash function

1965
01:16:29,040 --> 01:16:31,760
uh ourselves and the reduction i mean we

1966
01:16:31,760 --> 01:16:33,520
we as the reduction can also do the

1967
01:16:33,520 --> 01:16:35,920
reprogramming ourselves and trying to do

1968
01:16:35,920 --> 01:16:38,320
the random measurement and the outcome

1969
01:16:38,320 --> 01:16:41,360
and output x prime and x double prime

1970
01:16:41,360 --> 01:16:42,320
okay

1971
01:16:42,320 --> 01:16:44,960
so but the approach has two issues the

1972
01:16:44,960 --> 01:16:48,000
first issue is how to reprogram h prime

1973
01:16:48,000 --> 01:16:48,880
because

1974
01:16:48,880 --> 01:16:51,120
the point we want to reprogram is

1975
01:16:51,120 --> 01:16:52,960
exactly the point we want to output we

1976
01:16:52,960 --> 01:16:55,520
want to guess there's so we we don't

1977
01:16:55,520 --> 01:16:58,000
know if if we want if we can reprogram

1978
01:16:58,000 --> 01:16:59,920
at the first place why we just don't

1979
01:16:59,920 --> 01:17:01,440
output that

1980
01:17:01,440 --> 01:17:04,000
and the second issue is um

1981
01:17:04,000 --> 01:17:06,159
they still the entanglement issue that

1982
01:17:06,159 --> 01:17:08,560
is because they they're entangled the

1983
01:17:08,560 --> 01:17:10,000
measurement this random measurement

1984
01:17:10,000 --> 01:17:12,800
above may completely destroy the

1985
01:17:12,800 --> 01:17:15,440
behavior of charlie so they

1986
01:17:15,440 --> 01:17:18,400
there are some correlations so maybe a

1987
01:17:18,400 --> 01:17:21,360
success for uh extraction on both sides

1988
01:17:21,360 --> 01:17:24,480
always imply a failed uh extraction or

1989
01:17:24,480 --> 01:17:27,600
failed uh this outcome on the charlie

1990
01:17:27,600 --> 01:17:28,480
side

1991
01:17:28,480 --> 01:17:31,679
so there are two issues we want to solve

1992
01:17:31,679 --> 01:17:34,480
okay you are running more time so okay

1993
01:17:34,480 --> 01:17:36,480
sure let me let me quickly

1994
01:17:36,480 --> 01:17:38,400
wrap up okay so

1995
01:17:38,400 --> 01:17:40,960
our solution is to instead of looking at

1996
01:17:40,960 --> 01:17:42,719
the identical

1997
01:17:42,719 --> 01:17:44,480
because in the previous game we

1998
01:17:44,480 --> 01:17:45,679
reprogrammed

1999
01:17:45,679 --> 01:17:47,760
using the same b we're reprogramming

2000
01:17:47,760 --> 01:17:49,360
using differently

2001
01:17:49,360 --> 01:17:52,080
and and we realized that

2002
01:17:52,080 --> 01:17:53,199
this

2003
01:17:53,199 --> 01:17:55,120
independent reprogramming is very very

2004
01:17:55,120 --> 01:17:56,840
close to the identical

2005
01:17:56,840 --> 01:17:58,960
reprogramming and this is our main

2006
01:17:58,960 --> 01:18:02,239
technical lemma

2007
01:18:02,239 --> 01:18:03,520
so

2008
01:18:03,520 --> 01:18:05,840
this proof need a very helpful analyze

2009
01:18:05,840 --> 01:18:07,600
in the corresponding jordan block which

2010
01:18:07,600 --> 01:18:09,199
i will ignore which

2011
01:18:09,199 --> 01:18:11,440
may involve too many details but i think

2012
01:18:11,440 --> 01:18:13,920
this uh technical technical lemma will

2013
01:18:13,920 --> 01:18:16,400
be useful for other independent versus

2014
01:18:16,400 --> 01:18:19,040
dependent non-local games

2015
01:18:19,040 --> 01:18:21,679
so and and that's of the first issue

2016
01:18:21,679 --> 01:18:24,320
which we reduced a random independent

2017
01:18:24,320 --> 01:18:26,880
reprogram game and for the first and for

2018
01:18:26,880 --> 01:18:29,120
the first issue um

2019
01:18:29,120 --> 01:18:31,600
we what we do is um

2020
01:18:31,600 --> 01:18:32,880
we simply

2021
01:18:32,880 --> 01:18:36,080
use a not we we observe that reduction

2022
01:18:36,080 --> 01:18:38,800
can only reprogram on uh if the

2023
01:18:38,800 --> 01:18:40,800
adversary ever queries so if the

2024
01:18:40,800 --> 01:18:42,719
adversity never queries we don't

2025
01:18:42,719 --> 01:18:45,760
reprogram only if the adversary queries

2026
01:18:45,760 --> 01:18:46,640
on the

2027
01:18:46,640 --> 01:18:48,560
position we want to reprogram then we do

2028
01:18:48,560 --> 01:18:50,960
the reprogram and this can be based on

2029
01:18:50,960 --> 01:18:52,880
so called the coset states

2030
01:18:52,880 --> 01:18:55,280
and which also satisfy

2031
01:18:55,280 --> 01:18:56,960
all the property we want plus the

2032
01:18:56,960 --> 01:18:59,600
verifiability which is we can verify if

2033
01:18:59,600 --> 01:19:03,440
this x is the point we want to reprogram

2034
01:19:03,440 --> 01:19:06,880
okay so this is the our construction we

2035
01:19:06,880 --> 01:19:09,120
replace all the building block with the

2036
01:19:09,120 --> 01:19:11,280
so-called coset states and then we can

2037
01:19:11,280 --> 01:19:12,880
complete the proof and showing the

2038
01:19:12,880 --> 01:19:15,920
optimum security uh for unclonable

2039
01:19:15,920 --> 01:19:17,120
encryption

2040
01:19:17,120 --> 01:19:19,920
so and that's the recap of the proof and

2041
01:19:19,920 --> 01:19:21,679
since i don't have enough time and

2042
01:19:21,679 --> 01:19:23,280
that's everything i want to talk about

2043
01:19:23,280 --> 01:19:26,719
today thank you for coming

2044
01:19:30,400 --> 01:19:32,880
one quick question you have please come

2045
01:19:32,880 --> 01:19:36,120
to the microphone

2046
01:19:38,480 --> 01:19:40,639
no

2047
01:19:44,000 --> 01:19:45,600
i think you had a slight of it but just

2048
01:19:45,600 --> 01:19:48,320
to check so there is no hope to do it

2049
01:19:48,320 --> 01:19:50,080
based on standard extraction what is the

2050
01:19:50,080 --> 01:19:52,239
status if you put like instead of h some

2051
01:19:52,239 --> 01:19:55,679
kind of no it's it's just barrier i um

2052
01:19:55,679 --> 01:19:58,080
we didn't prove any uh impossibility

2053
01:19:58,080 --> 01:20:00,080
without respect to x structure so it's

2054
01:20:00,080 --> 01:20:03,040
still possible but uh to do it you need

2055
01:20:03,040 --> 01:20:05,120
the still the only thing we know is

2056
01:20:05,120 --> 01:20:07,600
about the impossibility so you either

2057
01:20:07,600 --> 01:20:09,679
uh maybe remove the deterministic you

2058
01:20:09,679 --> 01:20:12,480
need a randomized encryption scheme

2059
01:20:12,480 --> 01:20:14,080
to do it or

2060
01:20:14,080 --> 01:20:15,760
you need some computational assumption

2061
01:20:15,760 --> 01:20:17,679
but that's still possible

2062
01:20:17,679 --> 01:20:19,199
yes

2063
01:20:19,199 --> 01:20:20,719
right

2064
01:20:20,719 --> 01:20:23,040
thanks

2065
01:20:23,199 --> 01:20:25,520
all right let's have the extends the

2066
01:20:25,520 --> 01:20:28,239
speaker game

2067
01:20:31,440 --> 01:20:34,839
poppy brick

2068
01:21:08,560 --> 01:21:11,040
i needed myself all right yeah that's

2069
01:21:11,040 --> 01:21:15,000
amazing yeah thank you

