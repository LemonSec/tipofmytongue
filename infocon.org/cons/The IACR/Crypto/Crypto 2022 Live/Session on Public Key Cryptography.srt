1
00:00:00,320 --> 00:00:01,760
of the session

2
00:00:01,760 --> 00:00:03,600
are going to be a

3
00:00:03,600 --> 00:00:06,640
virtual talk uh it's called public key

4
00:00:06,640 --> 00:00:08,960
watermarking schemes pursued random

5
00:00:08,960 --> 00:00:11,840
functions by rupen young

6
00:00:11,840 --> 00:00:16,400
cau men huawei and willie susley

7
00:00:16,400 --> 00:00:20,840
and rupenk will give that talk

8
00:00:32,399 --> 00:00:33,760
all right so hello everyone i'm bu

9
00:00:33,760 --> 00:00:35,280
priyank and today i'm going to talk

10
00:00:35,280 --> 00:00:37,280
about how to construct a public key with

11
00:00:37,280 --> 00:00:39,680
macro prf this is visa and drawing to

12
00:00:39,680 --> 00:00:42,960
work with hru macho and with zero

13
00:00:42,960 --> 00:00:45,120
so automatic scheme can bend some

14
00:00:45,120 --> 00:00:46,800
information into a digital object

15
00:00:46,800 --> 00:00:49,200
retouching it too much

16
00:00:49,200 --> 00:00:51,600
and it will be hard to remove the

17
00:00:51,600 --> 00:00:53,760
abandoned information without destroying

18
00:00:53,760 --> 00:00:56,239
the watermark object

19
00:00:56,239 --> 00:00:57,680
in this talk we consider what

20
00:00:57,680 --> 00:00:59,280
parkinson's we need to follow the

21
00:00:59,280 --> 00:01:01,280
programs that is

22
00:01:01,280 --> 00:01:04,159
part object is a program

23
00:01:04,159 --> 00:01:07,720
firmly it consists

24
00:01:21,520 --> 00:01:23,680
was there a problem

25
00:01:23,680 --> 00:01:27,840
it was too quiet let's see now

26
00:01:28,880 --> 00:01:31,200
these are three algorithms namely the

27
00:01:31,200 --> 00:01:33,600
generation of research which produces a

28
00:01:33,600 --> 00:01:36,079
pro marquee and attraction key the

29
00:01:36,079 --> 00:01:38,880
marking of result which and banned a

30
00:01:38,880 --> 00:01:41,280
message into a program with a button key

31
00:01:41,280 --> 00:01:43,600
and the question algorithm which

32
00:01:43,600 --> 00:01:45,680
abandons the uh which attracts a message

33
00:01:45,680 --> 00:01:48,799
and by the new watermark circuit with an

34
00:01:48,799 --> 00:01:50,399
extraction key

35
00:01:50,399 --> 00:01:52,960
it's correctness requested what marked

36
00:01:52,960 --> 00:01:54,560
circles should

37
00:01:54,560 --> 00:01:56,880
roughly preserves the opportunity of the

38
00:01:56,880 --> 00:01:58,240
original

39
00:01:58,240 --> 00:01:59,520
program

40
00:01:59,520 --> 00:02:00,640
and that

41
00:02:00,640 --> 00:02:03,040
the attraction organism can attract the

42
00:02:03,040 --> 00:02:06,000
correct message and bandit

43
00:02:06,000 --> 00:02:07,520
yeah honestly

44
00:02:07,520 --> 00:02:10,639
watermarks circuit

45
00:02:10,639 --> 00:02:12,879
its mystical decrement is on

46
00:02:12,879 --> 00:02:15,520
removability which represent

47
00:02:15,520 --> 00:02:18,400
it will be computationally difficult for

48
00:02:18,400 --> 00:02:21,520
industry to remove or modify the message

49
00:02:21,520 --> 00:02:23,920
and bend it in automatic circuit

50
00:02:23,920 --> 00:02:26,959
without changing it's too much

51
00:02:26,959 --> 00:02:28,720
so when we hope to have watermark

52
00:02:28,720 --> 00:02:31,599
schemes for general functionalities

53
00:02:31,599 --> 00:02:35,680
however as shown by coherent on 2016

54
00:02:35,680 --> 00:02:37,760
it is impossible to watermark a

55
00:02:37,760 --> 00:02:40,319
learnable functionality

56
00:02:40,319 --> 00:02:42,400
a natural class of non-vulnerable

57
00:02:42,400 --> 00:02:44,160
functionalities are the cryptographic

58
00:02:44,160 --> 00:02:47,360
ones such as decryption organism the pf

59
00:02:47,360 --> 00:02:50,640
evolutionary sum and so on so in the

60
00:02:50,640 --> 00:02:53,440
study we mainly focus on what market

61
00:02:53,440 --> 00:02:56,319
schemes for cryptographic programs

62
00:02:56,319 --> 00:02:59,680
and in this work we also follow this and

63
00:02:59,680 --> 00:03:02,239
particularly focus on

64
00:03:02,239 --> 00:03:06,640
the election algorithm of the prf

65
00:03:06,640 --> 00:03:07,519
so

66
00:03:07,519 --> 00:03:09,920
next we give a more formal definition of

67
00:03:09,920 --> 00:03:12,640
the security of the automatic scheme for

68
00:03:12,640 --> 00:03:14,319
prf

69
00:03:14,319 --> 00:03:16,560
there are two practices involved in the

70
00:03:16,560 --> 00:03:18,879
security definition a challenger and

71
00:03:18,879 --> 00:03:21,200
unknown three the challenger will first

72
00:03:21,200 --> 00:03:22,800
generate a pair of marquee and

73
00:03:22,800 --> 00:03:24,000
attraction kit

74
00:03:24,000 --> 00:03:27,440
and it also samples a pf key

75
00:03:27,440 --> 00:03:29,599
then those three

76
00:03:29,599 --> 00:03:31,760
sends a message to the challenger and

77
00:03:31,760 --> 00:03:34,239
the challenge will embarrass the message

78
00:03:34,239 --> 00:03:37,519
into the pfk with the marker key

79
00:03:37,519 --> 00:03:40,000
it then sends the

80
00:03:40,000 --> 00:03:43,120
results security star to those three and

81
00:03:43,120 --> 00:03:45,680
those three will create a circular

82
00:03:45,680 --> 00:03:46,959
substitute

83
00:03:46,959 --> 00:03:50,319
and it wins if situated is close to the

84
00:03:50,319 --> 00:03:53,519
original watermarked circular system

85
00:03:53,519 --> 00:03:56,319
and the threshing algorithm fails to

86
00:03:56,319 --> 00:03:59,760
attract the original message from secure

87
00:03:59,760 --> 00:04:02,400
in this definition we do not allow the

88
00:04:02,400 --> 00:04:05,519
adultery to learn either the button k or

89
00:04:05,519 --> 00:04:07,439
the expression key

90
00:04:07,439 --> 00:04:11,280
so we denote it as clicky script here

91
00:04:11,280 --> 00:04:14,000
we can also consider a strong adultery

92
00:04:14,000 --> 00:04:17,040
that can learn the market of the

93
00:04:17,040 --> 00:04:19,440
automatic scheme and this is called

94
00:04:19,440 --> 00:04:22,079
public marketing security

95
00:04:22,079 --> 00:04:24,400
alternatively we can consider a

96
00:04:24,400 --> 00:04:28,400
groceries at least threshing key but

97
00:04:28,400 --> 00:04:30,960
and this is denoted as publication

98
00:04:30,960 --> 00:04:33,040
public integration security

99
00:04:33,040 --> 00:04:35,360
and finally we can consider public key

100
00:04:35,360 --> 00:04:37,919
security whereas the authority learns

101
00:04:37,919 --> 00:04:42,240
pulls the marquee and expression key

102
00:04:42,240 --> 00:04:44,880
so in real world applications if we use

103
00:04:44,880 --> 00:04:46,479
a watermarking scheme

104
00:04:46,479 --> 00:04:49,520
with the first three security guarantees

105
00:04:49,520 --> 00:04:51,199
we will have to set up a watermark

106
00:04:51,199 --> 00:04:53,199
consolidate to hold either the

107
00:04:53,199 --> 00:04:57,199
marketplace or the electricity of both

108
00:04:57,199 --> 00:05:00,639
such specialty is usually a single point

109
00:05:00,639 --> 00:05:03,759
of failure because if those three crops

110
00:05:03,759 --> 00:05:06,960
the ultimate conservative and gets the

111
00:05:06,960 --> 00:05:10,560
keyhole there then it is able to

112
00:05:10,560 --> 00:05:11,680
remove

113
00:05:11,680 --> 00:05:14,479
all messages invented in all

114
00:05:14,479 --> 00:05:16,400
watermark security

115
00:05:16,400 --> 00:05:18,000
this is a

116
00:05:18,000 --> 00:05:20,240
serious security

117
00:05:20,240 --> 00:05:24,320
threat to the scheme

118
00:05:24,320 --> 00:05:27,759
and if we use a automatic scheme with

119
00:05:27,759 --> 00:05:29,360
public security

120
00:05:29,360 --> 00:05:32,320
then we do not need such authority and

121
00:05:32,320 --> 00:05:34,479
the problem can be resolved

122
00:05:34,479 --> 00:05:37,759
so in practice it it is preferable to

123
00:05:37,759 --> 00:05:39,360
use a

124
00:05:39,360 --> 00:05:40,960
watermarking scheme with public key

125
00:05:40,960 --> 00:05:43,199
security

126
00:05:43,199 --> 00:05:44,720
unfortunately

127
00:05:44,720 --> 00:05:47,120
also we have very elegant constructions

128
00:05:47,120 --> 00:05:49,759
of debugging schemes that satisfy the

129
00:05:49,759 --> 00:05:52,800
first three security requirements we do

130
00:05:52,800 --> 00:05:54,560
not know how to construct a publicly

131
00:05:54,560 --> 00:05:57,520
automatical prf

132
00:05:57,840 --> 00:06:00,240
the goal of this work is therefore to

133
00:06:00,240 --> 00:06:01,440
construct

134
00:06:01,440 --> 00:06:02,319
the

135
00:06:02,319 --> 00:06:05,600
public key with micro pif

136
00:06:05,600 --> 00:06:08,240
so next we will see how to construct a

137
00:06:08,240 --> 00:06:10,400
public key automaker api

138
00:06:10,400 --> 00:06:13,199
our standpoint is a automatic kiss with

139
00:06:13,199 --> 00:06:16,000
public trashing and supermarket

140
00:06:16,000 --> 00:06:18,479
in this scheme there is a

141
00:06:18,479 --> 00:06:21,600
easy scheme the pfk

142
00:06:21,600 --> 00:06:24,479
page should be kept private and to embed

143
00:06:24,479 --> 00:06:25,680
a message

144
00:06:25,680 --> 00:06:27,520
into the pfk

145
00:06:27,520 --> 00:06:31,520
the mechanism will use a secret marquee

146
00:06:31,520 --> 00:06:34,000
and to extract a message from a

147
00:06:34,000 --> 00:06:36,479
watermark secret the creation algorithm

148
00:06:36,479 --> 00:06:40,160
will use a public tracking key

149
00:06:40,160 --> 00:06:42,400
so with this scheme

150
00:06:42,400 --> 00:06:44,800
to construct a public keyword macro pif

151
00:06:44,800 --> 00:06:46,160
our initial

152
00:06:46,160 --> 00:06:47,600
idea is to

153
00:06:47,600 --> 00:06:50,000
generate a fresh marquee and attraction

154
00:06:50,000 --> 00:06:53,039
key for each pfk

155
00:06:53,039 --> 00:06:57,599
that is the new cafe capital key now

156
00:06:57,599 --> 00:07:00,319
includes the original pfk

157
00:07:00,319 --> 00:07:03,120
flash market k and a fresh attraction

158
00:07:03,120 --> 00:07:05,280
kit

159
00:07:05,680 --> 00:07:07,840
in this way the

160
00:07:07,840 --> 00:07:09,120
there is no

161
00:07:09,120 --> 00:07:10,560
global marketing case that should be

162
00:07:10,560 --> 00:07:13,520
kept private so the scheme should have

163
00:07:13,520 --> 00:07:14,840
publicly

164
00:07:14,840 --> 00:07:16,479
security

165
00:07:16,479 --> 00:07:18,319
after this modification the marking

166
00:07:18,319 --> 00:07:20,479
algorithm can still work because it can

167
00:07:20,479 --> 00:07:24,560
use the marker key included in the prk

168
00:07:24,560 --> 00:07:26,800
but the question version doesn't work

169
00:07:26,800 --> 00:07:27,919
now

170
00:07:27,919 --> 00:07:30,319
because it needs the two needs to use

171
00:07:30,319 --> 00:07:32,080
the tracking key

172
00:07:32,080 --> 00:07:33,919
but the changing key

173
00:07:33,919 --> 00:07:36,400
is included in the prk and can't be

174
00:07:36,400 --> 00:07:40,000
accessed by the traditional result

175
00:07:40,000 --> 00:07:42,000
to solve this problem we need a

176
00:07:42,000 --> 00:07:43,919
mechanism to send decay to the

177
00:07:43,919 --> 00:07:46,000
extraction occlusal

178
00:07:46,000 --> 00:07:48,720
it seems that the only way to do this is

179
00:07:48,720 --> 00:07:52,240
to put ek to the pf output

180
00:07:52,240 --> 00:07:54,240
and of course we can't

181
00:07:54,240 --> 00:07:56,080
append it

182
00:07:56,080 --> 00:07:59,599
to the pf output directly because it may

183
00:07:59,599 --> 00:08:03,520
ruin the certainties of the prf

184
00:08:03,520 --> 00:08:06,479
we solve this problem by using a pd

185
00:08:06,479 --> 00:08:10,080
scheme with sudden subtext

186
00:08:10,080 --> 00:08:10,960
so

187
00:08:10,960 --> 00:08:13,680
let pk and sk be the

188
00:08:13,680 --> 00:08:16,240
publicly and security pair of the piggy

189
00:08:16,240 --> 00:08:17,120
scheme

190
00:08:17,120 --> 00:08:19,440
and put them into the public parameter

191
00:08:19,440 --> 00:08:21,759
of the opening scale

192
00:08:21,759 --> 00:08:24,319
we also modify the

193
00:08:24,319 --> 00:08:26,960
pf evaluation algorithm and

194
00:08:26,960 --> 00:08:30,080
append an increasing of the expression k

195
00:08:30,080 --> 00:08:32,559
to the original pf output

196
00:08:32,559 --> 00:08:34,958
here the randomness for the inclusion is

197
00:08:34,958 --> 00:08:38,799
determined by the input x

198
00:08:38,799 --> 00:08:40,640
to watermark uh

199
00:08:40,640 --> 00:08:43,200
pfk the mechanologism

200
00:08:43,200 --> 00:08:44,140
also

201
00:08:44,140 --> 00:08:45,519
[Music]

202
00:08:45,519 --> 00:08:48,000
combines the message into the first part

203
00:08:48,000 --> 00:08:49,120
of the

204
00:08:49,120 --> 00:08:50,320
prf

205
00:08:50,320 --> 00:08:52,080
evolution and result

206
00:08:52,080 --> 00:08:54,320
and then it keeps the second part of the

207
00:08:54,320 --> 00:08:57,279
solution unchanged

208
00:08:57,279 --> 00:09:00,640
and to extract a message from the

209
00:09:00,640 --> 00:09:03,440
watermarked circuit the cutting orgasm

210
00:09:03,440 --> 00:09:05,040
will first

211
00:09:05,040 --> 00:09:07,120
get decayed from the second part of the

212
00:09:07,120 --> 00:09:09,839
circular port by decrypting it

213
00:09:09,839 --> 00:09:12,160
then it uses it

214
00:09:12,160 --> 00:09:13,839
it uses the

215
00:09:13,839 --> 00:09:16,320
record extraction key to extract the

216
00:09:16,320 --> 00:09:18,080
message from the first part of the

217
00:09:18,080 --> 00:09:20,640
security

218
00:09:21,040 --> 00:09:22,640
so

219
00:09:22,640 --> 00:09:24,880
as the adult three is

220
00:09:24,880 --> 00:09:26,880
only allowed to modify the automatic

221
00:09:26,880 --> 00:09:30,000
circuit on the spot version of inputs

222
00:09:30,000 --> 00:09:34,959
uh the threshold are likely to get the

223
00:09:34,959 --> 00:09:38,399
correct objection k by decreasing the

224
00:09:38,399 --> 00:09:41,399
success

225
00:09:41,600 --> 00:09:44,600
and then by the security of the online

226
00:09:44,600 --> 00:09:48,080
publicly trackable automatically if

227
00:09:48,080 --> 00:09:49,920
the traditional algorithm can finally

228
00:09:49,920 --> 00:09:51,760
get a correct message

229
00:09:51,760 --> 00:09:55,200
so the security follows

230
00:09:55,200 --> 00:09:56,880
also we need to

231
00:09:56,880 --> 00:10:00,640
examine if the scheme has surveillance

232
00:10:00,640 --> 00:10:02,959
at first guys the answer should be yes

233
00:10:02,959 --> 00:10:04,720
because the

234
00:10:04,720 --> 00:10:07,680
pf output now includes two parts the

235
00:10:07,680 --> 00:10:09,200
first part is

236
00:10:09,200 --> 00:10:11,360
the output of another prf and the second

237
00:10:11,360 --> 00:10:14,399
part is the soft text or pc scheme with

238
00:10:14,399 --> 00:10:17,120
pseudo random soft text

239
00:10:17,120 --> 00:10:20,000
however the subtext suffering needs only

240
00:10:20,000 --> 00:10:22,320
holds against adultery without a secret

241
00:10:22,320 --> 00:10:24,800
key and now as the secret key is put

242
00:10:24,800 --> 00:10:26,240
into the

243
00:10:26,240 --> 00:10:27,440
parameter

244
00:10:27,440 --> 00:10:29,920
the doctor can learn it and saying it

245
00:10:29,920 --> 00:10:33,200
can decrease the certain parts of the pr

246
00:10:33,200 --> 00:10:35,760
outputs and see if they are all

247
00:10:35,760 --> 00:10:37,839
decrypted to a symbol

248
00:10:37,839 --> 00:10:40,880
so it is very easy to distinguish it

249
00:10:40,880 --> 00:10:42,320
from

250
00:10:42,320 --> 00:10:46,560
from the output of a random function

251
00:10:46,560 --> 00:10:50,079
to solve this problem we use a robust of

252
00:10:50,079 --> 00:10:54,320
approximate prf instead of the pt scheme

253
00:10:54,320 --> 00:10:56,399
in a nutshell the

254
00:10:56,399 --> 00:11:00,240
robust of classical prf is prf family

255
00:11:00,240 --> 00:11:03,440
where the pfk is associated with the

256
00:11:03,440 --> 00:11:06,000
screen s

257
00:11:06,000 --> 00:11:08,560
a student still requires that giving

258
00:11:08,560 --> 00:11:11,760
only all process to the pf area result

259
00:11:11,760 --> 00:11:13,760
no one could distinguish it from a

260
00:11:13,760 --> 00:11:16,399
random function

261
00:11:16,399 --> 00:11:19,680
but it now additionally requires that it

262
00:11:19,680 --> 00:11:22,000
is easy to get to screen s and binding

263
00:11:22,000 --> 00:11:24,160
in the pfk

264
00:11:24,160 --> 00:11:26,839
giving a circle that implants

265
00:11:26,839 --> 00:11:30,720
the pf electric algorithm

266
00:11:30,720 --> 00:11:32,959
and based on this we also need it to

267
00:11:32,959 --> 00:11:35,600
have robust vulnerability which requires

268
00:11:35,600 --> 00:11:38,079
that the secret can be recovered from a

269
00:11:38,079 --> 00:11:40,959
circuit that is close to the pr illusion

270
00:11:40,959 --> 00:11:43,360
of result

271
00:11:43,360 --> 00:11:44,160
okay

272
00:11:44,160 --> 00:11:47,519
so now it's a robust one of basketball

273
00:11:47,519 --> 00:11:48,720
prf

274
00:11:48,720 --> 00:11:52,240
we modify the construction as follows

275
00:11:52,240 --> 00:11:55,760
first we will include the pfk of the

276
00:11:55,760 --> 00:11:58,560
underlying robust of the fast capable

277
00:11:58,560 --> 00:12:02,079
prf into the pfk of the constructed

278
00:12:02,079 --> 00:12:03,760
automarketing scheme

279
00:12:03,760 --> 00:12:07,360
and the security embedded there is the

280
00:12:07,360 --> 00:12:09,600
creation key

281
00:12:09,600 --> 00:12:12,160
for the prk

282
00:12:12,160 --> 00:12:13,600
we also

283
00:12:13,600 --> 00:12:17,360
replace the subtext in the pf output

284
00:12:17,360 --> 00:12:22,720
with the output of the on object for prf

285
00:12:22,720 --> 00:12:25,920
the orgasm still works at big4

286
00:12:25,920 --> 00:12:28,240
that is it combines the message into the

287
00:12:28,240 --> 00:12:30,639
first part of the pf evaluation organism

288
00:12:30,639 --> 00:12:33,839
and remains a second part on change

289
00:12:33,839 --> 00:12:36,480
and the creation of concern now getting

290
00:12:36,480 --> 00:12:39,279
k from the second part of the second the

291
00:12:39,279 --> 00:12:42,480
giving circuit and then it uses a

292
00:12:42,480 --> 00:12:45,600
the recovery key to

293
00:12:45,600 --> 00:12:48,480
get the tool to collect the message from

294
00:12:48,480 --> 00:12:52,720
the first part of the security

295
00:12:52,720 --> 00:12:55,680
uh this works because uh

296
00:12:55,680 --> 00:12:57,200
due to the

297
00:12:57,200 --> 00:13:00,320
liability of the of of fascicle

298
00:13:00,320 --> 00:13:01,519
prf

299
00:13:01,519 --> 00:13:04,560
the treasure also can get the corrective

300
00:13:04,560 --> 00:13:08,079
key from the second part

301
00:13:08,079 --> 00:13:10,880
also the robust nubility

302
00:13:10,880 --> 00:13:12,560
further guaranteeing that

303
00:13:12,560 --> 00:13:14,560
the creation algorithm can get a correct

304
00:13:14,560 --> 00:13:17,440
uk from the second part of the watermark

305
00:13:17,440 --> 00:13:20,720
circle even if it is modified by the

306
00:13:20,720 --> 00:13:22,880
adultery

307
00:13:22,880 --> 00:13:24,959
and then by security

308
00:13:24,959 --> 00:13:27,360
of the online publicly created

309
00:13:27,360 --> 00:13:29,519
automatically if

310
00:13:29,519 --> 00:13:31,360
the attraction algorithm can get a

311
00:13:31,360 --> 00:13:33,279
correct message from

312
00:13:33,279 --> 00:13:35,920
watermark circles that has been changed

313
00:13:35,920 --> 00:13:38,079
by the adults recently

314
00:13:38,079 --> 00:13:40,639
so the security follows now

315
00:13:40,639 --> 00:13:43,519
also the pluralness of the new

316
00:13:43,519 --> 00:13:45,440
construction comes from the

317
00:13:45,440 --> 00:13:47,680
sovereignness of the publicly

318
00:13:47,680 --> 00:13:49,680
transformational pif

319
00:13:49,680 --> 00:13:54,000
and that i was a robust of the small plf

320
00:13:54,000 --> 00:13:56,800
and also the strongest holds

321
00:13:56,800 --> 00:13:58,800
so

322
00:13:58,800 --> 00:14:01,839
we have shown how to construct a public

323
00:14:01,839 --> 00:14:04,720
key watermark no pif from automotive pis

324
00:14:04,720 --> 00:14:06,560
with perpetuation

325
00:14:06,560 --> 00:14:10,160
and a robust opportunity prf

326
00:14:10,160 --> 00:14:11,920
the first building block can be

327
00:14:11,920 --> 00:14:14,240
constructed from indistinguishability of

328
00:14:14,240 --> 00:14:16,480
execution as joined by coherent how in

329
00:14:16,480 --> 00:14:18,079
2016.

330
00:14:18,079 --> 00:14:20,959
and in this work we give constructions

331
00:14:20,959 --> 00:14:22,560
on robust

332
00:14:22,560 --> 00:14:25,600
object fast keyboard qrfs from either

333
00:14:25,600 --> 00:14:28,880
one function or fpg with different

334
00:14:28,880 --> 00:14:33,120
tradeoffs in their parameters

335
00:14:33,680 --> 00:14:34,720
okay

336
00:14:34,720 --> 00:14:37,199
so before continuing our discussion we

337
00:14:37,199 --> 00:14:39,279
recall our first

338
00:14:39,279 --> 00:14:40,959
attempt again

339
00:14:40,959 --> 00:14:43,519
the attempt fields because the threshing

340
00:14:43,519 --> 00:14:46,959
episode can't get to the traction key to

341
00:14:46,959 --> 00:14:50,880
perform the pressure procedure

342
00:14:50,880 --> 00:14:52,800
so

343
00:14:52,800 --> 00:14:54,240
we note that

344
00:14:54,240 --> 00:14:55,680
this

345
00:14:55,680 --> 00:14:58,880
if we consider a weak notion of marking

346
00:14:58,880 --> 00:15:01,440
where the threshold rhythm is

347
00:15:01,440 --> 00:15:06,240
allowed to use a hint part of the pfk

348
00:15:06,240 --> 00:15:08,560
then this problem

349
00:15:08,560 --> 00:15:11,279
can be solved very easily by setting the

350
00:15:11,279 --> 00:15:14,480
hint to be the attraction key

351
00:15:14,480 --> 00:15:16,880
so because it's a shrinking automatic

352
00:15:16,880 --> 00:15:18,399
prf

353
00:15:18,399 --> 00:15:21,199
and by using this new notion

354
00:15:21,199 --> 00:15:23,360
we can divide our

355
00:15:23,360 --> 00:15:26,800
construction transmission into two parts

356
00:15:26,800 --> 00:15:29,040
in the first part we get a publicly

357
00:15:29,040 --> 00:15:31,120
thinking with micro prior from old micro

358
00:15:31,120 --> 00:15:33,360
prior to publication

359
00:15:33,360 --> 00:15:36,560
and in the second part we upgrade the

360
00:15:36,560 --> 00:15:39,759
publication rpf to be a standalone

361
00:15:39,759 --> 00:15:43,360
public key automatic rf using a robust

362
00:15:43,360 --> 00:15:46,800
of basketball prf

363
00:15:47,759 --> 00:15:48,560
okay

364
00:15:48,560 --> 00:15:50,160
so

365
00:15:50,160 --> 00:15:53,040
next we will see how to get public

366
00:15:53,040 --> 00:15:54,639
automatically have

367
00:15:54,639 --> 00:15:57,519
from simple assumptions

368
00:15:57,519 --> 00:16:00,000
thanks to our general framework

369
00:16:00,000 --> 00:16:02,480
it is sufficient to show how to

370
00:16:02,480 --> 00:16:05,199
construct public thinking watermark pif

371
00:16:05,199 --> 00:16:08,920
from simpler assumptions

372
00:16:08,959 --> 00:16:11,759
so the construction

373
00:16:11,759 --> 00:16:15,680
is built on a proper f

374
00:16:16,480 --> 00:16:19,440
roughly speaking a particular pif allows

375
00:16:19,440 --> 00:16:20,560
one to

376
00:16:20,560 --> 00:16:25,040
puncture pfk i import extra

377
00:16:25,040 --> 00:16:28,079
the function key functions authentically

378
00:16:28,079 --> 00:16:32,720
as engine okay on all other inputs

379
00:16:32,720 --> 00:16:36,320
and it will hide the view output without

380
00:16:36,320 --> 00:16:38,720
pf output on

381
00:16:38,720 --> 00:16:40,079
the function

382
00:16:40,079 --> 00:16:43,040
point extra

383
00:16:43,199 --> 00:16:47,040
so now with a pointer pif we construct

384
00:16:47,040 --> 00:16:49,680
the publicly hinted automatic pif as

385
00:16:49,680 --> 00:16:51,120
follows

386
00:16:51,120 --> 00:16:54,959
the new prf k capital k includes the prk

387
00:16:54,959 --> 00:16:57,040
of the punctual pif

388
00:16:57,040 --> 00:16:58,320
and

389
00:16:58,320 --> 00:17:01,040
random input x star

390
00:17:01,040 --> 00:17:04,720
we also compute the pf output y star of

391
00:17:04,720 --> 00:17:06,400
x star

392
00:17:06,400 --> 00:17:09,919
and compute this star as g of y star

393
00:17:09,919 --> 00:17:13,839
where g is an objective one function

394
00:17:13,839 --> 00:17:15,760
the hint is

395
00:17:15,760 --> 00:17:18,799
retained they include a star at this

396
00:17:18,799 --> 00:17:21,119
time

397
00:17:21,199 --> 00:17:24,720
to watermark a pf evolution of reserve

398
00:17:24,720 --> 00:17:28,240
the microorganism just

399
00:17:28,319 --> 00:17:31,840
punctures the prfk on

400
00:17:31,840 --> 00:17:35,440
and the circuit will evaluate with a

401
00:17:35,440 --> 00:17:37,600
punctured key

402
00:17:37,600 --> 00:17:40,960
also to test if the

403
00:17:40,960 --> 00:17:43,760
uh circuit is work marked the pressure

404
00:17:43,760 --> 00:17:46,080
algorithm will test if the security is

405
00:17:46,080 --> 00:17:47,840
functional or extra

406
00:17:47,840 --> 00:17:51,200
that is if the circuit if the security

407
00:17:51,200 --> 00:17:53,840
error is

408
00:17:54,559 --> 00:17:55,919
that is if

409
00:17:55,919 --> 00:17:58,640
cx star is not equal to y star

410
00:17:58,640 --> 00:18:02,080
since g is an injective function it is

411
00:18:02,080 --> 00:18:04,880
equivalent to test if g

412
00:18:04,880 --> 00:18:08,480
c g of c of x star is not equal to this

413
00:18:08,480 --> 00:18:09,919
star

414
00:18:09,919 --> 00:18:12,880
this can be finished by using only the

415
00:18:12,880 --> 00:18:15,440
information from the hint and the

416
00:18:15,440 --> 00:18:19,360
queries under the giving security

417
00:18:19,600 --> 00:18:20,799
so

418
00:18:20,799 --> 00:18:23,919
also the security of the

419
00:18:23,919 --> 00:18:25,840
injected worm function and the security

420
00:18:25,840 --> 00:18:27,679
of the puncture pis

421
00:18:27,679 --> 00:18:28,559
that

422
00:18:28,559 --> 00:18:31,280
the dos 3 is not able to learn 1 star

423
00:18:31,280 --> 00:18:33,440
from the current and the automatic

424
00:18:33,440 --> 00:18:34,720
circuit

425
00:18:34,720 --> 00:18:37,120
so it is not able to

426
00:18:37,120 --> 00:18:38,080
generate

427
00:18:38,080 --> 00:18:40,480
circuits that are pushed faster on input

428
00:18:40,480 --> 00:18:42,320
extra

429
00:18:42,320 --> 00:18:44,080
and thus

430
00:18:44,080 --> 00:18:46,639
it can't

431
00:18:46,880 --> 00:18:49,919
make a watermark circulate or marked

432
00:18:49,919 --> 00:18:53,200
and the security follows

433
00:18:54,000 --> 00:18:56,960
okay so by putting the

434
00:18:56,960 --> 00:18:59,919
about construction into our blueprint

435
00:18:59,919 --> 00:19:03,440
we get a publicly automatic pif

436
00:19:03,440 --> 00:19:05,919
from either one function or one-way

437
00:19:05,919 --> 00:19:09,120
function plus fft

438
00:19:09,200 --> 00:19:12,720
with different shadows in the parameters

439
00:19:12,720 --> 00:19:14,960
the construction has a restriction that

440
00:19:14,960 --> 00:19:18,559
it only supports mac binding that is a

441
00:19:18,559 --> 00:19:22,160
circuit is either marked or unmarked

442
00:19:22,160 --> 00:19:25,760
and unlike the construction from ro

443
00:19:25,760 --> 00:19:30,080
which has message and binding

444
00:19:30,160 --> 00:19:32,240
we also give a

445
00:19:32,240 --> 00:19:34,559
construction our machine binding public

446
00:19:34,559 --> 00:19:36,880
key automatic prf from

447
00:19:36,880 --> 00:19:40,000
purely from standalone assumptions

448
00:19:40,000 --> 00:19:43,440
uh by using a quantitative scheme

449
00:19:43,440 --> 00:19:45,679
please you know see our four people for

450
00:19:45,679 --> 00:19:48,480
the construction

451
00:19:49,440 --> 00:19:50,700
okay so

452
00:19:50,700 --> 00:19:51,760
[Music]

453
00:19:51,760 --> 00:19:54,480
to conclude in this work we give a

454
00:19:54,480 --> 00:19:56,720
general flow general forward that

455
00:19:56,720 --> 00:19:59,120
construct publicly automatically pif

456
00:19:59,120 --> 00:20:01,760
from a public thinking automatic pif and

457
00:20:01,760 --> 00:20:05,840
a robust of vascular

458
00:20:05,840 --> 00:20:08,240
we also insatiate

459
00:20:08,240 --> 00:20:10,159
both primitive from different

460
00:20:10,159 --> 00:20:14,000
assumptions with different tradeoffs

461
00:20:14,080 --> 00:20:16,720
the main tradeoffs we considered in this

462
00:20:16,720 --> 00:20:18,320
work

463
00:20:18,320 --> 00:20:20,720
include whether the scheme

464
00:20:20,720 --> 00:20:23,600
uh support message binding and the how

465
00:20:23,600 --> 00:20:26,799
large the perimeter emission is

466
00:20:26,799 --> 00:20:28,640
the perimeter of snow

467
00:20:28,640 --> 00:20:32,320
denotes the version of impulse

468
00:20:32,320 --> 00:20:35,520
of c star that can be modified by the

469
00:20:35,520 --> 00:20:38,080
rosary

470
00:20:38,480 --> 00:20:39,600
and

471
00:20:39,600 --> 00:20:43,039
if you observe our results

472
00:20:43,039 --> 00:20:46,880
you will see if you hope to have to to

473
00:20:46,880 --> 00:20:49,840
have methane binding and if you don't

474
00:20:49,840 --> 00:20:51,760
want to use ro

475
00:20:51,760 --> 00:20:54,559
then you will have a very very

476
00:20:54,559 --> 00:20:58,799
small x node which is

477
00:20:59,440 --> 00:21:00,960
concrete

478
00:21:00,960 --> 00:21:04,640
exponentially small volume

479
00:21:04,640 --> 00:21:08,720
also if you hope to have constant xl

480
00:21:08,720 --> 00:21:12,640
then you have to use fg even if you have

481
00:21:12,640 --> 00:21:14,240
you have used

482
00:21:14,240 --> 00:21:15,440
ro

483
00:21:15,440 --> 00:21:18,799
and finally none of us constructions can

484
00:21:18,799 --> 00:21:20,559
achieve the optimal

485
00:21:20,559 --> 00:21:21,679
uh

486
00:21:21,679 --> 00:21:25,200
epsilon which is roughly 102.

487
00:21:25,200 --> 00:21:28,799
so it is an interesting open problem to

488
00:21:28,799 --> 00:21:31,200
construct publicly automatic pifs

489
00:21:31,200 --> 00:21:34,720
without the restrictions

490
00:21:34,720 --> 00:21:35,919
so

491
00:21:35,919 --> 00:21:38,000
now to conclude

492
00:21:38,000 --> 00:21:40,960
in this work we

493
00:21:40,960 --> 00:21:43,919
initiate the study of public key

494
00:21:43,919 --> 00:21:46,559
automatically prf

495
00:21:46,559 --> 00:21:49,360
and that is just a start there are many

496
00:21:49,360 --> 00:21:52,640
many interesting problems in this area

497
00:21:52,640 --> 00:21:55,520
okay so that's all thanks for attending

498
00:21:55,520 --> 00:21:59,840
and i'm happy to answer questions

499
00:22:00,159 --> 00:22:02,720
thank you

500
00:22:04,159 --> 00:22:07,039
any questions

501
00:22:10,240 --> 00:22:13,280
i have two quick questions uh

502
00:22:13,280 --> 00:22:15,600
first uh and maybe i missed it in the

503
00:22:15,600 --> 00:22:17,280
first slide i was setting up can you

504
00:22:17,280 --> 00:22:20,000
comment on the applications for your

505
00:22:20,000 --> 00:22:22,559
primitive and sorry if i missed it and

506
00:22:22,559 --> 00:22:24,400
the second question is

507
00:22:24,400 --> 00:22:25,200
uh

508
00:22:25,200 --> 00:22:27,760
what is one over x how is it different

509
00:22:27,760 --> 00:22:28,799
from

510
00:22:28,799 --> 00:22:33,039
negligible uh in the last slide

511
00:22:33,039 --> 00:22:35,600
uh all right uh so the first question is

512
00:22:35,600 --> 00:22:37,919
about uh what is a publication or what

513
00:22:37,919 --> 00:22:39,679
markov pr right

514
00:22:39,679 --> 00:22:40,960
yeah

515
00:22:40,960 --> 00:22:43,919
yeah okay so a wordpress can be used to

516
00:22:43,919 --> 00:22:47,520
construct uh what microphone uh schemes

517
00:22:47,520 --> 00:22:49,600
uh in the mini crypt such as what

518
00:22:49,600 --> 00:22:52,000
microphone uh sticky inclusion with

519
00:22:52,000 --> 00:22:55,600
multiple mac and so on and also

520
00:22:55,600 --> 00:22:57,840
the techniques developed to construct

521
00:22:57,840 --> 00:23:00,000
what type of pis may be used to

522
00:23:00,000 --> 00:23:02,480
construct other target schemes

523
00:23:02,480 --> 00:23:05,760
especially a cat is unlike a

524
00:23:05,760 --> 00:23:08,480
pte scheme

525
00:23:14,640 --> 00:23:17,840
we need to consider uh how to deal with

526
00:23:17,840 --> 00:23:19,840
all the imports so

527
00:23:19,840 --> 00:23:21,039
uh

528
00:23:21,039 --> 00:23:24,799
for ppe scheme we only need to

529
00:23:24,960 --> 00:23:27,760
consider how to deal with the valid

530
00:23:27,760 --> 00:23:30,159
input that is the honest

531
00:23:30,159 --> 00:23:31,520
substance

532
00:23:31,520 --> 00:23:31,760
so

533
00:23:31,760 --> 00:23:33,039
[Music]

534
00:23:33,039 --> 00:23:35,520
i think

535
00:23:47,440 --> 00:23:49,279
so the

536
00:23:49,279 --> 00:23:52,720
parameter excel is what or

537
00:23:52,720 --> 00:23:55,840
exponential is the industry is only

538
00:23:55,840 --> 00:23:56,960
allowed to

539
00:23:56,960 --> 00:23:59,200
extract

540
00:23:59,200 --> 00:24:02,080
allow the tool to modify the particular

541
00:24:02,080 --> 00:24:07,120
our computer exponentially small uh

542
00:24:08,080 --> 00:24:10,640
small volume for example it can be made

543
00:24:10,640 --> 00:24:13,200
to be 1 over 2

544
00:24:13,200 --> 00:24:15,919
y over 2 to the a

545
00:24:15,919 --> 00:24:18,799
such as that but when we when it is

546
00:24:18,799 --> 00:24:21,520
negligible it can be any negligible

547
00:24:21,520 --> 00:24:22,480
function

548
00:24:22,480 --> 00:24:25,360
so we can't have a predefined value on

549
00:24:25,360 --> 00:24:27,279
it

550
00:24:27,279 --> 00:24:29,760
let's answer your question

551
00:24:29,760 --> 00:24:30,799
okay

552
00:24:30,799 --> 00:24:33,200
thank you very much okay let's thank the

553
00:24:33,200 --> 00:24:36,000
speaker again

554
00:24:38,480 --> 00:24:40,720
thank you and the

555
00:24:40,720 --> 00:24:43,840
next talk of this session is called chip

556
00:24:43,840 --> 00:24:46,640
and chris protecting all parties against

557
00:24:46,640 --> 00:24:49,520
compromise through identity binding

558
00:24:49,520 --> 00:24:50,559
fakes

559
00:24:50,559 --> 00:24:53,919
by cass grammers money now shahar pass

560
00:24:53,919 --> 00:24:59,480
and ale ronan and ayal will give

561
00:25:13,679 --> 00:25:15,279
yeah this is the stream in this

562
00:25:15,279 --> 00:25:18,279
application

563
00:25:30,640 --> 00:25:32,799
one one one yes

564
00:25:32,799 --> 00:25:34,559
okay um

565
00:25:34,559 --> 00:25:35,760
can you hear me

566
00:25:35,760 --> 00:25:38,000
okay thank you for the introduction

567
00:25:38,000 --> 00:25:39,200
and uh

568
00:25:39,200 --> 00:25:41,520
mentioned this is a joint work and uh

569
00:25:41,520 --> 00:25:43,919
i'm really sad that um student shah

570
00:25:43,919 --> 00:25:45,279
couldn't be here to give the talk

571
00:25:45,279 --> 00:25:47,760
because he did most of the heavy lifting

572
00:25:47,760 --> 00:25:49,200
but

573
00:25:49,200 --> 00:25:51,120
we'll try not to take too much of his

574
00:25:51,120 --> 00:25:52,320
credit

575
00:25:52,320 --> 00:25:53,360
um

576
00:25:53,360 --> 00:25:54,400
so

577
00:25:54,400 --> 00:25:55,760
the first thing that we need to talk

578
00:25:55,760 --> 00:25:57,360
about when we're talking about password

579
00:25:57,360 --> 00:25:59,440
authenticated key exchange is the

580
00:25:59,440 --> 00:26:02,400
question why do we still talk about it

581
00:26:02,400 --> 00:26:05,279
and um i just want to say that i don't

582
00:26:05,279 --> 00:26:07,279
like passwords any more than you they

583
00:26:07,279 --> 00:26:09,440
are bad they are evil you can say a lot

584
00:26:09,440 --> 00:26:11,840
of things about them unfortunately

585
00:26:11,840 --> 00:26:13,760
although many people have repeatedly

586
00:26:13,760 --> 00:26:16,559
said that passwords are dead and they

587
00:26:16,559 --> 00:26:17,840
are not

588
00:26:17,840 --> 00:26:18,720
and

589
00:26:18,720 --> 00:26:20,640
every year we can give this talk again

590
00:26:20,640 --> 00:26:22,320
and again and every year it will be

591
00:26:22,320 --> 00:26:24,159
correct to say that passwords are now

592
00:26:24,159 --> 00:26:26,400
more ubiquitous than ever we have a lot

593
00:26:26,400 --> 00:26:29,279
of alternatives but still if you look at

594
00:26:29,279 --> 00:26:31,440
most websites when you try to login they

595
00:26:31,440 --> 00:26:35,440
will use the passwords and the whole um

596
00:26:35,440 --> 00:26:38,559
amazing realm of iot devices still

597
00:26:38,559 --> 00:26:41,039
mostly based on passwords there have

598
00:26:41,039 --> 00:26:42,799
been a recent effort to standardize

599
00:26:42,799 --> 00:26:45,039
passwords and to incorporate it into the

600
00:26:45,039 --> 00:26:48,400
tls 1.3 protocol so at least for the

601
00:26:48,400 --> 00:26:49,840
recent future

602
00:26:49,840 --> 00:26:52,799
we are still stuck with them so we might

603
00:26:52,799 --> 00:26:55,440
as well try to find more um

604
00:26:55,440 --> 00:26:58,240
better ways how to use them

605
00:26:58,240 --> 00:27:00,320
and um there are many different use

606
00:27:00,320 --> 00:27:02,400
cases for when and how they want to use

607
00:27:02,400 --> 00:27:03,600
passwords

608
00:27:03,600 --> 00:27:05,679
and maybe the simplest one is when we

609
00:27:05,679 --> 00:27:07,840
want to authenticate to

610
00:27:07,840 --> 00:27:09,760
some server for example we want to log

611
00:27:09,760 --> 00:27:11,120
into

612
00:27:11,120 --> 00:27:12,960
to a website and we have a lot of

613
00:27:12,960 --> 00:27:14,159
different ways to do it and there's a

614
00:27:14,159 --> 00:27:16,159
lot of different trade-offs but we're

615
00:27:16,159 --> 00:27:18,320
not going to talk about it today

616
00:27:18,320 --> 00:27:20,960
and the second thing which i found maybe

617
00:27:20,960 --> 00:27:23,279
even more interesting is to use

618
00:27:23,279 --> 00:27:25,760
passwords in order to create a secure

619
00:27:25,760 --> 00:27:27,919
channel and we

620
00:27:27,919 --> 00:27:30,399
want to have this type of magic well we

621
00:27:30,399 --> 00:27:32,960
take a very low entropy password which

622
00:27:32,960 --> 00:27:33,760
is

623
00:27:33,760 --> 00:27:35,440
relatively easy to

624
00:27:35,440 --> 00:27:37,919
boot for us and we want to exchange it

625
00:27:37,919 --> 00:27:40,720
for a very high entropy key which we can

626
00:27:40,720 --> 00:27:42,880
actually use in order to encrypt

627
00:27:42,880 --> 00:27:44,880
messages of our channel

628
00:27:44,880 --> 00:27:45,840
and

629
00:27:45,840 --> 00:27:48,399
we we have many different settings and

630
00:27:48,399 --> 00:27:50,399
one setting which was the original one

631
00:27:50,399 --> 00:27:54,159
is the schematic setting if

632
00:27:54,159 --> 00:27:56,480
as a crypto alice will want to talk with

633
00:27:56,480 --> 00:27:58,080
bob and they should only share a

634
00:27:58,080 --> 00:28:00,320
password they can exchange this password

635
00:28:00,320 --> 00:28:01,679
into

636
00:28:01,679 --> 00:28:03,360
iron topic key and create a secure

637
00:28:03,360 --> 00:28:04,559
channel

638
00:28:04,559 --> 00:28:05,360
um

639
00:28:05,360 --> 00:28:07,679
the other setting which i think today

640
00:28:07,679 --> 00:28:08,559
is

641
00:28:08,559 --> 00:28:11,039
also very popular is the asthmatic

642
00:28:11,039 --> 00:28:12,480
setting when we have a client and a

643
00:28:12,480 --> 00:28:14,480
server and

644
00:28:14,480 --> 00:28:16,640
well the client usually

645
00:28:16,640 --> 00:28:19,279
can only remember the password instead

646
00:28:19,279 --> 00:28:22,240
and the server is able to store some

647
00:28:22,240 --> 00:28:24,320
password file something with ir entropy

648
00:28:24,320 --> 00:28:26,399
and it has and you can store it for a

649
00:28:26,399 --> 00:28:28,799
long time

650
00:28:28,840 --> 00:28:32,159
um and we ask ourselves but what about

651
00:28:32,159 --> 00:28:33,520
the

652
00:28:33,520 --> 00:28:34,880
a case of

653
00:28:34,880 --> 00:28:37,440
many too many when we have a mesh

654
00:28:37,440 --> 00:28:39,039
network with a lot of different devices

655
00:28:39,039 --> 00:28:41,200
that want to communicate with each other

656
00:28:41,200 --> 00:28:43,120
and they want to do this communication

657
00:28:43,120 --> 00:28:46,720
over um using appreciate secret which is

658
00:28:46,720 --> 00:28:48,960
a low entropy password

659
00:28:48,960 --> 00:28:51,919
and in that case um the first question

660
00:28:51,919 --> 00:28:55,600
is why can't we just use a multi

661
00:28:55,600 --> 00:28:57,360
multiple one to

662
00:28:57,360 --> 00:28:58,320
and

663
00:28:58,320 --> 00:29:00,559
communication so basically we know how

664
00:29:00,559 --> 00:29:02,159
to um

665
00:29:02,159 --> 00:29:03,760
have a one-to-one communication using

666
00:29:03,760 --> 00:29:05,840
password so all devices can use the same

667
00:29:05,840 --> 00:29:07,440
password and try to communicate with

668
00:29:07,440 --> 00:29:08,559
each other

669
00:29:08,559 --> 00:29:11,440
so try to to try to motivate

670
00:29:11,440 --> 00:29:13,919
why this might not be the optimal option

671
00:29:13,919 --> 00:29:16,159
and let's look at a typical use case for

672
00:29:16,159 --> 00:29:18,159
a smart home network

673
00:29:18,159 --> 00:29:19,919
and

674
00:29:19,919 --> 00:29:22,480
in the smart home we of course have the

675
00:29:22,480 --> 00:29:25,279
computer the computer is latest

676
00:29:25,279 --> 00:29:27,039
generation

677
00:29:27,039 --> 00:29:29,679
intel amd um whatever your profile um

678
00:29:29,679 --> 00:29:32,720
cpu with a fully patched linux device

679
00:29:32,720 --> 00:29:34,720
and it doesn't have any known

680
00:29:34,720 --> 00:29:36,320
weaknesses it has

681
00:29:36,320 --> 00:29:38,880
mitigation for spectre meltdown whatever

682
00:29:38,880 --> 00:29:40,720
you want this is a relatively good and

683
00:29:40,720 --> 00:29:42,720
secure machine

684
00:29:42,720 --> 00:29:45,440
in our smart home we also have the lock

685
00:29:45,440 --> 00:29:47,919
on the door that is controlled via the

686
00:29:47,919 --> 00:29:49,279
network and

687
00:29:49,279 --> 00:29:51,760
it's able to open and close

688
00:29:51,760 --> 00:29:54,880
the physical door to the house

689
00:29:54,880 --> 00:29:57,200
also we have a thermostat this

690
00:29:57,200 --> 00:29:59,840
thermostat has been bricked by its

691
00:29:59,840 --> 00:30:02,559
window it's currently um

692
00:30:02,559 --> 00:30:04,320
doesn't work anymore we need to discard

693
00:30:04,320 --> 00:30:06,240
it but it's quick we don't if we are not

694
00:30:06,240 --> 00:30:08,480
even able to delete any credentials that

695
00:30:08,480 --> 00:30:11,760
are still stored in persistent memory

696
00:30:11,760 --> 00:30:14,480
we also have a tablet for the kids this

697
00:30:14,480 --> 00:30:17,440
is an android 8.0 the last security

698
00:30:17,440 --> 00:30:20,080
patch was january 2019

699
00:30:20,080 --> 00:30:22,080
and it is a currently powered member of

700
00:30:22,080 --> 00:30:25,120
at least eight different botnets

701
00:30:25,120 --> 00:30:28,159
we also have the router that we got from

702
00:30:28,159 --> 00:30:29,440
the isp

703
00:30:29,440 --> 00:30:31,600
which at least for example in israel we

704
00:30:31,600 --> 00:30:34,640
do consider to be malicious at least

705
00:30:34,640 --> 00:30:37,120
financially wise and because we want to

706
00:30:37,120 --> 00:30:38,880
move to a new cheaper sp this will be

707
00:30:38,880 --> 00:30:41,039
replaced in the next month for the new

708
00:30:41,039 --> 00:30:42,240
provider

709
00:30:42,240 --> 00:30:43,919
and again it has all of the wi-fi

710
00:30:43,919 --> 00:30:45,600
credentials

711
00:30:45,600 --> 00:30:49,120
uh and of course if um you're in a

712
00:30:49,120 --> 00:30:51,440
better social situation than i am and

713
00:30:51,440 --> 00:30:53,520
you have many friends then maybe they

714
00:30:53,520 --> 00:30:55,200
will come and visit you they will bring

715
00:30:55,200 --> 00:30:56,480
the smartphones and they will want to

716
00:30:56,480 --> 00:30:58,240
connect to your home network

717
00:30:58,240 --> 00:31:00,720
so um we also need to give them the

718
00:31:00,720 --> 00:31:02,159
password

719
00:31:02,159 --> 00:31:04,000
and the nice thing about it is that at

720
00:31:04,000 --> 00:31:07,679
least in wi-fi for example all devices

721
00:31:07,679 --> 00:31:09,919
need to store a copy

722
00:31:09,919 --> 00:31:11,840
of the password the actual plaintext

723
00:31:11,840 --> 00:31:13,440
password that you input is stored

724
00:31:13,440 --> 00:31:15,120
somewhere on the device because this is

725
00:31:15,120 --> 00:31:16,320
required

726
00:31:16,320 --> 00:31:17,440
for the

727
00:31:17,440 --> 00:31:18,720
protocol

728
00:31:18,720 --> 00:31:20,799
that they are using basically means we

729
00:31:20,799 --> 00:31:22,559
only need one compromise to hold them

730
00:31:22,559 --> 00:31:24,720
all we got a password and then we can

731
00:31:24,720 --> 00:31:26,399
impersonate anything in this network and

732
00:31:26,399 --> 00:31:29,279
we can do whatever we want

733
00:31:29,279 --> 00:31:31,519
which is not the best situation to to be

734
00:31:31,519 --> 00:31:34,399
in security-wise

735
00:31:34,399 --> 00:31:35,440
okay

736
00:31:35,440 --> 00:31:37,760
so let's talk about some of the

737
00:31:37,760 --> 00:31:41,039
challenges in this many-to-many settings

738
00:31:41,039 --> 00:31:44,159
so the first challenge maybe is that

739
00:31:44,159 --> 00:31:47,200
we only have one password but we have

740
00:31:47,200 --> 00:31:49,840
many many different users and devices

741
00:31:49,840 --> 00:31:52,240
and maybe we want to have some kind of

742
00:31:52,240 --> 00:31:54,720
source authentication for example

743
00:31:54,720 --> 00:31:56,880
maybe we don't want the

744
00:31:56,880 --> 00:31:58,880
thermostat to be able to send commands

745
00:31:58,880 --> 00:32:02,159
that will open and close the door lock

746
00:32:02,159 --> 00:32:04,240
so we want to be able to authenticate

747
00:32:04,240 --> 00:32:05,919
which is the source of the

748
00:32:05,919 --> 00:32:06,960
message

749
00:32:06,960 --> 00:32:09,200
moreover maybe we want to be able to

750
00:32:09,200 --> 00:32:10,559
revoke

751
00:32:10,559 --> 00:32:13,120
specific users for example if we had

752
00:32:13,120 --> 00:32:15,279
friends over and now we don't we

753
00:32:15,279 --> 00:32:16,480
with them and we don't talk with them

754
00:32:16,480 --> 00:32:18,000
anymore maybe we want to revoke the

755
00:32:18,000 --> 00:32:20,320
devices if we have an old iot devices

756
00:32:20,320 --> 00:32:22,080
that we throw away maybe you also want

757
00:32:22,080 --> 00:32:24,399
to revoke its credentials so if someone

758
00:32:24,399 --> 00:32:26,159
picks it up it can con steal the

759
00:32:26,159 --> 00:32:28,960
credentials

760
00:32:28,960 --> 00:32:32,000
another problem will challenge is the

761
00:32:32,000 --> 00:32:34,720
network topology is very dynamic so we

762
00:32:34,720 --> 00:32:36,960
need to be able to bootstrap new devices

763
00:32:36,960 --> 00:32:38,080
all the time

764
00:32:38,080 --> 00:32:41,360
and again we need to share with them

765
00:32:41,360 --> 00:32:43,120
some kind of secret so they can join the

766
00:32:43,120 --> 00:32:44,159
network

767
00:32:44,159 --> 00:32:46,880
and we want to be able to support easy

768
00:32:46,880 --> 00:32:49,600
replacement of existing entities

769
00:32:49,600 --> 00:32:53,120
um so for example if we have um the

770
00:32:53,120 --> 00:32:55,440
hardware for the wi-fi router which all

771
00:32:55,440 --> 00:32:57,919
devices has to talk with and and it's

772
00:32:57,919 --> 00:32:59,919
currently broken we need to we want to

773
00:32:59,919 --> 00:33:01,440
have a very simple process where we just

774
00:33:01,440 --> 00:33:03,679
replace it and everything works

775
00:33:03,679 --> 00:33:05,519
and basically

776
00:33:05,519 --> 00:33:08,480
we didn't set the the requirements we

777
00:33:08,480 --> 00:33:13,039
motivated by for example wi-fi networks

778
00:33:13,039 --> 00:33:15,279
and another thing that is very important

779
00:33:15,279 --> 00:33:17,360
is that we want to be able to

780
00:33:17,360 --> 00:33:21,200
um input the password in an acronis and

781
00:33:21,200 --> 00:33:24,320
sometimes even offline manual so example

782
00:33:24,320 --> 00:33:26,480
we don't want to to assume that we have

783
00:33:26,480 --> 00:33:28,559
any kind of communication

784
00:33:28,559 --> 00:33:30,480
with any of the other entities in order

785
00:33:30,480 --> 00:33:32,880
to set up the initial

786
00:33:32,880 --> 00:33:34,240
key generation

787
00:33:34,240 --> 00:33:35,519
and

788
00:33:35,519 --> 00:33:39,360
we don't have any shared randomness so

789
00:33:39,360 --> 00:33:41,360
maybe each device can have an access for

790
00:33:41,360 --> 00:33:44,880
its own local random randomness and it

791
00:33:44,880 --> 00:33:48,240
can generate it but there's no way for

792
00:33:48,240 --> 00:33:49,919
my smartphone and the router when

793
00:33:49,919 --> 00:33:52,399
they're offline to negotiate some kind

794
00:33:52,399 --> 00:33:53,279
of

795
00:33:53,279 --> 00:33:54,880
randomness

796
00:33:54,880 --> 00:33:57,279
and we cannot assume that we have any

797
00:33:57,279 --> 00:33:58,720
trusted

798
00:33:58,720 --> 00:34:02,240
third-party or pki infrastructure um not

799
00:34:02,240 --> 00:34:03,919
sure if you all were but in the recent

800
00:34:03,919 --> 00:34:06,480
real world crypto event and let's

801
00:34:06,480 --> 00:34:09,040
encrypt that 11 person in for their

802
00:34:09,040 --> 00:34:11,599
effort to try to bring um enough

803
00:34:11,599 --> 00:34:13,520
certificates and pki to the whole of the

804
00:34:13,520 --> 00:34:15,679
internet i feel their job will be much

805
00:34:15,679 --> 00:34:17,199
more challenging they also needed to

806
00:34:17,199 --> 00:34:19,440
provide certificates for every home

807
00:34:19,440 --> 00:34:21,760
network it's something that's a personal

808
00:34:21,760 --> 00:34:24,960
thing it's not very practical

809
00:34:24,960 --> 00:34:26,719
okay so

810
00:34:26,719 --> 00:34:28,719
let's look at the related work that we

811
00:34:28,719 --> 00:34:29,760
have

812
00:34:29,760 --> 00:34:32,480
and the first thing that we that

813
00:34:32,480 --> 00:34:34,239
we can talk about our password

814
00:34:34,239 --> 00:34:36,560
authenticated key exchange

815
00:34:36,560 --> 00:34:38,799
and

816
00:34:39,040 --> 00:34:41,599
this is a relatively old notion it goes

817
00:34:41,599 --> 00:34:43,918
back to the beginning of the 90s and in

818
00:34:43,918 --> 00:34:47,440
this we have this magical protocol

819
00:34:47,440 --> 00:34:49,918
poop two parties have a very low entropy

820
00:34:49,918 --> 00:34:51,760
passwords and they go they negotiate

821
00:34:51,760 --> 00:34:53,599
some protocol and they have a secure

822
00:34:53,599 --> 00:34:54,560
channel

823
00:34:54,560 --> 00:34:56,079
and they have several nice properties

824
00:34:56,079 --> 00:34:57,920
that we will talk about a little bit

825
00:34:57,920 --> 00:34:59,119
later on

826
00:34:59,119 --> 00:35:00,880
but when we look at the model of this

827
00:35:00,880 --> 00:35:03,040
password authenticate key exchange they

828
00:35:03,040 --> 00:35:06,160
assume that the password is never stored

829
00:35:06,160 --> 00:35:08,160
so in the way that uh

830
00:35:08,160 --> 00:35:10,160
their model for example in the uc model

831
00:35:10,160 --> 00:35:12,000
each time we have a session we assume

832
00:35:12,000 --> 00:35:12,880
that

833
00:35:12,880 --> 00:35:16,960
both parties input their passwords

834
00:35:17,040 --> 00:35:18,960
to the devices they use

835
00:35:18,960 --> 00:35:21,200
now you can ask which of you

836
00:35:21,200 --> 00:35:23,040
i'm sure that

837
00:35:23,040 --> 00:35:24,560
most of you at least are currently

838
00:35:24,560 --> 00:35:27,119
connected to the

839
00:35:27,119 --> 00:35:28,640
santa barbara

840
00:35:28,640 --> 00:35:30,400
wifi network or to your home network and

841
00:35:30,400 --> 00:35:32,320
you can ask yourself how many times you

842
00:35:32,320 --> 00:35:34,720
re-input your wi-fi password every time

843
00:35:34,720 --> 00:35:36,160
you try to connect

844
00:35:36,160 --> 00:35:38,320
and the answer is you usually don't and

845
00:35:38,320 --> 00:35:40,640
the reason for that is that in real life

846
00:35:40,640 --> 00:35:43,119
the password is usually stored on the

847
00:35:43,119 --> 00:35:45,920
device and because we don't have any

848
00:35:45,920 --> 00:35:48,800
better solution it stores in as in plain

849
00:35:48,800 --> 00:35:50,480
text maybe there is some protection

850
00:35:50,480 --> 00:35:52,880
device but the device need to to know

851
00:35:52,880 --> 00:35:53,839
the

852
00:35:53,839 --> 00:35:56,800
the plaintext password

853
00:35:56,800 --> 00:35:58,720
which i think personally is not a good

854
00:35:58,720 --> 00:36:01,280
security practice

855
00:36:01,280 --> 00:36:04,720
and we have the more advanced notion um

856
00:36:04,720 --> 00:36:08,079
of uh asthmatic back or augmented peak

857
00:36:08,079 --> 00:36:10,160
and here we assume that we have two

858
00:36:10,160 --> 00:36:12,640
different parties we have uh the client

859
00:36:12,640 --> 00:36:14,240
and we have the server

860
00:36:14,240 --> 00:36:16,560
now the client as before needs to

861
00:36:16,560 --> 00:36:19,200
re-input his first password each time

862
00:36:19,200 --> 00:36:21,280
we're going to run the protocol however

863
00:36:21,280 --> 00:36:23,520
the server is able to store some

864
00:36:23,520 --> 00:36:26,400
long-term secret it's going to to

865
00:36:26,400 --> 00:36:28,320
save something that is derived from the

866
00:36:28,320 --> 00:36:30,079
password and the nice thing about

867
00:36:30,079 --> 00:36:35,599
augmented makes is that um even if i um

868
00:36:35,599 --> 00:36:37,760
compromise the server and steal whatever

869
00:36:37,760 --> 00:36:39,760
is stored in it i can't use the

870
00:36:39,760 --> 00:36:41,839
information in order to impersonate the

871
00:36:41,839 --> 00:36:43,040
client

872
00:36:43,040 --> 00:36:45,440
the client as he knows that the the the

873
00:36:45,440 --> 00:36:47,520
password can do whatever it wants it's

874
00:36:47,520 --> 00:36:48,800
trivial for him to impersonate the

875
00:36:48,800 --> 00:36:50,960
server but the other way one doesn't

876
00:36:50,960 --> 00:36:53,440
work which is nice because

877
00:36:53,440 --> 00:36:54,480
we

878
00:36:54,480 --> 00:36:57,119
all of us make really good

879
00:36:57,119 --> 00:36:59,040
really good practices in protecting our

880
00:36:59,040 --> 00:37:00,560
own devices and we don't trust the

881
00:37:00,560 --> 00:37:02,640
servers that are probably

882
00:37:02,640 --> 00:37:04,640
less secure i'm not sure if this is a

883
00:37:04,640 --> 00:37:06,640
good security model or not but this is

884
00:37:06,640 --> 00:37:08,640
what we have here

885
00:37:08,640 --> 00:37:09,520
um

886
00:37:09,520 --> 00:37:11,760
very relatively recently this is the

887
00:37:11,760 --> 00:37:13,359
work that

888
00:37:13,359 --> 00:37:14,400
we

889
00:37:14,400 --> 00:37:17,839
like to extend and we have a new notion

890
00:37:17,839 --> 00:37:20,640
of strong asthmatic pec

891
00:37:20,640 --> 00:37:22,800
and here um

892
00:37:22,800 --> 00:37:23,920
we

893
00:37:23,920 --> 00:37:25,599
is thinking of the

894
00:37:25,599 --> 00:37:27,440
the protection on the server which

895
00:37:27,440 --> 00:37:30,640
basically means um if i compromise the

896
00:37:30,640 --> 00:37:31,760
server

897
00:37:31,760 --> 00:37:33,040
i'm not supposed to be able to

898
00:37:33,040 --> 00:37:35,200
impersonate the client however i can run

899
00:37:35,200 --> 00:37:37,440
a brute force attack attempting to all

900
00:37:37,440 --> 00:37:39,280
of the different passwords in a large

901
00:37:39,280 --> 00:37:41,200
password dictionary and in the end if i

902
00:37:41,200 --> 00:37:42,720
guess the correct password i have a way

903
00:37:42,720 --> 00:37:43,520
to

904
00:37:43,520 --> 00:37:44,720
verify it

905
00:37:44,720 --> 00:37:46,240
to the

906
00:37:46,240 --> 00:37:47,680
what is stolen

907
00:37:47,680 --> 00:37:50,480
with what is stored on the server and

908
00:37:50,480 --> 00:37:52,880
actually i can try to um

909
00:37:52,880 --> 00:37:54,720
run most of the computation that is

910
00:37:54,720 --> 00:37:56,320
needed for this attack

911
00:37:56,320 --> 00:37:58,480
in pre-processed stage before i even

912
00:37:58,480 --> 00:38:00,079
compromise the server

913
00:38:00,079 --> 00:38:02,160
however in

914
00:38:02,160 --> 00:38:04,640
strong in the strong setting i can't

915
00:38:04,640 --> 00:38:06,720
start this brute force attack until i

916
00:38:06,720 --> 00:38:08,880
actually compromised the server and got

917
00:38:08,880 --> 00:38:13,119
the password filed stored on it

918
00:38:13,119 --> 00:38:15,599
okay so this is what we currently have

919
00:38:15,599 --> 00:38:17,839
and the main problem that we have with

920
00:38:17,839 --> 00:38:18,640
this

921
00:38:18,640 --> 00:38:21,680
um augmented pack techniques is that

922
00:38:21,680 --> 00:38:25,200
they still require um one of the sites

923
00:38:25,200 --> 00:38:27,520
of the protocol namely the client to

924
00:38:27,520 --> 00:38:29,680
store a plaintext version of the

925
00:38:29,680 --> 00:38:31,599
of the password

926
00:38:31,599 --> 00:38:33,359
and this does not work in the schematic

927
00:38:33,359 --> 00:38:35,520
setting and for example

928
00:38:35,520 --> 00:38:39,119
uh for a wi-fi the wi-fi lines which is

929
00:38:39,119 --> 00:38:40,880
the consortium that

930
00:38:40,880 --> 00:38:43,119
controls the wi-fi setting um actually

931
00:38:43,119 --> 00:38:45,760
requires the protocols and the password

932
00:38:45,760 --> 00:38:47,520
authenticated kitchen protocols for

933
00:38:47,520 --> 00:38:50,400
wi-fi to be symmetric so all devices can

934
00:38:50,400 --> 00:38:52,960
communicate with each other

935
00:38:52,960 --> 00:38:56,560
okay so um for our solution we present

936
00:38:56,560 --> 00:38:58,240
cheap and crisp

937
00:38:58,240 --> 00:39:01,280
now the main edition we have compared to

938
00:39:01,280 --> 00:39:02,800
the old notions

939
00:39:02,800 --> 00:39:04,960
is that uh for example in our what we

940
00:39:04,960 --> 00:39:08,079
call identity based uh packs

941
00:39:08,079 --> 00:39:10,160
is that passwords are not stored as

942
00:39:10,160 --> 00:39:11,760
plain text in any

943
00:39:11,760 --> 00:39:13,760
of the different parties

944
00:39:13,760 --> 00:39:15,920
but moreover it's not just that we don't

945
00:39:15,920 --> 00:39:17,920
store them as plaintiffs we can always

946
00:39:17,920 --> 00:39:19,599
take the password hash it install the

947
00:39:19,599 --> 00:39:21,680
hash of the password but if we just

948
00:39:21,680 --> 00:39:23,520
store a hash of the password then this

949
00:39:23,520 --> 00:39:25,920
hash becomes the secret but now what we

950
00:39:25,920 --> 00:39:27,760
can do is we can actually bind the

951
00:39:27,760 --> 00:39:30,079
identity of a party into the password

952
00:39:30,079 --> 00:39:32,880
file that we derive so if we compromise

953
00:39:32,880 --> 00:39:36,079
a party one we can only impose on party

954
00:39:36,079 --> 00:39:38,160
one and not party two or any other party

955
00:39:38,160 --> 00:39:40,720
that we have in this network so the

956
00:39:40,720 --> 00:39:43,119
personal file is uh

957
00:39:43,119 --> 00:39:44,400
bind to the end

958
00:39:44,400 --> 00:39:46,000
to the identity

959
00:39:46,000 --> 00:39:48,560
uh we also um have the

960
00:39:48,560 --> 00:39:50,320
stronger notion variant which is strong

961
00:39:50,320 --> 00:39:53,440
identity based bank where all password

962
00:39:53,440 --> 00:39:56,240
storage are

963
00:39:56,240 --> 00:39:58,640
resilient to pre-computation so you

964
00:39:58,640 --> 00:40:00,160
can't actually try to boot for the

965
00:40:00,160 --> 00:40:02,720
password until you um compromise the

966
00:40:02,720 --> 00:40:04,079
first

967
00:40:04,079 --> 00:40:06,240
device in the network and we'll only

968
00:40:06,240 --> 00:40:08,400
mention here party one and party two but

969
00:40:08,400 --> 00:40:10,240
this can be to as many parties as you

970
00:40:10,240 --> 00:40:14,240
want to have in a simatic network

971
00:40:14,480 --> 00:40:17,839
okay so um the way that we realize this

972
00:40:17,839 --> 00:40:21,440
database pack is by um using techniques

973
00:40:21,440 --> 00:40:25,359
from identity based key exchange and um

974
00:40:25,359 --> 00:40:27,520
because then we have this notion of

975
00:40:27,520 --> 00:40:30,000
identity and we can have what you call

976
00:40:30,000 --> 00:40:32,480
um

977
00:40:32,960 --> 00:40:34,319
okay it doesn't matter i don't want to

978
00:40:34,319 --> 00:40:37,119
go to the specific details but

979
00:40:37,119 --> 00:40:38,880
but we can prevent impressionism

980
00:40:38,880 --> 00:40:40,960
impressionist impersonation attacks

981
00:40:40,960 --> 00:40:42,000
excuse me

982
00:40:42,000 --> 00:40:43,760
uh but the main thing here is that we

983
00:40:43,760 --> 00:40:46,240
only use the underlying ideas we don't

984
00:40:46,240 --> 00:40:50,240
actually require the the trusted

985
00:40:50,240 --> 00:40:52,640
key generator or key center that is

986
00:40:52,640 --> 00:40:55,200
actually used in um

987
00:40:55,200 --> 00:40:56,800
in this kind of

988
00:40:56,800 --> 00:40:59,440
regular identity based protocols we

989
00:40:59,440 --> 00:41:01,760
actually use the password to and derive

990
00:41:01,760 --> 00:41:03,520
it in order to simulate

991
00:41:03,520 --> 00:41:06,240
on each of the devices and this trusted

992
00:41:06,240 --> 00:41:08,640
third party and then derive

993
00:41:08,640 --> 00:41:11,520
the required password files

994
00:41:11,520 --> 00:41:13,680
we also do not actually need unique

995
00:41:13,680 --> 00:41:15,599
identifiers for each

996
00:41:15,599 --> 00:41:18,079
for each device but instead we can have

997
00:41:18,079 --> 00:41:21,359
any kind of abstract tabs um to bind the

998
00:41:21,359 --> 00:41:23,040
password storage to

999
00:41:23,040 --> 00:41:26,160
so this means that we can choose to um

1000
00:41:26,160 --> 00:41:28,160
bind storage to identities so for

1001
00:41:28,160 --> 00:41:31,040
example you can choose to bind bob alice

1002
00:41:31,040 --> 00:41:32,720
and charlie to each of his password

1003
00:41:32,720 --> 00:41:34,400
files but we can only

1004
00:41:34,400 --> 00:41:36,400
we can also choose roles for example

1005
00:41:36,400 --> 00:41:39,040
access point lock high security low

1006
00:41:39,040 --> 00:41:41,359
security and we can use also unique

1007
00:41:41,359 --> 00:41:43,280
actual unique data files like mac

1008
00:41:43,280 --> 00:41:45,839
addresses for wi-fi

1009
00:41:45,839 --> 00:41:47,599
and actually we can have multiple

1010
00:41:47,599 --> 00:41:50,160
devices that share the exact same tag it

1011
00:41:50,160 --> 00:41:52,319
doesn't have security it only means that

1012
00:41:52,319 --> 00:41:54,319
they can impersonate each other so if we

1013
00:41:54,319 --> 00:41:57,359
have for example in all of the visiting

1014
00:41:57,359 --> 00:41:59,280
visiting smartphone that we have we can

1015
00:41:59,280 --> 00:42:01,440
all give them the same tag because

1016
00:42:01,440 --> 00:42:03,760
we we don't care if they can impersonate

1017
00:42:03,760 --> 00:42:06,079
each other because they are ever they

1018
00:42:06,079 --> 00:42:07,040
will have

1019
00:42:07,040 --> 00:42:10,400
low permissions in our network

1020
00:42:10,400 --> 00:42:12,800
okay so now we try to give a little bit

1021
00:42:12,800 --> 00:42:14,640
of a test of how we actually do it and

1022
00:42:14,640 --> 00:42:17,839
we give the example of of crisp

1023
00:42:17,839 --> 00:42:18,800
and

1024
00:42:18,800 --> 00:42:20,560
in case we want to have this type of

1025
00:42:20,560 --> 00:42:23,040
pre-computation resistance

1026
00:42:23,040 --> 00:42:23,920
and

1027
00:42:23,920 --> 00:42:26,400
so how do we protect the password

1028
00:42:26,400 --> 00:42:29,040
so the one thing that we can do and i

1029
00:42:29,040 --> 00:42:31,119
thing that we should always do

1030
00:42:31,119 --> 00:42:33,119
is of course to hash the password and

1031
00:42:33,119 --> 00:42:34,560
not save the

1032
00:42:34,560 --> 00:42:36,720
the actual plaintext

1033
00:42:36,720 --> 00:42:38,640
and now in practice we should probably

1034
00:42:38,640 --> 00:42:40,480
hash the password and the unique

1035
00:42:40,480 --> 00:42:42,400
identifier of the network

1036
00:42:42,400 --> 00:42:45,040
but for brevity i don't write it in the

1037
00:42:45,040 --> 00:42:46,720
slides

1038
00:42:46,720 --> 00:42:48,640
and the problem is with this that this

1039
00:42:48,640 --> 00:42:50,319
is vulnerable to a very simple

1040
00:42:50,319 --> 00:42:52,400
pre-computation attack so for example if

1041
00:42:52,400 --> 00:42:53,760
we have a dictionary of all of the

1042
00:42:53,760 --> 00:42:56,400
possible passwords we can pre-compute

1043
00:42:56,400 --> 00:42:58,640
the hashes of all passwords we create a

1044
00:42:58,640 --> 00:43:01,680
lookup table which allows us to retrieve

1045
00:43:01,680 --> 00:43:03,680
the password equivalent to every

1046
00:43:03,680 --> 00:43:05,839
hash values and even if it's very large

1047
00:43:05,839 --> 00:43:07,280
there's a lot of very cool techniques

1048
00:43:07,280 --> 00:43:09,760
like um herman or rainbow tables that

1049
00:43:09,760 --> 00:43:11,599
allows you to do it relatively

1050
00:43:11,599 --> 00:43:13,040
efficiently

1051
00:43:13,040 --> 00:43:16,800
with not so much storage

1052
00:43:16,800 --> 00:43:19,440
another option that we can have is to

1053
00:43:19,440 --> 00:43:21,680
use salt for password this is a common

1054
00:43:21,680 --> 00:43:23,520
practice when we save passwords on

1055
00:43:23,520 --> 00:43:25,359
servers so we

1056
00:43:25,359 --> 00:43:26,400
sample some

1057
00:43:26,400 --> 00:43:29,119
random long salt x and we hash the

1058
00:43:29,119 --> 00:43:32,240
password together with this random salt

1059
00:43:32,240 --> 00:43:34,400
now this is good for security

1060
00:43:34,400 --> 00:43:35,920
and but

1061
00:43:35,920 --> 00:43:38,000
and so it's salted it's become it's

1062
00:43:38,000 --> 00:43:41,040
permutation resistant however it is not

1063
00:43:41,040 --> 00:43:42,880
trivial to actually generate a shared

1064
00:43:42,880 --> 00:43:44,960
key with this because if we have two

1065
00:43:44,960 --> 00:43:46,880
parties that do not show have a shared

1066
00:43:46,880 --> 00:43:48,560
randomness so one will generate

1067
00:43:48,560 --> 00:43:50,880
randomness x the other with the y and if

1068
00:43:50,880 --> 00:43:52,480
we assume the hash function function is

1069
00:43:52,480 --> 00:43:54,800
a random article and without actually

1070
00:43:54,800 --> 00:43:57,359
remembering a password there is no way

1071
00:43:57,359 --> 00:44:00,640
for those two parties to actually um

1072
00:44:00,640 --> 00:44:02,240
generate a

1073
00:44:02,240 --> 00:44:05,119
shared key we need some kind of

1074
00:44:05,119 --> 00:44:07,200
structure to a one-way function in order

1075
00:44:07,200 --> 00:44:09,119
to in order to do it

1076
00:44:09,119 --> 00:44:11,680
so fortunately for us we know one-way

1077
00:44:11,680 --> 00:44:14,319
functions with structures so maybe we

1078
00:44:14,319 --> 00:44:17,280
can just generate a random sort and take

1079
00:44:17,280 --> 00:44:18,319
the

1080
00:44:18,319 --> 00:44:20,000
hash of the password

1081
00:44:20,000 --> 00:44:21,920
multiplied by the sort and put it in an

1082
00:44:21,920 --> 00:44:24,800
exponent of some nice generator

1083
00:44:24,800 --> 00:44:28,079
so um this is indeed a one-way function

1084
00:44:28,079 --> 00:44:30,400
it has and

1085
00:44:30,400 --> 00:44:32,480
it has structure so we can actually

1086
00:44:32,480 --> 00:44:34,000
derive a short key

1087
00:44:34,000 --> 00:44:36,079
however it is still vulnerable to this

1088
00:44:36,079 --> 00:44:38,079
type of computation attacks

1089
00:44:38,079 --> 00:44:40,319
and the reason is that we can if we know

1090
00:44:40,319 --> 00:44:42,880
x we can simply remove x

1091
00:44:42,880 --> 00:44:44,400
from the

1092
00:44:44,400 --> 00:44:47,359
exponent and we have we can still

1093
00:44:47,359 --> 00:44:49,520
compute the table before we know the the

1094
00:44:49,520 --> 00:44:50,800
x values

1095
00:44:50,800 --> 00:44:52,960
so basically we can separate this x

1096
00:44:52,960 --> 00:44:55,680
value and the password

1097
00:44:55,680 --> 00:44:58,240
another option which is it will be to

1098
00:44:58,240 --> 00:45:00,720
not save the salt but

1099
00:45:00,720 --> 00:45:02,480
save um

1100
00:45:02,480 --> 00:45:05,359
exponentiation using this salt

1101
00:45:05,359 --> 00:45:07,040
now this is actually pre-computation

1102
00:45:07,040 --> 00:45:09,760
resistant it has some nice properties

1103
00:45:09,760 --> 00:45:12,000
it's it's a function that's been

1104
00:45:12,000 --> 00:45:15,359
researched and looked at for over

1105
00:45:15,359 --> 00:45:16,480
20 years

1106
00:45:16,480 --> 00:45:19,440
and it actually can be uh it can be a

1107
00:45:19,440 --> 00:45:20,640
good solution

1108
00:45:20,640 --> 00:45:23,440
and the one problem depending if or not

1109
00:45:23,440 --> 00:45:25,280
we look at it is that it requires

1110
00:45:25,280 --> 00:45:27,440
pairing

1111
00:45:27,440 --> 00:45:28,400
um

1112
00:45:28,400 --> 00:45:30,800
actually what we what we use in practice

1113
00:45:30,800 --> 00:45:31,680
is

1114
00:45:31,680 --> 00:45:32,480
we

1115
00:45:32,480 --> 00:45:35,599
use a hash to grow polish to help of the

1116
00:45:35,599 --> 00:45:37,839
password in order to generate a secure

1117
00:45:37,839 --> 00:45:40,319
point and this is uh have similar

1118
00:45:40,319 --> 00:45:42,400
properties but it does allow us to

1119
00:45:42,400 --> 00:45:45,599
actually prove that um any brute force

1120
00:45:45,599 --> 00:45:47,839
attempt require one pairing operation

1121
00:45:47,839 --> 00:45:50,800
for every guess which you think is nice

1122
00:45:50,800 --> 00:45:54,640
um so this is the protocols and

1123
00:45:54,640 --> 00:45:57,599
basically we start by

1124
00:45:57,599 --> 00:46:00,560
by sampling some random some random

1125
00:46:00,560 --> 00:46:02,560
value and we save the exponent

1126
00:46:02,560 --> 00:46:04,560
exponentiation of this value

1127
00:46:04,560 --> 00:46:06,800
then we do the hash of curve raise it to

1128
00:46:06,800 --> 00:46:10,079
the power of the same um random salt and

1129
00:46:10,079 --> 00:46:13,200
what we also do is we hash

1130
00:46:13,200 --> 00:46:16,000
um the identity for example alice or bob

1131
00:46:16,000 --> 00:46:18,240
and raise it to the same power so now we

1132
00:46:18,240 --> 00:46:20,800
have a triplet of values the generator

1133
00:46:20,800 --> 00:46:22,960
has a hashtag of curve of the password

1134
00:46:22,960 --> 00:46:25,040
and hash to curve of the identity and

1135
00:46:25,040 --> 00:46:26,319
they are all raised to the power of the

1136
00:46:26,319 --> 00:46:28,800
same exponent and the main details are

1137
00:46:28,800 --> 00:46:30,560
not that important but we can use them

1138
00:46:30,560 --> 00:46:34,079
to both derive the share secret which we

1139
00:46:34,079 --> 00:46:35,520
then um

1140
00:46:35,520 --> 00:46:37,440
input to a peak in order to get all of

1141
00:46:37,440 --> 00:46:39,200
the nice properties that we like out of

1142
00:46:39,200 --> 00:46:42,160
space like perfect for secrecy and the

1143
00:46:42,160 --> 00:46:44,480
online

1144
00:46:44,480 --> 00:46:46,079
online attacks

1145
00:46:46,079 --> 00:46:47,200
resilient

1146
00:46:47,200 --> 00:46:49,760
and we can also use them to actually

1147
00:46:49,760 --> 00:46:50,880
validate

1148
00:46:50,880 --> 00:46:54,160
um the identity that is

1149
00:46:54,160 --> 00:46:56,560
claimed by each of those parties and in

1150
00:46:56,560 --> 00:46:58,560
the end we um

1151
00:46:58,560 --> 00:47:00,319
we can get a nice protocol

1152
00:47:00,319 --> 00:47:02,880
and those protocols are actually

1153
00:47:02,880 --> 00:47:05,520
efficient we implement them in code we

1154
00:47:05,520 --> 00:47:07,920
benchmark them and the nice thing about

1155
00:47:07,920 --> 00:47:10,240
all of them is that they are actually

1156
00:47:10,240 --> 00:47:11,280
faster

1157
00:47:11,280 --> 00:47:13,599
or at least comparable to what is

1158
00:47:13,599 --> 00:47:16,079
currently implemented in a wi-fi network

1159
00:47:16,079 --> 00:47:17,200
so this is something that we can

1160
00:47:17,200 --> 00:47:18,240
actually use

1161
00:47:18,240 --> 00:47:20,559
and cheap which relies on simpler

1162
00:47:20,559 --> 00:47:22,720
assumption is more efficient crisp takes

1163
00:47:22,720 --> 00:47:24,480
a little bit longer

1164
00:47:24,480 --> 00:47:26,800
and we have several suggestions how to

1165
00:47:26,800 --> 00:47:28,960
optimize it

1166
00:47:28,960 --> 00:47:32,079
regarding security and we

1167
00:47:32,079 --> 00:47:33,760
both define and

1168
00:47:33,760 --> 00:47:36,079
they they use it

1169
00:47:36,079 --> 00:47:37,680
you use it

1170
00:47:37,680 --> 00:47:40,480
ideal functionalities for ipad and sapec

1171
00:47:40,480 --> 00:47:42,880
and we prove a cheap to realize them

1172
00:47:42,880 --> 00:47:45,280
under a random local model and chris

1173
00:47:45,280 --> 00:47:48,880
bundle and ggm plus random oracle model

1174
00:47:48,880 --> 00:47:50,000
um

1175
00:47:50,000 --> 00:47:51,839
there are some open questions which we

1176
00:47:51,839 --> 00:47:54,000
think at least are interesting and for

1177
00:47:54,000 --> 00:47:57,359
example uh we know that um chip actually

1178
00:47:57,359 --> 00:48:00,000
requires the random oracle model uh but

1179
00:48:00,000 --> 00:48:02,240
we don't know if a ggm is actually

1180
00:48:02,240 --> 00:48:04,079
required for the strong variant we're

1181
00:48:04,079 --> 00:48:06,319
very nice to either prove it or find a

1182
00:48:06,319 --> 00:48:08,079
more efficient construction

1183
00:48:08,079 --> 00:48:11,040
and currently we don't have a very fine

1184
00:48:11,040 --> 00:48:13,119
grass rain post compromise password

1185
00:48:13,119 --> 00:48:15,440
hardening so for if we want to how to

1186
00:48:15,440 --> 00:48:17,520
protect the password we can for example

1187
00:48:17,520 --> 00:48:19,760
use iterative hashing and we can control

1188
00:48:19,760 --> 00:48:22,160
the hardness of the brute force attack

1189
00:48:22,160 --> 00:48:24,240
and for

1190
00:48:24,240 --> 00:48:26,400
for crisp we can only do a pairing

1191
00:48:26,400 --> 00:48:28,559
operation we want to make it harder we

1192
00:48:28,559 --> 00:48:30,480
need larger curves

1193
00:48:30,480 --> 00:48:31,359
and

1194
00:48:31,359 --> 00:48:33,040
we it would be nice to find we have some

1195
00:48:33,040 --> 00:48:34,640
notion of what is the optimal bond on

1196
00:48:34,640 --> 00:48:37,520
the cost of brute force attacks on any

1197
00:48:37,520 --> 00:48:39,839
algorithm and it will be nice if we can

1198
00:48:39,839 --> 00:48:41,119
try to achieve it

1199
00:48:41,119 --> 00:48:43,200
and currently we know how to do a three

1200
00:48:43,200 --> 00:48:44,640
message

1201
00:48:44,640 --> 00:48:46,800
protocol it would be nice to see is it

1202
00:48:46,800 --> 00:48:49,040
possible to do and to message your proof

1203
00:48:49,040 --> 00:48:51,119
that we can do it

1204
00:48:51,119 --> 00:48:54,000
so in conclusion uh we present cheap

1205
00:48:54,000 --> 00:48:55,040
encrypts

1206
00:48:55,040 --> 00:48:57,200
and we provide stronger guarantees for

1207
00:48:57,200 --> 00:48:59,440
password storage and we are able to

1208
00:48:59,440 --> 00:49:01,520
protect all of the parties and we work

1209
00:49:01,520 --> 00:49:02,960
in a semantic setting which is something

1210
00:49:02,960 --> 00:49:04,880
that we at least think is actually

1211
00:49:04,880 --> 00:49:06,720
required in practice

1212
00:49:06,720 --> 00:49:08,960
and um you can view other the full

1213
00:49:08,960 --> 00:49:10,960
versions either the paper for more

1214
00:49:10,960 --> 00:49:13,200
details or a look at the github report

1215
00:49:13,200 --> 00:49:15,359
for the code if you want to play with it

1216
00:49:15,359 --> 00:49:17,040
and thank you very much we'll be happy

1217
00:49:17,040 --> 00:49:18,640
to answer any questions

1218
00:49:18,640 --> 00:49:21,200
thank you

1219
00:49:22,720 --> 00:49:25,680
any questions

1220
00:49:27,040 --> 00:49:30,359
yes daring

1221
00:49:32,640 --> 00:49:35,359
how i mean where did he use ggm or kind

1222
00:49:35,359 --> 00:49:37,760
of what i mean why random oracle wasn't

1223
00:49:37,760 --> 00:49:39,040
enough

1224
00:49:39,040 --> 00:49:41,839
okay so um

1225
00:49:41,839 --> 00:49:45,680
the gtm was used

1226
00:49:45,680 --> 00:49:47,760
for the bilinear pairing

1227
00:49:47,760 --> 00:49:49,760
and

1228
00:49:49,760 --> 00:49:51,520
and because

1229
00:49:51,520 --> 00:49:53,920
we need to the the one-way function to

1230
00:49:53,920 --> 00:49:56,240
actually include the randomness in order

1231
00:49:56,240 --> 00:49:58,160
to have the post-compromised resilient

1232
00:49:58,160 --> 00:50:00,160
and then we need some we needed some

1233
00:50:00,160 --> 00:50:02,319
random overhead with some structure

1234
00:50:02,319 --> 00:50:04,480
which was the bc as you're saying

1235
00:50:04,480 --> 00:50:06,000
yeah yeah yeah i think it's for pcs i

1236
00:50:06,000 --> 00:50:07,599
said that's because you need to open to

1237
00:50:07,599 --> 00:50:09,200
give the secret key and you needed like

1238
00:50:09,200 --> 00:50:11,680
more structure and on the meeting i said

1239
00:50:11,680 --> 00:50:12,640
interesting

1240
00:50:12,640 --> 00:50:14,319
yeah i think we can talk it offline but

1241
00:50:14,319 --> 00:50:16,880
basically yes

1242
00:50:19,920 --> 00:50:22,720
so by any chance uh just try to

1243
00:50:22,720 --> 00:50:24,880
incorporate this into

1244
00:50:24,880 --> 00:50:27,440
open source firmwares for wi-fi's or

1245
00:50:27,440 --> 00:50:30,319
something and see how that goes

1246
00:50:30,319 --> 00:50:33,280
um we didn't try it but we

1247
00:50:33,280 --> 00:50:34,960
looked at how this is actually

1248
00:50:34,960 --> 00:50:37,839
implemented for wp3 and we think that

1249
00:50:37,839 --> 00:50:41,200
it's very relatively straightforward to

1250
00:50:41,200 --> 00:50:42,720
incorporate we have the code we can

1251
00:50:42,720 --> 00:50:43,680
simply

1252
00:50:43,680 --> 00:50:46,240
go and put it in but we didn't actually

1253
00:50:46,240 --> 00:50:48,558
do it

1254
00:50:49,599 --> 00:50:54,359
all right let's thank the speaker again

1255
00:50:57,760 --> 00:51:00,000
and the next talk is called password

1256
00:51:00,000 --> 00:51:02,319
authenticated key exchange from group

1257
00:51:02,319 --> 00:51:06,160
actions by michelle abdullah thurston

1258
00:51:06,160 --> 00:51:08,960
eisenhofer ike kilts some

1259
00:51:08,960 --> 00:51:12,000
sabrina kunzweiler and the ring ripple

1260
00:51:12,000 --> 00:51:13,680
and the reena will

1261
00:51:13,680 --> 00:51:17,640
dorine will get the top

1262
00:51:43,680 --> 00:51:46,680
okay

1263
00:51:50,720 --> 00:51:53,599
thanks can you hear me

1264
00:51:53,599 --> 00:51:54,960
yes

1265
00:51:54,960 --> 00:51:55,760
good

1266
00:51:55,760 --> 00:51:58,000
uh yeah thanks for the introduction i i

1267
00:51:58,000 --> 00:51:59,599
will talk about uh password

1268
00:51:59,599 --> 00:52:01,920
authenticated key exchange uh from group

1269
00:52:01,920 --> 00:52:03,680
actions and this is joint work with

1270
00:52:03,680 --> 00:52:06,319
michelle abdullah torsten eisenhofer ike

1271
00:52:06,319 --> 00:52:09,760
kills and sabrina consuela

1272
00:52:09,760 --> 00:52:12,160
so the idea in a password authenticated

1273
00:52:12,160 --> 00:52:14,079
key exchange is that two parties can

1274
00:52:14,079 --> 00:52:16,400
agree upon a secure session key based

1275
00:52:16,400 --> 00:52:19,040
only on a low entropy string also known

1276
00:52:19,040 --> 00:52:21,520
as a password and thanks to my previous

1277
00:52:21,520 --> 00:52:23,839
speaker i don't have to motivate this

1278
00:52:23,839 --> 00:52:25,599
apart from this i also think it's a

1279
00:52:25,599 --> 00:52:27,920
really nice primitive to study

1280
00:52:27,920 --> 00:52:30,480
and we should use it more often

1281
00:52:30,480 --> 00:52:33,119
so consider two users alice and bob who

1282
00:52:33,119 --> 00:52:36,400
share like the a string a password and

1283
00:52:36,400 --> 00:52:38,640
only by exchanging some messages they

1284
00:52:38,640 --> 00:52:41,040
could should agree upon a secure session

1285
00:52:41,040 --> 00:52:43,520
key and what we mean by secure is that

1286
00:52:43,520 --> 00:52:46,079
we if we put an adversary in in the

1287
00:52:46,079 --> 00:52:48,800
interaction so let's uh take mallory and

1288
00:52:48,800 --> 00:52:51,040
he wants to impersonate bob

1289
00:52:51,040 --> 00:52:53,839
um he could for example guess a password

1290
00:52:53,839 --> 00:52:54,960
and

1291
00:52:54,960 --> 00:52:57,760
just try to complete the interaction and

1292
00:52:57,760 --> 00:52:59,599
at the end he should only know that that

1293
00:52:59,599 --> 00:53:01,760
was not the correct password this is

1294
00:53:01,760 --> 00:53:03,280
what we normally call an online

1295
00:53:03,280 --> 00:53:05,119
dictionary attack and in particular we

1296
00:53:05,119 --> 00:53:07,119
want to prevent these offline attacks

1297
00:53:07,119 --> 00:53:09,119
where the adversary could just after

1298
00:53:09,119 --> 00:53:11,119
this interaction brute force the

1299
00:53:11,119 --> 00:53:13,599
password space and we will see such an

1300
00:53:13,599 --> 00:53:16,160
attack later in my talk

1301
00:53:16,160 --> 00:53:18,160
um we will we want to build this

1302
00:53:18,160 --> 00:53:20,800
primitive fun group actions and group

1303
00:53:20,800 --> 00:53:22,880
actions um attracted

1304
00:53:22,880 --> 00:53:24,880
or got some attraction

1305
00:53:24,880 --> 00:53:27,359
recently because of

1306
00:53:27,359 --> 00:53:30,720
the the post quantum security

1307
00:53:30,720 --> 00:53:32,720
properties so this is very close to the

1308
00:53:32,720 --> 00:53:34,800
classical diffie-hellman setting

1309
00:53:34,800 --> 00:53:37,040
and the promising instantiation is given

1310
00:53:37,040 --> 00:53:38,800
by seaside

1311
00:53:38,800 --> 00:53:40,640
seaside is by the way not affected by

1312
00:53:40,640 --> 00:53:43,520
the recent attacks we had saw an sid age

1313
00:53:43,520 --> 00:53:44,559
so

1314
00:53:44,559 --> 00:53:46,160
keep the fingers crossed that we we

1315
00:53:46,160 --> 00:53:49,359
still have post quantum security here

1316
00:53:49,359 --> 00:53:51,040
and we have seen some

1317
00:53:51,040 --> 00:53:53,119
nice proposals for for example public

1318
00:53:53,119 --> 00:53:55,440
key encryption signatures and oblivious

1319
00:53:55,440 --> 00:53:57,359
transfer

1320
00:53:57,359 --> 00:53:59,520
and we thought okay can we now build

1321
00:53:59,520 --> 00:54:01,520
password authenticated key exchange from

1322
00:54:01,520 --> 00:54:02,880
group actions

1323
00:54:02,880 --> 00:54:04,480
and actually we were not the only ones

1324
00:54:04,480 --> 00:54:07,040
who thought about this um and there was

1325
00:54:07,040 --> 00:54:09,599
a nice work showing which approaches do

1326
00:54:09,599 --> 00:54:12,480
not work and this is mostly due to the

1327
00:54:12,480 --> 00:54:14,880
limited structure which a group action

1328
00:54:14,880 --> 00:54:16,319
offers

1329
00:54:16,319 --> 00:54:18,240
and then as the finding goal is to

1330
00:54:18,240 --> 00:54:20,640
instantiate it with seaside we have to

1331
00:54:20,640 --> 00:54:22,960
consider some additional properties of

1332
00:54:22,960 --> 00:54:25,760
seaside which also makes things harder

1333
00:54:25,760 --> 00:54:28,240
so at the moment we cannot take any

1334
00:54:28,240 --> 00:54:30,160
diffie-hellman based protocol which we

1335
00:54:30,160 --> 00:54:33,760
knew for years now to to just transfer

1336
00:54:33,760 --> 00:54:37,200
it to the group action setting directly

1337
00:54:37,200 --> 00:54:38,960
what we do know is some generic

1338
00:54:38,960 --> 00:54:40,720
constructions um

1339
00:54:40,720 --> 00:54:43,520
so we can will take from from oblivious

1340
00:54:43,520 --> 00:54:45,680
transfer for example but these generic

1341
00:54:45,680 --> 00:54:48,319
compilers are usually very inefficient

1342
00:54:48,319 --> 00:54:50,720
and also another very common approach is

1343
00:54:50,720 --> 00:54:52,400
to use a hash proof system

1344
00:54:52,400 --> 00:54:54,319
but this is also not clear how how we

1345
00:54:54,319 --> 00:54:57,040
can do this for the group action setting

1346
00:54:57,040 --> 00:54:57,839
um

1347
00:54:57,839 --> 00:55:00,079
yeah which brings me to

1348
00:55:00,079 --> 00:55:02,400
some technical intro so i

1349
00:55:02,400 --> 00:55:03,920
if you're not familiar with this i will

1350
00:55:03,920 --> 00:55:05,760
now talk a bit about the cryptographic

1351
00:55:05,760 --> 00:55:07,680
group action framework um which was

1352
00:55:07,680 --> 00:55:10,319
introduced by allah martial

1353
00:55:10,319 --> 00:55:11,760
at asia crypt

1354
00:55:11,760 --> 00:55:13,760
to to capture exactly the seaside

1355
00:55:13,760 --> 00:55:16,640
setting in a more approachable way

1356
00:55:16,640 --> 00:55:19,520
so we take a group g

1357
00:55:19,520 --> 00:55:22,000
and the group has some identity element

1358
00:55:22,000 --> 00:55:24,720
and we have a set x and now we say that

1359
00:55:24,720 --> 00:55:27,599
the group acts uh on the set x if we

1360
00:55:27,599 --> 00:55:30,799
have such a map which we denote by star

1361
00:55:30,799 --> 00:55:32,799
which satisfies the properties that if

1362
00:55:32,799 --> 00:55:35,040
we apply the identity to a set element

1363
00:55:35,040 --> 00:55:38,400
we should get the same set element back

1364
00:55:38,400 --> 00:55:40,559
and we can also perform computations

1365
00:55:40,559 --> 00:55:42,400
first in the group then apply the group

1366
00:55:42,400 --> 00:55:43,599
action

1367
00:55:43,599 --> 00:55:45,680
which should be the same as applying the

1368
00:55:45,680 --> 00:55:48,400
group action one up there not one after

1369
00:55:48,400 --> 00:55:50,400
another

1370
00:55:50,400 --> 00:55:52,079
in this paper they also introduced some

1371
00:55:52,079 --> 00:55:54,559
technical assumptions um which we need

1372
00:55:54,559 --> 00:55:56,240
for this setting is for example that the

1373
00:55:56,240 --> 00:55:59,280
group and the and the set are finite um

1374
00:55:59,280 --> 00:56:01,200
the group is also communicative and the

1375
00:56:01,200 --> 00:56:03,520
group action should be regular

1376
00:56:03,520 --> 00:56:05,440
that means if we take any two set

1377
00:56:05,440 --> 00:56:08,319
elements there is exactly one g which

1378
00:56:08,319 --> 00:56:10,240
maps from one settlement to the other

1379
00:56:10,240 --> 00:56:11,520
one

1380
00:56:11,520 --> 00:56:13,920
and for notational reasons also we we

1381
00:56:13,920 --> 00:56:16,559
need this distinguished element x tilde

1382
00:56:16,559 --> 00:56:18,319
which is just known to everyone and you

1383
00:56:18,319 --> 00:56:20,000
can think about this

1384
00:56:20,000 --> 00:56:22,400
something like a generator

1385
00:56:22,400 --> 00:56:25,040
of the set

1386
00:56:26,319 --> 00:56:28,720
and keep in mind so we we are we only

1387
00:56:28,720 --> 00:56:30,640
have a group action and in particular as

1388
00:56:30,640 --> 00:56:33,040
opposed to like the normal prime order

1389
00:56:33,040 --> 00:56:35,839
group setting we cannot combine two

1390
00:56:35,839 --> 00:56:38,559
elements of the set this is what makes

1391
00:56:38,559 --> 00:56:40,400
it hard to to construct very efficient

1392
00:56:40,400 --> 00:56:43,680
protocols which you will see later

1393
00:56:43,680 --> 00:56:45,760
which brings me to seaside so seaside is

1394
00:56:45,760 --> 00:56:48,400
the commutative super singular i thought

1395
00:56:48,400 --> 00:56:50,680
you needed helman it was proposed in

1396
00:56:50,680 --> 00:56:52,319
2018

1397
00:56:52,319 --> 00:56:54,240
and in this

1398
00:56:54,240 --> 00:56:56,640
framework by ala matierda they showed

1399
00:56:56,640 --> 00:56:58,640
that seaside is actually a restricted

1400
00:56:58,640 --> 00:57:00,559
effective group action

1401
00:57:00,559 --> 00:57:01,920
you don't need to know what these

1402
00:57:01,920 --> 00:57:04,640
technical terms means for for this talk

1403
00:57:04,640 --> 00:57:06,640
it will be enough to to live with the

1404
00:57:06,640 --> 00:57:08,799
abstraction i gave you before

1405
00:57:08,799 --> 00:57:11,520
and in seaside the group corresponds to

1406
00:57:11,520 --> 00:57:14,319
to the isogenies between elliptic curves

1407
00:57:14,319 --> 00:57:16,799
and the set is just uh the the set of

1408
00:57:16,799 --> 00:57:20,160
super singular elliptic curves over fp

1409
00:57:20,160 --> 00:57:22,160
and what is nice about this is that now

1410
00:57:22,160 --> 00:57:24,480
we can define all the computational

1411
00:57:24,480 --> 00:57:26,079
problems we know from the normal prime

1412
00:57:26,079 --> 00:57:28,319
order setting so we can define the

1413
00:57:28,319 --> 00:57:30,400
discrete log algorithm as given a set

1414
00:57:30,400 --> 00:57:32,799
element find the group element that maps

1415
00:57:32,799 --> 00:57:35,280
to it in the same way we can define the

1416
00:57:35,280 --> 00:57:37,359
computational difference

1417
00:57:37,359 --> 00:57:40,079
given two set elements compute the cdh

1418
00:57:40,079 --> 00:57:42,160
value of the two and then the decisional

1419
00:57:42,160 --> 00:57:43,599
version of this

1420
00:57:43,599 --> 00:57:45,839
and what we will need for our protocols

1421
00:57:45,839 --> 00:57:48,319
is a bit stronger so it's the strong or

1422
00:57:48,319 --> 00:57:50,880
gap cdh assumption

1423
00:57:50,880 --> 00:57:53,760
which is cdh but you also have

1424
00:57:53,760 --> 00:57:55,839
access to a decision oracle

1425
00:57:55,839 --> 00:57:58,240
and strong here means that this first

1426
00:57:58,240 --> 00:58:01,119
input to this oracle is always fixed and

1427
00:58:01,119 --> 00:58:03,200
the gap cdh is slightly stronger so that

1428
00:58:03,200 --> 00:58:04,960
the adversary can

1429
00:58:04,960 --> 00:58:08,880
choose all of the inputs to the function

1430
00:58:08,880 --> 00:58:10,000
okay

1431
00:58:10,000 --> 00:58:12,720
um a bit more about the the setting

1432
00:58:12,720 --> 00:58:14,000
opaque we

1433
00:58:14,000 --> 00:58:15,280
consider

1434
00:58:15,280 --> 00:58:16,160
so

1435
00:58:16,160 --> 00:58:18,400
we consider balanced or symmetric peg

1436
00:58:18,400 --> 00:58:20,160
where alice and bob share the same

1437
00:58:20,160 --> 00:58:22,079
password

1438
00:58:22,079 --> 00:58:23,200
and we

1439
00:58:23,200 --> 00:58:24,880
in our approach we use a game based

1440
00:58:24,880 --> 00:58:27,040
model and extend it to multiple test

1441
00:58:27,040 --> 00:58:29,280
queries so basically this is a key

1442
00:58:29,280 --> 00:58:31,040
industry initiability model the

1443
00:58:31,040 --> 00:58:34,960
adversary can actively intervene in the

1444
00:58:34,960 --> 00:58:37,200
with the parties and can send messages

1445
00:58:37,200 --> 00:58:39,280
or drop and inject messages and in the

1446
00:58:39,280 --> 00:58:40,319
end it

1447
00:58:40,319 --> 00:58:42,559
can choose several sessions for

1448
00:58:42,559 --> 00:58:44,400
challenge queries uh which means it will

1449
00:58:44,400 --> 00:58:45,839
either get the

1450
00:58:45,839 --> 00:58:48,160
real key or the random key

1451
00:58:48,160 --> 00:58:50,559
and this model um also captures perfect

1452
00:58:50,559 --> 00:58:52,160
forward secrecy

1453
00:58:52,160 --> 00:58:54,720
but uh for simplicity i will now only

1454
00:58:54,720 --> 00:58:56,960
concentrate uh

1455
00:58:56,960 --> 00:58:59,920
on weak forward secrecy which means that

1456
00:58:59,920 --> 00:59:01,520
if the

1457
00:59:01,520 --> 00:59:03,440
if the adversary wants to corrupt the

1458
00:59:03,440 --> 00:59:04,400
session

1459
00:59:04,400 --> 00:59:06,160
we need to require that he didn't

1460
00:59:06,160 --> 00:59:07,839
interfere before

1461
00:59:07,839 --> 00:59:09,680
so here you can see the adversary got

1462
00:59:09,680 --> 00:59:11,680
got the password and then we still want

1463
00:59:11,680 --> 00:59:15,680
key and distinguishability in this case

1464
00:59:15,680 --> 00:59:19,839
which brings me to our first protocol

1465
00:59:21,760 --> 00:59:24,400
as i said we cannot translate

1466
00:59:24,400 --> 00:59:27,200
the the prime order group

1467
00:59:27,200 --> 00:59:29,599
protocols we had but our ideas were

1468
00:59:29,599 --> 00:59:30,880
somehow

1469
00:59:30,880 --> 00:59:33,119
inspired by this simple password

1470
00:59:33,119 --> 00:59:35,119
exponential key exchange which was

1471
00:59:35,119 --> 00:59:38,319
proposed by jabla in in the 90s

1472
00:59:38,319 --> 00:59:41,119
and in this protocol also for you to get

1473
00:59:41,119 --> 00:59:42,880
used to this um

1474
00:59:42,880 --> 00:59:45,119
this notation what happens here is

1475
00:59:45,119 --> 00:59:46,720
basically that the user and the server

1476
00:59:46,720 --> 00:59:48,799
do a normal diffie-hellman key exchange

1477
00:59:48,799 --> 00:59:52,000
but the generator they use um is derived

1478
00:59:52,000 --> 00:59:54,640
um from a hash function so we hash the

1479
00:59:54,640 --> 00:59:57,440
the password to to a set element and

1480
00:59:57,440 --> 00:59:58,880
then we perform the diffie-hellman key

1481
00:59:58,880 --> 01:00:00,559
exchange and to derive the final

1482
01:00:00,559 --> 01:00:01,599
password

1483
01:00:01,599 --> 01:00:03,200
we will just put everything in another

1484
01:00:03,200 --> 01:00:04,880
hash function

1485
01:00:04,880 --> 01:00:07,280
why can't we just use this um well we

1486
01:00:07,280 --> 01:00:10,079
don't know uh such a hash function so

1487
01:00:10,079 --> 01:00:11,520
the problem of

1488
01:00:11,520 --> 01:00:14,640
hashing obliviously into super singular

1489
01:00:14,640 --> 01:00:17,280
isotony graphs is still unsolved so a

1490
01:00:17,280 --> 01:00:19,119
lot of people tried this especially this

1491
01:00:19,119 --> 01:00:20,160
year

1492
01:00:20,160 --> 01:00:22,000
but as long as we don't know such a hash

1493
01:00:22,000 --> 01:00:25,440
function we cannot use this approach

1494
01:00:25,440 --> 01:00:27,520
so we try to

1495
01:00:27,520 --> 01:00:29,599
extend it with a bit by bit approach and

1496
01:00:29,599 --> 01:00:31,599
if you have seen some other

1497
01:00:31,599 --> 01:00:33,760
constructions from group actions this

1498
01:00:33,760 --> 01:00:36,559
seems quite inherent for for many cases

1499
01:00:36,559 --> 01:00:38,240
um that you have to do this bitwise

1500
01:00:38,240 --> 01:00:40,640
thing because you you only have this one

1501
01:00:40,640 --> 01:00:44,240
group action what we do is we take a crs

1502
01:00:44,240 --> 01:00:46,319
consisting of two elements

1503
01:00:46,319 --> 01:00:49,040
and then we we interpret the password as

1504
01:00:49,040 --> 01:00:50,400
a bit string

1505
01:00:50,400 --> 01:00:53,040
and now for each password bit we will do

1506
01:00:53,040 --> 01:00:55,359
a diffie-hellman key exchange

1507
01:00:55,359 --> 01:00:58,559
so user and server both choose l group

1508
01:00:58,559 --> 01:01:00,720
elements then they will apply them to

1509
01:01:00,720 --> 01:01:02,720
the

1510
01:01:02,720 --> 01:01:04,960
corresponding crs element depending on

1511
01:01:04,960 --> 01:01:06,079
the bit

1512
01:01:06,079 --> 01:01:07,839
um they will compute the diffie-hellman

1513
01:01:07,839 --> 01:01:10,880
shares and hash everything

1514
01:01:10,880 --> 01:01:13,599
this looks quite easy and natural we can

1515
01:01:13,599 --> 01:01:16,079
try to analyze it security

1516
01:01:16,079 --> 01:01:18,400
so security against passive adversaries

1517
01:01:18,400 --> 01:01:20,240
is pretty straightforward if you're

1518
01:01:20,240 --> 01:01:22,000
familiar with these things so we can do

1519
01:01:22,000 --> 01:01:24,000
this under the strong cdh assumption in

1520
01:01:24,000 --> 01:01:26,480
the random oracle model what we would do

1521
01:01:26,480 --> 01:01:28,400
is we would embed the first element of

1522
01:01:28,400 --> 01:01:30,640
the cdh challenge in the user's message

1523
01:01:30,640 --> 01:01:32,960
and the second in the service message

1524
01:01:32,960 --> 01:01:35,040
and in order for the adversary to

1525
01:01:35,040 --> 01:01:37,359
distinguish the session key it must

1526
01:01:37,359 --> 01:01:40,079
query the random oracle on the solution

1527
01:01:40,079 --> 01:01:42,880
and we need the the ddh oracle just to

1528
01:01:42,880 --> 01:01:45,119
to patch things and and to get a tight

1529
01:01:45,119 --> 01:01:46,720
proof

1530
01:01:46,720 --> 01:01:49,520
we now look at active adversary

1531
01:01:49,520 --> 01:01:51,680
we can show that this protocol is secure

1532
01:01:51,680 --> 01:01:53,920
under the simultaneous defendant

1533
01:01:53,920 --> 01:01:55,359
assumption

1534
01:01:55,359 --> 01:01:57,359
also in the random oracle model this

1535
01:01:57,359 --> 01:01:59,520
assumption was used in the prime order

1536
01:01:59,520 --> 01:02:01,839
setting before it was well studied and

1537
01:02:01,839 --> 01:02:06,839
well it was proven in the ggm and agm

1538
01:02:06,960 --> 01:02:09,839
it's also used in in the cpase protocol

1539
01:02:09,839 --> 01:02:11,440
which is now being standardized but

1540
01:02:11,440 --> 01:02:13,520
unfortunately in this setting uh this

1541
01:02:13,520 --> 01:02:15,680
assumption does not hold anymore

1542
01:02:15,680 --> 01:02:18,559
um and this brings me to some additional

1543
01:02:18,559 --> 01:02:20,880
structure of the seaside group action

1544
01:02:20,880 --> 01:02:22,400
and this is

1545
01:02:22,400 --> 01:02:24,160
we are working with elliptic curves here

1546
01:02:24,160 --> 01:02:26,720
and each elliptic curve has a twist

1547
01:02:26,720 --> 01:02:29,359
which we can compute efficiently so what

1548
01:02:29,359 --> 01:02:32,480
that algebraically means is that if we

1549
01:02:32,480 --> 01:02:35,760
have a set element which is defined as g

1550
01:02:35,760 --> 01:02:38,720
acts on the original element then we can

1551
01:02:38,720 --> 01:02:42,720
efficiently compute g to the minus 1

1552
01:02:42,720 --> 01:02:45,440
times this origin element and this is

1553
01:02:45,440 --> 01:02:47,200
something we don't know of in the prime

1554
01:02:47,200 --> 01:02:49,200
water group setting and this will break

1555
01:02:49,200 --> 01:02:51,839
the assumption and i will demonstrate

1556
01:02:51,839 --> 01:02:53,760
this to you in an offline dictionary

1557
01:02:53,760 --> 01:02:54,799
attack

1558
01:02:54,799 --> 01:02:57,039
so we we look at the simplified case

1559
01:02:57,039 --> 01:02:59,359
with only one password bit here it's

1560
01:02:59,359 --> 01:03:02,640
naturally it extends to many bits so the

1561
01:03:02,640 --> 01:03:04,480
the adversary would just

1562
01:03:04,480 --> 01:03:08,000
ask for for a message of the user um

1563
01:03:08,000 --> 01:03:10,400
then it would also choose its secret but

1564
01:03:10,400 --> 01:03:13,200
then it wouldn't choose the crs element

1565
01:03:13,200 --> 01:03:15,520
i mean it doesn't know the password but

1566
01:03:15,520 --> 01:03:18,240
it will twist the element it just got

1567
01:03:18,240 --> 01:03:19,839
and send it over

1568
01:03:19,839 --> 01:03:21,680
the user will compute

1569
01:03:21,680 --> 01:03:24,319
will finish the the key exchange and now

1570
01:03:24,319 --> 01:03:27,200
now let's see what actually happens here

1571
01:03:27,200 --> 01:03:29,920
so what happens on the adversary side is

1572
01:03:29,920 --> 01:03:32,559
that we have this uh the inverse now of

1573
01:03:32,559 --> 01:03:35,839
the of the user secret and and then the

1574
01:03:35,839 --> 01:03:38,000
the twist um is defined to the origin

1575
01:03:38,000 --> 01:03:39,680
element so we would also have to take

1576
01:03:39,680 --> 01:03:41,839
the twist of the corresponding crs

1577
01:03:41,839 --> 01:03:43,520
element here

1578
01:03:43,520 --> 01:03:46,160
which means on the other side that the u

1579
01:03:46,160 --> 01:03:48,400
cancels out

1580
01:03:48,400 --> 01:03:49,920
and what the adversary can do it can

1581
01:03:49,920 --> 01:03:51,119
just

1582
01:03:51,119 --> 01:03:53,039
compute both diffie-hellman shares

1583
01:03:53,039 --> 01:03:54,720
because the user secret is not involved

1584
01:03:54,720 --> 01:03:55,920
anymore

1585
01:03:55,920 --> 01:03:58,880
and then it can offline check which

1586
01:03:58,880 --> 01:04:00,720
which bit it was like for one bit it's

1587
01:04:00,720 --> 01:04:03,039
not so interesting but you can maybe now

1588
01:04:03,039 --> 01:04:04,880
imagine that it extends too many bits

1589
01:04:04,880 --> 01:04:07,280
and we assume the password space to be

1590
01:04:07,280 --> 01:04:09,839
rather small so this would uh

1591
01:04:09,839 --> 01:04:13,039
yield the brute force attack

1592
01:04:13,039 --> 01:04:15,760
so we try to fix this issue

1593
01:04:15,760 --> 01:04:17,839
our first approach is

1594
01:04:17,839 --> 01:04:20,240
maybe quite quite natural if the the

1595
01:04:20,240 --> 01:04:22,319
attack depended on the on the fact that

1596
01:04:22,319 --> 01:04:24,720
the adversary could choose the message

1597
01:04:24,720 --> 01:04:27,119
depending on the other person's message

1598
01:04:27,119 --> 01:04:29,200
then why not just let the party commit

1599
01:04:29,200 --> 01:04:30,480
on this message

1600
01:04:30,480 --> 01:04:32,240
we model this with a with a random

1601
01:04:32,240 --> 01:04:33,760
oracle

1602
01:04:33,760 --> 01:04:36,000
and then we can prove security under the

1603
01:04:36,000 --> 01:04:38,720
gap cdh assumption

1604
01:04:38,720 --> 01:04:40,880
but i think that the more

1605
01:04:40,880 --> 01:04:43,839
interesting approach we or alternative

1606
01:04:43,839 --> 01:04:46,000
we also propose is

1607
01:04:46,000 --> 01:04:48,400
to use cross terms what that basically

1608
01:04:48,400 --> 01:04:50,079
means is we

1609
01:04:50,079 --> 01:04:51,760
we will increase the number of elements

1610
01:04:51,760 --> 01:04:53,839
and combine them in different ways and i

1611
01:04:53,839 --> 01:04:55,920
will show you now how this works so this

1612
01:04:55,920 --> 01:04:57,839
is the base protocol we had before the

1613
01:04:57,839 --> 01:04:59,520
insecure one

1614
01:04:59,520 --> 01:05:02,480
and now both parties will just choose

1615
01:05:02,480 --> 01:05:05,920
another l element they will send over

1616
01:05:05,920 --> 01:05:09,119
another l set elements and now we will

1617
01:05:09,119 --> 01:05:11,359
combine these in three different ways so

1618
01:05:11,359 --> 01:05:14,240
we will take the the original ones

1619
01:05:14,240 --> 01:05:15,680
uh like the

1620
01:05:15,680 --> 01:05:18,160
the uh messages we had before and then

1621
01:05:18,160 --> 01:05:20,799
we will combine um the original one with

1622
01:05:20,799 --> 01:05:22,559
the new ones and the other way around

1623
01:05:22,559 --> 01:05:24,000
actually we don't need all four

1624
01:05:24,000 --> 01:05:26,079
combinations three are enough to to

1625
01:05:26,079 --> 01:05:27,760
prove security

1626
01:05:27,760 --> 01:05:30,240
um and this allows us to prevent these

1627
01:05:30,240 --> 01:05:32,559
attacks we saw before because now the

1628
01:05:32,559 --> 01:05:34,160
both parties are

1629
01:05:34,160 --> 01:05:35,920
forced to use their secret in two

1630
01:05:35,920 --> 01:05:37,839
different ways

1631
01:05:37,839 --> 01:05:40,160
um so we also proved security for that

1632
01:05:40,160 --> 01:05:42,319
for positive bursaries not much changes

1633
01:05:42,319 --> 01:05:44,319
but now the interesting cases act

1634
01:05:44,319 --> 01:05:46,960
adversaries and there we we came up

1635
01:05:46,960 --> 01:05:49,119
first with an assumption which was like

1636
01:05:49,119 --> 01:05:51,520
mimicking the protocol and we tried it

1637
01:05:51,520 --> 01:05:53,920
to reduce it to something very simple

1638
01:05:53,920 --> 01:05:56,400
and we came up with a this square

1639
01:05:56,400 --> 01:05:58,799
inverse assumption it's actually uh

1640
01:05:58,799 --> 01:06:01,039
pretty simple so given only one set

1641
01:06:01,039 --> 01:06:02,240
element

1642
01:06:02,240 --> 01:06:04,559
the adversary has to compute three

1643
01:06:04,559 --> 01:06:06,079
elements so it can

1644
01:06:06,079 --> 01:06:08,799
really choose a base y

1645
01:06:08,799 --> 01:06:11,680
and then it has to compute a zenul c

1646
01:06:11,680 --> 01:06:14,319
zero which is the square of g applied to

1647
01:06:14,319 --> 01:06:15,280
y

1648
01:06:15,280 --> 01:06:18,079
and then the one which is the inverse of

1649
01:06:18,079 --> 01:06:19,520
g

1650
01:06:19,520 --> 01:06:20,960
applied to y

1651
01:06:20,960 --> 01:06:22,000
um

1652
01:06:22,000 --> 01:06:23,920
unfortunately we cannot reduce this to

1653
01:06:23,920 --> 01:06:25,599
any standard assumption because we have

1654
01:06:25,599 --> 01:06:27,520
this freedom in the y which is the same

1655
01:06:27,520 --> 01:06:29,280
as in the simultaneous if you helmet

1656
01:06:29,280 --> 01:06:31,680
assumption but we can now give some

1657
01:06:31,680 --> 01:06:34,480
algebraic

1658
01:06:34,799 --> 01:06:38,720
arguments why this is still secure

1659
01:06:38,720 --> 01:06:40,240
um

1660
01:06:40,240 --> 01:06:42,400
okay we we saw that we have to send a

1661
01:06:42,400 --> 01:06:44,400
lot of elements if you think of ls

1662
01:06:44,400 --> 01:06:46,640
linear in the security parameter so we

1663
01:06:46,640 --> 01:06:49,520
try to improve on that

1664
01:06:49,520 --> 01:06:52,079
so why do we take two elements and the

1665
01:06:52,079 --> 01:06:54,720
crs we can just take more of them

1666
01:06:54,720 --> 01:06:57,599
let's say n and then we we can keep the

1667
01:06:57,599 --> 01:06:59,599
password as it is but we will

1668
01:06:59,599 --> 01:07:02,000
basically interpret this as blocks of

1669
01:07:02,000 --> 01:07:05,440
bits and then for each block this will

1670
01:07:05,440 --> 01:07:06,720
map to

1671
01:07:06,720 --> 01:07:09,520
a value between 0 and n minus 1 and then

1672
01:07:09,520 --> 01:07:12,960
we will use this corresponding set a crs

1673
01:07:12,960 --> 01:07:15,119
element and

1674
01:07:15,119 --> 01:07:16,480
the

1675
01:07:16,480 --> 01:07:18,480
the conclusion is that we now can choose

1676
01:07:18,480 --> 01:07:21,599
a smaller value for l um

1677
01:07:21,599 --> 01:07:25,359
but we still get the same security

1678
01:07:25,359 --> 01:07:28,000
um also these these twists were were

1679
01:07:28,000 --> 01:07:30,480
used um to to optimize some other

1680
01:07:30,480 --> 01:07:32,319
protocols before and we thought oh maybe

1681
01:07:32,319 --> 01:07:34,160
we can do that also

1682
01:07:34,160 --> 01:07:37,039
but the only way we could identify to

1683
01:07:37,039 --> 01:07:39,680
use these twists um to optimize the

1684
01:07:39,680 --> 01:07:41,680
protocol is to

1685
01:07:41,680 --> 01:07:44,319
decrease the size of the crs so what we

1686
01:07:44,319 --> 01:07:47,119
now do we don't choose n elements but we

1687
01:07:47,119 --> 01:07:50,000
choose a n over two and we implicitly

1688
01:07:50,000 --> 01:07:52,480
define the second and over two elements

1689
01:07:52,480 --> 01:07:54,480
to be the twist

1690
01:07:54,480 --> 01:07:56,799
of the of the first ones um

1691
01:07:56,799 --> 01:07:59,280
and we also proved security for for

1692
01:07:59,280 --> 01:08:02,240
these uh two optimizations

1693
01:08:02,240 --> 01:08:04,799
um to give you now a short overview how

1694
01:08:04,799 --> 01:08:06,559
that actually compares to what we have

1695
01:08:06,559 --> 01:08:09,359
known before so before we had this uh we

1696
01:08:09,359 --> 01:08:11,440
only knew the how to build paid from

1697
01:08:11,440 --> 01:08:13,280
oblivious transfer there was this really

1698
01:08:13,280 --> 01:08:14,319
nice

1699
01:08:14,319 --> 01:08:17,520
ot protocol at eurocrypt last year

1700
01:08:17,520 --> 01:08:19,279
but the problem is that this the

1701
01:08:19,279 --> 01:08:21,520
compiler is still very very inefficient

1702
01:08:21,520 --> 01:08:23,359
so we basically have to run the ot

1703
01:08:23,359 --> 01:08:26,238
protocol also a linear

1704
01:08:26,238 --> 01:08:28,399
a linear number in the security

1705
01:08:28,399 --> 01:08:29,759
parameter

1706
01:08:29,759 --> 01:08:32,399
which means we have to send

1707
01:08:32,399 --> 01:08:35,600
more than like hundreds set elements and

1708
01:08:35,600 --> 01:08:38,158
with our optimizations we can get for

1709
01:08:38,158 --> 01:08:40,080
the same security we only have to send

1710
01:08:40,080 --> 01:08:43,198
16 or 32 because of this doubling of

1711
01:08:43,198 --> 01:08:44,880
elements

1712
01:08:44,880 --> 01:08:45,920
elements

1713
01:08:45,920 --> 01:08:48,080
this also translates to the number of

1714
01:08:48,080 --> 01:08:51,120
group actions we have to evaluate

1715
01:08:51,120 --> 01:08:53,759
and uh also in in terms of uh round

1716
01:08:53,759 --> 01:08:57,600
complexity we we can um improve uh

1717
01:08:57,600 --> 01:09:00,080
especially this cross-term approach um

1718
01:09:00,080 --> 01:09:02,000
allows us to to

1719
01:09:02,000 --> 01:09:04,319
get a one-round protocol this means both

1720
01:09:04,319 --> 01:09:06,479
parties can essentially send at the same

1721
01:09:06,479 --> 01:09:08,880
time which is of course not possible for

1722
01:09:08,880 --> 01:09:11,040
for this commitment version

1723
01:09:11,040 --> 01:09:12,399
um

1724
01:09:12,399 --> 01:09:14,719
however we need to rely on a

1725
01:09:14,719 --> 01:09:16,799
non-standard assumption i would say so

1726
01:09:16,799 --> 01:09:19,439
the gap cdh for for one of them and then

1727
01:09:19,439 --> 01:09:22,719
this new only well algebraically

1728
01:09:22,719 --> 01:09:24,319
secure

1729
01:09:24,319 --> 01:09:26,719
strong square inverse assumption

1730
01:09:26,719 --> 01:09:29,120
um but one other advantage of this is

1731
01:09:29,120 --> 01:09:31,198
that that we can get a tight proof here

1732
01:09:31,198 --> 01:09:32,158
and

1733
01:09:32,158 --> 01:09:33,439
since the other

1734
01:09:33,439 --> 01:09:35,679
assumptions um

1735
01:09:35,679 --> 01:09:37,600
that are actually used are interactive

1736
01:09:37,600 --> 01:09:40,640
we cannot get a type group there

1737
01:09:40,640 --> 01:09:41,839
okay

1738
01:09:41,839 --> 01:09:44,080
let me compute conclude with

1739
01:09:44,080 --> 01:09:46,880
a summary of what we did so we extend

1740
01:09:46,880 --> 01:09:47,759
this

1741
01:09:47,759 --> 01:09:49,839
framework of cryptographic group actions

1742
01:09:49,839 --> 01:09:51,040
by the twist

1743
01:09:51,040 --> 01:09:53,279
because we think well they offer

1744
01:09:53,279 --> 01:09:55,520
potential on the one hand to to improve

1745
01:09:55,520 --> 01:09:58,560
constructions but as we saw they also

1746
01:09:58,560 --> 01:10:00,560
should be considered in the security

1747
01:10:00,560 --> 01:10:02,800
analyzers because of this

1748
01:10:02,800 --> 01:10:04,880
new possibility to to compute the

1749
01:10:04,880 --> 01:10:06,880
inverse efficiently

1750
01:10:06,880 --> 01:10:08,960
with this we get the first

1751
01:10:08,960 --> 01:10:11,360
direct constructions which are probably

1752
01:10:11,360 --> 01:10:12,960
secure

1753
01:10:12,960 --> 01:10:15,360
and are way better in in terms of

1754
01:10:15,360 --> 01:10:17,679
efficiency than

1755
01:10:17,679 --> 01:10:19,520
everything we knew before for example

1756
01:10:19,520 --> 01:10:22,640
this ot to pay compiler

1757
01:10:22,640 --> 01:10:24,800
yes and that's concludes my talk thank

1758
01:10:24,800 --> 01:10:28,679
you for your attention

1759
01:10:32,159 --> 01:10:35,519
we have time for questions

1760
01:10:40,960 --> 01:10:43,520
i have a quick question

1761
01:10:43,520 --> 01:10:45,760
quantum security uh

1762
01:10:45,760 --> 01:10:47,600
do you think uh proof in the quantum

1763
01:10:47,600 --> 01:10:49,840
random oracle model makes sense and if

1764
01:10:49,840 --> 01:10:51,840
you look that into that

1765
01:10:51,840 --> 01:10:54,560
we looked a bit into that um

1766
01:10:54,560 --> 01:10:54,930
so

1767
01:10:54,930 --> 01:10:56,239
[Music]

1768
01:10:56,239 --> 01:10:58,159
we we have a follow-up work not looking

1769
01:10:58,159 --> 01:11:00,480
at pay but on on a

1770
01:11:00,480 --> 01:11:02,560
simpler setting um

1771
01:11:02,560 --> 01:11:04,560
so what will

1772
01:11:04,560 --> 01:11:07,120
pretty sure we what will work is if we

1773
01:11:07,120 --> 01:11:08,080
um

1774
01:11:08,080 --> 01:11:10,719
add one round of key confirmation that

1775
01:11:10,719 --> 01:11:12,640
often makes things in the quantum random

1776
01:11:12,640 --> 01:11:14,480
random oracle model easier because you

1777
01:11:14,480 --> 01:11:16,480
will send the information on the wire

1778
01:11:16,480 --> 01:11:18,400
and then you can extract actually what's

1779
01:11:18,400 --> 01:11:20,000
what's in there

1780
01:11:20,000 --> 01:11:22,719
for this protocol

1781
01:11:22,719 --> 01:11:24,880
we need to rely on a bit stronger

1782
01:11:24,880 --> 01:11:26,480
assumptions which

1783
01:11:26,480 --> 01:11:29,199
include this this quantum

1784
01:11:29,199 --> 01:11:33,440
decision assumptions or something

1785
01:11:33,440 --> 01:11:35,040
thank you

1786
01:11:35,040 --> 01:11:36,640
any more questions

1787
01:11:36,640 --> 01:11:38,480
yeah so a question about this um this

1788
01:11:38,480 --> 01:11:40,400
new assumption you mentioned that the

1789
01:11:40,400 --> 01:11:42,560
the y is particularly important and hard

1790
01:11:42,560 --> 01:11:44,640
to get rid of uh the square and the

1791
01:11:44,640 --> 01:11:46,560
inverse though you know are those powers

1792
01:11:46,560 --> 01:11:49,440
particularly important um

1793
01:11:49,440 --> 01:11:50,640
um

1794
01:11:50,640 --> 01:11:52,080
you know it could have been cuban

1795
01:11:52,080 --> 01:11:55,280
inverse for example

1796
01:11:55,280 --> 01:11:57,199
sorry what could that be a q could it

1797
01:11:57,199 --> 01:11:59,520
have been cube and inverse are the uh

1798
01:11:59,520 --> 01:12:00,880
you know is the nature of the assumption

1799
01:12:00,880 --> 01:12:02,480
particularly sensitive to the exponents

1800
01:12:02,480 --> 01:12:03,679
involved here

1801
01:12:03,679 --> 01:12:04,640
um

1802
01:12:04,640 --> 01:12:07,120
i'm not sure i think this was just the

1803
01:12:07,120 --> 01:12:09,520
easiest we could think of um so we

1804
01:12:09,520 --> 01:12:12,239
didn't try to extend it

1805
01:12:12,239 --> 01:12:14,400
sorry

1806
01:12:14,400 --> 01:12:19,400
all right let's thank the speaker again

1807
01:12:22,080 --> 01:12:24,719
and the last talk of the session is

1808
01:12:24,719 --> 01:12:27,760
called efficient physics and signatures

1809
01:12:27,760 --> 01:12:31,199
from commit and open protocols and the

1810
01:12:31,199 --> 01:12:33,520
quantum random oracle model

1811
01:12:33,520 --> 01:12:34,560
and

1812
01:12:34,560 --> 01:12:38,320
it's by elle dawn says here uh christian

1813
01:12:38,320 --> 01:12:41,120
mayans and christian

1814
01:12:41,120 --> 01:12:42,159
schaffner

1815
01:12:42,159 --> 01:12:46,839
and christian mayans will give the top

1816
01:12:50,080 --> 01:12:51,520
yeah thank you very much for the

1817
01:12:51,520 --> 01:12:52,640
introduction

1818
01:12:52,640 --> 01:12:54,960
um

1819
01:12:55,040 --> 01:12:57,520
yeah let's let's just wait until the

1820
01:12:57,520 --> 01:13:01,000
slides are up

1821
01:13:18,560 --> 01:13:19,840
okay

1822
01:13:19,840 --> 01:13:22,159
yes that works

1823
01:13:22,159 --> 01:13:25,120
yeah um it's great to um to give the the

1824
01:13:25,120 --> 01:13:27,120
last talk of this session i will talk

1825
01:13:27,120 --> 01:13:28,800
about um efficient physics and

1826
01:13:28,800 --> 01:13:30,000
signatures from commits and open

1827
01:13:30,000 --> 01:13:31,440
protocols and the quantum related oracle

1828
01:13:31,440 --> 01:13:33,679
model and uh yeah this is joint work

1829
01:13:33,679 --> 01:13:35,360
with pierre landon

1830
01:13:35,360 --> 01:13:37,440
and chris schaffner

1831
01:13:37,440 --> 01:13:38,640
um

1832
01:13:38,640 --> 01:13:40,640
so here's an outline i will start by

1833
01:13:40,640 --> 01:13:43,199
introducing our the problem that we were

1834
01:13:43,199 --> 01:13:44,960
working on and

1835
01:13:44,960 --> 01:13:47,440
give an overview of our results then i

1836
01:13:47,440 --> 01:13:49,600
will introduce the commit and open

1837
01:13:49,600 --> 01:13:51,199
protocols in more detail which are the

1838
01:13:51,199 --> 01:13:53,440
central object of our

1839
01:13:53,440 --> 01:13:56,239
of our study here and

1840
01:13:56,239 --> 01:13:58,640
then i will go on to describe

1841
01:13:58,640 --> 01:14:00,880
our extractor in the quantum mechanical

1842
01:14:00,880 --> 01:14:03,199
model um our main result and the

1843
01:14:03,199 --> 01:14:05,040
techniques we use to prove it and

1844
01:14:05,040 --> 01:14:06,880
finally i might touch upon our

1845
01:14:06,880 --> 01:14:08,960
additional result on the unroot

1846
01:14:08,960 --> 01:14:12,960
transform if i have time

1847
01:14:12,960 --> 01:14:15,840
let's start with the problem

1848
01:14:16,239 --> 01:14:18,000
uh to describe the problem i first need

1849
01:14:18,000 --> 01:14:18,719
to

1850
01:14:18,719 --> 01:14:20,400
say what a sigma protocol and the

1851
01:14:20,400 --> 01:14:22,880
theater mirror transform is um i i think

1852
01:14:22,880 --> 01:14:24,159
i can be brief because there were a

1853
01:14:24,159 --> 01:14:25,760
couple of introductions to um

1854
01:14:25,760 --> 01:14:28,080
interactive proof systems and and so on

1855
01:14:28,080 --> 01:14:30,239
already at this conference so here we

1856
01:14:30,239 --> 01:14:32,000
have an interactive proof system so

1857
01:14:32,000 --> 01:14:34,640
approver wants to convince a verifier of

1858
01:14:34,640 --> 01:14:37,040
the truth of the statement x so we can

1859
01:14:37,040 --> 01:14:39,280
think of x being in language l and

1860
01:14:39,280 --> 01:14:40,840
because we want to think about

1861
01:14:40,840 --> 01:14:43,199
extractability we also need a witness

1862
01:14:43,199 --> 01:14:45,120
relation r

1863
01:14:45,120 --> 01:14:47,280
so the proof proceeds by the prover

1864
01:14:47,280 --> 01:14:49,520
sending somewhere to try

1865
01:14:49,520 --> 01:14:51,360
the verifier sampling

1866
01:14:51,360 --> 01:14:54,000
uniformly random challenge from some set

1867
01:14:54,000 --> 01:14:56,480
c and then the

1868
01:14:56,480 --> 01:14:58,320
approver answers with the

1869
01:14:58,320 --> 01:15:00,239
response z

1870
01:15:00,239 --> 01:15:02,239
and now the verifier can evaluate some

1871
01:15:02,239 --> 01:15:04,480
uh verification predicate to decide

1872
01:15:04,480 --> 01:15:06,159
whether to accept or reject this this

1873
01:15:06,159 --> 01:15:06,960
proof

1874
01:15:06,960 --> 01:15:08,560
and the feature mirror transformation is

1875
01:15:08,560 --> 01:15:10,880
of course now a transformation that

1876
01:15:10,880 --> 01:15:13,199
replaces this random challenge by the

1877
01:15:13,199 --> 01:15:15,840
hash of um the problem usually of the

1878
01:15:15,840 --> 01:15:17,520
problem instance and

1879
01:15:17,520 --> 01:15:19,440
in the first message

1880
01:15:19,440 --> 01:15:21,520
this makes the the proof non-interactive

1881
01:15:21,520 --> 01:15:24,320
so now we have a non-interactive proof

1882
01:15:24,320 --> 01:15:28,480
system in in the random oracle model

1883
01:15:29,280 --> 01:15:31,840
so what is extractability

1884
01:15:31,840 --> 01:15:34,239
uh extractability is or sometimes also

1885
01:15:34,239 --> 01:15:36,560
called proof of knowledge property

1886
01:15:36,560 --> 01:15:40,000
here we want to guarantee that somebody

1887
01:15:40,000 --> 01:15:41,920
that is successful prover actually knows

1888
01:15:41,920 --> 01:15:42,880
a witness

1889
01:15:42,880 --> 01:15:45,199
so how do we guarantee this basically by

1890
01:15:45,199 --> 01:15:46,880
saying that there should exist an

1891
01:15:46,880 --> 01:15:49,600
extractor algorithm that has um some

1892
01:15:49,600 --> 01:15:52,560
kind of augmented access to

1893
01:15:52,560 --> 01:15:53,840
the prover

1894
01:15:53,840 --> 01:15:56,159
usually black box access but in some

1895
01:15:56,159 --> 01:15:59,040
sense enhanced um and should then

1896
01:15:59,040 --> 01:16:01,040
produce a witness from a successful

1897
01:16:01,040 --> 01:16:03,440
proverb

1898
01:16:04,320 --> 01:16:06,880
okay so here is an overview over this

1899
01:16:06,880 --> 01:16:09,440
situation of extractability of the

1900
01:16:09,440 --> 01:16:11,120
theatre mere transformation of different

1901
01:16:11,120 --> 01:16:12,560
kinds of sigma protocols and in

1902
01:16:12,560 --> 01:16:14,400
different settings

1903
01:16:14,400 --> 01:16:16,000
so if we have an arbitrary sigma

1904
01:16:16,000 --> 01:16:18,080
protocol and we are working in the

1905
01:16:18,080 --> 01:16:21,360
random oracle model then

1906
01:16:21,360 --> 01:16:24,000
this sigma protocol is extractable and

1907
01:16:24,000 --> 01:16:26,159
so here i assume the sigma protocol has

1908
01:16:26,159 --> 01:16:28,960
special soundness um

1909
01:16:28,960 --> 01:16:30,640
it's extractable but it's not tightly

1910
01:16:30,640 --> 01:16:32,960
extractable so basically that means that

1911
01:16:32,960 --> 01:16:34,880
if the prover has a success probability

1912
01:16:34,880 --> 01:16:35,600
p

1913
01:16:35,600 --> 01:16:37,840
then the extractor only succeeds with

1914
01:16:37,840 --> 01:16:39,920
the degraded success probability for

1915
01:16:39,920 --> 01:16:42,800
example p squared divided by q or p

1916
01:16:42,800 --> 01:16:44,880
divided by q depending on what kind of

1917
01:16:44,880 --> 01:16:47,120
run time we allow for

1918
01:16:47,120 --> 01:16:49,440
for the extractor

1919
01:16:49,440 --> 01:16:51,679
however if we restrict our attention to

1920
01:16:51,679 --> 01:16:54,800
a restricted class of um sigma protocols

1921
01:16:54,800 --> 01:16:56,719
that's called commit and open protocols

1922
01:16:56,719 --> 01:16:57,520
then

1923
01:16:57,520 --> 01:16:58,480
um

1924
01:16:58,480 --> 01:16:59,440
this is

1925
01:16:59,440 --> 01:17:00,960
turns out it turns out that the feature

1926
01:17:00,960 --> 01:17:02,800
mirror transformation is tightly

1927
01:17:02,800 --> 01:17:04,000
extractable

1928
01:17:04,000 --> 01:17:06,000
in the random oracle model

1929
01:17:06,000 --> 01:17:08,400
so here if the proper succeeds with the

1930
01:17:08,400 --> 01:17:10,400
probability p then

1931
01:17:10,400 --> 01:17:11,920
the extractor also succeeds with

1932
01:17:11,920 --> 01:17:13,600
probability p up to a negligible

1933
01:17:13,600 --> 01:17:15,040
difference

1934
01:17:15,040 --> 01:17:17,679
now if we're going to the quantum random

1935
01:17:17,679 --> 01:17:21,520
oracle model then um the sigma protocol

1936
01:17:21,520 --> 01:17:23,120
usually needs an additional property

1937
01:17:23,120 --> 01:17:24,719
that's called collapsingness but that's

1938
01:17:24,719 --> 01:17:26,560
not important in this talk

1939
01:17:26,560 --> 01:17:30,640
and um here also we get a result that

1940
01:17:30,640 --> 01:17:33,040
sigma the future mere transformation of

1941
01:17:33,040 --> 01:17:35,120
an arbitrary sigma protocol

1942
01:17:35,120 --> 01:17:36,640
with special soundness and

1943
01:17:36,640 --> 01:17:38,960
collapsingness is extractable

1944
01:17:38,960 --> 01:17:41,760
and again there's a degraded extraction

1945
01:17:41,760 --> 01:17:44,080
probability

1946
01:17:44,080 --> 01:17:46,239
but if we now move to commit and open

1947
01:17:46,239 --> 01:17:49,760
protocols then um prior to our work

1948
01:17:49,760 --> 01:17:52,400
also the best result was

1949
01:17:52,400 --> 01:17:55,600
a non-tight extractor so that has

1950
01:17:55,600 --> 01:17:59,040
an extraction probability that is um

1951
01:17:59,040 --> 01:18:01,840
that that has a loss of uh the square of

1952
01:18:01,840 --> 01:18:03,679
the number of random or quantum random

1953
01:18:03,679 --> 01:18:05,040
oracle queries

1954
01:18:05,040 --> 01:18:06,400
and there's some no reason why this

1955
01:18:06,400 --> 01:18:07,679
would be the case

1956
01:18:07,679 --> 01:18:09,600
um so some of some of this there's no

1957
01:18:09,600 --> 01:18:11,600
natural obstruction why we shouldn't get

1958
01:18:11,600 --> 01:18:14,400
tight online extractability

1959
01:18:14,400 --> 01:18:16,080
for these for the feature new

1960
01:18:16,080 --> 01:18:17,280
transformation of commits and open

1961
01:18:17,280 --> 01:18:19,840
protocols

1962
01:18:20,960 --> 01:18:24,480
and this brings me to to our results so

1963
01:18:24,480 --> 01:18:26,480
we indeed construct

1964
01:18:26,480 --> 01:18:29,600
an online extractor for um the future

1965
01:18:29,600 --> 01:18:31,120
mere transformation of commits and open

1966
01:18:31,120 --> 01:18:32,640
protocols in the quantum media market

1967
01:18:32,640 --> 01:18:35,199
model and this is a tight

1968
01:18:35,199 --> 01:18:36,480
extractor

1969
01:18:36,480 --> 01:18:38,480
and we also extend this

1970
01:18:38,480 --> 01:18:41,040
this extractor to um

1971
01:18:41,040 --> 01:18:43,199
so-called merkle tree based commitments

1972
01:18:43,199 --> 01:18:45,120
i will later describe what what i mean

1973
01:18:45,120 --> 01:18:46,000
by that

1974
01:18:46,000 --> 01:18:48,400
um and in addition we modularize and

1975
01:18:48,400 --> 01:18:50,480
improve the so-called unreal transform

1976
01:18:50,480 --> 01:18:52,640
which is a different transformation to

1977
01:18:52,640 --> 01:18:55,520
construct a nazik from a sigma protocol

1978
01:18:55,520 --> 01:18:56,640
that is

1979
01:18:56,640 --> 01:18:58,239
online extractable

1980
01:18:58,239 --> 01:18:59,280
as well

1981
01:18:59,280 --> 01:19:01,920
and and finally we apply our results to

1982
01:19:01,920 --> 01:19:05,520
the picnic digital signature scheme

1983
01:19:06,480 --> 01:19:08,880
so here's some related works um the

1984
01:19:08,880 --> 01:19:11,920
first to kind of um formulate the

1985
01:19:11,920 --> 01:19:14,719
problem of uh online extractability of

1986
01:19:14,719 --> 01:19:16,719
the theater mere transformation of

1987
01:19:16,719 --> 01:19:18,719
commitment open stigma protocols was it

1988
01:19:18,719 --> 01:19:19,920
was shayu

1989
01:19:19,920 --> 01:19:20,800
and

1990
01:19:20,800 --> 01:19:22,320
he has

1991
01:19:22,320 --> 01:19:25,840
published a result on this um however um

1992
01:19:25,840 --> 01:19:28,159
there turns out to be a subtle flaw in

1993
01:19:28,159 --> 01:19:30,560
in the proof which was then fixed but

1994
01:19:30,560 --> 01:19:33,040
using a specific assumption that that

1995
01:19:33,040 --> 01:19:35,040
depends on the scheme on the sigma

1996
01:19:35,040 --> 01:19:38,480
protocol that is transformed

1997
01:19:38,480 --> 01:19:40,239
and in addition there's also a work by

1998
01:19:40,239 --> 01:19:43,280
kiesa manohar and spooner

1999
01:19:43,280 --> 01:19:45,440
which analyzes a specific snark

2000
01:19:45,440 --> 01:19:47,040
construction

2001
01:19:47,040 --> 01:19:47,840
this

2002
01:19:47,840 --> 01:19:49,760
turns out to bear quite some similarity

2003
01:19:49,760 --> 01:19:52,400
to our merkle tree commitment result but

2004
01:19:52,400 --> 01:19:55,600
somehow this um this paper was um a bit

2005
01:19:55,600 --> 01:19:57,679
missed in in the analysis of

2006
01:19:57,679 --> 01:20:00,080
the picnic signature scheme and we also

2007
01:20:00,080 --> 01:20:02,800
only realized um that this is similar

2008
01:20:02,800 --> 01:20:06,400
after we completed our work

2009
01:20:08,239 --> 01:20:09,840
okay so this was

2010
01:20:09,840 --> 01:20:12,400
the overview now let's get a bit more

2011
01:20:12,400 --> 01:20:14,400
into the details so first of all i want

2012
01:20:14,400 --> 01:20:15,920
to describe what commit and open

2013
01:20:15,920 --> 01:20:18,159
protocols are

2014
01:20:18,159 --> 01:20:19,679
so commit an open protocol is a

2015
01:20:19,679 --> 01:20:22,960
particular structure of a particular

2016
01:20:22,960 --> 01:20:25,360
kind of sigma protocol where the first

2017
01:20:25,360 --> 01:20:27,360
message consists just of a bunch of

2018
01:20:27,360 --> 01:20:30,320
commitments to messages m1 up to ml

2019
01:20:30,320 --> 01:20:34,159
and now the challenge is just um

2020
01:20:34,159 --> 01:20:36,239
a subset of

2021
01:20:36,239 --> 01:20:38,159
these messages and the response is

2022
01:20:38,159 --> 01:20:40,800
support is in the opening of

2023
01:20:40,800 --> 01:20:43,600
the subset of commitments

2024
01:20:43,600 --> 01:20:45,040
of course we can also feature a mere

2025
01:20:45,040 --> 01:20:49,600
transform such a commit an open protocol

2026
01:20:50,000 --> 01:20:51,679
now if we look at

2027
01:20:51,679 --> 01:20:54,320
these commitment open protocols

2028
01:20:54,320 --> 01:20:56,800
the property that we need is that

2029
01:20:56,800 --> 01:20:58,560
the approver needs to be able to commit

2030
01:20:58,560 --> 01:21:00,239
to a bunch of messages and it the

2031
01:21:00,239 --> 01:21:01,840
approver also needs to be able to open

2032
01:21:01,840 --> 01:21:04,000
this up a subset of failure

2033
01:21:04,000 --> 01:21:04,880
and

2034
01:21:04,880 --> 01:21:07,120
um somehow

2035
01:21:07,120 --> 01:21:08,880
that means that any kind of collective

2036
01:21:08,880 --> 01:21:10,639
commitment would also work as long as we

2037
01:21:10,639 --> 01:21:12,560
can open a subset of them

2038
01:21:12,560 --> 01:21:14,880
and this is what is done in picnic so

2039
01:21:14,880 --> 01:21:17,840
there a merkle tree is used to commit to

2040
01:21:17,840 --> 01:21:20,560
all the messages at once and then um

2041
01:21:20,560 --> 01:21:23,040
basically

2042
01:21:23,040 --> 01:21:25,520
the authentication paths are

2043
01:21:25,520 --> 01:21:28,920
used to open

2044
01:21:29,199 --> 01:21:30,800
okay so now when we know what the

2045
01:21:30,800 --> 01:21:32,560
commits and open protocol is and let's

2046
01:21:32,560 --> 01:21:34,400
go back to thinking about the plane

2047
01:21:34,400 --> 01:21:36,000
commit an open protocol with atomic

2048
01:21:36,000 --> 01:21:37,840
commitments for each message

2049
01:21:37,840 --> 01:21:38,960
and

2050
01:21:38,960 --> 01:21:41,040
let me describe how online extractable

2051
01:21:41,040 --> 01:21:43,440
works extra extractability works in the

2052
01:21:43,440 --> 01:21:46,638
random oracle model first

2053
01:21:46,880 --> 01:21:48,719
so here we have an adversary against the

2054
01:21:48,719 --> 01:21:51,120
fiat mirror transform for simplicity we

2055
01:21:51,120 --> 01:21:53,440
use again a special sound commit an open

2056
01:21:53,440 --> 01:21:56,080
protocol so how does that work um the

2057
01:21:56,080 --> 01:21:58,960
adversary gets an instance then it makes

2058
01:21:58,960 --> 01:22:00,719
a bunch of queries to the random oracle

2059
01:22:00,719 --> 01:22:04,320
h and then it outputs the proof

2060
01:22:04,320 --> 01:22:05,920
now the extractor

2061
01:22:05,920 --> 01:22:07,520
needs some augmented access to the

2062
01:22:07,520 --> 01:22:09,120
adversary and here this means that the

2063
01:22:09,120 --> 01:22:11,360
extractor gets the proof as well as the

2064
01:22:11,360 --> 01:22:13,440
transcript of the queries the adversary

2065
01:22:13,440 --> 01:22:16,480
made to the random article

2066
01:22:16,560 --> 01:22:18,639
now how does extraction work it's very

2067
01:22:18,639 --> 01:22:20,239
easy um

2068
01:22:20,239 --> 01:22:21,920
somehow given the transcript the

2069
01:22:21,920 --> 01:22:23,440
extractor can just

2070
01:22:23,440 --> 01:22:25,120
extract the commitments

2071
01:22:25,120 --> 01:22:26,719
in the vector y

2072
01:22:26,719 --> 01:22:28,880
and if um

2073
01:22:28,880 --> 01:22:31,520
if the openings to these commitments are

2074
01:22:31,520 --> 01:22:33,840
valid then the extractor can just

2075
01:22:33,840 --> 01:22:36,400
compile two proofs from these openings

2076
01:22:36,400 --> 01:22:38,320
and feed them into the special soundness

2077
01:22:38,320 --> 01:22:39,440
extractor

2078
01:22:39,440 --> 01:22:43,120
and thereby obtain a witness

2079
01:22:44,960 --> 01:22:47,679
so why does this extractor work

2080
01:22:47,679 --> 01:22:49,920
and of course i mean if these

2081
01:22:49,920 --> 01:22:51,280
commitments that are sent in the

2082
01:22:51,280 --> 01:22:53,280
beginning if they are all too valid

2083
01:22:53,280 --> 01:22:55,679
messages um then everything is fine

2084
01:22:55,679 --> 01:22:57,679
right and in the interactive setting

2085
01:22:57,679 --> 01:22:59,360
it's completely clear why this needs to

2086
01:22:59,360 --> 01:23:01,520
be the case because the approver doesn't

2087
01:23:01,520 --> 01:23:03,679
know which challenge it will receive but

2088
01:23:03,679 --> 01:23:05,440
then in the in the fetch amir

2089
01:23:05,440 --> 01:23:08,080
transformed setting um

2090
01:23:08,080 --> 01:23:10,639
you know it's it's it's easy to produce

2091
01:23:10,639 --> 01:23:12,639
um usually it's easy to produce a bunch

2092
01:23:12,639 --> 01:23:15,120
of commitments and then uh openings for

2093
01:23:15,120 --> 01:23:16,400
one challenge

2094
01:23:16,400 --> 01:23:18,960
and the adversary could try to um

2095
01:23:18,960 --> 01:23:21,840
to do that right in principle um

2096
01:23:21,840 --> 01:23:23,280
the only one

2097
01:23:23,280 --> 01:23:26,000
opening is involved in the in the proof

2098
01:23:26,000 --> 01:23:27,360
however

2099
01:23:27,360 --> 01:23:29,520
we can see that this is not so easy so

2100
01:23:29,520 --> 01:23:31,040
if we think of a

2101
01:23:31,040 --> 01:23:33,360
for simplicity of a protocol where the

2102
01:23:33,360 --> 01:23:36,000
challenges are subsets of size are

2103
01:23:36,000 --> 01:23:37,600
then um

2104
01:23:37,600 --> 01:23:40,080
we can think about what a an adversary

2105
01:23:40,080 --> 01:23:41,280
needs to do

2106
01:23:41,280 --> 01:23:42,000
to

2107
01:23:42,000 --> 01:23:43,679
convince the prover but to make the

2108
01:23:43,679 --> 01:23:45,920
extractor fail

2109
01:23:45,920 --> 01:23:48,400
so in that case basically the adversary

2110
01:23:48,400 --> 01:23:51,679
can only ever um query the messages to

2111
01:23:51,679 --> 01:23:53,920
the random oracle that it will open

2112
01:23:53,920 --> 01:23:55,760
later

2113
01:23:55,760 --> 01:23:56,880
however that

2114
01:23:56,880 --> 01:23:58,639
remember that the challenge is the hash

2115
01:23:58,639 --> 01:24:00,639
of um of this vector of commitment so

2116
01:24:00,639 --> 01:24:02,880
basically it turns out that this

2117
01:24:02,880 --> 01:24:05,199
basically defines a hard oracle search

2118
01:24:05,199 --> 01:24:08,400
task so the search task is as follows

2119
01:24:08,400 --> 01:24:11,840
if an adversary succeeds um but it

2120
01:24:11,840 --> 01:24:13,920
basically makes the extractor fail then

2121
01:24:13,920 --> 01:24:16,080
it needs to follow solve the following

2122
01:24:16,080 --> 01:24:17,040
problem

2123
01:24:17,040 --> 01:24:18,719
find a valid

2124
01:24:18,719 --> 01:24:20,000
pair of

2125
01:24:20,000 --> 01:24:23,360
commitments y and openings m

2126
01:24:23,360 --> 01:24:25,040
for the challenge given by the hash of

2127
01:24:25,040 --> 01:24:29,040
the um of y without querying any valid

2128
01:24:29,040 --> 01:24:30,400
messages

2129
01:24:30,400 --> 01:24:32,800
that are not opened later

2130
01:24:32,800 --> 01:24:34,320
and i would call this

2131
01:24:34,320 --> 01:24:36,000
an artificial search task because

2132
01:24:36,000 --> 01:24:38,800
somehow the task is described by

2133
01:24:38,800 --> 01:24:40,800
referring to the transcript of queries

2134
01:24:40,800 --> 01:24:44,560
of um of the algorithm that solves it

2135
01:24:44,560 --> 01:24:46,400
however it's kind of not too not too

2136
01:24:46,400 --> 01:24:48,239
hard to see that this is a hard task and

2137
01:24:48,239 --> 01:24:51,120
that basically gives us the proof of um

2138
01:24:51,120 --> 01:24:53,600
tight extractability of the fear-to-mere

2139
01:24:53,600 --> 01:24:54,880
transformation of committed open

2140
01:24:54,880 --> 01:24:59,159
protocols in the random oracle model

2141
01:25:00,480 --> 01:25:02,239
okay so and this was kind of the

2142
01:25:02,239 --> 01:25:04,560
background the classic one now let's get

2143
01:25:04,560 --> 01:25:06,719
to the to the quantum mechanical model

2144
01:25:06,719 --> 01:25:08,880
extractor and it turns out that there's

2145
01:25:08,880 --> 01:25:10,480
a couple of problems for example there's

2146
01:25:10,480 --> 01:25:13,199
no transcript of queries because these

2147
01:25:13,199 --> 01:25:14,639
are quantum queries and they cannot be

2148
01:25:14,639 --> 01:25:17,360
copied into a transcript however there's

2149
01:25:17,360 --> 01:25:19,120
this marvelous tool called a compare

2150
01:25:19,120 --> 01:25:22,560
historical that was introduced by gendry

2151
01:25:22,560 --> 01:25:25,199
and it kind of serves as a transcript

2152
01:25:25,199 --> 01:25:27,840
therefore we can basically construct

2153
01:25:27,840 --> 01:25:29,520
an extractor based on the compare

2154
01:25:29,520 --> 01:25:30,960
historical

2155
01:25:30,960 --> 01:25:32,000
so

2156
01:25:32,000 --> 01:25:34,159
now we're looking at an adversary this

2157
01:25:34,159 --> 01:25:36,000
is a quantum adversary against the

2158
01:25:36,000 --> 01:25:38,560
theater mere transformation of a special

2159
01:25:38,560 --> 01:25:40,080
sound commit an open protocol in the

2160
01:25:40,080 --> 01:25:42,000
quantum memorandum model so this

2161
01:25:42,000 --> 01:25:44,960
adversary will get an instance then make

2162
01:25:44,960 --> 01:25:46,800
some grace to the quantum random article

2163
01:25:46,800 --> 01:25:49,040
that we now instantiate with the

2164
01:25:49,040 --> 01:25:50,880
compressed oracle

2165
01:25:50,880 --> 01:25:54,080
um and then it will produce a proof so

2166
01:25:54,080 --> 01:25:56,080
the compressed oracle is the stateful

2167
01:25:56,080 --> 01:25:58,239
simulation of a quantum accessible

2168
01:25:58,239 --> 01:26:00,159
random article and it has this internal

2169
01:26:00,159 --> 01:26:02,239
state that we call a database that's

2170
01:26:02,239 --> 01:26:03,920
called d

2171
01:26:03,920 --> 01:26:06,880
now the extractor just gets as input the

2172
01:26:06,880 --> 01:26:09,199
proof as well as this database of the

2173
01:26:09,199 --> 01:26:11,120
oracle simulation

2174
01:26:11,120 --> 01:26:12,719
and it turns out that basically it can

2175
01:26:12,719 --> 01:26:15,360
just proceed exactly as in the classical

2176
01:26:15,360 --> 01:26:17,040
setting it can extract the commitments

2177
01:26:17,040 --> 01:26:18,719
using their database

2178
01:26:18,719 --> 01:26:21,280
and then it can feed the result into the

2179
01:26:21,280 --> 01:26:23,120
special soundness extractor to obtain a

2180
01:26:23,120 --> 01:26:25,440
witness

2181
01:26:25,760 --> 01:26:27,840
now again of course the the million

2182
01:26:27,840 --> 01:26:29,600
dollar question is why does this

2183
01:26:29,600 --> 01:26:32,320
extractor work

2184
01:26:32,719 --> 01:26:36,159
um and again we can formulate

2185
01:26:36,159 --> 01:26:38,800
an artificial search task

2186
01:26:38,800 --> 01:26:40,960
that an adversary needs to solve to be

2187
01:26:40,960 --> 01:26:43,440
successful in convincing the verifier

2188
01:26:43,440 --> 01:26:45,360
but to make the extractor fail

2189
01:26:45,360 --> 01:26:47,840
however it turns out that is slightly

2190
01:26:47,840 --> 01:26:50,960
more artificial in this setting because

2191
01:26:50,960 --> 01:26:53,280
if you remember in the last in the case

2192
01:26:53,280 --> 01:26:56,000
of the rom we had this oracle search

2193
01:26:56,000 --> 01:26:57,920
task but it was basically a task of

2194
01:26:57,920 --> 01:26:59,600
searching a random article

2195
01:26:59,600 --> 01:27:02,239
so now we don't have a task of searching

2196
01:27:02,239 --> 01:27:04,960
a quantum random article we have a task

2197
01:27:04,960 --> 01:27:08,320
of searching um in this compressed

2198
01:27:08,320 --> 01:27:11,040
oracle because basically

2199
01:27:11,040 --> 01:27:13,840
the task is to to find a vector of

2200
01:27:13,840 --> 01:27:16,800
commitments and the openings m

2201
01:27:16,800 --> 01:27:18,719
corresponding to the challenge

2202
01:27:18,719 --> 01:27:21,199
obtained from querying the the um

2203
01:27:21,199 --> 01:27:24,159
the random the compressed oracle

2204
01:27:24,159 --> 01:27:26,960
but in a way such that no additional

2205
01:27:26,960 --> 01:27:28,719
openings are in the database of the

2206
01:27:28,719 --> 01:27:30,800
comparison oracle so this is basically a

2207
01:27:30,800 --> 01:27:32,560
task that directly refers to this

2208
01:27:32,560 --> 01:27:36,239
database of the compressed article

2209
01:27:36,400 --> 01:27:38,880
so first of all it's nice that

2210
01:27:38,880 --> 01:27:41,440
there's already a nice body of

2211
01:27:41,440 --> 01:27:43,679
literature of lower bounds for

2212
01:27:43,679 --> 01:27:45,600
compressed oracle so basically

2213
01:27:45,600 --> 01:27:48,000
compressed oracle techniques for lower

2214
01:27:48,000 --> 01:27:50,239
bounds that for the quantum render

2215
01:27:50,239 --> 01:27:52,159
oracle model

2216
01:27:52,159 --> 01:27:53,120
however

2217
01:27:53,120 --> 01:27:56,239
um these are not readily used in the

2218
01:27:56,239 --> 01:27:58,960
case where of our weird predicate that

2219
01:27:58,960 --> 01:28:00,880
depends directly on

2220
01:28:00,880 --> 01:28:04,719
the database of the compressed oracle

2221
01:28:06,800 --> 01:28:10,320
so now let me present our main result so

2222
01:28:10,320 --> 01:28:13,199
we overcome this

2223
01:28:13,199 --> 01:28:15,360
this problem and prove the following

2224
01:28:15,360 --> 01:28:16,320
theorem

2225
01:28:16,320 --> 01:28:18,080
so basically what we prove is that the

2226
01:28:18,080 --> 01:28:20,159
the extractor that i just presented

2227
01:28:20,159 --> 01:28:22,960
works so that means that for the fiat

2228
01:28:22,960 --> 01:28:25,040
mere transformation of a commit an open

2229
01:28:25,040 --> 01:28:27,520
protocol with any of a very general

2230
01:28:27,520 --> 01:28:29,360
class of special soundness like

2231
01:28:29,360 --> 01:28:31,679
properties there exists an online

2232
01:28:31,679 --> 01:28:33,040
extractor

2233
01:28:33,040 --> 01:28:34,800
um that

2234
01:28:34,800 --> 01:28:37,120
extracts a witness whenever the prover

2235
01:28:37,120 --> 01:28:39,600
succeeds except with the negligible

2236
01:28:39,600 --> 01:28:41,440
difference in the quantum media oracle

2237
01:28:41,440 --> 01:28:44,000
model and as i said this also works in

2238
01:28:44,000 --> 01:28:45,920
the case of these merkle tree

2239
01:28:45,920 --> 01:28:48,480
commitments

2240
01:28:49,360 --> 01:28:51,600
and for the proof we pick one of these

2241
01:28:51,600 --> 01:28:54,239
existing um

2242
01:28:54,239 --> 01:28:55,840
lower bound techniques from the

2243
01:28:55,840 --> 01:28:57,760
literature um

2244
01:28:57,760 --> 01:28:59,840
it's a framework for query lower bound

2245
01:28:59,840 --> 01:29:03,199
by uh zhong fair huang and liao and we

2246
01:29:03,199 --> 01:29:05,679
generalize it to kind of allow these

2247
01:29:05,679 --> 01:29:08,480
more general uh predicates that depend

2248
01:29:08,480 --> 01:29:12,718
on the comprehensive database

2249
01:29:13,199 --> 01:29:15,440
this is great because now we have this

2250
01:29:15,440 --> 01:29:17,840
tight online extractability in the

2251
01:29:17,840 --> 01:29:19,920
quantum random oracle model for the fear

2252
01:29:19,920 --> 01:29:21,280
terminal transformation of commit and

2253
01:29:21,280 --> 01:29:23,199
open protocol so we fixed this table

2254
01:29:23,199 --> 01:29:25,440
that i showed you earlier so that we

2255
01:29:25,440 --> 01:29:26,880
also get

2256
01:29:26,880 --> 01:29:28,400
that the extractor succeeds with the

2257
01:29:28,400 --> 01:29:30,960
same probability as the prover succeeds

2258
01:29:30,960 --> 01:29:34,400
up to a negligible difference

2259
01:29:35,760 --> 01:29:37,440
as an application we can apply this

2260
01:29:37,440 --> 01:29:39,280
result to the picnic digital signature

2261
01:29:39,280 --> 01:29:41,600
scheme so this is a digital signature

2262
01:29:41,600 --> 01:29:44,560
scheme that is based on a fear-to-mere

2263
01:29:44,560 --> 01:29:46,719
transformation of

2264
01:29:46,719 --> 01:29:48,560
a sigma protocol that's constructed

2265
01:29:48,560 --> 01:29:51,120
using the npc in the head paradigm this

2266
01:29:51,120 --> 01:29:54,800
is a um an idea of how to construct a

2267
01:29:54,800 --> 01:29:56,560
particular sigma protocols that turn out

2268
01:29:56,560 --> 01:30:00,000
to be committed in open signal protocols

2269
01:30:00,000 --> 01:30:01,760
and it's nice because this digital

2270
01:30:01,760 --> 01:30:03,440
signature scheme is provably secure in

2271
01:30:03,440 --> 01:30:04,719
the curom

2272
01:30:04,719 --> 01:30:06,560
at least you know it can be provably

2273
01:30:06,560 --> 01:30:08,080
based on the security of a couple of

2274
01:30:08,080 --> 01:30:10,159
underlying symmetric key primitives

2275
01:30:10,159 --> 01:30:13,120
including a block cipher

2276
01:30:13,120 --> 01:30:15,199
however previously the the proof of this

2277
01:30:15,199 --> 01:30:16,159
um

2278
01:30:16,159 --> 01:30:17,920
the security proof was a very much

2279
01:30:17,920 --> 01:30:21,360
non-tight with both a power loss and a

2280
01:30:21,360 --> 01:30:23,199
loss that's polynomial in the number of

2281
01:30:23,199 --> 01:30:24,639
queries

2282
01:30:24,639 --> 01:30:27,600
to the random article

2283
01:30:27,840 --> 01:30:29,600
now our result can be used to improve

2284
01:30:29,600 --> 01:30:31,040
over this

2285
01:30:31,040 --> 01:30:33,199
and get a multiple multiplicatively

2286
01:30:33,199 --> 01:30:34,960
tight reduction

2287
01:30:34,960 --> 01:30:37,679
um and even the additive error that we

2288
01:30:37,679 --> 01:30:39,760
get is um

2289
01:30:39,760 --> 01:30:42,400
essentially kind of explained by natural

2290
01:30:42,400 --> 01:30:44,719
attacks on the hash function that is

2291
01:30:44,719 --> 01:30:47,600
used for commitment and for the theater

2292
01:30:47,600 --> 01:30:50,239
mere transform

2293
01:30:51,360 --> 01:30:53,360
so um

2294
01:30:53,360 --> 01:30:54,800
in in the last couple of minutes let me

2295
01:30:54,800 --> 01:30:57,440
give a brief idea of um how we prove

2296
01:30:57,440 --> 01:31:00,320
this result so that we use this um

2297
01:31:00,320 --> 01:31:02,800
frame framework for query lower bounds

2298
01:31:02,800 --> 01:31:05,360
so first of all how do we prove query

2299
01:31:05,360 --> 01:31:07,360
lower bounds for compass oracles

2300
01:31:07,360 --> 01:31:10,159
this basically based on the idea by

2301
01:31:10,159 --> 01:31:12,639
january that if there's no pair

2302
01:31:12,639 --> 01:31:14,880
no input output pair in the database

2303
01:31:14,880 --> 01:31:17,360
that fulfills a certain relation then an

2304
01:31:17,360 --> 01:31:19,120
adversary can also not output such a

2305
01:31:19,120 --> 01:31:20,159
pair

2306
01:31:20,159 --> 01:31:22,800
this generalizes nicely and could be

2307
01:31:22,800 --> 01:31:24,560
used to

2308
01:31:24,560 --> 01:31:26,960
prove bounds for multi-collision

2309
01:31:26,960 --> 01:31:29,280
space-time trades are trade-offs and et

2310
01:31:29,280 --> 01:31:30,880
cetera so this was a very productive

2311
01:31:30,880 --> 01:31:32,080
technique

2312
01:31:32,080 --> 01:31:33,280
um

2313
01:31:33,280 --> 01:31:34,560
and

2314
01:31:34,560 --> 01:31:37,280
this framework by zhongfier huang and

2315
01:31:37,280 --> 01:31:41,520
liao is basically a way of um

2316
01:31:41,520 --> 01:31:43,840
proving such lower bounds by using what

2317
01:31:43,840 --> 01:31:47,120
they call trend transition capacities

2318
01:31:47,120 --> 01:31:49,120
so transition capacity in the classical

2319
01:31:49,120 --> 01:31:52,000
setting is just the maximum probability

2320
01:31:52,000 --> 01:31:54,400
that a fresh lazy sampled random oracle

2321
01:31:54,400 --> 01:31:56,840
pair a input output pair

2322
01:31:56,840 --> 01:32:00,480
um it basically turns a transparent from

2323
01:32:00,480 --> 01:32:02,639
not fulfilling a certain relation

2324
01:32:02,639 --> 01:32:05,199
into fulfilling a certain relation

2325
01:32:05,199 --> 01:32:07,360
and analogously in the quantum setting

2326
01:32:07,360 --> 01:32:10,320
this is the maximum amplitude with which

2327
01:32:10,320 --> 01:32:12,480
the compressed oracle unitary

2328
01:32:12,480 --> 01:32:13,440
and

2329
01:32:13,440 --> 01:32:15,199
transforms a database that does not

2330
01:32:15,199 --> 01:32:16,960
fulfill a certain relation

2331
01:32:16,960 --> 01:32:17,840
into

2332
01:32:17,840 --> 01:32:21,120
a database that fulfills that relation

2333
01:32:21,120 --> 01:32:22,880
and that basically

2334
01:32:22,880 --> 01:32:24,320
can be used to

2335
01:32:24,320 --> 01:32:27,120
improve lower about so very informally

2336
01:32:27,120 --> 01:32:29,600
in that work it was proven that there is

2337
01:32:29,600 --> 01:32:32,480
kind of a closed formula how to uh

2338
01:32:32,480 --> 01:32:33,440
obtain

2339
01:32:33,440 --> 01:32:35,440
a query lower bound from a quantum

2340
01:32:35,440 --> 01:32:37,840
transition capacity

2341
01:32:37,840 --> 01:32:39,520
and what we do is we kind of remove a

2342
01:32:39,520 --> 01:32:41,679
technical restriction from this result

2343
01:32:41,679 --> 01:32:44,560
and then apply it to um to this kind of

2344
01:32:44,560 --> 01:32:47,760
artificial search research task that we

2345
01:32:47,760 --> 01:32:50,159
need to show is hard to prove online

2346
01:32:50,159 --> 01:32:51,679
extractability

2347
01:32:51,679 --> 01:32:54,320
tightly

2348
01:32:54,320 --> 01:32:55,520
okay

2349
01:32:55,520 --> 01:32:58,239
so um maybe a couple of words about our

2350
01:32:58,239 --> 01:32:59,760
additional result on the unruly

2351
01:32:59,760 --> 01:33:02,320
transform so the unruly transform is a

2352
01:33:02,320 --> 01:33:03,520
different

2353
01:33:03,520 --> 01:33:06,239
generic transformation to

2354
01:33:06,239 --> 01:33:09,360
construct a nizik from a sigma protocol

2355
01:33:09,360 --> 01:33:11,040
so here we take an arbitrary sigma

2356
01:33:11,040 --> 01:33:12,880
protocol but then

2357
01:33:12,880 --> 01:33:14,239
we first

2358
01:33:14,239 --> 01:33:16,639
construct a new sigma protocol where the

2359
01:33:16,639 --> 01:33:19,120
first message is

2360
01:33:19,120 --> 01:33:21,679
includes now commitments to all possible

2361
01:33:21,679 --> 01:33:24,080
openings so to all possible possible

2362
01:33:24,080 --> 01:33:25,679
responses

2363
01:33:25,679 --> 01:33:28,560
and uh the response is then um given

2364
01:33:28,560 --> 01:33:29,840
together with the openings of these

2365
01:33:29,840 --> 01:33:31,280
commitments

2366
01:33:31,280 --> 01:33:33,600
now um the unruled sense form is then

2367
01:33:33,600 --> 01:33:35,440
the future mere transform of this modify

2368
01:33:35,440 --> 01:33:38,000
sigma protocol and it turns out that

2369
01:33:38,000 --> 01:33:40,000
this looks very much like a commit an

2370
01:33:40,000 --> 01:33:41,920
open protocol and in the end it is so

2371
01:33:41,920 --> 01:33:44,800
this additional um first message a from

2372
01:33:44,800 --> 01:33:47,760
the original sigma protocol doesn't um

2373
01:33:47,760 --> 01:33:49,679
change our results so we can basically

2374
01:33:49,679 --> 01:33:52,800
use our technique to remove the

2375
01:33:52,800 --> 01:33:54,480
requirement of a length preserving

2376
01:33:54,480 --> 01:33:55,679
commitment

2377
01:33:55,679 --> 01:33:57,360
um and

2378
01:33:57,360 --> 01:33:58,960
we also can also allow merkle tree

2379
01:33:58,960 --> 01:34:02,560
commitments in the unreal transform

2380
01:34:03,040 --> 01:34:06,719
this brings me to to the end of my talk

2381
01:34:06,719 --> 01:34:08,880
so we give the first tight curum

2382
01:34:08,880 --> 01:34:11,600
reduction for the fiat amir transform of

2383
01:34:11,600 --> 01:34:13,520
commit and open protocols

2384
01:34:13,520 --> 01:34:16,159
and this reduction also works if merkle

2385
01:34:16,159 --> 01:34:18,800
tree based commitments are used

2386
01:34:18,800 --> 01:34:19,840
and this

2387
01:34:19,840 --> 01:34:22,000
these results can be now used to

2388
01:34:22,000 --> 01:34:24,400
obtain a tight furum reduction for the

2389
01:34:24,400 --> 01:34:26,719
picnic digital signature scheme

2390
01:34:26,719 --> 01:34:29,120
and as an additional result we also get

2391
01:34:29,120 --> 01:34:33,639
a more efficient onward transform

2392
01:34:35,120 --> 01:34:38,239
thanks a lot for for your attention and

2393
01:34:38,239 --> 01:34:40,159
i'm happy to answer questions

2394
01:34:40,159 --> 01:34:42,719
thank you

2395
01:34:45,679 --> 01:34:48,639
any questions

2396
01:34:51,679 --> 01:34:52,960
okay

2397
01:34:52,960 --> 01:34:55,199
i also don't have a question but thank

2398
01:34:55,199 --> 01:34:57,119
you very much let's thank the speaker

2399
01:34:57,119 --> 01:35:00,119
again

2400
01:35:01,119 --> 01:35:02,880
and you don't have to leave because the

2401
01:35:02,880 --> 01:35:05,520
ice the icer membership meeting is going

2402
01:35:05,520 --> 01:35:09,119
to be here in a couple of minutes

2403
01:35:09,119 --> 01:35:11,360
we will hold this zoom room open for the

2404
01:35:11,360 --> 01:35:14,759
membership meeting

2405
01:36:16,159 --> 01:36:19,159
okay

2406
01:37:06,880 --> 01:37:09,880
right

2407
01:38:04,000 --> 01:38:07,000
oh

2408
01:38:26,800 --> 01:38:30,920
so kevin can hear me

2409
01:38:31,280 --> 01:38:34,280
yes

2410
01:39:26,159 --> 01:39:29,159
okay

2411
01:40:11,600 --> 01:40:14,239
can you hear me yeah

2412
01:40:14,239 --> 01:40:17,760
so kevin did you see my message

2413
01:40:17,760 --> 01:40:21,000
in the chat

2414
01:40:26,800 --> 01:40:28,880
you

