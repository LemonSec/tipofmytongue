1
00:00:03,760 --> 00:00:07,440
all right uh welcome back to the

2
00:00:07,440 --> 00:00:10,400
symmetry crypto theory session so we're

3
00:00:10,400 --> 00:00:13,440
going to have uh four talks so the first

4
00:00:13,440 --> 00:00:16,480
one is on the tide pre-image resistance

5
00:00:16,480 --> 00:00:18,400
of the sponge construction this is

6
00:00:18,400 --> 00:00:20,560
worked by charlotte le faire and bart

7
00:00:20,560 --> 00:00:22,400
manning and charlotte will be giving the

8
00:00:22,400 --> 00:00:23,439
talk

9
00:00:23,439 --> 00:00:26,240
okay thank you for the introduction so i

10
00:00:26,240 --> 00:00:28,080
will present a result regarding the type

11
00:00:28,080 --> 00:00:29,359
of image resistance of the sponge

12
00:00:29,359 --> 00:00:31,119
construction and this is a work done

13
00:00:31,119 --> 00:00:33,120
gently with vagnelic

14
00:00:33,120 --> 00:00:34,719
so here we focus on the generalized

15
00:00:34,719 --> 00:00:36,320
version of the sponge construction used

16
00:00:36,320 --> 00:00:38,559
for hashing purposes and it is here

17
00:00:38,559 --> 00:00:40,879
based on the permutation so the spawn

18
00:00:40,879 --> 00:00:42,960
operates on the state of size divots and

19
00:00:42,960 --> 00:00:44,800
it split into two parts

20
00:00:44,800 --> 00:00:46,480
the first one is called the auto parts

21
00:00:46,480 --> 00:00:48,640
it is made out of orbits and r is called

22
00:00:48,640 --> 00:00:49,600
the rays

23
00:00:49,600 --> 00:00:51,120
then we have the inner part which

24
00:00:51,120 --> 00:00:53,039
comprises c bits t is called the

25
00:00:53,039 --> 00:00:54,640
capacity and this is the security

26
00:00:54,640 --> 00:00:56,559
parameter of the scope

27
00:00:56,559 --> 00:00:58,399
now to pump the hash of the message we

28
00:00:58,399 --> 00:01:00,079
first split the padded message into

29
00:01:00,079 --> 00:01:02,480
several blocks each block comprises all

30
00:01:02,480 --> 00:01:03,280
this

31
00:01:03,280 --> 00:01:05,199
then we go through the absorption page

32
00:01:05,199 --> 00:01:07,119
where message blocks are added to the

33
00:01:07,119 --> 00:01:09,200
outer part of the state and after each

34
00:01:09,200 --> 00:01:11,119
addition we apply the permutation on the

35
00:01:11,119 --> 00:01:12,560
entire state

36
00:01:12,560 --> 00:01:14,479
once once all of the message blocks are

37
00:01:14,479 --> 00:01:16,159
absorbed we can move on to the squid

38
00:01:16,159 --> 00:01:18,400
intakes where orbits of the digest are

39
00:01:18,400 --> 00:01:19,920
extracted at a time

40
00:01:19,920 --> 00:01:21,840
and between each extraction we apply

41
00:01:21,840 --> 00:01:23,840
again the permutation

42
00:01:23,840 --> 00:01:25,600
so by design the sponge offers a

43
00:01:25,600 --> 00:01:27,520
variable length digest but here we will

44
00:01:27,520 --> 00:01:29,520
rustic or restrict ourselves to the case

45
00:01:29,520 --> 00:01:31,119
where the digest site is fixed to

46
00:01:31,119 --> 00:01:33,600
endlets and we denote by l the number of

47
00:01:33,600 --> 00:01:36,320
required squish schools

48
00:01:36,320 --> 00:01:38,000
so there exists several tweaks to this

49
00:01:38,000 --> 00:01:40,000
construction and here we focus on two of

50
00:01:40,000 --> 00:01:41,680
them which were both introduced in the

51
00:01:41,680 --> 00:01:43,520
context of the photo scheme

52
00:01:43,520 --> 00:01:45,040
the first one allows to have a first

53
00:01:45,040 --> 00:01:46,640
message block which is larger with the

54
00:01:46,640 --> 00:01:49,040
size denoted by rpm prime and in the

55
00:01:49,040 --> 00:01:51,119
second tweak the digest is extracted

56
00:01:51,119 --> 00:01:54,079
using a larger rate denoted by r5

57
00:01:54,079 --> 00:01:55,759
therefore especially when the rate is

58
00:01:55,759 --> 00:01:57,600
quite small which is usually the case in

59
00:01:57,600 --> 00:01:59,840
that lightweight crypto these tweaks

60
00:01:59,840 --> 00:02:01,759
allow to reduce the number of required

61
00:02:01,759 --> 00:02:03,920
permutation posts to compute the digest

62
00:02:03,920 --> 00:02:06,560
making the skin more efficient

63
00:02:06,560 --> 00:02:08,959
so now we are interested in the probable

64
00:02:08,959 --> 00:02:11,760
secretive warranties of the sponge

65
00:02:11,760 --> 00:02:13,360
and in order to argue that we have a

66
00:02:13,360 --> 00:02:14,720
good hash function there are three

67
00:02:14,720 --> 00:02:17,120
classical security properties the first

68
00:02:17,120 --> 00:02:19,120
one is called for image resistance where

69
00:02:19,120 --> 00:02:21,440
we are given an n bit string h and it

70
00:02:21,440 --> 00:02:22,800
should be hard to invert the hash

71
00:02:22,800 --> 00:02:24,720
function on this input

72
00:02:24,720 --> 00:02:25,840
then we have segment for image

73
00:02:25,840 --> 00:02:28,160
resistance where additionally to h we

74
00:02:28,160 --> 00:02:30,080
are providing a message that was used to

75
00:02:30,080 --> 00:02:32,160
complete this digest and it should be

76
00:02:32,160 --> 00:02:33,920
hard to find a different message that

77
00:02:33,920 --> 00:02:36,160
hashes to the same value and finally

78
00:02:36,160 --> 00:02:37,920
there is collision resistance where it

79
00:02:37,920 --> 00:02:39,360
should be hard to find two different

80
00:02:39,360 --> 00:02:41,519
messages that hash to the same value

81
00:02:41,519 --> 00:02:43,440
so historically these properties are

82
00:02:43,440 --> 00:02:45,040
considered as very important but they

83
00:02:45,040 --> 00:02:46,239
are not strong enough for some

84
00:02:46,239 --> 00:02:48,480
applications so consider the following

85
00:02:48,480 --> 00:02:50,319
mac construction where the tag is

86
00:02:50,319 --> 00:02:52,239
generated by computing the hash of the

87
00:02:52,239 --> 00:02:54,560
key concatenated with the message so in

88
00:02:54,560 --> 00:02:55,920
the render miracle model this

89
00:02:55,920 --> 00:02:57,680
construction is secure

90
00:02:57,680 --> 00:02:59,440
but on the other side consider the plain

91
00:02:59,440 --> 00:03:01,120
vehicle damn guard construction based on

92
00:03:01,120 --> 00:03:03,280
an ideal compression function then this

93
00:03:03,280 --> 00:03:05,040
hash function is spray image segment

94
00:03:05,040 --> 00:03:07,040
image and collision resistance but on

95
00:03:07,040 --> 00:03:08,800
the other side it is exposed to length

96
00:03:08,800 --> 00:03:10,239
extension attack

97
00:03:10,239 --> 00:03:12,080
making this uh

98
00:03:12,080 --> 00:03:14,080
this instantiation completely unsecured

99
00:03:14,080 --> 00:03:15,760
in this mac construction

100
00:03:15,760 --> 00:03:17,680
so this uh classical security

101
00:03:17,680 --> 00:03:19,760
requirements do not capture all of the

102
00:03:19,760 --> 00:03:21,200
applications of the hash function that

103
00:03:21,200 --> 00:03:22,959
we would like to have

104
00:03:22,959 --> 00:03:25,280
in fact the best thing we could ever

105
00:03:25,280 --> 00:03:26,720
have for a hash function is a render

106
00:03:26,720 --> 00:03:28,720
morocco but a render miracle is

107
00:03:28,720 --> 00:03:30,400
described by an infinite amount of

108
00:03:30,400 --> 00:03:32,159
entropy while a hash function is

109
00:03:32,159 --> 00:03:34,080
described by a finite string of bits so

110
00:03:34,080 --> 00:03:36,400
it's impossible to have one in practice

111
00:03:36,400 --> 00:03:37,840
but there exists a secretive notion

112
00:03:37,840 --> 00:03:39,680
which captures this idea of behaving

113
00:03:39,680 --> 00:03:41,519
like a random morocco and this is

114
00:03:41,519 --> 00:03:43,040
indifferentiability

115
00:03:43,040 --> 00:03:44,480
so indifferentiability is a

116
00:03:44,480 --> 00:03:46,560
distinguishing game where the adversary

117
00:03:46,560 --> 00:03:48,799
is either in the real world or in the

118
00:03:48,799 --> 00:03:51,120
simulated world in the real world it has

119
00:03:51,120 --> 00:03:52,879
access to a primitive fee

120
00:03:52,879 --> 00:03:54,959
that we assume to be ideal so simple

121
00:03:54,959 --> 00:03:57,360
uniformly adrenal but it has also access

122
00:03:57,360 --> 00:03:58,959
to the hash construction music in this

123
00:03:58,959 --> 00:04:01,360
primitive in the simulated world the

124
00:04:01,360 --> 00:04:02,879
hash construction is replaced by a

125
00:04:02,879 --> 00:04:04,480
random morocco and the primitive

126
00:04:04,480 --> 00:04:07,040
biosimulator the goal of the simulator

127
00:04:07,040 --> 00:04:09,040
is to mimic the primitive behavior

128
00:04:09,040 --> 00:04:11,280
according to the random oracle response

129
00:04:11,280 --> 00:04:12,640
in other words it must maintain

130
00:04:12,640 --> 00:04:15,040
construction primitive consistency

131
00:04:15,040 --> 00:04:16,399
and the goal is to show that the

132
00:04:16,399 --> 00:04:18,160
adversary can distinguish between

133
00:04:18,160 --> 00:04:19,839
between these two words only with a

134
00:04:19,839 --> 00:04:22,160
negligible probability or with a number

135
00:04:22,160 --> 00:04:23,759
of queries which is unreachable in

136
00:04:23,759 --> 00:04:25,440
practice

137
00:04:25,440 --> 00:04:27,520
so indifferentiability is much stronger

138
00:04:27,520 --> 00:04:29,360
than the previous security properties it

139
00:04:29,360 --> 00:04:31,280
has been shown that indifferentiability

140
00:04:31,280 --> 00:04:33,680
implies security warranties regarding

141
00:04:33,680 --> 00:04:35,120
any generic attack on the harsh

142
00:04:35,120 --> 00:04:37,360
construction so in particular it implies

143
00:04:37,360 --> 00:04:39,199
pre-image second primage and collision

144
00:04:39,199 --> 00:04:41,520
security

145
00:04:41,520 --> 00:04:42,720
now going back to the sponge

146
00:04:42,720 --> 00:04:44,479
construction it has been proven to be

147
00:04:44,479 --> 00:04:46,639
indifferentiable with a bond or form q

148
00:04:46,639 --> 00:04:48,800
over two to the c over two or q denotes

149
00:04:48,800 --> 00:04:50,720
the number of queries in fact for the

150
00:04:50,720 --> 00:04:52,160
plane's point construction the bond is

151
00:04:52,160 --> 00:04:53,600
slightly better because this is the

152
00:04:53,600 --> 00:04:54,960
square of it

153
00:04:54,960 --> 00:04:57,040
but in both cases it tells us that in

154
00:04:57,040 --> 00:04:58,479
order to be able to differentiate the

155
00:04:58,479 --> 00:05:00,080
sponge from a random oracle with a

156
00:05:00,080 --> 00:05:02,560
non-negligible probability one needs at

157
00:05:02,560 --> 00:05:04,639
least two today over two queries

158
00:05:04,639 --> 00:05:06,560
and below this number of queries any

159
00:05:06,560 --> 00:05:08,320
attack on the sponge cannot be easier

160
00:05:08,320 --> 00:05:09,680
than the same attack on the render

161
00:05:09,680 --> 00:05:11,039
morocco

162
00:05:11,039 --> 00:05:12,720
so this is what we can see on this table

163
00:05:12,720 --> 00:05:14,560
for the classical security properties

164
00:05:14,560 --> 00:05:16,240
the security bomb is the sum of two

165
00:05:16,240 --> 00:05:17,199
terms

166
00:05:17,199 --> 00:05:18,240
the first one comes from

167
00:05:18,240 --> 00:05:20,240
indifferentiability while the second one

168
00:05:20,240 --> 00:05:22,320
is the success probability of a generic

169
00:05:22,320 --> 00:05:24,479
attack on the render morocco

170
00:05:24,479 --> 00:05:26,160
so now we want to compare the security

171
00:05:26,160 --> 00:05:28,160
bomb against the best mode attack and

172
00:05:28,160 --> 00:05:30,639
see if the two points is match

173
00:05:30,639 --> 00:05:33,120
so for the classical security properties

174
00:05:33,120 --> 00:05:34,720
the best attack cost is the minimum

175
00:05:34,720 --> 00:05:36,479
between two terms and it corresponds to

176
00:05:36,479 --> 00:05:38,639
two different strategies the first one

177
00:05:38,639 --> 00:05:40,400
is an attack that exploits the inner

178
00:05:40,400 --> 00:05:42,080
working of the sponge like the second

179
00:05:42,080 --> 00:05:44,800
one is just a generic attach

180
00:05:44,800 --> 00:05:47,120
so now for indifferentiability collision

181
00:05:47,120 --> 00:05:48,800
and second pre-image this is clear that

182
00:05:48,800 --> 00:05:50,560
the security bond matches the best-known

183
00:05:50,560 --> 00:05:51,680
attack

184
00:05:51,680 --> 00:05:53,600
however for pre-match on one side the

185
00:05:53,600 --> 00:05:55,680
security bone is exactly the same as the

186
00:05:55,680 --> 00:05:57,840
one of second pre-image but on the other

187
00:05:57,840 --> 00:05:59,759
side in the best attacks there is an

188
00:05:59,759 --> 00:06:02,240
extra term in the non-generic part

189
00:06:02,240 --> 00:06:04,160
therefore when this term is larger than

190
00:06:04,160 --> 00:06:06,560
2dc over to there is therefore a gap

191
00:06:06,560 --> 00:06:08,240
between the security bomb and the best

192
00:06:08,240 --> 00:06:09,759
known attack

193
00:06:09,759 --> 00:06:11,280
and the goal of this work is to fill in

194
00:06:11,280 --> 00:06:13,120
this gap by proving a better security

195
00:06:13,120 --> 00:06:14,880
bond for pre-image resistance and it

196
00:06:14,880 --> 00:06:16,800
shows in particular the optimality of

197
00:06:16,800 --> 00:06:18,479
the best-known attack

198
00:06:18,479 --> 00:06:20,639
for now i will show the best new attack

199
00:06:20,639 --> 00:06:22,080
on the three classical security

200
00:06:22,080 --> 00:06:24,160
properties and not that for

201
00:06:24,160 --> 00:06:25,919
indifferentiability the best known

202
00:06:25,919 --> 00:06:27,680
attack is essentially the same one as

203
00:06:27,680 --> 00:06:30,319
the collision attack

204
00:06:30,319 --> 00:06:32,800
so for collision attack the idea is to

205
00:06:32,800 --> 00:06:35,039
exploit collisions in the inner parts

206
00:06:35,039 --> 00:06:36,720
within the sponge states

207
00:06:36,720 --> 00:06:38,800
so to do that we consider two to the c

208
00:06:38,800 --> 00:06:40,960
over two different message and one here

209
00:06:40,960 --> 00:06:42,479
for each of them we add them to the

210
00:06:42,479 --> 00:06:44,639
outer part of the iv we apply the

211
00:06:44,639 --> 00:06:46,240
permutation and it gives us two

212
00:06:46,240 --> 00:06:47,680
tendocity over two states and we are

213
00:06:47,680 --> 00:06:50,000
going to store them in a list

214
00:06:50,000 --> 00:06:52,080
now with high probability there exists

215
00:06:52,080 --> 00:06:53,919
two different elements in this list that

216
00:06:53,919 --> 00:06:56,080
shows that display a collision on the

217
00:06:56,080 --> 00:06:57,840
inner part

218
00:06:57,840 --> 00:06:59,440
now we can transform this partial

219
00:06:59,440 --> 00:07:01,759
collision into a full state collision by

220
00:07:01,759 --> 00:07:03,360
compensating the difference in the outer

221
00:07:03,360 --> 00:07:06,160
part using the thumb absorb curve

222
00:07:06,160 --> 00:07:08,160
so now we have two different sequence of

223
00:07:08,160 --> 00:07:09,759
message blocks that

224
00:07:09,759 --> 00:07:12,319
go to the same state so in particular it

225
00:07:12,319 --> 00:07:14,720
gives the collision in the hash digest

226
00:07:14,720 --> 00:07:16,560
and this attack is expected to cost

227
00:07:16,560 --> 00:07:19,840
around two to the c over two queries

228
00:07:19,840 --> 00:07:22,000
now for the second primage attack

229
00:07:22,000 --> 00:07:24,479
the idea is also to exploit collision in

230
00:07:24,479 --> 00:07:26,479
a collision in the sponge states

231
00:07:26,479 --> 00:07:28,319
so we are providing here a first pro

232
00:07:28,319 --> 00:07:30,400
image so in particular we are able to

233
00:07:30,400 --> 00:07:32,400
compute intermediate states within the

234
00:07:32,400 --> 00:07:34,800
spawns when computing the digest

235
00:07:34,800 --> 00:07:36,639
there is one state which is particularly

236
00:07:36,639 --> 00:07:38,400
interesting for us this is the states

237
00:07:38,400 --> 00:07:40,319
right before the speeding takes let's

238
00:07:40,319 --> 00:07:43,520
call it y in particular if we can reach

239
00:07:43,520 --> 00:07:45,520
this state from the iv using a different

240
00:07:45,520 --> 00:07:47,520
sequence of message block then in

241
00:07:47,520 --> 00:07:50,319
particular we form a second pre-image

242
00:07:50,319 --> 00:07:52,160
and to do that we are again considered

243
00:07:52,160 --> 00:07:53,039
to

244
00:07:53,039 --> 00:07:55,360
use collisions in the inner part in the

245
00:07:55,360 --> 00:07:57,360
inner part of the sponge so this time we

246
00:07:57,360 --> 00:07:58,800
start from the iv

247
00:07:58,800 --> 00:08:00,160
consider two to to see over two

248
00:08:00,160 --> 00:08:01,680
different message uh apply the

249
00:08:01,680 --> 00:08:03,440
permutation and store the states in a

250
00:08:03,440 --> 00:08:04,240
list

251
00:08:04,240 --> 00:08:07,440
then start from y compute inverse

252
00:08:07,440 --> 00:08:09,360
absolute code and check for collisions

253
00:08:09,360 --> 00:08:11,360
again against the list

254
00:08:11,360 --> 00:08:13,440
and compensated use the second absolute

255
00:08:13,440 --> 00:08:16,080
call to obtain a full state collision

256
00:08:16,080 --> 00:08:18,080
and this attack is also expected to cost

257
00:08:18,080 --> 00:08:21,680
around two to the other temporaries

258
00:08:21,919 --> 00:08:23,680
now for our first primage attack the

259
00:08:23,680 --> 00:08:25,680
situation is a bit more complicated

260
00:08:25,680 --> 00:08:27,599
because here we are not provided any

261
00:08:27,599 --> 00:08:29,360
intermediate states

262
00:08:29,360 --> 00:08:31,360
and the idea with of this attack is to

263
00:08:31,360 --> 00:08:33,440
first start is to first find a good

264
00:08:33,440 --> 00:08:34,958
state and then apply the second

265
00:08:34,958 --> 00:08:36,479
premature attack

266
00:08:36,479 --> 00:08:38,159
by good states i mean that we need to

267
00:08:38,159 --> 00:08:40,240
find the state y here such that the l

268
00:08:40,240 --> 00:08:42,399
consecutive permutation evaluation gives

269
00:08:42,399 --> 00:08:44,640
the state such that uh each of them have

270
00:08:44,640 --> 00:08:47,279
the desired order part so the one to the

271
00:08:47,279 --> 00:08:48,640
l

272
00:08:48,640 --> 00:08:50,720
to do that the best strategy is to start

273
00:08:50,720 --> 00:08:52,880
from a state during the first squeezing

274
00:08:52,880 --> 00:08:56,000
takes y1 with auto part d1 and then

275
00:08:56,000 --> 00:08:57,680
cross our fingers so that the l minus

276
00:08:57,680 --> 00:08:59,519
one consecutive permutation evaluation

277
00:08:59,519 --> 00:09:02,720
gives us states with desired order parts

278
00:09:02,720 --> 00:09:04,720
so we require on average two to the n

279
00:09:04,720 --> 00:09:07,040
minus operand queries uh before finding

280
00:09:07,040 --> 00:09:09,680
such a states and once again uh once

281
00:09:09,680 --> 00:09:11,600
this state is formed we just apply uh

282
00:09:11,600 --> 00:09:13,040
the uh

283
00:09:13,040 --> 00:09:14,720
secondary image attached so that the

284
00:09:14,720 --> 00:09:16,880
total uh the total attack cost is the

285
00:09:16,880 --> 00:09:19,519
sum of the two terms

286
00:09:19,519 --> 00:09:21,360
now adding the generic term on top of

287
00:09:21,360 --> 00:09:23,519
that we obtain a best-known prosper

288
00:09:23,519 --> 00:09:25,839
image attack with which succeeds around

289
00:09:25,839 --> 00:09:28,240
after around this number of queries

290
00:09:28,240 --> 00:09:29,680
on the other side remember that the

291
00:09:29,680 --> 00:09:31,519
indifferentiability bomb guaranteed

292
00:09:31,519 --> 00:09:33,360
prematurity up to this number of

293
00:09:33,360 --> 00:09:34,320
quarries

294
00:09:34,320 --> 00:09:36,000
so in particular the cost of the extra

295
00:09:36,000 --> 00:09:37,760
step that i described the slide ago does

296
00:09:37,760 --> 00:09:39,600
not appear in the indifferentiability

297
00:09:39,600 --> 00:09:41,760
bonds therefore when the cost of this

298
00:09:41,760 --> 00:09:43,440
step is larger than the cost of finding

299
00:09:43,440 --> 00:09:45,279
in a collision there is therefore a gap

300
00:09:45,279 --> 00:09:46,880
between the security bomb and the best

301
00:09:46,880 --> 00:09:48,080
move attack

302
00:09:48,080 --> 00:09:50,240
this happens for schemes that have quite

303
00:09:50,240 --> 00:09:52,000
small primitives with small weights

304
00:09:52,000 --> 00:09:53,519
which is uh usually the case of

305
00:09:53,519 --> 00:09:55,760
lightweight crypto schemes

306
00:09:55,760 --> 00:09:57,600
another contribution here was to prove

307
00:09:57,600 --> 00:09:59,279
for image resistance with a better bomb

308
00:09:59,279 --> 00:10:01,839
so the following bomb and it shows it is

309
00:10:01,839 --> 00:10:03,920
a tight bond and it shows in particular

310
00:10:03,920 --> 00:10:06,000
the optimality of this attack

311
00:10:06,000 --> 00:10:07,680
in fact this bond was already believed

312
00:10:07,680 --> 00:10:10,000
to be true the designer of the sponge

313
00:10:10,000 --> 00:10:12,720
sponge and photon made security claims

314
00:10:12,720 --> 00:10:14,720
based on this bomb but there was before

315
00:10:14,720 --> 00:10:16,839
him no proof for

316
00:10:16,839 --> 00:10:20,160
that so more concretely uh so here we

317
00:10:20,160 --> 00:10:21,920
polluted the adversarial advantage

318
00:10:21,920 --> 00:10:23,600
according to the logarithmic number of

319
00:10:23,600 --> 00:10:25,760
queries for two different parameter sets

320
00:10:25,760 --> 00:10:26,959
that corresponds to two different

321
00:10:26,959 --> 00:10:29,040
schemes so asco and squadron's largest

322
00:10:29,040 --> 00:10:30,399
mode

323
00:10:30,399 --> 00:10:32,000
so for ascon school the state-of-the-art

324
00:10:32,000 --> 00:10:34,279
bond guaranteed premium security up to

325
00:10:34,279 --> 00:10:36,399
128 bits

326
00:10:36,399 --> 00:10:38,519
and the newborn levels security up to

327
00:10:38,519 --> 00:10:40,320
192 bits

328
00:10:40,320 --> 00:10:42,160
and in particular the graph almost

329
00:10:42,160 --> 00:10:44,320
overlap overlaps with the graph of the

330
00:10:44,320 --> 00:10:45,839
the state of your attack and the

331
00:10:45,839 --> 00:10:47,279
difference is only due to constant

332
00:10:47,279 --> 00:10:48,880
factors

333
00:10:48,880 --> 00:10:50,880
now for sponsors uh the state-of-the-art

334
00:10:50,880 --> 00:10:54,640
bond is almost is the same one as uh 120

335
00:10:54,640 --> 00:10:57,120
bits and in this case our bond improves

336
00:10:57,120 --> 00:10:58,720
even more because it gives pregnant

337
00:10:58,720 --> 00:11:01,519
security up to 240 bits

338
00:11:01,519 --> 00:11:03,600
in fact ascorb and spongebob both have

339
00:11:03,600 --> 00:11:05,279
the same capacity and the same digest

340
00:11:05,279 --> 00:11:07,519
size the difference is in the size of

341
00:11:07,519 --> 00:11:09,839
the primitive so this one of sponges is

342
00:11:09,839 --> 00:11:11,760
a bit smaller than the one of asco and

343
00:11:11,760 --> 00:11:13,680
therefore the rate is smaller and that's

344
00:11:13,680 --> 00:11:16,959
the place where a bond improves the most

345
00:11:16,959 --> 00:11:19,680
so this is the place where

346
00:11:19,680 --> 00:11:21,440
the exact place where the bond starts to

347
00:11:21,440 --> 00:11:23,200
improve the state of yards and in both

348
00:11:23,200 --> 00:11:25,040
cases it happens at small adversarial

349
00:11:25,040 --> 00:11:27,920
advantage 10 to the minus 36 for a small

350
00:11:27,920 --> 00:11:31,680
and 10 to the minus 64 correspondence

351
00:11:31,680 --> 00:11:33,680
now for the proof id the proof id

352
00:11:33,680 --> 00:11:35,600
closely follows the id behind the first

353
00:11:35,600 --> 00:11:38,079
premise attack so remember that here we

354
00:11:38,079 --> 00:11:39,839
are in the ideal primitive model so we

355
00:11:39,839 --> 00:11:42,320
assume that the permutation is random

356
00:11:42,320 --> 00:11:44,000
suppose that the adversary has formed a

357
00:11:44,000 --> 00:11:46,000
pre-image then in particular it must

358
00:11:46,000 --> 00:11:47,760
have formed the cascade of l minus one

359
00:11:47,760 --> 00:11:50,399
permutation evaluation giving the outer

360
00:11:50,399 --> 00:11:52,560
part z2 up to the l

361
00:11:52,560 --> 00:11:54,480
however having such a cascade is not

362
00:11:54,480 --> 00:11:56,079
enough because it must be reached from

363
00:11:56,079 --> 00:11:57,920
the initial state

364
00:11:57,920 --> 00:11:59,360
now have a look at the state right

365
00:11:59,360 --> 00:12:01,760
before the squeezing phase call it x1

366
00:12:01,760 --> 00:12:04,000
and let y1 be the image of x1 by the

367
00:12:04,000 --> 00:12:06,399
permutation so it gives us a query and

368
00:12:06,399 --> 00:12:08,160
depending on the direction of this query

369
00:12:08,160 --> 00:12:10,880
there are two different scenarios

370
00:12:10,880 --> 00:12:12,320
if the query was made in the forward

371
00:12:12,320 --> 00:12:14,160
direction then the cascade is extended

372
00:12:14,160 --> 00:12:16,399
by one so now we require a good

373
00:12:16,399 --> 00:12:18,800
permutation evaluations

374
00:12:18,800 --> 00:12:20,560
on the other side if the query was made

375
00:12:20,560 --> 00:12:22,560
in the inverse direction additionally to

376
00:12:22,560 --> 00:12:25,279
this cascade then we require that an

377
00:12:25,279 --> 00:12:26,880
inner collision must have been formed

378
00:12:26,880 --> 00:12:29,040
during the absorption phase

379
00:12:29,040 --> 00:12:30,880
so by doing this we reduce the

380
00:12:30,880 --> 00:12:32,480
probability computation of finding a

381
00:12:32,480 --> 00:12:34,560
primitive into the one of three smaller

382
00:12:34,560 --> 00:12:36,880
events so now it remains to a problem it

383
00:12:36,880 --> 00:12:39,920
will each of these terms

384
00:12:39,920 --> 00:12:42,000
so uh in the case where the query was

385
00:12:42,000 --> 00:12:43,760
made in the forward direction then this

386
00:12:43,760 --> 00:12:46,000
reduces to a guessing game in order to

387
00:12:46,000 --> 00:12:48,320
win the adversary must have

388
00:12:48,320 --> 00:12:50,880
formed a good x1 it is it is good in the

389
00:12:50,880 --> 00:12:52,959
sense that it gives access to a chain of

390
00:12:52,959 --> 00:12:55,279
l values such that each of these values

391
00:12:55,279 --> 00:12:57,440
have the desired outer part

392
00:12:57,440 --> 00:12:59,040
so in the proof we have to argue that

393
00:12:59,040 --> 00:13:00,959
the other permutation evaluations of the

394
00:13:00,959 --> 00:13:03,680
adversary do not bias it towards certain

395
00:13:03,680 --> 00:13:05,279
values of x1

396
00:13:05,279 --> 00:13:07,279
and after a few extra steps we obtain a

397
00:13:07,279 --> 00:13:10,480
bond of from q over 2 to the m

398
00:13:10,480 --> 00:13:12,320
on the other side if the query was made

399
00:13:12,320 --> 00:13:13,760
in the inverse direction then the

400
00:13:13,760 --> 00:13:15,760
cascade part is a bit more involved

401
00:13:15,760 --> 00:13:17,920
since in this case we do not specify how

402
00:13:17,920 --> 00:13:20,399
does the adversary reaches the cascade

403
00:13:20,399 --> 00:13:21,920
so for example you can just start from a

404
00:13:21,920 --> 00:13:24,480
state with the autopsy too then make a

405
00:13:24,480 --> 00:13:26,880
forward queries to reach here and then

406
00:13:26,880 --> 00:13:29,519
finish with inverse queries to reach y1

407
00:13:29,519 --> 00:13:32,000
and then x1 so in particular the winning

408
00:13:32,000 --> 00:13:33,600
queries can appear anywhere in the

409
00:13:33,600 --> 00:13:36,079
cascade and in any direction

410
00:13:36,079 --> 00:13:38,079
so here since the cascade

411
00:13:38,079 --> 00:13:40,480
size is reduced by one we obtain a bond

412
00:13:40,480 --> 00:13:43,600
of form q over 2 to the n minus r prime

413
00:13:43,600 --> 00:13:45,519
then the inner collision part is a

414
00:13:45,519 --> 00:13:47,279
classical result so that we have the

415
00:13:47,279 --> 00:13:49,600
following uh upper bond here we have

416
00:13:49,600 --> 00:13:51,279
this extra term q over two to the c

417
00:13:51,279 --> 00:13:52,560
prime prime because remember that the

418
00:13:52,560 --> 00:13:55,440
first uh capacity is smaller than the

419
00:13:55,440 --> 00:13:57,360
absorbing capacity

420
00:13:57,360 --> 00:13:59,120
and by gluing all of this term together

421
00:13:59,120 --> 00:14:00,240
we obtain

422
00:14:00,240 --> 00:14:02,079
the frame all right uh thank you for the

423
00:14:02,079 --> 00:14:04,959
talk so do we have uh any questions

424
00:14:04,959 --> 00:14:07,360
feel free to come forward

425
00:14:07,360 --> 00:14:10,240
also on zoom

426
00:14:10,320 --> 00:14:12,079
so we have plenty of time so so

427
00:14:12,079 --> 00:14:15,360
otherwise one question so do you know of

428
00:14:15,360 --> 00:14:17,680
other properties that are other

429
00:14:17,680 --> 00:14:19,440
properties beyond pre-image resistance

430
00:14:19,440 --> 00:14:20,480
where the

431
00:14:20,480 --> 00:14:22,399
indifferentiability bound

432
00:14:22,399 --> 00:14:24,160
is not tight and when we will where we

433
00:14:24,160 --> 00:14:28,040
would like to have a better proof

434
00:14:31,760 --> 00:14:33,040
in the case of the sponge construction

435
00:14:33,040 --> 00:14:35,120
yeah so so

436
00:14:35,120 --> 00:14:36,639
i don't mean multi-collisions or

437
00:14:36,639 --> 00:14:38,160
something like that do we you know if

438
00:14:38,160 --> 00:14:40,079
there's a gap

439
00:14:40,079 --> 00:14:41,040
okay

440
00:14:41,040 --> 00:14:42,839
yeah revisiting there's a

441
00:14:42,839 --> 00:14:46,079
question uh hi thanks for the talk

442
00:14:46,079 --> 00:14:47,920
sorry if this is kind of a basic

443
00:14:47,920 --> 00:14:50,160
question but um i noticed that you're

444
00:14:50,160 --> 00:14:52,240
proving indifferentiability in some kind

445
00:14:52,240 --> 00:14:53,920
of like ideal

446
00:14:53,920 --> 00:14:56,480
permutation model so i just want to ask

447
00:14:56,480 --> 00:14:58,639
are like do you know are there any

448
00:14:58,639 --> 00:15:00,240
attacks on

449
00:15:00,240 --> 00:15:02,639
these uh constructions that might try to

450
00:15:02,639 --> 00:15:04,480
attack the permutation

451
00:15:04,480 --> 00:15:07,279
and like how are are those how are those

452
00:15:07,279 --> 00:15:08,639
attacks

453
00:15:08,639 --> 00:15:11,120
you mean attack that uh that exploits

454
00:15:11,120 --> 00:15:12,560
the properties of the underlying

455
00:15:12,560 --> 00:15:13,760
permutations

456
00:15:13,760 --> 00:15:15,100
uh yeah

457
00:15:15,100 --> 00:15:18,299
[Music]

458
00:15:20,560 --> 00:15:22,719
oh

459
00:15:25,760 --> 00:15:28,079
all thanks

460
00:15:28,079 --> 00:15:29,600
and and again we have another thing so

461
00:15:29,600 --> 00:15:31,120
for for sure three doesn't matter right

462
00:15:31,120 --> 00:15:33,680
so in that case the the

463
00:15:33,680 --> 00:15:37,279
the bound was already tight right

464
00:15:37,600 --> 00:15:40,320
one round so

465
00:15:41,920 --> 00:15:43,680
yeah okay all right

466
00:15:43,680 --> 00:15:48,359
all right so let's thank charlotte again

467
00:16:42,720 --> 00:16:44,000
all right so we're a bit ahead of

468
00:16:44,000 --> 00:16:45,519
schedule i think we will go ahead but

469
00:16:45,519 --> 00:16:47,680
then if you're too fast we will take a

470
00:16:47,680 --> 00:16:49,680
short break after you talk to match up

471
00:16:49,680 --> 00:16:51,120
with them okay

472
00:16:51,120 --> 00:16:53,279
all right so the next talk is uh block

473
00:16:53,279 --> 00:16:56,079
cipher based uh tree hashing by by alder

474
00:16:56,079 --> 00:16:58,880
kunsing and aldo is going to talk

475
00:16:58,880 --> 00:17:00,959
thank you for the introduction

476
00:17:00,959 --> 00:17:03,360
so like the previous talk my talk will

477
00:17:03,360 --> 00:17:05,439
also be about hash functions

478
00:17:05,439 --> 00:17:06,319
so

479
00:17:06,319 --> 00:17:08,559
we'll repeat a bit of the definitions

480
00:17:08,559 --> 00:17:11,919
but i will go over them briefly

481
00:17:11,919 --> 00:17:14,079
so a hash function is a function that

482
00:17:14,079 --> 00:17:14,959
maps

483
00:17:14,959 --> 00:17:17,280
an input of arbitrary lengths to a fixed

484
00:17:17,280 --> 00:17:18,480
length output

485
00:17:18,480 --> 00:17:20,319
and as we saw there are multiple

486
00:17:20,319 --> 00:17:22,720
possible security notions for them

487
00:17:22,720 --> 00:17:24,640
so one example was the notion of

488
00:17:24,640 --> 00:17:27,119
collision resistance which means that it

489
00:17:27,119 --> 00:17:28,640
should be difficult to find two

490
00:17:28,640 --> 00:17:31,679
different inputs that get mapped to the

491
00:17:31,679 --> 00:17:33,280
same output

492
00:17:33,280 --> 00:17:34,160
but

493
00:17:34,160 --> 00:17:36,480
for some cryptographic schemes this is

494
00:17:36,480 --> 00:17:38,640
not strong enough and there are also

495
00:17:38,640 --> 00:17:40,640
other notions required

496
00:17:40,640 --> 00:17:42,640
and the strongest one is that a hash

497
00:17:42,640 --> 00:17:44,400
function should behave like a random

498
00:17:44,400 --> 00:17:45,360
oracle

499
00:17:45,360 --> 00:17:48,400
so that every output should be uniformly

500
00:17:48,400 --> 00:17:49,440
randomly

501
00:17:49,440 --> 00:17:51,600
generated and also independent from each

502
00:17:51,600 --> 00:17:52,880
other

503
00:17:52,880 --> 00:17:55,360
also as we saw before this is formalized

504
00:17:55,360 --> 00:17:58,400
as indifferentiability by maura at all

505
00:17:58,400 --> 00:18:01,039
and also specif specified for hashing by

506
00:18:01,039 --> 00:18:03,919
cornet at all

507
00:18:03,919 --> 00:18:06,240
and the second kind of construction

508
00:18:06,240 --> 00:18:08,640
we'll look at our mac functions

509
00:18:08,640 --> 00:18:11,200
but we will mostly use them to show that

510
00:18:11,200 --> 00:18:12,960
some hash functions are not in

511
00:18:12,960 --> 00:18:14,799
differentiable

512
00:18:14,799 --> 00:18:18,799
so a mac function like a hash function

513
00:18:18,799 --> 00:18:20,960
takes an input of arbitrary length and

514
00:18:20,960 --> 00:18:24,160
maps it to the fixed length output but

515
00:18:24,160 --> 00:18:26,480
this is a keyed function so it also

516
00:18:26,480 --> 00:18:28,880
takes a key as an input

517
00:18:28,880 --> 00:18:30,960
and they are used to check the integrity

518
00:18:30,960 --> 00:18:33,280
of a message

519
00:18:33,280 --> 00:18:34,720
so when you send a message and you

520
00:18:34,720 --> 00:18:37,120
append a mac to it

521
00:18:37,120 --> 00:18:38,799
then that means that the message should

522
00:18:38,799 --> 00:18:43,600
not be able to change be changed

523
00:18:43,600 --> 00:18:45,360
and for this presentation just two

524
00:18:45,360 --> 00:18:47,520
properties are important so the first

525
00:18:47,520 --> 00:18:49,200
one is that it should behave like an

526
00:18:49,200 --> 00:18:50,960
integrity check

527
00:18:50,960 --> 00:18:52,240
so

528
00:18:52,240 --> 00:18:54,880
if we know a message m1 and the

529
00:18:54,880 --> 00:18:57,760
corresponding tag h1 then it should be

530
00:18:57,760 --> 00:19:01,360
difficult to forge the message

531
00:19:01,360 --> 00:19:04,640
so to find another message m2

532
00:19:04,640 --> 00:19:08,400
with the corresponding tag h1

533
00:19:08,400 --> 00:19:10,720
and the second property is that if you

534
00:19:10,720 --> 00:19:13,360
have an indifferential hash function

535
00:19:13,360 --> 00:19:14,480
uh h

536
00:19:14,480 --> 00:19:17,280
then the mac function that uses this

537
00:19:17,280 --> 00:19:20,000
hash hash function and simply passes the

538
00:19:20,000 --> 00:19:22,840
key and the message

539
00:19:22,840 --> 00:19:25,840
to uh to the hash function then this

540
00:19:25,840 --> 00:19:27,600
should be a secure

541
00:19:27,600 --> 00:19:28,720
uh mac

542
00:19:28,720 --> 00:19:31,039
and uh there are there should be two

543
00:19:31,039 --> 00:19:33,200
possible attacks

544
00:19:33,200 --> 00:19:36,320
is exhaustive key search

545
00:19:36,320 --> 00:19:38,960
which gives a security level of k and

546
00:19:38,960 --> 00:19:40,559
the second one is that you could also

547
00:19:40,559 --> 00:19:42,960
find collision so that's where we get

548
00:19:42,960 --> 00:19:43,679
the

549
00:19:43,679 --> 00:19:45,039
n over two

550
00:19:45,039 --> 00:19:46,960
and we will mostly use this

551
00:19:46,960 --> 00:19:48,080
uh

552
00:19:48,080 --> 00:19:50,720
when we instantiate a hash function then

553
00:19:50,720 --> 00:19:52,880
we will see that this function may not

554
00:19:52,880 --> 00:19:54,799
be a good mac and that will also mean

555
00:19:54,799 --> 00:19:56,320
that the hash function is not

556
00:19:56,320 --> 00:19:59,120
indifferentiable

557
00:19:59,440 --> 00:20:00,320
so

558
00:20:00,320 --> 00:20:03,600
the classic uh hash construction is the

559
00:20:03,600 --> 00:20:06,480
mercury dom guard construction which is

560
00:20:06,480 --> 00:20:09,600
on the fixed size compression function f

561
00:20:09,600 --> 00:20:12,400
and it simply compresses a message

562
00:20:12,400 --> 00:20:14,080
sequentially in blocks

563
00:20:14,080 --> 00:20:17,440
so we start we start with an rv and then

564
00:20:17,440 --> 00:20:20,000
we call the compression function with m1

565
00:20:20,000 --> 00:20:22,240
sk inputs and then passes through and

566
00:20:22,240 --> 00:20:24,559
compressed again with m2 all the way up

567
00:20:24,559 --> 00:20:28,240
to mm and then output of the final

568
00:20:28,240 --> 00:20:30,480
compression call will be the

569
00:20:30,480 --> 00:20:32,400
outputs

570
00:20:32,400 --> 00:20:33,679
however

571
00:20:33,679 --> 00:20:35,200
this construct

572
00:20:35,200 --> 00:20:37,200
is susceptible to that

573
00:20:37,200 --> 00:20:39,600
attack

574
00:20:41,200 --> 00:20:42,799
so

575
00:20:42,799 --> 00:20:45,039
suppose that we use it as a mac function

576
00:20:45,039 --> 00:20:47,200
as before so that we

577
00:20:47,200 --> 00:20:49,120
prepends the key to

578
00:20:49,120 --> 00:20:51,039
the message

579
00:20:51,039 --> 00:20:54,240
and when we look at the outputs of m1

580
00:20:54,240 --> 00:20:56,880
and m1 concatenated with

581
00:20:56,880 --> 00:20:59,360
m2 we'll we will get

582
00:20:59,360 --> 00:21:01,440
these two constructions so for the first

583
00:21:01,440 --> 00:21:04,159
one first box k and then m1 and for the

584
00:21:04,159 --> 00:21:06,159
second one the same but it's also m2

585
00:21:06,159 --> 00:21:07,360
abandoned

586
00:21:07,360 --> 00:21:10,400
and if we look at the mag security

587
00:21:10,400 --> 00:21:11,919
uh

588
00:21:11,919 --> 00:21:14,000
what we are looking at is that suppose

589
00:21:14,000 --> 00:21:17,360
that m1 is sanded with a bit attack so

590
00:21:17,360 --> 00:21:20,720
suppose we know m1 and attack h1 and

591
00:21:20,720 --> 00:21:22,320
then we will

592
00:21:22,320 --> 00:21:23,200
look

593
00:21:23,200 --> 00:21:26,720
also given m2 can we compute this this

594
00:21:26,720 --> 00:21:30,240
new tag h2 without needing to know the

595
00:21:30,240 --> 00:21:31,919
secret key k

596
00:21:31,919 --> 00:21:35,679
and in this case what we can see is that

597
00:21:35,679 --> 00:21:37,360
actually the first construction is

598
00:21:37,360 --> 00:21:39,039
repeated here

599
00:21:39,039 --> 00:21:41,360
and that the intermediate chaining value

600
00:21:41,360 --> 00:21:43,600
will be equal to h1

601
00:21:43,600 --> 00:21:47,039
so we can simply compute h2 by

602
00:21:47,039 --> 00:21:48,640
calling the compression

603
00:21:48,640 --> 00:21:51,520
function on h1 with the key m2

604
00:21:51,520 --> 00:21:53,840
and because we do not need to know

605
00:21:53,840 --> 00:21:55,760
the secret key k for this this is a

606
00:21:55,760 --> 00:21:58,240
problem and this means that it is this

607
00:21:58,240 --> 00:21:59,039
is

608
00:21:59,039 --> 00:22:01,840
not a secure mac function

609
00:22:01,840 --> 00:22:03,600
and as a consequence

610
00:22:03,600 --> 00:22:04,960
the hash function is not

611
00:22:04,960 --> 00:22:07,760
indifferentiable

612
00:22:07,919 --> 00:22:10,240
so most straightforward way i think to

613
00:22:10,240 --> 00:22:13,520
fix this is to use domain separation

614
00:22:13,520 --> 00:22:16,720
so now instead of having

615
00:22:16,720 --> 00:22:19,039
the message blocks as directly as key

616
00:22:19,039 --> 00:22:21,600
inputs we will also append a bit to it

617
00:22:21,600 --> 00:22:22,799
during the notes

618
00:22:22,799 --> 00:22:25,039
whether it's the final note or not so

619
00:22:25,039 --> 00:22:28,559
we'll almost always append a zero but

620
00:22:28,559 --> 00:22:29,840
only for the

621
00:22:29,840 --> 00:22:32,880
for the final block we will append a one

622
00:22:32,880 --> 00:22:35,280
and now the attack doesn't work anymore

623
00:22:35,280 --> 00:22:36,400
because

624
00:22:36,400 --> 00:22:38,240
uh this first construction is not

625
00:22:38,240 --> 00:22:40,480
repeated here because

626
00:22:40,480 --> 00:22:42,000
here we have a one and the area f is

627
00:22:42,000 --> 00:22:43,919
zero so it doesn't work

628
00:22:43,919 --> 00:22:44,880
and

629
00:22:44,880 --> 00:22:46,880
this construction is also shown to be

630
00:22:46,880 --> 00:22:48,400
indifferentiable

631
00:22:48,400 --> 00:22:50,960
by govern at all when it is based on an

632
00:22:50,960 --> 00:22:52,840
ideal compression function

633
00:22:52,840 --> 00:22:56,320
f and this is more commonly done

634
00:22:56,320 --> 00:22:58,080
is that often the

635
00:22:58,080 --> 00:22:59,280
the hash

636
00:22:59,280 --> 00:23:01,919
constructions are based on a smaller

637
00:23:01,919 --> 00:23:04,720
fixed size compression friction f

638
00:23:04,720 --> 00:23:07,039
however such an ideal compression

639
00:23:07,039 --> 00:23:09,360
function we cannot build that directly

640
00:23:09,360 --> 00:23:12,320
and we have to use another primitive

641
00:23:12,320 --> 00:23:14,159
and the possible building block is to

642
00:23:14,159 --> 00:23:16,000
use a block cipher e

643
00:23:16,000 --> 00:23:17,679
and a common way to

644
00:23:17,679 --> 00:23:20,000
transform a block cipher to a

645
00:23:20,000 --> 00:23:21,840
compression function is by using the

646
00:23:21,840 --> 00:23:24,640
davis-meyer construction which uses a

647
00:23:24,640 --> 00:23:27,600
feed force in the data inputs

648
00:23:27,600 --> 00:23:29,360
however this construction is not

649
00:23:29,360 --> 00:23:31,120
indifferentiable from an ideal

650
00:23:31,120 --> 00:23:33,600
compression function so we cannot

651
00:23:33,600 --> 00:23:36,080
compose these results and not really the

652
00:23:36,080 --> 00:23:38,559
right abstraction level so we really

653
00:23:38,559 --> 00:23:40,960
need the dedicated analysis using the

654
00:23:40,960 --> 00:23:43,039
block cipher as the underlying

655
00:23:43,039 --> 00:23:45,279
assumption and not

656
00:23:45,279 --> 00:23:47,760
the compression function

657
00:23:47,760 --> 00:23:51,919
and this was done by dominant uh at all

658
00:23:51,919 --> 00:23:53,679
where they try to find sufficient

659
00:23:53,679 --> 00:23:55,279
conditions for

660
00:23:55,279 --> 00:23:56,159
uh

661
00:23:56,159 --> 00:23:58,000
for hashing modes based on the block

662
00:23:58,000 --> 00:24:01,440
cipher and also some other constructions

663
00:24:01,440 --> 00:24:04,240
however it turns out that there was a

664
00:24:04,240 --> 00:24:05,600
flaw

665
00:24:05,600 --> 00:24:07,440
in the paper as

666
00:24:07,440 --> 00:24:08,960
samuel nevis

667
00:24:08,960 --> 00:24:10,960
found that it also proves faulty

668
00:24:10,960 --> 00:24:13,200
constructions secure

669
00:24:13,200 --> 00:24:15,520
so now we have the same construction as

670
00:24:15,520 --> 00:24:18,240
before with the domain separation but

671
00:24:18,240 --> 00:24:21,440
instead of using a compression function

672
00:24:21,440 --> 00:24:24,880
f we will use the block cipher

673
00:24:24,880 --> 00:24:26,480
and now it is

674
00:24:26,480 --> 00:24:28,480
insecure again because

675
00:24:28,480 --> 00:24:31,120
we can make use of the fact that the

676
00:24:31,120 --> 00:24:33,279
block cipher is invertible

677
00:24:33,279 --> 00:24:35,360
so suppose again that we

678
00:24:35,360 --> 00:24:38,720
know the message m1 and attack h1 and we

679
00:24:38,720 --> 00:24:42,640
will try to forge it to any new message

680
00:24:42,640 --> 00:24:44,840
and what we can simply do

681
00:24:44,840 --> 00:24:48,159
is compute the intermediate chaining

682
00:24:48,159 --> 00:24:51,760
value cv by calling inverse block cipher

683
00:24:51,760 --> 00:24:54,720
and then going forward again with

684
00:24:54,720 --> 00:24:56,320
with a different message

685
00:24:56,320 --> 00:24:59,039
as a key input we do not need to know

686
00:24:59,039 --> 00:25:00,720
the secret key k

687
00:25:00,720 --> 00:25:02,240
for this

688
00:25:02,240 --> 00:25:04,159
but we can still

689
00:25:04,159 --> 00:25:07,120
compute this h2

690
00:25:07,120 --> 00:25:09,440
so this goes that

691
00:25:09,440 --> 00:25:11,279
the paper proves some faulty

692
00:25:11,279 --> 00:25:13,919
construction secure so there's there's

693
00:25:13,919 --> 00:25:16,559
problem there

694
00:25:17,039 --> 00:25:18,720
and then errata

695
00:25:18,720 --> 00:25:20,080
i and also

696
00:25:20,080 --> 00:25:23,039
with the dominant mening

697
00:25:23,039 --> 00:25:25,520
that provides a quick fix where we

698
00:25:25,520 --> 00:25:27,679
require additional truncation in the

699
00:25:27,679 --> 00:25:29,120
conditions

700
00:25:29,120 --> 00:25:31,200
to fix those but

701
00:25:31,200 --> 00:25:32,880
there's also an error in the proof and

702
00:25:32,880 --> 00:25:35,360
if we look more closely at what the

703
00:25:35,360 --> 00:25:38,240
error is it's actually more fundamental

704
00:25:38,240 --> 00:25:40,880
about the individuality setting

705
00:25:40,880 --> 00:25:43,279
so now we will quickly over the

706
00:25:43,279 --> 00:25:45,760
individuality setting so it is a bit

707
00:25:45,760 --> 00:25:48,080
technical but it is necessary to to

708
00:25:48,080 --> 00:25:50,720
explain what the error is

709
00:25:50,720 --> 00:25:53,039
so inevitability setting

710
00:25:53,039 --> 00:25:55,520
it is a distinguishing game so we have a

711
00:25:55,520 --> 00:25:58,480
distinguisher d and it tries to just

712
00:25:58,480 --> 00:26:00,559
distinguish between the real and the

713
00:26:00,559 --> 00:26:02,159
ideal goals

714
00:26:02,159 --> 00:26:03,760
and it can make

715
00:26:03,760 --> 00:26:07,120
two kinds of queries or yes

716
00:26:07,120 --> 00:26:10,080
but one kind also has two kinds but it

717
00:26:10,080 --> 00:26:11,840
can make primitive and construction

718
00:26:11,840 --> 00:26:12,960
queries

719
00:26:12,960 --> 00:26:14,960
so in the real world

720
00:26:14,960 --> 00:26:17,600
the primitive is the block cipher and

721
00:26:17,600 --> 00:26:19,039
the construction is simply good

722
00:26:19,039 --> 00:26:20,640
reconstruction

723
00:26:20,640 --> 00:26:22,240
so

724
00:26:22,240 --> 00:26:23,919
how does the construction computes and

725
00:26:23,919 --> 00:26:25,840
outputs so it simply calls the block

726
00:26:25,840 --> 00:26:27,440
cipher

727
00:26:27,440 --> 00:26:29,440
to get the output

728
00:26:29,440 --> 00:26:31,840
and in the ideal world what we want is

729
00:26:31,840 --> 00:26:34,400
that the construction behaves like a

730
00:26:34,400 --> 00:26:36,400
random oracle so we put a random oracle

731
00:26:36,400 --> 00:26:37,760
there

732
00:26:37,760 --> 00:26:38,640
but

733
00:26:38,640 --> 00:26:40,559
a random oracle doesn't really have a

734
00:26:40,559 --> 00:26:44,000
primitive so we define a simulator for

735
00:26:44,000 --> 00:26:45,679
the primitive

736
00:26:45,679 --> 00:26:48,400
and what a what simulator will simply do

737
00:26:48,400 --> 00:26:51,520
is basically always give random outputs

738
00:26:51,520 --> 00:26:53,760
but it also has to behave like the

739
00:26:53,760 --> 00:26:56,320
primitive of the construction

740
00:26:56,320 --> 00:26:59,760
so when it finishes

741
00:26:59,760 --> 00:27:01,279
like a

742
00:27:01,279 --> 00:27:03,279
computation of a message then it has to

743
00:27:03,279 --> 00:27:05,919
be consistent with a random oracle so in

744
00:27:05,919 --> 00:27:07,840
those cases it will query the random

745
00:27:07,840 --> 00:27:10,159
oracle and then it's basically forced to

746
00:27:10,159 --> 00:27:13,279
take some value

747
00:27:13,440 --> 00:27:15,039
and because

748
00:27:15,039 --> 00:27:17,120
we use the block cipher as the

749
00:27:17,120 --> 00:27:18,640
underlying

750
00:27:18,640 --> 00:27:21,919
primitive it's uh we can also make four

751
00:27:21,919 --> 00:27:23,919
and background queries

752
00:27:23,919 --> 00:27:26,480
uh for this primitive

753
00:27:26,480 --> 00:27:28,399
so now we can take a look at what the

754
00:27:28,399 --> 00:27:32,000
flawed reasoning is so it will

755
00:27:32,000 --> 00:27:34,000
the reasoning takes multiple steps and

756
00:27:34,000 --> 00:27:36,080
soma are also fine

757
00:27:36,080 --> 00:27:38,320
so it starts with multiplying the

758
00:27:38,320 --> 00:27:41,840
distinguisher d to an equivalent one d

759
00:27:41,840 --> 00:27:45,200
prime and this step will actually be phi

760
00:27:45,200 --> 00:27:49,440
so what does our d prime do so it starts

761
00:27:49,440 --> 00:27:53,120
with just interacting like d did this

762
00:27:53,120 --> 00:27:55,919
so on the right side i have an example

763
00:27:55,919 --> 00:27:58,080
and this is actually

764
00:27:58,080 --> 00:28:00,880
the attack we had earlier so

765
00:28:00,880 --> 00:28:02,799
what the attack did is that it started

766
00:28:02,799 --> 00:28:04,960
at the end it made an inverse query and

767
00:28:04,960 --> 00:28:06,320
then for it again

768
00:28:06,320 --> 00:28:08,799
so if you look at it more formally

769
00:28:08,799 --> 00:28:10,960
it starts with a construction query to

770
00:28:10,960 --> 00:28:12,320
get

771
00:28:12,320 --> 00:28:14,720
the first stack h1

772
00:28:14,720 --> 00:28:18,399
then it made an inverse query on this h1

773
00:28:18,399 --> 00:28:20,960
with our message to get the

774
00:28:20,960 --> 00:28:24,000
supposed chaining value of cv prime

775
00:28:24,000 --> 00:28:26,320
then it made a fourth query again on

776
00:28:26,320 --> 00:28:28,320
this supposed chaining value

777
00:28:28,320 --> 00:28:30,559
with a different message

778
00:28:30,559 --> 00:28:32,960
to get well a supposed

779
00:28:32,960 --> 00:28:35,440
new tag and then we

780
00:28:35,440 --> 00:28:37,679
call the construction oracle again to

781
00:28:37,679 --> 00:28:38,880
get to

782
00:28:38,880 --> 00:28:40,159
check whether

783
00:28:40,159 --> 00:28:43,360
these correspond or not

784
00:28:43,440 --> 00:28:44,559
so

785
00:28:44,559 --> 00:28:47,600
after interacting like d what d prime

786
00:28:47,600 --> 00:28:49,039
additionally does

787
00:28:49,039 --> 00:28:51,919
is that it adds verification queries for

788
00:28:51,919 --> 00:28:54,399
these construction queries

789
00:28:54,399 --> 00:28:55,360
so

790
00:28:55,360 --> 00:28:57,440
we call construction or go

791
00:28:57,440 --> 00:28:59,840
on on k appenders with

792
00:28:59,840 --> 00:29:03,679
m1 and k with m2 and we will also verify

793
00:29:03,679 --> 00:29:07,200
these queries so then it first calls

794
00:29:07,200 --> 00:29:10,000
the primitive busy iv with the key as

795
00:29:10,000 --> 00:29:12,640
input to get chaining value and then

796
00:29:12,640 --> 00:29:15,679
with this chaining value with m1 to get

797
00:29:15,679 --> 00:29:18,799
h1 and the same for h2 and we have a bit

798
00:29:18,799 --> 00:29:21,919
of overlap so on query is

799
00:29:21,919 --> 00:29:24,840
is repeatedly but we don't know

800
00:29:24,840 --> 00:29:28,399
that after these verification queries d

801
00:29:28,399 --> 00:29:30,480
prime will simply output the same

802
00:29:30,480 --> 00:29:33,039
decision as d did so in this case it

803
00:29:33,039 --> 00:29:34,799
checks whether these two values are the

804
00:29:34,799 --> 00:29:38,159
same it's not that important

805
00:29:38,159 --> 00:29:40,399
and what we now can see is that

806
00:29:40,399 --> 00:29:41,760
these verification queries in these

807
00:29:41,760 --> 00:29:43,840
construction pairs contain duplicate

808
00:29:43,840 --> 00:29:46,240
information because

809
00:29:46,240 --> 00:29:48,240
uh here we have an h1 and in the

810
00:29:48,240 --> 00:29:50,240
primitive carriers as well and the same

811
00:29:50,240 --> 00:29:52,159
for h2

812
00:29:52,159 --> 00:29:54,320
and the primitive queries

813
00:29:54,320 --> 00:29:56,240
they also contain the chaining value so

814
00:29:56,240 --> 00:29:59,200
they contain more information

815
00:29:59,200 --> 00:30:01,279
but the construction queries their

816
00:30:01,279 --> 00:30:03,200
outputs can be derived from primitive

817
00:30:03,200 --> 00:30:04,799
queries

818
00:30:04,799 --> 00:30:06,799
so how the reason goes is well then we

819
00:30:06,799 --> 00:30:08,960
simply can simply ignore them to make

820
00:30:08,960 --> 00:30:09,679
the

821
00:30:09,679 --> 00:30:12,640
analysis easier

822
00:30:12,640 --> 00:30:14,080
but this cannot

823
00:30:14,080 --> 00:30:16,880
be done this is a problem because it

824
00:30:16,880 --> 00:30:18,880
ignores that the output of the

825
00:30:18,880 --> 00:30:20,399
construction queries can have an

826
00:30:20,399 --> 00:30:23,039
influence on the later queries

827
00:30:23,039 --> 00:30:24,880
so what we had is that the output of the

828
00:30:24,880 --> 00:30:27,200
first construction query was h1 and we

829
00:30:27,200 --> 00:30:28,559
actually use

830
00:30:28,559 --> 00:30:30,720
that value in our first inverse

831
00:30:30,720 --> 00:30:32,640
primitive query

832
00:30:32,640 --> 00:30:35,760
and if we ignore the query well h1

833
00:30:35,760 --> 00:30:37,200
is not there so

834
00:30:37,200 --> 00:30:38,880
this does not work

835
00:30:38,880 --> 00:30:40,960
and we can also not

836
00:30:40,960 --> 00:30:43,440
uh like fake some value that's randomly

837
00:30:43,440 --> 00:30:45,520
generated because

838
00:30:45,520 --> 00:30:47,679
the verification query should output the

839
00:30:47,679 --> 00:30:50,559
same h1

840
00:30:50,799 --> 00:30:51,760
but

841
00:30:51,760 --> 00:30:53,840
but we don't have it so

842
00:30:53,840 --> 00:30:56,480
it's it really is

843
00:30:56,480 --> 00:30:58,799
it's more like is really a fundamental

844
00:30:58,799 --> 00:31:00,960
plot that ignores

845
00:31:00,960 --> 00:31:02,640
a lot of the interaction between the

846
00:31:02,640 --> 00:31:05,360
construction and primitive oracles

847
00:31:05,360 --> 00:31:07,840
and the same flaws actually also present

848
00:31:07,840 --> 00:31:10,799
in many other individuality papers

849
00:31:10,799 --> 00:31:13,519
so there are two also on hashing and

850
00:31:13,519 --> 00:31:15,200
also four on the

851
00:31:15,200 --> 00:31:17,679
sum of permutations and these are

852
00:31:17,679 --> 00:31:19,279
actually also all the works on the

853
00:31:19,279 --> 00:31:24,080
individuality of the sum of permutations

854
00:31:24,159 --> 00:31:25,279
so

855
00:31:25,279 --> 00:31:27,840
we have a slight positive notice that

856
00:31:27,840 --> 00:31:29,840
this reasoning does hold in the

857
00:31:29,840 --> 00:31:31,840
sequential

858
00:31:31,840 --> 00:31:34,159
setting where all the primitive queries

859
00:31:34,159 --> 00:31:35,919
have to be made before the construction

860
00:31:35,919 --> 00:31:37,120
ones

861
00:31:37,120 --> 00:31:39,039
so what we can say

862
00:31:39,039 --> 00:31:41,679
is that these results are

863
00:31:41,679 --> 00:31:45,440
downgraded to this vcar setting so that

864
00:31:45,440 --> 00:31:49,679
they still have some positive results

865
00:31:49,840 --> 00:31:52,799
and if we look at the case for hashing

866
00:31:52,799 --> 00:31:55,519
as we saw earlier that the errata fixed

867
00:31:55,519 --> 00:31:58,080
the conditions by requiring sufficient

868
00:31:58,080 --> 00:31:59,519
truncation

869
00:31:59,519 --> 00:32:02,480
but this is not that great of a fix as

870
00:32:02,480 --> 00:32:04,960
not really all modes can apply this so

871
00:32:04,960 --> 00:32:06,399
in this work

872
00:32:06,399 --> 00:32:07,360
uh

873
00:32:07,360 --> 00:32:10,080
look at also some other options so the

874
00:32:10,080 --> 00:32:12,320
first one is truncation again but there

875
00:32:12,320 --> 00:32:13,120
are

876
00:32:13,120 --> 00:32:16,240
we also have some interesting variations

877
00:32:16,240 --> 00:32:18,240
the second one is the enveloped

878
00:32:18,240 --> 00:32:21,200
finalization which is a generalization

879
00:32:21,200 --> 00:32:23,840
of enveloped mercury domguard

880
00:32:23,840 --> 00:32:25,519
and the third one is feedforward

881
00:32:25,519 --> 00:32:26,880
finalization

882
00:32:26,880 --> 00:32:29,840
this is also one we'll look at in this

883
00:32:29,840 --> 00:32:32,720
uh presentation

884
00:32:34,480 --> 00:32:37,600
so the feedboard isn't it's a common

885
00:32:37,600 --> 00:32:40,399
uh common finalization

886
00:32:40,399 --> 00:32:42,720
and what it does is that it takes the

887
00:32:42,720 --> 00:32:44,240
input

888
00:32:44,240 --> 00:32:48,960
of a block circle and also xors it

889
00:32:48,960 --> 00:32:50,960
with the output

890
00:32:50,960 --> 00:32:53,600
and in this paper we also have more

891
00:32:53,600 --> 00:32:55,200
assumptions on the

892
00:32:55,200 --> 00:32:56,480
on what the input

893
00:32:56,480 --> 00:32:58,000
looks like so it

894
00:32:58,000 --> 00:32:59,919
consists of two parts the first one will

895
00:32:59,919 --> 00:33:02,559
always be a chaining value of a previous

896
00:33:02,559 --> 00:33:04,320
compression call

897
00:33:04,320 --> 00:33:07,279
and for the second one

898
00:33:07,279 --> 00:33:08,840
we simply use an

899
00:33:08,840 --> 00:33:12,480
rv and what you see is that

900
00:33:12,480 --> 00:33:14,000
this feedforward is actually only

901
00:33:14,000 --> 00:33:16,000
required for the final compression call

902
00:33:16,000 --> 00:33:16,960
while

903
00:33:16,960 --> 00:33:20,880
for indifferentiability while

904
00:33:22,240 --> 00:33:23,279
all

905
00:33:23,279 --> 00:33:25,840
all compression functions

906
00:33:25,840 --> 00:33:28,960
it's only the final one is required

907
00:33:28,960 --> 00:33:30,000
uh

908
00:33:30,000 --> 00:33:31,919
and i said like oh we

909
00:33:31,919 --> 00:33:34,799
we have this iv2 but

910
00:33:34,799 --> 00:33:37,840
it's not necessarily a fixed value it

911
00:33:37,840 --> 00:33:39,919
can also

912
00:33:39,919 --> 00:33:42,320
to be more flexible be allowed to have

913
00:33:42,320 --> 00:33:44,000
multiple possible

914
00:33:44,000 --> 00:33:46,240
values for example a counter which we

915
00:33:46,240 --> 00:33:49,200
will see later

916
00:33:49,919 --> 00:33:51,440
but

917
00:33:51,440 --> 00:33:53,919
the simulator has to loop over all these

918
00:33:53,919 --> 00:33:56,240
possibilities in some cases and query

919
00:33:56,240 --> 00:33:57,760
the random oracle

920
00:33:57,760 --> 00:33:59,600
for everyone

921
00:33:59,600 --> 00:34:01,679
and

922
00:34:01,679 --> 00:34:04,080
having many options does not really

923
00:34:04,080 --> 00:34:05,760
influence the

924
00:34:05,760 --> 00:34:08,560
advantage of the distinguisher d

925
00:34:08,560 --> 00:34:10,719
but it does increase the query

926
00:34:10,719 --> 00:34:13,440
complexity of our simulator

927
00:34:13,440 --> 00:34:15,918
which is a bit more simple but it's also

928
00:34:15,918 --> 00:34:17,119
something

929
00:34:17,119 --> 00:34:20,480
that should be limited

930
00:34:20,480 --> 00:34:22,320
so

931
00:34:22,320 --> 00:34:25,199
the major application is blake 3 which

932
00:34:25,199 --> 00:34:28,079
is a recent block cipher based 3 hashing

933
00:34:28,079 --> 00:34:29,199
mode

934
00:34:29,199 --> 00:34:30,159
and

935
00:34:30,159 --> 00:34:32,079
we will for this talk will focus on the

936
00:34:32,079 --> 00:34:35,359
final compression call so it

937
00:34:35,359 --> 00:34:38,480
looks like this and what we see is that

938
00:34:38,480 --> 00:34:41,440
the key input is equal to the final

939
00:34:41,440 --> 00:34:43,440
message block m

940
00:34:43,440 --> 00:34:45,918
and the data input consists of a

941
00:34:45,918 --> 00:34:47,280
chaining value

942
00:34:47,280 --> 00:34:50,480
and for the other part it contains an iv

943
00:34:50,480 --> 00:34:52,879
counter t the number of bytes being a

944
00:34:52,879 --> 00:34:55,040
message and some flags

945
00:34:55,040 --> 00:34:57,040
it's not always important but the

946
00:34:57,040 --> 00:34:59,200
counter t

947
00:34:59,200 --> 00:35:01,280
is more interesting which we'll focus

948
00:35:01,280 --> 00:35:02,400
later on

949
00:35:02,400 --> 00:35:04,320
and the outputs is actually

950
00:35:04,320 --> 00:35:06,720
split into the lower and the higher bits

951
00:35:06,720 --> 00:35:09,040
and then there's some internal xor

952
00:35:09,040 --> 00:35:10,560
and then

953
00:35:10,560 --> 00:35:12,720
the chaining values xor

954
00:35:12,720 --> 00:35:14,320
with one of them

955
00:35:14,320 --> 00:35:16,240
so it does not exactly follow the

956
00:35:16,240 --> 00:35:17,680
definition

957
00:35:17,680 --> 00:35:19,839
we had earlier but for the proof that's

958
00:35:19,839 --> 00:35:21,440
actually fine it's

959
00:35:21,440 --> 00:35:23,200
because we only use that the chaining

960
00:35:23,200 --> 00:35:24,720
value

961
00:35:24,720 --> 00:35:27,599
is fed forward

962
00:35:27,599 --> 00:35:32,079
so blake three has two different modes

963
00:35:32,079 --> 00:35:34,880
so one is a fixed output mode and for

964
00:35:34,880 --> 00:35:37,440
this it uses truncation

965
00:35:37,440 --> 00:35:39,760
which you will study before and this is

966
00:35:39,760 --> 00:35:40,640
fine

967
00:35:40,640 --> 00:35:42,960
but it also has extendable outputs and

968
00:35:42,960 --> 00:35:45,680
there it uses the counter so to get

969
00:35:45,680 --> 00:35:48,240
multiple blocks of outputs

970
00:35:48,240 --> 00:35:50,560
uh it starts with setting the counter to

971
00:35:50,560 --> 00:35:53,280
zero and getting the output and sets it

972
00:35:53,280 --> 00:35:58,760
through one and advance it and so on

973
00:35:59,520 --> 00:36:00,720
and

974
00:36:00,720 --> 00:36:02,720
as i said before black three uses the

975
00:36:02,720 --> 00:36:05,040
speed force finalization

976
00:36:05,040 --> 00:36:07,599
but what we said is that

977
00:36:07,599 --> 00:36:09,440
like this non-cv

978
00:36:09,440 --> 00:36:10,880
inputs

979
00:36:10,880 --> 00:36:13,520
which we call rv2 should have a limited

980
00:36:13,520 --> 00:36:16,320
number of possibilities but because of

981
00:36:16,320 --> 00:36:19,119
this counter which just can go on and on

982
00:36:19,119 --> 00:36:22,240
there are actually many possibilities

983
00:36:22,240 --> 00:36:25,200
and this is an interesting property

984
00:36:25,200 --> 00:36:26,800
namely

985
00:36:26,800 --> 00:36:30,000
so let's assume that we know a message m

986
00:36:30,000 --> 00:36:31,520
and it's

987
00:36:31,520 --> 00:36:33,760
a full message

988
00:36:33,760 --> 00:36:35,680
and it's hash output

989
00:36:35,680 --> 00:36:38,880
add some offset t for the counter but we

990
00:36:38,880 --> 00:36:41,760
do not know the counter itself

991
00:36:41,760 --> 00:36:44,160
what we can actually see is that we can

992
00:36:44,160 --> 00:36:47,119
then compute this counter directly well

993
00:36:47,119 --> 00:36:49,599
in as ideal behavior we would expect

994
00:36:49,599 --> 00:36:51,599
that we would have to try every

995
00:36:51,599 --> 00:36:54,640
possibility and make a query

996
00:36:54,640 --> 00:36:57,119
so here all the values that are known

997
00:36:57,119 --> 00:36:58,480
are highlighted

998
00:36:58,480 --> 00:37:00,800
so the chaining value can be computed

999
00:37:00,800 --> 00:37:02,400
from the message

1000
00:37:02,400 --> 00:37:04,400
and the last message block is also part

1001
00:37:04,400 --> 00:37:07,440
of that and we assume that we know the

1002
00:37:07,440 --> 00:37:10,480
full hash output so also the

1003
00:37:10,480 --> 00:37:13,599
hl and h

1004
00:37:13,599 --> 00:37:15,280
and what you can see if we start at the

1005
00:37:15,280 --> 00:37:16,640
right

1006
00:37:16,640 --> 00:37:18,800
first there's an xor with chaining value

1007
00:37:18,800 --> 00:37:20,480
which is known so we can

1008
00:37:20,480 --> 00:37:22,400
move on and then we

1009
00:37:22,400 --> 00:37:24,560
have an internal one which you also know

1010
00:37:24,560 --> 00:37:26,160
so we also get

1011
00:37:26,160 --> 00:37:29,040
the the vl and the vhtr also known and

1012
00:37:29,040 --> 00:37:30,880
because because we also know the key

1013
00:37:30,880 --> 00:37:33,920
inputs we can make an inverse query and

1014
00:37:33,920 --> 00:37:35,839
compute all these inputs including the

1015
00:37:35,839 --> 00:37:38,400
counter t

1016
00:37:38,880 --> 00:37:42,160
so in short if we know a message m and

1017
00:37:42,160 --> 00:37:44,960
it's hash output but not counter then we

1018
00:37:44,960 --> 00:37:48,720
can compute this counter

1019
00:37:49,520 --> 00:37:51,599
and as consequence of this we cannot

1020
00:37:51,599 --> 00:37:54,079
really rely on the secrecy of this

1021
00:37:54,079 --> 00:37:56,640
counter

1022
00:37:56,720 --> 00:37:58,960
and we can illustrate this with by

1023
00:37:58,960 --> 00:38:01,920
defining a contrived mac function

1024
00:38:01,920 --> 00:38:04,160
so mac function had in

1025
00:38:04,160 --> 00:38:06,560
the key input and a message

1026
00:38:06,560 --> 00:38:08,720
and in this case we assume that the key

1027
00:38:08,720 --> 00:38:12,160
is 128 bits and we will split it into

1028
00:38:12,160 --> 00:38:14,960
two parts so the first part of 70 bits

1029
00:38:14,960 --> 00:38:17,520
and the second part of 58 just so that

1030
00:38:17,520 --> 00:38:20,560
the definitions worked out

1031
00:38:20,560 --> 00:38:21,359
and

1032
00:38:21,359 --> 00:38:23,359
a bit like before

1033
00:38:23,359 --> 00:38:27,040
to compute the the tag of the mac

1034
00:38:27,040 --> 00:38:29,520
we will call the hash function on the

1035
00:38:29,520 --> 00:38:31,599
message input with the key

1036
00:38:31,599 --> 00:38:34,400
appended to it but in this case we move

1037
00:38:34,400 --> 00:38:35,839
part of the key

1038
00:38:35,839 --> 00:38:38,240
to the offset

1039
00:38:38,240 --> 00:38:40,479
and

1040
00:38:40,880 --> 00:38:42,800
ideally this

1041
00:38:42,800 --> 00:38:44,800
this would only allow for a key recovery

1042
00:38:44,800 --> 00:38:48,480
attack into the power 128

1043
00:38:48,480 --> 00:38:51,040
bits that sometimes we can actually do

1044
00:38:51,040 --> 00:38:54,640
it in to the power chevy queries

1045
00:38:54,640 --> 00:38:57,680
so for an attack we assume that we

1046
00:38:57,680 --> 00:38:59,280
know the message m

1047
00:38:59,280 --> 00:39:01,359
and the hash output

1048
00:39:01,359 --> 00:39:04,160
and remember if you know

1049
00:39:04,160 --> 00:39:06,720
the message and the hash of

1050
00:39:06,720 --> 00:39:08,320
that full message then we know the

1051
00:39:08,320 --> 00:39:09,440
counts are

1052
00:39:09,440 --> 00:39:11,119
so these amps are actually not the same

1053
00:39:11,119 --> 00:39:12,960
so

1054
00:39:12,960 --> 00:39:15,680
in this case we know m but k1 is also

1055
00:39:15,680 --> 00:39:17,680
part of its input

1056
00:39:17,680 --> 00:39:21,680
so we do have to guess k1 which is where

1057
00:39:21,680 --> 00:39:24,240
the 2 to the power 70 comes from but

1058
00:39:24,240 --> 00:39:26,000
once we know that we can compute the

1059
00:39:26,000 --> 00:39:29,599
counter see which is equal to the second

1060
00:39:29,599 --> 00:39:31,760
part of the key directly

1061
00:39:31,760 --> 00:39:32,720
so we

1062
00:39:32,720 --> 00:39:35,040
don't have to guess that

1063
00:39:35,040 --> 00:39:39,359
so then this gives the desired result

1064
00:39:39,599 --> 00:39:42,880
so concluding we saw that many previous

1065
00:39:42,880 --> 00:39:44,720
indefensibility proofs

1066
00:39:44,720 --> 00:39:47,680
contain really a fundamental error

1067
00:39:47,680 --> 00:39:49,760
and that's these results are downgraded

1068
00:39:49,760 --> 00:39:51,280
to the weaker sequential

1069
00:39:51,280 --> 00:39:54,400
interferenceability setting

1070
00:39:54,400 --> 00:39:57,359
and for block cipher base 3 hashing

1071
00:39:57,359 --> 00:40:00,000
uh we have an unsatisfactory fix that

1072
00:40:00,000 --> 00:40:02,079
requires truncation

1073
00:40:02,079 --> 00:40:04,960
and in this work we prove also other

1074
00:40:04,960 --> 00:40:07,839
finalizations secure including

1075
00:40:07,839 --> 00:40:09,839
the government feed

1076
00:40:09,839 --> 00:40:12,319
and we also saw that blake 3

1077
00:40:12,319 --> 00:40:14,800
can be proven indifferentiable but it

1078
00:40:14,800 --> 00:40:17,359
does require a public offset in the

1079
00:40:17,359 --> 00:40:18,640
extendable

1080
00:40:18,640 --> 00:40:21,440
outputs so that is not ideal behavior

1081
00:40:21,440 --> 00:40:24,079
but a practice also not that big of a

1082
00:40:24,079 --> 00:40:25,920
problem

1083
00:40:25,920 --> 00:40:28,079
so that's the end of my presentation

1084
00:40:28,079 --> 00:40:31,200
thank you for your attention

1085
00:40:36,960 --> 00:40:38,240
we still have a few minutes for

1086
00:40:38,240 --> 00:40:40,319
questions so that's anyone a question

1087
00:40:40,319 --> 00:40:43,520
yeah looks like it

1088
00:40:43,680 --> 00:40:46,079
so i just wanted to ask this is a cool

1089
00:40:46,079 --> 00:40:49,680
talk um i wanted to ask if um

1090
00:40:49,680 --> 00:40:51,520
i kind of have an intuition for what

1091
00:40:51,520 --> 00:40:53,280
security guarantees i'm getting with an

1092
00:40:53,280 --> 00:40:55,599
indifferentiability proof on a hashing

1093
00:40:55,599 --> 00:40:57,839
mode i don't have a lot of intuition for

1094
00:40:57,839 --> 00:40:58,880
what the sequential and

1095
00:40:58,880 --> 00:41:00,880
differentiability is telling me

1096
00:41:00,880 --> 00:41:02,079
does that what does that because that

1097
00:41:02,079 --> 00:41:03,839
seems very it seems like it's very weak

1098
00:41:03,839 --> 00:41:05,359
intuitively so

1099
00:41:05,359 --> 00:41:07,760
do you have a good way of a good guide

1100
00:41:07,760 --> 00:41:08,720
for

1101
00:41:08,720 --> 00:41:10,560
how do how should i think about the

1102
00:41:10,560 --> 00:41:12,160
implications of just having sequential

1103
00:41:12,160 --> 00:41:14,319
and differentiability on

1104
00:41:14,319 --> 00:41:15,599
in the proof

1105
00:41:15,599 --> 00:41:19,119
yeah so this is a much bigger notion

1106
00:41:19,119 --> 00:41:21,359
and i think it

1107
00:41:21,359 --> 00:41:24,720
does have also more limited applications

1108
00:41:24,720 --> 00:41:26,480
but so

1109
00:41:26,480 --> 00:41:28,800
uh like included it so that they still

1110
00:41:28,800 --> 00:41:31,040
have positive results but we really

1111
00:41:31,040 --> 00:41:33,359
should want to have an individuality

1112
00:41:33,359 --> 00:41:35,200
proof and not the sequential

1113
00:41:35,200 --> 00:41:37,280
differentiability one like participation

1114
00:41:37,280 --> 00:41:38,319
trophy

1115
00:41:38,319 --> 00:41:40,560
yes

1116
00:41:42,640 --> 00:41:44,319
all right so uh

1117
00:41:44,319 --> 00:41:46,000
again forgive me if this is a somewhat

1118
00:41:46,000 --> 00:41:49,280
basic question but um as as i learned in

1119
00:41:49,280 --> 00:41:50,960
cryptography class

1120
00:41:50,960 --> 00:41:53,359
uh hash functions are not implied by

1121
00:41:53,359 --> 00:41:55,680
one-way functions which means they

1122
00:41:55,680 --> 00:41:57,839
cannot be constructed out of

1123
00:41:57,839 --> 00:41:59,040
prf

1124
00:41:59,040 --> 00:41:59,920
so

1125
00:41:59,920 --> 00:42:02,720
uh my question is what

1126
00:42:02,720 --> 00:42:05,040
like if you have an indistinguishability

1127
00:42:05,040 --> 00:42:07,680
proof for a hash function construction

1128
00:42:07,680 --> 00:42:09,839
from a block cipher what additional

1129
00:42:09,839 --> 00:42:11,359
assumptions are you making on the block

1130
00:42:11,359 --> 00:42:12,400
cipher

1131
00:42:12,400 --> 00:42:14,800
to make that possible because because

1132
00:42:14,800 --> 00:42:17,599
you couldn't just assume that is era

1133
00:42:17,599 --> 00:42:21,680
i'll assume that it is an ideal cypher

1134
00:42:21,680 --> 00:42:23,599
okay that's

1135
00:42:23,599 --> 00:42:26,000
but you get uh like in differentiability

1136
00:42:26,000 --> 00:42:27,920
and that's

1137
00:42:27,920 --> 00:42:31,319
also some

1138
00:42:31,839 --> 00:42:34,480
so like in different videos not exactly

1139
00:42:34,480 --> 00:42:37,920
random oracle but uh in many cases

1140
00:42:37,920 --> 00:42:40,079
it behaves like one oh wait so you you

1141
00:42:40,079 --> 00:42:41,839
have some kind of indifferentiability

1142
00:42:41,839 --> 00:42:43,440
assumption on the

1143
00:42:43,440 --> 00:42:45,440
block cipher itself

1144
00:42:45,440 --> 00:42:49,040
yes all right all right thank you

1145
00:42:50,960 --> 00:42:52,160
yeah although thanks for a really

1146
00:42:52,160 --> 00:42:54,800
interesting talk um i don't have a

1147
00:42:54,800 --> 00:42:57,520
question i have a complaint

1148
00:42:57,520 --> 00:42:59,040
actually not to you it's to the

1149
00:42:59,040 --> 00:43:01,200
community in general right as you point

1150
00:43:01,200 --> 00:43:03,200
out in your paper um

1151
00:43:03,200 --> 00:43:05,280
in the like it's there's no proof that

1152
00:43:05,280 --> 00:43:07,839
indifferential hash functions resist

1153
00:43:07,839 --> 00:43:10,240
length extension attacks but that was

1154
00:43:10,240 --> 00:43:13,359
more or less the um

1155
00:43:13,359 --> 00:43:14,240
the

1156
00:43:14,240 --> 00:43:16,640
promise made of why we introduced the

1157
00:43:16,640 --> 00:43:18,560
indifferentiability framework but it

1158
00:43:18,560 --> 00:43:21,200
seems in the past more than 10 years

1159
00:43:21,200 --> 00:43:23,280
there hasn't been

1160
00:43:23,280 --> 00:43:25,440
much progress that i know of in this

1161
00:43:25,440 --> 00:43:26,640
area

1162
00:43:26,640 --> 00:43:28,240
so i think

1163
00:43:28,240 --> 00:43:30,160
an indifferential hash function does

1164
00:43:30,160 --> 00:43:31,760
imply that it is

1165
00:43:31,760 --> 00:43:34,079
uh it doesn't have the length extension

1166
00:43:34,079 --> 00:43:35,200
problem

1167
00:43:35,200 --> 00:43:36,240
so it's more

1168
00:43:36,240 --> 00:43:39,040
i think the length extension

1169
00:43:39,040 --> 00:43:40,880
there's more that you that chose to buy

1170
00:43:40,880 --> 00:43:43,040
you want some indifferentiable hash so

1171
00:43:43,040 --> 00:43:44,640
yeah american guy

1172
00:43:44,640 --> 00:43:46,000
right but okay here

1173
00:43:46,000 --> 00:43:47,040
um

1174
00:43:47,040 --> 00:43:49,440
although we expect them to we do not

1175
00:43:49,440 --> 00:43:52,000
have proof that current in differential

1176
00:43:52,000 --> 00:43:53,760
hash constructions resist length

1177
00:43:53,760 --> 00:43:55,680
extension attacks

1178
00:43:55,680 --> 00:43:58,800
this is in your paper

1179
00:43:58,800 --> 00:44:02,839
i'm reading this in your paper

1180
00:44:13,680 --> 00:44:16,160
there's a technical problem um that

1181
00:44:16,160 --> 00:44:18,400
that's been pointed out at europa 2011

1182
00:44:18,400 --> 00:44:22,240
uh related to this um okay yeah like

1183
00:44:22,240 --> 00:44:23,520
it's technical and it's related to

1184
00:44:23,520 --> 00:44:25,599
multi-stage adversaries so it's um yeah

1185
00:44:25,599 --> 00:44:27,280
so that's true that's

1186
00:44:27,280 --> 00:44:29,119
the in differentiability is only about a

1187
00:44:29,119 --> 00:44:31,599
single stage and not multiple states

1188
00:44:31,599 --> 00:44:34,640
maybe that's but all of the or perhaps

1189
00:44:34,640 --> 00:44:37,599
this all of the formalizations of uh

1190
00:44:37,599 --> 00:44:39,280
length extension attacks involve a

1191
00:44:39,280 --> 00:44:42,560
multi-stage adversary

1192
00:44:42,640 --> 00:44:45,839
yeah perhaps there's uh no i think

1193
00:44:45,839 --> 00:44:47,760
let's look at this offline

1194
00:44:47,760 --> 00:44:49,839
so just wanted to discuss it yeah like

1195
00:44:49,839 --> 00:44:51,280
uh maybe we want to take this offline

1196
00:44:51,280 --> 00:44:53,280
yeah discuss further anyway thank you

1197
00:44:53,280 --> 00:44:54,800
for a really interesting presentation

1198
00:44:54,800 --> 00:44:56,160
thank you

1199
00:44:56,160 --> 00:44:57,760
it's just so actually a quick

1200
00:44:57,760 --> 00:44:59,920
clarification so for the so since you

1201
00:44:59,920 --> 00:45:01,760
found the bugs the bug in a series of

1202
00:45:01,760 --> 00:45:03,680
papers so are there still statements

1203
00:45:03,680 --> 00:45:05,200
that remain

1204
00:45:05,200 --> 00:45:06,960
open so you have examples of things that

1205
00:45:06,960 --> 00:45:07,760
are

1206
00:45:07,760 --> 00:45:08,880
but we only have sequential

1207
00:45:08,880 --> 00:45:10,480
differentiability and we will need to

1208
00:45:10,480 --> 00:45:12,720
fix things yes so

1209
00:45:12,720 --> 00:45:14,720
this is interesting for the the sum of

1210
00:45:14,720 --> 00:45:16,839
permutations

1211
00:45:16,839 --> 00:45:19,599
because they're what i first thought and

1212
00:45:19,599 --> 00:45:22,720
also and there's like oh it is more like

1213
00:45:22,720 --> 00:45:24,880
a technical problem

1214
00:45:24,880 --> 00:45:28,079
and we can probably just fix it uh

1215
00:45:28,079 --> 00:45:30,319
easily to make it also indifferentiable

1216
00:45:30,319 --> 00:45:31,440
but

1217
00:45:31,440 --> 00:45:33,599
uh i also looked at it more and it's

1218
00:45:33,599 --> 00:45:35,599
still going work but

1219
00:45:35,599 --> 00:45:36,560
uh

1220
00:45:36,560 --> 00:45:38,960
surprisingly there's there is actually

1221
00:45:38,960 --> 00:45:40,160
there are a difference between the

1222
00:45:40,160 --> 00:45:42,480
sequential and full indifferentiability

1223
00:45:42,480 --> 00:45:43,599
so

1224
00:45:43,599 --> 00:45:45,119
uh so it's

1225
00:45:45,119 --> 00:45:46,960
so the attack is like

1226
00:45:46,960 --> 00:45:48,800
you have a specific simulator so not

1227
00:45:48,800 --> 00:45:50,880
that clear but there really is a

1228
00:45:50,880 --> 00:45:53,440
difference uh more than you maybe would

1229
00:45:53,440 --> 00:45:54,560
expect

1230
00:45:54,560 --> 00:45:56,640
you see but it's not really not refilled

1231
00:45:56,640 --> 00:45:58,000
to move from sequential to full

1232
00:45:58,000 --> 00:45:59,520
differentiability by the way when you

1233
00:45:59,520 --> 00:46:01,200
say sequential because both variants

1234
00:46:01,200 --> 00:46:03,040
exist do you mean construction before

1235
00:46:03,040 --> 00:46:04,480
primitives or primitive before

1236
00:46:04,480 --> 00:46:05,920
construction primitive before

1237
00:46:05,920 --> 00:46:07,680
construction okay yeah

1238
00:46:07,680 --> 00:46:09,839
okay

1239
00:46:10,400 --> 00:46:12,800
all right no more question

1240
00:46:12,800 --> 00:46:14,400
let's thank aldo again then the next

1241
00:46:14,400 --> 00:46:17,119
speaker consider

1242
00:46:19,040 --> 00:46:21,920
and we are back on schedule

1243
00:46:21,920 --> 00:46:25,640
thanks for asking questions

1244
00:47:04,640 --> 00:47:07,040
all right so the the next talk is on

1245
00:47:07,040 --> 00:47:09,520
probably secure reflection ciphers and

1246
00:47:09,520 --> 00:47:11,359
this is joint work by tim vayner and

1247
00:47:11,359 --> 00:47:13,040
yulon chen and yulong is going to give

1248
00:47:13,040 --> 00:47:15,599
the talk okay so thank you stefano thank

1249
00:47:15,599 --> 00:47:18,079
you for the introduction um this talk is

1250
00:47:18,079 --> 00:47:20,160
not really about hash functions anymore

1251
00:47:20,160 --> 00:47:21,920
so we are going to talk a little bit

1252
00:47:21,920 --> 00:47:22,880
about

1253
00:47:22,880 --> 00:47:26,880
not primitive namely block cyprus

1254
00:47:26,880 --> 00:47:28,960
cryptographers has long been fascinated

1255
00:47:28,960 --> 00:47:31,599
by the self-inverse or the cell and the

1256
00:47:31,599 --> 00:47:33,440
same self-interest property of

1257
00:47:33,440 --> 00:47:35,200
encryption device

1258
00:47:35,200 --> 00:47:38,000
and the famous example is an enigma road

1259
00:47:38,000 --> 00:47:40,240
machine where the encryption and the

1260
00:47:40,240 --> 00:47:42,720
decryption operations are identical this

1261
00:47:42,720 --> 00:47:45,119
is enabled by the middle reflector which

1262
00:47:45,119 --> 00:47:47,040
makes the encryption device much more

1263
00:47:47,040 --> 00:47:48,880
compact

1264
00:47:48,880 --> 00:47:50,319
now this

1265
00:47:50,319 --> 00:47:53,040
self-inverse property can actually also

1266
00:47:53,040 --> 00:47:55,520
be found back in the modern ciphers for

1267
00:47:55,520 --> 00:47:58,559
example cypher space on the famous

1268
00:47:58,559 --> 00:48:02,240
faysal network uh example is a you know

1269
00:48:02,240 --> 00:48:04,079
this block cipher

1270
00:48:04,079 --> 00:48:04,839
now

1271
00:48:04,839 --> 00:48:07,680
um those five societies have the

1272
00:48:07,680 --> 00:48:09,839
following property namely decryption is

1273
00:48:09,839 --> 00:48:12,240
always possible that is equal to

1274
00:48:12,240 --> 00:48:14,480
encryption using wrong keys in the

1275
00:48:14,480 --> 00:48:17,119
reverse order

1276
00:48:17,119 --> 00:48:17,920
and

1277
00:48:17,920 --> 00:48:21,040
this property leads actually to

1278
00:48:21,040 --> 00:48:24,240
the fact that we do not need to use our

1279
00:48:24,240 --> 00:48:26,640
underlying runs functions to be

1280
00:48:26,640 --> 00:48:29,440
invertible anymore and this gives us

1281
00:48:29,440 --> 00:48:31,680
actually more flexibility when we need

1282
00:48:31,680 --> 00:48:34,240
to use those runs functions because um

1283
00:48:34,240 --> 00:48:35,359
during

1284
00:48:35,359 --> 00:48:37,440
decryption we can also just evaluate

1285
00:48:37,440 --> 00:48:41,200
those round functions forward

1286
00:48:41,200 --> 00:48:43,599
another property is that not the entire

1287
00:48:43,599 --> 00:48:45,920
input string is updated every want

1288
00:48:45,920 --> 00:48:47,920
because that's only the right part

1289
00:48:47,920 --> 00:48:49,119
priority

1290
00:48:49,119 --> 00:48:51,440
function

1291
00:48:52,880 --> 00:48:55,839
so the generic security of the physical

1292
00:48:55,839 --> 00:48:58,720
cybers actually first started by um

1293
00:48:58,720 --> 00:49:00,839
juventus blackout in

1294
00:49:00,839 --> 00:49:04,559
95. now that's it's another important

1295
00:49:04,559 --> 00:49:06,319
class of um

1296
00:49:06,319 --> 00:49:08,559
divers are actually based on another

1297
00:49:08,559 --> 00:49:10,640
design structure which the alternating

1298
00:49:10,640 --> 00:49:14,640
sci-fi structure and um that famously is

1299
00:49:14,640 --> 00:49:15,760
based on

1300
00:49:15,760 --> 00:49:18,800
here um the office were actually first

1301
00:49:18,800 --> 00:49:21,839
inspired by sean's idea and

1302
00:49:21,839 --> 00:49:24,079
a very special property of the key

1303
00:49:24,079 --> 00:49:26,559
alternating cyphers is that um that

1304
00:49:26,559 --> 00:49:29,119
usually requires less from some bison

1305
00:49:29,119 --> 00:49:30,559
site

1306
00:49:30,559 --> 00:49:32,880
and another property is fast diffusion

1307
00:49:32,880 --> 00:49:35,440
since the entire input string is updated

1308
00:49:35,440 --> 00:49:37,040
every month

1309
00:49:37,040 --> 00:49:39,359
now the limitation about the key

1310
00:49:39,359 --> 00:49:41,119
automating stuff is that they do not

1311
00:49:41,119 --> 00:49:42,240
have

1312
00:49:42,240 --> 00:49:45,680
the self-interest property like bicycles

1313
00:49:45,680 --> 00:49:48,319
and the generic security of the the

1314
00:49:48,319 --> 00:49:50,640
alternating cyphers first i was first

1315
00:49:50,640 --> 00:49:53,920
started by event sponsor in 1991

1316
00:49:53,920 --> 00:49:56,400
for the single bronze case and by bosnia

1317
00:49:56,400 --> 00:49:57,480
no fatal

1318
00:49:57,480 --> 00:50:01,119
2012 and for the musical wrong phase

1319
00:50:01,119 --> 00:50:02,240
now

1320
00:50:02,240 --> 00:50:04,880
i explained about both type of design

1321
00:50:04,880 --> 00:50:07,440
structures and both

1322
00:50:07,440 --> 00:50:08,880
design structures have their own

1323
00:50:08,880 --> 00:50:10,839
advantage and

1324
00:50:10,839 --> 00:50:14,079
limitations you may wonder um do we get

1325
00:50:14,079 --> 00:50:16,240
the following question whether we can

1326
00:50:16,240 --> 00:50:18,720
combine the two ideas such as we can get

1327
00:50:18,720 --> 00:50:22,160
a nice structure such that um it's

1328
00:50:22,160 --> 00:50:23,760
similar to the key of the mating cypher

1329
00:50:23,760 --> 00:50:25,920
design structure such as restaurants can

1330
00:50:25,920 --> 00:50:28,640
be that are needed to

1331
00:50:28,640 --> 00:50:30,720
build up your cipher while still

1332
00:50:30,720 --> 00:50:33,520
obtaining the self-inverse property of

1333
00:50:33,520 --> 00:50:35,599
the physo network

1334
00:50:35,599 --> 00:50:37,520
the answer to this question is actually

1335
00:50:37,520 --> 00:50:39,760
already given

1336
00:50:39,760 --> 00:50:42,880
um by boko hartol where they produce the

1337
00:50:42,880 --> 00:50:46,640
prince book cipher so here you can even

1338
00:50:46,640 --> 00:50:48,240
slide this

1339
00:50:48,240 --> 00:50:50,400
the design property i mean the design

1340
00:50:50,400 --> 00:50:52,720
structure of the internal structure of

1341
00:50:52,720 --> 00:50:55,680
the pinstock cipher and we call it the

1342
00:50:55,680 --> 00:50:57,440
key of the mating reflection cipher

1343
00:50:57,440 --> 00:50:58,559
where this

1344
00:50:58,559 --> 00:51:01,280
r is actually a reflector it's normally

1345
00:51:01,280 --> 00:51:03,359
an evolution

1346
00:51:03,359 --> 00:51:04,240
and

1347
00:51:04,240 --> 00:51:07,440
this type of scythe ciphers has a boeing

1348
00:51:07,440 --> 00:51:08,960
property named the

1349
00:51:08,960 --> 00:51:11,440
friction problem property that's um

1350
00:51:11,440 --> 00:51:13,599
decryption is always equal to encryption

1351
00:51:13,599 --> 00:51:15,680
using related keys

1352
00:51:15,680 --> 00:51:16,480
and

1353
00:51:16,480 --> 00:51:19,119
this makes a cypher particularly

1354
00:51:19,119 --> 00:51:22,640
suitable for low latency low use case

1355
00:51:22,640 --> 00:51:26,160
however unlike the case for fiso or for

1356
00:51:26,160 --> 00:51:28,640
key automating cyphers the generic

1357
00:51:28,640 --> 00:51:31,359
security the study of generic security

1358
00:51:31,359 --> 00:51:34,400
are actually missing until this moment

1359
00:51:34,400 --> 00:51:37,280
so in this work we are going to um

1360
00:51:37,280 --> 00:51:39,440
study the genetic security of the

1361
00:51:39,440 --> 00:51:41,200
reflection

1362
00:51:41,200 --> 00:51:43,680
before i'm going to do that um i first

1363
00:51:43,680 --> 00:51:45,440
want to explain what's generic

1364
00:51:45,440 --> 00:51:47,280
experience for block science

1365
00:51:47,280 --> 00:51:49,680
in order to do that we need to define a

1366
00:51:49,680 --> 00:51:52,319
attack so at the beginning of the game

1367
00:51:52,319 --> 00:51:55,200
so um one of the tools are chosen

1368
00:51:55,200 --> 00:51:57,280
either the real world on the right on

1369
00:51:57,280 --> 00:51:58,400
the left side

1370
00:51:58,400 --> 00:52:01,440
and the id right side so this attacker

1371
00:52:01,440 --> 00:52:04,480
here can make you a berries to the

1372
00:52:04,480 --> 00:52:07,040
construction oracle which is um the

1373
00:52:07,040 --> 00:52:10,000
proposed block cipher in the real world

1374
00:52:10,000 --> 00:52:13,599
i do a uniform permutation

1375
00:52:13,599 --> 00:52:15,280
in the ideal

1376
00:52:15,280 --> 00:52:16,559
and

1377
00:52:16,559 --> 00:52:18,640
yeah at the same time that attacker can

1378
00:52:18,640 --> 00:52:21,359
also make p primitive queries and the

1379
00:52:21,359 --> 00:52:23,440
underlying primitives are the

1380
00:52:23,440 --> 00:52:24,960
permutations which

1381
00:52:24,960 --> 00:52:27,599
works office builds um since we are

1382
00:52:27,599 --> 00:52:30,960
dealing with idea from page model

1383
00:52:30,960 --> 00:52:33,760
so after ace communication i should

1384
00:52:33,760 --> 00:52:36,240
state which of those two worlds was

1385
00:52:36,240 --> 00:52:38,000
intact

1386
00:52:38,000 --> 00:52:41,040
and the probability of um that attacker

1387
00:52:41,040 --> 00:52:43,599
can distinguish the two worlds actually

1388
00:52:43,599 --> 00:52:45,359
um that's actually the

1389
00:52:45,359 --> 00:52:47,520
is actually measured by this problem

1390
00:52:47,520 --> 00:52:49,359
and um for the rest of the this

1391
00:52:49,359 --> 00:52:52,000
presentation we are going to um denote

1392
00:52:52,000 --> 00:52:54,000
this probability by the advantage

1393
00:52:54,000 --> 00:52:56,400
function and so we can see that the more

1394
00:52:56,400 --> 00:52:59,200
query access that's um the attacker gets

1395
00:52:59,200 --> 00:53:01,200
the higher the probability that can

1396
00:53:01,200 --> 00:53:02,640
distinguish

1397
00:53:02,640 --> 00:53:05,760
from the two worlds has um this

1398
00:53:05,760 --> 00:53:09,839
advantage actually a function of the

1399
00:53:10,160 --> 00:53:13,040
construction and difficult areas

1400
00:53:13,040 --> 00:53:14,960
now we can only say that they can

1401
00:53:14,960 --> 00:53:18,400
diverse cure if um that this function is

1402
00:53:18,400 --> 00:53:20,160
negative

1403
00:53:20,160 --> 00:53:21,040
okay

1404
00:53:21,040 --> 00:53:23,200
so um we are focused we are going to

1405
00:53:23,200 --> 00:53:26,880
focus on the two rounds case here and um

1406
00:53:26,880 --> 00:53:30,000
yeah we try to minimize the num the

1407
00:53:30,000 --> 00:53:32,480
number of randomness that's um i need

1408
00:53:32,480 --> 00:53:35,680
so then you first want to go to the one

1409
00:53:35,680 --> 00:53:38,720
d case but yeah this construction is

1410
00:53:38,720 --> 00:53:42,000
obviously your random vector is linear

1411
00:53:42,000 --> 00:53:44,880
since then we can just choose a message

1412
00:53:44,880 --> 00:53:47,280
m to obtain the corresponding ciphertext

1413
00:53:47,280 --> 00:53:49,520
and we can choose another

1414
00:53:49,520 --> 00:53:52,160
message that's equal to this ciphertext

1415
00:53:52,160 --> 00:53:56,079
and then and to obtain um

1416
00:53:56,079 --> 00:53:57,200
and then

1417
00:53:57,200 --> 00:53:59,520
yeah then we can see this new ciphertext

1418
00:53:59,520 --> 00:54:01,200
actually equal to

1419
00:54:01,200 --> 00:54:04,559
the um previous message once um vector

1420
00:54:04,559 --> 00:54:05,599
is in

1421
00:54:05,599 --> 00:54:08,000
and yeah of course we can immediately

1422
00:54:08,000 --> 00:54:11,200
distinguish the viewer from brandon

1423
00:54:11,200 --> 00:54:13,520
we can also

1424
00:54:13,520 --> 00:54:14,720
uh

1425
00:54:14,720 --> 00:54:17,359
second sense of force

1426
00:54:17,359 --> 00:54:19,599
stigma of chaos

1427
00:54:19,599 --> 00:54:20,640
pollution

1428
00:54:20,640 --> 00:54:23,119
but the problem here is that even

1429
00:54:23,119 --> 00:54:26,000
construction in that case not even a

1430
00:54:26,000 --> 00:54:28,400
secure up to burst rebounds when

1431
00:54:28,400 --> 00:54:29,920
required

1432
00:54:29,920 --> 00:54:32,960
since the reason here is because um that

1433
00:54:32,960 --> 00:54:34,559
this um

1434
00:54:34,559 --> 00:54:37,359
file with kxs

1435
00:54:37,359 --> 00:54:40,319
it's actually not uniform random so we

1436
00:54:40,319 --> 00:54:41,839
show that our

1437
00:54:41,839 --> 00:54:43,920
work that's because um

1438
00:54:43,920 --> 00:54:46,240
for linear in pollution they have they

1439
00:54:46,240 --> 00:54:48,799
have too many fixed points and so we'll

1440
00:54:48,799 --> 00:54:52,400
get problem down with been inside

1441
00:54:52,400 --> 00:54:54,480
which i'm just saying

1442
00:54:54,480 --> 00:54:56,640
right

1443
00:54:56,640 --> 00:54:58,799
now therefore we are going to

1444
00:54:58,799 --> 00:55:01,760
focus um on constructions to independent

1445
00:55:01,760 --> 00:55:04,000
keys

1446
00:55:04,000 --> 00:55:05,680
and um

1447
00:55:05,680 --> 00:55:07,839
yeah we do not claim that one key case

1448
00:55:07,839 --> 00:55:10,720
is not possible since um

1449
00:55:10,720 --> 00:55:11,680
yeah

1450
00:55:11,680 --> 00:55:13,839
we do believe that if we want to use a

1451
00:55:13,839 --> 00:55:16,880
single key then either it's need to have

1452
00:55:16,880 --> 00:55:19,520
a very special troll and choice of the

1453
00:55:19,520 --> 00:55:22,319
middle effector are or we need to use a

1454
00:55:22,319 --> 00:55:23,680
non-linear

1455
00:55:23,680 --> 00:55:26,559
reflector and stigma that has um

1456
00:55:26,559 --> 00:55:27,440
less

1457
00:55:27,440 --> 00:55:30,240
points but um yeah then this can differ

1458
00:55:30,240 --> 00:55:32,839
difficult and situation when we need to

1459
00:55:32,839 --> 00:55:34,000
bond and

1460
00:55:34,000 --> 00:55:37,599
other bad defense security

1461
00:55:37,599 --> 00:55:39,920
um so this will be left us and one

1462
00:55:39,920 --> 00:55:41,440
future

1463
00:55:41,440 --> 00:55:44,240
now in this work our first contribution

1464
00:55:44,240 --> 00:55:47,200
is to prove the generic note of the

1465
00:55:47,200 --> 00:55:50,640
two runs um yeah the automatic friction

1466
00:55:50,640 --> 00:55:51,839
cipher case

1467
00:55:51,839 --> 00:55:53,920
um based on the assumption that um

1468
00:55:53,920 --> 00:55:55,599
linear vector is

1469
00:55:55,599 --> 00:55:57,920
sent through automating

1470
00:55:57,920 --> 00:56:01,920
and this our um duty bonds change

1471
00:56:01,920 --> 00:56:03,119
and

1472
00:56:03,119 --> 00:56:05,200
the transaction has the following

1473
00:56:05,200 --> 00:56:07,440
property that decryption is encryption

1474
00:56:07,440 --> 00:56:08,400
using

1475
00:56:08,400 --> 00:56:10,079
that the two keys

1476
00:56:10,079 --> 00:56:11,920
just button keys

1477
00:56:11,920 --> 00:56:12,640
and

1478
00:56:12,640 --> 00:56:15,200
i'm going to say a little bit more about

1479
00:56:15,200 --> 00:56:18,400
those two terms the bonds and um why

1480
00:56:18,400 --> 00:56:20,480
those terms are tied for the general

1481
00:56:20,480 --> 00:56:23,359
force of um

1482
00:56:23,359 --> 00:56:27,279
and the first one is actually um

1483
00:56:27,760 --> 00:56:31,760
at the the actually the pq term then um

1484
00:56:31,760 --> 00:56:33,280
this is actually just an information

1485
00:56:33,280 --> 00:56:34,400
theoretic

1486
00:56:34,400 --> 00:56:35,200
so

1487
00:56:35,200 --> 00:56:37,520
um here we need to choose two q

1488
00:56:37,520 --> 00:56:39,200
construction queries and primitive

1489
00:56:39,200 --> 00:56:42,720
queries that that's um p square q is um

1490
00:56:42,720 --> 00:56:44,720
2 to the power 2 m

1491
00:56:44,720 --> 00:56:45,920
and then

1492
00:56:45,920 --> 00:56:50,319
for each possible pairs k1 and k2 we

1493
00:56:50,319 --> 00:56:52,400
need to find a pair of primitive queries

1494
00:56:52,400 --> 00:56:55,760
such as this um that those equations of

1495
00:56:55,760 --> 00:56:59,359
mx no k1 is equal to um burst um

1496
00:56:59,359 --> 00:57:03,440
primitive very u and c for xor and a two

1497
00:57:03,440 --> 00:57:06,960
is equal to second spring query so once

1498
00:57:06,960 --> 00:57:09,520
this happens then we can check whether

1499
00:57:09,520 --> 00:57:12,640
this um that this terminal relationship

1500
00:57:12,640 --> 00:57:14,960
information um

1501
00:57:14,960 --> 00:57:17,119
so once those all hold them we can

1502
00:57:17,119 --> 00:57:20,000
breathe system but as mentioned this is

1503
00:57:20,000 --> 00:57:22,240
just an information theoretic

1504
00:57:22,240 --> 00:57:24,000
so um

1505
00:57:24,000 --> 00:57:27,119
we say that attack is two to power two

1506
00:57:27,119 --> 00:57:29,520
and take over and tables

1507
00:57:29,520 --> 00:57:31,760
look ups and therefore it's really

1508
00:57:31,760 --> 00:57:34,160
impractical but it gives the idea that

1509
00:57:34,160 --> 00:57:37,599
um that this um the pq term is actually

1510
00:57:37,599 --> 00:57:40,640
avoidable and bombs but um

1511
00:57:40,640 --> 00:57:42,480
the next attack is actually more

1512
00:57:42,480 --> 00:57:43,920
interesting since

1513
00:57:43,920 --> 00:57:46,480
um uh practical attack that can be

1514
00:57:46,480 --> 00:57:49,760
performed in real time it's actually a

1515
00:57:49,760 --> 00:57:52,240
variance of the virulence like attack of

1516
00:57:52,240 --> 00:57:55,279
um donkey monkey

1517
00:58:01,280 --> 00:58:03,599
we can perform this attack if

1518
00:58:03,599 --> 00:58:05,760
this little reflector has many fixed

1519
00:58:05,760 --> 00:58:08,880
points and um

1520
00:58:17,599 --> 00:58:19,599
the high level idea of the attack is

1521
00:58:19,599 --> 00:58:21,359
that we need to find the pair of

1522
00:58:21,359 --> 00:58:23,359
construction queries that satisfy this

1523
00:58:23,359 --> 00:58:27,119
situation so we find the m that's um

1524
00:58:27,119 --> 00:58:28,559
the actual

1525
00:58:28,559 --> 00:58:29,599
um

1526
00:58:29,599 --> 00:58:32,079
message and this new cipher that's

1527
00:58:32,079 --> 00:58:35,280
equal to the x of the two keys but then

1528
00:58:35,280 --> 00:58:38,480
at the same time that um this actual

1529
00:58:38,480 --> 00:58:39,440
is

1530
00:58:39,440 --> 00:58:43,680
equal to um the extra of um your message

1531
00:58:43,680 --> 00:58:46,160
um by the text instance

1532
00:58:46,160 --> 00:58:49,520
here the volume here provides this value

1533
00:58:49,520 --> 00:58:52,160
and value

1534
00:58:52,960 --> 00:58:55,359
so once this

1535
00:58:55,359 --> 00:58:58,079
bonds then uh we are able to recover the

1536
00:58:58,079 --> 00:59:00,799
variable a1 page and this is really a

1537
00:59:00,799 --> 00:59:03,119
practical attach that can be

1538
00:59:03,119 --> 00:59:05,760
performed when um we have enough fixed

1539
00:59:05,760 --> 00:59:06,640
points

1540
00:59:06,640 --> 00:59:08,240
um so

1541
00:59:08,240 --> 00:59:10,640
yeah we actually can um

1542
00:59:10,640 --> 00:59:13,440
there is a chance that we may be able to

1543
00:59:13,440 --> 00:59:16,000
improve the security of the construction

1544
00:59:16,000 --> 00:59:19,440
when we choose a reflector with um

1545
00:59:19,440 --> 00:59:22,240
not so many fixed points then there's um

1546
00:59:22,240 --> 00:59:24,880
maybe a chance that we can avoid this um

1547
00:59:24,880 --> 00:59:28,880
attack and avoid this new square term

1548
00:59:28,880 --> 00:59:32,960
but this seems also one of the uh

1549
00:59:32,960 --> 00:59:35,920
now a little bit idea about um the

1550
00:59:35,920 --> 00:59:37,680
security analysis is performed using

1551
00:59:37,680 --> 00:59:39,440
battalions new theory

1552
00:59:39,440 --> 00:59:41,200
where the formulas are given here i'm

1553
00:59:41,200 --> 00:59:44,079
not going to experience details but we

1554
00:59:44,079 --> 00:59:46,319
have two terms the green one is actually

1555
00:59:46,319 --> 00:59:48,559
the probability of the

1556
00:59:48,559 --> 00:59:51,040
best transcripts while the this blue one

1557
00:59:51,040 --> 00:59:53,440
is actually obtained by the ratio of the

1558
00:59:53,440 --> 00:59:54,160
um

1559
00:59:54,160 --> 00:59:55,359
with stress

1560
00:59:55,359 --> 00:59:56,240
and a

1561
00:59:56,240 --> 00:59:58,559
real-world idea

1562
00:59:58,559 --> 01:00:02,000
and here we obtain this um a blue term

1563
01:00:02,000 --> 01:00:05,280
by an apparent idea of first iteration

1564
01:00:05,280 --> 01:00:07,440
of year theory what that is and you can

1565
01:00:07,440 --> 01:00:10,480
check the details of it

1566
01:00:10,480 --> 01:00:12,960
and we are dealing with ideal

1567
01:00:12,960 --> 01:00:14,559
permutation although

1568
01:00:14,559 --> 01:00:15,440
um

1569
01:00:15,440 --> 01:00:17,920
attacking will have internal access of

1570
01:00:17,920 --> 01:00:20,640
the um underlying current

1571
01:00:20,640 --> 01:00:23,200
time and since we have a single

1572
01:00:23,200 --> 01:00:25,599
permutation case we do have domain

1573
01:00:25,599 --> 01:00:28,799
separation in order to prove security

1574
01:00:28,799 --> 01:00:31,359
this is actually um guaranteed by

1575
01:00:31,359 --> 01:00:33,520
actually um by introducing a bad event

1576
01:00:33,520 --> 01:00:36,960
that's um similar to that's um yeah on

1577
01:00:36,960 --> 01:00:40,480
one um your slides are packaged

1578
01:00:40,480 --> 01:00:44,160
use grand term um so i'm not going to

1579
01:00:44,160 --> 01:00:46,240
much into details about the

1580
01:00:46,240 --> 01:00:48,160
analysis so this is our own first

1581
01:00:48,160 --> 01:00:51,839
contribution our second contribution is

1582
01:00:51,839 --> 01:00:52,559
um

1583
01:00:52,559 --> 01:00:55,760
yeah keyland standard so i first want to

1584
01:00:55,760 --> 01:00:58,480
explain the um old skill and standard

1585
01:00:58,480 --> 01:01:00,799
and produce the prince and bumpus diver

1586
01:01:00,799 --> 01:01:03,359
they use um the fixed structure which is

1587
01:01:03,359 --> 01:01:06,960
not here which they um they use external

1588
01:01:06,960 --> 01:01:07,680
um

1589
01:01:07,680 --> 01:01:11,440
bay to send the key lens from 64 bits to

1590
01:01:11,440 --> 01:01:13,440
128

1591
01:01:13,440 --> 01:01:15,920
now um they proved their results the

1592
01:01:15,920 --> 01:01:17,200
fact that

1593
01:01:17,200 --> 01:01:18,079
so

1594
01:01:18,079 --> 01:01:19,839
star is actually an ideal reflection

1595
01:01:19,839 --> 01:01:23,760
cipher and we can see that

1596
01:01:23,760 --> 01:01:25,440
looks like

1597
01:01:25,440 --> 01:01:28,480
yeah like this size

1598
01:01:28,480 --> 01:01:31,040
and um they proved the security of green

1599
01:01:31,040 --> 01:01:34,000
skill and thunder and to this bones we

1600
01:01:34,000 --> 01:01:36,559
can see this be a typical

1601
01:01:36,559 --> 01:01:38,880
birthday type of term which can

1602
01:01:38,880 --> 01:01:40,880
sometimes be insufficient for some

1603
01:01:40,880 --> 01:01:42,240
application

1604
01:01:42,240 --> 01:01:44,880
and and therefore they also the authors

1605
01:01:44,880 --> 01:01:47,920
also um use um the version tool which is

1606
01:01:47,920 --> 01:01:50,720
block cipher which used and uses

1607
01:01:50,720 --> 01:01:52,480
alternating runs

1608
01:01:52,480 --> 01:01:54,640
where the middle reflector is also

1609
01:01:54,640 --> 01:01:57,200
modified for a little bit

1610
01:01:57,200 --> 01:01:59,119
now our second contribution is we

1611
01:01:59,119 --> 01:02:01,920
introduced this new prince

1612
01:02:01,920 --> 01:02:04,480
i'm sorry the new pre-skill and extender

1613
01:02:04,480 --> 01:02:05,599
which

1614
01:02:05,599 --> 01:02:09,359
has bone security bonds and um our proof

1615
01:02:09,359 --> 01:02:11,680
is based on assumption

1616
01:02:11,680 --> 01:02:15,680
i do cipher and um our results actually

1617
01:02:15,680 --> 01:02:18,079
a direct production from

1618
01:02:18,079 --> 01:02:21,039
the one of security result of two runs

1619
01:02:21,039 --> 01:02:23,520
key automating servers but in order to

1620
01:02:23,520 --> 01:02:26,799
reduce um the security result of the

1621
01:02:26,799 --> 01:02:28,960
operating system we first need to

1622
01:02:28,960 --> 01:02:30,960
improve the security bundle we want to

1623
01:02:30,960 --> 01:02:32,640
key alternating

1624
01:02:32,640 --> 01:02:35,680
that's fun and at this part here and

1625
01:02:35,680 --> 01:02:37,920
this is actually the one that changed

1626
01:02:37,920 --> 01:02:40,680
from um the result of crypto

1627
01:02:40,680 --> 01:02:44,720
2014 well this is our um security fund

1628
01:02:44,720 --> 01:02:46,799
and we did that by improving the stone

1629
01:02:46,799 --> 01:02:49,760
capsule they might use variants of

1630
01:02:49,760 --> 01:02:54,000
quality and um this is actually um that

1631
01:02:54,000 --> 01:02:56,880
gives us an improved and spiritual term

1632
01:02:56,880 --> 01:03:00,240
that bans which need better and security

1633
01:03:00,240 --> 01:03:01,280
bonds

1634
01:03:01,280 --> 01:03:04,640
um yeah we still want to mention that

1635
01:03:04,640 --> 01:03:05,760
what we

1636
01:03:05,760 --> 01:03:08,240
i'm sorry

1637
01:03:08,720 --> 01:03:11,599
and what we proved here is actually

1638
01:03:11,599 --> 01:03:13,280
that different construction is and

1639
01:03:13,280 --> 01:03:15,839
genericities are secure against generic

1640
01:03:15,839 --> 01:03:17,359
action

1641
01:03:17,359 --> 01:03:20,240
up to this term however in order to use

1642
01:03:20,240 --> 01:03:21,839
this construction

1643
01:03:21,839 --> 01:03:24,000
for practical applications then we still

1644
01:03:24,000 --> 01:03:26,799
need to increase crypto analysis

1645
01:03:26,799 --> 01:03:31,359
and in order to make sure there will be

1646
01:03:31,359 --> 01:03:34,240
so if we compare our construction with

1647
01:03:34,240 --> 01:03:37,039
the original fx designer we can see that

1648
01:03:37,039 --> 01:03:39,119
that's actually the only difference that

1649
01:03:39,119 --> 01:03:42,319
we have by exporting okay and before and

1650
01:03:42,319 --> 01:03:45,319
after

1651
01:03:56,000 --> 01:03:58,640
version 2 then we can see that while our

1652
01:03:58,640 --> 01:04:00,720
construction just have a

1653
01:04:00,720 --> 01:04:03,359
change on the original things block

1654
01:04:03,359 --> 01:04:05,280
cipher and the prince version two

1655
01:04:05,280 --> 01:04:08,640
actually use two automating and keys and

1656
01:04:08,640 --> 01:04:10,720
besides their reflector is modified in

1657
01:04:10,720 --> 01:04:13,359
that way it doesn't really

1658
01:04:13,359 --> 01:04:15,839
preserve all the reflection properties

1659
01:04:15,839 --> 01:04:18,480
so we can see that our function actually

1660
01:04:18,480 --> 01:04:20,400
i'm comparison favorite

1661
01:04:20,400 --> 01:04:22,160
and

1662
01:04:22,160 --> 01:04:25,359
the last slide conclusion so our new

1663
01:04:25,359 --> 01:04:28,319
result is first generic treatment of um

1664
01:04:28,319 --> 01:04:30,880
reflection cyphers where we have two

1665
01:04:30,880 --> 01:04:32,640
main contributions the first one is to

1666
01:04:32,640 --> 01:04:35,119
improve the improvement your

1667
01:04:35,119 --> 01:04:37,200
results for two rounds about key

1668
01:04:37,200 --> 01:04:40,640
automating infection cipher and we also

1669
01:04:40,640 --> 01:04:43,119
provide a new key length gender with

1670
01:04:43,119 --> 01:04:45,039
better security

1671
01:04:45,039 --> 01:04:47,280
and

1672
01:04:47,359 --> 01:04:49,280
for future

1673
01:04:49,280 --> 01:04:51,920
research topics there are many things

1674
01:04:51,920 --> 01:04:54,160
that can be done for example if we

1675
01:04:54,160 --> 01:04:55,839
unless mentioned before we can have a

1676
01:04:55,839 --> 01:04:57,920
look at a single key case with whether

1677
01:04:57,920 --> 01:04:59,039
we can

1678
01:04:59,039 --> 01:05:02,000
try to modify the middle vector to have

1679
01:05:02,000 --> 01:05:04,559
some key case and um

1680
01:05:04,559 --> 01:05:07,039
yeah whether we can also modify the

1681
01:05:07,039 --> 01:05:09,520
minimum vectors such that maybe maybe

1682
01:05:09,520 --> 01:05:10,559
this

1683
01:05:10,559 --> 01:05:13,440
two square term can be avoided or and if

1684
01:05:13,440 --> 01:05:16,160
we can look at the general case like for

1685
01:05:16,160 --> 01:05:18,079
the key automating cyphers we go through

1686
01:05:18,079 --> 01:05:20,000
the mutable rounds where we can get

1687
01:05:20,000 --> 01:05:23,119
better at a tight security bonds and if

1688
01:05:23,119 --> 01:05:24,079
we can

1689
01:05:24,079 --> 01:05:27,200
extend this um idea to some of the

1690
01:05:27,200 --> 01:05:29,119
reflection cycles to the twig bowl and

1691
01:05:29,119 --> 01:05:30,799
reflection side

1692
01:05:30,799 --> 01:05:33,200
so um that this was the work done during

1693
01:05:33,200 --> 01:05:37,359
my phd now a small commercial for myself

1694
01:05:37,359 --> 01:05:41,520
yeah so thank you for your attention and

1695
01:05:41,520 --> 01:05:45,319
yeah so that's

1696
01:05:51,119 --> 01:05:52,799
all right thank you uh

1697
01:05:52,799 --> 01:05:54,319
thank you for the talk are there any

1698
01:05:54,319 --> 01:05:56,720
questions

1699
01:05:59,280 --> 01:06:03,039
so just just a quick one uh then so

1700
01:06:03,039 --> 01:06:04,880
so what what do you expect the biggest

1701
01:06:04,880 --> 01:06:07,119
difficulty to be to increase the number

1702
01:06:07,119 --> 01:06:08,640
right so is it like like new some

1703
01:06:08,640 --> 01:06:11,119
capture theorems or is it just yeah

1704
01:06:11,119 --> 01:06:14,240
definitely because um as i mentioned the

1705
01:06:14,240 --> 01:06:18,558
one with a single key case because um

1706
01:06:24,960 --> 01:06:27,520
because i think that i mentioned before

1707
01:06:27,520 --> 01:06:31,440
that function of k xor and stigma of

1708
01:06:31,440 --> 01:06:33,359
no yeah that's actually the case where

1709
01:06:33,359 --> 01:06:35,520
you don't get um

1710
01:06:35,520 --> 01:06:39,280
that's not uniform and

1711
01:06:40,240 --> 01:06:43,479
go back

1712
01:06:49,839 --> 01:06:52,400
yeah this one so and this this thing is

1713
01:06:52,400 --> 01:06:55,200
actually i'm not useful if under stigma

1714
01:06:55,200 --> 01:06:57,920
is um linear evolution so if we can use

1715
01:06:57,920 --> 01:07:00,079
a nonlinear evolution then we can choose

1716
01:07:00,079 --> 01:07:03,680
one that's probably have a better um

1717
01:07:03,680 --> 01:07:05,599
but the problem is here in this you will

1718
01:07:05,599 --> 01:07:07,920
get problems with some capture dilemma

1719
01:07:07,920 --> 01:07:09,599
when we need to bounce down the bad

1720
01:07:09,599 --> 01:07:11,680
defense then we usually need to have

1721
01:07:11,680 --> 01:07:13,440
that this thing should be linear in

1722
01:07:13,440 --> 01:07:15,599
order to use the tricks but in the case

1723
01:07:15,599 --> 01:07:18,480
of non-linear case then we cannot trick

1724
01:07:18,480 --> 01:07:20,960
and probably some capture them i cannot

1725
01:07:20,960 --> 01:07:21,920
and we

1726
01:07:21,920 --> 01:07:23,119
have a

1727
01:07:23,119 --> 01:07:26,720
say a better or a difficult technique to

1728
01:07:26,720 --> 01:07:29,359
uh monster bats but that's

1729
01:07:29,359 --> 01:07:32,160
one of the difficult cases also for the

1730
01:07:32,160 --> 01:07:34,480
mutable bronze case i think um to be

1731
01:07:34,480 --> 01:07:36,559
more difficult than the case of key

1732
01:07:36,559 --> 01:07:38,319
automating cyphers

1733
01:07:38,319 --> 01:07:41,839
now we only have um doubt so

1734
01:07:41,839 --> 01:07:44,400
we have one preparation here well we if

1735
01:07:44,400 --> 01:07:46,319
we extend it to a mutable ones we'll

1736
01:07:46,319 --> 01:07:47,839
have beautiful plantations but each

1737
01:07:47,839 --> 01:07:50,640
permutation is used twice so and the

1738
01:07:50,640 --> 01:07:52,960
forwards and the inverse

1739
01:07:52,960 --> 01:07:56,839
so that's what

1740
01:07:57,280 --> 01:08:00,079
right thank you so if there are no more

1741
01:08:00,079 --> 01:08:01,839
questions then let's thank you long

1742
01:08:01,839 --> 01:08:04,839
again

1743
01:08:43,600 --> 01:08:45,359
all right

1744
01:08:45,359 --> 01:08:48,080
so this takes us to the last talk of the

1745
01:08:48,080 --> 01:08:51,198
morning uh that is uh about overloading

1746
01:08:51,198 --> 01:08:54,960
the nonce rock prp's nonsense aad and

1747
01:08:54,960 --> 01:08:56,319
order resilient channels that's worked

1748
01:08:56,319 --> 01:08:58,960
by jean paul de gabriele and lucas in

1749
01:08:58,960 --> 01:09:00,158
karate

1750
01:09:00,158 --> 01:09:02,000
thank you

1751
01:09:02,000 --> 01:09:04,238
um so this is joint work with my student

1752
01:09:04,238 --> 01:09:05,920
brokashin who unfortunately couldn't be

1753
01:09:05,920 --> 01:09:08,080
here and

1754
01:09:08,080 --> 01:09:10,560
so in this work we make contributions in

1755
01:09:10,560 --> 01:09:13,040
three main directions we introduce a new

1756
01:09:13,040 --> 01:09:15,198
notion for pseudonym mutations called

1757
01:09:15,198 --> 01:09:17,120
rugged prps

1758
01:09:17,120 --> 01:09:20,080
we introduce a new variant of aed called

1759
01:09:20,080 --> 01:09:22,080
non-set aad

1760
01:09:22,080 --> 01:09:24,399
and when it shows how this can be used

1761
01:09:24,399 --> 01:09:26,560
to construct order resilient secure

1762
01:09:26,560 --> 01:09:28,560
channels

1763
01:09:28,560 --> 01:09:29,439
and

1764
01:09:29,439 --> 01:09:32,080
the main part of our title

1765
01:09:32,080 --> 01:09:33,600
refers to an underlying theme in our

1766
01:09:33,600 --> 01:09:35,759
work which is that of overloading the

1767
01:09:35,759 --> 01:09:37,198
use of the nons

1768
01:09:37,198 --> 01:09:39,279
traditionally nonsense serves to

1769
01:09:39,279 --> 01:09:41,359
diversify ciphertext but in this work we

1770
01:09:41,359 --> 01:09:43,120
use it also additionally to

1771
01:09:43,120 --> 01:09:44,880
provide authentication

1772
01:09:44,880 --> 01:09:47,120
and to recover the correct ordering of

1773
01:09:47,120 --> 01:09:50,560
the messages and orders being challenged

1774
01:09:50,560 --> 01:09:52,799
so i'll start this talk with

1775
01:09:52,799 --> 01:09:55,199
presenting the definition of rugged prps

1776
01:09:55,199 --> 01:09:57,679
i'll describe then a construction for

1777
01:09:57,679 --> 01:10:00,560
realizing rugged prp's called

1778
01:10:00,560 --> 01:10:03,120
the uiv construction

1779
01:10:03,120 --> 01:10:04,560
and then we'll see how we can transform

1780
01:10:04,560 --> 01:10:06,239
rugged prps into

1781
01:10:06,239 --> 01:10:08,239
aed schemes with a variety of security

1782
01:10:08,239 --> 01:10:09,760
properties

1783
01:10:09,760 --> 01:10:12,400
we'll then introduce non-set aad and see

1784
01:10:12,400 --> 01:10:14,800
how this can be used to construct orders

1785
01:10:14,800 --> 01:10:17,679
in channels

1786
01:10:17,679 --> 01:10:20,320
okay so let's start with definition

1787
01:10:20,320 --> 01:10:22,640
and the syntax of rugged prp is

1788
01:10:22,640 --> 01:10:25,280
essentially a variable length tweakable

1789
01:10:25,280 --> 01:10:28,640
cipher over a split domain

1790
01:10:28,640 --> 01:10:31,600
and and that means that the inputs and

1791
01:10:31,600 --> 01:10:32,960
outputs of it could be cipher will

1792
01:10:32,960 --> 01:10:35,040
consist of pairs of strings which we

1793
01:10:35,040 --> 01:10:36,560
refer to as the left string and the

1794
01:10:36,560 --> 01:10:38,400
right string

1795
01:10:38,400 --> 01:10:40,320
and in this presentation the last string

1796
01:10:40,320 --> 01:10:42,800
will consist of a string of n

1797
01:10:42,800 --> 01:10:45,199
size n where n is typically one to eight

1798
01:10:45,199 --> 01:10:47,040
bits or two five six bits

1799
01:10:47,040 --> 01:10:48,480
and the right string will be a variable

1800
01:10:48,480 --> 01:10:50,320
length

1801
01:10:50,320 --> 01:10:52,080
so identificable cipher consists of two

1802
01:10:52,080 --> 01:10:53,120
algorithms

1803
01:10:53,120 --> 01:10:54,800
and ciphering and deciphering and

1804
01:10:54,800 --> 01:10:56,719
ciphering here will take a tweak

1805
01:10:56,719 --> 01:10:58,800
and a pair of inputs xl and xr and

1806
01:10:58,800 --> 01:11:01,600
return a pair of outputs yl and yr

1807
01:11:01,600 --> 01:11:04,000
and for every tweak value this algorithm

1808
01:11:04,000 --> 01:11:05,040
will define

1809
01:11:05,040 --> 01:11:07,360
a distinct permutation

1810
01:11:07,360 --> 01:11:09,120
and then the deciphering algorithm

1811
01:11:09,120 --> 01:11:12,000
simply inverts this this mapping

1812
01:11:12,000 --> 01:11:13,600
in terms of security

1813
01:11:13,600 --> 01:11:16,800
um rugged prps achieve or strike

1814
01:11:16,800 --> 01:11:18,400
a level of security that sits right in

1815
01:11:18,400 --> 01:11:22,159
between that of prps and strong prbs

1816
01:11:22,159 --> 01:11:24,880
and at a high level this is achieved by

1817
01:11:24,880 --> 01:11:27,040
giving the adversary full access to the

1818
01:11:27,040 --> 01:11:29,360
ciphering algorithm but only giving it

1819
01:11:29,360 --> 01:11:30,719
partial access to the ciphering

1820
01:11:30,719 --> 01:11:32,960
algorithm

1821
01:11:32,960 --> 01:11:35,120
and so in contrast to the strong sprp

1822
01:11:35,120 --> 01:11:36,480
notion for example where the university

1823
01:11:36,480 --> 01:11:38,560
has full access to both and prp where

1824
01:11:38,560 --> 01:11:39,840
the adversary has only access to the

1825
01:11:39,840 --> 01:11:42,320
inside frame algorithm

1826
01:11:42,320 --> 01:11:44,239
okay so here's the definition in more

1827
01:11:44,239 --> 01:11:45,600
detail

1828
01:11:45,600 --> 01:11:47,600
we give the adversary

1829
01:11:47,600 --> 01:11:48,960
oracle access to the in ciphering

1830
01:11:48,960 --> 01:11:51,360
algorithm and deciphering algorithm

1831
01:11:51,360 --> 01:11:53,760
but now we impose two main restrictions

1832
01:11:53,760 --> 01:11:55,440
on what the adversary can query to

1833
01:11:55,440 --> 01:11:57,040
decipher in the rocket

1834
01:11:57,040 --> 01:11:59,600
the first restriction is that it cannot

1835
01:11:59,600 --> 01:12:02,239
make a deciphering query using the left

1836
01:12:02,239 --> 01:12:04,080
value that was previously returned by

1837
01:12:04,080 --> 01:12:07,440
the enciphering oracle

1838
01:12:07,440 --> 01:12:09,199
and this holds no matter what the other

1839
01:12:09,199 --> 01:12:12,800
values of t and y are are

1840
01:12:12,800 --> 01:12:14,640
and the second restriction is that the

1841
01:12:14,640 --> 01:12:17,600
adversary cannot repeat values of yl

1842
01:12:17,600 --> 01:12:21,440
across different deciphering queries

1843
01:12:21,440 --> 01:12:24,320
so note that these are rather

1844
01:12:24,320 --> 01:12:26,320
limiting restrictions that we make on

1845
01:12:26,320 --> 01:12:28,000
the adversaries queries

1846
01:12:28,000 --> 01:12:30,000
and are not just there to avoid trivial

1847
01:12:30,000 --> 01:12:33,600
win conditions these are much stricter

1848
01:12:33,600 --> 01:12:35,440
so then to relax a bit this notion we

1849
01:12:35,440 --> 01:12:37,280
introduce a second way that the

1850
01:12:37,280 --> 01:12:38,960
adversary can interact

1851
01:12:38,960 --> 01:12:41,040
with the deciphering algorithm

1852
01:12:41,040 --> 01:12:43,920
and this is via a guess oracle

1853
01:12:43,920 --> 01:12:45,440
and the guest oracle takes all the

1854
01:12:45,440 --> 01:12:47,360
inputs takes us input all the inputs

1855
01:12:47,360 --> 01:12:49,840
required to decipher and algorithm plus

1856
01:12:49,840 --> 01:12:52,880
an initial input xl prime which serves

1857
01:12:52,880 --> 01:12:56,159
as a guess of the output of the left

1858
01:12:56,159 --> 01:12:58,800
value of the deciphering algorithm

1859
01:12:58,800 --> 01:13:00,640
and the oracle returns true or false

1860
01:13:00,640 --> 01:13:02,000
indicating whether this guess was

1861
01:13:02,000 --> 01:13:04,640
correct or not

1862
01:13:04,640 --> 01:13:06,719
so that's the real world then when we

1863
01:13:06,719 --> 01:13:11,199
change sorry and so to recap

1864
01:13:11,199 --> 01:13:12,640
the ciphering can be accessed by the

1865
01:13:12,640 --> 01:13:14,719
adversary and two separate ways we have

1866
01:13:14,719 --> 01:13:17,280
the decipher and gorakil on the one hand

1867
01:13:17,280 --> 01:13:19,280
which has restricted queries but returns

1868
01:13:19,280 --> 01:13:21,040
the full output

1869
01:13:21,040 --> 01:13:23,520
and then we have the guess oracle which

1870
01:13:23,520 --> 01:13:25,440
has unrestricted queries but returns

1871
01:13:25,440 --> 01:13:29,199
only a single bit of information

1872
01:13:29,280 --> 01:13:30,960
and this gives two ways of interacting

1873
01:13:30,960 --> 01:13:33,520
with the deciphering algorithm then

1874
01:13:33,520 --> 01:13:35,520
that's the real world so in the ideal

1875
01:13:35,520 --> 01:13:37,600
world we simply change the

1876
01:13:37,600 --> 01:13:39,440
tweakable cipher construction to an

1877
01:13:39,440 --> 01:13:42,400
ideal cipher one

1878
01:13:43,199 --> 01:13:44,640
and

1879
01:13:44,640 --> 01:13:47,360
now for an ideal cipher pie

1880
01:13:47,360 --> 01:13:50,719
and we noted that the adversary can only

1881
01:13:50,719 --> 01:13:52,960
make a successful guess query

1882
01:13:52,960 --> 01:13:54,560
uh with negative probability so we

1883
01:13:54,560 --> 01:13:56,320
simplify the definition a bit further by

1884
01:13:56,320 --> 01:13:57,679
replacing

1885
01:13:57,679 --> 01:14:00,239
this guess oracle with a dummy oracle

1886
01:14:00,239 --> 01:14:01,840
that always returns false no matter what

1887
01:14:01,840 --> 01:14:03,280
the input is

1888
01:14:03,280 --> 01:14:04,880
and in order to make this change now we

1889
01:14:04,880 --> 01:14:06,719
have to impose some mild restrictions on

1890
01:14:06,719 --> 01:14:08,800
what can be created a gas circle but

1891
01:14:08,800 --> 01:14:10,320
these are just there to avoid reviewing

1892
01:14:10,320 --> 01:14:12,320
conditions and don't significantly

1893
01:14:12,320 --> 01:14:13,360
weaken

1894
01:14:13,360 --> 01:14:15,520
the notion

1895
01:14:15,520 --> 01:14:18,800
so that's the formal definition

1896
01:14:19,360 --> 01:14:20,880
a few notes about the definition so the

1897
01:14:20,880 --> 01:14:22,320
term rugged is meant to reflect the

1898
01:14:22,320 --> 01:14:23,840
intermediate overall security of the

1899
01:14:23,840 --> 01:14:25,840
primitive but more importantly the

1900
01:14:25,840 --> 01:14:28,080
asymmetry between the security that is

1901
01:14:28,080 --> 01:14:29,760
required from the ciphering algorithm

1902
01:14:29,760 --> 01:14:31,520
and the deciphering algorithm so the

1903
01:14:31,520 --> 01:14:32,960
cyphering algorithm is now required to

1904
01:14:32,960 --> 01:14:34,719
be more pseudorandom than the

1905
01:14:34,719 --> 01:14:37,520
deciphering algorithm

1906
01:14:37,520 --> 01:14:38,960
and the second point to note is that

1907
01:14:38,960 --> 01:14:41,120
this notion is mainly intended for

1908
01:14:41,120 --> 01:14:43,440
variable length ciphers in the context

1909
01:14:43,440 --> 01:14:44,320
of the

1910
01:14:44,320 --> 01:14:46,800
encoding and cipher paradigm

1911
01:14:46,800 --> 01:14:48,719
and essentially meaning that

1912
01:14:48,719 --> 01:14:50,159
we're thinking of variable lengths we

1913
01:14:50,159 --> 01:14:52,560
can decipher us from which we can easily

1914
01:14:52,560 --> 01:14:53,920
realize

1915
01:14:53,920 --> 01:14:56,159
aed schemes with a variety of security

1916
01:14:56,159 --> 01:14:59,120
properties and is not very meaningful in

1917
01:14:59,120 --> 01:15:00,640
the context for example of tweakable

1918
01:15:00,640 --> 01:15:02,000
block ciphers

1919
01:15:02,000 --> 01:15:04,239
right

1920
01:15:04,719 --> 01:15:06,800
and the definition itself might seem a

1921
01:15:06,800 --> 01:15:09,520
bit artificial but it is motivated by

1922
01:15:09,520 --> 01:15:12,239
the encoder and cipher paradigm and

1923
01:15:12,239 --> 01:15:14,560
certain features that are common

1924
01:15:14,560 --> 01:15:16,320
to various constructions of variable

1925
01:15:16,320 --> 01:15:18,400
length ciphers so with these in mind

1926
01:15:18,400 --> 01:15:20,560
then the definition is a rather natural

1927
01:15:20,560 --> 01:15:22,719
one

1928
01:15:22,960 --> 01:15:24,400
so let's see now we can how we can

1929
01:15:24,400 --> 01:15:26,800
construct rugged prps

1930
01:15:26,800 --> 01:15:28,880
our starting point here is the piv

1931
01:15:28,880 --> 01:15:30,640
construction or protected iv

1932
01:15:30,640 --> 01:15:33,120
construction by shrimp and tereshima

1933
01:15:33,120 --> 01:15:35,920
and this construction builds a tweakable

1934
01:15:35,920 --> 01:15:38,159
cipher construction that achieves the

1935
01:15:38,159 --> 01:15:41,120
stronger notion of sprp security

1936
01:15:41,120 --> 01:15:43,679
it consists of three layers so

1937
01:15:43,679 --> 01:15:45,600
the first layer and the third layer

1938
01:15:45,600 --> 01:15:47,440
consist of a fixed input length

1939
01:15:47,440 --> 01:15:50,080
tweakable cipher with a variable length

1940
01:15:50,080 --> 01:15:52,400
tweak size

1941
01:15:52,400 --> 01:15:55,360
and the middle layer consists simply of

1942
01:15:55,360 --> 01:15:58,239
a variable output length prf that is

1943
01:15:58,239 --> 01:16:00,400
typically associated with a sunblock

1944
01:16:00,400 --> 01:16:03,360
ciphering counter mode

1945
01:16:03,440 --> 01:16:04,840
and then our

1946
01:16:04,840 --> 01:16:06,719
construction uh which we call the

1947
01:16:06,719 --> 01:16:08,800
unilaterally reported iv is simply

1948
01:16:08,800 --> 01:16:10,239
obtained from this construction by

1949
01:16:10,239 --> 01:16:12,640
dropping the last round

1950
01:16:12,640 --> 01:16:13,679
and

1951
01:16:13,679 --> 01:16:15,360
this construction was already considered

1952
01:16:15,360 --> 01:16:17,840
by shrimp and tarashima but it was shown

1953
01:16:17,840 --> 01:16:19,280
to be

1954
01:16:19,280 --> 01:16:21,679
not sufficient for spr security and

1955
01:16:21,679 --> 01:16:23,840
hence it was dismissed but here we show

1956
01:16:23,840 --> 01:16:26,080
that it's enough for achieving rprp

1957
01:16:26,080 --> 01:16:28,719
security so it automatically gives a

1958
01:16:28,719 --> 01:16:31,199
separation showing that rprps are

1959
01:16:31,199 --> 01:16:35,559
strictly weaker than sprps

1960
01:16:35,840 --> 01:16:36,880
another nice feature of this

1961
01:16:36,880 --> 01:16:38,080
construction is that it can be

1962
01:16:38,080 --> 01:16:41,760
instantiated from gcm components

1963
01:16:41,760 --> 01:16:43,280
leading to a performance characteristic

1964
01:16:43,280 --> 01:16:46,800
that is very similar to gcm siv

1965
01:16:46,800 --> 01:16:49,199
and it is closely related to two other

1966
01:16:49,199 --> 01:16:51,679
constructions and one is called mini ctr

1967
01:16:51,679 --> 01:16:53,440
by minamatsu

1968
01:16:53,440 --> 01:16:56,000
and the other one is called gcm rap by

1969
01:16:56,000 --> 01:16:58,560
ashur dunkelman and luix from crypto

1970
01:16:58,560 --> 01:16:59,920
2017

1971
01:16:59,920 --> 01:17:03,679
and i'll highlight as we go along how um

1972
01:17:03,679 --> 01:17:05,520
this relates to these other two

1973
01:17:05,520 --> 01:17:07,920
constructions

1974
01:17:07,920 --> 01:17:10,080
okay so let's see now i can transform

1975
01:17:10,080 --> 01:17:13,280
rugged prps into aed

1976
01:17:13,280 --> 01:17:15,040
and the problem of transforming a

1977
01:17:15,040 --> 01:17:16,560
variable-length cipher into an

1978
01:17:16,560 --> 01:17:18,239
authenticated encryption scheme is a

1979
01:17:18,239 --> 01:17:20,560
classic one that dates back to 2000 and

1980
01:17:20,560 --> 01:17:22,880
was studied by belarian roadway

1981
01:17:22,880 --> 01:17:24,480
and was then revised in the work of

1982
01:17:24,480 --> 01:17:26,800
shrimp and rashman

1983
01:17:26,800 --> 01:17:29,280
and however both of these works require

1984
01:17:29,280 --> 01:17:31,360
the decipher satisfy the stronger notion

1985
01:17:31,360 --> 01:17:32,000
of

1986
01:17:32,000 --> 01:17:34,400
sprp security and in this work we

1987
01:17:34,400 --> 01:17:36,480
revisited this paradigm but we'll make

1988
01:17:36,480 --> 01:17:38,320
do with the quicker notion of rugged

1989
01:17:38,320 --> 01:17:40,880
prps

1990
01:17:41,679 --> 01:17:42,560
so

1991
01:17:42,560 --> 01:17:46,320
our first construction sorry um

1992
01:17:49,520 --> 01:17:52,560
and our first construction is the etd

1993
01:17:52,560 --> 01:17:54,640
transform

1994
01:17:54,640 --> 01:17:56,080
so

1995
01:17:56,080 --> 01:17:57,360
to transform

1996
01:17:57,360 --> 01:17:58,960
the cipher into

1997
01:17:58,960 --> 01:18:00,400
an aed scheme

1998
01:18:00,400 --> 01:18:02,480
we encode the nonce and the header into

1999
01:18:02,480 --> 01:18:04,000
the tweak

2000
01:18:04,000 --> 01:18:06,239
we place the message into the right part

2001
01:18:06,239 --> 01:18:08,400
of the input and we

2002
01:18:08,400 --> 01:18:10,400
put some redundant bits into the left

2003
01:18:10,400 --> 01:18:12,480
part of the input

2004
01:18:12,480 --> 01:18:15,440
in this case shown as all zeros

2005
01:18:15,440 --> 01:18:16,320
and then

2006
01:18:16,320 --> 01:18:17,920
decryption works by applying the

2007
01:18:17,920 --> 01:18:20,800
deciphering algorithm

2008
01:18:20,800 --> 01:18:23,600
in a natural way and checking whether

2009
01:18:23,600 --> 01:18:26,159
the left output is equal to the all zero

2010
01:18:26,159 --> 01:18:28,880
string and if that's the case the

2011
01:18:28,880 --> 01:18:31,199
message is released as the output

2012
01:18:31,199 --> 01:18:32,320
otherwise

2013
01:18:32,320 --> 01:18:36,080
decryption returns an error message

2014
01:18:37,920 --> 01:18:39,679
so in the paper we define it a bit more

2015
01:18:39,679 --> 01:18:41,040
generally but here we simplify a little

2016
01:18:41,040 --> 01:18:43,760
bit for a cleaning exposition

2017
01:18:43,760 --> 01:18:45,280
and our main result here our first

2018
01:18:45,280 --> 01:18:47,920
result is that if the cipher is an rprp

2019
01:18:47,920 --> 01:18:50,400
secure cipher then this construction not

2020
01:18:50,400 --> 01:18:52,640
only yields a secure av scheme but also

2021
01:18:52,640 --> 01:18:54,400
one that is secure against

2022
01:18:54,400 --> 01:18:55,679
misuse

2023
01:18:55,679 --> 01:18:58,800
that is repeating nonsense

2024
01:18:58,800 --> 01:19:01,199
and however the asymmetry in rugged p

2025
01:19:01,199 --> 01:19:03,040
and derivative prp definition prompts us

2026
01:19:03,040 --> 01:19:04,719
to consider alternative construction

2027
01:19:04,719 --> 01:19:07,040
where we now use deciphering to encrypt

2028
01:19:07,040 --> 01:19:09,840
and then ciphering to decrypt

2029
01:19:09,840 --> 01:19:12,080
and now and remember that the definition

2030
01:19:12,080 --> 01:19:14,480
required for example that the left input

2031
01:19:14,480 --> 01:19:16,800
to deciphering algorithm never repeats

2032
01:19:16,800 --> 01:19:18,800
so this becomes a natural candidate for

2033
01:19:18,800 --> 01:19:20,400
the nonce

2034
01:19:20,400 --> 01:19:22,560
and since we're using the left part for

2035
01:19:22,560 --> 01:19:24,480
the nonce then we have to place the

2036
01:19:24,480 --> 01:19:27,280
redundant bits in the right part and in

2037
01:19:27,280 --> 01:19:28,960
this construction because we're using

2038
01:19:28,960 --> 01:19:31,040
again ciphering to decrypt it turns out

2039
01:19:31,040 --> 01:19:32,880
to be okay and yields a secure

2040
01:19:32,880 --> 01:19:34,800
construction but would not have been

2041
01:19:34,800 --> 01:19:38,400
okay in the previous construction

2042
01:19:38,719 --> 01:19:40,320
so then here decryption proceeds in a

2043
01:19:40,320 --> 01:19:41,920
similar way we apply in ciphering to

2044
01:19:41,920 --> 01:19:43,360
decrypt and we check that the redundant

2045
01:19:43,360 --> 01:19:46,400
bits are equal to zero

2046
01:19:46,400 --> 01:19:49,040
and here the result is that again if the

2047
01:19:49,040 --> 01:19:51,920
scheme of the cipher is an rprp

2048
01:19:51,920 --> 01:19:53,679
then this construction yields an once

2049
01:19:53,679 --> 01:19:57,120
hiding aad scheme that is secure under

2050
01:19:57,120 --> 01:19:59,199
the release of a verified plaintext

2051
01:19:59,199 --> 01:20:02,480
or group a security

2052
01:20:03,360 --> 01:20:05,090
and and when the

2053
01:20:05,090 --> 01:20:06,639
[Music]

2054
01:20:06,639 --> 01:20:09,719
tweakable cipher is instantiated with

2055
01:20:09,719 --> 01:20:11,360
gcmuiv

2056
01:20:11,360 --> 01:20:13,679
this construction corresponds to the gcm

2057
01:20:13,679 --> 01:20:16,800
rap construction by

2058
01:20:16,840 --> 01:20:19,440
ads17 we can instantiate this

2059
01:20:19,440 --> 01:20:21,280
construction a bit differently and

2060
01:20:21,280 --> 01:20:23,600
obtain

2061
01:20:23,600 --> 01:20:26,080
a scheme that yields a nonce

2062
01:20:26,080 --> 01:20:27,520
based scheme with more complex

2063
01:20:27,520 --> 01:20:28,880
ciphertext

2064
01:20:28,880 --> 01:20:30,320
so essentially

2065
01:20:30,320 --> 01:20:32,320
we don't really need the extra redundant

2066
01:20:32,320 --> 01:20:33,600
bits

2067
01:20:33,600 --> 01:20:36,239
we can simply use the nonce itself as

2068
01:20:36,239 --> 01:20:37,840
the redundant bits

2069
01:20:37,840 --> 01:20:39,760
so we can get rid of the extra zeros

2070
01:20:39,760 --> 01:20:42,400
that we're appending in the message part

2071
01:20:42,400 --> 01:20:45,199
and instead during decryption

2072
01:20:45,199 --> 01:20:46,880
check that the provided non-subscription

2073
01:20:46,880 --> 01:20:49,040
algorithm is equal to the recovered

2074
01:20:49,040 --> 01:20:51,600
nonsense prime

2075
01:20:51,600 --> 01:20:53,760
and this has a more complex ciphertext

2076
01:20:53,760 --> 01:20:57,440
when compared to gcmrop for example

2077
01:20:58,639 --> 01:21:00,239
and again we have a similar result here

2078
01:21:00,239 --> 01:21:02,239
that if the underlying ciphers are prp

2079
01:21:02,239 --> 01:21:04,800
secure then this gives a an aed scheme

2080
01:21:04,800 --> 01:21:07,840
that is rupert is a queue

2081
01:21:08,320 --> 01:21:09,440
okay so

2082
01:21:09,440 --> 01:21:11,360
let's now get into the

2083
01:21:11,360 --> 01:21:14,560
new variant of aed called noncity ad

2084
01:21:14,560 --> 01:21:16,719
and i'll start by motivating the

2085
01:21:16,719 --> 01:21:18,800
primitive with a construction and then

2086
01:21:18,800 --> 01:21:20,480
i'll define later

2087
01:21:20,480 --> 01:21:23,440
more formally what the primitive is

2088
01:21:23,440 --> 01:21:25,360
so essentially the last trick we saw of

2089
01:21:25,360 --> 01:21:27,600
using the nonce for authentication can

2090
01:21:27,600 --> 01:21:28,800
also be applied in the first

2091
01:21:28,800 --> 01:21:29,920
construction that we saw the

2092
01:21:29,920 --> 01:21:32,239
deconstruction

2093
01:21:32,239 --> 01:21:33,760
and

2094
01:21:33,760 --> 01:21:35,040
this would indeed

2095
01:21:35,040 --> 01:21:36,560
when instantiated again with the uiv

2096
01:21:36,560 --> 01:21:38,400
construction this would yield something

2097
01:21:38,400 --> 01:21:40,000
that's quite close to the municipr

2098
01:21:40,000 --> 01:21:43,120
construction by minamatsu

2099
01:21:43,120 --> 01:21:44,639
and however we can generalize this

2100
01:21:44,639 --> 01:21:46,800
construction further and essentially

2101
01:21:46,800 --> 01:21:49,520
replace this equality check between the

2102
01:21:49,520 --> 01:21:52,880
nonsense with a set membership test

2103
01:21:52,880 --> 01:21:54,239
so

2104
01:21:54,239 --> 01:21:56,639
if this instead of checking for equality

2105
01:21:56,639 --> 01:21:57,920
we check that the recovered nonce and

2106
01:21:57,920 --> 01:22:02,239
prime is within some set w of nonsense

2107
01:22:02,239 --> 01:22:04,880
and if this says if the size of the set

2108
01:22:04,880 --> 01:22:06,080
is limited

2109
01:22:06,080 --> 01:22:08,000
then this construction would still give

2110
01:22:08,000 --> 01:22:08,840
us

2111
01:22:08,840 --> 01:22:12,480
adequate integrity

2112
01:22:15,199 --> 01:22:16,880
and this construction is what we call

2113
01:22:16,880 --> 01:22:19,040
the awn for authenticate with nonce

2114
01:22:19,040 --> 01:22:20,400
transform

2115
01:22:20,400 --> 01:22:23,440
however it does not yield a standard aad

2116
01:22:23,440 --> 01:22:26,159
scheme it yields something that we call

2117
01:22:26,159 --> 01:22:28,960
non-set aed

2118
01:22:29,199 --> 01:22:31,199
and again here we have this analog

2119
01:22:31,199 --> 01:22:33,280
analogous result that when the

2120
01:22:33,280 --> 01:22:35,920
underlying cipher is our php secure this

2121
01:22:35,920 --> 01:22:37,760
yields announced aad scheme that is

2122
01:22:37,760 --> 01:22:39,280
misused resistant

2123
01:22:39,280 --> 01:22:41,199
but let's now define more formally what

2124
01:22:41,199 --> 01:22:44,320
we what an onset a this game is

2125
01:22:44,320 --> 01:22:46,480
so synthetically the main change is in

2126
01:22:46,480 --> 01:22:48,560
the decryption algorithm

2127
01:22:48,560 --> 01:22:50,400
which now takes instead of a single

2128
01:22:50,400 --> 01:22:53,120
nonstick a set of nonsense w

2129
01:22:53,120 --> 01:22:54,800
and returns the pairs of a pair of

2130
01:22:54,800 --> 01:22:57,040
strings and prime and then prime if the

2131
01:22:57,040 --> 01:22:58,639
encryption succeeds or if the decryption

2132
01:22:58,639 --> 01:23:00,080
fails it returns

2133
01:23:00,080 --> 01:23:02,239
a set of error messages

2134
01:23:02,239 --> 01:23:03,440
and it is required that whenever

2135
01:23:03,440 --> 01:23:06,000
decryption succeeds the returned nonce

2136
01:23:06,000 --> 01:23:08,400
and prime is within

2137
01:23:08,400 --> 01:23:09,199
is

2138
01:23:09,199 --> 01:23:12,239
as included in the set w

2139
01:23:12,239 --> 01:23:14,480
so at a high level here what's happening

2140
01:23:14,480 --> 01:23:15,440
is that

2141
01:23:15,440 --> 01:23:17,280
the set of nonsense indicates to the

2142
01:23:17,280 --> 01:23:18,880
decryption algorithm

2143
01:23:18,880 --> 01:23:20,960
which ciphertext can be accepted at this

2144
01:23:20,960 --> 01:23:22,639
point in time

2145
01:23:22,639 --> 01:23:24,000
right

2146
01:23:24,000 --> 01:23:25,920
and in return the decryption algorithm

2147
01:23:25,920 --> 01:23:27,760
returns the nonce indicating which of

2148
01:23:27,760 --> 01:23:30,000
these nonce is in the set was associated

2149
01:23:30,000 --> 01:23:33,880
successfully to that ciphertext

2150
01:23:34,400 --> 01:23:36,800
then we need to adapt correctness as

2151
01:23:36,800 --> 01:23:37,850
follows so

2152
01:23:37,850 --> 01:23:39,120
[Music]

2153
01:23:39,120 --> 01:23:41,600
correctness now guarantees that um

2154
01:23:41,600 --> 01:23:43,760
whenever this nonsense includes the

2155
01:23:43,760 --> 01:23:45,199
nonce that was used to produce the

2156
01:23:45,199 --> 01:23:46,639
ciphertext

2157
01:23:46,639 --> 01:23:48,400
decryption must recover the urgent

2158
01:23:48,400 --> 01:23:52,480
message and the original nouns

2159
01:23:52,480 --> 01:23:54,800
and in terms of security uh

2160
01:23:54,800 --> 01:23:55,920
security can be translated in a

2161
01:23:55,920 --> 01:23:57,679
straightforward manner

2162
01:23:57,679 --> 01:23:59,760
we only need to adapt the prohibited

2163
01:23:59,760 --> 01:24:01,520
queries that the adversary

2164
01:24:01,520 --> 01:24:03,840
is prohibited from making

2165
01:24:03,840 --> 01:24:06,400
so essentially um the adversary cannot

2166
01:24:06,400 --> 01:24:08,960
make queries of the following form um

2167
01:24:08,960 --> 01:24:11,920
for a ciphertext c and an onset w

2168
01:24:11,920 --> 01:24:13,679
where w contains the nodes that was

2169
01:24:13,679 --> 01:24:15,840
produ that was used to produce that

2170
01:24:15,840 --> 01:24:18,400
cipher text

2171
01:24:18,560 --> 01:24:21,600
using the encryption article

2172
01:24:21,600 --> 01:24:23,120
okay so why is this primitive

2173
01:24:23,120 --> 01:24:24,239
interesting

2174
01:24:24,239 --> 01:24:26,000
it isn't naturally primitive and to

2175
01:24:26,000 --> 01:24:28,239
consider in the context of orders in

2176
01:24:28,239 --> 01:24:31,440
channels such as quick and datagram tls

2177
01:24:31,440 --> 01:24:34,960
which employ window mechanisms

2178
01:24:35,040 --> 01:24:36,320
and

2179
01:24:36,320 --> 01:24:38,159
we'll see that nonset aad serves as a

2180
01:24:38,159 --> 01:24:39,760
stepping stone from which a variety of

2181
01:24:39,760 --> 01:24:43,440
secure channels can be easily realized

2182
01:24:43,440 --> 01:24:45,600
and alternatively and there's under

2183
01:24:45,600 --> 01:24:47,600
construction of how to construct nozzle

2184
01:24:47,600 --> 01:24:49,920
aad it can be realized in a black box

2185
01:24:49,920 --> 01:24:53,040
manner using uh or in a generic way

2186
01:24:53,040 --> 01:24:55,360
using noise hiding aad

2187
01:24:55,360 --> 01:24:57,600
by a straightforward generic transform

2188
01:24:57,600 --> 01:24:59,360
however the construction we've seen the

2189
01:24:59,360 --> 01:25:02,320
awn construction has the advantage that

2190
01:25:02,320 --> 01:25:04,400
it yields more compact cipher to extend

2191
01:25:04,400 --> 01:25:06,239
this generic transform

2192
01:25:06,239 --> 01:25:09,440
using those hiding aad

2193
01:25:10,320 --> 01:25:12,560
okay so let's see now how this

2194
01:25:12,560 --> 01:25:13,920
has applications to order the in

2195
01:25:13,920 --> 01:25:15,600
channels

2196
01:25:15,600 --> 01:25:16,320
so

2197
01:25:16,320 --> 01:25:19,199
by order resilient channels we mean

2198
01:25:19,199 --> 01:25:22,719
protocols like quick entity ls that try

2199
01:25:22,719 --> 01:25:24,800
to realize secure channels over

2200
01:25:24,800 --> 01:25:27,520
unreliable transports like udp

2201
01:25:27,520 --> 01:25:28,880
and in particular because of that they

2202
01:25:28,880 --> 01:25:30,880
need to be able to handle ciphertext

2203
01:25:30,880 --> 01:25:33,920
that are delivered out of order

2204
01:25:33,920 --> 01:25:35,520
and in general we're constructing such

2205
01:25:35,520 --> 01:25:36,639
channels

2206
01:25:36,639 --> 01:25:38,239
and there are several possibilities for

2207
01:25:38,239 --> 01:25:40,400
how to handle reorderings replays

2208
01:25:40,400 --> 01:25:42,080
modifications and deletions of

2209
01:25:42,080 --> 01:25:43,280
ciphertext

2210
01:25:43,280 --> 01:25:47,280
and how much of which can be tolerated

2211
01:25:47,280 --> 01:25:50,080
and typical constructions employ windows

2212
01:25:50,080 --> 01:25:52,320
one or more window mechanisms which

2213
01:25:52,320 --> 01:25:55,520
typically add to the complexity of the

2214
01:25:55,520 --> 01:25:57,040
channel description

2215
01:25:57,040 --> 01:25:58,480
which makes them hard to analyze and

2216
01:25:58,480 --> 01:26:00,560
understand

2217
01:26:00,560 --> 01:26:02,320
in general it is often unclear whether

2218
01:26:02,320 --> 01:26:04,239
these indigenous mechanisms how they

2219
01:26:04,239 --> 01:26:07,120
interact with the ad scheme and what is

2220
01:26:07,120 --> 01:26:08,880
the resulting overall security of the

2221
01:26:08,880 --> 01:26:11,199
channel

2222
01:26:11,600 --> 01:26:13,520
so we said that there are a number of

2223
01:26:13,520 --> 01:26:15,600
choices that one can make on the

2224
01:26:15,600 --> 01:26:18,159
functionality of such a channel

2225
01:26:18,159 --> 01:26:20,000
and mathematically these are normally

2226
01:26:20,000 --> 01:26:21,440
formalized via something called a

2227
01:26:21,440 --> 01:26:23,840
support predicate and the support

2228
01:26:23,840 --> 01:26:26,080
predicate takes three inputs it takes a

2229
01:26:26,080 --> 01:26:27,280
ciphertext

2230
01:26:27,280 --> 01:26:30,000
a list of the ciphertexts that were sent

2231
01:26:30,000 --> 01:26:32,080
until this point and a list of the

2232
01:26:32,080 --> 01:26:34,000
ciphertexts that have been received and

2233
01:26:34,000 --> 01:26:35,840
whether they have been accepted or uh

2234
01:26:35,840 --> 01:26:37,120
rejected

2235
01:26:37,120 --> 01:26:38,719
the support predicate determines whether

2236
01:26:38,719 --> 01:26:40,400
this cipher text should be accepted or

2237
01:26:40,400 --> 01:26:42,080
not

2238
01:26:42,080 --> 01:26:44,320
and the support predicate was developed

2239
01:26:44,320 --> 01:26:47,360
in the works of um bachelor 19 and

2240
01:26:47,360 --> 01:26:49,760
fishland gunter and janssen

2241
01:26:49,760 --> 01:26:51,679
as a generalization of this silencing

2242
01:26:51,679 --> 01:26:55,760
approach by road away and junk from 2018

2243
01:26:55,760 --> 01:26:58,639
and the support predicates permeates all

2244
01:26:58,639 --> 01:27:00,560
aspects of the secure channel

2245
01:27:00,560 --> 01:27:02,320
from correctness to security to the

2246
01:27:02,320 --> 01:27:03,760
notion of robustness that was put

2247
01:27:03,760 --> 01:27:07,239
forward by fgj20

2248
01:27:07,360 --> 01:27:09,760
so our main contribution here is uh the

2249
01:27:09,760 --> 01:27:12,400
following generic transform uh for

2250
01:27:12,400 --> 01:27:14,159
building

2251
01:27:14,159 --> 01:27:16,800
a order resilient channel from any

2252
01:27:16,800 --> 01:27:19,679
noncity and this construction is generic

2253
01:27:19,679 --> 01:27:23,280
and universal in the sense that um

2254
01:27:23,280 --> 01:27:25,120
we can construct a channel

2255
01:27:25,120 --> 01:27:27,679
with any desired function that that we

2256
01:27:27,679 --> 01:27:29,760
require so essentially for any any

2257
01:27:29,760 --> 01:27:32,639
desired support predicate

2258
01:27:32,639 --> 01:27:34,800
so it consists of two main components

2259
01:27:34,800 --> 01:27:35,840
and

2260
01:27:35,840 --> 01:27:38,159
the first one is denoncity ad

2261
01:27:38,159 --> 01:27:41,120
and whose components are shown in blue

2262
01:27:41,120 --> 01:27:43,280
and the second building block is a what

2263
01:27:43,280 --> 01:27:45,920
we call the nonset processing scheme

2264
01:27:45,920 --> 01:27:48,239
whose components the components of which

2265
01:27:48,239 --> 01:27:49,840
are shown in red

2266
01:27:49,840 --> 01:27:50,639
so

2267
01:27:50,639 --> 01:27:52,159
this consists of a total of four

2268
01:27:52,159 --> 01:27:55,120
algorithms the first one is simply

2269
01:27:55,120 --> 01:27:57,120
a state individual initialization

2270
01:27:57,120 --> 01:27:58,880
algorithm

2271
01:27:58,880 --> 01:27:59,679
then

2272
01:27:59,679 --> 01:28:01,280
we have a non-subtract algorithm and

2273
01:28:01,280 --> 01:28:03,440
descend uh

2274
01:28:03,440 --> 01:28:05,600
from the sender side which takes the

2275
01:28:05,600 --> 01:28:08,239
sender states and returns an ablated

2276
01:28:08,239 --> 01:28:10,080
state together with the nonce that is

2277
01:28:10,080 --> 01:28:12,880
then fed to the encryption orchid at the

2278
01:28:12,880 --> 01:28:15,280
receiver side we have an onset policy

2279
01:28:15,280 --> 01:28:18,159
that given the current state extracts

2280
01:28:18,159 --> 01:28:20,320
a set of nonsense that are then fed to

2281
01:28:20,320 --> 01:28:22,159
the decryption algorithm

2282
01:28:22,159 --> 01:28:24,239
and the decryption succeeds then we call

2283
01:28:24,239 --> 01:28:26,480
the state the state update algorithm is

2284
01:28:26,480 --> 01:28:29,199
called on the nonce that is returned

2285
01:28:29,199 --> 01:28:30,960
by the decryption algorithm

2286
01:28:30,960 --> 01:28:32,960
and the current state

2287
01:28:32,960 --> 01:28:35,520
and this updates the state and also

2288
01:28:35,520 --> 01:28:38,480
returns a message number indicating the

2289
01:28:38,480 --> 01:28:41,520
position of the recovered message within

2290
01:28:41,520 --> 01:28:43,120
the current sequence of messages that

2291
01:28:43,120 --> 01:28:45,679
they received

2292
01:28:46,400 --> 01:28:48,000
so

2293
01:28:48,000 --> 01:28:50,239
we proved that this general construction

2294
01:28:50,239 --> 01:28:52,880
is correct robust and secure in a

2295
01:28:52,880 --> 01:28:54,880
generic way for any support predicted

2296
01:28:54,880 --> 01:28:57,360
that one defines

2297
01:28:57,360 --> 01:28:59,600
and what we require is that

2298
01:28:59,600 --> 01:29:01,760
the knowledge at aed scheme is secure

2299
01:29:01,760 --> 01:29:03,760
and that the non-set

2300
01:29:03,760 --> 01:29:06,000
processing scheme satisfy

2301
01:29:06,000 --> 01:29:07,679
a functionality property that we call

2302
01:29:07,679 --> 01:29:08,960
faithfulness

2303
01:29:08,960 --> 01:29:11,520
so at a high level um the support

2304
01:29:11,520 --> 01:29:12,639
predicate

2305
01:29:12,639 --> 01:29:14,560
is

2306
01:29:14,560 --> 01:29:16,639
is oblivious of the representation that

2307
01:29:16,639 --> 01:29:18,480
we use

2308
01:29:18,480 --> 01:29:20,960
for the cipher text in its symbols so in

2309
01:29:20,960 --> 01:29:23,199
particular we can use the nonsense to

2310
01:29:23,199 --> 01:29:25,360
identify the ciphertext and the inputs

2311
01:29:25,360 --> 01:29:26,960
to support predicate

2312
01:29:26,960 --> 01:29:29,040
and essentially the faithfulness

2313
01:29:29,040 --> 01:29:31,280
requirement says that the nonset

2314
01:29:31,280 --> 01:29:33,040
processing scheme

2315
01:29:33,040 --> 01:29:35,040
faithfully reproduces the support

2316
01:29:35,040 --> 01:29:37,760
predicate logic over the nonsense

2317
01:29:37,760 --> 01:29:39,040
so it's purely a functionality

2318
01:29:39,040 --> 01:29:40,480
requirement and there's no it's not a

2319
01:29:40,480 --> 01:29:42,719
security requirement

2320
01:29:42,719 --> 01:29:44,320
and the nice property of this

2321
01:29:44,320 --> 01:29:45,760
construction then is that the protocol

2322
01:29:45,760 --> 01:29:47,840
designer can simply tune the nonset

2323
01:29:47,840 --> 01:29:50,080
processing algorithms to obtain the

2324
01:29:50,080 --> 01:29:51,199
desired

2325
01:29:51,199 --> 01:29:52,960
functionality

2326
01:29:52,960 --> 01:29:55,440
and plug in their favorite non-set aed

2327
01:29:55,440 --> 01:29:56,560
scheme

2328
01:29:56,560 --> 01:29:58,800
and correctness security and robustness

2329
01:29:58,800 --> 01:30:02,239
will be automatically guaranteed

2330
01:30:04,000 --> 01:30:05,520
so to conclude

2331
01:30:05,520 --> 01:30:07,679
um we've introduced a

2332
01:30:07,679 --> 01:30:09,520
new notion of rugged prp that strikes a

2333
01:30:09,520 --> 01:30:10,960
new trade-off between security and

2334
01:30:10,960 --> 01:30:13,440
performance and in particular we have we

2335
01:30:13,440 --> 01:30:15,120
have used it to show that the encoder

2336
01:30:15,120 --> 01:30:17,760
and cypher paradigm can be made to work

2337
01:30:17,760 --> 01:30:19,520
with weaker notions than

2338
01:30:19,520 --> 01:30:22,320
strong prps

2339
01:30:22,960 --> 01:30:25,120
and with this abstraction we were also

2340
01:30:25,120 --> 01:30:27,120
able to provide a systematic exploration

2341
01:30:27,120 --> 01:30:28,639
of the different aed schemes and

2342
01:30:28,639 --> 01:30:30,080
nonsense aed schemes that can be

2343
01:30:30,080 --> 01:30:32,000
obtained from uiv

2344
01:30:32,000 --> 01:30:33,679
but now we can also look at alternative

2345
01:30:33,679 --> 01:30:35,760
rprp constructions and plug them into

2346
01:30:35,760 --> 01:30:38,080
these constructions and obtain new

2347
01:30:38,080 --> 01:30:42,400
aed schemes or nozzle aed schemes

2348
01:30:42,400 --> 01:30:44,639
and finally we think the nonset a the

2349
01:30:44,639 --> 01:30:46,800
abstraction is also useful because it

2350
01:30:46,800 --> 01:30:50,480
provides a clean boundary between

2351
01:30:50,480 --> 01:30:51,840
for understanding

2352
01:30:51,840 --> 01:30:53,760
orders in channels and this boundary

2353
01:30:53,760 --> 01:30:56,159
separates security that is mostly

2354
01:30:56,159 --> 01:30:58,800
provided by the nozzle aad and the

2355
01:30:58,800 --> 01:31:00,719
general functionality result which is

2356
01:31:00,719 --> 01:31:02,239
obtained from the unanswered processing

2357
01:31:02,239 --> 01:31:04,239
algorithms

2358
01:31:04,239 --> 01:31:06,320
so that concludes my talk and thank you

2359
01:31:06,320 --> 01:31:09,280
very much for your attention

2360
01:31:14,400 --> 01:31:16,719
all right uh any questions from the

2361
01:31:16,719 --> 01:31:19,040
audience

2362
01:31:20,719 --> 01:31:23,600
thanks a lot for the nice talk um

2363
01:31:23,600 --> 01:31:26,159
i i just one thing that i wondered is in

2364
01:31:26,159 --> 01:31:28,639
this separating construction so this is

2365
01:31:28,639 --> 01:31:30,320
a real world construction right that's

2366
01:31:30,320 --> 01:31:32,400
uh that's supposed to be used is that is

2367
01:31:32,400 --> 01:31:33,440
that correct

2368
01:31:33,440 --> 01:31:35,520
um the channel construction the the

2369
01:31:35,520 --> 01:31:37,520
separating construction between rugged

2370
01:31:37,520 --> 01:31:40,880
prp and sprp

2371
01:31:40,880 --> 01:31:43,679
oh okay so the uiv construction right

2372
01:31:43,679 --> 01:31:44,400
yeah

2373
01:31:44,400 --> 01:31:46,320
is this something that's that's used in

2374
01:31:46,320 --> 01:31:47,760
the real world right

2375
01:31:47,760 --> 01:31:49,120
yeah yeah i mean

2376
01:31:49,120 --> 01:31:50,639
so in that case i was just wondering

2377
01:31:50,639 --> 01:31:52,800
like that it has these two components

2378
01:31:52,800 --> 01:31:54,159
the

2379
01:31:54,159 --> 01:31:56,840
variable output length prp

2380
01:31:56,840 --> 01:31:59,679
and the

2381
01:31:59,679 --> 01:32:01,600
cipher

2382
01:32:01,600 --> 01:32:04,080
right and you're removing you can remove

2383
01:32:04,080 --> 01:32:06,159
one instance of the cipher so like i was

2384
01:32:06,159 --> 01:32:08,080
just wondering about the

2385
01:32:08,080 --> 01:32:09,280
um

2386
01:32:09,280 --> 01:32:10,639
basically the influence of the two

2387
01:32:10,639 --> 01:32:12,639
components on the runtime like how much

2388
01:32:12,639 --> 01:32:15,360
runtime you can save with this

2389
01:32:15,360 --> 01:32:16,800
okay um

2390
01:32:16,800 --> 01:32:19,280
yeah that's a good question um

2391
01:32:19,280 --> 01:32:21,280
so in particular so for example one

2392
01:32:21,280 --> 01:32:24,000
thing that made it clear is that

2393
01:32:24,000 --> 01:32:26,400
when you have three layers you'd need at

2394
01:32:26,400 --> 01:32:29,280
least two passes over both and ciphering

2395
01:32:29,280 --> 01:32:31,440
and deciphering over the data

2396
01:32:31,440 --> 01:32:32,960
when you remove one

2397
01:32:32,960 --> 01:32:34,480
you will have a similar effect that you

2398
01:32:34,480 --> 01:32:37,040
have with gcms iv or siv essentially

2399
01:32:37,040 --> 01:32:38,639
that

2400
01:32:38,639 --> 01:32:40,480
and ciphering will require two passes

2401
01:32:40,480 --> 01:32:42,159
but the ciphering will require only one

2402
01:32:42,159 --> 01:32:44,320
pass because the two can be paralyzed

2403
01:32:44,320 --> 01:32:45,679
together

2404
01:32:45,679 --> 01:32:47,199
and here i mean

2405
01:32:47,199 --> 01:32:49,440
it's not just to realize the tweakable

2406
01:32:49,440 --> 01:32:50,960
cipher you normally

2407
01:32:50,960 --> 01:32:52,880
need a block cipher or a tweakable

2408
01:32:52,880 --> 01:32:55,120
cipher with a fixed tweak size but then

2409
01:32:55,120 --> 01:32:56,719
you need something else

2410
01:32:56,719 --> 01:32:58,800
to handle the variable length tweak and

2411
01:32:58,800 --> 01:33:00,080
that's normally like a universal hash

2412
01:33:00,080 --> 01:33:01,280
function

2413
01:33:01,280 --> 01:33:03,199
right so it's not just one block cipher

2414
01:33:03,199 --> 01:33:04,560
call it's also

2415
01:33:04,560 --> 01:33:07,760
um computing and that's tweakable scythe

2416
01:33:07,760 --> 01:33:09,520
at that sorry that universal hash which

2417
01:33:09,520 --> 01:33:13,199
in the case of gcm is normally g hash

2418
01:33:13,199 --> 01:33:16,000
okay so basically uh if i understand

2419
01:33:16,000 --> 01:33:18,320
correctly what you're saying um actually

2420
01:33:18,320 --> 01:33:20,480
the cypher is the more expensive thing

2421
01:33:20,480 --> 01:33:23,120
here and the variable output length prf

2422
01:33:23,120 --> 01:33:24,719
is the cheaper thing

2423
01:33:24,719 --> 01:33:26,320
the very bottom curve tends to be the

2424
01:33:26,320 --> 01:33:27,280
most

2425
01:33:27,280 --> 01:33:29,840
demanding

2426
01:33:30,880 --> 01:33:32,480
but

2427
01:33:32,480 --> 01:33:34,880
if you have like two tweakable ciphers

2428
01:33:34,880 --> 01:33:37,600
you can't parallelize them with the

2429
01:33:37,600 --> 01:33:40,320
variable prprf right so then you need to

2430
01:33:40,320 --> 01:33:44,080
leave another pass over the data right

2431
01:33:44,080 --> 01:33:46,320
thanks

2432
01:33:47,679 --> 01:33:48,800
all right

2433
01:33:48,800 --> 01:33:51,040
looks like there are no more questions

2434
01:33:51,040 --> 01:33:53,040
uh i think it's time for lunch but maybe

2435
01:33:53,040 --> 01:33:54,800
i mean i'll allow myself to make one

2436
01:33:54,800 --> 01:33:56,560
important announcement

2437
01:33:56,560 --> 01:33:58,239
you might be used from the past to the

2438
01:33:58,239 --> 01:34:00,320
fact that the conference ends now but

2439
01:34:00,320 --> 01:34:01,840
just a reminder we're not ending now

2440
01:34:01,840 --> 01:34:03,040
there are still there's still one

2441
01:34:03,040 --> 01:34:04,400
session after lunch

2442
01:34:04,400 --> 01:34:06,560
starting at 1 until 2 15 and that's

2443
01:34:06,560 --> 01:34:08,480
going to be the official last session of

2444
01:34:08,480 --> 01:34:10,239
the conference so hopefully many of you

2445
01:34:10,239 --> 01:34:14,040
will be there thank you

