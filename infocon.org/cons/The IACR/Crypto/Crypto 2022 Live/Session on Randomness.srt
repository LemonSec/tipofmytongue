1
00:00:00,080 --> 00:00:01,360
f in this session is on public

2
00:00:01,360 --> 00:00:02,879
randomness extraction with ephemeral

3
00:00:02,879 --> 00:00:04,640
roles and diversities corruption by

4
00:00:04,640 --> 00:00:07,520
jesper bush nielsen marcia bremsky and

5
00:00:07,520 --> 00:00:10,799
joao ribeiro

6
00:00:11,519 --> 00:00:14,080
all right yeah thanks christoph uh yeah

7
00:00:14,080 --> 00:00:16,560
so yeah welcome everyone um

8
00:00:16,560 --> 00:00:18,560
yeah so this was a really fun project uh

9
00:00:18,560 --> 00:00:20,800
with the esprit from mooroos and mache

10
00:00:20,800 --> 00:00:22,320
from cqt in the national university of

11
00:00:22,320 --> 00:00:23,439
singapore

12
00:00:23,439 --> 00:00:25,199
uh so let me just start you know the

13
00:00:25,199 --> 00:00:27,519
very basics uh so i mean everyone knows

14
00:00:27,519 --> 00:00:29,199
that you know cryptography fundamentally

15
00:00:29,199 --> 00:00:31,039
requires randomness and so it's

16
00:00:31,039 --> 00:00:32,880
important to think about how we generate

17
00:00:32,880 --> 00:00:34,480
these remnants like the type of remnants

18
00:00:34,480 --> 00:00:36,480
that we need and sometimes we even need

19
00:00:36,480 --> 00:00:38,079
you know types of remnants where you

20
00:00:38,079 --> 00:00:38,879
know

21
00:00:38,879 --> 00:00:40,719
several parties need to agree on a

22
00:00:40,719 --> 00:00:42,320
common string and they need to trust

23
00:00:42,320 --> 00:00:43,920
that this string is indeed

24
00:00:43,920 --> 00:00:45,840
uniformly random

25
00:00:45,840 --> 00:00:47,760
and one very

26
00:00:47,760 --> 00:00:49,360
obvious solution for this is to maybe

27
00:00:49,360 --> 00:00:51,120
assume that there's some trusted

28
00:00:51,120 --> 00:00:53,360
randomness generator in the sky that

29
00:00:53,360 --> 00:00:55,680
just samples random bits broadcast them

30
00:00:55,680 --> 00:00:58,000
to everyone and here of course then

31
00:00:58,000 --> 00:01:00,000
everyone agrees on the same bit and they

32
00:01:00,000 --> 00:01:01,359
all trust that this grid is indeed

33
00:01:01,359 --> 00:01:04,159
uniformly random uh this of course is a

34
00:01:04,159 --> 00:01:06,159
very strong assumption we'd like to

35
00:01:06,159 --> 00:01:08,400
weaken this so we usually replace this

36
00:01:08,400 --> 00:01:10,640
by some distributed protocol where

37
00:01:10,640 --> 00:01:11,920
parties interact with each other to

38
00:01:11,920 --> 00:01:14,080
agree on a common bit

39
00:01:14,080 --> 00:01:16,560
but it is also very complicated because

40
00:01:16,560 --> 00:01:17,360
uh

41
00:01:17,360 --> 00:01:18,960
most of the protocols for this task kind

42
00:01:18,960 --> 00:01:20,799
of require you to maintain a stateful

43
00:01:20,799 --> 00:01:22,880
environment for a very long time

44
00:01:22,880 --> 00:01:25,360
and uh this is challenging because for

45
00:01:25,360 --> 00:01:27,600
example there can be some power outage

46
00:01:27,600 --> 00:01:29,840
uh that maybe some computer goes offline

47
00:01:29,840 --> 00:01:31,759
or another computer decides to restart

48
00:01:31,759 --> 00:01:33,600
start installing some updates

49
00:01:33,600 --> 00:01:35,200
uh and it's even worse if there's an

50
00:01:35,200 --> 00:01:37,119
adversary involved because the diversity

51
00:01:37,119 --> 00:01:39,280
can maybe mount some targeted denial of

52
00:01:39,280 --> 00:01:41,280
service attacks

53
00:01:41,280 --> 00:01:44,479
and this motivated this notion of

54
00:01:44,479 --> 00:01:46,479
stateless multiparty computation where

55
00:01:46,479 --> 00:01:48,320
the goal is to design protocols that

56
00:01:48,320 --> 00:01:50,000
don't require parties to keep

57
00:01:50,000 --> 00:01:52,079
a state throughout the protocol

58
00:01:52,079 --> 00:01:54,399
and a very specific

59
00:01:54,399 --> 00:01:56,720
uh

60
00:01:57,520 --> 00:01:58,799
sorry

61
00:01:58,799 --> 00:02:01,840
let me just hide this

62
00:02:02,000 --> 00:02:04,719
all right yeah so one very recent model

63
00:02:04,719 --> 00:02:06,960
for this is uh what's called yozo so you

64
00:02:06,960 --> 00:02:08,959
only speak once and this is going to be

65
00:02:08,959 --> 00:02:11,920
also the focus of our work

66
00:02:11,920 --> 00:02:13,760
uh and yoso so it's a model for

67
00:02:13,760 --> 00:02:15,280
stateless npc

68
00:02:15,280 --> 00:02:17,120
and protocols here are composed of a

69
00:02:17,120 --> 00:02:19,120
series of roles

70
00:02:19,120 --> 00:02:21,680
that are activated in sequence and the

71
00:02:21,680 --> 00:02:23,440
way i think we should think about this

72
00:02:23,440 --> 00:02:25,760
at a high level is that there is a large

73
00:02:25,760 --> 00:02:27,360
ground set of parties

74
00:02:27,360 --> 00:02:29,440
and there is a role selection mechanism

75
00:02:29,440 --> 00:02:31,680
that

76
00:02:32,080 --> 00:02:34,560
that picks a party uh to execute a

77
00:02:34,560 --> 00:02:37,360
certain role and executing a role

78
00:02:37,360 --> 00:02:39,599
basically means that you can broadcast a

79
00:02:39,599 --> 00:02:41,360
public value and you can send private

80
00:02:41,360 --> 00:02:44,160
messages to future roles

81
00:02:44,160 --> 00:02:47,200
and after the party executes this rule

82
00:02:47,200 --> 00:02:48,959
it can go offline forever it could blow

83
00:02:48,959 --> 00:02:50,959
itself up and not never speak again and

84
00:02:50,959 --> 00:02:52,239
that's perfectly fine because parties

85
00:02:52,239 --> 00:02:53,840
don't have to keep state

86
00:02:53,840 --> 00:02:55,360
so for the second role you know the

87
00:02:55,360 --> 00:02:57,040
selection mechanism picks up our party

88
00:02:57,040 --> 00:02:59,599
this party executes uh the second role

89
00:02:59,599 --> 00:03:01,040
broadcast a public message sends a

90
00:03:01,040 --> 00:03:02,959
message to the future

91
00:03:02,959 --> 00:03:05,280
and so on

92
00:03:05,280 --> 00:03:08,720
right and usually uh what what we think

93
00:03:08,720 --> 00:03:10,319
of is that this part with the role

94
00:03:10,319 --> 00:03:11,840
selection mechanism this large ground

95
00:03:11,840 --> 00:03:14,640
set of parties is abstracted away

96
00:03:14,640 --> 00:03:17,120
uh and in original work we

97
00:03:17,120 --> 00:03:18,879
it was just assumed that you know this

98
00:03:18,879 --> 00:03:21,280
is uh uniformly random and they use this

99
00:03:21,280 --> 00:03:22,959
to do you know some very cool stuff

100
00:03:22,959 --> 00:03:26,080
including uh secure npc uh with close to

101
00:03:26,080 --> 00:03:27,920
have uh corruptions and the reason for

102
00:03:27,920 --> 00:03:30,239
this is that you can think of if there

103
00:03:30,239 --> 00:03:31,440
are like

104
00:03:31,440 --> 00:03:33,440
uh worst case corruptions or chosen

105
00:03:33,440 --> 00:03:35,519
corruptions on the ground set of parties

106
00:03:35,519 --> 00:03:37,040
uh since the select mechanism basically

107
00:03:37,040 --> 00:03:38,720
from the random you're going to see

108
00:03:38,720 --> 00:03:41,120
random corruptions of rules so this is

109
00:03:41,120 --> 00:03:42,480
something they use

110
00:03:42,480 --> 00:03:44,799
right so onto our work

111
00:03:44,799 --> 00:03:47,200
so the main difference uh

112
00:03:47,200 --> 00:03:48,640
with respect to our work is that we

113
00:03:48,640 --> 00:03:50,799
basically replace these iid random

114
00:03:50,799 --> 00:03:52,239
corruptions of rules

115
00:03:52,239 --> 00:03:54,480
by static chosen corruptions

116
00:03:54,480 --> 00:03:57,040
okay so again here's an example here's

117
00:03:57,040 --> 00:03:59,280
four rules for a protocol

118
00:03:59,280 --> 00:04:00,640
before the protocol starts we allow the

119
00:04:00,640 --> 00:04:02,239
adversary to corrupt say two roles of

120
00:04:02,239 --> 00:04:03,519
his choice

121
00:04:03,519 --> 00:04:05,200
uh and the protocol proceeds as before

122
00:04:05,200 --> 00:04:07,280
right so rule number one broadcast a

123
00:04:07,280 --> 00:04:09,439
public message sends private messages to

124
00:04:09,439 --> 00:04:10,480
the future

125
00:04:10,480 --> 00:04:12,000
second rule does the same thing but now

126
00:04:12,000 --> 00:04:13,280
it's corrupted so we can deviate

127
00:04:13,280 --> 00:04:15,439
arbitrarily from the protocol

128
00:04:15,439 --> 00:04:16,880
and so on

129
00:04:16,880 --> 00:04:19,199
okay so i guess one question is

130
00:04:19,199 --> 00:04:20,639
uh right so

131
00:04:20,639 --> 00:04:24,000
we consider this uh problem of uh public

132
00:04:24,000 --> 00:04:25,520
readiness extraction or you call me call

133
00:04:25,520 --> 00:04:28,560
it also uh public coin tossing

134
00:04:28,560 --> 00:04:30,000
and the goal here is that we're going to

135
00:04:30,000 --> 00:04:32,720
take these public values x1 through x4

136
00:04:32,720 --> 00:04:34,000
and we want to

137
00:04:34,000 --> 00:04:35,919
apply a deterministic function and

138
00:04:35,919 --> 00:04:37,360
compute a coin that should be

139
00:04:37,360 --> 00:04:39,280
statistically close to uniform

140
00:04:39,280 --> 00:04:41,840
okay and why do we care only about

141
00:04:41,840 --> 00:04:44,320
public values is that we also want that

142
00:04:44,320 --> 00:04:45,759
people that did not participate in the

143
00:04:45,759 --> 00:04:47,600
protocol to also be able to just look at

144
00:04:47,600 --> 00:04:49,120
the transcript and compute the coin by

145
00:04:49,120 --> 00:04:50,720
themselves so that more people can have

146
00:04:50,720 --> 00:04:52,720
a shared random bit

147
00:04:52,720 --> 00:04:53,840
okay so

148
00:04:53,840 --> 00:04:56,000
naturally we can ask you know why do we

149
00:04:56,000 --> 00:04:57,440
care about worst case corruptions in

150
00:04:57,440 --> 00:04:59,520
this setting i think one natural

151
00:04:59,520 --> 00:05:01,280
motivation is that the role selection

152
00:05:01,280 --> 00:05:03,280
mechanism may actually not be perfectly

153
00:05:03,280 --> 00:05:04,720
uniform it may be biased towards the

154
00:05:04,720 --> 00:05:06,800
adversary at certain points and i we

155
00:05:06,800 --> 00:05:08,000
think that worst case corruption has

156
00:05:08,000 --> 00:05:10,479
kind of captured this nicely

157
00:05:10,479 --> 00:05:12,080
second is that

158
00:05:12,080 --> 00:05:13,440
studying chosen corruptions in this

159
00:05:13,440 --> 00:05:15,840
setting kind of forces us to go beyond

160
00:05:15,840 --> 00:05:18,080
some round-based or committee-based mpc

161
00:05:18,080 --> 00:05:19,360
techniques

162
00:05:19,360 --> 00:05:21,440
uh third we actually think this is a

163
00:05:21,440 --> 00:05:23,680
very clean model that probably find more

164
00:05:23,680 --> 00:05:25,440
applications in the future

165
00:05:25,440 --> 00:05:27,520
and finally there's also some close

166
00:05:27,520 --> 00:05:29,759
relationship to other

167
00:05:29,759 --> 00:05:32,160
previous works in randomized extraction

168
00:05:32,160 --> 00:05:35,120
that's going back maybe 50 years

169
00:05:35,120 --> 00:05:36,639
all right

170
00:05:36,639 --> 00:05:39,520
so i guess one thing that i uh need to

171
00:05:39,520 --> 00:05:41,680
kind of spend a bit of time on is that

172
00:05:41,680 --> 00:05:43,600
we need to kind of describe how these

173
00:05:43,600 --> 00:05:44,960
messages to the future are implemented

174
00:05:44,960 --> 00:05:46,800
because this affects the adversarial

175
00:05:46,800 --> 00:05:47,919
model

176
00:05:47,919 --> 00:05:49,120
okay

177
00:05:49,120 --> 00:05:51,120
so in this talk uh we're just gonna

178
00:05:51,120 --> 00:05:52,800
focused on one specific setting we

179
00:05:52,800 --> 00:05:54,960
actually have more settings in the paper

180
00:05:54,960 --> 00:05:56,400
but the idea is that we have models that

181
00:05:56,400 --> 00:05:57,600
are inspired by some concrete

182
00:05:57,600 --> 00:06:00,800
implementations uh of this mechanism

183
00:06:00,800 --> 00:06:02,720
uh and we're just gonna assume that the

184
00:06:02,720 --> 00:06:04,639
adversary learns incoming messages to a

185
00:06:04,639 --> 00:06:06,639
corrupted role only when this role is

186
00:06:06,639 --> 00:06:08,639
executed so in particular if you have

187
00:06:08,639 --> 00:06:10,319
role number one sending a private

188
00:06:10,319 --> 00:06:11,919
message to roll number four and roll

189
00:06:11,919 --> 00:06:13,440
number four is corrupted

190
00:06:13,440 --> 00:06:15,680
then when the adversary is controlling

191
00:06:15,680 --> 00:06:17,120
role number two you won't know this

192
00:06:17,120 --> 00:06:18,840
message

193
00:06:18,840 --> 00:06:20,880
okay all right so out could this be

194
00:06:20,880 --> 00:06:22,240
implemented in practice well you can

195
00:06:22,240 --> 00:06:24,639
pretend that you know maybe roles share

196
00:06:24,639 --> 00:06:26,800
some public key secret key pairs

197
00:06:26,800 --> 00:06:28,240
um

198
00:06:28,240 --> 00:06:29,840
and the secret key can be maybe secret

199
00:06:29,840 --> 00:06:31,440
share over a committee and when this

200
00:06:31,440 --> 00:06:33,919
roll number four would be executed this

201
00:06:33,919 --> 00:06:36,000
committee reconstructs the secret key

202
00:06:36,000 --> 00:06:37,120
to this

203
00:06:37,120 --> 00:06:38,400
role number four

204
00:06:38,400 --> 00:06:40,080
and now roll number one can just you

205
00:06:40,080 --> 00:06:41,840
know encrypt something some secret

206
00:06:41,840 --> 00:06:43,919
message under the public key and then

207
00:06:43,919 --> 00:06:46,840
roll number four can just decrypt

208
00:06:46,840 --> 00:06:48,560
okay

209
00:06:48,560 --> 00:06:51,120
all right so i guess our main question

210
00:06:51,120 --> 00:06:53,440
that we try to understand here is what

211
00:06:53,440 --> 00:06:55,599
is the maximum corruption rate that

212
00:06:55,599 --> 00:06:57,120
still allows us to

213
00:06:57,120 --> 00:06:57,919
uh

214
00:06:57,919 --> 00:06:59,919
do low bias randomized extraction or low

215
00:06:59,919 --> 00:07:02,400
bias coin tossing in our setting

216
00:07:02,400 --> 00:07:03,520
okay

217
00:07:03,520 --> 00:07:05,680
and so we can basically start you know

218
00:07:05,680 --> 00:07:07,360
by trying to see what we can get with a

219
00:07:07,360 --> 00:07:08,880
very simple probably the most basic

220
00:07:08,880 --> 00:07:11,039
approach uh we could think of

221
00:07:11,039 --> 00:07:12,000
and

222
00:07:12,000 --> 00:07:13,919
probably for us the most basic approach

223
00:07:13,919 --> 00:07:15,199
is to you know take something that we

224
00:07:15,199 --> 00:07:16,639
understand quite well which are

225
00:07:16,639 --> 00:07:19,680
round-based uh npc protocols and try to

226
00:07:19,680 --> 00:07:21,599
naively um

227
00:07:21,599 --> 00:07:24,160
translate them into yozo protocols

228
00:07:24,160 --> 00:07:26,400
so let's say we start with some n-party

229
00:07:26,400 --> 00:07:29,039
around protocol for you know delta

230
00:07:29,039 --> 00:07:30,560
corruption rate

231
00:07:30,560 --> 00:07:32,319
uh we can just emulate naively the

232
00:07:32,319 --> 00:07:35,199
rounds in the yoso setting so basically

233
00:07:35,199 --> 00:07:37,440
for each party we have

234
00:07:37,440 --> 00:07:39,919
our roles okay and we have our blocks

235
00:07:39,919 --> 00:07:42,080
and each block basically emulates around

236
00:07:42,080 --> 00:07:43,919
so first block would emulate the first

237
00:07:43,919 --> 00:07:45,840
round of the protocol

238
00:07:45,840 --> 00:07:47,360
and you could just use the private

239
00:07:47,360 --> 00:07:49,680
messages to basically pass state to the

240
00:07:49,680 --> 00:07:51,919
next round okay then you just simulate

241
00:07:51,919 --> 00:07:53,840
all the rounds

242
00:07:53,840 --> 00:07:54,960
and

243
00:07:54,960 --> 00:07:56,800
you get a protocol but there's a problem

244
00:07:56,800 --> 00:07:59,919
because note that the number of roles

245
00:07:59,919 --> 00:08:02,960
went from n parties to n times r rolls

246
00:08:02,960 --> 00:08:04,400
but the number of corruptions needs to

247
00:08:04,400 --> 00:08:05,919
stay the same because you need to assume

248
00:08:05,919 --> 00:08:07,840
that if you look at the chain of roles

249
00:08:07,840 --> 00:08:09,199
that corresponds to a party if you

250
00:08:09,199 --> 00:08:11,280
corrupt one of the roles in the chain

251
00:08:11,280 --> 00:08:12,160
you basically have to assume that you

252
00:08:12,160 --> 00:08:14,639
corrupted everything okay so number of

253
00:08:14,639 --> 00:08:16,160
corruption stays the same number of

254
00:08:16,160 --> 00:08:18,400
roles blows up so the corruption rate

255
00:08:18,400 --> 00:08:20,160
that you tolerate decrease from delta to

256
00:08:20,160 --> 00:08:22,160
delta over r

257
00:08:22,160 --> 00:08:24,639
okay so for concreteness if you try to

258
00:08:24,639 --> 00:08:26,800
you know apply this to see what we can

259
00:08:26,800 --> 00:08:29,440
get so let's say we try we we apply we

260
00:08:29,440 --> 00:08:31,680
have a round-based protocol for three

261
00:08:31,680 --> 00:08:33,519
rounds and one is our corruption rate

262
00:08:33,519 --> 00:08:35,039
they basically get a yoaso protocol that

263
00:08:35,039 --> 00:08:36,799
secure against a roughly one over nine

264
00:08:36,799 --> 00:08:38,320
corruption rate okay so that's our

265
00:08:38,320 --> 00:08:39,440
baseline

266
00:08:39,440 --> 00:08:41,839
and we'd like to do better right

267
00:08:41,839 --> 00:08:44,480
and that's exactly what we do so we

268
00:08:44,480 --> 00:08:46,640
have both positive and negative results

269
00:08:46,640 --> 00:08:48,720
so in terms of positive results

270
00:08:48,720 --> 00:08:50,000
we basically get some zero error

271
00:08:50,000 --> 00:08:52,080
randomness extraction protocols against

272
00:08:52,080 --> 00:08:54,560
t corruptions with five t-rolls

273
00:08:54,560 --> 00:08:56,160
which gives you a corruption rate of

274
00:08:56,160 --> 00:08:57,760
about one over five

275
00:08:57,760 --> 00:08:59,519
uh or you know we have also have a

276
00:08:59,519 --> 00:09:01,360
stronger adversarial model we we get

277
00:09:01,360 --> 00:09:03,360
corruption right one over six

278
00:09:03,360 --> 00:09:05,279
and to complement this we also get an

279
00:09:05,279 --> 00:09:06,640
impossibility result that says that you

280
00:09:06,640 --> 00:09:08,800
know if you want to do uh low bias run

281
00:09:08,800 --> 00:09:10,480
with extraction against the corruptions

282
00:09:10,480 --> 00:09:11,760
you need you cannot do better than

283
00:09:11,760 --> 00:09:14,240
corruption rate one over four okay

284
00:09:14,240 --> 00:09:15,600
so it's a very interesting problem to

285
00:09:15,600 --> 00:09:16,959
try to close the gap between these two

286
00:09:16,959 --> 00:09:18,720
results

287
00:09:18,720 --> 00:09:19,760
all right so

288
00:09:19,760 --> 00:09:22,320
let me go and try to explain the main

289
00:09:22,320 --> 00:09:23,360
ideas

290
00:09:23,360 --> 00:09:25,920
behind our positive results and i'm just

291
00:09:25,920 --> 00:09:27,360
going to present here a slightly

292
00:09:27,360 --> 00:09:28,880
sub-optimal version

293
00:09:28,880 --> 00:09:30,800
of our positive results i'm going to

294
00:09:30,800 --> 00:09:31,839
give you

295
00:09:31,839 --> 00:09:34,800
a protocol that is secure against t

296
00:09:34,800 --> 00:09:37,279
corruptions with five t plus two rolls

297
00:09:37,279 --> 00:09:38,480
and then

298
00:09:38,480 --> 00:09:39,600
in the paper you can actually show how

299
00:09:39,600 --> 00:09:42,480
to uh save an extra two rolls from there

300
00:09:42,480 --> 00:09:43,600
all right

301
00:09:43,600 --> 00:09:46,000
so the main idea in just one sentence is

302
00:09:46,000 --> 00:09:48,560
that this is a usefied version of wooly

303
00:09:48,560 --> 00:09:51,360
mower's uh very follow secret sharing

304
00:09:51,360 --> 00:09:54,000
scheme from this secure npc made simple

305
00:09:54,000 --> 00:09:55,440
paper

306
00:09:55,440 --> 00:09:56,640
and

307
00:09:56,640 --> 00:09:58,399
here's how it works so

308
00:09:58,399 --> 00:09:59,519
um

309
00:09:59,519 --> 00:10:01,760
we can we basically have again five t

310
00:10:01,760 --> 00:10:03,440
plus two rolls we split them into two

311
00:10:03,440 --> 00:10:05,279
batches so the first batch we call the

312
00:10:05,279 --> 00:10:06,800
samplers there are three t plus one

313
00:10:06,800 --> 00:10:08,720
samplers second batch we call the

314
00:10:08,720 --> 00:10:10,079
publishers there are two t plus one

315
00:10:10,079 --> 00:10:11,519
publishers

316
00:10:11,519 --> 00:10:13,600
and the i level id is the following so

317
00:10:13,600 --> 00:10:15,920
we're going to use subsets of samplers

318
00:10:15,920 --> 00:10:18,320
to basically commit to values so random

319
00:10:18,320 --> 00:10:19,680
values and then send them to the

320
00:10:19,680 --> 00:10:20,880
publishers

321
00:10:20,880 --> 00:10:23,200
the publishers literally just broadcast

322
00:10:23,200 --> 00:10:24,880
whatever they receive

323
00:10:24,880 --> 00:10:26,480
and then we just take some careful

324
00:10:26,480 --> 00:10:28,320
majorities and you xor everything

325
00:10:28,320 --> 00:10:29,519
together and you're going to get a

326
00:10:29,519 --> 00:10:31,040
random bit

327
00:10:31,040 --> 00:10:32,640
all right so let me explain this in a

328
00:10:32,640 --> 00:10:34,800
bit more detail all right so

329
00:10:34,800 --> 00:10:36,000
the way it's going to work is that we're

330
00:10:36,000 --> 00:10:37,760
actually going to do a procedure that

331
00:10:37,760 --> 00:10:39,200
works in parallel

332
00:10:39,200 --> 00:10:41,760
over basically all subsets of size 2t

333
00:10:41,760 --> 00:10:44,079
plus 1 of samplers

334
00:10:44,079 --> 00:10:45,920
and the reason why the 2t plus 1 is

335
00:10:45,920 --> 00:10:48,560
because then we get honest majority

336
00:10:48,560 --> 00:10:50,240
uh and here's how it works so the first

337
00:10:50,240 --> 00:10:52,640
party in the set samples around a bit

338
00:10:52,640 --> 00:10:54,720
forwards to everyone to all the other

339
00:10:54,720 --> 00:10:56,560
samplers

340
00:10:56,560 --> 00:10:58,000
and the second

341
00:10:58,000 --> 00:11:00,079
sampler basically forwards what he got

342
00:11:00,079 --> 00:11:01,839
to all the other samplers

343
00:11:01,839 --> 00:11:04,160
etc and

344
00:11:04,160 --> 00:11:06,160
of course we may have corrupted samplers

345
00:11:06,160 --> 00:11:07,920
and if a sampler is corrupted it may

346
00:11:07,920 --> 00:11:10,240
choose to lie and send different bits to

347
00:11:10,240 --> 00:11:12,800
different parties or to different roles

348
00:11:12,800 --> 00:11:14,560
so we need a consistent check to make

349
00:11:14,560 --> 00:11:16,399
sure you know everything is going okay

350
00:11:16,399 --> 00:11:17,760
and the consistency check is pretty

351
00:11:17,760 --> 00:11:19,680
simple so a role just looks at

352
00:11:19,680 --> 00:11:21,200
everything he got

353
00:11:21,200 --> 00:11:23,200
and just checks if they're all the same

354
00:11:23,200 --> 00:11:24,720
because if they're not all the same then

355
00:11:24,720 --> 00:11:26,160
you know there was some adversary

356
00:11:26,160 --> 00:11:27,600
corrupting things

357
00:11:27,600 --> 00:11:29,440
and so we can if this happened then you

358
00:11:29,440 --> 00:11:30,959
can just say okay i'm complaining about

359
00:11:30,959 --> 00:11:32,480
this set and this side is no good

360
00:11:32,480 --> 00:11:34,000
there's an adversary so the procedure

361
00:11:34,000 --> 00:11:35,519
just supports

362
00:11:35,519 --> 00:11:37,360
otherwise if they're all the same we can

363
00:11:37,360 --> 00:11:39,279
say okay everything's okay so we're just

364
00:11:39,279 --> 00:11:40,640
going to forward everything to the

365
00:11:40,640 --> 00:11:42,320
publishers

366
00:11:42,320 --> 00:11:43,839
and you and this constituted check

367
00:11:43,839 --> 00:11:46,959
basically runs for all the assemblers

368
00:11:46,959 --> 00:11:48,720
okay so when you look

369
00:11:48,720 --> 00:11:50,800
when those publishers

370
00:11:50,800 --> 00:11:53,920
receive this uh zs they basically just

371
00:11:53,920 --> 00:11:56,000
you know you get a list of two t plus

372
00:11:56,000 --> 00:11:57,519
one z's potentially if there was no

373
00:11:57,519 --> 00:11:58,880
complaint

374
00:11:58,880 --> 00:12:01,519
and they literally just um i'll put the

375
00:12:01,519 --> 00:12:03,360
majority and you do this for all the

376
00:12:03,360 --> 00:12:04,560
publishers so they just output the

377
00:12:04,560 --> 00:12:07,040
majority of whatever they received for

378
00:12:07,040 --> 00:12:08,800
this specific set

379
00:12:08,800 --> 00:12:10,959
and now it's pretty simple so for each

380
00:12:10,959 --> 00:12:14,320
set s we just set w sub s to p 0 if

381
00:12:14,320 --> 00:12:15,839
there was a complaint otherwise we just

382
00:12:15,839 --> 00:12:18,000
take the majorities of all the

383
00:12:18,000 --> 00:12:20,399
majorities that the publishers output

384
00:12:20,399 --> 00:12:21,760
and in the end we just xor everything

385
00:12:21,760 --> 00:12:23,279
together

386
00:12:23,279 --> 00:12:25,040
and i'm just going to give you a very

387
00:12:25,040 --> 00:12:26,800
rough idea why this works what are the

388
00:12:26,800 --> 00:12:28,639
key properties behind this

389
00:12:28,639 --> 00:12:32,000
so first thing is that every status

390
00:12:32,000 --> 00:12:35,120
of samplers has a strict honest majority

391
00:12:35,120 --> 00:12:38,000
uh second thing is is if the setas did

392
00:12:38,000 --> 00:12:39,680
not receive a complaint and all these

393
00:12:39,680 --> 00:12:42,000
honest roles uh in the set s they agree

394
00:12:42,000 --> 00:12:43,680
on the same value which basically means

395
00:12:43,680 --> 00:12:44,880
that you're committing to a value

396
00:12:44,880 --> 00:12:45,920
because there's a there's an honest

397
00:12:45,920 --> 00:12:47,120
majority

398
00:12:47,120 --> 00:12:48,160
uh

399
00:12:48,160 --> 00:12:49,839
in this set

400
00:12:49,839 --> 00:12:50,880
okay

401
00:12:50,880 --> 00:12:53,279
and finally there is a special set a

402
00:12:53,279 --> 00:12:56,160
star such that all samplers

403
00:12:56,160 --> 00:12:58,240
in this set are going to be honest

404
00:12:58,240 --> 00:13:00,000
and this is important because

405
00:13:00,000 --> 00:13:02,399
the value that these guys agree on this

406
00:13:02,399 --> 00:13:04,880
w sub star will be uniformly random and

407
00:13:04,880 --> 00:13:06,399
will also be hidden from the adversary

408
00:13:06,399 --> 00:13:08,160
at all times which means that whatever

409
00:13:08,160 --> 00:13:10,800
the adversary does

410
00:13:10,800 --> 00:13:12,639
whatever values he chooses to for him if

411
00:13:12,639 --> 00:13:14,160
he chooses to complain or he chooses to

412
00:13:14,160 --> 00:13:16,160
bias some value

413
00:13:16,160 --> 00:13:17,760
this will all be independent of w sub

414
00:13:17,760 --> 00:13:19,200
star and so this

415
00:13:19,200 --> 00:13:22,560
xor will be uniformly bad

416
00:13:22,560 --> 00:13:24,480
all right and so this works this gives

417
00:13:24,480 --> 00:13:26,639
you five t plus two and we can uh save

418
00:13:26,639 --> 00:13:29,279
two roles uh with more care

419
00:13:29,279 --> 00:13:31,200
all right so

420
00:13:31,200 --> 00:13:33,920
you know this protocol if you just

421
00:13:33,920 --> 00:13:35,440
specialize me for one corruption this

422
00:13:35,440 --> 00:13:37,600
gives you like seven roles so it's kind

423
00:13:37,600 --> 00:13:38,560
of

424
00:13:38,560 --> 00:13:40,639
uh natural to think you know whether we

425
00:13:40,639 --> 00:13:41,760
can

426
00:13:41,760 --> 00:13:44,160
improve on this maybe naively

427
00:13:44,160 --> 00:13:45,920
and i think it's instructive to just

428
00:13:45,920 --> 00:13:48,720
consider some very concrete settings

429
00:13:48,720 --> 00:13:50,240
uh and

430
00:13:50,240 --> 00:13:51,440
let me just give you know a simple

431
00:13:51,440 --> 00:13:52,880
protocol to show that indeed we can do

432
00:13:52,880 --> 00:13:53,920
better

433
00:13:53,920 --> 00:13:55,279
um

434
00:13:55,279 --> 00:13:56,079
so

435
00:13:56,079 --> 00:13:57,360
here's the

436
00:13:57,360 --> 00:13:58,959
the example for just one corruption so

437
00:13:58,959 --> 00:14:01,440
again same flavor you have

438
00:14:01,440 --> 00:14:03,040
um

439
00:14:03,040 --> 00:14:06,240
two samplers three publishers okay

440
00:14:06,240 --> 00:14:08,320
and again very simple so

441
00:14:08,320 --> 00:14:10,160
first sampler just samples a bit sends

442
00:14:10,160 --> 00:14:12,240
to everyone second sampler samples

443
00:14:12,240 --> 00:14:14,560
another random bit sends to everyone

444
00:14:14,560 --> 00:14:17,040
they all just publish whatever they got

445
00:14:17,040 --> 00:14:18,079
you take

446
00:14:18,079 --> 00:14:21,120
the majorities of the reported values

447
00:14:21,120 --> 00:14:24,560
and you just exert them together and why

448
00:14:24,560 --> 00:14:26,160
does this work well this works because

449
00:14:26,160 --> 00:14:27,680
of case analysis so if you have one

450
00:14:27,680 --> 00:14:28,959
corruption say you corrupt one of the

451
00:14:28,959 --> 00:14:31,839
samplers say roll number two

452
00:14:31,839 --> 00:14:33,600
then what happens you can of course lie

453
00:14:33,600 --> 00:14:34,959
and send different values to different

454
00:14:34,959 --> 00:14:37,279
publishers but one thing that happens is

455
00:14:37,279 --> 00:14:39,279
that two of the publishers must receive

456
00:14:39,279 --> 00:14:40,560
the same value

457
00:14:40,560 --> 00:14:41,920
it is important because this means

458
00:14:41,920 --> 00:14:43,040
you're essentially committing to this

459
00:14:43,040 --> 00:14:44,480
value that you're sending twice because

460
00:14:44,480 --> 00:14:46,320
you're going to take majorities

461
00:14:46,320 --> 00:14:48,240
so then that part's fine

462
00:14:48,240 --> 00:14:49,519
so if you try to corrupt one of the

463
00:14:49,519 --> 00:14:52,079
publishers that's also fine because

464
00:14:52,079 --> 00:14:53,519
again two of the publishers will be

465
00:14:53,519 --> 00:14:55,120
honest and the samples will also be

466
00:14:55,120 --> 00:14:56,959
honest so whatever you decide to do with

467
00:14:56,959 --> 00:14:58,880
the third step with the third publisher

468
00:14:58,880 --> 00:14:59,920
they're not going to be a problem

469
00:14:59,920 --> 00:15:01,040
because you're anyway going to take

470
00:15:01,040 --> 00:15:02,800
majorities okay

471
00:15:02,800 --> 00:15:04,000
so this works and this gives you a

472
00:15:04,000 --> 00:15:05,600
protocol for five parties and one

473
00:15:05,600 --> 00:15:07,839
corruption and you can generalize this

474
00:15:07,839 --> 00:15:09,600
combined with ideas from the previous

475
00:15:09,600 --> 00:15:12,240
slide to get this 5t rolls instead of 5

476
00:15:12,240 --> 00:15:14,480
t plus 2.

477
00:15:14,480 --> 00:15:15,920
all right

478
00:15:15,920 --> 00:15:17,440
okay so

479
00:15:17,440 --> 00:15:19,839
i should also maybe give you some ideas

480
00:15:19,839 --> 00:15:21,040
about

481
00:15:21,040 --> 00:15:22,720
our impossibility result which is kind

482
00:15:22,720 --> 00:15:24,320
of subtle

483
00:15:24,320 --> 00:15:26,160
so again just a reminder so we proved

484
00:15:26,160 --> 00:15:27,760
that basically if you want to do

485
00:15:27,760 --> 00:15:29,600
uh public randomness extraction in our

486
00:15:29,600 --> 00:15:32,000
model we'd say sub-constant bias

487
00:15:32,000 --> 00:15:34,959
uh then you need um at least four t plus

488
00:15:34,959 --> 00:15:37,279
one rolls so in other words you need you

489
00:15:37,279 --> 00:15:38,880
cannot do better than say one over four

490
00:15:38,880 --> 00:15:40,399
corruption rate

491
00:15:40,399 --> 00:15:41,839
all right

492
00:15:41,839 --> 00:15:44,720
so just to clarify what we get uh in

493
00:15:44,720 --> 00:15:46,639
this case uh so if you have this weaker

494
00:15:46,639 --> 00:15:48,160
adversary where we're

495
00:15:48,160 --> 00:15:50,720
considering in this talk uh you get some

496
00:15:50,720 --> 00:15:52,240
the optimal number of roles is somewhere

497
00:15:52,240 --> 00:15:54,399
between 40 plus one and five t

498
00:15:54,399 --> 00:15:55,440
uh if you can see an hour stronger

499
00:15:55,440 --> 00:15:57,120
adversary in the paper uh you get

500
00:15:57,120 --> 00:15:58,880
something that's between forty plus one

501
00:15:58,880 --> 00:16:00,800
sixty plus one again very interesting

502
00:16:00,800 --> 00:16:04,399
open problem to try to uh close this gap

503
00:16:04,399 --> 00:16:06,320
and so let me just give you an idea of

504
00:16:06,320 --> 00:16:07,360
how we

505
00:16:07,360 --> 00:16:09,279
how this works so just as a warm-up

506
00:16:09,279 --> 00:16:10,959
let's just do uh three rolls one

507
00:16:10,959 --> 00:16:12,720
corruption so showing that you need

508
00:16:12,720 --> 00:16:14,240
better than one of you cannot do better

509
00:16:14,240 --> 00:16:16,399
than say one-third corruption rate

510
00:16:16,399 --> 00:16:19,040
and yeah our idea so here's a protocol

511
00:16:19,040 --> 00:16:20,959
structure again

512
00:16:20,959 --> 00:16:22,800
parties broadcast but roles broadcast

513
00:16:22,800 --> 00:16:25,440
public values they send private messages

514
00:16:25,440 --> 00:16:27,040
to future roles

515
00:16:27,040 --> 00:16:29,199
right and the way this is gonna work uh

516
00:16:29,199 --> 00:16:31,199
is that we're gonna go party by party

517
00:16:31,199 --> 00:16:33,120
from sorry we're gonna go roll by roll

518
00:16:33,120 --> 00:16:35,199
from last roll to first roll

519
00:16:35,199 --> 00:16:37,040
and we're going to try to you know have

520
00:16:37,040 --> 00:16:38,880
a strategy for corrupting the protocol

521
00:16:38,880 --> 00:16:40,240
and we know that this strategy cannot

522
00:16:40,240 --> 00:16:41,279
work because we're assuming that the

523
00:16:41,279 --> 00:16:43,680
protocol exists and it works

524
00:16:43,680 --> 00:16:44,720
and so this is going to give you some

525
00:16:44,720 --> 00:16:45,839
properties that the protocol must

526
00:16:45,839 --> 00:16:49,440
satisfy and when we reach the first role

527
00:16:49,440 --> 00:16:51,199
we're going to run into a problem okay

528
00:16:51,199 --> 00:16:53,279
so let's look at you know so we compute

529
00:16:53,279 --> 00:16:54,720
the coin in this way

530
00:16:54,720 --> 00:16:55,920
and we look at

531
00:16:55,920 --> 00:16:58,480
the third roll so

532
00:16:58,480 --> 00:17:01,440
i claim that if there are two bits such

533
00:17:01,440 --> 00:17:03,360
that you know the last row can just

534
00:17:03,360 --> 00:17:06,400
choose uh essentially the output uh the

535
00:17:06,400 --> 00:17:08,079
value of the coin then that's a problem

536
00:17:08,079 --> 00:17:09,679
right because if i corrupt the last row

537
00:17:09,679 --> 00:17:12,559
and this is true i could say choose x30

538
00:17:12,559 --> 00:17:14,079
and the value of the coin would always

539
00:17:14,079 --> 00:17:16,480
be zero okay so clearly this is a

540
00:17:16,480 --> 00:17:18,559
problem this bias is the coin

541
00:17:18,559 --> 00:17:20,880
and what is the conclusion is that

542
00:17:20,880 --> 00:17:23,520
whatever protocol we have the first two

543
00:17:23,520 --> 00:17:25,119
public values must indeed fully

544
00:17:25,119 --> 00:17:27,839
determine the coin with high probability

545
00:17:27,839 --> 00:17:30,080
all right so then we can go to roll

546
00:17:30,080 --> 00:17:31,600
number two

547
00:17:31,600 --> 00:17:33,440
and

548
00:17:33,440 --> 00:17:35,360
here maybe one natural way to try to

549
00:17:35,360 --> 00:17:37,280
corrupt this is to

550
00:17:37,280 --> 00:17:39,360
uh maybe try to

551
00:17:39,360 --> 00:17:42,240
simulate uh in my head two honest runs

552
00:17:42,240 --> 00:17:44,480
of the protocol and then try to choose

553
00:17:44,480 --> 00:17:47,120
the one i like the most okay

554
00:17:47,120 --> 00:17:48,720
and i can do this because in green i

555
00:17:48,720 --> 00:17:51,200
know that just the output

556
00:17:51,200 --> 00:17:52,559
the public outputs of the two first

557
00:17:52,559 --> 00:17:55,039
roles would determine the final coin

558
00:17:55,039 --> 00:17:57,440
all right so i could sample x to zero x

559
00:17:57,440 --> 00:17:59,760
to one id like i would be honest and

560
00:17:59,760 --> 00:18:00,960
then try to predict what they're going

561
00:18:00,960 --> 00:18:02,720
to say right what's going to be the

562
00:18:02,720 --> 00:18:04,720
final value of the coin and this just

563
00:18:04,720 --> 00:18:07,039
choose the path that i like the most

564
00:18:07,039 --> 00:18:08,640
again this is problematic there's some

565
00:18:08,640 --> 00:18:11,039
bias and what we conclude is that if we

566
00:18:11,039 --> 00:18:13,679
have two independent

567
00:18:13,679 --> 00:18:15,760
the samples then they basically must

568
00:18:15,760 --> 00:18:18,000
lead uh to the same value all the time

569
00:18:18,000 --> 00:18:18,799
so

570
00:18:18,799 --> 00:18:20,880
what basically what this means is that

571
00:18:20,880 --> 00:18:21,840
just the

572
00:18:21,840 --> 00:18:24,880
first role actually determines the whole

573
00:18:24,880 --> 00:18:26,880
protocol or the the value of the coin

574
00:18:26,880 --> 00:18:28,240
and this is a problem right because now

575
00:18:28,240 --> 00:18:30,160
you can corrupt just the first rule you

576
00:18:30,160 --> 00:18:32,320
just simulate two honest runs of the

577
00:18:32,320 --> 00:18:34,160
protocol we know that the protocol is

578
00:18:34,160 --> 00:18:35,600
correct so they're going to lead to two

579
00:18:35,600 --> 00:18:38,160
different values with high probability

580
00:18:38,160 --> 00:18:41,120
uh and so roll number one can actually

581
00:18:41,120 --> 00:18:42,640
biased the coin as well and it is a

582
00:18:42,640 --> 00:18:44,480
problem okay

583
00:18:44,480 --> 00:18:46,000
so

584
00:18:46,000 --> 00:18:48,240
uh i won't have time to go over like our

585
00:18:48,240 --> 00:18:50,400
actual result for four rolls uh so i'm

586
00:18:50,400 --> 00:18:52,400
just going to give you a very uh brief

587
00:18:52,400 --> 00:18:54,400
idea of why this doesn't work why why

588
00:18:54,400 --> 00:18:57,200
why we need to be careful uh and so

589
00:18:57,200 --> 00:18:59,200
again this is our structure right of our

590
00:18:59,200 --> 00:19:01,360
protocol again we start by corrupting

591
00:19:01,360 --> 00:19:03,280
maybe start by going roll number four

592
00:19:03,280 --> 00:19:05,120
and then everything is okay we slide

593
00:19:05,120 --> 00:19:06,400
back we then we corrupt roll number

594
00:19:06,400 --> 00:19:09,039
three everything is again okay but then

595
00:19:09,039 --> 00:19:11,280
we try to corrupt role number two and

596
00:19:11,280 --> 00:19:12,799
the properties at high level that we're

597
00:19:12,799 --> 00:19:15,440
using is that one role number two must

598
00:19:15,440 --> 00:19:17,200
be able to influence the final output

599
00:19:17,200 --> 00:19:18,960
and this is certainly true and it's easy

600
00:19:18,960 --> 00:19:20,000
to show

601
00:19:20,000 --> 00:19:21,919
and but we also need that role number

602
00:19:21,919 --> 00:19:24,320
two must be able to predict uh which

603
00:19:24,320 --> 00:19:27,840
path leads to which value of the coin

604
00:19:27,840 --> 00:19:29,840
and this is actually the hard part and

605
00:19:29,840 --> 00:19:31,520
this is hard because

606
00:19:31,520 --> 00:19:33,039
rule number two doesn't know the private

607
00:19:33,039 --> 00:19:34,960
message from rule number one to rule

608
00:19:34,960 --> 00:19:36,160
number three

609
00:19:36,160 --> 00:19:38,080
uh and so we kind of need to find a way

610
00:19:38,080 --> 00:19:40,240
to get around this uh

611
00:19:40,240 --> 00:19:42,720
and it is subtle uh but yeah but i'll

612
00:19:42,720 --> 00:19:43,919
leave it at that and i'll leave you to

613
00:19:43,919 --> 00:19:46,000
you know check the paper so yeah just

614
00:19:46,000 --> 00:19:47,760
wrapping up uh

615
00:19:47,760 --> 00:19:49,600
very clearly so we we looked at yoso

616
00:19:49,600 --> 00:19:51,360
which is stateless npc because of denial

617
00:19:51,360 --> 00:19:53,440
of service attacks we consider public

618
00:19:53,440 --> 00:19:55,679
coin tossing with worst case corruptions

619
00:19:55,679 --> 00:19:57,520
why because we need we want something

620
00:19:57,520 --> 00:19:59,200
that's still secure if the role

621
00:19:59,200 --> 00:20:01,600
selection mechanism is biased we want to

622
00:20:01,600 --> 00:20:04,320
go beyond round-based mpc techniques

623
00:20:04,320 --> 00:20:05,360
and

624
00:20:05,360 --> 00:20:08,960
we get some positive results so we get

625
00:20:08,960 --> 00:20:11,679
protocols for 60 plus 1 or 5t

626
00:20:11,679 --> 00:20:13,600
rolls for t corruptions

627
00:20:13,600 --> 00:20:15,679
and um

628
00:20:15,679 --> 00:20:16,960
just leaving here with some open

629
00:20:16,960 --> 00:20:18,880
problems so of course it'd be very

630
00:20:18,880 --> 00:20:20,240
interesting to close the gap between our

631
00:20:20,240 --> 00:20:22,640
two results positive and negative

632
00:20:22,640 --> 00:20:24,400
uh also i'm not sure if you notice but

633
00:20:24,400 --> 00:20:26,400
our protocols are super inefficient they

634
00:20:26,400 --> 00:20:27,840
have exponential complexity in the

635
00:20:27,840 --> 00:20:29,120
number of roles

636
00:20:29,120 --> 00:20:30,880
and uh it's a very interesting open

637
00:20:30,880 --> 00:20:32,240
problem to just try to get polynomial

638
00:20:32,240 --> 00:20:34,480
complexity number of roles and finally

639
00:20:34,480 --> 00:20:35,440
just you know try to get more

640
00:20:35,440 --> 00:20:36,720
functionalities because we just did coin

641
00:20:36,720 --> 00:20:41,679
tossing so yeah thanks a lot and

642
00:20:42,559 --> 00:20:44,000
thanks for the top

643
00:20:44,000 --> 00:20:45,679
we have time for one short question

644
00:20:45,679 --> 00:20:48,400
while the next speaker sets up um if you

645
00:20:48,400 --> 00:20:49,600
have questions please go to the

646
00:20:49,600 --> 00:20:51,120
microphones here so there's people on

647
00:20:51,120 --> 00:20:52,559
zoom here you or you can also ask

648
00:20:52,559 --> 00:20:54,559
questions in the zoom chat

649
00:20:54,559 --> 00:20:56,000
so if there's not maybe i can ask you

650
00:20:56,000 --> 00:20:58,080
what is the conjecture four or five

651
00:20:58,080 --> 00:21:00,000
where is the right ah

652
00:21:00,000 --> 00:21:01,919
probably yeah i think 40 plus one is

653
00:21:01,919 --> 00:21:04,080
probably the next speaker here also

654
00:21:04,080 --> 00:21:05,039
yeah

655
00:21:05,039 --> 00:21:07,039
yeah 40 plus one is probably tight yeah

656
00:21:07,039 --> 00:21:09,120
okay yeah i think so

657
00:21:09,120 --> 00:21:12,918
okay thanks thanks

658
00:22:23,919 --> 00:22:26,159
so our next talk is on non-deterministic

659
00:22:26,159 --> 00:22:28,000
hardness resistant malleability by

660
00:22:28,000 --> 00:22:30,000
marshall bolt anna dahman solet and

661
00:22:30,000 --> 00:22:34,240
julian los and julian is giving the talk

662
00:22:35,280 --> 00:22:39,879
i don't think uh the slightest picture

663
00:22:46,159 --> 00:22:49,280
okay uh hi my name is julian um and i'm

664
00:22:49,280 --> 00:22:50,320
going to be talking about

665
00:22:50,320 --> 00:22:52,080
non-deterministic hardness versus

666
00:22:52,080 --> 00:22:53,679
non-malability

667
00:22:53,679 --> 00:22:55,679
this is joint work with marshall ball

668
00:22:55,679 --> 00:22:58,640
from nyu and donna dahman solid from

669
00:22:58,640 --> 00:23:00,880
umd

670
00:23:00,880 --> 00:23:02,400
okay so suppose that we're in the

671
00:23:02,400 --> 00:23:04,799
following setting we have a party a and

672
00:23:04,799 --> 00:23:06,080
a party b

673
00:23:06,080 --> 00:23:09,760
and a alice would like to send a message

674
00:23:09,760 --> 00:23:12,640
to to bob on the right side here

675
00:23:12,640 --> 00:23:14,480
so what she does is she encodes this

676
00:23:14,480 --> 00:23:16,720
message as a series of bit strings and

677
00:23:16,720 --> 00:23:20,000
then she sends this message to bob

678
00:23:20,000 --> 00:23:22,960
but the problem might be that m now

679
00:23:22,960 --> 00:23:24,799
could contain errors because there could

680
00:23:24,799 --> 00:23:28,240
be an adversary say on this channel that

681
00:23:28,240 --> 00:23:30,080
flips a couple of these bits and then

682
00:23:30,080 --> 00:23:33,120
bob doesn't get the correct message

683
00:23:33,120 --> 00:23:35,440
so one simple solution to this problem

684
00:23:35,440 --> 00:23:37,280
might be to

685
00:23:37,280 --> 00:23:39,440
apply an error correcting code so an

686
00:23:39,440 --> 00:23:43,120
error correcting code is a code

687
00:23:43,120 --> 00:23:45,039
which contains an encoding function you

688
00:23:45,039 --> 00:23:48,159
can apply this code to the message m

689
00:23:48,159 --> 00:23:49,039
and

690
00:23:49,039 --> 00:23:51,520
you get as an output code word

691
00:23:51,520 --> 00:23:54,720
which bob can then decrypt to the

692
00:23:54,720 --> 00:23:57,600
original message even if there were some

693
00:23:57,600 --> 00:24:00,159
errors and the code word was flipped

694
00:24:00,159 --> 00:24:03,360
into a into a different code word c hat

695
00:24:03,360 --> 00:24:05,440
but now the problem is that we can't

696
00:24:05,440 --> 00:24:07,679
actually guarantee that the decoding

697
00:24:07,679 --> 00:24:10,240
will output the original message and the

698
00:24:10,240 --> 00:24:12,720
question is what can we still guarantee

699
00:24:12,720 --> 00:24:15,679
in this question in this setting

700
00:24:15,679 --> 00:24:18,880
so a little bit more in detail we refer

701
00:24:18,880 --> 00:24:20,480
to this kind of attack where some bits

702
00:24:20,480 --> 00:24:22,480
of the code words are flipped as a

703
00:24:22,480 --> 00:24:25,679
tampering attack so an adversary here

704
00:24:25,679 --> 00:24:28,480
tampers the original code word c into a

705
00:24:28,480 --> 00:24:31,600
tampered code word c hat such that

706
00:24:31,600 --> 00:24:34,320
the decoding of c hat does not yield the

707
00:24:34,320 --> 00:24:36,480
original message m

708
00:24:36,480 --> 00:24:38,880
and um this can have very very bad

709
00:24:38,880 --> 00:24:41,200
consequences as you can imagine

710
00:24:41,200 --> 00:24:43,520
um so here's a simple example

711
00:24:43,520 --> 00:24:46,320
maybe alice is sending or trying to send

712
00:24:46,320 --> 00:24:48,559
bob a message m order pizza for dinner

713
00:24:48,559 --> 00:24:50,559
and now there's an adversary here and

714
00:24:50,559 --> 00:24:52,559
he's tampering with this message and so

715
00:24:52,559 --> 00:24:54,640
what you end up with is a message that

716
00:24:54,640 --> 00:24:57,600
says order pineapple pizza for dinner

717
00:24:57,600 --> 00:24:59,360
and this is of course something we

718
00:24:59,360 --> 00:25:01,120
really want to avoid

719
00:25:01,120 --> 00:25:02,240
and

720
00:25:02,240 --> 00:25:05,120
yes you do and uh you could apply a mac

721
00:25:05,120 --> 00:25:07,440
here but um

722
00:25:07,440 --> 00:25:10,559
you know a mac is a key primitive and uh

723
00:25:10,559 --> 00:25:12,080
it's an interesting question whether you

724
00:25:12,080 --> 00:25:14,000
can actually do this without having any

725
00:25:14,000 --> 00:25:16,240
keys and this is the kind of question

726
00:25:16,240 --> 00:25:18,080
that we're trying to answer here

727
00:25:18,080 --> 00:25:20,720
and uh the tool well i'm sorry this is

728
00:25:20,720 --> 00:25:22,320
blocked but the tool that we're trying

729
00:25:22,320 --> 00:25:24,880
to apply to get here is is a tool called

730
00:25:24,880 --> 00:25:26,480
non-malleable codes introduced by

731
00:25:26,480 --> 00:25:30,480
jambowski pierce and vixx in 2010 so a

732
00:25:30,480 --> 00:25:32,240
non-malibu code is just a code with an

733
00:25:32,240 --> 00:25:34,640
encoding function e a decoding function

734
00:25:34,640 --> 00:25:36,159
d with

735
00:25:36,159 --> 00:25:38,080
roughly a property that prevents

736
00:25:38,080 --> 00:25:40,240
tampering as follows

737
00:25:40,240 --> 00:25:42,799
or in the following sense so uh if you

738
00:25:42,799 --> 00:25:45,440
input m to the encoding e and then e

739
00:25:45,440 --> 00:25:47,039
outputs a code word and now the

740
00:25:47,039 --> 00:25:49,440
adversary tampers with this cohort

741
00:25:49,440 --> 00:25:52,799
then the decoding function is guaranteed

742
00:25:52,799 --> 00:25:56,000
to either output the original message or

743
00:25:56,000 --> 00:25:58,159
to output something that's completely

744
00:25:58,159 --> 00:26:00,559
unrelated to the original message okay

745
00:26:00,559 --> 00:26:02,880
so this in some sense captures the

746
00:26:02,880 --> 00:26:04,799
intuition that the best attack that the

747
00:26:04,799 --> 00:26:06,880
adversary should be able to do is to

748
00:26:06,880 --> 00:26:08,799
delete the code word from the channel

749
00:26:08,799 --> 00:26:10,960
entirely and replace it with something

750
00:26:10,960 --> 00:26:13,840
that's a completely unrelated codeword

751
00:26:13,840 --> 00:26:15,520
so defining security is a little bit

752
00:26:15,520 --> 00:26:17,200
tricky in this setting so let me try to

753
00:26:17,200 --> 00:26:19,679
do it here um so we're going to use the

754
00:26:19,679 --> 00:26:22,080
real world ideal world paradigm

755
00:26:22,080 --> 00:26:24,240
to define the security experiment here

756
00:26:24,240 --> 00:26:26,400
so i'm going to show you the real world

757
00:26:26,400 --> 00:26:28,320
experiment first so this is just a

758
00:26:28,320 --> 00:26:30,240
tampering experiment and i'm emphasizing

759
00:26:30,240 --> 00:26:32,159
here that the encoding that we want to

760
00:26:32,159 --> 00:26:33,039
uh

761
00:26:33,039 --> 00:26:34,880
to reason about here is is actually

762
00:26:34,880 --> 00:26:37,279
randomized uh so i'm going to input the

763
00:26:37,279 --> 00:26:39,200
message to the encoding then the

764
00:26:39,200 --> 00:26:41,279
encoding will output a code word and

765
00:26:41,279 --> 00:26:43,360
then um we're going to model the

766
00:26:43,360 --> 00:26:46,000
tampering function now as an efficiently

767
00:26:46,000 --> 00:26:48,159
computable function f which takes in the

768
00:26:48,159 --> 00:26:50,000
code word it outputs a tampered code

769
00:26:50,000 --> 00:26:51,760
word c hat

770
00:26:51,760 --> 00:26:53,760
and then c hat is fed into the decoding

771
00:26:53,760 --> 00:26:55,840
and then the decoding outputs uh well

772
00:26:55,840 --> 00:26:57,360
whatever comes out of d

773
00:26:57,360 --> 00:26:59,200
so this is the real world experiment and

774
00:26:59,200 --> 00:27:01,840
now for the ideal world experiment

775
00:27:01,840 --> 00:27:04,799
uh we're going to use a simulator which

776
00:27:04,799 --> 00:27:07,360
actually doesn't take the message m as

777
00:27:07,360 --> 00:27:09,840
an input so what the simulator does is

778
00:27:09,840 --> 00:27:12,320
it's going to either sample a constant

779
00:27:12,320 --> 00:27:13,600
word same

780
00:27:13,600 --> 00:27:17,120
or something uh that comes from the

781
00:27:17,120 --> 00:27:21,279
input output space of this code

782
00:27:21,279 --> 00:27:22,240
and

783
00:27:22,240 --> 00:27:25,760
this simulator now induces uh basically

784
00:27:25,760 --> 00:27:27,360
a distribution which should be

785
00:27:27,360 --> 00:27:30,399
indistinguishable from the distribution

786
00:27:30,399 --> 00:27:32,640
induced by the real world experiment as

787
00:27:32,640 --> 00:27:35,360
follows so if we input m here to the

788
00:27:35,360 --> 00:27:37,840
experiment or the experiment is defined

789
00:27:37,840 --> 00:27:39,840
relative to m rather

790
00:27:39,840 --> 00:27:42,559
then if the simulator output's same m

791
00:27:42,559 --> 00:27:45,039
will be the output of this distribution

792
00:27:45,039 --> 00:27:47,840
and otherwise if it's m hat it will be m

793
00:27:47,840 --> 00:27:50,240
hat okay and uh so as i said this

794
00:27:50,240 --> 00:27:52,559
induces a distribution df that depends

795
00:27:52,559 --> 00:27:55,440
on the tampering function and it is a

796
00:27:55,440 --> 00:27:58,480
distribution over identity constant

797
00:27:58,480 --> 00:28:00,960
functions over the input output space

798
00:28:00,960 --> 00:28:02,559
of this code

799
00:28:02,559 --> 00:28:03,919
and what we want is that this

800
00:28:03,919 --> 00:28:05,440
distribution is statistically

801
00:28:05,440 --> 00:28:07,200
indistinguishable from the real-world

802
00:28:07,200 --> 00:28:09,600
distribution and if a code has this

803
00:28:09,600 --> 00:28:12,000
property then we call it a non-valuable

804
00:28:12,000 --> 00:28:13,679
code

805
00:28:13,679 --> 00:28:15,440
okay so now that you've seen the

806
00:28:15,440 --> 00:28:17,440
security definition here are the goals

807
00:28:17,440 --> 00:28:19,760
of this work um basically what we're

808
00:28:19,760 --> 00:28:21,520
looking for here are efficient and

809
00:28:21,520 --> 00:28:22,640
explicit

810
00:28:22,640 --> 00:28:25,200
non-malleable codes

811
00:28:25,200 --> 00:28:27,360
um we want constructions in the plane

812
00:28:27,360 --> 00:28:30,960
model and from plausible assumptions um

813
00:28:30,960 --> 00:28:34,159
and finally we are interested in you

814
00:28:34,159 --> 00:28:36,159
know as broad of a tampering class as we

815
00:28:36,159 --> 00:28:38,559
possibly can get ideally we would like a

816
00:28:38,559 --> 00:28:40,399
tampering class that includes all

817
00:28:40,399 --> 00:28:42,880
arbitrary polynomial size circuits

818
00:28:42,880 --> 00:28:45,120
but unfortunately this is not possible

819
00:28:45,120 --> 00:28:46,880
so these goals are inherently

820
00:28:46,880 --> 00:28:48,480
conflicting

821
00:28:48,480 --> 00:28:50,640
and the reason for this is because there

822
00:28:50,640 --> 00:28:53,039
is a very simple attack which i can just

823
00:28:53,039 --> 00:28:54,640
show you here

824
00:28:54,640 --> 00:28:56,320
so basically the attack works as follows

825
00:28:56,320 --> 00:28:59,520
suppose that i'm encoding m i get c and

826
00:28:59,520 --> 00:29:01,279
now i can actually write down an

827
00:29:01,279 --> 00:29:03,520
efficient

828
00:29:03,520 --> 00:29:05,600
tampering function here

829
00:29:05,600 --> 00:29:08,640
which is just the following so it first

830
00:29:08,640 --> 00:29:11,679
decodes the code word then you get m

831
00:29:11,679 --> 00:29:14,080
you add one to this message then you

832
00:29:14,080 --> 00:29:16,240
re-encode it you get c-hat

833
00:29:16,240 --> 00:29:19,440
and then c-hat will be uh a codeword

834
00:29:19,440 --> 00:29:21,200
basically that that violates this

835
00:29:21,200 --> 00:29:23,840
property of non-temperability of the

836
00:29:23,840 --> 00:29:25,600
non-member code

837
00:29:25,600 --> 00:29:27,600
so the reason that this is efficient is

838
00:29:27,600 --> 00:29:29,520
of course because the code itself is

839
00:29:29,520 --> 00:29:32,720
efficient and so we can't hope to get

840
00:29:32,720 --> 00:29:35,120
security against an arbitrary polynomial

841
00:29:35,120 --> 00:29:36,880
size tampering class if we would like

842
00:29:36,880 --> 00:29:38,799
the code itself to be efficient

843
00:29:38,799 --> 00:29:40,720
so what is the next best thing that we

844
00:29:40,720 --> 00:29:42,880
can hope to get

845
00:29:42,880 --> 00:29:45,279
um well this is what we actually are

846
00:29:45,279 --> 00:29:46,720
going to try to do

847
00:29:46,720 --> 00:29:50,000
so for every constant c we will give an

848
00:29:50,000 --> 00:29:52,159
efficient non-nullable code

849
00:29:52,159 --> 00:29:56,159
uh against end to the c sized uh

850
00:29:56,159 --> 00:29:58,720
circuits or uh and to the seaside

851
00:29:58,720 --> 00:30:00,880
circuit tampering classes

852
00:30:00,880 --> 00:30:02,000
and um

853
00:30:02,000 --> 00:30:03,360
the problem that we have to somehow

854
00:30:03,360 --> 00:30:05,520
overcome is that this is actually known

855
00:30:05,520 --> 00:30:07,840
to imply polynomial circuit lower bounds

856
00:30:07,840 --> 00:30:10,159
which are of course notoriously hard to

857
00:30:10,159 --> 00:30:12,720
derive and to not have to do that what

858
00:30:12,720 --> 00:30:14,240
we're going to do is we're going to

859
00:30:14,240 --> 00:30:16,000
assume these circuit lower bounds and

860
00:30:16,000 --> 00:30:16,880
then

861
00:30:16,880 --> 00:30:18,480
reduce to one of them

862
00:30:18,480 --> 00:30:20,960
so that's the road map and before i go

863
00:30:20,960 --> 00:30:22,799
into our proof techniques any further

864
00:30:22,799 --> 00:30:24,000
let's actually

865
00:30:24,000 --> 00:30:26,000
have a brief look at some prior works

866
00:30:26,000 --> 00:30:28,559
and their limitations

867
00:30:28,559 --> 00:30:29,679
so

868
00:30:29,679 --> 00:30:32,480
there is one line of works which uh is

869
00:30:32,480 --> 00:30:34,480
in the crs model

870
00:30:34,480 --> 00:30:36,640
and basically these are non-explicit

871
00:30:36,640 --> 00:30:38,640
monte carlo constructions

872
00:30:38,640 --> 00:30:41,279
uh there is the cherokee guru swami

873
00:30:41,279 --> 00:30:43,440
construction from 2014 here it's in the

874
00:30:43,440 --> 00:30:45,919
crs model and also the construction of

875
00:30:45,919 --> 00:30:48,880
faust mukherjee venturi and vix

876
00:30:48,880 --> 00:30:51,039
also from 2014

877
00:30:51,039 --> 00:30:53,039
so as i said both of these constructions

878
00:30:53,039 --> 00:30:54,640
are in the crs model we would like to

879
00:30:54,640 --> 00:30:57,200
get a construction in the plane model

880
00:30:57,200 --> 00:30:59,919
and there is also a line of work on

881
00:30:59,919 --> 00:31:02,399
computationally secure constructions

882
00:31:02,399 --> 00:31:04,640
from relatively strong crypto so what do

883
00:31:04,640 --> 00:31:06,320
i mean by strong crypto here that this

884
00:31:06,320 --> 00:31:08,960
is cryptography that potentially has

885
00:31:08,960 --> 00:31:10,640
some instantiation

886
00:31:10,640 --> 00:31:12,720
in the plane model but currently

887
00:31:12,720 --> 00:31:14,640
requires the random oracle model so in

888
00:31:14,640 --> 00:31:17,120
some sense these constructions also are

889
00:31:17,120 --> 00:31:18,880
not explicit

890
00:31:18,880 --> 00:31:21,440
so here we have works of baal dakhman

891
00:31:21,440 --> 00:31:25,120
solit kulkani lenin malkin 2019 and also

892
00:31:25,120 --> 00:31:27,120
the works of dhakran zoled komangowski

893
00:31:27,120 --> 00:31:30,640
and pass from 2020.

894
00:31:30,640 --> 00:31:32,799
okay so now that we've seen some prior

895
00:31:32,799 --> 00:31:34,320
work let's actually have a look at the

896
00:31:34,320 --> 00:31:36,080
main hardness assumption that we are

897
00:31:36,080 --> 00:31:37,919
using and the theorem that we would like

898
00:31:37,919 --> 00:31:39,519
to prove

899
00:31:39,519 --> 00:31:42,000
so um to state the hardness assumption

900
00:31:42,000 --> 00:31:44,159
let's actually define e

901
00:31:44,159 --> 00:31:45,120
as

902
00:31:45,120 --> 00:31:47,440
the class of all uh

903
00:31:47,440 --> 00:31:49,200
languages that are decidable within

904
00:31:49,200 --> 00:31:50,960
deterministic or exponential

905
00:31:50,960 --> 00:31:52,799
deterministic time

906
00:31:52,799 --> 00:31:54,799
and the conjecture that we're going to

907
00:31:54,799 --> 00:31:58,000
use here says the following so

908
00:31:58,000 --> 00:32:00,080
we're going to require the existence of

909
00:32:00,080 --> 00:32:03,600
a constant gamma between 0 and 1 and

910
00:32:03,600 --> 00:32:06,159
some language in this class of languages

911
00:32:06,159 --> 00:32:07,039
e

912
00:32:07,039 --> 00:32:09,600
such that for almost all n l should be

913
00:32:09,600 --> 00:32:11,919
undecidable for non-deterministic

914
00:32:11,919 --> 00:32:16,240
circuits of size 2 to the gamma times n

915
00:32:16,240 --> 00:32:18,640
so some properties of this conjecture

916
00:32:18,640 --> 00:32:19,600
are

917
00:32:19,600 --> 00:32:21,440
that it's a worst case assumption it's

918
00:32:21,440 --> 00:32:23,519
actually in some sense doubly worst case

919
00:32:23,519 --> 00:32:25,600
it's very robust because we only require

920
00:32:25,600 --> 00:32:27,760
the existence of such a gamma and the

921
00:32:27,760 --> 00:32:29,760
existence of such a language so that

922
00:32:29,760 --> 00:32:31,519
makes it a very very robust assumption

923
00:32:31,519 --> 00:32:32,799
it's been used

924
00:32:32,799 --> 00:32:35,519
sometimes before in the literature also

925
00:32:35,519 --> 00:32:37,519
it also has the nice property of having

926
00:32:37,519 --> 00:32:39,200
some complete problems which is very

927
00:32:39,200 --> 00:32:40,840
useful to prove

928
00:32:40,840 --> 00:32:44,159
reductions and and finally it's

929
00:32:44,159 --> 00:32:46,080
to the best of our knowledge orthogonal

930
00:32:46,080 --> 00:32:48,159
to cryptography because it's not known

931
00:32:48,159 --> 00:32:49,279
to by

932
00:32:49,279 --> 00:32:52,399
the existence of one-way functions

933
00:32:52,399 --> 00:32:54,559
okay so now here is our theorem suppose

934
00:32:54,559 --> 00:32:56,640
that this conjecture is true

935
00:32:56,640 --> 00:32:58,640
then for all constant c

936
00:32:58,640 --> 00:33:00,880
we show that there exists an explicit

937
00:33:00,880 --> 00:33:03,279
non-malleable code for n to the c size

938
00:33:03,279 --> 00:33:04,480
circuits

939
00:33:04,480 --> 00:33:05,279
now

940
00:33:05,279 --> 00:33:07,200
i should say that our non-malleable

941
00:33:07,200 --> 00:33:09,039
codes actually have a slight correctness

942
00:33:09,039 --> 00:33:12,080
error which is uh n to the minus c

943
00:33:12,080 --> 00:33:13,519
and um

944
00:33:13,519 --> 00:33:15,440
an open question is if we can actually

945
00:33:15,440 --> 00:33:18,240
get something that

946
00:33:18,240 --> 00:33:20,480
is statistically or even perfectly

947
00:33:20,480 --> 00:33:22,720
correct

948
00:33:22,799 --> 00:33:25,120
okay so the key obstacle that we have to

949
00:33:25,120 --> 00:33:27,519
overcome in uh in our proof

950
00:33:27,519 --> 00:33:30,799
is that on the one hand the code ed has

951
00:33:30,799 --> 00:33:33,840
to be hard or enter the c-size circuits

952
00:33:33,840 --> 00:33:36,080
but on the other hand our reduction from

953
00:33:36,080 --> 00:33:38,240
conjecture one has to simulate the

954
00:33:38,240 --> 00:33:40,159
tampering experiment and these goals

955
00:33:40,159 --> 00:33:42,799
seem to conflict with each other

956
00:33:42,799 --> 00:33:45,679
so our solution is to actually have a

957
00:33:45,679 --> 00:33:47,760
non-deterministic reduction

958
00:33:47,760 --> 00:33:50,000
and to use a strong statistical tool

959
00:33:50,000 --> 00:33:53,840
which i'll introduce on the next slide

960
00:33:54,000 --> 00:33:56,159
so the strong statistical tool that

961
00:33:56,159 --> 00:33:58,799
we're starting from is a class of

962
00:33:58,799 --> 00:34:00,480
non-malleable codes against something

963
00:34:00,480 --> 00:34:04,559
known as bounded communication tampering

964
00:34:04,559 --> 00:34:06,240
and actually it's not only bounded

965
00:34:06,240 --> 00:34:07,919
communication but it's actually split

966
00:34:07,919 --> 00:34:10,879
stage tampering so uh this is going to

967
00:34:10,879 --> 00:34:12,320
look as follows in the tampering

968
00:34:12,320 --> 00:34:13,440
experiment

969
00:34:13,440 --> 00:34:15,918
the the code will now produce a left and

970
00:34:15,918 --> 00:34:17,839
the right code word it will give the

971
00:34:17,839 --> 00:34:19,918
left codeword to alice and the write

972
00:34:19,918 --> 00:34:21,520
code word to bop

973
00:34:21,520 --> 00:34:23,199
and now they're allowed to talk to each

974
00:34:23,199 --> 00:34:24,879
other but the transcript of their

975
00:34:24,879 --> 00:34:27,520
communication has to be much smaller

976
00:34:27,520 --> 00:34:28,639
than

977
00:34:28,639 --> 00:34:30,960
either of these code words

978
00:34:30,960 --> 00:34:33,040
and in the end they're going to output

979
00:34:33,040 --> 00:34:35,760
their respective uh tampered half of

980
00:34:35,760 --> 00:34:38,000
their code words and um

981
00:34:38,000 --> 00:34:39,599
the the nice thing about this class of

982
00:34:39,599 --> 00:34:41,280
tampering attacks is that we actually

983
00:34:41,280 --> 00:34:44,960
know explicit nmcs uh for these for

984
00:34:44,960 --> 00:34:46,879
these tampering classes in the standard

985
00:34:46,879 --> 00:34:48,719
model and this is where we sort of start

986
00:34:48,719 --> 00:34:50,399
from

987
00:34:50,399 --> 00:34:52,399
okay so here is our construction a

988
00:34:52,399 --> 00:34:54,079
little bit more concretely for end to

989
00:34:54,079 --> 00:34:56,079
the c-side circuits

990
00:34:56,079 --> 00:34:59,359
so we start from um a non-malleable code

991
00:34:59,359 --> 00:35:01,200
against the class of tampering attacks

992
00:35:01,200 --> 00:35:03,200
that i just showed you so let's denote

993
00:35:03,200 --> 00:35:06,160
this code as util detailed

994
00:35:06,160 --> 00:35:08,000
and we also start from a very special

995
00:35:08,000 --> 00:35:09,920
prg this is actually

996
00:35:09,920 --> 00:35:12,320
the reason that we required this

997
00:35:12,320 --> 00:35:14,079
this conjecture that that's where we

998
00:35:14,079 --> 00:35:17,280
really needed to instantiate this prg um

999
00:35:17,280 --> 00:35:19,680
so this is from prior work of course but

1000
00:35:19,680 --> 00:35:22,960
this prg is a special prg that has a

1001
00:35:22,960 --> 00:35:25,119
property of being uniform with respect

1002
00:35:25,119 --> 00:35:27,520
to deterministic circuits excuse me

1003
00:35:27,520 --> 00:35:29,599
non-deterministic circuits size and to

1004
00:35:29,599 --> 00:35:31,680
the c so i should point out here that

1005
00:35:31,680 --> 00:35:33,920
this of course means that the prg is

1006
00:35:33,920 --> 00:35:36,480
actually not evaluatable or

1007
00:35:36,480 --> 00:35:38,480
non-deterministic circuits of the size

1008
00:35:38,480 --> 00:35:40,079
because if you can evaluate it then of

1009
00:35:40,079 --> 00:35:42,000
course you can distinguish it from

1010
00:35:42,000 --> 00:35:43,119
random

1011
00:35:43,119 --> 00:35:44,960
so you actually need a larger circuit

1012
00:35:44,960 --> 00:35:47,359
size to even evaluate this prg so keep

1013
00:35:47,359 --> 00:35:48,800
that in mind for the next couple of

1014
00:35:48,800 --> 00:35:50,000
slides

1015
00:35:50,000 --> 00:35:52,400
so now here's our code so on input x

1016
00:35:52,400 --> 00:35:55,119
it's going to output a seat and

1017
00:35:55,119 --> 00:35:57,280
a right half of the code word cb such

1018
00:35:57,280 --> 00:35:59,760
that cb corresponds to the right half of

1019
00:35:59,760 --> 00:36:03,200
the code word of uh applying e tilde to

1020
00:36:03,200 --> 00:36:04,560
the input x

1021
00:36:04,560 --> 00:36:07,920
and the prg so yeah the prg evaluated on

1022
00:36:07,920 --> 00:36:10,400
s corresponds to the left half of a code

1023
00:36:10,400 --> 00:36:13,200
word if we input it to this

1024
00:36:13,200 --> 00:36:15,440
encoding until then and in our work we

1025
00:36:15,440 --> 00:36:17,280
actually show an efficient way of doing

1026
00:36:17,280 --> 00:36:18,800
this

1027
00:36:18,800 --> 00:36:19,680
okay

1028
00:36:19,680 --> 00:36:21,680
so now the decoding of course follows

1029
00:36:21,680 --> 00:36:23,760
quite straightforwardly you just apply

1030
00:36:23,760 --> 00:36:25,599
the prg to the left half of the code

1031
00:36:25,599 --> 00:36:28,320
word and then you apply the original

1032
00:36:28,320 --> 00:36:29,680
vtilda

1033
00:36:29,680 --> 00:36:31,119
decoding function

1034
00:36:31,119 --> 00:36:34,000
so this is our construction very roughly

1035
00:36:34,000 --> 00:36:36,400
and the proof idea now

1036
00:36:36,400 --> 00:36:38,800
i mean i cannot go into details here but

1037
00:36:38,800 --> 00:36:41,280
i'm just going to sketch a couple of the

1038
00:36:41,280 --> 00:36:43,520
very very high level ideas for you so

1039
00:36:43,520 --> 00:36:46,240
the proof idea is to basically turn an

1040
00:36:46,240 --> 00:36:47,359
attack

1041
00:36:47,359 --> 00:36:50,640
on our code into an extinguisher against

1042
00:36:50,640 --> 00:36:52,400
this underlying prg

1043
00:36:52,400 --> 00:36:55,119
and here is how this is going to work so

1044
00:36:55,119 --> 00:36:57,599
we know that if the code word is

1045
00:36:57,599 --> 00:37:00,000
generated according to the

1046
00:37:00,000 --> 00:37:02,960
underlying split state non-malable code

1047
00:37:02,960 --> 00:37:05,680
then this is secure

1048
00:37:05,680 --> 00:37:08,240
because we have a construction for that

1049
00:37:08,240 --> 00:37:09,040
but

1050
00:37:09,040 --> 00:37:11,280
if now we de-randomize this code by

1051
00:37:11,280 --> 00:37:13,200
generating generating the left half of

1052
00:37:13,200 --> 00:37:16,000
this code word as applying the prg to

1053
00:37:16,000 --> 00:37:18,320
the seat then actually there is an

1054
00:37:18,320 --> 00:37:20,720
efficient tampering attack and this

1055
00:37:20,720 --> 00:37:22,800
attack uses the fact

1056
00:37:22,800 --> 00:37:23,680
that

1057
00:37:23,680 --> 00:37:26,240
alice in this experiment can send over

1058
00:37:26,240 --> 00:37:28,000
the seat

1059
00:37:28,000 --> 00:37:30,480
which is short so she doesn't exceed her

1060
00:37:30,480 --> 00:37:33,280
bound on the communication here and now

1061
00:37:33,280 --> 00:37:36,160
bob can apply his efficient tampering

1062
00:37:36,160 --> 00:37:38,960
function f locally on s and his half of

1063
00:37:38,960 --> 00:37:41,359
the code word and send back an also

1064
00:37:41,359 --> 00:37:43,200
short seed as tilde which is tampered

1065
00:37:43,200 --> 00:37:46,240
and now alice can evaluate the prg

1066
00:37:46,240 --> 00:37:48,839
locally and both of them can

1067
00:37:48,839 --> 00:37:52,079
output uh their respective house of

1068
00:37:52,079 --> 00:37:54,240
their tempered code words

1069
00:37:54,240 --> 00:37:55,920
now intuitively this should lead to a

1070
00:37:55,920 --> 00:37:58,560
distinguisher on prg on the prg because

1071
00:37:58,560 --> 00:38:00,400
uh these two worlds

1072
00:38:00,400 --> 00:38:02,560
uh are not the same in one world we have

1073
00:38:02,560 --> 00:38:04,560
a secure non-malibu code whereas in the

1074
00:38:04,560 --> 00:38:06,480
other world it's completely broken so

1075
00:38:06,480 --> 00:38:08,400
somehow this should lead to a

1076
00:38:08,400 --> 00:38:11,040
distinguishing attack on the prg and

1077
00:38:11,040 --> 00:38:12,960
this is exactly actually

1078
00:38:12,960 --> 00:38:14,720
what we do and i'm going to show this in

1079
00:38:14,720 --> 00:38:16,720
the next step so i should point out a

1080
00:38:16,720 --> 00:38:18,800
couple of things though first first of

1081
00:38:18,800 --> 00:38:21,680
all alice is uh computationally much

1082
00:38:21,680 --> 00:38:24,240
more expensive than bob because she has

1083
00:38:24,240 --> 00:38:27,200
to evaluate this expensive prg on her

1084
00:38:27,200 --> 00:38:29,200
side whereas bob is very efficient

1085
00:38:29,200 --> 00:38:31,119
because all that he has to do is

1086
00:38:31,119 --> 00:38:33,760
evaluate the tampering function

1087
00:38:33,760 --> 00:38:36,720
okay and so this leads us to consider

1088
00:38:36,720 --> 00:38:38,800
actually a class of protocols called

1089
00:38:38,800 --> 00:38:41,200
merlin arthur protocols

1090
00:38:41,200 --> 00:38:43,920
where on the left side we have a wizard

1091
00:38:43,920 --> 00:38:46,079
called merlin and he's going to act as

1092
00:38:46,079 --> 00:38:47,839
the prover in this protocol and he has

1093
00:38:47,839 --> 00:38:49,920
unbounded communication power

1094
00:38:49,920 --> 00:38:52,480
on the right side we have arthur who is

1095
00:38:52,480 --> 00:38:54,079
supposed to be efficient because he's

1096
00:38:54,079 --> 00:38:56,720
only human and roughly speaking alice

1097
00:38:56,720 --> 00:38:58,880
from my previous slide and bob from my

1098
00:38:58,880 --> 00:39:00,640
previous slide are going to correspond

1099
00:39:00,640 --> 00:39:02,400
to these two entities in this in this

1100
00:39:02,400 --> 00:39:05,040
slide here okay so bob was efficient so

1101
00:39:05,040 --> 00:39:06,960
arthur is efficient alice was a little

1102
00:39:06,960 --> 00:39:08,720
bit inefficient but that's okay because

1103
00:39:08,720 --> 00:39:10,079
now she's going to be merlin in this

1104
00:39:10,079 --> 00:39:11,440
protocol

1105
00:39:11,440 --> 00:39:12,720
um

1106
00:39:12,720 --> 00:39:15,440
okay so roughly speaking the protocol

1107
00:39:15,440 --> 00:39:17,599
that we built is supposed to accept

1108
00:39:17,599 --> 00:39:20,000
tuples of the form s comma p or g

1109
00:39:20,000 --> 00:39:22,240
evaluated on s and it's supposed to

1110
00:39:22,240 --> 00:39:24,800
reject tuples of the form s

1111
00:39:24,800 --> 00:39:26,800
and a uniform string

1112
00:39:26,800 --> 00:39:28,560
so we don't get perfect correctness or

1113
00:39:28,560 --> 00:39:30,960
soundness here but that's actually okay

1114
00:39:30,960 --> 00:39:33,839
uh we don't need that and um as i said

1115
00:39:33,839 --> 00:39:35,839
merlin has unbounded so it can easily

1116
00:39:35,839 --> 00:39:37,920
evaluate the prg whereas arthro is

1117
00:39:37,920 --> 00:39:39,440
efficient because it only has to

1118
00:39:39,440 --> 00:39:41,520
evaluate f

1119
00:39:41,520 --> 00:39:43,200
now finally uh once we have this

1120
00:39:43,200 --> 00:39:45,119
protocol we can actually turn this into

1121
00:39:45,119 --> 00:39:47,280
a non-deterministic distinguisher for

1122
00:39:47,280 --> 00:39:50,560
the prg via node techniques

1123
00:39:50,560 --> 00:39:52,240
and yeah that's

1124
00:39:52,240 --> 00:39:53,839
the proof sketch for for our main

1125
00:39:53,839 --> 00:39:55,680
results if you're interested then please

1126
00:39:55,680 --> 00:39:57,599
have a look at our paper and that

1127
00:39:57,599 --> 00:40:00,960
concludes the talk thanks

1128
00:40:01,520 --> 00:40:03,119
thanks for this great talk we have time

1129
00:40:03,119 --> 00:40:05,599
for one or two questions

1130
00:40:05,599 --> 00:40:10,040
i don't see questions on zoom

1131
00:40:10,160 --> 00:40:11,839
so we have a short question so your

1132
00:40:11,839 --> 00:40:14,240
decoder also needs n2 to see space right

1133
00:40:14,240 --> 00:40:16,000
so is there any chance of maybe using

1134
00:40:16,000 --> 00:40:18,319
prf since that prg is too old

1135
00:40:18,319 --> 00:40:20,400
uh that's a good question

1136
00:40:20,400 --> 00:40:22,480
so sorry what's the question actually so

1137
00:40:22,480 --> 00:40:26,480
you know any chance to use prfs instead

1138
00:40:27,440 --> 00:40:29,680
that's

1139
00:40:32,160 --> 00:40:35,599
no but maybe you can use prg from from a

1140
00:40:35,599 --> 00:40:37,040
little bit of a weaker complexity

1141
00:40:37,040 --> 00:40:39,520
assumption because you could maybe uh

1142
00:40:39,520 --> 00:40:41,359
you could maybe use a space

1143
00:40:41,359 --> 00:40:43,200
some kind of space constraint so that

1144
00:40:43,200 --> 00:40:45,119
that might be possible

1145
00:40:45,119 --> 00:40:48,240
but i don't know i'm not sure

1146
00:40:49,040 --> 00:40:52,720
okay if there's no more questions then

1147
00:40:52,720 --> 00:40:57,480
maybe the third speaker can come up

1148
00:42:07,040 --> 00:42:09,520
sorry our third talk is on short leakage

1149
00:42:09,520 --> 00:42:10,880
resilient and non-malleable secret

1150
00:42:10,880 --> 00:42:13,200
sharing schemes by nishant chandra

1151
00:42:13,200 --> 00:42:14,640
havana

1152
00:42:14,640 --> 00:42:17,040
kanu

1153
00:42:20,560 --> 00:42:22,640
is giving the talk

1154
00:42:22,640 --> 00:42:25,879
thank you

1155
00:42:33,520 --> 00:42:35,359
uh yeah uh thank you for the

1156
00:42:35,359 --> 00:42:37,839
introduction so um today i'm going to be

1157
00:42:37,839 --> 00:42:40,079
telling you about how we end up building

1158
00:42:40,079 --> 00:42:42,160
shortly resilient and non-maple secret

1159
00:42:42,160 --> 00:42:44,560
sharing schemes so uh this is joint work

1160
00:42:44,560 --> 00:42:46,240
with my wonderful co-authors nishan

1161
00:42:46,240 --> 00:42:49,599
chandran khan kriti and so

1162
00:42:49,599 --> 00:42:50,880
um

1163
00:42:50,880 --> 00:42:52,880
let's start by looking at uh secret

1164
00:42:52,880 --> 00:42:54,640
sharing schemes which we all know about

1165
00:42:54,640 --> 00:42:56,800
and love uh this is

1166
00:42:56,800 --> 00:42:59,040
was introduced in 1979 by charmed and

1167
00:42:59,040 --> 00:43:00,400
bleakly

1168
00:43:00,400 --> 00:43:02,079
so the goal of this protocol just to

1169
00:43:02,079 --> 00:43:05,119
recall is there's a dealer bob who has

1170
00:43:05,119 --> 00:43:07,119
some secret and doesn't want to keep the

1171
00:43:07,119 --> 00:43:09,680
secret in its entirety instead wants to

1172
00:43:09,680 --> 00:43:12,160
split it into amongst n parties into

1173
00:43:12,160 --> 00:43:14,880
these shares s1 through sn and the kind

1174
00:43:14,880 --> 00:43:17,040
of property that you seek from these are

1175
00:43:17,040 --> 00:43:18,000
that

1176
00:43:18,000 --> 00:43:20,480
if you take t amongst these n parties

1177
00:43:20,480 --> 00:43:22,640
and use their shares it would be enough

1178
00:43:22,640 --> 00:43:24,400
for you to reconstruct and recover the

1179
00:43:24,400 --> 00:43:27,520
secret so this is basic correctness um

1180
00:43:27,520 --> 00:43:29,839
and t here is some threshold basically

1181
00:43:29,839 --> 00:43:31,119
that you can set

1182
00:43:31,119 --> 00:43:33,440
and it's less than equal to n

1183
00:43:33,440 --> 00:43:35,280
and on the other end you want a privacy

1184
00:43:35,280 --> 00:43:37,359
guarantee that if less than t parties

1185
00:43:37,359 --> 00:43:39,040
are corrupted by some adversary and he

1186
00:43:39,040 --> 00:43:41,440
procures those shares uh you don't want

1187
00:43:41,440 --> 00:43:43,599
anything to be leaked about the secret

1188
00:43:43,599 --> 00:43:45,520
so how do we capture this a bit more

1189
00:43:45,520 --> 00:43:46,800
firmly

1190
00:43:46,800 --> 00:43:48,640
we do that by saying that whether you

1191
00:43:48,640 --> 00:43:51,680
pick a secret s or a secret s prime uh

1192
00:43:51,680 --> 00:43:53,760
and consider a set of less than t shares

1193
00:43:53,760 --> 00:43:55,200
corresponding to s

1194
00:43:55,200 --> 00:43:56,319
that looks

1195
00:43:56,319 --> 00:43:58,319
indistinguishable or close enough to the

1196
00:43:58,319 --> 00:44:00,720
corresponding set of shares for s prime

1197
00:44:00,720 --> 00:44:02,240
so throughout our talk will be in the

1198
00:44:02,240 --> 00:44:04,079
information theoretic setting which

1199
00:44:04,079 --> 00:44:06,400
means the closeness that i'll be talking

1200
00:44:06,400 --> 00:44:09,680
about would be statistical distance

1201
00:44:09,680 --> 00:44:10,880
so about

1202
00:44:10,880 --> 00:44:13,839
uh two decades post the introduction um

1203
00:44:13,839 --> 00:44:15,440
came about this class of attacks that

1204
00:44:15,440 --> 00:44:16,720
have been looked at widely called

1205
00:44:16,720 --> 00:44:19,359
leakage attacks um it was introduced by

1206
00:44:19,359 --> 00:44:21,760
kosher and

1207
00:44:21,760 --> 00:44:23,680
in the context of secret sharing this

1208
00:44:23,680 --> 00:44:25,599
particularly led to a natural question

1209
00:44:25,599 --> 00:44:27,920
what if in addition to the t minus one

1210
00:44:27,920 --> 00:44:30,319
shares that adversary procures he's also

1211
00:44:30,319 --> 00:44:32,480
allowed to get uh some bounded bits of

1212
00:44:32,480 --> 00:44:34,640
leakage from the remaining shares

1213
00:44:34,640 --> 00:44:36,880
and turns out this is not uh something

1214
00:44:36,880 --> 00:44:38,880
that directly gives security in the

1215
00:44:38,880 --> 00:44:40,800
standard secret sharing schemes so in

1216
00:44:40,800 --> 00:44:43,040
fact a bit more formally the xiaomi

1217
00:44:43,040 --> 00:44:45,119
secret sharing scheme that we all use

1218
00:44:45,119 --> 00:44:47,760
widely uh in several applications

1219
00:44:47,760 --> 00:44:50,240
breaks in fact if you give even one bit

1220
00:44:50,240 --> 00:44:52,560
of leakage on the rest of the shares in

1221
00:44:52,560 --> 00:44:54,400
addition to the t minus one full shares

1222
00:44:54,400 --> 00:44:55,760
so this was shown by guru swami and

1223
00:44:55,760 --> 00:44:57,839
buddha's in 2016.

1224
00:44:57,839 --> 00:45:00,160
and uh naturally this is what led to a

1225
00:45:00,160 --> 00:45:02,240
formal study of leakage in secret

1226
00:45:02,240 --> 00:45:04,880
sharing schemes

1227
00:45:04,880 --> 00:45:06,640
and basically in addition to the

1228
00:45:06,640 --> 00:45:09,200
standard correctness now instead of just

1229
00:45:09,200 --> 00:45:10,960
seeking privacy we want something

1230
00:45:10,960 --> 00:45:12,640
stronger which we call leakage

1231
00:45:12,640 --> 00:45:15,119
resilience so recall the privacy only

1232
00:45:15,119 --> 00:45:16,800
guarantee that if you give t minus 1

1233
00:45:16,800 --> 00:45:18,880
shares there should be nothing leaked

1234
00:45:18,880 --> 00:45:20,640
now instead we we want to capture

1235
00:45:20,640 --> 00:45:22,800
something that can be given about all

1236
00:45:22,800 --> 00:45:24,480
the shares

1237
00:45:24,480 --> 00:45:26,240
so particularly

1238
00:45:26,240 --> 00:45:28,400
if i have to generally capture it i'll

1239
00:45:28,400 --> 00:45:30,720
pick some function family that captures

1240
00:45:30,720 --> 00:45:32,960
my leakage and the privacy as well

1241
00:45:32,960 --> 00:45:34,800
potentially will get to the specific

1242
00:45:34,800 --> 00:45:36,079
function family

1243
00:45:36,079 --> 00:45:38,000
but for this function family whenever i

1244
00:45:38,000 --> 00:45:39,280
pick a function

1245
00:45:39,280 --> 00:45:40,960
and apply it on all of the shares

1246
00:45:40,960 --> 00:45:43,680
together and output it this f applied on

1247
00:45:43,680 --> 00:45:46,160
the shares which is my leakage now it

1248
00:45:46,160 --> 00:45:47,680
captures essentially the leakage that

1249
00:45:47,680 --> 00:45:49,040
should give no information about the

1250
00:45:49,040 --> 00:45:50,319
secret

1251
00:45:50,319 --> 00:45:51,040
so

1252
00:45:51,040 --> 00:45:52,800
as before this was captured by saying

1253
00:45:52,800 --> 00:45:55,680
for any two distinct secrets s prime the

1254
00:45:55,680 --> 00:45:58,000
f applied on shares of s looks close

1255
00:45:58,000 --> 00:46:00,720
enough to f applied on the shares of s1

1256
00:46:00,720 --> 00:46:01,839
so

1257
00:46:01,839 --> 00:46:03,520
what is the kind of family that are

1258
00:46:03,520 --> 00:46:05,599
natural in the setup something that also

1259
00:46:05,599 --> 00:46:08,400
captures privacy uh that we'll get to in

1260
00:46:08,400 --> 00:46:09,599
the next slide

1261
00:46:09,599 --> 00:46:11,280
so more generally what are the

1262
00:46:11,280 --> 00:46:14,640
parameters of interest um as with

1263
00:46:14,640 --> 00:46:16,960
regular secret sharing schemes the first

1264
00:46:16,960 --> 00:46:19,119
uh crucial parameter of interest is

1265
00:46:19,119 --> 00:46:21,599
share size right so for regular swami

1266
00:46:21,599 --> 00:46:22,960
secret sharing scheme we know we have

1267
00:46:22,960 --> 00:46:24,720
the optimal share size which is the

1268
00:46:24,720 --> 00:46:26,960
message length uh particularly it

1269
00:46:26,960 --> 00:46:28,560
measures essentially the size of the

1270
00:46:28,560 --> 00:46:30,960
largest share amongst all the ensures

1271
00:46:30,960 --> 00:46:33,359
and in the leakage resilience setup the

1272
00:46:33,359 --> 00:46:36,480
best share size one can hope for uh is

1273
00:46:36,480 --> 00:46:39,040
actually the message length plus mu

1274
00:46:39,040 --> 00:46:41,280
where mu is the bounded number of bits

1275
00:46:41,280 --> 00:46:44,079
of leakage uh that you can give per

1276
00:46:44,079 --> 00:46:45,920
share essentially so this is the best

1277
00:46:45,920 --> 00:46:47,359
you can hope for in the leakage net

1278
00:46:47,359 --> 00:46:49,440
setup

1279
00:46:49,440 --> 00:46:51,520
and second is the leakage family which i

1280
00:46:51,520 --> 00:46:53,440
promised to mention about

1281
00:46:53,440 --> 00:46:54,400
so

1282
00:46:54,400 --> 00:46:56,319
the particular family of interest which

1283
00:46:56,319 --> 00:46:57,680
would be looking at today is called the

1284
00:46:57,680 --> 00:46:59,280
local leakage family which was one of

1285
00:46:59,280 --> 00:47:01,040
the first studied ones

1286
00:47:01,040 --> 00:47:02,960
and uh here essentially

1287
00:47:02,960 --> 00:47:04,640
if i look at it uh

1288
00:47:04,640 --> 00:47:06,319
from the perspective of an adversary

1289
00:47:06,319 --> 00:47:08,800
challenger game uh the adversary sense

1290
00:47:08,800 --> 00:47:11,200
this function which now comprises of n

1291
00:47:11,200 --> 00:47:13,119
separate functions n being the number of

1292
00:47:13,119 --> 00:47:14,720
shares that you would have

1293
00:47:14,720 --> 00:47:16,960
and the way the leakage

1294
00:47:16,960 --> 00:47:19,839
works in this family is basically each

1295
00:47:19,839 --> 00:47:22,400
fi acts on only one share which is the

1296
00:47:22,400 --> 00:47:24,559
si so s1 through sn are the shares

1297
00:47:24,559 --> 00:47:26,079
corresponding to s

1298
00:47:26,079 --> 00:47:28,720
and you return basically f i of s i as

1299
00:47:28,720 --> 00:47:30,960
the share so note here the adversary

1300
00:47:30,960 --> 00:47:32,640
sends all these functions in a single

1301
00:47:32,640 --> 00:47:34,640
shot so it's a non-adaptive

1302
00:47:34,640 --> 00:47:37,440
uh way of sending the leakage functions

1303
00:47:37,440 --> 00:47:39,359
and uh each function acts on a single

1304
00:47:39,359 --> 00:47:40,880
share so it's kind of independent

1305
00:47:40,880 --> 00:47:42,400
leakage on each share

1306
00:47:42,400 --> 00:47:44,640
so particularly this can this captures

1307
00:47:44,640 --> 00:47:46,079
privacy because

1308
00:47:46,079 --> 00:47:48,000
uh t minus one of these functions can

1309
00:47:48,000 --> 00:47:49,920
essentially be the identity functions so

1310
00:47:49,920 --> 00:47:51,920
they will just give out the full shares

1311
00:47:51,920 --> 00:47:53,760
and the remaining functions would be

1312
00:47:53,760 --> 00:47:55,839
giving out some new bits new bounded

1313
00:47:55,839 --> 00:47:56,960
bits from the

1314
00:47:56,960 --> 00:47:57,839
uh

1315
00:47:57,839 --> 00:48:00,480
the share that takes such input

1316
00:48:00,480 --> 00:48:02,240
so this is basically the local leakage

1317
00:48:02,240 --> 00:48:04,240
family that would be of concern for our

1318
00:48:04,240 --> 00:48:06,559
talk today but uh in literature people

1319
00:48:06,559 --> 00:48:08,480
have studied stronger leakage families

1320
00:48:08,480 --> 00:48:10,079
thereafter

1321
00:48:10,079 --> 00:48:12,240
as well

1322
00:48:12,240 --> 00:48:14,800
so that brings me to prior works what is

1323
00:48:14,800 --> 00:48:17,359
what is known in this realm

1324
00:48:17,359 --> 00:48:18,960
there has been a long line of research

1325
00:48:18,960 --> 00:48:20,960
since the introduction of these schemes

1326
00:48:20,960 --> 00:48:21,839
and

1327
00:48:21,839 --> 00:48:24,400
broadly most of these works as i

1328
00:48:24,400 --> 00:48:25,920
mentioned focus on strengthening the

1329
00:48:25,920 --> 00:48:28,000
leakage model because it is truly an

1330
00:48:28,000 --> 00:48:30,000
important aspect to get the strongest

1331
00:48:30,000 --> 00:48:32,880
possible leakage model in the setup so

1332
00:48:32,880 --> 00:48:34,400
they've studied adaptive and joint

1333
00:48:34,400 --> 00:48:37,359
versions of what i just presented to you

1334
00:48:37,359 --> 00:48:39,839
however uh for all these schemes the

1335
00:48:39,839 --> 00:48:42,319
share size of of the leakages and secret

1336
00:48:42,319 --> 00:48:44,880
sharing is omega of message length so

1337
00:48:44,880 --> 00:48:46,880
um particularly they have polynomial

1338
00:48:46,880 --> 00:48:49,760
blow up or like it's really large share

1339
00:48:49,760 --> 00:48:50,800
size

1340
00:48:50,800 --> 00:48:52,240
so

1341
00:48:52,240 --> 00:48:54,800
our focus is to first start and look at

1342
00:48:54,800 --> 00:48:56,559
the local leakage model

1343
00:48:56,559 --> 00:48:59,040
and see what is known about the the

1344
00:48:59,040 --> 00:49:00,400
trade-off between the share size and

1345
00:49:00,400 --> 00:49:03,040
leakage in the known schemes so broadly

1346
00:49:03,040 --> 00:49:04,960
in this local leakage model there are

1347
00:49:04,960 --> 00:49:07,200
two lines of work the first which look

1348
00:49:07,200 --> 00:49:09,040
at the xiaomi secret sharing scheme in

1349
00:49:09,040 --> 00:49:11,440
itself because it's widely in use so the

1350
00:49:11,440 --> 00:49:13,040
natural question to ask is does shami

1351
00:49:13,040 --> 00:49:15,359
secret sharing scheme in itself satisfy

1352
00:49:15,359 --> 00:49:16,960
some form of leakage resilience to begin

1353
00:49:16,960 --> 00:49:18,000
with

1354
00:49:18,000 --> 00:49:20,319
in some setup at least and turns out it

1355
00:49:20,319 --> 00:49:22,480
does so in this work basically

1356
00:49:22,480 --> 00:49:23,760
um

1357
00:49:23,760 --> 00:49:26,160
what is shown is for a restricted setup

1358
00:49:26,160 --> 00:49:27,680
where you consider a large

1359
00:49:27,680 --> 00:49:29,280
characteristic field

1360
00:49:29,280 --> 00:49:31,839
a large number of parties and also you

1361
00:49:31,839 --> 00:49:33,520
restrict the

1362
00:49:33,520 --> 00:49:35,119
full share corruptions to be only a

1363
00:49:35,119 --> 00:49:36,720
constant number so only constant number

1364
00:49:36,720 --> 00:49:38,559
of full shares are given

1365
00:49:38,559 --> 00:49:40,880
under these restrictions there are two

1366
00:49:40,880 --> 00:49:42,640
trade-offs you can get so if you

1367
00:49:42,640 --> 00:49:44,720
restrict the threshold to be at least n

1368
00:49:44,720 --> 00:49:46,400
minus o of log n

1369
00:49:46,400 --> 00:49:48,559
n is the number of parties recall

1370
00:49:48,559 --> 00:49:51,040
then the xiaomi secret sharing allows

1371
00:49:51,040 --> 00:49:53,280
you to leak one fourth of the bits uh

1372
00:49:53,280 --> 00:49:54,800
from each of the share so we are in the

1373
00:49:54,800 --> 00:49:56,880
local leakage model each each leakage is

1374
00:49:56,880 --> 00:49:59,440
from a share independently so this will

1375
00:49:59,440 --> 00:50:01,040
allow you to leak one fourth of the bits

1376
00:50:01,040 --> 00:50:03,359
from each of those shares

1377
00:50:03,359 --> 00:50:05,680
on the other hand if i want the

1378
00:50:05,680 --> 00:50:08,160
threshold to be alpha n

1379
00:50:08,160 --> 00:50:10,240
for some alpha

1380
00:50:10,240 --> 00:50:11,839
there however you will only be able to

1381
00:50:11,839 --> 00:50:14,400
leak constant number of bits per share

1382
00:50:14,400 --> 00:50:16,319
so this is the kind of trade-off that

1383
00:50:16,319 --> 00:50:18,800
you have from a secret sharing scheme

1384
00:50:18,800 --> 00:50:22,000
in this restricted setup

1385
00:50:22,319 --> 00:50:24,960
and is this the best you can do

1386
00:50:24,960 --> 00:50:27,359
in some sense it is shown to be the best

1387
00:50:27,359 --> 00:50:29,040
you can do with xiaomi secret sharing

1388
00:50:29,040 --> 00:50:30,000
scheme

1389
00:50:30,000 --> 00:50:30,800
so

1390
00:50:30,800 --> 00:50:32,559
this is uh

1391
00:50:32,559 --> 00:50:34,720
what led to the question can we get like

1392
00:50:34,720 --> 00:50:36,400
the optimal trade-off between the

1393
00:50:36,400 --> 00:50:38,640
leakage and the share size

1394
00:50:38,640 --> 00:50:40,800
and that led to the other line of

1395
00:50:40,800 --> 00:50:42,400
constructions in this realm which was

1396
00:50:42,400 --> 00:50:44,400
building generic compilers that taken

1397
00:50:44,400 --> 00:50:47,760
any secret sharing scheme uh and convert

1398
00:50:47,760 --> 00:50:49,359
it into a leakages line secret sharing

1399
00:50:49,359 --> 00:50:51,599
that works for this leakage model so

1400
00:50:51,599 --> 00:50:53,599
this was uh particularly for the local

1401
00:50:53,599 --> 00:50:55,599
leakage model these two works build a

1402
00:50:55,599 --> 00:50:59,119
generic compiler and amongst these uh

1403
00:50:59,119 --> 00:51:02,400
the work of uh sv19 show best trade-off

1404
00:51:02,400 --> 00:51:05,119
known for the setup so particularly for

1405
00:51:05,119 --> 00:51:06,880
any arbitrary number of parties and

1406
00:51:06,880 --> 00:51:08,480
threshold that you can consider

1407
00:51:08,480 --> 00:51:10,640
what they show is the share size that

1408
00:51:10,640 --> 00:51:12,240
you can get is three times the message

1409
00:51:12,240 --> 00:51:13,839
length plus mu so there's a factor of

1410
00:51:13,839 --> 00:51:14,960
three blow up

1411
00:51:14,960 --> 00:51:18,079
and uh however you can get uh any like

1412
00:51:18,079 --> 00:51:19,680
so the new bits of leakage to get get

1413
00:51:19,680 --> 00:51:22,160
per share that can go for any uh

1414
00:51:22,160 --> 00:51:24,079
arbitrarily close to one minus

1415
00:51:24,079 --> 00:51:25,599
over one times the message length so

1416
00:51:25,599 --> 00:51:28,319
this is basically in some sense the best

1417
00:51:28,319 --> 00:51:30,480
leakage you can hope for but the share

1418
00:51:30,480 --> 00:51:32,559
size is uh blown up

1419
00:51:32,559 --> 00:51:34,640
by a factor of three

1420
00:51:34,640 --> 00:51:35,440
so

1421
00:51:35,440 --> 00:51:36,720
um

1422
00:51:36,720 --> 00:51:37,440
the

1423
00:51:37,440 --> 00:51:40,720
known lower bounds for for what is the

1424
00:51:40,720 --> 00:51:42,960
trade-off between share size and leakage

1425
00:51:42,960 --> 00:51:45,280
doesn't apply to the generic compilers

1426
00:51:45,280 --> 00:51:47,440
and hence the scope for getting really

1427
00:51:47,440 --> 00:51:49,680
the truest optimal trade-off between the

1428
00:51:49,680 --> 00:51:51,760
share size and leakage

1429
00:51:51,760 --> 00:51:53,760
is open somewhat only in the generic

1430
00:51:53,760 --> 00:51:56,240
generic compiler context and so we'll be

1431
00:51:56,240 --> 00:51:57,599
looking at that and the particular

1432
00:51:57,599 --> 00:51:59,680
question we ask in this work is can we

1433
00:51:59,680 --> 00:52:01,119
actually get a leakage indian secure

1434
00:52:01,119 --> 00:52:03,520
sharing scheme that matches what we know

1435
00:52:03,520 --> 00:52:04,720
is the best

1436
00:52:04,720 --> 00:52:06,880
and gives an efficient scheme so can we

1437
00:52:06,880 --> 00:52:08,800
get the optimal share size and leakage

1438
00:52:08,800 --> 00:52:09,920
trade-off

1439
00:52:09,920 --> 00:52:11,680
particularly in the local leakage model

1440
00:52:11,680 --> 00:52:12,880
at least

1441
00:52:12,880 --> 00:52:13,680
so

1442
00:52:13,680 --> 00:52:16,240
that is the um that is the focus of our

1443
00:52:16,240 --> 00:52:18,319
results so a bit more formally our

1444
00:52:18,319 --> 00:52:21,280
results are the following so the the

1445
00:52:21,280 --> 00:52:23,359
first result that we get is basically we

1446
00:52:23,359 --> 00:52:24,240
build

1447
00:52:24,240 --> 00:52:26,559
the uh and leakage and secret sharing

1448
00:52:26,559 --> 00:52:29,920
scheme for this local leakage model uh

1449
00:52:29,920 --> 00:52:31,920
threshold access structures uh that

1450
00:52:31,920 --> 00:52:34,319
allow new bits of leakage per share and

1451
00:52:34,319 --> 00:52:36,079
we get a the optimal share size of

1452
00:52:36,079 --> 00:52:38,079
message message length plus mu as i

1453
00:52:38,079 --> 00:52:39,680
promised

1454
00:52:39,680 --> 00:52:41,760
and further we can also extend our

1455
00:52:41,760 --> 00:52:43,359
compiler to work for general access

1456
00:52:43,359 --> 00:52:44,400
structure so it will be a rate

1457
00:52:44,400 --> 00:52:46,079
preserving compiler for general access

1458
00:52:46,079 --> 00:52:47,599
structures

1459
00:52:47,599 --> 00:52:50,800
and as an application uh we also show

1460
00:52:50,800 --> 00:52:51,920
how we can

1461
00:52:51,920 --> 00:52:54,720
use the original connection known from

1462
00:52:54,720 --> 00:52:57,280
go el commas work and actually get a

1463
00:52:57,280 --> 00:52:58,880
non-malware secret sharing scheme with

1464
00:52:58,880 --> 00:53:01,040
the share size much improved share size

1465
00:53:01,040 --> 00:53:03,119
or four times the message length in

1466
00:53:03,119 --> 00:53:05,839
addition we introduce uh a variant of

1467
00:53:05,839 --> 00:53:07,280
non-member secret sharing that just

1468
00:53:07,280 --> 00:53:10,880
works for random secrets um and for that

1469
00:53:10,880 --> 00:53:12,880
we show that you can even get a further

1470
00:53:12,880 --> 00:53:14,400
improvement in share size to two times

1471
00:53:14,400 --> 00:53:15,760
message length

1472
00:53:15,760 --> 00:53:16,960
so

1473
00:53:16,960 --> 00:53:18,480
this part i will not be talking about

1474
00:53:18,480 --> 00:53:20,640
the focus of our talk from here on would

1475
00:53:20,640 --> 00:53:23,040
be on just getting uh showing you how

1476
00:53:23,040 --> 00:53:24,400
the construction for the threshold

1477
00:53:24,400 --> 00:53:27,359
access structure works

1478
00:53:27,599 --> 00:53:28,800
okay so

1479
00:53:28,800 --> 00:53:30,240
let's start by looking at the building

1480
00:53:30,240 --> 00:53:32,240
blocks that we need for our construction

1481
00:53:32,240 --> 00:53:33,359
um

1482
00:53:33,359 --> 00:53:35,599
we need a very only one single building

1483
00:53:35,599 --> 00:53:38,319
block which is linear extractors uh so

1484
00:53:38,319 --> 00:53:40,160
what are linear extractors first

1485
00:53:40,160 --> 00:53:41,839
randomness extractors were introduced by

1486
00:53:41,839 --> 00:53:44,240
nissan and zuckerman in 1996

1487
00:53:44,240 --> 00:53:45,200
and

1488
00:53:45,200 --> 00:53:46,559
the version of them that we'll be

1489
00:53:46,559 --> 00:53:48,240
looking at are seated extractors so

1490
00:53:48,240 --> 00:53:50,160
particularly

1491
00:53:50,160 --> 00:53:51,920
the extractor function takes in some

1492
00:53:51,920 --> 00:53:54,079
source string that's drawn from this

1493
00:53:54,079 --> 00:53:56,559
distribution w which is known to have a

1494
00:53:56,559 --> 00:53:58,079
high min entropy

1495
00:53:58,079 --> 00:53:59,839
given some extra information so z is

1496
00:53:59,839 --> 00:54:02,319
some string that's given about w in

1497
00:54:02,319 --> 00:54:04,240
spite of giving that you know the mean

1498
00:54:04,240 --> 00:54:06,240
entropy of w is i

1499
00:54:06,240 --> 00:54:07,200
and

1500
00:54:07,200 --> 00:54:09,839
in addition the extractor takes as an

1501
00:54:09,839 --> 00:54:10,559
aid

1502
00:54:10,559 --> 00:54:12,720
a random string

1503
00:54:12,720 --> 00:54:13,760
called c

1504
00:54:13,760 --> 00:54:16,079
it's a short random string and with that

1505
00:54:16,079 --> 00:54:18,319
help it is able to produce a string y

1506
00:54:18,319 --> 00:54:20,960
which looks close to uniform

1507
00:54:20,960 --> 00:54:22,880
so a little bit more formally the

1508
00:54:22,880 --> 00:54:24,880
uniformity guarantee here is that the

1509
00:54:24,880 --> 00:54:26,800
extractor output

1510
00:54:26,800 --> 00:54:29,280
looks close to uniform even when i give

1511
00:54:29,280 --> 00:54:30,880
out this additional information said

1512
00:54:30,880 --> 00:54:32,880
about the source and you give out the

1513
00:54:32,880 --> 00:54:34,559
seed also out and clear

1514
00:54:34,559 --> 00:54:36,319
this is the uniformity guarantee that we

1515
00:54:36,319 --> 00:54:38,240
need

1516
00:54:38,240 --> 00:54:40,319
and in addition we need a linearity

1517
00:54:40,319 --> 00:54:43,119
property which essentially says that uh

1518
00:54:43,119 --> 00:54:45,200
for a fixed seed s

1519
00:54:45,200 --> 00:54:47,359
the function extractor

1520
00:54:47,359 --> 00:54:50,000
on the on the fixed cds so it's now just

1521
00:54:50,000 --> 00:54:52,000
a function of the source

1522
00:54:52,000 --> 00:54:54,319
and this function is a linear function

1523
00:54:54,319 --> 00:54:56,720
so particularly we need such a linearity

1524
00:54:56,720 --> 00:54:58,960
for for its invertibility

1525
00:54:58,960 --> 00:55:00,240
and i'll

1526
00:55:00,240 --> 00:55:01,680
in the next slide i'll get to what kind

1527
00:55:01,680 --> 00:55:03,599
of invertibility we need but that's why

1528
00:55:03,599 --> 00:55:05,599
we use linear extractors and in

1529
00:55:05,599 --> 00:55:07,760
literature we know linear extractor with

1530
00:55:07,760 --> 00:55:09,920
great parameters in terms of the

1531
00:55:09,920 --> 00:55:11,680
known seed length and everything and

1532
00:55:11,680 --> 00:55:13,599
i'll get to that also when we talk about

1533
00:55:13,599 --> 00:55:14,400
the

1534
00:55:14,400 --> 00:55:16,559
share size

1535
00:55:16,559 --> 00:55:18,319
okay so what is the kind of inversion we

1536
00:55:18,319 --> 00:55:20,720
need from the linear extractors

1537
00:55:20,720 --> 00:55:23,440
so particularly if i consider the

1538
00:55:23,440 --> 00:55:26,000
source distribution to be just the

1539
00:55:26,000 --> 00:55:28,000
uniform distribution

1540
00:55:28,000 --> 00:55:31,200
which is enough for our construction

1541
00:55:31,200 --> 00:55:32,559
and

1542
00:55:32,559 --> 00:55:34,319
what i want is for such a linear

1543
00:55:34,319 --> 00:55:35,839
extractor there should exist some

1544
00:55:35,839 --> 00:55:38,000
efficient inward function which i call

1545
00:55:38,000 --> 00:55:39,440
invert extractor

1546
00:55:39,440 --> 00:55:42,400
and it satisfies uh essentially

1547
00:55:42,400 --> 00:55:44,079
firstly a basic property which just

1548
00:55:44,079 --> 00:55:46,400
tells you that this inward function

1549
00:55:46,400 --> 00:55:48,960
can in some sense get a correct source

1550
00:55:48,960 --> 00:55:49,760
string

1551
00:55:49,760 --> 00:55:52,400
when i invert it on the uh

1552
00:55:52,400 --> 00:55:54,079
correct extractor output so if you

1553
00:55:54,079 --> 00:55:56,079
notice it takes in as input the

1554
00:55:56,079 --> 00:55:57,839
extractor output

1555
00:55:57,839 --> 00:56:00,480
and the seed and it spits out something

1556
00:56:00,480 --> 00:56:02,240
which technically should give you the

1557
00:56:02,240 --> 00:56:04,079
correct source string that led to the

1558
00:56:04,079 --> 00:56:06,240
extractor output so what this is saying

1559
00:56:06,240 --> 00:56:08,079
is that when the invert extractor is

1560
00:56:08,079 --> 00:56:10,400
applied on the correct extractor output

1561
00:56:10,400 --> 00:56:11,760
and the seed

1562
00:56:11,760 --> 00:56:13,760
that distribution would look essentially

1563
00:56:13,760 --> 00:56:15,440
identical to uniform which was my

1564
00:56:15,440 --> 00:56:17,280
original source distribution

1565
00:56:17,280 --> 00:56:18,240
so

1566
00:56:18,240 --> 00:56:19,520
uh this is

1567
00:56:19,520 --> 00:56:21,200
the kind of first property you want from

1568
00:56:21,200 --> 00:56:24,160
the invert extractor besides that is the

1569
00:56:24,160 --> 00:56:26,400
like standard correctness feature in the

1570
00:56:26,400 --> 00:56:27,680
sense that

1571
00:56:27,680 --> 00:56:29,520
whenever you you have a guarantee that

1572
00:56:29,520 --> 00:56:32,799
for the fixed seed and the string y

1573
00:56:32,799 --> 00:56:35,920
the relation is corresponding to some

1574
00:56:35,920 --> 00:56:37,599
valid extractor output which means that

1575
00:56:37,599 --> 00:56:39,760
there was some source to begin with

1576
00:56:39,760 --> 00:56:42,000
for which the extractor output gave y if

1577
00:56:42,000 --> 00:56:43,440
this is the relation

1578
00:56:43,440 --> 00:56:45,119
then i will always be able to invert

1579
00:56:45,119 --> 00:56:46,960
correctly so basically it means that

1580
00:56:46,960 --> 00:56:49,119
this function would output some w prime

1581
00:56:49,119 --> 00:56:51,040
such that the extractor on w prime and s

1582
00:56:51,040 --> 00:56:53,359
is y with probability one

1583
00:56:53,359 --> 00:56:55,200
so whenever i give a correct string

1584
00:56:55,200 --> 00:56:56,799
drawn from the extractor output space

1585
00:56:56,799 --> 00:56:58,480
you will always be able to invert that's

1586
00:56:58,480 --> 00:56:59,839
all this is saying

1587
00:56:59,839 --> 00:57:01,760
but if not uh i would output some

1588
00:57:01,760 --> 00:57:03,680
special symbol which is spot so if there

1589
00:57:03,680 --> 00:57:06,160
is no such w that you can invert to your

1590
00:57:06,160 --> 00:57:09,119
output board essentially

1591
00:57:09,119 --> 00:57:10,880
okay so the this is the kind of

1592
00:57:10,880 --> 00:57:12,400
inversion feature that we need from it

1593
00:57:12,400 --> 00:57:15,680
and we'll see where we exactly use it

1594
00:57:15,680 --> 00:57:17,599
so with that i'm ready to tell you how

1595
00:57:17,599 --> 00:57:21,280
our construction works and um

1596
00:57:21,280 --> 00:57:22,799
it's a fairly straightforward

1597
00:57:22,799 --> 00:57:24,160
construction to

1598
00:57:24,160 --> 00:57:26,799
think about uh basically you take the

1599
00:57:26,799 --> 00:57:28,960
secret message m

1600
00:57:28,960 --> 00:57:31,119
and uh the first thing as i said is we

1601
00:57:31,119 --> 00:57:34,000
build a compiler so we first share it

1602
00:57:34,000 --> 00:57:36,000
using the a regular secret sharing

1603
00:57:36,000 --> 00:57:37,119
scheme so particularly we are in the

1604
00:57:37,119 --> 00:57:39,280
threshold setup and we care for optimal

1605
00:57:39,280 --> 00:57:41,280
share size so we'll share it using the

1606
00:57:41,280 --> 00:57:43,280
swami secret sharing scheme which

1607
00:57:43,280 --> 00:57:44,559
gives you the optimal share size at

1608
00:57:44,559 --> 00:57:45,680
least in the

1609
00:57:45,680 --> 00:57:47,440
uh standard secret sharing notion right

1610
00:57:47,440 --> 00:57:48,880
so we will share it using the xiaomi

1611
00:57:48,880 --> 00:57:50,559
secret sharing scheme

1612
00:57:50,559 --> 00:57:51,440
um

1613
00:57:51,440 --> 00:57:55,599
now i pick a seed for the extractor

1614
00:57:55,599 --> 00:57:59,839
and what i do is i invert each mi

1615
00:57:59,839 --> 00:58:01,839
using the invert function for the same

1616
00:58:01,839 --> 00:58:04,160
seed s

1617
00:58:04,160 --> 00:58:06,319
so note here like i'm using the same

1618
00:58:06,319 --> 00:58:09,040
seed for each of the inward function and

1619
00:58:09,040 --> 00:58:11,520
i'm taking this mi to represent my

1620
00:58:11,520 --> 00:58:13,119
extractor output in some sense so i'm

1621
00:58:13,119 --> 00:58:15,680
inverting and recovering some source

1622
00:58:15,680 --> 00:58:18,880
corresponding to this output

1623
00:58:18,880 --> 00:58:20,000
and

1624
00:58:20,000 --> 00:58:22,640
then i just secret share my seed

1625
00:58:22,640 --> 00:58:24,480
using uh swami's secret sharing scheme

1626
00:58:24,480 --> 00:58:26,559
with same threshold d

1627
00:58:26,559 --> 00:58:29,680
and i output the shares s1 through xm so

1628
00:58:29,680 --> 00:58:32,319
the final shares here are just each

1629
00:58:32,319 --> 00:58:36,440
so the share i is just wisi

1630
00:58:36,640 --> 00:58:38,880
so um of course

1631
00:58:38,880 --> 00:58:40,720
what i did not mention about here is the

1632
00:58:40,720 --> 00:58:43,280
scenario where the inward outputted part

1633
00:58:43,280 --> 00:58:45,920
what if there was no valid wi that's a

1634
00:58:45,920 --> 00:58:48,880
possibility here in such a case i'll

1635
00:58:48,880 --> 00:58:51,200
just ensure correctness and for that i

1636
00:58:51,200 --> 00:58:53,040
will just give you the original message

1637
00:58:53,040 --> 00:58:55,359
am i if there's no wi if there's even

1638
00:58:55,359 --> 00:58:58,000
one j for which the wi did not exist i

1639
00:58:58,000 --> 00:59:00,160
will end up giving you mis for all the

1640
00:59:00,160 --> 00:59:02,720
all the shares so clearly here you will

1641
00:59:02,720 --> 00:59:04,319
not achieve leakage resilience but what

1642
00:59:04,319 --> 00:59:05,680
we'll end up showing in the proof is

1643
00:59:05,680 --> 00:59:07,520
that this only occurs with negligible

1644
00:59:07,520 --> 00:59:08,480
probability

1645
00:59:08,480 --> 00:59:09,680
so it doesn't spoil the leakage

1646
00:59:09,680 --> 00:59:11,680
resilience

1647
00:59:11,680 --> 00:59:13,440
okay so first

1648
00:59:13,440 --> 00:59:14,319
check

1649
00:59:14,319 --> 00:59:16,720
correctness holes well uh in the first

1650
00:59:16,720 --> 00:59:17,599
case

1651
00:59:17,599 --> 00:59:19,680
it directly holds because we had wi's

1652
00:59:19,680 --> 00:59:20,799
and sis

1653
00:59:20,799 --> 00:59:23,200
you could reconstruct the sis and get

1654
00:59:23,200 --> 00:59:25,520
the seed first then you could just apply

1655
00:59:25,520 --> 00:59:27,920
the extractor and recover the tmis from

1656
00:59:27,920 --> 00:59:29,839
which you could reconstruct the message

1657
00:59:29,839 --> 00:59:32,240
so that was a case where you had the

1658
00:59:32,240 --> 00:59:34,559
wi's and sis and here you already have

1659
00:59:34,559 --> 00:59:36,799
the mis to begin with in which case you

1660
00:59:36,799 --> 00:59:38,400
can just reconstruct using the xiaomi

1661
00:59:38,400 --> 00:59:41,040
secret sharing

1662
00:59:41,200 --> 00:59:43,440
okay so why does leakage resilience hold

1663
00:59:43,440 --> 00:59:44,480
and

1664
00:59:44,480 --> 00:59:46,000
i'll be able to take you through a high

1665
00:59:46,000 --> 00:59:50,000
level sketch of wired holes uh so

1666
00:59:50,000 --> 00:59:52,240
let's start with the first case as i

1667
00:59:52,240 --> 00:59:54,240
mentioned here you want to show that

1668
00:59:54,240 --> 00:59:55,680
this is a case where you can't hope for

1669
00:59:55,680 --> 00:59:58,160
leakages lens right but what we'll end

1670
00:59:58,160 --> 01:00:00,400
up showing is that the probability that

1671
01:00:00,400 --> 01:00:02,960
this uh there exists some wj for which

1672
01:00:02,960 --> 01:00:05,119
the invert extractor outputs part that

1673
01:00:05,119 --> 01:00:07,119
would be actually negligible so this

1674
01:00:07,119 --> 01:00:08,799
this case in itself happens only with

1675
01:00:08,799 --> 01:00:11,680
negligible probability why is that this

1676
01:00:11,680 --> 01:00:13,760
uses an added feature that uh shumi's

1677
01:00:13,760 --> 01:00:16,000
secret sharing scheme already has and we

1678
01:00:16,000 --> 01:00:18,880
assume this we call local uniformity so

1679
01:00:18,880 --> 01:00:20,720
what does it say that if you look at any

1680
01:00:20,720 --> 01:00:23,440
individual share of shamir

1681
01:00:23,440 --> 01:00:26,319
that itself looks uniform so each mi the

1682
01:00:26,319 --> 01:00:28,160
distribution on one particular share

1683
01:00:28,160 --> 01:00:30,480
that looks close to uniform and this is

1684
01:00:30,480 --> 01:00:31,920
something you can

1685
01:00:31,920 --> 01:00:34,960
see that chemise came already satisfied

1686
01:00:34,960 --> 01:00:36,559
once you have this you can use the

1687
01:00:36,559 --> 01:00:38,240
extractor security

1688
01:00:38,240 --> 01:00:40,559
and take this to the case that the mi

1689
01:00:40,559 --> 01:00:41,920
actually ends up looking close to the

1690
01:00:41,920 --> 01:00:43,839
extractor output

1691
01:00:43,839 --> 01:00:46,000
so what does this tell me like

1692
01:00:46,000 --> 01:00:47,839
whatever you're feeding in as the input

1693
01:00:47,839 --> 01:00:49,520
to the invert extractor

1694
01:00:49,520 --> 01:00:51,680
you can ensure that at least it's close

1695
01:00:51,680 --> 01:00:53,040
close enough to being picked from the

1696
01:00:53,040 --> 01:00:55,200
extractor distribution and we know that

1697
01:00:55,200 --> 01:00:57,200
when that happens so the correctness is

1698
01:00:57,200 --> 01:00:58,720
guaranteed you will be able to output a

1699
01:00:58,720 --> 01:00:59,920
wi with

1700
01:00:59,920 --> 01:01:02,720
um probability one when that happens so

1701
01:01:02,720 --> 01:01:05,119
except for the error that is there by

1702
01:01:05,119 --> 01:01:06,400
this closeness

1703
01:01:06,400 --> 01:01:08,559
uh you're good in this situation

1704
01:01:08,559 --> 01:01:10,079
so only with the negligible probability

1705
01:01:10,079 --> 01:01:12,799
there will be a bot situation

1706
01:01:12,799 --> 01:01:15,359
so this case does not occur

1707
01:01:15,359 --> 01:01:17,839
for for uh with with high probability

1708
01:01:17,839 --> 01:01:19,520
hence we can look at the main scenario

1709
01:01:19,520 --> 01:01:22,000
what what what does uh how what happens

1710
01:01:22,000 --> 01:01:25,359
when w isi is output right so here uh

1711
01:01:25,359 --> 01:01:27,920
for the leakage resilience so

1712
01:01:27,920 --> 01:01:29,680
recall in the we are in the local

1713
01:01:29,680 --> 01:01:31,599
leakage model right so it was all

1714
01:01:31,599 --> 01:01:33,440
individual fi is acting on each of the

1715
01:01:33,440 --> 01:01:36,720
share so particularly the last t minus

1716
01:01:36,720 --> 01:01:38,720
one shares our full shares

1717
01:01:38,720 --> 01:01:41,040
and uh the remaining are all like for

1718
01:01:41,040 --> 01:01:42,799
the sake of this proof like consider the

1719
01:01:42,799 --> 01:01:45,280
last t-minus one shares are full um and

1720
01:01:45,280 --> 01:01:46,720
the remaining are the ones which output

1721
01:01:46,720 --> 01:01:48,720
bounded bits from the share

1722
01:01:48,720 --> 01:01:49,839
so

1723
01:01:49,839 --> 01:01:51,520
how does leakage agents work first look

1724
01:01:51,520 --> 01:01:53,599
at the ones that correspond to the

1725
01:01:53,599 --> 01:01:56,160
leakage part right so n minus t minus 1

1726
01:01:56,160 --> 01:01:57,680
shares for which you outputted bounded

1727
01:01:57,680 --> 01:01:58,799
bits

1728
01:01:58,799 --> 01:02:00,880
the point to note here is because of the

1729
01:02:00,880 --> 01:02:02,720
property of the extractor

1730
01:02:02,720 --> 01:02:04,160
you you had the guarantee that the

1731
01:02:04,160 --> 01:02:05,520
invert extractor

1732
01:02:05,520 --> 01:02:07,839
whatever it outputs that distribution is

1733
01:02:07,839 --> 01:02:09,760
close to uniform so what you can

1734
01:02:09,760 --> 01:02:10,640
actually

1735
01:02:10,640 --> 01:02:12,960
capture here that the leakages that you

1736
01:02:12,960 --> 01:02:15,680
get from each of these wiseis turn out

1737
01:02:15,680 --> 01:02:17,839
to be independent of mi because

1738
01:02:17,839 --> 01:02:20,319
you can show that the wi wi's here look

1739
01:02:20,319 --> 01:02:22,319
close to uniform

1740
01:02:22,319 --> 01:02:24,880
so the point here is you want to ensure

1741
01:02:24,880 --> 01:02:27,599
that this n minus t minus 1 shares

1742
01:02:27,599 --> 01:02:29,680
corresponding to leakage they end up

1743
01:02:29,680 --> 01:02:30,640
using

1744
01:02:30,640 --> 01:02:32,559
no information or giving no information

1745
01:02:32,559 --> 01:02:34,640
about the mi's in itself

1746
01:02:34,640 --> 01:02:36,960
because for the next part which is the

1747
01:02:36,960 --> 01:02:38,000
full share

1748
01:02:38,000 --> 01:02:39,440
i want to use the privacy of the

1749
01:02:39,440 --> 01:02:41,440
underlying scheme

1750
01:02:41,440 --> 01:02:42,319
so

1751
01:02:42,319 --> 01:02:44,559
what i mean is once you've used and

1752
01:02:44,559 --> 01:02:45,839
shown that the leakage part

1753
01:02:45,839 --> 01:02:48,640
corresponding to the first shares first

1754
01:02:48,640 --> 01:02:50,480
set of shares they are independent of

1755
01:02:50,480 --> 01:02:52,720
their mis now for the full shares i can

1756
01:02:52,720 --> 01:02:54,720
just uh use the underlying privacy of

1757
01:02:54,720 --> 01:02:57,760
shamir and guarantee that it's okay to

1758
01:02:57,760 --> 01:02:58,880
give these pushers so they will be

1759
01:02:58,880 --> 01:03:01,119
independent of them essentially so

1760
01:03:01,119 --> 01:03:03,520
that's essentially the uh high level

1761
01:03:03,520 --> 01:03:05,200
idea behind how we show leakage length

1762
01:03:05,200 --> 01:03:06,640
for this

1763
01:03:06,640 --> 01:03:07,760
so

1764
01:03:07,760 --> 01:03:09,680
just to conclude what i showed you here

1765
01:03:09,680 --> 01:03:11,680
today was a construction for how to get

1766
01:03:11,680 --> 01:03:13,920
these leakages in secret sharing schemes

1767
01:03:13,920 --> 01:03:15,599
for the threshold access structure in

1768
01:03:15,599 --> 01:03:17,200
the local leakage model that gets the

1769
01:03:17,200 --> 01:03:20,000
optimal share size and uh

1770
01:03:20,000 --> 01:03:22,319
leakage as well um

1771
01:03:22,319 --> 01:03:24,480
and our compiler also and what i did not

1772
01:03:24,480 --> 01:03:26,559
talk about is that our compiler also

1773
01:03:26,559 --> 01:03:28,160
extends and we can prove a rate

1774
01:03:28,160 --> 01:03:30,079
preserving version for the general

1775
01:03:30,079 --> 01:03:31,359
access structures

1776
01:03:31,359 --> 01:03:32,480
and

1777
01:03:32,480 --> 01:03:34,240
in addition we also have applications to

1778
01:03:34,240 --> 01:03:35,839
non-map and secret sharing schemes with

1779
01:03:35,839 --> 01:03:37,359
improved share size

1780
01:03:37,359 --> 01:03:39,200
so if you're interested

1781
01:03:39,200 --> 01:03:40,559
are you welcome to take a look at our

1782
01:03:40,559 --> 01:03:42,160
paper

1783
01:03:42,160 --> 01:03:44,000
what is open here and still interesting

1784
01:03:44,000 --> 01:03:45,920
to look at is the

1785
01:03:45,920 --> 01:03:47,440
what what what about the stronger

1786
01:03:47,440 --> 01:03:49,839
leakage models so for the adaptive joint

1787
01:03:49,839 --> 01:03:52,079
model uh there's only one construction

1788
01:03:52,079 --> 01:03:54,559
known that has a constant rate and even

1789
01:03:54,559 --> 01:03:58,400
there the constant is quite big so

1790
01:03:58,400 --> 01:04:00,480
of course achieving optimal share size

1791
01:04:00,480 --> 01:04:02,400
for a stronger leakage model is a very

1792
01:04:02,400 --> 01:04:04,799
interesting open problem to look at

1793
01:04:04,799 --> 01:04:08,559
um thank you for listening yeah

1794
01:04:09,440 --> 01:04:12,160
okay thank you for this great talk so

1795
01:04:12,160 --> 01:04:14,880
while the next speaker sets up maybe if

1796
01:04:14,880 --> 01:04:19,160
there are questions please come forward

1797
01:04:54,400 --> 01:04:57,400
if

1798
01:05:09,359 --> 01:05:12,160
so our fourth and last uh talk in this

1799
01:05:12,160 --> 01:05:13,680
session is called cryptography from

1800
01:05:13,680 --> 01:05:16,640
pseudorandom states

1801
01:05:17,760 --> 01:05:19,920
by prabhupada anat

1802
01:05:19,920 --> 01:05:21,520
and henry yen and

1803
01:05:21,520 --> 01:05:25,480
roman is giving the talk

1804
01:05:36,880 --> 01:05:38,400
should i start

1805
01:05:38,400 --> 01:05:41,200
should i start now

1806
01:05:41,200 --> 01:05:44,079
should i start now yes oh okay

1807
01:05:44,079 --> 01:05:46,160
yeah thank you for the introduction

1808
01:05:46,160 --> 01:05:48,319
um so

1809
01:05:48,319 --> 01:05:50,960
now um for the last talk of the session

1810
01:05:50,960 --> 01:05:52,799
i'm going to talk about a very different

1811
01:05:52,799 --> 01:05:55,200
kind of randomness so i will be talking

1812
01:05:55,200 --> 01:05:57,440
about this work about constructing

1813
01:05:57,440 --> 01:05:59,440
quantum cryptography from pseudo-random

1814
01:05:59,440 --> 01:06:00,880
quantum states

1815
01:06:00,880 --> 01:06:03,440
uh and this is drain work with prabhanja

1816
01:06:03,440 --> 01:06:05,839
anna from ucsb and harry young from

1817
01:06:05,839 --> 01:06:07,520
colombia

1818
01:06:07,520 --> 01:06:08,640
um

1819
01:06:08,640 --> 01:06:11,119
so let me start by maybe giving you the

1820
01:06:11,119 --> 01:06:12,319
takeaway

1821
01:06:12,319 --> 01:06:14,640
if you are not a quantum person

1822
01:06:14,640 --> 01:06:16,160
so let's start with the following

1823
01:06:16,160 --> 01:06:18,400
question um let's say

1824
01:06:18,400 --> 01:06:20,880
uh take your favorite cryptography

1825
01:06:20,880 --> 01:06:23,680
you know aes geo-three rsa or

1826
01:06:23,680 --> 01:06:25,839
assumptions like lattices or even

1827
01:06:25,839 --> 01:06:27,440
concrete

1828
01:06:27,440 --> 01:06:30,319
cryptographic protocols like tis and you

1829
01:06:30,319 --> 01:06:32,880
actually prove the security of any of

1830
01:06:32,880 --> 01:06:34,960
these products

1831
01:06:34,960 --> 01:06:36,000
and

1832
01:06:36,000 --> 01:06:38,000
thanks to decades of

1833
01:06:38,000 --> 01:06:40,480
cryptographic research we know that this

1834
01:06:40,480 --> 01:06:43,119
is probably not possible because

1835
01:06:43,119 --> 01:06:46,000
any unconditional security proof of any

1836
01:06:46,000 --> 01:06:48,240
of these protocols will imply the

1837
01:06:48,240 --> 01:06:50,880
existence of a primitive called one-way

1838
01:06:50,880 --> 01:06:52,079
functions

1839
01:06:52,079 --> 01:06:54,319
and as you might have heard in julian's

1840
01:06:54,319 --> 01:06:56,480
talk this thing is

1841
01:06:56,480 --> 01:06:58,839
considered to be the best stone for

1842
01:06:58,839 --> 01:07:01,119
cryptography and furthermore you will

1843
01:07:01,119 --> 01:07:03,119
also settle the

1844
01:07:03,119 --> 01:07:05,760
p versus mp question and win the million

1845
01:07:05,760 --> 01:07:06,720
dollar

1846
01:07:06,720 --> 01:07:08,160
so

1847
01:07:08,160 --> 01:07:09,920
this is probably not possible without

1848
01:07:09,920 --> 01:07:13,119
assuming any assumptions

1849
01:07:13,119 --> 01:07:14,559
so the focus of

1850
01:07:14,559 --> 01:07:16,799
uh of the talk today is going to be on

1851
01:07:16,799 --> 01:07:18,480
quantum cryptography

1852
01:07:18,480 --> 01:07:22,640
which is a a cryptographic protocol

1853
01:07:22,640 --> 01:07:23,839
for

1854
01:07:23,839 --> 01:07:26,160
uh quantum parties meaning that even

1855
01:07:26,160 --> 01:07:27,839
honest parties participating in the

1856
01:07:27,839 --> 01:07:31,119
protocol have quantum capabilities

1857
01:07:31,119 --> 01:07:32,960
and

1858
01:07:32,960 --> 01:07:35,440
so prior to our work

1859
01:07:35,440 --> 01:07:37,760
all non-quantum cryptography

1860
01:07:37,760 --> 01:07:40,000
are either information theoretic

1861
01:07:40,000 --> 01:07:43,039
or they are computational secure but

1862
01:07:43,039 --> 01:07:45,039
they assume at least

1863
01:07:45,039 --> 01:07:47,760
some assumption that is uh that will

1864
01:07:47,760 --> 01:07:50,640
imply one-way functions

1865
01:07:50,640 --> 01:07:51,520
so

1866
01:07:51,520 --> 01:07:54,240
the contribution of our work is showing

1867
01:07:54,240 --> 01:07:56,319
that for a broad class of quantum

1868
01:07:56,319 --> 01:07:57,680
cryptography

1869
01:07:57,680 --> 01:08:00,000
it is actually not necessary

1870
01:08:00,000 --> 01:08:02,319
to assume the existence of any kinds of

1871
01:08:02,319 --> 01:08:04,000
only functions

1872
01:08:04,000 --> 01:08:04,880
and

1873
01:08:04,880 --> 01:08:06,480
so you can also

1874
01:08:06,480 --> 01:08:08,480
think of this as

1875
01:08:08,480 --> 01:08:10,160
the evidence that maybe there are there

1876
01:08:10,160 --> 01:08:12,240
are no various at least a similar

1877
01:08:12,240 --> 01:08:15,119
barrier for classical cryptography for

1878
01:08:15,119 --> 01:08:17,359
getting a security proof

1879
01:08:17,359 --> 01:08:18,238
um

1880
01:08:18,238 --> 01:08:20,960
so this is this follows by the work that

1881
01:08:20,960 --> 01:08:23,600
i'm going to talk about today and

1882
01:08:23,600 --> 01:08:26,880
a prior work by krashmer last year

1883
01:08:26,880 --> 01:08:29,839
and um there is also a concurrent work

1884
01:08:29,839 --> 01:08:32,319
by maury and yamakawa who show something

1885
01:08:32,319 --> 01:08:34,158
similar in spirit

1886
01:08:34,158 --> 01:08:35,600
but with

1887
01:08:35,600 --> 01:08:37,120
different proofs and different

1888
01:08:37,120 --> 01:08:39,120
techniques which is going to be

1889
01:08:39,120 --> 01:08:40,640
happening um

1890
01:08:40,640 --> 01:08:42,640
just right after this talk

1891
01:08:42,640 --> 01:08:45,759
uh in the other room

1892
01:08:45,759 --> 01:08:46,719
okay

1893
01:08:46,719 --> 01:08:47,920
so

1894
01:08:47,920 --> 01:08:50,158
now let's delve into

1895
01:08:50,158 --> 01:08:50,880
the

1896
01:08:50,880 --> 01:08:52,960
more technical specifics

1897
01:08:52,960 --> 01:08:55,600
so the focus of today's work is going to

1898
01:08:55,600 --> 01:08:58,560
be this quantum object or primitive

1899
01:08:58,560 --> 01:09:00,479
called pseudo-random quantum states or

1900
01:09:00,479 --> 01:09:02,238
prs for sure

1901
01:09:02,238 --> 01:09:04,399
um so this object was introduced three

1902
01:09:04,399 --> 01:09:07,439
years ago by g leo and sul

1903
01:09:07,439 --> 01:09:09,679
so informally this object is like a

1904
01:09:09,679 --> 01:09:12,080
pseudo-random generator

1905
01:09:12,080 --> 01:09:14,080
in the sense that it also takes

1906
01:09:14,080 --> 01:09:16,640
as input a short sleeve

1907
01:09:16,640 --> 01:09:19,279
however unlike a pseudo-random generator

1908
01:09:19,279 --> 01:09:22,080
the output is a quantum state instead of

1909
01:09:22,080 --> 01:09:24,799
a pseudo-random space string

1910
01:09:24,799 --> 01:09:27,198
and the pseudo-randomness property that

1911
01:09:27,198 --> 01:09:29,520
you are supposed to require on this

1912
01:09:29,520 --> 01:09:31,439
object is that this thing

1913
01:09:31,439 --> 01:09:34,399
should look pseudo-random in the

1914
01:09:34,399 --> 01:09:37,839
in some appropriate quantum random uh

1915
01:09:37,839 --> 01:09:40,560
notion called hiring

1916
01:09:40,560 --> 01:09:43,359
so let me now um introduce you to this

1917
01:09:43,359 --> 01:09:45,279
high random

1918
01:09:45,279 --> 01:09:46,799
definition

1919
01:09:46,799 --> 01:09:47,679
so

1920
01:09:47,679 --> 01:09:50,319
just to remind everyone um

1921
01:09:50,319 --> 01:09:53,439
uh for a quantum state uh let's think of

1922
01:09:53,439 --> 01:09:56,080
a a quantum state for a single bit also

1923
01:09:56,080 --> 01:09:58,560
called as a qubit which is formally just

1924
01:09:58,560 --> 01:10:01,440
a unit vector in two-dimensional complex

1925
01:10:01,440 --> 01:10:04,239
uh euclidean space

1926
01:10:04,239 --> 01:10:06,880
and for n cubits it's just uh n-tensor

1927
01:10:06,880 --> 01:10:09,440
products of qubits so it's a two to the

1928
01:10:09,440 --> 01:10:13,360
n dimensional complex uh hilbert

1929
01:10:13,360 --> 01:10:15,360
or silver space

1930
01:10:15,360 --> 01:10:18,800
and the heart random state

1931
01:10:18,800 --> 01:10:22,640
is basically a uniform distribution over

1932
01:10:22,640 --> 01:10:24,719
all the unit vectors

1933
01:10:24,719 --> 01:10:26,719
lying on the unit sphere of this two to

1934
01:10:26,719 --> 01:10:28,800
the n-dimensional space

1935
01:10:28,800 --> 01:10:31,120
so one immediate observation that you

1936
01:10:31,120 --> 01:10:32,159
can make

1937
01:10:32,159 --> 01:10:34,080
is that even to describe an

1938
01:10:34,080 --> 01:10:36,640
approximation of a high random state you

1939
01:10:36,640 --> 01:10:41,199
would need an exponential number of bits

1940
01:10:41,199 --> 01:10:43,440
and uh because

1941
01:10:43,440 --> 01:10:45,679
we define this heart randomness

1942
01:10:45,679 --> 01:10:46,560
to

1943
01:10:46,560 --> 01:10:48,960
be a uniform distribution over the

1944
01:10:48,960 --> 01:10:50,239
sphere

1945
01:10:50,239 --> 01:10:52,400
it also satisfy a crucial property that

1946
01:10:52,400 --> 01:10:54,000
we'll use later called unitary

1947
01:10:54,000 --> 01:10:55,199
invariance

1948
01:10:55,199 --> 01:10:57,520
which roughly means that for any unitary

1949
01:10:57,520 --> 01:10:59,120
which you can think of as a rotation of

1950
01:10:59,120 --> 01:11:00,480
the sphere

1951
01:11:00,480 --> 01:11:02,320
the heart random distribution after

1952
01:11:02,320 --> 01:11:04,719
applied unitary is still the same

1953
01:11:04,719 --> 01:11:06,159
distribution as the original

1954
01:11:06,159 --> 01:11:08,879
distribution

1955
01:11:09,199 --> 01:11:10,800
okay so now let me give you the

1956
01:11:10,800 --> 01:11:13,840
definition of prs more formally

1957
01:11:13,840 --> 01:11:16,560
so we call a quantum algorithm g

1958
01:11:16,560 --> 01:11:20,400
to be an n qubit prs generator if it

1959
01:11:20,400 --> 01:11:22,000
satisfies the two

1960
01:11:22,000 --> 01:11:23,280
criteria

1961
01:11:23,280 --> 01:11:25,040
the first criteria says

1962
01:11:25,040 --> 01:11:27,199
the generation is efficient so it takes

1963
01:11:27,199 --> 01:11:28,719
as input i

1964
01:11:28,719 --> 01:11:30,719
end up with c

1965
01:11:30,719 --> 01:11:32,640
and runs in some polynomial time and

1966
01:11:32,640 --> 01:11:37,440
then outputs a pure state of n qubits

1967
01:11:37,440 --> 01:11:39,280
and the pseudo randomness

1968
01:11:39,280 --> 01:11:40,560
says that

1969
01:11:40,560 --> 01:11:43,199
these outputs even with many copies

1970
01:11:43,199 --> 01:11:46,000
looks just like uh many copies of power

1971
01:11:46,000 --> 01:11:47,520
random states

1972
01:11:47,520 --> 01:11:51,199
so formally we are saying that

1973
01:11:51,199 --> 01:11:54,719
if for any polynomial number of copies t

1974
01:11:54,719 --> 01:11:58,080
t copies of a random prs state is

1975
01:11:58,080 --> 01:12:00,719
computationally indistinguishable to

1976
01:12:00,719 --> 01:12:03,600
a high random n qubit

1977
01:12:03,600 --> 01:12:05,600
quantum state

1978
01:12:05,600 --> 01:12:08,000
also given t copies

1979
01:12:08,000 --> 01:12:08,880
so

1980
01:12:08,880 --> 01:12:10,960
just some observations on this

1981
01:12:10,960 --> 01:12:13,920
definition first we unlike prg here we

1982
01:12:13,920 --> 01:12:16,880
need to give many copies because quantum

1983
01:12:16,880 --> 01:12:18,880
states um how random states in

1984
01:12:18,880 --> 01:12:20,400
particular are

1985
01:12:20,400 --> 01:12:22,880
not not clonable so the more copies you

1986
01:12:22,880 --> 01:12:25,360
get you can actually get

1987
01:12:25,360 --> 01:12:27,920
more information

1988
01:12:27,920 --> 01:12:30,159
and the second observation is that the

1989
01:12:30,159 --> 01:12:32,159
security is supposed to hold just like

1990
01:12:32,159 --> 01:12:33,440
for prf

1991
01:12:33,440 --> 01:12:36,719
uh for any arbitrary

1992
01:12:36,719 --> 01:12:39,040
large number of copies

1993
01:12:39,040 --> 01:12:40,880
as on its polynomial

1994
01:12:40,880 --> 01:12:44,239
and if this is a fixed number then

1995
01:12:44,239 --> 01:12:47,440
this has already been studied in uh

1996
01:12:47,440 --> 01:12:49,920
prior works it's called the t design if

1997
01:12:49,920 --> 01:12:51,840
he is funded here we are considering t

1998
01:12:51,840 --> 01:12:55,520
to be not unbounded

1999
01:12:55,679 --> 01:12:58,239
okay so here's what we know about uh

2000
01:12:58,239 --> 01:13:00,239
comparison between one-way functions or

2001
01:13:00,239 --> 01:13:02,480
equivalently pseudo-random generators

2002
01:13:02,480 --> 01:13:04,400
versus pseudorandom states

2003
01:13:04,400 --> 01:13:05,760
so in the

2004
01:13:05,760 --> 01:13:07,600
original work that introduced this

2005
01:13:07,600 --> 01:13:09,920
object they showed that if you start

2006
01:13:09,920 --> 01:13:12,239
with one-way functions

2007
01:13:12,239 --> 01:13:14,640
you can construct pseudo-random states

2008
01:13:14,640 --> 01:13:16,719
for any output length that's super

2009
01:13:16,719 --> 01:13:19,520
logarithmic

2010
01:13:19,520 --> 01:13:22,159
and once you have that they show an

2011
01:13:22,159 --> 01:13:24,480
application of such an object in

2012
01:13:24,480 --> 01:13:26,800
particular they give a construction of

2013
01:13:26,800 --> 01:13:29,600
private key query secure quantum money

2014
01:13:29,600 --> 01:13:33,840
which is a fancy quantum crypto

2015
01:13:34,480 --> 01:13:36,800
on the other hand we don't know whether

2016
01:13:36,800 --> 01:13:39,120
pseudo-random states implies one-way

2017
01:13:39,120 --> 01:13:41,360
function or even something more wild

2018
01:13:41,360 --> 01:13:44,560
like or more like weaker like p not

2019
01:13:44,560 --> 01:13:46,560
equal qma

2020
01:13:46,560 --> 01:13:48,640
and if you look at

2021
01:13:48,640 --> 01:13:50,640
what would go wrong with the classical

2022
01:13:50,640 --> 01:13:53,360
proof that maybe prg implies p not equal

2023
01:13:53,360 --> 01:13:54,400
mp

2024
01:13:54,400 --> 01:13:57,520
here the the problem is basically that

2025
01:13:57,520 --> 01:13:59,440
when you are trying to do that reduction

2026
01:13:59,440 --> 01:14:03,199
you get a quantum statement however

2027
01:14:03,199 --> 01:14:06,400
for p or qma even for qma the statement

2028
01:14:06,400 --> 01:14:07,199
is

2029
01:14:07,199 --> 01:14:09,120
classical

2030
01:14:09,120 --> 01:14:11,520
although the witness is quantum

2031
01:14:11,520 --> 01:14:13,600
and indeed there is this work by

2032
01:14:13,600 --> 01:14:16,560
crashman last year showing that uh there

2033
01:14:16,560 --> 01:14:19,520
is an oracle relative to which

2034
01:14:19,520 --> 01:14:22,880
p equals qma and yet pseudorandom states

2035
01:14:22,880 --> 01:14:23,920
exist

2036
01:14:23,920 --> 01:14:24,719
so

2037
01:14:24,719 --> 01:14:27,120
uh from a cryptographer's view this is a

2038
01:14:27,120 --> 01:14:29,040
black box separation between

2039
01:14:29,040 --> 01:14:30,320
pseudo-random states and one-way

2040
01:14:30,320 --> 01:14:33,120
function in particular it tells you that

2041
01:14:33,120 --> 01:14:35,760
you cannot construct a one-way function

2042
01:14:35,760 --> 01:14:38,000
post quantum or not from a single random

2043
01:14:38,000 --> 01:14:41,600
state in a black box way

2044
01:14:41,840 --> 01:14:45,679
okay and so all of this points to the uh

2045
01:14:45,679 --> 01:14:48,640
a belief that maybe pseudo-random states

2046
01:14:48,640 --> 01:14:51,280
by themselves could be a weaker

2047
01:14:51,280 --> 01:14:53,360
uh quantum hardness assumption than

2048
01:14:53,360 --> 01:14:56,719
one-way functions

2049
01:14:56,719 --> 01:14:58,800
so the starting point of our work is to

2050
01:14:58,800 --> 01:15:00,640
ask the following question

2051
01:15:00,640 --> 01:15:03,600
so uh forget quantum money which is way

2052
01:15:03,600 --> 01:15:06,560
too fancy what kind of

2053
01:15:06,560 --> 01:15:09,199
crypto tasks that we already consider in

2054
01:15:09,199 --> 01:15:11,280
the classical literature can we achieve

2055
01:15:11,280 --> 01:15:13,360
just with like just assuming the

2056
01:15:13,360 --> 01:15:16,480
existence of prs

2057
01:15:17,600 --> 01:15:19,360
and then we run into a bunch of

2058
01:15:19,360 --> 01:15:23,199
difficulties of using prs so let me

2059
01:15:23,199 --> 01:15:24,960
quickly mention them

2060
01:15:24,960 --> 01:15:27,520
so this is also observing the original

2061
01:15:27,520 --> 01:15:29,199
work by jos

2062
01:15:29,199 --> 01:15:31,600
which just says that um for a higher

2063
01:15:31,600 --> 01:15:33,440
random state or eq

2064
01:15:33,440 --> 01:15:37,120
more or less equivalently prs the

2065
01:15:37,120 --> 01:15:39,199
pseudo-random state output is highly

2066
01:15:39,199 --> 01:15:40,640
entangled

2067
01:15:40,640 --> 01:15:43,440
and this this is an issue because

2068
01:15:43,440 --> 01:15:44,239
an

2069
01:15:44,239 --> 01:15:46,320
entangled state is kind of brittle in

2070
01:15:46,320 --> 01:15:49,679
the following sense so for a concrete uh

2071
01:15:49,679 --> 01:15:50,800
problem

2072
01:15:50,800 --> 01:15:51,760
we

2073
01:15:51,760 --> 01:15:54,080
to the best of our uh to the best of my

2074
01:15:54,080 --> 01:15:55,679
knowledge we still don't know how to

2075
01:15:55,679 --> 01:15:58,159
prove some uh something like this which

2076
01:15:58,159 --> 01:16:02,080
is um assuming you have an n-qubit prs

2077
01:16:02,080 --> 01:16:05,040
uh can you construct an n-prime qubit

2078
01:16:05,040 --> 01:16:08,159
prs for any non-trivial m prime

2079
01:16:08,159 --> 01:16:11,040
for example starting with a

2080
01:16:11,040 --> 01:16:13,280
prs whose output is four times longer

2081
01:16:13,280 --> 01:16:15,280
than the seed can you construct another

2082
01:16:15,280 --> 01:16:18,800
prs that's only two times longer

2083
01:16:18,800 --> 01:16:21,520
and of course for prg this is trivial

2084
01:16:21,520 --> 01:16:24,000
you just truncated the second time

2085
01:16:24,000 --> 01:16:26,080
however this doesn't work for prs

2086
01:16:26,080 --> 01:16:28,159
because if you truncate the second half

2087
01:16:28,159 --> 01:16:30,239
you'll now get a mixed state because

2088
01:16:30,239 --> 01:16:33,040
they were entangled

2089
01:16:33,040 --> 01:16:36,400
and once it's mixed then it's no longer

2090
01:16:36,400 --> 01:16:38,239
indistinguishable from power end because

2091
01:16:38,239 --> 01:16:41,919
the high random state is a pure slip

2092
01:16:42,000 --> 01:16:43,520
and furthermore

2093
01:16:43,520 --> 01:16:44,880
for prs

2094
01:16:44,880 --> 01:16:46,080
even if

2095
01:16:46,080 --> 01:16:49,440
the output length is not expanding

2096
01:16:49,440 --> 01:16:51,440
um this object could still be

2097
01:16:51,440 --> 01:16:54,320
non-trivial in fact the uh oracle

2098
01:16:54,320 --> 01:16:56,800
separation consisted by a pressure has

2099
01:16:56,800 --> 01:16:59,520
the output length exactly as long as the

2100
01:16:59,520 --> 01:17:02,239
input c length

2101
01:17:02,239 --> 01:17:03,679
so um

2102
01:17:03,679 --> 01:17:05,840
well at the end of the day we came out

2103
01:17:05,840 --> 01:17:07,360
with this new

2104
01:17:07,360 --> 01:17:08,400
object

2105
01:17:08,400 --> 01:17:11,679
called which is a state analog of prf

2106
01:17:11,679 --> 01:17:14,159
which we call prfs which i'll define

2107
01:17:14,159 --> 01:17:16,080
shortly that

2108
01:17:16,080 --> 01:17:18,640
allows us to gather on these issues so

2109
01:17:18,640 --> 01:17:22,159
our result basically uh is summarized as

2110
01:17:22,159 --> 01:17:23,360
follows

2111
01:17:23,360 --> 01:17:25,840
so using this object i'll definitely

2112
01:17:25,840 --> 01:17:27,280
call prfs

2113
01:17:27,280 --> 01:17:28,480
as an

2114
01:17:28,480 --> 01:17:31,360
important intermediate uh construction

2115
01:17:31,360 --> 01:17:33,920
we showed uh the following uh

2116
01:17:33,920 --> 01:17:36,080
construction of useful cryptography from

2117
01:17:36,080 --> 01:17:38,400
the random states

2118
01:17:38,400 --> 01:17:40,800
so uh the first construction is that if

2119
01:17:40,800 --> 01:17:44,960
the prs output is super logarithmic long

2120
01:17:44,960 --> 01:17:48,080
then we can do one time encryption of

2121
01:17:48,080 --> 01:17:50,960
any message then

2122
01:17:50,960 --> 01:17:52,159
and

2123
01:17:52,159 --> 01:17:54,719
secondly

2124
01:17:54,800 --> 01:17:55,920
assuming

2125
01:17:55,920 --> 01:17:59,199
the prs output is a little bit more than

2126
01:17:59,199 --> 01:18:01,199
two log lambda

2127
01:18:01,199 --> 01:18:03,360
we can actually construct statistically

2128
01:18:03,360 --> 01:18:05,199
binding commitments

2129
01:18:05,199 --> 01:18:06,159
and

2130
01:18:06,159 --> 01:18:09,199
furthermore we also show how this

2131
01:18:09,199 --> 01:18:11,440
quantum commitment that we construct

2132
01:18:11,440 --> 01:18:14,080
is compatible with known literature

2133
01:18:14,080 --> 01:18:15,280
constructing

2134
01:18:15,280 --> 01:18:17,280
secure multi-party computation protocols

2135
01:18:17,280 --> 01:18:19,040
from only functions

2136
01:18:19,040 --> 01:18:22,560
and as a corollary we get

2137
01:18:22,560 --> 01:18:24,880
secure multiparty computations just

2138
01:18:24,880 --> 01:18:29,280
assuming pseudo-random states

2139
01:18:30,239 --> 01:18:32,800
so let me remark that these parameters

2140
01:18:32,800 --> 01:18:33,600
are

2141
01:18:33,600 --> 01:18:37,120
somewhat optimal in the asymptotic sense

2142
01:18:37,120 --> 01:18:39,520
so in particular this work by brakerski

2143
01:18:39,520 --> 01:18:40,960
and shimuli

2144
01:18:40,960 --> 01:18:44,080
show that if the output length is

2145
01:18:44,080 --> 01:18:46,719
logarithmic for some constant

2146
01:18:46,719 --> 01:18:48,000
then you can actually construct

2147
01:18:48,000 --> 01:18:50,719
statistically secure prs

2148
01:18:50,719 --> 01:18:53,920
and for all we know all of this uh

2149
01:18:53,920 --> 01:18:55,760
objects like one time encryption and

2150
01:18:55,760 --> 01:18:58,640
commitments are not possible information

2151
01:18:58,640 --> 01:18:59,840
theoretically

2152
01:18:59,840 --> 01:19:01,280
so um

2153
01:19:01,280 --> 01:19:02,960
so we do have to assume the output

2154
01:19:02,960 --> 01:19:04,560
length is at least some

2155
01:19:04,560 --> 01:19:06,800
some logarithmic however there's still

2156
01:19:06,800 --> 01:19:09,360
some gap which is basically saying that

2157
01:19:09,360 --> 01:19:10,159
um

2158
01:19:10,159 --> 01:19:12,800
there are some constant times log

2159
01:19:12,800 --> 01:19:15,840
uh so if the your output length is that

2160
01:19:15,840 --> 01:19:17,600
then we don't know whether it

2161
01:19:17,600 --> 01:19:20,480
gives you crypto nor do we know how to

2162
01:19:20,480 --> 01:19:23,760
construct it statistically

2163
01:19:23,760 --> 01:19:25,920
so the concurrent work which is

2164
01:19:25,920 --> 01:19:28,960
happening after our talk

2165
01:19:28,960 --> 01:19:32,239
considers a somewhat different prs

2166
01:19:32,239 --> 01:19:33,840
so they also show how to construct

2167
01:19:33,840 --> 01:19:35,840
commitments and also one-time signature

2168
01:19:35,840 --> 01:19:38,320
but they assume the output length is

2169
01:19:38,320 --> 01:19:39,760
expanding

2170
01:19:39,760 --> 01:19:40,560
but

2171
01:19:40,560 --> 01:19:42,239
on the flip side they only require the

2172
01:19:42,239 --> 01:19:44,400
prs to be secure when you're only given

2173
01:19:44,400 --> 01:19:47,040
a single copy whereas here we are

2174
01:19:47,040 --> 01:19:48,080
assume

2175
01:19:48,080 --> 01:19:51,280
many copies depending on the

2176
01:19:51,280 --> 01:19:54,320
the output length

2177
01:19:55,679 --> 01:19:58,480
okay um so i promise you i will talk

2178
01:19:58,480 --> 01:20:00,880
about this object so here it is so this

2179
01:20:00,880 --> 01:20:03,199
prfs is called pseudorandom function

2180
01:20:03,199 --> 01:20:05,679
like states which as i said is a

2181
01:20:05,679 --> 01:20:08,400
pseudo-random function analog to to the

2182
01:20:08,400 --> 01:20:10,560
random state

2183
01:20:10,560 --> 01:20:12,159
so we say

2184
01:20:12,159 --> 01:20:13,760
so i will just highlight the difference

2185
01:20:13,760 --> 01:20:16,480
between a prfs and prs

2186
01:20:16,480 --> 01:20:21,360
so basically for a prfs uh allows you to

2187
01:20:21,360 --> 01:20:23,520
uh so for the generator algorithm it

2188
01:20:23,520 --> 01:20:26,239
additionally allows you to give it a

2189
01:20:26,239 --> 01:20:28,320
short input x

2190
01:20:28,320 --> 01:20:31,679
and uh the c theorem uh you can think of

2191
01:20:31,679 --> 01:20:34,239
this input in the same way as an input

2192
01:20:34,239 --> 01:20:36,880
to a pseudo random function

2193
01:20:36,880 --> 01:20:39,920
and the pseudo randomness requirement

2194
01:20:39,920 --> 01:20:42,960
says that um again for any number of

2195
01:20:42,960 --> 01:20:46,480
copies but also for any uh number of

2196
01:20:46,480 --> 01:20:48,239
indices that you want to query through

2197
01:20:48,239 --> 01:20:49,679
this prfs

2198
01:20:49,679 --> 01:20:52,560
um the output states looks just like a

2199
01:20:52,560 --> 01:20:55,280
bunch of independent high random states

2200
01:20:55,280 --> 01:20:56,960
uh drawn from the higher random

2201
01:20:56,960 --> 01:20:59,520
distribution

2202
01:20:59,520 --> 01:21:01,440
um

2203
01:21:01,440 --> 01:21:04,719
and we remark that if we can have this

2204
01:21:04,719 --> 01:21:06,560
um prfs

2205
01:21:06,560 --> 01:21:08,560
uh object then

2206
01:21:08,560 --> 01:21:11,760
a lot of known classical crypto uh that

2207
01:21:11,760 --> 01:21:13,600
you build using prf

2208
01:21:13,600 --> 01:21:15,600
can also be built

2209
01:21:15,600 --> 01:21:18,560
readily built by replacing the pi with

2210
01:21:18,560 --> 01:21:21,280
prfs so this includes like secret key

2211
01:21:21,280 --> 01:21:23,040
encryptions

2212
01:21:23,040 --> 01:21:24,960
message authentication code and so on

2213
01:21:24,960 --> 01:21:28,080
and so forth

2214
01:21:28,080 --> 01:21:30,159
okay so um

2215
01:21:30,159 --> 01:21:32,080
so

2216
01:21:32,080 --> 01:21:34,560
i believe most of you might have a

2217
01:21:34,560 --> 01:21:38,080
natural question to ask me which is um

2218
01:21:38,080 --> 01:21:39,199
uh

2219
01:21:39,199 --> 01:21:40,800
okay but what about candidate

2220
01:21:40,800 --> 01:21:43,440
construction of pseudorandom state

2221
01:21:43,440 --> 01:21:46,560
and is this where i will finally talk

2222
01:21:46,560 --> 01:21:49,280
about wormholes

2223
01:21:49,280 --> 01:21:51,520
so stay tuned until the end of the talk

2224
01:21:51,520 --> 01:21:53,199
once i finish telling you how we

2225
01:21:53,199 --> 01:21:54,840
construct

2226
01:21:54,840 --> 01:21:58,239
um uh this crypto

2227
01:21:58,239 --> 01:22:00,000
okay so first let me tell you how we

2228
01:22:00,000 --> 01:22:01,760
construct pseudorandom function like

2229
01:22:01,760 --> 01:22:02,719
states

2230
01:22:02,719 --> 01:22:04,719
uh from prf

2231
01:22:04,719 --> 01:22:05,840
uh

2232
01:22:05,840 --> 01:22:08,480
so it turns out uh this is the crucial

2233
01:22:08,480 --> 01:22:10,639
observation that we made

2234
01:22:10,639 --> 01:22:12,480
that made this

2235
01:22:12,480 --> 01:22:14,560
construction work so let's say you're

2236
01:22:14,560 --> 01:22:18,239
given a quantum state of n qubits

2237
01:22:18,239 --> 01:22:20,960
well um one thing you can do is to take

2238
01:22:20,960 --> 01:22:22,639
the first qubit of this day and then

2239
01:22:22,639 --> 01:22:24,400
measure it

2240
01:22:24,400 --> 01:22:25,360
then

2241
01:22:25,360 --> 01:22:26,960
once you measure it will give you one of

2242
01:22:26,960 --> 01:22:29,280
two outcomes either zero or one just a

2243
01:22:29,280 --> 01:22:30,880
classical bit

2244
01:22:30,880 --> 01:22:34,480
and the remaining state which is now n

2245
01:22:34,480 --> 01:22:36,239
minus one cubits long because you

2246
01:22:36,239 --> 01:22:38,320
measure one qubit it's going to collapse

2247
01:22:38,320 --> 01:22:40,159
some post measurement state if you

2248
01:22:40,159 --> 01:22:42,159
measure zero and similarly if you

2249
01:22:42,159 --> 01:22:44,080
measure one you also get another post

2250
01:22:44,080 --> 01:22:46,000
measurement state

2251
01:22:46,000 --> 01:22:48,560
and it turns out that we can show that

2252
01:22:48,560 --> 01:22:51,760
if your starting state is high random so

2253
01:22:51,760 --> 01:22:53,040
it's drawn from the horizontal

2254
01:22:53,040 --> 01:22:54,480
distribution

2255
01:22:54,480 --> 01:22:57,040
then these two post measurement states

2256
01:22:57,040 --> 01:22:59,440
are actually close to independent copies

2257
01:22:59,440 --> 01:23:01,520
of power random states by themselves

2258
01:23:01,520 --> 01:23:03,120
although uh

2259
01:23:03,120 --> 01:23:06,480
they are shorter by one qubit

2260
01:23:06,480 --> 01:23:09,360
so this is a very powerful observation

2261
01:23:09,360 --> 01:23:11,040
because once we have this we can just

2262
01:23:11,040 --> 01:23:13,040
replace the random state with the prs

2263
01:23:13,040 --> 01:23:14,000
state

2264
01:23:14,000 --> 01:23:16,239
and we can say well now i've generated

2265
01:23:16,239 --> 01:23:20,440
two prs from one prs

2266
01:23:20,800 --> 01:23:24,159
um and furthermore you can extend this

2267
01:23:24,159 --> 01:23:26,080
uh construction to

2268
01:23:26,080 --> 01:23:28,239
measuring multiple qubits not just one

2269
01:23:28,239 --> 01:23:29,679
qubit

2270
01:23:29,679 --> 01:23:33,120
so uh so here's how we construct prfs

2271
01:23:33,120 --> 01:23:34,800
from prs

2272
01:23:34,800 --> 01:23:36,560
so basically you just

2273
01:23:36,560 --> 01:23:39,520
take the first dq bits

2274
01:23:39,520 --> 01:23:42,239
it doesn't matter which how you how you

2275
01:23:42,239 --> 01:23:44,639
label these qubits but you just take any

2276
01:23:44,639 --> 01:23:47,199
dq bits and then measure them

2277
01:23:47,199 --> 01:23:49,440
and then condition on getting x which is

2278
01:23:49,440 --> 01:23:52,000
your input you just output the post

2279
01:23:52,000 --> 01:23:53,360
measurement state on the remaining

2280
01:23:53,360 --> 01:23:56,239
qubits which is uh there are n minus

2281
01:23:56,239 --> 01:23:58,159
three of them

2282
01:23:58,159 --> 01:24:00,159
and we show that for higher random

2283
01:24:00,159 --> 01:24:01,679
distribution

2284
01:24:01,679 --> 01:24:04,560
this post-selection success probability

2285
01:24:04,560 --> 01:24:07,440
uh or like this conditioning this event

2286
01:24:07,440 --> 01:24:09,040
that we're conditioning on

2287
01:24:09,040 --> 01:24:11,520
this uh probability is exponentially

2288
01:24:11,520 --> 01:24:13,360
concentrated around

2289
01:24:13,360 --> 01:24:15,280
1 over 2 to the t

2290
01:24:15,280 --> 01:24:17,760
which means that if we can just do

2291
01:24:17,760 --> 01:24:21,040
rejection sampling to

2292
01:24:21,440 --> 01:24:23,679
to produce these states given that d is

2293
01:24:23,679 --> 01:24:26,960
only logarithmic law

2294
01:24:27,280 --> 01:24:29,679
okay so the formal theorem that we show

2295
01:24:29,679 --> 01:24:31,840
is that um

2296
01:24:31,840 --> 01:24:33,040
if you

2297
01:24:33,040 --> 01:24:36,000
have a d plus n qubit silly randomly

2298
01:24:36,000 --> 01:24:37,360
then you can

2299
01:24:37,360 --> 01:24:40,080
construct an n qubit prfs

2300
01:24:40,080 --> 01:24:42,800
with d bits input as long as this d is

2301
01:24:42,800 --> 01:24:45,840
only logarithmic

2302
01:24:46,159 --> 01:24:47,120
okay

2303
01:24:47,120 --> 01:24:49,040
so now let me tell you about how to

2304
01:24:49,040 --> 01:24:50,719
construct encryption

2305
01:24:50,719 --> 01:24:52,719
so the task of encryption is that two

2306
01:24:52,719 --> 01:24:54,239
parties share

2307
01:24:54,239 --> 01:24:55,760
some

2308
01:24:55,760 --> 01:24:57,040
secret

2309
01:24:57,040 --> 01:24:59,040
that is m bit long

2310
01:24:59,040 --> 01:25:01,440
and then uh let's say alice wants to

2311
01:25:01,440 --> 01:25:04,000
transmit a message she is going to send

2312
01:25:04,000 --> 01:25:07,199
a cipher text to both and then bob with

2313
01:25:07,199 --> 01:25:10,080
his secret can encode decode the message

2314
01:25:10,080 --> 01:25:11,600
and the security says that if the

2315
01:25:11,600 --> 01:25:15,920
ciphertext is given to a malicious party

2316
01:25:15,920 --> 01:25:18,320
he will not see learn anything about the

2317
01:25:18,320 --> 01:25:19,679
message

2318
01:25:19,679 --> 01:25:22,800
so an encryption is not trivial if the

2319
01:25:22,800 --> 01:25:24,639
message length is longer than the key

2320
01:25:24,639 --> 01:25:27,280
length where you cannot do one time path

2321
01:25:27,280 --> 01:25:29,040
and in fact um

2322
01:25:29,040 --> 01:25:30,960
classically we know anything like this

2323
01:25:30,960 --> 01:25:31,840
would

2324
01:25:31,840 --> 01:25:33,920
actually imply the existence of one way

2325
01:25:33,920 --> 01:25:36,000
functions

2326
01:25:36,000 --> 01:25:38,239
okay so now let's consider building a

2327
01:25:38,239 --> 01:25:40,080
quantum encryption so everything is the

2328
01:25:40,080 --> 01:25:43,280
same but the ciphertext is not quantum

2329
01:25:43,280 --> 01:25:46,400
and the goal is to build a one-time

2330
01:25:46,400 --> 01:25:47,520
encryption

2331
01:25:47,520 --> 01:25:49,679
of arbitrarily many bits much longer

2332
01:25:49,679 --> 01:25:51,199
than the

2333
01:25:51,199 --> 01:25:53,440
the starting c that your the starting

2334
01:25:53,440 --> 01:25:55,840
key that you are given

2335
01:25:55,840 --> 01:25:58,400
so once uh so i claim that this is easy

2336
01:25:58,400 --> 01:26:00,960
once you have prfs because what you can

2337
01:26:00,960 --> 01:26:03,600
do is to look at each bit in your

2338
01:26:03,600 --> 01:26:05,600
message so for example for the first bit

2339
01:26:05,600 --> 01:26:08,480
of the message if the message is the

2340
01:26:08,480 --> 01:26:10,800
first bit is zero then you can just send

2341
01:26:10,800 --> 01:26:14,159
the prfs date on input one

2342
01:26:14,159 --> 01:26:16,000
otherwise you just send a high random

2343
01:26:16,000 --> 01:26:17,520
state

2344
01:26:17,520 --> 01:26:20,320
and you just repeat this for every bit

2345
01:26:20,320 --> 01:26:23,199
and for bob what he can do is to to

2346
01:26:23,199 --> 01:26:25,040
decode the message he can just take

2347
01:26:25,040 --> 01:26:27,600
every higher random state try to project

2348
01:26:27,600 --> 01:26:29,679
it onto the prfs state because he knows

2349
01:26:29,679 --> 01:26:32,960
the key and if uh if which is basically

2350
01:26:32,960 --> 01:26:36,400
means test equality so if it equals the

2351
01:26:36,400 --> 01:26:39,040
um the prfs state then he will know that

2352
01:26:39,040 --> 01:26:41,199
this is uh this message bit was zero

2353
01:26:41,199 --> 01:26:42,960
otherwise he's going to say okay it's

2354
01:26:42,960 --> 01:26:44,719
probably a one

2355
01:26:44,719 --> 01:26:47,360
so um it's not hard to show that this

2356
01:26:47,360 --> 01:26:49,920
scheme is correct with probably like 1

2357
01:26:49,920 --> 01:26:50,960
minus

2358
01:26:50,960 --> 01:26:54,159
something like exponentially small in n

2359
01:26:54,159 --> 01:26:55,679
so

2360
01:26:55,679 --> 01:26:57,360
as long as the

2361
01:26:57,360 --> 01:27:00,080
the prfs output length is super

2362
01:27:00,080 --> 01:27:02,560
logarithmic this is correct except with

2363
01:27:02,560 --> 01:27:05,280
negligible probability

2364
01:27:05,280 --> 01:27:06,880
um

2365
01:27:06,880 --> 01:27:09,199
so and another crucial observation here

2366
01:27:09,199 --> 01:27:12,560
is that we only fed l different uh

2367
01:27:12,560 --> 01:27:15,040
inputs to the prfs so as long as the

2368
01:27:15,040 --> 01:27:16,719
input domain is

2369
01:27:16,719 --> 01:27:20,639
as large as l this construction works

2370
01:27:20,639 --> 01:27:23,199
and for security um

2371
01:27:23,199 --> 01:27:25,360
uh this immediately follows by the

2372
01:27:25,360 --> 01:27:27,840
security of prfs which says that no

2373
01:27:27,840 --> 01:27:29,679
matter what you are

2374
01:27:29,679 --> 01:27:33,440
encrypting all of these

2375
01:27:33,440 --> 01:27:35,520
all of these states should all look like

2376
01:27:35,520 --> 01:27:36,880
high random quantum state by the

2377
01:27:36,880 --> 01:27:40,080
security of prfs

2378
01:27:40,880 --> 01:27:42,239
okay

2379
01:27:42,239 --> 01:27:44,239
so for big commitment

2380
01:27:44,239 --> 01:27:47,199
um i think i'm i i'm running kind of

2381
01:27:47,199 --> 01:27:49,440
short on time so

2382
01:27:49,440 --> 01:27:52,320
um so i'll just give you a high-level

2383
01:27:52,320 --> 01:27:55,360
idea of how we constructed it

2384
01:27:55,360 --> 01:27:58,560
so this is uh the null commitment that

2385
01:27:58,560 --> 01:28:01,520
we all know uh how to construct from

2386
01:28:01,520 --> 01:28:03,760
pseudorandom generator

2387
01:28:03,760 --> 01:28:06,080
and it turns out that once you have prfs

2388
01:28:06,080 --> 01:28:08,560
then you can just replace the prg with

2389
01:28:08,560 --> 01:28:10,159
the prfs

2390
01:28:10,159 --> 01:28:12,400
so on a high level what you do is

2391
01:28:12,400 --> 01:28:14,719
previously you are sending the output of

2392
01:28:14,719 --> 01:28:16,080
the prg

2393
01:28:16,080 --> 01:28:17,679
plus uh

2394
01:28:17,679 --> 01:28:19,120
either

2395
01:28:19,120 --> 01:28:22,080
either a a random x or or you do not do

2396
01:28:22,080 --> 01:28:23,920
that random xor depending on which bit

2397
01:28:23,920 --> 01:28:26,480
you want to commit here you just

2398
01:28:26,480 --> 01:28:28,560
prepare the prfs date

2399
01:28:28,560 --> 01:28:30,320
so that it's long enough and then you

2400
01:28:30,320 --> 01:28:32,800
either apply a poly or not depending on

2401
01:28:32,800 --> 01:28:34,880
which bit you want to commit and then we

2402
01:28:34,880 --> 01:28:39,040
show how this is hiding and binding

2403
01:28:39,760 --> 01:28:42,880
so there are some subtleties um

2404
01:28:42,880 --> 01:28:44,719
of course first

2405
01:28:44,719 --> 01:28:46,239
because this is a quantum commitment

2406
01:28:46,239 --> 01:28:48,560
scheme what happens if uh if the

2407
01:28:48,560 --> 01:28:50,320
malicious commander commits to a

2408
01:28:50,320 --> 01:28:53,280
superposition over two two bits

2409
01:28:53,280 --> 01:28:56,560
and also i didn't really tell you

2410
01:28:56,560 --> 01:28:59,280
but how do we actually efficiently test

2411
01:28:59,280 --> 01:29:00,400
whether

2412
01:29:00,400 --> 01:29:01,840
these days

2413
01:29:01,840 --> 01:29:04,400
test equality basically if you send me a

2414
01:29:04,400 --> 01:29:06,960
prfs how do i actually test whether this

2415
01:29:06,960 --> 01:29:09,360
is the correct state

2416
01:29:09,360 --> 01:29:11,280
so i'm just going to refer you to the

2417
01:29:11,280 --> 01:29:12,320
paper

2418
01:29:12,320 --> 01:29:15,120
for for for these subtleties um

2419
01:29:15,120 --> 01:29:18,080
so we come up with a new binding

2420
01:29:18,080 --> 01:29:20,480
definition and then we also give a

2421
01:29:20,480 --> 01:29:22,320
testing circuit

2422
01:29:22,320 --> 01:29:25,760
okay so now i i should i last tell you

2423
01:29:25,760 --> 01:29:29,520
um candidate constructions of prfs

2424
01:29:29,520 --> 01:29:31,840
and why should they be

2425
01:29:31,840 --> 01:29:33,360
uh why should these candidate

2426
01:29:33,360 --> 01:29:36,840
constructions be independent of online

2427
01:29:36,840 --> 01:29:39,520
functions okay so the first candidates

2428
01:29:39,520 --> 01:29:41,199
come from uh

2429
01:29:41,199 --> 01:29:43,520
random content circuits so here's an

2430
01:29:43,520 --> 01:29:45,440
illustration

2431
01:29:45,440 --> 01:29:46,880
on a high level

2432
01:29:46,880 --> 01:29:48,320
um

2433
01:29:48,320 --> 01:29:50,560
it's just a bunch of random gates

2434
01:29:50,560 --> 01:29:52,880
applied on two two qubit at a time and

2435
01:29:52,880 --> 01:29:55,199
then you just repeat this process

2436
01:29:55,199 --> 01:29:57,280
so this thing can be described by a

2437
01:29:57,280 --> 01:29:58,800
classical key

2438
01:29:58,800 --> 01:30:00,159
um

2439
01:30:00,159 --> 01:30:01,920
which is basically describing which two

2440
01:30:01,920 --> 01:30:03,760
qubits you're acting on and then what is

2441
01:30:03,760 --> 01:30:04,840
the

2442
01:30:04,840 --> 01:30:07,280
action um so

2443
01:30:07,280 --> 01:30:09,600
the the way that you compute it is to

2444
01:30:09,600 --> 01:30:11,679
you start with the old zero state you

2445
01:30:11,679 --> 01:30:14,159
compute this random quantum circuit and

2446
01:30:14,159 --> 01:30:16,480
then you just take its output

2447
01:30:16,480 --> 01:30:18,880
and the conjecture is that this actually

2448
01:30:18,880 --> 01:30:21,360
gives you a pseudo-random state

2449
01:30:21,360 --> 01:30:22,800
and

2450
01:30:22,800 --> 01:30:24,800
this object is interesting because this

2451
01:30:24,800 --> 01:30:26,400
thing has already been studied in

2452
01:30:26,400 --> 01:30:29,440
various other contexts including quantum

2453
01:30:29,440 --> 01:30:30,719
supremacy

2454
01:30:30,719 --> 01:30:32,639
like the experiment that they are

2455
01:30:32,639 --> 01:30:34,480
performing is exactly on this kind of

2456
01:30:34,480 --> 01:30:36,560
circuit but also in the study of black

2457
01:30:36,560 --> 01:30:37,440
holes

2458
01:30:37,440 --> 01:30:39,679
and maybe we can even hope that maybe we

2459
01:30:39,679 --> 01:30:40,719
can get

2460
01:30:40,719 --> 01:30:42,400
uh

2461
01:30:42,400 --> 01:30:44,639
quantum crypto protocols that can be

2462
01:30:44,639 --> 01:30:47,040
realizable on near-term content devices

2463
01:30:47,040 --> 01:30:50,000
if we start with this kind of

2464
01:30:50,000 --> 01:30:52,639
candidate

2465
01:30:53,199 --> 01:30:56,560
okay and finally worm holes

2466
01:30:56,560 --> 01:30:59,040
so what is a wormhole a wormhole

2467
01:30:59,040 --> 01:31:01,920
is just two black holes connecting two

2468
01:31:01,920 --> 01:31:04,400
distinct regions of space-time as

2469
01:31:04,400 --> 01:31:07,120
illustrated here

2470
01:31:07,120 --> 01:31:08,400
so

2471
01:31:08,400 --> 01:31:10,639
so the toy model of a wormhole is that

2472
01:31:10,639 --> 01:31:13,199
you start with an initial state called

2473
01:31:13,199 --> 01:31:14,480
tft

2474
01:31:14,480 --> 01:31:16,880
and then there is some uh

2475
01:31:16,880 --> 01:31:19,360
unitary that governs how the

2476
01:31:19,360 --> 01:31:21,840
wormhole evolves over time

2477
01:31:21,840 --> 01:31:24,320
uh we denote the su

2478
01:31:24,320 --> 01:31:26,719
and so the construction is that we are

2479
01:31:26,719 --> 01:31:29,199
going to basically send random particles

2480
01:31:29,199 --> 01:31:31,040
into the wormhole

2481
01:31:31,040 --> 01:31:33,520
formerly this is captured by a shock

2482
01:31:33,520 --> 01:31:35,920
which is a random poly operator applied

2483
01:31:35,920 --> 01:31:37,760
on the first qubit so you can think of

2484
01:31:37,760 --> 01:31:40,239
this as some random particles that we're

2485
01:31:40,239 --> 01:31:42,960
sending into one side of the black hole

2486
01:31:42,960 --> 01:31:44,560
so here's the construction it's

2487
01:31:44,560 --> 01:31:46,880
basically you start with the state you

2488
01:31:46,880 --> 01:31:48,400
let it evolve for a while and then you

2489
01:31:48,400 --> 01:31:49,760
apply a shock

2490
01:31:49,760 --> 01:31:51,280
you will let it evolve for a while and

2491
01:31:51,280 --> 01:31:53,040
you apply a shock and then these shocks

2492
01:31:53,040 --> 01:31:56,400
will be the private key for the prs

2493
01:31:56,400 --> 01:31:59,679
and it is conjectured by this work uh

2494
01:31:59,679 --> 01:32:02,719
uh by boolean peppermint vadirani

2495
01:32:02,719 --> 01:32:03,520
uh

2496
01:32:03,520 --> 01:32:05,199
saying that this thing should be a

2497
01:32:05,199 --> 01:32:06,719
pseudo-random state

2498
01:32:06,719 --> 01:32:08,560
and they prove that this is true if you

2499
01:32:08,560 --> 01:32:09,360
can

2500
01:32:09,360 --> 01:32:14,080
model u as the random black box unitary

2501
01:32:14,800 --> 01:32:16,239
so maybe

2502
01:32:16,239 --> 01:32:19,199
we can hope that this is secure

2503
01:32:19,199 --> 01:32:21,600
just from the the

2504
01:32:21,600 --> 01:32:24,000
evidence that black holes are

2505
01:32:24,000 --> 01:32:25,280
scrambling

2506
01:32:25,280 --> 01:32:26,880
and therefore maybe we can use some

2507
01:32:26,880 --> 01:32:29,600
literature from backhoe physics to prove

2508
01:32:29,600 --> 01:32:32,080
its security

2509
01:32:32,080 --> 01:32:34,560
okay so these are the two candidates

2510
01:32:34,560 --> 01:32:36,800
uh wormhole and random quantum circuits

2511
01:32:36,800 --> 01:32:38,639
that i know of

2512
01:32:38,639 --> 01:32:40,880
i don't know any other more but i would

2513
01:32:40,880 --> 01:32:42,080
love to

2514
01:32:42,080 --> 01:32:42,960
um

2515
01:32:42,960 --> 01:32:45,840
but obviously we right now don't have

2516
01:32:45,840 --> 01:32:47,520
much formal evidence whether they are

2517
01:32:47,520 --> 01:32:49,199
secure or insecure

2518
01:32:49,199 --> 01:32:49,920
or

2519
01:32:49,920 --> 01:32:51,760
if they are actually independent when we

2520
01:32:51,760 --> 01:32:53,199
function although

2521
01:32:53,199 --> 01:32:55,840
it appears so

2522
01:32:55,840 --> 01:32:58,480
um and finally you could even hope that

2523
01:32:58,480 --> 01:33:00,159
maybe we can achieve better crypto

2524
01:33:00,159 --> 01:33:04,080
protocols from uh these candidates

2525
01:33:04,080 --> 01:33:06,400
okay so to conclude let me also mention

2526
01:33:06,400 --> 01:33:08,639
some other discussion

2527
01:33:08,639 --> 01:33:11,520
so our work really gives a

2528
01:33:11,520 --> 01:33:13,360
new research direction

2529
01:33:13,360 --> 01:33:15,199
which is considering quantum

2530
01:33:15,199 --> 01:33:17,760
cryptography and their relation with

2531
01:33:17,760 --> 01:33:20,719
quantum computational hardness

2532
01:33:20,719 --> 01:33:23,600
so um as i mentioned there are some

2533
01:33:23,600 --> 01:33:25,920
output lengths for which prs neither

2534
01:33:25,920 --> 01:33:28,080
suffices for statistical construction or

2535
01:33:28,080 --> 01:33:29,120
crypto

2536
01:33:29,120 --> 01:33:31,360
so ideally i would like to close this

2537
01:33:31,360 --> 01:33:32,320
gap

2538
01:33:32,320 --> 01:33:35,120
and also what other interesting quantum

2539
01:33:35,120 --> 01:33:36,960
hardness lies beyond consideration

2540
01:33:36,960 --> 01:33:39,360
states

2541
01:33:39,520 --> 01:33:40,480
so

2542
01:33:40,480 --> 01:33:43,760
there is an upcoming work that

2543
01:33:43,760 --> 01:33:46,960
partially gives some solution for these

2544
01:33:46,960 --> 01:33:49,760
problems and we also give somewhat

2545
01:33:49,760 --> 01:33:51,360
minimal primitive for quantum

2546
01:33:51,360 --> 01:33:53,520
cryptography okay so that's all thank

2547
01:33:53,520 --> 01:33:55,679
you

2548
01:34:00,080 --> 01:34:01,679
okay thank you for this great talk do

2549
01:34:01,679 --> 01:34:03,840
you have any questions then please come

2550
01:34:03,840 --> 01:34:05,840
forward

2551
01:34:05,840 --> 01:34:08,840
yes

2552
01:34:18,480 --> 01:34:21,520
i i don't know if the question uh uh

2553
01:34:21,520 --> 01:34:23,840
really makes any sense um

2554
01:34:23,840 --> 01:34:27,280
but i have given myself the privilege of

2555
01:34:27,280 --> 01:34:30,080
asking what i call stupid quantum

2556
01:34:30,080 --> 01:34:31,360
questions

2557
01:34:31,360 --> 01:34:34,239
of which there are many um

2558
01:34:34,239 --> 01:34:35,520
do

2559
01:34:35,520 --> 01:34:39,280
errors help with this

2560
01:34:39,280 --> 01:34:42,159
if the circuits are uh

2561
01:34:42,159 --> 01:34:44,960
are not accurate if there's uh if there

2562
01:34:44,960 --> 01:34:47,199
are quantum errors in this

2563
01:34:47,199 --> 01:34:50,559
does that help or hurt you

2564
01:34:52,080 --> 01:34:53,280
so you mean

2565
01:34:53,280 --> 01:34:55,600
does it help or hurt making

2566
01:34:55,600 --> 01:34:58,239
cryptographic applications

2567
01:34:58,239 --> 01:35:01,239
um

2568
01:35:02,239 --> 01:35:03,600
i don't know

2569
01:35:03,600 --> 01:35:05,679
i haven't thought about it much yeah

2570
01:35:05,679 --> 01:35:08,000
sorry

2571
01:35:10,159 --> 01:35:11,600
if there's no more questions you know i

2572
01:35:11,600 --> 01:35:13,199
hope to see this black hole

2573
01:35:13,199 --> 01:35:16,400
implementation next year

2574
01:35:16,400 --> 01:35:17,760
so let's tag the speakers of this

2575
01:35:17,760 --> 01:35:22,119
session again and thank you

