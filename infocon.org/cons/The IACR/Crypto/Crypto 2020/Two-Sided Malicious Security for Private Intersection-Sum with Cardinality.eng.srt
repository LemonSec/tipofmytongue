1
00:00:04,080 --> 00:00:06,160
hey everyone so today i'll be talking

2
00:00:05,759 --> 00:00:09,519
about

3
00:00:06,160 --> 00:00:11,759
our moment two-sided malicious security

4
00:00:09,519 --> 00:00:13,519
for private intersection some and this

5
00:00:11,759 --> 00:00:14,480
is trying to work with my co-authors at

6
00:00:13,519 --> 00:00:17,759
google

7
00:00:14,480 --> 00:00:18,800
and with peyton meow who's uh

8
00:00:17,760 --> 00:00:22,240
starting as a professor at the

9
00:00:18,800 --> 00:00:22,240
university of new orleans chicago

10
00:00:22,560 --> 00:00:27,359
uh it's the first i'm gonna describe the

11
00:00:24,400 --> 00:00:29,278
problem and why we care about it

12
00:00:27,359 --> 00:00:31,279
uh so our problem is a special case of

13
00:00:29,279 --> 00:00:32,640
secure multi-party computation so as

14
00:00:31,279 --> 00:00:34,160
most of you already know signal

15
00:00:32,640 --> 00:00:35,680
multi-party computation or at least

16
00:00:34,160 --> 00:00:38,000
two-party computation

17
00:00:35,680 --> 00:00:38,879
so we have two parties with inputs x and

18
00:00:38,000 --> 00:00:41,200
y

19
00:00:38,879 --> 00:00:42,879
and they want to compute functions f and

20
00:00:41,200 --> 00:00:45,280
g on

21
00:00:42,879 --> 00:00:46,879
their joint inputs such that neither

22
00:00:45,280 --> 00:00:50,000
party learns anything additional about

23
00:00:46,879 --> 00:00:50,000
the audience's input

24
00:00:50,160 --> 00:00:53,279
and so rare focus on this functionality

25
00:00:52,559 --> 00:00:55,519
which we call

26
00:00:53,280 --> 00:00:56,960
private intersections some with

27
00:00:55,520 --> 00:00:59,039
cardinality

28
00:00:56,960 --> 00:01:01,520
where it's basically a special case of

29
00:00:59,039 --> 00:01:02,960
secure multi-quarter computation

30
00:01:01,520 --> 00:01:06,159
where the output that the parties want

31
00:01:02,960 --> 00:01:09,520
to learn is the size of the intersection

32
00:01:06,159 --> 00:01:12,640
of their databases and also the sum

33
00:01:09,520 --> 00:01:13,600
of the associated values for values in

34
00:01:12,640 --> 00:01:15,759
the intersection

35
00:01:13,600 --> 00:01:17,199
so here the items in the intersection

36
00:01:15,759 --> 00:01:20,479
are the intersection between

37
00:01:17,200 --> 00:01:21,520
inputs x and y and one party holds some

38
00:01:20,479 --> 00:01:24,640
weights w

39
00:01:21,520 --> 00:01:26,720
or values w w one to wn

40
00:01:24,640 --> 00:01:27,759
and the party should also learn the sum

41
00:01:26,720 --> 00:01:30,560
of the wi

42
00:01:27,759 --> 00:01:31,040
for those xlyi that were in common

43
00:01:30,560 --> 00:01:34,640
between

44
00:01:31,040 --> 00:01:36,159
two and why do we care about this uh

45
00:01:34,640 --> 00:01:37,119
problem well it turns out to have a

46
00:01:36,159 --> 00:01:39,840
great deal of

47
00:01:37,119 --> 00:01:40,880
uh practical applications so google

48
00:01:39,840 --> 00:01:42,560
recently had a

49
00:01:40,880 --> 00:01:44,640
not that recent maybe a couple years ago

50
00:01:42,560 --> 00:01:46,240
had a blog post about

51
00:01:44,640 --> 00:01:48,240
what they call private joining compute

52
00:01:46,240 --> 00:01:49,199
which describes exactly this problem and

53
00:01:48,240 --> 00:01:54,560
they talk about many

54
00:01:49,200 --> 00:01:56,399
interesting applications including to

55
00:01:54,560 --> 00:01:57,430
privately measuring aggregate ad

56
00:01:56,399 --> 00:01:58,719
conversions

57
00:01:57,430 --> 00:02:00,399
[Music]

58
00:01:58,719 --> 00:02:02,079
and facebook is recently shown also

59
00:02:00,399 --> 00:02:04,320
interested in this problem and they've

60
00:02:02,079 --> 00:02:06,798
uh also had a recent blog post talking

61
00:02:04,320 --> 00:02:09,359
about private journal compute and other

62
00:02:06,799 --> 00:02:10,319
ancillary protocols and they've also

63
00:02:09,360 --> 00:02:12,239
talked about

64
00:02:10,318 --> 00:02:13,839
the usefulness of being able to compute

65
00:02:12,239 --> 00:02:16,959
sums over an intersection

66
00:02:13,840 --> 00:02:18,720
in a private way so this is a problem

67
00:02:16,959 --> 00:02:22,640
which we know has a lot of

68
00:02:18,720 --> 00:02:25,680
interest in practice uh

69
00:02:22,640 --> 00:02:28,079
and so just to recap some of the problem

70
00:02:25,680 --> 00:02:29,599
the characteristics of the problem of

71
00:02:28,080 --> 00:02:31,519
private journal compute or prior

72
00:02:29,599 --> 00:02:36,160
intersections on the cardinality

73
00:02:31,519 --> 00:02:38,319
so uh in the original work by google

74
00:02:36,160 --> 00:02:39,920
they discuss mostly honest but curious

75
00:02:38,319 --> 00:02:43,200
security

76
00:02:39,920 --> 00:02:46,238
uh which means participants are assumed

77
00:02:43,200 --> 00:02:47,679
to follow the protocol steps honestly

78
00:02:46,239 --> 00:02:50,239
but try to learn as much as they can

79
00:02:47,680 --> 00:02:52,640
from the transcript and

80
00:02:50,239 --> 00:02:54,400
the protocol the applications also

81
00:02:52,640 --> 00:02:56,238
assume that both parties receive the

82
00:02:54,400 --> 00:02:59,680
output of the protocol

83
00:02:56,239 --> 00:03:00,480
and furthermore the main measures of

84
00:02:59,680 --> 00:03:03,440
efficiency

85
00:03:00,480 --> 00:03:05,359
are communication costs and monetary

86
00:03:03,440 --> 00:03:08,480
costs of running the protocol

87
00:03:05,360 --> 00:03:09,519
and these those papers claim uh are more

88
00:03:08,480 --> 00:03:13,440
important than

89
00:03:09,519 --> 00:03:15,599
in turn on time and a special pieces are

90
00:03:13,440 --> 00:03:19,040
revealing the size of the intersection

91
00:03:15,599 --> 00:03:20,879
is uh okay or even desirable or useful

92
00:03:19,040 --> 00:03:22,560
for some of the applications

93
00:03:20,879 --> 00:03:24,000
uh this is interesting because in many

94
00:03:22,560 --> 00:03:25,280
cases like where you want to compute

95
00:03:24,000 --> 00:03:27,040
over the intersection

96
00:03:25,280 --> 00:03:28,879
like being forced to review the size of

97
00:03:27,040 --> 00:03:30,959
the intersection is seen as an

98
00:03:28,879 --> 00:03:32,319
undesirable leakage but in the case of

99
00:03:30,959 --> 00:03:35,519
some of the applications we actually

100
00:03:32,319 --> 00:03:35,518
need this intersection set

101
00:03:35,680 --> 00:03:38,799
so in this work we're going to be

102
00:03:36,959 --> 00:03:41,200
focused on keeping

103
00:03:38,799 --> 00:03:43,200
all those other constraints that come

104
00:03:41,200 --> 00:03:45,679
from the practical applications like

105
00:03:43,200 --> 00:03:46,399
both sides receiving the output focusing

106
00:03:45,680 --> 00:03:48,000
on uh

107
00:03:46,400 --> 00:03:49,920
minimizing communication costs and

108
00:03:48,000 --> 00:03:51,200
monetary costs and being okay with doing

109
00:03:49,920 --> 00:03:52,720
intersection sets

110
00:03:51,200 --> 00:03:54,720
but trying to beef up the security

111
00:03:52,720 --> 00:03:56,959
guarantee that we can provide by

112
00:03:54,720 --> 00:03:58,799
providing security against malicious or

113
00:03:56,959 --> 00:04:00,000
active adversaries who can arbitrarily

114
00:03:58,799 --> 00:04:01,760
deviate from the protocol

115
00:04:00,000 --> 00:04:04,480
in order to try to learn more that

116
00:04:01,760 --> 00:04:04,480
they're supposed to

117
00:04:05,040 --> 00:04:08,798
uh so i'd like to start by first talking

118
00:04:07,200 --> 00:04:11,599
about some straightforward approaches

119
00:04:08,799 --> 00:04:12,720
that uh normally you should check when

120
00:04:11,599 --> 00:04:15,760
you're trying to go from

121
00:04:12,720 --> 00:04:19,120
a semi on a secure protocol to a

122
00:04:15,760 --> 00:04:21,199
security against malicious adversaries

123
00:04:19,120 --> 00:04:22,720
so i'll quickly go through some of these

124
00:04:21,199 --> 00:04:23,680
so the first straightforward approach is

125
00:04:22,720 --> 00:04:25,840
to just add

126
00:04:23,680 --> 00:04:27,520
zero knowledge proofs to each step of

127
00:04:25,840 --> 00:04:29,119
the semi honors protocol

128
00:04:27,520 --> 00:04:31,840
to make it so that each party has to

129
00:04:29,120 --> 00:04:33,120
prove that they did their set correctly

130
00:04:31,840 --> 00:04:36,000
and that's how you normally get

131
00:04:33,120 --> 00:04:37,600
religious security

132
00:04:36,000 --> 00:04:39,840
um but to see why we run into

133
00:04:37,600 --> 00:04:42,080
difficulties let's just quickly recap

134
00:04:39,840 --> 00:04:43,520
what happens in the semi honest protocol

135
00:04:42,080 --> 00:04:45,039
so you have these parties with their

136
00:04:43,520 --> 00:04:46,880
inputs and what they're going to do is

137
00:04:45,040 --> 00:04:49,040
they're going to generate keys for

138
00:04:46,880 --> 00:04:51,120
the polaroid helmet cipher over some

139
00:04:49,040 --> 00:04:53,759
group uh let's say it's an elliptic

140
00:04:51,120 --> 00:04:55,360
group for now and so the first party is

141
00:04:53,759 --> 00:04:56,880
going to take each of its inputs and

142
00:04:55,360 --> 00:04:59,440
then

143
00:04:56,880 --> 00:05:00,159
hash it into the curve for the cipher

144
00:04:59,440 --> 00:05:03,199
and then

145
00:05:00,160 --> 00:05:05,520
encrypt it using its keyshare k1 and

146
00:05:03,199 --> 00:05:06,880
send them all to the second party

147
00:05:05,520 --> 00:05:08,639
and then the second party is going to

148
00:05:06,880 --> 00:05:09,280
apply a second layer of public helmet

149
00:05:08,639 --> 00:05:11,039
encryption

150
00:05:09,280 --> 00:05:12,559
and then shuffle these double encrypted

151
00:05:11,039 --> 00:05:14,080
values and send them back to the first

152
00:05:12,560 --> 00:05:16,479
party

153
00:05:14,080 --> 00:05:18,000
then the second party is going to single

154
00:05:16,479 --> 00:05:20,960
encrypt its

155
00:05:18,000 --> 00:05:21,680
values y1 to yn and then also send along

156
00:05:20,960 --> 00:05:24,320
its

157
00:05:21,680 --> 00:05:24,800
associated values w1 to wn encrypted

158
00:05:24,320 --> 00:05:26,400
using

159
00:05:24,800 --> 00:05:28,240
an additive homomorphic encryption

160
00:05:26,400 --> 00:05:31,679
scheme

161
00:05:28,240 --> 00:05:33,840
and the first part is going to added the

162
00:05:31,680 --> 00:05:35,520
encryption layer of k1 to the second

163
00:05:33,840 --> 00:05:38,479
party's inputs and then now

164
00:05:35,520 --> 00:05:39,440
both parties party says inputs are in

165
00:05:38,479 --> 00:05:42,479
this double

166
00:05:39,440 --> 00:05:44,160
encrypted space including the k1 and k2

167
00:05:42,479 --> 00:05:45,520
and so the first part you can just

168
00:05:44,160 --> 00:05:48,320
determine which of

169
00:05:45,520 --> 00:05:50,560
the items are in the intersection and

170
00:05:48,320 --> 00:05:53,520
thereby learn the intersection size

171
00:05:50,560 --> 00:05:55,280
and then also add together the

172
00:05:53,520 --> 00:05:57,120
corresponding homomorphic encryptions to

173
00:05:55,280 --> 00:05:58,000
get an encryption of the intersection

174
00:05:57,120 --> 00:05:59,440
sum

175
00:05:58,000 --> 00:06:00,639
and then send this back to the first

176
00:05:59,440 --> 00:06:01,440
part of the second party to get

177
00:06:00,639 --> 00:06:03,840
decrypted and

178
00:06:01,440 --> 00:06:05,520
we'll send it back let's tell both

179
00:06:03,840 --> 00:06:07,198
parties to know the cardinality and the

180
00:06:05,520 --> 00:06:09,198
sum

181
00:06:07,199 --> 00:06:10,880
uh so now the first problem we get when

182
00:06:09,199 --> 00:06:12,960
trying to add proofs everywhere here

183
00:06:10,880 --> 00:06:14,800
is it's easy to prove that everything is

184
00:06:12,960 --> 00:06:16,638
exponential to the same exponent

185
00:06:14,800 --> 00:06:18,639
but actually we also have to prove that

186
00:06:16,639 --> 00:06:21,600
the thing that's being exponentiated

187
00:06:18,639 --> 00:06:23,120
is a hash of something to improve and

188
00:06:21,600 --> 00:06:24,720
then proving this hash

189
00:06:23,120 --> 00:06:26,880
actually turns out to be very annoying

190
00:06:24,720 --> 00:06:28,800
and expensive

191
00:06:26,880 --> 00:06:30,479
so that's one problem with following

192
00:06:28,800 --> 00:06:33,039
this first recipe

193
00:06:30,479 --> 00:06:34,880
and the second thing is the first party

194
00:06:33,039 --> 00:06:36,318
uh you know does this thing of figuring

195
00:06:34,880 --> 00:06:37,919
out what things are in the intersection

196
00:06:36,319 --> 00:06:38,800
and sum the corresponding values

197
00:06:37,919 --> 00:06:40,799
together

198
00:06:38,800 --> 00:06:42,960
but how is the first party supposed to

199
00:06:40,800 --> 00:06:44,639
prove to the second party that it sum

200
00:06:42,960 --> 00:06:47,359
the right things and not just whatever

201
00:06:44,639 --> 00:06:48,080
it was like like this also turns out to

202
00:06:47,360 --> 00:06:50,639
be uh

203
00:06:48,080 --> 00:06:52,159
quite an annoying thing to prove um to

204
00:06:50,639 --> 00:06:55,120
create a proof for

205
00:06:52,160 --> 00:06:55,759
and so this is the second difficulty

206
00:06:55,120 --> 00:06:58,000
that we get

207
00:06:55,759 --> 00:06:58,960
uh we're trying to follow this strategy

208
00:06:58,000 --> 00:07:02,080
so

209
00:06:58,960 --> 00:07:03,198
the strategy has some people teasing so

210
00:07:02,080 --> 00:07:06,240
the second strategy

211
00:07:03,199 --> 00:07:08,400
is to take an existing protocol that uh

212
00:07:06,240 --> 00:07:09,759
gives malicious security for a private

213
00:07:08,400 --> 00:07:12,960
set intersection

214
00:07:09,759 --> 00:07:14,560
and uh but that only has one-sided

215
00:07:12,960 --> 00:07:17,680
output and then transform it into a

216
00:07:14,560 --> 00:07:19,360
protocol that has two separate outputs

217
00:07:17,680 --> 00:07:21,120
and there's actually several excellent

218
00:07:19,360 --> 00:07:22,319
works that uh give very efficient

219
00:07:21,120 --> 00:07:25,120
protocols for

220
00:07:22,319 --> 00:07:27,919
a private set intersection with

221
00:07:25,120 --> 00:07:29,520
one-sided output

222
00:07:27,919 --> 00:07:31,599
with security against malicious cyber

223
00:07:29,520 --> 00:07:33,280
states

224
00:07:31,599 --> 00:07:35,199
and the standard way for returning a

225
00:07:33,280 --> 00:07:37,119
one-sided output protocol into two-sided

226
00:07:35,199 --> 00:07:38,720
output protocol is to have both parties

227
00:07:37,120 --> 00:07:40,560
commit to their inputs

228
00:07:38,720 --> 00:07:42,160
and then run the protocol first in one

229
00:07:40,560 --> 00:07:44,240
direction and then in second

230
00:07:42,160 --> 00:07:45,919
in the other direction one party being

231
00:07:44,240 --> 00:07:47,680
the output receiver and the other party

232
00:07:45,919 --> 00:07:50,400
in the output receiver

233
00:07:47,680 --> 00:07:51,440
and then in each of these executions

234
00:07:50,400 --> 00:07:53,440
proving that

235
00:07:51,440 --> 00:07:55,199
the inputs used by the parties are the

236
00:07:53,440 --> 00:07:57,120
committed influence

237
00:07:55,199 --> 00:07:59,280
and this is a straightforward recipe and

238
00:07:57,120 --> 00:08:02,479
it works but the problem is proving

239
00:07:59,280 --> 00:08:05,440
using any of those existing protocols

240
00:08:02,479 --> 00:08:06,800
with proofs that you use the inputs that

241
00:08:05,440 --> 00:08:08,240
we're committed to

242
00:08:06,800 --> 00:08:10,840
actually turns out to be not

243
00:08:08,240 --> 00:08:12,160
straightforward and adds a bunch of

244
00:08:10,840 --> 00:08:14,878
expense

245
00:08:12,160 --> 00:08:16,400
so basically this also runs into this

246
00:08:14,879 --> 00:08:20,080
problem that it's not easy to compose

247
00:08:16,400 --> 00:08:22,239
these protocols with committed inputs

248
00:08:20,080 --> 00:08:24,719
and the third option is to use generic

249
00:08:22,240 --> 00:08:27,360
secure computation techniques

250
00:08:24,720 --> 00:08:28,479
and there are actually grape works that

251
00:08:27,360 --> 00:08:30,879
do this as well so

252
00:08:28,479 --> 00:08:32,559
one prominent one is a one that uses

253
00:08:30,879 --> 00:08:33,919
garbled circuits in order to do private

254
00:08:32,559 --> 00:08:36,159
set intersection

255
00:08:33,919 --> 00:08:38,478
uh using the so-called sword compare

256
00:08:36,159 --> 00:08:40,240
shuffle technique

257
00:08:38,479 --> 00:08:42,399
and this is great because this actually

258
00:08:40,240 --> 00:08:46,160
extends straightforwardly to

259
00:08:42,399 --> 00:08:48,560
uh malicious security it also enables

260
00:08:46,160 --> 00:08:50,560
a two-sided output for the protocol and

261
00:08:48,560 --> 00:08:52,000
it also enables computing functions of

262
00:08:50,560 --> 00:08:55,119
associated data

263
00:08:52,000 --> 00:08:56,800
for things in the intersection

264
00:08:55,120 --> 00:08:58,160
but the problem is that these generic

265
00:08:56,800 --> 00:09:01,439
techniques usually incur

266
00:08:58,160 --> 00:09:03,199
very high communication costs and

267
00:09:01,440 --> 00:09:05,920
because of that very high

268
00:09:03,200 --> 00:09:06,560
monetary cost and this is usually

269
00:09:05,920 --> 00:09:07,839
because

270
00:09:06,560 --> 00:09:09,760
in order to do these techniques you have

271
00:09:07,839 --> 00:09:11,360
to bit wise encrypt each of your inputs

272
00:09:09,760 --> 00:09:13,680
and that causes a large communication

273
00:09:11,360 --> 00:09:13,680
rule

274
00:09:14,399 --> 00:09:18,399
so our approach or our contribution is

275
00:09:16,480 --> 00:09:20,560
going to be to

276
00:09:18,399 --> 00:09:23,040
give a new protocol that gives private

277
00:09:20,560 --> 00:09:24,959
set intersection with cardinality

278
00:09:23,040 --> 00:09:27,279
security against malicious adversaries

279
00:09:24,959 --> 00:09:29,518
supports two-sided output

280
00:09:27,279 --> 00:09:31,040
and has communication costs that's only

281
00:09:29,519 --> 00:09:33,760
modestly larger

282
00:09:31,040 --> 00:09:36,319
than the semi-honors protocol based on

283
00:09:33,760 --> 00:09:37,600
decisional tiffy helmet

284
00:09:36,320 --> 00:09:39,680
that's the private joining compute

285
00:09:37,600 --> 00:09:40,640
protocol and monetary costs that's

286
00:09:39,680 --> 00:09:42,719
somewhat larger

287
00:09:40,640 --> 00:09:44,720
than the semi-honors protocol based on

288
00:09:42,720 --> 00:09:45,200
dbh and here monitor costs are going to

289
00:09:44,720 --> 00:09:48,839
measure

290
00:09:45,200 --> 00:09:50,800
using resource costs for cloud machines

291
00:09:48,839 --> 00:09:54,000
in

292
00:09:50,800 --> 00:09:54,000
from a public cloud provider

293
00:09:54,240 --> 00:09:59,760
okay so now let's start getting into uh

294
00:09:56,800 --> 00:10:01,439
what our exact construction is

295
00:09:59,760 --> 00:10:03,600
so our idea is going to be kind of to

296
00:10:01,440 --> 00:10:05,279
follow the recipe for the private joint

297
00:10:03,600 --> 00:10:07,680
and compute protocol

298
00:10:05,279 --> 00:10:10,480
and inside that our first step is going

299
00:10:07,680 --> 00:10:11,680
to be to build a distributed opiate the

300
00:10:10,480 --> 00:10:14,640
defibrillator

301
00:10:11,680 --> 00:10:16,000
is where two parties have shares of keys

302
00:10:14,640 --> 00:10:18,240
k1 and k2

303
00:10:16,000 --> 00:10:20,240
and one party has a bunch of inputs and

304
00:10:18,240 --> 00:10:21,440
at the end of the distributed oprf

305
00:10:20,240 --> 00:10:24,240
protocol

306
00:10:21,440 --> 00:10:25,279
both bodies are going to learn the

307
00:10:24,240 --> 00:10:28,640
evaluation

308
00:10:25,279 --> 00:10:31,839
of a pseudorandom function f which has

309
00:10:28,640 --> 00:10:32,319
you know both keys k1 and k2 as this key

310
00:10:31,839 --> 00:10:36,240
and

311
00:10:32,320 --> 00:10:38,240
uh evaluator on each of the inputs

312
00:10:36,240 --> 00:10:40,480
uh and the reason that both parties can

313
00:10:38,240 --> 00:10:43,040
learn the output is that like as long as

314
00:10:40,480 --> 00:10:45,040
uh not both the part like uh neither

315
00:10:43,040 --> 00:10:46,399
party has both the key shares so the

316
00:10:45,040 --> 00:10:48,240
output is going to look super random to

317
00:10:46,399 --> 00:10:50,000
each of the parties

318
00:10:48,240 --> 00:10:52,720
so our first idea is to build a

319
00:10:50,000 --> 00:10:54,399
distributed oprf protocol

320
00:10:52,720 --> 00:10:56,560
and of course secure against malicious

321
00:10:54,399 --> 00:10:58,160
adversaries

322
00:10:56,560 --> 00:11:00,000
and then we're going to extend this so

323
00:10:58,160 --> 00:11:02,000
that the party who provided the inputs

324
00:11:00,000 --> 00:11:03,680
is not going to learn the

325
00:11:02,000 --> 00:11:05,440
outputs in the same order but it's going

326
00:11:03,680 --> 00:11:07,040
to learn them in shuffled order with the

327
00:11:05,440 --> 00:11:08,640
order of shuffling chosen by the other

328
00:11:07,040 --> 00:11:10,160
40.

329
00:11:08,640 --> 00:11:12,079
and the point of this shuffling is so

330
00:11:10,160 --> 00:11:13,439
that the party is not going to be able

331
00:11:12,079 --> 00:11:14,640
to figure out exact

332
00:11:13,440 --> 00:11:16,160
later on the party's not going to be

333
00:11:14,640 --> 00:11:17,600
able to figure out exactly which items

334
00:11:16,160 --> 00:11:19,279
are in the intersection but rather it's

335
00:11:17,600 --> 00:11:20,480
only going to see how many items are in

336
00:11:19,279 --> 00:11:22,560
the intersection

337
00:11:20,480 --> 00:11:25,600
this is similar to the strategy taken in

338
00:11:22,560 --> 00:11:27,119
the semi honest protocol

339
00:11:25,600 --> 00:11:28,640
and in order to achieve the shuffling

340
00:11:27,120 --> 00:11:29,040
with malicious security we're going to

341
00:11:28,640 --> 00:11:30,640
use

342
00:11:29,040 --> 00:11:32,800
a shuffle proof and there's many of

343
00:11:30,640 --> 00:11:34,160
these in the literature we're going to

344
00:11:32,800 --> 00:11:36,319
use the specific one which we'll talk

345
00:11:34,160 --> 00:11:38,640
about later

346
00:11:36,320 --> 00:11:41,200
and so once we have the shuffle

347
00:11:38,640 --> 00:11:42,399
distributed oprf we're actually all set

348
00:11:41,200 --> 00:11:45,760
to get a protocol

349
00:11:42,399 --> 00:11:47,600
for just the psi cardinality

350
00:11:45,760 --> 00:11:49,040
part of the problem which is to find the

351
00:11:47,600 --> 00:11:50,639
intersection phase

352
00:11:49,040 --> 00:11:52,079
and the way we're going to do this is

353
00:11:50,639 --> 00:11:54,800
we're just going to have

354
00:11:52,079 --> 00:11:57,040
the sdo prf evaluated first on one

355
00:11:54,800 --> 00:11:58,880
party's inputs and then evaluator on the

356
00:11:57,040 --> 00:12:02,880
second party's inputs and then we have

357
00:11:58,880 --> 00:12:06,320
to do it with the key the same keys

358
00:12:02,880 --> 00:12:08,839
and since the seo prf uh has a property

359
00:12:06,320 --> 00:12:10,160
that both parties receive the opr

360
00:12:08,839 --> 00:12:11,680
evaluations

361
00:12:10,160 --> 00:12:13,040
now both parties can just look at the

362
00:12:11,680 --> 00:12:14,160
transcripts from each of these two

363
00:12:13,040 --> 00:12:16,800
different

364
00:12:14,160 --> 00:12:17,600
protocol executions and see how many of

365
00:12:16,800 --> 00:12:19,359
the opr

366
00:12:17,600 --> 00:12:20,880
outputs were the same between the two

367
00:12:19,360 --> 00:12:24,560
and that's how they can figure out what

368
00:12:20,880 --> 00:12:26,399
the intersection size is

369
00:12:24,560 --> 00:12:27,920
and so this gives us cardinality and

370
00:12:26,399 --> 00:12:29,760
then now if you want to extend

371
00:12:27,920 --> 00:12:31,279
the sum so now one party has these

372
00:12:29,760 --> 00:12:32,959
associated values

373
00:12:31,279 --> 00:12:34,399
what we're going to do is use a

374
00:12:32,959 --> 00:12:37,040
homomorphic encryption

375
00:12:34,399 --> 00:12:38,399
of the uh associated values and these

376
00:12:37,040 --> 00:12:41,360
are going to get sent along

377
00:12:38,399 --> 00:12:42,800
in the shuffle theoprf evaluation in the

378
00:12:41,360 --> 00:12:44,240
second part

379
00:12:42,800 --> 00:12:46,399
and this automotive encryption is going

380
00:12:44,240 --> 00:12:47,839
to be a split key encryption so that

381
00:12:46,399 --> 00:12:51,360
the key is shared between the two

382
00:12:47,839 --> 00:12:54,000
different parties the decryption key

383
00:12:51,360 --> 00:12:56,160
and we're going to kind of uh provably

384
00:12:54,000 --> 00:12:57,920
shuffle and re-randomize the encryptions

385
00:12:56,160 --> 00:12:59,760
of these associated values

386
00:12:57,920 --> 00:13:01,040
with the same permutation that's used to

387
00:12:59,760 --> 00:13:05,279
shuffle the opr

388
00:13:01,040 --> 00:13:05,279
evaluations of the y values

389
00:13:05,760 --> 00:13:09,120
and then in the output of this so the

390
00:13:07,279 --> 00:13:11,360
output of this protocol will be the opr

391
00:13:09,120 --> 00:13:16,800
values and also the associated

392
00:13:11,360 --> 00:13:19,519
uh encryptions of the

393
00:13:16,800 --> 00:13:20,000
w values right shuffle then re-randomize

394
00:13:19,519 --> 00:13:22,959
for the same

395
00:13:20,000 --> 00:13:24,560
shuffle and then once you have this both

396
00:13:22,959 --> 00:13:26,000
parties can again look at the transcript

397
00:13:24,560 --> 00:13:28,479
and see which of the

398
00:13:26,000 --> 00:13:30,320
opr values are in common across the two

399
00:13:28,480 --> 00:13:32,480
and then add together the associated

400
00:13:30,320 --> 00:13:33,120
homomorphic encryption values to get an

401
00:13:32,480 --> 00:13:37,279
encryption

402
00:13:33,120 --> 00:13:39,519
of the intersection sum

403
00:13:37,279 --> 00:13:41,040
uh and then once you have this

404
00:13:39,519 --> 00:13:42,720
encryption of the intersection some the

405
00:13:41,040 --> 00:13:44,480
parties can interactively and proof of

406
00:13:42,720 --> 00:13:46,560
the decrypt this value to get the actual

407
00:13:44,480 --> 00:13:49,040
intersection sum

408
00:13:46,560 --> 00:13:50,880
and we note that this fact that uh both

409
00:13:49,040 --> 00:13:51,279
parties can look at the transcripts and

410
00:13:50,880 --> 00:13:54,160
see

411
00:13:51,279 --> 00:13:56,320
exactly which opr values are in common

412
00:13:54,160 --> 00:13:57,360
and then deterministically add together

413
00:13:56,320 --> 00:13:59,519
the homomorphic

414
00:13:57,360 --> 00:14:01,199
associated homomorphic encryption this

415
00:13:59,519 --> 00:14:03,120
avoids that major headache we talked

416
00:14:01,199 --> 00:14:04,560
about which is how is one party supposed

417
00:14:03,120 --> 00:14:06,880
to prove to the other party

418
00:14:04,560 --> 00:14:08,800
that this homomorphic encryption of the

419
00:14:06,880 --> 00:14:10,800
sum was created correctly

420
00:14:08,800 --> 00:14:12,240
like here the point is that both parties

421
00:14:10,800 --> 00:14:14,079
can do this independently

422
00:14:12,240 --> 00:14:15,839
and deterministically create the

423
00:14:14,079 --> 00:14:17,359
ciphertext that has the homomorphic

424
00:14:15,839 --> 00:14:17,760
encryption of the intersection some so

425
00:14:17,360 --> 00:14:19,440
no

426
00:14:17,760 --> 00:14:20,880
additional proof is needed like both

427
00:14:19,440 --> 00:14:23,519
parties know what the ciphertext is

428
00:14:20,880 --> 00:14:26,320
supposed to be

429
00:14:23,519 --> 00:14:28,079
okay so this is our recipe and then now

430
00:14:26,320 --> 00:14:29,920
we can talk about what exactly

431
00:14:28,079 --> 00:14:31,359
is the oprf we're going to use and then

432
00:14:29,920 --> 00:14:32,639
we'll talk about exactly how we

433
00:14:31,360 --> 00:14:33,680
implemented each of the steps of the

434
00:14:32,639 --> 00:14:35,760
protocol

435
00:14:33,680 --> 00:14:38,399
so the prf we're going to use is a

436
00:14:35,760 --> 00:14:40,880
variant of the so-called dodis jambolsky

437
00:14:38,399 --> 00:14:42,639
pierre which is uh also sometimes called

438
00:14:40,880 --> 00:14:44,399
bone boy npr

439
00:14:42,639 --> 00:14:46,320
and the variance we're going to use is

440
00:14:44,399 --> 00:14:49,600
one that allows split keys so

441
00:14:46,320 --> 00:14:51,600
um the normal prf just has one key k

442
00:14:49,600 --> 00:14:53,279
and the evaluation is g to the one over

443
00:14:51,600 --> 00:14:56,480
k plus x but for us we're going to have

444
00:14:53,279 --> 00:14:58,480
additive shares in the key k1 and k2

445
00:14:56,480 --> 00:14:59,519
and the security of this prf can be

446
00:14:58,480 --> 00:15:02,079
based on the

447
00:14:59,519 --> 00:15:04,880
q inverse cdh assumption in the group

448
00:15:02,079 --> 00:15:04,880
generated by g

449
00:15:05,360 --> 00:15:08,720
uh and it also turns out there's

450
00:15:06,880 --> 00:15:11,519
interactive protocols to

451
00:15:08,720 --> 00:15:12,880
compute this prf not in the split key

452
00:15:11,519 --> 00:15:14,560
setting but in the single key setting

453
00:15:12,880 --> 00:15:15,360
but we're going to do a variance of

454
00:15:14,560 --> 00:15:18,479
those

455
00:15:15,360 --> 00:15:21,519
and those protocols uh

456
00:15:18,480 --> 00:15:23,440
leverage the command issue crypto system

457
00:15:21,519 --> 00:15:25,120
so this commander should cryptosystem is

458
00:15:23,440 --> 00:15:26,160
an additively homomorphic encryption

459
00:15:25,120 --> 00:15:28,959
scheme and then

460
00:15:26,160 --> 00:15:30,800
it supports proofs of uh that you

461
00:15:28,959 --> 00:15:33,680
encrypted a value and proves that your

462
00:15:30,800 --> 00:15:33,680
decrypted value

463
00:15:34,880 --> 00:15:38,079
and so now we can get into exactly how

464
00:15:37,040 --> 00:15:41,439
we're going to implement

465
00:15:38,079 --> 00:15:42,959
our distributed opera so uh

466
00:15:41,440 --> 00:15:44,720
let's just assume the first party has

467
00:15:42,959 --> 00:15:46,479
the inputs right now and now so both

468
00:15:44,720 --> 00:15:49,120
parties are going to generate key shares

469
00:15:46,480 --> 00:15:50,160
for this distributed opera

470
00:15:49,120 --> 00:15:52,320
and they're going to agree on a

471
00:15:50,160 --> 00:15:55,759
generator g for

472
00:15:52,320 --> 00:15:56,399
a group capital g uh and that the order

473
00:15:55,759 --> 00:15:59,680
of that g

474
00:15:56,399 --> 00:16:01,440
be cubed this q is different from the q

475
00:15:59,680 --> 00:16:03,279
and the q inverse ddh assumption

476
00:16:01,440 --> 00:16:06,320
but here let's just think about q as

477
00:16:03,279 --> 00:16:08,320
being the order of this group

478
00:16:06,320 --> 00:16:10,079
and so the part the second party the

479
00:16:08,320 --> 00:16:13,120
non-input providing party

480
00:16:10,079 --> 00:16:16,239
is going to sound different up its

481
00:16:13,120 --> 00:16:18,720
keyshare k2 and the first party is going

482
00:16:16,240 --> 00:16:21,759
to use the homomorphism of the

483
00:16:18,720 --> 00:16:23,759
super encryption to uh send an

484
00:16:21,759 --> 00:16:27,199
encryption of k1 plus k2

485
00:16:23,759 --> 00:16:29,120
plus xi for each of its inputs and x i

486
00:16:27,199 --> 00:16:31,120
but actually the sonotone is not secure

487
00:16:29,120 --> 00:16:31,759
so actually the first body is going to

488
00:16:31,120 --> 00:16:35,360
mask it

489
00:16:31,759 --> 00:16:37,440
using random masks ai and biq so ai is

490
00:16:35,360 --> 00:16:38,720
going to mastic here up to k2 plus x and

491
00:16:37,440 --> 00:16:40,399
biq

492
00:16:38,720 --> 00:16:42,000
this thing is there because basically

493
00:16:40,399 --> 00:16:44,240
the message space in the command is

494
00:16:42,000 --> 00:16:47,600
encryption scheme is different from the

495
00:16:44,240 --> 00:16:49,680
exponent space of g and so this biq is

496
00:16:47,600 --> 00:16:52,000
kind of simulating a mod q

497
00:16:49,680 --> 00:16:54,000
operation within the plane type space of

498
00:16:52,000 --> 00:16:57,199
the commandership encryption

499
00:16:54,000 --> 00:17:00,000
that's my stuff and so

500
00:16:57,199 --> 00:17:02,240
the party who receives the command strip

501
00:17:00,000 --> 00:17:05,280
encryption is now going to decrypt it

502
00:17:02,240 --> 00:17:08,000
and then invert it and exponentiate g

503
00:17:05,280 --> 00:17:10,720
to the one over a all this stuff

504
00:17:08,000 --> 00:17:14,160
whatever it decrypted

505
00:17:10,720 --> 00:17:17,120
and because the order of uh the of g

506
00:17:14,160 --> 00:17:18,000
is uh q the bi q part disappears so you

507
00:17:17,119 --> 00:17:21,438
get one over

508
00:17:18,000 --> 00:17:24,400
a i a k 1 plus k 2 x i

509
00:17:21,439 --> 00:17:25,679
and then the receiving party can just

510
00:17:24,400 --> 00:17:28,880
remove

511
00:17:25,679 --> 00:17:30,640
the power ai by exponenti

512
00:17:28,880 --> 00:17:33,120
but actually we do a small optimization

513
00:17:30,640 --> 00:17:33,919
to make this a little bit more efficient

514
00:17:33,120 --> 00:17:35,439
which is that

515
00:17:33,919 --> 00:17:37,440
the first part is actually going to send

516
00:17:35,440 --> 00:17:39,760
along uh g to the ai

517
00:17:37,440 --> 00:17:41,840
along with this command super encryption

518
00:17:39,760 --> 00:17:42,960
and the second part is going to use this

519
00:17:41,840 --> 00:17:45,039
cheater the ai

520
00:17:42,960 --> 00:17:47,760
to exponentiate with the inverse so

521
00:17:45,039 --> 00:17:49,600
instead of using g it is greater than af

522
00:17:47,760 --> 00:17:51,360
and then the ai is automatically going

523
00:17:49,600 --> 00:17:52,240
to cancel out and so the result is

524
00:17:51,360 --> 00:17:55,840
actually going to be

525
00:17:52,240 --> 00:17:59,600
already f uh evaluated the

526
00:17:55,840 --> 00:18:01,280
distributor will be evaluated on x n

527
00:17:59,600 --> 00:18:02,719
and so this is exactly our distributor

528
00:18:01,280 --> 00:18:06,080
prf protocol and it's

529
00:18:02,720 --> 00:18:06,080
like both parties get the output

530
00:18:06,400 --> 00:18:11,280
and uh in addition we have to have zk

531
00:18:09,600 --> 00:18:11,760
proofs for each thing and it turns out

532
00:18:11,280 --> 00:18:13,760
that

533
00:18:11,760 --> 00:18:15,760
committed super encryption and all these

534
00:18:13,760 --> 00:18:18,559
other things all these other operations

535
00:18:15,760 --> 00:18:22,960
are amenable to different kinds of ck

536
00:18:18,559 --> 00:18:22,960
proofs based on sigma's protocol style

537
00:18:23,919 --> 00:18:27,360
the special piece that we need to know

538
00:18:25,280 --> 00:18:29,360
here is actually we need to do

539
00:18:27,360 --> 00:18:31,199
all our proofs need to have our range

540
00:18:29,360 --> 00:18:34,399
proof component to it

541
00:18:31,200 --> 00:18:35,280
um because the orders of the groups that

542
00:18:34,400 --> 00:18:38,320
we care about

543
00:18:35,280 --> 00:18:38,879
are different sizes so in order to prove

544
00:18:38,320 --> 00:18:40,639
that we

545
00:18:38,880 --> 00:18:42,160
you know if we wrapped around in one of

546
00:18:40,640 --> 00:18:42,880
in both the groups then you could have a

547
00:18:42,160 --> 00:18:44,240
problem

548
00:18:42,880 --> 00:18:46,559
so you need to do a range group to show

549
00:18:44,240 --> 00:18:49,200
that you didn't wrap around in at least

550
00:18:46,559 --> 00:18:49,200
one of them

551
00:18:50,000 --> 00:18:53,360
okay uh

552
00:18:54,240 --> 00:18:59,760
and so this is our thing for uh dopr but

553
00:18:57,440 --> 00:19:01,200
now what if you want to do shuffle gopr

554
00:18:59,760 --> 00:19:03,120
well what we're going to do is instead

555
00:19:01,200 --> 00:19:04,240
of send and instead of the second party

556
00:19:03,120 --> 00:19:07,280
sending back

557
00:19:04,240 --> 00:19:08,799
just the you know the opr evaluations

558
00:19:07,280 --> 00:19:10,799
it's insecure to send back

559
00:19:08,799 --> 00:19:13,520
alcohol encryptions of the opr

560
00:19:10,799 --> 00:19:13,520
evaluations

561
00:19:13,840 --> 00:19:17,280
and then it's going to send a shuffle

562
00:19:15,679 --> 00:19:19,440
and decryption of the outcome

563
00:19:17,280 --> 00:19:20,879
those algomar encryptions and this is

564
00:19:19,440 --> 00:19:21,760
how we're going to implement our

565
00:19:20,880 --> 00:19:23,760
shockplane

566
00:19:21,760 --> 00:19:24,799
so if the changes are as they're sent

567
00:19:23,760 --> 00:19:26,160
into pair values

568
00:19:24,799 --> 00:19:27,918
and command encryptions and now we have

569
00:19:26,160 --> 00:19:30,000
to change our proofs so that

570
00:19:27,919 --> 00:19:31,679
we have to prove instead of saying that

571
00:19:30,000 --> 00:19:33,760
we decrypted this

572
00:19:31,679 --> 00:19:35,200
the second part decrypted the value and

573
00:19:33,760 --> 00:19:36,720
exponentiated the inverse it's going to

574
00:19:35,200 --> 00:19:40,160
be decrypt

575
00:19:36,720 --> 00:19:41,919
uh invert exponentiate and re-encrypted

576
00:19:40,160 --> 00:19:43,360
of them all

577
00:19:41,919 --> 00:19:45,200
uh so it's a slightly more complicated

578
00:19:43,360 --> 00:19:47,280
proof but also very doable

579
00:19:45,200 --> 00:19:48,799
and then also we add a second proof

580
00:19:47,280 --> 00:19:50,559
which is going to be a shuffling

581
00:19:48,799 --> 00:19:52,320
decryption of these album all values and

582
00:19:50,559 --> 00:19:54,480
for this we're going to use a proof

583
00:19:52,320 --> 00:19:56,000
from a bearing growth from europe in

584
00:19:54,480 --> 00:19:57,679
2012

585
00:19:56,000 --> 00:19:59,360
there's many different ones we just used

586
00:19:57,679 --> 00:20:02,960
this one because

587
00:19:59,360 --> 00:20:02,959
it seemed the most important one

588
00:20:03,679 --> 00:20:07,360
and now we have a protocol with those

589
00:20:05,679 --> 00:20:09,600
components we have a protocol for

590
00:20:07,360 --> 00:20:11,360
malicious psi cardinality and now if you

591
00:20:09,600 --> 00:20:13,199
want to extend to psi

592
00:20:11,360 --> 00:20:14,639
sum we're going to do what we talked

593
00:20:13,200 --> 00:20:16,480
about before which is that we're going

594
00:20:14,640 --> 00:20:17,760
to get the split key homomorphic

595
00:20:16,480 --> 00:20:20,000
encryption scheme

596
00:20:17,760 --> 00:20:21,120
and specifically we're going to use

597
00:20:20,000 --> 00:20:23,840
split key

598
00:20:21,120 --> 00:20:26,639
exponential algomal for our additive

599
00:20:23,840 --> 00:20:28,399
homomorphic encryption scheme

600
00:20:26,640 --> 00:20:30,320
and it turns out if we use exponential

601
00:20:28,400 --> 00:20:32,480
alcohol as a homo free encryption scheme

602
00:20:30,320 --> 00:20:34,559
there's a problem that the

603
00:20:32,480 --> 00:20:35,679
values need to be bounded into something

604
00:20:34,559 --> 00:20:38,000
that can be

605
00:20:35,679 --> 00:20:39,280
decrypted by a discrete log but that

606
00:20:38,000 --> 00:20:40,720
turns out to be okay for

607
00:20:39,280 --> 00:20:43,600
most of the applications that we care

608
00:20:40,720 --> 00:20:46,799
about uh but if we use this

609
00:20:43,600 --> 00:20:48,080
exponential lml uh

610
00:20:46,799 --> 00:20:49,918
it turns out that this is very

611
00:20:48,080 --> 00:20:50,879
compatible with the shuffle proof that

612
00:20:49,919 --> 00:20:54,440
we use for the

613
00:20:50,880 --> 00:20:57,679
do prf section and the shuffle and

614
00:20:54,440 --> 00:20:58,080
re-randomization can be uh added on to

615
00:20:57,679 --> 00:21:00,480
the

616
00:20:58,080 --> 00:21:01,600
shuffle and decrypt proof from that we

617
00:21:00,480 --> 00:21:04,799
already had

618
00:21:01,600 --> 00:21:06,320
with a small additional cost and so

619
00:21:04,799 --> 00:21:08,080
that's exactly what we do

620
00:21:06,320 --> 00:21:10,639
and as you mentioned before both parties

621
00:21:08,080 --> 00:21:12,480
can now figure out what's the

622
00:21:10,640 --> 00:21:14,720
encryption of the intersection sum and

623
00:21:12,480 --> 00:21:17,360
then we do an interactive decryption

624
00:21:14,720 --> 00:21:20,159
uh this is also straightforward for

625
00:21:17,360 --> 00:21:22,000
exponential demo

626
00:21:20,159 --> 00:21:23,360
and so this is essentially a protocol

627
00:21:22,000 --> 00:21:26,559
and there's a few uh

628
00:21:23,360 --> 00:21:29,280
additional tricky parts here

629
00:21:26,559 --> 00:21:30,000
so one first tricky part is that unlike

630
00:21:29,280 --> 00:21:32,879
some of the previous

631
00:21:30,000 --> 00:21:33,520
works we don't assume a trusted modulus

632
00:21:32,880 --> 00:21:36,320
for

633
00:21:33,520 --> 00:21:37,200
uh commitments and command issue

634
00:21:36,320 --> 00:21:40,960
encryption that

635
00:21:37,200 --> 00:21:42,080
uh that was assumed by some of the

636
00:21:40,960 --> 00:21:43,760
previous works and so

637
00:21:42,080 --> 00:21:45,120
each party is going to independent page

638
00:21:43,760 --> 00:21:48,720
100 it's

639
00:21:45,120 --> 00:21:49,760
a modular for a command issue encryption

640
00:21:48,720 --> 00:21:51,600
and then they're going to have to prove

641
00:21:49,760 --> 00:21:52,799
to each other that these parties are

642
00:21:51,600 --> 00:21:54,639
okay

643
00:21:52,799 --> 00:21:56,639
and then a second big issue is that many

644
00:21:54,640 --> 00:21:59,520
of these proofs are crossing

645
00:21:56,640 --> 00:22:01,520
different groups and so a lot of care

646
00:21:59,520 --> 00:22:04,400
needs to be taken like this is a massive

647
00:22:01,520 --> 00:22:06,158
place for pitfalls and soundness errors

648
00:22:04,400 --> 00:22:08,480
with uh

649
00:22:06,159 --> 00:22:10,480
with different ck proofs and we have to

650
00:22:08,480 --> 00:22:11,760
really carefully use the strong rca

651
00:22:10,480 --> 00:22:13,360
assumption and use these bridge

652
00:22:11,760 --> 00:22:14,158
commitments in order to make sure that

653
00:22:13,360 --> 00:22:17,360
everything looks

654
00:22:14,159 --> 00:22:18,559
okay and then another important piece is

655
00:22:17,360 --> 00:22:22,080
that we had to

656
00:22:18,559 --> 00:22:23,600
uh design a custom uh decrypt uh

657
00:22:22,080 --> 00:22:25,360
inward and exponentiate proofs a

658
00:22:23,600 --> 00:22:26,320
decrypted managed to invert and

659
00:22:25,360 --> 00:22:29,439
expertise

660
00:22:26,320 --> 00:22:32,158
and encrypt with elgamal and a standard

661
00:22:29,440 --> 00:22:34,640
sigma protocol doesn't work in this case

662
00:22:32,159 --> 00:22:36,320
and uh finally it turns out the q

663
00:22:34,640 --> 00:22:39,679
inverse ddh assumption

664
00:22:36,320 --> 00:22:42,000
which uh gives the security of the opr

665
00:22:39,679 --> 00:22:44,320
assumes a polynomial domain so that

666
00:22:42,000 --> 00:22:46,640
would restrict the x and y values to be

667
00:22:44,320 --> 00:22:48,080
from a polynomial size domain

668
00:22:46,640 --> 00:22:50,799
but return it turns out we can get

669
00:22:48,080 --> 00:22:54,000
around this by

670
00:22:50,799 --> 00:22:56,000
if we commit the inputs uh beforehand

671
00:22:54,000 --> 00:22:57,039
if each party commits x and commits to y

672
00:22:56,000 --> 00:22:58,960
beforehand

673
00:22:57,039 --> 00:23:00,559
uh before choosing the keys for the opr

674
00:22:58,960 --> 00:23:02,480
then it turns out that it can be an

675
00:23:00,559 --> 00:23:02,879
exponential domain as long as the number

676
00:23:02,480 --> 00:23:05,919
of

677
00:23:02,880 --> 00:23:09,840
uh as long as the input sizes are upon

678
00:23:05,919 --> 00:23:11,440
you know like the number of inputs

679
00:23:09,840 --> 00:23:12,959
okay and then furthermore we have a

680
00:23:11,440 --> 00:23:13,840
whole bunch of batching techniques that

681
00:23:12,960 --> 00:23:15,520
you described

682
00:23:13,840 --> 00:23:16,879
in the paper and these batching

683
00:23:15,520 --> 00:23:18,960
techniques are crucial to getting the

684
00:23:16,880 --> 00:23:21,280
communication costs to be very low

685
00:23:18,960 --> 00:23:23,679
uh for the ck proofs and also for the

686
00:23:21,280 --> 00:23:25,600
other components so one is that we use a

687
00:23:23,679 --> 00:23:27,039
heavily bashed version of commander

688
00:23:25,600 --> 00:23:30,240
shoot encryption

689
00:23:27,039 --> 00:23:31,760
uh so command shoot encryption is a big

690
00:23:30,240 --> 00:23:33,760
chunk of the communication cost of the

691
00:23:31,760 --> 00:23:35,200
protocol and it actually has a forex

692
00:23:33,760 --> 00:23:37,120
communication overhead between the

693
00:23:35,200 --> 00:23:39,760
plaintext and the ciphertext

694
00:23:37,120 --> 00:23:41,360
and so the batching that we do here is a

695
00:23:39,760 --> 00:23:42,000
combination of the batching techniques

696
00:23:41,360 --> 00:23:43,760
from

697
00:23:42,000 --> 00:23:45,360
elgamal encryption and paella encryption

698
00:23:43,760 --> 00:23:48,158
so come into shoe can kind of be thought

699
00:23:45,360 --> 00:23:50,399
of as a hybrid between algamal in paella

700
00:23:48,159 --> 00:23:51,600
and so one of the optimizations is to

701
00:23:50,400 --> 00:23:53,600
reuse the first

702
00:23:51,600 --> 00:23:54,959
component across multiple ciphertexts

703
00:23:53,600 --> 00:23:58,240
like a common

704
00:23:54,960 --> 00:24:00,159
uh optimization for alcohol encryption

705
00:23:58,240 --> 00:24:01,760
a second one is to use uh damn guard

706
00:24:00,159 --> 00:24:03,679
zero style optimization as it's

707
00:24:01,760 --> 00:24:06,158
available in payee encryption

708
00:24:03,679 --> 00:24:06,720
which is to do everything mod n to the s

709
00:24:06,159 --> 00:24:10,320
plus one

710
00:24:06,720 --> 00:24:11,919
instead of just n square and the tricky

711
00:24:10,320 --> 00:24:14,000
part here is that we have to

712
00:24:11,919 --> 00:24:15,360
this ends up blowing up the plain text

713
00:24:14,000 --> 00:24:16,000
space and so we have to modify the

714
00:24:15,360 --> 00:24:19,199
protocol

715
00:24:16,000 --> 00:24:20,080
to batch multiple opr evaluations into a

716
00:24:19,200 --> 00:24:21,679
single

717
00:24:20,080 --> 00:24:23,678
membership ciphertext and to show how to

718
00:24:21,679 --> 00:24:25,520
do this and this has a big

719
00:24:23,679 --> 00:24:29,360
impact on the communication overhead

720
00:24:25,520 --> 00:24:30,879
factor uh for climate change

721
00:24:29,360 --> 00:24:32,959
and the second big kind of batching that

722
00:24:30,880 --> 00:24:36,080
we do is bashing the sigma protocol

723
00:24:32,960 --> 00:24:39,679
so there's two

724
00:24:36,080 --> 00:24:41,840
points to note here so uh one is that

725
00:24:39,679 --> 00:24:43,520
since we have to all our proofs need a

726
00:24:41,840 --> 00:24:46,639
range component

727
00:24:43,520 --> 00:24:47,520
uh we actually modified the standard way

728
00:24:46,640 --> 00:24:50,720
of patching

729
00:24:47,520 --> 00:24:53,039
uh sigma protocols so that uh we

730
00:24:50,720 --> 00:24:54,320
more carefully control the slack induced

731
00:24:53,039 --> 00:24:57,600
by uh

732
00:24:54,320 --> 00:25:00,799
the batching uh

733
00:24:57,600 --> 00:25:02,240
the the slack and the range

734
00:25:00,799 --> 00:25:03,679
induced by the patching and this has a

735
00:25:02,240 --> 00:25:05,600
big impact on our communication

736
00:25:03,679 --> 00:25:07,360
overheads

737
00:25:05,600 --> 00:25:09,199
and the second is we give a new batch

738
00:25:07,360 --> 00:25:10,559
proof for commandership decryption and

739
00:25:09,200 --> 00:25:13,679
technically for the decrypt

740
00:25:10,559 --> 00:25:15,678
invert exponentiate proof and overall

741
00:25:13,679 --> 00:25:18,240
this makes it so that our proofs are

742
00:25:15,679 --> 00:25:18,799
asymptotically sublinear in the input

743
00:25:18,240 --> 00:25:20,480
sizes

744
00:25:18,799 --> 00:25:22,400
and the proofs actually become a very

745
00:25:20,480 --> 00:25:25,600
small part of the overall communication

746
00:25:22,400 --> 00:25:27,279
cost in a concrete measurement

747
00:25:25,600 --> 00:25:29,199
and so finally i'd like to talk about

748
00:25:27,279 --> 00:25:30,960
some of our measurements for our

749
00:25:29,200 --> 00:25:32,080
protocols and comparisons with other

750
00:25:30,960 --> 00:25:35,120
works

751
00:25:32,080 --> 00:25:37,439
so uh our first comparison is going to

752
00:25:35,120 --> 00:25:39,520
be against the semi honest ddh protocol

753
00:25:37,440 --> 00:25:41,279
when we try to aggressively minimize the

754
00:25:39,520 --> 00:25:42,240
communication costs and it turns out if

755
00:25:41,279 --> 00:25:44,400
we use the

756
00:25:42,240 --> 00:25:46,640
very aggressive choice of batching

757
00:25:44,400 --> 00:25:49,120
parameters then we can

758
00:25:46,640 --> 00:25:51,200
greatly reduce the communication costs

759
00:25:49,120 --> 00:25:53,439
uh to something very competitive which

760
00:25:51,200 --> 00:25:57,600
between four and five x expansion over

761
00:25:53,440 --> 00:25:59,679
the semi honest tdh-based protocol

762
00:25:57,600 --> 00:26:01,918
uh but it turns out that this has a

763
00:25:59,679 --> 00:26:02,880
large impact on the computation cost so

764
00:26:01,919 --> 00:26:06,320
if we try to

765
00:26:02,880 --> 00:26:08,559
instead uh minimize monetary costs we

766
00:26:06,320 --> 00:26:10,000
end up with parameters that give like

767
00:26:08,559 --> 00:26:13,120
less of a

768
00:26:10,000 --> 00:26:13,919
communication uh give more communication

769
00:26:13,120 --> 00:26:16,320
costs but

770
00:26:13,919 --> 00:26:17,919
much lower computation and so here we

771
00:26:16,320 --> 00:26:20,320
have like a 7x increase

772
00:26:17,919 --> 00:26:22,480
in communication and overall we have

773
00:26:20,320 --> 00:26:27,120
like a 24 to 25 increase

774
00:26:22,480 --> 00:26:29,440
in uh monitoring cost of uh

775
00:26:27,120 --> 00:26:30,559
executing the protocol and this monitor

776
00:26:29,440 --> 00:26:33,360
cost uses these

777
00:26:30,559 --> 00:26:35,120
uh costs for resources from uh google

778
00:26:33,360 --> 00:26:39,840
cloud platform but for

779
00:26:35,120 --> 00:26:39,840
aws and hunter it's pretty similar

780
00:26:41,039 --> 00:26:44,480
and in terms of comparing to other

781
00:26:42,480 --> 00:26:45,360
protocols that uh try to do malicious

782
00:26:44,480 --> 00:26:48,799
psi

783
00:26:45,360 --> 00:26:50,240
uh we note that uh the sort compare

784
00:26:48,799 --> 00:26:52,320
shuffle is the most prominent one that

785
00:26:50,240 --> 00:26:53,840
gives two-sided output with computing

786
00:26:52,320 --> 00:26:57,120
over the intersection

787
00:26:53,840 --> 00:27:00,158
and in this case we have a monetary cost

788
00:26:57,120 --> 00:27:02,879
which is like 10 to 50 times better

789
00:27:00,159 --> 00:27:04,400
and uh communication cost that's a lot

790
00:27:02,880 --> 00:27:06,880
lot better

791
00:27:04,400 --> 00:27:07,440
than this work and uh actually you can

792
00:27:06,880 --> 00:27:09,440
see that

793
00:27:07,440 --> 00:27:10,880
even relative to the very efficient

794
00:27:09,440 --> 00:27:13,120
one-sided psi

795
00:27:10,880 --> 00:27:13,919
uh protocols the malicious security psn

796
00:27:13,120 --> 00:27:16,719
protocols

797
00:27:13,919 --> 00:27:17,919
we only have a moderate uh monetary cost

798
00:27:16,720 --> 00:27:20,159
increase

799
00:27:17,919 --> 00:27:23,679
uh even though we give two-sided output

800
00:27:20,159 --> 00:27:23,679
and compute over the intersection

801
00:27:23,840 --> 00:27:28,000
uh we know that this comparison doesn't

802
00:27:25,840 --> 00:27:29,520
include a very recent work from europe

803
00:27:28,000 --> 00:27:32,399
2020 which actually

804
00:27:29,520 --> 00:27:35,279
has a much better monetary cost than the

805
00:27:32,399 --> 00:27:37,918
previous works uh

806
00:27:35,279 --> 00:27:38,559
but we note that this uh new work also

807
00:27:37,919 --> 00:27:40,880
only has

808
00:27:38,559 --> 00:27:42,480
one-sided psi and so some significant

809
00:27:40,880 --> 00:27:43,679
extra cost is needed in order to make it

810
00:27:42,480 --> 00:27:46,840
to set a psi

811
00:27:43,679 --> 00:27:48,559
and to support computing over the

812
00:27:46,840 --> 00:27:50,720
intersection

813
00:27:48,559 --> 00:27:59,918
okay and with that i'd like to thank you

814
00:27:50,720 --> 00:27:59,919
and thank you

