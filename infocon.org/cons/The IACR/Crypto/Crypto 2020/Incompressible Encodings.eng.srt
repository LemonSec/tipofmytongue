1
00:00:01,839 --> 00:00:04,960
hi i'm daniel wicks

2
00:00:03,199 --> 00:00:06,720
and i'm going to tell you about

3
00:00:04,960 --> 00:00:09,920
incompressible encodings

4
00:00:06,720 --> 00:00:11,440
uh this is joint work with talmuran

5
00:00:09,920 --> 00:00:13,440
let me start with a question the

6
00:00:11,440 --> 00:00:14,920
question is how much space does it take

7
00:00:13,440 --> 00:00:17,520
to store

8
00:00:14,920 --> 00:00:19,359
wikipedia so it turns out that you can

9
00:00:17,520 --> 00:00:21,600
actually download the entire wikipedia

10
00:00:19,359 --> 00:00:23,439
contents for offline use

11
00:00:21,600 --> 00:00:24,880
and depending on which version you get

12
00:00:23,439 --> 00:00:27,198
it can be something like

13
00:00:24,880 --> 00:00:28,080
50 gigabytes i think this is for the

14
00:00:27,199 --> 00:00:31,359
text only

15
00:00:28,080 --> 00:00:33,599
english version but there's an intern

16
00:00:31,359 --> 00:00:37,000
alternate way of storing the wikipedia

17
00:00:33,600 --> 00:00:38,399
data which is just to store the link

18
00:00:37,000 --> 00:00:40,719
www.wikipedia.org

19
00:00:38,399 --> 00:00:41,680
that only takes about 17 bytes and with

20
00:00:40,719 --> 00:00:43,920
this link you can

21
00:00:41,680 --> 00:00:44,960
access the wikipedia data whenever you

22
00:00:43,920 --> 00:00:46,480
want

23
00:00:44,960 --> 00:00:48,640
and the point i want to make here is

24
00:00:46,480 --> 00:00:50,078
that when it comes to some public data

25
00:00:48,640 --> 00:00:52,960
like wikipedia

26
00:00:50,079 --> 00:00:54,960
even though the data can be very large

27
00:00:52,960 --> 00:00:57,199
just by storing the link

28
00:00:54,960 --> 00:00:58,320
you can essentially have this data for

29
00:00:57,199 --> 00:01:01,358
free without

30
00:00:58,320 --> 00:01:01,359
without storing it

31
00:01:01,440 --> 00:01:05,759
and the question for this dog is can we

32
00:01:04,000 --> 00:01:07,840
take such public data let's say the

33
00:01:05,760 --> 00:01:10,240
entire wikipedia contents

34
00:01:07,840 --> 00:01:10,880
and make it incompressible in other

35
00:01:10,240 --> 00:01:13,520
words

36
00:01:10,880 --> 00:01:15,199
can we come up with a representation of

37
00:01:13,520 --> 00:01:17,520
the wikipedia data

38
00:01:15,200 --> 00:01:19,439
that would uh require let's say 50

39
00:01:17,520 --> 00:01:20,640
gigabytes of storage to store this

40
00:01:19,439 --> 00:01:22,720
representation

41
00:01:20,640 --> 00:01:24,560
even for people that have the link to

42
00:01:22,720 --> 00:01:26,479
the underlying wikipedia data

43
00:01:24,560 --> 00:01:28,479
and have access to that for free you

44
00:01:26,479 --> 00:01:30,400
don't need to start

45
00:01:28,479 --> 00:01:31,920
so let me tell you what i actually mean

46
00:01:30,400 --> 00:01:34,240
by this let me make this precise

47
00:01:31,920 --> 00:01:37,200
and let me get straight to defining this

48
00:01:34,240 --> 00:01:39,119
notion of incompressible encodings

49
00:01:37,200 --> 00:01:41,280
so in compressive encoding consists of

50
00:01:39,119 --> 00:01:43,520
two algorithm an encoding algorithm

51
00:01:41,280 --> 00:01:44,720
and a decoding algorithm and the

52
00:01:43,520 --> 00:01:46,960
encoding algorithm

53
00:01:44,720 --> 00:01:47,759
takes some underlying data m let's say

54
00:01:46,960 --> 00:01:51,119
the

55
00:01:47,759 --> 00:01:52,479
underlying wikipedia data and encodes it

56
00:01:51,119 --> 00:01:55,280
in a probabilistic

57
00:01:52,479 --> 00:01:56,079
a randomized way to derive some code

58
00:01:55,280 --> 00:01:58,880
word c

59
00:01:56,079 --> 00:02:00,399
and here i made the code with uh the

60
00:01:58,880 --> 00:02:03,520
image of the codeword c

61
00:02:00,399 --> 00:02:05,840
uh have some noise or look noisy to uh

62
00:02:03,520 --> 00:02:08,399
to indicate that it that it somehow uses

63
00:02:05,840 --> 00:02:10,720
randomness to drive this codeword

64
00:02:08,399 --> 00:02:12,959
but this covert c is essentially a good

65
00:02:10,720 --> 00:02:14,160
representation of the wikipedia data

66
00:02:12,959 --> 00:02:16,720
anybody can come

67
00:02:14,160 --> 00:02:18,160
and decode the code word and recover the

68
00:02:16,720 --> 00:02:21,359
original data itself

69
00:02:18,160 --> 00:02:25,359
so storing the codeword is as good as

70
00:02:21,360 --> 00:02:27,360
storing the underlying uh data itself

71
00:02:25,360 --> 00:02:28,959
you can think of it as just an alternate

72
00:02:27,360 --> 00:02:31,599
randomized representation

73
00:02:28,959 --> 00:02:32,800
of the data again i want to emphasize

74
00:02:31,599 --> 00:02:34,399
that the encoding and decoding

75
00:02:32,800 --> 00:02:36,400
procedures are public efficient

76
00:02:34,400 --> 00:02:38,239
procedures anybody can run them

77
00:02:36,400 --> 00:02:39,519
there are no secret keys or public keys

78
00:02:38,239 --> 00:02:42,000
or anything like that

79
00:02:39,519 --> 00:02:43,040
anybody can run these procedures and we

80
00:02:42,000 --> 00:02:44,720
want correctness

81
00:02:43,040 --> 00:02:47,040
so uh correctness is that whatever

82
00:02:44,720 --> 00:02:49,280
message you start with if you encode it

83
00:02:47,040 --> 00:02:51,040
and then decode it you should get back

84
00:02:49,280 --> 00:02:52,080
the original message with probably one

85
00:02:51,040 --> 00:02:54,319
where the probability

86
00:02:52,080 --> 00:02:56,800
is over the randomness of the encoding

87
00:02:54,319 --> 00:02:56,799
procedure

88
00:02:57,360 --> 00:03:01,360
but we want this encoding to be

89
00:02:58,959 --> 00:03:04,080
incompressible and that means that

90
00:03:01,360 --> 00:03:05,040
it should be hard to compress the code

91
00:03:04,080 --> 00:03:07,120
word c

92
00:03:05,040 --> 00:03:08,400
even for an adversary that knows the

93
00:03:07,120 --> 00:03:10,560
underlying data

94
00:03:08,400 --> 00:03:12,480
so we're going to consider an adversary

95
00:03:10,560 --> 00:03:14,159
that uh for whom the data m

96
00:03:12,480 --> 00:03:15,679
is public let's say has access to

97
00:03:14,159 --> 00:03:17,359
wikipedia on the internet

98
00:03:15,680 --> 00:03:20,080
and the goal of the adversary is to take

99
00:03:17,360 --> 00:03:21,120
this code word and compress it down so

100
00:03:20,080 --> 00:03:22,720
remember that

101
00:03:21,120 --> 00:03:24,640
the code word was created using some

102
00:03:22,720 --> 00:03:25,519
randomized process randomizing coding

103
00:03:24,640 --> 00:03:26,798
procedure

104
00:03:25,519 --> 00:03:29,440
so it contains some additional

105
00:03:26,799 --> 00:03:31,280
information beyond the wikipedia data

106
00:03:29,440 --> 00:03:32,799
and the goal here should be that it

107
00:03:31,280 --> 00:03:34,159
should be hard to compress

108
00:03:32,799 --> 00:03:36,400
the covert itself this new

109
00:03:34,159 --> 00:03:38,640
representation of the wikipedia data

110
00:03:36,400 --> 00:03:39,920
even for someone that knows the

111
00:03:38,640 --> 00:03:42,399
underlying data

112
00:03:39,920 --> 00:03:43,599
for free so the average sequences of two

113
00:03:42,400 --> 00:03:45,440
algorithms compress

114
00:03:43,599 --> 00:03:47,760
and decompress the compression algorithm

115
00:03:45,440 --> 00:03:51,200
that takes the culvert c and output some

116
00:03:47,760 --> 00:03:55,200
compressed value w which will be of size

117
00:03:51,200 --> 00:03:57,359
uh beta and the decompression algorithm

118
00:03:55,200 --> 00:03:59,920
takes uh this compressed value w and its

119
00:03:57,360 --> 00:04:01,280
goal is to recover the original covert

120
00:03:59,920 --> 00:04:03,920
scene

121
00:04:01,280 --> 00:04:05,040
and security says that this should be uh

122
00:04:03,920 --> 00:04:06,720
impossible for an

123
00:04:05,040 --> 00:04:09,200
efficient adversary to do so we're going

124
00:04:06,720 --> 00:04:11,200
to say that for any message

125
00:04:09,200 --> 00:04:12,958
that you start with and any adversary

126
00:04:11,200 --> 00:04:14,720
that consists of this compressed and

127
00:04:12,959 --> 00:04:16,478
decompress procedures

128
00:04:14,720 --> 00:04:18,720
and notice i'm quantifying over the

129
00:04:16,478 --> 00:04:20,399
worst case choice of the message

130
00:04:18,720 --> 00:04:21,680
so this indicates that the adversary

131
00:04:20,399 --> 00:04:22,479
could actually have the message

132
00:04:21,680 --> 00:04:24,880
hard-coded

133
00:04:22,479 --> 00:04:26,240
inside it in other words this message is

134
00:04:24,880 --> 00:04:28,240
completely known

135
00:04:26,240 --> 00:04:29,440
and we don't pay any anything for

136
00:04:28,240 --> 00:04:32,560
storing it

137
00:04:29,440 --> 00:04:33,840
okay and we're going to say that uh if

138
00:04:32,560 --> 00:04:36,400
we take the message

139
00:04:33,840 --> 00:04:36,960
uh encoded by this problem coding

140
00:04:36,400 --> 00:04:39,280
algorithm

141
00:04:36,960 --> 00:04:40,320
give it to the compress procedure which

142
00:04:39,280 --> 00:04:42,880
output some

143
00:04:40,320 --> 00:04:44,880
compressed value of beta bits and then

144
00:04:42,880 --> 00:04:46,479
apply the decompression procedure

145
00:04:44,880 --> 00:04:47,600
then the problem was getting back the

146
00:04:46,479 --> 00:04:49,359
original code where it should be

147
00:04:47,600 --> 00:04:50,800
negligible in other words

148
00:04:49,360 --> 00:04:53,040
uh the problem of the adversary

149
00:04:50,800 --> 00:04:54,720
succeeding in compressing this codeword

150
00:04:53,040 --> 00:04:56,320
and radar later being able to use the

151
00:04:54,720 --> 00:05:00,320
compressed value to recover it

152
00:04:56,320 --> 00:05:00,320
should be a most negligible one

153
00:05:00,880 --> 00:05:04,240
okay and the goal is to come up with

154
00:05:03,120 --> 00:05:06,800
such some scheme

155
00:05:04,240 --> 00:05:08,639
where uh the size of the code word alpha

156
00:05:06,800 --> 00:05:10,400
is as close as possible to the original

157
00:05:08,639 --> 00:05:11,360
data size so we don't want to add much

158
00:05:10,400 --> 00:05:13,919
overhead

159
00:05:11,360 --> 00:05:15,199
and it should be incompressible again

160
00:05:13,919 --> 00:05:17,599
almost to the entire

161
00:05:15,199 --> 00:05:19,039
uh codeword or data size so the address

162
00:05:17,600 --> 00:05:22,160
it cannot compress it much

163
00:05:19,039 --> 00:05:25,520
much beyond the the underlying size of

164
00:05:22,160 --> 00:05:28,080
the data

165
00:05:25,520 --> 00:05:29,440
okay so uh let me tell you a little bit

166
00:05:28,080 --> 00:05:30,960
about this problem this problem was

167
00:05:29,440 --> 00:05:32,080
actually introduced in prior work and so

168
00:05:30,960 --> 00:05:35,198
i'll tell you a little about

169
00:05:32,080 --> 00:05:36,320
about the prime work and our results so

170
00:05:35,199 --> 00:05:38,240
there's a prior work of

171
00:05:36,320 --> 00:05:40,400
dam guard ganesh and orlandi and they

172
00:05:38,240 --> 00:05:42,560
defined a variant of this notion of

173
00:05:40,400 --> 00:05:44,479
incompressible encodings

174
00:05:42,560 --> 00:05:46,080
essentially as a building block to build

175
00:05:44,479 --> 00:05:46,800
something called proofs of replicated

176
00:05:46,080 --> 00:05:48,960
storage

177
00:05:46,800 --> 00:05:50,479
and i'm not going to get into what these

178
00:05:48,960 --> 00:05:53,359
are in this talk

179
00:05:50,479 --> 00:05:53,758
but in this context they uh constructed

180
00:05:53,360 --> 00:05:56,000
uh

181
00:05:53,759 --> 00:05:58,000
these incompressible encodings albeit

182
00:05:56,000 --> 00:05:59,440
with some major caveats again i'll

183
00:05:58,000 --> 00:06:01,199
discuss those later but

184
00:05:59,440 --> 00:06:02,800
uh one of them is that the their

185
00:06:01,199 --> 00:06:04,840
construction only worked in

186
00:06:02,800 --> 00:06:06,400
some idealized model like random oracle

187
00:06:04,840 --> 00:06:08,400
model

188
00:06:06,400 --> 00:06:09,919
and so in our work the main point of our

189
00:06:08,400 --> 00:06:11,919
work is actually to take this notion of

190
00:06:09,919 --> 00:06:12,880
incompressible encoding and define it as

191
00:06:11,919 --> 00:06:15,280
a standalone

192
00:06:12,880 --> 00:06:17,199
object that we believe is interesting to

193
00:06:15,280 --> 00:06:20,080
study in its own right

194
00:06:17,199 --> 00:06:22,000
and we give new and improved

195
00:06:20,080 --> 00:06:23,758
constructions of this primitive

196
00:06:22,000 --> 00:06:25,360
in particular we'll show as we'll see

197
00:06:23,759 --> 00:06:28,160
later we get some constructions in the

198
00:06:25,360 --> 00:06:29,520
standard model without a random oracle

199
00:06:28,160 --> 00:06:31,840
we also give some lower bounds and

200
00:06:29,520 --> 00:06:33,120
negative results and we give a new

201
00:06:31,840 --> 00:06:35,840
application

202
00:06:33,120 --> 00:06:37,680
of this object to something called biki

203
00:06:35,840 --> 00:06:39,440
cryptography so a completely different

204
00:06:37,680 --> 00:06:41,840
application than the original one

205
00:06:39,440 --> 00:06:43,759
to prove some replicated storage so let

206
00:06:41,840 --> 00:06:45,520
me actually start by uh giving you this

207
00:06:43,759 --> 00:06:48,080
application i think it will also

208
00:06:45,520 --> 00:06:49,599
um illuminate a little more about what

209
00:06:48,080 --> 00:06:50,560
these what the notion is and why it's

210
00:06:49,599 --> 00:06:52,319
useful

211
00:06:50,560 --> 00:06:54,479
and then we'll talk about the

212
00:06:52,319 --> 00:06:56,319
constructions

213
00:06:54,479 --> 00:06:58,880
so the applications to something called

214
00:06:56,319 --> 00:06:59,440
uh biki cryptography uh there's an area

215
00:06:58,880 --> 00:07:00,719
that's

216
00:06:59,440 --> 00:07:03,039
been studied in the past and it's

217
00:07:00,720 --> 00:07:06,160
motivated by the problem that

218
00:07:03,039 --> 00:07:09,199
computers can often become compromised

219
00:07:06,160 --> 00:07:10,000
by various malware or trojan horses or

220
00:07:09,199 --> 00:07:11,520
etc

221
00:07:10,000 --> 00:07:14,000
and essentially it means that a remote

222
00:07:11,520 --> 00:07:16,560
attacker can get access

223
00:07:14,000 --> 00:07:18,479
to the compromised computer and if you

224
00:07:16,560 --> 00:07:19,919
have any kind of a secret key on this

225
00:07:18,479 --> 00:07:22,880
computer the attacker can just

226
00:07:19,919 --> 00:07:24,240
exfiltrate it can download it and uh get

227
00:07:22,880 --> 00:07:26,880
the secret key

228
00:07:24,240 --> 00:07:29,280
and so that means that whatever the

229
00:07:26,880 --> 00:07:31,039
security of the secretview is providing

230
00:07:29,280 --> 00:07:32,799
is completely lost so the attacker can

231
00:07:31,039 --> 00:07:34,159
then let's say if this was a decryption

232
00:07:32,800 --> 00:07:37,599
key the attacker can

233
00:07:34,160 --> 00:07:40,400
decrypt any messages that were encrypted

234
00:07:37,599 --> 00:07:40,400
with respect to this

235
00:07:40,720 --> 00:07:44,160
and a really nice idea to prevent these

236
00:07:43,120 --> 00:07:47,280
types of attack

237
00:07:44,160 --> 00:07:49,680
is to make secret keys intentionally big

238
00:07:47,280 --> 00:07:52,080
uh so instead of having a secret key be

239
00:07:49,680 --> 00:07:53,919
like 128 or 256 bits

240
00:07:52,080 --> 00:07:55,840
let's think of a secret key which is 50

241
00:07:53,919 --> 00:07:57,680
gigabytes in size

242
00:07:55,840 --> 00:08:00,479
and the idea is that a 50 gigabyte

243
00:07:57,680 --> 00:08:02,080
secret key is difficult to exfiltrate

244
00:08:00,479 --> 00:08:05,039
from the compromise system it's a lot

245
00:08:02,080 --> 00:08:06,719
harder to get it out than it would be to

246
00:08:05,039 --> 00:08:08,719
take to get a smoky out

247
00:08:06,720 --> 00:08:11,120
maybe there's some firewalls etc that

248
00:08:08,720 --> 00:08:13,120
can detect huge amounts of exfiltration

249
00:08:11,120 --> 00:08:14,319
but wouldn't be able to detect uh just

250
00:08:13,120 --> 00:08:17,360
128

251
00:08:14,319 --> 00:08:19,759
bit keeping being exfiltrated

252
00:08:17,360 --> 00:08:21,440
and so i want to use an image that's uh

253
00:08:19,759 --> 00:08:24,800
due to adi shamir so

254
00:08:21,440 --> 00:08:27,199
uh adi had this great analogy he said

255
00:08:24,800 --> 00:08:28,560
you know if you want to protect a small

256
00:08:27,199 --> 00:08:30,080
diamond you really need a lot of

257
00:08:28,560 --> 00:08:32,159
security you need to watch it very

258
00:08:30,080 --> 00:08:34,478
carefully have a security team

259
00:08:32,159 --> 00:08:36,399
but uh statue of liberty is also a

260
00:08:34,479 --> 00:08:38,399
pretty valuable object you're not really

261
00:08:36,399 --> 00:08:39,919
worried about people stealing the statue

262
00:08:38,399 --> 00:08:41,599
of liberty because it's very difficult

263
00:08:39,919 --> 00:08:43,360
to steal and so that's the idea

264
00:08:41,599 --> 00:08:45,440
here we're going to sort of make the key

265
00:08:43,360 --> 00:08:48,320
intention a huge to make it difficult

266
00:08:45,440 --> 00:08:48,320
uh to steal it

267
00:08:49,120 --> 00:08:53,120
okay and so this uh this idea actually

268
00:08:51,200 --> 00:08:54,080
goes back it's been studied uh in quite

269
00:08:53,120 --> 00:08:57,040
a few cryptographic

270
00:08:54,080 --> 00:08:58,720
works uh um often it's referred to as

271
00:08:57,040 --> 00:08:59,760
the bound retrieval model or biki

272
00:08:58,720 --> 00:09:01,680
cryptography

273
00:08:59,760 --> 00:09:03,600
and these cryptosystems have two goals

274
00:09:01,680 --> 00:09:05,199
so the first goal is to design a crypto

275
00:09:03,600 --> 00:09:07,440
system that has a huge key

276
00:09:05,200 --> 00:09:08,399
50 gigabytes key and ensure that

277
00:09:07,440 --> 00:09:11,680
security holds

278
00:09:08,399 --> 00:09:14,720
even if uh let's say 99 of the

279
00:09:11,680 --> 00:09:17,519
key data leaks so even if 99

280
00:09:14,720 --> 00:09:18,399
of the even if let's say 49 out of 50

281
00:09:17,519 --> 00:09:20,959
gigabytes

282
00:09:18,399 --> 00:09:22,160
uh are are leaked out of the system the

283
00:09:20,959 --> 00:09:24,079
adversary cannot

284
00:09:22,160 --> 00:09:26,240
uh break the security of the crypto

285
00:09:24,080 --> 00:09:28,320
system and the second goal

286
00:09:26,240 --> 00:09:29,279
is to make sure these crypto systems are

287
00:09:28,320 --> 00:09:31,040
efficient

288
00:09:29,279 --> 00:09:32,320
even though their secret key is huge so

289
00:09:31,040 --> 00:09:34,240
for example uh

290
00:09:32,320 --> 00:09:35,440
reading even just reading an entire 50

291
00:09:34,240 --> 00:09:37,279
gigabyte key to like

292
00:09:35,440 --> 00:09:38,560
do a cryptographic operation would be

293
00:09:37,279 --> 00:09:40,000
real and efficient

294
00:09:38,560 --> 00:09:42,160
so we want to make sure these crypto

295
00:09:40,000 --> 00:09:43,839
systems only read a small portion of the

296
00:09:42,160 --> 00:09:45,920
key in each operation and their overall

297
00:09:43,839 --> 00:09:48,080
efficiency should not be much worse

298
00:09:45,920 --> 00:09:50,719
than that of standard small key crypto

299
00:09:48,080 --> 00:09:54,399
systems that have a 128 or 256

300
00:09:50,720 --> 00:09:55,120
uh vicky so uh so there's a lot of work

301
00:09:54,399 --> 00:09:58,399
devoted

302
00:09:55,120 --> 00:09:59,279
to to um to this idea but one problem

303
00:09:58,399 --> 00:10:01,600
with all of the

304
00:09:59,279 --> 00:10:02,880
prior works is that they require the

305
00:10:01,600 --> 00:10:05,600
users to store

306
00:10:02,880 --> 00:10:06,880
a huge let's say 50 gigabyte key and

307
00:10:05,600 --> 00:10:09,920
waste its storage

308
00:10:06,880 --> 00:10:11,839
on this on this the key is completely

309
00:10:09,920 --> 00:10:13,760
useless for any other reason other than

310
00:10:11,839 --> 00:10:14,160
to do cryptography so you're essentially

311
00:10:13,760 --> 00:10:17,760
just

312
00:10:14,160 --> 00:10:18,000
wasting storage and so the new idea in

313
00:10:17,760 --> 00:10:20,000
our

314
00:10:18,000 --> 00:10:21,760
work is let's make the key useful

315
00:10:20,000 --> 00:10:23,120
instead of just storing some making the

316
00:10:21,760 --> 00:10:25,760
key random data

317
00:10:23,120 --> 00:10:26,720
let's make the key uh store something

318
00:10:25,760 --> 00:10:28,560
useful like

319
00:10:26,720 --> 00:10:30,800
let's say the movie database that a user

320
00:10:28,560 --> 00:10:32,640
would store anyway or maybe an offline

321
00:10:30,800 --> 00:10:33,279
version of wikipedia that the user wants

322
00:10:32,640 --> 00:10:36,160
to store

323
00:10:33,279 --> 00:10:36,800
for when the user goes offline and wants

324
00:10:36,160 --> 00:10:40,480
to still

325
00:10:36,800 --> 00:10:41,439
read wikipedia so so the idea is let's

326
00:10:40,480 --> 00:10:43,519
make

327
00:10:41,440 --> 00:10:45,440
wikipedia data let's make the secret key

328
00:10:43,519 --> 00:10:47,440
consists of wikipedia data

329
00:10:45,440 --> 00:10:49,120
now is that a good idea is wikipedia a

330
00:10:47,440 --> 00:10:50,959
good secret key well no it's

331
00:10:49,120 --> 00:10:53,279
it's a really terrible idea wikipedia is

332
00:10:50,959 --> 00:10:54,560
public uh anyone can access it on the

333
00:10:53,279 --> 00:10:57,360
internet so it's a really

334
00:10:54,560 --> 00:10:58,719
terrible secret key uh it's really a

335
00:10:57,360 --> 00:11:01,040
terrible idea to use wikipedia as a

336
00:10:58,720 --> 00:11:03,600
secret key

337
00:11:01,040 --> 00:11:05,279
but the idea is don't use wikipedia

338
00:11:03,600 --> 00:11:07,360
itself as a secret key instead

339
00:11:05,279 --> 00:11:08,959
use an incompressible encoding of

340
00:11:07,360 --> 00:11:11,200
wikipedia and here

341
00:11:08,959 --> 00:11:12,880
uh you can certainly see that this

342
00:11:11,200 --> 00:11:14,399
starts making a lot more sense so first

343
00:11:12,880 --> 00:11:16,880
of all there was some randomness

344
00:11:14,399 --> 00:11:18,320
that went into making this encoding and

345
00:11:16,880 --> 00:11:20,079
therefore the encoding is not

346
00:11:18,320 --> 00:11:21,519
predictable so at least there's a chance

347
00:11:20,079 --> 00:11:23,839
of being a good key

348
00:11:21,519 --> 00:11:25,360
and moreover even if the system is

349
00:11:23,839 --> 00:11:27,440
compromised and adversary tries to

350
00:11:25,360 --> 00:11:29,040
exfiltrate some small amount of data

351
00:11:27,440 --> 00:11:30,880
this incompressible encoding is

352
00:11:29,040 --> 00:11:32,880
incompressible so it ensures

353
00:11:30,880 --> 00:11:34,560
that if you use it as a key the address

354
00:11:32,880 --> 00:11:36,880
it can't steal the entire key

355
00:11:34,560 --> 00:11:38,959
by downloading by exfiltrating some

356
00:11:36,880 --> 00:11:40,160
small amount of data from the compromise

357
00:11:38,959 --> 00:11:41,920
system

358
00:11:40,160 --> 00:11:43,439
so this tells us at least it has a

359
00:11:41,920 --> 00:11:45,199
chance of working of course

360
00:11:43,440 --> 00:11:46,560
uh that's not we're not done yet in

361
00:11:45,200 --> 00:11:49,040
order to actually make

362
00:11:46,560 --> 00:11:50,239
use of this key we have to design new

363
00:11:49,040 --> 00:11:53,279
crypto systems

364
00:11:50,240 --> 00:11:55,440
um that ensure that security holds as

365
00:11:53,279 --> 00:11:57,439
long as the attacker doesn't download

366
00:11:55,440 --> 00:11:58,560
doesn't compress the entire key and we

367
00:11:57,440 --> 00:12:00,480
managed to do this

368
00:11:58,560 --> 00:12:01,920
so in our work we show how to construct

369
00:12:00,480 --> 00:12:03,519
a public key encryption

370
00:12:01,920 --> 00:12:05,040
in this setting so essentially construct

371
00:12:03,519 --> 00:12:08,560
public encryption scheme

372
00:12:05,040 --> 00:12:10,240
where the secret key can be a huge

373
00:12:08,560 --> 00:12:11,680
incompressible encoding of some public

374
00:12:10,240 --> 00:12:12,639
data and compressible cooking coding

375
00:12:11,680 --> 00:12:14,638
wikipedia

376
00:12:12,639 --> 00:12:16,320
and security will hold even if that

377
00:12:14,639 --> 00:12:17,920
attacker gets a very large

378
00:12:16,320 --> 00:12:19,600
exfiltrates a large fraction of the

379
00:12:17,920 --> 00:12:21,760
encoding size um

380
00:12:19,600 --> 00:12:23,279
as long as he doesn't exfiltrate enough

381
00:12:21,760 --> 00:12:25,839
to be able to

382
00:12:23,279 --> 00:12:28,720
recover the encoding to be able to

383
00:12:25,839 --> 00:12:28,720
recover the codeword

384
00:12:30,000 --> 00:12:34,079
okay so that's the new application

385
00:12:32,320 --> 00:12:34,959
artwork and i want to tell you a little

386
00:12:34,079 --> 00:12:36,399
bit about the

387
00:12:34,959 --> 00:12:38,479
constructions of incompressible

388
00:12:36,399 --> 00:12:40,160
encodings uh both from our work and from

389
00:12:38,480 --> 00:12:43,040
the previous work so as i mentioned

390
00:12:40,160 --> 00:12:43,360
uh this problem was originally studied

391
00:12:43,040 --> 00:12:45,279
in

392
00:12:43,360 --> 00:12:47,040
a work from kryptolazu by dam guard

393
00:12:45,279 --> 00:12:49,040
gandhian orlandi

394
00:12:47,040 --> 00:12:51,439
and they gave a construction in the

395
00:12:49,040 --> 00:12:53,279
ideal permutation model

396
00:12:51,440 --> 00:12:54,480
additionally using trapdoor permutations

397
00:12:53,279 --> 00:12:56,000
or rsa

398
00:12:54,480 --> 00:12:57,440
okay so this was not in the standard

399
00:12:56,000 --> 00:12:58,560
model they assume they have an ideal

400
00:12:57,440 --> 00:13:00,880
permutation

401
00:12:58,560 --> 00:13:01,839
which is something that's a little bit

402
00:13:00,880 --> 00:13:05,040
stronger than

403
00:13:01,839 --> 00:13:06,720
a random oracle um

404
00:13:05,040 --> 00:13:08,480
so that's one caveat of their work that

405
00:13:06,720 --> 00:13:10,480
they needed ideal permutations and the

406
00:13:08,480 --> 00:13:11,440
other caveat of their work is that the

407
00:13:10,480 --> 00:13:13,680
complexity

408
00:13:11,440 --> 00:13:15,360
of the encoding process was quadratic in

409
00:13:13,680 --> 00:13:17,199
the message size

410
00:13:15,360 --> 00:13:19,279
um and this is actually quite a big

411
00:13:17,200 --> 00:13:20,720
caveat because we want to apply this to

412
00:13:19,279 --> 00:13:22,560
large messages like

413
00:13:20,720 --> 00:13:24,000
50 gigabytes or maybe terabytes in

414
00:13:22,560 --> 00:13:26,880
length

415
00:13:24,000 --> 00:13:27,360
and a quadratic complexity on such large

416
00:13:26,880 --> 00:13:31,120
data

417
00:13:27,360 --> 00:13:32,639
is really really inefficient

418
00:13:31,120 --> 00:13:34,160
and lastly there was one more caveat

419
00:13:32,639 --> 00:13:34,880
which is that the proof of security in

420
00:13:34,160 --> 00:13:38,240
that work

421
00:13:34,880 --> 00:13:40,000
um was uh was flawed so we noticed this

422
00:13:38,240 --> 00:13:41,360
that there was uh serious issues with

423
00:13:40,000 --> 00:13:43,199
the security proof

424
00:13:41,360 --> 00:13:45,600
and it seemed to be flawed beyond some

425
00:13:43,199 --> 00:13:47,519
simple patch or simple fix

426
00:13:45,600 --> 00:13:48,880
and actually there was a concurrent work

427
00:13:47,519 --> 00:13:51,120
concurrent to ours by

428
00:13:48,880 --> 00:13:53,120
gargle and waters they also noticed that

429
00:13:51,120 --> 00:13:55,600
there was a problem with the proof

430
00:13:53,120 --> 00:13:56,800
and uh they actually managed to fix the

431
00:13:55,600 --> 00:13:57,839
proof i want to give them a shout out

432
00:13:56,800 --> 00:14:00,479
this was not a

433
00:13:57,839 --> 00:14:01,680
simple fix they it really required an

434
00:14:00,480 --> 00:14:03,600
entirely new proof

435
00:14:01,680 --> 00:14:04,800
and quite a bit of difficult work so

436
00:14:03,600 --> 00:14:07,839
this was actually a

437
00:14:04,800 --> 00:14:08,160
a new major new result to show that uh

438
00:14:07,839 --> 00:14:09,920
the

439
00:14:08,160 --> 00:14:12,160
original construction from the work of

440
00:14:09,920 --> 00:14:14,240
ganesh namgar ganesha narandi

441
00:14:12,160 --> 00:14:16,240
can actually be fixed can be proven

442
00:14:14,240 --> 00:14:17,600
proven secure

443
00:14:16,240 --> 00:14:19,120
and in doing that they actually also

444
00:14:17,600 --> 00:14:20,880
managed to improve it in one additional

445
00:14:19,120 --> 00:14:21,920
way they managed to replace the ideal

446
00:14:20,880 --> 00:14:24,320
tractor permutation

447
00:14:21,920 --> 00:14:25,519
ideal permutation with just a random

448
00:14:24,320 --> 00:14:28,959
oracle which is

449
00:14:25,519 --> 00:14:31,120
somewhat simpler primitive

450
00:14:28,959 --> 00:14:32,479
so in our work uh we give actually a

451
00:14:31,120 --> 00:14:34,079
brand new construction

452
00:14:32,480 --> 00:14:35,839
of incompressible encodings different

453
00:14:34,079 --> 00:14:37,439
construction uh

454
00:14:35,839 --> 00:14:39,120
so uh and we managed to give a

455
00:14:37,440 --> 00:14:41,120
construction that is

456
00:14:39,120 --> 00:14:44,000
secure in the common random string model

457
00:14:41,120 --> 00:14:45,760
so we avoid the use of random oracles

458
00:14:44,000 --> 00:14:47,360
and we prove it secure under either the

459
00:14:45,760 --> 00:14:49,600
learning with errors

460
00:14:47,360 --> 00:14:51,360
or decision composite residual acid

461
00:14:49,600 --> 00:14:52,880
assumption

462
00:14:51,360 --> 00:14:54,560
so that's one improvement we get a

463
00:14:52,880 --> 00:14:56,720
construction standard model

464
00:14:54,560 --> 00:14:58,880
the other improvement is that we improve

465
00:14:56,720 --> 00:15:00,639
the complexity from quadratic to linear

466
00:14:58,880 --> 00:15:02,480
as i said earlier because we're thinking

467
00:15:00,639 --> 00:15:06,160
of applying this to big data

468
00:15:02,480 --> 00:15:07,600
this is a significant uh improvement

469
00:15:06,160 --> 00:15:09,120
uh but there are some caveats with this

470
00:15:07,600 --> 00:15:11,440
construction so it actually only

471
00:15:09,120 --> 00:15:14,240
achieves selective security

472
00:15:11,440 --> 00:15:16,079
where we assume that the message has to

473
00:15:14,240 --> 00:15:17,440
be chosen by the adversary before seeing

474
00:15:16,079 --> 00:15:19,359
the crs

475
00:15:17,440 --> 00:15:21,279
and the crs size is very long it's as

476
00:15:19,360 --> 00:15:22,399
large as the size of the data we're

477
00:15:21,279 --> 00:15:24,399
trying to encode

478
00:15:22,399 --> 00:15:26,079
so we're trying to go wikipedia it would

479
00:15:24,399 --> 00:15:29,279
be let's say 50 gigabyte

480
00:15:26,079 --> 00:15:31,199
long crs and we show that we can remove

481
00:15:29,279 --> 00:15:32,720
uh both of these caveats and the random

482
00:15:31,199 --> 00:15:33,519
oracle model so we go to the random

483
00:15:32,720 --> 00:15:36,240
oracle model

484
00:15:33,519 --> 00:15:37,680
then we can get uh adaptive security

485
00:15:36,240 --> 00:15:38,720
there's no crs it's just a random

486
00:15:37,680 --> 00:15:40,719
article so we don't have to

487
00:15:38,720 --> 00:15:42,399
we don't need a long crs either so we

488
00:15:40,720 --> 00:15:43,839
essentially get the best of all worlds

489
00:15:42,399 --> 00:15:44,959
and this still improves on the previous

490
00:15:43,839 --> 00:15:46,560
work by removing

491
00:15:44,959 --> 00:15:48,560
by improving the complexity from

492
00:15:46,560 --> 00:15:51,359
quadratic to linear

493
00:15:48,560 --> 00:15:53,518
even in the random or command and we

494
00:15:51,360 --> 00:15:54,800
also give some black box separations to

495
00:15:53,519 --> 00:15:56,000
show that these constructions are

496
00:15:54,800 --> 00:15:58,079
essentially optimal

497
00:15:56,000 --> 00:16:00,399
so for example we show that we cannot

498
00:15:58,079 --> 00:16:03,519
have provably secure

499
00:16:00,399 --> 00:16:05,199
non-trivial constructions of um of

500
00:16:03,519 --> 00:16:08,480
incompressible encodings

501
00:16:05,199 --> 00:16:10,719
in the plane model and in the crs model

502
00:16:08,480 --> 00:16:12,720
uh we actually need to suffer from all

503
00:16:10,720 --> 00:16:14,480
of the caveats that our construction had

504
00:16:12,720 --> 00:16:16,320
so the crs needs to be long

505
00:16:14,480 --> 00:16:19,040
and we can only achieve selective

506
00:16:16,320 --> 00:16:20,800
security so this holds for constructions

507
00:16:19,040 --> 00:16:23,519
that are provably secure

508
00:16:20,800 --> 00:16:26,079
using game based or falsifiable

509
00:16:23,519 --> 00:16:26,079
assumptions

510
00:16:26,800 --> 00:16:31,120
okay so let me tell you a little bit

511
00:16:29,440 --> 00:16:32,480
about our construction i'll give you a

512
00:16:31,120 --> 00:16:35,279
slightly simplified

513
00:16:32,480 --> 00:16:35,680
uh version of this and i want to say

514
00:16:35,279 --> 00:16:37,759
that

515
00:16:35,680 --> 00:16:39,199
our construction one additional i would

516
00:16:37,759 --> 00:16:40,800
say benefit of our construction

517
00:16:39,199 --> 00:16:42,719
construction is that it's conceptually

518
00:16:40,800 --> 00:16:43,920
very simple and i'll actually be able to

519
00:16:42,720 --> 00:16:46,639
even show you

520
00:16:43,920 --> 00:16:48,079
um uh the proof of security for a

521
00:16:46,639 --> 00:16:49,519
slightly simplified version of this

522
00:16:48,079 --> 00:16:51,439
construction

523
00:16:49,519 --> 00:16:53,920
so for the simplified version let's

524
00:16:51,440 --> 00:16:55,360
pretend that we have saw a really nice

525
00:16:53,920 --> 00:16:56,560
object called the lossy trapdoor

526
00:16:55,360 --> 00:16:58,880
permutation

527
00:16:56,560 --> 00:17:00,800
so a lossy tractor permutation is like a

528
00:16:58,880 --> 00:17:01,519
lossy trapped or function so there's an

529
00:17:00,800 --> 00:17:04,480
ocean due to

530
00:17:01,519 --> 00:17:05,280
uh biker and waters which is also a

531
00:17:04,480 --> 00:17:06,799
permutation

532
00:17:05,280 --> 00:17:10,399
so we assume we have a family of

533
00:17:06,799 --> 00:17:12,720
functions uh indexed by some public epk

534
00:17:10,400 --> 00:17:14,640
uh that maps and bits to embed so both

535
00:17:12,720 --> 00:17:16,559
the domain and range are in bits

536
00:17:14,640 --> 00:17:18,000
and we can sample the public in one of

537
00:17:16,559 --> 00:17:19,839
two indistinguishable modes

538
00:17:18,000 --> 00:17:22,000
so in the first mode the function is

539
00:17:19,839 --> 00:17:24,079
injective so this is the standard notion

540
00:17:22,000 --> 00:17:26,000
of trapdoor permutations

541
00:17:24,079 --> 00:17:27,599
uh you can sample the public key with a

542
00:17:26,000 --> 00:17:29,760
trapdoor that allows us to

543
00:17:27,599 --> 00:17:31,360
efficiently invert the function at any

544
00:17:29,760 --> 00:17:33,679
point

545
00:17:31,360 --> 00:17:35,199
but in the second mode uh we can sample

546
00:17:33,679 --> 00:17:37,840
the public key in a way

547
00:17:35,200 --> 00:17:39,840
that the image size of the function fpk

548
00:17:37,840 --> 00:17:41,600
is much much smaller than the domain

549
00:17:39,840 --> 00:17:43,120
zero one to the n so it's two to the

550
00:17:41,600 --> 00:17:45,120
little of n

551
00:17:43,120 --> 00:17:47,439
which means that if i give you f p k of

552
00:17:45,120 --> 00:17:49,918
x this loses a lot of information

553
00:17:47,440 --> 00:17:50,559
almost all the information about the

554
00:17:49,919 --> 00:17:54,080
input

555
00:17:50,559 --> 00:17:54,080
x so it's very lost

556
00:17:54,960 --> 00:17:59,520
okay so using this object this lossy

557
00:17:57,840 --> 00:18:00,159
chapter permutation let me show you how

558
00:17:59,520 --> 00:18:02,080
to construct

559
00:18:00,160 --> 00:18:03,440
incompressible encodings in the crs

560
00:18:02,080 --> 00:18:06,320
model

561
00:18:03,440 --> 00:18:06,960
and uh in this construction the crs will

562
00:18:06,320 --> 00:18:10,080
consist

563
00:18:06,960 --> 00:18:13,039
of some number of random

564
00:18:10,080 --> 00:18:13,439
values and bit values you can think of

565
00:18:13,039 --> 00:18:17,280
these

566
00:18:13,440 --> 00:18:19,200
as outputs of descriptor permutation

567
00:18:17,280 --> 00:18:20,799
so this is just a common random string

568
00:18:19,200 --> 00:18:23,679
now to encode a message

569
00:18:20,799 --> 00:18:23,918
m which we think of as uh consisting of

570
00:18:23,679 --> 00:18:27,039
l

571
00:18:23,919 --> 00:18:29,200
blocks each of n bits and bits each

572
00:18:27,039 --> 00:18:30,480
we're going to sample a random public

573
00:18:29,200 --> 00:18:32,799
key along with a trapdoor

574
00:18:30,480 --> 00:18:34,240
for the lossy chart representation in

575
00:18:32,799 --> 00:18:36,080
injected mode

576
00:18:34,240 --> 00:18:37,360
and then we're going to invert the

577
00:18:36,080 --> 00:18:40,639
trader permutation

578
00:18:37,360 --> 00:18:42,559
on the values mi xor yi so we're going

579
00:18:40,640 --> 00:18:44,000
to take the message xor it with the

580
00:18:42,559 --> 00:18:47,760
value in the crs

581
00:18:44,000 --> 00:18:48,720
and invert it uh and output xi's the

582
00:18:47,760 --> 00:18:50,480
xi's

583
00:18:48,720 --> 00:18:51,919
and that's going to be the encoding so

584
00:18:50,480 --> 00:18:53,039
the encoding is going to consist of the

585
00:18:51,919 --> 00:18:56,799
public key

586
00:18:53,039 --> 00:18:59,360
and all of these pre and we're going to

587
00:18:56,799 --> 00:19:00,639
forget the trapdoor okay so the trapdoor

588
00:18:59,360 --> 00:19:01,678
was part of the randomness of the

589
00:19:00,640 --> 00:19:03,280
encoding process

590
00:19:01,679 --> 00:19:05,679
but the encoding is going to forget it

591
00:19:03,280 --> 00:19:08,160
afterwards

592
00:19:05,679 --> 00:19:08,799
and this is efficiently decodable so if

593
00:19:08,160 --> 00:19:11,600
i give you

594
00:19:08,799 --> 00:19:12,960
this code word c you can easily just

595
00:19:11,600 --> 00:19:13,678
apply the function in the forward

596
00:19:12,960 --> 00:19:16,480
direction

597
00:19:13,679 --> 00:19:18,400
on the xi's you can take fbq of xi xor

598
00:19:16,480 --> 00:19:18,880
them with the values in the crs xor them

599
00:19:18,400 --> 00:19:21,440
with the y

600
00:19:18,880 --> 00:19:23,360
eyes and recover the message so anybody

601
00:19:21,440 --> 00:19:25,760
can decode the code word and recover the

602
00:19:23,360 --> 00:19:27,360
original data

603
00:19:25,760 --> 00:19:29,440
okay and so i want to give you uh the

604
00:19:27,360 --> 00:19:30,320
proof of security uh intuitively very

605
00:19:29,440 --> 00:19:32,640
simple

606
00:19:30,320 --> 00:19:33,918
so the adversary in this game sees the

607
00:19:32,640 --> 00:19:35,919
common random string

608
00:19:33,919 --> 00:19:37,760
and some code word c which is an

609
00:19:35,919 --> 00:19:40,160
encoding of some message m that the

610
00:19:37,760 --> 00:19:41,679
adversary knows

611
00:19:40,160 --> 00:19:43,520
and in the original game the

612
00:19:41,679 --> 00:19:45,600
distribution of these two values is that

613
00:19:43,520 --> 00:19:48,799
the public key sample injective modes

614
00:19:45,600 --> 00:19:49,520
the y i's in the crs are uniformly

615
00:19:48,799 --> 00:19:52,320
random

616
00:19:49,520 --> 00:19:53,039
and the x i's are computed by inverting

617
00:19:52,320 --> 00:19:56,320
the function

618
00:19:53,039 --> 00:19:58,160
on the message xor with the crs

619
00:19:56,320 --> 00:20:00,639
but we can actually think of this

620
00:19:58,160 --> 00:20:02,320
distribution an alternate way

621
00:20:00,640 --> 00:20:03,679
which is completely identical so

622
00:20:02,320 --> 00:20:05,439
actually this is an identical

623
00:20:03,679 --> 00:20:08,159
distribution

624
00:20:05,440 --> 00:20:10,240
so in this case think of sampling so

625
00:20:08,159 --> 00:20:12,320
before we are sampling the y i's in the

626
00:20:10,240 --> 00:20:14,960
sierras at random and computing the x

627
00:20:12,320 --> 00:20:15,918
i's by inverting the the permutation now

628
00:20:14,960 --> 00:20:18,799
let's switch it up

629
00:20:15,919 --> 00:20:19,280
and sample the x i's uniformly random

630
00:20:18,799 --> 00:20:20,960
and

631
00:20:19,280 --> 00:20:22,799
compute the y i's by applying the

632
00:20:20,960 --> 00:20:25,919
function in the forward direction

633
00:20:22,799 --> 00:20:27,760
so this is exactly the same distribution

634
00:20:25,919 --> 00:20:29,280
notice the x i's and y rs are

635
00:20:27,760 --> 00:20:32,080
individually random

636
00:20:29,280 --> 00:20:33,039
in each of the two cases subject to this

637
00:20:32,080 --> 00:20:37,199
relation

638
00:20:33,039 --> 00:20:38,640
holding that y i is f of x i x or m i

639
00:20:37,200 --> 00:20:40,400
okay so this is the exact same

640
00:20:38,640 --> 00:20:43,520
distribution but

641
00:20:40,400 --> 00:20:45,440
uh syntactically now we're sampling the

642
00:20:43,520 --> 00:20:47,520
common random string in a way that

643
00:20:45,440 --> 00:20:49,200
depends on the message

644
00:20:47,520 --> 00:20:50,799
so this is something we couldn't have

645
00:20:49,200 --> 00:20:52,559
done in the original construction where

646
00:20:50,799 --> 00:20:53,200
the crs was chosen independently of the

647
00:20:52,559 --> 00:20:55,120
message

648
00:20:53,200 --> 00:20:56,320
but in this hybrid distribution we can

649
00:20:55,120 --> 00:20:59,360
do that

650
00:20:56,320 --> 00:21:01,200
uh even though nothing has changed from

651
00:20:59,360 --> 00:21:02,639
the distribution perspective

652
00:21:01,200 --> 00:21:04,559
and now we're just going to make the

653
00:21:02,640 --> 00:21:06,640
public key lossy

654
00:21:04,559 --> 00:21:07,678
okay and this is indistinguishable by

655
00:21:06,640 --> 00:21:09,039
the uh

656
00:21:07,679 --> 00:21:11,120
security of the lossy chamber

657
00:21:09,039 --> 00:21:12,640
permutation

658
00:21:11,120 --> 00:21:14,879
so what's happening now now the

659
00:21:12,640 --> 00:21:16,880
adversary gets the crs and the codeword

660
00:21:14,880 --> 00:21:20,000
under this lossy public key

661
00:21:16,880 --> 00:21:21,200
and notice that the code word has a lot

662
00:21:20,000 --> 00:21:25,039
of entropy

663
00:21:21,200 --> 00:21:27,440
even given the crs why is that

664
00:21:25,039 --> 00:21:29,280
because the x i values in the codeword

665
00:21:27,440 --> 00:21:31,039
are chosen uniformly random

666
00:21:29,280 --> 00:21:33,200
and then we apply a lossy trapdoor

667
00:21:31,039 --> 00:21:35,440
permutations on them

668
00:21:33,200 --> 00:21:36,480
which loses a lot of information about

669
00:21:35,440 --> 00:21:39,120
the xi's

670
00:21:36,480 --> 00:21:40,000
so actually even if i give you the crs

671
00:21:39,120 --> 00:21:42,320
the code word

672
00:21:40,000 --> 00:21:43,280
is has a lot of information theratic

673
00:21:42,320 --> 00:21:45,760
entropy

674
00:21:43,280 --> 00:21:46,320
even for a completely fixed message mi

675
00:21:45,760 --> 00:21:49,200
that

676
00:21:46,320 --> 00:21:50,879
that is known in public and this says

677
00:21:49,200 --> 00:21:51,280
that in this hybrid the code word is

678
00:21:50,880 --> 00:21:53,919
actually

679
00:21:51,280 --> 00:21:54,320
information theoretically incompressible

680
00:21:53,919 --> 00:21:57,120
uh

681
00:21:54,320 --> 00:21:59,039
even an unbounded adversary in this and

682
00:21:57,120 --> 00:22:01,199
the last hybrid cannot compress

683
00:21:59,039 --> 00:22:03,200
uh the code word down at something much

684
00:22:01,200 --> 00:22:04,960
smaller than the covert size

685
00:22:03,200 --> 00:22:06,640
because it has a lot of real information

686
00:22:04,960 --> 00:22:08,080
theoretic entropy and because it's

687
00:22:06,640 --> 00:22:10,080
indistinguishable from the original

688
00:22:08,080 --> 00:22:10,960
distribution it means that no adversary

689
00:22:10,080 --> 00:22:13,280
can succeed

690
00:22:10,960 --> 00:22:15,039
in compressing the code word also in the

691
00:22:13,280 --> 00:22:16,720
original distribution

692
00:22:15,039 --> 00:22:19,280
so that's the entire proof of security

693
00:22:16,720 --> 00:22:22,559
uh very very intuitively simple

694
00:22:19,280 --> 00:22:24,158
uh simple idea so uh last i want to talk

695
00:22:22,559 --> 00:22:26,960
about the instantiation so

696
00:22:24,159 --> 00:22:28,320
unfortunately we don't have a lossy

697
00:22:26,960 --> 00:22:30,240
traveler permutations

698
00:22:28,320 --> 00:22:31,520
uh that are as beautiful as what i

699
00:22:30,240 --> 00:22:33,200
assume we had

700
00:22:31,520 --> 00:22:34,799
uh where the domain and range is just

701
00:22:33,200 --> 00:22:36,880
zero one to the n

702
00:22:34,799 --> 00:22:38,400
so if you look at known constructions of

703
00:22:36,880 --> 00:22:39,360
lossy tractor functions the vast

704
00:22:38,400 --> 00:22:41,520
majority of them

705
00:22:39,360 --> 00:22:43,120
are not surjective the output size is

706
00:22:41,520 --> 00:22:44,559
bigger than the input size

707
00:22:43,120 --> 00:22:46,559
and in this construction our

708
00:22:44,559 --> 00:22:48,320
construction we crucially use that we

709
00:22:46,559 --> 00:22:51,440
have a subjective function because

710
00:22:48,320 --> 00:22:54,799
uh the honest scheme actually

711
00:22:51,440 --> 00:22:56,799
inverted the function at random outputs

712
00:22:54,799 --> 00:22:58,320
okay so we cannot use the vast majority

713
00:22:56,799 --> 00:23:00,559
of constructions of velocity charger

714
00:22:58,320 --> 00:23:03,520
functions because they're not surjective

715
00:23:00,559 --> 00:23:05,760
and uh and or they also don't have like

716
00:23:03,520 --> 00:23:07,360
nice domains like zero one to the n

717
00:23:05,760 --> 00:23:08,799
uh so their domains are much more

718
00:23:07,360 --> 00:23:10,399
structured like group elements or

719
00:23:08,799 --> 00:23:12,080
something like that

720
00:23:10,400 --> 00:23:13,679
so in our work we show that we actually

721
00:23:12,080 --> 00:23:15,439
don't need to have these beautiful

722
00:23:13,679 --> 00:23:18,000
lossy character permutations we can do

723
00:23:15,440 --> 00:23:18,480
with something a little more relaxed uh

724
00:23:18,000 --> 00:23:21,840
something

725
00:23:18,480 --> 00:23:23,360
called surjective lossy functions uh so

726
00:23:21,840 --> 00:23:25,280
the domain doesn't have to be as nice as

727
00:23:23,360 --> 00:23:26,639
you want to the end and they do have to

728
00:23:25,280 --> 00:23:27,520
be subjective but they don't actually

729
00:23:26,640 --> 00:23:29,679
have to be fully

730
00:23:27,520 --> 00:23:31,039
injective so we relax the injectivity

731
00:23:29,679 --> 00:23:32,880
requirements

732
00:23:31,039 --> 00:23:34,960
and we managed to construct these from

733
00:23:32,880 --> 00:23:37,200
decision composite residuosity

734
00:23:34,960 --> 00:23:38,960
and learning with errors assumption and

735
00:23:37,200 --> 00:23:40,159
i want to mention actually the lwe

736
00:23:38,960 --> 00:23:43,360
version construction

737
00:23:40,159 --> 00:23:44,720
has some uh interesting new ideas uh

738
00:23:43,360 --> 00:23:46,399
so for example we didn't even know how

739
00:23:44,720 --> 00:23:48,240
to construct trapdoor permutations from

740
00:23:46,400 --> 00:23:48,799
lw so you really need something

741
00:23:48,240 --> 00:23:50,400
different

742
00:23:48,799 --> 00:23:52,960
than let's say even the random oracle

743
00:23:50,400 --> 00:23:54,720
construction of damkar ganesha orlandi

744
00:23:52,960 --> 00:23:56,159
which required which will relied on

745
00:23:54,720 --> 00:23:58,720
tractor permutations

746
00:23:56,159 --> 00:24:00,240
so here uh we managed to show something

747
00:23:58,720 --> 00:24:01,200
under lw it's not quite a trapdoor

748
00:24:00,240 --> 00:24:02,480
permutation

749
00:24:01,200 --> 00:24:04,159
but it's something that just closes

750
00:24:02,480 --> 00:24:05,679
possible representation so it's a

751
00:24:04,159 --> 00:24:09,200
surjective function

752
00:24:05,679 --> 00:24:09,760
where um the uh the domain is not much

753
00:24:09,200 --> 00:24:11,360
bigger

754
00:24:09,760 --> 00:24:13,600
than the range so it's surjective it's a

755
00:24:11,360 --> 00:24:17,279
little compressing but not by much

756
00:24:13,600 --> 00:24:18,000
um and this uh this is some interesting

757
00:24:17,279 --> 00:24:20,960
new idea so

758
00:24:18,000 --> 00:24:22,320
i encourage you to look in the paper and

759
00:24:20,960 --> 00:24:24,000
that's all i want to tell you so thank

760
00:24:22,320 --> 00:24:26,399
you very much uh for your attention

761
00:24:24,000 --> 00:24:28,240
uh if you have any questions uh i'll be

762
00:24:26,400 --> 00:24:28,960
uh doing giving this talk live during

763
00:24:28,240 --> 00:24:30,799
crypto

764
00:24:28,960 --> 00:24:32,000
and i'm also happy to answer questions

765
00:24:30,799 --> 00:24:38,240
by email so please email

766
00:24:32,000 --> 00:24:38,240
me thank you

