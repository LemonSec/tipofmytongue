1
00:00:00,160 --> 00:00:03,520
hello everyone in this video i'm going

2
00:00:02,000 --> 00:00:05,040
to play into some recent work we get

3
00:00:03,520 --> 00:00:06,798
with my colleagues paul kirchner and

4
00:00:05,040 --> 00:00:08,800
kieran fucon the first production of

5
00:00:06,799 --> 00:00:11,519
algebraic lattices

6
00:00:08,800 --> 00:00:14,400
first of all a bit of recall on lattices

7
00:00:11,519 --> 00:00:17,440
and the celebrated ll algorithm

8
00:00:14,400 --> 00:00:18,960
so alatis is a discrete subgroup of a

9
00:00:17,440 --> 00:00:22,160
euclidean space so for instance

10
00:00:18,960 --> 00:00:24,400
r to the n um it means that we get

11
00:00:22,160 --> 00:00:25,680
a bunch of regularly space points in the

12
00:00:24,400 --> 00:00:26,560
space which are handled with a group

13
00:00:25,680 --> 00:00:29,039
structure

14
00:00:26,560 --> 00:00:31,919
another way of saying it is that we can

15
00:00:29,039 --> 00:00:33,680
take a freezy module and handle it with

16
00:00:31,920 --> 00:00:34,559
some inner product on the ambient space

17
00:00:33,680 --> 00:00:37,280
which is

18
00:00:34,559 --> 00:00:39,199
your lattice tensorized by r a very

19
00:00:37,280 --> 00:00:42,000
interesting property of lattices is that

20
00:00:39,200 --> 00:00:42,800
uh for in the lattice lambda of fixed

21
00:00:42,000 --> 00:00:44,960
round d

22
00:00:42,800 --> 00:00:46,239
then we are sure by minkowski theorem

23
00:00:44,960 --> 00:00:49,440
that we can find

24
00:00:46,239 --> 00:00:52,078
a vector which is somehow small

25
00:00:49,440 --> 00:00:54,320
compared to the normalization of the

26
00:00:52,079 --> 00:00:57,680
curve volume which encodes somehow

27
00:00:54,320 --> 00:00:59,760
how dense your lattice is

28
00:00:57,680 --> 00:01:02,160
the problem is that even though we know

29
00:00:59,760 --> 00:01:05,519
that such a short vector exists

30
00:01:02,160 --> 00:01:09,679
uh finding it computationally is very

31
00:01:05,519 --> 00:01:11,040
hard however in 82 less transfer and

32
00:01:09,680 --> 00:01:12,640
lovatch proved that there exists a

33
00:01:11,040 --> 00:01:14,960
polynomial time algorithm which given

34
00:01:12,640 --> 00:01:16,640
any lattice can produce a vector

35
00:01:14,960 --> 00:01:17,919
of the lattice which is of length at

36
00:01:16,640 --> 00:01:19,439
most two to the n longer than the

37
00:01:17,920 --> 00:01:22,080
shortest vector so the prime is

38
00:01:19,439 --> 00:01:23,679
hard for sure but you have polynomial

39
00:01:22,080 --> 00:01:26,798
time approximation

40
00:01:23,680 --> 00:01:30,320
of uh the surface vector this

41
00:01:26,799 --> 00:01:31,759
enables uh to solve a lot of uh

42
00:01:30,320 --> 00:01:32,880
problems arising in number three such as

43
00:01:31,759 --> 00:01:34,880
the simultaneous difference in

44
00:01:32,880 --> 00:01:36,640
approximation problem it also allows to

45
00:01:34,880 --> 00:01:37,759
find minimal polynomials of algebraic

46
00:01:36,640 --> 00:01:39,920
numbers

47
00:01:37,759 --> 00:01:41,280
in particular in this one the first

48
00:01:39,920 --> 00:01:43,280
application of

49
00:01:41,280 --> 00:01:44,399
the algorithm as it was presented by the

50
00:01:43,280 --> 00:01:46,799
original paper

51
00:01:44,399 --> 00:01:49,360
it allows to find the factorization of

52
00:01:46,799 --> 00:01:52,880
polynomials over rational numbers

53
00:01:49,360 --> 00:01:53,360
and in cryptanalysis lattice reduction

54
00:01:52,880 --> 00:01:56,399
has

55
00:01:53,360 --> 00:01:57,759
a huge number of applications it allows

56
00:01:56,399 --> 00:01:58,960
to solve knapsack problem in some

57
00:01:57,759 --> 00:02:02,560
specific settings

58
00:01:58,960 --> 00:02:03,199
it allows to solve rsa for small public

59
00:02:02,560 --> 00:02:06,320
exponent

60
00:02:03,200 --> 00:02:08,080
and of course it allows to break and

61
00:02:06,320 --> 00:02:11,920
estimate the security of

62
00:02:08,080 --> 00:02:14,319
all the lattice-based schemes

63
00:02:11,920 --> 00:02:15,119
but more importantly for what is going

64
00:02:14,319 --> 00:02:18,160
to follow

65
00:02:15,120 --> 00:02:18,640
it is also very useful in computational

66
00:02:18,160 --> 00:02:22,079
number

67
00:02:18,640 --> 00:02:24,640
theory in particular it is a

68
00:02:22,080 --> 00:02:27,040
basic building block of ideal

69
00:02:24,640 --> 00:02:28,879
computational algorithm or for the h and

70
00:02:27,040 --> 00:02:32,319
f computation algorithm

71
00:02:28,879 --> 00:02:34,640
over modules and it is used everywhere

72
00:02:32,319 --> 00:02:36,720
in algebraic number theory to control

73
00:02:34,640 --> 00:02:39,599
the size of the elements appearing

74
00:02:36,720 --> 00:02:41,040
in inside other more sophisticated

75
00:02:39,599 --> 00:02:42,640
algorithms

76
00:02:41,040 --> 00:02:44,480
so first of all let's see what the

77
00:02:42,640 --> 00:02:46,958
blueprint of this algorithm

78
00:02:44,480 --> 00:02:48,319
in particular what are the basic ideas

79
00:02:46,959 --> 00:02:50,400
that are

80
00:02:48,319 --> 00:02:51,920
making possible to reduce lattices in

81
00:02:50,400 --> 00:02:53,440
polynomial time

82
00:02:51,920 --> 00:02:55,359
so let's suppose that we want to reduce

83
00:02:53,440 --> 00:02:56,480
a rank n arbitrary lattice

84
00:02:55,360 --> 00:02:58,080
so the first thing we're going to do is

85
00:02:56,480 --> 00:02:59,679
to compute secure decomposition or

86
00:02:58,080 --> 00:03:01,840
equivalently to find the gram-schmidt

87
00:02:59,680 --> 00:03:04,319
vectors associated to the input basis

88
00:03:01,840 --> 00:03:05,599
which somehow encodes the defect of

89
00:03:04,319 --> 00:03:08,720
orthogonality that these

90
00:03:05,599 --> 00:03:10,640
the input basis vectors are okay so this

91
00:03:08,720 --> 00:03:13,040
is a polynomial time computation

92
00:03:10,640 --> 00:03:14,559
and then we're going to apply a

93
00:03:13,040 --> 00:03:17,120
procedure

94
00:03:14,560 --> 00:03:18,319
uh which given as an input the qr

95
00:03:17,120 --> 00:03:21,920
decomposition

96
00:03:18,319 --> 00:03:25,518
will allow us to reduce slightly

97
00:03:21,920 --> 00:03:29,280
the size of z vectors

98
00:03:25,519 --> 00:03:30,720
this will allows us to using integral

99
00:03:29,280 --> 00:03:33,440
roundings

100
00:03:30,720 --> 00:03:35,359
to find a shorter vectors and to control

101
00:03:33,440 --> 00:03:37,519
the size of the coefficients appearing

102
00:03:35,360 --> 00:03:39,280
during the reductions

103
00:03:37,519 --> 00:03:41,360
once we've done that through an

104
00:03:39,280 --> 00:03:44,159
iterative design

105
00:03:41,360 --> 00:03:44,959
the algorithm will call the reduction of

106
00:03:44,159 --> 00:03:46,959
rank 2

107
00:03:44,959 --> 00:03:48,720
projected sub-lattices i'm not entering

108
00:03:46,959 --> 00:03:51,200
into more details here but the

109
00:03:48,720 --> 00:03:51,840
uh basic idea behind the algorithm is

110
00:03:51,200 --> 00:03:53,599
that there is

111
00:03:51,840 --> 00:03:55,439
a polynomial time reduction from the

112
00:03:53,599 --> 00:03:56,560
reduction of a rank and lattice to the

113
00:03:55,439 --> 00:03:59,760
reduction of

114
00:03:56,560 --> 00:04:03,519
numerous but still polynomial

115
00:03:59,760 --> 00:04:06,000
numbers of wrong two sub-lattices

116
00:04:03,519 --> 00:04:08,560
this can be done efficiently using for

117
00:04:06,000 --> 00:04:11,599
instance a gauss algorithm which is

118
00:04:08,560 --> 00:04:14,000
which aims at reducing completely

119
00:04:11,599 --> 00:04:15,839
lattices of rank 2. so using this sub

120
00:04:14,000 --> 00:04:16,320
procedure what we're going to do is just

121
00:04:15,840 --> 00:04:18,639
to

122
00:04:16,320 --> 00:04:19,440
continue over and over until nothing

123
00:04:18,639 --> 00:04:21,120
happens and

124
00:04:19,440 --> 00:04:23,680
at that point we say that the basis is

125
00:04:21,120 --> 00:04:25,120
reduced so quantitatively speaking if we

126
00:04:23,680 --> 00:04:26,800
perform a naive analysis of this

127
00:04:25,120 --> 00:04:27,680
procedure basically we find a dependency

128
00:04:26,800 --> 00:04:29,840
which is sextic

129
00:04:27,680 --> 00:04:31,199
in the dimension of the lattice which is

130
00:04:29,840 --> 00:04:33,919
cubic in the

131
00:04:31,199 --> 00:04:34,479
bit size of them however uh if we

132
00:04:33,919 --> 00:04:37,198
replace

133
00:04:34,479 --> 00:04:38,960
naive arithmetic in particular handling

134
00:04:37,199 --> 00:04:39,840
a rational coefficient by numerator

135
00:04:38,960 --> 00:04:42,320
denominator

136
00:04:39,840 --> 00:04:43,919
and we use floating point representation

137
00:04:42,320 --> 00:04:46,560
basically we can prove

138
00:04:43,919 --> 00:04:48,000
that we can decrease the dependency in

139
00:04:46,560 --> 00:04:51,120
the bit size to

140
00:04:48,000 --> 00:04:55,040
quadratic and this was optimized by the

141
00:04:51,120 --> 00:04:57,360
work of angular and steely in 2009

142
00:04:55,040 --> 00:04:58,800
more recently using a recursive strategy

143
00:04:57,360 --> 00:05:01,520
uh numeron still

144
00:04:58,800 --> 00:05:03,600
proves that we can be actually quasi

145
00:05:01,520 --> 00:05:07,120
linear in the bit size of the input

146
00:05:03,600 --> 00:05:10,400
and be only a quasi aquatic

147
00:05:07,120 --> 00:05:13,919
in the dependency on the degree

148
00:05:10,400 --> 00:05:17,198
so now let's focus to the main

149
00:05:13,919 --> 00:05:18,880
purpose of this work and see how we can

150
00:05:17,199 --> 00:05:20,560
provide a reduction algorithm which is

151
00:05:18,880 --> 00:05:22,240
efficient for

152
00:05:20,560 --> 00:05:24,479
some generalization of the notional

153
00:05:22,240 --> 00:05:26,240
places which are algebraic lattices

154
00:05:24,479 --> 00:05:28,560
so to define what an algebraic lattice

155
00:05:26,240 --> 00:05:30,320
is basically we need to set up first uh

156
00:05:28,560 --> 00:05:32,000
what's a number field so it's a finite

157
00:05:30,320 --> 00:05:33,199
extension of the field of original q

158
00:05:32,000 --> 00:05:36,320
which can be realized

159
00:05:33,199 --> 00:05:38,960
as the quotient of q x by the ideal

160
00:05:36,320 --> 00:05:40,719
generated by some polynomial p

161
00:05:38,960 --> 00:05:42,159
inside this field we can find a

162
00:05:40,720 --> 00:05:44,479
particularly interesting ring which is a

163
00:05:42,160 --> 00:05:44,880
ring of integers and can be defined as a

164
00:05:44,479 --> 00:05:48,479
set

165
00:05:44,880 --> 00:05:51,680
of elements of the number fields which

166
00:05:48,479 --> 00:05:52,800
are annihilated by some monique

167
00:05:51,680 --> 00:05:56,080
polynomials with

168
00:05:52,800 --> 00:05:56,479
integral coefficients so for instance if

169
00:05:56,080 --> 00:05:59,440
you

170
00:05:56,479 --> 00:06:01,199
uh take the most basic number philosophy

171
00:05:59,440 --> 00:06:02,719
which is q itself as an extension of

172
00:06:01,199 --> 00:06:05,360
degree one over itself

173
00:06:02,720 --> 00:06:06,319
then the ring of integers recovers the

174
00:06:05,360 --> 00:06:08,720
actual

175
00:06:06,319 --> 00:06:10,240
integers rational integers if you take

176
00:06:08,720 --> 00:06:12,160
something which is slightly bigger

177
00:06:10,240 --> 00:06:13,840
so let's say a quadratic extension for

178
00:06:12,160 --> 00:06:16,800
instance q i

179
00:06:13,840 --> 00:06:18,159
then the ring of integer of qi is

180
00:06:16,800 --> 00:06:20,000
nothing else

181
00:06:18,160 --> 00:06:21,440
but the gaussian integers which are

182
00:06:20,000 --> 00:06:23,840
defined as

183
00:06:21,440 --> 00:06:24,800
z of i which are the elements of the

184
00:06:23,840 --> 00:06:28,000
form a plus

185
00:06:24,800 --> 00:06:31,759
a b for a b integral

186
00:06:28,000 --> 00:06:33,360
elements so recall that

187
00:06:31,759 --> 00:06:34,800
a bit earlier we defined the lattice as

188
00:06:33,360 --> 00:06:38,319
being a discrete sub growth of

189
00:06:34,800 --> 00:06:40,240
euclidean space and uh in fact we

190
00:06:38,319 --> 00:06:41,919
gave a slightly more general definition

191
00:06:40,240 --> 00:06:42,880
which was to take a freezie module of

192
00:06:41,919 --> 00:06:44,880
finite rank and

193
00:06:42,880 --> 00:06:45,919
with some inner products over the

194
00:06:44,880 --> 00:06:47,840
ambient space

195
00:06:45,919 --> 00:06:49,758
here what you can do to generalize this

196
00:06:47,840 --> 00:06:51,840
notion is to change

197
00:06:49,759 --> 00:06:52,800
the ring over which we are considering

198
00:06:51,840 --> 00:06:54,880
the lattice

199
00:06:52,800 --> 00:06:56,880
and in particular if we fix a number

200
00:06:54,880 --> 00:07:00,159
fill l what we can do

201
00:06:56,880 --> 00:07:01,599
is to uh set as a definition of natural

202
00:07:00,160 --> 00:07:03,520
languages to be a free

203
00:07:01,599 --> 00:07:05,280
ol module of finite rank which is

204
00:07:03,520 --> 00:07:08,400
endowed with an inner product

205
00:07:05,280 --> 00:07:09,520
on some ambient space and then you could

206
00:07:08,400 --> 00:07:11,120
say okay but what's

207
00:07:09,520 --> 00:07:12,560
what's the shape of an inner product on

208
00:07:11,120 --> 00:07:14,400
this crazy space and

209
00:07:12,560 --> 00:07:16,000
i'm not entering details here but you

210
00:07:14,400 --> 00:07:19,039
can define it in a canonical

211
00:07:16,000 --> 00:07:23,280
way using all the embeddings of

212
00:07:19,039 --> 00:07:23,280
your number field into c2cm

213
00:07:23,680 --> 00:07:28,960
so okay using this definition

214
00:07:26,800 --> 00:07:30,080
now we can wonder on what is the

215
00:07:28,960 --> 00:07:32,799
possible reduction

216
00:07:30,080 --> 00:07:33,840
of such objects and to give a bit of

217
00:07:32,800 --> 00:07:37,840
context between

218
00:07:33,840 --> 00:07:40,479
before explaining how we do that um just

219
00:07:37,840 --> 00:07:42,239
recall that the so-called ideal lattices

220
00:07:40,479 --> 00:07:44,719
and so-called module lattices are just

221
00:07:42,240 --> 00:07:46,400
particular form of algebraic lattices

222
00:07:44,720 --> 00:07:48,639
algebraic lattice concept

223
00:07:46,400 --> 00:07:49,758
is encompassing anything which is

224
00:07:48,639 --> 00:07:51,919
appearing in

225
00:07:49,759 --> 00:07:52,960
the field of lattice-based cryptography

226
00:07:51,919 --> 00:07:54,639
in particular

227
00:07:52,960 --> 00:07:57,198
exploiting the specific algebraic

228
00:07:54,639 --> 00:07:57,680
structure of such lattices enables to

229
00:07:57,199 --> 00:07:59,199
design

230
00:07:57,680 --> 00:08:01,199
more compact and more efficient

231
00:07:59,199 --> 00:08:01,599
cryptographic primitives in particular

232
00:08:01,199 --> 00:08:04,400
it's

233
00:08:01,599 --> 00:08:06,240
no surprise then that many lattice-based

234
00:08:04,400 --> 00:08:08,960
candidates of the nist competition

235
00:08:06,240 --> 00:08:10,240
are relying on either idea lattices or

236
00:08:08,960 --> 00:08:11,840
module lattices

237
00:08:10,240 --> 00:08:13,680
so being able to have a reduction

238
00:08:11,840 --> 00:08:15,919
procedure for this very

239
00:08:13,680 --> 00:08:17,599
particular kind of lattices is of the

240
00:08:15,919 --> 00:08:21,198
utmost interest for

241
00:08:17,599 --> 00:08:24,479
uh the security evaluation of uh

242
00:08:21,199 --> 00:08:26,240
post-quantum candidates so

243
00:08:24,479 --> 00:08:27,520
now the question is how do we reduce

244
00:08:26,240 --> 00:08:28,879
these particularities to find short

245
00:08:27,520 --> 00:08:32,718
vectors and be able to

246
00:08:28,879 --> 00:08:36,159
give security estimations for the

247
00:08:32,719 --> 00:08:38,880
premises so a very

248
00:08:36,159 --> 00:08:40,399
simple idea would say okay so if i take

249
00:08:38,880 --> 00:08:41,120
an algebraic lattice basically i can

250
00:08:40,399 --> 00:08:43,440
always

251
00:08:41,120 --> 00:08:44,240
descend the full lattice over the

252
00:08:43,440 --> 00:08:46,560
integer z

253
00:08:44,240 --> 00:08:47,920
and get a bigger lattice a bigger

254
00:08:46,560 --> 00:08:50,239
integral that is

255
00:08:47,920 --> 00:08:51,360
um which has the same geometrical

256
00:08:50,240 --> 00:08:53,600
properties

257
00:08:51,360 --> 00:08:55,600
so this corresponds to completely forget

258
00:08:53,600 --> 00:08:58,240
the algebraic structure

259
00:08:55,600 --> 00:08:59,680
and only keep the metric structure which

260
00:08:58,240 --> 00:09:01,680
is underlying

261
00:08:59,680 --> 00:09:02,800
uh and if you want to reduce that using

262
00:09:01,680 --> 00:09:06,239
ll basically

263
00:09:02,800 --> 00:09:09,599
the resulting algorithm is as fast

264
00:09:06,240 --> 00:09:11,279
as the lll algorithm you will use over

265
00:09:09,600 --> 00:09:13,040
and it gives exponential approximation

266
00:09:11,279 --> 00:09:13,839
factors so their first work in the

267
00:09:13,040 --> 00:09:16,560
direction was

268
00:09:13,839 --> 00:09:18,399
uh done by figure and still in in your

269
00:09:16,560 --> 00:09:20,719
nine

270
00:09:18,399 --> 00:09:22,320
but it's a bit sad because you have a

271
00:09:20,720 --> 00:09:24,560
very structured object

272
00:09:22,320 --> 00:09:26,240
so a module lattice an ideal lattice an

273
00:09:24,560 --> 00:09:28,000
algebraic lattice

274
00:09:26,240 --> 00:09:29,760
but you are completely forgetting all of

275
00:09:28,000 --> 00:09:31,200
the algebraic properties

276
00:09:29,760 --> 00:09:34,080
on the other hand what you could do is

277
00:09:31,200 --> 00:09:35,760
try to mimic the behavior of ll

278
00:09:34,080 --> 00:09:37,440
and to replace all of these rounding

279
00:09:35,760 --> 00:09:40,319
procedures i told you by

280
00:09:37,440 --> 00:09:41,120
directly svp or cvp or records so this

281
00:09:40,320 --> 00:09:44,399
line of work

282
00:09:41,120 --> 00:09:46,480
uh have uh been recently

283
00:09:44,399 --> 00:09:48,000
uh shown that we can find very

284
00:09:46,480 --> 00:09:50,839
interesting reductions

285
00:09:48,000 --> 00:09:54,320
uh in particular by the work of uh

286
00:09:50,839 --> 00:09:56,800
lpsw19 and from ms20

287
00:09:54,320 --> 00:09:59,120
which is presented uh at uh another

288
00:09:56,800 --> 00:10:01,199
venue of this uh same conference

289
00:09:59,120 --> 00:10:02,560
and they prove that we can have a

290
00:10:01,200 --> 00:10:06,079
reduction uh

291
00:10:02,560 --> 00:10:09,599
which will be uh polynomial time uh

292
00:10:06,079 --> 00:10:10,959
but we'll call uh svp oracles or cvp

293
00:10:09,600 --> 00:10:14,079
oracles in some case

294
00:10:10,959 --> 00:10:15,680
to be able to mimic cll algorithm so

295
00:10:14,079 --> 00:10:17,680
we get something which is exponential

296
00:10:15,680 --> 00:10:18,800
time in the field degree because we need

297
00:10:17,680 --> 00:10:21,040
these oracles

298
00:10:18,800 --> 00:10:22,319
but it gives polynomial approximation

299
00:10:21,040 --> 00:10:25,599
factors in the rank

300
00:10:22,320 --> 00:10:27,920
of the lattice and so our goal for today

301
00:10:25,600 --> 00:10:30,320
will be to try to still

302
00:10:27,920 --> 00:10:31,760
be polynomial time and but use the

303
00:10:30,320 --> 00:10:35,040
algebraic structure

304
00:10:31,760 --> 00:10:39,360
to design an ll type reduction

305
00:10:35,040 --> 00:10:42,000
which is not using cvp or svpr records

306
00:10:39,360 --> 00:10:43,680
so let's try to do exactly the same as

307
00:10:42,000 --> 00:10:46,800
we would do for

308
00:10:43,680 --> 00:10:49,439
llm so let's take another a rank

309
00:10:46,800 --> 00:10:50,479
n algebraic lattice and try to uh

310
00:10:49,440 --> 00:10:52,959
emulate the

311
00:10:50,480 --> 00:10:54,240
behavioral value so first thing we're

312
00:10:52,959 --> 00:10:55,839
going to do is to do the qr

313
00:10:54,240 --> 00:10:56,560
decomposition it will be exactly the

314
00:10:55,839 --> 00:10:59,200
same

315
00:10:56,560 --> 00:11:00,479
as for the cura decompression over the

316
00:10:59,200 --> 00:11:02,800
integers

317
00:11:00,480 --> 00:11:03,760
then we do this size reduction procedure

318
00:11:02,800 --> 00:11:07,040
and

319
00:11:03,760 --> 00:11:08,319
here it's not integral rounding we need

320
00:11:07,040 --> 00:11:10,000
to be

321
00:11:08,320 --> 00:11:12,320
a bit more precise because we are

322
00:11:10,000 --> 00:11:13,360
manipulating actually quotients of

323
00:11:12,320 --> 00:11:16,000
polynomials

324
00:11:13,360 --> 00:11:16,720
but okay let's take the simplest thing

325
00:11:16,000 --> 00:11:19,279
we can do

326
00:11:16,720 --> 00:11:21,600
and do coefficient-wise rounding okay

327
00:11:19,279 --> 00:11:23,279
that's dumb but it will surfaces

328
00:11:21,600 --> 00:11:25,279
here we have to introduce a very

329
00:11:23,279 --> 00:11:28,720
specific trick which is

330
00:11:25,279 --> 00:11:29,360
the unit rounding in short when you are

331
00:11:28,720 --> 00:11:32,800
dealing

332
00:11:29,360 --> 00:11:34,880
with number fees you have a plethoric

333
00:11:32,800 --> 00:11:37,040
number of so-called units which are

334
00:11:34,880 --> 00:11:40,720
elements of algebraic num1

335
00:11:37,040 --> 00:11:43,920
which acts on the way the embeddings

336
00:11:40,720 --> 00:11:44,720
of elements are balanced and so here we

337
00:11:43,920 --> 00:11:47,760
need some

338
00:11:44,720 --> 00:11:48,880
very fine tuning of the balancing of the

339
00:11:47,760 --> 00:11:52,800
embeddings to

340
00:11:48,880 --> 00:11:54,880
ensure that our reduction will be fast

341
00:11:52,800 --> 00:11:57,519
and then we use exactly the same design

342
00:11:54,880 --> 00:11:58,079
as ll so we are reducing the reduction

343
00:11:57,519 --> 00:12:00,160
of

344
00:11:58,079 --> 00:12:02,800
a wrong and lattice to the resolution of

345
00:12:00,160 --> 00:12:04,880
multiple wrong to projected subletters

346
00:12:02,800 --> 00:12:06,079
actually you can do it in a parallel way

347
00:12:04,880 --> 00:12:07,279
and this is what we use for the

348
00:12:06,079 --> 00:12:11,120
implementation but uh

349
00:12:07,279 --> 00:12:12,880
i will uh going back to that layer

350
00:12:11,120 --> 00:12:14,800
and then the question is how we reduce

351
00:12:12,880 --> 00:12:17,200
this round two projected sub lattices so

352
00:12:14,800 --> 00:12:20,560
if the base field is already z

353
00:12:17,200 --> 00:12:22,720
or q then okay we know how to do it

354
00:12:20,560 --> 00:12:24,479
we just use gauss or even a faster

355
00:12:22,720 --> 00:12:27,760
algorithm like schoneg's algorithm

356
00:12:24,480 --> 00:12:30,000
but if the answer is no what we can do

357
00:12:27,760 --> 00:12:31,760
is instead of calling us svp oracle

358
00:12:30,000 --> 00:12:34,000
there is to descend

359
00:12:31,760 --> 00:12:35,279
this wrong two projected sub lattice

360
00:12:34,000 --> 00:12:38,480
onto the

361
00:12:35,279 --> 00:12:39,439
subfield which is just under the field

362
00:12:38,480 --> 00:12:41,600
we're working

363
00:12:39,440 --> 00:12:43,839
and then it will mean that we need to

364
00:12:41,600 --> 00:12:46,320
reduce another

365
00:12:43,839 --> 00:12:48,959
full rank lattice of big dimension and

366
00:12:46,320 --> 00:12:51,200
then we do that recursively

367
00:12:48,959 --> 00:12:52,719
and once this reduction is done what we

368
00:12:51,200 --> 00:12:55,120
get from this reduction

369
00:12:52,720 --> 00:12:56,079
is a short vector and this short vector

370
00:12:55,120 --> 00:12:59,200
need to be

371
00:12:56,079 --> 00:13:01,439
lifted up to uh the upper field

372
00:12:59,200 --> 00:13:02,560
and we can do that using some kind of

373
00:13:01,440 --> 00:13:05,600
generalization

374
00:13:02,560 --> 00:13:07,920
of the euclid algorithm

375
00:13:05,600 --> 00:13:09,839
and then we do exactly the same as we

376
00:13:07,920 --> 00:13:12,719
would do

377
00:13:09,839 --> 00:13:14,720
for the original ll and cycle until the

378
00:13:12,720 --> 00:13:18,720
base is reduced

379
00:13:14,720 --> 00:13:19,440
so here i just put it maybe the two main

380
00:13:18,720 --> 00:13:20,639
differences

381
00:13:19,440 --> 00:13:22,800
except of course this recursive

382
00:13:20,639 --> 00:13:26,399
structure with the

383
00:13:22,800 --> 00:13:28,160
original ll algorithm once comes from

384
00:13:26,399 --> 00:13:29,440
this unique rounding which is necessary

385
00:13:28,160 --> 00:13:31,439
to ensure polynomial time

386
00:13:29,440 --> 00:13:32,880
and one is this lift which absolutely

387
00:13:31,440 --> 00:13:37,279
doesn't exist

388
00:13:32,880 --> 00:13:40,000
and is not needed in the

389
00:13:37,279 --> 00:13:40,000
inter-reduction

390
00:13:40,720 --> 00:13:45,839
and then you can have you can optimize

391
00:13:43,519 --> 00:13:48,000
stuff in particular in this

392
00:13:45,839 --> 00:13:49,600
queue in this qr decomposition and size

393
00:13:48,000 --> 00:13:51,519
reduction sub procedure

394
00:13:49,600 --> 00:13:52,959
using simplex structure so this will be

395
00:13:51,519 --> 00:13:55,199
the final part of the talk

396
00:13:52,959 --> 00:13:56,479
but the idea here just quick spoiler is

397
00:13:55,199 --> 00:13:59,920
that you can

398
00:13:56,480 --> 00:14:04,240
halve the computation time of

399
00:13:59,920 --> 00:14:06,479
this wall part in yellow

400
00:14:04,240 --> 00:14:09,120
so just to give you another way of the

401
00:14:06,480 --> 00:14:11,519
algorithm under the view

402
00:14:09,120 --> 00:14:12,480
here i take a tower of number field so

403
00:14:11,519 --> 00:14:15,760
big field

404
00:14:12,480 --> 00:14:16,639
kh which and a suitable torah which is

405
00:14:15,760 --> 00:14:19,439
just under

406
00:14:16,639 --> 00:14:20,959
and suppose we want to reduce uh wrong d

407
00:14:19,440 --> 00:14:22,720
lattice over kh

408
00:14:20,959 --> 00:14:24,880
so as i said what we're going to do is

409
00:14:22,720 --> 00:14:26,800
to call the reduction of

410
00:14:24,880 --> 00:14:28,480
multiple instances of projected sub

411
00:14:26,800 --> 00:14:30,719
lattices of

412
00:14:28,480 --> 00:14:32,399
round two and where what we are going to

413
00:14:30,720 --> 00:14:34,800
do is to descend

414
00:14:32,399 --> 00:14:37,040
this sub lattice so we are descending it

415
00:14:34,800 --> 00:14:39,920
over the subfield which is right under

416
00:14:37,040 --> 00:14:41,040
so we get some new lattices and what

417
00:14:39,920 --> 00:14:44,240
we're going to do is

418
00:14:41,040 --> 00:14:47,199
again call the reduction to reduce

419
00:14:44,240 --> 00:14:49,760
the problem to solving uh the reduction

420
00:14:47,199 --> 00:14:51,279
problem for round two sublattices

421
00:14:49,760 --> 00:14:53,760
and we do that again and again again

422
00:14:51,279 --> 00:14:55,839
until we reach z and when

423
00:14:53,760 --> 00:14:57,199
z is reached we can use schneger's

424
00:14:55,839 --> 00:15:00,399
algorithm to

425
00:14:57,199 --> 00:15:02,639
completely reduce this wrong two vectors

426
00:15:00,399 --> 00:15:04,560
so we find the short vector v we

427
00:15:02,639 --> 00:15:06,880
complete it in every two spaces

428
00:15:04,560 --> 00:15:08,800
and then we plug that back and it will

429
00:15:06,880 --> 00:15:12,160
yield the short vector of this

430
00:15:08,800 --> 00:15:14,880
final lattice that we will lift

431
00:15:12,160 --> 00:15:16,800
using this uh euclid euclid generation

432
00:15:14,880 --> 00:15:18,880
of euclid procedure

433
00:15:16,800 --> 00:15:21,040
and we continue that we go up and up and

434
00:15:18,880 --> 00:15:23,839
up and at one point we will be able to

435
00:15:21,040 --> 00:15:25,519
have fully reduced the wrong two

436
00:15:23,839 --> 00:15:26,320
projected sub lattices appearing in the

437
00:15:25,519 --> 00:15:29,680
reduction

438
00:15:26,320 --> 00:15:31,600
so this is the basic idea on on how this

439
00:15:29,680 --> 00:15:34,959
recursive strategy over the tower of

440
00:15:31,600 --> 00:15:36,880
number fields is is working

441
00:15:34,959 --> 00:15:38,000
so now a bit of heuristic complexity

442
00:15:36,880 --> 00:15:39,600
because uh

443
00:15:38,000 --> 00:15:41,839
in all of this reduction particularly on

444
00:15:39,600 --> 00:15:44,000
the behavior of this lifting part

445
00:15:41,839 --> 00:15:44,959
uh we couldn't prove any improve

446
00:15:44,000 --> 00:15:48,079
everything so

447
00:15:44,959 --> 00:15:49,518
we rely on some mild heuristic uh

448
00:15:48,079 --> 00:15:51,120
if you take a sufficiently smooth

449
00:15:49,519 --> 00:15:53,759
integer the complexity of

450
00:15:51,120 --> 00:15:56,480
this reduced procedure for rank two

451
00:15:53,759 --> 00:15:59,519
modules over cycloatomic fields

452
00:15:56,480 --> 00:16:03,680
where your input is represented as a as

453
00:15:59,519 --> 00:16:07,759
a matrix m with a bit size b

454
00:16:03,680 --> 00:16:10,880
is heuristically uh o soft of n square b

455
00:16:07,759 --> 00:16:13,040
which is way faster than what uh

456
00:16:10,880 --> 00:16:14,160
well what a classical algorithm ln

457
00:16:13,040 --> 00:16:16,959
algorithm would do

458
00:16:14,160 --> 00:16:18,399
on a lattice of the same size in

459
00:16:16,959 --> 00:16:20,319
particular

460
00:16:18,399 --> 00:16:23,279
we decrease the dependency which has in

461
00:16:20,320 --> 00:16:26,880
enforce to something in n2

462
00:16:23,279 --> 00:16:28,639
uh there is a slight uh slight thing to

463
00:16:26,880 --> 00:16:30,160
to notice is that

464
00:16:28,639 --> 00:16:31,759
we are slightly losing on the

465
00:16:30,160 --> 00:16:35,040
approximation factor

466
00:16:31,759 --> 00:16:37,199
actually uh lll is retrieving uh

467
00:16:35,040 --> 00:16:39,120
is returning vectors which are within an

468
00:16:37,199 --> 00:16:40,639
approximation factor in two to the n

469
00:16:39,120 --> 00:16:43,440
and here we get something which is in

470
00:16:40,639 --> 00:16:45,279
two to the software and we have a slight

471
00:16:43,440 --> 00:16:46,959
loss in the approximation factor but in

472
00:16:45,279 --> 00:16:50,079
comparison we're

473
00:16:46,959 --> 00:16:52,479
much faster so now let's see how

474
00:16:50,079 --> 00:16:54,959
we can improve the complexity of the

475
00:16:52,480 --> 00:16:57,440
algorithm using simplex symmetries

476
00:16:54,959 --> 00:16:59,040
so daily would be to have the time of

477
00:16:57,440 --> 00:17:00,639
this size reduction part that i said and

478
00:16:59,040 --> 00:17:02,959
this can be seen as the generation of

479
00:17:00,639 --> 00:17:04,640
the work of gamma gargame and ingredient

480
00:17:02,959 --> 00:17:07,280
o6

481
00:17:04,640 --> 00:17:08,640
so first of all let's draw a bit of a

482
00:17:07,280 --> 00:17:10,879
table between differences between the

483
00:17:08,640 --> 00:17:12,959
cleaning space in simplicity space

484
00:17:10,880 --> 00:17:15,199
so on a construction you can space you

485
00:17:12,959 --> 00:17:15,919
take a real vector space and you endure

486
00:17:15,199 --> 00:17:17,679
it

487
00:17:15,919 --> 00:17:19,120
with a symmetric bilinear form on the

488
00:17:17,679 --> 00:17:21,120
other hand for a simplitic space you can

489
00:17:19,119 --> 00:17:22,958
do it with an antisymmetric bilinear

490
00:17:21,119 --> 00:17:26,319
form let's say omega

491
00:17:22,959 --> 00:17:28,160
and uh the subgroup of linear

492
00:17:26,319 --> 00:17:30,240
transformations that will preserve

493
00:17:28,160 --> 00:17:31,679
the uh symmetrical enough form in the

494
00:17:30,240 --> 00:17:32,000
case of the euclidean space is called

495
00:17:31,679 --> 00:17:35,600
the

496
00:17:32,000 --> 00:17:36,880
orthogonal group whereas the same group

497
00:17:35,600 --> 00:17:38,399
the transformation groups that will

498
00:17:36,880 --> 00:17:39,600
preserve the simplicity formula called

499
00:17:38,400 --> 00:17:42,400
the simplex group

500
00:17:39,600 --> 00:17:43,918
associated to the form and we have a

501
00:17:42,400 --> 00:17:47,200
notion of

502
00:17:43,919 --> 00:17:48,960
nice and congenial basis for both of

503
00:17:47,200 --> 00:17:50,640
these spaces for euclidean spaces it's

504
00:17:48,960 --> 00:17:53,280
corresponds to orthonormal

505
00:17:50,640 --> 00:17:54,000
bases which are basically the basis for

506
00:17:53,280 --> 00:17:57,120
which the

507
00:17:54,000 --> 00:18:00,480
uh the inner product uh as

508
00:17:57,120 --> 00:18:03,520
as matrix the identity matrix and for

509
00:18:00,480 --> 00:18:06,799
sympathetic spaces the form

510
00:18:03,520 --> 00:18:08,799
omega as for for arts form this matrix

511
00:18:06,799 --> 00:18:09,600
minus identity identity in reverse

512
00:18:08,799 --> 00:18:12,720
diagonal

513
00:18:09,600 --> 00:18:15,199
and this is called a darbu base

514
00:18:12,720 --> 00:18:15,760
and why is it useful it's because like

515
00:18:15,200 --> 00:18:18,520
if you

516
00:18:15,760 --> 00:18:21,120
think of the size reduction as a

517
00:18:18,520 --> 00:18:22,879
discretization of the orthogonalization

518
00:18:21,120 --> 00:18:26,719
process

519
00:18:22,880 --> 00:18:29,919
then you can adapt the size reduction

520
00:18:26,720 --> 00:18:32,960
to work as a discretization of the darbu

521
00:18:29,919 --> 00:18:34,559
process and what happens is that

522
00:18:32,960 --> 00:18:36,320
for instance if you want to set reduce a

523
00:18:34,559 --> 00:18:37,440
basis what you do is start with the

524
00:18:36,320 --> 00:18:40,799
first vector

525
00:18:37,440 --> 00:18:42,960
and then use it to orthogonalize the

526
00:18:40,799 --> 00:18:46,240
second vector and do it for the third

527
00:18:42,960 --> 00:18:48,240
the fourth and so on and the interesting

528
00:18:46,240 --> 00:18:49,120
idea here that for double bass is what

529
00:18:48,240 --> 00:18:51,840
you can do

530
00:18:49,120 --> 00:18:53,439
is you start with the first vector and

531
00:18:51,840 --> 00:18:56,639
you use it to reduce

532
00:18:53,440 --> 00:18:59,120
the you use it to reduce the second one

533
00:18:56,640 --> 00:19:00,080
but and this is because of the simplex

534
00:18:59,120 --> 00:19:02,159
symmetry

535
00:19:00,080 --> 00:19:04,639
what i learned is that the knowledge of

536
00:19:02,160 --> 00:19:06,080
this second vector

537
00:19:04,640 --> 00:19:08,799
the reducedness of the second vector

538
00:19:06,080 --> 00:19:11,039
also allows you to for free reduce

539
00:19:08,799 --> 00:19:12,799
the penultimate vector and then you can

540
00:19:11,039 --> 00:19:13,120
do again for the third vector using the

541
00:19:12,799 --> 00:19:15,840
two

542
00:19:13,120 --> 00:19:16,639
first one you can uh orthogonalize it in

543
00:19:15,840 --> 00:19:21,120
some sense

544
00:19:16,640 --> 00:19:21,120
and for three you get the uh

545
00:19:21,200 --> 00:19:25,520
the third one starting from the

546
00:19:23,200 --> 00:19:27,520
beginning from the end

547
00:19:25,520 --> 00:19:28,559
and you can do that over and over until

548
00:19:27,520 --> 00:19:31,760
you reach actually

549
00:19:28,559 --> 00:19:34,879
the middle of the basis so for the cost

550
00:19:31,760 --> 00:19:35,600
of orthogonalizing only half of the

551
00:19:34,880 --> 00:19:36,960
bases

552
00:19:35,600 --> 00:19:39,520
you get for free the full art

553
00:19:36,960 --> 00:19:42,799
organization of the double bass

554
00:19:39,520 --> 00:19:45,360
using simplex symmetries

555
00:19:42,799 --> 00:19:48,240
the thing is any wrong two lattice is

556
00:19:45,360 --> 00:19:50,000
naturally symplectic up to scaling the

557
00:19:48,240 --> 00:19:52,080
form you are taking to consider that is

558
00:19:50,000 --> 00:19:53,440
just a determinant form

559
00:19:52,080 --> 00:19:55,280
and in particular any wrong two

560
00:19:53,440 --> 00:19:56,160
algebraic lattice becomes naturally

561
00:19:55,280 --> 00:19:59,120
symplectic

562
00:19:56,160 --> 00:20:01,039
for a suitable form what we would like

563
00:19:59,120 --> 00:20:03,199
to do then is to create simplex symmetry

564
00:20:01,039 --> 00:20:04,640
at each recursive level of the recursion

565
00:20:03,200 --> 00:20:05,520
tree of the algorithm i presented

566
00:20:04,640 --> 00:20:07,200
earlier

567
00:20:05,520 --> 00:20:08,960
and this means that we need to construct

568
00:20:07,200 --> 00:20:09,840
a full simplex structure which will be

569
00:20:08,960 --> 00:20:12,880
compatible

570
00:20:09,840 --> 00:20:15,120
with the descent and using

571
00:20:12,880 --> 00:20:16,400
all of this technique together basically

572
00:20:15,120 --> 00:20:19,039
you can halve

573
00:20:16,400 --> 00:20:20,159
the reduction time at each level of the

574
00:20:19,039 --> 00:20:22,480
recursion tree

575
00:20:20,159 --> 00:20:23,600
and so again a polynomial factor on the

576
00:20:22,480 --> 00:20:25,840
overall complexity

577
00:20:23,600 --> 00:20:28,320
so heuristically we can get an improved

578
00:20:25,840 --> 00:20:31,520
complexity using this sympathetic trick

579
00:20:28,320 --> 00:20:33,520
and the overall complexity for

580
00:20:31,520 --> 00:20:35,440
modulus from two other cycloatomic

581
00:20:33,520 --> 00:20:39,440
fields will be something

582
00:20:35,440 --> 00:20:42,720
in or soft off and two minus something

583
00:20:39,440 --> 00:20:44,240
b b steals a bit size and this uh

584
00:20:42,720 --> 00:20:45,840
minus something is something which

585
00:20:44,240 --> 00:20:48,640
depends on

586
00:20:45,840 --> 00:20:49,360
the field you are considering in for

587
00:20:48,640 --> 00:20:52,000
instance for

588
00:20:49,360 --> 00:20:53,678
a power of two cycloatomic fields you

589
00:20:52,000 --> 00:20:56,880
will get something which is in

590
00:20:53,679 --> 00:21:00,320
n um log in base

591
00:20:56,880 --> 00:21:03,520
2 of 3 which is

592
00:21:00,320 --> 00:21:06,960
better than n square b which is

593
00:21:03,520 --> 00:21:08,960
the uh estimate you can get from uh

594
00:21:06,960 --> 00:21:10,480
the number of swap when you're analyzing

595
00:21:08,960 --> 00:21:12,480
your algorithm with

596
00:21:10,480 --> 00:21:14,640
the potential method so this is very

597
00:21:12,480 --> 00:21:17,360
interesting because using this

598
00:21:14,640 --> 00:21:17,840
uh this sympathetic technique allows to

599
00:21:17,360 --> 00:21:19,840
beat

600
00:21:17,840 --> 00:21:22,000
actually the number of swap you could

601
00:21:19,840 --> 00:21:23,439
think which is required by the potential

602
00:21:22,000 --> 00:21:25,760
analysis

603
00:21:23,440 --> 00:21:26,640
uh and all in all you get a vector which

604
00:21:25,760 --> 00:21:28,799
is uh

605
00:21:26,640 --> 00:21:31,120
within approximation factor two to this

606
00:21:28,799 --> 00:21:34,000
software of n

607
00:21:31,120 --> 00:21:34,959
times the normalized coefficient in

608
00:21:34,000 --> 00:21:38,159
practice

609
00:21:34,960 --> 00:21:39,840
and this is implemented with the gp

610
00:21:38,159 --> 00:21:41,919
language

611
00:21:39,840 --> 00:21:44,000
this technique allows to reduce ggs

612
00:21:41,919 --> 00:21:46,080
light lattices in a dimension

613
00:21:44,000 --> 00:21:48,480
two to the eleven in four days where

614
00:21:46,080 --> 00:21:51,760
fpll would take

615
00:21:48,480 --> 00:21:55,200
up to uh estimation uh

616
00:21:51,760 --> 00:21:56,720
40 a hundred years

617
00:21:55,200 --> 00:21:59,520
which is an improvement of something

618
00:21:56,720 --> 00:22:02,799
like four millions

619
00:21:59,520 --> 00:22:03,280
and for the uh we were we were also able

620
00:22:02,799 --> 00:22:05,440
to

621
00:22:03,280 --> 00:22:06,879
uh reconstruct the gentry low algorithm

622
00:22:05,440 --> 00:22:11,520
and use it in dimension

623
00:22:06,880 --> 00:22:13,120
uh 1024 in 100 hour where we were fpl

624
00:22:11,520 --> 00:22:14,158
for the same kind of lattices would have

625
00:22:13,120 --> 00:22:16,959
take let's say

626
00:22:14,159 --> 00:22:19,440
10 years which is a very huge

627
00:22:16,960 --> 00:22:22,000
improvement

628
00:22:19,440 --> 00:22:23,760
so thank you for your attention and i'm

629
00:22:22,000 --> 00:22:27,840
happy to answer the question

630
00:22:23,760 --> 00:22:27,840
in the corresponding question session

