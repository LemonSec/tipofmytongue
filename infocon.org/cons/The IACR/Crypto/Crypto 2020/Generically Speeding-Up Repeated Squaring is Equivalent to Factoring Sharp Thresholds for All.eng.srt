1
00:00:00,880 --> 00:00:04,799
hi i'm lior and i will talk about why

2
00:00:03,280 --> 00:00:07,119
generically speeding gap repeated

3
00:00:04,799 --> 00:00:08,960
querying is equivalent to factoring

4
00:00:07,120 --> 00:00:10,639
i will do so by presenting sharp

5
00:00:08,960 --> 00:00:11,840
thresholds for all generic ring delay

6
00:00:10,639 --> 00:00:15,040
functions

7
00:00:11,840 --> 00:00:17,119
this is joint work with gil segev

8
00:00:15,040 --> 00:00:18,880
okay so let's start by reviewing what

9
00:00:17,119 --> 00:00:20,720
exactly are delay functions

10
00:00:18,880 --> 00:00:22,160
informally a cryptographic delay

11
00:00:20,720 --> 00:00:23,599
function is a function which is

12
00:00:22,160 --> 00:00:25,279
efficiently computable

13
00:00:23,600 --> 00:00:28,000
but only in a manner which is inherently

14
00:00:25,279 --> 00:00:29,920
sequential concretely a delay function

15
00:00:28,000 --> 00:00:31,679
takes an additional delay parameter

16
00:00:29,920 --> 00:00:33,200
which specifies how long it should take

17
00:00:31,679 --> 00:00:35,519
to compute the function

18
00:00:33,200 --> 00:00:36,559
for a delay parameter t the function

19
00:00:35,520 --> 00:00:38,960
should be computable

20
00:00:36,559 --> 00:00:40,559
in time polynomial in t however it

21
00:00:38,960 --> 00:00:42,640
should not be possible to evaluate the

22
00:00:40,559 --> 00:00:45,199
function on a randomly chosen input

23
00:00:42,640 --> 00:00:46,879
in time less than t even if we allow for

24
00:00:45,200 --> 00:00:50,079
a preprocessing stage and for a

25
00:00:46,879 --> 00:00:52,000
polynomial number of parallel processors

26
00:00:50,079 --> 00:00:54,000
one reason for why delay functions are

27
00:00:52,000 --> 00:00:55,920
interesting is that they serve as a

28
00:00:54,000 --> 00:00:57,520
building block for other very useful

29
00:00:55,920 --> 00:00:59,520
cryptographic primitives

30
00:00:57,520 --> 00:01:01,520
a prominent example is that of time lock

31
00:00:59,520 --> 00:01:03,359
puzzles introduced by the vestramillion

32
00:01:01,520 --> 00:01:05,600
wagner in 96.

33
00:01:03,359 --> 00:01:06,720
in our terminology a time lock puzzle is

34
00:01:05,600 --> 00:01:08,798
a delay function

35
00:01:06,720 --> 00:01:09,840
which allows for fast sampling of input

36
00:01:08,799 --> 00:01:11,280
output pairs

37
00:01:09,840 --> 00:01:13,520
whereby fast we mean in time poly

38
00:01:11,280 --> 00:01:15,759
logarithmic in the delay parameter t

39
00:01:13,520 --> 00:01:18,158
another example is the more recent

40
00:01:15,759 --> 00:01:21,280
notion of verifiable delay functions

41
00:01:18,159 --> 00:01:22,799
formalized by vonetal in 2018 a

42
00:01:21,280 --> 00:01:25,840
verifiable delay function

43
00:01:22,799 --> 00:01:27,680
or a vdf for short is a delay function

44
00:01:25,840 --> 00:01:29,040
which allows for fast verification of

45
00:01:27,680 --> 00:01:30,720
input output pairs

46
00:01:29,040 --> 00:01:32,640
possibly giving an additional short

47
00:01:30,720 --> 00:01:34,720
proof of their validity

48
00:01:32,640 --> 00:01:36,560
these two refinements of delay functions

49
00:01:34,720 --> 00:01:38,960
time lock puzzles and vdfs

50
00:01:36,560 --> 00:01:40,960
have many very useful applications

51
00:01:38,960 --> 00:01:43,919
examples include time lock encryption

52
00:01:40,960 --> 00:01:46,320
sealed deductions for contract signing

53
00:01:43,920 --> 00:01:48,240
publicly verifiable randomness beacons

54
00:01:46,320 --> 00:01:50,079
resource efficient blockchains and

55
00:01:48,240 --> 00:01:51,759
computational timestamping

56
00:01:50,079 --> 00:01:54,079
and many more applications exist for

57
00:01:51,759 --> 00:01:55,840
these useful primitives

58
00:01:54,079 --> 00:01:57,839
perhaps the simplest example of a delay

59
00:01:55,840 --> 00:01:58,799
function is the iterated hashing

60
00:01:57,840 --> 00:02:00,640
function

61
00:01:58,799 --> 00:02:02,399
this function is obtained by iteratively

62
00:02:00,640 --> 00:02:04,880
applying a cryptographic hash function

63
00:02:02,399 --> 00:02:06,399
such as sha onto the input a main

64
00:02:04,880 --> 00:02:07,360
advantage of the iterated hashing

65
00:02:06,399 --> 00:02:09,038
function

66
00:02:07,360 --> 00:02:11,920
is that it enjoys a formal security

67
00:02:09,038 --> 00:02:13,760
argument in an idealized model

68
00:02:11,920 --> 00:02:15,280
concretely its sequentiality can be

69
00:02:13,760 --> 00:02:17,359
proven unconditionally

70
00:02:15,280 --> 00:02:18,959
when the hash function age is modeled as

71
00:02:17,360 --> 00:02:20,560
a random oracle

72
00:02:18,959 --> 00:02:22,480
the downside of this delay function

73
00:02:20,560 --> 00:02:23,520
however is that it seems to be

74
00:02:22,480 --> 00:02:25,679
understructured

75
00:02:23,520 --> 00:02:27,120
to enable extensions to timelock puzzles

76
00:02:25,680 --> 00:02:28,480
or to vdfs

77
00:02:27,120 --> 00:02:30,400
it should be mentioned that

78
00:02:28,480 --> 00:02:32,238
asymptotically speaking it has been

79
00:02:30,400 --> 00:02:35,040
suggested to use extremely verifiable

80
00:02:32,239 --> 00:02:37,360
computation to enable fast verification

81
00:02:35,040 --> 00:02:38,560
but at least at the moment this approach

82
00:02:37,360 --> 00:02:42,080
doesn't seem to enable

83
00:02:38,560 --> 00:02:44,160
any concretely efficient instantiations

84
00:02:42,080 --> 00:02:46,160
given the fact that iterated hashing

85
00:02:44,160 --> 00:02:47,920
seems to be under structured to enable

86
00:02:46,160 --> 00:02:48,959
extensions to timelock puzzles and to

87
00:02:47,920 --> 00:02:50,399
vdfs

88
00:02:48,959 --> 00:02:52,319
we wish to have more structured

89
00:02:50,400 --> 00:02:55,200
constructions of delay functions

90
00:02:52,319 --> 00:02:56,799
which may allow for such extensions the

91
00:02:55,200 --> 00:02:58,079
main candidate that we currently have

92
00:02:56,800 --> 00:03:00,000
for a delay function

93
00:02:58,080 --> 00:03:02,080
that offers such structure is the

94
00:03:00,000 --> 00:03:04,000
repeated squaring function

95
00:03:02,080 --> 00:03:05,519
this function is defined with respect to

96
00:03:04,000 --> 00:03:07,360
a group g

97
00:03:05,519 --> 00:03:09,440
given the delay parameter t and the

98
00:03:07,360 --> 00:03:11,440
group element x as input

99
00:03:09,440 --> 00:03:13,840
the output of the function is x raised

100
00:03:11,440 --> 00:03:15,760
to the power of two to the t

101
00:03:13,840 --> 00:03:17,519
note that if the group operation is

102
00:03:15,760 --> 00:03:18,000
computable in time polynomial in the

103
00:03:17,519 --> 00:03:20,400
security

104
00:03:18,000 --> 00:03:22,000
parameter lambda then this function is

105
00:03:20,400 --> 00:03:23,840
indeed computable in time t

106
00:03:22,000 --> 00:03:25,120
times poly lambda by t repeated

107
00:03:23,840 --> 00:03:27,280
queryings

108
00:03:25,120 --> 00:03:29,200
the repeated querying function indeed

109
00:03:27,280 --> 00:03:32,000
offers the sufficient structure needed

110
00:03:29,200 --> 00:03:33,920
for time lock puzzles and for vdfs

111
00:03:32,000 --> 00:03:35,040
it was actually first proposed by virtua

112
00:03:33,920 --> 00:03:37,518
miriam wagner

113
00:03:35,040 --> 00:03:39,280
as the basis for their timelock puzzle

114
00:03:37,519 --> 00:03:41,120
and it was recently and elegantly

115
00:03:39,280 --> 00:03:44,159
augmented with succinct proofs

116
00:03:41,120 --> 00:03:45,599
yielding efficient vdf constructions

117
00:03:44,159 --> 00:03:47,519
the sequentiality of the repeated

118
00:03:45,599 --> 00:03:48,399
squaring function is based on the

119
00:03:47,519 --> 00:03:50,239
assumption

120
00:03:48,400 --> 00:03:52,239
that there are groups in which it is

121
00:03:50,239 --> 00:03:53,760
impossible to significantly speed up the

122
00:03:52,239 --> 00:03:55,599
function's computation

123
00:03:53,760 --> 00:03:57,518
even with preprocessing and with

124
00:03:55,599 --> 00:03:59,280
parallel processors

125
00:03:57,519 --> 00:04:00,640
of course a necessary condition for this

126
00:03:59,280 --> 00:04:03,120
assumption to hold

127
00:04:00,640 --> 00:04:04,720
is that the group's order is unknown the

128
00:04:03,120 --> 00:04:05,920
main candidate that we currently have in

129
00:04:04,720 --> 00:04:08,720
cryptography for such

130
00:04:05,920 --> 00:04:10,238
groups is the family of rsa groups

131
00:04:08,720 --> 00:04:12,400
additional candidates are the class

132
00:04:10,239 --> 00:04:13,760
groups of imaginary quadratic fields

133
00:04:12,400 --> 00:04:15,519
but they are not as well studied

134
00:04:13,760 --> 00:04:17,120
cryptographically

135
00:04:15,519 --> 00:04:18,880
it should be emphasized that the

136
00:04:17,120 --> 00:04:20,399
sequentiality assumption for repeated

137
00:04:18,880 --> 00:04:23,280
querying in rsi groups

138
00:04:20,399 --> 00:04:24,239
is exactly this an assumption and prior

139
00:04:23,280 --> 00:04:26,080
to this work

140
00:04:24,240 --> 00:04:27,759
there was no formal security argument

141
00:04:26,080 --> 00:04:29,440
supporting this assumption

142
00:04:27,759 --> 00:04:31,840
as degrees for the iterated hashing

143
00:04:29,440 --> 00:04:33,120
function so the main question that we

144
00:04:31,840 --> 00:04:35,039
deal with in this work

145
00:04:33,120 --> 00:04:37,199
is can we base the sequentiality of

146
00:04:35,040 --> 00:04:39,759
repeated squaring in rsi groups

147
00:04:37,199 --> 00:04:41,440
on other better established assumptions

148
00:04:39,759 --> 00:04:44,160
such as the factoring assumption

149
00:04:41,440 --> 00:04:46,080
or the rsi assumption our main

150
00:04:44,160 --> 00:04:47,199
contribution is answering this question

151
00:04:46,080 --> 00:04:49,758
in the affirmative

152
00:04:47,199 --> 00:04:51,759
within the generic ring model our

153
00:04:49,759 --> 00:04:53,199
results are actually more general

154
00:04:51,759 --> 00:04:55,040
we put forth the notion of a

155
00:04:53,199 --> 00:04:56,080
sequentiality depth of generic link

156
00:04:55,040 --> 00:04:58,000
functions

157
00:04:56,080 --> 00:05:00,080
and prove that it serves as a sharp

158
00:04:58,000 --> 00:05:02,080
threshold for the number of sequential

159
00:05:00,080 --> 00:05:03,280
ring operations required to compute the

160
00:05:02,080 --> 00:05:06,000
function

161
00:05:03,280 --> 00:05:07,679
concretely our main theorem states that

162
00:05:06,000 --> 00:05:08,880
if factoring is hard in the standard

163
00:05:07,680 --> 00:05:10,720
model

164
00:05:08,880 --> 00:05:12,880
then for any generic link function of

165
00:05:10,720 --> 00:05:15,120
sequentiality depth d

166
00:05:12,880 --> 00:05:16,960
exactly these sequential ring operations

167
00:05:15,120 --> 00:05:18,720
are necessary and sufficient

168
00:05:16,960 --> 00:05:20,000
in order to generically evaluate the

169
00:05:18,720 --> 00:05:22,639
function

170
00:05:20,000 --> 00:05:24,160
that is the function can be generically

171
00:05:22,639 --> 00:05:27,120
evaluated on any input

172
00:05:24,160 --> 00:05:28,320
using d sequential ring operations but

173
00:05:27,120 --> 00:05:30,000
on the other hand

174
00:05:28,320 --> 00:05:32,240
the function cannot be generically

175
00:05:30,000 --> 00:05:34,080
evaluated on a random input

176
00:05:32,240 --> 00:05:36,479
using less than d sequential ring

177
00:05:34,080 --> 00:05:38,400
operations even with the preprocessing

178
00:05:36,479 --> 00:05:40,719
stage and the polynomial number of

179
00:05:38,400 --> 00:05:42,719
parallel processors

180
00:05:40,720 --> 00:05:44,479
since as we will see the repeated

181
00:05:42,720 --> 00:05:45,600
querying function relative to a delay

182
00:05:44,479 --> 00:05:47,680
parameter t

183
00:05:45,600 --> 00:05:50,720
has sequentiality depth which is exactly

184
00:05:47,680 --> 00:05:52,320
t and immediate corollary of our theorem

185
00:05:50,720 --> 00:05:53,840
is a generically speeding up the

186
00:05:52,320 --> 00:05:55,440
repeated querying function

187
00:05:53,840 --> 00:05:57,440
is equivalent to factoring in the

188
00:05:55,440 --> 00:05:59,360
standard model

189
00:05:57,440 --> 00:06:00,880
we also have analogous results for the

190
00:05:59,360 --> 00:06:02,000
pseudorandomness of generic link

191
00:06:00,880 --> 00:06:03,440
functions

192
00:06:02,000 --> 00:06:05,360
based on our new notion of

193
00:06:03,440 --> 00:06:07,039
pseudorandomous depth

194
00:06:05,360 --> 00:06:08,960
for the specific case of repeated

195
00:06:07,039 --> 00:06:10,080
querying the two notions

196
00:06:08,960 --> 00:06:12,479
so the randomness depth and

197
00:06:10,080 --> 00:06:14,560
sequentiality depth coincide

198
00:06:12,479 --> 00:06:16,080
and we in fact show that the output of

199
00:06:14,560 --> 00:06:17,360
the repeated squaring function on a

200
00:06:16,080 --> 00:06:19,199
random input

201
00:06:17,360 --> 00:06:21,280
is pseudorandom for generic ring

202
00:06:19,199 --> 00:06:23,600
algorithms performing less than t

203
00:06:21,280 --> 00:06:25,119
sequential ring operations

204
00:06:23,600 --> 00:06:26,639
the remainder of this talk will follow

205
00:06:25,120 --> 00:06:28,319
this outline

206
00:06:26,639 --> 00:06:30,400
first we will present and discuss the

207
00:06:28,319 --> 00:06:31,919
generic ring model in which we prove our

208
00:06:30,400 --> 00:06:33,840
results

209
00:06:31,919 --> 00:06:35,198
then we will define generic ring delay

210
00:06:33,840 --> 00:06:37,359
functions and the notion of

211
00:06:35,199 --> 00:06:39,039
sequentiality depth

212
00:06:37,360 --> 00:06:40,800
we will then see our main result

213
00:06:39,039 --> 00:06:42,880
establishing a sharp threshold on the

214
00:06:40,800 --> 00:06:45,039
number of sequential ring operations

215
00:06:42,880 --> 00:06:46,240
required to generically evaluate generic

216
00:06:45,039 --> 00:06:48,000
link functions

217
00:06:46,240 --> 00:06:50,720
and finally we will conclude with some

218
00:06:48,000 --> 00:06:52,960
closing remarks and open problems

219
00:06:50,720 --> 00:06:54,000
so let's start by presenting the generic

220
00:06:52,960 --> 00:06:55,840
model

221
00:06:54,000 --> 00:06:58,319
this model was introduced by aguava and

222
00:06:55,840 --> 00:06:59,198
maul and roughly speaking it captures

223
00:06:58,319 --> 00:07:01,280
algorithms

224
00:06:59,199 --> 00:07:02,960
that operate on ring elements but

225
00:07:01,280 --> 00:07:04,559
without exploiting the concrete

226
00:07:02,960 --> 00:07:07,039
representation

227
00:07:04,560 --> 00:07:09,440
in essence this is captured by modern

228
00:07:07,039 --> 00:07:12,080
green operations as oracle queries

229
00:07:09,440 --> 00:07:14,840
and exposing to the algorithm only the

230
00:07:12,080 --> 00:07:17,359
qualities among green elements in the

231
00:07:14,840 --> 00:07:19,520
computation the generic ring model is a

232
00:07:17,360 --> 00:07:21,039
special case of malware's generic model

233
00:07:19,520 --> 00:07:23,359
of computation

234
00:07:21,039 --> 00:07:24,240
and queries within this model are

235
00:07:23,360 --> 00:07:26,479
specified

236
00:07:24,240 --> 00:07:28,479
by pointing to elements previously seen

237
00:07:26,479 --> 00:07:30,159
in the computation

238
00:07:28,479 --> 00:07:32,479
of course not all computations are

239
00:07:30,160 --> 00:07:34,319
generic jaeger and schwenk

240
00:07:32,479 --> 00:07:36,560
proved the generically computing the

241
00:07:34,319 --> 00:07:37,120
jacobi symbols of elements in the ring

242
00:07:36,560 --> 00:07:40,240
zn

243
00:07:37,120 --> 00:07:41,440
of integers module n is as hard as

244
00:07:40,240 --> 00:07:43,199
factoring

245
00:07:41,440 --> 00:07:46,000
even though this can be computed

246
00:07:43,199 --> 00:07:48,080
efficiently in a non-generic manner

247
00:07:46,000 --> 00:07:50,319
nevertheless unlike computing jacobi

248
00:07:48,080 --> 00:07:52,479
symbols the sequentiality of repeated

249
00:07:50,319 --> 00:07:53,599
querying is unbroken generically or

250
00:07:52,479 --> 00:07:55,359
otherwise

251
00:07:53,599 --> 00:07:57,759
and as jager and schwenk themselves

252
00:07:55,360 --> 00:07:59,840
point out the generic ring model still

253
00:07:57,759 --> 00:08:02,560
captures a wide variety of practical

254
00:07:59,840 --> 00:08:04,318
constructions and cryptanalytic attacks

255
00:08:02,560 --> 00:08:05,680
we will revisit this point at the end of

256
00:08:04,319 --> 00:08:07,520
the talk

257
00:08:05,680 --> 00:08:09,599
let's go ahead and define the generic

258
00:08:07,520 --> 00:08:12,000
ring model more formally

259
00:08:09,599 --> 00:08:14,159
a generic computation in this model is

260
00:08:12,000 --> 00:08:14,960
associated with a table b of ring

261
00:08:14,160 --> 00:08:18,080
elements

262
00:08:14,960 --> 00:08:20,080
managed by the oracle this table is

263
00:08:18,080 --> 00:08:22,080
initialized with the additive and the

264
00:08:20,080 --> 00:08:22,719
multiplicative identity elements in the

265
00:08:22,080 --> 00:08:25,520
ring

266
00:08:22,720 --> 00:08:26,560
as its first entries then followed by

267
00:08:25,520 --> 00:08:29,198
the ring elements

268
00:08:26,560 --> 00:08:31,280
which the algorithm receives as input

269
00:08:29,199 --> 00:08:33,599
the generic algorithm can then produce

270
00:08:31,280 --> 00:08:35,439
two types of queries to the oracle

271
00:08:33,599 --> 00:08:36,800
group operation queries and equality

272
00:08:35,440 --> 00:08:39,599
queries

273
00:08:36,799 --> 00:08:41,679
to issue a query the algorithm specifies

274
00:08:39,599 --> 00:08:43,680
the indices of the two elements

275
00:08:41,679 --> 00:08:45,519
that it wishes to compare or to which it

276
00:08:43,679 --> 00:08:46,560
wants to apply one of the four possible

277
00:08:45,519 --> 00:08:48,320
operations

278
00:08:46,560 --> 00:08:49,760
the touring operations and their

279
00:08:48,320 --> 00:08:52,160
inverses

280
00:08:49,760 --> 00:08:53,839
in response to a ring operation query

281
00:08:52,160 --> 00:08:54,560
the oracle computes the result in the

282
00:08:53,839 --> 00:08:56,800
ring

283
00:08:54,560 --> 00:08:58,560
and places it in the next vacant entry

284
00:08:56,800 --> 00:09:00,880
of the table b

285
00:08:58,560 --> 00:09:02,319
in response to any quality query the

286
00:09:00,880 --> 00:09:03,920
oracle simply compares the two

287
00:09:02,320 --> 00:09:06,399
corresponding green elements

288
00:09:03,920 --> 00:09:08,240
and answers accordingly when a generic

289
00:09:06,399 --> 00:09:09,200
algorithm wishes to output a ring

290
00:09:08,240 --> 00:09:10,640
element

291
00:09:09,200 --> 00:09:13,600
it outputs the index of the

292
00:09:10,640 --> 00:09:15,600
corresponding entry of the table b

293
00:09:13,600 --> 00:09:17,760
note that the model naturally extends to

294
00:09:15,600 --> 00:09:19,920
capture parallel computations

295
00:09:17,760 --> 00:09:23,120
by allowing algorithms to issue many

296
00:09:19,920 --> 00:09:24,640
parallel ring operation queries at once

297
00:09:23,120 --> 00:09:26,959
a special case of generic ring

298
00:09:24,640 --> 00:09:29,120
algorithms that we will be interested in

299
00:09:26,959 --> 00:09:31,279
is that of straight line programs or

300
00:09:29,120 --> 00:09:33,279
slps for short

301
00:09:31,279 --> 00:09:34,399
these are deterministic generic link

302
00:09:33,279 --> 00:09:37,519
algorithms

303
00:09:34,399 --> 00:09:39,680
which do not issue any quality queries

304
00:09:37,519 --> 00:09:41,279
each ring element which is computed by a

305
00:09:39,680 --> 00:09:42,719
generic green algorithm

306
00:09:41,279 --> 00:09:45,200
either as an output or as an

307
00:09:42,720 --> 00:09:47,360
intermediate value is obtained from the

308
00:09:45,200 --> 00:09:48,160
input elements by a sequence of ring

309
00:09:47,360 --> 00:09:51,760
operations

310
00:09:48,160 --> 00:09:54,160
and their inverses hence informally

311
00:09:51,760 --> 00:09:56,240
it can be seen as a rational function of

312
00:09:54,160 --> 00:09:58,640
the input elements

313
00:09:56,240 --> 00:10:00,399
more formally to avoid the problem of

314
00:09:58,640 --> 00:10:03,199
division by zero

315
00:10:00,399 --> 00:10:05,040
each such rim element is associated with

316
00:10:03,200 --> 00:10:07,440
a pair of polynomials

317
00:10:05,040 --> 00:10:08,719
where the natural interpretation is that

318
00:10:07,440 --> 00:10:10,320
the first polynomial

319
00:10:08,720 --> 00:10:12,480
is the numerator of the rational

320
00:10:10,320 --> 00:10:14,160
function and the second one is the

321
00:10:12,480 --> 00:10:16,480
denominator

322
00:10:14,160 --> 00:10:18,399
formally each ring element given to the

323
00:10:16,480 --> 00:10:20,320
generic algorithm as input

324
00:10:18,399 --> 00:10:21,760
is associated with a different formal

325
00:10:20,320 --> 00:10:23,839
variable

326
00:10:21,760 --> 00:10:25,760
then the polynomials associated with

327
00:10:23,839 --> 00:10:27,040
ring elements that are computed by the

328
00:10:25,760 --> 00:10:29,839
algorithm

329
00:10:27,040 --> 00:10:31,920
are defined in a recursive manner the

330
00:10:29,839 --> 00:10:33,920
polynomials associated with the result

331
00:10:31,920 --> 00:10:36,079
of a ring operation query

332
00:10:33,920 --> 00:10:37,599
are obtained using standard rational

333
00:10:36,079 --> 00:10:39,359
functions arithmetic

334
00:10:37,600 --> 00:10:41,760
from the two pairs of polynomials

335
00:10:39,360 --> 00:10:44,720
associated with the ring elements

336
00:10:41,760 --> 00:10:47,279
given as arguments to the query you can

337
00:10:44,720 --> 00:10:50,240
see a formal definition on the slide

338
00:10:47,279 --> 00:10:52,640
observe that using this interpretation

339
00:10:50,240 --> 00:10:55,200
the output of a straight line program

340
00:10:52,640 --> 00:10:57,360
can be seen as a fixed rational function

341
00:10:55,200 --> 00:10:59,279
in the input elements

342
00:10:57,360 --> 00:11:01,200
this is in contrast to the general case

343
00:10:59,279 --> 00:11:03,519
of generic ring algorithms

344
00:11:01,200 --> 00:11:05,680
who compute a rational function which

345
00:11:03,519 --> 00:11:07,839
may depend on the randomness

346
00:11:05,680 --> 00:11:10,719
and on the equality pattern among green

347
00:11:07,839 --> 00:11:13,040
elements throughout the computation

348
00:11:10,720 --> 00:11:15,040
a work closely related to ours is that

349
00:11:13,040 --> 00:11:17,120
of agarwal and malwa

350
00:11:15,040 --> 00:11:19,519
they proved the generically computing

351
00:11:17,120 --> 00:11:21,200
roots of random elements in rsi groups

352
00:11:19,519 --> 00:11:23,279
is equivalent to standard model

353
00:11:21,200 --> 00:11:25,360
factoring there are three main

354
00:11:23,279 --> 00:11:27,360
conceptual and technical differences

355
00:11:25,360 --> 00:11:28,399
between our work and that of arga1 and

356
00:11:27,360 --> 00:11:30,800
malwa

357
00:11:28,399 --> 00:11:31,760
first we prove fine-grained threshold

358
00:11:30,800 --> 00:11:33,599
theorems

359
00:11:31,760 --> 00:11:35,040
whereas agarwal and magwell proved an

360
00:11:33,600 --> 00:11:36,880
impossibility result

361
00:11:35,040 --> 00:11:38,959
which holds for all polynomial generic

362
00:11:36,880 --> 00:11:41,680
link algorithms

363
00:11:38,959 --> 00:11:43,119
second our results consider parallel

364
00:11:41,680 --> 00:11:44,959
algorithms

365
00:11:43,120 --> 00:11:46,320
this is of no consequence for improving

366
00:11:44,959 --> 00:11:48,160
lower bounds for the class of all

367
00:11:46,320 --> 00:11:49,839
polyquery algorithms

368
00:11:48,160 --> 00:11:51,839
but makes sense when considering

369
00:11:49,839 --> 00:11:53,279
fine-grained lower bounds as is the case

370
00:11:51,839 --> 00:11:55,320
in our work

371
00:11:53,279 --> 00:11:57,839
finally we also consider a

372
00:11:55,320 --> 00:11:59,079
pseudorandomness-based security notion

373
00:11:57,839 --> 00:12:00,560
in addition to the

374
00:11:59,079 --> 00:12:01,920
unpredictability-flavored security

375
00:12:00,560 --> 00:12:04,239
notion

376
00:12:01,920 --> 00:12:05,599
still as we will later see in order to

377
00:12:04,240 --> 00:12:07,680
prove our results

378
00:12:05,600 --> 00:12:10,399
we rely on a generalization of the main

379
00:12:07,680 --> 00:12:12,560
technical emma of agawan and maul

380
00:12:10,399 --> 00:12:14,639
roughly it states that a polynomial

381
00:12:12,560 --> 00:12:15,518
which has many roots in the ring zn of

382
00:12:14,639 --> 00:12:18,720
integers model

383
00:12:15,519 --> 00:12:21,680
n can be used to factor n we will

384
00:12:18,720 --> 00:12:23,440
present the lemma in more detail shortly

385
00:12:21,680 --> 00:12:25,279
let's move on to discuss generic link

386
00:12:23,440 --> 00:12:26,720
delay functions and the notion of

387
00:12:25,279 --> 00:12:29,439
sequentiality depth

388
00:12:26,720 --> 00:12:31,920
a generic ring delay function df is a

389
00:12:29,440 --> 00:12:34,079
deterministic generic ring algorithm

390
00:12:31,920 --> 00:12:35,439
taking carrying elements as input for

391
00:12:34,079 --> 00:12:37,920
some parameter k

392
00:12:35,440 --> 00:12:39,279
for simplicity we assume here that the

393
00:12:37,920 --> 00:12:42,079
function's output

394
00:12:39,279 --> 00:12:43,439
consists of a single ring element we

395
00:12:42,079 --> 00:12:45,199
also focus here

396
00:12:43,440 --> 00:12:46,639
on the specific case where the ring is

397
00:12:45,200 --> 00:12:49,839
zn where n

398
00:12:46,639 --> 00:12:51,600
is in rsi modulus the sequentiality

399
00:12:49,839 --> 00:12:52,720
guarantee of a generic link delay

400
00:12:51,600 --> 00:12:54,800
function

401
00:12:52,720 --> 00:12:56,560
is defined via the following security

402
00:12:54,800 --> 00:12:59,439
experiment

403
00:12:56,560 --> 00:13:00,239
first a modulus generation algorithm mod

404
00:12:59,440 --> 00:13:02,399
gen

405
00:13:00,240 --> 00:13:04,000
is invoked in order to generate the rsa

406
00:13:02,399 --> 00:13:07,120
group modulus n

407
00:13:04,000 --> 00:13:10,399
then the pre-processing attacker a0

408
00:13:07,120 --> 00:13:12,800
produces some state st and the k-tuple

409
00:13:10,399 --> 00:13:14,720
x of ring elements is chosen uniformly

410
00:13:12,800 --> 00:13:17,519
at random from zn

411
00:13:14,720 --> 00:13:18,000
the online attacker a1 receives the

412
00:13:17,519 --> 00:13:21,200
state

413
00:13:18,000 --> 00:13:23,200
st and the input x and output submarine

414
00:13:21,200 --> 00:13:25,760
element y prime

415
00:13:23,200 --> 00:13:26,800
we say that a0 and a1 win in the

416
00:13:25,760 --> 00:13:29,279
experiment

417
00:13:26,800 --> 00:13:30,880
if this y prime is equal to the true

418
00:13:29,279 --> 00:13:34,480
output y of df on

419
00:13:30,880 --> 00:13:35,200
input x we say that a generic link delay

420
00:13:34,480 --> 00:13:38,560
function

421
00:13:35,200 --> 00:13:39,279
is t sequential if for every pair a0 and

422
00:13:38,560 --> 00:13:42,399
the a1

423
00:13:39,279 --> 00:13:45,120
of generic link algorithms such that a0

424
00:13:42,399 --> 00:13:47,279
makes a polynomial number of queries and

425
00:13:45,120 --> 00:13:49,199
a1 consists of at most a polynomial

426
00:13:47,279 --> 00:13:50,720
number of parallel processors

427
00:13:49,199 --> 00:13:52,399
each of which making it most t

428
00:13:50,720 --> 00:13:55,279
sequential queries

429
00:13:52,399 --> 00:13:56,240
the probability that a0 and a1 win in

430
00:13:55,279 --> 00:13:58,000
the experiment

431
00:13:56,240 --> 00:13:59,680
is negligible in the security parameter

432
00:13:58,000 --> 00:14:01,519
lambda

433
00:13:59,680 --> 00:14:02,800
note that the notion of a generic ring

434
00:14:01,519 --> 00:14:05,279
delay function

435
00:14:02,800 --> 00:14:07,120
can be extended by allowing for explicit

436
00:14:05,279 --> 00:14:08,560
inputs and outputs which are not ring

437
00:14:07,120 --> 00:14:10,560
elements

438
00:14:08,560 --> 00:14:11,920
our results easily extend to such

439
00:14:10,560 --> 00:14:13,680
functions as well

440
00:14:11,920 --> 00:14:16,319
but for simplicity we do not consider

441
00:14:13,680 --> 00:14:18,079
such functions in this talk

442
00:14:16,320 --> 00:14:20,160
we are now ready to present our notion

443
00:14:18,079 --> 00:14:21,920
of sequentiality depth

444
00:14:20,160 --> 00:14:23,839
recall that this notion will serve as a

445
00:14:21,920 --> 00:14:26,240
threshold for the number of sequential

446
00:14:23,839 --> 00:14:28,560
incorporation queries needed in order to

447
00:14:26,240 --> 00:14:30,800
compute a generic ring function

448
00:14:28,560 --> 00:14:32,638
so we natural place to start is the

449
00:14:30,800 --> 00:14:33,279
number of sequential queries needed in

450
00:14:32,639 --> 00:14:35,600
order to

451
00:14:33,279 --> 00:14:36,480
quote unquote trivially evaluate the

452
00:14:35,600 --> 00:14:38,639
function

453
00:14:36,480 --> 00:14:40,320
while taking into account parallelism

454
00:14:38,639 --> 00:14:42,320
and pre-processing

455
00:14:40,320 --> 00:14:44,480
so for example the repeated squaring

456
00:14:42,320 --> 00:14:48,000
function can be trivially evaluated

457
00:14:44,480 --> 00:14:50,240
using tiering operations this function

458
00:14:48,000 --> 00:14:52,639
can be evaluated using t plus two

459
00:14:50,240 --> 00:14:55,680
sequential rounds of ring operations

460
00:14:52,639 --> 00:14:58,160
using four parallel processors

461
00:14:55,680 --> 00:14:59,839
this function can be evaluated using t

462
00:14:58,160 --> 00:15:01,279
plus two sequential queries on two

463
00:14:59,839 --> 00:15:03,279
processors

464
00:15:01,279 --> 00:15:04,720
but there is an equivalent function

465
00:15:03,279 --> 00:15:07,920
which is simply x2

466
00:15:04,720 --> 00:15:09,440
over x3 which can be evaluated using

467
00:15:07,920 --> 00:15:11,279
just one query

468
00:15:09,440 --> 00:15:13,360
so we would like the sequentiality depth

469
00:15:11,279 --> 00:15:16,000
of this function to be 1.

470
00:15:13,360 --> 00:15:16,399
finally consider the function 2 to the t

471
00:15:16,000 --> 00:15:19,839
times

472
00:15:16,399 --> 00:15:20,320
x this function can be evaluated using

473
00:15:19,839 --> 00:15:23,360
log t

474
00:15:20,320 --> 00:15:25,360
plus 1 queries however log 2 of them are

475
00:15:23,360 --> 00:15:26,959
independent of the input x

476
00:15:25,360 --> 00:15:28,800
and can be performed during the

477
00:15:26,959 --> 00:15:30,479
preprocessing stage

478
00:15:28,800 --> 00:15:32,959
so we would like the sequentiality depth

479
00:15:30,480 --> 00:15:35,519
of this function to be just one

480
00:15:32,959 --> 00:15:37,119
so with these examples in mind the idea

481
00:15:35,519 --> 00:15:38,800
is the following

482
00:15:37,120 --> 00:15:40,560
we will say that the generic link

483
00:15:38,800 --> 00:15:43,758
function df

484
00:15:40,560 --> 00:15:45,680
has sequentiality depth d if there is a

485
00:15:43,759 --> 00:15:48,639
generic ring algorithm

486
00:15:45,680 --> 00:15:50,638
which after preprocessing computes a

487
00:15:48,639 --> 00:15:53,759
somehow equivalent function

488
00:15:50,639 --> 00:15:55,600
in exactly the sequential queries we'll

489
00:15:53,759 --> 00:15:57,680
now formally define the sequentiality

490
00:15:55,600 --> 00:15:59,440
depth of straight line functions

491
00:15:57,680 --> 00:16:00,880
the sequentiality depth of a straight

492
00:15:59,440 --> 00:16:04,079
line function df

493
00:16:00,880 --> 00:16:06,079
is defined via the following experiment

494
00:16:04,079 --> 00:16:07,519
the experiment starts off in a similar

495
00:16:06,079 --> 00:16:08,959
manner to the one that we saw a few

496
00:16:07,519 --> 00:16:11,440
slides ago

497
00:16:08,959 --> 00:16:13,518
first an rsa model is dissampled and

498
00:16:11,440 --> 00:16:16,560
then the preprocessing attacker a0

499
00:16:13,519 --> 00:16:19,519
outputs a state st but then instead of

500
00:16:16,560 --> 00:16:22,079
sampling concrete ring elements as input

501
00:16:19,519 --> 00:16:23,040
we look at the output of a1 as a

502
00:16:22,079 --> 00:16:26,479
rational function

503
00:16:23,040 --> 00:16:28,079
in the input elements that is we look at

504
00:16:26,480 --> 00:16:30,959
the pair of polynomials

505
00:16:28,079 --> 00:16:32,319
p of x and q of x which correspond to

506
00:16:30,959 --> 00:16:35,279
the output of a1

507
00:16:32,320 --> 00:16:37,360
as described before here we assume that

508
00:16:35,279 --> 00:16:40,480
a1 is a straight line problem

509
00:16:37,360 --> 00:16:41,920
and hence for any fixing of n t and the

510
00:16:40,480 --> 00:16:44,320
state st

511
00:16:41,920 --> 00:16:45,360
the output of a1 is a fixed partial

512
00:16:44,320 --> 00:16:47,440
rational function

513
00:16:45,360 --> 00:16:49,279
in the ring elements which it receives

514
00:16:47,440 --> 00:16:51,839
as inputs

515
00:16:49,279 --> 00:16:53,279
we say that a0 and a1 win if the

516
00:16:51,839 --> 00:16:56,560
polynomials p and q

517
00:16:53,279 --> 00:17:00,399
are non-trivial and the polynomial

518
00:16:56,560 --> 00:17:03,518
p times q prime minus p prime times q

519
00:17:00,399 --> 00:17:04,959
is the zero polynomial model n where p

520
00:17:03,519 --> 00:17:06,959
prime and q prime

521
00:17:04,959 --> 00:17:09,679
are the polynomials which correspond to

522
00:17:06,959 --> 00:17:12,559
the output of the function df

523
00:17:09,679 --> 00:17:12,880
intuitively this list requirement states

524
00:17:12,559 --> 00:17:14,720
that

525
00:17:12,880 --> 00:17:18,240
a1 computes a function which is

526
00:17:14,720 --> 00:17:20,640
equivalent to the one computed by df

527
00:17:18,240 --> 00:17:21,520
note that since df is a straight line

528
00:17:20,640 --> 00:17:24,480
program

529
00:17:21,520 --> 00:17:27,039
for any fixing of n and t the output of

530
00:17:24,480 --> 00:17:28,160
df can indeed be described by the fixed

531
00:17:27,039 --> 00:17:32,400
pair of polynomials

532
00:17:28,160 --> 00:17:35,039
p prime and q prime we say that df

533
00:17:32,400 --> 00:17:37,440
has sequentiality depth at least d if

534
00:17:35,039 --> 00:17:39,679
for every pair l0 and a1

535
00:17:37,440 --> 00:17:40,799
such that a0 makes a polynomial number

536
00:17:39,679 --> 00:17:43,280
of queries

537
00:17:40,799 --> 00:17:44,799
and a1 makes it most desequential rounds

538
00:17:43,280 --> 00:17:46,480
of ring operation queries

539
00:17:44,799 --> 00:17:49,520
on a polynomial number of parallel

540
00:17:46,480 --> 00:17:50,480
processors the probability that a0 and

541
00:17:49,520 --> 00:17:54,480
a1 win

542
00:17:50,480 --> 00:17:56,559
is negligible in other words if a1 makes

543
00:17:54,480 --> 00:17:59,120
less than the sequential queries

544
00:17:56,559 --> 00:18:00,399
it does not compute a function which is

545
00:17:59,120 --> 00:18:03,439
trivially equivalent

546
00:18:00,400 --> 00:18:05,600
to the one computed by df we will say

547
00:18:03,440 --> 00:18:08,559
that df has sequentiality depth

548
00:18:05,600 --> 00:18:08,879
d if its sequentiality depth is at least

549
00:18:08,559 --> 00:18:12,320
d

550
00:18:08,880 --> 00:18:14,240
but not at least d plus 1. it's not hard

551
00:18:12,320 --> 00:18:15,360
to see that if df is a simple enough

552
00:18:14,240 --> 00:18:17,280
polynomial

553
00:18:15,360 --> 00:18:19,039
then its sequentiality depth is roughly

554
00:18:17,280 --> 00:18:21,520
the log of its degree

555
00:18:19,039 --> 00:18:23,919
in particular the sequentiality depth of

556
00:18:21,520 --> 00:18:27,200
repeated squaring with delay parameter t

557
00:18:23,919 --> 00:18:28,000
is indeed exactly t but in general we

558
00:18:27,200 --> 00:18:29,520
leave it as an open

559
00:18:28,000 --> 00:18:31,120
question to characterize the

560
00:18:29,520 --> 00:18:33,360
sequentiality depth of general

561
00:18:31,120 --> 00:18:36,000
multivariate rational functions

562
00:18:33,360 --> 00:18:37,520
finally due to time restrictions you can

563
00:18:36,000 --> 00:18:39,679
see the paper for a generalized

564
00:18:37,520 --> 00:18:41,760
definition of the sequentiality depth

565
00:18:39,679 --> 00:18:44,080
of general generic link functions and

566
00:18:41,760 --> 00:18:45,919
not just straight line programs

567
00:18:44,080 --> 00:18:47,760
so now we can present our main threshold

568
00:18:45,919 --> 00:18:48,960
theorem and the rough outline for the

569
00:18:47,760 --> 00:18:51,600
proof

570
00:18:48,960 --> 00:18:53,919
so our main theorem is the following let

571
00:18:51,600 --> 00:18:56,399
df be a generic linked delay function of

572
00:18:53,919 --> 00:18:59,120
sequentiality depth d

573
00:18:56,400 --> 00:19:01,760
then for any pair g0 and g1 of

574
00:18:59,120 --> 00:19:04,159
polynomial time generic ring algorithms

575
00:19:01,760 --> 00:19:05,679
such that g1 issues less than the

576
00:19:04,160 --> 00:19:06,960
sequential rounds of ring operation

577
00:19:05,679 --> 00:19:09,679
queries

578
00:19:06,960 --> 00:19:11,280
there is a standard model algorithm a

579
00:19:09,679 --> 00:19:14,400
with the following guarantee

580
00:19:11,280 --> 00:19:15,360
if g0 and g1 win in the sequentiality

581
00:19:14,400 --> 00:19:18,480
game of df

582
00:19:15,360 --> 00:19:21,678
with non-negligible probability that is

583
00:19:18,480 --> 00:19:23,360
g1 manages to compute the output of df

584
00:19:21,679 --> 00:19:26,880
on a randomly chosen input

585
00:19:23,360 --> 00:19:28,879
with non-negligible probability then a

586
00:19:26,880 --> 00:19:30,320
factors n with probability which is 1

587
00:19:28,880 --> 00:19:32,000
minus epsilon

588
00:19:30,320 --> 00:19:33,360
in time which is polynomial in the

589
00:19:32,000 --> 00:19:35,440
security parameter

590
00:19:33,360 --> 00:19:37,039
and in log 1 over epsilon for every

591
00:19:35,440 --> 00:19:39,440
choice of epsilon

592
00:19:37,039 --> 00:19:40,960
in other words our theory means that if

593
00:19:39,440 --> 00:19:43,039
there is a generic attacker which

594
00:19:40,960 --> 00:19:44,720
computes df in the ring zn

595
00:19:43,039 --> 00:19:46,320
with less than d sequential ring

596
00:19:44,720 --> 00:19:48,240
operation queries

597
00:19:46,320 --> 00:19:49,600
then this attacker can be used to factor

598
00:19:48,240 --> 00:19:52,320
n

599
00:19:49,600 --> 00:19:53,760
we note that this result is tight since

600
00:19:52,320 --> 00:19:56,639
in the paper we also show

601
00:19:53,760 --> 00:19:58,720
that assuming that factoring n is hard

602
00:19:56,640 --> 00:20:01,760
then df can be computed using

603
00:19:58,720 --> 00:20:04,240
these sequential ring operation queries

604
00:20:01,760 --> 00:20:06,240
the proof proceeds in several steps

605
00:20:04,240 --> 00:20:08,720
first we present the technical lemma

606
00:20:06,240 --> 00:20:10,480
which the following steps rely on then

607
00:20:08,720 --> 00:20:11,360
we prove the theorem for the simplified

608
00:20:10,480 --> 00:20:13,919
case

609
00:20:11,360 --> 00:20:15,439
in which the function df is given by a

610
00:20:13,919 --> 00:20:17,280
straight line program

611
00:20:15,440 --> 00:20:19,520
and the attacker is also a straight line

612
00:20:17,280 --> 00:20:21,360
program so it's deterministic and does

613
00:20:19,520 --> 00:20:24,158
not make any quality queries

614
00:20:21,360 --> 00:20:24,639
and there is no pre-processing stage

615
00:20:24,159 --> 00:20:27,039
then

616
00:20:24,640 --> 00:20:29,280
in step two we discuss how to revise the

617
00:20:27,039 --> 00:20:31,200
proof to accommodate it to attackers the

618
00:20:29,280 --> 00:20:32,840
do make equality queries

619
00:20:31,200 --> 00:20:35,760
we will see these tabs in the coming

620
00:20:32,840 --> 00:20:37,199
slides what remains is to extend the

621
00:20:35,760 --> 00:20:38,799
proof to attackers

622
00:20:37,200 --> 00:20:40,320
that use a pre-processing stage and

623
00:20:38,799 --> 00:20:42,158
randomization

624
00:20:40,320 --> 00:20:44,639
and to arbitrary generic ring delay

625
00:20:42,159 --> 00:20:46,000
functions that may also issue equality

626
00:20:44,640 --> 00:20:48,240
queries

627
00:20:46,000 --> 00:20:50,400
due to time limitations we will not see

628
00:20:48,240 --> 00:20:51,919
these final two steps in this talk

629
00:20:50,400 --> 00:20:53,679
and you can see the paper for more

630
00:20:51,919 --> 00:20:55,360
details

631
00:20:53,679 --> 00:20:57,360
our main technical lemma is a

632
00:20:55,360 --> 00:20:58,879
generalization of the lemma presented by

633
00:20:57,360 --> 00:21:00,719
agarwal and malware

634
00:20:58,880 --> 00:21:02,880
it states that for any straight line

635
00:21:00,720 --> 00:21:04,400
program s which receives scaling

636
00:21:02,880 --> 00:21:07,120
elements as input

637
00:21:04,400 --> 00:21:09,360
runs in time t issues at most q

638
00:21:07,120 --> 00:21:12,239
sequential ring operation queries on w

639
00:21:09,360 --> 00:21:14,799
processors and whose output corresponds

640
00:21:12,240 --> 00:21:17,520
to the polynomials p and q

641
00:21:14,799 --> 00:21:18,720
such that p is not the 0 polynomial and

642
00:21:17,520 --> 00:21:21,840
the probability that

643
00:21:18,720 --> 00:21:22,720
p of x is 0 for a random x is at least

644
00:21:21,840 --> 00:21:25,520
mu

645
00:21:22,720 --> 00:21:26,880
there is an algorithm a which runs in

646
00:21:25,520 --> 00:21:30,080
time polynomial

647
00:21:26,880 --> 00:21:32,960
in k t q and w and factors n

648
00:21:30,080 --> 00:21:33,678
with probability which is at least mu

649
00:21:32,960 --> 00:21:36,960
over k

650
00:21:33,679 --> 00:21:39,360
squared times q times w

651
00:21:36,960 --> 00:21:41,200
note that if s runs in polynomial time

652
00:21:39,360 --> 00:21:43,039
and makes a polynomial number of ring

653
00:21:41,200 --> 00:21:45,679
operation queries in total

654
00:21:43,039 --> 00:21:47,039
and if the fraction of roots of p in zn

655
00:21:45,679 --> 00:21:49,840
is non-negligible

656
00:21:47,039 --> 00:21:53,120
then a runs in polynomial time and has a

657
00:21:49,840 --> 00:21:54,959
non-negligible success probability

658
00:21:53,120 --> 00:21:56,959
so with the first step let's consider

659
00:21:54,960 --> 00:21:58,480
the case where df is a straight line

660
00:21:56,960 --> 00:22:01,200
program of sequentiality depth

661
00:21:58,480 --> 00:22:02,240
d and the attacker s is also a straight

662
00:22:01,200 --> 00:22:04,640
line program

663
00:22:02,240 --> 00:22:05,760
which runs in time t with w parallel

664
00:22:04,640 --> 00:22:07,760
processors

665
00:22:05,760 --> 00:22:09,919
and issues less than the sequential

666
00:22:07,760 --> 00:22:11,679
rounds of ring operation quiz

667
00:22:09,919 --> 00:22:13,520
we denote the success probability of s

668
00:22:11,679 --> 00:22:16,080
by epsilon

669
00:22:13,520 --> 00:22:18,480
let's denote by p and q the polynomials

670
00:22:16,080 --> 00:22:21,280
which correspond to the output of df

671
00:22:18,480 --> 00:22:23,919
and by p prime q prime the ones which

672
00:22:21,280 --> 00:22:25,678
correspond to the output of s

673
00:22:23,919 --> 00:22:28,320
consider the straight line program as

674
00:22:25,679 --> 00:22:29,840
prime whose output can be described as

675
00:22:28,320 --> 00:22:33,280
the polynomial

676
00:22:29,840 --> 00:22:36,639
p times q prime minus q times p

677
00:22:33,280 --> 00:22:39,520
prime we will not see this here but if

678
00:22:36,640 --> 00:22:40,000
d t and w are all polynomials in the

679
00:22:39,520 --> 00:22:42,720
security

680
00:22:40,000 --> 00:22:44,159
parameter then s prime runs in time

681
00:22:42,720 --> 00:22:45,600
which is polynomial in the security

682
00:22:44,159 --> 00:22:47,840
parameter as well

683
00:22:45,600 --> 00:22:49,840
and also issues a polynomial number of

684
00:22:47,840 --> 00:22:52,720
ring operation queries

685
00:22:49,840 --> 00:22:54,080
now observe that since s makes less than

686
00:22:52,720 --> 00:22:57,120
the sequential ring operation

687
00:22:54,080 --> 00:22:58,480
queries and since df has sequentiality

688
00:22:57,120 --> 00:23:00,479
depth d

689
00:22:58,480 --> 00:23:02,960
then by our definition of sequentiality

690
00:23:00,480 --> 00:23:06,480
depth it means that the polynomial

691
00:23:02,960 --> 00:23:09,520
f computed by s prime which is p times

692
00:23:06,480 --> 00:23:12,880
q prime minus q times p prime

693
00:23:09,520 --> 00:23:15,600
is not the zero polynomial moreover

694
00:23:12,880 --> 00:23:17,600
for any input x on which s is successful

695
00:23:15,600 --> 00:23:18,959
in computing df of x

696
00:23:17,600 --> 00:23:20,959
it means that the value of the

697
00:23:18,960 --> 00:23:24,080
polynomial f at the point x

698
00:23:20,960 --> 00:23:24,320
is zero hence by the success probability

699
00:23:24,080 --> 00:23:27,520
of

700
00:23:24,320 --> 00:23:27,760
s in computing df the probability that f

701
00:23:27,520 --> 00:23:30,960
of

702
00:23:27,760 --> 00:23:31,280
x is zero for randomly chosen x is at

703
00:23:30,960 --> 00:23:34,640
least

704
00:23:31,280 --> 00:23:36,158
epsilon this means that by our lemma

705
00:23:34,640 --> 00:23:38,480
there is a standard model factoring

706
00:23:36,159 --> 00:23:40,000
algorithm a which runs in time which is

707
00:23:38,480 --> 00:23:42,799
polynomial in t w

708
00:23:40,000 --> 00:23:43,840
and d and factors n with probability

709
00:23:42,799 --> 00:23:46,960
polynomial in

710
00:23:43,840 --> 00:23:48,480
epsilon d t and w if all of these

711
00:23:46,960 --> 00:23:50,000
parameters are polynomials in the

712
00:23:48,480 --> 00:23:53,120
security parameter

713
00:23:50,000 --> 00:23:54,640
then a breaks the factoring assumption

714
00:23:53,120 --> 00:23:56,879
now let's consider a slightly more

715
00:23:54,640 --> 00:23:59,039
general case in which the attacker s can

716
00:23:56,880 --> 00:24:01,360
perform equality queries

717
00:23:59,039 --> 00:24:02,480
the analysis in this case is based on

718
00:24:01,360 --> 00:24:04,320
the observation

719
00:24:02,480 --> 00:24:06,320
that there can be essentially two types

720
00:24:04,320 --> 00:24:09,600
of equality queries

721
00:24:06,320 --> 00:24:11,279
one is so-called biased equality queries

722
00:24:09,600 --> 00:24:13,760
which are queries that are answered in

723
00:24:11,279 --> 00:24:16,080
the same manner for almost all inputs

724
00:24:13,760 --> 00:24:18,158
for example a query which is answered

725
00:24:16,080 --> 00:24:21,520
negatively for almost all inputs

726
00:24:18,159 --> 00:24:22,400
is a biased query as we will see biased

727
00:24:21,520 --> 00:24:24,320
queries

728
00:24:22,400 --> 00:24:26,320
can be compiled out of the attack in

729
00:24:24,320 --> 00:24:28,559
some sense

730
00:24:26,320 --> 00:24:30,080
the second type of queries is so-called

731
00:24:28,559 --> 00:24:31,520
balanced queries

732
00:24:30,080 --> 00:24:33,840
these are just queries which are not

733
00:24:31,520 --> 00:24:36,240
biased as we will see

734
00:24:33,840 --> 00:24:38,240
if the attacker issues a balanced query

735
00:24:36,240 --> 00:24:39,200
then this query can be used directly to

736
00:24:38,240 --> 00:24:40,799
factor n

737
00:24:39,200 --> 00:24:43,039
regardless of the attacker's success

738
00:24:40,799 --> 00:24:44,960
probability in quickly evaluating the

739
00:24:43,039 --> 00:24:47,679
delay function

740
00:24:44,960 --> 00:24:48,159
now let's consider two cases the first

741
00:24:47,679 --> 00:24:50,080
case

742
00:24:48,159 --> 00:24:52,240
is that all quality queries issued by

743
00:24:50,080 --> 00:24:54,399
the attacker s are biased

744
00:24:52,240 --> 00:24:56,640
that is each of them is answered in the

745
00:24:54,400 --> 00:24:58,640
same manner for almost all inputs

746
00:24:56,640 --> 00:25:00,640
in this case in the reduction we can

747
00:24:58,640 --> 00:25:01,440
simply learn the n cells to all equality

748
00:25:00,640 --> 00:25:04,400
queries

749
00:25:01,440 --> 00:25:05,279
by checking them on a random input then

750
00:25:04,400 --> 00:25:07,279
we can convert

751
00:25:05,279 --> 00:25:09,279
the attacker back to a straight line

752
00:25:07,279 --> 00:25:11,120
program by prefixing

753
00:25:09,279 --> 00:25:13,440
the answers to all equality queries to

754
00:25:11,120 --> 00:25:14,639
be the answers that we got on the random

755
00:25:13,440 --> 00:25:16,720
input

756
00:25:14,640 --> 00:25:19,360
with high probability these will be

757
00:25:16,720 --> 00:25:20,880
consistent with n cells on most inputs

758
00:25:19,360 --> 00:25:22,639
and hence this will not affect the

759
00:25:20,880 --> 00:25:24,080
success probability of the attack air by

760
00:25:22,640 --> 00:25:26,000
too much

761
00:25:24,080 --> 00:25:27,918
the second case is that the attacker

762
00:25:26,000 --> 00:25:29,120
issues at least one balanced equality

763
00:25:27,919 --> 00:25:31,440
query

764
00:25:29,120 --> 00:25:33,279
let's consider the first balanced query

765
00:25:31,440 --> 00:25:35,200
and let's compile out all equality

766
00:25:33,279 --> 00:25:37,039
queries preceding it as we did in the

767
00:25:35,200 --> 00:25:39,600
first case

768
00:25:37,039 --> 00:25:40,640
now this balanced equality query is a

769
00:25:39,600 --> 00:25:42,959
query comparing

770
00:25:40,640 --> 00:25:44,400
two ring elements and we can look at the

771
00:25:42,960 --> 00:25:47,440
pairs of polynomials

772
00:25:44,400 --> 00:25:49,440
p q and p prime q prime corresponding to

773
00:25:47,440 --> 00:25:51,200
these elements

774
00:25:49,440 --> 00:25:53,120
consider the straight line program s

775
00:25:51,200 --> 00:25:57,200
prime computing the polynomial

776
00:25:53,120 --> 00:25:59,678
p times q prime minus p prime times q

777
00:25:57,200 --> 00:26:01,760
since the quantity query is balanced

778
00:25:59,679 --> 00:26:04,799
this polynomial is non-trivial

779
00:26:01,760 --> 00:26:05,440
and has many roots in zn it is not

780
00:26:04,799 --> 00:26:08,000
trivial

781
00:26:05,440 --> 00:26:09,679
since otherwise the quality query would

782
00:26:08,000 --> 00:26:10,559
have been answered affirmatively on all

783
00:26:09,679 --> 00:26:12,960
inputs

784
00:26:10,559 --> 00:26:14,559
and it would not have been balanced it

785
00:26:12,960 --> 00:26:16,640
has many roots in zn

786
00:26:14,559 --> 00:26:18,639
since otherwise the quality query would

787
00:26:16,640 --> 00:26:18,880
have been answered negatively on almost

788
00:26:18,640 --> 00:26:20,880
all

789
00:26:18,880 --> 00:26:22,320
inputs and again the query would not

790
00:26:20,880 --> 00:26:24,159
have been balanced

791
00:26:22,320 --> 00:26:25,678
hence we can invoke our technical lemma

792
00:26:24,159 --> 00:26:27,520
to derive a successful factoring

793
00:26:25,679 --> 00:26:29,440
algorithm

794
00:26:27,520 --> 00:26:31,600
let's conclude with some closing remarks

795
00:26:29,440 --> 00:26:33,520
and open questions

796
00:26:31,600 --> 00:26:35,039
prior to our work there was quite a gap

797
00:26:33,520 --> 00:26:36,240
when it came to the repeated squaring

798
00:26:35,039 --> 00:26:38,240
assumption

799
00:26:36,240 --> 00:26:40,400
on the one hand this was purely an

800
00:26:38,240 --> 00:26:41,679
assumption with no security argument

801
00:26:40,400 --> 00:26:43,760
supporting it

802
00:26:41,679 --> 00:26:45,440
but on the other hand the assumption

803
00:26:43,760 --> 00:26:46,879
remained essentially unbroken for

804
00:26:45,440 --> 00:26:49,279
decades

805
00:26:46,880 --> 00:26:52,240
our work narrows this gap for the

806
00:26:49,279 --> 00:26:53,360
natural class of generic attacks even

807
00:26:52,240 --> 00:26:54,880
though as we mentioned

808
00:26:53,360 --> 00:26:56,719
there are examples for inherently

809
00:26:54,880 --> 00:26:59,200
non-generic algorithms

810
00:26:56,720 --> 00:27:01,039
our results can be seen as having two

811
00:26:59,200 --> 00:27:02,880
main implications

812
00:27:01,039 --> 00:27:04,879
on the one hand they direct

813
00:27:02,880 --> 00:27:06,640
cryptanalytic efforts to non-generic

814
00:27:04,880 --> 00:27:08,240
directions

815
00:27:06,640 --> 00:27:10,320
while on the other hand they are

816
00:27:08,240 --> 00:27:12,320
somewhat necessary step in the quest for

817
00:27:10,320 --> 00:27:13,918
similar results in less restrictive

818
00:27:12,320 --> 00:27:16,158
models

819
00:27:13,919 --> 00:27:18,240
one natural direction in this respect is

820
00:27:16,159 --> 00:27:20,720
to try and prove similar results in an

821
00:27:18,240 --> 00:27:22,000
algebraic ring model extending the

822
00:27:20,720 --> 00:27:24,240
algebraic group model

823
00:27:22,000 --> 00:27:25,679
recently proposed by fuck's bower kilts

824
00:27:24,240 --> 00:27:27,520
and loss

825
00:27:25,679 --> 00:27:29,440
in that regard it should be mentioned

826
00:27:27,520 --> 00:27:32,000
that in an independent work

827
00:27:29,440 --> 00:27:33,360
cut loss and sue proved an incomparable

828
00:27:32,000 --> 00:27:35,120
result to ours

829
00:27:33,360 --> 00:27:36,959
showing that within an enhanced

830
00:27:35,120 --> 00:27:38,959
algebraic group model

831
00:27:36,960 --> 00:27:40,799
speeding up repeated querying in the

832
00:27:38,960 --> 00:27:42,640
group of quadratic residues model

833
00:27:40,799 --> 00:27:45,600
n where n is the product of two safe

834
00:27:42,640 --> 00:27:47,360
primes is equivalent to factoring n

835
00:27:45,600 --> 00:27:49,678
so it's interesting whether this result

836
00:27:47,360 --> 00:27:51,360
can be extended to the ring zn

837
00:27:49,679 --> 00:27:53,600
but it does seem that additional

838
00:27:51,360 --> 00:27:55,918
techniques are required for that

839
00:27:53,600 --> 00:27:57,840
another interesting open problem is what

840
00:27:55,919 --> 00:27:59,760
security arguments can be made in

841
00:27:57,840 --> 00:28:01,520
support of the sequentiality of other

842
00:27:59,760 --> 00:28:03,120
candidate delay functions

843
00:28:01,520 --> 00:28:05,600
such as repeated squaring in class

844
00:28:03,120 --> 00:28:07,918
groups exogeny-based candidates

845
00:28:05,600 --> 00:28:10,158
and this target-based we-do function in

846
00:28:07,919 --> 00:28:12,480
prime fields

847
00:28:10,159 --> 00:28:14,399
okay let's conclude we presented the

848
00:28:12,480 --> 00:28:16,320
sharp threshold for the sequentiality of

849
00:28:14,399 --> 00:28:17,439
all functions within the generic ring

850
00:28:16,320 --> 00:28:19,360
model

851
00:28:17,440 --> 00:28:21,360
we put forth the notion of sequentiality

852
00:28:19,360 --> 00:28:22,799
depth and saw that assuming that

853
00:28:21,360 --> 00:28:24,639
factoring is hard

854
00:28:22,799 --> 00:28:26,399
this notion indeed serves as a sharp

855
00:28:24,640 --> 00:28:27,679
threshold for the number of sequential

856
00:28:26,399 --> 00:28:29,520
ring operations

857
00:28:27,679 --> 00:28:30,720
required to compute any generic ring

858
00:28:29,520 --> 00:28:32,399
function

859
00:28:30,720 --> 00:28:33,840
we mentioned analogous results for the

860
00:28:32,399 --> 00:28:34,719
pseudorandomness of generic ring

861
00:28:33,840 --> 00:28:37,360
functions

862
00:28:34,720 --> 00:28:38,720
and you can see the paper for details so

863
00:28:37,360 --> 00:28:42,240
that's all i have for you today and

864
00:28:38,720 --> 00:28:42,240
thank you for listening

