1
00:00:00,560 --> 00:00:06,560
sorry thank you for your patience

2
00:00:03,120 --> 00:00:10,320
and now you should be good to go okay

3
00:00:06,560 --> 00:00:13,518
great um so now i'm in the wrong

4
00:00:10,320 --> 00:00:15,280
window give me a second hi everyone

5
00:00:13,519 --> 00:00:17,440
um it's it's great to see so many

6
00:00:15,280 --> 00:00:18,800
familiar faces i guess i've been missing

7
00:00:17,440 --> 00:00:21,920
most of you more

8
00:00:18,800 --> 00:00:23,680
during the pandemic um we now have uh

9
00:00:21,920 --> 00:00:25,039
short presentations of six exciting

10
00:00:23,680 --> 00:00:26,640
research results coming up

11
00:00:25,039 --> 00:00:29,760
and it's my pleasure to share this

12
00:00:26,640 --> 00:00:31,920
session together with julio

13
00:00:29,760 --> 00:00:34,239
um most of you will already be used to

14
00:00:31,920 --> 00:00:34,880
this so just very quickly um we will

15
00:00:34,239 --> 00:00:36,800
have

16
00:00:34,880 --> 00:00:38,160
10 minutes per paper starting with a

17
00:00:36,800 --> 00:00:40,800
presentation of

18
00:00:38,160 --> 00:00:42,480
about five minutes so speakers don't

19
00:00:40,800 --> 00:00:44,000
don't worry if you run a little bit over

20
00:00:42,480 --> 00:00:46,319
time we're not going to interrupt you

21
00:00:44,000 --> 00:00:48,000
too soon but you will be kicked out

22
00:00:46,320 --> 00:00:51,760
after 10 minutes to give enough

23
00:00:48,000 --> 00:00:53,280
time for the other speakers um

24
00:00:51,760 --> 00:00:55,199
and then this will be immediately

25
00:00:53,280 --> 00:00:59,359
followed by about 5 minutes for

26
00:00:55,199 --> 00:01:01,039
a q a if not so many questions are asked

27
00:00:59,359 --> 00:01:02,960
then we will simply move on to the next

28
00:01:01,039 --> 00:01:04,720
presentation uh which might

29
00:01:02,960 --> 00:01:07,920
leave us some room for our second round

30
00:01:04,720 --> 00:01:10,320
of questions at the end of the session

31
00:01:07,920 --> 00:01:11,760
and if you want to ask questions then

32
00:01:10,320 --> 00:01:14,880
please do so either

33
00:01:11,760 --> 00:01:15,439
via the chat at shell.icr.org in the

34
00:01:14,880 --> 00:01:16,880
topic

35
00:01:15,439 --> 00:01:18,798
public key function and witness

36
00:01:16,880 --> 00:01:20,798
encryption um

37
00:01:18,799 --> 00:01:23,119
or raise your hand and zoom or express

38
00:01:20,799 --> 00:01:25,119
your willingness to ask a live question

39
00:01:23,119 --> 00:01:26,240
in the zoom chat and julia will moderate

40
00:01:25,119 --> 00:01:28,400
the questions

41
00:01:26,240 --> 00:01:29,920
um yeah finally the usual disclaimer

42
00:01:28,400 --> 00:01:30,799
please don't forget to mute your

43
00:01:29,920 --> 00:01:32,479
microphones

44
00:01:30,799 --> 00:01:33,920
throughout the sessions unless you're

45
00:01:32,479 --> 00:01:36,960
asking a question

46
00:01:33,920 --> 00:01:40,240
and enjoy the session okay so

47
00:01:36,960 --> 00:01:42,320
um the first presentation

48
00:01:40,240 --> 00:01:43,920
is about a paper with the title

49
00:01:42,320 --> 00:01:46,320
functional encryption

50
00:01:43,920 --> 00:01:47,360
for attribute-based weighted sums from

51
00:01:46,320 --> 00:01:49,360
kaelin

52
00:01:47,360 --> 00:01:51,200
this paper is by michelle abdullah june

53
00:01:49,360 --> 00:01:53,680
king gong and what agree

54
00:01:51,200 --> 00:01:56,000
and junking will give the presentation

55
00:01:53,680 --> 00:02:09,840
so please go ahead share your screen

56
00:01:56,000 --> 00:02:09,840
and start your presentation

57
00:02:14,480 --> 00:02:18,480
oh can you see my slides and hear me

58
00:02:19,920 --> 00:02:26,079
yes we can hear you okay okay okay

59
00:02:22,959 --> 00:02:28,319
uh thanks for the introduction so

60
00:02:26,080 --> 00:02:29,599
let me first motivate attribute weighted

61
00:02:28,319 --> 00:02:32,079
sum

62
00:02:29,599 --> 00:02:33,839
so give a database with private health

63
00:02:32,080 --> 00:02:34,560
information highlighted by blue

64
00:02:33,840 --> 00:02:37,120
background

65
00:02:34,560 --> 00:02:38,000
we may want to do some analysis shown on

66
00:02:37,120 --> 00:02:40,319
the right

67
00:02:38,000 --> 00:02:42,560
this is actually a weighted sum of

68
00:02:40,319 --> 00:02:45,760
private data

69
00:02:42,560 --> 00:02:48,400
the weight for each i is a function f in

70
00:02:45,760 --> 00:02:52,160
corresponding public attribute

71
00:02:48,400 --> 00:02:54,720
let x v be public and the private data

72
00:02:52,160 --> 00:02:55,840
we write the sum like this and call it

73
00:02:54,720 --> 00:02:59,359
attribute-weighted

74
00:02:55,840 --> 00:03:00,800
sum with functional encryption for

75
00:02:59,360 --> 00:03:04,080
attribute weighted sum

76
00:03:00,800 --> 00:03:04,720
we can encrypt x i and zi with x-ib in

77
00:03:04,080 --> 00:03:06,879
public

78
00:03:04,720 --> 00:03:08,720
and issue a secret key for the function

79
00:03:06,879 --> 00:03:10,640
f

80
00:03:08,720 --> 00:03:12,879
decryption gives the attribute where it

81
00:03:10,640 --> 00:03:16,839
is sum and nothing about

82
00:03:12,879 --> 00:03:18,640
z-i can be leaked this is formulated by

83
00:03:16,840 --> 00:03:20,800
simulation-based security

84
00:03:18,640 --> 00:03:23,518
against unbounded collusion the

85
00:03:20,800 --> 00:03:24,239
simulated cycle text does not contain zi

86
00:03:23,519 --> 00:03:26,080
anymore

87
00:03:24,239 --> 00:03:28,640
while the sum are embedded into the

88
00:03:26,080 --> 00:03:31,440
simulated key

89
00:03:28,640 --> 00:03:33,839
also when we want to add new data even

90
00:03:31,440 --> 00:03:36,239
after issuing a secret key

91
00:03:33,840 --> 00:03:37,680
therefore we require secret key to work

92
00:03:36,239 --> 00:03:41,120
for unbounded n

93
00:03:37,680 --> 00:03:43,920
we call this unbounded slot feature

94
00:03:41,120 --> 00:03:45,360
in general we consider z i via vectors

95
00:03:43,920 --> 00:03:47,760
over zp

96
00:03:45,360 --> 00:03:51,280
this capture more applications and

97
00:03:47,760 --> 00:03:53,519
classical functional encryptions

98
00:03:51,280 --> 00:03:54,959
our main result is an fe scheme for

99
00:03:53,519 --> 00:03:57,120
attribute-weighted sum

100
00:03:54,959 --> 00:03:58,000
with selective security front key linear

101
00:03:57,120 --> 00:04:01,439
assumption

102
00:03:58,000 --> 00:04:04,799
and supporting unbounded slot feature

103
00:04:01,439 --> 00:04:05,439
here f can be an arithmetic function

104
00:04:04,799 --> 00:04:09,120
program

105
00:04:05,439 --> 00:04:12,000
that covers nc1 and more

106
00:04:09,120 --> 00:04:12,239
technically we build a one slot scheme

107
00:04:12,000 --> 00:04:15,760
and

108
00:04:12,239 --> 00:04:17,440
bootstrap it to the n slot setting

109
00:04:15,760 --> 00:04:18,798
this talk will focus on the

110
00:04:17,440 --> 00:04:22,560
bootstrapping part

111
00:04:18,798 --> 00:04:22,560
using a three slot example

112
00:04:22,639 --> 00:04:26,960
we first extend one slot scheme to

113
00:04:24,880 --> 00:04:30,000
compute attribute weighted sound

114
00:04:26,960 --> 00:04:32,239
hidden by w times r where w and

115
00:04:30,000 --> 00:04:34,160
r are random values in the ciphertext

116
00:04:32,240 --> 00:04:37,199
and the key

117
00:04:34,160 --> 00:04:40,720
as a world map we encrypt each x i z

118
00:04:37,199 --> 00:04:41,840
i by one slot scheme with correlated

119
00:04:40,720 --> 00:04:45,040
random value w

120
00:04:41,840 --> 00:04:47,679
i the secret key is the same as the one

121
00:04:45,040 --> 00:04:47,680
slot case

122
00:04:47,840 --> 00:04:51,198
decrypting each sub-cycle text by the

123
00:04:50,240 --> 00:04:54,400
secret key

124
00:04:51,199 --> 00:04:59,120
gives a partial result with mask wi

125
00:04:54,400 --> 00:05:01,359
times r adding them together

126
00:04:59,120 --> 00:05:04,720
gives us the attribute weighted sound by

127
00:05:01,360 --> 00:05:04,720
the relation of wi

128
00:05:05,199 --> 00:05:11,520
the scheme is has unbounded slot feature

129
00:05:09,199 --> 00:05:14,880
since we use the same one slot key to

130
00:05:11,520 --> 00:05:17,280
decrypt all sub ciphertexts

131
00:05:14,880 --> 00:05:18,400
one can simply argue that these partial

132
00:05:17,280 --> 00:05:20,880
results have the

133
00:05:18,400 --> 00:05:23,758
same distribution as this and they only

134
00:05:20,880 --> 00:05:25,919
leak the attribute weighted sum

135
00:05:23,759 --> 00:05:28,560
however in the actual proof we cannot

136
00:05:25,919 --> 00:05:30,320
embed all three partial results into one

137
00:05:28,560 --> 00:05:33,120
secret key

138
00:05:30,320 --> 00:05:34,479
our first idea is to divide the argument

139
00:05:33,120 --> 00:05:37,919
into several hybrids

140
00:05:34,479 --> 00:05:39,199
and gradually collect the partial sum

141
00:05:37,919 --> 00:05:41,440
hybrid 0

142
00:05:39,199 --> 00:05:44,000
rewrite the first partial result by the

143
00:05:41,440 --> 00:05:46,719
relation of wi

144
00:05:44,000 --> 00:05:47,759
partial 1 used w2 to collect the partial

145
00:05:46,720 --> 00:05:50,800
sum for the first

146
00:05:47,759 --> 00:05:53,600
two slots then partial 2

147
00:05:50,800 --> 00:05:55,759
used w3 to pick the last cement and get

148
00:05:53,600 --> 00:05:57,759
the same distribution as the one shot

149
00:05:55,759 --> 00:06:00,560
argument

150
00:05:57,759 --> 00:06:02,000
since each hybrid only involve two slots

151
00:06:00,560 --> 00:06:06,400
we only need to embed

152
00:06:02,000 --> 00:06:07,680
two partial results at one time so our

153
00:06:06,400 --> 00:06:10,239
second idea

154
00:06:07,680 --> 00:06:12,319
is to prepare two sub keys for two

155
00:06:10,240 --> 00:06:14,400
copies of one slot scheme

156
00:06:12,319 --> 00:06:15,680
and get two place to embed the two

157
00:06:14,400 --> 00:06:18,239
values

158
00:06:15,680 --> 00:06:18,880
accordingly the first subcipher text are

159
00:06:18,240 --> 00:06:21,759
encrypted

160
00:06:18,880 --> 00:06:24,479
under the first copy and others are

161
00:06:21,759 --> 00:06:24,479
under the second

162
00:06:24,639 --> 00:06:28,800
this is sufficient for the proof and it

163
00:06:26,560 --> 00:06:30,720
gives actual scheme

164
00:06:28,800 --> 00:06:32,560
i want to skip the proof but to show you

165
00:06:30,720 --> 00:06:34,960
the simulator

166
00:06:32,560 --> 00:06:35,680
here sub ciphertext do not contain zi

167
00:06:34,960 --> 00:06:37,359
anymore

168
00:06:35,680 --> 00:06:39,840
and the attribute weighted sum is

169
00:06:37,360 --> 00:06:43,360
embedded into the sub key from the first

170
00:06:39,840 --> 00:06:44,318
copy and this can be extended to the n

171
00:06:43,360 --> 00:06:47,440
slot case

172
00:06:44,319 --> 00:06:49,280
without changing secret key

173
00:06:47,440 --> 00:06:52,240
as a summary we study functional

174
00:06:49,280 --> 00:06:54,318
encryption for attribute-weighted sum

175
00:06:52,240 --> 00:06:56,960
and the builder can create a scheme with

176
00:06:54,319 --> 00:06:59,680
bootstrapping technique

177
00:06:56,960 --> 00:07:01,599
we can also get its multi-client variant

178
00:06:59,680 --> 00:07:02,240
each slot is encrypted by different

179
00:07:01,599 --> 00:07:05,280
party

180
00:07:02,240 --> 00:07:05,280
who can be corrupted

181
00:07:05,440 --> 00:07:10,319
we finally leave some open problem our

182
00:07:07,840 --> 00:07:12,479
parent-based scheme is selective secure

183
00:07:10,319 --> 00:07:13,599
it is desirable to achieve adaptive

184
00:07:12,479 --> 00:07:15,120
security

185
00:07:13,599 --> 00:07:16,719
and also find the lattice-based

186
00:07:15,120 --> 00:07:18,880
construction

187
00:07:16,720 --> 00:07:21,280
in our multi-client scheme require all

188
00:07:18,880 --> 00:07:22,479
party to negotiate fresh randomness for

189
00:07:21,280 --> 00:07:24,239
each encryption

190
00:07:22,479 --> 00:07:25,840
so it is interesting to move this

191
00:07:24,240 --> 00:07:31,840
restriction

192
00:07:25,840 --> 00:07:31,840
thank you for your attention

193
00:07:34,560 --> 00:07:38,960
okay thank you very much for your talk

194
00:07:36,560 --> 00:07:40,400
um if you have questions please type

195
00:07:38,960 --> 00:07:43,840
them in the zoom chat

196
00:07:40,400 --> 00:07:45,840
uh or just unmute yourself uh i'll be

197
00:07:43,840 --> 00:07:47,599
also checking the zulip chapters in case

198
00:07:45,840 --> 00:07:50,159
someone is

199
00:07:47,599 --> 00:07:50,159
writing there

200
00:07:56,479 --> 00:07:59,919
so yeah if there's no question i have a

201
00:07:58,639 --> 00:08:04,000
few actually for you

202
00:07:59,919 --> 00:08:07,280
um so you mentioned that um

203
00:08:04,000 --> 00:08:10,400
uh you achieve a simulation based uh

204
00:08:07,280 --> 00:08:13,520
definition of security and uh

205
00:08:10,400 --> 00:08:15,520
i wonder if one wants to settle

206
00:08:13,520 --> 00:08:16,960
uh purchasing distinguishability-based

207
00:08:15,520 --> 00:08:20,080
definitions

208
00:08:16,960 --> 00:08:20,560
does that make the scheme easier can you

209
00:08:20,080 --> 00:08:22,318
can you

210
00:08:20,560 --> 00:08:24,800
expect to have a more efficient variant

211
00:08:22,319 --> 00:08:25,280
or that you still encounter the same

212
00:08:24,800 --> 00:08:27,360
issue

213
00:08:25,280 --> 00:08:29,758
that you described in your in your in

214
00:08:27,360 --> 00:08:29,759
your talk

215
00:08:31,840 --> 00:08:36,718
i i think maybe uh maybe the simulation

216
00:08:35,519 --> 00:08:38,880
securities uh

217
00:08:36,719 --> 00:08:40,719
because the underlying building block is

218
00:08:38,880 --> 00:08:41,838
basically just a simulation based

219
00:08:40,719 --> 00:08:45,040
security

220
00:08:41,839 --> 00:08:48,959
so if you combine them together so it's

221
00:08:45,040 --> 00:08:51,439
reasonable to uh to

222
00:08:48,959 --> 00:08:53,439
have a simulation based secure for the

223
00:08:51,440 --> 00:08:57,360
for the final scheme

224
00:08:53,440 --> 00:08:57,760
so well for me i didn't consider if you

225
00:08:57,360 --> 00:09:01,680
can

226
00:08:57,760 --> 00:09:05,600
get efficiency improvement if you

227
00:09:01,680 --> 00:09:07,599
have other security security requirement

228
00:09:05,600 --> 00:09:09,040
so maybe it's a good idea to check

229
00:09:07,600 --> 00:09:14,080
whether we have

230
00:09:09,040 --> 00:09:14,079
some trade-off thanks for the question

231
00:09:17,760 --> 00:09:20,000
okay

232
00:09:21,200 --> 00:09:28,399
i don't see any other question

233
00:09:24,720 --> 00:09:29,920
please let me know if i'm mistaken um

234
00:09:28,399 --> 00:09:32,399
actually queries i wanted to ask another

235
00:09:29,920 --> 00:09:35,519
thing um did you actually

236
00:09:32,399 --> 00:09:38,800
consider oh someone someone

237
00:09:35,519 --> 00:09:40,480
raise their hand please uh

238
00:09:38,800 --> 00:09:42,560
mute yourself i think you're gonna roman

239
00:09:40,480 --> 00:09:44,880
and uh you can get yourself

240
00:09:42,560 --> 00:09:47,040
uh i have a question uh you said you

241
00:09:44,880 --> 00:09:49,040
achieve only selective security

242
00:09:47,040 --> 00:09:50,160
and adaptive security is still an open

243
00:09:49,040 --> 00:09:53,360
problem

244
00:09:50,160 --> 00:09:56,160
but for weaker functionalities like

245
00:09:53,360 --> 00:09:58,399
in a product functional encryption or

246
00:09:56,160 --> 00:10:00,640
attribute based encryption

247
00:09:58,399 --> 00:10:01,839
there are adaptively secure schemes so

248
00:10:00,640 --> 00:10:06,000
is there something

249
00:10:01,839 --> 00:10:08,880
especially difficult with this whitehead

250
00:10:06,000 --> 00:10:11,920
thumbs attribute right at some um to

251
00:10:08,880 --> 00:10:14,800
achieve adaptive security

252
00:10:11,920 --> 00:10:16,880
uh thanks for the for the question so

253
00:10:14,800 --> 00:10:18,640
for in a product

254
00:10:16,880 --> 00:10:20,880
actually our construction use uh

255
00:10:18,640 --> 00:10:22,399
technique from uh inner product function

256
00:10:20,880 --> 00:10:25,760
encryption and the

257
00:10:22,399 --> 00:10:26,399
uh the technique for uh partial partial

258
00:10:25,760 --> 00:10:29,519
hidden

259
00:10:26,399 --> 00:10:31,040
uh predict encryption so actually for

260
00:10:29,519 --> 00:10:34,880
both of them

261
00:10:31,040 --> 00:10:37,599
we can do adaptively simulation-based

262
00:10:34,880 --> 00:10:39,600
simulation-based security uh but the

263
00:10:37,600 --> 00:10:41,279
point is how to combine them together

264
00:10:39,600 --> 00:10:43,760
and we also need to worry about the

265
00:10:41,279 --> 00:10:46,480
bootstrapping step

266
00:10:43,760 --> 00:10:47,760
because because the two technique only

267
00:10:46,480 --> 00:10:50,320
solved the one slot

268
00:10:47,760 --> 00:10:52,160
uh scheme but if you want to bootstrap

269
00:10:50,320 --> 00:10:54,880
from one slot to

270
00:10:52,160 --> 00:10:57,279
to multislot you also need to take care

271
00:10:54,880 --> 00:10:57,279
of this

272
00:10:57,440 --> 00:11:03,920
ah okay i see thanks

273
00:11:00,959 --> 00:11:03,920
thanks for the question

274
00:11:07,920 --> 00:11:12,079
all right um i don't see any other

275
00:11:10,720 --> 00:11:14,640
question

276
00:11:12,079 --> 00:11:16,160
maybe we can move on with the next talk

277
00:11:14,640 --> 00:11:17,680
and uh

278
00:11:16,160 --> 00:11:19,360
if there's any question maybe you guys

279
00:11:17,680 --> 00:11:22,000
can you can ask them at the end at the

280
00:11:19,360 --> 00:11:23,920
very end of the session

281
00:11:22,000 --> 00:11:25,680
okay great yeah thank you for this

282
00:11:23,920 --> 00:11:27,279
presentation uh it's probably a good

283
00:11:25,680 --> 00:11:28,959
idea if we have some minutes left at the

284
00:11:27,279 --> 00:11:29,680
end because sometimes it takes a little

285
00:11:28,959 --> 00:11:32,959
bit

286
00:11:29,680 --> 00:11:34,959
um to think about things

287
00:11:32,959 --> 00:11:36,959
good then we move on to the next

288
00:11:34,959 --> 00:11:38,959
presentation

289
00:11:36,959 --> 00:11:41,199
this paper has the title amplifying the

290
00:11:38,959 --> 00:11:44,239
security of functional encryption

291
00:11:41,200 --> 00:11:46,399
unconditionally it's by ayush jane

292
00:11:44,240 --> 00:11:47,279
alexis corp nathan manohar and ahmed

293
00:11:46,399 --> 00:11:51,279
zahi

294
00:11:47,279 --> 00:11:51,279
and the presentation will be given by

295
00:11:54,839 --> 00:11:57,839
alexis

296
00:11:58,480 --> 00:12:03,760
okay cool so i'm alexis and

297
00:12:01,920 --> 00:12:05,519
uh our paper is on amplifying the

298
00:12:03,760 --> 00:12:07,680
security of functional encryption

299
00:12:05,519 --> 00:12:08,639
unconditionally and this is joint work

300
00:12:07,680 --> 00:12:11,920
with ayush jane

301
00:12:08,639 --> 00:12:13,519
nathan manahar and emits hi

302
00:12:11,920 --> 00:12:15,760
so to quickly review functional

303
00:12:13,519 --> 00:12:17,920
encryption and a functional encryption

304
00:12:15,760 --> 00:12:20,319
scheme an authority can give

305
00:12:17,920 --> 00:12:22,560
function keys to users and then the

306
00:12:20,320 --> 00:12:24,880
authority can encrypt the message m

307
00:12:22,560 --> 00:12:26,560
and correct as holes if a user with a

308
00:12:24,880 --> 00:12:28,480
function key for function m and the

309
00:12:26,560 --> 00:12:32,000
encryption of a message m can compute f

310
00:12:28,480 --> 00:12:33,839
m so for security we consider an

311
00:12:32,000 --> 00:12:35,279
adversary whose logic request function

312
00:12:33,839 --> 00:12:37,680
keys of his choice

313
00:12:35,279 --> 00:12:38,639
and then we'll output two messages m0

314
00:12:37,680 --> 00:12:40,319
and m1

315
00:12:38,639 --> 00:12:42,160
and security holds if the adversary

316
00:12:40,320 --> 00:12:43,120
cannot distinguish between an encryption

317
00:12:42,160 --> 00:12:46,160
of m0

318
00:12:43,120 --> 00:12:47,839
and an encryption m1 so since we're

319
00:12:46,160 --> 00:12:48,880
considering amplification we want to

320
00:12:47,839 --> 00:12:51,279
define a

321
00:12:48,880 --> 00:12:52,000
notion of weak security so we will

322
00:12:51,279 --> 00:12:54,240
define a

323
00:12:52,000 --> 00:12:55,519
p secure fe scheme to be one in which

324
00:12:54,240 --> 00:12:56,399
the distinguishing advantage of the

325
00:12:55,519 --> 00:12:59,279
adversary

326
00:12:56,399 --> 00:13:01,200
is at most p so as an example the

327
00:12:59,279 --> 00:13:02,560
standard notion of security will have p

328
00:13:01,200 --> 00:13:05,200
be some negligible function of the

329
00:13:02,560 --> 00:13:07,439
security parameter but more generally p

330
00:13:05,200 --> 00:13:10,160
can be any value between zero and one

331
00:13:07,440 --> 00:13:11,760
so for instance an fe scheme that leaks

332
00:13:10,160 --> 00:13:12,560
the message with probability one half

333
00:13:11,760 --> 00:13:16,160
would have p

334
00:13:12,560 --> 00:13:17,439
equals to one half so this brings us to

335
00:13:16,160 --> 00:13:19,279
amplification

336
00:13:17,440 --> 00:13:20,720
and amplification is where you take a

337
00:13:19,279 --> 00:13:22,240
weekly secure primitive

338
00:13:20,720 --> 00:13:24,079
and use it as a building block to

339
00:13:22,240 --> 00:13:26,399
construct a fully secure primitive

340
00:13:24,079 --> 00:13:27,439
of the same type so for instance we

341
00:13:26,399 --> 00:13:29,200
could take a

342
00:13:27,440 --> 00:13:30,880
fe scheme which is a camera probably one

343
00:13:29,200 --> 00:13:33,200
half and want to amplify it to a fully

344
00:13:30,880 --> 00:13:34,720
secure fps game

345
00:13:33,200 --> 00:13:36,480
so apart from being a fundamental

346
00:13:34,720 --> 00:13:38,079
question in its own right this is

347
00:13:36,480 --> 00:13:39,760
especially useful for effie

348
00:13:38,079 --> 00:13:41,760
since we currently do not know how to

349
00:13:39,760 --> 00:13:42,800
build the most general version fe for

350
00:13:41,760 --> 00:13:45,120
all functions

351
00:13:42,800 --> 00:13:46,959
from any standard assumptions so what

352
00:13:45,120 --> 00:13:48,959
amplification means is that if we can

353
00:13:46,959 --> 00:13:50,638
build even a weekly secure fe scheme

354
00:13:48,959 --> 00:13:52,239
from standard assumptions then this

355
00:13:50,639 --> 00:13:53,760
would imply the existence of a fully

356
00:13:52,240 --> 00:13:54,800
secure fe scheme from standard

357
00:13:53,760 --> 00:13:56,399
assumptions

358
00:13:54,800 --> 00:13:58,639
and building such a weekly security game

359
00:13:56,399 --> 00:14:01,040
may be quite a bit easier

360
00:13:58,639 --> 00:14:02,160
so also as a last note the results can

361
00:14:01,040 --> 00:14:04,079
be unconditional

362
00:14:02,160 --> 00:14:05,600
unlike in many other areas of crypto

363
00:14:04,079 --> 00:14:07,920
which just means that

364
00:14:05,600 --> 00:14:10,079
the security of the fully secure scheme

365
00:14:07,920 --> 00:14:11,439
is only dependent on the weak security

366
00:14:10,079 --> 00:14:13,519
of the weekly secure scheme

367
00:14:11,440 --> 00:14:16,160
[Music]

368
00:14:13,519 --> 00:14:16,720
so what has previously been done on ags

369
00:14:16,160 --> 00:14:19,279
18

370
00:14:16,720 --> 00:14:22,560
and ag lms19 they show that you can

371
00:14:19,279 --> 00:14:24,160
amplify fe from a 1-1 over poly lambda

372
00:14:22,560 --> 00:14:25,680
secure scheme which means that it's

373
00:14:24,160 --> 00:14:27,279
almost always broken

374
00:14:25,680 --> 00:14:30,000
to full security assuming

375
00:14:27,279 --> 00:14:31,279
sub-exponentially secure lwe

376
00:14:30,000 --> 00:14:33,199
and although i haven't defined these

377
00:14:31,279 --> 00:14:35,680
terms for those who know this preserves

378
00:14:33,199 --> 00:14:37,199
compactness and sublinearity

379
00:14:35,680 --> 00:14:38,800
they also have both polynomial and

380
00:14:37,199 --> 00:14:39,279
sub-exponential versions of their

381
00:14:38,800 --> 00:14:40,639
theorem

382
00:14:39,279 --> 00:14:43,360
which are against polynomial

383
00:14:40,639 --> 00:14:45,120
sub-exponential size adversaries

384
00:14:43,360 --> 00:14:48,480
and apart from these two works there are

385
00:14:45,120 --> 00:14:50,399
no other fe amplification results known

386
00:14:48,480 --> 00:14:52,639
so since they use sub-exponentially

387
00:14:50,399 --> 00:14:52,959
secure lwe this brings up the question

388
00:14:52,639 --> 00:14:55,120
of

389
00:14:52,959 --> 00:14:56,239
can we get amplification from weaker

390
00:14:55,120 --> 00:14:59,600
assumptions

391
00:14:56,240 --> 00:15:01,600
and the answer is yes so in our work we

392
00:14:59,600 --> 00:15:04,079
show that you can amplify fb from

393
00:15:01,600 --> 00:15:05,600
constant security to full security

394
00:15:04,079 --> 00:15:07,199
unconditionally

395
00:15:05,600 --> 00:15:09,040
and like the previous work this

396
00:15:07,199 --> 00:15:12,000
preserves compactness and has both

397
00:15:09,040 --> 00:15:14,000
polynomial and sub-exponential versions

398
00:15:12,000 --> 00:15:15,360
so just the note the previous work

399
00:15:14,000 --> 00:15:17,519
actually allows you to amplify from

400
00:15:15,360 --> 00:15:19,360
slightly weaker fe whereas iris requires

401
00:15:17,519 --> 00:15:20,959
at least constant security

402
00:15:19,360 --> 00:15:22,280
however our work has the major advantage

403
00:15:20,959 --> 00:15:24,800
that is unconditional

404
00:15:22,280 --> 00:15:26,959
[Music]

405
00:15:24,800 --> 00:15:28,560
so just as a high level overview of how

406
00:15:26,959 --> 00:15:29,599
we do this we have two steps

407
00:15:28,560 --> 00:15:31,839
amplification

408
00:15:29,600 --> 00:15:34,079
first we go from constant security to

409
00:15:31,839 --> 00:15:35,839
arbitrarily small constant security

410
00:15:34,079 --> 00:15:37,519
and then from a small enough constant

411
00:15:35,839 --> 00:15:39,759
secured scheme say less than one-sixth

412
00:15:37,519 --> 00:15:41,360
we can go to a fully secure scheme

413
00:15:39,759 --> 00:15:42,800
and the reason we do this in two steps

414
00:15:41,360 --> 00:15:44,000
is because we actually used two

415
00:15:42,800 --> 00:15:46,000
different constructions

416
00:15:44,000 --> 00:15:47,680
as the parameters were quite delicate

417
00:15:46,000 --> 00:15:49,279
and neither construction on its own was

418
00:15:47,680 --> 00:15:50,479
enough to provide the application we

419
00:15:49,279 --> 00:15:52,959
needed

420
00:15:50,480 --> 00:15:54,880
so as a couple more high level remarks

421
00:15:52,959 --> 00:15:56,959
for the first step we use a new nesting

422
00:15:54,880 --> 00:15:59,199
technique for hardcore measures

423
00:15:56,959 --> 00:16:00,880
and this also allows us to prove that a

424
00:15:59,199 --> 00:16:02,079
nested public key encryption scheme

425
00:16:00,880 --> 00:16:04,000
which is where you encrypt the

426
00:16:02,079 --> 00:16:05,120
encryption a message can also be

427
00:16:04,000 --> 00:16:06,480
amplified

428
00:16:05,120 --> 00:16:08,240
although we do already have

429
00:16:06,480 --> 00:16:10,560
amplification for public encryption

430
00:16:08,240 --> 00:16:12,240
it was not previously known how to prove

431
00:16:10,560 --> 00:16:14,079
that this simple nesting provided this

432
00:16:12,240 --> 00:16:16,800
amplification

433
00:16:14,079 --> 00:16:18,479
and then for our second transformation

434
00:16:16,800 --> 00:16:20,160
as couple high level remarks we use a

435
00:16:18,480 --> 00:16:21,680
form of parallel repetition

436
00:16:20,160 --> 00:16:23,279
and we introduce a new form of secret

437
00:16:21,680 --> 00:16:25,680
sharing that we call set homomorphic

438
00:16:23,279 --> 00:16:27,199
secret sharing

439
00:16:25,680 --> 00:16:29,279
so just in summary we show that you can

440
00:16:27,199 --> 00:16:32,319
amplify fe from constant security

441
00:16:29,279 --> 00:16:33,920
to full security unconditionally we show

442
00:16:32,320 --> 00:16:34,880
a new technique for amplifying nested

443
00:16:33,920 --> 00:16:36,719
primitives

444
00:16:34,880 --> 00:16:39,570
and we introduce set homomorphic secret

445
00:16:36,720 --> 00:16:44,000
sharing thank you

446
00:16:39,570 --> 00:16:46,720
[Music]

447
00:16:44,000 --> 00:16:47,360
okay thanks alexis for your talk um

448
00:16:46,720 --> 00:16:50,000
again

449
00:16:47,360 --> 00:16:50,720
if there's any question please let

450
00:16:50,000 --> 00:16:53,440
yourself

451
00:16:50,720 --> 00:16:53,440
be visible

452
00:16:54,800 --> 00:16:59,680
[Music]

453
00:16:57,519 --> 00:17:00,500
maybe one great question from from my

454
00:16:59,680 --> 00:17:02,000
side

455
00:17:00,500 --> 00:17:04,079
[Music]

456
00:17:02,000 --> 00:17:05,520
so you require epsilon security with

457
00:17:04,079 --> 00:17:09,678
constant epsilon

458
00:17:05,520 --> 00:17:11,359
um could you is it possible to sketch on

459
00:17:09,679 --> 00:17:13,360
a high level

460
00:17:11,359 --> 00:17:14,958
why this constant is necessary i mean i

461
00:17:13,359 --> 00:17:18,240
guess one would have expected

462
00:17:14,959 --> 00:17:21,839
noticeable or non-negligible maybe

463
00:17:18,240 --> 00:17:21,839
right yeah so for

464
00:17:21,919 --> 00:17:25,039
so parameters here were actually very

465
00:17:23,599 --> 00:17:27,918
delicate so for our second

466
00:17:25,039 --> 00:17:28,559
transformation there was a trade-off

467
00:17:27,919 --> 00:17:31,360
between

468
00:17:28,559 --> 00:17:32,000
security and correctness and so we had

469
00:17:31,360 --> 00:17:33,840
some equations

470
00:17:32,000 --> 00:17:35,280
for security and some equations for

471
00:17:33,840 --> 00:17:37,280
correctness and they were only

472
00:17:35,280 --> 00:17:38,639
satisfiable with a small enough constant

473
00:17:37,280 --> 00:17:41,840
security

474
00:17:38,640 --> 00:17:44,720
and then to increase this uh to

475
00:17:41,840 --> 00:17:45,120
any constant we could use nesting but it

476
00:17:44,720 --> 00:17:47,440
still

477
00:17:45,120 --> 00:17:49,039
was the parameters were still pretty

478
00:17:47,440 --> 00:17:51,360
delicate because the way we proved this

479
00:17:49,039 --> 00:17:52,480
was with hardcore measures and

480
00:17:51,360 --> 00:17:54,229
there are a lot of equations that need

481
00:17:52,480 --> 00:17:56,160
to be satisfied

482
00:17:54,230 --> 00:17:59,520
[Music]

483
00:17:56,160 --> 00:18:00,880
see thank you so there are a few more

484
00:17:59,520 --> 00:18:04,240
questions in the chat

485
00:18:00,880 --> 00:18:07,120
um sorry shopkoyal asks whether the

486
00:18:04,240 --> 00:18:10,160
amplification transform works also for

487
00:18:07,120 --> 00:18:13,760
the bounded collusion case

488
00:18:10,160 --> 00:18:15,440
uh yeah so so for we we prove it for uh

489
00:18:13,760 --> 00:18:18,240
selective security

490
00:18:15,440 --> 00:18:19,200
but you can actually if you have a

491
00:18:18,240 --> 00:18:21,440
sublinear

492
00:18:19,200 --> 00:18:22,240
fully secure fe scheme you can change

493
00:18:21,440 --> 00:18:24,880
that into

494
00:18:22,240 --> 00:18:25,840
a unban the collusion adaptive secure

495
00:18:24,880 --> 00:18:28,720
scheme

496
00:18:25,840 --> 00:18:30,480
so if you had a weak selective sublinary

497
00:18:28,720 --> 00:18:32,799
scheme you could amplify that

498
00:18:30,480 --> 00:18:33,919
and then turn that into a fully secure

499
00:18:32,799 --> 00:18:35,510
adaptive

500
00:18:33,919 --> 00:18:38,720
case

501
00:18:35,510 --> 00:18:42,799
[Music]

502
00:18:38,720 --> 00:18:45,280
i hope richard please let yourself

503
00:18:42,799 --> 00:18:46,720
uh um just to follow up on that uh so

504
00:18:45,280 --> 00:18:48,000
it's not about the compactness my

505
00:18:46,720 --> 00:18:48,640
question was more about bounded

506
00:18:48,000 --> 00:18:50,400
collisions

507
00:18:48,640 --> 00:18:52,400
if the number of keys that the adversary

508
00:18:50,400 --> 00:18:53,840
can get is a priority bounded then in

509
00:18:52,400 --> 00:18:54,559
that case does the amplification still

510
00:18:53,840 --> 00:18:57,199
work

511
00:18:54,559 --> 00:18:58,960
uh yes so you can also go from uh you

512
00:18:57,200 --> 00:19:00,400
can also go

513
00:18:58,960 --> 00:19:03,440
additionally to adaptive you can go to

514
00:19:00,400 --> 00:19:03,440
unbounded collusion as well

515
00:19:03,520 --> 00:19:07,280
from our selective security definition

516
00:19:07,520 --> 00:19:12,799
okay thanks

517
00:19:11,360 --> 00:19:14,399
so there's a there are a few more

518
00:19:12,799 --> 00:19:15,360
questions but i think they can be merged

519
00:19:14,400 --> 00:19:17,120
into one

520
00:19:15,360 --> 00:19:19,199
if you if you guys are not happy then

521
00:19:17,120 --> 00:19:21,520
just post another question but um so

522
00:19:19,200 --> 00:19:23,679
pratik sarkar and elaine

523
00:19:21,520 --> 00:19:24,799
uh asked whether you can briefly mention

524
00:19:23,679 --> 00:19:26,720
what is

525
00:19:24,799 --> 00:19:28,799
set homomorphic secret sharing and

526
00:19:26,720 --> 00:19:30,240
whether that's a form of homework

527
00:19:28,799 --> 00:19:32,240
encryption

528
00:19:30,240 --> 00:19:33,679
right so uh so homework is secret

529
00:19:32,240 --> 00:19:35,760
sharing is

530
00:19:33,679 --> 00:19:37,200
like a generalized version of function

531
00:19:35,760 --> 00:19:38,960
secret sharing

532
00:19:37,200 --> 00:19:40,880
so for function secret sharing you would

533
00:19:38,960 --> 00:19:42,960
break the function into function shares

534
00:19:40,880 --> 00:19:45,039
and the input into input shares

535
00:19:42,960 --> 00:19:47,600
and then you compute the function shares

536
00:19:45,039 --> 00:19:49,600
on the individual input shares

537
00:19:47,600 --> 00:19:51,360
independently and recombine them to get

538
00:19:49,600 --> 00:19:54,159
your function of your message

539
00:19:51,360 --> 00:19:55,600
so for set homomorphic secret sharing we

540
00:19:54,160 --> 00:19:57,520
are computing on

541
00:19:55,600 --> 00:19:59,280
sets of function input shares so we

542
00:19:57,520 --> 00:20:00,240
still break it into function shares and

543
00:19:59,280 --> 00:20:02,480
input shares

544
00:20:00,240 --> 00:20:03,440
and then we compute on different sets of

545
00:20:02,480 --> 00:20:05,520
them

546
00:20:03,440 --> 00:20:06,960
and so the reason we do this is because

547
00:20:05,520 --> 00:20:09,440
we don't know how to get function secret

548
00:20:06,960 --> 00:20:12,000
sharing from one-way functions

549
00:20:09,440 --> 00:20:13,280
so we had to create a set homework

550
00:20:12,000 --> 00:20:14,559
secret sharing which we could get from

551
00:20:13,280 --> 00:20:17,280
one-way functions

552
00:20:14,559 --> 00:20:18,960
and since weak fe implies weak one-way

553
00:20:17,280 --> 00:20:19,440
functions which can be amplified we can

554
00:20:18,960 --> 00:20:20,960
assume

555
00:20:19,440 --> 00:20:23,760
one-way functions and still get

556
00:20:20,960 --> 00:20:25,919
unconditional results

557
00:20:23,760 --> 00:20:28,000
so for our scheme what we would do is we

558
00:20:25,919 --> 00:20:31,520
would break it into secret shares

559
00:20:28,000 --> 00:20:32,880
and then we would put these into sets

560
00:20:31,520 --> 00:20:34,400
we would compute independently on the

561
00:20:32,880 --> 00:20:35,600
sets using our independent functional

562
00:20:34,400 --> 00:20:37,360
encryption schemes

563
00:20:35,600 --> 00:20:39,159
and then we could recombine the results

564
00:20:37,360 --> 00:20:43,199
to get our function of our message

565
00:20:39,160 --> 00:20:46,880
[Music]

566
00:20:43,200 --> 00:20:47,679
okay great so julie we have time for one

567
00:20:46,880 --> 00:20:49,520
quick question

568
00:20:47,679 --> 00:20:51,600
but yeah so i saw there are a few

569
00:20:49,520 --> 00:20:53,120
questions on zulip uh but and there's

570
00:20:51,600 --> 00:20:54,879
one more on the chat here so maybe we'll

571
00:20:53,120 --> 00:20:56,639
just take the one on from the chat here

572
00:20:54,880 --> 00:20:57,120
and then you can maybe uh answer later

573
00:20:56,640 --> 00:21:00,000
the one

574
00:20:57,120 --> 00:21:02,158
in zurich um and then we move on with

575
00:21:00,000 --> 00:21:05,039
the next session um

576
00:21:02,159 --> 00:21:06,240
and yeah british data asks whether you

577
00:21:05,039 --> 00:21:08,000
do require

578
00:21:06,240 --> 00:21:10,880
the start scheme to support general

579
00:21:08,000 --> 00:21:13,679
circuits i assume it means the fe scheme

580
00:21:10,880 --> 00:21:15,440
right uh yes so we would we do require

581
00:21:13,679 --> 00:21:16,080
our fe scheme to support general

582
00:21:15,440 --> 00:21:18,320
circuits

583
00:21:16,080 --> 00:21:21,039
because our amplification actually

584
00:21:18,320 --> 00:21:24,559
changes the circuit class that we use

585
00:21:21,039 --> 00:21:25,600
so we are requiring certain functions to

586
00:21:24,559 --> 00:21:27,600
be computed which

587
00:21:25,600 --> 00:21:29,039
are dependent on the circuit we want but

588
00:21:27,600 --> 00:21:32,559
also just

589
00:21:29,039 --> 00:21:35,200
should yeah so they have to be general

590
00:21:32,559 --> 00:21:36,799
okay great thank you very much alexis

591
00:21:35,200 --> 00:21:37,919
for the presentation and a very good

592
00:21:36,799 --> 00:21:39,760
discussion

593
00:21:37,919 --> 00:21:41,280
um so we move on to the next

594
00:21:39,760 --> 00:21:43,600
presentation

595
00:21:41,280 --> 00:21:46,158
um this one is about the dynamic

596
00:21:43,600 --> 00:21:49,439
decentralized functional encryption

597
00:21:46,159 --> 00:21:52,559
by jeremy schottar eduardo falzones

598
00:21:49,440 --> 00:21:53,760
uh romar gay donghyu fun and david

599
00:21:52,559 --> 00:21:56,840
porschel

600
00:21:53,760 --> 00:21:59,520
and the presentation will be given by

601
00:21:56,840 --> 00:22:02,559
eduardo you hear me everyone

602
00:21:59,520 --> 00:22:04,320
yes we can okay okay hi everyone so yeah

603
00:22:02,559 --> 00:22:05,760
i'm edward i'm gonna be talking about

604
00:22:04,320 --> 00:22:06,720
dynamic decentralized functional

605
00:22:05,760 --> 00:22:09,360
encryption

606
00:22:06,720 --> 00:22:10,159
or the dfe for short and again this is

607
00:22:09,360 --> 00:22:12,959
trying to work with

608
00:22:10,159 --> 00:22:12,960
jeremy schweitzer

609
00:22:15,679 --> 00:22:18,720
the situation we find ourselves in right

610
00:22:17,520 --> 00:22:22,559
now is that

611
00:22:18,720 --> 00:22:24,960
uh there's some kind of false dichotomy

612
00:22:22,559 --> 00:22:26,639
around the use of machine learning in

613
00:22:24,960 --> 00:22:28,480
software products

614
00:22:26,640 --> 00:22:31,120
so basically machine learning enables

615
00:22:28,480 --> 00:22:32,960
companies to gather everyone's data

616
00:22:31,120 --> 00:22:34,239
and then gather extremely valuable

617
00:22:32,960 --> 00:22:36,480
intelligence from it

618
00:22:34,240 --> 00:22:37,440
so that they can make inference and make

619
00:22:36,480 --> 00:22:39,200
their products better and

620
00:22:37,440 --> 00:22:40,640
make their services better but there's a

621
00:22:39,200 --> 00:22:41,679
privacy concern obviously because that

622
00:22:40,640 --> 00:22:43,679
means that

623
00:22:41,679 --> 00:22:45,600
a few institutions can gather i have to

624
00:22:43,679 --> 00:22:48,400
gather everyone's data

625
00:22:45,600 --> 00:22:50,879
so the false economy is that people seem

626
00:22:48,400 --> 00:22:52,840
to think that you either have to

627
00:22:50,880 --> 00:22:54,240
have machine learning and accept the

628
00:22:52,840 --> 00:22:55,439
privacy that's

629
00:22:54,240 --> 00:22:57,840
actually that you need to sacrifice your

630
00:22:55,440 --> 00:23:01,919
privacy or that you should

631
00:22:57,840 --> 00:23:03,678
renounce all of those benefits and then

632
00:23:01,919 --> 00:23:05,679
and then you can have privacy but you

633
00:23:03,679 --> 00:23:08,400
can no longer have smart products

634
00:23:05,679 --> 00:23:09,520
and if that were the actual choice i may

635
00:23:08,400 --> 00:23:10,240
choose privacy and you may choose

636
00:23:09,520 --> 00:23:11,760
privacy

637
00:23:10,240 --> 00:23:13,600
but we can see that most consumers

638
00:23:11,760 --> 00:23:16,320
choose machine learning so

639
00:23:13,600 --> 00:23:17,120
fortunately those are not the only ways

640
00:23:16,320 --> 00:23:19,600
forward

641
00:23:17,120 --> 00:23:20,639
we can have a third way which would be

642
00:23:19,600 --> 00:23:22,080
to train

643
00:23:20,640 --> 00:23:24,559
machine learning models without

644
00:23:22,080 --> 00:23:26,960
sacrificing privacy and that's uh

645
00:23:24,559 --> 00:23:28,080
what uh one one application that dynamic

646
00:23:26,960 --> 00:23:29,200
centralized functional encryption would

647
00:23:28,080 --> 00:23:31,280
enable

648
00:23:29,200 --> 00:23:32,960
so because we're a bit short on time i'm

649
00:23:31,280 --> 00:23:34,158
just gonna jump right in and give you an

650
00:23:32,960 --> 00:23:36,240
example of uh

651
00:23:34,159 --> 00:23:37,280
how that might work uh with that with

652
00:23:36,240 --> 00:23:39,039
ddfe

653
00:23:37,280 --> 00:23:40,960
uh and then i'm gonna say a few more

654
00:23:39,039 --> 00:23:42,480
things uh

655
00:23:40,960 --> 00:23:45,679
so for our example we would have four

656
00:23:42,480 --> 00:23:46,960
participants alice bob charlie and diane

657
00:23:45,679 --> 00:23:48,840
and they all have some pictures of

658
00:23:46,960 --> 00:23:50,880
themselves that they're storing on some

659
00:23:48,840 --> 00:23:53,600
device and

660
00:23:50,880 --> 00:23:54,640
that they uh they're basically they care

661
00:23:53,600 --> 00:23:58,240
about

662
00:23:54,640 --> 00:23:59,679
and so a company comes in and it might

663
00:23:58,240 --> 00:24:02,240
want to train

664
00:23:59,679 --> 00:24:03,679
some large model uh on this data so here

665
00:24:02,240 --> 00:24:05,200
this is only for the example and

666
00:24:03,679 --> 00:24:06,480
practice that's not something would be

667
00:24:05,200 --> 00:24:08,480
able today but that's something that the

668
00:24:06,480 --> 00:24:10,960
definitions would allow us to do

669
00:24:08,480 --> 00:24:13,039
and so the way it would work today is

670
00:24:10,960 --> 00:24:14,240
that probably automatically the device

671
00:24:13,039 --> 00:24:16,559
would upload the pictures to the

672
00:24:14,240 --> 00:24:18,880
company's server and then the

673
00:24:16,559 --> 00:24:20,399
the company would run some algorithm it

674
00:24:18,880 --> 00:24:21,600
would need to have the full images but

675
00:24:20,400 --> 00:24:22,880
then it would only extract some

676
00:24:21,600 --> 00:24:24,959
knowledge from it

677
00:24:22,880 --> 00:24:27,440
uh and that would enable it to uh

678
00:24:24,960 --> 00:24:28,720
provide better services

679
00:24:27,440 --> 00:24:30,840
so the issue is that that would be

680
00:24:28,720 --> 00:24:32,640
detrimental to the privacy of our

681
00:24:30,840 --> 00:24:34,000
participants so instead they would

682
00:24:32,640 --> 00:24:34,799
prefer to use something that protects

683
00:24:34,000 --> 00:24:37,200
their privacy

684
00:24:34,799 --> 00:24:38,158
and that's going to be ddf here so what

685
00:24:37,200 --> 00:24:38,799
they're going to do is they're going to

686
00:24:38,159 --> 00:24:42,000
encrypt

687
00:24:38,799 --> 00:24:43,520
all of their images and so the

688
00:24:42,000 --> 00:24:45,039
the that contains a ciphertext of their

689
00:24:43,520 --> 00:24:47,360
image and then there's

690
00:24:45,039 --> 00:24:48,799
some additional data which could be for

691
00:24:47,360 --> 00:24:49,520
instance the date so maybe they're gonna

692
00:24:48,799 --> 00:24:51,360
say

693
00:24:49,520 --> 00:24:52,799
i only want the company to be able to

694
00:24:51,360 --> 00:24:54,479
aggregate my data

695
00:24:52,799 --> 00:24:56,639
with the data of those other

696
00:24:54,480 --> 00:24:58,159
participants on this specific date

697
00:24:56,640 --> 00:24:59,360
so that then you can't mix and match

698
00:24:58,159 --> 00:25:00,559
between different dates and if we're

699
00:24:59,360 --> 00:25:01,039
going to be training a new neural

700
00:25:00,559 --> 00:25:04,000
network

701
00:25:01,039 --> 00:25:05,200
a month from now then we don't want we

702
00:25:04,000 --> 00:25:07,120
don't want you to be

703
00:25:05,200 --> 00:25:08,880
we don't want those datas to be able to

704
00:25:07,120 --> 00:25:10,320
be mixed together

705
00:25:08,880 --> 00:25:12,480
and then they also specify the set and

706
00:25:10,320 --> 00:25:14,639
so let's say as an example again

707
00:25:12,480 --> 00:25:16,640
that they're going to have to uh all

708
00:25:14,640 --> 00:25:18,960
agree on the set of participants

709
00:25:16,640 --> 00:25:20,640
so that uh so that the company can't

710
00:25:18,960 --> 00:25:22,240
tell alice that oh yeah we're only

711
00:25:20,640 --> 00:25:23,760
agreeing with bob and then tell diane

712
00:25:22,240 --> 00:25:25,200
that actually you're beginning with

713
00:25:23,760 --> 00:25:26,240
alice and bob and so on that shouldn't

714
00:25:25,200 --> 00:25:28,320
work

715
00:25:26,240 --> 00:25:29,520
so send the cipher text to the company

716
00:25:28,320 --> 00:25:31,600
because the cipher text

717
00:25:29,520 --> 00:25:33,360
the company doesn't see anything might

718
00:25:31,600 --> 00:25:36,000
as well be in cpa encryption

719
00:25:33,360 --> 00:25:37,360
and that's because ddfe is a functional

720
00:25:36,000 --> 00:25:40,320
encryption type scheme

721
00:25:37,360 --> 00:25:41,760
so you need functional keys so companies

722
00:25:40,320 --> 00:25:42,000
going to go back to the participants and

723
00:25:41,760 --> 00:25:43,840
ask

724
00:25:42,000 --> 00:25:45,600
for some keys to allow it to perform

725
00:25:43,840 --> 00:25:48,320
some computation

726
00:25:45,600 --> 00:25:49,840
and the keys are going to specify the

727
00:25:48,320 --> 00:25:51,360
type of computation that they're that

728
00:25:49,840 --> 00:25:53,039
the company is allowed to do so here's

729
00:25:51,360 --> 00:25:54,240
going to be a neural network training

730
00:25:53,039 --> 00:25:55,840
and probably it's going to specify a

731
00:25:54,240 --> 00:25:57,200
bunch of things like hyper parameters

732
00:25:55,840 --> 00:25:58,480
and the specific way that neural network

733
00:25:57,200 --> 00:26:00,159
is going to be trained

734
00:25:58,480 --> 00:26:01,600
and then again the set of participants

735
00:26:00,159 --> 00:26:02,799
and let's say that they we can all have

736
00:26:01,600 --> 00:26:04,879
to agree on the exact set of

737
00:26:02,799 --> 00:26:06,799
participants

738
00:26:04,880 --> 00:26:08,240
so now the company has all it needs so

739
00:26:06,799 --> 00:26:10,320
you can mix the

740
00:26:08,240 --> 00:26:11,679
the keys with the cipher text and

741
00:26:10,320 --> 00:26:14,000
perform some computations

742
00:26:11,679 --> 00:26:14,880
that enable it to uh to get back that

743
00:26:14,000 --> 00:26:16,799
model

744
00:26:14,880 --> 00:26:19,039
that is uh that's like valuable

745
00:26:16,799 --> 00:26:21,120
intelligence but it never gets to see

746
00:26:19,039 --> 00:26:24,879
the individual pictures doesn't learn

747
00:26:21,120 --> 00:26:27,678
anything besides the resulting model

748
00:26:24,880 --> 00:26:28,799
so for running that type of uh of

749
00:26:27,679 --> 00:26:30,400
computation

750
00:26:28,799 --> 00:26:32,240
there are a few existing solutions that

751
00:26:30,400 --> 00:26:34,559
you might have thought about and

752
00:26:32,240 --> 00:26:35,760
the reason we had to introduce ddf is

753
00:26:34,559 --> 00:26:38,080
that we felt there were a few things

754
00:26:35,760 --> 00:26:39,120
that were lacking in each of those so

755
00:26:38,080 --> 00:26:41,039
one thing you might have thought about

756
00:26:39,120 --> 00:26:44,479
because it's a very popular solution

757
00:26:41,039 --> 00:26:46,320
for doing um cloud computations on uh

758
00:26:44,480 --> 00:26:47,760
privacy sensitive data is fully

759
00:26:46,320 --> 00:26:49,279
homomorphic encryption

760
00:26:47,760 --> 00:26:50,799
and the issue is that it is it would be

761
00:26:49,279 --> 00:26:52,000
non-interactive with the application

762
00:26:50,799 --> 00:26:53,440
we're thinking about

763
00:26:52,000 --> 00:26:55,440
meaning that once you run a full

764
00:26:53,440 --> 00:26:57,360
homomorphic uh evaluation

765
00:26:55,440 --> 00:26:58,559
you get better you get back a cipher

766
00:26:57,360 --> 00:27:00,719
text

767
00:26:58,559 --> 00:27:01,760
well uh well with ddf you can get back a

768
00:27:00,720 --> 00:27:03,919
plain text

769
00:27:01,760 --> 00:27:05,120
so if you get cipher text then the

770
00:27:03,919 --> 00:27:07,360
company would have to go back to the

771
00:27:05,120 --> 00:27:09,360
participants to ask for this description

772
00:27:07,360 --> 00:27:10,799
that makes it more complicated we'd want

773
00:27:09,360 --> 00:27:12,559
something where like the participants

774
00:27:10,799 --> 00:27:14,400
are just sending here's my data

775
00:27:12,559 --> 00:27:15,918
there's an authorization to compute and

776
00:27:14,400 --> 00:27:17,440
from that from then on

777
00:27:15,919 --> 00:27:20,640
they can go offline and the company

778
00:27:17,440 --> 00:27:22,799
manages everything then there was a

779
00:27:20,640 --> 00:27:24,399
gmc fe so this decentralized

780
00:27:22,799 --> 00:27:26,320
multi-client functional encryption which

781
00:27:24,399 --> 00:27:28,399
we introduced in 2018

782
00:27:26,320 --> 00:27:30,399
uh it was not interactive but it's like

783
00:27:28,399 --> 00:27:31,918
dynamicity meaning you had to

784
00:27:30,399 --> 00:27:33,678
agree on the set of participants at the

785
00:27:31,919 --> 00:27:34,159
beginning of time it would have just

786
00:27:33,679 --> 00:27:36,720
been

787
00:27:34,159 --> 00:27:38,240
alice bob charlie and diane and then

788
00:27:36,720 --> 00:27:39,919
they wouldn't have been able to be

789
00:27:38,240 --> 00:27:41,200
joined by someone else without rerunning

790
00:27:39,919 --> 00:27:42,720
an entire setup

791
00:27:41,200 --> 00:27:44,799
which makes it inconvenient for most

792
00:27:42,720 --> 00:27:48,159
practical applications

793
00:27:44,799 --> 00:27:49,918
and uh and last year ad hoc multi-input

794
00:27:48,159 --> 00:27:51,520
functional encryption was introduced

795
00:27:49,919 --> 00:27:53,039
which was dynamic so now you could just

796
00:27:51,520 --> 00:27:55,520
choose your set of participants

797
00:27:53,039 --> 00:27:56,080
as you went uh but unfortunately it's

798
00:27:55,520 --> 00:27:58,320
lacked

799
00:27:56,080 --> 00:27:59,600
the full exclusive power that so much

800
00:27:58,320 --> 00:28:00,559
functional encryption had brought for

801
00:27:59,600 --> 00:28:02,320
single input

802
00:28:00,559 --> 00:28:04,639
functional encryption functionalities

803
00:28:02,320 --> 00:28:06,080
meaning that the the definitions were

804
00:28:04,640 --> 00:28:08,080
somewhat tailored to the constructions

805
00:28:06,080 --> 00:28:09,279
they were bringing forward uh

806
00:28:08,080 --> 00:28:10,879
and some of the construction that we

807
00:28:09,279 --> 00:28:11,440
bring forward could not be captured by

808
00:28:10,880 --> 00:28:13,600
that

809
00:28:11,440 --> 00:28:15,360
so we we also do we wanted to be careful

810
00:28:13,600 --> 00:28:16,399
to define something that could be an

811
00:28:15,360 --> 00:28:18,240
umbrella notion

812
00:28:16,399 --> 00:28:20,399
and be able to express all kinds of

813
00:28:18,240 --> 00:28:22,159
decentralized computations

814
00:28:20,399 --> 00:28:23,520
so finally i'm going to recap capturing

815
00:28:22,159 --> 00:28:25,440
our contributions

816
00:28:23,520 --> 00:28:26,639
uh we started by defining dynamic

817
00:28:25,440 --> 00:28:28,080
decentralized functional encryption

818
00:28:26,640 --> 00:28:29,919
which you think can be a

819
00:28:28,080 --> 00:28:31,918
useful umbrella notion and we also

820
00:28:29,919 --> 00:28:33,200
provided some security definitions

821
00:28:31,919 --> 00:28:35,279
and then we provided the three

822
00:28:33,200 --> 00:28:38,000
constructions uh each of

823
00:28:35,279 --> 00:28:39,679
which depends on uh on the previous ones

824
00:28:38,000 --> 00:28:41,840
so the first uh the

825
00:28:39,679 --> 00:28:42,720
the first uh dds functionality we

826
00:28:41,840 --> 00:28:45,039
introduce

827
00:28:42,720 --> 00:28:46,559
is aurora all-or-nothing encapsulation

828
00:28:45,039 --> 00:28:47,279
and basically it's something that's

829
00:28:46,559 --> 00:28:48,960
useful

830
00:28:47,279 --> 00:28:51,440
for proving security in the other

831
00:28:48,960 --> 00:28:53,279
schemes uh because sometimes the

832
00:28:51,440 --> 00:28:55,120
the natural notion of security just you

833
00:28:53,279 --> 00:28:56,720
can't quite get that without a layer of

834
00:28:55,120 --> 00:28:58,320
colonoscopy encapsulation

835
00:28:56,720 --> 00:29:00,880
we construct that from identity based

836
00:28:58,320 --> 00:29:02,799
encryption in a black box way

837
00:29:00,880 --> 00:29:04,159
then we construct something for which we

838
00:29:02,799 --> 00:29:06,720
call decentralized term

839
00:29:04,159 --> 00:29:08,960
which is uh for uh for computing us

840
00:29:06,720 --> 00:29:10,640
prograding sounds with other parties

841
00:29:08,960 --> 00:29:12,000
and we give a black box instruction from

842
00:29:10,640 --> 00:29:14,240
that for that from

843
00:29:12,000 --> 00:29:16,399
uh an uninteractive key exchange and

844
00:29:14,240 --> 00:29:18,799
again allanon encapsulation

845
00:29:16,399 --> 00:29:20,559
and finally we construct in our product

846
00:29:18,799 --> 00:29:21,520
uh dynamic decentralized functional

847
00:29:20,559 --> 00:29:23,840
encryption

848
00:29:21,520 --> 00:29:25,279
and that allows you as used earlier to

849
00:29:23,840 --> 00:29:27,520
compute weighted sums

850
00:29:25,279 --> 00:29:29,120
uh on on input data where the weights

851
00:29:27,520 --> 00:29:32,559
come from the functional keys

852
00:29:29,120 --> 00:29:35,279
and the the the values come from

853
00:29:32,559 --> 00:29:36,480
ciphertext and that relies on all the

854
00:29:35,279 --> 00:29:38,840
aforementioned constructions

855
00:29:36,480 --> 00:29:40,720
and on primary groups and so all of

856
00:29:38,840 --> 00:29:43,760
those constructions

857
00:29:40,720 --> 00:29:47,039
are fairly uh fairly practical

858
00:29:43,760 --> 00:29:49,120
so it's like possible that you might be

859
00:29:47,039 --> 00:29:50,640
able to implement and use them today

860
00:29:49,120 --> 00:29:51,918
and i think there are lots of

861
00:29:50,640 --> 00:29:53,840
opportunities for building a more

862
00:29:51,919 --> 00:29:56,000
complex and more interesting

863
00:29:53,840 --> 00:29:58,158
functionalities to i look forward to

864
00:29:56,000 --> 00:30:00,080
follow workforce on that

865
00:29:58,159 --> 00:30:01,600
and so that's it for my talk thank you

866
00:30:00,080 --> 00:30:03,439
please check out the full paper

867
00:30:01,600 --> 00:30:06,799
or the video online if you want more

868
00:30:03,440 --> 00:30:06,799
details and thank you to these questions

869
00:30:06,840 --> 00:30:11,439
now

870
00:30:08,720 --> 00:30:12,960
okay thanks edward for the talk and as

871
00:30:11,440 --> 00:30:22,720
before if you have questions

872
00:30:12,960 --> 00:30:26,559
don't be shy

873
00:30:22,720 --> 00:30:28,240
um okay maybe let me start um

874
00:30:26,559 --> 00:30:29,840
you mentioned that uh for this

875
00:30:28,240 --> 00:30:31,679
distributed sum you need

876
00:30:29,840 --> 00:30:33,520
a non-interactive key exchange can you

877
00:30:31,679 --> 00:30:36,080
elaborate on which kind of manufacture

878
00:30:33,520 --> 00:30:38,480
key exchange you you need for that or on

879
00:30:36,080 --> 00:30:41,199
the construction that you actually use

880
00:30:38,480 --> 00:30:42,080
yeah sure so i mean basically that's a

881
00:30:41,200 --> 00:30:44,480
the notion of

882
00:30:42,080 --> 00:30:45,760
uh usually we require some notion of

883
00:30:44,480 --> 00:30:48,000
security which uh

884
00:30:45,760 --> 00:30:49,840
basically the notion of security like

885
00:30:48,000 --> 00:30:51,360
how well your non-interactive exchange

886
00:30:49,840 --> 00:30:54,320
tolerates corruption

887
00:30:51,360 --> 00:30:55,279
is going to translate into uh how well

888
00:30:54,320 --> 00:30:57,519
your g-sum

889
00:30:55,279 --> 00:30:59,279
tolerates corruption so we proved that

890
00:30:57,519 --> 00:31:00,399
for like this the strongest notion but

891
00:30:59,279 --> 00:31:01,600
then you can have all kinds of

892
00:31:00,399 --> 00:31:04,959
variations

893
00:31:01,600 --> 00:31:06,559
um maybe if you're trying to get a hint

894
00:31:04,960 --> 00:31:09,679
of sort of what the

895
00:31:06,559 --> 00:31:12,158
construction uh looks like it's uh

896
00:31:09,679 --> 00:31:13,360
based on the idea of some of prfs from

897
00:31:12,159 --> 00:31:16,720
jason show

898
00:31:13,360 --> 00:31:17,279
2009 and uh basically the way it works

899
00:31:16,720 --> 00:31:18,080
is

900
00:31:17,279 --> 00:31:20,240
you're going to have this set of

901
00:31:18,080 --> 00:31:21,918
participants that want to continue some

902
00:31:20,240 --> 00:31:26,000
on the fly

903
00:31:21,919 --> 00:31:28,240
and uh they want to compute some mask

904
00:31:26,000 --> 00:31:29,679
that for their own data that would

905
00:31:28,240 --> 00:31:31,760
cancel out with the data

906
00:31:29,679 --> 00:31:33,600
of the other participants so if i can if

907
00:31:31,760 --> 00:31:35,519
we can all have some random value

908
00:31:33,600 --> 00:31:38,000
so that the sum of the random values is

909
00:31:35,519 --> 00:31:39,919
zero uh then we can just use use that

910
00:31:38,000 --> 00:31:41,279
random value to hide our data

911
00:31:39,919 --> 00:31:43,120
and then summing everything together

912
00:31:41,279 --> 00:31:45,440
we're gonna get back to sum right

913
00:31:43,120 --> 00:31:47,199
so the question is like can you actually

914
00:31:45,440 --> 00:31:48,720
compute this random value

915
00:31:47,200 --> 00:31:50,240
in a non-interactive way without

916
00:31:48,720 --> 00:31:52,240
actually going through some protocol and

917
00:31:50,240 --> 00:31:54,000
communicating but just by knowing

918
00:31:52,240 --> 00:31:56,240
some other part is probably key then can

919
00:31:54,000 --> 00:31:57,840
you sample that random value

920
00:31:56,240 --> 00:31:59,840
and the way you do that is turn on an

921
00:31:57,840 --> 00:32:00,879
interactive key exchange you compute a

922
00:31:59,840 --> 00:32:02,799
shared mask with

923
00:32:00,880 --> 00:32:04,480
uh another quality so it's i'm going to

924
00:32:02,799 --> 00:32:06,080
compute a shared mask with you

925
00:32:04,480 --> 00:32:07,760
and you can compute that same mask it's

926
00:32:06,080 --> 00:32:10,399
not interactive key exchange

927
00:32:07,760 --> 00:32:11,519
and now we're gonna we're gonna one of

928
00:32:10,399 --> 00:32:14,080
the one of us is gonna

929
00:32:11,519 --> 00:32:14,880
flip this mask by adding a minus sign to

930
00:32:14,080 --> 00:32:17,918
it

931
00:32:14,880 --> 00:32:19,919
and now and we so we compute all those

932
00:32:17,919 --> 00:32:22,159
maps for all those participants and we

933
00:32:19,919 --> 00:32:23,679
add all the masks that we get together

934
00:32:22,159 --> 00:32:24,480
and then when we sum all of those masks

935
00:32:23,679 --> 00:32:25,919
together

936
00:32:24,480 --> 00:32:28,320
because some of them has a plus sign and

937
00:32:25,919 --> 00:32:30,960
some of them have a minus sign they all

938
00:32:28,320 --> 00:32:32,399
cancel out and you can get back to some

939
00:32:30,960 --> 00:32:34,799
god let me know if that doesn't answer

940
00:32:32,399 --> 00:32:37,039
your question yeah yeah i

941
00:32:34,799 --> 00:32:39,200
i i guess you assume also that the

942
00:32:37,039 --> 00:32:41,200
participant has somehow appreciated

943
00:32:39,200 --> 00:32:43,200
random secret because otherwise like

944
00:32:41,200 --> 00:32:44,399
yeah doing so fully non-interactive key

945
00:32:43,200 --> 00:32:46,559
exchanges

946
00:32:44,399 --> 00:32:48,080
from from assumptions is a big open

947
00:32:46,559 --> 00:32:49,600
problem so yeah yeah i was wondering

948
00:32:48,080 --> 00:32:52,399
okay yeah

949
00:32:49,600 --> 00:32:53,760
they do uh uh i mean we're in the rhonda

950
00:32:52,399 --> 00:32:57,840
miracle model if that's

951
00:32:53,760 --> 00:32:57,840
uh which

952
00:33:00,480 --> 00:33:04,799
yeah okay so uh sorry to interrupt this

953
00:33:02,880 --> 00:33:06,640
is exciting but we have to move on to

954
00:33:04,799 --> 00:33:07,918
give the other speakers enough time so

955
00:33:06,640 --> 00:33:09,440
thank you very much um

956
00:33:07,919 --> 00:33:12,000
for the good presentation and do a great

957
00:33:09,440 --> 00:33:15,039
discussion so next coming up

958
00:33:12,000 --> 00:33:17,760
is the paper on succinct arguments

959
00:33:15,039 --> 00:33:20,399
and witness encryption from groups this

960
00:33:17,760 --> 00:33:22,799
is joint work of what batter yuval is

961
00:33:20,399 --> 00:33:24,158
rafaelski and david wu

962
00:33:22,799 --> 00:33:26,799
and what is going to give the

963
00:33:24,159 --> 00:33:29,279
presentation

964
00:33:26,799 --> 00:33:30,399
hey so thank you for the introduction so

965
00:33:29,279 --> 00:33:32,159
indeed i present

966
00:33:30,399 --> 00:33:34,080
and the walkon succinct arguments and

967
00:33:32,159 --> 00:33:35,600
witness encryption from groups

968
00:33:34,080 --> 00:33:38,399
which i meant with you alicia

969
00:33:35,600 --> 00:33:40,719
fellowstovsky and david

970
00:33:38,399 --> 00:33:42,719
so our motivating questions coming to

971
00:33:40,720 --> 00:33:44,080
this research well first how short can a

972
00:33:42,720 --> 00:33:45,919
proof be

973
00:33:44,080 --> 00:33:47,678
and the second the motivating question

974
00:33:45,919 --> 00:33:50,399
is can we build witness encryption from

975
00:33:47,679 --> 00:33:53,279
so-called 20th century cryptography

976
00:33:50,399 --> 00:33:54,959
and those questions look very different

977
00:33:53,279 --> 00:33:56,000
uh but they turn out to be actually

978
00:33:54,960 --> 00:33:57,679
related

979
00:33:56,000 --> 00:33:59,760
and we studied them both in the generic

980
00:33:57,679 --> 00:34:02,480
group model which was offered by shu

981
00:33:59,760 --> 00:34:04,399
in the 20th century so for the first

982
00:34:02,480 --> 00:34:06,159
question of how short books can be we

983
00:34:04,399 --> 00:34:08,239
look mainly on designated verified

984
00:34:06,159 --> 00:34:09,919
succinct non-interactive arguments or

985
00:34:08,239 --> 00:34:11,279
this is snug for short

986
00:34:09,918 --> 00:34:13,279
in which we have like any

987
00:34:11,280 --> 00:34:15,119
non-interactive argument a prover that

988
00:34:13,280 --> 00:34:17,440
wants to convince the very file

989
00:34:15,119 --> 00:34:18,560
and he needs to send him as short of as

990
00:34:17,440 --> 00:34:20,079
possible

991
00:34:18,560 --> 00:34:21,918
and we allow them to use a common

992
00:34:20,079 --> 00:34:25,040
reference string which was

993
00:34:21,918 --> 00:34:25,918
a generator that it was pre-processing

994
00:34:25,040 --> 00:34:27,918
stage

995
00:34:25,918 --> 00:34:29,520
by trusted setup as well as a secret

996
00:34:27,918 --> 00:34:32,000
verification key

997
00:34:29,520 --> 00:34:33,280
and as usual we demand completeness and

998
00:34:32,000 --> 00:34:36,399
soundness

999
00:34:33,280 --> 00:34:39,119
so as a lot of previous works

1000
00:34:36,399 --> 00:34:40,000
on snugs and the most uh succinct

1001
00:34:39,119 --> 00:34:42,079
practical

1002
00:34:40,000 --> 00:34:44,159
uh snug was offered by a ghost in this

1003
00:34:42,079 --> 00:34:45,919
europe 16 paper

1004
00:34:44,159 --> 00:34:47,440
it includes three group elements in a

1005
00:34:45,918 --> 00:34:49,679
millennial group setting which in

1006
00:34:47,440 --> 00:34:50,560
practice translates to just over 1000

1007
00:34:49,679 --> 00:34:52,879
bits

1008
00:34:50,560 --> 00:34:55,520
a suggestion to snugs with less than 1

1009
00:34:52,879 --> 00:34:56,639
000 bits rely on classical pcp on

1010
00:34:55,520 --> 00:34:59,040
obfuscation and

1011
00:34:56,639 --> 00:35:00,720
thus considered impractical and this

1012
00:34:59,040 --> 00:35:03,680
leaves up on the question of can we

1013
00:35:00,720 --> 00:35:06,078
improve the substance of practical snugs

1014
00:35:03,680 --> 00:35:07,200
and we give a construction of designated

1015
00:35:06,079 --> 00:35:09,599
verifier snug

1016
00:35:07,200 --> 00:35:11,359
which is practical it has two group

1017
00:35:09,599 --> 00:35:11,680
elements in the generic group model so

1018
00:35:11,359 --> 00:35:14,960
it

1019
00:35:11,680 --> 00:35:17,759
is two times shorter than go 16 it has

1020
00:35:14,960 --> 00:35:20,000
10 times faster verification and also

1021
00:35:17,760 --> 00:35:21,599
uses less structure than go 16 standard

1022
00:35:20,000 --> 00:35:24,000
groups and not millennial

1023
00:35:21,599 --> 00:35:25,599
the downside beyond giving up on public

1024
00:35:24,000 --> 00:35:27,440
qualification is that it has a

1025
00:35:25,599 --> 00:35:27,920
relatively large common reference thing

1026
00:35:27,440 --> 00:35:30,320
and slow

1027
00:35:27,920 --> 00:35:31,440
over time they are reasonable for small

1028
00:35:30,320 --> 00:35:35,440
circuits but

1029
00:35:31,440 --> 00:35:37,599
they don't scare well and we also

1030
00:35:35,440 --> 00:35:38,880
achieve only small yet non-negligible

1031
00:35:37,599 --> 00:35:41,119
soundness level

1032
00:35:38,880 --> 00:35:42,720
as us this contraction construction is

1033
00:35:41,119 --> 00:35:44,480
attractive for weak or energy

1034
00:35:42,720 --> 00:35:45,839
constrained very files

1035
00:35:44,480 --> 00:35:47,839
and we are able to achieve this

1036
00:35:45,839 --> 00:35:48,880
designated verifies now using something

1037
00:35:47,839 --> 00:35:51,520
that we call a

1038
00:35:48,880 --> 00:35:53,440
packing technique for linear pcps so in

1039
00:35:51,520 --> 00:35:55,599
linear pcps we have verified

1040
00:35:53,440 --> 00:35:57,839
as it makes linear queries to a both

1041
00:35:55,599 --> 00:36:00,160
vector and they tend to be simpler and

1042
00:35:57,839 --> 00:36:02,160
more efficient than classical pcps

1043
00:36:00,160 --> 00:36:04,960
and by time scatter show the reduction

1044
00:36:02,160 --> 00:36:05,759
from classical pcp to one query linear

1045
00:36:04,960 --> 00:36:07,680
pcp

1046
00:36:05,760 --> 00:36:09,359
and from there to a single cipher that's

1047
00:36:07,680 --> 00:36:10,560
designated very fast now which in

1048
00:36:09,359 --> 00:36:13,119
particular

1049
00:36:10,560 --> 00:36:14,000
two elements in a generic group and we

1050
00:36:13,119 --> 00:36:16,800
are able to show

1051
00:36:14,000 --> 00:36:19,119
another route to one query linear pcp

1052
00:36:16,800 --> 00:36:20,960
that does not start from classical pcp

1053
00:36:19,119 --> 00:36:22,240
using something that we called query

1054
00:36:20,960 --> 00:36:24,320
packing technique

1055
00:36:22,240 --> 00:36:26,240
and we refer to the external talk in the

1056
00:36:24,320 --> 00:36:28,400
paper for more details

1057
00:36:26,240 --> 00:36:29,839
and for the our second question we

1058
00:36:28,400 --> 00:36:32,000
consider witness encryption which

1059
00:36:29,839 --> 00:36:33,839
introduced by gargatel and is defined

1060
00:36:32,000 --> 00:36:35,599
with respect to relational

1061
00:36:33,839 --> 00:36:37,279
so in witness encryption we have them

1062
00:36:35,599 --> 00:36:39,680
clicked algorithm that gets

1063
00:36:37,280 --> 00:36:41,280
a message m and an instance x and it

1064
00:36:39,680 --> 00:36:43,118
outputs a cipher text

1065
00:36:41,280 --> 00:36:44,960
and we demand that an efficient

1066
00:36:43,119 --> 00:36:47,760
decryption algorithm can recover

1067
00:36:44,960 --> 00:36:48,400
m only if it gets weakness such that x

1068
00:36:47,760 --> 00:36:51,920
and w

1069
00:36:48,400 --> 00:36:53,839
are in the relation out and it is a hub

1070
00:36:51,920 --> 00:36:55,440
for a lot of cryptography application

1071
00:36:53,839 --> 00:36:57,279
and can be used to build public key

1072
00:36:55,440 --> 00:36:58,880
encryption identity-based encryption

1073
00:36:57,280 --> 00:37:02,320
attribute-based encryption

1074
00:36:58,880 --> 00:37:03,920
and so on so known constructions of

1075
00:37:02,320 --> 00:37:06,079
weakness encryption are currently based

1076
00:37:03,920 --> 00:37:08,400
on multi-linear maps or relatively

1077
00:37:06,079 --> 00:37:10,640
unexplored algebraic structures

1078
00:37:08,400 --> 00:37:12,160
and our theoretical contribution is

1079
00:37:10,640 --> 00:37:14,480
weakness encryption construction

1080
00:37:12,160 --> 00:37:16,000
in the generic book model that relies

1081
00:37:14,480 --> 00:37:17,119
only on hardness of approximation

1082
00:37:16,000 --> 00:37:18,480
hypothesis

1083
00:37:17,119 --> 00:37:21,680
this sentence of approximation

1084
00:37:18,480 --> 00:37:22,720
hypothesis may be proven unconditionally

1085
00:37:21,680 --> 00:37:24,799
in the future

1086
00:37:22,720 --> 00:37:26,560
and thus we rule out negative results

1087
00:37:24,800 --> 00:37:27,680
about witness encryption in the generic

1088
00:37:26,560 --> 00:37:30,640
group model

1089
00:37:27,680 --> 00:37:31,359
and this way also opens the way for even

1090
00:37:30,640 --> 00:37:32,960
a

1091
00:37:31,359 --> 00:37:35,440
newer and better constructions of

1092
00:37:32,960 --> 00:37:37,040
weakness encryption in the future

1093
00:37:35,440 --> 00:37:38,800
so what is the connection between

1094
00:37:37,040 --> 00:37:40,640
witness encryption and the succinct

1095
00:37:38,800 --> 00:37:42,320
arguments the connection is

1096
00:37:40,640 --> 00:37:44,960
something that is called predictable

1097
00:37:42,320 --> 00:37:45,760
argument in predictable argument at

1098
00:37:44,960 --> 00:37:47,920
every round

1099
00:37:45,760 --> 00:37:49,680
the verifier has at most one predictable

1100
00:37:47,920 --> 00:37:50,960
answer that wouldn't cause him to reject

1101
00:37:49,680 --> 00:37:53,279
and all the other

1102
00:37:50,960 --> 00:37:55,440
answers would surely cause him to reject

1103
00:37:53,280 --> 00:37:57,119
if only hotel defines this

1104
00:37:55,440 --> 00:37:59,200
notion and shows its predictable

1105
00:37:57,119 --> 00:38:00,800
argument with negligible songs implies

1106
00:37:59,200 --> 00:38:02,640
witness encryption

1107
00:38:00,800 --> 00:38:04,560
so our method to obtain weakness

1108
00:38:02,640 --> 00:38:06,799
encryption is to show a predictable

1109
00:38:04,560 --> 00:38:08,799
argument in the generic work model

1110
00:38:06,800 --> 00:38:10,800
and we are doing so by looking on the

1111
00:38:08,800 --> 00:38:12,640
gap minimal distance problem

1112
00:38:10,800 --> 00:38:14,560
uh which is to determine if the minimal

1113
00:38:12,640 --> 00:38:16,640
distance of a linear code generated by

1114
00:38:14,560 --> 00:38:18,400
matrix a is smaller than d or larger

1115
00:38:16,640 --> 00:38:19,920
than better time to be

1116
00:38:18,400 --> 00:38:22,240
there are many previous works that

1117
00:38:19,920 --> 00:38:23,920
considered this problem starting from

1118
00:38:22,240 --> 00:38:25,919
the work of dumeritel

1119
00:38:23,920 --> 00:38:27,200
and they showed that that reduces to gap

1120
00:38:25,920 --> 00:38:28,880
minimal distance problem in

1121
00:38:27,200 --> 00:38:31,200
quasi-polynomial time

1122
00:38:28,880 --> 00:38:32,800
when the gap approximation parameter is

1123
00:38:31,200 --> 00:38:34,480
omega of log n the field size is

1124
00:38:32,800 --> 00:38:36,800
polynomial in n

1125
00:38:34,480 --> 00:38:38,640
we need something that is very similar

1126
00:38:36,800 --> 00:38:39,920
we need that that would reduce the gap

1127
00:38:38,640 --> 00:38:42,319
minimal distance problem

1128
00:38:39,920 --> 00:38:44,480
in polynomial time when the

1129
00:38:42,320 --> 00:38:46,480
approximation gap is the same omega of

1130
00:38:44,480 --> 00:38:46,960
log n and the field is slightly larger

1131
00:38:46,480 --> 00:38:50,160
so

1132
00:38:46,960 --> 00:38:52,079
a quasi-polynomial as this hypothesis

1133
00:38:50,160 --> 00:38:53,920
seems very plausible to experts in the

1134
00:38:52,079 --> 00:38:54,640
field it does not see any better to

1135
00:38:53,920 --> 00:38:57,359
prove it

1136
00:38:54,640 --> 00:38:58,078
unconditionally in the future so to

1137
00:38:57,359 --> 00:39:00,078
summarize

1138
00:38:58,079 --> 00:39:01,520
we show the first practical designated

1139
00:39:00,079 --> 00:39:03,119
verifiable snag with only

1140
00:39:01,520 --> 00:39:05,359
two group elements in the generic group

1141
00:39:03,119 --> 00:39:06,720
model we showed witness encryption the

1142
00:39:05,359 --> 00:39:08,480
generic book model

1143
00:39:06,720 --> 00:39:11,040
under plausible complexity theoretical

1144
00:39:08,480 --> 00:39:13,760
hypothesis and we referred to the paper

1145
00:39:11,040 --> 00:39:14,800
for an extra minor result such as

1146
00:39:13,760 --> 00:39:17,599
neo-linear

1147
00:39:14,800 --> 00:39:19,359
pcp constructions and efficiency

1148
00:39:17,599 --> 00:39:22,880
tradeoffs and zero knowledge in our

1149
00:39:19,359 --> 00:39:25,279
element and and designated very fast

1150
00:39:22,880 --> 00:39:27,920
and also a first two element laconic

1151
00:39:25,280 --> 00:39:29,760
argument with negligible summer cell

1152
00:39:27,920 --> 00:39:32,240
which is in the genetical model and does

1153
00:39:29,760 --> 00:39:34,640
not rely on any assumption

1154
00:39:32,240 --> 00:39:34,640
thank you

1155
00:39:37,520 --> 00:39:41,599
thanks so hard for the talk um now it's

1156
00:39:40,560 --> 00:39:43,839
time for a question we have a few

1157
00:39:41,599 --> 00:39:43,839
minutes

1158
00:39:44,720 --> 00:39:52,078
may i have asked a quick question

1159
00:39:48,320 --> 00:39:54,400
so go ahead go ahead so uh

1160
00:39:52,079 --> 00:39:56,400
thank you for a nice presentation i mean

1161
00:39:54,400 --> 00:39:57,920
as you know growth has here as you said

1162
00:39:56,400 --> 00:40:00,240
three group elements

1163
00:39:57,920 --> 00:40:01,520
but also grad discussed that if you want

1164
00:40:00,240 --> 00:40:03,680
to use instead of

1165
00:40:01,520 --> 00:40:05,759
cap quadratic arithmetic programs if you

1166
00:40:03,680 --> 00:40:08,480
use squaring arithmetic programs

1167
00:40:05,760 --> 00:40:09,760
basically you still can have succinct

1168
00:40:08,480 --> 00:40:13,359
two

1169
00:40:09,760 --> 00:40:14,800
uh argument which basically also is

1170
00:40:13,359 --> 00:40:17,680
public verifiable

1171
00:40:14,800 --> 00:40:19,040
so here but the problem in that scenario

1172
00:40:17,680 --> 00:40:22,319
is that you will have

1173
00:40:19,040 --> 00:40:23,520
a longer crs and longer basically prover

1174
00:40:22,319 --> 00:40:27,279
computation

1175
00:40:23,520 --> 00:40:29,119
so i'm wondering how inefficient

1176
00:40:27,280 --> 00:40:31,440
is your case that you mentioned you have

1177
00:40:29,119 --> 00:40:34,000
longer crs in your case

1178
00:40:31,440 --> 00:40:36,319
so we are less efficient than goes in

1179
00:40:34,000 --> 00:40:37,440
cls and overtimes and also have wall

1180
00:40:36,319 --> 00:40:39,520
soundness

1181
00:40:37,440 --> 00:40:40,880
but what you miss is that if you take

1182
00:40:39,520 --> 00:40:44,560
ghost instantiation

1183
00:40:40,880 --> 00:40:46,800
and work with the squarespan programs

1184
00:40:44,560 --> 00:40:48,640
then you need to use symmetric uh

1185
00:40:46,800 --> 00:40:49,520
bilinear groups which actually translate

1186
00:40:48,640 --> 00:40:52,480
to even

1187
00:40:49,520 --> 00:40:53,359
more beats than the thousands and ghosts

1188
00:40:52,480 --> 00:40:55,680
arrived

1189
00:40:53,359 --> 00:40:56,799
so he uses the quadratic span problem

1190
00:40:55,680 --> 00:40:58,799
not

1191
00:40:56,800 --> 00:40:59,839
like also for approval efficiency

1192
00:40:58,800 --> 00:41:02,720
reasons but

1193
00:40:59,839 --> 00:41:03,440
mostly because it is what translated to

1194
00:41:02,720 --> 00:41:06,078
the

1195
00:41:03,440 --> 00:41:08,319
um most exciting tests now get a bit

1196
00:41:06,079 --> 00:41:08,319
wise

1197
00:41:10,800 --> 00:41:14,400
our main advantage is the fact that we

1198
00:41:12,480 --> 00:41:20,319
are two times show thousand

1199
00:41:14,400 --> 00:41:22,240
then the shortest goals could achieve

1200
00:41:20,319 --> 00:41:23,920
so there's another question in the chat

1201
00:41:22,240 --> 00:41:26,959
sorry if

1202
00:41:23,920 --> 00:41:29,680
i hope uh we're happy with the answer

1203
00:41:26,960 --> 00:41:30,480
if not please go ahead and write some

1204
00:41:29,680 --> 00:41:34,879
more

1205
00:41:30,480 --> 00:41:36,800
so uh

1206
00:41:34,880 --> 00:41:37,839
so the question is that they is they

1207
00:41:36,800 --> 00:41:38,640
part of this needless for the

1208
00:41:37,839 --> 00:41:42,160
correctness and

1209
00:41:38,640 --> 00:41:44,799
not just the security um

1210
00:41:42,160 --> 00:41:45,920
so yeah we need it for the construction

1211
00:41:44,800 --> 00:41:47,839
um

1212
00:41:45,920 --> 00:41:49,920
like the construction starts from a

1213
00:41:47,839 --> 00:41:52,960
minimal distance problem instance so

1214
00:41:49,920 --> 00:41:57,119
we start by um

1215
00:41:52,960 --> 00:42:00,480
applying uh this hypothesis reduction

1216
00:41:57,119 --> 00:42:02,400
if you walk with the known results so

1217
00:42:00,480 --> 00:42:04,160
looking on constants better and not the

1218
00:42:02,400 --> 00:42:06,000
super constants better

1219
00:42:04,160 --> 00:42:08,078
then basically it means that it takes

1220
00:42:06,000 --> 00:42:09,040
the same time to break the system as it

1221
00:42:08,079 --> 00:42:11,920
takes to

1222
00:42:09,040 --> 00:42:12,720
prepare the question so this is why we

1223
00:42:11,920 --> 00:42:14,839
need

1224
00:42:12,720 --> 00:42:16,879
that the reduction would be more

1225
00:42:14,839 --> 00:42:18,160
efficient yeah would run in polynomial

1226
00:42:16,880 --> 00:42:19,359
time and the gap parameter would be a

1227
00:42:18,160 --> 00:42:22,319
super constant

1228
00:42:19,359 --> 00:42:22,319
like omega floating

1229
00:42:25,440 --> 00:42:29,280
okay please yeah i'll start going sorry

1230
00:42:28,800 --> 00:42:31,119
uh i

1231
00:42:29,280 --> 00:42:33,359
am sorry sorry for interrupting but it's

1232
00:42:31,119 --> 00:42:36,160
time to move on unfortunately

1233
00:42:33,359 --> 00:42:37,279
um time is running fast so um thank you

1234
00:42:36,160 --> 00:42:40,480
very much award for

1235
00:42:37,280 --> 00:42:43,200
for the presentation um next

1236
00:42:40,480 --> 00:42:44,160
is the paper fully deniable interactive

1237
00:42:43,200 --> 00:42:46,960
encryption by

1238
00:42:44,160 --> 00:42:48,720
ren carnetti sono park and oksana pubu

1239
00:42:46,960 --> 00:42:51,680
rin naya

1240
00:42:48,720 --> 00:42:51,680
so please go ahead

1241
00:42:53,359 --> 00:42:56,720
okay thanks for the introduction so i

1242
00:42:55,280 --> 00:42:59,520
will be talking about

1243
00:42:56,720 --> 00:43:01,759
our work on fully deniable encryption

1244
00:42:59,520 --> 00:43:04,480
and this is a joint work with run canadi

1245
00:43:01,760 --> 00:43:04,480
and central park

1246
00:43:06,720 --> 00:43:10,959
so what is deniable encryption in

1247
00:43:09,280 --> 00:43:12,640
standard public key encryption

1248
00:43:10,960 --> 00:43:14,720
the goal is to protect against

1249
00:43:12,640 --> 00:43:16,640
eavesdropping attacks

1250
00:43:14,720 --> 00:43:18,480
in deniable encryption which was

1251
00:43:16,640 --> 00:43:20,799
introduced in 96

1252
00:43:18,480 --> 00:43:21,680
the goal is to protect against a strong

1253
00:43:20,800 --> 00:43:25,599
adversary

1254
00:43:21,680 --> 00:43:28,319
called a cursor such an adversary

1255
00:43:25,599 --> 00:43:30,079
has additional power it can first look

1256
00:43:28,319 --> 00:43:33,200
at the communication

1257
00:43:30,079 --> 00:43:35,440
and then it can come to both parties and

1258
00:43:33,200 --> 00:43:37,839
demand that these parties disclose

1259
00:43:35,440 --> 00:43:40,960
the all the secret keys and randomness

1260
00:43:37,839 --> 00:43:43,440
used to transmit the message

1261
00:43:40,960 --> 00:43:45,599
in particular deniable encryption

1262
00:43:43,440 --> 00:43:48,560
requires that parties should be able to

1263
00:43:45,599 --> 00:43:51,040
come up with fake keys and randomness

1264
00:43:48,560 --> 00:43:55,839
consistent with any desired target fake

1265
00:43:51,040 --> 00:43:55,839
plaintext m prime

1266
00:43:56,079 --> 00:44:00,400
and note that standard public encryption

1267
00:43:58,160 --> 00:44:01,520
schemes do not protect against this kind

1268
00:44:00,400 --> 00:44:04,240
of attack

1269
00:44:01,520 --> 00:44:05,359
for example in algamal encryption scheme

1270
00:44:04,240 --> 00:44:08,319
the cipher text

1271
00:44:05,359 --> 00:44:09,440
actually uniquely determines randomness

1272
00:44:08,319 --> 00:44:13,040
s of the sender

1273
00:44:09,440 --> 00:44:13,040
and therefore the plaintext m

1274
00:44:14,800 --> 00:44:18,000
let's look at the simple case so if

1275
00:44:17,200 --> 00:44:20,960
parties

1276
00:44:18,000 --> 00:44:23,040
have access to a pre-shared secret k the

1277
00:44:20,960 --> 00:44:25,440
enable encryption can be very easy

1278
00:44:23,040 --> 00:44:27,440
just send a one-time pad and then

1279
00:44:25,440 --> 00:44:29,280
everybody can easily come up with the

1280
00:44:27,440 --> 00:44:31,440
secret key consistent with a given plain

1281
00:44:29,280 --> 00:44:34,319
text

1282
00:44:31,440 --> 00:44:37,680
however the question is how to agree on

1283
00:44:34,319 --> 00:44:40,079
such a key deniably to begin with

1284
00:44:37,680 --> 00:44:41,200
for example if you use div helmet key

1285
00:44:40,079 --> 00:44:43,680
exchange

1286
00:44:41,200 --> 00:44:46,319
then your key is committed to by the

1287
00:44:43,680 --> 00:44:49,118
transcript of the key exchange

1288
00:44:46,319 --> 00:44:51,359
and therefore we are back to square one

1289
00:44:49,119 --> 00:44:53,760
and the question is how to

1290
00:44:51,359 --> 00:44:56,400
agree on this key deniably in other

1291
00:44:53,760 --> 00:44:58,960
words can we get a deniable key exchange

1292
00:44:56,400 --> 00:45:01,760
or alternatively speaking interactive

1293
00:44:58,960 --> 00:45:03,920
deniable encryption

1294
00:45:01,760 --> 00:45:05,680
and indeed this is the main goal of this

1295
00:45:03,920 --> 00:45:08,720
work we ask

1296
00:45:05,680 --> 00:45:11,680
does there exist deniable encryption

1297
00:45:08,720 --> 00:45:12,240
potentially interactive one or in other

1298
00:45:11,680 --> 00:45:15,359
words

1299
00:45:12,240 --> 00:45:19,279
is it possible to communicate in a way

1300
00:45:15,359 --> 00:45:22,400
which is secure against conversion

1301
00:45:19,280 --> 00:45:24,560
let me briefly mention prior work

1302
00:45:22,400 --> 00:45:26,079
so we did know an ambassador

1303
00:45:24,560 --> 00:45:28,240
impossibility result

1304
00:45:26,079 --> 00:45:31,280
saying that receiver deniable encryption

1305
00:45:28,240 --> 00:45:33,118
is impossible in two rounds

1306
00:45:31,280 --> 00:45:34,800
at the same time we know some positive

1307
00:45:33,119 --> 00:45:36,880
results with our standard denial

1308
00:45:34,800 --> 00:45:39,359
encryption from obfuscation

1309
00:45:36,880 --> 00:45:41,280
and it can be easily converted to a

1310
00:45:39,359 --> 00:45:43,279
receiver deniable encryption but in

1311
00:45:41,280 --> 00:45:46,000
three rounds

1312
00:45:43,280 --> 00:45:46,640
in fact it's also easy to convert it

1313
00:45:46,000 --> 00:45:49,040
into

1314
00:45:46,640 --> 00:45:51,118
an encryption scheme which is sender or

1315
00:45:49,040 --> 00:45:53,440
receiver deniable but still just one

1316
00:45:51,119 --> 00:45:55,599
party can be cursed

1317
00:45:53,440 --> 00:45:56,560
and it was an open problem whether there

1318
00:45:55,599 --> 00:45:58,800
exists

1319
00:45:56,560 --> 00:46:01,599
an encryption scheme which can withstand

1320
00:45:58,800 --> 00:46:04,000
coercion of both parties

1321
00:46:01,599 --> 00:46:05,200
note that this case is inherently harder

1322
00:46:04,000 --> 00:46:07,200
because in this case

1323
00:46:05,200 --> 00:46:08,560
the adversary can see the randomness of

1324
00:46:07,200 --> 00:46:10,799
all the parties

1325
00:46:08,560 --> 00:46:14,560
and you cannot simply hide some values

1326
00:46:10,800 --> 00:46:16,960
for example by secret sharing them

1327
00:46:14,560 --> 00:46:17,839
so here is the result so first we

1328
00:46:16,960 --> 00:46:19,839
propose

1329
00:46:17,839 --> 00:46:21,440
a new definition called of the record

1330
00:46:19,839 --> 00:46:23,680
deniability

1331
00:46:21,440 --> 00:46:26,960
and roughly it gives protection for a

1332
00:46:23,680 --> 00:46:28,960
case when claims are inconsistent

1333
00:46:26,960 --> 00:46:30,880
and note that this definition is

1334
00:46:28,960 --> 00:46:32,400
incomparable to standard definition of

1335
00:46:30,880 --> 00:46:34,400
deniability

1336
00:46:32,400 --> 00:46:35,440
however together with the original

1337
00:46:34,400 --> 00:46:38,079
definition

1338
00:46:35,440 --> 00:46:39,920
it gives you the protection akin to the

1339
00:46:38,079 --> 00:46:43,040
ideal channel

1340
00:46:39,920 --> 00:46:44,800
with respect to coercive attacks and our

1341
00:46:43,040 --> 00:46:47,520
main result in the paper

1342
00:46:44,800 --> 00:46:47,839
is the feasibility result we show that

1343
00:46:47,520 --> 00:46:50,480
there

1344
00:46:47,839 --> 00:46:52,000
exists interactive deniable encryption

1345
00:46:50,480 --> 00:46:54,319
it takes three messages

1346
00:46:52,000 --> 00:46:57,520
and follows the communication pattern as

1347
00:46:54,319 --> 00:47:00,160
on the picture and it satisfies both

1348
00:46:57,520 --> 00:47:01,920
original definition of deniability and

1349
00:47:00,160 --> 00:47:03,440
our new definition as well

1350
00:47:01,920 --> 00:47:04,960
and therefore it basically gives you

1351
00:47:03,440 --> 00:47:07,440
this ideal version of

1352
00:47:04,960 --> 00:47:09,440
secure channels even against against the

1353
00:47:07,440 --> 00:47:12,000
chairs of adversary

1354
00:47:09,440 --> 00:47:13,680
and we do need strong assumptions such

1355
00:47:12,000 --> 00:47:15,839
as obfuscation

1356
00:47:13,680 --> 00:47:16,960
but know that even center-deniable

1357
00:47:15,839 --> 00:47:19,520
encryption so far

1358
00:47:16,960 --> 00:47:21,280
is only known from obfuscation and

1359
00:47:19,520 --> 00:47:21,680
that's a fascinated open fascinating

1360
00:47:21,280 --> 00:47:24,800
opera

1361
00:47:21,680 --> 00:47:26,000
problem just to say one word about the

1362
00:47:24,800 --> 00:47:28,240
scheme

1363
00:47:26,000 --> 00:47:29,040
so the very high level idea is that

1364
00:47:28,240 --> 00:47:31,680
parties

1365
00:47:29,040 --> 00:47:32,800
are going uh to have an access to the

1366
00:47:31,680 --> 00:47:35,200
crs

1367
00:47:32,800 --> 00:47:36,000
and the crs will contain an obfuscated

1368
00:47:35,200 --> 00:47:37,520
version

1369
00:47:36,000 --> 00:47:39,440
of all the programs of deniable

1370
00:47:37,520 --> 00:47:40,960
encryption

1371
00:47:39,440 --> 00:47:42,640
and they will not compute anything

1372
00:47:40,960 --> 00:47:46,240
themselves they will just run

1373
00:47:42,640 --> 00:47:48,480
these programs first two messages

1374
00:47:46,240 --> 00:47:49,680
will be basically the hashes under some

1375
00:47:48,480 --> 00:47:52,720
special hash

1376
00:47:49,680 --> 00:47:54,399
of everything which parties known so far

1377
00:47:52,720 --> 00:47:56,720
and the third message will be an

1378
00:47:54,400 --> 00:48:00,559
encryption of the plain text

1379
00:47:56,720 --> 00:48:01,520
and these hashes and then we can make

1380
00:48:00,559 --> 00:48:04,000
every program

1381
00:48:01,520 --> 00:48:05,599
deniable separately by using the

1382
00:48:04,000 --> 00:48:07,359
techniques from

1383
00:48:05,599 --> 00:48:09,040
standard deniable encryption of the high

1384
00:48:07,359 --> 00:48:11,759
waters

1385
00:48:09,040 --> 00:48:12,319
the problem however is that technique

1386
00:48:11,760 --> 00:48:14,480
only

1387
00:48:12,319 --> 00:48:15,599
guarantees deniability for separate

1388
00:48:14,480 --> 00:48:17,599
programs

1389
00:48:15,599 --> 00:48:20,319
it does not give any guarantees for the

1390
00:48:17,599 --> 00:48:21,440
case where you have access to multiple

1391
00:48:20,319 --> 00:48:24,000
related programs

1392
00:48:21,440 --> 00:48:26,480
like we do here and that's the main

1393
00:48:24,000 --> 00:48:28,640
contribution of our work technically

1394
00:48:26,480 --> 00:48:29,599
is to understand why this current scheme

1395
00:48:28,640 --> 00:48:32,799
is broken

1396
00:48:29,599 --> 00:48:35,359
and how to fix it and let me really

1397
00:48:32,800 --> 00:48:37,760
briefly mention our key steps

1398
00:48:35,359 --> 00:48:39,598
so first we figure out that there is a

1399
00:48:37,760 --> 00:48:42,160
certain chain in attack which can be

1400
00:48:39,599 --> 00:48:44,079
always performed

1401
00:48:42,160 --> 00:48:46,319
and to avoid this attack we need the

1402
00:48:44,079 --> 00:48:47,839
decryption to follow a very special

1403
00:48:46,319 --> 00:48:50,240
decryption behavior which i

1404
00:48:47,839 --> 00:48:52,558
don't have time to describe but to

1405
00:48:50,240 --> 00:48:53,520
enable such a behavior from a decryption

1406
00:48:52,559 --> 00:48:55,280
algorithm

1407
00:48:53,520 --> 00:48:57,680
we need to organize the flow of

1408
00:48:55,280 --> 00:48:58,400
information between all pieces of the

1409
00:48:57,680 --> 00:49:00,319
scheme

1410
00:48:58,400 --> 00:49:02,000
such as randomness used by the parties

1411
00:49:00,319 --> 00:49:04,960
and the transcript

1412
00:49:02,000 --> 00:49:06,000
this is all i have to say about my paper

1413
00:49:04,960 --> 00:49:07,520
feel free to

1414
00:49:06,000 --> 00:49:09,040
take a look at the imprint version we

1415
00:49:07,520 --> 00:49:11,599
updated it and thank you very much for

1416
00:49:09,040 --> 00:49:11,599
your attention

1417
00:49:13,359 --> 00:49:16,720
thank you very much roxanna for the

1418
00:49:14,880 --> 00:49:30,400
pretty great talk

1419
00:49:16,720 --> 00:49:33,919
we have the time for a few questions

1420
00:49:30,400 --> 00:49:36,960
um yeah so i'm actually queries myself

1421
00:49:33,920 --> 00:49:39,200
um can you comment on

1422
00:49:36,960 --> 00:49:41,520
whether you think we can eventually

1423
00:49:39,200 --> 00:49:42,839
remove the assumption of io getting from

1424
00:49:41,520 --> 00:49:46,000
you know

1425
00:49:42,839 --> 00:49:48,078
more established tools even

1426
00:49:46,000 --> 00:49:49,839
maybe leveraging more interaction

1427
00:49:48,079 --> 00:49:52,240
possibly you can comment on the main

1428
00:49:49,839 --> 00:49:55,680
barrier to get that

1429
00:49:52,240 --> 00:49:57,439
yes i have looked at a person with more

1430
00:49:55,680 --> 00:50:01,279
interaction maybe more rounds

1431
00:49:57,440 --> 00:50:02,800
and it sounds like a similar attack

1432
00:50:01,280 --> 00:50:05,440
can be possible there but it's sort of

1433
00:50:02,800 --> 00:50:07,119
harder to explicitly write and prove but

1434
00:50:05,440 --> 00:50:08,800
my feeling was that there is a similar

1435
00:50:07,119 --> 00:50:11,920
barrier so i'm not sure

1436
00:50:08,800 --> 00:50:13,760
that interaction will help however i

1437
00:50:11,920 --> 00:50:16,079
think at least for the standard deniable

1438
00:50:13,760 --> 00:50:17,680
encryption it is very plausible that we

1439
00:50:16,079 --> 00:50:19,760
can remove io

1440
00:50:17,680 --> 00:50:21,359
and i encourage everybody to look at i

1441
00:50:19,760 --> 00:50:21,760
think it's a fascinating problem if we

1442
00:50:21,359 --> 00:50:23,759
can

1443
00:50:21,760 --> 00:50:25,359
you know if we can get uh the sender

1444
00:50:23,760 --> 00:50:26,800
deniable encryption from standard

1445
00:50:25,359 --> 00:50:29,440
assumptions

1446
00:50:26,800 --> 00:50:31,280
so the by deniable version like in this

1447
00:50:29,440 --> 00:50:33,440
work it will require

1448
00:50:31,280 --> 00:50:35,040
more work if you want to remove io so we

1449
00:50:33,440 --> 00:50:36,559
use io actually like in

1450
00:50:35,040 --> 00:50:38,558
sort of three different independent

1451
00:50:36,559 --> 00:50:41,599
places in some sense

1452
00:50:38,559 --> 00:50:44,800
uh so yeah first step would be to get a

1453
00:50:41,599 --> 00:50:44,800
standard enable encryption

1454
00:50:46,319 --> 00:50:48,640
thanks

1455
00:50:51,440 --> 00:50:56,960
okay so i guess then we can move on

1456
00:50:54,880 --> 00:50:58,079
to the next presentation unfortunately

1457
00:50:56,960 --> 00:51:00,800
already the last one

1458
00:50:58,079 --> 00:51:03,680
of this session um this one is about

1459
00:51:00,800 --> 00:51:09,760
verifier registration based encryption

1460
00:51:03,680 --> 00:51:13,118
by richard

1461
00:51:09,760 --> 00:51:16,079
is going to give the presentation

1462
00:51:13,119 --> 00:51:17,040
thanks for the introduction uh hi my

1463
00:51:16,079 --> 00:51:19,280
name is satya

1464
00:51:17,040 --> 00:51:21,040
today i'm going to present about our

1465
00:51:19,280 --> 00:51:24,000
verifiable registration based encryption

1466
00:51:21,040 --> 00:51:24,720
this is a joint work with bishop goal we

1467
00:51:24,000 --> 00:51:26,400
all know that

1468
00:51:24,720 --> 00:51:27,919
one of the most fundamental problems in

1469
00:51:26,400 --> 00:51:28,880
cryptography is one-to-one secure

1470
00:51:27,920 --> 00:51:30,720
communication

1471
00:51:28,880 --> 00:51:32,480
where alice wants to secure a sender

1472
00:51:30,720 --> 00:51:33,919
message to bob

1473
00:51:32,480 --> 00:51:35,760
probably the simplest way of doing this

1474
00:51:33,920 --> 00:51:37,680
is public encryption

1475
00:51:35,760 --> 00:51:39,520
but for that alice certainly needs to

1476
00:51:37,680 --> 00:51:41,598
obtain bob's publicly first

1477
00:51:39,520 --> 00:51:43,359
and one of the most standard ways of

1478
00:51:41,599 --> 00:51:45,119
doing it is to have an authority which

1479
00:51:43,359 --> 00:51:48,480
corrects public keys from every user

1480
00:51:45,119 --> 00:51:50,480
and then sends bob's publicly to alice

1481
00:51:48,480 --> 00:51:51,920
the problem with this is uh alice needs

1482
00:51:50,480 --> 00:51:54,000
to contact the authority every time she

1483
00:51:51,920 --> 00:51:56,319
needs to talk to someone

1484
00:51:54,000 --> 00:51:57,599
an alternate solution for encryption is

1485
00:51:56,319 --> 00:52:00,000
identity-based encryption

1486
00:51:57,599 --> 00:52:02,000
uh here there is an authority which

1487
00:52:00,000 --> 00:52:03,680
samples a master public security pair

1488
00:52:02,000 --> 00:52:05,440
and using that sample is a secret key

1489
00:52:03,680 --> 00:52:06,799
for every user

1490
00:52:05,440 --> 00:52:08,400
here alice need not contact the

1491
00:52:06,800 --> 00:52:12,000
authority every time because she can

1492
00:52:08,400 --> 00:52:12,000
encrypt a message just using bob's name

1493
00:52:14,720 --> 00:52:18,240
both in identity-based encryption and in

1494
00:52:16,720 --> 00:52:19,919
public encryption there's a fundamental

1495
00:52:18,240 --> 00:52:21,680
limitation that we are giving too much

1496
00:52:19,920 --> 00:52:23,119
power to the authority

1497
00:52:21,680 --> 00:52:24,399
for for example if the authority is

1498
00:52:23,119 --> 00:52:25,119
corrupted then in identity based

1499
00:52:24,400 --> 00:52:27,839
encryption

1500
00:52:25,119 --> 00:52:29,359
the authority can read every scientist

1501
00:52:27,839 --> 00:52:31,279
and in case of public encryption

1502
00:52:29,359 --> 00:52:33,359
the authority can send wrong keys to

1503
00:52:31,280 --> 00:52:36,000
alice and this problem is famously known

1504
00:52:33,359 --> 00:52:38,078
as a key script problem

1505
00:52:36,000 --> 00:52:39,520
recently darting and recently gerge and

1506
00:52:38,079 --> 00:52:40,800
others came up with this beautiful

1507
00:52:39,520 --> 00:52:41,359
primitive called registration business

1508
00:52:40,800 --> 00:52:44,400
encryption

1509
00:52:41,359 --> 00:52:45,520
to solve a ksc problem this system has

1510
00:52:44,400 --> 00:52:47,119
an ib flavor to it

1511
00:52:45,520 --> 00:52:49,359
which means that alice can encrypt a

1512
00:52:47,119 --> 00:52:51,760
message to bob just using bob's name

1513
00:52:49,359 --> 00:52:53,040
but at the same time the authority here

1514
00:52:51,760 --> 00:52:55,280
doesn't have store any secret

1515
00:52:53,040 --> 00:52:56,319
information

1516
00:52:55,280 --> 00:52:57,839
the role of the authority is

1517
00:52:56,319 --> 00:52:58,800
specifically designed not to have too

1518
00:52:57,839 --> 00:53:00,960
much power

1519
00:52:58,800 --> 00:53:02,559
here buffer samples the public security

1520
00:53:00,960 --> 00:53:03,599
pair just using regular public

1521
00:53:02,559 --> 00:53:05,520
encryption scheme

1522
00:53:03,599 --> 00:53:07,520
and then he sends his name along with

1523
00:53:05,520 --> 00:53:09,119
public key to the authority

1524
00:53:07,520 --> 00:53:10,559
likewise the authority collects public

1525
00:53:09,119 --> 00:53:12,079
keys of every user

1526
00:53:10,559 --> 00:53:14,319
it just accumulates all this infor

1527
00:53:12,079 --> 00:53:15,839
public information and publishes a short

1528
00:53:14,319 --> 00:53:17,359
public parameters

1529
00:53:15,839 --> 00:53:19,040
and given the short public parameters

1530
00:53:17,359 --> 00:53:21,200
alice can encrypt a message just using

1531
00:53:19,040 --> 00:53:23,279
bob's name

1532
00:53:21,200 --> 00:53:24,879
just to add some more flexibility here

1533
00:53:23,280 --> 00:53:26,720
the authority can also additionally give

1534
00:53:24,880 --> 00:53:29,119
some supplement information to bob

1535
00:53:26,720 --> 00:53:30,160
and using which and along with his own

1536
00:53:29,119 --> 00:53:33,760
secret key

1537
00:53:30,160 --> 00:53:33,759
bob can decrypt the science text

1538
00:53:33,839 --> 00:53:37,440
again the catch here is that the

1539
00:53:35,599 --> 00:53:38,720
authority does not store any secret

1540
00:53:37,440 --> 00:53:39,440
information here during the entire

1541
00:53:38,720 --> 00:53:41,279
process

1542
00:53:39,440 --> 00:53:42,640
and that drastically reduces the power

1543
00:53:41,280 --> 00:53:43,520
of the authority to be able to launch

1544
00:53:42,640 --> 00:53:46,799
any attack

1545
00:53:43,520 --> 00:53:48,480
when is corrupted and as you know

1546
00:53:46,800 --> 00:53:50,079
this primitive has been proposed to

1547
00:53:48,480 --> 00:53:53,440
solve the kiosk problem

1548
00:53:50,079 --> 00:53:54,720
but does it really solve it yes but not

1549
00:53:53,440 --> 00:53:56,000
exactly

1550
00:53:54,720 --> 00:53:58,720
let's look back look back at this

1551
00:53:56,000 --> 00:54:01,200
picture if the third is correct how can

1552
00:53:58,720 --> 00:54:02,799
he launch an attack

1553
00:54:01,200 --> 00:54:04,240
well if the daughter is correct he can

1554
00:54:02,800 --> 00:54:05,200
generate public parameters in an

1555
00:54:04,240 --> 00:54:07,439
arbitrary way

1556
00:54:05,200 --> 00:54:09,439
for example he can double register bob

1557
00:54:07,440 --> 00:54:11,359
he can register bob first time with

1558
00:54:09,440 --> 00:54:14,079
bob's actual key and he can resist a bob

1559
00:54:11,359 --> 00:54:15,839
again with a different public key

1560
00:54:14,079 --> 00:54:17,359
he can also register users who did not

1561
00:54:15,839 --> 00:54:18,799
submit a registration request

1562
00:54:17,359 --> 00:54:21,279
users who did not even sign up for the

1563
00:54:18,800 --> 00:54:21,760
system that sounds like a serious

1564
00:54:21,280 --> 00:54:24,000
problem

1565
00:54:21,760 --> 00:54:25,119
right the data can literally break into

1566
00:54:24,000 --> 00:54:27,119
the system

1567
00:54:25,119 --> 00:54:28,400
and to solve this problem the previous

1568
00:54:27,119 --> 00:54:32,800
papers uh

1569
00:54:28,400 --> 00:54:34,640
introduced an auditor where uh who

1570
00:54:32,800 --> 00:54:37,040
verifies whether the auditor is working

1571
00:54:34,640 --> 00:54:38,720
honestly or not basically the auditor

1572
00:54:37,040 --> 00:54:40,960
runs the entire registration algorithm

1573
00:54:38,720 --> 00:54:43,680
himself and verifies whether the output

1574
00:54:40,960 --> 00:54:45,440
is matching with that of the authority

1575
00:54:43,680 --> 00:54:47,279
this audio process is good but it's kind

1576
00:54:45,440 --> 00:54:49,839
of inefficient because the auditor has

1577
00:54:47,280 --> 00:54:51,760
to run the entire audit process himself

1578
00:54:49,839 --> 00:54:53,839
and the question here is can we do

1579
00:54:51,760 --> 00:54:55,440
something more efficient than that

1580
00:54:53,839 --> 00:54:57,279
and to that end we propose this notion

1581
00:54:55,440 --> 00:54:59,680
called individual verifiability

1582
00:54:57,280 --> 00:55:01,839
basically here bob wants to make sure

1583
00:54:59,680 --> 00:55:03,279
that he is being resisted

1584
00:55:01,839 --> 00:55:05,040
and the authority can give a proof of

1585
00:55:03,280 --> 00:55:07,440
that the authority

1586
00:55:05,040 --> 00:55:08,720
might be able uh the authority uh is

1587
00:55:07,440 --> 00:55:11,680
giving a proof that bob

1588
00:55:08,720 --> 00:55:13,439
is resisted honestly the dirty matter

1589
00:55:11,680 --> 00:55:15,200
cheated when resisting other users

1590
00:55:13,440 --> 00:55:17,520
but this proof doesn't speak of that

1591
00:55:15,200 --> 00:55:19,598
this proof only speaks of bob

1592
00:55:17,520 --> 00:55:21,040
and we extend this notion even further

1593
00:55:19,599 --> 00:55:22,480
consider this old man

1594
00:55:21,040 --> 00:55:24,400
who did not register his public key with

1595
00:55:22,480 --> 00:55:26,079
authority and

1596
00:55:24,400 --> 00:55:27,520
alice doesn't know that and alice might

1597
00:55:26,079 --> 00:55:31,040
still be encrypting her messages

1598
00:55:27,520 --> 00:55:32,480
to this uh old man and the other team

1599
00:55:31,040 --> 00:55:34,400
might be taking advantage of it

1600
00:55:32,480 --> 00:55:36,319
and he might be registering uh this old

1601
00:55:34,400 --> 00:55:37,359
man illegally and might be decrypting

1602
00:55:36,319 --> 00:55:39,839
alice ciphertext

1603
00:55:37,359 --> 00:55:41,520
and that's a problem and the old man

1604
00:55:39,839 --> 00:55:42,400
wants to make sure that the dart is not

1605
00:55:41,520 --> 00:55:44,079
cheating this way

1606
00:55:42,400 --> 00:55:46,400
so he wants to have a proof that the

1607
00:55:44,079 --> 00:55:47,839
daughter did not resist him

1608
00:55:46,400 --> 00:55:49,839
so basically here there are two kinds of

1609
00:55:47,839 --> 00:55:52,640
proofs approved for a registered user

1610
00:55:49,839 --> 00:55:54,240
and approved for unregistered users and

1611
00:55:52,640 --> 00:55:57,359
the basic requirement here is

1612
00:55:54,240 --> 00:55:58,720
the proofs have to be short and all the

1613
00:55:57,359 --> 00:56:00,720
proven verify algorithms have to be

1614
00:55:58,720 --> 00:56:02,799
efficient

1615
00:56:00,720 --> 00:56:04,720
the by that i mean all these parameters

1616
00:56:02,799 --> 00:56:07,520
have to be at most poly logarithmic

1617
00:56:04,720 --> 00:56:08,879
in terms of overall number of users the

1618
00:56:07,520 --> 00:56:10,640
security guarantees that

1619
00:56:08,880 --> 00:56:13,599
if the directi can give a proof then you

1620
00:56:10,640 --> 00:56:15,200
should not be able to cheat

1621
00:56:13,599 --> 00:56:16,799
in this paper we introduce this concept

1622
00:56:15,200 --> 00:56:18,399
called verifiable obvi

1623
00:56:16,799 --> 00:56:20,319
which is just plain old registration

1624
00:56:18,400 --> 00:56:21,760
based encryption added with

1625
00:56:20,319 --> 00:56:23,680
added property called individual

1626
00:56:21,760 --> 00:56:24,799
verifiability and then we can start it

1627
00:56:23,680 --> 00:56:27,759
from standard assumptions

1628
00:56:24,799 --> 00:56:29,040
by simplifying ldn1 constructions and

1629
00:56:27,760 --> 00:56:30,319
thank you for listening to my talk you

1630
00:56:29,040 --> 00:56:33,920
can find more details in

1631
00:56:30,319 --> 00:56:33,920
rd print version and our youtube talk

1632
00:56:35,119 --> 00:56:38,319
thank you thank you very much for your

1633
00:56:36,400 --> 00:56:40,240
talk um

1634
00:56:38,319 --> 00:56:45,839
it's time to take questions i believe we

1635
00:56:40,240 --> 00:56:45,839
have a few minutes and um

1636
00:56:48,400 --> 00:56:51,200
there's a question

1637
00:56:52,079 --> 00:56:57,680
uh so predictor car asks whether

1638
00:56:55,920 --> 00:57:01,280
given the chapter of pp can the

1639
00:56:57,680 --> 00:57:01,279
authority decrypt the cypher attacks

1640
00:57:05,839 --> 00:57:12,160
so here we use a crs here

1641
00:57:09,680 --> 00:57:13,598
the crs of the which can which should be

1642
00:57:12,160 --> 00:57:15,520
generated by a honest party

1643
00:57:13,599 --> 00:57:17,839
and the authority is given the crs

1644
00:57:15,520 --> 00:57:18,640
directly and if the trapdoor is given to

1645
00:57:17,839 --> 00:57:20,720
the crs

1646
00:57:18,640 --> 00:57:22,480
then you can decrypt but uh we want to

1647
00:57:20,720 --> 00:57:27,839
make sure that the crs is generated by

1648
00:57:22,480 --> 00:57:27,839
honest party

1649
00:57:30,640 --> 00:57:34,720
okay there's there's another question

1650
00:57:32,480 --> 00:57:37,920
from uh fotenibaldmiti

1651
00:57:34,720 --> 00:57:39,520
and she asks whether um can you comment

1652
00:57:37,920 --> 00:57:41,520
a bit on the construction

1653
00:57:39,520 --> 00:57:45,520
and whether a standard universal

1654
00:57:41,520 --> 00:57:45,520
accumulator wouldn't be sufficient here

1655
00:57:48,400 --> 00:57:51,839
so the construction is actually for

1656
00:57:50,480 --> 00:57:54,079
users merkle trees

1657
00:57:51,839 --> 00:57:55,680
here the authority gathers all these

1658
00:57:54,079 --> 00:57:57,680
public keys and identities

1659
00:57:55,680 --> 00:57:58,720
and it arranges in the merkle tree

1660
00:57:57,680 --> 00:58:00,399
assorted mercury

1661
00:57:58,720 --> 00:58:01,839
and the hash of the mercury is going to

1662
00:58:00,400 --> 00:58:05,040
the public parameters

1663
00:58:01,839 --> 00:58:07,200
and in the construction the encryption

1664
00:58:05,040 --> 00:58:10,400
algorithm is going to be a circuit

1665
00:58:07,200 --> 00:58:12,078
the which which verifies uh

1666
00:58:10,400 --> 00:58:14,079
which verifies whether a bob's public is

1667
00:58:12,079 --> 00:58:14,960
valid or not and if it's public is valid

1668
00:58:14,079 --> 00:58:16,160
then

1669
00:58:14,960 --> 00:58:18,240
it's going to encrypt a message with

1670
00:58:16,160 --> 00:58:20,319
respect to bob's public key and bob is

1671
00:58:18,240 --> 00:58:22,160
going to

1672
00:58:20,319 --> 00:58:23,520
run this program and it's going to

1673
00:58:22,160 --> 00:58:24,480
obtain an encryption with respect to his

1674
00:58:23,520 --> 00:58:26,640
own public key

1675
00:58:24,480 --> 00:58:28,079
and uh we're using the using his own

1676
00:58:26,640 --> 00:58:30,720
secret key is going to decrypt the

1677
00:58:28,079 --> 00:58:30,720
cipher text

1678
00:58:32,799 --> 00:58:36,000
the contraction uses something called

1679
00:58:35,119 --> 00:58:39,119
hash goblin

1680
00:58:36,000 --> 00:58:39,599
like which has been uh pretty much used

1681
00:58:39,119 --> 00:58:41,839
in the

1682
00:58:39,599 --> 00:58:42,720
previous constructions on uh identity

1683
00:58:41,839 --> 00:58:45,599
based uh

1684
00:58:42,720 --> 00:58:46,720
dotting and girl and uh those related

1685
00:58:45,599 --> 00:58:49,680
papers

1686
00:58:46,720 --> 00:58:50,160
the construction can be uh based on lw

1687
00:58:49,680 --> 00:58:53,040
and

1688
00:58:50,160 --> 00:58:53,040
ddh assumptions

1689
00:58:56,240 --> 00:58:59,759
all right thank you for the answer i

1690
00:58:58,079 --> 00:59:02,079
believe we have

1691
00:58:59,760 --> 00:59:02,839
room for one more question which is in

1692
00:59:02,079 --> 00:59:06,160
the chat

1693
00:59:02,839 --> 00:59:09,279
um vlasiscouts also asks whether uh

1694
00:59:06,160 --> 00:59:10,240
the proposal supports dynamic changes in

1695
00:59:09,280 --> 00:59:11,520
the user

1696
00:59:10,240 --> 00:59:12,799
meaning that the authority needs to

1697
00:59:11,520 --> 00:59:13,599
produce new public parameters and

1698
00:59:12,799 --> 00:59:15,920
broadcast

1699
00:59:13,599 --> 00:59:17,280
every time a new bob joins is that

1700
00:59:15,920 --> 00:59:19,040
correct

1701
00:59:17,280 --> 00:59:20,640
yes the daughter needs to publish new

1702
00:59:19,040 --> 00:59:22,960
public parameters every time a new user

1703
00:59:20,640 --> 00:59:22,960
joins

1704
00:59:23,200 --> 00:59:26,960
i guess maybe wonders whether that's

1705
00:59:24,960 --> 00:59:27,440
just specific to your construction or

1706
00:59:26,960 --> 00:59:31,680
for

1707
00:59:27,440 --> 00:59:34,240
all uh rbe schemes that we know

1708
00:59:31,680 --> 00:59:35,040
yeah yeah yeah that's uh that's common

1709
00:59:34,240 --> 00:59:36,640
for all the rb

1710
00:59:35,040 --> 00:59:39,119
all the previous obviously not just

1711
00:59:36,640 --> 00:59:39,118
tasking

1712
00:59:44,160 --> 00:59:47,839
okay um

1713
00:59:48,319 --> 00:59:55,040
i think we have a few more minutes uh

1714
00:59:51,680 --> 00:59:55,040
maybe um

1715
00:59:55,680 --> 01:00:02,000
yeah work uh how much time

1716
01:00:00,720 --> 01:00:03,200
do you have time for for a few more

1717
01:00:02,000 --> 01:00:04,559
questions so there were a few more

1718
01:00:03,200 --> 01:00:06,960
questions

1719
01:00:04,559 --> 01:00:08,880
um at the very beginning for for the

1720
01:00:06,960 --> 01:00:09,200
talk of alexis maybe we can talk you can

1721
01:00:08,880 --> 01:00:12,400
take

1722
01:00:09,200 --> 01:00:14,720
those ones that's everybody else

1723
01:00:12,400 --> 01:00:16,240
yeah uh yeah thanks for thanks for the

1724
01:00:14,720 --> 01:00:21,680
talk again

1725
01:00:16,240 --> 01:00:25,040
thank you um so they're in this tulip

1726
01:00:21,680 --> 01:00:28,000
um alex so you see oh yeah uh

1727
01:00:25,040 --> 01:00:29,200
that's yeah okay yeah so the first

1728
01:00:28,000 --> 01:00:31,680
question asked whether you can

1729
01:00:29,200 --> 01:00:33,200
say more about the second transform for

1730
01:00:31,680 --> 01:00:35,759
full security

1731
01:00:33,200 --> 01:00:36,319
right okay so yes the second transform

1732
01:00:35,760 --> 01:00:39,040
we use

1733
01:00:36,319 --> 01:00:40,000
the our set homomorphic secret sharing

1734
01:00:39,040 --> 01:00:43,119
so what we'll do

1735
01:00:40,000 --> 01:00:44,720
is we'll break uh the function into

1736
01:00:43,119 --> 01:00:46,160
function shares we'll break the input

1737
01:00:44,720 --> 01:00:48,399
into input shares

1738
01:00:46,160 --> 01:00:49,440
and we'll group them into different sets

1739
01:00:48,400 --> 01:00:51,520
and then we'll run

1740
01:00:49,440 --> 01:00:53,839
functional encryption on each of the

1741
01:00:51,520 --> 01:00:55,200
sets of them so we'll have independent

1742
01:00:53,839 --> 01:00:56,799
functional encryption scheme for each

1743
01:00:55,200 --> 01:00:58,799
set of them and we can compute them

1744
01:00:56,799 --> 01:01:02,079
independently so we get the

1745
01:00:58,799 --> 01:01:03,200
uh results of each set of shares of the

1746
01:01:02,079 --> 01:01:05,520
function shares

1747
01:01:03,200 --> 01:01:06,720
and then we can then recombine these all

1748
01:01:05,520 --> 01:01:09,520
into our

1749
01:01:06,720 --> 01:01:11,439
function of our message so again it's a

1750
01:01:09,520 --> 01:01:12,880
sort of like function secret sharing and

1751
01:01:11,440 --> 01:01:14,880
as long as one of the

1752
01:01:12,880 --> 01:01:16,000
sets of shares or enough sets of shares

1753
01:01:14,880 --> 01:01:18,720
are hidden

1754
01:01:16,000 --> 01:01:20,079
then we can prove security so our

1755
01:01:18,720 --> 01:01:21,520
security notion actually requires

1756
01:01:20,079 --> 01:01:24,400
multiple sets to be hidden

1757
01:01:21,520 --> 01:01:25,599
uh so we require multiple of the

1758
01:01:24,400 --> 01:01:27,920
functional encryption schemes to be

1759
01:01:25,599 --> 01:01:27,920
secure

1760
01:01:31,119 --> 01:01:36,839
all right thank you very much and there

1761
01:01:32,960 --> 01:01:39,200
is one more question for you

1762
01:01:36,839 --> 01:01:41,200
um i'd just like to mention that you're

1763
01:01:39,200 --> 01:01:44,078
a few minutes over so we should try to

1764
01:01:41,200 --> 01:01:44,078
wrap up quickly

1765
01:01:44,720 --> 01:01:48,640
okay so let me just ask the last

1766
01:01:46,480 --> 01:01:50,480
question and then and then we wrap up

1767
01:01:48,640 --> 01:01:52,160
there is there are a few questions on

1768
01:01:50,480 --> 01:01:54,720
the chat but maybe you guys can

1769
01:01:52,160 --> 01:01:56,160
take it offline um so jessica asks

1770
01:01:54,720 --> 01:01:58,799
whether you can say anything more about

1771
01:01:56,160 --> 01:02:01,598
the nested hardcore measure technique

1772
01:01:58,799 --> 01:02:03,119
right okay so yeah so for our our

1773
01:02:01,599 --> 01:02:05,440
nesting technique

1774
01:02:03,119 --> 01:02:06,880
uh we'll have we use hardcore measures

1775
01:02:05,440 --> 01:02:08,559
we'll have a hardcore measure for the

1776
01:02:06,880 --> 01:02:10,160
inner encryption outer encryption so if

1777
01:02:08,559 --> 01:02:13,680
you consider them nested

1778
01:02:10,160 --> 01:02:15,359
on each other and for the

1779
01:02:13,680 --> 01:02:17,118
problems here when we do the reduction

1780
01:02:15,359 --> 01:02:20,558
so further reduction we'll have to

1781
01:02:17,119 --> 01:02:22,400
sample from the outer hardcore measure

1782
01:02:20,559 --> 01:02:24,000
and this is a problem one because the

1783
01:02:22,400 --> 01:02:25,680
other hardcore measure might not be

1784
01:02:24,000 --> 01:02:26,720
efficient to sample from or efficient to

1785
01:02:25,680 --> 01:02:29,279
compute

1786
01:02:26,720 --> 01:02:30,799
and then it also may rely on the inner

1787
01:02:29,280 --> 01:02:32,400
encryption so like whether or not the

1788
01:02:30,799 --> 01:02:34,960
inner encryption is secure

1789
01:02:32,400 --> 01:02:37,200
so we have to get around this by uh

1790
01:02:34,960 --> 01:02:39,119
simulating the outer hardcore measure

1791
01:02:37,200 --> 01:02:40,399
and making it sort of independent of the

1792
01:02:39,119 --> 01:02:42,640
inner encryption but

1793
01:02:40,400 --> 01:02:43,920
uh the longer talk has more details

1794
01:02:42,640 --> 01:02:47,118
about this

1795
01:02:43,920 --> 01:02:49,200
and you can probably message me as well

1796
01:02:47,119 --> 01:02:50,640
perfect thank you very much so i'm gonna

1797
01:02:49,200 --> 01:02:53,439
leave it to timber for

1798
01:02:50,640 --> 01:02:53,759
the closing remarks yeah okay so i mean

1799
01:02:53,440 --> 01:02:55,280
we

1800
01:02:53,760 --> 01:02:56,960
ran a little bit over time but we

1801
01:02:55,280 --> 01:02:58,960
started late so i guess this is fine and

1802
01:02:56,960 --> 01:03:01,039
the topic is interesting enough

1803
01:02:58,960 --> 01:03:03,200
so yeah so julia and i would like to

1804
01:03:01,039 --> 01:03:05,520
thank all speakers for insightful

1805
01:03:03,200 --> 01:03:08,399
presentations and very good discussion

1806
01:03:05,520 --> 01:03:10,319
um so yeah a silent route of applause i

1807
01:03:08,400 --> 01:03:13,200
guess is very deserved

1808
01:03:10,319 --> 01:03:15,279
um yeah coming up next is the session on

1809
01:03:13,200 --> 01:03:17,118
post quantum crypto one which will start

1810
01:03:15,280 --> 01:03:20,799
in about 10 minutes

1811
01:03:17,119 --> 01:03:20,799
and then yeah enjoy

