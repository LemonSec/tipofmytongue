1
00:00:04,480 --> 00:00:08,320
hi

2
00:00:05,920 --> 00:00:10,719
my name is alexander nielsen i'm a phd

3
00:00:08,320 --> 00:00:13,920
student at lund university in sweden

4
00:00:10,719 --> 00:00:15,838
and at the security company adventure

5
00:00:13,920 --> 00:00:18,000
today i'm going to present the paper a

6
00:00:15,839 --> 00:00:19,119
key recovery timing attack on post

7
00:00:18,000 --> 00:00:21,198
quantum primitives

8
00:00:19,119 --> 00:00:22,640
using the fujisaka okumoto

9
00:00:21,199 --> 00:00:25,760
transformation and its

10
00:00:22,640 --> 00:00:27,840
application on frodocamp

11
00:00:25,760 --> 00:00:30,080
it was authored by myself and

12
00:00:27,840 --> 00:00:33,840
tomasurance on naloon university

13
00:00:30,080 --> 00:00:35,839
and changu also from lund university who

14
00:00:33,840 --> 00:00:39,360
as well as the time was working at the

15
00:00:35,840 --> 00:00:39,360
university of bergen norway

16
00:00:39,440 --> 00:00:43,440
so let's start with some preliminaries

17
00:00:41,600 --> 00:00:44,079
as we all know when crypto is

18
00:00:43,440 --> 00:00:46,079
implemented

19
00:00:44,079 --> 00:00:48,320
we run the risk of introducing new

20
00:00:46,079 --> 00:00:50,000
weaknesses not anticipated by the

21
00:00:48,320 --> 00:00:51,600
theoretical models

22
00:00:50,000 --> 00:00:53,760
under which many schemes are often

23
00:00:51,600 --> 00:00:55,840
proven secure

24
00:00:53,760 --> 00:00:57,039
obviously this is due to the inability

25
00:00:55,840 --> 00:00:59,840
of these models

26
00:00:57,039 --> 00:01:01,760
to sufficiently capture the real world

27
00:00:59,840 --> 00:01:03,920
behavior of silicon

28
00:01:01,760 --> 00:01:05,920
whether it is implemented in software or

29
00:01:03,920 --> 00:01:08,320
hardware

30
00:01:05,920 --> 00:01:10,799
this disconnect between the theoretical

31
00:01:08,320 --> 00:01:12,399
and mathematical models and on silicon

32
00:01:10,799 --> 00:01:14,400
behavior brings us to our first

33
00:01:12,400 --> 00:01:17,119
observation

34
00:01:14,400 --> 00:01:18,400
implementing crypto is hard we know this

35
00:01:17,119 --> 00:01:20,799
because over the years

36
00:01:18,400 --> 00:01:22,400
many so-called sign channel tags have

37
00:01:20,799 --> 00:01:24,720
surfaced

38
00:01:22,400 --> 00:01:26,960
we have the first sectional attack on

39
00:01:24,720 --> 00:01:30,000
rsa and different hellmann dating as far

40
00:01:26,960 --> 00:01:32,479
back as 1996

41
00:01:30,000 --> 00:01:33,600
and openssl has been attacked again and

42
00:01:32,479 --> 00:01:35,039
again

43
00:01:33,600 --> 00:01:37,199
and there are of course many more

44
00:01:35,040 --> 00:01:39,280
attacks than i have listed here

45
00:01:37,200 --> 00:01:40,640
but these are the most impactful attacks

46
00:01:39,280 --> 00:01:43,119
against the classical schemes that we

47
00:01:40,640 --> 00:01:46,159
use today

48
00:01:43,119 --> 00:01:48,079
but what about post quantum schemes

49
00:01:46,159 --> 00:01:51,680
well yes we have those as well for

50
00:01:48,079 --> 00:01:58,399
example against immaculees in 2010

51
00:01:51,680 --> 00:02:00,240
and 2013. and against bliss in 2016.

52
00:01:58,399 --> 00:02:01,680
and the most recent attack is against

53
00:02:00,240 --> 00:02:03,759
lack in ram stake

54
00:02:01,680 --> 00:02:05,040
that exploited the timing variations

55
00:02:03,759 --> 00:02:06,719
when executing

56
00:02:05,040 --> 00:02:09,039
the error correcting codes that these

57
00:02:06,719 --> 00:02:11,120
schemes employ to reduce the decoding

58
00:02:09,038 --> 00:02:13,040
failure rate

59
00:02:11,120 --> 00:02:16,000
the authors showed that the attack could

60
00:02:13,040 --> 00:02:17,840
be generalized to cover any scheme

61
00:02:16,000 --> 00:02:19,520
which inherently employ error correcting

62
00:02:17,840 --> 00:02:22,319
codes which are not implemented in

63
00:02:19,520 --> 00:02:24,000
constant time manner

64
00:02:22,319 --> 00:02:25,839
and here today i'm also presenting a

65
00:02:24,000 --> 00:02:27,760
general attack

66
00:02:25,840 --> 00:02:29,599
but we are targeting the fujisaki

67
00:02:27,760 --> 00:02:31,359
okamoto construction which was not

68
00:02:29,599 --> 00:02:33,839
previously known has to be implemented

69
00:02:31,360 --> 00:02:36,400
in a constant time manner

70
00:02:33,840 --> 00:02:38,000
and this is the core of our contribution

71
00:02:36,400 --> 00:02:40,480
namely that even though as we'll see

72
00:02:38,000 --> 00:02:42,720
later the f4 transform does not actually

73
00:02:40,480 --> 00:02:44,399
handle any secret information

74
00:02:42,720 --> 00:02:46,319
it still needs to be implemented in

75
00:02:44,400 --> 00:02:48,319
constant time

76
00:02:46,319 --> 00:02:50,160
this was apparently not well known

77
00:02:48,319 --> 00:02:51,760
before so we can see that the list of

78
00:02:50,160 --> 00:02:52,079
schemes that at some point in time did

79
00:02:51,760 --> 00:02:53,679
not

80
00:02:52,080 --> 00:02:56,959
implement therefore transformation in

81
00:02:53,680 --> 00:03:00,400
constant time it's not so short

82
00:02:56,959 --> 00:03:04,319
we have for example photochem lac bike

83
00:03:00,400 --> 00:03:06,239
hqc rollo and rqc

84
00:03:04,319 --> 00:03:08,720
we want to know that this list is by no

85
00:03:06,239 --> 00:03:11,120
means comprehensive

86
00:03:08,720 --> 00:03:12,319
in the paper we have selected photocam

87
00:03:11,120 --> 00:03:14,159
to demonstrate

88
00:03:12,319 --> 00:03:16,480
the attack due to its conservative

89
00:03:14,159 --> 00:03:18,560
design and the designers clear

90
00:03:16,480 --> 00:03:20,079
statements of otherwise using constant

91
00:03:18,560 --> 00:03:22,400
time and side channel resistant

92
00:03:20,080 --> 00:03:24,319
implementation

93
00:03:22,400 --> 00:03:27,040
i also wish to add that partial attack

94
00:03:24,319 --> 00:03:29,119
details on a theoretical attack on lac

95
00:03:27,040 --> 00:03:31,440
is included in as an appendix to the

96
00:03:29,120 --> 00:03:31,440
paper

97
00:03:31,680 --> 00:03:35,200
before we go any further i think it

98
00:03:33,519 --> 00:03:37,200
would be a good idea to

99
00:03:35,200 --> 00:03:38,560
very shortly go through some background

100
00:03:37,200 --> 00:03:40,399
just to establish some of the core

101
00:03:38,560 --> 00:03:44,080
concepts that we're talking about

102
00:03:40,400 --> 00:03:46,560
i'll try to be as brief as possible

103
00:03:44,080 --> 00:03:48,480
first up is public key encryption which

104
00:03:46,560 --> 00:03:49,280
is most simply defined as a triplet of

105
00:03:48,480 --> 00:03:51,840
algorithms

106
00:03:49,280 --> 00:03:53,360
namely key generation encryption and

107
00:03:51,840 --> 00:03:55,200
decryption

108
00:03:53,360 --> 00:03:57,439
but many of the schemes in the nist post

109
00:03:55,200 --> 00:03:59,599
quantum crypto standardization project

110
00:03:57,439 --> 00:04:01,359
are not actually defined as a pke scheme

111
00:03:59,599 --> 00:04:03,359
but are instead defined as a key

112
00:04:01,360 --> 00:04:05,120
encapsulation scheme

113
00:04:03,360 --> 00:04:07,439
that instead of encrypting a plain text

114
00:04:05,120 --> 00:04:09,360
directly produces a shared secret

115
00:04:07,439 --> 00:04:12,560
by which one can use symmetric crypto to

116
00:04:09,360 --> 00:04:14,560
encrypt a variable sized payload

117
00:04:12,560 --> 00:04:16,160
an extend of encryption and decryption

118
00:04:14,560 --> 00:04:18,160
algorithms we talk about

119
00:04:16,160 --> 00:04:20,959
encapsulation and decapsulation

120
00:04:18,160 --> 00:04:20,959
algorithms

121
00:04:21,279 --> 00:04:25,840
now the security of a pke or a chem can

122
00:04:24,080 --> 00:04:26,719
be defined in a variety of different

123
00:04:25,840 --> 00:04:29,359
models

124
00:04:26,720 --> 00:04:30,639
but the common strategy is to analyze

125
00:04:29,360 --> 00:04:33,120
the pke scheme

126
00:04:30,639 --> 00:04:36,240
in the model indistinguishability on the

127
00:04:33,120 --> 00:04:36,240
chosen plaintext attack

128
00:04:36,880 --> 00:04:40,639
which is defined as a security game

129
00:04:38,720 --> 00:04:42,000
where the adversary only has access to

130
00:04:40,639 --> 00:04:44,240
the public key and the public

131
00:04:42,000 --> 00:04:46,240
encryption as well as the polynomial

132
00:04:44,240 --> 00:04:48,560
bounded amount of computational

133
00:04:46,240 --> 00:04:50,400
resources

134
00:04:48,560 --> 00:04:51,840
the goal of the game is for the

135
00:04:50,400 --> 00:04:53,919
adversary to

136
00:04:51,840 --> 00:04:55,599
form a cyber text determine which out of

137
00:04:53,919 --> 00:04:56,880
two publicly known plaintexts the

138
00:04:55,600 --> 00:05:00,960
ciphertext corresponds

139
00:04:56,880 --> 00:05:02,639
to this model is sufficient for some use

140
00:05:00,960 --> 00:05:04,719
cases but not for all

141
00:05:02,639 --> 00:05:09,039
for other use cases a stronger model is

142
00:05:04,720 --> 00:05:11,039
desired and are mentioned in cca here

143
00:05:09,039 --> 00:05:12,400
it differs from the cpa models in that

144
00:05:11,039 --> 00:05:14,639
the address server now has

145
00:05:12,400 --> 00:05:16,239
access to a decryption article which

146
00:05:14,639 --> 00:05:18,479
answers with the corresponding plain

147
00:05:16,240 --> 00:05:20,400
text to any cipher text

148
00:05:18,479 --> 00:05:24,000
except for a specific ciphertext used in

149
00:05:20,400 --> 00:05:27,359
the challenge of course

150
00:05:24,000 --> 00:05:29,840
in the next pqc project

151
00:05:27,360 --> 00:05:31,919
many submissions use the same approach

152
00:05:29,840 --> 00:05:35,359
to construct a csa secure cam

153
00:05:31,919 --> 00:05:37,359
from a cpa secure pke this approach

154
00:05:35,360 --> 00:05:39,840
makes use of the fusaka or motor

155
00:05:37,360 --> 00:05:39,840
transform

156
00:05:40,720 --> 00:05:44,639
before we talk more about the fo

157
00:05:42,479 --> 00:05:46,800
transform i want to mention an important

158
00:05:44,639 --> 00:05:48,080
property that many of the pqc schemes

159
00:05:46,800 --> 00:05:52,320
both in and outside

160
00:05:48,080 --> 00:05:54,000
the nist project share the property

161
00:05:52,320 --> 00:05:55,759
i'm talking about is the way that these

162
00:05:54,000 --> 00:05:57,680
schemes encrypt messages

163
00:05:55,759 --> 00:05:58,880
on a high level they do so by first

164
00:05:57,680 --> 00:06:00,639
encoding it

165
00:05:58,880 --> 00:06:02,639
and then by adding a randomized error

166
00:06:00,639 --> 00:06:05,120
vector

167
00:06:02,639 --> 00:06:07,039
this means that when the decoding the

168
00:06:05,120 --> 00:06:08,880
arrow vector must be removed by either

169
00:06:07,039 --> 00:06:12,560
some form of lattice technique

170
00:06:08,880 --> 00:06:14,400
or by a decoding algorithm basically

171
00:06:12,560 --> 00:06:16,960
it's on this property that the security

172
00:06:14,400 --> 00:06:18,638
of the scheme's hinges one

173
00:06:16,960 --> 00:06:20,318
but the thing that we care about today

174
00:06:18,639 --> 00:06:21,680
is the fact that if we modify the

175
00:06:20,319 --> 00:06:23,440
ciphertext

176
00:06:21,680 --> 00:06:24,880
of these schemes with a small amount we

177
00:06:23,440 --> 00:06:27,919
can still decrypt to the same

178
00:06:24,880 --> 00:06:30,560
original plain text

179
00:06:27,919 --> 00:06:32,318
however if we modify the ciphertext with

180
00:06:30,560 --> 00:06:33,280
a larger amount we suddenly fail to

181
00:06:32,319 --> 00:06:36,400
decrypt

182
00:06:33,280 --> 00:06:38,479
or decrypt another unrelated plaintext

183
00:06:36,400 --> 00:06:40,799
this property is one of the reasons why

184
00:06:38,479 --> 00:06:43,758
many of the schemes are only cpa secure

185
00:06:40,800 --> 00:06:45,280
in the basic construction

186
00:06:43,759 --> 00:06:48,880
it's also one of the things that is

187
00:06:45,280 --> 00:06:50,559
fixed by the f4 transformation

188
00:06:48,880 --> 00:06:52,240
so let's talk a little bit about how the

189
00:06:50,560 --> 00:06:54,319
form transform looks like

190
00:06:52,240 --> 00:06:56,720
and how we can make the scheme more

191
00:06:54,319 --> 00:06:56,720
secure

192
00:06:56,880 --> 00:07:02,080
so to convert a cpa secure pke cipher

193
00:06:59,840 --> 00:07:07,198
into a cca secure chem

194
00:07:02,080 --> 00:07:09,440
we can use the algorithm 1 here as shown

195
00:07:07,199 --> 00:07:11,360
basically we take as input a public key

196
00:07:09,440 --> 00:07:12,880
and output a ciphertext and a shared

197
00:07:11,360 --> 00:07:15,520
secret

198
00:07:12,880 --> 00:07:17,280
first we pick a random value m then we

199
00:07:15,520 --> 00:07:19,359
use the pseudorandom function that

200
00:07:17,280 --> 00:07:21,919
generates values indistinguishable from

201
00:07:19,360 --> 00:07:24,240
true randomness

202
00:07:21,919 --> 00:07:26,318
from the sampling of this hash function

203
00:07:24,240 --> 00:07:29,520
we get random looking values r

204
00:07:26,319 --> 00:07:32,319
and k the next step is to call the

205
00:07:29,520 --> 00:07:34,080
encryption function from the pka scheme

206
00:07:32,319 --> 00:07:35,599
as input we have the public key and the

207
00:07:34,080 --> 00:07:37,758
message m

208
00:07:35,599 --> 00:07:39,280
we use r as a source of randomness in

209
00:07:37,759 --> 00:07:43,120
order to make the schemes

210
00:07:39,280 --> 00:07:44,239
deterministic note here that the

211
00:07:43,120 --> 00:07:46,960
encryption function

212
00:07:44,240 --> 00:07:49,360
here is a call to in cpa secure pke

213
00:07:46,960 --> 00:07:49,359
cipher

214
00:07:49,520 --> 00:07:52,960
and i would also like to point out that

215
00:07:51,360 --> 00:07:54,720
there are many variations of the fo

216
00:07:52,960 --> 00:07:57,359
transform and the one presented here is

217
00:07:54,720 --> 00:07:59,759
the one that is used by photochem

218
00:07:57,360 --> 00:08:01,039
but essentially all camps in an east pcs

219
00:07:59,759 --> 00:08:03,759
projects use a similar

220
00:08:01,039 --> 00:08:05,440
construction okay so that was the

221
00:08:03,759 --> 00:08:06,879
encapsulation function

222
00:08:05,440 --> 00:08:08,960
next step is how to do the

223
00:08:06,879 --> 00:08:11,199
de-capsulation

224
00:08:08,960 --> 00:08:13,520
the capsulation is just as conceptually

225
00:08:11,199 --> 00:08:15,120
simple as the encapsulation function

226
00:08:13,520 --> 00:08:16,960
although we need a few more steps to

227
00:08:15,120 --> 00:08:19,599
describe it

228
00:08:16,960 --> 00:08:21,198
what we do is to decode the ciphertext

229
00:08:19,599 --> 00:08:22,878
and then re-encrypt it

230
00:08:21,199 --> 00:08:26,080
and compare the new ciphertext to one

231
00:08:22,879 --> 00:08:28,560
that was received

232
00:08:26,080 --> 00:08:30,000
algorithm 2 looks like this where we

233
00:08:28,560 --> 00:08:33,599
have the ciphertext as well

234
00:08:30,000 --> 00:08:35,760
as the secret and public keys as inputs

235
00:08:33,599 --> 00:08:38,839
the output is hopefully the same shared

236
00:08:35,760 --> 00:08:40,479
secret as was given by the encapsulation

237
00:08:38,839 --> 00:08:43,360
function

238
00:08:40,479 --> 00:08:45,600
like i said first we decrypt the receive

239
00:08:43,360 --> 00:08:47,519
ciphertext using the secret key

240
00:08:45,600 --> 00:08:49,279
we call that decrypted ciphertext m

241
00:08:47,519 --> 00:08:51,279
prime

242
00:08:49,279 --> 00:08:53,600
then we use the same hash function as in

243
00:08:51,279 --> 00:08:56,640
the encapsulation function to generate r

244
00:08:53,600 --> 00:08:58,959
prime and k prime

245
00:08:56,640 --> 00:09:00,959
the public key m prime and r prime are

246
00:08:58,959 --> 00:09:01,760
in the same managers to generate a new

247
00:09:00,959 --> 00:09:08,959
cyber text

248
00:09:01,760 --> 00:09:11,200
called c prime here the next step

249
00:09:08,959 --> 00:09:13,199
is the important part because here we

250
00:09:11,200 --> 00:09:13,680
compare the two ciphertext with each

251
00:09:13,200 --> 00:09:15,680
other

252
00:09:13,680 --> 00:09:17,920
and if they are equal then the shared

253
00:09:15,680 --> 00:09:20,959
secret is computed identically

254
00:09:17,920 --> 00:09:22,959
to the encapsulation function

255
00:09:20,959 --> 00:09:24,319
if they are not equal however we

256
00:09:22,959 --> 00:09:26,959
generate a different

257
00:09:24,320 --> 00:09:26,959
shared secret

258
00:09:27,760 --> 00:09:33,200
this decrypt encrypt compare procedure

259
00:09:30,160 --> 00:09:35,680
is what provides us with cca security

260
00:09:33,200 --> 00:09:37,839
it's also what is removing their

261
00:09:35,680 --> 00:09:39,279
non-deterministic decoding property from

262
00:09:37,839 --> 00:09:43,680
the underlying pke

263
00:09:39,279 --> 00:09:45,760
scheme so now the question is how do we

264
00:09:43,680 --> 00:09:47,439
implement this in software

265
00:09:45,760 --> 00:09:48,959
well it's common knowledge that all

266
00:09:47,440 --> 00:09:51,040
secret dependent

267
00:09:48,959 --> 00:09:54,000
addressing and branching must be

268
00:09:51,040 --> 00:09:57,920
implemented in constant time

269
00:09:54,000 --> 00:09:57,920
but what about this comparison here

270
00:09:58,320 --> 00:10:02,480
because the original ciphertext is not a

271
00:10:00,640 --> 00:10:04,240
secret and neither is c prime

272
00:10:02,480 --> 00:10:07,120
since it's also known to the sending

273
00:10:04,240 --> 00:10:09,040
party in an attack scenario

274
00:10:07,120 --> 00:10:10,640
so you would be forgiven to believe that

275
00:10:09,040 --> 00:10:13,599
this comparison do not need to be

276
00:10:10,640 --> 00:10:16,319
implemented in constant time

277
00:10:13,600 --> 00:10:16,720
but as my co-authors and i will show

278
00:10:16,320 --> 00:10:19,839
this

279
00:10:16,720 --> 00:10:21,600
would be a mistake

280
00:10:19,839 --> 00:10:23,279
okay so with the background out of the

281
00:10:21,600 --> 00:10:25,680
way we can proceed to talk more about

282
00:10:23,279 --> 00:10:27,760
the attack

283
00:10:25,680 --> 00:10:29,439
i'm first going to talk about attack in

284
00:10:27,760 --> 00:10:31,120
general terms before we dive

285
00:10:29,440 --> 00:10:33,440
into the details of the attack on

286
00:10:31,120 --> 00:10:35,120
freudochem

287
00:10:33,440 --> 00:10:37,120
so as we saw before on the previous

288
00:10:35,120 --> 00:10:38,320
slide we know that in many cases the

289
00:10:37,120 --> 00:10:40,640
comparison step

290
00:10:38,320 --> 00:10:41,360
in the f4 transform is often implemented

291
00:10:40,640 --> 00:10:44,160
with the c

292
00:10:41,360 --> 00:10:45,519
function memcomp and here is how we can

293
00:10:44,160 --> 00:10:48,880
use such an implementation

294
00:10:45,519 --> 00:10:50,800
at the top we have the two ciphertexts

295
00:10:48,880 --> 00:10:52,880
c being the ciphertext as received by

296
00:10:50,800 --> 00:10:55,120
the decapsulation function

297
00:10:52,880 --> 00:10:57,519
and c prime being the re-encryption of

298
00:10:55,120 --> 00:11:00,079
the decoder plaintext

299
00:10:57,519 --> 00:11:00,720
the two values are compared in the f4

300
00:11:00,079 --> 00:11:03,439
transform

301
00:11:00,720 --> 00:11:04,079
with the memcom function which has a

302
00:11:03,440 --> 00:11:06,399
sort

303
00:11:04,079 --> 00:11:08,880
short circuiting behavior as our first

304
00:11:06,399 --> 00:11:08,880
assumption

305
00:11:10,320 --> 00:11:14,000
for the second assumption we make use of

306
00:11:12,240 --> 00:11:16,079
the non-deterministic property

307
00:11:14,000 --> 00:11:18,399
of the underlying cpa decryption

308
00:11:16,079 --> 00:11:18,399
function

309
00:11:18,720 --> 00:11:22,240
that is a small modification to

310
00:11:20,560 --> 00:11:24,079
ciphertext c

311
00:11:22,240 --> 00:11:25,600
before entering the decapsulation

312
00:11:24,079 --> 00:11:27,439
algorithm

313
00:11:25,600 --> 00:11:31,600
will result in a c prime that is

314
00:11:27,440 --> 00:11:31,600
identical to the original ciphertext

315
00:11:31,680 --> 00:11:36,000
this means that memcomp terminates at

316
00:11:34,079 --> 00:11:38,239
the fourth comparison in our example

317
00:11:36,000 --> 00:11:38,240
here

318
00:11:39,040 --> 00:11:42,880
however if we make a large modification

319
00:11:41,200 --> 00:11:44,720
instead

320
00:11:42,880 --> 00:11:46,320
then we assume that c prime will be

321
00:11:44,720 --> 00:11:47,920
decoded to something completely

322
00:11:46,320 --> 00:11:50,160
different

323
00:11:47,920 --> 00:11:51,680
this is assumption 3 which means that

324
00:11:50,160 --> 00:11:53,519
with high probability

325
00:11:51,680 --> 00:11:57,839
memcomp terminates at the very first

326
00:11:53,519 --> 00:11:57,839
comparison step

327
00:12:01,120 --> 00:12:04,320
this means that due to the

328
00:12:02,399 --> 00:12:06,320
short-circuiting behavior of memcomp we

329
00:12:04,320 --> 00:12:09,200
get a very different timing profile for

330
00:12:06,320 --> 00:12:11,760
these two cases

331
00:12:09,200 --> 00:12:13,680
the strategy then is to instead make

332
00:12:11,760 --> 00:12:15,600
modifications at the end

333
00:12:13,680 --> 00:12:19,359
of the cipher text in order to enlarge

334
00:12:15,600 --> 00:12:19,360
the differences as much as possible

335
00:12:19,839 --> 00:12:23,760
by doing this we can using for example

336
00:12:22,800 --> 00:12:25,439
binary search

337
00:12:23,760 --> 00:12:27,040
find out the exact amount of

338
00:12:25,440 --> 00:12:29,040
modifications necessary

339
00:12:27,040 --> 00:12:31,279
to flip c prime to a different cipher

340
00:12:29,040 --> 00:12:31,279
text

341
00:12:33,040 --> 00:12:36,079
then we simply perform the attack

342
00:12:34,959 --> 00:12:38,000
multiple times

343
00:12:36,079 --> 00:12:40,239
while measuring the execution time of

344
00:12:38,000 --> 00:12:41,760
the decapsulation function in order to

345
00:12:40,240 --> 00:12:44,639
distinguish between

346
00:12:41,760 --> 00:12:44,639
the two cases

347
00:12:45,519 --> 00:12:48,880
when we have done this using the

348
00:12:47,519 --> 00:12:51,279
recorded knowledge of m

349
00:12:48,880 --> 00:12:54,320
we can extract secret information from

350
00:12:51,279 --> 00:12:56,320
the chem scheme we are attacking

351
00:12:54,320 --> 00:13:00,000
although this part is highly dependent

352
00:12:56,320 --> 00:13:00,000
on the actual scheme in question

353
00:13:00,959 --> 00:13:04,719
we can summarize the previous slide as

354
00:13:02,880 --> 00:13:07,279
an algorithm for finding out whether or

355
00:13:04,720 --> 00:13:09,279
not a ciphertext modification d

356
00:13:07,279 --> 00:13:12,639
would result in a decryption failure in

357
00:13:09,279 --> 00:13:16,160
the cpa secure decryption function

358
00:13:12,639 --> 00:13:17,839
here we have algorithm 3 where we input

359
00:13:16,160 --> 00:13:19,279
a plaintext m

360
00:13:17,839 --> 00:13:21,279
and the amount of modifications to

361
00:13:19,279 --> 00:13:25,519
perform in the value

362
00:13:21,279 --> 00:13:26,560
variable d the output is whether or not

363
00:13:25,519 --> 00:13:28,959
the value d

364
00:13:26,560 --> 00:13:31,359
results in a different value of c prime

365
00:13:28,959 --> 00:13:31,359
or not

366
00:13:32,000 --> 00:13:35,519
first we encode the plain text as in the

367
00:13:34,800 --> 00:13:38,719
original

368
00:13:35,519 --> 00:13:40,079
encapsulation function then we do the

369
00:13:38,720 --> 00:13:43,120
modification

370
00:13:40,079 --> 00:13:45,040
the main step of the attack is to send

371
00:13:43,120 --> 00:13:46,720
our modification

372
00:13:45,040 --> 00:13:48,079
to the target and record the side

373
00:13:46,720 --> 00:13:51,120
channel information

374
00:13:48,079 --> 00:13:52,399
after the capsulation function in our

375
00:13:51,120 --> 00:13:56,000
case we simply time

376
00:13:52,399 --> 00:13:57,839
the execution the last step

377
00:13:56,000 --> 00:13:59,680
is to determine whether or not the cpa

378
00:13:57,839 --> 00:14:01,120
call resulted in a different ciphertext

379
00:13:59,680 --> 00:14:02,959
or not

380
00:14:01,120 --> 00:14:06,000
we use the side channel information to

381
00:14:02,959 --> 00:14:06,000
make this decision

382
00:14:07,600 --> 00:14:11,360
unfortunately using this information to

383
00:14:10,399 --> 00:14:13,680
mount an attack

384
00:14:11,360 --> 00:14:14,959
requires adaptations to the actual cam

385
00:14:13,680 --> 00:14:17,359
scheme

386
00:14:14,959 --> 00:14:19,439
but algorithm 4 here highlights some of

387
00:14:17,360 --> 00:14:21,600
the general steps

388
00:14:19,440 --> 00:14:24,720
first we loop a predetermined number of

389
00:14:21,600 --> 00:14:27,760
times in such a way that we find

390
00:14:24,720 --> 00:14:30,399
a set of d and m values such that

391
00:14:27,760 --> 00:14:32,720
the value of d represents the exact

392
00:14:30,399 --> 00:14:34,639
maximum modification possible

393
00:14:32,720 --> 00:14:36,399
without causing a decryption failure in

394
00:14:34,639 --> 00:14:38,560
the cpa call

395
00:14:36,399 --> 00:14:40,720
we proposed to use binary search to find

396
00:14:38,560 --> 00:14:42,719
this value

397
00:14:40,720 --> 00:14:44,000
then we used to set the plaintext and

398
00:14:42,720 --> 00:14:48,480
corresponding d values

399
00:14:44,000 --> 00:14:48,480
to somehow extract the secret key

400
00:14:49,040 --> 00:14:53,360
in order to provide more details on the

401
00:14:51,440 --> 00:14:55,040
attack we must limit ourselves to a

402
00:14:53,360 --> 00:14:57,920
specific scheme

403
00:14:55,040 --> 00:14:59,199
we use here protocam as an example but

404
00:14:57,920 --> 00:15:00,880
we note that there are other

405
00:14:59,199 --> 00:15:03,040
possibilities

406
00:15:00,880 --> 00:15:04,320
the key generation algorithm for frodo

407
00:15:03,040 --> 00:15:06,160
chem specification

408
00:15:04,320 --> 00:15:08,000
looks a little like this but i have

409
00:15:06,160 --> 00:15:09,519
simplified it as much as i could so that

410
00:15:08,000 --> 00:15:13,440
we do not get hung up on

411
00:15:09,519 --> 00:15:15,120
unimportant details

412
00:15:13,440 --> 00:15:17,279
i wish to draw your attention to the

413
00:15:15,120 --> 00:15:17,839
last equation for the public key where

414
00:15:17,279 --> 00:15:20,000
both b

415
00:15:17,839 --> 00:15:22,240
and a are publicly known matrices and

416
00:15:20,000 --> 00:15:25,519
both s and e are arrowed matrices

417
00:15:22,240 --> 00:15:29,040
with small values both are secrets

418
00:15:25,519 --> 00:15:31,120
and s is saved as part of the secret key

419
00:15:29,040 --> 00:15:34,480
make a note of this equation because i'm

420
00:15:31,120 --> 00:15:34,480
going to refer to it later

421
00:15:34,639 --> 00:15:39,759
the encapsulation algorithm is too large

422
00:15:37,040 --> 00:15:41,599
to properly display here in full details

423
00:15:39,759 --> 00:15:44,480
so instead i'm going to once again show

424
00:15:41,600 --> 00:15:44,480
a simplified version

425
00:15:44,959 --> 00:15:49,199
a uniform random plain text is first

426
00:15:47,519 --> 00:15:51,440
chosen it is then used

427
00:15:49,199 --> 00:15:53,680
to generate some seven random bit

428
00:15:51,440 --> 00:15:56,000
strings

429
00:15:53,680 --> 00:15:59,839
in turn determines error matrices s

430
00:15:56,000 --> 00:15:59,839
prime e prime and e double prime

431
00:16:00,880 --> 00:16:09,199
the ciphertext contains two parts

432
00:16:05,920 --> 00:16:09,599
one denoted as b prime being s prime

433
00:16:09,199 --> 00:16:13,599
times

434
00:16:09,600 --> 00:16:16,800
a plus e prime and the second part

435
00:16:13,600 --> 00:16:20,079
denoted as c capital

436
00:16:16,800 --> 00:16:21,359
being s prime times b plus e double

437
00:16:20,079 --> 00:16:23,199
prime

438
00:16:21,360 --> 00:16:25,920
plus the encoding of the random

439
00:16:23,199 --> 00:16:28,160
plaintext m

440
00:16:25,920 --> 00:16:31,599
these matrices are converted to b

441
00:16:28,160 --> 00:16:35,360
strings using the frodo pack algorithm

442
00:16:31,600 --> 00:16:38,160
and finally we return the secret

443
00:16:35,360 --> 00:16:38,160
and the ciphertext

444
00:16:39,360 --> 00:16:43,360
continuing with our simplified

445
00:16:41,120 --> 00:16:47,199
presentation of roto we now

446
00:16:43,360 --> 00:16:49,120
arrive at the decapsulation function

447
00:16:47,199 --> 00:16:50,800
for the first step the decapsulation

448
00:16:49,120 --> 00:16:52,959
removes all the noise and hopefully

449
00:16:50,800 --> 00:16:56,399
recovers the initial plaintext

450
00:16:52,959 --> 00:16:58,560
we call this value m prime

451
00:16:56,399 --> 00:17:01,120
then we use the m prime to re-encrypt

452
00:16:58,560 --> 00:17:04,159
using the same steps as in the

453
00:17:01,120 --> 00:17:05,760
encapsulation function this results in

454
00:17:04,160 --> 00:17:09,439
the new ciphertext parts

455
00:17:05,760 --> 00:17:12,000
b double prime and c prime

456
00:17:09,439 --> 00:17:14,880
and lastly we do the comparison to get

457
00:17:12,000 --> 00:17:18,559
the share secret

458
00:17:14,880 --> 00:17:20,959
just like in the general for transform

459
00:17:18,559 --> 00:17:21,839
the useful observation here is that the

460
00:17:20,959 --> 00:17:24,400
quality check

461
00:17:21,839 --> 00:17:27,760
in floricam is implemented with memcomp

462
00:17:24,400 --> 00:17:27,760
as previously discussed

463
00:17:31,120 --> 00:17:34,639
in the de-capsulation step we have this

464
00:17:33,039 --> 00:17:37,679
step where we compute c

465
00:17:34,640 --> 00:17:39,760
minus b prime times s

466
00:17:37,679 --> 00:17:41,120
by doing some substitutions one could

467
00:17:39,760 --> 00:17:42,799
easily see that this

468
00:17:41,120 --> 00:17:44,559
actually computes the encoding of the

469
00:17:42,799 --> 00:17:48,160
random value

470
00:17:44,559 --> 00:17:50,799
m prime plus s prime times e

471
00:17:48,160 --> 00:17:53,120
minus e prime times s plus e double

472
00:17:50,799 --> 00:17:53,120
prime

473
00:17:53,679 --> 00:17:56,880
from the specification of roto we know

474
00:17:55,760 --> 00:18:00,160
that s

475
00:17:56,880 --> 00:18:02,880
s prime e e prime and e double

476
00:18:00,160 --> 00:18:05,120
prime all have small entries in their

477
00:18:02,880 --> 00:18:07,440
respective matrices

478
00:18:05,120 --> 00:18:08,320
this means that the entire tail part of

479
00:18:07,440 --> 00:18:11,120
this equation

480
00:18:08,320 --> 00:18:11,760
will also have somewhat small entries

481
00:18:11,120 --> 00:18:15,520
and can be

482
00:18:11,760 --> 00:18:17,200
regarded as noise and we call this the

483
00:18:15,520 --> 00:18:21,039
combined noise matrix

484
00:18:17,200 --> 00:18:21,039
or as e triple prime

485
00:18:21,840 --> 00:18:25,120
now we observe that the values in s

486
00:18:24,640 --> 00:18:28,160
prime

487
00:18:25,120 --> 00:18:29,280
e prime and e double prime are known and

488
00:18:28,160 --> 00:18:33,440
we also know

489
00:18:29,280 --> 00:18:37,200
that e is equal to b minus a times s

490
00:18:33,440 --> 00:18:37,200
from the equation in the key generation

491
00:18:39,840 --> 00:18:44,639
from this we can see that we will have

492
00:18:42,400 --> 00:18:45,760
linear equations for each entry in the

493
00:18:44,640 --> 00:18:49,039
secret key matrix

494
00:18:45,760 --> 00:18:49,280
s if we can only figure out the value of

495
00:18:49,039 --> 00:18:51,840
e

496
00:18:49,280 --> 00:18:51,840
triple prime

497
00:18:52,480 --> 00:18:56,559
each time we run our attack algorithm we

498
00:18:55,280 --> 00:18:58,559
get

499
00:18:56,559 --> 00:18:59,918
the value of a single entry in the

500
00:18:58,559 --> 00:19:02,720
combined error matrix

501
00:18:59,919 --> 00:19:02,720
e triple prime

502
00:19:02,960 --> 00:19:06,960
such entry provides us with a single

503
00:19:05,919 --> 00:19:10,240
linear equation

504
00:19:06,960 --> 00:19:11,200
of the secret matrix s therefore we need

505
00:19:10,240 --> 00:19:13,039
to collect

506
00:19:11,200 --> 00:19:15,840
roughly as many entries as we have

507
00:19:13,039 --> 00:19:15,840
entries in s

508
00:19:17,520 --> 00:19:21,360
alright by using a lemma from the

509
00:19:19,120 --> 00:19:23,360
fruitcam specification we know that the

510
00:19:21,360 --> 00:19:25,760
range of values for each entry in the

511
00:19:23,360 --> 00:19:26,399
noise matrix that protocam can handle

512
00:19:25,760 --> 00:19:29,600
without

513
00:19:26,400 --> 00:19:30,160
experiencing a decoding failure as you

514
00:19:29,600 --> 00:19:31,600
can see

515
00:19:30,160 --> 00:19:33,360
i'm going to save some time here by

516
00:19:31,600 --> 00:19:35,840
skipping over the details of deriving

517
00:19:33,360 --> 00:19:38,320
this range

518
00:19:35,840 --> 00:19:40,480
and the bounds are that each entry of

519
00:19:38,320 --> 00:19:41,439
the arrow matrix must be greater than or

520
00:19:40,480 --> 00:19:44,480
equal to

521
00:19:41,440 --> 00:19:48,320
minus 2 raised to power

522
00:19:44,480 --> 00:19:51,520
of d minus bp minus 1.

523
00:19:48,320 --> 00:19:53,120
symmetrically it must also be less than

524
00:19:51,520 --> 00:19:56,400
2 raised to the power of d

525
00:19:53,120 --> 00:19:58,479
minus b p minus 1.

526
00:19:56,400 --> 00:19:59,679
this means that we can recover each

527
00:19:58,480 --> 00:20:02,960
index i j

528
00:19:59,679 --> 00:20:02,960
from e triple prime

529
00:20:04,640 --> 00:20:10,880
by determining the value x0 such that

530
00:20:07,840 --> 00:20:13,678
e triple prime plus x0 equals the upper

531
00:20:10,880 --> 00:20:13,679
interval limit

532
00:20:15,679 --> 00:20:18,880
we can do this by using the generic side

533
00:20:18,080 --> 00:20:22,399
channel attack

534
00:20:18,880 --> 00:20:24,240
as previously described so using binary

535
00:20:22,400 --> 00:20:25,760
search we can do this efficiently since

536
00:20:24,240 --> 00:20:28,799
we can detect when the value

537
00:20:25,760 --> 00:20:30,559
x is either too large or too small so

538
00:20:28,799 --> 00:20:34,400
for each tested value of x

539
00:20:30,559 --> 00:20:34,720
we get two possibilities if the value is

540
00:20:34,400 --> 00:20:37,760
not

541
00:20:34,720 --> 00:20:40,159
large enough to cause a decoding failure

542
00:20:37,760 --> 00:20:42,400
the two ciphertext only differs

543
00:20:40,159 --> 00:20:44,080
somewhere in the last positions

544
00:20:42,400 --> 00:20:46,080
meaning we get a close to normal

545
00:20:44,080 --> 00:20:48,080
execution time

546
00:20:46,080 --> 00:20:50,240
but if on the other hand the tested

547
00:20:48,080 --> 00:20:51,918
value of x is larger than frodicam's

548
00:20:50,240 --> 00:20:53,600
design interval

549
00:20:51,919 --> 00:20:55,039
then we end up with totally different

550
00:20:53,600 --> 00:20:57,840
ciphertext

551
00:20:55,039 --> 00:20:59,840
ciphertext which means that the memcom

552
00:20:57,840 --> 00:21:03,678
function will terminate early and we get

553
00:20:59,840 --> 00:21:05,600
a shorter execution time

554
00:21:03,679 --> 00:21:07,679
due to the implementation of memcomp we

555
00:21:05,600 --> 00:21:09,439
decided to introduce the added noise x

556
00:21:07,679 --> 00:21:16,080
at the tail part of the ciphertext in

557
00:21:09,440 --> 00:21:18,000
order to enlarge the time difference

558
00:21:16,080 --> 00:21:19,439
now that we know more of the attack i

559
00:21:18,000 --> 00:21:21,360
think it's time to take a look at some

560
00:21:19,440 --> 00:21:23,280
of our results

561
00:21:21,360 --> 00:21:26,879
we start by only measuring the memcomp

562
00:21:23,280 --> 00:21:26,879
function as employee perforacam

563
00:21:27,760 --> 00:21:33,200
here we have around 10 000 measurements

564
00:21:30,000 --> 00:21:36,400
for three different cases

565
00:21:33,200 --> 00:21:37,520
first we set x to zero that is we make

566
00:21:36,400 --> 00:21:39,679
no modifications

567
00:21:37,520 --> 00:21:43,120
but simply run the decapsulation

568
00:21:39,679 --> 00:21:44,799
algorithm with a valid ciphertext

569
00:21:43,120 --> 00:21:47,199
then we make the smallest possible

570
00:21:44,799 --> 00:21:49,918
modification

571
00:21:47,200 --> 00:21:52,480
and set x to one and finally we make the

572
00:21:49,919 --> 00:21:54,720
largest possible modification

573
00:21:52,480 --> 00:21:56,960
and for each case we measured the timing

574
00:21:54,720 --> 00:21:59,120
behavior of only the calls to the memcom

575
00:21:56,960 --> 00:22:02,320
function

576
00:21:59,120 --> 00:22:04,559
as you can see the difference is huge we

577
00:22:02,320 --> 00:22:07,360
basically go from around 5000 clock

578
00:22:04,559 --> 00:22:09,039
cycles to close to zero

579
00:22:07,360 --> 00:22:12,080
i should note that there are no in

580
00:22:09,039 --> 00:22:13,520
between cases the timing behavior will

581
00:22:12,080 --> 00:22:16,879
always fall into one

582
00:22:13,520 --> 00:22:16,879
or the other category

583
00:22:17,200 --> 00:22:20,720
as you can imagine it would not be

584
00:22:18,960 --> 00:22:23,760
difficult to construct a distinguisher

585
00:22:20,720 --> 00:22:23,760
for these two cases

586
00:22:24,720 --> 00:22:28,880
however if we restrict ourselves to only

587
00:22:26,960 --> 00:22:29,679
measure the entire decapsulation

588
00:22:28,880 --> 00:22:32,320
function

589
00:22:29,679 --> 00:22:34,400
as a real world attack would force us to

590
00:22:32,320 --> 00:22:37,200
then as we can see the differences are

591
00:22:34,400 --> 00:22:39,200
no longer that huge

592
00:22:37,200 --> 00:22:41,120
this means that we must collect many

593
00:22:39,200 --> 00:22:41,760
more samples before we can distinguish

594
00:22:41,120 --> 00:22:44,559
between

595
00:22:41,760 --> 00:22:44,559
these two cases

596
00:22:46,720 --> 00:22:52,159
the differences in runtime are actually

597
00:22:48,799 --> 00:22:54,158
as low as 0.04

598
00:22:52,159 --> 00:22:57,200
so in our lab environment we got good

599
00:22:54,159 --> 00:22:58,960
results with 97 000 encapsulations per

600
00:22:57,200 --> 00:23:00,880
binary search

601
00:22:58,960 --> 00:23:03,520
in order to extract a single entry in e

602
00:23:00,880 --> 00:23:03,520
triple prime

603
00:23:04,000 --> 00:23:10,400
and for floatercam 1344 we have

604
00:23:07,440 --> 00:23:12,640
a noise matrix with a size of 1344 times

605
00:23:10,400 --> 00:23:12,640
eight

606
00:23:14,240 --> 00:23:17,919
combining this we can make a complete

607
00:23:16,559 --> 00:23:20,879
key recovery using

608
00:23:17,919 --> 00:23:22,000
an estimated two to thirty d capsulation

609
00:23:20,880 --> 00:23:26,960
queries

610
00:23:22,000 --> 00:23:26,960
for floricam 1344 aes

611
00:23:28,640 --> 00:23:32,480
so we have just about reached the end of

612
00:23:30,480 --> 00:23:33,120
this talk and i wish to reiterate that

613
00:23:32,480 --> 00:23:35,600
the attack

614
00:23:33,120 --> 00:23:37,360
we have shown is a general one and that

615
00:23:35,600 --> 00:23:39,280
all pqc schemes

616
00:23:37,360 --> 00:23:41,120
should quickly move over to use constant

617
00:23:39,280 --> 00:23:45,760
time implementations

618
00:23:41,120 --> 00:23:45,760
also for the fujisaki okamoto transform

619
00:23:47,039 --> 00:23:51,120
and so finally for the conclusion i have

620
00:23:49,679 --> 00:23:52,240
here an excerpt from the protocam

621
00:23:51,120 --> 00:23:53,918
specification

622
00:23:52,240 --> 00:23:56,000
where the authors claim to have an

623
00:23:53,919 --> 00:23:59,120
implementation that is protected against

624
00:23:56,000 --> 00:23:59,120
timing and cash attacks

625
00:24:01,600 --> 00:24:05,360
i have spent some time looking through

626
00:24:03,279 --> 00:24:07,279
the fruitcam codebase and so far i found

627
00:24:05,360 --> 00:24:09,279
nothing that would invalidate this claim

628
00:24:07,279 --> 00:24:10,960
in so far as dealing with secrets are

629
00:24:09,279 --> 00:24:13,200
concerned

630
00:24:10,960 --> 00:24:15,600
but as we have shown in our paper

631
00:24:13,200 --> 00:24:18,240
implementing crypto is hard

632
00:24:15,600 --> 00:24:20,399
and even when you do everything right it

633
00:24:18,240 --> 00:24:24,240
turns out that you had to do just this

634
00:24:20,400 --> 00:24:25,039
little bit more thank you all for your

635
00:24:24,240 --> 00:24:26,880
attention

636
00:24:25,039 --> 00:24:32,640
and please if you have any questions

637
00:24:26,880 --> 00:24:47,840
whatsoever do not hesitate to contact us

638
00:24:32,640 --> 00:24:47,840
thank you very much

639
00:24:54,960 --> 00:24:57,039
you

