1
00:00:01,040 --> 00:00:04,319
hello everyone my name is leo and i'm

2
00:00:03,439 --> 00:00:07,520
going to talk about

3
00:00:04,319 --> 00:00:08,320
alzet a 64-bit rx box this talk will

4
00:00:07,520 --> 00:00:11,440
also feature

5
00:00:08,320 --> 00:00:13,440
our new ciphers called cracks and t-rex

6
00:00:11,440 --> 00:00:14,799
this is very much a teamwork with

7
00:00:13,440 --> 00:00:18,960
christoph alex

8
00:00:14,799 --> 00:00:22,320
luwan johan alexey veslin and ching chu

9
00:00:18,960 --> 00:00:22,800
quite a team in the beginning of this

10
00:00:22,320 --> 00:00:24,560
work

11
00:00:22,800 --> 00:00:26,400
was our nice lightweight crypto

12
00:00:24,560 --> 00:00:28,479
submission called sparkle

13
00:00:26,400 --> 00:00:29,439
it consists of two hash functions called

14
00:00:28,480 --> 00:00:31,279
ash

15
00:00:29,439 --> 00:00:34,079
and several authenticated encryption

16
00:00:31,279 --> 00:00:35,760
schemes called schwem

17
00:00:34,079 --> 00:00:37,200
this is not the topic of the day if you

18
00:00:35,760 --> 00:00:39,199
want to learn more about those

19
00:00:37,200 --> 00:00:41,440
i suggest you have a look at our task

20
00:00:39,200 --> 00:00:43,840
paper presenting them

21
00:00:41,440 --> 00:00:45,440
instead today i'm going to talk about

22
00:00:43,840 --> 00:00:48,000
alzet

23
00:00:45,440 --> 00:00:48,718
so in our next submissions the core

24
00:00:48,000 --> 00:00:50,800
components

25
00:00:48,719 --> 00:00:53,440
are permutations these permutations

26
00:00:50,800 --> 00:00:56,000
themselves have a core component

27
00:00:53,440 --> 00:00:56,800
as it so the aim of this talk is to

28
00:00:56,000 --> 00:00:58,559
analyze

29
00:00:56,800 --> 00:01:00,399
this component and thus to shed some

30
00:00:58,559 --> 00:01:03,839
light on the security of our

31
00:01:00,399 --> 00:01:05,360
candidates along the way we will also

32
00:01:03,840 --> 00:01:08,960
show that this component can

33
00:01:05,360 --> 00:01:09,760
be used to construct new tweakable block

34
00:01:08,960 --> 00:01:13,199
ciphers

35
00:01:09,760 --> 00:01:14,880
and new regular regular block ciphers

36
00:01:13,200 --> 00:01:16,960
the outline of this talk is this kind of

37
00:01:14,880 --> 00:01:19,119
obvious first i'm going to talk about lz

38
00:01:16,960 --> 00:01:21,600
and then i'm going to talk about the new

39
00:01:19,119 --> 00:01:21,600
cyphers

40
00:01:21,920 --> 00:01:28,159
so first

41
00:01:25,040 --> 00:01:29,439
what is an s box so this is a block

42
00:01:28,159 --> 00:01:32,720
cipher it operates on

43
00:01:29,439 --> 00:01:33,600
n bits and it has a key kappa of a fixed

44
00:01:32,720 --> 00:01:36,479
length

45
00:01:33,600 --> 00:01:37,119
n is usually 128 or in our case you will

46
00:01:36,479 --> 00:01:40,479
see

47
00:01:37,119 --> 00:01:43,200
64 or 256 and

48
00:01:40,479 --> 00:01:44,159
it's a permutation of the space of n-bit

49
00:01:43,200 --> 00:01:47,439
permutation of

50
00:01:44,159 --> 00:01:50,960
n-bit strings

51
00:01:47,439 --> 00:01:50,960
which is parameterized by a key

52
00:01:51,200 --> 00:01:54,960
in practice block ciphers operate using

53
00:01:54,079 --> 00:01:56,880
a round function

54
00:01:54,960 --> 00:01:59,039
this run function is iterated multiple

55
00:01:56,880 --> 00:02:02,079
times

56
00:01:59,040 --> 00:02:04,560
using also a sub key called

57
00:02:02,079 --> 00:02:05,119
in this case ki which is sort into the

58
00:02:04,560 --> 00:02:07,920
state

59
00:02:05,119 --> 00:02:09,520
before the round function the round keys

60
00:02:07,920 --> 00:02:11,120
are derived from the master key

61
00:02:09,520 --> 00:02:12,959
using the key schedule which i'm not

62
00:02:11,120 --> 00:02:14,879
going to talk about today

63
00:02:12,959 --> 00:02:17,760
and the round function itself needs to

64
00:02:14,879 --> 00:02:21,280
have several properties

65
00:02:17,760 --> 00:02:24,640
so this was the findings of

66
00:02:21,280 --> 00:02:26,319
chlochanon the cloud shannon in a block

67
00:02:24,640 --> 00:02:27,119
cipher you need to have confusion and

68
00:02:26,319 --> 00:02:28,799
diffusion

69
00:02:27,120 --> 00:02:30,239
and these two properties you also need

70
00:02:28,800 --> 00:02:31,680
to have them at the level of the round

71
00:02:30,239 --> 00:02:33,519
function

72
00:02:31,680 --> 00:02:35,680
to a lesser extent and then by iterating

73
00:02:33,519 --> 00:02:38,239
this round function you get the property

74
00:02:35,680 --> 00:02:39,040
that you need for the cipher the idea of

75
00:02:38,239 --> 00:02:40,879
confusion

76
00:02:39,040 --> 00:02:42,959
is actually kind of difficult to

77
00:02:40,879 --> 00:02:44,239
formalize it's not the relationship

78
00:02:42,959 --> 00:02:46,959
between the output bits

79
00:02:44,239 --> 00:02:48,000
the input bits and key bits has to be

80
00:02:46,959 --> 00:02:49,599
complicated

81
00:02:48,000 --> 00:02:51,519
in practice it means that it has to be

82
00:02:49,599 --> 00:02:53,518
highly non-linear

83
00:02:51,519 --> 00:02:55,120
diffusion is simpler it's the idea that

84
00:02:53,519 --> 00:02:56,000
all output bits need to depend on all

85
00:02:55,120 --> 00:03:00,319
key bits and all

86
00:02:56,000 --> 00:03:01,280
input bits a convenient way of doing

87
00:03:00,319 --> 00:03:04,238
that

88
00:03:01,280 --> 00:03:06,159
is to use what we call an s-box layer so

89
00:03:04,239 --> 00:03:07,760
you're going to have small functions

90
00:03:06,159 --> 00:03:10,480
that operate on a small part of the

91
00:03:07,760 --> 00:03:13,840
state which are applied in parallel

92
00:03:10,480 --> 00:03:15,359
over the full state these will enter the

93
00:03:13,840 --> 00:03:17,599
confusion

94
00:03:15,360 --> 00:03:20,000
for diffusion if we use a function which

95
00:03:17,599 --> 00:03:22,560
is linear then it's

96
00:03:20,000 --> 00:03:24,080
i'm not going to say easier it's less

97
00:03:22,560 --> 00:03:28,319
difficult

98
00:03:24,080 --> 00:03:30,319
to quantify the dependency between the

99
00:03:28,319 --> 00:03:32,159
outputs and the inputs

100
00:03:30,319 --> 00:03:33,440
so these small functions s that are

101
00:03:32,159 --> 00:03:36,879
applied in parallel

102
00:03:33,440 --> 00:03:36,879
on the state that's the s box

103
00:03:37,200 --> 00:03:40,238
in practice what does an s box look like

104
00:03:39,519 --> 00:03:42,400
well

105
00:03:40,239 --> 00:03:43,599
that's the xbox of the aes the block

106
00:03:42,400 --> 00:03:45,519
cipher

107
00:03:43,599 --> 00:03:46,959
you can specify it just using its lookup

108
00:03:45,519 --> 00:03:51,040
table so in this case

109
00:03:46,959 --> 00:03:53,599
it maps this the input bit string

110
00:03:51,040 --> 00:03:54,319
of with eight zeros to the output

111
00:03:53,599 --> 00:03:57,760
bitstring

112
00:03:54,319 --> 00:04:00,238
with 0x63

113
00:03:57,760 --> 00:04:02,159
etc etc you can also define it with a

114
00:04:00,239 --> 00:04:04,080
math formula which is also the case for

115
00:04:02,159 --> 00:04:06,079
the aes

116
00:04:04,080 --> 00:04:08,480
you can also use a bit sliced

117
00:04:06,080 --> 00:04:11,200
representation so where each output bit

118
00:04:08,480 --> 00:04:12,560
is effectively a boolean function of the

119
00:04:11,200 --> 00:04:14,798
input bits

120
00:04:12,560 --> 00:04:16,320
so here we have the s-box of ketchup

121
00:04:14,799 --> 00:04:18,639
it's a 5-bit

122
00:04:16,320 --> 00:04:21,599
permutation in this case and it has this

123
00:04:18,639 --> 00:04:21,600
nice representation

124
00:04:22,000 --> 00:04:25,120
this is the case of smallest boxes which

125
00:04:24,479 --> 00:04:28,159
is

126
00:04:25,120 --> 00:04:29,840
the case usually

127
00:04:28,160 --> 00:04:31,199
in ketchup it's five bits in the aes

128
00:04:29,840 --> 00:04:31,919
it's eight bits and these are pretty

129
00:04:31,199 --> 00:04:35,759
typical

130
00:04:31,919 --> 00:04:38,880
block sizes for s-boxes the advantages

131
00:04:35,759 --> 00:04:40,479
of using small s-boxes are that the

132
00:04:38,880 --> 00:04:42,400
cryptographic properties are easy to

133
00:04:40,479 --> 00:04:44,800
study because computing the relevant

134
00:04:42,400 --> 00:04:45,840
properties for a permutation that has a

135
00:04:44,800 --> 00:04:47,840
small block size

136
00:04:45,840 --> 00:04:48,880
is computationally trivial so if you

137
00:04:47,840 --> 00:04:51,359
want to compute the ddt

138
00:04:48,880 --> 00:04:54,080
the lat or the a and f when n is small

139
00:04:51,360 --> 00:04:56,160
it's very easy

140
00:04:54,080 --> 00:04:57,599
the resulting ciphers are easier to

141
00:04:56,160 --> 00:04:59,440
study also that's one of the main

142
00:04:57,600 --> 00:05:01,440
selling points of the aes which is that

143
00:04:59,440 --> 00:05:04,719
it's provably secure

144
00:05:01,440 --> 00:05:06,800
against some specific forms of

145
00:05:04,720 --> 00:05:09,039
differential and linear attacks

146
00:05:06,800 --> 00:05:10,479
because of the properties of the xbox

147
00:05:09,039 --> 00:05:14,240
and how they interact

148
00:05:10,479 --> 00:05:14,240
with the linear layer

149
00:05:14,560 --> 00:05:18,000
they are easy to implement you can

150
00:05:16,240 --> 00:05:20,000
simply use a lookup and

151
00:05:18,000 --> 00:05:21,600
you win or in the case of ketchup you

152
00:05:20,000 --> 00:05:25,039
have the bit slice representation

153
00:05:21,600 --> 00:05:27,440
and voila

154
00:05:25,039 --> 00:05:29,120
and for small block sizes components

155
00:05:27,440 --> 00:05:30,160
that are basically optimal are well

156
00:05:29,120 --> 00:05:32,720
known

157
00:05:30,160 --> 00:05:34,639
and easy to implement so the

158
00:05:32,720 --> 00:05:36,720
multiplicative inverse in the final

159
00:05:34,639 --> 00:05:38,880
field

160
00:05:36,720 --> 00:05:40,479
has all that you need it has a very high

161
00:05:38,880 --> 00:05:42,719
algebraic degree it has very good

162
00:05:40,479 --> 00:05:44,560
differential properties very good linear

163
00:05:42,720 --> 00:05:48,400
properties in fact the best

164
00:05:44,560 --> 00:05:52,240
that we know how to achieve so

165
00:05:48,400 --> 00:05:54,719
it's a solved problem to some extent

166
00:05:52,240 --> 00:05:56,639
not everything is perfect though if you

167
00:05:54,720 --> 00:05:58,080
are implementing your sbox using a

168
00:05:56,639 --> 00:05:59,120
lookup table then you are going to have

169
00:05:58,080 --> 00:06:02,560
problems with

170
00:05:59,120 --> 00:06:04,960
sidechannel attacks and

171
00:06:02,560 --> 00:06:06,000
in order to use a smallest box you need

172
00:06:04,960 --> 00:06:09,198
to have a linear layer

173
00:06:06,000 --> 00:06:09,759
which provides strong diffusion and that

174
00:06:09,199 --> 00:06:12,000
can be

175
00:06:09,759 --> 00:06:13,919
a bottleneck in terms of performances so

176
00:06:12,000 --> 00:06:15,680
you can have a

177
00:06:13,919 --> 00:06:18,080
linear layer which is strongly aligned

178
00:06:15,680 --> 00:06:21,199
like in the hash functions tree bug

179
00:06:18,080 --> 00:06:24,080
where the linear layer is this dense

180
00:06:21,199 --> 00:06:26,960
eight by eight matrix

181
00:06:24,080 --> 00:06:28,560
or you can have um linear layers which

182
00:06:26,960 --> 00:06:30,719
are not aligned with the words

183
00:06:28,560 --> 00:06:31,919
in the s box in which case it can be

184
00:06:30,720 --> 00:06:33,039
more efficient but then it's more

185
00:06:31,919 --> 00:06:35,198
difficult to study so

186
00:06:33,039 --> 00:06:37,280
for instance when you look at ketchup

187
00:06:35,199 --> 00:06:38,080
you have whole papers dedicated to the

188
00:06:37,280 --> 00:06:40,080
analysis

189
00:06:38,080 --> 00:06:41,599
of the differential properties of the

190
00:06:40,080 --> 00:06:43,440
permutation

191
00:06:41,600 --> 00:06:44,960
which are needed because you can't use

192
00:06:43,440 --> 00:06:48,639
arguments as simple as in the case of

193
00:06:44,960 --> 00:06:51,520
the aes

194
00:06:48,639 --> 00:06:53,599
you have alternatives to structures

195
00:06:51,520 --> 00:06:54,318
based on smallest boxes so you can have

196
00:06:53,599 --> 00:06:57,520
ciphers

197
00:06:54,319 --> 00:07:00,080
like cha cha or spec or

198
00:06:57,520 --> 00:07:00,719
hash the hash function blake 2 is the

199
00:07:00,080 --> 00:07:02,000
same

200
00:07:00,720 --> 00:07:04,880
where you're going to have an arcs

201
00:07:02,000 --> 00:07:06,560
network so it's not as box-based

202
00:07:04,880 --> 00:07:08,080
but then it can be very difficult to

203
00:07:06,560 --> 00:07:10,479
study

204
00:07:08,080 --> 00:07:12,159
the question then is if it's possible

205
00:07:10,479 --> 00:07:14,960
for a cypher to not use

206
00:07:12,160 --> 00:07:16,319
smallest boxes while still allowing

207
00:07:14,960 --> 00:07:18,400
strong security arguments

208
00:07:16,319 --> 00:07:21,360
in the style that you can have when you

209
00:07:18,400 --> 00:07:21,359
use smallest boxes

210
00:07:23,120 --> 00:07:26,960
to answer this question we need to

211
00:07:24,960 --> 00:07:28,400
answer an obvious question which is what

212
00:07:26,960 --> 00:07:29,919
actually is an s-box

213
00:07:28,400 --> 00:07:31,919
because we tend to think of them as

214
00:07:29,919 --> 00:07:33,440
small permutations that are implemented

215
00:07:31,919 --> 00:07:35,520
using their lookup tables

216
00:07:33,440 --> 00:07:37,599
but now that we're defining s-boxes

217
00:07:35,520 --> 00:07:39,520
using

218
00:07:37,599 --> 00:07:43,120
boolean functions it's not really a good

219
00:07:39,520 --> 00:07:43,120
description in my opinion

220
00:07:43,520 --> 00:07:47,359
and since the xbox is supposed to

221
00:07:45,440 --> 00:07:47,919
provide confusion we need then to answer

222
00:07:47,360 --> 00:07:50,720
the

223
00:07:47,919 --> 00:07:51,919
very deep question of what is confusion

224
00:07:50,720 --> 00:07:54,240
in a cipher

225
00:07:51,919 --> 00:07:56,000
and that will quickly lead us to very

226
00:07:54,240 --> 00:07:57,120
deep philosophical questions to which i

227
00:07:56,000 --> 00:08:02,080
won't even pretend

228
00:07:57,120 --> 00:08:03,599
having the answer to so

229
00:08:02,080 --> 00:08:05,440
let's see what are the properties that

230
00:08:03,599 --> 00:08:06,319
you need for a good xbox you need that

231
00:08:05,440 --> 00:08:08,879
they have

232
00:08:06,319 --> 00:08:10,000
known very important that we know the

233
00:08:08,879 --> 00:08:12,080
properties

234
00:08:10,000 --> 00:08:14,000
and that they be good obviously you want

235
00:08:12,080 --> 00:08:15,758
good properties

236
00:08:14,000 --> 00:08:17,520
that are relevant to crypto so

237
00:08:15,759 --> 00:08:19,360
differential properties linear ones

238
00:08:17,520 --> 00:08:20,799
integral algebraic properties you want

239
00:08:19,360 --> 00:08:21,599
them to be good and you want to know

240
00:08:20,800 --> 00:08:25,280
them

241
00:08:21,599 --> 00:08:27,759
that's what makes a good xbox

242
00:08:25,280 --> 00:08:29,280
and that's pretty much it actually you

243
00:08:27,759 --> 00:08:31,039
don't need to know its size

244
00:08:29,280 --> 00:08:33,199
it's not really a criteria to be a good

245
00:08:31,039 --> 00:08:34,319
xbox it's the only

246
00:08:33,200 --> 00:08:36,000
thing you care about is that the

247
00:08:34,320 --> 00:08:38,240
properties are known and that they're

248
00:08:36,000 --> 00:08:38,240
good

249
00:08:38,479 --> 00:08:42,320
the size doesn't matter to define an

250
00:08:40,799 --> 00:08:45,599
s-box

251
00:08:42,320 --> 00:08:47,120
and in fact it's not a an idea that

252
00:08:45,600 --> 00:08:49,360
we're introducing

253
00:08:47,120 --> 00:08:51,279
we already have such things in saturn

254
00:08:49,360 --> 00:08:54,480
where you have a 16-bit transformation

255
00:08:51,279 --> 00:08:58,240
which was considered like a big s box

256
00:08:54,480 --> 00:08:58,720
you have a 128 bit transformation in

257
00:08:58,240 --> 00:09:00,720
spook

258
00:08:58,720 --> 00:09:02,640
which is bit like a small block cipher

259
00:09:00,720 --> 00:09:05,120
which you can see as a biggest box and

260
00:09:02,640 --> 00:09:07,760
then you have four of those in parallel

261
00:09:05,120 --> 00:09:09,760
and you also have the 96 bit sp box in

262
00:09:07,760 --> 00:09:13,200
gimli which can be seen

263
00:09:09,760 --> 00:09:13,200
in a way as a big s box

264
00:09:14,160 --> 00:09:18,399
so how do we design then a widest box

265
00:09:16,880 --> 00:09:20,480
it's more complicated because with a

266
00:09:18,399 --> 00:09:22,160
smallest box that is 4 over 8 bits you

267
00:09:20,480 --> 00:09:22,959
can just compute their cryptographic

268
00:09:22,160 --> 00:09:26,160
properties

269
00:09:22,959 --> 00:09:29,439
using standard tools but it's not really

270
00:09:26,160 --> 00:09:29,439
possible for wides boxes

271
00:09:29,680 --> 00:09:33,120
so let's write first the scope statement

272
00:09:32,480 --> 00:09:36,000
of the

273
00:09:33,120 --> 00:09:37,600
widest box we wanted to build so first

274
00:09:36,000 --> 00:09:39,600
we wanted

275
00:09:37,600 --> 00:09:41,760
our algorithms to be very good in

276
00:09:39,600 --> 00:09:43,920
software

277
00:09:41,760 --> 00:09:46,000
it means that modular edition makes

278
00:09:43,920 --> 00:09:47,040
sense modular edition is not going to be

279
00:09:46,000 --> 00:09:50,000
so great

280
00:09:47,040 --> 00:09:51,279
in hardware but on software it's

281
00:09:50,000 --> 00:09:53,600
extremely efficient

282
00:09:51,279 --> 00:09:57,040
so we went for an arcs structure with

283
00:09:53,600 --> 00:09:57,040
addition rotation and xor

284
00:09:57,360 --> 00:10:01,120
we wanted to be efficient on 8 16 and

285
00:10:00,240 --> 00:10:04,240
32-bit

286
00:10:01,120 --> 00:10:06,240
microcontrollers and that imposes then

287
00:10:04,240 --> 00:10:08,640
the use of 32-bit instructions because

288
00:10:06,240 --> 00:10:09,600
if we used say 8-bit instructions it

289
00:10:08,640 --> 00:10:11,920
would have been great

290
00:10:09,600 --> 00:10:12,800
on 8-bit microcontrollers but it would

291
00:10:11,920 --> 00:10:16,079
have sucked on

292
00:10:12,800 --> 00:10:17,839
32-bit ones on the other hand

293
00:10:16,079 --> 00:10:19,359
32-bit instructions can also be very

294
00:10:17,839 --> 00:10:22,399
efficient on 8-bit micro

295
00:10:19,360 --> 00:10:23,680
controllers also since we are in the

296
00:10:22,399 --> 00:10:26,640
software case

297
00:10:23,680 --> 00:10:28,239
we want to use parallel shifters but

298
00:10:26,640 --> 00:10:29,279
then we have to use specific rotation

299
00:10:28,240 --> 00:10:31,760
amounts

300
00:10:29,279 --> 00:10:33,279
because different rotations can have

301
00:10:31,760 --> 00:10:35,600
different

302
00:10:33,279 --> 00:10:37,120
cycle counts on different platforms so

303
00:10:35,600 --> 00:10:39,519
we have to choose these rotations very

304
00:10:37,120 --> 00:10:39,519
carefully

305
00:10:40,160 --> 00:10:44,560
we want the cryptographic properties to

306
00:10:42,079 --> 00:10:46,160
be both strong and well understood

307
00:10:44,560 --> 00:10:47,680
as i said before we want to use this as

308
00:10:46,160 --> 00:10:50,880
an sbox so we have to know

309
00:10:47,680 --> 00:10:52,319
what it does and that means we're going

310
00:10:50,880 --> 00:10:53,760
to have to use an iterated structure

311
00:10:52,320 --> 00:10:55,519
because then we can leverage the

312
00:10:53,760 --> 00:10:56,399
literature on the analysis of block

313
00:10:55,519 --> 00:10:58,320
ciphers

314
00:10:56,399 --> 00:11:00,000
if we build our sbox like a small block

315
00:10:58,320 --> 00:11:02,079
cipher then we can

316
00:11:00,000 --> 00:11:03,920
analyze it like a small block cipher and

317
00:11:02,079 --> 00:11:08,000
we know how to do that

318
00:11:03,920 --> 00:11:09,839
we also want then to minimize its width

319
00:11:08,000 --> 00:11:11,200
because if the width is not too large

320
00:11:09,839 --> 00:11:13,120
then we can make some extensive

321
00:11:11,200 --> 00:11:14,399
experiments to ensure that our analysis

322
00:11:13,120 --> 00:11:17,920
is good

323
00:11:14,399 --> 00:11:18,480
so we are going to stuck to two 32-bit

324
00:11:17,920 --> 00:11:21,519
words

325
00:11:18,480 --> 00:11:24,079
so we need 32 bit words to be efficient

326
00:11:21,519 --> 00:11:25,600
on all microcontrollers and only two of

327
00:11:24,079 --> 00:11:28,640
them

328
00:11:25,600 --> 00:11:30,560
to ease our analysis

329
00:11:28,640 --> 00:11:32,240
and finally we want to have diffusion

330
00:11:30,560 --> 00:11:34,719
that is as fast as possible

331
00:11:32,240 --> 00:11:36,000
inside the s-box and in practice it's

332
00:11:34,720 --> 00:11:38,240
going to mean that we want to use

333
00:11:36,000 --> 00:11:40,399
different rotations in each round

334
00:11:38,240 --> 00:11:41,360
so instead of having an id an identical

335
00:11:40,399 --> 00:11:43,440
round which is

336
00:11:41,360 --> 00:11:45,600
repeated several times there is going to

337
00:11:43,440 --> 00:11:47,200
be slight modifications in the rounds

338
00:11:45,600 --> 00:11:48,640
this will complicate the analysis but it

339
00:11:47,200 --> 00:11:51,200
will significantly increase the

340
00:11:48,640 --> 00:11:51,199
efficiency

341
00:11:51,920 --> 00:11:55,439
so from this scope statement we got an

342
00:11:54,800 --> 00:11:57,439
outline

343
00:11:55,440 --> 00:11:58,800
and now from this outline this is what

344
00:11:57,440 --> 00:12:02,399
we get

345
00:11:58,800 --> 00:12:06,000
so something very simple with just three

346
00:12:02,399 --> 00:12:08,240
operations an addition of a rotation

347
00:12:06,000 --> 00:12:10,720
a sort of rotation and the addition of

348
00:12:08,240 --> 00:12:13,440
the sore of a round constant

349
00:12:10,720 --> 00:12:16,079
questions remain how many rounds do we

350
00:12:13,440 --> 00:12:17,519
need so how many iterations of that

351
00:12:16,079 --> 00:12:20,160
what are the rotation amounts that we

352
00:12:17,519 --> 00:12:21,680
need these rotation amounts will decide

353
00:12:20,160 --> 00:12:23,519
the cryptographic properties

354
00:12:21,680 --> 00:12:25,680
as well as the implementation properties

355
00:12:23,519 --> 00:12:27,680
so we have to choose them very carefully

356
00:12:25,680 --> 00:12:30,160
and also what sort of round constants do

357
00:12:27,680 --> 00:12:30,160
we want

358
00:12:32,480 --> 00:12:36,079
of course we are going to want to pick

359
00:12:34,959 --> 00:12:37,920
the best

360
00:12:36,079 --> 00:12:39,120
constants and rotation amounts and to

361
00:12:37,920 --> 00:12:40,399
pick the best it means that we have an

362
00:12:39,120 --> 00:12:42,240
optimization problem

363
00:12:40,399 --> 00:12:44,480
and then we need to have criteria to

364
00:12:42,240 --> 00:12:48,000
optimize for

365
00:12:44,480 --> 00:12:49,680
so one of them is that asset has to help

366
00:12:48,000 --> 00:12:51,040
prevent differential attacks

367
00:12:49,680 --> 00:12:54,399
so this is the quantity we need to

368
00:12:51,040 --> 00:12:56,560
modify to optimize in this context

369
00:12:54,399 --> 00:12:58,639
it's the maximum over all possible alpha

370
00:12:56,560 --> 00:13:01,119
and beta where alpha is not zero

371
00:12:58,639 --> 00:13:02,639
of the probability that lz maps a

372
00:13:01,120 --> 00:13:06,000
difference equal to alpha

373
00:13:02,639 --> 00:13:09,279
to a difference equal to beta

374
00:13:06,000 --> 00:13:11,839
is very standard in symmetric crypto

375
00:13:09,279 --> 00:13:13,920
in practice since alset operates on 64

376
00:13:11,839 --> 00:13:16,399
bits we cannot compute

377
00:13:13,920 --> 00:13:18,319
this quantity instead we are going to

378
00:13:16,399 --> 00:13:18,800
estimate it and we are going to do it

379
00:13:18,320 --> 00:13:20,480
again

380
00:13:18,800 --> 00:13:21,760
in a way which is very standard in

381
00:13:20,480 --> 00:13:23,200
symmetry crypto which is that we're

382
00:13:21,760 --> 00:13:23,839
going to look at the best differential

383
00:13:23,200 --> 00:13:27,040
trail

384
00:13:23,839 --> 00:13:31,040
so that's a sequence of differences

385
00:13:27,040 --> 00:13:34,319
that will lead from alpha to beta

386
00:13:31,040 --> 00:13:36,240
so this probability it's about

387
00:13:34,320 --> 00:13:38,399
the maximum taken over all possible

388
00:13:36,240 --> 00:13:41,600
delta 1 delta 2 and delta 3

389
00:13:38,399 --> 00:13:43,120
of this product

390
00:13:41,600 --> 00:13:44,639
assumptions are being made in the

391
00:13:43,120 --> 00:13:46,240
background so allow me to open a

392
00:13:44,639 --> 00:13:49,920
parenthesis to discuss those

393
00:13:46,240 --> 00:13:52,240
for a few seconds the first assumption

394
00:13:49,920 --> 00:13:54,000
is the assumption that we can just

395
00:13:52,240 --> 00:13:56,560
multiply these probabilities

396
00:13:54,000 --> 00:13:58,480
meaning that they are independent a

397
00:13:56,560 --> 00:14:00,399
priori is not the case

398
00:13:58,480 --> 00:14:01,519
but it's a standard assumption to make

399
00:14:00,399 --> 00:14:03,440
in symmetric crypto

400
00:14:01,519 --> 00:14:04,800
usually it's the mark of assumption we

401
00:14:03,440 --> 00:14:07,920
rely on the

402
00:14:04,800 --> 00:14:09,760
addition of sub keys to have more

403
00:14:07,920 --> 00:14:11,839
confidence in the fact that it holds

404
00:14:09,760 --> 00:14:12,880
but we are when we look at uh

405
00:14:11,839 --> 00:14:14,800
permutation

406
00:14:12,880 --> 00:14:16,880
with permutations with a fixed key as is

407
00:14:14,800 --> 00:14:19,359
the case here

408
00:14:16,880 --> 00:14:19,920
we do not have key additions but we can

409
00:14:19,360 --> 00:14:22,720
still

410
00:14:19,920 --> 00:14:24,000
make this assumption and then see how it

411
00:14:22,720 --> 00:14:26,079
works in practice that's how it's

412
00:14:24,000 --> 00:14:27,760
usually done

413
00:14:26,079 --> 00:14:29,680
this also relies on the assumption that

414
00:14:27,760 --> 00:14:31,680
the probability is dominated by a single

415
00:14:29,680 --> 00:14:34,319
trade

416
00:14:31,680 --> 00:14:34,959
assumptions mean verification so we need

417
00:14:34,320 --> 00:14:39,040
to verify

418
00:14:34,959 --> 00:14:42,239
if these hold experimentally and we have

419
00:14:39,040 --> 00:14:44,880
and they do to make a long story short

420
00:14:42,240 --> 00:14:46,320
the probabilities are indeed independent

421
00:14:44,880 --> 00:14:47,839
uh i mean act as if they were

422
00:14:46,320 --> 00:14:50,639
independent

423
00:14:47,839 --> 00:14:53,040
and the probability is indeed dominated

424
00:14:50,639 --> 00:14:54,800
by that of a single trade

425
00:14:53,040 --> 00:14:56,639
so what is all in good and i can just

426
00:14:54,800 --> 00:14:58,560
close the parenthesis

427
00:14:56,639 --> 00:15:00,720
and we have that this approximation is

428
00:14:58,560 --> 00:15:02,239
true

429
00:15:00,720 --> 00:15:04,800
this doesn't mean that the work is done

430
00:15:02,240 --> 00:15:08,079
far from it then we need to find a way

431
00:15:04,800 --> 00:15:11,439
to estimate to to compute this maximum

432
00:15:08,079 --> 00:15:12,959
and to achieve this we have used matsui

433
00:15:11,440 --> 00:15:16,320
style tree search

434
00:15:12,959 --> 00:15:17,680
to find the best differential trade or

435
00:15:16,320 --> 00:15:19,440
differential traits if there are several

436
00:15:17,680 --> 00:15:21,439
of them

437
00:15:19,440 --> 00:15:22,880
we have done the same type of analysis

438
00:15:21,440 --> 00:15:24,880
for the linear case

439
00:15:22,880 --> 00:15:28,720
in this case it's not based on met's

440
00:15:24,880 --> 00:15:28,720
research we have used the sad solver

441
00:15:29,040 --> 00:15:33,199
we have repeated this analysis for many

442
00:15:31,040 --> 00:15:35,839
different sets of rotations

443
00:15:33,199 --> 00:15:36,959
and we have picked the sets of rotations

444
00:15:35,839 --> 00:15:37,839
that were the best from an

445
00:15:36,959 --> 00:15:40,479
implementation

446
00:15:37,839 --> 00:15:44,000
standpoint so those that have a very

447
00:15:40,480 --> 00:15:47,120
small distance to multiples of 8

448
00:15:44,000 --> 00:15:51,279
think 0 1 7 8

449
00:15:47,120 --> 00:15:52,480
9 etc and then we have picked those with

450
00:15:51,279 --> 00:15:54,639
the best

451
00:15:52,480 --> 00:15:55,680
differential probabilities and linear

452
00:15:54,639 --> 00:15:58,560
correlations

453
00:15:55,680 --> 00:16:00,880
so the lowest so that's what you have in

454
00:15:58,560 --> 00:16:03,439
this table

455
00:16:00,880 --> 00:16:04,480
here is the set of rotations for alzet

456
00:16:03,440 --> 00:16:06,240
these are

457
00:16:04,480 --> 00:16:07,839
minus logarithm the differential

458
00:16:06,240 --> 00:16:09,920
probabilities

459
00:16:07,839 --> 00:16:11,199
estimate i described before and below is

460
00:16:09,920 --> 00:16:14,880
for linear correlation

461
00:16:11,199 --> 00:16:18,880
so the higher the number the better

462
00:16:14,880 --> 00:16:20,399
and for comparison we have also put

463
00:16:18,880 --> 00:16:22,639
these quantities for the blocks the

464
00:16:20,399 --> 00:16:24,240
64-bit block cipher spec

465
00:16:22,639 --> 00:16:26,480
when the numbers are in blue like this

466
00:16:24,240 --> 00:16:28,399
24 here it means that we have

467
00:16:26,480 --> 00:16:31,199
a bound so we know that the probability

468
00:16:28,399 --> 00:16:33,360
cannot be higher than 2 to the minus 24

469
00:16:31,199 --> 00:16:34,639
but actually maybe the highest possible

470
00:16:33,360 --> 00:16:37,279
is 2-25

471
00:16:34,639 --> 00:16:40,639
we're not sure but we are certain that

472
00:16:37,279 --> 00:16:42,320
it's at most to the minus 24.

473
00:16:40,639 --> 00:16:44,720
and that's how we go there's it we have

474
00:16:42,320 --> 00:16:46,639
picked the best uh

475
00:16:44,720 --> 00:16:47,759
set of rotations and that's the one that

476
00:16:46,639 --> 00:16:50,959
is pictured on the

477
00:16:47,759 --> 00:16:54,639
on the right of the screen so

478
00:16:50,959 --> 00:16:56,719
31 24 etc etc i won't go over the

479
00:16:54,639 --> 00:16:58,959
specifics of how we have chosen

480
00:16:56,720 --> 00:17:01,040
the round constants because that would

481
00:16:58,959 --> 00:17:03,199
take me very far

482
00:17:01,040 --> 00:17:04,799
but we have found that if we use the

483
00:17:03,199 --> 00:17:07,760
same constant

484
00:17:04,799 --> 00:17:08,480
in each round then it's fine and we have

485
00:17:07,760 --> 00:17:10,799
chose

486
00:17:08,480 --> 00:17:14,240
chosen them carefully to optimize even

487
00:17:10,799 --> 00:17:14,240
further the linear properties

488
00:17:14,720 --> 00:17:18,240
so in the end the results for alzet are

489
00:17:16,480 --> 00:17:22,160
as follows basically

490
00:17:18,240 --> 00:17:25,359
it kind of behaves like an as round

491
00:17:22,160 --> 00:17:27,679
so one iteration of lz has similar

492
00:17:25,359 --> 00:17:29,120
differential and linear properties and

493
00:17:27,679 --> 00:17:32,720
two iterations of alzet

494
00:17:29,120 --> 00:17:34,159
have similar properties to two rounds of

495
00:17:32,720 --> 00:17:37,360
aes so that's one

496
00:17:34,160 --> 00:17:37,360
supers box in this case

497
00:17:38,559 --> 00:17:41,760
we have looked at many other attacks

498
00:17:40,240 --> 00:17:43,600
beyond differential and linear we have

499
00:17:41,760 --> 00:17:44,960
also looked at integral attacks

500
00:17:43,600 --> 00:17:46,639
that would leverage the division

501
00:17:44,960 --> 00:17:49,280
property and we have found

502
00:17:46,640 --> 00:17:50,080
that they can not cover more than six

503
00:17:49,280 --> 00:17:52,480
rounds

504
00:17:50,080 --> 00:17:54,320
we have looked at invariants linear ones

505
00:17:52,480 --> 00:17:56,799
but also non-linear ones and we have

506
00:17:54,320 --> 00:17:58,320
found them not to really be an issue

507
00:17:56,799 --> 00:18:00,480
the algebraic degree increases very

508
00:17:58,320 --> 00:18:02,399
quickly because modular edition has a

509
00:18:00,480 --> 00:18:05,120
high algebraic degree

510
00:18:02,400 --> 00:18:06,160
and as i mentioned before we could make

511
00:18:05,120 --> 00:18:08,719
some experiments

512
00:18:06,160 --> 00:18:10,160
to see if there was a big clustering of

513
00:18:08,720 --> 00:18:11,360
the differential trails so many

514
00:18:10,160 --> 00:18:12,240
differential traits with the same

515
00:18:11,360 --> 00:18:14,240
starting point

516
00:18:12,240 --> 00:18:16,080
the same endpoint but different values

517
00:18:14,240 --> 00:18:19,039
in the middle

518
00:18:16,080 --> 00:18:19,840
this is something which is observable

519
00:18:19,039 --> 00:18:22,400
but

520
00:18:19,840 --> 00:18:24,080
nothing to be worried about and indeed

521
00:18:22,400 --> 00:18:25,280
the very fact that we could make these

522
00:18:24,080 --> 00:18:29,840
experiments

523
00:18:25,280 --> 00:18:29,840
uh is a nice aspect of alzet

524
00:18:30,480 --> 00:18:36,960
as for the name well this is luxembourg

525
00:18:34,320 --> 00:18:38,320
if you don't really see where that is

526
00:18:36,960 --> 00:18:42,000
these are the neighbors

527
00:18:38,320 --> 00:18:45,439
france belgium and germany

528
00:18:42,000 --> 00:18:49,120
the asset is this blue

529
00:18:45,440 --> 00:18:51,120
thing down the middle it's a river

530
00:18:49,120 --> 00:18:53,280
and you have a picture of alzade taken

531
00:18:51,120 --> 00:18:56,799
in luxembourg city

532
00:18:53,280 --> 00:19:00,160
just under my face

533
00:18:56,799 --> 00:19:01,918
ash is the name of the hash function and

534
00:19:00,160 --> 00:19:03,600
because it's very close to the

535
00:19:01,919 --> 00:19:06,799
university of luxembourg

536
00:19:03,600 --> 00:19:08,320
which is based in esheraldset alzet

537
00:19:06,799 --> 00:19:11,760
being the name of the river

538
00:19:08,320 --> 00:19:14,399
so that's why

539
00:19:11,760 --> 00:19:16,240
what more can we do with lz well we can

540
00:19:14,400 --> 00:19:17,440
design new block ciphers possibly with a

541
00:19:16,240 --> 00:19:19,440
tweak

542
00:19:17,440 --> 00:19:21,039
so first let's look at a very simple way

543
00:19:19,440 --> 00:19:22,080
of building a block cipher using a

544
00:19:21,039 --> 00:19:25,360
64-bit

545
00:19:22,080 --> 00:19:27,600
rx box so

546
00:19:25,360 --> 00:19:29,600
if i give you a 64-bit test box and i

547
00:19:27,600 --> 00:19:31,360
ask you to build a 64-bit block cipher

548
00:19:29,600 --> 00:19:33,280
how do you do it

549
00:19:31,360 --> 00:19:39,840
think of the simple simple structure and

550
00:19:33,280 --> 00:19:39,840
i'm going to give you some time

551
00:19:40,880 --> 00:19:47,200
so very straightforward you just take

552
00:19:44,480 --> 00:19:48,799
a master key that you got in two halves

553
00:19:47,200 --> 00:19:51,600
look for the first half

554
00:19:48,799 --> 00:19:53,039
apply the rx box so the second half

555
00:19:51,600 --> 00:19:55,918
apply the ark sparks

556
00:19:53,039 --> 00:19:57,600
and repeat there is just a small issue

557
00:19:55,919 --> 00:19:57,919
if you do that which is that you might

558
00:19:57,600 --> 00:19:59,840
have

559
00:19:57,919 --> 00:20:01,440
what we call slide attacks and so to

560
00:19:59,840 --> 00:20:04,559
prevent it

561
00:20:01,440 --> 00:20:07,280
you just saw a round counter

562
00:20:04,559 --> 00:20:09,678
and that's it that's what we called

563
00:20:07,280 --> 00:20:09,678
cracks

564
00:20:10,080 --> 00:20:14,639
but this is a round structure we still

565
00:20:12,720 --> 00:20:18,240
need to give a number

566
00:20:14,640 --> 00:20:21,840
of steps so

567
00:20:18,240 --> 00:20:25,200
this is block cipher ek

568
00:20:21,840 --> 00:20:26,399
um how would an attack work in practice

569
00:20:25,200 --> 00:20:28,960
so how do attacks

570
00:20:26,400 --> 00:20:30,799
work against block ciphers you have a

571
00:20:28,960 --> 00:20:32,720
distinguisher in the middle so it's a

572
00:20:30,799 --> 00:20:33,520
property of the cipher that you would

573
00:20:32,720 --> 00:20:36,159
not expect

574
00:20:33,520 --> 00:20:37,600
from a random permutation and you have

575
00:20:36,159 --> 00:20:40,480
that in center rounds

576
00:20:37,600 --> 00:20:41,840
and you are going to try and reach these

577
00:20:40,480 --> 00:20:44,159
center rounds by guessing

578
00:20:41,840 --> 00:20:46,080
part of the keys from the bottom and

579
00:20:44,159 --> 00:20:49,120
from the top

580
00:20:46,080 --> 00:20:49,840
so if you want to avoid attacks you want

581
00:20:49,120 --> 00:20:51,918
to

582
00:20:49,840 --> 00:20:53,840
prevent the existence of a distinguisher

583
00:20:51,919 --> 00:20:58,000
with a complexity

584
00:20:53,840 --> 00:21:01,520
that you would find worrying

585
00:20:58,000 --> 00:21:03,120
and you need to prevent an attacker from

586
00:21:01,520 --> 00:21:04,320
from reaching the distinguisher in the

587
00:21:03,120 --> 00:21:08,399
middle rounds

588
00:21:04,320 --> 00:21:10,399
through key guessing so you're going to

589
00:21:08,400 --> 00:21:12,159
compute the number of rounds that are

590
00:21:10,400 --> 00:21:14,080
needed to prevent

591
00:21:12,159 --> 00:21:16,880
all the distinguishers you know about

592
00:21:14,080 --> 00:21:18,240
and care about and the number of rounds

593
00:21:16,880 --> 00:21:21,520
that is needed

594
00:21:18,240 --> 00:21:25,039
for all bits of the state to depend on

595
00:21:21,520 --> 00:21:25,840
all the bits of the key the first is re

596
00:21:25,039 --> 00:21:28,559
the second is

597
00:21:25,840 --> 00:21:30,959
rd and then the number of rounds is

598
00:21:28,559 --> 00:21:34,399
basically two times

599
00:21:30,960 --> 00:21:38,000
rd to prevent key guessing plus re

600
00:21:34,400 --> 00:21:41,039
to prevent distinguishers and to be safe

601
00:21:38,000 --> 00:21:43,840
you don't quite do that you also

602
00:21:41,039 --> 00:21:45,840
allow for possible improvements in the

603
00:21:43,840 --> 00:21:49,840
cryptanalysis of the cipher

604
00:21:45,840 --> 00:21:54,000
and you don't use one times

605
00:21:49,840 --> 00:21:59,840
one time re you do it one plus eta

606
00:21:54,000 --> 00:21:59,840
times r e where eta is a security factor

607
00:22:00,240 --> 00:22:06,559
and that's cracks so a cracks is a

608
00:22:03,600 --> 00:22:08,158
cute bird with a very nice haircut and

609
00:22:06,559 --> 00:22:10,720
in our case

610
00:22:08,159 --> 00:22:13,039
it's a 64-bit block cipher with a

611
00:22:10,720 --> 00:22:15,679
128-bit key

612
00:22:13,039 --> 00:22:16,799
a very simple key schedule and given the

613
00:22:15,679 --> 00:22:21,200
parameters

614
00:22:16,799 --> 00:22:24,879
we have and a security factor of 20

615
00:22:21,200 --> 00:22:24,880
we have that we need 10 rounds

616
00:22:25,360 --> 00:22:29,439
cracks is extremely lightweight so this

617
00:22:27,840 --> 00:22:33,199
is a full implementation

618
00:22:29,440 --> 00:22:34,720
of cracks you can compile it that's

619
00:22:33,200 --> 00:22:38,480
valid c code

620
00:22:34,720 --> 00:22:39,919
that's the correct encryption in full

621
00:22:38,480 --> 00:22:42,559
we have made some optimized

622
00:22:39,919 --> 00:22:44,080
implementation on microcontrollers and

623
00:22:42,559 --> 00:22:45,840
we have compared them with the best

624
00:22:44,080 --> 00:22:48,639
implementations we are aware of

625
00:22:45,840 --> 00:22:49,439
of several lightweight block ciphers

626
00:22:48,640 --> 00:22:51,360
this table

627
00:22:49,440 --> 00:22:53,280
is in the full version of the paper the

628
00:22:51,360 --> 00:22:55,600
one which is on imprint

629
00:22:53,280 --> 00:22:57,039
and as you can see cracks is extremely

630
00:22:55,600 --> 00:22:59,360
good

631
00:22:57,039 --> 00:23:00,320
especially in terms of ram so the ram

632
00:22:59,360 --> 00:23:03,439
usage

633
00:23:00,320 --> 00:23:06,320
for both encryption and decryption is

634
00:23:03,440 --> 00:23:07,600
four times slower than the second best

635
00:23:06,320 --> 00:23:08,879
and since we don't really have a key

636
00:23:07,600 --> 00:23:12,000
schedule

637
00:23:08,880 --> 00:23:13,039
this one is free compared to others it's

638
00:23:12,000 --> 00:23:16,080
also very small

639
00:23:13,039 --> 00:23:17,520
and very fast so

640
00:23:16,080 --> 00:23:19,199
pretty good lightweight block cipher

641
00:23:17,520 --> 00:23:23,039
which you might consider using

642
00:23:19,200 --> 00:23:24,799
if you need such a thing

643
00:23:23,039 --> 00:23:26,640
but what if you don't need a lightweight

644
00:23:24,799 --> 00:23:29,280
block cipher but instead something

645
00:23:26,640 --> 00:23:29,280
much bigger

646
00:23:30,720 --> 00:23:34,960
in other words can you use a wide xbox

647
00:23:33,120 --> 00:23:36,320
in another way than the trivial one

648
00:23:34,960 --> 00:23:38,799
which consists in just

649
00:23:36,320 --> 00:23:40,158
iterating it can you go beyond so we

650
00:23:38,799 --> 00:23:43,279
would call this kind of structure even

651
00:23:40,159 --> 00:23:46,240
more solar in symmetric crypto

652
00:23:43,279 --> 00:23:47,679
well yes you can that's what we call the

653
00:23:46,240 --> 00:23:48,720
long trade strategy so that's something

654
00:23:47,679 --> 00:23:52,320
we introduced

655
00:23:48,720 --> 00:23:54,480
when we designed sparks in 2016

656
00:23:52,320 --> 00:23:55,360
if i remember correctly and the long

657
00:23:54,480 --> 00:23:58,000
trade strategy

658
00:23:55,360 --> 00:23:58,799
is a design strategy which allows you to

659
00:23:58,000 --> 00:24:01,760
leverage

660
00:23:58,799 --> 00:24:03,600
wider xboxes so if you have an sbox

661
00:24:01,760 --> 00:24:05,360
which needs several iterations to offer

662
00:24:03,600 --> 00:24:08,080
good cryptographic properties like

663
00:24:05,360 --> 00:24:09,678
lz does then it's better to avoid full

664
00:24:08,080 --> 00:24:12,080
diffusion in one round

665
00:24:09,679 --> 00:24:13,679
because since your s-box it's like a

666
00:24:12,080 --> 00:24:14,799
diesel engine it needs time to get

667
00:24:13,679 --> 00:24:16,480
started

668
00:24:14,799 --> 00:24:18,158
it's better to leave it some time to do

669
00:24:16,480 --> 00:24:22,880
its thing on its branch

670
00:24:18,159 --> 00:24:24,559
and then try to to interact with it

671
00:24:22,880 --> 00:24:27,360
so it's a principle which allows us to

672
00:24:24,559 --> 00:24:29,360
use a white sbox

673
00:24:27,360 --> 00:24:32,158
and then we'll see why we would want to

674
00:24:29,360 --> 00:24:35,760
use white as boxes

675
00:24:32,159 --> 00:24:36,159
so this idea of letting the xbox do its

676
00:24:35,760 --> 00:24:37,520
thing

677
00:24:36,159 --> 00:24:40,159
in practice it means that you're going

678
00:24:37,520 --> 00:24:41,600
to have an spn structure a classical one

679
00:24:40,159 --> 00:24:44,400
with a layer of s-boxes

680
00:24:41,600 --> 00:24:46,080
and then a linear layer for diffusion

681
00:24:44,400 --> 00:24:47,760
what's specific is that the linear layer

682
00:24:46,080 --> 00:24:49,039
will be itself built like a faister

683
00:24:47,760 --> 00:24:52,559
network

684
00:24:49,039 --> 00:24:56,080
so like you can see on the pictures

685
00:24:52,559 --> 00:24:58,080
why is it nice let's look at two steps

686
00:24:56,080 --> 00:25:00,879
so when you have two steps uh that's

687
00:24:58,080 --> 00:25:04,240
what it looks like what it looks like

688
00:25:00,880 --> 00:25:06,240
and you know for a fact that

689
00:25:04,240 --> 00:25:08,240
uh the some of the differences will have

690
00:25:06,240 --> 00:25:12,080
to go through two iterations

691
00:25:08,240 --> 00:25:13,039
uh of your widest box so of ld in our

692
00:25:12,080 --> 00:25:15,199
case

693
00:25:13,039 --> 00:25:16,559
so we know that as soon as a difference

694
00:25:15,200 --> 00:25:18,000
enters here

695
00:25:16,559 --> 00:25:20,000
it will have to go through a double

696
00:25:18,000 --> 00:25:22,320
large box and that

697
00:25:20,000 --> 00:25:24,480
means that the probability of this trade

698
00:25:22,320 --> 00:25:27,039
will be at most 2 to the minus

699
00:25:24,480 --> 00:25:28,320
32 in the case of asset which is very

700
00:25:27,039 --> 00:25:32,000
low

701
00:25:28,320 --> 00:25:33,918
and you won't be able to leverage

702
00:25:32,000 --> 00:25:36,240
some hypothetical clustering that you

703
00:25:33,919 --> 00:25:37,440
could have because the difference

704
00:25:36,240 --> 00:25:39,279
the value of the difference here is

705
00:25:37,440 --> 00:25:42,640
fixed since you are tapping the value

706
00:25:39,279 --> 00:25:45,279
here to solve it on the other side

707
00:25:42,640 --> 00:25:47,120
same holds when you have more branches

708
00:25:45,279 --> 00:25:48,799
especially in this case

709
00:25:47,120 --> 00:25:50,158
this given the definition of l-prime

710
00:25:48,799 --> 00:25:53,918
that we have used

711
00:25:50,159 --> 00:25:57,360
is an mds layer so it also provides

712
00:25:53,919 --> 00:25:59,600
strong diffusion

713
00:25:57,360 --> 00:26:01,360
long trace strategy how to use widest

714
00:25:59,600 --> 00:26:04,158
boxes to build

715
00:26:01,360 --> 00:26:04,158
block ciphers

716
00:26:04,559 --> 00:26:09,840
and the t-rex round function is as

717
00:26:07,840 --> 00:26:12,320
follows so that's just

718
00:26:09,840 --> 00:26:14,158
a 256-bit version where you have four

719
00:26:12,320 --> 00:26:16,158
64-bit branches

720
00:26:14,159 --> 00:26:17,279
and you add the tweak directly so you

721
00:26:16,159 --> 00:26:19,120
have a key addition which is not

722
00:26:17,279 --> 00:26:20,240
represented with a complex key schedule

723
00:26:19,120 --> 00:26:22,879
in this case

724
00:26:20,240 --> 00:26:23,600
but the tweak is just cut in two halves

725
00:26:22,880 --> 00:26:26,480
of

726
00:26:23,600 --> 00:26:27,840
64 bits each and you have the first half

727
00:26:26,480 --> 00:26:29,760
which goes here and the second half

728
00:26:27,840 --> 00:26:33,279
which goes here

729
00:26:29,760 --> 00:26:36,559
the tweak is added every second round

730
00:26:33,279 --> 00:26:39,279
every second step not at every step

731
00:26:36,559 --> 00:26:40,320
because it turns out to give us a better

732
00:26:39,279 --> 00:26:43,039
bounce

733
00:26:40,320 --> 00:26:45,279
what kind of bound you ask give me some

734
00:26:43,039 --> 00:26:45,279
time

735
00:26:46,080 --> 00:26:49,120
so how do we justify the security of a

736
00:26:47,919 --> 00:26:51,440
cipher built in this way

737
00:26:49,120 --> 00:26:52,559
why is this a nice way to build a cipher

738
00:26:51,440 --> 00:26:54,960
at all

739
00:26:52,559 --> 00:26:56,158
so let's look at truncated traits a

740
00:26:54,960 --> 00:26:58,400
truncated trail

741
00:26:56,159 --> 00:26:59,440
is a differential trail where you only

742
00:26:58,400 --> 00:27:02,000
care about

743
00:26:59,440 --> 00:27:03,600
whether the part of the state is active

744
00:27:02,000 --> 00:27:05,039
or not so you don't care about the value

745
00:27:03,600 --> 00:27:06,320
you just want to know if it's active or

746
00:27:05,039 --> 00:27:08,879
not

747
00:27:06,320 --> 00:27:09,600
so for each s box you want to know if it

748
00:27:08,880 --> 00:27:12,799
has

749
00:27:09,600 --> 00:27:17,199
a non-zero difference in in its input

750
00:27:12,799 --> 00:27:20,158
or not so if you have ls boxes

751
00:27:17,200 --> 00:27:21,919
then you have two to the l possibilities

752
00:27:20,159 --> 00:27:24,559
per step

753
00:27:21,919 --> 00:27:27,520
each s box is active or not that's two

754
00:27:24,559 --> 00:27:29,440
possibilities and you have to do the l

755
00:27:27,520 --> 00:27:31,120
so if you have s steps to take into

756
00:27:29,440 --> 00:27:33,039
account

757
00:27:31,120 --> 00:27:34,479
that gives you a total of two to the

758
00:27:33,039 --> 00:27:38,158
power l times s

759
00:27:34,480 --> 00:27:41,840
so in the case of aes 128 which is a

760
00:27:38,159 --> 00:27:43,520
10 round cipher with an 8b test box

761
00:27:41,840 --> 00:27:45,600
where you have 16 of them applied in

762
00:27:43,520 --> 00:27:49,520
parallel that gives you a search

763
00:27:45,600 --> 00:27:51,360
search space of size 2 to 160.

764
00:27:49,520 --> 00:27:53,360
you're not going to enumerate all of

765
00:27:51,360 --> 00:27:55,840
those so you can

766
00:27:53,360 --> 00:27:57,520
reduce this number to some extent using

767
00:27:55,840 --> 00:27:59,840
the properties of the linear layer

768
00:27:57,520 --> 00:28:00,639
so not all transitions are possible from

769
00:27:59,840 --> 00:28:03,439
round around

770
00:28:00,640 --> 00:28:05,600
to the next so you can use that to

771
00:28:03,440 --> 00:28:08,399
reduce the search space significantly

772
00:28:05,600 --> 00:28:08,799
but what you can do is use white as box

773
00:28:08,399 --> 00:28:11,840
to

774
00:28:08,799 --> 00:28:12,720
reduce and i mean reduce the search

775
00:28:11,840 --> 00:28:16,000
space

776
00:28:12,720 --> 00:28:17,279
in the case of the aes 128 if you were

777
00:28:16,000 --> 00:28:20,000
using

778
00:28:17,279 --> 00:28:21,039
lz as your s box then you wouldn't have

779
00:28:20,000 --> 00:28:23,919
2 to the 16

780
00:28:21,039 --> 00:28:26,799
possibility in each step you would have

781
00:28:23,919 --> 00:28:31,360
2 to the power 2

782
00:28:26,799 --> 00:28:32,799
which is quite significant

783
00:28:31,360 --> 00:28:35,120
what this means is that if you have an

784
00:28:32,799 --> 00:28:38,639
algorithm which uses widest boxes

785
00:28:35,120 --> 00:28:40,719
like t-rex then you can enumerate all

786
00:28:38,640 --> 00:28:41,760
truncated traits you can just loop over

787
00:28:40,720 --> 00:28:44,159
all of them it's

788
00:28:41,760 --> 00:28:45,279
practical it's practical it's actually

789
00:28:44,159 --> 00:28:47,760
quite fast

790
00:28:45,279 --> 00:28:49,120
you don't need a cluster to do that and

791
00:28:47,760 --> 00:28:51,120
what you can do for instance and that's

792
00:28:49,120 --> 00:28:53,840
the idea of the long trade strategy

793
00:28:51,120 --> 00:28:55,918
is to enumerate all trades and then for

794
00:28:53,840 --> 00:28:59,678
each of them you compute a bound

795
00:28:55,919 --> 00:29:02,240
on the probability of the differential

796
00:28:59,679 --> 00:29:03,440
and then you pick the best the worst

797
00:29:02,240 --> 00:29:05,679
bound you have found

798
00:29:03,440 --> 00:29:08,159
over all the possible traits and that's

799
00:29:05,679 --> 00:29:10,840
a bound for the whole cipher

800
00:29:08,159 --> 00:29:12,399
that's the idea of the long trail

801
00:29:10,840 --> 00:29:14,240
argument

802
00:29:12,399 --> 00:29:15,840
what happens when you add a tweak so a

803
00:29:14,240 --> 00:29:18,880
tweak is

804
00:29:15,840 --> 00:29:21,439
kind of like a key which is public

805
00:29:18,880 --> 00:29:24,159
but not in the publicly cryptosense if

806
00:29:21,440 --> 00:29:27,840
that makes sense

807
00:29:24,159 --> 00:29:30,880
so you have a tweakable block cipher has

808
00:29:27,840 --> 00:29:33,840
three inputs the plain text the key

809
00:29:30,880 --> 00:29:35,760
as before and the tweak the tweak kind

810
00:29:33,840 --> 00:29:37,120
of acts like a key but which you can

811
00:29:35,760 --> 00:29:39,520
assume is under the control of the

812
00:29:37,120 --> 00:29:43,199
adversary so not only does the adversary

813
00:29:39,520 --> 00:29:44,559
know it maybe they can even choose it

814
00:29:43,200 --> 00:29:46,159
which gives a new venue for attack

815
00:29:44,559 --> 00:29:46,879
because then the adversary can inject

816
00:29:46,159 --> 00:29:49,279
differences

817
00:29:46,880 --> 00:29:50,399
through the tweak so how do we handle

818
00:29:49,279 --> 00:29:53,679
this from a

819
00:29:50,399 --> 00:29:55,199
block cipher design's perspective

820
00:29:53,679 --> 00:29:57,039
it's actually very easy when you have a

821
00:29:55,200 --> 00:29:58,399
cipher designed using the long trade

822
00:29:57,039 --> 00:30:00,158
strategy because you can you could

823
00:29:58,399 --> 00:30:03,199
enumerate all the differential trade the

824
00:30:00,159 --> 00:30:05,760
truncated differential trades before

825
00:30:03,200 --> 00:30:06,240
well in our case when you add a tweak

826
00:30:05,760 --> 00:30:09,919
that's

827
00:30:06,240 --> 00:30:12,159
only two new inputs that you need to

828
00:30:09,919 --> 00:30:14,399
consider in every step

829
00:30:12,159 --> 00:30:16,159
which is really not that much so you can

830
00:30:14,399 --> 00:30:18,239
use the same approach as before

831
00:30:16,159 --> 00:30:19,360
you just make a small well i'm not going

832
00:30:18,240 --> 00:30:20,640
to say tweak you just make a small

833
00:30:19,360 --> 00:30:23,199
modification

834
00:30:20,640 --> 00:30:25,200
which is that the tweak can cancel or

835
00:30:23,200 --> 00:30:29,440
maybe add

836
00:30:25,200 --> 00:30:32,880
new branches to your truncated tray

837
00:30:29,440 --> 00:30:36,320
and that and what this means is that

838
00:30:32,880 --> 00:30:38,960
the related tweak security

839
00:30:36,320 --> 00:30:40,720
is very easy to assess both from a

840
00:30:38,960 --> 00:30:42,240
conceptual and from a computational

841
00:30:40,720 --> 00:30:44,720
standpoint

842
00:30:42,240 --> 00:30:46,080
when you have a cipher with wide s boxes

843
00:30:44,720 --> 00:30:47,520
which is built using the long trade

844
00:30:46,080 --> 00:30:50,080
strategy

845
00:30:47,520 --> 00:30:51,600
so we have gone from how do you build

846
00:30:50,080 --> 00:30:53,360
the widest box

847
00:30:51,600 --> 00:30:55,840
to how do you build a cipher using a

848
00:30:53,360 --> 00:30:58,000
white sbox and now finally

849
00:30:55,840 --> 00:30:59,439
why do you want to be the cipher with

850
00:30:58,000 --> 00:31:00,960
the white sbox

851
00:30:59,440 --> 00:31:02,640
and one of the reasons why you want to

852
00:31:00,960 --> 00:31:04,559
do that is that it gives you very easy

853
00:31:02,640 --> 00:31:06,960
security arguments in the related tweak

854
00:31:04,559 --> 00:31:06,960
setting

855
00:31:07,120 --> 00:31:13,120
so we have done just that t-rex

856
00:31:10,640 --> 00:31:14,240
l is a family of is a tweakable block

857
00:31:13,120 --> 00:31:16,639
cipher sorry

858
00:31:14,240 --> 00:31:18,320
so we have taken the round function that

859
00:31:16,640 --> 00:31:20,960
i have showed you before

860
00:31:18,320 --> 00:31:21,840
added a key schedule to it to handle the

861
00:31:20,960 --> 00:31:24,159
master key

862
00:31:21,840 --> 00:31:25,039
the tweak is just sorted into the state

863
00:31:24,159 --> 00:31:26,480
every second step

864
00:31:25,039 --> 00:31:28,559
because we have found that we got the

865
00:31:26,480 --> 00:31:29,840
best bounce

866
00:31:28,559 --> 00:31:31,600
when the tweet was added every second

867
00:31:29,840 --> 00:31:35,600
step

868
00:31:31,600 --> 00:31:38,879
it has a 256 bit key a 128 bit tweak

869
00:31:35,600 --> 00:31:40,399
a 256 bit block size and

870
00:31:38,880 --> 00:31:42,960
using the same type of analysis as

871
00:31:40,399 --> 00:31:46,320
before we have found that it needs

872
00:31:42,960 --> 00:31:48,559
17 steps we have put a bound

873
00:31:46,320 --> 00:31:51,360
on the quarry complexity of the attacks

874
00:31:48,559 --> 00:31:54,399
so an attacker can

875
00:31:51,360 --> 00:31:55,439
try as many key as they want but they

876
00:31:54,399 --> 00:32:00,959
cannot use

877
00:31:55,440 --> 00:32:03,200
more than 102 to the power 128

878
00:32:00,960 --> 00:32:04,000
known or chosen plain texts that's the

879
00:32:03,200 --> 00:32:08,159
idea

880
00:32:04,000 --> 00:32:11,679
so it's just not realistic

881
00:32:08,159 --> 00:32:13,760
to allow the adversary to query

882
00:32:11,679 --> 00:32:14,720
a keyed oracle as many times as they

883
00:32:13,760 --> 00:32:16,960
want

884
00:32:14,720 --> 00:32:18,880
and doing so would lead us to use too

885
00:32:16,960 --> 00:32:21,440
many steps in the primitives so we have

886
00:32:18,880 --> 00:32:22,880
chosen to give it a very very

887
00:32:21,440 --> 00:32:26,000
conservative bound

888
00:32:22,880 --> 00:32:26,000
and work from there

889
00:32:26,720 --> 00:32:31,120
why you would you want to do that with a

890
00:32:29,360 --> 00:32:31,439
white tweakable block cipher you can do

891
00:32:31,120 --> 00:32:33,918
some

892
00:32:31,440 --> 00:32:34,480
nice things because you have at this

893
00:32:33,919 --> 00:32:37,279
stage quite

894
00:32:34,480 --> 00:32:39,200
mature modes of operation that need a

895
00:32:37,279 --> 00:32:42,240
tweakable block cipher which are

896
00:32:39,200 --> 00:32:43,360
paralyzable but then the well problem

897
00:32:42,240 --> 00:32:45,360
you could have is that

898
00:32:43,360 --> 00:32:47,199
usually their security is in a birthday

899
00:32:45,360 --> 00:32:48,799
bound follows the birthday bound on the

900
00:32:47,200 --> 00:32:51,039
block size

901
00:32:48,799 --> 00:32:53,200
so the bigger the block size the bigger

902
00:32:51,039 --> 00:32:56,480
security

903
00:32:53,200 --> 00:32:58,640
hence the need for a white

904
00:32:56,480 --> 00:33:01,200
clickable block cipher which trx

905
00:32:58,640 --> 00:33:01,200
provides you

906
00:33:01,440 --> 00:33:07,120
time to wrap up so lz which is

907
00:33:04,960 --> 00:33:08,000
the key component of the sparkle

908
00:33:07,120 --> 00:33:10,158
permutations

909
00:33:08,000 --> 00:33:11,440
which are themselves the key components

910
00:33:10,159 --> 00:33:14,240
of our nist

911
00:33:11,440 --> 00:33:15,760
lightweight crypto submissions has well

912
00:33:14,240 --> 00:33:19,039
understood

913
00:33:15,760 --> 00:33:21,120
which is what we want on xbox to have

914
00:33:19,039 --> 00:33:23,279
and strong cryptographic properties so

915
00:33:21,120 --> 00:33:26,879
this provides

916
00:33:23,279 --> 00:33:30,159
new light more light on the analysis

917
00:33:26,880 --> 00:33:31,919
of this nist candidate

918
00:33:30,159 --> 00:33:33,360
lz can also be used to build a

919
00:33:31,919 --> 00:33:34,960
lightweight block cipher which is

920
00:33:33,360 --> 00:33:39,760
arguably at least as light

921
00:33:34,960 --> 00:33:40,480
as spec it can also be used to build a

922
00:33:39,760 --> 00:33:42,799
wide

923
00:33:40,480 --> 00:33:44,799
tweakable block cipher which will allow

924
00:33:42,799 --> 00:33:45,679
you since the modes are moralizable to

925
00:33:44,799 --> 00:33:49,200
better use

926
00:33:45,679 --> 00:33:49,919
vector instructions and also the wider

927
00:33:49,200 --> 00:33:51,919
block size

928
00:33:49,919 --> 00:33:54,399
is very interesting for people who work

929
00:33:51,919 --> 00:33:56,320
on post quantum symmetric crypto so

930
00:33:54,399 --> 00:33:59,918
that's another context in which tracks

931
00:33:56,320 --> 00:34:00,639
could be useful and maybe in your own

932
00:33:59,919 --> 00:34:03,200
design

933
00:34:00,640 --> 00:34:04,159
that's a 64-bit test box if you need

934
00:34:03,200 --> 00:34:07,919
such a thing

935
00:34:04,159 --> 00:34:10,960
then just go ahead and use it finally i

936
00:34:07,919 --> 00:34:12,800
urge you to uh not miss

937
00:34:10,960 --> 00:34:14,159
the talk on improved differential linear

938
00:34:12,800 --> 00:34:16,320
attacks with applications to

939
00:34:14,159 --> 00:34:18,320
arc ciphers which deals with the

940
00:34:16,320 --> 00:34:18,879
cryptanalysis of arts-based ciphers

941
00:34:18,320 --> 00:34:21,760
which

942
00:34:18,879 --> 00:34:22,960
those using alzette very much are and

943
00:34:21,760 --> 00:34:24,960
it's a paper by

944
00:34:22,960 --> 00:34:26,720
uh christophe bayerle and his authors

945
00:34:24,960 --> 00:34:30,560
crystal being a co-author of

946
00:34:26,719 --> 00:34:31,118
this one so be sure to check this one

947
00:34:30,560 --> 00:34:35,839
out

948
00:34:31,119 --> 00:34:35,839
and with that i thank you

