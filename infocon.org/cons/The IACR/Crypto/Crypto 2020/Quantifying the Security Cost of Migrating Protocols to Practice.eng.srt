1
00:00:00,560 --> 00:00:04,400
my name is chris patton i'm a recent

2
00:00:02,399 --> 00:00:07,359
graduate of the university of florida

3
00:00:04,400 --> 00:00:09,280
where i was advised by tom shrimpton in

4
00:00:07,359 --> 00:00:09,760
this talk i'll present our latest paper

5
00:00:09,280 --> 00:00:11,360
called

6
00:00:09,760 --> 00:00:13,840
quantifying the security cost of

7
00:00:11,360 --> 00:00:15,678
migrating protocols to practice

8
00:00:13,840 --> 00:00:17,119
these days the standard of security for

9
00:00:15,679 --> 00:00:19,119
a cryptographic protocol

10
00:00:17,119 --> 00:00:20,880
is that breaking it should be as hard as

11
00:00:19,119 --> 00:00:22,880
invalidating some well-studied

12
00:00:20,880 --> 00:00:25,038
computational assumption

13
00:00:22,880 --> 00:00:26,720
which provides a strong guarantee in

14
00:00:25,039 --> 00:00:28,880
theory but in practice

15
00:00:26,720 --> 00:00:31,519
the provable security methodology has

16
00:00:28,880 --> 00:00:33,440
some important limitations

17
00:00:31,519 --> 00:00:35,519
one of them is that for a given system

18
00:00:33,440 --> 00:00:37,120
it succeeds at eliminating attacks

19
00:00:35,520 --> 00:00:38,559
only to the extent that the system's

20
00:00:37,120 --> 00:00:40,239
formal specification

21
00:00:38,559 --> 00:00:43,120
accurately captures its real world

22
00:00:40,239 --> 00:00:45,519
behavior so the subject of this paper

23
00:00:43,120 --> 00:00:46,879
is the task of reconciling discrepancies

24
00:00:45,520 --> 00:00:49,520
between the real system

25
00:00:46,879 --> 00:00:51,199
and it's a supporting analysis so let me

26
00:00:49,520 --> 00:00:52,399
start off with a simple motivating

27
00:00:51,199 --> 00:00:55,360
example

28
00:00:52,399 --> 00:00:56,239
the latest version of tls tls 1.3 is

29
00:00:55,360 --> 00:00:58,960
often lauded

30
00:00:56,239 --> 00:01:00,959
as a success story for provable security

31
00:00:58,960 --> 00:01:01,520
what sets 1.3 apart from earlier

32
00:01:00,960 --> 00:01:03,760
versions

33
00:01:01,520 --> 00:01:06,240
is that security proofs were pursued

34
00:01:03,760 --> 00:01:08,640
during the standardization process

35
00:01:06,240 --> 00:01:11,520
in that spirit an early draft of 1.3 was

36
00:01:08,640 --> 00:01:14,159
based on a protocol called optls

37
00:01:11,520 --> 00:01:15,840
optls has a security proof and it was

38
00:01:14,159 --> 00:01:17,200
designed to meet the needs of the new

39
00:01:15,840 --> 00:01:19,759
standard

40
00:01:17,200 --> 00:01:22,479
even so significant changes were made to

41
00:01:19,759 --> 00:01:25,759
optls in the process of translating it

42
00:01:22,479 --> 00:01:28,158
into the draft of tls 1.3 and this is

43
00:01:25,759 --> 00:01:30,320
typical of the standardization process

44
00:01:28,159 --> 00:01:31,680
the protocol's original designers won't

45
00:01:30,320 --> 00:01:33,758
be able to foresee

46
00:01:31,680 --> 00:01:35,360
all of the practical considerations that

47
00:01:33,759 --> 00:01:38,159
the standard needs to address

48
00:01:35,360 --> 00:01:39,360
so changes are often necessary but it

49
00:01:38,159 --> 00:01:42,240
does raise an

50
00:01:39,360 --> 00:01:43,520
interesting question what if any of the

51
00:01:42,240 --> 00:01:45,839
provable security

52
00:01:43,520 --> 00:01:49,119
that supported the original protocol is

53
00:01:45,840 --> 00:01:50,880
inherited by the final standard

54
00:01:49,119 --> 00:01:53,200
our goal in this work is to answer a

55
00:01:50,880 --> 00:01:55,280
more general version of this question

56
00:01:53,200 --> 00:01:56,719
starting with some reference system for

57
00:01:55,280 --> 00:01:59,040
which security is known

58
00:01:56,719 --> 00:02:00,880
we want to infer the security of the

59
00:01:59,040 --> 00:02:03,360
real system derived from it

60
00:02:00,880 --> 00:02:05,039
so here the reference system refers to

61
00:02:03,360 --> 00:02:06,240
the formal specification from the

62
00:02:05,040 --> 00:02:08,239
original analysis

63
00:02:06,240 --> 00:02:09,598
and the real system is obtained by

64
00:02:08,239 --> 00:02:11,520
revising the spec

65
00:02:09,598 --> 00:02:13,359
in order to account for some observed

66
00:02:11,520 --> 00:02:15,040
behavior like the details of the

67
00:02:13,360 --> 00:02:16,640
standard

68
00:02:15,040 --> 00:02:18,720
i'll refer to this process as

69
00:02:16,640 --> 00:02:21,599
translation generally speaking

70
00:02:18,720 --> 00:02:22,879
translation is the revision of a system

71
00:02:21,599 --> 00:02:24,720
says specification

72
00:02:22,879 --> 00:02:26,799
in order to account for something not

73
00:02:24,720 --> 00:02:29,280
dealt with in the original analysis

74
00:02:26,800 --> 00:02:30,720
that is in the in the reference system

75
00:02:29,280 --> 00:02:32,720
and because changing the spec

76
00:02:30,720 --> 00:02:34,080
can result in an attack it's important

77
00:02:32,720 --> 00:02:36,800
to thoroughly evaluate

78
00:02:34,080 --> 00:02:38,959
its impact on secure suppose we have a

79
00:02:36,800 --> 00:02:42,720
security proof for some reference system

80
00:02:38,959 --> 00:02:46,160
y when we translate y into a new system

81
00:02:42,720 --> 00:02:47,200
x the hope is that x is at least as

82
00:02:46,160 --> 00:02:49,280
secure as y

83
00:02:47,200 --> 00:02:50,640
that is the translation doesn't result

84
00:02:49,280 --> 00:02:52,480
in a new attack

85
00:02:50,640 --> 00:02:53,920
and the way we verify this is to repeat

86
00:02:52,480 --> 00:02:57,040
the same analysis for x

87
00:02:53,920 --> 00:02:58,879
that's already been done for y that is

88
00:02:57,040 --> 00:03:01,679
suppose that we know that breaking y

89
00:02:58,879 --> 00:03:02,959
is as hard as solving some problem p

90
00:03:01,680 --> 00:03:04,720
what we want to show

91
00:03:02,959 --> 00:03:06,400
is that this reduction from the hardness

92
00:03:04,720 --> 00:03:07,920
of p to the security of y

93
00:03:06,400 --> 00:03:10,640
can be modified to account for the

94
00:03:07,920 --> 00:03:13,040
translation but this task

95
00:03:10,640 --> 00:03:14,958
bears a significant analytical cost and

96
00:03:13,040 --> 00:03:17,120
one that might make a rigorous treatment

97
00:03:14,959 --> 00:03:19,200
of this problem prohibitive

98
00:03:17,120 --> 00:03:20,959
because generating a fresh proof just

99
00:03:19,200 --> 00:03:23,119
requires a certain amount of work

100
00:03:20,959 --> 00:03:25,200
and depending on how different the real

101
00:03:23,120 --> 00:03:27,040
system is from the reference system

102
00:03:25,200 --> 00:03:29,040
this task is likely to be highly

103
00:03:27,040 --> 00:03:30,720
redundant to take an analogy

104
00:03:29,040 --> 00:03:32,720
imagine we want to find a route to the

105
00:03:30,720 --> 00:03:34,799
top of a mountain we might choose to

106
00:03:32,720 --> 00:03:36,480
start from scratch

107
00:03:34,799 --> 00:03:38,640
but if someone else has already found a

108
00:03:36,480 --> 00:03:39,679
path to a point close to where we want

109
00:03:38,640 --> 00:03:41,359
to go

110
00:03:39,680 --> 00:03:43,360
then we might save ourselves a good deal

111
00:03:41,360 --> 00:03:44,159
of trouble by starting our pathfinding

112
00:03:43,360 --> 00:03:46,400
expedition

113
00:03:44,159 --> 00:03:48,720
from this previously discovered point

114
00:03:46,400 --> 00:03:50,560
and so it is with provable security

115
00:03:48,720 --> 00:03:51,840
the work required to prove that the real

116
00:03:50,560 --> 00:03:53,680
system is secure

117
00:03:51,840 --> 00:03:55,040
might significantly overlap with the

118
00:03:53,680 --> 00:03:58,799
work required to prove

119
00:03:55,040 --> 00:04:00,959
that the rest reference system is secure

120
00:03:58,799 --> 00:04:02,799
so what we're going to do in this work

121
00:04:00,959 --> 00:04:03,920
is characterize the conditions under

122
00:04:02,799 --> 00:04:06,400
which it's possible

123
00:04:03,920 --> 00:04:08,159
to prove the real system secure by

124
00:04:06,400 --> 00:04:09,760
appealing directly to what's already

125
00:04:08,159 --> 00:04:10,480
been established for the reference

126
00:04:09,760 --> 00:04:12,480
system

127
00:04:10,480 --> 00:04:14,560
in other words what we want is a black

128
00:04:12,480 --> 00:04:17,199
box reduction from the security of y

129
00:04:14,560 --> 00:04:18,720
to the security of x and the main

130
00:04:17,199 --> 00:04:20,959
contribution of this work

131
00:04:18,720 --> 00:04:23,600
is a formal framework in which this kind

132
00:04:20,959 --> 00:04:26,639
of argument can be made precise

133
00:04:23,600 --> 00:04:28,040
we call it the translation framework

134
00:04:26,639 --> 00:04:30,000
it's based on the notion of

135
00:04:28,040 --> 00:04:31,440
indifferentiability which by now is a

136
00:04:30,000 --> 00:04:33,199
fairly well-known idea

137
00:04:31,440 --> 00:04:35,199
particularly as a design goal for

138
00:04:33,199 --> 00:04:37,040
cryptographic hash functions

139
00:04:35,199 --> 00:04:38,320
but the notion is much more general than

140
00:04:37,040 --> 00:04:39,680
this one application

141
00:04:38,320 --> 00:04:41,360
here i'm going to demonstrate for the

142
00:04:39,680 --> 00:04:42,000
first time it's used for studying

143
00:04:41,360 --> 00:04:44,400
cryptographic

144
00:04:42,000 --> 00:04:46,400
protocols now if you've never heard of

145
00:04:44,400 --> 00:04:48,000
this concept of indifferentiability

146
00:04:46,400 --> 00:04:50,000
don't worry i'm going to define it in a

147
00:04:48,000 --> 00:04:52,000
little while i'll start this off by

148
00:04:50,000 --> 00:04:54,080
describing the case study that motivated

149
00:04:52,000 --> 00:04:55,759
this application of indifferentiability

150
00:04:54,080 --> 00:04:58,240
and the more general translation

151
00:04:55,759 --> 00:05:00,320
framework one of my favorite types of

152
00:04:58,240 --> 00:05:01,280
protocols is password authenticated key

153
00:05:00,320 --> 00:05:03,759
exchange or

154
00:05:01,280 --> 00:05:04,799
pake for short the goal of pake is to

155
00:05:03,759 --> 00:05:06,400
establish a key

156
00:05:04,800 --> 00:05:08,639
between a client and a server who

157
00:05:06,400 --> 00:05:11,120
initially only share a password

158
00:05:08,639 --> 00:05:12,320
so here i've drawn a peak protocol with

159
00:05:11,120 --> 00:05:13,759
just two messages

160
00:05:12,320 --> 00:05:15,440
the first sent from the client to the

161
00:05:13,759 --> 00:05:16,880
server and the second sent from the

162
00:05:15,440 --> 00:05:18,560
server to the client

163
00:05:16,880 --> 00:05:20,560
having exchanged these messages the

164
00:05:18,560 --> 00:05:22,880
parties can then derive a share key

165
00:05:20,560 --> 00:05:24,400
which we'll call the session key the

166
00:05:22,880 --> 00:05:26,240
security goal for pake is that the

167
00:05:24,400 --> 00:05:27,440
session key should be indistinguishable

168
00:05:26,240 --> 00:05:29,600
from a random key

169
00:05:27,440 --> 00:05:30,639
even to an adversary who observes all

170
00:05:29,600 --> 00:05:32,400
network traffic

171
00:05:30,639 --> 00:05:35,680
and can actively interfere in the

172
00:05:32,400 --> 00:05:35,679
protocol's execution

173
00:05:35,919 --> 00:05:39,359
and more to the point this should hold

174
00:05:37,919 --> 00:05:41,840
even when the password has

175
00:05:39,360 --> 00:05:42,400
relatively low entropy but of course the

176
00:05:41,840 --> 00:05:44,560
entropy

177
00:05:42,400 --> 00:05:46,159
is too low then there's no hope of

178
00:05:44,560 --> 00:05:48,080
achieving security at all

179
00:05:46,160 --> 00:05:49,919
because the adversary can always try to

180
00:05:48,080 --> 00:05:51,440
guess the password when impersonating

181
00:05:49,919 --> 00:05:53,440
one party to the other

182
00:05:51,440 --> 00:05:55,280
and since this is inevitable pigs are

183
00:05:53,440 --> 00:05:56,400
designed to ensure that the adversary

184
00:05:55,280 --> 00:06:00,239
can't do any better

185
00:05:56,400 --> 00:06:02,159
than this simple online guessing attack

186
00:06:00,240 --> 00:06:03,759
now pigs are wonderfully versatile

187
00:06:02,160 --> 00:06:04,880
objects that find a lot of useful

188
00:06:03,759 --> 00:06:06,880
applications

189
00:06:04,880 --> 00:06:08,560
they tend to be on the simple side often

190
00:06:06,880 --> 00:06:10,159
having just two messages

191
00:06:08,560 --> 00:06:11,759
and simplicity is a real asset here

192
00:06:10,160 --> 00:06:12,560
because the lower the communication

193
00:06:11,759 --> 00:06:14,479
complexity

194
00:06:12,560 --> 00:06:16,639
the easier it is to integrate the pake

195
00:06:14,479 --> 00:06:18,479
into applications

196
00:06:16,639 --> 00:06:20,639
in particular there's been a lot of

197
00:06:18,479 --> 00:06:22,479
recent interest in integrating a pake

198
00:06:20,639 --> 00:06:24,160
into tls

199
00:06:22,479 --> 00:06:26,479
now this would allow using passwords

200
00:06:24,160 --> 00:06:28,000
alongside of or even in lieu of

201
00:06:26,479 --> 00:06:30,159
traditional certificates

202
00:06:28,000 --> 00:06:31,600
so that tls can be used without solely

203
00:06:30,160 --> 00:06:34,080
relying on the web public key

204
00:06:31,600 --> 00:06:36,000
infrastructure for authentication

205
00:06:34,080 --> 00:06:38,000
okay so let's let's think about how we

206
00:06:36,000 --> 00:06:41,120
might do this how we might integrate

207
00:06:38,000 --> 00:06:42,319
opaque into the tls protocol so here we

208
00:06:41,120 --> 00:06:45,360
see a simplified view

209
00:06:42,319 --> 00:06:46,400
of the tls 1.3 handshake the client and

210
00:06:45,360 --> 00:06:48,319
server exchange

211
00:06:46,400 --> 00:06:50,638
three flows before they derive a session

212
00:06:48,319 --> 00:06:52,319
key in the first flow the client sends

213
00:06:50,639 --> 00:06:53,120
its diffie-hellman key share to the

214
00:06:52,319 --> 00:06:55,199
server

215
00:06:53,120 --> 00:06:57,280
and in the second flow the server sends

216
00:06:55,199 --> 00:06:59,680
its own key share to the client

217
00:06:57,280 --> 00:07:00,400
as well as another value which i'll call

218
00:06:59,680 --> 00:07:02,479
the server's

219
00:07:00,400 --> 00:07:04,479
confirmation message and in the last

220
00:07:02,479 --> 00:07:07,199
flow the client the client sends its own

221
00:07:04,479 --> 00:07:09,039
confirmation message to the server

222
00:07:07,199 --> 00:07:11,360
each of these flows corresponds to a

223
00:07:09,039 --> 00:07:12,800
sequence of actual handshake messages in

224
00:07:11,360 --> 00:07:14,960
the tls protocol

225
00:07:12,800 --> 00:07:16,639
but as we'll see later the contents and

226
00:07:14,960 --> 00:07:18,479
semantics of these messages

227
00:07:16,639 --> 00:07:20,560
aren't relevant to the problem at hand

228
00:07:18,479 --> 00:07:21,199
for our purposes all that really matters

229
00:07:20,560 --> 00:07:22,880
about them

230
00:07:21,199 --> 00:07:24,240
is that the key exchange messages are

231
00:07:22,880 --> 00:07:25,599
sent in the clear whereas the

232
00:07:24,240 --> 00:07:28,000
confirmation messages

233
00:07:25,599 --> 00:07:29,919
depend on keys derived from the shared

234
00:07:28,000 --> 00:07:31,520
secret i'll return to this idea in a

235
00:07:29,919 --> 00:07:33,280
little while

236
00:07:31,520 --> 00:07:34,960
now those familiar with tls will notice

237
00:07:33,280 --> 00:07:36,559
that there are any number of ways that

238
00:07:34,960 --> 00:07:37,599
we might integrate opaque into the

239
00:07:36,560 --> 00:07:39,599
handshake

240
00:07:37,599 --> 00:07:41,680
but the general principle is that we

241
00:07:39,599 --> 00:07:43,120
would standardize a protocol extension

242
00:07:41,680 --> 00:07:45,199
for this purpose

243
00:07:43,120 --> 00:07:47,120
now many extensions in tls have the same

244
00:07:45,199 --> 00:07:49,120
basic structure

245
00:07:47,120 --> 00:07:51,120
a client requests usage of a particular

246
00:07:49,120 --> 00:07:53,039
extension by sending what's called an

247
00:07:51,120 --> 00:07:54,800
extension request to the server

248
00:07:53,039 --> 00:07:56,479
if the server agrees to use it then

249
00:07:54,800 --> 00:07:57,759
it'll send an extension response and

250
00:07:56,479 --> 00:07:59,599
reply

251
00:07:57,759 --> 00:08:02,639
the request and response might carry

252
00:07:59,599 --> 00:08:05,840
data that's relevant to the extension

253
00:08:02,639 --> 00:08:07,680
so we can specify an extension which

254
00:08:05,840 --> 00:08:09,758
in which the request carries the first

255
00:08:07,680 --> 00:08:10,800
page message and the response carries

256
00:08:09,759 --> 00:08:12,639
the second

257
00:08:10,800 --> 00:08:14,639
then we would use the pake shared secret

258
00:08:12,639 --> 00:08:17,039
to derive keys rather than the usual

259
00:08:14,639 --> 00:08:20,000
diffie-hellman key exchange

260
00:08:17,039 --> 00:08:22,080
now this is one approach to integrating

261
00:08:20,000 --> 00:08:22,639
opaque into tls it's not the only one of

262
00:08:22,080 --> 00:08:25,280
course

263
00:08:22,639 --> 00:08:27,759
but it has some nice features it works

264
00:08:25,280 --> 00:08:29,919
with any pake that has just two messages

265
00:08:27,759 --> 00:08:32,240
and therefore appears to have relatively

266
00:08:29,919 --> 00:08:34,559
low implementation complexity

267
00:08:32,240 --> 00:08:36,560
but what about security the hope is that

268
00:08:34,559 --> 00:08:38,159
at the very least this usage of the pake

269
00:08:36,559 --> 00:08:39,039
should be no less secure than the pick

270
00:08:38,159 --> 00:08:41,039
itself

271
00:08:39,039 --> 00:08:42,880
in other words whatever security

272
00:08:41,039 --> 00:08:45,920
property has been proven for the pake

273
00:08:42,880 --> 00:08:46,240
should also hold for our extension okay

274
00:08:45,920 --> 00:08:49,519
so

275
00:08:46,240 --> 00:08:52,000
now we need a definition of security

276
00:08:49,519 --> 00:08:54,000
here i'll provide a brief overview of an

277
00:08:52,000 --> 00:08:56,320
appropriate model for authenticated key

278
00:08:54,000 --> 00:08:57,839
exchange i'm going to define it in terms

279
00:08:56,320 --> 00:09:00,080
of two objects

280
00:08:57,839 --> 00:09:01,600
the execution environment which

281
00:09:00,080 --> 00:09:02,399
formalizes the interaction of the

282
00:09:01,600 --> 00:09:04,640
adversary

283
00:09:02,399 --> 00:09:06,320
with honest parties in the protocol and

284
00:09:04,640 --> 00:09:08,319
the game which will formalize

285
00:09:06,320 --> 00:09:09,600
the adversary's objective in attacking

286
00:09:08,320 --> 00:09:11,360
the protocol

287
00:09:09,600 --> 00:09:13,600
now if you're familiar with game based

288
00:09:11,360 --> 00:09:16,480
models for authenticated key exchange

289
00:09:13,600 --> 00:09:17,920
then this decoupling of the components

290
00:09:16,480 --> 00:09:20,560
of the security experiment

291
00:09:17,920 --> 00:09:21,599
might seem might seem a bit unusual but

292
00:09:20,560 --> 00:09:23,439
it's going to help us get

293
00:09:21,600 --> 00:09:25,040
to where we're eventually going which is

294
00:09:23,440 --> 00:09:28,080
to use in differentiability

295
00:09:25,040 --> 00:09:29,920
to formalize secure translation we model

296
00:09:28,080 --> 00:09:30,720
an active network attacker by having the

297
00:09:29,920 --> 00:09:33,120
adversary

298
00:09:30,720 --> 00:09:34,560
be responsible for relaying all traffic

299
00:09:33,120 --> 00:09:36,880
in the network

300
00:09:34,560 --> 00:09:38,399
it's also responsible for initiating

301
00:09:36,880 --> 00:09:40,320
each session that is

302
00:09:38,399 --> 00:09:42,720
each instance of a party running the

303
00:09:40,320 --> 00:09:44,399
protocol presumably with an instance of

304
00:09:42,720 --> 00:09:46,320
some other party

305
00:09:44,399 --> 00:09:48,720
the attacker is empowered to corrupt a

306
00:09:46,320 --> 00:09:50,480
session by revealing its ephemeral key

307
00:09:48,720 --> 00:09:52,000
which consists of the random coins

308
00:09:50,480 --> 00:09:53,920
consumed by that session

309
00:09:52,000 --> 00:09:55,519
for example to generate the party's

310
00:09:53,920 --> 00:09:58,319
keyshare

311
00:09:55,519 --> 00:10:00,160
it can also corrupt a party by revealing

312
00:09:58,320 --> 00:10:02,240
that party's static key that is

313
00:10:00,160 --> 00:10:04,640
the long-term secret used by the party

314
00:10:02,240 --> 00:10:06,320
across multiple sessions so in our case

315
00:10:04,640 --> 00:10:09,439
a client static key would be

316
00:10:06,320 --> 00:10:10,160
its password when a session completes

317
00:10:09,440 --> 00:10:12,320
successfully

318
00:10:10,160 --> 00:10:15,199
it outputs a session key which the

319
00:10:12,320 --> 00:10:16,480
attacker is also capable of revealing

320
00:10:15,200 --> 00:10:18,640
and recall that the goal of the

321
00:10:16,480 --> 00:10:20,160
adversary is to distinguish some session

322
00:10:18,640 --> 00:10:22,480
key from a random key

323
00:10:20,160 --> 00:10:24,480
to formalize this the experiment defines

324
00:10:22,480 --> 00:10:25,920
an oracle that executes the following

325
00:10:24,480 --> 00:10:28,160
simple procedure

326
00:10:25,920 --> 00:10:29,360
it flips a coin and if the coin comes up

327
00:10:28,160 --> 00:10:32,399
heads then

328
00:10:29,360 --> 00:10:33,120
the oracle returns a key output by some

329
00:10:32,399 --> 00:10:35,600
test session

330
00:10:33,120 --> 00:10:37,680
chosen by the adversary otherwise is it

331
00:10:35,600 --> 00:10:38,800
chooses a key at random and returns that

332
00:10:37,680 --> 00:10:41,439
instead

333
00:10:38,800 --> 00:10:43,359
the adversary wins if it correctly

334
00:10:41,440 --> 00:10:46,640
guesses the outcome of the coin flip

335
00:10:43,360 --> 00:10:49,200
based on the output of this oracle

336
00:10:46,640 --> 00:10:49,839
we also require that the test session is

337
00:10:49,200 --> 00:10:51,920
fresh

338
00:10:49,839 --> 00:10:53,279
in the in the sense that computing the

339
00:10:51,920 --> 00:10:56,160
real test session key

340
00:10:53,279 --> 00:10:57,760
should be non-trivial for the adversary

341
00:10:56,160 --> 00:10:58,800
we're going to write this experiment in

342
00:10:57,760 --> 00:11:01,839
terms of three

343
00:10:58,800 --> 00:11:03,120
objects the adversary a the game g

344
00:11:01,839 --> 00:11:05,040
that formalizes this key

345
00:11:03,120 --> 00:11:05,519
indistinguishability property and the

346
00:11:05,040 --> 00:11:07,519
system

347
00:11:05,519 --> 00:11:08,800
x that formalizes the execution

348
00:11:07,519 --> 00:11:11,839
environment

349
00:11:08,800 --> 00:11:13,040
x specifies two distinct interfaces one

350
00:11:11,839 --> 00:11:14,560
that's called by the game

351
00:11:13,040 --> 00:11:17,199
and another that's called by the

352
00:11:14,560 --> 00:11:19,518
adversary the second interface lets the

353
00:11:17,200 --> 00:11:21,440
adversary interact with honest parties

354
00:11:19,519 --> 00:11:23,200
including initializing new sessions

355
00:11:21,440 --> 00:11:26,240
sending messages to sessions

356
00:11:23,200 --> 00:11:28,480
and revealing ephemeral and static keys

357
00:11:26,240 --> 00:11:30,320
the first interface is used by the game

358
00:11:28,480 --> 00:11:32,079
in order to obtain session keys

359
00:11:30,320 --> 00:11:34,480
as well as other information that might

360
00:11:32,079 --> 00:11:37,760
be used to determine if the test session

361
00:11:34,480 --> 00:11:38,160
is fresh the adversary makes queries to

362
00:11:37,760 --> 00:11:39,920
the game

363
00:11:38,160 --> 00:11:41,439
in order to reveal session keys

364
00:11:39,920 --> 00:11:43,199
including for the test session

365
00:11:41,440 --> 00:11:45,440
and to make its guess of the challenge

366
00:11:43,200 --> 00:11:46,240
bit the experiment begins by running the

367
00:11:45,440 --> 00:11:48,399
adversary

368
00:11:46,240 --> 00:11:50,399
and once it halts the game outputs a bit

369
00:11:48,399 --> 00:11:52,880
that indicates whether the adversary's

370
00:11:50,399 --> 00:11:54,880
attack was successful

371
00:11:52,880 --> 00:11:56,160
what we're interested in is a protocol's

372
00:11:54,880 --> 00:11:57,920
concrete security

373
00:11:56,160 --> 00:11:59,680
that is the probability that an

374
00:11:57,920 --> 00:12:00,800
adversary with a given run time and

375
00:11:59,680 --> 00:12:03,199
query complexity

376
00:12:00,800 --> 00:12:04,800
correctly guesses the challenge bit our

377
00:12:03,200 --> 00:12:05,760
goal for the design of our pick

378
00:12:04,800 --> 00:12:08,319
extension

379
00:12:05,760 --> 00:12:09,839
is that its concrete security should be

380
00:12:08,320 --> 00:12:12,000
roughly the same as the concrete

381
00:12:09,839 --> 00:12:14,480
security of the underlying pick

382
00:12:12,000 --> 00:12:16,480
more formally we want to show that for

383
00:12:14,480 --> 00:12:18,399
every adversary a that breaks the pick

384
00:12:16,480 --> 00:12:20,560
extension with some probability

385
00:12:18,399 --> 00:12:21,760
there exists an adversary b that breaks

386
00:12:20,560 --> 00:12:23,760
the peak itself

387
00:12:21,760 --> 00:12:26,160
with essentially the same probability

388
00:12:23,760 --> 00:12:27,519
and that has a similar runtime and query

389
00:12:26,160 --> 00:12:29,199
complexity

390
00:12:27,519 --> 00:12:30,639
now it turns out that we can construct

391
00:12:29,200 --> 00:12:33,279
such a b whenever

392
00:12:30,639 --> 00:12:34,480
the execution of the pake extension is

393
00:12:33,279 --> 00:12:37,519
indifferentiable

394
00:12:34,480 --> 00:12:39,279
from the execution of the pic so let me

395
00:12:37,519 --> 00:12:41,440
now clarify what this means

396
00:12:39,279 --> 00:12:42,880
in particular i want to show you how to

397
00:12:41,440 --> 00:12:44,160
use the standard notion of

398
00:12:42,880 --> 00:12:46,959
indifferentiability

399
00:12:44,160 --> 00:12:48,240
to reason about secure translation and

400
00:12:46,959 --> 00:12:50,319
what we're going to find

401
00:12:48,240 --> 00:12:52,079
is that it has some limitations that

402
00:12:50,320 --> 00:12:54,240
we're going to need to overcome in the

403
00:12:52,079 --> 00:12:55,279
translation framework

404
00:12:54,240 --> 00:12:57,120
now the usual notion of

405
00:12:55,279 --> 00:12:58,720
indifferentiability is expressed in

406
00:12:57,120 --> 00:13:00,480
terms of an adversary d

407
00:12:58,720 --> 00:13:02,880
which we'll call the differentiator and

408
00:13:00,480 --> 00:13:05,040
a pair of systems x and y

409
00:13:02,880 --> 00:13:06,880
x is thought of as the real system and

410
00:13:05,040 --> 00:13:09,120
we'll think of y as the reference system

411
00:13:06,880 --> 00:13:11,600
for which security is known

412
00:13:09,120 --> 00:13:12,639
now d is given black box access to one

413
00:13:11,600 --> 00:13:14,800
of these systems

414
00:13:12,639 --> 00:13:16,079
and its task is to determine which it's

415
00:13:14,800 --> 00:13:17,599
interacting with

416
00:13:16,079 --> 00:13:19,359
it outputs one if it believes it's

417
00:13:17,600 --> 00:13:20,800
interacting with the real system

418
00:13:19,360 --> 00:13:22,800
and we're interested what we're

419
00:13:20,800 --> 00:13:23,760
interested in is the probability that it

420
00:13:22,800 --> 00:13:25,599
outputs one

421
00:13:23,760 --> 00:13:27,120
in the real experiment versus in the

422
00:13:25,600 --> 00:13:28,959
reference experiment

423
00:13:27,120 --> 00:13:31,040
and this will formalize its advantage in

424
00:13:28,959 --> 00:13:32,560
discerning which system it's interacting

425
00:13:31,040 --> 00:13:34,800
with

426
00:13:32,560 --> 00:13:36,880
now in the reference experiment the

427
00:13:34,800 --> 00:13:37,599
adversary's access to the system second

428
00:13:36,880 --> 00:13:40,240
interface

429
00:13:37,600 --> 00:13:41,360
is mediated by a simulator s as shown

430
00:13:40,240 --> 00:13:43,760
here

431
00:13:41,360 --> 00:13:44,720
the simulator's job is to trick the

432
00:13:43,760 --> 00:13:46,560
adversary

433
00:13:44,720 --> 00:13:47,760
into thinking it's interacting with the

434
00:13:46,560 --> 00:13:49,518
real system when

435
00:13:47,760 --> 00:13:51,439
in fact it's running in the reference

436
00:13:49,519 --> 00:13:54,560
experiment so

437
00:13:51,440 --> 00:13:56,880
the system second interface intuitively

438
00:13:54,560 --> 00:13:59,439
is meant to formalize what changes from

439
00:13:56,880 --> 00:14:00,639
the reference experiment to the real one

440
00:13:59,440 --> 00:14:02,880
so going back to our model for

441
00:14:00,639 --> 00:14:04,000
authenticated key exchange recall that

442
00:14:02,880 --> 00:14:06,000
the second interface

443
00:14:04,000 --> 00:14:07,120
lets the adversary execute sessions of

444
00:14:06,000 --> 00:14:09,920
the protocol

445
00:14:07,120 --> 00:14:11,600
so in this setting the simulator's job

446
00:14:09,920 --> 00:14:14,399
is to make the execution

447
00:14:11,600 --> 00:14:16,000
of the base pake look like the execution

448
00:14:14,399 --> 00:14:18,160
of the pake extension

449
00:14:16,000 --> 00:14:19,839
in general we say that x is

450
00:14:18,160 --> 00:14:22,000
indifferentiable from y

451
00:14:19,839 --> 00:14:23,040
if for every efficient d there exists an

452
00:14:22,000 --> 00:14:25,120
efficient s

453
00:14:23,040 --> 00:14:27,120
such that d's advantage in

454
00:14:25,120 --> 00:14:28,480
differentiating the real experiment from

455
00:14:27,120 --> 00:14:30,959
the reference experiment

456
00:14:28,480 --> 00:14:33,279
is small in other words to prove

457
00:14:30,959 --> 00:14:36,399
indifferentiability what we want to do

458
00:14:33,279 --> 00:14:37,839
is construct the simulator s such that

459
00:14:36,399 --> 00:14:40,399
the differentiator d

460
00:14:37,839 --> 00:14:41,920
is unable to tell which experiment it

461
00:14:40,399 --> 00:14:43,920
finds itself in

462
00:14:41,920 --> 00:14:45,599
if we can do this then there's a simple

463
00:14:43,920 --> 00:14:46,800
dilemma that allows us to relate the

464
00:14:45,600 --> 00:14:48,639
security of the real

465
00:14:46,800 --> 00:14:50,399
system to the security of the reference

466
00:14:48,639 --> 00:14:52,720
system in particular

467
00:14:50,399 --> 00:14:53,760
for every efficient attacker a and

468
00:14:52,720 --> 00:14:56,800
simulator s

469
00:14:53,760 --> 00:14:59,760
we can construct an efficient attacker b

470
00:14:56,800 --> 00:15:00,719
and differentiator d such that a success

471
00:14:59,760 --> 00:15:02,639
probability

472
00:15:00,720 --> 00:15:04,240
is bounded above by b success

473
00:15:02,639 --> 00:15:07,600
probability plus

474
00:15:04,240 --> 00:15:09,600
d's differentiating advantage

475
00:15:07,600 --> 00:15:11,040
in other words if the real system is

476
00:15:09,600 --> 00:15:11,519
indifferentiable from the reference

477
00:15:11,040 --> 00:15:13,760
system

478
00:15:11,519 --> 00:15:14,720
then we can transform an attack against

479
00:15:13,760 --> 00:15:16,639
the real system

480
00:15:14,720 --> 00:15:17,839
into an attack against the reference

481
00:15:16,639 --> 00:15:21,360
system

482
00:15:17,839 --> 00:15:21,760
so for any game g if y is secure in the

483
00:15:21,360 --> 00:15:24,240
sense

484
00:15:21,760 --> 00:15:26,000
formalized by g and x is

485
00:15:24,240 --> 00:15:28,639
indifferentiable from y

486
00:15:26,000 --> 00:15:29,920
then x is also secure in the sense

487
00:15:28,639 --> 00:15:32,399
formalized by g

488
00:15:29,920 --> 00:15:34,880
and this is true for any game that's

489
00:15:32,399 --> 00:15:36,800
compatible with our security experiment

490
00:15:34,880 --> 00:15:38,800
which is great because we now have a way

491
00:15:36,800 --> 00:15:40,240
to infer security of the real system

492
00:15:38,800 --> 00:15:42,479
from what's already been established

493
00:15:40,240 --> 00:15:44,959
for the reference system all we have to

494
00:15:42,480 --> 00:15:46,240
do is prove indifferentiability

495
00:15:44,959 --> 00:15:49,040
so we're at the top of the mountain

496
00:15:46,240 --> 00:15:51,120
right not quite

497
00:15:49,040 --> 00:15:52,240
this notion which i'll remind you is the

498
00:15:51,120 --> 00:15:54,480
usual notion of

499
00:15:52,240 --> 00:15:56,079
indifferentiability is not yet suitable

500
00:15:54,480 --> 00:15:57,519
for a formal treatment of secure

501
00:15:56,079 --> 00:15:59,758
translation

502
00:15:57,519 --> 00:16:02,000
now individuality i'll remind you is

503
00:15:59,759 --> 00:16:04,160
normally used to reason about relatively

504
00:16:02,000 --> 00:16:05,360
simple objects like hash functions or

505
00:16:04,160 --> 00:16:07,120
block ciphers

506
00:16:05,360 --> 00:16:09,519
the objects that we're interested in

507
00:16:07,120 --> 00:16:11,440
authenticated key exchange for example

508
00:16:09,519 --> 00:16:12,639
are more complex than this so to deal

509
00:16:11,440 --> 00:16:14,639
with this complexity

510
00:16:12,639 --> 00:16:15,680
we'll need to generalize the notion a

511
00:16:14,639 --> 00:16:17,120
bit further

512
00:16:15,680 --> 00:16:19,040
for starters our notion of

513
00:16:17,120 --> 00:16:21,040
indifferentiability pertains to a more

514
00:16:19,040 --> 00:16:23,279
general security experiment

515
00:16:21,040 --> 00:16:24,240
so here we see the experiment that we

516
00:16:23,279 --> 00:16:26,880
had before

517
00:16:24,240 --> 00:16:28,639
involving the same old system x game g

518
00:16:26,880 --> 00:16:30,399
and adversary a

519
00:16:28,639 --> 00:16:32,079
in the translation framework we're going

520
00:16:30,399 --> 00:16:35,120
to embellish this experiment

521
00:16:32,079 --> 00:16:37,199
in three key ways the first thing we'll

522
00:16:35,120 --> 00:16:38,800
do is add another object which we'll

523
00:16:37,199 --> 00:16:40,399
call the resources

524
00:16:38,800 --> 00:16:42,000
now resource resources are going to

525
00:16:40,399 --> 00:16:44,399
model things that might be used

526
00:16:42,000 --> 00:16:45,440
to prove security but aren't essential

527
00:16:44,399 --> 00:16:48,079
to defining

528
00:16:45,440 --> 00:16:49,839
a security so for example resources are

529
00:16:48,079 --> 00:16:51,519
used to formalize the random oracle

530
00:16:49,839 --> 00:16:53,279
model in our experiment

531
00:16:51,519 --> 00:16:54,800
now they can be used for a variety of

532
00:16:53,279 --> 00:16:57,120
things but in general

533
00:16:54,800 --> 00:16:58,880
they're going to be things that that

534
00:16:57,120 --> 00:17:01,360
that in the experiment that the system

535
00:16:58,880 --> 00:17:03,199
and adversary share access to for

536
00:17:01,360 --> 00:17:04,959
example the random oracle in the random

537
00:17:03,199 --> 00:17:07,438
oracle model

538
00:17:04,959 --> 00:17:08,240
next the experiment is parameterized by

539
00:17:07,439 --> 00:17:10,400
a function

540
00:17:08,240 --> 00:17:12,079
psi called the transcript predicate

541
00:17:10,400 --> 00:17:13,280
which is used to determine if the

542
00:17:12,079 --> 00:17:15,678
adversary's attack

543
00:17:13,280 --> 00:17:18,160
is valid based on the sequence of

544
00:17:15,679 --> 00:17:21,199
queries it makes to the game and system

545
00:17:18,160 --> 00:17:21,760
the adversary wins now if it wins the

546
00:17:21,199 --> 00:17:23,919
game

547
00:17:21,760 --> 00:17:25,520
and its attack is valid according to the

548
00:17:23,919 --> 00:17:27,039
transcript predicate

549
00:17:25,520 --> 00:17:29,280
and this is going to be useful for

550
00:17:27,039 --> 00:17:29,919
enforcing restrictions on the execution

551
00:17:29,280 --> 00:17:33,039
environment

552
00:17:29,919 --> 00:17:34,960
when proving so for example

553
00:17:33,039 --> 00:17:36,879
in an analysis of a particular

554
00:17:34,960 --> 00:17:38,799
authenticated key exchange protocol

555
00:17:36,880 --> 00:17:40,720
we might need to restrict the adversary

556
00:17:38,799 --> 00:17:41,760
from revealing ephemeral key

557
00:17:40,720 --> 00:17:44,080
and this is what the transcript

558
00:17:41,760 --> 00:17:45,600
predicate is useful for the last

559
00:17:44,080 --> 00:17:48,399
generalization will make

560
00:17:45,600 --> 00:17:50,480
is intended to simplify the analysis of

561
00:17:48,400 --> 00:17:51,679
standards for real-world protocols like

562
00:17:50,480 --> 00:17:54,320
tls

563
00:17:51,679 --> 00:17:55,600
now tls specifies a complex protocol and

564
00:17:54,320 --> 00:17:57,520
most of the details

565
00:17:55,600 --> 00:17:59,600
are not necessarily relevant to what we

566
00:17:57,520 --> 00:18:01,200
might want to prove about it

567
00:17:59,600 --> 00:18:03,360
the partially specified protocol

568
00:18:01,200 --> 00:18:05,200
methodology of rogue away and staggers

569
00:18:03,360 --> 00:18:07,360
provides a nice way to account for these

570
00:18:05,200 --> 00:18:08,400
details without needing to specify them

571
00:18:07,360 --> 00:18:09,760
exhaustively

572
00:18:08,400 --> 00:18:12,559
and we're going to incorporate their

573
00:18:09,760 --> 00:18:14,960
core idea into our framework

574
00:18:12,559 --> 00:18:17,678
their strategy is to divide a protocol

575
00:18:14,960 --> 00:18:19,840
specification into two components

576
00:18:17,679 --> 00:18:21,200
the protocol core which formalizes the

577
00:18:19,840 --> 00:18:23,439
elements of the standard that

578
00:18:21,200 --> 00:18:24,960
are essential to the security goal and

579
00:18:23,440 --> 00:18:27,840
the specification details

580
00:18:24,960 --> 00:18:29,840
which captures everything else the

581
00:18:27,840 --> 00:18:30,399
protocol core is defined in terms of

582
00:18:29,840 --> 00:18:33,600
calls

583
00:18:30,400 --> 00:18:35,280
to a specification details oracle

584
00:18:33,600 --> 00:18:37,280
which in the security experiment is

585
00:18:35,280 --> 00:18:39,440
answered by the adversary

586
00:18:37,280 --> 00:18:42,080
that means the adversary participates in

587
00:18:39,440 --> 00:18:44,240
the computation of the protocol this

588
00:18:42,080 --> 00:18:44,879
formalizes an unusually strong attack

589
00:18:44,240 --> 00:18:47,039
model

590
00:18:44,880 --> 00:18:48,240
but one that yields a rigorous treatment

591
00:18:47,039 --> 00:18:50,480
of the standard itself

592
00:18:48,240 --> 00:18:52,640
without exhaustively specifying all of

593
00:18:50,480 --> 00:18:54,799
the details

594
00:18:52,640 --> 00:18:56,640
okay let's define a notion of

595
00:18:54,799 --> 00:18:58,160
indifferentiability that's suitable for

596
00:18:56,640 --> 00:19:00,080
this experiment

597
00:18:58,160 --> 00:19:01,840
remember that what we're interested in

598
00:19:00,080 --> 00:19:02,799
is an adversary's advantage in

599
00:19:01,840 --> 00:19:05,840
differentiating

600
00:19:02,799 --> 00:19:07,200
some real system x from some reference

601
00:19:05,840 --> 00:19:09,600
system y

602
00:19:07,200 --> 00:19:10,480
as usual d's access to the second

603
00:19:09,600 --> 00:19:12,959
interface of y

604
00:19:10,480 --> 00:19:14,640
is mediated by a simulator s and

605
00:19:12,960 --> 00:19:17,039
likewise d's access to the

606
00:19:14,640 --> 00:19:18,480
to the resources will be also mediated

607
00:19:17,039 --> 00:19:20,640
by the simulator

608
00:19:18,480 --> 00:19:21,520
and this means that the resources might

609
00:19:20,640 --> 00:19:23,280
also change

610
00:19:21,520 --> 00:19:25,440
from the reference experiment to the

611
00:19:23,280 --> 00:19:26,879
real one and this is will be a useful

612
00:19:25,440 --> 00:19:29,679
feature of the model

613
00:19:26,880 --> 00:19:30,160
and in particular for our case study we

614
00:19:29,679 --> 00:19:32,799
say that

615
00:19:30,160 --> 00:19:34,400
x with shared resources r is psi

616
00:19:32,799 --> 00:19:37,120
indifferentiable from y

617
00:19:34,400 --> 00:19:37,760
with shared resources q if for every

618
00:19:37,120 --> 00:19:39,840
efficient

619
00:19:37,760 --> 00:19:41,360
side differentiator d there exists an

620
00:19:39,840 --> 00:19:44,000
efficient simulator s

621
00:19:41,360 --> 00:19:45,918
such that d can't differentiate the real

622
00:19:44,000 --> 00:19:48,640
experiment from the reference experiment

623
00:19:45,919 --> 00:19:50,320
except with perhaps small probability

624
00:19:48,640 --> 00:19:50,640
for this generalized notion which we'll

625
00:19:50,320 --> 00:19:52,720
call

626
00:19:50,640 --> 00:19:54,480
shared resource indifferentiability it's

627
00:19:52,720 --> 00:19:55,520
easy to prove an analog of the lemma

628
00:19:54,480 --> 00:19:59,039
that we had before

629
00:19:55,520 --> 00:19:59,600
which says that if the real system x

630
00:19:59,039 --> 00:20:01,360
with r

631
00:19:59,600 --> 00:20:03,120
is psi indifferentiable from the

632
00:20:01,360 --> 00:20:05,439
reference system y with q

633
00:20:03,120 --> 00:20:07,280
then breaking x with r is essentially as

634
00:20:05,440 --> 00:20:09,840
hard as breaking y with q

635
00:20:07,280 --> 00:20:12,080
in the sense formalized by any game g

636
00:20:09,840 --> 00:20:13,760
and transcript predicate psi

637
00:20:12,080 --> 00:20:16,320
so that's a bit of a mouthful let me

638
00:20:13,760 --> 00:20:18,559
quickly summarize what's going on

639
00:20:16,320 --> 00:20:19,520
the translation framework is basically a

640
00:20:18,559 --> 00:20:21,678
security model

641
00:20:19,520 --> 00:20:22,720
that allows us to express a wide range

642
00:20:21,679 --> 00:20:25,200
of security goals

643
00:20:22,720 --> 00:20:27,440
for a wide range of systems and for this

644
00:20:25,200 --> 00:20:28,799
model we've defined a generalized notion

645
00:20:27,440 --> 00:20:30,240
of indifferentiability

646
00:20:28,799 --> 00:20:31,840
called shared resource in

647
00:20:30,240 --> 00:20:33,600
differentiability that

648
00:20:31,840 --> 00:20:35,120
suffices to show that a given

649
00:20:33,600 --> 00:20:38,320
translation is secure

650
00:20:35,120 --> 00:20:40,320
and without resorting to a fresh proof

651
00:20:38,320 --> 00:20:42,320
now there's much more to the translation

652
00:20:40,320 --> 00:20:44,320
framework than i have time to get into

653
00:20:42,320 --> 00:20:47,120
so i'd encourage you to check out our

654
00:20:44,320 --> 00:20:49,360
paper if you'd like to learn more

655
00:20:47,120 --> 00:20:50,158
in the meantime in the last few minutes

656
00:20:49,360 --> 00:20:52,000
i have left

657
00:20:50,159 --> 00:20:54,880
let me turn back to our case study of

658
00:20:52,000 --> 00:20:56,720
designing a pig extension for tls

659
00:20:54,880 --> 00:20:58,720
so what we did specifically in this

660
00:20:56,720 --> 00:20:59,600
paper is show how to securely

661
00:20:58,720 --> 00:21:02,159
instantiate

662
00:20:59,600 --> 00:21:04,799
the tls extension we discussed earlier

663
00:21:02,159 --> 00:21:08,400
with a particular peg protocol

664
00:21:04,799 --> 00:21:10,960
in that protocol is spk2 first proposed

665
00:21:08,400 --> 00:21:14,080
and analyzed by abdallah and poincheval

666
00:21:10,960 --> 00:21:16,480
back in 2005. now s pic2

667
00:21:14,080 --> 00:21:17,360
is an exceptionally simple scheme making

668
00:21:16,480 --> 00:21:20,080
it i think

669
00:21:17,360 --> 00:21:22,158
well suited for this application still

670
00:21:20,080 --> 00:21:24,720
in translating it into the extension it

671
00:21:22,159 --> 00:21:27,520
was useful to make some changes to it

672
00:21:24,720 --> 00:21:28,240
in particular we changed key derivation

673
00:21:27,520 --> 00:21:30,240
slightly

674
00:21:28,240 --> 00:21:32,159
in order to ease the task of integrating

675
00:21:30,240 --> 00:21:32,880
the shared secret into the tls key

676
00:21:32,159 --> 00:21:34,960
schedule

677
00:21:32,880 --> 00:21:36,720
and we also change the manner in which

678
00:21:34,960 --> 00:21:38,320
the public parameters are chosen

679
00:21:36,720 --> 00:21:40,559
again i don't have time to go into the

680
00:21:38,320 --> 00:21:42,320
details so please check out the paper

681
00:21:40,559 --> 00:21:44,158
now what we show is that breaking the

682
00:21:42,320 --> 00:21:46,799
extension is at least as hard as

683
00:21:44,159 --> 00:21:48,640
breaking espec to itself

684
00:21:46,799 --> 00:21:50,400
this is true for any security goal that

685
00:21:48,640 --> 00:21:51,120
can be formalized as a game in our

686
00:21:50,400 --> 00:21:53,039
experiment

687
00:21:51,120 --> 00:21:54,559
and it's true in particular for the

688
00:21:53,039 --> 00:21:56,559
security goal targeted

689
00:21:54,559 --> 00:21:58,158
by abdallah and poincheval in their

690
00:21:56,559 --> 00:21:59,520
original analysis

691
00:21:58,159 --> 00:22:02,000
we need only to assume that the

692
00:21:59,520 --> 00:22:05,039
adversary doesn't reveal ephemeral keys

693
00:22:02,000 --> 00:22:05,760
as do abdullah and poincheval so our

694
00:22:05,039 --> 00:22:08,320
strategy

695
00:22:05,760 --> 00:22:09,120
is to prove that the execution of the

696
00:22:08,320 --> 00:22:11,439
extension

697
00:22:09,120 --> 00:22:13,439
is indifferentiable from the execution

698
00:22:11,440 --> 00:22:15,520
of the original protocol

699
00:22:13,440 --> 00:22:16,960
and the proof is quite interesting but

700
00:22:15,520 --> 00:22:17,760
unfortunately i don't have time for the

701
00:22:16,960 --> 00:22:20,400
details

702
00:22:17,760 --> 00:22:22,320
so let me just tell you about the the

703
00:22:20,400 --> 00:22:24,320
the most interesting part

704
00:22:22,320 --> 00:22:25,678
it was really dealing with the details

705
00:22:24,320 --> 00:22:27,760
of tls so

706
00:22:25,679 --> 00:22:29,440
we formalized the extension as a

707
00:22:27,760 --> 00:22:32,000
partially specified protocol

708
00:22:29,440 --> 00:22:34,000
which allows us to easily handle most of

709
00:22:32,000 --> 00:22:36,240
the specification details without

710
00:22:34,000 --> 00:22:38,640
needing to specify them exhaustively

711
00:22:36,240 --> 00:22:40,000
but one part one one part we have to

712
00:22:38,640 --> 00:22:42,240
account for explicitly

713
00:22:40,000 --> 00:22:44,640
is derivation of the keys that are used

714
00:22:42,240 --> 00:22:47,200
to compute the confirmation messages

715
00:22:44,640 --> 00:22:48,480
simulating this computation in with our

716
00:22:47,200 --> 00:22:50,400
using our simulator

717
00:22:48,480 --> 00:22:52,000
results in a modest loss of concrete

718
00:22:50,400 --> 00:22:54,400
security

719
00:22:52,000 --> 00:22:56,400
so let me just wrap this up the provable

720
00:22:54,400 --> 00:22:58,320
security methodology has profoundly

721
00:22:56,400 --> 00:23:00,400
shaped the practice of cryptography

722
00:22:58,320 --> 00:23:02,559
so much so that a proof is often a

723
00:23:00,400 --> 00:23:03,600
prerequisite to standardization of a

724
00:23:02,559 --> 00:23:06,080
protocol

725
00:23:03,600 --> 00:23:07,760
yet this process of standardization can

726
00:23:06,080 --> 00:23:09,678
create discrepancies between the real

727
00:23:07,760 --> 00:23:11,760
system and its formal specification

728
00:23:09,679 --> 00:23:13,360
that result in a gap between what's

729
00:23:11,760 --> 00:23:14,960
known about the system

730
00:23:13,360 --> 00:23:17,678
and its reference and its real world

731
00:23:14,960 --> 00:23:19,200
security the translation framework

732
00:23:17,679 --> 00:23:21,280
allows a rigorous treatment of these

733
00:23:19,200 --> 00:23:22,400
discrepancies without resorting to a

734
00:23:21,280 --> 00:23:24,320
fresh proof

735
00:23:22,400 --> 00:23:26,320
particular to show that a translation is

736
00:23:24,320 --> 00:23:27,200
secure it suffices to prove that the

737
00:23:26,320 --> 00:23:29,520
real system

738
00:23:27,200 --> 00:23:31,440
is shared resource indifferentiable from

739
00:23:29,520 --> 00:23:33,440
the reference system

740
00:23:31,440 --> 00:23:35,760
now this approach can significantly

741
00:23:33,440 --> 00:23:38,080
reduce the analytical effort required to

742
00:23:35,760 --> 00:23:41,440
evaluate the impact of translation

743
00:23:38,080 --> 00:23:43,439
as we demonstrate with our case study

744
00:23:41,440 --> 00:23:45,559
well that's it thanks for listening and

745
00:23:43,440 --> 00:23:48,559
i hope you enjoy the rest of the virtual

746
00:23:45,559 --> 00:23:48,559
conference

