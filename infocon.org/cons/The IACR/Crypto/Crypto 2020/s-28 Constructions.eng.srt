1
00:00:00,080 --> 00:00:05,680
in one second ah there it goes okay yes

2
00:00:03,040 --> 00:00:07,680
now you're ready to go great so i guess

3
00:00:05,680 --> 00:00:08,320
uh welcome everyone to the construction

4
00:00:07,680 --> 00:00:10,800
section

5
00:00:08,320 --> 00:00:12,719
so this section will have six talks so

6
00:00:10,800 --> 00:00:14,320
well you will do the usual business so

7
00:00:12,719 --> 00:00:14,639
five minutes for the talk five minutes

8
00:00:14,320 --> 00:00:16,480
for

9
00:00:14,639 --> 00:00:19,039
questions if you have questions please

10
00:00:16,480 --> 00:00:22,560
feel free to post either on uh

11
00:00:19,039 --> 00:00:24,320
zoom chat or via on zulip so both me and

12
00:00:22,560 --> 00:00:26,640
mariana my co-host

13
00:00:24,320 --> 00:00:27,359
for this session will be uh we'll be

14
00:00:26,640 --> 00:00:29,439
monitoring

15
00:00:27,359 --> 00:00:30,960
uh for questions so without further ado

16
00:00:29,439 --> 00:00:32,719
let's begin with the first talk

17
00:00:30,960 --> 00:00:35,040
so the first talk in this section will

18
00:00:32,719 --> 00:00:36,960
be new techniques for trader tracing

19
00:00:35,040 --> 00:00:38,800
size n to the one third and more from

20
00:00:36,960 --> 00:00:41,360
parents by mark zandry and mark will

21
00:00:38,800 --> 00:00:41,360
give the talk

22
00:00:41,440 --> 00:00:48,320
thank you for the introduction uh

23
00:00:44,559 --> 00:00:51,120
right so what is trader tracing the

24
00:00:48,320 --> 00:00:51,600
setting is we have a content distributor

25
00:00:51,120 --> 00:00:54,879
who

26
00:00:51,600 --> 00:00:56,640
is uh sending an encrypted broadcast to

27
00:00:54,879 --> 00:00:59,358
a bunch of users and we're worried

28
00:00:56,640 --> 00:01:00,640
that some of the users will take their

29
00:00:59,359 --> 00:01:04,159
secret key

30
00:01:00,640 --> 00:01:05,920
and release it uh publicly or sell it to

31
00:01:04,159 --> 00:01:09,520
a friend or whatever

32
00:01:05,920 --> 00:01:12,159
and the the goal is to if

33
00:01:09,520 --> 00:01:12,960
if the content industry ever finds such

34
00:01:12,159 --> 00:01:14,960
a

35
00:01:12,960 --> 00:01:16,640
leak secret key to identify the trader

36
00:01:14,960 --> 00:01:18,798
and we want to do this even if the

37
00:01:16,640 --> 00:01:20,400
secret key is embedded in a decoder

38
00:01:18,799 --> 00:01:21,920
program or actually even a physical

39
00:01:20,400 --> 00:01:24,000
decoder device

40
00:01:21,920 --> 00:01:25,680
even if arbitrarily many users collude

41
00:01:24,000 --> 00:01:28,000
to build the coder device

42
00:01:25,680 --> 00:01:30,320
and even if the decoder fails most of

43
00:01:28,000 --> 00:01:32,799
the time

44
00:01:30,320 --> 00:01:34,798
the main objective in trader tracing has

45
00:01:32,799 --> 00:01:37,520
been to

46
00:01:34,799 --> 00:01:38,400
achieve trader tracing with the best

47
00:01:37,520 --> 00:01:40,399
possible

48
00:01:38,400 --> 00:01:42,079
parameter sizes in terms of the number

49
00:01:40,400 --> 00:01:44,479
of users

50
00:01:42,079 --> 00:01:45,919
so the relevant parameter sizes are the

51
00:01:44,479 --> 00:01:47,920
public key size

52
00:01:45,920 --> 00:01:50,240
the secret key size and the cipher text

53
00:01:47,920 --> 00:01:53,360
size

54
00:01:50,240 --> 00:01:55,119
what's known is well there's some

55
00:01:53,360 --> 00:01:56,240
combinatorial constructions just based

56
00:01:55,119 --> 00:01:58,079
on generic public

57
00:01:56,240 --> 00:02:00,000
encryption or you can do a little better

58
00:01:58,079 --> 00:02:01,279
based on identity-based encryption

59
00:02:00,000 --> 00:02:03,040
uh there's a trivial construction where

60
00:02:01,280 --> 00:02:04,560
you just encrypt every user separately

61
00:02:03,040 --> 00:02:07,759
this has linear size

62
00:02:04,560 --> 00:02:09,039
ciphertext and public keys and then

63
00:02:07,759 --> 00:02:10,720
there was an improvement

64
00:02:09,038 --> 00:02:12,559
um using something called fingerprinting

65
00:02:10,720 --> 00:02:14,239
codes which achieves constant size cyber

66
00:02:12,560 --> 00:02:17,680
text but it's the cost of

67
00:02:14,239 --> 00:02:20,840
very large public keys and secret keys

68
00:02:17,680 --> 00:02:22,080
and then there are a number of algebraic

69
00:02:20,840 --> 00:02:25,040
constructions

70
00:02:22,080 --> 00:02:25,760
uh the maybe the most relevant for today

71
00:02:25,040 --> 00:02:27,200
is the

72
00:02:25,760 --> 00:02:29,040
pairings based construction of bonane

73
00:02:27,200 --> 00:02:29,839
sci high waters which achieves square

74
00:02:29,040 --> 00:02:33,599
root and

75
00:02:29,840 --> 00:02:35,200
public keys and cipher text

76
00:02:33,599 --> 00:02:37,518
and then there were some more recent

77
00:02:35,200 --> 00:02:40,000
constructions using other

78
00:02:37,519 --> 00:02:42,080
algebraic tools that achieve all

79
00:02:40,000 --> 00:02:44,239
parameters constantly

80
00:02:42,080 --> 00:02:46,640
in this talk i'll focus mostly on

81
00:02:44,239 --> 00:02:49,519
pairings and weaker objects

82
00:02:46,640 --> 00:02:51,518
and in this work what we do is we

83
00:02:49,519 --> 00:02:52,560
develop a handful of new techniques for

84
00:02:51,519 --> 00:02:54,319
trader tracing that

85
00:02:52,560 --> 00:02:56,800
gives new parameter size trade-offs for

86
00:02:54,319 --> 00:02:59,518
pairings and other primitives

87
00:02:56,800 --> 00:03:00,560
for pairings we achieve a variety of

88
00:02:59,519 --> 00:03:03,040
parameter sizes

89
00:03:00,560 --> 00:03:04,959
in the setting where the product of the

90
00:03:03,040 --> 00:03:06,079
public key secret key in cyber text size

91
00:03:04,959 --> 00:03:09,200
is equal to

92
00:03:06,080 --> 00:03:12,319
n uh so the benefit and water scheme

93
00:03:09,200 --> 00:03:13,280
uh lies in this space as well as the

94
00:03:12,319 --> 00:03:15,359
trivial scheme

95
00:03:13,280 --> 00:03:16,400
when instantiated from ibe and that was

96
00:03:15,360 --> 00:03:18,239
basically it

97
00:03:16,400 --> 00:03:20,560
and what we do in this work is we we

98
00:03:18,239 --> 00:03:23,440
fill in this uh space a lot more

99
00:03:20,560 --> 00:03:23,840
perhaps the most interesting points here

100
00:03:23,440 --> 00:03:27,200
are

101
00:03:23,840 --> 00:03:28,879
the the spot in the center where all

102
00:03:27,200 --> 00:03:31,359
public key secret key and cyber text

103
00:03:28,879 --> 00:03:34,079
size are cube root n

104
00:03:31,360 --> 00:03:35,680
and on the bottom left hand corner where

105
00:03:34,080 --> 00:03:36,720
we get to constant size public keys and

106
00:03:35,680 --> 00:03:40,080
cipher text

107
00:03:36,720 --> 00:03:43,120
albeit linear size secret keys

108
00:03:40,080 --> 00:03:44,879
we give a few other results we consider

109
00:03:43,120 --> 00:03:46,879
the case of trader tracing when combined

110
00:03:44,879 --> 00:03:49,040
with a broadcast functionality

111
00:03:46,879 --> 00:03:50,640
and in particular we give the first

112
00:03:49,040 --> 00:03:53,439
construction from standard assumptions

113
00:03:50,640 --> 00:03:56,480
with constant size ciphertext

114
00:03:53,439 --> 00:03:57,280
and we also look at the combinatorial

115
00:03:56,480 --> 00:03:58,959
setting

116
00:03:57,280 --> 00:04:00,480
based on public key encryption or

117
00:03:58,959 --> 00:04:03,360
identity-based encryption

118
00:04:00,480 --> 00:04:04,079
and we show how to achieve um all

119
00:04:03,360 --> 00:04:06,239
parameters

120
00:04:04,080 --> 00:04:09,599
sub-linear namely and two-thirds based

121
00:04:06,239 --> 00:04:11,599
on generic identity-based encryption

122
00:04:09,599 --> 00:04:13,518
uh so we achieve these results through a

123
00:04:11,599 --> 00:04:16,399
number of new techniques

124
00:04:13,519 --> 00:04:17,120
there's this concept called threshold

125
00:04:16,399 --> 00:04:19,120
tracing

126
00:04:17,120 --> 00:04:21,120
where you can only trace decoders that

127
00:04:19,120 --> 00:04:23,759
work most of the time and we show how to

128
00:04:21,120 --> 00:04:26,160
actually generically remove

129
00:04:23,759 --> 00:04:27,040
such a limitation without asymptotically

130
00:04:26,160 --> 00:04:30,160
changing the

131
00:04:27,040 --> 00:04:32,880
parameter sizes we show a general

132
00:04:30,160 --> 00:04:33,280
technique for trading off between public

133
00:04:32,880 --> 00:04:36,639
key

134
00:04:33,280 --> 00:04:39,280
and secret key sizes by reducing those

135
00:04:36,639 --> 00:04:40,639
at the cost of increasing ciphertext

136
00:04:39,280 --> 00:04:42,719
we consider something called risky

137
00:04:40,639 --> 00:04:44,720
tracing show how to root

138
00:04:42,720 --> 00:04:46,960
which is another weakening of trader

139
00:04:44,720 --> 00:04:49,840
tracing we show how to eliminate

140
00:04:46,960 --> 00:04:51,599
this weakening at the cost of larger or

141
00:04:49,840 --> 00:04:53,599
secret keys

142
00:04:51,600 --> 00:04:55,199
we show a way to convert something

143
00:04:53,600 --> 00:04:57,520
called threshold broadcast

144
00:04:55,199 --> 00:04:59,360
into trader tracing and we give a number

145
00:04:57,520 --> 00:05:01,120
of new algebraic instantiations from

146
00:04:59,360 --> 00:05:05,120
parents

147
00:05:01,120 --> 00:05:05,120
so that's the end of my my summary

148
00:05:06,880 --> 00:05:11,440
great thanks mark so do we have any

149
00:05:09,919 --> 00:05:13,520
questions so if you have questions

150
00:05:11,440 --> 00:05:16,320
again please type either in the zoom

151
00:05:13,520 --> 00:05:17,840
chat or on zulip

152
00:05:16,320 --> 00:05:19,440
so i guess i can start that with a

153
00:05:17,840 --> 00:05:21,039
question so

154
00:05:19,440 --> 00:05:22,880
do your techniques generalized to

155
00:05:21,039 --> 00:05:25,280
settings like broadcast and trace

156
00:05:22,880 --> 00:05:25,919
where we both have sublinear ciphertexts

157
00:05:25,280 --> 00:05:27,840
as well

158
00:05:25,919 --> 00:05:29,680
as the trade and have the trader tracing

159
00:05:27,840 --> 00:05:33,119
functionality

160
00:05:29,680 --> 00:05:36,160
yes they uh they all

161
00:05:33,120 --> 00:05:38,400
will general all the

162
00:05:36,160 --> 00:05:39,520
so the you know the first four on this

163
00:05:38,400 --> 00:05:42,638
page are all

164
00:05:39,520 --> 00:05:43,359
generic and they they um also apply to

165
00:05:42,639 --> 00:05:45,440
the

166
00:05:43,360 --> 00:05:47,039
broadcast and trace setting and this is

167
00:05:45,440 --> 00:05:48,000
how we get our broadcast and trace

168
00:05:47,039 --> 00:05:49,759
results

169
00:05:48,000 --> 00:05:51,120
uh the new algebraic instantiations it

170
00:05:49,759 --> 00:05:53,680
depends on sort of what's

171
00:05:51,120 --> 00:05:55,280
uh you know some of the instantiations

172
00:05:53,680 --> 00:05:56,160
will achieve the broadcast functionality

173
00:05:55,280 --> 00:05:59,039
and others

174
00:05:56,160 --> 00:05:59,840
and others won't cool so how do the

175
00:05:59,039 --> 00:06:01,680
parameters

176
00:05:59,840 --> 00:06:03,520
compare in term with that with respect

177
00:06:01,680 --> 00:06:04,960
to existing broadcast and trace schemes

178
00:06:03,520 --> 00:06:08,880
say from pairings

179
00:06:04,960 --> 00:06:12,318
let me let me go back um

180
00:06:08,880 --> 00:06:13,360
so um basically we so if you if you're

181
00:06:12,319 --> 00:06:15,520
willing to assume

182
00:06:13,360 --> 00:06:17,440
things like obfuscation or slightly

183
00:06:15,520 --> 00:06:18,799
weaker primitives but nonetheless uh

184
00:06:17,440 --> 00:06:21,039
non-standard

185
00:06:18,800 --> 00:06:22,720
you can get constant size parameters for

186
00:06:21,039 --> 00:06:25,599
broadcasting trees

187
00:06:22,720 --> 00:06:26,639
if you are focusing on standard

188
00:06:25,600 --> 00:06:28,880
assumptions

189
00:06:26,639 --> 00:06:30,160
uh there's the old work by bonnet and

190
00:06:28,880 --> 00:06:31,840
waters where

191
00:06:30,160 --> 00:06:33,520
just based on pairings you can get n to

192
00:06:31,840 --> 00:06:34,719
the one half for all three parameter

193
00:06:33,520 --> 00:06:38,400
sizes

194
00:06:34,720 --> 00:06:40,800
um we basically improve that down by

195
00:06:38,400 --> 00:06:42,159
getting constant size secret keys um

196
00:06:40,800 --> 00:06:45,520
while maintaining the end of one half

197
00:06:42,160 --> 00:06:48,080
public keys and cipher text

198
00:06:45,520 --> 00:06:49,039
and then there was a more recent work by

199
00:06:48,080 --> 00:06:52,240
goyadol

200
00:06:49,039 --> 00:06:54,880
that combines pairings with lwe to get

201
00:06:52,240 --> 00:06:56,880
the smaller ciphertext they were unable

202
00:06:54,880 --> 00:06:58,880
to get constant size that they could get

203
00:06:56,880 --> 00:07:00,560
any arbitrarily small polynomial five

204
00:06:58,880 --> 00:07:02,880
ciphertext

205
00:07:00,560 --> 00:07:03,759
but at the cost of at least linear

206
00:07:02,880 --> 00:07:06,880
secret keys

207
00:07:03,759 --> 00:07:08,240
and um and

208
00:07:06,880 --> 00:07:10,560
sorry it's cost of at least linear

209
00:07:08,240 --> 00:07:12,000
public keys and quadratic secret keys

210
00:07:10,560 --> 00:07:14,960
and what we're able to do is go all the

211
00:07:12,000 --> 00:07:17,360
way down to constant size ciphertext

212
00:07:14,960 --> 00:07:20,080
and keep the public keys and secret keys

213
00:07:17,360 --> 00:07:20,080
the most on here

214
00:07:20,400 --> 00:07:24,080
great thanks

215
00:07:25,039 --> 00:07:31,840
so do we have other questions for mark

216
00:07:41,599 --> 00:07:47,919
um so do we have a an author

217
00:07:45,039 --> 00:07:50,240
to present the second paper uh which is

218
00:07:47,919 --> 00:07:54,000
new constructions of hinting prg's

219
00:07:50,240 --> 00:07:54,000
one-way functions with encryption and

220
00:07:56,840 --> 00:08:02,799
more

221
00:07:58,479 --> 00:08:05,360
any any volunteer to present the paper

222
00:08:02,800 --> 00:08:07,440
oh oh we do have an author i we've been

223
00:08:05,360 --> 00:08:08,879
asking for the author to step in for a

224
00:08:07,440 --> 00:08:13,199
while

225
00:08:08,879 --> 00:08:16,240
okay so uh this is our

226
00:08:13,199 --> 00:08:18,960
second paper of the session

227
00:08:16,240 --> 00:08:20,240
uh and i guess the author presenting the

228
00:08:18,960 --> 00:08:24,159
paper is

229
00:08:20,240 --> 00:08:26,400
narayana uh the floor is yours

230
00:08:24,160 --> 00:08:28,080
thanks for the introduction hi my name

231
00:08:26,400 --> 00:08:29,758
is satya today i'm going to discuss

232
00:08:28,080 --> 00:08:30,878
about our paper on new constructions of

233
00:08:29,759 --> 00:08:32,479
hinting technologies

234
00:08:30,879 --> 00:08:34,399
one way functions with encryption and

235
00:08:32,479 --> 00:08:34,800
more this is a joint work with bishop

236
00:08:34,399 --> 00:08:36,880
girl

237
00:08:34,799 --> 00:08:38,000
and brainwaters let's start with the

238
00:08:36,880 --> 00:08:40,799
brief history

239
00:08:38,000 --> 00:08:42,159
way back in 2017 joe and others came up

240
00:08:40,799 --> 00:08:43,598
with this beautiful primitive called

241
00:08:42,159 --> 00:08:45,200
laconic obliques transfer

242
00:08:43,599 --> 00:08:46,800
to make oblivious transfer more

243
00:08:45,200 --> 00:08:48,880
communication efficient

244
00:08:46,800 --> 00:08:50,719
later on uh they used really cool

245
00:08:48,880 --> 00:08:52,480
techniques in this laconic coty paper

246
00:08:50,720 --> 00:08:53,680
later on darting and gunk abstracted out

247
00:08:52,480 --> 00:08:54,080
these techniques into a beautiful

248
00:08:53,680 --> 00:08:57,040
primitive

249
00:08:54,080 --> 00:08:58,560
called chameleon hash with encryption

250
00:08:57,040 --> 00:08:59,120
later on this parameter and its variants

251
00:08:58,560 --> 00:09:01,359
form

252
00:08:59,120 --> 00:09:03,600
tons of applications like identity-based

253
00:09:01,360 --> 00:09:05,680
encryption registration based encryption

254
00:09:03,600 --> 00:09:08,160
trapdoor functions designated wildfire

255
00:09:05,680 --> 00:09:11,120
zero knowledge cpa to cca transformation

256
00:09:08,160 --> 00:09:12,640
trapdoor hash functions and so on that's

257
00:09:11,120 --> 00:09:14,560
a ton of applications

258
00:09:12,640 --> 00:09:16,000
as it turns out all these applications

259
00:09:14,560 --> 00:09:17,040
are based on a very few related

260
00:09:16,000 --> 00:09:18,720
primitives such as

261
00:09:17,040 --> 00:09:21,760
one-way function with encryption hash

262
00:09:18,720 --> 00:09:23,279
with encryption hinting prgs and so on

263
00:09:21,760 --> 00:09:25,040
these parameters are syntactically

264
00:09:23,279 --> 00:09:27,839
predicted to each other and some of them

265
00:09:25,040 --> 00:09:29,040
are even known to imply each other

266
00:09:27,839 --> 00:09:30,880
and since these primitives are so

267
00:09:29,040 --> 00:09:33,040
powerful like we certainly need

268
00:09:30,880 --> 00:09:34,240
more and more uh efficient schemes to

269
00:09:33,040 --> 00:09:35,599
build these primitives

270
00:09:34,240 --> 00:09:37,920
and that's exactly what we do in this

271
00:09:35,600 --> 00:09:39,120
work we made better primitives for

272
00:09:37,920 --> 00:09:40,800
better constructions for

273
00:09:39,120 --> 00:09:42,959
one way function with encryption and

274
00:09:40,800 --> 00:09:44,640
hinting prgs

275
00:09:42,959 --> 00:09:46,479
even though we concentrate only on these

276
00:09:44,640 --> 00:09:47,519
two uh primitives we believe our

277
00:09:46,480 --> 00:09:51,519
techniques are helpful

278
00:09:47,519 --> 00:09:52,640
to build even other parameters as well

279
00:09:51,519 --> 00:09:54,880
let's see what one-way function of

280
00:09:52,640 --> 00:09:56,319
encryption actually is

281
00:09:54,880 --> 00:09:57,920
as the title says there is a one-way

282
00:09:56,320 --> 00:09:58,399
function component to it so there is a

283
00:09:57,920 --> 00:10:00,560
function

284
00:09:58,399 --> 00:10:02,640
f that takes input x and outputs a value

285
00:10:00,560 --> 00:10:03,439
y and there is an encryption component

286
00:10:02,640 --> 00:10:05,040
as well

287
00:10:03,440 --> 00:10:06,480
so there is an encrypter that encrypts a

288
00:10:05,040 --> 00:10:08,880
message and there is a decrypter that

289
00:10:06,480 --> 00:10:10,240
decrypts the ciphertext

290
00:10:08,880 --> 00:10:12,560
and but what are keys to these

291
00:10:10,240 --> 00:10:13,920
algorithms the keys actually come from

292
00:10:12,560 --> 00:10:16,160
the one-way function part

293
00:10:13,920 --> 00:10:18,479
here y acts as an encryption key and x

294
00:10:16,160 --> 00:10:20,079
acts as a decryption key

295
00:10:18,480 --> 00:10:22,480
in addition to that encryption algorithm

296
00:10:20,079 --> 00:10:23,439
also takes index i and a bit b also

297
00:10:22,480 --> 00:10:25,120
input

298
00:10:23,440 --> 00:10:27,680
and now the decryption algorithm works

299
00:10:25,120 --> 00:10:30,720
if x is a pre image of y

300
00:10:27,680 --> 00:10:33,040
and if either bit of x is equals to b

301
00:10:30,720 --> 00:10:34,640
so not every pre image of y works for

302
00:10:33,040 --> 00:10:36,880
decryption only specific pre-measures of

303
00:10:34,640 --> 00:10:39,120
y work

304
00:10:36,880 --> 00:10:40,079
for the security part first of all f has

305
00:10:39,120 --> 00:10:42,000
to be one way

306
00:10:40,079 --> 00:10:43,359
and secondly f has to be smooth which

307
00:10:42,000 --> 00:10:44,000
means if x is sample from a uniform

308
00:10:43,360 --> 00:10:45,600
distribution

309
00:10:44,000 --> 00:10:47,839
then the resulting y also should

310
00:10:45,600 --> 00:10:49,839
resemble uniform distribution

311
00:10:47,839 --> 00:10:51,120
for the security of encryption part if

312
00:10:49,839 --> 00:10:51,920
the adversary doesn't have the right

313
00:10:51,120 --> 00:10:55,360
decryption key

314
00:10:51,920 --> 00:10:55,360
then the ciphertex should look uniform

315
00:10:55,839 --> 00:10:59,360
dottinghenger came up with a beautiful

316
00:10:58,320 --> 00:11:02,240
construction of this

317
00:10:59,360 --> 00:11:03,600
one-way function encryption as well

318
00:11:02,240 --> 00:11:04,560
without going into further details of

319
00:11:03,600 --> 00:11:06,720
the construction

320
00:11:04,560 --> 00:11:08,640
uh all you need to know is if you want

321
00:11:06,720 --> 00:11:11,839
to encrypt a message with respect to

322
00:11:08,640 --> 00:11:13,439
index i bid b and randomness row

323
00:11:11,839 --> 00:11:15,040
the cipher test is going to contain

324
00:11:13,440 --> 00:11:16,560
these elements

325
00:11:15,040 --> 00:11:18,800
here n is the input and the one way

326
00:11:16,560 --> 00:11:20,560
function

327
00:11:18,800 --> 00:11:22,000
the ciphertext contains two and two n

328
00:11:20,560 --> 00:11:23,920
elements except for one block

329
00:11:22,000 --> 00:11:25,360
the block that is opposite to i comma b

330
00:11:23,920 --> 00:11:28,560
then i from a b index

331
00:11:25,360 --> 00:11:30,959
that was missing

332
00:11:28,560 --> 00:11:32,560
the security of the encryption scheme

333
00:11:30,959 --> 00:11:34,479
crucially relies on the fact that

334
00:11:32,560 --> 00:11:36,319
the cipher text is missing in one one

335
00:11:34,480 --> 00:11:38,560
block and that's why we call it as

336
00:11:36,320 --> 00:11:41,600
missing block framework

337
00:11:38,560 --> 00:11:42,800
remember this picture of a slide ago

338
00:11:41,600 --> 00:11:44,480
there are tons of applications in the

339
00:11:42,800 --> 00:11:46,399
literature and all of them are based on

340
00:11:44,480 --> 00:11:48,079
a very few related primitives

341
00:11:46,399 --> 00:11:49,760
as it turns out the constructions of all

342
00:11:48,079 --> 00:11:50,560
these primitives also rely on missing

343
00:11:49,760 --> 00:11:53,760
block framework

344
00:11:50,560 --> 00:11:55,518
so that's a very powerful technique

345
00:11:53,760 --> 00:11:57,200
but the problem here is this technique

346
00:11:55,519 --> 00:11:58,720
is listening in long ciphertex

347
00:11:57,200 --> 00:12:00,240
and if you use this one function

348
00:11:58,720 --> 00:12:01,600
encryption to uh

349
00:12:00,240 --> 00:12:04,000
build trapdoor functions then you're

350
00:12:01,600 --> 00:12:05,600
going to get long public keys

351
00:12:04,000 --> 00:12:07,040
it tends to look out for new techniques

352
00:12:05,600 --> 00:12:08,720
and new

353
00:12:07,040 --> 00:12:10,880
frameworks to build these primitives and

354
00:12:08,720 --> 00:12:11,519
that's why we introduced a new technique

355
00:12:10,880 --> 00:12:13,040
to

356
00:12:11,519 --> 00:12:16,000
build one-way function of encryption and

357
00:12:13,040 --> 00:12:19,279
we also extend the same technique to

358
00:12:16,000 --> 00:12:19,279
constructing hinting prgs

359
00:12:19,760 --> 00:12:22,880
now let's compare the efficiency of our

360
00:12:21,519 --> 00:12:24,880
work with that of previous works

361
00:12:22,880 --> 00:12:26,399
the previous work based on dating is

362
00:12:24,880 --> 00:12:27,920
dotting in ger which is based on ddh

363
00:12:26,399 --> 00:12:30,079
assumption

364
00:12:27,920 --> 00:12:31,279
that has the following time complexities

365
00:12:30,079 --> 00:12:32,560
our first

366
00:12:31,279 --> 00:12:34,320
construction is based on factoring

367
00:12:32,560 --> 00:12:36,160
assumption as you know we want to

368
00:12:34,320 --> 00:12:37,600
optimize

369
00:12:36,160 --> 00:12:38,719
encryption time and ciphertext size and

370
00:12:37,600 --> 00:12:40,639
we want to deviate from this missing

371
00:12:38,720 --> 00:12:42,639
block framework

372
00:12:40,639 --> 00:12:44,079
and so here are the time complexes rest

373
00:12:42,639 --> 00:12:45,279
of the complexes remaining the same our

374
00:12:44,079 --> 00:12:47,680
encryption time and ciphertext

375
00:12:45,279 --> 00:12:49,120
are asymptotically better and rest of

376
00:12:47,680 --> 00:12:50,638
the complexes are same

377
00:12:49,120 --> 00:12:53,279
we also extended the same techniques

378
00:12:50,639 --> 00:12:55,600
based on dvd h assumption which is some

379
00:12:53,279 --> 00:12:57,439
pairing based assumption

380
00:12:55,600 --> 00:12:59,279
even here we optimize encryption time

381
00:12:57,440 --> 00:12:59,920
and ciphertext size to be asymptotically

382
00:12:59,279 --> 00:13:02,800
better

383
00:12:59,920 --> 00:13:03,680
but the setup time one way function time

384
00:13:02,800 --> 00:13:05,199
and decryption time

385
00:13:03,680 --> 00:13:07,359
are actually words so there is some

386
00:13:05,200 --> 00:13:09,680
trade-off here even in factoring based

387
00:13:07,360 --> 00:13:11,600
assumption our

388
00:13:09,680 --> 00:13:13,199
group says this are bigger generally

389
00:13:11,600 --> 00:13:16,560
because rsm modulus is bigger

390
00:13:13,200 --> 00:13:16,560
so there is some trade-off there as well

391
00:13:17,279 --> 00:13:19,839
let's finally move on to our

392
00:13:18,480 --> 00:13:22,000
construction from factoring based

393
00:13:19,839 --> 00:13:23,440
assumption

394
00:13:22,000 --> 00:13:25,519
here the public parameters would consist

395
00:13:23,440 --> 00:13:26,720
of an rss modulus n which is a product

396
00:13:25,519 --> 00:13:28,800
of two large primes

397
00:13:26,720 --> 00:13:30,639
and it consists of a generator g which

398
00:13:28,800 --> 00:13:33,839
is randomly sampled from

399
00:13:30,639 --> 00:13:35,120
group z and star and it consists of two

400
00:13:33,839 --> 00:13:37,040
and random large primes

401
00:13:35,120 --> 00:13:39,360
where n is input length of one way

402
00:13:37,040 --> 00:13:39,360
function

403
00:13:39,920 --> 00:13:43,199
and uh if you want if you have input x

404
00:13:42,079 --> 00:13:46,239
and if you want to compute

405
00:13:43,199 --> 00:13:48,399
one way function on input x then from

406
00:13:46,240 --> 00:13:50,399
each column of this matrix you sample

407
00:13:48,399 --> 00:13:51,680
you take one element

408
00:13:50,399 --> 00:13:53,440
depending on the bits of x and you

409
00:13:51,680 --> 00:13:54,239
multiply them so that's product of e j

410
00:13:53,440 --> 00:13:56,959
xj

411
00:13:54,240 --> 00:13:57,440
and you raise it to generator g and

412
00:13:56,959 --> 00:14:00,880
that's

413
00:13:57,440 --> 00:14:03,040
the output value of one function

414
00:14:00,880 --> 00:14:05,279
and now if you want to encrypt a message

415
00:14:03,040 --> 00:14:07,839
with respect to encryption key y

416
00:14:05,279 --> 00:14:10,720
randomness 0 index i am big b and this

417
00:14:07,839 --> 00:14:12,720
is our soft text is going to look like

418
00:14:10,720 --> 00:14:14,560
remember earlier in the ddh construction

419
00:14:12,720 --> 00:14:17,040
we had these two n elements and

420
00:14:14,560 --> 00:14:18,079
we were missing in one block and here is

421
00:14:17,040 --> 00:14:20,160
exactly the opposite

422
00:14:18,079 --> 00:14:21,519
we only give out one block and miss out

423
00:14:20,160 --> 00:14:23,600
rest of the blocks

424
00:14:21,519 --> 00:14:24,800
and that's where our efficiency kicks in

425
00:14:23,600 --> 00:14:26,320
and that's where encryption time is

426
00:14:24,800 --> 00:14:28,160
lower and the ciphertext size is also

427
00:14:26,320 --> 00:14:31,120
better

428
00:14:28,160 --> 00:14:32,240
we also used really cool techniques uh

429
00:14:31,120 --> 00:14:33,600
in math theorems like

430
00:14:32,240 --> 00:14:36,000
prime number theorem for improving the

431
00:14:33,600 --> 00:14:38,560
security of this construction uh

432
00:14:36,000 --> 00:14:40,320
you can have more details in the paper

433
00:14:38,560 --> 00:14:42,719
let me finally conclude the talk

434
00:14:40,320 --> 00:14:44,639
in this uh talk we discussed about one

435
00:14:42,720 --> 00:14:46,079
function of encryption and uh

436
00:14:44,639 --> 00:14:47,519
we used we saw that the previous

437
00:14:46,079 --> 00:14:48,319
constructions are using missing block

438
00:14:47,519 --> 00:14:51,199
framework

439
00:14:48,320 --> 00:14:52,399
and we came up with some a bit some

440
00:14:51,199 --> 00:14:53,839
better framework for

441
00:14:52,399 --> 00:14:55,440
constructing one function encryption

442
00:14:53,839 --> 00:14:57,279
with shorter ciphertext cells

443
00:14:55,440 --> 00:14:58,800
and we also extend the same techniques

444
00:14:57,279 --> 00:15:00,480
for constructing hinting prgs with

445
00:14:58,800 --> 00:15:02,399
shorter public parameters

446
00:15:00,480 --> 00:15:04,160
we cover the polar schemes and evaluate

447
00:15:02,399 --> 00:15:06,320
the performance as well you can find the

448
00:15:04,160 --> 00:15:08,079
details in the paper

449
00:15:06,320 --> 00:15:09,600
uh for more details you can look at the

450
00:15:08,079 --> 00:15:13,359
print version of the paper and

451
00:15:09,600 --> 00:15:16,639
our youtube talk

452
00:15:13,360 --> 00:15:18,800
thank you uh so we have some questions

453
00:15:16,639 --> 00:15:20,800
the first question is from microsoft who

454
00:15:18,800 --> 00:15:24,000
is interested to know how wild

455
00:15:20,800 --> 00:15:26,560
is this dbdhi chai

456
00:15:24,000 --> 00:15:29,199
assumption is it the q type assumption

457
00:15:26,560 --> 00:15:30,719
is it interactive

458
00:15:29,199 --> 00:15:32,639
uh it's a q type assumption it's not

459
00:15:30,720 --> 00:15:34,720
interactive

460
00:15:32,639 --> 00:15:36,480
uh the assumption states that if you

461
00:15:34,720 --> 00:15:38,240
have g power alpha

462
00:15:36,480 --> 00:15:40,000
if you're given g power alpha g power

463
00:15:38,240 --> 00:15:41,360
alpha square g power alpha

464
00:15:40,000 --> 00:15:43,440
power and so on up to g power alpha

465
00:15:41,360 --> 00:15:45,680
power n then you cannot you will not be

466
00:15:43,440 --> 00:15:49,839
able to compute e of g comma g power

467
00:15:45,680 --> 00:15:49,839
one by alpha power one by alpha

468
00:15:51,279 --> 00:15:55,040
thank you um and this is another

469
00:15:54,480 --> 00:15:58,320
question

470
00:15:55,040 --> 00:16:01,519
from uh from the

471
00:15:58,320 --> 00:16:03,600
from british uh how is your views on

472
00:16:01,519 --> 00:16:04,639
using your techniques to build the same

473
00:16:03,600 --> 00:16:07,680
primitives from

474
00:16:04,639 --> 00:16:10,240
lpn or lw lwe

475
00:16:07,680 --> 00:16:10,239
assumptions

476
00:16:13,450 --> 00:16:16,599
[Music]

477
00:16:20,839 --> 00:16:24,959
um

478
00:16:22,079 --> 00:16:25,439
actually i don't know much about that

479
00:16:24,959 --> 00:16:28,479
okay

480
00:16:25,440 --> 00:16:31,600
that's i think that's that's okay

481
00:16:28,480 --> 00:16:35,120
sounds like uh interesting future work

482
00:16:31,600 --> 00:16:38,800
um any other questions

483
00:16:35,120 --> 00:16:38,800
do we have anything from the chat

484
00:16:39,920 --> 00:16:47,839
i don't see anymore okay

485
00:16:44,959 --> 00:16:49,599
thank you then we can move to the next

486
00:16:47,839 --> 00:16:53,519
talk

487
00:16:49,600 --> 00:16:54,000
great so uh our third speaker for this

488
00:16:53,519 --> 00:16:57,040
session

489
00:16:54,000 --> 00:16:58,880
or our third uh paper is going to be on

490
00:16:57,040 --> 00:17:00,560
adaptively secure

491
00:16:58,880 --> 00:17:03,279
constrained pseudorandom functions in

492
00:17:00,560 --> 00:17:06,399
the standard model by alex davidson

493
00:17:03,279 --> 00:17:08,959
katsumata ryomishimaki shioka yamada

494
00:17:06,400 --> 00:17:09,839
and tatashi yamakawa and takashi will be

495
00:17:08,959 --> 00:17:13,839
giving the talk

496
00:17:09,839 --> 00:17:16,879
the closers can you see the screen

497
00:17:13,839 --> 00:17:18,720
uh yep i think we're good so thank you

498
00:17:16,880 --> 00:17:21,120
for your introduction

499
00:17:18,720 --> 00:17:22,559
so i'm takashi so i will talk about

500
00:17:21,119 --> 00:17:24,479
adapt with your constraint synonym

501
00:17:22,559 --> 00:17:28,319
function understand the model

502
00:17:24,480 --> 00:17:29,600
okay so constraint prf cpr f is an

503
00:17:28,319 --> 00:17:32,879
extended version

504
00:17:29,600 --> 00:17:34,879
of the third random function in cprf

505
00:17:32,880 --> 00:17:36,720
when we are given the key k and the

506
00:17:34,880 --> 00:17:37,360
constraint c we can generate a

507
00:17:36,720 --> 00:17:40,480
constraint

508
00:17:37,360 --> 00:17:40,879
key denoted by k sub c which can be a

509
00:17:40,480 --> 00:17:43,440
verb

510
00:17:40,880 --> 00:17:44,400
which can be used to evaluate the plf on

511
00:17:43,440 --> 00:17:46,960
any input

512
00:17:44,400 --> 00:17:47,840
that satisfy the constraint c on the

513
00:17:46,960 --> 00:17:50,320
other hand

514
00:17:47,840 --> 00:17:51,280
even if we are given this constraint key

515
00:17:50,320 --> 00:17:53,840
uh

516
00:17:51,280 --> 00:17:54,720
prp values on input that doesn't satisfy

517
00:17:53,840 --> 00:17:59,280
the constraint

518
00:17:54,720 --> 00:18:02,160
remains pseudorandom this is the cprf

519
00:17:59,280 --> 00:18:03,678
so there are several flavors of security

520
00:18:02,160 --> 00:18:06,000
notion for cprf

521
00:18:03,679 --> 00:18:08,080
and especially we consider the following

522
00:18:06,000 --> 00:18:10,960
two axis of the security level

523
00:18:08,080 --> 00:18:13,360
of the cprf the first is selective

524
00:18:10,960 --> 00:18:15,440
security versus adaptive security

525
00:18:13,360 --> 00:18:17,760
and the second is single key security

526
00:18:15,440 --> 00:18:20,160
versus collusion resistance

527
00:18:17,760 --> 00:18:21,919
and ideally the optimal notion of

528
00:18:20,160 --> 00:18:24,000
security notion of cprf

529
00:18:21,919 --> 00:18:24,960
is adaptive and acute collusion

530
00:18:24,000 --> 00:18:28,880
resistance

531
00:18:24,960 --> 00:18:31,440
for all polynomials

532
00:18:28,880 --> 00:18:33,200
so here i will review non-construction

533
00:18:31,440 --> 00:18:35,600
of cprfs

534
00:18:33,200 --> 00:18:38,720
and as a first category we consider

535
00:18:35,600 --> 00:18:40,959
construction from standard assumptions

536
00:18:38,720 --> 00:18:43,280
there are many constructions in this

537
00:18:40,960 --> 00:18:45,840
category however we observe

538
00:18:43,280 --> 00:18:47,600
that all these constructions only

539
00:18:45,840 --> 00:18:49,840
achieve selective security

540
00:18:47,600 --> 00:18:50,879
and most of them only achieve single key

541
00:18:49,840 --> 00:18:53,918
security

542
00:18:50,880 --> 00:18:56,400
so our question for this category is

543
00:18:53,919 --> 00:18:57,840
can we construct adaptively secure and

544
00:18:56,400 --> 00:19:01,360
collision resistant

545
00:18:57,840 --> 00:19:02,879
uh cprf for any functionality uh

546
00:19:01,360 --> 00:19:04,639
based on standard assumption in the

547
00:19:02,880 --> 00:19:07,280
standard model and

548
00:19:04,640 --> 00:19:09,840
another category uh we also consider

549
00:19:07,280 --> 00:19:13,280
construction from

550
00:19:09,840 --> 00:19:16,080
uh this category online country gave a

551
00:19:13,280 --> 00:19:17,760
construction of cprf for poly collusion

552
00:19:16,080 --> 00:19:20,240
resistance cprm for

553
00:19:17,760 --> 00:19:20,879
p slash poly which is the old polynomial

554
00:19:20,240 --> 00:19:22,320
size circuit

555
00:19:20,880 --> 00:19:24,880
however this construction is only

556
00:19:22,320 --> 00:19:27,520
selectively secure on the other hand

557
00:19:24,880 --> 00:19:29,760
there are two contractions of adaptively

558
00:19:27,520 --> 00:19:33,039
secure cprf based on obfuscation

559
00:19:29,760 --> 00:19:34,640
however this construction only support

560
00:19:33,039 --> 00:19:36,480
limited function class such as

561
00:19:34,640 --> 00:19:39,440
puncturing or np1

562
00:19:36,480 --> 00:19:41,440
so our question for this category is can

563
00:19:39,440 --> 00:19:45,360
we construct adaptively secure and

564
00:19:41,440 --> 00:19:47,679
collusion resistant uh cprf for pth poly

565
00:19:45,360 --> 00:19:49,678
basin or fascication in the standard

566
00:19:47,679 --> 00:19:52,320
model

567
00:19:49,679 --> 00:19:53,360
and in this paper we give three new

568
00:19:52,320 --> 00:19:56,639
constructions

569
00:19:53,360 --> 00:19:57,678
of adaptably secure cprf our first

570
00:19:56,640 --> 00:20:00,000
construction

571
00:19:57,679 --> 00:20:02,400
is adaptively secure and ordering

572
00:20:00,000 --> 00:20:04,840
collision released on the cpif for tc

573
00:20:02,400 --> 00:20:06,640
and f for any constant t from one

574
00:20:04,840 --> 00:20:09,678
function here tc

575
00:20:06,640 --> 00:20:10,960
and f is the class of predicate that can

576
00:20:09,679 --> 00:20:14,960
be expressed as a

577
00:20:10,960 --> 00:20:17,360
end of many clauses that depend at most

578
00:20:14,960 --> 00:20:18,000
t input bits and especially this class

579
00:20:17,360 --> 00:20:21,120
includes

580
00:20:18,000 --> 00:20:23,840
bit fixing as a special case and

581
00:20:21,120 --> 00:20:25,199
our second construction is adaptively

582
00:20:23,840 --> 00:20:28,320
synergy secure cpr

583
00:20:25,200 --> 00:20:30,880
and for in-app products from lwe

584
00:20:28,320 --> 00:20:32,879
and our third construction is adaptively

585
00:20:30,880 --> 00:20:34,159
secure and order one collision radiation

586
00:20:32,880 --> 00:20:36,400
cprf for pc

587
00:20:34,159 --> 00:20:38,559
poly from indistinguishability of

588
00:20:36,400 --> 00:20:40,720
fascication and lwe

589
00:20:38,559 --> 00:20:41,840
and especially the first two

590
00:20:40,720 --> 00:20:44,320
constructions

591
00:20:41,840 --> 00:20:45,360
are the first construction of adaptably

592
00:20:44,320 --> 00:20:47,520
secure cprf

593
00:20:45,360 --> 00:20:49,678
for any functionality based on standard

594
00:20:47,520 --> 00:20:52,000
assumption in the standard model

595
00:20:49,679 --> 00:20:54,640
and our third construction is the first

596
00:20:52,000 --> 00:20:56,000
construction of adaptively secure cprf

597
00:20:54,640 --> 00:20:59,200
for pcs poly

598
00:20:56,000 --> 00:21:00,840
in the standard model even though we

599
00:20:59,200 --> 00:21:03,679
rely on very strong assumptions of

600
00:21:00,840 --> 00:21:05,600
indistinguishability or verification

601
00:21:03,679 --> 00:21:06,960
and and there are several applications

602
00:21:05,600 --> 00:21:10,480
of our cprs

603
00:21:06,960 --> 00:21:13,200
so after uploading our first version of

604
00:21:10,480 --> 00:21:15,760
our first version of our work on eprint

605
00:21:13,200 --> 00:21:18,720
fabry used our crop contraction

606
00:21:15,760 --> 00:21:19,200
to construct adaptively secure abe for

607
00:21:18,720 --> 00:21:23,120
tc

608
00:21:19,200 --> 00:21:25,520
and f based on lwe unfortunately

609
00:21:23,120 --> 00:21:28,320
her construction is not directly

610
00:21:25,520 --> 00:21:30,720
applicable to our second construction

611
00:21:28,320 --> 00:21:32,080
on the other hand and in our recent work

612
00:21:30,720 --> 00:21:34,400
of which we appear at

613
00:21:32,080 --> 00:21:36,559
age group this year we generalize how

614
00:21:34,400 --> 00:21:38,320
framework to be applicable to our second

615
00:21:36,559 --> 00:21:40,399
cpr for inner product

616
00:21:38,320 --> 00:21:43,360
as a result we obtain the first

617
00:21:40,400 --> 00:21:44,880
construction of adaptably secure ipe

618
00:21:43,360 --> 00:21:48,080
from lwe

619
00:21:44,880 --> 00:21:50,400
which has been open for almost a decade

620
00:21:48,080 --> 00:21:53,360
and this is uh the summary of my talk

621
00:21:50,400 --> 00:21:53,360
thank you for your other thing

622
00:21:55,520 --> 00:21:58,639
great thanks for the talk so do we have

623
00:21:57,600 --> 00:22:00,719
any questions

624
00:21:58,640 --> 00:22:02,000
if you have one please post either in

625
00:22:00,720 --> 00:22:05,280
zoom or on

626
00:22:02,000 --> 00:22:08,080
zulip you have a few minutes for people

627
00:22:05,280 --> 00:22:11,200
to type in their questions

628
00:22:08,080 --> 00:22:13,280
no i guess i can start with one so

629
00:22:11,200 --> 00:22:14,880
any thoughts on extending or

630
00:22:13,280 --> 00:22:16,720
generalizing your techniques to get

631
00:22:14,880 --> 00:22:18,480
super constant collusion resistance

632
00:22:16,720 --> 00:22:20,320
so trying to get say even logarithmic

633
00:22:18,480 --> 00:22:22,559
number of keys uh do you think

634
00:22:20,320 --> 00:22:26,080
there's any uh hope of getting such

635
00:22:22,559 --> 00:22:29,520
constructions from standard assumptions

636
00:22:26,080 --> 00:22:30,320
so i think our technique uh okay so we

637
00:22:29,520 --> 00:22:32,639
have

638
00:22:30,320 --> 00:22:34,240
three construction and for fast

639
00:22:32,640 --> 00:22:36,240
contraction i think

640
00:22:34,240 --> 00:22:38,080
this construction authorization this

641
00:22:36,240 --> 00:22:38,960
construction is based on combinatorial

642
00:22:38,080 --> 00:22:42,158
technique

643
00:22:38,960 --> 00:22:44,480
and i think the constant collusion

644
00:22:42,159 --> 00:22:47,360
resistance limitation is very inherent

645
00:22:44,480 --> 00:22:48,640
in this idea so i don't think we can

646
00:22:47,360 --> 00:22:51,760
extend this to

647
00:22:48,640 --> 00:22:53,440
super constant one and the second one is

648
00:22:51,760 --> 00:22:55,520
only single key and this is it is

649
00:22:53,440 --> 00:22:56,400
difficult to construct more than single

650
00:22:55,520 --> 00:22:58,720
key security

651
00:22:56,400 --> 00:23:00,320
and start construction uh it may be

652
00:22:58,720 --> 00:23:02,559
possible to achieve

653
00:23:00,320 --> 00:23:03,360
more than content screen resistance but

654
00:23:02,559 --> 00:23:09,840
so

655
00:23:03,360 --> 00:23:09,840
but that is based on objection

656
00:23:10,000 --> 00:23:13,520
i guess just a follow-up question

657
00:23:11,760 --> 00:23:14,799
regarding your third construction so it

658
00:23:13,520 --> 00:23:16,720
looks like you require both

659
00:23:14,799 --> 00:23:19,918
indistinguishability obfuscation and

660
00:23:16,720 --> 00:23:23,200
lwe so do you have any insight on what

661
00:23:19,919 --> 00:23:25,440
lwe is necessary for and whether we can

662
00:23:23,200 --> 00:23:27,760
sort of remove that additional

663
00:23:25,440 --> 00:23:30,000
assumption and just reduce it to io plus

664
00:23:27,760 --> 00:23:32,480
one-way function

665
00:23:30,000 --> 00:23:34,840
so we use lre for constructing a

666
00:23:32,480 --> 00:23:36,799
primitive called shift hiding shift of a

667
00:23:34,840 --> 00:23:39,199
function and

668
00:23:36,799 --> 00:23:40,240
here i we try to construct that

669
00:23:39,200 --> 00:23:43,440
primitive

670
00:23:40,240 --> 00:23:47,279
based in io and one function

671
00:23:43,440 --> 00:23:50,559
but so as long as we can see so that we

672
00:23:47,279 --> 00:23:53,760
require some exponential security of i o

673
00:23:50,559 --> 00:23:56,399
so i we passing we

674
00:23:53,760 --> 00:23:57,039
think that uh it may be difficult to

675
00:23:56,400 --> 00:23:59,679
construct

676
00:23:57,039 --> 00:24:01,600
that primitive uh solely between the

677
00:23:59,679 --> 00:24:05,279
polynomial hardness of io

678
00:24:01,600 --> 00:24:08,240
and function

679
00:24:05,279 --> 00:24:08,240
okay cool

680
00:24:08,720 --> 00:24:13,440
thanks so are there other questions

681
00:24:11,800 --> 00:24:17,120
[Music]

682
00:24:13,440 --> 00:24:18,400
no i think i think that wraps it up for

683
00:24:17,120 --> 00:24:22,158
this paper

684
00:24:18,400 --> 00:24:24,559
okay um so we continue with

685
00:24:22,159 --> 00:24:25,200
our fourth paper for the session which

686
00:24:24,559 --> 00:24:27,760
will be

687
00:24:25,200 --> 00:24:33,840
collusion resistant watermarkable prfs

688
00:24:27,760 --> 00:24:33,840
from standard assumptions

689
00:24:35,919 --> 00:24:40,960
my screen yes

690
00:24:38,960 --> 00:24:42,400
great thanks for watching you know

691
00:24:40,960 --> 00:24:44,400
thanks for the introduction

692
00:24:42,400 --> 00:24:45,520
uh today i'm going to talk about how to

693
00:24:44,400 --> 00:24:47,600
construct

694
00:24:45,520 --> 00:24:49,840
chlorine resistant automatically

695
00:24:47,600 --> 00:24:53,120
functions from standard substrates

696
00:24:49,840 --> 00:24:57,039
this is based on a joint work with mahou

697
00:24:53,120 --> 00:24:57,439
and chulachi so a waterparking scheme

698
00:24:57,039 --> 00:24:59,919
can

699
00:24:57,440 --> 00:25:00,559
bend some information into a ditched

700
00:24:59,919 --> 00:25:03,520
object

701
00:25:00,559 --> 00:25:04,559
without changing it too much also it

702
00:25:03,520 --> 00:25:07,520
should be hard

703
00:25:04,559 --> 00:25:09,200
to remove the embedded information from

704
00:25:07,520 --> 00:25:11,918
the watermark object

705
00:25:09,200 --> 00:25:14,559
without damaging it in this talk we

706
00:25:11,919 --> 00:25:17,840
focus on tracking schemes for programs

707
00:25:14,559 --> 00:25:20,080
formally it consists of a much marking

708
00:25:17,840 --> 00:25:22,480
algorithm and an expression of result

709
00:25:20,080 --> 00:25:24,559
the market algorithm can and bind a

710
00:25:22,480 --> 00:25:25,039
message into a program with a marketing

711
00:25:24,559 --> 00:25:27,840
key

712
00:25:25,039 --> 00:25:29,120
and the extraction algorithm can the

713
00:25:27,840 --> 00:25:31,760
embedded message from

714
00:25:29,120 --> 00:25:33,279
a watermark program without extraction

715
00:25:31,760 --> 00:25:34,960
key

716
00:25:33,279 --> 00:25:37,440
the main security property of our

717
00:25:34,960 --> 00:25:40,000
waterparking scheme is unbreakability

718
00:25:37,440 --> 00:25:42,320
which requires that the dossier is not

719
00:25:40,000 --> 00:25:44,400
able to remove or modify

720
00:25:42,320 --> 00:25:45,918
the unbanned message from a watermark

721
00:25:44,400 --> 00:25:49,120
program without

722
00:25:45,919 --> 00:25:51,360
significantly changing its functionality

723
00:25:49,120 --> 00:25:53,120
also in practice it is usually desired

724
00:25:51,360 --> 00:25:56,000
to have

725
00:25:53,120 --> 00:25:56,799
vulnerability against chlorine attacks

726
00:25:56,000 --> 00:26:00,320
that is

727
00:25:56,799 --> 00:26:02,480
the the attacker may learn more than one

728
00:26:00,320 --> 00:26:04,320
boot market programs which are generated

729
00:26:02,480 --> 00:26:08,240
by embedding different messengers

730
00:26:04,320 --> 00:26:10,320
into the same program also when we hope

731
00:26:08,240 --> 00:26:13,279
to have watermarking schemes for

732
00:26:10,320 --> 00:26:15,600
arbitrary programs however as showing

733
00:26:13,279 --> 00:26:17,520
back okay at all in 2016

734
00:26:15,600 --> 00:26:20,399
we can't construct wood packing schemes

735
00:26:17,520 --> 00:26:23,520
for learnable functionalities

736
00:26:20,400 --> 00:26:25,520
so in the study of tracking we usually

737
00:26:23,520 --> 00:26:26,480
focus on watermarking schemes for

738
00:26:25,520 --> 00:26:28,720
cryptographic

739
00:26:26,480 --> 00:26:30,000
programs such as the declaration

740
00:26:28,720 --> 00:26:32,640
algorithm or an

741
00:26:30,000 --> 00:26:33,760
equivalent scheme the sign algorithm our

742
00:26:32,640 --> 00:26:35,760
signature scheme

743
00:26:33,760 --> 00:26:38,000
and the evaluation algorithm of a

744
00:26:35,760 --> 00:26:39,840
pseudonym function

745
00:26:38,000 --> 00:26:42,799
now towards constructing woodworking

746
00:26:39,840 --> 00:26:44,879
schemes for cryptographic programs

747
00:26:42,799 --> 00:26:47,039
we already know how to construct

748
00:26:44,880 --> 00:26:48,799
chlorine resistant watermarking schemes

749
00:26:47,039 --> 00:26:52,000
for public key primitives

750
00:26:48,799 --> 00:26:54,320
from standard assumptions such as the

751
00:26:52,000 --> 00:26:57,520
existence of one function

752
00:26:54,320 --> 00:27:00,399
standard lattice assumptions and so on

753
00:26:57,520 --> 00:27:02,000
however for workmarking schemes for

754
00:27:00,400 --> 00:27:03,919
synonym functions

755
00:27:02,000 --> 00:27:06,400
previous constructions from standard

756
00:27:03,919 --> 00:27:08,960
assumptions can only achieve a weaker

757
00:27:06,400 --> 00:27:10,559
single training vulnerability and the

758
00:27:08,960 --> 00:27:12,559
only known clone resistant

759
00:27:10,559 --> 00:27:14,080
woodworking schemes for surgical

760
00:27:12,559 --> 00:27:16,720
functions are constructed

761
00:27:14,080 --> 00:27:18,879
from indistinguishability of exhibition

762
00:27:16,720 --> 00:27:20,880
so the question is can we construct a

763
00:27:18,880 --> 00:27:21,760
gluten resistant or multiple signal

764
00:27:20,880 --> 00:27:24,960
functions

765
00:27:21,760 --> 00:27:27,840
from standard assumptions

766
00:27:24,960 --> 00:27:29,440
so in this work we solve this problem by

767
00:27:27,840 --> 00:27:31,678
providing a compiler

768
00:27:29,440 --> 00:27:32,480
that upgrades a single key circuit with

769
00:27:31,679 --> 00:27:34,960
multiple

770
00:27:32,480 --> 00:27:36,480
function into a clone resistance one the

771
00:27:34,960 --> 00:27:39,440
compiler only

772
00:27:36,480 --> 00:27:41,120
involves standard cryptographic

773
00:27:39,440 --> 00:27:44,080
parameters such as

774
00:27:41,120 --> 00:27:46,799
public inquiry schemes signature schemes

775
00:27:44,080 --> 00:27:48,960
fingerprint codes and so on

776
00:27:46,799 --> 00:27:50,879
all of them can be constructed from

777
00:27:48,960 --> 00:27:53,440
standard assumptions

778
00:27:50,880 --> 00:27:54,320
by applying our compiler to previous

779
00:27:53,440 --> 00:27:56,320
constructions

780
00:27:54,320 --> 00:27:58,399
of single key circuit remarkable

781
00:27:56,320 --> 00:28:02,320
functions from standard assumptions

782
00:27:58,399 --> 00:28:04,320
we can obtain several standard

783
00:28:02,320 --> 00:28:06,320
assumption-based clone-resistant

784
00:28:04,320 --> 00:28:08,879
automation functions with

785
00:28:06,320 --> 00:28:10,720
wireless secure properties the new

786
00:28:08,880 --> 00:28:14,399
schemes can roughly preserve

787
00:28:10,720 --> 00:28:14,399
security of the android scheme

788
00:28:14,840 --> 00:28:20,080
but our compiler

789
00:28:17,440 --> 00:28:21,520
will still comprise some properties of

790
00:28:20,080 --> 00:28:23,279
the underlying

791
00:28:21,520 --> 00:28:25,200
uh single key circuit board parking

792
00:28:23,279 --> 00:28:27,360
schemes first

793
00:28:25,200 --> 00:28:29,679
the new scheme can only achieve

794
00:28:27,360 --> 00:28:30,000
unlimited against bonded charge queries

795
00:28:29,679 --> 00:28:32,480
even

796
00:28:30,000 --> 00:28:33,360
if the original scheme can achieve

797
00:28:32,480 --> 00:28:35,919
unreal

798
00:28:33,360 --> 00:28:37,360
unremovability against unbounded

799
00:28:35,919 --> 00:28:39,679
actuation queries

800
00:28:37,360 --> 00:28:42,080
also the new scheme can only support a

801
00:28:39,679 --> 00:28:44,880
polynomially large messenger space

802
00:28:42,080 --> 00:28:45,760
it is an interesting open problem to

803
00:28:44,880 --> 00:28:49,200
remove these

804
00:28:45,760 --> 00:28:52,640
restrictions in the future construction

805
00:28:49,200 --> 00:28:56,320
also for some reason i'm not able to

806
00:28:52,640 --> 00:28:58,159
explain why it is hard to construct a

807
00:28:56,320 --> 00:29:00,559
gluten resistant watermark both neural

808
00:28:58,159 --> 00:29:02,880
functions from standard assumptions

809
00:29:00,559 --> 00:29:04,000
and how we overcome these barriers in

810
00:29:02,880 --> 00:29:06,799
this short talk

811
00:29:04,000 --> 00:29:09,039
please see the long talk on youtube or

812
00:29:06,799 --> 00:29:11,679
our food paper for more details

813
00:29:09,039 --> 00:29:15,200
so that's all thanks for teaching and

814
00:29:11,679 --> 00:29:15,200
i'm happy to answer your questions

815
00:29:16,480 --> 00:29:19,840
thank you um

816
00:29:18,540 --> 00:29:22,399
[Music]

817
00:29:19,840 --> 00:29:23,760
well people are kind of coming up with

818
00:29:22,399 --> 00:29:26,559
questions maybe

819
00:29:23,760 --> 00:29:27,840
let me start i i was wondering so did

820
00:29:26,559 --> 00:29:30,158
you look at any

821
00:29:27,840 --> 00:29:32,320
other secret key primitives did you try

822
00:29:30,159 --> 00:29:35,200
to apply your techniques beyond

823
00:29:32,320 --> 00:29:36,799
constrained prfs or is there something

824
00:29:35,200 --> 00:29:37,120
that's inherent in your construction

825
00:29:36,799 --> 00:29:39,120
that

826
00:29:37,120 --> 00:29:41,520
these were it's kind of tied to the

827
00:29:39,120 --> 00:29:44,799
constraint period

828
00:29:41,520 --> 00:29:46,960
uh okay so our uh

829
00:29:44,799 --> 00:29:48,480
so our technique can be extended to

830
00:29:46,960 --> 00:29:50,480
other uh symmetric

831
00:29:48,480 --> 00:29:52,320
key primitives such as metric key

832
00:29:50,480 --> 00:29:55,679
encryption and the message

833
00:29:52,320 --> 00:29:58,639
authentication code but

834
00:29:55,679 --> 00:30:00,320
also i think also i think our technique

835
00:29:58,640 --> 00:30:03,600
can be extended to

836
00:30:00,320 --> 00:30:07,120
uh upgrade a single key circle

837
00:30:03,600 --> 00:30:10,639
uh remarkable public inclusion into a

838
00:30:07,120 --> 00:30:12,479
clean resist one but uh

839
00:30:10,640 --> 00:30:14,399
we already know how to construct clone

840
00:30:12,480 --> 00:30:15,679
resistant public key inclusion from

841
00:30:14,399 --> 00:30:18,158
standard subjects

842
00:30:15,679 --> 00:30:19,919
so we focus our technique on

843
00:30:18,159 --> 00:30:23,120
constructing chlorine resistance those

844
00:30:19,919 --> 00:30:27,360
microbiological functions

845
00:30:23,120 --> 00:30:29,039
i see and you mentioned that one of your

846
00:30:27,360 --> 00:30:30,639
building block components are

847
00:30:29,039 --> 00:30:33,440
fingerprinting codes

848
00:30:30,640 --> 00:30:34,799
so i was curious what what are the

849
00:30:33,440 --> 00:30:38,320
constructions or

850
00:30:34,799 --> 00:30:40,399
for those uh sorry

851
00:30:38,320 --> 00:30:41,439
you mean the construction of fingerprint

852
00:30:40,399 --> 00:30:44,559
code or

853
00:30:41,440 --> 00:30:47,120
how we use it no no what are what are

854
00:30:44,559 --> 00:30:50,639
construction for fingerprinting codes

855
00:30:47,120 --> 00:30:51,840
uh oh yeah uh actually in our

856
00:30:50,640 --> 00:30:55,039
construction we need

857
00:30:51,840 --> 00:30:55,760
a fingerprint code we need a fingerprint

858
00:30:55,039 --> 00:30:58,399
code with

859
00:30:55,760 --> 00:30:59,919
a stronger security property called

860
00:30:58,399 --> 00:31:02,479
security against

861
00:30:59,919 --> 00:31:03,840
exchange queries and we give a new

862
00:31:02,480 --> 00:31:07,120
construction

863
00:31:03,840 --> 00:31:08,720
by a pla by adapting the well-known

864
00:31:07,120 --> 00:31:13,039
funny short code

865
00:31:08,720 --> 00:31:16,799
uh to achieve this strong security

866
00:31:13,039 --> 00:31:19,440
so generally the construction is

867
00:31:16,799 --> 00:31:23,120
similar to the financial code but we

868
00:31:19,440 --> 00:31:26,480
adapt the decoding algorithm to

869
00:31:23,120 --> 00:31:26,479
improve its security

870
00:31:26,960 --> 00:31:30,880
i see great thank you

871
00:31:31,600 --> 00:31:35,760
does the audience have any other

872
00:31:33,120 --> 00:31:35,760
questions

873
00:31:36,640 --> 00:31:41,679
so i have a quick question so uh so

874
00:31:39,840 --> 00:31:43,600
your work gives collusion resistant

875
00:31:41,679 --> 00:31:45,760
watermarking for pseudorandom functions

876
00:31:43,600 --> 00:31:47,760
does your techniques apply any in any

877
00:31:45,760 --> 00:31:49,600
way to get say collusion resistant

878
00:31:47,760 --> 00:31:51,200
constrained prfs

879
00:31:49,600 --> 00:31:52,719
and since one remarkable qrs and

880
00:31:51,200 --> 00:31:55,360
constraint prfs seem to have

881
00:31:52,720 --> 00:31:56,880
similar functionality so does can we get

882
00:31:55,360 --> 00:31:58,840
any kind of collusion resistance

883
00:31:56,880 --> 00:32:00,080
for constraining prfs through your

884
00:31:58,840 --> 00:32:02,480
frameworks ah

885
00:32:00,080 --> 00:32:03,439
yeah that's a good question actually we

886
00:32:02,480 --> 00:32:07,679
can

887
00:32:03,440 --> 00:32:11,039
copy clearly system for example punch pi

888
00:32:07,679 --> 00:32:14,640
by using our techniques but

889
00:32:11,039 --> 00:32:17,840
but the we can't get a standard

890
00:32:14,640 --> 00:32:18,640
clean resistant punctual function and we

891
00:32:17,840 --> 00:32:21,840
have to

892
00:32:18,640 --> 00:32:23,600
restrict the puncture set to some some

893
00:32:21,840 --> 00:32:28,080
specific form

894
00:32:23,600 --> 00:32:31,120
and so

895
00:32:28,080 --> 00:32:34,158
i guess uh we uh

896
00:32:31,120 --> 00:32:35,039
that is just uh just what we needed in

897
00:32:34,159 --> 00:32:37,679
constructing

898
00:32:35,039 --> 00:32:38,799
clone resistant macbook drawer function

899
00:32:37,679 --> 00:32:42,080
uh

900
00:32:38,799 --> 00:32:44,480
but we can't get a

901
00:32:42,080 --> 00:32:45,360
colonist a general clone resistant uh

902
00:32:44,480 --> 00:32:48,559
construction

903
00:32:45,360 --> 00:32:51,840
a punctual student function

904
00:32:48,559 --> 00:32:54,960
so we have to restrict

905
00:32:51,840 --> 00:32:56,799
the set the those uh the adversary can

906
00:32:54,960 --> 00:32:59,760
get from

907
00:32:56,799 --> 00:33:00,879
for the consumer kids uh i think they

908
00:32:59,760 --> 00:33:03,919
have two

909
00:33:00,880 --> 00:33:04,559
uh for example the adversary can only

910
00:33:03,919 --> 00:33:07,200
get

911
00:33:04,559 --> 00:33:09,120
one set and then that continuous set

912
00:33:07,200 --> 00:33:12,640
something like that

913
00:33:09,120 --> 00:33:15,518
so this is very restricted so we folks

914
00:33:12,640 --> 00:33:17,919
are constructing remarkable pseudonym

915
00:33:15,519 --> 00:33:17,919
functions

916
00:33:21,600 --> 00:33:25,519
wait i i don't think we have more any

917
00:33:24,320 --> 00:33:29,840
more questions

918
00:33:25,519 --> 00:33:29,840
and thanks the speaker again

919
00:33:30,399 --> 00:33:33,918
so i guess let's move on to the fifth

920
00:33:32,640 --> 00:33:37,360
talk so do we have a

921
00:33:33,919 --> 00:33:39,840
speaker for the this talk

922
00:33:37,360 --> 00:33:40,879
all right ah i see john good great so

923
00:33:39,840 --> 00:33:42,559
our fifth talk

924
00:33:40,880 --> 00:33:44,080
in this uh session will be on

925
00:33:42,559 --> 00:33:46,000
non-malleable secret sharing

926
00:33:44,080 --> 00:33:47,279
against bounded joint tampering attacks

927
00:33:46,000 --> 00:33:49,760
in the playing model

928
00:33:47,279 --> 00:33:51,039
uh this is work by john luca bryan

929
00:33:49,760 --> 00:33:54,240
antonio fognio

930
00:33:51,039 --> 00:33:54,960
massige obremsky mark simkin and daniele

931
00:33:54,240 --> 00:33:58,320
venturi

932
00:33:54,960 --> 00:34:01,440
and jean luca will give the talk

933
00:33:58,320 --> 00:34:03,600
thank you for the introduction so

934
00:34:01,440 --> 00:34:05,360
in secret sharing there is a dealer that

935
00:34:03,600 --> 00:34:07,519
has a secret message and wants to share

936
00:34:05,360 --> 00:34:09,679
it among other end parties so that only

937
00:34:07,519 --> 00:34:11,359
certain subsets of parties are able to

938
00:34:09,679 --> 00:34:13,040
reconstruct the message

939
00:34:11,359 --> 00:34:14,960
in particular in standard signal sharing

940
00:34:13,040 --> 00:34:17,119
there are two properties that are

941
00:34:14,960 --> 00:34:18,240
correctness stating that all authorized

942
00:34:17,119 --> 00:34:21,280
subsets of parties

943
00:34:18,239 --> 00:34:22,158
are able to reconstruct the secret and

944
00:34:21,280 --> 00:34:24,240
privacy

945
00:34:22,159 --> 00:34:26,399
stating that no unauthorized subset of

946
00:34:24,239 --> 00:34:27,520
party should learn any information about

947
00:34:26,399 --> 00:34:29,279
the secret

948
00:34:27,520 --> 00:34:31,199
in our paper we also consider two

949
00:34:29,280 --> 00:34:34,240
additional standard properties that are

950
00:34:31,199 --> 00:34:37,040
literature resilient and normally we'll

951
00:34:34,239 --> 00:34:39,520
ability in particular literature

952
00:34:37,040 --> 00:34:39,520
resilience

953
00:34:40,480 --> 00:34:45,119
means that even if the attacker learns

954
00:34:43,280 --> 00:34:45,919
some information from possibly all the

955
00:34:45,119 --> 00:34:47,679
shares

956
00:34:45,918 --> 00:34:49,359
still does not learn any information

957
00:34:47,679 --> 00:34:52,000
from the secret

958
00:34:49,359 --> 00:34:52,560
and normal ability states that even if

959
00:34:52,000 --> 00:34:54,800
the

960
00:34:52,560 --> 00:34:55,599
attacker modifies possibly all the

961
00:34:54,800 --> 00:34:58,079
shares

962
00:34:55,599 --> 00:34:58,880
and sees the reconstruction of the

963
00:34:58,079 --> 00:35:02,480
message

964
00:34:58,880 --> 00:35:04,880
from the modified shares the new

965
00:35:02,480 --> 00:35:06,720
message is unrelated to the previous one

966
00:35:04,880 --> 00:35:08,480
and the and thus the

967
00:35:06,720 --> 00:35:10,319
attacker still does not learn any

968
00:35:08,480 --> 00:35:12,960
information about the secret

969
00:35:10,320 --> 00:35:14,560
and usually these two properties are uh

970
00:35:12,960 --> 00:35:14,880
considered together in what is called

971
00:35:14,560 --> 00:35:17,599
league

972
00:35:14,880 --> 00:35:19,359
resilient normal ability in particular

973
00:35:17,599 --> 00:35:21,359
in our paper we focus on literature

974
00:35:19,359 --> 00:35:23,200
resilience signal sharing

975
00:35:21,359 --> 00:35:24,720
against joint leakage and tampering

976
00:35:23,200 --> 00:35:27,439
attacks and we consider

977
00:35:24,720 --> 00:35:28,319
two different models in the first model

978
00:35:27,440 --> 00:35:31,680
we consider

979
00:35:28,320 --> 00:35:34,240
the selective partitioning that is uh

980
00:35:31,680 --> 00:35:36,000
that the attacker commits to a single

981
00:35:34,240 --> 00:35:37,680
singular construction set and a single

982
00:35:36,000 --> 00:35:40,800
partition of that uh

983
00:35:37,680 --> 00:35:42,720
set and then he is able to uh

984
00:35:40,800 --> 00:35:45,040
jointly leak from and tamper with all

985
00:35:42,720 --> 00:35:47,680
the shares within each subset

986
00:35:45,040 --> 00:35:49,520
in this setting we proved that any one

987
00:35:47,680 --> 00:35:51,040
time statistically in a malleable cigar

988
00:35:49,520 --> 00:35:52,560
sharing scheme is also a leakage

989
00:35:51,040 --> 00:35:53,759
resilient one-time normal level

990
00:35:52,560 --> 00:35:55,759
signature scheme

991
00:35:53,760 --> 00:35:57,200
and we proved this fact by complexity

992
00:35:55,760 --> 00:36:00,480
leveraging in particular

993
00:35:57,200 --> 00:36:04,160
we reduce to secure to we construct a

994
00:36:00,480 --> 00:36:06,079
reduction to simple normal ability and

995
00:36:04,160 --> 00:36:08,078
the reduction tries to guess the leakage

996
00:36:06,079 --> 00:36:08,720
and finally it checks that the leakage

997
00:36:08,079 --> 00:36:11,040
is correct

998
00:36:08,720 --> 00:36:12,240
using the tampering query we also find

999
00:36:11,040 --> 00:36:14,079
two applications to these

1000
00:36:12,240 --> 00:36:15,919
two applications to this fact that are

1001
00:36:14,079 --> 00:36:18,079
in lower bounds for the size of the

1002
00:36:15,920 --> 00:36:21,040
shares of non-malleable signal sharing

1003
00:36:18,079 --> 00:36:22,160
and we in a construction of a compiler

1004
00:36:21,040 --> 00:36:24,720
that takes as input

1005
00:36:22,160 --> 00:36:26,078
a leakage resilient one-time malleable

1006
00:36:24,720 --> 00:36:28,319
single sharing scheme

1007
00:36:26,079 --> 00:36:29,440
and outputs a ptime and malleable signal

1008
00:36:28,320 --> 00:36:32,720
sharing scheme

1009
00:36:29,440 --> 00:36:35,599
scheme under uh in the computational

1010
00:36:32,720 --> 00:36:36,879
secure in the computational setting the

1011
00:36:35,599 --> 00:36:38,880
second model we

1012
00:36:36,880 --> 00:36:40,160
consider is the one of semi-adaptive

1013
00:36:38,880 --> 00:36:43,760
partitioning

1014
00:36:40,160 --> 00:36:47,520
in adaptive partitioning the attacker

1015
00:36:43,760 --> 00:36:49,599
does not choose a reconstruction set and

1016
00:36:47,520 --> 00:36:50,560
does not commit to a reconstruction set

1017
00:36:49,599 --> 00:36:53,119
or a

1018
00:36:50,560 --> 00:36:54,078
partition but he is allowed to choose

1019
00:36:53,119 --> 00:36:57,280
the partition

1020
00:36:54,079 --> 00:36:59,040
for each query adaptively however in

1021
00:36:57,280 --> 00:37:02,160
semi-adaptive partitioning

1022
00:36:59,040 --> 00:37:02,800
the attack there is a reduction that is

1023
00:37:02,160 --> 00:37:05,839
that

1024
00:37:02,800 --> 00:37:06,320
each subset of each linkage query is

1025
00:37:05,839 --> 00:37:08,799
either

1026
00:37:06,320 --> 00:37:09,920
inside or outside a subset of the

1027
00:37:08,800 --> 00:37:11,760
dampering query

1028
00:37:09,920 --> 00:37:14,960
in particular there should be no

1029
00:37:11,760 --> 00:37:16,640
overlaps partial overlaps between

1030
00:37:14,960 --> 00:37:19,839
subset of the leakage partition and

1031
00:37:16,640 --> 00:37:22,319
subsets of the tampering partition

1032
00:37:19,839 --> 00:37:23,599
in the setting we construct a leakage

1033
00:37:22,320 --> 00:37:25,520
resilient secretions

1034
00:37:23,599 --> 00:37:27,280
one-time non-malleable signature scheme

1035
00:37:25,520 --> 00:37:28,400
that actually secured against this kind

1036
00:37:27,280 --> 00:37:31,280
of attacks

1037
00:37:28,400 --> 00:37:32,960
and our construction involves a normal

1038
00:37:31,280 --> 00:37:34,880
level code that splits the

1039
00:37:32,960 --> 00:37:37,280
secret in the left part and the right

1040
00:37:34,880 --> 00:37:38,800
part and then

1041
00:37:37,280 --> 00:37:40,480
we apply a different literature

1042
00:37:38,800 --> 00:37:42,560
resilient cigarette sharing scheme to

1043
00:37:40,480 --> 00:37:45,680
each of the two parts and finally

1044
00:37:42,560 --> 00:37:47,040
we pack the each left share with their

1045
00:37:45,680 --> 00:37:49,839
respective right share

1046
00:37:47,040 --> 00:37:51,599
to obtain the final shares the proof of

1047
00:37:49,839 --> 00:37:55,200
security is uh

1048
00:37:51,599 --> 00:37:58,800
proceeds by hybrid argument and actually

1049
00:37:55,200 --> 00:38:00,480
we gradually proceed to

1050
00:37:58,800 --> 00:38:02,480
separate the computation of the

1051
00:38:00,480 --> 00:38:04,160
tempering query to the left part and to

1052
00:38:02,480 --> 00:38:05,280
the right part so that we can finally

1053
00:38:04,160 --> 00:38:08,078
reduce to the

1054
00:38:05,280 --> 00:38:09,040
uh to normal ability of the normal level

1055
00:38:08,079 --> 00:38:10,720
code

1056
00:38:09,040 --> 00:38:12,560
also in this case we have the we have

1057
00:38:10,720 --> 00:38:14,480
the application for the

1058
00:38:12,560 --> 00:38:15,440
compiler for the time normal level

1059
00:38:14,480 --> 00:38:17,359
serial sharing scheme in the

1060
00:38:15,440 --> 00:38:20,800
computational setting

1061
00:38:17,359 --> 00:38:23,520
and finally we have we leave some

1062
00:38:20,800 --> 00:38:24,960
open problems we are actually working on

1063
00:38:23,520 --> 00:38:28,800
these open problems

1064
00:38:24,960 --> 00:38:31,440
we have a submission in tcc 2020

1065
00:38:28,800 --> 00:38:32,960
and the first open problem is to achieve

1066
00:38:31,440 --> 00:38:36,320
continuous normal ability

1067
00:38:32,960 --> 00:38:38,800
rather than p-time number ability uh

1068
00:38:36,320 --> 00:38:39,599
and this the kind of security against

1069
00:38:38,800 --> 00:38:41,520
joint

1070
00:38:39,599 --> 00:38:42,720
leakage tapering attacks in the plane

1071
00:38:41,520 --> 00:38:45,759
model

1072
00:38:42,720 --> 00:38:48,560
and the second uh

1073
00:38:45,760 --> 00:38:49,359
open problem is to achieve optimal rate

1074
00:38:48,560 --> 00:38:52,640
uh we are

1075
00:38:49,359 --> 00:38:54,400
actually able to improve uh the rate but

1076
00:38:52,640 --> 00:38:56,560
uh

1077
00:38:54,400 --> 00:38:58,480
at the moment optimal rate is still

1078
00:38:56,560 --> 00:39:01,119
another problem

1079
00:38:58,480 --> 00:39:03,839
and so that's everything and thank you

1080
00:39:01,119 --> 00:39:03,839
for the attention

1081
00:39:05,440 --> 00:39:10,640
great thanks john luco for the pop

1082
00:39:08,560 --> 00:39:11,759
so it looks like we have one question

1083
00:39:10,640 --> 00:39:13,200
from zoom so

1084
00:39:11,760 --> 00:39:15,119
for other audience members if you have

1085
00:39:13,200 --> 00:39:16,799
additional questions please feel free to

1086
00:39:15,119 --> 00:39:19,760
ask and zoom or on a zulu

1087
00:39:16,800 --> 00:39:21,839
so the question from subadeep is how

1088
00:39:19,760 --> 00:39:24,240
much leakage can your steam tolerate

1089
00:39:21,839 --> 00:39:25,680
it seems like it is possible to tolerate

1090
00:39:24,240 --> 00:39:27,279
only logarithmic leakage

1091
00:39:25,680 --> 00:39:29,759
since you have to guess the leakage in

1092
00:39:27,280 --> 00:39:33,119
the reduction

1093
00:39:29,760 --> 00:39:37,839
uh well actually

1094
00:39:33,119 --> 00:39:40,880
since we choose the the parameter zadok

1095
00:39:37,839 --> 00:39:44,560
we could choose ideally any

1096
00:39:40,880 --> 00:39:45,560
leakage bound we want we use a bounded

1097
00:39:44,560 --> 00:39:47,359
leakage and

1098
00:39:45,560 --> 00:39:52,240
[Music]

1099
00:39:47,359 --> 00:39:55,920
so we can virtually

1100
00:39:52,240 --> 00:39:58,000
fix any leakage bound we desire because

1101
00:39:55,920 --> 00:39:59,599
the underlying skill we can adjust the

1102
00:39:58,000 --> 00:40:02,560
parameters of the underlying

1103
00:39:59,599 --> 00:40:04,000
schemes accordingly so if we need the

1104
00:40:02,560 --> 00:40:06,160
security

1105
00:40:04,000 --> 00:40:07,599
epsilon security for the leakage

1106
00:40:06,160 --> 00:40:10,078
resilient one normal

1107
00:40:07,599 --> 00:40:10,880
normal level single sharing scheme then

1108
00:40:10,079 --> 00:40:14,960
we

1109
00:40:10,880 --> 00:40:17,280
adjust the accordingly the underlying

1110
00:40:14,960 --> 00:40:20,079
normal level single sharing scheme with

1111
00:40:17,280 --> 00:40:23,599
a particular

1112
00:40:20,079 --> 00:40:26,880
parameter that is in particular epsilon

1113
00:40:23,599 --> 00:40:30,240
over 2 to the l so uh

1114
00:40:26,880 --> 00:40:32,960
yeah we our constructions work in the

1115
00:40:30,240 --> 00:40:34,479
statistical under statistical security

1116
00:40:32,960 --> 00:40:37,520
achieve statistical security

1117
00:40:34,480 --> 00:40:40,800
so um we

1118
00:40:37,520 --> 00:40:44,960
can allow any leakage we want by

1119
00:40:40,800 --> 00:40:44,960
adjusting the parameters accordingly

1120
00:40:46,880 --> 00:40:56,240
great so any other questions

1121
00:40:53,599 --> 00:40:57,520
i think i think that these were probably

1122
00:40:56,240 --> 00:40:59,520
all the questions

1123
00:40:57,520 --> 00:41:00,640
great so if not then we can move on to

1124
00:40:59,520 --> 00:41:03,680
the final talk

1125
00:41:00,640 --> 00:41:06,839
in this section thanks again okay uh

1126
00:41:03,680 --> 00:41:09,359
the final talk for this session is

1127
00:41:06,839 --> 00:41:11,920
non-malleability against polynomial

1128
00:41:09,359 --> 00:41:11,920
tampering

1129
00:41:17,040 --> 00:41:23,440
okay thanks for the introduction

1130
00:41:20,240 --> 00:41:26,319
can you see my slides yes yeah okay

1131
00:41:23,440 --> 00:41:28,160
thank you so the title of our work is uh

1132
00:41:26,319 --> 00:41:29,040
numeriability against polynomial

1133
00:41:28,160 --> 00:41:30,960
temporary

1134
00:41:29,040 --> 00:41:33,119
and this is a joint work with marshall

1135
00:41:30,960 --> 00:41:34,319
ball ichan chadopathier thomakin and

1136
00:41:33,119 --> 00:41:36,160
lyantan

1137
00:41:34,319 --> 00:41:38,079
so because of the time constraint i will

1138
00:41:36,160 --> 00:41:38,879
only give a brief summary of our main

1139
00:41:38,079 --> 00:41:40,160
results

1140
00:41:38,880 --> 00:41:42,319
and if you are interested in the

1141
00:41:40,160 --> 00:41:42,879
technical parts please check our youtube

1142
00:41:42,319 --> 00:41:45,839
video

1143
00:41:42,880 --> 00:41:48,560
or the paper so first let me tell you

1144
00:41:45,839 --> 00:41:50,240
what is a nominable code so numerical

1145
00:41:48,560 --> 00:41:51,599
code is first introduced by czemboski

1146
00:41:50,240 --> 00:41:53,680
prtrack and wix

1147
00:41:51,599 --> 00:41:55,599
and it consists of a randomized encoding

1148
00:41:53,680 --> 00:41:56,560
function and a deterministic decoding

1149
00:41:55,599 --> 00:41:58,079
function

1150
00:41:56,560 --> 00:42:00,319
and we'll consider a temporary

1151
00:41:58,079 --> 00:42:02,960
experiment which we take a message as

1152
00:42:00,319 --> 00:42:04,480
and encode it into a cohort c then there

1153
00:42:02,960 --> 00:42:05,280
will be anniversary who tempers the

1154
00:42:04,480 --> 00:42:06,880
codeword

1155
00:42:05,280 --> 00:42:08,800
then we will declare the temporal world

1156
00:42:06,880 --> 00:42:11,119
to get temporary message

1157
00:42:08,800 --> 00:42:12,160
and what we want to guarantee in this

1158
00:42:11,119 --> 00:42:14,720
temporary experiment

1159
00:42:12,160 --> 00:42:16,240
is two properties so the first one is

1160
00:42:14,720 --> 00:42:18,480
the correctness which says

1161
00:42:16,240 --> 00:42:21,279
if there is no tempering happens then we

1162
00:42:18,480 --> 00:42:23,200
should get exactly the original message

1163
00:42:21,280 --> 00:42:24,400
and second property says if some

1164
00:42:23,200 --> 00:42:26,240
tempering happens

1165
00:42:24,400 --> 00:42:28,560
then either the temper message remains

1166
00:42:26,240 --> 00:42:30,078
unchanged or it should become something

1167
00:42:28,560 --> 00:42:32,480
unrelated to original message

1168
00:42:30,079 --> 00:42:34,319
s which means it gets destroyed by this

1169
00:42:32,480 --> 00:42:36,960
temporary experiment

1170
00:42:34,319 --> 00:42:39,279
so a simple observation here is it is

1171
00:42:36,960 --> 00:42:41,200
impossible to

1172
00:42:39,280 --> 00:42:42,480
construct a numerical code for arbitrary

1173
00:42:41,200 --> 00:42:44,399
temporary function

1174
00:42:42,480 --> 00:42:46,400
otherwise the diversity can just decode

1175
00:42:44,400 --> 00:42:47,040
the cold war and temper it and re-encode

1176
00:42:46,400 --> 00:42:48,800
it

1177
00:42:47,040 --> 00:42:51,520
so some restrictions on this temporary

1178
00:42:48,800 --> 00:42:54,240
function family is necessary

1179
00:42:51,520 --> 00:42:55,599
and in prior works the most well-studied

1180
00:42:54,240 --> 00:42:57,200
temporary functions probably the

1181
00:42:55,599 --> 00:42:59,280
split-state model

1182
00:42:57,200 --> 00:43:01,598
but recently some other works also

1183
00:42:59,280 --> 00:43:03,599
started to expose the possibilities

1184
00:43:01,599 --> 00:43:05,119
beyond this split state model

1185
00:43:03,599 --> 00:43:07,520
and some examples are shown on the

1186
00:43:05,119 --> 00:43:09,599
slides so in this work

1187
00:43:07,520 --> 00:43:11,280
we consider the tempering functions to

1188
00:43:09,599 --> 00:43:15,040
be polynomials

1189
00:43:11,280 --> 00:43:17,760
over prime field fq and formally

1190
00:43:15,040 --> 00:43:18,480
in our nominative code the cold war will

1191
00:43:17,760 --> 00:43:21,119
be

1192
00:43:18,480 --> 00:43:23,040
an element over a prime field fq then

1193
00:43:21,119 --> 00:43:24,319
the diversity can choose some degree d

1194
00:43:23,040 --> 00:43:26,400
polynomials

1195
00:43:24,319 --> 00:43:28,800
as a temporary function so if the

1196
00:43:26,400 --> 00:43:30,640
adversary chooses like p1 to pr and then

1197
00:43:28,800 --> 00:43:31,040
the temporary code will be pure next to

1198
00:43:30,640 --> 00:43:34,078
p and

1199
00:43:31,040 --> 00:43:37,119
x and our first result is

1200
00:43:34,079 --> 00:43:39,280
we show that for every integer m and d

1201
00:43:37,119 --> 00:43:40,160
and the sufficiently large prime q we

1202
00:43:39,280 --> 00:43:42,720
can construct

1203
00:43:40,160 --> 00:43:43,520
an available code which encode the ambit

1204
00:43:42,720 --> 00:43:45,919
message

1205
00:43:43,520 --> 00:43:48,319
and is secure against degreed polynomial

1206
00:43:45,920 --> 00:43:50,240
temporaries

1207
00:43:48,319 --> 00:43:51,839
and an interesting corollary of our

1208
00:43:50,240 --> 00:43:54,240
first result is

1209
00:43:51,839 --> 00:43:56,480
the same level code actually also works

1210
00:43:54,240 --> 00:43:58,799
for arithmetic circuits

1211
00:43:56,480 --> 00:44:00,960
so an arithmetic circuit is a circuit

1212
00:43:58,800 --> 00:44:02,480
where each kit computes either the sum

1213
00:44:00,960 --> 00:44:04,880
or the product of its two

1214
00:44:02,480 --> 00:44:06,720
inputs over some field and if we

1215
00:44:04,880 --> 00:44:10,160
consider temporary functions to be

1216
00:44:06,720 --> 00:44:13,040
some size s arithmetic circuit

1217
00:44:10,160 --> 00:44:14,240
and it is not hard to see that a size s

1218
00:44:13,040 --> 00:44:16,480
or spectic circuit

1219
00:44:14,240 --> 00:44:17,680
actually computes a degree two to s

1220
00:44:16,480 --> 00:44:19,440
polynomials

1221
00:44:17,680 --> 00:44:21,520
so it directly implies that our

1222
00:44:19,440 --> 00:44:22,880
numerable code also works for arithmatic

1223
00:44:21,520 --> 00:44:25,440
circuits

1224
00:44:22,880 --> 00:44:27,359
so this is our first result and our

1225
00:44:25,440 --> 00:44:28,160
second result is the nominable secret

1226
00:44:27,359 --> 00:44:30,319
sharing

1227
00:44:28,160 --> 00:44:31,920
and thanks to jean luca we have already

1228
00:44:30,319 --> 00:44:32,640
seen the definition of the secret

1229
00:44:31,920 --> 00:44:34,880
sharing

1230
00:44:32,640 --> 00:44:37,200
and i just want to mention that in this

1231
00:44:34,880 --> 00:44:38,000
work we focus on tea out of fun secret

1232
00:44:37,200 --> 00:44:40,480
sharing

1233
00:44:38,000 --> 00:44:41,359
where we can reconstruct the secret with

1234
00:44:40,480 --> 00:44:43,359
t-shirts

1235
00:44:41,359 --> 00:44:45,200
but we cannot get any information about

1236
00:44:43,359 --> 00:44:46,880
the secret if we only have less than

1237
00:44:45,200 --> 00:44:48,640
t-shirts

1238
00:44:46,880 --> 00:44:50,800
and the recent work by goyan kumar

1239
00:44:48,640 --> 00:44:53,520
introduced the nominable sql sharing

1240
00:44:50,800 --> 00:44:54,720
which is basically a tr a secret sharing

1241
00:44:53,520 --> 00:44:58,319
with an additional

1242
00:44:54,720 --> 00:44:59,520
nominability guarantees and in this work

1243
00:44:58,319 --> 00:45:01,839
we show that

1244
00:44:59,520 --> 00:45:03,680
for every integer m and dt and the

1245
00:45:01,839 --> 00:45:06,160
sufficiently large prime q

1246
00:45:03,680 --> 00:45:07,040
we can construct a t out of a nominable

1247
00:45:06,160 --> 00:45:09,279
square sharing

1248
00:45:07,040 --> 00:45:11,920
for ambient secret which is secure

1249
00:45:09,280 --> 00:45:13,839
against degree polynomial temperatures

1250
00:45:11,920 --> 00:45:15,760
and furthermore we actually provide a

1251
00:45:13,839 --> 00:45:18,078
stronger security guarantee that

1252
00:45:15,760 --> 00:45:20,240
we allow the adversary to adaptively

1253
00:45:18,079 --> 00:45:22,880
choose the template functions

1254
00:45:20,240 --> 00:45:23,759
so more precisely the adversary can

1255
00:45:22,880 --> 00:45:26,240
first

1256
00:45:23,760 --> 00:45:28,480
check some t-minus one shares and then

1257
00:45:26,240 --> 00:45:30,640
use these shares to decide some degree

1258
00:45:28,480 --> 00:45:32,640
polynomials as a temporary function

1259
00:45:30,640 --> 00:45:34,240
and then the version will apply to the

1260
00:45:32,640 --> 00:45:36,078
polynomials on the shares to get the

1261
00:45:34,240 --> 00:45:38,078
temperatures

1262
00:45:36,079 --> 00:45:39,760
so uh we want to emphasize that this is

1263
00:45:38,079 --> 00:45:40,640
actually a pretty strong security

1264
00:45:39,760 --> 00:45:42,720
guarantee

1265
00:45:40,640 --> 00:45:44,560
because it allows the adversary to

1266
00:45:42,720 --> 00:45:47,598
temper these t-minus one shares

1267
00:45:44,560 --> 00:45:51,680
like jointly and arbitrarily

1268
00:45:47,599 --> 00:45:53,440
so yeah and uh similar to nominable code

1269
00:45:51,680 --> 00:45:56,879
the same our numerable security sharing

1270
00:45:53,440 --> 00:45:59,040
also works for asthmatic circuits

1271
00:45:56,880 --> 00:46:00,000
and to build these two results uh the

1272
00:45:59,040 --> 00:46:02,160
the

1273
00:46:00,000 --> 00:46:04,560
main building block of our two results

1274
00:46:02,160 --> 00:46:06,720
is a c less nominable extractor

1275
00:46:04,560 --> 00:46:08,720
against polynomial temporary but um

1276
00:46:06,720 --> 00:46:12,078
unfortunately we don't have time to

1277
00:46:08,720 --> 00:46:14,720
talk about this today and then with this

1278
00:46:12,079 --> 00:46:16,720
uh building block we'll apply the a

1279
00:46:14,720 --> 00:46:18,240
reduction by triaxia and guru swami to

1280
00:46:16,720 --> 00:46:19,919
get a nominable code

1281
00:46:18,240 --> 00:46:23,279
and then we'll apply another scheme by

1282
00:46:19,920 --> 00:46:25,839
line at o to get the numerable security

1283
00:46:23,280 --> 00:46:27,520
and in addition to apply these

1284
00:46:25,839 --> 00:46:29,520
reductions we actually need an

1285
00:46:27,520 --> 00:46:30,640
efficient inverter for our nominable

1286
00:46:29,520 --> 00:46:33,280
extractor

1287
00:46:30,640 --> 00:46:35,200
and this diffusion inverter in our paper

1288
00:46:33,280 --> 00:46:36,160
also contains some interesting new idea

1289
00:46:35,200 --> 00:46:39,359
which we believe

1290
00:46:36,160 --> 00:46:40,960
might be of independent interest

1291
00:46:39,359 --> 00:46:42,480
finally let me show you some open

1292
00:46:40,960 --> 00:46:45,119
problems

1293
00:46:42,480 --> 00:46:46,319
so the first one is trying to improve

1294
00:46:45,119 --> 00:46:48,880
the parameters

1295
00:46:46,319 --> 00:46:50,960
in our numerical code such as the

1296
00:46:48,880 --> 00:46:53,680
information rate and the arrow

1297
00:46:50,960 --> 00:46:54,640
and the second is to try to achieve

1298
00:46:53,680 --> 00:46:57,919
nominability

1299
00:46:54,640 --> 00:46:59,920
against polynomials over f2 and because

1300
00:46:57,920 --> 00:47:01,680
our construction relies on whale bound

1301
00:46:59,920 --> 00:47:04,720
which is only non-trivial

1302
00:47:01,680 --> 00:47:05,118
over a large field so we think this

1303
00:47:04,720 --> 00:47:08,560
might

1304
00:47:05,119 --> 00:47:10,880
require some very different ideas

1305
00:47:08,560 --> 00:47:12,960
and finally it will also be interesting

1306
00:47:10,880 --> 00:47:13,760
to achieve number ability against some

1307
00:47:12,960 --> 00:47:16,160
other

1308
00:47:13,760 --> 00:47:17,040
temporary functions especially those

1309
00:47:16,160 --> 00:47:19,598
with some

1310
00:47:17,040 --> 00:47:20,079
non-trivial average case lower bond such

1311
00:47:19,599 --> 00:47:22,480
as

1312
00:47:20,079 --> 00:47:24,880
small waste branching programs or aco

1313
00:47:22,480 --> 00:47:29,119
circuits with priority gates

1314
00:47:24,880 --> 00:47:32,400
thank you for your attention thank you

1315
00:47:29,119 --> 00:47:35,200
so we already have some questions so the

1316
00:47:32,400 --> 00:47:37,599
first question is from anna kaplan

1317
00:47:35,200 --> 00:47:38,240
and the question is can you go into more

1318
00:47:37,599 --> 00:47:40,480
detail

1319
00:47:38,240 --> 00:47:43,200
why you chose to look at polynomials

1320
00:47:40,480 --> 00:47:45,520
over fq for the tampering functions

1321
00:47:43,200 --> 00:47:48,000
was the use in arithmetic circuits the

1322
00:47:45,520 --> 00:47:51,200
motivation

1323
00:47:48,000 --> 00:47:53,760
uh yes so the use in arithmetic circuit

1324
00:47:51,200 --> 00:47:57,279
is part of the motivation

1325
00:47:53,760 --> 00:47:57,280
but i think

1326
00:47:58,400 --> 00:48:03,839
but i guess the main motivation is in

1327
00:48:00,880 --> 00:48:03,839
some previous work

1328
00:48:04,400 --> 00:48:07,520
so in the previous work by chad body and

1329
00:48:06,960 --> 00:48:09,760
li

1330
00:48:07,520 --> 00:48:10,960
they consider the five functions to be

1331
00:48:09,760 --> 00:48:14,079
the temporary function

1332
00:48:10,960 --> 00:48:15,200
so we want to like try to generalize it

1333
00:48:14,079 --> 00:48:18,559
a little bit more

1334
00:48:15,200 --> 00:48:20,799
like maybe consider the uh like the five

1335
00:48:18,559 --> 00:48:23,280
functions are degree one polynomials

1336
00:48:20,800 --> 00:48:24,480
then uh we want to explore like what we

1337
00:48:23,280 --> 00:48:26,640
can do if the

1338
00:48:24,480 --> 00:48:28,400
temporary functions are like a higher

1339
00:48:26,640 --> 00:48:30,480
degree polynomials

1340
00:48:28,400 --> 00:48:35,040
so i think that's probably the main

1341
00:48:30,480 --> 00:48:37,680
motivation of this word

1342
00:48:35,040 --> 00:48:39,680
great thank you uh the next question is

1343
00:48:37,680 --> 00:48:41,520
from microsoft

1344
00:48:39,680 --> 00:48:43,680
uh what is the rate of your

1345
00:48:41,520 --> 00:48:44,240
non-malleable code how does it compare

1346
00:48:43,680 --> 00:48:47,680
to other

1347
00:48:44,240 --> 00:48:50,959
non-valuable codes so

1348
00:48:47,680 --> 00:48:56,480
the rate of our number code is

1349
00:48:50,960 --> 00:48:58,000
uh so if we want to

1350
00:48:56,480 --> 00:48:59,760
construct a numerical code which is

1351
00:48:58,000 --> 00:49:02,559
secure against like

1352
00:48:59,760 --> 00:49:05,119
polynomials and variables then the rate

1353
00:49:02,559 --> 00:49:08,559
of our number of code will be

1354
00:49:05,119 --> 00:49:12,400
1 over n where n is the number of

1355
00:49:08,559 --> 00:49:14,240
variables but and

1356
00:49:12,400 --> 00:49:15,680
i don't think we have a proper

1357
00:49:14,240 --> 00:49:18,160
comparison between

1358
00:49:15,680 --> 00:49:19,919
our numerable code and other number code

1359
00:49:18,160 --> 00:49:22,319
because the temporary functions we are

1360
00:49:19,920 --> 00:49:25,440
considering are different

1361
00:49:22,319 --> 00:49:27,040
so yeah but in some

1362
00:49:25,440 --> 00:49:29,520
other temporary function families such

1363
00:49:27,040 --> 00:49:32,800
as the split state model

1364
00:49:29,520 --> 00:49:34,880
they can achieve the constant rate

1365
00:49:32,800 --> 00:49:36,160
number code in a two split state model

1366
00:49:34,880 --> 00:49:37,680
but i think it's

1367
00:49:36,160 --> 00:49:40,558
incomparable because the temperature

1368
00:49:37,680 --> 00:49:40,558
functions are different

1369
00:49:43,520 --> 00:49:50,160
um okay uh another question

1370
00:49:46,559 --> 00:49:52,240
uh from sriti sekker would you be able

1371
00:49:50,160 --> 00:49:53,598
to get leakage from your non-valuable

1372
00:49:52,240 --> 00:49:57,040
secret sharing

1373
00:49:53,599 --> 00:50:01,440
also what is its rate so i guess again

1374
00:49:57,040 --> 00:50:05,520
questions about rates uh yes so

1375
00:50:01,440 --> 00:50:09,920
actually the same uh secretary scheme

1376
00:50:05,520 --> 00:50:13,040
is secure so it is leakage resilient to

1377
00:50:09,920 --> 00:50:16,559
a fine leakage but it is not really

1378
00:50:13,040 --> 00:50:19,839
a leakage region available to uh

1379
00:50:16,559 --> 00:50:23,040
any kind of a fine leakage so uh

1380
00:50:19,839 --> 00:50:26,400
to achieve the nominability we allow

1381
00:50:23,040 --> 00:50:27,040
certain kind of a fine leakage and some

1382
00:50:26,400 --> 00:50:29,520
examples

1383
00:50:27,040 --> 00:50:31,359
include like just rebuilding some of the

1384
00:50:29,520 --> 00:50:33,759
shares to the adversary

1385
00:50:31,359 --> 00:50:35,359
uh like like what we show in this

1386
00:50:33,760 --> 00:50:38,720
adaptive choice slice

1387
00:50:35,359 --> 00:50:40,558
but there are certain kind of

1388
00:50:38,720 --> 00:50:42,078
a fine leakage which will break the

1389
00:50:40,559 --> 00:50:44,240
nominability so

1390
00:50:42,079 --> 00:50:46,319
we don't want to include this as like

1391
00:50:44,240 --> 00:50:48,959
part of our main result because

1392
00:50:46,319 --> 00:50:49,839
it will be it'll be weird to like

1393
00:50:48,960 --> 00:50:53,119
prohibit

1394
00:50:49,839 --> 00:50:53,119
certain kind of affinity

1395
00:50:53,680 --> 00:50:57,279
but uh it is they could uh it is

1396
00:50:55,520 --> 00:51:00,559
nominable even

1397
00:50:57,280 --> 00:51:01,839
uh if the adversary can get like some

1398
00:51:00,559 --> 00:51:04,319
kind of a finding

1399
00:51:01,839 --> 00:51:04,319
i would say

1400
00:51:05,200 --> 00:51:08,879
thank you um are there any other

1401
00:51:08,160 --> 00:51:11,920
questions

1402
00:51:08,880 --> 00:51:11,920
any follow-ups

1403
00:51:16,240 --> 00:51:20,078
okay i think since we have a few more

1404
00:51:18,720 --> 00:51:22,319
minutes

1405
00:51:20,079 --> 00:51:24,800
i would open the floor to any questions

1406
00:51:22,319 --> 00:51:26,720
for any of the speakers if you forgot to

1407
00:51:24,800 --> 00:51:30,000
ask a question for any of the previous

1408
00:51:26,720 --> 00:51:30,000
speakers also feel free

1409
00:51:30,160 --> 00:51:32,480
thank you

1410
00:51:34,400 --> 00:51:37,440
i think this is a question again for the

1411
00:51:36,559 --> 00:51:40,880
last speaker

1412
00:51:37,440 --> 00:51:40,880
is this already implemented

1413
00:51:44,079 --> 00:51:48,160
okay i think we have more questions you

1414
00:51:46,480 --> 00:51:51,839
could you should

1415
00:51:48,160 --> 00:51:53,440
stay on um so okay so then we have a

1416
00:51:51,839 --> 00:51:55,839
question from evgeny

1417
00:51:53,440 --> 00:51:58,880
uh how complex is your encoding and

1418
00:51:55,839 --> 00:52:02,160
deciding as a polynomial

1419
00:51:58,880 --> 00:52:02,160
uh okay so

1420
00:52:02,240 --> 00:52:05,598
uh okay maybe let me share my slides

1421
00:52:05,200 --> 00:52:10,960
again

1422
00:52:05,599 --> 00:52:10,960
for the uh decoding for the construction

1423
00:52:17,760 --> 00:52:21,760
so are we

1424
00:52:25,280 --> 00:52:31,760
so our construction in in this form so

1425
00:52:28,319 --> 00:52:32,720
uh in the based on the of swami

1426
00:52:31,760 --> 00:52:35,680
reduction

1427
00:52:32,720 --> 00:52:37,359
uh the decoding function will be the

1428
00:52:35,680 --> 00:52:40,240
nominable extractor

1429
00:52:37,359 --> 00:52:40,799
and our numerical extractor is basically

1430
00:52:40,240 --> 00:52:44,000
apply

1431
00:52:40,800 --> 00:52:46,240
a polynomial on the input and then take

1432
00:52:44,000 --> 00:52:46,559
the less m bit of the polynomial output

1433
00:52:46,240 --> 00:52:49,680
as

1434
00:52:46,559 --> 00:52:51,760
our output and so this

1435
00:52:49,680 --> 00:52:52,799
is the decoding function it's pretty

1436
00:52:51,760 --> 00:52:55,760
simple

1437
00:52:52,800 --> 00:52:58,160
and the encoding function will be an

1438
00:52:55,760 --> 00:53:01,119
efficient inverter for

1439
00:52:58,160 --> 00:53:01,839
this construction and we achieved this

1440
00:53:01,119 --> 00:53:05,760
by

1441
00:53:01,839 --> 00:53:09,040
adapting a rejection sampling algorithm

1442
00:53:05,760 --> 00:53:12,240
by uh triaxia and chocolati to

1443
00:53:09,040 --> 00:53:14,160
our settings so and it's also not very

1444
00:53:12,240 --> 00:53:17,200
hard it's just like

1445
00:53:14,160 --> 00:53:20,000
every time we choose a hyper plan

1446
00:53:17,200 --> 00:53:20,319
and consider the intersection of it with

1447
00:53:20,000 --> 00:53:23,920
uh

1448
00:53:20,319 --> 00:53:27,759
the with a fine space and then

1449
00:53:23,920 --> 00:53:30,880
try to solve the

1450
00:53:27,760 --> 00:53:33,359
univariate polynomials so it's also

1451
00:53:30,880 --> 00:53:33,359
efficient

1452
00:53:35,359 --> 00:53:42,319
great thank you any

1453
00:53:38,880 --> 00:53:44,720
other questions

1454
00:53:42,319 --> 00:53:47,680
or the speaker or any of the previous

1455
00:53:44,720 --> 00:53:47,680
speakers as well

1456
00:53:53,680 --> 00:54:01,520
okay go okay evgeny has more follow-ups

1457
00:53:58,079 --> 00:54:04,960
how low is q uh so this q

1458
00:54:01,520 --> 00:54:08,079
is polynomial in uh

1459
00:54:04,960 --> 00:54:11,520
an n which is a number of variables

1460
00:54:08,079 --> 00:54:16,400
and d which is a degree and then 2 3 m

1461
00:54:11,520 --> 00:54:20,640
where m is the length of the message

1462
00:54:16,400 --> 00:54:20,640
and also polynomial in one over epsilon

1463
00:54:23,599 --> 00:54:26,079
thank you

1464
00:54:27,359 --> 00:54:30,480
other questions

1465
00:54:31,200 --> 00:54:35,040
going once going first

1466
00:54:37,040 --> 00:54:40,160
uh i think i don't see any other

1467
00:54:39,440 --> 00:54:42,880
questions

1468
00:54:40,160 --> 00:54:44,000
david do you have anything on your

1469
00:54:42,880 --> 00:54:47,839
spouse i think we are

1470
00:54:44,000 --> 00:54:47,839
set i think all of myself

1471
00:54:48,079 --> 00:54:51,760
great well thanks everyone for attending

1472
00:54:50,880 --> 00:54:55,240
this

1473
00:54:51,760 --> 00:54:58,240
session and enjoy the rest of the

1474
00:54:55,240 --> 00:54:58,240
conference

