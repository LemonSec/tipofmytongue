1
00:00:01,680 --> 00:00:05,040
hey everyone welcome to this talk

2
00:00:03,520 --> 00:00:06,798
and thanks for your interest in dynamic

3
00:00:05,040 --> 00:00:08,720
decentralized functional encryption

4
00:00:06,799 --> 00:00:10,960
this is joint work with jeremy shotar

5
00:00:08,720 --> 00:00:12,000
roman gay john gilfan and david

6
00:00:10,960 --> 00:00:13,920
poncheval

7
00:00:12,000 --> 00:00:15,599
my name is eduardo for sons and i worked

8
00:00:13,920 --> 00:00:17,039
on this airport where i was at economic

9
00:00:15,599 --> 00:00:18,240
superior in paris

10
00:00:17,039 --> 00:00:20,240
and in part where i was at carnegie

11
00:00:18,240 --> 00:00:22,799
mellon university in pittsburgh and i'll

12
00:00:20,240 --> 00:00:24,159
be giving the talk today

13
00:00:22,800 --> 00:00:25,840
i think we can all agree that one

14
00:00:24,160 --> 00:00:27,359
superior of computer science has had

15
00:00:25,840 --> 00:00:28,640
unbelievable growth during the last two

16
00:00:27,359 --> 00:00:30,400
decades or so

17
00:00:28,640 --> 00:00:32,000
and unfortunately for this conference

18
00:00:30,400 --> 00:00:32,800
you probably missed out

19
00:00:32,000 --> 00:00:34,640
because i'm not talking about

20
00:00:32,800 --> 00:00:35,599
cryptography i'm talking about machine

21
00:00:34,640 --> 00:00:36,800
learning

22
00:00:35,600 --> 00:00:38,879
the convergence of the massive

23
00:00:36,800 --> 00:00:40,480
availability of many types of data

24
00:00:38,879 --> 00:00:42,480
the affordability of highly parallel

25
00:00:40,480 --> 00:00:44,078
compute equipment and algorithmic

26
00:00:42,480 --> 00:00:45,440
advances relevant to machine learning

27
00:00:44,079 --> 00:00:47,760
have issued in a new wave of very

28
00:00:45,440 --> 00:00:49,440
successful intelligent products

29
00:00:47,760 --> 00:00:50,800
of course it has also raised enormous

30
00:00:49,440 --> 00:00:52,160
privacy concerns

31
00:00:50,800 --> 00:00:54,000
because these machine learning models

32
00:00:52,160 --> 00:00:55,839
are trained using databases

33
00:00:54,000 --> 00:00:58,800
of sometimes very personal data that are

34
00:00:55,840 --> 00:01:00,879
under control of a few institutions

35
00:00:58,800 --> 00:01:02,320
because it's so hard to argue against

36
00:01:00,879 --> 00:01:03,358
the benefits of better artificial

37
00:01:02,320 --> 00:01:04,799
intelligence

38
00:01:03,359 --> 00:01:06,560
it's unlikely that consumers would

39
00:01:04,799 --> 00:01:07,520
prefer a system where no data mining

40
00:01:06,560 --> 00:01:09,119
occurs

41
00:01:07,520 --> 00:01:10,880
but perhaps cryptography can provide a

42
00:01:09,119 --> 00:01:12,400
solution that protects privacy

43
00:01:10,880 --> 00:01:14,479
without sacrificing the benefits of

44
00:01:12,400 --> 00:01:16,960
machine learning

45
00:01:14,479 --> 00:01:18,400
now one might ask since clearly we're

46
00:01:16,960 --> 00:01:20,720
going to be looking at some form of

47
00:01:18,400 --> 00:01:22,320
computation involving encrypted data

48
00:01:20,720 --> 00:01:24,720
whether it's something that's already

49
00:01:22,320 --> 00:01:26,240
solved by foliomorphic encryption

50
00:01:24,720 --> 00:01:28,640
and while you can certainly construct

51
00:01:26,240 --> 00:01:30,079
solutions to this problem from fhe

52
00:01:28,640 --> 00:01:31,520
i would like to argue that it's not the

53
00:01:30,079 --> 00:01:33,520
ideal theoretical cryptographic

54
00:01:31,520 --> 00:01:35,840
primitive for our scenario

55
00:01:33,520 --> 00:01:36,880
recall fhe is for computing on data you

56
00:01:35,840 --> 00:01:38,479
can't see

57
00:01:36,880 --> 00:01:40,240
so in fhe you would typically have a

58
00:01:38,479 --> 00:01:41,439
server competing on data that is owned

59
00:01:40,240 --> 00:01:43,199
by a client

60
00:01:41,439 --> 00:01:44,639
and a client because it knows the secret

61
00:01:43,200 --> 00:01:46,079
key can decrypt the result of the

62
00:01:44,640 --> 00:01:47,280
computation

63
00:01:46,079 --> 00:01:49,199
it makes sense for offloading

64
00:01:47,280 --> 00:01:51,200
computation to a server whether for

65
00:01:49,200 --> 00:01:53,360
performance reasons or because the model

66
00:01:51,200 --> 00:01:55,520
is too large for the client to store

67
00:01:53,360 --> 00:01:57,119
but in the scenario we are describing we

68
00:01:55,520 --> 00:01:59,200
want the server to run the computations

69
00:01:57,119 --> 00:02:01,680
but also to get back the result

70
00:01:59,200 --> 00:02:03,680
fha can't achieve that or at least not

71
00:02:01,680 --> 00:02:05,360
in an uninteractive way

72
00:02:03,680 --> 00:02:07,840
and to be clear what we mean by an

73
00:02:05,360 --> 00:02:09,280
interactive here is that in the long run

74
00:02:07,840 --> 00:02:10,640
you should just be sending a single

75
00:02:09,280 --> 00:02:11,599
cipher text of the data you just

76
00:02:10,639 --> 00:02:13,440
generated

77
00:02:11,599 --> 00:02:14,879
and then it's up to the server to gather

78
00:02:13,440 --> 00:02:16,560
the data of the other parties and to

79
00:02:14,879 --> 00:02:18,399
perform the computations

80
00:02:16,560 --> 00:02:20,319
an interactivity matters when your

81
00:02:18,400 --> 00:02:22,000
clients are regular internet users

82
00:02:20,319 --> 00:02:23,839
who will be on enough and are unlikely

83
00:02:22,000 --> 00:02:25,280
to have the time or resources

84
00:02:23,840 --> 00:02:28,720
to participate in a computationally

85
00:02:25,280 --> 00:02:30,319
heavy massively multi-party protocol

86
00:02:28,720 --> 00:02:31,840
so today we will be talking about

87
00:02:30,319 --> 00:02:33,760
something else

88
00:02:31,840 --> 00:02:36,160
something that lets the server aggregate

89
00:02:33,760 --> 00:02:39,040
our data with that of other participants

90
00:02:36,160 --> 00:02:40,879
and in an interactive way that's dynamic

91
00:02:39,040 --> 00:02:44,160
decentralized functional encryption

92
00:02:40,879 --> 00:02:44,160
or ddfe for short

93
00:02:44,640 --> 00:02:48,958
so here's the plan for today first we'll

94
00:02:47,200 --> 00:02:50,079
briefly talk about functional encryption

95
00:02:48,959 --> 00:02:52,800
its history

96
00:02:50,080 --> 00:02:54,080
and how it relates to the dfe then we'll

97
00:02:52,800 --> 00:02:55,599
define the dfe

98
00:02:54,080 --> 00:02:57,920
both formally and with some helpful

99
00:02:55,599 --> 00:02:59,760
examples and then

100
00:02:57,920 --> 00:03:01,518
we'll give constructions of ddfe for a

101
00:02:59,760 --> 00:03:03,040
few functionalities

102
00:03:01,519 --> 00:03:05,599
we'll start by looking at something we

103
00:03:03,040 --> 00:03:07,599
call decentralized sum

104
00:03:05,599 --> 00:03:09,040
in the process of building that i'll

105
00:03:07,599 --> 00:03:11,040
notice that we fall a bit short of the

106
00:03:09,040 --> 00:03:12,640
security guarantees we want

107
00:03:11,040 --> 00:03:14,640
then it would be nice to start by adding

108
00:03:12,640 --> 00:03:16,839
something to our toolbox

109
00:03:14,640 --> 00:03:18,640
that tool or the all-or-nothing

110
00:03:16,840 --> 00:03:21,440
encapsulation and we will show how to

111
00:03:18,640 --> 00:03:23,440
build one from identity-based encryption

112
00:03:21,440 --> 00:03:25,760
finally we'll present a more complex

113
00:03:23,440 --> 00:03:26,799
primitive it's a decentralized inner

114
00:03:25,760 --> 00:03:28,239
product scheme

115
00:03:26,799 --> 00:03:31,360
and we'll try to give an overview of the

116
00:03:28,239 --> 00:03:33,120
key ideas behind our construction

117
00:03:31,360 --> 00:03:35,120
the history of functional encryption in

118
00:03:33,120 --> 00:03:37,040
a sense was all the way back to the

119
00:03:35,120 --> 00:03:38,480
invention of public key encryption

120
00:03:37,040 --> 00:03:41,120
public encryption is one of the most

121
00:03:38,480 --> 00:03:44,000
basic forms of functional encryption

122
00:03:41,120 --> 00:03:46,159
in 2001 we get identity-based encryption

123
00:03:44,000 --> 00:03:48,159
which allows for some access control

124
00:03:46,159 --> 00:03:50,319
and then in 2006 attribute-based

125
00:03:48,159 --> 00:03:53,040
encryption which is stronger and allows

126
00:03:50,319 --> 00:03:54,798
for more complex forms of access control

127
00:03:53,040 --> 00:03:56,079
and is alternated in 2011 with

128
00:03:54,799 --> 00:03:58,080
functional encryption

129
00:03:56,080 --> 00:04:00,480
which is even stronger and allows for

130
00:03:58,080 --> 00:04:01,599
computations on the text data

131
00:04:00,480 --> 00:04:03,920
but there's something deeper about

132
00:04:01,599 --> 00:04:05,760
functional encryption it's interesting

133
00:04:03,920 --> 00:04:06,958
because it's not just a stronger

134
00:04:05,760 --> 00:04:08,798
more powerful variant of its

135
00:04:06,959 --> 00:04:11,439
predecessors

136
00:04:08,799 --> 00:04:13,360
functional encryption is a framework

137
00:04:11,439 --> 00:04:15,280
what's great about functional encryption

138
00:04:13,360 --> 00:04:16,639
is that while the definition allows for

139
00:04:15,280 --> 00:04:17,839
schemes that would allow for general

140
00:04:16,639 --> 00:04:20,400
computations

141
00:04:17,839 --> 00:04:21,758
and general access control structures it

142
00:04:20,399 --> 00:04:22,960
still captures schemes that are much

143
00:04:21,759 --> 00:04:24,800
more limited

144
00:04:22,960 --> 00:04:26,400
public encryption identity-based

145
00:04:24,800 --> 00:04:26,960
encryption and attribute-based

146
00:04:26,400 --> 00:04:29,039
encryption

147
00:04:26,960 --> 00:04:30,400
are all forms of functional encryption

148
00:04:29,040 --> 00:04:31,520
but they are not instances of one

149
00:04:30,400 --> 00:04:33,520
another

150
00:04:31,520 --> 00:04:35,120
a great fit of functional encryption is

151
00:04:33,520 --> 00:04:37,120
giving cryptographers a common language

152
00:04:35,120 --> 00:04:38,639
to use to describe many possibly very

153
00:04:37,120 --> 00:04:40,560
different schemes

154
00:04:38,639 --> 00:04:42,560
all it takes is giving the functionality

155
00:04:40,560 --> 00:04:45,440
of the scheme and then the definitions

156
00:04:42,560 --> 00:04:47,199
and security game follow immediately

157
00:04:45,440 --> 00:04:48,560
still functional encryption has its

158
00:04:47,199 --> 00:04:49,919
limitations

159
00:04:48,560 --> 00:04:52,000
there are two that are relevant to what

160
00:04:49,919 --> 00:04:53,599
we're talking about today

161
00:04:52,000 --> 00:04:55,199
one is that it doesn't really allow for

162
00:04:53,600 --> 00:04:56,400
computations that involve multiple

163
00:04:55,199 --> 00:04:58,000
parties

164
00:04:56,400 --> 00:04:59,919
that's a non-starter for what we talked

165
00:04:58,000 --> 00:05:01,840
about earlier aggregating data from

166
00:04:59,919 --> 00:05:04,159
multiple users

167
00:05:01,840 --> 00:05:05,359
multi-input and multi-client variants of

168
00:05:04,160 --> 00:05:07,520
functional encryption

169
00:05:05,360 --> 00:05:09,199
were introduced to address this point

170
00:05:07,520 --> 00:05:10,560
but they inherited another issue of

171
00:05:09,199 --> 00:05:12,800
functional encryption

172
00:05:10,560 --> 00:05:14,000
there is a master secret key the order

173
00:05:12,800 --> 00:05:16,639
of which can basically learn

174
00:05:14,000 --> 00:05:18,080
anything it wants we tried moving away

175
00:05:16,639 --> 00:05:20,320
from this in 2018

176
00:05:18,080 --> 00:05:21,919
with decentralized multi-client

177
00:05:20,320 --> 00:05:23,680
functional encryption

178
00:05:21,919 --> 00:05:25,520
but the primitive we defined required

179
00:05:23,680 --> 00:05:26,880
the set of participants to be set at the

180
00:05:25,520 --> 00:05:28,560
beginning of time

181
00:05:26,880 --> 00:05:32,000
and no new members could join from that

182
00:05:28,560 --> 00:05:34,880
point on so it was not dynamic

183
00:05:32,000 --> 00:05:36,560
ad hoc multi-input functional encryption

184
00:05:34,880 --> 00:05:39,600
came in a year later

185
00:05:36,560 --> 00:05:41,199
it was dynamic but in a sense it lacked

186
00:05:39,600 --> 00:05:43,520
the full definitional power

187
00:05:41,199 --> 00:05:44,960
that functional encryption had brought

188
00:05:43,520 --> 00:05:45,919
the definitions are tailored to their

189
00:05:44,960 --> 00:05:47,440
constructions

190
00:05:45,919 --> 00:05:48,880
and that framework cannot capture some

191
00:05:47,440 --> 00:05:50,000
of the functionalities we'll present

192
00:05:48,880 --> 00:05:52,000
here today

193
00:05:50,000 --> 00:05:53,440
now that you have the context i start

194
00:05:52,000 --> 00:05:56,960
talking about what ddf

195
00:05:53,440 --> 00:06:00,639
is we'll start with some examples

196
00:05:56,960 --> 00:06:03,120
so we have four people alice bub charlie

197
00:06:00,639 --> 00:06:04,720
and diane they have some pictures of

198
00:06:03,120 --> 00:06:06,720
themselves that they're probably storing

199
00:06:04,720 --> 00:06:08,639
on some levi's

200
00:06:06,720 --> 00:06:10,880
now those pictures would be valuable to

201
00:06:08,639 --> 00:06:12,560
a company it can use deep learning to

202
00:06:10,880 --> 00:06:14,319
extract valuable intelligence from the

203
00:06:12,560 --> 00:06:16,960
data

204
00:06:14,319 --> 00:06:19,039
however sending the data directly to the

205
00:06:16,960 --> 00:06:20,638
company so it can mine it

206
00:06:19,039 --> 00:06:22,400
well that could be detrimental to the

207
00:06:20,639 --> 00:06:24,479
privacy of our subjects

208
00:06:22,400 --> 00:06:25,919
they might not agree to participate or

209
00:06:24,479 --> 00:06:28,240
be unhappy about it if it happens

210
00:06:25,919 --> 00:06:30,240
without their consent

211
00:06:28,240 --> 00:06:32,400
lucky for them as you may have noticed

212
00:06:30,240 --> 00:06:35,520
earlier they're dealing with

213
00:06:32,400 --> 00:06:37,039
not very evil corp and that firm decided

214
00:06:35,520 --> 00:06:39,120
it would use the dfe

215
00:06:37,039 --> 00:06:42,400
so it can achieve its objectives while

216
00:06:39,120 --> 00:06:45,199
protecting its customers privacy

217
00:06:42,400 --> 00:06:47,198
full disclosure here training an actual

218
00:06:45,199 --> 00:06:48,560
neural network

219
00:06:47,199 --> 00:06:50,319
it's not something that's realistic to

220
00:06:48,560 --> 00:06:51,680
do with the cryptographic tools we have

221
00:06:50,319 --> 00:06:53,440
today

222
00:06:51,680 --> 00:06:55,280
so this example is about what the dream

223
00:06:53,440 --> 00:06:57,039
application would be what we're working

224
00:06:55,280 --> 00:06:59,039
towards

225
00:06:57,039 --> 00:07:01,599
so all of our friends here would encrypt

226
00:06:59,039 --> 00:07:03,360
the data under

227
00:07:01,599 --> 00:07:04,880
there ddfe some metadata associated with

228
00:07:03,360 --> 00:07:06,479
its ciphertext

229
00:07:04,880 --> 00:07:08,000
namely the date and the set of

230
00:07:06,479 --> 00:07:10,560
participants

231
00:07:08,000 --> 00:07:12,240
and the policy will be let's say that

232
00:07:10,560 --> 00:07:14,560
data can only be aggregated

233
00:07:12,240 --> 00:07:15,280
between participants that all agree on

234
00:07:14,560 --> 00:07:18,400
the date

235
00:07:15,280 --> 00:07:20,239
and the set of participants

236
00:07:18,400 --> 00:07:22,159
so they send off the cipher text to the

237
00:07:20,240 --> 00:07:24,240
not very evil corp

238
00:07:22,160 --> 00:07:25,599
and at that point these are totally

239
00:07:24,240 --> 00:07:27,440
opaque to the company

240
00:07:25,599 --> 00:07:29,520
it might as well be your favorite flavor

241
00:07:27,440 --> 00:07:31,120
of ncp encryption

242
00:07:29,520 --> 00:07:32,799
that's because the company has no

243
00:07:31,120 --> 00:07:34,479
functional keys

244
00:07:32,800 --> 00:07:36,720
so the company has to go back to the

245
00:07:34,479 --> 00:07:38,560
participants for that

246
00:07:36,720 --> 00:07:39,840
in this case the participants are

247
00:07:38,560 --> 00:07:42,319
willing to help

248
00:07:39,840 --> 00:07:45,039
so they each independently compute a

249
00:07:42,319 --> 00:07:47,039
functional decryption key of their own

250
00:07:45,039 --> 00:07:48,159
the key is associated with the set of

251
00:07:47,039 --> 00:07:49,840
participants

252
00:07:48,160 --> 00:07:51,680
and a specific method for training a

253
00:07:49,840 --> 00:07:53,919
neural network

254
00:07:51,680 --> 00:07:56,560
again all of those will have to match

255
00:07:53,919 --> 00:07:59,039
across all participants

256
00:07:56,560 --> 00:08:01,440
and now the cooperation has all it needs

257
00:07:59,039 --> 00:08:03,039
to start working

258
00:08:01,440 --> 00:08:05,599
using the functional keys on the

259
00:08:03,039 --> 00:08:06,800
ciphertexts it can extract knowledge

260
00:08:05,599 --> 00:08:09,360
from the data

261
00:08:06,800 --> 00:08:10,720
and nothing more it doesn't get to see

262
00:08:09,360 --> 00:08:13,840
the plaintext data

263
00:08:10,720 --> 00:08:16,400
only the result of the training

264
00:08:13,840 --> 00:08:18,400
okay that's it for our example now let's

265
00:08:16,400 --> 00:08:22,239
get four more shall we

266
00:08:18,400 --> 00:08:25,758
for a ddfe scheme the third of key is k

267
00:08:22,240 --> 00:08:27,280
and a set of messages m a dfe scheme

268
00:08:25,759 --> 00:08:28,720
will first be characterized by its

269
00:08:27,280 --> 00:08:30,318
functionality

270
00:08:28,720 --> 00:08:32,399
it's essentially the set of functions

271
00:08:30,319 --> 00:08:34,320
the scheme can compute

272
00:08:32,399 --> 00:08:36,799
and it also describes how different keys

273
00:08:34,320 --> 00:08:39,839
enable different functions

274
00:08:36,799 --> 00:08:40,079
for the dfe a functionality takes a list

275
00:08:39,839 --> 00:08:42,959
of

276
00:08:40,080 --> 00:08:45,839
public key functional key pairs and a

277
00:08:42,958 --> 00:08:47,518
list of public key message pairs

278
00:08:45,839 --> 00:08:49,680
the way to think about it is that you'll

279
00:08:47,519 --> 00:08:50,959
be mixing a bunch of keys and a bunch of

280
00:08:49,680 --> 00:08:53,599
messages together

281
00:08:50,959 --> 00:08:55,680
to get some value out as we saw earlier

282
00:08:53,600 --> 00:08:58,160
with the neural network training

283
00:08:55,680 --> 00:08:59,519
and each key and each message is

284
00:08:58,160 --> 00:09:01,839
fundamentally tied

285
00:08:59,519 --> 00:09:03,519
to the identity of its creator so that

286
00:09:01,839 --> 00:09:06,720
we can tell when someone is allowing

287
00:09:03,519 --> 00:09:09,200
computation on their own data

288
00:09:06,720 --> 00:09:10,399
now for the flow of things you would

289
00:09:09,200 --> 00:09:13,279
start with a setup

290
00:09:10,399 --> 00:09:15,279
which generates some shared parameters

291
00:09:13,279 --> 00:09:18,880
maybe everyone agrees on a hash function

292
00:09:15,279 --> 00:09:21,279
analytical parameters and so on

293
00:09:18,880 --> 00:09:24,160
you do this once and then everyone can

294
00:09:21,279 --> 00:09:26,399
generate their public private key pair

295
00:09:24,160 --> 00:09:28,079
they advertise the public key that's

296
00:09:26,399 --> 00:09:30,320
their identity for all intents and

297
00:09:28,080 --> 00:09:31,440
purposes here

298
00:09:30,320 --> 00:09:34,480
and they keep the secret key to

299
00:09:31,440 --> 00:09:38,160
themselves they'll use it for encrypting

300
00:09:34,480 --> 00:09:40,399
and generating functional keys finally

301
00:09:38,160 --> 00:09:41,360
anyone can decrypt once they have enough

302
00:09:40,399 --> 00:09:44,399
ciphertexts

303
00:09:41,360 --> 00:09:46,959
and enough functional keys that's maybe

304
00:09:44,399 --> 00:09:48,959
a bit terse let's see how we can connect

305
00:09:46,959 --> 00:09:50,560
those concepts to the example we saw

306
00:09:48,959 --> 00:09:52,800
earlier

307
00:09:50,560 --> 00:09:54,399
so in our case you'll remember that our

308
00:09:52,800 --> 00:09:55,439
participants would embed into their

309
00:09:54,399 --> 00:09:57,360
functional key

310
00:09:55,440 --> 00:09:58,560
both the set of participants as they

311
00:09:57,360 --> 00:10:01,519
perceived it

312
00:09:58,560 --> 00:10:03,359
and the training algorithm the set of

313
00:10:01,519 --> 00:10:05,040
participants would really be a set of

314
00:10:03,360 --> 00:10:07,040
public keys

315
00:10:05,040 --> 00:10:08,399
and maybe that algorithm was represented

316
00:10:07,040 --> 00:10:11,120
as a circuit

317
00:10:08,399 --> 00:10:11,680
hence the set of keys here the cartesian

318
00:10:11,120 --> 00:10:14,160
product

319
00:10:11,680 --> 00:10:16,399
of the set of sets of public keys and a

320
00:10:14,160 --> 00:10:18,800
set of circuits

321
00:10:16,399 --> 00:10:19,839
the message contained an image a date

322
00:10:18,800 --> 00:10:22,319
and again

323
00:10:19,839 --> 00:10:25,120
a set of participants so the set of

324
00:10:22,320 --> 00:10:28,240
messages is pretty straightforward

325
00:10:25,120 --> 00:10:30,399
now clearly we want to hide the image

326
00:10:28,240 --> 00:10:32,000
but perhaps those other attributes don't

327
00:10:30,399 --> 00:10:34,160
need to be hidden

328
00:10:32,000 --> 00:10:35,360
that's all okay it can be expressed with

329
00:10:34,160 --> 00:10:36,480
the functionality

330
00:10:35,360 --> 00:10:39,040
as it would be with traditional

331
00:10:36,480 --> 00:10:40,079
functional encryption

332
00:10:39,040 --> 00:10:43,199
now let's take a look at the

333
00:10:40,079 --> 00:10:46,079
functionality it's a bit ugly at first

334
00:10:43,200 --> 00:10:48,480
but we can break it down together the

335
00:10:46,079 --> 00:10:51,519
first argument is a set of keys

336
00:10:48,480 --> 00:10:52,880
associated with their users recall that

337
00:10:51,519 --> 00:10:55,440
the keys are composed of a set of

338
00:10:52,880 --> 00:10:58,320
participants and a circuit

339
00:10:55,440 --> 00:10:59,600
here the keys are not indexed by pk so

340
00:10:58,320 --> 00:11:01,519
it's very simple

341
00:10:59,600 --> 00:11:02,880
they are the same for all participants

342
00:11:01,519 --> 00:11:04,240
in the set

343
00:11:02,880 --> 00:11:07,040
they contain that same set of

344
00:11:04,240 --> 00:11:09,360
participants and a circuit that performs

345
00:11:07,040 --> 00:11:12,800
neural network training

346
00:11:09,360 --> 00:11:15,440
up next we have the messages here

347
00:11:12,800 --> 00:11:16,399
again everyone agrees on the date and

348
00:11:15,440 --> 00:11:17,839
everyone agrees on the set of

349
00:11:16,399 --> 00:11:21,360
participants

350
00:11:17,839 --> 00:11:23,839
but each participant has their own image

351
00:11:21,360 --> 00:11:25,519
and so the result of that evaluation

352
00:11:23,839 --> 00:11:26,720
will be a neural network trained on a

353
00:11:25,519 --> 00:11:29,760
set of images

354
00:11:26,720 --> 00:11:31,440
simple as that notice that this is a

355
00:11:29,760 --> 00:11:33,519
simple functionality

356
00:11:31,440 --> 00:11:36,240
in that the set of users who provide

357
00:11:33,519 --> 00:11:38,560
keys is the same as the set of users

358
00:11:36,240 --> 00:11:42,399
who provide messages while our framework

359
00:11:38,560 --> 00:11:44,079
doesn't actually require that

360
00:11:42,399 --> 00:11:45,519
now that we've had an overview of what

361
00:11:44,079 --> 00:11:48,160
ddfe is

362
00:11:45,519 --> 00:11:52,320
we can move on to actual constructions

363
00:11:48,160 --> 00:11:54,880
we'll start with decentralized sum

364
00:11:52,320 --> 00:11:56,720
at a high level decentralized sum is

365
00:11:54,880 --> 00:11:58,800
about computing sums

366
00:11:56,720 --> 00:12:00,399
or to be accurate repeated group

367
00:11:58,800 --> 00:12:03,839
operations in finite

368
00:12:00,399 --> 00:12:06,880
billing groups in practice the group a

369
00:12:03,839 --> 00:12:08,320
will often be that of modular integers

370
00:12:06,880 --> 00:12:09,839
so our messages will contain a group

371
00:12:08,320 --> 00:12:12,079
element that we want to aggregate with

372
00:12:09,839 --> 00:12:13,760
other people's group elements

373
00:12:12,079 --> 00:12:15,199
we need to specify the set of people we

374
00:12:13,760 --> 00:12:17,600
want to aggregate with

375
00:12:15,200 --> 00:12:19,519
and we'll want to agree on a label in

376
00:12:17,600 --> 00:12:21,600
practice this is something that might be

377
00:12:19,519 --> 00:12:23,600
set to the date so that if we want to

378
00:12:21,600 --> 00:12:25,519
aggregate different data later

379
00:12:23,600 --> 00:12:26,880
an attacker can come in and mix and

380
00:12:25,519 --> 00:12:28,000
match our data from the different

381
00:12:26,880 --> 00:12:30,800
aggregations

382
00:12:28,000 --> 00:12:32,720
to learn more than they should what's

383
00:12:30,800 --> 00:12:34,479
maybe striking about this functionality

384
00:12:32,720 --> 00:12:36,240
is that there are no keys only

385
00:12:34,480 --> 00:12:38,560
ciphertexts

386
00:12:36,240 --> 00:12:40,399
that means any functionality evaluation

387
00:12:38,560 --> 00:12:41,518
will have an empty list for a list of

388
00:12:40,399 --> 00:12:45,200
keys

389
00:12:41,519 --> 00:12:47,040
we denote that empty list by epsilon

390
00:12:45,200 --> 00:12:48,399
even in traditional single input

391
00:12:47,040 --> 00:12:50,399
functional encryption

392
00:12:48,399 --> 00:12:51,839
there's a key epsilon that serves to

393
00:12:50,399 --> 00:12:53,200
capture the default leakage from

394
00:12:51,839 --> 00:12:54,959
ciphertexts

395
00:12:53,200 --> 00:12:56,320
but in a single input setting that's

396
00:12:54,959 --> 00:12:59,839
usually something limited

397
00:12:56,320 --> 00:13:02,079
like the lengths of the plain text here

398
00:12:59,839 --> 00:13:03,680
in your multi-user setting we can have

399
00:13:02,079 --> 00:13:05,359
more complex data leakage

400
00:13:03,680 --> 00:13:07,120
depending on the set of ciphertexts that

401
00:13:05,360 --> 00:13:09,440
are matched together

402
00:13:07,120 --> 00:13:11,519
so for this sum if the participants

403
00:13:09,440 --> 00:13:12,399
agree on the set of participants and the

404
00:13:11,519 --> 00:13:16,320
label

405
00:13:12,399 --> 00:13:18,240
the sum will be revealed so

406
00:13:16,320 --> 00:13:20,720
how can we build the ddfe scheme for the

407
00:13:18,240 --> 00:13:23,200
decent functionality

408
00:13:20,720 --> 00:13:25,440
here's a good starting point if each

409
00:13:23,200 --> 00:13:27,519
party were able to compute a mask

410
00:13:25,440 --> 00:13:28,560
so that the mask taken together cancel

411
00:13:27,519 --> 00:13:30,240
out

412
00:13:28,560 --> 00:13:31,680
then we would have it mostly figured out

413
00:13:30,240 --> 00:13:33,120
right

414
00:13:31,680 --> 00:13:34,959
because we can simply publish our

415
00:13:33,120 --> 00:13:37,279
element hidden by the mask

416
00:13:34,959 --> 00:13:38,719
and given all of those ciphertexts you

417
00:13:37,279 --> 00:13:40,079
would just add them up

418
00:13:38,720 --> 00:13:42,639
and you would immediately recover the

419
00:13:40,079 --> 00:13:45,760
sum of the plain texts

420
00:13:42,639 --> 00:13:48,160
but can we actually do that can all of

421
00:13:45,760 --> 00:13:50,240
those participants sample a mask that is

422
00:13:48,160 --> 00:13:51,680
not uniformly random

423
00:13:50,240 --> 00:13:53,839
but belonging to the structured

424
00:13:51,680 --> 00:13:55,439
distribution without relying on a

425
00:13:53,839 --> 00:13:57,199
trusted third party

426
00:13:55,440 --> 00:13:59,519
without coordinating and without

427
00:13:57,199 --> 00:14:01,519
communicating

428
00:13:59,519 --> 00:14:03,279
the answer to that is yes in a

429
00:14:01,519 --> 00:14:06,320
computational sense

430
00:14:03,279 --> 00:14:08,399
a solution appears in json 2009 and is

431
00:14:06,320 --> 00:14:10,160
attributed to blunt waters

432
00:14:08,399 --> 00:14:11,920
it consists in having each pair of

433
00:14:10,160 --> 00:14:13,600
parties computer shared key

434
00:14:11,920 --> 00:14:15,040
through a non-interactive key exchange

435
00:14:13,600 --> 00:14:16,959
scheme

436
00:14:15,040 --> 00:14:18,399
then from that shared key they can

437
00:14:16,959 --> 00:14:20,239
compute a shared randomness that is

438
00:14:18,399 --> 00:14:22,800
specific to a label

439
00:14:20,240 --> 00:14:24,560
simply by evaluating a prf with that key

440
00:14:22,800 --> 00:14:26,479
on that label

441
00:14:24,560 --> 00:14:28,079
and now they can combine all the

442
00:14:26,480 --> 00:14:29,519
randomnesses they computed according to

443
00:14:28,079 --> 00:14:31,519
this formula here

444
00:14:29,519 --> 00:14:33,040
where only some of them have a negative

445
00:14:31,519 --> 00:14:34,320
sign

446
00:14:33,040 --> 00:14:36,719
now it is that you see that if my

447
00:14:34,320 --> 00:14:38,480
randomness with you has a positive sign

448
00:14:36,720 --> 00:14:39,839
then your randomness with me has a

449
00:14:38,480 --> 00:14:42,079
negative sign

450
00:14:39,839 --> 00:14:43,839
when we sum it all up together all the

451
00:14:42,079 --> 00:14:46,399
randomnesses cancel out as we were

452
00:14:43,839 --> 00:14:46,399
hoping for

453
00:14:46,639 --> 00:14:52,800
so is this enough to construct d70 dfe

454
00:14:50,480 --> 00:14:55,279
it's almost enough but there's an issue

455
00:14:52,800 --> 00:14:57,120
that will stop you from proving security

456
00:14:55,279 --> 00:14:59,439
let's have a simple example with alice

457
00:14:57,120 --> 00:15:00,880
wanting to aggregate data with bob

458
00:14:59,440 --> 00:15:04,720
and charlie is the one that will compute

459
00:15:00,880 --> 00:15:06,720
the sun given only alice's ciphertext

460
00:15:04,720 --> 00:15:08,880
charlie should learn nothing because he

461
00:15:06,720 --> 00:15:11,279
needs one from bob to decrypt

462
00:15:08,880 --> 00:15:13,920
once he gets bob's cipher text charlie

463
00:15:11,279 --> 00:15:16,240
should learn the sum

464
00:15:13,920 --> 00:15:18,319
but now what happens when alice

465
00:15:16,240 --> 00:15:20,000
generates two cipher texts

466
00:15:18,320 --> 00:15:21,839
for the same label on the same pair of

467
00:15:20,000 --> 00:15:24,399
participants

468
00:15:21,839 --> 00:15:25,760
it's not obvious why alice would do that

469
00:15:24,399 --> 00:15:27,600
but hey nothing stopping her from

470
00:15:25,760 --> 00:15:29,199
generating those cipher texts so here

471
00:15:27,600 --> 00:15:32,959
she goes

472
00:15:29,199 --> 00:15:34,880
now what should charlie learn here

473
00:15:32,959 --> 00:15:37,119
in theory charlie shouldn't learn

474
00:15:34,880 --> 00:15:40,240
anything because he still doesn't have a

475
00:15:37,120 --> 00:15:42,079
cipher text from bug to evaluate with

476
00:15:40,240 --> 00:15:43,360
but if we just use the mask we talked

477
00:15:42,079 --> 00:15:46,399
about earlier

478
00:15:43,360 --> 00:15:47,920
since that mask is deterministic charlie

479
00:15:46,399 --> 00:15:49,440
can cancel the mask out

480
00:15:47,920 --> 00:15:52,079
and evaluate the difference between the

481
00:15:49,440 --> 00:15:55,279
original messages

482
00:15:52,079 --> 00:15:56,479
now you might argue hey charlie was

483
00:15:55,279 --> 00:15:57,519
going to learn that by linear

484
00:15:56,480 --> 00:15:59,839
combination

485
00:15:57,519 --> 00:16:02,000
the second bug puts out some cipher text

486
00:15:59,839 --> 00:16:05,040
so what's the big deal

487
00:16:02,000 --> 00:16:06,480
but maybe bob was never going to do that

488
00:16:05,040 --> 00:16:08,880
so what we want is to have a clean

489
00:16:06,480 --> 00:16:10,079
security model that's easy for everyone

490
00:16:08,880 --> 00:16:11,920
to understand

491
00:16:10,079 --> 00:16:13,519
without caveats that are added in

492
00:16:11,920 --> 00:16:14,880
because the cryptographic structure

493
00:16:13,519 --> 00:16:17,519
just doesn't quite get us the most

494
00:16:14,880 --> 00:16:17,519
natural thing

495
00:16:19,120 --> 00:16:23,920
to that end we introduce all or nothing

496
00:16:22,000 --> 00:16:26,000
encapsulation

497
00:16:23,920 --> 00:16:27,839
it's a djf functionality that will solve

498
00:16:26,000 --> 00:16:30,000
our problem

499
00:16:27,839 --> 00:16:31,680
in aone the message is some fixed length

500
00:16:30,000 --> 00:16:35,199
data and again

501
00:16:31,680 --> 00:16:38,319
a set of users and a label much like d

502
00:16:35,199 --> 00:16:40,319
sum aone has no keys and decryption

503
00:16:38,320 --> 00:16:43,199
requires that all ciphertexts agree on

504
00:16:40,320 --> 00:16:46,399
the label and the set of participants

505
00:16:43,199 --> 00:16:48,000
unlike dsum aoni simply reveals all of

506
00:16:46,399 --> 00:16:51,759
the plaintext messages

507
00:16:48,000 --> 00:16:55,120
and their association to a participant

508
00:16:51,759 --> 00:16:58,880
so if a or any reveals all of the data

509
00:16:55,120 --> 00:17:01,600
what is it good for well

510
00:16:58,880 --> 00:17:04,160
it only allows this reveal once all the

511
00:17:01,600 --> 00:17:05,679
cipher texts have been received

512
00:17:04,160 --> 00:17:07,280
that's essentially what we were missing

513
00:17:05,679 --> 00:17:09,760
for gsm

514
00:17:07,280 --> 00:17:13,199
the ability to hide everything until

515
00:17:09,760 --> 00:17:13,199
everyone has contributed a message

516
00:17:13,520 --> 00:17:18,000
now here's a simple idea for

517
00:17:15,439 --> 00:17:19,679
constructing a or any

518
00:17:18,000 --> 00:17:21,039
everyone generates an identity based

519
00:17:19,679 --> 00:17:24,160
encryption key pair

520
00:17:21,039 --> 00:17:25,919
and advertises the public key when you

521
00:17:24,160 --> 00:17:28,079
want to encapsulate data

522
00:17:25,919 --> 00:17:31,039
you encrypt it under as many layers of

523
00:17:28,079 --> 00:17:32,559
ione as there are participants

524
00:17:31,039 --> 00:17:34,240
each layer is under a different

525
00:17:32,559 --> 00:17:37,600
participant's public key

526
00:17:34,240 --> 00:17:39,440
and under identity l finally

527
00:17:37,600 --> 00:17:40,879
you also include your functional key for

528
00:17:39,440 --> 00:17:43,440
identity l

529
00:17:40,880 --> 00:17:44,720
and that's pretty much it once everyone

530
00:17:43,440 --> 00:17:46,880
has done that

531
00:17:44,720 --> 00:17:49,120
you have all the keys for identity l so

532
00:17:46,880 --> 00:17:52,240
you can remove all the layers of ibe

533
00:17:49,120 --> 00:17:53,678
and get back all the plain texts now the

534
00:17:52,240 --> 00:17:54,799
problem with the solution we just

535
00:17:53,679 --> 00:17:56,799
described

536
00:17:54,799 --> 00:17:58,840
is that each individual cipher text has

537
00:17:56,799 --> 00:18:00,400
size line near in the number of

538
00:17:58,840 --> 00:18:02,559
participants

539
00:18:00,400 --> 00:18:04,480
the great news is that if you carefully

540
00:18:02,559 --> 00:18:06,559
instantiate our above construction

541
00:18:04,480 --> 00:18:07,919
with bernie and franklin's original ib

542
00:18:06,559 --> 00:18:10,320
from 2001

543
00:18:07,919 --> 00:18:11,919
that problem goes away you can get sex

544
00:18:10,320 --> 00:18:13,678
in cipher texts

545
00:18:11,919 --> 00:18:15,840
if you are curious please refer to the

546
00:18:13,679 --> 00:18:17,360
paper for details

547
00:18:15,840 --> 00:18:18,879
we can finally move on to our most

548
00:18:17,360 --> 00:18:21,600
interesting functionality

549
00:18:18,880 --> 00:18:22,480
in our product it's the most complicated

550
00:18:21,600 --> 00:18:24,320
one

551
00:18:22,480 --> 00:18:26,559
so we'll simplify things a bit so we can

552
00:18:24,320 --> 00:18:29,039
focus on the important ideas

553
00:18:26,559 --> 00:18:30,399
the messages contain a scalar and as

554
00:18:29,039 --> 00:18:33,919
we're used to by now

555
00:18:30,400 --> 00:18:36,400
a set of users and a label the keys are

556
00:18:33,919 --> 00:18:38,880
a vector on a set of participants

557
00:18:36,400 --> 00:18:40,240
so it is a set tying each participant to

558
00:18:38,880 --> 00:18:41,760
a scalar

559
00:18:40,240 --> 00:18:43,200
and a functionality is that if four

560
00:18:41,760 --> 00:18:45,280
messages agree on the set of

561
00:18:43,200 --> 00:18:47,679
participants under label

562
00:18:45,280 --> 00:18:49,760
and all keys agree on a unique vector y

563
00:18:47,679 --> 00:18:51,440
over that same set of participants

564
00:18:49,760 --> 00:18:53,679
we should be able to compute the inner

565
00:18:51,440 --> 00:18:54,640
product which is the sum of the message

566
00:18:53,679 --> 00:18:57,840
scalars

567
00:18:54,640 --> 00:18:59,919
weighted by the key scalers

568
00:18:57,840 --> 00:19:01,280
as a starting point let's look at the

569
00:18:59,919 --> 00:19:03,120
construction for inner product

570
00:19:01,280 --> 00:19:06,559
multi-client functional encryption

571
00:19:03,120 --> 00:19:09,280
we introduced at asiacrypt 2018.

572
00:19:06,559 --> 00:19:10,799
here we're reusing ddf notations for

573
00:19:09,280 --> 00:19:12,399
those of you who might not be familiar

574
00:19:10,799 --> 00:19:15,120
with ncfe

575
00:19:12,400 --> 00:19:16,960
but basically in mcife there is a

576
00:19:15,120 --> 00:19:18,159
central authority which will sample keys

577
00:19:16,960 --> 00:19:19,679
for people

578
00:19:18,160 --> 00:19:21,919
and hand out the functional decryption

579
00:19:19,679 --> 00:19:23,760
keys by relying on its global knowledge

580
00:19:21,919 --> 00:19:26,240
of everyone's keys

581
00:19:23,760 --> 00:19:27,520
in gdfe we have to compute those keys in

582
00:19:26,240 --> 00:19:30,480
a decentralized way

583
00:19:27,520 --> 00:19:32,480
which is much harder so this is an

584
00:19:30,480 --> 00:19:34,160
mcifee that has been rewritten to try to

585
00:19:32,480 --> 00:19:35,760
achieve a ddfe

586
00:19:34,160 --> 00:19:37,840
but the biggest challenges remain ahead

587
00:19:35,760 --> 00:19:40,160
of us

588
00:19:37,840 --> 00:19:41,918
basic idea here is that encryption is

589
00:19:40,160 --> 00:19:43,200
somewhat algae male like

590
00:19:41,919 --> 00:19:45,120
but the message is placed in the

591
00:19:43,200 --> 00:19:46,640
exponent because you want to achieve

592
00:19:45,120 --> 00:19:48,559
inner product which is essentially an

593
00:19:46,640 --> 00:19:50,000
additive functionality

594
00:19:48,559 --> 00:19:52,799
and instead of something a random

595
00:19:50,000 --> 00:19:54,320
exponent you use a random oracle

596
00:19:52,799 --> 00:19:55,840
to compute a random element that is

597
00:19:54,320 --> 00:19:57,600
shared between all participants for a

598
00:19:55,840 --> 00:19:58,799
given label

599
00:19:57,600 --> 00:20:01,120
because you don't know the discrete

600
00:19:58,799 --> 00:20:02,960
algorithm of the random oracle output

601
00:20:01,120 --> 00:20:04,158
you can only encrypt if you know the

602
00:20:02,960 --> 00:20:06,320
secret key

603
00:20:04,159 --> 00:20:08,559
but that's fine because ipdf is not a

604
00:20:06,320 --> 00:20:10,799
public key functionality

605
00:20:08,559 --> 00:20:12,480
for the functional key if we're trying

606
00:20:10,799 --> 00:20:13,840
to give a key that will enable the user

607
00:20:12,480 --> 00:20:15,200
to evaluate in our products with a

608
00:20:13,840 --> 00:20:17,199
vector y

609
00:20:15,200 --> 00:20:19,280
well recall that we essentially have a

610
00:20:17,200 --> 00:20:20,880
vector s of secret keys

611
00:20:19,280 --> 00:20:22,879
so we simply give out the inner product

612
00:20:20,880 --> 00:20:24,159
between y and s

613
00:20:22,880 --> 00:20:25,600
and then there's a way to combine a

614
00:20:24,159 --> 00:20:27,120
bunch of ciphertexts with the

615
00:20:25,600 --> 00:20:28,879
functionality

616
00:20:27,120 --> 00:20:30,799
it uses the structure of the group and

617
00:20:28,880 --> 00:20:33,360
you can do the math it works out

618
00:20:30,799 --> 00:20:34,000
and you get back this inner product as

619
00:20:33,360 --> 00:20:35,120
is common with

620
00:20:34,000 --> 00:20:37,360
group-based interpreter functional

621
00:20:35,120 --> 00:20:39,199
encryption schemes that result is in the

622
00:20:37,360 --> 00:20:40,639
exponent of the group generator

623
00:20:39,200 --> 00:20:42,480
so you have to make sure the result of

624
00:20:40,640 --> 00:20:43,679
your computation isn't too big

625
00:20:42,480 --> 00:20:46,480
so that you can compute the discrete

626
00:20:43,679 --> 00:20:49,600
algorithm it's a bit unfortunate

627
00:20:46,480 --> 00:20:51,679
but it's usually manageable in practice

628
00:20:49,600 --> 00:20:53,520
so how can we distribute the key

629
00:20:51,679 --> 00:20:56,880
generation in this scheme

630
00:20:53,520 --> 00:20:59,200
so it is closer to being a proper ddfe

631
00:20:56,880 --> 00:20:59,919
well we set the key is the inner product

632
00:20:59,200 --> 00:21:02,159
between the vector

633
00:20:59,919 --> 00:21:04,240
y from the function on t and the vector

634
00:21:02,159 --> 00:21:05,919
s of the secret key

635
00:21:04,240 --> 00:21:08,000
another totally equivalent way of

636
00:21:05,919 --> 00:21:08,960
looking at it is that it's the sum of

637
00:21:08,000 --> 00:21:12,080
the y's

638
00:21:08,960 --> 00:21:14,480
multiplied by the appropriate s's

639
00:21:12,080 --> 00:21:16,480
if you see it as a sum you realize this

640
00:21:14,480 --> 00:21:17,600
for key generation you really want a

641
00:21:16,480 --> 00:21:20,480
decentralized

642
00:21:17,600 --> 00:21:21,918
non-interactive way to evaluate this sum

643
00:21:20,480 --> 00:21:24,000
but that's what we were talking about

644
00:21:21,919 --> 00:21:26,240
just a few minutes ago

645
00:21:24,000 --> 00:21:28,880
that's d sum which does indeed let us

646
00:21:26,240 --> 00:21:31,360
decentralize key generation

647
00:21:28,880 --> 00:21:32,799
another issue you run into is that of

648
00:21:31,360 --> 00:21:35,600
repeated queries

649
00:21:32,799 --> 00:21:37,280
as we did earlier with dsm because

650
00:21:35,600 --> 00:21:38,719
encryption is again deterministic

651
00:21:37,280 --> 00:21:40,320
so you can use the group structure to

652
00:21:38,720 --> 00:21:41,360
figure out the difference between two

653
00:21:40,320 --> 00:21:42,960
plain texts

654
00:21:41,360 --> 00:21:45,600
from two cipher texts for the same set

655
00:21:42,960 --> 00:21:48,480
of participants in the same label

656
00:21:45,600 --> 00:21:49,840
thankfully it turns out aone which we

657
00:21:48,480 --> 00:21:52,960
had used for dsm

658
00:21:49,840 --> 00:21:54,639
also helps here finally

659
00:21:52,960 --> 00:21:57,039
we simplified things a bit here by

660
00:21:54,640 --> 00:21:58,559
having simple scalars as messages

661
00:21:57,039 --> 00:22:01,039
but we can actually have vectors as

662
00:21:58,559 --> 00:22:01,440
messages that actually complicate things

663
00:22:01,039 --> 00:22:03,919
a bit

664
00:22:01,440 --> 00:22:05,760
as far as repeated queries are concerned

665
00:22:03,919 --> 00:22:07,520
this can be addressed by combining

666
00:22:05,760 --> 00:22:08,960
a layer of single input in our product

667
00:22:07,520 --> 00:22:11,280
functional encryption

668
00:22:08,960 --> 00:22:12,960
with another layer of aone under

669
00:22:11,280 --> 00:22:15,039
functional keys

670
00:22:12,960 --> 00:22:16,799
again i'll refer you to the paper for

671
00:22:15,039 --> 00:22:18,559
details

672
00:22:16,799 --> 00:22:20,799
allow me to conclude by recapitulating

673
00:22:18,559 --> 00:22:23,678
our main contributions

674
00:22:20,799 --> 00:22:25,039
first we defined dynamic decentralized

675
00:22:23,679 --> 00:22:26,720
functional encryption

676
00:22:25,039 --> 00:22:28,400
which is a framework for describing a

677
00:22:26,720 --> 00:22:29,919
variety of cryptosystems

678
00:22:28,400 --> 00:22:31,440
that enable a server to perform

679
00:22:29,919 --> 00:22:34,880
controlled computations

680
00:22:31,440 --> 00:22:36,799
on data from a variety of clients next

681
00:22:34,880 --> 00:22:38,320
we define three interesting dtfe

682
00:22:36,799 --> 00:22:41,760
functionalities

683
00:22:38,320 --> 00:22:44,000
for which we also provide constructions

684
00:22:41,760 --> 00:22:46,240
although nothing encapsulation is an

685
00:22:44,000 --> 00:22:47,840
extremely helpful building block

686
00:22:46,240 --> 00:22:50,400
for achieving a natural notion of

687
00:22:47,840 --> 00:22:52,080
security in our other functionalities

688
00:22:50,400 --> 00:22:54,240
and we give a generic construction there

689
00:22:52,080 --> 00:22:56,240
are from identity based encryption

690
00:22:54,240 --> 00:22:57,760
with a succinct variant from bi-linear

691
00:22:56,240 --> 00:23:00,159
maps

692
00:22:57,760 --> 00:23:01,440
we then define decentralized sum for

693
00:23:00,159 --> 00:23:03,600
which our construction

694
00:23:01,440 --> 00:23:06,159
makes generate use of aorni and of

695
00:23:03,600 --> 00:23:08,080
non-interactive key exchange

696
00:23:06,159 --> 00:23:09,200
finally we use both of these

697
00:23:08,080 --> 00:23:11,520
functionalities

698
00:23:09,200 --> 00:23:13,679
in addition to prime order groups to

699
00:23:11,520 --> 00:23:15,918
construct a decentralized scheme

700
00:23:13,679 --> 00:23:19,039
for the functional evaluation of inner

701
00:23:15,919 --> 00:23:20,960
products over sensitive data

702
00:23:19,039 --> 00:23:22,240
that's it for today's presentation i'd

703
00:23:20,960 --> 00:23:22,880
like to thank you again for your

704
00:23:22,240 --> 00:23:24,320
interest

705
00:23:22,880 --> 00:23:25,600
and i look forward to interacting with

706
00:23:24,320 --> 00:23:28,240
you and answering your questions during

707
00:23:25,600 --> 00:23:28,240
the conference

