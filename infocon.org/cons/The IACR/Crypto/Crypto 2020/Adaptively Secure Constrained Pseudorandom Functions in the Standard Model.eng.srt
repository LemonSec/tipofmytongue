1
00:00:02,159 --> 00:00:06,000
hello everyone

2
00:00:03,360 --> 00:00:07,839
i'm takashi today i will talk about

3
00:00:06,000 --> 00:00:10,320
adaptively secure constraints to the

4
00:00:07,839 --> 00:00:12,960
random functions in the standard model

5
00:00:10,320 --> 00:00:14,920
this is a joint work with alex shuichi

6
00:00:12,960 --> 00:00:17,119
yo and

7
00:00:14,920 --> 00:00:19,759
shorter

8
00:00:17,119 --> 00:00:22,720
third random function plf is a

9
00:00:19,760 --> 00:00:25,439
fundamental preemptive in cryptography

10
00:00:22,720 --> 00:00:28,240
plf is a key function that is

11
00:00:25,439 --> 00:00:30,720
indistinguishable from a random function

12
00:00:28,240 --> 00:00:31,679
if a distinguisher is only given oracle

13
00:00:30,720 --> 00:00:35,040
access to the

14
00:00:31,679 --> 00:00:37,280
function as a classical result

15
00:00:35,040 --> 00:00:38,160
it is known that there is a construction

16
00:00:37,280 --> 00:00:41,760
of plf

17
00:00:38,160 --> 00:00:41,760
based on any one way function

18
00:00:42,640 --> 00:00:46,960
reason 3 there was proposed extension of

19
00:00:46,079 --> 00:00:51,039
plf

20
00:00:46,960 --> 00:00:54,239
called constrained plf or cprf

21
00:00:51,039 --> 00:00:57,440
in cprf are given the key k

22
00:00:54,239 --> 00:01:00,160
and the constraint c that defines a

23
00:00:57,440 --> 00:01:01,280
pattern predicate we can generate a

24
00:01:00,160 --> 00:01:04,640
constraint key

25
00:01:01,280 --> 00:01:05,760
denoted by k sub c by using the

26
00:01:04,640 --> 00:01:09,520
constraint key

27
00:01:05,760 --> 00:01:13,280
we can evaluate the prf on any input x

28
00:01:09,520 --> 00:01:16,560
that satisfies the predicate that is

29
00:01:13,280 --> 00:01:17,439
as correctness we require that for any

30
00:01:16,560 --> 00:01:20,560
input x

31
00:01:17,439 --> 00:01:22,880
such that c of x is equal to 1 we can

32
00:01:20,560 --> 00:01:24,799
use this constraint key to evaluate the

33
00:01:22,880 --> 00:01:28,399
plf value

34
00:01:24,799 --> 00:01:29,040
on the other hand as security we require

35
00:01:28,400 --> 00:01:32,159
that for

36
00:01:29,040 --> 00:01:35,439
any input x such that c of x

37
00:01:32,159 --> 00:01:38,240
equal to zero pls value

38
00:01:35,439 --> 00:01:41,839
is look so random even if we are given

39
00:01:38,240 --> 00:01:41,839
the constraint key k sub c

40
00:01:42,880 --> 00:01:47,439
more formally uh for defining the

41
00:01:45,759 --> 00:01:50,640
security of cprf

42
00:01:47,439 --> 00:01:53,279
we consider the following security game

43
00:01:50,640 --> 00:01:55,680
in the security game adversary can make

44
00:01:53,280 --> 00:01:58,399
the following three types of queries

45
00:01:55,680 --> 00:01:59,200
the first is the key query uh in the key

46
00:01:58,399 --> 00:02:02,560
query

47
00:01:59,200 --> 00:02:05,040
addbox will submit our predicate c

48
00:02:02,560 --> 00:02:07,040
and then the challenger returns a

49
00:02:05,040 --> 00:02:09,520
constraint key corresponding to this

50
00:02:07,040 --> 00:02:10,479
predicate the second is a variation

51
00:02:09,520 --> 00:02:13,200
query

52
00:02:10,479 --> 00:02:13,840
in this evaluation query addboss will

53
00:02:13,200 --> 00:02:16,640
submit

54
00:02:13,840 --> 00:02:18,080
some input x and then the challenger

55
00:02:16,640 --> 00:02:21,119
return the pl value

56
00:02:18,080 --> 00:02:22,800
on this input x the third type is

57
00:02:21,120 --> 00:02:26,239
challenge query

58
00:02:22,800 --> 00:02:27,200
uh for other challenge query other three

59
00:02:26,239 --> 00:02:30,239
submits some

60
00:02:27,200 --> 00:02:31,440
input extern that must satisfy a certain

61
00:02:30,239 --> 00:02:34,000
condition to prevent

62
00:02:31,440 --> 00:02:34,879
trivia attacks and then the challenger

63
00:02:34,000 --> 00:02:37,920
picks a

64
00:02:34,879 --> 00:02:40,319
coin from uniformly from zero one

65
00:02:37,920 --> 00:02:41,518
and if coin is equal to one challenger

66
00:02:40,319 --> 00:02:44,640
returns the pr

67
00:02:41,519 --> 00:02:46,800
value on the challenge input x star

68
00:02:44,640 --> 00:02:47,839
and otherwise it returns a uniform

69
00:02:46,800 --> 00:02:50,959
string y

70
00:02:47,840 --> 00:02:53,040
uh in the range of the prf and

71
00:02:50,959 --> 00:02:54,239
other pathways goal is to guess which is

72
00:02:53,040 --> 00:02:57,440
the case and

73
00:02:54,239 --> 00:02:58,720
it outputs its guess coin prime we say

74
00:02:57,440 --> 00:03:02,239
that otherwise we win

75
00:02:58,720 --> 00:03:04,800
the game if coin prime is equal to coin

76
00:03:02,239 --> 00:03:06,400
and we see that the cprf is secure if

77
00:03:04,800 --> 00:03:09,040
for any adversary

78
00:03:06,400 --> 00:03:11,920
the probability of directory guessing is

79
00:03:09,040 --> 00:03:11,920
almost one half

80
00:03:12,319 --> 00:03:16,319
uh in more detail there are several

81
00:03:15,280 --> 00:03:19,760
flavors of

82
00:03:16,319 --> 00:03:22,238
definition of the security of cprf

83
00:03:19,760 --> 00:03:24,319
and in particular in this work we

84
00:03:22,239 --> 00:03:27,360
consider the following two axis of

85
00:03:24,319 --> 00:03:28,319
strength level of security of cprf the

86
00:03:27,360 --> 00:03:30,560
first is

87
00:03:28,319 --> 00:03:31,679
selective security versus adaptive

88
00:03:30,560 --> 00:03:33,760
security

89
00:03:31,680 --> 00:03:34,799
in the adaptive security otherwise we

90
00:03:33,760 --> 00:03:37,840
can make

91
00:03:34,799 --> 00:03:38,799
its queries in arbitrary order on the

92
00:03:37,840 --> 00:03:41,680
other hand in

93
00:03:38,799 --> 00:03:43,760
selective security the order is

94
00:03:41,680 --> 00:03:46,159
restricted in a certain way

95
00:03:43,760 --> 00:03:47,120
so of course adaptive security is

96
00:03:46,159 --> 00:03:50,239
stronger

97
00:03:47,120 --> 00:03:53,200
than the selective security and

98
00:03:50,239 --> 00:03:54,799
as a second we also consider single key

99
00:03:53,200 --> 00:03:57,200
security versus

100
00:03:54,799 --> 00:04:00,159
q collision resistance in the q

101
00:03:57,200 --> 00:04:03,119
collision resistance

102
00:04:00,159 --> 00:04:04,480
we can make at most two key queries on

103
00:04:03,120 --> 00:04:06,560
the other hand in the single key

104
00:04:04,480 --> 00:04:09,920
security otherwise we can query

105
00:04:06,560 --> 00:04:10,720
only one key query and of course if q is

106
00:04:09,920 --> 00:04:13,359
larger than one

107
00:04:10,720 --> 00:04:14,799
q collision resistance is stronger than

108
00:04:13,360 --> 00:04:17,440
single key security

109
00:04:14,799 --> 00:04:18,959
so ideally the optimal notion security

110
00:04:17,440 --> 00:04:22,320
notion of cprf

111
00:04:18,959 --> 00:04:28,240
is adaptive and q collusion resistance

112
00:04:22,320 --> 00:04:29,800
for any polynomial queue

113
00:04:28,240 --> 00:04:32,800
here i would like to review

114
00:04:29,800 --> 00:04:36,000
non-contractions of cprf

115
00:04:32,800 --> 00:04:37,600
and i would like to divide known

116
00:04:36,000 --> 00:04:39,199
construction into the following two

117
00:04:37,600 --> 00:04:42,000
categories

118
00:04:39,199 --> 00:04:44,000
the first category is construction from

119
00:04:42,000 --> 00:04:45,919
standard assumption

120
00:04:44,000 --> 00:04:47,919
there are a lot of construction in this

121
00:04:45,919 --> 00:04:50,639
category however

122
00:04:47,919 --> 00:04:51,599
all constructions only achieve selective

123
00:04:50,639 --> 00:04:53,680
security

124
00:04:51,600 --> 00:04:55,040
and most of them only achieve single key

125
00:04:53,680 --> 00:04:58,000
security

126
00:04:55,040 --> 00:04:59,280
so we would like to ask one question for

127
00:04:58,000 --> 00:05:01,840
this category

128
00:04:59,280 --> 00:05:02,880
our question is can we construct

129
00:05:01,840 --> 00:05:05,919
adaptive secure

130
00:05:02,880 --> 00:05:07,039
and collision resistant cprf for any

131
00:05:05,919 --> 00:05:09,359
functionality

132
00:05:07,039 --> 00:05:11,199
from standard assumption so this is our

133
00:05:09,360 --> 00:05:13,919
first question

134
00:05:11,199 --> 00:05:16,479
and the second category is construction

135
00:05:13,919 --> 00:05:19,359
from obfuscation

136
00:05:16,479 --> 00:05:20,479
uh by using a frustration bonnie and

137
00:05:19,360 --> 00:05:22,479
tantry

138
00:05:20,479 --> 00:05:23,520
uh showed that we can construct

139
00:05:22,479 --> 00:05:26,479
collectively

140
00:05:23,520 --> 00:05:27,440
poly collision resistant cprf for p

141
00:05:26,479 --> 00:05:29,758
slash poly

142
00:05:27,440 --> 00:05:31,039
however this only satisfies elective

143
00:05:29,759 --> 00:05:34,479
security

144
00:05:31,039 --> 00:05:36,080
and interestingly those obfuscation is

145
00:05:34,479 --> 00:05:38,960
very strong primitive

146
00:05:36,080 --> 00:05:40,800
it turns out very difficult to construct

147
00:05:38,960 --> 00:05:44,479
adaptively secure cprf

148
00:05:40,800 --> 00:05:48,320
uh even using authentication and in

149
00:05:44,479 --> 00:05:51,599
15 2015 ohm bargain tower constructed

150
00:05:48,320 --> 00:05:54,240
adaptively secure cprf for

151
00:05:51,600 --> 00:05:55,680
puncturing functionality however so

152
00:05:54,240 --> 00:05:57,199
puncturing with very limited

153
00:05:55,680 --> 00:06:00,880
functionality so this is

154
00:05:57,199 --> 00:06:03,680
not sufficient and uh recently

155
00:06:00,880 --> 00:06:04,639
in 2019 after parliamentary improves

156
00:06:03,680 --> 00:06:07,039
that result

157
00:06:04,639 --> 00:06:07,919
to construct adaptively and single key

158
00:06:07,039 --> 00:06:11,440
secure

159
00:06:07,919 --> 00:06:13,440
cprf for nc1 from obfuscation

160
00:06:11,440 --> 00:06:15,919
however this is not still sufficient

161
00:06:13,440 --> 00:06:17,680
because a single key station it only

162
00:06:15,919 --> 00:06:21,039
satisfy single key security

163
00:06:17,680 --> 00:06:24,160
and the function class is limited to nc1

164
00:06:21,039 --> 00:06:27,120
so our question for this category

165
00:06:24,160 --> 00:06:28,800
is can we construct adaptively secure

166
00:06:27,120 --> 00:06:32,240
and collision resistant

167
00:06:28,800 --> 00:06:32,720
cprf for p slash poly which is the class

168
00:06:32,240 --> 00:06:36,400
of

169
00:06:32,720 --> 00:06:39,199
all polynomial side circuit

170
00:06:36,400 --> 00:06:40,318
and here i would like to remark that we

171
00:06:39,199 --> 00:06:43,199
omit contraction

172
00:06:40,319 --> 00:06:44,000
rely on complexity leveraging or random

173
00:06:43,199 --> 00:06:46,479
work

174
00:06:44,000 --> 00:06:48,000
and we focus in construction in the

175
00:06:46,479 --> 00:06:52,240
standard model

176
00:06:48,000 --> 00:06:52,240
from polynomial hardness assumption

177
00:06:53,759 --> 00:06:59,280
so in this work we construct new

178
00:06:56,960 --> 00:07:00,799
three new construction of adaptively

179
00:06:59,280 --> 00:07:03,280
secure cprs

180
00:07:00,800 --> 00:07:04,960
the first construction is adaptively

181
00:07:03,280 --> 00:07:06,559
secure and other word collision

182
00:07:04,960 --> 00:07:09,280
resistance cprf

183
00:07:06,560 --> 00:07:09,919
for the class of t c and f for any

184
00:07:09,280 --> 00:07:13,119
constant t

185
00:07:09,919 --> 00:07:15,840
from one function here t c and f

186
00:07:13,120 --> 00:07:16,319
is a predicate that is expressed at the

187
00:07:15,840 --> 00:07:20,239
end

188
00:07:16,319 --> 00:07:23,199
of many clauses that each of which are

189
00:07:20,240 --> 00:07:24,160
depends on at most t input bits and

190
00:07:23,199 --> 00:07:26,720
especially

191
00:07:24,160 --> 00:07:27,759
this class includes bit fixing

192
00:07:26,720 --> 00:07:32,400
functionality

193
00:07:27,759 --> 00:07:35,759
because bit fixing is exactly one cnf

194
00:07:32,400 --> 00:07:38,719
second our second construction is

195
00:07:35,759 --> 00:07:42,160
adaptively single key secure cprf for

196
00:07:38,720 --> 00:07:44,960
inner product functionality from lwe

197
00:07:42,160 --> 00:07:47,360
and our cell construction is adaptably

198
00:07:44,960 --> 00:07:48,159
secure and order one collision resistant

199
00:07:47,360 --> 00:07:50,120
cprf

200
00:07:48,160 --> 00:07:52,160
for p slash poly from

201
00:07:50,120 --> 00:07:55,520
indistinguishability of location and

202
00:07:52,160 --> 00:07:58,080
level e and here i note that

203
00:07:55,520 --> 00:07:59,840
the first two construction also satisfy

204
00:07:58,080 --> 00:08:03,120
weak one key privacy

205
00:07:59,840 --> 00:08:04,000
which roughly says that the constraint

206
00:08:03,120 --> 00:08:07,039
key doesn't

207
00:08:04,000 --> 00:08:10,400
reveal the constraint that

208
00:08:07,039 --> 00:08:10,400
is associated with the key

209
00:08:11,680 --> 00:08:15,840
so from now i would like to explain each

210
00:08:13,840 --> 00:08:18,719
construction in more detail

211
00:08:15,840 --> 00:08:21,039
so our path construction is adaptively

212
00:08:18,720 --> 00:08:22,319
order run collision resistance cprf for

213
00:08:21,039 --> 00:08:26,240
tc and f for

214
00:08:22,319 --> 00:08:27,520
any constant t from one function as a

215
00:08:26,240 --> 00:08:30,240
historical note

216
00:08:27,520 --> 00:08:32,799
in the first version of our work we

217
00:08:30,240 --> 00:08:34,159
constructed adaptively overrun collusion

218
00:08:32,799 --> 00:08:36,880
resistant cprf

219
00:08:34,159 --> 00:08:37,838
for a smaller class of bit fiction and

220
00:08:36,880 --> 00:08:41,200
after that

221
00:08:37,839 --> 00:08:43,519
cavalry observed that we can trade the

222
00:08:41,200 --> 00:08:45,440
collision resistance and functionality

223
00:08:43,519 --> 00:08:48,880
to achieve single key secure

224
00:08:45,440 --> 00:08:51,920
security for tcnf

225
00:08:48,880 --> 00:08:55,120
and in the current version of our work

226
00:08:51,920 --> 00:08:58,240
we take the both advantages that is

227
00:08:55,120 --> 00:08:59,519
our scheme our cprf is older and

228
00:08:58,240 --> 00:09:02,640
collision resistant

229
00:08:59,519 --> 00:09:05,839
and at the same time we that supports

230
00:09:02,640 --> 00:09:09,439
the tcnf functionality

231
00:09:05,839 --> 00:09:11,040
and as and i also note that

232
00:09:09,440 --> 00:09:13,839
in the concurrent work of pi

233
00:09:11,040 --> 00:09:15,360
constitution they also gave a similar

234
00:09:13,839 --> 00:09:17,680
construction to ours

235
00:09:15,360 --> 00:09:20,800
but they only improved selective and

236
00:09:17,680 --> 00:09:23,279
single key security

237
00:09:20,800 --> 00:09:25,359
our construction is based on a

238
00:09:23,279 --> 00:09:28,880
combinatorial construction from

239
00:09:25,360 --> 00:09:31,279
normal prf and for simplicity

240
00:09:28,880 --> 00:09:32,720
we focus on the special case of bit

241
00:09:31,279 --> 00:09:37,200
fiction

242
00:09:32,720 --> 00:09:40,000
in this talk

243
00:09:37,200 --> 00:09:42,800
this is a construction of adaptively

244
00:09:40,000 --> 00:09:45,360
single key secure cpr for bit pitching

245
00:09:42,800 --> 00:09:47,120
uh here a bit fetching predicate is

246
00:09:45,360 --> 00:09:49,760
described by your string b

247
00:09:47,120 --> 00:09:51,680
that consists of zero one or asterisk

248
00:09:49,760 --> 00:09:54,720
that means wild card

249
00:09:51,680 --> 00:09:56,079
for input x always is that x satisfy the

250
00:09:54,720 --> 00:09:59,440
predicate v

251
00:09:56,080 --> 00:10:02,560
if v i equal x i or v i

252
00:09:59,440 --> 00:10:06,079
is wildcard for all i

253
00:10:02,560 --> 00:10:06,640
then the key of our cprf consists of two

254
00:10:06,079 --> 00:10:10,160
l

255
00:10:06,640 --> 00:10:13,519
keys of the underlying normal normal prf

256
00:10:10,160 --> 00:10:16,800
and the cprf on input x is

257
00:10:13,519 --> 00:10:18,800
defined to the x or of l evaluation of

258
00:10:16,800 --> 00:10:21,519
the underlying normal prf

259
00:10:18,800 --> 00:10:23,839
using a key that is chosen according to

260
00:10:21,519 --> 00:10:26,640
each bit of x

261
00:10:23,839 --> 00:10:27,680
then for our predicate bit fixing

262
00:10:26,640 --> 00:10:30,560
bracket v

263
00:10:27,680 --> 00:10:32,560
a constant key case of v is said to be a

264
00:10:30,560 --> 00:10:35,518
subset of these keys

265
00:10:32,560 --> 00:10:36,880
are according chosen according to the

266
00:10:35,519 --> 00:10:40,079
predicate v

267
00:10:36,880 --> 00:10:42,880
for example if l equal to five and v

268
00:10:40,079 --> 00:10:43,279
equals zero one attribute zero at risk

269
00:10:42,880 --> 00:10:46,399
then

270
00:10:43,279 --> 00:10:48,959
k v is looks like this

271
00:10:46,399 --> 00:10:50,079
and for example if we want to evaluate

272
00:10:48,959 --> 00:10:52,000
on their one

273
00:10:50,079 --> 00:10:54,319
there's a zero then that is possible

274
00:10:52,000 --> 00:10:57,279
because there are one zero zero zero

275
00:10:54,320 --> 00:10:58,480
so the corresponding key is contained in

276
00:10:57,279 --> 00:11:01,519
case of v

277
00:10:58,480 --> 00:11:04,880
on the other hand if we want to evaluate

278
00:11:01,519 --> 00:11:08,079
uh on zero zero zero there then

279
00:11:04,880 --> 00:11:09,200
k two zero is missing so we cannot

280
00:11:08,079 --> 00:11:12,319
evaluate that

281
00:11:09,200 --> 00:11:12,959
using this case of v and similarly in

282
00:11:12,320 --> 00:11:15,279
general

283
00:11:12,959 --> 00:11:16,479
we can prove that this construction

284
00:11:15,279 --> 00:11:19,279
satisfy

285
00:11:16,480 --> 00:11:20,000
the security if other battery only

286
00:11:19,279 --> 00:11:24,399
obtains

287
00:11:20,000 --> 00:11:27,360
at most one key however unfortunately

288
00:11:24,399 --> 00:11:29,040
it is easy to see that this construction

289
00:11:27,360 --> 00:11:31,839
can be completely broken

290
00:11:29,040 --> 00:11:33,360
by using two key queries so we have to

291
00:11:31,839 --> 00:11:35,839
modify the construction to achieve

292
00:11:33,360 --> 00:11:38,720
collusion resistance

293
00:11:35,839 --> 00:11:39,839
for achieving true collusion resistance

294
00:11:38,720 --> 00:11:44,000
our idea

295
00:11:39,839 --> 00:11:47,120
is to associate each normal prf key

296
00:11:44,000 --> 00:11:48,079
with q input bits in set of one like

297
00:11:47,120 --> 00:11:51,040
this

298
00:11:48,079 --> 00:11:53,519
and overall structure of the cprf is

299
00:11:51,040 --> 00:11:57,839
similar to the single key secure case

300
00:11:53,519 --> 00:11:58,560
so that is xor of a variation of the

301
00:11:57,839 --> 00:12:01,760
underlying

302
00:11:58,560 --> 00:12:03,279
normal prf using key that is chosen

303
00:12:01,760 --> 00:12:06,880
according to

304
00:12:03,279 --> 00:12:08,880
according to each bit of x

305
00:12:06,880 --> 00:12:10,000
and i will not explain the detail of the

306
00:12:08,880 --> 00:12:12,959
security proof

307
00:12:10,000 --> 00:12:13,839
but by some simple combinatorial

308
00:12:12,959 --> 00:12:16,479
argument we can

309
00:12:13,839 --> 00:12:17,760
indeed prove that this is q collusion

310
00:12:16,480 --> 00:12:21,440
resistant

311
00:12:17,760 --> 00:12:22,160
and as for efficiency because the number

312
00:12:21,440 --> 00:12:25,360
of

313
00:12:22,160 --> 00:12:28,880
uh the each cpf key consists of

314
00:12:25,360 --> 00:12:30,880
two l to the q normal pf key

315
00:12:28,880 --> 00:12:33,200
so for keeping this should be polynomial

316
00:12:30,880 --> 00:12:36,800
in the security parameter we have to

317
00:12:33,200 --> 00:12:39,200
set q to be a constant and that's why

318
00:12:36,800 --> 00:12:42,560
this construction is only limited to all

319
00:12:39,200 --> 00:12:42,560
the run collision resistance

320
00:12:44,000 --> 00:12:47,200
next i'll move on to the second

321
00:12:46,000 --> 00:12:49,760
contraction

322
00:12:47,200 --> 00:12:52,720
our second contraction is adaptively

323
00:12:49,760 --> 00:12:56,880
single key secure cprf for inner product

324
00:12:52,720 --> 00:12:59,920
from l of e in a product predicate

325
00:12:56,880 --> 00:13:00,800
is specified by integer vector y and for

326
00:12:59,920 --> 00:13:04,079
integer vector

327
00:13:00,800 --> 00:13:04,800
x x satisfies the predicate specified by

328
00:13:04,079 --> 00:13:08,160
y

329
00:13:04,800 --> 00:13:11,359
if the inner product between x and y

330
00:13:08,160 --> 00:13:13,199
is there over the integer our

331
00:13:11,360 --> 00:13:13,680
contraction is divided into the

332
00:13:13,200 --> 00:13:17,600
following

333
00:13:13,680 --> 00:13:20,479
two steps in the first step we construct

334
00:13:17,600 --> 00:13:22,000
selectively secure cpr for inner

335
00:13:20,480 --> 00:13:24,880
products

336
00:13:22,000 --> 00:13:27,600
based on existing construction of key

337
00:13:24,880 --> 00:13:29,600
homomorphic normal pif

338
00:13:27,600 --> 00:13:31,279
i know that the concurrent work of

339
00:13:29,600 --> 00:13:33,839
picada initiation

340
00:13:31,279 --> 00:13:37,680
also gave a similar contraction for this

341
00:13:33,839 --> 00:13:37,680
selectively secure contraction

342
00:13:38,079 --> 00:13:42,479
as a second step we modify the

343
00:13:40,639 --> 00:13:44,480
selectively secure contraction to

344
00:13:42,480 --> 00:13:47,360
achieve the adaptive security

345
00:13:44,480 --> 00:13:48,880
by using the technique taken from lost c

346
00:13:47,360 --> 00:13:51,920
mode of lme

347
00:13:48,880 --> 00:13:55,760
and partitioning technique inspired by

348
00:13:51,920 --> 00:13:55,760
recent work of liberal ether

349
00:13:56,800 --> 00:14:01,359
so our starting point is a lot based key

350
00:13:59,360 --> 00:14:04,720
homomorphic prf

351
00:14:01,360 --> 00:14:07,279
by banerjee and picard

352
00:14:04,720 --> 00:14:08,639
in the construction there is a public

353
00:14:07,279 --> 00:14:12,480
matrix denoted by

354
00:14:08,639 --> 00:14:16,560
a and the secret key of this plf

355
00:14:12,480 --> 00:14:19,839
is a vector s then

356
00:14:16,560 --> 00:14:23,439
for evaluating the prf on input x

357
00:14:19,839 --> 00:14:23,839
uh we first compute a certain matrix a

358
00:14:23,440 --> 00:14:27,120
sub

359
00:14:23,839 --> 00:14:30,240
x that is associated with input x from

360
00:14:27,120 --> 00:14:33,680
a by using bgg

361
00:14:30,240 --> 00:14:36,639
14 homomorphic evaporation technique and

362
00:14:33,680 --> 00:14:38,399
the data of this part is irrelevant for

363
00:14:36,639 --> 00:14:39,120
the purpose of this talk so i would like

364
00:14:38,399 --> 00:14:42,399
to skip

365
00:14:39,120 --> 00:14:43,600
this part and then after generating the

366
00:14:42,399 --> 00:14:48,720
matrix a sub

367
00:14:43,600 --> 00:14:52,079
x the prf value on input x is said to be

368
00:14:48,720 --> 00:14:54,639
s transpose a sub x rounded

369
00:14:52,079 --> 00:14:54,638
module p

370
00:14:56,639 --> 00:15:00,399
so here i would like to explain uh how

371
00:14:59,440 --> 00:15:03,680
to modify

372
00:15:00,399 --> 00:15:05,839
the bp14 construction to obtain

373
00:15:03,680 --> 00:15:07,199
selectively secure cprf for inner

374
00:15:05,839 --> 00:15:10,399
products

375
00:15:07,199 --> 00:15:11,519
so the difference from the bb14

376
00:15:10,399 --> 00:15:14,480
construction

377
00:15:11,519 --> 00:15:15,279
is that the secret key is said to be a

378
00:15:14,480 --> 00:15:18,800
matrix

379
00:15:15,279 --> 00:15:19,439
instead of a vector and the input of the

380
00:15:18,800 --> 00:15:22,240
prf

381
00:15:19,440 --> 00:15:23,040
is a integer vector instead of a bit

382
00:15:22,240 --> 00:15:26,720
string

383
00:15:23,040 --> 00:15:30,000
and we use sx

384
00:15:26,720 --> 00:15:30,560
as a so fx plays the role of the secret

385
00:15:30,000 --> 00:15:34,000
key

386
00:15:30,560 --> 00:15:37,119
in the bp 14 construction

387
00:15:34,000 --> 00:15:39,040
and this is the construction of our the

388
00:15:37,120 --> 00:15:43,680
selectable secure cprf

389
00:15:39,040 --> 00:15:47,680
and for generating a constraint key for

390
00:15:43,680 --> 00:15:49,199
predicate y uh we first uniformly choose

391
00:15:47,680 --> 00:15:51,920
a random vector d

392
00:15:49,199 --> 00:15:52,639
and then we set the constraint key k sub

393
00:15:51,920 --> 00:15:56,079
y to be

394
00:15:52,639 --> 00:15:59,440
s plus d tensor y

395
00:15:56,079 --> 00:16:02,959
and by using this constraint key

396
00:15:59,440 --> 00:16:07,040
for evaluating the prf we just use

397
00:16:02,959 --> 00:16:10,399
k sub y instead of the secant key k

398
00:16:07,040 --> 00:16:11,279
like this and then the by definition of

399
00:16:10,399 --> 00:16:15,440
k sub y

400
00:16:11,279 --> 00:16:19,040
we can write this like this

401
00:16:15,440 --> 00:16:21,600
and if the inner product when x and y

402
00:16:19,040 --> 00:16:23,040
is equal to zero then this additional

403
00:16:21,600 --> 00:16:26,160
time disappears and so

404
00:16:23,040 --> 00:16:28,319
this is equal to the original value

405
00:16:26,160 --> 00:16:29,839
on the other hand if the inner product

406
00:16:28,320 --> 00:16:33,120
is not equal to 0

407
00:16:29,839 --> 00:16:36,480
then this additional time remains and so

408
00:16:33,120 --> 00:16:37,279
this can be written like this and here

409
00:16:36,480 --> 00:16:40,800
we notice

410
00:16:37,279 --> 00:16:44,240
that this term is actually the pl

411
00:16:40,800 --> 00:16:47,920
value of bp 14 if we see

412
00:16:44,240 --> 00:16:51,360
the other secret key of the bb14

413
00:16:47,920 --> 00:16:54,880
so this means that this value is the

414
00:16:51,360 --> 00:16:58,560
original plf value shifted by some

415
00:16:54,880 --> 00:17:02,639
another pf value this means that this

416
00:16:58,560 --> 00:17:03,518
uh this value computationally hides the

417
00:17:02,639 --> 00:17:06,720
original

418
00:17:03,519 --> 00:17:10,480
pl value and that's why we cannot use

419
00:17:06,720 --> 00:17:13,600
this constraint key to evaluate the prf

420
00:17:10,480 --> 00:17:15,360
uh on input x such that inner product is

421
00:17:13,599 --> 00:17:18,719
not equal to zero

422
00:17:15,359 --> 00:17:21,359
and this intuition can be turned into

423
00:17:18,720 --> 00:17:22,160
formal proof in the select selective

424
00:17:21,359 --> 00:17:26,319
setting

425
00:17:22,160 --> 00:17:28,720
however unfortunately we cannot prove

426
00:17:26,319 --> 00:17:29,840
the adaptive security in this way so we

427
00:17:28,720 --> 00:17:32,000
have to use

428
00:17:29,840 --> 00:17:34,559
additional ideas to achieve adaptive

429
00:17:32,000 --> 00:17:34,559
security

430
00:17:35,840 --> 00:17:41,120
for achieving the adaptive security we

431
00:17:38,799 --> 00:17:42,320
will rely on the technique often

432
00:17:41,120 --> 00:17:46,399
referred to as a

433
00:17:42,320 --> 00:17:47,760
lossy mode of lwe the elaborate

434
00:17:46,400 --> 00:17:50,880
assumption

435
00:17:47,760 --> 00:17:54,160
says that our elevator

436
00:17:50,880 --> 00:17:56,160
of the form a d transpose a plus noise

437
00:17:54,160 --> 00:17:58,480
is computationally indistinguishable

438
00:17:56,160 --> 00:18:01,120
from uniform

439
00:17:58,480 --> 00:18:01,760
and in this context we consider two

440
00:18:01,120 --> 00:18:05,439
modes

441
00:18:01,760 --> 00:18:08,240
for the public matrix a the first mode

442
00:18:05,440 --> 00:18:08,799
is the injective mode in the injecting

443
00:18:08,240 --> 00:18:10,960
mode

444
00:18:08,799 --> 00:18:13,200
the lovely tuple information

445
00:18:10,960 --> 00:18:14,640
theoretically determines the secret

446
00:18:13,200 --> 00:18:17,760
vector d

447
00:18:14,640 --> 00:18:21,039
on the other hand in the lofty mode

448
00:18:17,760 --> 00:18:24,080
the lw topper leaks almost no

449
00:18:21,039 --> 00:18:26,960
information about the circuit vector d

450
00:18:24,080 --> 00:18:28,080
and interestingly it is known that we

451
00:18:26,960 --> 00:18:31,039
can generate

452
00:18:28,080 --> 00:18:31,600
matrix in the injective mode or lossy

453
00:18:31,039 --> 00:18:33,440
mode

454
00:18:31,600 --> 00:18:36,480
in such a way that they are

455
00:18:33,440 --> 00:18:40,320
computationally indistinguishable

456
00:18:36,480 --> 00:18:43,360
extending these notions a recent work of

457
00:18:40,320 --> 00:18:45,600
liberty at atar introduced a technique

458
00:18:43,360 --> 00:18:48,159
or which we call sometimes injective

459
00:18:45,600 --> 00:18:50,480
mode in the following sense

460
00:18:48,160 --> 00:18:51,679
they gave a way to generate repairing

461
00:18:50,480 --> 00:18:54,640
matrix a

462
00:18:51,679 --> 00:18:56,960
so that the following three conditions

463
00:18:54,640 --> 00:19:00,240
are satisfied first

464
00:18:56,960 --> 00:19:03,440
a is the random assuming lwe

465
00:19:00,240 --> 00:19:05,440
second a matrix a sub x can be

466
00:19:03,440 --> 00:19:08,480
efficiently computed from

467
00:19:05,440 --> 00:19:11,679
a and x and third

468
00:19:08,480 --> 00:19:15,200
for any x 1 to x q and x star

469
00:19:11,679 --> 00:19:18,559
for any polynomial q the probability

470
00:19:15,200 --> 00:19:21,760
that a sub x i is lossy for all

471
00:19:18,559 --> 00:19:24,960
i and a sub x star is injective

472
00:19:21,760 --> 00:19:27,760
is one over poly so

473
00:19:24,960 --> 00:19:29,120
in this condition we consider two

474
00:19:27,760 --> 00:19:32,400
platform matrices

475
00:19:29,120 --> 00:19:35,360
and the first two matrices are lossy

476
00:19:32,400 --> 00:19:37,360
but only one matrix is injected and

477
00:19:35,360 --> 00:19:40,879
that's why we call this technique

478
00:19:37,360 --> 00:19:40,879
sometimes injective mode

479
00:19:41,840 --> 00:19:45,840
this is our construction of adaptably

480
00:19:44,000 --> 00:19:48,320
secure cprf

481
00:19:45,840 --> 00:19:50,480
this construction is very similar to the

482
00:19:48,320 --> 00:19:52,399
selectively secure construction

483
00:19:50,480 --> 00:19:54,720
except for the difference is that we

484
00:19:52,400 --> 00:19:56,160
take a randomness extractor at the left

485
00:19:54,720 --> 00:19:59,600
of the evaluation

486
00:19:56,160 --> 00:20:02,559
and also we define the matrix a sub x

487
00:19:59,600 --> 00:20:03,120
so that we can set this matrix to be in

488
00:20:02,559 --> 00:20:05,520
the

489
00:20:03,120 --> 00:20:06,158
sometimes injecting mode in the security

490
00:20:05,520 --> 00:20:09,918
proof

491
00:20:06,159 --> 00:20:12,240
by using the technique of rebuilt ether

492
00:20:09,919 --> 00:20:14,000
then i will explain the proof sketch of

493
00:20:12,240 --> 00:20:17,280
the adaptive security

494
00:20:14,000 --> 00:20:20,480
so first we implicitly set

495
00:20:17,280 --> 00:20:24,000
s to be s hat minus d tends to y

496
00:20:20,480 --> 00:20:26,559
by using the uniform matrix s hat

497
00:20:24,000 --> 00:20:27,360
here i know that this s is the master

498
00:20:26,559 --> 00:20:30,080
secret key

499
00:20:27,360 --> 00:20:31,439
of the cpr f and so this is not given to

500
00:20:30,080 --> 00:20:34,158
the other three

501
00:20:31,440 --> 00:20:34,480
so the reduction algorithm doesn't need

502
00:20:34,159 --> 00:20:37,679
to

503
00:20:34,480 --> 00:20:39,840
explicitly compute this s and further

504
00:20:37,679 --> 00:20:43,039
reduction algorithm actually does is to

505
00:20:39,840 --> 00:20:45,840
just pick a uniform matrix is hat

506
00:20:43,039 --> 00:20:47,840
then by using this s hat uh the

507
00:20:45,840 --> 00:20:49,600
constraint key case of y is easy to

508
00:20:47,840 --> 00:20:52,080
simulate because this

509
00:20:49,600 --> 00:20:54,399
d tensor y is cancelled so the

510
00:20:52,080 --> 00:20:56,320
constraint key k sub y is just equal to

511
00:20:54,400 --> 00:20:58,400
f hat

512
00:20:56,320 --> 00:21:00,879
i'll let x one through x cube be the

513
00:20:58,400 --> 00:21:04,320
evaluation queries and x serve is a

514
00:21:00,880 --> 00:21:07,360
challenge query then

515
00:21:04,320 --> 00:21:08,639
if we set a sub x to be in the sometimes

516
00:21:07,360 --> 00:21:11,760
injected mode

517
00:21:08,640 --> 00:21:13,440
then the probability that a sub x sub i

518
00:21:11,760 --> 00:21:17,120
is lossy for all i

519
00:21:13,440 --> 00:21:20,320
and a sub x star is injective in

520
00:21:17,120 --> 00:21:23,280
one over poly then

521
00:21:20,320 --> 00:21:23,760
uh the pr values on these evaluation

522
00:21:23,280 --> 00:21:25,440
queries

523
00:21:23,760 --> 00:21:27,919
and the challenge query can be written

524
00:21:25,440 --> 00:21:31,039
like this

525
00:21:27,919 --> 00:21:34,240
here because we assume that the a's have

526
00:21:31,039 --> 00:21:37,600
x sub i is lossy so this means that

527
00:21:34,240 --> 00:21:40,960
this term leaks almost no

528
00:21:37,600 --> 00:21:41,600
information about d so even if we are

529
00:21:40,960 --> 00:21:44,640
given

530
00:21:41,600 --> 00:21:48,080
all these pr values d

531
00:21:44,640 --> 00:21:48,880
still has a lot of entropy on the other

532
00:21:48,080 --> 00:21:51,918
hand

533
00:21:48,880 --> 00:21:55,360
because we assume that a sub x

534
00:21:51,919 --> 00:21:55,600
star is in the objective mode so because

535
00:21:55,360 --> 00:21:58,879
d

536
00:21:55,600 --> 00:21:59,840
has a lot of mean entropy this term also

537
00:21:58,880 --> 00:22:02,400
has a lot of

538
00:21:59,840 --> 00:22:04,720
my entropy therefore by using the

539
00:22:02,400 --> 00:22:07,679
property of the randomness extractor

540
00:22:04,720 --> 00:22:09,679
uh we can conclude that the ph value on

541
00:22:07,679 --> 00:22:10,480
the challenge input x star is to the

542
00:22:09,679 --> 00:22:13,679
random

543
00:22:10,480 --> 00:22:15,919
and this completes the security proof

544
00:22:13,679 --> 00:22:17,280
and what is important in this security

545
00:22:15,919 --> 00:22:20,000
proof is that

546
00:22:17,280 --> 00:22:22,080
after switching the public matrix to the

547
00:22:20,000 --> 00:22:24,320
sometimes injected mode

548
00:22:22,080 --> 00:22:26,080
the rest of the argument is completely

549
00:22:24,320 --> 00:22:28,879
information theoretical

550
00:22:26,080 --> 00:22:31,760
and this is why this proof works in the

551
00:22:28,880 --> 00:22:31,760
adaptive setting

552
00:22:32,640 --> 00:22:37,600
our third construction is adaptively

553
00:22:35,360 --> 00:22:38,479
secure and orderly collision resistant

554
00:22:37,600 --> 00:22:40,600
cprf

555
00:22:38,480 --> 00:22:42,480
for p slash poly from

556
00:22:40,600 --> 00:22:45,600
indistinguishability of fossilization

557
00:22:42,480 --> 00:22:48,240
and lwe and our construction is

558
00:22:45,600 --> 00:22:50,320
basically obtained by obfuscating

559
00:22:48,240 --> 00:22:52,000
a primitive called shift hiding

560
00:22:50,320 --> 00:22:54,879
shiftable function

561
00:22:52,000 --> 00:22:56,240
that is constructed based in lwe by pai

562
00:22:54,880 --> 00:22:59,039
cadentia hin

563
00:22:56,240 --> 00:23:00,159
so our construction looks like this and

564
00:22:59,039 --> 00:23:02,080
unfortunately

565
00:23:00,159 --> 00:23:04,000
i don't have enough time to explain the

566
00:23:02,080 --> 00:23:04,559
detail of the construction and security

567
00:23:04,000 --> 00:23:08,080
proof

568
00:23:04,559 --> 00:23:10,320
but our main idea is to embed previous

569
00:23:08,080 --> 00:23:11,360
key queries into pre-charging key

570
00:23:10,320 --> 00:23:14,799
queries

571
00:23:11,360 --> 00:23:17,439
and this idea is uh very different

572
00:23:14,799 --> 00:23:18,240
from the previous work of bonnet

573
00:23:17,440 --> 00:23:21,120
chambray

574
00:23:18,240 --> 00:23:22,960
of constructed selectively secure cprf

575
00:23:21,120 --> 00:23:25,199
from obfuscation

576
00:23:22,960 --> 00:23:28,080
because they embed the challenge into

577
00:23:25,200 --> 00:23:28,080
all queries

578
00:23:28,799 --> 00:23:35,120
finally i like to introduce several

579
00:23:32,159 --> 00:23:38,000
applications of our constructions

580
00:23:35,120 --> 00:23:39,760
after uploading the initial draft of our

581
00:23:38,000 --> 00:23:42,480
construct our paper

582
00:23:39,760 --> 00:23:43,679
table used our path construction to

583
00:23:42,480 --> 00:23:47,200
construct

584
00:23:43,679 --> 00:23:49,360
adaptively secure abe for tc and f

585
00:23:47,200 --> 00:23:51,200
and actually she gave a generic

586
00:23:49,360 --> 00:23:56,158
conversion from adaptively

587
00:23:51,200 --> 00:23:58,720
secure cprf to adaptability secure abe

588
00:23:56,159 --> 00:24:01,039
uh with uh if we assume certain property

589
00:23:58,720 --> 00:24:04,000
for the underlying cprf

590
00:24:01,039 --> 00:24:06,559
unfortunately her conversion is not

591
00:24:04,000 --> 00:24:08,159
directly applicable to our second cprf

592
00:24:06,559 --> 00:24:09,760
because that doesn't satisfy the

593
00:24:08,159 --> 00:24:12,960
condition

594
00:24:09,760 --> 00:24:15,440
in the recent work of hours we generate

595
00:24:12,960 --> 00:24:17,360
sampling framework to be applicable to

596
00:24:15,440 --> 00:24:20,960
our second cprf

597
00:24:17,360 --> 00:24:22,399
and as a result we obtained adaptable

598
00:24:20,960 --> 00:24:25,279
secure ipe

599
00:24:22,400 --> 00:24:28,159
from lwe which have been opened for

600
00:24:25,279 --> 00:24:28,159
almost a decade

601
00:24:28,720 --> 00:24:33,840
this is our summary slide thank you for

602
00:24:31,279 --> 00:24:33,840
your attention

