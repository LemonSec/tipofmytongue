1
00:00:01,040 --> 00:00:04,880
hello i'm jack derner coming before you

2
00:00:03,280 --> 00:00:06,720
today with my pandemic here to talk

3
00:00:04,880 --> 00:00:07,919
about multi-party generation of rsa

4
00:00:06,720 --> 00:00:10,000
moduli

5
00:00:07,919 --> 00:00:10,959
this is joint work with megan chen ron

6
00:00:10,000 --> 00:00:13,519
cohen joshua

7
00:00:10,960 --> 00:00:14,400
conde issa lee shula rosefield and abi

8
00:00:13,519 --> 00:00:16,000
shalat

9
00:00:14,400 --> 00:00:20,640
and you can find our paper online as

10
00:00:16,000 --> 00:00:22,880
iacr eprint number 2020-370.

11
00:00:20,640 --> 00:00:24,960
in this work we introduce a new protocol

12
00:00:22,880 --> 00:00:26,560
for distributed rsa modulus sampling

13
00:00:24,960 --> 00:00:29,279
with malicious security against a

14
00:00:26,560 --> 00:00:30,880
dishonest majority in the uc model

15
00:00:29,279 --> 00:00:32,238
hours is the first such protocol from

16
00:00:30,880 --> 00:00:33,680
only oblivious transfer and the

17
00:00:32,238 --> 00:00:35,440
factoring assumption to support an

18
00:00:33,680 --> 00:00:37,040
arbitrary number of parties

19
00:00:35,440 --> 00:00:38,800
and so far as we know the first to

20
00:00:37,040 --> 00:00:41,040
achieve cubic complexity or better in

21
00:00:38,800 --> 00:00:43,440
the length of the modulus

22
00:00:41,040 --> 00:00:44,480
an rsa modulus usually designated by the

23
00:00:43,440 --> 00:00:46,559
variable n

24
00:00:44,480 --> 00:00:48,239
is the product of two large randomly

25
00:00:46,559 --> 00:00:51,360
chosen primes which we call p

26
00:00:48,239 --> 00:00:52,959
and q we call such numbers by primes and

27
00:00:51,360 --> 00:00:55,840
in this talk i will use the terms by

28
00:00:52,960 --> 00:00:57,360
prime and rsa modulus interchangeably

29
00:00:55,840 --> 00:00:59,280
it is one of the oldest public key

30
00:00:57,360 --> 00:01:00,719
assumptions we have that factoring such

31
00:00:59,280 --> 00:01:02,800
numbers is hard

32
00:01:00,719 --> 00:01:04,479
and when used as the modulus they form

33
00:01:02,800 --> 00:01:05,759
multiplicative groups wherein finding

34
00:01:04,479 --> 00:01:07,039
the group order is equivalent to

35
00:01:05,760 --> 00:01:09,439
factoring

36
00:01:07,040 --> 00:01:11,439
this makes rsa moduli useful for a huge

37
00:01:09,439 --> 00:01:12,720
range of applications

38
00:01:11,439 --> 00:01:14,479
of course they can be used to construct

39
00:01:12,720 --> 00:01:15,119
signature schemes and various kinds of

40
00:01:14,479 --> 00:01:16,720
encryption

41
00:01:15,119 --> 00:01:18,880
but they're also useful for building

42
00:01:16,720 --> 00:01:20,560
advanced primitives such as for example

43
00:01:18,880 --> 00:01:22,798
cryptographic accumulators

44
00:01:20,560 --> 00:01:24,000
and time lock puzzles and verifiable

45
00:01:22,799 --> 00:01:25,840
delay functions

46
00:01:24,000 --> 00:01:27,200
and recently some kinds of highly

47
00:01:25,840 --> 00:01:28,320
efficient zero-knowledge argument

48
00:01:27,200 --> 00:01:30,720
systems

49
00:01:28,320 --> 00:01:31,679
this list is far from exhaustive

50
00:01:30,720 --> 00:01:33,520
amazingly

51
00:01:31,680 --> 00:01:35,040
although rsa is one of the seminal

52
00:01:33,520 --> 00:01:36,399
asymmetric crypto systems

53
00:01:35,040 --> 00:01:38,640
many of these applications are very

54
00:01:36,400 --> 00:01:40,000
recent in fact all of the ones i've

55
00:01:38,640 --> 00:01:42,560
highlighted here were published within

56
00:01:40,000 --> 00:01:45,200
the last two years they all use rsa

57
00:01:42,560 --> 00:01:47,040
moduli as part of their trusted setup

58
00:01:45,200 --> 00:01:48,960
however there's no way that we know of

59
00:01:47,040 --> 00:01:50,079
to sample a buy prime for which nobody

60
00:01:48,960 --> 00:01:52,320
knows the factors

61
00:01:50,079 --> 00:01:53,839
using only public randomness so the

62
00:01:52,320 --> 00:01:54,639
remaining option is to distribute

63
00:01:53,840 --> 00:01:56,479
sampling

64
00:01:54,640 --> 00:01:58,399
among many parties using multi-party

65
00:01:56,479 --> 00:02:00,399
computation

66
00:01:58,399 --> 00:02:02,000
this isn't merely a theoretical concern

67
00:02:00,399 --> 00:02:03,439
by the way the ethereum foundation has

68
00:02:02,000 --> 00:02:05,759
publicly announced an intention to

69
00:02:03,439 --> 00:02:06,719
migrate to rsa-based verifiable delay

70
00:02:05,759 --> 00:02:08,479
functions

71
00:02:06,719 --> 00:02:10,160
which means that they need secure by

72
00:02:08,479 --> 00:02:11,599
prime sampling in the real world

73
00:02:10,160 --> 00:02:13,200
and they needed to be efficient for many

74
00:02:11,599 --> 00:02:14,799
parties

75
00:02:13,200 --> 00:02:16,560
it's not surprising to find that the

76
00:02:14,800 --> 00:02:19,040
history of secure byprime sampling

77
00:02:16,560 --> 00:02:20,879
mirrors the history of its applications

78
00:02:19,040 --> 00:02:22,480
a great deal of initial interest and a

79
00:02:20,879 --> 00:02:24,000
recent resurgence

80
00:02:22,480 --> 00:02:26,399
bonai and franklin wrote the seminal

81
00:02:24,000 --> 00:02:27,920
paper on the subject in 1997

82
00:02:26,400 --> 00:02:29,520
and pretty much all of the subsequent

83
00:02:27,920 --> 00:02:31,119
works follow their basic layout

84
00:02:29,520 --> 00:02:32,640
including ours

85
00:02:31,120 --> 00:02:34,640
i'm going to skip most of the history

86
00:02:32,640 --> 00:02:36,079
which focused on semi-honest or honest

87
00:02:34,640 --> 00:02:37,920
majority constructions

88
00:02:36,080 --> 00:02:39,920
and talk only about the most recent

89
00:02:37,920 --> 00:02:41,679
works which are those of huzai nicholson

90
00:02:39,920 --> 00:02:43,599
robin toft and nicolosi

91
00:02:41,680 --> 00:02:44,800
and frederiks and lindell oceador and

92
00:02:43,599 --> 00:02:46,480
pincus

93
00:02:44,800 --> 00:02:48,080
i'd also like to point out that there is

94
00:02:46,480 --> 00:02:49,359
already a follow-up to our work which

95
00:02:48,080 --> 00:02:50,160
uses some of the techniques we

96
00:02:49,360 --> 00:02:52,319
introduced

97
00:02:50,160 --> 00:02:54,560
and achieves a really astonishing

98
00:02:52,319 --> 00:02:56,640
performance in the aggregator model

99
00:02:54,560 --> 00:02:57,599
that paper is on eprint now and it will

100
00:02:56,640 --> 00:03:01,760
appear at s

101
00:02:57,599 --> 00:03:03,200
p in 2021 after i talk about these prior

102
00:03:01,760 --> 00:03:05,280
works and the general shape of the

103
00:03:03,200 --> 00:03:06,000
problem i'll introduce our protocol

104
00:03:05,280 --> 00:03:07,680
itself

105
00:03:06,000 --> 00:03:09,440
and after that i'll show you why it's

106
00:03:07,680 --> 00:03:11,840
efficient

107
00:03:09,440 --> 00:03:13,760
now i claim that generating an rsa by

108
00:03:11,840 --> 00:03:15,440
prime using a multi-party protocol

109
00:03:13,760 --> 00:03:17,120
is uniquely difficult relative to

110
00:03:15,440 --> 00:03:19,040
multi-party key generation for other

111
00:03:17,120 --> 00:03:22,239
kinds of cryptosystems because

112
00:03:19,040 --> 00:03:22,959
we sample by primes by rejection that is

113
00:03:22,239 --> 00:03:24,959
we pick a k

114
00:03:22,959 --> 00:03:26,000
bit number where k is a security

115
00:03:24,959 --> 00:03:27,920
parameter

116
00:03:26,000 --> 00:03:29,680
test whether it's prime and throw it

117
00:03:27,920 --> 00:03:32,000
away if it's not

118
00:03:29,680 --> 00:03:34,319
when we find two primes p and q we

119
00:03:32,000 --> 00:03:35,120
multiply them together to form a 2k bit

120
00:03:34,319 --> 00:03:38,000
by prime

121
00:03:35,120 --> 00:03:39,599
n primality is usually determined via

122
00:03:38,000 --> 00:03:41,599
the miller robin test

123
00:03:39,599 --> 00:03:42,879
i won't show it to you in detail but the

124
00:03:41,599 --> 00:03:44,879
important thing to know is that it

125
00:03:42,879 --> 00:03:45,679
requires us to repeatedly take a random

126
00:03:44,879 --> 00:03:48,720
base a

127
00:03:45,680 --> 00:03:50,400
to some secret power modulo p

128
00:03:48,720 --> 00:03:52,239
turning this into a multi-party protocol

129
00:03:50,400 --> 00:03:54,400
naively would require many secure

130
00:03:52,239 --> 00:03:57,519
modular exponentiations with large

131
00:03:54,400 --> 00:03:59,200
secret moduli and this is very very far

132
00:03:57,519 --> 00:04:00,640
from practical

133
00:03:59,200 --> 00:04:02,560
bonnie and franklin were the first to

134
00:04:00,640 --> 00:04:03,359
recognize this and in the seminal paper

135
00:04:02,560 --> 00:04:05,120
on this topic

136
00:04:03,360 --> 00:04:06,720
they devised a more efficient test in

137
00:04:05,120 --> 00:04:08,640
the semi-honest setting

138
00:04:06,720 --> 00:04:09,920
rather than testing the primality of two

139
00:04:08,640 --> 00:04:12,480
individual numbers

140
00:04:09,920 --> 00:04:14,238
they devised a direct biprimality test

141
00:04:12,480 --> 00:04:16,478
that only use the product of the two

142
00:04:14,239 --> 00:04:17,918
primes which is to say the candidate by

143
00:04:16,478 --> 00:04:19,918
prime n

144
00:04:17,918 --> 00:04:22,400
for some statistical parameter number of

145
00:04:19,918 --> 00:04:24,000
iterations they choose a random base a

146
00:04:22,400 --> 00:04:26,080
with jacobi symbol one

147
00:04:24,000 --> 00:04:27,520
and take it to the power of n minus p

148
00:04:26,080 --> 00:04:30,479
minus q plus 1

149
00:04:27,520 --> 00:04:31,198
modulo n if this is equal to plus or

150
00:04:30,479 --> 00:04:34,159
minus 1

151
00:04:31,199 --> 00:04:36,080
in all iterations then the test passes

152
00:04:34,160 --> 00:04:38,240
for technical reasons they also require

153
00:04:36,080 --> 00:04:39,199
a gcd test but we won't worry about this

154
00:04:38,240 --> 00:04:41,199
for now

155
00:04:39,199 --> 00:04:43,520
the key here is that the modulus n is

156
00:04:41,199 --> 00:04:45,280
the public output of the protocol

157
00:04:43,520 --> 00:04:46,960
this means that we can cut the factors p

158
00:04:45,280 --> 00:04:49,520
and q into integer shares

159
00:04:46,960 --> 00:04:51,520
one share of each for every party and

160
00:04:49,520 --> 00:04:52,960
then rewrite the test as the product of

161
00:04:51,520 --> 00:04:54,560
terms that the parties can compute

162
00:04:52,960 --> 00:04:56,320
locally

163
00:04:54,560 --> 00:04:58,320
an integer sharing in this case is

164
00:04:56,320 --> 00:05:00,159
simply a set of randomly chosen

165
00:04:58,320 --> 00:05:01,840
positive integers that add up to the

166
00:05:00,160 --> 00:05:03,520
shared value

167
00:05:01,840 --> 00:05:05,440
this style of sharing is important

168
00:05:03,520 --> 00:05:06,960
because it yields a natural method for

169
00:05:05,440 --> 00:05:09,600
reconstructing p and q

170
00:05:06,960 --> 00:05:10,159
modulo phi of n in the exponent where

171
00:05:09,600 --> 00:05:11,840
phi of n

172
00:05:10,160 --> 00:05:14,639
is the order of the multiplicative group

173
00:05:11,840 --> 00:05:14,638
modulo n

174
00:05:14,880 --> 00:05:19,360
if you know one or more integer shares

175
00:05:16,800 --> 00:05:21,120
of a value then you know both upper and

176
00:05:19,360 --> 00:05:23,520
lower bounds on that value

177
00:05:21,120 --> 00:05:24,960
in other words integer shares leak some

178
00:05:23,520 --> 00:05:26,479
information

179
00:05:24,960 --> 00:05:28,239
bone and franklin provide a proof that

180
00:05:26,479 --> 00:05:30,000
this leakage doesn't grant an adversary

181
00:05:28,240 --> 00:05:31,199
any meaningful advantage in factoring

182
00:05:30,000 --> 00:05:33,199
the biprimes that their protocol

183
00:05:31,199 --> 00:05:35,039
produces

184
00:05:33,199 --> 00:05:37,039
although the bone franklin test itself

185
00:05:35,039 --> 00:05:38,240
is efficient the downside is that it

186
00:05:37,039 --> 00:05:40,800
requires us to guess

187
00:05:38,240 --> 00:05:41,919
two long prime numbers simultaneously in

188
00:05:40,800 --> 00:05:43,680
order to succeed

189
00:05:41,919 --> 00:05:46,080
instead of just one as in the case of

190
00:05:43,680 --> 00:05:48,320
individual primality testing

191
00:05:46,080 --> 00:05:50,320
to increase the probability of success

192
00:05:48,320 --> 00:05:52,000
bone and franklin try to filter out some

193
00:05:50,320 --> 00:05:53,840
of the candidate ps and queues that are

194
00:05:52,000 --> 00:05:55,120
obviously not prime before running the

195
00:05:53,840 --> 00:05:57,039
test

196
00:05:55,120 --> 00:05:59,199
each candidate factor is divided by a

197
00:05:57,039 --> 00:06:00,800
sequence of small primes and rejected if

198
00:05:59,199 --> 00:06:03,039
it divides evenly

199
00:06:00,800 --> 00:06:04,960
this is known as trial division they

200
00:06:03,039 --> 00:06:06,080
show that if a kbit candidate prime is

201
00:06:04,960 --> 00:06:07,840
sampled uniformly

202
00:06:06,080 --> 00:06:10,240
and it passes trial division by all

203
00:06:07,840 --> 00:06:12,000
primes up to some bound capital b

204
00:06:10,240 --> 00:06:13,520
then it's prime with probability an

205
00:06:12,000 --> 00:06:16,160
omega of log of b

206
00:06:13,520 --> 00:06:18,080
over k the probability that the

207
00:06:16,160 --> 00:06:20,240
biprimality test six seeds

208
00:06:18,080 --> 00:06:21,359
is the square of that and if you repeat

209
00:06:20,240 --> 00:06:24,000
the whole protocol

210
00:06:21,360 --> 00:06:25,440
until you successfully sample a by prime

211
00:06:24,000 --> 00:06:27,600
then the number of times that you have

212
00:06:25,440 --> 00:06:31,280
to repeat it is in expectation

213
00:06:27,600 --> 00:06:33,120
of k squared over log squared b

214
00:06:31,280 --> 00:06:36,638
now as i said i'm going to skip forward

215
00:06:33,120 --> 00:06:38,800
a bit 15 years later the hmrt protocol

216
00:06:36,639 --> 00:06:40,720
was the first to support an arbitrary

217
00:06:38,800 --> 00:06:43,680
number of parties and achieve malicious

218
00:06:40,720 --> 00:06:46,400
security against a dishonest majority

219
00:06:43,680 --> 00:06:48,720
in order to do this they use homomorphic

220
00:06:46,400 --> 00:06:50,400
encryption and take a gmw-like approach

221
00:06:48,720 --> 00:06:52,560
to achieving security

222
00:06:50,400 --> 00:06:54,638
that is each party proves that each

223
00:06:52,560 --> 00:06:55,919
operation on a ciphertext was performed

224
00:06:54,639 --> 00:06:58,000
correctly

225
00:06:55,919 --> 00:06:59,840
this is conceptually straightforward but

226
00:06:58,000 --> 00:07:00,800
it leads to a somewhat complex security

227
00:06:59,840 --> 00:07:03,520
analysis

228
00:07:00,800 --> 00:07:05,120
and because the hmrt protocol relies

229
00:07:03,520 --> 00:07:07,919
specifically on both pi

230
00:07:05,120 --> 00:07:09,599
encryption and elgamal encryption we are

231
00:07:07,919 --> 00:07:11,198
forced to accept both the decisional

232
00:07:09,599 --> 00:07:12,639
composite residuosity

233
00:07:11,199 --> 00:07:14,800
and decisional diffie-hellman

234
00:07:12,639 --> 00:07:16,240
assumptions furthermore

235
00:07:14,800 --> 00:07:18,160
proving statements about paella and

236
00:07:16,240 --> 00:07:20,080
al-gamal ciphertexts and zero knowledge

237
00:07:18,160 --> 00:07:21,840
is very expensive

238
00:07:20,080 --> 00:07:24,159
even without the zero-knowledge proofs

239
00:07:21,840 --> 00:07:26,239
in semi-honest mode with two parties

240
00:07:24,160 --> 00:07:28,000
they report taking no less than 15

241
00:07:26,240 --> 00:07:29,680
minutes to sample a buy prime

242
00:07:28,000 --> 00:07:31,599
mostly due to the computational cost of

243
00:07:29,680 --> 00:07:33,759
homomorphic encryption

244
00:07:31,599 --> 00:07:35,280
on the other hand the flop protocol

245
00:07:33,759 --> 00:07:37,120
focuses on the two-party case

246
00:07:35,280 --> 00:07:39,039
exclusively and is the first malicious

247
00:07:37,120 --> 00:07:40,720
secure protocol with concrete efficiency

248
00:07:39,039 --> 00:07:41,680
which they demonstrated by implementing

249
00:07:40,720 --> 00:07:43,759
it

250
00:07:41,680 --> 00:07:46,080
instead of homomorphic encryption it

251
00:07:43,759 --> 00:07:47,520
uses one of n oblivious transfer to

252
00:07:46,080 --> 00:07:49,520
implement trial division

253
00:07:47,520 --> 00:07:51,440
and it uses one of two oblivious

254
00:07:49,520 --> 00:07:53,280
transfer to build a malicious gilboa

255
00:07:51,440 --> 00:07:56,080
style multiplier for multiplying p

256
00:07:53,280 --> 00:07:56,719
and q together rather than taking the

257
00:07:56,080 --> 00:07:58,400
gmw

258
00:07:56,720 --> 00:07:59,840
style approach of proving each step

259
00:07:58,400 --> 00:08:01,520
correct as it occurs

260
00:07:59,840 --> 00:08:03,440
the authors instead introduce what they

261
00:08:01,520 --> 00:08:05,440
call a proof of honesty

262
00:08:03,440 --> 00:08:08,000
a single proof that's run at the end

263
00:08:05,440 --> 00:08:10,319
only if the biprimality test passes

264
00:08:08,000 --> 00:08:12,080
which verifies a few key algebraic

265
00:08:10,319 --> 00:08:13,280
relationships among values used in the

266
00:08:12,080 --> 00:08:15,359
protocol

267
00:08:13,280 --> 00:08:16,479
they do also evaluate a symmetric key

268
00:08:15,360 --> 00:08:18,639
relation but

269
00:08:16,479 --> 00:08:20,800
this can somewhat easily be removed so i

270
00:08:18,639 --> 00:08:22,400
won't count it against them

271
00:08:20,800 --> 00:08:24,560
regardless this approach has both

272
00:08:22,400 --> 00:08:26,400
advantages and disadvantages

273
00:08:24,560 --> 00:08:28,000
treating ot as a black box allows

274
00:08:26,400 --> 00:08:29,359
flexibility with respect to which

275
00:08:28,000 --> 00:08:31,759
assumptions are required

276
00:08:29,360 --> 00:08:34,399
and the flop protocol is concretely fast

277
00:08:31,759 --> 00:08:35,919
by comparison to the hmrt protocol

278
00:08:34,399 --> 00:08:37,440
frederickson and all report being able

279
00:08:35,919 --> 00:08:39,039
to sample a buy prime with malicious

280
00:08:37,440 --> 00:08:40,320
security in roughly two and a half

281
00:08:39,039 --> 00:08:41,838
minutes when using high performance

282
00:08:40,320 --> 00:08:44,080
hardware

283
00:08:41,839 --> 00:08:45,760
on the other hand their ot-based trial

284
00:08:44,080 --> 00:08:47,200
division method leaks some bits of the

285
00:08:45,760 --> 00:08:49,120
candidate primes

286
00:08:47,200 --> 00:08:51,279
this is selective leakage on the part of

287
00:08:49,120 --> 00:08:54,399
an adversary and not merely a natural

288
00:08:51,279 --> 00:08:56,160
byproduct of using integer shares

289
00:08:54,399 --> 00:08:57,839
furthermore while their proof of honesty

290
00:08:56,160 --> 00:08:58,719
framework frees them from the costs of

291
00:08:57,839 --> 00:09:00,480
the gmw

292
00:08:58,720 --> 00:09:02,560
approach they only run it when the

293
00:09:00,480 --> 00:09:04,000
biprimality test succeeds

294
00:09:02,560 --> 00:09:05,920
which means it's possible for a

295
00:09:04,000 --> 00:09:07,279
malicious adversary to force failures

296
00:09:05,920 --> 00:09:09,279
covertly

297
00:09:07,279 --> 00:09:10,880
the adversary can combine this ability

298
00:09:09,279 --> 00:09:12,880
with the leakage i mentioned before to

299
00:09:10,880 --> 00:09:14,160
reject candidates selectively

300
00:09:12,880 --> 00:09:16,000
and the only way to prevent the

301
00:09:14,160 --> 00:09:17,040
adversary from engaging in a denial of

302
00:09:16,000 --> 00:09:18,880
service attack

303
00:09:17,040 --> 00:09:20,800
is to run so many instances of the

304
00:09:18,880 --> 00:09:22,080
sampling procedure that a biprime should

305
00:09:20,800 --> 00:09:23,599
be produced with overwhelming

306
00:09:22,080 --> 00:09:25,360
probability

307
00:09:23,600 --> 00:09:27,519
thus a malicious adversary can slow

308
00:09:25,360 --> 00:09:30,640
their protocol down by a factor of up to

309
00:09:27,519 --> 00:09:32,320
the statistical security parameter

310
00:09:30,640 --> 00:09:34,080
in the wake of these two works then we

311
00:09:32,320 --> 00:09:35,920
have an open question

312
00:09:34,080 --> 00:09:37,920
can one build a protocol with support

313
00:09:35,920 --> 00:09:39,680
for an arbitrarily many parties and

314
00:09:37,920 --> 00:09:40,560
malicious security against a dishonest

315
00:09:39,680 --> 00:09:42,800
majority

316
00:09:40,560 --> 00:09:44,560
which has flexible assumptions doesn't

317
00:09:42,800 --> 00:09:46,160
require homomorphic encryption

318
00:09:44,560 --> 00:09:47,920
doesn't use expensive zero knowledge

319
00:09:46,160 --> 00:09:50,160
over cryptographic statements

320
00:09:47,920 --> 00:09:52,319
and gives the adversary no extra leakage

321
00:09:50,160 --> 00:09:53,760
or denial of service ability

322
00:09:52,320 --> 00:09:56,399
in this work we answer in the

323
00:09:53,760 --> 00:09:58,240
affirmative we do require

324
00:09:56,399 --> 00:09:59,920
one specific assumption which is the

325
00:09:58,240 --> 00:10:01,839
assumption that it's hard to factor by

326
00:09:59,920 --> 00:10:03,360
primes from our protocol's underlying

327
00:10:01,839 --> 00:10:05,440
sample distribution

328
00:10:03,360 --> 00:10:07,279
but we view this as acceptable since

329
00:10:05,440 --> 00:10:09,200
it's precisely the assumption required

330
00:10:07,279 --> 00:10:10,880
to use the protocol's output

331
00:10:09,200 --> 00:10:12,480
and without it the whole exercise is

332
00:10:10,880 --> 00:10:14,399
pointless

333
00:10:12,480 --> 00:10:16,240
beyond these things we also provide a

334
00:10:14,399 --> 00:10:17,839
modular security analysis

335
00:10:16,240 --> 00:10:20,240
whereas previous works have proven their

336
00:10:17,839 --> 00:10:21,600
protocol somewhat monolithically

337
00:10:20,240 --> 00:10:23,440
we hope this will make it easy to

338
00:10:21,600 --> 00:10:25,120
interchange primitives and potentially

339
00:10:23,440 --> 00:10:26,560
prove new security guarantees in the

340
00:10:25,120 --> 00:10:28,240
future

341
00:10:26,560 --> 00:10:30,560
finally our protocol improves

342
00:10:28,240 --> 00:10:32,079
asymptotically on the flop protocol by a

343
00:10:30,560 --> 00:10:34,640
factor of the security parameter

344
00:10:32,079 --> 00:10:36,880
in terms of communication cost we don't

345
00:10:34,640 --> 00:10:38,959
have an asymptotic analysis of the hmrt

346
00:10:36,880 --> 00:10:40,480
protocols communication costs so i don't

347
00:10:38,959 --> 00:10:41,920
want to make a specific comparative

348
00:10:40,480 --> 00:10:43,920
complexity claim

349
00:10:41,920 --> 00:10:46,079
but i will point out that we know hmrt

350
00:10:43,920 --> 00:10:48,560
to be much more expensive than flop

351
00:10:46,079 --> 00:10:49,920
concretely so now we come to the

352
00:10:48,560 --> 00:10:51,279
protocol itself

353
00:10:49,920 --> 00:10:52,640
for the sake of clarity and time i'm

354
00:10:51,279 --> 00:10:54,320
going to explain a drastically

355
00:10:52,640 --> 00:10:56,240
simplified version

356
00:10:54,320 --> 00:10:57,920
for the most part i'll only talk about

357
00:10:56,240 --> 00:10:59,040
two parties though hopefully you can

358
00:10:57,920 --> 00:11:00,479
imagine how everything can be

359
00:10:59,040 --> 00:11:02,240
generalized

360
00:11:00,480 --> 00:11:04,160
i also won't always talk about how

361
00:11:02,240 --> 00:11:05,600
malicious security can be achieved

362
00:11:04,160 --> 00:11:07,920
but i'll try to let you know where i

363
00:11:05,600 --> 00:11:10,240
make important omissions

364
00:11:07,920 --> 00:11:12,399
our protocol has a simple layout first

365
00:11:10,240 --> 00:11:13,360
it securely samples candidate factors p

366
00:11:12,399 --> 00:11:14,880
and q

367
00:11:13,360 --> 00:11:16,959
then it securely multiplies those

368
00:11:14,880 --> 00:11:18,560
factors to produce a candidate biprime

369
00:11:16,959 --> 00:11:20,880
which it subjects to the bone a franklin

370
00:11:18,560 --> 00:11:22,880
biprimality test and finally

371
00:11:20,880 --> 00:11:24,800
it runs a retroactive consistency check

372
00:11:22,880 --> 00:11:27,120
to ensure no malicious behavior occurred

373
00:11:24,800 --> 00:11:28,880
during the previous phases

374
00:11:27,120 --> 00:11:30,880
the first three parts of this layout are

375
00:11:28,880 --> 00:11:32,399
common among almost all by prime

376
00:11:30,880 --> 00:11:35,040
sampling protocols

377
00:11:32,399 --> 00:11:36,480
they come from bonaire franklin our

378
00:11:35,040 --> 00:11:38,160
consistency check is new

379
00:11:36,480 --> 00:11:40,000
but it can be thought of as somewhat

380
00:11:38,160 --> 00:11:41,920
analogous to the proof of honesty used

381
00:11:40,000 --> 00:11:43,680
by fredericks and a all

382
00:11:41,920 --> 00:11:45,360
i'll talk about the techniques we use to

383
00:11:43,680 --> 00:11:46,000
implement each step of this layout in

384
00:11:45,360 --> 00:11:48,720
turn

385
00:11:46,000 --> 00:11:49,920
starting with sampling our sampling

386
00:11:48,720 --> 00:11:51,600
technique is based on the chinese

387
00:11:49,920 --> 00:11:52,800
remainder theorem so let's recall that

388
00:11:51,600 --> 00:11:54,800
quickly

389
00:11:52,800 --> 00:11:56,000
if we have a vector of the first l

390
00:11:54,800 --> 00:11:58,000
unique primes

391
00:11:56,000 --> 00:12:00,160
which we'll call a primordial vector

392
00:11:58,000 --> 00:12:02,079
here represented by the letter m

393
00:12:00,160 --> 00:12:04,639
and we have the product of those primes

394
00:12:02,079 --> 00:12:06,399
which is the elf primordial number

395
00:12:04,639 --> 00:12:08,480
then the chinese remainder theorem says

396
00:12:06,399 --> 00:12:10,720
that there is an isomorphism between the

397
00:12:08,480 --> 00:12:11,600
product of fields modulo the individual

398
00:12:10,720 --> 00:12:13,600
primes

399
00:12:11,600 --> 00:12:15,680
and the ring modulo the corresponding

400
00:12:13,600 --> 00:12:17,440
primordial number

401
00:12:15,680 --> 00:12:19,199
we'll talk about values in these spaces

402
00:12:17,440 --> 00:12:20,800
a lot so i'm going to color code them to

403
00:12:19,200 --> 00:12:22,480
make it easier

404
00:12:20,800 --> 00:12:24,319
values in the product of the fields

405
00:12:22,480 --> 00:12:25,279
modulo the individual primes will be

406
00:12:24,320 --> 00:12:28,800
magenta

407
00:12:25,279 --> 00:12:30,560
we call this the crt form values in the

408
00:12:28,800 --> 00:12:31,199
ring modulo the primordial number will

409
00:12:30,560 --> 00:12:33,599
be teal

410
00:12:31,200 --> 00:12:34,959
and we'll call this standard form the

411
00:12:33,600 --> 00:12:38,079
chinese remainder theorem

412
00:12:34,959 --> 00:12:40,319
also gives us another important fact a

413
00:12:38,079 --> 00:12:40,719
set of values in crt form which we'll

414
00:12:40,320 --> 00:12:43,680
call

415
00:12:40,720 --> 00:12:45,279
x map to a value in standard form we'll

416
00:12:43,680 --> 00:12:48,000
call this value p

417
00:12:45,279 --> 00:12:49,120
if and only if the jth element of x is

418
00:12:48,000 --> 00:12:52,560
congruent to p

419
00:12:49,120 --> 00:12:55,120
modulo the jth prime for all j

420
00:12:52,560 --> 00:12:56,479
this means that if you select a crt form

421
00:12:55,120 --> 00:12:59,120
vector x with no

422
00:12:56,480 --> 00:13:00,480
zero elements then the corresponding

423
00:12:59,120 --> 00:13:02,480
standard form value p

424
00:13:00,480 --> 00:13:04,959
will not be divisible by any of the

425
00:13:02,480 --> 00:13:07,120
primes in the primordial vector

426
00:13:04,959 --> 00:13:08,079
thus we sample probable primes without

427
00:13:07,120 --> 00:13:11,200
trial division

428
00:13:08,079 --> 00:13:13,040
we call this constructive sampling

429
00:13:11,200 --> 00:13:14,800
if we had only one party our sampling

430
00:13:13,040 --> 00:13:17,599
algorithm would be simple

431
00:13:14,800 --> 00:13:19,040
choose a crt form value randomly test to

432
00:13:17,600 --> 00:13:20,000
make sure all of its elements are

433
00:13:19,040 --> 00:13:21,519
non-zero

434
00:13:20,000 --> 00:13:23,519
then find the corresponding standard

435
00:13:21,519 --> 00:13:25,200
form value and interpret it as an

436
00:13:23,519 --> 00:13:28,000
integer which is our candidate prime

437
00:13:25,200 --> 00:13:29,920
p it turns out that if we want to

438
00:13:28,000 --> 00:13:31,600
distribute this algorithm we can do so

439
00:13:29,920 --> 00:13:32,240
by instructing the parties to run the

440
00:13:31,600 --> 00:13:34,240
algorithm

441
00:13:32,240 --> 00:13:37,120
individually and locally to generate

442
00:13:34,240 --> 00:13:38,800
integer shares of the candidate prime p

443
00:13:37,120 --> 00:13:41,199
and instead of performing local zero

444
00:13:38,800 --> 00:13:43,199
tests we instruct them to jointly test

445
00:13:41,199 --> 00:13:45,040
the modular sums of their crt form

446
00:13:43,199 --> 00:13:46,399
elements in each small prime field or

447
00:13:45,040 --> 00:13:48,719
non-zero

448
00:13:46,399 --> 00:13:50,000
i'm going to gloss over how this works

449
00:13:48,720 --> 00:13:52,240
for the moment

450
00:13:50,000 --> 00:13:54,560
we show that if they do this then the

451
00:13:52,240 --> 00:13:55,519
integer sum of their shares of p will be

452
00:13:54,560 --> 00:13:57,119
indivisible by

453
00:13:55,519 --> 00:13:59,440
all of the primes in the primordial

454
00:13:57,120 --> 00:14:01,440
vector and of course they can repeat the

455
00:13:59,440 --> 00:14:03,199
process to sample q

456
00:14:01,440 --> 00:14:05,120
the integer shares here are important by

457
00:14:03,199 --> 00:14:06,560
the way we need them for compatibility

458
00:14:05,120 --> 00:14:09,120
with the bone franklin test

459
00:14:06,560 --> 00:14:10,319
which we're going to run later now once

460
00:14:09,120 --> 00:14:12,320
the parties have shares of p

461
00:14:10,320 --> 00:14:14,639
and q they must multiply them together

462
00:14:12,320 --> 00:14:16,079
to form shares of a by prime n

463
00:14:14,639 --> 00:14:17,600
this is where all prior works have

464
00:14:16,079 --> 00:14:19,839
encountered a bottleneck in the form of

465
00:14:17,600 --> 00:14:23,600
multiplication protocols over length k

466
00:14:19,839 --> 00:14:25,199
inputs typically ot-based multi-party

467
00:14:23,600 --> 00:14:27,199
multiplication protocols have at least

468
00:14:25,199 --> 00:14:28,839
quadratic computation and communication

469
00:14:27,199 --> 00:14:30,160
complexity in the bit length of their

470
00:14:28,839 --> 00:14:31,440
inputs

471
00:14:30,160 --> 00:14:33,120
homomorphic encryption-based

472
00:14:31,440 --> 00:14:34,720
multiplication protocols like the ones

473
00:14:33,120 --> 00:14:37,199
used by hmrt

474
00:14:34,720 --> 00:14:39,440
have better communication complexity but

475
00:14:37,199 --> 00:14:41,839
worse computation complexity

476
00:14:39,440 --> 00:14:43,760
for example hmrt use pi a encryption

477
00:14:41,839 --> 00:14:45,440
which requires modular exponentiation

478
00:14:43,760 --> 00:14:46,800
with a modulus of length proportionate

479
00:14:45,440 --> 00:14:48,639
to k

480
00:14:46,800 --> 00:14:50,160
we take the ot based approach but we

481
00:14:48,639 --> 00:14:51,839
leverage the chinese remainder theorem

482
00:14:50,160 --> 00:14:54,639
once again to improve our result

483
00:14:51,839 --> 00:14:56,399
relative to naive multiplication

484
00:14:54,639 --> 00:14:58,560
once again consider the single party

485
00:14:56,399 --> 00:15:01,839
case we observe that if we take

486
00:14:58,560 --> 00:15:03,920
two crt form values x and u defined with

487
00:15:01,839 --> 00:15:05,120
respect to the same primorial vector m

488
00:15:03,920 --> 00:15:06,880
of length l

489
00:15:05,120 --> 00:15:08,480
then the product of their corresponding

490
00:15:06,880 --> 00:15:11,519
standard form values p

491
00:15:08,480 --> 00:15:14,160
and q modulo the lth primorial number

492
00:15:11,519 --> 00:15:16,240
corresponds to the element-wise modular

493
00:15:14,160 --> 00:15:18,000
product of x and u

494
00:15:16,240 --> 00:15:20,560
here i'm using the circle dot to

495
00:15:18,000 --> 00:15:22,240
represent element-wise multiplication

496
00:15:20,560 --> 00:15:24,000
this means that if we want the standard

497
00:15:22,240 --> 00:15:26,639
form product of p and q

498
00:15:24,000 --> 00:15:27,040
we can multiply the crt form values x

499
00:15:26,639 --> 00:15:29,360
and u

500
00:15:27,040 --> 00:15:31,040
element by element then evaluate the

501
00:15:29,360 --> 00:15:33,680
mapping instead of evaluating the

502
00:15:31,040 --> 00:15:35,680
mapping before multiplication

503
00:15:33,680 --> 00:15:36,719
we can show that if a primordial number

504
00:15:35,680 --> 00:15:38,560
has k bits

505
00:15:36,720 --> 00:15:40,560
then the length of the largest prime in

506
00:15:38,560 --> 00:15:43,839
the corresponding primordial vector

507
00:15:40,560 --> 00:15:45,920
is an o of log k and also that l

508
00:15:43,839 --> 00:15:48,320
the length of the primarily vector is an

509
00:15:45,920 --> 00:15:50,319
o of k over log k

510
00:15:48,320 --> 00:15:52,480
consequently if our fundamental

511
00:15:50,320 --> 00:15:54,639
multiplication complexity is quadratic

512
00:15:52,480 --> 00:15:55,920
then we can multiply two k bit numbers

513
00:15:54,639 --> 00:15:59,360
in crt form

514
00:15:55,920 --> 00:15:59,839
in complexity of k log k as opposed to o

515
00:15:59,360 --> 00:16:03,120
of k

516
00:15:59,839 --> 00:16:04,880
squared if we did it naively the zero

517
00:16:03,120 --> 00:16:06,959
testing operation which i glossed over

518
00:16:04,880 --> 00:16:08,160
earlier is done using this distributed

519
00:16:06,959 --> 00:16:10,880
crt multiplication

520
00:16:08,160 --> 00:16:12,719
technique but unfortunately we can't

521
00:16:10,880 --> 00:16:13,199
immediately use the same technique to

522
00:16:12,720 --> 00:16:15,199
compute

523
00:16:13,199 --> 00:16:17,279
n from the candidate primes p and q that

524
00:16:15,199 --> 00:16:18,880
i showed you how to sample a moment ago

525
00:16:17,279 --> 00:16:21,120
because the technique computes the

526
00:16:18,880 --> 00:16:22,959
product modulo the primordial number

527
00:16:21,120 --> 00:16:24,320
whereas we need to compute the integer

528
00:16:22,959 --> 00:16:26,560
product

529
00:16:24,320 --> 00:16:28,399
this is not however a dead end

530
00:16:26,560 --> 00:16:31,040
fortunately we can show that there is a

531
00:16:28,399 --> 00:16:32,240
way to expand a crt representation to

532
00:16:31,040 --> 00:16:34,959
new prime fields

533
00:16:32,240 --> 00:16:37,199
without changing its semantic value this

534
00:16:34,959 --> 00:16:37,599
allows us to enlarge the standard form

535
00:16:37,199 --> 00:16:39,120
ring

536
00:16:37,600 --> 00:16:40,560
to the point that there is no wrapping

537
00:16:39,120 --> 00:16:41,360
when a modular multiplication is

538
00:16:40,560 --> 00:16:43,119
performed

539
00:16:41,360 --> 00:16:45,519
which makes the result equivalent to an

540
00:16:43,120 --> 00:16:47,839
integer multiplication

541
00:16:45,519 --> 00:16:49,600
before we move on i should mention that

542
00:16:47,839 --> 00:16:52,320
because the crt

543
00:16:49,600 --> 00:16:54,480
extension operation is local corrupt

544
00:16:52,320 --> 00:16:56,399
parties can do whatever they want

545
00:16:54,480 --> 00:16:58,399
also because there's no authentication

546
00:16:56,399 --> 00:16:59,360
on the output shares of our element-wise

547
00:16:58,399 --> 00:17:01,519
multiplication

548
00:16:59,360 --> 00:17:02,800
corrupt parties can lie about the shares

549
00:17:01,519 --> 00:17:04,720
that they got

550
00:17:02,800 --> 00:17:06,240
i haven't taken pains to show you how we

551
00:17:04,720 --> 00:17:08,000
achieve malicious security

552
00:17:06,240 --> 00:17:09,839
so it's important to know that even in

553
00:17:08,000 --> 00:17:11,839
the malicious version of our protocol

554
00:17:09,839 --> 00:17:13,280
this sort of cheat is still possible and

555
00:17:11,839 --> 00:17:15,438
we have to account for it later in our

556
00:17:13,280 --> 00:17:17,199
consistency check

557
00:17:15,439 --> 00:17:19,120
i'm only going to talk briefly about the

558
00:17:17,199 --> 00:17:21,280
biprimality test since our protocol

559
00:17:19,119 --> 00:17:22,879
follows mostly from prior work

560
00:17:21,280 --> 00:17:25,678
the interesting thing is that we prove

561
00:17:22,880 --> 00:17:27,839
it realizes a standalone functionality

562
00:17:25,679 --> 00:17:29,600
here i have a simplified version of it

563
00:17:27,839 --> 00:17:32,320
it takes the candidate by prime

564
00:17:29,600 --> 00:17:33,600
n as a common input and integer shares

565
00:17:32,320 --> 00:17:35,840
of the candidate factors p

566
00:17:33,600 --> 00:17:36,719
and q from each party and it outputs

567
00:17:35,840 --> 00:17:39,840
success

568
00:17:36,720 --> 00:17:41,679
only if both n is a bi-prime and n

569
00:17:39,840 --> 00:17:42,879
is really the product of the input

570
00:17:41,679 --> 00:17:45,280
factors

571
00:17:42,880 --> 00:17:47,280
the adversary can also force failures

572
00:17:45,280 --> 00:17:49,280
but it can't force successes

573
00:17:47,280 --> 00:17:51,600
which means that this functionality has

574
00:17:49,280 --> 00:17:53,840
no false positives

575
00:17:51,600 --> 00:17:55,280
the functionality is clean and free of

576
00:17:53,840 --> 00:17:57,678
protocol artifacts such as

577
00:17:55,280 --> 00:17:59,600
authentication primitives and it allows

578
00:17:57,679 --> 00:18:00,720
corrupt parties to use whatever shares

579
00:17:59,600 --> 00:18:02,799
they like

580
00:18:00,720 --> 00:18:04,559
notice however that if n really is a

581
00:18:02,799 --> 00:18:06,160
bi-prime then there are only two

582
00:18:04,559 --> 00:18:08,320
possible pairs of factors p

583
00:18:06,160 --> 00:18:09,440
and q that would make the functionality

584
00:18:08,320 --> 00:18:11,120
succeed

585
00:18:09,440 --> 00:18:13,039
one follows from the honest protocol

586
00:18:11,120 --> 00:18:14,399
execution and we show that finding the

587
00:18:13,039 --> 00:18:17,200
other is as hard as factoring

588
00:18:14,400 --> 00:18:18,880
n this is an important and subtle case

589
00:18:17,200 --> 00:18:21,200
that is essential to our simulation

590
00:18:18,880 --> 00:18:23,919
argument

591
00:18:21,200 --> 00:18:24,640
finally we come to the consistency check

592
00:18:23,919 --> 00:18:26,160
so far

593
00:18:24,640 --> 00:18:27,919
every part of the protocol that you've

594
00:18:26,160 --> 00:18:29,919
seen has been composed of simple

595
00:18:27,919 --> 00:18:31,679
non-cryptographic operations

596
00:18:29,919 --> 00:18:33,840
and the only functionalities involved

597
00:18:31,679 --> 00:18:37,120
have been a multiplication functionality

598
00:18:33,840 --> 00:18:38,959
and a biprimality testing functionality

599
00:18:37,120 --> 00:18:40,479
our retroactive consistency check

600
00:18:38,960 --> 00:18:42,080
ensures that the local operations are

601
00:18:40,480 --> 00:18:43,280
performed correctly

602
00:18:42,080 --> 00:18:44,240
and that the inputs to the

603
00:18:43,280 --> 00:18:45,840
functionalities have the right

604
00:18:44,240 --> 00:18:47,840
relationships

605
00:18:45,840 --> 00:18:49,678
we show that there exists a simple

606
00:18:47,840 --> 00:18:50,320
algebraic predicate involving only the

607
00:18:49,679 --> 00:18:53,200
modulus

608
00:18:50,320 --> 00:18:53,760
n and the expanded crt form shares of p

609
00:18:53,200 --> 00:18:55,280
and q

610
00:18:53,760 --> 00:18:57,679
here again i'm showing it to you in the

611
00:18:55,280 --> 00:18:59,200
two-party setting which is sufficient to

612
00:18:57,679 --> 00:19:02,080
guarantee security against

613
00:18:59,200 --> 00:19:02,480
malicious behavior if the biprimality

614
00:19:02,080 --> 00:19:05,280
test

615
00:19:02,480 --> 00:19:07,760
passed then n might be our output so we

616
00:19:05,280 --> 00:19:09,440
evaluate this predicate securely

617
00:19:07,760 --> 00:19:11,600
in the current version of the paper we

618
00:19:09,440 --> 00:19:12,960
use generic mpc for a canonical

619
00:19:11,600 --> 00:19:14,719
instantiation

620
00:19:12,960 --> 00:19:17,600
but it's conceivable that this can be

621
00:19:14,720 --> 00:19:20,240
improved with tailored protocols

622
00:19:17,600 --> 00:19:22,240
this can be comparatively slow but we

623
00:19:20,240 --> 00:19:24,640
only have to do it when we succeed

624
00:19:22,240 --> 00:19:25,360
if the by primality test failed then

625
00:19:24,640 --> 00:19:28,400
either n

626
00:19:25,360 --> 00:19:30,559
isn't a biprime or some party cheated

627
00:19:28,400 --> 00:19:32,400
regardless there's no need for privacy

628
00:19:30,559 --> 00:19:33,200
and so the parties open up their values

629
00:19:32,400 --> 00:19:35,200
to one another

630
00:19:33,200 --> 00:19:36,960
and verify the predicate locally which

631
00:19:35,200 --> 00:19:38,400
is much faster

632
00:19:36,960 --> 00:19:40,480
there are a lot of details that i'm

633
00:19:38,400 --> 00:19:42,160
sweeping under the rug here for example

634
00:19:40,480 --> 00:19:43,840
we have to enforce that the inputs to

635
00:19:42,160 --> 00:19:46,000
the multiplication functionality are

636
00:19:43,840 --> 00:19:47,039
opened or loaded into the generic npc

637
00:19:46,000 --> 00:19:49,679
faithfully

638
00:19:47,039 --> 00:19:51,520
but this is the essence of it of course

639
00:19:49,679 --> 00:19:52,080
the paper gives a rigorous simulation

640
00:19:51,520 --> 00:19:53,918
based proof

641
00:19:52,080 --> 00:19:56,159
so for the details i invite you to look

642
00:19:53,919 --> 00:19:57,679
there

643
00:19:56,160 --> 00:19:59,600
now before i close i want to talk a

644
00:19:57,679 --> 00:20:01,200
little bit about efficiency

645
00:19:59,600 --> 00:20:02,399
i've been qualifying my complexity

646
00:20:01,200 --> 00:20:04,240
statements throughout this talk by

647
00:20:02,400 --> 00:20:06,000
saying that they hold if multiplication

648
00:20:04,240 --> 00:20:07,760
has a quadratic cost

649
00:20:06,000 --> 00:20:09,360
in the malicious setting we instantiate

650
00:20:07,760 --> 00:20:11,440
our multiplication functionality using

651
00:20:09,360 --> 00:20:13,520
an ot based construction derived from

652
00:20:11,440 --> 00:20:16,159
multipliers introduced by recent works

653
00:20:13,520 --> 00:20:18,158
on secure ecdsa signing

654
00:20:16,159 --> 00:20:20,159
as a basis we use the silent ot

655
00:20:18,159 --> 00:20:20,960
extension scheme introduced last year by

656
00:20:20,159 --> 00:20:23,600
boyle

657
00:20:20,960 --> 00:20:26,080
gilboa ishai cole and scholl which has

658
00:20:23,600 --> 00:20:27,918
almost no overhead when amortized

659
00:20:26,080 --> 00:20:29,840
but the multiplier construction itself

660
00:20:27,919 --> 00:20:31,840
requires a special encoding scheme which

661
00:20:29,840 --> 00:20:35,520
means that it has communication constant

662
00:20:31,840 --> 00:20:38,080
o of n x squared plus nsx per party

663
00:20:35,520 --> 00:20:40,480
for n parties and x bit inputs where s

664
00:20:38,080 --> 00:20:42,399
is the statistical parameter

665
00:20:40,480 --> 00:20:43,760
this leads to an overall communication

666
00:20:42,400 --> 00:20:45,840
complexity and of

667
00:20:43,760 --> 00:20:47,600
nsk for sampling and modulus

668
00:20:45,840 --> 00:20:50,080
construction

669
00:20:47,600 --> 00:20:52,080
as an aside if we use the ot extension

670
00:20:50,080 --> 00:20:54,399
protocol of keller or cenia in shoal

671
00:20:52,080 --> 00:20:55,918
instead of silent ot extension then this

672
00:20:54,400 --> 00:20:58,400
cost goes up by a factor of

673
00:20:55,919 --> 00:21:00,880
s over log k which is concretely

674
00:20:58,400 --> 00:21:03,200
something like 4 to 8.

675
00:21:00,880 --> 00:21:04,559
our biprimality test has different costs

676
00:21:03,200 --> 00:21:06,400
depending on whether it reports a

677
00:21:04,559 --> 00:21:09,360
failure or a success

678
00:21:06,400 --> 00:21:10,640
in failed instances it also costs an o

679
00:21:09,360 --> 00:21:12,879
of nsk

680
00:21:10,640 --> 00:21:14,799
in terms of communication but in

681
00:21:12,880 --> 00:21:16,159
successful instances where it determines

682
00:21:14,799 --> 00:21:18,320
that n is a bi-prime

683
00:21:16,159 --> 00:21:19,200
it costs in this term which you don't

684
00:21:18,320 --> 00:21:20,960
need to worry about

685
00:21:19,200 --> 00:21:22,880
because it will be subsumed by something

686
00:21:20,960 --> 00:21:25,039
else later

687
00:21:22,880 --> 00:21:26,480
our consistency check also has different

688
00:21:25,039 --> 00:21:28,240
costs depending on whether or not n is

689
00:21:26,480 --> 00:21:30,400
thought to be a biprime

690
00:21:28,240 --> 00:21:32,240
if n is thought to be a bi-prime then we

691
00:21:30,400 --> 00:21:33,919
use generic npc to evaluate the

692
00:21:32,240 --> 00:21:35,360
predicate securely

693
00:21:33,919 --> 00:21:37,280
if we instantiate this with the

694
00:21:35,360 --> 00:21:38,799
authenticated garbling protocol of wang

695
00:21:37,280 --> 00:21:40,879
ranalucci and cats

696
00:21:38,799 --> 00:21:42,559
then it has communication complexity and

697
00:21:40,880 --> 00:21:46,640
o of n squared

698
00:21:42,559 --> 00:21:48,720
s k squared over log of n k

699
00:21:46,640 --> 00:21:50,559
if n is thought not to be a by prime

700
00:21:48,720 --> 00:21:51,919
then we reveal everything and evaluate

701
00:21:50,559 --> 00:21:54,960
the predicate locally

702
00:21:51,919 --> 00:21:58,320
and the reveal operation costs o of nsk

703
00:21:54,960 --> 00:21:59,919
overall if we repeat the whole protocol

704
00:21:58,320 --> 00:22:02,559
until a success occurs

705
00:21:59,919 --> 00:22:04,480
we need o of k squared over log square

706
00:22:02,559 --> 00:22:06,158
to k repetitions and expectation

707
00:22:04,480 --> 00:22:08,480
which follows from bonnie and franklin's

708
00:22:06,159 --> 00:22:10,559
theorem all but one of these repetitions

709
00:22:08,480 --> 00:22:12,640
will be failures so we pay the smaller

710
00:22:10,559 --> 00:22:14,399
cost for both the buy primality test and

711
00:22:12,640 --> 00:22:16,320
the consistency check

712
00:22:14,400 --> 00:22:18,159
and only in the last repetition do we

713
00:22:16,320 --> 00:22:19,678
pay the larger costs

714
00:22:18,159 --> 00:22:21,360
putting everything together finally

715
00:22:19,679 --> 00:22:23,360
gives us an overall expected

716
00:22:21,360 --> 00:22:24,639
communication complexity per party for

717
00:22:23,360 --> 00:22:27,360
sampling a buy prime

718
00:22:24,640 --> 00:22:28,799
which you can see here now i know my

719
00:22:27,360 --> 00:22:30,559
protocol descriptions and security

720
00:22:28,799 --> 00:22:32,480
arguments have been rather loose but

721
00:22:30,559 --> 00:22:34,879
this is exactly the cost of the real

722
00:22:32,480 --> 00:22:36,559
protocol as presented in the paper

723
00:22:34,880 --> 00:22:38,080
there are a few more lemmas that i won't

724
00:22:36,559 --> 00:22:38,559
show you which allow us to conclude that

725
00:22:38,080 --> 00:22:41,840
this is

726
00:22:38,559 --> 00:22:42,480
strictly less than o of n s k cubed over

727
00:22:41,840 --> 00:22:46,559
log of n

728
00:22:42,480 --> 00:22:48,320
k to conclude i hope that this talk has

729
00:22:46,559 --> 00:22:49,918
convinced you that distributed by prime

730
00:22:48,320 --> 00:22:51,520
sampling is a challenge

731
00:22:49,919 --> 00:22:53,039
i've shown you how the chinese remainder

732
00:22:51,520 --> 00:22:54,799
theorem can be used to optimize the

733
00:22:53,039 --> 00:22:56,400
sampling of candidate primes

734
00:22:54,799 --> 00:22:58,480
and how it can be used to optimize

735
00:22:56,400 --> 00:23:00,080
multiplying those candidates together

736
00:22:58,480 --> 00:23:01,600
and i've shown you how an algebraic

737
00:23:00,080 --> 00:23:03,280
predicate can be used to tie

738
00:23:01,600 --> 00:23:05,039
everything together without homomorphic

739
00:23:03,280 --> 00:23:06,639
encryption or proofs over cryptographic

740
00:23:05,039 --> 00:23:08,400
statements

741
00:23:06,640 --> 00:23:10,240
in the paper of course everything is

742
00:23:08,400 --> 00:23:12,720
presented in much more rigor

743
00:23:10,240 --> 00:23:13,840
and there are a few additional results

744
00:23:12,720 --> 00:23:15,600
we show how to achieve

745
00:23:13,840 --> 00:23:17,840
a constant round count and we give a

746
00:23:15,600 --> 00:23:19,918
concrete cost analysis

747
00:23:17,840 --> 00:23:21,760
we also present a semi-honest variant of

748
00:23:19,919 --> 00:23:23,120
the protocol with perfect security in

749
00:23:21,760 --> 00:23:24,158
the same hybrid model as the main

750
00:23:23,120 --> 00:23:26,320
protocol

751
00:23:24,159 --> 00:23:27,679
and we give a modular security analysis

752
00:23:26,320 --> 00:23:29,439
of the main protocol

753
00:23:27,679 --> 00:23:31,520
with some informal discussion of how

754
00:23:29,440 --> 00:23:33,280
various modules can be substituted to

755
00:23:31,520 --> 00:23:33,760
achieve stronger security guarantees

756
00:23:33,280 --> 00:23:37,600
such as

757
00:23:33,760 --> 00:23:39,600
adaptive security or identifiable abort

758
00:23:37,600 --> 00:23:44,158
that's all for today though thank you

759
00:23:39,600 --> 00:23:44,158
for listening

