1
00:00:01,760 --> 00:00:05,759
hello i'm going to be talking about

2
00:00:03,840 --> 00:00:08,559
uh non-interactive zero knowledge

3
00:00:05,759 --> 00:00:10,800
arguments for qma with pre-processing

4
00:00:08,559 --> 00:00:12,799
i'm tina zhang and this was joint work

5
00:00:10,800 --> 00:00:15,200
with andrea carlo d'angelo and tamara

6
00:00:12,799 --> 00:00:15,200
viddick

7
00:00:15,679 --> 00:00:18,240
so i want to motivate a little bit the

8
00:00:17,119 --> 00:00:19,359
problem that we're going to try and

9
00:00:18,240 --> 00:00:20,880
study and

10
00:00:19,359 --> 00:00:23,279
to do that i have to remind everyone

11
00:00:20,880 --> 00:00:24,799
about interactive proof systems and what

12
00:00:23,279 --> 00:00:28,080
they're used for

13
00:00:24,800 --> 00:00:30,400
so let's suppose that we have a graph

14
00:00:28,080 --> 00:00:32,960
uh x and let's suppose that today our

15
00:00:30,400 --> 00:00:34,719
purpose in life is to decide whether x

16
00:00:32,960 --> 00:00:36,880
is three colorable or not three

17
00:00:34,719 --> 00:00:38,399
colorable and by three colorable of

18
00:00:36,880 --> 00:00:39,280
course we mean that a graph can be

19
00:00:38,399 --> 00:00:41,120
colored

20
00:00:39,280 --> 00:00:42,559
using only three colors such that each

21
00:00:41,120 --> 00:00:45,599
edge connects

22
00:00:42,559 --> 00:00:46,079
two vertices of different colors so of

23
00:00:45,600 --> 00:00:47,680
course

24
00:00:46,079 --> 00:00:49,360
three coloring is a problem that's

25
00:00:47,680 --> 00:00:51,199
complete for mp

26
00:00:49,360 --> 00:00:54,480
so if we can decide this problem we can

27
00:00:51,199 --> 00:00:56,399
decide any problem in mp

28
00:00:54,480 --> 00:00:58,000
so the setup we're going to use to do

29
00:00:56,399 --> 00:01:01,039
this is that we have a week

30
00:00:58,000 --> 00:01:02,000
um so probabilistic polynomial time

31
00:01:01,039 --> 00:01:06,240
verifier

32
00:01:02,000 --> 00:01:07,920
and an unbounded but untrusted prover

33
00:01:06,240 --> 00:01:10,240
we're going to try and design a protocol

34
00:01:07,920 --> 00:01:12,240
that this weak verifier

35
00:01:10,240 --> 00:01:13,520
can use to interact with the untrusted

36
00:01:12,240 --> 00:01:15,679
prover and

37
00:01:13,520 --> 00:01:17,439
at the end of the interaction the

38
00:01:15,680 --> 00:01:20,720
verifier should know whether x

39
00:01:17,439 --> 00:01:22,559
is recolorable or not so formally we

40
00:01:20,720 --> 00:01:23,920
want two protocols uh two properties

41
00:01:22,560 --> 00:01:26,400
from this protocol

42
00:01:23,920 --> 00:01:28,000
soundness and zero knowledge so the

43
00:01:26,400 --> 00:01:28,960
first one is soundness which means that

44
00:01:28,000 --> 00:01:31,439
the prover

45
00:01:28,960 --> 00:01:32,720
um even though it's unbounded can't

46
00:01:31,439 --> 00:01:33,758
convince the verifier with high

47
00:01:32,720 --> 00:01:37,520
probability

48
00:01:33,759 --> 00:01:37,520
that x is three colorable if it's not

49
00:01:38,320 --> 00:01:42,240
well this is pretty easy to achieve um

50
00:01:40,560 --> 00:01:42,720
there's a trivial protocol that achieves

51
00:01:42,240 --> 00:01:44,640
it

52
00:01:42,720 --> 00:01:47,520
uh which is which is simply that the

53
00:01:44,640 --> 00:01:49,040
prover sends the coloring

54
00:01:47,520 --> 00:01:50,560
so in this case the verifier would

55
00:01:49,040 --> 00:01:53,200
receive the coloring

56
00:01:50,560 --> 00:01:54,000
and check that each edge joins two

57
00:01:53,200 --> 00:01:57,280
vertices of different

58
00:01:54,000 --> 00:01:59,119
colors but okay we're doing cryptography

59
00:01:57,280 --> 00:01:59,920
and so maybe we don't trust the verify

60
00:01:59,119 --> 00:02:02,000
either

61
00:01:59,920 --> 00:02:03,680
so maybe this three coloring encode some

62
00:02:02,000 --> 00:02:05,759
sort of state secret and we don't want

63
00:02:03,680 --> 00:02:08,160
the verifier to know the coloring and

64
00:02:05,759 --> 00:02:10,239
we only wanted to know whether x is

65
00:02:08,160 --> 00:02:11,920
recolorable or not

66
00:02:10,239 --> 00:02:13,520
so that brings us to the second property

67
00:02:11,920 --> 00:02:15,119
which is zero knowledge and zero

68
00:02:13,520 --> 00:02:16,800
knowledge just means that

69
00:02:15,120 --> 00:02:19,280
in the protocol in which the verifier

70
00:02:16,800 --> 00:02:21,840
makes use of this untrusted prover to

71
00:02:19,280 --> 00:02:24,640
decide whether x is recolorable or not

72
00:02:21,840 --> 00:02:26,560
the verifier should not learn anything

73
00:02:24,640 --> 00:02:29,279
except for the fact that x is

74
00:02:26,560 --> 00:02:29,280
recolorable

75
00:02:29,599 --> 00:02:33,040
so i'm going to quickly go through the

76
00:02:31,519 --> 00:02:35,680
sort of

77
00:02:33,040 --> 00:02:37,519
quintessential protocol for deciding mp

78
00:02:35,680 --> 00:02:38,720
problems in a zero knowledge of a which

79
00:02:37,519 --> 00:02:40,720
is the goldrich

80
00:02:38,720 --> 00:02:42,239
nikali wiktion protocol for three

81
00:02:40,720 --> 00:02:44,160
coloring

82
00:02:42,239 --> 00:02:46,720
so firstly we have to label all the

83
00:02:44,160 --> 00:02:49,599
vertices and all the edges of x

84
00:02:46,720 --> 00:02:50,080
which i've done here the vertices have

85
00:02:49,599 --> 00:02:53,679
numbers

86
00:02:50,080 --> 00:02:55,360
and the edges have letters so the first

87
00:02:53,680 --> 00:02:56,800
message in the protocol comes from the

88
00:02:55,360 --> 00:02:58,480
prover

89
00:02:56,800 --> 00:03:00,239
and the first thing that the preview

90
00:02:58,480 --> 00:03:02,079
does is permute the colors of the three

91
00:03:00,239 --> 00:03:05,200
coloring randomly

92
00:03:02,080 --> 00:03:07,680
so here we had you know red here

93
00:03:05,200 --> 00:03:09,200
white here and blue here here it's just

94
00:03:07,680 --> 00:03:11,040
a random permutation of those three

95
00:03:09,200 --> 00:03:13,119
colors

96
00:03:11,040 --> 00:03:14,799
then the proof is sends a commitment to

97
00:03:13,120 --> 00:03:17,200
that coloring

98
00:03:14,800 --> 00:03:19,120
uh we should think of a commitment as a

99
00:03:17,200 --> 00:03:20,720
safe

100
00:03:19,120 --> 00:03:22,480
so the prover can put anything it wants

101
00:03:20,720 --> 00:03:24,879
in the safe and then it locks the safe

102
00:03:22,480 --> 00:03:26,560
and it sends it to the verifier

103
00:03:24,879 --> 00:03:28,159
and the prover can't change its mind

104
00:03:26,560 --> 00:03:29,760
about what's in the safe after it has

105
00:03:28,159 --> 00:03:31,679
sent it to the verifier

106
00:03:29,760 --> 00:03:35,440
but the verifier also can't open the

107
00:03:31,680 --> 00:03:35,440
safe unless the prover gives it a key

108
00:03:35,599 --> 00:03:40,640
so what's in the save well i drew only

109
00:03:38,640 --> 00:03:42,319
one safe but you actually should imagine

110
00:03:40,640 --> 00:03:43,679
that there's one say for every vertex of

111
00:03:42,319 --> 00:03:45,119
the graph x

112
00:03:43,680 --> 00:03:47,840
so in this case there should be five

113
00:03:45,120 --> 00:03:49,760
saves

114
00:03:47,840 --> 00:03:51,760
so for each vertex the proofer writes

115
00:03:49,760 --> 00:03:54,159
down the color of that vertex so

116
00:03:51,760 --> 00:03:55,518
for example in the first safe the proof

117
00:03:54,159 --> 00:03:57,519
will put red

118
00:03:55,519 --> 00:03:58,720
because the first vertex is red the

119
00:03:57,519 --> 00:04:01,360
second safe the proof

120
00:03:58,720 --> 00:04:02,799
will put blue and so on so the previous

121
00:04:01,360 --> 00:04:04,799
sends this collection of safes to the

122
00:04:02,799 --> 00:04:07,040
verifier

123
00:04:04,799 --> 00:04:10,159
and that's the first step in the gmw

124
00:04:07,040 --> 00:04:10,159
protocol for three coloring

125
00:04:11,439 --> 00:04:16,159
okay and the second step is that the

126
00:04:13,599 --> 00:04:18,399
verifier sends a label of an edge

127
00:04:16,160 --> 00:04:19,919
which constitutes a challenge to the

128
00:04:18,399 --> 00:04:23,758
prover so this is edge f

129
00:04:19,918 --> 00:04:26,479
over here then the printer sends back

130
00:04:23,759 --> 00:04:28,000
the keys to the safes for the vertices

131
00:04:26,479 --> 00:04:29,840
that are connected to that edge so

132
00:04:28,000 --> 00:04:31,840
in this case the third and the fourth

133
00:04:29,840 --> 00:04:34,479
safes because vertices three and four

134
00:04:31,840 --> 00:04:36,239
are connected to edge f

135
00:04:34,479 --> 00:04:37,680
the verifier can then open those safes

136
00:04:36,240 --> 00:04:42,000
and check that the two colours that the

137
00:04:37,680 --> 00:04:43,520
proof have put inside are different

138
00:04:42,000 --> 00:04:45,840
so intuitively we can see that this

139
00:04:43,520 --> 00:04:48,560
protocol satisfies soundness

140
00:04:45,840 --> 00:04:49,520
because if x is not three colorable then

141
00:04:48,560 --> 00:04:51,600
one of the edges

142
00:04:49,520 --> 00:04:53,919
at least will join two vertices of the

143
00:04:51,600 --> 00:04:55,440
same color

144
00:04:53,919 --> 00:04:57,198
so then the verify will look at that

145
00:04:55,440 --> 00:04:59,040
edge with some probability so if we

146
00:04:57,199 --> 00:05:01,280
repeat the protocol many times and

147
00:04:59,040 --> 00:05:04,320
x is not three colorable then the

148
00:05:01,280 --> 00:05:06,559
approval will eventually get caught out

149
00:05:04,320 --> 00:05:07,919
but the the protocol also satisfies

150
00:05:06,560 --> 00:05:10,639
their knowledge

151
00:05:07,919 --> 00:05:12,159
chiefly because of the random

152
00:05:10,639 --> 00:05:14,639
permutations of colors that the

153
00:05:12,160 --> 00:05:16,479
privilege chooses so you might imagine

154
00:05:14,639 --> 00:05:17,520
that the verifier could try to deviate

155
00:05:16,479 --> 00:05:19,680
from the protocol by

156
00:05:17,520 --> 00:05:21,198
running it many times and each time

157
00:05:19,680 --> 00:05:23,759
trying to learn the colors

158
00:05:21,199 --> 00:05:26,560
attached to a different edge in hopes of

159
00:05:23,759 --> 00:05:28,160
reconstructing the entire coloring

160
00:05:26,560 --> 00:05:30,240
however this won't work because every

161
00:05:28,160 --> 00:05:31,440
time the permutation of colors

162
00:05:30,240 --> 00:05:33,520
that the proofer chooses will be

163
00:05:31,440 --> 00:05:35,120
different so the verify will just see

164
00:05:33,520 --> 00:05:36,479
each time that the two colors attached

165
00:05:35,120 --> 00:05:38,800
to any given edge

166
00:05:36,479 --> 00:05:40,159
are different so hopefully this example

167
00:05:38,800 --> 00:05:43,440
gives some intuition for why this

168
00:05:40,160 --> 00:05:43,440
protocol is zero knowledge

169
00:05:45,039 --> 00:05:48,800
so now i want to talk a little bit about

170
00:05:46,960 --> 00:05:50,400
non-interactive zero-knowledge proof

171
00:05:48,800 --> 00:05:51,680
systems which are really the focus of

172
00:05:50,400 --> 00:05:53,840
the paper

173
00:05:51,680 --> 00:05:55,360
so in the previous protocol there was a

174
00:05:53,840 --> 00:05:56,880
kind of back and forth between the

175
00:05:55,360 --> 00:05:58,560
verifier and the prover

176
00:05:56,880 --> 00:05:59,919
the prover had to send a commitment and

177
00:05:58,560 --> 00:06:01,039
then the verifier had to send a

178
00:05:59,919 --> 00:06:02,159
challenge and then prove it had to

179
00:06:01,039 --> 00:06:04,318
respond

180
00:06:02,160 --> 00:06:06,880
so we might sometimes wish because for

181
00:06:04,319 --> 00:06:08,639
some reason communication is expensive

182
00:06:06,880 --> 00:06:10,560
um we might wish that the approver can

183
00:06:08,639 --> 00:06:13,840
just send a single message

184
00:06:10,560 --> 00:06:15,680
uh to the verifier now if we saw we saw

185
00:06:13,840 --> 00:06:16,719
that if we don't require zero knowledge

186
00:06:15,680 --> 00:06:19,360
then this is fine

187
00:06:16,720 --> 00:06:20,080
for mp problems since the prover can

188
00:06:19,360 --> 00:06:22,960
just send

189
00:06:20,080 --> 00:06:24,400
in this case the the coloring but that

190
00:06:22,960 --> 00:06:26,318
is not zero knowledge

191
00:06:24,400 --> 00:06:27,840
so the question is can we do that in a

192
00:06:26,319 --> 00:06:31,440
zero knowledge fashion

193
00:06:27,840 --> 00:06:33,440
and the answer is no it's impossible for

194
00:06:31,440 --> 00:06:35,360
languages outside of bpp

195
00:06:33,440 --> 00:06:37,120
so for three coloring since that's a

196
00:06:35,360 --> 00:06:38,800
problem that's complete for mp

197
00:06:37,120 --> 00:06:40,240
it's impossible to have a protocol to

198
00:06:38,800 --> 00:06:41,280
decide three coloring that would only

199
00:06:40,240 --> 00:06:44,400
use one message

200
00:06:41,280 --> 00:06:44,400
from prover to verify

201
00:06:45,120 --> 00:06:49,440
so this is why people consider extended

202
00:06:47,039 --> 00:06:49,759
models and one popular extend model is

203
00:06:49,440 --> 00:06:52,319
the

204
00:06:49,759 --> 00:06:53,440
crs model which stands for common

205
00:06:52,319 --> 00:06:55,039
reference string

206
00:06:53,440 --> 00:06:57,280
and it just means that in addition to

207
00:06:55,039 --> 00:06:59,840
the usual setup where the instance x is

208
00:06:57,280 --> 00:07:02,000
known to both program verifier and so on

209
00:06:59,840 --> 00:07:03,758
there's a trusted third party which

210
00:07:02,000 --> 00:07:06,639
samples this string

211
00:07:03,759 --> 00:07:08,479
from a specified distribution and makes

212
00:07:06,639 --> 00:07:10,319
it publicly available

213
00:07:08,479 --> 00:07:11,919
so this is not achievable in the

214
00:07:10,319 --> 00:07:13,440
standard model because we can't trust

215
00:07:11,919 --> 00:07:15,599
the verifier to generate string and we

216
00:07:13,440 --> 00:07:17,440
can't trust the approver to do it either

217
00:07:15,599 --> 00:07:18,800
but if we assume that this this string

218
00:07:17,440 --> 00:07:20,160
can be obtained somehow

219
00:07:18,800 --> 00:07:21,440
and maybe that's not such an

220
00:07:20,160 --> 00:07:22,160
unreasonable assumption in the real

221
00:07:21,440 --> 00:07:24,479
world

222
00:07:22,160 --> 00:07:26,240
then we can do it so we can indeed have

223
00:07:24,479 --> 00:07:28,080
protocol where with the crs

224
00:07:26,240 --> 00:07:30,880
the prover only sends a single message

225
00:07:28,080 --> 00:07:32,560
to the verifier

226
00:07:30,880 --> 00:07:34,560
so okay then there's a question of what

227
00:07:32,560 --> 00:07:36,240
happens in the quantum setting

228
00:07:34,560 --> 00:07:37,840
and the first thing we want to look at

229
00:07:36,240 --> 00:07:39,599
in the quantum setting is post quantum

230
00:07:37,840 --> 00:07:40,479
security which is where the verify is

231
00:07:39,599 --> 00:07:42,240
now

232
00:07:40,479 --> 00:07:43,680
allowed to be a potentially cheating

233
00:07:42,240 --> 00:07:46,080
quantum device

234
00:07:43,680 --> 00:07:48,160
so the prover was unbounded anyway but

235
00:07:46,080 --> 00:07:49,758
if the verifier is allowed to be quantum

236
00:07:48,160 --> 00:07:52,400
can we still make the protocol zero

237
00:07:49,759 --> 00:07:53,919
knowledge and the answer is yes

238
00:07:52,400 --> 00:07:56,080
and in particular it's known to be

239
00:07:53,919 --> 00:07:58,799
possible in the crs model

240
00:07:56,080 --> 00:08:02,159
under lwe so learning with errors which

241
00:07:58,800 --> 00:08:04,160
is proven in 2019

242
00:08:02,160 --> 00:08:05,520
but okay post quantum security might not

243
00:08:04,160 --> 00:08:06,000
be the only thing that we're interested

244
00:08:05,520 --> 00:08:07,198
in

245
00:08:06,000 --> 00:08:09,039
in a world where there are quantum

246
00:08:07,199 --> 00:08:10,479
computers maybe now that there are

247
00:08:09,039 --> 00:08:12,000
quantum computers we're not only

248
00:08:10,479 --> 00:08:14,479
interested in mp problems but

249
00:08:12,000 --> 00:08:15,840
also problems in qma which is the

250
00:08:14,479 --> 00:08:17,280
quantum analog of np

251
00:08:15,840 --> 00:08:19,520
in the sense that it's the class of

252
00:08:17,280 --> 00:08:20,400
problems that can be checked efficiently

253
00:08:19,520 --> 00:08:22,318
by a quantum

254
00:08:20,400 --> 00:08:24,080
computer with access to a quantum

255
00:08:22,319 --> 00:08:27,680
witness

256
00:08:24,080 --> 00:08:29,840
so in this case x

257
00:08:27,680 --> 00:08:32,399
uh which was a graph before because

258
00:08:29,840 --> 00:08:34,559
three coloring is complete for mp

259
00:08:32,399 --> 00:08:36,320
would be replaced with some instance of

260
00:08:34,559 --> 00:08:38,000
a qma complete problem

261
00:08:36,320 --> 00:08:40,000
such as the local hamiltonian problem

262
00:08:38,000 --> 00:08:41,839
which i'll talk more about later

263
00:08:40,000 --> 00:08:43,760
and in this in this case in this

264
00:08:41,839 --> 00:08:45,360
situation we might also want to allow

265
00:08:43,760 --> 00:08:48,399
the message that the proof sends

266
00:08:45,360 --> 00:08:49,920
to the verifier to be quantum

267
00:08:48,399 --> 00:08:51,279
but we want to achieve the same thing we

268
00:08:49,920 --> 00:08:52,000
did in the classical setting which is

269
00:08:51,279 --> 00:08:55,040
that the prover

270
00:08:52,000 --> 00:08:57,440
sends only a single message to the

271
00:08:55,040 --> 00:09:00,560
verifier

272
00:08:57,440 --> 00:09:01,920
so this problem is perhaps still

273
00:09:00,560 --> 00:09:03,439
unsolved do we in this paper don't

274
00:09:01,920 --> 00:09:05,599
achieve something quite that's a deal

275
00:09:03,440 --> 00:09:06,640
but we achieve something that's almost

276
00:09:05,600 --> 00:09:08,480
what we want

277
00:09:06,640 --> 00:09:10,399
so instead of exactly one message we

278
00:09:08,480 --> 00:09:12,800
have two messages

279
00:09:10,399 --> 00:09:14,560
one from verified approver which

280
00:09:12,800 --> 00:09:15,359
contains a quantum part and classical

281
00:09:14,560 --> 00:09:17,279
part

282
00:09:15,360 --> 00:09:19,440
and one from private to verify which is

283
00:09:17,279 --> 00:09:20,880
actually entirely classical

284
00:09:19,440 --> 00:09:21,920
so the thing that allows us still to

285
00:09:20,880 --> 00:09:23,600
claim that our protocol is

286
00:09:21,920 --> 00:09:24,160
non-interactive is that the first

287
00:09:23,600 --> 00:09:27,519
message

288
00:09:24,160 --> 00:09:29,519
is independent of x so in a sense it can

289
00:09:27,519 --> 00:09:31,120
be thought of like the crs

290
00:09:29,519 --> 00:09:33,760
in that it's part of an instance

291
00:09:31,120 --> 00:09:36,480
independent pre-processing phase

292
00:09:33,760 --> 00:09:38,160
which can if need be completed ages in

293
00:09:36,480 --> 00:09:38,480
advance of the actual protocol before

294
00:09:38,160 --> 00:09:40,959
the

295
00:09:38,480 --> 00:09:42,640
the instance is even decided so we just

296
00:09:40,959 --> 00:09:44,160
need the verifier to send this message

297
00:09:42,640 --> 00:09:45,839
at some point to the approver

298
00:09:44,160 --> 00:09:48,000
so that it can trust that it was sent

299
00:09:45,839 --> 00:09:50,640
properly and also for the

300
00:09:48,000 --> 00:09:52,080
the crs to be generated at some point

301
00:09:50,640 --> 00:09:52,800
then after the pre-processing is

302
00:09:52,080 --> 00:09:54,880
complete

303
00:09:52,800 --> 00:09:58,719
the prover only needs to send a single

304
00:09:54,880 --> 00:09:58,720
classical message to the verifier

305
00:09:59,279 --> 00:10:04,320
okay so i want to go over how we achieve

306
00:10:01,440 --> 00:10:04,880
this and to do that i need to explain a

307
00:10:04,320 --> 00:10:07,360
bit

308
00:10:04,880 --> 00:10:09,360
um an interactive zero knowledge proof

309
00:10:07,360 --> 00:10:13,519
system for qma

310
00:10:09,360 --> 00:10:16,000
which inspires our protocol so

311
00:10:13,519 --> 00:10:16,800
let me talk a little bit more about the

312
00:10:16,000 --> 00:10:19,760
instance

313
00:10:16,800 --> 00:10:21,599
here so you know in the np case we had a

314
00:10:19,760 --> 00:10:26,160
graph

315
00:10:21,600 --> 00:10:27,920
because the coloring was complete for mp

316
00:10:26,160 --> 00:10:29,360
so in this case we have a local

317
00:10:27,920 --> 00:10:32,240
hamiltonian

318
00:10:29,360 --> 00:10:33,440
so a measurement operator that's the sum

319
00:10:32,240 --> 00:10:35,279
of clifford terms

320
00:10:33,440 --> 00:10:36,800
the these terms here which i've called

321
00:10:35,279 --> 00:10:38,320
ci

322
00:10:36,800 --> 00:10:40,000
and the problem is to decide whether the

323
00:10:38,320 --> 00:10:41,839
hamiltonian h

324
00:10:40,000 --> 00:10:43,680
has a smallest eigenvalue that is

325
00:10:41,839 --> 00:10:46,079
smaller than some number a

326
00:10:43,680 --> 00:10:47,359
or greater than some number b so your

327
00:10:46,079 --> 00:10:48,880
promise that it's one of these two it

328
00:10:47,360 --> 00:10:51,360
can't be in between

329
00:10:48,880 --> 00:10:53,279
and this problem um was shown to be

330
00:10:51,360 --> 00:10:56,160
complete for qma by broadbent

331
00:10:53,279 --> 00:10:57,760
z song and wetruce these guys in the

332
00:10:56,160 --> 00:11:00,800
same paper in which they propose

333
00:10:57,760 --> 00:11:01,680
this protocol so you know i've drawn a

334
00:11:00,800 --> 00:11:03,199
scale here

335
00:11:01,680 --> 00:11:04,319
um that's because the hamiltonian

336
00:11:03,200 --> 00:11:05,839
represents a measurement it's a

337
00:11:04,320 --> 00:11:07,760
measurement operator

338
00:11:05,839 --> 00:11:09,279
so you know that we can make an analogy

339
00:11:07,760 --> 00:11:11,200
where the question is

340
00:11:09,279 --> 00:11:13,200
um is there an object that i can place

341
00:11:11,200 --> 00:11:14,800
on the scale which will make it make it

342
00:11:13,200 --> 00:11:16,959
read

343
00:11:14,800 --> 00:11:18,719
a small value now obviously this is a

344
00:11:16,959 --> 00:11:20,319
trivial question with a normal scale but

345
00:11:18,720 --> 00:11:20,880
we can imagine that maybe the scale is

346
00:11:20,320 --> 00:11:22,640
weird

347
00:11:20,880 --> 00:11:24,640
it doesn't respond in the way we think

348
00:11:22,640 --> 00:11:28,640
it should and so the question is can we

349
00:11:24,640 --> 00:11:32,319
make it read a low value now because the

350
00:11:28,640 --> 00:11:34,480
hamiltonian h is a sum of terms um

351
00:11:32,320 --> 00:11:36,320
a particular state so a particular

352
00:11:34,480 --> 00:11:40,079
object placed on the scale

353
00:11:36,320 --> 00:11:42,240
in the analogy um has a small eigenvalue

354
00:11:40,079 --> 00:11:44,800
with respect to the hamiltonian h

355
00:11:42,240 --> 00:11:46,560
if and only if it has a small eigenvalue

356
00:11:44,800 --> 00:11:48,000
with respect to each of the ci's that

357
00:11:46,560 --> 00:11:50,000
make up the sum

358
00:11:48,000 --> 00:11:52,240
and each of these ci's is a clifford and

359
00:11:50,000 --> 00:11:54,000
is also a measurement operator

360
00:11:52,240 --> 00:11:55,680
so this gives us a convenient way to

361
00:11:54,000 --> 00:11:56,079
make an analogy with the classical

362
00:11:55,680 --> 00:11:58,800
setting

363
00:11:56,079 --> 00:12:00,399
so in three coloring the verifier in the

364
00:11:58,800 --> 00:12:02,639
second step of the protocol

365
00:12:00,399 --> 00:12:04,720
um chose a random edge from the graph

366
00:12:02,639 --> 00:12:06,560
that was the problem instance

367
00:12:04,720 --> 00:12:08,320
and that represented its challenge to

368
00:12:06,560 --> 00:12:10,000
the approver so here

369
00:12:08,320 --> 00:12:12,160
the verifier can choose a random term

370
00:12:10,000 --> 00:12:13,760
from this hamiltonian h

371
00:12:12,160 --> 00:12:15,519
and measure that and that's kind of

372
00:12:13,760 --> 00:12:18,959
analogous to the verifier in the

373
00:12:15,519 --> 00:12:22,320
previous setting choosing a random

374
00:12:18,959 --> 00:12:23,439
a random edge so you know now there's a

375
00:12:22,320 --> 00:12:24,880
question why don't we just measure the

376
00:12:23,440 --> 00:12:26,560
whole hamiltonian and

377
00:12:24,880 --> 00:12:28,000
you know that will become answered

378
00:12:26,560 --> 00:12:30,160
shortly

379
00:12:28,000 --> 00:12:31,120
so okay let me describe the first step

380
00:12:30,160 --> 00:12:34,319
of the

381
00:12:31,120 --> 00:12:37,360
bjsw protocol for qma

382
00:12:34,320 --> 00:12:40,160
so the first thing the prover does is to

383
00:12:37,360 --> 00:12:41,519
choose an encryption key k now this

384
00:12:40,160 --> 00:12:43,519
encryption scheme

385
00:12:41,519 --> 00:12:44,800
acts on quantum states we want to

386
00:12:43,519 --> 00:12:46,800
imagine it

387
00:12:44,800 --> 00:12:49,040
takes quantum states as input encrypts

388
00:12:46,800 --> 00:12:52,479
them and then outputs quantum states

389
00:12:49,040 --> 00:12:56,240
um and so it sends it puts

390
00:12:52,480 --> 00:12:59,360
k in the safe and sends commitment to k

391
00:12:56,240 --> 00:13:00,959
to the verifier sort of like how the

392
00:12:59,360 --> 00:13:02,560
prover committed in the beginning of the

393
00:13:00,959 --> 00:13:06,239
gmw protocol

394
00:13:02,560 --> 00:13:09,119
and it also sends so recall that

395
00:13:06,240 --> 00:13:09,920
the prover has um it's supposed to know

396
00:13:09,120 --> 00:13:12,480
this witness

397
00:13:09,920 --> 00:13:13,120
um and in in this case the witness is a

398
00:13:12,480 --> 00:13:15,440
state

399
00:13:13,120 --> 00:13:16,880
because qma is the class of problems

400
00:13:15,440 --> 00:13:19,440
that can be checked by a quantum

401
00:13:16,880 --> 00:13:21,360
computer an efficient quantum computer

402
00:13:19,440 --> 00:13:23,920
using a quantum witness so in this case

403
00:13:21,360 --> 00:13:26,720
the quantum witness is a quantum state

404
00:13:23,920 --> 00:13:27,199
and this quantum state allows v to check

405
00:13:26,720 --> 00:13:29,920
if it had

406
00:13:27,200 --> 00:13:31,440
access to that state that x is indeed a

407
00:13:29,920 --> 00:13:33,760
yes instance

408
00:13:31,440 --> 00:13:35,040
and remember that x being a yes instance

409
00:13:33,760 --> 00:13:37,279
in this case

410
00:13:35,040 --> 00:13:39,439
uh means that there exists you know some

411
00:13:37,279 --> 00:13:41,760
object we can place on the scale

412
00:13:39,440 --> 00:13:43,519
such that the scale reads a low value so

413
00:13:41,760 --> 00:13:45,120
you know this state is just

414
00:13:43,519 --> 00:13:47,199
some state we can measure with respect

415
00:13:45,120 --> 00:13:48,480
to this habitonian which will have a low

416
00:13:47,199 --> 00:13:50,399
eigenvalue with respect to that

417
00:13:48,480 --> 00:13:52,399
hamiltonian

418
00:13:50,399 --> 00:13:54,480
so the proofer is going to send an

419
00:13:52,399 --> 00:13:55,600
encryption under this key k that it just

420
00:13:54,480 --> 00:13:58,480
committed to

421
00:13:55,600 --> 00:14:00,000
of um this witness state and send that

422
00:13:58,480 --> 00:14:02,000
to the verifier

423
00:14:00,000 --> 00:14:03,040
and you know intuitively why do we want

424
00:14:02,000 --> 00:14:05,519
to encrypt

425
00:14:03,040 --> 00:14:06,240
the state well it's so that v when it

426
00:14:05,519 --> 00:14:07,920
receives

427
00:14:06,240 --> 00:14:09,760
you know this message this quantum

428
00:14:07,920 --> 00:14:11,040
message it can't learn anything about

429
00:14:09,760 --> 00:14:12,480
the state by looking at the encryption

430
00:14:11,040 --> 00:14:15,680
of the state

431
00:14:12,480 --> 00:14:16,000
and but this encryption has um one more

432
00:14:15,680 --> 00:14:17,760
special

433
00:14:16,000 --> 00:14:19,760
property which is that it allows

434
00:14:17,760 --> 00:14:20,480
homomorphic applications of clifford

435
00:14:19,760 --> 00:14:22,639
gates

436
00:14:20,480 --> 00:14:23,760
and so homomorphic measurements of

437
00:14:22,639 --> 00:14:26,000
clifford operators

438
00:14:23,760 --> 00:14:27,680
through the encryption and that why this

439
00:14:26,000 --> 00:14:28,320
is important will become clear in the

440
00:14:27,680 --> 00:14:31,199
second

441
00:14:28,320 --> 00:14:31,839
in the next slide okay so this is the

442
00:14:31,199 --> 00:14:34,959
first step

443
00:14:31,839 --> 00:14:37,519
of the interactive bjsw protocol

444
00:14:34,959 --> 00:14:39,760
for deciding problems in qma in a zero

445
00:14:37,519 --> 00:14:42,720
knowledge fashion

446
00:14:39,760 --> 00:14:44,240
so the second step is that the verifier

447
00:14:42,720 --> 00:14:45,279
is going to choose a challenge rather

448
00:14:44,240 --> 00:14:48,800
like in the second step

449
00:14:45,279 --> 00:14:50,240
of the gmw protocol so the verifier

450
00:14:48,800 --> 00:14:53,839
chooses an index j

451
00:14:50,240 --> 00:14:56,959
uniformly at random and it takes the

452
00:14:53,839 --> 00:14:58,480
term in the sum here that corresponds to

453
00:14:56,959 --> 00:15:00,560
that j

454
00:14:58,480 --> 00:15:02,320
so basically it chooses a random term of

455
00:15:00,560 --> 00:15:04,880
the hamiltonian h

456
00:15:02,320 --> 00:15:05,600
and as we said before it will measure

457
00:15:04,880 --> 00:15:08,959
that term

458
00:15:05,600 --> 00:15:11,199
of the hamiltonian and now um but i will

459
00:15:08,959 --> 00:15:14,239
measure the that term of the hamiltonian

460
00:15:11,199 --> 00:15:15,920
on um the encrypted witness state that i

461
00:15:14,240 --> 00:15:19,279
just received from the approver

462
00:15:15,920 --> 00:15:20,639
and not um the

463
00:15:19,279 --> 00:15:22,399
the actual witness state because we

464
00:15:20,639 --> 00:15:23,839
don't want it to have access to that so

465
00:15:22,399 --> 00:15:25,839
now it becomes clear why you know we

466
00:15:23,839 --> 00:15:27,680
need this encryption scheme to have

467
00:15:25,839 --> 00:15:29,360
the homomorphic property with respect to

468
00:15:27,680 --> 00:15:31,519
clifford gates and that's because

469
00:15:29,360 --> 00:15:33,440
we need it to we need the verifier to be

470
00:15:31,519 --> 00:15:33,759
able to homomorphically measure this

471
00:15:33,440 --> 00:15:36,160
thing

472
00:15:33,759 --> 00:15:37,839
through through the encryption and okay

473
00:15:36,160 --> 00:15:38,719
it does that and what happens when it

474
00:15:37,839 --> 00:15:41,279
does that

475
00:15:38,720 --> 00:15:42,800
it gets an encryption you know it gets

476
00:15:41,279 --> 00:15:45,360
classical outcome and the classical

477
00:15:42,800 --> 00:15:47,519
outcome exactly represents ad encryption

478
00:15:45,360 --> 00:15:48,800
under the key k of the outcome it would

479
00:15:47,519 --> 00:15:52,160
have gotten if it had

480
00:15:48,800 --> 00:15:55,839
measured w directly um under

481
00:15:52,160 --> 00:15:56,800
cj okay and i will just make one remark

482
00:15:55,839 --> 00:15:59,440
here which is that

483
00:15:56,800 --> 00:16:01,359
um this term cj does not depend on k

484
00:15:59,440 --> 00:16:02,880
well this should be obvious because

485
00:16:01,360 --> 00:16:04,880
um you know the verify does not have

486
00:16:02,880 --> 00:16:05,759
access to k but it will become important

487
00:16:04,880 --> 00:16:07,920
later that

488
00:16:05,759 --> 00:16:09,680
we don't need the to know the key in

489
00:16:07,920 --> 00:16:13,120
order to perform this

490
00:16:09,680 --> 00:16:13,120
this homomorphic measurement

491
00:16:14,320 --> 00:16:18,639
okay and so now you know in the in the

492
00:16:18,000 --> 00:16:21,440
original

493
00:16:18,639 --> 00:16:22,079
gmw protocol for np what happens next is

494
00:16:21,440 --> 00:16:24,880
that the

495
00:16:22,079 --> 00:16:26,479
the proofer reveals um it opens its

496
00:16:24,880 --> 00:16:28,320
commitment it opens the safe

497
00:16:26,480 --> 00:16:30,160
sends the verifier the key to the safe

498
00:16:28,320 --> 00:16:31,920
so that the verifier can check

499
00:16:30,160 --> 00:16:33,439
um essentially that the preview was not

500
00:16:31,920 --> 00:16:35,199
cheating um

501
00:16:33,440 --> 00:16:37,040
now here maybe you'd imagine that an

502
00:16:35,199 --> 00:16:39,758
analogy would be that the approver would

503
00:16:37,040 --> 00:16:41,519
open the safe the commitment to the key

504
00:16:39,759 --> 00:16:44,880
that it sent at the beginning

505
00:16:41,519 --> 00:16:47,279
and allow the verifier to use the key k

506
00:16:44,880 --> 00:16:48,240
to check to decrypt this encryption and

507
00:16:47,279 --> 00:16:50,800
check that zed

508
00:16:48,240 --> 00:16:53,120
in fact corresponds to you know a low

509
00:16:50,800 --> 00:16:55,920
reading of the scale

510
00:16:53,120 --> 00:16:56,480
but um this might not be a zero

511
00:16:55,920 --> 00:16:57,920
knowledge

512
00:16:56,480 --> 00:16:59,680
or at least it's hard to argue that it

513
00:16:57,920 --> 00:17:01,439
is zero knowledge but there is something

514
00:16:59,680 --> 00:17:04,879
else the perfect can do

515
00:17:01,440 --> 00:17:07,760
and that is that it can use an np

516
00:17:04,880 --> 00:17:09,199
um zero knowledge proof system to prove

517
00:17:07,760 --> 00:17:11,599
the following statement

518
00:17:09,199 --> 00:17:13,600
there exists a key um consistent with

519
00:17:11,599 --> 00:17:16,159
the commitment that was sent in step one

520
00:17:13,599 --> 00:17:17,760
so you know the the commitment to key

521
00:17:16,160 --> 00:17:20,319
here

522
00:17:17,760 --> 00:17:21,599
such that the outcome that the verifier

523
00:17:20,319 --> 00:17:24,399
got in this step

524
00:17:21,599 --> 00:17:25,678
um is an encryption under k of an

525
00:17:24,400 --> 00:17:27,360
accepting outcome

526
00:17:25,679 --> 00:17:30,400
so this is essentially saying you know

527
00:17:27,359 --> 00:17:33,520
um verifier if you had the key

528
00:17:30,400 --> 00:17:35,679
k you would accept at the stage

529
00:17:33,520 --> 00:17:37,039
and why why is this an empty statement

530
00:17:35,679 --> 00:17:38,559
well it's an empty statement because

531
00:17:37,039 --> 00:17:40,000
it can be efficiently checked with a

532
00:17:38,559 --> 00:17:42,000
witness and the witness is simply the

533
00:17:40,000 --> 00:17:43,919
key k so if the verifier had the key

534
00:17:42,000 --> 00:17:45,200
it could check now we don't want to give

535
00:17:43,919 --> 00:17:46,799
the verifier the key k

536
00:17:45,200 --> 00:17:48,559
so we're just going to prove to it in a

537
00:17:46,799 --> 00:17:49,280
zero knowledge fashion using as our

538
00:17:48,559 --> 00:17:53,120
knowledge

539
00:17:49,280 --> 00:17:55,039
proof for mp statements that um in fact

540
00:17:53,120 --> 00:17:57,439
basically the prover's behavior has been

541
00:17:55,039 --> 00:17:57,440
honest

542
00:17:58,080 --> 00:18:02,720
so okay we want to make the bjsw

543
00:18:00,400 --> 00:18:04,160
protocol non-interactive

544
00:18:02,720 --> 00:18:05,760
the first thing we can do the obvious

545
00:18:04,160 --> 00:18:07,679
thing is to replace

546
00:18:05,760 --> 00:18:09,039
the zero knowledge proof that the prover

547
00:18:07,679 --> 00:18:12,000
sends

548
00:18:09,039 --> 00:18:13,360
um at the end of the bgsw protocol with

549
00:18:12,000 --> 00:18:16,720
a non-interactive

550
00:18:13,360 --> 00:18:18,639
zero knowledge proof but the real

551
00:18:16,720 --> 00:18:21,039
obstacle to compressing the three steps

552
00:18:18,640 --> 00:18:23,039
of the btsw protocol into one

553
00:18:21,039 --> 00:18:24,480
is that the proof is proof in step three

554
00:18:23,039 --> 00:18:26,799
this one

555
00:18:24,480 --> 00:18:28,000
uh depends on the verifies challenge and

556
00:18:26,799 --> 00:18:31,679
measurement outcome from step

557
00:18:28,000 --> 00:18:34,559
two uh depends on these

558
00:18:31,679 --> 00:18:35,360
which in turn depend on the instant

559
00:18:34,559 --> 00:18:37,120
dependent

560
00:18:35,360 --> 00:18:39,039
witness state that the previous approver

561
00:18:37,120 --> 00:18:40,879
holds

562
00:18:39,039 --> 00:18:43,440
so we can't have the prover do step two

563
00:18:40,880 --> 00:18:45,520
that would clearly violate soundness

564
00:18:43,440 --> 00:18:49,200
but we also don't have enough messages

565
00:18:45,520 --> 00:18:49,200
for the verifier to do step 2.

566
00:18:52,480 --> 00:18:57,120
so our first main idea is to get around

567
00:18:54,640 --> 00:18:59,120
this using quantum teleportation

568
00:18:57,120 --> 00:19:02,719
so notice that instead of directly

569
00:18:59,120 --> 00:19:11,439
sending the verify the encrypted witness

570
00:19:02,720 --> 00:19:13,120
in step one this step here

571
00:19:11,440 --> 00:19:14,559
the prover could equally have used

572
00:19:13,120 --> 00:19:17,039
quantum teleportation

573
00:19:14,559 --> 00:19:19,440
to teleport the witness to the verifier

574
00:19:17,039 --> 00:19:22,240
provided that they share epr pairs

575
00:19:19,440 --> 00:19:24,160
so this would generate a string d

576
00:19:22,240 --> 00:19:26,880
representing the one-time pad that gets

577
00:19:24,160 --> 00:19:29,280
applied to the teleported witness date

578
00:19:26,880 --> 00:19:30,720
after the teleportation and the proofer

579
00:19:29,280 --> 00:19:32,720
would need to send this to the verifier

580
00:19:30,720 --> 00:19:34,640
as well so the verify could undo

581
00:19:32,720 --> 00:19:36,559
the one-time pad and carrying out the

582
00:19:34,640 --> 00:19:38,720
rest of the protocol

583
00:19:36,559 --> 00:19:39,760
so so far we've just complicated the

584
00:19:38,720 --> 00:19:42,559
protocol without

585
00:19:39,760 --> 00:19:44,000
buying ourselves anything but now notice

586
00:19:42,559 --> 00:19:45,120
that the proof is teleportation

587
00:19:44,000 --> 00:19:47,840
measurement

588
00:19:45,120 --> 00:19:48,639
um that teleports the witness state to

589
00:19:47,840 --> 00:19:52,240
the verifier

590
00:19:48,640 --> 00:19:53,120
over here and the uh the verifies

591
00:19:52,240 --> 00:19:56,720
measurement

592
00:19:53,120 --> 00:19:59,600
of cj on the teleported witness date

593
00:19:56,720 --> 00:20:00,240
commute uh if we ignore for now the

594
00:19:59,600 --> 00:20:03,360
issue

595
00:20:00,240 --> 00:20:04,840
of the one-time pad string d um

596
00:20:03,360 --> 00:20:07,120
that the proofer has to send to the

597
00:20:04,840 --> 00:20:10,320
verify and this is because

598
00:20:07,120 --> 00:20:13,039
you know this and this

599
00:20:10,320 --> 00:20:15,360
are both just measurements on different

600
00:20:13,039 --> 00:20:17,280
halves of their shared epr pairs

601
00:20:15,360 --> 00:20:20,240
so we could switch the order of these

602
00:20:17,280 --> 00:20:22,399
actions without affecting the protocol

603
00:20:20,240 --> 00:20:24,320
okay so here's the modified protocol

604
00:20:22,400 --> 00:20:26,480
firstly we assume that the verifier

605
00:20:24,320 --> 00:20:27,600
prepares epr pairs for the teleportation

606
00:20:26,480 --> 00:20:30,720
and sends

607
00:20:27,600 --> 00:20:33,039
the prover it's halves it turns out this

608
00:20:30,720 --> 00:20:34,720
is okay for zero knowledge

609
00:20:33,039 --> 00:20:37,200
and the verifier then chooses this

610
00:20:34,720 --> 00:20:40,159
challenge as before

611
00:20:37,200 --> 00:20:42,640
and measures that clifford operator on

612
00:20:40,159 --> 00:20:44,400
its halves of the epr pairs

613
00:20:42,640 --> 00:20:48,880
as if they already contained the

614
00:20:44,400 --> 00:20:51,520
teleported witness date

615
00:20:48,880 --> 00:20:52,480
now note that cj doesn't depend on k so

616
00:20:51,520 --> 00:20:54,400
it's fine the

617
00:20:52,480 --> 00:20:56,480
the encryption key k so it's fine that k

618
00:20:54,400 --> 00:20:58,000
hasn't even been chosen yet

619
00:20:56,480 --> 00:21:00,000
the verifier gets you know some

620
00:20:58,000 --> 00:21:03,200
measurement outcome m

621
00:21:00,000 --> 00:21:05,440
which it sends the prover

622
00:21:03,200 --> 00:21:07,840
and then the prover creates the

623
00:21:05,440 --> 00:21:11,039
encrypted witness state

624
00:21:07,840 --> 00:21:12,959
and teleports this to the verifier

625
00:21:11,039 --> 00:21:15,200
now this results as we said is in a one

626
00:21:12,960 --> 00:21:16,559
time pad string d

627
00:21:15,200 --> 00:21:18,320
and if you think for a second you'll see

628
00:21:16,559 --> 00:21:21,440
that d xor

629
00:21:18,320 --> 00:21:21,840
with m will end up being the encryption

630
00:21:21,440 --> 00:21:25,760
of

631
00:21:21,840 --> 00:21:29,360
zed of decryption of z under k

632
00:21:25,760 --> 00:21:30,879
where inc is is just the thing

633
00:21:29,360 --> 00:21:33,520
that the verifier would have gotten in

634
00:21:30,880 --> 00:21:36,880
the bgsw protocol

635
00:21:33,520 --> 00:21:39,520
so for the final step the prover sends

636
00:21:36,880 --> 00:21:41,440
the commitment to k

637
00:21:39,520 --> 00:21:43,760
that in the bgsw protocol it would have

638
00:21:41,440 --> 00:21:46,640
sent in the first step

639
00:21:43,760 --> 00:21:49,200
it sends d the one time pad string and

640
00:21:46,640 --> 00:21:51,520
it also sends an nizk proof

641
00:21:49,200 --> 00:21:54,480
for an np statement now this mp

642
00:21:51,520 --> 00:21:56,320
statement is a little bit different

643
00:21:54,480 --> 00:21:58,080
now it will say something like verify if

644
00:21:56,320 --> 00:22:00,879
you had k

645
00:21:58,080 --> 00:22:03,039
then you would x you could x or d to the

646
00:22:00,880 --> 00:22:06,320
measurement outcome that you got

647
00:22:03,039 --> 00:22:09,600
in this step and now what is step one m

648
00:22:06,320 --> 00:22:10,720
you could xor d to m and then decrypt

649
00:22:09,600 --> 00:22:13,520
the encryption

650
00:22:10,720 --> 00:22:14,640
remember that d x or m is equal to n k

651
00:22:13,520 --> 00:22:16,158
of z

652
00:22:14,640 --> 00:22:19,200
uh you could decrypt the encryption to

653
00:22:16,159 --> 00:22:21,360
get an accepting outcome said

654
00:22:19,200 --> 00:22:22,880
so are we done now it turns out not

655
00:22:21,360 --> 00:22:24,399
quite um there are a few holes in this

656
00:22:22,880 --> 00:22:27,360
construction

657
00:22:24,400 --> 00:22:28,080
to verify i can't measure cj yet in this

658
00:22:27,360 --> 00:22:29,439
step because

659
00:22:28,080 --> 00:22:31,600
this step is meant to be instance

660
00:22:29,440 --> 00:22:32,880
independent and cj is part of the

661
00:22:31,600 --> 00:22:34,879
instance x

662
00:22:32,880 --> 00:22:36,799
so i won't go into details of how we get

663
00:22:34,880 --> 00:22:39,360
around that but it can be done

664
00:22:36,799 --> 00:22:41,120
secondly the verifier can't just send cj

665
00:22:39,360 --> 00:22:41,918
and m to the approver before the prover

666
00:22:41,120 --> 00:22:45,199
has sent

667
00:22:41,919 --> 00:22:46,559
its witness date otherwise the proof

668
00:22:45,200 --> 00:22:48,080
would know the verifier's challenge

669
00:22:46,559 --> 00:22:50,000
ahead of time which is like knowing the

670
00:22:48,080 --> 00:22:51,280
edge to be checked ahead of time in the

671
00:22:50,000 --> 00:22:54,240
gmw protocol

672
00:22:51,280 --> 00:22:56,639
which obviously violates soundness and

673
00:22:54,240 --> 00:22:59,039
thirdly the prover gets to report d

674
00:22:56,640 --> 00:23:00,720
so maybe if it was clever it could

675
00:22:59,039 --> 00:23:02,000
misreport it and make the measurement

676
00:23:00,720 --> 00:23:03,039
outcome the verifiers measurement

677
00:23:02,000 --> 00:23:04,559
outcome m

678
00:23:03,039 --> 00:23:06,640
look like an accepting one even if it

679
00:23:04,559 --> 00:23:11,120
wasn't because after all

680
00:23:06,640 --> 00:23:11,120
d controls d x or m

681
00:23:11,360 --> 00:23:15,520
so to address these problems we add one

682
00:23:13,919 --> 00:23:16,799
more ingredient we use homomorphic

683
00:23:15,520 --> 00:23:18,879
encryption

684
00:23:16,799 --> 00:23:21,200
so the idea here is pretty simple though

685
00:23:18,880 --> 00:23:23,760
it's a little delicate to implement

686
00:23:21,200 --> 00:23:26,320
so basically we have the verifier

687
00:23:23,760 --> 00:23:29,520
homomorphically encrypt

688
00:23:26,320 --> 00:23:31,360
cj and m so notice

689
00:23:29,520 --> 00:23:33,280
after we do this the prover can the

690
00:23:31,360 --> 00:23:34,959
prover no longer knows the verifiers

691
00:23:33,280 --> 00:23:36,559
challenge

692
00:23:34,960 --> 00:23:38,240
because it's encrypted so it can't get

693
00:23:36,559 --> 00:23:39,520
away with teleporting a state that's not

694
00:23:38,240 --> 00:23:41,760
a witness

695
00:23:39,520 --> 00:23:42,799
it also wouldn't know what d to report

696
00:23:41,760 --> 00:23:45,279
here

697
00:23:42,799 --> 00:23:46,240
to make to mislead the verify into

698
00:23:45,279 --> 00:23:48,240
thinking that

699
00:23:46,240 --> 00:23:50,080
m was accepting when it wasn't because m

700
00:23:48,240 --> 00:23:52,640
is now encrypted

701
00:23:50,080 --> 00:23:55,439
however if it behaves honestly it can

702
00:23:52,640 --> 00:23:58,559
still compute its nizk proof at the end

703
00:23:55,440 --> 00:24:02,480
by homomorphically encrypting

704
00:23:58,559 --> 00:24:05,279
k this k it's it's um

705
00:24:02,480 --> 00:24:06,880
its own encryption key under the

706
00:24:05,279 --> 00:24:09,840
verifier's public key for

707
00:24:06,880 --> 00:24:10,880
he the homophobic encryption scheme and

708
00:24:09,840 --> 00:24:13,360
computing this whole

709
00:24:10,880 --> 00:24:14,320
mp proof homomorphically and then the

710
00:24:13,360 --> 00:24:16,000
verifier can

711
00:24:14,320 --> 00:24:19,840
decrypt the proof and check that the mp

712
00:24:16,000 --> 00:24:19,840
proof is valid

713
00:24:20,000 --> 00:24:24,559
so i've basically just stepped through

714
00:24:21,520 --> 00:24:27,039
the soundness argument for our protocol

715
00:24:24,559 --> 00:24:27,840
note that our protocol is an argument

716
00:24:27,039 --> 00:24:29,200
not a proof

717
00:24:27,840 --> 00:24:30,799
meaning that it's only sound against

718
00:24:29,200 --> 00:24:31,760
computationally efficient provers and

719
00:24:30,799 --> 00:24:34,960
that's

720
00:24:31,760 --> 00:24:36,640
that's due to the homomorphic encryption

721
00:24:34,960 --> 00:24:38,559
so i'm basically out of time so i won't

722
00:24:36,640 --> 00:24:39,760
go through the zero knowledge proof

723
00:24:38,559 --> 00:24:41,918
but if you're interested you can check

724
00:24:39,760 --> 00:24:44,158
out the paper there are a few subtleties

725
00:24:41,919 --> 00:24:46,559
to be worked out there as well

726
00:24:44,159 --> 00:24:47,760
we also define in this paper jointly

727
00:24:46,559 --> 00:24:50,320
with ann broadbent and

728
00:24:47,760 --> 00:24:52,000
alex greelo who publish independently

729
00:24:50,320 --> 00:24:53,120
the notion of a proof of quantum

730
00:24:52,000 --> 00:24:55,200
knowledge

731
00:24:53,120 --> 00:24:56,239
in analogy with the classical idea of a

732
00:24:55,200 --> 00:24:57,760
proof of knowledge

733
00:24:56,240 --> 00:25:00,080
and we show that this protocol i've been

734
00:24:57,760 --> 00:25:02,559
describing is also an argument of

735
00:25:00,080 --> 00:25:04,158
quantum knowledge

736
00:25:02,559 --> 00:25:06,158
so once again feel free to check out the

737
00:25:04,159 --> 00:25:10,320
paper if you're interested and

738
00:25:06,159 --> 00:25:10,320
thanks for listening

