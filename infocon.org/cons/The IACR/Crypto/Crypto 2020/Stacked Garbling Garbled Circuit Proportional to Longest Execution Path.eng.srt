1
00:00:00,799 --> 00:00:04,560
hi my name is david heath

2
00:00:03,040 --> 00:00:06,319
in this talk i'll be talking about our

3
00:00:04,560 --> 00:00:08,080
paper stacked garbling

4
00:00:06,319 --> 00:00:09,519
garbled circuit proportional to longest

5
00:00:08,080 --> 00:00:11,200
execution path

6
00:00:09,519 --> 00:00:12,880
this is work done by myself and my

7
00:00:11,200 --> 00:00:15,040
advisor claude kolesnikov

8
00:00:12,880 --> 00:00:17,359
and the two of us work at georgia tech

9
00:00:15,040 --> 00:00:19,759
in atlanta georgia

10
00:00:17,359 --> 00:00:20,720
so as some background for this work i'll

11
00:00:19,760 --> 00:00:23,279
be discussing

12
00:00:20,720 --> 00:00:24,320
yale's garbled circuit which is an

13
00:00:23,279 --> 00:00:26,640
efficient protocol

14
00:00:24,320 --> 00:00:28,640
that allows two parties to securely

15
00:00:26,640 --> 00:00:31,199
compute an arbitrary function of their

16
00:00:28,640 --> 00:00:32,079
of their inputs what i mean by securely

17
00:00:31,199 --> 00:00:34,079
compute

18
00:00:32,079 --> 00:00:35,280
is that the two parties provide private

19
00:00:34,079 --> 00:00:37,280
inputs and

20
00:00:35,280 --> 00:00:38,879
or nothing except for the function

21
00:00:37,280 --> 00:00:42,079
output that is their private input

22
00:00:38,879 --> 00:00:43,440
is protected the reason that we like

23
00:00:42,079 --> 00:00:44,800
garbled circuits

24
00:00:43,440 --> 00:00:46,800
is because it is often the most

25
00:00:44,800 --> 00:00:48,480
efficient technique for secure two-party

26
00:00:46,800 --> 00:00:52,319
computation

27
00:00:48,480 --> 00:00:54,718
so in particular garbled circuit is a

28
00:00:52,320 --> 00:00:56,800
constant round protocol and this means

29
00:00:54,719 --> 00:01:00,879
that we don't have to suffer

30
00:00:56,800 --> 00:01:03,120
from high network latency of course

31
00:01:00,879 --> 00:01:04,559
it's always interesting to try to make

32
00:01:03,120 --> 00:01:06,560
uh protocols more efficient

33
00:01:04,559 --> 00:01:08,640
and that's what we achieve in this work

34
00:01:06,560 --> 00:01:11,040
so in yale's garbled circuit

35
00:01:08,640 --> 00:01:12,560
communication in terms of bandwidth is

36
00:01:11,040 --> 00:01:16,000
the bottleneck

37
00:01:12,560 --> 00:01:17,119
so specifically one player the so-called

38
00:01:16,000 --> 00:01:20,240
circuit generator

39
00:01:17,119 --> 00:01:21,920
has to produce a large encryption

40
00:01:20,240 --> 00:01:24,158
of the circuit that represents their

41
00:01:21,920 --> 00:01:26,479
function and then send this encryption

42
00:01:24,159 --> 00:01:28,000
over the network to the so-called

43
00:01:26,479 --> 00:01:29,920
circuit evaluator

44
00:01:28,000 --> 00:01:31,600
and is this simple sending of an

45
00:01:29,920 --> 00:01:33,040
encryption from one player to the other

46
00:01:31,600 --> 00:01:36,079
that is the bottleneck of the entire

47
00:01:33,040 --> 00:01:36,880
protocol so reducing the size of this

48
00:01:36,079 --> 00:01:38,839
encryption

49
00:01:36,880 --> 00:01:40,399
is a very interesting direction of

50
00:01:38,840 --> 00:01:42,880
research

51
00:01:40,400 --> 00:01:44,880
in this work we show that we can take

52
00:01:42,880 --> 00:01:47,280
advantage of conditional branching that

53
00:01:44,880 --> 00:01:49,280
occurs in the source program

54
00:01:47,280 --> 00:01:50,799
so for instance if your function has

55
00:01:49,280 --> 00:01:53,360
some sort of if statements

56
00:01:50,799 --> 00:01:54,159
or switch statements in it then we can

57
00:01:53,360 --> 00:01:56,880
take advantage

58
00:01:54,159 --> 00:01:58,399
of this exclusive conditional behavior

59
00:01:56,880 --> 00:02:00,399
that only one of these branches is

60
00:01:58,399 --> 00:02:02,000
actually evaluated

61
00:02:00,399 --> 00:02:04,960
in order to reduce the total amount of

62
00:02:02,000 --> 00:02:07,600
bandwidth that we consume

63
00:02:04,960 --> 00:02:09,840
traditionally it has been assumed that

64
00:02:07,600 --> 00:02:12,560
we need communication proportional to

65
00:02:09,840 --> 00:02:15,440
the entire circuit that is including all

66
00:02:12,560 --> 00:02:18,319
of the different conditional branches

67
00:02:15,440 --> 00:02:19,120
because we need to ensure security

68
00:02:18,319 --> 00:02:21,839
meaning that

69
00:02:19,120 --> 00:02:22,640
the players have to uh do something

70
00:02:21,840 --> 00:02:24,400
symmetric

71
00:02:22,640 --> 00:02:25,760
with respect to the different branches

72
00:02:24,400 --> 00:02:29,040
we'll see that

73
00:02:25,760 --> 00:02:32,160
in this talk and so the simplest way to

74
00:02:29,040 --> 00:02:33,679
achieve this is to have them simply

75
00:02:32,160 --> 00:02:35,519
run a garbled circuit for all of the

76
00:02:33,680 --> 00:02:36,720
branches and then resolve

77
00:02:35,519 --> 00:02:39,519
which bridge was actually taken

78
00:02:36,720 --> 00:02:40,560
afterwards in this work we showed that

79
00:02:39,519 --> 00:02:42,080
there are some

80
00:02:40,560 --> 00:02:44,080
cryptographic techniques that you can

81
00:02:42,080 --> 00:02:45,040
use to reduce the amount of

82
00:02:44,080 --> 00:02:47,280
communication

83
00:02:45,040 --> 00:02:49,200
such that it is proportional only to the

84
00:02:47,280 --> 00:02:50,959
single longest execution path

85
00:02:49,200 --> 00:02:52,720
that is if you have 100 different

86
00:02:50,959 --> 00:02:54,160
conditional branches you don't need to

87
00:02:52,720 --> 00:02:55,120
pay for all of them in terms of

88
00:02:54,160 --> 00:02:57,120
communication

89
00:02:55,120 --> 00:02:59,680
you only need to pay for the single

90
00:02:57,120 --> 00:03:01,760
longest branch

91
00:02:59,680 --> 00:03:03,200
i'd like to begin by reviewing some of

92
00:03:01,760 --> 00:03:05,120
the basics of garbled circuit

93
00:03:03,200 --> 00:03:07,200
such that later on we can extend these

94
00:03:05,120 --> 00:03:10,000
basics with the principles evolved with

95
00:03:07,200 --> 00:03:10,000
stacked garbling

96
00:03:10,159 --> 00:03:15,519
garbled circuit relies on giving the two

97
00:03:13,440 --> 00:03:18,000
players two separate roles

98
00:03:15,519 --> 00:03:18,800
so here we'll allow alice to be the

99
00:03:18,000 --> 00:03:21,599
so-called

100
00:03:18,800 --> 00:03:22,319
circuit generator circuit generator's

101
00:03:21,599 --> 00:03:25,440
job

102
00:03:22,319 --> 00:03:26,079
is to build an encryption of the entire

103
00:03:25,440 --> 00:03:28,319
circuit

104
00:03:26,080 --> 00:03:31,519
which he then sends across the wire to

105
00:03:28,319 --> 00:03:34,159
bob the so-called circuit evaluator

106
00:03:31,519 --> 00:03:36,879
the evaluator's job is to step through

107
00:03:34,159 --> 00:03:40,640
this encrypted circuit gate by gate

108
00:03:36,879 --> 00:03:43,679
propagating encryptions of input values

109
00:03:40,640 --> 00:03:46,079
to encryptions of output values

110
00:03:43,680 --> 00:03:47,599
such that the semantic values on the

111
00:03:46,080 --> 00:03:49,760
wires are propagated

112
00:03:47,599 --> 00:03:50,640
through the circuit but it's also such

113
00:03:49,760 --> 00:03:52,560
that he does not

114
00:03:50,640 --> 00:03:54,159
learn what any of these semantic values

115
00:03:52,560 --> 00:03:56,159
actually are

116
00:03:54,159 --> 00:03:58,000
he only gets to see encryptions of all

117
00:03:56,159 --> 00:03:59,599
the values

118
00:03:58,000 --> 00:04:01,680
once bob has walked all the way through

119
00:03:59,599 --> 00:04:04,640
the circuit from beginning to end and

120
00:04:01,680 --> 00:04:06,720
obtained encryptions of output values

121
00:04:04,640 --> 00:04:08,000
the two players work together to decrypt

122
00:04:06,720 --> 00:04:11,920
these output values

123
00:04:08,000 --> 00:04:11,920
and learn the output of the function

124
00:04:12,080 --> 00:04:17,920
so in more detail let's start by looking

125
00:04:14,480 --> 00:04:17,920
at what the circuit generator does

126
00:04:18,000 --> 00:04:22,560
first alice is going to select

127
00:04:20,959 --> 00:04:26,840
pseudo-random

128
00:04:22,560 --> 00:04:28,240
wire labels for each of the wires in the

129
00:04:26,840 --> 00:04:31,758
circuit

130
00:04:28,240 --> 00:04:33,199
so here i have these depicted as keys

131
00:04:31,759 --> 00:04:35,600
and this is significant because we will

132
00:04:33,199 --> 00:04:39,040
use these keys to encrypt

133
00:04:35,600 --> 00:04:41,199
logical truth tables as we will see

134
00:04:39,040 --> 00:04:42,479
each wire has two different keys a red

135
00:04:41,199 --> 00:04:45,520
key and a green key

136
00:04:42,479 --> 00:04:48,479
which correspond to a logical zero

137
00:04:45,520 --> 00:04:49,198
and logical one respectively the idea is

138
00:04:48,479 --> 00:04:51,680
that

139
00:04:49,199 --> 00:04:52,479
later when bob evaluates the circuit he

140
00:04:51,680 --> 00:04:55,120
will only have

141
00:04:52,479 --> 00:04:57,120
one key per wire and furthermore he will

142
00:04:55,120 --> 00:04:59,600
be unable to distinguish which color key

143
00:04:57,120 --> 00:04:59,600
he has

144
00:04:59,919 --> 00:05:03,359
alice uses these keys to encrypt the

145
00:05:02,800 --> 00:05:05,520
logic

146
00:05:03,360 --> 00:05:06,880
of each of the gates in the circuit so

147
00:05:05,520 --> 00:05:09,840
let's just look at one gate

148
00:05:06,880 --> 00:05:11,520
this and gate here so this and gate has

149
00:05:09,840 --> 00:05:15,280
a particular truth table

150
00:05:11,520 --> 00:05:18,159
corresponding to its semantics alex

151
00:05:15,280 --> 00:05:20,080
constructs a an encrypted version of

152
00:05:18,160 --> 00:05:22,840
this these semantics

153
00:05:20,080 --> 00:05:24,080
by looking at each row of the truth

154
00:05:22,840 --> 00:05:26,719
table

155
00:05:24,080 --> 00:05:29,359
and for each output of the truth table

156
00:05:26,720 --> 00:05:31,680
she will place a corresponding

157
00:05:29,360 --> 00:05:32,720
output key so you can see here that she

158
00:05:31,680 --> 00:05:34,000
has placed

159
00:05:32,720 --> 00:05:35,759
corresponding the outputs of this

160
00:05:34,000 --> 00:05:37,680
logical truth table

161
00:05:35,759 --> 00:05:39,600
a red key where a zero appears in a

162
00:05:37,680 --> 00:05:42,000
green key where one appears

163
00:05:39,600 --> 00:05:42,639
she then encrypts the outputs of these

164
00:05:42,000 --> 00:05:46,240
keys

165
00:05:42,639 --> 00:05:49,759
using the corresponding input keys

166
00:05:46,240 --> 00:05:52,560
now so far this is not yet secure

167
00:05:49,759 --> 00:05:53,919
later when bob gets input keys

168
00:05:52,560 --> 00:05:55,919
corresponding to this table he will

169
00:05:53,919 --> 00:05:58,000
decrypt a particular row

170
00:05:55,919 --> 00:05:59,440
but right now we have these these rows

171
00:05:58,000 --> 00:06:02,240
in a particular order

172
00:05:59,440 --> 00:06:03,199
such that if bob knew to decrypt say the

173
00:06:02,240 --> 00:06:05,039
second row

174
00:06:03,199 --> 00:06:07,759
he would know which input keys he has

175
00:06:05,039 --> 00:06:10,400
and also which output he has

176
00:06:07,759 --> 00:06:12,319
so we break this ordering from the

177
00:06:10,400 --> 00:06:13,198
semantic meaning by just randomly

178
00:06:12,319 --> 00:06:16,479
permitting

179
00:06:13,199 --> 00:06:17,520
the order of the rows and now we're done

180
00:06:16,479 --> 00:06:20,880
we've encrypted

181
00:06:17,520 --> 00:06:22,479
the logic of this particular gate

182
00:06:20,880 --> 00:06:23,919
alice continues doing this for every

183
00:06:22,479 --> 00:06:25,840
gate in the circuit

184
00:06:23,919 --> 00:06:27,680
and generates all of these these

185
00:06:25,840 --> 00:06:28,479
collections of encryptions of truth

186
00:06:27,680 --> 00:06:30,240
tables

187
00:06:28,479 --> 00:06:31,520
which we collectively refer to as the

188
00:06:30,240 --> 00:06:34,960
material

189
00:06:31,520 --> 00:06:36,960
this this material is the stuff

190
00:06:34,960 --> 00:06:38,239
that bob needs to walk through the

191
00:06:36,960 --> 00:06:42,318
circuit gate by gate

192
00:06:38,240 --> 00:06:42,319
in order to decrypt output keys

193
00:06:42,720 --> 00:06:46,000
now for the purposes of this talk i

194
00:06:44,960 --> 00:06:48,239
actually would like

195
00:06:46,000 --> 00:06:51,039
to abstract a bit and i'd like for you

196
00:06:48,240 --> 00:06:54,880
to think of these encrypted truth tables

197
00:06:51,039 --> 00:06:57,759
as random strings that is

198
00:06:54,880 --> 00:06:58,960
specifically from the perspective of bob

199
00:06:57,759 --> 00:07:01,360
when he receives

200
00:06:58,960 --> 00:07:04,080
these encrypted truth tables he cannot

201
00:07:01,360 --> 00:07:06,080
see any of the structure that they have

202
00:07:04,080 --> 00:07:07,599
instead they just appear to be random

203
00:07:06,080 --> 00:07:11,680
strings which he then

204
00:07:07,599 --> 00:07:13,360
interprets as encrypted truth tables

205
00:07:11,680 --> 00:07:14,960
as we will see later on this turns out

206
00:07:13,360 --> 00:07:17,440
to be very significant

207
00:07:14,960 --> 00:07:18,799
because it means that bob cannot

208
00:07:17,440 --> 00:07:20,719
distinguish

209
00:07:18,800 --> 00:07:22,000
when an encryption of a circuit is

210
00:07:20,720 --> 00:07:25,199
properly constructed

211
00:07:22,000 --> 00:07:25,199
versus when it is not

212
00:07:25,840 --> 00:07:30,719
so alice takes all of these encryptions

213
00:07:28,960 --> 00:07:32,638
of truth tables

214
00:07:30,720 --> 00:07:35,199
compiles this into a single string of

215
00:07:32,639 --> 00:07:36,720
material and sends it across the wire to

216
00:07:35,199 --> 00:07:38,960
bob

217
00:07:36,720 --> 00:07:40,720
i'd like to re-emphasize that this

218
00:07:38,960 --> 00:07:43,198
simple sending of the material from

219
00:07:40,720 --> 00:07:45,759
alice to bob is the most expensive part

220
00:07:43,199 --> 00:07:48,000
of garbled circuit protocols

221
00:07:45,759 --> 00:07:49,360
and it is this communication this

222
00:07:48,000 --> 00:07:53,360
bandwidth consumption

223
00:07:49,360 --> 00:07:53,360
that we reduce in this work

224
00:07:55,360 --> 00:08:00,319
now let's look at how bob uses this

225
00:07:58,800 --> 00:08:03,520
material to finish

226
00:08:00,319 --> 00:08:05,919
the garble circuit protocol

227
00:08:03,520 --> 00:08:07,039
again bob now has access to all of the

228
00:08:05,919 --> 00:08:08,318
material

229
00:08:07,039 --> 00:08:10,479
and though i won't discuss this at

230
00:08:08,319 --> 00:08:12,960
length he also is able to get

231
00:08:10,479 --> 00:08:14,800
access to keys corresponding to the

232
00:08:12,960 --> 00:08:16,878
player's input values

233
00:08:14,800 --> 00:08:19,919
which is primarily achieved via

234
00:08:16,879 --> 00:08:19,919
oblivious transfer

235
00:08:20,240 --> 00:08:23,759
from here bob simply walks through this

236
00:08:22,000 --> 00:08:26,080
circuit gate by gate

237
00:08:23,759 --> 00:08:27,280
decrypting the logical truth tables we

238
00:08:26,080 --> 00:08:30,479
constructed earlier

239
00:08:27,280 --> 00:08:32,240
according to the keys that he has so he

240
00:08:30,479 --> 00:08:35,598
propagates the keys from

241
00:08:32,240 --> 00:08:37,279
input wires to output wires

242
00:08:35,599 --> 00:08:38,640
now that he has keys corresponding to

243
00:08:37,279 --> 00:08:41,279
the circuit output wires

244
00:08:38,640 --> 00:08:42,559
he and alice can work together to

245
00:08:41,279 --> 00:08:46,880
decrypt

246
00:08:42,559 --> 00:08:50,000
the semantic values of these keys

247
00:08:46,880 --> 00:08:52,720
and this completes the basic version of

248
00:08:50,000 --> 00:08:54,720
yale's girlboat circuit protocol

249
00:08:52,720 --> 00:08:57,440
to review the circuit generator's job is

250
00:08:54,720 --> 00:08:59,519
to encrypt the circuit gate by gate

251
00:08:57,440 --> 00:09:01,360
and ultimately to build this large

252
00:08:59,519 --> 00:09:02,720
string of material

253
00:09:01,360 --> 00:09:04,399
again i'd like you to think of this

254
00:09:02,720 --> 00:09:06,080
material as being

255
00:09:04,399 --> 00:09:08,560
random looking especially from the

256
00:09:06,080 --> 00:09:11,360
perspective of bob the evaluator

257
00:09:08,560 --> 00:09:13,920
the evaluator then uses this material to

258
00:09:11,360 --> 00:09:16,160
evaluate the circuit gate by gate

259
00:09:13,920 --> 00:09:18,319
decrypting the individual encrypted

260
00:09:16,160 --> 00:09:20,079
truth tables

261
00:09:18,320 --> 00:09:21,600
by doing so the players are able to

262
00:09:20,080 --> 00:09:24,000
propagate encryptions of

263
00:09:21,600 --> 00:09:25,279
input truth values to encryptions of

264
00:09:24,000 --> 00:09:26,959
output truth values

265
00:09:25,279 --> 00:09:29,040
and therefore to securely evaluate the

266
00:09:26,959 --> 00:09:32,160
function

267
00:09:29,040 --> 00:09:33,680
finally the dominant cost in miao

268
00:09:32,160 --> 00:09:35,279
scarborough circuit is this

269
00:09:33,680 --> 00:09:37,680
string of material that is sent from

270
00:09:35,279 --> 00:09:40,000
generator to evaluator

271
00:09:37,680 --> 00:09:40,719
again our goal is to just simply

272
00:09:40,000 --> 00:09:43,760
decrease

273
00:09:40,720 --> 00:09:45,839
the length of this string

274
00:09:43,760 --> 00:09:50,080
which we do by taking advantage of

275
00:09:45,839 --> 00:09:51,760
conditional branching in the circuit the

276
00:09:50,080 --> 00:09:53,839
subject of this work again is to

277
00:09:51,760 --> 00:09:55,200
explore how to make garble circuit more

278
00:09:53,839 --> 00:09:56,959
efficient

279
00:09:55,200 --> 00:09:59,120
the prior work has also looked at this

280
00:09:56,959 --> 00:10:01,839
problem decreasing communication

281
00:09:59,120 --> 00:10:03,839
bandwidth due to garbled circuits the

282
00:10:01,839 --> 00:10:05,120
primary way that people have improved

283
00:10:03,839 --> 00:10:08,399
the protocols

284
00:10:05,120 --> 00:10:11,120
is to decrease the number of

285
00:10:08,399 --> 00:10:15,040
encryptions needed to encode the

286
00:10:11,120 --> 00:10:15,040
semantics of an individual gate

287
00:10:15,200 --> 00:10:18,399
due to these improvements scarborough

288
00:10:16,560 --> 00:10:21,920
circuit today is efficient even for

289
00:10:18,399 --> 00:10:21,920
circuits with large numbers of gates

290
00:10:22,399 --> 00:10:26,079
however i'd like to point out that

291
00:10:24,640 --> 00:10:28,640
encrypting each gate

292
00:10:26,079 --> 00:10:29,920
individually leaves some efficiency on

293
00:10:28,640 --> 00:10:31,360
the table

294
00:10:29,920 --> 00:10:33,040
in particular with respect to

295
00:10:31,360 --> 00:10:35,519
conditional branching

296
00:10:33,040 --> 00:10:37,279
we individually encrypt all of the

297
00:10:35,519 --> 00:10:39,680
conditional branches of a circuit

298
00:10:37,279 --> 00:10:40,560
and send them across the wire while in

299
00:10:39,680 --> 00:10:42,880
fact

300
00:10:40,560 --> 00:10:44,959
almost none of the work involved with

301
00:10:42,880 --> 00:10:47,439
conditional branching is actually needed

302
00:10:44,959 --> 00:10:49,199
that is the output encryptions of all

303
00:10:47,440 --> 00:10:51,440
except for one conditional branch are

304
00:10:49,200 --> 00:10:54,079
completely discarded

305
00:10:51,440 --> 00:10:55,360
so when we encode conditional branches

306
00:10:54,079 --> 00:10:58,079
into circuits

307
00:10:55,360 --> 00:11:01,200
we waste a lot of work it is this fact

308
00:10:58,079 --> 00:11:03,760
that we exploit in our work

309
00:11:01,200 --> 00:11:05,440
we show a way to take advantage of this

310
00:11:03,760 --> 00:11:06,480
conditional branching such we do not

311
00:11:05,440 --> 00:11:14,160
have to produce

312
00:11:06,480 --> 00:11:16,000
separate encryptions all the branches

313
00:11:14,160 --> 00:11:17,279
two prior works have also looked at the

314
00:11:16,000 --> 00:11:18,240
same problem

315
00:11:17,279 --> 00:11:20,640
how to reduce the amount of

316
00:11:18,240 --> 00:11:23,680
communication for a garbled circuit

317
00:11:20,640 --> 00:11:26,399
in the case of conditional branching

318
00:11:23,680 --> 00:11:27,439
so free if due to my advisor vlad

319
00:11:26,399 --> 00:11:29,360
kolesnikov

320
00:11:27,440 --> 00:11:31,040
ask the question question how can we

321
00:11:29,360 --> 00:11:33,839
reduce communication

322
00:11:31,040 --> 00:11:35,519
if the circuit generator happens to know

323
00:11:33,839 --> 00:11:37,120
the control flow path

324
00:11:35,519 --> 00:11:38,959
through the program that is the

325
00:11:37,120 --> 00:11:41,760
generator knows all of the conditional

326
00:11:38,959 --> 00:11:45,599
branching decisions that are made

327
00:11:41,760 --> 00:11:47,439
symmetrically vlad and myself asked

328
00:11:45,600 --> 00:11:49,920
what can we do if the evaluator knows

329
00:11:47,440 --> 00:11:52,320
which branch is taken

330
00:11:49,920 --> 00:11:53,760
but in this work we ask the more

331
00:11:52,320 --> 00:11:56,000
difficult question

332
00:11:53,760 --> 00:11:57,920
we use some of the key ideas from these

333
00:11:56,000 --> 00:11:59,600
two prior works and ask the question

334
00:11:57,920 --> 00:12:01,920
what if no one knows which branch is

335
00:11:59,600 --> 00:12:04,480
taken so this brings us to our approach

336
00:12:01,920 --> 00:12:06,000
of stacked garbling

337
00:12:04,480 --> 00:12:07,440
so it is no longer sufficient to

338
00:12:06,000 --> 00:12:08,839
consider only one circuit of course

339
00:12:07,440 --> 00:12:10,399
since we're considering conditional

340
00:12:08,839 --> 00:12:12,000
branches so

341
00:12:10,399 --> 00:12:15,040
for the purposes of this talk we'll

342
00:12:12,000 --> 00:12:16,880
discuss two circuits

343
00:12:15,040 --> 00:12:18,560
now i'd like to start by emphasizing

344
00:12:16,880 --> 00:12:20,079
that we place no requirements on the

345
00:12:18,560 --> 00:12:22,399
structure of these circuits

346
00:12:20,079 --> 00:12:23,120
they can in particular have different

347
00:12:22,399 --> 00:12:25,360
gates

348
00:12:23,120 --> 00:12:27,279
and completely different topologies the

349
00:12:25,360 --> 00:12:29,920
circuits need not even be of the same

350
00:12:27,279 --> 00:12:32,000
number of gates

351
00:12:29,920 --> 00:12:33,519
now with that said i want to abstract

352
00:12:32,000 --> 00:12:34,160
and forget about the details of the

353
00:12:33,519 --> 00:12:36,000
circuit

354
00:12:34,160 --> 00:12:38,480
and simply think of these as objects

355
00:12:36,000 --> 00:12:40,000
that can be encrypted an initial

356
00:12:38,480 --> 00:12:42,160
question is to ask

357
00:12:40,000 --> 00:12:44,240
what does it mean that neither player

358
00:12:42,160 --> 00:12:46,880
knows which branch is taken

359
00:12:44,240 --> 00:12:47,680
the answer that we adopt is that the

360
00:12:46,880 --> 00:12:50,079
so-called

361
00:12:47,680 --> 00:12:51,120
branch condition which controls which

362
00:12:50,079 --> 00:12:54,160
branch is taken

363
00:12:51,120 --> 00:12:55,440
must be the output of some prior garbled

364
00:12:54,160 --> 00:12:57,120
circuit

365
00:12:55,440 --> 00:12:58,880
so here we have three circuits which we

366
00:12:57,120 --> 00:13:00,560
will compose together

367
00:12:58,880 --> 00:13:01,920
and it is this wire which is going to

368
00:13:00,560 --> 00:13:03,839
instruct which of the two

369
00:13:01,920 --> 00:13:07,279
conditionally composed circuits c1 and

370
00:13:03,839 --> 00:13:09,600
c2 should be evaluated

371
00:13:07,279 --> 00:13:11,360
i'd like to quickly show how this would

372
00:13:09,600 --> 00:13:14,480
be done in an ie fashion

373
00:13:11,360 --> 00:13:17,519
that is without stacked garbling

374
00:13:14,480 --> 00:13:19,680
the idea is simple we just route the

375
00:13:17,519 --> 00:13:22,399
output wires of this prior circuit

376
00:13:19,680 --> 00:13:25,519
to both of our conditional branches

377
00:13:22,399 --> 00:13:27,200
evaluate both circuits in their entirety

378
00:13:25,519 --> 00:13:29,519
and then add a special circuit at the

379
00:13:27,200 --> 00:13:31,440
end which we call a multiplexer

380
00:13:29,519 --> 00:13:32,880
the multiplexer's job is simply to

381
00:13:31,440 --> 00:13:34,399
select out

382
00:13:32,880 --> 00:13:37,120
the output of the branch that was

383
00:13:34,399 --> 00:13:37,120
actually taken

384
00:13:38,079 --> 00:13:42,239
i'll now show how we improve over this

385
00:13:40,560 --> 00:13:43,839
naive approach by

386
00:13:42,240 --> 00:13:45,440
compacting the amount of material that

387
00:13:43,839 --> 00:13:48,240
is needed for circuits that include

388
00:13:45,440 --> 00:13:50,160
conditional branching

389
00:13:48,240 --> 00:13:51,360
as one final piece of background i'd

390
00:13:50,160 --> 00:13:53,839
like to discuss

391
00:13:51,360 --> 00:13:56,480
the notion of expanding a circuit

392
00:13:53,839 --> 00:13:59,199
encryption starting from a seed

393
00:13:56,480 --> 00:14:00,160
if we recall alice's first job was to

394
00:13:59,199 --> 00:14:02,160
select

395
00:14:00,160 --> 00:14:03,519
random keys for all of the wires in the

396
00:14:02,160 --> 00:14:05,680
circuit

397
00:14:03,519 --> 00:14:08,720
in this work we insist that she does so

398
00:14:05,680 --> 00:14:11,680
according to a pseudo-random seed

399
00:14:08,720 --> 00:14:13,440
from this point forward all of alice's

400
00:14:11,680 --> 00:14:16,638
actions in constructing the circuit

401
00:14:13,440 --> 00:14:18,240
encryption are completely deterministic

402
00:14:16,639 --> 00:14:20,079
and so what this means is that the

403
00:14:18,240 --> 00:14:23,040
pseudorandom seed has become

404
00:14:20,079 --> 00:14:25,839
a compact description of the entire

405
00:14:23,040 --> 00:14:29,120
circuit encryption

406
00:14:25,839 --> 00:14:31,120
of course we cannot use this seed

407
00:14:29,120 --> 00:14:32,480
as the encryption of a circuit in all

408
00:14:31,120 --> 00:14:34,720
cases

409
00:14:32,480 --> 00:14:36,720
the problem is that if we just send the

410
00:14:34,720 --> 00:14:38,800
seed from alice to bob

411
00:14:36,720 --> 00:14:40,320
then bob will get to see all of the keys

412
00:14:38,800 --> 00:14:42,079
on all of the wires

413
00:14:40,320 --> 00:14:44,560
and this is simply not secure he gets

414
00:14:42,079 --> 00:14:47,279
far too much information

415
00:14:44,560 --> 00:14:48,319
however in this work we show that in the

416
00:14:47,279 --> 00:14:51,439
case of branches

417
00:14:48,320 --> 00:14:51,760
not taken it is okay for the encryption

418
00:14:51,440 --> 00:14:54,639
of

419
00:14:51,760 --> 00:14:56,800
one of these untaken branches to be

420
00:14:54,639 --> 00:14:59,839
derived from a seed that bob is allowed

421
00:14:56,800 --> 00:14:59,839
to know

422
00:15:01,440 --> 00:15:05,839
so now for our approach again we have

423
00:15:04,880 --> 00:15:08,880
some circuit c

424
00:15:05,839 --> 00:15:12,000
prime that is feeding outputs into

425
00:15:08,880 --> 00:15:13,600
the two branches c1 and c2 we

426
00:15:12,000 --> 00:15:16,240
start by simply constructing an

427
00:15:13,600 --> 00:15:18,639
encryption of this first circuit m prime

428
00:15:16,240 --> 00:15:20,639
but for the branches alice will perform

429
00:15:18,639 --> 00:15:22,240
differently

430
00:15:20,639 --> 00:15:23,920
we will have her construct encryptions

431
00:15:22,240 --> 00:15:25,600
of these two circuits according to

432
00:15:23,920 --> 00:15:27,839
pseudorandom seeds

433
00:15:25,600 --> 00:15:29,680
to build up two strings of material m1

434
00:15:27,839 --> 00:15:30,880
and m2

435
00:15:29,680 --> 00:15:34,719
again recall that these strings of

436
00:15:30,880 --> 00:15:36,480
material are encryptions of truth tables

437
00:15:34,720 --> 00:15:40,160
but they can be regarded as nothing more

438
00:15:36,480 --> 00:15:41,839
than random looking strings

439
00:15:40,160 --> 00:15:43,600
recall that we have a branch condition

440
00:15:41,839 --> 00:15:45,519
that is either zero or one

441
00:15:43,600 --> 00:15:48,320
and that there are keys available which

442
00:15:45,519 --> 00:15:49,759
encode these two different values

443
00:15:48,320 --> 00:15:52,240
what we will do is have the circuit

444
00:15:49,759 --> 00:15:55,199
generator construct encryptions

445
00:15:52,240 --> 00:15:56,399
of the two seats in a encrypted truth

446
00:15:55,199 --> 00:15:58,880
table

447
00:15:56,399 --> 00:16:00,880
that if bob gets access to the green key

448
00:15:58,880 --> 00:16:01,600
then he should be allowed access to seed

449
00:16:00,880 --> 00:16:03,519
one

450
00:16:01,600 --> 00:16:05,360
and if he gets access to the red key he

451
00:16:03,519 --> 00:16:08,880
should be allowed access to seed

452
00:16:05,360 --> 00:16:11,519
two what this will do is allow bob

453
00:16:08,880 --> 00:16:14,000
to construct an encryption of the branch

454
00:16:11,519 --> 00:16:15,600
that is not taken

455
00:16:14,000 --> 00:16:17,759
like our encrypted truth tables from

456
00:16:15,600 --> 00:16:18,800
earlier we need alice to randomly

457
00:16:17,759 --> 00:16:20,839
permute

458
00:16:18,800 --> 00:16:22,000
the order of these seeds such that bob

459
00:16:20,839 --> 00:16:24,480
cannot

460
00:16:22,000 --> 00:16:26,000
correlate the thing that he decrypts

461
00:16:24,480 --> 00:16:28,320
with some semantic meaning in the

462
00:16:26,000 --> 00:16:28,320
circuit

463
00:16:29,120 --> 00:16:33,519
next alice is going to package up the

464
00:16:31,440 --> 00:16:35,600
material to send over to bob

465
00:16:33,519 --> 00:16:38,079
so she collects m prime and also this

466
00:16:35,600 --> 00:16:40,160
encrypted truth table including seeds

467
00:16:38,079 --> 00:16:41,120
but instead of sending m1 and m2

468
00:16:40,160 --> 00:16:43,839
separately

469
00:16:41,120 --> 00:16:46,480
she adds these two values together using

470
00:16:43,839 --> 00:16:48,240
bitwise exclusive or

471
00:16:46,480 --> 00:16:49,519
here is where we have one in terms of

472
00:16:48,240 --> 00:16:51,759
communication

473
00:16:49,519 --> 00:16:52,880
in the naive approach we would send m1

474
00:16:51,759 --> 00:16:55,680
and m2 separately

475
00:16:52,880 --> 00:16:58,240
but now we are sending the xor sum of

476
00:16:55,680 --> 00:17:00,800
these two values

477
00:16:58,240 --> 00:17:01,279
alice sends this all of this material

478
00:17:00,800 --> 00:17:04,959
across

479
00:17:01,279 --> 00:17:07,520
the wire to the evaluator

480
00:17:04,959 --> 00:17:09,360
so now in the evaluator's view the

481
00:17:07,520 --> 00:17:13,199
evaluator has access to the sum

482
00:17:09,359 --> 00:17:14,079
m1 plus m2 into m prime and also by

483
00:17:13,199 --> 00:17:16,480
evaluating c

484
00:17:14,079 --> 00:17:18,879
prime he gets some branch condition in

485
00:17:16,480 --> 00:17:21,839
this case we'll say he gets a green key

486
00:17:18,880 --> 00:17:23,439
meant to indicate that the circuit c2 is

487
00:17:21,839 --> 00:17:26,079
taken

488
00:17:23,439 --> 00:17:27,280
of course bob is not supposed to know

489
00:17:26,079 --> 00:17:28,960
which branch is taken

490
00:17:27,280 --> 00:17:31,120
and we'll revisit revisit that in a

491
00:17:28,960 --> 00:17:33,679
moment for now let's suppose

492
00:17:31,120 --> 00:17:36,799
magically bob has figured out which

493
00:17:33,679 --> 00:17:36,799
circuit is meant to be taken

494
00:17:37,360 --> 00:17:41,439
what you can do from here is decrypt a

495
00:17:40,160 --> 00:17:44,480
seed

496
00:17:41,440 --> 00:17:47,200
from this encrypted truth table of seeds

497
00:17:44,480 --> 00:17:48,320
and use the seed to re-encrypt the

498
00:17:47,200 --> 00:17:52,880
branch not taken

499
00:17:48,320 --> 00:17:56,000
that is to regenerate the string m1

500
00:17:52,880 --> 00:17:59,200
now he can use bitwise x4 once again

501
00:17:56,000 --> 00:18:01,280
to extract the string m2

502
00:17:59,200 --> 00:18:03,120
from here it's a simple manner to feed

503
00:18:01,280 --> 00:18:07,280
in the correct inputs

504
00:18:03,120 --> 00:18:10,080
and derive output keys by evaluation

505
00:18:07,280 --> 00:18:11,039
of course as i have described so far

506
00:18:10,080 --> 00:18:12,960
there is a problem

507
00:18:11,039 --> 00:18:15,919
because the evaluator is not supposed to

508
00:18:12,960 --> 00:18:17,919
know which branch is actually taken

509
00:18:15,919 --> 00:18:19,360
the way that we resolve this is to

510
00:18:17,919 --> 00:18:22,720
ensure that bob's

511
00:18:19,360 --> 00:18:23,600
actions are symmetric that is he does

512
00:18:22,720 --> 00:18:25,440
not know

513
00:18:23,600 --> 00:18:27,600
that the second circuit is taken he

514
00:18:25,440 --> 00:18:29,919
simply guesses if that's the case

515
00:18:27,600 --> 00:18:32,320
and symmetrically he also guesses that

516
00:18:29,919 --> 00:18:34,320
the first circuit is taken

517
00:18:32,320 --> 00:18:36,159
so to describe what happens when when he

518
00:18:34,320 --> 00:18:39,200
makes this second guess

519
00:18:36,160 --> 00:18:41,440
well he uses the seed as before but

520
00:18:39,200 --> 00:18:43,840
instead of trying to encrypt c1 he tries

521
00:18:41,440 --> 00:18:46,480
to encrypt c2

522
00:18:43,840 --> 00:18:47,840
notice that this action of encrypting c2

523
00:18:46,480 --> 00:18:49,919
has nothing to do

524
00:18:47,840 --> 00:18:51,760
with any action taken so far by the

525
00:18:49,919 --> 00:18:54,320
circuit generator

526
00:18:51,760 --> 00:18:56,000
the circuit generator never encrypted

527
00:18:54,320 --> 00:18:59,600
the circuit c2

528
00:18:56,000 --> 00:19:01,120
using seed one so instead of getting

529
00:18:59,600 --> 00:19:02,159
something that the generator had

530
00:19:01,120 --> 00:19:04,399
generated

531
00:19:02,160 --> 00:19:06,880
the evaluator generates a new encryption

532
00:19:04,400 --> 00:19:08,960
m2 star

533
00:19:06,880 --> 00:19:10,160
when the evaluator then goes to try to

534
00:19:08,960 --> 00:19:13,200
extract the material

535
00:19:10,160 --> 00:19:16,799
m1 he is unsuccessful that is this

536
00:19:13,200 --> 00:19:19,760
algebraic expression does not reduce

537
00:19:16,799 --> 00:19:21,840
so instead of having an encryption

538
00:19:19,760 --> 00:19:23,520
corresponding to circuit one

539
00:19:21,840 --> 00:19:26,000
the evaluator has an encryption

540
00:19:23,520 --> 00:19:28,639
corresponding to nothing at all

541
00:19:26,000 --> 00:19:30,720
this string of material is simply

542
00:19:28,640 --> 00:19:32,480
garbage

543
00:19:30,720 --> 00:19:34,720
here it is significant that these

544
00:19:32,480 --> 00:19:37,280
strings of material look random

545
00:19:34,720 --> 00:19:38,559
you see when the evaluator obtains this

546
00:19:37,280 --> 00:19:41,120
string of material

547
00:19:38,559 --> 00:19:42,320
this large sum it's critical that he

548
00:19:41,120 --> 00:19:45,760
cannot distinguish

549
00:19:42,320 --> 00:19:45,760
this is not a valid encryption

550
00:19:45,840 --> 00:19:50,399
thus when the evaluator tries to run

551
00:19:48,880 --> 00:19:52,640
this circuit

552
00:19:50,400 --> 00:19:54,640
using this invalid encryption he

553
00:19:52,640 --> 00:19:56,240
inevitably ends up with some output

554
00:19:54,640 --> 00:19:57,360
labels that are neither an encryption or

555
00:19:56,240 --> 00:19:59,360
zero over one

556
00:19:57,360 --> 00:20:01,600
the output labels are simply garbage as

557
00:19:59,360 --> 00:20:01,600
well

558
00:20:02,320 --> 00:20:07,360
from here we would like to get rid of

559
00:20:05,120 --> 00:20:09,520
the garbage output labels

560
00:20:07,360 --> 00:20:11,840
we want to discard the garbage and

561
00:20:09,520 --> 00:20:12,559
retain the valid output labels that came

562
00:20:11,840 --> 00:20:14,879
from

563
00:20:12,559 --> 00:20:17,918
the actually taken branch and we want

564
00:20:14,880 --> 00:20:19,840
this to all happen obliviously

565
00:20:17,919 --> 00:20:21,679
one way that this could be done is to

566
00:20:19,840 --> 00:20:23,760
involve some sort of protocol

567
00:20:21,679 --> 00:20:25,600
this is the approach that was taken in

568
00:20:23,760 --> 00:20:27,360
the free if paper

569
00:20:25,600 --> 00:20:29,439
the idea is that the two players will

570
00:20:27,360 --> 00:20:31,439
communicate using some sort of protocol

571
00:20:29,440 --> 00:20:34,240
involving oblivious transfer

572
00:20:31,440 --> 00:20:35,440
in order to discard the garbage and

573
00:20:34,240 --> 00:20:37,760
yield only

574
00:20:35,440 --> 00:20:40,159
re-encrypted versions of the output keys

575
00:20:37,760 --> 00:20:42,799
from the taken branch

576
00:20:40,159 --> 00:20:43,280
this is somewhat unsatisfying recall

577
00:20:42,799 --> 00:20:45,280
that

578
00:20:43,280 --> 00:20:46,559
one of the primary advantages of garbled

579
00:20:45,280 --> 00:20:49,520
circuits is its

580
00:20:46,559 --> 00:20:50,399
constant round property by incorporating

581
00:20:49,520 --> 00:20:52,879
a protocol

582
00:20:50,400 --> 00:20:54,880
to eliminate garbage we are losing the

583
00:20:52,880 --> 00:20:56,000
fact that we have constant rounds

584
00:20:54,880 --> 00:20:57,200
the number of rounds are now

585
00:20:56,000 --> 00:20:59,520
proportional to the number of

586
00:20:57,200 --> 00:21:02,960
conditional branches

587
00:20:59,520 --> 00:21:04,280
therefore we developed a way to discard

588
00:21:02,960 --> 00:21:07,280
this garbage completely

589
00:21:04,280 --> 00:21:07,280
non-interactively

590
00:21:07,360 --> 00:21:11,199
this is perhaps the most technically

591
00:21:09,520 --> 00:21:14,080
involved and confusing part of

592
00:21:11,200 --> 00:21:15,280
our approach so i hope that if you have

593
00:21:14,080 --> 00:21:17,600
trouble with this explanation you'll

594
00:21:15,280 --> 00:21:19,678
take a look at our paper

595
00:21:17,600 --> 00:21:21,678
but the idea is that the generator is

596
00:21:19,679 --> 00:21:23,520
going to do some extra work

597
00:21:21,679 --> 00:21:24,720
in order to build a garbled circuit

598
00:21:23,520 --> 00:21:27,440
gadget

599
00:21:24,720 --> 00:21:28,320
which when decrypted will yield only the

600
00:21:27,440 --> 00:21:30,000
valid

601
00:21:28,320 --> 00:21:31,439
output labels and will discard all of

602
00:21:30,000 --> 00:21:34,000
the garbage

603
00:21:31,440 --> 00:21:34,960
at a high level alice is going to put

604
00:21:34,000 --> 00:21:37,039
herself

605
00:21:34,960 --> 00:21:40,159
in the shoes of bob when he makes one of

606
00:21:37,039 --> 00:21:42,799
these assumptions that is bad

607
00:21:40,159 --> 00:21:44,320
so specifically what she will do is she

608
00:21:42,799 --> 00:21:48,400
will use seed 1

609
00:21:44,320 --> 00:21:50,158
to encrypt c2 recall that this is not

610
00:21:48,400 --> 00:21:51,520
consistent with the way that she built

611
00:21:50,159 --> 00:21:53,360
her circuit encryption

612
00:21:51,520 --> 00:21:54,720
this corresponds to a bad assumption

613
00:21:53,360 --> 00:21:58,000
made by bob about which

614
00:21:54,720 --> 00:22:01,280
branch is taken

615
00:21:58,000 --> 00:22:03,360
therefore by running the circuit c1

616
00:22:01,280 --> 00:22:05,840
using the same garbage material as bob

617
00:22:03,360 --> 00:22:09,039
did she can arrive at the same garbage

618
00:22:05,840 --> 00:22:11,120
output labels that bob did

619
00:22:09,039 --> 00:22:12,158
and symmetrically she can perform the

620
00:22:11,120 --> 00:22:14,639
same exact

621
00:22:12,159 --> 00:22:17,840
actions to derive the garbage output

622
00:22:14,640 --> 00:22:17,840
labels from c2

623
00:22:18,799 --> 00:22:22,799
now alice knows the garbage output

624
00:22:21,039 --> 00:22:24,559
labels

625
00:22:22,799 --> 00:22:26,158
from both circuits as well as the valid

626
00:22:24,559 --> 00:22:28,000
output labels

627
00:22:26,159 --> 00:22:30,400
this amount of information suffices for

628
00:22:28,000 --> 00:22:32,400
her to build a garbled gadget

629
00:22:30,400 --> 00:22:34,400
this garbled gadget is simply a large

630
00:22:32,400 --> 00:22:36,320
encrypted truth table

631
00:22:34,400 --> 00:22:38,480
which when provided inputs that are

632
00:22:36,320 --> 00:22:41,280
either garbage or valid values

633
00:22:38,480 --> 00:22:44,320
will throw away the garbage values and

634
00:22:41,280 --> 00:22:45,918
retain the valid ones

635
00:22:44,320 --> 00:22:47,439
there is one small problem with what i

636
00:22:45,919 --> 00:22:49,600
have depicted so far

637
00:22:47,440 --> 00:22:52,000
which is that the number of garbage

638
00:22:49,600 --> 00:22:52,480
values that the evaluator could arrive

639
00:22:52,000 --> 00:22:56,799
at

640
00:22:52,480 --> 00:22:59,280
is exponential in the number of inputs

641
00:22:56,799 --> 00:23:00,918
to resolve this we add one additional

642
00:22:59,280 --> 00:23:04,240
component which is this front

643
00:23:00,919 --> 00:23:05,679
demultiplexer this demultiplexer

644
00:23:04,240 --> 00:23:07,919
component is simple

645
00:23:05,679 --> 00:23:10,240
its job is to make sure that the inputs

646
00:23:07,919 --> 00:23:12,720
that bob uses for the branches not taken

647
00:23:10,240 --> 00:23:13,679
are predictable you can think of what

648
00:23:12,720 --> 00:23:16,400
that is doing

649
00:23:13,679 --> 00:23:18,080
is it is multiplying all of the inputs

650
00:23:16,400 --> 00:23:20,159
to each branch by either 0

651
00:23:18,080 --> 00:23:21,439
or 1 depending on if the branch is taken

652
00:23:20,159 --> 00:23:23,840
or not

653
00:23:21,440 --> 00:23:24,559
by doing so we eliminate uncertainty

654
00:23:23,840 --> 00:23:26,720
about these

655
00:23:24,559 --> 00:23:28,399
output garbage values there's simply

656
00:23:26,720 --> 00:23:30,559
only one of them that can possibly come

657
00:23:28,400 --> 00:23:32,400
out of each circuit

658
00:23:30,559 --> 00:23:34,399
with this in hand it is now practical

659
00:23:32,400 --> 00:23:36,240
for alice to build one of these

660
00:23:34,400 --> 00:23:38,000
multiplexer components based on the

661
00:23:36,240 --> 00:23:41,039
values that come out of invalid

662
00:23:38,000 --> 00:23:41,039
execution of circuits

663
00:23:45,039 --> 00:23:49,840
so this was stacked garbling again our

664
00:23:47,840 --> 00:23:51,039
contribution is to reduce the amount of

665
00:23:49,840 --> 00:23:52,639
material

666
00:23:51,039 --> 00:23:54,559
sent from the circuit generator to the

667
00:23:52,640 --> 00:23:56,240
evaluator in yao's garble circuit

668
00:23:54,559 --> 00:23:58,320
protocol

669
00:23:56,240 --> 00:24:00,240
our communication is constant in the

670
00:23:58,320 --> 00:24:02,840
number of conditional branches

671
00:24:00,240 --> 00:24:05,440
a theoretical improvement over prior

672
00:24:02,840 --> 00:24:06,879
work as some future work

673
00:24:05,440 --> 00:24:09,520
we're interested in reducing the

674
00:24:06,880 --> 00:24:11,360
computation overhead of our approach

675
00:24:09,520 --> 00:24:13,918
although i didn't discuss it the

676
00:24:11,360 --> 00:24:17,279
procedure that of alice putting herself

677
00:24:13,919 --> 00:24:19,679
in the place of bob incurs quadratic

678
00:24:17,279 --> 00:24:21,200
work in the number of branches we're

679
00:24:19,679 --> 00:24:22,559
interested in approaches which improve

680
00:24:21,200 --> 00:24:24,320
on this

681
00:24:22,559 --> 00:24:26,240
as of now we know a technique that

682
00:24:24,320 --> 00:24:26,639
improves this computation overhead to

683
00:24:26,240 --> 00:24:29,679
only

684
00:24:26,640 --> 00:24:31,520
o log b we are very much interested in

685
00:24:29,679 --> 00:24:32,159
any approaches that can further improve

686
00:24:31,520 --> 00:24:35,600
this

687
00:24:32,159 --> 00:24:37,039
computation so this was stacked gargling

688
00:24:35,600 --> 00:24:40,320
thank you very much for your time and

689
00:24:37,039 --> 00:24:40,320
for listening

