1
00:00:00,080 --> 00:00:04,240
can i already start ah there i see it

2
00:00:03,600 --> 00:00:06,319
okay

3
00:00:04,240 --> 00:00:08,480
so hi everybody welcome to the nisk's

4
00:00:06,319 --> 00:00:10,480
consensus and delay function session

5
00:00:08,480 --> 00:00:12,320
i'm alone then i'm sharing the session

6
00:00:10,480 --> 00:00:14,000
together with julio monavolta you can

7
00:00:12,320 --> 00:00:17,359
see him also

8
00:00:14,000 --> 00:00:18,720
appearing here our first stock amongst

9
00:00:17,359 --> 00:00:21,199
the five talks that we have in the

10
00:00:18,720 --> 00:00:23,198
session uh it's tied to spartan

11
00:00:21,199 --> 00:00:25,760
efficient and general purpose zero not

12
00:00:23,199 --> 00:00:28,160
it starts without the trusted setup

13
00:00:25,760 --> 00:00:29,920
and the speaker is three not seti you

14
00:00:28,160 --> 00:00:31,519
will have five minutes to speak and then

15
00:00:29,920 --> 00:00:32,559
we'll have five minutes for discussion

16
00:00:31,519 --> 00:00:36,079
while we set up

17
00:00:32,558 --> 00:00:39,519
for the next talk so

18
00:00:36,079 --> 00:00:41,680
you can begin sooner thank you thank you

19
00:00:39,520 --> 00:00:44,079
this talk is about a new family of zk

20
00:00:41,680 --> 00:00:46,000
snarks which we call spartan

21
00:00:44,079 --> 00:00:48,160
before i describe spartan let's recall

22
00:00:46,000 --> 00:00:50,320
what a zk snark is

23
00:00:48,160 --> 00:00:52,000
a zika snack is an argument of knowledge

24
00:00:50,320 --> 00:00:54,239
meaning that it's a protocol between a

25
00:00:52,000 --> 00:00:56,160
brewer and a verifier

26
00:00:54,239 --> 00:00:58,000
specifically given a circuit c the

27
00:00:56,160 --> 00:00:59,919
prover wants to prove the knowledge of a

28
00:00:58,000 --> 00:01:02,960
witness w such that the circuit is

29
00:00:59,920 --> 00:01:03,520
satisfiable second it's a zero knowledge

30
00:01:02,960 --> 00:01:05,920
argument

31
00:01:03,520 --> 00:01:07,920
meaning that the proof hides the witness

32
00:01:05,920 --> 00:01:10,880
third it's non-interactive

33
00:01:07,920 --> 00:01:11,920
finally it's succeed there are two forms

34
00:01:10,880 --> 00:01:13,839
of succinctness

35
00:01:11,920 --> 00:01:15,759
first the size of the proof is sublinear

36
00:01:13,840 --> 00:01:17,840
in the size of the circuit

37
00:01:15,759 --> 00:01:18,799
second the cost to verify the proof is

38
00:01:17,840 --> 00:01:21,920
also sublinear

39
00:01:18,799 --> 00:01:23,759
in the size of the circuit there are

40
00:01:21,920 --> 00:01:24,640
many approaches to build zika snarks in

41
00:01:23,759 --> 00:01:26,159
the literature

42
00:01:24,640 --> 00:01:29,280
starting with the works of kilian and

43
00:01:26,159 --> 00:01:31,439
mikhail unfortunately they rely on pcp

44
00:01:29,280 --> 00:01:33,360
so they remain too expensive to be used

45
00:01:31,439 --> 00:01:35,039
in practice

46
00:01:33,360 --> 00:01:37,920
a breakthrough result in this area was

47
00:01:35,040 --> 00:01:39,280
provided by the work of ggpr

48
00:01:37,920 --> 00:01:41,840
their scheme supports proving the

49
00:01:39,280 --> 00:01:43,759
satisfiability of arbitrary circuits

50
00:01:41,840 --> 00:01:45,600
more importantly the scheme achieves

51
00:01:43,759 --> 00:01:48,159
near optimal asymptotics with good

52
00:01:45,600 --> 00:01:50,559
constants

53
00:01:48,159 --> 00:01:52,799
unfortunately a major downside with this

54
00:01:50,560 --> 00:01:54,560
scheme is that it requires a per circuit

55
00:01:52,799 --> 00:01:56,560
trusted setup

56
00:01:54,560 --> 00:02:00,640
the setup is trusted because it requires

57
00:01:56,560 --> 00:02:02,880
a trapdoor that must be kept secret

58
00:02:00,640 --> 00:02:04,719
this problem has motivated another class

59
00:02:02,880 --> 00:02:06,479
of works called zk snarks without

60
00:02:04,719 --> 00:02:09,199
trusted setup

61
00:02:06,479 --> 00:02:11,120
there are several schemes in this class

62
00:02:09,199 --> 00:02:12,000
unfortunately existing schemes can

63
00:02:11,120 --> 00:02:14,000
support

64
00:02:12,000 --> 00:02:16,800
either arbitrary circuits or a succinct

65
00:02:14,000 --> 00:02:19,120
verifier but not both

66
00:02:16,800 --> 00:02:20,879
for example hyrax supports a succinct

67
00:02:19,120 --> 00:02:23,360
verifier but it requires its circuits to

68
00:02:20,879 --> 00:02:25,040
be layered data parallel circuits

69
00:02:23,360 --> 00:02:26,959
similarly stark supports a succinct

70
00:02:25,040 --> 00:02:29,920
verifier but it requires circuits to be

71
00:02:26,959 --> 00:02:32,160
a sequence of repeated sub-circuits

72
00:02:29,920 --> 00:02:33,200
on the other side we have ligero aurora

73
00:02:32,160 --> 00:02:34,959
and bulletproofs

74
00:02:33,200 --> 00:02:36,399
that target arbitrary circuits but the

75
00:02:34,959 --> 00:02:39,440
require but they incur

76
00:02:36,400 --> 00:02:40,720
linear time verification costs in

77
00:02:39,440 --> 00:02:42,319
contrast our work can

78
00:02:40,720 --> 00:02:45,760
simultaneously support arbitrary

79
00:02:42,319 --> 00:02:47,599
circuits and a succinct verifier

80
00:02:45,760 --> 00:02:49,840
this turns out to be challenging because

81
00:02:47,599 --> 00:02:51,518
arbitrary circuits by definition have no

82
00:02:49,840 --> 00:02:53,519
structure

83
00:02:51,519 --> 00:02:56,480
furthermore the verifier must actually

84
00:02:53,519 --> 00:02:58,239
know what statement it's verifying

85
00:02:56,480 --> 00:03:00,079
what this means is that verification

86
00:02:58,239 --> 00:03:02,560
must be at least linear in the size of

87
00:03:00,080 --> 00:03:04,319
the circuit

88
00:03:02,560 --> 00:03:05,920
spartan gets around this problem by

89
00:03:04,319 --> 00:03:09,040
pre-processing circuits

90
00:03:05,920 --> 00:03:11,200
but without using any secret trapdoors

91
00:03:09,040 --> 00:03:12,720
in particular the verifier retains a

92
00:03:11,200 --> 00:03:14,159
short cryptographic commitment to the

93
00:03:12,720 --> 00:03:16,640
description of the circuit which we call

94
00:03:14,159 --> 00:03:18,159
it computational commitment

95
00:03:16,640 --> 00:03:20,159
creating a computation commitment

96
00:03:18,159 --> 00:03:21,359
requires time that's at least linear in

97
00:03:20,159 --> 00:03:23,920
the size of the circuit but it's

98
00:03:21,360 --> 00:03:23,920
reusable

99
00:03:25,440 --> 00:03:28,560
uh in the next one minute or so i'm

100
00:03:27,760 --> 00:03:31,040
going to provide an

101
00:03:28,560 --> 00:03:32,239
overview of house pattern works so the

102
00:03:31,040 --> 00:03:33,679
foundation of spartan

103
00:03:32,239 --> 00:03:35,760
is the subject protocol which is an

104
00:03:33,680 --> 00:03:38,159
interactive proof system for proving

105
00:03:35,760 --> 00:03:41,120
that a polynomial sums to a target value

106
00:03:38,159 --> 00:03:42,798
t over some boolean hypercube

107
00:03:41,120 --> 00:03:44,720
but spartan is interested in proving the

108
00:03:42,799 --> 00:03:46,560
satisfiability of circuits

109
00:03:44,720 --> 00:03:48,560
so in the paper we provide a reduction

110
00:03:46,560 --> 00:03:49,680
from r1cs instances to some check

111
00:03:48,560 --> 00:03:51,760
instances

112
00:03:49,680 --> 00:03:54,159
where r1cs generalizes arithmetic

113
00:03:51,760 --> 00:03:55,840
circuit satisfiability

114
00:03:54,159 --> 00:03:57,920
we then design a set of techniques in

115
00:03:55,840 --> 00:03:59,519
conjunction with existing compilers to

116
00:03:57,920 --> 00:04:01,119
transform the subject protocol

117
00:03:59,519 --> 00:04:03,280
into a non-interactive zero knowledge

118
00:04:01,120 --> 00:04:05,200
proof system for r1cs

119
00:04:03,280 --> 00:04:07,200
here both the prover and the verifier

120
00:04:05,200 --> 00:04:08,720
take as input some public parameters

121
00:04:07,200 --> 00:04:12,720
and the description of the circuit which

122
00:04:08,720 --> 00:04:12,720
is denoted with this triple a b c

123
00:04:13,200 --> 00:04:16,238
but because the verifier reads the

124
00:04:14,799 --> 00:04:17,840
description of the circuit the cost of

125
00:04:16,238 --> 00:04:19,358
the verifier is at least linear in the

126
00:04:17,839 --> 00:04:21,358
circuit size

127
00:04:19,358 --> 00:04:22,719
so we design another algorithm that we

128
00:04:21,358 --> 00:04:24,080
call an encoder that treats the

129
00:04:22,720 --> 00:04:25,919
description of the circuit and

130
00:04:24,080 --> 00:04:27,359
outputs a computational commitment which

131
00:04:25,919 --> 00:04:30,400
consists of commitments to three

132
00:04:27,360 --> 00:04:31,759
polynomials that describe the circuit

133
00:04:30,400 --> 00:04:33,840
so we combine this computation

134
00:04:31,759 --> 00:04:35,199
commitment with our music proof system

135
00:04:33,840 --> 00:04:37,520
to get a zk snark

136
00:04:35,199 --> 00:04:39,199
where instead of reading the description

137
00:04:37,520 --> 00:04:41,599
of the circuit the verifier reads a

138
00:04:39,199 --> 00:04:43,280
computational commitment

139
00:04:41,600 --> 00:04:45,199
the prover in addition to producing a

140
00:04:43,280 --> 00:04:47,198
nazi proof of satisfiability it also

141
00:04:45,199 --> 00:04:49,040
produces a proof of correct evaluation

142
00:04:47,199 --> 00:04:52,160
of the computation commitment

143
00:04:49,040 --> 00:04:54,080
which we denote with pi gamma

144
00:04:52,160 --> 00:04:56,400
one remaining technical problem is that

145
00:04:54,080 --> 00:04:58,080
both encoder and the prover require a

146
00:04:56,400 --> 00:05:01,198
polynomial commitment scheme for

147
00:04:58,080 --> 00:05:03,120
sparse multilinear polynomials so if we

148
00:05:01,199 --> 00:05:05,120
apply existing schemes the both the

149
00:05:03,120 --> 00:05:08,560
encoder and the prover incur cost that

150
00:05:05,120 --> 00:05:10,800
are quadratic in the size of the circuit

151
00:05:08,560 --> 00:05:12,639
so we design a generic compiler that can

152
00:05:10,800 --> 00:05:14,800
take an existing polynomial commitment

153
00:05:12,639 --> 00:05:15,199
scheme for dense multilinear polynomials

154
00:05:14,800 --> 00:05:17,919
and then

155
00:05:15,199 --> 00:05:20,800
transform it into a scheme for sparse

156
00:05:17,919 --> 00:05:22,639
multi-linear polynomials

157
00:05:20,800 --> 00:05:24,320
we implemented the scheme and here is a

158
00:05:22,639 --> 00:05:25,840
table that depicts the performance of

159
00:05:24,320 --> 00:05:28,400
spartan and compares it with

160
00:05:25,840 --> 00:05:29,599
existing schemes there are three

161
00:05:28,400 --> 00:05:33,198
takeaways here

162
00:05:29,600 --> 00:05:35,600
first spartan offers the fastest proverb

163
00:05:33,199 --> 00:05:37,680
second grad 16 which requires a trusted

164
00:05:35,600 --> 00:05:39,759
setup offers the fastest verifier and

165
00:05:37,680 --> 00:05:41,759
shortest proof sizes

166
00:05:39,759 --> 00:05:44,240
but if you focus on schemes that do not

167
00:05:41,759 --> 00:05:46,320
require a trusted setup spartan offers

168
00:05:44,240 --> 00:05:47,440
the fastest verifier and shortest proof

169
00:05:46,320 --> 00:05:49,360
sizes

170
00:05:47,440 --> 00:05:51,520
the only exception here is the size of

171
00:05:49,360 --> 00:05:53,039
the proof under bullet proofs but

172
00:05:51,520 --> 00:05:55,840
incur slower verification both

173
00:05:53,039 --> 00:05:59,280
asymptotically and concretely

174
00:05:55,840 --> 00:05:59,280
with that i can take questions

175
00:06:00,560 --> 00:06:05,120
thank you very much julia is taking over

176
00:06:03,280 --> 00:06:07,280
with the question

177
00:06:05,120 --> 00:06:08,400
yes thanks for the talk uh if you have

178
00:06:07,280 --> 00:06:10,400
questions please

179
00:06:08,400 --> 00:06:12,318
make yourself noticed you can raise your

180
00:06:10,400 --> 00:06:21,840
hand or just unmute yourself and

181
00:06:12,319 --> 00:06:21,840
ask a question

182
00:06:23,759 --> 00:06:30,479
so i have a quick question for you um

183
00:06:27,520 --> 00:06:31,280
uh you you saw this table under which uh

184
00:06:30,479 --> 00:06:34,960
assumptions

185
00:06:31,280 --> 00:06:37,359
do does your does your scheme

186
00:06:34,960 --> 00:06:38,560
provide those guarantees so the

187
00:06:37,360 --> 00:06:40,960
implemented scheme

188
00:06:38,560 --> 00:06:44,639
requires the hardness of discrete

189
00:06:40,960 --> 00:06:47,440
logarithms in the random oracle model

190
00:06:44,639 --> 00:06:49,120
but uh so the assumptions made by

191
00:06:47,440 --> 00:06:50,479
spartan are essentially the assumptions

192
00:06:49,120 --> 00:06:52,160
required for the polynomial commitment

193
00:06:50,479 --> 00:06:52,400
scheme so the one we implement requires

194
00:06:52,160 --> 00:06:55,120
the

195
00:06:52,400 --> 00:06:55,758
hardness of discrete logarithms i see

196
00:06:55,120 --> 00:06:58,080
but it's

197
00:06:55,759 --> 00:06:59,280
not difficult to to implement it using

198
00:06:58,080 --> 00:07:00,639
other

199
00:06:59,280 --> 00:07:03,840
constructions possibly from other

200
00:07:00,639 --> 00:07:03,840
assumptions yes

201
00:07:07,599 --> 00:07:11,360
i have another question actually two

202
00:07:09,840 --> 00:07:13,280
questions

203
00:07:11,360 --> 00:07:15,759
the first one is about the times of the

204
00:07:13,280 --> 00:07:17,039
implementation that you reported

205
00:07:15,759 --> 00:07:19,280
looking at the table they seem

206
00:07:17,039 --> 00:07:22,080
fantastically faster than other

207
00:07:19,280 --> 00:07:23,359
solutions do you have an explanation to

208
00:07:22,080 --> 00:07:25,680
that

209
00:07:23,360 --> 00:07:27,520
oh so so i could repeat the question so

210
00:07:25,680 --> 00:07:29,360
so the times that you reported for your

211
00:07:27,520 --> 00:07:32,479
proofs for spartan

212
00:07:29,360 --> 00:07:35,599
the orders of magnitude faster

213
00:07:32,479 --> 00:07:36,639
than all of the other proofs yes you

214
00:07:35,599 --> 00:07:39,759
have an explanation

215
00:07:36,639 --> 00:07:40,400
how could this be possibly true yeah

216
00:07:39,759 --> 00:07:43,120
yeah so

217
00:07:40,400 --> 00:07:44,080
um so spartan relies on the subject

218
00:07:43,120 --> 00:07:46,639
protocol which is

219
00:07:44,080 --> 00:07:48,240
a lot of the work happens with the

220
00:07:46,639 --> 00:07:50,800
scalar arithmetic rather than

221
00:07:48,240 --> 00:07:52,160
cryptographic work so uh the amount of

222
00:07:50,800 --> 00:07:54,479
cryptographic work that

223
00:07:52,160 --> 00:07:56,240
sparta needs is much less than many of

224
00:07:54,479 --> 00:07:59,520
the existing schemes so

225
00:07:56,240 --> 00:08:01,759
so it can for instance starks that rely

226
00:07:59,520 --> 00:08:03,599
they rely on pcps but they do rely on

227
00:08:01,759 --> 00:08:06,000
symmetrically crypto

228
00:08:03,599 --> 00:08:07,120
yes yes yes crystallography is not so

229
00:08:06,000 --> 00:08:08,720
expensive and

230
00:08:07,120 --> 00:08:10,240
it seems like they reported numbers

231
00:08:08,720 --> 00:08:13,440
they're much bigger

232
00:08:10,240 --> 00:08:14,000
yes yes so uh for compared to stocks so

233
00:08:13,440 --> 00:08:16,560
one one

234
00:08:14,000 --> 00:08:17,280
um difficulty with stocks is even though

235
00:08:16,560 --> 00:08:19,440
the

236
00:08:17,280 --> 00:08:21,359
the most primitive operation is very

237
00:08:19,440 --> 00:08:24,400
efficient uh it needs to do a

238
00:08:21,360 --> 00:08:26,879
lot more of those operations so overall

239
00:08:24,400 --> 00:08:28,799
and it also requires repetitions to it

240
00:08:26,879 --> 00:08:31,440
this boosts the soundness error

241
00:08:28,800 --> 00:08:32,479
uh so if you count the end-to-end cause

242
00:08:31,440 --> 00:08:35,838
it turns out it

243
00:08:32,479 --> 00:08:35,839
it requires more work

244
00:08:36,399 --> 00:08:42,880
okay thank you thank you very much okay

245
00:08:39,200 --> 00:08:42,880
so tamara you're the next speaker

246
00:08:43,039 --> 00:08:46,399
do you want to share the screen

247
00:08:47,519 --> 00:08:49,920
thank you

248
00:08:50,800 --> 00:08:57,839
yeah can you hear me now um yes

249
00:08:55,360 --> 00:08:58,480
so let's wait a half a minute so that we

250
00:08:57,839 --> 00:09:09,839
are

251
00:08:58,480 --> 00:09:09,839
on time

252
00:09:31,279 --> 00:09:40,160
okay so ernest

253
00:09:37,040 --> 00:09:42,640
our next talk is titled nist from lpn

254
00:09:40,160 --> 00:09:44,399
and trapped or hash via correlation

255
00:09:42,640 --> 00:09:45,279
interactability for approximable

256
00:09:44,399 --> 00:09:47,600
relation

257
00:09:45,279 --> 00:09:50,959
to paper by cerica bagelski even

258
00:09:47,600 --> 00:09:50,959
catacopula and tamirmo

259
00:09:55,920 --> 00:10:00,160
okay so let's start so yeah so i'm going

260
00:09:58,800 --> 00:10:00,800
to talk about our paper where we

261
00:10:00,160 --> 00:10:02,079
construct

262
00:10:00,800 --> 00:10:05,040
a non-interactive zero knowledge

263
00:10:02,079 --> 00:10:08,079
protocol based on trebler hash and lpn

264
00:10:05,040 --> 00:10:08,560
and since we know how to get a trapdoor

265
00:10:08,079 --> 00:10:12,000
hatch

266
00:10:08,560 --> 00:10:13,518
based on the ddh assumption then

267
00:10:12,000 --> 00:10:15,040
one of the consequences is the first

268
00:10:13,519 --> 00:10:17,760
music under

269
00:10:15,040 --> 00:10:20,000
both lpn and ddh combined so this is a

270
00:10:17,760 --> 00:10:21,360
joint work with spika and venkata

271
00:10:20,000 --> 00:10:23,279
so let's first recall what uh

272
00:10:21,360 --> 00:10:24,640
non-interactive zero knowledge for an np

273
00:10:23,279 --> 00:10:26,959
language l

274
00:10:24,640 --> 00:10:28,560
uh it's simply a zero knowledge uh proof

275
00:10:26,959 --> 00:10:29,680
system which is not interactive so it

276
00:10:28,560 --> 00:10:31,279
has only one message

277
00:10:29,680 --> 00:10:33,439
and we know that we can get physics for

278
00:10:31,279 --> 00:10:36,800
np only in the crs model so we're going

279
00:10:33,440 --> 00:10:38,720
to assume the existence of a crs

280
00:10:36,800 --> 00:10:41,519
so nazix are very powerful they have

281
00:10:38,720 --> 00:10:43,760
lots of nice applications in crypto

282
00:10:41,519 --> 00:10:45,200
but they are known to be constructed

283
00:10:43,760 --> 00:10:47,439
only under a

284
00:10:45,200 --> 00:10:49,920
limited set of standard assumptions that

285
00:10:47,440 --> 00:10:52,399
include a particular lwe of pairing

286
00:10:49,920 --> 00:10:53,360
and effecting related assumptions and

287
00:10:52,399 --> 00:10:55,040
like i said

288
00:10:53,360 --> 00:10:56,399
in our paper we show the first music

289
00:10:55,040 --> 00:10:59,599
under both

290
00:10:56,399 --> 00:11:02,000
and ddh so the way we get in

291
00:10:59,600 --> 00:11:03,360
is through the uh general paradigm of

292
00:11:02,000 --> 00:11:05,040
the future maintenance form

293
00:11:03,360 --> 00:11:06,640
so we start with a three message a

294
00:11:05,040 --> 00:11:07,760
public coin zero knowledge protocol

295
00:11:06,640 --> 00:11:10,160
which is interactive

296
00:11:07,760 --> 00:11:11,040
and we use a hash function uh to remove

297
00:11:10,160 --> 00:11:13,040
the interaction

298
00:11:11,040 --> 00:11:14,800
from that protocol so more specifically

299
00:11:13,040 --> 00:11:18,000
instead of letting the verifier

300
00:11:14,800 --> 00:11:19,599
sam build and send uh his challenge

301
00:11:18,000 --> 00:11:21,760
we let the prover compute the very first

302
00:11:19,600 --> 00:11:23,040
challenge uh using the hash function

303
00:11:21,760 --> 00:11:24,480
so the very first challenge in the

304
00:11:23,040 --> 00:11:26,000
non-interactive protocol is simply the

305
00:11:24,480 --> 00:11:28,079
hash function applied on the

306
00:11:26,000 --> 00:11:29,200
rubric's first message uh using a hash

307
00:11:28,079 --> 00:11:32,560
key that we sample

308
00:11:29,200 --> 00:11:34,160
in the crs um so we know that the

309
00:11:32,560 --> 00:11:35,839
vehicle may transform preserves both

310
00:11:34,160 --> 00:11:37,360
completeness and zero knowledge but it's

311
00:11:35,839 --> 00:11:39,120
not clear that we get a

312
00:11:37,360 --> 00:11:41,120
sound protocol even if we start with the

313
00:11:39,120 --> 00:11:42,800
sound based protocol

314
00:11:41,120 --> 00:11:44,880
and the way we usually claim soundness

315
00:11:42,800 --> 00:11:46,640
of fiat chamier is by saying that it's

316
00:11:44,880 --> 00:11:47,360
computationally hard for a cheating

317
00:11:46,640 --> 00:11:50,480
proverb

318
00:11:47,360 --> 00:11:52,240
to find a first message a such that h of

319
00:11:50,480 --> 00:11:53,120
a which is essentially the very first

320
00:11:52,240 --> 00:11:55,839
challenge

321
00:11:53,120 --> 00:11:56,160
uh is a bad challenge and by by that i

322
00:11:55,839 --> 00:11:58,320
mean

323
00:11:56,160 --> 00:11:59,839
a challenge that may possibly allow each

324
00:11:58,320 --> 00:12:02,079
improver to cheat

325
00:11:59,839 --> 00:12:03,600
so it's bad for the verifier and more

326
00:12:02,079 --> 00:12:04,638
generally we can consider the notion

327
00:12:03,600 --> 00:12:05,760
which is called correlation

328
00:12:04,639 --> 00:12:09,120
interactability

329
00:12:05,760 --> 00:12:11,360
so a correlation exactly bill has h uh

330
00:12:09,120 --> 00:12:12,480
is a hash family where it's hard to find

331
00:12:11,360 --> 00:12:14,800
an input a

332
00:12:12,480 --> 00:12:15,839
such that a and h of a satisfies some

333
00:12:14,800 --> 00:12:17,439
general relation

334
00:12:15,839 --> 00:12:19,040
so the relation we're going to consider

335
00:12:17,440 --> 00:12:19,600
here for this x is the bad challenge

336
00:12:19,040 --> 00:12:21,519
relation

337
00:12:19,600 --> 00:12:24,240
that relates any first message with the

338
00:12:21,519 --> 00:12:27,120
set of bad challenges cool

339
00:12:24,240 --> 00:12:28,399
so in order to uh draw the outline of

340
00:12:27,120 --> 00:12:29,839
our contribution i'm actually going to

341
00:12:28,399 --> 00:12:33,680
start with imperial work

342
00:12:29,839 --> 00:12:36,720
so in last crypto biker show how to take

343
00:12:33,680 --> 00:12:39,040
a cryptographic primitive

344
00:12:36,720 --> 00:12:39,839
that enjoys some homomorphism for a

345
00:12:39,040 --> 00:12:42,480
function class

346
00:12:39,839 --> 00:12:44,639
f and construct correlation flexibility

347
00:12:42,480 --> 00:12:45,920
for all relations that are searchable by

348
00:12:44,639 --> 00:12:48,160
the function class f

349
00:12:45,920 --> 00:12:49,519
and by that i mean that if we take any

350
00:12:48,160 --> 00:12:52,079
function in the class

351
00:12:49,519 --> 00:12:52,880
small f then it's hard to find an input

352
00:12:52,079 --> 00:12:56,160
x such that

353
00:12:52,880 --> 00:12:57,920
h of x and f x are equal

354
00:12:56,160 --> 00:12:59,279
and they use the observation that the

355
00:12:57,920 --> 00:13:00,319
bad challenge function for some zero

356
00:12:59,279 --> 00:13:02,639
knowledge protocol

357
00:13:00,320 --> 00:13:04,399
is unique and is efficiently computable

358
00:13:02,639 --> 00:13:05,600
and this allows us to focus on the

359
00:13:04,399 --> 00:13:08,240
function class of

360
00:13:05,600 --> 00:13:10,399
efficiently computable functions so we

361
00:13:08,240 --> 00:13:12,560
know that we can uh so yeah so in

362
00:13:10,399 --> 00:13:13,680
in this picture this f of x is our bad

363
00:13:12,560 --> 00:13:17,040
challenge

364
00:13:13,680 --> 00:13:19,760
so using this observation we know that

365
00:13:17,040 --> 00:13:21,040
uh we get homomorphism for all official

366
00:13:19,760 --> 00:13:23,680
computable functions under

367
00:13:21,040 --> 00:13:24,719
lwe so this is simply a fully follow

368
00:13:23,680 --> 00:13:26,000
morphism

369
00:13:24,720 --> 00:13:27,279
uh and therefore we get correlation

370
00:13:26,000 --> 00:13:29,360
adaptability for all efficiently

371
00:13:27,279 --> 00:13:30,480
computable relations in particular our

372
00:13:29,360 --> 00:13:33,600
bad challenge function

373
00:13:30,480 --> 00:13:35,760
and therefore we get musics on the lwe

374
00:13:33,600 --> 00:13:37,440
cool so what we do differently is we

375
00:13:35,760 --> 00:13:39,680
observe that if we start with

376
00:13:37,440 --> 00:13:41,199
homomorphic primitives that further

377
00:13:39,680 --> 00:13:44,000
enjoy some very nice

378
00:13:41,199 --> 00:13:45,359
and useful structure then we can get a

379
00:13:44,000 --> 00:13:47,279
stronger correlation attractability

380
00:13:45,360 --> 00:13:50,000
guarantees

381
00:13:47,279 --> 00:13:51,199
so uh in particular we we get a hash

382
00:13:50,000 --> 00:13:54,399
family where it's hard

383
00:13:51,199 --> 00:13:56,880
for and for an adversary to find a an x

384
00:13:54,399 --> 00:13:58,560
such that h of x and f of x are even

385
00:13:56,880 --> 00:14:01,519
close to each other

386
00:13:58,560 --> 00:14:02,560
in hamming distance so uh this allows us

387
00:14:01,519 --> 00:14:04,959
to consider the

388
00:14:02,560 --> 00:14:05,920
approximation complexity of our target

389
00:14:04,959 --> 00:14:08,638
function the bad

390
00:14:05,920 --> 00:14:08,959
challenge function um and we observe

391
00:14:08,639 --> 00:14:10,560
that

392
00:14:08,959 --> 00:14:12,479
there is some zero knowledge protocol

393
00:14:10,560 --> 00:14:13,920
based on lpn where the batch range

394
00:14:12,480 --> 00:14:14,720
function can be probabilistically

395
00:14:13,920 --> 00:14:18,399
computable

396
00:14:14,720 --> 00:14:21,519
using constant degree polynomials and

397
00:14:18,399 --> 00:14:23,839
to formalize this a bit then

398
00:14:21,519 --> 00:14:25,040
we show that with probability all but

399
00:14:23,839 --> 00:14:27,440
negligible

400
00:14:25,040 --> 00:14:28,959
uh our bad challenge function falls

401
00:14:27,440 --> 00:14:30,959
inside the hamming ball

402
00:14:28,959 --> 00:14:32,000
of an evaluation of a constant degree

403
00:14:30,959 --> 00:14:34,079
polynomial

404
00:14:32,000 --> 00:14:35,199
over x so we sample the constant degree

405
00:14:34,079 --> 00:14:36,880
polynomial from something

406
00:14:35,199 --> 00:14:39,439
distribution and with overwhelming

407
00:14:36,880 --> 00:14:42,720
probability our bad challenge

408
00:14:39,440 --> 00:14:45,040
is inside this hamming ball um

409
00:14:42,720 --> 00:14:47,279
and this means that uh correlation uh

410
00:14:45,040 --> 00:14:49,120
interactability against uh

411
00:14:47,279 --> 00:14:50,720
relations approximately by a constant

412
00:14:49,120 --> 00:14:51,600
degree polynomials is sufficient for

413
00:14:50,720 --> 00:14:54,720
music

414
00:14:51,600 --> 00:14:56,639
uh and we show that uh uh our

415
00:14:54,720 --> 00:14:57,760
well-structured homomorphism requirement

416
00:14:56,639 --> 00:15:00,079
is satisfied by

417
00:14:57,760 --> 00:15:02,399
by an abstraction called trapdoor hash

418
00:15:00,079 --> 00:15:04,959
which can be instantiated under ddh

419
00:15:02,399 --> 00:15:05,839
and therefore combining lpn and ddh uh

420
00:15:04,959 --> 00:15:09,119
we get

421
00:15:05,839 --> 00:15:10,000
nizix following this out so let me

422
00:15:09,120 --> 00:15:12,560
conclude uh

423
00:15:10,000 --> 00:15:14,240
uh with a real quick discussion so we

424
00:15:12,560 --> 00:15:15,599
introduced this new notion of uh

425
00:15:14,240 --> 00:15:17,120
correlation detectability for

426
00:15:15,600 --> 00:15:19,199
approximate relations

427
00:15:17,120 --> 00:15:20,800
and so it basically says that it's hard

428
00:15:19,199 --> 00:15:23,599
for anniversary to find

429
00:15:20,800 --> 00:15:24,079
uh an input x such that h of x and some

430
00:15:23,600 --> 00:15:27,120
function

431
00:15:24,079 --> 00:15:29,758
our target class uh uh

432
00:15:27,120 --> 00:15:30,959
f so that h of s and f x are close to

433
00:15:29,759 --> 00:15:32,560
each other

434
00:15:30,959 --> 00:15:34,959
and like i said this allows us to

435
00:15:32,560 --> 00:15:35,359
consider uh the approximation complexity

436
00:15:34,959 --> 00:15:37,279
of

437
00:15:35,360 --> 00:15:38,959
our target class which is usually weaker

438
00:15:37,279 --> 00:15:42,480
than the exact complexity

439
00:15:38,959 --> 00:15:42,880
uh and following this we get a physics

440
00:15:42,480 --> 00:15:45,360
under

441
00:15:42,880 --> 00:15:46,800
a new standard assumptions but it's very

442
00:15:45,360 --> 00:15:48,399
natural to ask whether there are more

443
00:15:46,800 --> 00:15:50,160
applications of this notion

444
00:15:48,399 --> 00:15:51,519
and one reason to believe that uh

445
00:15:50,160 --> 00:15:53,519
there's some potential there

446
00:15:51,519 --> 00:15:54,800
is because this uh notion of question

447
00:15:53,519 --> 00:15:57,920
inductability

448
00:15:54,800 --> 00:15:58,399
it relates between an input x and a set

449
00:15:57,920 --> 00:16:00,560
of

450
00:15:58,399 --> 00:16:02,000
outputs which is in in this case the

451
00:16:00,560 --> 00:16:04,800
hamming ball around some

452
00:16:02,000 --> 00:16:06,639
f of x rather than an input x with and a

453
00:16:04,800 --> 00:16:09,680
unique output

454
00:16:06,639 --> 00:16:10,079
similarly to the uh uh very recent works

455
00:16:09,680 --> 00:16:12,638
that

456
00:16:10,079 --> 00:16:13,120
got physics understands assumptions uh

457
00:16:12,639 --> 00:16:18,079
cool

458
00:16:13,120 --> 00:16:18,079
uh that's it thanks thank you very much

459
00:16:19,519 --> 00:16:22,399
okay thank you thanks tamara for the

460
00:16:20,880 --> 00:16:22,959
talk i actually have a few questions for

461
00:16:22,399 --> 00:16:26,320
you

462
00:16:22,959 --> 00:16:28,719
but i'm going to let the audience ask if

463
00:16:26,320 --> 00:16:28,720
they have it

464
00:16:34,079 --> 00:16:38,239
by the way if you have questions that

465
00:16:35,440 --> 00:16:41,120
you want to ask later it's also possible

466
00:16:38,240 --> 00:16:42,399
so yes you can either go on the zulip

467
00:16:41,120 --> 00:16:46,399
chat or

468
00:16:42,399 --> 00:16:48,959
write them here um okay so

469
00:16:46,399 --> 00:16:50,399
so maybe let me let me start um you

470
00:16:48,959 --> 00:16:53,599
mentioned lpn what's the

471
00:16:50,399 --> 00:16:55,199
what's the noise regime that that you

472
00:16:53,600 --> 00:16:56,959
need in order to instantiate

473
00:16:55,199 --> 00:16:58,560
we need the low noise we need uh

474
00:16:56,959 --> 00:17:05,839
something around one over square root

475
00:16:58,560 --> 00:17:05,839
of dimensions not enough

476
00:17:25,839 --> 00:17:29,438
okay so julia

477
00:17:30,400 --> 00:17:34,720
okay so we can move to the next

478
00:17:35,120 --> 00:17:40,080
talk thank you

479
00:17:40,880 --> 00:17:44,559
dominic can you share the screen

480
00:17:45,039 --> 00:17:50,160
okay so the next talk is titled shorter

481
00:17:48,320 --> 00:17:52,399
non-interactive zero knowledge arguments

482
00:17:50,160 --> 00:17:54,799
and zaps for algebraic languages by

483
00:17:52,400 --> 00:17:55,600
jeffrey and dominique hartmann and

484
00:17:54,799 --> 00:17:58,960
dominic

485
00:17:55,600 --> 00:17:59,760
will give the talk okay thanks for the

486
00:17:58,960 --> 00:18:02,559
introduction

487
00:17:59,760 --> 00:18:04,080
yeah as the title said um i'll talk

488
00:18:02,559 --> 00:18:05,280
about non-interactive zero knowledge

489
00:18:04,080 --> 00:18:08,320
arguments

490
00:18:05,280 --> 00:18:10,240
and um so we've seen the setup before

491
00:18:08,320 --> 00:18:12,240
but let me briefly recap it

492
00:18:10,240 --> 00:18:13,280
we have alice who wants to convince bob

493
00:18:12,240 --> 00:18:15,840
of some statement

494
00:18:13,280 --> 00:18:17,520
but alice does not want to reveal her

495
00:18:15,840 --> 00:18:18,080
secret witness so we want zero knowledge

496
00:18:17,520 --> 00:18:20,639
proofs

497
00:18:18,080 --> 00:18:22,000
and there are two broad types

498
00:18:20,640 --> 00:18:23,520
interactive protocols

499
00:18:22,000 --> 00:18:25,679
like sigma protocols as we've seen in

500
00:18:23,520 --> 00:18:28,480
the talk before where alice and bob

501
00:18:25,679 --> 00:18:30,160
exchange multiple messages and these

502
00:18:28,480 --> 00:18:31,039
protocols are often really simple and

503
00:18:30,160 --> 00:18:33,679
well understood

504
00:18:31,039 --> 00:18:35,200
but have the disadvantage that both

505
00:18:33,679 --> 00:18:36,320
parties have to wait for the other

506
00:18:35,200 --> 00:18:38,559
person's messages

507
00:18:36,320 --> 00:18:40,720
and they are also non-transferable so in

508
00:18:38,559 --> 00:18:41,600
many cases we require non-interactive

509
00:18:40,720 --> 00:18:43,520
zero knowledge

510
00:18:41,600 --> 00:18:45,199
where alice can simply send a single

511
00:18:43,520 --> 00:18:47,120
message

512
00:18:45,200 --> 00:18:48,880
but then we require additional setup

513
00:18:47,120 --> 00:18:51,678
like a common reference string

514
00:18:48,880 --> 00:18:52,880
or the random oracle model and

515
00:18:51,679 --> 00:18:54,720
additionally they are often

516
00:18:52,880 --> 00:18:56,080
computationally more expensive than

517
00:18:54,720 --> 00:18:58,880
interactive proofs

518
00:18:56,080 --> 00:19:00,159
so there's a bit of a balance between

519
00:18:58,880 --> 00:19:03,200
between the two

520
00:19:00,160 --> 00:19:06,480
so we introduce a new

521
00:19:03,200 --> 00:19:07,200
way to build nizex but let me first

522
00:19:06,480 --> 00:19:09,360
recap some

523
00:19:07,200 --> 00:19:11,200
existing constructions and why we need

524
00:19:09,360 --> 00:19:13,360
another one

525
00:19:11,200 --> 00:19:14,640
so we've seen in in the last talk um the

526
00:19:13,360 --> 00:19:16,479
future transformation

527
00:19:14,640 --> 00:19:17,919
which takes an interactive protocol and

528
00:19:16,480 --> 00:19:20,799
compiles it into a

529
00:19:17,919 --> 00:19:22,960
music using the random oracle model and

530
00:19:20,799 --> 00:19:26,080
this yields very efficient proofs for

531
00:19:22,960 --> 00:19:28,000
many languages and if we assume the

532
00:19:26,080 --> 00:19:30,480
random oracle we can reduce everything

533
00:19:28,000 --> 00:19:31,440
to the security of the underlying sitcom

534
00:19:30,480 --> 00:19:34,240
protocol

535
00:19:31,440 --> 00:19:35,039
but the random oracle is a huge drawback

536
00:19:34,240 --> 00:19:36,720
because

537
00:19:35,039 --> 00:19:38,559
real hash functions simply aren't random

538
00:19:36,720 --> 00:19:40,320
oracles so we would like to avoid them

539
00:19:38,559 --> 00:19:43,280
if we can

540
00:19:40,320 --> 00:19:45,039
another method for constructing physics

541
00:19:43,280 --> 00:19:46,879
is the gross high methodology which uses

542
00:19:45,039 --> 00:19:48,400
pairings and can prove statements over

543
00:19:46,880 --> 00:19:49,919
pairing product equations

544
00:19:48,400 --> 00:19:51,600
under standard assumptions in the

545
00:19:49,919 --> 00:19:55,039
standard model but is

546
00:19:51,600 --> 00:19:56,959
way less efficient than future meal

547
00:19:55,039 --> 00:19:59,440
proofs

548
00:19:56,960 --> 00:20:00,240
and a third line of work is so-called

549
00:19:59,440 --> 00:20:03,760
quasi-adaptive

550
00:20:00,240 --> 00:20:04,799
musics which are also possible in the

551
00:20:03,760 --> 00:20:06,320
standard model under standard

552
00:20:04,799 --> 00:20:08,400
assumptions but only for the class of

553
00:20:06,320 --> 00:20:10,000
linear languages which is

554
00:20:08,400 --> 00:20:12,320
a lot smaller than pairing product

555
00:20:10,000 --> 00:20:15,679
equations or even np

556
00:20:12,320 --> 00:20:16,399
so the question is can we find a proof

557
00:20:15,679 --> 00:20:19,679
system

558
00:20:16,400 --> 00:20:21,360
which is as easy and and efficient as

559
00:20:19,679 --> 00:20:23,280
the future here transformation

560
00:20:21,360 --> 00:20:24,639
but secure in the standard model under

561
00:20:23,280 --> 00:20:26,399
some standard assumption and

562
00:20:24,640 --> 00:20:27,840
has a full adaptive sound as a not only

563
00:20:26,400 --> 00:20:29,840
quasi-adaptive

564
00:20:27,840 --> 00:20:32,959
and in this paper we present a new

565
00:20:29,840 --> 00:20:35,039
compiler for sigma protocols to nizix

566
00:20:32,960 --> 00:20:36,240
which does not require random oracles in

567
00:20:35,039 --> 00:20:38,720
the security proof

568
00:20:36,240 --> 00:20:40,720
and works for algebraic languages the

569
00:20:38,720 --> 00:20:41,600
efficiency is almost as good as the vhm

570
00:20:40,720 --> 00:20:45,280
transformation

571
00:20:41,600 --> 00:20:47,439
and it is also fully adaptively sound

572
00:20:45,280 --> 00:20:48,639
but has the downside that we require a

573
00:20:47,440 --> 00:20:50,480
new assumption

574
00:20:48,640 --> 00:20:51,679
which we call the extended kernel matrix

575
00:20:50,480 --> 00:20:53,440
difficult assumption

576
00:20:51,679 --> 00:20:55,280
which as the name suggests is an

577
00:20:53,440 --> 00:20:58,480
extension of the

578
00:20:55,280 --> 00:21:00,720
kernel matrix if you have an assumption

579
00:20:58,480 --> 00:21:02,080
so how does our construction look it's

580
00:21:00,720 --> 00:21:03,919
actually pretty simple we start

581
00:21:02,080 --> 00:21:05,280
from a sigma protocol so a three move

582
00:21:03,919 --> 00:21:07,840
public coin interactive

583
00:21:05,280 --> 00:21:08,639
protocol and we want to remove the

584
00:21:07,840 --> 00:21:12,000
interaction

585
00:21:08,640 --> 00:21:13,679
so the message e from the verifier um

586
00:21:12,000 --> 00:21:15,600
and we can't use hash functions since

587
00:21:13,679 --> 00:21:16,559
then we would likely need random oracles

588
00:21:15,600 --> 00:21:18,000
again

589
00:21:16,559 --> 00:21:19,760
so we want to give it as the common

590
00:21:18,000 --> 00:21:20,640
reference string but we can't give it in

591
00:21:19,760 --> 00:21:23,520
the clear

592
00:21:20,640 --> 00:21:24,559
so instead we hide it in the exponent of

593
00:21:23,520 --> 00:21:27,600
a group but not

594
00:21:24,559 --> 00:21:28,080
the same as the language but in a second

595
00:21:27,600 --> 00:21:29,760
group

596
00:21:28,080 --> 00:21:31,840
so we move to a pairing group setting

597
00:21:29,760 --> 00:21:33,520
with asymmetric pairings between g1 and

598
00:21:31,840 --> 00:21:35,760
g2

599
00:21:33,520 --> 00:21:37,520
and hide e in the exponent of the second

600
00:21:35,760 --> 00:21:40,000
group while the language still remains

601
00:21:37,520 --> 00:21:42,080
in the first group now of course the

602
00:21:40,000 --> 00:21:43,520
second flow of the prover has to move to

603
00:21:42,080 --> 00:21:45,360
group g2 as well

604
00:21:43,520 --> 00:21:47,280
but similarly to the fiatumu

605
00:21:45,360 --> 00:21:47,760
transformation soundness and zero

606
00:21:47,280 --> 00:21:49,200
knowledge

607
00:21:47,760 --> 00:21:52,240
directly adapts from the underlying

608
00:21:49,200 --> 00:21:54,720
protocol but now instead of

609
00:21:52,240 --> 00:21:56,400
hashes we have pairings which is why

610
00:21:54,720 --> 00:21:57,600
this is not as efficient as the hme

611
00:21:56,400 --> 00:21:58,880
transformation since pairings are

612
00:21:57,600 --> 00:22:00,719
expensive

613
00:21:58,880 --> 00:22:02,400
now the interesting questions are for

614
00:22:00,720 --> 00:22:05,120
which languages does this actually work

615
00:22:02,400 --> 00:22:06,880
and why would this be sound

616
00:22:05,120 --> 00:22:08,879
and for soundness the intuition is that

617
00:22:06,880 --> 00:22:09,679
since the challenge is hidden in a

618
00:22:08,880 --> 00:22:12,320
different group

619
00:22:09,679 --> 00:22:13,440
than the statement and the first flow it

620
00:22:12,320 --> 00:22:16,879
should be difficult

621
00:22:13,440 --> 00:22:18,559
to use it in any way to to cheat in the

622
00:22:16,880 --> 00:22:21,280
protocol

623
00:22:18,559 --> 00:22:22,240
and this also limits what languages we

624
00:22:21,280 --> 00:22:25,678
can prove

625
00:22:22,240 --> 00:22:28,080
statements about because

626
00:22:25,679 --> 00:22:29,440
in inherently if we want to exploit that

627
00:22:28,080 --> 00:22:30,480
the challenge and the language are in

628
00:22:29,440 --> 00:22:32,720
different groups

629
00:22:30,480 --> 00:22:34,240
then of course our language can't spend

630
00:22:32,720 --> 00:22:35,679
both pairing groups or even the target

631
00:22:34,240 --> 00:22:37,679
groups so something like pairing product

632
00:22:35,679 --> 00:22:39,760
equations is quite unlikely

633
00:22:37,679 --> 00:22:41,760
and so the best we can currently do are

634
00:22:39,760 --> 00:22:44,559
algebraic languages which only live over

635
00:22:41,760 --> 00:22:44,559
a single group

636
00:22:44,880 --> 00:22:48,159
and what can we do with this

637
00:22:46,320 --> 00:22:49,600
construction we can

638
00:22:48,159 --> 00:22:51,520
actually construct ore proofs for

639
00:22:49,600 --> 00:22:52,320
example for the ddh language which which

640
00:22:51,520 --> 00:22:56,960
is actually

641
00:22:52,320 --> 00:22:56,960
used in in many schemes and

642
00:22:57,120 --> 00:23:01,199
currently the ddh proofs in many schemes

643
00:22:59,840 --> 00:23:03,120
are the gross high proofs

644
00:23:01,200 --> 00:23:04,400
which require 10 group elements and 24

645
00:23:03,120 --> 00:23:07,520
pairings while we only

646
00:23:04,400 --> 00:23:08,960
need 7 group elements and 12 pairings

647
00:23:07,520 --> 00:23:10,720
of course this comes at the cost of

648
00:23:08,960 --> 00:23:12,240
assuming our new assumption

649
00:23:10,720 --> 00:23:14,480
and we also require witness sample

650
00:23:12,240 --> 00:23:16,480
ability for the languages

651
00:23:14,480 --> 00:23:18,720
which i certainly don't have the time to

652
00:23:16,480 --> 00:23:21,440
to define for this you'll have to

653
00:23:18,720 --> 00:23:22,080
look at the paper or the longer version

654
00:23:21,440 --> 00:23:24,320
but also

655
00:23:22,080 --> 00:23:25,600
our proofs are also asymptotically

656
00:23:24,320 --> 00:23:27,678
shorter and faster

657
00:23:25,600 --> 00:23:28,799
than grosser high proofs and some of the

658
00:23:27,679 --> 00:23:30,159
applications that i mentioned

659
00:23:28,799 --> 00:23:31,679
are for example tightly secure

660
00:23:30,159 --> 00:23:33,679
structure-preserving signatures

661
00:23:31,679 --> 00:23:36,320
simulation sound quartz adaptive musics

662
00:23:33,679 --> 00:23:37,039
ring signatures and many more and since

663
00:23:36,320 --> 00:23:38,639
the

664
00:23:37,039 --> 00:23:40,240
proofs are often a big part of these

665
00:23:38,640 --> 00:23:42,080
protocols we can save

666
00:23:40,240 --> 00:23:43,840
significant space and time with our

667
00:23:42,080 --> 00:23:45,840
construction

668
00:23:43,840 --> 00:23:48,080
additionally to the music arguments as

669
00:23:45,840 --> 00:23:50,639
the title says we also get statistical

670
00:23:48,080 --> 00:23:53,360
zaps for algebraic languages

671
00:23:50,640 --> 00:23:54,080
and using the randomization techniques

672
00:23:53,360 --> 00:23:55,039
also

673
00:23:54,080 --> 00:23:57,600
non-interactive witness

674
00:23:55,039 --> 00:23:59,200
indistinguishable proofs and also

675
00:23:57,600 --> 00:24:00,799
non-interactive zero knowledge proofs

676
00:23:59,200 --> 00:24:02,559
for algebraic languages under the

677
00:24:00,799 --> 00:24:04,639
standard ddh assumption

678
00:24:02,559 --> 00:24:06,399
but those don't improve over gross high

679
00:24:04,640 --> 00:24:09,039
proofs so they are

680
00:24:06,400 --> 00:24:10,400
nice to have but not as interesting and

681
00:24:09,039 --> 00:24:11,200
if you want to read the full version

682
00:24:10,400 --> 00:24:13,600
it's an eprint

683
00:24:11,200 --> 00:24:14,880
and you can also watch the long talk and

684
00:24:13,600 --> 00:24:15,439
if you have any questions i gladly

685
00:24:14,880 --> 00:24:18,640
answer them

686
00:24:15,440 --> 00:24:21,120
thank you thank you very much dominic

687
00:24:18,640 --> 00:24:21,120
for the talk

688
00:24:21,679 --> 00:24:32,000
thank you for the talk um let's see if

689
00:24:24,159 --> 00:24:34,400
there are some questions

690
00:24:32,000 --> 00:24:35,360
there's a question on zulip and

691
00:24:34,400 --> 00:24:38,080
predictor car

692
00:24:35,360 --> 00:24:40,559
asks what is the cost of obtaining proof

693
00:24:38,080 --> 00:24:44,320
of knowledge

694
00:24:40,559 --> 00:24:47,600
um proof of knowledge

695
00:24:44,320 --> 00:24:49,439
is quite hard because uh or is is

696
00:24:47,600 --> 00:24:52,158
unlikely to to get here

697
00:24:49,440 --> 00:24:53,919
because um we basically talk about

698
00:24:52,159 --> 00:24:57,039
relations between exponents

699
00:24:53,919 --> 00:24:58,640
and not um between group elements so um

700
00:24:57,039 --> 00:25:15,840
proof of knowledge we don't know how to

701
00:24:58,640 --> 00:25:15,840
achieve those with our framework

702
00:25:20,159 --> 00:25:23,840
uh there's a follow-up on your question

703
00:25:22,880 --> 00:25:26,559
as

704
00:25:23,840 --> 00:25:27,918
again by pratik he asks whether you can

705
00:25:26,559 --> 00:25:30,960
use the knowledge of hispanic

706
00:25:27,919 --> 00:25:30,960
assumptions to get it

707
00:25:31,840 --> 00:25:36,320
maybe actually we didn't really think

708
00:25:34,799 --> 00:25:37,760
about that because our goal was

709
00:25:36,320 --> 00:25:40,000
explicitly to avoid

710
00:25:37,760 --> 00:25:41,360
strong knowledge type assumptions and

711
00:25:40,000 --> 00:25:43,200
get everything under falsifiable

712
00:25:41,360 --> 00:25:46,559
assumptions in the standard model

713
00:25:43,200 --> 00:25:48,159
so basically if we would then

714
00:25:46,559 --> 00:25:50,000
use knowledge of exponent assumptions

715
00:25:48,159 --> 00:25:50,880
and the like we could use snarks and

716
00:25:50,000 --> 00:25:52,880
then

717
00:25:50,880 --> 00:25:54,640
our construction itself would be kind of

718
00:25:52,880 --> 00:25:59,279
pointless because then we

719
00:25:54,640 --> 00:25:59,279
could get better efficiency as well so

720
00:26:03,039 --> 00:26:05,520
thank you

721
00:26:06,720 --> 00:26:11,279
um i believe we have a few more minutes

722
00:26:09,840 --> 00:26:13,600
if

723
00:26:11,279 --> 00:26:24,450
so if someone has more questions please

724
00:26:13,600 --> 00:26:26,959
speak up

725
00:26:24,450 --> 00:26:28,240
[Music]

726
00:26:26,960 --> 00:26:30,400
i don't see anything so we can maybe

727
00:26:28,240 --> 00:26:35,919
move to the next speaker

728
00:26:30,400 --> 00:26:35,919
okay so the next talk is titled order

729
00:26:36,840 --> 00:26:39,840
fairness

730
00:26:57,919 --> 00:27:01,919
ah i believe alon has lost his

731
00:27:00,799 --> 00:27:05,120
connection

732
00:27:01,919 --> 00:27:06,400
oh so i thought i froze sorry no you're

733
00:27:05,120 --> 00:27:10,799
good

734
00:27:06,400 --> 00:27:12,960
then let me take over um i'm back sorry

735
00:27:10,799 --> 00:27:14,400
okay alone please so julia didn't get

736
00:27:12,960 --> 00:27:17,840
into it already

737
00:27:14,400 --> 00:27:19,919
no i thought i froze myself so

738
00:27:17,840 --> 00:27:21,840
okay i'm back for some reason it's

739
00:27:19,919 --> 00:27:23,919
question so the next talk is

740
00:27:21,840 --> 00:27:27,678
titled order fairness for byzantine

741
00:27:23,919 --> 00:27:27,679
consensus and the speaker is

742
00:27:27,840 --> 00:27:37,600
it's a it's joint work with the

743
00:27:34,799 --> 00:27:40,158
phantom stephen goldfeather and the

744
00:27:37,600 --> 00:27:42,158
archers

745
00:27:40,159 --> 00:27:44,320
so thank you for the introduction hi

746
00:27:42,159 --> 00:27:45,440
everyone i'm a phd student at cornell

747
00:27:44,320 --> 00:27:47,200
and colonel tech

748
00:27:45,440 --> 00:27:49,279
and today i'll be talking about order

749
00:27:47,200 --> 00:27:50,880
fairness for byzantine consensus and

750
00:27:49,279 --> 00:27:53,279
this is joint work with other authors at

751
00:27:50,880 --> 00:27:55,440
kernel tech

752
00:27:53,279 --> 00:27:57,039
so briefly the abstraction of state

753
00:27:55,440 --> 00:27:58,080
machine replication or byzantine

754
00:27:57,039 --> 00:28:00,080
consensus

755
00:27:58,080 --> 00:28:01,760
can be used to build a linearly ordered

756
00:28:00,080 --> 00:28:03,760
log or a blockchain

757
00:28:01,760 --> 00:28:06,000
and there's broadly two properties that

758
00:28:03,760 --> 00:28:07,919
consensus protocols need to satisfy

759
00:28:06,000 --> 00:28:10,240
so the first is consistency which

760
00:28:07,919 --> 00:28:12,480
ensures that all the nodes have the same

761
00:28:10,240 --> 00:28:14,880
view of the linearly ordered log

762
00:28:12,480 --> 00:28:16,559
and the second is liveness which ensures

763
00:28:14,880 --> 00:28:18,240
that the system makes progress

764
00:28:16,559 --> 00:28:19,840
so basically the linearly ordered log

765
00:28:18,240 --> 00:28:22,480
grows

766
00:28:19,840 --> 00:28:24,720
but unfortunately neither consistency

767
00:28:22,480 --> 00:28:26,640
nor aliveness says anything about the

768
00:28:24,720 --> 00:28:27,600
actual ordering of transactions in the

769
00:28:26,640 --> 00:28:29,120
log

770
00:28:27,600 --> 00:28:31,039
so for example the consistency

771
00:28:29,120 --> 00:28:33,360
requirement can be met even

772
00:28:31,039 --> 00:28:34,640
if an adversarial node is able to choose

773
00:28:33,360 --> 00:28:37,678
the ordering

774
00:28:34,640 --> 00:28:38,399
for all of the transactions and as it

775
00:28:37,679 --> 00:28:41,360
turns out

776
00:28:38,399 --> 00:28:44,879
the transaction ordering is often very

777
00:28:41,360 --> 00:28:46,320
easy to manipulate in existing protocols

778
00:28:44,880 --> 00:28:48,240
so this brings us to the central

779
00:28:46,320 --> 00:28:49,279
question that we sort of try to answer

780
00:28:48,240 --> 00:28:52,080
in our paper

781
00:28:49,279 --> 00:28:52,960
of like why exactly is fair ordering so

782
00:28:52,080 --> 00:28:54,799
important

783
00:28:52,960 --> 00:28:56,240
so i'll briefly highlight two main

784
00:28:54,799 --> 00:28:58,158
motivations

785
00:28:56,240 --> 00:28:59,279
but please see our paper for the full

786
00:28:58,159 --> 00:29:01,200
details

787
00:28:59,279 --> 00:29:03,039
so the biggest motivator for order

788
00:29:01,200 --> 00:29:04,720
fairness is seen in the context of

789
00:29:03,039 --> 00:29:06,158
decentralized exchanges

790
00:29:04,720 --> 00:29:08,399
and here results could actually be

791
00:29:06,159 --> 00:29:10,240
catastrophic without fair ordering

792
00:29:08,399 --> 00:29:11,520
so there was this recent paper by phil

793
00:29:10,240 --> 00:29:14,640
diane and others at

794
00:29:11,520 --> 00:29:14,960
s p 2020 which showed the rampant rise

795
00:29:14,640 --> 00:29:17,120
of

796
00:29:14,960 --> 00:29:18,159
bots on the ethereum network which

797
00:29:17,120 --> 00:29:20,639
waited

798
00:29:18,159 --> 00:29:23,279
to make profits from unsuspecting users

799
00:29:20,640 --> 00:29:25,360
by manipulating the transaction ordering

800
00:29:23,279 --> 00:29:26,720
so this is not unlike high frequency

801
00:29:25,360 --> 00:29:28,479
trading on wall street

802
00:29:26,720 --> 00:29:30,720
which was popularized by this best

803
00:29:28,480 --> 00:29:32,720
seller expose flash boys

804
00:29:30,720 --> 00:29:34,399
so this was a time when firms built low

805
00:29:32,720 --> 00:29:35,279
latency channels to the new york stock

806
00:29:34,399 --> 00:29:37,600
exchange

807
00:29:35,279 --> 00:29:38,480
and capitalized on information asymmetry

808
00:29:37,600 --> 00:29:41,199
to seal

809
00:29:38,480 --> 00:29:42,799
small profits at a really large volume

810
00:29:41,200 --> 00:29:44,960
of transactions

811
00:29:42,799 --> 00:29:46,320
and blockchain exchanges aren't really

812
00:29:44,960 --> 00:29:48,720
as regulated as

813
00:29:46,320 --> 00:29:50,158
real-world exchanges so it's important

814
00:29:48,720 --> 00:29:54,080
to use cryptography to

815
00:29:50,159 --> 00:29:55,760
provably prevent order manipulation

816
00:29:54,080 --> 00:29:57,360
so there's definitely a lot of practical

817
00:29:55,760 --> 00:29:59,600
motivation for order fairness and i'm

818
00:29:57,360 --> 00:30:00,639
really only scratching the surface here

819
00:29:59,600 --> 00:30:02,480
but we think there's a strong

820
00:30:00,640 --> 00:30:04,000
theoretical motivation as well and i

821
00:30:02,480 --> 00:30:05,279
think for cryptographers that's equally

822
00:30:04,000 --> 00:30:07,520
important

823
00:30:05,279 --> 00:30:09,919
so order fairness as it turns out is a

824
00:30:07,520 --> 00:30:12,000
natural analog of the validity condition

825
00:30:09,919 --> 00:30:13,120
a closely related problem of byzantine

826
00:30:12,000 --> 00:30:14,880
agreement

827
00:30:13,120 --> 00:30:16,799
so basically the validity property says

828
00:30:14,880 --> 00:30:18,240
that if all honest nodes are input the

829
00:30:16,799 --> 00:30:20,320
same value v

830
00:30:18,240 --> 00:30:22,399
then all the honest nodes should output

831
00:30:20,320 --> 00:30:24,480
the same value v

832
00:30:22,399 --> 00:30:26,399
so analogously order fairness

833
00:30:24,480 --> 00:30:29,679
intuitively is the property that if all

834
00:30:26,399 --> 00:30:31,760
honest nodes are input m1 before m2

835
00:30:29,679 --> 00:30:33,600
then all honest nodes should agree to

836
00:30:31,760 --> 00:30:36,080
output m1 before m2

837
00:30:33,600 --> 00:30:39,199
and again this is not something that

838
00:30:36,080 --> 00:30:41,279
current protocols satisfy

839
00:30:39,200 --> 00:30:42,799
so we considered several definitions of

840
00:30:41,279 --> 00:30:44,080
order fairness in our paper

841
00:30:42,799 --> 00:30:46,559
and it turns out some of the most

842
00:30:44,080 --> 00:30:48,240
natural ones are impossible to achieve

843
00:30:46,559 --> 00:30:50,158
so here's the definition we settled on

844
00:30:48,240 --> 00:30:52,080
which we call block order fairness

845
00:30:50,159 --> 00:30:53,520
and this still maintains the sort of

846
00:30:52,080 --> 00:30:55,600
first and first style

847
00:30:53,520 --> 00:30:57,200
first and first out style of ordering

848
00:30:55,600 --> 00:30:58,320
but it is possible to achieve in

849
00:30:57,200 --> 00:31:00,799
practice

850
00:30:58,320 --> 00:31:02,399
so here we allow nodes to deliver m1 and

851
00:31:00,799 --> 00:31:04,879
m2 in the same block

852
00:31:02,399 --> 00:31:06,239
m1 just can't appear at a later index in

853
00:31:04,880 --> 00:31:09,360
the blockchain

854
00:31:06,240 --> 00:31:12,320
so i'll also emphasize that we make

855
00:31:09,360 --> 00:31:13,439
minimal use of this relaxation so our

856
00:31:12,320 --> 00:31:16,559
protocol will order

857
00:31:13,440 --> 00:31:18,640
m1 before m2 except when it can't due to

858
00:31:16,559 --> 00:31:20,240
an impossibility result

859
00:31:18,640 --> 00:31:22,080
we also parameterize the definition

860
00:31:20,240 --> 00:31:25,600
using an order fairness parameter

861
00:31:22,080 --> 00:31:26,399
gamma so from a purely definitional

862
00:31:25,600 --> 00:31:28,559
standpoint

863
00:31:26,399 --> 00:31:30,158
order fairness is strictly stronger than

864
00:31:28,559 --> 00:31:32,559
previously considered notions

865
00:31:30,159 --> 00:31:34,240
like censorship resistance or using a

866
00:31:32,559 --> 00:31:36,240
random leader election

867
00:31:34,240 --> 00:31:37,919
or using threshold encryption to hide

868
00:31:36,240 --> 00:31:40,880
the transaction contents

869
00:31:37,919 --> 00:31:40,880
before they're ordered

870
00:31:42,080 --> 00:31:46,559
so finally in our paper we construct a

871
00:31:44,880 --> 00:31:48,399
first fair ordering protocol

872
00:31:46,559 --> 00:31:50,720
iquitas which we named after the roman

873
00:31:48,399 --> 00:31:52,799
personification for fairness

874
00:31:50,720 --> 00:31:54,480
so very roughly the protocol will take

875
00:31:52,799 --> 00:31:56,480
place in three stages

876
00:31:54,480 --> 00:31:58,000
the gossip stage the agreement stage and

877
00:31:56,480 --> 00:31:59,600
the finalization stage

878
00:31:58,000 --> 00:32:01,200
and each of the transactions will go

879
00:31:59,600 --> 00:32:03,918
through these three stages

880
00:32:01,200 --> 00:32:04,720
before being output to the log so in the

881
00:32:03,919 --> 00:32:06,880
gossip stage

882
00:32:04,720 --> 00:32:08,720
each node will gossip its own local

883
00:32:06,880 --> 00:32:10,559
ordering of transactions as it's

884
00:32:08,720 --> 00:32:12,960
received from the clients

885
00:32:10,559 --> 00:32:15,360
in the agreement stage nodes will agree

886
00:32:12,960 --> 00:32:17,519
on whose local orderings to use to

887
00:32:15,360 --> 00:32:20,080
sequence a particular transaction

888
00:32:17,519 --> 00:32:22,000
and in the finalization stage nodes will

889
00:32:20,080 --> 00:32:24,639
finalize the transaction ordering and

890
00:32:22,000 --> 00:32:26,720
output it to the blockchain

891
00:32:24,640 --> 00:32:28,320
so the finalization stage requires no

892
00:32:26,720 --> 00:32:30,240
extra communication

893
00:32:28,320 --> 00:32:33,039
and all of the computation can be done

894
00:32:30,240 --> 00:32:34,799
locally so intuitively this is because

895
00:32:33,039 --> 00:32:37,039
all the data that's needed to compute

896
00:32:34,799 --> 00:32:40,158
the final ordering is agreed upon in the

897
00:32:37,039 --> 00:32:40,158
previous two stages

898
00:32:40,640 --> 00:32:44,799
in terms of adversarial corruption

899
00:32:42,720 --> 00:32:47,200
thresholds our synchronous protocol

900
00:32:44,799 --> 00:32:48,639
requires n greater than two f over two

901
00:32:47,200 --> 00:32:50,480
gamma minus one

902
00:32:48,640 --> 00:32:52,080
um so in the easiest case of gamma

903
00:32:50,480 --> 00:32:55,039
equals one we still require

904
00:32:52,080 --> 00:32:56,000
an honest majority and our protocols

905
00:32:55,039 --> 00:32:58,240
also work for

906
00:32:56,000 --> 00:32:59,600
completely asynchronous models but we

907
00:32:58,240 --> 00:33:03,519
require n greater than

908
00:32:59,600 --> 00:33:03,519
four f over two lambda minus one

909
00:33:04,240 --> 00:33:09,760
uh another sort of interesting takeaway

910
00:33:07,440 --> 00:33:11,919
is our protocol technique actually

911
00:33:09,760 --> 00:33:15,200
serves as a general compiler

912
00:33:11,919 --> 00:33:15,919
that can take any standard consensus

913
00:33:15,200 --> 00:33:18,080
protocol

914
00:33:15,919 --> 00:33:19,840
and transform it into one that also

915
00:33:18,080 --> 00:33:22,480
provides order fairness

916
00:33:19,840 --> 00:33:24,320
and this is because we only require weak

917
00:33:22,480 --> 00:33:25,679
broadcast and agreement primitives in a

918
00:33:24,320 --> 00:33:27,600
black box way

919
00:33:25,679 --> 00:33:30,640
which can be realized from any existing

920
00:33:27,600 --> 00:33:30,639
consensus protocol

921
00:33:32,320 --> 00:33:36,879
um so just some final thoughts our work

922
00:33:34,799 --> 00:33:38,559
is sort of the first to formalize order

923
00:33:36,880 --> 00:33:39,519
fairness and provide protocols to

924
00:33:38,559 --> 00:33:40,960
realize it

925
00:33:39,519 --> 00:33:42,799
and we think order fairness is a

926
00:33:40,960 --> 00:33:44,399
primitive is important for a lot of

927
00:33:42,799 --> 00:33:46,639
blockchain applications

928
00:33:44,399 --> 00:33:47,600
i mentioned decentralized exchanges

929
00:33:46,640 --> 00:33:50,159
briefly before

930
00:33:47,600 --> 00:33:53,279
but we think in general decentralized

931
00:33:50,159 --> 00:33:56,559
finance could benefit from fair ordering

932
00:33:53,279 --> 00:33:57,600
and um yeah this could also be important

933
00:33:56,559 --> 00:34:00,799
for like

934
00:33:57,600 --> 00:34:04,240
initial coin offerings for icos for

935
00:34:00,799 --> 00:34:06,320
chance to do fair investing

936
00:34:04,240 --> 00:34:08,000
so this concludes my presentation i've

937
00:34:06,320 --> 00:34:09,359
put my colonel email address as well as

938
00:34:08,000 --> 00:34:11,040
a link to the full paper if you're

939
00:34:09,359 --> 00:34:14,560
interested

940
00:34:11,040 --> 00:34:16,800
thank you thank you very much

941
00:34:14,560 --> 00:34:16,799
now

942
00:34:18,000 --> 00:34:21,760
so let's see if there are some questions

943
00:34:20,079 --> 00:34:24,000
if you have questions please

944
00:34:21,760 --> 00:34:25,440
you can either write in the chat or mute

945
00:34:24,000 --> 00:34:27,599
yourself for those of you who are not

946
00:34:25,440 --> 00:34:27,599
here

947
00:34:29,520 --> 00:34:35,359
so let me start with one um

948
00:34:32,639 --> 00:34:35,760
can you give some intuition about uh why

949
00:34:35,359 --> 00:34:39,598
the

950
00:34:35,760 --> 00:34:39,599
uh intuitive nation notion

951
00:34:41,839 --> 00:34:45,040
it's able to achieve in general

952
00:34:46,639 --> 00:34:50,320
you're muted froze could you repeat the

953
00:34:48,560 --> 00:34:53,119
question

954
00:34:50,320 --> 00:34:54,000
sorry um yeah i was asking whether you

955
00:34:53,119 --> 00:34:56,560
could give some

956
00:34:54,000 --> 00:34:58,240
uh some intuition about what the

957
00:34:56,560 --> 00:34:59,839
property

958
00:34:58,240 --> 00:35:00,879
the intuitive property of order fairness

959
00:34:59,839 --> 00:35:02,480
that you mentioned in the beginning is

960
00:35:00,880 --> 00:35:03,599
impossible to achieve in the general

961
00:35:02,480 --> 00:35:06,960
case

962
00:35:03,599 --> 00:35:08,560
okay uh so basically the it comes from a

963
00:35:06,960 --> 00:35:11,040
surprising connection to

964
00:35:08,560 --> 00:35:12,560
voting theory um specifically the

965
00:35:11,040 --> 00:35:14,800
condorcet paradox

966
00:35:12,560 --> 00:35:16,960
so even this basically is a situation

967
00:35:14,800 --> 00:35:18,240
where even if the individual preferences

968
00:35:16,960 --> 00:35:20,160
are transitive

969
00:35:18,240 --> 00:35:21,759
then you can still have a case where

970
00:35:20,160 --> 00:35:24,560
there's a cycle in the ordering so the

971
00:35:21,760 --> 00:35:26,640
global preference becomes non-transitive

972
00:35:24,560 --> 00:35:28,640
um so this is why there is the the

973
00:35:26,640 --> 00:35:30,879
impossibility result

974
00:35:28,640 --> 00:35:33,040
but the key idea of why our block order

975
00:35:30,880 --> 00:35:35,119
fairness relaxation works is we can

976
00:35:33,040 --> 00:35:38,400
sort of shove these paradoxical

977
00:35:35,119 --> 00:35:38,400
orderings into the same block

978
00:35:39,920 --> 00:35:45,839
i see thank you

979
00:35:54,880 --> 00:36:01,680
any more questions julia

980
00:35:58,000 --> 00:36:05,760
i don't see any other question um

981
00:36:01,680 --> 00:36:05,759
neither here nor in the zolip chat so

982
00:36:06,720 --> 00:36:11,839
okay like a few more seconds and then

983
00:36:08,480 --> 00:36:11,839
move on

984
00:36:14,400 --> 00:36:18,079
leo you can start sharing

985
00:36:22,880 --> 00:36:26,000
if anybody has questions about previous

986
00:36:24,720 --> 00:36:28,000
talks we we might

987
00:36:26,000 --> 00:36:30,640
have some few minutes at the end of the

988
00:36:28,000 --> 00:36:33,920
session so feel free to ask

989
00:36:30,640 --> 00:36:33,920
if something comes up

990
00:36:35,920 --> 00:36:39,359
okay so the next paper is titled

991
00:36:37,839 --> 00:36:42,078
generically speeding up repeated

992
00:36:39,359 --> 00:36:44,000
squaring is equivalent to factoring

993
00:36:42,079 --> 00:36:45,839
sharp thresholds for all generic ring

994
00:36:44,000 --> 00:36:47,200
delay functions it's a paper valley

995
00:36:45,839 --> 00:36:50,400
overtime and guild sergei

996
00:36:47,200 --> 00:36:53,680
and leo will give the talk

997
00:36:50,400 --> 00:36:55,839
okay so thank you alon and zelon said

998
00:36:53,680 --> 00:36:56,720
i'm your and this is going to work with

999
00:36:55,839 --> 00:36:58,560
gear

1000
00:36:56,720 --> 00:36:59,919
and this talk is going to be about delay

1001
00:36:58,560 --> 00:37:03,119
functions

1002
00:36:59,920 --> 00:37:04,960
so what sorry water delay functions

1003
00:37:03,119 --> 00:37:06,720
so roughly speaking a cryptographic

1004
00:37:04,960 --> 00:37:07,920
delay function is a function which is

1005
00:37:06,720 --> 00:37:10,480
efficiently complete

1006
00:37:07,920 --> 00:37:12,480
sorry efficiently computable but only in

1007
00:37:10,480 --> 00:37:14,640
a manner which is inherited sequential

1008
00:37:12,480 --> 00:37:16,640
so concretely a delay function takes in

1009
00:37:14,640 --> 00:37:18,560
an additional delay parameter t

1010
00:37:16,640 --> 00:37:20,000
and given this dla parameter the

1011
00:37:18,560 --> 00:37:21,920
function should be computable

1012
00:37:20,000 --> 00:37:24,000
in some time polynomiality so for

1013
00:37:21,920 --> 00:37:25,680
example 40 or t cubed

1014
00:37:24,000 --> 00:37:27,599
however it should not be possible to

1015
00:37:25,680 --> 00:37:29,040
evaluate the function on a random input

1016
00:37:27,599 --> 00:37:30,960
in time less than t

1017
00:37:29,040 --> 00:37:33,040
and this would hold even if we allow for

1018
00:37:30,960 --> 00:37:34,839
a preprocessing stage and for attackers

1019
00:37:33,040 --> 00:37:36,640
with the polynomial number of parallel

1020
00:37:34,839 --> 00:37:38,400
processors

1021
00:37:36,640 --> 00:37:40,240
so one reason to care about delay

1022
00:37:38,400 --> 00:37:42,160
functions is that they serve as a

1023
00:37:40,240 --> 00:37:44,160
fundamental building block for two very

1024
00:37:42,160 --> 00:37:46,000
useful cryptographic primitives

1025
00:37:44,160 --> 00:37:47,359
the first is time lock puzzles

1026
00:37:46,000 --> 00:37:48,960
introduced by the investor william

1027
00:37:47,359 --> 00:37:50,880
wagner in 96

1028
00:37:48,960 --> 00:37:52,960
and in our terminology a time lock

1029
00:37:50,880 --> 00:37:55,280
puzzle is a delay function

1030
00:37:52,960 --> 00:37:56,640
which allows for a first generation of

1031
00:37:55,280 --> 00:37:58,320
input output pairs

1032
00:37:56,640 --> 00:38:00,160
will be fast we typically mean in time

1033
00:37:58,320 --> 00:38:01,359
poly logarithmic in the delay parameter

1034
00:38:00,160 --> 00:38:03,759
t

1035
00:38:01,359 --> 00:38:06,400
the second notion is that verifiable

1036
00:38:03,760 --> 00:38:08,160
delay functions or vdfs for short

1037
00:38:06,400 --> 00:38:09,680
these were formalized a couple of years

1038
00:38:08,160 --> 00:38:11,759
ago by bonetal

1039
00:38:09,680 --> 00:38:13,118
and in our terminology a vdf is a

1040
00:38:11,760 --> 00:38:14,960
daylight function

1041
00:38:13,119 --> 00:38:16,480
which allows for fast verification

1042
00:38:14,960 --> 00:38:19,839
nothing with output pairs

1043
00:38:16,480 --> 00:38:22,400
possibly given an additional short proof

1044
00:38:19,839 --> 00:38:24,400
now these two primitives timelock

1045
00:38:22,400 --> 00:38:26,400
puzzles and vdfs have numerous

1046
00:38:24,400 --> 00:38:28,000
applications in cryptography

1047
00:38:26,400 --> 00:38:29,839
you can see a very partial list on the

1048
00:38:28,000 --> 00:38:31,920
slide but the main

1049
00:38:29,839 --> 00:38:33,759
takeaway message from the slide is that

1050
00:38:31,920 --> 00:38:36,320
we want delay functions

1051
00:38:33,760 --> 00:38:38,960
which enable extensions to time of

1052
00:38:36,320 --> 00:38:41,839
puzzles and to vdfs

1053
00:38:38,960 --> 00:38:43,119
okay so perhaps the simplest example of

1054
00:38:41,839 --> 00:38:45,440
a delay function

1055
00:38:43,119 --> 00:38:47,599
is the iterated hashing function it's

1056
00:38:45,440 --> 00:38:48,880
obtained by iteratively applying a hash

1057
00:38:47,599 --> 00:38:52,240
function

1058
00:38:48,880 --> 00:38:53,599
denoted by h in this case onto the input

1059
00:38:52,240 --> 00:38:55,439
and then the output of the delay

1060
00:38:53,599 --> 00:38:58,320
function is the output of the last

1061
00:38:55,440 --> 00:39:01,599
invocation of h

1062
00:38:58,320 --> 00:39:03,920
one positive thing about this function

1063
00:39:01,599 --> 00:39:05,920
is that it has a formal security

1064
00:39:03,920 --> 00:39:08,160
argument in an idealized model

1065
00:39:05,920 --> 00:39:10,560
so concretely when the hash function h

1066
00:39:08,160 --> 00:39:12,839
is modeled as a random oracle

1067
00:39:10,560 --> 00:39:14,078
one can fairly easily prove

1068
00:39:12,839 --> 00:39:17,119
unconditionally

1069
00:39:14,079 --> 00:39:20,240
that computing the function requires a t

1070
00:39:17,119 --> 00:39:22,960
sequential calls to the random oracle

1071
00:39:20,240 --> 00:39:24,078
the downside of this function however is

1072
00:39:22,960 --> 00:39:26,079
that it seems to

1073
00:39:24,079 --> 00:39:28,240
lack the structure needed in order to

1074
00:39:26,079 --> 00:39:29,440
enable extensions to time up puzzles and

1075
00:39:28,240 --> 00:39:32,240
to pdfs

1076
00:39:29,440 --> 00:39:33,760
so what we want is vdf or sorry delay

1077
00:39:32,240 --> 00:39:36,640
function candidates

1078
00:39:33,760 --> 00:39:38,079
with more structure and this is where

1079
00:39:36,640 --> 00:39:39,279
the repeated squaring function comes

1080
00:39:38,079 --> 00:39:41,200
into the picture

1081
00:39:39,280 --> 00:39:42,400
and it is defined with respect to some

1082
00:39:41,200 --> 00:39:45,279
group of g

1083
00:39:42,400 --> 00:39:46,400
and given a group element x as input the

1084
00:39:45,280 --> 00:39:49,119
output of the function

1085
00:39:46,400 --> 00:39:50,560
is x raised to the power of two dot t

1086
00:39:49,119 --> 00:39:52,079
now it's not hard to see that this is

1087
00:39:50,560 --> 00:39:53,680
neat computable in time t

1088
00:39:52,079 --> 00:39:55,680
times poly lambda where the lambda is

1089
00:39:53,680 --> 00:39:57,279
the security parameter by the repeated

1090
00:39:55,680 --> 00:39:59,598
squarings in the group

1091
00:39:57,280 --> 00:40:01,359
and indeed this function has enough

1092
00:39:59,599 --> 00:40:02,320
structure for time of puzzles and for

1093
00:40:01,359 --> 00:40:04,078
pdfs

1094
00:40:02,320 --> 00:40:06,319
so it was first proposed by the first

1095
00:40:04,079 --> 00:40:07,520
journaling wagner as the basis for the

1096
00:40:06,319 --> 00:40:09,359
timeline puzzle

1097
00:40:07,520 --> 00:40:11,280
and it was recently and elegantly

1098
00:40:09,359 --> 00:40:13,759
augmented with succinct proofs in order

1099
00:40:11,280 --> 00:40:15,920
to yield validif candidates

1100
00:40:13,760 --> 00:40:17,440
so the sequentiality of this function

1101
00:40:15,920 --> 00:40:18,640
prior to our work was based on the

1102
00:40:17,440 --> 00:40:20,720
assumption

1103
00:40:18,640 --> 00:40:22,839
that there are groups in which one

1104
00:40:20,720 --> 00:40:24,319
cannot significantly speed up this

1105
00:40:22,839 --> 00:40:26,319
computation

1106
00:40:24,319 --> 00:40:28,079
without pre-processing in parallel

1107
00:40:26,319 --> 00:40:29,440
processors

1108
00:40:28,079 --> 00:40:31,440
so it's not hard to see that the

1109
00:40:29,440 --> 00:40:32,880
necessary condition for this assumption

1110
00:40:31,440 --> 00:40:34,400
to hold in some group

1111
00:40:32,880 --> 00:40:36,800
is that this group is a group of anu

1112
00:40:34,400 --> 00:40:38,319
noda meaning that it is infeasible to

1113
00:40:36,800 --> 00:40:40,079
compute the group so they are given the

1114
00:40:38,319 --> 00:40:41,839
group's representation

1115
00:40:40,079 --> 00:40:43,359
and the main candidate that we currently

1116
00:40:41,839 --> 00:40:46,640
have in photography for such

1117
00:40:43,359 --> 00:40:48,640
groups is the family of rsa groups

1118
00:40:46,640 --> 00:40:50,640
we do have a second candidate which is

1119
00:40:48,640 --> 00:40:51,680
the class groups of imaginary quadratic

1120
00:40:50,640 --> 00:40:53,279
fields

1121
00:40:51,680 --> 00:40:55,279
but these are not as well studied

1122
00:40:53,280 --> 00:40:56,800
cryptographically and also the group

1123
00:40:55,280 --> 00:41:00,640
operation there seems to be

1124
00:40:56,800 --> 00:41:02,400
somewhat less efficient okay so

1125
00:41:00,640 --> 00:41:04,799
prior to our work this assumption was

1126
00:41:02,400 --> 00:41:06,560
exactly this an assumption

1127
00:41:04,800 --> 00:41:08,720
and the repeated squaring function did

1128
00:41:06,560 --> 00:41:11,359
not enjoy a similar

1129
00:41:08,720 --> 00:41:13,118
formal proof of security not even in an

1130
00:41:11,359 --> 00:41:16,720
idealized model

1131
00:41:13,119 --> 00:41:18,560
as the iterated hashing function so this

1132
00:41:16,720 --> 00:41:20,240
raises the natural question of can we

1133
00:41:18,560 --> 00:41:21,759
base the sequentiality of the period of

1134
00:41:20,240 --> 00:41:23,680
squaring in our recycle

1135
00:41:21,760 --> 00:41:27,040
on better established assumptions such

1136
00:41:23,680 --> 00:41:28,480
as factoring or the rsa assumption

1137
00:41:27,040 --> 00:41:30,960
so in this slide our contributions are

1138
00:41:28,480 --> 00:41:33,440
the following we present a sharp

1139
00:41:30,960 --> 00:41:35,359
sequentiality threshold that applies

1140
00:41:33,440 --> 00:41:36,880
for all functions within the generic

1141
00:41:35,359 --> 00:41:39,759
link model

1142
00:41:36,880 --> 00:41:42,319
so roughly speaking this model captures

1143
00:41:39,760 --> 00:41:45,200
functions and more generally

1144
00:41:42,319 --> 00:41:46,880
sorry more general algorithms that deal

1145
00:41:45,200 --> 00:41:50,319
with ring elements but without

1146
00:41:46,880 --> 00:41:52,960
exploiting the underlying representation

1147
00:41:50,319 --> 00:41:55,040
and concretely what we do is we put

1148
00:41:52,960 --> 00:41:56,079
forth a new notion of sequentiality

1149
00:41:55,040 --> 00:41:58,480
depth

1150
00:41:56,079 --> 00:41:59,200
for such functions and we prove that

1151
00:41:58,480 --> 00:42:01,839
this notion

1152
00:41:59,200 --> 00:42:02,480
indeed serves a sharp threshold on the

1153
00:42:01,839 --> 00:42:05,200
number

1154
00:42:02,480 --> 00:42:06,960
of sequential ring operations required

1155
00:42:05,200 --> 00:42:09,520
in order to compute the function

1156
00:42:06,960 --> 00:42:11,680
so completely assuming the hardness of

1157
00:42:09,520 --> 00:42:14,079
factoring the rsa models

1158
00:42:11,680 --> 00:42:15,839
in the standard model we show that the

1159
00:42:14,079 --> 00:42:16,960
generic ring function of sequentiality

1160
00:42:15,839 --> 00:42:19,119
depth d

1161
00:42:16,960 --> 00:42:21,119
can be generically evaluated using these

1162
00:42:19,119 --> 00:42:23,520
sequential rounds of ring operations

1163
00:42:21,119 --> 00:42:24,960
but cannot be generically evaluated on a

1164
00:42:23,520 --> 00:42:26,240
random input with less

1165
00:42:24,960 --> 00:42:28,640
than the sequential amounts of ring

1166
00:42:26,240 --> 00:42:31,759
operations even with pre-processing and

1167
00:42:28,640 --> 00:42:33,839
a polynomial nodule of prior processor

1168
00:42:31,760 --> 00:42:34,880
now we don't have the time to talk about

1169
00:42:33,839 --> 00:42:38,078
this notion

1170
00:42:34,880 --> 00:42:39,680
of sequentiality depth in depth

1171
00:42:38,079 --> 00:42:41,920
but we will say that for simple enough

1172
00:42:39,680 --> 00:42:43,359
polynomials it roughly corresponds to

1173
00:42:41,920 --> 00:42:45,280
the log of their degree

1174
00:42:43,359 --> 00:42:47,200
and in particular for the repeated

1175
00:42:45,280 --> 00:42:50,480
squaring function

1176
00:42:47,200 --> 00:42:53,359
with respect to a delay parameter t er

1177
00:42:50,480 --> 00:42:53,760
its sequentiality depth is exactly t so

1178
00:42:53,359 --> 00:42:55,359
with

1179
00:42:53,760 --> 00:42:56,880
an immediate corollary we get the

1180
00:42:55,359 --> 00:42:58,480
generically speeding gap

1181
00:42:56,880 --> 00:43:00,079
repeated querying is equivalent to

1182
00:42:58,480 --> 00:43:01,839
factoring and i

1183
00:43:00,079 --> 00:43:03,280
will mention that we also have analogous

1184
00:43:01,839 --> 00:43:06,480
results for uh

1185
00:43:03,280 --> 00:43:10,160
pseudorandomness but i won't have time

1186
00:43:06,480 --> 00:43:11,520
to discuss them okay so i'll conclude

1187
00:43:10,160 --> 00:43:13,200
very briefly with a couple of open

1188
00:43:11,520 --> 00:43:15,440
problems

1189
00:43:13,200 --> 00:43:17,118
so prior to our work uh the landscape

1190
00:43:15,440 --> 00:43:17,680
regarding the sequentiality of repeated

1191
00:43:17,119 --> 00:43:19,359
querying

1192
00:43:17,680 --> 00:43:20,879
seemed something like this so on the one

1193
00:43:19,359 --> 00:43:22,000
hand there was no formal security

1194
00:43:20,880 --> 00:43:23,440
argument

1195
00:43:22,000 --> 00:43:25,040
but on the other hand the assumption

1196
00:43:23,440 --> 00:43:26,640
remained essentially unbroken for two

1197
00:43:25,040 --> 00:43:28,880
and a half decades

1198
00:43:26,640 --> 00:43:31,520
and what we do is we somewhat narrow

1199
00:43:28,880 --> 00:43:34,160
this gap with certain class of attacks

1200
00:43:31,520 --> 00:43:36,079
namely for generic attacks so obviously

1201
00:43:34,160 --> 00:43:37,520
not algorithms are generic but this is a

1202
00:43:36,079 --> 00:43:39,599
rather natural class

1203
00:43:37,520 --> 00:43:41,200
and two implications of this result is

1204
00:43:39,599 --> 00:43:42,800
that if you want to break the

1205
00:43:41,200 --> 00:43:43,598
sequentiality assumption of repeated

1206
00:43:42,800 --> 00:43:45,200
squaring

1207
00:43:43,599 --> 00:43:46,880
you now know better than to try and do

1208
00:43:45,200 --> 00:43:48,960
it generically

1209
00:43:46,880 --> 00:43:50,240
and on the other hand it's a somewhat

1210
00:43:48,960 --> 00:43:52,480
necessary step

1211
00:43:50,240 --> 00:43:54,160
in the quest for proving similar results

1212
00:43:52,480 --> 00:43:55,839
in leicester's predictive models

1213
00:43:54,160 --> 00:43:57,680
so this is the first open question can

1214
00:43:55,839 --> 00:43:59,520
you do so can you prove similar results

1215
00:43:57,680 --> 00:44:02,160
in lesson 15 models

1216
00:43:59,520 --> 00:44:04,160
and the natural candidate is the

1217
00:44:02,160 --> 00:44:07,440
algebraic rearing model

1218
00:44:04,160 --> 00:44:08,078
which is a natural extension of the

1219
00:44:07,440 --> 00:44:09,760
algebraic

1220
00:44:08,079 --> 00:44:11,760
group model recently proposed by focused

1221
00:44:09,760 --> 00:44:13,440
biological loss

1222
00:44:11,760 --> 00:44:15,200
and the other open question is what

1223
00:44:13,440 --> 00:44:18,000
about other candidate delay functions

1224
00:44:15,200 --> 00:44:19,919
such as repeated square new class groups

1225
00:44:18,000 --> 00:44:23,040
isogeny based constructions

1226
00:44:19,920 --> 00:44:26,880
or the recently proposed video function

1227
00:44:23,040 --> 00:44:29,759
in prime fields okay so that's all

1228
00:44:26,880 --> 00:44:32,960
and i'll take questions thank you thank

1229
00:44:29,760 --> 00:44:32,960
you very much leo

1230
00:44:33,760 --> 00:44:38,480
julia so yeah for those of you just

1231
00:44:37,280 --> 00:44:40,319
connected

1232
00:44:38,480 --> 00:44:41,760
to ask questions please mute yourself or

1233
00:44:40,319 --> 00:44:44,079
raise your hands or

1234
00:44:41,760 --> 00:44:44,079
make sure

1235
00:44:44,880 --> 00:44:48,839
nobody wants to ask questions actually a

1236
00:44:46,960 --> 00:44:52,640
few questions for you

1237
00:44:48,839 --> 00:44:55,759
okay um

1238
00:44:52,640 --> 00:44:57,920
okay so let me um so

1239
00:44:55,760 --> 00:44:59,359
first of all one clarification when you

1240
00:44:57,920 --> 00:45:02,560
say that uh

1241
00:44:59,359 --> 00:45:04,000
you uh assume uh pre-processing uh do

1242
00:45:02,560 --> 00:45:05,359
you mean that

1243
00:45:04,000 --> 00:45:07,599
does your result hold even if the

1244
00:45:05,359 --> 00:45:11,200
adversary has access to the group

1245
00:45:07,599 --> 00:45:13,599
description whenever it's pre-processing

1246
00:45:11,200 --> 00:45:15,839
no so it holds the pre-processing

1247
00:45:13,599 --> 00:45:17,119
algorithm is also generic

1248
00:45:15,839 --> 00:45:19,040
it doesn't have access to group

1249
00:45:17,119 --> 00:45:21,359
description uh

1250
00:45:19,040 --> 00:45:23,440
but or the ring description in this case

1251
00:45:21,359 --> 00:45:26,480
uh but you know it can do

1252
00:45:23,440 --> 00:45:28,160
more than uh in the case of repeated

1253
00:45:26,480 --> 00:45:30,640
querying more than t

1254
00:45:28,160 --> 00:45:33,359
sequential rounds of ring operations but

1255
00:45:30,640 --> 00:45:34,960
it doesn't get the input

1256
00:45:33,359 --> 00:45:36,400
right i guess i guess i guess my

1257
00:45:34,960 --> 00:45:38,480
question was whether you can

1258
00:45:36,400 --> 00:45:40,319
query the group or even in the

1259
00:45:38,480 --> 00:45:42,000
pre-processing

1260
00:45:40,319 --> 00:45:43,359
yeah you can query the the ring

1261
00:45:42,000 --> 00:45:46,800
calculation oracle

1262
00:45:43,359 --> 00:45:47,598
you know any number of times that you

1263
00:45:46,800 --> 00:45:50,880
want

1264
00:45:47,599 --> 00:45:52,240
and but obviously yeah you might get

1265
00:45:50,880 --> 00:45:53,920
access to some public parameters or

1266
00:45:52,240 --> 00:45:55,040
whatever but you don't get access to the

1267
00:45:53,920 --> 00:45:58,800
uh

1268
00:45:55,040 --> 00:46:00,480
to the inputted function um

1269
00:45:58,800 --> 00:46:02,160
one more question is that some

1270
00:46:00,480 --> 00:46:04,480
application of timelock puzzles

1271
00:46:02,160 --> 00:46:05,200
uh i believe to nominable nomidable

1272
00:46:04,480 --> 00:46:07,440
commitments

1273
00:46:05,200 --> 00:46:08,560
they require some exponential security

1274
00:46:07,440 --> 00:46:11,839
does your results say

1275
00:46:08,560 --> 00:46:13,200
anything in that in that settings

1276
00:46:11,839 --> 00:46:16,160
where the attacker is allowed to run in

1277
00:46:13,200 --> 00:46:16,160
sub-exponential time

1278
00:46:17,280 --> 00:46:25,359
so i'm not sure what you mean about

1279
00:46:20,720 --> 00:46:25,359
i mean specifically for um

1280
00:46:25,839 --> 00:46:29,680
so it depends how you measure time right

1281
00:46:27,599 --> 00:46:32,800
i mean you have like two

1282
00:46:29,680 --> 00:46:34,240
yeah this model yeah so so you have like

1283
00:46:32,800 --> 00:46:34,480
two definitions of time this model you

1284
00:46:34,240 --> 00:46:36,560
have

1285
00:46:34,480 --> 00:46:38,160
running time and you have the number of

1286
00:46:36,560 --> 00:46:42,160
uh queries

1287
00:46:38,160 --> 00:46:44,720
so you know the online attacker can

1288
00:46:42,160 --> 00:46:46,240
make you know up to if the sequentiality

1289
00:46:44,720 --> 00:46:49,200
depth of the function is d

1290
00:46:46,240 --> 00:46:50,479
up to the sequential uh lingual

1291
00:46:49,200 --> 00:46:53,359
potential queries

1292
00:46:50,480 --> 00:46:55,200
and it can run in any arbitrary time t

1293
00:46:53,359 --> 00:46:56,400
but then the factoring algorithm will

1294
00:46:55,200 --> 00:46:58,879
inherit

1295
00:46:56,400 --> 00:47:00,720
this time all right so if you want to

1296
00:46:58,880 --> 00:47:02,079
break the uh

1297
00:47:00,720 --> 00:47:04,078
the factoring assumption then you need

1298
00:47:02,079 --> 00:47:05,839
to run in some you know

1299
00:47:04,079 --> 00:47:08,800
in time which is less than whatever you

1300
00:47:05,839 --> 00:47:08,799
assume about factoring

1301
00:47:09,599 --> 00:47:13,040
yeah i guess my question was about the

1302
00:47:10,960 --> 00:47:13,920
parameter d whether you can set it to be

1303
00:47:13,040 --> 00:47:16,560
for example

1304
00:47:13,920 --> 00:47:18,640
sub sub exponential or whether you're

1305
00:47:16,560 --> 00:47:25,839
you can decide it to be whatever

1306
00:47:18,640 --> 00:47:25,839
god thanks

1307
00:47:27,680 --> 00:47:32,480
so i believe there's no other question

1308
00:47:30,240 --> 00:47:32,479
um

1309
00:47:33,119 --> 00:47:38,319
i guess we have a few minutes so if

1310
00:47:36,160 --> 00:47:42,480
someone has some questions about uh

1311
00:47:38,319 --> 00:47:42,480
the previous talks please speak up now

1312
00:47:44,319 --> 00:47:49,119
you know what i do want to say that the

1313
00:47:47,040 --> 00:47:52,640
um

1314
00:47:49,119 --> 00:47:53,760
factoring algorithm will also inherent

1315
00:47:52,640 --> 00:47:55,839
the running time of the factoring

1316
00:47:53,760 --> 00:47:58,960
algorithm will also be dependent

1317
00:47:55,839 --> 00:48:01,839
on the parameter d right so it can be

1318
00:47:58,960 --> 00:48:01,839
sub-exponential

1319
00:48:01,920 --> 00:48:07,119
if you believe some some sub-exponential

1320
00:48:05,520 --> 00:48:09,759
hardness of factoring

1321
00:48:07,119 --> 00:48:21,839
but it cannot be too large right of

1322
00:48:09,760 --> 00:48:21,839
course of course that makes sense

1323
00:48:24,160 --> 00:48:28,319
well i guess uh if you guys have any any

1324
00:48:26,640 --> 00:48:31,118
more questions

1325
00:48:28,319 --> 00:48:32,558
contact the speakers privately and yeah

1326
00:48:31,119 --> 00:48:33,440
thanks everyone for for sharing the

1327
00:48:32,559 --> 00:48:36,160
session with me

1328
00:48:33,440 --> 00:48:36,160
and thanks

1329
00:48:37,200 --> 00:48:43,118
thanks everybody for participating and

1330
00:48:39,680 --> 00:48:43,118
for the wonderful talks

