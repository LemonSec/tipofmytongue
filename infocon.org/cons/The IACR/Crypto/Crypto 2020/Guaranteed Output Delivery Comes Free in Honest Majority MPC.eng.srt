1
00:00:03,520 --> 00:00:07,359
hello everyone

2
00:00:04,799 --> 00:00:09,760
my name is ivan sang today i'm honored

3
00:00:07,359 --> 00:00:12,080
to give a talk about our results

4
00:00:09,760 --> 00:00:14,080
guaranteed output theory comes free in

5
00:00:12,080 --> 00:00:16,240
honest majority mpc

6
00:00:14,080 --> 00:00:18,480
closed with people goya and the changer

7
00:00:16,239 --> 00:00:18,479
drew

8
00:00:19,600 --> 00:00:23,279
multiparty computation allows several

9
00:00:21,600 --> 00:00:25,359
mutually distrusting parties

10
00:00:23,279 --> 00:00:26,320
to evaluate the function on zero private

11
00:00:25,359 --> 00:00:28,400
inputs

12
00:00:26,320 --> 00:00:29,599
it guarantees that the practical

13
00:00:28,400 --> 00:00:31,519
execution does not

14
00:00:29,599 --> 00:00:33,760
leak anything about the individual

15
00:00:31,519 --> 00:00:35,519
inputs beyond what can be inferred from

16
00:00:33,760 --> 00:00:38,000
the function output

17
00:00:35,520 --> 00:00:39,120
usually the functionality is represented

18
00:00:38,000 --> 00:00:41,600
as a circuit

19
00:00:39,120 --> 00:00:42,879
and in particular here we choose to use

20
00:00:41,600 --> 00:00:45,760
an arithmetic circuit

21
00:00:42,879 --> 00:00:47,760
or our finance field the circuit

22
00:00:45,760 --> 00:00:51,280
supports addition dates and

23
00:00:47,760 --> 00:00:53,199
multiplication date in this work

24
00:00:51,280 --> 00:00:54,640
we are interested in the honest majority

25
00:00:53,199 --> 00:00:56,160
setting

26
00:00:54,640 --> 00:00:58,079
assuming broadcast channel and the

27
00:00:56,160 --> 00:00:59,680
peer-to-peer private channels

28
00:00:58,079 --> 00:01:02,160
our goal is to construct an

29
00:00:59,680 --> 00:01:06,080
unconditional secure and busy protocol

30
00:01:02,160 --> 00:01:06,080
with guaranteed output delivery

31
00:01:07,760 --> 00:01:10,880
before we move on i would like to

32
00:01:09,760 --> 00:01:13,680
motivate my talk

33
00:01:10,880 --> 00:01:14,320
by answering the following two questions

34
00:01:13,680 --> 00:01:17,360
first

35
00:01:14,320 --> 00:01:19,279
why do we care about unconditional npc

36
00:01:17,360 --> 00:01:20,560
a key feature of unconditional npc is

37
00:01:19,280 --> 00:01:22,479
that we do not

38
00:01:20,560 --> 00:01:24,000
need any extensive cryptographic

39
00:01:22,479 --> 00:01:26,000
primitive such as

40
00:01:24,000 --> 00:01:27,280
public key encryption or obvious

41
00:01:26,000 --> 00:01:28,640
transfer

42
00:01:27,280 --> 00:01:31,439
and the protocol is secure

43
00:01:28,640 --> 00:01:33,200
unconditionally comparing with protocols

44
00:01:31,439 --> 00:01:35,439
in the computational setting

45
00:01:33,200 --> 00:01:36,880
one major benefit is that cloud courses

46
00:01:35,439 --> 00:01:38,960
usually do not require

47
00:01:36,880 --> 00:01:40,640
require complicated and time-consuming

48
00:01:38,960 --> 00:01:43,119
local computation

49
00:01:40,640 --> 00:01:45,280
and it is possible to achieve fairness

50
00:01:43,119 --> 00:01:46,479
and guaranteed output delivery in the

51
00:01:45,280 --> 00:01:48,960
setting

52
00:01:46,479 --> 00:01:50,960
as a result the most efficient mpc

53
00:01:48,960 --> 00:01:52,798
protocols are in the unconditional npc

54
00:01:50,960 --> 00:01:55,199
paradigm

55
00:01:52,799 --> 00:01:56,799
second why do we focus on communication

56
00:01:55,200 --> 00:01:58,880
complexity

57
00:01:56,799 --> 00:02:00,079
since the local computations are

58
00:01:58,880 --> 00:02:03,199
typically simple

59
00:02:00,079 --> 00:02:05,199
often just a series of linear operations

60
00:02:03,200 --> 00:02:07,520
the efficiency of a protocol in the real

61
00:02:05,200 --> 00:02:10,160
world is dominated by its communication

62
00:02:07,520 --> 00:02:10,160
complexity

63
00:02:12,239 --> 00:02:17,760
here are two different types of adult

64
00:02:14,080 --> 00:02:19,599
three one one is a semi-unused adversary

65
00:02:17,760 --> 00:02:20,959
this kind of adversary follows the

66
00:02:19,599 --> 00:02:23,280
protocol honestly

67
00:02:20,959 --> 00:02:25,280
but try to learn extra information from

68
00:02:23,280 --> 00:02:27,120
what he had received

69
00:02:25,280 --> 00:02:30,080
the other one is a fully malicious

70
00:02:27,120 --> 00:02:32,080
adultery it can debit from the protocol

71
00:02:30,080 --> 00:02:34,800
arbitrarily

72
00:02:32,080 --> 00:02:35,519
if an npc protocol allows a premature

73
00:02:34,800 --> 00:02:37,680
board

74
00:02:35,519 --> 00:02:38,720
the messages protocol is secure with the

75
00:02:37,680 --> 00:02:40,959
board

76
00:02:38,720 --> 00:02:42,800
if an mvc protocol can ensure the

77
00:02:40,959 --> 00:02:45,040
success of the computation

78
00:02:42,800 --> 00:02:48,239
then receives protocol is fully secure

79
00:02:45,040 --> 00:02:51,519
or guaranteed output delivery

80
00:02:48,239 --> 00:02:53,599
in general to achieve malicious security

81
00:02:51,519 --> 00:02:55,280
we need to compare seminars protocols

82
00:02:53,599 --> 00:02:58,159
using additional tools

83
00:02:55,280 --> 00:02:59,519
for example gmw compiler in the

84
00:02:58,159 --> 00:03:01,519
computational setting

85
00:02:59,519 --> 00:03:03,840
and a verifiable sharing in the end

86
00:03:01,519 --> 00:03:06,319
conditional setting

87
00:03:03,840 --> 00:03:07,519
apparently security against fully

88
00:03:06,319 --> 00:03:09,359
malicious adultery

89
00:03:07,519 --> 00:03:11,760
is more difficult to achieve than

90
00:03:09,360 --> 00:03:15,120
semi-honest adultery

91
00:03:11,760 --> 00:03:17,200
therefore we ask the following question

92
00:03:15,120 --> 00:03:19,840
is it necessary to pay for malaysia

93
00:03:17,200 --> 00:03:19,839
security

94
00:03:21,040 --> 00:03:26,079
in this work we show that we can achieve

95
00:03:24,080 --> 00:03:27,760
basically the same efficiency

96
00:03:26,080 --> 00:03:29,680
as the best known protocol in the

97
00:03:27,760 --> 00:03:31,359
semi-iron setting

98
00:03:29,680 --> 00:03:33,360
here is a comparison of recent

99
00:03:31,360 --> 00:03:34,239
constructions of communication efficient

100
00:03:33,360 --> 00:03:37,599
mpc

101
00:03:34,239 --> 00:03:37,599
in the einstein majority setting

102
00:03:39,599 --> 00:03:43,760
in the semi-autonomic setting the best

103
00:03:41,519 --> 00:03:45,599
known construction is the dm protocol

104
00:03:43,760 --> 00:03:46,798
which requires six elements per party

105
00:03:45,599 --> 00:03:49,040
per gate

106
00:03:46,799 --> 00:03:51,280
this can be viewed as a baseline for the

107
00:03:49,040 --> 00:03:54,560
communication complexity

108
00:03:51,280 --> 00:03:57,599
recently there are two works cgh

109
00:03:54,560 --> 00:03:58,720
18 and m18 both achieving 12 elements

110
00:03:57,599 --> 00:04:00,238
per party packet

111
00:03:58,720 --> 00:04:02,480
in the setting of security with the

112
00:04:00,239 --> 00:04:04,159
board in this work

113
00:04:02,480 --> 00:04:06,079
we obtain the first secure with the

114
00:04:04,159 --> 00:04:08,000
board npc protocol

115
00:04:06,080 --> 00:04:10,720
where the communication complexity

116
00:04:08,000 --> 00:04:12,640
matches the semi-on-steam protocol

117
00:04:10,720 --> 00:04:14,000
we make a further improvement of the dm

118
00:04:12,640 --> 00:04:16,238
protocol which allows us

119
00:04:14,000 --> 00:04:19,358
to reduce the communication cost from

120
00:04:16,238 --> 00:04:20,959
six elements to 5.5 elements

121
00:04:19,358 --> 00:04:23,280
in the setting of guaranteed output

122
00:04:20,959 --> 00:04:25,520
delivery the best known previous

123
00:04:23,280 --> 00:04:27,599
constructions have bad dependencies

124
00:04:25,520 --> 00:04:29,280
on either the circuit depth are the

125
00:04:27,600 --> 00:04:32,479
circuit widths

126
00:04:29,280 --> 00:04:33,599
in bsf012 it has the term order of d

127
00:04:32,479 --> 00:04:37,199
times n squared

128
00:04:33,600 --> 00:04:40,639
where d is the circuit steps in ikp

129
00:04:37,199 --> 00:04:44,400
16 it has the term order of w times

130
00:04:40,639 --> 00:04:46,720
poly where w is the circuit bit

131
00:04:44,400 --> 00:04:48,479
the efficiency of this protocol will

132
00:04:46,720 --> 00:04:49,440
suffer when either the circuit depth is

133
00:04:48,479 --> 00:04:52,400
very large

134
00:04:49,440 --> 00:04:53,440
or the circuit base is very large in

135
00:04:52,400 --> 00:04:55,280
this work

136
00:04:53,440 --> 00:04:57,360
we give the first construction where the

137
00:04:55,280 --> 00:04:59,919
communication complexity property

138
00:04:57,360 --> 00:05:02,800
is linear in the circuit side our

139
00:04:59,919 --> 00:05:04,240
protocol achieves 5.5 elements per party

140
00:05:02,800 --> 00:05:07,199
in the best case

141
00:05:04,240 --> 00:05:10,160
and 7.5 elements when one or more

142
00:05:07,199 --> 00:05:12,720
corrupted parties are identified

143
00:05:10,160 --> 00:05:14,560
this result is obtained by compiling our

144
00:05:12,720 --> 00:05:17,759
secure with the board protocol

145
00:05:14,560 --> 00:05:17,759
into a fully secure one

146
00:05:18,960 --> 00:05:22,479
here is an outline of this talk we will

147
00:05:21,280 --> 00:05:25,599
start with the best

148
00:05:22,479 --> 00:05:27,280
semi on communication

149
00:05:25,600 --> 00:05:29,840
efficient protocol in the semi-iron

150
00:05:27,280 --> 00:05:31,119
setting then show how to gather secure

151
00:05:29,840 --> 00:05:33,039
with the bot protocol

152
00:05:31,120 --> 00:05:35,360
in the fully malicious setting and

153
00:05:33,039 --> 00:05:37,440
finally how to reach a fully secure

154
00:05:35,360 --> 00:05:41,360
protocol with comparable efficiency

155
00:05:37,440 --> 00:05:41,360
as the best known semi-is protocol

156
00:05:42,880 --> 00:05:46,320
we will use square bracket x with

157
00:05:45,199 --> 00:05:48,320
subscript t

158
00:05:46,320 --> 00:05:49,599
to represent the degree t sharing of the

159
00:05:48,320 --> 00:05:52,080
value x

160
00:05:49,600 --> 00:05:53,520
it requires at least the t t-1 shares to

161
00:05:52,080 --> 00:05:55,440
do reconstruction

162
00:05:53,520 --> 00:05:57,599
and any t-shirts do not leak any

163
00:05:55,440 --> 00:05:59,360
information about eggs

164
00:05:57,600 --> 00:06:01,680
here are two properties of chemistry

165
00:05:59,360 --> 00:06:03,039
sharing skin the first one is linear

166
00:06:01,680 --> 00:06:05,600
homomorphism

167
00:06:03,039 --> 00:06:06,240
namely adding two degree t-shirts x and

168
00:06:05,600 --> 00:06:08,560
y

169
00:06:06,240 --> 00:06:10,319
yields a degree t-sharing of the secret

170
00:06:08,560 --> 00:06:12,639
x plus y

171
00:06:10,319 --> 00:06:14,000
the second property is that multiplying

172
00:06:12,639 --> 00:06:16,800
two degree t-sharing

173
00:06:14,000 --> 00:06:17,600
x and y gives the degree 2d sharing of

174
00:06:16,800 --> 00:06:20,639
the secret

175
00:06:17,600 --> 00:06:22,479
x times y

176
00:06:20,639 --> 00:06:24,960
the best known seminars protocol in this

177
00:06:22,479 --> 00:06:27,520
setting was proposed by then guard and

178
00:06:24,960 --> 00:06:29,599
nelson in 2007.

179
00:06:27,520 --> 00:06:31,440
recall that a semi-honest adultery

180
00:06:29,600 --> 00:06:33,600
follows the protocol honestly

181
00:06:31,440 --> 00:06:36,800
but try to learn extra information from

182
00:06:33,600 --> 00:06:38,800
the messages it has seen

183
00:06:36,800 --> 00:06:40,240
the high level idea of the dm protocol

184
00:06:38,800 --> 00:06:43,280
is to compute a degree t

185
00:06:40,240 --> 00:06:44,800
sharing for each wire by the nature of

186
00:06:43,280 --> 00:06:46,880
shamrock sql sharing scheme

187
00:06:44,800 --> 00:06:48,000
the shares held by cropping parties are

188
00:06:46,880 --> 00:06:50,240
not enough to reconstruct

189
00:06:48,000 --> 00:06:52,560
the secret and therefore are just

190
00:06:50,240 --> 00:06:54,800
several independent values

191
00:06:52,560 --> 00:06:56,319
this ensures the security of the

192
00:06:54,800 --> 00:06:58,639
protocol

193
00:06:56,319 --> 00:07:00,319
to make this idea work we need to take

194
00:06:58,639 --> 00:07:02,960
care of multiplication gates

195
00:07:00,319 --> 00:07:04,720
and addition gates recall that the

196
00:07:02,960 --> 00:07:06,080
shamir sequel sharing scheme is linear

197
00:07:04,720 --> 00:07:08,800
homomorphic

198
00:07:06,080 --> 00:07:11,599
therefore for addition gates all parties

199
00:07:08,800 --> 00:07:13,680
can simply add their shares locally

200
00:07:11,599 --> 00:07:17,840
the core idea of the dim protocol is how

201
00:07:13,680 --> 00:07:17,840
to evaluate the multiplication bits

202
00:07:18,000 --> 00:07:22,720
assume the input sharings are x and y we

203
00:07:21,039 --> 00:07:25,199
know that all parts can locally

204
00:07:22,720 --> 00:07:26,240
multiply their shares to obtain a degree

205
00:07:25,199 --> 00:07:29,919
2t sharing of

206
00:07:26,240 --> 00:07:32,479
x times y therefore it is sufficient to

207
00:07:29,919 --> 00:07:34,159
do the reduction to this gearing

208
00:07:32,479 --> 00:07:36,318
the idea of the dm protocol is to

209
00:07:34,160 --> 00:07:39,599
prepare a pair of random shearings

210
00:07:36,319 --> 00:07:40,720
of the same value of r one sharing is a

211
00:07:39,599 --> 00:07:42,000
degree t-sharing

212
00:07:40,720 --> 00:07:45,360
and the other one is a degree

213
00:07:42,000 --> 00:07:47,840
traditionally to do debris reduction

214
00:07:45,360 --> 00:07:49,039
all parties use the random dvd sharing

215
00:07:47,840 --> 00:07:50,799
as a mask

216
00:07:49,039 --> 00:07:53,039
then the first party collects all the

217
00:07:50,800 --> 00:07:54,720
shares reconstruct the secrets

218
00:07:53,039 --> 00:07:56,159
and sends the results back to other

219
00:07:54,720 --> 00:07:58,720
parties

220
00:07:56,160 --> 00:08:00,639
finally all parties can locally subtract

221
00:07:58,720 --> 00:08:04,240
the random dvt sharing

222
00:08:00,639 --> 00:08:04,240
and obtain the share when they want

223
00:08:05,280 --> 00:08:09,440
we observe that all parties do not need

224
00:08:07,680 --> 00:08:12,000
to know the reconstruction

225
00:08:09,440 --> 00:08:14,639
reconstruction result p1 can instead

226
00:08:12,000 --> 00:08:17,199
distribute the sharing of the result

227
00:08:14,639 --> 00:08:18,800
all parties can still get the criteria

228
00:08:17,199 --> 00:08:20,720
ringing they want

229
00:08:18,800 --> 00:08:22,879
also we do not need to keep the

230
00:08:20,720 --> 00:08:25,599
reconstruction results secret

231
00:08:22,879 --> 00:08:26,879
p1 can choose the last t-shirts to be

232
00:08:25,599 --> 00:08:29,520
zero

233
00:08:26,879 --> 00:08:31,680
using this t-shirt and the secret e

234
00:08:29,520 --> 00:08:33,679
people reconstruct the whole sharing

235
00:08:31,680 --> 00:08:35,839
and only distribute the shares to the

236
00:08:33,679 --> 00:08:38,000
first t-plus one parties

237
00:08:35,839 --> 00:08:39,519
the last 30 parties take 0 as their

238
00:08:38,000 --> 00:08:41,599
shares

239
00:08:39,519 --> 00:08:43,599
these two observations allow us to

240
00:08:41,599 --> 00:08:48,000
reduce the communication cost

241
00:08:43,599 --> 00:08:48,000
from six elements to 5.5 elements

242
00:08:49,920 --> 00:08:53,040
now let's switch to a fully malicious

243
00:08:51,680 --> 00:08:54,479
adultery

244
00:08:53,040 --> 00:08:56,719
a fully malicious adultery can

245
00:08:54,480 --> 00:08:58,640
arbitrarily deviate from the protocol

246
00:08:56,720 --> 00:09:00,160
so it is clear that the dm protocol is

247
00:08:58,640 --> 00:09:01,360
no longer correct in the food of

248
00:09:00,160 --> 00:09:03,439
malaysia setting

249
00:09:01,360 --> 00:09:05,519
for example crowded parties can

250
00:09:03,440 --> 00:09:07,760
distribute inconsistent shearings

251
00:09:05,519 --> 00:09:08,560
or even refuse to participate in the

252
00:09:07,760 --> 00:09:11,279
competition

253
00:09:08,560 --> 00:09:11,279
at some point

254
00:09:12,240 --> 00:09:17,360
surprisingly it has been shown that dm

255
00:09:15,279 --> 00:09:17,920
protocol provides perfect privacy on the

256
00:09:17,360 --> 00:09:21,279
inputs

257
00:09:17,920 --> 00:09:23,040
of honest parties before output phase

258
00:09:21,279 --> 00:09:24,720
one approach to obtain the malicious

259
00:09:23,040 --> 00:09:26,719
security is to first

260
00:09:24,720 --> 00:09:28,800
run the dm protocol until the output

261
00:09:26,720 --> 00:09:29,839
phase then check the correctness of the

262
00:09:28,800 --> 00:09:32,719
computation

263
00:09:29,839 --> 00:09:33,360
and finally reconstruct the output note

264
00:09:32,720 --> 00:09:35,760
that

265
00:09:33,360 --> 00:09:36,640
addition gates are evaluated locally

266
00:09:35,760 --> 00:09:38,319
therefore

267
00:09:36,640 --> 00:09:40,800
it is sufficient to only check the

268
00:09:38,320 --> 00:09:42,720
correctness of multiplications

269
00:09:40,800 --> 00:09:44,160
this approach has been used in several

270
00:09:42,720 --> 00:09:46,480
previous works

271
00:09:44,160 --> 00:09:48,240
in our construction we rely on the

272
00:09:46,480 --> 00:09:51,040
technique in bbc g

273
00:09:48,240 --> 00:09:53,760
19 to achieve sub-linear communication

274
00:09:51,040 --> 00:09:57,120
in the number of multiplication gates

275
00:09:53,760 --> 00:09:58,800
compared with bbc g plus 19 we extend

276
00:09:57,120 --> 00:10:01,519
the use of this technique

277
00:09:58,800 --> 00:10:03,439
to the n-party setting the original

278
00:10:01,519 --> 00:10:05,519
technique is for zero knowledge and

279
00:10:03,440 --> 00:10:07,920
fully linear pcps

280
00:10:05,519 --> 00:10:10,079
we modify this technique to make it more

281
00:10:07,920 --> 00:10:12,640
suitable for mpc

282
00:10:10,079 --> 00:10:16,479
furthermore we explore recursion to make

283
00:10:12,640 --> 00:10:16,480
it even more efficient in practice

284
00:10:17,200 --> 00:10:20,320
our idea is inspired by two other

285
00:10:19,360 --> 00:10:22,480
techniques

286
00:10:20,320 --> 00:10:24,640
one is an extension of the dm protocol

287
00:10:22,480 --> 00:10:26,000
to handle inner product operations

288
00:10:24,640 --> 00:10:28,160
the other one is specialized

289
00:10:26,000 --> 00:10:29,920
multiplication verification introduced

290
00:10:28,160 --> 00:10:32,079
in bsf412

291
00:10:29,920 --> 00:10:32,959
and its extension for inner product

292
00:10:32,079 --> 00:10:36,479
operations

293
00:10:32,959 --> 00:10:38,000
introduced in envy 18. for the extension

294
00:10:36,480 --> 00:10:39,839
of the dm particle

295
00:10:38,000 --> 00:10:41,040
the main point is that all parties can

296
00:10:39,839 --> 00:10:43,519
locally obtain the

297
00:10:41,040 --> 00:10:44,160
2d sharing of the inner product of two

298
00:10:43,519 --> 00:10:47,440
vectors

299
00:10:44,160 --> 00:10:49,839
x and y then it is sufficient to do a

300
00:10:47,440 --> 00:10:52,000
deep reduction to this sharing

301
00:10:49,839 --> 00:10:53,760
this becomes the same problem solved by

302
00:10:52,000 --> 00:10:56,399
the dm particle

303
00:10:53,760 --> 00:10:58,399
note that the communication cost is

304
00:10:56,399 --> 00:11:01,360
independent of the dimension of this

305
00:10:58,399 --> 00:11:03,760
input vectors this extension has been

306
00:11:01,360 --> 00:11:08,560
observed and used in many previous works

307
00:11:03,760 --> 00:11:08,560
for example the work cgh plus 18.

308
00:11:09,200 --> 00:11:13,360
the second technique is spikewise

309
00:11:11,040 --> 00:11:16,000
multiplication verification

310
00:11:13,360 --> 00:11:17,120
given a bunch of m multiplication tuples

311
00:11:16,000 --> 00:11:19,279
the goal is to check

312
00:11:17,120 --> 00:11:21,519
whether all the tables are correct in

313
00:11:19,279 --> 00:11:22,880
fact combining the dm protocol

314
00:11:21,519 --> 00:11:25,519
and the brightweight multiplication

315
00:11:22,880 --> 00:11:27,439
verification already yields a secure

316
00:11:25,519 --> 00:11:30,959
with a board protocol

317
00:11:27,440 --> 00:11:33,200
this is exactly the construction in mb18

318
00:11:30,959 --> 00:11:35,518
however we will see that the

319
00:11:33,200 --> 00:11:38,160
verification requires additional m

320
00:11:35,519 --> 00:11:39,120
modulations where we want to verify the

321
00:11:38,160 --> 00:11:42,480
multiplications

322
00:11:39,120 --> 00:11:45,120
with sub-linear cost at a higher level

323
00:11:42,480 --> 00:11:45,680
we want to construct three polynomials f

324
00:11:45,120 --> 00:11:48,720
g and

325
00:11:45,680 --> 00:11:49,519
h such that for the first m evaluation

326
00:11:48,720 --> 00:11:53,040
points

327
00:11:49,519 --> 00:11:55,040
f i g i h i corresponds to the x

328
00:11:53,040 --> 00:11:56,880
multiplication tables

329
00:11:55,040 --> 00:11:58,880
furthermore we want these three

330
00:11:56,880 --> 00:12:01,680
polynomials to satisfy that

331
00:11:58,880 --> 00:12:04,079
h equals f times g if all the

332
00:12:01,680 --> 00:12:06,399
multiplication tables are correct

333
00:12:04,079 --> 00:12:07,279
in this way verifying multiplication

334
00:12:06,399 --> 00:12:09,680
tuples

335
00:12:07,279 --> 00:12:11,839
becomes verifying whether h equals f

336
00:12:09,680 --> 00:12:14,160
times g

337
00:12:11,839 --> 00:12:15,680
for example in this toy case where we

338
00:12:14,160 --> 00:12:17,920
have three tuples

339
00:12:15,680 --> 00:12:21,359
we can list the requirements for these

340
00:12:17,920 --> 00:12:21,360
three polynomials in the table

341
00:12:23,200 --> 00:12:27,600
note that for both f and g they can be

342
00:12:26,320 --> 00:12:30,000
polynomials of degree

343
00:12:27,600 --> 00:12:31,040
n minus 1. we can use the grand

344
00:12:30,000 --> 00:12:33,839
interpolation

345
00:12:31,040 --> 00:12:34,719
to compute the coefficients of f and g

346
00:12:33,839 --> 00:12:37,839
using x i

347
00:12:34,720 --> 00:12:40,720
and y i respectively if we want

348
00:12:37,839 --> 00:12:42,639
h to be f times g h should be a

349
00:12:40,720 --> 00:12:45,920
polynomial of degree two times

350
00:12:42,639 --> 00:12:48,560
n minus one however we only have

351
00:12:45,920 --> 00:12:51,120
m points which are insufficient to

352
00:12:48,560 --> 00:12:53,680
determine the polynomial h

353
00:12:51,120 --> 00:12:55,440
therefore we will complete build another

354
00:12:53,680 --> 00:12:57,279
element's 1 multiplications

355
00:12:55,440 --> 00:12:58,720
to provide enough points for the grand

356
00:12:57,279 --> 00:13:01,600
interpolation

357
00:12:58,720 --> 00:13:04,320
for example in this toy case we first

358
00:13:01,600 --> 00:13:07,200
can peel the shear runes of both f and g

359
00:13:04,320 --> 00:13:09,040
at the evaluation points 4 and 5. then

360
00:13:07,200 --> 00:13:12,639
compute the multiplications

361
00:13:09,040 --> 00:13:14,719
and the results are denoted by d4 and d5

362
00:13:12,639 --> 00:13:17,600
now we can do interpolation to compute

363
00:13:14,720 --> 00:13:17,600
the coefficients of

364
00:13:18,839 --> 00:13:22,639
h

365
00:13:20,160 --> 00:13:25,199
now we have our three polynomials to

366
00:13:22,639 --> 00:13:26,800
test whether h equals f times g

367
00:13:25,200 --> 00:13:28,800
it is sufficient to test a random

368
00:13:26,800 --> 00:13:30,719
evaluation point alpha

369
00:13:28,800 --> 00:13:33,439
all parties generate a random challenge

370
00:13:30,720 --> 00:13:36,880
alpha and compute three

371
00:13:33,440 --> 00:13:39,440
f alpha g alpha and h alpha

372
00:13:36,880 --> 00:13:39,920
note that this reduces the problem of

373
00:13:39,440 --> 00:13:42,160
checking

374
00:13:39,920 --> 00:13:44,160
m multiplications into a check of a

375
00:13:42,160 --> 00:13:46,000
single modification

376
00:13:44,160 --> 00:13:48,160
the overall communication cost of

377
00:13:46,000 --> 00:13:52,079
batteries multiplication verification

378
00:13:48,160 --> 00:13:52,079
is order of m multiplication dates

379
00:13:53,920 --> 00:13:57,199
an extension of the batch by

380
00:13:55,600 --> 00:13:59,120
multiplication verification

381
00:13:57,199 --> 00:14:01,359
is to check the correctness of a batch

382
00:13:59,120 --> 00:14:03,360
of m inner product tuples

383
00:14:01,360 --> 00:14:05,360
this extension is first noted in the

384
00:14:03,360 --> 00:14:07,279
work envy 18.

385
00:14:05,360 --> 00:14:09,440
the idea is basically the same as the

386
00:14:07,279 --> 00:14:11,760
check for multiplication tuples

387
00:14:09,440 --> 00:14:13,760
except that we will need additional m

388
00:14:11,760 --> 00:14:17,199
minus one inner product operations

389
00:14:13,760 --> 00:14:19,839
instead of multiplication of operations

390
00:14:17,199 --> 00:14:21,199
however recall that the dm protocol

391
00:14:19,839 --> 00:14:24,079
allows us to evaluate

392
00:14:21,199 --> 00:14:26,079
an inner product gate with the same cost

393
00:14:24,079 --> 00:14:28,880
as a multiplication bit

394
00:14:26,079 --> 00:14:29,519
therefore the communication cost of

395
00:14:28,880 --> 00:14:32,480
batch

396
00:14:29,519 --> 00:14:33,199
inner product verification is the same

397
00:14:32,480 --> 00:14:35,360
as the one

398
00:14:33,199 --> 00:14:36,560
for multiplication tuples that is

399
00:14:35,360 --> 00:14:40,320
requires order of

400
00:14:36,560 --> 00:14:42,239
m multiplication operations in essence

401
00:14:40,320 --> 00:14:44,320
this technique allows us to reduce the

402
00:14:42,240 --> 00:14:46,320
check of m inner product tuples

403
00:14:44,320 --> 00:14:48,720
into one check of a single inner product

404
00:14:46,320 --> 00:14:48,720
tuple

405
00:14:50,240 --> 00:14:54,160
given and multiplication tuples our idea

406
00:14:53,279 --> 00:14:56,399
is to first

407
00:14:54,160 --> 00:14:58,000
transform these m tuples to a single

408
00:14:56,399 --> 00:15:01,760
inner product tuple of dimension

409
00:14:58,000 --> 00:15:04,320
m furthermore if one of the original

410
00:15:01,760 --> 00:15:05,760
multiplication tuples is incorrect this

411
00:15:04,320 --> 00:15:07,199
single inner product table should also

412
00:15:05,760 --> 00:15:09,519
be incorrect

413
00:15:07,199 --> 00:15:13,839
therefore it is sufficient to only check

414
00:15:09,519 --> 00:15:13,839
the single inner black tuple

415
00:15:14,160 --> 00:15:18,319
to obtain a single inner product tuple a

416
00:15:16,480 --> 00:15:18,880
straightforward way is to set the first

417
00:15:18,320 --> 00:15:22,000
vector

418
00:15:18,880 --> 00:15:25,439
x to be x1 x2 to xm

419
00:15:22,000 --> 00:15:26,000
y to be y1 y2 to ym and z to be the

420
00:15:25,440 --> 00:15:29,680
summation

421
00:15:26,000 --> 00:15:32,959
of zi however this is not sufficient

422
00:15:29,680 --> 00:15:37,120
for example if the adultery causes c1

423
00:15:32,959 --> 00:15:39,199
to be x1 times y1 plus 1 and d2 to be x2

424
00:15:37,120 --> 00:15:43,120
times y2 minus 1

425
00:15:39,199 --> 00:15:43,120
the errors are cancelled in this tuple

426
00:15:43,199 --> 00:15:46,479
consider the following two polynomials f

427
00:15:45,199 --> 00:15:49,599
and g

428
00:15:46,480 --> 00:15:53,199
the coefficients of f are x i times y

429
00:15:49,600 --> 00:15:55,120
i the coefficients of g are zi

430
00:15:53,199 --> 00:15:56,479
then the task becomes checking whether

431
00:15:55,120 --> 00:15:59,040
these two polynomials

432
00:15:56,480 --> 00:16:00,320
are the same which can be done by

433
00:15:59,040 --> 00:16:03,360
testing a random point

434
00:16:00,320 --> 00:16:06,560
a random point alpha therefore

435
00:16:03,360 --> 00:16:10,000
we can set the shearing x y v

436
00:16:06,560 --> 00:16:12,000
in this form we can verify that the

437
00:16:10,000 --> 00:16:15,440
inner product between x and y

438
00:16:12,000 --> 00:16:17,279
is f alpha and z is g and alpha

439
00:16:15,440 --> 00:16:20,160
this way we only need to check the

440
00:16:17,279 --> 00:16:20,160
single inner product

441
00:16:21,759 --> 00:16:25,920
however we note that the dimension of

442
00:16:24,560 --> 00:16:27,839
this inner duct table is

443
00:16:25,920 --> 00:16:29,839
m where m is the number of

444
00:16:27,839 --> 00:16:32,399
multiplication gates

445
00:16:29,839 --> 00:16:34,959
even checking a single input tuple would

446
00:16:32,399 --> 00:16:37,360
cause us proportional to m

447
00:16:34,959 --> 00:16:38,479
therefore our idea is to reduce

448
00:16:37,360 --> 00:16:40,560
dimension

449
00:16:38,480 --> 00:16:43,120
by a factor of k where k is the

450
00:16:40,560 --> 00:16:43,119
parameter

451
00:16:45,279 --> 00:16:50,399
in step two we want to reduce the

452
00:16:47,360 --> 00:16:52,560
dimension by a factor of k

453
00:16:50,399 --> 00:16:53,600
for each of the two input vectors we

454
00:16:52,560 --> 00:16:57,279
separate it into

455
00:16:53,600 --> 00:17:00,079
k sub vectors of the same dimensions

456
00:16:57,279 --> 00:17:01,600
by using the dn inner product protocol

457
00:17:00,079 --> 00:17:03,920
all parts computed

458
00:17:01,600 --> 00:17:05,599
the inner products for each pair of x i

459
00:17:03,920 --> 00:17:07,678
and the y i

460
00:17:05,599 --> 00:17:08,719
for the last pair instead of using the

461
00:17:07,679 --> 00:17:12,079
dm protocol

462
00:17:08,720 --> 00:17:12,799
we simply set dk to be to be z minus the

463
00:17:12,079 --> 00:17:17,198
summation

464
00:17:12,799 --> 00:17:18,959
of the first k mass 1 result in this way

465
00:17:17,199 --> 00:17:20,880
if the original inner product table is

466
00:17:18,959 --> 00:17:23,679
incorrect then at least

467
00:17:20,880 --> 00:17:25,280
one of the new inner product tuples is

468
00:17:23,679 --> 00:17:27,280
incorrect

469
00:17:25,280 --> 00:17:28,639
therefore we only need to check the

470
00:17:27,280 --> 00:17:31,280
correctness of this new

471
00:17:28,640 --> 00:17:33,200
k uniblock tuples note that the

472
00:17:31,280 --> 00:17:36,320
communication cost is just the k

473
00:17:33,200 --> 00:17:36,320
multiplication operations

474
00:17:36,960 --> 00:17:40,880
to this end we use the backwards inner

475
00:17:39,280 --> 00:17:42,960
product verification

476
00:17:40,880 --> 00:17:44,559
to reduce the check of k inner black

477
00:17:42,960 --> 00:17:46,880
doubles into a check

478
00:17:44,559 --> 00:17:48,160
of a single inner product type in

479
00:17:46,880 --> 00:17:51,200
particular

480
00:17:48,160 --> 00:17:54,240
the dimension becomes m

481
00:17:51,200 --> 00:17:56,240
the dimension becomes m over k the

482
00:17:54,240 --> 00:17:58,160
overall communication cost of step two

483
00:17:56,240 --> 00:18:00,240
is just out of k communicate

484
00:17:58,160 --> 00:18:03,120
multiplication operations which is

485
00:18:00,240 --> 00:18:03,120
independent of m

486
00:18:05,200 --> 00:18:09,039
in the last step we just repeat step two

487
00:18:08,160 --> 00:18:10,880
enough times

488
00:18:09,039 --> 00:18:14,240
until the dimension of the final step

489
00:18:10,880 --> 00:18:16,000
becomes the final tuple becomes 1.

490
00:18:14,240 --> 00:18:18,400
to simplify the verification of the

491
00:18:16,000 --> 00:18:21,600
final tuple we borrow the idea from

492
00:18:18,400 --> 00:18:24,080
m18 in the final iteration we add a

493
00:18:21,600 --> 00:18:26,080
random multiplication typo as a mask

494
00:18:24,080 --> 00:18:28,000
this allows us to directly open the

495
00:18:26,080 --> 00:18:30,399
final multiplication tuple

496
00:18:28,000 --> 00:18:31,520
and check the correctness as for

497
00:18:30,400 --> 00:18:34,240
efficiency

498
00:18:31,520 --> 00:18:35,440
we need to repeat log km temps in step

499
00:18:34,240 --> 00:18:38,000
3.

500
00:18:35,440 --> 00:18:38,799
since each iteration requires order of k

501
00:18:38,000 --> 00:18:41,280
multiplication

502
00:18:38,799 --> 00:18:42,240
operations the overall communication

503
00:18:41,280 --> 00:18:45,039
complexity

504
00:18:42,240 --> 00:18:46,160
is order of k times log k n or multi

505
00:18:45,039 --> 00:18:49,440
multiplications

506
00:18:46,160 --> 00:18:49,440
which is sublinear in m

507
00:18:51,039 --> 00:18:54,960
a follow-up work has implemented our

508
00:18:53,200 --> 00:18:56,480
protocol and compared with the

509
00:18:54,960 --> 00:18:58,720
previously best known

510
00:18:56,480 --> 00:19:02,400
implementation result the work by

511
00:18:58,720 --> 00:19:04,640
cheetah and others in crypto 2018.

512
00:19:02,400 --> 00:19:06,720
the experiments use arithmetic circuit

513
00:19:04,640 --> 00:19:09,679
with 1 million multiplication dates

514
00:19:06,720 --> 00:19:12,160
in the line setting the finite field is

515
00:19:09,679 --> 00:19:14,240
the 61-bit merchant field

516
00:19:12,160 --> 00:19:15,840
all the numbers are the running time in

517
00:19:14,240 --> 00:19:17,360
milliseconds

518
00:19:15,840 --> 00:19:19,840
we select two different kinds of

519
00:19:17,360 --> 00:19:22,559
circuits one can have steps 20

520
00:19:19,840 --> 00:19:24,639
and the other one has depth of thousand

521
00:19:22,559 --> 00:19:26,399
different calls respond to different

522
00:19:24,640 --> 00:19:27,440
number of parties participating in the

523
00:19:26,400 --> 00:19:29,440
computation

524
00:19:27,440 --> 00:19:32,480
we can see that when the circuit depth

525
00:19:29,440 --> 00:19:33,520
is 20 our protocol is about 1.7 times

526
00:19:32,480 --> 00:19:35,679
faster

527
00:19:33,520 --> 00:19:36,559
when the circuit depth is a thousand our

528
00:19:35,679 --> 00:19:40,880
particle is about

529
00:19:36,559 --> 00:19:41,520
1.6 times faster this experiment results

530
00:19:40,880 --> 00:19:43,360
show that

531
00:19:41,520 --> 00:19:45,840
our particle is also efficient in

532
00:19:43,360 --> 00:19:45,840
practice

533
00:19:46,480 --> 00:19:50,000
so far we have shown how to efficiently

534
00:19:48,960 --> 00:19:52,559
check the correctness

535
00:19:50,000 --> 00:19:53,520
of multiplications combining with the dm

536
00:19:52,559 --> 00:19:55,120
protocol

537
00:19:53,520 --> 00:19:57,600
we obtain a secure with the board

538
00:19:55,120 --> 00:19:59,439
protocol with the same efficiency as the

539
00:19:57,600 --> 00:20:01,840
semi-onstream protocol

540
00:19:59,440 --> 00:20:03,120
in the last part we will focus on full

541
00:20:01,840 --> 00:20:05,120
security

542
00:20:03,120 --> 00:20:08,799
our protocol is obtained by compiling

543
00:20:05,120 --> 00:20:08,799
the secure wizard board protocol

544
00:20:09,440 --> 00:20:15,120
at a high level we follow the idea of

545
00:20:11,679 --> 00:20:17,039
this build control introduced in bth06

546
00:20:15,120 --> 00:20:19,520
this is a general strategy to achieve

547
00:20:17,039 --> 00:20:21,840
for security efficiently

548
00:20:19,520 --> 00:20:23,520
the idea is to divide the circuit into

549
00:20:21,840 --> 00:20:25,840
small segments

550
00:20:23,520 --> 00:20:27,120
then all parts evaluate each segment in

551
00:20:25,840 --> 00:20:29,280
sequence

552
00:20:27,120 --> 00:20:30,959
when the computation boards all parties

553
00:20:29,280 --> 00:20:34,000
find the virus transmitted wrong

554
00:20:30,960 --> 00:20:35,679
and then rerun the current segment when

555
00:20:34,000 --> 00:20:38,400
we look into a transcript

556
00:20:35,679 --> 00:20:40,640
of an aborted communication either there

557
00:20:38,400 --> 00:20:41,679
is a corrupted party who does not follow

558
00:20:40,640 --> 00:20:44,080
the broadcast

559
00:20:41,679 --> 00:20:45,200
or there is a pair of parties who do not

560
00:20:44,080 --> 00:20:48,240
agree on the message

561
00:20:45,200 --> 00:20:49,840
sent from one party to the other

562
00:20:48,240 --> 00:20:52,400
the main difficulty of using this build

563
00:20:49,840 --> 00:20:53,600
control is to efficiently identify

564
00:20:52,400 --> 00:20:57,919
crafty parties

565
00:20:53,600 --> 00:20:57,918
or disputed parties when the computation

566
00:21:00,840 --> 00:21:04,158
aborts

567
00:21:02,320 --> 00:21:05,678
that in our secure with the board

568
00:21:04,159 --> 00:21:07,440
protocol in the end of the

569
00:21:05,679 --> 00:21:09,679
multiplication verification

570
00:21:07,440 --> 00:21:11,600
all parties only need to verify a single

571
00:21:09,679 --> 00:21:13,200
multiplication tuple

572
00:21:11,600 --> 00:21:16,320
our idea is to compute a word of

573
00:21:13,200 --> 00:21:19,200
transcript of this ultimate table

574
00:21:16,320 --> 00:21:21,280
a virtuous virtual transcript is not

575
00:21:19,200 --> 00:21:23,840
executed but all parties should agree on

576
00:21:21,280 --> 00:21:26,080
the messages appearing on the transcript

577
00:21:23,840 --> 00:21:27,600
concretely all parties will together

578
00:21:26,080 --> 00:21:30,000
compute over the transcript

579
00:21:27,600 --> 00:21:32,320
of the ultimate tuple as if they

580
00:21:30,000 --> 00:21:33,679
directly compute this tuple using the dm

581
00:21:32,320 --> 00:21:35,918
protocol

582
00:21:33,679 --> 00:21:36,799
in this case if the ultimate table is

583
00:21:35,919 --> 00:21:38,720
incorrect

584
00:21:36,799 --> 00:21:40,879
it is sufficient to only examine this

585
00:21:38,720 --> 00:21:42,720
virtual transcript

586
00:21:40,880 --> 00:21:45,039
our idea is to follow the multiplication

587
00:21:42,720 --> 00:21:46,480
verification of our secure with the bar

588
00:21:45,039 --> 00:21:49,360
protocol

589
00:21:46,480 --> 00:21:51,520
at each step we will compute a virtual

590
00:21:49,360 --> 00:21:54,959
transcript from the transcripts of the

591
00:21:51,520 --> 00:21:55,760
input tuples one feature of our approach

592
00:21:54,960 --> 00:21:57,919
is that

593
00:21:55,760 --> 00:22:00,320
all virtual transcripts can be computed

594
00:21:57,919 --> 00:22:02,000
without interaction

595
00:22:00,320 --> 00:22:03,760
it means that we can obtain virtual

596
00:22:02,000 --> 00:22:05,760
transcripts for free

597
00:22:03,760 --> 00:22:06,960
and the overall communication complexity

598
00:22:05,760 --> 00:22:10,799
remains the same

599
00:22:06,960 --> 00:22:10,799
as the secure with the board protocol

600
00:22:11,760 --> 00:22:15,679
we'll briefly discuss other issues of

601
00:22:14,000 --> 00:22:17,840
achievement for security

602
00:22:15,679 --> 00:22:18,960
the first one is how the protocol is

603
00:22:17,840 --> 00:22:21,840
perceived if

604
00:22:18,960 --> 00:22:22,320
one or more crop parties support note

605
00:22:21,840 --> 00:22:24,959
that

606
00:22:22,320 --> 00:22:26,399
when we use the dm protocol to evaluate

607
00:22:24,960 --> 00:22:28,480
the multiplication dates

608
00:22:26,400 --> 00:22:31,120
the first party needs all the shares to

609
00:22:28,480 --> 00:22:34,080
reconstruct a deep 2d sharing

610
00:22:31,120 --> 00:22:35,918
when one or more crop parties abort p1

611
00:22:34,080 --> 00:22:39,760
will not receive enough shares to do

612
00:22:35,919 --> 00:22:42,080
the reconstructions our idea is to do a

613
00:22:39,760 --> 00:22:44,559
small surgery to the input sharing

614
00:22:42,080 --> 00:22:47,520
of each multiplication gate such that

615
00:22:44,559 --> 00:22:49,918
the shares of aborted parties are zero

616
00:22:47,520 --> 00:22:52,559
in this way py no longer needs the

617
00:22:49,919 --> 00:22:54,320
aborted parties to send their shares

618
00:22:52,559 --> 00:22:57,120
our approach only requires two

619
00:22:54,320 --> 00:23:00,320
additional elements per party

620
00:22:57,120 --> 00:23:03,120
this results in 7.5 field elements when

621
00:23:00,320 --> 00:23:05,280
one or more crops party support

622
00:23:03,120 --> 00:23:07,439
the second problem is that when we

623
00:23:05,280 --> 00:23:10,080
examine the ultimate transcript

624
00:23:07,440 --> 00:23:11,679
we may find that the input sharings or

625
00:23:10,080 --> 00:23:13,439
the random double sharings are

626
00:23:11,679 --> 00:23:16,400
inconsistent

627
00:23:13,440 --> 00:23:18,640
note that the virtual transcript do not

628
00:23:16,400 --> 00:23:20,400
contain the generation of these sharings

629
00:23:18,640 --> 00:23:23,120
we cannot know which party is cheating

630
00:23:20,400 --> 00:23:25,039
by just checking the word of transcript

631
00:23:23,120 --> 00:23:27,840
instead we need to go back to the

632
00:23:25,039 --> 00:23:30,520
generation precise of these sharings

633
00:23:27,840 --> 00:23:32,080
to this end we borrowed the idea from

634
00:23:30,520 --> 00:23:34,240
bsf-12

635
00:23:32,080 --> 00:23:35,678
to add verifiability to shamelessly

636
00:23:34,240 --> 00:23:38,000
sharing

637
00:23:35,679 --> 00:23:39,600
this technique has overhead only epsilon

638
00:23:38,000 --> 00:23:41,600
elements per party per gate

639
00:23:39,600 --> 00:23:43,279
where epsilon is an arbitrarily small

640
00:23:41,600 --> 00:23:44,879
constant

641
00:23:43,279 --> 00:23:47,120
we refer to our paper for more

642
00:23:44,880 --> 00:23:50,960
discussion about these two problems

643
00:23:47,120 --> 00:23:53,360
and our solutions

644
00:23:50,960 --> 00:23:55,360
as the conclusion we first see the

645
00:23:53,360 --> 00:23:57,678
construction of dm protocol which is the

646
00:23:55,360 --> 00:23:59,760
best known semi-arts protocol

647
00:23:57,679 --> 00:24:01,600
surprisingly dm protocol provides some

648
00:23:59,760 --> 00:24:03,360
kind of security when running in the

649
00:24:01,600 --> 00:24:04,959
fully managed setting

650
00:24:03,360 --> 00:24:06,639
based on this observation and the

651
00:24:04,960 --> 00:24:09,600
technique in bbc g

652
00:24:06,640 --> 00:24:10,559
19 we are able to achieve security with

653
00:24:09,600 --> 00:24:12,399
the board

654
00:24:10,559 --> 00:24:13,840
with the same efficiency as the dm

655
00:24:12,400 --> 00:24:16,799
protocol

656
00:24:13,840 --> 00:24:18,000
to further achieve full security we rely

657
00:24:16,799 --> 00:24:21,520
on the general strategy

658
00:24:18,000 --> 00:24:23,679
called disbuild control however

659
00:24:21,520 --> 00:24:27,440
three problems arise when considering

660
00:24:23,679 --> 00:24:30,000
the detailed design of the protocol

661
00:24:27,440 --> 00:24:30,720
we rely on the world of transcript small

662
00:24:30,000 --> 00:24:32,480
surgery

663
00:24:30,720 --> 00:24:34,240
and a very variable sequential ring to

664
00:24:32,480 --> 00:24:36,720
overcome the difficulties

665
00:24:34,240 --> 00:24:38,240
and finally achieve full security with

666
00:24:36,720 --> 00:24:41,279
comparable efficiency

667
00:24:38,240 --> 00:24:41,279
as the dm protocol

668
00:24:41,919 --> 00:24:47,840
thank you

