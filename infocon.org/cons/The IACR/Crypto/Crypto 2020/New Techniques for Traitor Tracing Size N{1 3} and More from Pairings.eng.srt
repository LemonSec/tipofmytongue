1
00:00:00,880 --> 00:00:05,680
today i will be talking about some new

2
00:00:02,639 --> 00:00:07,919
results for trader tracing

3
00:00:05,680 --> 00:00:10,160
trader tracing solves the following

4
00:00:07,919 --> 00:00:12,320
problem we have a content distributor

5
00:00:10,160 --> 00:00:13,920
who is encrypting a broadcast to a bunch

6
00:00:12,320 --> 00:00:17,680
of recipients

7
00:00:13,920 --> 00:00:21,198
each recipient has their own secret key

8
00:00:17,680 --> 00:00:22,480
what we are concerned about is that one

9
00:00:21,199 --> 00:00:25,359
of the recipients

10
00:00:22,480 --> 00:00:26,560
may take their secret key and distribute

11
00:00:25,359 --> 00:00:28,960
it

12
00:00:26,560 --> 00:00:30,000
and maybe they distribute their secret

13
00:00:28,960 --> 00:00:33,840
key in the clear

14
00:00:30,000 --> 00:00:38,320
or maybe they embed it in some sort of

15
00:00:33,840 --> 00:00:40,640
decoder device what the

16
00:00:38,320 --> 00:00:42,160
content distributor would like to do is

17
00:00:40,640 --> 00:00:45,039
if they ever come across

18
00:00:42,160 --> 00:00:47,519
such a decoder device they want to be

19
00:00:45,039 --> 00:00:49,280
able to identify the trader

20
00:00:47,520 --> 00:00:51,440
and we want to make sure that they can

21
00:00:49,280 --> 00:00:52,160
identify the trader even if arbitrarily

22
00:00:51,440 --> 00:00:54,160
many

23
00:00:52,160 --> 00:00:55,919
users collude in order to build the

24
00:00:54,160 --> 00:00:58,800
decoder

25
00:00:55,920 --> 00:01:00,239
and also even if the decoder doesn't

26
00:00:58,800 --> 00:01:03,519
always work even if it fails

27
00:01:00,239 --> 00:01:05,280
most of the time to decrypt

28
00:01:03,520 --> 00:01:08,240
an encrypted broadcast we still want to

29
00:01:05,280 --> 00:01:12,400
be able to trace the decoder to

30
00:01:08,240 --> 00:01:13,839
one of the traders

31
00:01:12,400 --> 00:01:15,600
uh so i want to spend a little bit of

32
00:01:13,840 --> 00:01:17,439
time talking about what the main

33
00:01:15,600 --> 00:01:20,320
objective in trader tracing is

34
00:01:17,439 --> 00:01:22,240
it turns out it's easy to build a trader

35
00:01:20,320 --> 00:01:24,158
tracing scheme what is difficult is to

36
00:01:22,240 --> 00:01:27,199
build a trader tracing scheme

37
00:01:24,159 --> 00:01:28,960
uh with small parameters so um

38
00:01:27,200 --> 00:01:30,400
if you'd asked me a few years ago i

39
00:01:28,960 --> 00:01:31,759
would have said the goal

40
00:01:30,400 --> 00:01:33,360
of trader tracing is to build a

41
00:01:31,759 --> 00:01:34,000
collusion resistant trader tracing

42
00:01:33,360 --> 00:01:37,119
scheme

43
00:01:34,000 --> 00:01:39,040
where the ciphertext overhead is

44
00:01:37,119 --> 00:01:40,479
minimized in terms of the number of

45
00:01:39,040 --> 00:01:42,880
users and

46
00:01:40,479 --> 00:01:46,320
this sentiment was is common to much of

47
00:01:42,880 --> 00:01:49,520
the literature on trader tracing

48
00:01:46,320 --> 00:01:53,679
uh however this is not the

49
00:01:49,520 --> 00:01:56,640
entire picture uh because in 2002

50
00:01:53,680 --> 00:01:58,000
bonaire nauer showed how to use general

51
00:01:56,640 --> 00:01:59,680
public key encryption

52
00:01:58,000 --> 00:02:01,520
to get the trader tracing scheme where

53
00:01:59,680 --> 00:02:02,399
the ciphertext overhead is actually very

54
00:02:01,520 --> 00:02:04,399
small

55
00:02:02,399 --> 00:02:05,920
it's just two ciphertexts in particular

56
00:02:04,399 --> 00:02:08,239
constant and independent of the number

57
00:02:05,920 --> 00:02:10,959
of users

58
00:02:08,239 --> 00:02:12,879
all right so what have we been doing for

59
00:02:10,959 --> 00:02:15,040
the last 18 years if we've already

60
00:02:12,879 --> 00:02:16,079
solved the problem of small cycle check

61
00:02:15,040 --> 00:02:18,319
size

62
00:02:16,080 --> 00:02:20,840
uh well there's a couple different views

63
00:02:18,319 --> 00:02:23,359
on why the bonnet now our scheme doesn't

64
00:02:20,840 --> 00:02:24,800
count uh one view

65
00:02:23,360 --> 00:02:27,040
that you'll find in much of the

66
00:02:24,800 --> 00:02:27,920
literature is that the bonnet narrower

67
00:02:27,040 --> 00:02:30,079
scheme

68
00:02:27,920 --> 00:02:31,920
doesn't meet the usual definition we

69
00:02:30,080 --> 00:02:33,440
want in the sense that it is only a

70
00:02:31,920 --> 00:02:35,920
threshold scheme

71
00:02:33,440 --> 00:02:37,359
what a threshold tracing scheme means is

72
00:02:35,920 --> 00:02:39,760
that you can only

73
00:02:37,360 --> 00:02:41,360
trace the decoder if they decrypt most

74
00:02:39,760 --> 00:02:42,640
of the time and remember we said we want

75
00:02:41,360 --> 00:02:46,319
to

76
00:02:42,640 --> 00:02:49,518
trace decoders that decrypt very very

77
00:02:46,319 --> 00:02:51,839
even very very rarely um

78
00:02:49,519 --> 00:02:53,760
now the this this constant 0.9 is

79
00:02:51,840 --> 00:02:56,080
somewhat arbitrary but we can

80
00:02:53,760 --> 00:02:58,480
imagine and we can imagine shrinking it

81
00:02:56,080 --> 00:03:02,080
but the idea is that once you have fixed

82
00:02:58,480 --> 00:03:03,518
the percentage of the time that you want

83
00:03:02,080 --> 00:03:05,760
the decoder to decrypt

84
00:03:03,519 --> 00:03:06,640
you can actually easily fool tracing by

85
00:03:05,760 --> 00:03:08,480
decrypting

86
00:03:06,640 --> 00:03:10,399
slightly less often so if you decrypt it

87
00:03:08,480 --> 00:03:12,640
with probability 0.8

88
00:03:10,400 --> 00:03:14,480
in this case you can actually avoid

89
00:03:12,640 --> 00:03:17,679
tracing

90
00:03:14,480 --> 00:03:20,159
the other problem with the bonne nauer

91
00:03:17,680 --> 00:03:22,000
trader tracing scheme is that the secret

92
00:03:20,159 --> 00:03:23,040
keys are extremely large they're namely

93
00:03:22,000 --> 00:03:25,360
quadratic

94
00:03:23,040 --> 00:03:26,798
in the number of users and being

95
00:03:25,360 --> 00:03:29,120
quadratic in the number of users is

96
00:03:26,799 --> 00:03:32,959
considered too large

97
00:03:29,120 --> 00:03:35,680
to be useful based on

98
00:03:32,959 --> 00:03:38,640
these problems uh identified with the

99
00:03:35,680 --> 00:03:41,840
bonne nara scheme i want to take a

100
00:03:38,640 --> 00:03:43,279
more general view of what the goal of

101
00:03:41,840 --> 00:03:45,440
trader tracing is

102
00:03:43,280 --> 00:03:47,760
so if you ask me today i would say the

103
00:03:45,440 --> 00:03:49,359
main goal of trader tracing is to build

104
00:03:47,760 --> 00:03:51,120
a collusion resistant trader tracing

105
00:03:49,360 --> 00:03:52,400
scheme that offers the best parameter

106
00:03:51,120 --> 00:03:55,280
side tradeoffs

107
00:03:52,400 --> 00:03:57,280
in terms of the number of users n and

108
00:03:55,280 --> 00:03:59,200
ideally we would do this also without

109
00:03:57,280 --> 00:04:01,680
the threshold limitation

110
00:03:59,200 --> 00:04:02,879
okay so this is going to be the

111
00:04:01,680 --> 00:04:06,319
overarching goal

112
00:04:02,879 --> 00:04:07,920
of this talk all right so let me just

113
00:04:06,319 --> 00:04:11,599
introduce some notation

114
00:04:07,920 --> 00:04:12,958
so we have uh there's three parameters

115
00:04:11,599 --> 00:04:14,959
of interest in trader tracing there's a

116
00:04:12,959 --> 00:04:16,399
public key size the secret key size and

117
00:04:14,959 --> 00:04:19,840
the ciphertext size

118
00:04:16,399 --> 00:04:20,880
and i will use uh the notation this

119
00:04:19,839 --> 00:04:24,320
triple

120
00:04:20,880 --> 00:04:27,120
of functions of n to

121
00:04:24,320 --> 00:04:29,280
denote the public key secret key and

122
00:04:27,120 --> 00:04:31,919
cipher check size respectively

123
00:04:29,280 --> 00:04:33,679
so what is known uh so on the right here

124
00:04:31,919 --> 00:04:35,599
we have some schemes that are

125
00:04:33,680 --> 00:04:38,000
built from generic tools like public key

126
00:04:35,600 --> 00:04:41,440
encryption or identity based encryption

127
00:04:38,000 --> 00:04:43,199
um so up on the upper right is sort of a

128
00:04:41,440 --> 00:04:43,680
very easy way to build trader tracing

129
00:04:43,199 --> 00:04:46,400
that we'll

130
00:04:43,680 --> 00:04:48,080
talk a little bit more about later and

131
00:04:46,400 --> 00:04:50,080
at the bottom on the right is

132
00:04:48,080 --> 00:04:52,719
the bone in our scheme with its

133
00:04:50,080 --> 00:04:56,639
quadratic secret keys and constant size

134
00:04:52,720 --> 00:04:59,680
ciphertext now here on the bottom left

135
00:04:56,639 --> 00:05:01,440
we have some algebraic schemes that

136
00:04:59,680 --> 00:05:03,440
improve on these parameters

137
00:05:01,440 --> 00:05:04,880
uh we have a scheme from pairings from

138
00:05:03,440 --> 00:05:07,360
bones to high and waters

139
00:05:04,880 --> 00:05:09,280
that gets end to the one half public

140
00:05:07,360 --> 00:05:10,720
keys and cipher text with constant size

141
00:05:09,280 --> 00:05:14,239
secret keys

142
00:05:10,720 --> 00:05:16,160
and then some improvements using um the

143
00:05:14,240 --> 00:05:17,919
sophisticated tool of

144
00:05:16,160 --> 00:05:21,120
indistinguishability obfuscation

145
00:05:17,919 --> 00:05:23,520
which simultaneously gets all

146
00:05:21,120 --> 00:05:25,120
parameters to be constant size and then

147
00:05:23,520 --> 00:05:27,198
more recently

148
00:05:25,120 --> 00:05:28,320
goyal coppola and waters were able to

149
00:05:27,199 --> 00:05:32,560
achieve similar

150
00:05:28,320 --> 00:05:32,560
parameter sizes but from lwe

151
00:05:33,039 --> 00:05:36,320
so based on the the current state of the

152
00:05:35,520 --> 00:05:39,198
art

153
00:05:36,320 --> 00:05:40,000
we can identify a few interesting open

154
00:05:39,199 --> 00:05:43,759
questions

155
00:05:40,000 --> 00:05:44,880
so the first one is from generic uh even

156
00:05:43,759 --> 00:05:47,440
if you're going to

157
00:05:44,880 --> 00:05:50,159
ignore the threshold limitation and

158
00:05:47,440 --> 00:05:53,600
allow for threshold tracing schemes

159
00:05:50,160 --> 00:05:56,479
is there a way to achieve sub-quadratic

160
00:05:53,600 --> 00:05:58,080
secret keys and sub-linear ciphertext

161
00:05:56,479 --> 00:06:00,960
from any of the following tools public

162
00:05:58,080 --> 00:06:03,520
key encryption identity-based encryption

163
00:06:00,960 --> 00:06:07,280
groups without a pairing operation or

164
00:06:03,520 --> 00:06:10,080
any factoring-like assumptions

165
00:06:07,280 --> 00:06:11,840
uh another open question is again even

166
00:06:10,080 --> 00:06:14,318
if we don't care about

167
00:06:11,840 --> 00:06:16,400
the threshold tracing limitation is can

168
00:06:14,319 --> 00:06:20,080
you get subquadratic

169
00:06:16,400 --> 00:06:23,198
secret keys and sub root and cipher text

170
00:06:20,080 --> 00:06:26,400
from pairings and then

171
00:06:23,199 --> 00:06:29,440
lastly let's even let's insist on

172
00:06:26,400 --> 00:06:31,120
threshold tracing but now ignore public

173
00:06:29,440 --> 00:06:33,600
key and secret key size

174
00:06:31,120 --> 00:06:36,000
is there any way to get sub root and

175
00:06:33,600 --> 00:06:40,639
cipher text from anything other than

176
00:06:36,000 --> 00:06:44,479
lwe and indistinguishability obfuscation

177
00:06:40,639 --> 00:06:47,360
so one observation is that

178
00:06:44,479 --> 00:06:49,280
if that all the best collusion

179
00:06:47,360 --> 00:06:51,440
resistance schemes from the literature

180
00:06:49,280 --> 00:06:53,119
follow something called a private linear

181
00:06:51,440 --> 00:06:55,120
broadcast description or plbe which i'll

182
00:06:53,120 --> 00:06:57,680
describe on the next slide

183
00:06:55,120 --> 00:06:58,960
and by best i mean that well you could

184
00:06:57,680 --> 00:07:00,800
take it to mean multiple things you

185
00:06:58,960 --> 00:07:02,960
could take it either to mean

186
00:07:00,800 --> 00:07:04,800
no threshold limitation or you could

187
00:07:02,960 --> 00:07:05,359
take it to mean where all the parameter

188
00:07:04,800 --> 00:07:07,199
sizes

189
00:07:05,360 --> 00:07:08,560
are sublinear so so basically all of the

190
00:07:07,199 --> 00:07:12,400
best schemes

191
00:07:08,560 --> 00:07:13,919
uh more or less follow the same approach

192
00:07:12,400 --> 00:07:16,318
which is this private linear broadcast

193
00:07:13,919 --> 00:07:18,960
encryption so what is this

194
00:07:16,319 --> 00:07:21,199
private linear broadcast encryption is a

195
00:07:18,960 --> 00:07:24,000
type of broadcast encryption

196
00:07:21,199 --> 00:07:26,319
where every user is given a number from

197
00:07:24,000 --> 00:07:28,400
one to n

198
00:07:26,319 --> 00:07:31,520
and when you encrypt you can specify an

199
00:07:28,400 --> 00:07:33,919
index j

200
00:07:31,520 --> 00:07:35,039
the encrypted broadcast can then be

201
00:07:33,919 --> 00:07:37,758
decrypted

202
00:07:35,039 --> 00:07:40,719
by any user whose identity is less than

203
00:07:37,759 --> 00:07:42,400
or equal to the index j

204
00:07:40,720 --> 00:07:44,720
on the other hand if your identity is

205
00:07:42,400 --> 00:07:47,280
greater than the index j then you

206
00:07:44,720 --> 00:07:47,919
cannot learn the message the additional

207
00:07:47,280 --> 00:07:50,400
requirement

208
00:07:47,919 --> 00:07:51,758
is that essentially the index j is

209
00:07:50,400 --> 00:07:53,919
hidden now of course

210
00:07:51,759 --> 00:07:55,599
a user i learns whether they decrypt or

211
00:07:53,919 --> 00:07:56,639
not and therefore learns whether i is

212
00:07:55,599 --> 00:07:58,560
less than or equal to j

213
00:07:56,639 --> 00:08:01,520
but the user should learn nothing else

214
00:07:58,560 --> 00:08:01,520
about the index j

215
00:08:02,160 --> 00:08:06,800
now what uh we know as proven by bones

216
00:08:05,520 --> 00:08:08,318
sahayan waters

217
00:08:06,800 --> 00:08:09,840
is that if you have a private linear

218
00:08:08,319 --> 00:08:11,759
broadcast encryption

219
00:08:09,840 --> 00:08:15,679
this actually implies a trader tracing

220
00:08:11,759 --> 00:08:18,240
scheme with the same exact parameters

221
00:08:15,680 --> 00:08:19,599
so building private linear broadcast

222
00:08:18,240 --> 00:08:21,599
encryption is actually very easy if

223
00:08:19,599 --> 00:08:24,400
you're to ignore the parameter sizes

224
00:08:21,599 --> 00:08:26,159
basically just give every user a

225
00:08:24,400 --> 00:08:27,758
distinct independent secret key for

226
00:08:26,160 --> 00:08:31,199
public key encryption scheme

227
00:08:27,759 --> 00:08:33,120
and when you want to encrypt to

228
00:08:31,199 --> 00:08:35,200
all users less than or equal to j you

229
00:08:33,120 --> 00:08:36,560
simply encrypt the message separately to

230
00:08:35,200 --> 00:08:38,800
all of those users

231
00:08:36,559 --> 00:08:40,079
and for all the remaining users you just

232
00:08:38,799 --> 00:08:42,880
put some dummy message

233
00:08:40,080 --> 00:08:44,720
say a special symbol bot um so all users

234
00:08:42,880 --> 00:08:46,880
above j won't be able to decrypt and all

235
00:08:44,720 --> 00:08:49,839
users below j will be able to decrypt

236
00:08:46,880 --> 00:08:50,320
and only a user knows whether or not

237
00:08:49,839 --> 00:08:53,360
they

238
00:08:50,320 --> 00:08:53,360
were able to decrypt

239
00:08:53,440 --> 00:08:56,800
uh so the trivial private linear

240
00:08:55,120 --> 00:09:00,080
broadcast encryption system

241
00:08:56,800 --> 00:09:01,680
achieves linear size ciphertext um

242
00:09:00,080 --> 00:09:03,600
and basically what all of the best

243
00:09:01,680 --> 00:09:05,839
trader tracing schemes do

244
00:09:03,600 --> 00:09:07,200
is they give improved algebraic

245
00:09:05,839 --> 00:09:08,880
constructions of private linear

246
00:09:07,200 --> 00:09:11,839
broadcast encryption

247
00:09:08,880 --> 00:09:13,040
uh which then they rely on the theorem

248
00:09:11,839 --> 00:09:15,120
of bone sign waters

249
00:09:13,040 --> 00:09:17,599
to derive a new trader tracing scheme

250
00:09:15,120 --> 00:09:17,600
from that

251
00:09:18,560 --> 00:09:22,079
now for pairings going through private

252
00:09:20,399 --> 00:09:23,839
linear broadcast encryption seems to

253
00:09:22,080 --> 00:09:25,760
present a barrier

254
00:09:23,839 --> 00:09:27,120
um what our pairings pairings

255
00:09:25,760 --> 00:09:28,880
essentially allow

256
00:09:27,120 --> 00:09:32,000
are groups that allow for degree two

257
00:09:28,880 --> 00:09:34,320
functions in the exponent

258
00:09:32,000 --> 00:09:35,440
the reason this leads to an n to the one

259
00:09:34,320 --> 00:09:38,320
half

260
00:09:35,440 --> 00:09:39,760
psi ciphertext scheme is that you can

261
00:09:38,320 --> 00:09:43,120
roughly imagine

262
00:09:39,760 --> 00:09:45,040
arranging the n cybertex components of

263
00:09:43,120 --> 00:09:48,480
the trivial private bypassed

264
00:09:45,040 --> 00:09:51,839
scheme into a grid of

265
00:09:48,480 --> 00:09:53,920
n to the one-half by n to the one-half

266
00:09:51,839 --> 00:09:56,399
now you will leverage the fact that you

267
00:09:53,920 --> 00:10:00,560
can compute degree two functions

268
00:09:56,399 --> 00:10:02,959
to write this um this matrix

269
00:10:00,560 --> 00:10:05,199
as the tensor product of two vectors

270
00:10:02,959 --> 00:10:06,719
each of length n to the one half

271
00:10:05,200 --> 00:10:09,040
so what you actually give out in the

272
00:10:06,720 --> 00:10:11,360
ciphertext then are these

273
00:10:09,040 --> 00:10:12,959
vectors of length n to the one half and

274
00:10:11,360 --> 00:10:14,000
then when you decrypt you can

275
00:10:12,959 --> 00:10:17,839
reconstruct

276
00:10:14,000 --> 00:10:21,120
the n total cybertex components using

277
00:10:17,839 --> 00:10:21,120
the fact that you have a pairing

278
00:10:21,279 --> 00:10:25,920
and as far as we know the best known

279
00:10:24,399 --> 00:10:27,279
private linear broadcast encryption

280
00:10:25,920 --> 00:10:29,519
scheme from pairings

281
00:10:27,279 --> 00:10:33,839
achieves this n to the one-half value

282
00:10:29,519 --> 00:10:33,839
and we don't know anything better

283
00:10:34,320 --> 00:10:40,000
so in this work what we do is we offer

284
00:10:37,760 --> 00:10:41,439
a handful of new techniques for trader

285
00:10:40,000 --> 00:10:43,760
tracing

286
00:10:41,440 --> 00:10:45,200
uh outside of the private linear

287
00:10:43,760 --> 00:10:48,079
broadcast encryption

288
00:10:45,200 --> 00:10:48,880
paradigm and this will allow us to

289
00:10:48,079 --> 00:10:52,079
circumvent

290
00:10:48,880 --> 00:10:53,600
the n to the one-half barrier and more

291
00:10:52,079 --> 00:10:55,120
generally just get new parameter

292
00:10:53,600 --> 00:10:56,959
trade-offs from pairings

293
00:10:55,120 --> 00:10:58,800
as well as a few other results from

294
00:10:56,959 --> 00:11:00,560
other primitives

295
00:10:58,800 --> 00:11:02,719
so let me just briefly summarize our

296
00:11:00,560 --> 00:11:06,160
results

297
00:11:02,720 --> 00:11:08,720
um so from pairings um

298
00:11:06,160 --> 00:11:09,279
all our trader tracing results will

299
00:11:08,720 --> 00:11:12,720
generally

300
00:11:09,279 --> 00:11:15,360
fall um we'll generally have the form

301
00:11:12,720 --> 00:11:17,120
where the public key times the secret

302
00:11:15,360 --> 00:11:18,480
key times the ciphertext size will be

303
00:11:17,120 --> 00:11:20,640
equal to n

304
00:11:18,480 --> 00:11:22,160
or if i look at the exponents of n for

305
00:11:20,640 --> 00:11:24,079
the varia for

306
00:11:22,160 --> 00:11:25,839
the public key secret key and cybertext

307
00:11:24,079 --> 00:11:28,000
size the exponents will sum to one

308
00:11:25,839 --> 00:11:30,079
simple if we take the trivial

309
00:11:28,000 --> 00:11:32,640
construction of private linear broadcast

310
00:11:30,079 --> 00:11:33,920
and instantiate it using identity based

311
00:11:32,640 --> 00:11:35,360
encryption which allows you to shrink

312
00:11:33,920 --> 00:11:37,120
the public key size

313
00:11:35,360 --> 00:11:38,640
this gives us the scheme in the lower

314
00:11:37,120 --> 00:11:40,399
right hand corner with constant size

315
00:11:38,640 --> 00:11:43,360
public and secret keys

316
00:11:40,399 --> 00:11:45,040
as well as linear sci cipher text on the

317
00:11:43,360 --> 00:11:46,959
other hand the bones high water scheme

318
00:11:45,040 --> 00:11:48,959
sort of lies in the middle on this

319
00:11:46,959 --> 00:11:50,479
right edge here with this end to the one

320
00:11:48,959 --> 00:11:52,000
half size public keys

321
00:11:50,480 --> 00:11:54,839
constant size secret keys and end of the

322
00:11:52,000 --> 00:11:57,200
one half sized

323
00:11:54,839 --> 00:11:58,079
ciphertext so our results are everything

324
00:11:57,200 --> 00:12:00,800
in green

325
00:11:58,079 --> 00:12:01,760
so one is we sort of interpolate between

326
00:12:00,800 --> 00:12:03,599
the trivial

327
00:12:01,760 --> 00:12:04,880
trader tracing scheme and the bone sahai

328
00:12:03,600 --> 00:12:07,279
water scheme

329
00:12:04,880 --> 00:12:08,639
and we also give this triangle at the

330
00:12:07,279 --> 00:12:11,920
bottom here

331
00:12:08,639 --> 00:12:14,000
the interesting parts that i want to

332
00:12:11,920 --> 00:12:15,040
draw attention to are the lower left

333
00:12:14,000 --> 00:12:16,880
hand corner

334
00:12:15,040 --> 00:12:18,639
where we achieve constant size public

335
00:12:16,880 --> 00:12:21,519
keys and cipher texts

336
00:12:18,639 --> 00:12:23,040
uh while having linear size secret keys

337
00:12:21,519 --> 00:12:26,320
thus

338
00:12:23,040 --> 00:12:29,599
significantly improving on the

339
00:12:26,320 --> 00:12:31,760
uh bonnet now our scheme

340
00:12:29,600 --> 00:12:33,440
uh and in the middle here we actually

341
00:12:31,760 --> 00:12:35,200
get a scheme where all parameters are

342
00:12:33,440 --> 00:12:37,200
actually

343
00:12:35,200 --> 00:12:39,040
order n to the one third thus if your

344
00:12:37,200 --> 00:12:40,959
goal is to sort of minimize all

345
00:12:39,040 --> 00:12:43,920
parameters simultaneously

346
00:12:40,959 --> 00:12:45,760
this scheme will achieve the best no

347
00:12:43,920 --> 00:12:47,439
known from pairings

348
00:12:45,760 --> 00:12:50,839
and i want to emphasize that all of

349
00:12:47,440 --> 00:12:52,720
these schemes do not have the threshold

350
00:12:50,839 --> 00:12:54,399
limitation

351
00:12:52,720 --> 00:12:56,399
um some other results from pairings is

352
00:12:54,399 --> 00:12:58,880
we look at the setting of broadcast and

353
00:12:56,399 --> 00:13:01,760
trace which augments the trader tracing

354
00:12:58,880 --> 00:13:02,399
system with a broadcast functionality

355
00:13:01,760 --> 00:13:05,120
the

356
00:13:02,399 --> 00:13:07,760
best previous known from pairings alone

357
00:13:05,120 --> 00:13:09,440
was by bonnay waters in 2006

358
00:13:07,760 --> 00:13:11,360
we showed how to get all parameters

359
00:13:09,440 --> 00:13:13,839
simultaneously equal to

360
00:13:11,360 --> 00:13:14,399
n to the one-half we improve on this

361
00:13:13,839 --> 00:13:17,120
slightly

362
00:13:14,399 --> 00:13:18,160
by still getting n to the one-half for

363
00:13:17,120 --> 00:13:20,880
the public keys in

364
00:13:18,160 --> 00:13:21,839
cyphertext but getting constant sized

365
00:13:20,880 --> 00:13:23,600
secret keys

366
00:13:21,839 --> 00:13:26,240
we also offer some more trade-offs

367
00:13:23,600 --> 00:13:27,920
between the public and cypher text size

368
00:13:26,240 --> 00:13:30,240
on the other hand we actually also show

369
00:13:27,920 --> 00:13:33,360
how to shrink the cyber text

370
00:13:30,240 --> 00:13:35,839
below square root all the way down even

371
00:13:33,360 --> 00:13:36,959
to constant though at the cost of linear

372
00:13:35,839 --> 00:13:40,240
size public

373
00:13:36,959 --> 00:13:42,800
and secret keys and um

374
00:13:40,240 --> 00:13:44,560
this is actually uh this improves

375
00:13:42,800 --> 00:13:45,839
significantly on the prior work of

376
00:13:44,560 --> 00:13:49,199
goyalatol

377
00:13:45,839 --> 00:13:51,279
who show how to get very small cyber

378
00:13:49,199 --> 00:13:53,519
attacks but not constant size

379
00:13:51,279 --> 00:13:54,800
from both from the combination of

380
00:13:53,519 --> 00:13:57,199
pairings in lwe

381
00:13:54,800 --> 00:13:58,079
so we'd remove the need for lwe and we

382
00:13:57,199 --> 00:14:00,479
actually get

383
00:13:58,079 --> 00:14:01,599
truly constant psi ciphertext and we

384
00:14:00,480 --> 00:14:05,760
also improve

385
00:14:01,600 --> 00:14:09,360
the secret keys as well

386
00:14:05,760 --> 00:14:12,480
uh finally our last set of results are

387
00:14:09,360 --> 00:14:15,120
are generic and we show

388
00:14:12,480 --> 00:14:16,079
first uh essentially how to remove the

389
00:14:15,120 --> 00:14:19,040
threshold limitation

390
00:14:16,079 --> 00:14:20,959
from the bone naur scheme thus getting a

391
00:14:19,040 --> 00:14:22,800
scheme from general public encryption

392
00:14:20,959 --> 00:14:25,518
with constant size hypertext and

393
00:14:22,800 --> 00:14:27,199
no threshold limitation um and then

394
00:14:25,519 --> 00:14:31,600
using identity-based encryption

395
00:14:27,199 --> 00:14:34,399
um we can shrink the public key size

396
00:14:31,600 --> 00:14:35,760
one interesting thing is is that we can

397
00:14:34,399 --> 00:14:37,600
actually trade off between the secret

398
00:14:35,760 --> 00:14:40,880
key and ciphertext size

399
00:14:37,600 --> 00:14:41,760
and achieve both being size n to the two

400
00:14:40,880 --> 00:14:43,600
thirds

401
00:14:41,760 --> 00:14:46,240
and this gives us the first fully

402
00:14:43,600 --> 00:14:48,639
sublinear scheme

403
00:14:46,240 --> 00:14:50,160
from general ibe which can then be

404
00:14:48,639 --> 00:14:52,480
instantiated from

405
00:14:50,160 --> 00:14:55,040
pairing free groups or factoring like

406
00:14:52,480 --> 00:14:55,040
assumptions

407
00:14:56,399 --> 00:14:59,440
so in order to achieve these results we

408
00:14:58,880 --> 00:15:02,480
develop

409
00:14:59,440 --> 00:15:04,320
a handful of new techniques uh

410
00:15:02,480 --> 00:15:06,240
first we show actually how to

411
00:15:04,320 --> 00:15:07,279
generically remove thresholds from any

412
00:15:06,240 --> 00:15:09,600
threshold

413
00:15:07,279 --> 00:15:11,680
trader tracing system without

414
00:15:09,600 --> 00:15:13,760
asymptotically changing the parameter

415
00:15:11,680 --> 00:15:16,239
sizes

416
00:15:13,760 --> 00:15:17,279
we show another theorem that trades off

417
00:15:16,240 --> 00:15:19,120
the public

418
00:15:17,279 --> 00:15:20,639
and secret key sizes with the ciphertext

419
00:15:19,120 --> 00:15:21,760
size allows you to shrink public and

420
00:15:20,639 --> 00:15:25,440
secret keys

421
00:15:21,760 --> 00:15:26,880
at the cost of expanded ciphertext size

422
00:15:25,440 --> 00:15:28,880
we look at something called risky

423
00:15:26,880 --> 00:15:31,199
tracing and show how to remove the risk

424
00:15:28,880 --> 00:15:34,639
from risky tracing schemes

425
00:15:31,199 --> 00:15:37,199
at the cost of larger secret keys um

426
00:15:34,639 --> 00:15:38,880
we look at something that we call

427
00:15:37,199 --> 00:15:40,560
threshold broadcast here the notion of

428
00:15:38,880 --> 00:15:41,759
threshold is not to be confused with

429
00:15:40,560 --> 00:15:43,359
threshold tracing

430
00:15:41,759 --> 00:15:45,600
i'll elaborate on this a little more

431
00:15:43,360 --> 00:15:47,040
later and we show that threshold

432
00:15:45,600 --> 00:15:49,680
broadcast encryption

433
00:15:47,040 --> 00:15:50,480
can be used to build a trader tracing

434
00:15:49,680 --> 00:15:52,000
system

435
00:15:50,480 --> 00:15:55,759
and then finally we give some new

436
00:15:52,000 --> 00:15:59,199
algebraic instantiations from pairings

437
00:15:55,759 --> 00:16:03,040
so now i'll just very briefly talk about

438
00:15:59,199 --> 00:16:04,880
our new techniques so first

439
00:16:03,040 --> 00:16:07,279
for trading off ciphertext size for

440
00:16:04,880 --> 00:16:08,639
public and secret key sizes

441
00:16:07,279 --> 00:16:10,720
essentially what we do is we just

442
00:16:08,639 --> 00:16:12,959
generalize a trivial private linear

443
00:16:10,720 --> 00:16:16,240
broadcast

444
00:16:12,959 --> 00:16:18,800
construction so what we do is

445
00:16:16,240 --> 00:16:20,480
for some parameter t we will set up t

446
00:16:18,800 --> 00:16:22,319
independent instances

447
00:16:20,480 --> 00:16:24,720
of the some underlying trader tracing

448
00:16:22,320 --> 00:16:26,399
scheme but we'll instantiate the

449
00:16:24,720 --> 00:16:28,079
underlying trader tracing scheme with

450
00:16:26,399 --> 00:16:31,839
fewer users namely n over t

451
00:16:28,079 --> 00:16:32,319
users so now the total number of users

452
00:16:31,839 --> 00:16:35,040
across

453
00:16:32,320 --> 00:16:35,519
all t instances of the scheme is

454
00:16:35,040 --> 00:16:38,959
actually

455
00:16:35,519 --> 00:16:40,560
n um but we've instantiated each scheme

456
00:16:38,959 --> 00:16:43,119
with fewer users and hopefully reduce

457
00:16:40,560 --> 00:16:46,000
the parameter sizes

458
00:16:43,120 --> 00:16:46,480
however to encrypt to make sure that

459
00:16:46,000 --> 00:16:48,720
everyone

460
00:16:46,480 --> 00:16:51,199
encrypts we have to encrypt to every

461
00:16:48,720 --> 00:16:53,759
instance separately thus blowing up

462
00:16:51,199 --> 00:16:55,279
the ciphertext size and in particular we

463
00:16:53,759 --> 00:16:58,399
get the following parameters

464
00:16:55,279 --> 00:17:01,519
so if our our original scheme had

465
00:16:58,399 --> 00:17:04,640
public secret key and cybertech size p

466
00:17:01,519 --> 00:17:07,520
k and c we

467
00:17:04,640 --> 00:17:08,079
we now evaluate those those parameter

468
00:17:07,520 --> 00:17:11,119
sizes

469
00:17:08,079 --> 00:17:12,399
on the on n over t instead of n

470
00:17:11,119 --> 00:17:14,399
uh but then we have to blow up the

471
00:17:12,400 --> 00:17:15,839
public key by a factor of t because we

472
00:17:14,400 --> 00:17:16,959
need a public key for every

473
00:17:15,839 --> 00:17:20,079
instance and we also blow up the

474
00:17:16,959 --> 00:17:22,240
ciphertext by a factor of t

475
00:17:20,079 --> 00:17:24,000
the good news is that we can often

476
00:17:22,240 --> 00:17:26,400
actually

477
00:17:24,000 --> 00:17:27,039
avoid blowing up the public key size

478
00:17:26,400 --> 00:17:29,200
using

479
00:17:27,039 --> 00:17:30,799
ibe techniques and the result is we

480
00:17:29,200 --> 00:17:32,000
really shrink the public key and secret

481
00:17:30,799 --> 00:17:35,039
key size at the cost

482
00:17:32,000 --> 00:17:38,080
of larger ciphertex

483
00:17:35,039 --> 00:17:40,240
one thing to note here is that the

484
00:17:38,080 --> 00:17:41,199
tracing algorithm incurs a factor of t

485
00:17:40,240 --> 00:17:42,640
loss

486
00:17:41,200 --> 00:17:44,320
and this means that we can't use

487
00:17:42,640 --> 00:17:47,440
threshold tracing so we can't apply this

488
00:17:44,320 --> 00:17:49,840
say to the bonnet now our scheme

489
00:17:47,440 --> 00:17:52,000
however our next result shows how to

490
00:17:49,840 --> 00:17:54,480
remove the threshold limitation

491
00:17:52,000 --> 00:17:55,280
and our idea is actually pretty simple

492
00:17:54,480 --> 00:17:57,840
basically

493
00:17:55,280 --> 00:17:58,639
to we suppose we have some trader

494
00:17:57,840 --> 00:18:00,480
tracing scheme

495
00:17:58,640 --> 00:18:02,240
that has this threshold limitation so we

496
00:18:00,480 --> 00:18:03,679
can only trace decoders that decrypt

497
00:18:02,240 --> 00:18:05,600
most of the time

498
00:18:03,679 --> 00:18:07,600
what we will do is we will take a

499
00:18:05,600 --> 00:18:10,879
message that we want to encrypt

500
00:18:07,600 --> 00:18:12,000
and we will split it into a bunch of

501
00:18:10,880 --> 00:18:14,799
shares

502
00:18:12,000 --> 00:18:16,160
uh say using an n out event a t out of t

503
00:18:14,799 --> 00:18:17,520
secret sharing scheme

504
00:18:16,160 --> 00:18:19,440
and then we'll encrypt each search

505
00:18:17,520 --> 00:18:20,799
separately

506
00:18:19,440 --> 00:18:22,240
the idea here is we're essentially

507
00:18:20,799 --> 00:18:23,760
performing some sort of hardness

508
00:18:22,240 --> 00:18:27,280
amplification

509
00:18:23,760 --> 00:18:29,840
that will allow us to transfer

510
00:18:27,280 --> 00:18:31,039
a decoder with very very small success

511
00:18:29,840 --> 00:18:34,159
probability into one with

512
00:18:31,039 --> 00:18:37,039
a much larger success probability

513
00:18:34,160 --> 00:18:38,480
the key feature of this transformation

514
00:18:37,039 --> 00:18:40,080
is that the number of shares that we

515
00:18:38,480 --> 00:18:41,120
need to split into is independent of the

516
00:18:40,080 --> 00:18:42,799
number of users n

517
00:18:41,120 --> 00:18:44,239
and can be taken just to be the security

518
00:18:42,799 --> 00:18:45,679
parameter

519
00:18:44,240 --> 00:18:48,080
and therefore we don't change the

520
00:18:45,679 --> 00:18:49,840
asymptotics of any of the

521
00:18:48,080 --> 00:18:52,159
parameters in our scheme as a function

522
00:18:49,840 --> 00:18:52,159
of n

523
00:18:52,240 --> 00:18:58,720
now combining this um

524
00:18:55,520 --> 00:19:01,039
generic removal of thresholds with

525
00:18:58,720 --> 00:19:02,160
our parameter size trade-off from the

526
00:19:01,039 --> 00:19:04,080
the previous slide

527
00:19:02,160 --> 00:19:05,440
this is already enough to get us our

528
00:19:04,080 --> 00:19:06,080
public encryption identity based

529
00:19:05,440 --> 00:19:10,640
encryption

530
00:19:06,080 --> 00:19:11,918
results um next i'll talk about

531
00:19:10,640 --> 00:19:14,400
mitigating risk

532
00:19:11,919 --> 00:19:15,280
so what is a risky tracing scheme where

533
00:19:14,400 --> 00:19:17,520
it's one

534
00:19:15,280 --> 00:19:18,720
where you're guaranteed never to accuse

535
00:19:17,520 --> 00:19:21,120
an honest user

536
00:19:18,720 --> 00:19:22,080
but you may fail to accuse anyone

537
00:19:21,120 --> 00:19:24,239
there's actually a

538
00:19:22,080 --> 00:19:25,439
with a risky trader tracing scheme

539
00:19:24,240 --> 00:19:28,320
there's a high likelihood that you'll

540
00:19:25,440 --> 00:19:30,000
actually fail to accuse any user

541
00:19:28,320 --> 00:19:32,000
um but the guarantee is that there's at

542
00:19:30,000 --> 00:19:35,520
least some small probability

543
00:19:32,000 --> 00:19:39,039
that you will accuse

544
00:19:35,520 --> 00:19:41,120
a malicious user uh goyal

545
00:19:39,039 --> 00:19:43,520
at all defined this notion and moreover

546
00:19:41,120 --> 00:19:45,600
showed how to construct a risky scheme

547
00:19:43,520 --> 00:19:48,080
uh with constant size parameters except

548
00:19:45,600 --> 00:19:51,520
the the amount of risk is very high

549
00:19:48,080 --> 00:19:53,600
so you're only guaranteed to trace to

550
00:19:51,520 --> 00:19:56,879
a malicious user with probability one

551
00:19:53,600 --> 00:19:59,760
over n the number of users

552
00:19:56,880 --> 00:20:01,200
so we show is actually that is possible

553
00:19:59,760 --> 00:20:03,120
to

554
00:20:01,200 --> 00:20:04,840
remove the risk from a risky tracing

555
00:20:03,120 --> 00:20:07,120
scheme

556
00:20:04,840 --> 00:20:07,918
without blowing up the parameters too

557
00:20:07,120 --> 00:20:11,039
much

558
00:20:07,919 --> 00:20:12,720
the idea is going to be um

559
00:20:11,039 --> 00:20:14,400
kind of like before we're going to run t

560
00:20:12,720 --> 00:20:16,400
independent instances of the scheme

561
00:20:14,400 --> 00:20:18,240
of some of the underlying risky tracing

562
00:20:16,400 --> 00:20:20,080
scheme except here

563
00:20:18,240 --> 00:20:22,559
we're going to each and have each

564
00:20:20,080 --> 00:20:24,960
instance still have end users

565
00:20:22,559 --> 00:20:26,799
so now there are no end times t

566
00:20:24,960 --> 00:20:27,520
different secret keys across all the

567
00:20:26,799 --> 00:20:29,679
instances

568
00:20:27,520 --> 00:20:30,879
the secret key for user i will sort of

569
00:20:29,679 --> 00:20:33,840
be a slice

570
00:20:30,880 --> 00:20:35,200
um selecting one secret key from every

571
00:20:33,840 --> 00:20:37,600
one of the t

572
00:20:35,200 --> 00:20:38,720
schemes and when it comes time to

573
00:20:37,600 --> 00:20:40,240
encrypt

574
00:20:38,720 --> 00:20:41,840
uh what we're going to do is we're going

575
00:20:40,240 --> 00:20:43,600
to encrypt to we're going to choose a

576
00:20:41,840 --> 00:20:45,199
random instance every time we encrypt

577
00:20:43,600 --> 00:20:47,520
and we're just going to encrypt

578
00:20:45,200 --> 00:20:51,200
to that single instance so there's only

579
00:20:47,520 --> 00:20:53,440
ever one ciphertext component

580
00:20:51,200 --> 00:20:55,440
uh the rough idea is that if you have a

581
00:20:53,440 --> 00:20:58,480
tracing algorithm that can

582
00:20:55,440 --> 00:20:59,600
let's say always decrypt if it can

583
00:20:58,480 --> 00:21:02,720
always decrypt

584
00:20:59,600 --> 00:21:04,719
that means it can decrypt no matter what

585
00:21:02,720 --> 00:21:06,320
instance was chosen during encryption

586
00:21:04,720 --> 00:21:07,679
and this means that the decoder is

587
00:21:06,320 --> 00:21:11,760
actually able to

588
00:21:07,679 --> 00:21:13,120
uh decrypt for all possible instances

589
00:21:11,760 --> 00:21:15,280
so what you can do is you can take this

590
00:21:13,120 --> 00:21:17,918
decoder and actually derive from it

591
00:21:15,280 --> 00:21:19,678
a decoder for each one of the possible

592
00:21:17,919 --> 00:21:21,679
instances

593
00:21:19,679 --> 00:21:23,039
now the tracing guarantee says i have

594
00:21:21,679 --> 00:21:26,080
some probability

595
00:21:23,039 --> 00:21:28,240
of tracing each one of these decoders

596
00:21:26,080 --> 00:21:29,520
and we show essentially that the

597
00:21:28,240 --> 00:21:32,320
probabilities sort of

598
00:21:29,520 --> 00:21:32,720
act as you would expect so that if you

599
00:21:32,320 --> 00:21:35,840
run

600
00:21:32,720 --> 00:21:38,559
t independent instances the

601
00:21:35,840 --> 00:21:40,639
probability that they all fail is 1

602
00:21:38,559 --> 00:21:44,399
minus the riskiness of one instance

603
00:21:40,640 --> 00:21:46,480
raised to the t so what you can do

604
00:21:44,400 --> 00:21:47,679
is then set t to be something like one

605
00:21:46,480 --> 00:21:49,280
over alpha

606
00:21:47,679 --> 00:21:51,039
or a little more than one over alpha and

607
00:21:49,280 --> 00:21:53,678
you'll actually uh trace with

608
00:21:51,039 --> 00:21:56,720
overwhelming probability

609
00:21:53,679 --> 00:21:58,000
uh now the in order to get things to

610
00:21:56,720 --> 00:22:00,640
work we actually require

611
00:21:58,000 --> 00:22:02,480
that the original decoder succeeds with

612
00:22:00,640 --> 00:22:04,400
high probability say 0.9

613
00:22:02,480 --> 00:22:05,919
so we we only immediately get a

614
00:22:04,400 --> 00:22:07,360
threshold scheme but

615
00:22:05,919 --> 00:22:08,960
fortunately we have our threshold

616
00:22:07,360 --> 00:22:10,639
elimination compiler which we can then

617
00:22:08,960 --> 00:22:12,480
apply on top of this

618
00:22:10,640 --> 00:22:14,799
to get a full scheme that completely

619
00:22:12,480 --> 00:22:16,240
removes the risk

620
00:22:14,799 --> 00:22:18,879
and the parameters that we ultimately

621
00:22:16,240 --> 00:22:20,000
get are we preserve the ciphertext size

622
00:22:18,880 --> 00:22:23,200
of the scheme

623
00:22:20,000 --> 00:22:25,039
but we blow up the public key and secret

624
00:22:23,200 --> 00:22:28,720
key size by a factor of

625
00:22:25,039 --> 00:22:29,840
alpha inverse the good news is though

626
00:22:28,720 --> 00:22:31,600
that like before

627
00:22:29,840 --> 00:22:32,879
often using identity-based encryption

628
00:22:31,600 --> 00:22:35,039
techniques we

629
00:22:32,880 --> 00:22:36,480
can actually save from blowing up the

630
00:22:35,039 --> 00:22:40,000
public key size and the result is we

631
00:22:36,480 --> 00:22:41,760
only increase the secret key size

632
00:22:40,000 --> 00:22:43,600
um and this is enough to get our scheme

633
00:22:41,760 --> 00:22:45,600
from pairings with constant sized public

634
00:22:43,600 --> 00:22:46,080
keys and ciphertext by combining our

635
00:22:45,600 --> 00:22:50,080
risk

636
00:22:46,080 --> 00:22:53,039
mitigation with our previous compilers

637
00:22:50,080 --> 00:22:54,080
um finally i want to talk about

638
00:22:53,039 --> 00:22:56,000
threshold broadcast

639
00:22:54,080 --> 00:22:57,520
i won't formally define this but instead

640
00:22:56,000 --> 00:22:59,280
i'll define a simpler notion of

641
00:22:57,520 --> 00:23:01,360
broadcast encryption

642
00:22:59,280 --> 00:23:02,480
which is kind of like private linear

643
00:23:01,360 --> 00:23:05,360
broadcast encryption

644
00:23:02,480 --> 00:23:07,120
except one when i encrypt i can actually

645
00:23:05,360 --> 00:23:09,918
choose an arbitrary set of unit

646
00:23:07,120 --> 00:23:12,399
users rather than just a linear set like

647
00:23:09,919 --> 00:23:15,440
in private linear broadcast encryption

648
00:23:12,400 --> 00:23:19,520
and the other difference is that in

649
00:23:15,440 --> 00:23:19,520
broadcast encryption the set s is public

650
00:23:20,480 --> 00:23:27,200
so our idea is to try to take

651
00:23:23,600 --> 00:23:30,399
a broadcast encryption even though

652
00:23:27,200 --> 00:23:31,840
um the setas is public we're going to

653
00:23:30,400 --> 00:23:35,600
try to use it

654
00:23:31,840 --> 00:23:38,879
to be able to encrypt it to secret sets

655
00:23:35,600 --> 00:23:39,840
and by encrypting to secret sets we will

656
00:23:38,880 --> 00:23:42,400
allow for

657
00:23:39,840 --> 00:23:44,959
tracing somewhat analogous to the

658
00:23:42,400 --> 00:23:47,600
private linear broadcast setting

659
00:23:44,960 --> 00:23:49,440
so what we do is we assign users

660
00:23:47,600 --> 00:23:52,158
essentially random identity so that only

661
00:23:49,440 --> 00:23:55,039
the user knows their identity

662
00:23:52,159 --> 00:23:56,640
and no one else knows it and uh this

663
00:23:55,039 --> 00:23:57,760
basic because no one else knows that

664
00:23:56,640 --> 00:24:01,120
user's identity it

665
00:23:57,760 --> 00:24:03,520
essentially allows us to uh encrypt

666
00:24:01,120 --> 00:24:06,000
to a set of users without actually

667
00:24:03,520 --> 00:24:08,320
revealing who the users are

668
00:24:06,000 --> 00:24:09,200
this doesn't quite work um and this is

669
00:24:08,320 --> 00:24:11,200
why we need to

670
00:24:09,200 --> 00:24:12,559
generalize the some threshold

671
00:24:11,200 --> 00:24:13,679
functionality which i won't really

672
00:24:12,559 --> 00:24:16,320
define

673
00:24:13,679 --> 00:24:17,440
so when we put everything together um

674
00:24:16,320 --> 00:24:19,760
what we're going to do

675
00:24:17,440 --> 00:24:22,000
is we're going to first take an existing

676
00:24:19,760 --> 00:24:24,240
threshold broadcast encryption scheme

677
00:24:22,000 --> 00:24:25,760
we're going to optimize it for the

678
00:24:24,240 --> 00:24:28,960
trader tracing app

679
00:24:25,760 --> 00:24:30,000
we're going to combine it algebraically

680
00:24:28,960 --> 00:24:31,760
with techniques for

681
00:24:30,000 --> 00:24:33,600
develop for building risky trader

682
00:24:31,760 --> 00:24:37,200
tracing we'll apply

683
00:24:33,600 --> 00:24:41,520
our compilers and at the end we'll get

684
00:24:37,200 --> 00:24:44,880
the our trader tracing results

685
00:24:41,520 --> 00:24:46,639
uh so in summary uh the high level

686
00:24:44,880 --> 00:24:49,840
takeaways from this work

687
00:24:46,640 --> 00:24:50,880
are that one private linear broadcast is

688
00:24:49,840 --> 00:24:53,760
not inherent

689
00:24:50,880 --> 00:24:55,120
to achieving uh good trader tracing

690
00:24:53,760 --> 00:24:58,480
results

691
00:24:55,120 --> 00:25:00,239
um another takeaway is that

692
00:24:58,480 --> 00:25:02,080
threshold tracing is no longer a

693
00:25:00,240 --> 00:25:03,520
limitation we can generically remove

694
00:25:02,080 --> 00:25:06,000
thresholds without affecting the

695
00:25:03,520 --> 00:25:09,520
parameter sizes

696
00:25:06,000 --> 00:25:10,880
the final lesson is that risky and

697
00:25:09,520 --> 00:25:12,559
threshold tracing

698
00:25:10,880 --> 00:25:14,559
are actually useful stepping stones to

699
00:25:12,559 --> 00:25:17,600
building full trader tracing schemes

700
00:25:14,559 --> 00:25:20,240
these objects were originally

701
00:25:17,600 --> 00:25:21,760
defined as sort of ends on their own or

702
00:25:20,240 --> 00:25:22,960
for other applications

703
00:25:21,760 --> 00:25:25,520
and what we have shown is that you can

704
00:25:22,960 --> 00:25:26,640
actually start from a risky or threshold

705
00:25:25,520 --> 00:25:29,520
trader tracing scheme

706
00:25:26,640 --> 00:25:33,039
and achieve a full trader tracing scheme

707
00:25:29,520 --> 00:25:35,200
potentially at some possible parameters

708
00:25:33,039 --> 00:25:37,360
and with that i conclude my talk thank

709
00:25:35,200 --> 00:25:37,360
you

