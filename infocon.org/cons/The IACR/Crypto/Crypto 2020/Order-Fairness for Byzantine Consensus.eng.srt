1
00:00:01,760 --> 00:00:05,359
hello everyone i'm excited to be at

2
00:00:03,679 --> 00:00:07,680
virtual crypto 2020.

3
00:00:05,359 --> 00:00:10,000
i'm mohimna and i'm a phd student at

4
00:00:07,680 --> 00:00:11,759
cornell university and cornell tech

5
00:00:10,000 --> 00:00:14,160
today i will be presenting our paper

6
00:00:11,759 --> 00:00:15,759
order fairness for byzantine consensus

7
00:00:14,160 --> 00:00:17,520
this is joint work with other authors

8
00:00:15,759 --> 00:00:20,080
like cornell tech fan zhang

9
00:00:17,520 --> 00:00:21,600
stephen goldfeder and ari jules so let's

10
00:00:20,080 --> 00:00:23,198
begin

11
00:00:21,600 --> 00:00:24,880
first i thought it would be a good idea

12
00:00:23,199 --> 00:00:26,800
to briefly recall the state machine

13
00:00:24,880 --> 00:00:27,680
replication problem and some of its

14
00:00:26,800 --> 00:00:29,840
properties

15
00:00:27,680 --> 00:00:31,840
so the problem setup is as follows the

16
00:00:29,840 --> 00:00:32,320
system consists of a set of servers or

17
00:00:31,840 --> 00:00:34,399
nodes

18
00:00:32,320 --> 00:00:36,320
and some of these may be byzantine

19
00:00:34,399 --> 00:00:38,800
there's clients or users in the system

20
00:00:36,320 --> 00:00:40,559
that send transactions to these nodes

21
00:00:38,800 --> 00:00:42,640
and the goal for the nodes is to agree

22
00:00:40,559 --> 00:00:43,760
on a consistent ordering of these user

23
00:00:42,640 --> 00:00:45,840
transactions

24
00:00:43,760 --> 00:00:47,599
so consistent in the sense that all of

25
00:00:45,840 --> 00:00:48,559
the honest nodes should output the same

26
00:00:47,600 --> 00:00:50,000
ordering

27
00:00:48,559 --> 00:00:51,360
this linearly ordered log of

28
00:00:50,000 --> 00:00:52,480
transactions is what we call a

29
00:00:51,360 --> 00:00:54,320
blockchain

30
00:00:52,480 --> 00:00:56,160
so just a side note in this talk i'll

31
00:00:54,320 --> 00:00:58,640
use the term state machine replication

32
00:00:56,160 --> 00:01:00,718
and byzantine consensus interchangeably

33
00:00:58,640 --> 00:01:02,480
and i'll also frequently use terms more

34
00:01:00,719 --> 00:01:04,400
common in the blockchain literature

35
00:01:02,480 --> 00:01:05,920
like transactions or linearly ordered

36
00:01:04,400 --> 00:01:08,000
log but note that

37
00:01:05,920 --> 00:01:09,920
all of what i say is analogously true

38
00:01:08,000 --> 00:01:12,080
for the original formulation

39
00:01:09,920 --> 00:01:14,479
using state transitions and system

40
00:01:12,080 --> 00:01:16,158
states

41
00:01:14,479 --> 00:01:18,720
okay so there's two properties that

42
00:01:16,159 --> 00:01:21,280
consensus protocols need to satisfy

43
00:01:18,720 --> 00:01:22,400
consistency and liveness so the first

44
00:01:21,280 --> 00:01:24,799
requirement

45
00:01:22,400 --> 00:01:26,960
uh consistency ensures that all of the

46
00:01:24,799 --> 00:01:28,479
honest notes have the same view of the

47
00:01:26,960 --> 00:01:30,479
linearly ordered log

48
00:01:28,479 --> 00:01:33,119
and the second requirement liveness

49
00:01:30,479 --> 00:01:35,360
ensures that the system makes progress

50
00:01:33,119 --> 00:01:36,880
so basically any fresh transactions that

51
00:01:35,360 --> 00:01:40,240
are input by clients

52
00:01:36,880 --> 00:01:42,798
are incorporated into this log suit

53
00:01:40,240 --> 00:01:44,960
but unfortunately neither consistency

54
00:01:42,799 --> 00:01:46,960
nor liveness says anything about the

55
00:01:44,960 --> 00:01:48,479
actual ordering of transactions in this

56
00:01:46,960 --> 00:01:50,320
log

57
00:01:48,479 --> 00:01:52,159
so for example the consistency

58
00:01:50,320 --> 00:01:54,079
requirement can be satisfied

59
00:01:52,159 --> 00:01:55,840
even if there's a single adversarial

60
00:01:54,079 --> 00:01:57,839
node that completely chooses the

61
00:01:55,840 --> 00:01:59,920
ordering of all the transactions

62
00:01:57,840 --> 00:02:02,799
and as it turns out this transaction

63
00:01:59,920 --> 00:02:06,000
ordering is often easy to manipulate

64
00:02:02,799 --> 00:02:08,399
in existing protocols so

65
00:02:06,000 --> 00:02:09,840
almost all classical protocols are what

66
00:02:08,399 --> 00:02:11,840
we call leader based

67
00:02:09,840 --> 00:02:13,920
which means that a single leader node is

68
00:02:11,840 --> 00:02:15,280
responsible for proposing the ordering

69
00:02:13,920 --> 00:02:18,079
of the transactions

70
00:02:15,280 --> 00:02:18,560
so take protocols like pbst for instance

71
00:02:18,080 --> 00:02:21,440
which

72
00:02:18,560 --> 00:02:22,480
have a single leader node for the entire

73
00:02:21,440 --> 00:02:24,079
protocol

74
00:02:22,480 --> 00:02:26,160
except when the leader tries to

75
00:02:24,080 --> 00:02:27,440
equivocate by proposing two different

76
00:02:26,160 --> 00:02:30,799
transactions

77
00:02:27,440 --> 00:02:32,800
or it becomes unresponsive there's more

78
00:02:30,800 --> 00:02:34,879
recent protocols like hot stuff

79
00:02:32,800 --> 00:02:37,040
which will randomly select leaders for

80
00:02:34,879 --> 00:02:38,879
each round and then the leader for that

81
00:02:37,040 --> 00:02:40,959
round is responsible for the ordering

82
00:02:38,879 --> 00:02:43,200
proposal for that round

83
00:02:40,959 --> 00:02:45,040
but even then the current round leader

84
00:02:43,200 --> 00:02:45,518
can sort of propose any ordering it

85
00:02:45,040 --> 00:02:47,359
wants

86
00:02:45,519 --> 00:02:49,280
and when the leader is adversarial it

87
00:02:47,360 --> 00:02:50,480
can manipulate the transaction ordering

88
00:02:49,280 --> 00:02:52,480
arbitrarily

89
00:02:50,480 --> 00:02:55,840
this type of reordering isn't really

90
00:02:52,480 --> 00:02:57,440
handled by existing protocols

91
00:02:55,840 --> 00:02:59,920
so all of this talk on order

92
00:02:57,440 --> 00:03:01,359
manipulation raises the central question

93
00:02:59,920 --> 00:03:03,200
that drove our paper

94
00:03:01,360 --> 00:03:04,400
so why exactly is fair ordering so

95
00:03:03,200 --> 00:03:06,319
important

96
00:03:04,400 --> 00:03:08,400
consensus as a primitive has been

97
00:03:06,319 --> 00:03:10,238
studied for several decades now and the

98
00:03:08,400 --> 00:03:12,000
field is reasonably mature

99
00:03:10,239 --> 00:03:13,280
so recent protocols mostly try to

100
00:03:12,000 --> 00:03:15,840
improve scalability

101
00:03:13,280 --> 00:03:16,319
or reduce communication complexity or

102
00:03:15,840 --> 00:03:18,800
opt for

103
00:03:16,319 --> 00:03:19,839
simpler designs or fewer assumptions but

104
00:03:18,800 --> 00:03:21,680
in this paper

105
00:03:19,840 --> 00:03:24,000
we look back at the standard consensus

106
00:03:21,680 --> 00:03:26,319
properties to see whether they fit

107
00:03:24,000 --> 00:03:27,440
real world requirements for blockchains

108
00:03:26,319 --> 00:03:29,518
in particular

109
00:03:27,440 --> 00:03:30,480
so in the next few minutes my goal is to

110
00:03:29,519 --> 00:03:32,879
motivate

111
00:03:30,480 --> 00:03:33,840
fair ordering and tell you why it's so

112
00:03:32,879 --> 00:03:36,640
important for

113
00:03:33,840 --> 00:03:38,400
blockchains and our paper has more

114
00:03:36,640 --> 00:03:41,279
examples of these but i'll discuss the

115
00:03:38,400 --> 00:03:43,120
primary motivations here

116
00:03:41,280 --> 00:03:45,519
so the biggest motivator for order

117
00:03:43,120 --> 00:03:46,879
fairness is decentralized exchanges

118
00:03:45,519 --> 00:03:49,360
and i claim that results could be

119
00:03:46,879 --> 00:03:52,000
catastrophic here without fair ordering

120
00:03:49,360 --> 00:03:53,200
so for context michael lewis had this

121
00:03:52,000 --> 00:03:56,080
best-seller book

122
00:03:53,200 --> 00:03:56,640
in 2014 called flash boys which brought

123
00:03:56,080 --> 00:03:58,879
to light

124
00:03:56,640 --> 00:04:00,559
the high frequency trading practices in

125
00:03:58,879 --> 00:04:03,040
the early days of wall street

126
00:04:00,560 --> 00:04:04,480
so this is when investment firms spent

127
00:04:03,040 --> 00:04:06,400
millions of dollars

128
00:04:04,480 --> 00:04:08,720
building low latency channels to the new

129
00:04:06,400 --> 00:04:10,799
york stock exchange and nasdaq

130
00:04:08,720 --> 00:04:12,319
so that they could receive information

131
00:04:10,799 --> 00:04:13,599
and act on it in the matter of

132
00:04:12,319 --> 00:04:15,839
microseconds

133
00:04:13,599 --> 00:04:17,120
so they capitalize on this information

134
00:04:15,840 --> 00:04:19,519
asymmetry

135
00:04:17,120 --> 00:04:22,479
in order to make small profits on a

136
00:04:19,519 --> 00:04:24,639
really large volume of transactions

137
00:04:22,479 --> 00:04:27,199
over the years high frequency trading

138
00:04:24,639 --> 00:04:29,280
has been subject to a lot of regulation

139
00:04:27,199 --> 00:04:30,639
and it's no longer the wild beast it

140
00:04:29,280 --> 00:04:33,280
once was

141
00:04:30,639 --> 00:04:34,960
but in some sense high frequency trading

142
00:04:33,280 --> 00:04:37,198
is exactly what we're seeing on

143
00:04:34,960 --> 00:04:39,599
decentralized exchanges today

144
00:04:37,199 --> 00:04:40,840
so this recent paper by phil diane and

145
00:04:39,600 --> 00:04:43,840
others at s p

146
00:04:40,840 --> 00:04:45,520
2020 showed the rampant rise of bots on

147
00:04:43,840 --> 00:04:47,198
the ethereum network

148
00:04:45,520 --> 00:04:48,719
waiting to make profits from

149
00:04:47,199 --> 00:04:51,440
unsuspecting users

150
00:04:48,720 --> 00:04:53,360
by manipulating the transaction ordering

151
00:04:51,440 --> 00:04:54,320
so these bots would wait for favorable

152
00:04:53,360 --> 00:04:56,400
opportunities

153
00:04:54,320 --> 00:04:58,240
and then front run users by inserting

154
00:04:56,400 --> 00:04:59,039
their own transactions and trying to get

155
00:04:58,240 --> 00:05:01,520
them sequenced

156
00:04:59,040 --> 00:05:02,479
earlier so this allowed them to execute

157
00:05:01,520 --> 00:05:04,080
arbitrage

158
00:05:02,479 --> 00:05:06,080
which is when you buy a security and

159
00:05:04,080 --> 00:05:08,719
then quickly turn around and sell it to

160
00:05:06,080 --> 00:05:10,719
a user at a higher price

161
00:05:08,720 --> 00:05:12,720
so and unlike in real world exchanges

162
00:05:10,720 --> 00:05:14,160
there's not so much regulation in these

163
00:05:12,720 --> 00:05:17,120
blockchain exchanges

164
00:05:14,160 --> 00:05:19,759
so it's important to use cryptography to

165
00:05:17,120 --> 00:05:22,000
provably prevent these types of attacks

166
00:05:19,759 --> 00:05:24,160
so there's a lot of practical motivation

167
00:05:22,000 --> 00:05:26,400
actually for order fairness and i'm

168
00:05:24,160 --> 00:05:28,160
really only scratching the surface

169
00:05:26,400 --> 00:05:29,840
i highly encourage you to read this

170
00:05:28,160 --> 00:05:33,199
diane at all paper if you're interested

171
00:05:29,840 --> 00:05:34,560
in these types of reordering attacks

172
00:05:33,199 --> 00:05:36,479
but we think that there's a strong

173
00:05:34,560 --> 00:05:38,080
theoretical motivation as well

174
00:05:36,479 --> 00:05:39,599
and for cryptographers i think that's

175
00:05:38,080 --> 00:05:41,840
equally important

176
00:05:39,600 --> 00:05:44,240
so order fairness as it turns out is a

177
00:05:41,840 --> 00:05:46,400
natural analog of the validity condition

178
00:05:44,240 --> 00:05:47,440
the closely related byzantine agreement

179
00:05:46,400 --> 00:05:50,400
problem

180
00:05:47,440 --> 00:05:52,320
so in the ba problem all nodes are input

181
00:05:50,400 --> 00:05:54,479
some value in a value set

182
00:05:52,320 --> 00:05:56,159
and the goal is for them to agree on the

183
00:05:54,479 --> 00:05:58,318
same output value

184
00:05:56,160 --> 00:05:59,919
the validity property says that if all

185
00:05:58,319 --> 00:06:02,240
of the honest nodes are input

186
00:05:59,919 --> 00:06:03,039
a value v then all of the honest nodes

187
00:06:02,240 --> 00:06:05,919
should also

188
00:06:03,039 --> 00:06:08,159
output the value v i haven't formally

189
00:06:05,919 --> 00:06:09,198
defined order fairness but here's the

190
00:06:08,160 --> 00:06:11,840
gist

191
00:06:09,199 --> 00:06:13,039
if all of the honest nodes are input m1

192
00:06:11,840 --> 00:06:14,719
before m2

193
00:06:13,039 --> 00:06:17,199
then all of the honest nodes should

194
00:06:14,720 --> 00:06:19,440
agree to output m1 before m2

195
00:06:17,199 --> 00:06:21,520
so in a sense order fairness is exactly

196
00:06:19,440 --> 00:06:24,080
the analog of validity

197
00:06:21,520 --> 00:06:26,560
extended to a more continuous version of

198
00:06:24,080 --> 00:06:28,719
the agreement problem

199
00:06:26,560 --> 00:06:29,680
so just to put order fairness in the

200
00:06:28,720 --> 00:06:32,000
context of

201
00:06:29,680 --> 00:06:33,600
current techniques i'll briefly compare

202
00:06:32,000 --> 00:06:35,120
to related notions

203
00:06:33,600 --> 00:06:37,840
but see our paper for the full

204
00:06:35,120 --> 00:06:39,440
comparison to related work

205
00:06:37,840 --> 00:06:41,198
so usually there's a couple different

206
00:06:39,440 --> 00:06:42,880
techniques in which ordering can be

207
00:06:41,199 --> 00:06:44,800
manipulated by a node

208
00:06:42,880 --> 00:06:46,000
so a malicious node can censor

209
00:06:44,800 --> 00:06:48,479
transactions

210
00:06:46,000 --> 00:06:49,360
or insert its own or try to reorder

211
00:06:48,479 --> 00:06:52,240
transactions

212
00:06:49,360 --> 00:06:53,840
in general so there's several protocols

213
00:06:52,240 --> 00:06:56,000
that provide the so-called

214
00:06:53,840 --> 00:06:57,198
censorship resistance property so this

215
00:06:56,000 --> 00:06:59,440
informally means that

216
00:06:57,199 --> 00:07:02,160
any honest user transaction will

217
00:06:59,440 --> 00:07:03,840
eventually make its way into the log

218
00:07:02,160 --> 00:07:06,080
so censorship resistance is a great

219
00:07:03,840 --> 00:07:06,960
first step but it doesn't really prevent

220
00:07:06,080 --> 00:07:10,080
any form of

221
00:07:06,960 --> 00:07:12,479
insertion or reordering attacks

222
00:07:10,080 --> 00:07:14,880
another line of work has focused on

223
00:07:12,479 --> 00:07:17,440
electing the leaders randomly

224
00:07:14,880 --> 00:07:18,560
so you don't give a particular leader

225
00:07:17,440 --> 00:07:20,400
too much power

226
00:07:18,560 --> 00:07:21,759
so let's say a leader is elected at

227
00:07:20,400 --> 00:07:24,159
every round and then

228
00:07:21,759 --> 00:07:26,080
for that round the leader is responsible

229
00:07:24,160 --> 00:07:28,240
for the proposal

230
00:07:26,080 --> 00:07:30,080
but here adversarial leaders will also

231
00:07:28,240 --> 00:07:32,240
get elected every now and then

232
00:07:30,080 --> 00:07:35,280
and whenever they are elected they can

233
00:07:32,240 --> 00:07:38,880
manipulate the ordering at will

234
00:07:35,280 --> 00:07:41,119
uh probably heavy heavyweight technique

235
00:07:38,880 --> 00:07:42,719
that's been explored recently is to use

236
00:07:41,120 --> 00:07:44,720
threshold encryption

237
00:07:42,720 --> 00:07:45,919
to ensure that the order of transactions

238
00:07:44,720 --> 00:07:48,639
is fixed

239
00:07:45,919 --> 00:07:50,479
before the actual contents are revealed

240
00:07:48,639 --> 00:07:52,800
so this is quite nice actually

241
00:07:50,479 --> 00:07:54,800
from a purely definitional standpoint an

242
00:07:52,800 --> 00:07:58,080
adversary should still be able to

243
00:07:54,800 --> 00:07:59,680
randomly or blindly sense or reorder but

244
00:07:58,080 --> 00:08:01,758
you may argue that there's no real

245
00:07:59,680 --> 00:08:02,720
incentive for an adversary to do this in

246
00:08:01,759 --> 00:08:05,280
practice

247
00:08:02,720 --> 00:08:05,919
so threshold encryption does prevent a

248
00:08:05,280 --> 00:08:08,318
lot of

249
00:08:05,919 --> 00:08:09,680
real world attacks but it still has one

250
00:08:08,319 --> 00:08:11,840
major problem

251
00:08:09,680 --> 00:08:12,720
if the adversarial notice colluding with

252
00:08:11,840 --> 00:08:15,520
the user

253
00:08:12,720 --> 00:08:16,960
it knows which encryption corresponds to

254
00:08:15,520 --> 00:08:18,799
the user transaction

255
00:08:16,960 --> 00:08:20,239
and therefore it can try to sequence it

256
00:08:18,800 --> 00:08:22,400
first so our

257
00:08:20,240 --> 00:08:24,240
property of order fairness is actually

258
00:08:22,400 --> 00:08:25,599
strictly stronger than these earlier

259
00:08:24,240 --> 00:08:27,360
considered notions

260
00:08:25,599 --> 00:08:29,440
so it should be able to prevent all

261
00:08:27,360 --> 00:08:32,080
kinds of censorship and insertion and

262
00:08:29,440 --> 00:08:33,519
reordering attacks

263
00:08:32,080 --> 00:08:35,440
all right so hopefully by now i've

264
00:08:33,519 --> 00:08:37,039
convinced you that order fairness is

265
00:08:35,440 --> 00:08:39,120
indeed important to study

266
00:08:37,039 --> 00:08:40,718
and that no current protocol actually

267
00:08:39,120 --> 00:08:42,560
achieves this notion

268
00:08:40,719 --> 00:08:44,159
so next i'll like to go into a little

269
00:08:42,559 --> 00:08:47,920
more detail about our model

270
00:08:44,159 --> 00:08:50,160
and our definitions of order fairness

271
00:08:47,920 --> 00:08:51,439
so we model a permission network with n

272
00:08:50,160 --> 00:08:53,760
nodes in total

273
00:08:51,440 --> 00:08:55,040
and out of these at most f can be

274
00:08:53,760 --> 00:08:57,200
adversarial

275
00:08:55,040 --> 00:08:59,279
we also allow clients to collude with

276
00:08:57,200 --> 00:09:01,839
protocol nodes

277
00:08:59,279 --> 00:09:03,760
in terms of the communication we model

278
00:09:01,839 --> 00:09:05,600
two different kinds of networks

279
00:09:03,760 --> 00:09:07,760
an external network and an internal

280
00:09:05,600 --> 00:09:09,519
network so the external network is the

281
00:09:07,760 --> 00:09:11,439
communication channel between the

282
00:09:09,519 --> 00:09:13,200
clients and the consensus nodes

283
00:09:11,440 --> 00:09:15,120
and the internal network is the one

284
00:09:13,200 --> 00:09:16,640
that's usually modeled in literature

285
00:09:15,120 --> 00:09:19,040
and it's the channel amongst the

286
00:09:16,640 --> 00:09:19,519
consensus nodes so for the external

287
00:09:19,040 --> 00:09:21,279
network

288
00:09:19,519 --> 00:09:23,360
we assume that the clients send their

289
00:09:21,279 --> 00:09:25,120
transactions to all of the nodes instead

290
00:09:23,360 --> 00:09:26,959
of just one leader node

291
00:09:25,120 --> 00:09:28,959
we also assume that the adversary is not

292
00:09:26,959 --> 00:09:30,800
in charge of the message delivery here

293
00:09:28,959 --> 00:09:33,119
so intuitively this makes sense because

294
00:09:30,800 --> 00:09:35,120
otherwise it would essentially imply

295
00:09:33,120 --> 00:09:37,680
that the adversary is in charge of the

296
00:09:35,120 --> 00:09:39,519
client's connection to the internet

297
00:09:37,680 --> 00:09:42,719
the adversarial assumptions for the

298
00:09:39,519 --> 00:09:44,880
internal network are standardly modeled

299
00:09:42,720 --> 00:09:46,160
so basically the adversary handles all

300
00:09:44,880 --> 00:09:48,839
of the message delivery

301
00:09:46,160 --> 00:09:50,640
and can reorder messages and can't drop

302
00:09:48,839 --> 00:09:53,519
messages

303
00:09:50,640 --> 00:09:55,439
it also moves last in every round so it

304
00:09:53,519 --> 00:09:57,839
can see the broadcast

305
00:09:55,440 --> 00:10:00,399
from other nodes before deciding on its

306
00:09:57,839 --> 00:10:02,240
own messages

307
00:10:00,399 --> 00:10:05,519
okay so next i'll describe what it means

308
00:10:02,240 --> 00:10:09,120
for our protocols to be synchronous

309
00:10:05,519 --> 00:10:10,880
in the in this talk i'll focus mostly on

310
00:10:09,120 --> 00:10:12,800
our synchronous protocol

311
00:10:10,880 --> 00:10:14,800
but our protocols can actually be made

312
00:10:12,800 --> 00:10:16,079
to work for completely asynchronous

313
00:10:14,800 --> 00:10:18,640
models as well

314
00:10:16,079 --> 00:10:20,640
so to define synchrony we assume that

315
00:10:18,640 --> 00:10:22,640
the protocols takes place in

316
00:10:20,640 --> 00:10:23,760
rounds and our nodes have consistent

317
00:10:22,640 --> 00:10:25,839
clocks

318
00:10:23,760 --> 00:10:27,200
so the external network is said to be

319
00:10:25,839 --> 00:10:29,440
delta synchronous

320
00:10:27,200 --> 00:10:31,279
if the following condition holds if a

321
00:10:29,440 --> 00:10:34,079
transaction is input to

322
00:10:31,279 --> 00:10:36,000
some node in round r then all of the

323
00:10:34,079 --> 00:10:38,959
honest nodes will have received it as

324
00:10:36,000 --> 00:10:40,880
input in round r plus delta so

325
00:10:38,959 --> 00:10:43,119
informally this is the assumption that a

326
00:10:40,880 --> 00:10:45,839
client's connection to one node

327
00:10:43,120 --> 00:10:47,200
isn't much slower than its connection to

328
00:10:45,839 --> 00:10:49,120
other nodes

329
00:10:47,200 --> 00:10:50,320
so for the internal network our

330
00:10:49,120 --> 00:10:53,519
synchrony assumption

331
00:10:50,320 --> 00:10:55,600
is the same as prior word so formally

332
00:10:53,519 --> 00:10:56,640
the internal network is said to be delta

333
00:10:55,600 --> 00:10:59,040
synchronous

334
00:10:56,640 --> 00:11:00,160
if when an honest node sends a message

335
00:10:59,040 --> 00:11:02,079
in round r

336
00:11:00,160 --> 00:11:03,519
all of the intended recipients should

337
00:11:02,079 --> 00:11:06,640
have received it

338
00:11:03,519 --> 00:11:08,880
in round r plus delta

339
00:11:06,640 --> 00:11:11,199
okay so having set up the groundwork for

340
00:11:08,880 --> 00:11:13,279
our model we can now start to think

341
00:11:11,200 --> 00:11:14,640
of how best to define this order

342
00:11:13,279 --> 00:11:16,480
fairness

343
00:11:14,640 --> 00:11:18,399
so here's a natural definition which we

344
00:11:16,480 --> 00:11:20,720
call receive order fairness

345
00:11:18,399 --> 00:11:22,160
so for an order fairness parameter gamma

346
00:11:20,720 --> 00:11:26,079
which is at least half

347
00:11:22,160 --> 00:11:28,079
and at most one um gamma order fairness

348
00:11:26,079 --> 00:11:31,439
is defined as follows

349
00:11:28,079 --> 00:11:34,239
so if gamma times n nodes are input

350
00:11:31,440 --> 00:11:36,720
m1 before m2 then all of the honest

351
00:11:34,240 --> 00:11:38,079
nodes should deliver m1 before n2

352
00:11:36,720 --> 00:11:40,240
and this is very similar to the

353
00:11:38,079 --> 00:11:41,760
definition i mentioned when comparing it

354
00:11:40,240 --> 00:11:43,920
to ba validity

355
00:11:41,760 --> 00:11:46,800
but here we now add an extra order

356
00:11:43,920 --> 00:11:48,640
fairness parameter

357
00:11:46,800 --> 00:11:50,399
so the receive order fairness definition

358
00:11:48,640 --> 00:11:51,839
is probably the most natural way to

359
00:11:50,399 --> 00:11:54,079
define fair ordering

360
00:11:51,839 --> 00:11:56,160
but it does have one major flaw

361
00:11:54,079 --> 00:11:57,760
basically carefully chosen transaction

362
00:11:56,160 --> 00:11:59,040
orderings can lead to a global

363
00:11:57,760 --> 00:12:01,519
intransitivity

364
00:11:59,040 --> 00:12:03,360
or a cycle in the ordering so for this

365
00:12:01,519 --> 00:12:03,839
we'll draw from a surprising connection

366
00:12:03,360 --> 00:12:06,399
to

367
00:12:03,839 --> 00:12:08,079
social choice theory particularly the

368
00:12:06,399 --> 00:12:09,519
conor say paradox

369
00:12:08,079 --> 00:12:11,760
so the conor say paradox is the

370
00:12:09,519 --> 00:12:14,560
situation resultant from a global

371
00:12:11,760 --> 00:12:16,319
non-transitive preference even when all

372
00:12:14,560 --> 00:12:17,839
the individual preferences are

373
00:12:16,320 --> 00:12:20,000
transitive

374
00:12:17,839 --> 00:12:22,160
in the context of order fairness let's

375
00:12:20,000 --> 00:12:24,480
look at a simple example

376
00:12:22,160 --> 00:12:26,240
so suppose we have three protocol notes

377
00:12:24,480 --> 00:12:28,560
alice bob and carol

378
00:12:26,240 --> 00:12:30,240
and there's three transactions x y and z

379
00:12:28,560 --> 00:12:32,560
input into the system

380
00:12:30,240 --> 00:12:33,839
so alice receives them in the order x y

381
00:12:32,560 --> 00:12:39,599
z bob in the order

382
00:12:33,839 --> 00:12:42,160
y z x and carol in the order of zx1

383
00:12:39,600 --> 00:12:42,959
so now two nodes have received x before

384
00:12:42,160 --> 00:12:45,199
y

385
00:12:42,959 --> 00:12:47,599
two nodes have received y before z and

386
00:12:45,200 --> 00:12:49,839
two nodes have received z before x

387
00:12:47,600 --> 00:12:50,880
so any majority receive order fare

388
00:12:49,839 --> 00:12:55,040
protocol

389
00:12:50,880 --> 00:12:56,800
should order transactions this way

390
00:12:55,040 --> 00:12:59,360
but now if you look closely at the

391
00:12:56,800 --> 00:13:01,839
constraints you'll see that the final

392
00:12:59,360 --> 00:13:04,320
final ordering needs to be cyclic which

393
00:13:01,839 --> 00:13:06,560
results in a contradiction

394
00:13:04,320 --> 00:13:08,480
we can extrapolate this impossibility

395
00:13:06,560 --> 00:13:11,040
result to a general end

396
00:13:08,480 --> 00:13:11,920
our informal result is that for any n

397
00:13:11,040 --> 00:13:14,399
for any f

398
00:13:11,920 --> 00:13:15,199
greater than or equal to one and any

399
00:13:14,399 --> 00:13:17,360
gamma

400
00:13:15,200 --> 00:13:19,519
no protocol can achieve all of

401
00:13:17,360 --> 00:13:20,320
consistency liveness and receive order

402
00:13:19,519 --> 00:13:22,240
fairness

403
00:13:20,320 --> 00:13:23,839
if the external network synchrony bound

404
00:13:22,240 --> 00:13:25,600
is at least n

405
00:13:23,839 --> 00:13:27,920
for gamma less than one the

406
00:13:25,600 --> 00:13:28,160
impossibility result actually holds even

407
00:13:27,920 --> 00:13:31,279
if

408
00:13:28,160 --> 00:13:31,279
x equals zero

409
00:13:31,360 --> 00:13:34,800
so to weaken our definition we

410
00:13:33,440 --> 00:13:37,920
considered several

411
00:13:34,800 --> 00:13:40,160
alternative uh ones in our paper

412
00:13:37,920 --> 00:13:42,079
but here's the one we settled on we call

413
00:13:40,160 --> 00:13:43,920
this block order fairness

414
00:13:42,079 --> 00:13:46,160
so we think this intuitively captures

415
00:13:43,920 --> 00:13:47,920
the same first and first stop notion

416
00:13:46,160 --> 00:13:49,360
but we can construct protocols to

417
00:13:47,920 --> 00:13:50,880
realize it

418
00:13:49,360 --> 00:13:52,320
the key difference between this

419
00:13:50,880 --> 00:13:53,839
definition and the receive order

420
00:13:52,320 --> 00:13:55,760
fairness definition

421
00:13:53,839 --> 00:13:57,760
is that the protocol is now allowed to

422
00:13:55,760 --> 00:14:00,000
deliver m1 and m2

423
00:13:57,760 --> 00:14:02,160
in the same block so hence the aptly

424
00:14:00,000 --> 00:14:04,639
named block order fairness

425
00:14:02,160 --> 00:14:06,560
m1 just can't be delivered in the later

426
00:14:04,639 --> 00:14:08,399
vlog

427
00:14:06,560 --> 00:14:10,638
so this is a small definitional change

428
00:14:08,399 --> 00:14:12,720
but it's actually quite significant

429
00:14:10,639 --> 00:14:14,560
because it allows us to sidestep the

430
00:14:12,720 --> 00:14:16,399
condorcet paradox

431
00:14:14,560 --> 00:14:17,760
so this is done by placing the

432
00:14:16,399 --> 00:14:19,760
transactions with

433
00:14:17,760 --> 00:14:22,560
uh contradictory or non-transitive

434
00:14:19,760 --> 00:14:24,959
orderings into the same block

435
00:14:22,560 --> 00:14:26,479
an important point here is that the

436
00:14:24,959 --> 00:14:27,760
transactions in a block are still

437
00:14:26,480 --> 00:14:29,440
totally ordered

438
00:14:27,760 --> 00:14:31,279
it's just that the reordering within a

439
00:14:29,440 --> 00:14:32,480
block is no longer considered to be

440
00:14:31,279 --> 00:14:34,800
unfair

441
00:14:32,480 --> 00:14:36,639
so we'll use minimal use of this

442
00:14:34,800 --> 00:14:38,560
relaxation

443
00:14:36,639 --> 00:14:39,680
our protocols will actually achieve the

444
00:14:38,560 --> 00:14:41,839
stronger receive

445
00:14:39,680 --> 00:14:44,079
order fairness definition except when

446
00:14:41,839 --> 00:14:47,760
it's actually impossible to achieve

447
00:14:44,079 --> 00:14:47,760
because of the condorcet paradox

448
00:14:48,240 --> 00:14:52,880
okay before i get into describing our

449
00:14:50,399 --> 00:14:55,120
actual protocols i want to put forth a

450
00:14:52,880 --> 00:14:57,680
straw man protocol to build intuition

451
00:14:55,120 --> 00:14:59,360
on why it's non-trivial the first

452
00:14:57,680 --> 00:15:01,120
thought that comes to mind is well why

453
00:14:59,360 --> 00:15:03,760
not just use a median time stamping

454
00:15:01,120 --> 00:15:05,680
protocol as a proxy for the ordering

455
00:15:03,760 --> 00:15:08,959
so clearly if all of the honest node

456
00:15:05,680 --> 00:15:11,040
receive a transaction tx1 before tx2

457
00:15:08,959 --> 00:15:12,239
then the median timestamp for tx1 will

458
00:15:11,040 --> 00:15:14,319
be smaller

459
00:15:12,240 --> 00:15:17,040
so the problem with this logic lies in

460
00:15:14,320 --> 00:15:19,760
the presence of even a single adversary

461
00:15:17,040 --> 00:15:21,439
which can flip its own ordering by

462
00:15:19,760 --> 00:15:23,199
claiming to have received

463
00:15:21,440 --> 00:15:24,480
a different ordering than it actually

464
00:15:23,199 --> 00:15:26,160
did

465
00:15:24,480 --> 00:15:28,800
so i'll illustrate this with a simple

466
00:15:26,160 --> 00:15:31,439
example so suppose there's five notes

467
00:15:28,800 --> 00:15:33,758
a b c d and e and there's two

468
00:15:31,440 --> 00:15:36,320
transactions tx1 and tx2

469
00:15:33,759 --> 00:15:38,800
so tx1 is highlighted and highlighted in

470
00:15:36,320 --> 00:15:41,519
yellow and tx2 is highlighted in green

471
00:15:38,800 --> 00:15:43,439
and all of the nodes have received tx1

472
00:15:41,519 --> 00:15:45,040
before tx2

473
00:15:43,440 --> 00:15:47,040
so now if you calculate the median

474
00:15:45,040 --> 00:15:49,599
timestamps you'll find that the median

475
00:15:47,040 --> 00:15:50,160
for tx1 is 2 and the median for tx2 is

476
00:15:49,600 --> 00:15:52,399
3.

477
00:15:50,160 --> 00:15:53,360
so everything's good so far now let's

478
00:15:52,399 --> 00:15:55,839
see what happens

479
00:15:53,360 --> 00:15:57,360
when e is malicious and decides to claim

480
00:15:55,839 --> 00:15:58,720
a different ordering than the one it

481
00:15:57,360 --> 00:16:00,800
actually received

482
00:15:58,720 --> 00:16:03,040
so recall that since the adversary has

483
00:16:00,800 --> 00:16:05,199
the ability to move last

484
00:16:03,040 --> 00:16:06,719
it can strategically choose its own

485
00:16:05,199 --> 00:16:09,920
input ordering after seeing the

486
00:16:06,720 --> 00:16:11,759
broadcast by other nodes

487
00:16:09,920 --> 00:16:13,599
so let's say e claims to have received

488
00:16:11,759 --> 00:16:16,399
tx2 in round two

489
00:16:13,600 --> 00:16:18,480
and tx1 in round three now if you

490
00:16:16,399 --> 00:16:21,199
calculate the median timestamp

491
00:16:18,480 --> 00:16:22,079
you'll notice that the median for tx1 is

492
00:16:21,199 --> 00:16:24,800
3 which is

493
00:16:22,079 --> 00:16:27,120
larger than the median for tx2 so this

494
00:16:24,800 --> 00:16:30,880
means that a median timestamp protocol

495
00:16:27,120 --> 00:16:32,399
would order tx2 before tx1 even though

496
00:16:30,880 --> 00:16:34,399
all honest nodes received the

497
00:16:32,399 --> 00:16:37,440
transactions in the opposite order

498
00:16:34,399 --> 00:16:40,079
so this clearly wouldn't work

499
00:16:37,440 --> 00:16:40,639
okay so let me now talk a little bit

500
00:16:40,079 --> 00:16:43,680
about

501
00:16:40,639 --> 00:16:45,920
our actual fare ordering protocols so we

502
00:16:43,680 --> 00:16:48,638
describe our protocol iquitas

503
00:16:45,920 --> 00:16:50,959
which is named after the roman

504
00:16:48,639 --> 00:16:53,040
personification for fairness

505
00:16:50,959 --> 00:16:55,040
so broadly the iquitos protocol will

506
00:16:53,040 --> 00:16:57,279
take place in three stages

507
00:16:55,040 --> 00:16:59,040
the gossip stage the agreement stage and

508
00:16:57,279 --> 00:17:01,120
the finalization stage

509
00:16:59,040 --> 00:17:02,079
and the transactions that are input into

510
00:17:01,120 --> 00:17:03,759
the system

511
00:17:02,079 --> 00:17:06,079
will go through each of these three

512
00:17:03,759 --> 00:17:07,839
stages before finally being delivered as

513
00:17:06,079 --> 00:17:09,678
part of the blockchain

514
00:17:07,839 --> 00:17:12,159
in the next several slides i'll go

515
00:17:09,679 --> 00:17:14,240
through the key ideas for each one of

516
00:17:12,160 --> 00:17:16,079
these three stages

517
00:17:14,240 --> 00:17:18,240
so the first stage that a transaction

518
00:17:16,079 --> 00:17:20,720
goes through is the gossip stage

519
00:17:18,240 --> 00:17:23,039
so in this stage honest nodes broadcast

520
00:17:20,720 --> 00:17:25,600
transactions to all of the other nodes

521
00:17:23,039 --> 00:17:26,640
in the order that they were received so

522
00:17:25,599 --> 00:17:28,719
and at the same time

523
00:17:26,640 --> 00:17:30,480
nodes process the broadcast received

524
00:17:28,720 --> 00:17:33,760
from others and store them in

525
00:17:30,480 --> 00:17:37,120
local logs so local log subscript i

526
00:17:33,760 --> 00:17:39,280
superscript j contains node eyes view

527
00:17:37,120 --> 00:17:40,559
of how the transactions were received by

528
00:17:39,280 --> 00:17:42,320
node j

529
00:17:40,559 --> 00:17:44,240
so at the end of the stage we want to

530
00:17:42,320 --> 00:17:45,360
guarantee that these local logs are

531
00:17:44,240 --> 00:17:48,080
consistent

532
00:17:45,360 --> 00:17:48,399
so basically two honest nodes should not

533
00:17:48,080 --> 00:17:50,720
have

534
00:17:48,400 --> 00:17:52,720
different views of the broadcasts by

535
00:17:50,720 --> 00:17:55,520
another node

536
00:17:52,720 --> 00:17:58,000
to accomplish this we use the fifo or

537
00:17:55,520 --> 00:18:00,160
first in first out broadcast primitive

538
00:17:58,000 --> 00:18:02,320
in a fifo broadcast protocol there's a

539
00:18:00,160 --> 00:18:04,880
single defined sender that sends

540
00:18:02,320 --> 00:18:05,760
a series of messages to all of the other

541
00:18:04,880 --> 00:18:07,840
nodes

542
00:18:05,760 --> 00:18:09,200
so fifa broadcast guarantees that if the

543
00:18:07,840 --> 00:18:11,120
sender is honest

544
00:18:09,200 --> 00:18:13,120
then its broadcast will be delivered in

545
00:18:11,120 --> 00:18:14,479
the same order as they were initially

546
00:18:13,120 --> 00:18:16,639
broadcast

547
00:18:14,480 --> 00:18:18,240
even if the sender is malicious its

548
00:18:16,640 --> 00:18:19,679
broadcast will be delivered in a

549
00:18:18,240 --> 00:18:21,520
consistent order

550
00:18:19,679 --> 00:18:23,679
so all of the nodes should deliver them

551
00:18:21,520 --> 00:18:25,760
in the same order as each other

552
00:18:23,679 --> 00:18:27,679
but this may not be the same order as

553
00:18:25,760 --> 00:18:29,840
they were initially broadcast by the

554
00:18:27,679 --> 00:18:32,080
adversarial sender

555
00:18:29,840 --> 00:18:32,959
prior work has shown how to realize fifo

556
00:18:32,080 --> 00:18:36,320
broadcast

557
00:18:32,960 --> 00:18:38,400
just from standard reliable broadcast

558
00:18:36,320 --> 00:18:40,480
in our protocol nodes will instantiate

559
00:18:38,400 --> 00:18:43,360
this fifo broadcast primitive

560
00:18:40,480 --> 00:18:44,240
in order to broadcast their transactions

561
00:18:43,360 --> 00:18:46,240
so there will be

562
00:18:44,240 --> 00:18:48,320
n different instances of the fifo

563
00:18:46,240 --> 00:18:51,520
broadcast one for each node

564
00:18:48,320 --> 00:18:54,000
so the gossip stage will end when

565
00:18:51,520 --> 00:18:56,160
enough time has passed for all of the

566
00:18:54,000 --> 00:18:59,600
honest nodes to broadcast

567
00:18:56,160 --> 00:18:59,600
this transaction tx

568
00:19:00,000 --> 00:19:04,559
the second stage of our iq task protocol

569
00:19:02,960 --> 00:19:06,559
is the agreement stage

570
00:19:04,559 --> 00:19:09,360
so after the gossip stage for some

571
00:19:06,559 --> 00:19:11,200
particular transaction tx has ended

572
00:19:09,360 --> 00:19:13,918
all of the honest notes will have a set

573
00:19:11,200 --> 00:19:15,600
of local logs that contain tx

574
00:19:13,919 --> 00:19:17,679
but these nodes may have received

575
00:19:15,600 --> 00:19:20,159
different like local logs from

576
00:19:17,679 --> 00:19:21,280
different nodes by the time the gossip

577
00:19:20,160 --> 00:19:23,760
stage ends

578
00:19:21,280 --> 00:19:26,399
and in the agreement stage the goal is

579
00:19:23,760 --> 00:19:27,440
to agree on exactly which local locks to

580
00:19:26,400 --> 00:19:30,799
use to order

581
00:19:27,440 --> 00:19:32,640
tx the main guarantee that we want

582
00:19:30,799 --> 00:19:35,120
is that all of the honest nodes should

583
00:19:32,640 --> 00:19:36,480
use the same local logs to finalize the

584
00:19:35,120 --> 00:19:38,639
ordering

585
00:19:36,480 --> 00:19:39,919
since the logs are already consistent

586
00:19:38,640 --> 00:19:41,840
from the gossip stage

587
00:19:39,919 --> 00:19:43,200
this means that all of the nodes will

588
00:19:41,840 --> 00:19:45,520
use the same data

589
00:19:43,200 --> 00:19:47,120
to compute the final ordering so this

590
00:19:45,520 --> 00:19:48,960
agreement stage can be easily

591
00:19:47,120 --> 00:19:52,639
extrapolated from standard

592
00:19:48,960 --> 00:19:54,720
uh byzantine agreement

593
00:19:52,640 --> 00:19:57,039
the third and last stage is the not so

594
00:19:54,720 --> 00:19:58,640
cleverly named finalization stage

595
00:19:57,039 --> 00:20:00,640
where you might have guessed it nodes

596
00:19:58,640 --> 00:20:02,320
will finalize the ordering for a given

597
00:20:00,640 --> 00:20:04,960
transaction tx

598
00:20:02,320 --> 00:20:07,200
so our finalization stage is leaderless

599
00:20:04,960 --> 00:20:09,120
and involves no further communication

600
00:20:07,200 --> 00:20:11,200
between the consensus nodes

601
00:20:09,120 --> 00:20:12,959
all of the computation can be performed

602
00:20:11,200 --> 00:20:14,720
locally

603
00:20:12,960 --> 00:20:17,200
the main sub-problem for the

604
00:20:14,720 --> 00:20:19,520
finalization stage that we need to solve

605
00:20:17,200 --> 00:20:20,720
is to decide on the ordering for a given

606
00:20:19,520 --> 00:20:24,000
pair of transactions

607
00:20:20,720 --> 00:20:27,120
tx and tx prime so for this and

608
00:20:24,000 --> 00:20:29,120
a node will look at if one transaction

609
00:20:27,120 --> 00:20:31,199
occurs before the other in a large

610
00:20:29,120 --> 00:20:32,959
number of these local logs

611
00:20:31,200 --> 00:20:35,360
so for example if many local locks

612
00:20:32,960 --> 00:20:37,200
contain tx prime before tx

613
00:20:35,360 --> 00:20:38,799
then ideally tx prime should be

614
00:20:37,200 --> 00:20:40,960
delivered first

615
00:20:38,799 --> 00:20:43,280
this means that before proceeding with

616
00:20:40,960 --> 00:20:45,600
the finalization stage for tx

617
00:20:43,280 --> 00:20:47,440
we should wait until tx prime has been

618
00:20:45,600 --> 00:20:49,600
delivered in the final log

619
00:20:47,440 --> 00:20:50,640
so in this case we say that tx is

620
00:20:49,600 --> 00:20:52,879
waiting for tx

621
00:20:50,640 --> 00:20:54,960
prime and these sort of relations

622
00:20:52,880 --> 00:20:56,240
between transactions can be viewed as a

623
00:20:54,960 --> 00:20:57,840
directed graph

624
00:20:56,240 --> 00:20:59,919
which we call the dependency or the

625
00:20:57,840 --> 00:21:02,559
waiting graph so in this graph

626
00:20:59,919 --> 00:21:03,440
vertices will represent transactions and

627
00:21:02,559 --> 00:21:06,480
an edge from

628
00:21:03,440 --> 00:21:09,600
a to b will represent that b is waiting

629
00:21:06,480 --> 00:21:09,600
for a to be delivered

630
00:21:09,679 --> 00:21:13,600
okay so what if there's no clear winner

631
00:21:11,919 --> 00:21:15,520
so what if there's not one of these

632
00:21:13,600 --> 00:21:17,439
transactions that occurs before the

633
00:21:15,520 --> 00:21:19,120
other large number of times

634
00:21:17,440 --> 00:21:21,039
so this will correspond to there not

635
00:21:19,120 --> 00:21:22,799
being an edge in the graph between these

636
00:21:21,039 --> 00:21:25,520
two transactions

637
00:21:22,799 --> 00:21:27,200
so essentially there's two main problems

638
00:21:25,520 --> 00:21:29,440
that we need to solve

639
00:21:27,200 --> 00:21:30,480
the first problem is that the graph may

640
00:21:29,440 --> 00:21:33,120
not be

641
00:21:30,480 --> 00:21:33,520
complete or even connected so this means

642
00:21:33,120 --> 00:21:35,918
that

643
00:21:33,520 --> 00:21:37,039
some transactions may not be comparable

644
00:21:35,919 --> 00:21:39,039
as of now

645
00:21:37,039 --> 00:21:40,158
so to retrieve a total ordering from

646
00:21:39,039 --> 00:21:42,080
this graph

647
00:21:40,159 --> 00:21:43,679
we need some way to compare these

648
00:21:42,080 --> 00:21:46,000
transactions

649
00:21:43,679 --> 00:21:47,520
the other problem is that the graph may

650
00:21:46,000 --> 00:21:51,360
still have cycles

651
00:21:47,520 --> 00:21:53,520
courtesy of the condorcet paradox

652
00:21:51,360 --> 00:21:56,320
so to solve the first problem the key

653
00:21:53,520 --> 00:21:58,320
idea is to wait for a common descendant

654
00:21:56,320 --> 00:21:59,760
before ordering transactions that don't

655
00:21:58,320 --> 00:22:01,760
have an edge

656
00:21:59,760 --> 00:22:03,760
so now the ordering can be based on the

657
00:22:01,760 --> 00:22:06,000
maximum number of descendants

658
00:22:03,760 --> 00:22:08,158
for each of the transactions and in case

659
00:22:06,000 --> 00:22:09,679
there's a tie we can use a predetermined

660
00:22:08,159 --> 00:22:11,520
tiebreaker function

661
00:22:09,679 --> 00:22:13,679
so the intuitive explanation for why

662
00:22:11,520 --> 00:22:15,039
this works is that once a common

663
00:22:13,679 --> 00:22:17,039
descendant arrives

664
00:22:15,039 --> 00:22:18,960
any other transaction that arrives later

665
00:22:17,039 --> 00:22:20,320
will also be a common descendant

666
00:22:18,960 --> 00:22:21,840
so this means that the difference

667
00:22:20,320 --> 00:22:23,200
between the descendants will stay the

668
00:22:21,840 --> 00:22:25,120
same henceforth

669
00:22:23,200 --> 00:22:26,240
so this is crucial to maintain

670
00:22:25,120 --> 00:22:28,479
consistency

671
00:22:26,240 --> 00:22:29,600
so whenever a node decides to order two

672
00:22:28,480 --> 00:22:31,039
transactions

673
00:22:29,600 --> 00:22:32,959
the difference between the number of

674
00:22:31,039 --> 00:22:34,799
descendants will be the same as when

675
00:22:32,960 --> 00:22:37,200
another node decides to order the same

676
00:22:34,799 --> 00:22:38,960
number of the same pair of transactions

677
00:22:37,200 --> 00:22:43,520
so this will ensure that all of the

678
00:22:38,960 --> 00:22:43,520
nodes take the same ordering decision

679
00:22:43,840 --> 00:22:48,480
the second problem is that the

680
00:22:45,760 --> 00:22:50,320
dependency graph may still have cycles

681
00:22:48,480 --> 00:22:52,640
so to get a total ordering we will

682
00:22:50,320 --> 00:22:54,559
compute the condensation graph

683
00:22:52,640 --> 00:22:55,679
by collapsing the strongly connected

684
00:22:54,559 --> 00:22:57,440
components

685
00:22:55,679 --> 00:22:59,679
so the condensation graph is now

686
00:22:57,440 --> 00:23:02,159
guaranteed to be acyclic

687
00:22:59,679 --> 00:23:04,720
and vertices in a cycle will be included

688
00:23:02,159 --> 00:23:06,720
in the same strongly connected component

689
00:23:04,720 --> 00:23:08,960
so now we can use the trick i mentioned

690
00:23:06,720 --> 00:23:09,919
earlier by delivering these cycles

691
00:23:08,960 --> 00:23:11,360
together

692
00:23:09,919 --> 00:23:13,200
so this is done by delivering the

693
00:23:11,360 --> 00:23:15,199
transactions in the same strongly

694
00:23:13,200 --> 00:23:17,280
connected component as part of the same

695
00:23:15,200 --> 00:23:18,720
block

696
00:23:17,280 --> 00:23:20,480
so that's pretty much the gist of our

697
00:23:18,720 --> 00:23:22,159
protocol there's a few more

698
00:23:20,480 --> 00:23:23,360
considerations that need to be dealt

699
00:23:22,159 --> 00:23:26,799
with carefully

700
00:23:23,360 --> 00:23:28,879
but i won't go into detail of them here

701
00:23:26,799 --> 00:23:30,639
in terms of adversarial corruption

702
00:23:28,880 --> 00:23:31,600
threshold our synchronous protocol

703
00:23:30,640 --> 00:23:33,760
requires

704
00:23:31,600 --> 00:23:34,639
n greater than two f over two gamma

705
00:23:33,760 --> 00:23:37,120
minus one

706
00:23:34,640 --> 00:23:37,679
so in the easiest case of gamma equals

707
00:23:37,120 --> 00:23:40,399
one

708
00:23:37,679 --> 00:23:42,320
we still require an honest majority the

709
00:23:40,400 --> 00:23:43,039
asynchronous protocol will require n

710
00:23:42,320 --> 00:23:46,399
greater than

711
00:23:43,039 --> 00:23:49,200
four f over two gamma minus one

712
00:23:46,400 --> 00:23:50,000
i'll also briefly mention some caveats

713
00:23:49,200 --> 00:23:52,880
our protocol

714
00:23:50,000 --> 00:23:54,880
only achieves a weaker form of liveness

715
00:23:52,880 --> 00:23:57,600
which informally will require that new

716
00:23:54,880 --> 00:24:00,400
transactions are input sufficiently late

717
00:23:57,600 --> 00:24:01,600
in order to deliver current transactions

718
00:24:00,400 --> 00:24:02,960
but this should be reasonable in

719
00:24:01,600 --> 00:24:04,879
practice

720
00:24:02,960 --> 00:24:06,559
we also achieve conventional liveness

721
00:24:04,880 --> 00:24:08,720
when the external network has a small

722
00:24:06,559 --> 00:24:10,158
synchrony

723
00:24:08,720 --> 00:24:12,640
another point to note is that the

724
00:24:10,159 --> 00:24:14,720
adversary can always unfairly order

725
00:24:12,640 --> 00:24:16,480
if it controls the whole internet for

726
00:24:14,720 --> 00:24:18,880
example if it controls the client's

727
00:24:16,480 --> 00:24:21,600
access to all of the consensus nodes

728
00:24:18,880 --> 00:24:23,520
and in our modeling we sidestep this by

729
00:24:21,600 --> 00:24:26,399
assuming that the adversary does not

730
00:24:23,520 --> 00:24:29,039
control the external network

731
00:24:26,400 --> 00:24:30,880
a very cool byproduct of our protocol is

732
00:24:29,039 --> 00:24:32,000
that it serves as a fair ordering

733
00:24:30,880 --> 00:24:34,400
compiler

734
00:24:32,000 --> 00:24:35,840
so our protocols use fifo broadcast and

735
00:24:34,400 --> 00:24:38,000
agreement primitives

736
00:24:35,840 --> 00:24:39,918
which are sort of weak primitives in the

737
00:24:38,000 --> 00:24:42,640
sense that they can be realized

738
00:24:39,919 --> 00:24:43,840
from any consensus protocol so this

739
00:24:42,640 --> 00:24:46,640
results in a sort of

740
00:24:43,840 --> 00:24:47,918
interesting observation our iquitos

741
00:24:46,640 --> 00:24:50,480
technique provides a

742
00:24:47,919 --> 00:24:52,559
general compiler that can take any

743
00:24:50,480 --> 00:24:55,840
standard consensus protocol

744
00:24:52,559 --> 00:24:59,039
and transform it in a black box way into

745
00:24:55,840 --> 00:25:01,918
one that also provides order fairness

746
00:24:59,039 --> 00:25:03,039
just to give some final concluding

747
00:25:01,919 --> 00:25:06,240
thoughts

748
00:25:03,039 --> 00:25:07,919
our work is the first to formalize this

749
00:25:06,240 --> 00:25:11,120
order fairness notion

750
00:25:07,919 --> 00:25:12,880
and provide protocols to realize it and

751
00:25:11,120 --> 00:25:14,479
we think order fairness is an important

752
00:25:12,880 --> 00:25:16,240
property for many decentralized

753
00:25:14,480 --> 00:25:18,080
blockchain applications

754
00:25:16,240 --> 00:25:20,559
i mentioned decentralized exchanges

755
00:25:18,080 --> 00:25:22,879
earlier which is a 2.4 billion dollar

756
00:25:20,559 --> 00:25:24,720
market in 2019.

757
00:25:22,880 --> 00:25:27,279
another important use case is that of

758
00:25:24,720 --> 00:25:29,520
icos or initial coin offerings

759
00:25:27,279 --> 00:25:31,360
which could benefit from first and first

760
00:25:29,520 --> 00:25:34,400
out ordering for fair investing

761
00:25:31,360 --> 00:25:36,158
this is a 12 billion dollar market in

762
00:25:34,400 --> 00:25:38,320
general we think that decentralized

763
00:25:36,159 --> 00:25:40,840
finance or defy applications should also

764
00:25:38,320 --> 00:25:43,360
benefit from this notion of

765
00:25:40,840 --> 00:25:44,720
ordering so this concludes my

766
00:25:43,360 --> 00:25:46,399
presentation

767
00:25:44,720 --> 00:25:47,919
i've put my cornell email address as

768
00:25:46,400 --> 00:25:50,159
well as a link to the paper on this

769
00:25:47,919 --> 00:25:52,799
slide if you want to take a look

770
00:25:50,159 --> 00:25:57,840
uh thank you and i hope you have a great

771
00:25:52,799 --> 00:25:57,840
virtual crypto 2020 experience

