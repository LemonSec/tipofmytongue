1
00:00:00,880 --> 00:00:03,520
hi i'm karsten baum and i'm going to

2
00:00:02,879 --> 00:00:05,839
present

3
00:00:03,520 --> 00:00:07,040
our recent work on efficient constant

4
00:00:05,839 --> 00:00:08,880
ground mpc

5
00:00:07,040 --> 00:00:10,400
with identifiable abort and public

6
00:00:08,880 --> 00:00:12,799
verifiability

7
00:00:10,400 --> 00:00:13,599
this is joint work with emanuela orsini

8
00:00:12,799 --> 00:00:15,838
from karl

9
00:00:13,599 --> 00:00:18,000
levin and peter scholand eduardo sawyer

10
00:00:15,839 --> 00:00:20,080
vasquez from august university

11
00:00:18,000 --> 00:00:22,880
this paper has been accepted at crypto

12
00:00:20,080 --> 00:00:25,919
2020.

13
00:00:22,880 --> 00:00:28,000
let me begin by giving you a motivation

14
00:00:25,920 --> 00:00:31,199
and high level statement of the problem

15
00:00:28,000 --> 00:00:33,680
that we want to solve in our work

16
00:00:31,199 --> 00:00:34,480
consider the following example where we

17
00:00:33,680 --> 00:00:37,920
have

18
00:00:34,480 --> 00:00:39,839
four parties uh p1 to p4

19
00:00:37,920 --> 00:00:40,960
and the parties want to bid for a

20
00:00:39,840 --> 00:00:43,360
certain good

21
00:00:40,960 --> 00:00:44,079
party one in this example would bet

22
00:00:43,360 --> 00:00:46,399
three

23
00:00:44,079 --> 00:00:48,480
uh coins well party two would beat four

24
00:00:46,399 --> 00:00:51,440
coins and so on and so forth

25
00:00:48,480 --> 00:00:52,000
and these parties would in an ideal

26
00:00:51,440 --> 00:00:54,399
setting

27
00:00:52,000 --> 00:00:56,079
send their bids in a sealed envelope to

28
00:00:54,399 --> 00:00:58,719
an auctioneer

29
00:00:56,079 --> 00:00:59,199
and this auctioneer would compute a

30
00:00:58,719 --> 00:01:00,800
function

31
00:00:59,199 --> 00:01:02,719
on these bits by looking into the

32
00:01:00,800 --> 00:01:04,559
envelopes and checking uh how much each

33
00:01:02,719 --> 00:01:06,320
party bids and it would identify it in

34
00:01:04,559 --> 00:01:09,119
this case party two

35
00:01:06,320 --> 00:01:09,759
uh was having the highest bid with four

36
00:01:09,119 --> 00:01:12,960
coins

37
00:01:09,760 --> 00:01:13,600
and it would then announce to all

38
00:01:12,960 --> 00:01:17,280
parties

39
00:01:13,600 --> 00:01:20,640
that um party two has won this uh bid

40
00:01:17,280 --> 00:01:23,040
and that party two bid four coins

41
00:01:20,640 --> 00:01:25,040
in practice we want to eliminate this

42
00:01:23,040 --> 00:01:27,119
so-called trusted third party

43
00:01:25,040 --> 00:01:28,640
which is the auctioneer and replace the

44
00:01:27,119 --> 00:01:30,320
trusted third party by

45
00:01:28,640 --> 00:01:34,640
a secure multi-party computation

46
00:01:30,320 --> 00:01:37,758
protocol which simulates this ttp

47
00:01:34,640 --> 00:01:40,000
here the npc protocol would simulate the

48
00:01:37,759 --> 00:01:41,600
trusted third party as follows due to

49
00:01:40,000 --> 00:01:44,799
the correctness guarantee

50
00:01:41,600 --> 00:01:48,880
of the mpc protocol we would know that

51
00:01:44,799 --> 00:01:50,960
the simulated uh trusted third party

52
00:01:48,880 --> 00:01:52,640
would output the exact same value as the

53
00:01:50,960 --> 00:01:54,960
actual trusted third party

54
00:01:52,640 --> 00:01:56,960
and by the privacy of the mpc protocol

55
00:01:54,960 --> 00:02:00,479
would be guaranteed

56
00:01:56,960 --> 00:02:01,839
that only the highest bid would

57
00:02:00,479 --> 00:02:03,679
be announced in the end of the

58
00:02:01,840 --> 00:02:06,719
computation and that all

59
00:02:03,680 --> 00:02:10,640
other lower bids would remain

60
00:02:06,719 --> 00:02:13,760
invisible to a potential adversary

61
00:02:10,639 --> 00:02:16,238
the problem in this setting is uh

62
00:02:13,760 --> 00:02:17,280
that uh fairness in this setting is not

63
00:02:16,239 --> 00:02:19,680
guaranteed

64
00:02:17,280 --> 00:02:20,959
fairness is a property where we require

65
00:02:19,680 --> 00:02:22,800
that if the

66
00:02:20,959 --> 00:02:24,080
adversary gets the output of a secure

67
00:02:22,800 --> 00:02:27,040
computation

68
00:02:24,080 --> 00:02:27,440
then also the honest parties will get

69
00:02:27,040 --> 00:02:29,359
this

70
00:02:27,440 --> 00:02:32,239
output but due to an impossibility

71
00:02:29,360 --> 00:02:33,440
resolve by clay from 1986 we know that

72
00:02:32,239 --> 00:02:34,080
if we're in the distance majority

73
00:02:33,440 --> 00:02:37,280
setting

74
00:02:34,080 --> 00:02:40,160
we can't actually guarantee uh fairness

75
00:02:37,280 --> 00:02:40,879
and in this setting as we are here uh we

76
00:02:40,160 --> 00:02:44,160
would have

77
00:02:40,879 --> 00:02:46,239
no honest majority uh

78
00:02:44,160 --> 00:02:47,599
fairness is an important property in the

79
00:02:46,239 --> 00:02:50,959
setting because

80
00:02:47,599 --> 00:02:53,200
consider the following situation

81
00:02:50,959 --> 00:02:54,080
as the protocol is not fair we would run

82
00:02:53,200 --> 00:02:56,160
this auction

83
00:02:54,080 --> 00:02:57,840
and the adversary would learn that alice

84
00:02:56,160 --> 00:02:59,920
gave the highest bid

85
00:02:57,840 --> 00:03:02,000
and this was four coins and afterwards

86
00:02:59,920 --> 00:03:04,559
the protocol aborts

87
00:03:02,000 --> 00:03:05,519
now that means that since the honest

88
00:03:04,560 --> 00:03:07,840
parties don't know

89
00:03:05,519 --> 00:03:08,720
what happened the best uh they can do is

90
00:03:07,840 --> 00:03:10,400
re-run

91
00:03:08,720 --> 00:03:12,159
this auction but now the adversary has

92
00:03:10,400 --> 00:03:13,200
an advantage namely knowing that alice

93
00:03:12,159 --> 00:03:16,399
would bid

94
00:03:13,200 --> 00:03:17,518
uh four coins and this means that uh the

95
00:03:16,400 --> 00:03:22,640
adversary would

96
00:03:17,519 --> 00:03:26,000
be able to unfairly bias such an auction

97
00:03:22,640 --> 00:03:26,399
an alternative to using a fair protocol

98
00:03:26,000 --> 00:03:27,599
is

99
00:03:26,400 --> 00:03:29,840
what is called a protocol with

100
00:03:27,599 --> 00:03:32,480
identifiable abort

101
00:03:29,840 --> 00:03:33,280
let us compare unfair to identify with

102
00:03:32,480 --> 00:03:35,518
the board here

103
00:03:33,280 --> 00:03:37,040
so in an unfair protocol we would have

104
00:03:35,519 --> 00:03:38,879
that the adversary would

105
00:03:37,040 --> 00:03:40,239
always learn the output of the

106
00:03:38,879 --> 00:03:43,120
computation

107
00:03:40,239 --> 00:03:44,400
and either it allows the honest parties

108
00:03:43,120 --> 00:03:47,280
to also get this or

109
00:03:44,400 --> 00:03:49,440
it denies that the honest parties get

110
00:03:47,280 --> 00:03:51,360
the output

111
00:03:49,440 --> 00:03:52,799
now in a protocol with identifiable

112
00:03:51,360 --> 00:03:54,159
abort we would still be in the same

113
00:03:52,799 --> 00:03:56,080
situation that

114
00:03:54,159 --> 00:03:57,840
the adversary always learns the output

115
00:03:56,080 --> 00:04:00,720
of the computation

116
00:03:57,840 --> 00:04:02,560
but now either it lets the honest

117
00:04:00,720 --> 00:04:04,720
parties get the output as well

118
00:04:02,560 --> 00:04:05,760
or the honest parties at least learn the

119
00:04:04,720 --> 00:04:09,519
identity

120
00:04:05,760 --> 00:04:09,518
of one of the corrupted parties

121
00:04:09,760 --> 00:04:13,599
and we know that this is actually

122
00:04:11,680 --> 00:04:16,639
possible to achieve which existing

123
00:04:13,599 --> 00:04:19,039
with existing cryptography namely a

124
00:04:16,639 --> 00:04:21,120
tweak of the original gmw protocol

125
00:04:19,040 --> 00:04:23,440
already achieves this

126
00:04:21,120 --> 00:04:26,560
in particular using a compiler from

127
00:04:23,440 --> 00:04:29,040
ishayadol from 2014.

128
00:04:26,560 --> 00:04:29,840
our contributions are as follows we

129
00:04:29,040 --> 00:04:31,360
present

130
00:04:29,840 --> 00:04:32,880
an actively secure multi-party

131
00:04:31,360 --> 00:04:34,880
computation protocol

132
00:04:32,880 --> 00:04:36,560
that has this identifiable abort

133
00:04:34,880 --> 00:04:37,440
property and runs in a constant number

134
00:04:36,560 --> 00:04:39,840
of rounds

135
00:04:37,440 --> 00:04:41,680
our protocol is proven secure against

136
00:04:39,840 --> 00:04:43,520
any static adversary that controls a

137
00:04:41,680 --> 00:04:46,560
dishonest majority of parties

138
00:04:43,520 --> 00:04:47,599
but not all parties at the same time our

139
00:04:46,560 --> 00:04:49,840
protocol has

140
00:04:47,600 --> 00:04:52,639
a reasonable overhead over the best

141
00:04:49,840 --> 00:04:55,440
existing constant round npc protocols

142
00:04:52,639 --> 00:04:56,240
that do not have identifiable abort and

143
00:04:55,440 --> 00:04:58,960
in addition

144
00:04:56,240 --> 00:05:00,720
we show a transformation that also

145
00:04:58,960 --> 00:05:01,680
yields public verifiability of the

146
00:05:00,720 --> 00:05:04,400
output

147
00:05:01,680 --> 00:05:06,320
meaning that a third party could look at

148
00:05:04,400 --> 00:05:08,080
the transcript of the computation and

149
00:05:06,320 --> 00:05:09,360
either verify that the output was

150
00:05:08,080 --> 00:05:12,080
computed correctly

151
00:05:09,360 --> 00:05:13,440
or it could identify a cheater in the

152
00:05:12,080 --> 00:05:15,280
computation

153
00:05:13,440 --> 00:05:18,800
and this can be realized using for

154
00:05:15,280 --> 00:05:18,799
example a bulletin board

155
00:05:18,880 --> 00:05:22,159
let me mention some work that is related

156
00:05:20,639 --> 00:05:24,639
to ours

157
00:05:22,160 --> 00:05:26,160
we are not the first to consider npc

158
00:05:24,639 --> 00:05:29,520
with identifiable abort

159
00:05:26,160 --> 00:05:32,800
in 2014 ishayadal presented a

160
00:05:29,520 --> 00:05:34,080
gmw style compiler that allows to

161
00:05:32,800 --> 00:05:37,120
construct

162
00:05:34,080 --> 00:05:40,159
idmpc from oblivious

163
00:05:37,120 --> 00:05:42,080
preferred as adaptively secure and their

164
00:05:40,160 --> 00:05:43,840
compiler can also be applied to existing

165
00:05:42,080 --> 00:05:48,000
constant ground protocols

166
00:05:43,840 --> 00:05:51,440
and then yields a constant rod npc

167
00:05:48,000 --> 00:05:54,720
protocol that has identifiable board

168
00:05:51,440 --> 00:05:56,800
but in work by myself uh emmanuella and

169
00:05:54,720 --> 00:06:00,319
peter as well as

170
00:05:56,800 --> 00:06:01,120
spinney and fair as well as cunningham

171
00:06:00,319 --> 00:06:05,360
fuller

172
00:06:01,120 --> 00:06:07,600
and jacopov there were constructions of

173
00:06:05,360 --> 00:06:09,600
npc with the default abort from the so

174
00:06:07,600 --> 00:06:11,199
called speeds protocol

175
00:06:09,600 --> 00:06:12,800
the speeds protocol as such is not

176
00:06:11,199 --> 00:06:14,400
constant round so these protocols are

177
00:06:12,800 --> 00:06:17,680
not constant round

178
00:06:14,400 --> 00:06:20,080
and in 2015 kis ethal gave

179
00:06:17,680 --> 00:06:23,199
a construction that achieves a publicly

180
00:06:20,080 --> 00:06:25,440
verifiable npc with identifiable abort

181
00:06:23,199 --> 00:06:26,240
based on these x it will also show how

182
00:06:25,440 --> 00:06:28,080
we can

183
00:06:26,240 --> 00:06:31,280
compare to this construction and the ios

184
00:06:28,080 --> 00:06:31,280
at 14 a bit later

185
00:06:31,360 --> 00:06:40,000
and both the is14 and the kz15

186
00:06:36,639 --> 00:06:41,520
uh use zero knowledge in uh a very

187
00:06:40,000 --> 00:06:43,520
crucial way and

188
00:06:41,520 --> 00:06:45,280
uh these are generally uh rather

189
00:06:43,520 --> 00:06:46,840
inefficient protocols that one yields

190
00:06:45,280 --> 00:06:48,719
from that so these are more feasibility

191
00:06:46,840 --> 00:06:52,560
results

192
00:06:48,720 --> 00:06:55,680
in some recent work with david dausley

193
00:06:52,560 --> 00:06:58,319
nielsen and axner

194
00:06:55,680 --> 00:06:58,800
we additionally show that one can also

195
00:06:58,319 --> 00:07:01,919
obtain

196
00:06:58,800 --> 00:07:03,919
mpc with output independent abort this

197
00:07:01,919 --> 00:07:06,318
is like npc with identifiable board but

198
00:07:03,919 --> 00:07:09,758
there the adversary has to decide

199
00:07:06,319 --> 00:07:10,560
on whether he wants to reveal the output

200
00:07:09,759 --> 00:07:13,360
or not

201
00:07:10,560 --> 00:07:14,400
to the honest parties before actually

202
00:07:13,360 --> 00:07:16,319
seeing the output

203
00:07:14,400 --> 00:07:17,440
whereas in our case the adversary can

204
00:07:16,319 --> 00:07:20,479
see the output first

205
00:07:17,440 --> 00:07:23,440
and then make a decision

206
00:07:20,479 --> 00:07:24,318
first let me recap how the compiler by

207
00:07:23,440 --> 00:07:26,560
ishaya dal

208
00:07:24,319 --> 00:07:30,319
actually works in their construction

209
00:07:26,560 --> 00:07:32,720
they take an arbitrary mpc protocol and

210
00:07:30,319 --> 00:07:33,840
add a pre-processing phase to it and

211
00:07:32,720 --> 00:07:35,680
this pre-processing

212
00:07:33,840 --> 00:07:37,919
is then used to make the overall

213
00:07:35,680 --> 00:07:39,120
construction secure with the nd5

214
00:07:37,919 --> 00:07:41,280
motherboard

215
00:07:39,120 --> 00:07:42,880
this pre-processing works as follows

216
00:07:41,280 --> 00:07:44,559
first

217
00:07:42,880 --> 00:07:46,000
this pre-processing is independent of

218
00:07:44,560 --> 00:07:47,440
the actual inputs

219
00:07:46,000 --> 00:07:49,039
uh that the participant are going to

220
00:07:47,440 --> 00:07:51,680
provide to the mpc protocol

221
00:07:49,039 --> 00:07:52,080
so the observation of which it all is

222
00:07:51,680 --> 00:07:55,599
that

223
00:07:52,080 --> 00:07:58,560
this protocol can fully be revealed

224
00:07:55,599 --> 00:08:00,159
in case there are any errors so the

225
00:07:58,560 --> 00:08:02,080
speed processing then works as follows

226
00:08:00,160 --> 00:08:03,520
the parties first commit to a random

227
00:08:02,080 --> 00:08:06,318
tape

228
00:08:03,520 --> 00:08:08,318
then they generate correlated randomness

229
00:08:06,319 --> 00:08:12,080
which in this case means that they

230
00:08:08,319 --> 00:08:14,319
pre-process zero knowledge proofs

231
00:08:12,080 --> 00:08:15,919
then since all the communication runs

232
00:08:14,319 --> 00:08:18,080
through a broadcast channel

233
00:08:15,919 --> 00:08:20,799
parties always know if another party

234
00:08:18,080 --> 00:08:23,039
sends protocol messages or not

235
00:08:20,800 --> 00:08:25,199
and then if there is any problem in

236
00:08:23,039 --> 00:08:28,240
generating this correlated randomness

237
00:08:25,199 --> 00:08:29,840
during the pre-processing then the

238
00:08:28,240 --> 00:08:31,520
parties just open

239
00:08:29,840 --> 00:08:33,519
these commitments that they made to

240
00:08:31,520 --> 00:08:34,958
their random tapes

241
00:08:33,519 --> 00:08:37,519
this doesn't reveal any information

242
00:08:34,958 --> 00:08:39,119
about the online phase about the actual

243
00:08:37,519 --> 00:08:41,120
inputs because this is just

244
00:08:39,120 --> 00:08:42,240
random values and then they compare

245
00:08:41,120 --> 00:08:45,920
these transcripts

246
00:08:42,240 --> 00:08:49,120
uh together the transcript that was uh

247
00:08:45,920 --> 00:08:50,560
made by all parties with the randomness

248
00:08:49,120 --> 00:08:53,040
that they committed to

249
00:08:50,560 --> 00:08:54,479
and if everything is consistent then

250
00:08:53,040 --> 00:08:55,920
they punish the party that complained

251
00:08:54,480 --> 00:08:57,440
otherwise they identified the cheater

252
00:08:55,920 --> 00:08:59,120
this way

253
00:08:57,440 --> 00:09:01,600
and then in the online phase they run

254
00:08:59,120 --> 00:09:03,760
the actual mpc protocol

255
00:09:01,600 --> 00:09:06,160
and prove in each step in zero knowledge

256
00:09:03,760 --> 00:09:07,360
that the messages are well formed this

257
00:09:06,160 --> 00:09:09,519
then also allows

258
00:09:07,360 --> 00:09:11,680
identifiable abort by simply verifying

259
00:09:09,519 --> 00:09:15,279
the zero-knowledge proofs

260
00:09:11,680 --> 00:09:17,120
one natural idea in order to obtain

261
00:09:15,279 --> 00:09:18,640
mpc with identifiable aborting a

262
00:09:17,120 --> 00:09:19,440
constant number of rounds would be to

263
00:09:18,640 --> 00:09:21,519
compile

264
00:09:19,440 --> 00:09:23,680
a constant run protocols and these are

265
00:09:21,519 --> 00:09:25,760
generally based on the so-called bmr

266
00:09:23,680 --> 00:09:27,359
paradigm which uses goblet circuits so

267
00:09:25,760 --> 00:09:29,600
let me just quickly recap

268
00:09:27,360 --> 00:09:31,040
goblet circuits for passively secure

269
00:09:29,600 --> 00:09:33,760
two-party computation this is

270
00:09:31,040 --> 00:09:34,640
due to yao and here we have two parties

271
00:09:33,760 --> 00:09:38,240
a gobbler

272
00:09:34,640 --> 00:09:38,560
and an evaluator that gobbler would take

273
00:09:38,240 --> 00:09:40,160
the

274
00:09:38,560 --> 00:09:41,839
circuit that is supposed to be computed

275
00:09:40,160 --> 00:09:44,079
securely let's call it c

276
00:09:41,839 --> 00:09:45,040
and would gobble it and make it

277
00:09:44,080 --> 00:09:48,080
unintelligible

278
00:09:45,040 --> 00:09:50,480
this is called z prime then

279
00:09:48,080 --> 00:09:52,800
the gobbler would send this circuit to

280
00:09:50,480 --> 00:09:54,880
the evaluator

281
00:09:52,800 --> 00:09:57,279
and afterwards um the parties are going

282
00:09:54,880 --> 00:09:59,680
to run an input encoding step

283
00:09:57,279 --> 00:10:00,720
where party one outputs in its input

284
00:09:59,680 --> 00:10:04,079
party two outputs

285
00:10:00,720 --> 00:10:06,560
inputs its own input and the output

286
00:10:04,079 --> 00:10:07,760
is an encoding of each party's input

287
00:10:06,560 --> 00:10:11,279
which is both then sent

288
00:10:07,760 --> 00:10:14,480
to party 2 the evaluator

289
00:10:11,279 --> 00:10:15,839
and the evaluator then uses the

290
00:10:14,480 --> 00:10:17,600
evaluation algorithm

291
00:10:15,839 --> 00:10:19,200
to compute the output of the actual

292
00:10:17,600 --> 00:10:21,920
computation

293
00:10:19,200 --> 00:10:23,440
and here the important point is that

294
00:10:21,920 --> 00:10:25,360
this

295
00:10:23,440 --> 00:10:27,360
gobbled circuit together with the input

296
00:10:25,360 --> 00:10:29,760
encodings only reveals the output and no

297
00:10:27,360 --> 00:10:32,959
other information

298
00:10:29,760 --> 00:10:34,880
and then in order to have to also

299
00:10:32,959 --> 00:10:37,119
provide alice with the output

300
00:10:34,880 --> 00:10:39,680
the evaluator would then send the output

301
00:10:37,120 --> 00:10:42,560
to alice

302
00:10:39,680 --> 00:10:44,399
in a multi-party setting we could do

303
00:10:42,560 --> 00:10:47,518
something similar

304
00:10:44,399 --> 00:10:49,680
using the following approach first we

305
00:10:47,519 --> 00:10:52,399
use a generic mpc protocol

306
00:10:49,680 --> 00:10:54,560
which performs both the garbling step

307
00:10:52,399 --> 00:10:56,640
inside the mpc

308
00:10:54,560 --> 00:10:58,079
this garbling step with an output the

309
00:10:56,640 --> 00:11:00,959
gobbled circuit

310
00:10:58,079 --> 00:11:01,839
but maybe plus some additional error on

311
00:11:00,959 --> 00:11:03,920
top

312
00:11:01,839 --> 00:11:06,079
and then the parties would also use the

313
00:11:03,920 --> 00:11:08,560
mpc protocol in order to compute

314
00:11:06,079 --> 00:11:09,599
the input encoding step now since both

315
00:11:08,560 --> 00:11:11,839
the input encoding

316
00:11:09,600 --> 00:11:13,680
and the actual garbling are of constant

317
00:11:11,839 --> 00:11:15,279
depth this gives a constant round

318
00:11:13,680 --> 00:11:17,599
protocol if implemented with any

319
00:11:15,279 --> 00:11:19,600
arbitrary npc protocol

320
00:11:17,600 --> 00:11:20,640
and the parties can then each locally

321
00:11:19,600 --> 00:11:24,399
use this

322
00:11:20,640 --> 00:11:27,439
evaluation to evaluate

323
00:11:24,399 --> 00:11:29,040
the circuit on the encoded input this

324
00:11:27,440 --> 00:11:31,040
can always be done locally

325
00:11:29,040 --> 00:11:32,959
and in case there is no error we would

326
00:11:31,040 --> 00:11:34,800
get the guarantee from the

327
00:11:32,959 --> 00:11:36,319
multi-party goblet circuits protocol

328
00:11:34,800 --> 00:11:37,519
that the correct output would be

329
00:11:36,320 --> 00:11:40,640
revealed

330
00:11:37,519 --> 00:11:42,240
and otherwise an abort would happen in

331
00:11:40,640 --> 00:11:43,519
our case we obviously want that instead

332
00:11:42,240 --> 00:11:46,720
of an abort happening

333
00:11:43,519 --> 00:11:48,320
a a dishonest party will be uh revealed

334
00:11:46,720 --> 00:11:51,040
in this step

335
00:11:48,320 --> 00:11:53,279
one could obviously try to directly

336
00:11:51,040 --> 00:11:55,120
compile a constant run protocol with ios

337
00:11:53,279 --> 00:11:57,760
14 as mentioned before

338
00:11:55,120 --> 00:11:59,360
so uh let's take as an example the

339
00:11:57,760 --> 00:12:02,240
protocol by hazai shal

340
00:11:59,360 --> 00:12:02,880
and soriya vasquez which we is which is

341
00:12:02,240 --> 00:12:04,880
also the

342
00:12:02,880 --> 00:12:06,720
core of our construction and let's

343
00:12:04,880 --> 00:12:08,000
compile it with this compiler by

344
00:12:06,720 --> 00:12:10,160
ishaital what

345
00:12:08,000 --> 00:12:12,880
actually is a disadvantage of this

346
00:12:10,160 --> 00:12:15,360
approach so the first point is that's

347
00:12:12,880 --> 00:12:16,720
the protocol by hazai it already has a

348
00:12:15,360 --> 00:12:19,200
pre-processing stop

349
00:12:16,720 --> 00:12:20,000
step which is independent of the actual

350
00:12:19,200 --> 00:12:22,079
input

351
00:12:20,000 --> 00:12:23,360
so it doesn't make sense to have another

352
00:12:22,079 --> 00:12:24,000
round of pre-processing before this

353
00:12:23,360 --> 00:12:26,480
which is also

354
00:12:24,000 --> 00:12:28,079
input independent so one would like to

355
00:12:26,480 --> 00:12:31,519
merge these two

356
00:12:28,079 --> 00:12:35,199
processes together

357
00:12:31,519 --> 00:12:38,240
also garbling something means that

358
00:12:35,200 --> 00:12:41,600
prfs need to be evaluated and this

359
00:12:38,240 --> 00:12:43,839
is not just inefficient if done

360
00:12:41,600 --> 00:12:45,440
inside multi-party computation but it

361
00:12:43,839 --> 00:12:47,040
would also be inefficient to prove and

362
00:12:45,440 --> 00:12:49,839
zero knowledge that

363
00:12:47,040 --> 00:12:52,319
one evaluated the prf correctly so we

364
00:12:49,839 --> 00:12:56,480
would like to avoid this

365
00:12:52,320 --> 00:12:59,440
so if we would directly uh garble using

366
00:12:56,480 --> 00:13:00,880
hss 17 and then throw the ios at

367
00:12:59,440 --> 00:13:03,200
compiler on top

368
00:13:00,880 --> 00:13:04,320
we would obtain a protocol that would

369
00:13:03,200 --> 00:13:07,200
need

370
00:13:04,320 --> 00:13:09,600
n squared zero knowledge proofs for each

371
00:13:07,200 --> 00:13:12,480
gate that is garbled

372
00:13:09,600 --> 00:13:14,480
where n is the number of parties whereas

373
00:13:12,480 --> 00:13:16,480
in our constructions we will not need

374
00:13:14,480 --> 00:13:17,519
any zero knowledge proofs whatsoever in

375
00:13:16,480 --> 00:13:21,200
order to

376
00:13:17,519 --> 00:13:21,519
gobble the circuit let me now explain to

377
00:13:21,200 --> 00:13:25,040
you

378
00:13:21,519 --> 00:13:28,800
how we solve this problem based on

379
00:13:25,040 --> 00:13:32,160
the protocol by hazard al first let me

380
00:13:28,800 --> 00:13:33,839
recap how to carbon engage which is the

381
00:13:32,160 --> 00:13:34,639
core of the goblet circuits approach

382
00:13:33,839 --> 00:13:37,440
there

383
00:13:34,639 --> 00:13:39,199
instead of having the inputs and outputs

384
00:13:37,440 --> 00:13:42,399
of the gate in plane

385
00:13:39,199 --> 00:13:44,479
we would replace the input bits of the

386
00:13:42,399 --> 00:13:47,440
input wires u and v

387
00:13:44,480 --> 00:13:48,160
with bit strings and we would do the

388
00:13:47,440 --> 00:13:52,160
same with

389
00:13:48,160 --> 00:13:56,079
the outputs that means the

390
00:13:52,160 --> 00:13:57,040
zero on the wire u would be replaced by

391
00:13:56,079 --> 00:14:00,638
a bit string

392
00:13:57,040 --> 00:14:04,079
a random bit string which we call k u0

393
00:14:00,639 --> 00:14:06,160
and the same for the 1 on the u

394
00:14:04,079 --> 00:14:07,439
wire and the same for v and w

395
00:14:06,160 --> 00:14:10,800
respectively

396
00:14:07,440 --> 00:14:15,680
then one would encrypt

397
00:14:10,800 --> 00:14:18,800
the outputs of respective bit values

398
00:14:15,680 --> 00:14:23,199
under the input keys meaning

399
00:14:18,800 --> 00:14:25,680
we would encrypt the zero

400
00:14:23,199 --> 00:14:28,000
string on w meaning we encrypt the

401
00:14:25,680 --> 00:14:30,638
output of the gate being zero

402
00:14:28,000 --> 00:14:31,600
under inputs being 0 or either of the

403
00:14:30,639 --> 00:14:34,240
inputs

404
00:14:31,600 --> 00:14:35,839
being 0 and the other one being 1 and we

405
00:14:34,240 --> 00:14:39,440
would encrypt the

406
00:14:35,839 --> 00:14:43,120
output 1 under the input keys that

407
00:14:39,440 --> 00:14:46,480
corresponds to both inputs being 1.

408
00:14:43,120 --> 00:14:49,839
then uh after this encryption process

409
00:14:46,480 --> 00:14:52,639
uh one would shuffle uh the table

410
00:14:49,839 --> 00:14:53,040
so that's uh during the evaluation one

411
00:14:52,639 --> 00:14:56,880
uh

412
00:14:53,040 --> 00:14:59,920
cannot find out uh which uh

413
00:14:56,880 --> 00:15:00,480
the which is actually the current truth

414
00:14:59,920 --> 00:15:04,880
value

415
00:15:00,480 --> 00:15:06,639
when uh decrypting this uh encryptions

416
00:15:04,880 --> 00:15:08,639
in the setting where we have more than

417
00:15:06,639 --> 00:15:10,079
two parties let's say end parties

418
00:15:08,639 --> 00:15:12,800
this goblin actually works a bit

419
00:15:10,079 --> 00:15:15,279
different in the example here we

420
00:15:12,800 --> 00:15:18,639
consider the hss goblin

421
00:15:15,279 --> 00:15:20,720
here instead of a key for each

422
00:15:18,639 --> 00:15:23,760
of the zero and one values per wire we

423
00:15:20,720 --> 00:15:25,519
would have a vector of keys

424
00:15:23,760 --> 00:15:26,800
that would be the input and the outputs

425
00:15:25,519 --> 00:15:29,519
respectively

426
00:15:26,800 --> 00:15:31,758
meaning that instead of having a let's

427
00:15:29,519 --> 00:15:35,759
say 128-bit key

428
00:15:31,759 --> 00:15:39,120
we would have a 128-bit key

429
00:15:35,759 --> 00:15:43,040
for each of the end parties and these

430
00:15:39,120 --> 00:15:46,320
uh n 128-bit keys would then make up

431
00:15:43,040 --> 00:15:49,360
uh the whole output key of the actual

432
00:15:46,320 --> 00:15:51,759
goblet gate and

433
00:15:49,360 --> 00:15:53,440
each party uh in this setting actually

434
00:15:51,759 --> 00:15:55,440
provides

435
00:15:53,440 --> 00:15:57,360
one part of the keys meaning that party

436
00:15:55,440 --> 00:16:00,399
one provides the first block

437
00:15:57,360 --> 00:16:02,800
of this party two provides a second

438
00:16:00,399 --> 00:16:04,480
block and so on and so forth

439
00:16:02,800 --> 00:16:05,839
and then each of the encryptions

440
00:16:04,480 --> 00:16:10,240
actually consists

441
00:16:05,839 --> 00:16:13,279
of an encryption of each of the outputs

442
00:16:10,240 --> 00:16:16,480
each of the output blocks under

443
00:16:13,279 --> 00:16:19,680
all the different input keys

444
00:16:16,480 --> 00:16:21,680
for this respective truth value

445
00:16:19,680 --> 00:16:24,000
now creating all of these encryptions

446
00:16:21,680 --> 00:16:26,160
creating all of this garbling

447
00:16:24,000 --> 00:16:28,000
is actually happening during a

448
00:16:26,160 --> 00:16:30,000
pre-processing phase and is independent

449
00:16:28,000 --> 00:16:32,639
of the actual inputs

450
00:16:30,000 --> 00:16:33,360
and during the evaluation what happens

451
00:16:32,639 --> 00:16:37,040
is that

452
00:16:33,360 --> 00:16:39,279
parties have actual keys with

453
00:16:37,040 --> 00:16:40,800
some respective truth values for example

454
00:16:39,279 --> 00:16:43,839
they have

455
00:16:40,800 --> 00:16:46,319
the 1k for u

456
00:16:43,839 --> 00:16:47,120
and the one key for v and now they want

457
00:16:46,320 --> 00:16:49,920
to

458
00:16:47,120 --> 00:16:50,880
obtain the output of the group gate so

459
00:16:49,920 --> 00:16:54,800
what the parties do

460
00:16:50,880 --> 00:16:58,399
is they then decrypt the output key

461
00:16:54,800 --> 00:17:01,439
and use this then as input to

462
00:16:58,399 --> 00:17:04,079
for example the next end gate now there

463
00:17:01,440 --> 00:17:07,360
are two possible output keys that

464
00:17:04,079 --> 00:17:08,399
could result from this decryption

465
00:17:07,359 --> 00:17:11,119
process

466
00:17:08,400 --> 00:17:13,919
the 0 key which is the key that

467
00:17:11,119 --> 00:17:18,079
corresponds to the truth value 0 or

468
00:17:13,919 --> 00:17:21,120
the 1 key and during the evaluation

469
00:17:18,079 --> 00:17:24,918
as said uh the parties decrypt

470
00:17:21,119 --> 00:17:28,319
the respective key in this case this is

471
00:17:24,919 --> 00:17:32,160
kw1 i'm using the

472
00:17:28,319 --> 00:17:35,200
two input keys that they have

473
00:17:32,160 --> 00:17:37,280
and then they need to check if this is

474
00:17:35,200 --> 00:17:39,310
actually a correct output key

475
00:17:37,280 --> 00:17:40,639
so they need to check that

476
00:17:39,310 --> 00:17:42,399
[Music]

477
00:17:40,640 --> 00:17:45,120
nobody cheated during the garbling

478
00:17:42,400 --> 00:17:48,480
process uh if you remember the goblin

479
00:17:45,120 --> 00:17:50,239
might add some error e to

480
00:17:48,480 --> 00:17:53,280
the the whole garbling step because it

481
00:17:50,240 --> 00:17:55,679
happens in multiparty

482
00:17:53,280 --> 00:17:57,200
so the parties then in order to

483
00:17:55,679 --> 00:18:00,320
establish correctness

484
00:17:57,200 --> 00:18:02,640
check if the block of the

485
00:18:00,320 --> 00:18:03,520
of the key that they provided uh

486
00:18:02,640 --> 00:18:07,200
contains

487
00:18:03,520 --> 00:18:09,760
uh their uh respective zero or one key

488
00:18:07,200 --> 00:18:12,160
so as mentioned before in the garbling

489
00:18:09,760 --> 00:18:15,200
um each party actually provides

490
00:18:12,160 --> 00:18:16,960
a block of each key party one

491
00:18:15,200 --> 00:18:18,799
provides the first one so many bits

492
00:18:16,960 --> 00:18:20,799
party two the second

493
00:18:18,799 --> 00:18:22,080
so during the evaluation each party

494
00:18:20,799 --> 00:18:26,240
simply checks

495
00:18:22,080 --> 00:18:28,320
if in the decrypted key that they obtain

496
00:18:26,240 --> 00:18:31,440
the party one for example checks if the

497
00:18:28,320 --> 00:18:33,918
first 128 bits of the key corresponds

498
00:18:31,440 --> 00:18:34,559
to either the zero or the one key that

499
00:18:33,919 --> 00:18:37,760
it's uh

500
00:18:34,559 --> 00:18:39,840
provided as part of of this

501
00:18:37,760 --> 00:18:41,039
and if not then uh the parties noted

502
00:18:39,840 --> 00:18:44,159
some cheating happened

503
00:18:41,039 --> 00:18:47,360
and in the usual hss

504
00:18:44,160 --> 00:18:50,240
evaluations the parties would then abort

505
00:18:47,360 --> 00:18:50,639
in order to obtain identifiable abort in

506
00:18:50,240 --> 00:18:53,200
this

507
00:18:50,640 --> 00:18:55,200
we make the following observation first

508
00:18:53,200 --> 00:18:58,640
during the gardening step

509
00:18:55,200 --> 00:18:59,760
the party each party first generates an

510
00:18:58,640 --> 00:19:04,240
additive share

511
00:18:59,760 --> 00:19:06,879
of the full encryption of the output key

512
00:19:04,240 --> 00:19:07,360
in each row under the different input

513
00:19:06,880 --> 00:19:11,039
keys

514
00:19:07,360 --> 00:19:14,320
so here each party has an additive share

515
00:19:11,039 --> 00:19:17,840
of the output key

516
00:19:14,320 --> 00:19:20,000
and it has shares of the individual

517
00:19:17,840 --> 00:19:20,959
input keys and it then generates from

518
00:19:20,000 --> 00:19:23,440
this a share

519
00:19:20,960 --> 00:19:24,799
of the encryption and afterwards each

520
00:19:23,440 --> 00:19:27,840
party broadcasts

521
00:19:24,799 --> 00:19:30,559
this share of the encryption

522
00:19:27,840 --> 00:19:31,439
in the evaluation after summing up all

523
00:19:30,559 --> 00:19:34,559
the shares

524
00:19:31,440 --> 00:19:36,799
what a party does uh is to

525
00:19:34,559 --> 00:19:38,399
decrypt the output key in their

526
00:19:36,799 --> 00:19:41,360
respective row

527
00:19:38,400 --> 00:19:43,039
by applying the two input keys that it

528
00:19:41,360 --> 00:19:47,280
has

529
00:19:43,039 --> 00:19:50,960
now um we observed that

530
00:19:47,280 --> 00:19:52,080
this broadcast step actually reveals the

531
00:19:50,960 --> 00:19:55,919
shares

532
00:19:52,080 --> 00:19:57,918
already and that this does not hurt

533
00:19:55,919 --> 00:19:59,120
the security of the overall protocol

534
00:19:57,919 --> 00:20:01,280
namely

535
00:19:59,120 --> 00:20:03,439
let's say that the party is detected at

536
00:20:01,280 --> 00:20:05,918
a certain gate

537
00:20:03,440 --> 00:20:07,360
in a certain row the decryption doesn't

538
00:20:05,919 --> 00:20:10,640
work correctly

539
00:20:07,360 --> 00:20:13,439
now if the parties would broadcast

540
00:20:10,640 --> 00:20:14,000
the u and the v value that they used in

541
00:20:13,440 --> 00:20:15,840
order to

542
00:20:14,000 --> 00:20:17,039
generate the encryption then this

543
00:20:15,840 --> 00:20:18,480
doesn't hurt because during the

544
00:20:17,039 --> 00:20:21,440
evaluation

545
00:20:18,480 --> 00:20:22,880
each party already holds these as part

546
00:20:21,440 --> 00:20:26,320
of their decryption

547
00:20:22,880 --> 00:20:27,120
uh keys that they apply so this does not

548
00:20:26,320 --> 00:20:29,280
uh

549
00:20:27,120 --> 00:20:32,239
this doesn't pose any security issues

550
00:20:29,280 --> 00:20:34,799
and the same applies to the share of

551
00:20:32,240 --> 00:20:36,480
of the output vector that one would

552
00:20:34,799 --> 00:20:37,039
obtain because the adversary already

553
00:20:36,480 --> 00:20:39,039
knows

554
00:20:37,039 --> 00:20:40,480
the correct output that it would get in

555
00:20:39,039 --> 00:20:43,520
this setting

556
00:20:40,480 --> 00:20:44,960
so actually whenever we obtain whenever

557
00:20:43,520 --> 00:20:47,360
we would see an error

558
00:20:44,960 --> 00:20:49,520
in a specific row all we have to do is

559
00:20:47,360 --> 00:20:51,760
to recompute this garbling step in

560
00:20:49,520 --> 00:20:53,840
public

561
00:20:51,760 --> 00:20:55,919
in order to be able to do this public

562
00:20:53,840 --> 00:20:58,879
reconstruction

563
00:20:55,919 --> 00:21:00,240
we have to have the parties commit to

564
00:20:58,880 --> 00:21:02,960
their shares

565
00:21:00,240 --> 00:21:03,919
and then open these commitments uh

566
00:21:02,960 --> 00:21:06,799
before

567
00:21:03,919 --> 00:21:08,240
we do this uh re-gobbling in public this

568
00:21:06,799 --> 00:21:10,080
is because the parties could lie about

569
00:21:08,240 --> 00:21:10,640
the shares that they used in order to

570
00:21:10,080 --> 00:21:12,960
gobble

571
00:21:10,640 --> 00:21:14,480
their respective gates so that means

572
00:21:12,960 --> 00:21:16,480
that during the pre-processing we will

573
00:21:14,480 --> 00:21:18,320
have to the parties have to commit

574
00:21:16,480 --> 00:21:20,000
to the shares that they used in the

575
00:21:18,320 --> 00:21:22,639
pre-processing step

576
00:21:20,000 --> 00:21:25,360
then during the evaluation we identify

577
00:21:22,640 --> 00:21:28,480
the smallest gate where an error occurs

578
00:21:25,360 --> 00:21:31,439
then the parties decommit the shares

579
00:21:28,480 --> 00:21:32,240
that they used uh in order to gobble the

580
00:21:31,440 --> 00:21:35,280
specific

581
00:21:32,240 --> 00:21:37,520
uh row that uh was decrypted

582
00:21:35,280 --> 00:21:38,960
and then uh during the recomputation

583
00:21:37,520 --> 00:21:41,760
they find out

584
00:21:38,960 --> 00:21:42,240
uh where an error occurred or if error

585
00:21:41,760 --> 00:21:44,640
occurred

586
00:21:42,240 --> 00:21:46,480
at all and this is then used in order to

587
00:21:44,640 --> 00:21:48,320
identify the cheater

588
00:21:46,480 --> 00:21:49,840
for this to work we obviously need

589
00:21:48,320 --> 00:21:51,840
commitments from the pre-processing

590
00:21:49,840 --> 00:21:54,320
phase to the individual shares

591
00:21:51,840 --> 00:21:56,000
so we have to modify the hss

592
00:21:54,320 --> 00:21:59,280
pre-processing as follows

593
00:21:56,000 --> 00:22:01,280
first of all uh similar to the

594
00:21:59,280 --> 00:22:03,520
ios compiler we will let every party

595
00:22:01,280 --> 00:22:05,039
commit to their random tape

596
00:22:03,520 --> 00:22:07,520
next we will run the pre-processing

597
00:22:05,039 --> 00:22:10,640
protocol of hss

598
00:22:07,520 --> 00:22:12,080
and we will generate commitments to the

599
00:22:10,640 --> 00:22:15,200
individual keys

600
00:22:12,080 --> 00:22:16,559
using a broadcast channel next we will

601
00:22:15,200 --> 00:22:19,520
check the consistency

602
00:22:16,559 --> 00:22:21,200
of the values that were obtained and of

603
00:22:19,520 --> 00:22:23,120
the committed values

604
00:22:21,200 --> 00:22:25,200
and then in case of an inconsistency we

605
00:22:23,120 --> 00:22:26,559
can actually open the commitment to the

606
00:22:25,200 --> 00:22:28,799
random tapes

607
00:22:26,559 --> 00:22:30,240
that were made by every party and

608
00:22:28,799 --> 00:22:31,918
similar to

609
00:22:30,240 --> 00:22:33,600
the protocol by ishayan i'll simply

610
00:22:31,919 --> 00:22:34,240
compare with all the messages that were

611
00:22:33,600 --> 00:22:35,918
sent

612
00:22:34,240 --> 00:22:38,720
again since this is the pre-processing

613
00:22:35,919 --> 00:22:41,039
step and no inputs no actual inputs

614
00:22:38,720 --> 00:22:42,720
of any party were used at this step this

615
00:22:41,039 --> 00:22:45,760
will not

616
00:22:42,720 --> 00:22:46,240
break the security now this approach

617
00:22:45,760 --> 00:22:49,280
might

618
00:22:46,240 --> 00:22:50,799
be intuitively secure but when one wants

619
00:22:49,280 --> 00:22:53,600
to prove this

620
00:22:50,799 --> 00:22:55,200
secure based on a simulation-based proof

621
00:22:53,600 --> 00:22:57,678
this is actually not trivial

622
00:22:55,200 --> 00:22:59,360
the problem being that the simulator

623
00:22:57,679 --> 00:23:00,080
itself obviously does not know the

624
00:22:59,360 --> 00:23:02,879
shares of

625
00:23:00,080 --> 00:23:04,799
the honest parties so these shares are

626
00:23:02,880 --> 00:23:07,919
hidden by the ideal functionality

627
00:23:04,799 --> 00:23:09,520
but once we open all the messages that

628
00:23:07,919 --> 00:23:12,240
are sent in case of in

629
00:23:09,520 --> 00:23:14,158
case of an abort these shares will be

630
00:23:12,240 --> 00:23:16,880
revealed by the ideal functionality

631
00:23:14,159 --> 00:23:19,120
and then the protocol generated is

632
00:23:16,880 --> 00:23:21,600
inconsistent

633
00:23:19,120 --> 00:23:23,918
so in case of an abort there will be an

634
00:23:21,600 --> 00:23:25,918
inconsistency between the simulation

635
00:23:23,919 --> 00:23:27,360
and an actual protocol and this is a

636
00:23:25,919 --> 00:23:30,320
problem

637
00:23:27,360 --> 00:23:31,678
now uh ishayat i'll solve this by using

638
00:23:30,320 --> 00:23:33,200
an adaptively secure

639
00:23:31,679 --> 00:23:34,400
protocol in order to generate the

640
00:23:33,200 --> 00:23:37,039
pre-processing this is where the

641
00:23:34,400 --> 00:23:40,240
adaptively secure ot comes from

642
00:23:37,039 --> 00:23:43,279
in our case we circumvent this problem

643
00:23:40,240 --> 00:23:45,279
by simply defining the problem away our

644
00:23:43,279 --> 00:23:47,520
solution is to define the pre-processing

645
00:23:45,279 --> 00:23:50,159
functionality as follows

646
00:23:47,520 --> 00:23:52,000
we say that either the protocol was

647
00:23:50,159 --> 00:23:54,320
executed correctly in such a case an

648
00:23:52,000 --> 00:23:56,720
adversary may not abort anymore

649
00:23:54,320 --> 00:23:57,520
it cannot afford any more in practice

650
00:23:56,720 --> 00:23:59,919
actually

651
00:23:57,520 --> 00:24:00,720
so in this case the honest parties

652
00:23:59,919 --> 00:24:03,360
obtain

653
00:24:00,720 --> 00:24:03,840
the shares from the ideal functionality

654
00:24:03,360 --> 00:24:06,000
whereas

655
00:24:03,840 --> 00:24:07,199
in case of an abort the shares were

656
00:24:06,000 --> 00:24:10,799
never sent to

657
00:24:07,200 --> 00:24:13,039
the honest parties and that means that

658
00:24:10,799 --> 00:24:14,879
there is no way of comparing with the

659
00:24:13,039 --> 00:24:15,919
values that were sampled in the ideal

660
00:24:14,880 --> 00:24:17,679
functionality

661
00:24:15,919 --> 00:24:20,000
and there is no need to use an

662
00:24:17,679 --> 00:24:21,919
adaptively secure protocol

663
00:24:20,000 --> 00:24:23,120
now an alternative to this was uh

664
00:24:21,919 --> 00:24:25,279
recently proposed

665
00:24:23,120 --> 00:24:26,158
in another work of myself david and

666
00:24:25,279 --> 00:24:28,159
dousley

667
00:24:26,159 --> 00:24:29,840
where we define a so-called uber

668
00:24:28,159 --> 00:24:33,520
simulation which

669
00:24:29,840 --> 00:24:37,439
allows to obser obtain this uc

670
00:24:33,520 --> 00:24:39,279
verifiability in a different way

671
00:24:37,440 --> 00:24:41,600
to conclude in this talk i introduced

672
00:24:39,279 --> 00:24:43,120
our recent construction of

673
00:24:41,600 --> 00:24:44,840
efficient constant run npc with

674
00:24:43,120 --> 00:24:46,799
identifiable abort and public

675
00:24:44,840 --> 00:24:49,279
verifiability

676
00:24:46,799 --> 00:24:51,200
the challenges that we faced when

677
00:24:49,279 --> 00:24:52,799
constructing this protocol were first of

678
00:24:51,200 --> 00:24:54,480
all to deal with this

679
00:24:52,799 --> 00:24:56,480
identifiable abort and with public

680
00:24:54,480 --> 00:25:00,080
verifiability in an efficient way

681
00:24:56,480 --> 00:25:03,279
meaning to avoid inefficient

682
00:25:00,080 --> 00:25:07,120
techniques such as zero knowledge proofs

683
00:25:03,279 --> 00:25:09,039
as much as possible we also eliminated

684
00:25:07,120 --> 00:25:11,199
this necessity of having adaptively

685
00:25:09,039 --> 00:25:12,559
secure oblivious transfer or adaptive

686
00:25:11,200 --> 00:25:16,159
secure pre-processing

687
00:25:12,559 --> 00:25:17,678
in order to have this verifiability of

688
00:25:16,159 --> 00:25:20,320
the pre-processing phase

689
00:25:17,679 --> 00:25:22,159
uh which is an additional contribution

690
00:25:20,320 --> 00:25:24,639
that we see in our work

691
00:25:22,159 --> 00:25:25,679
uh with respect to the work of hazard at

692
00:25:24,640 --> 00:25:27,520
all

693
00:25:25,679 --> 00:25:29,679
our overheads are as follows first of

694
00:25:27,520 --> 00:25:32,720
all during the online phase we

695
00:25:29,679 --> 00:25:33,919
make more use of broadcasts than than

696
00:25:32,720 --> 00:25:35,600
they do

697
00:25:33,919 --> 00:25:37,200
or use of a bulletin board in order to

698
00:25:35,600 --> 00:25:39,918
achieve public verifiability

699
00:25:37,200 --> 00:25:40,720
but we can actually reduce this overhead

700
00:25:39,919 --> 00:25:42,720
by

701
00:25:40,720 --> 00:25:44,080
using an optimistic variant of a

702
00:25:42,720 --> 00:25:46,240
protocol

703
00:25:44,080 --> 00:25:47,840
and during the offline phase we may also

704
00:25:46,240 --> 00:25:51,679
have to use more broadcast

705
00:25:47,840 --> 00:25:53,039
except um we can also reduce this

706
00:25:51,679 --> 00:25:55,919
using an optimistic variant of a

707
00:25:53,039 --> 00:25:57,440
protocol and we additionally need to use

708
00:25:55,919 --> 00:25:58,320
commitments or anarchist homomorphic

709
00:25:57,440 --> 00:26:01,520
commitments

710
00:25:58,320 --> 00:26:02,559
as mentioned in this talk with this

711
00:26:01,520 --> 00:26:04,400
i would like to thank you for your

712
00:26:02,559 --> 00:26:05,760
attention and if you have any questions

713
00:26:04,400 --> 00:26:07,520
feel free to contact

714
00:26:05,760 --> 00:26:11,520
me or any of the other authors of this

715
00:26:07,520 --> 00:26:11,520
work thank you

