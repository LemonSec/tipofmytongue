1
00:00:00,320 --> 00:00:05,040
hello everyone i'm subradit chakravarti

2
00:00:03,120 --> 00:00:08,000
and today i'll be talking about reverse

3
00:00:05,040 --> 00:00:09,599
firewalls for actively secure npcs

4
00:00:08,000 --> 00:00:12,639
this is a joint work with stefan

5
00:00:09,599 --> 00:00:14,320
jambowski and jesper boos nielsen

6
00:00:12,639 --> 00:00:16,640
in the classical setting we would like

7
00:00:14,320 --> 00:00:19,760
to think of two parties alice and bob

8
00:00:16,640 --> 00:00:22,080
with their private inputs x and x b and

9
00:00:19,760 --> 00:00:24,400
they want to engage in a protocol

10
00:00:22,080 --> 00:00:25,680
to produce some outputs y a and yb

11
00:00:24,400 --> 00:00:27,598
respectively

12
00:00:25,680 --> 00:00:29,279
and we think of an adversary sitting in

13
00:00:27,599 --> 00:00:31,840
the middle and observing the

14
00:00:29,279 --> 00:00:32,800
transcript of communication between

15
00:00:31,840 --> 00:00:34,880
alice and bob

16
00:00:32,800 --> 00:00:37,360
and potentially corrupting one of the

17
00:00:34,880 --> 00:00:40,000
protocol participants in this case bob

18
00:00:37,360 --> 00:00:41,760
to learn some useful information and we

19
00:00:40,000 --> 00:00:43,680
say that this protocol is secure

20
00:00:41,760 --> 00:00:45,839
if the adversary cannot cause any harm

21
00:00:43,680 --> 00:00:47,200
to alice even after corrupting bob

22
00:00:45,840 --> 00:00:50,640
and seeing the messages that are

23
00:00:47,200 --> 00:00:53,039
exchanging between the two parties

24
00:00:50,640 --> 00:00:54,320
however in the real world it's not just

25
00:00:53,039 --> 00:00:57,920
alice

26
00:00:54,320 --> 00:00:59,280
who talks to bob but it's alice's

27
00:00:57,920 --> 00:01:00,960
trusted computer who

28
00:00:59,280 --> 00:01:03,199
implements all the operations in the

29
00:01:00,960 --> 00:01:06,400
name of alice because alice cannot

30
00:01:03,199 --> 00:01:09,280
compute bilinear maps in her head

31
00:01:06,400 --> 00:01:10,000
so this brings us to the question should

32
00:01:09,280 --> 00:01:12,240
alice

33
00:01:10,000 --> 00:01:13,680
trust her computer the computer looks

34
00:01:12,240 --> 00:01:16,000
nice and innocent so far

35
00:01:13,680 --> 00:01:18,320
but one can never be too careful so in

36
00:01:16,000 --> 00:01:20,240
particular if alice's trusted computer

37
00:01:18,320 --> 00:01:22,479
is replaced with this tampered

38
00:01:20,240 --> 00:01:24,399
implementation with red eyes

39
00:01:22,479 --> 00:01:25,520
instead of sending the first legitimate

40
00:01:24,400 --> 00:01:28,240
message to bob

41
00:01:25,520 --> 00:01:29,119
it can just send alice's password over

42
00:01:28,240 --> 00:01:31,119
to bob

43
00:01:29,119 --> 00:01:33,600
and in the second message send over

44
00:01:31,119 --> 00:01:35,360
alice's credit card number to bob

45
00:01:33,600 --> 00:01:38,399
bob might be a bit confused but our

46
00:01:35,360 --> 00:01:40,720
adversary will certainly be happy

47
00:01:38,400 --> 00:01:42,560
while one can argue that this is

48
00:01:40,720 --> 00:01:44,798
obviously detectable

49
00:01:42,560 --> 00:01:46,000
but the adversary can be smart and it

50
00:01:44,799 --> 00:01:48,240
can use

51
00:01:46,000 --> 00:01:49,040
its own encryption key to encrypt this

52
00:01:48,240 --> 00:01:53,119
information

53
00:01:49,040 --> 00:01:53,119
or leak information steganographically

54
00:01:53,360 --> 00:01:56,880
and this is not only a theoretical

55
00:01:55,040 --> 00:01:58,880
prospect or a concern

56
00:01:56,880 --> 00:02:00,000
there has been widespread apparently

57
00:01:58,880 --> 00:02:02,320
accidental bugs

58
00:02:00,000 --> 00:02:03,360
in cryptographic software like the

59
00:02:02,320 --> 00:02:06,079
poodle

60
00:02:03,360 --> 00:02:07,280
the hurt bleed apple's go to failure the

61
00:02:06,079 --> 00:02:10,079
debian failure

62
00:02:07,280 --> 00:02:11,599
lockjam attacks and so on and so forth

63
00:02:10,080 --> 00:02:13,599
and while these attacks

64
00:02:11,599 --> 00:02:15,599
seem to be apparently accidental

65
00:02:13,599 --> 00:02:17,679
unfortunately there has been deliberate

66
00:02:15,599 --> 00:02:19,280
corruption of hardware and software

67
00:02:17,680 --> 00:02:22,080
that has been done by government

68
00:02:19,280 --> 00:02:24,239
agencies for example the nsa

69
00:02:22,080 --> 00:02:25,440
and you got to know that cryptographic

70
00:02:24,239 --> 00:02:29,120
tools and

71
00:02:25,440 --> 00:02:29,120
standards can be subverted

72
00:02:29,440 --> 00:02:32,959
one more recent example is the chinese

73
00:02:31,440 --> 00:02:35,519
chip hack that also

74
00:02:32,959 --> 00:02:36,000
infiltrated the hardware and affected

75
00:02:35,519 --> 00:02:38,000
the

76
00:02:36,000 --> 00:02:40,560
technology supply chain of the us on a

77
00:02:38,000 --> 00:02:42,720
massive scale

78
00:02:40,560 --> 00:02:44,400
so this brings us to this line of

79
00:02:42,720 --> 00:02:46,239
cryptography which is called post

80
00:02:44,400 --> 00:02:48,319
snowden cryptography

81
00:02:46,239 --> 00:02:49,760
which asks the following seemingly

82
00:02:48,319 --> 00:02:53,518
absurd question

83
00:02:49,760 --> 00:02:55,760
can we do crypto on tampered machines

84
00:02:53,519 --> 00:02:58,000
in particular can we get meaningful

85
00:02:55,760 --> 00:03:00,159
security for cryptographic protocols

86
00:02:58,000 --> 00:03:01,519
in the presence of an adversary who can

87
00:03:00,159 --> 00:03:04,560
arbitrarily tamper

88
00:03:01,519 --> 00:03:06,560
with the victim's computer

89
00:03:04,560 --> 00:03:07,840
and in fact there has been a statement

90
00:03:06,560 --> 00:03:11,760
by the iscr

91
00:03:07,840 --> 00:03:15,040
in eurocrypt 2014 that

92
00:03:11,760 --> 00:03:17,440
much that research should be done

93
00:03:15,040 --> 00:03:19,440
along these lines and one should develop

94
00:03:17,440 --> 00:03:20,239
effective techniques to protect personal

95
00:03:19,440 --> 00:03:21,840
privacy

96
00:03:20,239 --> 00:03:24,400
against government and corporate

97
00:03:21,840 --> 00:03:24,400
overreach

98
00:03:25,440 --> 00:03:28,640
so there has been some prior works

99
00:03:27,200 --> 00:03:30,640
addressing these issues

100
00:03:28,640 --> 00:03:33,440
starting with the work of simon's in

101
00:03:30,640 --> 00:03:36,000
1984 on subliminal channels

102
00:03:33,440 --> 00:03:37,440
divertable protocols cryptography and

103
00:03:36,000 --> 00:03:39,599
crypto biology

104
00:03:37,440 --> 00:03:40,720
unfortunately this line of works kind of

105
00:03:39,599 --> 00:03:43,440
died off

106
00:03:40,720 --> 00:03:44,720
after the 90s and it was resurrected

107
00:03:43,440 --> 00:03:46,400
only after the

108
00:03:44,720 --> 00:03:48,480
snowden revelations and one of the

109
00:03:46,400 --> 00:03:50,560
earlier works to address this was the

110
00:03:48,480 --> 00:03:52,079
work of bellare patterson and rogave

111
00:03:50,560 --> 00:03:54,480
who coined the name algorithm

112
00:03:52,080 --> 00:03:56,400
substitution attacks

113
00:03:54,480 --> 00:03:58,798
this mostly studied symmetric key

114
00:03:56,400 --> 00:04:00,480
encryption in this model

115
00:03:58,799 --> 00:04:03,439
and there has been work such as back

116
00:04:00,480 --> 00:04:05,679
door prgs by doris at all

117
00:04:03,439 --> 00:04:06,799
so this brings us to the second part of

118
00:04:05,680 --> 00:04:09,439
the talk

119
00:04:06,799 --> 00:04:10,959
about cryptographic reverse firewall so

120
00:04:09,439 --> 00:04:12,879
this model of cryptographic reverse

121
00:04:10,959 --> 00:04:14,000
firewall was introduced in eurocrypt

122
00:04:12,879 --> 00:04:17,358
2015 by

123
00:04:14,000 --> 00:04:19,279
ilya miranov and stephen davidowitz

124
00:04:17,358 --> 00:04:21,358
so what is a cryptographic reverse

125
00:04:19,279 --> 00:04:22,159
firewall so we can think of a reverse

126
00:04:21,358 --> 00:04:24,560
firewall as an

127
00:04:22,160 --> 00:04:26,320
active intermediary or a router that

128
00:04:24,560 --> 00:04:28,400
sits between alice's network

129
00:04:26,320 --> 00:04:30,479
and the outside internet represented by

130
00:04:28,400 --> 00:04:32,560
bob here

131
00:04:30,479 --> 00:04:34,560
it is a stateful algorithm that takes as

132
00:04:32,560 --> 00:04:37,120
input its current state

133
00:04:34,560 --> 00:04:38,240
and some message m and it outputs an

134
00:04:37,120 --> 00:04:40,800
updated state

135
00:04:38,240 --> 00:04:41,759
and some message m tilde so in

136
00:04:40,800 --> 00:04:43,680
particular

137
00:04:41,759 --> 00:04:45,919
we think of the firewall as sitting on

138
00:04:43,680 --> 00:04:47,919
the edge of alice's network

139
00:04:45,919 --> 00:04:49,120
and it sees the incoming and the

140
00:04:47,919 --> 00:04:51,758
outgoing messages

141
00:04:49,120 --> 00:04:53,520
that are sent and received by alice and

142
00:04:51,759 --> 00:04:55,680
it modifies these messages

143
00:04:53,520 --> 00:04:58,000
so in particular alice sends m1 the

144
00:04:55,680 --> 00:05:01,360
fireball mauls it to m1 tilde

145
00:04:58,000 --> 00:05:04,800
bob sends m2 fireball mall c2 m2 tilde

146
00:05:01,360 --> 00:05:07,039
and so on and one important requirement

147
00:05:04,800 --> 00:05:08,240
is that it should be transparent to

148
00:05:07,039 --> 00:05:10,880
legitimate traffic

149
00:05:08,240 --> 00:05:12,720
so this means that while alice sends a

150
00:05:10,880 --> 00:05:13,680
single message to the firewall the

151
00:05:12,720 --> 00:05:16,560
firewall

152
00:05:13,680 --> 00:05:17,360
should send the same message to bob so

153
00:05:16,560 --> 00:05:19,440
it's not like

154
00:05:17,360 --> 00:05:21,120
alice and the firewall are exchanging 20

155
00:05:19,440 --> 00:05:23,919
messages back and forth

156
00:05:21,120 --> 00:05:25,520
so in that in that sense alice should be

157
00:05:23,919 --> 00:05:27,039
completely oblivious that there is a

158
00:05:25,520 --> 00:05:30,799
firewall sitting on its

159
00:05:27,039 --> 00:05:32,000
network and the most important point is

160
00:05:30,800 --> 00:05:34,320
that the firewall

161
00:05:32,000 --> 00:05:35,039
shares no secret with alice so for

162
00:05:34,320 --> 00:05:37,199
example

163
00:05:35,039 --> 00:05:38,400
we are not delegating the trust to the

164
00:05:37,199 --> 00:05:40,720
firewall

165
00:05:38,400 --> 00:05:42,400
so the firewall is not a trusted third

166
00:05:40,720 --> 00:05:45,919
party it's just a helpful

167
00:05:42,400 --> 00:05:49,198
third party as i'll shortly

168
00:05:45,919 --> 00:05:52,080
demonstrate so the properties

169
00:05:49,199 --> 00:05:53,759
from such a crf are as follows

170
00:05:52,080 --> 00:05:55,280
functionality preserving

171
00:05:53,759 --> 00:05:57,120
so suppose there is an underlying

172
00:05:55,280 --> 00:05:58,159
classical protocol in which alice and

173
00:05:57,120 --> 00:06:01,520
bob talks

174
00:05:58,160 --> 00:06:03,039
and alice outputs y a and bob outputs yb

175
00:06:01,520 --> 00:06:04,840
so we want that the protocol with the

176
00:06:03,039 --> 00:06:06,719
firewall should not screw up the

177
00:06:04,840 --> 00:06:08,239
functionality so if alice's

178
00:06:06,720 --> 00:06:10,000
implementation is honest

179
00:06:08,240 --> 00:06:12,240
the protocol with the firewall should

180
00:06:10,000 --> 00:06:14,560
also allow alice to output ya

181
00:06:12,240 --> 00:06:16,960
and bob to output yb so this is

182
00:06:14,560 --> 00:06:19,199
extremely straightforward

183
00:06:16,960 --> 00:06:20,080
the second more important property is

184
00:06:19,199 --> 00:06:22,960
that of security

185
00:06:20,080 --> 00:06:24,880
preservation so suppose there is an

186
00:06:22,960 --> 00:06:28,159
underlying classical protocol

187
00:06:24,880 --> 00:06:30,240
that satisfies some security requirement

188
00:06:28,160 --> 00:06:31,680
say this is modeled by some crazy game

189
00:06:30,240 --> 00:06:33,600
in which the

190
00:06:31,680 --> 00:06:35,600
adversary corrupts bob and might have

191
00:06:33,600 --> 00:06:37,280
oracle access to multiple copies of

192
00:06:35,600 --> 00:06:39,680
alice and so on

193
00:06:37,280 --> 00:06:41,679
and still the adversary cannot break the

194
00:06:39,680 --> 00:06:44,400
security of the protocol

195
00:06:41,680 --> 00:06:45,440
so now we want to say that if there is a

196
00:06:44,400 --> 00:06:48,080
firewall

197
00:06:45,440 --> 00:06:49,759
and if alice's implementation is corrupt

198
00:06:48,080 --> 00:06:50,960
the security of the protocol will be

199
00:06:49,759 --> 00:06:53,199
preserved

200
00:06:50,960 --> 00:06:55,198
so in particular the protocol with the

201
00:06:53,199 --> 00:06:56,479
firewall should satisfy the same

202
00:06:55,199 --> 00:07:00,000
security requirements

203
00:06:56,479 --> 00:07:02,479
x but now alice's implementation

204
00:07:00,000 --> 00:07:05,039
is replaced with any efficient

205
00:07:02,479 --> 00:07:05,039
corruption

206
00:07:05,759 --> 00:07:09,280
and we want to say that the adversary

207
00:07:08,160 --> 00:07:12,000
also loses

208
00:07:09,280 --> 00:07:12,559
in this firewall protocol when it gets

209
00:07:12,000 --> 00:07:17,280
access

210
00:07:12,560 --> 00:07:19,039
to this firewalled version of alice

211
00:07:17,280 --> 00:07:20,559
and here we make a distinction between

212
00:07:19,039 --> 00:07:23,919
strong versus weak

213
00:07:20,560 --> 00:07:27,280
security preservation which i'll shortly

214
00:07:23,919 --> 00:07:29,840
explain and i want to stress

215
00:07:27,280 --> 00:07:31,359
this point that we always assume that

216
00:07:29,840 --> 00:07:32,000
there should be a protocol that is

217
00:07:31,360 --> 00:07:34,560
functional

218
00:07:32,000 --> 00:07:36,400
and secure without the firewall and the

219
00:07:34,560 --> 00:07:39,919
protocols that are not functional in the

220
00:07:36,400 --> 00:07:42,719
first place are not interesting

221
00:07:39,919 --> 00:07:43,198
so the types of corruptions that we will

222
00:07:42,720 --> 00:07:46,560
become

223
00:07:43,199 --> 00:07:48,160
we will be considering are suppose there

224
00:07:46,560 --> 00:07:50,319
is a classical protocol

225
00:07:48,160 --> 00:07:51,440
that satisfies some functionality f and

226
00:07:50,319 --> 00:07:54,319
security requirement

227
00:07:51,440 --> 00:07:56,240
s so we want so the first model of

228
00:07:54,319 --> 00:07:58,160
corruption is strong corruption where we

229
00:07:56,240 --> 00:08:00,479
assume that there is any efficient

230
00:07:58,160 --> 00:08:02,560
arbitrary tampering strategy

231
00:08:00,479 --> 00:08:04,560
and secondly weak corruption that says

232
00:08:02,560 --> 00:08:05,520
that the tampering strategy can be

233
00:08:04,560 --> 00:08:07,039
arbitrary

234
00:08:05,520 --> 00:08:08,960
as long as it does not break the

235
00:08:07,039 --> 00:08:10,960
correctness of the protocol

236
00:08:08,960 --> 00:08:13,440
however it might still behave

237
00:08:10,960 --> 00:08:16,000
arbitrarily a negligible fraction of

238
00:08:13,440 --> 00:08:17,599
time for instance suppose there is an

239
00:08:16,000 --> 00:08:19,120
oblivious transfer protocol

240
00:08:17,599 --> 00:08:21,520
in which bob's first message is

241
00:08:19,120 --> 00:08:24,800
uniformly random over some set

242
00:08:21,520 --> 00:08:26,080
and the and bob learns mb

243
00:08:24,800 --> 00:08:27,840
and it should not learn the other

244
00:08:26,080 --> 00:08:29,840
message whereas ali should not learn the

245
00:08:27,840 --> 00:08:31,198
bit b

246
00:08:29,840 --> 00:08:32,958
now it might happen that for a

247
00:08:31,199 --> 00:08:34,399
particular choice of the first message

248
00:08:32,958 --> 00:08:37,119
of bob

249
00:08:34,399 --> 00:08:38,880
say zeros all zero strings alice just

250
00:08:37,120 --> 00:08:42,719
encodes

251
00:08:38,880 --> 00:08:43,279
the um xor of both m 0 and m 1 into the

252
00:08:42,719 --> 00:08:46,320
output

253
00:08:43,279 --> 00:08:47,519
represented by z 1 tilde here to bob and

254
00:08:46,320 --> 00:08:50,000
bob

255
00:08:47,519 --> 00:08:52,080
when it is corrupt can just send this

256
00:08:50,000 --> 00:08:52,959
all 0 string to learn the xor of the two

257
00:08:52,080 --> 00:08:55,120
messages which

258
00:08:52,959 --> 00:08:57,279
otherwise would not have been possible

259
00:08:55,120 --> 00:09:00,560
in

260
00:08:57,279 --> 00:09:01,920
for a secure ot protocol and the third

261
00:09:00,560 --> 00:09:03,839
property that we need is that of

262
00:09:01,920 --> 00:09:06,000
exfiltration resistance

263
00:09:03,839 --> 00:09:08,320
which says that a corrupt implementation

264
00:09:06,000 --> 00:09:09,279
of alice cannot leak any information to

265
00:09:08,320 --> 00:09:11,760
an attacker

266
00:09:09,279 --> 00:09:12,800
via the reverse firewall so in

267
00:09:11,760 --> 00:09:16,319
particular

268
00:09:12,800 --> 00:09:18,079
in the world above alice's

269
00:09:16,320 --> 00:09:20,839
tampered implementation is clubbed with

270
00:09:18,080 --> 00:09:22,080
the firewall and we see this as a joint

271
00:09:20,839 --> 00:09:26,000
party

272
00:09:22,080 --> 00:09:27,760
and in the second world alice is honest

273
00:09:26,000 --> 00:09:29,760
and is clubbed with the firewall and we

274
00:09:27,760 --> 00:09:31,200
want to say that in both these worlds

275
00:09:29,760 --> 00:09:34,000
are indistinguishable

276
00:09:31,200 --> 00:09:35,760
and again we make a distinction between

277
00:09:34,000 --> 00:09:36,480
strong versus weak exfiltration

278
00:09:35,760 --> 00:09:38,800
resistance

279
00:09:36,480 --> 00:09:40,480
so when i say strong i'm referring to

280
00:09:38,800 --> 00:09:42,560
the strong model of corruption

281
00:09:40,480 --> 00:09:44,959
and weak i'm referring to the weak model

282
00:09:42,560 --> 00:09:45,680
of corruption and in this case if bob is

283
00:09:44,959 --> 00:09:48,800
corrupt

284
00:09:45,680 --> 00:09:52,719
we call security against pr party else

285
00:09:48,800 --> 00:09:52,719
we call security against an eavesdropper

286
00:09:53,839 --> 00:09:57,360
so the first work of miranov and stephen

287
00:09:56,240 --> 00:09:59,040
davidavids

288
00:09:57,360 --> 00:10:01,120
constructed reverse firewall for

289
00:09:59,040 --> 00:10:04,959
arbitrary two-party protocols

290
00:10:01,120 --> 00:10:06,800
we are constructing an rf compatib

291
00:10:04,959 --> 00:10:08,160
rf compatible private function

292
00:10:06,800 --> 00:10:10,079
evaluation protocol

293
00:10:08,160 --> 00:10:11,839
and their techniques used

294
00:10:10,079 --> 00:10:14,239
re-randomizable garble circuit and

295
00:10:11,839 --> 00:10:16,000
re-randomizable od

296
00:10:14,240 --> 00:10:18,079
and they also show a general method to

297
00:10:16,000 --> 00:10:19,600
compile any protocol to an exfiltration

298
00:10:18,079 --> 00:10:21,920
resistant protocol

299
00:10:19,600 --> 00:10:23,440
however the disadvantage is that it

300
00:10:21,920 --> 00:10:24,640
recompiles the protocol into the

301
00:10:23,440 --> 00:10:27,920
encrypted domain

302
00:10:24,640 --> 00:10:31,199
which makes the protocol

303
00:10:27,920 --> 00:10:33,439
not transparent so in the follow-up work

304
00:10:31,200 --> 00:10:35,760
by doris mironov and stephen davidowitz

305
00:10:33,440 --> 00:10:36,880
they construct secure message

306
00:10:35,760 --> 00:10:40,000
transmission protocol

307
00:10:36,880 --> 00:10:42,640
in the rf setting and there is

308
00:10:40,000 --> 00:10:44,880
another follow-up work which shows how

309
00:10:42,640 --> 00:10:46,720
to construct

310
00:10:44,880 --> 00:10:48,000
reverse firewalls for functionalities

311
00:10:46,720 --> 00:10:50,399
that are realizable

312
00:10:48,000 --> 00:10:51,440
by smooth projective hash proof systems

313
00:10:50,399 --> 00:10:54,959
and finally

314
00:10:51,440 --> 00:10:57,360
uh in a recent work uh

315
00:10:54,959 --> 00:10:59,439
ganesh maguri and vanchuri shows how to

316
00:10:57,360 --> 00:11:00,079
construct crs for interactive proof

317
00:10:59,440 --> 00:11:04,160
system

318
00:11:00,079 --> 00:11:06,239
via malleable sigma protocols

319
00:11:04,160 --> 00:11:08,560
so quoting miranov and stephen

320
00:11:06,240 --> 00:11:10,000
davidovich from their original paper

321
00:11:08,560 --> 00:11:11,839
the holy grail would be a full

322
00:11:10,000 --> 00:11:13,200
characterization of functionalities and

323
00:11:11,839 --> 00:11:15,680
security properties

324
00:11:13,200 --> 00:11:16,640
for which reverse firewall exist so in

325
00:11:15,680 --> 00:11:19,199
this paper

326
00:11:16,640 --> 00:11:20,720
we solve this open problem and give a

327
00:11:19,200 --> 00:11:24,240
full characterization

328
00:11:20,720 --> 00:11:26,399
of such functionalities in particular

329
00:11:24,240 --> 00:11:28,720
we construct multi-party computation

330
00:11:26,399 --> 00:11:30,240
with reverse firewall so

331
00:11:28,720 --> 00:11:32,640
in this setting there is a bunch of

332
00:11:30,240 --> 00:11:35,519
parties each with their private inputs

333
00:11:32,640 --> 00:11:35,839
x i and they want to compute a function

334
00:11:35,519 --> 00:11:38,399
f

335
00:11:35,839 --> 00:11:39,760
over their inputs and a subset of these

336
00:11:38,399 --> 00:11:40,640
parties can be corrupted by the

337
00:11:39,760 --> 00:11:43,920
adversary

338
00:11:40,640 --> 00:11:46,000
and we want to say that the pa that

339
00:11:43,920 --> 00:11:49,760
nothing other than the output should be

340
00:11:46,000 --> 00:11:52,240
leaked that is f of x 1 to x n

341
00:11:49,760 --> 00:11:54,319
and this can be formalized using the

342
00:11:52,240 --> 00:11:56,160
real world ideal world paradigm which i

343
00:11:54,320 --> 00:11:58,399
will not go into

344
00:11:56,160 --> 00:11:59,600
so in the reverse firewall setting again

345
00:11:58,399 --> 00:12:01,440
each of the parties have their own

346
00:11:59,600 --> 00:12:03,040
private inputs and a subset of them can

347
00:12:01,440 --> 00:12:05,279
be corrupt as before

348
00:12:03,040 --> 00:12:07,040
but now the remaining honest parties can

349
00:12:05,279 --> 00:12:08,959
also be corrupt

350
00:12:07,040 --> 00:12:10,719
albeit in a functionality maintaining

351
00:12:08,959 --> 00:12:12,638
way so we consider

352
00:12:10,720 --> 00:12:14,079
all the parties in the mpc protocol can

353
00:12:12,639 --> 00:12:15,839
now be corrupted

354
00:12:14,079 --> 00:12:18,000
some subset of them can be corrupted in

355
00:12:15,839 --> 00:12:18,560
an arbitrary way as in the original mpc

356
00:12:18,000 --> 00:12:20,240
protocol

357
00:12:18,560 --> 00:12:22,560
and the remaining honest parties can

358
00:12:20,240 --> 00:12:25,839
also be corrupt but in a functionality

359
00:12:22,560 --> 00:12:25,839
maintaining way

360
00:12:26,480 --> 00:12:30,480
and for those parties which are

361
00:12:28,639 --> 00:12:31,200
corrupted in a functionality maintaining

362
00:12:30,480 --> 00:12:33,920
way

363
00:12:31,200 --> 00:12:35,360
we replace those parties with the party

364
00:12:33,920 --> 00:12:39,120
with the tempered implementation of the

365
00:12:35,360 --> 00:12:42,320
parties clubbed with the firewall

366
00:12:39,120 --> 00:12:43,200
and we call these parties as this joint

367
00:12:42,320 --> 00:12:46,399
parties with

368
00:12:43,200 --> 00:12:50,240
a hat so in particular pi hat is the

369
00:12:46,399 --> 00:12:53,360
firewall composed with pi

370
00:12:50,240 --> 00:12:56,079
and we want to say that when

371
00:12:53,360 --> 00:12:56,880
uh the parties the honest parties and

372
00:12:56,079 --> 00:12:59,439
are

373
00:12:56,880 --> 00:13:01,600
honest the firework protocol should not

374
00:12:59,440 --> 00:13:04,160
break the functionality

375
00:13:01,600 --> 00:13:07,279
security preservation says that now when

376
00:13:04,160 --> 00:13:09,199
we replace this pis with pi heads

377
00:13:07,279 --> 00:13:11,760
the security property of the mpc

378
00:13:09,200 --> 00:13:14,079
protocol should be retained

379
00:13:11,760 --> 00:13:17,279
an exfiltration resistance says that for

380
00:13:14,079 --> 00:13:17,279
example p3 hat

381
00:13:19,360 --> 00:13:22,880
cannot leak any information um via the

382
00:13:22,240 --> 00:13:24,560
firewall

383
00:13:22,880 --> 00:13:26,160
to any other parties and similarly we

384
00:13:24,560 --> 00:13:29,680
can define it for p1 hat

385
00:13:26,160 --> 00:13:31,600
and p5 head and so on so in this paper

386
00:13:29,680 --> 00:13:32,638
we construct the first actively secure

387
00:13:31,600 --> 00:13:35,120
mpc protocol

388
00:13:32,639 --> 00:13:37,360
in the setting and we show a generic

389
00:13:35,120 --> 00:13:38,800
compiler that takes any passively secure

390
00:13:37,360 --> 00:13:40,880
mpc protocol

391
00:13:38,800 --> 00:13:43,120
to and compiles it to an actively secure

392
00:13:40,880 --> 00:13:45,519
mpc protocol in the rf setting

393
00:13:43,120 --> 00:13:47,519
so the way we do that is we take the gmw

394
00:13:45,519 --> 00:13:49,360
compiler and show how to make it reverse

395
00:13:47,519 --> 00:13:51,760
firewall compatible

396
00:13:49,360 --> 00:13:53,519
so the main contribution of our work is

397
00:13:51,760 --> 00:13:55,439
how to construct a multi-party coin

398
00:13:53,519 --> 00:13:57,199
tossing protocol in this setting

399
00:13:55,440 --> 00:13:58,800
and finally we show that all these

400
00:13:57,199 --> 00:14:01,359
individual building blocks when they are

401
00:13:58,800 --> 00:14:04,000
made rf compatible they compose together

402
00:14:01,360 --> 00:14:05,279
to give the final actively secure

403
00:14:04,000 --> 00:14:07,120
protocol

404
00:14:05,279 --> 00:14:08,639
and as a result of independent interest

405
00:14:07,120 --> 00:14:10,480
we also show a compiler

406
00:14:08,639 --> 00:14:12,079
for reverse firewall in the broadcast

407
00:14:10,480 --> 00:14:15,199
model

408
00:14:12,079 --> 00:14:18,079
so let's just quickly recall ourselves

409
00:14:15,199 --> 00:14:20,319
about the blueprint of the gmw compiler

410
00:14:18,079 --> 00:14:22,719
so it takes any semi-honest mpc protocol

411
00:14:20,320 --> 00:14:23,440
pi and compiles it to pi prime as

412
00:14:22,720 --> 00:14:25,120
follows

413
00:14:23,440 --> 00:14:26,800
all the parties first commit to their

414
00:14:25,120 --> 00:14:27,760
input by running an input commitment

415
00:14:26,800 --> 00:14:30,079
protocol

416
00:14:27,760 --> 00:14:31,600
and then the parties fix their random

417
00:14:30,079 --> 00:14:34,880
tapes by running

418
00:14:31,600 --> 00:14:38,000
a coin tossing protocol and finally

419
00:14:34,880 --> 00:14:40,079
they run the parties then run each step

420
00:14:38,000 --> 00:14:43,199
of the semi honest mpc protocol

421
00:14:40,079 --> 00:14:45,519
and proving zero knowledge that

422
00:14:43,199 --> 00:14:46,880
the the computation was correct and is

423
00:14:45,519 --> 00:14:50,240
consistent with their

424
00:14:46,880 --> 00:14:51,120
committed inputs and their uh random

425
00:14:50,240 --> 00:14:52,880
tapes

426
00:14:51,120 --> 00:14:54,720
and the claim is this this protocol is

427
00:14:52,880 --> 00:14:58,160
actively secure by now it is

428
00:14:54,720 --> 00:15:00,560
well known and now

429
00:14:58,160 --> 00:15:01,519
to lift this compiler to the reverse

430
00:15:00,560 --> 00:15:03,040
firewall setting

431
00:15:01,519 --> 00:15:05,040
we need to replace each of this

432
00:15:03,040 --> 00:15:06,959
highlighted component into the reverse

433
00:15:05,040 --> 00:15:09,120
firewall counterpart

434
00:15:06,959 --> 00:15:10,880
so i will mostly focus on the coin

435
00:15:09,120 --> 00:15:13,760
tossing protocol which will give you an

436
00:15:10,880 --> 00:15:16,000
idea about

437
00:15:13,760 --> 00:15:17,680
the techniques that we use for the rest

438
00:15:16,000 --> 00:15:20,079
of the protocols as well

439
00:15:17,680 --> 00:15:22,000
so for that we brief let's briefly

440
00:15:20,079 --> 00:15:23,199
recall ourselves about non-interactive

441
00:15:22,000 --> 00:15:25,440
zero knowledge proofs

442
00:15:23,199 --> 00:15:27,359
which allows approver to convince a

443
00:15:25,440 --> 00:15:30,720
verifier that it knows a witness

444
00:15:27,360 --> 00:15:30,720
without revealing the witness

445
00:15:30,959 --> 00:15:34,079
and the completeness is that the honest

446
00:15:32,480 --> 00:15:36,160
prover should always convince the

447
00:15:34,079 --> 00:15:37,839
verifier if it knows the witness

448
00:15:36,160 --> 00:15:39,519
soundness says that the cheating prover

449
00:15:37,839 --> 00:15:42,240
cannot convince a verifier

450
00:15:39,519 --> 00:15:44,000
if the statement is not in the language

451
00:15:42,240 --> 00:15:45,360
and we want the property of simulation

452
00:15:44,000 --> 00:15:48,880
sound extractability

453
00:15:45,360 --> 00:15:50,959
which says that even if after seeing

454
00:15:48,880 --> 00:15:52,639
many simulated proofs if the adversary

455
00:15:50,959 --> 00:15:54,479
comes up with a new proof

456
00:15:52,639 --> 00:15:56,399
there is an extractor who can extract a

457
00:15:54,480 --> 00:15:59,600
witness and it's easy to see that

458
00:15:56,399 --> 00:16:01,279
sse implies non-malleability

459
00:15:59,600 --> 00:16:03,759
so although we are talking about

460
00:16:01,279 --> 00:16:05,600
multi-party coin tossing but let's just

461
00:16:03,759 --> 00:16:06,880
uh consider the case of two parties

462
00:16:05,600 --> 00:16:10,320
which will give the

463
00:16:06,880 --> 00:16:12,560
the ideas um behind

464
00:16:10,320 --> 00:16:14,320
the coin tossing protocol so the

465
00:16:12,560 --> 00:16:15,839
functionality that we want to achieve is

466
00:16:14,320 --> 00:16:16,639
that two parties initially have no

467
00:16:15,839 --> 00:16:18,720
inputs

468
00:16:16,639 --> 00:16:19,759
and then one party would end up with a

469
00:16:18,720 --> 00:16:22,160
uniformly random

470
00:16:19,759 --> 00:16:24,639
m-bit string and the other party would

471
00:16:22,160 --> 00:16:26,800
get commitment to the string

472
00:16:24,639 --> 00:16:28,720
so this follows by the classical commit

473
00:16:26,800 --> 00:16:29,758
and proof paradigm where p1 first

474
00:16:28,720 --> 00:16:32,320
samples a string

475
00:16:29,759 --> 00:16:34,079
s commits to it and then proves in zero

476
00:16:32,320 --> 00:16:35,680
knowledge the commitment is consistent

477
00:16:34,079 --> 00:16:36,719
and sends the commitment and the proof

478
00:16:35,680 --> 00:16:39,279
to b2

479
00:16:36,720 --> 00:16:40,160
p2 also samples some string s2 and sends

480
00:16:39,279 --> 00:16:44,000
this s2

481
00:16:40,160 --> 00:16:46,880
to p1 and and then the p1 computes the

482
00:16:44,000 --> 00:16:49,440
final string as the xor of s1 and s2

483
00:16:46,880 --> 00:16:50,560
and commits to this string s and proves

484
00:16:49,440 --> 00:16:52,639
in zero knowledge

485
00:16:50,560 --> 00:16:53,839
that the initial commitment c 1 was also

486
00:16:52,639 --> 00:16:56,639
consistent

487
00:16:53,839 --> 00:16:57,600
and c is also consistent with the choice

488
00:16:56,639 --> 00:17:01,199
of the randomness

489
00:16:57,600 --> 00:17:04,160
and the strings s 1 s 2 and sends this

490
00:17:01,199 --> 00:17:06,799
final commitment and proof to p 2 and

491
00:17:04,160 --> 00:17:08,400
the output of p1 is the xor of these two

492
00:17:06,799 --> 00:17:10,319
strings

493
00:17:08,400 --> 00:17:12,720
and the output of p2 is the commitment

494
00:17:10,319 --> 00:17:16,399
to the string s

495
00:17:12,720 --> 00:17:18,160
okay now let's consider

496
00:17:16,400 --> 00:17:20,640
this protocol in the reverse firewall

497
00:17:18,160 --> 00:17:22,079
setting let's consider the case where p2

498
00:17:20,640 --> 00:17:25,199
is corrupt

499
00:17:22,079 --> 00:17:26,159
and now p1 is corrupt in a functionality

500
00:17:25,199 --> 00:17:29,440
maintaining way

501
00:17:26,160 --> 00:17:30,840
so what can go wrong first p1 might

502
00:17:29,440 --> 00:17:34,080
commit to a bad string

503
00:17:30,840 --> 00:17:36,159
s1 also the randomness r1 that is used

504
00:17:34,080 --> 00:17:38,799
to commit to s1 might leak information

505
00:17:36,160 --> 00:17:41,679
about the committed element

506
00:17:38,799 --> 00:17:44,720
and finally the final commitment proof

507
00:17:41,679 --> 00:17:44,720
might also be leaky

508
00:17:45,440 --> 00:17:49,440
now let's consider the case where p2 is

509
00:17:47,520 --> 00:17:50,160
corrupt in a functionality maintaining

510
00:17:49,440 --> 00:17:52,400
way

511
00:17:50,160 --> 00:17:54,480
surely it can choose a string s2 that

512
00:17:52,400 --> 00:17:57,200
acts as a subliminal channel

513
00:17:54,480 --> 00:17:58,240
to trigger some bad behavior of p1 so if

514
00:17:57,200 --> 00:18:00,240
we want to construct

515
00:17:58,240 --> 00:18:02,160
a coin tossing protocol in the reverse

516
00:18:00,240 --> 00:18:04,640
firewall setting we should be able to

517
00:18:02,160 --> 00:18:07,039
account for all these facts

518
00:18:04,640 --> 00:18:09,039
so let's see how to do it so the first

519
00:18:07,039 --> 00:18:11,840
idea is to

520
00:18:09,039 --> 00:18:14,080
is that when p1 is corrupt and there is

521
00:18:11,840 --> 00:18:16,000
a firewall sitting on top of p1

522
00:18:14,080 --> 00:18:17,199
it should be able to maul the commitment

523
00:18:16,000 --> 00:18:20,160
string c1

524
00:18:17,200 --> 00:18:23,440
so as to transform itself into a unif a

525
00:18:20,160 --> 00:18:25,679
commitment to a uniformly random string

526
00:18:23,440 --> 00:18:27,200
with fresh randomness it turns out that

527
00:18:25,679 --> 00:18:28,000
if we can replace the commitment with

528
00:18:27,200 --> 00:18:30,880
any homomorphic

529
00:18:28,000 --> 00:18:33,120
commitment scheme which allows for

530
00:18:30,880 --> 00:18:35,919
mauling and re-randomization

531
00:18:33,120 --> 00:18:36,719
this is sufficient however at this point

532
00:18:35,919 --> 00:18:40,000
the proof pi

533
00:18:36,720 --> 00:18:41,919
1 is no longer a valid proof

534
00:18:40,000 --> 00:18:43,760
and for the firewall to maintain the

535
00:18:41,919 --> 00:18:45,200
functionality it should be able to maul

536
00:18:43,760 --> 00:18:47,360
the proof as well

537
00:18:45,200 --> 00:18:49,679
however there is one inherent difficulty

538
00:18:47,360 --> 00:18:50,639
here since the proof is simulation sound

539
00:18:49,679 --> 00:18:52,880
extractable

540
00:18:50,640 --> 00:18:54,559
and this implies non-malleability by

541
00:18:52,880 --> 00:18:55,679
definition it cannot be mauled by the

542
00:18:54,559 --> 00:18:57,840
firewall

543
00:18:55,679 --> 00:18:59,679
and also a bigger problem is that even

544
00:18:57,840 --> 00:19:01,520
if the proof is malleable somehow

545
00:18:59,679 --> 00:19:03,280
the firewall does not know how to mull

546
00:19:01,520 --> 00:19:05,039
it since it does not know the

547
00:19:03,280 --> 00:19:06,639
committed string or the witness in the

548
00:19:05,039 --> 00:19:09,600
first place

549
00:19:06,640 --> 00:19:10,080
so to resolve this we use the idea we

550
00:19:09,600 --> 00:19:11,918
replace

551
00:19:10,080 --> 00:19:13,678
the music proof of knowledge or the

552
00:19:11,919 --> 00:19:15,919
simulation sound extractable

553
00:19:13,679 --> 00:19:17,440
music with a controlled malleable music

554
00:19:15,919 --> 00:19:20,320
proof system that i define

555
00:19:17,440 --> 00:19:22,840
next so this was in introduced in the

556
00:19:20,320 --> 00:19:24,159
paper of chess at all from eurocrypt

557
00:19:22,840 --> 00:19:25,840
2012.

558
00:19:24,160 --> 00:19:28,000
so this is an easy-proof system that

559
00:19:25,840 --> 00:19:29,520
satisfies completeness and soundness as

560
00:19:28,000 --> 00:19:32,000
before

561
00:19:29,520 --> 00:19:33,440
and in addition it satisfies

562
00:19:32,000 --> 00:19:35,679
malleability which says

563
00:19:33,440 --> 00:19:37,280
that given a bunch of proofs valid

564
00:19:35,679 --> 00:19:39,520
proofs for some statements

565
00:19:37,280 --> 00:19:40,559
there is a public evaluation procedure

566
00:19:39,520 --> 00:19:42,879
that takes this

567
00:19:40,559 --> 00:19:43,760
statements and proofs and molds it into

568
00:19:42,880 --> 00:19:47,120
a valid proof

569
00:19:43,760 --> 00:19:50,160
for a transform statement t

570
00:19:47,120 --> 00:19:52,399
where t is belongs to from belongs to

571
00:19:50,160 --> 00:19:54,640
some class of transformation

572
00:19:52,400 --> 00:19:57,919
note that zkevel does not need the

573
00:19:54,640 --> 00:19:59,919
witness to compute this valid proof

574
00:19:57,919 --> 00:20:02,080
and we want re-randomizability which

575
00:19:59,919 --> 00:20:03,840
says that any proof can also be

576
00:20:02,080 --> 00:20:07,360
randomized in a way that it is

577
00:20:03,840 --> 00:20:09,360
indistinguishable from a fresh proof

578
00:20:07,360 --> 00:20:11,600
and we want derivation privacy which

579
00:20:09,360 --> 00:20:14,799
says that the output of ck eval

580
00:20:11,600 --> 00:20:17,678
is indistinguishable from the case

581
00:20:14,799 --> 00:20:19,200
if the prover was giving a fresh proof

582
00:20:17,679 --> 00:20:22,400
on the transform statement

583
00:20:19,200 --> 00:20:24,080
and the transformed witness

584
00:20:22,400 --> 00:20:25,840
and finally we want the property of

585
00:20:24,080 --> 00:20:27,439
control malleable simulation sound

586
00:20:25,840 --> 00:20:30,000
extractability

587
00:20:27,440 --> 00:20:31,280
which says that even after seeing many

588
00:20:30,000 --> 00:20:33,039
simulated proofs

589
00:20:31,280 --> 00:20:35,600
if the adversary comes up with a proof

590
00:20:33,039 --> 00:20:37,760
pi star for some statement x star

591
00:20:35,600 --> 00:20:40,158
there is an extractor who can extract

592
00:20:37,760 --> 00:20:42,480
now either the witness

593
00:20:40,159 --> 00:20:43,360
such attesting to the fact that x star

594
00:20:42,480 --> 00:20:46,159
is in the np

595
00:20:43,360 --> 00:20:48,879
language so far this is same as ssenezik

596
00:20:46,159 --> 00:20:51,120
but also a tuple such that

597
00:20:48,880 --> 00:20:53,280
x star can be explained via this

598
00:20:51,120 --> 00:20:54,000
statement x prime and the transformation

599
00:20:53,280 --> 00:20:56,080
t

600
00:20:54,000 --> 00:20:59,039
such that x prime was previously queried

601
00:20:56,080 --> 00:20:59,039
by the adversary

602
00:20:59,440 --> 00:21:04,080
and basically uh it was shown in the

603
00:21:02,240 --> 00:21:04,799
paper that assuming decision linear

604
00:21:04,080 --> 00:21:06,320
assumption

605
00:21:04,799 --> 00:21:08,000
one can instantiate this control

606
00:21:06,320 --> 00:21:08,480
malleable physics in particular the

607
00:21:08,000 --> 00:21:11,440
gross

608
00:21:08,480 --> 00:21:12,400
high proofs are control malleable so now

609
00:21:11,440 --> 00:21:14,080
equipped with this

610
00:21:12,400 --> 00:21:16,320
homomorphic commitments and control

611
00:21:14,080 --> 00:21:17,600
malleable proof let's see how to do

612
00:21:16,320 --> 00:21:19,600
uh reverse firewalls for the coin

613
00:21:17,600 --> 00:21:21,600
tossing protocol

614
00:21:19,600 --> 00:21:23,520
so the idea would be the firewall should

615
00:21:21,600 --> 00:21:25,360
maul each and every step of the protocol

616
00:21:23,520 --> 00:21:28,480
and this is how it does

617
00:21:25,360 --> 00:21:31,520
so after receiving the first c one comma

618
00:21:28,480 --> 00:21:32,880
pi one it the the firewall computes the

619
00:21:31,520 --> 00:21:35,200
fresh commitments on it

620
00:21:32,880 --> 00:21:36,400
on its own and homomorphically adds the

621
00:21:35,200 --> 00:21:37,760
commitment and defines the

622
00:21:36,400 --> 00:21:40,960
transformation to be

623
00:21:37,760 --> 00:21:44,559
this homomorphic operation and derives a

624
00:21:40,960 --> 00:21:47,520
proof by using this zika eval algorithm

625
00:21:44,559 --> 00:21:48,639
so in fact you need to re-randomize this

626
00:21:47,520 --> 00:21:51,840
proof as well

627
00:21:48,640 --> 00:21:54,080
so first it re outputs this

628
00:21:51,840 --> 00:21:55,439
proof using zk val and randomizes the

629
00:21:54,080 --> 00:21:58,960
proof and sends this

630
00:21:55,440 --> 00:21:59,840
to p2 p2 then sends s2 and now the

631
00:21:58,960 --> 00:22:03,280
firewall mounts

632
00:21:59,840 --> 00:22:04,240
s2 by the offset it shows in the in step

633
00:22:03,280 --> 00:22:08,320
1

634
00:22:04,240 --> 00:22:11,200
and sends this mould s2 hat to p1

635
00:22:08,320 --> 00:22:13,200
and when p1 sends the final c comma pi

636
00:22:11,200 --> 00:22:13,840
it also appropriately malls the

637
00:22:13,200 --> 00:22:15,919
statement

638
00:22:13,840 --> 00:22:17,120
and molds the proof and hands over this

639
00:22:15,919 --> 00:22:19,200
proof to p2

640
00:22:17,120 --> 00:22:20,559
so one can show that the output of the

641
00:22:19,200 --> 00:22:22,720
coin tossing protocol

642
00:22:20,559 --> 00:22:24,879
is consistent so the firewall did not

643
00:22:22,720 --> 00:22:28,320
screw up the functionality

644
00:22:24,880 --> 00:22:28,320
and this is quite easy to see

645
00:22:28,480 --> 00:22:33,039
and in our paper we show that if the

646
00:22:31,679 --> 00:22:34,720
underlying building blocks

647
00:22:33,039 --> 00:22:36,799
satisfy the properties required the

648
00:22:34,720 --> 00:22:39,280
firewall satisfies security and

649
00:22:36,799 --> 00:22:42,158
exfiltration resistance against p2

650
00:22:39,280 --> 00:22:43,200
in this weak model of corruption okay

651
00:22:42,159 --> 00:22:45,360
now the

652
00:22:43,200 --> 00:22:46,960
coming to the input commit pen protocol

653
00:22:45,360 --> 00:22:49,439
so here the party pi

654
00:22:46,960 --> 00:22:51,200
has its input x i and r i and it commits

655
00:22:49,440 --> 00:22:53,679
to its input

656
00:22:51,200 --> 00:22:54,400
um and then proves in zero knowledge the

657
00:22:53,679 --> 00:22:56,240
commitments

658
00:22:54,400 --> 00:22:57,760
commitment was consistent and the

659
00:22:56,240 --> 00:23:00,880
firewall protocol is

660
00:22:57,760 --> 00:23:02,559
the idea is very similar so first

661
00:23:00,880 --> 00:23:04,720
the firewall computes the commitment to

662
00:23:02,559 --> 00:23:06,240
zero and hands over this

663
00:23:04,720 --> 00:23:08,720
and homomorphically computes the

664
00:23:06,240 --> 00:23:09,840
commitment and molds the proof and hands

665
00:23:08,720 --> 00:23:13,600
over this proof

666
00:23:09,840 --> 00:23:13,600
to uh the other parties

667
00:23:14,559 --> 00:23:18,720
okay and we also show that uh the

668
00:23:16,799 --> 00:23:20,879
firewall weakly preserves security

669
00:23:18,720 --> 00:23:22,320
for p1 and its exfiltration resistance

670
00:23:20,880 --> 00:23:24,720
for p1 against

671
00:23:22,320 --> 00:23:26,559
p2 so in particular we proved the

672
00:23:24,720 --> 00:23:29,840
multiparty version of this

673
00:23:26,559 --> 00:23:31,200
theorem and as as the last missing piece

674
00:23:29,840 --> 00:23:33,439
we show a reverse firewall for the

675
00:23:31,200 --> 00:23:35,440
authenticated computation protocol

676
00:23:33,440 --> 00:23:37,120
note that after the coin tossing and the

677
00:23:35,440 --> 00:23:39,520
input commitment protocol the inputs and

678
00:23:37,120 --> 00:23:41,918
the random tapes of each party is fixed

679
00:23:39,520 --> 00:23:43,600
and all other parties holds commitment

680
00:23:41,919 --> 00:23:44,480
to all other parties inputs and random

681
00:23:43,600 --> 00:23:45,918
steps

682
00:23:44,480 --> 00:23:47,840
and at this point we can just run the

683
00:23:45,919 --> 00:23:48,559
passively secured mpc and prove in zero

684
00:23:47,840 --> 00:23:52,080
knowledge

685
00:23:48,559 --> 00:23:53,760
that each computational step is valid so

686
00:23:52,080 --> 00:23:57,039
for the reverse firewall version of this

687
00:23:53,760 --> 00:23:58,960
we just need to re-randomize the proof

688
00:23:57,039 --> 00:24:01,120
which we can do using uh the

689
00:23:58,960 --> 00:24:04,000
randomizable musics

690
00:24:01,120 --> 00:24:04,879
and we also show that uh this firewall

691
00:24:04,000 --> 00:24:06,799
weakly preserves

692
00:24:04,880 --> 00:24:08,480
security for p1 and its exfiltration

693
00:24:06,799 --> 00:24:11,679
resistance against

694
00:24:08,480 --> 00:24:13,840
any pj so finally

695
00:24:11,679 --> 00:24:16,320
uh as a result of independent interest

696
00:24:13,840 --> 00:24:18,639
we show how to construct a compiler for

697
00:24:16,320 --> 00:24:20,240
reverse firewall for the broadcast model

698
00:24:18,640 --> 00:24:22,159
note that the assumption of broadcast

699
00:24:20,240 --> 00:24:24,159
channels in the rf setting is a stronger

700
00:24:22,159 --> 00:24:26,159
assumption than in the classical setting

701
00:24:24,159 --> 00:24:27,360
so we instantiate this using the dollar

702
00:24:26,159 --> 00:24:29,360
strong protocol

703
00:24:27,360 --> 00:24:31,039
and the main idea would be to transform

704
00:24:29,360 --> 00:24:32,399
the dollar strong protocol to a unique

705
00:24:31,039 --> 00:24:34,000
message protocol

706
00:24:32,400 --> 00:24:37,120
and this we do it by replacing the

707
00:24:34,000 --> 00:24:38,960
signatures with unique signatures

708
00:24:37,120 --> 00:24:40,639
so at any point there is a unique choice

709
00:24:38,960 --> 00:24:41,200
of the next message that a party can

710
00:24:40,640 --> 00:24:43,360
send

711
00:24:41,200 --> 00:24:45,200
which is a signature and since it is

712
00:24:43,360 --> 00:24:47,360
corrupted in a functionality maintaining

713
00:24:45,200 --> 00:24:49,200
way it is forced to send this correct

714
00:24:47,360 --> 00:24:51,120
message

715
00:24:49,200 --> 00:24:53,360
and we this can be generalized for the

716
00:24:51,120 --> 00:24:56,080
class of re-randomizable signatures

717
00:24:53,360 --> 00:24:57,918
as well so to summarize we show the

718
00:24:56,080 --> 00:24:59,918
first feasibility result for actively

719
00:24:57,919 --> 00:25:00,960
secure mpc in the setting of reverse

720
00:24:59,919 --> 00:25:04,320
firewalls

721
00:25:00,960 --> 00:25:06,320
we show how to upgrade the gmw compiler

722
00:25:04,320 --> 00:25:07,760
to be made rf compatible

723
00:25:06,320 --> 00:25:09,600
and this we do by exploiting the

724
00:25:07,760 --> 00:25:10,640
homomorphic properties of the underlying

725
00:25:09,600 --> 00:25:12,719
commitment scheme

726
00:25:10,640 --> 00:25:15,840
and the control malleability feature of

727
00:25:12,720 --> 00:25:17,600
the underlying music argument system

728
00:25:15,840 --> 00:25:19,918
and we prove a generic composability

729
00:25:17,600 --> 00:25:22,000
theorem and show a reverse firewall

730
00:25:19,919 --> 00:25:24,080
for the broadcast model so some of the

731
00:25:22,000 --> 00:25:25,679
interesting open problems are

732
00:25:24,080 --> 00:25:27,279
can we construct more efficient and

733
00:25:25,679 --> 00:25:29,840
round optimal mpc

734
00:25:27,279 --> 00:25:30,799
in the rf setting say 2 round mpc in

735
00:25:29,840 --> 00:25:32,959
this setting

736
00:25:30,799 --> 00:25:34,400
can we construct adaptively secure mpc

737
00:25:32,960 --> 00:25:36,559
in the rf setting

738
00:25:34,400 --> 00:25:38,320
also note that since we use

739
00:25:36,559 --> 00:25:40,399
non-interactive zero knowledge proofs we

740
00:25:38,320 --> 00:25:43,600
rely on the trusted setup phase

741
00:25:40,400 --> 00:25:44,640
so can we remove uh the trusted setup

742
00:25:43,600 --> 00:25:47,520
assumption

743
00:25:44,640 --> 00:25:48,000
so with this i would like to conclude my

744
00:25:47,520 --> 00:25:50,080
talk

745
00:25:48,000 --> 00:25:51,039
and one can find the e-print version of

746
00:25:50,080 --> 00:25:54,080
our paper

747
00:25:51,039 --> 00:25:57,120
with report number 1317

748
00:25:54,080 --> 00:25:57,120
thank you

