1
00:00:02,159 --> 00:00:04,960
hi i'm marcia ball and i'm excited to

2
00:00:04,319 --> 00:00:06,720
tell you

3
00:00:04,960 --> 00:00:08,960
about some new techniques for zero

4
00:00:06,720 --> 00:00:11,280
knowledge um that were developed with

5
00:00:08,960 --> 00:00:13,679
donna document soled and cool cool

6
00:00:11,280 --> 00:00:13,678
kearney

7
00:00:14,480 --> 00:00:19,279
so to begin uh just a brief reminder

8
00:00:17,199 --> 00:00:21,119
about uh what a zero knowledge proof is

9
00:00:19,279 --> 00:00:22,800
so we have approver and a verifier

10
00:00:21,119 --> 00:00:24,720
and the approver is trying to convince

11
00:00:22,800 --> 00:00:28,320
the efficient verifier

12
00:00:24,720 --> 00:00:31,359
that uh this statement is true

13
00:00:28,320 --> 00:00:33,360
x is in l and and so

14
00:00:31,359 --> 00:00:34,399
there they interact and we only need

15
00:00:33,360 --> 00:00:36,800
three properties

16
00:00:34,399 --> 00:00:38,480
we need completeness if the statement is

17
00:00:36,800 --> 00:00:39,599
true then the verifier accepts with high

18
00:00:38,480 --> 00:00:41,680
probability

19
00:00:39,600 --> 00:00:43,520
we need the soundness so if the

20
00:00:41,680 --> 00:00:44,719
statement is not true then the verifier

21
00:00:43,520 --> 00:00:46,320
will reject

22
00:00:44,719 --> 00:00:48,480
uh with high probability and this should

23
00:00:46,320 --> 00:00:51,199
hold even if the prover is not behaving

24
00:00:48,480 --> 00:00:54,199
as specified behaving in fact or

25
00:00:51,199 --> 00:00:58,559
completely arbitrarily

26
00:00:54,199 --> 00:01:01,920
and we want zero knowledge so

27
00:00:58,559 --> 00:01:05,199
the zero knowledge says roughly that

28
00:01:01,920 --> 00:01:05,920
the verifier only learns the truth of

29
00:01:05,199 --> 00:01:07,759
the statement

30
00:01:05,920 --> 00:01:09,520
from interacting with approver and

31
00:01:07,760 --> 00:01:12,640
nothing else

32
00:01:09,520 --> 00:01:15,759
and this is captured by this

33
00:01:12,640 --> 00:01:19,119
uh simulation paradigm so right it's

34
00:01:15,759 --> 00:01:20,799
it says that uh right zero knowledge

35
00:01:19,119 --> 00:01:24,159
holds if there exists a simulator

36
00:01:20,799 --> 00:01:26,240
an efficient uh procedure for generating

37
00:01:24,159 --> 00:01:27,439
a transcript which is indistinguishable

38
00:01:26,240 --> 00:01:29,759
from the

39
00:01:27,439 --> 00:01:30,559
the real one by the prover the verifier

40
00:01:29,759 --> 00:01:32,400
center

41
00:01:30,560 --> 00:01:33,840
interacting with this truly magical

42
00:01:32,400 --> 00:01:36,079
program

43
00:01:33,840 --> 00:01:37,040
uh so since your knowledge is

44
00:01:36,079 --> 00:01:40,320
introduction

45
00:01:37,040 --> 00:01:42,799
we now know fair amount about the

46
00:01:40,320 --> 00:01:43,758
sort of complexity so if one way

47
00:01:42,799 --> 00:01:45,119
functions exist

48
00:01:43,759 --> 00:01:47,200
we have zero knowledge proofs for all of

49
00:01:45,119 --> 00:01:49,840
np and if they don't

50
00:01:47,200 --> 00:01:50,799
uh basically we only have zero knowledge

51
00:01:49,840 --> 00:01:53,270
proofs for

52
00:01:50,799 --> 00:01:54,799
languages that are trivial on average

53
00:01:53,270 --> 00:01:56,798
[Music]

54
00:01:54,799 --> 00:01:58,399
and the culmination of this is this work

55
00:01:56,799 --> 00:02:00,399
by ang vadan that says

56
00:01:58,399 --> 00:02:02,399
that we have zero knowledge for language

57
00:02:00,399 --> 00:02:05,920
even only if the language admits

58
00:02:02,399 --> 00:02:08,000
instance dependent commitments um

59
00:02:05,920 --> 00:02:09,280
in this work we're interested in

60
00:02:08,000 --> 00:02:11,038
understanding sort of

61
00:02:09,280 --> 00:02:13,040
minimal assumptions for zero knowledge

62
00:02:11,038 --> 00:02:16,399
but in particular we're interested

63
00:02:13,040 --> 00:02:20,000
in situations with uh very limited

64
00:02:16,400 --> 00:02:22,640
interaction and trust actually

65
00:02:20,000 --> 00:02:23,440
um so but the non-interactive zero

66
00:02:22,640 --> 00:02:27,040
knowledge is

67
00:02:23,440 --> 00:02:27,520
sort of uh a set a zero knowledge proof

68
00:02:27,040 --> 00:02:30,560
with

69
00:02:27,520 --> 00:02:32,400
as little interaction as possible um so

70
00:02:30,560 --> 00:02:34,480
in this setting right the prover is just

71
00:02:32,400 --> 00:02:36,000
going to send a single message

72
00:02:34,480 --> 00:02:38,160
to the verifier the verifier isn't going

73
00:02:36,000 --> 00:02:40,800
to speak at all

74
00:02:38,160 --> 00:02:41,200
this isn't achievable in the standalone

75
00:02:40,800 --> 00:02:44,080
model

76
00:02:41,200 --> 00:02:45,599
so what's typically done is the approver

77
00:02:44,080 --> 00:02:48,959
and verifier are given

78
00:02:45,599 --> 00:02:50,238
access to some public randomness

79
00:02:48,959 --> 00:02:52,879
so there's two settings that are

80
00:02:50,239 --> 00:02:54,640
typically considered one is the

81
00:02:52,879 --> 00:02:56,480
what we will call the common random

82
00:02:54,640 --> 00:02:59,679
string model or crs model

83
00:02:56,480 --> 00:03:02,640
where the randomness in the sky

84
00:02:59,680 --> 00:03:03,519
can be correlated need not be uniform

85
00:03:02,640 --> 00:03:06,559
bits

86
00:03:03,519 --> 00:03:10,319
and the other model considered

87
00:03:06,560 --> 00:03:12,720
typically in the literature is uh

88
00:03:10,319 --> 00:03:14,399
this uniform random string model or urs

89
00:03:12,720 --> 00:03:16,000
model where the bits are uniform

90
00:03:14,400 --> 00:03:18,480
and this is better typically understood

91
00:03:16,000 --> 00:03:20,640
to be sort of a situation

92
00:03:18,480 --> 00:03:22,640
requiring less trust whereas the

93
00:03:20,640 --> 00:03:24,000
correlations in the crs model might

94
00:03:22,640 --> 00:03:27,518
require

95
00:03:24,000 --> 00:03:29,760
uh using develop it must need to

96
00:03:27,519 --> 00:03:31,200
be generated using an npc or something

97
00:03:29,760 --> 00:03:32,640
like this anyways

98
00:03:31,200 --> 00:03:34,720
that's sort of outside the scope of this

99
00:03:32,640 --> 00:03:35,920
work um what do we know about these two

100
00:03:34,720 --> 00:03:39,040
models

101
00:03:35,920 --> 00:03:39,599
uh one way from one-way functions we can

102
00:03:39,040 --> 00:03:42,239
construct

103
00:03:39,599 --> 00:03:44,119
uh music with crs for np this can be

104
00:03:42,239 --> 00:03:47,760
extended actually to am

105
00:03:44,120 --> 00:03:49,280
and for in the uniform random string

106
00:03:47,760 --> 00:03:51,920
model we know how to construct

107
00:03:49,280 --> 00:03:53,599
nzx for np from one-way permutations

108
00:03:51,920 --> 00:03:57,040
this can also be extended

109
00:03:53,599 --> 00:03:59,200
we are also interested in sort of um

110
00:03:57,040 --> 00:04:02,239
relaxations of zero knowledge with

111
00:03:59,200 --> 00:04:04,238
limited interaction so one such notion

112
00:04:02,239 --> 00:04:06,959
that is found in many applications is

113
00:04:04,239 --> 00:04:09,920
this a beautiful idea from torque

114
00:04:06,959 --> 00:04:11,200
nor called a zap so in his app we have

115
00:04:09,920 --> 00:04:14,079
approver and a verifier

116
00:04:11,200 --> 00:04:14,399
and zap follows a very specific format

117
00:04:14,080 --> 00:04:16,239
so

118
00:04:14,400 --> 00:04:17,440
it's a public coin protocol and so the

119
00:04:16,238 --> 00:04:19,918
verifier sends

120
00:04:17,440 --> 00:04:21,680
uh start begins by sending a uniformly

121
00:04:19,918 --> 00:04:24,719
random message and the prover response

122
00:04:21,680 --> 00:04:27,919
and that's the end of the interaction

123
00:04:24,720 --> 00:04:29,759
and the difference between what i was

124
00:04:27,919 --> 00:04:32,719
describing earlier is that this

125
00:04:29,759 --> 00:04:34,720
uh the promise here is weaker than the

126
00:04:32,720 --> 00:04:36,400
one of zero knowledge is we just require

127
00:04:34,720 --> 00:04:38,479
witness and distinguishability so what

128
00:04:36,400 --> 00:04:42,000
is witness and distinguishability

129
00:04:38,479 --> 00:04:45,520
uh what we want is that for

130
00:04:42,000 --> 00:04:47,680
any two witnesses w1 w2 if i run the

131
00:04:45,520 --> 00:04:51,198
prover with w1

132
00:04:47,680 --> 00:04:52,080
and let them interact with any efficient

133
00:04:51,199 --> 00:04:53,680
verifier

134
00:04:52,080 --> 00:04:55,599
there is the transcript should be

135
00:04:53,680 --> 00:04:58,400
indistinguishable from

136
00:04:55,600 --> 00:04:59,680
if i ran the protocol where the approver

137
00:04:58,400 --> 00:05:03,359
had

138
00:04:59,680 --> 00:05:04,000
witnessed to so one thing to note is

139
00:05:03,360 --> 00:05:07,520
that

140
00:05:04,000 --> 00:05:10,080
if the language has unique weaknesses

141
00:05:07,520 --> 00:05:11,039
then this property is trivially

142
00:05:10,080 --> 00:05:12,639
satisfiable

143
00:05:11,039 --> 00:05:14,719
i can just prove it can just send the

144
00:05:12,639 --> 00:05:18,080
witness and it will be

145
00:05:14,720 --> 00:05:20,400
indistinguishable and uh

146
00:05:18,080 --> 00:05:22,960
secondly if the prover if we don't uh

147
00:05:20,400 --> 00:05:24,960
constrain the approver at all

148
00:05:22,960 --> 00:05:26,638
then the proofer can just find say the

149
00:05:24,960 --> 00:05:29,758
lexicographically first witness

150
00:05:26,639 --> 00:05:33,600
for any statement for the uh x and

151
00:05:29,759 --> 00:05:36,639
just send that um

152
00:05:33,600 --> 00:05:39,440
yeah so what did dwarkener

153
00:05:36,639 --> 00:05:39,919
show about this notion of zap they

154
00:05:39,440 --> 00:05:43,600
showed

155
00:05:39,919 --> 00:05:46,500
that it was equivalent to nizik

156
00:05:43,600 --> 00:05:48,160
in the uniform random string model

157
00:05:46,500 --> 00:05:50,320
[Music]

158
00:05:48,160 --> 00:05:52,160
and you may look at the slide you say

159
00:05:50,320 --> 00:05:53,759
why why do you have

160
00:05:52,160 --> 00:05:55,759
music is implied by a trapdoor

161
00:05:53,759 --> 00:05:58,160
permutation didn't you just show it

162
00:05:55,759 --> 00:06:00,639
holds from a comparatively weak

163
00:05:58,160 --> 00:06:03,120
assumption of one-way permutation

164
00:06:00,639 --> 00:06:04,639
and the reason for that is that this

165
00:06:03,120 --> 00:06:07,919
transformation

166
00:06:04,639 --> 00:06:10,880
critically only applies if the prover

167
00:06:07,919 --> 00:06:11,680
is efficient and the transformation i

168
00:06:10,880 --> 00:06:13,680
showed you

169
00:06:11,680 --> 00:06:15,680
or that was on the previous slide the

170
00:06:13,680 --> 00:06:16,880
provers inverting a one-way permutation

171
00:06:15,680 --> 00:06:19,919
and so this

172
00:06:16,880 --> 00:06:21,360
this construction from uh figure lapido

173
00:06:19,919 --> 00:06:25,039
and shamir

174
00:06:21,360 --> 00:06:26,400
is inherently inefficient so what we are

175
00:06:25,039 --> 00:06:28,880
interested in this work is

176
00:06:26,400 --> 00:06:30,239
can we show a similar transformation

177
00:06:28,880 --> 00:06:33,680
from the zik to zap

178
00:06:30,240 --> 00:06:36,240
with an inefficient prover and

179
00:06:33,680 --> 00:06:38,000
that is indeed what we do and so as a

180
00:06:36,240 --> 00:06:41,919
consequence we get zaps from

181
00:06:38,000 --> 00:06:44,880
one-way permutations uh with

182
00:06:41,919 --> 00:06:45,840
inefficient progress um but still

183
00:06:44,880 --> 00:06:48,560
non-trivial

184
00:06:45,840 --> 00:06:49,039
and we have a variety of applications uh

185
00:06:48,560 --> 00:06:52,240
or

186
00:06:49,039 --> 00:06:56,000
uh sort of relax zero knowledge type

187
00:06:52,240 --> 00:06:57,039
uh proofs with very limited interaction

188
00:06:56,000 --> 00:06:59,199
non-interactive witness and

189
00:06:57,039 --> 00:07:01,120
distinguishability one message serial

190
00:06:59,199 --> 00:07:02,960
knowledge and a new notion

191
00:07:01,120 --> 00:07:04,960
of what we call fine-grained zero

192
00:07:02,960 --> 00:07:07,198
knowledge and i'll say more about that

193
00:07:04,960 --> 00:07:08,318
at the end of this talk for now i just

194
00:07:07,199 --> 00:07:10,639
want to focus on

195
00:07:08,319 --> 00:07:12,479
this arrow across the middle this

196
00:07:10,639 --> 00:07:16,080
transformation from the zig to

197
00:07:12,479 --> 00:07:20,080
zap um

198
00:07:16,080 --> 00:07:23,198
and in particular what i'd like to show

199
00:07:20,080 --> 00:07:24,960
is this theorem so

200
00:07:23,199 --> 00:07:26,880
what does this say so right if a

201
00:07:24,960 --> 00:07:28,638
language l has

202
00:07:26,880 --> 00:07:30,719
a nizik in the uniform random string

203
00:07:28,639 --> 00:07:33,599
model and a t time improver

204
00:07:30,720 --> 00:07:34,240
then the language has a zap with a poly

205
00:07:33,599 --> 00:07:37,840
n times t

206
00:07:34,240 --> 00:07:38,400
program right as a corollary uh this

207
00:07:37,840 --> 00:07:42,479
from this

208
00:07:38,400 --> 00:07:45,840
immediately we get using this lapido

209
00:07:42,479 --> 00:07:48,080
lapido chemier uh protocol we get zaps

210
00:07:45,840 --> 00:07:49,919
with uh subexponential time perverse for

211
00:07:48,080 --> 00:07:52,240
np

212
00:07:49,919 --> 00:07:53,680
um so right we want to show this main

213
00:07:52,240 --> 00:07:56,960
theorem at the top

214
00:07:53,680 --> 00:07:57,360
uh let's recall how dwark and or show

215
00:07:56,960 --> 00:07:59,280
the

216
00:07:57,360 --> 00:08:00,720
transformation for efficient proofers so

217
00:07:59,280 --> 00:08:03,039
we start with the nizzic

218
00:08:00,720 --> 00:08:04,960
p and v are going to denote the verifier

219
00:08:03,039 --> 00:08:06,639
approver and verifier respectively and

220
00:08:04,960 --> 00:08:08,080
we want to construct a zap

221
00:08:06,639 --> 00:08:10,080
all right the first message needs to be

222
00:08:08,080 --> 00:08:12,000
random so we'll do just that

223
00:08:10,080 --> 00:08:13,359
the verifier will sample some random

224
00:08:12,000 --> 00:08:14,160
strings and send them over to the

225
00:08:13,360 --> 00:08:15,759
proverb

226
00:08:14,160 --> 00:08:18,000
approver will sample a random string of

227
00:08:15,759 --> 00:08:21,919
his own s

228
00:08:18,000 --> 00:08:25,840
then he will xor s with

229
00:08:21,919 --> 00:08:29,039
each ri to generate a series of

230
00:08:25,840 --> 00:08:29,840
urs's and with respect to each urs he's

231
00:08:29,039 --> 00:08:31,919
going to generate

232
00:08:29,840 --> 00:08:33,519
a proof he will send this back to the

233
00:08:31,919 --> 00:08:36,958
verifier

234
00:08:33,519 --> 00:08:39,679
and she will accept if the music

235
00:08:36,958 --> 00:08:41,439
verifier accepts all of the proofs

236
00:08:39,679 --> 00:08:43,439
after reconstructing the uss of course

237
00:08:41,440 --> 00:08:44,480
so as you can see like right the first

238
00:08:43,440 --> 00:08:46,720
message is uh

239
00:08:44,480 --> 00:08:49,120
informs the satisfies public coin the

240
00:08:46,720 --> 00:08:51,440
urs because we're xoring random stuff

241
00:08:49,120 --> 00:08:52,959
with a random string is going to be uh

242
00:08:51,440 --> 00:08:56,480
uniform for

243
00:08:52,959 --> 00:08:57,920
each proof so right it should be

244
00:08:56,480 --> 00:08:59,680
fairly obvious by inspection that

245
00:08:57,920 --> 00:09:00,800
completeness holds based on the

246
00:08:59,680 --> 00:09:04,079
completeness of the

247
00:09:00,800 --> 00:09:06,399
music proof soundness

248
00:09:04,080 --> 00:09:07,279
uh to see soundness we're going to fix

249
00:09:06,399 --> 00:09:08,800
some uh

250
00:09:07,279 --> 00:09:10,399
x that's not in the language that we

251
00:09:08,800 --> 00:09:11,519
care about

252
00:09:10,399 --> 00:09:13,519
and we're going to invoke the

253
00:09:11,519 --> 00:09:16,640
statistical soundness of the music

254
00:09:13,519 --> 00:09:20,000
to argue that there are very few

255
00:09:16,640 --> 00:09:23,199
bad uniform random strings in this

256
00:09:20,000 --> 00:09:26,720
uniform random string is bad if

257
00:09:23,200 --> 00:09:29,680
there exists a pie which makes the

258
00:09:26,720 --> 00:09:29,680
verifier accept

259
00:09:30,160 --> 00:09:35,439
and right so

260
00:09:33,600 --> 00:09:36,720
next we will observe that for any fixed

261
00:09:35,440 --> 00:09:40,160
s over the randomness

262
00:09:36,720 --> 00:09:41,680
of r the rise the probability that all

263
00:09:40,160 --> 00:09:45,360
of these uniformly random

264
00:09:41,680 --> 00:09:47,199
urs's are bad is

265
00:09:45,360 --> 00:09:48,839
can be bounded by something that's

266
00:09:47,200 --> 00:09:51,600
exponential in

267
00:09:48,839 --> 00:09:54,399
m and next

268
00:09:51,600 --> 00:09:56,480
uh by simply taking a union bound over

269
00:09:54,399 --> 00:09:58,959
all of the s's

270
00:09:56,480 --> 00:09:59,600
uh we can bound the probability that

271
00:09:58,959 --> 00:10:03,119
there exists

272
00:09:59,600 --> 00:10:04,880
any sort of s that would allow the

273
00:10:03,120 --> 00:10:08,480
proverb to

274
00:10:04,880 --> 00:10:10,720
trick the verifier and um

275
00:10:08,480 --> 00:10:11,519
and we can bound this with to the minus

276
00:10:10,720 --> 00:10:14,720
m plus n

277
00:10:11,519 --> 00:10:17,279
so as long as m is greater than n we're

278
00:10:14,720 --> 00:10:18,480
good and we have statistical soundness

279
00:10:17,279 --> 00:10:21,519
the final property we need

280
00:10:18,480 --> 00:10:23,839
is witness and distinguishability

281
00:10:21,519 --> 00:10:23,839
um

282
00:10:24,720 --> 00:10:28,160
and i guess before i continue there's

283
00:10:26,240 --> 00:10:32,079
nothing about these prior proofs

284
00:10:28,160 --> 00:10:34,800
completeness or soundness that required

285
00:10:32,079 --> 00:10:36,079
uh it said anything that sort of would

286
00:10:34,800 --> 00:10:39,519
differ if the program was

287
00:10:36,079 --> 00:10:40,000
inefficient so the problem is going to

288
00:10:39,519 --> 00:10:40,800
come up

289
00:10:40,000 --> 00:10:42,640
here in the witness and

290
00:10:40,800 --> 00:10:44,160
distinguishability so the witness and

291
00:10:42,640 --> 00:10:47,199
distinguishability is going to be proven

292
00:10:44,160 --> 00:10:50,319
near using a hybrid argument so we want

293
00:10:47,200 --> 00:10:53,360
to switch these proofs

294
00:10:50,320 --> 00:10:56,160
pi 1 through pi n one by one

295
00:10:53,360 --> 00:10:57,040
from being generated using a witness one

296
00:10:56,160 --> 00:11:00,160
to witness

297
00:10:57,040 --> 00:11:02,640
two and so in the ice hybrid what we'll

298
00:11:00,160 --> 00:11:05,760
have is we'll have already switched

299
00:11:02,640 --> 00:11:09,519
uh over the first i minus one proofs

300
00:11:05,760 --> 00:11:10,079
uh to witness two and we'll try to

301
00:11:09,519 --> 00:11:14,560
switch

302
00:11:10,079 --> 00:11:16,319
over the ice proof

303
00:11:14,560 --> 00:11:18,079
and the way that we're going to do this

304
00:11:16,320 --> 00:11:21,760
is we're going to reduce

305
00:11:18,079 --> 00:11:24,880
to the zero knowledge property of the

306
00:11:21,760 --> 00:11:28,560
uh um

307
00:11:24,880 --> 00:11:31,680
music proof system uh

308
00:11:28,560 --> 00:11:32,880
right we're going to by we're going to

309
00:11:31,680 --> 00:11:35,040
swap this proof

310
00:11:32,880 --> 00:11:36,800
this ice proof for a simulated proof

311
00:11:35,040 --> 00:11:39,519
right and this will this will reduce

312
00:11:36,800 --> 00:11:41,359
to the zero knowledge property uh the

313
00:11:39,519 --> 00:11:43,200
reduction will simply generate all of

314
00:11:41,360 --> 00:11:46,240
these surrounding proofs run the

315
00:11:43,200 --> 00:11:51,360
the distinguisher to break the

316
00:11:46,240 --> 00:11:54,240
underlying music zero knowledge property

317
00:11:51,360 --> 00:11:57,120
and the argument for

318
00:11:54,240 --> 00:11:59,600
indistinguishability to go to move to

319
00:11:57,120 --> 00:12:00,240
from the simulated proof to uh proof

320
00:11:59,600 --> 00:12:04,079
generated

321
00:12:00,240 --> 00:12:07,600
using witness 2 is is identical

322
00:12:04,079 --> 00:12:11,439
okay so one thing to note here

323
00:12:07,600 --> 00:12:15,760
though is because soundness is

324
00:12:11,440 --> 00:12:18,880
uh statistical if we want uh

325
00:12:15,760 --> 00:12:20,639
uh zaps for np we want this

326
00:12:18,880 --> 00:12:21,519
transformation to hold for np and we

327
00:12:20,639 --> 00:12:23,040
don't want to cause some sort of

328
00:12:21,519 --> 00:12:26,000
collapse it's sort of critical

329
00:12:23,040 --> 00:12:27,120
that this indistinguishability argument

330
00:12:26,000 --> 00:12:31,040
is

331
00:12:27,120 --> 00:12:32,079
uh computational so this reduction

332
00:12:31,040 --> 00:12:33,279
if we're going to follow some sort of

333
00:12:32,079 --> 00:12:35,040
production framework it's like very

334
00:12:33,279 --> 00:12:36,959
important that this reduction is

335
00:12:35,040 --> 00:12:40,560
efficient

336
00:12:36,959 --> 00:12:45,119
and the problem with applying this

337
00:12:40,560 --> 00:12:47,920
to an inefficient approver

338
00:12:45,120 --> 00:12:48,800
is that generating these surrounding

339
00:12:47,920 --> 00:12:51,279
proofs

340
00:12:48,800 --> 00:12:52,000
to feed to the reduction is simply too

341
00:12:51,279 --> 00:12:54,639
expensive because

342
00:12:52,000 --> 00:12:55,279
the prover we don't have time to sample

343
00:12:54,639 --> 00:12:58,399
the

344
00:12:55,279 --> 00:13:01,439
the proofs ourselves okay

345
00:12:58,399 --> 00:13:02,240
so how can we get around this so one

346
00:13:01,440 --> 00:13:03,680
thing

347
00:13:02,240 --> 00:13:07,440
the first thing to sort of think about

348
00:13:03,680 --> 00:13:09,680
might be to sort of hard code

349
00:13:07,440 --> 00:13:11,200
these sample these proofs and sort of

350
00:13:09,680 --> 00:13:14,319
some pre-pressing phase

351
00:13:11,200 --> 00:13:17,440
and hard-code them into

352
00:13:14,320 --> 00:13:21,839
uh distinguisher into our uh sort of

353
00:13:17,440 --> 00:13:21,839
distinguisher for the hybrids

354
00:13:22,320 --> 00:13:25,920
so um given that this is the first

355
00:13:24,160 --> 00:13:28,079
attempt what goes wrong

356
00:13:25,920 --> 00:13:29,360
what goes wrong here so let's look at

357
00:13:28,079 --> 00:13:32,319
our the reduction

358
00:13:29,360 --> 00:13:33,279
from or that's right so sort of the

359
00:13:32,320 --> 00:13:36,639
first step we're going to

360
00:13:33,279 --> 00:13:38,800
sort of invoke the the distinguished

361
00:13:36,639 --> 00:13:40,720
verifier distinguisher or whatever

362
00:13:38,800 --> 00:13:42,800
to get these r1 through rm you can think

363
00:13:40,720 --> 00:13:45,920
of this as sort of a worst case choice

364
00:13:42,800 --> 00:13:49,120
and the then we're going to choose

365
00:13:45,920 --> 00:13:53,519
set in the for the prover

366
00:13:49,120 --> 00:13:56,880
we're going to set s to be uh

367
00:13:53,519 --> 00:13:59,440
ri xor with urs so urs is the

368
00:13:56,880 --> 00:14:00,160
is the uniform random string given to us

369
00:13:59,440 --> 00:14:03,279
by this

370
00:14:00,160 --> 00:14:05,519
uh nizik zero knowledge game security

371
00:14:03,279 --> 00:14:05,519
game

372
00:14:07,360 --> 00:14:11,760
next we're going to set the jth urs to

373
00:14:10,720 --> 00:14:17,120
be

374
00:14:11,760 --> 00:14:18,959
s xord with rj

375
00:14:17,120 --> 00:14:20,160
and finally we're going to generate

376
00:14:18,959 --> 00:14:24,160
these uh

377
00:14:20,160 --> 00:14:25,199
proofs right so what is the what is the

378
00:14:24,160 --> 00:14:29,839
issue here

379
00:14:25,199 --> 00:14:31,680
uh if we if we hard coded

380
00:14:29,839 --> 00:14:32,959
these if we wanted to hard code these

381
00:14:31,680 --> 00:14:36,000
proofs to begin with

382
00:14:32,959 --> 00:14:38,160
the thing is uh right

383
00:14:36,000 --> 00:14:39,199
the these the way that we sampled these

384
00:14:38,160 --> 00:14:42,480
urs is it

385
00:14:39,199 --> 00:14:46,079
depends very critically on the urs that

386
00:14:42,480 --> 00:14:46,079
were given from the security game

387
00:14:46,399 --> 00:14:52,399
so we don't uh know ahead of time

388
00:14:49,680 --> 00:14:54,160
uh how to choose them and right this

389
00:14:52,399 --> 00:14:57,120
sort of issue here is that they're

390
00:14:54,160 --> 00:14:57,839
they're potentially uh or if as soon as

391
00:14:57,120 --> 00:15:00,880
you fix this

392
00:14:57,839 --> 00:15:04,480
ri they are very very correlated

393
00:15:00,880 --> 00:15:08,000
um so how can we get around this uh

394
00:15:04,480 --> 00:15:10,839
well we dig up an old idea for

395
00:15:08,000 --> 00:15:12,000
sort of breaking these sort of

396
00:15:10,839 --> 00:15:15,760
correlations

397
00:15:12,000 --> 00:15:18,079
from the 80s so nissan and richardson

398
00:15:15,760 --> 00:15:18,800
um encountered a similar problem while

399
00:15:18,079 --> 00:15:20,479
trying to build

400
00:15:18,800 --> 00:15:21,839
uh pseudo-random generators and the way

401
00:15:20,480 --> 00:15:23,920
they solved it was using

402
00:15:21,839 --> 00:15:25,440
combinatorial designs so what is it this

403
00:15:23,920 --> 00:15:28,719
thing so you have these

404
00:15:25,440 --> 00:15:31,759
m subsets of integers from 1

405
00:15:28,720 --> 00:15:36,720
to l such

406
00:15:31,759 --> 00:15:36,720
that each subset is a fixed size n

407
00:15:37,040 --> 00:15:44,719
and for any two distinct subsets

408
00:15:41,680 --> 00:15:47,920
their intersection is very small

409
00:15:44,720 --> 00:15:51,120
so think of c as three

410
00:15:47,920 --> 00:15:53,360
for for for our purposes

411
00:15:51,120 --> 00:15:55,360
so right as you see in this picture

412
00:15:53,360 --> 00:15:56,959
right we have two subsets that are large

413
00:15:55,360 --> 00:15:59,279
and they have very very small

414
00:15:56,959 --> 00:16:02,319
intersection um

415
00:15:59,279 --> 00:16:06,240
and they showed that

416
00:16:02,320 --> 00:16:09,040
uh constructions of these objects for um

417
00:16:06,240 --> 00:16:11,120
yeah basically any c where l is order n

418
00:16:09,040 --> 00:16:14,880
squared

419
00:16:11,120 --> 00:16:17,519
um and

420
00:16:14,880 --> 00:16:18,320
the way to if you want to hint as to how

421
00:16:17,519 --> 00:16:21,759
to do this

422
00:16:18,320 --> 00:16:25,199
consider uh low degree polynomials

423
00:16:21,759 --> 00:16:29,440
the bottom of the slide so how do we

424
00:16:25,199 --> 00:16:33,199
use this design nissan vectors in design

425
00:16:29,440 --> 00:16:36,480
so uh let's recall our construction

426
00:16:33,199 --> 00:16:37,758
from before so we're going to use these

427
00:16:36,480 --> 00:16:41,839
designs

428
00:16:37,759 --> 00:16:44,399
to to break the correlations on the urs

429
00:16:41,839 --> 00:16:45,040
so we're going to instead of using s

430
00:16:44,399 --> 00:16:47,680
directly

431
00:16:45,040 --> 00:16:48,719
to generate the ice uniform random

432
00:16:47,680 --> 00:16:52,079
string we're going to

433
00:16:48,720 --> 00:16:55,680
sample the bits corresponding to

434
00:16:52,079 --> 00:16:58,560
ti the i set in this uh design

435
00:16:55,680 --> 00:16:59,839
so you get so s is going to be slightly

436
00:16:58,560 --> 00:17:01,599
longer than before

437
00:16:59,839 --> 00:17:04,079
and we're going to take some of the bits

438
00:17:01,600 --> 00:17:05,760
and xor this with the ice random string

439
00:17:04,079 --> 00:17:07,198
that the verifier sent us

440
00:17:05,760 --> 00:17:09,359
and everything else would proceed

441
00:17:07,199 --> 00:17:14,079
identically and the point being here

442
00:17:09,359 --> 00:17:15,760
so now if we look at the ursj versus usi

443
00:17:14,079 --> 00:17:18,399
there's very little dependence between

444
00:17:15,760 --> 00:17:21,520
them uh

445
00:17:18,400 --> 00:17:23,039
if all of like say you fix our ri and rj

446
00:17:21,520 --> 00:17:25,439
right and all the freedom we have is

447
00:17:23,039 --> 00:17:28,480
over s then there's like only a few

448
00:17:25,439 --> 00:17:29,760
uh a few bits in common so three if c is

449
00:17:28,480 --> 00:17:32,640
three

450
00:17:29,760 --> 00:17:33,520
so completeness is preserved if we do

451
00:17:32,640 --> 00:17:35,600
this

452
00:17:33,520 --> 00:17:36,720
and critically soundness doesn't change

453
00:17:35,600 --> 00:17:39,520
by a lot so the s

454
00:17:36,720 --> 00:17:40,799
is slightly longer so we have a slightly

455
00:17:39,520 --> 00:17:44,960
larger

456
00:17:40,799 --> 00:17:49,440
union bound but

457
00:17:44,960 --> 00:17:52,880
as long as c is you know say three then

458
00:17:49,440 --> 00:17:54,480
uh you get uh that something uh

459
00:17:52,880 --> 00:17:57,840
that's uh you can bound this with

460
00:17:54,480 --> 00:17:57,840
something exponential in n

461
00:17:58,400 --> 00:18:02,960
okay so uh right

462
00:18:01,440 --> 00:18:05,840
so let's check witness and

463
00:18:02,960 --> 00:18:05,840
distinguishability

464
00:18:06,320 --> 00:18:09,200
so at a high level what we're going to

465
00:18:07,679 --> 00:18:11,440
want what we're doing is our reduction

466
00:18:09,200 --> 00:18:12,240
is going to end up being ultimately a

467
00:18:11,440 --> 00:18:14,880
distribution

468
00:18:12,240 --> 00:18:16,880
over circuits but we'll sort of view the

469
00:18:14,880 --> 00:18:20,240
sampling this distribution

470
00:18:16,880 --> 00:18:24,880
uh as a preprocessing step for

471
00:18:20,240 --> 00:18:24,880
the sake of clarity so the the

472
00:18:24,960 --> 00:18:28,240
so what we're going to do is we're going

473
00:18:25,840 --> 00:18:31,199
to get our r1 through rm from

474
00:18:28,240 --> 00:18:31,760
the distinguisher we're going to sample

475
00:18:31,200 --> 00:18:34,400
our s

476
00:18:31,760 --> 00:18:35,679
all the bits of s that aren't that don't

477
00:18:34,400 --> 00:18:37,840
correspond to the i

478
00:18:35,679 --> 00:18:40,840
subset from the design okay we're going

479
00:18:37,840 --> 00:18:44,240
to sample those uniformly

480
00:18:40,840 --> 00:18:47,439
and we're going to for each

481
00:18:44,240 --> 00:18:49,760
j not equal to i and every

482
00:18:47,440 --> 00:18:50,960
setting of the bits that we didn't

483
00:18:49,760 --> 00:18:54,799
already set

484
00:18:50,960 --> 00:18:58,080
so right all the bits in an i t i

485
00:18:54,799 --> 00:18:58,879
uh we're going to so for each right this

486
00:18:58,080 --> 00:19:00,399
is going to give us

487
00:18:58,880 --> 00:19:02,880
essentially right there's the most c of

488
00:19:00,400 --> 00:19:05,760
these bits so we have

489
00:19:02,880 --> 00:19:07,200
uh at most two to the c settings of them

490
00:19:05,760 --> 00:19:08,640
and so for each of these

491
00:19:07,200 --> 00:19:11,840
uniform random strings we're going to

492
00:19:08,640 --> 00:19:14,320
sample a proof for the statement

493
00:19:11,840 --> 00:19:16,320
okay and we're going to hard code this

494
00:19:14,320 --> 00:19:18,639
whole thing as a lookup table

495
00:19:16,320 --> 00:19:21,439
into our reduction so right the lookup

496
00:19:18,640 --> 00:19:24,160
table is of size 2 to the c

497
00:19:21,440 --> 00:19:26,240
so the reduction is not significantly

498
00:19:24,160 --> 00:19:30,320
bigger if c is a constant

499
00:19:26,240 --> 00:19:33,440
okay so now uh what do we do online

500
00:19:30,320 --> 00:19:35,760
so right on input pi urs

501
00:19:33,440 --> 00:19:36,880
from this music security game we simply

502
00:19:35,760 --> 00:19:40,640
uh set

503
00:19:36,880 --> 00:19:43,840
uh the ice uh

504
00:19:40,640 --> 00:19:47,679
s i the the the ice

505
00:19:43,840 --> 00:19:48,399
urs uh as as before uh you but using

506
00:19:47,679 --> 00:19:50,400
this design

507
00:19:48,400 --> 00:19:52,160
and to evaluate all the lookup tables to

508
00:19:50,400 --> 00:19:54,000
get the correct

509
00:19:52,160 --> 00:19:56,400
the proofs that are correctly

510
00:19:54,000 --> 00:19:58,960
distributed

511
00:19:56,400 --> 00:20:01,120
and finally we continue running the rest

512
00:19:58,960 --> 00:20:03,600
of the distinguisher

513
00:20:01,120 --> 00:20:05,039
and that completes the proof so right

514
00:20:03,600 --> 00:20:06,399
this is what we saw we saw this

515
00:20:05,039 --> 00:20:08,158
transformation

516
00:20:06,400 --> 00:20:09,960
this simple transformation using this

517
00:20:08,159 --> 00:20:13,280
old idea from

518
00:20:09,960 --> 00:20:14,720
de-randomization and it sort of gives us

519
00:20:13,280 --> 00:20:17,840
a tight way of preserving

520
00:20:14,720 --> 00:20:21,679
uh running time approval running time in

521
00:20:17,840 --> 00:20:23,120
uh this uh related transformation to

522
00:20:21,679 --> 00:20:24,480
that of dwark and or

523
00:20:23,120 --> 00:20:26,158
and this immediately gives us this

524
00:20:24,480 --> 00:20:29,760
one-way permutations from

525
00:20:26,159 --> 00:20:32,559
uh zaps from one-way permutations so

526
00:20:29,760 --> 00:20:33,039
it may be though that maybe you find

527
00:20:32,559 --> 00:20:35,678
this

528
00:20:33,039 --> 00:20:38,000
idea of agreeing proven verifier

529
00:20:35,679 --> 00:20:38,480
agreeing on a uniform random string is

530
00:20:38,000 --> 00:20:40,320
already

531
00:20:38,480 --> 00:20:42,480
like too much to assume so can we get

532
00:20:40,320 --> 00:20:44,480
away without any setup so

533
00:20:42,480 --> 00:20:46,320
if we want zero knowledge we know that

534
00:20:44,480 --> 00:20:48,799
this is not possible

535
00:20:46,320 --> 00:20:50,158
but there are sort of relaxations for

536
00:20:48,799 --> 00:20:52,799
which you don't need

537
00:20:50,159 --> 00:20:53,600
uh public randomness and sort of where

538
00:20:52,799 --> 00:20:55,440
you can

539
00:20:53,600 --> 00:20:56,879
which are achievable in the plain model

540
00:20:55,440 --> 00:21:00,240
so one

541
00:20:56,880 --> 00:21:01,840
relaxation is one message zero knowledge

542
00:21:00,240 --> 00:21:04,320
from barack and pause

543
00:21:01,840 --> 00:21:06,240
so here right you approver sends a

544
00:21:04,320 --> 00:21:10,240
message the verifier doesn't speak

545
00:21:06,240 --> 00:21:10,240
and there's no um

546
00:21:11,840 --> 00:21:17,840
public randomness but so instead of

547
00:21:14,720 --> 00:21:17,840
achieving uh

548
00:21:18,000 --> 00:21:23,440
soundness uh against arbitrary cheating

549
00:21:21,200 --> 00:21:24,240
prover strategies instead we just

550
00:21:23,440 --> 00:21:26,080
guarantee

551
00:21:24,240 --> 00:21:27,360
uniform soundness so what this says is

552
00:21:26,080 --> 00:21:28,480
that if the statement isn't true then

553
00:21:27,360 --> 00:21:30,559
the verifier will eject

554
00:21:28,480 --> 00:21:32,159
when interacting with any uniform

555
00:21:30,559 --> 00:21:35,280
sub-exponential time

556
00:21:32,159 --> 00:21:38,000
uh prover and

557
00:21:35,280 --> 00:21:40,639
another relaxation is non-interactive

558
00:21:38,000 --> 00:21:42,880
witness and distinguishability or newly

559
00:21:40,640 --> 00:21:44,400
so here it's just witness

560
00:21:42,880 --> 00:21:46,240
indistinguishability

561
00:21:44,400 --> 00:21:47,840
uh exactly like the zap except now the

562
00:21:46,240 --> 00:21:50,960
verifier doesn't send a message

563
00:21:47,840 --> 00:21:54,720
uh to begin with

564
00:21:50,960 --> 00:21:58,400
um and this is due to brock on data

565
00:21:54,720 --> 00:22:00,000
and so two sort of uh

566
00:21:58,400 --> 00:22:02,159
applications of our technique by sort of

567
00:22:00,000 --> 00:22:04,880
modifying uh brock on buttons

568
00:22:02,159 --> 00:22:06,000
uh framework uh tweaking it a little bit

569
00:22:04,880 --> 00:22:09,600
to hold for this

570
00:22:06,000 --> 00:22:11,679
our setting um we get uh

571
00:22:09,600 --> 00:22:13,199
from one-way permutations and hitting

572
00:22:11,679 --> 00:22:16,000
set generators

573
00:22:13,200 --> 00:22:17,520
for co-non-deterministic circuits i'm

574
00:22:16,000 --> 00:22:19,039
not going to describe what those are

575
00:22:17,520 --> 00:22:19,679
here but you can look at our paper for

576
00:22:19,039 --> 00:22:21,919
details

577
00:22:19,679 --> 00:22:23,840
we get me we for np with sub-exponential

578
00:22:21,919 --> 00:22:27,760
time perverse

579
00:22:23,840 --> 00:22:30,959
and similarly if we also add to this

580
00:22:27,760 --> 00:22:33,360
uh some exponentially secure uniform

581
00:22:30,960 --> 00:22:34,400
collision-resistant hash functions we

582
00:22:33,360 --> 00:22:38,240
get one message

583
00:22:34,400 --> 00:22:41,200
uh mizix where the simulator

584
00:22:38,240 --> 00:22:42,159
is efficient after a pre-processing step

585
00:22:41,200 --> 00:22:44,320
which

586
00:22:42,159 --> 00:22:46,559
so after the pre-processing is

587
00:22:44,320 --> 00:22:48,000
independent of the statement

588
00:22:46,559 --> 00:22:49,678
but it's not in sort of a standard

589
00:22:48,000 --> 00:22:51,280
setting okay but

590
00:22:49,679 --> 00:22:53,360
briefly i'd like to tell you in the one

591
00:22:51,280 --> 00:22:54,799
minute remaining about this notion of

592
00:22:53,360 --> 00:22:56,080
finding grain zero knowledge and our

593
00:22:54,799 --> 00:22:57,200
results there so in the classic

594
00:22:56,080 --> 00:23:00,720
formalization

595
00:22:57,200 --> 00:23:04,080
of uh the verifier learning nothing

596
00:23:00,720 --> 00:23:07,280
right if you have it start with any ppt

597
00:23:04,080 --> 00:23:09,120
verifier then the transcript uh

598
00:23:07,280 --> 00:23:10,960
generated by the prover interacting with

599
00:23:09,120 --> 00:23:12,320
this verifier should be simulatable in

600
00:23:10,960 --> 00:23:16,880
polytime

601
00:23:12,320 --> 00:23:16,879
so and for our notion of fine grains

602
00:23:17,280 --> 00:23:20,639
zero knowledge right we're just going to

603
00:23:18,559 --> 00:23:23,918
replace any occurrence of ppt

604
00:23:20,640 --> 00:23:27,440
with some complexity class c so if

605
00:23:23,919 --> 00:23:28,400
uh c complexity c verifier should be

606
00:23:27,440 --> 00:23:31,520
simulated on

607
00:23:28,400 --> 00:23:34,640
time in in this complexity class c

608
00:23:31,520 --> 00:23:37,600
and simulatable means so it's the

609
00:23:34,640 --> 00:23:40,080
transcript is indistinguishable to see

610
00:23:37,600 --> 00:23:43,678
the algorithm procedures in c

611
00:23:40,080 --> 00:23:45,439
and we extend this also to

612
00:23:43,679 --> 00:23:47,440
witness and distinguishability and as a

613
00:23:45,440 --> 00:23:50,640
running example what we are considering

614
00:23:47,440 --> 00:23:52,720
is c equal to nc 1

615
00:23:50,640 --> 00:23:55,200
or log depth circuits over a standard

616
00:23:52,720 --> 00:23:57,679
basis and we allow them to be randomized

617
00:23:55,200 --> 00:23:59,919
and results here we get using this from

618
00:23:57,679 --> 00:24:04,559
this worst case assumption

619
00:23:59,919 --> 00:24:09,200
of parity l poly not contain uh

620
00:24:04,559 --> 00:24:12,080
not contained in nc1 we get uh

621
00:24:09,200 --> 00:24:14,159
nc1 fine grain musics in this sense that

622
00:24:12,080 --> 00:24:16,879
i described earlier

623
00:24:14,159 --> 00:24:18,240
the uniform random string model for np

624
00:24:16,880 --> 00:24:21,200
zaps for np

625
00:24:18,240 --> 00:24:21,919
in this for nc one fine grain sense as

626
00:24:21,200 --> 00:24:23,520
well

627
00:24:21,919 --> 00:24:25,520
if we add hitting set generators for

628
00:24:23,520 --> 00:24:28,480
codon deterministic circuits

629
00:24:25,520 --> 00:24:30,720
we get fine-grained non-interactive

630
00:24:28,480 --> 00:24:32,559
witness and distinguishability

631
00:24:30,720 --> 00:24:34,960
and finally if we also add uniform

632
00:24:32,559 --> 00:24:38,000
collision resistant hash functions

633
00:24:34,960 --> 00:24:41,360
we get one minute message

634
00:24:38,000 --> 00:24:42,799
nc1 fine-grained music for np right the

635
00:24:41,360 --> 00:24:45,840
key thing here is that

636
00:24:42,799 --> 00:24:47,520
inefficient relative to nc1

637
00:24:45,840 --> 00:24:48,879
is different from inefficient relative

638
00:24:47,520 --> 00:24:51,600
to ppt so

639
00:24:48,880 --> 00:24:53,200
all of our provers are actually polytime

640
00:24:51,600 --> 00:24:56,959
they're just not as efficient

641
00:24:53,200 --> 00:25:01,840
as the verifiers

642
00:24:56,960 --> 00:25:01,840
and that's all thank you

