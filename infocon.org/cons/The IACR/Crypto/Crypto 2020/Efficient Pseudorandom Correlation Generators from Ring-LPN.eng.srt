1
00:00:00,960 --> 00:00:04,640
i'm peter schull and this is my talk on

2
00:00:03,120 --> 00:00:06,720
efficient pseudo-random correlation

3
00:00:04,640 --> 00:00:08,480
generators from rig lpm

4
00:00:06,720 --> 00:00:10,480
this is joint work with my co-authors

5
00:00:08,480 --> 00:00:14,000
ellette boyle jeffoy kutto

6
00:00:10,480 --> 00:00:16,000
neve gobar evalishai and lisa cole

7
00:00:14,000 --> 00:00:18,080
the main motivation for this work is

8
00:00:16,000 --> 00:00:20,000
towards secure multi-party computation

9
00:00:18,080 --> 00:00:22,159
in the pre-processing model

10
00:00:20,000 --> 00:00:23,359
in this model the parties involved here

11
00:00:22,160 --> 00:00:24,720
alice and bob

12
00:00:23,359 --> 00:00:26,880
are given access to a source of

13
00:00:24,720 --> 00:00:30,240
correlated randomness generated in a

14
00:00:26,880 --> 00:00:32,800
pre-processing phase by a trusted dealer

15
00:00:30,240 --> 00:00:34,480
then in an online phase the parties take

16
00:00:32,800 --> 00:00:36,320
the correlated randomness together with

17
00:00:34,480 --> 00:00:38,718
their inputs x and y

18
00:00:36,320 --> 00:00:39,440
and exchange some messages to evaluate

19
00:00:38,719 --> 00:00:43,360
the function

20
00:00:39,440 --> 00:00:45,120
f on their inputs the main advantages of

21
00:00:43,360 --> 00:00:46,559
using correlated randomness

22
00:00:45,120 --> 00:00:48,320
are that the online phase can be

23
00:00:46,559 --> 00:00:51,199
information theoretically secure

24
00:00:48,320 --> 00:00:52,559
and also very efficient in fact the

25
00:00:51,199 --> 00:00:55,039
overhead of this protocol

26
00:00:52,559 --> 00:00:56,320
is just a small constant factor on top

27
00:00:55,039 --> 00:00:58,000
of evaluating

28
00:00:56,320 --> 00:00:59,840
and sending a circuit description of the

29
00:00:58,000 --> 00:01:01,680
function in the clear

30
00:00:59,840 --> 00:01:03,199
however the main drawback of this

31
00:01:01,680 --> 00:01:05,360
approach is that to generate the

32
00:01:03,199 --> 00:01:07,119
correlated randomness in a secure way

33
00:01:05,360 --> 00:01:09,280
the parties have to run an interactive

34
00:01:07,119 --> 00:01:10,159
protocol and this pre-processing

35
00:01:09,280 --> 00:01:12,159
protocol

36
00:01:10,159 --> 00:01:13,600
is what typically dominates the overall

37
00:01:12,159 --> 00:01:17,119
secure computation cost

38
00:01:13,600 --> 00:01:18,000
in practice a pseudo-random correlation

39
00:01:17,119 --> 00:01:20,720
generator

40
00:01:18,000 --> 00:01:22,640
or pcg is a tool that can potentially

41
00:01:20,720 --> 00:01:24,798
avoid this expensive pre-processing

42
00:01:22,640 --> 00:01:28,040
phase and secure computation

43
00:01:24,799 --> 00:01:31,600
pcg is defined for a target correlation

44
00:01:28,040 --> 00:01:33,759
r0r1 which might be for example

45
00:01:31,600 --> 00:01:35,039
a set of many oblivious transfers on

46
00:01:33,759 --> 00:01:36,799
random strings

47
00:01:35,040 --> 00:01:38,079
or a large amount of multiplication

48
00:01:36,799 --> 00:01:41,040
triples

49
00:01:38,079 --> 00:01:41,759
the pcg also consists of two algorithms

50
00:01:41,040 --> 00:01:43,840
firstly

51
00:01:41,759 --> 00:01:45,680
a seed generation algorithm which

52
00:01:43,840 --> 00:01:48,720
outputs a pair k 0 k

53
00:01:45,680 --> 00:01:50,240
1 of correlated seeds together with an

54
00:01:48,720 --> 00:01:52,399
expansion algorithm

55
00:01:50,240 --> 00:01:53,920
which takes one of the seeds and locally

56
00:01:52,399 --> 00:01:55,759
expands it to produce a large

57
00:01:53,920 --> 00:01:57,680
pseudorandom output

58
00:01:55,759 --> 00:02:00,079
there's a correctness requirement which

59
00:01:57,680 --> 00:02:01,680
says that two expanded outputs

60
00:02:00,079 --> 00:02:04,000
should be indistinguishable from an

61
00:02:01,680 --> 00:02:06,079
actual sample from the correlation

62
00:02:04,000 --> 00:02:08,000
secondly the security requirement says

63
00:02:06,079 --> 00:02:11,038
that even if i'm given one of the seeds

64
00:02:08,000 --> 00:02:11,840
say k0 then the other seeds expanded

65
00:02:11,038 --> 00:02:13,440
output

66
00:02:11,840 --> 00:02:14,879
should be indistinguishable from an

67
00:02:13,440 --> 00:02:17,200
output of the correlation

68
00:02:14,879 --> 00:02:20,160
sampled conditioned on the expanded

69
00:02:17,200 --> 00:02:22,560
output from seed k0

70
00:02:20,160 --> 00:02:23,840
given a pcg to produce some correlated

71
00:02:22,560 --> 00:02:26,239
randomness

72
00:02:23,840 --> 00:02:26,959
all we need now is a secure setup

73
00:02:26,239 --> 00:02:29,280
protocol

74
00:02:26,959 --> 00:02:31,760
that's actually generating the pcg seeds

75
00:02:29,280 --> 00:02:33,840
without a trusted third party

76
00:02:31,760 --> 00:02:35,840
putting these things together we obtain

77
00:02:33,840 --> 00:02:38,720
a secure computation protocol with what

78
00:02:35,840 --> 00:02:40,800
we call a silent pre-processing phase

79
00:02:38,720 --> 00:02:42,720
here we just have a small setup protocol

80
00:02:40,800 --> 00:02:44,959
to generate the short seeds

81
00:02:42,720 --> 00:02:45,840
followed by silent and completely local

82
00:02:44,959 --> 00:02:47,599
expansion

83
00:02:45,840 --> 00:02:50,720
to produce the correlated randomness

84
00:02:47,599 --> 00:02:52,799
used in the protocol several previous

85
00:02:50,720 --> 00:02:55,519
works have constructed pcgs

86
00:02:52,800 --> 00:02:56,239
for useful classes of correlations for

87
00:02:55,519 --> 00:02:58,080
instance

88
00:02:56,239 --> 00:03:00,640
from learning with errors we can

89
00:02:58,080 --> 00:03:02,319
construct a pcg for arbitrary additively

90
00:03:00,640 --> 00:03:05,359
secret shed correlations

91
00:03:02,319 --> 00:03:06,799
using homomorphic secret sharing however

92
00:03:05,360 --> 00:03:08,959
this is based on fully homomorphed

93
00:03:06,800 --> 00:03:10,239
encryption and is computationally very

94
00:03:08,959 --> 00:03:12,000
expensive

95
00:03:10,239 --> 00:03:13,680
there are also recent constructions

96
00:03:12,000 --> 00:03:14,480
based on the learning parity with noise

97
00:03:13,680 --> 00:03:17,200
assumption

98
00:03:14,480 --> 00:03:18,319
instead of lwe these can be used for

99
00:03:17,200 --> 00:03:19,920
simple correlations

100
00:03:18,319 --> 00:03:22,319
like vector oblivious linear function

101
00:03:19,920 --> 00:03:23,839
evaluation and oblivious transfer

102
00:03:22,319 --> 00:03:25,760
and these constructions have been shown

103
00:03:23,840 --> 00:03:27,040
to have good concrete efficiency

104
00:03:25,760 --> 00:03:28,640
in some recent works which have

105
00:03:27,040 --> 00:03:30,560
optimized them and presented

106
00:03:28,640 --> 00:03:32,958
implementations

107
00:03:30,560 --> 00:03:34,799
lpn can also be used to construct more

108
00:03:32,959 --> 00:03:36,319
complex correlations like oblivious

109
00:03:34,799 --> 00:03:38,319
linear function evaluation

110
00:03:36,319 --> 00:03:39,920
multiplication triples and even higher

111
00:03:38,319 --> 00:03:41,760
degree correlations

112
00:03:39,920 --> 00:03:43,760
unfortunately these constructions are

113
00:03:41,760 --> 00:03:45,518
not practical since they have at least a

114
00:03:43,760 --> 00:03:47,359
quadratic computational cost

115
00:03:45,519 --> 00:03:49,519
in n where n is the length of the

116
00:03:47,360 --> 00:03:51,440
expanded correlated output

117
00:03:49,519 --> 00:03:52,799
there are also older constructions of

118
00:03:51,440 --> 00:03:54,959
pcgs for simple

119
00:03:52,799 --> 00:03:56,879
linear classes of correlations such as

120
00:03:54,959 --> 00:03:58,720
pseudo-random secret sharing

121
00:03:56,879 --> 00:04:01,679
as well as a construction for one-time

122
00:03:58,720 --> 00:04:04,080
truth tables from the paper last year

123
00:04:01,680 --> 00:04:06,159
the main contributions of this work are

124
00:04:04,080 --> 00:04:08,000
to construct efficient pcgs

125
00:04:06,159 --> 00:04:09,280
for correlations like oblivious linear

126
00:04:08,000 --> 00:04:11,519
function evaluation

127
00:04:09,280 --> 00:04:14,720
and multiplication triples based on the

128
00:04:11,519 --> 00:04:16,239
ring lpn assumption these constructions

129
00:04:14,720 --> 00:04:19,279
can silently expand

130
00:04:16,238 --> 00:04:22,078
n o less or triples in quasiline in n

131
00:04:19,279 --> 00:04:23,758
runtime improving upon the quadratic

132
00:04:22,079 --> 00:04:25,280
cost of the previous lpn based

133
00:04:23,759 --> 00:04:27,120
constructions

134
00:04:25,280 --> 00:04:29,679
we also present several extensions at

135
00:04:27,120 --> 00:04:32,080
variants for authenticated triples

136
00:04:29,680 --> 00:04:34,720
multi-party triples and other bilinear

137
00:04:32,080 --> 00:04:36,800
correlations such as matrix triples

138
00:04:34,720 --> 00:04:38,800
we also present secure protocols for

139
00:04:36,800 --> 00:04:41,600
setting up the seeds of these pcgs

140
00:04:38,800 --> 00:04:44,560
with active security in particular for a

141
00:04:41,600 --> 00:04:46,560
two-party pcg for authenticated triples

142
00:04:44,560 --> 00:04:48,320
this implies a silent pre-processing

143
00:04:46,560 --> 00:04:50,800
protocol for the speeds

144
00:04:48,320 --> 00:04:52,240
multi-party computation protocol this

145
00:04:50,800 --> 00:04:53,360
protocol has very good concrete

146
00:04:52,240 --> 00:04:55,280
efficiency

147
00:04:53,360 --> 00:04:57,120
but the size of each party seed can be

148
00:04:55,280 --> 00:04:58,799
as small as around a megabyte

149
00:04:57,120 --> 00:05:00,960
and the run times for expanding the

150
00:04:58,800 --> 00:05:02,800
seeds are comparable to the times for

151
00:05:00,960 --> 00:05:05,120
generating multi-party triples

152
00:05:02,800 --> 00:05:06,560
using the overdrive protocol which is a

153
00:05:05,120 --> 00:05:09,199
non-silent protocol

154
00:05:06,560 --> 00:05:10,320
based on homomorphic encryption on the

155
00:05:09,199 --> 00:05:11,759
technical side

156
00:05:10,320 --> 00:05:13,599
some of our techniques were actually

157
00:05:11,759 --> 00:05:15,840
inspired by work on fully homomorph

158
00:05:13,600 --> 00:05:18,080
encryption using ring lwe

159
00:05:15,840 --> 00:05:19,758
for instance a method for switching from

160
00:05:18,080 --> 00:05:22,159
lpn to ring lpn

161
00:05:19,759 --> 00:05:23,680
to avoid a quadratic blow up and a

162
00:05:22,160 --> 00:05:26,160
bootstrapping style technique to

163
00:05:23,680 --> 00:05:28,240
optimize superior seed generation

164
00:05:26,160 --> 00:05:30,400
our most efficient constructions also

165
00:05:28,240 --> 00:05:31,039
rely on new arithmetic variants of ring

166
00:05:30,400 --> 00:05:33,679
lpn

167
00:05:31,039 --> 00:05:35,120
over polynomial rings since these hadn't

168
00:05:33,680 --> 00:05:37,280
been studied previously

169
00:05:35,120 --> 00:05:38,800
we also provided new security analysis

170
00:05:37,280 --> 00:05:40,880
to improve our confidence in these

171
00:05:38,800 --> 00:05:43,199
assumptions

172
00:05:40,880 --> 00:05:44,719
our main goal will be to construct pcgs

173
00:05:43,199 --> 00:05:45,680
for the oblivious linear function

174
00:05:44,720 --> 00:05:48,080
evaluation

175
00:05:45,680 --> 00:05:49,600
or ole and multiplication triple

176
00:05:48,080 --> 00:05:51,840
correlations

177
00:05:49,600 --> 00:05:53,440
ole is a two-party functionality between

178
00:05:51,840 --> 00:05:55,679
a sender and a receiver

179
00:05:53,440 --> 00:05:57,199
but the receiver has input x the sender

180
00:05:55,680 --> 00:05:59,840
has input u and v

181
00:05:57,199 --> 00:06:01,440
and the receiver obtains w equals ux

182
00:05:59,840 --> 00:06:02,960
plus v

183
00:06:01,440 --> 00:06:05,120
since we're constructing a correlation

184
00:06:02,960 --> 00:06:06,880
we'll consider a random variant of this

185
00:06:05,120 --> 00:06:08,880
where both parties inputs are sampled

186
00:06:06,880 --> 00:06:10,639
uniformly

187
00:06:08,880 --> 00:06:11,919
the related notion of multiplication

188
00:06:10,639 --> 00:06:14,479
triples is an

189
00:06:11,919 --> 00:06:15,919
n-party correlation which samples random

190
00:06:14,479 --> 00:06:18,080
values a b and c

191
00:06:15,919 --> 00:06:19,680
where c is a times b and then

192
00:06:18,080 --> 00:06:22,800
distributes to each party an

193
00:06:19,680 --> 00:06:25,600
additive sharing of a b and c so

194
00:06:22,800 --> 00:06:27,039
party i gets values a i b i c i where a

195
00:06:25,600 --> 00:06:29,759
is the sum of a i

196
00:06:27,039 --> 00:06:30,639
and so on these two correlations are

197
00:06:29,759 --> 00:06:33,039
related

198
00:06:30,639 --> 00:06:35,360
in the in the two-party setting two

199
00:06:33,039 --> 00:06:38,719
random oles can be locally converted

200
00:06:35,360 --> 00:06:40,319
into a single multiplication triple

201
00:06:38,720 --> 00:06:42,319
and finally we also will consider

202
00:06:40,319 --> 00:06:44,000
authenticated multiplication triples

203
00:06:42,319 --> 00:06:47,360
which are a stronger variant used in

204
00:06:44,000 --> 00:06:50,080
actively secure protocols such as speeds

205
00:06:47,360 --> 00:06:52,000
here as well as a b and c each party

206
00:06:50,080 --> 00:06:54,318
also gets an additive share of these

207
00:06:52,000 --> 00:06:56,479
values multiplied by a random mackey

208
00:06:54,319 --> 00:06:57,360
delta before moving on to the

209
00:06:56,479 --> 00:06:58,960
constructions

210
00:06:57,360 --> 00:07:01,599
i'll introduce distributed point

211
00:06:58,960 --> 00:07:02,080
functions these are a secret shared form

212
00:07:01,599 --> 00:07:04,080
of point

213
00:07:02,080 --> 00:07:05,120
function which is a function

214
00:07:04,080 --> 00:07:07,359
parameterized by

215
00:07:05,120 --> 00:07:08,160
points alpha and beta as well as the

216
00:07:07,360 --> 00:07:11,360
domain size

217
00:07:08,160 --> 00:07:14,319
n and input x and domain

218
00:07:11,360 --> 00:07:15,199
outputs either beta if x is alpha or

219
00:07:14,319 --> 00:07:18,160
otherwise zero

220
00:07:15,199 --> 00:07:19,120
on every other input distributed point

221
00:07:18,160 --> 00:07:21,120
function

222
00:07:19,120 --> 00:07:23,440
consists of a key generation algorithm

223
00:07:21,120 --> 00:07:26,160
which samples two random keys

224
00:07:23,440 --> 00:07:27,120
then an evaluation algorithm which takes

225
00:07:26,160 --> 00:07:29,840
one of the keys

226
00:07:27,120 --> 00:07:31,919
as well as a public input and outputs a

227
00:07:29,840 --> 00:07:34,560
secret sharing of the point function

228
00:07:31,919 --> 00:07:36,159
applied to the input x there are very

229
00:07:34,560 --> 00:07:37,120
efficient constructions of distributed

230
00:07:36,160 --> 00:07:38,560
point functions

231
00:07:37,120 --> 00:07:40,240
based on any length doubling

232
00:07:38,560 --> 00:07:43,599
pseudorandom generator

233
00:07:40,240 --> 00:07:45,280
following a ggm style tree construction

234
00:07:43,599 --> 00:07:47,759
there's also a highly efficient setup

235
00:07:45,280 --> 00:07:49,440
protocol for generating a pair of seeds

236
00:07:47,759 --> 00:07:50,639
for the secret point function in a

237
00:07:49,440 --> 00:07:54,879
distributed manner

238
00:07:50,639 --> 00:07:56,240
by donor and gillette as a warm up

239
00:07:54,879 --> 00:07:58,160
we'll see that a distributed point

240
00:07:56,240 --> 00:07:59,120
function can be used to contain a simple

241
00:07:58,160 --> 00:08:03,120
pcg

242
00:07:59,120 --> 00:08:04,800
to compress a random unit vector

243
00:08:03,120 --> 00:08:06,800
the key generation algorithm simply

244
00:08:04,800 --> 00:08:07,599
samples the distributed point function

245
00:08:06,800 --> 00:08:11,039
keys

246
00:08:07,599 --> 00:08:13,440
for a secret point alpha and beta

247
00:08:11,039 --> 00:08:15,360
and then to expand this to a unit vector

248
00:08:13,440 --> 00:08:16,080
each party simply locally evaluates

249
00:08:15,360 --> 00:08:18,639
their key

250
00:08:16,080 --> 00:08:20,479
at every input x in the domain to obtain

251
00:08:18,639 --> 00:08:22,879
a length n vector

252
00:08:20,479 --> 00:08:24,560
such that when sum together one of these

253
00:08:22,879 --> 00:08:27,840
sums will be non-zero

254
00:08:24,560 --> 00:08:29,199
and the rest will all be 0. we can

255
00:08:27,840 --> 00:08:31,359
easily extend this

256
00:08:29,199 --> 00:08:32,719
from secret sharing a unit vector to any

257
00:08:31,360 --> 00:08:35,919
sparse vector with t

258
00:08:32,719 --> 00:08:38,320
nonzero entries the neve approach

259
00:08:35,919 --> 00:08:39,838
is to take one dpf for every point in

260
00:08:38,320 --> 00:08:41,599
the vector

261
00:08:39,839 --> 00:08:44,000
evaluate these locally and then add up

262
00:08:41,599 --> 00:08:46,160
the resulting shares

263
00:08:44,000 --> 00:08:48,160
we can obtain a more efficient approach

264
00:08:46,160 --> 00:08:49,519
if the sparse vector can be obtained by

265
00:08:48,160 --> 00:08:52,240
concatenating

266
00:08:49,519 --> 00:08:53,920
t smaller vectors of the same length

267
00:08:52,240 --> 00:08:54,640
however this requires some additional

268
00:08:53,920 --> 00:08:56,640
structure

269
00:08:54,640 --> 00:08:59,199
on the positions of the non-zero entries

270
00:08:56,640 --> 00:09:01,279
in the sparse vector

271
00:08:59,200 --> 00:09:02,959
the security of our constructions relies

272
00:09:01,279 --> 00:09:04,880
on arithmetic variants of the learning

273
00:09:02,959 --> 00:09:06,959
parity with noise assumption

274
00:09:04,880 --> 00:09:08,640
in its most basic form the primal

275
00:09:06,959 --> 00:09:11,920
version of lpn

276
00:09:08,640 --> 00:09:14,080
says that given a s plus e where a is a

277
00:09:11,920 --> 00:09:16,719
large random public matrix

278
00:09:14,080 --> 00:09:17,839
s is a secret vector and e is a large

279
00:09:16,720 --> 00:09:19,279
error vector

280
00:09:17,839 --> 00:09:21,680
this is indistinguishable from a

281
00:09:19,279 --> 00:09:24,160
uniformly random vector

282
00:09:21,680 --> 00:09:25,680
but here if we're over a large field e

283
00:09:24,160 --> 00:09:27,920
has a small hamming weight

284
00:09:25,680 --> 00:09:30,160
but the non-zero entries of e are

285
00:09:27,920 --> 00:09:32,319
uniformly random

286
00:09:30,160 --> 00:09:33,439
this is also equivalent to lpn in its

287
00:09:32,320 --> 00:09:34,959
dual version

288
00:09:33,440 --> 00:09:37,440
also known as the syndrome decoding

289
00:09:34,959 --> 00:09:39,359
problem where we don't have a secret s

290
00:09:37,440 --> 00:09:41,120
but the sparse vector e is simply

291
00:09:39,360 --> 00:09:44,560
multiplied by with a public

292
00:09:41,120 --> 00:09:46,480
compressing random matrix h we'll also

293
00:09:44,560 --> 00:09:48,079
consider variants where the matrices a

294
00:09:46,480 --> 00:09:50,399
and h are more structured

295
00:09:48,080 --> 00:09:52,560
instead of being simply uniform and we

296
00:09:50,399 --> 00:09:54,560
could do the same for the error vector e

297
00:09:52,560 --> 00:09:56,959
for example the regular structure on the

298
00:09:54,560 --> 00:09:59,119
previous slide

299
00:09:56,959 --> 00:10:01,040
the starting point for our constructions

300
00:09:59,120 --> 00:10:02,000
is the pcg for the tensor product

301
00:10:01,040 --> 00:10:05,040
correlation

302
00:10:02,000 --> 00:10:06,720
from our paper from crypto last year

303
00:10:05,040 --> 00:10:09,120
here the target correlation we want to

304
00:10:06,720 --> 00:10:10,320
consider is where two parties each have

305
00:10:09,120 --> 00:10:14,240
a random vector

306
00:10:10,320 --> 00:10:16,240
x 0 x 1 as well as an n by n matrix

307
00:10:14,240 --> 00:10:18,160
where these matrices additive secret

308
00:10:16,240 --> 00:10:20,560
shared of the tensor product

309
00:10:18,160 --> 00:10:22,800
of the two vectors where here the tensor

310
00:10:20,560 --> 00:10:26,160
product denotes the n by n matrix

311
00:10:22,800 --> 00:10:28,719
consisting of every pairwise product

312
00:10:26,160 --> 00:10:30,959
note that this construction inherently

313
00:10:28,720 --> 00:10:32,880
has a quadratic computational cost

314
00:10:30,959 --> 00:10:34,479
just to compute the entire output

315
00:10:32,880 --> 00:10:35,760
because of the fact that it's an n by n

316
00:10:34,480 --> 00:10:37,920
matrix

317
00:10:35,760 --> 00:10:39,680
however having a tensor product does

318
00:10:37,920 --> 00:10:42,079
mean that the parties can just take the

319
00:10:39,680 --> 00:10:44,319
n-diagonal entries of these matrices

320
00:10:42,079 --> 00:10:47,920
and these can be locally converted into

321
00:10:44,320 --> 00:10:50,160
n independent instance of ole

322
00:10:47,920 --> 00:10:52,800
the construction from the crypto 2019

323
00:10:50,160 --> 00:10:54,560
paper is based on two main ideas

324
00:10:52,800 --> 00:10:56,240
firstly the fact that tensor product

325
00:10:54,560 --> 00:10:58,239
preserves sparsity

326
00:10:56,240 --> 00:10:59,760
so if we have a tensor product of two

327
00:10:58,240 --> 00:11:01,680
sparse vectors

328
00:10:59,760 --> 00:11:03,360
then the resulting matrix is still

329
00:11:01,680 --> 00:11:04,959
somewhat sparse

330
00:11:03,360 --> 00:11:06,880
in that if the original vectors have t

331
00:11:04,959 --> 00:11:10,079
non-zero entries then the product

332
00:11:06,880 --> 00:11:12,240
has t squared secondly

333
00:11:10,079 --> 00:11:13,359
they use the idea that we can randomize

334
00:11:12,240 --> 00:11:16,399
sparse vectors

335
00:11:13,360 --> 00:11:19,200
using the lpn assumption for example

336
00:11:16,399 --> 00:11:20,880
using dual lpn we can take a secret

337
00:11:19,200 --> 00:11:22,800
shared sparse vector

338
00:11:20,880 --> 00:11:25,439
and then each party can locally multiply

339
00:11:22,800 --> 00:11:27,519
this by the public compressing matrix h

340
00:11:25,440 --> 00:11:29,440
to obtain something that is pseudorandom

341
00:11:27,519 --> 00:11:31,279
under lpn

342
00:11:29,440 --> 00:11:33,680
putting these two things together the

343
00:11:31,279 --> 00:11:35,279
construction looks like this

344
00:11:33,680 --> 00:11:37,120
firstly the generation algorithm will

345
00:11:35,279 --> 00:11:39,279
sample two sparse vectors

346
00:11:37,120 --> 00:11:40,640
e and f and give one of these to each of

347
00:11:39,279 --> 00:11:43,360
the parties

348
00:11:40,640 --> 00:11:46,000
we'll then generate dpf seeds for the

349
00:11:43,360 --> 00:11:49,279
tensor product matrix e tends to f

350
00:11:46,000 --> 00:11:51,360
which has t-squared non-zero entries

351
00:11:49,279 --> 00:11:53,200
in the expansion phase the parties will

352
00:11:51,360 --> 00:11:55,680
evaluate the dpf instances

353
00:11:53,200 --> 00:11:56,320
on the n squared points in the domain to

354
00:11:55,680 --> 00:11:59,120
obtain

355
00:11:56,320 --> 00:11:59,920
matrices r0 and r1 which are secret

356
00:11:59,120 --> 00:12:02,560
sharings

357
00:11:59,920 --> 00:12:04,639
of the tensor product finally to

358
00:12:02,560 --> 00:12:05,279
randomize this into a uniform tensor

359
00:12:04,639 --> 00:12:08,079
product

360
00:12:05,279 --> 00:12:08,800
they will apply the lpn assumption twice

361
00:12:08,079 --> 00:12:10,638
first

362
00:12:08,800 --> 00:12:11,839
multiply the shares on the left by the

363
00:12:10,639 --> 00:12:13,839
matrix h

364
00:12:11,839 --> 00:12:15,839
and secondly multiply on the right by

365
00:12:13,839 --> 00:12:17,519
the transpose of h

366
00:12:15,839 --> 00:12:19,279
you can see that this gives us tensor

367
00:12:17,519 --> 00:12:21,600
product of h e

368
00:12:19,279 --> 00:12:23,519
and hf which is uniformly random under

369
00:12:21,600 --> 00:12:25,360
lpn

370
00:12:23,519 --> 00:12:26,880
the problem with this construction is

371
00:12:25,360 --> 00:12:27,600
that the parties inherently have to

372
00:12:26,880 --> 00:12:30,160
compute an

373
00:12:27,600 --> 00:12:32,560
entire n by n tensor product which is

374
00:12:30,160 --> 00:12:35,519
competentially very expensive

375
00:12:32,560 --> 00:12:36,880
even if they only want to obtain n oles

376
00:12:35,519 --> 00:12:38,079
which would be in the diagonal entries

377
00:12:36,880 --> 00:12:40,399
of this matrix

378
00:12:38,079 --> 00:12:41,680
we don't see a natural way to obtain

379
00:12:40,399 --> 00:12:44,720
these without computing

380
00:12:41,680 --> 00:12:46,719
everything else so the natural question

381
00:12:44,720 --> 00:12:49,760
is perhaps as a way of modifying the

382
00:12:46,720 --> 00:12:51,120
matrix h to rely on a variant of lpn

383
00:12:49,760 --> 00:12:53,519
that would allow us to compute these

384
00:12:51,120 --> 00:12:56,079
diagonal entries directly

385
00:12:53,519 --> 00:12:56,720
a natural first attempt is to try using

386
00:12:56,079 --> 00:12:59,359
a matrix

387
00:12:56,720 --> 00:13:02,480
h consisting of van der waals matrices

388
00:12:59,360 --> 00:13:04,079
based on evaluating polynomials

389
00:13:02,480 --> 00:13:06,880
this does actually allow you to do this

390
00:13:04,079 --> 00:13:08,800
computation efficiently however

391
00:13:06,880 --> 00:13:11,519
unfortunately turns out to be insecure

392
00:13:08,800 --> 00:13:13,279
due to an algebraic attack

393
00:13:11,519 --> 00:13:15,920
however based on a slight variant of

394
00:13:13,279 --> 00:13:17,519
this using the ring lpn assumption over

395
00:13:15,920 --> 00:13:18,719
polynomial rings

396
00:13:17,519 --> 00:13:20,959
turns out we can actually build

397
00:13:18,720 --> 00:13:23,600
something secure

398
00:13:20,959 --> 00:13:24,399
the precise assumption we rely on is

399
00:13:23,600 --> 00:13:26,480
ring lpn

400
00:13:24,399 --> 00:13:28,000
over a polynomial ring which has

401
00:13:26,480 --> 00:13:30,639
polynomials over z p

402
00:13:28,000 --> 00:13:32,480
modulo x to the n plus one where here n

403
00:13:30,639 --> 00:13:33,920
is a power of two

404
00:13:32,480 --> 00:13:36,160
this assumption states that given a

405
00:13:33,920 --> 00:13:36,719
random polynomial a together with a

406
00:13:36,160 --> 00:13:39,360
times e

407
00:13:36,720 --> 00:13:40,959
plus e prime of both e and e prime are

408
00:13:39,360 --> 00:13:43,760
sparse polynomials

409
00:13:40,959 --> 00:13:46,000
this is pseudorandom and most efficient

410
00:13:43,760 --> 00:13:46,880
constructions will also use a reducible

411
00:13:46,000 --> 00:13:48,800
form of this

412
00:13:46,880 --> 00:13:51,439
where x to the n plus 1 actually splits

413
00:13:48,800 --> 00:13:54,319
into linear factors modulo p

414
00:13:51,440 --> 00:13:54,880
this means that rp is isomorphic to zp

415
00:13:54,320 --> 00:13:56,560
to the power

416
00:13:54,880 --> 00:13:59,120
n which means that given a

417
00:13:56,560 --> 00:14:01,439
multiplication triple in rp

418
00:13:59,120 --> 00:14:03,360
this can actually be locally converted

419
00:14:01,440 --> 00:14:06,639
into n independent triples

420
00:14:03,360 --> 00:14:07,360
in zp since the reducible form of ring

421
00:14:06,639 --> 00:14:09,360
lpn

422
00:14:07,360 --> 00:14:11,120
hasn't previously been studied in the

423
00:14:09,360 --> 00:14:12,079
paper we do perform some security

424
00:14:11,120 --> 00:14:13,680
analysis

425
00:14:12,079 --> 00:14:15,519
where we observe that it only appears

426
00:14:13,680 --> 00:14:17,839
slightly weaker than the standard

427
00:14:15,519 --> 00:14:19,519
irreducible form of re-lpn or even

428
00:14:17,839 --> 00:14:20,959
standard lpn

429
00:14:19,519 --> 00:14:23,839
the main attack that you have to watch

430
00:14:20,959 --> 00:14:24,959
out for is that an attacker can exploit

431
00:14:23,839 --> 00:14:27,279
sparse factors

432
00:14:24,959 --> 00:14:29,199
of the polynomial x to the n plus one

433
00:14:27,279 --> 00:14:31,519
when you use these to reduce an instance

434
00:14:29,199 --> 00:14:33,599
down to a smaller dimension

435
00:14:31,519 --> 00:14:35,040
however there's a trade-off here since

436
00:14:33,600 --> 00:14:37,360
reducing the dimension

437
00:14:35,040 --> 00:14:39,120
also increases the noise rate so as long

438
00:14:37,360 --> 00:14:41,920
as we carefully choose the parameters

439
00:14:39,120 --> 00:14:43,040
we can ensure that this is still secure

440
00:14:41,920 --> 00:14:45,760
using ring lpn

441
00:14:43,040 --> 00:14:46,719
instead of lpn the construction of the

442
00:14:45,760 --> 00:14:48,720
pcg

443
00:14:46,720 --> 00:14:51,360
will now use a polynomial product

444
00:14:48,720 --> 00:14:53,519
instead of a tensor product

445
00:14:51,360 --> 00:14:55,760
so the seed generation algorithm will

446
00:14:53,519 --> 00:14:58,959
sample some sparse polynomials e

447
00:14:55,760 --> 00:15:00,079
e prime f f prime and then multiply

448
00:14:58,959 --> 00:15:01,680
every pair of these

449
00:15:00,079 --> 00:15:04,719
so this is just a length two tensor

450
00:15:01,680 --> 00:15:06,160
product over the polynomial ring

451
00:15:04,720 --> 00:15:08,480
note that each of these polynomial

452
00:15:06,160 --> 00:15:09,439
products reduced modular x to the n plus

453
00:15:08,480 --> 00:15:12,160
one

454
00:15:09,440 --> 00:15:13,040
is now another polynomial of length n

455
00:15:12,160 --> 00:15:16,560
with at most t

456
00:15:13,040 --> 00:15:18,719
squared non-zero coefficients

457
00:15:16,560 --> 00:15:20,319
in the expansion phase after obtaining

458
00:15:18,720 --> 00:15:20,959
shares of each of these polynomial

459
00:15:20,320 --> 00:15:23,279
products

460
00:15:20,959 --> 00:15:25,518
we could then randomize them using lpn

461
00:15:23,279 --> 00:15:25,839
by multiplying with a public random polo

462
00:15:25,519 --> 00:15:28,240
mill

463
00:15:25,839 --> 00:15:29,040
a this gives the parties shares of the

464
00:15:28,240 --> 00:15:32,240
product of

465
00:15:29,040 --> 00:15:34,240
ae plus a prime with af plus f

466
00:15:32,240 --> 00:15:36,880
prime since this is linear in the

467
00:15:34,240 --> 00:15:39,920
products of the sparse polynomials

468
00:15:36,880 --> 00:15:42,639
this is pseudorandom under ring lpn and

469
00:15:39,920 --> 00:15:44,880
then can be locally unpacked into zp

470
00:15:42,639 --> 00:15:47,279
to obtain n multiplication triples over

471
00:15:44,880 --> 00:15:47,279
zp

472
00:15:47,360 --> 00:15:52,079
now instead of having o of n squared cos

473
00:15:49,839 --> 00:15:54,880
to produce n triples in zp

474
00:15:52,079 --> 00:15:56,719
we've managed to reduce this concretely

475
00:15:54,880 --> 00:15:59,199
the dpf expansion phase

476
00:15:56,720 --> 00:16:00,480
requires of n times t squared prg

477
00:15:59,199 --> 00:16:02,880
operations

478
00:16:00,480 --> 00:16:03,759
however this can be reduced of nt or

479
00:16:02,880 --> 00:16:06,320
even better

480
00:16:03,759 --> 00:16:08,800
using other techniques and then the

481
00:16:06,320 --> 00:16:11,839
polynomial products require of n log n

482
00:16:08,800 --> 00:16:12,719
arithmetic operations again we have a

483
00:16:11,839 --> 00:16:14,959
seed size

484
00:16:12,720 --> 00:16:15,759
requiring the same as around t squared

485
00:16:14,959 --> 00:16:18,959
dpfs

486
00:16:15,759 --> 00:16:20,959
which is t squared lambda log n bits

487
00:16:18,959 --> 00:16:22,479
one nice thing about this construction

488
00:16:20,959 --> 00:16:24,719
is that we can go from multiplication

489
00:16:22,480 --> 00:16:26,959
triples to authenticated triples

490
00:16:24,720 --> 00:16:29,040
almost for free by simply multiplying

491
00:16:26,959 --> 00:16:30,638
everything with the random mac key

492
00:16:29,040 --> 00:16:32,959
since multiplying by a scalar doesn't

493
00:16:30,639 --> 00:16:34,839
affect sparsity this only has a round of

494
00:16:32,959 --> 00:16:36,000
factor two overhead on the basic

495
00:16:34,839 --> 00:16:37,920
construction

496
00:16:36,000 --> 00:16:39,839
finally in the paper we present several

497
00:16:37,920 --> 00:16:41,599
extensions to the construction

498
00:16:39,839 --> 00:16:43,759
including pcgs for inner product

499
00:16:41,600 --> 00:16:44,639
correlations matrix multiplication

500
00:16:43,759 --> 00:16:47,279
triples

501
00:16:44,639 --> 00:16:49,120
and generalized degree two correlations

502
00:16:47,279 --> 00:16:50,000
and except for the authenticated triples

503
00:16:49,120 --> 00:16:51,519
construction

504
00:16:50,000 --> 00:16:53,839
we can extend all of these to the

505
00:16:51,519 --> 00:16:56,560
multi-party setting

506
00:16:53,839 --> 00:16:58,320
as well as our pcg constructions we give

507
00:16:56,560 --> 00:17:00,319
efficient setup protocols

508
00:16:58,320 --> 00:17:02,240
for generating the pcgc's in a

509
00:17:00,320 --> 00:17:04,799
distributed way

510
00:17:02,240 --> 00:17:07,599
here in our olea triples construction

511
00:17:04,799 --> 00:17:10,079
the main challenge is to set up dpf keys

512
00:17:07,599 --> 00:17:11,119
for a product of two sparse polynomials

513
00:17:10,079 --> 00:17:13,678
in the ring rp

514
00:17:11,119 --> 00:17:15,520
with malicious security the first step

515
00:17:13,679 --> 00:17:17,120
here is to do a secret shed sparse

516
00:17:15,520 --> 00:17:19,280
polynomial multiplication

517
00:17:17,119 --> 00:17:21,119
more importantly we want communication

518
00:17:19,280 --> 00:17:22,959
to be independent of the degree of the

519
00:17:21,119 --> 00:17:24,399
polynomials

520
00:17:22,959 --> 00:17:26,559
we show that this can be done with t

521
00:17:24,400 --> 00:17:28,480
squared multiplications over zp

522
00:17:26,559 --> 00:17:30,080
as well as t squared binary addition

523
00:17:28,480 --> 00:17:32,960
circuits to compute

524
00:17:30,080 --> 00:17:35,439
x or sharings of the non-zero positions

525
00:17:32,960 --> 00:17:37,120
in the polynomial product

526
00:17:35,440 --> 00:17:38,880
once we have this we also need a

527
00:17:37,120 --> 00:17:42,239
maliciously secure protocol

528
00:17:38,880 --> 00:17:44,160
to set up the dpf seats we do this by

529
00:17:42,240 --> 00:17:46,960
extending the semi honest donor shellac

530
00:17:44,160 --> 00:17:48,720
protocol from ccs 2017

531
00:17:46,960 --> 00:17:50,240
by doing the computation on

532
00:17:48,720 --> 00:17:52,240
authenticated inputs

533
00:17:50,240 --> 00:17:54,000
and adding a check a correctness check

534
00:17:52,240 --> 00:17:57,200
to verify the authenticity

535
00:17:54,000 --> 00:17:58,559
of the outputs a protocol is not fully

536
00:17:57,200 --> 00:18:00,080
actively secure

537
00:17:58,559 --> 00:18:02,320
it does still allow selective failure

538
00:18:00,080 --> 00:18:02,960
attacks however we show that this only

539
00:18:02,320 --> 00:18:05,360
results

540
00:18:02,960 --> 00:18:07,919
in at most of one bit amount of leakage

541
00:18:05,360 --> 00:18:09,840
on the lpn error vector

542
00:18:07,919 --> 00:18:11,200
using this protocol we give some

543
00:18:09,840 --> 00:18:12,559
efficiency estimates

544
00:18:11,200 --> 00:18:14,640
for generating authenticated

545
00:18:12,559 --> 00:18:16,720
multiplication triples for the speeds

546
00:18:14,640 --> 00:18:17,919
protocol for actively secure two-party

547
00:18:16,720 --> 00:18:20,720
computation

548
00:18:17,919 --> 00:18:21,760
in this protocol the pcg setup phase

549
00:18:20,720 --> 00:18:25,360
requires around

550
00:18:21,760 --> 00:18:26,400
25 000 triples to generate the first pcg

551
00:18:25,360 --> 00:18:28,000
seeds

552
00:18:26,400 --> 00:18:30,559
this costs around four megabytes of

553
00:18:28,000 --> 00:18:31,280
communication in the silent expansion

554
00:18:30,559 --> 00:18:33,039
phase

555
00:18:31,280 --> 00:18:35,520
these can then be expanded to produce a

556
00:18:33,039 --> 00:18:36,720
million triples in under 20 seconds of

557
00:18:35,520 --> 00:18:38,480
computation

558
00:18:36,720 --> 00:18:39,919
we can then perform a bootstrapping

559
00:18:38,480 --> 00:18:42,080
phase where we use

560
00:18:39,919 --> 00:18:44,000
some of the triples that are expanded

561
00:18:42,080 --> 00:18:47,199
and reserve them to generate a seed

562
00:18:44,000 --> 00:18:47,679
for the next set of pcg seats in this

563
00:18:47,200 --> 00:18:50,000
way

564
00:18:47,679 --> 00:18:52,160
the cost of the 25 000 seed triples

565
00:18:50,000 --> 00:18:54,840
essentially only needs to be paid once

566
00:18:52,160 --> 00:18:56,640
could be seen as a one-time setup for

567
00:18:54,840 --> 00:18:58,799
comparison the state-of-the-art

568
00:18:56,640 --> 00:19:00,960
overdrive protocol for generating speed

569
00:18:58,799 --> 00:19:02,879
triples using homework encryption

570
00:19:00,960 --> 00:19:04,240
requires a one-time distributed key

571
00:19:02,880 --> 00:19:06,000
generation setup

572
00:19:04,240 --> 00:19:07,440
and then costs around 20 seconds of

573
00:19:06,000 --> 00:19:09,679
computation time

574
00:19:07,440 --> 00:19:12,240
as well as 2 gigabytes of bandwidth to

575
00:19:09,679 --> 00:19:14,640
produce the same number of trebles

576
00:19:12,240 --> 00:19:16,000
so using a pcg it seems that we can

577
00:19:14,640 --> 00:19:17,039
obtain the benefits of silent

578
00:19:16,000 --> 00:19:18,720
pre-processing

579
00:19:17,039 --> 00:19:22,480
with roughly comparable costs and

580
00:19:18,720 --> 00:19:24,880
computation to non-silent approaches

581
00:19:22,480 --> 00:19:26,960
in summary we've shown that using pcgs

582
00:19:24,880 --> 00:19:28,640
for ole and multiplication triples

583
00:19:26,960 --> 00:19:30,320
gives a practical approach using the

584
00:19:28,640 --> 00:19:32,320
ring lpn assumption

585
00:19:30,320 --> 00:19:35,039
this expands the types of correlations

586
00:19:32,320 --> 00:19:36,720
we can perform efficiently using pcgs

587
00:19:35,039 --> 00:19:38,640
and gives us the benefit of silent

588
00:19:36,720 --> 00:19:39,840
preprocessing compared with previous

589
00:19:38,640 --> 00:19:41,280
protocols

590
00:19:39,840 --> 00:19:43,039
there are still some interesting open

591
00:19:41,280 --> 00:19:44,799
problems that remain

592
00:19:43,039 --> 00:19:47,039
for example a triple generation

593
00:19:44,799 --> 00:19:47,760
construction can only silently generate

594
00:19:47,039 --> 00:19:50,160
triples

595
00:19:47,760 --> 00:19:51,520
over reasonably large finite fields it

596
00:19:50,160 --> 00:19:53,520
would be nice to extend this to work

597
00:19:51,520 --> 00:19:57,280
over the integers modulo 2 to the k

598
00:19:53,520 --> 00:19:58,559
on modulo 2. also the matrix triple

599
00:19:57,280 --> 00:20:00,080
construction we give

600
00:19:58,559 --> 00:20:02,158
is not that efficient and would be great

601
00:20:00,080 --> 00:20:03,520
to improve as well as have better

602
00:20:02,159 --> 00:20:04,880
constructions for higher degree

603
00:20:03,520 --> 00:20:06,639
correlations

604
00:20:04,880 --> 00:20:08,880
and finally i'd like to see some more

605
00:20:06,640 --> 00:20:10,640
study of the security of ring lpn

606
00:20:08,880 --> 00:20:12,799
including its different variants which

607
00:20:10,640 --> 00:20:14,480
we use in our constructions

608
00:20:12,799 --> 00:20:20,080
thanks for listening i hope you've

609
00:20:14,480 --> 00:20:22,159
enjoyed this presentation

610
00:20:20,080 --> 00:20:22,158
you

