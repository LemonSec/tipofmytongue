1
00:00:01,280 --> 00:00:05,839
hello everybody my name is abdel

2
00:00:03,439 --> 00:00:07,040
i'm an intern at crypto experts company

3
00:00:05,839 --> 00:00:09,040
in france

4
00:00:07,040 --> 00:00:10,400
and today i'll be presenting our work

5
00:00:09,040 --> 00:00:13,120
along with sonia bella

6
00:00:10,400 --> 00:00:13,120
john sebastian

7
00:00:13,759 --> 00:00:16,880
about the random probing security of

8
00:00:15,759 --> 00:00:19,920
masking schemes

9
00:00:16,880 --> 00:00:22,000
against side channel attacks

10
00:00:19,920 --> 00:00:24,480
so most cryptographic algorithms are

11
00:00:22,000 --> 00:00:24,880
usually secure when an adversary only

12
00:00:24,480 --> 00:00:27,119
has

13
00:00:24,880 --> 00:00:28,560
access to the inputs and outputs of this

14
00:00:27,119 --> 00:00:31,279
algorithm

15
00:00:28,560 --> 00:00:33,440
however when implemented on hardware

16
00:00:31,279 --> 00:00:35,600
these algorithms become vulnerable to

17
00:00:33,440 --> 00:00:38,000
so-called side-channel attacks

18
00:00:35,600 --> 00:00:39,600
where an adversary can also observe the

19
00:00:38,000 --> 00:00:42,320
physical leakage of the device

20
00:00:39,600 --> 00:00:43,200
such as power consumption or execution

21
00:00:42,320 --> 00:00:45,200
time

22
00:00:43,200 --> 00:00:48,320
and exploit its dependence with the

23
00:00:45,200 --> 00:00:50,160
secret values of the algorithm

24
00:00:48,320 --> 00:00:51,440
and so to protect implementations on

25
00:00:50,160 --> 00:00:54,078
embedded devices

26
00:00:51,440 --> 00:00:56,079
many countermeasures have been developed

27
00:00:54,079 --> 00:00:58,399
the most widely used of them

28
00:00:56,079 --> 00:01:01,039
is the must encounter measure where the

29
00:00:58,399 --> 00:01:04,640
idea is to split a sensitive variable

30
00:01:01,039 --> 00:01:06,960
x into n values that we call shares

31
00:01:04,640 --> 00:01:07,760
where the first n minus 1 values are

32
00:01:06,960 --> 00:01:10,080
generated

33
00:01:07,760 --> 00:01:11,040
uniformly at random from the underlying

34
00:01:10,080 --> 00:01:13,280
group

35
00:01:11,040 --> 00:01:14,560
and the last element is the combination

36
00:01:13,280 --> 00:01:17,520
of the random elements

37
00:01:14,560 --> 00:01:19,920
and the secret value and the the aim

38
00:01:17,520 --> 00:01:23,679
here is to break the dependence of the

39
00:01:19,920 --> 00:01:25,840
secret with any set of n minus 1 shares

40
00:01:23,680 --> 00:01:27,759
making it difficult to recover the value

41
00:01:25,840 --> 00:01:30,240
of the secret as the number of the

42
00:01:27,759 --> 00:01:32,159
shares grows

43
00:01:30,240 --> 00:01:34,158
and so to reason about the security of

44
00:01:32,159 --> 00:01:36,320
masking schemes in theory

45
00:01:34,159 --> 00:01:38,400
the community introduced what we call

46
00:01:36,320 --> 00:01:40,880
leakage models

47
00:01:38,400 --> 00:01:41,520
in general an algorithm is said to be

48
00:01:40,880 --> 00:01:43,759
secure

49
00:01:41,520 --> 00:01:45,360
in a leakage model if the leaking

50
00:01:43,759 --> 00:01:48,399
variables do not reveal

51
00:01:45,360 --> 00:01:50,240
any information about the secrets

52
00:01:48,399 --> 00:01:51,520
now there are three main models that

53
00:01:50,240 --> 00:01:54,079
vary in terms of

54
00:01:51,520 --> 00:01:55,679
convenience for security proofs and

55
00:01:54,079 --> 00:01:59,199
closeness to reality

56
00:01:55,680 --> 00:02:01,360
of physical leakage the first one

57
00:01:59,200 --> 00:02:02,960
is the probing model where we consider

58
00:02:01,360 --> 00:02:05,200
that during an execution

59
00:02:02,960 --> 00:02:06,798
there is a fixed number of t leaking

60
00:02:05,200 --> 00:02:09,039
variables

61
00:02:06,799 --> 00:02:10,879
the second one is the random probing

62
00:02:09,038 --> 00:02:14,238
model where each variable

63
00:02:10,878 --> 00:02:14,720
leaks with a probability p and the last

64
00:02:14,239 --> 00:02:17,040
one

65
00:02:14,720 --> 00:02:18,319
is the noisy leakage model where all

66
00:02:17,040 --> 00:02:21,920
variables leak

67
00:02:18,319 --> 00:02:25,040
with some noise and in fact as a model

68
00:02:21,920 --> 00:02:27,920
better describes the reality of leakage

69
00:02:25,040 --> 00:02:28,879
it becomes less convenient for proofs

70
00:02:27,920 --> 00:02:31,200
and until now

71
00:02:28,879 --> 00:02:32,239
the most widely used one is the probing

72
00:02:31,200 --> 00:02:34,480
model

73
00:02:32,239 --> 00:02:35,519
but it has recently been challenged

74
00:02:34,480 --> 00:02:37,760
since it does not

75
00:02:35,519 --> 00:02:39,120
capture very well the reality of

76
00:02:37,760 --> 00:02:41,359
physical leakage

77
00:02:39,120 --> 00:02:43,280
and so researchers have been trying to

78
00:02:41,360 --> 00:02:46,239
establish security properties

79
00:02:43,280 --> 00:02:46,239
in the other models

80
00:02:46,319 --> 00:02:51,200
now there is actually a reduction

81
00:02:48,080 --> 00:02:53,519
property established in 2014

82
00:02:51,200 --> 00:02:54,640
that allows to move from one model to

83
00:02:53,519 --> 00:02:57,680
another

84
00:02:54,640 --> 00:02:58,319
it states that if a certain algorithm is

85
00:02:57,680 --> 00:03:00,879
secure

86
00:02:58,319 --> 00:03:01,518
in the probing model then it is also

87
00:03:00,879 --> 00:03:04,239
secure

88
00:03:01,519 --> 00:03:05,599
in the random probing one but in this

89
00:03:04,239 --> 00:03:08,480
part of the implication

90
00:03:05,599 --> 00:03:09,839
the security parameter is reduced as the

91
00:03:08,480 --> 00:03:12,319
size of the algorithm

92
00:03:09,840 --> 00:03:13,840
grows so it is not a very tight

93
00:03:12,319 --> 00:03:15,760
reduction

94
00:03:13,840 --> 00:03:17,920
on the other hand the second part of the

95
00:03:15,760 --> 00:03:18,720
reduction from random probing to noisy

96
00:03:17,920 --> 00:03:21,679
leakage

97
00:03:18,720 --> 00:03:23,280
is tighter and more convenient to use

98
00:03:21,680 --> 00:03:25,360
which is why our work

99
00:03:23,280 --> 00:03:26,560
tries to reason in the random probing

100
00:03:25,360 --> 00:03:28,720
model since

101
00:03:26,560 --> 00:03:29,760
it is still more convenient in terms of

102
00:03:28,720 --> 00:03:32,879
security proofs

103
00:03:29,760 --> 00:03:34,560
than the noisy leakage one

104
00:03:32,879 --> 00:03:36,319
now there are some constructions that

105
00:03:34,560 --> 00:03:37,760
already exist in the random probing

106
00:03:36,319 --> 00:03:40,238
model

107
00:03:37,760 --> 00:03:42,480
mainly two of them are based on expander

108
00:03:40,239 --> 00:03:42,879
graphs but they are not very simple to

109
00:03:42,480 --> 00:03:45,119
use

110
00:03:42,879 --> 00:03:46,480
and the tolerated leakage probability is

111
00:03:45,120 --> 00:03:49,879
not made explicit

112
00:03:46,480 --> 00:03:51,359
by the authors a more recent work from

113
00:03:49,879 --> 00:03:53,760
2018

114
00:03:51,360 --> 00:03:55,760
is based on secure multi-party

115
00:03:53,760 --> 00:03:58,079
computation protocols

116
00:03:55,760 --> 00:04:00,640
and it tolerates a leakage probability

117
00:03:58,080 --> 00:04:03,040
of about 2 to the minus 25

118
00:04:00,640 --> 00:04:05,040
with a complexity polynomial in the

119
00:04:03,040 --> 00:04:07,840
security parameter

120
00:04:05,040 --> 00:04:11,439
however this polynomial is not made

121
00:04:07,840 --> 00:04:14,080
explicit by the authors in the work

122
00:04:11,439 --> 00:04:15,519
so our work is another one based in the

123
00:04:14,080 --> 00:04:19,120
random probing model

124
00:04:15,519 --> 00:04:21,680
and our contributions are threefold

125
00:04:19,120 --> 00:04:23,680
we first introduce a new automatic

126
00:04:21,680 --> 00:04:24,639
formal verification tool that we call

127
00:04:23,680 --> 00:04:26,479
wraps

128
00:04:24,639 --> 00:04:29,040
which given a small circuit on our

129
00:04:26,479 --> 00:04:29,919
algorithm computes the parameters for

130
00:04:29,040 --> 00:04:33,520
which it is

131
00:04:29,919 --> 00:04:36,560
random probing secure we also provide

132
00:04:33,520 --> 00:04:39,359
new composition and expansion properties

133
00:04:36,560 --> 00:04:41,120
to make small circuits composable in a

134
00:04:39,360 --> 00:04:44,400
global random probing

135
00:04:41,120 --> 00:04:45,280
secure circuit while achieving arbitrary

136
00:04:44,400 --> 00:04:48,239
security

137
00:04:45,280 --> 00:04:52,400
levels under certain conditions and we

138
00:04:48,240 --> 00:04:55,600
show the complexity of such a strategy

139
00:04:52,400 --> 00:04:58,400
finally we exhibit an instantiation with

140
00:04:55,600 --> 00:05:01,039
new construction from base gadgets

141
00:04:58,400 --> 00:05:03,120
that fulfill the expansion property as

142
00:05:01,039 --> 00:05:05,280
verified by our tool

143
00:05:03,120 --> 00:05:06,720
and we show that for a given security

144
00:05:05,280 --> 00:05:09,520
parameter kappa

145
00:05:06,720 --> 00:05:11,759
we are able to achieve a complexity in

146
00:05:09,520 --> 00:05:14,159
kappa to the 7.5

147
00:05:11,759 --> 00:05:15,759
while tolerating a leakage probability

148
00:05:14,160 --> 00:05:18,000
of about two to the minus

149
00:05:15,759 --> 00:05:18,000
eight

150
00:05:20,560 --> 00:05:24,560
so what is this random probing security

151
00:05:22,800 --> 00:05:27,280
that i keep mentioning

152
00:05:24,560 --> 00:05:27,840
for our definitions we consider circuits

153
00:05:27,280 --> 00:05:29,919
that are

154
00:05:27,840 --> 00:05:31,440
directed graphs as you can see on the

155
00:05:29,919 --> 00:05:33,919
example on the left

156
00:05:31,440 --> 00:05:35,520
which edges are the variables that we

157
00:05:33,919 --> 00:05:38,719
call wires

158
00:05:35,520 --> 00:05:41,680
and that link each with probability p

159
00:05:38,720 --> 00:05:42,800
and the vertices are the operation gates

160
00:05:41,680 --> 00:05:44,160
now we can have additional

161
00:05:42,800 --> 00:05:46,720
multiplication gates

162
00:05:44,160 --> 00:05:48,240
we can have random gates that generate

163
00:05:46,720 --> 00:05:50,800
random values

164
00:05:48,240 --> 00:05:52,000
and we can have copy gates that output

165
00:05:50,800 --> 00:05:55,280
two fresh copies

166
00:05:52,000 --> 00:05:57,280
of an input variable and in our model

167
00:05:55,280 --> 00:05:59,758
we don't consider leakage on output

168
00:05:57,280 --> 00:06:00,479
wires since when composing several

169
00:05:59,759 --> 00:06:02,720
circuits

170
00:06:00,479 --> 00:06:06,318
the output wires of a circuit are just

171
00:06:02,720 --> 00:06:08,720
the input wires in the next circuit

172
00:06:06,319 --> 00:06:11,039
so in the random probing model since

173
00:06:08,720 --> 00:06:12,720
each wire leaks independently with

174
00:06:11,039 --> 00:06:15,440
probability p

175
00:06:12,720 --> 00:06:16,000
we we try to formalize this by the

176
00:06:15,440 --> 00:06:19,120
notion

177
00:06:16,000 --> 00:06:21,199
of a set of leaking wires w

178
00:06:19,120 --> 00:06:22,479
now this set can be thought of as a

179
00:06:21,199 --> 00:06:25,600
random variable

180
00:06:22,479 --> 00:06:26,880
output from a random process in which in

181
00:06:25,600 --> 00:06:30,080
which each wire

182
00:06:26,880 --> 00:06:33,199
in the circuit is added to w with probab

183
00:06:30,080 --> 00:06:35,120
with probability p independently of the

184
00:06:33,199 --> 00:06:37,919
other wires

185
00:06:35,120 --> 00:06:38,720
now such a circuit is said to be p

186
00:06:37,919 --> 00:06:42,560
epsilon

187
00:06:38,720 --> 00:06:45,680
random probing secure if for any set w

188
00:06:42,560 --> 00:06:46,560
of leaking wires this set should be

189
00:06:45,680 --> 00:06:49,520
independent

190
00:06:46,560 --> 00:06:51,440
from the secret inputs meaning that it

191
00:06:49,520 --> 00:06:52,639
does not require the knowledge of the

192
00:06:51,440 --> 00:06:56,719
secret values

193
00:06:52,639 --> 00:06:58,800
to be simulated now if it is independent

194
00:06:56,720 --> 00:07:00,319
then we say that we have a simulation

195
00:06:58,800 --> 00:07:03,199
success

196
00:07:00,319 --> 00:07:04,319
if not we say that we have a simulation

197
00:07:03,199 --> 00:07:06,960
failure

198
00:07:04,319 --> 00:07:08,400
and we associate this failure event with

199
00:07:06,960 --> 00:07:12,080
a probability function

200
00:07:08,400 --> 00:07:14,638
epsilon and so actually to determine the

201
00:07:12,080 --> 00:07:17,280
random probing security of a circuit we

202
00:07:14,639 --> 00:07:20,720
would need to compute the value of this

203
00:07:17,280 --> 00:07:20,719
failure event probability

204
00:07:20,800 --> 00:07:25,280
now it can be observed that when

205
00:07:22,720 --> 00:07:28,319
acquiring a set of wires w

206
00:07:25,280 --> 00:07:31,280
since each wire is leaking

207
00:07:28,319 --> 00:07:34,240
independently with probability p then

208
00:07:31,280 --> 00:07:37,039
the probability of having such a set

209
00:07:34,240 --> 00:07:38,960
follows a binomial distribution with

210
00:07:37,039 --> 00:07:40,880
respect to the value p

211
00:07:38,960 --> 00:07:42,880
and the total number of wires in the

212
00:07:40,880 --> 00:07:45,840
circuit s

213
00:07:42,880 --> 00:07:47,919
and since epsilon is the probability of

214
00:07:45,840 --> 00:07:50,239
having a failure event

215
00:07:47,919 --> 00:07:51,680
we can actually express it as a function

216
00:07:50,240 --> 00:07:54,960
of p

217
00:07:51,680 --> 00:07:57,680
we can say that epsilon is the sum over

218
00:07:54,960 --> 00:07:59,599
all sets w for which there is a

219
00:07:57,680 --> 00:08:01,840
simulation failure

220
00:07:59,599 --> 00:08:03,199
of the corresponding probability of

221
00:08:01,840 --> 00:08:06,159
acquisition

222
00:08:03,199 --> 00:08:08,960
so it's the sum of probabilities of all

223
00:08:06,160 --> 00:08:12,000
the failure events

224
00:08:08,960 --> 00:08:14,719
and we can also express this epsilon

225
00:08:12,000 --> 00:08:16,160
slightly differently by a grouping the

226
00:08:14,720 --> 00:08:19,199
failure sets w

227
00:08:16,160 --> 00:08:22,240
with respect to their sizes so

228
00:08:19,199 --> 00:08:25,919
if we denote ci the number of sets

229
00:08:22,240 --> 00:08:27,199
w of size i for which there is a failure

230
00:08:25,919 --> 00:08:30,318
event

231
00:08:27,199 --> 00:08:31,039
then epsilon is simply the sum over all

232
00:08:30,319 --> 00:08:34,959
sizes

233
00:08:31,039 --> 00:08:37,199
from 1 to s of the coefficient ci

234
00:08:34,958 --> 00:08:39,439
times the corresponding acquisition

235
00:08:37,200 --> 00:08:42,000
probability

236
00:08:39,440 --> 00:08:42,959
and using this expression we can exhibit

237
00:08:42,000 --> 00:08:46,000
an algorithm

238
00:08:42,958 --> 00:08:48,399
that given a circuit of s wires

239
00:08:46,000 --> 00:08:49,120
computes the corresponding coefficient c

240
00:08:48,399 --> 00:08:52,839
i

241
00:08:49,120 --> 00:08:54,640
to get the value of epsilon in terms of

242
00:08:52,839 --> 00:08:57,020
p

243
00:08:54,640 --> 00:08:58,480
and basically what our algorithm

244
00:08:57,020 --> 00:09:02,160
[Music]

245
00:08:58,480 --> 00:09:03,120
wraps does is that it it computes the

246
00:09:02,160 --> 00:09:06,560
coefficients

247
00:09:03,120 --> 00:09:09,760
of epsilon c1 through cs

248
00:09:06,560 --> 00:09:11,199
it will iterate over all sizes from 1 to

249
00:09:09,760 --> 00:09:14,880
s

250
00:09:11,200 --> 00:09:18,160
enumerate the corresponding sets w

251
00:09:14,880 --> 00:09:20,880
of size i and apply a set of rules

252
00:09:18,160 --> 00:09:22,000
inspired from mask verif which is a

253
00:09:20,880 --> 00:09:25,360
verification tool

254
00:09:22,000 --> 00:09:27,360
in the probing model from 2015

255
00:09:25,360 --> 00:09:30,320
to determine whether each set is

256
00:09:27,360 --> 00:09:33,120
independent from the secret inputs

257
00:09:30,320 --> 00:09:34,560
and finally the coefficient ci will be

258
00:09:33,120 --> 00:09:36,959
the number of failures

259
00:09:34,560 --> 00:09:38,560
that we were able to detect in the list

260
00:09:36,959 --> 00:09:40,719
l

261
00:09:38,560 --> 00:09:42,399
now indeed this algorithm is interesting

262
00:09:40,720 --> 00:09:45,519
for small circuits

263
00:09:42,399 --> 00:09:47,360
as when the size of the circuit grows

264
00:09:45,519 --> 00:09:49,279
computing these coefficients becomes

265
00:09:47,360 --> 00:09:52,320
exponentially hard

266
00:09:49,279 --> 00:09:55,120
but testing security for small circuits

267
00:09:52,320 --> 00:09:55,760
can be interesting especially when we

268
00:09:55,120 --> 00:09:57,760
try to

269
00:09:55,760 --> 00:09:59,839
deduce global security through

270
00:09:57,760 --> 00:10:02,079
composition properties like we do in our

271
00:09:59,839 --> 00:10:04,880
work

272
00:10:02,079 --> 00:10:07,439
and so in addition in our paper we offer

273
00:10:04,880 --> 00:10:09,519
a couple of more optimizations

274
00:10:07,440 --> 00:10:10,480
that allow us to increase the size of

275
00:10:09,519 --> 00:10:13,120
the circuits

276
00:10:10,480 --> 00:10:14,240
that we that we are able to feed to our

277
00:10:13,120 --> 00:10:19,839
algorithm

278
00:10:14,240 --> 00:10:19,839
with a reasonable execution time

279
00:10:20,640 --> 00:10:25,439
so as i just said in our work we also

280
00:10:23,040 --> 00:10:26,560
try to achieve global random probing

281
00:10:25,440 --> 00:10:29,600
security

282
00:10:26,560 --> 00:10:30,319
from small composable circuits and so we

283
00:10:29,600 --> 00:10:32,800
reason on

284
00:10:30,320 --> 00:10:33,839
small and share circuits that we call

285
00:10:32,800 --> 00:10:35,760
gadgets

286
00:10:33,839 --> 00:10:37,440
and that compute a certain functionality

287
00:10:35,760 --> 00:10:40,480
so for example an and share

288
00:10:37,440 --> 00:10:40,800
addition gadget outputs the sum of its

289
00:10:40,480 --> 00:10:43,680
two

290
00:10:40,800 --> 00:10:44,560
and share inputs and we show that if

291
00:10:43,680 --> 00:10:47,359
given such

292
00:10:44,560 --> 00:10:49,599
gadgets for each basic gate operation

293
00:10:47,360 --> 00:10:52,640
that are random probing composable

294
00:10:49,600 --> 00:10:55,279
for parameters t epsilon and p

295
00:10:52,640 --> 00:10:58,000
then a circuit that composes them will

296
00:10:55,279 --> 00:11:00,079
also be globally random probing secure

297
00:10:58,000 --> 00:11:02,640
with a failure probability that is

298
00:11:00,079 --> 00:11:04,880
multiplied by the size of the circuit

299
00:11:02,640 --> 00:11:06,959
and this is because each gadget in the

300
00:11:04,880 --> 00:11:10,000
circuit fails with the probability

301
00:11:06,959 --> 00:11:11,040
epsilon so the overall case failure is

302
00:11:10,000 --> 00:11:14,560
when at least

303
00:11:11,040 --> 00:11:17,040
one of the composed gadgets fail

304
00:11:14,560 --> 00:11:17,920
so concerning the random gate it can be

305
00:11:17,040 --> 00:11:20,959
seen that an

306
00:11:17,920 --> 00:11:24,160
end sharing of a random value is simply

307
00:11:20,959 --> 00:11:26,319
n independent random values which is why

308
00:11:24,160 --> 00:11:27,519
we don't necessarily mention a gadget

309
00:11:26,320 --> 00:11:29,839
for randomness

310
00:11:27,519 --> 00:11:32,399
since it will trivially verify the

311
00:11:29,839 --> 00:11:34,160
property

312
00:11:32,399 --> 00:11:36,079
so the definition of random probing

313
00:11:34,160 --> 00:11:38,480
composability is just a

314
00:11:36,079 --> 00:11:40,079
more developed definition of random

315
00:11:38,480 --> 00:11:42,480
probing security

316
00:11:40,079 --> 00:11:44,479
we will still consider a set w of

317
00:11:42,480 --> 00:11:46,399
leaking wires for the simulation

318
00:11:44,480 --> 00:11:48,720
succession failure

319
00:11:46,399 --> 00:11:49,440
but in addition we will also consider

320
00:11:48,720 --> 00:11:52,720
any set

321
00:11:49,440 --> 00:11:56,320
of t or less output wires and

322
00:11:52,720 --> 00:12:00,240
these two sets should be simulated

323
00:11:56,320 --> 00:12:02,480
from at most t shares of each input

324
00:12:00,240 --> 00:12:04,959
now this additional constraint allows us

325
00:12:02,480 --> 00:12:05,920
to have an invariant in the composition

326
00:12:04,959 --> 00:12:08,399
notion

327
00:12:05,920 --> 00:12:09,760
since for each gadget we can achieve a

328
00:12:08,399 --> 00:12:12,880
perfect simulation

329
00:12:09,760 --> 00:12:13,279
of the leaking wires plus t shares of

330
00:12:12,880 --> 00:12:16,560
each

331
00:12:13,279 --> 00:12:19,279
output sharing from at most t shares

332
00:12:16,560 --> 00:12:20,638
of each input sharing and since when

333
00:12:19,279 --> 00:12:23,439
composing circuits

334
00:12:20,639 --> 00:12:25,200
the internal output and input wires are

335
00:12:23,440 --> 00:12:28,000
directly connected

336
00:12:25,200 --> 00:12:29,920
this allows us to have the global random

337
00:12:28,000 --> 00:12:33,279
probing security property

338
00:12:29,920 --> 00:12:33,279
for the resulting circuit

339
00:12:35,279 --> 00:12:40,240
now in addition to composing gadgets for

340
00:12:37,839 --> 00:12:42,800
global random probing security

341
00:12:40,240 --> 00:12:45,760
we also exhibit a property that allows

342
00:12:42,800 --> 00:12:48,639
composable gadgets to be expanded

343
00:12:45,760 --> 00:12:50,880
and achieve arbitrary security levels

344
00:12:48,639 --> 00:12:53,000
and this is a revisited strategy of the

345
00:12:50,880 --> 00:12:55,279
multi-party computation approach from

346
00:12:53,000 --> 00:12:58,160
2018.

347
00:12:55,279 --> 00:13:00,800
the expansion strategy consists in using

348
00:12:58,160 --> 00:13:04,160
enshare gadgets for basic operations

349
00:13:00,800 --> 00:13:07,359
that are random probing expandable

350
00:13:04,160 --> 00:13:11,040
and use them to replace a base circuit

351
00:13:07,360 --> 00:13:13,920
where each wire leaks with probability p

352
00:13:11,040 --> 00:13:16,719
by an expanded circuit where each gate

353
00:13:13,920 --> 00:13:20,079
is replaced by the corresponding gadget

354
00:13:16,720 --> 00:13:20,639
and each wire by n wires carrying a

355
00:13:20,079 --> 00:13:23,920
sharing

356
00:13:20,639 --> 00:13:25,680
of the original wire now in fact this

357
00:13:23,920 --> 00:13:26,719
allows us to replace the leakage

358
00:13:25,680 --> 00:13:29,439
probability p

359
00:13:26,720 --> 00:13:32,000
of a wire in the original circuit by the

360
00:13:29,440 --> 00:13:34,240
failure event probability epsilon in the

361
00:13:32,000 --> 00:13:37,120
expanded gadget simulation

362
00:13:34,240 --> 00:13:39,120
because if a simulation fails then one

363
00:13:37,120 --> 00:13:40,639
needs the full input sharing for the

364
00:13:39,120 --> 00:13:42,560
gadget simulation

365
00:13:40,639 --> 00:13:43,839
which corresponds to leaking the

366
00:13:42,560 --> 00:13:47,279
corresponding wire

367
00:13:43,839 --> 00:13:48,079
value in the base case and this strategy

368
00:13:47,279 --> 00:13:51,120
can be applied

369
00:13:48,079 --> 00:13:53,199
recursively on the base circuit

370
00:13:51,120 --> 00:13:54,880
amplifying the security level from the

371
00:13:53,199 --> 00:13:57,920
original circuit

372
00:13:54,880 --> 00:13:59,199
until we achieve a desired security

373
00:13:57,920 --> 00:14:01,839
level

374
00:13:59,199 --> 00:14:05,199
and this works as long as epsilon is

375
00:14:01,839 --> 00:14:05,199
strictly smaller than p

376
00:14:05,440 --> 00:14:09,199
now to do this the gadgets should verify

377
00:14:07,680 --> 00:14:10,560
what we call random probing

378
00:14:09,199 --> 00:14:12,479
expandability

379
00:14:10,560 --> 00:14:15,040
which is a more advanced definition of

380
00:14:12,480 --> 00:14:17,279
the random probing composability

381
00:14:15,040 --> 00:14:18,240
as before since we are still composing

382
00:14:17,279 --> 00:14:20,320
gadgets

383
00:14:18,240 --> 00:14:22,000
we will still have the same definitions

384
00:14:20,320 --> 00:14:25,440
with the t output wires

385
00:14:22,000 --> 00:14:26,320
and t input wires meanwhile since in the

386
00:14:25,440 --> 00:14:29,040
base case

387
00:14:26,320 --> 00:14:30,800
each wire as input of the gate leaks

388
00:14:29,040 --> 00:14:32,560
independently

389
00:14:30,800 --> 00:14:34,719
then a gadget should have a failure

390
00:14:32,560 --> 00:14:36,319
probability which is independent for

391
00:14:34,720 --> 00:14:38,320
each input

392
00:14:36,320 --> 00:14:39,519
which is why our failure event

393
00:14:38,320 --> 00:14:42,320
probabilities are

394
00:14:39,519 --> 00:14:43,600
epsilon on the first input epsilon on

395
00:14:42,320 --> 00:14:46,800
the second input

396
00:14:43,600 --> 00:14:49,600
and epsilon squared on both

397
00:14:46,800 --> 00:14:51,279
now in addition in case of failure in a

398
00:14:49,600 --> 00:14:53,120
composed gadget

399
00:14:51,279 --> 00:14:54,480
we should still be able to have a

400
00:14:53,120 --> 00:14:56,560
perfect simulation

401
00:14:54,480 --> 00:14:59,040
in the gadgets that are directly

402
00:14:56,560 --> 00:15:01,839
connected to it in the circuit

403
00:14:59,040 --> 00:15:03,839
and a necessary condition to have this

404
00:15:01,839 --> 00:15:07,120
is to be able to choose

405
00:15:03,839 --> 00:15:10,079
at least one set of n minus one

406
00:15:07,120 --> 00:15:11,120
output wires for which the simulation

407
00:15:10,079 --> 00:15:15,040
succeeds

408
00:15:11,120 --> 00:15:15,440
along with the set w now having access

409
00:15:15,040 --> 00:15:18,480
to n

410
00:15:15,440 --> 00:15:21,279
minus one shares plus the original input

411
00:15:18,480 --> 00:15:23,519
wire in the base case simulation

412
00:15:21,279 --> 00:15:26,079
uh this case this way in case of a

413
00:15:23,519 --> 00:15:28,000
failure event in a composed gadget

414
00:15:26,079 --> 00:15:30,638
we will still be able to produce a

415
00:15:28,000 --> 00:15:33,920
simulation in the resulting circuit

416
00:15:30,639 --> 00:15:36,079
with the right number of input shares so

417
00:15:33,920 --> 00:15:37,360
in this condition we are really allowed

418
00:15:36,079 --> 00:15:40,800
to choose any set

419
00:15:37,360 --> 00:15:44,399
of n minus 1y output wires and have at

420
00:15:40,800 --> 00:15:44,399
least one simulation success

421
00:15:45,279 --> 00:15:49,600
now using this definition we show that

422
00:15:48,160 --> 00:15:52,639
any end share gadget

423
00:15:49,600 --> 00:15:54,880
that is random probing expandable then

424
00:15:52,639 --> 00:15:57,360
the expanded gadget to the gate level

425
00:15:54,880 --> 00:15:58,320
is also expandable with the failure

426
00:15:57,360 --> 00:16:01,759
probability

427
00:15:58,320 --> 00:16:04,399
f to the power k as we desired

428
00:16:01,759 --> 00:16:05,600
in addition we show that such an

429
00:16:04,399 --> 00:16:08,399
expandable gadget

430
00:16:05,600 --> 00:16:09,279
is also composable with a failure

431
00:16:08,399 --> 00:16:11,680
function

432
00:16:09,279 --> 00:16:12,880
two times epsilon which is not very

433
00:16:11,680 --> 00:16:14,800
complicated to see

434
00:16:12,880 --> 00:16:16,160
since the expandability is just

435
00:16:14,800 --> 00:16:18,160
composability

436
00:16:16,160 --> 00:16:20,319
with some additional conditions on the

437
00:16:18,160 --> 00:16:22,959
simulation

438
00:16:20,320 --> 00:16:23,680
and finally using these two results we

439
00:16:22,959 --> 00:16:26,560
show that we

440
00:16:23,680 --> 00:16:28,560
see that using expandable gadgets and

441
00:16:26,560 --> 00:16:31,359
the expansion strategy

442
00:16:28,560 --> 00:16:32,880
on a base circuit we can achieve random

443
00:16:31,360 --> 00:16:34,959
probing security

444
00:16:32,880 --> 00:16:37,439
and choose the number of expansions to

445
00:16:34,959 --> 00:16:38,800
perform to achieve an arbitrary security

446
00:16:37,440 --> 00:16:40,880
level

447
00:16:38,800 --> 00:16:43,040
and to verify the composability and

448
00:16:40,880 --> 00:16:45,040
expandability of small gadgets

449
00:16:43,040 --> 00:16:46,959
we add some modifications to our

450
00:16:45,040 --> 00:16:48,880
verification tool perhaps

451
00:16:46,959 --> 00:16:51,599
in order to compute the necessary

452
00:16:48,880 --> 00:16:53,600
parameters for each of the properties

453
00:16:51,600 --> 00:16:56,160
now it is clear that the difference with

454
00:16:53,600 --> 00:16:59,040
random probing security verification

455
00:16:56,160 --> 00:16:59,519
is that we have to consider output wires

456
00:16:59,040 --> 00:17:02,719
as well

457
00:16:59,519 --> 00:17:05,039
in the simulation and consider failure

458
00:17:02,720 --> 00:17:06,880
when a simulation needs more than t

459
00:17:05,039 --> 00:17:09,439
shares of the inputs

460
00:17:06,880 --> 00:17:10,959
so having these conditions in mind we

461
00:17:09,439 --> 00:17:15,199
include the verification

462
00:17:10,959 --> 00:17:15,199
of these two properties in our tool

463
00:17:17,679 --> 00:17:22,000
in our work we are able to instantiate

464
00:17:20,240 --> 00:17:23,599
the expansion strategy

465
00:17:22,000 --> 00:17:26,079
with the three share gadgets

466
00:17:23,599 --> 00:17:28,319
construction that we show our random

467
00:17:26,079 --> 00:17:30,799
probing expandable

468
00:17:28,319 --> 00:17:32,799
now first here is a construction of a

469
00:17:30,799 --> 00:17:36,000
three share copy gadget

470
00:17:32,799 --> 00:17:39,600
that outputs two fresh copies v and w

471
00:17:36,000 --> 00:17:42,960
of the variable x for each of the copies

472
00:17:39,600 --> 00:17:44,000
we use three random values that are

473
00:17:42,960 --> 00:17:47,039
added twice

474
00:17:44,000 --> 00:17:50,160
to each output in a circular order

475
00:17:47,039 --> 00:17:54,400
for example for the first output we add

476
00:17:50,160 --> 00:17:58,000
r0 r1 and r2 to the three output shares

477
00:17:54,400 --> 00:18:00,160
and then we add r1 r2 r0

478
00:17:58,000 --> 00:18:01,760
now in this way we have output shares

479
00:18:00,160 --> 00:18:03,760
that are randomized

480
00:18:01,760 --> 00:18:04,799
and their combination gives us the

481
00:18:03,760 --> 00:18:07,760
original value

482
00:18:04,799 --> 00:18:10,160
x and the same thing goes for the second

483
00:18:07,760 --> 00:18:10,160
output

484
00:18:10,480 --> 00:18:15,520
now for the construction of addition

485
00:18:12,320 --> 00:18:18,720
gadget we use almost the same idea

486
00:18:15,520 --> 00:18:21,200
for each of the inputs x and y but

487
00:18:18,720 --> 00:18:23,919
we change the order in which the random

488
00:18:21,200 --> 00:18:26,960
values are added to the outputs

489
00:18:23,919 --> 00:18:27,520
so as you can see the column of randoms

490
00:18:26,960 --> 00:18:30,880
r1

491
00:18:27,520 --> 00:18:33,840
r2 r0 does not directly follow the

492
00:18:30,880 --> 00:18:36,640
column r0 r1 r2

493
00:18:33,840 --> 00:18:38,559
as in the copy gadget and this allows us

494
00:18:36,640 --> 00:18:41,440
to mix up the random elements

495
00:18:38,559 --> 00:18:45,039
so that intermediate variables become

496
00:18:41,440 --> 00:18:48,000
more independent from one another

497
00:18:45,039 --> 00:18:49,919
and finally the multiplication gadget

498
00:18:48,000 --> 00:18:53,360
starts by refreshing

499
00:18:49,919 --> 00:18:54,000
the inputs x and y using the exact same

500
00:18:53,360 --> 00:18:56,559
principle

501
00:18:54,000 --> 00:18:58,880
as the above gadgets and then it

502
00:18:56,559 --> 00:19:01,120
performs the product of shares to

503
00:18:58,880 --> 00:19:02,880
compute the final result

504
00:19:01,120 --> 00:19:05,520
now the combination of the shares

505
00:19:02,880 --> 00:19:06,480
product is done while adding some random

506
00:19:05,520 --> 00:19:08,799
values

507
00:19:06,480 --> 00:19:10,000
in between each combination which is

508
00:19:08,799 --> 00:19:14,080
also to break

509
00:19:10,000 --> 00:19:16,640
dependencies with intermediate variables

510
00:19:14,080 --> 00:19:18,639
and fees feeding these gadgets to our

511
00:19:16,640 --> 00:19:21,280
verification tool graphs

512
00:19:18,640 --> 00:19:22,400
we verify that they are random probing

513
00:19:21,280 --> 00:19:25,440
expandable

514
00:19:22,400 --> 00:19:25,919
with parameters t equal to one the

515
00:19:25,440 --> 00:19:28,720
function

516
00:19:25,919 --> 00:19:30,480
epsilon with the smallest exponent of p

517
00:19:28,720 --> 00:19:32,960
of three over two

518
00:19:30,480 --> 00:19:35,360
and they tolerate a leakage probability

519
00:19:32,960 --> 00:19:37,840
of about two to the minus eight

520
00:19:35,360 --> 00:19:38,799
so i will use this construction as an

521
00:19:37,840 --> 00:19:40,959
example

522
00:19:38,799 --> 00:19:44,080
to reason about the complexity of the

523
00:19:40,960 --> 00:19:44,080
expansion strategy

524
00:19:45,280 --> 00:19:48,559
now to determine the complexity of the

525
00:19:47,120 --> 00:19:51,678
expansion strategy

526
00:19:48,559 --> 00:19:52,399
we use linear algebra representing each

527
00:19:51,679 --> 00:19:55,360
circuit

528
00:19:52,400 --> 00:19:57,360
as a vector of its number of gates for

529
00:19:55,360 --> 00:20:01,280
each of the basic operations

530
00:19:57,360 --> 00:20:03,439
add copy multiplication and random

531
00:20:01,280 --> 00:20:04,559
and given the gadgets used for the

532
00:20:03,440 --> 00:20:07,280
strategy

533
00:20:04,559 --> 00:20:08,240
we will construct a matrix where each

534
00:20:07,280 --> 00:20:10,240
column

535
00:20:08,240 --> 00:20:11,600
is the vector corresponding to each of

536
00:20:10,240 --> 00:20:13,679
the gadgets

537
00:20:11,600 --> 00:20:16,000
and the last column for the randomness

538
00:20:13,679 --> 00:20:17,600
only generates any random values so in

539
00:20:16,000 --> 00:20:20,000
this case we only have

540
00:20:17,600 --> 00:20:20,719
the value 3 in the last position in the

541
00:20:20,000 --> 00:20:23,919
matrix

542
00:20:20,720 --> 00:20:24,480
for three share gadgets now using the

543
00:20:23,919 --> 00:20:27,200
eigen

544
00:20:24,480 --> 00:20:28,240
the eigen decomposition of the matrix we

545
00:20:27,200 --> 00:20:32,000
can see that when

546
00:20:28,240 --> 00:20:34,000
expanding a circuit the gates vector for

547
00:20:32,000 --> 00:20:37,120
the resulting circuit

548
00:20:34,000 --> 00:20:39,440
is just the result of the matrix to the

549
00:20:37,120 --> 00:20:42,000
power of the expansion level

550
00:20:39,440 --> 00:20:43,520
multiplied by the vector of the original

551
00:20:42,000 --> 00:20:45,679
circuit

552
00:20:43,520 --> 00:20:46,879
so the complexity of this operation

553
00:20:45,679 --> 00:20:49,120
strongly depends

554
00:20:46,880 --> 00:20:50,880
on the eigenvalues of the so-called

555
00:20:49,120 --> 00:20:53,120
matrix

556
00:20:50,880 --> 00:20:54,159
now another other observation that we

557
00:20:53,120 --> 00:20:56,799
can

558
00:20:54,159 --> 00:20:57,280
make is that we only have multiplication

559
00:20:56,799 --> 00:21:00,000
gates

560
00:20:57,280 --> 00:21:01,600
in the multiplication gadget so the

561
00:21:00,000 --> 00:21:04,720
third row has zeros

562
00:21:01,600 --> 00:21:06,320
except in the third position and using

563
00:21:04,720 --> 00:21:08,799
this observation

564
00:21:06,320 --> 00:21:10,320
it can be checked that the eigenvalues

565
00:21:08,799 --> 00:21:12,240
of the matrix

566
00:21:10,320 --> 00:21:14,480
are just the eigenvalues of the

567
00:21:12,240 --> 00:21:16,400
sub-matrix mac

568
00:21:14,480 --> 00:21:18,400
the number of multiplication in the

569
00:21:16,400 --> 00:21:20,480
multiplication gadget

570
00:21:18,400 --> 00:21:21,760
and the number of randoms in the last

571
00:21:20,480 --> 00:21:23,679
column

572
00:21:21,760 --> 00:21:25,360
so the complexity of the compiled

573
00:21:23,679 --> 00:21:27,360
circuit expresses

574
00:21:25,360 --> 00:21:29,120
in terms of the maximum of these

575
00:21:27,360 --> 00:21:32,320
eigenvalues to the power

576
00:21:29,120 --> 00:21:32,320
the expansion level k

577
00:21:32,720 --> 00:21:37,200
now for a certain security parameter

578
00:21:34,720 --> 00:21:40,480
kappa and a failure function

579
00:21:37,200 --> 00:21:42,720
epsilon of amplification order d which

580
00:21:40,480 --> 00:21:44,799
is the smallest exponent of p that we

581
00:21:42,720 --> 00:21:47,440
have in the function

582
00:21:44,799 --> 00:21:50,000
so to achieve the security level we need

583
00:21:47,440 --> 00:21:53,360
the expanded failure probability

584
00:21:50,000 --> 00:21:54,320
almost equal to the secure to true to

585
00:21:53,360 --> 00:21:57,199
the power of

586
00:21:54,320 --> 00:21:59,120
minus the security parameter so we can

587
00:21:57,200 --> 00:22:02,640
express the complexity

588
00:21:59,120 --> 00:22:04,559
in terms of kappa to the power e where e

589
00:22:02,640 --> 00:22:08,080
is a function of the maximum of the

590
00:22:04,559 --> 00:22:10,960
eigenvalues and the amplification order

591
00:22:08,080 --> 00:22:11,600
now in our three-share construction we

592
00:22:10,960 --> 00:22:15,120
have e

593
00:22:11,600 --> 00:22:18,320
equal to 7.5 since our maximum

594
00:22:15,120 --> 00:22:19,918
of the eigenvalues is equal to 21 and

595
00:22:18,320 --> 00:22:23,520
the amplification order

596
00:22:19,919 --> 00:22:25,600
as computed by our tool is 3 over 2.

597
00:22:23,520 --> 00:22:29,840
and so this is how we reason about the

598
00:22:25,600 --> 00:22:29,840
complexity of the expansion strategy

599
00:22:32,559 --> 00:22:38,399
now if you want to compare our strategy

600
00:22:34,799 --> 00:22:40,960
with the expansion from 2018

601
00:22:38,400 --> 00:22:42,320
first of all what we call random probing

602
00:22:40,960 --> 00:22:44,320
expandability

603
00:22:42,320 --> 00:22:46,799
is equivalently called composable

604
00:22:44,320 --> 00:22:49,280
security in their work

605
00:22:46,799 --> 00:22:50,639
achieving this property in our case is

606
00:22:49,280 --> 00:22:53,200
done by constructing

607
00:22:50,640 --> 00:22:54,480
gadgets that verify the necessary

608
00:22:53,200 --> 00:22:57,039
conditions

609
00:22:54,480 --> 00:23:00,320
their work is based on the use of secure

610
00:22:57,039 --> 00:23:02,559
multi-party computation protocols

611
00:23:00,320 --> 00:23:03,439
and for the instantiation part we

612
00:23:02,559 --> 00:23:05,840
constructed

613
00:23:03,440 --> 00:23:08,080
three share gadgets that we show our

614
00:23:05,840 --> 00:23:10,240
random probing expandable

615
00:23:08,080 --> 00:23:13,360
while they use an already existing

616
00:23:10,240 --> 00:23:16,760
protocol due to motor from 2006

617
00:23:13,360 --> 00:23:19,439
to instantiate their strategy

618
00:23:16,760 --> 00:23:19,760
complexity-wise we achieve a complexity

619
00:23:19,440 --> 00:23:22,720
that

620
00:23:19,760 --> 00:23:24,480
expresses in the security parameter to

621
00:23:22,720 --> 00:23:26,400
the 7.5

622
00:23:24,480 --> 00:23:28,000
and while comparing their analysis with

623
00:23:26,400 --> 00:23:30,799
hours we saw that they

624
00:23:28,000 --> 00:23:33,760
achieve a complexity in the security

625
00:23:30,799 --> 00:23:36,400
parameter to the 7.87

626
00:23:33,760 --> 00:23:37,919
while these two complexities are close

627
00:23:36,400 --> 00:23:38,960
in terms of tolerated leakage

628
00:23:37,919 --> 00:23:41,120
probability

629
00:23:38,960 --> 00:23:42,400
we can tolerate up to a value of 2 to

630
00:23:41,120 --> 00:23:45,279
the minus 8

631
00:23:42,400 --> 00:23:47,200
while they tolerate p equal to 2 to the

632
00:23:45,279 --> 00:23:49,840
minus 25

633
00:23:47,200 --> 00:23:51,039
so for an almost equal complexity we can

634
00:23:49,840 --> 00:23:54,320
tolerate the leakage

635
00:23:51,039 --> 00:23:54,320
much higher than theirs

636
00:23:54,559 --> 00:23:57,840
so to conclude we provide a public

637
00:23:56,880 --> 00:24:00,880
implementation

638
00:23:57,840 --> 00:24:03,360
sage of our verification tool for users

639
00:24:00,880 --> 00:24:06,159
to test on small circuits

640
00:24:03,360 --> 00:24:07,840
we introduced new notions of composition

641
00:24:06,159 --> 00:24:10,880
and expansion for achieving

642
00:24:07,840 --> 00:24:12,000
global arbitrary random probing security

643
00:24:10,880 --> 00:24:14,400
levels

644
00:24:12,000 --> 00:24:16,240
and we instantiate these properties with

645
00:24:14,400 --> 00:24:19,600
a concrete construction

646
00:24:16,240 --> 00:24:22,159
that we show using our tool tolerates

647
00:24:19,600 --> 00:24:23,360
a leakage a certain leakage probability

648
00:24:22,159 --> 00:24:27,200
with a complexity

649
00:24:23,360 --> 00:24:29,760
depending on the security parameter

650
00:24:27,200 --> 00:24:31,840
and last but not least we also provide a

651
00:24:29,760 --> 00:24:32,799
full implementation of the expansion

652
00:24:31,840 --> 00:24:36,000
strategy

653
00:24:32,799 --> 00:24:38,240
that operates on small circuits and we

654
00:24:36,000 --> 00:24:41,279
provide an implementation of the aes

655
00:24:38,240 --> 00:24:42,640
algorithm in c language that uses the

656
00:24:41,279 --> 00:24:45,039
expanded gadgets

657
00:24:42,640 --> 00:24:47,360
as a concrete example of usage of the

658
00:24:45,039 --> 00:24:49,679
expansion procedure

659
00:24:47,360 --> 00:24:52,959
and finally for further works we aim to

660
00:24:49,679 --> 00:24:55,760
look more into complexity and tolerated

661
00:24:52,960 --> 00:24:57,679
leakage probability trade-offs and we

662
00:24:55,760 --> 00:25:00,559
also try to look more into

663
00:24:57,679 --> 00:25:03,039
generic generic constructions that

664
00:25:00,559 --> 00:25:05,760
satisfy the introduced properties

665
00:25:03,039 --> 00:25:07,360
for any number of shares rather than a

666
00:25:05,760 --> 00:25:09,360
fixed one

667
00:25:07,360 --> 00:25:10,879
this will be the end of my presentation

668
00:25:09,360 --> 00:25:15,120
and i would like to thank you all for

669
00:25:10,880 --> 00:25:15,120
your attention

