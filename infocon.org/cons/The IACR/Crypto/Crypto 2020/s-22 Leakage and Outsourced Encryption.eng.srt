1
00:00:03,280 --> 00:00:06,880
and you should be good to go

2
00:00:04,640 --> 00:00:06,880
yes

3
00:00:08,400 --> 00:00:11,599
okay so good morning good afternoon good

4
00:00:11,120 --> 00:00:13,840
evening

5
00:00:11,599 --> 00:00:15,200
uh depending on where you are welcome to

6
00:00:13,840 --> 00:00:18,320
this session on

7
00:00:15,200 --> 00:00:19,600
leakage and outsource encryption which

8
00:00:18,320 --> 00:00:22,320
will be chaired by

9
00:00:19,600 --> 00:00:23,199
me and anant raghunatha my name is leila

10
00:00:22,320 --> 00:00:25,199
battina

11
00:00:23,199 --> 00:00:27,519
and we are together sharing this session

12
00:00:25,199 --> 00:00:30,720
so try to

13
00:00:27,519 --> 00:00:32,640
make sure everything goes smoothly and

14
00:00:30,720 --> 00:00:34,640
that all your pa all your questions and

15
00:00:32,640 --> 00:00:38,160
comments are also addressed

16
00:00:34,640 --> 00:00:40,719
so in this session we have uh six talks

17
00:00:38,160 --> 00:00:41,519
six presentations uh each will take five

18
00:00:40,719 --> 00:00:43,760
minutes as

19
00:00:41,520 --> 00:00:44,960
in other sessions and then there is also

20
00:00:43,760 --> 00:00:47,599
some time for questions

21
00:00:44,960 --> 00:00:48,079
i believe also five minutes so the first

22
00:00:47,600 --> 00:00:51,280
talk

23
00:00:48,079 --> 00:00:53,760
is uh on random probing security

24
00:00:51,280 --> 00:00:55,520
verification composition expansion and

25
00:00:53,760 --> 00:00:58,640
new constructions

26
00:00:55,520 --> 00:01:01,120
uh by a number of cultures uh

27
00:00:58,640 --> 00:01:02,079
which i won't read them all but uh abdul

28
00:01:01,120 --> 00:01:05,840
rahman taleb

29
00:01:02,079 --> 00:01:09,680
will present the doc the floor is yours

30
00:01:05,840 --> 00:01:12,159
hi everybody are you seeing the slide

31
00:01:09,680 --> 00:01:13,920
okay yes we are okay i will be

32
00:01:12,159 --> 00:01:15,280
presenting our work about the random

33
00:01:13,920 --> 00:01:18,479
probing security of

34
00:01:15,280 --> 00:01:20,000
masking screens uh against side channel

35
00:01:18,479 --> 00:01:22,320
attacks

36
00:01:20,000 --> 00:01:23,119
so usually when algorithms are

37
00:01:22,320 --> 00:01:25,520
implemented on

38
00:01:23,119 --> 00:01:27,600
embedded devices they become vulnerable

39
00:01:25,520 --> 00:01:29,439
to side channel analysis

40
00:01:27,600 --> 00:01:31,439
where an adversary can deduce

41
00:01:29,439 --> 00:01:33,839
information about on the

42
00:01:31,439 --> 00:01:35,600
secret from measurements such as power

43
00:01:33,840 --> 00:01:38,000
consumption for example

44
00:01:35,600 --> 00:01:39,919
and so to protect implementations one of

45
00:01:38,000 --> 00:01:42,960
the most popular counter measures

46
00:01:39,920 --> 00:01:44,640
is the masking scheme the idea is to

47
00:01:42,960 --> 00:01:47,600
split a sensitive variable

48
00:01:44,640 --> 00:01:49,600
into n values where all the values

49
00:01:47,600 --> 00:01:51,600
except for the last one are generated

50
00:01:49,600 --> 00:01:53,600
uniformly at random

51
00:01:51,600 --> 00:01:54,798
and this helps break the dependence of

52
00:01:53,600 --> 00:01:58,320
the secret

53
00:01:54,799 --> 00:01:59,759
with any set of n minus one value and in

54
00:01:58,320 --> 00:02:01,758
this example you can see that the

55
00:01:59,759 --> 00:02:02,479
operation i use is the door for a

56
00:02:01,759 --> 00:02:04,159
boolean

57
00:02:02,479 --> 00:02:06,079
masking but it can be any other

58
00:02:04,159 --> 00:02:08,560
operation

59
00:02:06,079 --> 00:02:10,318
and so usually the theoretical security

60
00:02:08,560 --> 00:02:13,520
of masking schemes is proven

61
00:02:10,318 --> 00:02:15,200
under certain leakage models and models

62
00:02:13,520 --> 00:02:17,200
vary in terms of convenience for

63
00:02:15,200 --> 00:02:18,160
security proofs and closeness to the

64
00:02:17,200 --> 00:02:21,200
reality of

65
00:02:18,160 --> 00:02:23,520
physical leakage in the state of vr

66
00:02:21,200 --> 00:02:25,280
the most widely used one is the probing

67
00:02:23,520 --> 00:02:27,360
model where we consider that

68
00:02:25,280 --> 00:02:29,440
two variables of an algorithm leak

69
00:02:27,360 --> 00:02:31,920
during an execution

70
00:02:29,440 --> 00:02:33,280
but to better approach the reality of

71
00:02:31,920 --> 00:02:34,879
physical leakage

72
00:02:33,280 --> 00:02:37,440
the community have been trying to

73
00:02:34,879 --> 00:02:39,518
establish security in other models

74
00:02:37,440 --> 00:02:40,800
now our work focuses on the random

75
00:02:39,519 --> 00:02:42,800
probing model

76
00:02:40,800 --> 00:02:44,879
since there is a tight reduction from

77
00:02:42,800 --> 00:02:46,959
this model to the noisy leakage model

78
00:02:44,879 --> 00:02:50,160
and is still easier to prove and

79
00:02:46,959 --> 00:02:54,160
actually not a lot of work have tried to

80
00:02:50,160 --> 00:02:54,160
reason in the random probing model

81
00:02:54,319 --> 00:02:58,720
so we formalize an algorithm as a

82
00:02:56,640 --> 00:03:01,119
circuit which is a directed graph

83
00:02:58,720 --> 00:03:02,879
with variables as edges and operation

84
00:03:01,120 --> 00:03:04,560
gates as vertices

85
00:03:02,879 --> 00:03:06,640
and in the random probing model each

86
00:03:04,560 --> 00:03:09,120
variable leaks independently

87
00:03:06,640 --> 00:03:10,720
with a certain probability p except for

88
00:03:09,120 --> 00:03:12,560
the output variables

89
00:03:10,720 --> 00:03:14,239
and such a circuit is said to be a

90
00:03:12,560 --> 00:03:17,360
random probing secure

91
00:03:14,239 --> 00:03:20,239
if any set of intermediate variables is

92
00:03:17,360 --> 00:03:22,319
independent of the secret inputs a

93
00:03:20,239 --> 00:03:25,040
failure probability epsilon

94
00:03:22,319 --> 00:03:26,640
is associated to this security which

95
00:03:25,040 --> 00:03:29,679
determines the sets that

96
00:03:26,640 --> 00:03:32,000
reveal information about the secret

97
00:03:29,680 --> 00:03:33,920
and for this we provide a formal

98
00:03:32,000 --> 00:03:34,799
verification tool that we like to call

99
00:03:33,920 --> 00:03:37,280
graphs

100
00:03:34,799 --> 00:03:38,799
which given any small circuit computes

101
00:03:37,280 --> 00:03:41,920
the parameters

102
00:03:38,799 --> 00:03:44,560
the parameter epsilon as a function of p

103
00:03:41,920 --> 00:03:47,839
for which the circuit is p epsilon

104
00:03:44,560 --> 00:03:47,840
random probing secure

105
00:03:48,400 --> 00:03:52,239
and next we provide a new notion of

106
00:03:51,040 --> 00:03:54,079
composition

107
00:03:52,239 --> 00:03:55,439
which allows us to compose small

108
00:03:54,080 --> 00:03:58,000
circuits or what we call

109
00:03:55,439 --> 00:03:59,519
gadgets into a global random probing

110
00:03:58,000 --> 00:04:02,319
secure circuit

111
00:03:59,519 --> 00:04:04,640
now in a nutshell if we have gadgets for

112
00:04:02,319 --> 00:04:07,200
each of the basic data operations

113
00:04:04,640 --> 00:04:08,720
that are a random probing composable for

114
00:04:07,200 --> 00:04:12,159
certain parameters t

115
00:04:08,720 --> 00:04:15,200
and epsilon we show that using them to

116
00:04:12,159 --> 00:04:17,279
construct a circuit uh big circuit

117
00:04:15,200 --> 00:04:18,399
results in a global random probing

118
00:04:17,279 --> 00:04:21,518
secure one

119
00:04:18,399 --> 00:04:23,440
for parameters p and epsilon times the

120
00:04:21,519 --> 00:04:26,720
size of the original circuit

121
00:04:23,440 --> 00:04:26,719
and the number of its gates

122
00:04:27,120 --> 00:04:31,520
and in addition to composing gadgets for

123
00:04:29,520 --> 00:04:33,440
global random program security

124
00:04:31,520 --> 00:04:36,560
we exhibit an expansion strategy

125
00:04:33,440 --> 00:04:39,520
inspired from work from 2018

126
00:04:36,560 --> 00:04:40,639
which allows base and share gadgets to

127
00:04:39,520 --> 00:04:43,758
be expanded

128
00:04:40,639 --> 00:04:45,840
and achieve arbitrary security levels

129
00:04:43,759 --> 00:04:47,919
so the idea is to start from a base

130
00:04:45,840 --> 00:04:51,039
circuit with base gates

131
00:04:47,919 --> 00:04:54,240
and replace each wire by n wire carrying

132
00:04:51,040 --> 00:04:57,919
a sharing of the original wire

133
00:04:54,240 --> 00:04:59,759
and so this and each gate will

134
00:04:57,919 --> 00:05:01,280
also be replaced by the corresponding

135
00:04:59,759 --> 00:05:03,199
gadgets

136
00:05:01,280 --> 00:05:04,960
and this strategy allows to replace

137
00:05:03,199 --> 00:05:07,120
their leakage probability p

138
00:05:04,960 --> 00:05:09,039
by a certain failure event probability

139
00:05:07,120 --> 00:05:11,199
which is a function of t

140
00:05:09,039 --> 00:05:12,800
and this can be applied recursively on

141
00:05:11,199 --> 00:05:15,280
the resulting circuit

142
00:05:12,800 --> 00:05:17,680
reducing the failure probability until

143
00:05:15,280 --> 00:05:20,080
we reach a certain security level

144
00:05:17,680 --> 00:05:23,039
amplified to the case level which we

145
00:05:20,080 --> 00:05:25,198
call the amplification level

146
00:05:23,039 --> 00:05:26,400
and we show in our work that to execute

147
00:05:25,199 --> 00:05:29,280
this the gadgets

148
00:05:26,400 --> 00:05:30,239
should be random probing expandable and

149
00:05:29,280 --> 00:05:32,960
if that's the case

150
00:05:30,240 --> 00:05:35,120
then the resulting expanded circuit will

151
00:05:32,960 --> 00:05:37,120
also be a random probing secure

152
00:05:35,120 --> 00:05:40,880
with a failure of probability to the

153
00:05:37,120 --> 00:05:40,880
power k the expansion level

154
00:05:41,280 --> 00:05:44,799
and after this we are able to

155
00:05:42,720 --> 00:05:47,600
instantiate the expansion strategy

156
00:05:44,800 --> 00:05:49,520
with a three share gadgets construction

157
00:05:47,600 --> 00:05:50,479
that we show our random probing

158
00:05:49,520 --> 00:05:53,440
expandable

159
00:05:50,479 --> 00:05:55,440
using our verification pool graphs and

160
00:05:53,440 --> 00:05:56,639
we show that they can tolerate a leakage

161
00:05:55,440 --> 00:05:59,039
probability

162
00:05:56,639 --> 00:05:59,680
of about two to the minus eight with an

163
00:05:59,039 --> 00:06:02,400
asymptote

164
00:05:59,680 --> 00:06:03,840
asymptotic complexity in kappa to the

165
00:06:02,400 --> 00:06:04,479
seventh quarter to the power of seven

166
00:06:03,840 --> 00:06:05,758
point five

167
00:06:04,479 --> 00:06:08,800
we kappa capitalize the security

168
00:06:05,759 --> 00:06:10,479
parameter in comparison we exhibit the

169
00:06:08,800 --> 00:06:13,600
instantiation

170
00:06:10,479 --> 00:06:16,318
provided in the original work from 2018

171
00:06:13,600 --> 00:06:18,720
which tolerates a much lower probability

172
00:06:16,319 --> 00:06:21,039
of about 2 to the minus 25

173
00:06:18,720 --> 00:06:23,840
with an asymptotic complexity that is

174
00:06:21,039 --> 00:06:23,840
close to ours

175
00:06:24,160 --> 00:06:28,479
so the takeaway from our work is the

176
00:06:26,639 --> 00:06:31,120
introduction of a new formal

177
00:06:28,479 --> 00:06:33,120
verification tool for security of

178
00:06:31,120 --> 00:06:34,880
any small circuit or gadget in the

179
00:06:33,120 --> 00:06:37,360
random probing model

180
00:06:34,880 --> 00:06:39,039
we also introduced new notions of

181
00:06:37,360 --> 00:06:42,160
composition and expansion

182
00:06:39,039 --> 00:06:44,479
for achieving global random probing

183
00:06:42,160 --> 00:06:46,080
security levels by using small secure

184
00:06:44,479 --> 00:06:48,318
base gadgets

185
00:06:46,080 --> 00:06:50,400
and finally we instantiate this notion

186
00:06:48,319 --> 00:06:53,199
with a concrete construction

187
00:06:50,400 --> 00:06:55,198
that we show using our tool tolerate a

188
00:06:53,199 --> 00:06:56,960
probability a leakage probability of

189
00:06:55,199 --> 00:06:59,120
about 2 to the minus 8

190
00:06:56,960 --> 00:07:00,799
with a complexity in terms of the size

191
00:06:59,120 --> 00:07:04,000
of the circuit c

192
00:07:00,800 --> 00:07:06,800
and the security parameter to the 7.5

193
00:07:04,000 --> 00:07:06,800
thank you very much

194
00:07:08,800 --> 00:07:14,880
thank you anand thank you for the talk

195
00:07:12,160 --> 00:07:17,840
do we have questions from the audience

196
00:07:14,880 --> 00:07:17,840
or comments

197
00:07:19,360 --> 00:07:22,800
so no no questions so far uh let me

198
00:07:21,440 --> 00:07:24,319
check the

199
00:07:22,800 --> 00:07:26,800
uh check this out chat again just a

200
00:07:24,319 --> 00:07:28,319
reminder and post your questions here

201
00:07:26,800 --> 00:07:30,560
on zoom but you can also post them on

202
00:07:28,319 --> 00:07:32,160
the zooloop chat because that way

203
00:07:30,560 --> 00:07:33,599
it's persistent and people can answer

204
00:07:32,160 --> 00:07:36,800
questions after this once uh

205
00:07:33,599 --> 00:07:36,800
zoom session is over

206
00:07:37,520 --> 00:07:40,960
so there are there are no questions i so

207
00:07:39,680 --> 00:07:42,800
i sort of

208
00:07:40,960 --> 00:07:44,000
i had a quick question i don't think you

209
00:07:42,800 --> 00:07:46,560
mentioned this in the talk but

210
00:07:44,000 --> 00:07:47,599
it's in the paper um i noticed that

211
00:07:46,560 --> 00:07:50,000
there is a

212
00:07:47,599 --> 00:07:50,878
p to the three halves uh parameter in

213
00:07:50,000 --> 00:07:52,800
one of the

214
00:07:50,879 --> 00:07:54,080
expressions uh where you're trying to

215
00:07:52,800 --> 00:07:56,560
basically i think um

216
00:07:54,080 --> 00:07:57,520
tie down epsilon and the probability of

217
00:07:56,560 --> 00:07:58,560
a random failure

218
00:07:57,520 --> 00:08:00,560
i was just curious if we had an

219
00:07:58,560 --> 00:08:03,440
intuition around that sort of

220
00:08:00,560 --> 00:08:03,440
three-halves exponent

221
00:08:04,080 --> 00:08:08,800
oh in the instantiation you mean above

222
00:08:06,319 --> 00:08:11,440
our construction

223
00:08:08,800 --> 00:08:12,080
yeah because actually the three half

224
00:08:11,440 --> 00:08:15,120
comes

225
00:08:12,080 --> 00:08:17,680
mostly from the failure function of the

226
00:08:15,120 --> 00:08:19,120
of the multiplication gadget because if

227
00:08:17,680 --> 00:08:21,120
you can see in our paper for

228
00:08:19,120 --> 00:08:22,639
the epsilon in the random probing

229
00:08:21,120 --> 00:08:24,400
expandability property

230
00:08:22,639 --> 00:08:25,919
you have a failure that is independent

231
00:08:24,400 --> 00:08:28,080
for each of the input

232
00:08:25,919 --> 00:08:29,680
and you have failure that is

233
00:08:28,080 --> 00:08:33,039
unbelievable

234
00:08:29,680 --> 00:08:33,440
and the lower authentication budget will

235
00:08:33,039 --> 00:08:36,319
be

236
00:08:33,440 --> 00:08:38,000
the maximum between the failure on each

237
00:08:36,320 --> 00:08:38,800
of the inputs independently and the

238
00:08:38,000 --> 00:08:42,080
square root

239
00:08:38,799 --> 00:08:44,159
of the failure on both inputs and so

240
00:08:42,080 --> 00:08:46,320
the function that is computed by our

241
00:08:44,159 --> 00:08:49,760
tool for the multiplication gadgets

242
00:08:46,320 --> 00:08:53,279
i had a code had a power of

243
00:08:49,760 --> 00:08:54,319
3 actually but this power of 3 was a

244
00:08:53,279 --> 00:08:56,560
failure on both

245
00:08:54,320 --> 00:08:57,519
inputs one and two and so taking its

246
00:08:56,560 --> 00:08:59,680
square root

247
00:08:57,519 --> 00:09:01,440
the final function will have the power

248
00:08:59,680 --> 00:09:04,160
of three over two

249
00:09:01,440 --> 00:09:06,240
as a video so thank you you're welcome

250
00:09:04,160 --> 00:09:07,920
uh maybe a quick question also from my

251
00:09:06,240 --> 00:09:09,040
side so you didn't talk much about

252
00:09:07,920 --> 00:09:10,959
performance

253
00:09:09,040 --> 00:09:12,560
issues in this short talk but i remember

254
00:09:10,959 --> 00:09:16,239
some things from the paper so

255
00:09:12,560 --> 00:09:19,279
especially the new construction so uh

256
00:09:16,240 --> 00:09:21,120
like mostly with respect to randomness

257
00:09:19,279 --> 00:09:22,399
how practical do you think this new

258
00:09:21,120 --> 00:09:25,839
construction is

259
00:09:22,399 --> 00:09:28,560
kind of for real world applications

260
00:09:25,839 --> 00:09:29,920
so we show in our paper that uh with our

261
00:09:28,560 --> 00:09:31,599
instantiation when

262
00:09:29,920 --> 00:09:34,479
expanded it to achieve a certain

263
00:09:31,600 --> 00:09:36,800
security level the more we expand it

264
00:09:34,480 --> 00:09:38,480
the more costly it will be but it should

265
00:09:36,800 --> 00:09:39,279
be noted also that the construction that

266
00:09:38,480 --> 00:09:42,480
we provide

267
00:09:39,279 --> 00:09:49,920
is a concrete example of uh just to show

268
00:09:42,480 --> 00:09:52,000
how the expansion strategy works

269
00:09:49,920 --> 00:09:52,560
tolerated leakage probability also so

270
00:09:52,000 --> 00:09:55,040
maybe

271
00:09:52,560 --> 00:09:56,479
our instantiation to achieve a high

272
00:09:55,040 --> 00:09:58,560
security level is not very

273
00:09:56,480 --> 00:10:00,000
well adapted but we have found other

274
00:09:58,560 --> 00:10:01,760
constructions that

275
00:10:00,000 --> 00:10:03,440
have a higher amplification order for

276
00:10:01,760 --> 00:10:06,399
example and so

277
00:10:03,440 --> 00:10:07,680
they don't need a a high level of

278
00:10:06,399 --> 00:10:10,959
expansion

279
00:10:07,680 --> 00:10:12,959
so they should be more practical to use

280
00:10:10,959 --> 00:10:15,839
so it's actually an open problem to find

281
00:10:12,959 --> 00:10:19,279
the best instantiation

282
00:10:15,839 --> 00:10:22,399
okay thank you yeah i guess

283
00:10:19,279 --> 00:10:23,760
we're good to go further thanks again

284
00:10:22,399 --> 00:10:25,040
just just before we move to the next

285
00:10:23,760 --> 00:10:26,399
speaker later there's one more question

286
00:10:25,040 --> 00:10:27,599
on the zooloop chat that you just want

287
00:10:26,399 --> 00:10:28,480
to call attention absolutely you can

288
00:10:27,600 --> 00:10:29,920
respond to them

289
00:10:28,480 --> 00:10:32,480
privately and you can respond to them in

290
00:10:29,920 --> 00:10:32,479
this sort of chat

291
00:10:42,640 --> 00:10:49,279
okay so uh may we move on uh

292
00:10:46,160 --> 00:10:52,399
fx can you share the slides yes so great

293
00:10:49,279 --> 00:10:53,279
uh our next speaker is francoxavia

294
00:10:52,399 --> 00:10:57,440
standard

295
00:10:53,279 --> 00:11:00,079
again a big group of quarters

296
00:10:57,440 --> 00:11:01,279
uh so i only mentioned uh the speaker so

297
00:11:00,079 --> 00:11:05,120
you can all read that

298
00:11:01,279 --> 00:11:07,839
and uh uh also see in the paper so

299
00:11:05,120 --> 00:11:09,279
the talk is mode level versus

300
00:11:07,839 --> 00:11:11,760
implementation level

301
00:11:09,279 --> 00:11:13,279
physical security in symmetric crypto a

302
00:11:11,760 --> 00:11:14,000
practical guide through the leakage

303
00:11:13,279 --> 00:11:17,680
resistance

304
00:11:14,000 --> 00:11:20,240
jungle fx go ahead

305
00:11:17,680 --> 00:11:21,120
thank you so i will also try to to

306
00:11:20,240 --> 00:11:24,240
summarize

307
00:11:21,120 --> 00:11:25,920
the results we have um and for

308
00:11:24,240 --> 00:11:27,279
motivation or introduction i will start

309
00:11:25,920 --> 00:11:29,279
with the least lightweight crypto

310
00:11:27,279 --> 00:11:30,480
competition so at the moment the nist is

311
00:11:29,279 --> 00:11:34,160
trying to standardize

312
00:11:30,480 --> 00:11:36,720
new authenticated encryption schemes

313
00:11:34,160 --> 00:11:38,000
with hopefully good features for light

314
00:11:36,720 --> 00:11:41,040
rate implementations

315
00:11:38,000 --> 00:11:42,160
and side channel resistance and

316
00:11:41,040 --> 00:11:44,399
therefore we have many

317
00:11:42,160 --> 00:11:46,480
candidates this designed with leakage in

318
00:11:44,399 --> 00:11:48,079
mind

319
00:11:46,480 --> 00:11:49,519
sometimes it's working at a primitive

320
00:11:48,079 --> 00:11:51,279
level like typically we have block

321
00:11:49,519 --> 00:11:52,880
ciphers and permutations that try to

322
00:11:51,279 --> 00:11:55,279
minimize the number of

323
00:11:52,880 --> 00:11:56,639
nonlinear components sometimes it's

324
00:11:55,279 --> 00:11:59,600
working at the mode level

325
00:11:56,639 --> 00:12:01,040
and and then it's using different uh

326
00:11:59,600 --> 00:12:03,360
design tricks

327
00:12:01,040 --> 00:12:04,319
so as typical example some one one thing

328
00:12:03,360 --> 00:12:07,040
that is popular

329
00:12:04,320 --> 00:12:09,440
is playing with ephemeral key evolution

330
00:12:07,040 --> 00:12:11,040
so there you you generate a fresh key

331
00:12:09,440 --> 00:12:13,440
and you make the key evolve through the

332
00:12:11,040 --> 00:12:17,360
computation in order to

333
00:12:13,440 --> 00:12:19,440
improve confidentiality with leakage and

334
00:12:17,360 --> 00:12:21,360
something else that is used is using key

335
00:12:19,440 --> 00:12:23,120
generation functions and tag generation

336
00:12:21,360 --> 00:12:24,880
functions that are strengthened

337
00:12:23,120 --> 00:12:27,040
against side channel attacks both for

338
00:12:24,880 --> 00:12:29,920
integrity and confidentiality

339
00:12:27,040 --> 00:12:31,680
and for example sometimes we also use to

340
00:12:29,920 --> 00:12:32,160
pass designs in order to better cope

341
00:12:31,680 --> 00:12:35,519
with

342
00:12:32,160 --> 00:12:36,959
decryption leakage so all these

343
00:12:35,519 --> 00:12:38,880
and their orders in fact all these are

344
00:12:36,959 --> 00:12:41,680
intuitively appealing ideas

345
00:12:38,880 --> 00:12:43,360
and maybe one limitation is that the

346
00:12:41,680 --> 00:12:45,199
constructions rarely come with

347
00:12:43,360 --> 00:12:46,560
explicitly

348
00:12:45,200 --> 00:12:48,720
explicit specifications of the

349
00:12:46,560 --> 00:12:50,160
guarantees they provide and

350
00:12:48,720 --> 00:12:52,000
the the physical assumptions they

351
00:12:50,160 --> 00:12:53,839
require which makes things a little bit

352
00:12:52,000 --> 00:12:55,519
difficult to compare

353
00:12:53,839 --> 00:12:57,920
and the goal of this paper is really to

354
00:12:55,519 --> 00:13:00,720
try using the leakage resistance

355
00:12:57,920 --> 00:13:02,800
literature in order to

356
00:13:00,720 --> 00:13:04,959
clarify a little bit this state of the

357
00:13:02,800 --> 00:13:07,439
art

358
00:13:04,959 --> 00:13:09,119
so for this we are going to use um

359
00:13:07,440 --> 00:13:10,480
authenticated encryption schemes that we

360
00:13:09,120 --> 00:13:14,079
split in four parts

361
00:13:10,480 --> 00:13:15,920
as i already said so um the first part

362
00:13:14,079 --> 00:13:17,359
is the key generation function which is

363
00:13:15,920 --> 00:13:18,880
optional and then you have the bulk

364
00:13:17,360 --> 00:13:20,560
computation which processes

365
00:13:18,880 --> 00:13:22,240
the message blocks then the tag

366
00:13:20,560 --> 00:13:26,319
generation function and

367
00:13:22,240 --> 00:13:28,480
finally the verification in the

368
00:13:26,320 --> 00:13:29,360
formal part of the work what we do which

369
00:13:28,480 --> 00:13:31,680
is as usual

370
00:13:29,360 --> 00:13:32,800
is trying to reduce the security of the

371
00:13:31,680 --> 00:13:34,638
mode to some

372
00:13:32,800 --> 00:13:36,079
combination of physical and mathematical

373
00:13:34,639 --> 00:13:38,800
assumptions

374
00:13:36,079 --> 00:13:40,319
and there one problem that we have is

375
00:13:38,800 --> 00:13:42,399
that

376
00:13:40,320 --> 00:13:43,440
you have many competing physical

377
00:13:42,399 --> 00:13:45,680
assumptions in the

378
00:13:43,440 --> 00:13:46,639
literature most of them coming with pros

379
00:13:45,680 --> 00:13:49,279
and cons

380
00:13:46,639 --> 00:13:51,519
no complete agreement on what to use and

381
00:13:49,279 --> 00:13:53,519
most of the times for current analysis

382
00:13:51,519 --> 00:13:55,279
people combine several assumptions in

383
00:13:53,519 --> 00:13:56,959
order to try gaining

384
00:13:55,279 --> 00:13:59,199
insights about the security of the

385
00:13:56,959 --> 00:14:01,199
schemes so this also makes things a

386
00:13:59,199 --> 00:14:03,920
little bit difficult to compare

387
00:14:01,199 --> 00:14:05,599
and in this respect a first observation

388
00:14:03,920 --> 00:14:06,800
in the in the paper is that if you try

389
00:14:05,600 --> 00:14:09,440
to translate

390
00:14:06,800 --> 00:14:11,359
all these assumptions into necessary

391
00:14:09,440 --> 00:14:14,079
design goals you can really simplify

392
00:14:11,360 --> 00:14:17,120
them into two main security conditions

393
00:14:14,079 --> 00:14:18,079
that we call the dpa security and spa

394
00:14:17,120 --> 00:14:19,839
security

395
00:14:18,079 --> 00:14:22,160
so these are two types of attacks that

396
00:14:19,839 --> 00:14:24,720
would be analyzed by um

397
00:14:22,160 --> 00:14:25,439
evaluation labs nowadays so dps security

398
00:14:24,720 --> 00:14:27,040
means

399
00:14:25,440 --> 00:14:28,800
that we need to prevent attacks where

400
00:14:27,040 --> 00:14:31,040
the adversary can

401
00:14:28,800 --> 00:14:32,240
observe the leakage of the primitive for

402
00:14:31,040 --> 00:14:34,399
several inputs

403
00:14:32,240 --> 00:14:36,880
or many different inputs and spss

404
00:14:34,399 --> 00:14:38,320
security is the same but

405
00:14:36,880 --> 00:14:40,560
the adversary can only observe the

406
00:14:38,320 --> 00:14:42,959
leakage of a few inputs

407
00:14:40,560 --> 00:14:44,719
and typically dpa security will be to

408
00:14:42,959 --> 00:14:46,959
protect long-term secrets and

409
00:14:44,720 --> 00:14:48,160
sps security is more related to

410
00:14:46,959 --> 00:14:51,119
ephemeral secrets

411
00:14:48,160 --> 00:14:52,800
and interestingly as put in the table at

412
00:14:51,120 --> 00:14:53,839
the bottom of the table for integrity

413
00:14:52,800 --> 00:14:56,079
guarantees we can

414
00:14:53,839 --> 00:14:58,000
sometimes even tolerate unbounded

415
00:14:56,079 --> 00:15:00,000
leakage which means that for some part

416
00:14:58,000 --> 00:15:03,839
of the implementation we can give

417
00:15:00,000 --> 00:15:03,839
absolutely everything to the adversary

418
00:15:04,320 --> 00:15:10,399
so to try giving some intuition about

419
00:15:07,680 --> 00:15:12,479
why using weaker physical assumptions is

420
00:15:10,399 --> 00:15:14,480
very relevant in practice

421
00:15:12,480 --> 00:15:16,000
this table summarize or give some

422
00:15:14,480 --> 00:15:17,680
approximate numbers for the the

423
00:15:16,000 --> 00:15:18,000
performance overheads that you will need

424
00:15:17,680 --> 00:15:20,800
for

425
00:15:18,000 --> 00:15:22,880
dpa security and spa security and the

426
00:15:20,800 --> 00:15:25,680
summary is that dpa security is

427
00:15:22,880 --> 00:15:26,399
very expensive the overheads can be by a

428
00:15:25,680 --> 00:15:30,479
factor

429
00:15:26,399 --> 00:15:32,639
100 or more um sps security let's say

430
00:15:30,480 --> 00:15:33,519
it's moderately expensive so factor one

431
00:15:32,639 --> 00:15:35,040
to five

432
00:15:33,519 --> 00:15:36,560
and of course when you tolerate

433
00:15:35,040 --> 00:15:37,759
unbounded leakage you can use the

434
00:15:36,560 --> 00:15:41,439
implementation as this

435
00:15:37,759 --> 00:15:42,800
and then it is very efficient

436
00:15:41,440 --> 00:15:44,880
so that's one thing the second thing

437
00:15:42,800 --> 00:15:47,199
that we try to simplify in the paper

438
00:15:44,880 --> 00:15:48,000
is the the definitional framework that

439
00:15:47,199 --> 00:15:50,719
we have

440
00:15:48,000 --> 00:15:52,560
in leakage resistance because currently

441
00:15:50,720 --> 00:15:54,160
in the literature you have many possible

442
00:15:52,560 --> 00:15:56,319
security targets

443
00:15:54,160 --> 00:15:57,759
so this is somehow to some extent

444
00:15:56,320 --> 00:15:59,839
unavoidable because

445
00:15:57,759 --> 00:16:02,240
uh in this physical world the use of

446
00:15:59,839 --> 00:16:05,600
composite definitions where you separate

447
00:16:02,240 --> 00:16:07,920
confidentiality and integrity are this

448
00:16:05,600 --> 00:16:09,920
is interesting because what you need

449
00:16:07,920 --> 00:16:11,680
physically to guarantee confidentiality

450
00:16:09,920 --> 00:16:12,639
and integrity can be very different and

451
00:16:11,680 --> 00:16:14,719
for example

452
00:16:12,639 --> 00:16:17,920
tolerating unbounded leakage you can

453
00:16:14,720 --> 00:16:20,079
only do that with integrity guarantees

454
00:16:17,920 --> 00:16:21,199
so we keep that but we still try to

455
00:16:20,079 --> 00:16:24,479
organize

456
00:16:21,199 --> 00:16:26,000
all these definitions in a more limited

457
00:16:24,480 --> 00:16:28,000
fashion with different grades and

458
00:16:26,000 --> 00:16:28,880
essentially for confidentiality we will

459
00:16:28,000 --> 00:16:31,279
use

460
00:16:28,880 --> 00:16:32,399
cca security for integrity ciphertext

461
00:16:31,279 --> 00:16:34,160
integrity

462
00:16:32,399 --> 00:16:36,560
for leakage we consider leakage in

463
00:16:34,160 --> 00:16:38,560
encryption only this is the l1 notation

464
00:16:36,560 --> 00:16:40,959
and leakage in encryption and decryption

465
00:16:38,560 --> 00:16:42,399
this is the l2 notation and we

466
00:16:40,959 --> 00:16:43,439
additionally consider some kind of

467
00:16:42,399 --> 00:16:44,959
misuse

468
00:16:43,440 --> 00:16:47,040
which comes with some technical

469
00:16:44,959 --> 00:16:48,319
technicalities that i leave for the long

470
00:16:47,040 --> 00:16:52,240
version of the talk or

471
00:16:48,320 --> 00:16:54,240
the paper and based on all that

472
00:16:52,240 --> 00:16:56,480
the type of results that we have is

473
00:16:54,240 --> 00:16:58,320
summarized in this table

474
00:16:56,480 --> 00:17:00,240
so the idea is that we can take

475
00:16:58,320 --> 00:17:03,839
different authenticated encryption

476
00:17:00,240 --> 00:17:06,000
schemes here i give the example with six

477
00:17:03,839 --> 00:17:07,280
all of them are split in different parts

478
00:17:06,000 --> 00:17:09,039
right key generation

479
00:17:07,280 --> 00:17:11,599
message processing verification and so

480
00:17:09,039 --> 00:17:12,480
on and we have the different security

481
00:17:11,599 --> 00:17:15,839
targets

482
00:17:12,480 --> 00:17:18,799
for confidentiality and for integrity

483
00:17:15,839 --> 00:17:20,559
and the table essentially tells hardware

484
00:17:18,799 --> 00:17:21,839
engineers what they have to satisfy so

485
00:17:20,559 --> 00:17:24,959
if i take one example

486
00:17:21,839 --> 00:17:26,480
extreme sorry example ocb is a mode of

487
00:17:24,959 --> 00:17:28,160
operation that doesn't come with

488
00:17:26,480 --> 00:17:30,400
any leakage resistance guarantee so

489
00:17:28,160 --> 00:17:32,640
there you will really ask hardware

490
00:17:30,400 --> 00:17:34,160
engineer to guarantee to ensure dpa

491
00:17:32,640 --> 00:17:36,240
security for all the parts of the

492
00:17:34,160 --> 00:17:38,960
implementation

493
00:17:36,240 --> 00:17:40,960
and at the other extreme if i take tdt

494
00:17:38,960 --> 00:17:42,480
this is a mode with strong

495
00:17:40,960 --> 00:17:44,640
leakage resistance guarantees but of

496
00:17:42,480 --> 00:17:47,280
course it's also more expensive

497
00:17:44,640 --> 00:17:48,880
in this case you still need dpa security

498
00:17:47,280 --> 00:17:50,480
for the key generation function and the

499
00:17:48,880 --> 00:17:52,799
tag generation function

500
00:17:50,480 --> 00:17:54,080
but all the rest uh has weaker

501
00:17:52,799 --> 00:17:55,840
requirements so for

502
00:17:54,080 --> 00:17:57,600
confidentiality everything is

503
00:17:55,840 --> 00:17:59,678
essentially espa security

504
00:17:57,600 --> 00:18:00,719
and for integrity you can leak and burn

505
00:17:59,679 --> 00:18:03,039
that for all the rest

506
00:18:00,720 --> 00:18:04,960
of the implementation and what's

507
00:18:03,039 --> 00:18:06,960
interesting here is that you can really

508
00:18:04,960 --> 00:18:09,039
it motivates this idea of of leveled

509
00:18:06,960 --> 00:18:10,080
implementations where you

510
00:18:09,039 --> 00:18:11,679
have different parts of an

511
00:18:10,080 --> 00:18:13,840
implementation that haven't have

512
00:18:11,679 --> 00:18:15,760
different levels of security against

513
00:18:13,840 --> 00:18:18,799
sectional attacks and therefore

514
00:18:15,760 --> 00:18:20,559
different performance levels

515
00:18:18,799 --> 00:18:22,639
so quickly the conclusion i would say

516
00:18:20,559 --> 00:18:24,480
from from the the theory point of view

517
00:18:22,640 --> 00:18:26,240
the main conclusion or take on message

518
00:18:24,480 --> 00:18:28,320
is that in the field of leakage

519
00:18:26,240 --> 00:18:30,720
resilience there's no single

520
00:18:28,320 --> 00:18:31,520
right definition of authenticated

521
00:18:30,720 --> 00:18:34,240
encryption you

522
00:18:31,520 --> 00:18:35,200
more have a kind of continuous trade-off

523
00:18:34,240 --> 00:18:37,280
between mode level

524
00:18:35,200 --> 00:18:38,720
and implementation level leakage

525
00:18:37,280 --> 00:18:41,600
resistance

526
00:18:38,720 --> 00:18:42,240
and in practice i would say the main

527
00:18:41,600 --> 00:18:44,879
conclusion

528
00:18:42,240 --> 00:18:46,799
is that as the the security level that

529
00:18:44,880 --> 00:18:48,400
you want in practice increases

530
00:18:46,799 --> 00:18:50,559
then of course leveraging more level

531
00:18:48,400 --> 00:18:52,559
guarantees is going to gain interest

532
00:18:50,559 --> 00:18:54,720
and can really lead to significant

533
00:18:52,559 --> 00:18:56,639
significant performance gains

534
00:18:54,720 --> 00:18:58,160
because because all the countermeasures

535
00:18:56,640 --> 00:19:03,360
are actually very expensive

536
00:18:58,160 --> 00:19:03,360
in this field and that's it thank you

537
00:19:04,000 --> 00:19:10,640
thank you thanks fx so

538
00:19:07,039 --> 00:19:12,799
let me check with my co-chair

539
00:19:10,640 --> 00:19:15,280
session coach no no questions from the

540
00:19:12,799 --> 00:19:15,280
audience

541
00:19:15,600 --> 00:19:20,000
no questions okay so maybe a quick

542
00:19:18,960 --> 00:19:22,559
question so

543
00:19:20,000 --> 00:19:24,000
uh you were talking about the overhead

544
00:19:22,559 --> 00:19:27,120
in in the range of uh

545
00:19:24,000 --> 00:19:30,080
factor five two hundred uh yeah

546
00:19:27,120 --> 00:19:31,039
for for dpa uh protection basically so

547
00:19:30,080 --> 00:19:34,240
could you share some

548
00:19:31,039 --> 00:19:37,280
insight uh about what do you expect

549
00:19:34,240 --> 00:19:37,840
to do to be like uh requiring factor of

550
00:19:37,280 --> 00:19:40,320
100

551
00:19:37,840 --> 00:19:40,959
in terms of protection and why really

552
00:19:40,320 --> 00:19:43,678
does it

553
00:19:40,960 --> 00:19:44,480
uh relate to specific design with

554
00:19:43,679 --> 00:19:48,559
candidates

555
00:19:44,480 --> 00:19:52,080
or uh you know security requirements

556
00:19:48,559 --> 00:19:53,840
so yeah so this is

557
00:19:52,080 --> 00:19:55,678
this these are figures that i take from

558
00:19:53,840 --> 00:19:58,559
the masking literature right so it's

559
00:19:55,679 --> 00:19:59,120
isw like masking with large number of

560
00:19:58,559 --> 00:20:01,520
shares

561
00:19:59,120 --> 00:20:03,439
as you would typically need in uh in

562
00:20:01,520 --> 00:20:05,200
software implementations if you want to

563
00:20:03,440 --> 00:20:06,960
reach high security levels so we are

564
00:20:05,200 --> 00:20:09,120
also speaking about

565
00:20:06,960 --> 00:20:11,200
uh attacks that that can cope with two

566
00:20:09,120 --> 00:20:12,959
to the 40

567
00:20:11,200 --> 00:20:16,480
measurements typically so that would

568
00:20:12,960 --> 00:20:18,559
require more than eight shares

569
00:20:16,480 --> 00:20:20,640
yeah yep when you say higher order you

570
00:20:18,559 --> 00:20:23,039
mean then which order

571
00:20:20,640 --> 00:20:24,720
typically i as i said for for this

572
00:20:23,039 --> 00:20:27,520
software platform that we

573
00:20:24,720 --> 00:20:29,039
like arm cortex type of things it's it's

574
00:20:27,520 --> 00:20:31,360
more than eight shares it's be

575
00:20:29,039 --> 00:20:32,480
eight nine ten shares if you want this

576
00:20:31,360 --> 00:20:34,158
security level

577
00:20:32,480 --> 00:20:35,840
and between four and eight shares you

578
00:20:34,159 --> 00:20:37,760
already have some security right you can

579
00:20:35,840 --> 00:20:39,840
tolerate

580
00:20:37,760 --> 00:20:40,879
100 000 measurements one million

581
00:20:39,840 --> 00:20:42,399
something like that

582
00:20:40,880 --> 00:20:46,080
yes but practically speaking do we

583
00:20:42,400 --> 00:20:49,280
really need that high order security

584
00:20:46,080 --> 00:20:51,120
um yeah with it like

585
00:20:49,280 --> 00:20:52,799
1 million 10 million measurements it's

586
00:20:51,120 --> 00:20:54,799
not something that take

587
00:20:52,799 --> 00:20:56,559
days to compute so that that's really

588
00:20:54,799 --> 00:20:58,960
something to decide depending on

589
00:20:56,559 --> 00:21:00,639
on the the application yeah these are

590
00:20:58,960 --> 00:21:02,080
also figures we just had this this

591
00:21:00,640 --> 00:21:04,880
workshop with the list

592
00:21:02,080 --> 00:21:06,799
about standardization of masking schemes

593
00:21:04,880 --> 00:21:10,000
and it was more or less agreed that

594
00:21:06,799 --> 00:21:10,879
that between four to eight shares in

595
00:21:10,000 --> 00:21:12,640
software

596
00:21:10,880 --> 00:21:13,919
was relevant and probably in hardware it

597
00:21:12,640 --> 00:21:15,039
would be a bit less because you have

598
00:21:13,919 --> 00:21:17,039
more noise

599
00:21:15,039 --> 00:21:18,879
and and stronger possibilities to

600
00:21:17,039 --> 00:21:20,559
combine with other countermeasures

601
00:21:18,880 --> 00:21:22,080
yeah sure that is a big distinction

602
00:21:20,559 --> 00:21:24,480
there okay uh

603
00:21:22,080 --> 00:21:25,678
thanks uh is that a question in the

604
00:21:24,480 --> 00:21:27,840
meantime

605
00:21:25,679 --> 00:21:28,840
people's people need some coffee i guess

606
00:21:27,840 --> 00:21:32,720
to wake up

607
00:21:28,840 --> 00:21:35,439
okay uh yeah let's thank the speaker

608
00:21:32,720 --> 00:21:37,440
and maybe proceed to the next talk

609
00:21:35,440 --> 00:21:39,760
thanks again

610
00:21:37,440 --> 00:21:39,760
um

611
00:21:40,880 --> 00:21:47,600
next speaker could you please share

612
00:21:44,000 --> 00:21:47,600
your screen with us

613
00:21:48,159 --> 00:21:55,520
yes it's coming yep can you share it

614
00:21:51,760 --> 00:21:58,240
yes great so next talk is

615
00:21:55,520 --> 00:21:59,120
yeah on leakage resilient key exchange

616
00:21:58,240 --> 00:22:02,480
and two seed

617
00:21:59,120 --> 00:22:05,520
extractors uh and willy quash will

618
00:22:02,480 --> 00:22:06,799
give the talk uh yeah thanks for the

619
00:22:05,520 --> 00:22:09,120
introduction

620
00:22:06,799 --> 00:22:11,280
so as the title suggests in this paper

621
00:22:09,120 --> 00:22:12,799
we study leakage resilience for

622
00:22:11,280 --> 00:22:16,320
exchange and this is join work with

623
00:22:12,799 --> 00:22:16,320
cindy lee farmier and daniel weeks

624
00:22:16,640 --> 00:22:21,600
oops that's that's internet okay so

625
00:22:19,760 --> 00:22:22,799
what we are considering in this paper is

626
00:22:21,600 --> 00:22:25,120
exchange where you have

627
00:22:22,799 --> 00:22:26,639
two parties alice and bob who execute

628
00:22:25,120 --> 00:22:28,799
some randomized protocol

629
00:22:26,640 --> 00:22:30,799
and in the end the manager agree on the

630
00:22:28,799 --> 00:22:34,158
shared key

631
00:22:30,799 --> 00:22:35,918
so to be more precise uh what i'm

632
00:22:34,159 --> 00:22:38,960
considering here is what i'll call a

633
00:22:35,919 --> 00:22:40,799
nike which is a non-interactive exchange

634
00:22:38,960 --> 00:22:42,720
where alice and bob can compute their

635
00:22:40,799 --> 00:22:44,400
messages in advance before the protocol

636
00:22:42,720 --> 00:22:45,919
execution

637
00:22:44,400 --> 00:22:47,440
and that is secure against specific

638
00:22:45,919 --> 00:22:49,520
adversaries

639
00:22:47,440 --> 00:22:50,799
so we require that if there's an if

640
00:22:49,520 --> 00:22:52,720
stripper that can see

641
00:22:50,799 --> 00:22:54,639
the messages that are exchanged during

642
00:22:52,720 --> 00:22:56,559
the protocol execution

643
00:22:54,640 --> 00:22:58,080
then she shouldn't be able to infer any

644
00:22:56,559 --> 00:23:01,120
information about

645
00:22:58,080 --> 00:23:03,760
the keys so

646
00:23:01,120 --> 00:23:05,280
on top of that we'll consider another

647
00:23:03,760 --> 00:23:07,600
layer of security

648
00:23:05,280 --> 00:23:09,039
so leakage resistance and the basic

649
00:23:07,600 --> 00:23:12,080
question that it asks

650
00:23:09,039 --> 00:23:13,919
is what happens if the random coins

651
00:23:12,080 --> 00:23:15,280
that alice and bob use to execute the

652
00:23:13,919 --> 00:23:18,880
protocol is

653
00:23:15,280 --> 00:23:19,678
unreliable somehow so for instance eve

654
00:23:18,880 --> 00:23:22,320
could get

655
00:23:19,679 --> 00:23:23,840
some information on alice and bob's

656
00:23:22,320 --> 00:23:26,000
random kind through through sometimes

657
00:23:23,840 --> 00:23:27,918
chapters and would like to ensure that

658
00:23:26,000 --> 00:23:31,039
even if this is the case

659
00:23:27,919 --> 00:23:32,559
uh the protocol is secure so the way

660
00:23:31,039 --> 00:23:35,039
we'll model that

661
00:23:32,559 --> 00:23:36,480
is that eve will be able to see alice's

662
00:23:35,039 --> 00:23:39,280
random coins that she uses

663
00:23:36,480 --> 00:23:40,720
for the protocol execution compress that

664
00:23:39,280 --> 00:23:43,279
information down somehow

665
00:23:40,720 --> 00:23:44,559
and keep some leakage in her hand do the

666
00:23:43,279 --> 00:23:47,679
same for bob

667
00:23:44,559 --> 00:23:50,158
and require that in the eyes of eve the

668
00:23:47,679 --> 00:23:51,760
trickies are the keys that is shared in

669
00:23:50,159 --> 00:23:55,600
the end of the protocol is

670
00:23:51,760 --> 00:23:57,360
looks uniform so it turns out that

671
00:23:55,600 --> 00:24:00,158
this problem has been quite heavily

672
00:23:57,360 --> 00:24:02,158
studied before

673
00:24:00,159 --> 00:24:03,520
and particularly there are kind of

674
00:24:02,159 --> 00:24:05,840
generic techniques and

675
00:24:03,520 --> 00:24:06,960
actually all the things that i know you

676
00:24:05,840 --> 00:24:08,959
use some kind of

677
00:24:06,960 --> 00:24:10,320
leak-free randomness so what does it

678
00:24:08,960 --> 00:24:14,240
mean

679
00:24:10,320 --> 00:24:17,279
uh you can given an ikea you can kind of

680
00:24:14,240 --> 00:24:20,400
generally transform the protocol uh

681
00:24:17,279 --> 00:24:22,240
by requiring alice and bomb to use some

682
00:24:20,400 --> 00:24:23,679
additional randomness here denoted in

683
00:24:22,240 --> 00:24:26,799
green

684
00:24:23,679 --> 00:24:28,559
such that if eve doesn't get any leakage

685
00:24:26,799 --> 00:24:32,158
on those green random coins

686
00:24:28,559 --> 00:24:34,799
then the protocol remains secure

687
00:24:32,159 --> 00:24:36,159
so uh but leak free randomness is really

688
00:24:34,799 --> 00:24:37,600
not something we would want

689
00:24:36,159 --> 00:24:39,360
in practice and actually goes kind of

690
00:24:37,600 --> 00:24:40,559
against the main motivations of the case

691
00:24:39,360 --> 00:24:42,479
resilience

692
00:24:40,559 --> 00:24:43,760
so one main goal of the paper is to

693
00:24:42,480 --> 00:24:48,400
actually get

694
00:24:43,760 --> 00:24:48,400
a pure like a pure kick challenge

695
00:24:49,600 --> 00:24:52,959
and we know this uh so yeah sorry uh

696
00:24:52,480 --> 00:24:54,320
just for

697
00:24:52,960 --> 00:24:56,400
for notation i'll call a leakage

698
00:24:54,320 --> 00:24:58,240
resistant exchange uh kickstart shall

699
00:24:56,400 --> 00:25:01,279
remain secure whenever eve

700
00:24:58,240 --> 00:25:04,080
gets uh some leakage and uh alice and

701
00:25:01,279 --> 00:25:04,080
bertrand guys

702
00:25:04,400 --> 00:25:07,840
and he's setting uh some something that

703
00:25:06,320 --> 00:25:09,279
um so something

704
00:25:07,840 --> 00:25:12,240
to notice is that it actually makes

705
00:25:09,279 --> 00:25:14,159
sense to consider a symmetric version of

706
00:25:12,240 --> 00:25:16,559
this protocol

707
00:25:14,159 --> 00:25:18,000
so where alice and bob would start with

708
00:25:16,559 --> 00:25:20,240
the secret key

709
00:25:18,000 --> 00:25:22,159
and would in the end agree on the new

710
00:25:20,240 --> 00:25:25,039
uniformity

711
00:25:22,159 --> 00:25:26,320
so here like a resident means that if

712
00:25:25,039 --> 00:25:29,279
should be about to leak

713
00:25:26,320 --> 00:25:30,000
jointly on the secret key on an alice's

714
00:25:29,279 --> 00:25:31,679
random cards

715
00:25:30,000 --> 00:25:33,200
so in some sense she like imagine she

716
00:25:31,679 --> 00:25:34,880
has a backdoor

717
00:25:33,200 --> 00:25:38,159
through alice's device and yeah get like

718
00:25:34,880 --> 00:25:38,159
all kind of information she wants

719
00:25:38,559 --> 00:25:44,639
so okay so how could such a primitive uh

720
00:25:42,320 --> 00:25:46,158
be useful so for instance if alice and

721
00:25:44,640 --> 00:25:48,320
bob sharoki

722
00:25:46,159 --> 00:25:49,679
this key gets somehow leaked and they

723
00:25:48,320 --> 00:25:53,279
would like to refresh that

724
00:25:49,679 --> 00:25:55,360
so that could be an example application

725
00:25:53,279 --> 00:25:56,720
and the question you may ask is why

726
00:25:55,360 --> 00:25:59,039
would you consider such a

727
00:25:56,720 --> 00:26:00,000
such a setting you can just use standard

728
00:25:59,039 --> 00:26:03,279
liquid resin

729
00:26:00,000 --> 00:26:04,320
naked to do that and the point here is

730
00:26:03,279 --> 00:26:07,200
that it's a

731
00:26:04,320 --> 00:26:08,399
simpler uh it's a simple problem and you

732
00:26:07,200 --> 00:26:10,799
could hope for better

733
00:26:08,400 --> 00:26:11,760
solutions so here what we're aiming for

734
00:26:10,799 --> 00:26:14,720
is information

735
00:26:11,760 --> 00:26:14,720
authority constructions

736
00:26:14,880 --> 00:26:18,480
yeah so so now i can describe our

737
00:26:16,720 --> 00:26:20,880
contributions

738
00:26:18,480 --> 00:26:22,480
so our first contribution relates to the

739
00:26:20,880 --> 00:26:23,600
dissymmetric setting that i just talked

740
00:26:22,480 --> 00:26:26,080
about

741
00:26:23,600 --> 00:26:28,480
and we showed that this symmetric key

742
00:26:26,080 --> 00:26:30,080
leakages in nikes

743
00:26:28,480 --> 00:26:32,080
is very related through a notion of

744
00:26:30,080 --> 00:26:35,199
randomness extractor that we call

745
00:26:32,080 --> 00:26:37,439
electricity extractors so to see that

746
00:26:35,200 --> 00:26:37,440
link

747
00:26:37,679 --> 00:26:42,320
that pretty much corresponds to the

748
00:26:39,360 --> 00:26:43,918
special kind of uh symmetric kinaki

749
00:26:42,320 --> 00:26:47,120
where alice and bob just send to each

750
00:26:43,919 --> 00:26:47,120
other their whole random goods

751
00:26:47,200 --> 00:26:51,200
so what happens is that the protocol

752
00:26:49,039 --> 00:26:54,799
that they use to derive the key

753
00:26:51,200 --> 00:26:57,520
in the end is in some sense extracting

754
00:26:54,799 --> 00:26:59,120
entropy fresh entropy out of some source

755
00:26:57,520 --> 00:27:01,039
share the key that they share

756
00:26:59,120 --> 00:27:02,639
using some seeds the random currents

757
00:27:01,039 --> 00:27:03,919
that they use for the protocol

758
00:27:02,640 --> 00:27:07,120
and that's pretty much what atrocities

759
00:27:03,919 --> 00:27:08,720
extractor would

760
00:27:07,120 --> 00:27:10,639
then we show how to construct such

761
00:27:08,720 --> 00:27:12,400
strategic factors given some

762
00:27:10,640 --> 00:27:13,760
communication complexity lower bounds

763
00:27:12,400 --> 00:27:15,679
more precision in the number and

764
00:27:13,760 --> 00:27:17,840
forehead model

765
00:27:15,679 --> 00:27:19,200
and because we have efficient functions

766
00:27:17,840 --> 00:27:21,520
that have a

767
00:27:19,200 --> 00:27:23,200
high communication complexity in the end

768
00:27:21,520 --> 00:27:25,360
what we obtain is information theory

769
00:27:23,200 --> 00:27:29,279
constructions of such symmetric energies

770
00:27:25,360 --> 00:27:30,799
indicators so our second set of

771
00:27:29,279 --> 00:27:31,520
contributions would be in the more

772
00:27:30,799 --> 00:27:33,039
standard

773
00:27:31,520 --> 00:27:35,279
public setting where alice and bob do

774
00:27:33,039 --> 00:27:38,000
not share it in advance

775
00:27:35,279 --> 00:27:39,120
and somewhat surprisingly i'm personally

776
00:27:38,000 --> 00:27:42,799
not aware of any

777
00:27:39,120 --> 00:27:44,799
construction in the setting and one

778
00:27:42,799 --> 00:27:46,399
potential reason why is the following

779
00:27:44,799 --> 00:27:49,360
impossibility results

780
00:27:46,399 --> 00:27:50,799
we show that rules out any black box

781
00:27:49,360 --> 00:27:53,439
reduction

782
00:27:50,799 --> 00:27:55,120
from any cryptographic game for a

783
00:27:53,440 --> 00:27:56,960
special kind of leakage resolutions

784
00:27:55,120 --> 00:28:00,879
namely those with perfect correctness

785
00:27:56,960 --> 00:28:03,120
and with not too small leakage

786
00:28:00,880 --> 00:28:04,480
so so just to parse this what i mean by

787
00:28:03,120 --> 00:28:08,080
cryptographic game

788
00:28:04,480 --> 00:28:08,640
um i refer to the talk for my details

789
00:28:08,080 --> 00:28:11,279
but that

790
00:28:08,640 --> 00:28:12,720
essentially uh includes all the

791
00:28:11,279 --> 00:28:16,320
assumptions we like to make

792
00:28:12,720 --> 00:28:17,840
usually uh but still

793
00:28:16,320 --> 00:28:19,360
there are some limitations to this black

794
00:28:17,840 --> 00:28:22,240
box impossibility result

795
00:28:19,360 --> 00:28:23,840
and so we would still like to get uh

796
00:28:22,240 --> 00:28:26,000
some constructions

797
00:28:23,840 --> 00:28:27,520
and at least in the the throne statement

798
00:28:26,000 --> 00:28:30,240
as i stated

799
00:28:27,520 --> 00:28:32,000
there are some ways potential ways to

800
00:28:30,240 --> 00:28:33,679
circumvent

801
00:28:32,000 --> 00:28:36,399
indeed for instance if we consider

802
00:28:33,679 --> 00:28:39,039
leakages and nikes with small leakage

803
00:28:36,399 --> 00:28:40,719
we show that any nike is actually

804
00:28:39,039 --> 00:28:44,158
natively resilient to

805
00:28:40,720 --> 00:28:46,480
a log size page

806
00:28:44,159 --> 00:28:47,520
so we leave the the question of constru

807
00:28:46,480 --> 00:28:51,120
constructing

808
00:28:47,520 --> 00:28:53,360
uh nikes with non-black box reductions

809
00:28:51,120 --> 00:28:54,959
or that would somehow meaningfully use

810
00:28:53,360 --> 00:28:56,479
the fact that they have statistical

811
00:28:54,960 --> 00:28:56,799
correctness instead of perfect kindness

812
00:28:56,480 --> 00:28:59,840
as

813
00:28:56,799 --> 00:28:59,840
natural open questions

814
00:28:59,919 --> 00:29:03,840
and last if you dig a tiny bit more into

815
00:29:02,080 --> 00:29:05,520
the impossibility results

816
00:29:03,840 --> 00:29:08,080
we can notice that it actually only

817
00:29:05,520 --> 00:29:09,918
deals with nikes in the plane model

818
00:29:08,080 --> 00:29:11,678
or at least using some kind of public

819
00:29:09,919 --> 00:29:14,080
quantity

820
00:29:11,679 --> 00:29:16,559
it turns out that if you are okay using

821
00:29:14,080 --> 00:29:18,799
secret concernings we can actually give

822
00:29:16,559 --> 00:29:19,760
in some sections so for instance we

823
00:29:18,799 --> 00:29:23,440
managed to get

824
00:29:19,760 --> 00:29:25,600
an insurance situation using parents

825
00:29:23,440 --> 00:29:27,200
uh yeah that's pretty much all i had to

826
00:29:25,600 --> 00:29:29,760
say uh feel free to ask questions and

827
00:29:27,200 --> 00:29:29,760
thanks for your time

828
00:29:29,919 --> 00:29:33,360
thanks thanks for your talk

829
00:29:33,520 --> 00:29:39,840
let's see if yes there is a question

830
00:29:36,640 --> 00:29:40,880
um anant you want to take over there is

831
00:29:39,840 --> 00:29:43,760
a question in zoom

832
00:29:40,880 --> 00:29:45,039
chat so really if you want to unmute

833
00:29:43,760 --> 00:29:46,720
yourself and ask the question you can do

834
00:29:45,039 --> 00:29:49,520
that

835
00:29:46,720 --> 00:29:51,679
uh thanks so i wanted to ask that

836
00:29:49,520 --> 00:29:54,080
leakage resilient nike in the public key

837
00:29:51,679 --> 00:29:56,240
setting isn't it trivially impossible so

838
00:29:54,080 --> 00:29:58,960
for example the adversary can just

839
00:29:56,240 --> 00:29:59,679
embed the session key derivation

840
00:29:58,960 --> 00:30:02,799
function

841
00:29:59,679 --> 00:30:07,679
while leaking on the secret key of alice

842
00:30:02,799 --> 00:30:09,520
and just um leak directly from the nike

843
00:30:07,679 --> 00:30:11,200
so so you mean that the leakage could be

844
00:30:09,520 --> 00:30:12,639
like somehow like directly related to

845
00:30:11,200 --> 00:30:14,559
the nt

846
00:30:12,640 --> 00:30:16,080
uh yes so for example when the the

847
00:30:14,559 --> 00:30:17,760
leakage can be as follows so the

848
00:30:16,080 --> 00:30:20,399
adversary wants to leak on the

849
00:30:17,760 --> 00:30:21,679
secret key of alice so it takes the

850
00:30:20,399 --> 00:30:23,840
public key of bob

851
00:30:21,679 --> 00:30:25,600
and the leakage function is just a nike

852
00:30:23,840 --> 00:30:28,000
shared key derivation function

853
00:30:25,600 --> 00:30:30,000
and this directly gives you a say some

854
00:30:28,000 --> 00:30:33,200
bits of leakage on the nine key

855
00:30:30,000 --> 00:30:35,919
which um yeah which breaks the circuit

856
00:30:33,200 --> 00:30:37,039
yeah good question so so the thing is

857
00:30:35,919 --> 00:30:39,200
that the leakage should be

858
00:30:37,039 --> 00:30:40,799
computed before seeing the the

859
00:30:39,200 --> 00:30:43,200
transcript of the protocol otherwise

860
00:30:40,799 --> 00:30:44,000
indeed it doesn't make sense and for for

861
00:30:43,200 --> 00:30:46,559
the same reason

862
00:30:44,000 --> 00:30:47,039
we asked that the leakage should be kind

863
00:30:46,559 --> 00:30:50,080
of

864
00:30:47,039 --> 00:30:52,879
independent between um

865
00:30:50,080 --> 00:30:53,520
uh like should not be a joint decentral

866
00:30:52,880 --> 00:30:54,640
alison

867
00:30:53,520 --> 00:30:56,240
and bob state you should be like

868
00:30:54,640 --> 00:30:57,120
independent analyst and then in

869
00:30:56,240 --> 00:31:00,080
independent

870
00:30:57,120 --> 00:31:00,479
otherwise you can just compute the key

871
00:31:00,080 --> 00:31:01,840
so

872
00:31:00,480 --> 00:31:03,679
in some sense the leakage has to be like

873
00:31:01,840 --> 00:31:04,879
kind of independent of what's happening

874
00:31:03,679 --> 00:31:06,640
in the protocol execution

875
00:31:04,880 --> 00:31:08,320
so it's like more leakage that you get

876
00:31:06,640 --> 00:31:09,760
in advance um

877
00:31:08,320 --> 00:31:12,320
beforehand and then you execute the

878
00:31:09,760 --> 00:31:14,640
protocol and then secure okay so

879
00:31:12,320 --> 00:31:16,320
is it is so does that mean that your

880
00:31:14,640 --> 00:31:18,320
protocol is only secure in the split

881
00:31:16,320 --> 00:31:20,799
state leakage model

882
00:31:18,320 --> 00:31:21,918
uh yeah kind of i mean otherwise it

883
00:31:20,799 --> 00:31:22,879
doesn't make sense though the province

884
00:31:21,919 --> 00:31:25,120
doesn't make sense if i understand

885
00:31:22,880 --> 00:31:28,320
correctly

886
00:31:25,120 --> 00:31:31,279
okay i'll see okay thank you sir

887
00:31:28,320 --> 00:31:31,678
deep and again i encourage others to

888
00:31:31,279 --> 00:31:33,279
post

889
00:31:31,679 --> 00:31:34,880
questions on the zulub chat so that you

890
00:31:33,279 --> 00:31:36,720
can continue the discussion maybe if you

891
00:31:34,880 --> 00:31:40,000
want to repost it that would be great

892
00:31:36,720 --> 00:31:41,519
um i guess you're out of time so we move

893
00:31:40,000 --> 00:31:43,120
to the next next stop

894
00:31:41,519 --> 00:31:45,039
yeah we should move to the next we're

895
00:31:43,120 --> 00:31:46,239
halfway through this session which seems

896
00:31:45,039 --> 00:31:49,840
to be good timing

897
00:31:46,240 --> 00:31:52,720
if we proceed to that so um

898
00:31:49,840 --> 00:31:54,240
could you please share your slides our

899
00:31:52,720 --> 00:31:58,240
next speaker is

900
00:31:54,240 --> 00:31:58,240
kevin kevin yeah

901
00:31:59,039 --> 00:32:03,120
yes we see the slides and his stock is

902
00:32:02,559 --> 00:32:05,519
on

903
00:32:03,120 --> 00:32:06,719
lower bounds for encrypted multi-maps

904
00:32:05,519 --> 00:32:09,760
and searchable encryption

905
00:32:06,720 --> 00:32:11,840
in the leakage cell probe model and

906
00:32:09,760 --> 00:32:14,559
it might work yeah with a few more

907
00:32:11,840 --> 00:32:15,439
people please go ahead sorry i'm sorry i

908
00:32:14,559 --> 00:32:16,799
interrupted you thank you for the

909
00:32:15,440 --> 00:32:18,159
introduction yeah i'd like to say this

910
00:32:16,799 --> 00:32:21,120
is the joint work with startup hotel and

911
00:32:18,159 --> 00:32:22,480
pinot gristiano from universal in google

912
00:32:21,120 --> 00:32:24,158
all right so the problem that we're

913
00:32:22,480 --> 00:32:24,960
considering in this paper is sort of the

914
00:32:24,159 --> 00:32:26,480
idea of

915
00:32:24,960 --> 00:32:28,399
outsourcing storage essentially you can

916
00:32:26,480 --> 00:32:28,880
sort of have a data owner or a client on

917
00:32:28,399 --> 00:32:30,479
your left

918
00:32:28,880 --> 00:32:31,919
that wants to outsource let's say some

919
00:32:30,480 --> 00:32:33,200
sort of map on the

920
00:32:31,919 --> 00:32:35,120
potential trusted server on the right

921
00:32:33,200 --> 00:32:36,640
let's say like keys and values

922
00:32:35,120 --> 00:32:37,918
and so if you do this in a naive way

923
00:32:36,640 --> 00:32:38,320
where you know even if you just did sort

924
00:32:37,919 --> 00:32:40,240
of

925
00:32:38,320 --> 00:32:41,840
playing client-side encryption what

926
00:32:40,240 --> 00:32:43,279
happens is when the data owner wants to

927
00:32:41,840 --> 00:32:45,600
sort of retrieve a key

928
00:32:43,279 --> 00:32:46,960
and and the associated value for a key

929
00:32:45,600 --> 00:32:48,719
the server sort of sees

930
00:32:46,960 --> 00:32:50,159
what keys were being queried over time

931
00:32:48,720 --> 00:32:51,760
and this is sort of you can imagine that

932
00:32:50,159 --> 00:32:53,039
over a long period of time the server

933
00:32:51,760 --> 00:32:54,559
will be able to get

934
00:32:53,039 --> 00:32:56,000
more more detailed information

935
00:32:54,559 --> 00:32:56,240
statistics about what's going on or what

936
00:32:56,000 --> 00:32:57,679
the

937
00:32:56,240 --> 00:32:59,519
intent of the owner is or what the

938
00:32:57,679 --> 00:33:00,480
underlying data is

939
00:32:59,519 --> 00:33:01,919
so in this work what we're really

940
00:33:00,480 --> 00:33:02,559
considering is a is a problem where

941
00:33:01,919 --> 00:33:04,159
essentially

942
00:33:02,559 --> 00:33:05,918
we want to just provide privacy for the

943
00:33:04,159 --> 00:33:07,679
requested key so for example the data

944
00:33:05,919 --> 00:33:10,720
owner has outsourced this data in some

945
00:33:07,679 --> 00:33:11,200
fancy way it it does a request for key

946
00:33:10,720 --> 00:33:13,360
ki

947
00:33:11,200 --> 00:33:14,559
receives the value vi and the server has

948
00:33:13,360 --> 00:33:15,439
us you know the server doesn't know

949
00:33:14,559 --> 00:33:17,360
exactly what the key

950
00:33:15,440 --> 00:33:18,640
is and i'll be more informal on what the

951
00:33:17,360 --> 00:33:19,439
privacy actually means but sort of we're

952
00:33:18,640 --> 00:33:22,720
just trying to hide

953
00:33:19,440 --> 00:33:24,000
what keys being queried so it turns out

954
00:33:22,720 --> 00:33:25,679
that uh you know what i'm considering

955
00:33:24,000 --> 00:33:26,960
essentially are maps or multi-maps and

956
00:33:25,679 --> 00:33:28,240
there's actually been a lot of work on

957
00:33:26,960 --> 00:33:28,880
this on this data structure over the

958
00:33:28,240 --> 00:33:30,159
years

959
00:33:28,880 --> 00:33:32,399
and you can actually view this sort of

960
00:33:30,159 --> 00:33:33,840
as a privacy spectrum so on the left you

961
00:33:32,399 --> 00:33:35,760
have sort of the most efficient

962
00:33:33,840 --> 00:33:37,039
but least private sort of solutions and

963
00:33:35,760 --> 00:33:38,399
on the right you can have the

964
00:33:37,039 --> 00:33:40,640
the least efficient but the most private

965
00:33:38,399 --> 00:33:41,840
solutions so i mean the least uh the

966
00:33:40,640 --> 00:33:43,200
most efficient solutions are obviously

967
00:33:41,840 --> 00:33:44,639
the ones that provide no privacy so you

968
00:33:43,200 --> 00:33:46,159
can think of plain text maps

969
00:33:44,640 --> 00:33:47,919
you know such as the fks hashing the

970
00:33:46,159 --> 00:33:48,559
very famous ones from the 80s that give

971
00:33:47,919 --> 00:33:50,159
you essentially

972
00:33:48,559 --> 00:33:52,480
constant efficiency but leak everything

973
00:33:50,159 --> 00:33:54,320
because the goal is not privacy

974
00:33:52,480 --> 00:33:55,679
so in recent years there's been a step

975
00:33:54,320 --> 00:33:56,799
up where people have considered the idea

976
00:33:55,679 --> 00:33:58,880
of structured encryption

977
00:33:56,799 --> 00:34:00,639
also known as encrypted search where the

978
00:33:58,880 --> 00:34:02,399
efficiency essentially is order one

979
00:34:00,640 --> 00:34:03,760
but the leakage is something which is

980
00:34:02,399 --> 00:34:05,279
slightly non-trivial it's a non-trivial

981
00:34:03,760 --> 00:34:06,799
leakage function and i'll get back to

982
00:34:05,279 --> 00:34:09,040
you and i'll explain in more detail

983
00:34:06,799 --> 00:34:10,480
just a little bit later and finally on

984
00:34:09,040 --> 00:34:11,759
the far right what we have essentially

985
00:34:10,480 --> 00:34:13,119
are oblivious rams

986
00:34:11,760 --> 00:34:14,879
where you get you know where you have

987
00:34:13,119 --> 00:34:16,240
essentially optimal privacy the only

988
00:34:14,879 --> 00:34:17,520
leakage essentially that's leaked is the

989
00:34:16,239 --> 00:34:18,560
length over the number of operations

990
00:34:17,520 --> 00:34:20,320
that are performed

991
00:34:18,560 --> 00:34:22,879
but the efficiency jumps logarithmically

992
00:34:20,320 --> 00:34:24,000
higher from constant to log n

993
00:34:22,879 --> 00:34:25,839
so in this way what we're actually

994
00:34:24,000 --> 00:34:27,839
trying to explore is this area between

995
00:34:25,839 --> 00:34:29,119
structured encryption and oblivious ram

996
00:34:27,839 --> 00:34:30,719
essentially we're asking you know we

997
00:34:29,119 --> 00:34:31,520
have this sort of we know that you know

998
00:34:30,719 --> 00:34:32,879
the left

999
00:34:31,520 --> 00:34:34,800
there is there's just constant

1000
00:34:32,879 --> 00:34:36,159
constructions with non-trivial leakage

1001
00:34:34,800 --> 00:34:38,079
and there's just login constructions

1002
00:34:36,159 --> 00:34:38,720
with almost no leakage how does this

1003
00:34:38,079 --> 00:34:40,639
ramp up

1004
00:34:38,719 --> 00:34:42,319
where does this go from constant to log

1005
00:34:40,639 --> 00:34:44,240
in what privacy is required

1006
00:34:42,320 --> 00:34:45,280
or what privacy can we actually obtain

1007
00:34:44,239 --> 00:34:46,399
with constant overhead that's maybe

1008
00:34:45,280 --> 00:34:49,119
better than the non-trivial leakage

1009
00:34:46,399 --> 00:34:51,520
functions that we currently have

1010
00:34:49,119 --> 00:34:52,720
so okay like i said if i want to explore

1011
00:34:51,520 --> 00:34:54,159
this i sort of explain to you

1012
00:34:52,719 --> 00:34:56,158
what is structured encryption what this

1013
00:34:54,159 --> 00:34:58,079
nontrivial leakage function is

1014
00:34:56,159 --> 00:34:59,680
so it turns out that this whole area of

1015
00:34:58,079 --> 00:35:00,880
structured encryption a lot of the ideas

1016
00:34:59,680 --> 00:35:02,399
can actually be

1017
00:35:00,880 --> 00:35:04,400
formulated in a very simple idea of a

1018
00:35:02,400 --> 00:35:05,599
hashtag compiler so we do is you

1019
00:35:04,400 --> 00:35:07,359
consider any plain text

1020
00:35:05,599 --> 00:35:08,800
on map with operations like insert get

1021
00:35:07,359 --> 00:35:10,240
and delete and this is all done in plain

1022
00:35:08,800 --> 00:35:11,599
text

1023
00:35:10,240 --> 00:35:12,879
and what you do is you take a you know

1024
00:35:11,599 --> 00:35:14,240
the client or the data owner will keep

1025
00:35:12,880 --> 00:35:17,839
some single private key

1026
00:35:14,240 --> 00:35:19,680
okay and simply hash all the keys ki

1027
00:35:17,839 --> 00:35:22,240
using it using some

1028
00:35:19,680 --> 00:35:23,759
prf for example and in cpa encrypt all

1029
00:35:22,240 --> 00:35:25,520
the values

1030
00:35:23,760 --> 00:35:26,720
so if you do this it turns out you can

1031
00:35:25,520 --> 00:35:28,000
still do all the queries for example if

1032
00:35:26,720 --> 00:35:29,680
you want to do a query you just send a

1033
00:35:28,000 --> 00:35:30,560
hash of your key that you're requesting

1034
00:35:29,680 --> 00:35:31,680
and you'll get back

1035
00:35:30,560 --> 00:35:33,839
the encrypted value which you can

1036
00:35:31,680 --> 00:35:34,399
decrypt and similarly you can also

1037
00:35:33,839 --> 00:35:36,400
insert

1038
00:35:34,400 --> 00:35:37,520
for example if i want to insert a key ki

1039
00:35:36,400 --> 00:35:39,599
and a value vi

1040
00:35:37,520 --> 00:35:40,800
i send the hash of the of the key and

1041
00:35:39,599 --> 00:35:42,160
encryption of the value

1042
00:35:40,800 --> 00:35:43,280
and then the server node and i tell the

1043
00:35:42,160 --> 00:35:44,560
insert which essentially insert these

1044
00:35:43,280 --> 00:35:46,960
values and the server would essentially

1045
00:35:44,560 --> 00:35:48,400
insert it into the plain text map

1046
00:35:46,960 --> 00:35:50,240
so i mean this is a very straightforward

1047
00:35:48,400 --> 00:35:50,880
and you can argue what kind of privacy

1048
00:35:50,240 --> 00:35:52,959
it gets

1049
00:35:50,880 --> 00:35:54,079
you know this is a good question so okay

1050
00:35:52,960 --> 00:35:57,200
so yeah insert so

1051
00:35:54,079 --> 00:35:58,400
let's let's explore it so

1052
00:35:57,200 --> 00:35:59,598
to take a closer look what actually

1053
00:35:58,400 --> 00:36:01,200
happens in the leakage you can sort of

1054
00:35:59,599 --> 00:36:02,640
see that for each query

1055
00:36:01,200 --> 00:36:04,640
the server gets to see sort of three

1056
00:36:02,640 --> 00:36:06,000
pieces of information the type of

1057
00:36:04,640 --> 00:36:07,680
operation that's performed

1058
00:36:06,000 --> 00:36:09,760
a hash of the key that's being uh

1059
00:36:07,680 --> 00:36:10,160
operated on and an encryption of the

1060
00:36:09,760 --> 00:36:11,359
value

1061
00:36:10,160 --> 00:36:12,399
that's being inserted or the or the

1062
00:36:11,359 --> 00:36:14,480
encryption of values that are being

1063
00:36:12,400 --> 00:36:16,560
returned for a query

1064
00:36:14,480 --> 00:36:18,240
so just to summarize quickly that's

1065
00:36:16,560 --> 00:36:19,680
these two these three operations

1066
00:36:18,240 --> 00:36:20,319
essentially you know type of operation

1067
00:36:19,680 --> 00:36:22,319
performed

1068
00:36:20,320 --> 00:36:23,599
the length of the query response and the

1069
00:36:22,320 --> 00:36:26,400
last thing which i really want to focus

1070
00:36:23,599 --> 00:36:27,680
on is the key quality pattern

1071
00:36:26,400 --> 00:36:29,359
so what is key equality pattern

1072
00:36:27,680 --> 00:36:30,160
essentially means that the server can

1073
00:36:29,359 --> 00:36:31,920
see whether

1074
00:36:30,160 --> 00:36:33,440
any two operations are performed on the

1075
00:36:31,920 --> 00:36:35,119
same on the same key or not

1076
00:36:33,440 --> 00:36:37,200
and this is simply because we're

1077
00:36:35,119 --> 00:36:37,839
releasing a prf which is a deterministic

1078
00:36:37,200 --> 00:36:40,240
value

1079
00:36:37,839 --> 00:36:41,359
of the key of e of the requested key so

1080
00:36:40,240 --> 00:36:43,200
even though the server doesn't know for

1081
00:36:41,359 --> 00:36:45,359
example the second and third operation

1082
00:36:43,200 --> 00:36:46,240
are being performed on dog it knows this

1083
00:36:45,359 --> 00:36:47,520
is the same value and

1084
00:36:46,240 --> 00:36:49,359
also knows for example the third and

1085
00:36:47,520 --> 00:36:49,680
fourth operations are not for the same

1086
00:36:49,359 --> 00:36:53,200
team

1087
00:36:49,680 --> 00:36:55,359
because their hashes are different

1088
00:36:53,200 --> 00:36:56,720
so uh you know this you might ask this

1089
00:36:55,359 --> 00:36:58,078
this seems like a very weak notion

1090
00:36:56,720 --> 00:36:59,439
or it might not it's not very

1091
00:36:58,079 --> 00:37:01,040
interesting as a construction but it

1092
00:36:59,440 --> 00:37:01,599
turns out that this leakage essentially

1093
00:37:01,040 --> 00:37:03,440
matches

1094
00:37:01,599 --> 00:37:04,880
all the best constant construction

1095
00:37:03,440 --> 00:37:06,960
schemes for structured encryption and

1096
00:37:04,880 --> 00:37:08,480
encrypted search

1097
00:37:06,960 --> 00:37:09,680
all right so i mean this seems like an

1098
00:37:08,480 --> 00:37:11,440
inherent bottleneck and it's something

1099
00:37:09,680 --> 00:37:12,879
that we're trying to explore here

1100
00:37:11,440 --> 00:37:14,960
so you know a natural question is you

1101
00:37:12,880 --> 00:37:16,960
know can we do better

1102
00:37:14,960 --> 00:37:18,240
and the answer is well looking at the

1103
00:37:16,960 --> 00:37:19,119
three leakage functions it turns out

1104
00:37:18,240 --> 00:37:20,799
there's only one that

1105
00:37:19,119 --> 00:37:22,160
we can really work on for the type of

1106
00:37:20,800 --> 00:37:23,839
operation performed it's actually not

1107
00:37:22,160 --> 00:37:25,118
hard to mitigate you can just repeat

1108
00:37:23,839 --> 00:37:26,720
all operations there's only a constant

1109
00:37:25,119 --> 00:37:28,079
number of operations you can do some

1110
00:37:26,720 --> 00:37:29,520
dummies and you can actually

1111
00:37:28,079 --> 00:37:32,000
probably mitigate this without any

1112
00:37:29,520 --> 00:37:33,280
overhead the length of the query

1113
00:37:32,000 --> 00:37:35,119
response is actually much harder to do

1114
00:37:33,280 --> 00:37:36,640
without increasing cost significantly

1115
00:37:35,119 --> 00:37:38,480
obviously because if you if your map is

1116
00:37:36,640 --> 00:37:40,160
inherently very very

1117
00:37:38,480 --> 00:37:42,560
hasn't has one key with a very long

1118
00:37:40,160 --> 00:37:44,078
value or a multi-map with a very long

1119
00:37:42,560 --> 00:37:45,119
value you probably can't mitigate this

1120
00:37:44,079 --> 00:37:45,680
there's some work that does this

1121
00:37:45,119 --> 00:37:47,359
actually but

1122
00:37:45,680 --> 00:37:49,279
you turn it's actually very hard to

1123
00:37:47,359 --> 00:37:50,480
mitigate just naturally because of the

1124
00:37:49,280 --> 00:37:51,839
problem

1125
00:37:50,480 --> 00:37:54,240
so we focus on the third which is the

1126
00:37:51,839 --> 00:37:55,359
key quality pattern and we said okay so

1127
00:37:54,240 --> 00:37:56,799
you know we know what the key quality

1128
00:37:55,359 --> 00:37:58,319
pattern is what we consider is something

1129
00:37:56,800 --> 00:38:00,240
just slightly worse

1130
00:37:58,320 --> 00:38:01,599
or slightly better in terms of privacy

1131
00:38:00,240 --> 00:38:02,160
it might not even be meaningful but

1132
00:38:01,599 --> 00:38:03,839
let's let's

1133
00:38:02,160 --> 00:38:05,359
let's try it and we call it the

1134
00:38:03,839 --> 00:38:06,640
decoupled key equality

1135
00:38:05,359 --> 00:38:08,319
so we're essentially saying is we want

1136
00:38:06,640 --> 00:38:09,279
to decouple key equality between

1137
00:38:08,320 --> 00:38:11,200
operations

1138
00:38:09,280 --> 00:38:12,640
so before in the previous slide what i

1139
00:38:11,200 --> 00:38:13,759
had with you know the cats were all

1140
00:38:12,640 --> 00:38:16,160
colored by the same

1141
00:38:13,760 --> 00:38:17,119
by the same sort of color purple in this

1142
00:38:16,160 --> 00:38:18,799
case what i want

1143
00:38:17,119 --> 00:38:20,720
i'm okay with the server learning

1144
00:38:18,800 --> 00:38:22,400
whether the same key is being operated

1145
00:38:20,720 --> 00:38:23,759
on for two insert operations

1146
00:38:22,400 --> 00:38:24,960
but between an insert and query

1147
00:38:23,760 --> 00:38:26,640
operation i would like to sort of

1148
00:38:24,960 --> 00:38:27,359
decouple the the knowledge so for

1149
00:38:26,640 --> 00:38:28,879
example

1150
00:38:27,359 --> 00:38:30,720
the fourth and fifth operation even

1151
00:38:28,880 --> 00:38:32,720
though they're performing the same

1152
00:38:30,720 --> 00:38:34,160
keyword cat i wouldn't like the server

1153
00:38:32,720 --> 00:38:35,680
to know that information

1154
00:38:34,160 --> 00:38:37,200
but i'm okay with the server learning

1155
00:38:35,680 --> 00:38:37,839
whether two inserts are for the same cat

1156
00:38:37,200 --> 00:38:38,960
or not

1157
00:38:37,839 --> 00:38:40,799
like let's say the first and fourth

1158
00:38:38,960 --> 00:38:42,560
operation and you can do the same thing

1159
00:38:40,800 --> 00:38:43,280
with the other sort of uh keyword dog

1160
00:38:42,560 --> 00:38:44,640
you see that

1161
00:38:43,280 --> 00:38:46,960
since there's one's an insert one's a

1162
00:38:44,640 --> 00:38:47,598
query we would like to sort of decouple

1163
00:38:46,960 --> 00:38:48,960
them and say

1164
00:38:47,599 --> 00:38:50,480
the server shouldn't learn whether for

1165
00:38:48,960 --> 00:38:51,200
the same for the same requested key or

1166
00:38:50,480 --> 00:38:52,880
not

1167
00:38:51,200 --> 00:38:54,560
so you can ask you know is this really a

1168
00:38:52,880 --> 00:38:55,520
meaningful privacy guarantee i don't

1169
00:38:54,560 --> 00:38:57,200
know

1170
00:38:55,520 --> 00:38:59,359
but what we actually proved is something

1171
00:38:57,200 --> 00:39:00,879
quite surprising which is the following

1172
00:38:59,359 --> 00:39:02,799
and this is the main result of our of

1173
00:39:00,880 --> 00:39:04,960
our paper essentially it's sort of that

1174
00:39:02,800 --> 00:39:06,720
any encrypted multi-map with leakage at

1175
00:39:04,960 --> 00:39:09,200
most the decoupled key quality pattern

1176
00:39:06,720 --> 00:39:10,480
must have omega login overhead

1177
00:39:09,200 --> 00:39:12,078
so essentially what essentially means if

1178
00:39:10,480 --> 00:39:13,200
you want just the key quality pattern

1179
00:39:12,079 --> 00:39:14,240
you're okay you can get constant

1180
00:39:13,200 --> 00:39:15,680
overhead with the hash and encrypt

1181
00:39:14,240 --> 00:39:17,200
compiler which you described earlier

1182
00:39:15,680 --> 00:39:18,560
but as soon as you decouple as soon as

1183
00:39:17,200 --> 00:39:20,240
you want this very very slightly

1184
00:39:18,560 --> 00:39:21,520
stronger notion of

1185
00:39:20,240 --> 00:39:23,279
privacy which you know it might not even

1186
00:39:21,520 --> 00:39:25,200
be meaningful you end up having this

1187
00:39:23,280 --> 00:39:27,280
jump to logarithmic overhead

1188
00:39:25,200 --> 00:39:28,960
and of course this is tight because

1189
00:39:27,280 --> 00:39:30,079
there exists logarithmic or ram based

1190
00:39:28,960 --> 00:39:31,920
encrypted multi-maps

1191
00:39:30,079 --> 00:39:33,359
that leak much less than the decoupled

1192
00:39:31,920 --> 00:39:36,240
key equality pattern in fact they use

1193
00:39:33,359 --> 00:39:37,759
delete just a number of operations

1194
00:39:36,240 --> 00:39:39,520
so going back to the privacy spectrum in

1195
00:39:37,760 --> 00:39:40,560
this paper what we prove essentially is

1196
00:39:39,520 --> 00:39:42,880
sort of that

1197
00:39:40,560 --> 00:39:44,560
this ramp essentially wherever

1198
00:39:42,880 --> 00:39:48,240
structured encryption currently

1199
00:39:44,560 --> 00:39:48,240
sorry kevin could you wrap up please

1200
00:39:48,400 --> 00:39:52,160
so whatever we're at this is the last uh

1201
00:39:50,079 --> 00:39:53,359
this is the last of this essentially

1202
00:39:52,160 --> 00:39:56,960
what the best we can achieve everything

1203
00:39:53,359 --> 00:39:59,279
beyond that is is thank you

1204
00:39:56,960 --> 00:40:00,560
thank you thank you for the talk so like

1205
00:39:59,280 --> 00:40:02,560
i said uh we're a bit

1206
00:40:00,560 --> 00:40:03,599
running out of time and uh you you went

1207
00:40:02,560 --> 00:40:06,240
a bit uh on

1208
00:40:03,599 --> 00:40:08,560
after five minutes so i'll i'd like to

1209
00:40:06,240 --> 00:40:10,399
uh redirect the questions to zulip

1210
00:40:08,560 --> 00:40:12,400
uh there must be questions yeah thanks

1211
00:40:10,400 --> 00:40:15,520
for the talk kevin

1212
00:40:12,400 --> 00:40:18,480
and yeah hope people will

1213
00:40:15,520 --> 00:40:19,680
follow up with questions there um we're

1214
00:40:18,480 --> 00:40:22,960
moving on

1215
00:40:19,680 --> 00:40:25,919
to the next talk in this session which

1216
00:40:22,960 --> 00:40:28,560
will be given by gareth i'm waiting for

1217
00:40:25,920 --> 00:40:32,079
your slides to be shared

1218
00:40:28,560 --> 00:40:34,160
yes great so uh garrett

1219
00:40:32,079 --> 00:40:35,359
will speak about fast and secure

1220
00:40:34,160 --> 00:40:37,440
updatable encryption

1221
00:40:35,359 --> 00:40:39,040
that's also collaboration with other

1222
00:40:37,440 --> 00:40:41,200
people that he may

1223
00:40:39,040 --> 00:40:53,200
choose choose to mention or not please

1224
00:40:41,200 --> 00:40:55,598
go ahead

1225
00:40:53,200 --> 00:40:55,598
muted

1226
00:40:56,720 --> 00:41:10,640
yes garrett we don't hear you

1227
00:41:07,839 --> 00:41:10,640
okay try again

1228
00:41:15,680 --> 00:41:22,640
okay can you see the slides yes

1229
00:41:18,800 --> 00:41:24,640
yes both okay thank you sorry about that

1230
00:41:22,640 --> 00:41:26,799
okay so uh yep this is joint work with

1231
00:41:24,640 --> 00:41:29,680
my uh former colleagues from ncnu in the

1232
00:41:26,800 --> 00:41:31,839
beautiful city of china

1233
00:41:29,680 --> 00:41:32,799
so this talk concerns uh secure data

1234
00:41:31,839 --> 00:41:34,960
outsourcing

1235
00:41:32,800 --> 00:41:37,920
where a client encrypts files to send to

1236
00:41:34,960 --> 00:41:40,720
some untrusted storage provider

1237
00:41:37,920 --> 00:41:42,640
um and key compromise which can happen

1238
00:41:40,720 --> 00:41:45,520
from a device being lost or stolen

1239
00:41:42,640 --> 00:41:47,040
a security incident insecure hardware

1240
00:41:45,520 --> 00:41:48,400
this would give decryption capability to

1241
00:41:47,040 --> 00:41:50,560
an adversary that is in possession of

1242
00:41:48,400 --> 00:41:52,640
the ciphertext

1243
00:41:50,560 --> 00:41:54,400
so to mitigate against the risks uh

1244
00:41:52,640 --> 00:41:55,200
users can rotate their key to a fresh

1245
00:41:54,400 --> 00:41:58,319
key

1246
00:41:55,200 --> 00:42:00,160
either periodically or on demand

1247
00:41:58,319 --> 00:42:01,839
however downloading and re-encrypting

1248
00:42:00,160 --> 00:42:03,839
all files is simply not an option in the

1249
00:42:01,839 --> 00:42:05,520
vast majority of use cases

1250
00:42:03,839 --> 00:42:08,560
for our source and outsourced and

1251
00:42:05,520 --> 00:42:08,560
encrypted file storage

1252
00:42:09,119 --> 00:42:12,720
so to get around this problem updatable

1253
00:42:11,040 --> 00:42:13,119
encryption was introduced by bonnette

1254
00:42:12,720 --> 00:42:16,399
alvin

1255
00:42:13,119 --> 00:42:17,119
2013 the user calculates an update token

1256
00:42:16,400 --> 00:42:19,280
from their old

1257
00:42:17,119 --> 00:42:21,359
menu key and sends this token to the

1258
00:42:19,280 --> 00:42:22,960
server

1259
00:42:21,359 --> 00:42:24,799
the server then applies this token to

1260
00:42:22,960 --> 00:42:26,560
the old ciphertext to produce a new

1261
00:42:24,800 --> 00:42:28,480
ciphertext

1262
00:42:26,560 --> 00:42:31,839
the subscript here indicates the time

1263
00:42:28,480 --> 00:42:31,839
period or the ebook

1264
00:42:31,920 --> 00:42:35,119
so once this process is complete the

1265
00:42:33,599 --> 00:42:36,720
server can delete the token and the old

1266
00:42:35,119 --> 00:42:39,119
ciphertext and the user can delete their

1267
00:42:36,720 --> 00:42:41,439
old key and their token

1268
00:42:39,119 --> 00:42:42,640
so ciphertexts tokens and the update

1269
00:42:41,440 --> 00:42:43,760
process should of course not reveal

1270
00:42:42,640 --> 00:42:45,359
anything to the server about the

1271
00:42:43,760 --> 00:42:47,200
underlying plaintext

1272
00:42:45,359 --> 00:42:48,960
and i should say here that um updatable

1273
00:42:47,200 --> 00:42:50,799
encryption comes in two flavors

1274
00:42:48,960 --> 00:42:52,560
uh ciphertext independent schemes have

1275
00:42:50,800 --> 00:42:54,079
the same key for all ciphertexts which

1276
00:42:52,560 --> 00:42:56,000
means you only need one token

1277
00:42:54,079 --> 00:42:57,280
uh we'll be focusing on this for the

1278
00:42:56,000 --> 00:42:59,200
talk on the paper

1279
00:42:57,280 --> 00:43:01,119
uh ciphertext dependent schemes have one

1280
00:42:59,200 --> 00:43:03,839
key per cipher text and so one token

1281
00:43:01,119 --> 00:43:03,839
personality

1282
00:43:05,440 --> 00:43:10,000
okay so uh prior work by lehman and

1283
00:43:07,680 --> 00:43:11,520
tagman has defined confidentiality and a

1284
00:43:10,000 --> 00:43:13,440
very strong corruption model that allows

1285
00:43:11,520 --> 00:43:15,599
the adversary dynamic access to

1286
00:43:13,440 --> 00:43:17,280
keys tokens and ciphertexts across

1287
00:43:15,599 --> 00:43:19,440
different epochs

1288
00:43:17,280 --> 00:43:21,119
and the challenger tracks and

1289
00:43:19,440 --> 00:43:22,960
essentially works out if a trivial win

1290
00:43:21,119 --> 00:43:24,160
has occurred at the end

1291
00:43:22,960 --> 00:43:26,319
so the first stage is to assess

1292
00:43:24,160 --> 00:43:28,240
confidentiality of fresh ciphertexts

1293
00:43:26,319 --> 00:43:29,520
called indenk the challenge phase is

1294
00:43:28,240 --> 00:43:32,560
very similar to the regular

1295
00:43:29,520 --> 00:43:35,119
indistinguishability game for encryption

1296
00:43:32,560 --> 00:43:37,119
the second stage is to assess updates uh

1297
00:43:35,119 --> 00:43:38,160
by induct in which an adversary submits

1298
00:43:37,119 --> 00:43:40,400
two ciphertexts

1299
00:43:38,160 --> 00:43:42,399
that existed in the prior epoch uh

1300
00:43:40,400 --> 00:43:46,400
receives an encryption of one of them

1301
00:43:42,400 --> 00:43:46,400
uh i must decide which one was updated

1302
00:43:46,480 --> 00:43:51,760
um so if the adversary had access to

1303
00:43:48,560 --> 00:43:54,480
this uh crucial token here

1304
00:43:51,760 --> 00:43:56,000
for the epoch delta e tilde then a

1305
00:43:54,480 --> 00:43:57,280
scheme can only be secure if its update

1306
00:43:56,000 --> 00:44:00,560
procedure is randomized

1307
00:43:57,280 --> 00:44:03,520
uh this can occur perhaps in the elder

1308
00:44:00,560 --> 00:44:05,119
male based rise scheme of layman

1309
00:44:03,520 --> 00:44:06,720
and in our work we actually distinguish

1310
00:44:05,119 --> 00:44:09,359
these definitions for randomized updates

1311
00:44:06,720 --> 00:44:11,200
and deterministic updates

1312
00:44:09,359 --> 00:44:12,960
ciphertext integrity has also been

1313
00:44:11,200 --> 00:44:16,078
previously considered in the expected

1314
00:44:12,960 --> 00:44:18,240
way but in this strong corruption model

1315
00:44:16,079 --> 00:44:19,440
so we define a new security definition

1316
00:44:18,240 --> 00:44:21,598
for updated encryption

1317
00:44:19,440 --> 00:44:23,200
we call this in ue where an adversary

1318
00:44:21,599 --> 00:44:25,119
submits a message and ciphertext

1319
00:44:23,200 --> 00:44:26,399
from the prior epoch and receives back

1320
00:44:25,119 --> 00:44:27,200
either an encryption of the challenge

1321
00:44:26,400 --> 00:44:28,800
input message

1322
00:44:27,200 --> 00:44:30,720
or an update of the challenge input

1323
00:44:28,800 --> 00:44:32,480
circuit

1324
00:44:30,720 --> 00:44:33,680
and as it turns out this definition is

1325
00:44:32,480 --> 00:44:34,880
actually strictly stronger than the

1326
00:44:33,680 --> 00:44:38,078
combination of the two prior

1327
00:44:34,880 --> 00:44:38,079
confidentiality notions

1328
00:44:38,160 --> 00:44:41,839
and so please see the top of the paper

1329
00:44:40,160 --> 00:44:43,520
for full details but

1330
00:44:41,839 --> 00:44:46,000
we show how our notion relates to prior

1331
00:44:43,520 --> 00:44:49,040
work in the randomized updates case

1332
00:44:46,000 --> 00:44:52,720
uh also the designistic updates case

1333
00:44:49,040 --> 00:44:52,720
and in their chosen ciphertext system

1334
00:44:53,440 --> 00:44:57,440
so we also show the expected composition

1335
00:44:55,599 --> 00:45:00,720
result and we do so for each of these

1336
00:44:57,440 --> 00:45:00,720
confidentiality definitions

1337
00:45:01,920 --> 00:45:05,280
so additionally we give a new updatable

1338
00:45:03,760 --> 00:45:07,760
encryption scheme that we call

1339
00:45:05,280 --> 00:45:08,960
shine the encryption procedure takes a

1340
00:45:07,760 --> 00:45:10,400
nonsenate message

1341
00:45:08,960 --> 00:45:12,960
um passes that value through

1342
00:45:10,400 --> 00:45:15,119
implementation pi and exponentiates the

1343
00:45:12,960 --> 00:45:16,960
outcome

1344
00:45:15,119 --> 00:45:18,720
uh duplication works exactly as you'd

1345
00:45:16,960 --> 00:45:21,680
expect

1346
00:45:18,720 --> 00:45:23,359
so the update procedure produces a token

1347
00:45:21,680 --> 00:45:24,720
by multiplying the new key by the

1348
00:45:23,359 --> 00:45:26,319
inverse of the old key

1349
00:45:24,720 --> 00:45:28,640
and the server simply exponentiates

1350
00:45:26,319 --> 00:45:30,839
ciphertext by this group element

1351
00:45:28,640 --> 00:45:32,560
and note that this procedure is

1352
00:45:30,839 --> 00:45:34,319
deterministic

1353
00:45:32,560 --> 00:45:35,680
so the internal publication output is

1354
00:45:34,319 --> 00:45:37,279
static so decryption is again

1355
00:45:35,680 --> 00:45:38,560
straightforward

1356
00:45:37,280 --> 00:45:40,000
in the paper we actually define three

1357
00:45:38,560 --> 00:45:40,799
different variants for different size

1358
00:45:40,000 --> 00:45:42,240
messages

1359
00:45:40,800 --> 00:45:44,560
and show how to provide ciphertext

1360
00:45:42,240 --> 00:45:46,240
integrity we also discuss a number of

1361
00:45:44,560 --> 00:45:46,720
options for instantiating our schemes

1362
00:45:46,240 --> 00:45:48,000
with

1363
00:45:46,720 --> 00:45:49,919
different block ciphers and also

1364
00:45:48,000 --> 00:45:51,680
different elliptic curve groups and also

1365
00:45:49,920 --> 00:45:54,319
for mapping in between these spaces as

1366
00:45:51,680 --> 00:45:54,319
is necessary

1367
00:45:55,119 --> 00:46:00,800
so our schemes are secure under ddh and

1368
00:45:57,119 --> 00:46:03,119
cdh in the ideal cycle model

1369
00:46:00,800 --> 00:46:04,400
and the composition result that i

1370
00:46:03,119 --> 00:46:07,680
mentioned earlier tells us that our

1371
00:46:04,400 --> 00:46:07,680
schemes are cca secure

1372
00:46:08,319 --> 00:46:11,839
here we mentioned some prime work and

1373
00:46:09,920 --> 00:46:14,880
the maximal security properties that the

1374
00:46:11,839 --> 00:46:17,440
schemes can achieve

1375
00:46:14,880 --> 00:46:19,040
and our suite of schemes achieves the

1376
00:46:17,440 --> 00:46:22,720
best-known security level for updateable

1377
00:46:19,040 --> 00:46:22,720
encryption with seministic updates

1378
00:46:24,240 --> 00:46:28,160
so efficiency very much depends on the

1379
00:46:26,240 --> 00:46:29,279
sizes of the messages being encrypted

1380
00:46:28,160 --> 00:46:31,680
so please see the paper for a more

1381
00:46:29,280 --> 00:46:34,400
thorough comparison of efficiency and

1382
00:46:31,680 --> 00:46:34,399
also security

1383
00:46:34,560 --> 00:46:39,040
so at the cpa level and the cca level

1384
00:46:37,200 --> 00:46:41,040
for short and long messages

1385
00:46:39,040 --> 00:46:43,839
our schemes are at least as fast as

1386
00:46:41,040 --> 00:46:43,839
prior work

1387
00:46:45,359 --> 00:46:49,680
okay so to wrap up we give a new

1388
00:46:48,000 --> 00:46:50,960
security definition for updated

1389
00:46:49,680 --> 00:46:52,480
encryption schemes

1390
00:46:50,960 --> 00:46:54,960
uh we show the expected composition

1391
00:46:52,480 --> 00:46:56,480
result and we give a new suite about

1392
00:46:54,960 --> 00:46:58,079
updated encryption schemes

1393
00:46:56,480 --> 00:47:01,040
that meet the strongest possible known

1394
00:46:58,079 --> 00:47:01,040
security definitions

1395
00:47:01,119 --> 00:47:04,640
um from a technical point of view we

1396
00:47:03,359 --> 00:47:06,240
also advance the

1397
00:47:04,640 --> 00:47:08,560
capabilities of some existing proof

1398
00:47:06,240 --> 00:47:10,240
techniques in particular this

1399
00:47:08,560 --> 00:47:13,040
epoch separation strategy that's been

1400
00:47:10,240 --> 00:47:14,078
used in prior work

1401
00:47:13,040 --> 00:47:15,839
thanks very much for listening and

1402
00:47:14,079 --> 00:47:18,560
please check out the extended talk for

1403
00:47:15,839 --> 00:47:18,560
many more details

1404
00:47:19,119 --> 00:47:26,000
thanks thanks gareth let's move to

1405
00:47:23,280 --> 00:47:26,880
questions from the audience so there's

1406
00:47:26,000 --> 00:47:28,400
one

1407
00:47:26,880 --> 00:47:29,680
yeah there's one question it's just it's

1408
00:47:28,400 --> 00:47:30,559
a short question so i'm just going to

1409
00:47:29,680 --> 00:47:33,359
read it out

1410
00:47:30,559 --> 00:47:36,559
um pratik sarkar asks what is debt and

1411
00:47:33,359 --> 00:47:39,359
deterministics in that cca

1412
00:47:36,559 --> 00:47:40,240
so this means that the uh so this is

1413
00:47:39,359 --> 00:47:41,440
from

1414
00:47:40,240 --> 00:47:43,439
the perspective of the security

1415
00:47:41,440 --> 00:47:44,480
definition but it's basically to cover

1416
00:47:43,440 --> 00:47:47,680
schemes

1417
00:47:44,480 --> 00:47:50,640
um for which the the update procedure

1418
00:47:47,680 --> 00:47:51,598
um this exponentiation by the token for

1419
00:47:50,640 --> 00:47:53,680
example

1420
00:47:51,599 --> 00:47:55,119
is deterministic so you do not need to

1421
00:47:53,680 --> 00:47:55,839
generate randomness to update the

1422
00:47:55,119 --> 00:47:57,359
ciphertext

1423
00:47:55,839 --> 00:48:00,160
i remember it's the server that's doing

1424
00:47:57,359 --> 00:48:00,160
this updating

1425
00:48:00,640 --> 00:48:04,400
for that actually i had a question on

1426
00:48:02,400 --> 00:48:06,240
the slide while we wait for more

1427
00:48:04,400 --> 00:48:08,400
questions we have a couple of minutes

1428
00:48:06,240 --> 00:48:09,759
so the permutation which is i guess

1429
00:48:08,400 --> 00:48:11,839
modeled as an idea of

1430
00:48:09,760 --> 00:48:12,960
either permutation is that is that

1431
00:48:11,839 --> 00:48:14,880
public uh

1432
00:48:12,960 --> 00:48:16,480
in in the scheme or is that is that part

1433
00:48:14,880 --> 00:48:19,920
of the private key basically

1434
00:48:16,480 --> 00:48:21,119
no no this is public so um in paper i

1435
00:48:19,920 --> 00:48:24,079
think we

1436
00:48:21,119 --> 00:48:25,920
mentioned the possibility of using um

1437
00:48:24,079 --> 00:48:27,680
aes with

1438
00:48:25,920 --> 00:48:29,359
let's say normal size but large blocks

1439
00:48:27,680 --> 00:48:31,440
say 512 bits

1440
00:48:29,359 --> 00:48:34,078
with a key of all zeros so this would be

1441
00:48:31,440 --> 00:48:35,680
absolutely fine as far as our

1442
00:48:34,079 --> 00:48:37,599
construction is concerned because the

1443
00:48:35,680 --> 00:48:39,919
nonce is the thing that provides the

1444
00:48:37,599 --> 00:48:42,720
randomness in the initial encryption

1445
00:48:39,920 --> 00:48:44,400
um so the ideal cipher here uh

1446
00:48:42,720 --> 00:48:47,439
essentially models the inability

1447
00:48:44,400 --> 00:48:49,520
of an adversary to

1448
00:48:47,440 --> 00:48:51,440
gather any information by doing anything

1449
00:48:49,520 --> 00:48:54,000
other than actually

1450
00:48:51,440 --> 00:48:55,440
managing to get this decryption key it

1451
00:48:54,000 --> 00:48:58,640
makes the proof a lot easier

1452
00:48:55,440 --> 00:48:59,200
and is is a wide block is that a problem

1453
00:48:58,640 --> 00:49:02,319
for the

1454
00:48:59,200 --> 00:49:03,919
for schemes in the sense that

1455
00:49:02,319 --> 00:49:05,680
so it does create some challenges with

1456
00:49:03,920 --> 00:49:06,160
mapping to for example elliptic curve

1457
00:49:05,680 --> 00:49:09,118
groups

1458
00:49:06,160 --> 00:49:10,640
um but it's certainly possible um you

1459
00:49:09,119 --> 00:49:13,520
just need to be a bit careful

1460
00:49:10,640 --> 00:49:14,558
with um mapping to the the correct group

1461
00:49:13,520 --> 00:49:17,040
and there's

1462
00:49:14,559 --> 00:49:19,599
yeah a discussion of this in the paper

1463
00:49:17,040 --> 00:49:22,160
um which is perhaps more conclusive than

1464
00:49:19,599 --> 00:49:23,280
what i can try and uh go across here

1465
00:49:22,160 --> 00:49:25,200
cool

1466
00:49:23,280 --> 00:49:26,880
um i see there are no other questions uh

1467
00:49:25,200 --> 00:49:28,640
on zulu or on the chat but

1468
00:49:26,880 --> 00:49:29,920
again feel free to add questions in the

1469
00:49:28,640 --> 00:49:31,920
description session

1470
00:49:29,920 --> 00:49:33,280
and that we can continue discussion so i

1471
00:49:31,920 --> 00:49:34,240
think with that we can go to the next

1472
00:49:33,280 --> 00:49:37,359
talk later

1473
00:49:34,240 --> 00:49:40,000
yes yeah

1474
00:49:37,359 --> 00:49:40,960
thanks again gareth and the last talk in

1475
00:49:40,000 --> 00:49:45,040
this session

1476
00:49:40,960 --> 00:49:47,720
will be given by daniel wicks

1477
00:49:45,040 --> 00:49:49,839
it's uh the talk on incompre

1478
00:49:47,720 --> 00:49:51,680
incompressible encodings

1479
00:49:49,839 --> 00:49:53,520
and it's a joint work with tal moran

1480
00:49:51,680 --> 00:49:55,359
daniel go ahead

1481
00:49:53,520 --> 00:49:57,040
great thank you all right so let me

1482
00:49:55,359 --> 00:49:59,040
start with a question and uh the

1483
00:49:57,040 --> 00:50:01,279
question is how much space does it take

1484
00:49:59,040 --> 00:50:02,640
to store wikipedia

1485
00:50:01,280 --> 00:50:05,359
so it turns out you can actually

1486
00:50:02,640 --> 00:50:05,759
download a copy of wikipedia for offline

1487
00:50:05,359 --> 00:50:07,680
use

1488
00:50:05,760 --> 00:50:09,839
and some reasonable version of it is

1489
00:50:07,680 --> 00:50:12,799
about 50 gigabytes in length so it's

1490
00:50:09,839 --> 00:50:14,160
quite largest as you'd expect

1491
00:50:12,800 --> 00:50:15,599
but uh there's another way to store

1492
00:50:14,160 --> 00:50:18,640
wikipedia which is you just store the

1493
00:50:15,599 --> 00:50:20,640
link www.wikipedia.org that only takes

1494
00:50:18,640 --> 00:50:22,000
17 bytes and as long as you have an

1495
00:50:20,640 --> 00:50:23,440
internet connection

1496
00:50:22,000 --> 00:50:25,040
using this link you can access the

1497
00:50:23,440 --> 00:50:26,640
wikipedia data whenever

1498
00:50:25,040 --> 00:50:28,880
you want so it's sort of as good as

1499
00:50:26,640 --> 00:50:30,960
storing the wikipedia data

1500
00:50:28,880 --> 00:50:32,640
and the point i want to make is that

1501
00:50:30,960 --> 00:50:35,520
when we consider some public data like

1502
00:50:32,640 --> 00:50:37,040
wikipedia even if the data is very large

1503
00:50:35,520 --> 00:50:39,839
because it's public it's trivial to

1504
00:50:37,040 --> 00:50:41,279
compress it just store the link for it

1505
00:50:39,839 --> 00:50:43,119
and so the main question or goal for

1506
00:50:41,280 --> 00:50:45,359
this talk is to come up with some sort

1507
00:50:43,119 --> 00:50:46,880
of an incompressible representation of

1508
00:50:45,359 --> 00:50:48,400
public data in other words

1509
00:50:46,880 --> 00:50:50,880
i want to have some representation on

1510
00:50:48,400 --> 00:50:52,160
wikipedia that requires the full 50

1511
00:50:50,880 --> 00:50:53,920
gigabytes to store

1512
00:50:52,160 --> 00:50:55,759
even for someone that has the link to

1513
00:50:53,920 --> 00:50:58,000
the underlying wikipedia data and can

1514
00:50:55,760 --> 00:50:59,839
access that for free so that's the

1515
00:50:58,000 --> 00:51:01,839
notion of incompressible encodings and

1516
00:50:59,839 --> 00:51:03,680
uh let me actually define it so it just

1517
00:51:01,839 --> 00:51:04,960
consists of two algorithm and encoding

1518
00:51:03,680 --> 00:51:07,279
and a decoding algorithm

1519
00:51:04,960 --> 00:51:09,119
these are key less public algorithms

1520
00:51:07,280 --> 00:51:10,240
anyone can run them there's no secret

1521
00:51:09,119 --> 00:51:12,079
keys

1522
00:51:10,240 --> 00:51:13,919
the encoding algorithm is a

1523
00:51:12,079 --> 00:51:15,359
probabilistic algorithm it takes some

1524
00:51:13,920 --> 00:51:18,000
data m as an input

1525
00:51:15,359 --> 00:51:19,598
and it encodes it into a codeword c and

1526
00:51:18,000 --> 00:51:21,440
you can think of this code word

1527
00:51:19,599 --> 00:51:22,800
as some sort of randomized

1528
00:51:21,440 --> 00:51:26,160
representation

1529
00:51:22,800 --> 00:51:27,599
of the underlying data anybody can come

1530
00:51:26,160 --> 00:51:30,240
and decode the codeword

1531
00:51:27,599 --> 00:51:31,680
and recover the original data so it's

1532
00:51:30,240 --> 00:51:33,839
having the code word is as good as

1533
00:51:31,680 --> 00:51:35,759
having the underlying data

1534
00:51:33,839 --> 00:51:37,359
and we want correctness if you encode

1535
00:51:35,760 --> 00:51:39,520
and then decode you get back the

1536
00:51:37,359 --> 00:51:41,520
original message

1537
00:51:39,520 --> 00:51:43,359
and we want incompressibility which

1538
00:51:41,520 --> 00:51:44,640
considers an attacker that knows the

1539
00:51:43,359 --> 00:51:46,480
underlying data so

1540
00:51:44,640 --> 00:51:47,839
the attacker has the link for wikipedia

1541
00:51:46,480 --> 00:51:50,079
he knows wikipedia for free

1542
00:51:47,839 --> 00:51:50,960
but his goal is to compress this code

1543
00:51:50,079 --> 00:51:52,480
word this uh

1544
00:51:50,960 --> 00:51:54,319
this randomized representation of

1545
00:51:52,480 --> 00:51:56,640
wikipedia that we created

1546
00:51:54,319 --> 00:51:58,000
so uh the attacker concept2 algorithm

1547
00:51:56,640 --> 00:52:00,078
compression decompression

1548
00:51:58,000 --> 00:52:02,160
the compression gets the code word tries

1549
00:52:00,079 --> 00:52:03,440
to compress it down into some smaller

1550
00:52:02,160 --> 00:52:05,118
value w

1551
00:52:03,440 --> 00:52:07,119
and then later we want to be the attack

1552
00:52:05,119 --> 00:52:08,720
wants to take w and decompress it to

1553
00:52:07,119 --> 00:52:11,200
recover the code right

1554
00:52:08,720 --> 00:52:12,558
and the security requirements is that no

1555
00:52:11,200 --> 00:52:13,919
efficient adversary should be able to

1556
00:52:12,559 --> 00:52:15,440
succeed in this game

1557
00:52:13,920 --> 00:52:18,079
should be able to succeed in compressing

1558
00:52:15,440 --> 00:52:19,760
codeword with better than negligible

1559
00:52:18,079 --> 00:52:22,000
probability

1560
00:52:19,760 --> 00:52:23,040
so we have two parameters here uh

1561
00:52:22,000 --> 00:52:25,520
there's the

1562
00:52:23,040 --> 00:52:26,880
codeword size alpha and here we want the

1563
00:52:25,520 --> 00:52:28,480
codeword size alpha to

1564
00:52:26,880 --> 00:52:30,839
not be too much bigger than the data

1565
00:52:28,480 --> 00:52:33,119
size so the encoding should not add much

1566
00:52:30,839 --> 00:52:34,720
overhead and then there's the parameter

1567
00:52:33,119 --> 00:52:36,000
beta which is how much adversary is

1568
00:52:34,720 --> 00:52:38,000
allowed to compress to

1569
00:52:36,000 --> 00:52:39,520
and we want that to be uh also

1570
00:52:38,000 --> 00:52:40,880
essentially as big as the entire data

1571
00:52:39,520 --> 00:52:42,480
size or code word size

1572
00:52:40,880 --> 00:52:44,240
which says that dataset needs to store

1573
00:52:42,480 --> 00:52:46,559
essentially the entire covert

1574
00:52:44,240 --> 00:52:49,520
in order to be uh later able to

1575
00:52:46,559 --> 00:52:51,839
decompress it and recover

1576
00:52:49,520 --> 00:52:53,599
so it turns out that this notion uh was

1577
00:52:51,839 --> 00:52:55,599
introduced in a prior work from crypto

1578
00:52:53,599 --> 00:52:56,720
last year by dom guard ganesh and erlai

1579
00:52:55,599 --> 00:52:58,720
orlandi

1580
00:52:56,720 --> 00:53:00,399
and they defined a slight variant of

1581
00:52:58,720 --> 00:53:02,720
these incompressible encodings

1582
00:53:00,400 --> 00:53:03,680
uh they had a different name for it but

1583
00:53:02,720 --> 00:53:05,680
they thought of as

1584
00:53:03,680 --> 00:53:07,440
a tool for building a larger

1585
00:53:05,680 --> 00:53:09,200
cryptographic primitive called proofs of

1586
00:53:07,440 --> 00:53:11,200
replicated storage and i'm not going to

1587
00:53:09,200 --> 00:53:13,118
talk about what those are

1588
00:53:11,200 --> 00:53:15,118
but in that context they give a

1589
00:53:13,119 --> 00:53:16,240
construction of these incompressible

1590
00:53:15,119 --> 00:53:18,400
encoding

1591
00:53:16,240 --> 00:53:19,759
i'll be here with several major caveats

1592
00:53:18,400 --> 00:53:21,280
so one of the caveats is that the

1593
00:53:19,760 --> 00:53:23,920
construction required some ideal

1594
00:53:21,280 --> 00:53:26,800
permutation a random oracle model

1595
00:53:23,920 --> 00:53:28,400
the encoding time was also quadratic and

1596
00:53:26,800 --> 00:53:30,319
here we want to apply this to very large

1597
00:53:28,400 --> 00:53:30,800
data like many gigabytes of terabytes in

1598
00:53:30,319 --> 00:53:32,640
length

1599
00:53:30,800 --> 00:53:34,000
and so quadratic time is real

1600
00:53:32,640 --> 00:53:35,520
impractical

1601
00:53:34,000 --> 00:53:37,920
and lastly it turns out that the prove

1602
00:53:35,520 --> 00:53:40,079
secure they had was floater or someone

1603
00:53:37,920 --> 00:53:41,119
completed didn't consider it didn't work

1604
00:53:40,079 --> 00:53:43,200
for fully general

1605
00:53:41,119 --> 00:53:45,359
attackers and this was actually also

1606
00:53:43,200 --> 00:53:46,799
observed by concurrent work towers by

1607
00:53:45,359 --> 00:53:49,119
gargoyle and waters

1608
00:53:46,800 --> 00:53:50,480
and they managed to actually give a

1609
00:53:49,119 --> 00:53:51,920
fixed version of this proof so prove

1610
00:53:50,480 --> 00:53:52,720
that the original scheme from that work

1611
00:53:51,920 --> 00:53:54,559
is secure

1612
00:53:52,720 --> 00:53:58,399
uh required quite a bit of an effort and

1613
00:53:54,559 --> 00:54:00,240
it's a complicated and subtle proof

1614
00:53:58,400 --> 00:54:01,760
so in our work we essentially uh

1615
00:54:00,240 --> 00:54:03,598
initiate the study of random

1616
00:54:01,760 --> 00:54:05,280
of these incompressible encodings as a

1617
00:54:03,599 --> 00:54:07,599
standalone primitive that

1618
00:54:05,280 --> 00:54:08,559
uh is sort of of interest in its own

1619
00:54:07,599 --> 00:54:10,079
right

1620
00:54:08,559 --> 00:54:12,000
and uh we give new and improved

1621
00:54:10,079 --> 00:54:13,920
construction so we show construction

1622
00:54:12,000 --> 00:54:15,760
that works in just the common

1623
00:54:13,920 --> 00:54:17,599
reference string or random string model

1624
00:54:15,760 --> 00:54:18,800
uh without random oracles the encoding

1625
00:54:17,599 --> 00:54:21,440
time is linear

1626
00:54:18,800 --> 00:54:21,839
and lastly uh our proof is fairly simple

1627
00:54:21,440 --> 00:54:23,520
uh

1628
00:54:21,839 --> 00:54:24,880
so so it's a different construction with

1629
00:54:23,520 --> 00:54:26,400
that with a much simpler proof

1630
00:54:24,880 --> 00:54:28,000
we also give some lower bounds and

1631
00:54:26,400 --> 00:54:28,640
negative results for example showing

1632
00:54:28,000 --> 00:54:29,760
that the

1633
00:54:28,640 --> 00:54:31,118
common reference string model is

1634
00:54:29,760 --> 00:54:31,839
necessary you can't do it in the plain

1635
00:54:31,119 --> 00:54:34,240
model

1636
00:54:31,839 --> 00:54:36,400
at least under black box reductions and

1637
00:54:34,240 --> 00:54:37,598
we also give a new application to bicky

1638
00:54:36,400 --> 00:54:38,960
cryptography

1639
00:54:37,599 --> 00:54:41,119
so let me mention a little bit about

1640
00:54:38,960 --> 00:54:42,400
this application this is motivated by

1641
00:54:41,119 --> 00:54:44,960
computers becoming

1642
00:54:42,400 --> 00:54:45,839
compromised remote attacker hacking the

1643
00:54:44,960 --> 00:54:47,359
computer

1644
00:54:45,839 --> 00:54:48,720
and if you have a small cryptographic

1645
00:54:47,359 --> 00:54:49,440
key on your computer that's the first

1646
00:54:48,720 --> 00:54:50,640
thing that that

1647
00:54:49,440 --> 00:54:52,720
is going to steal are going to

1648
00:54:50,640 --> 00:54:54,400
exfiltrate it's very valuable

1649
00:54:52,720 --> 00:54:56,319
and the idea to prevent against that is

1650
00:54:54,400 --> 00:54:58,000
let's make our secret keys big like many

1651
00:54:56,319 --> 00:54:59,440
gigabytes or terabytes

1652
00:54:58,000 --> 00:55:01,839
and the idea is big keys should be

1653
00:54:59,440 --> 00:55:03,680
harder to exfiltrate maybe because you

1654
00:55:01,839 --> 00:55:06,319
have some firewall that detects

1655
00:55:03,680 --> 00:55:08,000
such large leakage and so there's

1656
00:55:06,319 --> 00:55:10,160
actually been a lot of work on this on

1657
00:55:08,000 --> 00:55:11,119
this idea uh called biki cryptosystems

1658
00:55:10,160 --> 00:55:14,078
or bonded

1659
00:55:11,119 --> 00:55:14,880
retrieval model but one thing common to

1660
00:55:14,079 --> 00:55:17,599
all these works

1661
00:55:14,880 --> 00:55:19,280
is that they require the user to waste a

1662
00:55:17,599 --> 00:55:20,240
lot of their storage and storing this

1663
00:55:19,280 --> 00:55:22,240
long uh

1664
00:55:20,240 --> 00:55:24,799
secret key many gigabytes or terabytes

1665
00:55:22,240 --> 00:55:27,279
on key which is useless for any for any

1666
00:55:24,799 --> 00:55:29,280
other purpose other than to do crypto

1667
00:55:27,280 --> 00:55:31,040
and so the idea and our work is let's

1668
00:55:29,280 --> 00:55:33,680
make the key useful let's make it

1669
00:55:31,040 --> 00:55:35,680
uh store some information the user would

1670
00:55:33,680 --> 00:55:37,200
want to store anyway maybe wikipedia or

1671
00:55:35,680 --> 00:55:40,960
their movie collection

1672
00:55:37,200 --> 00:55:42,799
etc so is wikipedia a good secret key

1673
00:55:40,960 --> 00:55:44,319
well obviously no wikipedia is public

1674
00:55:42,799 --> 00:55:45,920
everyone has it on the internet it's a

1675
00:55:44,319 --> 00:55:47,200
terrible idea to use wikipedia as your

1676
00:55:45,920 --> 00:55:49,040
secret key

1677
00:55:47,200 --> 00:55:50,799
but the idea is to use an incompressible

1678
00:55:49,040 --> 00:55:52,640
encoding of wikipedia

1679
00:55:50,799 --> 00:55:54,319
and uh this makes sense because we

1680
00:55:52,640 --> 00:55:56,078
showed that in compressible encoding

1681
00:55:54,319 --> 00:55:57,839
requires cannot be compressive and

1682
00:55:56,079 --> 00:55:59,119
adversary wanted to exfiltrate this

1683
00:55:57,839 --> 00:56:01,599
incompressible encoding

1684
00:55:59,119 --> 00:56:03,680
you would have to essentially exfiltrate

1685
00:56:01,599 --> 00:56:05,760
the entire size of the data

1686
00:56:03,680 --> 00:56:07,118
so a lot of information and so we

1687
00:56:05,760 --> 00:56:09,119
construct public key

1688
00:56:07,119 --> 00:56:10,400
uh encryption in the setting where the

1689
00:56:09,119 --> 00:56:12,000
secret key can be incur and then

1690
00:56:10,400 --> 00:56:14,079
compressor then coding some useful data

1691
00:56:12,000 --> 00:56:15,119
like wikipedia or movie collection

1692
00:56:14,079 --> 00:56:17,119
and the adversary will need to

1693
00:56:15,119 --> 00:56:18,720
exfiltrate almost the entire key to

1694
00:56:17,119 --> 00:56:20,319
break security

1695
00:56:18,720 --> 00:56:21,839
so in the last minute or so let me just

1696
00:56:20,319 --> 00:56:23,920
give a very uh

1697
00:56:21,839 --> 00:56:25,279
a brief and simplified uh version of our

1698
00:56:23,920 --> 00:56:26,400
construction of these incompressible

1699
00:56:25,280 --> 00:56:28,160
encodings

1700
00:56:26,400 --> 00:56:29,599
and here i'm going to assume we have

1701
00:56:28,160 --> 00:56:31,440
something called the lossy trapped or

1702
00:56:29,599 --> 00:56:32,079
permutation so it's a lossy chapter

1703
00:56:31,440 --> 00:56:33,680
function

1704
00:56:32,079 --> 00:56:35,680
which is also a permutation we don't

1705
00:56:33,680 --> 00:56:37,118
quite have these and in the paper we

1706
00:56:35,680 --> 00:56:39,200
deal with that but for the simplified

1707
00:56:37,119 --> 00:56:40,640
view let's just pretend we have them

1708
00:56:39,200 --> 00:56:41,919
and something called the message i'm

1709
00:56:40,640 --> 00:56:43,200
just going to pick a public key of this

1710
00:56:41,920 --> 00:56:45,119
permutation

1711
00:56:43,200 --> 00:56:46,799
and i'm going to use that along with a

1712
00:56:45,119 --> 00:56:49,200
trapdoor and use the trapdoor to invert

1713
00:56:46,799 --> 00:56:52,559
this permutation on the message xor

1714
00:56:49,200 --> 00:56:55,439
with the common random string so uh uh

1715
00:56:52,559 --> 00:56:55,839
and this uh x the inver the inverse i

1716
00:56:55,440 --> 00:56:58,400
get

1717
00:56:55,839 --> 00:56:59,920
is going to be part of the codeword and

1718
00:56:58,400 --> 00:57:02,000
so you can easily decode in

1719
00:56:59,920 --> 00:57:03,040
by decode this by computing the

1720
00:57:02,000 --> 00:57:05,839
permutation

1721
00:57:03,040 --> 00:57:06,319
in the forward direction and the secure

1722
00:57:05,839 --> 00:57:08,000
proof

1723
00:57:06,319 --> 00:57:09,440
real consider just two steps the first

1724
00:57:08,000 --> 00:57:10,559
step is let me just switch the

1725
00:57:09,440 --> 00:57:13,520
distribution

1726
00:57:10,559 --> 00:57:14,799
and of the codeword and think of

1727
00:57:13,520 --> 00:57:17,839
choosing it by choosing

1728
00:57:14,799 --> 00:57:19,680
x to be random and computing programming

1729
00:57:17,839 --> 00:57:22,319
the common random string the crs

1730
00:57:19,680 --> 00:57:24,000
to be f of x xor with the message so

1731
00:57:22,319 --> 00:57:25,200
this is exactly the same distribution

1732
00:57:24,000 --> 00:57:26,880
nothing changed

1733
00:57:25,200 --> 00:57:28,399
but then the second step now i'm not

1734
00:57:26,880 --> 00:57:31,680
using the trapdoor anywhere

1735
00:57:28,400 --> 00:57:33,839
and i can switch the public key to lossy

1736
00:57:31,680 --> 00:57:35,839
which means that fpk of x loses much of

1737
00:57:33,839 --> 00:57:38,000
the information about x

1738
00:57:35,839 --> 00:57:39,599
and in this case once i do that then

1739
00:57:38,000 --> 00:57:40,079
because fpk of x doesn't reveal much

1740
00:57:39,599 --> 00:57:42,559
information

1741
00:57:40,079 --> 00:57:43,920
about x the x part of the code word has

1742
00:57:42,559 --> 00:57:46,079
a lot of real entropy

1743
00:57:43,920 --> 00:57:47,920
even given the crs and therefore it

1744
00:57:46,079 --> 00:57:48,799
cannot even information theoretically be

1745
00:57:47,920 --> 00:57:50,240
compressed

1746
00:57:48,799 --> 00:57:52,319
and this shows that in the original

1747
00:57:50,240 --> 00:57:54,160
distribution a

1748
00:57:52,319 --> 00:57:55,599
computation leg cannot be compressed

1749
00:57:54,160 --> 00:57:56,720
otherwise the attacker could distinguish

1750
00:57:55,599 --> 00:58:01,359
these cases

1751
00:57:56,720 --> 00:58:01,359
so that's the entire idea and thank you

1752
00:58:02,240 --> 00:58:05,919
thanks danielle thanks for the talk we

1753
00:58:04,960 --> 00:58:08,400
have still

1754
00:58:05,920 --> 00:58:10,480
a few minutes maybe if there is a short

1755
00:58:08,400 --> 00:58:12,960
question yeah there is a question

1756
00:58:10,480 --> 00:58:14,559
announced maybe moderate please sure

1757
00:58:12,960 --> 00:58:15,760
yeah um i actually had a quick question

1758
00:58:14,559 --> 00:58:17,839
and then there's another one on the on

1759
00:58:15,760 --> 00:58:19,240
the zoom chart so my quick question was

1760
00:58:17,839 --> 00:58:21,440
uh so you mentioned you can use

1761
00:58:19,240 --> 00:58:22,240
incompressible encodings in this big key

1762
00:58:21,440 --> 00:58:23,760
crypto

1763
00:58:22,240 --> 00:58:26,558
are there any extra steps you need to

1764
00:58:23,760 --> 00:58:27,920
take uh to sort of use the big key or

1765
00:58:26,559 --> 00:58:29,280
is it some standard kind of

1766
00:58:27,920 --> 00:58:30,319
transformation i can plug and play sort

1767
00:58:29,280 --> 00:58:31,920
of thing

1768
00:58:30,319 --> 00:58:33,520
yeah absolutely that so i didn't mention

1769
00:58:31,920 --> 00:58:35,440
a lot of that but our extra steps so we

1770
00:58:33,520 --> 00:58:37,920
need to build a specially

1771
00:58:35,440 --> 00:58:38,640
designed public encryption for this

1772
00:58:37,920 --> 00:58:41,520
purpose

1773
00:58:38,640 --> 00:58:43,200
uh it's essentially public encryption

1774
00:58:41,520 --> 00:58:46,160
that ensures that the only way to break

1775
00:58:43,200 --> 00:58:47,919
security is to have some sort of a

1776
00:58:46,160 --> 00:58:49,279
version of the secret key i can take an

1777
00:58:47,920 --> 00:58:51,359
attacker break security

1778
00:58:49,280 --> 00:58:52,880
and extract the secret key out of them

1779
00:58:51,359 --> 00:58:54,480
so any such attacker that

1780
00:58:52,880 --> 00:58:56,400
would leak a small amount of info and

1781
00:58:54,480 --> 00:58:57,520
break security would serve as a

1782
00:58:56,400 --> 00:58:58,960
compression algorithm for the

1783
00:58:57,520 --> 00:59:00,480
incompressible encoding

1784
00:58:58,960 --> 00:59:02,079
so it's slightly related to the

1785
00:59:00,480 --> 00:59:03,680
compressibility sort of definition

1786
00:59:02,079 --> 00:59:06,799
basically

1787
00:59:03,680 --> 00:59:08,319
yeah i need encryption i need them to

1788
00:59:06,799 --> 00:59:10,640
work together uh that's useful

1789
00:59:08,319 --> 00:59:13,359
um so radeep had a question i mean you

1790
00:59:10,640 --> 00:59:13,359
can admit yourself

1791
00:59:14,319 --> 00:59:17,839
hi thanks for the talk daniel so uh i

1792
00:59:16,799 --> 00:59:19,440
wanted to ask that

1793
00:59:17,839 --> 00:59:21,920
in the proof of security you will need

1794
00:59:19,440 --> 00:59:23,359
to uh program the crs right so is it

1795
00:59:21,920 --> 00:59:24,880
true that you can only prove selective

1796
00:59:23,359 --> 00:59:26,880
security in this case

1797
00:59:24,880 --> 00:59:28,640
yeah absolutely good point uh so yeah we

1798
00:59:26,880 --> 00:59:29,040
only prove selective security and we

1799
00:59:28,640 --> 00:59:31,920
actually

1800
00:59:29,040 --> 00:59:32,960
show uh that this is inherent that you

1801
00:59:31,920 --> 00:59:34,880
cannot prove

1802
00:59:32,960 --> 00:59:36,480
adaptive security in the cs model via

1803
00:59:34,880 --> 00:59:38,160
black box reductions

1804
00:59:36,480 --> 00:59:40,079
so we also give an alternate

1805
00:59:38,160 --> 00:59:41,359
construction where you replace the crs

1806
00:59:40,079 --> 00:59:44,400
with a random oracle

1807
00:59:41,359 --> 00:59:47,839
then you can even get adaptive security

1808
00:59:44,400 --> 00:59:47,839
okay thanks

1809
00:59:48,880 --> 00:59:53,920
um yeah no more questions so

1810
00:59:52,079 --> 00:59:55,440
there aren't any questions actually

1811
00:59:53,920 --> 00:59:57,119
maybe there's one question from your

1812
00:59:55,440 --> 01:00:00,160
guinea on a different talk

1813
00:59:57,119 --> 01:00:01,680
um so maybe you can

1814
01:00:00,160 --> 01:00:03,440
quickly ask that you're getting and then

1815
01:00:01,680 --> 01:00:04,960
we can wrap up uh

1816
01:00:03,440 --> 01:00:06,559
well very quickly for updatable

1817
01:00:04,960 --> 01:00:08,000
encryption it's a very nice construction

1818
01:00:06,559 --> 01:00:09,680
and what we recall there are standard

1819
01:00:08,000 --> 01:00:10,640
model constructions of updatable

1820
01:00:09,680 --> 01:00:12,960
encryptions

1821
01:00:10,640 --> 01:00:14,000
do they achieve your level of security

1822
01:00:12,960 --> 01:00:16,400
or there is some inherent

1823
01:00:14,000 --> 01:00:16,400
barrier

1824
01:00:17,520 --> 01:00:20,640
uh yeah it's a really good question and

1825
01:00:19,520 --> 01:00:23,759
something that um

1826
01:00:20,640 --> 01:00:26,879
certainly article about quite a lot um

1827
01:00:23,760 --> 01:00:30,480
the real challenge here is that

1828
01:00:26,880 --> 01:00:33,359
in this very strong corruption model um

1829
01:00:30,480 --> 01:00:35,280
in order to provide uh non-challenged

1830
01:00:33,359 --> 01:00:37,440
ciphertexts this is in some sense like a

1831
01:00:35,280 --> 01:00:38,960
commitment to the epoch key

1832
01:00:37,440 --> 01:00:40,480
so we really need some way of

1833
01:00:38,960 --> 01:00:44,000
programming

1834
01:00:40,480 --> 01:00:47,040
our challenge uh into our reduction

1835
01:00:44,000 --> 01:00:48,799
and i really don't know how to do this

1836
01:00:47,040 --> 01:00:51,200
in these schemes where you have

1837
01:00:48,799 --> 01:00:53,839
essentially exponentiation for

1838
01:00:51,200 --> 01:00:56,399
encryption and updating um but i think

1839
01:00:53,839 --> 01:00:56,400
this is really

1840
01:00:56,480 --> 01:00:59,599
something that might be possible if

1841
01:00:58,559 --> 01:01:02,000
maybe you have

1842
01:00:59,599 --> 01:01:03,280
an assumption on the plp security but

1843
01:01:02,000 --> 01:01:05,119
then

1844
01:01:03,280 --> 01:01:07,359
this seems to just create a lot more

1845
01:01:05,119 --> 01:01:10,240
problems uh in the proof

1846
01:01:07,359 --> 01:01:11,598
than it actually solves so i would

1847
01:01:10,240 --> 01:01:13,598
really like to know the answer to this

1848
01:01:11,599 --> 01:01:16,000
as well

1849
01:01:13,599 --> 01:01:16,000
thank you

1850
01:01:18,480 --> 01:01:24,640
okay so yeah

1851
01:01:21,599 --> 01:01:26,160
wrapping up here i guess let's thank all

1852
01:01:24,640 --> 01:01:28,640
the speakers in this session

1853
01:01:26,160 --> 01:01:30,399
thank you all for joining uh please

1854
01:01:28,640 --> 01:01:33,920
continue on zulip and i guess

1855
01:01:30,400 --> 01:01:37,359
yeah next up is

1856
01:01:33,920 --> 01:01:40,640
social hour anyway so yeah yes

1857
01:01:37,359 --> 01:01:43,279
and i believe uh leo

1858
01:01:40,640 --> 01:01:44,720
should um say something except now i

1859
01:01:43,280 --> 01:01:46,559
realize i'm putting him on the spot

1860
01:01:44,720 --> 01:01:50,078
because i haven't told him what to say

1861
01:01:46,559 --> 01:01:53,839
um we are

1862
01:01:50,079 --> 01:01:53,839
leo if you want to chime in

1863
01:01:54,880 --> 01:01:58,480
because there will be a social hour i'll

1864
01:01:57,119 --> 01:02:01,839
just chime in to say

1865
01:01:58,480 --> 01:02:03,359
uh we're going to use the there's a link

1866
01:02:01,839 --> 01:02:06,960
on the program that you can go to we're

1867
01:02:03,359 --> 01:02:06,960
going to use the app from tuesday and so

