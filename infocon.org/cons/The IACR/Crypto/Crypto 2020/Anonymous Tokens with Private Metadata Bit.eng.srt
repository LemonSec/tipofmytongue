1
00:00:00,799 --> 00:00:05,759
hi my name is mikhaile and i will be

2
00:00:02,960 --> 00:00:07,359
presenting our work on anonymous tokens

3
00:00:05,759 --> 00:00:10,880
this is joint work with bank creator

4
00:00:07,359 --> 00:00:12,400
duncan le pong and mariana reichova

5
00:00:10,880 --> 00:00:14,320
in our work we introduce anonymous

6
00:00:12,400 --> 00:00:16,320
tokens a lightweight single-use

7
00:00:14,320 --> 00:00:17,920
anonymous credential

8
00:00:16,320 --> 00:00:20,720
they are basically authorizations that

9
00:00:17,920 --> 00:00:22,080
can be used only once

10
00:00:20,720 --> 00:00:23,759
throughout this talk we will focus on

11
00:00:22,080 --> 00:00:25,919
credentials that are secret key namely

12
00:00:23,760 --> 00:00:27,599
whatever entity issues these tokens

13
00:00:25,920 --> 00:00:29,119
will be also the entity that redeems

14
00:00:27,599 --> 00:00:30,560
them

15
00:00:29,119 --> 00:00:32,800
we will also require these tokens to

16
00:00:30,560 --> 00:00:34,960
allow the issuer to embed a secret bit

17
00:00:32,800 --> 00:00:36,879
that can be read redemption time and is

18
00:00:34,960 --> 00:00:38,800
hidden from the user

19
00:00:36,880 --> 00:00:40,160
this for instance will allow for the

20
00:00:38,800 --> 00:00:42,320
construction of a block list

21
00:00:40,160 --> 00:00:43,680
that is not detectable by the user at

22
00:00:42,320 --> 00:00:46,079
the cost of slightly diminishing the

23
00:00:43,680 --> 00:00:47,680
anonymity set

24
00:00:46,079 --> 00:00:49,120
so let me share a couple stories from

25
00:00:47,680 --> 00:00:52,160
the real-world trenches on why this

26
00:00:49,120 --> 00:00:52,160
primitive is relevant

27
00:00:52,399 --> 00:00:55,520
on the internet it is difficult to

28
00:00:54,079 --> 00:00:57,760
identify if requests come from

29
00:00:55,520 --> 00:00:59,359
legitimate users or bots

30
00:00:57,760 --> 00:01:01,680
it is even more difficult to do so with

31
00:00:59,359 --> 00:01:05,119
privacy in mind without logging services

32
00:01:01,680 --> 00:01:06,720
or third-party cookies generally

33
00:01:05,119 --> 00:01:08,720
website protection services like

34
00:01:06,720 --> 00:01:10,798
cloudflare act as a middleman

35
00:01:08,720 --> 00:01:12,000
to filter requests between a user and a

36
00:01:10,799 --> 00:01:15,600
web server for instance

37
00:01:12,000 --> 00:01:17,280
a cdn they assess the trustworthiness of

38
00:01:15,600 --> 00:01:18,240
a user generally on the base of their ip

39
00:01:17,280 --> 00:01:20,400
address

40
00:01:18,240 --> 00:01:22,158
which leads to a lot of false positives

41
00:01:20,400 --> 00:01:24,080
especially in the case of shared pus

42
00:01:22,159 --> 00:01:24,799
which is the case of anonymity services

43
00:01:24,080 --> 00:01:29,679
like tor

44
00:01:24,799 --> 00:01:31,840
or i2p or also in the case of vpns

45
00:01:29,680 --> 00:01:33,680
in cloudflare if an ap was suspected to

46
00:01:31,840 --> 00:01:35,600
be a bot instead of a legitimate user

47
00:01:33,680 --> 00:01:39,119
another round of communication was added

48
00:01:35,600 --> 00:01:41,600
and they were presented with a challenge

49
00:01:39,119 --> 00:01:43,600
it's basically meant to capture actually

50
00:01:41,600 --> 00:01:45,919
often times more than one

51
00:01:43,600 --> 00:01:49,039
and because of this the web experience

52
00:01:45,920 --> 00:01:50,640
of tour user became basically unbearable

53
00:01:49,040 --> 00:01:52,240
there were hashtags on blocked or on

54
00:01:50,640 --> 00:01:55,200
twitter and at hacker conferences you

55
00:01:52,240 --> 00:01:57,119
could even see stickers like this one

56
00:01:55,200 --> 00:01:58,640
in a few years however cloudflare

57
00:01:57,119 --> 00:02:01,439
implemented and deployed the solution

58
00:01:58,640 --> 00:02:04,479
called privacy pass

59
00:02:01,439 --> 00:02:06,000
privacy pass is anonymous token it comes

60
00:02:04,479 --> 00:02:07,600
in the form of a web extension

61
00:02:06,000 --> 00:02:09,840
where after successfully solving a

62
00:02:07,600 --> 00:02:10,318
captcha the user receives also a bunch

63
00:02:09,840 --> 00:02:13,599
of these

64
00:02:10,318 --> 00:02:15,920
tokens these tokens can be later spent

65
00:02:13,599 --> 00:02:17,519
instead of solving new captchas and

66
00:02:15,920 --> 00:02:18,399
because of the cryptographic properties

67
00:02:17,520 --> 00:02:20,560
of the tokens

68
00:02:18,400 --> 00:02:21,920
the anonymity of the user is preserved

69
00:02:20,560 --> 00:02:23,840
while at the same time it is not

70
00:02:21,920 --> 00:02:26,319
possible to spend more tokens than fp

71
00:02:23,840 --> 00:02:26,319
you should

72
00:02:26,879 --> 00:02:30,560
more recently other tech companies join

73
00:02:29,280 --> 00:02:32,800
the party

74
00:02:30,560 --> 00:02:34,080
brave israel now using anonymous tokens

75
00:02:32,800 --> 00:02:36,160
in order to

76
00:02:34,080 --> 00:02:38,080
reward in a privacy preserving manner

77
00:02:36,160 --> 00:02:40,000
user that the receiver are

78
00:02:38,080 --> 00:02:42,319
users that received advertisement on

79
00:02:40,000 --> 00:02:44,239
their browser

80
00:02:42,319 --> 00:02:46,000
facebook wants to use them in order to

81
00:02:44,239 --> 00:02:48,080
assess whether a user stands out a

82
00:02:46,000 --> 00:02:49,280
statistical anomaly

83
00:02:48,080 --> 00:02:50,640
more precisely they would like to

84
00:02:49,280 --> 00:02:52,160
understand for instance if a user

85
00:02:50,640 --> 00:02:54,238
clicked too frequently

86
00:02:52,160 --> 00:02:55,599
on too many ads without completing any

87
00:02:54,239 --> 00:02:58,800
purchase

88
00:02:55,599 --> 00:03:00,560
while at the same time avoiding sharing

89
00:02:58,800 --> 00:03:03,280
sensitive information about users with

90
00:03:00,560 --> 00:03:03,280
other websites

91
00:03:03,519 --> 00:03:08,480
google and more specifically chromium

92
00:03:05,840 --> 00:03:10,000
want to get rid of their party cookies

93
00:03:08,480 --> 00:03:11,518
third-party cookies are cookies that can

94
00:03:10,000 --> 00:03:13,200
be read by different origins for

95
00:03:11,519 --> 00:03:16,840
instance they can be set by google

96
00:03:13,200 --> 00:03:18,159
and then be read when i'm visiting

97
00:03:16,840 --> 00:03:19,920
bcc.com

98
00:03:18,159 --> 00:03:21,280
they can be used in order to assess if a

99
00:03:19,920 --> 00:03:23,040
user is fraudulent

100
00:03:21,280 --> 00:03:25,840
but at the same time they allow for

101
00:03:23,040 --> 00:03:27,440
tracking across different websites

102
00:03:25,840 --> 00:03:28,959
ideally we would like to be able to

103
00:03:27,440 --> 00:03:30,840
prevent spammy behavior

104
00:03:28,959 --> 00:03:32,159
without tracking an individual across a

105
00:03:30,840 --> 00:03:34,560
web

106
00:03:32,159 --> 00:03:36,159
so one solution for this is to issue

107
00:03:34,560 --> 00:03:38,080
tokens from popular websites

108
00:03:36,159 --> 00:03:39,200
and provide a service that allows to

109
00:03:38,080 --> 00:03:41,120
redeem them

110
00:03:39,200 --> 00:03:44,159
whenever we have an activity that is

111
00:03:41,120 --> 00:03:44,159
acceptable to abuse

112
00:03:45,120 --> 00:03:50,959
in some cases it is also crucial to

113
00:03:47,840 --> 00:03:52,799
protect against adversarial learning

114
00:03:50,959 --> 00:03:55,599
what may mean is that for instance if

115
00:03:52,799 --> 00:03:58,080
the issuer detects a malicious behavior

116
00:03:55,599 --> 00:03:59,599
and decides not to issue a token this

117
00:03:58,080 --> 00:04:01,200
different kind of response

118
00:03:59,599 --> 00:04:02,798
can be used in order to train algorithms

119
00:04:01,200 --> 00:04:06,720
that understand what kind of behavior

120
00:04:02,799 --> 00:04:06,720
led to spam detection and what didn't

121
00:04:07,599 --> 00:04:11,280
in these cases we want to issue

122
00:04:09,360 --> 00:04:12,959
credential also to suspicious actor

123
00:04:11,280 --> 00:04:14,319
and then decide at redemption time what

124
00:04:12,959 --> 00:04:15,680
to do with them

125
00:04:14,319 --> 00:04:19,199
for instance if you shouldn't provide a

126
00:04:15,680 --> 00:04:19,199
service to a user in a block list

127
00:04:19,358 --> 00:04:23,680
at this point the issuer if malicious

128
00:04:22,079 --> 00:04:24,160
could also split the anonymity set in

129
00:04:23,680 --> 00:04:25,840
two

130
00:04:24,160 --> 00:04:28,160
but there is a trade-off at play here

131
00:04:25,840 --> 00:04:30,159
between functionality and anonymity

132
00:04:28,160 --> 00:04:32,320
and it's still better and it is still a

133
00:04:30,160 --> 00:04:34,479
better solution than tracking

134
00:04:32,320 --> 00:04:38,400
in all of these cases what you want is a

135
00:04:34,479 --> 00:04:38,400
functionality called private metadata

136
00:04:38,880 --> 00:04:42,960
so how do we formalize such a credential

137
00:04:40,560 --> 00:04:44,880
system we are basically looking for two

138
00:04:42,960 --> 00:04:47,359
protocols

139
00:04:44,880 --> 00:04:48,240
an issuance protocol possibly of only

140
00:04:47,360 --> 00:04:50,160
one round

141
00:04:48,240 --> 00:04:53,040
where at the end of it the user gets a

142
00:04:50,160 --> 00:04:55,280
token given as input and nonce

143
00:04:53,040 --> 00:04:56,080
from the user and in the case of a

144
00:04:55,280 --> 00:05:00,400
private metadata

145
00:04:56,080 --> 00:05:02,000
bit the given bit by the issuer

146
00:05:00,400 --> 00:05:03,919
and the redemption algorithm that allows

147
00:05:02,000 --> 00:05:07,759
to check if the token is valid

148
00:05:03,919 --> 00:05:09,680
and read off the bit from the token

149
00:05:07,759 --> 00:05:11,520
for simplicity we will assume that the

150
00:05:09,680 --> 00:05:13,759
user communicates with the issuer over

151
00:05:11,520 --> 00:05:16,240
an authenticated and encrypted channel

152
00:05:13,759 --> 00:05:17,600
so basically over tls all the time and

153
00:05:16,240 --> 00:05:20,240
there is no man in the middle that can

154
00:05:17,600 --> 00:05:21,600
steal the tokens from a user

155
00:05:20,240 --> 00:05:22,960
in the paper however we will also

156
00:05:21,600 --> 00:05:24,479
provide generic ways for achieving

157
00:05:22,960 --> 00:05:25,198
security fest to men in the middle

158
00:05:24,479 --> 00:05:26,560
attacks

159
00:05:25,199 --> 00:05:29,120
which in this case are called token

160
00:05:26,560 --> 00:05:29,120
hijacking

161
00:05:29,360 --> 00:05:32,960
if we forget about token hijacking there

162
00:05:31,120 --> 00:05:35,520
are three base security properties that

163
00:05:32,960 --> 00:05:38,320
these algorithms should satisfy

164
00:05:35,520 --> 00:05:39,520
first unlinkability after interacting

165
00:05:38,320 --> 00:05:41,120
with multiple users

166
00:05:39,520 --> 00:05:43,120
it should be difficult for the issuer to

167
00:05:41,120 --> 00:05:44,800
link a particular token to its issuance

168
00:05:43,120 --> 00:05:46,880
session

169
00:05:44,800 --> 00:05:48,400
in the case of a private metadata bit we

170
00:05:46,880 --> 00:05:50,479
demand that

171
00:05:48,400 --> 00:05:53,840
it is not possible to link two sessions

172
00:05:50,479 --> 00:05:53,840
as long as they have the same bit

173
00:05:54,000 --> 00:05:57,280
formally this is achieved by letting the

174
00:05:56,000 --> 00:05:58,720
adversary pick even the public

175
00:05:57,280 --> 00:06:00,239
parameters but then demanding the

176
00:05:58,720 --> 00:06:01,919
existence of an extractor

177
00:06:00,240 --> 00:06:04,319
that can find out they then beat from a

178
00:06:01,919 --> 00:06:04,318
token

179
00:06:05,199 --> 00:06:08,240
and if you're familiar with blind

180
00:06:06,319 --> 00:06:09,600
signatures this is somewhat close to the

181
00:06:08,240 --> 00:06:12,000
definition of blindness

182
00:06:09,600 --> 00:06:15,039
if we forget about privacy of the method

183
00:06:12,000 --> 00:06:16,720
private metadata bit

184
00:06:15,039 --> 00:06:18,800
when more affordability instead protects

185
00:06:16,720 --> 00:06:20,960
the issuer it says that it is difficult

186
00:06:18,800 --> 00:06:21,600
for the user to spend l plus one valid

187
00:06:20,960 --> 00:06:23,440
tokens

188
00:06:21,600 --> 00:06:25,199
after interacting with the issuer l

189
00:06:23,440 --> 00:06:26,800
times

190
00:06:25,199 --> 00:06:28,720
in the case of a private metadata bit

191
00:06:26,800 --> 00:06:31,280
will allow the server to provide

192
00:06:28,720 --> 00:06:32,880
l-ish ones for each bit but ask for a

193
00:06:31,280 --> 00:06:35,840
plus one forgeries on the same bit by

194
00:06:32,880 --> 00:06:35,840
the adversary

195
00:06:36,400 --> 00:06:40,400
finally privacy of the metadata bit says

196
00:06:38,880 --> 00:06:41,039
that an issuance session with a bit set

197
00:06:40,400 --> 00:06:42,560
to 0

198
00:06:41,039 --> 00:06:45,360
should be indistinguishable from an

199
00:06:42,560 --> 00:06:46,880
issuance sessions with a bit set 1.

200
00:06:45,360 --> 00:06:48,479
in the distinguishability game the

201
00:06:46,880 --> 00:06:49,680
adversary is also able to observe

202
00:06:48,479 --> 00:06:51,758
multiple sessions

203
00:06:49,680 --> 00:06:53,120
even for bits of their own choice and

204
00:06:51,759 --> 00:06:55,919
then they must make a guess on a

205
00:06:53,120 --> 00:06:55,919
challenge session

206
00:06:56,479 --> 00:06:59,599
in the paper we also deal with a

207
00:06:57,599 --> 00:07:00,159
verification article namely an article

208
00:06:59,599 --> 00:07:02,479
that

209
00:07:00,160 --> 00:07:04,319
will check if a token is valid or not

210
00:07:02,479 --> 00:07:06,400
but for seconds implicitly i'm not going

211
00:07:04,319 --> 00:07:07,840
to consider it for the rest of this talk

212
00:07:06,400 --> 00:07:11,039
and invite you to check the paper for a

213
00:07:07,840 --> 00:07:11,039
stronger security model

214
00:07:11,120 --> 00:07:14,400
and why why are we doing all this why

215
00:07:12,800 --> 00:07:16,160
are we giving these definitions

216
00:07:14,400 --> 00:07:18,239
well because people want to standardize

217
00:07:16,160 --> 00:07:19,919
them the w3c

218
00:07:18,240 --> 00:07:22,080
would like to provide a javascript api

219
00:07:19,919 --> 00:07:24,880
in the browser that allows to demand

220
00:07:22,080 --> 00:07:26,639
and to redeem tokens the atf is

221
00:07:24,880 --> 00:07:28,000
standardizing privacy pass

222
00:07:26,639 --> 00:07:29,680
the protocol that i mentioned when i

223
00:07:28,000 --> 00:07:31,280
spoke about cloudflare

224
00:07:29,680 --> 00:07:32,960
including extensions such as the private

225
00:07:31,280 --> 00:07:34,559
metadata bit

226
00:07:32,960 --> 00:07:36,318
and as we believe it is important that

227
00:07:34,560 --> 00:07:37,840
these new cryptographic primitives

228
00:07:36,319 --> 00:07:40,479
undergo a formal assessment before

229
00:07:37,840 --> 00:07:40,479
deployment

230
00:07:41,520 --> 00:07:45,198
our contribution in this work has been

231
00:07:42,960 --> 00:07:46,400
to formally set down these definitions

232
00:07:45,199 --> 00:07:48,240
and provide a number of efficient

233
00:07:46,400 --> 00:07:49,599
protocols that satisfy them in the

234
00:07:48,240 --> 00:07:51,280
random oracle model

235
00:07:49,599 --> 00:07:52,960
with standard assumptions and without

236
00:07:51,280 --> 00:07:54,878
pairings

237
00:07:52,960 --> 00:07:56,479
more precisely we provide new protocols

238
00:07:54,879 --> 00:07:58,560
that efficiently implement anonymous

239
00:07:56,479 --> 00:08:00,479
tokens with private metadata bit

240
00:07:58,560 --> 00:08:01,840
and we illustrate also new techniques

241
00:08:00,479 --> 00:08:02,479
for getting rid of the zero knowledge

242
00:08:01,840 --> 00:08:04,479
proofs

243
00:08:02,479 --> 00:08:05,840
both in previously published protocols

244
00:08:04,479 --> 00:08:08,240
and in the ones that we provide

245
00:08:05,840 --> 00:08:10,400
ourselves

246
00:08:08,240 --> 00:08:12,080
unfortunately there are not many options

247
00:08:10,400 --> 00:08:13,039
already available in the space if we

248
00:08:12,080 --> 00:08:16,800
want

249
00:08:13,039 --> 00:08:16,800
anonymous tokens with private metadata

250
00:08:18,639 --> 00:08:22,000
full fledge and remote credential are

251
00:08:20,319 --> 00:08:23,759
just too expensive for instance if we

252
00:08:22,000 --> 00:08:26,080
think in the case of advertisement

253
00:08:23,759 --> 00:08:27,440
we need an olympus token that has fast

254
00:08:26,080 --> 00:08:30,719
redemption

255
00:08:27,440 --> 00:08:32,640
and also they are public key

256
00:08:30,720 --> 00:08:34,240
we have algebraic macs that are being

257
00:08:32,640 --> 00:08:35,439
used in signal right now and they cover

258
00:08:34,240 --> 00:08:37,039
a similar space

259
00:08:35,440 --> 00:08:38,959
but unfortunately they must support

260
00:08:37,039 --> 00:08:40,799
private metadata and they are also

261
00:08:38,958 --> 00:08:43,199
mods lower than privacy packs for

262
00:08:40,799 --> 00:08:43,199
instance

263
00:08:44,320 --> 00:08:47,600
we also have blind signatures and

264
00:08:45,839 --> 00:08:49,120
variations of blind signatures for

265
00:08:47,600 --> 00:08:51,279
instance conditional blind signatures

266
00:08:49,120 --> 00:08:53,519
that allow for private metadata

267
00:08:51,279 --> 00:08:54,959
however again they are public key and as

268
00:08:53,519 --> 00:08:56,480
we will see later conditional blind

269
00:08:54,959 --> 00:08:59,359
signatures are insecure for many

270
00:08:56,480 --> 00:08:59,360
parallel sessions

271
00:09:00,800 --> 00:09:03,839
the starting point of our work is

272
00:09:02,160 --> 00:09:05,839
privacy pass so a protocol without

273
00:09:03,839 --> 00:09:07,279
private metadata

274
00:09:05,839 --> 00:09:08,560
privacy pass assumes that the

275
00:09:07,279 --> 00:09:09,760
participants share some public

276
00:09:08,560 --> 00:09:11,839
informations

277
00:09:09,760 --> 00:09:13,439
a primordial cyclic group and a group

278
00:09:11,839 --> 00:09:15,680
element chosen by the issuer

279
00:09:13,440 --> 00:09:18,320
of which only they they know the

280
00:09:15,680 --> 00:09:18,319
discrete log

281
00:09:18,880 --> 00:09:22,399
the issuance protocol consists in a

282
00:09:20,320 --> 00:09:25,600
planning phase where the user blends the

283
00:09:22,399 --> 00:09:27,279
nonce and sends it out to the server

284
00:09:25,600 --> 00:09:29,200
the server then proceeds with assigning

285
00:09:27,279 --> 00:09:31,600
phase where computes the cth

286
00:09:29,200 --> 00:09:33,120
between the blended value and the given

287
00:09:31,600 --> 00:09:34,959
parameter

288
00:09:33,120 --> 00:09:36,959
finally the user proceeds on blending

289
00:09:34,959 --> 00:09:38,479
the token

290
00:09:36,959 --> 00:09:40,239
verification at this point simply

291
00:09:38,480 --> 00:09:43,040
consists in checking whether

292
00:09:40,240 --> 00:09:44,240
the given group element is the cgh

293
00:09:43,040 --> 00:09:46,800
between

294
00:09:44,240 --> 00:09:48,640
the hash of the nonce and the parameter

295
00:09:46,800 --> 00:09:50,719
provided

296
00:09:48,640 --> 00:09:52,480
now unforgeability of this scheme is

297
00:09:50,720 --> 00:09:54,080
exactly one more defiant

298
00:09:52,480 --> 00:09:55,680
the challenger is giving out many

299
00:09:54,080 --> 00:09:58,000
challenge group elements via the

300
00:09:55,680 --> 00:10:00,160
random oracle and adversary has to

301
00:09:58,000 --> 00:10:02,240
compute one more cdh in order to provide

302
00:10:00,160 --> 00:10:03,920
a forgery

303
00:10:02,240 --> 00:10:05,360
unlinkability on the other end is more

304
00:10:03,920 --> 00:10:06,800
difficult because the server could have

305
00:10:05,360 --> 00:10:09,200
used different acts

306
00:10:06,800 --> 00:10:10,560
to compute the cdh in each session and

307
00:10:09,200 --> 00:10:13,440
thus link a user

308
00:10:10,560 --> 00:10:15,359
with a different key by decisional

309
00:10:13,440 --> 00:10:17,200
defilement even more it's impossible for

310
00:10:15,360 --> 00:10:18,240
the user to know if the same secret key

311
00:10:17,200 --> 00:10:20,480
has been used

312
00:10:18,240 --> 00:10:21,839
and for this reason in fact we must add

313
00:10:20,480 --> 00:10:24,399
a zero knowledge proof

314
00:10:21,839 --> 00:10:26,000
the guarantees that the computation of w

315
00:10:24,399 --> 00:10:27,920
was done correctly

316
00:10:26,000 --> 00:10:29,920
by zero knowledge the proof can be

317
00:10:27,920 --> 00:10:32,319
simulated in the affordability game and

318
00:10:29,920 --> 00:10:34,000
the proof goes exactly as before but by

319
00:10:32,320 --> 00:10:35,760
soundness now the protocol is also

320
00:10:34,000 --> 00:10:37,279
unlinkable because we are guaranteed the

321
00:10:35,760 --> 00:10:39,360
same key has been used

322
00:10:37,279 --> 00:10:41,839
and because t is completely unrelated to

323
00:10:39,360 --> 00:10:41,839
the nonce

324
00:10:43,279 --> 00:10:46,560
now as i mentioned this protocol does

325
00:10:44,720 --> 00:10:47,120
not have a private metadata and one

326
00:10:46,560 --> 00:10:50,560
tribal

327
00:10:47,120 --> 00:10:52,560
one trivial way to extend this report

328
00:10:50,560 --> 00:10:54,000
could be to have two keys and provide a

329
00:10:52,560 --> 00:10:55,599
proof that either one of the two has

330
00:10:54,000 --> 00:10:57,360
been used

331
00:10:55,600 --> 00:10:59,200
during the issuance phase now we would

332
00:10:57,360 --> 00:11:00,880
use one of the two keys depending on the

333
00:10:59,200 --> 00:11:03,120
bit that it's chosen

334
00:11:00,880 --> 00:11:04,800
and we our proof would be another proof

335
00:11:03,120 --> 00:11:07,839
that either one of the two keys

336
00:11:04,800 --> 00:11:07,839
published has been used

337
00:11:08,320 --> 00:11:12,160
while very informally this protocol

338
00:11:10,000 --> 00:11:13,600
achieves unlinkability and affordability

339
00:11:12,160 --> 00:11:15,600
it does not really hide the private

340
00:11:13,600 --> 00:11:17,440
metadata bit

341
00:11:15,600 --> 00:11:19,040
in fact consider an attacker that starts

342
00:11:17,440 --> 00:11:22,079
two parallel sessions with the same

343
00:11:19,040 --> 00:11:23,519
non-st and at the end receive the cdh

344
00:11:22,079 --> 00:11:25,920
and also the zero-knowledge proof that

345
00:11:23,519 --> 00:11:28,560
i'm going between ignore

346
00:11:25,920 --> 00:11:29,920
if the bit use was the same then i'm

347
00:11:28,560 --> 00:11:30,479
blending will lead to the same group

348
00:11:29,920 --> 00:11:32,719
element

349
00:11:30,480 --> 00:11:33,920
otherwise it won't so the adversary has

350
00:11:32,720 --> 00:11:35,760
learned some information about the

351
00:11:33,920 --> 00:11:38,399
hidden bit

352
00:11:35,760 --> 00:11:39,760
and this is a real mistake that could

353
00:11:38,399 --> 00:11:40,959
happen and has happened

354
00:11:39,760 --> 00:11:42,560
and it shows that we really need a

355
00:11:40,959 --> 00:11:43,920
formal analysis and more eyes on this

356
00:11:42,560 --> 00:11:46,239
protocol in order to provide security

357
00:11:43,920 --> 00:11:46,240
backs

358
00:11:47,920 --> 00:11:52,399
the problem of the previous protocol was

359
00:11:49,680 --> 00:11:55,199
that it was based on a deterministic

360
00:11:52,399 --> 00:11:56,000
protocol on avioprf so let me say

361
00:11:55,200 --> 00:11:59,120
present a simple

362
00:11:56,000 --> 00:12:01,440
variant of the above protocol that

363
00:11:59,120 --> 00:12:02,959
will uh will not be successful to the

364
00:12:01,440 --> 00:12:04,480
same issue

365
00:12:02,959 --> 00:12:06,880
the trick is basically to add another

366
00:12:04,480 --> 00:12:07,760
generator now instead of having a single

367
00:12:06,880 --> 00:12:09,360
generator g

368
00:12:07,760 --> 00:12:11,040
we have two generators of which you

369
00:12:09,360 --> 00:12:12,160
don't know the disrespective discrete

370
00:12:11,040 --> 00:12:16,480
log

371
00:12:12,160 --> 00:12:17,920
the public key is now in these two basis

372
00:12:16,480 --> 00:12:20,320
in the scanning phase we do not only

373
00:12:17,920 --> 00:12:21,599
compute the cdh with the group element

374
00:12:20,320 --> 00:12:23,360
given by the user

375
00:12:21,600 --> 00:12:24,880
but we also add another element

376
00:12:23,360 --> 00:12:27,200
partially chosen by the issuer

377
00:12:24,880 --> 00:12:30,320
and the signature is done under this

378
00:12:27,200 --> 00:12:31,920
group element and one given by the user

379
00:12:30,320 --> 00:12:33,839
and blending is performed as before

380
00:12:31,920 --> 00:12:35,519
except that now we also multiply

381
00:12:33,839 --> 00:12:39,839
by the blending factor the element

382
00:12:35,519 --> 00:12:39,839
chosen by the issuer

383
00:12:40,000 --> 00:12:43,360
as before we must also add a

384
00:12:42,000 --> 00:12:45,120
zero-knowledge proof to prove that the

385
00:12:43,360 --> 00:12:47,600
same key is being used across multiple

386
00:12:45,120 --> 00:12:47,600
sessions

387
00:12:47,839 --> 00:12:51,279
this protocol despite being more complex

388
00:12:49,760 --> 00:12:52,959
than the previous one will have the

389
00:12:51,279 --> 00:12:53,680
property that the same trick of using

390
00:12:52,959 --> 00:12:56,959
two keys

391
00:12:53,680 --> 00:12:56,959
will lead to a secure protocol

392
00:12:59,200 --> 00:13:04,880
in fact now if we use two different keys

393
00:13:03,040 --> 00:13:06,639
the private metadata bit 0 cannot be

394
00:13:04,880 --> 00:13:08,639
distinguished from the bit set to 1

395
00:13:06,639 --> 00:13:10,560
because we can find an s that will work

396
00:13:08,639 --> 00:13:14,000
for 1 if the bit is set to 0

397
00:13:10,560 --> 00:13:15,599
via a sequence of hybrids

398
00:13:14,000 --> 00:13:17,440
actually for private privacy of the

399
00:13:15,600 --> 00:13:19,440
metadata bit there are small issues of

400
00:13:17,440 --> 00:13:20,160
malleability in case we provide a

401
00:13:19,440 --> 00:13:22,800
verification

402
00:13:20,160 --> 00:13:24,079
article but it satisfies the notion of

403
00:13:22,800 --> 00:13:25,519
privacy of the metadata

404
00:13:24,079 --> 00:13:27,279
that i gave during this talk and invite

405
00:13:25,519 --> 00:13:29,440
you to check the paper to see

406
00:13:27,279 --> 00:13:32,399
a stronger protocol that is secure also

407
00:13:29,440 --> 00:13:34,160
faced to a verification article

408
00:13:32,399 --> 00:13:35,839
the protocol is also unforgeable because

409
00:13:34,160 --> 00:13:36,719
we can embed a challenging one of the

410
00:13:35,839 --> 00:13:39,839
two keys

411
00:13:36,720 --> 00:13:42,720
in a similar way that we did before

412
00:13:39,839 --> 00:13:45,920
and make a guess on which bit the

413
00:13:42,720 --> 00:13:47,920
adversary will present a forgery

414
00:13:45,920 --> 00:13:49,680
and the protocol is also unlinkable for

415
00:13:47,920 --> 00:13:51,519
the same reason as before because t

416
00:13:49,680 --> 00:13:53,519
prime does not have any information

417
00:13:51,519 --> 00:13:55,120
about the nonce and the same key is

418
00:13:53,519 --> 00:14:02,959
being used across the session

419
00:13:55,120 --> 00:14:04,959
provided that we use the same hidden bit

420
00:14:02,959 --> 00:14:06,638
now let me show another completely

421
00:14:04,959 --> 00:14:09,680
different way

422
00:14:06,639 --> 00:14:10,480
for that we can use in the initial

423
00:14:09,680 --> 00:14:11,920
protocol

424
00:14:10,480 --> 00:14:13,760
for getting rid of the general knowledge

425
00:14:11,920 --> 00:14:17,439
proof

426
00:14:13,760 --> 00:14:19,040
in in privacy pass

427
00:14:17,440 --> 00:14:20,639
we can use in addition to a

428
00:14:19,040 --> 00:14:21,279
multiplicative mask in the blinding

429
00:14:20,639 --> 00:14:23,360
phase

430
00:14:21,279 --> 00:14:24,959
we can also use an additive mask

431
00:14:23,360 --> 00:14:27,920
shifting

432
00:14:24,959 --> 00:14:30,239
the blended element by a group element

433
00:14:27,920 --> 00:14:32,959
of which we know the discrete log

434
00:14:30,240 --> 00:14:34,800
the summing procedure stays unchanged in

435
00:14:32,959 --> 00:14:36,000
the planning phase now we would have to

436
00:14:34,800 --> 00:14:39,359
shift back this group

437
00:14:36,000 --> 00:14:40,800
element but because we the issuer

438
00:14:39,360 --> 00:14:44,000
multiplied the element by

439
00:14:40,800 --> 00:14:45,279
x we have to remove this quantity by the

440
00:14:44,000 --> 00:14:47,680
element that's been published by the

441
00:14:45,279 --> 00:14:47,680
server

442
00:14:49,199 --> 00:14:52,800
verification proceeds exactly as before

443
00:14:51,120 --> 00:14:53,760
i'm checking for the cdh between the

444
00:14:52,800 --> 00:14:56,880
element published

445
00:14:53,760 --> 00:14:58,560
and the hash of the token

446
00:14:56,880 --> 00:15:00,720
so the code on the server side as you

447
00:14:58,560 --> 00:15:03,279
can see is basically unchanged actually

448
00:15:00,720 --> 00:15:04,880
we are removing the zero-knowledge proof

449
00:15:03,279 --> 00:15:07,279
on the client there is on the other hand

450
00:15:04,880 --> 00:15:09,680
there's slightly increasing computation

451
00:15:07,279 --> 00:15:11,360
the basic idea in this protocol is that

452
00:15:09,680 --> 00:15:12,000
now if the public key that's been used

453
00:15:11,360 --> 00:15:14,320
for signing

454
00:15:12,000 --> 00:15:16,000
is different from the one published we

455
00:15:14,320 --> 00:15:18,720
will end up with a completely

456
00:15:16,000 --> 00:15:20,800
random and invalid token so now the

457
00:15:18,720 --> 00:15:24,240
anonymity set is split between

458
00:15:20,800 --> 00:15:26,639
valid tokens and invalid tokens

459
00:15:24,240 --> 00:15:27,839
and users can mitigate the risk of

460
00:15:26,639 --> 00:15:29,759
malicious issues

461
00:15:27,839 --> 00:15:32,000
trying to trace down users with invalid

462
00:15:29,759 --> 00:15:34,800
tokens by sending random group elements

463
00:15:32,000 --> 00:15:34,800
from time to time

464
00:15:35,120 --> 00:15:38,320
this protocol is unlinkable provided

465
00:15:36,800 --> 00:15:41,040
that we accept this partition of the

466
00:15:38,320 --> 00:15:42,639
anonymity set

467
00:15:41,040 --> 00:15:44,079
and forge ability on the other hand is

468
00:15:42,639 --> 00:15:47,279
based on one more different

469
00:15:44,079 --> 00:15:47,279
in the same way as before

470
00:15:50,079 --> 00:15:56,479
note now that this technique this trick

471
00:15:53,440 --> 00:15:57,920
is also compatible with the with the

472
00:15:56,480 --> 00:15:59,440
technique that they showed for adding a

473
00:15:57,920 --> 00:16:00,160
private metadata bit so they can be

474
00:15:59,440 --> 00:16:01,680
combined

475
00:16:00,160 --> 00:16:03,680
leading to a protocol that has private

476
00:16:01,680 --> 00:16:05,839
metadata and does not have

477
00:16:03,680 --> 00:16:07,279
does not require their knowledge proof i

478
00:16:05,839 --> 00:16:10,959
invite you to check the paper for more

479
00:16:07,279 --> 00:16:10,959
details on how this protocol works

480
00:16:12,959 --> 00:16:16,959
now it takes more than nice security

481
00:16:14,880 --> 00:16:18,560
protocols based on solid cryptography to

482
00:16:16,959 --> 00:16:21,040
make something useful

483
00:16:18,560 --> 00:16:21,758
so now that we've seen a bit more

484
00:16:21,040 --> 00:16:24,000
formally

485
00:16:21,759 --> 00:16:25,839
how these protocols are constructed let

486
00:16:24,000 --> 00:16:27,360
me take a couple minutes to show what it

487
00:16:25,839 --> 00:16:29,440
means to bridge the gap between theory

488
00:16:27,360 --> 00:16:31,279
and practice

489
00:16:29,440 --> 00:16:32,480
first of all the security assumptions we

490
00:16:31,279 --> 00:16:34,839
managed to move

491
00:16:32,480 --> 00:16:37,120
all the security assumption to one more

492
00:16:34,839 --> 00:16:38,240
defilement we know of great analytic

493
00:16:37,120 --> 00:16:40,079
attacks on them

494
00:16:38,240 --> 00:16:41,360
namely brown gallant and coin attack

495
00:16:40,079 --> 00:16:43,920
that allow to recover with

496
00:16:41,360 --> 00:16:46,639
sub-exponential complexity

497
00:16:43,920 --> 00:16:49,519
the secret key however they also depend

498
00:16:46,639 --> 00:16:52,240
on small divisors of p plus or minus one

499
00:16:49,519 --> 00:16:55,040
and for uh curved using course using

500
00:16:52,240 --> 00:16:57,680
practice for instance ker25519

501
00:16:55,040 --> 00:16:58,639
it is difficult to understand whether

502
00:16:57,680 --> 00:17:02,560
this should consider

503
00:16:58,639 --> 00:17:02,560
a real danger because they use a lot of

504
00:17:02,839 --> 00:17:07,120
bandwidth

505
00:17:05,039 --> 00:17:08,559
token hijacking let's assume for a

506
00:17:07,119 --> 00:17:10,319
second that the client is sending out

507
00:17:08,559 --> 00:17:13,119
requests over http

508
00:17:10,319 --> 00:17:14,559
so unencrypted and not authenticated

509
00:17:13,119 --> 00:17:16,399
what can we do in this case

510
00:17:14,559 --> 00:17:18,639
it turns out it's really inexpensive to

511
00:17:16,400 --> 00:17:19,679
prevent hijacking of tokens from a man

512
00:17:18,640 --> 00:17:21,439
in the middle

513
00:17:19,679 --> 00:17:24,400
in fact it's sufficient just to use a

514
00:17:21,439 --> 00:17:26,240
mac this was already shown by goldberg

515
00:17:24,400 --> 00:17:28,160
another but in our paper we present a

516
00:17:26,240 --> 00:17:32,080
genetic way that works on the top of all

517
00:17:28,160 --> 00:17:33,679
the previous protocols that i mentioned

518
00:17:32,080 --> 00:17:35,600
there are also engineering issues that

519
00:17:33,679 --> 00:17:36,320
need need to be taken into account like

520
00:17:35,600 --> 00:17:38,399
throttling

521
00:17:36,320 --> 00:17:40,320
how many tokens can be issued at once

522
00:17:38,400 --> 00:17:41,919
how often do you rotate the keys

523
00:17:40,320 --> 00:17:44,480
and also where do you store more

524
00:17:41,919 --> 00:17:45,760
importantly all these public parameters

525
00:17:44,480 --> 00:17:48,799
because all the users should have the

526
00:17:45,760 --> 00:17:48,799
same visibility on them

527
00:17:49,679 --> 00:17:53,039
another side we also provide an

528
00:17:51,120 --> 00:17:54,879
implementation placed based on the

529
00:17:53,039 --> 00:17:58,400
blazingly fast

530
00:17:54,880 --> 00:18:01,600
implementation of kerchief 519 by

531
00:17:58,400 --> 00:18:04,720
isis and henry and

532
00:18:01,600 --> 00:18:07,039
we did it on the top using restrict on

533
00:18:04,720 --> 00:18:08,720
the top for a prime order group element

534
00:18:07,039 --> 00:18:11,200
we published extender benchmark and we

535
00:18:08,720 --> 00:18:13,280
are now working on a port in webassem

536
00:18:11,200 --> 00:18:15,840
that can be used to perform demos in the

537
00:18:13,280 --> 00:18:15,840
browser

538
00:18:17,039 --> 00:18:20,960
we're taking also some other directions

539
00:18:18,960 --> 00:18:22,880
for instance public metadata

540
00:18:20,960 --> 00:18:24,400
because in the real world oftentimes you

541
00:18:22,880 --> 00:18:27,440
have multiple data centers

542
00:18:24,400 --> 00:18:29,440
each one following its own key cycle it

543
00:18:27,440 --> 00:18:31,039
would be interesting at this point

544
00:18:29,440 --> 00:18:32,720
to have public metadata that can be

545
00:18:31,039 --> 00:18:36,000
embedded in order to track which data

546
00:18:32,720 --> 00:18:38,320
center is issuing which tokens

547
00:18:36,000 --> 00:18:39,520
public verifiability a legitimate

548
00:18:38,320 --> 00:18:41,200
question is also whether

549
00:18:39,520 --> 00:18:43,520
the previous protocols can be made

550
00:18:41,200 --> 00:18:46,160
publicly verifiable

551
00:18:43,520 --> 00:18:47,120
for instance if an entity can be can

552
00:18:46,160 --> 00:18:48,880
verify the token

553
00:18:47,120 --> 00:18:50,559
and then another one can extract the bit

554
00:18:48,880 --> 00:18:52,000
from it

555
00:18:50,559 --> 00:18:53,840
even just if we look about blind

556
00:18:52,000 --> 00:18:54,880
signatures for instance privacy pass can

557
00:18:53,840 --> 00:18:58,480
be seen

558
00:18:54,880 --> 00:19:00,000
as a blind bls signatures so legitimate

559
00:18:58,480 --> 00:19:02,240
question is whether we can share

560
00:19:00,000 --> 00:19:03,520
the group element in g2 and then use it

561
00:19:02,240 --> 00:19:05,039
as a bls signature

562
00:19:03,520 --> 00:19:06,799
however there is a proof that needs to

563
00:19:05,039 --> 00:19:08,320
be given

564
00:19:06,799 --> 00:19:10,240
also in the case of a private metadata

565
00:19:08,320 --> 00:19:11,360
bit protocol we can think that we can

566
00:19:10,240 --> 00:19:13,760
transform it

567
00:19:11,360 --> 00:19:14,559
into a blind or kamoto schnorr signature

568
00:19:13,760 --> 00:19:16,160
however

569
00:19:14,559 --> 00:19:17,840
as we showed in a more recent paper

570
00:19:16,160 --> 00:19:20,799
together with the environmental help of

571
00:19:17,840 --> 00:19:22,720
fabius menamuda we show that

572
00:19:20,799 --> 00:19:25,840
blendokamoto schnorr signature shouldn't

573
00:19:22,720 --> 00:19:25,840
really be used in practice

574
00:19:26,160 --> 00:19:30,880
finally batching proofs whenever we we

575
00:19:28,400 --> 00:19:32,720
issue many tokens at once

576
00:19:30,880 --> 00:19:34,160
it's natural to ask whether we can batch

577
00:19:32,720 --> 00:19:35,280
the proofs for having more

578
00:19:34,160 --> 00:19:37,360
in order to have more efficient

579
00:19:35,280 --> 00:19:39,280
protocols and we

580
00:19:37,360 --> 00:19:41,199
we know that there are generic

581
00:19:39,280 --> 00:19:43,360
techniques for batching together

582
00:19:41,200 --> 00:19:45,600
sigma protocols but the problem comes

583
00:19:43,360 --> 00:19:47,520
when we issue tokens with a hidden beat

584
00:19:45,600 --> 00:19:49,520
with different bits inside

585
00:19:47,520 --> 00:19:51,679
this is a problem that can be isolated

586
00:19:49,520 --> 00:19:52,960
and treated separately

587
00:19:51,679 --> 00:19:55,039
and i'd like to close with a word of

588
00:19:52,960 --> 00:19:56,480
hope i i think

589
00:19:55,039 --> 00:19:58,720
it's about time that we start deploying

590
00:19:56,480 --> 00:19:59,679
anonymous credentials for handling

591
00:19:58,720 --> 00:20:01,200
finite resources

592
00:19:59,679 --> 00:20:03,679
and access control in as privacy

593
00:20:01,200 --> 00:20:04,400
respecting way i'd be very curious to

594
00:20:03,679 --> 00:20:06,480
see

595
00:20:04,400 --> 00:20:08,080
if people have their own use cases for

596
00:20:06,480 --> 00:20:09,840
them and invite you all to check the

597
00:20:08,080 --> 00:20:14,639
standardization documents and help out

598
00:20:09,840 --> 00:20:14,639
thank you

