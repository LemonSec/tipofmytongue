1
00:00:14,080 --> 00:00:20,000
hey we're live on youtube

2
00:00:16,400 --> 00:00:23,038
and we're recording um

3
00:00:20,000 --> 00:00:25,279
so we can start okay thank you

4
00:00:23,039 --> 00:00:26,720
welcome back everybody to the last

5
00:00:25,279 --> 00:00:28,840
session of the day

6
00:00:26,720 --> 00:00:30,000
uh the first session on post quantum

7
00:00:28,840 --> 00:00:32,000
cryptography

8
00:00:30,000 --> 00:00:33,840
we have four talks the first talk is

9
00:00:32,000 --> 00:00:34,719
practical product proofs for lattice

10
00:00:33,840 --> 00:00:37,840
commitments

11
00:00:34,719 --> 00:00:40,000
by thomas atema vadim lebashevsky

12
00:00:37,840 --> 00:00:43,280
and gregor seiler and gregor will give

13
00:00:40,000 --> 00:00:46,480
the talk gregor the floor is yours

14
00:00:43,280 --> 00:00:50,320
yes thank you very much so

15
00:00:46,480 --> 00:00:54,718
um to position our work so what this

16
00:00:50,320 --> 00:00:58,399
line of research is about is essentially

17
00:00:54,719 --> 00:01:00,719
fast linear-sized proof systems which

18
00:00:58,399 --> 00:01:01,920
nevertheless have proof sizes that are

19
00:01:00,719 --> 00:01:05,760
competitive

20
00:01:01,920 --> 00:01:08,240
with the recent pcp type systems

21
00:01:05,760 --> 00:01:10,000
in the case of small statements and

22
00:01:08,240 --> 00:01:11,439
especially in those statements

23
00:01:10,000 --> 00:01:13,280
that are encountered in leicester

24
00:01:11,439 --> 00:01:15,360
cryptography so

25
00:01:13,280 --> 00:01:16,720
to elaborate a bit on this so with the

26
00:01:15,360 --> 00:01:19,759
pcp type systems

27
00:01:16,720 --> 00:01:23,280
i mean these proof systems like liguero

28
00:01:19,759 --> 00:01:26,000
and aurora and they have sublinear

29
00:01:23,280 --> 00:01:26,479
proof sizes for example in terms of the

30
00:01:26,000 --> 00:01:29,600
circuit

31
00:01:26,479 --> 00:01:31,679
they're proving and

32
00:01:29,600 --> 00:01:33,839
so currently we don't know how to do

33
00:01:31,680 --> 00:01:35,040
this efficiently so this sub linearity

34
00:01:33,840 --> 00:01:37,520
with lattices

35
00:01:35,040 --> 00:01:38,840
but there is a range of interesting

36
00:01:37,520 --> 00:01:43,520
statements

37
00:01:38,840 --> 00:01:46,399
where linear proof systems can actually

38
00:01:43,520 --> 00:01:47,679
give comparable or even even smaller

39
00:01:46,399 --> 00:01:49,360
proof sizes

40
00:01:47,680 --> 00:01:50,720
um yeah as i said for for interesting

41
00:01:49,360 --> 00:01:53,280
statements and this is what we're

42
00:01:50,720 --> 00:01:55,439
interested in and then

43
00:01:53,280 --> 00:01:56,479
basically the lattice-based linear type

44
00:01:55,439 --> 00:01:58,639
systems um

45
00:01:56,479 --> 00:01:59,679
they also have very fast runtime which

46
00:01:58,640 --> 00:02:01,360
are then

47
00:01:59,680 --> 00:02:04,560
one or two orders of magnitude faster

48
00:02:01,360 --> 00:02:08,239
than the pcp type systems

49
00:02:04,560 --> 00:02:11,920
now this paper is concerned with a

50
00:02:08,239 --> 00:02:15,520
kind of uh one necessary ingredient for

51
00:02:11,920 --> 00:02:16,958
um uh arbitrary or for basically general

52
00:02:15,520 --> 00:02:18,800
product rule system or

53
00:02:16,959 --> 00:02:20,239
general proof systems and this

54
00:02:18,800 --> 00:02:23,360
ingredient is

55
00:02:20,239 --> 00:02:24,400
what we call a product proof in a

56
00:02:23,360 --> 00:02:27,280
product proof

57
00:02:24,400 --> 00:02:27,760
the goal is to be able to commit to

58
00:02:27,280 --> 00:02:30,239
secret

59
00:02:27,760 --> 00:02:31,599
vectors and then prove product relations

60
00:02:30,239 --> 00:02:34,480
between the coefficients

61
00:02:31,599 --> 00:02:35,518
of these vectors so for example like in

62
00:02:34,480 --> 00:02:39,040
the equation

63
00:02:35,519 --> 00:02:41,360
on this slide um so yeah so this is

64
00:02:39,040 --> 00:02:44,560
really what our paper is about

65
00:02:41,360 --> 00:02:45,440
and our main result is an improved

66
00:02:44,560 --> 00:02:47,360
product proof

67
00:02:45,440 --> 00:02:48,640
for a particular letters-based

68
00:02:47,360 --> 00:02:51,680
commitment scheme

69
00:02:48,640 --> 00:02:54,399
namely the bdlop commitment scheme

70
00:02:51,680 --> 00:02:55,519
and now to give some example for an

71
00:02:54,400 --> 00:02:58,239
application

72
00:02:55,519 --> 00:03:00,400
so if one or basically the simplest

73
00:02:58,239 --> 00:03:01,599
possible example where one only needs a

74
00:03:00,400 --> 00:03:04,080
product proof

75
00:03:01,599 --> 00:03:06,079
is a so-called range proof where the

76
00:03:04,080 --> 00:03:07,760
goal is to commit to some integer and

77
00:03:06,080 --> 00:03:09,040
then prove that the integer lies in a

78
00:03:07,760 --> 00:03:12,079
certain range

79
00:03:09,040 --> 00:03:14,879
now if the range has 1024 bit

80
00:03:12,080 --> 00:03:17,840
then our product proof achieves a proof

81
00:03:14,879 --> 00:03:21,120
size of 31 kilobytes

82
00:03:17,840 --> 00:03:23,440
so this is possible with several

83
00:03:21,120 --> 00:03:24,720
new techniques that we introduce and

84
00:03:23,440 --> 00:03:28,239
which are also

85
00:03:24,720 --> 00:03:28,959
useful for other protocols not just

86
00:03:28,239 --> 00:03:31,760
product

87
00:03:28,959 --> 00:03:32,799
proofs and in fact these techniques they

88
00:03:31,760 --> 00:03:34,399
already have been used

89
00:03:32,799 --> 00:03:36,159
in follow-up work and i'm going to say

90
00:03:34,400 --> 00:03:38,080
something in a minute about that

91
00:03:36,159 --> 00:03:39,200
um so the first technique we introduce

92
00:03:38,080 --> 00:03:42,400
is

93
00:03:39,200 --> 00:03:44,319
that unlike previous works about

94
00:03:42,400 --> 00:03:46,480
your knowledge proofs for the bdlp

95
00:03:44,319 --> 00:03:48,958
commitment scheme

96
00:03:46,480 --> 00:03:50,560
we show how to work with non-invertible

97
00:03:48,959 --> 00:03:51,440
challenge pairs so in previous works

98
00:03:50,560 --> 00:03:54,000
there was always

99
00:03:51,440 --> 00:03:55,920
some technical problem that the

100
00:03:54,000 --> 00:03:57,519
difference of two challenge polynomials

101
00:03:55,920 --> 00:03:59,599
needed to be invertible

102
00:03:57,519 --> 00:04:01,760
which effectively meant that one had to

103
00:03:59,599 --> 00:04:02,399
choose the polynomial ring in such a way

104
00:04:01,760 --> 00:04:06,239
that

105
00:04:02,400 --> 00:04:08,799
it didn't split into many small factors

106
00:04:06,239 --> 00:04:09,840
or alternatively restrict the challenge

107
00:04:08,799 --> 00:04:12,959
set

108
00:04:09,840 --> 00:04:15,920
due to very small size

109
00:04:12,959 --> 00:04:17,918
both of these basically possibilities

110
00:04:15,920 --> 00:04:19,680
resulted in in quite large proof sizes

111
00:04:17,918 --> 00:04:21,680
and now in our paper we show

112
00:04:19,680 --> 00:04:23,840
how to work with non-invertible

113
00:04:21,680 --> 00:04:27,280
challenges and basically get over this

114
00:04:23,840 --> 00:04:30,479
restriction and and smaller proof sizes

115
00:04:27,280 --> 00:04:33,520
and then as a second technique

116
00:04:30,479 --> 00:04:33,840
we give a new analysis of some variant

117
00:04:33,520 --> 00:04:35,758
of

118
00:04:33,840 --> 00:04:38,479
the opening proof of the bdlp commitment

119
00:04:35,759 --> 00:04:40,200
scheme which means for our product proof

120
00:04:38,479 --> 00:04:41,520
that we show how to

121
00:04:40,200 --> 00:04:44,560
[Music]

122
00:04:41,520 --> 00:04:46,880
basically get uh construct the

123
00:04:44,560 --> 00:04:49,040
the protocol such that it is not

124
00:04:46,880 --> 00:04:51,840
necessary to send some mask opening

125
00:04:49,040 --> 00:04:52,240
of of the secret vectors so i call this

126
00:04:51,840 --> 00:04:55,440
f

127
00:04:52,240 --> 00:04:57,440
here now um this also

128
00:04:55,440 --> 00:04:58,880
results in smaller proof sizes and then

129
00:04:57,440 --> 00:05:02,080
as a third technique

130
00:04:58,880 --> 00:05:05,360
we show how to boost soundness uh of uh

131
00:05:02,080 --> 00:05:07,599
basic protocols um with

132
00:05:05,360 --> 00:05:09,039
the help of offering automorphisms and

133
00:05:07,600 --> 00:05:11,830
technically this means

134
00:05:09,039 --> 00:05:13,120
that the verifier is able to compute

135
00:05:11,830 --> 00:05:15,840
[Music]

136
00:05:13,120 --> 00:05:16,720
mask openings of the secret vectors

137
00:05:15,840 --> 00:05:18,638
where the

138
00:05:16,720 --> 00:05:20,479
secret vectors are rotated by by certain

139
00:05:18,639 --> 00:05:24,880
automorphisms sigma

140
00:05:20,479 --> 00:05:27,520
and this then also cheats

141
00:05:24,880 --> 00:05:28,800
negligible soundless error without just

142
00:05:27,520 --> 00:05:30,400
repeating some

143
00:05:28,800 --> 00:05:31,919
simple protocols and in effect in a way

144
00:05:30,400 --> 00:05:34,560
which is better than just repeating some

145
00:05:31,919 --> 00:05:37,039
simple protocol

146
00:05:34,560 --> 00:05:40,320
now i said the techniques have also been

147
00:05:37,039 --> 00:05:42,240
used in other protocols i want to

148
00:05:40,320 --> 00:05:43,919
very quickly say what basically the

149
00:05:42,240 --> 00:05:47,280
outlook of all of this is and what

150
00:05:43,919 --> 00:05:49,198
the techniques can lead to so

151
00:05:47,280 --> 00:05:52,320
a natural example in lattice

152
00:05:49,199 --> 00:05:54,000
cryptography is being able to prove lwe

153
00:05:52,320 --> 00:05:55,360
samples the knowledge of the secret in

154
00:05:54,000 --> 00:05:56,880
some ld sample

155
00:05:55,360 --> 00:05:59,360
and with our technique and additional

156
00:05:56,880 --> 00:06:01,440
techniques so when we're now able

157
00:05:59,360 --> 00:06:02,880
to to do this with a proof size of less

158
00:06:01,440 --> 00:06:04,479
than 50 kilobytes

159
00:06:02,880 --> 00:06:06,240
and technically this means that one has

160
00:06:04,479 --> 00:06:09,440
to prove a ternary solution to

161
00:06:06,240 --> 00:06:10,800
some linear equation system with say

162
00:06:09,440 --> 00:06:13,440
2048

163
00:06:10,800 --> 00:06:15,039
variables and then for some example

164
00:06:13,440 --> 00:06:18,960
outside of lattice cryptographies

165
00:06:15,039 --> 00:06:21,280
which is also interesting um so in in

166
00:06:18,960 --> 00:06:22,479
in a so-called integer relation proof uh

167
00:06:21,280 --> 00:06:25,520
one wants to commit

168
00:06:22,479 --> 00:06:26,479
to several integers say three of them

169
00:06:25,520 --> 00:06:28,000
and prove

170
00:06:26,479 --> 00:06:29,919
that for example the product of the two

171
00:06:28,000 --> 00:06:32,960
first integers is is

172
00:06:29,919 --> 00:06:34,639
the third one and we know now note

173
00:06:32,960 --> 00:06:36,239
now how to do this with our techniques

174
00:06:34,639 --> 00:06:38,400
and some additional techniques

175
00:06:36,240 --> 00:06:41,440
um to prove in the case where the

176
00:06:38,400 --> 00:06:44,239
integers have 128 bits

177
00:06:41,440 --> 00:06:45,039
so we can do this now um with 40

178
00:06:44,240 --> 00:06:47,120
kilobytes

179
00:06:45,039 --> 00:06:48,479
and runtime that is only 2.4

180
00:06:47,120 --> 00:06:50,880
milliseconds and

181
00:06:48,479 --> 00:06:52,719
this is an example for how fast our true

182
00:06:50,880 --> 00:06:55,759
systems are

183
00:06:52,720 --> 00:06:57,919
um yeah with this

184
00:06:55,759 --> 00:06:59,759
and this is basically our what i want to

185
00:06:57,919 --> 00:07:00,799
save for the introduction of our paper

186
00:06:59,759 --> 00:07:04,160
and i'm open

187
00:07:00,800 --> 00:07:06,720
for questions thank you

188
00:07:04,160 --> 00:07:08,639
uh let's see are there any uh i don't

189
00:07:06,720 --> 00:07:12,000
see any questions yet on the chat

190
00:07:08,639 --> 00:07:12,000
uh are there any questions

191
00:07:13,360 --> 00:07:18,800
if anyone has technical problems in

192
00:07:15,759 --> 00:07:21,199
reaching the chat you can also

193
00:07:18,800 --> 00:07:23,280
push the i'm raising my hand button

194
00:07:21,199 --> 00:07:26,960
somewhere in

195
00:07:23,280 --> 00:07:29,119
in zoom or use the zoom chat so

196
00:07:26,960 --> 00:07:31,039
anything you can find technically you

197
00:07:29,120 --> 00:07:34,639
can use

198
00:07:31,039 --> 00:07:34,639
i'm trying to keep an eye on every

199
00:07:42,840 --> 00:07:45,840
possible

200
00:07:51,360 --> 00:07:55,919
so uh one question uh gregor about the

201
00:07:54,319 --> 00:07:58,960
techniques if you could go back

202
00:07:55,919 --> 00:08:02,639
a couple of slides

203
00:07:58,960 --> 00:08:06,080
thank you so if i understand correctly

204
00:08:02,639 --> 00:08:06,960
um you avoid the need for having to have

205
00:08:06,080 --> 00:08:09,599
an invertible

206
00:08:06,960 --> 00:08:12,239
uh pair of challenges invertible

207
00:08:09,599 --> 00:08:14,080
difference a pair of challenges

208
00:08:12,240 --> 00:08:15,840
this allows you to use fully splitting

209
00:08:14,080 --> 00:08:18,318
rings do the techniques

210
00:08:15,840 --> 00:08:19,119
also work even if the ring is not fully

211
00:08:18,319 --> 00:08:20,800
splitting

212
00:08:19,120 --> 00:08:23,199
or do you need some other algebraic

213
00:08:20,800 --> 00:08:25,520
condition in order to make this

214
00:08:23,199 --> 00:08:26,879
non-invertible difference a technique

215
00:08:25,520 --> 00:08:30,240
work

216
00:08:26,879 --> 00:08:31,759
yes so this technique also works in

217
00:08:30,240 --> 00:08:33,360
the case where the ring doesn't split

218
00:08:31,759 --> 00:08:36,640
fully so in essentially what

219
00:08:33,360 --> 00:08:38,800
we need technically is that we can bound

220
00:08:36,640 --> 00:08:40,559
the probability that a challenge pair

221
00:08:38,799 --> 00:08:41,838
is non-zero or the difference of two

222
00:08:40,559 --> 00:08:44,159
challenges is non-zero

223
00:08:41,839 --> 00:08:46,080
in the in the entity coefficients and

224
00:08:44,159 --> 00:08:48,399
for this it's actually enough

225
00:08:46,080 --> 00:08:50,560
that we can bound this probability for

226
00:08:48,399 --> 00:08:54,000
for each

227
00:08:50,560 --> 00:08:55,839
entity coefficient individually so um

228
00:08:54,000 --> 00:08:57,279
that in the end we don't need the

229
00:08:55,839 --> 00:08:59,600
probability that that

230
00:08:57,279 --> 00:09:00,480
the challenge is non-zero everywhere or

231
00:08:59,600 --> 00:09:02,080
invertible so

232
00:09:00,480 --> 00:09:04,399
it's enough that we have the probability

233
00:09:02,080 --> 00:09:06,480
for uh one

234
00:09:04,399 --> 00:09:07,519
uh basically one entity coefficient at a

235
00:09:06,480 --> 00:09:10,320
time

236
00:09:07,519 --> 00:09:11,600
and yeah in this way we can also use

237
00:09:10,320 --> 00:09:13,839
this in the case where it doesn't it

238
00:09:11,600 --> 00:09:17,839
doesn't split fully and

239
00:09:13,839 --> 00:09:19,600
yeah all right thank you yeah

240
00:09:17,839 --> 00:09:22,320
all right i think we'll uh if there are

241
00:09:19,600 --> 00:09:24,720
no other questions

242
00:09:22,320 --> 00:09:27,279
then we'll move to the second talk of

243
00:09:24,720 --> 00:09:27,279
the session

244
00:09:27,680 --> 00:09:40,319
so eduard

245
00:09:37,040 --> 00:09:43,279
very good so the second talk is lattice

246
00:09:40,320 --> 00:09:43,600
lattice-based blind signatures revisited

247
00:09:43,279 --> 00:09:47,040
uh

248
00:09:43,600 --> 00:09:50,480
by eduard hulk ike kiltz

249
00:09:47,040 --> 00:09:54,000
julian loss and con you win

250
00:09:50,480 --> 00:09:54,000
and eduard will give the talk

251
00:09:55,600 --> 00:09:59,680
thanks for the intro hi everyone a blind

252
00:09:58,720 --> 00:10:01,440
signature scheme

253
00:09:59,680 --> 00:10:02,880
is an interactive protocol between two

254
00:10:01,440 --> 00:10:05,760
parties a signer

255
00:10:02,880 --> 00:10:06,720
and the user the signer takes us input a

256
00:10:05,760 --> 00:10:08,720
secret key

257
00:10:06,720 --> 00:10:11,440
the user the public key as well as the

258
00:10:08,720 --> 00:10:12,959
message m where skpk is output by the

259
00:10:11,440 --> 00:10:15,680
keygen function

260
00:10:12,959 --> 00:10:17,359
in this work we restrict ourselves to

261
00:10:15,680 --> 00:10:19,279
three move interactions

262
00:10:17,360 --> 00:10:21,200
where at the end of the interaction the

263
00:10:19,279 --> 00:10:23,360
user learns a signature sigma

264
00:10:21,200 --> 00:10:26,079
on a message of its own choice and the

265
00:10:23,360 --> 00:10:28,240
signer does not learn anything

266
00:10:26,079 --> 00:10:29,519
further you define a public verify

267
00:10:28,240 --> 00:10:31,760
algorithm v

268
00:10:29,519 --> 00:10:33,200
which will either output accept or

269
00:10:31,760 --> 00:10:35,680
reject

270
00:10:33,200 --> 00:10:36,880
we consider two security notions one

271
00:10:35,680 --> 00:10:40,000
more enforceability

272
00:10:36,880 --> 00:10:40,959
and blindness in the blindness security

273
00:10:40,000 --> 00:10:42,800
experiment

274
00:10:40,959 --> 00:10:44,640
the adversary takes the role of a

275
00:10:42,800 --> 00:10:46,719
malicious signer

276
00:10:44,640 --> 00:10:48,640
intuitively the adversary should be

277
00:10:46,720 --> 00:10:50,160
blind to which message was used in a

278
00:10:48,640 --> 00:10:53,199
specific interaction

279
00:10:50,160 --> 00:10:55,040
as well as the produced signature

280
00:10:53,200 --> 00:10:57,279
in the one more informability security

281
00:10:55,040 --> 00:10:59,760
experiment the adversary takes the role

282
00:10:57,279 --> 00:11:01,519
of a malicious user

283
00:10:59,760 --> 00:11:03,920
every interaction with the experiment

284
00:11:01,519 --> 00:11:06,000
the adversary learns a signature

285
00:11:03,920 --> 00:11:07,120
intuitively it should be hard for the

286
00:11:06,000 --> 00:11:11,040
adversary to come

287
00:11:07,120 --> 00:11:11,040
up with a one more forgery

288
00:11:11,440 --> 00:11:14,720
linear three move plan signature schemes

289
00:11:13,760 --> 00:11:16,399
are susceptible

290
00:11:14,720 --> 00:11:17,760
to the so-called ross attack against the

291
00:11:16,399 --> 00:11:19,519
omo security

292
00:11:17,760 --> 00:11:21,600
the ros stands for random and

293
00:11:19,519 --> 00:11:24,240
homogeneities in an overdetermined

294
00:11:21,600 --> 00:11:25,839
soluble system of linear equations

295
00:11:24,240 --> 00:11:27,440
the ros attacker takes the role of a

296
00:11:25,839 --> 00:11:30,160
malicious user

297
00:11:27,440 --> 00:11:30,720
and it does the following first it

298
00:11:30,160 --> 00:11:34,160
starts

299
00:11:30,720 --> 00:11:37,440
l parallel sessions with the signer then

300
00:11:34,160 --> 00:11:39,600
with these l values r1 to rl it computes

301
00:11:37,440 --> 00:11:41,839
the solution to a ros problem

302
00:11:39,600 --> 00:11:44,079
the first part of the solution will be a

303
00:11:41,839 --> 00:11:46,399
vector of challenge value c1 to cl

304
00:11:44,079 --> 00:11:48,000
which it will send over the channel thus

305
00:11:46,399 --> 00:11:52,880
receiving l responses

306
00:11:48,000 --> 00:11:54,560
s1 to sl from these l responses s1 to sl

307
00:11:52,880 --> 00:11:56,399
in conjunction with the second part of

308
00:11:54,560 --> 00:11:59,279
the solution to the roth problem

309
00:11:56,399 --> 00:11:59,760
it verse 3 computes l plus 1 signatures

310
00:11:59,279 --> 00:12:02,800
thus

311
00:11:59,760 --> 00:12:03,279
breaking the ohm of security the bigger

312
00:12:02,800 --> 00:12:05,279
l

313
00:12:03,279 --> 00:12:07,519
the easier the draws problem as the

314
00:12:05,279 --> 00:12:10,000
adversary learns more information

315
00:12:07,519 --> 00:12:11,360
for small enough l it can be shown that

316
00:12:10,000 --> 00:12:13,279
the ros problem is information

317
00:12:11,360 --> 00:12:15,200
theoretically hard

318
00:12:13,279 --> 00:12:17,279
in a work which recently appeared on

319
00:12:15,200 --> 00:12:20,160
eprint by ben hamuda le paw

320
00:12:17,279 --> 00:12:21,120
or andrejkova they show if l gets large

321
00:12:20,160 --> 00:12:22,719
enough

322
00:12:21,120 --> 00:12:24,480
then the ross attacker runs in

323
00:12:22,720 --> 00:12:26,320
polynomial time

324
00:12:24,480 --> 00:12:28,959
in the latter setting the concrete

325
00:12:26,320 --> 00:12:31,200
hardness of the ros program is unknown

326
00:12:28,959 --> 00:12:33,359
in the non-letter setting ponjval and

327
00:12:31,200 --> 00:12:35,279
stern deal with it as follows

328
00:12:33,360 --> 00:12:37,360
in the seminal work which appeared in

329
00:12:35,279 --> 00:12:39,200
journal of cryptology 2000

330
00:12:37,360 --> 00:12:41,279
they give the first proof of the okamoto

331
00:12:39,200 --> 00:12:44,880
snowblind signature scheme

332
00:12:41,279 --> 00:12:46,480
their own proof limits the range of l

333
00:12:44,880 --> 00:12:48,880
such that the roth problem stays

334
00:12:46,480 --> 00:12:52,079
information theoretically hard

335
00:12:48,880 --> 00:12:53,279
while virtually all letter-spaced blind

336
00:12:52,079 --> 00:12:54,959
signature schemes

337
00:12:53,279 --> 00:12:57,120
reuse the proof techniques by punchval

338
00:12:54,959 --> 00:12:58,239
and stern most of them omit the part

339
00:12:57,120 --> 00:13:00,720
limiting the range of

340
00:12:58,240 --> 00:13:02,720
l thus making their own security

341
00:13:00,720 --> 00:13:04,639
statement uncertain

342
00:13:02,720 --> 00:13:06,240
in this work we point out flaws in

343
00:13:04,639 --> 00:13:10,240
exactly these works

344
00:13:06,240 --> 00:13:13,279
specifically hooker asia group 2000

345
00:13:10,240 --> 00:13:14,800
blaze by alcatraz

346
00:13:13,279 --> 00:13:17,600
which appeared in this year's financial

347
00:13:14,800 --> 00:13:19,839
crypto and others

348
00:13:17,600 --> 00:13:21,760
there we show that an unsound

349
00:13:19,839 --> 00:13:22,399
application of the bilar named working

350
00:13:21,760 --> 00:13:24,800
lemma

351
00:13:22,399 --> 00:13:25,839
leads to a gap in the um of proof

352
00:13:24,800 --> 00:13:28,880
specifically

353
00:13:25,839 --> 00:13:32,480
an argument on the outputs of the forked

354
00:13:28,880 --> 00:13:33,600
algorithm is missing in our second

355
00:13:32,480 --> 00:13:35,760
contribution

356
00:13:33,600 --> 00:13:37,680
we give a framework for blind signatures

357
00:13:35,760 --> 00:13:40,639
from latest assumptions

358
00:13:37,680 --> 00:13:42,160
we generalize the framework of hkl19

359
00:13:40,639 --> 00:13:45,279
from the error-free setting

360
00:13:42,160 --> 00:13:47,279
to the setting of correctness errors

361
00:13:45,279 --> 00:13:48,560
our framework consists of the following

362
00:13:47,279 --> 00:13:50,560
two steps

363
00:13:48,560 --> 00:13:52,880
we start with a linear hash function

364
00:13:50,560 --> 00:13:54,800
with noticeable in closeness arrow

365
00:13:52,880 --> 00:13:57,279
and closeness error is a notion closely

366
00:13:54,800 --> 00:13:58,880
related to the one of correctness arrow

367
00:13:57,279 --> 00:14:00,399
from that you get a linear

368
00:13:58,880 --> 00:14:03,040
identification scheme

369
00:14:00,399 --> 00:14:03,760
with negligible correctness error and

370
00:14:03,040 --> 00:14:06,000
from that

371
00:14:03,760 --> 00:14:09,120
a linear band signature scheme also with

372
00:14:06,000 --> 00:14:11,760
negligible correctness error

373
00:14:09,120 --> 00:14:14,560
our instantiation uses the linear hash

374
00:14:11,760 --> 00:14:16,560
function of lubashevsky in michiancho

375
00:14:14,560 --> 00:14:18,880
where the underlying assumption is that

376
00:14:16,560 --> 00:14:21,760
the rsif problem is hard

377
00:14:18,880 --> 00:14:24,160
the prime we use is quite large so our

378
00:14:21,760 --> 00:14:26,079
signatures are 36 megabytes large

379
00:14:24,160 --> 00:14:29,120
and assigning speed is probably quite

380
00:14:26,079 --> 00:14:32,079
slow due to the size of the prime

381
00:14:29,120 --> 00:14:33,760
further the maximum number of poly

382
00:14:32,079 --> 00:14:35,519
maximum number of signatures

383
00:14:33,760 --> 00:14:37,279
is poly logarithmic in the security

384
00:14:35,519 --> 00:14:39,519
parameter as

385
00:14:37,279 --> 00:14:40,639
our own security bound degrades

386
00:14:39,519 --> 00:14:43,279
exponentially

387
00:14:40,639 --> 00:14:44,079
in the number of issued signatures only

388
00:14:43,279 --> 00:14:46,000
in this range

389
00:14:44,079 --> 00:14:47,920
the roth problem is information

390
00:14:46,000 --> 00:14:51,040
theoretically hard

391
00:14:47,920 --> 00:14:53,279
so all in all our instantiation is not

392
00:14:51,040 --> 00:14:56,639
the practical

393
00:14:53,279 --> 00:14:57,920
to conclude we show how to construct a

394
00:14:56,639 --> 00:14:58,639
framework for lettuce-based plant

395
00:14:57,920 --> 00:15:01,360
signatures

396
00:14:58,639 --> 00:15:03,279
with negligible correctness error sound

397
00:15:01,360 --> 00:15:06,320
almost in blindness proofs

398
00:15:03,279 --> 00:15:09,040
yet the instantiation is improvable

399
00:15:06,320 --> 00:15:10,880
so as open problems we see to find a

400
00:15:09,040 --> 00:15:13,199
more efficient instantiation

401
00:15:10,880 --> 00:15:16,399
as well as analysis on the hardness of

402
00:15:13,199 --> 00:15:20,880
the generalized ros problem

403
00:15:16,399 --> 00:15:24,720
thanks thank you

404
00:15:20,880 --> 00:15:25,519
thank you so we are open for questions

405
00:15:24,720 --> 00:15:28,800
now again

406
00:15:25,519 --> 00:15:31,519
in the in any of the chats or write your

407
00:15:28,800 --> 00:15:31,519
virtual hand

408
00:15:35,680 --> 00:15:41,758
i actually have one question

409
00:15:38,959 --> 00:15:42,560
because you you mentioned the that you

410
00:15:41,759 --> 00:15:45,680
discovered an

411
00:15:42,560 --> 00:15:48,638
unsoundness in prior work um

412
00:15:45,680 --> 00:15:49,758
does this mean that you find a flaw in

413
00:15:48,639 --> 00:15:51,600
the proof but

414
00:15:49,759 --> 00:15:52,880
this key might be secure or do you

415
00:15:51,600 --> 00:15:55,120
actually

416
00:15:52,880 --> 00:15:56,959
if these are the existing schemes

417
00:15:55,120 --> 00:15:59,759
actually insecure

418
00:15:56,959 --> 00:16:03,599
we do not give concrete attacks but we

419
00:15:59,759 --> 00:16:03,600
only find a flaw in the room of proof

420
00:16:04,320 --> 00:16:08,480
but do you think it's kind of i mean

421
00:16:06,560 --> 00:16:11,119
does it feel like

422
00:16:08,480 --> 00:16:12,880
like something which which threatens the

423
00:16:11,120 --> 00:16:14,000
the schemes actually or does it feel

424
00:16:12,880 --> 00:16:16,639
like

425
00:16:14,000 --> 00:16:17,519
we just have no clue how to prove it

426
00:16:16,639 --> 00:16:19,759
this depends

427
00:16:17,519 --> 00:16:21,839
on the analysis of the generalized ros

428
00:16:19,759 --> 00:16:23,600
problem for our case we can give a

429
00:16:21,839 --> 00:16:25,040
reduction that if the roth problem is

430
00:16:23,600 --> 00:16:28,160
easy then

431
00:16:25,040 --> 00:16:28,719
our scheme is not almost secure and we

432
00:16:28,160 --> 00:16:31,759
think

433
00:16:28,720 --> 00:16:33,440
it might be easily generalizable to the

434
00:16:31,759 --> 00:16:34,160
other schemes or applicable to the other

435
00:16:33,440 --> 00:16:36,959
schemes

436
00:16:34,160 --> 00:16:38,240
but we do not know how hard it is in

437
00:16:36,959 --> 00:16:51,839
fact

438
00:16:38,240 --> 00:16:51,839
so we do not know okay

439
00:17:05,280 --> 00:17:08,959
so we do not seem to have any other

440
00:17:07,679 --> 00:17:11,760
questions at the moment

441
00:17:08,959 --> 00:17:14,000
so probably we can go to the next talk

442
00:17:11,760 --> 00:17:14,000
then

443
00:17:14,480 --> 00:17:19,839
yes let's have the next speaker uh bring

444
00:17:16,559 --> 00:17:19,839
up the slides

445
00:17:23,679 --> 00:17:29,200
thank you all right

446
00:17:26,720 --> 00:17:30,000
the next talk is lwe with side

447
00:17:29,200 --> 00:17:33,520
information

448
00:17:30,000 --> 00:17:36,720
attacks and concrete security estimation

449
00:17:33,520 --> 00:17:38,000
it's authored by adana dachman salad leo

450
00:17:36,720 --> 00:17:41,280
duca

451
00:17:38,000 --> 00:17:44,840
jin gong and melissa rossi and

452
00:17:41,280 --> 00:17:46,240
huijin will be giving the talk take it

453
00:17:44,840 --> 00:17:48,240
away

454
00:17:46,240 --> 00:17:49,600
so in short our work is to integrate

455
00:17:48,240 --> 00:17:51,919
some leaked information

456
00:17:49,600 --> 00:17:53,199
of the lwe secrets into the lattice

457
00:17:51,919 --> 00:17:55,360
reduction attack

458
00:17:53,200 --> 00:17:56,400
this work has a theoretical part which

459
00:17:55,360 --> 00:17:58,399
is to build a new

460
00:17:56,400 --> 00:18:00,080
framework for integrating the leaked

461
00:17:58,400 --> 00:18:01,120
secret information into the lattice

462
00:18:00,080 --> 00:18:03,039
reduction

463
00:18:01,120 --> 00:18:04,479
it can have many applications in crip

464
00:18:03,039 --> 00:18:06,720
analysis

465
00:18:04,480 --> 00:18:08,000
we include three applications uh as

466
00:18:06,720 --> 00:18:11,200
examples

467
00:18:08,000 --> 00:18:11,200
so for motivations

468
00:18:11,360 --> 00:18:14,719
let me see how to okay so for

469
00:18:13,679 --> 00:18:18,160
motivations

470
00:18:14,720 --> 00:18:19,200
uh given an lw scheme to estimate in

471
00:18:18,160 --> 00:18:22,000
security

472
00:18:19,200 --> 00:18:24,559
one standard way is to estimate the cost

473
00:18:22,000 --> 00:18:27,120
of primo lattice reduction attack

474
00:18:24,559 --> 00:18:28,960
um under the parameter under the

475
00:18:27,120 --> 00:18:31,280
perimeter set of the scheme

476
00:18:28,960 --> 00:18:32,880
the cost is represented by the block

477
00:18:31,280 --> 00:18:36,080
size of the bqc algorithm

478
00:18:32,880 --> 00:18:38,480
and which we call it beta many cost

479
00:18:36,080 --> 00:18:39,760
models can convert this data into the

480
00:18:38,480 --> 00:18:42,080
base security

481
00:18:39,760 --> 00:18:42,879
uh for example like usually uh three to

482
00:18:42,080 --> 00:18:45,520
four uh

483
00:18:42,880 --> 00:18:46,400
beta can convert to one bit security at

484
00:18:45,520 --> 00:18:49,039
the end

485
00:18:46,400 --> 00:18:51,120
uh we get the uh bit info bit security

486
00:18:49,039 --> 00:18:51,760
that represents the estimated amount of

487
00:18:51,120 --> 00:18:54,879
work

488
00:18:51,760 --> 00:18:57,600
for key recovery

489
00:18:54,880 --> 00:18:59,360
um from the cell channel aspect the

490
00:18:57,600 --> 00:19:00,320
sectional measurement can give extra

491
00:18:59,360 --> 00:19:03,360
information

492
00:19:00,320 --> 00:19:05,439
for example a text attack with

493
00:19:03,360 --> 00:19:06,799
enough good measurement might be able to

494
00:19:05,440 --> 00:19:09,280
recover the key

495
00:19:06,799 --> 00:19:11,120
for the previous work of said channel

496
00:19:09,280 --> 00:19:13,200
attack on lw scheme

497
00:19:11,120 --> 00:19:14,239
uh like most of them are using like ad

498
00:19:13,200 --> 00:19:16,080
hoc methods

499
00:19:14,240 --> 00:19:17,760
and need substantial amount of

500
00:19:16,080 --> 00:19:20,960
information leakage

501
00:19:17,760 --> 00:19:23,280
so we are wondering what uh sorry

502
00:19:20,960 --> 00:19:24,160
what if we get some information set

503
00:19:23,280 --> 00:19:26,960
information

504
00:19:24,160 --> 00:19:28,400
and it's not enough for the key recovery

505
00:19:26,960 --> 00:19:29,840
can we actually use the lattice

506
00:19:28,400 --> 00:19:32,480
reduction attack

507
00:19:29,840 --> 00:19:34,000
and and take this um this that

508
00:19:32,480 --> 00:19:36,400
information from the measurement

509
00:19:34,000 --> 00:19:38,240
into account hopefully we can get we can

510
00:19:36,400 --> 00:19:40,640
see how much better security

511
00:19:38,240 --> 00:19:42,400
gets dropped from using this um setting

512
00:19:40,640 --> 00:19:46,320
information

513
00:19:42,400 --> 00:19:49,200
okay so so for our contribution

514
00:19:46,320 --> 00:19:50,080
uh we actually propose um framework to

515
00:19:49,200 --> 00:19:52,480
integrate

516
00:19:50,080 --> 00:19:53,918
certain type of set information which we

517
00:19:52,480 --> 00:19:56,320
call it as a hint

518
00:19:53,919 --> 00:19:56,960
and we implemented our framework on

519
00:19:56,320 --> 00:20:00,320
stage

520
00:19:56,960 --> 00:20:02,960
on the on which is like over the python

521
00:20:00,320 --> 00:20:04,480
um our framework also be able to predict

522
00:20:02,960 --> 00:20:06,640
the security drop

523
00:20:04,480 --> 00:20:10,080
and we are able to validate the

524
00:20:06,640 --> 00:20:10,080
prediction experimentally

525
00:20:10,159 --> 00:20:14,799
as the application part of our work we

526
00:20:13,200 --> 00:20:16,400
give the three examples

527
00:20:14,799 --> 00:20:19,280
for the third example for the first

528
00:20:16,400 --> 00:20:20,640
examples uh we use the measured data

529
00:20:19,280 --> 00:20:23,840
from the first attack of

530
00:20:20,640 --> 00:20:26,880
both settables work note that their work

531
00:20:23,840 --> 00:20:27,760
uh their work has two attacks the second

532
00:20:26,880 --> 00:20:30,559
attack is

533
00:20:27,760 --> 00:20:32,400
successful and the first attack cannot

534
00:20:30,559 --> 00:20:33,360
recover the key under the reasonable

535
00:20:32,400 --> 00:20:36,159
amount of

536
00:20:33,360 --> 00:20:36,799
cost so we take that this the first

537
00:20:36,159 --> 00:20:40,000
attack

538
00:20:36,799 --> 00:20:40,879
as a good example for our framework um

539
00:20:40,000 --> 00:20:43,120
so it turns out

540
00:20:40,880 --> 00:20:46,159
that that our framework allows to

541
00:20:43,120 --> 00:20:48,559
heavily decrease the block size

542
00:20:46,159 --> 00:20:50,400
for the second example we extract the

543
00:20:48,559 --> 00:20:53,120
hint for the event

544
00:20:50,400 --> 00:20:55,200
when the decryption failure occurs our

545
00:20:53,120 --> 00:20:57,360
framework is able to reproduce the work

546
00:20:55,200 --> 00:21:00,159
of damage at all

547
00:20:57,360 --> 00:21:00,799
the third one um we actually extract the

548
00:21:00,159 --> 00:21:03,200
hint

549
00:21:00,799 --> 00:21:04,000
from the scheme specifications for

550
00:21:03,200 --> 00:21:06,400
example

551
00:21:04,000 --> 00:21:08,080
some schemes uh have sacred generated

552
00:21:06,400 --> 00:21:10,960
from the ternary distribution

553
00:21:08,080 --> 00:21:11,678
with pre-scripted number of plus one or

554
00:21:10,960 --> 00:21:14,880
negative and

555
00:21:11,679 --> 00:21:17,440
nicotine one and we the block

556
00:21:14,880 --> 00:21:18,159
the block size decreased from such hints

557
00:21:17,440 --> 00:21:21,760
is actually

558
00:21:18,159 --> 00:21:23,120
very small um so now you might be

559
00:21:21,760 --> 00:21:25,679
curious about

560
00:21:23,120 --> 00:21:26,559
like what type of the set information

561
00:21:25,679 --> 00:21:30,080
are included

562
00:21:26,559 --> 00:21:30,879
in our framework so the first three type

563
00:21:30,080 --> 00:21:33,120
of

564
00:21:30,880 --> 00:21:34,480
hints are about the linear relation of

565
00:21:33,120 --> 00:21:37,840
the secret vector

566
00:21:34,480 --> 00:21:40,880
that is given a vector v attacker

567
00:21:37,840 --> 00:21:44,158
may know the inner product of the secret

568
00:21:40,880 --> 00:21:45,039
s and v or the inner product modular

569
00:21:44,159 --> 00:21:48,320
integer

570
00:21:45,039 --> 00:21:50,480
or the inner product after some errors

571
00:21:48,320 --> 00:21:51,840
the first the fourth of the hint is a

572
00:21:50,480 --> 00:21:54,080
bit uh different

573
00:21:51,840 --> 00:21:55,840
it does not have the really like

574
00:21:54,080 --> 00:21:58,799
information on the secret but some other

575
00:21:55,840 --> 00:22:01,360
information about the letters

576
00:21:58,799 --> 00:22:02,960
so our technology techniques for

577
00:22:01,360 --> 00:22:06,240
integrating the hints

578
00:22:02,960 --> 00:22:07,120
including includes the specifying the

579
00:22:06,240 --> 00:22:10,159
letters

580
00:22:07,120 --> 00:22:10,879
intersecting or projecting on the header

581
00:22:10,159 --> 00:22:12,960
plans

582
00:22:10,880 --> 00:22:14,080
or altering the distribution of the

583
00:22:12,960 --> 00:22:16,559
sacred vector

584
00:22:14,080 --> 00:22:18,480
so this part is the heart of our work we

585
00:22:16,559 --> 00:22:19,440
actually have very nice animation drawn

586
00:22:18,480 --> 00:22:21,360
by melissa

587
00:22:19,440 --> 00:22:23,760
in our full talk to illustrate the

588
00:22:21,360 --> 00:22:26,399
geometric intuition

589
00:22:23,760 --> 00:22:29,919
yeah okay so thank you so much i'm happy

590
00:22:26,400 --> 00:22:29,919
to take any question you might have

591
00:22:31,120 --> 00:22:40,479
thank you very much so any questions

592
00:22:34,320 --> 00:22:44,080
from the audience

593
00:22:40,480 --> 00:22:47,200
um this is maybe a basic question but um

594
00:22:44,080 --> 00:22:49,918
uh would a uh

595
00:22:47,200 --> 00:22:51,520
learning a little bit of the noise uh in

596
00:22:49,919 --> 00:22:54,799
the lwe distribution

597
00:22:51,520 --> 00:22:58,240
uh fit into this framework of

598
00:22:54,799 --> 00:22:58,960
hinting uh what do you mean learning a

599
00:22:58,240 --> 00:23:01,280
little bit

600
00:22:58,960 --> 00:23:04,320
noise so you mean the error is sampled

601
00:23:01,280 --> 00:23:07,360
with smaller distributions

602
00:23:04,320 --> 00:23:12,000
uh yeah yeah for example um

603
00:23:07,360 --> 00:23:14,320
so in that one we uh i think

604
00:23:12,000 --> 00:23:15,760
um let me see i think yes because in

605
00:23:14,320 --> 00:23:17,439
that case the error

606
00:23:15,760 --> 00:23:19,200
uh we kind of have extra information

607
00:23:17,440 --> 00:23:21,200
about the error which the arrow has a

608
00:23:19,200 --> 00:23:24,240
smaller scientist than

609
00:23:21,200 --> 00:23:26,480
than than the standard lw assumptions

610
00:23:24,240 --> 00:23:26,480
right

611
00:23:27,280 --> 00:23:31,280
yeah so in that case we can uh have the

612
00:23:29,600 --> 00:23:33,678
hint for example

613
00:23:31,280 --> 00:23:35,039
like the approximate hint the s will be

614
00:23:33,679 --> 00:23:39,200
the arrow here

615
00:23:35,039 --> 00:23:41,520
um and a b will just be a um

616
00:23:39,200 --> 00:23:42,240
like identity matrix and it's it will

617
00:23:41,520 --> 00:23:45,279
follow some

618
00:23:42,240 --> 00:23:45,840
distributions yeah i think that will

619
00:23:45,279 --> 00:23:47,840
work

620
00:23:45,840 --> 00:23:49,520
i see so s doesn't have to be the secret

621
00:23:47,840 --> 00:23:50,799
in the distribution per se yeah sorry

622
00:23:49,520 --> 00:23:53,760
for the confusion that this

623
00:23:50,799 --> 00:23:55,360
s it's actually the uh the the including

624
00:23:53,760 --> 00:23:57,520
the secret vector and the concatenate

625
00:23:55,360 --> 00:24:00,879
base with the arrow vectors

626
00:23:57,520 --> 00:24:02,720
um so that is actually the short vector

627
00:24:00,880 --> 00:24:07,919
embedded from the canal embedding

628
00:24:02,720 --> 00:24:07,919
onto the lattice usb problem

629
00:24:08,080 --> 00:24:12,240
thank you no problem

630
00:24:15,919 --> 00:24:19,840
any other questions

631
00:24:24,480 --> 00:24:30,640
yeah so there's one question in the chat

632
00:24:27,520 --> 00:24:32,720
from the media tv

633
00:24:30,640 --> 00:24:33,679
is the attack expected to be more

634
00:24:32,720 --> 00:24:36,480
efficient

635
00:24:33,679 --> 00:24:38,480
maybe in terms of required leakage than

636
00:24:36,480 --> 00:24:42,799
purely statistical attacks

637
00:24:38,480 --> 00:24:42,799
that exploit the same type of relations

638
00:24:44,880 --> 00:24:48,240
sorry i'm not familiar with the

639
00:24:46,240 --> 00:24:52,000
statistical attack means

640
00:24:48,240 --> 00:24:54,480
um could you elaborate on that so maybe

641
00:24:52,000 --> 00:24:56,559
if you uh have audio you could can also

642
00:24:54,480 --> 00:25:01,840
unmute yourself and

643
00:24:56,559 --> 00:25:01,840
respond to huixing

644
00:25:10,559 --> 00:25:14,080
it's possible that medi when he says

645
00:25:12,799 --> 00:25:18,158
purely statistical

646
00:25:14,080 --> 00:25:21,439
attacks may be referring to

647
00:25:18,159 --> 00:25:26,559
uh yeah like things like the aurora

648
00:25:21,440 --> 00:25:29,120
attack or that use linearization

649
00:25:26,559 --> 00:25:31,279
as he said using linear regressions

650
00:25:29,120 --> 00:25:33,918
things like that

651
00:25:31,279 --> 00:25:36,080
i see um actually i'm not sure because

652
00:25:33,919 --> 00:25:43,840
we don't really compare with other

653
00:25:36,080 --> 00:25:43,840
attack like yeah experimentally

654
00:25:45,440 --> 00:25:50,480
uh the media edit media said

655
00:25:48,799 --> 00:25:52,799
thanks so probably that answers the

656
00:25:50,480 --> 00:25:52,799
question

657
00:26:00,640 --> 00:26:05,120
one more question uh in terms of the

658
00:26:04,080 --> 00:26:07,918
four

659
00:26:05,120 --> 00:26:09,760
categories of uh hints that you're able

660
00:26:07,919 --> 00:26:13,919
to

661
00:26:09,760 --> 00:26:17,919
exploit there are a couple of other

662
00:26:13,919 --> 00:26:22,039
things that or variants of lwe

663
00:26:17,919 --> 00:26:25,120
where for example the error is generated

664
00:26:22,039 --> 00:26:28,240
deterministically by rounding

665
00:26:25,120 --> 00:26:31,360
or where you have some

666
00:26:28,240 --> 00:26:32,400
combination of maybe a binary secret and

667
00:26:31,360 --> 00:26:37,039
then

668
00:26:32,400 --> 00:26:38,880
wider so-called error terms

669
00:26:37,039 --> 00:26:41,279
do these fit in or do you think there's

670
00:26:38,880 --> 00:26:43,760
any chance that these could fit into

671
00:26:41,279 --> 00:26:45,279
the framework that uh that you describe

672
00:26:43,760 --> 00:26:46,400
in this work or would it require some

673
00:26:45,279 --> 00:26:49,520
additional

674
00:26:46,400 --> 00:26:52,080
uh techniques and insights uh

675
00:26:49,520 --> 00:26:53,679
so so our like uh there is a

676
00:26:52,080 --> 00:26:54,720
straightforward way to fit in our

677
00:26:53,679 --> 00:26:57,279
framework by

678
00:26:54,720 --> 00:26:58,000
for example for the uh for the lwr

679
00:26:57,279 --> 00:27:01,120
things

680
00:26:58,000 --> 00:27:01,440
we can extract the covariance and also

681
00:27:01,120 --> 00:27:03,120
the

682
00:27:01,440 --> 00:27:04,720
mean from the distribution of the arrow

683
00:27:03,120 --> 00:27:07,199
we can just explicitly

684
00:27:04,720 --> 00:27:08,480
sample all the es and let's see what is

685
00:27:07,200 --> 00:27:11,200
distribution of the error

686
00:27:08,480 --> 00:27:12,000
and then we use our framework but the

687
00:27:11,200 --> 00:27:13,520
this also

688
00:27:12,000 --> 00:27:15,279
because we only use the mean and the

689
00:27:13,520 --> 00:27:16,879
covariance so actually this

690
00:27:15,279 --> 00:27:19,200
these two things models the gaussian

691
00:27:16,880 --> 00:27:21,120
distribution so if the resulting

692
00:27:19,200 --> 00:27:22,960
real solution a real distribution is

693
00:27:21,120 --> 00:27:25,120
very far from the question distribution

694
00:27:22,960 --> 00:27:26,960
maybe our framework cannot give you a

695
00:27:25,120 --> 00:27:28,719
very very good result

696
00:27:26,960 --> 00:27:30,559
but it's very close to the recursion

697
00:27:28,720 --> 00:27:32,880
distribution then i think that's a

698
00:27:30,559 --> 00:27:34,559
that's that's a very fitting power to

699
00:27:32,880 --> 00:27:36,320
our framework i see

700
00:27:34,559 --> 00:27:38,879
but if the error distribution is for

701
00:27:36,320 --> 00:27:41,439
example uniform over a small interval

702
00:27:38,880 --> 00:27:43,360
uh or something like that then then the

703
00:27:41,440 --> 00:27:47,120
framework may not be a good fit for

704
00:27:43,360 --> 00:27:49,520
understanding that kind of problem um

705
00:27:47,120 --> 00:27:50,879
i i think it depends on like how likely

706
00:27:49,520 --> 00:27:54,000
um

707
00:27:50,880 --> 00:27:55,840
so how good the content distribution can

708
00:27:54,000 --> 00:27:58,720
model the uniform distribution

709
00:27:55,840 --> 00:28:00,080
but um but it could be a good direction

710
00:27:58,720 --> 00:28:02,640
for the future work to

711
00:28:00,080 --> 00:28:03,840
include in the different type of

712
00:28:02,640 --> 00:28:08,080
distributions

713
00:28:03,840 --> 00:28:08,080
yeah all right thank you

714
00:28:10,559 --> 00:28:14,320
all right i think we'll move to the

715
00:28:12,399 --> 00:28:17,520
fourth uh and last

716
00:28:14,320 --> 00:28:21,520
talk of the session

717
00:28:17,520 --> 00:28:25,120
um alexander could put up his slides

718
00:28:21,520 --> 00:28:28,960
yes see if it works

719
00:28:25,120 --> 00:28:30,559
you see it we do see it thank you

720
00:28:28,960 --> 00:28:32,080
yeah all right so the final tackle of

721
00:28:30,559 --> 00:28:34,799
the session is

722
00:28:32,080 --> 00:28:37,199
a key recovery timing attack on post

723
00:28:34,799 --> 00:28:39,120
quantum primitives using the fujisaki

724
00:28:37,200 --> 00:28:43,200
okamoto transformation

725
00:28:39,120 --> 00:28:47,039
and its application on photochem the

726
00:28:43,200 --> 00:28:50,159
work is by kian guo thomas johansson

727
00:28:47,039 --> 00:28:51,039
and alexander nilsson and alexander will

728
00:28:50,159 --> 00:28:54,480
give the talk

729
00:28:51,039 --> 00:28:59,279
and the floor is yours yeah thank you

730
00:28:54,480 --> 00:29:01,760
um all right so uh

731
00:28:59,279 --> 00:29:03,039
moving directly to see if we can switch

732
00:29:01,760 --> 00:29:05,520
slides

733
00:29:03,039 --> 00:29:06,320
okay now it works so moving to our

734
00:29:05,520 --> 00:29:10,000
contribution

735
00:29:06,320 --> 00:29:12,799
directly we have uh

736
00:29:10,000 --> 00:29:14,640
the result that the fuji cycle can motor

737
00:29:12,799 --> 00:29:16,720
transform

738
00:29:14,640 --> 00:29:19,520
must be implemented in constant time and

739
00:29:16,720 --> 00:29:20,000
this was not previously known because it

740
00:29:19,520 --> 00:29:23,520
does

741
00:29:20,000 --> 00:29:26,960
doesn't handle secret data so this is an

742
00:29:23,520 --> 00:29:30,480
implementation attack but it's

743
00:29:26,960 --> 00:29:31,039
not previously known so uh we can see

744
00:29:30,480 --> 00:29:34,080
that

745
00:29:31,039 --> 00:29:37,520
this potentially uh affects

746
00:29:34,080 --> 00:29:38,879
a lot of different post-quantum crypto

747
00:29:37,520 --> 00:29:42,960
algorithm

748
00:29:38,880 --> 00:29:42,960
algorithms and

749
00:29:43,279 --> 00:29:49,679
we have decided to show

750
00:29:46,320 --> 00:29:53,520
it on prolucam because

751
00:29:49,679 --> 00:29:57,120
it's a conservative design and they

752
00:29:53,520 --> 00:30:00,080
designers have a clear statement on

753
00:29:57,120 --> 00:30:02,239
using constant time implementations in

754
00:30:00,080 --> 00:30:02,240
the

755
00:30:02,320 --> 00:30:12,559
rest of the implementation

756
00:30:09,679 --> 00:30:13,360
in our paper we have we rely on a common

757
00:30:12,559 --> 00:30:16,720
property of

758
00:30:13,360 --> 00:30:21,199
lwe and codebase schemes

759
00:30:16,720 --> 00:30:26,799
which is on a high level we have

760
00:30:21,200 --> 00:30:26,799
and then encoding strategy

761
00:30:28,880 --> 00:30:35,600
where we first encode the plain text and

762
00:30:31,679 --> 00:30:39,200
then we add a randomized error vector

763
00:30:35,600 --> 00:30:39,199
or a matrix um

764
00:30:39,600 --> 00:30:43,360
this means that when we det the code we

765
00:30:42,240 --> 00:30:47,520
must

766
00:30:43,360 --> 00:30:50,158
remove this error vector or matrix and

767
00:30:47,520 --> 00:30:50,960
we do this by either some lattice

768
00:30:50,159 --> 00:30:54,080
technique or

769
00:30:50,960 --> 00:30:57,519
decoding algorithms and basically

770
00:30:54,080 --> 00:31:00,470
this is the

771
00:30:57,519 --> 00:31:01,679
property that the security

772
00:31:00,470 --> 00:31:03,919
[Music]

773
00:31:01,679 --> 00:31:05,519
hinges upon for the schemes but what we

774
00:31:03,919 --> 00:31:09,600
are interested in

775
00:31:05,519 --> 00:31:13,279
is the fact that if we modify

776
00:31:09,600 --> 00:31:16,840
this error

777
00:31:13,279 --> 00:31:18,080
and also by extension modifying the

778
00:31:16,840 --> 00:31:22,559
ciphertext

779
00:31:18,080 --> 00:31:24,799
we get two different outcomes either

780
00:31:22,559 --> 00:31:26,720
we modify by small amount which means

781
00:31:24,799 --> 00:31:30,320
that we get

782
00:31:26,720 --> 00:31:33,840
the same decoding as we would have

783
00:31:30,320 --> 00:31:33,840
otherwise and or we

784
00:31:34,000 --> 00:31:39,279
get a decryption failure and

785
00:31:37,039 --> 00:31:40,960
failure in this case case means that we

786
00:31:39,279 --> 00:31:46,559
decrypt

787
00:31:40,960 --> 00:31:48,880
to a different plaintext

788
00:31:46,559 --> 00:31:48,879
uh

789
00:31:52,240 --> 00:31:55,679
yeah so the for recycle commodity

790
00:31:55,039 --> 00:32:00,640
transform

791
00:31:55,679 --> 00:32:04,080
is using this property and

792
00:32:00,640 --> 00:32:08,000
basically transforms it from

793
00:32:04,080 --> 00:32:11,519
a cpa to a cca secure cipher

794
00:32:08,000 --> 00:32:16,480
and it does it by removing this property

795
00:32:11,519 --> 00:32:16,480
and it do do it like

796
00:32:16,559 --> 00:32:23,279
this here we have the

797
00:32:19,600 --> 00:32:25,600
the capsulation function because i'm

798
00:32:23,279 --> 00:32:27,120
not having much time so we'll focus on

799
00:32:25,600 --> 00:32:29,840
that

800
00:32:27,120 --> 00:32:32,879
so basically what you do is you do the

801
00:32:29,840 --> 00:32:36,720
cpa secure version of the

802
00:32:32,880 --> 00:32:40,480
cipher and you decrypt

803
00:32:36,720 --> 00:32:43,760
a plain text and then you hash it

804
00:32:40,480 --> 00:32:47,039
with your public key

805
00:32:43,760 --> 00:32:50,640
uh so you get some values

806
00:32:47,039 --> 00:32:54,158
and after that

807
00:32:50,640 --> 00:32:57,519
you re-encrypt the value

808
00:32:54,159 --> 00:32:59,600
that you decoded and then you make a

809
00:32:57,519 --> 00:33:02,720
comparison

810
00:32:59,600 --> 00:33:05,360
and basically if

811
00:33:02,720 --> 00:33:06,000
you re-encrypted to the same ciphertext

812
00:33:05,360 --> 00:33:09,678
that

813
00:33:06,000 --> 00:33:12,880
the the capsulation function received

814
00:33:09,679 --> 00:33:16,000
then you return the same secret as the

815
00:33:12,880 --> 00:33:16,000
encapsulation function

816
00:33:16,320 --> 00:33:20,639
on the other hand if you get a different

817
00:33:23,200 --> 00:33:26,960
ciphertext than what you received then

818
00:33:25,360 --> 00:33:30,719
you

819
00:33:26,960 --> 00:33:32,960
make this result in a failure

820
00:33:30,720 --> 00:33:34,320
and most often this is implemented by

821
00:33:32,960 --> 00:33:36,799
simply returning a different shared

822
00:33:34,320 --> 00:33:36,799
secret

823
00:33:36,840 --> 00:33:42,240
um but here

824
00:33:39,360 --> 00:33:44,399
we have the interesting part because

825
00:33:42,240 --> 00:33:46,159
this comparison here

826
00:33:44,399 --> 00:33:48,719
is most often implemented with a

827
00:33:46,159 --> 00:33:52,960
memcompare function in t

828
00:33:48,720 --> 00:33:57,600
or java array equals

829
00:33:52,960 --> 00:33:57,600
or similar functions and

830
00:33:57,840 --> 00:34:03,519
the thing is that this is comparison of

831
00:34:01,039 --> 00:34:07,039
public values

832
00:34:03,519 --> 00:34:08,159
which means that you would be forgiven

833
00:34:07,039 --> 00:34:11,280
to not

834
00:34:08,159 --> 00:34:14,560
implementing this in constant time

835
00:34:11,280 --> 00:34:18,079
and this is what many schemes do

836
00:34:14,560 --> 00:34:21,040
and we have shown that

837
00:34:18,079 --> 00:34:24,000
one must in fact implement this part in

838
00:34:21,040 --> 00:34:24,000
constant time as well

839
00:34:24,399 --> 00:34:32,319
uh so moving on to

840
00:34:27,839 --> 00:34:34,799
a very brief description of the attack

841
00:34:32,320 --> 00:34:36,720
the details are in the longer video and

842
00:34:34,800 --> 00:34:40,000
the paper of course

843
00:34:36,719 --> 00:34:41,759
uh but this is a highlight so basically

844
00:34:40,000 --> 00:34:44,879
we have an algorithm where

845
00:34:41,760 --> 00:34:48,879
we take us input the plain text and

846
00:34:44,879 --> 00:34:51,759
a modification we call d

847
00:34:48,879 --> 00:34:52,078
and then output output whether or not

848
00:34:51,760 --> 00:34:55,280
this

849
00:34:52,079 --> 00:34:57,200
modification resulted in a decryption

850
00:34:55,280 --> 00:34:59,599
failure

851
00:34:57,200 --> 00:35:01,200
so basically what we do we do a normal

852
00:34:59,599 --> 00:35:04,800
encryption

853
00:35:01,200 --> 00:35:07,919
then we do a modification

854
00:35:04,800 --> 00:35:09,520
to the ciphertext that we encrypted and

855
00:35:07,920 --> 00:35:12,880
then we simply send

856
00:35:09,520 --> 00:35:16,079
the ciphertext to the

857
00:35:12,880 --> 00:35:17,920
target and then we measure in our case

858
00:35:16,079 --> 00:35:20,960
we measure the amount of time

859
00:35:17,920 --> 00:35:25,040
it takes to decapsulate

860
00:35:20,960 --> 00:35:27,119
our message and then depending on

861
00:35:25,040 --> 00:35:28,320
the timing measurement we decide whether

862
00:35:27,119 --> 00:35:32,240
or not

863
00:35:28,320 --> 00:35:32,240
this modification resulted

864
00:35:32,560 --> 00:35:36,960
in a decryption failure in the cpa

865
00:35:37,680 --> 00:35:40,640
decryption function

866
00:35:41,280 --> 00:35:45,839
and so this

867
00:35:46,720 --> 00:35:51,919
so this depends on using this

868
00:35:49,599 --> 00:35:54,480
information depends on the scheme

869
00:35:51,920 --> 00:35:56,640
you're actually trying to attack and in

870
00:35:54,480 --> 00:36:00,079
our longer video we are showing how we

871
00:35:56,640 --> 00:36:00,078
can do that on probably chem

872
00:36:00,160 --> 00:36:06,240
but moving on to the actual measurements

873
00:36:04,320 --> 00:36:09,920
we can see that

874
00:36:06,240 --> 00:36:13,598
if we modify our ciphertext

875
00:36:09,920 --> 00:36:16,960
not at all this will be the green graph

876
00:36:13,599 --> 00:36:18,640
then we get a timing profile looking

877
00:36:16,960 --> 00:36:22,160
kind of like this

878
00:36:18,640 --> 00:36:24,240
and if we do the very minimum amount of

879
00:36:22,160 --> 00:36:27,839
modification to our ciphertext

880
00:36:24,240 --> 00:36:30,879
we can see that nothing actually happens

881
00:36:27,839 --> 00:36:34,880
regarding the execution time

882
00:36:30,880 --> 00:36:37,680
but if we modify the ciphertext

883
00:36:34,880 --> 00:36:38,560
in the maximum amount of spot that is

884
00:36:37,680 --> 00:36:40,078
possible

885
00:36:38,560 --> 00:36:43,599
we can see that we actually get a

886
00:36:40,079 --> 00:36:45,920
different execution profile

887
00:36:43,599 --> 00:36:48,079
and the difference is not very big but

888
00:36:45,920 --> 00:36:55,200
it is definitely measurable

889
00:36:48,079 --> 00:36:58,400
as we can see here and

890
00:36:55,200 --> 00:37:02,000
this brings us to some numbers

891
00:36:58,400 --> 00:37:04,720
we have like i said tiny differences

892
00:37:02,000 --> 00:37:05,920
so so the measurement uh the execution

893
00:37:04,720 --> 00:37:09,439
time is actually

894
00:37:05,920 --> 00:37:10,640
differs as low as 0.04 which means we

895
00:37:09,440 --> 00:37:15,200
need a lots of

896
00:37:10,640 --> 00:37:18,560
measurements uh

897
00:37:15,200 --> 00:37:22,078
so for one instantiation of protocam

898
00:37:18,560 --> 00:37:26,640
we need 97 000 encapsulations

899
00:37:22,079 --> 00:37:30,880
per index in the frodo chem noise matrix

900
00:37:26,640 --> 00:37:34,879
and which means that for pro game

901
00:37:30,880 --> 00:37:37,760
protocol 1344 we need about two to

902
00:37:34,880 --> 00:37:40,720
thirty encapsulation queries to make a

903
00:37:37,760 --> 00:37:44,560
complete key recovery

904
00:37:40,720 --> 00:37:48,879
and uh yeah so this was very brief

905
00:37:44,560 --> 00:37:53,759
about our paper and

906
00:37:48,880 --> 00:37:53,760
not many details but i think

907
00:37:53,920 --> 00:37:58,000
or i hope you have gotten the gist of

908
00:37:56,079 --> 00:38:00,400
what i'm trying to

909
00:37:58,000 --> 00:38:00,400
show you

910
00:38:02,400 --> 00:38:08,880
i guess that is it and i can

911
00:38:05,440 --> 00:38:08,880
accept that any question you want

912
00:38:11,040 --> 00:38:18,880
okay thank you very much for your talk

913
00:38:14,880 --> 00:38:22,000
um so we are

914
00:38:18,880 --> 00:38:24,640
um um

915
00:38:22,000 --> 00:38:25,040
we have several questions in the chat

916
00:38:24,640 --> 00:38:27,520
and

917
00:38:25,040 --> 00:38:29,599
since it's the last the last session i

918
00:38:27,520 --> 00:38:32,720
think we have the time to go

919
00:38:29,599 --> 00:38:34,640
uh through all of them so um so the

920
00:38:32,720 --> 00:38:39,118
first question is by

921
00:38:34,640 --> 00:38:42,319
tanya lana a question for um

922
00:38:39,119 --> 00:38:47,839
i is would frodo can be saved by

923
00:38:42,320 --> 00:38:50,079
confirmation hashes

924
00:38:47,839 --> 00:38:50,078
uh

925
00:38:53,280 --> 00:38:58,839
i'm not quite sure what you mean by

926
00:38:55,839 --> 00:39:01,520
confirmation hashing is it

927
00:38:58,839 --> 00:39:02,078
because as far as i understand it isn't

928
00:39:01,520 --> 00:39:04,000
that

929
00:39:02,079 --> 00:39:06,640
basically what the recycle commodore

930
00:39:04,000 --> 00:39:09,760
transform is doing

931
00:39:06,640 --> 00:39:09,759
you are hashing the

932
00:39:11,280 --> 00:39:17,760
the input because

933
00:39:14,880 --> 00:39:18,640
in that case that is what we're

934
00:39:17,760 --> 00:39:20,320
attacking

935
00:39:18,640 --> 00:39:22,879
so i'm not quite sure if i understand

936
00:39:20,320 --> 00:39:22,880
the question so

937
00:39:23,200 --> 00:39:29,839
tanya um if you can clarify the question

938
00:39:27,520 --> 00:39:29,839
quickly

939
00:39:36,960 --> 00:39:46,000
okay then let me um

940
00:39:42,480 --> 00:39:49,760
tanya says what they mean is include the

941
00:39:46,000 --> 00:39:49,760
hash of the key comma x

942
00:39:53,760 --> 00:39:57,839
okay uh yes

943
00:40:01,520 --> 00:40:08,720
i don't think it i'm not sure

944
00:40:05,920 --> 00:40:11,280
but the fix is very much easier than

945
00:40:08,720 --> 00:40:13,689
that because you simply need to do the

946
00:40:11,280 --> 00:40:16,960
comparison constant time

947
00:40:13,690 --> 00:40:18,800
[Music]

948
00:40:16,960 --> 00:40:25,520
i'm trying to read the question at the

949
00:40:18,800 --> 00:40:29,359
same time i'm answering but

950
00:40:25,520 --> 00:40:32,480
okay uh yes this would probably help

951
00:40:29,359 --> 00:40:33,759
but like i said i think it's easier to

952
00:40:32,480 --> 00:40:35,760
simply

953
00:40:33,760 --> 00:40:37,839
implement it in constant time i looked

954
00:40:35,760 --> 00:40:40,640
at the patch from fruitcam it was very

955
00:40:37,839 --> 00:40:40,640
easy and simple

956
00:40:41,920 --> 00:40:44,079
so

957
00:40:45,839 --> 00:40:51,680
yeah okay then

958
00:40:49,440 --> 00:40:54,480
i will read the next question it's by

959
00:40:51,680 --> 00:40:54,480
daniel apon

960
00:40:54,720 --> 00:40:59,200
it seems like using a constant time java

961
00:40:57,680 --> 00:41:02,000
equals functions calls

962
00:40:59,200 --> 00:41:04,399
or similar would be enough is that

963
00:41:02,000 --> 00:41:04,400
correct

964
00:41:04,839 --> 00:41:07,839
yes

965
00:41:07,920 --> 00:41:12,079
yeah i don't think i need to say any

966
00:41:09,839 --> 00:41:19,920
more than yes okay

967
00:41:12,079 --> 00:41:21,920
and then a question by search ordnay um

968
00:41:19,920 --> 00:41:22,720
ah okay that wasn't actually a question

969
00:41:21,920 --> 00:41:27,040
it was a

970
00:41:22,720 --> 00:41:28,720
response to tanya um so by says rodney

971
00:41:27,040 --> 00:41:30,720
it seems to me that the attack does not

972
00:41:28,720 --> 00:41:32,160
depend on whether the pkc is lattice

973
00:41:30,720 --> 00:41:34,160
based or code based

974
00:41:32,160 --> 00:41:36,879
it only depends on the ciphertext being

975
00:41:34,160 --> 00:41:40,720
an array is that correct

976
00:41:36,880 --> 00:41:43,920
uh yes the in general but

977
00:41:40,720 --> 00:41:44,959
uh so the the general part is that you

978
00:41:43,920 --> 00:41:48,000
can

979
00:41:44,960 --> 00:41:50,880
get information on decryption

980
00:41:48,000 --> 00:41:52,640
failure or not even though the recycle

981
00:41:50,880 --> 00:41:55,040
commodore transform does not actually

982
00:41:52,640 --> 00:41:55,040
tell you

983
00:41:55,760 --> 00:42:02,000
but then you need to adapt it to

984
00:41:58,800 --> 00:42:03,599
the cipher to actually use

985
00:42:02,000 --> 00:42:05,760
this information and that's different

986
00:42:03,599 --> 00:42:08,960
for each scheme

987
00:42:05,760 --> 00:42:08,960
but in general yes

988
00:42:11,760 --> 00:42:18,960
um by thomas rosa

989
00:42:16,480 --> 00:42:21,359
did you consider to experiment with your

990
00:42:18,960 --> 00:42:25,200
side channel technique to extend

991
00:42:21,359 --> 00:42:28,799
the similar gpst galbraith pt

992
00:42:25,200 --> 00:42:31,118
sunny key attack approach on seeker

993
00:42:28,800 --> 00:42:32,960
where the fujisaki okamoto construction

994
00:42:31,119 --> 00:42:35,680
is believed to be a reliable

995
00:42:32,960 --> 00:42:35,680
countermeasure

996
00:42:39,280 --> 00:42:47,599
i do not recall any discussions on that

997
00:42:43,599 --> 00:42:50,079
maybe some of my co-authors remember

998
00:42:47,599 --> 00:42:51,280
a discussion on it they should be here

999
00:42:50,079 --> 00:42:54,079
but

1000
00:42:51,280 --> 00:42:56,480
i suppose they can answer in the chat if

1001
00:42:54,079 --> 00:42:56,480
they know

1002
00:42:56,960 --> 00:43:03,119
i do not believe i

1003
00:43:00,240 --> 00:43:04,720
we have considered it okay so we will

1004
00:43:03,119 --> 00:43:06,880
just move to the next question but if

1005
00:43:04,720 --> 00:43:08,879
the co-authors have some good answer

1006
00:43:06,880 --> 00:43:12,640
they can just post it in the quest as a

1007
00:43:08,880 --> 00:43:16,400
response then thomas will get the answer

1008
00:43:12,640 --> 00:43:18,560
next question by leo dukas

1009
00:43:16,400 --> 00:43:20,960
your conclusion is that protecting

1010
00:43:18,560 --> 00:43:22,720
secret related data is not enough

1011
00:43:20,960 --> 00:43:24,960
can you formulate a new general

1012
00:43:22,720 --> 00:43:28,560
principle that timing

1013
00:43:24,960 --> 00:43:32,720
safe implementation should aim for

1014
00:43:28,560 --> 00:43:36,720
um i suppose you could

1015
00:43:32,720 --> 00:43:41,839
uh basically expand the definition of

1016
00:43:36,720 --> 00:43:41,839
what is actually secret

1017
00:43:43,599 --> 00:43:55,440
because the comparison

1018
00:43:48,319 --> 00:43:57,680
basically assumes that

1019
00:43:55,440 --> 00:43:58,480
you you assume that the comparison will

1020
00:43:57,680 --> 00:44:03,359
be always

1021
00:43:58,480 --> 00:44:06,839
correct or equal and

1022
00:44:03,359 --> 00:44:09,680
anytime it is not equal it will be an

1023
00:44:06,839 --> 00:44:12,319
attack

1024
00:44:09,680 --> 00:44:12,319
so it

1025
00:44:14,800 --> 00:44:23,839
i have not thought of this before but i

1026
00:44:17,920 --> 00:44:23,839
guess an expansion on

1027
00:44:24,400 --> 00:44:33,440
what you mean by secret information

1028
00:44:27,760 --> 00:44:33,440
uh would be one way

1029
00:44:34,079 --> 00:44:38,720
but i guess there's better

1030
00:44:39,839 --> 00:44:44,640
i need to think about it but yes

1031
00:44:41,440 --> 00:44:44,640
probably it's possible

1032
00:44:45,760 --> 00:44:54,720
okay um thank you i saw a related snc

1033
00:44:50,400 --> 00:44:54,720
prime secret uh

1034
00:44:55,599 --> 00:44:59,280
i just saw it in the chat uh and yes or

1035
00:44:58,800 --> 00:45:01,440
no

1036
00:44:59,280 --> 00:45:02,720
it's not secret to the attacker because

1037
00:45:01,440 --> 00:45:05,270
the attacker

1038
00:45:02,720 --> 00:45:08,160
basically constructed it

1039
00:45:05,270 --> 00:45:11,280
[Music]

1040
00:45:08,160 --> 00:45:15,200
but that constructed the original

1041
00:45:11,280 --> 00:45:15,200
ciphertext but not the re-encryption

1042
00:45:16,319 --> 00:45:21,359
well they that i their re-encryption is

1043
00:45:19,200 --> 00:45:25,359
based on

1044
00:45:21,359 --> 00:45:28,480
uh the public key and uh

1045
00:45:25,359 --> 00:45:30,240
so the attacker first makes the

1046
00:45:28,480 --> 00:45:33,440
original cipher text then they do a

1047
00:45:30,240 --> 00:45:36,479
modification so they have both

1048
00:45:33,440 --> 00:45:37,920
there's a comment by douglas stebala who

1049
00:45:36,480 --> 00:45:41,440
says the re-encryption

1050
00:45:37,920 --> 00:45:43,920
is derived from secret data um after

1051
00:45:41,440 --> 00:45:44,640
we saw this attack he ran a taint

1052
00:45:43,920 --> 00:45:46,240
analysis

1053
00:45:44,640 --> 00:45:48,799
on the frodo chem source code using

1054
00:45:46,240 --> 00:45:51,040
valgrind and indeed it flagged the

1055
00:45:48,800 --> 00:45:52,240
re-encrypted ciphertext as tainted by

1056
00:45:51,040 --> 00:45:55,440
secret data

1057
00:45:52,240 --> 00:46:00,640
so there is a dependence uh on c of c

1058
00:45:55,440 --> 00:46:03,280
prime on the secret data um

1059
00:46:00,640 --> 00:46:03,279
in that respect

1060
00:46:04,079 --> 00:46:08,000
yeah because the the the attacker will

1061
00:46:07,200 --> 00:46:10,799
not know

1062
00:46:08,000 --> 00:46:11,680
to what the cipher text that the

1063
00:46:10,800 --> 00:46:14,880
attacker sent

1064
00:46:11,680 --> 00:46:16,078
decrypt and therefore it cannot the

1065
00:46:14,880 --> 00:46:17,040
attacker cannot predict what

1066
00:46:16,079 --> 00:46:20,240
re-encrypting

1067
00:46:17,040 --> 00:46:22,720
will give i think that's why the c prime

1068
00:46:20,240 --> 00:46:25,118
is actually secret

1069
00:46:22,720 --> 00:46:27,919
but i guess we should not get we have

1070
00:46:25,119 --> 00:46:29,820
still a few more questions so

1071
00:46:27,920 --> 00:46:31,599
but this is probably interesting

1072
00:46:29,820 --> 00:46:34,560
[Music]

1073
00:46:31,599 --> 00:46:37,200
food for thought for future discussions

1074
00:46:34,560 --> 00:46:37,200
on this topic

1075
00:46:38,800 --> 00:46:46,240
okay so um

1076
00:46:42,720 --> 00:46:49,118
next question is by paul koha

1077
00:46:46,240 --> 00:46:50,799
thank you interesting work thank you do

1078
00:46:49,119 --> 00:46:52,720
you think the specific comparison

1079
00:46:50,800 --> 00:46:54,640
operation you analyzed is likely

1080
00:46:52,720 --> 00:46:56,560
to be the only exploitable timing

1081
00:46:54,640 --> 00:46:58,400
variation in the implementation

1082
00:46:56,560 --> 00:47:00,400
or are there likely to be other timing

1083
00:46:58,400 --> 00:47:03,119
vulnerabilities as well

1084
00:47:00,400 --> 00:47:07,119
and if so did you consider any more

1085
00:47:03,119 --> 00:47:07,119
general algorithm level mitigation

1086
00:47:08,839 --> 00:47:14,240
um well the attack is

1087
00:47:11,760 --> 00:47:15,440
specific to the comparison but the

1088
00:47:14,240 --> 00:47:18,879
comparison can be

1089
00:47:15,440 --> 00:47:21,760
implemented by any

1090
00:47:18,880 --> 00:47:23,280
non-constant time function for it to be

1091
00:47:21,760 --> 00:47:25,839
valid

1092
00:47:23,280 --> 00:47:25,839
so

1093
00:47:26,720 --> 00:47:30,480
yeah basically depends on whether or not

1094
00:47:28,400 --> 00:47:33,839
the information the operation is

1095
00:47:30,480 --> 00:47:39,839
constant time or not constant time

1096
00:47:33,839 --> 00:47:39,839
that's the only important part

1097
00:47:42,319 --> 00:47:46,400
well you can expand it to other side

1098
00:47:44,400 --> 00:47:49,599
channeling

1099
00:47:46,400 --> 00:47:52,800
informations like making

1100
00:47:49,599 --> 00:47:54,070
our analysis and stuff like that but

1101
00:47:52,800 --> 00:47:57,040
that was not

1102
00:47:54,070 --> 00:47:59,200
[Music]

1103
00:47:57,040 --> 00:48:02,000
very interesting for us to do at the

1104
00:47:59,200 --> 00:48:02,000
moment but

1105
00:48:05,680 --> 00:48:08,640
okay um

1106
00:48:12,240 --> 00:48:20,399
i uh i will read out two two three more

1107
00:48:17,040 --> 00:48:21,839
uh more comments that i think not

1108
00:48:20,400 --> 00:48:23,599
i know they are partially questions and

1109
00:48:21,839 --> 00:48:27,119
partially comments

1110
00:48:23,599 --> 00:48:28,800
um so by daniel ivan

1111
00:48:27,119 --> 00:48:31,839
i think this is a great paper that

1112
00:48:28,800 --> 00:48:34,079
actually exemplifies a general concern

1113
00:48:31,839 --> 00:48:35,839
an algorithm specification is given and

1114
00:48:34,079 --> 00:48:37,599
the security argument is given based on

1115
00:48:35,839 --> 00:48:40,240
some computational problem

1116
00:48:37,599 --> 00:48:41,119
the specification is checked for general

1117
00:48:40,240 --> 00:48:43,759
crypto

1118
00:48:41,119 --> 00:48:44,800
crypto analytic attacks for example how

1119
00:48:43,760 --> 00:48:47,040
do i attack

1120
00:48:44,800 --> 00:48:48,800
the underlying computation of problems

1121
00:48:47,040 --> 00:48:50,480
people generally become comfortable with

1122
00:48:48,800 --> 00:48:53,119
a mathematical principle

1123
00:48:50,480 --> 00:48:54,720
the scheme is decent now further the

1124
00:48:53,119 --> 00:48:56,559
scheme is implemented

1125
00:48:54,720 --> 00:48:58,480
how do you ensure that there are no

1126
00:48:56,559 --> 00:48:59,680
implementation problems that leak the

1127
00:48:58,480 --> 00:49:01,119
key etc

1128
00:48:59,680 --> 00:49:03,200
i mean this ends with a question mark

1129
00:49:01,119 --> 00:49:05,760
but i think it's it's not

1130
00:49:03,200 --> 00:49:08,000
meant as a an actual question now to the

1131
00:49:05,760 --> 00:49:09,520
speaker but more kind of uh

1132
00:49:08,000 --> 00:49:11,359
well it's also called the generic

1133
00:49:09,520 --> 00:49:14,720
comment

1134
00:49:11,359 --> 00:49:18,799
um and another comment by

1135
00:49:14,720 --> 00:49:22,160
uh daniel bernstein

1136
00:49:18,800 --> 00:49:23,839
as a comment time cop has had already

1137
00:49:22,160 --> 00:49:26,399
flagged the problem here

1138
00:49:23,839 --> 00:49:29,119
with an automated vagrant analysis then

1139
00:49:26,400 --> 00:49:30,720
a link to it that i will not read out

1140
00:49:29,119 --> 00:49:33,040
for people who would like to check their

1141
00:49:30,720 --> 00:49:35,359
implementations time corp is

1142
00:49:33,040 --> 00:49:36,240
integrated into the next release of

1143
00:49:35,359 --> 00:49:39,440
super cop

1144
00:49:36,240 --> 00:49:41,200
coming up in a few days and then

1145
00:49:39,440 --> 00:49:45,839
in addition of course showing that the

1146
00:49:41,200 --> 00:49:45,839
problem is exploitable is worth a paper

1147
00:49:46,960 --> 00:49:55,200
yep that's good okay so that

1148
00:49:50,880 --> 00:49:55,200
was quite an interesting discussion um

1149
00:49:55,599 --> 00:50:01,839
yes i so chris is

1150
00:49:59,040 --> 00:50:02,160
taking care of the time so should we end

1151
00:50:01,839 --> 00:50:05,520
it

1152
00:50:02,160 --> 00:50:07,520
here or keep it going some more

1153
00:50:05,520 --> 00:50:09,759
well i would say uh i would say we're

1154
00:50:07,520 --> 00:50:12,880
comfortably over the scheduled time

1155
00:50:09,760 --> 00:50:14,559
uh and we've had a great discussion on

1156
00:50:12,880 --> 00:50:17,599
on this paper and and the others

1157
00:50:14,559 --> 00:50:20,240
so um we thank all the speakers

1158
00:50:17,599 --> 00:50:21,520
uh for their talks and all the authors

1159
00:50:20,240 --> 00:50:23,279
for their work and

1160
00:50:21,520 --> 00:50:24,960
and the audience for the great questions

1161
00:50:23,280 --> 00:50:27,520
and discussion and

1162
00:50:24,960 --> 00:50:28,319
i think that will be the end of today's

1163
00:50:27,520 --> 00:50:31,040
uh

1164
00:50:28,319 --> 00:50:33,920
program and we'll begin again tomorrow

1165
00:50:31,040 --> 00:50:37,520
hope to see all of you then

1166
00:50:33,920 --> 00:50:37,520
okay yes thank you thank

