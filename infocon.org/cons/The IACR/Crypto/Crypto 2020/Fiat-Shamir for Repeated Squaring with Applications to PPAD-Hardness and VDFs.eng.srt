1
00:00:00,960 --> 00:00:04,000
hey everyone and welcome to my talk for

2
00:00:02,800 --> 00:00:05,839
crypto 2020

3
00:00:04,000 --> 00:00:07,439
on fiat chamier for repeated squaring

4
00:00:05,839 --> 00:00:08,480
with applications to ppad hardness and

5
00:00:07,440 --> 00:00:10,639
vdx

6
00:00:08,480 --> 00:00:12,240
i'm alex this is joint work with vinod

7
00:00:10,639 --> 00:00:15,200
and our paper is publicly available on

8
00:00:12,240 --> 00:00:16,800
eprint at the link on the slide

9
00:00:15,200 --> 00:00:18,480
the talk is going to be about fiesta mir

10
00:00:16,800 --> 00:00:20,560
so let's start by defining it

11
00:00:18,480 --> 00:00:22,080
so the theatromir transform is a

12
00:00:20,560 --> 00:00:24,160
heuristic mechanism

13
00:00:22,080 --> 00:00:26,000
for converting public coin interactive

14
00:00:24,160 --> 00:00:28,000
protocols for some task

15
00:00:26,000 --> 00:00:29,198
into a non-interactive protocol for the

16
00:00:28,000 --> 00:00:30,960
same task

17
00:00:29,199 --> 00:00:32,719
so in more detail we start with an

18
00:00:30,960 --> 00:00:34,559
interactive protocol between approver

19
00:00:32,719 --> 00:00:36,239
and verifier as on the left

20
00:00:34,559 --> 00:00:38,079
and we assume that every verifier

21
00:00:36,239 --> 00:00:39,519
message all these betas are uniformly

22
00:00:38,079 --> 00:00:41,200
random strings

23
00:00:39,520 --> 00:00:43,120
feature mirror then converts this into a

24
00:00:41,200 --> 00:00:45,840
non-interactive protocol

25
00:00:43,120 --> 00:00:47,680
in the following way the prover and

26
00:00:45,840 --> 00:00:50,239
verifier both have access to some

27
00:00:47,680 --> 00:00:52,239
publicly computable hash function h

28
00:00:50,239 --> 00:00:54,239
and the prover is going to use h to

29
00:00:52,239 --> 00:00:56,078
generate an entire transcript for the

30
00:00:54,239 --> 00:00:58,000
interactive protocol in one

31
00:00:56,079 --> 00:01:00,160
message and the way that this can be

32
00:00:58,000 --> 00:01:02,719
done is by iteratively computing

33
00:01:00,160 --> 00:01:05,039
approver message alpha i and then

34
00:01:02,719 --> 00:01:07,920
computing the response beta i to be

35
00:01:05,040 --> 00:01:09,119
hash of all of the messages so far and

36
00:01:07,920 --> 00:01:11,280
so this will allow the proof

37
00:01:09,119 --> 00:01:13,600
to generate an entire transcript the

38
00:01:11,280 --> 00:01:16,159
verifier can compute all of these same

39
00:01:13,600 --> 00:01:18,559
hashes itself and then check whether the

40
00:01:16,159 --> 00:01:20,720
overall transcripts that the alphas

41
00:01:18,560 --> 00:01:21,920
indicate along with the hash function

42
00:01:20,720 --> 00:01:23,280
would be accepting

43
00:01:21,920 --> 00:01:25,759
and if so the verifier for the

44
00:01:23,280 --> 00:01:28,799
non-interactive protocol will accept

45
00:01:25,759 --> 00:01:29,920
so syntactically this makes sense but

46
00:01:28,799 --> 00:01:32,000
it's unclear

47
00:01:29,920 --> 00:01:33,759
whether the soundness of the protocol is

48
00:01:32,000 --> 00:01:36,240
preserved by this transformation so

49
00:01:33,759 --> 00:01:37,280
the question is whether it's still

50
00:01:36,240 --> 00:01:39,199
difficult

51
00:01:37,280 --> 00:01:41,840
for the prover of the non-interactive

52
00:01:39,200 --> 00:01:43,520
protocol to come up with a proof of a

53
00:01:41,840 --> 00:01:44,079
false statement that the verifier will

54
00:01:43,520 --> 00:01:46,240
accept

55
00:01:44,079 --> 00:01:48,320
that's the question so the the question

56
00:01:46,240 --> 00:01:50,399
of whether field mirror is sent

57
00:01:48,320 --> 00:01:52,000
and despite the fact that this

58
00:01:50,399 --> 00:01:53,520
transformation has been ubiquitous in

59
00:01:52,000 --> 00:01:55,280
cryptography for decades

60
00:01:53,520 --> 00:01:56,798
on the theory side relatively little is

61
00:01:55,280 --> 00:01:59,200
known actually about the

62
00:01:56,799 --> 00:02:00,640
security of this transformation so on

63
00:01:59,200 --> 00:02:02,479
the one hand we know that if you model

64
00:02:00,640 --> 00:02:04,320
the hash function as a random oracle

65
00:02:02,479 --> 00:02:06,479
you can show in fairly high generality

66
00:02:04,320 --> 00:02:09,038
that the transformation is sound

67
00:02:06,479 --> 00:02:10,000
but on the other hand it's also known

68
00:02:09,038 --> 00:02:12,000
that there are

69
00:02:10,000 --> 00:02:13,200
strong counter examples to doing this in

70
00:02:12,000 --> 00:02:14,319
the standard model so there are some

71
00:02:13,200 --> 00:02:15,760
interactive protocols

72
00:02:14,319 --> 00:02:17,359
such that no matter what efficiently

73
00:02:15,760 --> 00:02:18,239
computable hash function or family of

74
00:02:17,360 --> 00:02:21,040
hash functions

75
00:02:18,239 --> 00:02:22,959
you use for fiesta mere the resulting

76
00:02:21,040 --> 00:02:24,160
non-interactive protocol will be unsound

77
00:02:22,959 --> 00:02:25,840
so this is a setting where random

78
00:02:24,160 --> 00:02:28,000
oracles and real hash functions seem to

79
00:02:25,840 --> 00:02:30,160
be really different

80
00:02:28,000 --> 00:02:31,920
so given this uh in more detail the

81
00:02:30,160 --> 00:02:34,319
question is

82
00:02:31,920 --> 00:02:36,238
for which protocols can we actually

83
00:02:34,319 --> 00:02:37,518
instantiate fiat mirror using an actual

84
00:02:36,239 --> 00:02:39,599
hash function

85
00:02:37,519 --> 00:02:40,800
and what assumption do you need to make

86
00:02:39,599 --> 00:02:42,560
about the hash function

87
00:02:40,800 --> 00:02:44,959
that's sufficient to guarantee the

88
00:02:42,560 --> 00:02:47,920
soundness of the theatrometer protocol

89
00:02:44,959 --> 00:02:49,040
so for quite a long time basically

90
00:02:47,920 --> 00:02:50,559
nothing or very little

91
00:02:49,040 --> 00:02:52,640
was known about this question on the

92
00:02:50,560 --> 00:02:53,280
theory side but over the last few years

93
00:02:52,640 --> 00:02:55,359
there's been

94
00:02:53,280 --> 00:02:56,720
a sequence of works that finally began

95
00:02:55,360 --> 00:02:58,400
to make some progress

96
00:02:56,720 --> 00:03:00,800
on this question and and this talk is

97
00:02:58,400 --> 00:03:03,040
about one of these works

98
00:03:00,800 --> 00:03:04,000
so let me walk you all through the state

99
00:03:03,040 --> 00:03:06,560
of the art on fiat

100
00:03:04,000 --> 00:03:07,440
mirror before this paper so we knew that

101
00:03:06,560 --> 00:03:09,599
the mirror

102
00:03:07,440 --> 00:03:11,680
could be provably instantiated in the

103
00:03:09,599 --> 00:03:14,000
following situations

104
00:03:11,680 --> 00:03:16,159
so first of all we always restrict

105
00:03:14,000 --> 00:03:17,599
ourselves for for the rest of this talk

106
00:03:16,159 --> 00:03:19,440
to the setting where the interactive

107
00:03:17,599 --> 00:03:20,079
protocol is statistically sound so we

108
00:03:19,440 --> 00:03:21,599
assume

109
00:03:20,080 --> 00:03:24,319
that the interactive protocol is sound

110
00:03:21,599 --> 00:03:26,640
against unbounded cheating provers

111
00:03:24,319 --> 00:03:27,679
uh more so subject to this and subject

112
00:03:26,640 --> 00:03:29,920
to the number of rounds

113
00:03:27,680 --> 00:03:31,200
being not too large it's actually known

114
00:03:29,920 --> 00:03:32,879
that under a sufficiently strong

115
00:03:31,200 --> 00:03:34,879
assumption about the hash function

116
00:03:32,879 --> 00:03:36,399
uh theatre mirror will be sound uh it's

117
00:03:34,879 --> 00:03:37,679
not a standard assumption it's an

118
00:03:36,400 --> 00:03:39,840
incredibly strong assumption that you

119
00:03:37,680 --> 00:03:41,760
really don't want to make but

120
00:03:39,840 --> 00:03:42,959
theoretically fiat chamber could be

121
00:03:41,760 --> 00:03:44,239
sound this is

122
00:03:42,959 --> 00:03:46,080
evidence on the theory side for that

123
00:03:44,239 --> 00:03:48,560
fact

124
00:03:46,080 --> 00:03:49,680
second of all in some later works we

125
00:03:48,560 --> 00:03:52,400
were able to show

126
00:03:49,680 --> 00:03:53,760
that for a very special class of

127
00:03:52,400 --> 00:03:55,599
interactive proofs

128
00:03:53,760 --> 00:03:57,359
you can actually show that fiat mirror

129
00:03:55,599 --> 00:03:58,079
is sound for a particular hash function

130
00:03:57,360 --> 00:04:00,400
family

131
00:03:58,080 --> 00:04:02,239
under standard cryptographic assumptions

132
00:04:00,400 --> 00:04:04,000
in this case lwe

133
00:04:02,239 --> 00:04:06,159
then finally there is an intermediate

134
00:04:04,000 --> 00:04:07,519
case in the state of the arts a a class

135
00:04:06,159 --> 00:04:09,120
of protocols which is not quite so

136
00:04:07,519 --> 00:04:11,280
narrow as the second line

137
00:04:09,120 --> 00:04:12,319
but it's not nearly as broad as the

138
00:04:11,280 --> 00:04:15,760
first line

139
00:04:12,319 --> 00:04:17,759
uh where under a

140
00:04:15,760 --> 00:04:19,759
slightly weaker assumption than the

141
00:04:17,759 --> 00:04:21,199
general results you can show soundness

142
00:04:19,759 --> 00:04:23,360
and the the assumption for the third

143
00:04:21,199 --> 00:04:25,840
line is still very strong but it's in

144
00:04:23,360 --> 00:04:28,560
some sense or morally falsifiable

145
00:04:25,840 --> 00:04:30,159
uh as opposed to the first line which is

146
00:04:28,560 --> 00:04:31,919
an assumption which is not efficiently

147
00:04:30,160 --> 00:04:35,919
checkable

148
00:04:31,919 --> 00:04:38,080
so that's the state of the arts um

149
00:04:35,919 --> 00:04:39,359
a little bit more on why the first and

150
00:04:38,080 --> 00:04:41,199
third lines are making

151
00:04:39,360 --> 00:04:43,199
non-standard assumptions the kind of

152
00:04:41,199 --> 00:04:44,720
assumption they have to make is

153
00:04:43,199 --> 00:04:46,320
is what's called an optimal hardness

154
00:04:44,720 --> 00:04:47,440
assumption which says that there's some

155
00:04:46,320 --> 00:04:49,120
search problem that you can't

156
00:04:47,440 --> 00:04:49,919
efficiently solve much better than brute

157
00:04:49,120 --> 00:04:52,320
force

158
00:04:49,919 --> 00:04:53,599
this is very far from the kind of

159
00:04:52,320 --> 00:04:55,280
assumptions that we're used to making

160
00:04:53,600 --> 00:04:58,000
encrypted

161
00:04:55,280 --> 00:04:59,198
so one barrier an important barrier uh

162
00:04:58,000 --> 00:05:00,720
in this state of the art

163
00:04:59,199 --> 00:05:02,800
was being able to do feature mirror for

164
00:05:00,720 --> 00:05:04,320
a succinct interactive proof that is

165
00:05:02,800 --> 00:05:06,320
some interactive proof

166
00:05:04,320 --> 00:05:08,320
whose communication complexity was

167
00:05:06,320 --> 00:05:11,520
logarithmic in the amount of time

168
00:05:08,320 --> 00:05:15,120
t it takes to decide the language uh

169
00:05:11,520 --> 00:05:16,560
uh again or we're thinking about just

170
00:05:15,120 --> 00:05:17,280
proofs for deterministic computation in

171
00:05:16,560 --> 00:05:20,320
that case

172
00:05:17,280 --> 00:05:22,479
uh but yeah so we don't

173
00:05:20,320 --> 00:05:24,240
know how to come how to do fiat premiere

174
00:05:22,479 --> 00:05:25,280
for any succinct interactive proof as of

175
00:05:24,240 --> 00:05:27,520
the state of the art

176
00:05:25,280 --> 00:05:29,039
and this is very related it turns out to

177
00:05:27,520 --> 00:05:30,479
questions of p-pad hardness

178
00:05:29,039 --> 00:05:32,080
we'll we'll see later why this is the

179
00:05:30,479 --> 00:05:34,320
case

180
00:05:32,080 --> 00:05:35,280
so we'll be focusing on the second line

181
00:05:34,320 --> 00:05:37,199
of results

182
00:05:35,280 --> 00:05:39,119
uh in this talk and we'll be extending

183
00:05:37,199 --> 00:05:40,639
it beyond

184
00:05:39,120 --> 00:05:42,240
what was known before and in particular

185
00:05:40,639 --> 00:05:44,479
to some interactive so it comes to

186
00:05:42,240 --> 00:05:45,919
synced interactive

187
00:05:44,479 --> 00:05:48,240
so in this talk we'll be talking about

188
00:05:45,919 --> 00:05:51,120
the problem of iterated squaring

189
00:05:48,240 --> 00:05:53,120
so let me define that as well so the

190
00:05:51,120 --> 00:05:55,199
iterated squaring problem

191
00:05:53,120 --> 00:05:56,960
is is the is a problem in which you're

192
00:05:55,199 --> 00:05:57,360
given an rsa modulus so you're given a

193
00:05:56,960 --> 00:05:58,880
number

194
00:05:57,360 --> 00:06:00,400
n which is a product of two primes you

195
00:05:58,880 --> 00:06:02,560
don't know the factorization

196
00:06:00,400 --> 00:06:05,198
uh you're given some group element in z

197
00:06:02,560 --> 00:06:07,039
and star and some number of iterations t

198
00:06:05,199 --> 00:06:08,319
and you want to square the group element

199
00:06:07,039 --> 00:06:10,639
g

200
00:06:08,319 --> 00:06:11,919
t times so you want to compute g to the

201
00:06:10,639 --> 00:06:14,240
2 to the t mod n

202
00:06:11,919 --> 00:06:15,758
which can be done by doing t iterated

203
00:06:14,240 --> 00:06:18,880
squarings

204
00:06:15,759 --> 00:06:20,960
so there is a hard problem

205
00:06:18,880 --> 00:06:21,919
based on based on iterated squaring

206
00:06:20,960 --> 00:06:24,960
namely

207
00:06:21,919 --> 00:06:27,599
it's believed that it takes at least

208
00:06:24,960 --> 00:06:28,799
that it takes very close to time t to

209
00:06:27,600 --> 00:06:31,919
solve this problem

210
00:06:28,800 --> 00:06:34,319
uh and in fact it's it's a there's a

211
00:06:31,919 --> 00:06:35,280
stronger claim which is that even if you

212
00:06:34,319 --> 00:06:37,759
give

213
00:06:35,280 --> 00:06:38,719
your adversary a large amount of

214
00:06:37,759 --> 00:06:41,600
parallelism

215
00:06:38,720 --> 00:06:43,360
it's still believed to to require about

216
00:06:41,600 --> 00:06:45,680
sequential time t

217
00:06:43,360 --> 00:06:46,720
even given super polynomial parallelism

218
00:06:45,680 --> 00:06:49,199
so this is

219
00:06:46,720 --> 00:06:51,039
the hard problem underlying the rsw

220
00:06:49,199 --> 00:06:52,960
timelock puzzle

221
00:06:51,039 --> 00:06:54,080
and we're going to be interested in a

222
00:06:52,960 --> 00:06:57,599
protocol

223
00:06:54,080 --> 00:06:58,639
for this language the language of g

224
00:06:57,599 --> 00:07:02,639
comma h

225
00:06:58,639 --> 00:07:03,919
you're given this fixed modulus n so

226
00:07:02,639 --> 00:07:05,840
as i just said we're now going to think

227
00:07:03,919 --> 00:07:07,599
about making this problem verifiable

228
00:07:05,840 --> 00:07:08,638
so instead of just computing g to the 2

229
00:07:07,599 --> 00:07:10,000
to the t we want to think about

230
00:07:08,639 --> 00:07:11,840
computing this answer

231
00:07:10,000 --> 00:07:13,759
along with a proof that this group

232
00:07:11,840 --> 00:07:14,638
element h is actually g to the 2 to the

233
00:07:13,759 --> 00:07:17,120
t

234
00:07:14,639 --> 00:07:18,479
and so pierrezak gave a succinct

235
00:07:17,120 --> 00:07:20,319
interactive proof

236
00:07:18,479 --> 00:07:22,080
for this computation a couple of years

237
00:07:20,319 --> 00:07:24,479
ago and so we're interested in

238
00:07:22,080 --> 00:07:26,240
in compiling this protocol so let me

239
00:07:24,479 --> 00:07:26,800
quickly describe to you how the protocol

240
00:07:26,240 --> 00:07:29,120
works

241
00:07:26,800 --> 00:07:30,639
so here we have the prover and verifier

242
00:07:29,120 --> 00:07:32,400
uh so what the approver does

243
00:07:30,639 --> 00:07:33,919
the proverb is going to run in time t

244
00:07:32,400 --> 00:07:34,799
the verifier is going to hopefully run

245
00:07:33,919 --> 00:07:38,000
into log t

246
00:07:34,800 --> 00:07:40,720
that's that's what we want so first

247
00:07:38,000 --> 00:07:42,960
the prover computes the halfway point of

248
00:07:40,720 --> 00:07:45,680
the computation going from g to h

249
00:07:42,960 --> 00:07:46,799
so h is t iterated squarings of g so the

250
00:07:45,680 --> 00:07:49,039
prover first computes

251
00:07:46,800 --> 00:07:51,840
t over two iterated squarings of g and

252
00:07:49,039 --> 00:07:54,400
sends this midway point to the verifier

253
00:07:51,840 --> 00:07:56,400
so this group element u is implicitly

254
00:07:54,400 --> 00:07:59,359
making two claims

255
00:07:56,400 --> 00:08:00,960
one is that u is actually g to the two

256
00:07:59,360 --> 00:08:04,080
to the t over two

257
00:08:00,960 --> 00:08:06,318
and second that h is u to the

258
00:08:04,080 --> 00:08:08,080
two to the t over two that that's the

259
00:08:06,319 --> 00:08:09,919
claim that u is the midway point between

260
00:08:08,080 --> 00:08:12,318
g and h

261
00:08:09,919 --> 00:08:13,440
so so this message u generates two

262
00:08:12,319 --> 00:08:16,479
claims

263
00:08:13,440 --> 00:08:17,840
about iterated squarings of size t over

264
00:08:16,479 --> 00:08:18,719
two that the verifier wants to be

265
00:08:17,840 --> 00:08:20,799
convinced of

266
00:08:18,720 --> 00:08:22,479
but instead of asking the prover to

267
00:08:20,800 --> 00:08:24,960
prove both of these claims

268
00:08:22,479 --> 00:08:26,000
uh the verifier does a random two to one

269
00:08:24,960 --> 00:08:28,080
self-reduction

270
00:08:26,000 --> 00:08:30,160
so the verifier picks a random r

271
00:08:28,080 --> 00:08:32,319
thinking of r as an exponent

272
00:08:30,160 --> 00:08:34,880
and then the prover and verifier given

273
00:08:32,320 --> 00:08:36,000
this r can computes a random combination

274
00:08:34,880 --> 00:08:39,039
of the two claims

275
00:08:36,000 --> 00:08:40,719
that i just said uh so we get a new

276
00:08:39,039 --> 00:08:41,760
group element g prime which is u times g

277
00:08:40,719 --> 00:08:43,599
to the r and

278
00:08:41,760 --> 00:08:45,600
answer h prime which is h times u to the

279
00:08:43,599 --> 00:08:48,640
r and now the prover

280
00:08:45,600 --> 00:08:49,200
is supposed to show that h prime is

281
00:08:48,640 --> 00:08:51,120
equal to g

282
00:08:49,200 --> 00:08:52,959
prime to the two to the t over two so

283
00:08:51,120 --> 00:08:56,000
this this gives you a recursion

284
00:08:52,959 --> 00:08:58,079
and so after log depth

285
00:08:56,000 --> 00:09:01,279
of this recursion we'll get to a trivial

286
00:08:58,080 --> 00:09:03,519
statement the verifier can check onto

287
00:09:01,279 --> 00:09:04,399
so it turns out that this protocol can

288
00:09:03,519 --> 00:09:06,800
be made very

289
00:09:04,399 --> 00:09:08,240
efficient so the prover it turns out has

290
00:09:06,800 --> 00:09:10,800
to do very little

291
00:09:08,240 --> 00:09:12,240
work beyond just computing the answer uh

292
00:09:10,800 --> 00:09:13,120
and the verifier is working in time

293
00:09:12,240 --> 00:09:16,240
polylog t

294
00:09:13,120 --> 00:09:18,640
and and the group and logo group sets so

295
00:09:16,240 --> 00:09:19,920
this is great uh i haven't explained why

296
00:09:18,640 --> 00:09:21,519
this is sound but we'll

297
00:09:19,920 --> 00:09:22,560
we'll talk about it later when we're

298
00:09:21,519 --> 00:09:24,640
talking about the trim here but this is

299
00:09:22,560 --> 00:09:26,959
the protocol

300
00:09:24,640 --> 00:09:28,319
so uh when this was originally written

301
00:09:26,959 --> 00:09:29,839
down pieterzek said well

302
00:09:28,320 --> 00:09:31,360
we can take this interactive protocol

303
00:09:29,839 --> 00:09:32,959
and at least heuristically make it

304
00:09:31,360 --> 00:09:34,480
non-interactive using a random oracle by

305
00:09:32,959 --> 00:09:37,760
applying

306
00:09:34,480 --> 00:09:39,120
so in this work uh so what that means is

307
00:09:37,760 --> 00:09:42,160
instead of

308
00:09:39,120 --> 00:09:43,839
sampling r at random the prover can

309
00:09:42,160 --> 00:09:45,360
compute r to be a hash

310
00:09:43,839 --> 00:09:47,680
of all of the relevant information in

311
00:09:45,360 --> 00:09:49,360
each of these reduction steps

312
00:09:47,680 --> 00:09:51,599
so in this work we're asking whether we

313
00:09:49,360 --> 00:09:54,480
can do this compilation in the standard

314
00:09:51,600 --> 00:09:56,480
model and not just using a random oracle

315
00:09:54,480 --> 00:09:58,240
so now let me tell you our results the

316
00:09:56,480 --> 00:10:01,200
the short answer is you can

317
00:09:58,240 --> 00:10:03,040
um so what we show is that if the

318
00:10:01,200 --> 00:10:04,399
learning with errors problem lwe is

319
00:10:03,040 --> 00:10:06,000
sufficiently hard

320
00:10:04,399 --> 00:10:08,240
then fiat mirror for this protocol can

321
00:10:06,000 --> 00:10:11,440
be instantiated and we have a few

322
00:10:08,240 --> 00:10:14,959
quantitative variants of the result so

323
00:10:11,440 --> 00:10:16,720
first of all if lwe is two to the minus

324
00:10:14,959 --> 00:10:18,319
n to the one minus epsilon card so in

325
00:10:16,720 --> 00:10:20,160
other words it's a

326
00:10:18,320 --> 00:10:21,360
strong sub-exponential assumption about

327
00:10:20,160 --> 00:10:23,040
lwe

328
00:10:21,360 --> 00:10:25,839
then you can do fiat mirror for this

329
00:10:23,040 --> 00:10:27,279
protocol where the verifier runs in time

330
00:10:25,839 --> 00:10:29,680
to to the security parameter to the

331
00:10:27,279 --> 00:10:30,880
epsilon so some small sub-exponential

332
00:10:29,680 --> 00:10:32,560
time verification

333
00:10:30,880 --> 00:10:34,399
under a strong sub-exponential

334
00:10:32,560 --> 00:10:35,680
assumption

335
00:10:34,399 --> 00:10:37,760
in general there's a quantitative

336
00:10:35,680 --> 00:10:38,640
trade-off so under stronger lwe

337
00:10:37,760 --> 00:10:42,079
assumptions

338
00:10:38,640 --> 00:10:44,000
you can get faster verification

339
00:10:42,079 --> 00:10:45,279
but i just want to emphasize that all of

340
00:10:44,000 --> 00:10:48,000
the assumptions being made

341
00:10:45,279 --> 00:10:49,839
in all of these results are much much

342
00:10:48,000 --> 00:10:50,959
much weaker than the optimal security

343
00:10:49,839 --> 00:10:53,920
assumption

344
00:10:50,959 --> 00:10:54,640
that was implicit in in the in some of

345
00:10:53,920 --> 00:10:56,479
the

346
00:10:54,640 --> 00:10:57,920
prior work so even the strongest

347
00:10:56,480 --> 00:11:01,839
assumption we make here

348
00:10:57,920 --> 00:11:04,319
this q to the minus like 0.01 n hardness

349
00:11:01,839 --> 00:11:05,519
is uh is way less is way weaker than the

350
00:11:04,320 --> 00:11:07,519
optimal hardness assumption which is

351
00:11:05,519 --> 00:11:10,079
more like a q to the minus n something

352
00:11:07,519 --> 00:11:11,120
in particular all of the lwb assumptions

353
00:11:10,079 --> 00:11:13,120
that we make in this work

354
00:11:11,120 --> 00:11:14,560
actually follow from worst case hardness

355
00:11:13,120 --> 00:11:16,399
via the worst case to average case

356
00:11:14,560 --> 00:11:17,839
reduction

357
00:11:16,399 --> 00:11:19,600
but the first of these results i think

358
00:11:17,839 --> 00:11:21,680
is the most illustrative so under a

359
00:11:19,600 --> 00:11:23,120
strong sub-exponential assumption you

360
00:11:21,680 --> 00:11:25,359
can get a

361
00:11:23,120 --> 00:11:28,079
compiler with small sub-exponential

362
00:11:25,360 --> 00:11:30,880
verification time

363
00:11:28,079 --> 00:11:32,479
and uh so the the point of these of

364
00:11:30,880 --> 00:11:34,240
these stronger assumptions is to get a

365
00:11:32,480 --> 00:11:36,000
larger gap between the amount of time it

366
00:11:34,240 --> 00:11:37,200
takes to compute namely t

367
00:11:36,000 --> 00:11:39,360
and the amount of time it takes to

368
00:11:37,200 --> 00:11:41,279
verify but all of them have a have a

369
00:11:39,360 --> 00:11:43,440
large gap

370
00:11:41,279 --> 00:11:44,399
so from from this vehicle mirror

371
00:11:43,440 --> 00:11:46,480
compiler we get

372
00:11:44,399 --> 00:11:47,680
two cool applications so let me quickly

373
00:11:46,480 --> 00:11:49,760
walk you through them

374
00:11:47,680 --> 00:11:51,920
so first of all we get a verifiable

375
00:11:49,760 --> 00:11:53,680
delay function in the standard model

376
00:11:51,920 --> 00:11:55,120
uh i don't want to get into the

377
00:11:53,680 --> 00:11:57,599
technical definitions

378
00:11:55,120 --> 00:11:59,680
but a verifiable delay function is a

379
00:11:57,600 --> 00:12:00,959
proof of sequential work so a way to

380
00:11:59,680 --> 00:12:02,079
prove that you've done some amounts of

381
00:12:00,959 --> 00:12:04,000
work sequentially

382
00:12:02,079 --> 00:12:05,519
with a unique output that's why it's a

383
00:12:04,000 --> 00:12:08,160
function and with

384
00:12:05,519 --> 00:12:08,959
close to optimal efficiency which means

385
00:12:08,160 --> 00:12:10,639
that

386
00:12:08,959 --> 00:12:12,319
the amount of time it takes to generate

387
00:12:10,639 --> 00:12:14,160
the proof is uh

388
00:12:12,320 --> 00:12:15,760
is very close to the amount of time the

389
00:12:14,160 --> 00:12:19,120
verifier is convinced that you've

390
00:12:15,760 --> 00:12:21,040
worked for so this is very nice

391
00:12:19,120 --> 00:12:22,480
uh the primitive that was introduced

392
00:12:21,040 --> 00:12:24,319
recently

393
00:12:22,480 --> 00:12:26,320
inspired by some application many

394
00:12:24,320 --> 00:12:27,920
applications and sort of large-scale

395
00:12:26,320 --> 00:12:30,079
publicly verifiable protocols things

396
00:12:27,920 --> 00:12:33,360
like blockchain as an example

397
00:12:30,079 --> 00:12:34,000
um and so what peter zack said when he

398
00:12:33,360 --> 00:12:35,360
wrote down the

399
00:12:34,000 --> 00:12:36,639
protocol that i just showed you is that

400
00:12:35,360 --> 00:12:38,320
if you can do feature mirror for that

401
00:12:36,639 --> 00:12:39,839
interactive proof then you get a

402
00:12:38,320 --> 00:12:42,160
verifiable delay function so you get one

403
00:12:39,839 --> 00:12:44,160
in the random oracle model

404
00:12:42,160 --> 00:12:45,439
so that's the first consequence that's

405
00:12:44,160 --> 00:12:47,279
going to come out of our work

406
00:12:45,440 --> 00:12:48,880
the second is about hardness and the

407
00:12:47,279 --> 00:12:50,399
complexity class keypad

408
00:12:48,880 --> 00:12:52,160
this is based on some really cool works

409
00:12:50,399 --> 00:12:53,920
from last year so

410
00:12:52,160 --> 00:12:55,439
p-pad is a complexity class that

411
00:12:53,920 --> 00:12:57,439
captures the hardness

412
00:12:55,440 --> 00:12:58,480
of finding nash equilibria in game

413
00:12:57,440 --> 00:13:00,880
theory

414
00:12:58,480 --> 00:13:01,600
and it's known based on works from last

415
00:13:00,880 --> 00:13:03,680
year

416
00:13:01,600 --> 00:13:05,600
that if repeated squaring is a hard

417
00:13:03,680 --> 00:13:07,519
problem and you can do

418
00:13:05,600 --> 00:13:09,360
fiat chamier for the protocol i just

419
00:13:07,519 --> 00:13:11,279
described in the standard model

420
00:13:09,360 --> 00:13:13,360
then you get hardness of p-pad on

421
00:13:11,279 --> 00:13:15,439
average so just plugging

422
00:13:13,360 --> 00:13:16,720
those two applications into our field

423
00:13:15,440 --> 00:13:20,160
trimmer results

424
00:13:16,720 --> 00:13:21,839
we get that if repeated squaring and lwe

425
00:13:20,160 --> 00:13:23,760
are both sub-exponentially hard

426
00:13:21,839 --> 00:13:26,320
squaring slightly sub-exponentially hard

427
00:13:23,760 --> 00:13:27,839
and lwe very sub-exponentially hard

428
00:13:26,320 --> 00:13:29,600
then you get hardness in the complexity

429
00:13:27,839 --> 00:13:32,000
class keypad and

430
00:13:29,600 --> 00:13:33,120
second of all we get vdfs in the

431
00:13:32,000 --> 00:13:34,880
standard model

432
00:13:33,120 --> 00:13:36,720
with some small sub-exponential

433
00:13:34,880 --> 00:13:39,839
evaluation time

434
00:13:36,720 --> 00:13:42,160
from the first of our results and uh

435
00:13:39,839 --> 00:13:44,160
and even less evaluation time under the

436
00:13:42,160 --> 00:13:46,959
stronger lwd assumptions

437
00:13:44,160 --> 00:13:48,399
uh and it's a vdf assuming that squaring

438
00:13:46,959 --> 00:13:48,959
is also sequentially hard but of course

439
00:13:48,399 --> 00:13:52,560
you need

440
00:13:48,959 --> 00:13:54,479
to have a delay so what i like about

441
00:13:52,560 --> 00:13:56,239
these results is that we're making

442
00:13:54,480 --> 00:13:58,160
you know in the lw case may be somewhat

443
00:13:56,240 --> 00:14:01,120
strong but still sub-exponential

444
00:13:58,160 --> 00:14:02,800
time assumptions about two well-studied

445
00:14:01,120 --> 00:14:03,600
problems and getting these fiature

446
00:14:02,800 --> 00:14:06,319
compilers

447
00:14:03,600 --> 00:14:08,240
it's closer to the stand like it's a

448
00:14:06,320 --> 00:14:09,920
it's closer to the second category

449
00:14:08,240 --> 00:14:12,000
of the results that i showed you before

450
00:14:09,920 --> 00:14:14,880
instead of the first and the third

451
00:14:12,000 --> 00:14:16,959
and from these assumptions we get a

452
00:14:14,880 --> 00:14:19,040
succinct non-interactive argument for a

453
00:14:16,959 --> 00:14:21,518
very non-trivial language in particular

454
00:14:19,040 --> 00:14:23,360
a language that enables these two cool

455
00:14:21,519 --> 00:14:25,600
applications

456
00:14:23,360 --> 00:14:27,440
so just before i get into the results

457
00:14:25,600 --> 00:14:30,160
anymore let me just quickly

458
00:14:27,440 --> 00:14:31,360
show you what was known uh what is known

459
00:14:30,160 --> 00:14:32,560
about ppad hardness based on

460
00:14:31,360 --> 00:14:34,560
cryptography

461
00:14:32,560 --> 00:14:35,599
so there are three results worth

462
00:14:34,560 --> 00:14:37,680
mentioning

463
00:14:35,600 --> 00:14:39,360
one is that we know p-pad is hard under

464
00:14:37,680 --> 00:14:40,719
obfuscation-like assumptions that was

465
00:14:39,360 --> 00:14:42,399
the first result we knew about keypad

466
00:14:40,720 --> 00:14:44,000
hardness based on photography

467
00:14:42,399 --> 00:14:45,920
and second of all there there's this

468
00:14:44,000 --> 00:14:47,839
line of work from last year that fiat

469
00:14:45,920 --> 00:14:49,680
mirror for certain succinct interactive

470
00:14:47,839 --> 00:14:52,880
proofs is enough

471
00:14:49,680 --> 00:14:54,800
uh to get ppad hardness uh but

472
00:14:52,880 --> 00:14:55,920
last year we didn't have any concrete

473
00:14:54,800 --> 00:14:58,479
instantiate or

474
00:14:55,920 --> 00:14:59,439
any instantiations based on standard

475
00:14:58,480 --> 00:15:02,480
assumptions

476
00:14:59,440 --> 00:15:04,480
of this of this approach and then uh

477
00:15:02,480 --> 00:15:06,240
and then concurrent to this paper uh

478
00:15:04,480 --> 00:15:08,800
kalai panathen yang

479
00:15:06,240 --> 00:15:09,920
gave a different construction of a hard

480
00:15:08,800 --> 00:15:11,519
ppad instance

481
00:15:09,920 --> 00:15:13,120
based on a falsifiable assumption on

482
00:15:11,519 --> 00:15:14,639
bilinear maps and you can see lisa

483
00:15:13,120 --> 00:15:17,120
giving a talk on this work in the same

484
00:15:14,639 --> 00:15:17,120
conference

485
00:15:17,199 --> 00:15:21,519
okay so those are the results so for the

486
00:15:20,000 --> 00:15:24,560
rest of the talk

487
00:15:21,519 --> 00:15:25,680
i just want to uh go over a bit about

488
00:15:24,560 --> 00:15:26,959
how we prove the results

489
00:15:25,680 --> 00:15:29,359
so here's the overview of the rest of

490
00:15:26,959 --> 00:15:31,758
the talk i'll first describe the

491
00:15:29,360 --> 00:15:33,680
general paradigm that we know for

492
00:15:31,759 --> 00:15:34,480
provenly instantiating theochamiere in

493
00:15:33,680 --> 00:15:35,920
the standard model

494
00:15:34,480 --> 00:15:38,000
this is based on one of the works from

495
00:15:35,920 --> 00:15:40,160
last year

496
00:15:38,000 --> 00:15:41,680
we'll then see why the methodology as of

497
00:15:40,160 --> 00:15:43,279
last year wasn't enough

498
00:15:41,680 --> 00:15:44,479
to compile this protocol that we're

499
00:15:43,279 --> 00:15:46,000
talking about in this paper what the

500
00:15:44,480 --> 00:15:49,279
what the problem was

501
00:15:46,000 --> 00:15:51,440
and then i'll show you how to extend the

502
00:15:49,279 --> 00:15:52,399
paradigm for compiling for for doing

503
00:15:51,440 --> 00:15:54,800
feature mirror

504
00:15:52,399 --> 00:15:56,639
uh beyond what we could do last year and

505
00:15:54,800 --> 00:15:59,279
in particular enough like

506
00:15:56,639 --> 00:16:01,839
how to capture the protocol that we're

507
00:15:59,279 --> 00:16:05,120
trying to compile today

508
00:16:01,839 --> 00:16:06,880
so the main tool for compiling fiat

509
00:16:05,120 --> 00:16:08,720
chamier in the standard model

510
00:16:06,880 --> 00:16:10,000
are is correlation and tractability

511
00:16:08,720 --> 00:16:11,440
which is a security property of a hash

512
00:16:10,000 --> 00:16:12,880
function originally introduced

513
00:16:11,440 --> 00:16:15,600
actually for negative results in

514
00:16:12,880 --> 00:16:17,360
cryptography um but uh

515
00:16:15,600 --> 00:16:19,199
in our restricted setting we say that a

516
00:16:17,360 --> 00:16:20,079
hash function family h is correlation

517
00:16:19,199 --> 00:16:22,880
intractable

518
00:16:20,079 --> 00:16:23,920
for a function f if it's hard to find f

519
00:16:22,880 --> 00:16:25,360
correlations

520
00:16:23,920 --> 00:16:28,160
in the hash function that is it's hard

521
00:16:25,360 --> 00:16:32,560
to find an input x such that hash of x

522
00:16:28,160 --> 00:16:34,079
equals f of x so as of last year we know

523
00:16:32,560 --> 00:16:35,680
how to construct correlation and

524
00:16:34,079 --> 00:16:37,920
tractable hash functions

525
00:16:35,680 --> 00:16:39,599
for all efficiently computable functions

526
00:16:37,920 --> 00:16:41,759
f or

527
00:16:39,600 --> 00:16:43,199
more more accurately for every time

528
00:16:41,759 --> 00:16:44,800
bound t

529
00:16:43,199 --> 00:16:46,240
we can write down a hash function family

530
00:16:44,800 --> 00:16:46,719
which is correlation and tractable for

531
00:16:46,240 --> 00:16:47,839
time t

532
00:16:46,720 --> 00:16:49,519
computable functions where the

533
00:16:47,839 --> 00:16:50,959
evaluation time for the hash function is

534
00:16:49,519 --> 00:16:53,600
about t

535
00:16:50,959 --> 00:16:55,279
and uh this uh this t dependence is

536
00:16:53,600 --> 00:16:57,040
important and sort of explains why some

537
00:16:55,279 --> 00:16:57,759
of the previous attempts to do these uh

538
00:16:57,040 --> 00:16:59,839
keypad

539
00:16:57,759 --> 00:17:01,600
hardness results were weren't able to

540
00:16:59,839 --> 00:17:04,319
work

541
00:17:01,600 --> 00:17:06,160
uh so now let's see how these hash

542
00:17:04,319 --> 00:17:08,079
functions are useful for featurement

543
00:17:06,160 --> 00:17:10,240
so let's think about just for a second

544
00:17:08,079 --> 00:17:12,240
compiling three message protocols

545
00:17:10,240 --> 00:17:13,839
using a correlation intractable hash

546
00:17:12,240 --> 00:17:15,280
function i claim that for some

547
00:17:13,839 --> 00:17:16,639
interactive proofs for some

548
00:17:15,280 --> 00:17:18,240
for a certain class of interactive

549
00:17:16,640 --> 00:17:19,679
proofs the security property on the

550
00:17:18,240 --> 00:17:21,439
previous slide should be enough

551
00:17:19,679 --> 00:17:22,720
it should be uh enough to guarantee the

552
00:17:21,439 --> 00:17:23,679
soundness of the non-interactive

553
00:17:22,720 --> 00:17:25,039
protocol

554
00:17:23,679 --> 00:17:26,720
so we start with this protocol with

555
00:17:25,039 --> 00:17:28,640
messages alpha beta gamma

556
00:17:26,720 --> 00:17:30,080
and in the non-interactive version beta

557
00:17:28,640 --> 00:17:32,400
instead of being sampled at random

558
00:17:30,080 --> 00:17:33,760
is instead hash of alpha and possibly x

559
00:17:32,400 --> 00:17:35,760
as well

560
00:17:33,760 --> 00:17:37,200
so we'd like to argue that this protocol

561
00:17:35,760 --> 00:17:38,879
is sound

562
00:17:37,200 --> 00:17:41,120
so here's here's how we do it let's

563
00:17:38,880 --> 00:17:43,919
assume that the three methods protocol

564
00:17:41,120 --> 00:17:45,520
has a strong soundness property namely

565
00:17:43,919 --> 00:17:47,039
that for every false statement and

566
00:17:45,520 --> 00:17:48,720
every first message the approver could

567
00:17:47,039 --> 00:17:51,760
send there is at most

568
00:17:48,720 --> 00:17:52,000
one challenge beta such that the prover

569
00:17:51,760 --> 00:17:53,280
has

570
00:17:52,000 --> 00:17:55,200
any way of cheating such that there

571
00:17:53,280 --> 00:17:56,799
exists a third message gamma that would

572
00:17:55,200 --> 00:17:58,720
make the verifier accept

573
00:17:56,799 --> 00:18:00,000
so many protocols of course don't

574
00:17:58,720 --> 00:18:02,160
satisfy such a strong sound this

575
00:18:00,000 --> 00:18:04,880
property but some protocols do

576
00:18:02,160 --> 00:18:06,080
so i claim that in this case uh

577
00:18:04,880 --> 00:18:06,640
correlation and tractability for

578
00:18:06,080 --> 00:18:08,720
functions

579
00:18:06,640 --> 00:18:09,919
is enough to compile the protocol and so

580
00:18:08,720 --> 00:18:13,120
so here's why

581
00:18:09,919 --> 00:18:14,000
so if this sounds properly holds we can

582
00:18:13,120 --> 00:18:17,039
define a function

583
00:18:14,000 --> 00:18:20,000
f which maps the false statement x

584
00:18:17,039 --> 00:18:20,400
and the first message alpha to this one

585
00:18:20,000 --> 00:18:22,320
bad

586
00:18:20,400 --> 00:18:24,640
challenge that would enable the proof of

587
00:18:22,320 --> 00:18:27,120
the cheats we can define this function

588
00:18:24,640 --> 00:18:28,320
and then i claim that if the hash

589
00:18:27,120 --> 00:18:29,600
function family is correlation

590
00:18:28,320 --> 00:18:32,159
intractable for this function

591
00:18:29,600 --> 00:18:33,199
f then the resulting non-interactive

592
00:18:32,160 --> 00:18:34,320
protocol is sound

593
00:18:33,200 --> 00:18:37,120
and this just sort of falls out

594
00:18:34,320 --> 00:18:39,120
immediately or syntactically

595
00:18:37,120 --> 00:18:41,039
if the approver is successfully cheating

596
00:18:39,120 --> 00:18:42,799
for the non-interactive protocol

597
00:18:41,039 --> 00:18:45,360
then in particular the provers produced

598
00:18:42,799 --> 00:18:47,200
an accepting transcript alpha beta gamma

599
00:18:45,360 --> 00:18:49,199
but the assumption is that for every

600
00:18:47,200 --> 00:18:51,440
false x and first message alpha

601
00:18:49,200 --> 00:18:52,320
there is only one beta such that this is

602
00:18:51,440 --> 00:18:55,120
possible at all

603
00:18:52,320 --> 00:18:56,000
and so it must mean that the hash value

604
00:18:55,120 --> 00:18:57,760
beta is also

605
00:18:56,000 --> 00:18:59,760
equal to this function value f of x

606
00:18:57,760 --> 00:19:01,520
comma

607
00:18:59,760 --> 00:19:03,120
so this is the paradigm for doing

608
00:19:01,520 --> 00:19:04,559
fietromir uh

609
00:19:03,120 --> 00:19:06,320
it shows that correlation tractability

610
00:19:04,559 --> 00:19:07,918
for functions is enough to compile

611
00:19:06,320 --> 00:19:09,360
certain protocols

612
00:19:07,919 --> 00:19:11,039
uh but there's a big problem with what

613
00:19:09,360 --> 00:19:12,559
i've said so far which is that for

614
00:19:11,039 --> 00:19:14,160
essentially any interesting protocol any

615
00:19:12,559 --> 00:19:16,480
protocol at all

616
00:19:14,160 --> 00:19:18,000
doing anything not not silly the

617
00:19:16,480 --> 00:19:18,640
function f is actually going to be hard

618
00:19:18,000 --> 00:19:21,120
to compute

619
00:19:18,640 --> 00:19:23,600
not easy uh it's going to take super

620
00:19:21,120 --> 00:19:26,799
polynomial time to compute f

621
00:19:23,600 --> 00:19:30,159
and uh in some sense like

622
00:19:26,799 --> 00:19:31,760
you should expect this if if f were easy

623
00:19:30,160 --> 00:19:32,240
to compute it means the verifier could

624
00:19:31,760 --> 00:19:34,480
somehow

625
00:19:32,240 --> 00:19:35,360
already know what challenges were good

626
00:19:34,480 --> 00:19:36,640
or bad and

627
00:19:35,360 --> 00:19:38,399
and then interaction wouldn't be

628
00:19:36,640 --> 00:19:41,679
necessary anyway

629
00:19:38,400 --> 00:19:43,360
so so this is bad and the workaround so

630
00:19:41,679 --> 00:19:46,400
far the way that we actually

631
00:19:43,360 --> 00:19:49,199
accomplished anything was by

632
00:19:46,400 --> 00:19:49,760
supposing or constructing protocols

633
00:19:49,200 --> 00:19:52,400
where f

634
00:19:49,760 --> 00:19:53,760
might be hard to compute in reality but

635
00:19:52,400 --> 00:19:55,840
it's easy to compute

636
00:19:53,760 --> 00:19:57,679
in our heads in the security proof using

637
00:19:55,840 --> 00:19:58,959
a trapdoor a trapdoor that the

638
00:19:57,679 --> 00:20:00,799
verifier in particular doesn't have

639
00:19:58,960 --> 00:20:04,080
access to

640
00:20:00,799 --> 00:20:05,039
so that's how we got interesting results

641
00:20:04,080 --> 00:20:06,480
before

642
00:20:05,039 --> 00:20:08,320
and already what we're going to be using

643
00:20:06,480 --> 00:20:11,679
in this work is that

644
00:20:08,320 --> 00:20:13,840
you get an interesting compiled protocol

645
00:20:11,679 --> 00:20:14,960
as long as it's easier to compute f

646
00:20:13,840 --> 00:20:16,559
using the trapdoor

647
00:20:14,960 --> 00:20:18,320
than it is to decide the language as

648
00:20:16,559 --> 00:20:20,158
long as that's the case you might have

649
00:20:18,320 --> 00:20:22,320
super polynomial time verification

650
00:20:20,159 --> 00:20:24,000
using using the hash function but it'll

651
00:20:22,320 --> 00:20:25,120
be less than the time it takes to decide

652
00:20:24,000 --> 00:20:26,480
the language and therefore it'll be a

653
00:20:25,120 --> 00:20:27,600
non-trivial protocol

654
00:20:26,480 --> 00:20:29,360
you know in the end we're going to have

655
00:20:27,600 --> 00:20:31,280
small sub-exponential time verification

656
00:20:29,360 --> 00:20:33,600
as it turns out

657
00:20:31,280 --> 00:20:34,480
so let's try to apply this now this

658
00:20:33,600 --> 00:20:37,039
paradigm

659
00:20:34,480 --> 00:20:38,480
to peter's axe protocol so there are

660
00:20:37,039 --> 00:20:41,280
there are two problems

661
00:20:38,480 --> 00:20:42,640
uh with what i just said one is that

662
00:20:41,280 --> 00:20:44,559
peter zach protocol is not three

663
00:20:42,640 --> 00:20:46,559
messages it's actually a logarithmic

664
00:20:44,559 --> 00:20:49,120
number of messages so it's not clear

665
00:20:46,559 --> 00:20:49,600
uh how to adapt first of all and second

666
00:20:49,120 --> 00:20:51,918
of all

667
00:20:49,600 --> 00:20:53,439
if we can if we can freeze the soundness

668
00:20:51,919 --> 00:20:54,559
of this protocol in terms of a bad

669
00:20:53,440 --> 00:20:56,159
challenge function

670
00:20:54,559 --> 00:20:57,918
we then need to come up with an

671
00:20:56,159 --> 00:20:59,280
efficient representation of the function

672
00:20:57,919 --> 00:21:02,320
so that we can use correlation and

673
00:20:59,280 --> 00:21:03,840
tractability for efficient functions

674
00:21:02,320 --> 00:21:05,520
so the first of these problems is

675
00:21:03,840 --> 00:21:08,320
something that has been thought about

676
00:21:05,520 --> 00:21:10,080
before and there is a way for handling

677
00:21:08,320 --> 00:21:11,760
it there is a way to assign

678
00:21:10,080 --> 00:21:13,039
a bad challenge function to peter zach's

679
00:21:11,760 --> 00:21:13,840
protocol even though it's not three

680
00:21:13,039 --> 00:21:15,200
messages

681
00:21:13,840 --> 00:21:16,799
and the idea is that you're going to

682
00:21:15,200 --> 00:21:18,320
have or rather you're going to have one

683
00:21:16,799 --> 00:21:19,600
bad challenge function for each

684
00:21:18,320 --> 00:21:22,320
reduction step

685
00:21:19,600 --> 00:21:24,080
sequentially so you know here's one

686
00:21:22,320 --> 00:21:25,600
reduction step as i described it

687
00:21:24,080 --> 00:21:27,760
and the soundness analysis is going to

688
00:21:25,600 --> 00:21:29,918
say that if the statement

689
00:21:27,760 --> 00:21:32,720
is false that is if h is not the correct

690
00:21:29,919 --> 00:21:34,880
answer then no matter what first message

691
00:21:32,720 --> 00:21:36,240
the prover sends there's going to be at

692
00:21:34,880 --> 00:21:39,840
most one choice

693
00:21:36,240 --> 00:21:42,000
of second message r making the recursive

694
00:21:39,840 --> 00:21:43,840
call

695
00:21:42,000 --> 00:21:45,440
on a true statement instead of on a

696
00:21:43,840 --> 00:21:46,959
false statement you know so

697
00:21:45,440 --> 00:21:48,320
if the recursive call was made to a

698
00:21:46,960 --> 00:21:51,120
false statement then you could keep

699
00:21:48,320 --> 00:21:53,520
going and say everything is fine

700
00:21:51,120 --> 00:21:54,639
the the argument is going to be that

701
00:21:53,520 --> 00:21:56,799
it's rare

702
00:21:54,640 --> 00:21:58,400
to ever go from a false statement to a

703
00:21:56,799 --> 00:21:59,600
true statement as long as you stay on a

704
00:21:58,400 --> 00:22:01,840
false statement then at the end the

705
00:21:59,600 --> 00:22:03,520
verifier will reject

706
00:22:01,840 --> 00:22:04,959
okay so that's that's good and so this

707
00:22:03,520 --> 00:22:05,760
will give us a bad challenge function

708
00:22:04,960 --> 00:22:08,960
for each of

709
00:22:05,760 --> 00:22:12,000
each round reduction okay so

710
00:22:08,960 --> 00:22:13,360
so that's good uh and as i just said uh

711
00:22:12,000 --> 00:22:14,799
this this statement will give us a bad

712
00:22:13,360 --> 00:22:15,600
challenge function for each reduction

713
00:22:14,799 --> 00:22:17,679
step

714
00:22:15,600 --> 00:22:19,280
and so again based on what i just said

715
00:22:17,679 --> 00:22:20,480
if we can come up with a hash function

716
00:22:19,280 --> 00:22:21,840
which is correlation intractable for

717
00:22:20,480 --> 00:22:23,600
this bad challenge function then we'll

718
00:22:21,840 --> 00:22:27,678
get soundness of the resulting

719
00:22:23,600 --> 00:22:29,918
non-interactive protocol and we're done

720
00:22:27,679 --> 00:22:31,039
okay so so that's all well and good the

721
00:22:29,919 --> 00:22:33,760
uh

722
00:22:31,039 --> 00:22:34,559
the real question is you know can we

723
00:22:33,760 --> 00:22:36,640
show that f

724
00:22:34,559 --> 00:22:38,480
is in some sense efficiently computable

725
00:22:36,640 --> 00:22:40,559
perhaps given some trapdoor

726
00:22:38,480 --> 00:22:42,000
so so let's see you know what what is

727
00:22:40,559 --> 00:22:45,280
this function f uh so

728
00:22:42,000 --> 00:22:46,640
i'll spare you the details so it turns

729
00:22:45,280 --> 00:22:48,720
out that if you think about

730
00:22:46,640 --> 00:22:50,480
things in terms of discrete logs instead

731
00:22:48,720 --> 00:22:53,679
of the group elements

732
00:22:50,480 --> 00:22:56,640
that's the bad challenge function are

733
00:22:53,679 --> 00:22:57,360
there the bad challenge r associated to

734
00:22:56,640 --> 00:23:00,559
the statement

735
00:22:57,360 --> 00:23:02,000
and first method u is the solution to a

736
00:23:00,559 --> 00:23:04,158
linear equation

737
00:23:02,000 --> 00:23:06,840
in the exponents of the group where the

738
00:23:04,159 --> 00:23:09,120
coefficients of the equation

739
00:23:06,840 --> 00:23:10,559
are uh where the coefficients of the

740
00:23:09,120 --> 00:23:12,158
equation depend on these discrete

741
00:23:10,559 --> 00:23:13,840
logarithms

742
00:23:12,159 --> 00:23:15,440
so you know this is the linear equation

743
00:23:13,840 --> 00:23:18,879
don't worry about it too much

744
00:23:15,440 --> 00:23:19,760
um but let me at least argue to you guys

745
00:23:18,880 --> 00:23:21,760
that uh

746
00:23:19,760 --> 00:23:23,120
that this is not easy to compute even

747
00:23:21,760 --> 00:23:24,879
given the trapdoor

748
00:23:23,120 --> 00:23:26,320
so how how would you how would you find

749
00:23:24,880 --> 00:23:27,679
this bad challenge r

750
00:23:26,320 --> 00:23:29,678
so it's a linear equation in the

751
00:23:27,679 --> 00:23:30,880
exponent so what you could do is compute

752
00:23:29,679 --> 00:23:31,440
the coefficients and then solve the

753
00:23:30,880 --> 00:23:32,559
equation

754
00:23:31,440 --> 00:23:35,039
so to do that you need to do the

755
00:23:32,559 --> 00:23:37,120
following things you need to compute the

756
00:23:35,039 --> 00:23:39,520
order of the group which is this fee of

757
00:23:37,120 --> 00:23:41,279
n uh that's as hard as factoring in but

758
00:23:39,520 --> 00:23:43,279
this is not really a problem

759
00:23:41,279 --> 00:23:44,880
because if you have the factorization of

760
00:23:43,279 --> 00:23:46,720
n of the trap door then this is easy so

761
00:23:44,880 --> 00:23:48,559
that's fine

762
00:23:46,720 --> 00:23:49,600
uh we can then we then want to compute

763
00:23:48,559 --> 00:23:50,399
these coefficients of the linear

764
00:23:49,600 --> 00:23:52,959
equation

765
00:23:50,400 --> 00:23:54,960
so one of these is uh is easy to compute

766
00:23:52,960 --> 00:23:57,760
given again the factorization

767
00:23:54,960 --> 00:23:59,200
but we also need to compute these

768
00:23:57,760 --> 00:24:00,240
discrete logarithms the discrete

769
00:23:59,200 --> 00:24:03,760
logarithm

770
00:24:00,240 --> 00:24:04,960
of uh in particular the discrete

771
00:24:03,760 --> 00:24:08,320
logarithm of u

772
00:24:04,960 --> 00:24:10,720
in base g uh is an important one

773
00:24:08,320 --> 00:24:12,000
um and this seems very difficult u is

774
00:24:10,720 --> 00:24:13,679
something the prover produces you can't

775
00:24:12,000 --> 00:24:14,720
just pre-process this discrete logarithm

776
00:24:13,679 --> 00:24:17,520
away

777
00:24:14,720 --> 00:24:18,799
uh and moreover the factorization of n

778
00:24:17,520 --> 00:24:20,000
doesn't seem to help in computing this

779
00:24:18,799 --> 00:24:22,720
discrete logarithm at all

780
00:24:20,000 --> 00:24:24,480
like the problem of whether groups have

781
00:24:22,720 --> 00:24:25,919
trap doors for computing discrete log is

782
00:24:24,480 --> 00:24:28,720
well studied and we

783
00:24:25,919 --> 00:24:29,520
have no like there's no indication that

784
00:24:28,720 --> 00:24:31,600
this is the case

785
00:24:29,520 --> 00:24:35,200
it appears that discrete logarithms are

786
00:24:31,600 --> 00:24:38,320
hard given given track doors as well

787
00:24:35,200 --> 00:24:39,120
so this is bad uh we're we're currently

788
00:24:38,320 --> 00:24:40,879
stuck

789
00:24:39,120 --> 00:24:42,239
uh the the approach that i've described

790
00:24:40,880 --> 00:24:43,919
so far can't capture

791
00:24:42,240 --> 00:24:45,760
bad challenge functions which require

792
00:24:43,919 --> 00:24:47,600
computing discrete logarithms in hard

793
00:24:45,760 --> 00:24:50,320
discrete log groups

794
00:24:47,600 --> 00:24:51,760
and so our solution in this paper is

795
00:24:50,320 --> 00:24:53,200
that it might be the case that f is

796
00:24:51,760 --> 00:24:56,400
really hard to compute

797
00:24:53,200 --> 00:24:57,120
but we still get something if it's easy

798
00:24:56,400 --> 00:24:58,799
to compute

799
00:24:57,120 --> 00:25:00,399
with some small probability that is

800
00:24:58,799 --> 00:25:01,279
we're going to compute f via a

801
00:25:00,400 --> 00:25:03,679
randomized

802
00:25:01,279 --> 00:25:05,440
fast randomized algorithm that works

803
00:25:03,679 --> 00:25:08,880
with inverse sub-exponential

804
00:25:05,440 --> 00:25:11,120
non-trivial probability so it turns out

805
00:25:08,880 --> 00:25:12,720
that discrete logarithms can be computed

806
00:25:11,120 --> 00:25:14,479
efficiently in this model so i'm

807
00:25:12,720 --> 00:25:15,760
sweeping some details onto the rug

808
00:25:14,480 --> 00:25:17,039
but roughly but there's some

809
00:25:15,760 --> 00:25:17,600
pre-processing that also needs to be

810
00:25:17,039 --> 00:25:19,200
done

811
00:25:17,600 --> 00:25:21,520
but roughly speaking you can compute

812
00:25:19,200 --> 00:25:22,400
discrete logs in small sub-exponential

813
00:25:21,520 --> 00:25:24,240
time

814
00:25:22,400 --> 00:25:26,240
with large inverse of exponential

815
00:25:24,240 --> 00:25:27,600
probability uh and there are other

816
00:25:26,240 --> 00:25:29,120
trade-offs and each of these trade-offs

817
00:25:27,600 --> 00:25:29,840
ends up giving us a different theorem

818
00:25:29,120 --> 00:25:31,439
statement

819
00:25:29,840 --> 00:25:33,439
so this is just the standard index

820
00:25:31,440 --> 00:25:35,520
calculus algorithm but it's a

821
00:25:33,440 --> 00:25:36,880
with different parameter choices so

822
00:25:35,520 --> 00:25:39,200
that's you know the discrete log is not

823
00:25:36,880 --> 00:25:42,080
actually computed exactly

824
00:25:39,200 --> 00:25:43,679
um so so this is the fact that we're

825
00:25:42,080 --> 00:25:44,399
going to use to get a fiat chamier

826
00:25:43,679 --> 00:25:46,559
compiler

827
00:25:44,400 --> 00:25:48,799
and the idea is that if the hash

828
00:25:46,559 --> 00:25:50,000
function family is very quantitatively

829
00:25:48,799 --> 00:25:52,559
correlation interactable

830
00:25:50,000 --> 00:25:53,039
that is correlation and tractable even

831
00:25:52,559 --> 00:25:57,840
against

832
00:25:53,039 --> 00:25:57,840
small probability adversaries then

833
00:25:58,000 --> 00:26:03,600
that is if it's if it's if it's that ci

834
00:26:01,039 --> 00:26:04,320
for efficient functions then it should

835
00:26:03,600 --> 00:26:06,320
also be

836
00:26:04,320 --> 00:26:07,678
correlation intractable for inefficient

837
00:26:06,320 --> 00:26:10,158
functions that you can compute

838
00:26:07,679 --> 00:26:11,679
efficiently with small probability so

839
00:26:10,159 --> 00:26:13,039
this f in particular will get

840
00:26:11,679 --> 00:26:14,720
correlation and tractability for this f

841
00:26:13,039 --> 00:26:16,960
even though it's hard to compute

842
00:26:14,720 --> 00:26:18,400
uh by appealing to a sufficiently

843
00:26:16,960 --> 00:26:19,919
quantitatively strong form of

844
00:26:18,400 --> 00:26:21,919
correlation and tractability

845
00:26:19,919 --> 00:26:23,840
so this follows from a fairly simple

846
00:26:21,919 --> 00:26:25,440
lemma which says that if you're some

847
00:26:23,840 --> 00:26:26,959
epsilon correlation intractable for

848
00:26:25,440 --> 00:26:29,279
efficient functions

849
00:26:26,960 --> 00:26:30,720
and f is computable efficiently with

850
00:26:29,279 --> 00:26:32,240
probability epsilon

851
00:26:30,720 --> 00:26:34,320
then the hash family will also be

852
00:26:32,240 --> 00:26:36,240
correlation and tractable for f

853
00:26:34,320 --> 00:26:38,480
the reduction is there the proof is

854
00:26:36,240 --> 00:26:39,039
exactly as you would expect the point is

855
00:26:38,480 --> 00:26:40,559
that

856
00:26:39,039 --> 00:26:41,760
if you're breaking correlation and

857
00:26:40,559 --> 00:26:43,200
tractability for f then you'll also

858
00:26:41,760 --> 00:26:44,320
break correlation retractability for

859
00:26:43,200 --> 00:26:47,520
this efficient

860
00:26:44,320 --> 00:26:50,320
function g with some small probability

861
00:26:47,520 --> 00:26:51,279
so this idea is enough that this high

862
00:26:50,320 --> 00:26:52,720
level idea is enough

863
00:26:51,279 --> 00:26:54,320
in the end to get us the result we want

864
00:26:52,720 --> 00:26:55,600
so let me just sketch the overall

865
00:26:54,320 --> 00:26:57,439
analysis

866
00:26:55,600 --> 00:26:59,439
uh as i said before for each reduction

867
00:26:57,440 --> 00:27:02,400
step if the if the current

868
00:26:59,440 --> 00:27:04,799
claim is false then no matter what the

869
00:27:02,400 --> 00:27:08,320
prover sends as its next message

870
00:27:04,799 --> 00:27:10,158
there is at most one response r

871
00:27:08,320 --> 00:27:11,520
that that will make the next claim

872
00:27:10,159 --> 00:27:14,240
accidentally true

873
00:27:11,520 --> 00:27:16,240
so as long as we can avoid these then

874
00:27:14,240 --> 00:27:18,000
then we have soundness

875
00:27:16,240 --> 00:27:19,679
so this allows us to define a bad

876
00:27:18,000 --> 00:27:20,799
challenge function for this reduction

877
00:27:19,679 --> 00:27:22,080
step

878
00:27:20,799 --> 00:27:23,840
and if we have correlation and

879
00:27:22,080 --> 00:27:25,840
tractability for this function f then we

880
00:27:23,840 --> 00:27:28,639
get soundness of the whole protocol

881
00:27:25,840 --> 00:27:30,559
and by what what i just argued if you

882
00:27:28,640 --> 00:27:32,120
have a quantitatively stronger form of

883
00:27:30,559 --> 00:27:35,360
correlation and tractability for

884
00:27:32,120 --> 00:27:37,678
subexponentially efficient functions

885
00:27:35,360 --> 00:27:39,678
then you also get plane correlation and

886
00:27:37,679 --> 00:27:41,440
tractability for this function f

887
00:27:39,679 --> 00:27:43,200
which gives us soundness of the whole

888
00:27:41,440 --> 00:27:44,320
protocol so this is why we need to make

889
00:27:43,200 --> 00:27:46,960
a 2 to the

890
00:27:44,320 --> 00:27:48,080
minus lambda to the 0.99 say assumption

891
00:27:46,960 --> 00:27:49,919
about lwe

892
00:27:48,080 --> 00:27:51,678
in order to get a fiachimir compiler for

893
00:27:49,919 --> 00:27:54,559
this protocol

894
00:27:51,679 --> 00:27:55,600
so that's that's our main result uh let

895
00:27:54,559 --> 00:27:57,918
me just recap

896
00:27:55,600 --> 00:27:58,639
what we just saw so in this work we

897
00:27:57,919 --> 00:28:00,720
extend

898
00:27:58,640 --> 00:28:02,000
the bad challenge function paradigm for

899
00:28:00,720 --> 00:28:04,320
feature mirror

900
00:28:02,000 --> 00:28:06,159
to protocols that cannot be

901
00:28:04,320 --> 00:28:07,120
characterized by efficiently computable

902
00:28:06,159 --> 00:28:08,480
bad challenge functions they're

903
00:28:07,120 --> 00:28:09,360
characterized by challenge functions

904
00:28:08,480 --> 00:28:12,480
that are not

905
00:28:09,360 --> 00:28:13,760
efficient and the way we do it is by

906
00:28:12,480 --> 00:28:16,880
considering

907
00:28:13,760 --> 00:28:18,720
a model in which the

908
00:28:16,880 --> 00:28:20,080
bad challenge function is efficiently

909
00:28:18,720 --> 00:28:21,679
computable the model

910
00:28:20,080 --> 00:28:22,960
is you know that you only have to be

911
00:28:21,679 --> 00:28:24,720
able to compute the function with

912
00:28:22,960 --> 00:28:25,840
sub-exponential inverse sub-exponential

913
00:28:24,720 --> 00:28:28,640
probability

914
00:28:25,840 --> 00:28:29,279
and it turns out that this is that's a

915
00:28:28,640 --> 00:28:31,440
reasonable

916
00:28:29,279 --> 00:28:33,039
sub-exponential assumptions on the hash

917
00:28:31,440 --> 00:28:34,960
function are still enough to guarantee

918
00:28:33,039 --> 00:28:36,399
fiat amir soundness in this case

919
00:28:34,960 --> 00:28:38,320
and the punch line is that we get these

920
00:28:36,399 --> 00:28:39,439
two cool applications ppad hardness and

921
00:28:38,320 --> 00:28:40,559
verifiable delay function in the

922
00:28:39,440 --> 00:28:42,480
standard model

923
00:28:40,559 --> 00:28:44,240
from sub-exponential hardness of two

924
00:28:42,480 --> 00:28:46,559
well-studied problems

925
00:28:44,240 --> 00:28:47,679
uh so just you know one one takeaway

926
00:28:46,559 --> 00:28:48,158
that you might want to get from this

927
00:28:47,679 --> 00:28:50,480
paper

928
00:28:48,159 --> 00:28:51,360
is that you can now do feature mere for

929
00:28:50,480 --> 00:28:53,039
protocols

930
00:28:51,360 --> 00:28:54,719
that are characterized by bad challenge

931
00:28:53,039 --> 00:28:56,960
functions that are efficient

932
00:28:54,720 --> 00:28:58,080
modulo some discrete log computations

933
00:28:56,960 --> 00:29:00,000
that are of course inefficient

934
00:28:58,080 --> 00:29:01,439
and this says you can you can replace

935
00:29:00,000 --> 00:29:03,039
these computations by low success

936
00:29:01,440 --> 00:29:05,440
probability efficient algorithms and

937
00:29:03,039 --> 00:29:10,320
then argue future mere sounds

938
00:29:05,440 --> 00:29:10,320
thanks for listening

