1
00:00:00,399 --> 00:00:04,160
hello everyone and welcome to my talk on

2
00:00:02,399 --> 00:00:05,759
our paper shorter non-interactive zero

3
00:00:04,160 --> 00:00:07,040
knowledge arguments and zaps for

4
00:00:05,759 --> 00:00:08,639
algebraic languages

5
00:00:07,040 --> 00:00:11,120
my name is dominic hartmann and this is

6
00:00:08,639 --> 00:00:13,040
joint work with jeffrey couture

7
00:00:11,120 --> 00:00:14,959
so let me start by briefly recalling the

8
00:00:13,040 --> 00:00:16,799
setup for interactive proofs

9
00:00:14,960 --> 00:00:18,880
we have alice who wants to convince bob

10
00:00:16,800 --> 00:00:20,720
of a statement and alice knows witness

11
00:00:18,880 --> 00:00:23,038
but she doesn't want to reveal it so

12
00:00:20,720 --> 00:00:24,080
she requires a zero knowledge proof and

13
00:00:23,039 --> 00:00:26,240
there are two types of

14
00:00:24,080 --> 00:00:28,320
knowledge proofs first are interactive

15
00:00:26,240 --> 00:00:29,439
proofs which are often computationally

16
00:00:28,320 --> 00:00:32,000
very efficient

17
00:00:29,439 --> 00:00:33,680
and pretty well understood but they have

18
00:00:32,000 --> 00:00:35,200
the disadvantage that alice and bob have

19
00:00:33,680 --> 00:00:37,040
to exchange multiple messages

20
00:00:35,200 --> 00:00:39,360
so the latency between the messages is a

21
00:00:37,040 --> 00:00:41,360
major drawback and both parties have to

22
00:00:39,360 --> 00:00:43,600
be present throughout the whole protocol

23
00:00:41,360 --> 00:00:45,840
because these protocols generally aren't

24
00:00:43,600 --> 00:00:47,520
transferable so only if the other party

25
00:00:45,840 --> 00:00:49,840
is present during the protocol

26
00:00:47,520 --> 00:00:51,039
it actually believes the proof so in

27
00:00:49,840 --> 00:00:54,000
many cases we want

28
00:00:51,039 --> 00:00:54,800
non-interactive zero knowledge protocols

29
00:00:54,000 --> 00:00:57,680
where alice

30
00:00:54,800 --> 00:00:58,000
simply sends a single message a single

31
00:00:57,680 --> 00:01:00,399
proof

32
00:00:58,000 --> 00:01:02,000
pie and bob is convinced even if he sees

33
00:01:00,399 --> 00:01:03,440
the proof later

34
00:01:02,000 --> 00:01:05,438
the drawback of these protocols of

35
00:01:03,440 --> 00:01:06,240
course is that they don't exist in the

36
00:01:05,438 --> 00:01:08,158
plane model

37
00:01:06,240 --> 00:01:09,439
so we require some trusted setup like a

38
00:01:08,159 --> 00:01:11,600
common reference string

39
00:01:09,439 --> 00:01:13,439
or the random oracle model and they are

40
00:01:11,600 --> 00:01:15,039
often computationally way more expensive

41
00:01:13,439 --> 00:01:17,758
than interactive protocols

42
00:01:15,040 --> 00:01:18,400
but since interactive protocols can't be

43
00:01:17,759 --> 00:01:21,040
used in

44
00:01:18,400 --> 00:01:22,159
all applications for example in voting

45
00:01:21,040 --> 00:01:24,000
they are not feasible

46
00:01:22,159 --> 00:01:25,840
we often require non-interactive zero

47
00:01:24,000 --> 00:01:26,400
knowledge and we will focus on that in

48
00:01:25,840 --> 00:01:30,159
this

49
00:01:26,400 --> 00:01:31,759
paper so what are existing music

50
00:01:30,159 --> 00:01:33,520
constructions and why do we need another

51
00:01:31,759 --> 00:01:35,280
one well first there were

52
00:01:33,520 --> 00:01:37,119
results that showed that non-interactive

53
00:01:35,280 --> 00:01:39,439
zero knowledge exists for all of np

54
00:01:37,119 --> 00:01:41,600
however these generic constructions

55
00:01:39,439 --> 00:01:43,199
use expensive np reductions and don't

56
00:01:41,600 --> 00:01:46,000
yield efficient zero knowledge

57
00:01:43,200 --> 00:01:47,040
so we want to recap some efficient

58
00:01:46,000 --> 00:01:48,479
constructions

59
00:01:47,040 --> 00:01:51,280
and the first one was the so-called

60
00:01:48,479 --> 00:01:53,600
viejameer transformation from 87

61
00:01:51,280 --> 00:01:55,439
which compiles a sigma protocol into

62
00:01:53,600 --> 00:01:57,199
inizik using a hash function which is

63
00:01:55,439 --> 00:01:59,039
modeled as a random oracle

64
00:01:57,200 --> 00:02:00,719
and this yields very efficient

65
00:01:59,040 --> 00:02:02,159
non-interactive protocols almost as

66
00:02:00,719 --> 00:02:03,199
efficient as the underlying sigma

67
00:02:02,159 --> 00:02:06,880
protocol

68
00:02:03,200 --> 00:02:08,560
and security can be reduced to the

69
00:02:06,880 --> 00:02:10,878
properties of the underlying sigma

70
00:02:08,560 --> 00:02:13,040
protocol and since we can

71
00:02:10,878 --> 00:02:14,959
compile all public coin constant round

72
00:02:13,040 --> 00:02:17,519
protocols we can prove

73
00:02:14,959 --> 00:02:19,200
all statements over np however as i said

74
00:02:17,520 --> 00:02:20,160
the hash function has to be modeled as a

75
00:02:19,200 --> 00:02:23,200
random oracle

76
00:02:20,160 --> 00:02:24,319
in order to get a security proof so in

77
00:02:23,200 --> 00:02:27,119
the standard model

78
00:02:24,319 --> 00:02:29,040
this security is in a way heuristic so

79
00:02:27,120 --> 00:02:30,800
we would like to avoid this

80
00:02:29,040 --> 00:02:33,679
the first construction without random

81
00:02:30,800 --> 00:02:36,239
oracles was due to growth and so high

82
00:02:33,680 --> 00:02:37,599
which allows us to prove statements over

83
00:02:36,239 --> 00:02:39,519
pairing product equations

84
00:02:37,599 --> 00:02:41,839
and it is secure in the standard model

85
00:02:39,519 --> 00:02:43,599
under the ssdh assumption and also

86
00:02:41,840 --> 00:02:45,360
yields adaptive soundness

87
00:02:43,599 --> 00:02:47,440
however the efficiency is much worse

88
00:02:45,360 --> 00:02:49,599
than that of the vrmy transformation

89
00:02:47,440 --> 00:02:51,519
although still very much usable and it

90
00:02:49,599 --> 00:02:52,720
is widely used and was extended in many

91
00:02:51,519 --> 00:02:55,840
follow-up papers

92
00:02:52,720 --> 00:02:58,080
and is the i think the most used zero

93
00:02:55,840 --> 00:03:00,400
knowledge framework to date

94
00:02:58,080 --> 00:03:02,000
another line of work is on the so-called

95
00:03:00,400 --> 00:03:03,920
quasi-adaptive phenix

96
00:03:02,000 --> 00:03:05,360
which for linear languages culminated in

97
00:03:03,920 --> 00:03:08,159
the work of kills and we

98
00:03:05,360 --> 00:03:09,200
which gave constant size proofs for

99
00:03:08,159 --> 00:03:10,720
linear languages

100
00:03:09,200 --> 00:03:12,720
in the standard model under the standard

101
00:03:10,720 --> 00:03:15,040
kernel matrix if you have an assumption

102
00:03:12,720 --> 00:03:16,720
but as i said only in a quasi-adaptive

103
00:03:15,040 --> 00:03:17,679
sense so the common reference string

104
00:03:16,720 --> 00:03:20,800
they use

105
00:03:17,680 --> 00:03:22,800
may depend on the language and their

106
00:03:20,800 --> 00:03:24,000
approach only works for linear languages

107
00:03:22,800 --> 00:03:25,920
so a much

108
00:03:24,000 --> 00:03:28,319
smaller class than pairing product

109
00:03:25,920 --> 00:03:30,559
equations or even np

110
00:03:28,319 --> 00:03:32,238
so why do we need another framework for

111
00:03:30,560 --> 00:03:34,640
non-interactive zero knowledge

112
00:03:32,239 --> 00:03:36,400
as you can see all constructions that we

113
00:03:34,640 --> 00:03:36,720
showed here have some kind of drawback

114
00:03:36,400 --> 00:03:38,239
the

115
00:03:36,720 --> 00:03:40,000
mirror transformation requires the

116
00:03:38,239 --> 00:03:42,239
random oracle model in the proof

117
00:03:40,000 --> 00:03:43,360
grosser high proofs are quite

118
00:03:42,239 --> 00:03:45,519
inefficient compared

119
00:03:43,360 --> 00:03:46,959
to fiat chamier and the kills we proves

120
00:03:45,519 --> 00:03:48,959
although very efficient

121
00:03:46,959 --> 00:03:50,879
only work for linear languages and only

122
00:03:48,959 --> 00:03:52,720
with quasi-adaptive soundness

123
00:03:50,879 --> 00:03:54,000
so the question was can we find

124
00:03:52,720 --> 00:03:55,599
something which is

125
00:03:54,000 --> 00:03:57,439
as efficient as the fiatumu

126
00:03:55,599 --> 00:03:58,079
transformation secured in the standard

127
00:03:57,439 --> 00:04:00,560
model

128
00:03:58,080 --> 00:04:02,239
so does not require random oracles under

129
00:04:00,560 --> 00:04:03,680
some standard assumption with adaptive

130
00:04:02,239 --> 00:04:04,319
soundness for a larger class of

131
00:04:03,680 --> 00:04:06,640
languages

132
00:04:04,319 --> 00:04:08,640
than linear languages and the answer is

133
00:04:06,640 --> 00:04:10,879
partially yes

134
00:04:08,640 --> 00:04:12,839
in this work we present a new compiler

135
00:04:10,879 --> 00:04:14,640
for interactive protocols namely sigma

136
00:04:12,840 --> 00:04:16,639
protocols two

137
00:04:14,640 --> 00:04:18,399
non-interactive zero knowledge arguments

138
00:04:16,639 --> 00:04:19,519
that does not require random oracles in

139
00:04:18,399 --> 00:04:21,519
the security proof

140
00:04:19,519 --> 00:04:23,040
has almost as good efficiency as the

141
00:04:21,519 --> 00:04:24,720
fierce mere transformation

142
00:04:23,040 --> 00:04:26,479
adaptive soundness and works for the

143
00:04:24,720 --> 00:04:29,199
class of algebraic languages

144
00:04:26,479 --> 00:04:29,758
which is considerably considerably

145
00:04:29,199 --> 00:04:31,840
bigger

146
00:04:29,759 --> 00:04:32,960
than class of linear languages and is

147
00:04:31,840 --> 00:04:34,719
secure under

148
00:04:32,960 --> 00:04:36,479
a new assumption which we call the

149
00:04:34,720 --> 00:04:37,280
extended kernel matrix diffie-hellman

150
00:04:36,479 --> 00:04:39,919
assumption

151
00:04:37,280 --> 00:04:41,520
which is a natural extension of the

152
00:04:39,919 --> 00:04:43,599
regular kernel matrix different

153
00:04:41,520 --> 00:04:46,799
assumption

154
00:04:43,600 --> 00:04:48,960
so what is the idea of our compiler as i

155
00:04:46,800 --> 00:04:50,960
said we start with a sigma protocol and

156
00:04:48,960 --> 00:04:53,039
want to compile it into a nisik

157
00:04:50,960 --> 00:04:54,000
so this is a sigma protocol over an

158
00:04:53,040 --> 00:04:56,400
abelian group

159
00:04:54,000 --> 00:04:57,919
we have a word which is a group element

160
00:04:56,400 --> 00:05:00,719
vector and the witness is

161
00:04:57,919 --> 00:05:02,000
a zp vector the first flow is a group

162
00:05:00,720 --> 00:05:04,240
vector as well

163
00:05:02,000 --> 00:05:06,080
the challenge from the verifier is just

164
00:05:04,240 --> 00:05:09,280
a random cp element

165
00:05:06,080 --> 00:05:10,159
and the response is a zp vector and now

166
00:05:09,280 --> 00:05:11,758
we want to compile

167
00:05:10,160 --> 00:05:13,840
this into a non-interactive zero

168
00:05:11,759 --> 00:05:16,080
knowledge argument

169
00:05:13,840 --> 00:05:18,000
so we somehow have to eliminate this one

170
00:05:16,080 --> 00:05:19,039
flow from from the verifier to the

171
00:05:18,000 --> 00:05:21,199
prover

172
00:05:19,039 --> 00:05:22,080
and the most simple way would be okay we

173
00:05:21,199 --> 00:05:24,320
simply choose

174
00:05:22,080 --> 00:05:25,840
e as the common reference string and

175
00:05:24,320 --> 00:05:28,560
both parties have access to it

176
00:05:25,840 --> 00:05:29,198
and can simply non-interactively compute

177
00:05:28,560 --> 00:05:32,400
the proof

178
00:05:29,199 --> 00:05:34,560
and also verify it however this

179
00:05:32,400 --> 00:05:36,400
sadly doesn't work since it breaks the

180
00:05:34,560 --> 00:05:39,759
soundness of the protocol

181
00:05:36,400 --> 00:05:41,758
because the property of a sigma protocol

182
00:05:39,759 --> 00:05:43,280
one of them is the special honest

183
00:05:41,759 --> 00:05:45,840
verifier zero knowledge with

184
00:05:43,280 --> 00:05:47,520
which says that if we know the challenge

185
00:05:45,840 --> 00:05:47,919
and the statement which does not need to

186
00:05:47,520 --> 00:05:50,080
be

187
00:05:47,919 --> 00:05:52,000
in the language then there is a

188
00:05:50,080 --> 00:05:53,199
simulator which produces an accepting

189
00:05:52,000 --> 00:05:56,240
transcript so an a

190
00:05:53,199 --> 00:05:58,400
and a d which is accepting even though

191
00:05:56,240 --> 00:05:59,680
x is not a language so we can't make it

192
00:05:58,400 --> 00:06:03,120
as easy as simply

193
00:05:59,680 --> 00:06:05,520
giving e to the prover in advance

194
00:06:03,120 --> 00:06:07,360
however we somehow have to eliminate it

195
00:06:05,520 --> 00:06:08,000
and this is where our core idea comes

196
00:06:07,360 --> 00:06:11,120
from

197
00:06:08,000 --> 00:06:12,000
and instead of giving e in the clear we

198
00:06:11,120 --> 00:06:14,240
simply give it

199
00:06:12,000 --> 00:06:15,360
to a different group so instead of

200
00:06:14,240 --> 00:06:17,600
giving esd

201
00:06:15,360 --> 00:06:20,000
crs we give g2 to the e for some

202
00:06:17,600 --> 00:06:24,000
generator g2 of a group

203
00:06:20,000 --> 00:06:27,280
now x is in a different group than e

204
00:06:24,000 --> 00:06:28,160
and if the two groups have an asymmetric

205
00:06:27,280 --> 00:06:30,719
pairing

206
00:06:28,160 --> 00:06:32,880
then verification still is possible

207
00:06:30,720 --> 00:06:35,280
since most sigma protocols

208
00:06:32,880 --> 00:06:37,520
have a linear verification equation and

209
00:06:35,280 --> 00:06:38,799
all the protocols that we consider will

210
00:06:37,520 --> 00:06:41,039
have such an equation

211
00:06:38,800 --> 00:06:42,000
so correctness in this compiled protocol

212
00:06:41,039 --> 00:06:45,199
simply holds

213
00:06:42,000 --> 00:06:47,039
due to a pairing of course the

214
00:06:45,199 --> 00:06:48,319
second flow of the prover now also has

215
00:06:47,039 --> 00:06:49,919
to be in group g2

216
00:06:48,319 --> 00:06:51,520
since it depends on the challenge which

217
00:06:49,919 --> 00:06:55,120
is now only

218
00:06:51,520 --> 00:06:56,560
present in group g2 as well we can also

219
00:06:55,120 --> 00:06:58,080
easily see that this

220
00:06:56,560 --> 00:07:00,479
construction is zero knowledge because

221
00:06:58,080 --> 00:07:03,359
as i said if the prover had

222
00:07:00,479 --> 00:07:03,680
e in the clear it could simply compute a

223
00:07:03,360 --> 00:07:05,440
and d

224
00:07:03,680 --> 00:07:07,199
without knowing witness so this is

225
00:07:05,440 --> 00:07:11,039
exactly a simulation trapdoor

226
00:07:07,199 --> 00:07:14,560
now if we give the simulator e he can

227
00:07:11,039 --> 00:07:15,919
he can use the special honest verifier

228
00:07:14,560 --> 00:07:16,800
simulator of the underlying signal

229
00:07:15,919 --> 00:07:19,280
protocol

230
00:07:16,800 --> 00:07:20,880
and the proof is convincing the two

231
00:07:19,280 --> 00:07:23,198
interesting questions here are whether

232
00:07:20,880 --> 00:07:24,639
this construction is sound and if so for

233
00:07:23,199 --> 00:07:27,440
which languages

234
00:07:24,639 --> 00:07:29,280
and since the compiler itself is really

235
00:07:27,440 --> 00:07:31,120
simple those two questions are the main

236
00:07:29,280 --> 00:07:33,280
contribution of our work

237
00:07:31,120 --> 00:07:34,160
and as i told you in the beginning it

238
00:07:33,280 --> 00:07:36,479
will work for

239
00:07:34,160 --> 00:07:37,680
the so-called algebraic languages and

240
00:07:36,479 --> 00:07:39,599
sounds will hold

241
00:07:37,680 --> 00:07:41,199
relative to our new extended kernel

242
00:07:39,599 --> 00:07:42,719
matrix difficult assumption

243
00:07:41,199 --> 00:07:44,319
but before i get into the specifics let

244
00:07:42,720 --> 00:07:46,800
me give you a brief intuition

245
00:07:44,319 --> 00:07:49,919
on why soundness should hold and why and

246
00:07:46,800 --> 00:07:51,360
not for more than algebraic languages

247
00:07:49,919 --> 00:07:53,120
the intuition for soundness is as

248
00:07:51,360 --> 00:07:56,560
follows we have e

249
00:07:53,120 --> 00:07:59,680
in group g2 but we have to compute

250
00:07:56,560 --> 00:08:02,400
a vector a in group g1 which

251
00:07:59,680 --> 00:08:03,919
has a non-trivial relation to this e

252
00:08:02,400 --> 00:08:05,280
because this is exactly what normally

253
00:08:03,919 --> 00:08:06,960
the special honors verifier zero

254
00:08:05,280 --> 00:08:09,039
knowledge simulator would do

255
00:08:06,960 --> 00:08:10,159
because for x not in the language there

256
00:08:09,039 --> 00:08:13,919
simply isn't that

257
00:08:10,160 --> 00:08:16,160
aren't that many options for choosing a

258
00:08:13,919 --> 00:08:17,919
but since we have the one thing namely

259
00:08:16,160 --> 00:08:18,639
the challenge in group g2 but have to

260
00:08:17,919 --> 00:08:21,039
compute a

261
00:08:18,639 --> 00:08:22,800
in group g1 this should be hard because

262
00:08:21,039 --> 00:08:23,919
there should not be too much connection

263
00:08:22,800 --> 00:08:25,599
between the two groups

264
00:08:23,919 --> 00:08:27,039
other than the pairing but that only

265
00:08:25,599 --> 00:08:28,960
gives us group elements in

266
00:08:27,039 --> 00:08:30,240
the target group which also shouldn't

267
00:08:28,960 --> 00:08:33,519
help us find something

268
00:08:30,240 --> 00:08:35,599
in group g1 and this is also

269
00:08:33,519 --> 00:08:37,200
where the restriction to algebraic

270
00:08:35,599 --> 00:08:39,440
languages come from because algebraic

271
00:08:37,200 --> 00:08:40,959
languages only live over a single group

272
00:08:39,440 --> 00:08:42,320
however if we would have something like

273
00:08:40,958 --> 00:08:44,959
pairing product equations

274
00:08:42,320 --> 00:08:45,920
where the language is over group g1 and

275
00:08:44,959 --> 00:08:48,079
g2

276
00:08:45,920 --> 00:08:49,599
then this split between the challenge

277
00:08:48,080 --> 00:08:51,839
being hidden in one group

278
00:08:49,600 --> 00:08:53,279
and the first flow which is in the same

279
00:08:51,839 --> 00:08:55,200
group as the statement

280
00:08:53,279 --> 00:08:56,800
being in group g1 simply doesn't hold

281
00:08:55,200 --> 00:08:59,200
anymore because now

282
00:08:56,800 --> 00:09:00,479
this first flow is in group g1 and g2 or

283
00:08:59,200 --> 00:09:02,959
even in group gt

284
00:09:00,480 --> 00:09:03,519
and then this whole divide between

285
00:09:02,959 --> 00:09:06,000
challenge

286
00:09:03,519 --> 00:09:07,040
and commitment doesn't hold anymore and

287
00:09:06,000 --> 00:09:10,160
we don't know how to

288
00:09:07,040 --> 00:09:12,480
show soundness so that's it for

289
00:09:10,160 --> 00:09:14,399
intuition now let's get more into the

290
00:09:12,480 --> 00:09:16,320
technical details and for that i'll

291
00:09:14,399 --> 00:09:18,399
start with some notation

292
00:09:16,320 --> 00:09:20,240
as i said we'll be using asymmetric

293
00:09:18,399 --> 00:09:23,440
pairing groups so we have three groups

294
00:09:20,240 --> 00:09:25,600
g1 g2 and gt with respective generators

295
00:09:23,440 --> 00:09:27,440
and instead of writing gi to the x i'll

296
00:09:25,600 --> 00:09:30,080
use implicit notation and write x in

297
00:09:27,440 --> 00:09:31,839
brackets with subscript i

298
00:09:30,080 --> 00:09:33,680
vectors will be lowercase both front

299
00:09:31,839 --> 00:09:34,800
ladders and matrices will be uppercase

300
00:09:33,680 --> 00:09:36,800
bold from letters

301
00:09:34,800 --> 00:09:37,839
and pairings will be denoted by this dot

302
00:09:36,800 --> 00:09:40,479
and of course

303
00:09:37,839 --> 00:09:41,440
pairings and implicit notation directly

304
00:09:40,480 --> 00:09:43,920
translates

305
00:09:41,440 --> 00:09:45,279
to vectors and matrices so a matrix

306
00:09:43,920 --> 00:09:47,439
vector product in the

307
00:09:45,279 --> 00:09:49,839
appropriate groups can be expressed via

308
00:09:47,440 --> 00:09:51,839
pairings

309
00:09:49,839 --> 00:09:53,600
let's start with defining what algebraic

310
00:09:51,839 --> 00:09:56,000
languages actually are

311
00:09:53,600 --> 00:09:57,680
and an intuition is that these are the

312
00:09:56,000 --> 00:09:58,560
languages described by polynomial

313
00:09:57,680 --> 00:10:00,880
relationships

314
00:09:58,560 --> 00:10:02,880
between exponents in an abelian group so

315
00:10:00,880 --> 00:10:04,079
for example algamal encryptions of a bit

316
00:10:02,880 --> 00:10:06,240
are an algebraic language

317
00:10:04,079 --> 00:10:07,760
but also the square divi helmet language

318
00:10:06,240 --> 00:10:10,079
so whether

319
00:10:07,760 --> 00:10:11,360
we have g g to the x and g to the x

320
00:10:10,079 --> 00:10:13,680
squared or g

321
00:10:11,360 --> 00:10:14,720
g to the x and g to the z for some

322
00:10:13,680 --> 00:10:18,079
random

323
00:10:14,720 --> 00:10:18,880
z and formally these languages can be

324
00:10:18,079 --> 00:10:20,959
described by

325
00:10:18,880 --> 00:10:22,079
a language matrix function and a target

326
00:10:20,959 --> 00:10:24,800
vector function

327
00:10:22,079 --> 00:10:27,680
which both take the word as input and

328
00:10:24,800 --> 00:10:30,000
then output a matrix and a target vector

329
00:10:27,680 --> 00:10:31,120
and a word is in the language if its

330
00:10:30,000 --> 00:10:33,600
target vector

331
00:10:31,120 --> 00:10:34,320
is in the image of its language matrix

332
00:10:33,600 --> 00:10:36,160
so

333
00:10:34,320 --> 00:10:37,600
this already looks very similar to

334
00:10:36,160 --> 00:10:41,120
linear languages

335
00:10:37,600 --> 00:10:43,680
and exactly linear languages are

336
00:10:41,120 --> 00:10:45,440
a subset of these algebraic languages if

337
00:10:43,680 --> 00:10:47,359
we simply set the language matrix

338
00:10:45,440 --> 00:10:49,680
function as a constant matrix

339
00:10:47,360 --> 00:10:51,519
and the target vector as the identity

340
00:10:49,680 --> 00:10:53,920
function

341
00:10:51,519 --> 00:10:54,720
so we can already see that this is more

342
00:10:53,920 --> 00:10:57,199
versatile

343
00:10:54,720 --> 00:10:58,640
than linear languages and indeed it has

344
00:10:57,200 --> 00:11:00,320
the nice property that algebraic

345
00:10:58,640 --> 00:11:01,360
languages are closed under conjunction

346
00:11:00,320 --> 00:11:03,040
at this junction

347
00:11:01,360 --> 00:11:04,640
so the disjunction of two algebraic

348
00:11:03,040 --> 00:11:05,839
languages is in itself again an

349
00:11:04,640 --> 00:11:09,600
algebraic language

350
00:11:05,839 --> 00:11:11,680
so we get or proofs basically for free

351
00:11:09,600 --> 00:11:13,360
another property that we can define for

352
00:11:11,680 --> 00:11:14,800
algebraic languages is the so-called

353
00:11:13,360 --> 00:11:17,279
witness sample ability

354
00:11:14,800 --> 00:11:19,120
which means that this language matrix

355
00:11:17,279 --> 00:11:19,839
function can be sampled together with a

356
00:11:19,120 --> 00:11:21,200
track door

357
00:11:19,839 --> 00:11:23,519
which allows us to check language

358
00:11:21,200 --> 00:11:24,560
membership this property originally

359
00:11:23,519 --> 00:11:26,480
comes from

360
00:11:24,560 --> 00:11:28,959
linear languages where this language

361
00:11:26,480 --> 00:11:31,120
trapdoor is simply

362
00:11:28,959 --> 00:11:32,160
a vector in the kernel of the language

363
00:11:31,120 --> 00:11:35,360
matrix so

364
00:11:32,160 --> 00:11:37,439
if we multiply a potential

365
00:11:35,360 --> 00:11:39,440
element in the language with this kernel

366
00:11:37,440 --> 00:11:40,240
vector it is cancelled and if it is not

367
00:11:39,440 --> 00:11:42,640
in the language

368
00:11:40,240 --> 00:11:44,000
then it is a non-zero vector so it

369
00:11:42,640 --> 00:11:44,880
indeed allows us to check language

370
00:11:44,000 --> 00:11:47,360
membership

371
00:11:44,880 --> 00:11:48,160
however for algebraic languages it won't

372
00:11:47,360 --> 00:11:50,160
be as

373
00:11:48,160 --> 00:11:52,639
clear what this trapdoor exactly is

374
00:11:50,160 --> 00:11:55,439
because such a vector in the kernel

375
00:11:52,639 --> 00:11:56,000
of the language matrix for every x

376
00:11:55,440 --> 00:11:58,000
generally

377
00:11:56,000 --> 00:11:59,360
simply won't exist or won't be

378
00:11:58,000 --> 00:12:02,560
computable

379
00:11:59,360 --> 00:12:03,839
so we can't define it exactly the same

380
00:12:02,560 --> 00:12:05,439
as for linear languages but in the

381
00:12:03,839 --> 00:12:09,440
spirit it is the same

382
00:12:05,440 --> 00:12:11,360
and can be reasonably defined

383
00:12:09,440 --> 00:12:13,360
and an example for a witness samplable

384
00:12:11,360 --> 00:12:14,720
algebraic languages would indeed be the

385
00:12:13,360 --> 00:12:17,600
algamal encryption

386
00:12:14,720 --> 00:12:18,880
of a bit where simply the public the

387
00:12:17,600 --> 00:12:22,000
secret key sorry

388
00:12:18,880 --> 00:12:23,279
would be exactly this trapdoor and

389
00:12:22,000 --> 00:12:26,320
allowed us to check it

390
00:12:23,279 --> 00:12:28,240
however for square feminine languages

391
00:12:26,320 --> 00:12:30,480
it isn't clear what this trap door would

392
00:12:28,240 --> 00:12:32,480
exactly be especially if it has to be

393
00:12:30,480 --> 00:12:34,000
word independent because how can we

394
00:12:32,480 --> 00:12:36,639
check whether we have

395
00:12:34,000 --> 00:12:37,680
a square triple or not so not all

396
00:12:36,639 --> 00:12:39,279
algebraic languages

397
00:12:37,680 --> 00:12:42,479
are witness assemblable but many

398
00:12:39,279 --> 00:12:44,480
interesting ones actually are

399
00:12:42,480 --> 00:12:46,399
and to make it explicit once more as i

400
00:12:44,480 --> 00:12:48,800
already told you linear languages are a

401
00:12:46,399 --> 00:12:50,959
real subset of algebraic languages

402
00:12:48,800 --> 00:12:52,560
which themselves are a subset of pairing

403
00:12:50,959 --> 00:12:54,638
product equations

404
00:12:52,560 --> 00:12:56,319
which we can prove with grosser high

405
00:12:54,639 --> 00:12:58,000
because as you can see

406
00:12:56,320 --> 00:12:59,600
algebraic languages are only defined

407
00:12:58,000 --> 00:13:02,720
over a single group

408
00:12:59,600 --> 00:13:04,560
while pairing product equations span all

409
00:13:02,720 --> 00:13:06,800
three groups of an asymmetric pairing

410
00:13:04,560 --> 00:13:10,000
so of course they are more versatile

411
00:13:06,800 --> 00:13:12,240
than what we have here

412
00:13:10,000 --> 00:13:14,000
okay so we want to apply our compiler to

413
00:13:12,240 --> 00:13:16,320
algebraic languages and for that we need

414
00:13:14,000 --> 00:13:18,959
a sigma protocol for algebraic languages

415
00:13:16,320 --> 00:13:20,880
and this we get by instantiating the

416
00:13:18,959 --> 00:13:22,479
framework of maura

417
00:13:20,880 --> 00:13:24,079
and the resulting sigma protocol looks

418
00:13:22,480 --> 00:13:26,399
as follows the prover

419
00:13:24,079 --> 00:13:28,000
starts with a random image under the

420
00:13:26,399 --> 00:13:31,040
language matrix for the word he

421
00:13:28,000 --> 00:13:33,760
wants to prove a statement over gets a

422
00:13:31,040 --> 00:13:35,680
random zp element as a challenge and its

423
00:13:33,760 --> 00:13:38,720
response is the scaled

424
00:13:35,680 --> 00:13:39,839
witness blinded by the randomness used

425
00:13:38,720 --> 00:13:41,279
in the first step

426
00:13:39,839 --> 00:13:42,959
and you can see the verification

427
00:13:41,279 --> 00:13:43,839
equation is indeed linear in the

428
00:13:42,959 --> 00:13:46,399
challenge

429
00:13:43,839 --> 00:13:48,160
so simply by replacing the regular

430
00:13:46,399 --> 00:13:49,279
multiplication with pairings we can

431
00:13:48,160 --> 00:13:52,000
still verify

432
00:13:49,279 --> 00:13:54,560
and this is exactly what we do we move e

433
00:13:52,000 --> 00:13:56,959
in group g2 to the crs

434
00:13:54,560 --> 00:13:58,079
d is now also in group g2 and all the

435
00:13:56,959 --> 00:14:01,439
regular multiplication

436
00:13:58,079 --> 00:14:03,760
is now replaced by pairings

437
00:14:01,440 --> 00:14:04,880
and you can see easily that correctness

438
00:14:03,760 --> 00:14:06,800
holds and

439
00:14:04,880 --> 00:14:08,720
as i told you before if we give our

440
00:14:06,800 --> 00:14:11,439
simulator e

441
00:14:08,720 --> 00:14:12,160
in zp and not in g2 as a simulation

442
00:14:11,440 --> 00:14:13,920
trapdoor

443
00:14:12,160 --> 00:14:15,839
we can use the underlying special honest

444
00:14:13,920 --> 00:14:19,120
verifier simulator

445
00:14:15,839 --> 00:14:20,880
to show zero knowledge the

446
00:14:19,120 --> 00:14:22,480
open question is how can we prove

447
00:14:20,880 --> 00:14:24,800
soundness and for that

448
00:14:22,480 --> 00:14:25,600
as i already told you we want to exploit

449
00:14:24,800 --> 00:14:27,519
that e

450
00:14:25,600 --> 00:14:28,800
and a have to have a non-trivial

451
00:14:27,519 --> 00:14:31,839
relationship

452
00:14:28,800 --> 00:14:34,000
and reduce this to a new assumption

453
00:14:31,839 --> 00:14:35,519
and this new assumption is the so-called

454
00:14:34,000 --> 00:14:36,320
extended kernel matrix diffie-hellman

455
00:14:35,519 --> 00:14:37,760
assumption

456
00:14:36,320 --> 00:14:39,199
which as the name implies is an

457
00:14:37,760 --> 00:14:40,720
extension of the kernel matrix

458
00:14:39,199 --> 00:14:43,199
diffie-hellman assumption

459
00:14:40,720 --> 00:14:44,959
so next i'll show you what this kernel

460
00:14:43,199 --> 00:14:46,479
matrix if you have an assumption is

461
00:14:44,959 --> 00:14:48,000
why it is insufficient to prove

462
00:14:46,480 --> 00:14:50,480
soundness in this case

463
00:14:48,000 --> 00:14:51,519
and then show you our extension and why

464
00:14:50,480 --> 00:14:54,160
this is actually

465
00:14:51,519 --> 00:14:55,440
sufficient to show soundness but first

466
00:14:54,160 --> 00:14:57,600
since you now know what algebraic

467
00:14:55,440 --> 00:14:59,199
languages are and already know the name

468
00:14:57,600 --> 00:15:01,360
of the assumption

469
00:14:59,199 --> 00:15:02,560
i can show you the main theorem of our

470
00:15:01,360 --> 00:15:05,120
paper

471
00:15:02,560 --> 00:15:06,479
and this is as follows if we have a

472
00:15:05,120 --> 00:15:08,480
language matrix function

473
00:15:06,480 --> 00:15:10,880
m and a target vector function teta

474
00:15:08,480 --> 00:15:12,399
which describe an algebraic language

475
00:15:10,880 --> 00:15:14,320
and we have pairing groups then the

476
00:15:12,399 --> 00:15:14,800
compiled sigma protocol from the slide

477
00:15:14,320 --> 00:15:16,240
before

478
00:15:14,800 --> 00:15:18,160
is indeed a non-interactive zero

479
00:15:16,240 --> 00:15:20,480
knowledge argument for the language

480
00:15:18,160 --> 00:15:21,279
namely it is perfectly correct perfectly

481
00:15:20,480 --> 00:15:22,959
zero knowledge

482
00:15:21,279 --> 00:15:24,480
and if the extended kernel matrix

483
00:15:22,959 --> 00:15:26,479
diffie-hellman assumption holds

484
00:15:24,480 --> 00:15:29,519
relative to the pairing groups then the

485
00:15:26,480 --> 00:15:31,120
protocol is also computationally sound

486
00:15:29,519 --> 00:15:33,199
so let's get to the kernel matrix

487
00:15:31,120 --> 00:15:34,959
different helm assumption

488
00:15:33,199 --> 00:15:36,639
it was introduced by modular force and

489
00:15:34,959 --> 00:15:38,719
villa and it is pretty simple

490
00:15:36,639 --> 00:15:40,880
the adversary gets as a challenge a

491
00:15:38,720 --> 00:15:42,079
matrix d from some matrix distribution

492
00:15:40,880 --> 00:15:44,079
in group g2

493
00:15:42,079 --> 00:15:45,120
and has to answer with a vector c in

494
00:15:44,079 --> 00:15:47,120
group g1

495
00:15:45,120 --> 00:15:49,040
which has to be in the left kernel of

496
00:15:47,120 --> 00:15:51,360
this matrix

497
00:15:49,040 --> 00:15:52,399
and this is already in a similar flavor

498
00:15:51,360 --> 00:15:54,560
to what i told you

499
00:15:52,399 --> 00:15:55,839
is what we need we want the adversary to

500
00:15:54,560 --> 00:15:57,758
give us something

501
00:15:55,839 --> 00:16:00,000
in the opposite group of the challenge

502
00:15:57,759 --> 00:16:01,360
with a non-trivial relation to this

503
00:16:00,000 --> 00:16:03,759
challenge

504
00:16:01,360 --> 00:16:04,959
and as it turns out this kernel matrix

505
00:16:03,759 --> 00:16:07,040
if you haven't assumption

506
00:16:04,959 --> 00:16:08,880
is already sufficient to prove soundness

507
00:16:07,040 --> 00:16:11,199
for linear languages

508
00:16:08,880 --> 00:16:12,639
because if we have a linear language

509
00:16:11,199 --> 00:16:15,519
with subtract or t

510
00:16:12,639 --> 00:16:16,320
which as i told you cancels these this

511
00:16:15,519 --> 00:16:18,560
matrix m

512
00:16:16,320 --> 00:16:20,240
from the left then we can simply look at

513
00:16:18,560 --> 00:16:23,119
the verification equation

514
00:16:20,240 --> 00:16:24,240
and apply the trapdoor so we multiply it

515
00:16:23,120 --> 00:16:27,199
from the left

516
00:16:24,240 --> 00:16:28,720
and uh by definition this m vanishes so

517
00:16:27,199 --> 00:16:30,719
the left side is zero

518
00:16:28,720 --> 00:16:33,279
however if the adversary actually

519
00:16:30,720 --> 00:16:35,120
produced produced a proof for something

520
00:16:33,279 --> 00:16:39,040
not in the language

521
00:16:35,120 --> 00:16:42,079
then this x and this a won't cancel

522
00:16:39,040 --> 00:16:42,480
and if we rearrange this a bit then we

523
00:16:42,079 --> 00:16:45,199
can

524
00:16:42,480 --> 00:16:47,040
see the left side as a vector c and have

525
00:16:45,199 --> 00:16:48,639
a solution for the kernel matrix if we

526
00:16:47,040 --> 00:16:50,639
have an assumption

527
00:16:48,639 --> 00:16:52,720
for the language one e for the uh

528
00:16:50,639 --> 00:16:54,959
language matrix one e

529
00:16:52,720 --> 00:16:56,000
and we have a reduction to this

530
00:16:54,959 --> 00:16:57,758
assumption

531
00:16:56,000 --> 00:16:59,519
so why doesn't this work for algebraic

532
00:16:57,759 --> 00:17:00,320
languages problem comes with the

533
00:16:59,519 --> 00:17:02,480
trapdoor

534
00:17:00,320 --> 00:17:04,160
for linear languages we can find trap

535
00:17:02,480 --> 00:17:07,439
attractor which cancels the matrix

536
00:17:04,160 --> 00:17:09,439
m however for algebraic languages

537
00:17:07,439 --> 00:17:12,160
this in general won't be possible

538
00:17:09,439 --> 00:17:15,039
because now m depends on the word

539
00:17:12,160 --> 00:17:15,919
and since to use the trapdoor in the way

540
00:17:15,039 --> 00:17:18,160
we do it here

541
00:17:15,919 --> 00:17:19,520
the trapdoor has to be over zp because

542
00:17:18,160 --> 00:17:20,400
otherwise we would have to use the

543
00:17:19,520 --> 00:17:23,039
pairing

544
00:17:20,400 --> 00:17:23,600
at the point of multiplying t with a and

545
00:17:23,039 --> 00:17:25,119
x

546
00:17:23,599 --> 00:17:27,119
and then we couldn't use the pairing in

547
00:17:25,119 --> 00:17:27,760
the end and the solution would be in the

548
00:17:27,119 --> 00:17:31,678
wrong group

549
00:17:27,760 --> 00:17:34,400
because it would already be in group gt

550
00:17:31,679 --> 00:17:36,400
so we need a trapdoor over z p which

551
00:17:34,400 --> 00:17:36,880
somehow would have to depend on the

552
00:17:36,400 --> 00:17:40,080
vector

553
00:17:36,880 --> 00:17:42,080
x but x is over group g one

554
00:17:40,080 --> 00:17:43,360
so in order to compute this trapdoor

555
00:17:42,080 --> 00:17:45,918
which cancels m

556
00:17:43,360 --> 00:17:47,120
for every x it would have to depend on x

557
00:17:45,919 --> 00:17:49,360
and this is in general

558
00:17:47,120 --> 00:17:51,280
not possible so in order to cope with

559
00:17:49,360 --> 00:17:54,559
this freedom of the adversary to choose

560
00:17:51,280 --> 00:17:55,918
x and in this sense manipulate this

561
00:17:54,559 --> 00:17:57,918
matrix m of x

562
00:17:55,919 --> 00:17:59,520
we have to also give the adversary more

563
00:17:57,919 --> 00:18:01,360
freedom in the assumption

564
00:17:59,520 --> 00:18:03,039
and this is exactly what we do in the

565
00:18:01,360 --> 00:18:04,479
extended kernel matrix if we have an

566
00:18:03,039 --> 00:18:06,720
assumption

567
00:18:04,480 --> 00:18:09,440
and that looks as follows now we make it

568
00:18:06,720 --> 00:18:11,679
a bit easier for the adversary to find

569
00:18:09,440 --> 00:18:12,720
elements in the kernel of the matrix by

570
00:18:11,679 --> 00:18:15,600
allowing him

571
00:18:12,720 --> 00:18:16,880
to add rows to this matrix so he gets to

572
00:18:15,600 --> 00:18:18,559
add l rows

573
00:18:16,880 --> 00:18:20,559
but in order to keep the assumption not

574
00:18:18,559 --> 00:18:23,600
trivial he also has to give us

575
00:18:20,559 --> 00:18:24,559
l plus one vectors in the kernel of this

576
00:18:23,600 --> 00:18:26,879
new

577
00:18:24,559 --> 00:18:28,480
matrix and these vectors have to be

578
00:18:26,880 --> 00:18:30,480
linearly independent in order to keep

579
00:18:28,480 --> 00:18:32,000
the assumption non-trivial

580
00:18:30,480 --> 00:18:33,760
and this l is now a parameter of the

581
00:18:32,000 --> 00:18:36,559
assumption so the bigger l

582
00:18:33,760 --> 00:18:38,320
gets the more linearly independent

583
00:18:36,559 --> 00:18:39,360
kernel vectors the adversary has to give

584
00:18:38,320 --> 00:18:42,080
us

585
00:18:39,360 --> 00:18:43,678
formally we can say that this matrix c

586
00:18:42,080 --> 00:18:45,840
times d combined with b

587
00:18:43,679 --> 00:18:48,720
has to be zero and the rank of c has to

588
00:18:45,840 --> 00:18:50,399
be at least l plus one

589
00:18:48,720 --> 00:18:51,760
so why is this a reasonable assumption

590
00:18:50,400 --> 00:18:53,360
to make at all

591
00:18:51,760 --> 00:18:55,360
well first of all it is in a way a

592
00:18:53,360 --> 00:18:56,639
natural extension of the kernel matrix

593
00:18:55,360 --> 00:18:58,320
to the helmet assumption

594
00:18:56,640 --> 00:19:00,320
we give the adversary more freedom by

595
00:18:58,320 --> 00:19:03,039
allowing him to extend its challenge

596
00:19:00,320 --> 00:19:03,439
but in order to win he has to also give

597
00:19:03,039 --> 00:19:05,840
us

598
00:19:03,440 --> 00:19:07,280
more it is also a static and

599
00:19:05,840 --> 00:19:08,720
non-interactive assumption

600
00:19:07,280 --> 00:19:11,120
and we've shown that it holds in the

601
00:19:08,720 --> 00:19:13,440
generic and algebraic group model

602
00:19:11,120 --> 00:19:14,159
the problem comes in with falsifiability

603
00:19:13,440 --> 00:19:16,160
in order to

604
00:19:14,160 --> 00:19:18,160
for a solution to be a valid solution

605
00:19:16,160 --> 00:19:19,600
the rank of this matrix c has to be at

606
00:19:18,160 --> 00:19:21,600
least l plus one

607
00:19:19,600 --> 00:19:23,039
however this won't be checkable in

608
00:19:21,600 --> 00:19:26,000
general for a

609
00:19:23,039 --> 00:19:28,400
matrix of group vectors so the

610
00:19:26,000 --> 00:19:30,880
assumption in general is not falsifiable

611
00:19:28,400 --> 00:19:31,520
however for a large class of useful

612
00:19:30,880 --> 00:19:34,320
languages

613
00:19:31,520 --> 00:19:35,679
it actually can be falsifiable namely

614
00:19:34,320 --> 00:19:37,039
for the class of witness samplable

615
00:19:35,679 --> 00:19:38,720
algebraic languages

616
00:19:37,039 --> 00:19:40,879
because we have this trapdoor which

617
00:19:38,720 --> 00:19:43,200
allows us to check language membership

618
00:19:40,880 --> 00:19:44,799
and this can be used as follows again we

619
00:19:43,200 --> 00:19:47,280
look at the verification equation

620
00:19:44,799 --> 00:19:47,918
already multiplied by the trapdoor t

621
00:19:47,280 --> 00:19:51,360
which now

622
00:19:47,919 --> 00:19:54,000
does not cancel m of x and having put

623
00:19:51,360 --> 00:19:55,600
t times m of x paired with the on the

624
00:19:54,000 --> 00:19:57,600
right side

625
00:19:55,600 --> 00:19:59,039
and if we rewrite this again in the same

626
00:19:57,600 --> 00:20:02,879
way as we did for

627
00:19:59,039 --> 00:20:05,679
the linear case we get this matrix c

628
00:20:02,880 --> 00:20:06,559
which is in the kernel of one e combined

629
00:20:05,679 --> 00:20:08,400
with d

630
00:20:06,559 --> 00:20:09,918
so this d is now the extension that the

631
00:20:08,400 --> 00:20:13,200
adversary uses

632
00:20:09,919 --> 00:20:14,240
and this is hopefully a solution and we

633
00:20:13,200 --> 00:20:16,880
can actually show

634
00:20:14,240 --> 00:20:17,840
that the rank of c is full and in a

635
00:20:16,880 --> 00:20:20,480
sense visible

636
00:20:17,840 --> 00:20:21,360
if and only if this word x is not in the

637
00:20:20,480 --> 00:20:22,960
language

638
00:20:21,360 --> 00:20:24,959
so in exactly this case we get a

639
00:20:22,960 --> 00:20:26,480
reduction to our extended kernel matrix

640
00:20:24,960 --> 00:20:29,440
if you have an assumption

641
00:20:26,480 --> 00:20:30,080
the visibility of the rank in this case

642
00:20:29,440 --> 00:20:32,159
means

643
00:20:30,080 --> 00:20:33,600
that we can bring this matrix c in an

644
00:20:32,159 --> 00:20:36,960
upper triangular form

645
00:20:33,600 --> 00:20:40,480
without computing any anything like

646
00:20:36,960 --> 00:20:42,480
cdh so we can check the rank

647
00:20:40,480 --> 00:20:44,720
note that of course we also get a

648
00:20:42,480 --> 00:20:47,120
reduction to the assumption

649
00:20:44,720 --> 00:20:48,840
for non-witness-samplable languages

650
00:20:47,120 --> 00:20:50,479
however then the assumption is

651
00:20:48,840 --> 00:20:52,559
non-falsifiable

652
00:20:50,480 --> 00:20:54,000
however this non-falsifiability is not

653
00:20:52,559 --> 00:20:56,240
in a knowledge assumption

654
00:20:54,000 --> 00:20:57,120
flavor but more in a gap assumption

655
00:20:56,240 --> 00:21:00,320
flavor

656
00:20:57,120 --> 00:21:03,520
which one can think of as something like

657
00:21:00,320 --> 00:21:03,918
saying that ddh in group g2 is still

658
00:21:03,520 --> 00:21:07,280
hard

659
00:21:03,919 --> 00:21:10,400
even if we had a cdh oracle in group g1

660
00:21:07,280 --> 00:21:12,158
but this is only as an intuition so

661
00:21:10,400 --> 00:21:15,440
let's conclude this talk by comparing

662
00:21:12,159 --> 00:21:16,960
our results with some existing ones

663
00:21:15,440 --> 00:21:19,039
namely with the ones i told you about in

664
00:21:16,960 --> 00:21:20,720
the beginning and for

665
00:21:19,039 --> 00:21:22,400
the case of linear languages and more

666
00:21:20,720 --> 00:21:24,559
completely for ddh

667
00:21:22,400 --> 00:21:25,919
we can see that our construction is more

668
00:21:24,559 --> 00:21:27,760
efficient than grosser high

669
00:21:25,919 --> 00:21:29,840
in proof size where we save one group

670
00:21:27,760 --> 00:21:30,400
element as well as in number of pairings

671
00:21:29,840 --> 00:21:32,399
where we

672
00:21:30,400 --> 00:21:33,919
save three quarters of the pairings that

673
00:21:32,400 --> 00:21:36,240
gross the high needs

674
00:21:33,919 --> 00:21:38,240
which is quite a lot however we are not

675
00:21:36,240 --> 00:21:40,159
as efficient as the kills we proves

676
00:21:38,240 --> 00:21:41,440
since they yield constant size proofs

677
00:21:40,159 --> 00:21:43,679
and smaller ones

678
00:21:41,440 --> 00:21:45,120
and they need less pairings however our

679
00:21:43,679 --> 00:21:48,240
proofs are fully adaptive

680
00:21:45,120 --> 00:21:49,760
while theirs are only quasi-adaptive and

681
00:21:48,240 --> 00:21:50,559
the assumption is actually actually a

682
00:21:49,760 --> 00:21:53,120
sound one

683
00:21:50,559 --> 00:21:53,918
because we are secure under the same

684
00:21:53,120 --> 00:21:55,760
assumption

685
00:21:53,919 --> 00:21:57,360
as the kills we proved which is the

686
00:21:55,760 --> 00:21:59,679
standard kernel matrix diffie-hellman

687
00:21:57,360 --> 00:22:01,280
assumption for linear languages

688
00:21:59,679 --> 00:22:02,960
and the efficiency improvements compared

689
00:22:01,280 --> 00:22:05,760
to grocer high also hold

690
00:22:02,960 --> 00:22:07,440
in the general case for linear languages

691
00:22:05,760 --> 00:22:10,799
so also asymptotically

692
00:22:07,440 --> 00:22:13,120
we improve over gross high in proof size

693
00:22:10,799 --> 00:22:15,360
as well as pairing number

694
00:22:13,120 --> 00:22:16,799
another interesting fact is that to the

695
00:22:15,360 --> 00:22:18,639
best of our knowledge our

696
00:22:16,799 --> 00:22:20,799
framework yields the first proofs which

697
00:22:18,640 --> 00:22:22,080
are fully adaptive but leverage witness

698
00:22:20,799 --> 00:22:23,520
sample abilities so we

699
00:22:22,080 --> 00:22:25,840
close the gap between grosser high and

700
00:22:23,520 --> 00:22:27,440
kills we since the first

701
00:22:25,840 --> 00:22:29,360
is fully adapted and does not use

702
00:22:27,440 --> 00:22:29,600
witness assemblability while the kills

703
00:22:29,360 --> 00:22:32,799
we

704
00:22:29,600 --> 00:22:34,158
proves are both quasi-adaptive

705
00:22:32,799 --> 00:22:36,000
and one does not use witness

706
00:22:34,159 --> 00:22:40,720
assemblability while the other does

707
00:22:36,000 --> 00:22:42,799
so it is a nice completion in a sense

708
00:22:40,720 --> 00:22:43,840
another important applications are or

709
00:22:42,799 --> 00:22:46,080
proofs

710
00:22:43,840 --> 00:22:47,360
um and they're the most prominent and

711
00:22:46,080 --> 00:22:49,840
most used

712
00:22:47,360 --> 00:22:51,520
uh or proof is the one by ruffles which

713
00:22:49,840 --> 00:22:52,320
is an application of the gross high

714
00:22:51,520 --> 00:22:55,280
framework

715
00:22:52,320 --> 00:22:56,720
and again for the ore of qddh languages

716
00:22:55,280 --> 00:22:59,200
uh we will start

717
00:22:56,720 --> 00:23:00,799
and there the proof size of the existing

718
00:22:59,200 --> 00:23:02,480
proofs are 10 group elements and they

719
00:23:00,799 --> 00:23:05,679
require 24 pairings

720
00:23:02,480 --> 00:23:08,640
while we only need seven group elements

721
00:23:05,679 --> 00:23:09,520
and 12 pairings so a huge efficiency

722
00:23:08,640 --> 00:23:11,919
improvement

723
00:23:09,520 --> 00:23:13,840
of course at the cost of assuming our

724
00:23:11,919 --> 00:23:14,720
new extended kernel matrix diffijamen

725
00:23:13,840 --> 00:23:17,039
assumption

726
00:23:14,720 --> 00:23:19,679
and also using witness sampleability

727
00:23:17,039 --> 00:23:21,520
which for ddh is a given

728
00:23:19,679 --> 00:23:22,880
and this also of course extends to

729
00:23:21,520 --> 00:23:25,679
general languages

730
00:23:22,880 --> 00:23:27,679
described by an n times t matrix and an

731
00:23:25,679 --> 00:23:29,200
n2 times t2 matrix

732
00:23:27,679 --> 00:23:30,720
note that these do not have to be the

733
00:23:29,200 --> 00:23:32,000
same so this is a really flexible

734
00:23:30,720 --> 00:23:33,840
construction

735
00:23:32,000 --> 00:23:36,799
and there as well the efficiency

736
00:23:33,840 --> 00:23:39,360
improvements hold asymptotically

737
00:23:36,799 --> 00:23:41,279
so what are some applications of our new

738
00:23:39,360 --> 00:23:43,360
or proof

739
00:23:41,279 --> 00:23:44,559
there are many and some include the

740
00:23:43,360 --> 00:23:46,000
tightly secure structure preserving

741
00:23:44,559 --> 00:23:47,678
signature constructions

742
00:23:46,000 --> 00:23:50,320
simulation some quasi-adaptive physics

743
00:23:47,679 --> 00:23:52,640
ring signatures and many more

744
00:23:50,320 --> 00:23:54,000
and for many of these applications the

745
00:23:52,640 --> 00:23:56,640
or proof is actually a

746
00:23:54,000 --> 00:23:57,039
large part of their size and computation

747
00:23:56,640 --> 00:23:59,200
and

748
00:23:57,039 --> 00:24:00,400
by reducing its size we can

749
00:23:59,200 --> 00:24:02,400
significantly

750
00:24:00,400 --> 00:24:03,679
improve the size of the primitives in

751
00:24:02,400 --> 00:24:06,400
which they are used

752
00:24:03,679 --> 00:24:08,000
so by assuming our new assumption we can

753
00:24:06,400 --> 00:24:09,520
greatly improve many primitives

754
00:24:08,000 --> 00:24:11,279
so this is at least something to

755
00:24:09,520 --> 00:24:13,279
consider

756
00:24:11,279 --> 00:24:14,559
so that's it for my talk i hope you

757
00:24:13,279 --> 00:24:16,240
enjoyed it and thank you for your

758
00:24:14,559 --> 00:24:17,520
attention if you have any questions i'll

759
00:24:16,240 --> 00:24:18,559
gladly answer them at the panel

760
00:24:17,520 --> 00:24:23,840
discussion

761
00:24:18,559 --> 00:24:23,840
and i'll gladly see you then bye

