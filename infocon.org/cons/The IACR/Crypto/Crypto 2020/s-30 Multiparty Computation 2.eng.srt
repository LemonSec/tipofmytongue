1
00:00:05,600 --> 00:00:07,758
all right

2
00:00:06,080 --> 00:00:10,160
it looks like we're live on youtube

3
00:00:07,759 --> 00:00:12,080
hello everyone uh welcome to

4
00:00:10,160 --> 00:00:14,559
this session on secure multi-party

5
00:00:12,080 --> 00:00:16,400
computation this is the second of three

6
00:00:14,559 --> 00:00:18,240
sessions i'll be one of the session

7
00:00:16,400 --> 00:00:21,038
chairs along with antigone

8
00:00:18,240 --> 00:00:24,000
you'll see her as well but we'll just

9
00:00:21,039 --> 00:00:25,519
get started with the first talk as usual

10
00:00:24,000 --> 00:00:28,400
five minutes for the talk and five

11
00:00:25,519 --> 00:00:30,720
minutes for questions afterwards

12
00:00:28,400 --> 00:00:33,040
so the first talk is always have a

13
00:00:30,720 --> 00:00:36,160
backup plan fully secure synchronous

14
00:00:33,040 --> 00:00:38,559
npc with asynchronous fallback and

15
00:00:36,160 --> 00:00:40,319
chenda is going to give the talk so

16
00:00:38,559 --> 00:00:44,959
whenever you're ready

17
00:00:40,320 --> 00:00:48,480
uh take it away so can you see my screen

18
00:00:44,960 --> 00:00:50,640
yes okay okay so thanks for the

19
00:00:48,480 --> 00:00:52,000
introduction my name is chenda i'm from

20
00:00:50,640 --> 00:00:54,960
eta zurich

21
00:00:52,000 --> 00:00:57,280
i'm gonna talk about as you said about

22
00:00:54,960 --> 00:00:59,840
synchronous mpc with asynchronous

23
00:00:57,280 --> 00:01:01,520
fallback and this is joint work with

24
00:00:59,840 --> 00:01:04,640
erika and julian

25
00:01:01,520 --> 00:01:05,920
from university of maryland so the

26
00:01:04,640 --> 00:01:08,320
setting is that of

27
00:01:05,920 --> 00:01:10,000
secure multi-party computation where

28
00:01:08,320 --> 00:01:10,559
parties want to jointly compute a

29
00:01:10,000 --> 00:01:13,040
function

30
00:01:10,560 --> 00:01:15,119
over private inputs without revealing

31
00:01:13,040 --> 00:01:17,280
anything about the inputs

32
00:01:15,119 --> 00:01:19,280
just as if they had a trusted party

33
00:01:17,280 --> 00:01:21,680
available

34
00:01:19,280 --> 00:01:23,680
so very roughly npc protocols can be

35
00:01:21,680 --> 00:01:25,040
classified according to the underlying

36
00:01:23,680 --> 00:01:27,680
communication

37
00:01:25,040 --> 00:01:29,920
model and perhaps the most popular one

38
00:01:27,680 --> 00:01:32,000
is the synchronous model

39
00:01:29,920 --> 00:01:33,439
this assumes that parties have access to

40
00:01:32,000 --> 00:01:35,439
synchronized clocks

41
00:01:33,439 --> 00:01:38,240
and everyone knows an upper bound from

42
00:01:35,439 --> 00:01:40,639
the network communication team

43
00:01:38,240 --> 00:01:41,360
while having these assumptions is very

44
00:01:40,640 --> 00:01:43,119
convenient

45
00:01:41,360 --> 00:01:44,720
in many settings this might not be

46
00:01:43,119 --> 00:01:47,040
completely realistic

47
00:01:44,720 --> 00:01:49,039
for example if the network delay is

48
00:01:47,040 --> 00:01:51,680
unpredictable

49
00:01:49,040 --> 00:01:53,360
the much more realistic model is the

50
00:01:51,680 --> 00:01:55,600
asynchronous model

51
00:01:53,360 --> 00:01:57,280
so here protocols do not make any

52
00:01:55,600 --> 00:01:58,079
assumption on the synchrony of the

53
00:01:57,280 --> 00:02:01,040
clocks

54
00:01:58,079 --> 00:02:03,679
they only use the fact that messages

55
00:02:01,040 --> 00:02:05,759
sent are eventually delivered

56
00:02:03,680 --> 00:02:07,680
so then one can ask okay then then why

57
00:02:05,759 --> 00:02:08,639
do we care about synchronous protocols

58
00:02:07,680 --> 00:02:11,200
right

59
00:02:08,639 --> 00:02:11,839
and perhaps one reason is that having

60
00:02:11,200 --> 00:02:13,920
such

61
00:02:11,840 --> 00:02:16,640
strong assumptions allows us to have

62
00:02:13,920 --> 00:02:19,920
also very strong security guarantees

63
00:02:16,640 --> 00:02:22,958
so synchronous protocols tolerate a high

64
00:02:19,920 --> 00:02:25,359
threshold tolerance so up to in half

65
00:02:22,959 --> 00:02:27,840
and parties compute exactly the output

66
00:02:25,360 --> 00:02:29,599
that one would expect

67
00:02:27,840 --> 00:02:31,040
and on the other hand asynchronous

68
00:02:29,599 --> 00:02:33,679
protocols only get

69
00:02:31,040 --> 00:02:34,640
up to and third corruptions and

70
00:02:33,680 --> 00:02:36,560
unavoidably

71
00:02:34,640 --> 00:02:37,679
the inputs of up to d parties are

72
00:02:36,560 --> 00:02:39,599
ignored

73
00:02:37,680 --> 00:02:40,800
this means that parties do not really

74
00:02:39,599 --> 00:02:42,720
get f

75
00:02:40,800 --> 00:02:45,599
on the inputs which would be the normal

76
00:02:42,720 --> 00:02:47,840
output but the adversary is allowed to

77
00:02:45,599 --> 00:02:50,160
choose up to the inputs and substitute

78
00:02:47,840 --> 00:02:53,440
them by a default value

79
00:02:50,160 --> 00:02:55,840
button so in view of this

80
00:02:53,440 --> 00:02:58,319
we can ask whether there is one single

81
00:02:55,840 --> 00:02:59,760
mpc protocol that achieves guarantees in

82
00:02:58,319 --> 00:03:02,560
both regimes

83
00:02:59,760 --> 00:03:04,560
and we would like to have like high

84
00:03:02,560 --> 00:03:05,680
threshold tolerance when the network is

85
00:03:04,560 --> 00:03:08,480
synchronous

86
00:03:05,680 --> 00:03:10,560
of course with input completeness but

87
00:03:08,480 --> 00:03:11,359
even when the network is asynchronous we

88
00:03:10,560 --> 00:03:13,920
would like to

89
00:03:11,360 --> 00:03:15,440
still be able to tolerate a reasonable

90
00:03:13,920 --> 00:03:17,119
amount of corruptions

91
00:03:15,440 --> 00:03:19,120
but of course allowing some of the

92
00:03:17,120 --> 00:03:21,040
inputs to be ignored

93
00:03:19,120 --> 00:03:22,239
and this is the question that we answer

94
00:03:21,040 --> 00:03:25,679
in this work

95
00:03:22,239 --> 00:03:28,879
we say that yes such an npc exists

96
00:03:25,680 --> 00:03:31,280
if and only if ta plus 2ts

97
00:03:28,879 --> 00:03:32,000
smaller than n and the number of ignored

98
00:03:31,280 --> 00:03:36,640
inputs is

99
00:03:32,000 --> 00:03:38,560
at least ts in the asynchronous case

100
00:03:36,640 --> 00:03:41,599
so here is some related work there are

101
00:03:38,560 --> 00:03:42,319
some nice recent works by bloom cuts and

102
00:03:41,599 --> 00:03:44,480
loss

103
00:03:42,319 --> 00:03:45,599
that study such questions for the case

104
00:03:44,480 --> 00:03:48,480
of agreement

105
00:03:45,599 --> 00:03:51,280
primitives first for byzantine agreement

106
00:03:48,480 --> 00:03:54,079
and then for state machine replication

107
00:03:51,280 --> 00:03:55,680
and there are also some asynchronous mpc

108
00:03:54,080 --> 00:03:58,159
protocols out there

109
00:03:55,680 --> 00:03:59,360
i believe this was the first one i heard

110
00:03:58,159 --> 00:04:02,239
it all that

111
00:03:59,360 --> 00:04:03,120
that achieve input completeness when the

112
00:04:02,239 --> 00:04:06,799
network is

113
00:04:03,120 --> 00:04:07,120
the synchronous so let's get an overview

114
00:04:06,799 --> 00:04:10,159
of

115
00:04:07,120 --> 00:04:12,080
our construction so uh what we do is we

116
00:04:10,159 --> 00:04:13,920
rely on a core primitive which is

117
00:04:12,080 --> 00:04:17,040
basically

118
00:04:13,920 --> 00:04:19,680
we enhance a synchronous mpc protocol

119
00:04:17,040 --> 00:04:20,320
that not only gives all the guarantees

120
00:04:19,680 --> 00:04:22,079
that we

121
00:04:20,320 --> 00:04:24,560
would like to have when the network is

122
00:04:22,079 --> 00:04:26,400
synchronous but also achieves

123
00:04:24,560 --> 00:04:28,000
reasonable guarantees when the network

124
00:04:26,400 --> 00:04:30,638
is asynchronous

125
00:04:28,000 --> 00:04:32,080
meaning that every party gets an

126
00:04:30,639 --> 00:04:34,160
asynchronous output

127
00:04:32,080 --> 00:04:35,199
which is allowed to ignore a bunch of

128
00:04:34,160 --> 00:04:38,639
inputs

129
00:04:35,199 --> 00:04:42,000
or everyone obtains bottom

130
00:04:38,639 --> 00:04:44,560
and and the way we achieve this is

131
00:04:42,000 --> 00:04:46,560
following the the cdn approach kramer

132
00:04:44,560 --> 00:04:49,360
tamkartan nielsen which is based on

133
00:04:46,560 --> 00:04:51,199
threshold homomorphic encryption

134
00:04:49,360 --> 00:04:53,280
and once we have such a primitive it's

135
00:04:51,199 --> 00:04:54,000
easy to guess how to get the mpc that we

136
00:04:53,280 --> 00:04:56,320
want

137
00:04:54,000 --> 00:04:57,680
we first run the synchronous enhanced

138
00:04:56,320 --> 00:05:00,000
mpc protocol

139
00:04:57,680 --> 00:05:02,240
and if the output is bottom we run the

140
00:05:00,000 --> 00:05:03,520
asynchronous any asynchronous npc

141
00:05:02,240 --> 00:05:05,840
protocol

142
00:05:03,520 --> 00:05:07,520
and why does this work because if if the

143
00:05:05,840 --> 00:05:10,080
network is synchronous we inherit the

144
00:05:07,520 --> 00:05:13,520
security guarantees from the first

145
00:05:10,080 --> 00:05:14,719
component but even if the network is

146
00:05:13,520 --> 00:05:18,080
asynchronous either

147
00:05:14,720 --> 00:05:20,000
everyone obtains a y a output so we're

148
00:05:18,080 --> 00:05:22,800
happy or everyone obtains bottom in

149
00:05:20,000 --> 00:05:26,479
which case is completely safe to

150
00:05:22,800 --> 00:05:28,479
execute the asynchronous fallback

151
00:05:26,479 --> 00:05:30,000
so for more information i refer you to

152
00:05:28,479 --> 00:05:33,360
the full video presentation

153
00:05:30,000 --> 00:05:39,840
and or the full version of the paper

154
00:05:33,360 --> 00:05:39,840
thank you

155
00:05:45,440 --> 00:05:48,719
so if you have any questions please

156
00:05:47,120 --> 00:05:50,720
paste them either here on

157
00:05:48,720 --> 00:05:52,639
zulip i think there's already a question

158
00:05:50,720 --> 00:05:55,199
on juliep from castin

159
00:05:52,639 --> 00:05:58,560
how much overhead does the compilation

160
00:05:55,199 --> 00:05:58,560
of the synchronous protocol

161
00:06:00,000 --> 00:06:06,000
to have this extra property cost in

162
00:06:01,759 --> 00:06:09,680
terms of computation or communication

163
00:06:06,000 --> 00:06:12,720
so we have a bit more communication

164
00:06:09,680 --> 00:06:17,600
so in fact i might have some

165
00:06:12,720 --> 00:06:21,199
slides here let me see

166
00:06:17,600 --> 00:06:24,560
um but i would say compared to cdn not

167
00:06:21,199 --> 00:06:29,120
that much so so basically what we do is

168
00:06:24,560 --> 00:06:34,080
um instead of broadcasting um

169
00:06:29,120 --> 00:06:36,880
we we do um

170
00:06:34,080 --> 00:06:37,680
we run an extra acs protocol and this

171
00:06:36,880 --> 00:06:40,639
will incur

172
00:06:37,680 --> 00:06:41,919
basically uh some communication

173
00:06:40,639 --> 00:06:45,120
complexity because this

174
00:06:41,919 --> 00:06:48,479
is uh and broadcast and

175
00:06:45,120 --> 00:06:53,199
va protocols also yeah but

176
00:06:48,479 --> 00:06:53,199
but apart from that no yeah

177
00:06:53,599 --> 00:06:55,919
anyway

178
00:06:58,080 --> 00:07:02,080
i don't more questions just a quick

179
00:07:00,960 --> 00:07:03,919
question so your

180
00:07:02,080 --> 00:07:05,280
uh the primitive that you are using all

181
00:07:03,919 --> 00:07:09,120
the ways uh the homework

182
00:07:05,280 --> 00:07:11,119
encryption is uh the primitive that we

183
00:07:09,120 --> 00:07:13,120
rely on is uh additively

184
00:07:11,120 --> 00:07:14,240
homomorphic encryption threshold

185
00:07:13,120 --> 00:07:18,479
positive

186
00:07:14,240 --> 00:07:18,479
encryption is not fully homomorphic

187
00:07:20,880 --> 00:07:24,319
okay thanks a lot for your time so if

188
00:07:22,880 --> 00:07:27,840
you have more questions please

189
00:07:24,319 --> 00:07:30,960
feel free to ask agenda offline

190
00:07:27,840 --> 00:07:33,198
now we can move to the next talk thank

191
00:07:30,960 --> 00:07:33,198
you

192
00:07:33,520 --> 00:07:37,840
so the next talk is about stacked

193
00:07:35,520 --> 00:07:40,479
garbling garbled circuits proportional

194
00:07:37,840 --> 00:07:43,919
to longest execution path

195
00:07:40,479 --> 00:07:44,479
from david heath and vlad kolesnikov and

196
00:07:43,919 --> 00:07:46,560
david

197
00:07:44,479 --> 00:07:47,520
is giving the talk so david you can

198
00:07:46,560 --> 00:07:48,879
start

199
00:07:47,520 --> 00:07:50,560
thank you can you hear me hear me and

200
00:07:48,879 --> 00:07:53,919
see my slides

201
00:07:50,560 --> 00:07:55,599
yes okay uh yes so i'm

202
00:07:53,919 --> 00:07:57,039
david heath and i'll be presenting

203
00:07:55,599 --> 00:07:59,840
stacked garbling again this is joint

204
00:07:57,039 --> 00:08:02,000
work with my advisor vlad kalesnikov

205
00:07:59,840 --> 00:08:03,599
so this work is about garbled circuits

206
00:08:02,000 --> 00:08:05,440
so i'd like to briefly review the

207
00:08:03,599 --> 00:08:06,960
technique

208
00:08:05,440 --> 00:08:08,800
so garbled circuits is a protocol

209
00:08:06,960 --> 00:08:10,799
between two players a so-called circuit

210
00:08:08,800 --> 00:08:12,879
generator and evaluator

211
00:08:10,800 --> 00:08:15,039
and the circuit generator's job is to

212
00:08:12,879 --> 00:08:18,160
build an encryption of a

213
00:08:15,039 --> 00:08:19,520
function represented as a circuit and in

214
00:08:18,160 --> 00:08:21,120
this case we'll have her do so starting

215
00:08:19,520 --> 00:08:23,120
from a pseudorandom seed

216
00:08:21,120 --> 00:08:24,400
so she builds this encryption what i'm

217
00:08:23,120 --> 00:08:26,080
denoting m

218
00:08:24,400 --> 00:08:28,799
m is for what we refer to as the

219
00:08:26,080 --> 00:08:31,039
material and the material contains

220
00:08:28,800 --> 00:08:33,200
a collection of encrypted truth tables

221
00:08:31,039 --> 00:08:36,000
encoding the semantics of the individual

222
00:08:33,200 --> 00:08:38,080
gates in the boolean circuit c

223
00:08:36,000 --> 00:08:39,360
now after having constructed m the

224
00:08:38,080 --> 00:08:41,839
generator sends m

225
00:08:39,360 --> 00:08:42,479
across the network to evaluator and the

226
00:08:41,839 --> 00:08:44,640
key point

227
00:08:42,479 --> 00:08:46,240
is that this simple sending of material

228
00:08:44,640 --> 00:08:48,319
from the generator to evaluator is the

229
00:08:46,240 --> 00:08:48,959
single most expensive part of garbled

230
00:08:48,320 --> 00:08:50,640
circuits

231
00:08:48,959 --> 00:08:52,239
and it is this cost that we decrease in

232
00:08:50,640 --> 00:08:54,880
this work

233
00:08:52,240 --> 00:08:56,320
so the evaluator now has the material m

234
00:08:54,880 --> 00:08:59,360
and he also

235
00:08:56,320 --> 00:09:00,800
uh obtains so-called input labels though

236
00:08:59,360 --> 00:09:01,600
i won't describe how he gets these but

237
00:09:00,800 --> 00:09:03,599
these are

238
00:09:01,600 --> 00:09:04,959
our encryptions of the logical inputs to

239
00:09:03,600 --> 00:09:06,800
this circuit

240
00:09:04,959 --> 00:09:08,640
the input labels in the material are

241
00:09:06,800 --> 00:09:10,000
sufficient information for the evaluator

242
00:09:08,640 --> 00:09:12,560
to step through this circuit

243
00:09:10,000 --> 00:09:14,880
gate by gate and eventually arrive at

244
00:09:12,560 --> 00:09:17,518
labels that encode the circuit output

245
00:09:14,880 --> 00:09:19,200
now the two players can communicate in

246
00:09:17,519 --> 00:09:20,720
order to jointly decrypt the circuit

247
00:09:19,200 --> 00:09:22,480
output

248
00:09:20,720 --> 00:09:24,160
so this is garbled circuits and in this

249
00:09:22,480 --> 00:09:26,240
work we extend garbled circuits to

250
00:09:24,160 --> 00:09:28,480
efficiently handle conditional branching

251
00:09:26,240 --> 00:09:30,720
that arises in the underlying program

252
00:09:28,480 --> 00:09:33,120
so for example this if-else program that

253
00:09:30,720 --> 00:09:34,560
i have written here

254
00:09:33,120 --> 00:09:36,399
in order to represent conditional

255
00:09:34,560 --> 00:09:38,079
programs we need more than one circuit

256
00:09:36,399 --> 00:09:39,839
in particular we need one circuit per

257
00:09:38,080 --> 00:09:41,760
branch

258
00:09:39,839 --> 00:09:44,000
so we'll consider these two circuits c1

259
00:09:41,760 --> 00:09:45,760
and c2 and i'd like for you to imagine

260
00:09:44,000 --> 00:09:48,080
the case where the circuit c1

261
00:09:45,760 --> 00:09:50,959
is taken during the evaluation of this

262
00:09:48,080 --> 00:09:51,360
conditional branch the key point is that

263
00:09:50,959 --> 00:09:53,119
the

264
00:09:51,360 --> 00:09:54,480
circuit generator and evaluator should

265
00:09:53,120 --> 00:09:56,080
not know which of

266
00:09:54,480 --> 00:09:57,680
which of these two branches are taken

267
00:09:56,080 --> 00:09:59,440
during evaluation

268
00:09:57,680 --> 00:10:01,680
and our approach approach is going to

269
00:09:59,440 --> 00:10:02,640
reduce the amount of information needed

270
00:10:01,680 --> 00:10:04,959
to represent

271
00:10:02,640 --> 00:10:06,480
the encryption of a conditional branch

272
00:10:04,959 --> 00:10:08,560
without having to disclose to any of the

273
00:10:06,480 --> 00:10:11,200
players which branch is taken

274
00:10:08,560 --> 00:10:11,839
so our approach is as follows first

275
00:10:11,200 --> 00:10:14,000
instead of

276
00:10:11,839 --> 00:10:14,959
having only one seed we have one seed

277
00:10:14,000 --> 00:10:16,959
per branch

278
00:10:14,959 --> 00:10:18,880
so the circuit generator constructs

279
00:10:16,959 --> 00:10:20,160
encryptions of each of the branches in

280
00:10:18,880 --> 00:10:23,279
the conditional

281
00:10:20,160 --> 00:10:25,600
to get in this case strings m1 and m2

282
00:10:23,279 --> 00:10:27,360
now the key point is that instead of

283
00:10:25,600 --> 00:10:29,920
sending m1 and m2

284
00:10:27,360 --> 00:10:30,480
separately as would normally be done we

285
00:10:29,920 --> 00:10:34,079
instead

286
00:10:30,480 --> 00:10:35,839
send their bitwise xor m1 plus m2

287
00:10:34,079 --> 00:10:37,519
which is of course shorter than sending

288
00:10:35,839 --> 00:10:39,760
the two strings separately

289
00:10:37,519 --> 00:10:41,839
so this bitwise xor is the source of our

290
00:10:39,760 --> 00:10:44,319
improvement

291
00:10:41,839 --> 00:10:47,360
the evaluator now has access to this xor

292
00:10:44,320 --> 00:10:48,240
m1 plus m2 and he also gains access to

293
00:10:47,360 --> 00:10:50,560
the seed

294
00:10:48,240 --> 00:10:51,920
that encrypts the non-taken branch

295
00:10:50,560 --> 00:10:53,839
though i won't explain how this is

296
00:10:51,920 --> 00:10:56,079
conveyed

297
00:10:53,839 --> 00:10:56,959
now if we assume that the evaluator

298
00:10:56,079 --> 00:10:58,880
somehow did

299
00:10:56,959 --> 00:11:00,319
know which branch was taken then it

300
00:10:58,880 --> 00:11:02,079
would be relatively straightforward to

301
00:11:00,320 --> 00:11:04,800
see what he has to do

302
00:11:02,079 --> 00:11:05,920
because he can use this seed s2 to

303
00:11:04,800 --> 00:11:09,199
re-encrypt

304
00:11:05,920 --> 00:11:11,360
the non-taken branch and calculate m2

305
00:11:09,200 --> 00:11:12,959
given these two pieces of material he

306
00:11:11,360 --> 00:11:14,959
can use bitwise xor

307
00:11:12,959 --> 00:11:17,920
to extract the material for the taken

308
00:11:14,959 --> 00:11:19,680
branch and then evaluate as normal

309
00:11:17,920 --> 00:11:21,599
of course the key problem is that the

310
00:11:19,680 --> 00:11:23,199
evaluator is not supposed to know which

311
00:11:21,600 --> 00:11:24,800
branch is taken

312
00:11:23,200 --> 00:11:26,640
in our approach we resolve this by

313
00:11:24,800 --> 00:11:29,040
having the evaluator symmetrically

314
00:11:26,640 --> 00:11:30,959
attempt to evaluate both branches

315
00:11:29,040 --> 00:11:32,319
by this i mean that completely

316
00:11:30,959 --> 00:11:34,880
symmetrically

317
00:11:32,320 --> 00:11:35,519
the evaluator uses the same seed to also

318
00:11:34,880 --> 00:11:38,560
encrypt

319
00:11:35,519 --> 00:11:39,600
the first circuit this does not yield

320
00:11:38,560 --> 00:11:42,719
material m1

321
00:11:39,600 --> 00:11:44,000
but instead yields a new string m1 star

322
00:11:42,720 --> 00:11:46,079
different than the encryption built by

323
00:11:44,000 --> 00:11:48,000
the generator therefore when the

324
00:11:46,079 --> 00:11:51,000
evaluator attempts to extract

325
00:11:48,000 --> 00:11:52,480
the material m2 by bitwise xoring he is

326
00:11:51,000 --> 00:11:54,959
unsuccessful

327
00:11:52,480 --> 00:11:56,480
and when he evaluates he does not arrive

328
00:11:54,959 --> 00:11:59,359
at valid output labels

329
00:11:56,480 --> 00:12:00,160
but instead arrives at random looking

330
00:11:59,360 --> 00:12:01,839
garbage

331
00:12:00,160 --> 00:12:03,360
that is neither an encryption of zero

332
00:12:01,839 --> 00:12:05,519
nor of one

333
00:12:03,360 --> 00:12:07,440
now if we could somehow eliminate this

334
00:12:05,519 --> 00:12:08,959
garbage non-interactively then we would

335
00:12:07,440 --> 00:12:10,560
have evaluated this conditional very

336
00:12:08,959 --> 00:12:12,479
efficiently

337
00:12:10,560 --> 00:12:13,920
to do this garbage collection eliminate

338
00:12:12,480 --> 00:12:14,720
the garbage and propagate the valid

339
00:12:13,920 --> 00:12:17,519
labels

340
00:12:14,720 --> 00:12:18,639
we add a few components first we add a

341
00:12:17,519 --> 00:12:21,680
demultiplexer

342
00:12:18,639 --> 00:12:22,399
the demultiplexer's job is to handle

343
00:12:21,680 --> 00:12:24,560
inputs

344
00:12:22,399 --> 00:12:25,440
onto the taken branch it propagates

345
00:12:24,560 --> 00:12:28,239
valid inputs

346
00:12:25,440 --> 00:12:29,600
such that c1 evaluates as normal but on

347
00:12:28,240 --> 00:12:32,639
the non-taken branch

348
00:12:29,600 --> 00:12:33,920
it places fixed garbage input keys that

349
00:12:32,639 --> 00:12:36,480
are independent of the

350
00:12:33,920 --> 00:12:38,160
of the circuit input thus when the

351
00:12:36,480 --> 00:12:38,959
evaluator runs this circuit under

352
00:12:38,160 --> 00:12:41,439
encryption

353
00:12:38,959 --> 00:12:42,399
he still arrives at garbage labels but

354
00:12:41,440 --> 00:12:45,680
these labels are

355
00:12:42,399 --> 00:12:46,639
fixed our final observation is that the

356
00:12:45,680 --> 00:12:48,479
generator

357
00:12:46,639 --> 00:12:50,800
can place herself in the shoes of the

358
00:12:48,480 --> 00:12:52,720
evaluator to pre-compute

359
00:12:50,800 --> 00:12:55,760
these garbage output labels that is she

360
00:12:52,720 --> 00:12:57,360
can pre-compute these pink keys

361
00:12:55,760 --> 00:12:59,120
knowing the pink keys and knowing the

362
00:12:57,360 --> 00:13:01,120
valid output labels is sufficient

363
00:12:59,120 --> 00:13:01,920
information to build a new encrypted

364
00:13:01,120 --> 00:13:05,200
truth table

365
00:13:01,920 --> 00:13:07,760
which will obliviously collect garbage

366
00:13:05,200 --> 00:13:09,440
so put together stacked garbling allows

367
00:13:07,760 --> 00:13:10,959
us to bitwise xor

368
00:13:09,440 --> 00:13:13,200
the material from different conditional

369
00:13:10,959 --> 00:13:14,880
branches we add

370
00:13:13,200 --> 00:13:16,639
additional circuit gadgets that allow us

371
00:13:14,880 --> 00:13:18,320
to collect garbage

372
00:13:16,639 --> 00:13:20,000
put together stacked garbling offers a

373
00:13:18,320 --> 00:13:21,440
theoretical improvement to garbled

374
00:13:20,000 --> 00:13:22,560
circuit's ability to handle conditional

375
00:13:21,440 --> 00:13:26,160
branches

376
00:13:22,560 --> 00:13:26,160
so thank you and i'll take any questions

377
00:13:26,639 --> 00:13:30,320
all right thanks david that's uh some

378
00:13:29,200 --> 00:13:32,160
exciting work

379
00:13:30,320 --> 00:13:33,920
if anyone has any questions feel free to

380
00:13:32,160 --> 00:13:36,719
ask in

381
00:13:33,920 --> 00:13:39,040
either zulip or here on zoom and we'll

382
00:13:36,720 --> 00:13:42,399
get those relayed to the speaker

383
00:13:39,040 --> 00:13:43,839
in the meantime you know the very last

384
00:13:42,399 --> 00:13:45,920
thing you said is this is a theoretical

385
00:13:43,839 --> 00:13:47,360
improvement is it also a practical

386
00:13:45,920 --> 00:13:49,839
improvement

387
00:13:47,360 --> 00:13:50,959
uh yes so i'll refer you to our paper on

388
00:13:49,839 --> 00:13:54,079
an eprint but we

389
00:13:50,959 --> 00:13:55,439
we implemented this and uh

390
00:13:54,079 --> 00:13:57,519
i should emphasize that there is

391
00:13:55,440 --> 00:13:58,560
actually a computation overhead to doing

392
00:13:57,519 --> 00:14:00,240
this trick

393
00:13:58,560 --> 00:14:03,119
in particular where the generator has to

394
00:14:00,240 --> 00:14:04,639
pre-compute this garbage

395
00:14:03,120 --> 00:14:06,480
so we increased the amount of

396
00:14:04,639 --> 00:14:07,519
computation needed compared to standard

397
00:14:06,480 --> 00:14:09,360
garbled circuits

398
00:14:07,519 --> 00:14:10,639
but we showed that depending on your

399
00:14:09,360 --> 00:14:13,120
hardware and for most

400
00:14:10,639 --> 00:14:13,839
slower networks it's very much well

401
00:14:13,120 --> 00:14:16,079
worth it

402
00:14:13,839 --> 00:14:17,519
to make this trade off and the

403
00:14:16,079 --> 00:14:19,279
communication improvement is worth it

404
00:14:17,519 --> 00:14:21,760
basically so yes it's practically more

405
00:14:19,279 --> 00:14:25,279
efficient for most cases

406
00:14:21,760 --> 00:14:27,360
okay excellent uh marcel is asking

407
00:14:25,279 --> 00:14:29,040
on zulip is the number of interaction

408
00:14:27,360 --> 00:14:31,120
rounds independent of the number of

409
00:14:29,040 --> 00:14:32,880
branches in the circuit

410
00:14:31,120 --> 00:14:34,480
that's right it so this maintains a

411
00:14:32,880 --> 00:14:35,040
constant round property of garbled

412
00:14:34,480 --> 00:14:36,160
circuits

413
00:14:35,040 --> 00:14:38,480
so there are no added rounds of

414
00:14:36,160 --> 00:14:41,040
communication um

415
00:14:38,480 --> 00:14:42,079
and i i suppose you can nest this little

416
00:14:41,040 --> 00:14:43,599
gadget that you saw

417
00:14:42,079 --> 00:14:45,279
that you're showing on the screen you

418
00:14:43,600 --> 00:14:47,120
can nest it inside

419
00:14:45,279 --> 00:14:49,279
yes so in our paper we show two

420
00:14:47,120 --> 00:14:51,839
constructions we show how to nest it

421
00:14:49,279 --> 00:14:52,880
and then we also show how to sort of

422
00:14:51,839 --> 00:14:54,639
vectorize this

423
00:14:52,880 --> 00:14:56,320
so you can imagine the multiplexer

424
00:14:54,639 --> 00:14:57,199
feeding inputs to not two circuits but

425
00:14:56,320 --> 00:14:59,600
to ten

426
00:14:57,199 --> 00:15:00,479
which turns out to be uh computationally

427
00:14:59,600 --> 00:15:03,760
more efficient

428
00:15:00,480 --> 00:15:03,760
by a small amount

429
00:15:03,920 --> 00:15:07,519
okay great both of these are possible

430
00:15:06,560 --> 00:15:08,800
great

431
00:15:07,519 --> 00:15:10,399
we still have time if there are more

432
00:15:08,800 --> 00:15:13,040
questions otherwise i can keep asking

433
00:15:10,399 --> 00:15:13,040
questions all day

434
00:15:13,279 --> 00:15:17,120
one of my questions was

435
00:15:17,199 --> 00:15:20,399
this seems to work really well when

436
00:15:19,279 --> 00:15:22,800
there's a

437
00:15:20,399 --> 00:15:25,199
conditional branch in the circuit but

438
00:15:22,800 --> 00:15:27,359
you know is there any hope of applying

439
00:15:25,199 --> 00:15:30,319
tricks like this for circuits that you

440
00:15:27,360 --> 00:15:32,959
don't really naturally write in terms of

441
00:15:30,320 --> 00:15:34,720
uh switching statements like for example

442
00:15:32,959 --> 00:15:38,000
the aes circuit

443
00:15:34,720 --> 00:15:40,959
um you know is is there a way to

444
00:15:38,000 --> 00:15:41,759
apply your kind of ideas to maybe an

445
00:15:40,959 --> 00:15:45,040
unnatural

446
00:15:41,759 --> 00:15:48,480
example of a circuit yeah

447
00:15:45,040 --> 00:15:50,639
i'm not sure um so the the key

448
00:15:48,480 --> 00:15:52,240
property that you need is is that there

449
00:15:50,639 --> 00:15:55,199
does need to be some sort of

450
00:15:52,240 --> 00:15:56,399
exclusive behavior because as you can

451
00:15:55,199 --> 00:15:58,479
see on the slide here

452
00:15:56,399 --> 00:15:59,440
we're completely we're giving up the

453
00:15:58,480 --> 00:16:03,519
ability to

454
00:15:59,440 --> 00:16:03,519
correctly evaluate the circuit c2

455
00:16:03,600 --> 00:16:06,880
so if there is not some part of your

456
00:16:05,839 --> 00:16:09,199
circuit which

457
00:16:06,880 --> 00:16:10,639
in the end is not going to be evaluated

458
00:16:09,199 --> 00:16:11,758
i don't see how you can apply this

459
00:16:10,639 --> 00:16:14,240
technique

460
00:16:11,759 --> 00:16:16,079
um that said you know if it's not

461
00:16:14,240 --> 00:16:17,839
written in a high level language

462
00:16:16,079 --> 00:16:19,519
perhaps there are ways to kind of

463
00:16:17,839 --> 00:16:21,440
extract

464
00:16:19,519 --> 00:16:23,040
like by some compiler techniques deduce

465
00:16:21,440 --> 00:16:26,480
which parts of the circuit

466
00:16:23,040 --> 00:16:28,959
are exclusive with one another um

467
00:16:26,480 --> 00:16:30,560
but if in terms of like aes it seems

468
00:16:28,959 --> 00:16:31,920
like a stretch because i think you need

469
00:16:30,560 --> 00:16:33,279
the output of all of the

470
00:16:31,920 --> 00:16:35,199
of the gates in order to compute the

471
00:16:33,279 --> 00:16:36,800
eventual output

472
00:16:35,199 --> 00:16:38,160
okay excellent looks like more questions

473
00:16:36,800 --> 00:16:38,560
are appearing here we'll try to get to

474
00:16:38,160 --> 00:16:41,600
them

475
00:16:38,560 --> 00:16:42,638
quickly if we can online uh frank davis

476
00:16:41,600 --> 00:16:44,959
is asking

477
00:16:42,639 --> 00:16:47,360
uh you're trading off providing m1 and

478
00:16:44,959 --> 00:16:48,959
m2 as well as the seed

479
00:16:47,360 --> 00:16:50,639
because they send the xor if the xor

480
00:16:48,959 --> 00:16:52,560
value in the seed

481
00:16:50,639 --> 00:16:54,000
is the xor value and the siege shorter

482
00:16:52,560 --> 00:16:57,758
than simply giving

483
00:16:54,000 --> 00:16:59,519
m1 and m2 separately yes so the seed is

484
00:16:57,759 --> 00:16:59,759
very short you should think of the seed

485
00:16:59,519 --> 00:17:02,480
as

486
00:16:59,759 --> 00:17:03,120
you know 128 bits or something whereas

487
00:17:02,480 --> 00:17:05,599
the

488
00:17:03,120 --> 00:17:06,319
m1 and m2 are proportional to the number

489
00:17:05,599 --> 00:17:07,839
of

490
00:17:06,319 --> 00:17:10,000
well in truth proportional the number of

491
00:17:07,839 --> 00:17:13,280
multiplicative gates in each

492
00:17:10,000 --> 00:17:14,000
in the circuit um times the security

493
00:17:13,280 --> 00:17:16,480
parameter

494
00:17:14,000 --> 00:17:18,400
so the material is much much longer than

495
00:17:16,480 --> 00:17:20,240
the seeds

496
00:17:18,400 --> 00:17:21,919
and in fact we showed that you in our

497
00:17:20,240 --> 00:17:23,039
paper we don't even use additional seeds

498
00:17:21,919 --> 00:17:25,039
we just use

499
00:17:23,039 --> 00:17:26,400
there's a wire which is encoding which

500
00:17:25,039 --> 00:17:28,240
branch is taken

501
00:17:26,400 --> 00:17:30,160
and we just use that wire to perform the

502
00:17:28,240 --> 00:17:32,000
encryption we use that as the seed

503
00:17:30,160 --> 00:17:34,000
so the seed sort of comes completely for

504
00:17:32,000 --> 00:17:35,600
free it's just the material that costs

505
00:17:34,000 --> 00:17:37,280
anything

506
00:17:35,600 --> 00:17:38,399
okay and maybe uh one last question

507
00:17:37,280 --> 00:17:38,720
because we're running out of time i

508
00:17:38,400 --> 00:17:40,640
think

509
00:17:38,720 --> 00:17:42,240
this one has a short answer critique is

510
00:17:40,640 --> 00:17:43,360
asking what is the assumption on the

511
00:17:42,240 --> 00:17:45,520
underlying

512
00:17:43,360 --> 00:17:47,280
uh garbling scheme the underlying

513
00:17:45,520 --> 00:17:50,080
encryption for the ground updates

514
00:17:47,280 --> 00:17:51,520
right so uh we use the underlying

515
00:17:50,080 --> 00:17:53,120
garbage scheme we formalized has to be

516
00:17:51,520 --> 00:17:55,840
so-called stackable

517
00:17:53,120 --> 00:17:56,719
and what this means basically is that uh

518
00:17:55,840 --> 00:17:58,240
the encryption

519
00:17:56,720 --> 00:18:00,160
and the labels are indistinguishable

520
00:17:58,240 --> 00:18:01,360
from a random string

521
00:18:00,160 --> 00:18:02,960
so that's that's sort of the formal

522
00:18:01,360 --> 00:18:04,399
constraint and you can re there's a few

523
00:18:02,960 --> 00:18:05,919
other things but you can read that in

524
00:18:04,400 --> 00:18:07,039
our paper but that's the main one is

525
00:18:05,919 --> 00:18:08,080
that the stuff that comes out of the

526
00:18:07,039 --> 00:18:11,600
circuit has to look

527
00:18:08,080 --> 00:18:13,199
random basically okay thank you for

528
00:18:11,600 --> 00:18:14,480
surviving the barrage of questions

529
00:18:13,200 --> 00:18:16,720
there's one more question i see in the

530
00:18:14,480 --> 00:18:19,919
zoom chat maybe you can

531
00:18:16,720 --> 00:18:23,200
handle that uh offline absolutely

532
00:18:19,919 --> 00:18:26,160
but i think it's time to move along uh

533
00:18:23,200 --> 00:18:28,160
the next talk is on better concrete

534
00:18:26,160 --> 00:18:30,880
security for half gates garbling

535
00:18:28,160 --> 00:18:31,600
in the multi-instance setting i think

536
00:18:30,880 --> 00:18:33,440
chiang kai

537
00:18:31,600 --> 00:18:34,719
is going to give the talk so whenever

538
00:18:33,440 --> 00:18:38,400
you're ready

539
00:18:34,720 --> 00:18:43,520
um please go ahead and share your screen

540
00:18:38,400 --> 00:18:45,600
yeah thank you yeah looks good

541
00:18:43,520 --> 00:18:47,520
hello i'm chinka i'm presenting our

542
00:18:45,600 --> 00:18:48,639
paper to better concrete security for

543
00:18:47,520 --> 00:18:52,080
half gates garbling

544
00:18:48,640 --> 00:18:54,640
in the multi-instance setting in this

545
00:18:52,080 --> 00:18:56,320
sorry in this paper we mainly studied

546
00:18:54,640 --> 00:18:57,440
the concrete security for half case

547
00:18:56,320 --> 00:19:00,639
garbling

548
00:18:57,440 --> 00:19:02,559
and first uh we gave an attack on the

549
00:19:00,640 --> 00:19:04,799
current healthcare implementation

550
00:19:02,559 --> 00:19:07,200
to note that it does doesn't mean that

551
00:19:04,799 --> 00:19:08,400
half case protocol is insecure but we do

552
00:19:07,200 --> 00:19:10,320
find a weakness

553
00:19:08,400 --> 00:19:12,799
when the hash functions in the half gate

554
00:19:10,320 --> 00:19:15,520
is not instantiated properly

555
00:19:12,799 --> 00:19:17,120
and also there is a problem in some

556
00:19:15,520 --> 00:19:19,679
previous papers where they

557
00:19:17,120 --> 00:19:21,760
there is a lack of concrete security

558
00:19:19,679 --> 00:19:23,360
normally they only provide a sympathetic

559
00:19:21,760 --> 00:19:26,080
security bond

560
00:19:23,360 --> 00:19:26,959
and also we gave a new abstraction of

561
00:19:26,080 --> 00:19:28,639
hash function

562
00:19:26,960 --> 00:19:30,480
which can give a better concrete

563
00:19:28,640 --> 00:19:32,080
security

564
00:19:30,480 --> 00:19:34,080
and first let me review the australia

565
00:19:32,080 --> 00:19:35,918
circuits the yao scalpel circuit see the

566
00:19:34,080 --> 00:19:38,559
tabardi competition protocol

567
00:19:35,919 --> 00:19:40,240
it allows two parties to jointly compute

568
00:19:38,559 --> 00:19:41,520
function without revealing anything

569
00:19:40,240 --> 00:19:44,640
beyond the output

570
00:19:41,520 --> 00:19:46,480
and it seriously represents a

571
00:19:44,640 --> 00:19:47,919
function as a boolean circuit with end

572
00:19:46,480 --> 00:19:49,600
and xor gates

573
00:19:47,919 --> 00:19:51,840
and half case protocol is a

574
00:19:49,600 --> 00:19:54,399
state-of-the-art goblin scheme

575
00:19:51,840 --> 00:19:56,000
it's compatible with most other

576
00:19:54,400 --> 00:19:58,320
optimizations for the half

577
00:19:56,000 --> 00:19:59,440
for the global circuits and it can

578
00:19:58,320 --> 00:20:03,039
efficiently compute

579
00:19:59,440 --> 00:20:05,919
and gate with minimal communication

580
00:20:03,039 --> 00:20:07,440
and it also uses fixed key aes with the

581
00:20:05,919 --> 00:20:09,679
goblin it means that

582
00:20:07,440 --> 00:20:11,280
it instantiates the hash functions in

583
00:20:09,679 --> 00:20:14,799
the governor table

584
00:20:11,280 --> 00:20:17,360
using the pixel fixed key aes

585
00:20:14,799 --> 00:20:19,679
and the thing is that when this hash

586
00:20:17,360 --> 00:20:23,678
function is modeled as a random oracle

587
00:20:19,679 --> 00:20:26,400
there's a tight security reduction but

588
00:20:23,679 --> 00:20:27,600
when we use my reinstantiates this using

589
00:20:26,400 --> 00:20:29,679
the

590
00:20:27,600 --> 00:20:31,039
fixed key aes then there is a gap to

591
00:20:29,679 --> 00:20:33,600
exploit

592
00:20:31,039 --> 00:20:35,280
and i'll skip the details of the attack

593
00:20:33,600 --> 00:20:37,600
and give the results of our

594
00:20:35,280 --> 00:20:39,600
implementation

595
00:20:37,600 --> 00:20:42,399
here in our analysis the attacker

596
00:20:39,600 --> 00:20:44,320
succeeds in running time to the k over c

597
00:20:42,400 --> 00:20:46,320
here the k is the b length of the label

598
00:20:44,320 --> 00:20:47,439
and the c is the number of and gates in

599
00:20:46,320 --> 00:20:50,080
the circuit

600
00:20:47,440 --> 00:20:51,440
and this attack also applies for the

601
00:20:50,080 --> 00:20:55,039
multi-instance setting

602
00:20:51,440 --> 00:20:57,760
where the adversary may receive multiple

603
00:20:55,039 --> 00:20:58,400
circuits uh which are independently

604
00:20:57,760 --> 00:21:00,240
gathered

605
00:20:58,400 --> 00:21:02,400
and this c can be the total number of

606
00:21:00,240 --> 00:21:06,080
and gates in all these circuits

607
00:21:02,400 --> 00:21:08,240
and the results show that uh even if you

608
00:21:06,080 --> 00:21:10,320
use kb label for the global circuits it

609
00:21:08,240 --> 00:21:12,640
doesn't mean you have kvs security

610
00:21:10,320 --> 00:21:14,879
for example if you use atp label with

611
00:21:12,640 --> 00:21:18,240
the circuit size of 2 to the 40 then

612
00:21:14,880 --> 00:21:21,679
this circuit can be completely broken

613
00:21:18,240 --> 00:21:24,880
and this attack also applies for uh

614
00:21:21,679 --> 00:21:27,679
the skins who use half case garbling and

615
00:21:24,880 --> 00:21:28,000
including some works may present in this

616
00:21:27,679 --> 00:21:30,880
work

617
00:21:28,000 --> 00:21:33,039
in this conference and following our

618
00:21:30,880 --> 00:21:35,360
results we estimate that we can

619
00:21:33,039 --> 00:21:36,080
uh break the circuit where using atp

620
00:21:35,360 --> 00:21:39,439
label and

621
00:21:36,080 --> 00:21:40,080
the third side to 30 in 267 machine

622
00:21:39,440 --> 00:21:42,080
months

623
00:21:40,080 --> 00:21:43,199
if we run this attack in the cloud we

624
00:21:42,080 --> 00:21:46,080
estimate well it

625
00:21:43,200 --> 00:21:48,640
only costs 3 500 dollars and this this

626
00:21:46,080 --> 00:21:50,799
attack is highly parallel so

627
00:21:48,640 --> 00:21:52,320
uh if we instantiate many machines we

628
00:21:50,799 --> 00:21:55,120
can uh

629
00:21:52,320 --> 00:21:55,918
run it simultaneously and finish its

630
00:21:55,120 --> 00:21:59,360
attack in

631
00:21:55,919 --> 00:22:01,440
a short time so how do we use this pro

632
00:21:59,360 --> 00:22:02,719
how do we fix this problem now we

633
00:22:01,440 --> 00:22:06,080
already have the

634
00:22:02,720 --> 00:22:09,280
half gates protocol and the first step

635
00:22:06,080 --> 00:22:11,280
is to design a new abstraction which

636
00:22:09,280 --> 00:22:13,280
models the use of the hash function in

637
00:22:11,280 --> 00:22:15,440
the half gauge protocol

638
00:22:13,280 --> 00:22:17,200
then in the apps in the sense of this

639
00:22:15,440 --> 00:22:18,480
abstraction we design a new hash

640
00:22:17,200 --> 00:22:21,280
function which

641
00:22:18,480 --> 00:22:23,200
can uh which satisfies all the security

642
00:22:21,280 --> 00:22:26,320
requirements from this abstraction and

643
00:22:23,200 --> 00:22:28,400
provide a better concrete security here

644
00:22:26,320 --> 00:22:32,158
are our results of the design

645
00:22:28,400 --> 00:22:34,559
in the abstraction layer we

646
00:22:32,159 --> 00:22:36,320
we design the multi-instance checkable

647
00:22:34,559 --> 00:22:37,120
circular correlation robust hash

648
00:22:36,320 --> 00:22:40,320
function

649
00:22:37,120 --> 00:22:43,039
it takes inputs input label

650
00:22:40,320 --> 00:22:44,960
a tweak i and the random bit and outputs

651
00:22:43,039 --> 00:22:47,679
a linear combination of the

652
00:22:44,960 --> 00:22:48,559
hash value and the global delta because

653
00:22:47,679 --> 00:22:52,320
we consider

654
00:22:48,559 --> 00:22:52,720
multi instances so uh here the adversary

655
00:22:52,320 --> 00:22:55,678
can

656
00:22:52,720 --> 00:22:56,720
receive few instances and this tweak i

657
00:22:55,679 --> 00:22:59,919
can be reused for

658
00:22:56,720 --> 00:23:01,120
most meal times and in the sense of this

659
00:22:59,919 --> 00:23:03,919
abstraction we design

660
00:23:01,120 --> 00:23:04,479
the hash function mmoe it takes the

661
00:23:03,919 --> 00:23:07,919
inputs

662
00:23:04,480 --> 00:23:10,240
uh the label x and the tweak i here the

663
00:23:07,919 --> 00:23:12,000
sigma x is the linear osmosis and it's a

664
00:23:10,240 --> 00:23:15,200
kind of permutation

665
00:23:12,000 --> 00:23:17,760
and this e is modeled as an ideal cipher

666
00:23:15,200 --> 00:23:19,360
the key of this ideocyber is this trick

667
00:23:17,760 --> 00:23:21,919
i

668
00:23:19,360 --> 00:23:23,760
and to further bounce the maximum reuse

669
00:23:21,919 --> 00:23:26,240
of a single tweak we

670
00:23:23,760 --> 00:23:27,360
start this eye from a random point to

671
00:23:26,240 --> 00:23:30,559
know that

672
00:23:27,360 --> 00:23:33,840
in previous fifth key aspects

673
00:23:30,559 --> 00:23:36,960
implementations uh uh they use

674
00:23:33,840 --> 00:23:38,399
a gatehead identifier i and it always

675
00:23:36,960 --> 00:23:41,679
starts from one

676
00:23:38,400 --> 00:23:44,640
here we start it from a random point and

677
00:23:41,679 --> 00:23:46,559
uh uh after embedding all these designs

678
00:23:44,640 --> 00:23:49,440
in the half gate garbling we

679
00:23:46,559 --> 00:23:51,840
can derive a new a new concrete security

680
00:23:49,440 --> 00:23:51,840
bond

681
00:23:52,480 --> 00:24:00,000
and here are the implementations of

682
00:23:56,720 --> 00:24:02,400
our hash function we make use of the

683
00:24:00,000 --> 00:24:03,600
hardware support and some precompiled

684
00:24:02,400 --> 00:24:05,600
instructions to

685
00:24:03,600 --> 00:24:07,760
accelerate these operations including

686
00:24:05,600 --> 00:24:10,000
the aes 728

687
00:24:07,760 --> 00:24:11,120
the linear osmosis and the batch the key

688
00:24:10,000 --> 00:24:13,760
scheduling

689
00:24:11,120 --> 00:24:15,439
and the table shows our the performance

690
00:24:13,760 --> 00:24:18,480
of our implementation

691
00:24:15,440 --> 00:24:22,000
in most of the situations uh

692
00:24:18,480 --> 00:24:24,159
when the band the network bandwidth is

693
00:24:22,000 --> 00:24:26,400
less than two gigabytes per second uh

694
00:24:24,159 --> 00:24:28,960
the networks do the bottom next so

695
00:24:26,400 --> 00:24:29,760
uh the pro the performance is the same

696
00:24:28,960 --> 00:24:32,480
as the

697
00:24:29,760 --> 00:24:34,480
previous implementation when the network

698
00:24:32,480 --> 00:24:36,000
resource is enough our implementation is

699
00:24:34,480 --> 00:24:38,559
just 35

700
00:24:36,000 --> 00:24:39,520
percent slower than before and we

701
00:24:38,559 --> 00:24:41,840
further optimized

702
00:24:39,520 --> 00:24:43,360
this after we published the paper and

703
00:24:41,840 --> 00:24:46,240
now they're almost the same

704
00:24:43,360 --> 00:24:47,520
so in summary we enhance the security

705
00:24:46,240 --> 00:24:51,679
and the

706
00:24:47,520 --> 00:24:51,679
make little compromise on the efficiency

707
00:24:52,880 --> 00:24:59,279
the the implementation has been the em-2

708
00:24:56,480 --> 00:25:00,720
emp 2k library and there's also links to

709
00:24:59,279 --> 00:25:06,640
the full version of the paper

710
00:25:00,720 --> 00:25:06,640
thank you thanks a lot jenki

711
00:25:06,799 --> 00:25:10,799
okay so there's a question from mike but

712
00:25:09,760 --> 00:25:12,400
before

713
00:25:10,799 --> 00:25:15,840
actually can you give an intuition of

714
00:25:12,400 --> 00:25:15,840
the attack

715
00:25:16,240 --> 00:25:20,320
so sorry can you give an intuition of

716
00:25:18,320 --> 00:25:22,080
the attack and why you have to change to

717
00:25:20,320 --> 00:25:26,158
that hash function

718
00:25:22,080 --> 00:25:29,039
yeah because because we have showed the

719
00:25:26,159 --> 00:25:30,799
explicit attack on the current uh

720
00:25:29,039 --> 00:25:33,919
off-case implementation

721
00:25:30,799 --> 00:25:36,320
um i have mentioned that uh in the

722
00:25:33,919 --> 00:25:37,919
previous works they only provides the

723
00:25:36,320 --> 00:25:41,520
sympathetic security

724
00:25:37,919 --> 00:25:43,919
and uh it's uh that's secret

725
00:25:41,520 --> 00:25:44,639
sympathetic security bond is not enough

726
00:25:43,919 --> 00:25:46,720
uh

727
00:25:44,640 --> 00:25:48,799
for instruction to use in in the

728
00:25:46,720 --> 00:25:52,159
practice

729
00:25:48,799 --> 00:25:53,760
that means when the when the uh circuit

730
00:25:52,159 --> 00:25:56,960
size is too large

731
00:25:53,760 --> 00:25:58,080
then this circuit can be completely

732
00:25:56,960 --> 00:26:02,240
broken

733
00:25:58,080 --> 00:26:06,158
so i think the motivation is that we

734
00:26:02,240 --> 00:26:10,480
have given us a an explicit attack

735
00:26:06,159 --> 00:26:11,279
which can be which can be implemented in

736
00:26:10,480 --> 00:26:14,559
the real world

737
00:26:11,279 --> 00:26:16,960
uh practice so that can

738
00:26:14,559 --> 00:26:17,840
serve as a motivation of this work i

739
00:26:16,960 --> 00:26:21,120
think

740
00:26:17,840 --> 00:26:24,720
so there's a need to provide a new

741
00:26:21,120 --> 00:26:27,279
hash function which is uh more

742
00:26:24,720 --> 00:26:28,080
secure and more simple to use fixed key

743
00:26:27,279 --> 00:26:31,279
aes

744
00:26:28,080 --> 00:26:33,120
as uh uh to which

745
00:26:31,279 --> 00:26:36,000
to design a hash function based on the

746
00:26:33,120 --> 00:26:38,239
fixed key aes

747
00:26:36,000 --> 00:26:40,559
okay yeah i was just asking why you had

748
00:26:38,240 --> 00:26:43,120
to like move to that uh has function

749
00:26:40,559 --> 00:26:43,678
but we can uh i can ask you more details

750
00:26:43,120 --> 00:26:45,360
afterwards

751
00:26:43,679 --> 00:26:47,840
in the meantime mike can you just ask

752
00:26:45,360 --> 00:26:50,559
your question online

753
00:26:47,840 --> 00:26:51,678
uh sure uh you had an attack that the

754
00:26:50,559 --> 00:26:53,840
cost was

755
00:26:51,679 --> 00:26:56,240
2 to the k divided by c and c is the

756
00:26:53,840 --> 00:26:57,760
total size of the circuit

757
00:26:56,240 --> 00:27:00,240
does it have to be a single circuit or

758
00:26:57,760 --> 00:27:01,200
does it also work across many circuits

759
00:27:00,240 --> 00:27:03,039
because in

760
00:27:01,200 --> 00:27:04,880
half gates different circuits would have

761
00:27:03,039 --> 00:27:06,879
a different

762
00:27:04,880 --> 00:27:08,559
you know correlation a different reacts

763
00:27:06,880 --> 00:27:10,960
or delta value

764
00:27:08,559 --> 00:27:12,720
does it still work in that case it works

765
00:27:10,960 --> 00:27:15,679
for multi-instance setting when

766
00:27:12,720 --> 00:27:18,000
adversaries it's multiple circuits uh

767
00:27:15,679 --> 00:27:19,679
even if they are garbled independently

768
00:27:18,000 --> 00:27:22,399
using different

769
00:27:19,679 --> 00:27:22,960
global correlations this attack can

770
00:27:22,399 --> 00:27:26,799
still

771
00:27:22,960 --> 00:27:27,520
apply and the important thing is that

772
00:27:26,799 --> 00:27:29,679
it's a

773
00:27:27,520 --> 00:27:32,639
increased chance that the attacker break

774
00:27:29,679 --> 00:27:32,640
one of the circuit

775
00:27:32,799 --> 00:27:36,639
i mean at one time when uh the attacker

776
00:27:35,600 --> 00:27:39,039
find the hit

777
00:27:36,640 --> 00:27:39,919
uh like the pre-image of the hash it can

778
00:27:39,039 --> 00:27:42,559
still only

779
00:27:39,919 --> 00:27:43,600
uh attack one of the brick one of the

780
00:27:42,559 --> 00:27:46,399
circuit not all

781
00:27:43,600 --> 00:27:48,399
not all of them but all of them can uh

782
00:27:46,399 --> 00:27:51,279
increase the chance for the attacker to

783
00:27:48,399 --> 00:27:51,279
break off them

784
00:27:52,159 --> 00:27:56,799
thanks okay thanks a lot zhenkai there

785
00:27:56,559 --> 00:27:58,240
are

786
00:27:56,799 --> 00:28:00,480
no more questions and actually we are

787
00:27:58,240 --> 00:28:04,080
right on time to move to the next talk

788
00:28:00,480 --> 00:28:04,080
thanks a lot thank you

789
00:28:04,720 --> 00:28:07,679
so next we have

790
00:28:07,919 --> 00:28:12,240
rahul who is going to talk to us about

791
00:28:10,399 --> 00:28:15,600
improved primitives for mpc

792
00:28:12,240 --> 00:28:17,440
over fixed arithmetic binary circuits

793
00:28:15,600 --> 00:28:19,520
joint world with danielle escuderos a

794
00:28:17,440 --> 00:28:22,480
tragic ghost marshal keller

795
00:28:19,520 --> 00:28:22,480
and peter shaw

796
00:28:23,200 --> 00:28:26,960
so yeah rahul whenever you are ready you

797
00:28:25,279 --> 00:28:30,159
can start

798
00:28:26,960 --> 00:28:31,120
okay um thanks for the introduction so

799
00:28:30,159 --> 00:28:32,880
this is going to be a

800
00:28:31,120 --> 00:28:35,600
quick overview about our work improved

801
00:28:32,880 --> 00:28:37,440
perimeters for mpc or mixed circuits

802
00:28:35,600 --> 00:28:39,039
so as we know in mpc we have two

803
00:28:37,440 --> 00:28:39,919
computational domains arithmetic and

804
00:28:39,039 --> 00:28:42,000
binary

805
00:28:39,919 --> 00:28:43,520
um arithmetic does well for operations

806
00:28:42,000 --> 00:28:45,200
like multiplications and the binary

807
00:28:43,520 --> 00:28:46,559
domain does well for operations like

808
00:28:45,200 --> 00:28:48,320
comparisons

809
00:28:46,559 --> 00:28:49,678
uh given that multiplications and

810
00:28:48,320 --> 00:28:51,120
comparisons are

811
00:28:49,679 --> 00:28:53,360
interleaved in applications like

812
00:28:51,120 --> 00:28:55,120
biometric matching and machine learning

813
00:28:53,360 --> 00:28:56,639
we have motivation to have efficient

814
00:28:55,120 --> 00:28:58,879
protocols that allow us to switch back

815
00:28:56,640 --> 00:29:01,520
and forth between the two domains

816
00:28:58,880 --> 00:29:03,039
works like a b y a b three etcetera have

817
00:29:01,520 --> 00:29:04,879
made progress in this direction

818
00:29:03,039 --> 00:29:06,080
by proposing frameworks that let us do

819
00:29:04,880 --> 00:29:07,520
this but

820
00:29:06,080 --> 00:29:09,120
they're usually either in the weaker

821
00:29:07,520 --> 00:29:12,720
honest majority setting or

822
00:29:09,120 --> 00:29:14,399
in the semi honest corruption setting

823
00:29:12,720 --> 00:29:15,840
the recent work of debits works in the

824
00:29:14,399 --> 00:29:17,520
dishonest priority setting with active

825
00:29:15,840 --> 00:29:19,279
security

826
00:29:17,520 --> 00:29:21,039
taking inspiration from them we propose

827
00:29:19,279 --> 00:29:23,039
a framework which works in both the

828
00:29:21,039 --> 00:29:25,600
settings

829
00:29:23,039 --> 00:29:27,360
but outperforms debits in the dishonest

830
00:29:25,600 --> 00:29:30,000
majority setting

831
00:29:27,360 --> 00:29:31,678
so these are our results at a high level

832
00:29:30,000 --> 00:29:32,960
we introduce a new cryptographic object

833
00:29:31,679 --> 00:29:35,039
called data bits

834
00:29:32,960 --> 00:29:36,720
database can be used to do conversions

835
00:29:35,039 --> 00:29:38,000
in mpc

836
00:29:36,720 --> 00:29:40,399
we have improvements to truncation and

837
00:29:38,000 --> 00:29:41,919
secure comparison protocols

838
00:29:40,399 --> 00:29:43,520
and although we support all corruption

839
00:29:41,919 --> 00:29:44,880
thresholds we observe the most gain in

840
00:29:43,520 --> 00:29:47,440
the resonance majority setting with

841
00:29:44,880 --> 00:29:49,279
active security

842
00:29:47,440 --> 00:29:50,640
so to generate error bits we propose a

843
00:29:49,279 --> 00:29:52,559
novel cut and choose protocol

844
00:29:50,640 --> 00:29:54,399
which might be of independent interest

845
00:29:52,559 --> 00:29:57,200
it works by exploiting tamper resilience

846
00:29:54,399 --> 00:29:58,639
properties of binary circuits

847
00:29:57,200 --> 00:30:00,399
and finally we implement all our

848
00:29:58,640 --> 00:30:01,120
constructions and some end-to-end

849
00:30:00,399 --> 00:30:02,399
applications

850
00:30:01,120 --> 00:30:05,120
benchmarks for which are available in

851
00:30:02,399 --> 00:30:05,520
the paper what i'd like to point out is

852
00:30:05,120 --> 00:30:08,000
that

853
00:30:05,520 --> 00:30:10,000
if we consider comparisons where we use

854
00:30:08,000 --> 00:30:11,840
up to 25 times less communication

855
00:30:10,000 --> 00:30:13,200
and we have up to 47 times higher

856
00:30:11,840 --> 00:30:16,320
throughput than previous

857
00:30:13,200 --> 00:30:19,440
state-of-the-art which is debits

858
00:30:16,320 --> 00:30:22,158
so an ira bit is an extended debit

859
00:30:19,440 --> 00:30:23,279
it is it consists of m random bits which

860
00:30:22,159 --> 00:30:24,720
are shared over f2

861
00:30:23,279 --> 00:30:26,320
and their corresponding value shared

862
00:30:24,720 --> 00:30:29,919
over side m where m is

863
00:30:26,320 --> 00:30:32,799
either a prime order field or a ring

864
00:30:29,919 --> 00:30:33,600
so to generate ewbits were generated

865
00:30:32,799 --> 00:30:35,520
incrementally

866
00:30:33,600 --> 00:30:37,039
with the bits where we first batch

867
00:30:35,520 --> 00:30:39,120
produce a large number of debits and

868
00:30:37,039 --> 00:30:41,200
combine them to make an error bit

869
00:30:39,120 --> 00:30:42,399
our approach was to instead generate a

870
00:30:41,200 --> 00:30:44,720
bits directly

871
00:30:42,399 --> 00:30:46,639
and the advantage of doing so is that we

872
00:30:44,720 --> 00:30:48,000
can use cheap 40 base multiplications

873
00:30:46,640 --> 00:30:49,840
over f2

874
00:30:48,000 --> 00:30:51,039
instead of more expensive or more

875
00:30:49,840 --> 00:30:53,120
homomorphic encryption based

876
00:30:51,039 --> 00:30:54,799
multiplications

877
00:30:53,120 --> 00:30:57,120
as a result of this if we consider the

878
00:30:54,799 --> 00:30:58,960
active security case with two parties

879
00:30:57,120 --> 00:31:01,678
we are up to three to four times faster

880
00:30:58,960 --> 00:31:03,360
than debits

881
00:31:01,679 --> 00:31:04,960
so this is how we generate error bits at

882
00:31:03,360 --> 00:31:07,360
a high level

883
00:31:04,960 --> 00:31:08,320
each party secret shares a set of data

884
00:31:07,360 --> 00:31:10,000
bits

885
00:31:08,320 --> 00:31:12,639
we run a cut and choose protocol on each

886
00:31:10,000 --> 00:31:14,960
of these sets what we get as a result is

887
00:31:12,640 --> 00:31:16,240
verified priority debits but we can't

888
00:31:14,960 --> 00:31:18,000
use them directly because

889
00:31:16,240 --> 00:31:19,840
the party that proposes the set also

890
00:31:18,000 --> 00:31:21,840
knows the underlying values

891
00:31:19,840 --> 00:31:24,158
so we take one error bit from each party

892
00:31:21,840 --> 00:31:26,320
and we we add them using a

893
00:31:24,159 --> 00:31:27,919
binary circuit at the end we get

894
00:31:26,320 --> 00:31:30,399
verified global leader bits which we can

895
00:31:27,919 --> 00:31:32,640
then use

896
00:31:30,399 --> 00:31:34,719
so the current protocol requires a few

897
00:31:32,640 --> 00:31:35,440
tweaks as compared to the original one

898
00:31:34,720 --> 00:31:37,200
because

899
00:31:35,440 --> 00:31:39,519
that one was built for multiplication

900
00:31:37,200 --> 00:31:41,600
triples which have a linear relationship

901
00:31:39,519 --> 00:31:43,120
whereas eta bits have a non-linear

902
00:31:41,600 --> 00:31:44,559
relationship

903
00:31:43,120 --> 00:31:46,399
this means we need some auxiliary

904
00:31:44,559 --> 00:31:48,559
information and in this case we use

905
00:31:46,399 --> 00:31:50,479
triangulated triples

906
00:31:48,559 --> 00:31:51,840
so the naive approach would be to

907
00:31:50,480 --> 00:31:54,480
generate secure triples

908
00:31:51,840 --> 00:31:56,399
and using a process like current shoes

909
00:31:54,480 --> 00:31:58,240
and use them for either bits

910
00:31:56,399 --> 00:31:59,439
our approach was to instead have the

911
00:31:58,240 --> 00:32:00,559
part b that proposes the set of

912
00:31:59,440 --> 00:32:02,240
triangular triple

913
00:32:00,559 --> 00:32:03,840
set of ear bits also propose the

914
00:32:02,240 --> 00:32:05,519
required time you to triples

915
00:32:03,840 --> 00:32:07,439
and use them without verifying for

916
00:32:05,519 --> 00:32:09,360
correctness

917
00:32:07,440 --> 00:32:10,640
in the paper we analyze this version of

918
00:32:09,360 --> 00:32:12,158
cut and choose and prove that

919
00:32:10,640 --> 00:32:14,960
this doesn't give the adversary any

920
00:32:12,159 --> 00:32:17,039
additional advantage

921
00:32:14,960 --> 00:32:19,440
so this is the modified game which uses

922
00:32:17,039 --> 00:32:22,158
unreliable triples

923
00:32:19,440 --> 00:32:22,720
each party pi proposes a set of beta

924
00:32:22,159 --> 00:32:25,440
bits

925
00:32:22,720 --> 00:32:26,840
and the required ionutor triples we

926
00:32:25,440 --> 00:32:28,399
shuffle them using two public

927
00:32:26,840 --> 00:32:30,959
permutations

928
00:32:28,399 --> 00:32:32,239
we open c era bits and c prime sets of

929
00:32:30,960 --> 00:32:34,000
fine order triples

930
00:32:32,240 --> 00:32:36,320
and verify for correctness if any of

931
00:32:34,000 --> 00:32:37,919
them fail then we abort

932
00:32:36,320 --> 00:32:40,240
otherwise we take the remaining ones and

933
00:32:37,919 --> 00:32:42,159
place them into buckets

934
00:32:40,240 --> 00:32:43,760
and we carry out a bucket check protocol

935
00:32:42,159 --> 00:32:46,000
within each bucket

936
00:32:43,760 --> 00:32:47,840
we select the top lead a bit and perform

937
00:32:46,000 --> 00:32:48,880
a pairwise check with every other error

938
00:32:47,840 --> 00:32:51,519
bit in the bucket

939
00:32:48,880 --> 00:32:52,399
using the time utility triples if all of

940
00:32:51,519 --> 00:32:54,799
the checks

941
00:32:52,399 --> 00:32:58,479
pass then we output the top either bit

942
00:32:54,799 --> 00:32:58,480
as a verified private enterprise

943
00:32:59,840 --> 00:33:03,918
so analyzing this game gets us the

944
00:33:01,919 --> 00:33:06,960
following parameters

945
00:33:03,919 --> 00:33:08,799
for 40 statistical security we get

946
00:33:06,960 --> 00:33:10,240
we we found that we only have to open

947
00:33:08,799 --> 00:33:12,399
three either bits and

948
00:33:10,240 --> 00:33:14,000
three sets of tiny triples if you have a

949
00:33:12,399 --> 00:33:16,000
bucket size of three and we

950
00:33:14,000 --> 00:33:17,440
we generate either bits in the order of

951
00:33:16,000 --> 00:33:18,960
a million

952
00:33:17,440 --> 00:33:20,320
this is analogous to the original kind

953
00:33:18,960 --> 00:33:22,080
of choose game for multiplication

954
00:33:20,320 --> 00:33:24,158
triples where we have to open

955
00:33:22,080 --> 00:33:26,639
three multiplication triples for 40-bit

956
00:33:24,159 --> 00:33:26,640
security

957
00:33:27,919 --> 00:33:32,480
as i mentioned we have improvements to

958
00:33:29,519 --> 00:33:34,960
comparison and truncation using databits

959
00:33:32,480 --> 00:33:37,600
our constructions work over signed and

960
00:33:34,960 --> 00:33:39,440
unsigned data types

961
00:33:37,600 --> 00:33:41,279
we've benchmarked some end-to-end

962
00:33:39,440 --> 00:33:43,360
applications like logistic regression

963
00:33:41,279 --> 00:33:44,720
and convolutional neural networks

964
00:33:43,360 --> 00:33:47,120
the benchmarks for which are available

965
00:33:44,720 --> 00:33:48,559
in the full version of the talk

966
00:33:47,120 --> 00:33:50,959
and the code is available as a part of

967
00:33:48,559 --> 00:33:53,039
the mps library

968
00:33:50,960 --> 00:33:54,960
so i'm just going to conclude by showing

969
00:33:53,039 --> 00:33:57,360
um these benchmarks

970
00:33:54,960 --> 00:33:59,120
uh basically if we consider the

971
00:33:57,360 --> 00:34:01,120
dishonest majority case with two parties

972
00:33:59,120 --> 00:34:02,719
and active corruption

973
00:34:01,120 --> 00:34:04,559
then we are about three to five times

974
00:34:02,720 --> 00:34:05,840
better than debits if you consider the

975
00:34:04,559 --> 00:34:06,639
number of comparisons we can do per

976
00:34:05,840 --> 00:34:08,480
second

977
00:34:06,640 --> 00:34:10,000
and about five times better if we

978
00:34:08,480 --> 00:34:12,240
consider the communication cost per

979
00:34:10,000 --> 00:34:14,159
comparison

980
00:34:12,239 --> 00:34:15,279
so that was a quick overview of your

981
00:34:14,159 --> 00:34:20,320
bits and

982
00:34:15,280 --> 00:34:23,679
thank you i'm ready to take questions

983
00:34:20,320 --> 00:34:24,480
thanks rahul um if anyone has questions

984
00:34:23,679 --> 00:34:27,679
go ahead and

985
00:34:24,480 --> 00:34:29,520
uh ask them here uh

986
00:34:27,679 --> 00:34:31,599
in the meantime i had a question about

987
00:34:29,520 --> 00:34:34,639
your last slide where you showed some

988
00:34:31,599 --> 00:34:38,159
uh some empirical

989
00:34:34,639 --> 00:34:42,560
improvements uh yeah improvement factor

990
00:34:38,159 --> 00:34:45,919
20 to 60 x um are you just talking about

991
00:34:42,560 --> 00:34:48,799
the raw generation of these ada bits or

992
00:34:45,918 --> 00:34:50,078
uh or do you have like a an application

993
00:34:48,800 --> 00:34:52,079
in mind where

994
00:34:50,079 --> 00:34:53,760
the ability to switch from arithmetic to

995
00:34:52,079 --> 00:34:57,359
boolean is like a killer

996
00:34:53,760 --> 00:34:59,520
feature yeah so 20 to 60 is uh

997
00:34:57,359 --> 00:35:01,040
considering all setting all of our

998
00:34:59,520 --> 00:35:02,720
end-to-end applications i believe

999
00:35:01,040 --> 00:35:04,240
like logistic regression and the other

1000
00:35:02,720 --> 00:35:07,680
ones we've benchmarked it's not

1001
00:35:04,240 --> 00:35:07,680
the generation of database itself

1002
00:35:07,760 --> 00:35:10,960
i see so that's the whole the whole

1003
00:35:08,880 --> 00:35:12,640
protocol is improved even offline and

1004
00:35:10,960 --> 00:35:14,720
online phases

1005
00:35:12,640 --> 00:35:18,078
yeah i believe this is uh considering

1006
00:35:14,720 --> 00:35:18,078
the total communication

1007
00:35:18,320 --> 00:35:26,160
okay um i also was wondering um

1008
00:35:22,720 --> 00:35:27,118
how the conversion from uh from boolean

1009
00:35:26,160 --> 00:35:29,920
to and from

1010
00:35:27,119 --> 00:35:32,000
uh arithmetic does that affect the round

1011
00:35:29,920 --> 00:35:34,880
complexity

1012
00:35:32,000 --> 00:35:34,880
in the online phase

1013
00:35:37,040 --> 00:35:43,119
as opposed to using debits you mean

1014
00:35:40,079 --> 00:35:43,119
uh just in general

1015
00:35:43,440 --> 00:35:48,720
but sure in comparison to the prior work

1016
00:35:46,400 --> 00:35:48,720
as well

1017
00:35:49,359 --> 00:35:55,200
yeah i'm not not really uh i don't have

1018
00:35:53,119 --> 00:35:56,160
the numbers on the top of my head maybe

1019
00:35:55,200 --> 00:36:00,879
one of the other

1020
00:35:56,160 --> 00:36:00,879
co-authors can answer if they're online

1021
00:36:02,640 --> 00:36:08,640
okay in the media yeah peter hey

1022
00:36:06,960 --> 00:36:10,640
yeah so the conversion in the online

1023
00:36:08,640 --> 00:36:11,279
phase is just the same as previous works

1024
00:36:10,640 --> 00:36:12,720
using a

1025
00:36:11,280 --> 00:36:14,320
binary circuit so then the round

1026
00:36:12,720 --> 00:36:15,598
complexity depends on the depth of the

1027
00:36:14,320 --> 00:36:17,200
circuit

1028
00:36:15,599 --> 00:36:20,160
unless you do it using double circuits

1029
00:36:17,200 --> 00:36:20,160
to get a constant round

1030
00:36:20,560 --> 00:36:25,520
okay thanks

1031
00:36:23,599 --> 00:36:26,960
i see a question in the chat from how

1032
00:36:25,520 --> 00:36:28,880
chen does

1033
00:36:26,960 --> 00:36:31,119
does this work improve truncation and

1034
00:36:28,880 --> 00:36:33,280
comparison in the semi-honest setting as

1035
00:36:31,119 --> 00:36:33,280
well

1036
00:36:39,839 --> 00:36:43,119
in the seminar setting i think we're

1037
00:36:41,839 --> 00:36:44,960
about um

1038
00:36:43,119 --> 00:36:46,560
we've benchmarked for concrete

1039
00:36:44,960 --> 00:36:48,079
applications and

1040
00:36:46,560 --> 00:36:51,279
i think we're about we matched the

1041
00:36:48,079 --> 00:36:53,359
performance of uh something like aby3

1042
00:36:51,280 --> 00:36:56,480
i don't really remember the figures for

1043
00:36:53,359 --> 00:36:56,480
semi honest security though

1044
00:36:59,200 --> 00:37:02,560
this is muscle here if i can say briefly

1045
00:37:02,160 --> 00:37:04,640
uh

1046
00:37:02,560 --> 00:37:06,640
it's not it doesn't really improve on

1047
00:37:04,640 --> 00:37:08,078
apy3 because that uses like very

1048
00:37:06,640 --> 00:37:12,078
specific tricks

1049
00:37:08,079 --> 00:37:13,760
but it does improve as far as i know on

1050
00:37:12,079 --> 00:37:16,320
other settings like

1051
00:37:13,760 --> 00:37:17,359
shamia secret sharing because they're

1052
00:37:16,320 --> 00:37:18,880
like no that may

1053
00:37:17,359 --> 00:37:23,839
know that many special tricks you can

1054
00:37:18,880 --> 00:37:23,839
use with chameleon secret sharing

1055
00:37:25,599 --> 00:37:30,800
okay great um and i think uh

1056
00:37:29,119 --> 00:37:33,200
i think antigone also has a question

1057
00:37:30,800 --> 00:37:35,440
that she can ask

1058
00:37:33,200 --> 00:37:36,560
yeah thanks mike so with comparison

1059
00:37:35,440 --> 00:37:40,079
protocol you are

1060
00:37:36,560 --> 00:37:40,880
uh you are improving upon was it the one

1061
00:37:40,079 --> 00:37:43,040
in aby

1062
00:37:40,880 --> 00:37:45,839
or which one are you comparing against

1063
00:37:43,040 --> 00:37:45,839
for these numbers

1064
00:37:48,560 --> 00:37:52,160
the comparison protocol the truncation

1065
00:37:50,480 --> 00:37:56,000
comparison i think they come from this

1066
00:37:52,160 --> 00:37:59,920
uh paper by katrina and uh

1067
00:37:56,000 --> 00:38:02,240
sebastian i think so those are the ones

1068
00:37:59,920 --> 00:38:02,240
we've

1069
00:38:02,839 --> 00:38:06,560
implemented

1070
00:38:04,960 --> 00:38:10,079
okay if you can paste in the chat i

1071
00:38:06,560 --> 00:38:13,040
don't know which one you're referring to

1072
00:38:10,079 --> 00:38:13,040
okay thank you

1073
00:38:15,520 --> 00:38:18,880
okay i don't i don't see any other

1074
00:38:17,359 --> 00:38:21,759
questions queued up

1075
00:38:18,880 --> 00:38:23,599
and we're exactly at the end of time so

1076
00:38:21,760 --> 00:38:25,760
that's the end of the session uh

1077
00:38:23,599 --> 00:38:27,520
thanks to all the speakers i've seen in

1078
00:38:25,760 --> 00:38:29,680
the other sessions everyone unmutes and

1079
00:38:27,520 --> 00:38:33,839
claps so we can we can do that

1080
00:38:29,680 --> 00:38:33,839
that's kind of fun

1081
00:38:35,010 --> 00:38:38,349
[Applause]

1082
00:38:40,560 --> 00:38:44,160
thanks to all the speakers uh thanks to

1083
00:38:42,480 --> 00:38:47,200
everyone for asking questions

1084
00:38:44,160 --> 00:38:49,440
if you haven't gotten enough mpc

1085
00:38:47,200 --> 00:38:51,118
then stick around in 10 minutes the next

1086
00:38:49,440 --> 00:38:54,400
mpc session will start

1087
00:38:51,119 --> 00:38:54,400
and i hope to see you all there

