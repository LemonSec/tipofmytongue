1
00:00:02,240 --> 00:00:05,200
hi everyone

2
00:00:03,360 --> 00:00:06,798
i'm kevin i'm researching from google

3
00:00:05,200 --> 00:00:07,759
and today i'll talk to you guys about a

4
00:00:06,799 --> 00:00:09,679
new recent work

5
00:00:07,759 --> 00:00:11,440
on lower bounds for encrypted multi-maps

6
00:00:09,679 --> 00:00:13,120
and circuit checkable encryption

7
00:00:11,440 --> 00:00:14,639
in a new model that we call the leakage

8
00:00:13,120 --> 00:00:16,320
software model

9
00:00:14,639 --> 00:00:18,320
this is a joint work with my fabulous uh

10
00:00:16,320 --> 00:00:19,119
collaborators sarver patel and pino

11
00:00:18,320 --> 00:00:20,480
perciano

12
00:00:19,119 --> 00:00:23,039
from google and the university of

13
00:00:20,480 --> 00:00:25,279
siliconangle respectively

14
00:00:23,039 --> 00:00:26,720
all right so let's get into it so the

15
00:00:25,279 --> 00:00:27,840
problem we're trying to solve in this in

16
00:00:26,720 --> 00:00:28,720
this scenario the problem we're

17
00:00:27,840 --> 00:00:30,560
considering

18
00:00:28,720 --> 00:00:32,320
is sort of a user or data owner that

19
00:00:30,560 --> 00:00:34,960
wishes to outsource

20
00:00:32,320 --> 00:00:35,440
its data to a third party that on the

21
00:00:34,960 --> 00:00:39,200
right

22
00:00:35,440 --> 00:00:40,239
or a server that's potentially untrusted

23
00:00:39,200 --> 00:00:42,399
and he wants to do it in sort of a

24
00:00:40,239 --> 00:00:42,959
privacy preserving way and sort of so

25
00:00:42,399 --> 00:00:44,239
let's suppose

26
00:00:42,960 --> 00:00:46,480
let's consider an example where let's

27
00:00:44,239 --> 00:00:47,919
say the user has has already uploaded a

28
00:00:46,480 --> 00:00:50,398
map or a key value store

29
00:00:47,920 --> 00:00:51,440
keys associated with values so what

30
00:00:50,399 --> 00:00:53,600
happens is let's suppose

31
00:00:51,440 --> 00:00:55,039
the user wants to query for a ki it

32
00:00:53,600 --> 00:00:55,920
might send it in plain text and when it

33
00:00:55,039 --> 00:00:58,640
gets

34
00:00:55,920 --> 00:00:59,600
their associated tuple vi so what i

35
00:00:58,640 --> 00:01:03,120
guess i want to get to

36
00:00:59,600 --> 00:01:06,080
quickly sort of even if all the values

37
00:01:03,120 --> 00:01:08,080
were encrypted using a client-side key

38
00:01:06,080 --> 00:01:09,119
during sort of these queries or requests

39
00:01:08,080 --> 00:01:11,039
by the user

40
00:01:09,119 --> 00:01:13,040
the server will learn which key was

41
00:01:11,040 --> 00:01:15,040
being queried

42
00:01:13,040 --> 00:01:16,400
so okay it might learn it for a single

43
00:01:15,040 --> 00:01:16,799
for a single query it might not seem so

44
00:01:16,400 --> 00:01:18,640
bad

45
00:01:16,799 --> 00:01:20,240
but over a large sequence of operations

46
00:01:18,640 --> 00:01:21,840
of queries and inserts

47
00:01:20,240 --> 00:01:24,080
the server will get more statistics and

48
00:01:21,840 --> 00:01:25,040
more comp and more detailed information

49
00:01:24,080 --> 00:01:26,798
so for example

50
00:01:25,040 --> 00:01:28,080
things like maybe the second key was

51
00:01:26,799 --> 00:01:30,079
never queried

52
00:01:28,080 --> 00:01:31,200
and the 15th key was the most frequently

53
00:01:30,079 --> 00:01:33,919
queried uh

54
00:01:31,200 --> 00:01:36,079
key and sort of it's been shown in the

55
00:01:33,920 --> 00:01:38,320
past that using this sort of complex

56
00:01:36,079 --> 00:01:39,839
information it can be it can be used to

57
00:01:38,320 --> 00:01:41,119
try to understand what data is being

58
00:01:39,840 --> 00:01:41,840
outsourced even if the values are

59
00:01:41,119 --> 00:01:43,759
encrypted

60
00:01:41,840 --> 00:01:45,439
using a client-side key and also it can

61
00:01:43,759 --> 00:01:47,600
also learn what kind of intent or

62
00:01:45,439 --> 00:01:50,720
algorithm the user is trying to run

63
00:01:47,600 --> 00:01:52,880
by by just looking at these keys

64
00:01:50,720 --> 00:01:54,000
so in an ideal world what we would like

65
00:01:52,880 --> 00:01:56,000
is something like the following

66
00:01:54,000 --> 00:01:57,360
where the user gets a ki and wants a

67
00:01:56,000 --> 00:01:59,200
query maybe it does

68
00:01:57,360 --> 00:02:01,360
a sequence of complicated uh sort of

69
00:01:59,200 --> 00:02:03,439
retrievals from the server

70
00:02:01,360 --> 00:02:05,200
is able to get that the tuple of values

71
00:02:03,439 --> 00:02:06,559
bi associated with ki

72
00:02:05,200 --> 00:02:08,399
but it does it in such a way that the

73
00:02:06,560 --> 00:02:10,800
server doesn't know what the requested

74
00:02:08,399 --> 00:02:10,800
key is

75
00:02:10,878 --> 00:02:14,319
all right so try to try to understand to

76
00:02:12,560 --> 00:02:15,520
to further understand this problem what

77
00:02:14,319 --> 00:02:17,679
we can do is consider this

78
00:02:15,520 --> 00:02:19,360
this map data structure and consider the

79
00:02:17,680 --> 00:02:22,560
privacy spectrum that's achieved

80
00:02:19,360 --> 00:02:23,840
by various uh solutions so sort of the

81
00:02:22,560 --> 00:02:25,360
most basic solution is

82
00:02:23,840 --> 00:02:26,720
what we call plain text maps or we

83
00:02:25,360 --> 00:02:28,160
usually just call this map data

84
00:02:26,720 --> 00:02:30,160
structures

85
00:02:28,160 --> 00:02:31,519
you know this has been a this has been a

86
00:02:30,160 --> 00:02:32,720
very classic problem so it's actually

87
00:02:31,519 --> 00:02:34,800
called the dictionary problem

88
00:02:32,720 --> 00:02:36,080
in many years ago and it's been

89
00:02:34,800 --> 00:02:37,360
considered for a long period of time and

90
00:02:36,080 --> 00:02:39,040
it's been solved very well so there's

91
00:02:37,360 --> 00:02:41,200
many solutions such as perfect hashing

92
00:02:39,040 --> 00:02:42,799
the fps hashing scheme and cuckoo

93
00:02:41,200 --> 00:02:44,799
hashing and many many more

94
00:02:42,800 --> 00:02:46,879
but sort of what you get with these

95
00:02:44,800 --> 00:02:47,519
plaintext maps is the constant overhead

96
00:02:46,879 --> 00:02:48,720
so

97
00:02:47,519 --> 00:02:51,599
you know when you want to retrieve a key

98
00:02:48,720 --> 00:02:52,879
ki for a value for for values vi

99
00:02:51,599 --> 00:02:55,200
you would get you know that value

100
00:02:52,879 --> 00:02:56,799
associated with that key and similarly

101
00:02:55,200 --> 00:02:58,238
it only requires order and storage if

102
00:02:56,800 --> 00:03:00,080
you have n if you want to store a

103
00:02:58,239 --> 00:03:01,280
key consist a table consisting of n keys

104
00:03:00,080 --> 00:03:04,000
and values

105
00:03:01,280 --> 00:03:05,599
you only require order and storage on

106
00:03:04,000 --> 00:03:07,680
the other hand in terms of privacy

107
00:03:05,599 --> 00:03:09,440
it ends up leaking all keys and values

108
00:03:07,680 --> 00:03:12,000
because there's no privacy was not even

109
00:03:09,440 --> 00:03:13,920
a requirement for this case

110
00:03:12,000 --> 00:03:16,480
so we can so what we can then do is

111
00:03:13,920 --> 00:03:18,799
consider a slightly is a different uh

112
00:03:16,480 --> 00:03:20,079
primitive called structured encryption

113
00:03:18,800 --> 00:03:21,920
so this will obviously

114
00:03:20,080 --> 00:03:23,840
have stronger privacy but slightly less

115
00:03:21,920 --> 00:03:25,599
efficiency

116
00:03:23,840 --> 00:03:27,120
so what is structured encryption sort of

117
00:03:25,599 --> 00:03:27,920
the idea is to encrypt the data

118
00:03:27,120 --> 00:03:30,080
structure

119
00:03:27,920 --> 00:03:31,839
while maintaining its operations so the

120
00:03:30,080 --> 00:03:33,200
classical example has been very heavily

121
00:03:31,840 --> 00:03:33,920
studied is this idea of searchable

122
00:03:33,200 --> 00:03:35,518
encryption

123
00:03:33,920 --> 00:03:36,720
where you're essentially encrypting a

124
00:03:35,519 --> 00:03:37,360
search index while maintaining the

125
00:03:36,720 --> 00:03:39,519
operations

126
00:03:37,360 --> 00:03:40,879
of the search index and there's many

127
00:03:39,519 --> 00:03:42,000
works in the past two decades i've

128
00:03:40,879 --> 00:03:44,000
listed here that consider you know

129
00:03:42,000 --> 00:03:45,280
static dynamic and various privacy

130
00:03:44,000 --> 00:03:47,120
settings

131
00:03:45,280 --> 00:03:48,640
but sort of at a high level what is

132
00:03:47,120 --> 00:03:49,519
obtained by structured encryption for

133
00:03:48,640 --> 00:03:51,119
maps

134
00:03:49,519 --> 00:03:52,480
is you sort of typically get order one

135
00:03:51,120 --> 00:03:54,000
efficiency but of course it can be

136
00:03:52,480 --> 00:03:55,200
higher depending on the leakage function

137
00:03:54,000 --> 00:03:57,519
that you get

138
00:03:55,200 --> 00:03:58,879
and the privacy is obviously it doesn't

139
00:03:57,519 --> 00:03:59,439
leak everything above the keys and

140
00:03:58,879 --> 00:04:01,840
values

141
00:03:59,439 --> 00:04:03,200
but it leaks some sort of well-defined

142
00:04:01,840 --> 00:04:05,439
leakage function that contains

143
00:04:03,200 --> 00:04:06,798
various components so things like the

144
00:04:05,439 --> 00:04:07,519
number of values that are associated

145
00:04:06,799 --> 00:04:09,760
with keys

146
00:04:07,519 --> 00:04:11,280
for example you might learn key equality

147
00:04:09,760 --> 00:04:12,879
between operations which we'll get to a

148
00:04:11,280 --> 00:04:14,000
little more later but it's sort of

149
00:04:12,879 --> 00:04:16,000
learning whether two operations are

150
00:04:14,000 --> 00:04:17,358
performing the same key and so you might

151
00:04:16,000 --> 00:04:19,519
also learn the number of operations the

152
00:04:17,358 --> 00:04:21,358
user performs

153
00:04:19,519 --> 00:04:23,199
so sort of this is uh on the spectrum

154
00:04:21,358 --> 00:04:25,120
this is sort of a slightly more less

155
00:04:23,199 --> 00:04:27,280
slightly more private but less efficient

156
00:04:25,120 --> 00:04:28,960
primitive so finally to complete the

157
00:04:27,280 --> 00:04:30,000
spectrum we can go even further to the

158
00:04:28,960 --> 00:04:31,758
right and consider something

159
00:04:30,000 --> 00:04:33,040
that's much more private but much less

160
00:04:31,759 --> 00:04:34,639
efficient which

161
00:04:33,040 --> 00:04:36,560
which is the which is which can be built

162
00:04:34,639 --> 00:04:38,000
from things like oblivious rams

163
00:04:36,560 --> 00:04:39,199
so what is an oblivious ram essentially

164
00:04:38,000 --> 00:04:41,040
it was introduced by goldberg and

165
00:04:39,199 --> 00:04:44,160
ostrovsky in in the 90s

166
00:04:41,040 --> 00:04:45,360
there's been many works that uh

167
00:04:44,160 --> 00:04:47,040
you know that led to something of the

168
00:04:45,360 --> 00:04:48,160
order log and optimal overhead

169
00:04:47,040 --> 00:04:49,759
constructions

170
00:04:48,160 --> 00:04:51,360
but sort of what happens is they can

171
00:04:49,759 --> 00:04:52,800
actually in an oblivious round can

172
00:04:51,360 --> 00:04:55,120
actually implement a map

173
00:04:52,800 --> 00:04:56,720
using log n overhead and this turns out

174
00:04:55,120 --> 00:04:58,000
to be tight and based on lower bounds

175
00:04:56,720 --> 00:05:00,560
and various models that are

176
00:04:58,000 --> 00:05:01,120
over the past couple decades but for

177
00:05:00,560 --> 00:05:02,720
privacy

178
00:05:01,120 --> 00:05:04,400
what you end up getting is something

179
00:05:02,720 --> 00:05:05,759
very very strong

180
00:05:04,400 --> 00:05:07,520
what it turns out is that the adversary

181
00:05:05,759 --> 00:05:08,320
cannot distinguish any two sequences of

182
00:05:07,520 --> 00:05:10,320
the same length

183
00:05:08,320 --> 00:05:11,840
that could have been performed by the

184
00:05:10,320 --> 00:05:13,360
user

185
00:05:11,840 --> 00:05:14,638
so you know translating this to the to

186
00:05:13,360 --> 00:05:16,000
the world of leakage functions what

187
00:05:14,639 --> 00:05:18,000
essentially it says is that

188
00:05:16,000 --> 00:05:19,440
the leakage functions is only of either

189
00:05:18,000 --> 00:05:21,360
the length of the operational sequence

190
00:05:19,440 --> 00:05:24,080
or an upper bound of the

191
00:05:21,360 --> 00:05:24,800
operational sequence so in essence what

192
00:05:24,080 --> 00:05:26,800
happens is

193
00:05:24,800 --> 00:05:28,160
you sort of have this the spectrum where

194
00:05:26,800 --> 00:05:29,120
you know the left is the most efficient

195
00:05:28,160 --> 00:05:30,880
but the least private

196
00:05:29,120 --> 00:05:32,560
and as you move to the right you get

197
00:05:30,880 --> 00:05:35,039
less you trade efficiency for more

198
00:05:32,560 --> 00:05:35,039
privacy

199
00:05:35,120 --> 00:05:38,080
all right so in this work what we're

200
00:05:36,639 --> 00:05:39,680
really going to focus on is actually

201
00:05:38,080 --> 00:05:41,039
this area between structured encryption

202
00:05:39,680 --> 00:05:42,639
and oblivious ram

203
00:05:41,039 --> 00:05:44,719
as you can see there is a there's a gap

204
00:05:42,639 --> 00:05:46,400
in efficiency from constant to log n

205
00:05:44,720 --> 00:05:48,160
and similarly for leakage for privacy

206
00:05:46,400 --> 00:05:50,159
where oblivious rams are

207
00:05:48,160 --> 00:05:52,160
in some ways the ideal or the optimal

208
00:05:50,160 --> 00:05:53,759
privacy whereas the structured

209
00:05:52,160 --> 00:05:55,440
encryption ends up leaking some very

210
00:05:53,759 --> 00:05:57,600
non-trivial very

211
00:05:55,440 --> 00:05:59,360
informative leakage that the adversary

212
00:05:57,600 --> 00:06:00,240
could use to try to get information to

213
00:05:59,360 --> 00:06:02,560
try to

214
00:06:00,240 --> 00:06:03,520
compromise the data and what we're

215
00:06:02,560 --> 00:06:04,240
essentially trying to do is trying to

216
00:06:03,520 --> 00:06:07,198
figure out

217
00:06:04,240 --> 00:06:07,919
how this how this sort of ramp goes is

218
00:06:07,199 --> 00:06:10,400
it sort of

219
00:06:07,919 --> 00:06:11,599
a direct jump are are there more things

220
00:06:10,400 --> 00:06:12,080
here that are there more things we can

221
00:06:11,600 --> 00:06:13,919
construct

222
00:06:12,080 --> 00:06:16,080
that are have less than log and

223
00:06:13,919 --> 00:06:18,799
efficiency but better privacy than

224
00:06:16,080 --> 00:06:20,639
the structured encryption schemes of

225
00:06:18,800 --> 00:06:22,800
course to study this i stuff i have to

226
00:06:20,639 --> 00:06:24,319
i sort of have to tell you what

227
00:06:22,800 --> 00:06:25,360
structured encryption actually obtained

228
00:06:24,319 --> 00:06:28,080
because right now i've just said it's a

229
00:06:25,360 --> 00:06:30,319
non-trivial leakage function

230
00:06:28,080 --> 00:06:32,080
so it turns out that structured

231
00:06:30,319 --> 00:06:33,120
encryption can actually be defined using

232
00:06:32,080 --> 00:06:35,440
a very simple

233
00:06:33,120 --> 00:06:36,800
hashing encrypting pilot or many of

234
00:06:35,440 --> 00:06:38,719
these uh structured encryption

235
00:06:36,800 --> 00:06:40,400
uh schemes so the idea of a hash

236
00:06:38,720 --> 00:06:41,600
encrypting file is to take any playtex

237
00:06:40,400 --> 00:06:44,000
operations with let's say

238
00:06:41,600 --> 00:06:45,199
three operations insert keys values get

239
00:06:44,000 --> 00:06:46,560
keys delete keys

240
00:06:45,199 --> 00:06:48,479
you know these are this is a plain text

241
00:06:46,560 --> 00:06:50,160
map that has that's only trying to

242
00:06:48,479 --> 00:06:53,039
to get to to implement these operations

243
00:06:50,160 --> 00:06:56,080
efficiently and without any privacy

244
00:06:53,039 --> 00:06:57,680
so for example let's suppose uh we we've

245
00:06:56,080 --> 00:06:58,880
implemented this using a plane using the

246
00:06:57,680 --> 00:07:00,000
keys and values and plain text that we

247
00:06:58,880 --> 00:07:01,520
did before

248
00:07:00,000 --> 00:07:03,039
so the idea of the hash encrypt compiler

249
00:07:01,520 --> 00:07:05,120
is sort of simply

250
00:07:03,039 --> 00:07:06,800
store a client-side private key that

251
00:07:05,120 --> 00:07:09,039
consists of actually two keys of a hash

252
00:07:06,800 --> 00:07:11,599
key and an encryption key

253
00:07:09,039 --> 00:07:13,680
and simply replace each of the keys with

254
00:07:11,599 --> 00:07:15,680
the hash of the key

255
00:07:13,680 --> 00:07:19,199
and replace all the values within with

256
00:07:15,680 --> 00:07:20,720
an ncpa encryption of the values

257
00:07:19,199 --> 00:07:22,400
and it turns out you know it's very this

258
00:07:20,720 --> 00:07:23,680
is not a very complicated transformation

259
00:07:22,400 --> 00:07:25,840
but it still enables me

260
00:07:23,680 --> 00:07:27,680
uh both for example queries if you want

261
00:07:25,840 --> 00:07:30,400
to query for a tki

262
00:07:27,680 --> 00:07:31,759
the user simply hashes locally and sends

263
00:07:30,400 --> 00:07:33,440
the hash to the server

264
00:07:31,759 --> 00:07:34,800
and the server will look up the hash in

265
00:07:33,440 --> 00:07:36,639
the plaintext map and return the

266
00:07:34,800 --> 00:07:38,800
associated encryption

267
00:07:36,639 --> 00:07:40,880
of values or if it doesn't exist returns

268
00:07:38,800 --> 00:07:42,479
null similarly if you wanted to insert a

269
00:07:40,880 --> 00:07:44,080
key with some value bi

270
00:07:42,479 --> 00:07:45,919
you just send a hash of the key and an

271
00:07:44,080 --> 00:07:48,240
ncba encryption of the value

272
00:07:45,919 --> 00:07:50,000
and the server would simply perform the

273
00:07:48,240 --> 00:07:52,000
plaintext operation of inserting

274
00:07:50,000 --> 00:07:53,919
the hashed key to be associated with the

275
00:07:52,000 --> 00:07:57,120
encryption of the value vi

276
00:07:53,919 --> 00:07:58,400
such as that so

277
00:07:57,120 --> 00:08:00,560
let's take a look at what the leakage of

278
00:07:58,400 --> 00:08:02,719
the hashing encrypt compiler is so

279
00:08:00,560 --> 00:08:04,400
when you do let's say an insert for cats

280
00:08:02,720 --> 00:08:05,759
with the string zero one

281
00:08:04,400 --> 00:08:08,000
what ends up have what ends up being

282
00:08:05,759 --> 00:08:10,479
revealed is that the server sees

283
00:08:08,000 --> 00:08:11,599
a hash of cat an encryption of the

284
00:08:10,479 --> 00:08:12,639
string zero one

285
00:08:11,599 --> 00:08:14,000
and the fact that you're doing the

286
00:08:12,639 --> 00:08:15,840
insertion because the server has to know

287
00:08:14,000 --> 00:08:17,360
whether it's doing a query to either

288
00:08:15,840 --> 00:08:18,638
to do a query to the underlying

289
00:08:17,360 --> 00:08:20,160
plaintext map or an insertion to the

290
00:08:18,639 --> 00:08:21,599
underlying plaintext map

291
00:08:20,160 --> 00:08:23,440
and maybe you do another insertion for

292
00:08:21,599 --> 00:08:25,520
dogs so with with

293
00:08:23,440 --> 00:08:26,639
with the value zero zero so you get you

294
00:08:25,520 --> 00:08:27,758
know you get a hash of dog and

295
00:08:26,639 --> 00:08:28,720
encryption is your zoo and you know

296
00:08:27,759 --> 00:08:31,599
you're inserting

297
00:08:28,720 --> 00:08:33,200
and so on and so forth so let's let's

298
00:08:31,599 --> 00:08:34,718
analyze what leakage or what the

299
00:08:33,200 --> 00:08:36,000
adversary can learn by viewing this

300
00:08:34,719 --> 00:08:37,760
information

301
00:08:36,000 --> 00:08:39,679
so first of course it learns the type of

302
00:08:37,760 --> 00:08:41,519
operation performed like i said earlier

303
00:08:39,679 --> 00:08:43,760
the server has to know what what is

304
00:08:41,519 --> 00:08:45,519
doing a get or an insert

305
00:08:43,760 --> 00:08:47,040
into the underlying plaintext map so

306
00:08:45,519 --> 00:08:49,279
obviously has to learn the type of

307
00:08:47,040 --> 00:08:50,560
operation the user is performing

308
00:08:49,279 --> 00:08:52,480
it also learns the length of the query

309
00:08:50,560 --> 00:08:54,800
response so here for example

310
00:08:52,480 --> 00:08:56,240
you know and the first query it learns

311
00:08:54,800 --> 00:08:57,920
that there's one associated

312
00:08:56,240 --> 00:08:59,839
uh encryption with with the with the

313
00:08:57,920 --> 00:09:01,519
query keyword whereas for the fifth

314
00:08:59,839 --> 00:09:03,360
renault for the for the fifth operation

315
00:09:01,519 --> 00:09:05,120
this query for cats it learns that

316
00:09:03,360 --> 00:09:08,000
there's two encryptions actually

317
00:09:05,120 --> 00:09:10,640
associated with the with the query

318
00:09:08,000 --> 00:09:13,200
and finally this last but very important

319
00:09:10,640 --> 00:09:15,040
leakage is this key quality pattern

320
00:09:13,200 --> 00:09:16,560
so what the key quality pattern states

321
00:09:15,040 --> 00:09:20,000
is essentially that

322
00:09:16,560 --> 00:09:21,359
the server can identify which

323
00:09:20,000 --> 00:09:23,279
operations are being performed for the

324
00:09:21,360 --> 00:09:25,360
same on the same plain text key

325
00:09:23,279 --> 00:09:27,760
so take an example of these the the

326
00:09:25,360 --> 00:09:30,240
first the fourth and the fifth operation

327
00:09:27,760 --> 00:09:31,360
in all these operations the server learn

328
00:09:30,240 --> 00:09:34,480
the server is given

329
00:09:31,360 --> 00:09:36,000
a hash of cat which is deterministic and

330
00:09:34,480 --> 00:09:38,560
since it's deterministic what the server

331
00:09:36,000 --> 00:09:40,000
can quickly uh infer is that all three

332
00:09:38,560 --> 00:09:42,719
operations are being performed on the

333
00:09:40,000 --> 00:09:44,560
same keyword plaintext keyword

334
00:09:42,720 --> 00:09:46,080
but what i want to iterate is reiterate

335
00:09:44,560 --> 00:09:47,599
is that the server doesn't learn which

336
00:09:46,080 --> 00:09:48,800
plaintext keyword it was it was being

337
00:09:47,600 --> 00:09:49,839
performed so it wouldn't know it's cat

338
00:09:48,800 --> 00:09:52,800
but it knows that all three of these

339
00:09:49,839 --> 00:09:54,320
operations are performed on the same key

340
00:09:52,800 --> 00:09:56,160
similarly for the other two operations

341
00:09:54,320 --> 00:09:57,279
since they're both performed on dog

342
00:09:56,160 --> 00:09:59,199
the server learns that they're both

343
00:09:57,279 --> 00:10:00,399
performed on the same keyword so an

344
00:09:59,200 --> 00:10:01,519
essentially long story short what the

345
00:10:00,399 --> 00:10:03,920
key quality pattern says

346
00:10:01,519 --> 00:10:05,360
is that for any two operations you learn

347
00:10:03,920 --> 00:10:07,519
whether they perform on the same key or

348
00:10:05,360 --> 00:10:07,519
not

349
00:10:07,920 --> 00:10:11,040
so it turns out actually that

350
00:10:09,200 --> 00:10:11,839
surprisingly this ends up matching the

351
00:10:11,040 --> 00:10:14,000
leakage of

352
00:10:11,839 --> 00:10:15,360
many of almost all of the best

353
00:10:14,000 --> 00:10:16,880
structured encryption schemes with

354
00:10:15,360 --> 00:10:18,959
constant overhead

355
00:10:16,880 --> 00:10:20,079
so you know it's this area it's sort of

356
00:10:18,959 --> 00:10:21,359
this uh

357
00:10:20,079 --> 00:10:23,519
you know in the private spectrum it's

358
00:10:21,360 --> 00:10:24,880
this red box

359
00:10:23,519 --> 00:10:26,399
so a very good question is can we do

360
00:10:24,880 --> 00:10:27,600
better so let's take a look at the three

361
00:10:26,399 --> 00:10:29,600
leakage functions and see what we can

362
00:10:27,600 --> 00:10:30,800
mitigate in terms of leakage

363
00:10:29,600 --> 00:10:32,240
in terms of the type of operation

364
00:10:30,800 --> 00:10:33,040
performed is actually quite easy to

365
00:10:32,240 --> 00:10:34,640
mitigate

366
00:10:33,040 --> 00:10:37,040
because what the user could always do is

367
00:10:34,640 --> 00:10:38,640
perform all possible operation types

368
00:10:37,040 --> 00:10:40,399
and and sort of replace everything

369
00:10:38,640 --> 00:10:40,880
that's not a real operation with a mock

370
00:10:40,399 --> 00:10:42,399
one

371
00:10:40,880 --> 00:10:44,000
so for example you're doing a query you

372
00:10:42,399 --> 00:10:45,440
can also do a mock insert if you're

373
00:10:44,000 --> 00:10:47,839
doing an insert you can also do a mock

374
00:10:45,440 --> 00:10:47,839
query

375
00:10:47,920 --> 00:10:51,519
well the length of the query response is

376
00:10:49,440 --> 00:10:52,959
a little more tricky it's it's imp

377
00:10:51,519 --> 00:10:54,320
in fact it's very hard to mitigate

378
00:10:52,959 --> 00:10:56,640
because you sort of have to pad the

379
00:10:54,320 --> 00:10:58,240
responses to always be the maximum

380
00:10:56,640 --> 00:11:00,160
and there's been several works recently

381
00:10:58,240 --> 00:11:00,800
like camaro muay thais and eurocrypt19

382
00:11:00,160 --> 00:11:02,800
as well as

383
00:11:00,800 --> 00:11:04,719
work from our group and ccs19 that sort

384
00:11:02,800 --> 00:11:06,399
of show various solutions to

385
00:11:04,720 --> 00:11:08,320
volume hiding uh structural encryption

386
00:11:06,399 --> 00:11:09,680
schemes but the whole point is that sort

387
00:11:08,320 --> 00:11:10,800
of it gets very messy if you want to

388
00:11:09,680 --> 00:11:13,040
hide the length of query responses

389
00:11:10,800 --> 00:11:14,640
because you have the pad

390
00:11:13,040 --> 00:11:16,240
so we can then do is actually focus on

391
00:11:14,640 --> 00:11:18,000
this third leakage pattern called the

392
00:11:16,240 --> 00:11:19,600
key equality pattern

393
00:11:18,000 --> 00:11:21,360
and try to figure out you know what

394
00:11:19,600 --> 00:11:24,320
happens if we try to consider

395
00:11:21,360 --> 00:11:25,760
a slightly weaker notion of or of a key

396
00:11:24,320 --> 00:11:26,399
quality a slightly smaller leakage or a

397
00:11:25,760 --> 00:11:29,519
stronger

398
00:11:26,399 --> 00:11:30,399
stronger privacy so let's take a look

399
00:11:29,519 --> 00:11:32,000
again at

400
00:11:30,399 --> 00:11:33,040
the key quality pattern and what i'm

401
00:11:32,000 --> 00:11:34,560
going to do is i'm going to just define

402
00:11:33,040 --> 00:11:36,160
to you something we call the decoupled

403
00:11:34,560 --> 00:11:38,239
key equality pattern

404
00:11:36,160 --> 00:11:39,760
so like we said before in the first

405
00:11:38,240 --> 00:11:41,440
fourth and fifth operations

406
00:11:39,760 --> 00:11:42,720
you know the first and fourth operations

407
00:11:41,440 --> 00:11:43,440
are inserts and the fifth operation is a

408
00:11:42,720 --> 00:11:45,279
query

409
00:11:43,440 --> 00:11:46,560
the adversarial server learns that all

410
00:11:45,279 --> 00:11:47,680
three of them all these all three of

411
00:11:46,560 --> 00:11:48,079
these operations are performed on the

412
00:11:47,680 --> 00:11:50,319
same

413
00:11:48,079 --> 00:11:52,160
key cat even though it doesn't know what

414
00:11:50,320 --> 00:11:53,519
cabinets

415
00:11:52,160 --> 00:11:55,519
the decoupled key quality pattern

416
00:11:53,519 --> 00:11:57,600
essentially decouples the key qualities

417
00:11:55,519 --> 00:11:59,839
between inserts and query operations

418
00:11:57,600 --> 00:12:01,360
so what would happen now is that the uh

419
00:11:59,839 --> 00:12:02,560
this this average series server will

420
00:12:01,360 --> 00:12:03,920
still learn whether two insert

421
00:12:02,560 --> 00:12:05,199
operations are performing the same key

422
00:12:03,920 --> 00:12:07,120
or not

423
00:12:05,200 --> 00:12:08,399
and whether the same where the two query

424
00:12:07,120 --> 00:12:08,959
operators will perform the same key or

425
00:12:08,399 --> 00:12:10,880
not

426
00:12:08,959 --> 00:12:12,560
however we decouple the information that

427
00:12:10,880 --> 00:12:13,279
the adversary can see between inserts

428
00:12:12,560 --> 00:12:14,800
and queries

429
00:12:13,279 --> 00:12:16,320
so for example for an insert operation

430
00:12:14,800 --> 00:12:17,680
in a query operation

431
00:12:16,320 --> 00:12:19,040
the server would never learn whether

432
00:12:17,680 --> 00:12:20,560
these two operations are performed on

433
00:12:19,040 --> 00:12:22,880
the same key or not

434
00:12:20,560 --> 00:12:24,800
and sort of this is denoted by the fact

435
00:12:22,880 --> 00:12:26,320
that we we changed the color of this

436
00:12:24,800 --> 00:12:28,639
this cap for the query into a different

437
00:12:26,320 --> 00:12:30,000
color similarly we can

438
00:12:28,639 --> 00:12:32,079
we can do the same thing for this dog

439
00:12:30,000 --> 00:12:33,760
operation where again even though

440
00:12:32,079 --> 00:12:36,160
they're queried for the same keyword

441
00:12:33,760 --> 00:12:37,040
now we can try to construct a scheme

442
00:12:36,160 --> 00:12:38,719
where

443
00:12:37,040 --> 00:12:40,399
somehow the adversarial server would not

444
00:12:38,720 --> 00:12:43,519
learn that this insert and query are

445
00:12:40,399 --> 00:12:43,519
performed for the same key

446
00:12:43,680 --> 00:12:47,279
all right so actually this leads us sort

447
00:12:45,360 --> 00:12:49,360
of to our main result

448
00:12:47,279 --> 00:12:50,880
so what we actually end up moving is

449
00:12:49,360 --> 00:12:52,639
that any encrypted multi-map with

450
00:12:50,880 --> 00:12:53,600
leakage at most the decoupled key

451
00:12:52,639 --> 00:12:56,560
quality pattern

452
00:12:53,600 --> 00:12:58,079
must have omega log in overhead and

453
00:12:56,560 --> 00:12:59,518
actually this turns out to be a very

454
00:12:58,079 --> 00:13:00,239
this lower bound is tight because of

455
00:12:59,519 --> 00:13:01,920
their exist

456
00:13:00,240 --> 00:13:03,839
order login or ram-based encrypted

457
00:13:01,920 --> 00:13:05,199
multi-maps that end up leaking

458
00:13:03,839 --> 00:13:07,360
much less than the decoupled key

459
00:13:05,200 --> 00:13:09,279
equality pattern

460
00:13:07,360 --> 00:13:11,600
so sort of going back to this privacy

461
00:13:09,279 --> 00:13:15,040
spectrum what we end up showing

462
00:13:11,600 --> 00:13:16,639
is actually that essentially everything

463
00:13:15,040 --> 00:13:18,000
just slightly to the right

464
00:13:16,639 --> 00:13:20,720
of the structured encryption schemes

465
00:13:18,000 --> 00:13:22,240
because like i said we showed before

466
00:13:20,720 --> 00:13:24,079
earlier this hashing encrypt compiler

467
00:13:22,240 --> 00:13:25,920
that any sort of uh scheme that is able

468
00:13:24,079 --> 00:13:28,399
to leak the key quality pattern can have

469
00:13:25,920 --> 00:13:30,560
order one efficiency but as soon as you

470
00:13:28,399 --> 00:13:31,760
aim for something even slightly stronger

471
00:13:30,560 --> 00:13:33,760
in terms of privacy let's say the

472
00:13:31,760 --> 00:13:35,279
decoupled key coil pattern which doesn't

473
00:13:33,760 --> 00:13:36,079
really have many real world implications

474
00:13:35,279 --> 00:13:38,800
doesn't actually

475
00:13:36,079 --> 00:13:40,560
harden any sort of system theoretically

476
00:13:38,800 --> 00:13:43,760
it ends up requiring these

477
00:13:40,560 --> 00:13:45,599
schemes to use login overhead

478
00:13:43,760 --> 00:13:46,720
which ends up matching oblivious ramps

479
00:13:45,600 --> 00:13:47,040
so in other words what i'm trying to say

480
00:13:46,720 --> 00:13:48,160
is

481
00:13:47,040 --> 00:13:49,920
if you're gonna if you want anything

482
00:13:48,160 --> 00:13:50,719
slightly stronger than the instruction

483
00:13:49,920 --> 00:13:52,479
encryption

484
00:13:50,720 --> 00:13:53,440
in terms of theoretical asymptotics you

485
00:13:52,480 --> 00:13:56,000
might as well go all the way to

486
00:13:53,440 --> 00:13:57,440
oblivious grams

487
00:13:56,000 --> 00:13:59,839
all right so this is our result and

488
00:13:57,440 --> 00:14:01,440
let's let's go about trying to prove it

489
00:13:59,839 --> 00:14:02,720
so to prove this lower bound we end up

490
00:14:01,440 --> 00:14:03,519
using something called the cell probe

491
00:14:02,720 --> 00:14:04,880
model or

492
00:14:03,519 --> 00:14:06,959
the leakage cell probe model where we

493
00:14:04,880 --> 00:14:08,480
incorporate leakage functions

494
00:14:06,959 --> 00:14:09,760
so the idea of the cell pro model is

495
00:14:08,480 --> 00:14:11,199
sort of you have a again you have the

496
00:14:09,760 --> 00:14:11,680
user on the left and the server on the

497
00:14:11,199 --> 00:14:13,040
right

498
00:14:11,680 --> 00:14:14,719
and the server's memory essentially

499
00:14:13,040 --> 00:14:17,120
split up into something called cells and

500
00:14:14,720 --> 00:14:18,720
each cell is the same length

501
00:14:17,120 --> 00:14:20,480
the only cost in the cell probe model is

502
00:14:18,720 --> 00:14:22,720
essentially

503
00:14:20,480 --> 00:14:23,519
accessing any parts of server memory so

504
00:14:22,720 --> 00:14:25,120
accessing

505
00:14:23,519 --> 00:14:26,959
so one unit cost in this model

506
00:14:25,120 --> 00:14:27,839
essentially is means either reading or

507
00:14:26,959 --> 00:14:30,800
writing

508
00:14:27,839 --> 00:14:32,880
which we call also probing a selling of

509
00:14:30,800 --> 00:14:34,319
the server memory

510
00:14:32,880 --> 00:14:35,519
so it turns out that's the only cost we

511
00:14:34,320 --> 00:14:36,800
consider in the software model

512
00:14:35,519 --> 00:14:38,000
everything else is free so things like

513
00:14:36,800 --> 00:14:40,160
computation

514
00:14:38,000 --> 00:14:41,519
random oracles accessing client storage

515
00:14:40,160 --> 00:14:43,120
is all free so you can solve your

516
00:14:41,519 --> 00:14:45,040
favorite np-hard problem if you wanted

517
00:14:43,120 --> 00:14:47,440
to for free stuff like that

518
00:14:45,040 --> 00:14:49,120
and sort of okay why we consider a very

519
00:14:47,440 --> 00:14:50,560
weak cost model that ends up being very

520
00:14:49,120 --> 00:14:52,160
strong lower bounds

521
00:14:50,560 --> 00:14:53,920
if you were to consider a more realistic

522
00:14:52,160 --> 00:14:56,880
model where computation is uh

523
00:14:53,920 --> 00:14:57,279
is cost some amount of uh you know is

524
00:14:56,880 --> 00:14:59,040
some

525
00:14:57,279 --> 00:15:00,480
it costs some expense same thing as

526
00:14:59,040 --> 00:15:01,519
randomness generation or access to

527
00:15:00,480 --> 00:15:04,240
client storage

528
00:15:01,519 --> 00:15:05,760
our lower bounds will still hold in

529
00:15:04,240 --> 00:15:07,519
other words the cell pro models is in

530
00:15:05,760 --> 00:15:08,800
some ways the holy grail of lower bounds

531
00:15:07,519 --> 00:15:12,560
as is the weakest

532
00:15:08,800 --> 00:15:14,160
cost model so the technique we use to

533
00:15:12,560 --> 00:15:15,439
prove our lower bound is the information

534
00:15:14,160 --> 00:15:18,560
transfer technique introduced by

535
00:15:15,440 --> 00:15:20,720
petrascue and domain in 2006

536
00:15:18,560 --> 00:15:22,319
and sort of the high-level idea of the

537
00:15:20,720 --> 00:15:23,440
of the information transfer technique is

538
00:15:22,320 --> 00:15:25,680
to sort of

539
00:15:23,440 --> 00:15:26,959
arrange how information is transferred

540
00:15:25,680 --> 00:15:28,160
between various operations that are

541
00:15:26,959 --> 00:15:29,599
performed

542
00:15:28,160 --> 00:15:31,439
so sort of the idea is let's suppose you

543
00:15:29,600 --> 00:15:32,720
do n operations

544
00:15:31,440 --> 00:15:34,320
you know which i've listed sort of top

545
00:15:32,720 --> 00:15:35,600
out of top to bottom here operation once

546
00:15:34,320 --> 00:15:36,639
operation n

547
00:15:35,600 --> 00:15:38,720
and what we do is we're going to build a

548
00:15:36,639 --> 00:15:39,600
virtual binary tree over these n

549
00:15:38,720 --> 00:15:41,120
operations

550
00:15:39,600 --> 00:15:42,399
what does that mean essentially what

551
00:15:41,120 --> 00:15:44,240
means we're going to build a binary tree

552
00:15:42,399 --> 00:15:47,120
with n leaves

553
00:15:44,240 --> 00:15:48,240
such that each operation is assigned to

554
00:15:47,120 --> 00:15:50,480
a unique leaf

555
00:15:48,240 --> 00:15:51,279
in sort of chronological order so the

556
00:15:50,480 --> 00:15:52,800
the most

557
00:15:51,279 --> 00:15:54,320
the first operations assigned to the

558
00:15:52,800 --> 00:15:56,079
topmost leaf

559
00:15:54,320 --> 00:15:57,519
and second operation is assigned to the

560
00:15:56,079 --> 00:15:59,279
second most top leaf and so on and so

561
00:15:57,519 --> 00:16:01,120
forth

562
00:15:59,279 --> 00:16:02,800
so like i said in the cell pro model

563
00:16:01,120 --> 00:16:04,240
each of these operations you know so

564
00:16:02,800 --> 00:16:07,920
let's say you're reading or writing

565
00:16:04,240 --> 00:16:08,720
to the encrypted multi-map is actually

566
00:16:07,920 --> 00:16:11,759
implemented

567
00:16:08,720 --> 00:16:13,920
using sell reads and sell rights so for

568
00:16:11,759 --> 00:16:15,519
example whatever operation one was

569
00:16:13,920 --> 00:16:17,040
it's actually it made it's implemented

570
00:16:15,519 --> 00:16:18,800
using for example

571
00:16:17,040 --> 00:16:21,680
reading the 50 the sell at the address

572
00:16:18,800 --> 00:16:22,319
15 writing something to address uh salad

573
00:16:21,680 --> 00:16:24,560
or 17

574
00:16:22,320 --> 00:16:28,399
72 and writing something to sell address

575
00:16:24,560 --> 00:16:29,920
220 and so on and so forth

576
00:16:28,399 --> 00:16:32,320
so what we're actually going to do now

577
00:16:29,920 --> 00:16:34,160
is is sort of uh

578
00:16:32,320 --> 00:16:36,000
go iterate through every single cell

579
00:16:34,160 --> 00:16:38,319
read that occurs in this operation in

580
00:16:36,000 --> 00:16:41,199
this in this operational sequence

581
00:16:38,320 --> 00:16:42,160
and assign the red cell address to some

582
00:16:41,199 --> 00:16:44,800
unique node

583
00:16:42,160 --> 00:16:46,480
in the in this information transfer tree

584
00:16:44,800 --> 00:16:49,040
so for example let's suppose we took us

585
00:16:46,480 --> 00:16:51,759
an arbitrary salary let's say celery 15.

586
00:16:49,040 --> 00:16:53,839
that's the performance operation three

587
00:16:51,759 --> 00:16:55,519
what we then do is we go back and find

588
00:16:53,839 --> 00:16:57,920
the most recent

589
00:16:55,519 --> 00:16:59,839
operation that ended up writing to

590
00:16:57,920 --> 00:17:02,560
address to sell address 15 so that might

591
00:16:59,839 --> 00:17:04,319
be operation one

592
00:17:02,560 --> 00:17:05,760
and what we end up doing then is we're

593
00:17:04,319 --> 00:17:08,079
going to assign

594
00:17:05,760 --> 00:17:08,799
cell address 15 to the lowest common

595
00:17:08,079 --> 00:17:10,159
ancestor

596
00:17:08,799 --> 00:17:12,000
of the leaf nodes that are associated

597
00:17:10,160 --> 00:17:13,199
with operation one and operation three

598
00:17:12,000 --> 00:17:15,520
and in this case it happens to be the

599
00:17:13,199 --> 00:17:17,760
root of the tree

600
00:17:15,520 --> 00:17:19,199
and we do this sort of for every single

601
00:17:17,760 --> 00:17:22,640
address that's read in all

602
00:17:19,199 --> 00:17:24,240
and operations so what i will

603
00:17:22,640 --> 00:17:25,679
this is this is sort of the key point of

604
00:17:24,240 --> 00:17:26,880
the information transfer technique is

605
00:17:25,679 --> 00:17:28,880
sort of that

606
00:17:26,880 --> 00:17:30,240
the way we define and assign these cell

607
00:17:28,880 --> 00:17:31,919
addresses ends up

608
00:17:30,240 --> 00:17:33,600
defining the total amount of information

609
00:17:31,919 --> 00:17:35,919
that's being transferred so

610
00:17:33,600 --> 00:17:37,360
let's uh to explain this carefully let's

611
00:17:35,919 --> 00:17:38,799
consider a concrete example of this

612
00:17:37,360 --> 00:17:41,439
specific red node

613
00:17:38,799 --> 00:17:42,960
in this tree and this red node will have

614
00:17:41,440 --> 00:17:45,280
a seat we'll have like several cell

615
00:17:42,960 --> 00:17:48,640
addresses that are assigned to it

616
00:17:45,280 --> 00:17:50,240
and what these cell addresses signify is

617
00:17:48,640 --> 00:17:52,160
the total amount of information that's

618
00:17:50,240 --> 00:17:52,960
transferred from operations that are

619
00:17:52,160 --> 00:17:55,919
performed

620
00:17:52,960 --> 00:17:57,919
in the top sub-tree so this top sub-tree

621
00:17:55,919 --> 00:18:00,080
of this red node

622
00:17:57,919 --> 00:18:03,120
that would be used by operations in the

623
00:18:00,080 --> 00:18:06,080
bottom sub-tree of this red node

624
00:18:03,120 --> 00:18:07,120
so for example let's say somehow

625
00:18:06,080 --> 00:18:09,360
operation you know the

626
00:18:07,120 --> 00:18:11,600
an operation in the top sub tree wrote

627
00:18:09,360 --> 00:18:14,240
something to a specific

628
00:18:11,600 --> 00:18:14,639
overwrote a value for a specific key and

629
00:18:14,240 --> 00:18:17,600
that

630
00:18:14,640 --> 00:18:18,880
key is later read in the bottom subtree

631
00:18:17,600 --> 00:18:20,480
obviously that information

632
00:18:18,880 --> 00:18:22,160
for for the for the data structure to be

633
00:18:20,480 --> 00:18:23,039
correct that information must be

634
00:18:22,160 --> 00:18:24,799
transferred

635
00:18:23,039 --> 00:18:26,879
from the top subtree to the bottom

636
00:18:24,799 --> 00:18:28,320
subtree and that what i and what i'm

637
00:18:26,880 --> 00:18:29,679
trying this and what the information

638
00:18:28,320 --> 00:18:30,879
transfer technique shows is that

639
00:18:29,679 --> 00:18:33,120
actually

640
00:18:30,880 --> 00:18:34,880
the total amount of information that

641
00:18:33,120 --> 00:18:37,120
that's uh that's transferred

642
00:18:34,880 --> 00:18:38,400
is must exist in the cells assigned to

643
00:18:37,120 --> 00:18:39,760
this red node

644
00:18:38,400 --> 00:18:41,760
and to sort of see this what we can go

645
00:18:39,760 --> 00:18:43,440
through is sort of try some examples

646
00:18:41,760 --> 00:18:45,200
so let's say we take this blue this blue

647
00:18:43,440 --> 00:18:46,799
note and try to say maybe

648
00:18:45,200 --> 00:18:48,799
could any cell address that's a sign

649
00:18:46,799 --> 00:18:51,200
here somehow transfer notes from the

650
00:18:48,799 --> 00:18:52,400
from the from the the top subtree of

651
00:18:51,200 --> 00:18:53,360
this red node to the bottom section of

652
00:18:52,400 --> 00:18:54,320
this red node

653
00:18:53,360 --> 00:18:57,280
and if you sort of think about it

654
00:18:54,320 --> 00:18:58,879
quickly the answer is it can't because

655
00:18:57,280 --> 00:19:01,280
any cell addresses assigned to this blue

656
00:18:58,880 --> 00:19:02,880
node would be read in an operation that

657
00:19:01,280 --> 00:19:04,879
is already performed in the top sub-tree

658
00:19:02,880 --> 00:19:07,280
of this red node so in fact

659
00:19:04,880 --> 00:19:08,559
there can't be any information insiders

660
00:19:07,280 --> 00:19:10,879
that are signed here

661
00:19:08,559 --> 00:19:12,399
that can be transferred uh that's that's

662
00:19:10,880 --> 00:19:13,600
that's if that's transferred from the

663
00:19:12,400 --> 00:19:15,520
top subtree of the retina to the bottom

664
00:19:13,600 --> 00:19:17,039
substitute red node

665
00:19:15,520 --> 00:19:18,480
similarly you can do another analysis

666
00:19:17,039 --> 00:19:20,160
maybe pick another tree that pick

667
00:19:18,480 --> 00:19:20,960
another node that's a parent of the red

668
00:19:20,160 --> 00:19:22,240
node

669
00:19:20,960 --> 00:19:24,160
and again let's suppose some cell

670
00:19:22,240 --> 00:19:26,240
addresses the sign here that would mean

671
00:19:24,160 --> 00:19:28,960
it's it's written in you know

672
00:19:26,240 --> 00:19:30,400
in in some in in in the top sub tree of

673
00:19:28,960 --> 00:19:32,400
this uh of the blue node which

674
00:19:30,400 --> 00:19:33,760
consists of the whole tree rooted at the

675
00:19:32,400 --> 00:19:35,440
red node

676
00:19:33,760 --> 00:19:36,720
and it would be we read somewhere in the

677
00:19:35,440 --> 00:19:37,600
bottom subtree which is sort of not

678
00:19:36,720 --> 00:19:39,679
important

679
00:19:37,600 --> 00:19:41,039
for any uh any operations that performed

680
00:19:39,679 --> 00:19:42,559
in this uh

681
00:19:41,039 --> 00:19:44,160
that's performed in the bottom subtree

682
00:19:42,559 --> 00:19:46,240
of this red though

683
00:19:44,160 --> 00:19:47,760
so in other words what we end up what

684
00:19:46,240 --> 00:19:49,120
you will what you end up seeing is that

685
00:19:47,760 --> 00:19:50,480
all the information transferred from the

686
00:19:49,120 --> 00:19:51,600
top sub true the red node to the bottom

687
00:19:50,480 --> 00:19:53,200
substrate of red node

688
00:19:51,600 --> 00:19:56,080
must exist in the cells that are

689
00:19:53,200 --> 00:19:58,160
assigned in the red node

690
00:19:56,080 --> 00:19:59,520
so why is this important well it turns

691
00:19:58,160 --> 00:20:00,480
out what we'll end up going to do we're

692
00:19:59,520 --> 00:20:02,639
going to find is we're going to find

693
00:20:00,480 --> 00:20:04,000
operations that maximize

694
00:20:02,640 --> 00:20:06,640
the number of cell addresses that are

695
00:20:04,000 --> 00:20:08,240
assigned to to to each internal node so

696
00:20:06,640 --> 00:20:09,840
again let's look at this red node

697
00:20:08,240 --> 00:20:11,360
and what we can essentially do is try to

698
00:20:09,840 --> 00:20:12,559
find out a sequence of operations that

699
00:20:11,360 --> 00:20:13,199
would maximize the number of saw

700
00:20:12,559 --> 00:20:15,760
addresses

701
00:20:13,200 --> 00:20:16,240
that have to be assigned to the red node

702
00:20:15,760 --> 00:20:17,520
so

703
00:20:16,240 --> 00:20:18,960
in fact it's actually very simple to do

704
00:20:17,520 --> 00:20:19,440
this what you can do is in the top sub

705
00:20:18,960 --> 00:20:21,679
tree

706
00:20:19,440 --> 00:20:23,440
put a bunch of inserts in the bottom sub

707
00:20:21,679 --> 00:20:24,559
tree we can do a bunch of queries

708
00:20:23,440 --> 00:20:26,720
and sort of what we're going to do is

709
00:20:24,559 --> 00:20:28,399
you know we insert to uh to unique

710
00:20:26,720 --> 00:20:30,080
indices in the top sub tree

711
00:20:28,400 --> 00:20:32,080
with uh with these values that are

712
00:20:30,080 --> 00:20:35,199
completely random and then in the bottom

713
00:20:32,080 --> 00:20:35,199
sub tree you simply query though

714
00:20:35,280 --> 00:20:38,480
so trying to uh so using this idea what

715
00:20:37,679 --> 00:20:40,080
we're going to do is now actually

716
00:20:38,480 --> 00:20:41,520
construct our lower bound

717
00:20:40,080 --> 00:20:43,439
so for our lower bound we have to find

718
00:20:41,520 --> 00:20:44,559
some hard sequence

719
00:20:43,440 --> 00:20:45,760
and the hard sequence we essentially

720
00:20:44,559 --> 00:20:48,000
choose is something very simple it's

721
00:20:45,760 --> 00:20:49,520
like insert to one a random value b and

722
00:20:48,000 --> 00:20:52,080
then subsequently read it

723
00:20:49,520 --> 00:20:53,440
insert to index two and subsequently

724
00:20:52,080 --> 00:20:55,280
read and so on and so forth

725
00:20:53,440 --> 00:20:58,960
and we assume that how we generate these

726
00:20:55,280 --> 00:20:58,960
values has a larger amount of entropy

727
00:20:59,200 --> 00:21:03,520
so okay you might ask right off the bat

728
00:21:01,039 --> 00:21:05,280
isn't this operation easy to handle

729
00:21:03,520 --> 00:21:06,799
and sort of the key is that the sequence

730
00:21:05,280 --> 00:21:10,080
is indistinguishable from from many

731
00:21:06,799 --> 00:21:12,080
sequences with identical leakage

732
00:21:10,080 --> 00:21:13,199
so taking a look let's let's look at the

733
00:21:12,080 --> 00:21:15,120
let's look at this hard

734
00:21:13,200 --> 00:21:16,240
this hard distribution we can quickly

735
00:21:15,120 --> 00:21:18,479
see is that

736
00:21:16,240 --> 00:21:20,320
this heart sequence ends up maximizing

737
00:21:18,480 --> 00:21:21,600
you know all of these red nodes the

738
00:21:20,320 --> 00:21:22,639
number of charges let me assign to this

739
00:21:21,600 --> 00:21:24,240
red node for example

740
00:21:22,640 --> 00:21:26,720
let's look at this uh this top right

741
00:21:24,240 --> 00:21:28,080
node clearly you know all of the

742
00:21:26,720 --> 00:21:29,679
all the operations in this tops up to

743
00:21:28,080 --> 00:21:31,439
your inserts that are subsequently

744
00:21:29,679 --> 00:21:33,200
queried in the bottom subtree

745
00:21:31,440 --> 00:21:35,520
so okay this hard sequence at least

746
00:21:33,200 --> 00:21:37,600
maximizes the cell addresses for

747
00:21:35,520 --> 00:21:39,679
maximum cell just assigned to you know

748
00:21:37,600 --> 00:21:42,480
this uh this whole

749
00:21:39,679 --> 00:21:44,240
this whole level of nodes but what we

750
00:21:42,480 --> 00:21:46,240
can then do is actually

751
00:21:44,240 --> 00:21:47,840
slightly modify the operation so for

752
00:21:46,240 --> 00:21:48,640
example let's say we take the queries

753
00:21:47,840 --> 00:21:50,000
and change them

754
00:21:48,640 --> 00:21:51,760
so what we do is we change these two

755
00:21:50,000 --> 00:21:53,919
queries to be dummies

756
00:21:51,760 --> 00:21:55,760
and we actually query uh you know the

757
00:21:53,919 --> 00:21:58,880
key one and key two

758
00:21:55,760 --> 00:22:00,080
in in the bottom subtree and maybe to

759
00:21:58,880 --> 00:22:01,200
make sure the leakage remains the same

760
00:22:00,080 --> 00:22:02,240
between the two operations

761
00:22:01,200 --> 00:22:03,360
you might have to add some sort of

762
00:22:02,240 --> 00:22:05,760
header where you insert a bunch of

763
00:22:03,360 --> 00:22:08,399
dummies that can be queried later

764
00:22:05,760 --> 00:22:09,600
so we take a look at this new construct

765
00:22:08,400 --> 00:22:12,240
at this new uh

766
00:22:09,600 --> 00:22:13,760
sequence which has the the same leakage

767
00:22:12,240 --> 00:22:15,760
as the original hard distribution which

768
00:22:13,760 --> 00:22:17,520
i just described

769
00:22:15,760 --> 00:22:19,280
it turns out that this sequence ends up

770
00:22:17,520 --> 00:22:21,440
maximizing the number of cell addresses

771
00:22:19,280 --> 00:22:22,639
up to a constant factor of two the

772
00:22:21,440 --> 00:22:23,760
number of soldiers that have to be

773
00:22:22,640 --> 00:22:25,280
assigned to this red

774
00:22:23,760 --> 00:22:27,919
red node and you can do this

775
00:22:25,280 --> 00:22:30,879
repetitively for each internal node

776
00:22:27,919 --> 00:22:31,520
in the tree so sort of what ends up

777
00:22:30,880 --> 00:22:33,520
happening

778
00:22:31,520 --> 00:22:34,960
how we prove this lower bound is sort of

779
00:22:33,520 --> 00:22:36,799
you know we use these ideas to show that

780
00:22:34,960 --> 00:22:38,240
many probes must be assigned to half the

781
00:22:36,799 --> 00:22:41,760
internal nodes for this easy hard

782
00:22:38,240 --> 00:22:44,640
for this easy hard distribution

783
00:22:41,760 --> 00:22:45,440
and then what we also notice that each

784
00:22:44,640 --> 00:22:48,880
cell read

785
00:22:45,440 --> 00:22:50,960
or probe is assigned to at most

786
00:22:48,880 --> 00:22:53,120
one internal node in the tree so by

787
00:22:50,960 --> 00:22:53,679
simply summing up the probes assigned

788
00:22:53,120 --> 00:22:56,320
over all

789
00:22:53,679 --> 00:22:58,640
nodes provides the lordon so what i'm

790
00:22:56,320 --> 00:23:01,039
trying to say is sort of

791
00:22:58,640 --> 00:23:01,679
if for some reason there was not enough

792
00:23:01,039 --> 00:23:03,840
cell uh

793
00:23:01,679 --> 00:23:06,080
cells that are assigned to this red node

794
00:23:03,840 --> 00:23:08,799
we would know that this specific uh

795
00:23:06,080 --> 00:23:10,158
sequence couldn't exist so for privacy

796
00:23:08,799 --> 00:23:13,039
you have to assign

797
00:23:10,159 --> 00:23:14,320
the maximum addresses the maximum cells

798
00:23:13,039 --> 00:23:14,799
addresses that have to be at this red

799
00:23:14,320 --> 00:23:16,720
node

800
00:23:14,799 --> 00:23:17,918
according to this uh this distribution

801
00:23:16,720 --> 00:23:19,919
and if you do this for all of them you

802
00:23:17,919 --> 00:23:21,520
get you just sum up the maximums

803
00:23:19,919 --> 00:23:24,000
over all internal nodes and you get the

804
00:23:21,520 --> 00:23:24,000
lower bound

805
00:23:24,320 --> 00:23:27,039
all right so it turns out that so that's

806
00:23:25,760 --> 00:23:27,919
actually completes our lower bound from

807
00:23:27,039 --> 00:23:29,600
a very high level

808
00:23:27,919 --> 00:23:30,640
the information transfer technique but

809
00:23:29,600 --> 00:23:32,559
it turns out that you can actually

810
00:23:30,640 --> 00:23:34,000
modify the the lower bound to get

811
00:23:32,559 --> 00:23:35,840
the more modify the proof to get

812
00:23:34,000 --> 00:23:36,880
stronger lower bounds so it turns out

813
00:23:35,840 --> 00:23:37,520
that we can prove lower bounds in our

814
00:23:36,880 --> 00:23:39,760
paper

815
00:23:37,520 --> 00:23:41,200
even when one of the insert operations

816
00:23:39,760 --> 00:23:44,400
are reporting plain text or the chord

817
00:23:41,200 --> 00:23:47,440
operations that perform the plain text

818
00:23:44,400 --> 00:23:49,039
furthermore we can actually uh use this

819
00:23:47,440 --> 00:23:50,159
uses lower buffer encrypted multi-maps

820
00:23:49,039 --> 00:23:51,919
to end up proving lower bounds for

821
00:23:50,159 --> 00:23:55,039
dynamic searchable encryption and

822
00:23:51,919 --> 00:23:55,440
in fact what we show is that by by this

823
00:23:55,039 --> 00:23:57,440
this

824
00:23:55,440 --> 00:23:58,720
decoupled key quality ends up actually

825
00:23:57,440 --> 00:24:00,000
being

826
00:23:58,720 --> 00:24:02,320
something called response hiding in

827
00:24:00,000 --> 00:24:04,640
dynamic social encryption where you hide

828
00:24:02,320 --> 00:24:06,480
the actual documents that are that are

829
00:24:04,640 --> 00:24:07,919
associated with any query key

830
00:24:06,480 --> 00:24:09,120
and what we prove is that such response

831
00:24:07,919 --> 00:24:09,679
hiding dynamic sessional encryption

832
00:24:09,120 --> 00:24:11,279
schemes

833
00:24:09,679 --> 00:24:12,480
end up requiring login overhead and

834
00:24:11,279 --> 00:24:13,679
again this is tight because they

835
00:24:12,480 --> 00:24:14,960
actually end up being oram-based

836
00:24:13,679 --> 00:24:16,640
solutions for these for these the

837
00:24:14,960 --> 00:24:20,640
dynamic searchable encryption schemes

838
00:24:16,640 --> 00:24:21,440
that are responsive so okay so that that

839
00:24:20,640 --> 00:24:23,600
completes sort of

840
00:24:21,440 --> 00:24:25,360
what we did in this paper there turns

841
00:24:23,600 --> 00:24:26,158
out to be recently a large number of

842
00:24:25,360 --> 00:24:27,918
other works that

843
00:24:26,159 --> 00:24:29,279
the cryptographic lower boundary in the

844
00:24:27,919 --> 00:24:31,360
cell pro model so there's

845
00:24:29,279 --> 00:24:32,640
the seminal uh obligation paper by

846
00:24:31,360 --> 00:24:33,918
larsen nielsen

847
00:24:32,640 --> 00:24:35,360
as well as several follow-ups that i

848
00:24:33,919 --> 00:24:38,720
list here that if you're interested in

849
00:24:35,360 --> 00:24:40,479
you should uh you should go explore

850
00:24:38,720 --> 00:24:42,720
all right so thanks for listening to my

851
00:24:40,480 --> 00:24:47,840
talk and i hope you enjoyed

852
00:24:42,720 --> 00:24:47,840
and learn something

853
00:24:48,000 --> 00:24:50,080
you

