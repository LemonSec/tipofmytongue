1
00:00:01,920 --> 00:00:06,399
welcome to this talk about the measure

2
00:00:04,080 --> 00:00:09,760
and reprogram technique 2.0

3
00:00:06,399 --> 00:00:10,960
multi-round fiat xiaomi and more my name

4
00:00:09,760 --> 00:00:12,960
is yellow don

5
00:00:10,960 --> 00:00:16,960
and this is joint work with cerrosphere

6
00:00:12,960 --> 00:00:19,279
and christian mayans our work is about

7
00:00:16,960 --> 00:00:21,039
proofing fiat xiaomi digital signatures

8
00:00:19,279 --> 00:00:22,640
and in general fiat charm your zero

9
00:00:21,039 --> 00:00:26,000
knowledge proof systems

10
00:00:22,640 --> 00:00:28,000
secure against quantum attackers whereby

11
00:00:26,000 --> 00:00:30,320
secure we mean secure in the quantum

12
00:00:28,000 --> 00:00:32,480
random oracle model

13
00:00:30,320 --> 00:00:34,399
what we do is we extend an existing

14
00:00:32,479 --> 00:00:35,760
curom technique to a larger class of

15
00:00:34,399 --> 00:00:38,000
applications

16
00:00:35,760 --> 00:00:39,120
notably multi-round field xiaomi

17
00:00:38,000 --> 00:00:42,160
signatures

18
00:00:39,120 --> 00:00:45,839
of which mqdss is an example

19
00:00:42,160 --> 00:00:48,078
bulletproofs and sequential or proofs

20
00:00:45,840 --> 00:00:49,840
and finally we also show that the

21
00:00:48,079 --> 00:00:50,640
reductions that we get from applying

22
00:00:49,840 --> 00:00:54,559
these techniques

23
00:00:50,640 --> 00:00:55,039
are essentially tight i'll dive right in

24
00:00:54,559 --> 00:00:56,879
by

25
00:00:55,039 --> 00:00:58,239
explaining the quantum random oracle

26
00:00:56,879 --> 00:01:00,879
model

27
00:00:58,239 --> 00:01:03,199
suppose we have some protocol that makes

28
00:01:00,879 --> 00:01:05,759
use of a public hash function

29
00:01:03,199 --> 00:01:06,240
then proving security in the qrom means

30
00:01:05,760 --> 00:01:08,400
that

31
00:01:06,240 --> 00:01:10,080
we model the public hash function as an

32
00:01:08,400 --> 00:01:12,240
external random oracle

33
00:01:10,080 --> 00:01:14,080
to which all parties in a protocol have

34
00:01:12,240 --> 00:01:15,600
quantum query access

35
00:01:14,080 --> 00:01:17,200
this means that the function cannot be

36
00:01:15,600 --> 00:01:19,119
computed locally

37
00:01:17,200 --> 00:01:21,600
but all parties can query a

38
00:01:19,119 --> 00:01:24,720
superposition of inputs

39
00:01:21,600 --> 00:01:26,720
and this is a natural assumption since

40
00:01:24,720 --> 00:01:27,840
the hash function is assumed to be

41
00:01:26,720 --> 00:01:30,880
public

42
00:01:27,840 --> 00:01:32,000
anyone can build a quantum circuit to

43
00:01:30,880 --> 00:01:33,679
evaluate it

44
00:01:32,000 --> 00:01:35,920
once you have a quantum circuit to

45
00:01:33,680 --> 00:01:40,159
evaluate the function then it's easy to

46
00:01:35,920 --> 00:01:42,240
evaluate on a superposition of inputs

47
00:01:40,159 --> 00:01:45,360
but the problem is that in many

48
00:01:42,240 --> 00:01:48,000
classical random oracle model proofs

49
00:01:45,360 --> 00:01:50,240
we want to observe the queries that the

50
00:01:48,000 --> 00:01:52,320
adversary makes

51
00:01:50,240 --> 00:01:53,280
but as you probably know observing a

52
00:01:52,320 --> 00:01:57,199
quantum state

53
00:01:53,280 --> 00:01:59,360
can cause it to collapse and if the

54
00:01:57,200 --> 00:02:01,040
query state of the adversary collapses

55
00:01:59,360 --> 00:02:02,960
this might

56
00:02:01,040 --> 00:02:04,320
as well collapse the internal state of

57
00:02:02,960 --> 00:02:06,240
the adversary

58
00:02:04,320 --> 00:02:07,439
and then we can no longer predict

59
00:02:06,240 --> 00:02:11,280
anything about the

60
00:02:07,439 --> 00:02:11,280
adversary's output

61
00:02:11,440 --> 00:02:15,680
in general that is because we present a

62
00:02:14,239 --> 00:02:19,280
theorem

63
00:02:15,680 --> 00:02:22,400
that deals with so-called multi-input

64
00:02:19,280 --> 00:02:25,040
reprogrammability of the qram it says

65
00:02:22,400 --> 00:02:28,080
that if we are in this situation where

66
00:02:25,040 --> 00:02:28,640
we have an adversary making q quantum

67
00:02:28,080 --> 00:02:31,920
queries

68
00:02:28,640 --> 00:02:35,200
to some random oracle 8

69
00:02:31,920 --> 00:02:38,319
and then outputs an array so i use

70
00:02:35,200 --> 00:02:41,280
bolt fund here for arrays of

71
00:02:38,319 --> 00:02:43,280
input values to the oracle and some

72
00:02:41,280 --> 00:02:45,760
additional output z

73
00:02:43,280 --> 00:02:48,080
such that we we know we know something

74
00:02:45,760 --> 00:02:48,079
about

75
00:02:48,800 --> 00:02:53,120
about this output the probability of

76
00:02:50,879 --> 00:02:55,599
this output

77
00:02:53,120 --> 00:02:56,480
being such that x together with the hash

78
00:02:55,599 --> 00:03:00,079
values of x

79
00:02:56,480 --> 00:03:03,440
and c satisfy some arbitrary predicate

80
00:03:00,080 --> 00:03:05,519
v then

81
00:03:03,440 --> 00:03:06,560
there exists a simulator that can sort

82
00:03:05,519 --> 00:03:10,080
of creep

83
00:03:06,560 --> 00:03:14,640
in between the adversary and oracle

84
00:03:10,080 --> 00:03:17,760
and choose n of the adversaries queries

85
00:03:14,640 --> 00:03:20,720
at random measure them

86
00:03:17,760 --> 00:03:22,480
and on the input that it finds so in

87
00:03:20,720 --> 00:03:25,599
this example n is 2 and

88
00:03:22,480 --> 00:03:28,480
the simulator finds x i and xj

89
00:03:25,599 --> 00:03:30,000
it can then reprogram the oracle to

90
00:03:28,480 --> 00:03:33,040
fresh random values

91
00:03:30,000 --> 00:03:35,120
theta i and theta j

92
00:03:33,040 --> 00:03:36,079
and continue the run of the adversary

93
00:03:35,120 --> 00:03:39,360
such that

94
00:03:36,080 --> 00:03:42,319
its final output x bar c bar will

95
00:03:39,360 --> 00:03:44,879
satisfy the same predicate v

96
00:03:42,319 --> 00:03:48,159
but now with respect to these freshly

97
00:03:44,879 --> 00:03:50,879
programmed random values theta

98
00:03:48,159 --> 00:03:51,599
and as you can see we can even compare

99
00:03:50,879 --> 00:03:55,120
the

100
00:03:51,599 --> 00:03:58,159
probabilities for specific choices

101
00:03:55,120 --> 00:03:59,840
of this array x naught

102
00:03:58,159 --> 00:04:02,959
but by summing the inequality we can

103
00:03:59,840 --> 00:04:05,439
also make more general statements

104
00:04:02,959 --> 00:04:06,560
and of course as you can also see this

105
00:04:05,439 --> 00:04:10,959
all comes at

106
00:04:06,560 --> 00:04:15,760
uh multiplicative loss

107
00:04:10,959 --> 00:04:19,440
of order q to the power 2 n

108
00:04:15,760 --> 00:04:23,840
but indeed they are polynomially related

109
00:04:19,440 --> 00:04:27,199
for constant or logarithmic n

110
00:04:23,840 --> 00:04:28,400
right another observation that we can

111
00:04:27,199 --> 00:04:30,800
make is that

112
00:04:28,400 --> 00:04:32,400
instead of talking to a real random

113
00:04:30,800 --> 00:04:35,360
oracle

114
00:04:32,400 --> 00:04:38,320
itself the simulator can also use a

115
00:04:35,360 --> 00:04:41,360
quantum secure pseudo random function

116
00:04:38,320 --> 00:04:43,680
uh in order if

117
00:04:41,360 --> 00:04:45,520
if if a is at least computationally

118
00:04:43,680 --> 00:04:47,520
bounded so that he will not notice the

119
00:04:45,520 --> 00:04:49,919
difference

120
00:04:47,520 --> 00:04:52,880
uh right so that's the the main

121
00:04:49,919 --> 00:04:52,880
technical result

122
00:04:53,360 --> 00:04:57,680
it may all seem a bit abstract at this

123
00:04:55,440 --> 00:05:00,880
point but we can actually

124
00:04:57,680 --> 00:05:04,400
use it and apply it to proof

125
00:05:00,880 --> 00:05:06,960
security of multi-round field xiaomi

126
00:05:04,400 --> 00:05:08,840
so very quickly motoround v or xiaomi

127
00:05:06,960 --> 00:05:13,198
takes

128
00:05:08,840 --> 00:05:13,758
some public or an interactive proof

129
00:05:13,199 --> 00:05:17,320
system

130
00:05:13,759 --> 00:05:19,680
by anne and turns it into a

131
00:05:17,320 --> 00:05:22,800
non-non-interactive scheme

132
00:05:19,680 --> 00:05:24,800
and we show that the

133
00:05:22,800 --> 00:05:26,000
advantage of the best adversary against

134
00:05:24,800 --> 00:05:30,720
the non-interactive scheme

135
00:05:26,000 --> 00:05:34,400
is at most order q to the power 2

136
00:05:30,720 --> 00:05:36,960
order q to the power 2 n times as big

137
00:05:34,400 --> 00:05:39,840
as the adversary the best adversary

138
00:05:36,960 --> 00:05:42,479
against the interactive scheme

139
00:05:39,840 --> 00:05:44,000
and indeed this is tight because in our

140
00:05:42,479 --> 00:05:47,360
paper we

141
00:05:44,000 --> 00:05:49,440
provide an attack first we provide an

142
00:05:47,360 --> 00:05:52,960
attack for typical three-round schemes

143
00:05:49,440 --> 00:05:55,440
so-called sigma protocols which indeed

144
00:05:52,960 --> 00:05:57,840
boosts the success of the best

145
00:05:55,440 --> 00:06:01,120
interactive adversary by a factor q2

146
00:05:57,840 --> 00:06:04,159
per cube q squared

147
00:06:01,120 --> 00:06:07,600
showing that for n equals one this

148
00:06:04,160 --> 00:06:08,479
loss is optimal and then we extend the

149
00:06:07,600 --> 00:06:11,520
attack to

150
00:06:08,479 --> 00:06:14,719
a somewhat artificial multiround scheme

151
00:06:11,520 --> 00:06:17,919
and we get almost the same boost

152
00:06:14,720 --> 00:06:18,560
except for this vector n to the power -2

153
00:06:17,919 --> 00:06:20,318
n

154
00:06:18,560 --> 00:06:22,560
but since we're usually considering n to

155
00:06:20,319 --> 00:06:24,960
be constant

156
00:06:22,560 --> 00:06:26,000
that means that asymptotically q to the

157
00:06:24,960 --> 00:06:29,280
power 2 n

158
00:06:26,000 --> 00:06:29,280
is optimal as well

159
00:06:30,160 --> 00:06:33,520
okay for the rest of the talk i'll give

160
00:06:32,400 --> 00:06:36,239
you a bit more detail

161
00:06:33,520 --> 00:06:37,359
about how the via chemi transformation

162
00:06:36,240 --> 00:06:39,600
works

163
00:06:37,360 --> 00:06:41,440
how the original result is applied to

164
00:06:39,600 --> 00:06:43,120
prove it secure

165
00:06:41,440 --> 00:06:44,639
and then we'll come to the the

166
00:06:43,120 --> 00:06:47,440
motivation for this

167
00:06:44,639 --> 00:06:48,160
uh new work namely multi-round field

168
00:06:47,440 --> 00:06:50,080
xiaomi

169
00:06:48,160 --> 00:06:52,479
and i'll discuss what we need to prove

170
00:06:50,080 --> 00:06:54,159
that secure

171
00:06:52,479 --> 00:06:56,318
then i'll give you the proof idea for

172
00:06:54,160 --> 00:06:58,720
this main result that we have

173
00:06:56,319 --> 00:07:00,240
and i'll finish off by talking about yet

174
00:06:58,720 --> 00:07:03,840
another application in the

175
00:07:00,240 --> 00:07:03,840
sequential or proofs

176
00:07:04,000 --> 00:07:09,919
right so suppose that we have this

177
00:07:07,120 --> 00:07:11,199
three round identification scheme where

178
00:07:09,919 --> 00:07:14,639
some proofer can prove

179
00:07:11,199 --> 00:07:16,080
its identity by sending a commitment to

180
00:07:14,639 --> 00:07:18,240
a verifier

181
00:07:16,080 --> 00:07:19,199
and then upon receiving a challenge a

182
00:07:18,240 --> 00:07:21,919
random

183
00:07:19,199 --> 00:07:23,280
this must be a uniformly random

184
00:07:21,919 --> 00:07:26,560
challenge

185
00:07:23,280 --> 00:07:29,119
uses its knowledge of some secret key

186
00:07:26,560 --> 00:07:30,080
to compute the response and then the

187
00:07:29,120 --> 00:07:33,120
verifier

188
00:07:30,080 --> 00:07:36,479
who of course knows the public key

189
00:07:33,120 --> 00:07:37,120
of this proofer can compute some

190
00:07:36,479 --> 00:07:41,599
predicate

191
00:07:37,120 --> 00:07:43,280
on the messages to verify that indeed

192
00:07:41,599 --> 00:07:45,840
this proofer must have known the secret

193
00:07:43,280 --> 00:07:45,840
key

194
00:07:46,720 --> 00:07:49,840
now since this is an interactive

195
00:07:48,080 --> 00:07:51,919
protocol

196
00:07:49,840 --> 00:07:53,280
we could ask if we could make it

197
00:07:51,919 --> 00:07:55,039
non-interactive

198
00:07:53,280 --> 00:07:56,719
and the fiat xiaomi transformation says

199
00:07:55,039 --> 00:08:00,960
that we may do so by

200
00:07:56,720 --> 00:08:03,440
introducing this public hash function 8

201
00:08:00,960 --> 00:08:05,919
and then let the proofer instead of

202
00:08:03,440 --> 00:08:08,800
waiting for a random challenge

203
00:08:05,919 --> 00:08:10,840
compute a challenge himself simply by

204
00:08:08,800 --> 00:08:13,039
hassing the public key and the

205
00:08:10,840 --> 00:08:14,960
commitment then it only needs to send

206
00:08:13,039 --> 00:08:17,680
the commitment and response

207
00:08:14,960 --> 00:08:18,159
since the verifier on his side also

208
00:08:17,680 --> 00:08:21,680
knows

209
00:08:18,160 --> 00:08:23,120
how to evaluate aids so it can recompute

210
00:08:21,680 --> 00:08:25,039
this challenge

211
00:08:23,120 --> 00:08:26,960
and verify again that the response is

212
00:08:25,039 --> 00:08:28,878
correct with respect to

213
00:08:26,960 --> 00:08:31,840
this particular commitment and this

214
00:08:28,879 --> 00:08:33,519
particular challenge

215
00:08:31,840 --> 00:08:35,120
additionally the proofer could send a

216
00:08:33,519 --> 00:08:36,399
message along with this commitment in

217
00:08:35,120 --> 00:08:39,039
response

218
00:08:36,399 --> 00:08:40,799
as well as include it in the hash

219
00:08:39,039 --> 00:08:43,279
including it in the hash ensures the

220
00:08:40,799 --> 00:08:45,359
integrity of the message which combined

221
00:08:43,279 --> 00:08:47,120
with the proof of identity makes for a

222
00:08:45,360 --> 00:08:49,360
digital signature

223
00:08:47,120 --> 00:08:51,440
so this is the idea of fiat xiamir

224
00:08:49,360 --> 00:08:54,000
signatures

225
00:08:51,440 --> 00:08:55,839
well to prove this construction secure

226
00:08:54,000 --> 00:08:58,560
in the queue rom

227
00:08:55,839 --> 00:09:00,320
don fear myself schaffner in 2019

228
00:08:58,560 --> 00:09:01,439
presented the measure and reprogram

229
00:09:00,320 --> 00:09:03,920
technique

230
00:09:01,440 --> 00:09:05,760
which is basically the same as the

231
00:09:03,920 --> 00:09:08,880
multi-input version which i already

232
00:09:05,760 --> 00:09:11,920
presented to you except that now

233
00:09:08,880 --> 00:09:12,480
the output of the s adversary is just

234
00:09:11,920 --> 00:09:17,040
this

235
00:09:12,480 --> 00:09:20,160
single hash input x along with c

236
00:09:17,040 --> 00:09:22,480
and the simulator now chooses just one

237
00:09:20,160 --> 00:09:24,000
of the adversaries queries at random

238
00:09:22,480 --> 00:09:27,360
measures it

239
00:09:24,000 --> 00:09:29,519
reprograms the oracle on this input to a

240
00:09:27,360 --> 00:09:31,920
fresh random value theta

241
00:09:29,519 --> 00:09:33,120
and then we again get the guarantee that

242
00:09:31,920 --> 00:09:36,800
some predicate v

243
00:09:33,120 --> 00:09:40,080
holds now with respect to theta

244
00:09:36,800 --> 00:09:40,719
up to a q squared loss and also here we

245
00:09:40,080 --> 00:09:43,920
have

246
00:09:40,720 --> 00:09:45,120
an additive error term but the theorem

247
00:09:43,920 --> 00:09:46,959
has to promise that

248
00:09:45,120 --> 00:09:49,120
even when summing over all possible

249
00:09:46,959 --> 00:09:52,000
instances of x naught

250
00:09:49,120 --> 00:09:54,959
the error term remains negligible so we

251
00:09:52,000 --> 00:09:57,200
don't have to worry about it

252
00:09:54,959 --> 00:09:59,199
okay now i'll finally show you how to

253
00:09:57,200 --> 00:10:02,839
apply this tool

254
00:09:59,200 --> 00:10:04,720
in a reduction for the plain fiat xiaomi

255
00:10:02,839 --> 00:10:06,800
transformation

256
00:10:04,720 --> 00:10:07,839
what we want to do in the reduction is

257
00:10:06,800 --> 00:10:10,000
turn

258
00:10:07,839 --> 00:10:10,880
a proofer against the non-interactive

259
00:10:10,000 --> 00:10:13,760
fiat xiaomi

260
00:10:10,880 --> 00:10:14,399
scheme into approver for the interactive

261
00:10:13,760 --> 00:10:17,360
scheme

262
00:10:14,399 --> 00:10:18,240
to show that both are approximately

263
00:10:17,360 --> 00:10:20,959
equally hard

264
00:10:18,240 --> 00:10:20,959
to break

265
00:10:21,360 --> 00:10:25,279
well the pattern can be matched as

266
00:10:24,640 --> 00:10:28,640
follows

267
00:10:25,279 --> 00:10:31,120
we know that the adversary will output a

268
00:10:28,640 --> 00:10:32,480
public key a commitment and a response

269
00:10:31,120 --> 00:10:34,240
so the public key and the commitment to

270
00:10:32,480 --> 00:10:37,120
take the role of x and the response

271
00:10:34,240 --> 00:10:37,120
takes the role of c

272
00:10:37,440 --> 00:10:43,920
which means that we can start up

273
00:10:40,640 --> 00:10:47,199
an interactive protocol by

274
00:10:43,920 --> 00:10:51,279
running the adversary as a subroutine

275
00:10:47,200 --> 00:10:53,360
and just wait until the particular

276
00:10:51,279 --> 00:10:55,680
query comes up that we have chosen

277
00:10:53,360 --> 00:10:58,160
randomly to measure

278
00:10:55,680 --> 00:11:00,880
once we've measured it we have a public

279
00:10:58,160 --> 00:11:01,439
key and a commitment so we can send that

280
00:11:00,880 --> 00:11:05,120
to the

281
00:11:01,440 --> 00:11:05,600
interactive verifier the challenge that

282
00:11:05,120 --> 00:11:09,279
we

283
00:11:05,600 --> 00:11:11,680
get in return we program into the oracle

284
00:11:09,279 --> 00:11:13,519
and feed it back to the adversary and

285
00:11:11,680 --> 00:11:16,800
now we just have to wait

286
00:11:13,519 --> 00:11:18,560
for the adversary to finish and we get a

287
00:11:16,800 --> 00:11:20,399
response

288
00:11:18,560 --> 00:11:21,839
which we then forward back to the

289
00:11:20,399 --> 00:11:24,079
verifier and

290
00:11:21,839 --> 00:11:24,959
now of course with this inequality at

291
00:11:24,079 --> 00:11:28,160
hand

292
00:11:24,959 --> 00:11:30,959
we know that the probability that this

293
00:11:28,160 --> 00:11:31,839
response is correct with respect to this

294
00:11:30,959 --> 00:11:36,239
challenge

295
00:11:31,839 --> 00:11:39,040
which is represented here by theta

296
00:11:36,240 --> 00:11:39,920
is approximately the same up to this q

297
00:11:39,040 --> 00:11:42,800
squared plus

298
00:11:39,920 --> 00:11:44,079
as the probability that the original

299
00:11:42,800 --> 00:11:46,560
adversary can

300
00:11:44,079 --> 00:11:48,000
break the non-interactive fiat chamber

301
00:11:46,560 --> 00:11:51,199
scheme

302
00:11:48,000 --> 00:11:52,160
so that's the that's the reduction but

303
00:11:51,200 --> 00:11:54,560
as i said

304
00:11:52,160 --> 00:11:56,719
this is only a playing field xiaomi for

305
00:11:54,560 --> 00:11:58,719
three round schemes

306
00:11:56,720 --> 00:12:02,480
the main topic of the current work is

307
00:11:58,720 --> 00:12:06,480
about multi-round field xiaomi

308
00:12:02,480 --> 00:12:08,160
and indeed there exists many

309
00:12:06,480 --> 00:12:09,519
two n plus one round public coin

310
00:12:08,160 --> 00:12:14,000
interactive proof systems

311
00:12:09,519 --> 00:12:14,000
for constant but also logarithmic and

312
00:12:14,079 --> 00:12:20,079
where we can again

313
00:12:17,120 --> 00:12:22,839
remove the interaction in a fiat xiaomi

314
00:12:20,079 --> 00:12:25,279
or a heuristic

315
00:12:22,839 --> 00:12:28,240
way it looks

316
00:12:25,279 --> 00:12:31,040
like this we have an interactive scheme

317
00:12:28,240 --> 00:12:34,880
consisting of many rounds

318
00:12:31,040 --> 00:12:38,800
and just as before all these uniformly

319
00:12:34,880 --> 00:12:39,839
random challenges can we can be replaced

320
00:12:38,800 --> 00:12:43,279
by

321
00:12:39,839 --> 00:12:45,519
outputs of some public hash function

322
00:12:43,279 --> 00:12:47,519
which the verifier can compute in it on

323
00:12:45,519 --> 00:12:50,880
its own

324
00:12:47,519 --> 00:12:52,720
so that the proofer only needs to send

325
00:12:50,880 --> 00:12:55,200
the n different commitments and the

326
00:12:52,720 --> 00:12:58,320
final response

327
00:12:55,200 --> 00:12:59,040
and that's enough for the verifier to to

328
00:12:58,320 --> 00:13:02,639
check the

329
00:12:59,040 --> 00:13:06,399
verification predicate but now

330
00:13:02,639 --> 00:13:09,360
of course in the reduction we

331
00:13:06,399 --> 00:13:11,839
need to extract all of these commitments

332
00:13:09,360 --> 00:13:14,959
all of these hash inputs

333
00:13:11,839 --> 00:13:17,200
in order to reprogram the oracle value

334
00:13:14,959 --> 00:13:19,599
to the challenges that we get from the

335
00:13:17,200 --> 00:13:22,720
interactive verifier

336
00:13:19,600 --> 00:13:25,760
now to do that obviously what we need

337
00:13:22,720 --> 00:13:28,959
is a measure and reprogram technique

338
00:13:25,760 --> 00:13:31,200
but now one that can handle multiple

339
00:13:28,959 --> 00:13:33,359
measurements

340
00:13:31,200 --> 00:13:35,440
well of course that is exactly the

341
00:13:33,360 --> 00:13:38,079
theorem that i already presented to you

342
00:13:35,440 --> 00:13:40,000
at the beginning of this talk but let's

343
00:13:38,079 --> 00:13:40,959
for a moment assume that we don't yet

344
00:13:40,000 --> 00:13:43,360
know how to

345
00:13:40,959 --> 00:13:45,119
relate the left-hand side to the

346
00:13:43,360 --> 00:13:47,120
right-hand side scenario

347
00:13:45,120 --> 00:13:48,399
how would we go about proving this

348
00:13:47,120 --> 00:13:50,959
inequality

349
00:13:48,399 --> 00:13:54,240
starting just from the single input

350
00:13:50,959 --> 00:13:54,239
measure and reprogram tool

351
00:13:54,560 --> 00:14:02,399
well what we do is

352
00:13:58,160 --> 00:14:05,600
starting from this multi-input adversary

353
00:14:02,399 --> 00:14:07,760
we simply rewrite its output this array

354
00:14:05,600 --> 00:14:11,040
consisting of x's

355
00:14:07,760 --> 00:14:14,240
rewrite it as just x1

356
00:14:11,040 --> 00:14:18,639
with some z prime where

357
00:14:14,240 --> 00:14:21,920
now we sort of put all the

358
00:14:18,639 --> 00:14:25,199
or the other x values x2 up to xn

359
00:14:21,920 --> 00:14:27,040
inside c prime and it also contains the

360
00:14:25,199 --> 00:14:30,319
original

361
00:14:27,040 --> 00:14:33,199
additional output c

362
00:14:30,320 --> 00:14:33,839
so we really didn't do anything except

363
00:14:33,199 --> 00:14:37,199
just

364
00:14:33,839 --> 00:14:40,399
some formal trick rewriting

365
00:14:37,199 --> 00:14:43,040
but now the output has exactly the form

366
00:14:40,399 --> 00:14:44,320
to which we can apply the single input

367
00:14:43,040 --> 00:14:46,079
result

368
00:14:44,320 --> 00:14:48,240
namely we get the existence of a

369
00:14:46,079 --> 00:14:48,959
simulator that picks one of a's queries

370
00:14:48,240 --> 00:14:53,440
at random

371
00:14:48,959 --> 00:14:56,239
measures it finds x1 and reprograms

372
00:14:53,440 --> 00:14:57,279
the oracle at x1 to theta 1 such that

373
00:14:56,240 --> 00:15:01,279
now

374
00:14:57,279 --> 00:15:06,240
the predicate holds with respect to

375
00:15:01,279 --> 00:15:09,360
theta one instead of h of x one

376
00:15:06,240 --> 00:15:12,959
and note that here we made a choice to

377
00:15:09,360 --> 00:15:14,720
let s talk to the real random oracle

378
00:15:12,959 --> 00:15:17,199
instead of letting it use a

379
00:15:14,720 --> 00:15:18,959
pseudo-random function

380
00:15:17,199 --> 00:15:20,639
and the reason for this is that we can

381
00:15:18,959 --> 00:15:23,359
now consider

382
00:15:20,639 --> 00:15:25,440
a and s together as yet another

383
00:15:23,360 --> 00:15:29,600
algorithm

384
00:15:25,440 --> 00:15:32,959
which just has this particular output

385
00:15:29,600 --> 00:15:36,720
x1 c prime which we can again

386
00:15:32,959 --> 00:15:40,319
rewrite such that now

387
00:15:36,720 --> 00:15:43,199
x2 is the prominent hash input

388
00:15:40,320 --> 00:15:43,680
and z double prime has all the other

389
00:15:43,199 --> 00:15:46,719
axes

390
00:15:43,680 --> 00:15:49,599
and the original c so that

391
00:15:46,720 --> 00:15:52,240
of course as you can guess we can apply

392
00:15:49,600 --> 00:15:55,680
the single input result again

393
00:15:52,240 --> 00:15:59,680
to now measure x2

394
00:15:55,680 --> 00:15:59,680
and continuing

395
00:16:00,000 --> 00:16:07,279
for n times we will eventually get

396
00:16:03,199 --> 00:16:10,959
an algorithm which outputs x1 up to xn

397
00:16:07,279 --> 00:16:13,759
and z such that the predicate v

398
00:16:10,959 --> 00:16:16,479
checks out with respect to theta one up

399
00:16:13,759 --> 00:16:18,399
to theta n

400
00:16:16,480 --> 00:16:21,519
but what is now the loss factor that we

401
00:16:18,399 --> 00:16:23,839
get from this inductive application

402
00:16:21,519 --> 00:16:25,040
well from the first application we get a

403
00:16:23,839 --> 00:16:28,399
q squared loss

404
00:16:25,040 --> 00:16:30,560
as well as this additive error term

405
00:16:28,399 --> 00:16:32,160
and then in the second application we're

406
00:16:30,560 --> 00:16:33,518
up to q to the fourth and we have two

407
00:16:32,160 --> 00:16:35,839
error terms

408
00:16:33,519 --> 00:16:37,120
so continuing the pattern we indeed get

409
00:16:35,839 --> 00:16:41,360
this promised

410
00:16:37,120 --> 00:16:45,759
q to the power 2 n multiplicative plus

411
00:16:41,360 --> 00:16:47,600
and a sum of n error terms

412
00:16:45,759 --> 00:16:49,680
and if you remember we had the promise

413
00:16:47,600 --> 00:16:52,560
that for each i

414
00:16:49,680 --> 00:16:53,359
summing over all possible instances x i

415
00:16:52,560 --> 00:16:57,119
naught

416
00:16:53,360 --> 00:17:00,399
this error term remains negligible

417
00:16:57,120 --> 00:17:03,920
so surely summing over n of them

418
00:17:00,399 --> 00:17:07,039
keeping in mind that in applications and

419
00:17:03,920 --> 00:17:10,079
is constant or logarithmic the whole sum

420
00:17:07,039 --> 00:17:14,000
will remain negligible

421
00:17:10,079 --> 00:17:17,280
but the problem is that

422
00:17:14,000 --> 00:17:20,559
this is not what we need if we

423
00:17:17,280 --> 00:17:23,439
have a careful look at the inequality

424
00:17:20,559 --> 00:17:24,879
down here we see that this is for one

425
00:17:23,439 --> 00:17:28,480
particular choice

426
00:17:24,880 --> 00:17:29,760
of that array x naught so for one choice

427
00:17:28,480 --> 00:17:32,799
of combinations

428
00:17:29,760 --> 00:17:36,240
x one up to x n

429
00:17:32,799 --> 00:17:39,520
and if we sum over all possible areas

430
00:17:36,240 --> 00:17:42,559
we're going to sum over many more values

431
00:17:39,520 --> 00:17:46,639
than just

432
00:17:42,559 --> 00:17:50,399
each of the x i's summed independently

433
00:17:46,640 --> 00:17:53,760
so we can no longer control the size of

434
00:17:50,400 --> 00:17:56,799
this combined error that we have here

435
00:17:53,760 --> 00:18:00,160
and this proved it need to be a

436
00:17:56,799 --> 00:18:01,520
substantial barrier to completing the

437
00:18:00,160 --> 00:18:05,120
proof

438
00:18:01,520 --> 00:18:08,639
so what we had to do was go back to

439
00:18:05,120 --> 00:18:10,320
the original single input result

440
00:18:08,640 --> 00:18:11,679
and you'll now see why we call it the

441
00:18:10,320 --> 00:18:15,760
measure and reprogram

442
00:18:11,679 --> 00:18:18,480
technique 2.0 because what we did is we

443
00:18:15,760 --> 00:18:19,440
improved the original single input

444
00:18:18,480 --> 00:18:22,640
result

445
00:18:19,440 --> 00:18:24,720
we gave a different proof that doesn't

446
00:18:22,640 --> 00:18:26,480
have the need for this negligible error

447
00:18:24,720 --> 00:18:29,440
term

448
00:18:26,480 --> 00:18:29,760
which makes the statement cleaner and

449
00:18:29,440 --> 00:18:32,960
well

450
00:18:29,760 --> 00:18:35,039
for single input applications

451
00:18:32,960 --> 00:18:36,160
we get a negligible quantitative

452
00:18:35,039 --> 00:18:38,799
improvement

453
00:18:36,160 --> 00:18:39,440
but most importantly we lose the error

454
00:18:38,799 --> 00:18:42,480
terms

455
00:18:39,440 --> 00:18:46,559
in the multi-input case

456
00:18:42,480 --> 00:18:46,559
and we get the result that we wanted

457
00:18:47,120 --> 00:18:51,840
now one small issue that i have to

458
00:18:50,799 --> 00:18:54,160
mention

459
00:18:51,840 --> 00:18:55,600
as well if we now want to apply this

460
00:18:54,160 --> 00:18:58,160
multi-input

461
00:18:55,600 --> 00:18:59,520
reprogramming results to multi-round

462
00:18:58,160 --> 00:19:00,880
fiat xiaomi

463
00:18:59,520 --> 00:19:02,879
there's one more thing that we need to

464
00:19:00,880 --> 00:19:04,960
take care of

465
00:19:02,880 --> 00:19:07,520
as you can see this inductive

466
00:19:04,960 --> 00:19:09,520
application of the single input results

467
00:19:07,520 --> 00:19:11,039
does not give us any guarantee on the

468
00:19:09,520 --> 00:19:14,559
order of the

469
00:19:11,039 --> 00:19:17,840
hash inputs that we extract

470
00:19:14,559 --> 00:19:21,678
here in this example x2 is extracted

471
00:19:17,840 --> 00:19:24,799
before x3 but also before x1

472
00:19:21,679 --> 00:19:28,320
and in the reduction that we want to

473
00:19:24,799 --> 00:19:30,639
perform the interactive verifier

474
00:19:28,320 --> 00:19:31,760
expects these commitments in a

475
00:19:30,640 --> 00:19:34,880
particular order

476
00:19:31,760 --> 00:19:38,400
we cannot just send it com2 first and

477
00:19:34,880 --> 00:19:40,960
come one only at some later point so

478
00:19:38,400 --> 00:19:41,679
somehow we need to ensure that we

479
00:19:40,960 --> 00:19:44,720
extract

480
00:19:41,679 --> 00:19:45,520
the commitments in the right order the

481
00:19:44,720 --> 00:19:48,320
way to do that

482
00:19:45,520 --> 00:19:48,879
is simply to include the previous

483
00:19:48,320 --> 00:19:52,159
challenge

484
00:19:48,880 --> 00:19:52,880
in the hash for the next challenge which

485
00:19:52,160 --> 00:19:56,400
would mean

486
00:19:52,880 --> 00:19:59,520
in this example that before

487
00:19:56,400 --> 00:20:02,640
adversary could even query x2

488
00:19:59,520 --> 00:20:07,840
it needs to know the value of theta 1

489
00:20:02,640 --> 00:20:07,840
since it will be a part of x2

490
00:20:08,000 --> 00:20:14,400
so that that enforces the

491
00:20:11,120 --> 00:20:14,879
adversary to query all the hash inputs

492
00:20:14,400 --> 00:20:17,600
in the

493
00:20:14,880 --> 00:20:18,880
correct order this is not our

494
00:20:17,600 --> 00:20:21,840
contribution this is

495
00:20:18,880 --> 00:20:21,840
folklore knowledge

496
00:20:22,480 --> 00:20:25,520
also for classical multiround via

497
00:20:24,640 --> 00:20:27,280
charmer

498
00:20:25,520 --> 00:20:30,400
but i just wanted to mention it to

499
00:20:27,280 --> 00:20:30,399
complete the analysis

500
00:20:31,600 --> 00:20:39,280
okay so finally uh few words about

501
00:20:35,840 --> 00:20:42,799
another application of our new technique

502
00:20:39,280 --> 00:20:46,158
namely sequential or proofs

503
00:20:42,799 --> 00:20:48,559
this is something introduced by leo

504
00:20:46,159 --> 00:20:51,360
wayne one in 2004

505
00:20:48,559 --> 00:20:51,840
and it's it's via charming with a twist

506
00:20:51,360 --> 00:20:55,280
which

507
00:20:51,840 --> 00:20:58,480
allows a proofer to prove the truth of

508
00:20:55,280 --> 00:21:01,600
at least one of two statement x1 x2

509
00:20:58,480 --> 00:21:02,080
without revealing which one so it's it's

510
00:21:01,600 --> 00:21:05,280
a proof

511
00:21:02,080 --> 00:21:08,399
of the this young disjunction really

512
00:21:05,280 --> 00:21:12,320
uh and how does it work well uh

513
00:21:08,400 --> 00:21:12,720
the uh we we start from a simple three

514
00:21:12,320 --> 00:21:16,080
round

515
00:21:12,720 --> 00:21:18,080
uh sigma protocol and we

516
00:21:16,080 --> 00:21:20,799
use a hash function to turn it into a

517
00:21:18,080 --> 00:21:24,240
non-interactive scheme

518
00:21:20,799 --> 00:21:27,360
but now the challenges

519
00:21:24,240 --> 00:21:30,640
are computed over cross

520
00:21:27,360 --> 00:21:33,760
the proofer has to provide x1 com1 x2

521
00:21:30,640 --> 00:21:35,840
com2 and then uses aids of com2

522
00:21:33,760 --> 00:21:36,799
in order to compute the response that

523
00:21:35,840 --> 00:21:38,559
will be used to

524
00:21:36,799 --> 00:21:40,000
prove the statement the truth of

525
00:21:38,559 --> 00:21:43,440
statement x1

526
00:21:40,000 --> 00:21:45,919
and vice versa it uses aids of com1

527
00:21:43,440 --> 00:21:47,280
to compute the response that will be

528
00:21:45,919 --> 00:21:51,919
verified

529
00:21:47,280 --> 00:21:56,080
to determine the truth of statement x2

530
00:21:51,919 --> 00:21:58,880
now if we look carefully we see that

531
00:21:56,080 --> 00:21:59,760
only for this statement corresponding to

532
00:21:58,880 --> 00:22:02,000
the commitment

533
00:21:59,760 --> 00:22:03,919
that is the first out of the two that

534
00:22:02,000 --> 00:22:07,440
gets queried to age

535
00:22:03,919 --> 00:22:09,360
only for this statement the proofer

536
00:22:07,440 --> 00:22:12,559
needs to actually know a witness in

537
00:22:09,360 --> 00:22:17,199
order to compute a valid response

538
00:22:12,559 --> 00:22:21,440
why is this so well let's have a look

539
00:22:17,200 --> 00:22:23,360
suppose for now that com1 is the

540
00:22:21,440 --> 00:22:25,039
further the commitment that gets queried

541
00:22:23,360 --> 00:22:28,240
first

542
00:22:25,039 --> 00:22:29,360
then before having anything to do with

543
00:22:28,240 --> 00:22:32,960
com2

544
00:22:29,360 --> 00:22:35,678
the proofer already knows age of com1

545
00:22:32,960 --> 00:22:36,720
in other words knows the challenge that

546
00:22:35,679 --> 00:22:40,240
it will need

547
00:22:36,720 --> 00:22:42,799
to compute response to

548
00:22:40,240 --> 00:22:44,159
but by the honest verifiers here on

549
00:22:42,799 --> 00:22:46,000
knowledge property

550
00:22:44,159 --> 00:22:48,480
knowing the challenge before knowing the

551
00:22:46,000 --> 00:22:49,760
commitment allows one to compute the

552
00:22:48,480 --> 00:22:53,120
fake proof

553
00:22:49,760 --> 00:22:56,240
so to find some come to and

554
00:22:53,120 --> 00:22:59,678
responds to such that this predicate is

555
00:22:56,240 --> 00:22:59,679
satisfied for x2

556
00:22:59,840 --> 00:23:05,280
even without without knowing a witness

557
00:23:02,640 --> 00:23:05,280
for x2

558
00:23:05,679 --> 00:23:12,400
and then if com2 has been determined

559
00:23:09,200 --> 00:23:16,159
by this fake proof then the proofer can

560
00:23:12,400 --> 00:23:19,520
query it to 8 to find the challenge

561
00:23:16,159 --> 00:23:20,840
which now using a witness for x1 it can

562
00:23:19,520 --> 00:23:23,840
compute the valid

563
00:23:20,840 --> 00:23:27,280
response so that also the

564
00:23:23,840 --> 00:23:30,559
the other predicate is satisfied

565
00:23:27,280 --> 00:23:34,840
so the the security reduction uh works

566
00:23:30,559 --> 00:23:36,000
similarly uh we want to use a

567
00:23:34,840 --> 00:23:40,158
non-interactive

568
00:23:36,000 --> 00:23:43,360
adversary to convince

569
00:23:40,159 --> 00:23:46,799
one of the two verifiers or the verifier

570
00:23:43,360 --> 00:23:46,799
on one of the two statements

571
00:23:46,960 --> 00:23:50,240
but note that in order to do so we we

572
00:23:49,679 --> 00:23:53,279
have to

573
00:23:50,240 --> 00:23:56,320
extract both com1 and com2

574
00:23:53,279 --> 00:23:59,440
from this non-interactive adversary

575
00:23:56,320 --> 00:24:02,639
namely we have to extract

576
00:23:59,440 --> 00:24:06,559
com1 because this is the commitment that

577
00:24:02,640 --> 00:24:10,240
we are going to submit to the verifier

578
00:24:06,559 --> 00:24:12,799
remember we're assuming that x1

579
00:24:10,240 --> 00:24:15,039
is the is the statement that is actually

580
00:24:12,799 --> 00:24:16,639
true

581
00:24:15,039 --> 00:24:19,200
so the com1 is the one that we're going

582
00:24:16,640 --> 00:24:22,400
to submit to the verifier

583
00:24:19,200 --> 00:24:25,520
but we also need to extract com2

584
00:24:22,400 --> 00:24:28,000
because com2 is the input

585
00:24:25,520 --> 00:24:29,918
to the random oracle on which we need to

586
00:24:28,000 --> 00:24:32,559
reprogram

587
00:24:29,919 --> 00:24:34,720
in order to inject the challenge that we

588
00:24:32,559 --> 00:24:36,879
get from this verifier

589
00:24:34,720 --> 00:24:38,480
so that the response computed by the

590
00:24:36,880 --> 00:24:41,520
non-interactive adversary

591
00:24:38,480 --> 00:24:44,159
will be valid with respect to com1

592
00:24:41,520 --> 00:24:47,039
and the this channels that we

593
00:24:44,159 --> 00:24:50,159
reprogrammed to

594
00:24:47,039 --> 00:24:53,520
so yeah indeed

595
00:24:50,159 --> 00:24:56,159
using the multi-input

596
00:24:53,520 --> 00:24:58,158
measure and reprogram technique we can

597
00:24:56,159 --> 00:25:01,440
now for the first time prefight

598
00:24:58,159 --> 00:25:05,440
provide a cure reduction for this

599
00:25:01,440 --> 00:25:06,720
sequential or proof that concludes the

600
00:25:05,440 --> 00:25:10,720
talk

601
00:25:06,720 --> 00:25:10,720
thank you for listening

