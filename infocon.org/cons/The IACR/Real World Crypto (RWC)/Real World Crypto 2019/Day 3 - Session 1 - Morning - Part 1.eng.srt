1
00:07:56,009 --> 00:08:05,710
hello everybody welcome to the last

2
00:08:00,669 --> 00:08:07,419
morning of real world crypto 2019 I'm

3
00:08:05,710 --> 00:08:09,250
going to be popping up at different

4
00:08:07,419 --> 00:08:11,530
points during the day to say exactly the

5
00:08:09,250 --> 00:08:14,889
same thing is we're now planning for

6
00:08:11,530 --> 00:08:17,559
2020 as you can appreciate it's a very

7
00:08:14,889 --> 00:08:20,710
big conference to organize and therefore

8
00:08:17,560 --> 00:08:22,780
we need sponsorship I've already had two

9
00:08:20,710 --> 00:08:25,599
companies have already come up to me new

10
00:08:22,780 --> 00:08:28,299
sponsors already during the the program

11
00:08:25,599 --> 00:08:30,490
already this this time to add them to

12
00:08:28,300 --> 00:08:32,620
the huge list of sponsors if you're a

13
00:08:30,490 --> 00:08:36,250
company and you don't already sponsor us

14
00:08:32,620 --> 00:08:39,640
just come up to me give me your email

15
00:08:36,250 --> 00:08:41,110
and then give me your money and we will

16
00:08:39,640 --> 00:08:43,360
make sure that you're put on the list of

17
00:08:41,110 --> 00:08:47,950
sponsors for next year and with that I

18
00:08:43,360 --> 00:08:48,490
hand over to the boss thanks good

19
00:08:47,950 --> 00:08:49,540
morning everyone

20
00:08:48,490 --> 00:08:51,040
good to see some of you here this

21
00:08:49,540 --> 00:08:54,160
morning and the morning after the night

22
00:08:51,040 --> 00:08:57,250
before how many people had margaritas I

23
00:08:54,160 --> 00:08:59,529
had I had one too well maybe maybe more

24
00:08:57,250 --> 00:09:00,730
than that anyway let's get started so

25
00:08:59,529 --> 00:09:03,279
we've got three talks in this session

26
00:09:00,730 --> 00:09:06,250
and the first one is going to be given

27
00:09:03,279 --> 00:09:08,620
by Anders a person from I think from MIT

28
00:09:06,250 --> 00:09:12,209
and it's about efficient and verified

29
00:09:08,620 --> 00:09:12,209
finite field operations Thank You Anders

30
00:09:14,500 --> 00:09:19,100
good morning railroad crypto thanks to

31
00:09:17,389 --> 00:09:20,870
all of you who have come here at 9:00

32
00:09:19,100 --> 00:09:24,110
a.m. braving blockchain and sleep tap

33
00:09:20,870 --> 00:09:26,629
and I'm going to talking to talk about

34
00:09:24,110 --> 00:09:29,000
work that me and my college colleagues

35
00:09:26,629 --> 00:09:30,920
have done at MIT to produce high-quality

36
00:09:29,000 --> 00:09:32,300
implementations of finite field

37
00:09:30,920 --> 00:09:34,790
arithmetic for elliptic curves and the

38
00:09:32,300 --> 00:09:37,819
other crypto systems with proofs of

39
00:09:34,790 --> 00:09:39,800
functional correctness and generally

40
00:09:37,819 --> 00:09:41,360
good imitation style now here is an

41
00:09:39,800 --> 00:09:44,959
example of the state of practice today

42
00:09:41,360 --> 00:09:46,550
it's for the P to f6 elliptic curve the

43
00:09:44,959 --> 00:09:47,989
multiplication routine and next slide

44
00:09:46,550 --> 00:09:49,910
you can see the corresponding module

45
00:09:47,990 --> 00:09:51,230
reduction and for most of you the front

46
00:09:49,910 --> 00:09:52,670
is probably too small to make any sense

47
00:09:51,230 --> 00:09:54,889
of at this distance and you're not

48
00:09:52,670 --> 00:09:56,329
missing much inside anyway because all

49
00:09:54,889 --> 00:09:58,250
of this is really hand unrolled

50
00:09:56,329 --> 00:10:00,589
low-level optimized code based on a more

51
00:09:58,250 --> 00:10:01,790
general algorithm but it's not just the

52
00:10:00,589 --> 00:10:03,649
low level optimizations that make this

53
00:10:01,790 --> 00:10:05,000
kind of code tricky even if you look at

54
00:10:03,649 --> 00:10:07,310
the algorithm on its own this is the

55
00:10:05,000 --> 00:10:09,199
32-bit version of it it is still not

56
00:10:07,310 --> 00:10:10,729
obvious that you know it does the right

57
00:10:09,199 --> 00:10:14,628
thing or even that it corresponds to P

58
00:10:10,730 --> 00:10:16,519
to have 6 at all so in reality what

59
00:10:14,629 --> 00:10:17,959
happens is that there are experts many

60
00:10:16,519 --> 00:10:19,939
of whom are in this room or at least

61
00:10:17,959 --> 00:10:21,859
where yesterday who write this code

62
00:10:19,939 --> 00:10:24,319
meticulously for every combination of

63
00:10:21,860 --> 00:10:25,970
the desired operation their prime

64
00:10:24,319 --> 00:10:29,000
modulus and the hardware architecture

65
00:10:25,970 --> 00:10:31,730
being targeted and these experts are

66
00:10:29,000 --> 00:10:34,279
really in demand there is a lot of work

67
00:10:31,730 --> 00:10:35,449
to be done and every person who

68
00:10:34,279 --> 00:10:37,430
specialized in this field that I've

69
00:10:35,449 --> 00:10:38,899
talked to has a backlog and the future

70
00:10:37,430 --> 00:10:40,399
log of implementations they wish that

71
00:10:38,899 --> 00:10:44,269
could be improved that could be written

72
00:10:40,399 --> 00:10:47,300
to the future so we decided to do

73
00:10:44,269 --> 00:10:48,500
something different and by different I

74
00:10:47,300 --> 00:10:49,670
mean really mean we built a different

75
00:10:48,500 --> 00:10:51,379
implementation when from at the same

76
00:10:49,670 --> 00:10:53,899
interface as everybody else our code can

77
00:10:51,379 --> 00:10:55,069
be linked in place of existing

78
00:10:53,899 --> 00:10:58,850
implementations with relatively little

79
00:10:55,069 --> 00:10:59,990
effort however from from the get-go we

80
00:10:58,850 --> 00:11:01,790
insisted on machine shockable

81
00:10:59,990 --> 00:11:03,319
correctness proofs so we use the clock

82
00:11:01,790 --> 00:11:04,610
proof assistant and every operation

83
00:11:03,319 --> 00:11:05,779
including the non performance critical

84
00:11:04,610 --> 00:11:07,970
ones like serialization and

85
00:11:05,779 --> 00:11:09,860
deserialization has a proof and these

86
00:11:07,970 --> 00:11:11,829
proofs composed together to a proof of a

87
00:11:09,860 --> 00:11:13,819
full elliptic curve operation

88
00:11:11,829 --> 00:11:16,069
furthermore we did something rather

89
00:11:13,819 --> 00:11:18,349
unconventional we use the same source

90
00:11:16,069 --> 00:11:20,349
code for multiple primes and multiple

91
00:11:18,350 --> 00:11:22,220
hardware architectures so we write one

92
00:11:20,350 --> 00:11:24,490
unsaturated Selina's reduction

93
00:11:22,220 --> 00:11:28,160
implementation that works for poly 1305

94
00:11:24,490 --> 00:11:30,679
31:19 and curve 448 if you are willing

95
00:11:28,160 --> 00:11:33,860
to forego the cur super attacker superb

96
00:11:30,679 --> 00:11:36,079
multiplication and it actually turns out

97
00:11:33,860 --> 00:11:37,819
it worked really well when we first got

98
00:11:36,079 --> 00:11:39,709
the full pipeline working the C code

99
00:11:37,819 --> 00:11:42,829
that it spit out after compile time

100
00:11:39,709 --> 00:11:44,989
specialization performed better than

101
00:11:42,829 --> 00:11:48,649
expert written C code we had found an

102
00:11:44,990 --> 00:11:50,420
internet by that date and throughout

103
00:11:48,649 --> 00:11:52,579
this entire work who have enjoyed a

104
00:11:50,420 --> 00:11:55,459
fruitful collaboration with titan and

105
00:11:52,579 --> 00:11:57,319
pouring SSL teams at Google both of them

106
00:11:55,459 --> 00:11:59,508
use our implementations for multiple

107
00:11:57,319 --> 00:12:01,599
missed Prime's or at least three to five

108
00:11:59,509 --> 00:12:04,009
six in both of them and Kurt 1:9

109
00:12:01,600 --> 00:12:06,230
furthermore some open source libraries

110
00:12:04,009 --> 00:12:08,449
like wire guard and ring in the rust

111
00:12:06,230 --> 00:12:09,769
language link our code and maybe there

112
00:12:08,449 --> 00:12:14,389
are others but we haven't really done

113
00:12:09,769 --> 00:12:16,220
the census so they'll just add I rat

114
00:12:14,389 --> 00:12:17,839
right into it let's take a look at what

115
00:12:16,220 --> 00:12:19,850
that generated code looks like and what

116
00:12:17,839 --> 00:12:24,170
needs to be provided for every specific

117
00:12:19,850 --> 00:12:25,759
curve to get some code out for it let's

118
00:12:24,170 --> 00:12:28,699
try an implementation using the

119
00:12:25,759 --> 00:12:32,660
unsaturated selena strategy let's name

120
00:12:28,699 --> 00:12:37,069
it my curve and let's pick the prime 2

121
00:12:32,660 --> 00:12:38,420
through 255 minus 19 and the - for some

122
00:12:37,069 --> 00:12:39,620
reason did not fit in this command line

123
00:12:38,420 --> 00:12:42,110
interface so it's not there and we

124
00:12:39,620 --> 00:12:46,720
synthesized multiplication that includes

125
00:12:42,110 --> 00:12:53,059
carry and let's do it using ten limbs on

126
00:12:46,720 --> 00:12:56,540
64th 32-bit machine so here it is that

127
00:12:53,059 --> 00:12:58,399
is essentially you know modular variable

128
00:12:56,540 --> 00:13:00,949
names it is roughly the same code an

129
00:12:58,399 --> 00:13:02,110
expert would write if given the same

130
00:13:00,949 --> 00:13:05,809
task

131
00:13:02,110 --> 00:13:07,250
furthermore the same trick can be

132
00:13:05,809 --> 00:13:08,870
repeated with different parameters so

133
00:13:07,250 --> 00:13:11,779
we're calling the same code generator

134
00:13:08,870 --> 00:13:16,360
binary this time the prime is 2 to the

135
00:13:11,779 --> 00:13:19,819
130 minus 5 for a 32-bit machine and

136
00:13:16,360 --> 00:13:20,779
again here is the partial products of

137
00:13:19,819 --> 00:13:22,490
the multiplication

138
00:13:20,779 --> 00:13:24,559
here's the module reduction at the end

139
00:13:22,490 --> 00:13:26,240
and on top of the generated

140
00:13:24,559 --> 00:13:28,819
implementation is also a comment that

141
00:13:26,240 --> 00:13:30,980
specifies bounds on the input and output

142
00:13:28,819 --> 00:13:32,360
lens of this operation these bounds are

143
00:13:30,980 --> 00:13:36,279
taken straight from the correctness

144
00:13:32,360 --> 00:13:38,990
proof of this so this code in talked and

145
00:13:36,279 --> 00:13:39,769
even if you are not proving the code

146
00:13:38,990 --> 00:13:42,129
that calls the

147
00:13:39,769 --> 00:13:44,059
function these pounds are a sufficient

148
00:13:42,129 --> 00:13:48,350
description of what is going on here to

149
00:13:44,059 --> 00:13:50,660
use it safely and for some crimes like P

150
00:13:48,350 --> 00:13:52,249
256 more complicated imitation

151
00:13:50,660 --> 00:13:53,509
strategies are necessary so we have a

152
00:13:52,249 --> 00:13:57,499
different code generator for each

153
00:13:53,509 --> 00:13:59,720
implementation strategy and this is the

154
00:13:57,499 --> 00:14:01,610
word by word Montgomery strategy is used

155
00:13:59,720 --> 00:14:03,920
to that fast assembly code in opposite

156
00:14:01,610 --> 00:14:05,899
cell our code is not that fast mostly

157
00:14:03,920 --> 00:14:09,079
because it's si but it's still very good

158
00:14:05,899 --> 00:14:11,089
and still proofs and perhaps if C

159
00:14:09,079 --> 00:14:12,920
compilers were able to compile carry

160
00:14:11,089 --> 00:14:19,339
flag access better it could be as fast

161
00:14:12,920 --> 00:14:20,868
but that's not today you know let's go

162
00:14:19,339 --> 00:14:24,739
back and look at what is actually going

163
00:14:20,869 --> 00:14:26,299
on under the hood to make this happen at

164
00:14:24,739 --> 00:14:29,989
the center of our strategy is the

165
00:14:26,299 --> 00:14:32,749
proof assistant so the proposition

166
00:14:29,989 --> 00:14:34,850
is made for primarily mathematics also

167
00:14:32,749 --> 00:14:36,139
program verification and that the center

168
00:14:34,850 --> 00:14:37,639
of it is a functional programming

169
00:14:36,139 --> 00:14:39,230
language in which definitions and

170
00:14:37,639 --> 00:14:40,670
theorem statements can be written so

171
00:14:39,230 --> 00:14:41,899
there are no built-in verification

172
00:14:40,670 --> 00:14:43,069
conditions you need to write your own

173
00:14:41,899 --> 00:14:45,410
code and then write well you want to

174
00:14:43,069 --> 00:14:46,790
prove about it and then it is actually

175
00:14:45,410 --> 00:14:48,499
totally up to you how you come up with a

176
00:14:46,790 --> 00:14:50,089
proof object that the coq checker will

177
00:14:48,499 --> 00:14:52,490
check and the checker is the same for

178
00:14:50,089 --> 00:14:54,259
all proofs so we do not make any changes

179
00:14:52,490 --> 00:14:55,579
to it you can download the vanilla

180
00:14:54,259 --> 00:14:58,309
version of Kok and our proofs will check

181
00:14:55,579 --> 00:14:59,899
on it and the proofs are usually

182
00:14:58,309 --> 00:15:02,089
generated through some rather ad-hoc

183
00:14:59,899 --> 00:15:03,949
scripting or more in a more principled

184
00:15:02,089 --> 00:15:07,009
manner using proven correct static

185
00:15:03,949 --> 00:15:08,889
analysis pass or compiler and we rely

186
00:15:07,009 --> 00:15:11,089
heavily on these features that you can

187
00:15:08,889 --> 00:15:16,100
prove an algorithm correct and then use

188
00:15:11,089 --> 00:15:17,389
it in a proof so first of all we need to

189
00:15:16,100 --> 00:15:19,009
write the specification of what it means

190
00:15:17,389 --> 00:15:20,660
to have a finite field this is really

191
00:15:19,009 --> 00:15:22,579
simple the ROC standard library includes

192
00:15:20,660 --> 00:15:24,079
mathematical integers so we define field

193
00:15:22,579 --> 00:15:26,209
multiplication as integer multiplication

194
00:15:24,079 --> 00:15:29,029
followed by an integer modulo reduction

195
00:15:26,209 --> 00:15:30,799
each specification is one line for the

196
00:15:29,029 --> 00:15:33,610
operation itself plus one or two lines

197
00:15:30,799 --> 00:15:36,319
for the bounds of inputs and outputs

198
00:15:33,610 --> 00:15:38,299
then for each implementation strategy so

199
00:15:36,319 --> 00:15:39,919
these are things like Selina's reduction

200
00:15:38,299 --> 00:15:42,709
or Montgomery reduction or variants of

201
00:15:39,919 --> 00:15:45,259
thereof we write the generic template

202
00:15:42,709 --> 00:15:46,758
implementation so this template here is

203
00:15:45,259 --> 00:15:48,860
a Selina's reduction line shown on the

204
00:15:46,759 --> 00:15:50,720
slide will work for multiple Prime's

205
00:15:48,860 --> 00:15:52,519
when passed different parameters of

206
00:15:50,720 --> 00:15:53,270
course it is possible to pass it's silly

207
00:15:52,519 --> 00:15:55,820
parameters in

208
00:15:53,270 --> 00:15:57,110
which case it will be very very slow but

209
00:15:55,820 --> 00:15:58,850
it will still be correct in fact we

210
00:15:57,110 --> 00:16:01,490
prove that it is correct regardless of

211
00:15:58,850 --> 00:16:03,500
which parameters you pass to it but

212
00:16:01,490 --> 00:16:06,770
executing this template directly would

213
00:16:03,500 --> 00:16:08,840
be slow because here this one for

214
00:16:06,770 --> 00:16:11,540
example operates on linked lists of

215
00:16:08,840 --> 00:16:14,900
limbs so it's not going to roll in a

216
00:16:11,540 --> 00:16:17,349
real world we have a compiler pipeline

217
00:16:14,900 --> 00:16:19,370
that given an implementation and

218
00:16:17,350 --> 00:16:23,150
specific parameters for it will

219
00:16:19,370 --> 00:16:25,030
specialize it and compiled away all uses

220
00:16:23,150 --> 00:16:27,230
of dynamic memory allocation or

221
00:16:25,030 --> 00:16:28,720
references to weights of limbs that are

222
00:16:27,230 --> 00:16:31,760
sometimes present in the template itself

223
00:16:28,720 --> 00:16:35,150
to produce C code just like the one we

224
00:16:31,760 --> 00:16:37,370
saw and of course in the end we pass it

225
00:16:35,150 --> 00:16:39,260
to a C compiler depending on the C

226
00:16:37,370 --> 00:16:41,150
compiler is most likely not verified but

227
00:16:39,260 --> 00:16:43,160
our own specialization pass and the

228
00:16:41,150 --> 00:16:44,720
micro optimizations it applies and all

229
00:16:43,160 --> 00:16:46,040
the templates are verified in a manner

230
00:16:44,720 --> 00:16:47,450
the proofs composed to make an

231
00:16:46,040 --> 00:16:54,170
end-to-end certificate of correctness of

232
00:16:47,450 --> 00:16:57,410
the generated code now there are several

233
00:16:54,170 --> 00:16:59,120
important design choices we made in the

234
00:16:57,410 --> 00:17:00,800
writing of the templates that makes them

235
00:16:59,120 --> 00:17:03,500
easy to prove correct and allow them to

236
00:17:00,800 --> 00:17:04,790
generative efficient code and in the

237
00:17:03,500 --> 00:17:06,500
beginning we actually started with much

238
00:17:04,790 --> 00:17:09,829
more complicated templates in hope that

239
00:17:06,500 --> 00:17:11,690
it would generate us better code and you

240
00:17:09,829 --> 00:17:13,490
know that it should be hard work to

241
00:17:11,690 --> 00:17:14,540
write those implementations but what I'm

242
00:17:13,490 --> 00:17:16,760
going to show in the next couple of

243
00:17:14,540 --> 00:17:20,089
slides are templates that are a couple

244
00:17:16,760 --> 00:17:22,339
of lines each and perform interesting

245
00:17:20,089 --> 00:17:23,450
armed incorporations however to make

246
00:17:22,339 --> 00:17:25,399
this happen there are a couple of

247
00:17:23,450 --> 00:17:28,280
conventions we need to we have decided

248
00:17:25,400 --> 00:17:30,290
to follow first of all the templates

249
00:17:28,280 --> 00:17:32,810
work on mathematical integers so there

250
00:17:30,290 --> 00:17:35,780
is no overflow of course that means the

251
00:17:32,810 --> 00:17:38,510
compiler later needs to infer for each

252
00:17:35,780 --> 00:17:42,200
intermediate variable a fixed width in

253
00:17:38,510 --> 00:17:43,970
which it can be stored similarly each

254
00:17:42,200 --> 00:17:45,980
field element is represented in the high

255
00:17:43,970 --> 00:17:48,830
level implementation by a list of pairs

256
00:17:45,980 --> 00:17:52,010
so normally you just have limbs and the

257
00:17:48,830 --> 00:17:53,659
value of each limb is a nice index for

258
00:17:52,010 --> 00:17:56,690
us each limb also carries its own weight

259
00:17:53,660 --> 00:17:59,360
so if index 0 has weight 1 there is a

260
00:17:56,690 --> 00:18:01,640
pair of 1 comma X in our representation

261
00:17:59,360 --> 00:18:03,229
and that allows the high-level

262
00:18:01,640 --> 00:18:05,779
implementations to inspect the weights

263
00:18:03,230 --> 00:18:07,969
and branch on them for example

264
00:18:05,779 --> 00:18:10,070
but all those weights if the

265
00:18:07,969 --> 00:18:12,200
implementation is actually reasonable

266
00:18:10,070 --> 00:18:14,599
and does and does represent fast code

267
00:18:12,200 --> 00:18:16,820
are removed through constant propagation

268
00:18:14,599 --> 00:18:22,309
during compilation so none of that

269
00:18:16,820 --> 00:18:23,960
remains at runtime so here is the first

270
00:18:22,309 --> 00:18:26,029
implementation and it's in a functional

271
00:18:23,960 --> 00:18:27,950
language which I realize some of you may

272
00:18:26,029 --> 00:18:31,399
not be familiar with with but please

273
00:18:27,950 --> 00:18:33,379
bear with me it takes as input I hope

274
00:18:31,399 --> 00:18:35,748
that we'll get a pointer on here yeah

275
00:18:33,379 --> 00:18:37,070
text input two lists of pairs so the

276
00:18:35,749 --> 00:18:38,710
first element in each pair is the weight

277
00:18:37,070 --> 00:18:40,729
then the second is the runtime value and

278
00:18:38,710 --> 00:18:43,099
produces an order field element in the

279
00:18:40,729 --> 00:18:45,889
same representation then it iterates

280
00:18:43,099 --> 00:18:47,539
through both lists so map is the

281
00:18:45,889 --> 00:18:49,879
functional version of iteration that we

282
00:18:47,539 --> 00:18:52,399
apply here and for each pair of input

283
00:18:49,879 --> 00:18:53,658
limbs it produces one additional limb

284
00:18:52,399 --> 00:18:56,359
that is a partial product in that

285
00:18:53,659 --> 00:18:57,919
schoolbook multiplication sense the

286
00:18:56,359 --> 00:19:00,139
weight of the new partial product is the

287
00:18:57,919 --> 00:19:01,669
product of the old weights and the value

288
00:19:00,139 --> 00:19:04,728
of the new partial product is the

289
00:19:01,669 --> 00:19:06,609
product of the new bellies and this

290
00:19:04,729 --> 00:19:09,169
works for any representation including

291
00:19:06,609 --> 00:19:10,728
non-uniform radiuses for example the one

292
00:19:09,169 --> 00:19:14,179
used for curve two and nine and 32-bit

293
00:19:10,729 --> 00:19:16,719
architectures and notice that this code

294
00:19:14,179 --> 00:19:19,009
here will just leave around multiple

295
00:19:16,719 --> 00:19:20,330
partial products with the same weight or

296
00:19:19,009 --> 00:19:22,070
multiple partial products with slightly

297
00:19:20,330 --> 00:19:24,589
differing weights in cases of linear

298
00:19:22,070 --> 00:19:27,109
from radix but these can be aggregated

299
00:19:24,589 --> 00:19:28,609
later in a separate function that during

300
00:19:27,109 --> 00:19:31,299
compilation gets composed with this one

301
00:19:28,609 --> 00:19:33,439
and results in the code you would expect

302
00:19:31,299 --> 00:19:34,908
but writing it separately is useful

303
00:19:33,440 --> 00:19:36,859
because then we can write the proof of

304
00:19:34,909 --> 00:19:39,049
it of its correctness separately and

305
00:19:36,859 --> 00:19:40,519
this proof the complete proof of this

306
00:19:39,049 --> 00:19:43,210
multiplication is on the slide which

307
00:19:40,519 --> 00:19:46,549
consists of two lemmas one for each loop

308
00:19:43,210 --> 00:19:48,489
so the inner loop multiplies a list by a

309
00:19:46,549 --> 00:19:50,839
single length and the outer loop

310
00:19:48,489 --> 00:19:55,369
multiplies by each limb in the other

311
00:19:50,839 --> 00:19:57,529
input and most of the proof is delegated

312
00:19:55,369 --> 00:19:58,849
to the algebraic reasoning tactic and

313
00:19:57,529 --> 00:20:00,619
sets that uses criminal basis

314
00:19:58,849 --> 00:20:06,859
computation and is a part of the coq

315
00:20:00,619 --> 00:20:08,149
standard library but school the school

316
00:20:06,859 --> 00:20:09,739
book multiplication wasn't that tricky

317
00:20:08,149 --> 00:20:10,728
to begin with so perhaps it's not an

318
00:20:09,739 --> 00:20:14,179
instructive example let's look at

319
00:20:10,729 --> 00:20:16,220
something harder here is a general

320
00:20:14,179 --> 00:20:17,960
implementation of module reduction that

321
00:20:16,220 --> 00:20:19,000
is sensitive the shape of the prime so

322
00:20:17,960 --> 00:20:21,850
it

323
00:20:19,000 --> 00:20:23,230
is a generalization of the p25 six code

324
00:20:21,850 --> 00:20:26,040
that I showed earlier and the standard

325
00:20:23,230 --> 00:20:32,230
techniques used for 32 a nine curve 448

326
00:20:26,040 --> 00:20:34,870
poly 1305 and so on in the code here we

327
00:20:32,230 --> 00:20:36,310
have made an important convention to

328
00:20:34,870 --> 00:20:39,159
represent the modulus as a difference

329
00:20:36,310 --> 00:20:41,020
for s the first part in the subtraction

330
00:20:39,160 --> 00:20:43,300
is that power of two there is just

331
00:20:41,020 --> 00:20:44,500
greater than the prime and sees the

332
00:20:43,300 --> 00:20:46,090
difference between the power of two and

333
00:20:44,500 --> 00:20:48,580
the actual value of the prime and then

334
00:20:46,090 --> 00:20:51,310
the first lemma we prove that yep you

335
00:20:48,580 --> 00:20:53,919
can reduce modulo the prime by just

336
00:20:51,310 --> 00:20:55,810
replacing the the coefficient of the

337
00:20:53,920 --> 00:20:57,730
high half so s is the power of two and B

338
00:20:55,810 --> 00:20:59,770
is the high half of the vendor reducing

339
00:20:57,730 --> 00:21:01,030
and you just replace s with C and you

340
00:20:59,770 --> 00:21:03,370
have the same value of module of the

341
00:21:01,030 --> 00:21:04,660
prime notice that this first lemma does

342
00:21:03,370 --> 00:21:06,070
not say anything about limbs

343
00:21:04,660 --> 00:21:08,230
representations it's just if you have

344
00:21:06,070 --> 00:21:10,899
anything that is a plus power of two

345
00:21:08,230 --> 00:21:13,780
times B you can reduce it this way and

346
00:21:10,900 --> 00:21:18,430
then the definition in the middle of the

347
00:21:13,780 --> 00:21:20,290
slide called reduce takes in the prime

348
00:21:18,430 --> 00:21:22,360
again in the representation where the

349
00:21:20,290 --> 00:21:23,740
power of 2 is known separately and the

350
00:21:22,360 --> 00:21:24,850
difference between the following power

351
00:21:23,740 --> 00:21:27,460
of two and the prime itself is

352
00:21:24,850 --> 00:21:29,260
represented as a limit difference so for

353
00:21:27,460 --> 00:21:32,500
curve two and nine that is 1 comma 19

354
00:21:29,260 --> 00:21:38,110
for P to have 6 that is each of the taps

355
00:21:32,500 --> 00:21:39,460
in a separate limb and then the actual

356
00:21:38,110 --> 00:21:41,350
input that is being produced towards

357
00:21:39,460 --> 00:21:43,600
called P is split into drew into the

358
00:21:41,350 --> 00:21:46,240
high half in the low half the split

359
00:21:43,600 --> 00:21:48,310
function inspects the weights of each

360
00:21:46,240 --> 00:21:50,800
limb and then put so weights that are

361
00:21:48,310 --> 00:21:52,899
bigger than do 3 155 or technically

362
00:21:50,800 --> 00:21:54,340
divisible by it go into the high half

363
00:21:52,900 --> 00:21:57,820
and the small weights going through low

364
00:21:54,340 --> 00:21:59,530
health and then the module

365
00:21:57,820 --> 00:22:01,540
multiplication trick proved incorrect in

366
00:21:59,530 --> 00:22:03,639
the first lemma is applied directly of

367
00:22:01,540 --> 00:22:08,010
course we call limb wise multiplication

368
00:22:03,640 --> 00:22:11,050
and limb wise addition to generate the

369
00:22:08,010 --> 00:22:14,920
expected multi limb production as for

370
00:22:11,050 --> 00:22:18,669
example seen for P 2 5 6 if you take

371
00:22:14,920 --> 00:22:21,660
this code and plug in s and C to make P

372
00:22:18,670 --> 00:22:23,650
2 5 6 you will actually generate the

373
00:22:21,660 --> 00:22:24,880
reduction algorithm shown in the NIST

374
00:22:23,650 --> 00:22:29,260
documentation that I had in slide number

375
00:22:24,880 --> 00:22:31,990
4 but perhaps more important than that

376
00:22:29,260 --> 00:22:33,220
for expediency of this

377
00:22:31,990 --> 00:22:35,800
limitations for energies that the proof

378
00:22:33,220 --> 00:22:37,809
or this entire reduction algorithm is

379
00:22:35,800 --> 00:22:39,520
again on the slide this time it is a

380
00:22:37,809 --> 00:22:42,280
long line I had to stretch the text box

381
00:22:39,520 --> 00:22:43,690
a little bit but it is still completely

382
00:22:42,280 --> 00:22:46,920
tractable and they only need to do this

383
00:22:43,690 --> 00:22:46,920
once when writing this implementation

384
00:22:47,520 --> 00:22:53,230
now of course that it actually

385
00:22:50,620 --> 00:22:54,610
specializes correctly it also it wasn't

386
00:22:53,230 --> 00:22:57,429
even obvious to us before we wrote this

387
00:22:54,610 --> 00:22:59,080
code but in hindsight everything is

388
00:22:57,429 --> 00:23:01,390
20/20 so let's take a look at what the

389
00:22:59,080 --> 00:23:04,360
specialization phase actually has to do

390
00:23:01,390 --> 00:23:05,620
and okay so there is this light that

391
00:23:04,360 --> 00:23:07,199
says we have more implementations of

392
00:23:05,620 --> 00:23:09,280
water strategies that I forgot about

393
00:23:07,200 --> 00:23:10,720
there's definitely saturates Elena's

394
00:23:09,280 --> 00:23:12,730
reduction that handles caries between

395
00:23:10,720 --> 00:23:14,559
different limbs and there is also a

396
00:23:12,730 --> 00:23:18,940
variant of burl reduction that was used

397
00:23:14,559 --> 00:23:20,920
in Google Thailand so what does the

398
00:23:18,940 --> 00:23:22,750
compiler do to turn this high-level

399
00:23:20,920 --> 00:23:25,480
functional code into C code as you would

400
00:23:22,750 --> 00:23:27,850
expect to find in crypto library first

401
00:23:25,480 --> 00:23:31,360
of all as I showed in the live demo the

402
00:23:27,850 --> 00:23:33,100
lists of limbs have known length so we

403
00:23:31,360 --> 00:23:35,409
asked for a 10 limitation or a 5

404
00:23:33,100 --> 00:23:36,939
limitation so it just expands the list

405
00:23:35,410 --> 00:23:39,700
and creates new variables for its

406
00:23:36,940 --> 00:23:42,130
elements then the loops that iterate

407
00:23:39,700 --> 00:23:43,780
over this list can be unrolled and this

408
00:23:42,130 --> 00:23:47,830
generates more intermediate variables

409
00:23:43,780 --> 00:23:49,240
say one for each partial product and of

410
00:23:47,830 --> 00:23:51,370
course once we have those variables we

411
00:23:49,240 --> 00:23:52,870
can optimize the definition of each one

412
00:23:51,370 --> 00:23:54,399
separately applying arithmetic

413
00:23:52,870 --> 00:23:56,199
optimizations such as replacing

414
00:23:54,400 --> 00:23:58,870
multiplications by powers of two with

415
00:23:56,200 --> 00:24:02,800
bit shifts and modulo with binary

416
00:23:58,870 --> 00:24:04,389
masking at this time these are all still

417
00:24:02,800 --> 00:24:07,570
mathematical integers no overflow is

418
00:24:04,390 --> 00:24:09,090
accounted for and in the proofs we have

419
00:24:07,570 --> 00:24:14,050
assumed that overflow does not happen

420
00:24:09,090 --> 00:24:16,300
however the inputs are assumed to be

421
00:24:14,050 --> 00:24:18,129
within some range so in that code

422
00:24:16,300 --> 00:24:21,159
generator we actually use a heuristic to

423
00:24:18,130 --> 00:24:23,470
pick a starting value and then trace the

424
00:24:21,160 --> 00:24:25,330
bounds of each intermediate variable

425
00:24:23,470 --> 00:24:27,790
through the code and check that the

426
00:24:25,330 --> 00:24:29,740
final outputs are within the smaller

427
00:24:27,790 --> 00:24:32,340
bounds to the input was assumed to be so

428
00:24:29,740 --> 00:24:35,080
it can be called on its own output and

429
00:24:32,340 --> 00:24:37,780
this precedes step by step and based on

430
00:24:35,080 --> 00:24:38,710
the infrared range --is fixed with

431
00:24:37,780 --> 00:24:40,960
integers are assigned to each

432
00:24:38,710 --> 00:24:42,790
intermediate variable this is the only

433
00:24:40,960 --> 00:24:44,860
step that is not standard standard

434
00:24:42,790 --> 00:24:45,879
partial evaluation so everything else

435
00:24:44,860 --> 00:24:49,240
you would just think of

436
00:24:45,880 --> 00:24:51,669
it is constant propagation but this one

437
00:24:49,240 --> 00:24:56,650
actually changes from mathematical

438
00:24:51,669 --> 00:24:58,330
integers to fixed size integers and the

439
00:24:56,650 --> 00:25:00,280
output bounds are also included as a

440
00:24:58,330 --> 00:25:01,689
part of the documentation in case a

441
00:25:00,280 --> 00:25:03,309
developer wants to use these field

442
00:25:01,690 --> 00:25:06,730
operations directly in a non proven

443
00:25:03,309 --> 00:25:09,690
environment and when we first started

444
00:25:06,730 --> 00:25:12,280
doing this we used Hawkes built-in

445
00:25:09,690 --> 00:25:13,990
call-by-value evaluation strategy with a

446
00:25:12,280 --> 00:25:15,940
blacklist of which operations not to

447
00:25:13,990 --> 00:25:17,890
unfold to perform partial evaluation and

448
00:25:15,940 --> 00:25:19,270
honestly it was really convenient you

449
00:25:17,890 --> 00:25:21,280
just write the list of things you don't

450
00:25:19,270 --> 00:25:23,620
want to unfold and it does it for you

451
00:25:21,280 --> 00:25:26,889
but it also had surprising asymptotic

452
00:25:23,620 --> 00:25:29,110
complexity in that when we first got

453
00:25:26,890 --> 00:25:31,900
Peter 5:6 working next morning I tried

454
00:25:29,110 --> 00:25:34,320
to synthesize p3 84 code and I waited a

455
00:25:31,900 --> 00:25:37,840
couple of hours and it still wasn't done

456
00:25:34,320 --> 00:25:39,760
but then Jason went and implemented a

457
00:25:37,840 --> 00:25:41,590
verified partial evaluator inside Kok

458
00:25:39,760 --> 00:25:43,600
so it is a functional program that takes

459
00:25:41,590 --> 00:25:46,240
in an order program and produces a third

460
00:25:43,600 --> 00:25:48,639
program and it's proven correct in the

461
00:25:46,240 --> 00:25:50,799
sense that all input programs are mapped

462
00:25:48,640 --> 00:25:52,840
to equivalent output programs and this

463
00:25:50,799 --> 00:25:55,240
proof links with the field operations

464
00:25:52,840 --> 00:25:57,370
proofs for the high-level language so

465
00:25:55,240 --> 00:25:58,780
the top-level theorem we were proving

466
00:25:57,370 --> 00:26:00,309
did not change even though we switch to

467
00:25:58,780 --> 00:26:06,190
a totally different specialization

468
00:26:00,309 --> 00:26:07,658
strategy so you know that's I would say

469
00:26:06,190 --> 00:26:09,850
a is both the biggest downside and

470
00:26:07,659 --> 00:26:13,090
biggest upside of you can do this

471
00:26:09,850 --> 00:26:14,379
but you need to do this sometimes so

472
00:26:13,090 --> 00:26:15,250
enough complaining about performance

473
00:26:14,380 --> 00:26:17,049
let's say some good things about

474
00:26:15,250 --> 00:26:18,970
performance compilation is really slow

475
00:26:17,049 --> 00:26:22,539
but the compiled code is really quite

476
00:26:18,970 --> 00:26:25,720
fast for curve 209 the code that we

477
00:26:22,539 --> 00:26:27,100
produce is roughly on par with the

478
00:26:25,720 --> 00:26:28,480
fastest C code we know it depends

479
00:26:27,100 --> 00:26:30,100
exactly on which micro architecture you

480
00:26:28,480 --> 00:26:31,480
benchmark it and my laptop is always

481
00:26:30,100 --> 00:26:32,590
faster but other people tell me that

482
00:26:31,480 --> 00:26:38,200
they have something something something

483
00:26:32,590 --> 00:26:40,260
else be faster and for P to f6 it is the

484
00:26:38,200 --> 00:26:43,059
fastest C code but the assembler code is

485
00:26:40,260 --> 00:26:44,620
significantly ahead this is because of

486
00:26:43,059 --> 00:26:48,760
their carry flag optimizations I

487
00:26:44,620 --> 00:26:50,469
mentioned earlier and we also scraped

488
00:26:48,760 --> 00:26:52,600
curves at modern crypt of the rorg for

489
00:26:50,470 --> 00:26:55,330
prime numbers and transport all of them

490
00:26:52,600 --> 00:26:56,709
and for most of them we couldn't find

491
00:26:55,330 --> 00:26:58,540
expert implementations because nobody

492
00:26:56,710 --> 00:26:59,680
had put in the effort to write them but

493
00:26:58,540 --> 00:27:02,020
we're at least much faster

494
00:26:59,680 --> 00:27:06,750
g/b so that's good GFP is the key normal

495
00:27:02,020 --> 00:27:09,010
to precision library but of course we

496
00:27:06,750 --> 00:27:11,230
had to integrate this code into a real

497
00:27:09,010 --> 00:27:12,879
library and the code reviewers smirked

498
00:27:11,230 --> 00:27:15,850
at us and looked at us another time and

499
00:27:12,880 --> 00:27:17,470
in the end the pain points ended up

500
00:27:15,850 --> 00:27:19,300
being that nobody wants to depend on

501
00:27:17,470 --> 00:27:22,390
caulk to build the crypt library so we

502
00:27:19,300 --> 00:27:24,790
had to check in generate code generate

503
00:27:22,390 --> 00:27:25,390
code has gibberish variable names x1 x2

504
00:27:24,790 --> 00:27:27,399
and so on

505
00:27:25,390 --> 00:27:29,680
it also has no comments and no

506
00:27:27,400 --> 00:27:31,930
suggestive whitespace but and then our

507
00:27:29,680 --> 00:27:33,730
code was judged against the quality of

508
00:27:31,930 --> 00:27:35,290
the code 3 was replacing which also had

509
00:27:33,730 --> 00:27:36,760
the low comments and those suggested

510
00:27:35,290 --> 00:27:39,310
white space that gibberish variable

511
00:27:36,760 --> 00:27:40,810
names so it was generally seen as an

512
00:27:39,310 --> 00:27:42,040
improvement perhaps because of the

513
00:27:40,810 --> 00:27:43,810
little difference that we have

514
00:27:42,040 --> 00:27:45,690
high-level specifications that are

515
00:27:43,810 --> 00:27:47,980
proven to be cool into the code so you

516
00:27:45,690 --> 00:27:51,030
are relatively justified in just

517
00:27:47,980 --> 00:27:54,520
skipping reading the code altogether and

518
00:27:51,030 --> 00:27:55,960
then we actually well I when I was

519
00:27:54,520 --> 00:27:57,910
working as an intern at Google boring as

520
00:27:55,960 --> 00:28:00,190
hell and then refactor to all the colors

521
00:27:57,910 --> 00:28:01,900
of the critic of the cart 1:9 library to

522
00:28:00,190 --> 00:28:03,790
use different types for fill the lemons

523
00:28:01,900 --> 00:28:05,290
throwing different bounds and this also

524
00:28:03,790 --> 00:28:07,480
turned out relatively well because then

525
00:28:05,290 --> 00:28:09,760
I would just document that the

526
00:28:07,480 --> 00:28:11,800
definition of that dumb is struct of

527
00:28:09,760 --> 00:28:16,629
what bounds are assumed to be known of

528
00:28:11,800 --> 00:28:17,830
its of its limbs and in some cases we

529
00:28:16,630 --> 00:28:20,230
even went the other way around the

530
00:28:17,830 --> 00:28:26,199
prescribed the alter finite field

531
00:28:20,230 --> 00:28:29,170
implementation into caulk to prove it

532
00:28:26,200 --> 00:28:31,170
correct as a entire unit instead of

533
00:28:29,170 --> 00:28:34,180
verifying your visual field operations

534
00:28:31,170 --> 00:28:37,360
but of course this could continue that

535
00:28:34,180 --> 00:28:38,740
infinitum and perhaps I want to do

536
00:28:37,360 --> 00:28:40,240
something else for the next couple of

537
00:28:38,740 --> 00:28:42,370
years so here some things I would like

538
00:28:40,240 --> 00:28:44,680
to see happen but I'm probably not going

539
00:28:42,370 --> 00:28:46,270
to work on first of all their

540
00:28:44,680 --> 00:28:48,430
performance issues will hit uncock we

541
00:28:46,270 --> 00:28:49,780
believe are almost entirely spurious

542
00:28:48,430 --> 00:28:50,710
there is no fundamental reason gawked

543
00:28:49,780 --> 00:28:52,180
would have to be slow

544
00:28:50,710 --> 00:28:53,800
it is simply software written by

545
00:28:52,180 --> 00:28:55,180
mathematicians and it does very good

546
00:28:53,800 --> 00:28:57,030
mathematics so we should be happy for

547
00:28:55,180 --> 00:28:59,830
that

548
00:28:57,030 --> 00:29:02,200
similarly the open source C compilers

549
00:28:59,830 --> 00:29:03,909
could do much better on allocating carry

550
00:29:02,200 --> 00:29:06,490
flags ICC is slightly better already

551
00:29:03,910 --> 00:29:09,100
there will be a great improvement and of

552
00:29:06,490 --> 00:29:11,380
course proved more stuff but all of this

553
00:29:09,100 --> 00:29:12,939
is not really exciting in an academic

554
00:29:11,380 --> 00:29:13,420
context and perhaps if the real world

555
00:29:12,940 --> 00:29:15,400
wants

556
00:29:13,420 --> 00:29:18,910
that real-world should find the

557
00:29:15,400 --> 00:29:21,340
resources to actually get it done I'm

558
00:29:18,910 --> 00:29:24,960
happy to hear questions

559
00:29:21,340 --> 00:29:24,959
[Music]

560
00:29:27,320 --> 00:29:31,649
so it's probably never a good idea to

561
00:29:29,580 --> 00:29:34,770
admit that academia is not the real

562
00:29:31,650 --> 00:29:39,180
world but we have time for questions or

563
00:29:34,770 --> 00:29:41,370
comments just come to the mics what's in

564
00:29:39,180 --> 00:29:43,470
you ask questions so I have a question

565
00:29:41,370 --> 00:29:46,620
about the reliance on Grabner basis

566
00:29:43,470 --> 00:29:49,590
algorithms is there a certificate

567
00:29:46,620 --> 00:29:52,530
generated in Cocke that the ideal

568
00:29:49,590 --> 00:29:54,149
membership is in fact correct or are you

569
00:29:52,530 --> 00:29:56,550
relying entirely on the correctness of

570
00:29:54,150 --> 00:29:57,990
the gerbner basis algorithm this the

571
00:29:56,550 --> 00:29:59,399
standard Kok proof checker there is no

572
00:29:57,990 --> 00:30:01,410
correct reliance and correctness of the

573
00:29:59,400 --> 00:30:04,170
algorithm the way it actually works is

574
00:30:01,410 --> 00:30:07,500
that the creditor varices algorithm

575
00:30:04,170 --> 00:30:09,630
produces polynomials by which to

576
00:30:07,500 --> 00:30:13,020
multiply the Givens to produce about

577
00:30:09,630 --> 00:30:19,620
power of the goal and thus certified

578
00:30:13,020 --> 00:30:22,350
that it is zero hello you mentioned

579
00:30:19,620 --> 00:30:24,810
about comparison against to GMP have you

580
00:30:22,350 --> 00:30:27,360
done a similar comparison against be an

581
00:30:24,810 --> 00:30:32,970
open ourselves big number and how does

582
00:30:27,360 --> 00:30:36,389
it we did not thank you hi thanks for

583
00:30:32,970 --> 00:30:38,040
you talk do you have any idea of the men

584
00:30:36,390 --> 00:30:41,790
hours that you spend in verifying that

585
00:30:38,040 --> 00:30:43,830
and many lines of work do you have oh it

586
00:30:41,790 --> 00:30:47,220
was a lot of man-hours but a lot of it

587
00:30:43,830 --> 00:30:49,409
went into figuring out how to how to

588
00:30:47,220 --> 00:30:52,560
structure this entire project and in the

589
00:30:49,410 --> 00:30:54,770
end the high-level algorithms are really

590
00:30:52,560 --> 00:30:59,220
as simple as I showed in these slides

591
00:30:54,770 --> 00:31:01,550
the compiler is rather complicated has I

592
00:30:59,220 --> 00:31:03,690
think more than 10,000 lines of code now

593
00:31:01,550 --> 00:31:05,129
in addition to standard library

594
00:31:03,690 --> 00:31:08,390
extensions that MIT maintains for all

595
00:31:05,130 --> 00:31:11,160
his projects all of his talk projects so

596
00:31:08,390 --> 00:31:13,230
there is quite a bit of fixed cost to

597
00:31:11,160 --> 00:31:16,410
build the infrastructure and coq itself

598
00:31:13,230 --> 00:31:18,510
is a many decades in making project but

599
00:31:16,410 --> 00:31:20,640
adding a new implementation strategy is

600
00:31:18,510 --> 00:31:22,440
very easy and using an implementation

601
00:31:20,640 --> 00:31:24,570
strategy for a new prime is really easy

602
00:31:22,440 --> 00:31:28,590
as I just showed you the demo so that's

603
00:31:24,570 --> 00:31:30,030
the cost model okay thank you yeah

604
00:31:28,590 --> 00:31:32,159
thanks for the talk this is really cool

605
00:31:30,030 --> 00:31:34,920
I'm curious so when you're writing

606
00:31:32,160 --> 00:31:36,750
handwritten code for crypto operations

607
00:31:34,920 --> 00:31:37,530
and C you pay a lot of attention to say

608
00:31:36,750 --> 00:31:39,690
timing issues

609
00:31:37,530 --> 00:31:41,310
I'm curious did you sort of inspect the

610
00:31:39,690 --> 00:31:42,960
generated code to check for these or how

611
00:31:41,310 --> 00:31:45,240
did you think about about things like

612
00:31:42,960 --> 00:31:46,860
timing attacks and cache attacks so the

613
00:31:45,240 --> 00:31:49,530
low-level target language that is used

614
00:31:46,860 --> 00:31:51,209
for our code only includes operations

615
00:31:49,530 --> 00:31:52,980
that are believed to be implemented in

616
00:31:51,210 --> 00:31:54,240
constant time and common processors so

617
00:31:52,980 --> 00:32:02,400
for example there is no division in

618
00:31:54,240 --> 00:32:03,540
there in the language okay let's thank

619
00:32:02,400 --> 00:32:06,700
the speaker again and we'll move on with

620
00:32:03,540 --> 00:32:10,069
the next talk thank you very much

621
00:32:06,700 --> 00:32:10,069
[Music]

622
00:32:37,530 --> 00:32:43,680
mr. e okay great so next up we have a

623
00:32:41,790 --> 00:32:45,360
talk entitled verified vectorized

624
00:32:43,680 --> 00:32:47,640
cryptography and the talk will be given

625
00:32:45,360 --> 00:32:50,310
by Karthik bhagavaan Thank You Karthik

626
00:32:47,640 --> 00:32:51,990
thanks Kay all right so this is work

627
00:32:50,310 --> 00:32:53,190
with a bunch of people that you can see

628
00:32:51,990 --> 00:32:55,290
there but it's also part of a larger

629
00:32:53,190 --> 00:32:56,940
project which involves in Rio Microsoft

630
00:32:55,290 --> 00:32:58,639
Research CMU is called project

631
00:32:56,940 --> 00:33:01,500
expedition I include you to check it out

632
00:32:58,640 --> 00:33:03,600
so like the previous talk the focus here

633
00:33:01,500 --> 00:33:05,820
is how do we build high assurance crypto

634
00:33:03,600 --> 00:33:07,080
software like we all know writing crypto

635
00:33:05,820 --> 00:33:10,169
code is hard if you go look at the

636
00:33:07,080 --> 00:33:11,550
vulnerabilities page of OpenSSL just as

637
00:33:10,170 --> 00:33:12,960
here you will find multiple buffer

638
00:33:11,550 --> 00:33:15,030
overflows you will find many

639
00:33:12,960 --> 00:33:16,440
side-channel attacks occasionally you

640
00:33:15,030 --> 00:33:17,639
will find arithmetic bugs and filled

641
00:33:16,440 --> 00:33:21,330
asthmatic bugs like the ones we saw

642
00:33:17,640 --> 00:33:22,470
there so this is a problem and not not

643
00:33:21,330 --> 00:33:24,060
only that all of these have a

644
00:33:22,470 --> 00:33:26,550
commonality which is that these are kind

645
00:33:24,060 --> 00:33:28,200
of low probability bugs as and they were

646
00:33:26,550 --> 00:33:29,520
not going to be found by testing but if

647
00:33:28,200 --> 00:33:32,610
you know they exist they might be

648
00:33:29,520 --> 00:33:34,800
possible to exploit so like Andrew said

649
00:33:32,610 --> 00:33:36,149
we also kind of promote the idea of

650
00:33:34,800 --> 00:33:38,250
using formal verification as a

651
00:33:36,150 --> 00:33:40,950
principled approach to systematically

652
00:33:38,250 --> 00:33:42,600
eliminate lots large classes of bugs and

653
00:33:40,950 --> 00:33:44,820
there are many tools and we use the tool

654
00:33:42,600 --> 00:33:47,310
called I've started with this but

655
00:33:44,820 --> 00:33:49,770
verification in my experience for these

656
00:33:47,310 --> 00:33:51,929
kinds of things often is a significant

657
00:33:49,770 --> 00:33:54,180
effort so you mean like the question was

658
00:33:51,930 --> 00:33:55,530
the sauce it can be a PhD burning

659
00:33:54,180 --> 00:33:57,060
effective so like I'll call it you can

660
00:33:55,530 --> 00:33:58,200
take a PhD student send them off for two

661
00:33:57,060 --> 00:34:00,300
years and they'll come back with either

662
00:33:58,200 --> 00:34:02,400
an amazing tool for a finite field

663
00:34:00,300 --> 00:34:04,110
arithmetic or a proof for a few

664
00:34:02,400 --> 00:34:06,210
primitives and that's great if you only

665
00:34:04,110 --> 00:34:07,530
want to verify these this library once

666
00:34:06,210 --> 00:34:09,139
and for all and for a lot of things

667
00:34:07,530 --> 00:34:11,009
maybe you never want to change the code

668
00:34:09,139 --> 00:34:12,870
unfortunately modern libraries are not

669
00:34:11,010 --> 00:34:14,820
like this we have large full-scale

670
00:34:12,870 --> 00:34:16,710
libraries with multiple primitives and

671
00:34:14,820 --> 00:34:19,409
multiple implementations in assembly for

672
00:34:16,710 --> 00:34:20,879
each primitive and so on and so we want

673
00:34:19,409 --> 00:34:21,960
to figure out on how we can scale up

674
00:34:20,879 --> 00:34:24,089
this kind of techniques that we are

675
00:34:21,960 --> 00:34:27,629
talking about to work for real-world

676
00:34:24,090 --> 00:34:29,159
large modern libraries hint we don't

677
00:34:27,629 --> 00:34:32,069
want these libraries to be so large

678
00:34:29,159 --> 00:34:33,270
okay so that'll help us but let's color

679
00:34:32,070 --> 00:34:34,710
sell them the problem a little bit if

680
00:34:33,270 --> 00:34:35,909
you wanted to write verified crypto code

681
00:34:34,710 --> 00:34:37,560
what do you have end up doing so of

682
00:34:35,909 --> 00:34:39,570
course you start from the RFC so this is

683
00:34:37,560 --> 00:34:41,909
the I charge at many Poli one three or

684
00:34:39,570 --> 00:34:44,010
five RFC which has been extensively

685
00:34:41,909 --> 00:34:45,030
implemented over the last three yes but

686
00:34:44,010 --> 00:34:46,260
of course you can't just start from

687
00:34:45,030 --> 00:34:47,550
there you have to extract some pseudo

688
00:34:46,260 --> 00:34:49,740
code and if you're lucky the RFC

689
00:34:47,550 --> 00:34:51,419
actually has to record in it in a pipe

690
00:34:49,739 --> 00:34:53,158
like syntax or something so you don't

691
00:34:51,418 --> 00:34:54,509
have to make that effort for some nist

692
00:34:53,159 --> 00:34:56,790
RFC's you have to make a big effort to

693
00:34:54,510 --> 00:34:58,470
actually even extract the pseudocode so

694
00:34:56,790 --> 00:34:59,759
once you have that okay a programmer who

695
00:34:58,470 --> 00:35:01,560
can look at the pseudocode and write

696
00:34:59,760 --> 00:35:03,450
code in their favorite language probably

697
00:35:01,560 --> 00:35:05,369
see in this case and then they had some

698
00:35:03,450 --> 00:35:07,020
details like how do I look memory where

699
00:35:05,369 --> 00:35:09,000
you free in the memory maybe have a

700
00:35:07,020 --> 00:35:10,680
special kind of API like an incremental

701
00:35:09,000 --> 00:35:12,780
API you want to present which was not

702
00:35:10,680 --> 00:35:14,549
there in the original out of C and so on

703
00:35:12,780 --> 00:35:16,350
so there's some bit more work there but

704
00:35:14,550 --> 00:35:17,820
in the end for chacha 20 you can write

705
00:35:16,350 --> 00:35:20,460
the whole implementation a couple of

706
00:35:17,820 --> 00:35:22,830
hundred lines of code of course you

707
00:35:20,460 --> 00:35:24,750
might think well this is so small it's

708
00:35:22,830 --> 00:35:26,430
obviously correct right but it's there

709
00:35:24,750 --> 00:35:27,840
are still some issues you've started

710
00:35:26,430 --> 00:35:30,118
using memory so you might want to make

711
00:35:27,840 --> 00:35:31,380
sure that the code is memory safe you

712
00:35:30,119 --> 00:35:32,670
might have some timing leaks like was

713
00:35:31,380 --> 00:35:34,680
asked before so you might want to make

714
00:35:32,670 --> 00:35:36,750
sure for example any naive

715
00:35:34,680 --> 00:35:38,339
implementation of AES will have a timing

716
00:35:36,750 --> 00:35:39,240
leak is that the case here is well you

717
00:35:38,340 --> 00:35:40,550
might want to ask these kinds of

718
00:35:39,240 --> 00:35:42,540
questions

719
00:35:40,550 --> 00:35:44,490
poly one three or five slightly

720
00:35:42,540 --> 00:35:46,110
different and as we saw before the main

721
00:35:44,490 --> 00:35:48,479
thing there is although it's a beautiful

722
00:35:46,110 --> 00:35:51,030
mathematical spec polynomial evaluation

723
00:35:48,480 --> 00:35:52,680
over field elements what it relies on in

724
00:35:51,030 --> 00:35:54,750
the in the heart of it is finite field

725
00:35:52,680 --> 00:35:56,250
arithmetic and so when you try to

726
00:35:54,750 --> 00:35:58,020
implement this the code is actually

727
00:35:56,250 --> 00:36:00,359
significantly larger so if you wrote it

728
00:35:58,020 --> 00:36:01,890
by hand it would be about 500 lines

729
00:36:00,359 --> 00:36:03,930
where each number is broken into five

730
00:36:01,890 --> 00:36:05,160
you and thirty twos and so on and you it

731
00:36:03,930 --> 00:36:07,020
gets a bit more complex and you're

732
00:36:05,160 --> 00:36:08,700
worried about carry propagation bugs and

733
00:36:07,020 --> 00:36:11,400
these kinds of things as well so that's

734
00:36:08,700 --> 00:36:12,868
the setting in which we are and so if

735
00:36:11,400 --> 00:36:14,730
you wanted to verify the kind of code

736
00:36:12,869 --> 00:36:17,280
that you are writing here which is C

737
00:36:14,730 --> 00:36:19,170
code and so on the first step you have

738
00:36:17,280 --> 00:36:20,490
to do is you have to write a formal spec

739
00:36:19,170 --> 00:36:21,980
so the pseudo code is still not enough

740
00:36:20,490 --> 00:36:24,750
you still have to read that formal spec

741
00:36:21,980 --> 00:36:26,310
perhaps in coq perhaps an F star perhaps

742
00:36:24,750 --> 00:36:28,410
encrypt all but somebody has to do this

743
00:36:26,310 --> 00:36:30,779
okay and once you have that then we can

744
00:36:28,410 --> 00:36:32,759
put the might of our verification tools

745
00:36:30,780 --> 00:36:34,080
behind it and prove that the C code you

746
00:36:32,760 --> 00:36:36,510
have at the border matches the formal

747
00:36:34,080 --> 00:36:37,950
spec now note that really in an ideal

748
00:36:36,510 --> 00:36:39,540
world you don't just want to verify one

749
00:36:37,950 --> 00:36:41,549
small component of it like just if you

750
00:36:39,540 --> 00:36:43,320
let it medic or something you want to

751
00:36:41,550 --> 00:36:45,119
actually extend it all the way up to the

752
00:36:43,320 --> 00:36:47,609
full primitive because you don't want

753
00:36:45,119 --> 00:36:49,619
bugs in the polynomial evaluation or in

754
00:36:47,609 --> 00:36:51,090
the CTR mode or anywhere else and you

755
00:36:49,619 --> 00:36:53,880
want to verify for side-channel

756
00:36:51,090 --> 00:36:55,590
resistance well it's what a constant

757
00:36:53,880 --> 00:36:57,420
time coding sort of so-to-speak tired

758
00:36:55,590 --> 00:36:59,070
timing sectional resistance as well as

759
00:36:57,420 --> 00:37:00,869
memory safety and functional greatness

760
00:36:59,070 --> 00:37:02,400
and there's a bunch of tools that will

761
00:37:00,869 --> 00:37:02,970
do this for you our methodology for

762
00:37:02,400 --> 00:37:06,119
doing this

763
00:37:02,970 --> 00:37:07,379
in this is F star and we have a built a

764
00:37:06,119 --> 00:37:09,030
library called hackles job which we

765
00:37:07,380 --> 00:37:11,550
talked about last year here at your

766
00:37:09,030 --> 00:37:13,650
world crypto it's it implements a bunch

767
00:37:11,550 --> 00:37:15,810
of primitives and verifies every single

768
00:37:13,650 --> 00:37:17,280
aspect of them for all the properties we

769
00:37:15,810 --> 00:37:20,220
mentioned here you can go check it out

770
00:37:17,280 --> 00:37:24,390
of that URL so once you have verified

771
00:37:20,220 --> 00:37:27,509
this code you can compile it to a

772
00:37:24,390 --> 00:37:30,509
portable C code standalone code whose

773
00:37:27,510 --> 00:37:32,670
performance is we are comparable to an

774
00:37:30,510 --> 00:37:34,200
often better than handwritten C code so

775
00:37:32,670 --> 00:37:35,970
there's no reason to write handwritten C

776
00:37:34,200 --> 00:37:37,230
code anymore with fiat crypto like we

777
00:37:35,970 --> 00:37:39,240
saw the previous talk and with this one

778
00:37:37,230 --> 00:37:41,640
you can actually write code which is

779
00:37:39,240 --> 00:37:43,290
fast and also verified and this one is

780
00:37:41,640 --> 00:37:46,200
used in Mozilla Firefox and other such

781
00:37:43,290 --> 00:37:48,750
things but let's try to understand how

782
00:37:46,200 --> 00:37:52,020
much effort was involved to the effort

783
00:37:48,750 --> 00:37:54,030
question so in the Charter 20 code on

784
00:37:52,020 --> 00:37:55,770
the Pollione 3 or 5 code for for heckled

785
00:37:54,030 --> 00:37:57,569
star just looking at those ones the

786
00:37:55,770 --> 00:37:59,310
high-level spec was like less than 100

787
00:37:57,569 --> 00:38:01,619
lines ok it's very very very simple and

788
00:37:59,310 --> 00:38:02,970
nice but the verified code we write is

789
00:38:01,619 --> 00:38:04,859
actually significantly larger for

790
00:38:02,970 --> 00:38:07,140
char-char 20 and symmetric primitives

791
00:38:04,859 --> 00:38:08,910
like this typically if you have to

792
00:38:07,140 --> 00:38:12,569
produce if you want to verify let's say

793
00:38:08,910 --> 00:38:16,379
a 300 line C program you will end up

794
00:38:12,569 --> 00:38:18,270
writing maybe 400 500 lines of of

795
00:38:16,380 --> 00:38:20,130
annotations for the memory safety for

796
00:38:18,270 --> 00:38:22,079
first for functional correctness and so

797
00:38:20,130 --> 00:38:24,690
on and not all of it is interesting most

798
00:38:22,079 --> 00:38:26,369
of it is probably boring for Poli 1/3

799
00:38:24,690 --> 00:38:28,920
off I also doing field arithmetic proofs

800
00:38:26,369 --> 00:38:30,690
so the you might be writing 7 times as

801
00:38:28,920 --> 00:38:32,280
many proof annotations so it's still

802
00:38:30,690 --> 00:38:34,319
significant but if you only wanted to

803
00:38:32,280 --> 00:38:36,300
verify the reference implementation of

804
00:38:34,319 --> 00:38:38,790
these algorithms once and for all

805
00:38:36,300 --> 00:38:40,500
maybe this is a a worthy effort and you

806
00:38:38,790 --> 00:38:42,329
can you can do this and of course as we

807
00:38:40,500 --> 00:38:44,220
learn more and more about these tools we

808
00:38:42,329 --> 00:38:45,540
can use tools like the one percenter in

809
00:38:44,220 --> 00:38:47,209
the previous talk to make this effort

810
00:38:45,540 --> 00:38:50,400
less and less right

811
00:38:47,210 --> 00:38:52,200
the problem is verifying that C

812
00:38:50,400 --> 00:38:54,240
implementation isn't enough because in

813
00:38:52,200 --> 00:38:57,540
fact even though we delivered our

814
00:38:54,240 --> 00:38:59,250
beautiful C code to Firefox that code is

815
00:38:57,540 --> 00:39:01,770
actually never used in practice because

816
00:38:59,250 --> 00:39:04,050
every single library has a bunch of

817
00:39:01,770 --> 00:39:05,880
other assembly implementations optimized

818
00:39:04,050 --> 00:39:06,750
for each different platform and those

819
00:39:05,880 --> 00:39:08,400
are the ones that are going to be

820
00:39:06,750 --> 00:39:09,810
selected at runtime not the nice

821
00:39:08,400 --> 00:39:12,420
reference implementation that we

822
00:39:09,810 --> 00:39:13,920
verified and for good reason on a modern

823
00:39:12,420 --> 00:39:16,589
laptop like the ones you have it's

824
00:39:13,920 --> 00:39:19,170
probably gonna get a 4x improvement

825
00:39:16,589 --> 00:39:21,599
thanks improvement and speed between the

826
00:39:19,170 --> 00:39:23,549
C code and the assembly code for certain

827
00:39:21,599 --> 00:39:25,049
primitives not for curve 2 for 509 that

828
00:39:23,549 --> 00:39:27,449
is one where actually you don't get so

829
00:39:25,049 --> 00:39:29,339
much improvement but for poly and ChaCha

830
00:39:27,449 --> 00:39:31,739
definitely so why would anybody use that

831
00:39:29,339 --> 00:39:34,380
C curve so if you go look at the OpenSSL

832
00:39:31,739 --> 00:39:36,509
code in fact there is like 8 9 10

833
00:39:34,380 --> 00:39:38,670
assembly implementations of each critic

834
00:39:36,509 --> 00:39:41,099
and each of them is a thousand lines or

835
00:39:38,670 --> 00:39:42,869
more okay so now you are in a nice world

836
00:39:41,099 --> 00:39:44,160
where you have to verify 500 lines and

837
00:39:42,869 --> 00:39:46,289
now here in the world we get to verify

838
00:39:44,160 --> 00:39:47,098
10,000 lines let me just tell you this

839
00:39:46,289 --> 00:39:51,449
isn't happening

840
00:39:47,099 --> 00:39:53,039
ok so this is not happening so it's

841
00:39:51,449 --> 00:39:54,269
probably also awful for the people who

842
00:39:53,039 --> 00:39:55,650
have to maintain this stuff because the

843
00:39:54,269 --> 00:39:57,689
more code you have more things can go

844
00:39:55,650 --> 00:39:59,759
wrong more fiddly bits I don't know how

845
00:39:57,689 --> 00:40:01,288
they do it but there is way too much

846
00:39:59,759 --> 00:40:03,119
code even in boring SSL there would be

847
00:40:01,289 --> 00:40:05,039
five implementations of charger 20 and

848
00:40:03,119 --> 00:40:06,869
assembly and I think at least four and

849
00:40:05,039 --> 00:40:08,789
four Palio and three or five as well and

850
00:40:06,869 --> 00:40:10,920
the main reason they're there is because

851
00:40:08,789 --> 00:40:12,930
of vectorization each of these ones is

852
00:40:10,920 --> 00:40:17,719
doing specialized vectorization for

853
00:40:12,930 --> 00:40:19,799
armed neon for AVX avx2 sse3 and whatnot

854
00:40:17,719 --> 00:40:21,839
so this is a hard target for

855
00:40:19,799 --> 00:40:23,249
verification how do we scale up a

856
00:40:21,839 --> 00:40:24,359
verification to deal with all of them I

857
00:40:23,249 --> 00:40:26,640
don't want to verify each of them

858
00:40:24,359 --> 00:40:28,979
individually so the key idea that we are

859
00:40:26,640 --> 00:40:31,109
promoting in this talk is that we don't

860
00:40:28,979 --> 00:40:32,910
want you to write individuals separate

861
00:40:31,109 --> 00:40:34,799
completely independent implementations

862
00:40:32,910 --> 00:40:37,410
for each platform we want to rather

863
00:40:34,799 --> 00:40:38,788
identify the parallel algorithm we are

864
00:40:37,410 --> 00:40:40,499
trying to implement and the

865
00:40:38,789 --> 00:40:42,689
optimizations they're in and write a

866
00:40:40,499 --> 00:40:44,549
generic simle implementation that we can

867
00:40:42,689 --> 00:40:46,109
verify and from which we can compile

868
00:40:44,549 --> 00:40:48,749
down to individuals in the

869
00:40:46,109 --> 00:40:50,429
implementations for each pattern okay so

870
00:40:48,749 --> 00:40:52,229
in this way maybe the performance might

871
00:40:50,429 --> 00:40:53,670
be slightly less but at least you get a

872
00:40:52,229 --> 00:40:56,069
baseline performance from which you can

873
00:40:53,670 --> 00:40:57,179
optimize as I will show you the

874
00:40:56,069 --> 00:41:01,739
performance you get is actually pretty

875
00:40:57,179 --> 00:41:03,420
good so the architecture I'm going to be

876
00:41:01,739 --> 00:41:04,679
going to follow in this talk is the

877
00:41:03,420 --> 00:41:05,910
following so it's a bit of a hairy

878
00:41:04,679 --> 00:41:08,459
picture so I'm going to introduce it

879
00:41:05,910 --> 00:41:10,078
step by step we start off from a spec

880
00:41:08,459 --> 00:41:11,788
for the crypto algorithm we're gonna

881
00:41:10,079 --> 00:41:13,140
trip gonna do and there's going to be

882
00:41:11,789 --> 00:41:14,429
written a domain-specific language

883
00:41:13,140 --> 00:41:15,929
called hack spectral describe in a

884
00:41:14,429 --> 00:41:17,819
minute from that we're going to compile

885
00:41:15,929 --> 00:41:20,390
down to a formal specification in a

886
00:41:17,819 --> 00:41:22,709
store then you're going to write a

887
00:41:20,390 --> 00:41:24,179
vectorized algorithm a completely

888
00:41:22,709 --> 00:41:26,428
generic vectorized algorithm that

889
00:41:24,179 --> 00:41:28,469
doesn't care about how many how big your

890
00:41:26,429 --> 00:41:29,000
vectors are what specific platform

891
00:41:28,469 --> 00:41:30,680
you're on

892
00:41:29,000 --> 00:41:32,270
but it's basically a parallel algorithm

893
00:41:30,680 --> 00:41:34,759
that implements the same primitive and

894
00:41:32,270 --> 00:41:37,160
will prove that this is doing the same

895
00:41:34,760 --> 00:41:39,369
operation as the high-level spec okay so

896
00:41:37,160 --> 00:41:42,348
this is a pure specter spec

897
00:41:39,369 --> 00:41:43,910
transformation then we will write a

898
00:41:42,349 --> 00:41:46,250
vectorizing stateful vectorized

899
00:41:43,910 --> 00:41:47,118
implementation of this and all of this

900
00:41:46,250 --> 00:41:49,849
have going to be written in a language

901
00:41:47,119 --> 00:41:51,200
call F star and they're going to prove

902
00:41:49,849 --> 00:41:53,900
that the implementation matches the

903
00:41:51,200 --> 00:41:55,009
vectorized algorithm and in addition of

904
00:41:53,900 --> 00:41:57,109
course that the implementation doesn't

905
00:41:55,010 --> 00:41:58,670
have memory safety bugs or side channel

906
00:41:57,109 --> 00:42:00,049
problems and so on we'll do a bunch of

907
00:41:58,670 --> 00:42:01,730
verification of the implementation level

908
00:42:00,050 --> 00:42:03,950
but those things on the right I've been

909
00:42:01,730 --> 00:42:05,359
mostly automated over the over time and

910
00:42:03,950 --> 00:42:06,710
we've kind of got a very good

911
00:42:05,359 --> 00:42:09,470
understanding of how to do this almost

912
00:42:06,710 --> 00:42:10,730
without any new annotations and once

913
00:42:09,470 --> 00:42:12,799
you've verified everything we can just

914
00:42:10,730 --> 00:42:14,150
compile it down and the spawn special

915
00:42:12,800 --> 00:42:16,250
case of the vectorized code is going to

916
00:42:14,150 --> 00:42:18,470
be the scalar code which can be used on

917
00:42:16,250 --> 00:42:19,880
any machine and then they're going to be

918
00:42:18,470 --> 00:42:22,669
if you want you can generate code for

919
00:42:19,880 --> 00:42:24,950
128 bit for 256 bit firing 12 bit one

920
00:42:22,670 --> 00:42:26,300
from the same source code with no with

921
00:42:24,950 --> 00:42:27,710
no difference okay because it's been

922
00:42:26,300 --> 00:42:30,619
verified once and for all for all these

923
00:42:27,710 --> 00:42:35,060
widths so let's see how this goes

924
00:42:30,619 --> 00:42:37,190
through for one example okay okay and

925
00:42:35,060 --> 00:42:38,750
before I do that the whole point of this

926
00:42:37,190 --> 00:42:40,310
architecture is that at the end of it

927
00:42:38,750 --> 00:42:42,020
you get really optimized code on the

928
00:42:40,310 --> 00:42:43,970
bottom right which has been proved

929
00:42:42,020 --> 00:42:47,480
correct with respect to this very simple

930
00:42:43,970 --> 00:42:49,310
spec on the top left okay most of the

931
00:42:47,480 --> 00:42:51,710
steps here have been automated except

932
00:42:49,310 --> 00:42:53,359
for the big part here which is on the

933
00:42:51,710 --> 00:42:55,730
bottom left which is the proof that the

934
00:42:53,359 --> 00:42:57,020
vectorize algorithm generic vectorizer

935
00:42:55,730 --> 00:42:58,700
algorithm it just meets the high-level

936
00:42:57,020 --> 00:43:00,320
spec and that's where most of your

937
00:42:58,700 --> 00:43:01,669
manual effort is going to be but this is

938
00:43:00,320 --> 00:43:03,470
good because this is the interesting

939
00:43:01,670 --> 00:43:05,119
part of the proof and this is where we

940
00:43:03,470 --> 00:43:07,009
want to spend our manual effort if any

941
00:43:05,119 --> 00:43:10,240
we don't want to be spending it on the

942
00:43:07,010 --> 00:43:14,180
other stuff which is kind of boring okay

943
00:43:10,240 --> 00:43:16,700
so all of this is built around like a

944
00:43:14,180 --> 00:43:18,169
language called F star which is a

945
00:43:16,700 --> 00:43:20,118
verification oriented programming

946
00:43:18,170 --> 00:43:21,770
language if you write code in a star and

947
00:43:20,119 --> 00:43:23,359
if you know Oh camel or F sharp it kind

948
00:43:21,770 --> 00:43:25,190
of looks like that if you're doing

949
00:43:23,359 --> 00:43:26,660
proofs in a star it kind of looks like

950
00:43:25,190 --> 00:43:29,390
Coke except that you have access to a

951
00:43:26,660 --> 00:43:32,868
SMT solver calls a three so a lot of the

952
00:43:29,390 --> 00:43:34,490
simple kind of proof obligations you

953
00:43:32,869 --> 00:43:36,800
might have are automatically discharged

954
00:43:34,490 --> 00:43:38,959
and once you've done your proof in a

955
00:43:36,800 --> 00:43:41,150
star you can compile it down to or camel

956
00:43:38,960 --> 00:43:43,190
to c2 webassembly whatever you like

957
00:43:41,150 --> 00:43:44,539
okay so you can try out the language the

958
00:43:43,190 --> 00:43:46,339
pretty cool language is developed at

959
00:43:44,539 --> 00:43:49,279
Microsoft Research mainly but also with

960
00:43:46,339 --> 00:43:50,599
collaborations with India so let's go

961
00:43:49,279 --> 00:43:53,089
the first step you're going to write the

962
00:43:50,599 --> 00:43:54,380
spec that we want to verify against so

963
00:43:53,089 --> 00:43:56,630
the first point that would like to make

964
00:43:54,380 --> 00:43:58,309
here already is that we as verification

965
00:43:56,630 --> 00:44:00,339
people should not be writing the specs

966
00:43:58,309 --> 00:44:02,420
right we are trying to prove something

967
00:44:00,339 --> 00:44:03,440
but why are we writing this back

968
00:44:02,420 --> 00:44:05,089
somebody else should be writing the

969
00:44:03,440 --> 00:44:06,200
specs for us in fact the people should

970
00:44:05,089 --> 00:44:07,940
be writing the specs or the people who

971
00:44:06,200 --> 00:44:09,379
are writing the standards or even better

972
00:44:07,940 --> 00:44:11,569
the cryptographers who actually designed

973
00:44:09,380 --> 00:44:13,130
this thing instead we are trying to

974
00:44:11,569 --> 00:44:14,538
figure out what the spec is by reading

975
00:44:13,130 --> 00:44:16,970
these really obscure textual

976
00:44:14,539 --> 00:44:19,130
descriptions that come out and trying to

977
00:44:16,970 --> 00:44:20,180
extract it ourselves which is a wasted

978
00:44:19,130 --> 00:44:22,490
effort and there could be a gap between

979
00:44:20,180 --> 00:44:25,160
what the what the RFC says and what we

980
00:44:22,490 --> 00:44:26,750
are doing so instead we we have designed

981
00:44:25,160 --> 00:44:28,549
this to kind of make it easier for

982
00:44:26,750 --> 00:44:30,289
cryptographers and standard authors to

983
00:44:28,549 --> 00:44:32,509
write formal specs we designed this DSL

984
00:44:30,289 --> 00:44:35,029
called hack spec where we have written a

985
00:44:32,510 --> 00:44:36,349
whole buncha specs already it looks kind

986
00:44:35,029 --> 00:44:38,150
of like the pseudo code you will see in

987
00:44:36,349 --> 00:44:39,589
the standards in fact it is a typed

988
00:44:38,150 --> 00:44:41,270
subset of Python 3

989
00:44:39,589 --> 00:44:43,640
and I'll show you an example in a second

990
00:44:41,270 --> 00:44:45,339
you can write a spec in there and then

991
00:44:43,640 --> 00:44:47,509
we have compilers that will spit out

992
00:44:45,339 --> 00:44:48,828
specs in other languages so right now it

993
00:44:47,510 --> 00:44:52,010
works for a couple of formal languages

994
00:44:48,829 --> 00:44:53,510
but we intend to spit out specs in

995
00:44:52,010 --> 00:44:56,750
almost all the languages that people are

996
00:44:53,510 --> 00:44:58,430
using so this we hope will reduce the

997
00:44:56,750 --> 00:44:59,809
gap between between what the

998
00:44:58,430 --> 00:45:01,879
cryptographers thinks we are proving and

999
00:44:59,809 --> 00:45:03,529
what we are actually proving and also

1000
00:45:01,880 --> 00:45:04,670
maybe will allow us to compare and

1001
00:45:03,529 --> 00:45:07,819
compose the proofs done in different

1002
00:45:04,670 --> 00:45:10,130
systems all right so this is what a hack

1003
00:45:07,819 --> 00:45:11,359
spec of chart when he looks like it's

1004
00:45:10,130 --> 00:45:14,210
just the very first function and the

1005
00:45:11,359 --> 00:45:15,890
spectra gates the line function so this

1006
00:45:14,210 --> 00:45:17,839
is actually Python free syntax this code

1007
00:45:15,890 --> 00:45:19,129
runs in Python tree but if you're a

1008
00:45:17,839 --> 00:45:20,930
Python programmer the thing that might

1009
00:45:19,130 --> 00:45:22,279
look weird to you is all those type

1010
00:45:20,930 --> 00:45:25,160
annotations but they're allowed in

1011
00:45:22,279 --> 00:45:26,690
Python 3 syntax so here this is a type

1012
00:45:25,160 --> 00:45:28,339
subset every variable has to be

1013
00:45:26,690 --> 00:45:30,740
annotated with the type and the types

1014
00:45:28,339 --> 00:45:32,089
that we have here include range type so

1015
00:45:30,740 --> 00:45:34,549
I can say that the index has to be

1016
00:45:32,089 --> 00:45:37,369
between 0 and 15 the rotation value has

1017
00:45:34,549 --> 00:45:39,230
to be between 1 and 31 and the array has

1018
00:45:37,369 --> 00:45:41,359
to have a length which is exactly 16 and

1019
00:45:39,230 --> 00:45:44,240
so on so these are sort of quite kind of

1020
00:45:41,359 --> 00:45:46,339
fairly detailed types if you're giving

1021
00:45:44,240 --> 00:45:48,589
these and then we rewrite the the

1022
00:45:46,339 --> 00:45:49,970
specification the specification consists

1023
00:45:48,589 --> 00:45:51,710
of a series of functions and each of

1024
00:45:49,970 --> 00:45:53,730
these functions is observationally pure

1025
00:45:51,710 --> 00:45:55,680
which means that internally it can

1026
00:45:53,730 --> 00:45:57,060
local variables but it cannot have any

1027
00:45:55,680 --> 00:45:59,250
side effects which are externally

1028
00:45:57,060 --> 00:46:00,750
visible and this is important to be able

1029
00:45:59,250 --> 00:46:03,480
to compile them to many languages like

1030
00:46:00,750 --> 00:46:05,040
cork and star and so on but once you

1031
00:46:03,480 --> 00:46:06,780
return this code you can actually run

1032
00:46:05,040 --> 00:46:08,340
this this is a spec but it's executable

1033
00:46:06,780 --> 00:46:10,080
you can run this you can see it pass all

1034
00:46:08,340 --> 00:46:11,340
the tests vectors and when you're

1035
00:46:10,080 --> 00:46:13,020
running it it'll actually trigger

1036
00:46:11,340 --> 00:46:15,060
runtime type checks as well to make sure

1037
00:46:13,020 --> 00:46:16,830
that you're you didn't make some silly

1038
00:46:15,060 --> 00:46:19,830
mistake when writing the spec so this is

1039
00:46:16,830 --> 00:46:22,110
a tool for writing a formal spec for a

1040
00:46:19,830 --> 00:46:24,180
crypto algorithm but once you've written

1041
00:46:22,110 --> 00:46:26,250
that we can compile it to an F star spec

1042
00:46:24,180 --> 00:46:27,930
which looks very similar but it's a

1043
00:46:26,250 --> 00:46:29,220
different syntax but doesn't matter

1044
00:46:27,930 --> 00:46:30,480
right you don't care you don't you're

1045
00:46:29,220 --> 00:46:32,669
not even we're going to look at this as

1046
00:46:30,480 --> 00:46:34,740
long as you trust that my star compiler

1047
00:46:32,670 --> 00:46:36,870
may hack stacked X bar X star compiler

1048
00:46:34,740 --> 00:46:38,040
is good and this stuff will do

1049
00:46:36,870 --> 00:46:39,630
additional checks on this we'll check

1050
00:46:38,040 --> 00:46:41,160
all the ranges it'll make sure that all

1051
00:46:39,630 --> 00:46:42,960
the functions are terminated terminating

1052
00:46:41,160 --> 00:46:44,430
and so on okay but that's some

1053
00:46:42,960 --> 00:46:46,650
additional sort of sanity checks on the

1054
00:46:44,430 --> 00:46:48,000
spec so we have the spec now the next

1055
00:46:46,650 --> 00:46:48,420
step is to write the vectorized code

1056
00:46:48,000 --> 00:46:50,040
right

1057
00:46:48,420 --> 00:46:52,590
but first year to design a vectorized

1058
00:46:50,040 --> 00:46:54,330
implement them so what are the

1059
00:46:52,590 --> 00:46:56,580
vectorization strategies for charger 20

1060
00:46:54,330 --> 00:46:58,350
that typically - one is what i call the

1061
00:46:56,580 --> 00:47:00,060
line base parallelism if you look at the

1062
00:46:58,350 --> 00:47:01,500
operations that are happening that the

1063
00:47:00,060 --> 00:47:03,120
function line that i showed you in the

1064
00:47:01,500 --> 00:47:05,190
previous slide you see all the places

1065
00:47:03,120 --> 00:47:06,660
it's called you can actually identify if

1066
00:47:05,190 --> 00:47:08,010
you unroll them that four of them can

1067
00:47:06,660 --> 00:47:09,600
happen at the same time stick into four

1068
00:47:08,010 --> 00:47:11,760
lines and then four lines and four lines

1069
00:47:09,600 --> 00:47:14,100
and then four lines and so if you have a

1070
00:47:11,760 --> 00:47:16,650
vector vectorized architecture where you

1071
00:47:14,100 --> 00:47:18,569
can have 128-bit vector so you can

1072
00:47:16,650 --> 00:47:20,370
operate on four 32-bit numbers at the

1073
00:47:18,570 --> 00:47:22,950
same time you can actually make this go

1074
00:47:20,370 --> 00:47:24,960
much faster ok so that's one strategy

1075
00:47:22,950 --> 00:47:26,939
the other one is to say well forget

1076
00:47:24,960 --> 00:47:30,090
about charger 20 it's essentially and

1077
00:47:26,940 --> 00:47:32,280
CTR spec CTR algorithm it uses counter

1078
00:47:30,090 --> 00:47:33,990
mode and so counter mode is inherently

1079
00:47:32,280 --> 00:47:35,760
parallel you can process any number of

1080
00:47:33,990 --> 00:47:37,740
blocks at the same time and that's true

1081
00:47:35,760 --> 00:47:38,970
and that's another way of paralyzing it

1082
00:47:37,740 --> 00:47:41,279
you just take different blocks in them

1083
00:47:38,970 --> 00:47:43,140
and run them in parallel we've done both

1084
00:47:41,280 --> 00:47:44,640
but I'm going to focus on the second

1085
00:47:43,140 --> 00:47:48,180
because it's actually a bit faster and

1086
00:47:44,640 --> 00:47:49,950
it's actually a bit more generic so this

1087
00:47:48,180 --> 00:47:52,830
is what we the first step of writing a

1088
00:47:49,950 --> 00:47:55,020
generic char 20 vectorize algorithm is

1089
00:47:52,830 --> 00:47:56,520
to take the static spec and we

1090
00:47:55,020 --> 00:47:59,370
generalize it to work on any number of

1091
00:47:56,520 --> 00:48:01,890
lanes ok so I define the type called

1092
00:47:59,370 --> 00:48:04,049
lanes there which says how many un 32

1093
00:48:01,890 --> 00:48:05,819
scan I operate in at the same time and I

1094
00:48:04,050 --> 00:48:07,290
just put out some limits to it as it can

1095
00:48:05,820 --> 00:48:08,970
be 1 for 8

1096
00:48:07,290 --> 00:48:10,920
at 1632 if you like because those are

1097
00:48:08,970 --> 00:48:12,450
the common vectorization patterns we

1098
00:48:10,920 --> 00:48:14,160
have but really we don't we don't care

1099
00:48:12,450 --> 00:48:15,390
how many lanes there are it's just that

1100
00:48:14,160 --> 00:48:18,270
those ones we know how to implement

1101
00:48:15,390 --> 00:48:21,359
efficiently then we define a type called

1102
00:48:18,270 --> 00:48:24,840
you and 32 X n which means it is a UN 32

1103
00:48:21,360 --> 00:48:27,390
vector of size W and our state basically

1104
00:48:24,840 --> 00:48:28,970
becomes a sequence of these vectors but

1105
00:48:27,390 --> 00:48:32,129
if you think about it the state is now

1106
00:48:28,970 --> 00:48:34,290
internally representing W copies of the

1107
00:48:32,130 --> 00:48:36,540
chair of the of the scalar state so

1108
00:48:34,290 --> 00:48:39,390
there W independent scalar states that

1109
00:48:36,540 --> 00:48:41,040
are included in one vector I stick the

1110
00:48:39,390 --> 00:48:42,450
code for line looks like almost exactly

1111
00:48:41,040 --> 00:48:45,150
the same except that it is parametrized

1112
00:48:42,450 --> 00:48:47,730
by the number of lanes in W as the first

1113
00:48:45,150 --> 00:48:48,960
parameter and every operation that we

1114
00:48:47,730 --> 00:48:51,630
are doing there is now a Sindhi

1115
00:48:48,960 --> 00:48:53,130
operation and not a UN 32 operation so

1116
00:48:51,630 --> 00:48:54,960
it just means please do the same

1117
00:48:53,130 --> 00:48:57,150
operation on every Lane okay so this is

1118
00:48:54,960 --> 00:48:59,160
one of the simpler cases where the line

1119
00:48:57,150 --> 00:49:01,980
function in the vector I sense is simply

1120
00:48:59,160 --> 00:49:04,109
a mapping of the scalar line function

1121
00:49:01,980 --> 00:49:05,610
but on all lanes just do the same

1122
00:49:04,110 --> 00:49:07,110
operation and all leads but that's

1123
00:49:05,610 --> 00:49:10,110
surprising number of functions actually

1124
00:49:07,110 --> 00:49:12,060
have this have this so rather than

1125
00:49:10,110 --> 00:49:13,380
writing the scalar code I would say I'm

1126
00:49:12,060 --> 00:49:15,150
saying that we would we will rather

1127
00:49:13,380 --> 00:49:18,660
rather write this algorithm which is

1128
00:49:15,150 --> 00:49:19,950
actually more general okay so that's

1129
00:49:18,660 --> 00:49:21,359
your vector I expect for one function

1130
00:49:19,950 --> 00:49:23,600
but of course that's not enough you've

1131
00:49:21,360 --> 00:49:25,740
got to do that kind of vectorized

1132
00:49:23,600 --> 00:49:28,529
implementation for each of the functions

1133
00:49:25,740 --> 00:49:30,569
in the charge aspect okay hang on a sim

1134
00:49:28,530 --> 00:49:32,670
D library that we have then you have to

1135
00:49:30,570 --> 00:49:34,140
do a little bit more more work to define

1136
00:49:32,670 --> 00:49:35,880
all the translations from the scalar

1137
00:49:34,140 --> 00:49:37,620
state to the vector I state and back and

1138
00:49:35,880 --> 00:49:39,030
these effectively our matrix

1139
00:49:37,620 --> 00:49:40,680
transpositions but for which we have a

1140
00:49:39,030 --> 00:49:42,810
nice library to do these transpositions

1141
00:49:40,680 --> 00:49:44,040
and finally you have to modify the or

1142
00:49:42,810 --> 00:49:46,020
the overall counter mode encryption

1143
00:49:44,040 --> 00:49:47,340
block to make sure you can process

1144
00:49:46,020 --> 00:49:49,080
multiple blocks at a time but that's

1145
00:49:47,340 --> 00:49:52,110
reasonably straightforward but that's

1146
00:49:49,080 --> 00:49:53,880
the last thing and then you're done so

1147
00:49:52,110 --> 00:49:56,100
now you have your rectoress algorithm is

1148
00:49:53,880 --> 00:49:58,320
it correct to prove it's correct there's

1149
00:49:56,100 --> 00:50:00,690
at least two steps first which is the

1150
00:49:58,320 --> 00:50:02,280
easy one I would say for each function

1151
00:50:00,690 --> 00:50:04,530
that we define like the line function

1152
00:50:02,280 --> 00:50:06,780
you proved that the vectorized version

1153
00:50:04,530 --> 00:50:09,330
is simply a map of the scalar 1 so this

1154
00:50:06,780 --> 00:50:11,010
lemma here basically says that if you

1155
00:50:09,330 --> 00:50:13,140
run the vector eyes line function and

1156
00:50:11,010 --> 00:50:15,180
then you transpose the state it is the

1157
00:50:13,140 --> 00:50:17,190
same result as if you transpose the

1158
00:50:15,180 --> 00:50:19,620
state first and then you ran the scalar

1159
00:50:17,190 --> 00:50:20,120
line function on each component of the

1160
00:50:19,620 --> 00:50:22,310
result

1161
00:50:20,120 --> 00:50:24,350
so it's basically that's the correctness

1162
00:50:22,310 --> 00:50:26,509
guarantee for for this one and then

1163
00:50:24,350 --> 00:50:27,890
composing all of these you can go back

1164
00:50:26,510 --> 00:50:29,660
go all the way up to the top level

1165
00:50:27,890 --> 00:50:31,310
encryption function and prove your main

1166
00:50:29,660 --> 00:50:33,140
theorem which is that the vectorized

1167
00:50:31,310 --> 00:50:35,509
encrypt function has the exact same

1168
00:50:33,140 --> 00:50:36,890
result as a scaler encrypt function you

1169
00:50:35,510 --> 00:50:40,640
don't get it just faster but it's the

1170
00:50:36,890 --> 00:50:42,290
same result okay but note that all of

1171
00:50:40,640 --> 00:50:44,779
these functions and all of these llamas

1172
00:50:42,290 --> 00:50:47,000
are parameterize by W we don't care how

1173
00:50:44,780 --> 00:50:49,670
what your width is it's still going to

1174
00:50:47,000 --> 00:50:51,590
prove it for all widths okay not always

1175
00:50:49,670 --> 00:50:55,010
all limits if you put in the lanes up

1176
00:50:51,590 --> 00:50:57,920
there all right so we have the algorithm

1177
00:50:55,010 --> 00:50:59,330
we want to go to code okay what's the

1178
00:50:57,920 --> 00:51:00,620
difference we already have the algorithm

1179
00:50:59,330 --> 00:51:03,710
what's the difference well this is what

1180
00:51:00,620 --> 00:51:05,900
the f star code or stateful code for

1181
00:51:03,710 --> 00:51:07,580
that particular function looks like it's

1182
00:51:05,900 --> 00:51:10,070
actually in a subset of a star called

1183
00:51:07,580 --> 00:51:12,020
low star that you can compile to see the

1184
00:51:10,070 --> 00:51:14,300
real code is just the bottom three lines

1185
00:51:12,020 --> 00:51:16,460
of the of the of this slide okay so it's

1186
00:51:14,300 --> 00:51:18,050
not much the rest of it is the

1187
00:51:16,460 --> 00:51:19,400
preconditions and postconditions that

1188
00:51:18,050 --> 00:51:23,030
you need in order to use this code

1189
00:51:19,400 --> 00:51:24,350
safely okay so the first thing is the

1190
00:51:23,030 --> 00:51:26,390
memory safety precondition that's the

1191
00:51:24,350 --> 00:51:27,950
only precondition it says that in order

1192
00:51:26,390 --> 00:51:29,930
the color of this function had better

1193
00:51:27,950 --> 00:51:31,310
make sure that the St pointer is

1194
00:51:29,930 --> 00:51:33,290
actually live in the current heap

1195
00:51:31,310 --> 00:51:34,730
otherwise you're not allowed to call

1196
00:51:33,290 --> 00:51:38,300
this function with a with a null pointer

1197
00:51:34,730 --> 00:51:40,010
for example okay the memory safety post

1198
00:51:38,300 --> 00:51:42,350
condition the first post condition says

1199
00:51:40,010 --> 00:51:43,880
I promise that I will keep all live

1200
00:51:42,350 --> 00:51:46,790
variables live as and I'm not going to

1201
00:51:43,880 --> 00:51:48,530
deallocate or free anything and I only

1202
00:51:46,790 --> 00:51:49,910
modify the SD variable and nothing else

1203
00:51:48,530 --> 00:51:51,380
and this is important if you want to

1204
00:51:49,910 --> 00:51:54,470
call this function and other functions

1205
00:51:51,380 --> 00:51:55,940
and compose the the proofs and the last

1206
00:51:54,470 --> 00:51:57,439
post condition basically the functional

1207
00:51:55,940 --> 00:51:58,970
correctness guarantee which says I

1208
00:51:57,440 --> 00:52:00,440
guarantee that the output of this

1209
00:51:58,970 --> 00:52:02,540
function is going to be exactly the same

1210
00:52:00,440 --> 00:52:04,910
as what the spec says it should be okay

1211
00:52:02,540 --> 00:52:06,590
the spec says the result is a line I am

1212
00:52:04,910 --> 00:52:08,210
producing exactly the same result

1213
00:52:06,590 --> 00:52:10,700
except I'm putting it in an array and

1214
00:52:08,210 --> 00:52:12,380
you have to look it up and stuff and the

1215
00:52:10,700 --> 00:52:13,790
code obviously looks very similar to the

1216
00:52:12,380 --> 00:52:15,650
spec in this case is the simplest

1217
00:52:13,790 --> 00:52:17,029
function you can imagine but there are

1218
00:52:15,650 --> 00:52:18,920
more complex functions where they may it

1219
00:52:17,030 --> 00:52:20,990
might look quite different an ester will

1220
00:52:18,920 --> 00:52:23,450
almost automatically prove that this

1221
00:52:20,990 --> 00:52:24,560
function meets its back I mean for this

1222
00:52:23,450 --> 00:52:25,759
function it will prove it automatically

1223
00:52:24,560 --> 00:52:27,610
for some other functions you might have

1224
00:52:25,760 --> 00:52:30,460
to help it a little bit but not much

1225
00:52:27,610 --> 00:52:33,530
alright so now we've gotten to code okay

1226
00:52:30,460 --> 00:52:34,220
so let's compile it if you've done the

1227
00:52:33,530 --> 00:52:36,170
holes

1228
00:52:34,220 --> 00:52:38,270
from hacks back down to back vectorized

1229
00:52:36,170 --> 00:52:41,690
code and now we can compile it and spit

1230
00:52:38,270 --> 00:52:44,150
out see if you set w equals 1 and and

1231
00:52:41,690 --> 00:52:45,680
run if they start to see compiler it's

1232
00:52:44,150 --> 00:52:46,970
going to specialize the code throw away

1233
00:52:45,680 --> 00:52:48,890
all the dead code throw away all the

1234
00:52:46,970 --> 00:52:50,359
cases that are not relevant in line

1235
00:52:48,890 --> 00:52:51,828
everything that needs to be in line and

1236
00:52:50,359 --> 00:52:54,859
spit out C code

1237
00:52:51,829 --> 00:52:57,380
which is the scalar portable C code that

1238
00:52:54,859 --> 00:52:59,930
will work on any 32-bit platform if you

1239
00:52:57,380 --> 00:53:01,670
said W to b4 it'll spit out 128-bit

1240
00:52:59,930 --> 00:53:04,368
vector I scored by linking to an

1241
00:53:01,670 --> 00:53:06,740
intrinsics library which can which then

1242
00:53:04,369 --> 00:53:09,559
this code can run on arm neon or an AV X

1243
00:53:06,740 --> 00:53:11,509
or I succeed 3 machine without any

1244
00:53:09,559 --> 00:53:13,910
problems so it's sort of it's just

1245
00:53:11,510 --> 00:53:16,490
producing 128-bit vectorized code if it

1246
00:53:13,910 --> 00:53:18,710
W equals 8 256 so on you can just crank

1247
00:53:16,490 --> 00:53:21,709
out as many implementations of this as

1248
00:53:18,710 --> 00:53:23,329
you want okay as long as you have the

1249
00:53:21,710 --> 00:53:25,670
intrinsics to actually implement the

1250
00:53:23,329 --> 00:53:29,420
vectorized operations it will just put

1251
00:53:25,670 --> 00:53:31,069
it up so you've done all this work this

1252
00:53:29,420 --> 00:53:32,510
is the whole path we took and you

1253
00:53:31,069 --> 00:53:34,700
finally got to the bottom right of

1254
00:53:32,510 --> 00:53:36,589
course we did this just for charger 20

1255
00:53:34,700 --> 00:53:38,779
we can do we do the same for the for

1256
00:53:36,589 --> 00:53:40,369
poly 1 305 Chateau Sheree and these

1257
00:53:38,780 --> 00:53:44,030
kinds of things whichever benefits most

1258
00:53:40,369 --> 00:53:45,349
from from vectorization and the proofs

1259
00:53:44,030 --> 00:53:47,660
will be slightly different so when you

1260
00:53:45,349 --> 00:53:49,450
Eve Ector eyes poly 1 3 or 5 it's sort

1261
00:53:47,660 --> 00:53:51,319
of most of your effort is actually in

1262
00:53:49,450 --> 00:53:53,598
defining proving to the vector eyes

1263
00:53:51,319 --> 00:53:55,250
field arithmetic is correct and and then

1264
00:53:53,599 --> 00:53:57,079
you have to prove that the inherent

1265
00:53:55,250 --> 00:53:58,910
parallelism that you're exploiting which

1266
00:53:57,079 --> 00:54:01,010
is the polynomial evaluation has a

1267
00:53:58,910 --> 00:54:02,629
Horner's rule and you expand it out and

1268
00:54:01,010 --> 00:54:04,579
so on so the logic is slightly different

1269
00:54:02,630 --> 00:54:07,010
but but the process is more or less the

1270
00:54:04,579 --> 00:54:08,869
same so what did we win we did all this

1271
00:54:07,010 --> 00:54:10,790
effort were did we win well what we get

1272
00:54:08,869 --> 00:54:12,109
is we spit out three different

1273
00:54:10,790 --> 00:54:13,430
implementations for charter and three

1274
00:54:12,109 --> 00:54:15,440
different implementations from poly from

1275
00:54:13,430 --> 00:54:17,450
the same implementation the scalar

1276
00:54:15,440 --> 00:54:19,369
32-bit code that we get out from here is

1277
00:54:17,450 --> 00:54:21,348
as fast as handwritten C code so that's

1278
00:54:19,369 --> 00:54:23,119
not a problem that you can see from

1279
00:54:21,349 --> 00:54:25,160
anywhere the 128-bit code is

1280
00:54:23,119 --> 00:54:27,319
significantly faster the 206 bit code is

1281
00:54:25,160 --> 00:54:28,970
significantly faster and if you go to

1282
00:54:27,319 --> 00:54:30,770
the bottom and you see well what is the

1283
00:54:28,970 --> 00:54:33,169
fastest assembly implementation of these

1284
00:54:30,770 --> 00:54:34,460
things on on your laptops you'll find

1285
00:54:33,170 --> 00:54:36,020
that well they're a little bit slower

1286
00:54:34,460 --> 00:54:38,180
than the fastest assembly implementation

1287
00:54:36,020 --> 00:54:40,520
but not so much and we came from a

1288
00:54:38,180 --> 00:54:42,828
completely generic non platform-specific

1289
00:54:40,520 --> 00:54:45,680
code ok and we're coming down to that

1290
00:54:42,829 --> 00:54:46,819
that speed level of course the precise

1291
00:54:45,680 --> 00:54:47,660
numbers here's please don't pay

1292
00:54:46,819 --> 00:54:48,980
attention if we chain

1293
00:54:47,660 --> 00:54:51,140
the compiler you change the operating

1294
00:54:48,980 --> 00:54:52,640
system small changes will change the

1295
00:54:51,140 --> 00:54:54,220
numbers but the rough shape of the

1296
00:54:52,640 --> 00:54:58,190
numbers will stay the same

1297
00:54:54,220 --> 00:55:00,740
and what about the effort film what does

1298
00:54:58,190 --> 00:55:03,500
the effort to actually do this alright

1299
00:55:00,740 --> 00:55:04,910
so we are hoping that this the

1300
00:55:03,500 --> 00:55:05,660
high-level spec which is the hack spec

1301
00:55:04,910 --> 00:55:07,399
is going to be written by the

1302
00:55:05,660 --> 00:55:09,319
cryptography that's not our effort right

1303
00:55:07,400 --> 00:55:11,390
the green bits is what we have to write

1304
00:55:09,319 --> 00:55:13,450
so it for for ChaCha we had to write

1305
00:55:11,390 --> 00:55:16,879
about seventeen hundred lines of code

1306
00:55:13,450 --> 00:55:19,308
plus spec plus proof and for poly about

1307
00:55:16,880 --> 00:55:21,260
four thousand lines okay if you look at

1308
00:55:19,309 --> 00:55:22,880
it and if you look at the C code that is

1309
00:55:21,260 --> 00:55:24,950
actually generated because they're

1310
00:55:22,880 --> 00:55:27,650
generating three implementations of each

1311
00:55:24,950 --> 00:55:29,598
it's far now our proof effort is far

1312
00:55:27,650 --> 00:55:31,250
less than what the C code is okay but

1313
00:55:29,599 --> 00:55:32,930
that's maybe not fair and no way I would

1314
00:55:31,250 --> 00:55:35,059
let the way I would see it is the amount

1315
00:55:32,930 --> 00:55:36,649
of effort required to verify one scalar

1316
00:55:35,059 --> 00:55:38,329
implementation of these primitives

1317
00:55:36,650 --> 00:55:40,609
that's the effort you still have to do

1318
00:55:38,329 --> 00:55:43,849
but you get for free all the vectorized

1319
00:55:40,609 --> 00:55:45,380
implementations of course we are

1320
00:55:43,849 --> 00:55:46,789
generalizing this now and trying to do

1321
00:55:45,380 --> 00:55:48,109
it for all the primitives in the hackls

1322
00:55:46,789 --> 00:55:49,760
to our library and as soon as it's done

1323
00:55:48,109 --> 00:55:51,230
will do when you release and so on if

1324
00:55:49,760 --> 00:55:53,420
you want access to the code that we've

1325
00:55:51,230 --> 00:55:55,279
already got please ask me and I will

1326
00:55:53,420 --> 00:55:56,599
level or figure out how to how to get it

1327
00:55:55,279 --> 00:55:59,000
to you we're already there trying to

1328
00:55:56,599 --> 00:56:00,740
deploy it in all of these places of

1329
00:55:59,000 --> 00:56:02,240
course just verifying the crypto itself

1330
00:56:00,740 --> 00:56:04,250
is not so interesting you want to lift

1331
00:56:02,240 --> 00:56:06,950
it up and try to verify larger crypto

1332
00:56:04,250 --> 00:56:09,920
applications protocols and and stacks

1333
00:56:06,950 --> 00:56:11,930
and already we are seeing that the the

1334
00:56:09,920 --> 00:56:14,630
vectorized version of Java 3 can be very

1335
00:56:11,930 --> 00:56:15,740
easily used in many post quantum

1336
00:56:14,630 --> 00:56:17,839
committers that we are also trying to

1337
00:56:15,740 --> 00:56:19,729
verify and so on and more generally we

1338
00:56:17,839 --> 00:56:21,369
are sort of working on two different

1339
00:56:19,730 --> 00:56:23,900
projects which you might have heard of

1340
00:56:21,369 --> 00:56:25,970
which are basically trying where the

1341
00:56:23,900 --> 00:56:29,270
crypto library is just crucial but one

1342
00:56:25,970 --> 00:56:31,160
component of building a large verified

1343
00:56:29,270 --> 00:56:33,500
security stack for the web including

1344
00:56:31,160 --> 00:56:34,700
project Everest which is where a lot of

1345
00:56:33,500 --> 00:56:38,000
the developments that we are doing are

1346
00:56:34,700 --> 00:56:42,649
coming from I'm going to conclude with

1347
00:56:38,000 --> 00:56:44,150
this slide where the my controlling

1348
00:56:42,650 --> 00:56:45,289
thoughts basically are that well we're

1349
00:56:44,150 --> 00:56:46,910
all trying to build as high assurance

1350
00:56:45,289 --> 00:56:49,190
crypto library and we won't apply this

1351
00:56:46,910 --> 00:56:50,538
for full libraries right but that to do

1352
00:56:49,190 --> 00:56:52,730
that this has to be a collaborative

1353
00:56:50,539 --> 00:56:54,049
effort now the kind of talk the talk

1354
00:56:52,730 --> 00:56:56,029
that he saw just before and this one

1355
00:56:54,049 --> 00:56:57,470
you've seen the limits of what form of

1356
00:56:56,029 --> 00:56:59,539
verification researchers can actually

1357
00:56:57,470 --> 00:57:00,649
give you but we need help and we can't

1358
00:56:59,539 --> 00:57:02,000
just do it

1359
00:57:00,650 --> 00:57:04,040
all your code by ourselves if you're

1360
00:57:02,000 --> 00:57:05,660
going to dump hundred variations of

1361
00:57:04,040 --> 00:57:07,550
assembly code I mean it's not really

1362
00:57:05,660 --> 00:57:09,680
it's not you're not going to be able to

1363
00:57:07,550 --> 00:57:11,060
verify it instead maybe we can all help

1364
00:57:09,680 --> 00:57:14,330
each other if you're a cryptographer

1365
00:57:11,060 --> 00:57:15,710
maybe you can write formal specs so that

1366
00:57:14,330 --> 00:57:17,330
we don't have to and we can be sure that

1367
00:57:15,710 --> 00:57:18,710
we are proving the right thing and you

1368
00:57:17,330 --> 00:57:20,420
can try hack spec or you can try any of

1369
00:57:18,710 --> 00:57:22,160
these other formal languages if you're a

1370
00:57:20,420 --> 00:57:24,110
crypto developer try to rethink the way

1371
00:57:22,160 --> 00:57:26,240
you're developing your library maybe

1372
00:57:24,110 --> 00:57:29,330
there is value in defining generic

1373
00:57:26,240 --> 00:57:31,359
algorithmic optimizations first rather

1374
00:57:29,330 --> 00:57:34,970
than always focusing on the low-level

1375
00:57:31,360 --> 00:57:37,700
assembly language instructions that you

1376
00:57:34,970 --> 00:57:39,439
are trying to optimize for well that's

1377
00:57:37,700 --> 00:57:43,149
it and I'm completely out of time so

1378
00:57:39,440 --> 00:57:43,150
thank you for your patience

1379
00:57:45,460 --> 00:57:49,790
Thanks

1380
00:57:46,760 --> 00:57:51,230
I think we'll make a little bit time for

1381
00:57:49,790 --> 00:57:52,310
questions because I see interest from

1382
00:57:51,230 --> 00:57:54,200
the audience so let's take a few

1383
00:57:52,310 --> 00:57:58,430
questions and then we'll get the next

1384
00:57:54,200 --> 00:58:01,399
speaker set up thank you for your talk I

1385
00:57:58,430 --> 00:58:05,210
noticed that you were measuring effort

1386
00:58:01,400 --> 00:58:08,980
in number of lines of code how would you

1387
00:58:05,210 --> 00:58:12,620
translate that to number of hours spent

1388
00:58:08,980 --> 00:58:14,360
this is a fair question and I think what

1389
00:58:12,620 --> 00:58:15,770
what happens is there's always a

1390
00:58:14,360 --> 00:58:17,300
difference between the first time you do

1391
00:58:15,770 --> 00:58:19,190
something in the second time and this is

1392
00:58:17,300 --> 00:58:21,110
actually the second time the first time

1393
00:58:19,190 --> 00:58:22,820
you do something this I think it's the

1394
00:58:21,110 --> 00:58:24,500
number of lines doesn't make any sense

1395
00:58:22,820 --> 00:58:26,090
because it's probably then 25 versions

1396
00:58:24,500 --> 00:58:28,010
of that of that thing until you got the

1397
00:58:26,090 --> 00:58:29,540
right one but what we've been really

1398
00:58:28,010 --> 00:58:31,610
engineering over the last year and a

1399
00:58:29,540 --> 00:58:33,050
half is to kind of identify all the

1400
00:58:31,610 --> 00:58:34,280
patterns that used to be used for

1401
00:58:33,050 --> 00:58:36,410
developing the first version of hacker

1402
00:58:34,280 --> 00:58:37,910
star distilling them into libraries so

1403
00:58:36,410 --> 00:58:39,890
that we have all that domain knowledge

1404
00:58:37,910 --> 00:58:42,319
so that now I'm only counting the

1405
00:58:39,890 --> 00:58:45,410
incremental effort done for every new

1406
00:58:42,320 --> 00:58:51,400
thing so that is getting pretty close to

1407
00:58:45,410 --> 00:58:51,399
the line count okay but yeah thank you

1408
00:58:56,400 --> 00:59:00,120
thank you very much for the very nice

1409
00:58:57,750 --> 00:59:01,950
talk so in your in your overview of what

1410
00:59:00,120 --> 00:59:03,480
what happens from the elect op left to

1411
00:59:01,950 --> 00:59:05,310
the bottom right there were two steps

1412
00:59:03,480 --> 00:59:07,170
that are labeled compiles so one from

1413
00:59:05,310 --> 00:59:11,220
hacks back to a star and one at the end

1414
00:59:07,170 --> 00:59:12,600
from low star to CN intrinsics do I

1415
00:59:11,220 --> 00:59:14,370
understand correctly that this

1416
00:59:12,600 --> 00:59:17,009
compilation steps the actual compilers

1417
00:59:14,370 --> 00:59:20,549
are not verified right that is correct

1418
00:59:17,010 --> 00:59:22,230
so so we for the for the big one which

1419
00:59:20,550 --> 00:59:24,930
is the on the bottom right going from F

1420
00:59:22,230 --> 00:59:26,790
star to C we have paper proofs that are

1421
00:59:24,930 --> 00:59:28,919
computation strategy is correct but the

1422
00:59:26,790 --> 00:59:30,420
software is certainly not verified and

1423
00:59:28,920 --> 00:59:34,080
neither is the C compiler using below

1424
00:59:30,420 --> 00:59:35,910
but but yeah indeed that is that is a

1425
00:59:34,080 --> 00:59:39,270
trusted computing base here which is not

1426
00:59:35,910 --> 00:59:42,390
insignificant okay thank you last

1427
00:59:39,270 --> 00:59:44,490
mission probes so that was a very cool

1428
00:59:42,390 --> 00:59:45,870
talk so this question you know maybe

1429
00:59:44,490 --> 00:59:48,209
it's a bit unfair to just ask you and

1430
00:59:45,870 --> 00:59:50,520
not the previous speakers but you know

1431
00:59:48,210 --> 00:59:52,230
if one were to begin a new formal

1432
00:59:50,520 --> 00:59:53,640
verification effort of you know did a

1433
00:59:52,230 --> 00:59:57,300
different set of crypto algorithms that

1434
00:59:53,640 --> 00:59:59,819
that you all implemented and you can

1435
00:59:57,300 --> 01:00:01,170
assume you know assume for the answer

1436
00:59:59,820 --> 01:00:05,160
that I'm a person who's familiar with

1437
01:00:01,170 --> 01:00:06,930
familiar with F star you know what in

1438
01:00:05,160 --> 01:00:09,750
your view after having undergone this

1439
01:00:06,930 --> 01:00:11,220
effort are the trade-offs between using

1440
01:00:09,750 --> 01:00:13,320
these two approaches you know which

1441
01:00:11,220 --> 01:00:14,609
would you pick I guess or what are the

1442
01:00:13,320 --> 01:00:16,800
what are the justifications for picking

1443
01:00:14,610 --> 01:00:20,370
F star picking clock I guess that's

1444
01:00:16,800 --> 01:00:21,870
suddenly unfair to just ask me but well

1445
01:00:20,370 --> 01:00:24,240
I would frame that slightly differently

1446
01:00:21,870 --> 01:00:25,500
because tools are tools and everybody

1447
01:00:24,240 --> 01:00:27,540
gets familiar with certain tools and

1448
01:00:25,500 --> 01:00:30,750
they use one or the other okay but a

1449
01:00:27,540 --> 01:00:33,870
bigger thing there is between synthesis

1450
01:00:30,750 --> 01:00:36,870
and and verification okay so when do we

1451
01:00:33,870 --> 01:00:39,240
use a high-level kind of minimize spec

1452
01:00:36,870 --> 01:00:41,220
and generate correct by default code and

1453
01:00:39,240 --> 01:00:42,810
then should we use code that somebody

1454
01:00:41,220 --> 01:00:44,580
has written and try to verify that it's

1455
01:00:42,810 --> 01:00:45,960
correct and there are many projects that

1456
01:00:44,580 --> 01:00:47,250
are trying to do both there's another

1457
01:00:45,960 --> 01:00:48,900
lovely project called veil that they're

1458
01:00:47,250 --> 01:00:52,560
actually verifying the assembly in of

1459
01:00:48,900 --> 01:00:54,270
OpenSSL right now and and I think there

1460
01:00:52,560 --> 01:00:55,470
is room for both so yes you saw in my

1461
01:00:54,270 --> 01:00:57,780
picture there are some places that we

1462
01:00:55,470 --> 01:00:59,430
compile some places that we verify we

1463
01:00:57,780 --> 01:01:00,810
find that by compilation we can get

1464
01:00:59,430 --> 01:01:03,419
pretty close and Fiat certainly gets

1465
01:01:00,810 --> 01:01:06,420
very close and better than a hundred in

1466
01:01:03,420 --> 01:01:08,430
code but in some cases you do want

1467
01:01:06,420 --> 01:01:11,160
to some very specific optimizations that

1468
01:01:08,430 --> 01:01:13,049
only work for craft of a 509 but not for

1469
01:01:11,160 --> 01:01:14,790
perforate you know and there are such

1470
01:01:13,049 --> 01:01:16,770
optimizations that will just kind of

1471
01:01:14,790 --> 01:01:18,029
lift you beyond and people need this and

1472
01:01:16,770 --> 01:01:19,980
for certain primitives and they don't

1473
01:01:18,030 --> 01:01:21,359
care for others and there you do want to

1474
01:01:19,980 --> 01:01:24,170
kind of come back and do some

1475
01:01:21,359 --> 01:01:27,240
verification and so it depends I guess

1476
01:01:24,170 --> 01:01:29,430
my feeling from my talk and the top

1477
01:01:27,240 --> 01:01:31,680
before is that then you can if you can

1478
01:01:29,430 --> 01:01:33,450
synthesize from a small code base to the

1479
01:01:31,680 --> 01:01:36,149
real one that you want to use that's

1480
01:01:33,450 --> 01:01:37,439
clearly the best one but I don't think

1481
01:01:36,150 --> 01:01:39,059
that's always going to be the case I'm

1482
01:01:37,440 --> 01:01:40,260
pretty confident that people will want

1483
01:01:39,059 --> 01:01:41,849
to write their own code and won't you

1484
01:01:40,260 --> 01:01:45,510
point us to verify it so we have to find

1485
01:01:41,849 --> 01:01:55,349
a middle ground between them okay thank

1486
01:01:45,510 --> 01:01:58,549
you let's thank the speaker again and we

1487
01:01:55,349 --> 01:01:58,549
will just get the third talk setup

1488
01:02:10,980 --> 01:02:15,790
okay so the third talk in this session

1489
01:02:13,270 --> 01:02:18,910
is going to be given by SUNY Devdas from

1490
01:02:15,790 --> 01:02:21,940
MIT and he's talking about towards an

1491
01:02:18,910 --> 01:02:22,240
open I've just lost the title there we

1492
01:02:21,940 --> 01:02:23,950
go

1493
01:02:22,240 --> 01:02:26,049
an open source formally verified secure

1494
01:02:23,950 --> 01:02:27,250
processor thank you very much thanks

1495
01:02:26,050 --> 01:02:32,560
Kenny good morning everyone

1496
01:02:27,250 --> 01:02:34,480
real thrilled to be here as you can see

1497
01:02:32,560 --> 01:02:36,250
there's a lot of adjectives on my title

1498
01:02:34,480 --> 01:02:36,670
so I'll try and explain them as they go

1499
01:02:36,250 --> 01:02:38,680
along

1500
01:02:36,670 --> 01:02:40,720
I want to point out the aspirational

1501
01:02:38,680 --> 01:02:42,669
aspect of the first word there so if

1502
01:02:40,720 --> 01:02:44,350
you're not quite where we want to go or

1503
01:02:42,670 --> 01:02:47,890
where we want to be but we're working

1504
01:02:44,350 --> 01:02:49,630
towards it and talk to you but the work

1505
01:02:47,890 --> 01:02:51,640
we've done really over the last couple

1506
01:02:49,630 --> 01:02:56,020
of years trying to get to secure

1507
01:02:51,640 --> 01:02:59,109
processors and so if you look at what

1508
01:02:56,020 --> 01:03:01,150
time shared systems should give us one

1509
01:02:59,110 --> 01:03:03,570
of the things that they should give us

1510
01:03:01,150 --> 01:03:05,560
as architectural isolation we want

1511
01:03:03,570 --> 01:03:08,170
compartments that are associated with

1512
01:03:05,560 --> 01:03:09,970
processes and we want privacy and

1513
01:03:08,170 --> 01:03:12,520
integrity guarantees associated with

1514
01:03:09,970 --> 01:03:14,680
these processes and obviously that's

1515
01:03:12,520 --> 01:03:18,190
fundamental to maintaining process

1516
01:03:14,680 --> 01:03:20,980
correctness as well as obviously the

1517
01:03:18,190 --> 01:03:23,260
privacy considerations but unfortunately

1518
01:03:20,980 --> 01:03:25,540
what's happened over the past few years

1519
01:03:23,260 --> 01:03:28,300
is we have you know this picture here

1520
01:03:25,540 --> 01:03:31,210
which is there's all these leaks

1521
01:03:28,300 --> 01:03:33,340
associated with information that are

1522
01:03:31,210 --> 01:03:37,000
associated with the breaking process

1523
01:03:33,340 --> 01:03:38,980
abstractions and these process

1524
01:03:37,000 --> 01:03:40,210
abstractions are broken for a variety of

1525
01:03:38,980 --> 01:03:45,010
reasons I mean they may be broken

1526
01:03:40,210 --> 01:03:46,900
because of bugs or features but they are

1527
01:03:45,010 --> 01:03:50,110
also broken because of side-channel

1528
01:03:46,900 --> 01:03:51,610
attacks and in particular what's changed

1529
01:03:50,110 --> 01:03:53,950
in computer architecture really over the

1530
01:03:51,610 --> 01:03:56,800
past couple of years is that people have

1531
01:03:53,950 --> 01:03:59,319
realized that micro architectural

1532
01:03:56,800 --> 01:04:01,990
optimizations that are useful for

1533
01:03:59,320 --> 01:04:04,780
performance and energy have these

1534
01:04:01,990 --> 01:04:06,490
unintended really side effects that are

1535
01:04:04,780 --> 01:04:10,120
associated with leaking information

1536
01:04:06,490 --> 01:04:13,959
across processes and I think that

1537
01:04:10,120 --> 01:04:15,790
exacerbated I in the a domain of secure

1538
01:04:13,960 --> 01:04:17,980
enclaves which is really going to be the

1539
01:04:15,790 --> 01:04:19,570
primary focus of this talk where you

1540
01:04:17,980 --> 01:04:21,520
actually don't trust the software you

1541
01:04:19,570 --> 01:04:23,170
don't trust system software and so now

1542
01:04:21,520 --> 01:04:23,950
you have this malicious adversary

1543
01:04:23,170 --> 01:04:26,890
who

1544
01:04:23,950 --> 01:04:30,430
he has a lot of privilege and a lot of

1545
01:04:26,890 --> 01:04:34,839
power over the individual processes and

1546
01:04:30,430 --> 01:04:37,509
so this notion of force of containers

1547
01:04:34,839 --> 01:04:39,549
and enclaves predates micro

1548
01:04:37,510 --> 01:04:42,119
architectural side channels but I think

1549
01:04:39,550 --> 01:04:44,950
together they've sort of caused a

1550
01:04:42,119 --> 01:04:47,410
wrecked havoc on architectural

1551
01:04:44,950 --> 01:04:48,790
optimizations and so I'll hopefully give

1552
01:04:47,410 --> 01:04:51,129
you a sense of that by the time we're

1553
01:04:48,790 --> 01:04:53,800
done here so once you give you a sense

1554
01:04:51,130 --> 01:04:56,400
of the attacks that we're considering in

1555
01:04:53,800 --> 01:04:58,599
in our work and this is really a a

1556
01:04:56,400 --> 01:05:01,390
template for attacks

1557
01:04:58,599 --> 01:05:03,430
there's many specific attacks that fall

1558
01:05:01,390 --> 01:05:08,078
into this obviously attacks they're

1559
01:05:03,430 --> 01:05:09,578
combinations of in many cases bugs as

1560
01:05:08,079 --> 01:05:12,240
well as these micro architectural side

1561
01:05:09,579 --> 01:05:14,829
channels but if you kind of look into

1562
01:05:12,240 --> 01:05:16,689
what's going on with specter and

1563
01:05:14,829 --> 01:05:18,849
meltdown and the cache timing attacks

1564
01:05:16,690 --> 01:05:20,530
that really predated spectrum and

1565
01:05:18,849 --> 01:05:24,160
meltdown you have essentially the

1566
01:05:20,530 --> 01:05:26,589
picture here which is you have domains

1567
01:05:24,160 --> 01:05:29,589
you know you have containers domains

1568
01:05:26,589 --> 01:05:31,839
processes what-have-you and there's a

1569
01:05:29,589 --> 01:05:35,290
victim domain and there's a there's an

1570
01:05:31,839 --> 01:05:37,720
attacker domain and obviously these

1571
01:05:35,290 --> 01:05:39,730
domains should stay separate and what

1572
01:05:37,720 --> 01:05:44,500
happens is that you have a channel

1573
01:05:39,730 --> 01:05:47,349
that's built potentially by the attacker

1574
01:05:44,500 --> 01:05:50,500
but essentially exists in the design in

1575
01:05:47,349 --> 01:05:53,050
some fashion which is this side channel

1576
01:05:50,500 --> 01:05:55,180
and it could be completion time of a

1577
01:05:53,050 --> 01:05:57,010
process because the operating system can

1578
01:05:55,180 --> 01:05:58,540
view the completion time of a process it

1579
01:05:57,010 --> 01:06:01,180
could be because of shared macro

1580
01:05:58,540 --> 01:06:04,000
architectural state because you share a

1581
01:06:01,180 --> 01:06:06,190
cache it could be bandwidth it could be

1582
01:06:04,000 --> 01:06:07,210
an arbiter that's unfair and this is

1583
01:06:06,190 --> 01:06:08,410
just a wide variety of these things

1584
01:06:07,210 --> 01:06:11,319
since that's sort of what's in the

1585
01:06:08,410 --> 01:06:14,020
middle and what really you're trying to

1586
01:06:11,319 --> 01:06:16,029
do as an attacker is synthesize the

1587
01:06:14,020 --> 01:06:17,890
transmitter on one side which is running

1588
01:06:16,030 --> 01:06:20,829
inside of the victim protection domain

1589
01:06:17,890 --> 01:06:23,950
which allows obviously privileged access

1590
01:06:20,829 --> 01:06:26,339
or whatever access that you have for

1591
01:06:23,950 --> 01:06:29,740
your own code if you're the victim and

1592
01:06:26,339 --> 01:06:32,410
take the information from the victim

1593
01:06:29,740 --> 01:06:33,790
code victim data and propagated through

1594
01:06:32,410 --> 01:06:36,848
the channel to a receiver on the

1595
01:06:33,790 --> 01:06:40,359
attacker side right and so it

1596
01:06:36,849 --> 01:06:42,789
old twenty-year-old side-channel that

1597
01:06:40,359 --> 01:06:45,729
that is something that says conditional

1598
01:06:42,789 --> 01:06:47,979
execution in cryptographic algorithms

1599
01:06:45,729 --> 01:06:49,960
such as RSA where you do different

1600
01:06:47,979 --> 01:06:51,999
things based on the secret bit

1601
01:06:49,960 --> 01:06:53,559
corresponding to a private key where you

1602
01:06:51,999 --> 01:06:55,868
bring things into the cache or your

1603
01:06:53,559 --> 01:06:58,239
completion time or just the work that

1604
01:06:55,869 --> 01:07:01,359
you do is different in the if branch

1605
01:06:58,239 --> 01:07:02,920
versus the else branch and that's going

1606
01:07:01,359 --> 01:07:06,519
to be a channel right so that's an

1607
01:07:02,920 --> 01:07:08,170
example but more sophisticated examples

1608
01:07:06,519 --> 01:07:09,640
are things like meltdown which

1609
01:07:08,170 --> 01:07:11,410
correspond to a bug in the processor

1610
01:07:09,640 --> 01:07:13,660
pipeline and even more sophisticated

1611
01:07:11,410 --> 01:07:16,868
examples which give you a really rich

1612
01:07:13,660 --> 01:07:18,609
attack surface if you're an attacker are

1613
01:07:16,869 --> 01:07:20,140
things like spectral and meltdown where

1614
01:07:18,609 --> 01:07:22,420
they're actually synthesizing

1615
01:07:20,140 --> 01:07:25,239
transmitters from victim code sort of

1616
01:07:22,420 --> 01:07:27,249
putting together pieces of code that

1617
01:07:25,239 --> 01:07:29,710
exists in the victim and they have the

1618
01:07:27,249 --> 01:07:34,089
privilege of the victim and using that

1619
01:07:29,710 --> 01:07:35,829
to to exfiltrate information through

1620
01:07:34,089 --> 01:07:38,410
particular side channels and usually

1621
01:07:35,829 --> 01:07:39,910
most of the attacks that are out there

1622
01:07:38,410 --> 01:07:42,819
and the ones that have gotten a lot of

1623
01:07:39,910 --> 01:07:44,558
press are using the cache timing side

1624
01:07:42,819 --> 01:07:47,079
channel because it's a it's a kind of a

1625
01:07:44,559 --> 01:07:50,880
relatively low noise a high bandwidth

1626
01:07:47,079 --> 01:07:53,859
side channel but this picture really is

1627
01:07:50,880 --> 01:07:56,799
evocative of a whole class of techniques

1628
01:07:53,859 --> 01:07:58,779
and as I mentioned really the side

1629
01:07:56,799 --> 01:08:00,339
channels are everywhere right it's if

1630
01:07:58,779 --> 01:08:01,779
you look at a computer system and

1631
01:08:00,339 --> 01:08:02,920
there's tens of millions of lines of

1632
01:08:01,779 --> 01:08:05,079
code corresponding to the operating

1633
01:08:02,920 --> 01:08:06,969
system there's complexity associated

1634
01:08:05,079 --> 01:08:09,759
with the hardware this hardware is only

1635
01:08:06,969 --> 01:08:12,640
getting more complicated I hardware

1636
01:08:09,759 --> 01:08:13,869
designers want to know how to use for

1637
01:08:12,640 --> 01:08:16,028
better performance or lower in energy

1638
01:08:13,869 --> 01:08:18,099
all the real estate that they have and

1639
01:08:16,029 --> 01:08:21,759
so there's and there's a lot of sharing

1640
01:08:18,099 --> 01:08:23,290
associated with with these Hardware

1641
01:08:21,759 --> 01:08:26,380
constructs because you don't necessarily

1642
01:08:23,290 --> 01:08:28,269
just want to do accelerators and this

1643
01:08:26,380 --> 01:08:30,159
side channels everywhere there's

1644
01:08:28,270 --> 01:08:31,810
bandwidth side channels this storage

1645
01:08:30,158 --> 01:08:35,500
side channels there's completion time

1646
01:08:31,810 --> 01:08:37,779
side channels and it's only getting more

1647
01:08:35,500 --> 01:08:41,069
complicated there's also more domains of

1648
01:08:37,779 --> 01:08:43,179
course right I mean you have you have

1649
01:08:41,069 --> 01:08:44,710
many victims you know you have time

1650
01:08:43,179 --> 01:08:46,270
sharing and you have the operating

1651
01:08:44,710 --> 01:08:47,529
system you have hypervisors and so

1652
01:08:46,270 --> 01:08:48,969
there's different privilege levels as

1653
01:08:47,529 --> 01:08:50,870
well so this is a fairly complicated

1654
01:08:48,969 --> 01:08:53,480
situation here

1655
01:08:50,870 --> 01:08:56,019
so our philosophy really has been you

1656
01:08:53,479 --> 01:08:58,939
know for fertile a more than a decade is

1657
01:08:56,020 --> 01:09:01,310
build build enclaves you know not just

1658
01:08:58,939 --> 01:09:03,529
processes enclaves have an Associated

1659
01:09:01,310 --> 01:09:05,839
threat model as and you know you can

1660
01:09:03,529 --> 01:09:07,279
obviously vary that threat model and you

1661
01:09:05,839 --> 01:09:09,620
need to do more work obviously for the

1662
01:09:07,279 --> 01:09:11,420
more aggressive threats and build an

1663
01:09:09,620 --> 01:09:13,130
enclave platform so change the computer

1664
01:09:11,420 --> 01:09:15,350
architecture you know do hardware

1665
01:09:13,130 --> 01:09:16,940
software code design so you build an

1666
01:09:15,350 --> 01:09:19,760
enclave platform that doesn't just

1667
01:09:16,939 --> 01:09:22,129
support processes but supports stronger

1668
01:09:19,760 --> 01:09:23,570
notions of processes namely enclaves and

1669
01:09:22,130 --> 01:09:28,460
obviously I'll say a lot more about this

1670
01:09:23,569 --> 01:09:30,290
as they go along and so so I enclaves

1671
01:09:28,460 --> 01:09:33,710
need to strengthen the process

1672
01:09:30,290 --> 01:09:35,180
abstraction and the idea is that if you

1673
01:09:33,710 --> 01:09:36,560
have a threat model that includes site

1674
01:09:35,180 --> 01:09:38,839
channels and enclaves should be

1675
01:09:36,560 --> 01:09:40,850
resistant to those side channel attacks

1676
01:09:38,839 --> 01:09:43,040
and what-have-you

1677
01:09:40,850 --> 01:09:44,359
you want to get guarantee isolation of

1678
01:09:43,040 --> 01:09:47,300
memory that's really what it comes down

1679
01:09:44,359 --> 01:09:50,480
to you I the memory that you the victim

1680
01:09:47,300 --> 01:09:52,460
owns it should be just a readable by you

1681
01:09:50,479 --> 01:09:54,320
writable by you and there should be

1682
01:09:52,460 --> 01:09:57,860
other ways of extracting that

1683
01:09:54,320 --> 01:10:00,230
information and essentially what we have

1684
01:09:57,860 --> 01:10:03,860
here as you see in this in the slide is

1685
01:10:00,230 --> 01:10:05,839
you want to have this privacy guarantee

1686
01:10:03,860 --> 01:10:07,580
and I'll let you read that that's

1687
01:10:05,840 --> 01:10:10,160
associated not just with architectural

1688
01:10:07,580 --> 01:10:11,870
state which really computers are giving

1689
01:10:10,160 --> 01:10:14,210
you architectural state is not readable

1690
01:10:11,870 --> 01:10:15,740
by attackers it's really the other state

1691
01:10:14,210 --> 01:10:19,430
that is supporting the architectural

1692
01:10:15,740 --> 01:10:20,870
state that is causing problems and the

1693
01:10:19,430 --> 01:10:25,100
other thing that enclaves can do for you

1694
01:10:20,870 --> 01:10:26,990
is decouple performance from security

1695
01:10:25,100 --> 01:10:29,560
considerations so the idea is that you

1696
01:10:26,990 --> 01:10:32,480
pay for protection and so you have these

1697
01:10:29,560 --> 01:10:34,490
stronger processes that you pay more

1698
01:10:32,480 --> 01:10:37,429
when you enter them and you exit them

1699
01:10:34,490 --> 01:10:40,940
and you don't pay for you don't pay at

1700
01:10:37,430 --> 01:10:42,470
all for unprotected processes so we just

1701
01:10:40,940 --> 01:10:44,349
essentially running on public data and

1702
01:10:42,470 --> 01:10:48,740
you don't particularly care about

1703
01:10:44,350 --> 01:10:52,340
privacy for those processes hardware is

1704
01:10:48,740 --> 01:10:54,160
a is a complicated thing to build and it

1705
01:10:52,340 --> 01:10:57,140
also takes a long time to fabricate

1706
01:10:54,160 --> 01:10:58,700
chips and deploy them and so generally

1707
01:10:57,140 --> 01:11:00,470
speaking you don't want to make dramatic

1708
01:10:58,700 --> 01:11:02,780
changes I mean if you want to go make

1709
01:11:00,470 --> 01:11:03,610
dramatic changes in the AMD or the Intel

1710
01:11:02,780 --> 01:11:05,619
or the arm

1711
01:11:03,610 --> 01:11:07,900
the pipeline that's going to take you a

1712
01:11:05,619 --> 01:11:09,820
decade but if you change the interfaces

1713
01:11:07,900 --> 01:11:11,650
of hardware components it's less

1714
01:11:09,820 --> 01:11:13,030
invasive and you may have a chance on

1715
01:11:11,650 --> 01:11:14,469
getting into the next product now of

1716
01:11:13,030 --> 01:11:16,989
course we do clean slate design in

1717
01:11:14,469 --> 01:11:19,690
academia so but we do keep this in mind

1718
01:11:16,989 --> 01:11:21,369
in terms of the amount of hardware

1719
01:11:19,690 --> 01:11:22,989
change that you want to make to your

1720
01:11:21,369 --> 01:11:24,309
conventional processor it also makes

1721
01:11:22,989 --> 01:11:26,259
sense that if you make more dramatic

1722
01:11:24,310 --> 01:11:27,580
changes that you have the reason about

1723
01:11:26,260 --> 01:11:29,650
those more dramatic changes from a

1724
01:11:27,580 --> 01:11:31,780
standpoint of security and it might also

1725
01:11:29,650 --> 01:11:34,719
affect the performance all right and so

1726
01:11:31,780 --> 01:11:37,330
and then lastly you'd like to have some

1727
01:11:34,719 --> 01:11:39,369
sort of argument you know whether it's a

1728
01:11:37,330 --> 01:11:40,900
cryptographic argument or in most in

1729
01:11:39,369 --> 01:11:42,909
most of the cases here that I'll

1730
01:11:40,900 --> 01:11:44,799
describe it's an invariant you'd like to

1731
01:11:42,909 --> 01:11:47,110
have provable security and this may be

1732
01:11:44,800 --> 01:11:48,489
manual this may be formal formal I'll

1733
01:11:47,110 --> 01:11:50,349
say a little bit about that as I go

1734
01:11:48,489 --> 01:11:51,940
along and there are some downsides to

1735
01:11:50,350 --> 01:11:53,530
enclaves and building enclaves and I'll

1736
01:11:51,940 --> 01:11:56,290
say a little bit about that at the end

1737
01:11:53,530 --> 01:11:59,500
of end of the talk but this is this is

1738
01:11:56,290 --> 01:12:01,780
motivation and so the other thing I want

1739
01:11:59,500 --> 01:12:04,840
to talk about before I dive into details

1740
01:12:01,780 --> 01:12:07,719
is who do you trust right so you have

1741
01:12:04,840 --> 01:12:09,940
trusted computing basis and it's 100

1742
01:12:07,719 --> 01:12:12,280
million lines of code maybe more than

1743
01:12:09,940 --> 01:12:14,769
you're trusting Amazon Cloud and it's

1744
01:12:12,280 --> 01:12:17,050
the entirety of the computer system you

1745
01:12:14,770 --> 01:12:20,230
trust memory etc and so there's been

1746
01:12:17,050 --> 01:12:21,969
this effort that corresponds to secure

1747
01:12:20,230 --> 01:12:23,799
enclaves under untrusted operating

1748
01:12:21,969 --> 01:12:25,659
systems that really tries to shrink the

1749
01:12:23,800 --> 01:12:28,090
TCB right and there's also obviously

1750
01:12:25,659 --> 01:12:28,540
coprocessor work like TPMS and so on and

1751
01:12:28,090 --> 01:12:30,159
so forth

1752
01:12:28,540 --> 01:12:33,850
so you'd like to shrink the trusted

1753
01:12:30,159 --> 01:12:35,679
computing base and this slide is is 16

1754
01:12:33,850 --> 01:12:36,880
years old and I guess the chip in the

1755
01:12:35,679 --> 01:12:40,630
middle there looks like it's from the

1756
01:12:36,880 --> 01:12:42,310
1950s but it's it's it's just cool apart

1757
01:12:40,630 --> 01:12:44,020
from 15 years ago and you can see the

1758
01:12:42,310 --> 01:12:48,460
CRTs and so on

1759
01:12:44,020 --> 01:12:50,199
in the slide but this is again a slide

1760
01:12:48,460 --> 01:12:52,330
that essentially says you know here's

1761
01:12:50,199 --> 01:12:54,309
what the ideal world would look like if

1762
01:12:52,330 --> 01:12:56,100
you tried to minimize your trusted

1763
01:12:54,310 --> 01:12:59,380
computing base and you tried to

1764
01:12:56,100 --> 01:13:02,110
essentially build enclaves in this type

1765
01:12:59,380 --> 01:13:04,750
of architecture so you just trust the

1766
01:13:02,110 --> 01:13:06,549
the computer ship in terms of the

1767
01:13:04,750 --> 01:13:08,650
hardware it's it has an attestation

1768
01:13:06,550 --> 01:13:10,210
capability because you can't see inside

1769
01:13:08,650 --> 01:13:11,920
of it so it's going to have to do some

1770
01:13:10,210 --> 01:13:13,719
measurement and then it's going to have

1771
01:13:11,920 --> 01:13:15,550
to verify that the software that you're

1772
01:13:13,719 --> 01:13:16,930
running is in fact a software that you

1773
01:13:15,550 --> 01:13:18,100
expect to run

1774
01:13:16,930 --> 01:13:20,740
that's why you have a secret key in

1775
01:13:18,100 --> 01:13:23,830
there and you can build this in many

1776
01:13:20,740 --> 01:13:25,540
different ways but the way we build this

1777
01:13:23,830 --> 01:13:26,890
is we don't trust the operating system

1778
01:13:25,540 --> 01:13:28,780
and there's that kind of a baby

1779
01:13:26,890 --> 01:13:30,910
operating system or security monitor

1780
01:13:28,780 --> 01:13:32,440
that's what we call it that corresponds

1781
01:13:30,910 --> 01:13:34,300
to maybe about you know five thousand

1782
01:13:32,440 --> 01:13:36,129
lines of code in our implementation that

1783
01:13:34,300 --> 01:13:38,020
is trusted and it doesn't do the work

1784
01:13:36,130 --> 01:13:40,330
that the operating system does in terms

1785
01:13:38,020 --> 01:13:42,280
of resource allocation the decisions the

1786
01:13:40,330 --> 01:13:43,180
intelligence associated with that but it

1787
01:13:42,280 --> 01:13:44,889
checks invariants

1788
01:13:43,180 --> 01:13:46,960
it checks in variants associated with

1789
01:13:44,890 --> 01:13:49,090
isolation of memory right so that's why

1790
01:13:46,960 --> 01:13:52,660
it can be simple and you have to protect

1791
01:13:49,090 --> 01:13:55,780
side channels that correspond to a

1792
01:13:52,660 --> 01:13:57,340
memory and also there's obviously side

1793
01:13:55,780 --> 01:13:59,469
channels inside of it and I will say

1794
01:13:57,340 --> 01:14:01,060
that when we made the slide 16 years ago

1795
01:13:59,470 --> 01:14:04,570
didn't think side channels were gonna be

1796
01:14:01,060 --> 01:14:06,640
that big a deal but certainly the the

1797
01:14:04,570 --> 01:14:08,679
notion of a shrinking the trusted

1798
01:14:06,640 --> 01:14:12,280
computing base is something that this

1799
01:14:08,680 --> 01:14:14,200
slide describes and you'd like to take

1800
01:14:12,280 --> 01:14:16,210
that 10 million lines of code and shrink

1801
01:14:14,200 --> 01:14:19,170
it down into something much less that is

1802
01:14:16,210 --> 01:14:21,940
you know potentially formally verifiable

1803
01:14:19,170 --> 01:14:24,280
and so let me tell you a little bit

1804
01:14:21,940 --> 01:14:27,190
about enclaves and what we're trying to

1805
01:14:24,280 --> 01:14:29,349
build here and so essentially you think

1806
01:14:27,190 --> 01:14:31,330
about some enclaves as being containers

1807
01:14:29,350 --> 01:14:33,220
and you are very careful about what

1808
01:14:31,330 --> 01:14:34,690
these containers contain and you measure

1809
01:14:33,220 --> 01:14:38,530
them you measure them cryptographically

1810
01:14:34,690 --> 01:14:43,269
and the operating system creates them

1811
01:14:38,530 --> 01:14:45,460
and puts a program in code inside of

1812
01:14:43,270 --> 01:14:47,590
them and there's no sensitive code

1813
01:14:45,460 --> 01:14:49,210
inside it's all public at that point and

1814
01:14:47,590 --> 01:14:51,910
it does a measurement and then only

1815
01:14:49,210 --> 01:14:54,190
after that measurement will a sensitive

1816
01:14:51,910 --> 01:14:56,920
code or sensitive data be sent in an

1817
01:14:54,190 --> 01:14:59,290
encrypted way in to do decide inside of

1818
01:14:56,920 --> 01:15:01,450
the Enclave so that's one part of it and

1819
01:14:59,290 --> 01:15:03,070
the other part of it is that you

1820
01:15:01,450 --> 01:15:04,420
obviously running inside of the Enclave

1821
01:15:03,070 --> 01:15:06,219
and sometimes you have to go out and

1822
01:15:04,420 --> 01:15:07,800
make system calls and come back in and

1823
01:15:06,220 --> 01:15:09,820
you have to be super careful about

1824
01:15:07,800 --> 01:15:11,860
essentially the state that's associated

1825
01:15:09,820 --> 01:15:13,719
obviously not just architectural state

1826
01:15:11,860 --> 01:15:15,280
but also the micro architectural state

1827
01:15:13,720 --> 01:15:17,260
associated with supporting this Enclave

1828
01:15:15,280 --> 01:15:18,969
and make sure that you clean up after

1829
01:15:17,260 --> 01:15:21,000
yourself and you know Daniel and you've

1830
01:15:18,970 --> 01:15:23,350
all gave a great talk yesterday about

1831
01:15:21,000 --> 01:15:25,090
issues that come up with not cleaning

1832
01:15:23,350 --> 01:15:27,820
this micro architectural state and how

1833
01:15:25,090 --> 01:15:30,280
you have attacks based on those the

1834
01:15:27,820 --> 01:15:30,710
those errors if you will with respect to

1835
01:15:30,280 --> 01:15:31,849
not flaw

1836
01:15:30,710 --> 01:15:34,730
saying things and leaving things behind

1837
01:15:31,850 --> 01:15:36,080
you right so you have to do that but

1838
01:15:34,730 --> 01:15:39,650
that's essentially what we're trying to

1839
01:15:36,080 --> 01:15:41,450
support here and the isolation goal and

1840
01:15:39,650 --> 01:15:44,089
it's roughly speaking and I'd like to

1841
01:15:41,450 --> 01:15:45,830
read the details over here is you want

1842
01:15:44,090 --> 01:15:47,660
to have a high level property that

1843
01:15:45,830 --> 01:15:48,980
essentially says you know what even

1844
01:15:47,660 --> 01:15:50,540
though you're on the machine and you

1845
01:15:48,980 --> 01:15:54,169
have privilege as an operating system

1846
01:15:50,540 --> 01:15:56,510
you can't do anything worse than what

1847
01:15:54,170 --> 01:15:58,010
you would be able to do if you were away

1848
01:15:56,510 --> 01:16:00,110
in on a completely different machine

1849
01:15:58,010 --> 01:16:02,150
right so this is essentially something

1850
01:16:00,110 --> 01:16:04,460
that the top level you want this goal

1851
01:16:02,150 --> 01:16:06,500
you got to break this down into a bunch

1852
01:16:04,460 --> 01:16:07,969
of invariance if you want to actually go

1853
01:16:06,500 --> 01:16:09,500
off and prove things about it and you

1854
01:16:07,969 --> 01:16:11,030
have to say things very explicitly about

1855
01:16:09,500 --> 01:16:14,810
state and so on and so forth

1856
01:16:11,030 --> 01:16:17,059
I eat each piece of state what I want to

1857
01:16:14,810 --> 01:16:18,560
point out here is that we are not we're

1858
01:16:17,060 --> 01:16:21,620
assuming well-written programs I mean if

1859
01:16:18,560 --> 01:16:23,210
a program is dumb enough for it to to

1860
01:16:21,620 --> 01:16:25,160
write out its secret it's private key

1861
01:16:23,210 --> 01:16:27,080
over on stand it out I mean this doesn't

1862
01:16:25,160 --> 01:16:28,430
protect that right and so so if you're

1863
01:16:27,080 --> 01:16:30,559
not protecting against programs that

1864
01:16:28,430 --> 01:16:32,690
leak secrets through their their API

1865
01:16:30,560 --> 01:16:35,030
it's really outside of the API attacks

1866
01:16:32,690 --> 01:16:37,070
that we're trying to protect against and

1867
01:16:35,030 --> 01:16:39,650
there's basically three strategies for

1868
01:16:37,070 --> 01:16:41,509
isolation the spatial isolation temporal

1869
01:16:39,650 --> 01:16:43,299
isolation and cryptography right I'm not

1870
01:16:41,510 --> 01:16:46,219
gonna say a lot about cryptography so

1871
01:16:43,300 --> 01:16:49,520
sorry real-world crypto but it's mostly

1872
01:16:46,219 --> 01:16:51,110
about isolation spatial isolation and

1873
01:16:49,520 --> 01:16:52,940
temporal isolation corresponding to

1874
01:16:51,110 --> 01:16:56,900
these architectures and the photography

1875
01:16:52,940 --> 01:16:58,429
does have a some some role here briefly

1876
01:16:56,900 --> 01:17:00,230
mentioned that so I want to tell you

1877
01:16:58,430 --> 01:17:02,030
about a couple of processors that we've

1878
01:17:00,230 --> 01:17:04,040
built but one of them that was built a

1879
01:17:02,030 --> 01:17:06,019
couple of years ago and a processor that

1880
01:17:04,040 --> 01:17:08,360
we're in the middle of building and so

1881
01:17:06,020 --> 01:17:09,770
this was designed by Victor Coast and

1882
01:17:08,360 --> 01:17:12,019
and maybe a Leavitt of a couple of my

1883
01:17:09,770 --> 01:17:13,790
PhD students so it's based on the wrist

1884
01:17:12,020 --> 01:17:16,640
five and so you also had a talk on the

1885
01:17:13,790 --> 01:17:19,280
wrist five yesterday and so the wrist

1886
01:17:16,640 --> 01:17:20,830
five has this particular and sanctum has

1887
01:17:19,280 --> 01:17:22,969
this particular software stack and

1888
01:17:20,830 --> 01:17:24,739
essentially what you see here is what

1889
01:17:22,969 --> 01:17:28,070
you trust is the hardware and what you

1890
01:17:24,739 --> 01:17:30,110
trust is the Enclave which is really the

1891
01:17:28,070 --> 01:17:31,759
code that corresponds to the the victim

1892
01:17:30,110 --> 01:17:34,330
code if you will you need to trust

1893
01:17:31,760 --> 01:17:38,989
yourself and then on the top side in a

1894
01:17:34,330 --> 01:17:40,610
risk five has a machine mode and this is

1895
01:17:38,989 --> 01:17:43,070
where the security monitor the trusted

1896
01:17:40,610 --> 01:17:44,750
part of the operating system

1897
01:17:43,070 --> 01:17:46,429
and so this is the equivalent of

1898
01:17:44,750 --> 01:17:48,019
microcode in SGX for those of you who

1899
01:17:46,429 --> 01:17:51,079
are familiar with it except that this

1900
01:17:48,019 --> 01:17:52,369
code is relatively small and also

1901
01:17:51,079 --> 01:17:54,349
written in high level see it's written

1902
01:17:52,369 --> 01:17:55,789
in c99 it's about five thousand lines of

1903
01:17:54,349 --> 01:17:57,260
code in our implementation so you can

1904
01:17:55,789 --> 01:18:01,400
actually look at it and you can vet it

1905
01:17:57,260 --> 01:18:03,139
you can audit it and the this things in

1906
01:18:01,400 --> 01:18:04,699
the middle are untrusted and we don't

1907
01:18:03,139 --> 01:18:05,750
need to say much about it I just say

1908
01:18:04,699 --> 01:18:07,098
that the measurement route is

1909
01:18:05,750 --> 01:18:09,469
essentially something that responds to

1910
01:18:07,099 --> 01:18:11,059
cryptographic attestation you have a

1911
01:18:09,469 --> 01:18:12,920
situation where you also have this

1912
01:18:11,059 --> 01:18:15,289
obviously the security monitor that I've

1913
01:18:12,920 --> 01:18:16,880
mentioned before and together the

1914
01:18:15,289 --> 01:18:19,429
trusted computing base corresponding to

1915
01:18:16,880 --> 01:18:22,849
the what's on the top and obviously the

1916
01:18:19,429 --> 01:18:25,159
Enclave code I give you your enclaves in

1917
01:18:22,849 --> 01:18:26,750
your security guarantees and all of this

1918
01:18:25,159 --> 01:18:30,320
is based on a particular threat model

1919
01:18:26,750 --> 01:18:31,610
that you've chosen and so this

1920
01:18:30,320 --> 01:18:33,079
particular processor we built you know

1921
01:18:31,610 --> 01:18:36,049
did not have hyper threading in it it's

1922
01:18:33,079 --> 01:18:37,969
a risk 5 rocket no speculation so the

1923
01:18:36,050 --> 01:18:40,130
number of micro actual micro

1924
01:18:37,969 --> 01:18:44,510
architectural side channels was was much

1925
01:18:40,130 --> 01:18:47,150
less and if you look at the isolation

1926
01:18:44,510 --> 01:18:49,010
that we have to do here in sanctum for

1927
01:18:47,150 --> 01:18:50,750
things like private tlbs and register

1928
01:18:49,010 --> 01:18:52,250
files they're private to you so you have

1929
01:18:50,750 --> 01:18:54,440
to flush them and so that's your

1930
01:18:52,250 --> 01:18:56,539
temporal isolation but then you do have

1931
01:18:54,440 --> 01:18:59,419
shared caches and shared tlbs

1932
01:18:56,539 --> 01:19:02,000
that you want to maintain state as you

1933
01:18:59,420 --> 01:19:03,530
come in and out of these enclaves

1934
01:19:02,000 --> 01:19:08,449
because otherwise the performance would

1935
01:19:03,530 --> 01:19:09,800
just go ahead where if you keep cleaning

1936
01:19:08,449 --> 01:19:12,619
up all of the intermediate computations

1937
01:19:09,800 --> 01:19:17,269
you've done and for that you need

1938
01:19:12,619 --> 01:19:18,710
spatial isolation and so I want to talk

1939
01:19:17,269 --> 01:19:20,210
a little bit about some of the

1940
01:19:18,710 --> 01:19:22,940
interesting things in sanctum that have

1941
01:19:20,210 --> 01:19:23,659
in this particular case fixed problems

1942
01:19:22,940 --> 01:19:26,150
in SGX

1943
01:19:23,659 --> 01:19:28,219
and so the API I should say for sanctum

1944
01:19:26,150 --> 01:19:31,369
it was certainly motivated by SGX and

1945
01:19:28,219 --> 01:19:33,769
that the terminology as well and so if

1946
01:19:31,369 --> 01:19:35,210
you look at the operating system being

1947
01:19:33,769 --> 01:19:36,590
untrusted it is doing a lot of

1948
01:19:35,210 --> 01:19:38,239
management for you it's managing the

1949
01:19:36,590 --> 01:19:39,619
page tables and there side-channel

1950
01:19:38,239 --> 01:19:42,049
attacks associated with these page

1951
01:19:39,619 --> 01:19:43,699
tables and knowing what pages are being

1952
01:19:42,050 --> 01:19:45,829
accessed you can imagine that that would

1953
01:19:43,699 --> 01:19:47,659
be a break right and in SGX

1954
01:19:45,829 --> 01:19:49,610
i would call it as a design flaw the

1955
01:19:47,659 --> 01:19:51,289
operating system is capable of the

1956
01:19:49,610 --> 01:19:54,018
malicious hypervisor is capable of

1957
01:19:51,289 --> 01:19:56,570
looking at page fault addresses and also

1958
01:19:54,019 --> 01:19:58,580
modifying the page tables to

1959
01:19:56,570 --> 01:20:00,410
increase the number of page faults that

1960
01:19:58,580 --> 01:20:02,059
happen so essentially you're in a

1961
01:20:00,410 --> 01:20:04,960
situation where one of the older attacks

1962
01:20:02,060 --> 01:20:08,300
carried out by Microsoft on SGX

1963
01:20:04,960 --> 01:20:10,280
was something that said well if I'm

1964
01:20:08,300 --> 01:20:12,440
trying to protect this rubik's cube and

1965
01:20:10,280 --> 01:20:15,710
this is my secret data that's associated

1966
01:20:12,440 --> 01:20:17,000
with a the Enclave and i'm trying to

1967
01:20:15,710 --> 01:20:19,670
compare this with a whole bunch of other

1968
01:20:17,000 --> 01:20:21,290
public databases and all of this is

1969
01:20:19,670 --> 01:20:25,670
going to happen inside of an enclave

1970
01:20:21,290 --> 01:20:28,090
then this page fault bug a design flaw

1971
01:20:25,670 --> 01:20:31,010
was essentially something that allowed

1972
01:20:28,090 --> 01:20:33,080
the attackers to discover what you see

1973
01:20:31,010 --> 01:20:35,660
down at the bottom which is every once

1974
01:20:33,080 --> 01:20:37,460
in a while you see a pixel or the value

1975
01:20:35,660 --> 01:20:39,470
of a pixel associated with this

1976
01:20:37,460 --> 01:20:42,500
particular cube which is really a coarse

1977
01:20:39,470 --> 01:20:44,060
rendition of this of this cube and it

1978
01:20:42,500 --> 01:20:45,830
comes because you're not seeing every

1979
01:20:44,060 --> 01:20:47,840
memory address but you're seeing every

1980
01:20:45,830 --> 01:20:49,220
memory address at the page level when

1981
01:20:47,840 --> 01:20:50,780
you move from one page to another page

1982
01:20:49,220 --> 01:20:52,250
so you have to be careful here when you

1983
01:20:50,780 --> 01:20:54,830
have an untrusted operating system

1984
01:20:52,250 --> 01:20:57,170
associated with what you give it what

1985
01:20:54,830 --> 01:21:00,440
privilege do you give it and if you I

1986
01:20:57,170 --> 01:21:01,880
you have to ensure that that privilege

1987
01:21:00,440 --> 01:21:04,250
that it has doesn't allow you to do

1988
01:21:01,880 --> 01:21:08,330
these kinds of things and so in in in

1989
01:21:04,250 --> 01:21:10,460
sanctum Ivy changed the the page table

1990
01:21:08,330 --> 01:21:12,730
management to be something where you had

1991
01:21:10,460 --> 01:21:14,870
two sets of page tables associated with

1992
01:21:12,730 --> 01:21:16,490
had the Enclave page tables that

1993
01:21:14,870 --> 01:21:18,470
responded to Enclave memory that was

1994
01:21:16,490 --> 01:21:20,179
belong to the to the Enclave and then

1995
01:21:18,470 --> 01:21:21,740
the page table is corresponding to

1996
01:21:20,180 --> 01:21:23,570
shared memory that were controlled by

1997
01:21:21,740 --> 01:21:25,099
the operating system and this required a

1998
01:21:23,570 --> 01:21:26,599
hardware change I'm not gonna be able to

1999
01:21:25,100 --> 01:21:28,220
describe to you the specifics of the

2000
01:21:26,600 --> 01:21:30,020
hardware change but you can think of it

2001
01:21:28,220 --> 01:21:32,390
as dual mode page tables and some

2002
01:21:30,020 --> 01:21:34,880
multiplexers in the logic that allow you

2003
01:21:32,390 --> 01:21:37,580
to decide you know which way to go and

2004
01:21:34,880 --> 01:21:40,430
so and then that the one other example

2005
01:21:37,580 --> 01:21:42,080
I've mentioned of course wanting to how

2006
01:21:40,430 --> 01:21:45,410
protecting against cache timing attacks

2007
01:21:42,080 --> 01:21:48,860
in sanctum was simply to take a shared

2008
01:21:45,410 --> 01:21:51,230
cache and break up the shared cache into

2009
01:21:48,860 --> 01:21:52,969
partitions that are this is a spatial

2010
01:21:51,230 --> 01:21:54,919
partitioning and so you have a situation

2011
01:21:52,970 --> 01:21:56,330
where the Enclave and the OS are

2012
01:21:54,920 --> 01:21:59,300
completely isolated in the memory

2013
01:21:56,330 --> 01:22:02,990
hierarchy where you don't have a

2014
01:21:59,300 --> 01:22:04,580
situation where they're sharing cache

2015
01:22:02,990 --> 01:22:06,050
sets or cache ways or what-have-you

2016
01:22:04,580 --> 01:22:08,690
there's a couple of different ways you

2017
01:22:06,050 --> 01:22:09,949
could do partitioning and we chose set

2018
01:22:08,690 --> 01:22:12,530
partitioning and sank

2019
01:22:09,949 --> 01:22:15,489
and so what does this mean exactly well

2020
01:22:12,530 --> 01:22:17,480
you could use page coloring that that

2021
01:22:15,489 --> 01:22:19,370
perhaps many of you are familiar with

2022
01:22:17,480 --> 01:22:20,269
and the page coloring is based on the

2023
01:22:19,370 --> 01:22:23,210
fact that there's an intersection

2024
01:22:20,270 --> 01:22:24,830
between the cash set index bits and the

2025
01:22:23,210 --> 01:22:27,560
physical page number there corresponds

2026
01:22:24,830 --> 01:22:29,110
to this dram region and these dram

2027
01:22:27,560 --> 01:22:31,489
regions are essentially going to be

2028
01:22:29,110 --> 01:22:33,739
regions in memory that are going to be

2029
01:22:31,489 --> 01:22:36,290
isolated in the shared cache as well and

2030
01:22:33,739 --> 01:22:37,549
so pictorially speaking you might have

2031
01:22:36,290 --> 01:22:39,590
something like that where you see on the

2032
01:22:37,550 --> 01:22:41,000
right where you say you have the shared

2033
01:22:39,590 --> 01:22:43,340
cache on the right and you have colored

2034
01:22:41,000 --> 01:22:45,020
these things just like you did with page

2035
01:22:43,340 --> 01:22:46,850
colors and each of these different

2036
01:22:45,020 --> 01:22:48,469
processes has different colors and

2037
01:22:46,850 --> 01:22:50,390
different cache sets and then what

2038
01:22:48,469 --> 01:22:53,210
happens if you just do this in kind of a

2039
01:22:50,390 --> 01:22:55,370
naive way is that you now break up the

2040
01:22:53,210 --> 01:22:56,840
DRAM into different regions as well

2041
01:22:55,370 --> 01:22:58,580
corresponding to the different colors

2042
01:22:56,840 --> 01:23:00,949
and this is a little bit annoying from a

2043
01:22:58,580 --> 01:23:03,260
performance standpoint because you have

2044
01:23:00,949 --> 01:23:05,449
a situation where these colors are are

2045
01:23:03,260 --> 01:23:07,400
spread apart and and so then again a

2046
01:23:05,449 --> 01:23:09,169
little bit of bit shifting in the

2047
01:23:07,400 --> 01:23:10,820
hardware and so that would be a change

2048
01:23:09,170 --> 01:23:12,290
in the hardware is going to give you the

2049
01:23:10,820 --> 01:23:14,630
picture that you see here where you have

2050
01:23:12,290 --> 01:23:16,880
contiguous DRAM regions as well as as

2051
01:23:14,630 --> 01:23:19,400
obviously you have the contiguous shared

2052
01:23:16,880 --> 01:23:20,780
cache regions those are all sets anyway

2053
01:23:19,400 --> 01:23:22,639
and so these are the kinds of

2054
01:23:20,780 --> 01:23:24,019
performance tricks that you have to play

2055
01:23:22,640 --> 01:23:25,820
in order to sort of get back the

2056
01:23:24,020 --> 01:23:28,550
performance when you have to do

2057
01:23:25,820 --> 01:23:31,250
isolation in a stronger way over and

2058
01:23:28,550 --> 01:23:33,530
beyond conventional processors so a few

2059
01:23:31,250 --> 01:23:35,030
other changes in sanctum I just to give

2060
01:23:33,530 --> 01:23:37,099
you a sense of the kind of invasive

2061
01:23:35,030 --> 01:23:39,259
changes that are made in sanctum this is

2062
01:23:37,100 --> 01:23:40,699
a rocket core chip and the colors that

2063
01:23:39,260 --> 01:23:43,670
you see are the modifications that were

2064
01:23:40,699 --> 01:23:45,320
made in in sanctum and so most of the

2065
01:23:43,670 --> 01:23:47,630
colors that you see are Flushing State

2066
01:23:45,320 --> 01:23:49,610
so you have these storage of state that

2067
01:23:47,630 --> 01:23:51,050
and you're essentially clobbering the

2068
01:23:49,610 --> 01:23:52,280
state and then you see a little bit of

2069
01:23:51,050 --> 01:23:53,630
blue in the middle there those

2070
01:23:52,280 --> 01:23:55,370
correspond to these dual mode page

2071
01:23:53,630 --> 01:23:56,900
tables and so the whole thing was about

2072
01:23:55,370 --> 01:23:58,760
you know two percent different in terms

2073
01:23:56,900 --> 01:24:00,710
of area so you can see that this is not

2074
01:23:58,760 --> 01:24:02,900
a dramatic change to go from us process

2075
01:24:00,710 --> 01:24:05,449
abstraction to an enclave abstraction

2076
01:24:02,900 --> 01:24:08,000
alright so this this is really what we

2077
01:24:05,449 --> 01:24:09,910
did here a couple of years ago I want to

2078
01:24:08,000 --> 01:24:13,730
briefly mention some work that I did

2079
01:24:09,910 --> 01:24:15,949
with collaborators and I'm not a formal

2080
01:24:13,730 --> 01:24:17,629
verification expert but you know I did

2081
01:24:15,949 --> 01:24:20,178
stay in a Holiday Inn Express last night

2082
01:24:17,630 --> 01:24:21,920
or more seriously you know while I

2083
01:24:20,179 --> 01:24:23,480
stayed here last night and I'm not any

2084
01:24:21,920 --> 01:24:25,700
smarter but but I wore

2085
01:24:23,480 --> 01:24:29,209
with people like Santurce jie and and

2086
01:24:25,700 --> 01:24:31,070
more recently Adams polyp on thinking

2087
01:24:29,210 --> 01:24:32,930
about formally verifying these

2088
01:24:31,070 --> 01:24:34,580
properties of enclaves so really briefly

2089
01:24:32,930 --> 01:24:36,770
only because we're in a formal

2090
01:24:34,580 --> 01:24:38,750
verification session right

2091
01:24:36,770 --> 01:24:41,060
I noticed the title you know a few days

2092
01:24:38,750 --> 01:24:44,000
ago and so I want to talk to you a

2093
01:24:41,060 --> 01:24:46,370
little bit about the adversary I know

2094
01:24:44,000 --> 01:24:48,710
that we can formally modify sari model

2095
01:24:46,370 --> 01:24:50,780
the adversary we can formally model the

2096
01:24:48,710 --> 01:24:55,070
threat model based on observation

2097
01:24:50,780 --> 01:24:57,170
functions and tamper functions and you

2098
01:24:55,070 --> 01:24:58,730
have the notions of enclaves and really

2099
01:24:57,170 --> 01:25:00,710
the thing I want you to take away from

2100
01:24:58,730 --> 01:25:02,690
this is that there's three aspects to

2101
01:25:00,710 --> 01:25:04,580
enclaves that need to be put together to

2102
01:25:02,690 --> 01:25:06,589
get essentially this sort of secure

2103
01:25:04,580 --> 01:25:08,840
remote execution or secure execution

2104
01:25:06,590 --> 01:25:10,190
capability the isolation goal which is

2105
01:25:08,840 --> 01:25:12,260
measurement integrity and

2106
01:25:10,190 --> 01:25:13,639
confidentiality and there's invariants

2107
01:25:12,260 --> 01:25:16,310
associated with each of these things and

2108
01:25:13,640 --> 01:25:18,290
the work that my group did with Sanjiv

2109
01:25:16,310 --> 01:25:21,350
was essentially using model checking and

2110
01:25:18,290 --> 01:25:23,180
SMT solvers to take an abstract

2111
01:25:21,350 --> 01:25:25,220
specification of sanctum that included

2112
01:25:23,180 --> 01:25:27,380
both the security monitor as well as the

2113
01:25:25,220 --> 01:25:28,910
hardware and essentially there's this

2114
01:25:27,380 --> 01:25:30,980
thing called the trusted abstract

2115
01:25:28,910 --> 01:25:32,800
platform on the tab and we wrote

2116
01:25:30,980 --> 01:25:35,509
invariance for these things and

2117
01:25:32,800 --> 01:25:37,790
essentially verified these invariants

2118
01:25:35,510 --> 01:25:38,660
using these as empty solver and you know

2119
01:25:37,790 --> 01:25:39,590
there were a few things there's

2120
01:25:38,660 --> 01:25:43,010
certainly a few bugs that were

2121
01:25:39,590 --> 01:25:45,620
discovered in our specification that

2122
01:25:43,010 --> 01:25:47,090
occurs wanted to violating these

2123
01:25:45,620 --> 01:25:50,059
invariants then we went and fixed them

2124
01:25:47,090 --> 01:25:52,190
and so I mentioned the threat model and

2125
01:25:50,060 --> 01:25:54,950
it's important to keep that in mind

2126
01:25:52,190 --> 01:25:56,780
because if you look at the observation

2127
01:25:54,950 --> 01:25:58,880
function in the Tampa function that's

2128
01:25:56,780 --> 01:26:00,800
obviously an important consideration in

2129
01:25:58,880 --> 01:26:03,980
whether you have security or not perhaps

2130
01:26:00,800 --> 01:26:06,350
the most important consideration and scx

2131
01:26:03,980 --> 01:26:08,150
is in fact secured under a fairly

2132
01:26:06,350 --> 01:26:10,580
limited observation function where you

2133
01:26:08,150 --> 01:26:12,739
ignore sight channels and you ignore

2134
01:26:10,580 --> 01:26:14,960
well essentially shared caches and so on

2135
01:26:12,739 --> 01:26:17,059
and so forth and sanctum sort of raises

2136
01:26:14,960 --> 01:26:18,980
the bar a little bit it at least from a

2137
01:26:17,060 --> 01:26:22,340
standpoint of the threat model and so

2138
01:26:18,980 --> 01:26:24,530
you can show a refinement proof that

2139
01:26:22,340 --> 01:26:26,630
essentially says that under this

2140
01:26:24,530 --> 01:26:29,509
particular threat model Chris wanting to

2141
01:26:26,630 --> 01:26:32,450
share caches and some limited number of

2142
01:26:29,510 --> 01:26:34,070
side channel attacks that you want you

2143
01:26:32,450 --> 01:26:35,900
won't have brakes and in sanctum I

2144
01:26:34,070 --> 01:26:37,120
mentioned that it does not include

2145
01:26:35,900 --> 01:26:40,330
speculative access

2146
01:26:37,120 --> 01:26:40,900
so if you had ways of like a speculative

2147
01:26:40,330 --> 01:26:43,330
execution

2148
01:26:40,900 --> 01:26:45,519
excuse me speculative the executing code

2149
01:26:43,330 --> 01:26:47,019
then the threat model would have to be

2150
01:26:45,520 --> 01:26:51,280
different and we won't be able to do

2151
01:26:47,020 --> 01:26:54,180
that proof for for sanctum right so the

2152
01:26:51,280 --> 01:26:56,110
book sanctum it's running on a honor

2153
01:26:54,180 --> 01:26:58,570
essentially it's a risk 5 processor

2154
01:26:56,110 --> 01:26:59,799
running on an Amazon FPGA and as I

2155
01:26:58,570 --> 01:27:01,420
mentioned there's an ongoing formal

2156
01:26:59,800 --> 01:27:03,280
verification effort but I want to say

2157
01:27:01,420 --> 01:27:04,900
that this is an academic and a

2158
01:27:03,280 --> 01:27:07,750
lightweight processor it's a

2159
01:27:04,900 --> 01:27:09,719
microcontroller scale processor and one

2160
01:27:07,750 --> 01:27:11,680
of the things that room that is

2161
01:27:09,720 --> 01:27:13,660
something that we started thinking about

2162
01:27:11,680 --> 01:27:16,110
was especially after spectra and Melton

2163
01:27:13,660 --> 01:27:18,280
came out so 2018 was really the year of

2164
01:27:16,110 --> 01:27:18,969
spectra and meltdown and processors

2165
01:27:18,280 --> 01:27:21,219
getting broken

2166
01:27:18,970 --> 01:27:23,500
thanks to Daniel Daniel wall and and

2167
01:27:21,220 --> 01:27:24,730
their collaborators is you know what

2168
01:27:23,500 --> 01:27:26,230
would happen you know what would happen

2169
01:27:24,730 --> 01:27:29,620
to all of the things that I've told you

2170
01:27:26,230 --> 01:27:31,959
when you look at a bigger processors

2171
01:27:29,620 --> 01:27:34,000
more heavyweight processors including

2172
01:27:31,960 --> 01:27:36,970
things that have speculation in them and

2173
01:27:34,000 --> 01:27:38,260
so so we did some work on that and from

2174
01:27:36,970 --> 01:27:41,620
the few minutes that I have left I'd

2175
01:27:38,260 --> 01:27:45,820
like to describe that work and this is

2176
01:27:41,620 --> 01:27:47,980
done by my group and professor Arvind

2177
01:27:45,820 --> 01:27:51,849
students who's a close colleague of mine

2178
01:27:47,980 --> 01:27:53,889
and Kumar is here in the audience and so

2179
01:27:51,850 --> 01:27:55,210
you can talk to him as well and you can

2180
01:27:53,890 --> 01:27:56,550
see you know we have a cool name for it

2181
01:27:55,210 --> 01:27:58,330
or at least I think it's cool

2182
01:27:56,550 --> 01:28:01,510
corresponding to this particular

2183
01:27:58,330 --> 01:28:03,519
processor and the reason for that is we

2184
01:28:01,510 --> 01:28:06,850
are going to make an argument that this

2185
01:28:03,520 --> 01:28:09,340
processor is defense against Specter and

2186
01:28:06,850 --> 01:28:11,170
and melt on top of tax and the question

2187
01:28:09,340 --> 01:28:13,690
is you know we take what I've told you

2188
01:28:11,170 --> 01:28:16,060
right now what changes when you go to a

2189
01:28:13,690 --> 01:28:17,830
much more sophisticated processor right

2190
01:28:16,060 --> 01:28:20,200
and it is in fact much more

2191
01:28:17,830 --> 01:28:21,880
sophisticated ok so now I'm calling

2192
01:28:20,200 --> 01:28:23,889
sanctum a toy processor not just an

2193
01:28:21,880 --> 01:28:25,480
academic processor I didn't say that a

2194
01:28:23,890 --> 01:28:28,110
year ago but if you look at the

2195
01:28:25,480 --> 01:28:31,089
complexity of of superscalar

2196
01:28:28,110 --> 01:28:35,110
out-of-order execution it's way more

2197
01:28:31,090 --> 01:28:37,330
complicated than in order processing

2198
01:28:35,110 --> 01:28:39,490
namely the rocket ship or and and that's

2199
01:28:37,330 --> 01:28:41,620
what Sanctum is based on so think about

2200
01:28:39,490 --> 01:28:43,059
your computer architecture class your

2201
01:28:41,620 --> 01:28:44,860
graduate class if you've taken it and

2202
01:28:43,060 --> 01:28:46,780
sort of the second half of the class and

2203
01:28:44,860 --> 01:28:48,460
all of the techniques that were there in

2204
01:28:46,780 --> 01:28:50,320
that class of speculation and

2205
01:28:48,460 --> 01:28:52,030
scoreboarding and so on and there

2206
01:28:50,320 --> 01:28:54,280
in here in this processor that Professor

2207
01:28:52,030 --> 01:28:57,190
Arvind and students built which is

2208
01:28:54,280 --> 01:28:59,259
called the risky ol processor and it

2209
01:28:57,190 --> 01:29:01,928
again in this processor that we used is

2210
01:28:59,260 --> 01:29:05,230
a baseline but it boots Linux and runs

2211
01:29:01,929 --> 01:29:07,449
on an Amazon FPGA and that the key point

2212
01:29:05,230 --> 01:29:09,489
I want to make here is that this

2213
01:29:07,449 --> 01:29:11,049
processor is way more performant right

2214
01:29:09,489 --> 01:29:14,199
so if you don't speculate in this

2215
01:29:11,050 --> 01:29:16,989
processor it's 3 X less a performance

2216
01:29:14,199 --> 01:29:18,940
right and as much as 5 X less on a

2217
01:29:16,989 --> 01:29:20,949
really a wide variety of benchmarks so

2218
01:29:18,940 --> 01:29:22,928
just turning off speculation isn't

2219
01:29:20,949 --> 01:29:24,339
viable from a performance standpoint in

2220
01:29:22,929 --> 01:29:26,110
order to essentially say that you have

2221
01:29:24,340 --> 01:29:28,719
security all right so that's really what

2222
01:29:26,110 --> 01:29:29,380
I want to show here and that it's

2223
01:29:28,719 --> 01:29:30,849
complicated

2224
01:29:29,380 --> 01:29:32,619
the processor is complicated that'll

2225
01:29:30,849 --> 01:29:34,869
hope heck of a lot more side channels we

2226
01:29:32,619 --> 01:29:36,519
are discovering side channels that

2227
01:29:34,869 --> 01:29:38,710
really haven't been published in this

2228
01:29:36,520 --> 01:29:41,020
processor because we have things like

2229
01:29:38,710 --> 01:29:44,219
non-blocking caches and you don't just

2230
01:29:41,020 --> 01:29:46,989
have a shared cache you have many

2231
01:29:44,219 --> 01:29:49,030
hardware modules before the cache

2232
01:29:46,989 --> 01:29:50,888
corresponding to a crossbar there's an

2233
01:29:49,030 --> 01:29:52,449
arbitration mechanism associated with

2234
01:29:50,889 --> 01:29:54,489
this crossbar and if that arbitration

2235
01:29:52,449 --> 01:29:57,519
mechanism is unfair then there's a side

2236
01:29:54,489 --> 01:30:00,070
channel associated with it right so the

2237
01:29:57,520 --> 01:30:01,630
students here come on others have sort

2238
01:30:00,070 --> 01:30:02,949
of walked through that entire state the

2239
01:30:01,630 --> 01:30:04,179
wonderful thing about this is that we

2240
01:30:02,949 --> 01:30:06,190
have the hardware right in front of us

2241
01:30:04,179 --> 01:30:07,900
it's open source we can look at the

2242
01:30:06,190 --> 01:30:09,699
hardware is written by a grad student we

2243
01:30:07,900 --> 01:30:11,230
can look at every state in the processor

2244
01:30:09,699 --> 01:30:14,019
and figure out if this is a side channel

2245
01:30:11,230 --> 01:30:15,428
here or not right so and in fact as I

2246
01:30:14,020 --> 01:30:18,040
said we've discovered some side channels

2247
01:30:15,429 --> 01:30:20,230
corresponding to the unfairness it's not

2248
01:30:18,040 --> 01:30:22,630
just cash side channels and so really

2249
01:30:20,230 --> 01:30:24,218
quickly you can do the same philosophy

2250
01:30:22,630 --> 01:30:25,840
that I've talked about here which is you

2251
01:30:24,219 --> 01:30:27,400
can flush micro architectural state

2252
01:30:25,840 --> 01:30:30,460
every time you go inside of the Enclave

2253
01:30:27,400 --> 01:30:32,980
and come out of the Enclave and if you

2254
01:30:30,460 --> 01:30:34,840
do that and you run a benchmarks you

2255
01:30:32,980 --> 01:30:37,030
know to completion every time you do a

2256
01:30:34,840 --> 01:30:38,829
system called you have to essentially do

2257
01:30:37,030 --> 01:30:40,690
the slashing of the state the overhead

2258
01:30:38,829 --> 01:30:42,699
performance overhead is 5% so this is a

2259
01:30:40,690 --> 01:30:44,230
overhead associated with the Enclave

2260
01:30:42,699 --> 01:30:45,669
right because you're going inside and

2261
01:30:44,230 --> 01:30:47,940
outside of it if you didn't care about

2262
01:30:45,670 --> 01:30:50,110
security you wouldn't have this overhead

2263
01:30:47,940 --> 01:30:51,879
the last of the cache you know as a

2264
01:30:50,110 --> 01:30:53,710
problem it's a serious side channel if

2265
01:30:51,880 --> 01:30:55,300
you have to do spatial isolation for

2266
01:30:53,710 --> 01:30:57,130
that this unfortunately is something

2267
01:30:55,300 --> 01:30:59,349
that affects protected programs as well

2268
01:30:57,130 --> 01:31:01,780
as unprotected programs because you have

2269
01:30:59,349 --> 01:31:03,460
to share this cache in in this more

2270
01:31:01,780 --> 01:31:04,179
constrained play right so there's an

2271
01:31:03,460 --> 01:31:05,770
overhead associate

2272
01:31:04,180 --> 01:31:07,240
but that and you could imagine that you

2273
01:31:05,770 --> 01:31:09,700
could try and shrink that with smarter

2274
01:31:07,240 --> 01:31:13,960
partitioning schemes we're going to look

2275
01:31:09,700 --> 01:31:15,730
into that when we have time and every

2276
01:31:13,960 --> 01:31:17,260
time you're gonna copy state from

2277
01:31:15,730 --> 01:31:19,209
outside of the Enclave the inside of the

2278
01:31:17,260 --> 01:31:20,710
Enclave even though it's it's obviously

2279
01:31:19,210 --> 01:31:22,150
public state because it comes from

2280
01:31:20,710 --> 01:31:23,710
outside of the Enclave you have to be

2281
01:31:22,150 --> 01:31:25,420
super careful and the conservative way

2282
01:31:23,710 --> 01:31:27,520
of doing this is to turn off speculation

2283
01:31:25,420 --> 01:31:29,380
right now if you turned off speculation

2284
01:31:27,520 --> 01:31:31,810
overall I mean that's untenable like I

2285
01:31:29,380 --> 01:31:33,100
described but only the times that you're

2286
01:31:31,810 --> 01:31:34,840
copying state if you turn off

2287
01:31:33,100 --> 01:31:36,430
speculation then the overhead is

2288
01:31:34,840 --> 01:31:38,530
essentially negligible because you're

2289
01:31:36,430 --> 01:31:40,060
only doing that it's a very small

2290
01:31:38,530 --> 01:31:41,769
fraction of the time but you have to

2291
01:31:40,060 --> 01:31:43,450
have all of these Hardware modifications

2292
01:31:41,770 --> 01:31:44,950
that I talked about with respect to the

2293
01:31:43,450 --> 01:31:47,170
flushing with respect to turning off

2294
01:31:44,950 --> 01:31:49,120
speculation video mode page tables all

2295
01:31:47,170 --> 01:31:51,820
of these things have to be built into

2296
01:31:49,120 --> 01:31:53,710
the processor and that part was done

2297
01:31:51,820 --> 01:31:56,230
right so this is what I said about the

2298
01:31:53,710 --> 01:31:57,610
negligible and so overall it's similar

2299
01:31:56,230 --> 01:31:59,139
to the picture that I showed you I don't

2300
01:31:57,610 --> 01:32:01,860
have a picture like that but it's about

2301
01:31:59,140 --> 01:32:03,790
two percent a difference in terms of

2302
01:32:01,860 --> 01:32:05,200
essentially what you have to have you

2303
01:32:03,790 --> 01:32:07,390
have to have multiplexers you have to

2304
01:32:05,200 --> 01:32:08,769
have reset signals and you have to make

2305
01:32:07,390 --> 01:32:10,930
a bunch of changes in the hardware and

2306
01:32:08,770 --> 01:32:12,640
so this has been done I should say that

2307
01:32:10,930 --> 01:32:13,660
that we don't have user Moore enclaves

2308
01:32:12,640 --> 01:32:15,160
running on mi6

2309
01:32:13,660 --> 01:32:16,960
you know the software is essentially the

2310
01:32:15,160 --> 01:32:18,490
sanctum software we've changed the

2311
01:32:16,960 --> 01:32:20,170
hardware but there's a lot of things to

2312
01:32:18,490 --> 01:32:21,519
a lot of work to be done in order to

2313
01:32:20,170 --> 01:32:23,680
actually get to this to the point where

2314
01:32:21,520 --> 01:32:25,420
we can hand it off to a Daniel or a wall

2315
01:32:23,680 --> 01:32:29,470
and ask him to break it but that's our

2316
01:32:25,420 --> 01:32:31,030
intent so what's left about a lot of

2317
01:32:29,470 --> 01:32:33,160
things left including implementation as

2318
01:32:31,030 --> 01:32:34,780
I said one of the things that is

2319
01:32:33,160 --> 01:32:36,820
associated with enclaves that's the

2320
01:32:34,780 --> 01:32:39,250
downside especially as the threat models

2321
01:32:36,820 --> 01:32:41,410
evolve is the fact that enclaves trade

2322
01:32:39,250 --> 01:32:43,390
expressivity for security so we can't

2323
01:32:41,410 --> 01:32:45,070
arbitrarily just make system calls they

2324
01:32:43,390 --> 01:32:47,320
have to be proxy there's a collaboration

2325
01:32:45,070 --> 01:32:49,179
for alcohol involved anytime you have

2326
01:32:47,320 --> 01:32:50,889
adaptivity you have dynamic memory

2327
01:32:49,180 --> 01:32:52,930
allocation you're interacting with the

2328
01:32:50,890 --> 01:32:55,330
outside you have be super careful right

2329
01:32:52,930 --> 01:32:57,340
so these issues associated with that and

2330
01:32:55,330 --> 01:33:00,610
in general I think you know crypto could

2331
01:32:57,340 --> 01:33:03,010
be useful in the context of adaptivity

2332
01:33:00,610 --> 01:33:04,900
and provable security but I'm talking

2333
01:33:03,010 --> 01:33:06,850
about micro architectural optimizations

2334
01:33:04,900 --> 01:33:08,799
and doing things adaptively in hardware

2335
01:33:06,850 --> 01:33:12,640
to get performance or to get energy and

2336
01:33:08,800 --> 01:33:14,370
one example is is demand paging so if

2337
01:33:12,640 --> 01:33:16,240
you want to do demand paging securely

2338
01:33:14,370 --> 01:33:17,370
taking to account all of these

2339
01:33:16,240 --> 01:33:19,410
side-channel attacks

2340
01:33:17,370 --> 01:33:20,550
you'd essentially need in my mind the

2341
01:33:19,410 --> 01:33:23,190
only way I know how to do this is

2342
01:33:20,550 --> 01:33:25,320
page-level Oh RAM and integrity

2343
01:33:23,190 --> 01:33:26,940
verification and encryption in order to

2344
01:33:25,320 --> 01:33:28,440
get you know essentially provable

2345
01:33:26,940 --> 01:33:30,509
security when you want to do is secure

2346
01:33:28,440 --> 01:33:33,030
demand paging so there's other examples

2347
01:33:30,510 --> 01:33:35,310
but I want to leave you with that and so

2348
01:33:33,030 --> 01:33:38,250
let me just stop thanking all the people

2349
01:33:35,310 --> 01:33:39,780
who contributed to this to this talk and

2350
01:33:38,250 --> 01:33:40,710
this work and thank you for your

2351
01:33:39,780 --> 01:33:44,289
attention

2352
01:33:40,710 --> 01:33:44,289
[Applause]

2353
01:33:47,240 --> 01:33:51,630
that's great thank you very much any

2354
01:33:49,680 --> 01:33:54,150
quick questions since we're running

2355
01:33:51,630 --> 01:33:58,590
slightly behind schedule so please make

2356
01:33:54,150 --> 01:34:01,070
your questions short at this point I had

2357
01:33:58,590 --> 01:34:04,530
one quick question on the speculation

2358
01:34:01,070 --> 01:34:06,509
and turning it off and turning it on in

2359
01:34:04,530 --> 01:34:10,769
order in order to do those copying

2360
01:34:06,510 --> 01:34:12,600
operations question was did you notice

2361
01:34:10,770 --> 01:34:18,210
any performance degradation as a result

2362
01:34:12,600 --> 01:34:21,840
of this in place now so we actually

2363
01:34:18,210 --> 01:34:24,770
haven't done that experiment to the

2364
01:34:21,840 --> 01:34:27,150
point where I can give you a number and

2365
01:34:24,770 --> 01:34:29,340
pretty much I left it at a qualitative

2366
01:34:27,150 --> 01:34:31,650
level where I mean if you turn that off

2367
01:34:29,340 --> 01:34:34,470
and for the whole time you know it's

2368
01:34:31,650 --> 01:34:36,690
horrible as I mentioned to you I the

2369
01:34:34,470 --> 01:34:39,090
copy operation it's it's a function of

2370
01:34:36,690 --> 01:34:41,040
the ratio of the of the times that

2371
01:34:39,090 --> 01:34:44,670
you're turning this off so so you can

2372
01:34:41,040 --> 01:34:49,019
think of it as 3x overhead for 1% of the

2373
01:34:44,670 --> 01:34:50,490
time or 0.1% of the time and it depends

2374
01:34:49,020 --> 01:34:52,560
on system calls it depends on how many

2375
01:34:50,490 --> 01:34:57,120
times you're doing this in a batch style

2376
01:34:52,560 --> 01:35:01,050
computation I you do the copy once so in

2377
01:34:57,120 --> 01:35:06,269
that sense it's negligible okay thank

2378
01:35:01,050 --> 01:35:09,860
you it's more it's more often okay thank

2379
01:35:06,270 --> 01:35:09,860
you very much for that okay wonderful

2380
01:35:12,690 --> 01:35:17,110
quick announcement before you all go to

2381
01:35:14,770 --> 01:35:18,909
coffee we will be sending out a link for

2382
01:35:17,110 --> 01:35:21,848
a survey and we'd like to get your

2383
01:35:18,909 --> 01:35:23,739
feedback on RWC 2019 we'll be doing that

2384
01:35:21,849 --> 01:35:25,810
sometime after lunch today and we would

2385
01:35:23,739 --> 01:35:27,098
really value your input and in ideas for

2386
01:35:25,810 --> 01:35:31,510
improvement of the conference so look

2387
01:35:27,099 --> 01:35:34,380
out for that thank you oh yeah and give

2388
01:35:31,510 --> 01:35:34,380
us money Nigel says

