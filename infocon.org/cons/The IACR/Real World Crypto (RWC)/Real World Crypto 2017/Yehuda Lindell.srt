1
00:00:00,000 --> 00:00:03,780
<font color="#E5E5E5">okay good morning everyone I lost my</font>

2
00:00:02,129 --> 00:00:05,790
voice so<font color="#E5E5E5"> I hope they'll make it</font><font color="#CCCCCC"> through</font>

3
00:00:03,780 --> 00:00:07,439
the entire talk I'm going<font color="#E5E5E5"> to talk about</font>

4
00:00:05,790 --> 00:00:10,530
high throughput secure multi-party

5
00:00:07,440 --> 00:00:13,230
computation breaking the billion gate

6
00:00:10,530 --> 00:00:15,239
for a second barrier and this is based

7
00:00:13,230 --> 00:00:18,710
on a series of work with collaborators

8
00:00:15,240 --> 00:00:21,800
from bar-ilan<font color="#E5E5E5"> University and NEC Japan</font>

9
00:00:18,710 --> 00:00:24,660
secure multi-party computation enables a

10
00:00:21,800 --> 00:00:26,010
party to compete on private inputs

11
00:00:24,660 --> 00:00:28,590
without revealing anything but the

12
00:00:26,010 --> 00:00:32,579
output and there are a huge number of

13
00:00:28,590 --> 00:00:34,140
potential applications for for

14
00:00:32,579 --> 00:00:36,210
multi-party computation we can compare

15
00:00:34,140 --> 00:00:38,489
DNA samples without revealing that

16
00:00:36,210 --> 00:00:41,489
revealing them we can run learning or

17
00:00:38,489 --> 00:00:43,290
data mining algorithms on databases

18
00:00:41,489 --> 00:00:44,989
issue your databases for example

19
00:00:43,290 --> 00:00:49,379
different hospitals collaborating

20
00:00:44,989 --> 00:00:52,349
without revealing their private patient

21
00:00:49,379 --> 00:00:54,570
data we can run secure SQL we can

22
00:00:52,350 --> 00:00:57,239
predict protect credentials and

23
00:00:54,570 --> 00:00:59,149
biometrics by for example splitting keys

24
00:00:57,239 --> 00:01:00,959
or splitting templates and then

25
00:00:59,149 --> 00:01:02,609
competing on them without<font color="#E5E5E5"> bring them</font>

26
00:01:00,960 --> 00:01:04,439
together and therefore achieving higher

27
00:01:02,609 --> 00:01:07,020
protection there's a<font color="#E5E5E5"> lot of interest in</font>

28
00:01:04,438 --> 00:01:09,000
MPC lately and it's<font color="#CCCCCC"> even now being</font>

29
00:01:07,020 --> 00:01:10,740
deployed with a few startups working and

30
00:01:09,000 --> 00:01:13,650
interesting in from number of other

31
00:01:10,740 --> 00:01:15,810
<font color="#E5E5E5">places as well there are two standard</font>

32
00:01:13,650 --> 00:01:19,259
models that we've considered that have

33
00:01:15,810 --> 00:01:20,790
been considered for<font color="#E5E5E5"> security one is is</font>

34
00:01:19,259 --> 00:01:23,159
called the semi honest model and<font color="#E5E5E5"> this is</font>

35
00:01:20,790 --> 00:01:26,189
where the adverse<font color="#E5E5E5"> ER is rather benign it</font>

36
00:01:23,159 --> 00:01:28,350
runs the actual code that it's<font color="#CCCCCC"> supposed</font>

37
00:01:26,189 --> 00:01:32,008
<font color="#E5E5E5">to run but tries to learn more than it</font>

38
00:01:28,350 --> 00:01:33,990
<font color="#CCCCCC">should from the transcript these models</font>

39
00:01:32,009 --> 00:01:35,909
things like inadvertent leakage but also

40
00:01:33,990 --> 00:01:37,229
<font color="#CCCCCC">make sense in the example of different</font>

41
00:01:35,909 --> 00:01:39,090
hospitals the only reason why the

42
00:01:37,229 --> 00:01:40,530
<font color="#E5E5E5">hospitals won't bring their data</font>

43
00:01:39,090 --> 00:01:42,689
together because I'm allowed to because

44
00:01:40,530 --> 00:01:43,979
of privacy law but they<font color="#E5E5E5"> don't really do</font>

45
00:01:42,689 --> 00:01:45,860
<font color="#E5E5E5">not suspicious of each other they're</font>

46
00:01:43,979 --> 00:01:48,060
actually going to try to actively cheat

47
00:01:45,860 --> 00:01:49,679
however in many other cases we want

48
00:01:48,060 --> 00:01:51,210
secured against malicious adversaries

49
00:01:49,680 --> 00:01:54,149
and this means that<font color="#E5E5E5"> even if an adversary</font>

50
00:01:51,210 --> 00:01:56,158
can run arbitrary malicious code they

51
00:01:54,149 --> 00:01:57,509
still can learn anything beyond what

52
00:01:56,159 --> 00:01:59,549
<font color="#E5E5E5">they're allowed to so this for example</font>

53
00:01:57,509 --> 00:02:01,530
<font color="#E5E5E5">in the case of protecting</font><font color="#CCCCCC"> Keys against</font>

54
00:01:59,549 --> 00:02:05,430
<font color="#E5E5E5">breaking we will generally want</font>

55
00:02:01,530 --> 00:02:07,259
malicious security now secure

56
00:02:05,430 --> 00:02:09,209
multi-party computation holds great

57
00:02:07,259 --> 00:02:11,000
promise it's been<font color="#CCCCCC"> studied since the late</font>

58
00:02:09,209 --> 00:02:13,230
<font color="#E5E5E5">80s and we've talked about applications</font>

59
00:02:11,000 --> 00:02:16,549
for decades

60
00:02:13,230 --> 00:02:19,170
and they<font color="#E5E5E5"> are now becoming more and more</font>

61
00:02:16,549 --> 00:02:20,909
important and more and more viable but

62
00:02:19,170 --> 00:02:22,589
the main<font color="#CCCCCC"> question is whether we're</font>

63
00:02:20,909 --> 00:02:24,690
actually whether we are actually<font color="#E5E5E5"> able to</font>

64
00:02:22,590 --> 00:02:28,500
<font color="#E5E5E5">fulfill that promise can we actually</font>

65
00:02:24,690 --> 00:02:31,500
achieve speeds for<font color="#CCCCCC"> npc that are relevant</font>

66
00:02:28,500 --> 00:02:33,000
for applications in practice there are

67
00:02:31,500 --> 00:02:34,170
some applications that we can<font color="#E5E5E5"> solve</font>

68
00:02:33,000 --> 00:02:36,569
today and<font color="#E5E5E5"> these are things that are</font>

69
00:02:34,170 --> 00:02:39,179
being done we can<font color="#CCCCCC"> do cryptographic</font>

70
00:02:36,569 --> 00:02:41,849
operations we can do by biometric

71
00:02:39,180 --> 00:02:44,430
matching we can do DNA matching<font color="#E5E5E5"> and</font>

72
00:02:41,849 --> 00:02:48,540
things like that<font color="#E5E5E5"> but meet scale and</font>

73
00:02:44,430 --> 00:02:51,329
medium to large scale npc on large data

74
00:02:48,540 --> 00:02:53,819
with very<font color="#E5E5E5"> very large</font><font color="#CCCCCC"> circuit seems to be</font>

75
00:02:51,329 --> 00:02:55,170
<font color="#E5E5E5">way beyond reach especially when we want</font>

76
00:02:53,819 --> 00:02:56,910
to consider malicious adversary's

77
00:02:55,170 --> 00:02:59,309
because the initiative a serial model is

78
00:02:56,910 --> 00:03:01,440
one that is much much much harder to

79
00:02:59,310 --> 00:03:04,379
achieve and this is the<font color="#CCCCCC"> question that we</font>

80
00:03:01,440 --> 00:03:06,269
can we're trying<font color="#E5E5E5"> to solve in this work</font>

81
00:03:04,379 --> 00:03:09,060
so we consider a very specific setting

82
00:03:06,269 --> 00:03:10,410
which is secure<font color="#E5E5E5"> three party computation</font>

83
00:03:09,060 --> 00:03:13,379
with an honest majority meaning that

84
00:03:10,410 --> 00:03:17,010
most one party is corrupted and we want

85
00:03:13,379 --> 00:03:18,540
<font color="#CCCCCC">to achieve security in this setting it's</font>

86
00:03:17,010 --> 00:03:20,069
important<font color="#E5E5E5"> to distinguish between two</font>

87
00:03:18,540 --> 00:03:23,280
different goals and two different

88
00:03:20,069 --> 00:03:26,819
<font color="#E5E5E5">efficiency measures for these types of</font>

89
00:03:23,280 --> 00:03:28,290
tasks one is to consider latency which

90
00:03:26,819 --> 00:03:30,388
is how much time it takes from<font color="#CCCCCC"> the</font>

91
00:03:28,290 --> 00:03:32,280
beginning to the end and the<font color="#CCCCCC"> other</font><font color="#E5E5E5"> is</font>

92
00:03:30,389 --> 00:03:34,650
<font color="#E5E5E5">the third food how many computations can</font>

93
00:03:32,280 --> 00:03:36,690
we carry out per second and depending on

94
00:03:34,650 --> 00:03:39,810
the application you will either want low

95
00:03:36,690 --> 00:03:43,290
latency or high throughput sometimes you

96
00:03:39,810 --> 00:03:44,669
may have constraints on both<font color="#CCCCCC"> of them so</font>

97
00:03:43,290 --> 00:03:46,620
if you're looking<font color="#CCCCCC"> for low latency</font>

98
00:03:44,669 --> 00:03:47,819
protocols the garbled so-called garbled

99
00:03:46,620 --> 00:03:50,340
circuit approaches the approach that

100
00:03:47,819 --> 00:03:54,179
typically<font color="#E5E5E5"> is taken has a constant a</font>

101
00:03:50,340 --> 00:03:56,370
number of rounds and so<font color="#E5E5E5"> even on slow</font>

102
00:03:54,180 --> 00:03:58,859
network that can be very very efficient

103
00:03:56,370 --> 00:04:00,720
however the band which is relatively

104
00:03:58,859 --> 00:04:02,700
high which means it's not<font color="#E5E5E5"> so good for</font>

105
00:04:00,720 --> 00:04:05,160
getting<font color="#E5E5E5"> high throughput on the other</font>

106
00:04:02,700 --> 00:04:06,720
<font color="#E5E5E5">hand if you want I throughput then the</font>

107
00:04:05,160 --> 00:04:09,410
so-called secret sharing approach is

108
00:04:06,720 --> 00:04:12,299
better it has fast simpler operations

109
00:04:09,410 --> 00:04:14,519
much lower bandwidth but you need a

110
00:04:12,299 --> 00:04:16,228
<font color="#E5E5E5">number of rounds of communication</font><font color="#CCCCCC"> that</font>

111
00:04:14,519 --> 00:04:19,079
depends<font color="#E5E5E5"> on the depth of the circuit been</font>

112
00:04:16,228 --> 00:04:21,298
computed and so on a slow<font color="#CCCCCC"> Network this</font>

113
00:04:19,079 --> 00:04:24,330
will never<font color="#E5E5E5"> be good but on fast networks</font>

114
00:04:21,298 --> 00:04:26,039
these sort of computations computations

115
00:04:24,330 --> 00:04:26,969
can also actually have relatively low

116
00:04:26,039 --> 00:04:29,070
latency

117
00:04:26,970 --> 00:04:31,530
and can perform very very well so we're

118
00:04:29,070 --> 00:04:33,120
going<font color="#E5E5E5"> to focus on the high-throughput</font>

119
00:04:31,530 --> 00:04:36,030
setting because they're<font color="#CCCCCC"> thinking about</font>

120
00:04:33,120 --> 00:04:41,040
again carrying out massive computations

121
00:04:36,030 --> 00:04:45,450
on on data on large data sets with

122
00:04:41,040 --> 00:04:47,340
message<font color="#E5E5E5"> circuit with this in mind and in</font>

123
00:04:45,450 --> 00:04:50,219
understanding that bandwidth is a much

124
00:04:47,340 --> 00:04:52,039
bigger bottle neck than computation

125
00:04:50,220 --> 00:04:55,020
today in these parts<font color="#E5E5E5"> of protocols</font>

126
00:04:52,040 --> 00:04:57,690
because<font color="#CCCCCC"> cryptos become so fast with the</font>

127
00:04:55,020 --> 00:04:59,789
help of Intel and others we constructed

128
00:04:57,690 --> 00:05:01,560
a<font color="#E5E5E5"> protocols for the semi honest model</font>

129
00:04:59,790 --> 00:05:03,690
that requires the parties to send<font color="#E5E5E5"> only a</font>

130
00:05:01,560 --> 00:05:06,360
single bit for every and gate and saw

131
00:05:03,690 --> 00:05:08,310
Gator for free and also<font color="#E5E5E5"> it has a very</font>

132
00:05:06,360 --> 00:05:10,530
<font color="#CCCCCC">nice communication</font><font color="#E5E5E5"> pattern use each one</font>

133
00:05:08,310 --> 00:05:12,450
party each party seems a bit to another

134
00:05:10,530 --> 00:05:14,400
and it goes<font color="#E5E5E5"> around in a ring and in</font>

135
00:05:12,450 --> 00:05:16,409
between you can do computation the

136
00:05:14,400 --> 00:05:19,859
operations are very very simple with

137
00:05:16,410 --> 00:05:22,140
just a few<font color="#CCCCCC"> X ores and if you and / gate</font>

138
00:05:19,860 --> 00:05:24,630
and you need to do generate randomness

139
00:05:22,140 --> 00:05:27,840
but you can do one AE s operation for

140
00:05:24,630 --> 00:05:31,620
every 64 n gates so<font color="#E5E5E5"> using AES</font><font color="#CCCCCC"> ni this is</font>

141
00:05:27,840 --> 00:05:33,750
almost for free as well the protocol is

142
00:05:31,620 --> 00:05:36,120
very amenable to parallelization because

143
00:05:33,750 --> 00:05:38,760
of its structure so we<font color="#E5E5E5"> utilized the</font>

144
00:05:36,120 --> 00:05:45,479
<font color="#CCCCCC">Intel intrinsic the</font><font color="#E5E5E5"> ovx instruction set</font>

145
00:05:38,760 --> 00:05:47,340
and packed many many values together and

146
00:05:45,479 --> 00:05:48,630
single register actually a semi honest

147
00:05:47,340 --> 00:05:50,039
implementation used one to engage<font color="#CCCCCC"> the</font>

148
00:05:48,630 --> 00:05:52,830
registers now<font color="#E5E5E5"> already in tellin</font>

149
00:05:50,040 --> 00:05:55,770
structure<font color="#E5E5E5"> Intel chips have 256 the next</font>

150
00:05:52,830 --> 00:05:58,200
generations even 512<font color="#E5E5E5"> and with a highly</font>

151
00:05:55,770 --> 00:06:01,950
optimized implementation and packing

152
00:05:58,200 --> 00:06:05,940
each core receiving<font color="#CCCCCC"> 12,800 executions in</font>

153
00:06:01,950 --> 00:06:07,140
parallel we<font color="#E5E5E5"> actually got very very good</font>

154
00:06:05,940 --> 00:06:08,910
performance so this is these are the

155
00:06:07,140 --> 00:06:11,130
<font color="#CCCCCC">results on a cluster of three mid-level</font>

156
00:06:08,910 --> 00:06:12,960
servers so they're not home pcs but

157
00:06:11,130 --> 00:06:15,270
they're not massive machines they're

158
00:06:12,960 --> 00:06:18,460
there 20 core machines collected with a

159
00:06:15,270 --> 00:06:20,330
tear in it connected and attend Gigabit

160
00:06:18,460 --> 00:06:24,390
[Music]

161
00:06:20,330 --> 00:06:28,289
LAN we're with<font color="#E5E5E5"> the thing just looking at</font>

162
00:06:24,390 --> 00:06:29,880
a single core and actually below<font color="#E5E5E5"> one you</font>

163
00:06:28,290 --> 00:06:32,130
give it for a second connection so this

164
00:06:29,880 --> 00:06:34,710
is actually just a very simple type of

165
00:06:32,130 --> 00:06:39,409
setup we're really getting over 540

166
00:06:34,710 --> 00:06:42,349
million and gates per second

167
00:06:39,409 --> 00:06:44,719
at these scales linearly up to 10 cores

168
00:06:42,349 --> 00:06:46,819
at<font color="#E5E5E5"> 10</font><font color="#CCCCCC"> chords we're</font><font color="#E5E5E5"> getting 5 billion</font>

169
00:06:44,719 --> 00:06:48,860
over five billion and gates per second

170
00:06:46,819 --> 00:06:51,619
then you get some degradation because of

171
00:06:48,860 --> 00:06:54,889
the networking<font color="#E5E5E5"> but at 20 cores we get</font>

172
00:06:51,619 --> 00:06:57,409
<font color="#E5E5E5">over 7.15 billion and gates per second</font>

173
00:06:54,889 --> 00:07:00,050
which translates to<font color="#E5E5E5"> 1.3 million</font><font color="#CCCCCC"> AES</font>

174
00:06:57,409 --> 00:07:03,498
operations for a second now this is<font color="#E5E5E5"> a</font>

175
00:07:00,050 --> 00:07:06,229
truly<font color="#E5E5E5"> high throughput this is a very</font>

176
00:07:03,499 --> 00:07:07,639
<font color="#E5E5E5">very significant computation you can</font>

177
00:07:06,229 --> 00:07:09,619
think<font color="#E5E5E5"> of that</font><font color="#CCCCCC"> as an encryption machine</font>

178
00:07:07,639 --> 00:07:10,849
where the share is key to nobody knows

179
00:07:09,619 --> 00:07:13,099
it but you<font color="#E5E5E5"> can think more generally</font>

180
00:07:10,849 --> 00:07:15,860
forget the<font color="#E5E5E5"> AES that's just an example</font>

181
00:07:13,099 --> 00:07:17,659
circuit you<font color="#E5E5E5"> can think of a large circuit</font>

182
00:07:15,860 --> 00:07:19,309
computing I don't know a learning

183
00:07:17,659 --> 00:07:21,860
algorithm or something on distributed

184
00:07:19,309 --> 00:07:26,360
data at seven billion and gates per

185
00:07:21,860 --> 00:07:29,439
second you can<font color="#CCCCCC"> actually compute you know</font>

186
00:07:26,360 --> 00:07:33,709
a circuit with a trillion and gates in

187
00:07:29,439 --> 00:07:35,449
under 15<font color="#E5E5E5"> under 15 minutes even less</font>

188
00:07:33,709 --> 00:07:37,969
actually sorry that's<font color="#CCCCCC"> the yeah something</font>

189
00:07:35,449 --> 00:07:40,399
<font color="#CCCCCC">like that it's you can do really really</font>

190
00:07:37,969 --> 00:07:42,199
<font color="#E5E5E5">really big computations and this I</font>

191
00:07:40,399 --> 00:07:44,959
<font color="#E5E5E5">haven't got time in this talk to compare</font>

192
00:07:42,199 --> 00:07:46,909
to previous work but this<font color="#E5E5E5"> is far much</font>

193
00:07:44,959 --> 00:07:49,279
much much faster than any previous

194
00:07:46,909 --> 00:07:51,498
reported results it's a combination of a

195
00:07:49,279 --> 00:07:53,449
better protocol with lower bandwidth and

196
00:07:51,499 --> 00:07:57,289
simper operations and also the

197
00:07:53,449 --> 00:07:59,779
engineering in the implementation with

198
00:07:57,289 --> 00:08:03,199
the paralyzation enables us to get such

199
00:07:59,779 --> 00:08:04,699
subspace we wanted<font color="#CCCCCC"> to</font><font color="#E5E5E5"> see how this would</font>

200
00:08:03,199 --> 00:08:06,740
incorporate into the actual application

201
00:08:04,699 --> 00:08:11,899
so we consider the problem of<font color="#E5E5E5"> Active</font>

202
00:08:06,740 --> 00:08:13,399
<font color="#E5E5E5">Directory breach we're in Kerberos if</font>

203
00:08:11,899 --> 00:08:14,659
you get the<font color="#E5E5E5"> hash password you actually</font>

204
00:08:13,399 --> 00:08:17,389
don't<font color="#E5E5E5"> need anything else is no need to</font>

205
00:08:14,659 --> 00:08:18,919
brute force anything because that's

206
00:08:17,389 --> 00:08:20,209
<font color="#CCCCCC">actually what you need to decrypt the</font>

207
00:08:18,919 --> 00:08:23,359
ticket granting<font color="#E5E5E5"> ticket that you get from</font>

208
00:08:20,209 --> 00:08:24,919
the from<font color="#CCCCCC"> the server from so if the</font>

209
00:08:23,360 --> 00:08:26,539
active directory is breached then

210
00:08:24,919 --> 00:08:28,969
everything is completely gone in your

211
00:08:26,539 --> 00:08:31,808
whole organization and we'd<font color="#E5E5E5"> like to</font>

212
00:08:28,969 --> 00:08:35,289
protect that<font color="#E5E5E5"> so our idea is to split the</font>

213
00:08:31,809 --> 00:08:38,058
hashed passwords and keys of servers and

214
00:08:35,289 --> 00:08:39,828
between three different servers<font color="#CCCCCC"> at</font>

215
00:08:38,058 --> 00:08:41,328
<font color="#E5E5E5">separation with different administrators</font>

216
00:08:39,828 --> 00:08:43,218
so there isn't a single administrator

217
00:08:41,328 --> 00:08:44,689
<font color="#CCCCCC">that can now steal everything from</font>

218
00:08:43,219 --> 00:08:47,000
Active Directory and if an attacker

219
00:08:44,689 --> 00:08:48,559
breaches the network you have<font color="#E5E5E5"> to steal</font>

220
00:08:47,000 --> 00:08:52,430
more than<font color="#CCCCCC"> one administrators credentials</font>

221
00:08:48,559 --> 00:08:54,290
and we rewrote the curb

222
00:08:52,430 --> 00:08:56,810
a ticket granting server and the client

223
00:08:54,290 --> 00:09:00,349
to work in counter mode instead of CBC

224
00:08:56,810 --> 00:09:02,390
mode because CBC mode is inherently

225
00:09:00,350 --> 00:09:04,310
sequential and that will be a<font color="#CCCCCC"> problem</font>

226
00:09:02,390 --> 00:09:05,720
with latency but we rewrote them to work

227
00:09:04,310 --> 00:09:08,390
in counter most they could be fully

228
00:09:05,720 --> 00:09:09,620
paralyzed and it turns out with all of

229
00:09:08,390 --> 00:09:11,300
the encryptions you need to do with the

230
00:09:09,620 --> 00:09:13,430
service keys where with the<font color="#E5E5E5"> users</font>

231
00:09:11,300 --> 00:09:16,729
password and<font color="#CCCCCC"> some sort of 1432 AS</font>

232
00:09:13,430 --> 00:09:18,979
operations for every user logging and

233
00:09:16,730 --> 00:09:22,250
<font color="#E5E5E5">the result that we got purple is a</font>

234
00:09:18,980 --> 00:09:24,350
latency of 200 milliseconds<font color="#E5E5E5"> which is</font>

235
00:09:22,250 --> 00:09:27,100
very reasonable for human logging

236
00:09:24,350 --> 00:09:30,920
especially it's only at<font color="#E5E5E5"> login time and</font>

237
00:09:27,100 --> 00:09:32,680
with a single core we can support<font color="#CCCCCC"> 3,000</font>

238
00:09:30,920 --> 00:09:34,939
logins per second and a 20<font color="#CCCCCC"> chords</font>

239
00:09:32,680 --> 00:09:37,930
approximately forty one thousand logins

240
00:09:34,940 --> 00:09:40,640
per second this is enough to support a

241
00:09:37,930 --> 00:09:41,779
<font color="#E5E5E5">login storm of a huge organization I</font>

242
00:09:40,640 --> 00:09:43,580
don't think there are many organizations

243
00:09:41,779 --> 00:09:45,830
in the world that<font color="#E5E5E5"> need to support over</font>

244
00:09:43,580 --> 00:09:47,630
40,000 logins per second and this can be

245
00:09:45,830 --> 00:09:52,279
done on a single server so this<font color="#E5E5E5"> is a</font>

246
00:09:47,630 --> 00:09:54,110
real a high-throughput computation and a

247
00:09:52,279 --> 00:09:56,450
real<font color="#E5E5E5"> scenario and we see that</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> NPC</font>

248
00:09:54,110 --> 00:09:58,850
can actually support this at a scale far

249
00:09:56,450 --> 00:10:02,300
beyond what we would<font color="#E5E5E5"> have thought until</font>

250
00:09:58,850 --> 00:10:04,580
very very recently what about malicious

251
00:10:02,300 --> 00:10:06,920
security so semi honest security is good

252
00:10:04,580 --> 00:10:08,750
<font color="#E5E5E5">for some applications arguably for the</font>

253
00:10:06,920 --> 00:10:10,579
Kerberos<font color="#CCCCCC"> application to be questionable</font>

254
00:10:08,750 --> 00:10:13,130
if someone breaches the active directory

255
00:10:10,580 --> 00:10:15,080
then and I have root credentials they

256
00:10:13,130 --> 00:10:18,680
could<font color="#E5E5E5"> change the code that's being run</font>

257
00:10:15,080 --> 00:10:21,740
there on or on those servers so we'd

258
00:10:18,680 --> 00:10:22,849
like to prevent that<font color="#CCCCCC"> you need to prevent</font>

259
00:10:21,740 --> 00:10:24,920
it's much harder into preventive

260
00:10:22,850 --> 00:10:26,720
corrupted party from some our tampering

261
00:10:24,920 --> 00:10:28,939
with values in to check that they're

262
00:10:26,720 --> 00:10:31,610
behaving correctly and in the<font color="#CCCCCC"> past mrs.</font>

263
00:10:28,940 --> 00:10:33,110
mean this is meant that protocols for

264
00:10:31,610 --> 00:10:35,180
malicious security our orders of

265
00:10:33,110 --> 00:10:37,220
magnitude more expensive than semi-auto

266
00:10:35,180 --> 00:10:40,459
security and so then our high throughput

267
00:10:37,220 --> 00:10:42,560
will just go out the window we use the

268
00:10:40,459 --> 00:10:44,779
so-called multiplication triple approach

269
00:10:42,560 --> 00:10:46,729
essentially you need to generate a huge

270
00:10:44,779 --> 00:10:49,220
amount of multiplication triples and

271
00:10:46,730 --> 00:10:50,660
then you randomly shuffle them<font color="#CCCCCC"> and you</font>

272
00:10:49,220 --> 00:10:53,089
<font color="#E5E5E5">open some when you check against each</font>

273
00:10:50,660 --> 00:10:54,500
other and and so on<font color="#E5E5E5"> and so forth I don't</font>

274
00:10:53,089 --> 00:10:57,560
<font color="#E5E5E5">have time to</font><font color="#CCCCCC"> go into the details but</font>

275
00:10:54,500 --> 00:11:00,500
<font color="#E5E5E5">I'll just say that a lot of the work in</font>

276
00:10:57,560 --> 00:11:02,300
doing is protocol was optimizing every

277
00:11:00,500 --> 00:11:04,370
single bit that extent to reduce the

278
00:11:02,300 --> 00:11:05,599
bandwidth as much as possible and also

279
00:11:04,370 --> 00:11:07,310
<font color="#CCCCCC">you</font><font color="#E5E5E5"> found something very interesting</font>

280
00:11:05,600 --> 00:11:10,329
thing that since we are now working on

281
00:11:07,310 --> 00:11:13,069
massive arrays of triples because we

282
00:11:10,329 --> 00:11:15,589
want<font color="#E5E5E5"> to get high throughput actually the</font>

283
00:11:13,069 --> 00:11:17,000
bottleneck became the cache misses that

284
00:11:15,589 --> 00:11:19,250
was the<font color="#E5E5E5"> most expensive</font><font color="#CCCCCC"> thing in</font><font color="#E5E5E5"> the</font>

285
00:11:17,000 --> 00:11:22,579
protocol and<font color="#CCCCCC"> slowed everything down to a</font>

286
00:11:19,250 --> 00:11:24,139
halt essentially so we<font color="#E5E5E5"> designed a cache</font>

287
00:11:22,579 --> 00:11:26,000
efficient shuffling method which is

288
00:11:24,139 --> 00:11:28,519
suitable for cut and choose for here and

289
00:11:26,000 --> 00:11:30,709
a very optimized and tight combinatorial

290
00:11:28,519 --> 00:11:32,329
analysis because this has a huge effect

291
00:11:30,709 --> 00:11:34,099
on the actual efficiency of the protocol

292
00:11:32,329 --> 00:11:36,430
it tells you how many triples you need

293
00:11:34,100 --> 00:11:39,440
to open and check and so on and<font color="#E5E5E5"> so forth</font>

294
00:11:36,430 --> 00:11:42,949
our most uppers<font color="#E5E5E5"> optimized protocol sends</font>

295
00:11:39,440 --> 00:11:44,600
on<font color="#CCCCCC"> 7 bits per and gate as</font><font color="#E5E5E5"> Nigel said the</font>

296
00:11:42,949 --> 00:11:46,160
protocol is actually<font color="#E5E5E5"> really simple he</font>

297
00:11:44,600 --> 00:11:48,170
said moronic but I'm<font color="#E5E5E5"> just reading so</font>

298
00:11:46,160 --> 00:11:49,069
simple but actually from<font color="#CCCCCC"> what I</font>

299
00:11:48,170 --> 00:11:50,509
understand in a real world that's

300
00:11:49,069 --> 00:11:52,969
supposed to be good things the protocol

301
00:11:50,509 --> 00:11:54,980
is simple a lot of bad thing we have

302
00:11:52,970 --> 00:11:59,269
another variant that since 10 bits per<font color="#CCCCCC"> n</font>

303
00:11:54,980 --> 00:12:00,800
gate but has a better online phase if

304
00:11:59,269 --> 00:12:02,509
you want to separate between an offline

305
00:12:00,800 --> 00:12:05,269
preparation and an online computation

306
00:12:02,509 --> 00:12:07,519
phase and then on the same clusters

307
00:12:05,269 --> 00:12:09,589
before utilizing 20 cores we get

308
00:12:07,519 --> 00:12:11,860
something<font color="#E5E5E5"> that that really is a</font>

309
00:12:09,589 --> 00:12:15,860
surprising result were able to do

310
00:12:11,860 --> 00:12:20,600
compute 1.15 billion and gates per

311
00:12:15,860 --> 00:12:23,329
second and this is so actually it's even

312
00:12:20,600 --> 00:12:25,160
not it's<font color="#E5E5E5"> even better</font><font color="#CCCCCC"> than one seventh of</font>

313
00:12:23,329 --> 00:12:27,709
the<font color="#CCCCCC"> semi knowledge protocol that's</font>

314
00:12:25,160 --> 00:12:29,689
<font color="#E5E5E5">because of more optimization in the</font>

315
00:12:27,709 --> 00:12:32,180
implementation and this translates to

316
00:12:29,689 --> 00:12:34,329
about<font color="#E5E5E5"> 200 15,000 AES operations per</font>

317
00:12:32,180 --> 00:12:38,630
second begins think of computing on

318
00:12:34,329 --> 00:12:41,000
medical data or other data again over 1

319
00:12:38,630 --> 00:12:42,350
billion and gates per second so this is

320
00:12:41,000 --> 00:12:44,240
the 15 minutes actually because if you

321
00:12:42,350 --> 00:12:46,009
think<font color="#CCCCCC"> about a trillion and gates then</font>

322
00:12:44,240 --> 00:12:47,630
that will translate into<font color="#CCCCCC"> 16 minutes so</font>

323
00:12:46,009 --> 00:12:50,389
in semi owners would be two<font color="#CCCCCC"> minutes for</font>

324
00:12:47,630 --> 00:12:52,040
a true four trillion any days for the

325
00:12:50,389 --> 00:12:54,410
offline online variant we can actually

326
00:12:52,040 --> 00:12:56,360
<font color="#CCCCCC">get over 2.1 billion n-gage per second</font>

327
00:12:54,410 --> 00:12:58,219
if<font color="#CCCCCC"> you can adjust the online time which</font>

328
00:12:56,360 --> 00:13:00,110
<font color="#E5E5E5">is left for 100080 at</font><font color="#CCCCCC"> separation for</font>

329
00:12:58,220 --> 00:13:02,810
second this is orders of magnitude

330
00:13:00,110 --> 00:13:07,639
better than anything<font color="#E5E5E5"> that has</font><font color="#CCCCCC"> been done</font>

331
00:13:02,810 --> 00:13:10,459
until now so in summary<font color="#E5E5E5"> it is actually</font>

332
00:13:07,639 --> 00:13:13,130
possible to<font color="#E5E5E5"> achieve very fast rates even</font>

333
00:13:10,459 --> 00:13:14,779
for malicious adversary's specifically

334
00:13:13,130 --> 00:13:17,000
look at the three party sitting with

335
00:13:14,779 --> 00:13:18,510
with an honest majority but this is

336
00:13:17,000 --> 00:13:19,890
suitable for a number<font color="#CCCCCC"> of</font>

337
00:13:18,510 --> 00:13:24,240
different applications like<font color="#CCCCCC"> the Q</font>

338
00:13:19,890 --> 00:13:25,680
protection of application like hospitals

339
00:13:24,240 --> 00:13:27,110
collaborating and so on<font color="#E5E5E5"> and so forth a</font>

340
00:13:25,680 --> 00:13:29,819
lot<font color="#E5E5E5"> of them can use this part of setting</font>

341
00:13:27,110 --> 00:13:31,350
with rated<font color="#E5E5E5"> semi or semi on for their</font>

342
00:13:29,820 --> 00:13:32,850
seven billion and gates per second and

343
00:13:31,350 --> 00:13:35,790
<font color="#E5E5E5">over 1 billion n-gage for a second for</font>

344
00:13:32,850 --> 00:13:38,160
malicious we're<font color="#E5E5E5"> able to truly deal with</font>

345
00:13:35,790 --> 00:13:42,719
large computations there's been a lot of

346
00:13:38,160 --> 00:13:45,240
interest in MPC with the move to cloud

347
00:13:42,720 --> 00:13:47,430
<font color="#CCCCCC">ravit with</font><font color="#E5E5E5"> the desire to collaborate to</font>

348
00:13:45,240 --> 00:13:49,620
carry our computations together but the

349
00:13:47,430 --> 00:13:53,790
bottleneck of the of the throughput is

350
00:13:49,620 --> 00:13:55,590
something which has to be<font color="#E5E5E5"> has to be</font>

351
00:13:53,790 --> 00:13:57,990
solved before we can actually solve real

352
00:13:55,590 --> 00:14:00,290
problems and<font color="#E5E5E5"> I believe that what we've</font>

353
00:13:57,990 --> 00:14:02,850
done here is shown<font color="#CCCCCC"> that it can be done</font>

354
00:14:00,290 --> 00:14:04,709
of course this<font color="#E5E5E5"> is for these are fully</font>

355
00:14:02,850 --> 00:14:06,780
paralyzed<font color="#E5E5E5"> also adding more service means</font>

356
00:14:04,710 --> 00:14:10,980
<font color="#CCCCCC">you</font><font color="#E5E5E5"> just linearly increase the</font>

357
00:14:06,780 --> 00:14:12,360
throughput and so MPC can be used for

358
00:14:10,980 --> 00:14:15,260
much larger tasks than we thought

359
00:14:12,360 --> 00:14:15,260
beforehand thank

360
00:14:20,720 --> 00:14:28,020
so we have<font color="#E5E5E5"> time for one or</font><font color="#CCCCCC"> two questions</font>

361
00:14:23,990 --> 00:14:30,290
I'm glad there's time for two because my

362
00:14:28,020 --> 00:14:32,850
question is<font color="#E5E5E5"> not really</font><font color="#CCCCCC"> that insightful</font>

363
00:14:30,290 --> 00:14:34,560
I'm not very familiar with logic our

364
00:14:32,850 --> 00:14:35,910
<font color="#E5E5E5">computation and the actual protocols</font>

365
00:14:34,560 --> 00:14:37,560
right to mention<font color="#CCCCCC"> the malicious and the</font>

366
00:14:35,910 --> 00:14:39,449
semi honest model I know<font color="#E5E5E5"> that the</font>

367
00:14:37,560 --> 00:14:41,790
malicious model is in general<font color="#E5E5E5"> what we</font>

368
00:14:39,450 --> 00:14:43,140
want when applying it to what extent are

369
00:14:41,790 --> 00:14:44,910
the protocols that you built for<font color="#CCCCCC"> the</font>

370
00:14:43,140 --> 00:14:47,250
malicious model<font color="#E5E5E5"> just extensions of the</font>

371
00:14:44,910 --> 00:14:48,900
<font color="#E5E5E5">ones for the semi honest model do you</font>

372
00:14:47,250 --> 00:14:50,940
sometimes directly work in the malicious

373
00:14:48,900 --> 00:14:54,390
model or do you always go through semi

374
00:14:50,940 --> 00:14:56,490
honest to achieve malicious you don't

375
00:14:54,390 --> 00:14:58,050
always have to go but typically in terms

376
00:14:56,490 --> 00:14:59,610
of the design that's the way you do you

377
00:14:58,050 --> 00:15:01,979
take a semanas protocol then you add

378
00:14:59,610 --> 00:15:05,490
things to prevent your virtue from

379
00:15:01,980 --> 00:15:07,170
cheating in this case we built very

380
00:15:05,490 --> 00:15:08,910
heavily<font color="#E5E5E5"> on a semi honest protocol</font>

381
00:15:07,170 --> 00:15:10,260
because you can multiply really quickly

382
00:15:08,910 --> 00:15:11,579
so you can generate a huge number of

383
00:15:10,260 --> 00:15:14,370
tuples really quickly and<font color="#E5E5E5"> then you just</font>

384
00:15:11,580 --> 00:15:15,990
can check them so it's there it's based

385
00:15:14,370 --> 00:15:17,370
<font color="#E5E5E5">very heavily on oh but it turns out also</font>

386
00:15:15,990 --> 00:15:20,720
to be quite a simple protocol which

387
00:15:17,370 --> 00:15:20,720
means that deploying it is not difficult

388
00:15:22,970 --> 00:15:29,280
what will<font color="#E5E5E5"> happen if their server sign</font>

389
00:15:26,520 --> 00:15:32,250
different jurisdictions so the latency

390
00:15:29,280 --> 00:15:34,319
is big right<font color="#E5E5E5"> so in this star portal it's</font>

391
00:15:32,250 --> 00:15:35,730
not<font color="#E5E5E5"> suitable for that you would want</font><font color="#CCCCCC"> to</font>

392
00:15:34,320 --> 00:15:37,500
use<font color="#CCCCCC"> something like</font><font color="#E5E5E5"> double circuit</font>

393
00:15:35,730 --> 00:15:39,090
approach for that but if you<font color="#E5E5E5"> want to get</font>

394
00:15:37,500 --> 00:15:40,740
high degrees of separation you could

395
00:15:39,090 --> 00:15:43,500
think<font color="#E5E5E5"> of for example having one server</font>

396
00:15:40,740 --> 00:15:45,240
in<font color="#CCCCCC"> ashore in</font><font color="#E5E5E5"> on the</font><font color="#CCCCCC"> East Coast and</font><font color="#E5E5E5"> one</font>

397
00:15:43,500 --> 00:15:47,040
an Amazon on the East Coast you then

398
00:15:45,240 --> 00:15:48,840
still have low latency we'd have a high

399
00:15:47,040 --> 00:15:50,849
degree of separation between the

400
00:15:48,840 --> 00:15:52,230
<font color="#E5E5E5">different service so there are things</font>

401
00:15:50,850 --> 00:15:55,050
that you<font color="#E5E5E5"> can do to achieve that and</font>

402
00:15:52,230 --> 00:15:56,700
still get low latency my question<font color="#CCCCCC"> was</font>

403
00:15:55,050 --> 00:15:58,079
exactly the same because it seemed to me

404
00:15:56,700 --> 00:16:00,500
you're running this in the same cluster

405
00:15:58,080 --> 00:16:03,360
so you're not going<font color="#E5E5E5"> to get so much</font>

406
00:16:00,500 --> 00:16:04,950
<font color="#E5E5E5">independent between them yeah well the</font>

407
00:16:03,360 --> 00:16:06,690
independence you can get by having

408
00:16:04,950 --> 00:16:07,920
different administrators on the server

409
00:16:06,690 --> 00:16:09,120
so<font color="#E5E5E5"> you can't have any single</font>

410
00:16:07,920 --> 00:16:11,250
<font color="#E5E5E5">administrator that's already a</font>

411
00:16:09,120 --> 00:16:12,960
reasonable separation but point 13

412
00:16:11,250 --> 00:16:14,520
milliseconds ping time I<font color="#E5E5E5"> think you get</font>

413
00:16:12,960 --> 00:16:16,080
within the<font color="#CCCCCC"> East Coast you</font><font color="#E5E5E5"> can set up</font>

414
00:16:14,520 --> 00:16:17,760
between different cloud providers and

415
00:16:16,080 --> 00:16:22,050
get<font color="#E5E5E5"> that sort of thing time as well it's</font>

416
00:16:17,760 --> 00:16:24,720
not<font color="#E5E5E5"> a completely unrealistic I wondering</font>

417
00:16:22,050 --> 00:16:26,520
how configurable you oh sorry<font color="#E5E5E5"> okay how</font>

418
00:16:24,720 --> 00:16:28,110
configurable these results like how<font color="#E5E5E5"> much</font>

419
00:16:26,520 --> 00:16:28,819
of the optimization was done because you

420
00:16:28,110 --> 00:16:30,919
were specific

421
00:16:28,819 --> 00:16:32,449
computing<font color="#CCCCCC"> AES or how easy is it to just</font>

422
00:16:30,919 --> 00:16:34,069
<font color="#E5E5E5">like plug in whatever you can plug in</font>

423
00:16:32,449 --> 00:16:36,339
whatever circuit the only thing<font color="#CCCCCC"> is that</font>

424
00:16:34,069 --> 00:16:39,889
you need to build<font color="#E5E5E5"> something which will</font>

425
00:16:36,339 --> 00:16:42,709
you want to work in a run st. circuit at

426
00:16:39,889 --> 00:16:44,149
least many times together but even if

427
00:16:42,709 --> 00:16:45,738
you're doing for example learning you'll

428
00:16:44,149 --> 00:16:47,479
often do that you'll be writing the same

429
00:16:45,739 --> 00:16:49,729
thing on many pieces of<font color="#E5E5E5"> data and then</font>

430
00:16:47,479 --> 00:16:52,779
continuing through it so it's not at all

431
00:16:49,729 --> 00:16:52,779
up<font color="#E5E5E5"> to much for areas</font>

