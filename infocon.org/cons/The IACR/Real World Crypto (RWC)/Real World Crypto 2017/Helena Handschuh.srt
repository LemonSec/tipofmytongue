1
00:00:00,000 --> 00:00:05,879
um<font color="#CCCCCC"> alright so I'm kind of assuming that</font>

2
00:00:03,600 --> 00:00:08,040
most of you already know what GPA<font color="#E5E5E5"> is but</font>

3
00:00:05,879 --> 00:00:12,110
just in case i'm<font color="#CCCCCC"> going to give like it</font>

4
00:00:08,039 --> 00:00:12,110
one minute flash intro but what it<font color="#E5E5E5"> is</font>

5
00:00:12,590 --> 00:00:23,460
does that work<font color="#CCCCCC"> okay so it was</font><font color="#E5E5E5"> discovered</font>

6
00:00:18,720 --> 00:00:25,470
by the CRI research team in the<font color="#CCCCCC"> mid-90s</font>

7
00:00:23,460 --> 00:00:28,529
they discovered both simple and

8
00:00:25,470 --> 00:00:30,660
differential power analysis it's a

9
00:00:28,529 --> 00:00:32,308
low-cost non-invasive<font color="#E5E5E5"> attack on Krypto</font>

10
00:00:30,660 --> 00:00:33,899
hardware and software you can extract

11
00:00:32,308 --> 00:00:36,510
keys with it you can<font color="#E5E5E5"> even reverse</font>

12
00:00:33,899 --> 00:00:39,780
engineer some for example secret s boxes

13
00:00:36,510 --> 00:00:42,449
and stuff like that is it it's typically

14
00:00:39,780 --> 00:00:46,140
applies to all crypto algorithms that

15
00:00:42,450 --> 00:00:47,730
use keys so most of them do so you can

16
00:00:46,140 --> 00:00:49,590
extract keys out of symmetric key

17
00:00:47,730 --> 00:00:52,800
<font color="#CCCCCC">algorithms you can extract he's out of</font>

18
00:00:49,590 --> 00:00:55,440
public-key algorithms any<font color="#CCCCCC"> type of aryans</font>

19
00:00:52,800 --> 00:00:58,410
th<font color="#E5E5E5"> able to curve or say anything you</font>

20
00:00:55,440 --> 00:01:01,769
<font color="#CCCCCC">want it affects all types of hardware</font>

21
00:00:58,410 --> 00:01:05,820
and software it started off on smart

22
00:01:01,770 --> 00:01:08,340
cards which are easier to break and

23
00:01:05,820 --> 00:01:10,949
other platforms maybe but in the<font color="#E5E5E5"> last</font>

24
00:01:08,340 --> 00:01:13,920
<font color="#E5E5E5">few years in turns out that even a six</font>

25
00:01:10,950 --> 00:01:17,310
and<font color="#CCCCCC"> FPGAs and other types of more</font>

26
00:01:13,920 --> 00:01:21,390
complex computation systems can also be

27
00:01:17,310 --> 00:01:23,659
attacked with it and the same techniques

28
00:01:21,390 --> 00:01:26,310
actually work you can use different

29
00:01:23,659 --> 00:01:28,320
<font color="#CCCCCC">channel sources for your</font><font color="#E5E5E5"> information it</font>

30
00:01:26,310 --> 00:01:31,340
can be power consumption but it can also

31
00:01:28,320 --> 00:01:35,699
be radio<font color="#E5E5E5"> frequency it can be</font>

32
00:01:31,340 --> 00:01:37,409
electromagnetic etc<font color="#CCCCCC"> okay so that was it</font>

33
00:01:35,700 --> 00:01:41,909
was published in nineteen nine and let

34
00:01:37,409 --> 00:01:43,950
me<font color="#CCCCCC"> tell</font><font color="#E5E5E5"> you how this</font><font color="#CCCCCC"> works so let me try</font>

35
00:01:41,909 --> 00:01:46,979
to start with RSA this is<font color="#E5E5E5"> super simple</font>

36
00:01:43,950 --> 00:01:49,890
and<font color="#E5E5E5"> it's super visual in RSA you expand</font>

37
00:01:46,979 --> 00:01:52,829
<font color="#CCCCCC">NC 82</font><font color="#E5E5E5"> secret exponent d and this</font>

38
00:01:49,890 --> 00:01:54,899
exponent has this so if you use a

39
00:01:52,829 --> 00:01:56,189
typical let's say square and multiply

40
00:01:54,899 --> 00:01:59,100
algorithm and you don't worry about

41
00:01:56,189 --> 00:02:01,589
<font color="#E5E5E5">anything then you're going to see that</font>

42
00:01:59,100 --> 00:02:03,539
<font color="#CCCCCC">for each 0 bit you do is square and for</font>

43
00:02:01,590 --> 00:02:06,180
each one bit you'll do a square and a

44
00:02:03,540 --> 00:02:09,110
multiply so if you try to<font color="#E5E5E5"> plot a power</font>

45
00:02:06,180 --> 00:02:11,849
trace of what's going on on<font color="#CCCCCC"> your chip</font>

46
00:02:09,110 --> 00:02:13,450
you will see that the multiplies are

47
00:02:11,849 --> 00:02:16,299
actually different from this

48
00:02:13,450 --> 00:02:18,819
as we look<font color="#CCCCCC"> different and so when you see</font>

49
00:02:16,300 --> 00:02:21,160
like a big peak like that that is

50
00:02:18,819 --> 00:02:22,899
preceded by a smaller one that's

51
00:02:21,160 --> 00:02:24,700
typically multiplied preceded by a

52
00:02:22,900 --> 00:02:26,590
square and if you only have a small one

53
00:02:24,700 --> 00:02:28,839
that's the square only so essentially

54
00:02:26,590 --> 00:02:33,090
<font color="#E5E5E5">what it says is that you can read the</font>

55
00:02:28,840 --> 00:02:33,090
exponent off of one single<font color="#E5E5E5"> cartridge</font>

56
00:02:33,870 --> 00:02:38,950
<font color="#CCCCCC">okay so now for</font><font color="#E5E5E5"> us this is simple</font>

57
00:02:37,360 --> 00:02:41,620
<font color="#CCCCCC">carnales is for differential power</font>

58
00:02:38,950 --> 00:02:44,920
analysis<font color="#CCCCCC"> to look</font><font color="#E5E5E5"> more tricky for</font>

59
00:02:41,620 --> 00:02:46,480
algorithms such as a yes or des you

60
00:02:44,920 --> 00:02:49,559
don't<font color="#E5E5E5"> actually see anything on at them</font>

61
00:02:46,480 --> 00:02:52,780
on a single curve trace you have to use

62
00:02:49,560 --> 00:02:55,090
several ones and then you go<font color="#CCCCCC"> into the</font>

63
00:02:52,780 --> 00:02:58,269
domain of statistical analysis so you do

64
00:02:55,090 --> 00:03:00,519
<font color="#CCCCCC">Chi hypothesis testing you guess let's</font>

65
00:02:58,269 --> 00:03:03,250
say eight bits of the<font color="#E5E5E5"> key for a yes for</font>

66
00:03:00,519 --> 00:03:05,980
instance and then you choose one bit<font color="#CCCCCC"> of</font>

67
00:03:03,250 --> 00:03:08,829
the output of let's say one<font color="#CCCCCC"> of the first</font>

68
00:03:05,980 --> 00:03:11,530
s boxes and with your tea guess you're

69
00:03:08,829 --> 00:03:13,060
going<font color="#E5E5E5"> to be able to pre-compute</font><font color="#CCCCCC"> four</font>

70
00:03:11,530 --> 00:03:14,890
different plaintext what to suppose

71
00:03:13,060 --> 00:03:16,569
outlets it should be and depending on

72
00:03:14,890 --> 00:03:19,630
the value of<font color="#E5E5E5"> that bit you're going to be</font>

73
00:03:16,569 --> 00:03:23,708
<font color="#CCCCCC">able to sort your traces and put them in</font>

74
00:03:19,630 --> 00:03:25,840
two different buckets<font color="#E5E5E5"> this assumes that</font>

75
00:03:23,709 --> 00:03:27,730
if you compute with one's or zeros you

76
00:03:25,840 --> 00:03:29,799
don't consume the same power on your

77
00:03:27,730 --> 00:03:31,630
chip so you put<font color="#CCCCCC"> them into different</font>

78
00:03:29,799 --> 00:03:33,760
<font color="#CCCCCC">buckets and you take each bucket you</font>

79
00:03:31,630 --> 00:03:35,319
average all the traces in there and then

80
00:03:33,760 --> 00:03:38,108
you compute the difference<font color="#CCCCCC"> between the</font>

81
00:03:35,319 --> 00:03:40,780
two buckets and what happens is that<font color="#CCCCCC"> if</font>

82
00:03:38,109 --> 00:03:43,150
your key guess is correct essentially

83
00:03:40,780 --> 00:03:45,010
think of it<font color="#CCCCCC"> as weights right if you put</font>

84
00:03:43,150 --> 00:03:46,480
all the heavy weights on one side<font color="#CCCCCC"> and</font>

85
00:03:45,010 --> 00:03:48,670
all the light weights on<font color="#CCCCCC"> the other side</font>

86
00:03:46,480 --> 00:03:50,018
you will see a difference<font color="#E5E5E5"> if your tea</font>

87
00:03:48,670 --> 00:03:53,170
guess is correct because you will be

88
00:03:50,019 --> 00:03:54,910
sorting correctly this<font color="#E5E5E5"> is the power</font>

89
00:03:53,170 --> 00:03:57,339
trace that you see at<font color="#CCCCCC"> the bottom of the</font>

90
00:03:54,910 --> 00:03:59,200
slide so you see Peaks appearing it's

91
00:03:57,340 --> 00:04:02,349
totally visual and<font color="#E5E5E5"> you can just decide</font>

92
00:03:59,200 --> 00:04:04,060
<font color="#CCCCCC">okay this is the right to guess for an</font>

93
00:04:02,349 --> 00:04:08,048
incorrect tea yes here's what it looks

94
00:04:04,060 --> 00:04:10,329
like when you start<font color="#E5E5E5"> sorting according</font><font color="#CCCCCC"> to</font>

95
00:04:08,049 --> 00:04:12,730
an incorrect<font color="#E5E5E5"> bit key guess now you're</font>

96
00:04:10,329 --> 00:04:14,680
sorting completely randomly your traces

97
00:04:12,730 --> 00:04:16,539
<font color="#E5E5E5">into two different buckets and</font>

98
00:04:14,680 --> 00:04:18,130
<font color="#E5E5E5">essentially what ends up being in one</font>

99
00:04:16,539 --> 00:04:20,798
bucket and the other<font color="#E5E5E5"> baggage on average</font>

100
00:04:18,130 --> 00:04:22,960
is the same<font color="#E5E5E5"> thing so you see nothing so</font>

101
00:04:20,798 --> 00:04:24,479
the bottom<font color="#E5E5E5"> trace here you see there is</font>

102
00:04:22,960 --> 00:04:26,710
no peaks no nothing you can't

103
00:04:24,479 --> 00:04:26,960
distinguish anything interesting and

104
00:04:26,710 --> 00:04:29,000
there

105
00:04:26,960 --> 00:04:31,310
for you know that this is an incorrect

106
00:04:29,000 --> 00:04:33,199
key guess so we see the difference<font color="#CCCCCC"> here</font>

107
00:04:31,310 --> 00:04:37,039
is the bigger ones here's the<font color="#E5E5E5"> smaller</font>

108
00:04:33,199 --> 00:04:41,840
one<font color="#CCCCCC"> okay so that's SB MVP in a nutshell</font>

109
00:04:37,039 --> 00:04:43,370
in less than five minutes okay<font color="#CCCCCC"> so what</font>

110
00:04:41,840 --> 00:04:45,710
do you do to try to counteract these

111
00:04:43,370 --> 00:04:48,319
types of attacks you have very classical

112
00:04:45,710 --> 00:04:50,900
<font color="#CCCCCC">counter measures that have</font><font color="#E5E5E5"> been found</font>

113
00:04:48,319 --> 00:04:54,110
and described in more than 10,000 papers

114
00:04:50,900 --> 00:04:56,630
I think over time you can do several

115
00:04:54,110 --> 00:05:00,020
things you can do operation you can try

116
00:04:56,630 --> 00:05:02,599
to reduce the leak you can try to

117
00:05:00,020 --> 00:05:07,190
balance your designs you can try to

118
00:05:02,599 --> 00:05:09,289
introduce differential logic<font color="#CCCCCC"> styles you</font>

119
00:05:07,190 --> 00:05:11,810
can add temporal noise amplitude noise

120
00:05:09,289 --> 00:05:13,880
dummy operations you can add randomness

121
00:05:11,810 --> 00:05:17,000
which means that<font color="#CCCCCC"> you try to D correlate</font>

122
00:05:13,880 --> 00:05:18,620
your data from the<font color="#E5E5E5"> secrets</font><font color="#CCCCCC"> you can do</font>

123
00:05:17,000 --> 00:05:20,930
<font color="#CCCCCC">all sorts of an implementation</font><font color="#E5E5E5"> of</font>

124
00:05:18,620 --> 00:05:22,669
variations but all of<font color="#E5E5E5"> these suppose that</font>

125
00:05:20,930 --> 00:05:25,280
you can change the actual algorithm

126
00:05:22,669 --> 00:05:26,960
implementation that you're using and

127
00:05:25,280 --> 00:05:28,818
then in the real world that's not always

128
00:05:26,960 --> 00:05:30,979
the case so sometimes<font color="#E5E5E5"> we have people</font>

129
00:05:28,819 --> 00:05:33,770
<font color="#E5E5E5">coming to us and saying hey can you help</font>

130
00:05:30,979 --> 00:05:36,860
us you know secure our platform and our

131
00:05:33,770 --> 00:05:39,440
design but please don't change<font color="#E5E5E5"> anything</font>

132
00:05:36,860 --> 00:05:44,570
in the implementation<font color="#CCCCCC"> okay thank you</font>

133
00:05:39,440 --> 00:05:46,009
great no problem so<font color="#E5E5E5"> what you do then is</font>

134
00:05:44,570 --> 00:05:48,409
that you go one step<font color="#E5E5E5"> further and say</font>

135
00:05:46,009 --> 00:05:50,990
<font color="#CCCCCC">okay can I change anything at maybe the</font>

136
00:05:48,409 --> 00:05:54,500
protocol level so not touching the

137
00:05:50,990 --> 00:05:57,650
design of<font color="#CCCCCC"> the AES or whatever</font><font color="#E5E5E5"> just try</font>

138
00:05:54,500 --> 00:06:00,650
<font color="#E5E5E5">to change at the protocol level and this</font>

139
00:05:57,650 --> 00:06:03,349
is what I'm going<font color="#CCCCCC"> to try to</font><font color="#E5E5E5"> explain in</font>

140
00:06:00,650 --> 00:06:08,210
the next few slides<font color="#E5E5E5"> okay so the idea</font>

141
00:06:03,349 --> 00:06:10,190
here is that you say<font color="#E5E5E5"> okay if each time I</font>

142
00:06:08,210 --> 00:06:12,560
use the key i'm going to leak a little

143
00:06:10,190 --> 00:06:14,719
bit of information my goal is going to

144
00:06:12,560 --> 00:06:18,110
be to not use the key for too many

145
00:06:14,719 --> 00:06:21,020
different plaintext source I protects

146
00:06:18,110 --> 00:06:23,860
decryptions so I'm going<font color="#CCCCCC"> to</font><font color="#E5E5E5"> use the key</font>

147
00:06:21,020 --> 00:06:26,389
very carefully and only very few times

148
00:06:23,860 --> 00:06:28,759
and what I'm going<font color="#E5E5E5"> to describe next is</font>

149
00:06:26,389 --> 00:06:31,219
mostly applies to symmetric cryptography

150
00:06:28,759 --> 00:06:33,469
it doesn't apply so much<font color="#E5E5E5"> to</font><font color="#CCCCCC"> our essay or</font>

151
00:06:31,219 --> 00:06:36,380
anything here but what I'm describing is

152
00:06:33,469 --> 00:06:38,210
for symmetric based challenge-response

153
00:06:36,380 --> 00:06:39,560
encryption decryption and stuff like

154
00:06:38,210 --> 00:06:42,888
that<font color="#E5E5E5"> okay</font>

155
00:06:39,560 --> 00:06:45,770
so you're assuming<font color="#E5E5E5"> that you can find a</font>

156
00:06:42,889 --> 00:06:48,230
way<font color="#E5E5E5"> to only apply your key to very few</font>

157
00:06:45,770 --> 00:06:50,659
planes exercise of text blocks at a time

158
00:06:48,230 --> 00:06:52,460
and<font color="#E5E5E5"> then each time you think okay this</font>

159
00:06:50,660 --> 00:06:54,530
is enough I've<font color="#E5E5E5"> used it enough now I'm</font>

160
00:06:52,460 --> 00:07:00,109
going to change it evolved it<font color="#CCCCCC"> rotate it</font>

161
00:06:54,530 --> 00:07:02,179
and<font color="#E5E5E5"> choosing UT so the way you do this</font>

162
00:07:00,110 --> 00:07:04,850
is that you typically typically use

163
00:07:02,180 --> 00:07:06,770
something called a key tree so you start

164
00:07:04,850 --> 00:07:09,740
off from your shared secret which is

165
00:07:06,770 --> 00:07:11,690
noted as K root here and then you define

166
00:07:09,740 --> 00:07:14,180
something that's called<font color="#E5E5E5"> a</font><font color="#CCCCCC"> path and I</font>

167
00:07:11,690 --> 00:07:16,930
will come back to<font color="#E5E5E5"> what the path is and</font>

168
00:07:14,180 --> 00:07:19,700
then you walk<font color="#CCCCCC"> down a tree of cheese</font>

169
00:07:16,930 --> 00:07:22,370
meaning<font color="#CCCCCC"> that given depending on your</font>

170
00:07:19,700 --> 00:07:24,110
<font color="#E5E5E5">path bit you're going to choose</font><font color="#CCCCCC"> to go</font>

171
00:07:22,370 --> 00:07:26,150
one direction or the other if it's zero

172
00:07:24,110 --> 00:07:30,470
you'll go one way if it's one you'll go

173
00:07:26,150 --> 00:07:31,969
the other way f0 f1 being the functions

174
00:07:30,470 --> 00:07:35,000
applied to your Chi to make it evolve

175
00:07:31,970 --> 00:07:37,250
<font color="#CCCCCC">these are one-way</font><font color="#E5E5E5"> functions and you're</font>

176
00:07:35,000 --> 00:07:39,650
going<font color="#E5E5E5"> to use something at the bottom</font><font color="#CCCCCC"> of</font>

177
00:07:37,250 --> 00:07:44,270
the tree to do your actual computation

178
00:07:39,650 --> 00:07:48,260
with<font color="#E5E5E5"> ok so as a first example I'm going</font>

179
00:07:44,270 --> 00:07:50,270
to show challenge response using this

180
00:07:48,260 --> 00:07:54,080
technique so normally what you<font color="#E5E5E5"> do is you</font>

181
00:07:50,270 --> 00:07:55,789
send a challenge to your device when<font color="#E5E5E5"> you</font>

182
00:07:54,080 --> 00:07:58,490
want to authenticate it the device will

183
00:07:55,789 --> 00:08:01,010
reply with a crypto symmetric crypto

184
00:07:58,490 --> 00:08:03,500
function of your<font color="#CCCCCC"> route key apply to the</font>

185
00:08:01,010 --> 00:08:05,270
challenge that's a very<font color="#CCCCCC"> classical way</font>

186
00:08:03,500 --> 00:08:07,600
and if you want to do it in the<font color="#CCCCCC"> DPA</font>

187
00:08:05,270 --> 00:08:11,000
resistant fashion<font color="#E5E5E5"> you awake using your</font>

188
00:08:07,600 --> 00:08:13,580
tree of keys so what we call the path

189
00:08:11,000 --> 00:08:16,580
here is going to<font color="#E5E5E5"> be for example</font><font color="#CCCCCC"> din shot</font>

190
00:08:13,580 --> 00:08:18,560
sweat six hash value of your challenge

191
00:08:16,580 --> 00:08:21,859
that's received on the dices site and

192
00:08:18,560 --> 00:08:24,889
then from your<font color="#E5E5E5"> route key K root you're</font>

193
00:08:21,860 --> 00:08:26,360
going to go down your tree to define

194
00:08:24,889 --> 00:08:30,410
what the response will be to the

195
00:08:26,360 --> 00:08:33,550
challenge so f0 and f1 again are two

196
00:08:30,410 --> 00:08:36,830
distinct one-way hash functions with low

197
00:08:33,549 --> 00:08:38,900
<font color="#E5E5E5">unbounded leakage implementations but</font>

198
00:08:36,830 --> 00:08:41,599
essentially for every bit of the path

199
00:08:38,900 --> 00:08:43,309
you're<font color="#E5E5E5"> going to choose one direction or</font>

200
00:08:41,599 --> 00:08:45,950
the other and in the end what comes out

201
00:08:43,309 --> 00:08:48,739
is the response and the interesting

202
00:08:45,950 --> 00:08:51,640
<font color="#CCCCCC">thing here is that no matter how many</font>

203
00:08:48,740 --> 00:08:53,300
times you traverse this tree each

204
00:08:51,640 --> 00:08:55,310
individual

205
00:08:53,300 --> 00:08:58,160
intermediate<font color="#E5E5E5"> T that</font><font color="#CCCCCC"> you're computing is</font>

206
00:08:55,310 --> 00:09:00,199
only can only be attained by three

207
00:08:58,160 --> 00:09:03,079
different computations so either is

208
00:09:00,200 --> 00:09:07,130
coming down from<font color="#E5E5E5"> s1 here in red or going</font>

209
00:09:03,080 --> 00:09:09,589
down from k rude comment<font color="#CCCCCC"> one to f0</font><font color="#E5E5E5"> f1</font>

210
00:09:07,130 --> 00:09:12,709
depending on the next<font color="#CCCCCC"> T bit so you can</font>

211
00:09:09,589 --> 00:09:14,690
do anything you want to this protocol

212
00:09:12,709 --> 00:09:19,130
you can attack it any any way you want

213
00:09:14,690 --> 00:09:21,380
every individual different key in the in

214
00:09:19,130 --> 00:09:24,920
the<font color="#E5E5E5"> tree will only get use with three</font>

215
00:09:21,380 --> 00:09:29,060
different values which is not enough to

216
00:09:24,920 --> 00:09:31,040
run a DBA attack<font color="#CCCCCC"> okay so this is a very</font>

217
00:09:29,060 --> 00:09:32,479
<font color="#E5E5E5">simple challenge response but you can do</font>

218
00:09:31,040 --> 00:09:35,269
a little<font color="#E5E5E5"> bit more complicated you can</font>

219
00:09:32,480 --> 00:09:37,209
<font color="#CCCCCC">actually</font><font color="#E5E5E5"> do leakage resistant encryption</font>

220
00:09:35,269 --> 00:09:39,440
decryption and leakage resistant

221
00:09:37,209 --> 00:09:41,149
encryption decryption also means that

222
00:09:39,440 --> 00:09:43,399
you're going<font color="#E5E5E5"> to</font><font color="#CCCCCC"> use authenticated</font>

223
00:09:41,149 --> 00:09:47,680
encryption to make sure that<font color="#E5E5E5"> you're</font><font color="#CCCCCC"> not</font>

224
00:09:43,399 --> 00:09:47,680
vulnerable to<font color="#E5E5E5"> chosen ciphertext attacks</font>

225
00:09:48,820 --> 00:09:55,250
<font color="#E5E5E5">okay so where do you use as well okay</font>

226
00:09:51,890 --> 00:09:57,560
encryption decryption will be used in

227
00:09:55,250 --> 00:09:59,180
many different contexts for firmware

228
00:09:57,560 --> 00:10:03,140
decryption and pockets encryption

229
00:09:59,180 --> 00:10:05,180
<font color="#E5E5E5">decryption for storage and also when you</font>

230
00:10:03,140 --> 00:10:06,770
have something stored on a disk for

231
00:10:05,180 --> 00:10:09,829
example you're going to repeatedly

232
00:10:06,770 --> 00:10:13,310
decrypt the same thing which would be

233
00:10:09,829 --> 00:10:14,750
fine in general<font color="#E5E5E5"> but obviously the main</font>

234
00:10:13,310 --> 00:10:17,239
issue here is going to be that an

235
00:10:14,750 --> 00:10:19,790
attacker is able to submit chosen<font color="#CCCCCC"> cipher</font>

236
00:10:17,240 --> 00:10:21,860
<font color="#CCCCCC">texts so even if you don't intend to</font>

237
00:10:19,790 --> 00:10:24,740
decrypt any other<font color="#E5E5E5"> cipher text with your</font>

238
00:10:21,860 --> 00:10:27,320
teeth somebody's going<font color="#E5E5E5"> to submit</font>

239
00:10:24,740 --> 00:10:29,270
different ciphertext even if the mac

240
00:10:27,320 --> 00:10:31,310
sales in the<font color="#E5E5E5"> end it does matter it will</font>

241
00:10:29,270 --> 00:10:33,740
get rejected but you get the traces you

242
00:10:31,310 --> 00:10:37,819
need for your power<font color="#E5E5E5"> loss</font><font color="#CCCCCC"> okay so our</font>

243
00:10:33,740 --> 00:10:41,000
approach here then involves to use every

244
00:10:37,820 --> 00:10:43,790
T for only a very few number<font color="#E5E5E5"> of blocks</font>

245
00:10:41,000 --> 00:10:47,660
and to change<font color="#CCCCCC"> keys all the time all</font>

246
00:10:43,790 --> 00:10:50,029
<font color="#CCCCCC">right so how does it work</font><font color="#E5E5E5"> first of all</font>

247
00:10:47,660 --> 00:10:53,269
here is the encrypted data format so<font color="#CCCCCC"> you</font>

248
00:10:50,029 --> 00:10:56,269
choose<font color="#E5E5E5"> a message identifier at random</font>

249
00:10:53,269 --> 00:10:58,430
and you put it<font color="#E5E5E5"> together with something</font>

250
00:10:56,269 --> 00:11:00,320
<font color="#E5E5E5">called a validator which is basically a</font>

251
00:10:58,430 --> 00:11:02,959
mac<font color="#CCCCCC"> and i'll come</font><font color="#E5E5E5"> back on how to compute</font>

252
00:11:00,320 --> 00:11:06,510
that into a header and then you start

253
00:11:02,959 --> 00:11:10,439
encrypting chunks which are noted

254
00:11:06,510 --> 00:11:13,770
120 n the red part is the ciphertext of

255
00:11:10,440 --> 00:11:18,420
your the corresponding ciphertext<font color="#E5E5E5"> to</font>

256
00:11:13,770 --> 00:11:22,980
<font color="#E5E5E5">your encrypted plain text and the gray I</font>

257
00:11:18,420 --> 00:11:25,290
guess portions are hashes of the block

258
00:11:22,980 --> 00:11:27,600
that you're in hashes of the next block

259
00:11:25,290 --> 00:11:29,430
and the hashes of the soul plane txt let

260
00:11:27,600 --> 00:11:32,880
me describe this in a little<font color="#CCCCCC"> bit more</font>

261
00:11:29,430 --> 00:11:35,640
detail later so first of all<font color="#CCCCCC"> let's say</font>

262
00:11:32,880 --> 00:11:37,890
we start off from a message specific key

263
00:11:35,640 --> 00:11:40,199
<font color="#CCCCCC">K message right and I'll explain how you</font>

264
00:11:37,890 --> 00:11:42,210
compute that point later you<font color="#E5E5E5"> start out</font>

265
00:11:40,200 --> 00:11:44,730
from the<font color="#E5E5E5"> K message key and what you do</font>

266
00:11:42,210 --> 00:11:47,340
<font color="#CCCCCC">is that</font><font color="#E5E5E5"> you have shit as you go so</font><font color="#CCCCCC"> that</font>

267
00:11:44,730 --> 00:11:50,010
<font color="#E5E5E5">it will change every few plain text box</font>

268
00:11:47,340 --> 00:11:52,260
and by plain text lock I mean<font color="#CCCCCC"> not</font>

269
00:11:50,010 --> 00:11:54,300
necessarily just one AES loss can be a

270
00:11:52,260 --> 00:11:57,780
few<font color="#E5E5E5"> but not too many so you can set a</font>

271
00:11:54,300 --> 00:11:59,250
set a specific threshold here according

272
00:11:57,780 --> 00:12:01,829
to<font color="#E5E5E5"> how much your actual IES</font>

273
00:11:59,250 --> 00:12:04,170
implementation leaves so<font color="#E5E5E5"> you have to</font>

274
00:12:01,830 --> 00:12:06,750
choose one after the other and they

275
00:12:04,170 --> 00:12:09,660
change every every so many AAA es<font color="#E5E5E5"> plain</font>

276
00:12:06,750 --> 00:12:12,060
<font color="#E5E5E5">text blocks</font><font color="#CCCCCC"> ok that's first step so now</font>

277
00:12:09,660 --> 00:12:14,819
you're encrypt each block<font color="#CCCCCC"> ti with the</font>

278
00:12:12,060 --> 00:12:17,339
corresponding ki once you're done with

279
00:12:14,820 --> 00:12:19,230
<font color="#E5E5E5">all that you take all the plain text</font>

280
00:12:17,340 --> 00:12:21,900
blocks and hash them together and put

281
00:12:19,230 --> 00:12:23,940
them at the<font color="#E5E5E5"> end of the last encrypted</font>

282
00:12:21,900 --> 00:12:27,030
ciphertext junk on the complete right

283
00:12:23,940 --> 00:12:29,460
hand side each of peace and then you go

284
00:12:27,030 --> 00:12:31,709
backwards<font color="#E5E5E5"> and create a hash chain cipher</font>

285
00:12:29,460 --> 00:12:34,350
<font color="#E5E5E5">text so then you create the hash of the</font>

286
00:12:31,710 --> 00:12:37,050
full last block and include it in the

287
00:12:34,350 --> 00:12:41,490
previous block<font color="#E5E5E5"> that's H of 0 3 and</font>

288
00:12:37,050 --> 00:12:43,380
<font color="#E5E5E5">that's in this picture and then you do</font>

289
00:12:41,490 --> 00:12:45,330
the<font color="#E5E5E5"> same</font><font color="#CCCCCC"> thing</font><font color="#E5E5E5"> going backwards and then</font>

290
00:12:43,380 --> 00:12:48,200
you end up with the very first<font color="#CCCCCC"> hash of</font>

291
00:12:45,330 --> 00:12:52,350
go one here which we're going to keep

292
00:12:48,200 --> 00:12:55,440
aside for a second<font color="#CCCCCC"> alright this is the</font>

293
00:12:52,350 --> 00:12:57,900
first step here the second step is now

294
00:12:55,440 --> 00:13:00,000
<font color="#CCCCCC">ok how do I derive the message specific</font>

295
00:12:57,900 --> 00:13:01,650
key while is very simple as previously

296
00:13:00,000 --> 00:13:04,110
very similar to the challenge response

297
00:13:01,650 --> 00:13:07,590
protocol you're going to traverse the

298
00:13:04,110 --> 00:13:09,570
key<font color="#E5E5E5"> three of keys and compute a message</font>

299
00:13:07,590 --> 00:13:12,420
that's a big key chain message by

300
00:13:09,570 --> 00:13:16,260
applying the message ID the<font color="#E5E5E5"> randomly</font>

301
00:13:12,420 --> 00:13:19,059
chosen message ID as a path and you end

302
00:13:16,260 --> 00:13:21,699
<font color="#E5E5E5">up with one key that completely depends</font>

303
00:13:19,059 --> 00:13:24,819
on your message ID and only on that and

304
00:13:21,699 --> 00:13:27,098
the two<font color="#E5E5E5"> different functions h0 h1 one</font>

305
00:13:24,819 --> 00:13:28,988
way and they need to be different so for

306
00:13:27,099 --> 00:13:32,049
example<font color="#E5E5E5"> you can use a shot</font><font color="#CCCCCC"> 5 6 x</font>

307
00:13:28,989 --> 00:13:35,759
prepending 0 or 1 or some different

308
00:13:32,049 --> 00:13:39,759
constant value<font color="#E5E5E5"> to to what you're having</font>

309
00:13:35,759 --> 00:13:42,279
<font color="#CCCCCC">ok</font><font color="#E5E5E5"> message ID now you have</font><font color="#CCCCCC"> a key message</font>

310
00:13:39,759 --> 00:13:44,289
and now to finish the off<font color="#CCCCCC"> the protocol</font>

311
00:13:42,279 --> 00:13:46,359
how do you finally compute the

312
00:13:44,289 --> 00:13:47,829
validators so the<font color="#CCCCCC"> Mac that will check</font>

313
00:13:46,359 --> 00:13:51,159
<font color="#E5E5E5">that nobody</font><font color="#CCCCCC"> submitted</font><font color="#E5E5E5"> and wrong</font>

314
00:13:47,829 --> 00:13:54,069
<font color="#E5E5E5">ciphertext to you you take your</font><font color="#CCCCCC"> K</font>

315
00:13:51,159 --> 00:13:57,429
message and you take the remember<font color="#CCCCCC"> the</font>

316
00:13:54,069 --> 00:14:00,069
hash of the<font color="#E5E5E5"> 01 value which you hash</font>

317
00:13:57,429 --> 00:14:02,978
backwards and as you apply this hash

318
00:14:00,069 --> 00:14:04,899
value to the K message key again in a

319
00:14:02,979 --> 00:14:08,379
tree<font color="#CCCCCC"> version and out comes at the end</font>

320
00:14:04,899 --> 00:14:10,779
<font color="#E5E5E5">the value</font><font color="#CCCCCC"> that we call a validator ok so</font>

321
00:14:08,379 --> 00:14:15,219
now that<font color="#E5E5E5"> everybody's confused let me try</font>

322
00:14:10,779 --> 00:14:18,269
to show what this thing looks like so as

323
00:14:15,219 --> 00:14:21,159
a summary<font color="#CCCCCC"> of the whole protocol here</font>

324
00:14:18,269 --> 00:14:23,979
again you do generate a random<font color="#E5E5E5"> message</font>

325
00:14:21,159 --> 00:14:26,709
ID plug it at the beginning then encrypt

326
00:14:23,979 --> 00:14:29,469
each chunk hash the keys as you go and

327
00:14:26,709 --> 00:14:32,468
crispy chunk hash the full plane tix put

328
00:14:29,469 --> 00:14:35,739
it at the<font color="#E5E5E5"> end hash backwards on each</font>

329
00:14:32,469 --> 00:14:38,349
block and take the final hash which is

330
00:14:35,739 --> 00:14:40,269
the hash of the<font color="#E5E5E5"> very first block walk</font>

331
00:14:38,349 --> 00:14:42,279
down the tree again<font color="#E5E5E5"> and compute the</font>

332
00:14:40,269 --> 00:14:46,149
validator plug it in there and<font color="#E5E5E5"> that's</font>

333
00:14:42,279 --> 00:14:48,729
your full encrypted data for decryption

334
00:14:46,149 --> 00:14:52,209
you go the other way around<font color="#E5E5E5"> you take the</font>

335
00:14:48,729 --> 00:14:54,099
<font color="#E5E5E5">K message specific key by walking</font><font color="#CCCCCC"> down</font>

336
00:14:52,209 --> 00:14:57,069
the key tree from the<font color="#E5E5E5"> root key with the</font>

337
00:14:54,099 --> 00:15:00,009
message ID and<font color="#E5E5E5"> then you start</font><font color="#CCCCCC"> to a very</font>

338
00:14:57,069 --> 00:15:02,858
verified validator first so if you know

339
00:15:00,009 --> 00:15:06,159
<font color="#CCCCCC">that validator is correct you can start</font>

340
00:15:02,859 --> 00:15:07,809
decrypting ug<font color="#CCCCCC"> crips each chunk and hash</font>

341
00:15:06,159 --> 00:15:09,999
<font color="#CCCCCC">it as you go</font><font color="#E5E5E5"> to make sure that each</font>

342
00:15:07,809 --> 00:15:11,559
chunk has not been<font color="#CCCCCC"> modified and in the</font>

343
00:15:09,999 --> 00:15:12,939
end you can<font color="#E5E5E5"> check the final hash to make</font>

344
00:15:11,559 --> 00:15:15,459
sure it could respond to<font color="#E5E5E5"> the hash of the</font>

345
00:15:12,939 --> 00:15:18,009
<font color="#E5E5E5">place so essentially what you're doing</font>

346
00:15:15,459 --> 00:15:20,618
in this protocol is your every time you

347
00:15:18,009 --> 00:15:24,429
touch a key or<font color="#CCCCCC"> something</font><font color="#E5E5E5"> that's message</font>

348
00:15:20,619 --> 00:15:26,619
dependent you walk through three<font color="#CCCCCC"> of keys</font>

349
00:15:24,429 --> 00:15:30,249
which means that<font color="#E5E5E5"> every single keys only</font>

350
00:15:26,619 --> 00:15:32,710
apply to very few values and if anybody

351
00:15:30,249 --> 00:15:35,560
tries to submit a wrong ciphertext

352
00:15:32,710 --> 00:15:37,660
you somewhere if something is going to

353
00:15:35,560 --> 00:15:39,520
<font color="#CCCCCC">change</font><font color="#E5E5E5"> with make sure that some</font><font color="#CCCCCC"> of the</font>

354
00:15:37,660 --> 00:15:45,449
values somewhere will not met make a

355
00:15:39,520 --> 00:15:48,550
<font color="#E5E5E5">match up okay so this is a typical</font>

356
00:15:45,450 --> 00:15:49,930
protocol level countermeasure for the

357
00:15:48,550 --> 00:15:52,060
real world<font color="#CCCCCC"> you don't</font><font color="#E5E5E5"> have to change</font>

358
00:15:49,930 --> 00:15:53,650
pretty<font color="#CCCCCC"> much anything in your AE s</font>

359
00:15:52,060 --> 00:15:56,199
implementation you just need to make

360
00:15:53,650 --> 00:15:57,760
sure you can<font color="#E5E5E5"> actually change the</font>

361
00:15:56,200 --> 00:15:59,860
<font color="#E5E5E5">protocol itself so that's</font><font color="#CCCCCC"> not always</font>

362
00:15:57,760 --> 00:16:01,600
possible but sometimes you can be lucky

363
00:15:59,860 --> 00:16:03,880
and you can be in a<font color="#CCCCCC"> scenario where you</font>

364
00:16:01,600 --> 00:16:05,710
<font color="#E5E5E5">don't</font><font color="#CCCCCC"> have to necessarily follow</font>

365
00:16:03,880 --> 00:16:08,290
standards or be interoperable with

366
00:16:05,710 --> 00:16:11,680
anybody else<font color="#CCCCCC"> and your own other side of</font>

367
00:16:08,290 --> 00:16:13,420
<font color="#E5E5E5">your system and so this works nicely in</font>

368
00:16:11,680 --> 00:16:17,199
some settings so for example as an

369
00:16:13,420 --> 00:16:19,270
<font color="#E5E5E5">application typically you'll have</font><font color="#CCCCCC"> bit</font>

370
00:16:17,200 --> 00:16:21,100
<font color="#CCCCCC">stream encryption on fpga so you have a</font>

371
00:16:19,270 --> 00:16:23,430
bit stream encrypted that's sitting

372
00:16:21,100 --> 00:16:25,900
somewhere in memory and when you load it

373
00:16:23,430 --> 00:16:28,120
this is how you decrypt your bit stream

374
00:16:25,900 --> 00:16:30,910
and start running<font color="#E5E5E5"> it on your</font><font color="#CCCCCC"> FPGA and</font>

375
00:16:28,120 --> 00:16:33,100
this is kind<font color="#E5E5E5"> of a closed system where</font>

376
00:16:30,910 --> 00:16:34,719
you can decide on both sides<font color="#E5E5E5"> can run the</font>

377
00:16:33,100 --> 00:16:39,520
same protocols or you can<font color="#E5E5E5"> apply this</font>

378
00:16:34,720 --> 00:16:41,410
kind of come to measure<font color="#E5E5E5"> okay so let's</font>

379
00:16:39,520 --> 00:16:42,910
see you have a few<font color="#CCCCCC"> minutes left so let</font>

380
00:16:41,410 --> 00:16:47,650
<font color="#E5E5E5">me talk</font><font color="#CCCCCC"> about</font><font color="#E5E5E5"> something a little bit</font>

381
00:16:42,910 --> 00:16:50,880
different now something else we're

382
00:16:47,650 --> 00:16:55,569
working on at the company right now is

383
00:16:50,880 --> 00:16:58,660
trying<font color="#E5E5E5"> to change a little bit how you do</font>

384
00:16:55,570 --> 00:17:01,120
product testing<font color="#CCCCCC"> site on resistance</font>

385
00:16:58,660 --> 00:17:03,699
testings for actual products and for

386
00:17:01,120 --> 00:17:05,410
that we propose<font color="#E5E5E5"> a somewhat new</font>

387
00:17:03,700 --> 00:17:08,700
methodology which is called test

388
00:17:05,410 --> 00:17:11,320
director leakage assessment methodology

389
00:17:08,700 --> 00:17:14,650
what the goal is love this is that you

390
00:17:11,319 --> 00:17:16,839
want<font color="#E5E5E5"> to try to achieve some kind of</font>

391
00:17:14,650 --> 00:17:19,900
repeatable and very precise method for

392
00:17:16,839 --> 00:17:23,500
testing which is more automatic less

393
00:17:19,900 --> 00:17:25,570
subjective than pure lab analysis which

394
00:17:23,500 --> 00:17:28,000
is low cost<font color="#E5E5E5"> and also allows class time</font>

395
00:17:25,569 --> 00:17:30,610
to market and the reason<font color="#CCCCCC"> for this</font><font color="#E5E5E5"> is</font>

396
00:17:28,000 --> 00:17:33,340
that in general at least<font color="#E5E5E5"> in the</font>

397
00:17:30,610 --> 00:17:35,229
<font color="#E5E5E5">smartcard world people have chosen so</font>

398
00:17:33,340 --> 00:17:40,230
far to go down the evaluation route

399
00:17:35,230 --> 00:17:43,600
which is very similar<font color="#E5E5E5"> to common criteria</font>

400
00:17:40,230 --> 00:17:45,920
validation evaluation for example when

401
00:17:43,600 --> 00:17:47,899
you have labs essentially test

402
00:17:45,920 --> 00:17:50,000
trying to break<font color="#E5E5E5"> into your products and</font>

403
00:17:47,900 --> 00:17:52,370
if they succeed and you feel and if they

404
00:17:50,000 --> 00:17:53,930
don't succeed then you win what we're

405
00:17:52,370 --> 00:17:56,000
trying<font color="#CCCCCC"> to propose here</font><font color="#E5E5E5"> is a little bit</font>

406
00:17:53,930 --> 00:17:58,520
different and goes into<font color="#E5E5E5"> the</font><font color="#CCCCCC"> direction of</font>

407
00:17:56,000 --> 00:18:01,430
validation so this means you want to try

408
00:17:58,520 --> 00:18:03,290
to<font color="#E5E5E5"> write a specification which could</font>

409
00:18:01,430 --> 00:18:05,180
hopefully be standardized<font color="#E5E5E5"> and which says</font>

410
00:18:03,290 --> 00:18:07,909
okay if you apply these specific test

411
00:18:05,180 --> 00:18:10,880
vectors and you run these vectors on

412
00:18:07,910 --> 00:18:13,910
your device with specific specifically

413
00:18:10,880 --> 00:18:17,030
designed and standardized tools then if

414
00:18:13,910 --> 00:18:18,710
the result corresponds to some expected

415
00:18:17,030 --> 00:18:20,870
output then you know<font color="#CCCCCC"> that your product</font>

416
00:18:18,710 --> 00:18:23,630
is secure so it slightly different

417
00:18:20,870 --> 00:18:26,719
approach and the<font color="#E5E5E5"> reason to you want to</font>

418
00:18:23,630 --> 00:18:31,130
do is this is to say okay I might not

419
00:18:26,720 --> 00:18:33,230
necessarily be able to extract keys if I

420
00:18:31,130 --> 00:18:35,120
find<font color="#CCCCCC"> a leak but if I</font><font color="#E5E5E5"> don't find a leaked</font>

421
00:18:33,230 --> 00:18:37,070
and for sure I know I can't extract any

422
00:18:35,120 --> 00:18:39,590
case so there's someone's going a little

423
00:18:37,070 --> 00:18:41,480
bit further<font color="#E5E5E5"> than trying to break keys</font>

424
00:18:39,590 --> 00:18:44,899
out<font color="#CCCCCC"> of a product and do it over and over</font>

425
00:18:41,480 --> 00:18:47,900
again so each of these<font color="#E5E5E5"> methods have pros</font>

426
00:18:44,900 --> 00:18:49,430
and cons obviously but the one that

427
00:18:47,900 --> 00:18:52,130
we're trying<font color="#E5E5E5"> to describe here is a</font>

428
00:18:49,430 --> 00:18:55,400
little<font color="#E5E5E5"> bit more standardized able and</font>

429
00:18:52,130 --> 00:18:57,470
we're<font color="#E5E5E5"> helping us that this could end up</font>

430
00:18:55,400 --> 00:18:59,750
in ISO<font color="#E5E5E5"> Spanish there's already efforts</font>

431
00:18:57,470 --> 00:19:02,380
to do that and maybe I can show you a

432
00:18:59,750 --> 00:19:06,560
little<font color="#E5E5E5"> bit whether standards are at but</font>

433
00:19:02,380 --> 00:19:08,570
it's on its way<font color="#E5E5E5"> okay so essentially this</font>

434
00:19:06,560 --> 00:19:10,550
<font color="#CCCCCC">is a test vector approach similar to</font>

435
00:19:08,570 --> 00:19:12,409
known answer text in some sense so you

436
00:19:10,550 --> 00:19:14,510
want to change<font color="#E5E5E5"> from an attack style</font>

437
00:19:12,410 --> 00:19:17,390
methodology to<font color="#E5E5E5"> a white box validation</font>

438
00:19:14,510 --> 00:19:18,890
and you define exactly what the test

439
00:19:17,390 --> 00:19:21,500
vector should be for every single

440
00:19:18,890 --> 00:19:26,030
algorithm so essentially you're going

441
00:19:21,500 --> 00:19:28,220
from giving a lab all of the work to do

442
00:19:26,030 --> 00:19:30,770
to try to hack into each new product

443
00:19:28,220 --> 00:19:33,830
into trying<font color="#E5E5E5"> to define have experts it</font>

444
00:19:30,770 --> 00:19:35,960
together and try to define what<font color="#CCCCCC"> is the</font>

445
00:19:33,830 --> 00:19:38,240
<font color="#E5E5E5">perfect set of test vectors for each</font>

446
00:19:35,960 --> 00:19:40,700
specific algorithm that mostly depends

447
00:19:38,240 --> 00:19:42,620
on the algorithm and so once this is

448
00:19:40,700 --> 00:19:46,570
done then you can have everybody run the

449
00:19:42,620 --> 00:19:49,429
same kind<font color="#E5E5E5"> of</font><font color="#CCCCCC"> test and be comparable</font>

450
00:19:46,570 --> 00:19:54,260
evaluated and validated in a comparable

451
00:19:49,430 --> 00:19:56,120
way it does require a lot of control

452
00:19:54,260 --> 00:19:58,190
over the keys and everything that gets

453
00:19:56,120 --> 00:19:58,758
loaded into products your product under

454
00:19:58,190 --> 00:20:01,459
test

455
00:19:58,759 --> 00:20:04,369
to be a little<font color="#E5E5E5"> bit open so that you can</font>

456
00:20:01,459 --> 00:20:06,320
set specific keys and set specific data

457
00:20:04,369 --> 00:20:08,899
run it and then measure what the<font color="#E5E5E5"> outcome</font>

458
00:20:06,320 --> 00:20:11,089
is but once you have that implemented

459
00:20:08,899 --> 00:20:15,258
then it's all pretty<font color="#CCCCCC"> much automated and</font>

460
00:20:11,089 --> 00:20:19,039
<font color="#E5E5E5">under standard</font><font color="#CCCCCC"> okay so what it then</font>

461
00:20:15,259 --> 00:20:21,379
gives you is that you measure leakage

462
00:20:19,039 --> 00:20:24,799
and if your leakage is below a specific

463
00:20:21,379 --> 00:20:26,359
threshold you're reasonably assured that

464
00:20:24,799 --> 00:20:30,229
this will mean that your product is

465
00:20:26,359 --> 00:20:33,708
secure<font color="#E5E5E5"> okay what we propose is to use</font>

466
00:20:30,229 --> 00:20:35,329
<font color="#CCCCCC">something called the Welch's t-test so</font>

467
00:20:33,709 --> 00:20:37,819
what you do is you have sample

468
00:20:35,329 --> 00:20:40,698
populations that you're going<font color="#CCCCCC"> to compare</font>

469
00:20:37,819 --> 00:20:43,369
<font color="#E5E5E5">you have two different samples you have</font>

470
00:20:40,699 --> 00:20:45,649
their mean you have their standard

471
00:20:43,369 --> 00:20:47,329
deviations you have you compute the t

472
00:20:45,649 --> 00:20:50,569
value for that which is<font color="#E5E5E5"> the equation on</font>

473
00:20:47,329 --> 00:20:53,029
the right and then what you're trying to

474
00:20:50,569 --> 00:20:56,119
do is to<font color="#E5E5E5"> assess whether there is any</font>

475
00:20:53,029 --> 00:20:57,709
significance indeed when you observe two

476
00:20:56,119 --> 00:20:59,718
different<font color="#CCCCCC"> populations if there's any</font>

477
00:20:57,709 --> 00:21:02,149
significance in the difference of their

478
00:20:59,719 --> 00:21:04,009
<font color="#CCCCCC">meats remember DPA attack sorry about</font>

479
00:21:02,149 --> 00:21:05,779
comparing specs of traces to see if

480
00:21:04,009 --> 00:21:08,089
there's any difference<font color="#E5E5E5"> so here we're</font>

481
00:21:05,779 --> 00:21:10,940
trying<font color="#E5E5E5"> to assess if that difference</font>

482
00:21:08,089 --> 00:21:14,059
shows in the sense of not visually but

483
00:21:10,940 --> 00:21:15,889
statistically and if<font color="#E5E5E5"> that difference</font>

484
00:21:14,059 --> 00:21:18,979
means anything or not and<font color="#E5E5E5"> if it's below</font>

485
00:21:15,889 --> 00:21:22,488
a<font color="#E5E5E5"> certain threshold which is set here at</font>

486
00:21:18,979 --> 00:21:26,179
<font color="#E5E5E5">59 confidence so 4.5 times the standard</font>

487
00:21:22,489 --> 00:21:27,919
deviation then if you're below that it

488
00:21:26,179 --> 00:21:29,719
means that<font color="#CCCCCC"> you statistically can't see</font>

489
00:21:27,919 --> 00:21:31,429
any difference<font color="#E5E5E5"> between the two sets and</font>

490
00:21:29,719 --> 00:21:33,079
that's when you know there's no leak and

491
00:21:31,429 --> 00:21:35,089
if there's no leak then for sure you

492
00:21:33,079 --> 00:21:38,029
know that<font color="#CCCCCC"> you can't extract any keys out</font>

493
00:21:35,089 --> 00:21:40,759
<font color="#CCCCCC">of this what does require though is a</font>

494
00:21:38,029 --> 00:21:42,859
little bit of specific data sets and

495
00:21:40,759 --> 00:21:44,929
test vectors so you have to study the

496
00:21:42,859 --> 00:21:48,918
algorithms a little bit to figure out

497
00:21:44,929 --> 00:21:51,769
what the best test vectors are to try to

498
00:21:48,919 --> 00:21:54,259
find out where<font color="#CCCCCC"> the best attacks might be</font>

499
00:21:51,769 --> 00:21:56,779
and then standardized or define what

500
00:21:54,259 --> 00:21:59,149
those vectors are that you want to

501
00:21:56,779 --> 00:22:00,589
<font color="#E5E5E5">submit your product again there's</font>

502
00:21:59,149 --> 00:22:02,569
different techniques it takes a little

503
00:22:00,589 --> 00:22:06,158
bit<font color="#CCCCCC"> of time to explain all of that</font><font color="#E5E5E5"> but I</font>

504
00:22:02,569 --> 00:22:09,109
guess you<font color="#E5E5E5"> get the idea you for instance</font>

505
00:22:06,159 --> 00:22:09,810
you compare fixed<font color="#E5E5E5"> data against random</font>

506
00:22:09,109 --> 00:22:11,310
data run

507
00:22:09,810 --> 00:22:17,750
cheese etc<font color="#CCCCCC"> try to</font><font color="#E5E5E5"> see if there's any</font>

508
00:22:11,310 --> 00:22:21,450
difference<font color="#E5E5E5"> between those two sets okay</font>

509
00:22:17,750 --> 00:22:24,060
<font color="#E5E5E5">two independent data sets just tells you</font>

510
00:22:21,450 --> 00:22:25,680
that you need to collect quite some data

511
00:22:24,060 --> 00:22:28,290
so in order to have higher confidence

512
00:22:25,680 --> 00:22:30,620
what you can also do is collect two

513
00:22:28,290 --> 00:22:34,230
different data sets and run the<font color="#E5E5E5"> test</font>

514
00:22:30,620 --> 00:22:36,719
separately twice and then if both tests

515
00:22:34,230 --> 00:22:38,460
fail at the same point in time then for

516
00:22:36,720 --> 00:22:40,230
sure you know there is<font color="#CCCCCC"> a leak and if</font>

517
00:22:38,460 --> 00:22:43,940
they don't then you can decide<font color="#E5E5E5"> that</font>

518
00:22:40,230 --> 00:22:46,110
there is no leak from a vendor

519
00:22:43,940 --> 00:22:48,330
perspective the requirement is that you

520
00:22:46,110 --> 00:22:50,250
submit documentation to explain what

521
00:22:48,330 --> 00:22:52,939
your algorithm looks like what your

522
00:22:50,250 --> 00:22:55,200
modes and use cases are how you

523
00:22:52,940 --> 00:22:57,120
implement countermeasures what<font color="#CCCCCC"> you're</font>

524
00:22:55,200 --> 00:22:58,680
<font color="#CCCCCC">russian all is so that that doesn't</font>

525
00:22:57,120 --> 00:23:02,689
change too much but then you submit a

526
00:22:58,680 --> 00:23:05,400
device to<font color="#E5E5E5"> be tested which is able to</font>

527
00:23:02,690 --> 00:23:08,370
<font color="#E5E5E5">allow</font><font color="#CCCCCC"> the texture to set any keys that</font>

528
00:23:05,400 --> 00:23:10,710
he wants<font color="#E5E5E5"> that data the way you want</font>

529
00:23:08,370 --> 00:23:13,439
<font color="#CCCCCC">messages away in los trigger signals and</font>

530
00:23:10,710 --> 00:23:16,080
essentially run the standardized test

531
00:23:13,440 --> 00:23:18,510
vectors as this correct the other thing

532
00:23:16,080 --> 00:23:21,270
<font color="#CCCCCC">is that for this type of approach its</font>

533
00:23:18,510 --> 00:23:23,010
defined to be<font color="#E5E5E5"> time bandit and analysis</font>

534
00:23:21,270 --> 00:23:25,920
found it so you only get<font color="#CCCCCC"> a certain</font>

535
00:23:23,010 --> 00:23:28,070
number of data collection points let's

536
00:23:25,920 --> 00:23:30,120
say for one day<font color="#CCCCCC"> of measurement or</font>

537
00:23:28,070 --> 00:23:33,480
<font color="#CCCCCC">100,000 traces or something equivalent</font>

538
00:23:30,120 --> 00:23:35,459
and then you can only do bounded time

539
00:23:33,480 --> 00:23:37,140
analysis so that it's repeatable and

540
00:23:35,460 --> 00:23:40,560
measurable in<font color="#E5E5E5"> the same way on different</font>

541
00:23:37,140 --> 00:23:43,110
devices<font color="#E5E5E5"> okay so this is the kind of</font>

542
00:23:40,560 --> 00:23:45,210
approach that we<font color="#E5E5E5"> propose and let me tell</font>

543
00:23:43,110 --> 00:23:47,790
<font color="#CCCCCC">you a little</font><font color="#E5E5E5"> bit how far along we are in</font>

544
00:23:45,210 --> 00:23:55,140
the<font color="#E5E5E5"> last minute I guess what you minutes</font>

545
00:23:47,790 --> 00:23:56,820
15<font color="#CCCCCC"> okay 10</font><font color="#E5E5E5"> hahaha right so let me tell</font>

546
00:23:55,140 --> 00:23:59,940
you a<font color="#CCCCCC"> little bit how far along we are</font>

547
00:23:56,820 --> 00:24:02,280
with this initiative so in terms of

548
00:23:59,940 --> 00:24:05,160
standardization there are a different

549
00:24:02,280 --> 00:24:10,649
<font color="#E5E5E5">number of standards that try to look at</font>

550
00:24:05,160 --> 00:24:17,130
this approach I so won<font color="#CCCCCC"> 97 90 1788 225</font>

551
00:24:10,650 --> 00:24:19,590
and 2008 e5 with two parts the first one

552
00:24:17,130 --> 00:24:21,360
nineteen seventy nine zero is a pretty

553
00:24:19,590 --> 00:24:22,649
far along but there's a little<font color="#CCCCCC"> cat</font>

554
00:24:21,360 --> 00:24:25,678
yet at the<font color="#CCCCCC"> end let me try to explain</font>

555
00:24:22,650 --> 00:24:27,750
what that is so the<font color="#CCCCCC"> the standard is</font>

556
00:24:25,679 --> 00:24:29,580
defined security requirements for

557
00:24:27,750 --> 00:24:32,400
cryptographic modules it has<font color="#CCCCCC"> four</font>

558
00:24:29,580 --> 00:24:35,460
security security levels defined in

559
00:24:32,400 --> 00:24:37,890
<font color="#CCCCCC">Section 7.8 which talks about non visit</font>

560
00:24:35,460 --> 00:24:40,559
invasive<font color="#E5E5E5"> security read side-channel</font>

561
00:24:37,890 --> 00:24:42,390
attacks it says<font color="#E5E5E5"> that modules may</font>

562
00:24:40,559 --> 00:24:44,220
implement various techniques to mitigate

563
00:24:42,390 --> 00:24:46,470
against these types of attacks and then

564
00:24:44,220 --> 00:24:49,410
it goes<font color="#CCCCCC"> into describing litigation</font>

565
00:24:46,470 --> 00:24:51,750
techniques there's two types those that

566
00:24:49,410 --> 00:24:53,970
are not referenced in something called

567
00:24:51,750 --> 00:24:56,130
annex<font color="#CCCCCC"> F and there it says they will be</font>

568
00:24:53,970 --> 00:24:58,950
validated my requirements and associated

569
00:24:56,130 --> 00:25:02,669
tests are developed so future work not

570
00:24:58,950 --> 00:25:04,080
ready and then that there are the there

571
00:25:02,669 --> 00:25:06,150
are<font color="#CCCCCC"> the</font><font color="#E5E5E5"> ones that are referenced in</font>

572
00:25:04,080 --> 00:25:08,490
annex up and they have to meet<font color="#CCCCCC"> specific</font>

573
00:25:06,150 --> 00:25:10,919
requirements those requirements for

574
00:25:08,490 --> 00:25:13,290
level 3 and level 4 which are called

575
00:25:10,919 --> 00:25:17,070
<font color="#CCCCCC">three is called strong and four is</font>

576
00:25:13,290 --> 00:25:18,809
called stronger it says they shall be

577
00:25:17,070 --> 00:25:21,418
tested<font color="#CCCCCC"> to meet the approved non-invasive</font>

578
00:25:18,809 --> 00:25:24,360
<font color="#E5E5E5">attack mitigation test metrics reference</font>

579
00:25:21,419 --> 00:25:26,429
and annex eps great so far so<font color="#CCCCCC"> good and</font>

580
00:25:24,360 --> 00:25:28,500
then<font color="#CCCCCC"> you move on and you arrived at</font>

581
00:25:26,429 --> 00:25:30,750
<font color="#E5E5E5">annex and it says</font><font color="#CCCCCC"> approved non-invasive</font>

582
00:25:28,500 --> 00:25:33,030
<font color="#E5E5E5">attack mitigation test metrics and</font><font color="#CCCCCC"> very</font>

583
00:25:30,750 --> 00:25:35,100
says there are no approved non-invasive

584
00:25:33,030 --> 00:25:37,740
attack medication test metrics to find

585
00:25:35,100 --> 00:25:40,020
at this time so we're almost there we

586
00:25:37,740 --> 00:25:44,549
only just need to fill in<font color="#E5E5E5"> annex</font><font color="#CCCCCC"> f and</font>

587
00:25:40,020 --> 00:25:46,410
then we'll be done<font color="#E5E5E5"> okay but there is</font>

588
00:25:44,549 --> 00:25:48,360
actually another one which does define

589
00:25:46,410 --> 00:25:50,630
task metrics so that could be a link

590
00:25:48,360 --> 00:25:53,280
between the two at some point who knows

591
00:25:50,630 --> 00:25:55,440
this one is called<font color="#E5E5E5"> testing methods for</font>

592
00:25:53,280 --> 00:25:57,059
the mitigation of non-invasive attack

593
00:25:55,440 --> 00:26:00,110
classes with the<font color="#E5E5E5"> unscripted graphic</font>

594
00:25:57,059 --> 00:26:03,149
module so it does actually talk about

595
00:26:00,110 --> 00:26:06,540
test metrics for level security levels

596
00:26:03,150 --> 00:26:08,750
three and four as mentioned before it

597
00:26:06,540 --> 00:26:12,659
talks about side channels such as power

598
00:26:08,750 --> 00:26:14,280
electromagnetic timing attacks and it

599
00:26:12,660 --> 00:26:17,010
also leaves open the possibility for

600
00:26:14,280 --> 00:26:20,970
<font color="#E5E5E5">future side channels such as photon</font>

601
00:26:17,010 --> 00:26:23,220
emissions and acoustic signals and they

602
00:26:20,970 --> 00:26:25,770
describes how<font color="#E5E5E5"> to collect and analyze</font>

603
00:26:23,220 --> 00:26:27,540
measurements and it gives the<font color="#E5E5E5"> test</font>

604
00:26:25,770 --> 00:26:29,790
limitations that I talked<font color="#CCCCCC"> about before</font>

605
00:26:27,540 --> 00:26:32,370
as well so remember a test is limited in

606
00:26:29,790 --> 00:26:34,740
time it's limited in the number of

607
00:26:32,370 --> 00:26:36,959
waveforms so for<font color="#E5E5E5"> example</font>

608
00:26:34,740 --> 00:26:40,890
at level<font color="#CCCCCC"> three you can have six hours</font>

609
00:26:36,960 --> 00:26:44,220
maximum collection time per test and 72

610
00:26:40,890 --> 00:26:47,340
hours to<font color="#CCCCCC"> a liquidation time max with</font>

611
00:26:44,220 --> 00:26:50,540
10,000 wait for and level<font color="#E5E5E5"> 4 it's a</font>

612
00:26:47,340 --> 00:26:53,820
little bit more it's 24 hours per test

613
00:26:50,540 --> 00:26:57,090
288 hours maximum total acquisition time

614
00:26:53,820 --> 00:26:58,620
and hundred thousand waveforms and then

615
00:26:57,090 --> 00:27:01,050
when you've done all your test the test

616
00:26:58,620 --> 00:27:03,000
will fail as a bias exceeds<font color="#E5E5E5"> specific</font>

617
00:27:01,050 --> 00:27:06,120
leakage threshold and otherwise your

618
00:27:03,000 --> 00:27:08,970
device passes<font color="#CCCCCC"> okay so we're almost there</font>

619
00:27:06,120 --> 00:27:13,709
we just need to link this here with this

620
00:27:08,970 --> 00:27:15,809
one then there's two more one more

621
00:27:13,710 --> 00:27:18,300
center that has two parts in it but this

622
00:27:15,809 --> 00:27:20,309
one spell on your development and to be

623
00:27:18,300 --> 00:27:22,230
complete in this world you<font color="#E5E5E5"> also</font><font color="#CCCCCC"> have</font>

624
00:27:20,309 --> 00:27:24,080
tools and<font color="#E5E5E5"> these tools also have to be</font>

625
00:27:22,230 --> 00:27:26,809
<font color="#E5E5E5">calibrated and these tools have</font>

626
00:27:24,080 --> 00:27:30,750
requirements to them so there's this

627
00:27:26,809 --> 00:27:33,000
third one which talks about how<font color="#E5E5E5"> to</font>

628
00:27:30,750 --> 00:27:35,220
define test tools and test techniques

629
00:27:33,000 --> 00:27:37,500
and how they should work and how should

630
00:27:35,220 --> 00:27:39,929
they should<font color="#E5E5E5"> get calibrated and what that</font>

631
00:27:37,500 --> 00:27:44,270
apparatus should look like essentially

632
00:27:39,929 --> 00:27:48,110
<font color="#CCCCCC">okay so we're almost full circle and</font>

633
00:27:44,270 --> 00:27:52,080
<font color="#E5E5E5">this is let me speak</font><font color="#CCCCCC"> skip about that one</font>

634
00:27:48,110 --> 00:27:55,770
and<font color="#CCCCCC"> that leads me leads me to my</font>

635
00:27:52,080 --> 00:27:57,720
<font color="#CCCCCC">conclusion so we're almost there what</font>

636
00:27:55,770 --> 00:27:59,340
I've shown and this presentation is a

637
00:27:57,720 --> 00:28:01,110
protocol level come to measure for the

638
00:27:59,340 --> 00:28:04,139
real well when you can't change anything

639
00:28:01,110 --> 00:28:06,000
but it still makes your device secure if

640
00:28:04,140 --> 00:28:07,950
you're able to change the protocol of

641
00:28:06,000 --> 00:28:09,390
course sometimes that's<font color="#CCCCCC"> not possible but</font>

642
00:28:07,950 --> 00:28:12,090
if you can this is<font color="#E5E5E5"> a really nice</font>

643
00:28:09,390 --> 00:28:14,760
approach it allowed to use standard

644
00:28:12,090 --> 00:28:16,199
legacy crypto cores and crypto software

645
00:28:14,760 --> 00:28:19,470
<font color="#CCCCCC">no changes needed</font><font color="#E5E5E5"> in the implementation</font>

646
00:28:16,200 --> 00:28:21,690
and the second part i talked about

647
00:28:19,470 --> 00:28:25,470
alternative statistical side channel

648
00:28:21,690 --> 00:28:28,770
resistance testing approaches<font color="#CCCCCC"> called TV</font>

649
00:28:25,470 --> 00:28:31,140
<font color="#CCCCCC">la which is undergoing standardization</font>

650
00:28:28,770 --> 00:28:33,240
at this point and you can find<font color="#E5E5E5"> in the</font>

651
00:28:31,140 --> 00:28:35,970
two<font color="#E5E5E5"> links below here on either our</font>

652
00:28:33,240 --> 00:28:39,830
website or at the upcoming international

653
00:28:35,970 --> 00:28:41,970
crypto module conference you<font color="#E5E5E5"> can find</font>

654
00:28:39,830 --> 00:28:43,980
documents that show you what these test

655
00:28:41,970 --> 00:28:46,119
vectors look like and<font color="#CCCCCC"> there's</font>

656
00:28:43,980 --> 00:28:50,739
<font color="#E5E5E5">documentation for</font>

657
00:28:46,119 --> 00:28:53,458
<font color="#E5E5E5">tes sha when used in</font><font color="#CCCCCC"> hmf mode RSA</font>

658
00:28:50,739 --> 00:29:03,819
elliptic curve and so on<font color="#E5E5E5"> and I guess I'm</font>

659
00:28:53,459 --> 00:29:05,229
almost on time that's it thank<font color="#E5E5E5"> you okay</font>

660
00:29:03,819 --> 00:29:09,059
Greg you're standing between us and

661
00:29:05,229 --> 00:29:12,129
coughing so you get one question in your

662
00:29:09,059 --> 00:29:14,259
authenticated encryption model you

663
00:29:12,129 --> 00:29:16,418
needed everything started<font color="#CCCCCC"> with the</font>

664
00:29:14,259 --> 00:29:18,219
random message number yeah and and the

665
00:29:16,419 --> 00:29:21,039
current<font color="#CCCCCC"> direction is to try and get away</font>

666
00:29:18,219 --> 00:29:24,189
<font color="#CCCCCC">from the necessity for randomized</font>

667
00:29:21,039 --> 00:29:26,649
ivories rather than<font color="#CCCCCC"> count that nonces or</font>

668
00:29:24,189 --> 00:29:28,239
you know whatever and of course the

669
00:29:26,649 --> 00:29:29,859
usual solution to that is he just

670
00:29:28,239 --> 00:29:31,629
encrypt to counter and now it's or not

671
00:29:29,859 --> 00:29:34,329
and now<font color="#E5E5E5"> it's randomized or it looks</font>

672
00:29:31,629 --> 00:29:37,049
randomized except that doesn't work for

673
00:29:34,329 --> 00:29:39,099
<font color="#CCCCCC">you crazy so do</font><font color="#E5E5E5"> you have a scheme for</font>

674
00:29:37,049 --> 00:29:41,229
randomizing for coming<font color="#E5E5E5"> up</font><font color="#CCCCCC"> with good</font>

675
00:29:39,099 --> 00:29:43,899
randomized message numbers right so I

676
00:29:41,229 --> 00:29:45,699
said randomized but what I actually mean

677
00:29:43,899 --> 00:29:47,829
is that just has to<font color="#E5E5E5"> be unique / message</font>

678
00:29:45,699 --> 00:29:49,569
<font color="#E5E5E5">you don't want to repeat per message so</font>

679
00:29:47,829 --> 00:29:51,789
you could just<font color="#E5E5E5"> use a counter to record</font>

680
00:29:49,569 --> 00:29:55,389
<font color="#CCCCCC">okay yeah well no need to encrypt it</font>

681
00:29:51,789 --> 00:29:58,629
because otherwise yes taken an excited

682
00:29:55,389 --> 00:30:01,418
just the countersign<font color="#CCCCCC"> I was just</font>

683
00:29:58,629 --> 00:30:05,049
<font color="#CCCCCC">wondering from this test vector analysis</font>

684
00:30:01,419 --> 00:30:07,059
for<font color="#CCCCCC"> a power if you so it's not like</font>

685
00:30:05,049 --> 00:30:08,979
degenerating the test vectors is still

686
00:30:07,059 --> 00:30:10,899
sort of a manual like look at the

687
00:30:08,979 --> 00:30:12,609
<font color="#E5E5E5">algorithm and figure it out if you</font>

688
00:30:10,899 --> 00:30:14,968
looked at automated methods for

689
00:30:12,609 --> 00:30:19,269
determining the<font color="#E5E5E5"> worst-case test vectors</font>

690
00:30:14,969 --> 00:30:23,199
in order to then have that<font color="#E5E5E5"> be the</font>

691
00:30:19,269 --> 00:30:25,929
standardized<font color="#E5E5E5"> test well so I described it</font>

692
00:30:23,199 --> 00:30:27,519
a little bit as magic right you have to

693
00:30:25,929 --> 00:30:28,869
<font color="#E5E5E5">look at</font><font color="#CCCCCC"> the at the algorithm and find</font>

694
00:30:27,519 --> 00:30:31,869
the best<font color="#E5E5E5"> one so you</font><font color="#CCCCCC"> can actually be very</font>

695
00:30:28,869 --> 00:30:34,478
systematic but that will make an a quite

696
00:30:31,869 --> 00:30:36,639
big number<font color="#CCCCCC"> of pests right you could look</font>

697
00:30:34,479 --> 00:30:40,449
at each bit at each bite at each output

698
00:30:36,639 --> 00:30:43,688
at each round etc things like<font color="#E5E5E5"> that so</font>

699
00:30:40,449 --> 00:30:45,939
you want to<font color="#E5E5E5"> be a little</font><font color="#CCCCCC"> bit more precise</font>

700
00:30:43,689 --> 00:30:47,469
and and faster and that's why<font color="#CCCCCC"> we look</font><font color="#E5E5E5"> at</font>

701
00:30:45,939 --> 00:30:49,119
the algorithms but you could have<font color="#E5E5E5"> you</font>

702
00:30:47,469 --> 00:30:51,249
could do them all it would take<font color="#E5E5E5"> a little</font>

703
00:30:49,119 --> 00:30:53,379
bit long time there's certainly room for

704
00:30:51,249 --> 00:30:54,279
research<font color="#CCCCCC"> to will such thing</font><font color="#E5E5E5"> I guess I</font>

705
00:30:53,379 --> 00:30:57,429
was wondering if you could use

706
00:30:54,279 --> 00:31:00,190
<font color="#E5E5E5">simulators or something to with</font>

707
00:30:57,430 --> 00:31:04,240
exhausting the space determine maybe not

708
00:31:00,190 --> 00:31:06,700
the worst case but fine bad test vectors

709
00:31:04,240 --> 00:31:08,740
that you can test on you I think<font color="#E5E5E5"> that</font>

710
00:31:06,700 --> 00:31:11,230
pretty much relates to crypt analysis so

711
00:31:08,740 --> 00:31:12,760
I think<font color="#CCCCCC"> there's room to go together so</font>

712
00:31:11,230 --> 00:31:14,560
if you could analyze the algorithm

713
00:31:12,760 --> 00:31:16,240
you'll figure out what the words test

714
00:31:14,560 --> 00:31:20,290
vectors are that he could submit this

715
00:31:16,240 --> 00:31:20,850
thing too yep<font color="#E5E5E5"> okay look thanks Linda</font>

716
00:31:20,290 --> 00:31:27,320
again

717
00:31:20,850 --> 00:31:27,320
[Applause]

