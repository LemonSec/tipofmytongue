1
00:00:00,000 --> 00:00:04,710
<font color="#CCCCCC">alright think so</font><font color="#E5E5E5"> I'm excited to tell you</font>

2
00:00:02,340 --> 00:00:06,870
about data independence memory hard

3
00:00:04,710 --> 00:00:09,540
functions<font color="#E5E5E5"> I should mention this is joint</font>

4
00:00:06,870 --> 00:00:12,660
work with colleagues that<font color="#CCCCCC"> are</font>

5
00:00:09,540 --> 00:00:16,500
collaborators<font color="#E5E5E5"> at asda</font><font color="#CCCCCC"> austria joelle all</font>

6
00:00:12,660 --> 00:00:18,539
<font color="#E5E5E5">in and</font><font color="#CCCCCC"> Christoph so you might think</font><font color="#E5E5E5"> it's</font>

7
00:00:16,500 --> 00:00:21,630
a little bit odd to have the title

8
00:00:18,539 --> 00:00:24,210
theory in<font color="#E5E5E5"> the slide set of real world</font>

9
00:00:21,630 --> 00:00:28,349
crypto conference but<font color="#E5E5E5"> let me promise you</font>

10
00:00:24,210 --> 00:00:30,109
this is about very real world problem so

11
00:00:28,349 --> 00:00:33,920
consider the problem of password storage

12
00:00:30,109 --> 00:00:36,210
in particular suppose that<font color="#E5E5E5"> an attacker</font>

13
00:00:33,920 --> 00:00:38,969
manages to break into the server and

14
00:00:36,210 --> 00:00:42,210
feel the hash value<font color="#E5E5E5"> now we can try an</font>

15
00:00:38,969 --> 00:00:43,530
offline attack in which he compares the

16
00:00:42,210 --> 00:00:47,160
hash<font color="#CCCCCC"> value against the hashes of</font>

17
00:00:43,530 --> 00:00:50,700
multiple passwords in a large dictionary

18
00:00:47,160 --> 00:00:53,819
right and these attacks are increasingly

19
00:00:50,700 --> 00:00:56,010
commonplace so this was my wallet shame

20
00:00:53,820 --> 00:00:58,260
as of a couple years ago and this<font color="#E5E5E5"> is the</font>

21
00:00:56,010 --> 00:01:01,440
wall that just keeps growing and growing

22
00:00:58,260 --> 00:01:04,530
and<font color="#E5E5E5"> growing so now I can claim that</font>

23
00:01:01,440 --> 00:01:08,700
billions of user accounts have been been

24
00:01:04,530 --> 00:01:10,500
affected by these attacks not only is

25
00:01:08,700 --> 00:01:13,320
this a common<font color="#E5E5E5"> problem it's the</font>

26
00:01:10,500 --> 00:01:15,810
increasingly dangerous problem so if<font color="#CCCCCC"> you</font>

27
00:01:13,320 --> 00:01:18,630
<font color="#E5E5E5">log into amazon right now and search for</font>

28
00:01:15,810 --> 00:01:21,299
<font color="#E5E5E5">the</font><font color="#CCCCCC"> aunt minor s9 you could purchase</font>

29
00:01:18,630 --> 00:01:25,199
this machine for about three thousand

30
00:01:21,299 --> 00:01:29,790
dollars and this machine can compute 14

31
00:01:25,200 --> 00:01:32,009
trillion<font color="#CCCCCC"> sha256 hashes per second that's</font>

32
00:01:29,790 --> 00:01:34,409
a lot<font color="#CCCCCC"> of property taxes per second my</font>

33
00:01:32,009 --> 00:01:36,869
guess<font color="#CCCCCC"> is that most user passwords are</font>

34
00:01:34,409 --> 00:01:40,729
not going<font color="#E5E5E5"> to stand up to to this level</font>

35
00:01:36,869 --> 00:01:43,020
of attack in<font color="#E5E5E5"> particular this is what</font>

36
00:01:40,729 --> 00:01:45,780
what the user password distribution

37
00:01:43,020 --> 00:01:48,780
looks like at the<font color="#CCCCCC"> moment</font><font color="#E5E5E5"> people continue</font>

38
00:01:45,780 --> 00:01:51,270
<font color="#E5E5E5">to select weak passwords you know</font>

39
00:01:48,780 --> 00:01:53,460
despite decades of warning so it's

40
00:01:51,270 --> 00:01:55,920
difficult<font color="#CCCCCC"> to</font><font color="#E5E5E5"> create a number heart high</font>

41
00:01:53,460 --> 00:01:58,320
entropy passwords so we seem to be<font color="#E5E5E5"> stuck</font>

42
00:01:55,920 --> 00:02:01,890
in a world where users continue to

43
00:01:58,320 --> 00:02:03,960
select low entropy passwords so this

44
00:02:01,890 --> 00:02:07,500
motivates the goal of developing

45
00:02:03,960 --> 00:02:09,568
moderately expensive hash functions so

46
00:02:07,500 --> 00:02:11,790
we have to kind of contradictory

47
00:02:09,568 --> 00:02:13,410
requirements here we want a function

48
00:02:11,790 --> 00:02:16,109
that can be computed fast

49
00:02:13,410 --> 00:02:17,850
on your own<font color="#E5E5E5"> personal computer and we</font>

50
00:02:16,110 --> 00:02:20,160
also want<font color="#E5E5E5"> a function</font><font color="#CCCCCC"> that's expensive</font>

51
00:02:17,850 --> 00:02:21,600
for the adversary to compute even on

52
00:02:20,160 --> 00:02:28,020
customized hardware that he might

53
00:02:21,600 --> 00:02:30,660
purchase like that<font color="#E5E5E5"> ant minor s9 so one</font>

54
00:02:28,020 --> 00:02:32,550
of the promising techniques to to

55
00:02:30,660 --> 00:02:35,130
achieve both bowls is memory<font color="#E5E5E5"> hard</font>

56
00:02:32,550 --> 00:02:36,720
functions in particular memory costs

57
00:02:35,130 --> 00:02:39,570
tend to be equitable across different

58
00:02:36,720 --> 00:02:42,450
architectures the cost of you know

59
00:02:39,570 --> 00:02:44,519
building in a gigabyte of RAM on an

60
00:02:42,450 --> 00:02:46,920
<font color="#CCCCCC">ethnic is not dramatically lower than</font>

61
00:02:44,520 --> 00:02:50,580
the cost of<font color="#E5E5E5"> just purchasing a gigabyte</font>

62
00:02:46,920 --> 00:02:54,630
of<font color="#E5E5E5"> RAM for your personal computer</font><font color="#CCCCCC"> all</font>

63
00:02:50,580 --> 00:02:57,330
<font color="#CCCCCC">right so let</font><font color="#E5E5E5"> me know introduce data</font>

64
00:02:54,630 --> 00:02:59,359
independent memory<font color="#E5E5E5"> hard functions first</font>

65
00:02:57,330 --> 00:03:02,250
let's<font color="#E5E5E5"> talk about memory hard functions</font>

66
00:02:59,360 --> 00:03:03,990
alright so the intuition what's the

67
00:03:02,250 --> 00:03:06,150
memory heart function it's a function

68
00:03:03,990 --> 00:03:09,240
<font color="#E5E5E5">whose computation costs are dominated by</font>

69
00:03:06,150 --> 00:03:11,430
memory<font color="#CCCCCC"> cost so it is</font><font color="#E5E5E5"> infused a password</font>

70
00:03:09,240 --> 00:03:14,460
hash once we<font color="#E5E5E5"> want to force the attacker</font>

71
00:03:11,430 --> 00:03:17,250
to lock up a large amount of memory for

72
00:03:14,460 --> 00:03:19,709
a long period of time so in particular

73
00:03:17,250 --> 00:03:21,630
we'd like to attack her to lock up you

74
00:03:19,709 --> 00:03:24,209
know all this memory as opposed to<font color="#CCCCCC"> just</font>

75
00:03:21,630 --> 00:03:28,049
using hash iteration and locking up a

76
00:03:24,209 --> 00:03:33,150
very small processing unit for a short

77
00:03:28,050 --> 00:03:36,390
window time so<font color="#CCCCCC"> s crypt is one classical</font>

78
00:03:33,150 --> 00:03:39,209
example of a memory hard function and

79
00:03:36,390 --> 00:03:41,760
the next talk will actually give some

80
00:03:39,209 --> 00:03:44,100
positive exciting new positive<font color="#E5E5E5"> results</font>

81
00:03:41,760 --> 00:03:47,760
for a script one of the downsides with s

82
00:03:44,100 --> 00:03:50,400
crypto is that s stress induces a data

83
00:03:47,760 --> 00:03:52,049
dependent memory access pattern that

84
00:03:50,400 --> 00:03:54,480
means<font color="#E5E5E5"> that the pattern in which memory</font>

85
00:03:52,050 --> 00:03:56,660
is access depends on the sensitive user

86
00:03:54,480 --> 00:03:59,899
input in this<font color="#E5E5E5"> case the users password</font>

87
00:03:56,660 --> 00:04:02,100
why is this a problem well it<font color="#E5E5E5"> means that</font>

88
00:03:59,900 --> 00:04:04,530
potentially the password is vulnerable

89
00:04:02,100 --> 00:04:08,700
to side channel attack for example cash

90
00:04:04,530 --> 00:04:11,070
climbing attacks so a data independent

91
00:04:08,700 --> 00:04:13,140
memory heart function is simply<font color="#E5E5E5"> a memory</font>

92
00:04:11,070 --> 00:04:15,600
hard function whose memory access

93
00:04:13,140 --> 00:04:19,409
pattern does not depend<font color="#E5E5E5"> on the secret</font>

94
00:04:15,600 --> 00:04:21,120
user input and in this case if we<font color="#E5E5E5"> use</font>

95
00:04:19,410 --> 00:04:22,710
opted data independent memory card

96
00:04:21,120 --> 00:04:25,940
functions then we don't<font color="#E5E5E5"> have</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> worry</font>

97
00:04:22,710 --> 00:04:25,940
about these side-channel attacks

98
00:04:26,270 --> 00:04:31,469
<font color="#E5E5E5">alright so formally what is a data</font>

99
00:04:29,430 --> 00:04:32,940
independent memory<font color="#CCCCCC"> hard function well a</font>

100
00:04:31,470 --> 00:04:35,699
data independent memory heart function

101
00:04:32,940 --> 00:04:39,960
is defined by two<font color="#E5E5E5"> things directed</font>

102
00:04:35,699 --> 00:04:42,780
acyclic graph G which specifies data

103
00:04:39,960 --> 00:04:45,508
dependencies during<font color="#CCCCCC"> computations and the</font>

104
00:04:42,780 --> 00:04:48,419
compression function H which will treat

105
00:04:45,509 --> 00:04:51,120
as a random<font color="#E5E5E5"> Oracle in our analysis so</font>

106
00:04:48,419 --> 00:04:53,490
given<font color="#CCCCCC"> a graph as follows how do</font><font color="#E5E5E5"> we</font>

107
00:04:51,120 --> 00:04:56,190
compute this function well the input is

108
00:04:53,490 --> 00:04:58,289
the password in the<font color="#CCCCCC"> fault the label of</font>

109
00:04:56,190 --> 00:05:00,840
the<font color="#E5E5E5"> first node is just the hash of the</font>

110
00:04:58,289 --> 00:05:03,360
password in the salt the label<font color="#CCCCCC"> of an</font>

111
00:05:00,840 --> 00:05:05,698
internal<font color="#E5E5E5"> node is the hash of its parent</font>

112
00:05:03,360 --> 00:05:08,210
so in this case the label of snowed<font color="#CCCCCC"> 3 is</font>

113
00:05:05,699 --> 00:05:10,560
a hash of label<font color="#E5E5E5"> to and label 1 and</font>

114
00:05:08,210 --> 00:05:14,960
finally the output of this function<font color="#E5E5E5"> is</font>

115
00:05:10,560 --> 00:05:18,419
label of the last node the sink node

116
00:05:14,960 --> 00:05:21,060
<font color="#CCCCCC">alright so so to talk about computing</font>

117
00:05:18,419 --> 00:05:23,219
data independent memory hard function we

118
00:05:21,060 --> 00:05:25,500
can<font color="#E5E5E5"> use the language of graft coupling</font>

119
00:05:23,220 --> 00:05:27,840
in this<font color="#E5E5E5"> case placing a pebble on a node</font>

120
00:05:25,500 --> 00:05:30,110
means that we compute the corresponding

121
00:05:27,840 --> 00:05:32,520
data value and store it in memory

122
00:05:30,110 --> 00:05:34,800
removing a pebble from a note means that

123
00:05:32,520 --> 00:05:36,599
we free that value from memory<font color="#E5E5E5"> and of</font>

124
00:05:34,800 --> 00:05:40,229
course<font color="#CCCCCC"> our goal is to place a pebble on</font>

125
00:05:36,599 --> 00:05:42,960
the last node compute the final value of

126
00:05:40,229 --> 00:05:45,960
course there are rules that guide guide

127
00:05:42,960 --> 00:05:48,180
the puddling in particular<font color="#E5E5E5"> we can't just</font>

128
00:05:45,960 --> 00:05:50,909
place a pebble on the graphs at any

129
00:05:48,180 --> 00:05:53,610
point in<font color="#E5E5E5"> time we can only compute a</font>

130
00:05:50,909 --> 00:05:56,610
value if we have all the dependence data

131
00:05:53,610 --> 00:05:59,159
values in memory<font color="#CCCCCC"> so we can only place a</font>

132
00:05:56,610 --> 00:06:01,470
new pebble in the crap at time<font color="#E5E5E5"> stuff I</font>

133
00:05:59,159 --> 00:06:05,370
if at the<font color="#E5E5E5"> previous time step we had</font>

134
00:06:01,470 --> 00:06:07,770
troubles on both of<font color="#E5E5E5"> its parents all</font>

135
00:06:05,370 --> 00:06:09,180
right and of course the final

136
00:06:07,770 --> 00:06:11,159
requirement is that we have to<font color="#CCCCCC"> finish</font>

137
00:06:09,180 --> 00:06:14,820
doubling let's graph eventually our goal

138
00:06:11,159 --> 00:06:17,370
is to compute<font color="#E5E5E5"> the output</font><font color="#CCCCCC"> all right so so</font>

139
00:06:14,820 --> 00:06:19,080
here's an example<font color="#E5E5E5"> of coupling a very</font>

140
00:06:17,370 --> 00:06:21,720
simple you<font color="#E5E5E5"> start off with no couples on</font>

141
00:06:19,080 --> 00:06:24,599
the graph we can<font color="#E5E5E5"> start off by putting a</font>

142
00:06:21,720 --> 00:06:26,550
pebble on node1 now we can<font color="#E5E5E5"> place a tub</font>

143
00:06:24,599 --> 00:06:28,199
one<font color="#CCCCCC"> node two though it can place a</font>

144
00:06:26,550 --> 00:06:30,509
couple on those three<font color="#E5E5E5"> at the same time</font>

145
00:06:28,199 --> 00:06:33,779
we might want to free up these two

146
00:06:30,509 --> 00:06:36,120
values so<font color="#CCCCCC"> states memory now</font><font color="#E5E5E5"> I can place</font>

147
00:06:33,779 --> 00:06:37,520
a pebble one note<font color="#E5E5E5"> for and now that we</font>

148
00:06:36,120 --> 00:06:40,280
have pebbles on those<font color="#E5E5E5"> three and four</font>

149
00:06:37,520 --> 00:06:43,818
we can place<font color="#CCCCCC"> a</font><font color="#E5E5E5"> pebble on node 5 all</font>

150
00:06:40,280 --> 00:06:47,030
<font color="#E5E5E5">right so pretty straightforward all</font>

151
00:06:43,819 --> 00:06:50,330
<font color="#E5E5E5">right so recall</font><font color="#CCCCCC"> that our goal was to</font>

152
00:06:47,030 --> 00:06:53,900
force the attacker to lock up a large

153
00:06:50,330 --> 00:06:56,599
amount of space for a long time so how

154
00:06:53,900 --> 00:06:59,419
do we formalize this requirement well

155
00:06:56,599 --> 00:07:02,120
the first attempt is<font color="#CCCCCC"> space-time</font>

156
00:06:59,419 --> 00:07:04,039
<font color="#CCCCCC">complexity so we say that the space time</font>

157
00:07:02,120 --> 00:07:06,590
complexity of a particular pebble Inc

158
00:07:04,039 --> 00:07:10,669
strategy it's just the number of public

159
00:07:06,590 --> 00:07:13,429
steps x the maximum<font color="#CCCCCC"> number of pebbles on</font>

160
00:07:10,669 --> 00:07:16,818
<font color="#CCCCCC">the graph at any point in</font><font color="#E5E5E5"> time this is</font>

161
00:07:13,430 --> 00:07:20,330
kind of the<font color="#E5E5E5"> space that you use</font><font color="#CCCCCC"> all right</font>

162
00:07:16,819 --> 00:07:23,000
so this is a nice nice notion and<font color="#E5E5E5"> it has</font>

163
00:07:20,330 --> 00:07:25,370
a rich theory but I claim<font color="#CCCCCC"> that this is</font>

164
00:07:23,000 --> 00:07:28,849
not an appropriate<font color="#E5E5E5"> metrics for password</font>

165
00:07:25,370 --> 00:07:31,789
hashing why do<font color="#CCCCCC"> I claim that</font><font color="#E5E5E5"> well the</font>

166
00:07:28,849 --> 00:07:33,710
problem is for parallel computations SP

167
00:07:31,789 --> 00:07:36,740
complexity can scale badly and the

168
00:07:33,710 --> 00:07:38,930
number of evaluations of a function so

169
00:07:36,740 --> 00:07:41,990
suppose for example we have a<font color="#CCCCCC"> function</font>

170
00:07:38,930 --> 00:07:44,900
where we need a lot of<font color="#E5E5E5"> space initially</font>

171
00:07:41,990 --> 00:07:46,340
to compute<font color="#CCCCCC"> the function but we only need</font>

172
00:07:44,900 --> 00:07:50,210
a lot<font color="#CCCCCC"> of space for a very short period</font>

173
00:07:46,340 --> 00:07:53,029
of time so in particular space look like

174
00:07:50,210 --> 00:07:55,940
this so this blue curve well in this

175
00:07:53,029 --> 00:07:59,389
<font color="#E5E5E5">case the SP complexity of the evaluation</font>

176
00:07:55,940 --> 00:08:01,159
strategy is quite high but if we wanted

177
00:07:59,389 --> 00:08:03,710
<font color="#CCCCCC">to evaluate multiple instances of</font>

178
00:08:01,159 --> 00:08:06,139
multiple instances of the functions we

179
00:08:03,710 --> 00:08:08,330
could simply pipeline and evaluate

180
00:08:06,139 --> 00:08:11,139
multiple instances in parallel without

181
00:08:08,330 --> 00:08:14,330
increasing space time complexity in

182
00:08:11,139 --> 00:08:16,810
particular there<font color="#E5E5E5"> exist functions where</font>

183
00:08:14,330 --> 00:08:19,460
you can evaluate up to square root n

184
00:08:16,810 --> 00:08:22,639
instances of the memory heart functions

185
00:08:19,460 --> 00:08:29,270
without increasing space time complexity

186
00:08:22,639 --> 00:08:32,810
at all<font color="#CCCCCC"> alright so so this motivates the</font>

187
00:08:29,270 --> 00:08:35,120
need for cameos complexity as defined by

188
00:08:32,809 --> 00:08:37,159
all<font color="#E5E5E5"> wind and turban</font><font color="#CCCCCC"> anko tema de</font>

189
00:08:35,120 --> 00:08:38,690
complexity is just the integral under

190
00:08:37,159 --> 00:08:40,909
this curve so it's the<font color="#E5E5E5"> sum</font><font color="#CCCCCC"> over all</font>

191
00:08:38,690 --> 00:08:43,270
coupling steps of the number<font color="#E5E5E5"> of</font><font color="#CCCCCC"> pebbles</font>

192
00:08:40,909 --> 00:08:46,040
on the graph at that point in time<font color="#E5E5E5"> oh</font>

193
00:08:43,270 --> 00:08:48,319
what's nice about this metric well a

194
00:08:46,040 --> 00:08:49,920
couple<font color="#CCCCCC"> things the first thing is</font>

195
00:08:48,320 --> 00:08:52,260
amortization

196
00:08:49,920 --> 00:08:54,569
so the cumulative cost of troubling to

197
00:08:52,260 --> 00:08:56,250
independent instances of the<font color="#CCCCCC"> graph it's</font>

198
00:08:54,570 --> 00:08:58,139
just two times the cost of<font color="#E5E5E5"> coupling one</font>

199
00:08:56,250 --> 00:08:59,880
instance of the graph so this means that

200
00:08:58,139 --> 00:09:01,290
the attackers costs are going<font color="#E5E5E5"> to scale</font>

201
00:08:59,880 --> 00:09:06,149
with a number of password guesses that

202
00:09:01,290 --> 00:09:08,329
he wants to try<font color="#E5E5E5"> all right so this is a</font>

203
00:09:06,149 --> 00:09:11,459
nice metric how does it work well

204
00:09:08,329 --> 00:09:12,930
remember<font color="#E5E5E5"> our previous cuddling here what</font>

205
00:09:11,459 --> 00:09:15,540
would the cost of this doubling be it's

206
00:09:12,930 --> 00:09:21,359
just one plus two plus one plus two plus

207
00:09:15,540 --> 00:09:23,459
one or seven total<font color="#E5E5E5"> all right another</font>

208
00:09:21,360 --> 00:09:25,980
reason<font color="#CCCCCC"> why this notion is nice is</font>

209
00:09:23,459 --> 00:09:27,660
because there's a nice equivalence

210
00:09:25,980 --> 00:09:30,779
established by all<font color="#CCCCCC"> an absorbent a fail</font>

211
00:09:27,660 --> 00:09:34,500
again informally on at a very high level

212
00:09:30,779 --> 00:09:37,290
a high pebble<font color="#CCCCCC"> in complexity of</font><font color="#E5E5E5"> G implies</font>

213
00:09:34,500 --> 00:09:40,910
that the original memory<font color="#E5E5E5"> hard function</font>

214
00:09:37,290 --> 00:09:44,790
has high amortized memory complexity

215
00:09:40,910 --> 00:09:45,930
right so it's<font color="#CCCCCC"> sufficient to just reason</font>

216
00:09:44,790 --> 00:09:49,260
about the structure of the<font color="#E5E5E5"> underlying</font>

217
00:09:45,930 --> 00:09:54,269
graph to think it to prove security of

218
00:09:49,260 --> 00:09:57,180
the underlying I mhm alright so that's

219
00:09:54,269 --> 00:09:59,370
humid of complexity since this is<font color="#E5E5E5"> real</font>

220
00:09:57,180 --> 00:10:02,099
world crypto will move one step farther

221
00:09:59,370 --> 00:10:04,920
and actually introduce some other

222
00:10:02,100 --> 00:10:07,850
constants that theoreticians generally

223
00:10:04,920 --> 00:10:10,529
don't like to think about in particular

224
00:10:07,850 --> 00:10:12,480
we not only have to allocate space to

225
00:10:10,529 --> 00:10:15,240
evaluate so the function we also have<font color="#E5E5E5"> to</font>

226
00:10:12,480 --> 00:10:18,360
have<font color="#E5E5E5"> some coors</font><font color="#CCCCCC"> on chip to evaluate this</font>

227
00:10:15,240 --> 00:10:21,120
hash<font color="#E5E5E5"> function so here the content are</font>

228
00:10:18,360 --> 00:10:26,610
here is<font color="#E5E5E5"> just the space required to store</font>

229
00:10:21,120 --> 00:10:28,860
a random Oracle core on ship so I a

230
00:10:26,610 --> 00:10:31,620
theoretical level you know this doesn't

231
00:10:28,860 --> 00:10:35,040
change that and products of of the

232
00:10:31,620 --> 00:10:37,440
function but it'll bring us closer

233
00:10:35,040 --> 00:10:40,579
closer to reality when we when we

234
00:10:37,440 --> 00:10:45,540
evaluate these functions all right arm

235
00:10:40,579 --> 00:10:47,760
so now that<font color="#CCCCCC"> I told you how to how to</font>

236
00:10:45,540 --> 00:10:50,490
evaluate the security of the<font color="#CCCCCC"> I am a chef</font>

237
00:10:47,760 --> 00:10:53,160
so let's think<font color="#CCCCCC"> about coupling algorithm</font>

238
00:10:50,490 --> 00:10:55,260
<font color="#E5E5E5">and first of all I want</font><font color="#CCCCCC"> to think about</font>

239
00:10:53,160 --> 00:10:57,689
the pebble algorithm which would be used

240
00:10:55,260 --> 00:11:00,569
by the honest party will call this net

241
00:10:57,690 --> 00:11:03,640
the naive doubling algorithm and because

242
00:11:00,569 --> 00:11:06,790
the 90 staggering algorithm is run by

243
00:11:03,640 --> 00:11:08,230
an honest party typically<font color="#E5E5E5"> we expect this</font>

244
00:11:06,790 --> 00:11:11,800
algorithm to be something<font color="#CCCCCC"> that you could</font>

245
00:11:08,230 --> 00:11:13,870
run on a sequential computer so the

246
00:11:11,800 --> 00:11:16,390
constraint is only one new pebble can be

247
00:11:13,870 --> 00:11:19,510
placed on the graph per round the

248
00:11:16,390 --> 00:11:21,520
attacker isn't doesn't operate under the

249
00:11:19,510 --> 00:11:22,990
same constraints but the honest party

250
00:11:21,520 --> 00:11:26,560
needs to operate under the<font color="#E5E5E5"> constraint</font>

251
00:11:22,990 --> 00:11:28,600
all right so an example of<font color="#E5E5E5"> a naive</font>

252
00:11:26,560 --> 00:11:31,180
troubling algorithms is just to pebble

253
00:11:28,600 --> 00:11:35,770
the graph in topological order node 1 no

254
00:11:31,180 --> 00:11:37,630
2 no 3 etc and never discard couples so

255
00:11:35,770 --> 00:11:39,640
how long<font color="#CCCCCC"> does this take it takes n steps</font>

256
00:11:37,630 --> 00:11:41,620
and we have an<font color="#E5E5E5"> average of n over two</font>

257
00:11:39,640 --> 00:11:46,330
pebbles on the<font color="#E5E5E5"> grass at each point in</font>

258
00:11:41,620 --> 00:11:48,910
time so the<font color="#CCCCCC"> expected cost or the</font>

259
00:11:46,330 --> 00:11:53,530
cumulative energy<font color="#E5E5E5"> cost is going to scale</font>

260
00:11:48,910 --> 00:11:56,110
with<font color="#E5E5E5"> N squared all right so what does</font><font color="#CCCCCC"> it</font>

261
00:11:53,530 --> 00:11:58,750
mean to have an attack on a data

262
00:11:56,110 --> 00:12:01,960
independent memory<font color="#E5E5E5"> hard function oh well</font>

263
00:11:58,750 --> 00:12:03,780
we call an algorithm and attack if the

264
00:12:01,960 --> 00:12:06,070
amortized complexity of computing

265
00:12:03,780 --> 00:12:09,699
computing<font color="#E5E5E5"> this function is lower than</font>

266
00:12:06,070 --> 00:12:11,680
the cost<font color="#E5E5E5"> of the</font><font color="#CCCCCC"> naive algorithm so an</font>

267
00:12:09,700 --> 00:12:14,620
example here suppose algorithm a

268
00:12:11,680 --> 00:12:17,380
evaluates<font color="#E5E5E5"> 5 I MHS instances with total</font>

269
00:12:14,620 --> 00:12:21,250
<font color="#CCCCCC">cost 100 and suppose that the naive</font>

270
00:12:17,380 --> 00:12:25,420
algorithm costs 40 well in this<font color="#E5E5E5"> case the</font>

271
00:12:21,250 --> 00:12:28,120
quality of our attack is just too<font color="#E5E5E5"> all</font>

272
00:12:25,420 --> 00:12:31,689
<font color="#E5E5E5">right so what what properties do we</font>

273
00:12:28,120 --> 00:12:33,700
desire for an<font color="#E5E5E5"> IM hf well for practical</font>

274
00:12:31,690 --> 00:12:37,180
reasons we want to graph with constant

275
00:12:33,700 --> 00:12:40,720
in degree we also want to assure that

276
00:12:37,180 --> 00:12:42,520
any attack a has small quality less than

277
00:12:40,720 --> 00:12:45,640
or<font color="#CCCCCC"> equal to C for some hopefully small</font>

278
00:12:42,520 --> 00:12:47,980
constancy and we also want to ensure

279
00:12:45,640 --> 00:12:52,060
that<font color="#CCCCCC"> the naive algorithm is somewhat</font>

280
00:12:47,980 --> 00:12:54,400
expensive why why do we want the third

281
00:12:52,060 --> 00:12:57,969
constraint well it tells us that memory

282
00:12:54,400 --> 00:13:00,670
<font color="#CCCCCC">cost should dominate and also remember</font>

283
00:12:57,970 --> 00:13:02,770
that users are impatient so n the

284
00:13:00,670 --> 00:13:05,020
running time of the algorithm is fixed

285
00:13:02,770 --> 00:13:07,449
<font color="#CCCCCC">so we</font><font color="#E5E5E5"> want</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> make this function as</font>

286
00:13:05,020 --> 00:13:10,800
expensive as possible given<font color="#CCCCCC"> a bounded</font>

287
00:13:07,450 --> 00:13:15,700
running time so we want to<font color="#E5E5E5"> maximize</font><font color="#CCCCCC"> cost</font>

288
00:13:10,800 --> 00:13:17,260
466 running time in all right and we'll

289
00:13:15,700 --> 00:13:20,560
say that

290
00:13:17,260 --> 00:13:23,020
I'm NHS is the ideal if it satisfies all

291
00:13:20,560 --> 00:13:27,849
three of these constraints for some

292
00:13:23,020 --> 00:13:30,970
constant<font color="#CCCCCC"> tau alright so that's those</font><font color="#E5E5E5"> are</font>

293
00:13:27,850 --> 00:13:35,110
the desirable properties for an<font color="#E5E5E5"> IM</font><font color="#CCCCCC"> hf</font>

294
00:13:30,970 --> 00:13:39,520
but now let me tell you<font color="#CCCCCC"> about an attack</font>

295
00:13:35,110 --> 00:13:42,520
on existing ymhf<font color="#CCCCCC"> candidates so in</font>

296
00:13:39,520 --> 00:13:44,410
particular it may take away from the

297
00:13:42,520 --> 00:13:47,170
talk is that there's a combinatorial

298
00:13:44,410 --> 00:13:49,990
property called depth robustness which

299
00:13:47,170 --> 00:13:51,490
completely characterizes secure data

300
00:13:49,990 --> 00:13:54,160
independent memory heart functions in

301
00:13:51,490 --> 00:13:56,980
particular depth robustness is necessary

302
00:13:54,160 --> 00:14:01,420
and also suspicious for building a

303
00:13:56,980 --> 00:14:04,390
secure I<font color="#E5E5E5"> MHS</font><font color="#CCCCCC"> all right so so what is</font>

304
00:14:01,420 --> 00:14:08,530
this property<font color="#E5E5E5"> depth robustness well a</font>

305
00:14:04,390 --> 00:14:12,460
graph G is<font color="#CCCCCC"> ed reducible if there</font><font color="#E5E5E5"> exists</font>

306
00:14:08,530 --> 00:14:16,780
<font color="#CCCCCC">affect a subset s of vertices such that</font>

307
00:14:12,460 --> 00:14:19,990
the subset sighs moc and removing these

308
00:14:16,780 --> 00:14:22,660
nodes from the graph reduces the depth

309
00:14:19,990 --> 00:14:24,400
of the graph 2d and by<font color="#E5E5E5"> definitely graph</font>

310
00:14:22,660 --> 00:14:26,829
I mean the length of the longest path

311
00:14:24,400 --> 00:14:30,819
after removing after removing these

312
00:14:26,830 --> 00:14:33,190
nodes s and of<font color="#CCCCCC"> course if a graph is not</font>

313
00:14:30,820 --> 00:14:36,700
eat irreducible then we say it's ed

314
00:14:33,190 --> 00:14:39,100
depth robust so a simple example here

315
00:14:36,700 --> 00:14:41,140
here's a 12 reducible graphs that means

316
00:14:39,100 --> 00:14:44,260
we can delete one node and reduce the

317
00:14:41,140 --> 00:14:47,080
deficit ooh pretty easy to<font color="#E5E5E5"> fight here</font>

318
00:14:44,260 --> 00:14:50,310
just elite node 3 and it's easy<font color="#E5E5E5"> to</font>

319
00:14:47,080 --> 00:14:54,490
visually verify that any passes link to

320
00:14:50,310 --> 00:14:59,199
all right so now I claim that<font color="#E5E5E5"> we can</font>

321
00:14:54,490 --> 00:15:01,360
attack any heed irreducible graph how do

322
00:14:59,200 --> 00:15:02,590
<font color="#E5E5E5">we do that well the only thing we</font><font color="#CCCCCC"> know</font>

323
00:15:01,360 --> 00:15:05,560
about the graph is that it's ed

324
00:15:02,590 --> 00:15:08,110
reducible so if input our attack is

325
00:15:05,560 --> 00:15:10,349
<font color="#E5E5E5">going to just take subset X of nodes</font>

326
00:15:08,110 --> 00:15:13,000
which reduce the depth of the graph and

327
00:15:10,350 --> 00:15:16,030
the attack works in two phases light

328
00:15:13,000 --> 00:15:17,620
faces and balloon phases and the goal of

329
00:15:16,030 --> 00:15:19,870
a light phase is to make a lot of

330
00:15:17,620 --> 00:15:22,570
progress to pebble the next<font color="#E5E5E5"> G notes that</font>

331
00:15:19,870 --> 00:15:23,980
we want to<font color="#E5E5E5"> pebble and during a light</font>

332
00:15:22,570 --> 00:15:25,920
pace the intuition is that we're not

333
00:15:23,980 --> 00:15:28,240
<font color="#CCCCCC">going</font><font color="#E5E5E5"> to keep many pebbles on the graph</font>

334
00:15:25,920 --> 00:15:30,130
we're going<font color="#E5E5E5"> to discard almost every</font>

335
00:15:28,240 --> 00:15:30,470
pebble from the graph except for notes

336
00:15:30,130 --> 00:15:34,970
and

337
00:15:30,470 --> 00:15:37,010
and<font color="#CCCCCC"> for node for pebbles on notes of the</font>

338
00:15:34,970 --> 00:15:40,820
<font color="#E5E5E5">parents of the guys that we want to</font>

339
00:15:37,010 --> 00:15:43,700
<font color="#CCCCCC">temple in the</font><font color="#E5E5E5"> next G steps</font><font color="#CCCCCC"> all right so</font>

340
00:15:40,820 --> 00:15:45,470
we use a low memory and that phase lasts

341
00:15:43,700 --> 00:15:49,100
for a long time<font color="#E5E5E5"> G is going to be</font>

342
00:15:45,470 --> 00:15:51,490
typically large<font color="#CCCCCC"> all right so of course</font>

343
00:15:49,100 --> 00:15:53,600
at some point we're going to<font color="#E5E5E5"> run out of</font>

344
00:15:51,490 --> 00:15:56,000
run out of time and<font color="#CCCCCC"> we're not going</font><font color="#E5E5E5"> to</font>

345
00:15:53,600 --> 00:15:59,630
<font color="#E5E5E5">have pebbles on the parents of the next</font>

346
00:15:56,000 --> 00:16:01,760
notes that we want to want<font color="#E5E5E5"> to trouble so</font>

347
00:15:59,630 --> 00:16:04,850
now we<font color="#CCCCCC"> have to execute a balloon phase</font>

348
00:16:01,760 --> 00:16:06,770
to recover all these missing couples and

349
00:16:04,850 --> 00:16:10,400
the key point here is that because<font color="#E5E5E5"> the</font>

350
00:16:06,770 --> 00:16:12,199
depth of the<font color="#CCCCCC"> graph</font><font color="#E5E5E5"> is small we can</font>

351
00:16:10,400 --> 00:16:14,060
<font color="#E5E5E5">execute a balloon phase and very quickly</font>

352
00:16:12,200 --> 00:16:17,150
recover all the<font color="#E5E5E5"> missing values that</font>

353
00:16:14,060 --> 00:16:20,209
we've previously discarded so a balloon

354
00:16:17,150 --> 00:16:21,920
phase is expensive we're going<font color="#E5E5E5"> to be</font>

355
00:16:20,210 --> 00:16:23,990
operating in parallel and placing a lot

356
00:16:21,920 --> 00:16:28,550
of pebbles in the graph but the point is

357
00:16:23,990 --> 00:16:30,170
<font color="#E5E5E5">that it over very quickly you execute 4d</font>

358
00:16:28,550 --> 00:16:32,780
steps and you recover everything that

359
00:16:30,170 --> 00:16:35,780
you've discarded and then you you

360
00:16:32,780 --> 00:16:39,079
continue on your way<font color="#E5E5E5"> all right so our</font>

361
00:16:35,780 --> 00:16:40,730
theorem is that if your graph is<font color="#CCCCCC"> Ed</font>

362
00:16:39,080 --> 00:16:45,250
reducible then there's an efficient

363
00:16:40,730 --> 00:16:47,900
attack a with the following<font color="#E5E5E5"> complexity</font>

364
00:16:45,250 --> 00:16:51,820
so this<font color="#E5E5E5"> is a complicated term let's walk</font>

365
00:16:47,900 --> 00:16:55,220
through each each component bit by<font color="#CCCCCC"> bit</font>

366
00:16:51,820 --> 00:16:58,490
well we keep pebbles on<font color="#CCCCCC"> the set</font><font color="#E5E5E5"> X in the</font>

367
00:16:55,220 --> 00:17:01,550
set X outside e so we're going to pay

368
00:16:58,490 --> 00:17:05,630
costs e times n to keep a pulse on<font color="#E5E5E5"> the</font>

369
00:17:01,550 --> 00:17:07,550
graph for n rounds during the light

370
00:17:05,630 --> 00:17:09,230
phase we also maintain trouble from the

371
00:17:07,550 --> 00:17:13,579
parents of the<font color="#E5E5E5"> next</font><font color="#CCCCCC"> G notes that we want</font>

372
00:17:09,230 --> 00:17:17,810
to<font color="#E5E5E5"> trouble so there's in degree as</font><font color="#CCCCCC"> is</font>

373
00:17:13,579 --> 00:17:20,750
Delta so we have Delta<font color="#CCCCCC"> a times G parents</font>

374
00:17:17,810 --> 00:17:23,720
and we keep these pebbles on<font color="#CCCCCC"> the graph</font>

375
00:17:20,750 --> 00:17:27,710
for n rounds again so<font color="#E5E5E5"> Delta times G</font>

376
00:17:23,720 --> 00:17:29,990
times<font color="#CCCCCC"> N and this</font><font color="#E5E5E5"> last term here is the</font>

377
00:17:27,710 --> 00:17:33,530
cost of a balloon phase so we need to

378
00:17:29,990 --> 00:17:37,070
compute execute n / g balloon phases in

379
00:17:33,530 --> 00:17:42,379
total and the<font color="#E5E5E5"> length of a balloon phase</font>

380
00:17:37,070 --> 00:17:43,790
is d round and the maximum<font color="#CCCCCC"> number of</font>

381
00:17:42,380 --> 00:17:46,280
pebbles on the graphs during

382
00:17:43,790 --> 00:17:50,330
<font color="#E5E5E5">saloon phase is just n the number of</font>

383
00:17:46,280 --> 00:17:53,600
<font color="#E5E5E5">nodes in the graph so this upper bounds</font>

384
00:17:50,330 --> 00:17:57,020
<font color="#E5E5E5">the humid of space complexity and these</font>

385
00:17:53,600 --> 00:18:00,350
last few terms just trust me<font color="#CCCCCC"> there the</font>

386
00:17:57,020 --> 00:18:02,210
cost of squaring the random Oracle<font color="#CCCCCC"> all</font>

387
00:18:00,350 --> 00:18:04,580
<font color="#CCCCCC">right so we have</font><font color="#E5E5E5"> this complicated</font>

388
00:18:02,210 --> 00:18:07,340
looking bound know if we<font color="#E5E5E5"> to in parameter</font>

389
00:18:04,580 --> 00:18:11,389
it's appropriately we get the following

390
00:18:07,340 --> 00:18:15,830
energy complexity a<font color="#CCCCCC"> notes in particular</font>

391
00:18:11,390 --> 00:18:18,620
that if II and D are smaller than n that

392
00:18:15,830 --> 00:18:20,629
this gives<font color="#E5E5E5"> us an attack right this gives</font>

393
00:18:18,620 --> 00:18:24,110
us an algorithm<font color="#CCCCCC"> to evaluate this</font>

394
00:18:20,630 --> 00:18:27,410
function with costs the little o of N

395
00:18:24,110 --> 00:18:28,699
squared in particular<font color="#CCCCCC"> this is that</font>

396
00:18:27,410 --> 00:18:32,710
<font color="#E5E5E5">because we want to ensure that any</font>

397
00:18:28,700 --> 00:18:37,760
attack requires requires cost n squared

398
00:18:32,710 --> 00:18:41,150
<font color="#CCCCCC">okay so now we</font><font color="#E5E5E5"> have an attack generic</font>

399
00:18:37,760 --> 00:18:43,760
attack on any depth reducible grasp the

400
00:18:41,150 --> 00:18:46,870
question then is our existing I mhf

401
00:18:43,760 --> 00:18:50,450
candidates based on depth tour bus tags

402
00:18:46,870 --> 00:18:53,750
so in this talks will consider a few

403
00:18:50,450 --> 00:18:56,630
<font color="#E5E5E5">different I am a chef candidates there's</font>

404
00:18:53,750 --> 00:18:58,070
<font color="#CCCCCC">katina an entrance</font><font color="#E5E5E5"> into the password</font>

405
00:18:56,630 --> 00:19:01,310
hashing competition which received

406
00:18:58,070 --> 00:19:03,200
special<font color="#CCCCCC"> recognitions there is argon to</font>

407
00:19:01,310 --> 00:19:07,280
the winner of the password hashing

408
00:19:03,200 --> 00:19:09,530
competition in particular are gone ey

409
00:19:07,280 --> 00:19:12,129
the data independent mode is the

410
00:19:09,530 --> 00:19:14,510
recommended mode for password hashing

411
00:19:12,130 --> 00:19:18,800
there's a newer proposal called balloon

412
00:19:14,510 --> 00:19:20,660
hashing and the original<font color="#E5E5E5"> paper had three</font>

413
00:19:18,800 --> 00:19:24,490
variants I think there's just one one

414
00:19:20,660 --> 00:19:29,780
variant in the current current<font color="#CCCCCC"> proposal</font>

415
00:19:24,490 --> 00:19:33,110
<font color="#E5E5E5">ok but in some reason answer is no none</font>

416
00:19:29,780 --> 00:19:35,960
of these graphs are depth or bust so

417
00:19:33,110 --> 00:19:39,350
Katina is actually kind of maximally

418
00:19:35,960 --> 00:19:41,660
depth reducible so if i remove<font color="#CCCCCC"> inos that</font>

419
00:19:39,350 --> 00:19:44,480
can reduce the depth<font color="#E5E5E5"> to n</font><font color="#CCCCCC"> over</font><font color="#E5E5E5"> he that's</font>

420
00:19:41,660 --> 00:19:46,220
kind of as bad as it gets and a

421
00:19:44,480 --> 00:19:48,770
consequence of this is that the

422
00:19:46,220 --> 00:19:54,340
cumulative cost of computing this<font color="#E5E5E5"> I mhf</font>

423
00:19:48,770 --> 00:19:57,370
scales as oh sorry n to the<font color="#E5E5E5"> 1.6 to</font>

424
00:19:54,340 --> 00:19:59,770
an exponent here not so this is an order

425
00:19:57,370 --> 00:20:05,110
one it's not constant<font color="#E5E5E5"> time but end of</font>

426
00:19:59,770 --> 00:20:07,830
the 1.6 to all right so balloon<font color="#E5E5E5"> hashing</font>

427
00:20:05,110 --> 00:20:11,529
and argon Qi are also depth reducible

428
00:20:07,830 --> 00:20:13,960
slightly better than than<font color="#CCCCCC"> katina but</font>

429
00:20:11,529 --> 00:20:17,770
still depth reducible and we get an

430
00:20:13,960 --> 00:20:23,200
attack which has cost<font color="#E5E5E5"> scaling as n to</font>

431
00:20:17,770 --> 00:20:25,150
the<font color="#CCCCCC"> 1.71 the</font><font color="#E5E5E5"> latest version</font><font color="#CCCCCC"> of argon to</font>

432
00:20:23,200 --> 00:20:28,679
you is actually seems to be a<font color="#E5E5E5"> little bit</font>

433
00:20:25,150 --> 00:20:31,240
<font color="#E5E5E5">better but it still is eating reducible</font>

434
00:20:28,679 --> 00:20:34,500
and in particular the commune of

435
00:20:31,240 --> 00:20:38,440
complexity skills is the end of the 1.77

436
00:20:34,500 --> 00:20:40,750
in any<font color="#CCCCCC"> case none of</font><font color="#E5E5E5"> these</font><font color="#CCCCCC"> are</font><font color="#E5E5E5"> are close</font>

437
00:20:38,440 --> 00:20:46,270
to N squared which is<font color="#E5E5E5"> what what we</font>

438
00:20:40,750 --> 00:20:48,760
ideally want and of course you know the

439
00:20:46,270 --> 00:20:51,850
same general techniques apply to a host

440
00:20:48,760 --> 00:20:54,669
of other IHF candidates so there's some

441
00:20:51,850 --> 00:20:57,100
other follow-up work looking at mellow

442
00:20:54,669 --> 00:21:02,110
and other variants from the password

443
00:20:57,100 --> 00:21:04,090
hashing competition but let me<font color="#E5E5E5"> focus on</font>

444
00:21:02,110 --> 00:21:05,110
argonne see why since it's the the

445
00:21:04,090 --> 00:21:09,100
winner<font color="#E5E5E5"> of the password hashing</font>

446
00:21:05,110 --> 00:21:11,020
competition so what does<font color="#E5E5E5"> are gone to I</font>

447
00:21:09,100 --> 00:21:13,178
look like<font color="#CCCCCC"> in terms of its graph graph</font>

448
00:21:11,020 --> 00:21:16,090
structure well you start off with a

449
00:21:13,179 --> 00:21:20,529
chain 1 through n and then for each node

450
00:21:16,090 --> 00:21:22,720
I you pick a random predecessor<font color="#E5E5E5"> RI in</font>

451
00:21:20,529 --> 00:21:24,340
the original version this random

452
00:21:22,720 --> 00:21:26,890
predecessor has chosen from the uniform

453
00:21:24,340 --> 00:21:28,000
distribution and the newest version<font color="#CCCCCC"> has</font>

454
00:21:26,890 --> 00:21:30,970
chosen from a slightly more

455
00:21:28,000 --> 00:21:32,740
<font color="#E5E5E5">sophisticated distribution but it turns</font>

456
00:21:30,970 --> 00:21:37,659
out not to matter too much in terms of

457
00:21:32,740 --> 00:21:39,460
the performance for attack so here's how

458
00:21:37,659 --> 00:21:42,970
you would for example reduce the depths

459
00:21:39,460 --> 00:21:44,620
<font color="#E5E5E5">of an argon graph to root end first</font>

460
00:21:42,970 --> 00:21:47,529
we're arbitrarily going to partition

461
00:21:44,620 --> 00:21:51,370
these nodes into layers each layer has

462
00:21:47,529 --> 00:21:54,880
end of the three<font color="#E5E5E5"> fourth node and now</font>

463
00:21:51,370 --> 00:21:59,559
we're<font color="#CCCCCC"> just going to delete any node in</font>

464
00:21:54,880 --> 00:22:02,490
this set<font color="#CCCCCC"> f2 so s2 is basically all nodes</font>

465
00:21:59,559 --> 00:22:05,379
with the predecessor in the same layer

466
00:22:02,490 --> 00:22:07,539
so the claim i'm not going to prove<font color="#E5E5E5"> it</font>

467
00:22:05,380 --> 00:22:11,799
but just<font color="#E5E5E5"> trust me I x</font>

468
00:22:07,539 --> 00:22:15,100
<font color="#CCCCCC">who is pretty small well what happens</font>

469
00:22:11,799 --> 00:22:19,539
after you remove f2 from the graph now

470
00:22:15,100 --> 00:22:21,668
each layer essentially become a path and

471
00:22:19,539 --> 00:22:25,179
it turns out that<font color="#E5E5E5"> it's pretty easy to</font>

472
00:22:21,669 --> 00:22:27,039
reduce the depth of the path so now<font color="#E5E5E5"> I</font>

473
00:22:25,179 --> 00:22:30,190
<font color="#CCCCCC">will do is will reduce the</font><font color="#E5E5E5"> depth of each</font>

474
00:22:27,039 --> 00:22:32,289
layer since it's a path once we reduce

475
00:22:30,190 --> 00:22:35,049
the depth of each layer to let's say

476
00:22:32,289 --> 00:22:36,669
<font color="#CCCCCC">fourth root</font><font color="#E5E5E5"> of n then any pass through</font>

477
00:22:35,049 --> 00:22:38,799
the whole graph can stay in a single

478
00:22:36,669 --> 00:22:41,649
layer for at most fourth root<font color="#E5E5E5"> of n steps</font>

479
00:22:38,799 --> 00:22:42,879
and there's 4th ribbon and layers so the

480
00:22:41,649 --> 00:22:48,820
total depth of the graph would be

481
00:22:42,879 --> 00:22:51,519
through and all right so that gives us

482
00:22:48,820 --> 00:22:55,090
the tax in theory of course this<font color="#E5E5E5"> is a</font>

483
00:22:51,519 --> 00:22:56,919
real world crypto conference so the

484
00:22:55,090 --> 00:22:59,949
<font color="#E5E5E5">question is you know are these just</font>

485
00:22:56,919 --> 00:23:02,139
<font color="#E5E5E5">attacks in theory or good day we'd too</font>

486
00:22:59,950 --> 00:23:05,139
practical attacks for real memory

487
00:23:02,139 --> 00:23:08,949
parameters that that we might adopt and

488
00:23:05,139 --> 00:23:14,258
we would<font color="#CCCCCC"> argue that</font><font color="#E5E5E5"> the answer is</font><font color="#CCCCCC"> yes so</font>

489
00:23:08,950 --> 00:23:16,539
in particular for argon to<font color="#CCCCCC"> I with memory</font>

490
00:23:14,259 --> 00:23:19,479
perimeter to to the 20 so that's<font color="#E5E5E5"> the</font>

491
00:23:16,539 --> 00:23:23,070
gigabyte of memory which<font color="#CCCCCC"> is which is</font>

492
00:23:19,479 --> 00:23:26,229
practical we get to attack quality

493
00:23:23,070 --> 00:23:28,899
exceeding five and it's going to rapidly

494
00:23:26,229 --> 00:23:30,399
increase so if you you<font color="#CCCCCC"> know go up to</font>

495
00:23:28,899 --> 00:23:32,738
just two gigabytes of memory attack

496
00:23:30,399 --> 00:23:34,840
quality is going to be almost<font color="#CCCCCC"> 10 and</font>

497
00:23:32,739 --> 00:23:39,580
it's going<font color="#E5E5E5"> to further increases as</font>

498
00:23:34,840 --> 00:23:41,738
memory increases so 26 guess it's<font color="#E5E5E5"> locked</font>

499
00:23:39,580 --> 00:23:43,449
we actually simulated our attack so

500
00:23:41,739 --> 00:23:45,220
instead<font color="#CCCCCC"> of just plugging in the</font>

501
00:23:43,450 --> 00:23:48,129
theoretical bounds so we actually

502
00:23:45,220 --> 00:23:51,549
implemented the attacks generated some

503
00:23:48,129 --> 00:23:53,889
random are gone to I graphs and just ran

504
00:23:51,549 --> 00:23:56,499
the attacks to see see what performance

505
00:23:53,889 --> 00:23:59,998
look looks like and and this is what you

506
00:23:56,499 --> 00:24:02,679
get now<font color="#CCCCCC"> I should mention I've had a</font>

507
00:23:59,999 --> 00:24:05,769
graduate student working this semester

508
00:24:02,679 --> 00:24:07,119
on some alternate heuristics and I think

509
00:24:05,769 --> 00:24:09,909
these curves are actually going to shift

510
00:24:07,119 --> 00:24:12,789
left a little bit farther I don't have

511
00:24:09,909 --> 00:24:14,470
those results<font color="#E5E5E5"> yet but so if I had to</font>

512
00:24:12,789 --> 00:24:16,210
make<font color="#CCCCCC"> a wager I think these cards are</font>

513
00:24:14,470 --> 00:24:17,470
going to shift<font color="#E5E5E5"> a little bit left which</font>

514
00:24:16,210 --> 00:24:19,929
means<font color="#E5E5E5"> that the attacks are going to be</font>

515
00:24:17,470 --> 00:24:22,650
even<font color="#CCCCCC"> more practical and</font><font color="#E5E5E5"> even smaller</font>

516
00:24:19,929 --> 00:24:26,920
memory parameters

517
00:24:22,650 --> 00:24:29,740
alright so<font color="#E5E5E5"> I can also note that even</font>

518
00:24:26,920 --> 00:24:32,050
with the pessimistic parameter settings

519
00:24:29,740 --> 00:24:36,220
so if you make six passes through a

520
00:24:32,050 --> 00:24:39,159
gigabyte of memory we still we<font color="#CCCCCC"> still get</font>

521
00:24:36,220 --> 00:24:41,320
attacks so you<font color="#E5E5E5"> can still reduce your</font>

522
00:24:39,160 --> 00:24:43,630
costs by a factor of<font color="#E5E5E5"> two approximately</font>

523
00:24:41,320 --> 00:24:46,030
of course<font color="#E5E5E5"> there are good reasons why you</font>

524
00:24:43,630 --> 00:24:49,420
might not<font color="#E5E5E5"> want</font><font color="#CCCCCC"> to make six passes over</font>

525
00:24:46,030 --> 00:24:50,889
memory in particular users are impatient

526
00:24:49,420 --> 00:24:54,510
and so you probably don't have time to

527
00:24:50,890 --> 00:24:54,510
make six passes over gigabyte of memory

528
00:24:54,540 --> 00:25:02,559
<font color="#CCCCCC">alright well so this</font><font color="#E5E5E5"> doesn't just apply</font>

529
00:24:59,740 --> 00:25:06,400
to<font color="#CCCCCC"> our gone to I in fact we have a</font>

530
00:25:02,559 --> 00:25:10,629
general theorem stating that ideal I mhf

531
00:25:06,400 --> 00:25:14,020
don't exist and simplifying a little bit

532
00:25:10,630 --> 00:25:16,000
so we prove that any graph G with

533
00:25:14,020 --> 00:25:19,750
constant in degree is at least somewhat

534
00:25:16,000 --> 00:25:22,420
<font color="#CCCCCC">depths reducible so in particular that</font>

535
00:25:19,750 --> 00:25:26,230
implies that there's always an attack

536
00:25:22,420 --> 00:25:29,110
with quality oh sorry<font color="#E5E5E5"> this should be log</font>

537
00:25:26,230 --> 00:25:31,390
n over log log n not about the other way

538
00:25:29,110 --> 00:25:33,669
around<font color="#E5E5E5"> I'll pick some in my slides</font>

539
00:25:31,390 --> 00:25:35,440
before I send it to you but there's

540
00:25:33,670 --> 00:25:40,960
always<font color="#E5E5E5"> an attack with quality roughly</font>

541
00:25:35,440 --> 00:25:43,630
roughly login<font color="#CCCCCC"> all right so this is true</font>

542
00:25:40,960 --> 00:25:47,740
in theory but we can actually can't rule

543
00:25:43,630 --> 00:25:50,290
out ideal<font color="#E5E5E5"> imh ups in practice so if you</font>

544
00:25:47,740 --> 00:25:51,670
look<font color="#E5E5E5"> at you know the memory parameters</font>

545
00:25:50,290 --> 00:25:53,740
for which these attacks start to become

546
00:25:51,670 --> 00:25:57,070
practical they start to be practical

547
00:25:53,740 --> 00:26:02,370
somewhere around two to the 51 which is

548
00:25:57,070 --> 00:26:05,280
orders of magnitude above any any real

549
00:26:02,370 --> 00:26:09,159
memory parameter that we would select

550
00:26:05,280 --> 00:26:11,080
all right so<font color="#E5E5E5"> so in the last three to</font>

551
00:26:09,160 --> 00:26:14,470
four<font color="#E5E5E5"> minutes let me tell you about some</font>

552
00:26:11,080 --> 00:26:16,809
exciting new results not<font color="#E5E5E5"> only is def</font>

553
00:26:14,470 --> 00:26:19,570
robustness necessary for secure I'm a

554
00:26:16,809 --> 00:26:23,678
chef so it's also sufficient in

555
00:26:19,570 --> 00:26:25,450
particular<font color="#CCCCCC"> if G is Ed debt robust does</font>

556
00:26:23,679 --> 00:26:28,809
and the cumulative cost of pebble<font color="#CCCCCC"> Inge</font>

557
00:26:25,450 --> 00:26:31,750
is at least<font color="#CCCCCC"> a times D so that's a pretty</font>

558
00:26:28,809 --> 00:26:33,750
simple theorem statement and since this

559
00:26:31,750 --> 00:26:34,830
<font color="#CCCCCC">is a real world crypt</font>

560
00:26:33,750 --> 00:26:36,270
conference<font color="#E5E5E5"> I don't have to be</font>

561
00:26:34,830 --> 00:26:38,460
embarrassed and hide behind the

562
00:26:36,270 --> 00:26:40,620
simplicity of the proof that's<font color="#E5E5E5"> actually</font>

563
00:26:38,460 --> 00:26:43,910
the entire proof<font color="#E5E5E5"> I won't walk through it</font>

564
00:26:40,620 --> 00:26:46,199
but it fits in tips in a paragraph

565
00:26:43,910 --> 00:26:49,020
<font color="#E5E5E5">alright so what are the implications of</font>

566
00:26:46,200 --> 00:26:50,430
this theorem well one implication is

567
00:26:49,020 --> 00:26:52,650
that there exists a constant in degree

568
00:26:50,430 --> 00:26:56,340
graphs with cumulative complexity

569
00:26:52,650 --> 00:26:58,350
scaling as<font color="#CCCCCC"> N squared over log n so this</font>

570
00:26:56,340 --> 00:27:00,449
beats the previous best construction due

571
00:26:58,350 --> 00:27:04,980
to all win and Ferb<font color="#CCCCCC"> eniko which gets N</font>

572
00:27:00,450 --> 00:27:06,480
squared over log to<font color="#CCCCCC"> the 10 n and in fact</font>

573
00:27:04,980 --> 00:27:08,670
<font color="#E5E5E5">we can't really do better in an</font>

574
00:27:06,480 --> 00:27:12,600
asymptotic sense based on the last

575
00:27:08,670 --> 00:27:15,270
attack that I showed you I should

576
00:27:12,600 --> 00:27:18,780
mention<font color="#E5E5E5"> here that the result from this</font>

577
00:27:15,270 --> 00:27:21,870
<font color="#E5E5E5">paper abp 16 is definitely not practical</font>

578
00:27:18,780 --> 00:27:24,000
yet but we do have some constructions

579
00:27:21,870 --> 00:27:27,209
that we're<font color="#CCCCCC"> working on which we believe</font>

580
00:27:24,000 --> 00:27:31,070
will be practical so hopefully<font color="#CCCCCC"> I'll have</font>

581
00:27:27,210 --> 00:27:35,250
<font color="#E5E5E5">have some updates to share sheriff in</font>

582
00:27:31,070 --> 00:27:37,710
some<font color="#E5E5E5"> other new results so with this</font><font color="#CCCCCC"> new</font>

583
00:27:35,250 --> 00:27:39,660
<font color="#E5E5E5">technique we can not only upper bound</font>

584
00:27:37,710 --> 00:27:42,480
the complexity of computing these<font color="#E5E5E5"> amhs</font>

585
00:27:39,660 --> 00:27:45,360
we can also provide<font color="#E5E5E5"> some lower bounds so</font>

586
00:27:42,480 --> 00:27:48,540
in particular for the latest<font color="#CCCCCC"> version of</font>

587
00:27:45,360 --> 00:27:50,669
argon to why there's a lower bound the

588
00:27:48,540 --> 00:27:54,090
cumulative complexity is at least end of

589
00:27:50,670 --> 00:27:57,330
the 1.66 similarly<font color="#E5E5E5"> for our balloon</font>

590
00:27:54,090 --> 00:27:59,970
hashing a script so we're going to hear

591
00:27:57,330 --> 00:28:03,030
<font color="#CCCCCC">about the next lecture it actually has a</font>

592
00:27:59,970 --> 00:28:05,430
lower bound of N squared so that's

593
00:28:03,030 --> 00:28:08,550
exciting but of course s<font color="#E5E5E5"> script is data</font>

594
00:28:05,430 --> 00:28:12,570
dependent that's why our upper bounds

595
00:28:08,550 --> 00:28:14,820
don't apply<font color="#CCCCCC"> all right so in</font><font color="#E5E5E5"> conclusion</font>

596
00:28:12,570 --> 00:28:17,129
depth robustness is necessary and

597
00:28:14,820 --> 00:28:20,100
sufficient for building secure<font color="#E5E5E5"> amh up I</font>

598
00:28:17,130 --> 00:28:22,680
think the big challenge and one that I

599
00:28:20,100 --> 00:28:24,629
hope people<font color="#CCCCCC"> will be motivated to work on</font>

600
00:28:22,680 --> 00:28:28,220
is improved constructions of depth

601
00:28:24,630 --> 00:28:32,400
robust crap so the results in our paper

602
00:28:28,220 --> 00:28:35,040
really<font color="#E5E5E5"> used a results of</font><font color="#CCCCCC"> Erdos Graham</font>

603
00:28:32,400 --> 00:28:37,760
and summer Eddie from 77<font color="#CCCCCC"> their</font>

604
00:28:35,040 --> 00:28:42,389
combinatorial if it works particularly

605
00:28:37,760 --> 00:28:44,190
concerns with practical efficiency but

606
00:28:42,390 --> 00:28:47,700
in this case<font color="#E5E5E5"> constants obviously matter</font>

607
00:28:44,190 --> 00:28:49,799
a great deal more open question

608
00:28:47,700 --> 00:28:51,620
<font color="#CCCCCC">and I</font><font color="#E5E5E5"> think it would be cool to automate</font>

609
00:28:49,799 --> 00:28:55,080
the crypt analysis of I<font color="#CCCCCC"> mhf</font>

610
00:28:51,620 --> 00:28:57,570
unfortunately we have some results that

611
00:28:55,080 --> 00:29:00,809
the Justice may not be possible it's<font color="#E5E5E5"> NP</font>

612
00:28:57,570 --> 00:29:02,460
hard to compute C C of G but we can't

613
00:29:00,809 --> 00:29:06,840
rule out heuristics approximation

614
00:29:02,460 --> 00:29:08,730
algorithms and of course there's still

615
00:29:06,840 --> 00:29:11,039
room for a tighter analysis of the

616
00:29:08,730 --> 00:29:12,269
<font color="#E5E5E5">latest version of argon Qi there's a gap</font>

617
00:29:11,039 --> 00:29:18,149
<font color="#E5E5E5">between the lower bound and the upper</font>

618
00:29:12,269 --> 00:29:20,419
bound so with that I'll think thanks for

619
00:29:18,149 --> 00:29:20,418
<font color="#CCCCCC">listening</font>

620
00:29:25,260 --> 00:29:30,879
continued<font color="#CCCCCC"> thanks</font><font color="#E5E5E5"> so several times in</font>

621
00:29:28,179 --> 00:29:33,460
your talk you emphasized that the

622
00:29:30,880 --> 00:29:35,620
indegree<font color="#CCCCCC"> Delta has to be constant but</font>

623
00:29:33,460 --> 00:29:38,110
surely<font color="#CCCCCC"> it only has to be on at like on</font>

624
00:29:35,620 --> 00:29:40,629
average order one for performance

625
00:29:38,110 --> 00:29:44,889
reasons right you<font color="#E5E5E5"> only care how many</font>

626
00:29:40,630 --> 00:29:49,149
hashes you're doing on average so like

627
00:29:44,890 --> 00:29:52,090
you said the naive thing that the honest

628
00:29:49,149 --> 00:29:53,590
user would do would just be keep all the

629
00:29:52,090 --> 00:29:55,120
pebbles in memory and never erase the

630
00:29:53,590 --> 00:29:57,399
pebble race so if you just<font color="#E5E5E5"> have a graph</font>

631
00:29:55,120 --> 00:29:59,289
that was just one long chain and then

632
00:29:57,399 --> 00:30:02,408
the<font color="#E5E5E5"> last</font><font color="#CCCCCC"> node hashes everything you've</font>

633
00:29:59,289 --> 00:30:08,639
ever seen together right that gives you

634
00:30:02,409 --> 00:30:13,000
a constant average in degree and it

635
00:30:08,639 --> 00:30:16,110
seems<font color="#E5E5E5"> to me that be the naive algorithm</font>

636
00:30:13,000 --> 00:30:23,380
you suggest is the<font color="#CCCCCC"> best you can do there</font>

637
00:30:16,110 --> 00:30:26,309
so um what's wrong<font color="#CCCCCC"> oh okay so that's a</font>

638
00:30:23,380 --> 00:30:29,220
good question um so first of<font color="#E5E5E5"> all if but</font>

639
00:30:26,309 --> 00:30:31,889
<font color="#E5E5E5">if we're</font><font color="#CCCCCC"> talking</font><font color="#E5E5E5"> about average degree</font>

640
00:30:29,220 --> 00:30:35,980
you can still reduce the depths of any

641
00:30:31,889 --> 00:30:38,199
any graph with average with constant

642
00:30:35,980 --> 00:30:41,350
average degree the same same<font color="#E5E5E5"> result</font>

643
00:30:38,200 --> 00:30:43,330
would apply now that example you made

644
00:30:41,350 --> 00:30:46,269
<font color="#E5E5E5">all the pebbles right at the end you</font>

645
00:30:43,330 --> 00:30:51,428
need n pebbles in memory right<font color="#CCCCCC"> um so</font>

646
00:30:46,269 --> 00:30:53,590
there<font color="#E5E5E5"> is there would be a recursive</font>

647
00:30:51,429 --> 00:30:56,559
waseela value so take just the first

648
00:30:53,590 --> 00:31:00,850
chains the<font color="#E5E5E5"> N minus 1 notes there would</font>

649
00:30:56,559 --> 00:31:03,610
be a way<font color="#CCCCCC"> to kind</font><font color="#E5E5E5"> of pebble all those</font>

650
00:31:00,850 --> 00:31:07,269
notes with costs<font color="#CCCCCC"> I believe n Times log</font>

651
00:31:03,610 --> 00:31:09,729
in kind of using a recursive recursive

652
00:31:07,269 --> 00:31:10,950
approach so really<font color="#E5E5E5"> your cumulative cost</font>

653
00:31:09,730 --> 00:31:13,870
[Music]

654
00:31:10,950 --> 00:31:15,700
hard to prove this on the fly<font color="#CCCCCC"> but I</font>

655
00:31:13,870 --> 00:31:19,120
<font color="#E5E5E5">believe the key midibox would actually</font>

656
00:31:15,700 --> 00:31:21,279
be about n log in to evaluate that

657
00:31:19,120 --> 00:31:23,590
function of course<font color="#E5E5E5"> this is assuming that</font>

658
00:31:21,279 --> 00:31:27,789
you can execute that last steps but in

659
00:31:23,590 --> 00:31:30,039
like pseudo constant time right so if

660
00:31:27,789 --> 00:31:32,200
you have a hash value that that depends

661
00:31:30,039 --> 00:31:34,750
on everything everything previously it

662
00:31:32,200 --> 00:31:36,269
seems like it's not really all right

663
00:31:34,750 --> 00:31:40,519
route to be done internet com

664
00:31:36,269 --> 00:31:40,519
ah step but<font color="#CCCCCC"> it's a good</font><font color="#E5E5E5"> question yeah</font>

665
00:31:40,609 --> 00:31:45,689
<font color="#E5E5E5">when the argon and smaller comments from</font>

666
00:31:43,979 --> 00:31:49,019
Argan<font color="#E5E5E5"> to designers in particular if you</font>

667
00:31:45,690 --> 00:31:56,809
scroll back<font color="#E5E5E5"> to the plots with that the</font>

668
00:31:49,019 --> 00:31:59,729
qualities that<font color="#CCCCCC"> graphic so for</font><font color="#E5E5E5"> real world</font>

669
00:31:56,809 --> 00:32:02,849
implementers<font color="#E5E5E5"> some comments so interested</font>

670
00:31:59,729 --> 00:32:05,479
on this blood you see are going to with

671
00:32:02,849 --> 00:32:08,399
different parameters an interesting<font color="#E5E5E5"> wave</font>

672
00:32:05,479 --> 00:32:12,029
the ones at the bottom with<font color="#CCCCCC"> the lowest</font>

673
00:32:08,399 --> 00:32:14,758
<font color="#E5E5E5">deck quality are also slower than and</font>

674
00:32:12,029 --> 00:32:17,159
<font color="#E5E5E5">okay and take much memory within less</font>

675
00:32:14,759 --> 00:32:21,139
memory within the same<font color="#CCCCCC"> time compared to</font>

676
00:32:17,159 --> 00:32:24,979
upper ones so if you want when<font color="#E5E5E5"> you</font>

677
00:32:21,139 --> 00:32:30,329
increase this parameter tau he in fact

678
00:32:24,979 --> 00:32:34,129
the text quality<font color="#E5E5E5"> decreases slower than</font>

679
00:32:30,329 --> 00:32:37,229
adversary's brute force<font color="#CCCCCC"> cost so</font>

680
00:32:34,129 --> 00:32:39,269
counter-intuitively<font color="#CCCCCC"> it's to maximize</font>

681
00:32:37,229 --> 00:32:42,359
<font color="#CCCCCC">costs for adversity to</font><font color="#E5E5E5"> brute force your</font>

682
00:32:39,269 --> 00:32:44,940
<font color="#E5E5E5">passwords</font><font color="#CCCCCC"> it's better to</font><font color="#E5E5E5"> use argon to</font>

683
00:32:42,359 --> 00:32:47,609
with highest attack quality but not the

684
00:32:44,940 --> 00:32:50,969
lowest<font color="#E5E5E5"> one yeah so that's that's an</font>

685
00:32:47,609 --> 00:32:54,539
excellent<font color="#E5E5E5"> the excellent point so there's</font>

686
00:32:50,969 --> 00:32:56,929
two two criteria here there's a attack

687
00:32:54,539 --> 00:32:59,849
quality which measures the ratio between

688
00:32:56,929 --> 00:33:02,219
the cost of<font color="#E5E5E5"> the honest party and the</font>

689
00:32:59,849 --> 00:33:05,700
cost of<font color="#E5E5E5"> the attacker and because we're</font>

690
00:33:02,219 --> 00:33:08,609
plotting attacks quality here this is

691
00:33:05,700 --> 00:33:10,859
hiding what the attackers true true cost

692
00:33:08,609 --> 00:33:13,589
is so if you wanted to maximize the

693
00:33:10,859 --> 00:33:16,918
attackers costs you're actually going<font color="#E5E5E5"> to</font>

694
00:33:13,589 --> 00:33:18,570
pick<font color="#CCCCCC"> this red line that means of</font><font color="#E5E5E5"> course</font>

695
00:33:16,919 --> 00:33:21,329
<font color="#CCCCCC">that the attacker is going to want to</font>

696
00:33:18,570 --> 00:33:24,479
<font color="#E5E5E5">want to run our algorithm because it</font>

697
00:33:21,329 --> 00:33:26,309
gives them the highest advantage but<font color="#E5E5E5"> it</font>

698
00:33:24,479 --> 00:33:27,690
also<font color="#E5E5E5"> means that if you're if you're the</font>

699
00:33:26,309 --> 00:33:29,399
<font color="#E5E5E5">honest partying you're deploying this</font>

700
00:33:27,690 --> 00:33:31,559
algorithm your optimal thing is<font color="#E5E5E5"> actually</font>

701
00:33:29,399 --> 00:33:34,258
going to pick<font color="#CCCCCC"> this to select the</font>

702
00:33:31,559 --> 00:33:35,510
<font color="#E5E5E5">read-option here yeah everyone we think</font>

703
00:33:34,259 --> 00:33:43,319
Jeremiah

704
00:33:35,510 --> 00:33:43,319
[Applause]

