1
00:00:00,060 --> 00:00:02,599
here

2
00:00:04,980 --> 00:00:09,020
today tell us about the importance

3
00:00:10,340 --> 00:00:12,599
all right thank you for the introduction

4
00:00:12,599 --> 00:00:14,759
sorry can you hear me

5
00:00:14,759 --> 00:00:16,800
yes okay cool

6
00:00:16,800 --> 00:00:19,560
um hi everyone my name is Kevin Louie

7
00:00:19,560 --> 00:00:21,480
um I've been an engineer at meta for the

8
00:00:21,480 --> 00:00:23,640
past seven years and I'm really excited

9
00:00:23,640 --> 00:00:25,740
today to be able to talk a little bit

10
00:00:25,740 --> 00:00:27,900
about how end-to-end encrypted backups

11
00:00:27,900 --> 00:00:30,180
work at whatsapp which is a feature that

12
00:00:30,180 --> 00:00:32,880
we launched for our users towards the

13
00:00:32,880 --> 00:00:36,960
end of 2021 and mostly throughout 2022.

14
00:00:36,960 --> 00:00:39,000
so um for this talk I'm going to start

15
00:00:39,000 --> 00:00:40,680
with a little bit of motivation behind

16
00:00:40,680 --> 00:00:42,420
what we mean by end-to-end encrypted

17
00:00:42,420 --> 00:00:44,820
backups why they're important and then

18
00:00:44,820 --> 00:00:46,140
we'll get into the details of how the

19
00:00:46,140 --> 00:00:48,980
protocol actually works

20
00:00:49,700 --> 00:00:52,260
okay so

21
00:00:52,260 --> 00:00:54,539
um just as a review in any end-to-end

22
00:00:54,539 --> 00:00:56,640
encrypted messaging app

23
00:00:56,640 --> 00:00:58,440
um there's this security guarantee that

24
00:00:58,440 --> 00:01:00,120
essentially states that any two users

25
00:01:00,120 --> 00:01:02,100
should be able to establish a secure

26
00:01:02,100 --> 00:01:04,979
Communication channel between them uh

27
00:01:04,979 --> 00:01:08,159
with the guarantee that no one except

28
00:01:08,159 --> 00:01:10,560
for the endpoints the standard receiver

29
00:01:10,560 --> 00:01:12,119
should be able to receive should be able

30
00:01:12,119 --> 00:01:14,939
to read these messages

31
00:01:14,939 --> 00:01:17,820
um and a popular feature that many

32
00:01:17,820 --> 00:01:20,100
people enable on their encrypt on their

33
00:01:20,100 --> 00:01:21,900
end-to-end encrypted messaging apps is

34
00:01:21,900 --> 00:01:23,640
something called automatic Cloud backups

35
00:01:23,640 --> 00:01:25,979
and the idea behind this is that

36
00:01:25,979 --> 00:01:28,080
essentially like a plain text copy of

37
00:01:28,080 --> 00:01:31,140
your messages are periodically synced

38
00:01:31,140 --> 00:01:33,180
and uploaded to a cloud storage provider

39
00:01:33,180 --> 00:01:35,579
so that if the user ends up losing their

40
00:01:35,579 --> 00:01:38,520
device uh and wants to access the

41
00:01:38,520 --> 00:01:40,740
messages on the Lost device then they

42
00:01:40,740 --> 00:01:42,240
can recover them by getting a new device

43
00:01:42,240 --> 00:01:43,799
and then authenticating with the cloud

44
00:01:43,799 --> 00:01:45,840
storage provider to get their messages

45
00:01:45,840 --> 00:01:47,460
again

46
00:01:47,460 --> 00:01:50,159
and the problem with uh This Cloud

47
00:01:50,159 --> 00:01:52,140
backup situation is that it kind of

48
00:01:52,140 --> 00:01:54,060
weakens the ideal security promise of

49
00:01:54,060 --> 00:01:56,460
Android encryption right because now in

50
00:01:56,460 --> 00:01:58,020
addition to Allison Bob who have access

51
00:01:58,020 --> 00:01:59,280
to the messages there's this cloud

52
00:01:59,280 --> 00:02:00,960
storage provider who also has access to

53
00:02:00,960 --> 00:02:02,939
the plain text of these messages

54
00:02:02,939 --> 00:02:04,920
and this is not just a theoretical

55
00:02:04,920 --> 00:02:06,780
weakness this is

56
00:02:06,780 --> 00:02:08,399
um you know in the past there have been

57
00:02:08,399 --> 00:02:12,300
some very high profile cases where users

58
00:02:12,300 --> 00:02:13,739
will enable

59
00:02:13,739 --> 00:02:15,540
these online Cloud backups thinking that

60
00:02:15,540 --> 00:02:16,560
they're still onto an encryption

61
00:02:16,560 --> 00:02:18,540
protecting their messages but then say

62
00:02:18,540 --> 00:02:22,140
like a government agency comes in uh

63
00:02:22,140 --> 00:02:24,660
goes to the cloud storage provider to

64
00:02:24,660 --> 00:02:25,920
get access to the plain text messages

65
00:02:25,920 --> 00:02:28,500
and the user is confused as to how the

66
00:02:28,500 --> 00:02:30,360
Android the end-to-end encryption was

67
00:02:30,360 --> 00:02:32,340
broken in WhatsApp

68
00:02:32,340 --> 00:02:35,280
so up until 2022 WhatsApp users

69
00:02:35,280 --> 00:02:37,500
basically had two options either they

70
00:02:37,500 --> 00:02:40,140
don't enable backups and risk losing

71
00:02:40,140 --> 00:02:42,239
access to their messages if they lose

72
00:02:42,239 --> 00:02:45,000
their device or they enable backups with

73
00:02:45,000 --> 00:02:47,819
say iCloud or Google Drive and they have

74
00:02:47,819 --> 00:02:50,040
they have to essentially deal with the

75
00:02:50,040 --> 00:02:52,019
consequences of having weaker guarantees

76
00:02:52,019 --> 00:02:53,640
around the confidential the

77
00:02:53,640 --> 00:02:57,018
confidentiality of their messages

78
00:02:57,660 --> 00:02:59,519
so yeah basically there's this natural

79
00:02:59,519 --> 00:03:02,700
tension that exists oh

80
00:03:02,700 --> 00:03:05,220
sorry there's this natural tension that

81
00:03:05,220 --> 00:03:07,080
exists between usability and privacy

82
00:03:07,080 --> 00:03:09,540
here right ideally we want users to have

83
00:03:09,540 --> 00:03:10,980
the best of both options instead of

84
00:03:10,980 --> 00:03:13,080
having to choose usability over privacy

85
00:03:13,080 --> 00:03:14,940
or vice versa

86
00:03:14,940 --> 00:03:16,980
so this is what we mean by end-to-end

87
00:03:16,980 --> 00:03:19,019
encrypted backups essentially we want to

88
00:03:19,019 --> 00:03:21,480
make sure that we can still do backups

89
00:03:21,480 --> 00:03:24,500
but no one except for the endpoints

90
00:03:24,500 --> 00:03:26,819
the users themselves can access the

91
00:03:26,819 --> 00:03:28,700
backup data

92
00:03:28,700 --> 00:03:31,860
and so there are two kind of potential

93
00:03:31,860 --> 00:03:34,200
Solutions here one way we can try to

94
00:03:34,200 --> 00:03:36,239
achieve this is to essentially have

95
00:03:36,239 --> 00:03:38,459
users just like write down a serialized

96
00:03:38,459 --> 00:03:40,260
version of their encryption key

97
00:03:40,260 --> 00:03:42,060
um so like imagine you have a 256-bit

98
00:03:42,060 --> 00:03:44,940
backup key then we show the 256 bits to

99
00:03:44,940 --> 00:03:46,860
you and ask the users to store it

100
00:03:46,860 --> 00:03:48,900
somewhere safe right and we actually do

101
00:03:48,900 --> 00:03:51,120
have this option but we don't expect

102
00:03:51,120 --> 00:03:54,239
that most users will actually do this

103
00:03:54,239 --> 00:03:56,040
um so there's another option that we

104
00:03:56,040 --> 00:03:59,040
provide which is to allow users to set a

105
00:03:59,040 --> 00:04:01,560
memorable password that will gate access

106
00:04:01,560 --> 00:04:04,319
to their backup key and then enforce a

107
00:04:04,319 --> 00:04:06,299
maximum attempt counter

108
00:04:06,299 --> 00:04:09,060
um on top of that so the idea is

109
00:04:09,060 --> 00:04:11,640
um we give the user a certain number of

110
00:04:11,640 --> 00:04:14,340
attempts to enter their password to get

111
00:04:14,340 --> 00:04:16,500
access to their backup key and if say

112
00:04:16,500 --> 00:04:18,418
they fail after 10 attempts then the

113
00:04:18,418 --> 00:04:20,699
backups are actually irrecoverable from

114
00:04:20,699 --> 00:04:22,680
that point forward

115
00:04:22,680 --> 00:04:25,680
so this protocol that's behind this

116
00:04:25,680 --> 00:04:28,460
password with enforcing attempts limit

117
00:04:28,460 --> 00:04:30,419
method will be the subject of today's

118
00:04:30,419 --> 00:04:32,719
talk

119
00:04:33,440 --> 00:04:36,960
okay so in this protocol there are three

120
00:04:36,960 --> 00:04:38,900
parties there is going to be the client

121
00:04:38,900 --> 00:04:41,100
there's the cloud provider where the

122
00:04:41,100 --> 00:04:43,740
backups are stored uh using encryption

123
00:04:43,740 --> 00:04:45,360
and then there's a key Vault that's

124
00:04:45,360 --> 00:04:48,240
managed by WhatsApp uh which uses an HSM

125
00:04:48,240 --> 00:04:51,479
to store the user's encryption keys

126
00:04:51,479 --> 00:04:53,460
and the way the flow works is first the

127
00:04:53,460 --> 00:04:55,400
client will generate an encryption key

128
00:04:55,400 --> 00:04:57,900
and register a password to the key vault

129
00:04:57,900 --> 00:05:00,479
at which point their encryption key gets

130
00:05:00,479 --> 00:05:02,639
stored in the vault

131
00:05:02,639 --> 00:05:04,259
and the encryption key is then in

132
00:05:04,259 --> 00:05:05,759
parallel used to encrypt the messages

133
00:05:05,759 --> 00:05:08,220
that get uploaded to the cloud provider

134
00:05:08,220 --> 00:05:09,960
and then when a user wants to recover

135
00:05:09,960 --> 00:05:11,820
their backups they need to submit the

136
00:05:11,820 --> 00:05:13,080
same password that was used during

137
00:05:13,080 --> 00:05:16,020
registration to retrieve their key which

138
00:05:16,020 --> 00:05:17,820
is then used to once they have the key

139
00:05:17,820 --> 00:05:19,919
decrypt the encrypted message content

140
00:05:19,919 --> 00:05:21,240
that they retrieve from the cloud

141
00:05:21,240 --> 00:05:23,100
storage provider

142
00:05:23,100 --> 00:05:24,780
and if they enter an incorrect password

143
00:05:24,780 --> 00:05:26,880
then the user does not get their key

144
00:05:26,880 --> 00:05:28,979
back and this attempt counter goes up by

145
00:05:28,979 --> 00:05:31,159
one

146
00:05:31,259 --> 00:05:34,139
so from a cryptography perspective the

147
00:05:34,139 --> 00:05:35,699
two interesting Parts which we'll cover

148
00:05:35,699 --> 00:05:38,880
are a how does the key Vault work that

149
00:05:38,880 --> 00:05:41,460
WhatsApp maintains and B how do clients

150
00:05:41,460 --> 00:05:43,500
actually use a password to authenticate

151
00:05:43,500 --> 00:05:47,120
to this key ball in a secure manner

152
00:05:48,360 --> 00:05:50,639
okay so here's a more detailed view of

153
00:05:50,639 --> 00:05:52,800
what's going on inside the WhatsApp key

154
00:05:52,800 --> 00:05:55,380
Vault and by the way before I describe

155
00:05:55,380 --> 00:05:57,600
this entire system I just want to caveat

156
00:05:57,600 --> 00:05:59,759
that this is very much inspired by other

157
00:05:59,759 --> 00:06:02,220
works at other companies so for example

158
00:06:02,220 --> 00:06:03,600
um Apple in the past has talked about a

159
00:06:03,600 --> 00:06:05,759
version of this signal has a blog post

160
00:06:05,759 --> 00:06:08,039
about their own version of this and I

161
00:06:08,039 --> 00:06:09,780
think Google also has one as well so

162
00:06:09,780 --> 00:06:11,220
this is by no means a new design that

163
00:06:11,220 --> 00:06:15,080
we've come up with entirely on our own

164
00:06:15,560 --> 00:06:19,259
okay so first off we use hsms which

165
00:06:19,259 --> 00:06:22,199
stand for Hardware security modules as

166
00:06:22,199 --> 00:06:24,120
the hardware back security solution for

167
00:06:24,120 --> 00:06:27,120
providing a tamper resistant execution

168
00:06:27,120 --> 00:06:28,680
environment assuming that you trust the

169
00:06:28,680 --> 00:06:32,340
HSN vendors statements and the hsms

170
00:06:32,340 --> 00:06:34,139
provide protection for the Mastery

171
00:06:34,139 --> 00:06:36,440
secret keys that are used in this Vault

172
00:06:36,440 --> 00:06:38,580
and the interesting thing about them is

173
00:06:38,580 --> 00:06:40,080
that they can be essentially programmed

174
00:06:40,080 --> 00:06:43,740
using a set of admin cards which will

175
00:06:43,740 --> 00:06:45,960
allow us as Engineers to load custom

176
00:06:45,960 --> 00:06:48,479
code onto these modules and then run it

177
00:06:48,479 --> 00:06:49,860
on the hsms

178
00:06:49,860 --> 00:06:51,780
and the way that we use these admin

179
00:06:51,780 --> 00:06:54,120
cards is to initialize the system is

180
00:06:54,120 --> 00:06:55,680
with you can imagine like a trusted

181
00:06:55,680 --> 00:06:56,819
ceremony

182
00:06:56,819 --> 00:06:59,520
um that loads the key Vault code uh onto

183
00:06:59,520 --> 00:07:02,400
these hsms and then after we load that

184
00:07:02,400 --> 00:07:04,500
code we then physically destroy the

185
00:07:04,500 --> 00:07:05,880
admin carts

186
00:07:05,880 --> 00:07:07,380
um and the reason for this is that we

187
00:07:07,380 --> 00:07:08,699
don't want to be able to have the

188
00:07:08,699 --> 00:07:10,620
ability to update the code on these hsms

189
00:07:10,620 --> 00:07:12,539
after the facts

190
00:07:12,539 --> 00:07:14,580
um in particular we wouldn't want to

191
00:07:14,580 --> 00:07:17,699
have a secure system and then later on

192
00:07:17,699 --> 00:07:20,099
try to insert a backdoor for instance by

193
00:07:20,099 --> 00:07:22,259
changing the code into HSM so what we're

194
00:07:22,259 --> 00:07:24,000
really going for here I guess is an

195
00:07:24,000 --> 00:07:25,979
immutable execution environment with

196
00:07:25,979 --> 00:07:28,740
this procedure

197
00:07:28,740 --> 00:07:32,220
um right and then we use the hsms to

198
00:07:32,220 --> 00:07:33,479
store the encryption keys that the

199
00:07:33,479 --> 00:07:35,699
client generates and needs to to be able

200
00:07:35,699 --> 00:07:37,199
to recover

201
00:07:37,199 --> 00:07:40,080
and we also need these hsms to be able

202
00:07:40,080 --> 00:07:42,360
to store an attempt counter for every

203
00:07:42,360 --> 00:07:44,340
user account so that once the maximum

204
00:07:44,340 --> 00:07:46,800
attempts for wrong passwords have been

205
00:07:46,800 --> 00:07:48,960
reached then the HSN refuses to ever

206
00:07:48,960 --> 00:07:53,160
return that key for the for for any user

207
00:07:53,160 --> 00:07:56,580
okay so one challenge that we had to

208
00:07:56,580 --> 00:08:00,120
deal with is that hsms they only have a

209
00:08:00,120 --> 00:08:01,979
very limited amount of secure memory

210
00:08:01,979 --> 00:08:03,840
that they can manage which is going to

211
00:08:03,840 --> 00:08:06,060
be way smaller than what's actually

212
00:08:06,060 --> 00:08:07,680
needed to store all the encryption keys

213
00:08:07,680 --> 00:08:10,500
that correspond and also the intep

214
00:08:10,500 --> 00:08:11,880
counter is for every WhatsApp user right

215
00:08:11,880 --> 00:08:13,199
like WhatsApp has billions of users

216
00:08:13,199 --> 00:08:16,560
these hsms have maybe like megabytes at

217
00:08:16,560 --> 00:08:18,979
most of secure memory

218
00:08:18,979 --> 00:08:22,259
so to address this the hsms rely on an

219
00:08:22,259 --> 00:08:24,360
external storage for these values where

220
00:08:24,360 --> 00:08:27,180
the HSM first encrypts all the Blobs of

221
00:08:27,180 --> 00:08:29,520
data that it would normally store for a

222
00:08:29,520 --> 00:08:32,599
user using a key that only the HSM knows

223
00:08:32,599 --> 00:08:35,520
and then implicitly maintains a Merkle

224
00:08:35,520 --> 00:08:37,620
tree of all these data blobs where the

225
00:08:37,620 --> 00:08:39,779
root hash of the Merkle tree is kept in

226
00:08:39,779 --> 00:08:43,860
a secure memory location in the HSM

227
00:08:43,860 --> 00:08:46,680
and the idea behind this is that now

228
00:08:46,680 --> 00:08:49,200
every time the HSM wants to add or

229
00:08:49,200 --> 00:08:51,480
update an entry to the database then it

230
00:08:51,480 --> 00:08:53,100
will do so and then ask the database

231
00:08:53,100 --> 00:08:56,160
layer which we consider untrusted to

232
00:08:56,160 --> 00:08:58,200
provide a Merkel inclusion proof that

233
00:08:58,200 --> 00:08:59,700
the value was actually updated correctly

234
00:08:59,700 --> 00:09:02,820
and if the proof fails to verify because

235
00:09:02,820 --> 00:09:04,560
the database operator was say acting

236
00:09:04,560 --> 00:09:06,420
maliciously or trying to do a rollback

237
00:09:06,420 --> 00:09:09,060
attack on the values then the HSM can

238
00:09:09,060 --> 00:09:10,680
detect this

239
00:09:10,680 --> 00:09:12,540
and then similarly when HSM wants to

240
00:09:12,540 --> 00:09:14,399
look up a specific value like see what

241
00:09:14,399 --> 00:09:15,779
the current attempts counter for a user

242
00:09:15,779 --> 00:09:18,779
is then it also asks for an inclusion

243
00:09:18,779 --> 00:09:20,700
proof to verify that the database

244
00:09:20,700 --> 00:09:22,140
operator essentially isn't playing any

245
00:09:22,140 --> 00:09:24,240
tricks on it

246
00:09:24,240 --> 00:09:26,120
foreign

247
00:09:26,120 --> 00:09:28,200
and then additionally what we have

248
00:09:28,200 --> 00:09:30,480
pictured here is not just a single HSM

249
00:09:30,480 --> 00:09:32,880
but you know a cluster of hsms and this

250
00:09:32,880 --> 00:09:35,519
is mainly for for reliability purposes

251
00:09:35,519 --> 00:09:37,140
um if one HSM has a hardware failure

252
00:09:37,140 --> 00:09:38,580
then we want to make sure that the

253
00:09:38,580 --> 00:09:39,779
system is still up and running because

254
00:09:39,779 --> 00:09:42,000
we threw away our ability to update the

255
00:09:42,000 --> 00:09:45,240
code on these hsms so what we do is we

256
00:09:45,240 --> 00:09:46,860
have this Quorum of nodes each

257
00:09:46,860 --> 00:09:49,560
redundantly storing the same data and

258
00:09:49,560 --> 00:09:51,360
communicating with each user using

259
00:09:51,360 --> 00:09:53,160
secure channels

260
00:09:53,160 --> 00:09:55,200
um in between the hsms themselves to

261
00:09:55,200 --> 00:09:56,940
establish consensus

262
00:09:56,940 --> 00:09:59,459
and then uh yeah and this is extra

263
00:09:59,459 --> 00:10:01,260
important because if we're trying to

264
00:10:01,260 --> 00:10:03,000
enforce say like a global attempt

265
00:10:03,000 --> 00:10:05,160
counter for each account since we want

266
00:10:05,160 --> 00:10:06,720
to make sure that

267
00:10:06,720 --> 00:10:09,660
um each password that if a user contacts

268
00:10:09,660 --> 00:10:11,760
one HSM and a password fails then all

269
00:10:11,760 --> 00:10:13,980
hsns know about it otherwise like if we

270
00:10:13,980 --> 00:10:17,160
have a cluster of five hsms and we want

271
00:10:17,160 --> 00:10:19,200
to and each enforces a counter of say up

272
00:10:19,200 --> 00:10:20,880
to 10 then this would really be like

273
00:10:20,880 --> 00:10:25,019
okay uh having a total of of 50 attempts

274
00:10:25,019 --> 00:10:27,660
for each user

275
00:10:27,660 --> 00:10:31,680
foreign setup

276
00:10:32,100 --> 00:10:34,680
um basically we have this Quorum of hsms

277
00:10:34,680 --> 00:10:36,180
um each are maintaining these Merkle

278
00:10:36,180 --> 00:10:39,420
trees for this gigantic database of uh

279
00:10:39,420 --> 00:10:40,860
Records for each user containing

280
00:10:40,860 --> 00:10:43,200
encryption keys and how many attempts

281
00:10:43,200 --> 00:10:45,959
have been used to try to retrieve these

282
00:10:45,959 --> 00:10:48,120
encryption Keys now we're ready to talk

283
00:10:48,120 --> 00:10:50,220
about the second piece which is how does

284
00:10:50,220 --> 00:10:52,320
a client actually authenticate itself to

285
00:10:52,320 --> 00:10:54,660
the HSN cluster using a password

286
00:10:54,660 --> 00:10:56,220
and that's going to be the main focus

287
00:10:56,220 --> 00:10:59,000
for the rest of these slides

288
00:11:01,079 --> 00:11:03,959
so first in order for the client to know

289
00:11:03,959 --> 00:11:06,000
that it's actually talking to the

290
00:11:06,000 --> 00:11:08,339
correct HSM or set of HSM servers

291
00:11:08,339 --> 00:11:09,899
there's going to be a public key that's

292
00:11:09,899 --> 00:11:12,120
associated with the HSM that the client

293
00:11:12,120 --> 00:11:14,640
verifies and this public key is

294
00:11:14,640 --> 00:11:16,079
distributed to the client on app install

295
00:11:16,079 --> 00:11:18,540
so this kind of serves as the boot

296
00:11:18,540 --> 00:11:20,579
shopping mechanism for the root of trust

297
00:11:20,579 --> 00:11:22,560
for authentication here

298
00:11:22,560 --> 00:11:24,839
and there are two options that we

299
00:11:24,839 --> 00:11:27,660
consider here option one is kind of like

300
00:11:27,660 --> 00:11:29,279
the most straightforward option which is

301
00:11:29,279 --> 00:11:31,680
for the client to just say encrypt their

302
00:11:31,680 --> 00:11:34,500
password to the hsm's public key so that

303
00:11:34,500 --> 00:11:36,360
the HSM can decrypt it or you can

304
00:11:36,360 --> 00:11:37,860
imagine they first hash the password and

305
00:11:37,860 --> 00:11:40,260
then the HSM decrypts to get the hash of

306
00:11:40,260 --> 00:11:42,240
the password and then check against what

307
00:11:42,240 --> 00:11:44,640
was registered and if it matches then

308
00:11:44,640 --> 00:11:46,380
the client just encrypts their backup

309
00:11:46,380 --> 00:11:48,600
key in the same way and the HSM stores

310
00:11:48,600 --> 00:11:50,279
it

311
00:11:50,279 --> 00:11:52,200
right but one problem with this approach

312
00:11:52,200 --> 00:11:53,640
and by the way this is what pretty much

313
00:11:53,640 --> 00:11:55,980
like if you imagine logging into any

314
00:11:55,980 --> 00:11:59,040
website that requires a username and

315
00:11:59,040 --> 00:12:00,060
password this is probably what they do

316
00:12:00,060 --> 00:12:01,260
with the password like passwords over

317
00:12:01,260 --> 00:12:02,700
TLS

318
00:12:02,700 --> 00:12:04,019
um and one one problem with this

319
00:12:04,019 --> 00:12:05,700
approach is that the Privacy for the

320
00:12:05,700 --> 00:12:08,160
user's password relies entirely on the

321
00:12:08,160 --> 00:12:10,800
user trusting the Hardware security

322
00:12:10,800 --> 00:12:13,980
layer in our setup because the HSM gets

323
00:12:13,980 --> 00:12:15,899
to see like a plain text version of

324
00:12:15,899 --> 00:12:17,279
either the password or the hash the

325
00:12:17,279 --> 00:12:19,140
password depending on how how you do

326
00:12:19,140 --> 00:12:19,980
that

327
00:12:19,980 --> 00:12:22,019
so in our design

328
00:12:22,019 --> 00:12:23,700
um we decided to go for a slightly more

329
00:12:23,700 --> 00:12:26,160
advanced product approach which is to

330
00:12:26,160 --> 00:12:27,779
use a password authenticated key

331
00:12:27,779 --> 00:12:30,120
exchange protocol called opaque

332
00:12:30,120 --> 00:12:32,220
and one really cool thing about OPEC is

333
00:12:32,220 --> 00:12:34,920
that it has this guarantee that the the

334
00:12:34,920 --> 00:12:36,600
password is never actually exposed to

335
00:12:36,600 --> 00:12:38,940
the HSM server in plain text and we'll

336
00:12:38,940 --> 00:12:40,260
talk a little bit more about that in

337
00:12:40,260 --> 00:12:42,620
just a second

338
00:12:44,519 --> 00:12:46,920
okay so opaque is a protocol that was

339
00:12:46,920 --> 00:12:49,560
presented in eurocrypt in 2018 and

340
00:12:49,560 --> 00:12:51,959
there's actually a long line of works in

341
00:12:51,959 --> 00:12:53,820
the pick domain that achieve I guess

342
00:12:53,820 --> 00:12:55,560
like various properties

343
00:12:55,560 --> 00:12:57,779
um and the opaque paper the authors

344
00:12:57,779 --> 00:12:59,100
present a stronger notion of security

345
00:12:59,100 --> 00:13:00,600
than what was previously achievable

346
00:13:00,600 --> 00:13:03,360
called a strong asymmetric password I

347
00:13:03,360 --> 00:13:04,980
think exchange protocol

348
00:13:04,980 --> 00:13:07,620
and just for some background here

349
00:13:07,620 --> 00:13:10,200
um in a normal asymmetric pick there is

350
00:13:10,200 --> 00:13:11,880
a client and there's a server and the

351
00:13:11,880 --> 00:13:14,519
client has a password server has you can

352
00:13:14,519 --> 00:13:16,560
say like a one-way function of the

353
00:13:16,560 --> 00:13:18,779
password and together they engage in a

354
00:13:18,779 --> 00:13:21,000
protocol that allows them to establish a

355
00:13:21,000 --> 00:13:22,620
shared secret

356
00:13:22,620 --> 00:13:25,019
um using these two starting values

357
00:13:25,019 --> 00:13:27,959
and the new thing at the time uh with

358
00:13:27,959 --> 00:13:30,480
this with OPEC was that they introduced

359
00:13:30,480 --> 00:13:33,120
this definition of a strong asymmetric

360
00:13:33,120 --> 00:13:36,540
pick which is basically a way of saying

361
00:13:36,540 --> 00:13:38,399
that the protocol is resistant to a

362
00:13:38,399 --> 00:13:39,779
class of attacks called pre-computation

363
00:13:39,779 --> 00:13:41,940
attacks and so a pre-computation attack

364
00:13:41,940 --> 00:13:44,880
is this idea that an attacker can

365
00:13:44,880 --> 00:13:46,860
essentially if they want to be able to

366
00:13:46,860 --> 00:13:51,839
uh try to recover these servers hash or

367
00:13:51,839 --> 00:13:53,220
the password they could build like a

368
00:13:53,220 --> 00:13:54,300
rainbow table or some sort of

369
00:13:54,300 --> 00:13:57,420
pre-computing table before compromising

370
00:13:57,420 --> 00:13:59,339
the server so that once they have this

371
00:13:59,339 --> 00:14:00,899
table and then they if they're able to

372
00:14:00,899 --> 00:14:02,040
compromise the server then they can

373
00:14:02,040 --> 00:14:04,380
immediately recover uh passwords so this

374
00:14:04,380 --> 00:14:05,579
is kind of like outside the scope of

375
00:14:05,579 --> 00:14:06,899
this talk but

376
00:14:06,899 --> 00:14:08,579
um I guess the high level idea is there

377
00:14:08,579 --> 00:14:10,380
is the stronger security notion for pigs

378
00:14:10,380 --> 00:14:12,839
and opaque achieves it

379
00:14:12,839 --> 00:14:15,480
um and also opic was selected as the

380
00:14:15,480 --> 00:14:18,000
winner of the asymmetric pick

381
00:14:18,000 --> 00:14:20,639
competition that was held by the cfrg in

382
00:14:20,639 --> 00:14:23,100
2020 they had two competitions one for

383
00:14:23,100 --> 00:14:25,019
symmetric picks one for asymmetric and

384
00:14:25,019 --> 00:14:27,959
opaque was selected as the protocol to

385
00:14:27,959 --> 00:14:30,959
standardize for asymmetric picks which

386
00:14:30,959 --> 00:14:32,820
definitely weighed into our decision for

387
00:14:32,820 --> 00:14:34,980
using it within WhatsApp

388
00:14:34,980 --> 00:14:36,720
um so anyway one of the main results of

389
00:14:36,720 --> 00:14:40,440
this paper is a practical a practical

390
00:14:40,440 --> 00:14:42,720
construction or instantiation of

391
00:14:42,720 --> 00:14:44,820
achieving a strong opaque

392
00:14:44,820 --> 00:14:47,100
um from two things an oblivious super

393
00:14:47,100 --> 00:14:48,600
random function

394
00:14:48,600 --> 00:14:51,300
um and an authenticated key exchange and

395
00:14:51,300 --> 00:14:53,100
in our case we use something called dho

396
00:14:53,100 --> 00:14:55,920
prf which is this function here it's

397
00:14:55,920 --> 00:14:58,019
basically a specific instantiation of in

398
00:14:58,019 --> 00:15:03,500
Oblivion an oblivious several function

399
00:15:04,500 --> 00:15:07,620
okay so there are two flows here there's

400
00:15:07,620 --> 00:15:09,420
backup registration and there's backup

401
00:15:09,420 --> 00:15:11,940
recovery and each flow involves a series

402
00:15:11,940 --> 00:15:13,440
of messages that are passed between

403
00:15:13,440 --> 00:15:15,959
client and server backup registration is

404
00:15:15,959 --> 00:15:17,579
triggered when you enable the encrypted

405
00:15:17,579 --> 00:15:20,160
backups feature on your phone and that's

406
00:15:20,160 --> 00:15:22,019
when you have to select a password

407
00:15:22,019 --> 00:15:24,420
and backup recovery is triggered when

408
00:15:24,420 --> 00:15:26,100
say you lose your old phone and you are

409
00:15:26,100 --> 00:15:27,899
trying to recover your message history

410
00:15:27,899 --> 00:15:30,600
and here's where you have to enter that

411
00:15:30,600 --> 00:15:32,100
same password use for registration in

412
00:15:32,100 --> 00:15:34,940
order to retrieve your messages

413
00:15:35,699 --> 00:15:36,959
okay so I'm going to try to go through

414
00:15:36,959 --> 00:15:38,519
the protocol

415
00:15:38,519 --> 00:15:40,920
um so for registration the client starts

416
00:15:40,920 --> 00:15:43,139
out with a backup key k

417
00:15:43,139 --> 00:15:45,660
um a password and the hsn's public key

418
00:15:45,660 --> 00:15:47,880
and the HSM starts out with its private

419
00:15:47,880 --> 00:15:48,839
key

420
00:15:48,839 --> 00:15:50,820
and remember we assumed that the HSN

421
00:15:50,820 --> 00:15:52,500
public key has already been distributed

422
00:15:52,500 --> 00:15:54,779
to the client on app install so it's

423
00:15:54,779 --> 00:15:57,500
baked into the code

424
00:15:57,860 --> 00:16:00,240
and so in this protocol we'll be doing

425
00:16:00,240 --> 00:16:03,360
operations over a prime Order Group

426
00:16:03,360 --> 00:16:05,220
um and in the first step the client

427
00:16:05,220 --> 00:16:08,279
chooses a random scalar R and sends

428
00:16:08,279 --> 00:16:09,959
Alpha which is Hash of the passwords

429
00:16:09,959 --> 00:16:12,120
that are where this hash function is a

430
00:16:12,120 --> 00:16:13,860
hash to curve operation by the way if

431
00:16:13,860 --> 00:16:15,480
you've seen oprso4 this might just be

432
00:16:15,480 --> 00:16:17,459
review

433
00:16:17,459 --> 00:16:20,820
and then the server gets Alpha it then

434
00:16:20,820 --> 00:16:22,560
picks out a random scalar let's call it

435
00:16:22,560 --> 00:16:25,560
K Prime along with the knots and then

436
00:16:25,560 --> 00:16:27,540
computes beta which is just Alpha raise

437
00:16:27,540 --> 00:16:30,060
the K Prime and sends this along with

438
00:16:30,060 --> 00:16:33,079
the non-spec to the client

439
00:16:33,600 --> 00:16:38,660
and then in step five oops

440
00:16:38,880 --> 00:16:42,440
sorry in step five the client takes beta

441
00:16:42,440 --> 00:16:45,959
it raises it to the one over R and then

442
00:16:45,959 --> 00:16:48,240
hashes this along with the password and

443
00:16:48,240 --> 00:16:50,279
here we can imagine also using a slow

444
00:16:50,279 --> 00:16:53,060
password hashing function like pbkdf

445
00:16:53,060 --> 00:16:56,040
to get two outputs something called an

446
00:16:56,040 --> 00:16:59,220
export key and a client private key

447
00:16:59,220 --> 00:17:01,079
which we which we're going to use in the

448
00:17:01,079 --> 00:17:01,920
next step

449
00:17:01,920 --> 00:17:04,380
or sorry in the

450
00:17:04,380 --> 00:17:06,900
in the recovery flow

451
00:17:06,900 --> 00:17:10,140
uh and then in Step six the client

452
00:17:10,140 --> 00:17:13,679
has these two outputs it uh AES encrypts

453
00:17:13,679 --> 00:17:16,679
their actual backup key UK using the

454
00:17:16,679 --> 00:17:19,260
export key and then it also computes

455
00:17:19,260 --> 00:17:21,959
their own the public key component for

456
00:17:21,959 --> 00:17:23,699
their private key that was derived from

457
00:17:23,699 --> 00:17:26,900
this pvkdf operation

458
00:17:26,959 --> 00:17:31,080
and then finally it uses a CCA secure

459
00:17:31,080 --> 00:17:33,299
encryption scheme to encrypt using the

460
00:17:33,299 --> 00:17:37,740
hsm's public key the value K star which

461
00:17:37,740 --> 00:17:41,160
is sorry the the AES output along with

462
00:17:41,160 --> 00:17:43,679
this entire registration transcript

463
00:17:43,679 --> 00:17:46,799
okay and then the server upon receiving

464
00:17:46,799 --> 00:17:49,559
the Cyber text is going to decrypt and

465
00:17:49,559 --> 00:17:51,840
verify the transcripts and then stores

466
00:17:51,840 --> 00:17:54,780
k-star K Prime and the client public key

467
00:17:54,780 --> 00:17:58,100
for that user

468
00:17:59,760 --> 00:18:01,919
so definitely a lot of details here but

469
00:18:01,919 --> 00:18:04,200
the takeaway is that the client and

470
00:18:04,200 --> 00:18:06,120
server are essentially jointly Computing

471
00:18:06,120 --> 00:18:07,740
the output of a pseudo-random function

472
00:18:07,740 --> 00:18:09,960
where the input is not exposed to the

473
00:18:09,960 --> 00:18:11,760
server and the key is not exposed to the

474
00:18:11,760 --> 00:18:12,780
client

475
00:18:12,780 --> 00:18:15,600
and the server generates a random prf

476
00:18:15,600 --> 00:18:18,720
key and ends up storing a k star which

477
00:18:18,720 --> 00:18:21,360
is the encryption of the sensitive

478
00:18:21,360 --> 00:18:22,980
payload which in this case is the

479
00:18:22,980 --> 00:18:24,480
client's backup key okay

480
00:18:24,480 --> 00:18:26,220
using a key that's derived from the

481
00:18:26,220 --> 00:18:28,799
output of the prf along with

482
00:18:28,799 --> 00:18:30,360
um also storing a client public key

483
00:18:30,360 --> 00:18:32,280
where the corresponding private key

484
00:18:32,280 --> 00:18:33,900
component is also derived from the

485
00:18:33,900 --> 00:18:37,460
output of the prf that's it

486
00:18:38,820 --> 00:18:42,660
okay so now for the recovery flow

487
00:18:42,660 --> 00:18:45,000
um the client starts with a password and

488
00:18:45,000 --> 00:18:47,160
the HSN public key again and the server

489
00:18:47,160 --> 00:18:49,320
has the HSN private key along with three

490
00:18:49,320 --> 00:18:52,140
elements of the client record this K

491
00:18:52,140 --> 00:18:54,720
star k Prime and the client public

492
00:18:54,720 --> 00:18:57,380
component

493
00:18:57,600 --> 00:19:00,179
and step one is almost the same as in

494
00:19:00,179 --> 00:19:01,679
registration where the client picks a

495
00:19:01,679 --> 00:19:03,960
random scalar R computes Alpha which is

496
00:19:03,960 --> 00:19:06,419
Hash a password to the r and this time

497
00:19:06,419 --> 00:19:08,280
also the client selects an ephemeral

498
00:19:08,280 --> 00:19:10,380
private key for the key exchange

499
00:19:10,380 --> 00:19:12,660
component and sends over the public key

500
00:19:12,660 --> 00:19:17,299
component of that ephemeral private key

501
00:19:17,299 --> 00:19:20,160
and next the server picks its own

502
00:19:20,160 --> 00:19:21,740
ephemeral private key

503
00:19:21,740 --> 00:19:26,220
uh uses K Prime to construct beta in the

504
00:19:26,220 --> 00:19:28,640
same way as in registration

505
00:19:28,640 --> 00:19:31,080
and also

506
00:19:31,080 --> 00:19:35,160
uh uh has a signature attached to the um

507
00:19:35,160 --> 00:19:37,740
to Beta which is sent to the client

508
00:19:37,740 --> 00:19:39,240
um and critically at this point the

509
00:19:39,240 --> 00:19:40,799
server also decrements the attempts

510
00:19:40,799 --> 00:19:42,539
counter or sorry it increments the

511
00:19:42,539 --> 00:19:44,280
attempts counter

512
00:19:44,280 --> 00:19:47,460
um for the client so that the server

513
00:19:47,460 --> 00:19:50,340
um basically remember we're not just

514
00:19:50,340 --> 00:19:52,620
doing an Authentication Protocol with a

515
00:19:52,620 --> 00:19:54,120
password but we also want to make sure

516
00:19:54,120 --> 00:19:55,799
that we're keeping track of the number

517
00:19:55,799 --> 00:19:57,480
of failed attempts that the client has

518
00:19:57,480 --> 00:19:59,880
made so this is the attempt counter for

519
00:19:59,880 --> 00:20:00,960
that

520
00:20:00,960 --> 00:20:03,240
interaction

521
00:20:03,240 --> 00:20:04,380
um

522
00:20:04,380 --> 00:20:06,720
and next the client is going to

523
00:20:06,720 --> 00:20:09,059
recompute the prf output using the

524
00:20:09,059 --> 00:20:10,380
password hashing function in the same

525
00:20:10,380 --> 00:20:13,799
way and here the guarantee is that if

526
00:20:13,799 --> 00:20:14,760
the pin was the same as it was

527
00:20:14,760 --> 00:20:17,160
registered then the resulting export key

528
00:20:17,160 --> 00:20:19,020
and the client private key will be the

529
00:20:19,020 --> 00:20:21,299
same and otherwise the client gets a

530
00:20:21,299 --> 00:20:22,580
completely independent looking output

531
00:20:22,580 --> 00:20:26,400
which should be useless to them

532
00:20:26,400 --> 00:20:28,799
okay so assuming that the client did use

533
00:20:28,799 --> 00:20:30,960
the same password then they use the

534
00:20:30,960 --> 00:20:32,820
server as static public key the

535
00:20:32,820 --> 00:20:34,380
ephemeral public key and the client

536
00:20:34,380 --> 00:20:36,840
static key to obtain a shared secret key

537
00:20:36,840 --> 00:20:39,059
and finally sends a message to the

538
00:20:39,059 --> 00:20:42,660
server to complete the key exchange

539
00:20:42,660 --> 00:20:45,260
foreign

540
00:20:45,500 --> 00:20:48,900
call the server verifies that the key

541
00:20:48,900 --> 00:20:51,600
exchange is complete and if successful

542
00:20:51,600 --> 00:20:54,299
resets the attempts counter and also

543
00:20:54,299 --> 00:20:56,340
derives the same shared secret key and

544
00:20:56,340 --> 00:21:00,539
finally uses uh or it takes k-star and

545
00:21:00,539 --> 00:21:02,160
encrypts this using the secret key

546
00:21:02,160 --> 00:21:04,140
sending the ciphertext over back to the

547
00:21:04,140 --> 00:21:05,580
client

548
00:21:05,580 --> 00:21:08,400
and the very last step the client takes

549
00:21:08,400 --> 00:21:10,799
the Cyber text decrypts this using the

550
00:21:10,799 --> 00:21:13,140
shared secret key and then also decrypts

551
00:21:13,140 --> 00:21:15,840
using the export key to finally retrieve

552
00:21:15,840 --> 00:21:18,660
the original backup key k

553
00:21:18,660 --> 00:21:21,480
okay so thanks for bearing with me on

554
00:21:21,480 --> 00:21:23,520
that there's a lot of details but um one

555
00:21:23,520 --> 00:21:24,720
part that I wanted to highlight in this

556
00:21:24,720 --> 00:21:26,520
design is that

557
00:21:26,520 --> 00:21:27,840
um we're decrementing the attempt

558
00:21:27,840 --> 00:21:30,480
counter in step three

559
00:21:30,480 --> 00:21:32,100
um which is kind of like a weird place

560
00:21:32,100 --> 00:21:33,179
to do it because it's in the middle of

561
00:21:33,179 --> 00:21:35,220
the protocol it seems like the most

562
00:21:35,220 --> 00:21:37,080
logical thing would be to only decrement

563
00:21:37,080 --> 00:21:40,140
once the server realizes that the client

564
00:21:40,140 --> 00:21:42,179
entered an incorrect password right so

565
00:21:42,179 --> 00:21:44,520
maybe one like open question is why do

566
00:21:44,520 --> 00:21:47,280
we decrement in step three instead of uh

567
00:21:47,280 --> 00:21:50,039
step eight and the interesting thing I

568
00:21:50,039 --> 00:21:52,620
guess I'm answering the question but um

569
00:21:52,620 --> 00:21:54,059
the interesting thing about opaque is

570
00:21:54,059 --> 00:21:54,960
that

571
00:21:54,960 --> 00:21:56,720
um unlike the normal password

572
00:21:56,720 --> 00:22:00,360
Authentication Protocol where say the

573
00:22:00,360 --> 00:22:01,620
client just sends a password and the

574
00:22:01,620 --> 00:22:04,140
server computes the hash of it here in

575
00:22:04,140 --> 00:22:06,059
opaque it's actually the client that

576
00:22:06,059 --> 00:22:07,799
first learns whether or not the attempt

577
00:22:07,799 --> 00:22:10,919
was successful right so the server

578
00:22:10,919 --> 00:22:12,419
actually has to rely on the client to

579
00:22:12,419 --> 00:22:16,559
tell uh that the password attempt was

580
00:22:16,559 --> 00:22:18,240
unsuccessful before it can change its

581
00:22:18,240 --> 00:22:20,400
attempt counter so if we were to move

582
00:22:20,400 --> 00:22:22,860
that decrement attempt counter step to

583
00:22:22,860 --> 00:22:24,419
step eight this would actually be like

584
00:22:24,419 --> 00:22:26,760
completely insecure because the client

585
00:22:26,760 --> 00:22:28,500
could just check whether or not their

586
00:22:28,500 --> 00:22:31,200
password attempt was uh wrong and then

587
00:22:31,200 --> 00:22:32,580
like not tell the server and then try

588
00:22:32,580 --> 00:22:34,919
again and we would have no reliable way

589
00:22:34,919 --> 00:22:36,960
to actually track uh failed attempts so

590
00:22:36,960 --> 00:22:38,280
that's why we actually have to include

591
00:22:38,280 --> 00:22:40,860
that in step three before the client is

592
00:22:40,860 --> 00:22:43,080
able to uh or

593
00:22:43,080 --> 00:22:46,140
before the server has to wait for the

594
00:22:46,140 --> 00:22:48,059
client response so that's just kind of

595
00:22:48,059 --> 00:22:49,919
like one example of a lot of the

596
00:22:49,919 --> 00:22:51,840
subtleties that go into this design and

597
00:22:51,840 --> 00:22:53,460
so it's not just a matter of directly

598
00:22:53,460 --> 00:22:55,799
applying opaque I guess maybe as a

599
00:22:55,799 --> 00:22:58,080
future message for other companies or

600
00:22:58,080 --> 00:22:59,820
people who want to implement

601
00:22:59,820 --> 00:23:02,220
um encrypted backups that you have to be

602
00:23:02,220 --> 00:23:04,080
really careful with using opaque you

603
00:23:04,080 --> 00:23:06,059
can't just use opaque and expect that

604
00:23:06,059 --> 00:23:08,820
the attempt counters will just magically

605
00:23:08,820 --> 00:23:10,380
work

606
00:23:10,380 --> 00:23:13,220
um yeah

607
00:23:13,559 --> 00:23:15,539
so that was a high level overview of the

608
00:23:15,539 --> 00:23:18,720
protocol and in 2021 we also invited NCC

609
00:23:18,720 --> 00:23:20,340
group to audit the design of this

610
00:23:20,340 --> 00:23:22,320
protocol as well as the implementation

611
00:23:22,320 --> 00:23:24,780
of it for the entire encrypted backups

612
00:23:24,780 --> 00:23:26,820
code base within WhatsApp and they've

613
00:23:26,820 --> 00:23:28,260
reported a bunch of findings which we

614
00:23:28,260 --> 00:23:29,760
addressed and you can find more of them

615
00:23:29,760 --> 00:23:32,100
in this public report which is on their

616
00:23:32,100 --> 00:23:33,059
website

617
00:23:33,059 --> 00:23:34,620
we've also released a separate white

618
00:23:34,620 --> 00:23:36,960
paper uh which covers a lot of the

619
00:23:36,960 --> 00:23:39,000
details that I covered today

620
00:23:39,000 --> 00:23:40,559
um regarding the overall design maybe

621
00:23:40,559 --> 00:23:42,659
with a little bit less detail

622
00:23:42,659 --> 00:23:45,000
and finally I want to talk a little bit

623
00:23:45,000 --> 00:23:47,100
more about what we're doing with the or

624
00:23:47,100 --> 00:23:48,480
what we've been doing with the opaque

625
00:23:48,480 --> 00:23:51,539
protocol externally so when we were in

626
00:23:51,539 --> 00:23:52,980
the design phase of this project we

627
00:23:52,980 --> 00:23:54,299
realized that opaque was the right

628
00:23:54,299 --> 00:23:55,380
solution

629
00:23:55,380 --> 00:23:56,940
um to this problem but one major issue

630
00:23:56,940 --> 00:23:58,799
was that there weren't really any like

631
00:23:58,799 --> 00:24:00,659
off-the-shelf implementations that we

632
00:24:00,659 --> 00:24:02,700
could use uh which is to be expected

633
00:24:02,700 --> 00:24:05,280
because this paper came out in 2018.

634
00:24:05,280 --> 00:24:06,720
um so we decided to implement opaque

635
00:24:06,720 --> 00:24:08,460
ourselves and open source sample

636
00:24:08,460 --> 00:24:11,460
notation so that other people who maybe

637
00:24:11,460 --> 00:24:13,320
want to use opaque for different reasons

638
00:24:13,320 --> 00:24:16,320
or do encrypted backups for another

639
00:24:16,320 --> 00:24:19,080
application would be able to also do so

640
00:24:19,080 --> 00:24:20,520
and we put a lot of effort into making

641
00:24:20,520 --> 00:24:23,039
the API as simple as possible so right

642
00:24:23,039 --> 00:24:24,720
now you can go to creates.io if you're a

643
00:24:24,720 --> 00:24:27,059
bus fan and find the implementation that

644
00:24:27,059 --> 00:24:29,820
we're using as is to serve production

645
00:24:29,820 --> 00:24:31,860
traffic to Whatsapp users who've enabled

646
00:24:31,860 --> 00:24:34,140
encrypted backups

647
00:24:34,140 --> 00:24:36,120
and also um that code itself has been

648
00:24:36,120 --> 00:24:38,039
audited by NCC where we have a public

649
00:24:38,039 --> 00:24:42,260
report just for the opaque Library

650
00:24:43,340 --> 00:24:46,260
okay so

651
00:24:46,260 --> 00:24:47,640
um two potential future work directions

652
00:24:47,640 --> 00:24:50,159
that I guess I want to call out here one

653
00:24:50,159 --> 00:24:52,080
which is that we have this like really

654
00:24:52,080 --> 00:24:54,659
complicated infra setup which we try to

655
00:24:54,659 --> 00:24:56,700
model after this confidential and

656
00:24:56,700 --> 00:24:58,020
immutable

657
00:24:58,020 --> 00:25:00,419
um execution environment and one issue

658
00:25:00,419 --> 00:25:01,860
with the current design is that it

659
00:25:01,860 --> 00:25:03,780
inherently requires users to trust that

660
00:25:03,780 --> 00:25:05,580
we did what we said we did right like I

661
00:25:05,580 --> 00:25:07,020
can stand here and say that we threw

662
00:25:07,020 --> 00:25:08,880
away the keys but how do you or that we

663
00:25:08,880 --> 00:25:10,500
throw away the admin cards but how do

664
00:25:10,500 --> 00:25:12,059
you actually know that we did that and

665
00:25:12,059 --> 00:25:14,039
so the open question here is uh can we

666
00:25:14,039 --> 00:25:16,020
Implement some setup maybe with like

667
00:25:16,020 --> 00:25:19,080
remote access or with remote attestation

668
00:25:19,080 --> 00:25:20,580
that allows us to give some proofs to

669
00:25:20,580 --> 00:25:21,840
the clients

670
00:25:21,840 --> 00:25:23,400
um that they can actually verify our

671
00:25:23,400 --> 00:25:24,419
setup

672
00:25:24,419 --> 00:25:25,860
and the second which is kind of related

673
00:25:25,860 --> 00:25:27,240
to the first

674
00:25:27,240 --> 00:25:29,640
um is that the weakness here

675
00:25:29,640 --> 00:25:31,260
um is the hardware security aspect of

676
00:25:31,260 --> 00:25:32,460
things

677
00:25:32,460 --> 00:25:35,159
um so can we maybe further mitigate some

678
00:25:35,159 --> 00:25:37,380
of those weaknesses by considering like

679
00:25:37,380 --> 00:25:40,200
a threshold uh authentication scheme

680
00:25:40,200 --> 00:25:43,200
which splits Secrets across multiple

681
00:25:43,200 --> 00:25:45,120
machines so that if we're just talking

682
00:25:45,120 --> 00:25:46,440
about a compromise of a single machine

683
00:25:46,440 --> 00:25:48,120
there won't be enough to compromise the

684
00:25:48,120 --> 00:25:50,658
entire system

685
00:25:52,620 --> 00:25:56,460
okay so last slide just want to wrap up

686
00:25:56,460 --> 00:25:58,320
um I guess as a summary we've enabled

687
00:25:58,320 --> 00:25:59,640
end-to-end encrypted backups as a

688
00:25:59,640 --> 00:26:01,919
feature for WhatsApp users

689
00:26:01,919 --> 00:26:03,480
um this feature uses a combination of

690
00:26:03,480 --> 00:26:05,940
hsms plus the opaque protocol for a

691
00:26:05,940 --> 00:26:07,559
password-based Authentication

692
00:26:07,559 --> 00:26:10,440
and at the end of last year uh over 100

693
00:26:10,440 --> 00:26:12,360
million WhatsApp users have enabled

694
00:26:12,360 --> 00:26:14,460
Android backups which is like a number

695
00:26:14,460 --> 00:26:16,440
that surprised me for sure

696
00:26:16,440 --> 00:26:17,880
um and right now you can turn this on if

697
00:26:17,880 --> 00:26:19,559
you navigate to the chat backup page

698
00:26:19,559 --> 00:26:21,600
under encryption settings it's an

699
00:26:21,600 --> 00:26:23,700
available feature for everyone

700
00:26:23,700 --> 00:26:25,200
all right

701
00:26:25,200 --> 00:26:27,740
thank you

702
00:26:34,140 --> 00:26:36,720
uh thank you very much uh are there any

703
00:26:36,720 --> 00:26:39,299
questions yes please

704
00:26:39,299 --> 00:26:42,840
is the password that you put into opaque

705
00:26:42,840 --> 00:26:45,360
the same as the API login password and

706
00:26:45,360 --> 00:26:49,740
do you use opaque on the API logins

707
00:26:49,740 --> 00:26:51,779
um by API login password you mean so in

708
00:26:51,779 --> 00:26:53,940
WhatsApp you don't have a login you just

709
00:26:53,940 --> 00:26:55,620
authenticate using like so the password

710
00:26:55,620 --> 00:26:58,559
is only for backups yes yeah okay that

711
00:26:58,559 --> 00:27:01,580
was my question thank you

712
00:27:02,520 --> 00:27:04,080
thank you very much for the interesting

713
00:27:04,080 --> 00:27:05,159
talk

714
00:27:05,159 --> 00:27:06,659
um the the protocol seems to have two

715
00:27:06,659 --> 00:27:08,279
different aspects there's one that uses

716
00:27:08,279 --> 00:27:10,020
these Cutting Edge protocols and

717
00:27:10,020 --> 00:27:12,000
standards like opaque but there's a

718
00:27:12,000 --> 00:27:13,679
certain other part of the protocol that

719
00:27:13,679 --> 00:27:15,120
seems to be

720
00:27:15,120 --> 00:27:17,700
um original uh the the the recovery

721
00:27:17,700 --> 00:27:21,659
protocol the with the the multi-round

722
00:27:21,659 --> 00:27:24,059
trip thing and I was wondering what are

723
00:27:24,059 --> 00:27:25,320
the constraints that led to certain

724
00:27:25,320 --> 00:27:28,500
choices uh namely the usage of AES and

725
00:27:28,500 --> 00:27:30,960
specifically also the usage of pbkdf was

726
00:27:30,960 --> 00:27:33,539
it was it a hardware usually this stuff

727
00:27:33,539 --> 00:27:35,100
is due to a hardware or environment

728
00:27:35,100 --> 00:27:36,299
constraint so I was wondering if you

729
00:27:36,299 --> 00:27:38,100
could elaborate on that thank you yeah

730
00:27:38,100 --> 00:27:39,659
absolutely so

731
00:27:39,659 --> 00:27:42,360
um to clarify pbkdf is What's Done by

732
00:27:42,360 --> 00:27:44,640
the clients not the server so it's kind

733
00:27:44,640 --> 00:27:45,900
of reverse because an opaque the

734
00:27:45,900 --> 00:27:46,799
client's end up doing a lot of

735
00:27:46,799 --> 00:27:48,179
operations not the server so

736
00:27:48,179 --> 00:27:51,299
unfortunately we were only able to I

737
00:27:51,299 --> 00:27:53,279
guess due to

738
00:27:53,279 --> 00:27:55,200
client phone like mobile phone

739
00:27:55,200 --> 00:27:57,120
restrictions we only had access to pbkdf

740
00:27:57,120 --> 00:27:58,380
there

741
00:27:58,380 --> 00:28:00,120
um it would be nice to have used like a

742
00:28:00,120 --> 00:28:01,980
script or something like that but um we

743
00:28:01,980 --> 00:28:03,900
didn't have that option and then I guess

744
00:28:03,900 --> 00:28:06,480
oh you also asking my AES there

745
00:28:06,480 --> 00:28:08,520
um I guess yeah that was also just what

746
00:28:08,520 --> 00:28:09,779
was available on the client library

747
00:28:09,779 --> 00:28:11,460
because it the client is actually the

748
00:28:11,460 --> 00:28:14,039
one that has to run the AES protocol so

749
00:28:14,039 --> 00:28:15,480
um I don't know if that answers the

750
00:28:15,480 --> 00:28:17,900
question but

751
00:28:20,580 --> 00:28:22,620
um what kind of uh consensus

752
00:28:22,620 --> 00:28:25,559
requirements do you sorry what kind of

753
00:28:25,559 --> 00:28:27,240
consensus requirements do you apply to

754
00:28:27,240 --> 00:28:29,220
the rate limiting data like how many

755
00:28:29,220 --> 00:28:31,380
hsms could die and have the service

756
00:28:31,380 --> 00:28:33,900
still be operable

757
00:28:33,900 --> 00:28:37,740
yeah so we currently so I we have like

758
00:28:37,740 --> 00:28:39,480
say a quorum of I don't know the exact

759
00:28:39,480 --> 00:28:41,220
number but say like five hsms in an

760
00:28:41,220 --> 00:28:43,380
island and we want to be able tolerate

761
00:28:43,380 --> 00:28:44,340
like

762
00:28:44,340 --> 00:28:46,380
so that we need at least a majority so

763
00:28:46,380 --> 00:28:47,760
three out of five being able to still

764
00:28:47,760 --> 00:28:48,900
run

765
00:28:48,900 --> 00:28:52,080
um when we when more fail then we run

766
00:28:52,080 --> 00:28:54,419
into issues

767
00:28:54,419 --> 00:28:55,679
I guess it's a short way to say it

768
00:28:55,679 --> 00:28:58,340
interesting

769
00:28:58,440 --> 00:29:00,720
uh thank you very much your first talk

770
00:29:00,720 --> 00:29:03,980
as severeign

771
00:29:09,740 --> 00:29:12,059
do you have any counter measures against

772
00:29:12,059 --> 00:29:16,120
someone just deducing the

773
00:29:16,120 --> 00:29:16,500
[Music]

774
00:29:16,500 --> 00:29:17,460
um

775
00:29:17,460 --> 00:29:19,740
someone's backup so if they take her

776
00:29:19,740 --> 00:29:23,520
just tries wrong passwords for 10 times

777
00:29:23,520 --> 00:29:27,440
or more uh the back backup could become

778
00:29:27,440 --> 00:29:31,020
unavailable to anyone so anyone can just

779
00:29:31,020 --> 00:29:33,480
block using their backup either try it

780
00:29:33,480 --> 00:29:35,399
or you have some countermissions again

781
00:29:35,399 --> 00:29:37,919
against this yeah so I guess if you mean

782
00:29:37,919 --> 00:29:40,380
anyone as in like anyone in the world

783
00:29:40,380 --> 00:29:42,240
um you first have to prove that you are

784
00:29:42,240 --> 00:29:45,779
the user before you can try to make an

785
00:29:45,779 --> 00:29:48,659
attempt towards guessing their password

786
00:29:48,659 --> 00:29:50,159
um and there that just relies on the

787
00:29:50,159 --> 00:29:51,779
normal WhatsApp mechanisms for

788
00:29:51,779 --> 00:29:53,460
authenticating that you actually have

789
00:29:53,460 --> 00:29:55,380
access to this phone which is SMS if

790
00:29:55,380 --> 00:29:56,760
you're asking about like internal

791
00:29:56,760 --> 00:29:58,260
attacks like can we as WhatsApp

792
00:29:58,260 --> 00:30:03,120
Engineers try to like uh try like to uh

793
00:30:03,120 --> 00:30:05,340
I guess 10 10 times for each account we

794
00:30:05,340 --> 00:30:08,880
can and I guess the main like the

795
00:30:08,880 --> 00:30:10,320
purpose of having that attempt counter

796
00:30:10,320 --> 00:30:12,179
is so that mainly we can only have a ten

797
00:30:12,179 --> 00:30:14,039
attempts to do that or someone coerces

798
00:30:14,039 --> 00:30:16,140
us into trying to make these guesses

799
00:30:16,140 --> 00:30:17,760
they would only have 10 times to do so

800
00:30:17,760 --> 00:30:20,399
so in this case we actually chose uh I

801
00:30:20,399 --> 00:30:24,059
guess to Value the DDOS to be like lower

802
00:30:24,059 --> 00:30:26,640
than like we'd rather lose the

803
00:30:26,640 --> 00:30:28,200
information rather than have some sort

804
00:30:28,200 --> 00:30:29,760
of back door or some some way in which

805
00:30:29,760 --> 00:30:31,980
uh the key or the password could be

806
00:30:31,980 --> 00:30:35,880
exposed to us makes sense thank you

807
00:30:35,880 --> 00:30:38,000
um the question online

808
00:30:38,000 --> 00:30:41,940
how are you and did did you have to

809
00:30:41,940 --> 00:30:43,679
reassess the formal security proof of

810
00:30:43,679 --> 00:30:46,200
opaque after and modifying for the use

811
00:30:46,200 --> 00:30:48,440
case

812
00:30:48,539 --> 00:30:49,399
um sorry

813
00:30:49,399 --> 00:30:52,559
did you have to reassess the formal uh

814
00:30:52,559 --> 00:30:54,659
security proof of opaque after modifying

815
00:30:54,659 --> 00:30:55,500
it

816
00:30:55,500 --> 00:30:57,899
oh so actually yeah

817
00:30:57,899 --> 00:30:59,460
um this protocol as we described it

818
00:30:59,460 --> 00:31:01,020
actually does still use opaque in a

819
00:31:01,020 --> 00:31:02,640
black box manner we just added a bunch

820
00:31:02,640 --> 00:31:04,260
of bells and whistles on top of it so it

821
00:31:04,260 --> 00:31:05,399
didn't actually end up changing anything

822
00:31:05,399 --> 00:31:06,960
to do with the OPEC protocol or the

823
00:31:06,960 --> 00:31:09,679
security proof for it

824
00:31:10,440 --> 00:31:11,820
question

825
00:31:11,820 --> 00:31:13,200
um thank you it's a question I think

826
00:31:13,200 --> 00:31:14,700
it's that I got it wrong because I

827
00:31:14,700 --> 00:31:15,899
thought you have this counter I thought

828
00:31:15,899 --> 00:31:17,640
it was precisely for rate limiting but

829
00:31:17,640 --> 00:31:19,799
you said it wasn't sorry yeah not really

830
00:31:19,799 --> 00:31:21,840
limiting or I guess if you mean rate

831
00:31:21,840 --> 00:31:24,179
limiting as in like trying over a period

832
00:31:24,179 --> 00:31:26,159
of time it's not really limiting it's

833
00:31:26,159 --> 00:31:29,100
like a attempt counter so it doesn't go

834
00:31:29,100 --> 00:31:30,179
down

835
00:31:30,179 --> 00:31:32,520
um unless you enter a correct password

836
00:31:32,520 --> 00:31:34,919
yeah and I guess my question is like why

837
00:31:34,919 --> 00:31:36,480
you said you need to do that on the

838
00:31:36,480 --> 00:31:39,000
server side regardless of uh because the

839
00:31:39,000 --> 00:31:40,799
client needs to tell whether it

840
00:31:40,799 --> 00:31:43,080
succeeded or not uh with the decryption

841
00:31:43,080 --> 00:31:45,620
was that right yeah

842
00:31:45,620 --> 00:31:48,799
oh yeah so you you say that you couldn't

843
00:31:48,799 --> 00:31:52,020
uh put that at a later stage oh right

844
00:31:52,020 --> 00:31:53,580
yeah because of the client soon so

845
00:31:53,580 --> 00:31:55,559
couldn't you uh go around that by like

846
00:31:55,559 --> 00:31:57,000
deriving some

847
00:31:57,000 --> 00:31:59,340
signature key with that material well

848
00:31:59,340 --> 00:32:01,140
also I guess I'll take it offline yeah

849
00:32:01,140 --> 00:32:04,200
okay let's we need to move on to the

850
00:32:04,200 --> 00:32:06,779
next talk so let's take the questions

851
00:32:06,779 --> 00:32:10,940
offline thanks again thank you

852
00:32:14,760 --> 00:32:16,039
and

853
00:32:16,039 --> 00:32:18,780
the next talk

854
00:32:18,780 --> 00:32:22,000
[Music]

855
00:32:25,520 --> 00:32:28,080
will talk about why end-to-end

856
00:32:28,080 --> 00:32:29,760
encryption cloud storage is hard

857
00:32:29,760 --> 00:32:33,299
challenges attacks and best practices

858
00:32:33,299 --> 00:32:34,860
thank you

859
00:32:34,860 --> 00:32:37,020
okay yeah so welcome to this talk on why

860
00:32:37,020 --> 00:32:38,700
end-to-end encrypted cloud storage is

861
00:32:38,700 --> 00:32:40,320
hard and this is based on some

862
00:32:40,320 --> 00:32:42,240
observations that we made when studying

863
00:32:42,240 --> 00:32:43,740
the end-to-end crypto cloud storage

864
00:32:43,740 --> 00:32:46,860
service Mega a project which led to a

865
00:32:46,860 --> 00:32:48,600
paper titled Mega malleable encryption

866
00:32:48,600 --> 00:32:50,399
goes array and this is Joint work

867
00:32:50,399 --> 00:32:52,020
together with my colleagues here holler

868
00:32:52,020 --> 00:32:53,520
and Kenny Patterson and my name is

869
00:32:53,520 --> 00:32:55,620
matilla so let's talk about cloud

870
00:32:55,620 --> 00:32:58,080
storage I'm sure you're all aware of the

871
00:32:58,080 --> 00:32:59,760
advantages of this service which allows

872
00:32:59,760 --> 00:33:01,260
you to Outsource the storage of your

873
00:33:01,260 --> 00:33:03,539
files to the cloud such that they are

874
00:33:03,539 --> 00:33:05,580
available online can be accessed from

875
00:33:05,580 --> 00:33:07,620
multiple devices and provides you with a

876
00:33:07,620 --> 00:33:08,820
backup

877
00:33:08,820 --> 00:33:10,980
additionally files stored in the cloud

878
00:33:10,980 --> 00:33:12,539
can be easily shared with other people

879
00:33:12,539 --> 00:33:14,820
and many service providers even offer

880
00:33:14,820 --> 00:33:17,399
real-time collaborative editing

881
00:33:17,399 --> 00:33:19,140
so for these reasons and more cloud

882
00:33:19,140 --> 00:33:20,580
storage has become extremely popular

883
00:33:20,580 --> 00:33:23,519
however there is one major drawback and

884
00:33:23,519 --> 00:33:25,080
that is the lack of privacy

885
00:33:25,080 --> 00:33:27,120
so what do I mean by this well when you

886
00:33:27,120 --> 00:33:28,440
choose to put your files in the cloud

887
00:33:28,440 --> 00:33:30,419
they're no longer only on your device

888
00:33:30,419 --> 00:33:32,279
rather they're first being transported

889
00:33:32,279 --> 00:33:34,260
across a network and then stored at the

890
00:33:34,260 --> 00:33:35,100
server

891
00:33:35,100 --> 00:33:36,779
and neither of these two are entities

892
00:33:36,779 --> 00:33:38,880
that you necessarily Trust

893
00:33:38,880 --> 00:33:41,220
luckily we have secure channels such as

894
00:33:41,220 --> 00:33:43,140
TLS to protect the files while in

895
00:33:43,140 --> 00:33:45,120
transit so here we're not concerned with

896
00:33:45,120 --> 00:33:46,559
the network adversary

897
00:33:46,559 --> 00:33:48,659
additionally files are usually encrypted

898
00:33:48,659 --> 00:33:50,159
at rest in the cloud

899
00:33:50,159 --> 00:33:52,500
however and this is a crucial point the

900
00:33:52,500 --> 00:33:54,240
most common approach here is to encrypt

901
00:33:54,240 --> 00:33:55,980
the files with a key known to the

902
00:33:55,980 --> 00:33:57,419
service provider

903
00:33:57,419 --> 00:33:59,100
and this means that cloud storage

904
00:33:59,100 --> 00:34:01,200
implemented this way does not provide

905
00:34:01,200 --> 00:34:03,299
end-to-end encryption

906
00:34:03,299 --> 00:34:05,399
now the most straightforward alternative

907
00:34:05,399 --> 00:34:07,500
approach to this is to instead encrypt

908
00:34:07,500 --> 00:34:09,480
the files with a key known only to the

909
00:34:09,480 --> 00:34:11,280
user and when this is known as

910
00:34:11,280 --> 00:34:13,260
client-side encryption and when

911
00:34:13,260 --> 00:34:14,820
implemented correctly it provides

912
00:34:14,820 --> 00:34:16,619
end-to-end encryption

913
00:34:16,619 --> 00:34:18,418
so why do we care about end-to-end

914
00:34:18,418 --> 00:34:19,800
encryption in the cloud storage setting

915
00:34:19,800 --> 00:34:22,320
well as we heard in the last talk people

916
00:34:22,320 --> 00:34:23,760
want privacy

917
00:34:23,760 --> 00:34:26,460
and why well because without end-to-end

918
00:34:26,460 --> 00:34:28,619
encryption the service provider has

919
00:34:28,619 --> 00:34:31,020
direct access to user data and so for

920
00:34:31,020 --> 00:34:33,480
example they can read sensitive files or

921
00:34:33,480 --> 00:34:35,280
perform analytics in order to serve

922
00:34:35,280 --> 00:34:37,379
targeted advertisements

923
00:34:37,379 --> 00:34:39,119
and even if the service provider doesn't

924
00:34:39,119 --> 00:34:40,800
do either of these things there's always

925
00:34:40,800 --> 00:34:42,780
the risk that they would be compromised

926
00:34:42,780 --> 00:34:45,300
by some external adversary that wants to

927
00:34:45,300 --> 00:34:47,460
do these things or worse

928
00:34:47,460 --> 00:34:49,320
now in contrast with end-to-end

929
00:34:49,320 --> 00:34:51,000
encryption even a malicious or

930
00:34:51,000 --> 00:34:53,639
compromised cloud has no access to user

931
00:34:53,639 --> 00:34:55,560
data and cannot modify user files

932
00:34:55,560 --> 00:34:58,320
without it being detectable to the users

933
00:34:58,320 --> 00:35:00,960
so we think that well ideally entered

934
00:35:00,960 --> 00:35:02,520
encrypted cloud storage would provide

935
00:35:02,520 --> 00:35:04,380
kind of a Best of Both World scenario in

936
00:35:04,380 --> 00:35:05,880
the sense that you get the features of

937
00:35:05,880 --> 00:35:07,440
Outsource storage with the security

938
00:35:07,440 --> 00:35:10,020
guarantees of local search

939
00:35:10,020 --> 00:35:12,720
now in order to achieve this

940
00:35:12,720 --> 00:35:14,400
um the system obviously has to provide

941
00:35:14,400 --> 00:35:16,740
data confidentiality and integrity and

942
00:35:16,740 --> 00:35:18,480
this in a threat model where the cloud

943
00:35:18,480 --> 00:35:20,700
is potentially actively malicious or

944
00:35:20,700 --> 00:35:22,680
compromised

945
00:35:22,680 --> 00:35:25,880
and in this threat model there are some

946
00:35:25,880 --> 00:35:28,140
trivial attacks which a malicious Cloud

947
00:35:28,140 --> 00:35:29,880
can perform and which we consider out of

948
00:35:29,880 --> 00:35:30,720
scope

949
00:35:30,720 --> 00:35:32,700
so the first one is availability a

950
00:35:32,700 --> 00:35:34,859
malicious Cloud can always refuse a user

951
00:35:34,859 --> 00:35:36,480
access to their files

952
00:35:36,480 --> 00:35:38,640
the second one is user anonymity so this

953
00:35:38,640 --> 00:35:40,320
means we don't try to hide the mapping

954
00:35:40,320 --> 00:35:42,000
between a user's identity and their

955
00:35:42,000 --> 00:35:45,180
account nor their access patterns

956
00:35:45,180 --> 00:35:47,099
third a malicious Cloud can always try

957
00:35:47,099 --> 00:35:48,780
to perform a targeted dictionary attack

958
00:35:48,780 --> 00:35:51,180
on user passwords so as we saw in the

959
00:35:51,180 --> 00:35:53,280
previous talk passwords are often used

960
00:35:53,280 --> 00:35:54,740
as the route of security

961
00:35:54,740 --> 00:35:58,020
encrypted Cloud storages and the only

962
00:35:58,020 --> 00:35:59,400
good way we really have a protecting

963
00:35:59,400 --> 00:36:01,440
against this is to enforce a strict

964
00:36:01,440 --> 00:36:03,060
password policy

965
00:36:03,060 --> 00:36:05,700
furthermore there are also other ways in

966
00:36:05,700 --> 00:36:07,560
which a malicious Cloud can try to

967
00:36:07,560 --> 00:36:10,200
extract user secrets so for example if

968
00:36:10,200 --> 00:36:12,119
you access your cloud storage over the

969
00:36:12,119 --> 00:36:14,520
browser the server can serve you some

970
00:36:14,520 --> 00:36:16,320
malicious JavaScript code in order to

971
00:36:16,320 --> 00:36:18,119
try to get a hold of your password

972
00:36:18,119 --> 00:36:19,920
and trying to Integrity protect the

973
00:36:19,920 --> 00:36:21,240
JavaScript code is a very interesting

974
00:36:21,240 --> 00:36:22,859
problem but it's not something that we

975
00:36:22,859 --> 00:36:25,200
consider here

976
00:36:25,200 --> 00:36:26,760
so let's have a look at the state of

977
00:36:26,760 --> 00:36:28,680
consumer cloud storage today this table

978
00:36:28,680 --> 00:36:30,540
shows the four biggest providers we have

979
00:36:30,540 --> 00:36:32,160
Google Drive in the top with over 1

980
00:36:32,160 --> 00:36:34,500
billion active users OneDrive iCloud

981
00:36:34,500 --> 00:36:36,240
Dropbox and so on

982
00:36:36,240 --> 00:36:39,240
now surprisingly or perhaps not neither

983
00:36:39,240 --> 00:36:41,940
of these provide end-to-end encryption

984
00:36:41,940 --> 00:36:44,579
so we might ask ourselves why don't the

985
00:36:44,579 --> 00:36:46,440
big providers aim for end-to-end

986
00:36:46,440 --> 00:36:48,060
encryption

987
00:36:48,060 --> 00:36:49,740
well it turns out that implementing

988
00:36:49,740 --> 00:36:51,240
client-side encryption is not as

989
00:36:51,240 --> 00:36:53,220
straightforward as it may seem and

990
00:36:53,220 --> 00:36:54,540
rather it comes with some inherent

991
00:36:54,540 --> 00:36:56,099
challenges and I'll try to illustrate a

992
00:36:56,099 --> 00:36:58,140
few of those for you here

993
00:36:58,140 --> 00:37:00,119
so the first one is Key Management

994
00:37:00,119 --> 00:37:01,980
remember that we like to have the data

995
00:37:01,980 --> 00:37:04,140
be available from multiple devices

996
00:37:04,140 --> 00:37:06,359
but now if the files are encrypted with

997
00:37:06,359 --> 00:37:07,740
a key that's not known to the storage

998
00:37:07,740 --> 00:37:09,900
provider this means that this key needs

999
00:37:09,900 --> 00:37:12,240
to be available on all the devices where

1000
00:37:12,240 --> 00:37:14,940
a user wants to decrypt their files

1001
00:37:14,940 --> 00:37:16,980
but without assuming an out-of-band

1002
00:37:16,980 --> 00:37:19,079
Channel between the devices the only way

1003
00:37:19,079 --> 00:37:20,940
we have of transferring a key from one

1004
00:37:20,940 --> 00:37:23,160
device to the other is via the untrusted

1005
00:37:23,160 --> 00:37:24,359
provider

1006
00:37:24,359 --> 00:37:26,339
so obviously this can't happen in the

1007
00:37:26,339 --> 00:37:28,320
clear so we need to encrypt the key in

1008
00:37:28,320 --> 00:37:29,220
some way

1009
00:37:29,220 --> 00:37:31,140
but for this we need a key encryption

1010
00:37:31,140 --> 00:37:33,420
key and now this key encryption key also

1011
00:37:33,420 --> 00:37:34,920
needs to be available on all the devices

1012
00:37:34,920 --> 00:37:36,780
so we're sort of back at the start again

1013
00:37:36,780 --> 00:37:38,579
with the same problem and it's Turtles

1014
00:37:38,579 --> 00:37:40,680
all the way down

1015
00:37:40,680 --> 00:37:42,900
luckily if these devices belong to one

1016
00:37:42,900 --> 00:37:44,579
on the same user we actually have an

1017
00:37:44,579 --> 00:37:46,680
Autobahn Channel between them namely the

1018
00:37:46,680 --> 00:37:49,020
user themselves so if the user can just

1019
00:37:49,020 --> 00:37:50,460
remember the key and bring it with them

1020
00:37:50,460 --> 00:37:52,140
we have a solution to the key management

1021
00:37:52,140 --> 00:37:53,520
problem

1022
00:37:53,520 --> 00:37:55,800
unfortunately users are not very good

1023
00:37:55,800 --> 00:37:57,540
key managers

1024
00:37:57,540 --> 00:37:59,280
so it's inherently difficult for a human

1025
00:37:59,280 --> 00:38:01,619
to remember a cryptographic key

1026
00:38:01,619 --> 00:38:04,380
so instead the most common approach is

1027
00:38:04,380 --> 00:38:06,000
to use a password as the root of

1028
00:38:06,000 --> 00:38:07,980
security and what this means is that a

1029
00:38:07,980 --> 00:38:10,079
user chosen passphrase is fed into some

1030
00:38:10,079 --> 00:38:11,940
key derivation function in order to

1031
00:38:11,940 --> 00:38:13,500
derive all of the cryptographic keys

1032
00:38:13,500 --> 00:38:15,200
needed for the system

1033
00:38:15,200 --> 00:38:16,980
unfortunately

1034
00:38:16,980 --> 00:38:18,660
users are not very good password

1035
00:38:18,660 --> 00:38:20,400
managers either

1036
00:38:20,400 --> 00:38:22,560
so and password management is really

1037
00:38:22,560 --> 00:38:24,060
critical in the end encrypted setting

1038
00:38:24,060 --> 00:38:26,540
because if a user forgets their password

1039
00:38:26,540 --> 00:38:29,339
they lose access to all of their data

1040
00:38:29,339 --> 00:38:30,900
additionally passwords have a long

1041
00:38:30,900 --> 00:38:33,240
history of challenges with low entropy

1042
00:38:33,240 --> 00:38:35,160
and leaks and if a password is leaked or

1043
00:38:35,160 --> 00:38:36,960
compromised in the setting well it

1044
00:38:36,960 --> 00:38:38,579
immediately leads to key recovery attack

1045
00:38:38,579 --> 00:38:39,960
which undermines all of the security

1046
00:38:39,960 --> 00:38:42,300
guarantees of the system

1047
00:38:42,300 --> 00:38:44,339
so in summary we don't really have a

1048
00:38:44,339 --> 00:38:45,359
good solution to the key management

1049
00:38:45,359 --> 00:38:46,859
problem

1050
00:38:46,859 --> 00:38:48,900
and even if we imagine that we did have

1051
00:38:48,900 --> 00:38:51,300
a solution in the single user case for

1052
00:38:51,300 --> 00:38:52,500
example some smart way of using

1053
00:38:52,500 --> 00:38:54,660
passwords there's still the challenge of

1054
00:38:54,660 --> 00:38:57,119
sharing encrypted files between users

1055
00:38:57,119 --> 00:38:59,220
because if one file if one user has

1056
00:38:59,220 --> 00:39:00,599
encrypted a file and wants to share it

1057
00:39:00,599 --> 00:39:02,460
with another user they also need to

1058
00:39:02,460 --> 00:39:03,900
share the key

1059
00:39:03,900 --> 00:39:05,940
now again the challenge is to establish

1060
00:39:05,940 --> 00:39:07,619
a trusted Channel between the users

1061
00:39:07,619 --> 00:39:09,960
where in this setting the only point of

1062
00:39:09,960 --> 00:39:11,640
contact that we can really reasonably

1063
00:39:11,640 --> 00:39:14,880
assume is the untrusted provider

1064
00:39:14,880 --> 00:39:17,579
so these challenges and more is what we

1065
00:39:17,579 --> 00:39:19,260
think makes implementing end-to-end

1066
00:39:19,260 --> 00:39:21,119
encrypted cloud storage difficult and

1067
00:39:21,119 --> 00:39:23,300
interesting

1068
00:39:23,300 --> 00:39:26,160
so now that we established that into an

1069
00:39:26,160 --> 00:39:27,780
encrypted cloud storage is desirable but

1070
00:39:27,780 --> 00:39:30,060
not trivial to implement we're going to

1071
00:39:30,060 --> 00:39:32,700
look at how Mega specific cloud provider

1072
00:39:32,700 --> 00:39:34,440
tries to implement these challenges in

1073
00:39:34,440 --> 00:39:35,520
their design

1074
00:39:35,520 --> 00:39:37,460
so whose Mega they're the fifth biggest

1075
00:39:37,460 --> 00:39:39,900
cloud storage provider they have over

1076
00:39:39,900 --> 00:39:42,839
207 million users and so over 130

1077
00:39:42,839 --> 00:39:45,000
billion files well it makes them more

1078
00:39:45,000 --> 00:39:46,380
interesting compared to their bigger

1079
00:39:46,380 --> 00:39:48,060
competitors is that they advertise

1080
00:39:48,060 --> 00:39:50,640
security and privacy and they emphasize

1081
00:39:50,640 --> 00:39:52,380
this on their website through statements

1082
00:39:52,380 --> 00:39:54,359
like Mega does not have access to your

1083
00:39:54,359 --> 00:39:56,460
password or your data

1084
00:39:56,460 --> 00:39:58,200
so in the following we're going to have

1085
00:39:58,200 --> 00:39:59,760
a look at the simplified version of

1086
00:39:59,760 --> 00:40:01,800
Mega's design and see how they try to

1087
00:40:01,800 --> 00:40:03,359
address the challenges of end-to-end

1088
00:40:03,359 --> 00:40:05,640
encrypted cloud storage

1089
00:40:05,640 --> 00:40:07,500
so we're going to start with registering

1090
00:40:07,500 --> 00:40:10,020
a new user to register a new user the

1091
00:40:10,020 --> 00:40:12,960
user generates an RSA key pair that's

1092
00:40:12,960 --> 00:40:15,240
used for authentication it then uploads

1093
00:40:15,240 --> 00:40:17,700
RSA public key to the server in plain

1094
00:40:17,700 --> 00:40:21,119
text it also picks a password an

1095
00:40:21,119 --> 00:40:24,119
encrypts or say secret key with

1096
00:40:24,119 --> 00:40:25,859
um with that password and uploads this

1097
00:40:25,859 --> 00:40:27,359
to the server the reason for doing this

1098
00:40:27,359 --> 00:40:28,740
is that we want to be able to access

1099
00:40:28,740 --> 00:40:30,240
this key material also from other

1100
00:40:30,240 --> 00:40:32,040
devices

1101
00:40:32,040 --> 00:40:34,440
a registered user can then upload a file

1102
00:40:34,440 --> 00:40:36,240
in the following way it first

1103
00:40:36,240 --> 00:40:39,240
authenticates to the server and then for

1104
00:40:39,240 --> 00:40:41,339
a new file pick the key specifically for

1105
00:40:41,339 --> 00:40:43,560
that file encrypts the file with the

1106
00:40:43,560 --> 00:40:45,300
file key and uploads the encrypted file

1107
00:40:45,300 --> 00:40:46,500
to the server

1108
00:40:46,500 --> 00:40:48,660
but the user also uses their password to

1109
00:40:48,660 --> 00:40:51,240
encrypt the file key and then uploads

1110
00:40:51,240 --> 00:40:53,040
this encrypted file key to the server

1111
00:40:53,040 --> 00:40:54,960
again the reason for doing this is that

1112
00:40:54,960 --> 00:40:57,119
we want to be able to access this key

1113
00:40:57,119 --> 00:40:59,400
material also from another device

1114
00:40:59,400 --> 00:41:02,400
and that works as follows the sir the

1115
00:41:02,400 --> 00:41:04,380
user on this other device authenticates

1116
00:41:04,380 --> 00:41:06,780
again to the server and then fetches the

1117
00:41:06,780 --> 00:41:09,060
encrypted file but it also fetches the

1118
00:41:09,060 --> 00:41:10,920
encrypted file key and then uses their

1119
00:41:10,920 --> 00:41:13,020
knowledge of the password to decrypt the

1120
00:41:13,020 --> 00:41:15,300
file key and use that key to decrypt the

1121
00:41:15,300 --> 00:41:16,920
file

1122
00:41:16,920 --> 00:41:19,260
so although the scheme that we described

1123
00:41:19,260 --> 00:41:21,359
so far is pretty similar to the generic

1124
00:41:21,359 --> 00:41:22,920
construction described by Matilda in the

1125
00:41:22,920 --> 00:41:25,320
beginning it already has subtle flaws on

1126
00:41:25,320 --> 00:41:27,359
the implementation level so next we're

1127
00:41:27,359 --> 00:41:29,700
going to discuss cryptonalytic results

1128
00:41:29,700 --> 00:41:31,260
from our paper model encryption

1129
00:41:31,260 --> 00:41:33,599
conservari that will be published in s p

1130
00:41:33,599 --> 00:41:35,940
this year

1131
00:41:35,940 --> 00:41:37,440
and in particular we're going to start

1132
00:41:37,440 --> 00:41:39,000
with an attack where the malicious cloud

1133
00:41:39,000 --> 00:41:41,520
provider tries to recover a user's RSA

1134
00:41:41,520 --> 00:41:43,140
secret key with an attack that's more

1135
00:41:43,140 --> 00:41:44,700
sophisticated than just guessing the

1136
00:41:44,700 --> 00:41:45,720
password

1137
00:41:45,720 --> 00:41:47,460
this attack is going to exploit its

1138
00:41:47,460 --> 00:41:49,380
Authentication Protocol so let's look at

1139
00:41:49,380 --> 00:41:51,720
that in a bit more detail

1140
00:41:51,720 --> 00:41:53,460
first the user sends an authentication

1141
00:41:53,460 --> 00:41:55,800
request and fetches the encrypted RSA

1142
00:41:55,800 --> 00:41:57,660
secret key from the server

1143
00:41:57,660 --> 00:41:59,760
the server picks a session ID and

1144
00:41:59,760 --> 00:42:01,800
encrypts the session ID to the RSA

1145
00:42:01,800 --> 00:42:03,359
public key of the user that tries to

1146
00:42:03,359 --> 00:42:05,640
authenticate

1147
00:42:05,640 --> 00:42:07,200
the user then uses their knowledge of

1148
00:42:07,200 --> 00:42:09,180
the password to decrypt the RSA secret

1149
00:42:09,180 --> 00:42:11,099
key and uses our key to recover the

1150
00:42:11,099 --> 00:42:12,119
session ID

1151
00:42:12,119 --> 00:42:14,220
and to conclude authentication the user

1152
00:42:14,220 --> 00:42:16,079
will send back the session ID to the

1153
00:42:16,079 --> 00:42:18,119
server to prove that they successfully

1154
00:42:18,119 --> 00:42:21,240
recovered access to the RSA key material

1155
00:42:21,240 --> 00:42:23,220
however as the cryptographers in this

1156
00:42:23,220 --> 00:42:24,599
room will probably have already spotted

1157
00:42:24,599 --> 00:42:26,280
the big red flag that they're using as

1158
00:42:26,280 --> 00:42:29,400
ECB to encrypt the RSA secret key

1159
00:42:29,400 --> 00:42:32,099
so some of you may now think of a Linux

1160
00:42:32,099 --> 00:42:34,380
penguin which is the standard example of

1161
00:42:34,380 --> 00:42:37,320
why not to use asecb if you encrypt the

1162
00:42:37,320 --> 00:42:39,420
penguin with vcp you still have a

1163
00:42:39,420 --> 00:42:41,820
penguin just with a funky color scheme

1164
00:42:41,820 --> 00:42:43,859
however it's actually not trivial to

1165
00:42:43,859 --> 00:42:45,839
build a key recovery attack just from

1166
00:42:45,839 --> 00:42:48,420
the fact that they're using asecb

1167
00:42:48,420 --> 00:42:50,339
and the reason for this is that narsa

1168
00:42:50,339 --> 00:42:51,780
secret key is substantially different

1169
00:42:51,780 --> 00:42:54,720
from a penguin if you

1170
00:42:54,720 --> 00:42:58,740
want to if you want to encrypt an RSA

1171
00:42:58,740 --> 00:43:01,380
secret key with as ECB then you split it

1172
00:43:01,380 --> 00:43:03,359
into different blocks and you encrypt

1173
00:43:03,359 --> 00:43:05,900
those blocks separately with AES

1174
00:43:05,900 --> 00:43:09,780
but however the RSA secret key has high

1175
00:43:09,780 --> 00:43:12,180
entropy unlike the penguin that repeats

1176
00:43:12,180 --> 00:43:14,339
the same blocks of pixels over and over

1177
00:43:14,339 --> 00:43:15,839
again

1178
00:43:15,839 --> 00:43:18,060
so really

1179
00:43:18,060 --> 00:43:18,780
um

1180
00:43:18,780 --> 00:43:21,960
for the RSI secret key is with very high

1181
00:43:21,960 --> 00:43:24,200
probability those blocks are

1182
00:43:24,200 --> 00:43:27,060
different from each other so just

1183
00:43:27,060 --> 00:43:29,460
encrypting them AES is still a proceed

1184
00:43:29,460 --> 00:43:30,900
around the permutation so if you just

1185
00:43:30,900 --> 00:43:32,940
encrypt them and you get some ciphertext

1186
00:43:32,940 --> 00:43:34,440
blocks you cannot go back to the plain

1187
00:43:34,440 --> 00:43:36,720
text blocks without breaking as itself

1188
00:43:36,720 --> 00:43:38,819
so really we are not exploiting that

1189
00:43:38,819 --> 00:43:41,280
asecb is deterministic in this case

1190
00:43:41,280 --> 00:43:43,560
however what we can exploit is that

1191
00:43:43,560 --> 00:43:45,180
those blocks are encrypted independent

1192
00:43:45,180 --> 00:43:46,319
of each other

1193
00:43:46,319 --> 00:43:48,540
so a malicious cloud provider can garble

1194
00:43:48,540 --> 00:43:50,460
one of the ciphertext blocks and this

1195
00:43:50,460 --> 00:43:52,260
will propagate and garble only one of

1196
00:43:52,260 --> 00:43:54,839
the plaintext blocks so the idea for our

1197
00:43:54,839 --> 00:43:57,900
attack is that we garbled part of the

1198
00:43:57,900 --> 00:44:00,540
plane of the RSA secret key then observe

1199
00:44:00,540 --> 00:44:02,099
how the client uses this partially

1200
00:44:02,099 --> 00:44:03,780
garbled key and learn something about

1201
00:44:03,780 --> 00:44:05,460
the parts of the secret key that we did

1202
00:44:05,460 --> 00:44:07,680
not garble so we are exploiting that the

1203
00:44:07,680 --> 00:44:09,780
cipher here is malleable

1204
00:44:09,780 --> 00:44:11,940
but how can we make observations on how

1205
00:44:11,940 --> 00:44:13,859
the client uses a secret key

1206
00:44:13,859 --> 00:44:15,180
well if you go back to the

1207
00:44:15,180 --> 00:44:17,339
Authentication Protocol you realize that

1208
00:44:17,339 --> 00:44:19,079
we have a partial decryption Oracle

1209
00:44:19,079 --> 00:44:21,720
because the server picks the ciphertext

1210
00:44:21,720 --> 00:44:24,180
and then if the client

1211
00:44:24,180 --> 00:44:26,160
decrypt successfully it will send back

1212
00:44:26,160 --> 00:44:27,960
part of the plain text in form of the

1213
00:44:27,960 --> 00:44:29,940
session ID to the server

1214
00:44:29,940 --> 00:44:31,619
so putting this together to an attack

1215
00:44:31,619 --> 00:44:34,560
the server can exploit that RSA is equal

1216
00:44:34,560 --> 00:44:36,180
to key type vertex is smallable and

1217
00:44:36,180 --> 00:44:39,240
change full AES ECB blocks as I protects

1218
00:44:39,240 --> 00:44:41,099
blocks and then observe how the client

1219
00:44:41,099 --> 00:44:43,740
uses this partially garbled key through

1220
00:44:43,740 --> 00:44:46,079
the partial decryption Oracle

1221
00:44:46,079 --> 00:44:47,819
and it turns out that if the server

1222
00:44:47,819 --> 00:44:49,500
picks the right values for a session ID

1223
00:44:49,500 --> 00:44:52,079
this allows the malicious cloud provider

1224
00:44:52,079 --> 00:44:54,359
to perform a binary search for the RSA

1225
00:44:54,359 --> 00:44:56,819
secret key of a user so the impact of

1226
00:44:56,819 --> 00:44:58,200
this attack is that a malicious

1227
00:44:58,200 --> 00:44:59,940
supervisor can recover a user's RSA

1228
00:44:59,940 --> 00:45:02,760
secret key in 512 login attempts This

1229
00:45:02,760 --> 00:45:04,980
was later improved substantially to six

1230
00:45:04,980 --> 00:45:07,740
logins and two logins

1231
00:45:07,740 --> 00:45:10,500
um but if we take a step back and look

1232
00:45:10,500 --> 00:45:13,079
at Mega's design then we realize that

1233
00:45:13,079 --> 00:45:15,420
every file is encrypted with its own key

1234
00:45:15,420 --> 00:45:17,460
and those keys are not encrypted with

1235
00:45:17,460 --> 00:45:19,800
the RSA key material so just knowing the

1236
00:45:19,800 --> 00:45:21,540
RSA secret key does not allow an

1237
00:45:21,540 --> 00:45:23,880
adversary to read the user's files

1238
00:45:23,880 --> 00:45:26,400
however we were able to build a second

1239
00:45:26,400 --> 00:45:29,460
attack that allows file decryption

1240
00:45:29,460 --> 00:45:31,200
so for the second attack we're going to

1241
00:45:31,200 --> 00:45:32,880
assume that adversary already knows the

1242
00:45:32,880 --> 00:45:34,619
RSA secret key from running our first

1243
00:45:34,619 --> 00:45:36,859
attack

1244
00:45:37,319 --> 00:45:39,420
and the main observation for this attack

1245
00:45:39,420 --> 00:45:42,240
is that in their design Mega also uses

1246
00:45:42,240 --> 00:45:44,640
AES ECP to encrypt the file keys and

1247
00:45:44,640 --> 00:45:46,440
they're even using the same key for this

1248
00:45:46,440 --> 00:45:47,760
encryption

1249
00:45:47,760 --> 00:45:50,280
so essentially what we can do for our

1250
00:45:50,280 --> 00:45:52,260
attack is we can pretend that the file

1251
00:45:52,260 --> 00:45:54,540
key ciphertext is part of the RSA secret

1252
00:45:54,540 --> 00:45:56,880
key ciphertext and then cut and paste

1253
00:45:56,880 --> 00:45:59,160
full as ECB ciphertext blocks from the

1254
00:45:59,160 --> 00:46:00,960
file key encryption into the RSA secret

1255
00:46:00,960 --> 00:46:03,119
key encryption and at that point we can

1256
00:46:03,119 --> 00:46:04,440
use the vulnerable Authentication

1257
00:46:04,440 --> 00:46:06,300
Protocol that we already exploited in

1258
00:46:06,300 --> 00:46:08,460
our first attack to learn the decryption

1259
00:46:08,460 --> 00:46:10,500
of file keys

1260
00:46:10,500 --> 00:46:12,480
so the impact of this attack is that we

1261
00:46:12,480 --> 00:46:14,700
have a cheap asecb decryption Oracle

1262
00:46:14,700 --> 00:46:16,619
that allows the adversity that already

1263
00:46:16,619 --> 00:46:20,940
knows or say secret key to also recover

1264
00:46:20,940 --> 00:46:23,400
file keys and therefore decrypt all user

1265
00:46:23,400 --> 00:46:24,839
data

1266
00:46:24,839 --> 00:46:27,420
summarizing our attacks on Mega and

1267
00:46:27,420 --> 00:46:29,579
mistakes that should be avoided when

1268
00:46:29,579 --> 00:46:30,839
designing end-to-end encrypted cloud

1269
00:46:30,839 --> 00:46:32,040
storage

1270
00:46:32,040 --> 00:46:34,440
our first attack recovered the

1271
00:46:34,440 --> 00:46:36,060
malleability of key material that's

1272
00:46:36,060 --> 00:46:38,220
outsourced to a server to recover the

1273
00:46:38,220 --> 00:46:40,680
RSA secret key of a user and the problem

1274
00:46:40,680 --> 00:46:43,380
here is that this key ciphertext has no

1275
00:46:43,380 --> 00:46:45,359
Integrity protection because Mega did

1276
00:46:45,359 --> 00:46:47,099
not use authenticated encryption for

1277
00:46:47,099 --> 00:46:48,599
this

1278
00:46:48,599 --> 00:46:51,000
then we built a second attack on top of

1279
00:46:51,000 --> 00:46:52,500
our first attack

1280
00:46:52,500 --> 00:46:54,720
that allows the decryption of arbitrary

1281
00:46:54,720 --> 00:46:57,720
as ECB ciphertexts and the problem here

1282
00:46:57,720 --> 00:47:00,599
is that we can break the file encryption

1283
00:47:00,599 --> 00:47:02,040
with a Moon built in a completely

1284
00:47:02,040 --> 00:47:03,540
separate part of their design the

1285
00:47:03,540 --> 00:47:05,640
Authentication Protocol because they

1286
00:47:05,640 --> 00:47:07,859
reused the same key for both of those

1287
00:47:07,859 --> 00:47:10,020
parts

1288
00:47:10,020 --> 00:47:12,240
furthermore in our paper we have two

1289
00:47:12,240 --> 00:47:14,220
additional attacks that allow a

1290
00:47:14,220 --> 00:47:15,540
malicious cloud provider to craft

1291
00:47:15,540 --> 00:47:17,819
ciphertexts that decrypt to arbitrary

1292
00:47:17,819 --> 00:47:19,260
files

1293
00:47:19,260 --> 00:47:21,780
even without the malicious provider

1294
00:47:21,780 --> 00:47:23,880
knowing a user's password and the

1295
00:47:23,880 --> 00:47:25,560
problem here is that Mega designs their

1296
00:47:25,560 --> 00:47:27,839
own file encryption scheme that has some

1297
00:47:27,839 --> 00:47:29,460
non-standard structure that allows for

1298
00:47:29,460 --> 00:47:30,839
these attacks

1299
00:47:30,839 --> 00:47:32,940
finally we also have an attack that's

1300
00:47:32,940 --> 00:47:35,940
similar to our blacker's RSA padding

1301
00:47:35,940 --> 00:47:36,900
Oracle

1302
00:47:36,900 --> 00:47:38,760
uh but adapted to make a skeleton

1303
00:47:38,760 --> 00:47:40,440
padding scheme

1304
00:47:40,440 --> 00:47:42,480
and while this is another instance of

1305
00:47:42,480 --> 00:47:44,339
homegrown crypto it's also a legacy

1306
00:47:44,339 --> 00:47:46,440
issue because Mega was aware that this

1307
00:47:46,440 --> 00:47:48,420
part of their code is vulnerable however

1308
00:47:48,420 --> 00:47:50,220
they were not able to move away from it

1309
00:47:50,220 --> 00:47:51,359
for backwards compatibility

1310
00:47:51,359 --> 00:47:54,240
compatibility reasons

1311
00:47:54,240 --> 00:47:55,980
but with that we picked enough on Mega

1312
00:47:55,980 --> 00:47:57,480
and there's definitely things that they

1313
00:47:57,480 --> 00:47:58,859
did do right

1314
00:47:58,859 --> 00:48:00,900
for a start they aimed for end-to-end

1315
00:48:00,900 --> 00:48:02,880
encryption which is more that we can say

1316
00:48:02,880 --> 00:48:04,859
of other Cloud providers

1317
00:48:04,859 --> 00:48:06,660
furthermore they have a bug Bounty

1318
00:48:06,660 --> 00:48:07,680
programmer and they were very

1319
00:48:07,680 --> 00:48:10,200
collaborative during disclosure in fact

1320
00:48:10,200 --> 00:48:11,819
we enjoyed this collaboration so much

1321
00:48:11,819 --> 00:48:14,460
that we also decided to continue it and

1322
00:48:14,460 --> 00:48:18,619
break their patches on our first attacks

1323
00:48:19,020 --> 00:48:21,480
but Jokes Aside while working on their

1324
00:48:21,480 --> 00:48:24,000
system we realized that fundamental

1325
00:48:24,000 --> 00:48:26,040
changes to their design are infeasible

1326
00:48:26,040 --> 00:48:27,720
in practice for instance if you want to

1327
00:48:27,720 --> 00:48:29,940
replace the file encryption you need to

1328
00:48:29,940 --> 00:48:31,920
re-encrypt all files which would take

1329
00:48:31,920 --> 00:48:34,500
more than half a year in their system

1330
00:48:34,500 --> 00:48:36,480
furthermore it's also unclear how you

1331
00:48:36,480 --> 00:48:38,579
can recover from a compromise because

1332
00:48:38,579 --> 00:48:40,500
there's no way to rotate keys in their

1333
00:48:40,500 --> 00:48:42,660
system so really their design also

1334
00:48:42,660 --> 00:48:46,578
doesn't offer post compromise security

1335
00:48:48,599 --> 00:48:51,180
so now that we've seen some of the

1336
00:48:51,180 --> 00:48:52,859
issues that Mega faced the natural next

1337
00:48:52,859 --> 00:48:54,780
question to ask is how should we design

1338
00:48:54,780 --> 00:48:57,000
end-to-end encrypted cloud storage so

1339
00:48:57,000 --> 00:48:58,619
summarizing some of our observations

1340
00:48:58,619 --> 00:49:00,660
ideally we think that a good

1341
00:49:00,660 --> 00:49:02,400
well-designed system should provide

1342
00:49:02,400 --> 00:49:04,260
cryptographic agility such that it can

1343
00:49:04,260 --> 00:49:05,960
recover from vulnerabilities

1344
00:49:05,960 --> 00:49:08,460
modularity such that it can be securely

1345
00:49:08,460 --> 00:49:10,680
extended and to use analysis

1346
00:49:10,680 --> 00:49:12,180
of course it also has to provide the

1347
00:49:12,180 --> 00:49:13,619
basic features that make cloud storage

1348
00:49:13,619 --> 00:49:15,960
so attractive so Multi-Device access and

1349
00:49:15,960 --> 00:49:18,480
file sharing for example but we might

1350
00:49:18,480 --> 00:49:20,400
also want to aim for some more advanced

1351
00:49:20,400 --> 00:49:22,319
cryptographic features like the ability

1352
00:49:22,319 --> 00:49:24,599
to recover from compromises or to

1353
00:49:24,599 --> 00:49:27,240
protect your data from future compromise

1354
00:49:27,240 --> 00:49:28,859
however achieving these things are

1355
00:49:28,859 --> 00:49:30,960
challenging so first of all supporting

1356
00:49:30,960 --> 00:49:32,400
multiple devices leads to a key

1357
00:49:32,400 --> 00:49:33,960
management issue and this means that

1358
00:49:33,960 --> 00:49:36,780
users have to handle keys or passwords

1359
00:49:36,780 --> 00:49:39,240
additionally if we want to share files

1360
00:49:39,240 --> 00:49:40,920
between users we have to find a way to

1361
00:49:40,920 --> 00:49:43,140
do a key exchange between them

1362
00:49:43,140 --> 00:49:44,520
and furthermore achieving

1363
00:49:44,520 --> 00:49:46,500
post-compromise and forward security is

1364
00:49:46,500 --> 00:49:47,880
more challenging in the setting event

1365
00:49:47,880 --> 00:49:49,619
and acrylic cloud storage than in for

1366
00:49:49,619 --> 00:49:51,720
example messaging because the data here

1367
00:49:51,720 --> 00:49:54,240
is persistent so users want to be able

1368
00:49:54,240 --> 00:49:56,220
to come back and access their files over

1369
00:49:56,220 --> 00:49:57,540
and over again which means that we

1370
00:49:57,540 --> 00:49:59,460
cannot easily use ephemeral secrets to

1371
00:49:59,460 --> 00:50:01,079
protect the files and this makes

1372
00:50:01,079 --> 00:50:02,520
achieving post compromise and forward

1373
00:50:02,520 --> 00:50:04,920
security more challenging

1374
00:50:04,920 --> 00:50:06,720
and these challenges they stem at least

1375
00:50:06,720 --> 00:50:08,940
in part from the the fact that we're

1376
00:50:08,940 --> 00:50:10,380
assuming a very strong threat model

1377
00:50:10,380 --> 00:50:12,359
where we don't want to trust the storage

1378
00:50:12,359 --> 00:50:14,339
provider for essentially anything beyond

1379
00:50:14,339 --> 00:50:16,319
availability

1380
00:50:16,319 --> 00:50:19,260
however somewhat paradoxically we're

1381
00:50:19,260 --> 00:50:21,359
trusting the providers today with the

1382
00:50:21,359 --> 00:50:23,040
challenging task of Designing the

1383
00:50:23,040 --> 00:50:24,720
cryptograph the cryptography that's

1384
00:50:24,720 --> 00:50:26,579
supposed to protect our data from them

1385
00:50:26,579 --> 00:50:28,800
and as we see in the case of Mega this

1386
00:50:28,800 --> 00:50:30,480
doesn't always work out

1387
00:50:30,480 --> 00:50:33,060
so what can we do about this well we

1388
00:50:33,060 --> 00:50:34,500
would like to propose a standardization

1389
00:50:34,500 --> 00:50:37,619
effort where various stakeholders from

1390
00:50:37,619 --> 00:50:39,480
Academia and Industry come together in

1391
00:50:39,480 --> 00:50:41,160
order to design a well-analyzed and

1392
00:50:41,160 --> 00:50:42,599
practical end-to-end crypto cloud

1393
00:50:42,599 --> 00:50:44,640
storage system that we can all trust

1394
00:50:44,640 --> 00:50:46,380
and with that I want to end with a

1395
00:50:46,380 --> 00:50:48,240
question for you and that is how can we

1396
00:50:48,240 --> 00:50:49,680
interest providers in such a

1397
00:50:49,680 --> 00:50:51,839
standardization effort we don't have an

1398
00:50:51,839 --> 00:50:53,640
answer to this we're hoping that some

1399
00:50:53,640 --> 00:50:55,260
economic incentives like allowing

1400
00:50:55,260 --> 00:50:56,940
customizable features or an integration

1401
00:50:56,940 --> 00:50:58,980
into their ecosystems can help or

1402
00:50:58,980 --> 00:51:00,839
perhaps political political incentives

1403
00:51:00,839 --> 00:51:02,700
like data privacy laws and regulations

1404
00:51:02,700 --> 00:51:04,800
on the security that a system needs to

1405
00:51:04,800 --> 00:51:06,960
provide but we'd be super happy to hear

1406
00:51:06,960 --> 00:51:08,099
your thoughts so if you have any ideas

1407
00:51:08,099 --> 00:51:09,900
please come talk to us in the hallways

1408
00:51:09,900 --> 00:51:11,460
and with that I'd like to thank you for

1409
00:51:11,460 --> 00:51:13,579
your attention

1410
00:51:13,579 --> 00:51:16,579
thank you

1411
00:51:20,680 --> 00:51:24,910
[Applause]

1412
00:51:25,800 --> 00:51:28,500
thanks for the talk could it be possible

1413
00:51:28,500 --> 00:51:30,260
to design

1414
00:51:30,260 --> 00:51:33,900
a client that does all of the encryption

1415
00:51:33,900 --> 00:51:36,480
and just treats a service provider an

1416
00:51:36,480 --> 00:51:38,460
existing service provider as a black box

1417
00:51:38,460 --> 00:51:40,800
where you don't rely on anything from

1418
00:51:40,800 --> 00:51:42,720
them other than them hosting some bits

1419
00:51:42,720 --> 00:51:44,760
that you encrypted yourself wondering if

1420
00:51:44,760 --> 00:51:46,020
you could pursue the standardization

1421
00:51:46,020 --> 00:51:49,140
strictly by building a client-side app

1422
00:51:49,140 --> 00:51:51,780
so I think the issue with this is the

1423
00:51:51,780 --> 00:51:54,000
key management between different devices

1424
00:51:54,000 --> 00:51:57,180
because if you're only as long as you're

1425
00:51:57,180 --> 00:51:59,579
basically this is like encrypted backup

1426
00:51:59,579 --> 00:52:01,380
you encrypt your files you upload it

1427
00:52:01,380 --> 00:52:02,940
somewhere and you don't care what the

1428
00:52:02,940 --> 00:52:05,579
other person is doing but then how do

1429
00:52:05,579 --> 00:52:07,859
you get the keys from your laptop to

1430
00:52:07,859 --> 00:52:10,380
your mobile phone I think this is where

1431
00:52:10,380 --> 00:52:13,500
we sort of need to have some

1432
00:52:13,500 --> 00:52:17,880
amps support from from a cloud provider

1433
00:52:17,880 --> 00:52:20,339
two very related questions so the first

1434
00:52:20,339 --> 00:52:22,559
one if you just uh you know replace

1435
00:52:22,559 --> 00:52:24,480
encryption by authenticating encryption

1436
00:52:24,480 --> 00:52:26,940
don't do trivial things do we believe

1437
00:52:26,940 --> 00:52:30,240
that Mega System would be secure and

1438
00:52:30,240 --> 00:52:32,880
kind of related to this uh

1439
00:52:32,880 --> 00:52:35,040
um do you have actually a model I mean I

1440
00:52:35,040 --> 00:52:36,480
know it's an open question but you have

1441
00:52:36,480 --> 00:52:38,160
a model of something that you consider

1442
00:52:38,160 --> 00:52:42,680
secure and maybe some secure solution

1443
00:52:42,920 --> 00:52:46,260
so I wouldn't propose to use my guess

1444
00:52:46,260 --> 00:52:48,599
design even if they were to change some

1445
00:52:48,599 --> 00:52:49,859
of these things

1446
00:52:49,859 --> 00:52:50,880
um for the reason that they don't

1447
00:52:50,880 --> 00:52:52,380
provide most of these ideal features

1448
00:52:52,380 --> 00:52:53,520
that we like so they don't support

1449
00:52:53,520 --> 00:52:54,900
things like key rotation for example

1450
00:52:54,900 --> 00:52:56,520
there's definitely not cryptographically

1451
00:52:56,520 --> 00:52:58,920
agile it would be very hard to to

1452
00:52:58,920 --> 00:53:01,020
probably show that their system is

1453
00:53:01,020 --> 00:53:04,440
secure and yeah it's work in progress to

1454
00:53:04,440 --> 00:53:07,800
to make a security model that we can use

1455
00:53:07,800 --> 00:53:10,579
yes

1456
00:53:10,579 --> 00:53:13,619
hi thanks for the great talk so one

1457
00:53:13,619 --> 00:53:15,780
desired property that I didn't see is

1458
00:53:15,780 --> 00:53:18,720
that detecting when many users have the

1459
00:53:18,720 --> 00:53:20,700
same file like a book that thousands of

1460
00:53:20,700 --> 00:53:23,880
people may have because this can help uh

1461
00:53:23,880 --> 00:53:26,280
storage provider to reduce their costs a

1462
00:53:26,280 --> 00:53:29,400
lot and have you thought about uh what

1463
00:53:29,400 --> 00:53:31,800
is the impact of like this encryption on

1464
00:53:31,800 --> 00:53:35,520
cause and scalability and an extension

1465
00:53:35,520 --> 00:53:38,160
of that trying to improve this scheme in

1466
00:53:38,160 --> 00:53:41,099
a way that you can detect whether a file

1467
00:53:41,099 --> 00:53:43,380
is common in a privacy preserving Manner

1468
00:53:43,380 --> 00:53:48,059
and due to way off like handling private

1469
00:53:48,059 --> 00:53:51,480
create privately created and more

1470
00:53:51,480 --> 00:53:55,460
generic files separately

1471
00:53:57,720 --> 00:54:00,780
so I think a fundamental issue is as

1472
00:54:00,780 --> 00:54:04,980
soon as you are able to detect like you

1473
00:54:04,980 --> 00:54:06,780
need to have a deterministic encryption

1474
00:54:06,780 --> 00:54:08,640
scheme to be able to detect the two

1475
00:54:08,640 --> 00:54:10,440
files or the same if they're encrypted

1476
00:54:10,440 --> 00:54:12,839
and then you only have ntpi security

1477
00:54:12,839 --> 00:54:15,540
instead of in CCI security so there are

1478
00:54:15,540 --> 00:54:18,300
definitely trade-offs within

1479
00:54:18,300 --> 00:54:21,859
um performance and security here

1480
00:54:22,740 --> 00:54:23,880
I mean

1481
00:54:23,880 --> 00:54:25,079
if someone like me

1482
00:54:25,079 --> 00:54:27,180
like next to implement a some without

1483
00:54:27,180 --> 00:54:29,040
deduplication I think that's something

1484
00:54:29,040 --> 00:54:30,420
we should applaud right because it does

1485
00:54:30,420 --> 00:54:31,980
give higher privacy guarantees for the

1486
00:54:31,980 --> 00:54:34,500
users so

1487
00:54:34,500 --> 00:54:35,920
the

1488
00:54:35,920 --> 00:54:36,180
[Music]

1489
00:54:36,180 --> 00:54:37,319
um

1490
00:54:37,319 --> 00:54:39,900
let's thank the speakers and I'm there

1491
00:54:39,900 --> 00:54:42,260
is enough

1492
00:54:46,079 --> 00:54:49,980
and the last talk for this session uh

1493
00:54:49,980 --> 00:54:52,140
Luca here she is going to talk about a

1494
00:54:52,140 --> 00:54:54,059
reversing braking and fixing the French

1495
00:54:54,059 --> 00:54:58,280
legislative election e-voting protocol

1496
00:55:00,920 --> 00:55:04,099
all right

1497
00:55:06,740 --> 00:55:08,579
thank you

1498
00:55:08,579 --> 00:55:10,559
can you hear me yeah

1499
00:55:10,559 --> 00:55:13,740
okay so uh my name is lucasi and this is

1500
00:55:13,740 --> 00:55:16,220
a don't work with

1501
00:55:16,220 --> 00:55:19,920
Alexi in France and indeed I'm going to

1502
00:55:19,920 --> 00:55:21,780
tell you the story of how we reversed

1503
00:55:21,780 --> 00:55:25,079
broke and fixed the French legislative

1504
00:55:25,079 --> 00:55:27,960
election you're watching protocol

1505
00:55:27,960 --> 00:55:29,460
so

1506
00:55:29,460 --> 00:55:31,980
um so last year they used a new protocol

1507
00:55:31,980 --> 00:55:34,200
to organize the largest e-voting

1508
00:55:34,200 --> 00:55:36,180
election ever not only in France but

1509
00:55:36,180 --> 00:55:37,319
worldwide

1510
00:55:37,319 --> 00:55:40,800
and my largest I really mean in terms of

1511
00:55:40,800 --> 00:55:43,020
expressed votes in terms of ballots that

1512
00:55:43,020 --> 00:55:45,300
were cast so more than 500 ballots were

1513
00:55:45,300 --> 00:55:48,000
cast using this new protocol that we're

1514
00:55:48,000 --> 00:55:50,640
going to to call flap here in this talk

1515
00:55:50,640 --> 00:55:52,380
so that was a strong enough motivation

1516
00:55:52,380 --> 00:55:54,960
for us to try to assess whether this

1517
00:55:54,960 --> 00:55:57,540
protocol was Secure and or not

1518
00:55:57,540 --> 00:55:59,460
and we focused on Two soundtrack

1519
00:55:59,460 --> 00:56:01,800
security goals in e-booking

1520
00:56:01,800 --> 00:56:04,020
first ballot privacy which means that

1521
00:56:04,020 --> 00:56:06,839
another Echo should not be able to learn

1522
00:56:06,839 --> 00:56:08,640
how voters vote

1523
00:56:08,640 --> 00:56:11,160
obviously and but also very fability

1524
00:56:11,160 --> 00:56:13,800
which means that voters models must have

1525
00:56:13,800 --> 00:56:17,760
somehow a guarantee that their vote has

1526
00:56:17,760 --> 00:56:19,980
been counted and not compared with or

1527
00:56:19,980 --> 00:56:21,900
drug

1528
00:56:21,900 --> 00:56:24,660
so let's talk about this protocol a bit

1529
00:56:24,660 --> 00:56:28,079
uh here are all the agents involved in

1530
00:56:28,079 --> 00:56:30,359
the political so obviously you have a

1531
00:56:30,359 --> 00:56:33,359
voter voting from a voting client which

1532
00:56:33,359 --> 00:56:35,819
is essentially a JavaScript program

1533
00:56:35,819 --> 00:56:37,380
running in a browser

1534
00:56:37,380 --> 00:56:39,960
and it connects to a voting server

1535
00:56:39,960 --> 00:56:42,720
hosted by the French ministry here

1536
00:56:42,720 --> 00:56:44,760
and you also have decryption trustees

1537
00:56:44,760 --> 00:56:49,619
here who each each of the official has a

1538
00:56:49,619 --> 00:56:51,660
teacher and together they would be able

1539
00:56:51,660 --> 00:56:53,579
to decorate ballots

1540
00:56:53,579 --> 00:56:55,740
and finally you've got third party here

1541
00:56:55,740 --> 00:56:58,980
run by independent researchers and those

1542
00:56:58,980 --> 00:57:02,460
will observe the election do some checks

1543
00:57:02,460 --> 00:57:03,960
to make sure everything happens as

1544
00:57:03,960 --> 00:57:06,480
expected and that there was no no no

1545
00:57:06,480 --> 00:57:09,660
attack that could be detected

1546
00:57:09,660 --> 00:57:11,400
so next we want you to know how the

1547
00:57:11,400 --> 00:57:12,780
different agents interact with each

1548
00:57:12,780 --> 00:57:15,480
other uh what crypto they use what kind

1549
00:57:15,480 --> 00:57:17,160
of check they do and what kind of

1550
00:57:17,160 --> 00:57:19,980
messages they exchange but sadly at the

1551
00:57:19,980 --> 00:57:22,859
time there was no comprehensive

1552
00:57:22,859 --> 00:57:24,839
documentation or specification of the

1553
00:57:24,839 --> 00:57:25,680
protocol

1554
00:57:25,680 --> 00:57:28,200
so we we had to do it ourselves so we

1555
00:57:28,200 --> 00:57:29,880
looked at the voting client we looked at

1556
00:57:29,880 --> 00:57:32,760
the mostly the JavaScript program but it

1557
00:57:32,760 --> 00:57:34,859
was obfuscated so we had to reverse it

1558
00:57:34,859 --> 00:57:37,680
and so we did so so that today I can

1559
00:57:37,680 --> 00:57:40,020
tell you a bit more about the protocol

1560
00:57:40,020 --> 00:57:42,180
I will give you really an overview of

1561
00:57:42,180 --> 00:57:44,220
the protocol a very high level view but

1562
00:57:44,220 --> 00:57:47,540
all the goalie details are in the paper

1563
00:57:47,540 --> 00:57:51,420
so for the voter picks a choice let's

1564
00:57:51,420 --> 00:57:54,059
call it V and the vertical end is going

1565
00:57:54,059 --> 00:57:56,400
to asymmetrically encrypt it with the

1566
00:57:56,400 --> 00:57:58,260
decryption trust is key

1567
00:57:58,260 --> 00:58:00,839
and it also computes some geology proofs

1568
00:58:00,839 --> 00:58:03,480
to prove that this is a valid Choice

1569
00:58:03,480 --> 00:58:06,300
it's an encryption of a valid choice and

1570
00:58:06,300 --> 00:58:08,760
it also binds is to some metadatarity

1571
00:58:08,760 --> 00:58:10,380
election

1572
00:58:10,380 --> 00:58:12,420
and this is how ballot privacy is

1573
00:58:12,420 --> 00:58:15,420
supposed to be to be satisfied uh thanks

1574
00:58:15,420 --> 00:58:17,520
to this encryption here

1575
00:58:17,520 --> 00:58:19,319
okay then the watching server is going

1576
00:58:19,319 --> 00:58:23,220
to compute some recept for this ballot

1577
00:58:23,220 --> 00:58:25,260
essentially it's a hash over the ballot

1578
00:58:25,260 --> 00:58:27,599
and some metadata and also a signature

1579
00:58:27,599 --> 00:58:28,980
about this hash

1580
00:58:28,980 --> 00:58:31,559
and in the metadata there is The Ballot

1581
00:58:31,559 --> 00:58:33,839
Box identifier this is important because

1582
00:58:33,839 --> 00:58:35,480
for that election

1583
00:58:35,480 --> 00:58:38,640
there were many ballot boxes one for

1584
00:58:38,640 --> 00:58:40,500
each Consular which corresponds to a

1585
00:58:40,500 --> 00:58:42,599
city so for example the water Ballot Box

1586
00:58:42,599 --> 00:58:46,740
for Sydney one for Atlanta let's see

1587
00:58:46,740 --> 00:58:49,079
and this is important because the

1588
00:58:49,079 --> 00:58:51,540
results will be published per Ballot Box

1589
00:58:51,540 --> 00:58:54,000
so we're gonna have the results for

1590
00:58:54,000 --> 00:58:57,180
Atlanta and the results for Sydney

1591
00:58:57,180 --> 00:59:00,059
this is then displayed to the roller on

1592
00:59:00,059 --> 00:59:02,400
the watching client and you can you can

1593
00:59:02,400 --> 00:59:05,040
even Download a pdf file containing

1594
00:59:05,040 --> 00:59:08,339
those receipts for later use

1595
00:59:08,339 --> 00:59:10,700
and then the voting server is going to

1596
00:59:10,700 --> 00:59:14,339
store all those ballots put them in the

1597
00:59:14,339 --> 00:59:15,900
corresponding Ballot Box and the

1598
00:59:15,900 --> 00:59:17,760
decryption trustes are going to decrypt

1599
00:59:17,760 --> 00:59:19,559
each of the ballots sorry each of The

1600
00:59:19,559 --> 00:59:21,960
Ballot Box and

1601
00:59:21,960 --> 00:59:24,480
um publish the results per par Ballot

1602
00:59:24,480 --> 00:59:26,700
Box that I said they also compute some

1603
00:59:26,700 --> 00:59:28,980
geology proofs proving that this

1604
00:59:28,980 --> 00:59:30,480
decryption is correct

1605
00:59:30,480 --> 00:59:33,119
and all of that is checked observed and

1606
00:59:33,119 --> 00:59:36,140
checked by the third party

1607
00:59:36,140 --> 00:59:39,960
also the model can use can use a receipt

1608
00:59:39,960 --> 00:59:41,040
it got

1609
00:59:41,040 --> 00:59:45,119
to ask the third party whether their

1610
00:59:45,119 --> 00:59:46,920
ballots were really counted or not

1611
00:59:46,920 --> 00:59:48,960
because from the receipt the third party

1612
00:59:48,960 --> 00:59:50,599
can

1613
00:59:50,599 --> 00:59:52,859
identify the corresponding ballot and

1614
00:59:52,859 --> 00:59:54,540
make sure that it was indeed in The

1615
00:59:54,540 --> 00:59:56,339
Ballot Box that was used to another

1616
00:59:56,339 --> 00:59:57,480
result

1617
00:59:57,480 --> 00:59:59,579
this is how verifiability is supposed to

1618
00:59:59,579 --> 01:00:03,059
to be achieved through those receipts

1619
01:00:03,059 --> 01:00:05,339
okay so I've already mentioned the two

1620
01:00:05,339 --> 01:00:07,140
Central goals we're going to analyze

1621
01:00:07,140 --> 01:00:10,140
here but when do we expect them to to

1622
01:00:10,140 --> 01:00:13,380
hold so here are the different agents I

1623
01:00:13,380 --> 01:00:15,359
just added here the communication

1624
01:00:15,359 --> 01:00:18,839
Channel agent somehow you can think of

1625
01:00:18,839 --> 01:00:22,079
this as so you can think of a compromise

1626
01:00:22,079 --> 01:00:24,000
of the communication Channel as a weaker

1627
01:00:24,000 --> 01:00:26,520
attacker than devoting server attacker

1628
01:00:26,520 --> 01:00:28,799
because here we just assume that somehow

1629
01:00:28,799 --> 01:00:31,920
the attacker is able to decrypt jealous

1630
01:00:31,920 --> 01:00:34,859
packets and modify them possibly for

1631
01:00:34,859 --> 01:00:36,960
example if the attacker has a

1632
01:00:36,960 --> 01:00:38,339
certificate of the watching server

1633
01:00:38,339 --> 01:00:40,440
that's one example it's a strictly

1634
01:00:40,440 --> 01:00:44,040
weaker sweat models and assuming a

1635
01:00:44,040 --> 01:00:46,559
compromised working server

1636
01:00:46,559 --> 01:00:48,599
okay so when we expect the properties to

1637
01:00:48,599 --> 01:00:53,059
hold this is kind of a standard for

1638
01:00:53,059 --> 01:00:55,200
state-of-the-art Polar codes in

1639
01:00:55,200 --> 01:00:58,260
inverting for Bio privacy you you can

1640
01:00:58,260 --> 01:01:00,660
have the property under a compromise

1641
01:01:00,660 --> 01:01:02,700
watching server and also compromise

1642
01:01:02,700 --> 01:01:04,500
Communication channel and for

1643
01:01:04,500 --> 01:01:06,240
verifiability you don't even need to to

1644
01:01:06,240 --> 01:01:08,940
trace the decryption trusted

1645
01:01:08,940 --> 01:01:11,940
and as we shortly we found attacks on

1646
01:01:11,940 --> 01:01:13,400
the flat protocol

1647
01:01:13,400 --> 01:01:17,040
on an even weaker threat model so when

1648
01:01:17,040 --> 01:01:18,660
the communication channel is compromised

1649
01:01:18,660 --> 01:01:21,540
or if you want when the watching server

1650
01:01:21,540 --> 01:01:24,720
is compromised as well

1651
01:01:24,720 --> 01:01:27,359
okay so let's summarize a bit the

1652
01:01:27,359 --> 01:01:28,740
different things we we've done around

1653
01:01:28,740 --> 01:01:31,140
this protocol so thanks to the reverse

1654
01:01:31,140 --> 01:01:33,599
first we we were able to provide this

1655
01:01:33,599 --> 01:01:35,460
comprehensive specification of of the

1656
01:01:35,460 --> 01:01:36,480
protocol

1657
01:01:36,480 --> 01:01:39,660
I thought it was the first time we

1658
01:01:39,660 --> 01:01:42,420
we we provided such a public document

1659
01:01:42,420 --> 01:01:45,119
and based on this understanding we form

1660
01:01:45,119 --> 01:01:46,640
two vulnerabilities

1661
01:01:46,640 --> 01:01:49,440
on the system on which we base six

1662
01:01:49,440 --> 01:01:51,599
different attacks on by stability and

1663
01:01:51,599 --> 01:01:53,400
and privacy

1664
01:01:53,400 --> 01:01:55,619
and so in a responsible disclosure with

1665
01:01:55,619 --> 01:01:58,380
the Wonder and the ministry we propose

1666
01:01:58,380 --> 01:02:01,020
different fixes six of them uh and most

1667
01:02:01,020 --> 01:02:03,299
of them are already implemented for the

1668
01:02:03,299 --> 01:02:06,299
next election that are going to uh to be

1669
01:02:06,299 --> 01:02:08,280
organized in a few months now

1670
01:02:08,280 --> 01:02:10,799
and from this analysis we draw lessons

1671
01:02:10,799 --> 01:02:14,299
for like any system any deployment of

1672
01:02:14,299 --> 01:02:16,980
deployment of such a system and I will

1673
01:02:16,980 --> 01:02:18,839
briefly mention some of them at the end

1674
01:02:18,839 --> 01:02:21,200
of The Talk

1675
01:02:21,599 --> 01:02:23,339
okay so not

1676
01:02:23,339 --> 01:02:25,980
let's dive into the the attacks and the

1677
01:02:25,980 --> 01:02:29,040
fixes and let's start with the attack on

1678
01:02:29,040 --> 01:02:30,960
very stability

1679
01:02:30,960 --> 01:02:33,660
so here is the flow of the Polar quality

1680
01:02:33,660 --> 01:02:36,059
of our view of the product I just shown

1681
01:02:36,059 --> 01:02:37,859
you before and here we are going to

1682
01:02:37,859 --> 01:02:40,500
assume a compromise watching server the

1683
01:02:40,500 --> 01:02:43,319
rest the other agents are supposed to be

1684
01:02:43,319 --> 01:02:44,599
trustworthy

1685
01:02:44,599 --> 01:02:48,599
okay so what the article can do here

1686
01:02:48,599 --> 01:02:50,280
um so when the voting client sends a

1687
01:02:50,280 --> 01:02:52,559
ballot Associated to the voter's Choice

1688
01:02:52,559 --> 01:02:54,660
the voting server should compute the

1689
01:02:54,660 --> 01:02:56,099
receipt right

1690
01:02:56,099 --> 01:02:58,920
and this receipt must match the ballots

1691
01:02:58,920 --> 01:03:00,960
that has been combated by the voting

1692
01:03:00,960 --> 01:03:02,160
client right

1693
01:03:02,160 --> 01:03:04,500
indeed there is such a check in the

1694
01:03:04,500 --> 01:03:06,599
JavaScript program to make sure the

1695
01:03:06,599 --> 01:03:09,119
received matches but

1696
01:03:09,119 --> 01:03:10,859
to be honest it's quite of a mess

1697
01:03:10,859 --> 01:03:13,319
because there are at least four

1698
01:03:13,319 --> 01:03:15,119
different receipts handled by the voting

1699
01:03:15,119 --> 01:03:17,760
client four of them and there are many

1700
01:03:17,760 --> 01:03:19,799
different constancy checks but they're

1701
01:03:19,799 --> 01:03:23,040
float because in that mess we fall away

1702
01:03:23,040 --> 01:03:27,000
for malicious watching server to provide

1703
01:03:27,000 --> 01:03:29,160
attacker control receipt

1704
01:03:29,160 --> 01:03:31,500
that is going to be displayed to the

1705
01:03:31,500 --> 01:03:33,839
water and the voting client is not

1706
01:03:33,839 --> 01:03:35,940
complaining it will just proceed and

1707
01:03:35,940 --> 01:03:39,180
show this fake receipt to the to the to

1708
01:03:39,180 --> 01:03:40,980
the photo

1709
01:03:40,980 --> 01:03:42,599
so what does that mean it means that

1710
01:03:42,599 --> 01:03:44,160
then the water will use this fake

1711
01:03:44,160 --> 01:03:46,980
receipt to check valuability right and

1712
01:03:46,980 --> 01:03:48,660
because it's attacker controlled it

1713
01:03:48,660 --> 01:03:50,819
really means the voting server can

1714
01:03:50,819 --> 01:03:53,460
tamper with the ballot compute a ballot

1715
01:03:53,460 --> 01:03:56,339
for a choice of I mean for for a vote of

1716
01:03:56,339 --> 01:03:57,599
his choice

1717
01:03:57,599 --> 01:04:00,059
compute a fake receipt accordingly

1718
01:04:00,059 --> 01:04:02,579
Associated to this fake ballot

1719
01:04:02,579 --> 01:04:05,220
and the roller will use it to ask the

1720
01:04:05,220 --> 01:04:09,660
soul party hey is my ballot content and

1721
01:04:09,660 --> 01:04:12,180
no not your balance discounted but the

1722
01:04:12,180 --> 01:04:14,160
fake ballot Associated to the to the

1723
01:04:14,160 --> 01:04:16,339
receipt you provided me so neither

1724
01:04:16,339 --> 01:04:19,380
another third party is able to detect

1725
01:04:19,380 --> 01:04:21,059
such an attack

1726
01:04:21,059 --> 01:04:23,339
so what's the impact the impact is that

1727
01:04:23,339 --> 01:04:26,160
for watching server attacker and we

1728
01:04:26,160 --> 01:04:28,020
showing the people also for a channel

1729
01:04:28,020 --> 01:04:31,740
attacker the article can State CB modify

1730
01:04:31,740 --> 01:04:33,960
the outcome of the election by modifying

1731
01:04:33,960 --> 01:04:36,180
ballots or dropping ballots as we show

1732
01:04:36,180 --> 01:04:38,339
in the paper

1733
01:04:38,339 --> 01:04:40,920
that's pretty bad because that's what

1734
01:04:40,920 --> 01:04:44,099
what we ask from verifiability

1735
01:04:44,099 --> 01:04:45,720
but that's not the end of the story

1736
01:04:45,720 --> 01:04:47,640
because we also found issues regarding

1737
01:04:47,640 --> 01:04:48,960
privacy

1738
01:04:48,960 --> 01:04:51,720
so the main problem is at the design

1739
01:04:51,720 --> 01:04:55,760
level we found out that the Ballad The

1740
01:04:55,760 --> 01:04:58,799
Bells do not bind The Ballot Box

1741
01:04:58,799 --> 01:05:00,720
identifier

1742
01:05:00,720 --> 01:05:03,839
so it's not in the metadata for in the

1743
01:05:03,839 --> 01:05:04,920
proofs

1744
01:05:04,920 --> 01:05:07,859
but fortunately it's in the in the

1745
01:05:07,859 --> 01:05:11,099
receipt in the hash the hash hash is a

1746
01:05:11,099 --> 01:05:13,619
ballot and some Metallica but that's not

1747
01:05:13,619 --> 01:05:15,839
sufficient as we should see this is the

1748
01:05:15,839 --> 01:05:19,280
attack I will describe now so

1749
01:05:19,280 --> 01:05:21,839
eligible to vote in Sydney

1750
01:05:21,839 --> 01:05:25,140
so it will pick a choice computer a

1751
01:05:25,140 --> 01:05:27,660
ballot and the watching server keeps

1752
01:05:27,660 --> 01:05:30,119
this ballot as is but it will store it

1753
01:05:30,119 --> 01:05:31,920
will store it in the wrong Ballot Box

1754
01:05:31,920 --> 01:05:35,280
here for example it's a one for Minsk

1755
01:05:35,280 --> 01:05:37,859
and it will compute a receipt

1756
01:05:37,859 --> 01:05:40,200
for this palette but for the wrong

1757
01:05:40,200 --> 01:05:43,380
Ballot Box here Minsk

1758
01:05:43,380 --> 01:05:45,140
um and at the end the water will use

1759
01:05:45,140 --> 01:05:47,700
this receipt and the salt party will say

1760
01:05:47,700 --> 01:05:49,920
yeah your balance has been counted but

1761
01:05:49,920 --> 01:05:51,720
in the wrong Ballot Box but no one is

1762
01:05:51,720 --> 01:05:54,119
able to detect this problem here again

1763
01:05:54,119 --> 01:05:57,180
note that if The Ballot Box was

1764
01:05:57,180 --> 01:05:58,880
International the knowledge proof

1765
01:05:58,880 --> 01:06:01,380
metadata then this would not be possible

1766
01:06:01,380 --> 01:06:04,079
because the third party would say no

1767
01:06:04,079 --> 01:06:05,960
your ballot is counted but in the wrong

1768
01:06:05,960 --> 01:06:09,140
pilot box

1769
01:06:09,660 --> 01:06:12,119
so this is this is a problem in itself

1770
01:06:12,119 --> 01:06:14,700
but why doesn't impact privacy it does

1771
01:06:14,700 --> 01:06:16,559
because of yet of this attack I will I

1772
01:06:16,559 --> 01:06:18,540
will print now

1773
01:06:18,540 --> 01:06:21,720
so here we have a Target border

1774
01:06:21,720 --> 01:06:24,359
eligible to vote in Sydney and we have a

1775
01:06:24,359 --> 01:06:26,460
compromise watching server what can this

1776
01:06:26,460 --> 01:06:28,140
server do now

1777
01:06:28,140 --> 01:06:30,680
it will do the following when the water

1778
01:06:30,680 --> 01:06:33,059
casts a ballot

1779
01:06:33,059 --> 01:06:36,000
so a bilateral I mean voting for an

1780
01:06:36,000 --> 01:06:37,140
unknown

1781
01:06:37,140 --> 01:06:40,020
a vote option so here V question mark

1782
01:06:40,020 --> 01:06:42,900
the Virgin server will not store storage

1783
01:06:42,900 --> 01:06:46,859
in cinema in Sydney but in Minsk

1784
01:06:46,859 --> 01:06:49,740
you could choose any Ballot Box and here

1785
01:06:49,740 --> 01:06:51,359
we just assume he will choose a Ballot

1786
01:06:51,359 --> 01:06:55,400
Box for which there are a few expected

1787
01:06:55,400 --> 01:06:58,020
borrowers who will actually cast a

1788
01:06:58,020 --> 01:06:59,940
balance in there

1789
01:06:59,940 --> 01:07:02,339
maybe Minsk I don't know

1790
01:07:02,339 --> 01:07:04,619
okay so the watching server will compute

1791
01:07:04,619 --> 01:07:07,140
the fake receipt as explained

1792
01:07:07,140 --> 01:07:08,640
and when

1793
01:07:08,640 --> 01:07:10,920
um truly eligible voters for Minsk will

1794
01:07:10,920 --> 01:07:13,020
cast a ballot the watching server will

1795
01:07:13,020 --> 01:07:15,119
apply the previous attack

1796
01:07:15,119 --> 01:07:18,539
to modify what is I mean to compute a

1797
01:07:18,539 --> 01:07:20,940
new ballot for an option he knows for

1798
01:07:20,940 --> 01:07:22,440
example V1

1799
01:07:22,440 --> 01:07:23,579
okay

1800
01:07:23,579 --> 01:07:26,640
and for the second one maybe V2

1801
01:07:26,640 --> 01:07:29,280
and at the end this Ballot Box will be

1802
01:07:29,280 --> 01:07:31,740
decrypted by two decryption trustes that

1803
01:07:31,740 --> 01:07:34,079
I assume to be honest right

1804
01:07:34,079 --> 01:07:35,579
so they will do it

1805
01:07:35,579 --> 01:07:37,079
and they will publicly announce the

1806
01:07:37,079 --> 01:07:39,119
result for this Ballot Box

1807
01:07:39,119 --> 01:07:41,039
and because it's public the other girl

1808
01:07:41,039 --> 01:07:44,160
knows it as well right so we know that

1809
01:07:44,160 --> 01:07:47,700
V1 V2 and V question mark was in the

1810
01:07:47,700 --> 01:07:49,799
mailbox and because he knows all the

1811
01:07:49,799 --> 01:07:51,660
votes except the question mark you can

1812
01:07:51,660 --> 01:07:54,059
infer the question mark and break

1813
01:07:54,059 --> 01:07:56,039
privacy

1814
01:07:56,039 --> 01:07:59,400
so again for Server attacker and also

1815
01:07:59,400 --> 01:08:01,260
for actually a Communication channel

1816
01:08:01,260 --> 01:08:03,720
that occur it is possible to stealth

1817
01:08:03,720 --> 01:08:04,579
City

1818
01:08:04,579 --> 01:08:08,160
learn some Target models vote

1819
01:08:08,160 --> 01:08:09,900
and also be showing the paper that you

1820
01:08:09,900 --> 01:08:12,000
can do that on a group of photos and

1821
01:08:12,000 --> 01:08:13,980
this way you can exercise some

1822
01:08:13,980 --> 01:08:15,780
creativity for

1823
01:08:15,780 --> 01:08:19,140
on those orders just to make sure

1824
01:08:19,140 --> 01:08:21,479
uh to prove them that yeah I will be

1825
01:08:21,479 --> 01:08:23,698
able to know if you've voted as I

1826
01:08:23,698 --> 01:08:26,219
instructed so that you can exercise some

1827
01:08:26,219 --> 01:08:28,759
coercion

1828
01:08:30,540 --> 01:08:33,060
okay so we we Pro I mean we found those

1829
01:08:33,060 --> 01:08:35,520
attacks we disclose them to the wander

1830
01:08:35,520 --> 01:08:37,319
and the ministry but we also wanted to

1831
01:08:37,319 --> 01:08:39,359
purpose fix it right to actually fix the

1832
01:08:39,359 --> 01:08:40,198
system

1833
01:08:40,198 --> 01:08:43,259
and we propose six of them and I will

1834
01:08:43,259 --> 01:08:45,719
briefly mention three of them here

1835
01:08:45,719 --> 01:08:48,359
so first obviously you want the watching

1836
01:08:48,359 --> 01:08:49,620
Clan to display

1837
01:08:49,620 --> 01:08:52,439
the receipt ask compute I mean at least

1838
01:08:52,439 --> 01:08:54,899
a hash as computed by the voting client

1839
01:08:54,899 --> 01:08:57,420
you can do extra checks if you want but

1840
01:08:57,420 --> 01:08:59,339
the hash that will be displayed should

1841
01:08:59,339 --> 01:09:01,560
be the one complicated button client the

1842
01:09:01,560 --> 01:09:02,759
true one

1843
01:09:02,759 --> 01:09:04,738
this has been partially done for the

1844
01:09:04,738 --> 01:09:07,679
next election already so I won't go into

1845
01:09:07,679 --> 01:09:10,080
the details of why partially but uh yeah

1846
01:09:10,080 --> 01:09:12,359
okay there is a way for cautious water

1847
01:09:12,359 --> 01:09:15,238
to now detect this attack it's not ideal

1848
01:09:15,238 --> 01:09:18,540
but at least there is a way uh second we

1849
01:09:18,540 --> 01:09:21,899
want The Ballot Box identifier to be

1850
01:09:21,899 --> 01:09:24,359
um to to be bound by the generation

1851
01:09:24,359 --> 01:09:26,939
proofs this is done now and will be used

1852
01:09:26,939 --> 01:09:28,979
as is for the next election so it's

1853
01:09:28,979 --> 01:09:31,020
fixed and we also want the third party

1854
01:09:31,020 --> 01:09:34,020
to actually check that those identifiers

1855
01:09:34,020 --> 01:09:37,020
are consistent now and again this will

1856
01:09:37,020 --> 01:09:38,819
be the case for the next election coming

1857
01:09:38,819 --> 01:09:40,439
in a few months

1858
01:09:40,439 --> 01:09:42,420
yeah so all of that thanks to this

1859
01:09:42,420 --> 01:09:44,160
responsible disclosure and also a

1860
01:09:44,160 --> 01:09:46,140
special thanks to the ads and see which

1861
01:09:46,140 --> 01:09:49,198
is a a French agency who was really

1862
01:09:49,198 --> 01:09:52,580
proactive in this in this process

1863
01:09:53,100 --> 01:09:56,340
okay so in the remaining in the

1864
01:09:56,340 --> 01:09:59,219
remaining time I have I will try to draw

1865
01:09:59,219 --> 01:10:01,980
some lessons we can learn from this uh

1866
01:10:01,980 --> 01:10:03,900
this experience

1867
01:10:03,900 --> 01:10:06,420
this analysis

1868
01:10:06,420 --> 01:10:08,880
so first I have to say and maybe that's

1869
01:10:08,880 --> 01:10:12,120
surprising but I will I will explain uh

1870
01:10:12,120 --> 01:10:14,040
I have to say that this flat protocol

1871
01:10:14,040 --> 01:10:18,380
was based on or inspired by

1872
01:10:18,380 --> 01:10:20,460
state-of-the-art academic Polo color

1873
01:10:20,460 --> 01:10:22,020
called bellenius

1874
01:10:22,020 --> 01:10:24,600
and this Balinese protocol is proven

1875
01:10:24,600 --> 01:10:26,460
secure was proven secure both for

1876
01:10:26,460 --> 01:10:29,340
privacy and verifiability

1877
01:10:29,340 --> 01:10:31,739
and they had the Wonder had to adapt it

1878
01:10:31,739 --> 01:10:36,480
for the this real world use case for the

1879
01:10:36,480 --> 01:10:39,060
previous election and it has to

1880
01:10:39,060 --> 01:10:41,580
re-implement

1881
01:10:41,580 --> 01:10:45,120
um this protocol deploy do some audits

1882
01:10:45,120 --> 01:10:47,699
right and you end up with this system

1883
01:10:47,699 --> 01:10:50,040
used last year which is body broken

1884
01:10:50,040 --> 01:10:52,020
which was badly broken with those

1885
01:10:52,020 --> 01:10:55,860
attacks and I mean other concerns we

1886
01:10:55,860 --> 01:10:58,199
um described in the paper but that have

1887
01:10:58,199 --> 01:11:01,020
not talked about today

1888
01:11:01,020 --> 01:11:03,780
so how come you you start from this very

1889
01:11:03,780 --> 01:11:05,280
secure protocol and you end up with this

1890
01:11:05,280 --> 01:11:07,380
body broken system and what can we learn

1891
01:11:07,380 --> 01:11:09,480
from this

1892
01:11:09,480 --> 01:11:12,900
so first you could wonder why they had

1893
01:11:12,900 --> 01:11:14,719
to add up the design

1894
01:11:14,719 --> 01:11:17,219
and I would say this is mostly because

1895
01:11:17,219 --> 01:11:19,440
state of the art academic solutions they

1896
01:11:19,440 --> 01:11:22,440
lack features for real-world use cases

1897
01:11:22,440 --> 01:11:24,719
typically I mean just two examples first

1898
01:11:24,719 --> 01:11:27,659
one they cannot handle multi ballot

1899
01:11:27,659 --> 01:11:30,540
boxes and this is crucial to be able to

1900
01:11:30,540 --> 01:11:32,640
actually announce fine grain results per

1901
01:11:32,640 --> 01:11:33,900
pilot box

1902
01:11:33,900 --> 01:11:35,760
and so it's not only at the design level

1903
01:11:35,760 --> 01:11:37,800
it's also for stating the security

1904
01:11:37,800 --> 01:11:40,500
properties especially privacy and into

1905
01:11:40,500 --> 01:11:42,780
proofs in the security proofs this is

1906
01:11:42,780 --> 01:11:45,860
just not described at all

1907
01:11:45,860 --> 01:11:49,199
also they had to have a down

1908
01:11:49,199 --> 01:11:52,199
downloadable receipts so Speedy PDF

1909
01:11:52,199 --> 01:11:54,179
files this is an extra problem because

1910
01:11:54,179 --> 01:11:56,820
then you want you may want to generate

1911
01:11:56,820 --> 01:11:59,159
them as a server and not the clients so

1912
01:11:59,159 --> 01:12:01,020
then how do you check that they are

1913
01:12:01,020 --> 01:12:03,239
consistent this is another issue they

1914
01:12:03,239 --> 01:12:04,020
had

1915
01:12:04,020 --> 01:12:05,760
also

1916
01:12:05,760 --> 01:12:10,500
currently there is no practical solution

1917
01:12:10,500 --> 01:12:13,219
to really distribute Trust

1918
01:12:13,219 --> 01:12:16,440
for authenticating the borders so right

1919
01:12:16,440 --> 01:12:18,179
now right now it's a single point of

1920
01:12:18,179 --> 01:12:21,840
trust and you have to trust one entity

1921
01:12:21,840 --> 01:12:23,699
for eligibility verification that's

1922
01:12:23,699 --> 01:12:25,500
pretty bad but there is no particular

1923
01:12:25,500 --> 01:12:27,420
solution to date

1924
01:12:27,420 --> 01:12:31,320
and finally for for this design level

1925
01:12:31,320 --> 01:12:33,960
um sometimes you have a trade-off to do

1926
01:12:33,960 --> 01:12:36,540
between enforcing your properties at the

1927
01:12:36,540 --> 01:12:38,520
protocol level so mathematically in the

1928
01:12:38,520 --> 01:12:39,440
crypto

1929
01:12:39,440 --> 01:12:42,540
or through operational rules and

1930
01:12:42,540 --> 01:12:44,219
obviously I I mean it's much better to

1931
01:12:44,219 --> 01:12:45,960
do it mathematically but sometimes you

1932
01:12:45,960 --> 01:12:47,699
have to do a trade-off here and for

1933
01:12:47,699 --> 01:12:48,719
example

1934
01:12:48,719 --> 01:12:51,060
There Are Rules under which you can

1935
01:12:51,060 --> 01:12:54,420
decrypt Sorry rules for the column that

1936
01:12:54,420 --> 01:12:56,820
can decrypt a Ballot Box there are legal

1937
01:12:56,820 --> 01:12:59,699
rules and not all of them are on forced

1938
01:12:59,699 --> 01:13:01,980
cryptographically but only as

1939
01:13:01,980 --> 01:13:03,840
operational words but that's also

1940
01:13:03,840 --> 01:13:05,699
because there is no academic solution

1941
01:13:05,699 --> 01:13:07,440
for this so that's another open problem

1942
01:13:07,440 --> 01:13:09,360
to look at

1943
01:13:09,360 --> 01:13:11,330
foreign

1944
01:13:11,330 --> 01:13:14,420
[Music]

1945
01:13:14,420 --> 01:13:16,860
and here they made this mistake with the

1946
01:13:16,860 --> 01:13:18,600
receipt in the code

1947
01:13:18,600 --> 01:13:21,540
which is inexistent in berliners in the

1948
01:13:21,540 --> 01:13:22,980
default system

1949
01:13:22,980 --> 01:13:26,159
and maybe that's and despite the audits

1950
01:13:26,159 --> 01:13:29,400
right and maybe that's because the focus

1951
01:13:29,400 --> 01:13:31,080
of the solids were more on the server

1952
01:13:31,080 --> 01:13:34,260
they want to secure the server but for

1953
01:13:34,260 --> 01:13:36,840
e-verting evoting is radically different

1954
01:13:36,840 --> 01:13:38,699
you don't really care about the voting

1955
01:13:38,699 --> 01:13:42,060
server can be compromised can be flowed

1956
01:13:42,060 --> 01:13:43,500
you don't care because you have

1957
01:13:43,500 --> 01:13:45,600
verifiability what you care really about

1958
01:13:45,600 --> 01:13:47,340
is a voting client it's actually the

1959
01:13:47,340 --> 01:13:49,500
critical component so you have to make

1960
01:13:49,500 --> 01:13:51,900
it trustworthy so I think you have to

1961
01:13:51,900 --> 01:13:53,820
open this back and the code at least for

1962
01:13:53,820 --> 01:13:56,400
the watching client and obviously audit

1963
01:13:56,400 --> 01:13:58,320
this system

1964
01:13:58,320 --> 01:14:00,060
you also have to make it monitorable

1965
01:14:00,060 --> 01:14:02,820
which means you should be able life to

1966
01:14:02,820 --> 01:14:04,440
detect if there are differences between

1967
01:14:04,440 --> 01:14:07,440
the voting client served at your system

1968
01:14:07,440 --> 01:14:10,620
versus the truly legitimate one

1969
01:14:10,620 --> 01:14:13,380
and also you have to simplify and I mean

1970
01:14:13,380 --> 01:14:15,480
for specify and also simplify the

1971
01:14:15,480 --> 01:14:17,760
virtual tasks what you expect from the

1972
01:14:17,760 --> 01:14:20,460
borders and assume no more

1973
01:14:20,460 --> 01:14:23,760
because I want new extra extra checks

1974
01:14:23,760 --> 01:14:26,460
if they don't know and I mean on the

1975
01:14:26,460 --> 01:14:28,620
marginal note I think it's important for

1976
01:14:28,620 --> 01:14:30,300
such a critical system to promote

1977
01:14:30,300 --> 01:14:33,300
transparency and openness with false

1978
01:14:33,300 --> 01:14:35,520
clear security objectives and threat

1979
01:14:35,520 --> 01:14:37,739
models this was not the case for that

1980
01:14:37,739 --> 01:14:38,640
system

1981
01:14:38,640 --> 01:14:43,739
and it really open specification uh

1982
01:14:43,739 --> 01:14:48,620
uh maybe even open code plus and also

1983
01:14:48,620 --> 01:14:51,480
promote public scrutiny for example

1984
01:14:51,480 --> 01:14:54,540
through bank Monty programs and they do

1985
01:14:54,540 --> 01:14:55,860
that in Switzerland so I think that's a

1986
01:14:55,860 --> 01:14:57,780
good example

1987
01:14:57,780 --> 01:14:59,820
so I think I will I will stop here thank

1988
01:14:59,820 --> 01:15:01,620
you and I will be happy to take your

1989
01:15:01,620 --> 01:15:02,910
questions now

1990
01:15:02,910 --> 01:15:11,219
[Applause]

1991
01:15:11,219 --> 01:15:14,699
I'm sorry but we are really out of time

1992
01:15:14,699 --> 01:15:17,940
and we will move the questions to

1993
01:15:17,940 --> 01:15:20,580
offline okay thank you very much for to

1994
01:15:20,580 --> 01:15:22,760
all the speakers and to everyone

1995
01:15:22,760 --> 01:15:26,060
attended the year and

1996
01:15:26,060 --> 01:15:34,549
[Applause]

1997
01:15:39,960 --> 01:15:42,960
foreign

