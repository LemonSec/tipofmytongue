1
00:00:02,720 --> 00:00:06,120
University in Belgium on the work that I

2
00:00:06,120 --> 00:00:08,639
will present was accepted this year at

3
00:00:08,639 --> 00:00:10,920
usneck security and this was done in

4
00:00:10,920 --> 00:00:12,179
Colorado collaboration with

5
00:00:12,179 --> 00:00:15,480
domainscapers and uh John khanaton from

6
00:00:15,480 --> 00:00:17,880
Northeastern University

7
00:00:17,880 --> 00:00:19,859
was the title implies here we're not

8
00:00:19,859 --> 00:00:21,600
going to break encryption in the stock

9
00:00:21,600 --> 00:00:24,779
we're actually going to bypass it

10
00:00:24,779 --> 00:00:27,000
so let me first give a very quick

11
00:00:27,000 --> 00:00:29,640
introduction to Wi-Fi security

12
00:00:29,640 --> 00:00:31,439
as you may know we first started out

13
00:00:31,439 --> 00:00:33,660
with web encryption but that was quickly

14
00:00:33,660 --> 00:00:35,700
shown to be horribly broken

15
00:00:35,700 --> 00:00:38,160
then we moved on to WPA one and two

16
00:00:38,160 --> 00:00:40,140
which had their issues in particular

17
00:00:40,140 --> 00:00:41,879
they were vulnerable to offline

18
00:00:41,879 --> 00:00:45,000
dictionary attacks on a few years ago we

19
00:00:45,000 --> 00:00:47,700
had the introduction of wpa3 which

20
00:00:47,700 --> 00:00:49,739
initially had some issues that have also

21
00:00:49,739 --> 00:00:52,079
been presented here at real world crypto

22
00:00:52,079 --> 00:00:54,600
before but they have been fixed in the

23
00:00:54,600 --> 00:00:57,000
meantime so if you have a at least a

24
00:00:57,000 --> 00:00:59,460
properly secured Wi-Fi network you

25
00:00:59,460 --> 00:01:01,980
should be fairly secure

26
00:01:01,980 --> 00:01:05,099
now this covers the design of Wi-Fi

27
00:01:05,099 --> 00:01:07,200
there have also been several

28
00:01:07,200 --> 00:01:09,479
implementation flaws on one that I want

29
00:01:09,479 --> 00:01:11,760
to introduce here is the crook attack

30
00:01:11,760 --> 00:01:15,000
because some of our research of today is

31
00:01:15,000 --> 00:01:17,760
based on this implementation flaw

32
00:01:17,760 --> 00:01:20,340
so let me quickly introduce this

33
00:01:20,340 --> 00:01:23,280
implementation flow and how does this

34
00:01:23,280 --> 00:01:26,460
flaw work well assume that you have a

35
00:01:26,460 --> 00:01:28,740
vulnerable access point

36
00:01:28,740 --> 00:01:31,200
a Wi-Fi access point May temporarily

37
00:01:31,200 --> 00:01:34,320
buffer frames if the wireless medium is

38
00:01:34,320 --> 00:01:36,119
for example busy and there's no

39
00:01:36,119 --> 00:01:38,820
opportunity to send frames

40
00:01:38,820 --> 00:01:41,640
and interestingly in Wi-Fi these frames

41
00:01:41,640 --> 00:01:43,920
will be buffered in plain text they will

42
00:01:43,920 --> 00:01:45,900
not yet be encrypted

43
00:01:45,900 --> 00:01:49,079
what did these researchers discover well

44
00:01:49,079 --> 00:01:50,820
they found out that you can send a

45
00:01:50,820 --> 00:01:52,920
de-authentication frame which basically

46
00:01:52,920 --> 00:01:55,259
informs the access point hey I'm the

47
00:01:55,259 --> 00:01:57,780
client and I'm disconnecting and this

48
00:01:57,780 --> 00:01:59,880
causes the access point to remove the

49
00:01:59,880 --> 00:02:03,000
security context in other words the keys

50
00:02:03,000 --> 00:02:06,119
that are associated to the client

51
00:02:06,119 --> 00:02:07,500
and

52
00:02:07,500 --> 00:02:10,139
this was an implementation flaw

53
00:02:10,139 --> 00:02:12,660
what the researchers then realized once

54
00:02:12,660 --> 00:02:14,220
the wireless medium becomes available

55
00:02:14,220 --> 00:02:16,739
again these buffered frames are finally

56
00:02:16,739 --> 00:02:18,840
transmitted on they are leaked in plain

57
00:02:18,840 --> 00:02:20,879
text or sometimes encrypted using an all

58
00:02:20,879 --> 00:02:22,379
zero key

59
00:02:22,379 --> 00:02:25,020
now if we take a step back here what is

60
00:02:25,020 --> 00:02:26,940
essentially the problem is that we have

61
00:02:26,940 --> 00:02:28,980
buffered frames under the security

62
00:02:28,980 --> 00:02:32,459
context of these buffered frames changes

63
00:02:32,459 --> 00:02:34,680
now they discovered a specific instance

64
00:02:34,680 --> 00:02:37,200
of this but we can ask the questions our

65
00:02:37,200 --> 00:02:39,420
security contexts properly managed in

66
00:02:39,420 --> 00:02:41,340
general and this is the question that we

67
00:02:41,340 --> 00:02:43,440
investigated in our research we

68
00:02:43,440 --> 00:02:45,120
discovered several attacks on today I'm

69
00:02:45,120 --> 00:02:47,580
going to highlight two of them

70
00:02:47,580 --> 00:02:50,700
so let's start with the first attack

71
00:02:50,700 --> 00:02:53,459
so how does this attack work well we

72
00:02:53,459 --> 00:02:55,080
again assume that we have a vulnerable

73
00:02:55,080 --> 00:02:57,540
access point in our case we investigated

74
00:02:57,540 --> 00:03:00,720
mainly open source systems we assume

75
00:03:00,720 --> 00:03:03,060
that the client has successfully

76
00:03:03,060 --> 00:03:04,920
established a connection

77
00:03:04,920 --> 00:03:08,040
and our first novelty is that to control

78
00:03:08,040 --> 00:03:11,340
which frame on access points buffer

79
00:03:11,340 --> 00:03:13,440
we're going to send a so-called power

80
00:03:13,440 --> 00:03:15,780
save frame which is an ordinary data

81
00:03:15,780 --> 00:03:17,700
frame which basically tells the access

82
00:03:17,700 --> 00:03:20,459
point hey I'm the client and I'm going

83
00:03:20,459 --> 00:03:22,800
into power save mode please buffer

84
00:03:22,800 --> 00:03:25,620
frames and this Frame is unprotected

85
00:03:25,620 --> 00:03:28,800
meaning even in wpa3 you can spoof this

86
00:03:28,800 --> 00:03:30,659
Frame

87
00:03:30,659 --> 00:03:33,180
okay then the next thing we do as an

88
00:03:33,180 --> 00:03:35,580
attacker is we sell send a so-called

89
00:03:35,580 --> 00:03:38,879
authentication or Association frame

90
00:03:38,879 --> 00:03:42,360
we spoof that as the attacker and in

91
00:03:42,360 --> 00:03:44,940
wpa3 this Frame is actually protected

92
00:03:44,940 --> 00:03:47,519
but in WPA2 which most networks still

93
00:03:47,519 --> 00:03:50,280
use this can be spoofed by an adversary

94
00:03:50,280 --> 00:03:53,879
and basically when

95
00:03:53,879 --> 00:03:56,580
the attacker spoos this Frame it's

96
00:03:56,580 --> 00:03:58,260
telling the access point hey I'm the

97
00:03:58,260 --> 00:04:00,299
victim and I want to initiate a new

98
00:04:00,299 --> 00:04:02,220
connection and this causes the access

99
00:04:02,220 --> 00:04:05,220
point to again remove the client Keys uh

100
00:04:05,220 --> 00:04:07,319
from the memory

101
00:04:07,319 --> 00:04:09,299
and I guess you can see where this is

102
00:04:09,299 --> 00:04:10,319
going

103
00:04:10,319 --> 00:04:14,159
if we now wake up uh the client by again

104
00:04:14,159 --> 00:04:16,380
sending a wake-up frame

105
00:04:16,380 --> 00:04:17,699
we pretty much have the same

106
00:04:17,699 --> 00:04:19,918
vulnerability as before the access point

107
00:04:19,918 --> 00:04:22,500
will now send these buffered frames

108
00:04:22,500 --> 00:04:25,259
under a different security context to

109
00:04:25,259 --> 00:04:26,040
say

110
00:04:26,040 --> 00:04:28,620
because the access point has now removed

111
00:04:28,620 --> 00:04:30,180
the pairwise key

112
00:04:30,180 --> 00:04:31,740
and

113
00:04:31,740 --> 00:04:34,139
what do I mean here with an undefined

114
00:04:34,139 --> 00:04:37,380
security context well in practice we see

115
00:04:37,380 --> 00:04:39,180
that the frames are not necessarily

116
00:04:39,180 --> 00:04:42,000
leaked in plain text but how the frames

117
00:04:42,000 --> 00:04:44,280
are leaked depends on the system we are

118
00:04:44,280 --> 00:04:45,300
attacking

119
00:04:45,300 --> 00:04:48,300
let me illustrate this with FreeBSD as a

120
00:04:48,300 --> 00:04:50,820
Target surprisingly it supports Wi-Fi

121
00:04:50,820 --> 00:04:52,860
and

122
00:04:52,860 --> 00:04:57,000
how are frames leaked well if we look at

123
00:04:57,000 --> 00:04:59,160
version 3.0

124
00:04:59,160 --> 00:05:02,340
and if we specifically look at a Rowling

125
00:05:02,340 --> 00:05:04,680
driver then the frames are lead to plain

126
00:05:04,680 --> 00:05:05,580
text

127
00:05:05,580 --> 00:05:07,820
but if you update to the next version

128
00:05:07,820 --> 00:05:11,400
13.1 then suddenly these frames are used

129
00:05:11,400 --> 00:05:14,580
are sent using what we call an undefined

130
00:05:14,580 --> 00:05:16,800
security context which in this case

131
00:05:16,800 --> 00:05:19,560
happens to use web encryption which is

132
00:05:19,560 --> 00:05:21,120
already completely broken but in this

133
00:05:21,120 --> 00:05:22,560
case they also use an all zero

134
00:05:22,560 --> 00:05:24,240
encryption key so you can just decrypt

135
00:05:24,240 --> 00:05:26,759
it as an adversary

136
00:05:26,759 --> 00:05:28,800
interestingly if you use a different

137
00:05:28,800 --> 00:05:31,259
wireless dongle or a different driver

138
00:05:31,259 --> 00:05:34,080
from a different vendor then it can

139
00:05:34,080 --> 00:05:36,360
change how these frames are leaked for

140
00:05:36,360 --> 00:05:38,100
example we also observe that they are

141
00:05:38,100 --> 00:05:41,820
encrypted using a ccmp in this case with

142
00:05:41,820 --> 00:05:45,060
the so-called Group D of the network

143
00:05:45,060 --> 00:05:46,979
what is the group key the group key is

144
00:05:46,979 --> 00:05:49,139
basically a symmetric key that every

145
00:05:49,139 --> 00:05:51,120
client in the network knows and it is

146
00:05:51,120 --> 00:05:52,919
used to encrypt broadcast on multi-cost

147
00:05:52,919 --> 00:05:55,259
traffic and for some reasons these

148
00:05:55,259 --> 00:05:57,600
devices end up using that key

149
00:05:57,600 --> 00:06:00,539
but in a network like either ROM or the

150
00:06:00,539 --> 00:06:02,220
network you're connected to right now

151
00:06:02,220 --> 00:06:04,620
everyone knows the group key basically a

152
00:06:04,620 --> 00:06:06,479
malicious Insider can then use that

153
00:06:06,479 --> 00:06:09,840
knowledge to decrypt these leaked frames

154
00:06:09,840 --> 00:06:11,880
we also investigated other operating

155
00:06:11,880 --> 00:06:14,520
systems like Linux netbsd aren't open

156
00:06:14,520 --> 00:06:17,460
source otheros firmware aren't we

157
00:06:17,460 --> 00:06:19,560
discovered not necessarily exactly the

158
00:06:19,560 --> 00:06:21,660
same attack but variance of this

159
00:06:21,660 --> 00:06:24,060
vulnerability

160
00:06:24,060 --> 00:06:25,979
now what is the root cause here in our

161
00:06:25,979 --> 00:06:28,560
opinion with the crook attack they

162
00:06:28,560 --> 00:06:30,240
claimed okay this was an implementation

163
00:06:30,240 --> 00:06:33,419
flow but in our opinion because we saw

164
00:06:33,419 --> 00:06:35,520
many implementations that are vulnerable

165
00:06:35,520 --> 00:06:37,740
I think we can make the argument that

166
00:06:37,740 --> 00:06:39,539
was actually the standard that wasn't

167
00:06:39,539 --> 00:06:41,940
explicit enough and how to manage

168
00:06:41,940 --> 00:06:44,340
buffered frames

169
00:06:44,340 --> 00:06:46,020
for instance the standard could have

170
00:06:46,020 --> 00:06:48,960
said if a key changes or is removed then

171
00:06:48,960 --> 00:06:51,240
you should drop the buffered frames that

172
00:06:51,240 --> 00:06:55,259
uh were stored in plain text

173
00:06:55,259 --> 00:06:57,780
I think a more General lesson here

174
00:06:57,780 --> 00:07:01,259
that's also learn is that in the case of

175
00:07:01,259 --> 00:07:03,780
Wi-Fi it would be interesting to include

176
00:07:03,780 --> 00:07:05,940
this transmit queue so the buffered

177
00:07:05,940 --> 00:07:08,940
frames and formal models of Wi-Fi

178
00:07:08,940 --> 00:07:10,319
and this is a bit different from

179
00:07:10,319 --> 00:07:12,479
protocols like TLS because with TLS

180
00:07:12,479 --> 00:07:14,819
frames are immediately encrypted but

181
00:07:14,819 --> 00:07:16,680
with Wi-Fi they are first buffered in

182
00:07:16,680 --> 00:07:18,180
plain text

183
00:07:18,180 --> 00:07:19,979
now quite interestingly there is

184
00:07:19,979 --> 00:07:22,560
actually some previous works on formally

185
00:07:22,560 --> 00:07:25,979
modeling WPA2 where they indeed included

186
00:07:25,979 --> 00:07:28,380
this transmit queue in the model but

187
00:07:28,380 --> 00:07:31,139
they did not yet discover uh modeled key

188
00:07:31,139 --> 00:07:33,120
deletion so I think they got really

189
00:07:33,120 --> 00:07:36,000
close to discovering this attack so yeah

190
00:07:36,000 --> 00:07:37,620
it's a very interesting direction that

191
00:07:37,620 --> 00:07:40,520
they explored

192
00:07:40,560 --> 00:07:42,720
so that's the first attack the second

193
00:07:42,720 --> 00:07:45,360
attack that we discovered is a technique

194
00:07:45,360 --> 00:07:50,340
that can bypass Wi-Fi client isolation

195
00:07:50,340 --> 00:07:52,800
now let me Perhaps Perhaps first give a

196
00:07:52,800 --> 00:07:54,539
quick introduction to Wi-Fi client

197
00:07:54,539 --> 00:07:55,860
isolation

198
00:07:55,860 --> 00:07:58,319
what is client isolation well simply put

199
00:07:58,319 --> 00:08:01,199
if you're in a network where users

200
00:08:01,199 --> 00:08:03,660
cannot trust each other client isolation

201
00:08:03,660 --> 00:08:06,300
prevents two devices from communicating

202
00:08:06,300 --> 00:08:08,699
with each other and Hench also attacking

203
00:08:08,699 --> 00:08:09,780
each other

204
00:08:09,780 --> 00:08:12,740
this is for example used in say company

205
00:08:12,740 --> 00:08:16,620
networks to prevent uh a rogue employee

206
00:08:16,620 --> 00:08:19,440
or perhaps a compromised employee from

207
00:08:19,440 --> 00:08:21,660
then attacking other devices in the

208
00:08:21,660 --> 00:08:22,680
network

209
00:08:22,680 --> 00:08:25,740
is also used by certain hotspots that

210
00:08:25,740 --> 00:08:27,599
require Authentication

211
00:08:27,599 --> 00:08:29,340
and I think one example that we're all

212
00:08:29,340 --> 00:08:31,800
familiar with is either room using

213
00:08:31,800 --> 00:08:34,559
either room anyone can connect to your

214
00:08:34,559 --> 00:08:36,299
University network but you may not

215
00:08:36,299 --> 00:08:39,059
necessarily trust all your visitors

216
00:08:39,059 --> 00:08:41,339
so in that case Wi-Fi client isolation

217
00:08:41,339 --> 00:08:44,700
is definitely useful

218
00:08:44,700 --> 00:08:47,100
now what is interesting here about is

219
00:08:47,100 --> 00:08:49,500
the tech model is that in this case the

220
00:08:49,500 --> 00:08:51,480
adversary can connect to the same

221
00:08:51,480 --> 00:08:53,940
network that you are part of

222
00:08:53,940 --> 00:08:56,399
and this enables a very interesting

223
00:08:56,399 --> 00:08:58,740
attack where we can again cause the

224
00:08:58,740 --> 00:09:01,200
access point to send frames under what

225
00:09:01,200 --> 00:09:04,920
we call a different security context

226
00:09:04,920 --> 00:09:07,320
so how does that attack work

227
00:09:07,320 --> 00:09:09,720
well let's say we again have an access

228
00:09:09,720 --> 00:09:12,060
point that is vulnerable here so an

229
00:09:12,060 --> 00:09:14,519
access point here on the right we assume

230
00:09:14,519 --> 00:09:16,560
that the client is now connected to the

231
00:09:16,560 --> 00:09:17,880
access point

232
00:09:17,880 --> 00:09:20,580
and at some point the client will send a

233
00:09:20,580 --> 00:09:24,060
DNS or HTTP request to some server on

234
00:09:24,060 --> 00:09:26,300
the internet

235
00:09:26,519 --> 00:09:28,200
and

236
00:09:28,200 --> 00:09:30,300
okay the network the router of the

237
00:09:30,300 --> 00:09:32,100
network will then forward this request

238
00:09:32,100 --> 00:09:34,140
to the server on the internet

239
00:09:34,140 --> 00:09:36,420
now before the server of the internet

240
00:09:36,420 --> 00:09:38,940
had a chance to reply or at least before

241
00:09:38,940 --> 00:09:41,940
this reply arrived back at the Wi-Fi

242
00:09:41,940 --> 00:09:44,519
network we are going to perform an

243
00:09:44,519 --> 00:09:45,420
attack

244
00:09:45,420 --> 00:09:48,480
on what is the attack well conceptually

245
00:09:48,480 --> 00:09:50,459
the attack is actually fairly

246
00:09:50,459 --> 00:09:52,080
straightforward

247
00:09:52,080 --> 00:09:54,839
we're just going to spoof the client Mac

248
00:09:54,839 --> 00:09:57,959
address as an attacker and then we as an

249
00:09:57,959 --> 00:10:00,000
attacker are going to connect to the

250
00:10:00,000 --> 00:10:02,760
network using our own credentials

251
00:10:02,760 --> 00:10:05,040
and remember the adversary here is a

252
00:10:05,040 --> 00:10:06,839
malicious Insider so they have their own

253
00:10:06,839 --> 00:10:10,399
credentials to connect to the network

254
00:10:10,440 --> 00:10:12,360
now something quite interesting happens

255
00:10:12,360 --> 00:10:14,940
because when this line is connecting to

256
00:10:14,940 --> 00:10:17,220
the access point it will negotiate new

257
00:10:17,220 --> 00:10:20,519
session key and this session key will be

258
00:10:20,519 --> 00:10:22,860
Associated to the MAC address of the

259
00:10:22,860 --> 00:10:24,060
attacker

260
00:10:24,060 --> 00:10:25,800
and in this case that means it's also

261
00:10:25,800 --> 00:10:28,019
Associated to the MAC address of the

262
00:10:28,019 --> 00:10:28,860
victim

263
00:10:28,860 --> 00:10:31,620
so basically we are overriding the key

264
00:10:31,620 --> 00:10:35,279
that is associated with the victim

265
00:10:35,279 --> 00:10:38,399
so what now happens when this server on

266
00:10:38,399 --> 00:10:40,500
the on the internet finally replies to

267
00:10:40,500 --> 00:10:43,320
our DNS or https request

268
00:10:43,320 --> 00:10:45,779
well the router will receive this

269
00:10:45,779 --> 00:10:48,300
incoming packet from the internet it

270
00:10:48,300 --> 00:10:50,880
will know oh I have to send this to the

271
00:10:50,880 --> 00:10:53,640
local IP address of the client

272
00:10:53,640 --> 00:10:55,980
it will use its cache to look up the MAC

273
00:10:55,980 --> 00:10:58,079
address Associated to the IP address of

274
00:10:58,079 --> 00:11:00,360
the client on it will then realize okay

275
00:11:00,360 --> 00:11:03,360
I have to forward it this Frame to the

276
00:11:03,360 --> 00:11:05,760
victim's Mac address

277
00:11:05,760 --> 00:11:07,320
however

278
00:11:07,320 --> 00:11:09,420
the key Associated to the victim's Mac

279
00:11:09,420 --> 00:11:11,279
address now corresponds to the key of

280
00:11:11,279 --> 00:11:12,360
the attacker

281
00:11:12,360 --> 00:11:14,459
that basically means the response is now

282
00:11:14,459 --> 00:11:16,440
effectively sent to this malicious

283
00:11:16,440 --> 00:11:20,160
Insider to the attacker so the DNS can

284
00:11:20,160 --> 00:11:21,839
receive the response

285
00:11:21,839 --> 00:11:24,120
now of course here this response can be

286
00:11:24,120 --> 00:11:26,720
encrypted for example it can be an https

287
00:11:26,720 --> 00:11:29,160
response like we saw in the previous

288
00:11:29,160 --> 00:11:31,079
talk that would still leak the IP

289
00:11:31,079 --> 00:11:32,760
address that someone is visiting to

290
00:11:32,760 --> 00:11:35,279
which is still uh can be considered a

291
00:11:35,279 --> 00:11:38,480
privacy issue

292
00:11:38,820 --> 00:11:39,899
so

293
00:11:39,899 --> 00:11:42,660
one remark here is that the attacker

294
00:11:42,660 --> 00:11:44,579
here needs to be fast enough to

295
00:11:44,579 --> 00:11:46,800
reconnect to the access point it needs

296
00:11:46,800 --> 00:11:48,480
to be able to reconnect before this

297
00:11:48,480 --> 00:11:51,240
reply is received I'll come I'll come

298
00:11:51,240 --> 00:11:55,079
back to that in a bit

299
00:11:55,079 --> 00:11:57,899
now we tested several professional on

300
00:11:57,899 --> 00:12:00,420
home access points and all of them were

301
00:12:00,420 --> 00:12:02,700
vulnerable I think we tested about 10 in

302
00:12:02,700 --> 00:12:05,160
total on this really indicates that this

303
00:12:05,160 --> 00:12:07,680
is a design flaw in Wi-Fi client

304
00:12:07,680 --> 00:12:10,320
isolation

305
00:12:10,320 --> 00:12:13,860
and as I mentioned one obstacle is that

306
00:12:13,860 --> 00:12:16,620
we as an attacker have to be quite fast

307
00:12:16,620 --> 00:12:19,019
to reconnect to the network otherwise

308
00:12:19,019 --> 00:12:20,940
the attack will fail

309
00:12:20,940 --> 00:12:23,279
and we have a technique in the paper

310
00:12:23,279 --> 00:12:25,560
that allows us to reconnect to a Wi-Fi

311
00:12:25,560 --> 00:12:28,200
network rather quickly

312
00:12:28,200 --> 00:12:30,300
for the details I will refer you to the

313
00:12:30,300 --> 00:12:33,300
paper but basically in the good case we

314
00:12:33,300 --> 00:12:36,839
can connect in about 12 milliseconds

315
00:12:36,839 --> 00:12:39,180
if we now compare that to the average

316
00:12:39,180 --> 00:12:41,339
round trip time of a packet on the

317
00:12:41,339 --> 00:12:43,920
internet based on statistics from of

318
00:12:43,920 --> 00:12:46,019
Verizon we can see that the average

319
00:12:46,019 --> 00:12:48,120
round trip time of a transatlantic

320
00:12:48,120 --> 00:12:50,339
connection would be 70 milliseconds

321
00:12:50,339 --> 00:12:53,279
aren't within Europe on average it

322
00:12:53,279 --> 00:12:55,260
depends of course on the details it's

323
00:12:55,260 --> 00:12:58,139
around 13 milliseconds

324
00:12:58,139 --> 00:13:00,720
that means that even if you the victim

325
00:13:00,720 --> 00:13:03,420
is communicating with a server in the

326
00:13:03,420 --> 00:13:04,740
same continent

327
00:13:04,740 --> 00:13:07,380
we are barely fast enough to then

328
00:13:07,380 --> 00:13:09,720
intercept that reply but we are fast

329
00:13:09,720 --> 00:13:10,680
enough

330
00:13:10,680 --> 00:13:12,959
in case we are too slow we can just try

331
00:13:12,959 --> 00:13:15,660
to perform the attack again

332
00:13:15,660 --> 00:13:17,519
now this is the case if you're trying to

333
00:13:17,519 --> 00:13:20,940
intercept UDP responses if you're trying

334
00:13:20,940 --> 00:13:23,100
to perform this attack to intercept TCP

335
00:13:23,100 --> 00:13:25,260
responses then you actually don't have

336
00:13:25,260 --> 00:13:27,899
to be that fast because the server will

337
00:13:27,899 --> 00:13:30,180
just re-transmit these packets if they

338
00:13:30,180 --> 00:13:33,920
are not explicitly acknowledged

339
00:13:34,560 --> 00:13:37,740
now let's take a step back here

340
00:13:37,740 --> 00:13:40,440
look at the root cause of this

341
00:13:40,440 --> 00:13:42,720
vulnerability

342
00:13:42,720 --> 00:13:45,180
basically what happened here is that the

343
00:13:45,180 --> 00:13:47,700
client identity is not securely

344
00:13:47,700 --> 00:13:50,040
authenticated across the whole network

345
00:13:50,040 --> 00:13:51,899
stack

346
00:13:51,899 --> 00:13:54,720
basically with Wi-Fi security we have

347
00:13:54,720 --> 00:13:56,579
the identity of the user which for

348
00:13:56,579 --> 00:14:00,000
example can be an 802.1x identity in

349
00:14:00,000 --> 00:14:02,040
other words that can be your username or

350
00:14:02,040 --> 00:14:04,560
your client certificate that you use to

351
00:14:04,560 --> 00:14:06,180
authenticate

352
00:14:06,180 --> 00:14:08,279
but once you're authenticated this

353
00:14:08,279 --> 00:14:10,860
identity is no longer used because then

354
00:14:10,860 --> 00:14:13,139
all packets are routed based on the IP

355
00:14:13,139 --> 00:14:15,839
on Mac address that is associated to

356
00:14:15,839 --> 00:14:18,120
your client and there is no strong

357
00:14:18,120 --> 00:14:21,240
connection between these two or between

358
00:14:21,240 --> 00:14:23,459
all these identities

359
00:14:23,459 --> 00:14:26,160
and that basically means that malicious

360
00:14:26,160 --> 00:14:28,560
Insider can connect to the same network

361
00:14:28,560 --> 00:14:30,959
that you were connected to and then

362
00:14:30,959 --> 00:14:34,800
steal one of these identities

363
00:14:34,800 --> 00:14:38,220
another I think interesting remark

364
00:14:38,220 --> 00:14:39,839
on perhaps one reason why this

365
00:14:39,839 --> 00:14:42,660
vulnerability was only discovered now

366
00:14:42,660 --> 00:14:46,019
is that client isolation was in a sense

367
00:14:46,019 --> 00:14:49,680
bolted on to the Wi-Fi protocol by

368
00:14:49,680 --> 00:14:50,940
vendors

369
00:14:50,940 --> 00:14:53,220
in particular what I mean there is that

370
00:14:53,220 --> 00:14:55,399
it's not part of the official

371
00:14:55,399 --> 00:15:00,060
IEEE 802.11 standard and this probably

372
00:15:00,060 --> 00:15:03,660
meant that fewer researchers

373
00:15:03,660 --> 00:15:05,639
investigated the actual security

374
00:15:05,639 --> 00:15:09,660
guarantees of Wi-Fi client isolation

375
00:15:09,660 --> 00:15:11,820
however this is used a lot in public

376
00:15:11,820 --> 00:15:15,660
hotspots to provide extra security under

377
00:15:15,660 --> 00:15:17,760
this also used even on home networks to

378
00:15:17,760 --> 00:15:20,519
isolate for example insecure iot devices

379
00:15:20,519 --> 00:15:26,180
from important components of the network

380
00:15:27,420 --> 00:15:30,660
now the question is how can we fix this

381
00:15:30,660 --> 00:15:31,800
well

382
00:15:31,800 --> 00:15:34,680
one defense would be to disallow

383
00:15:34,680 --> 00:15:37,160
recently used Mac addresses

384
00:15:37,160 --> 00:15:41,160
unless certain conditions are met

385
00:15:41,160 --> 00:15:43,320
the first condition could be to disallow

386
00:15:43,320 --> 00:15:44,940
a recently used Mac address from

387
00:15:44,940 --> 00:15:46,920
connecting until a certain amount of

388
00:15:46,920 --> 00:15:49,079
time has passed and the Assumption here

389
00:15:49,079 --> 00:15:51,360
is that after this time there will be no

390
00:15:51,360 --> 00:15:53,519
more incoming data for this particular

391
00:15:53,519 --> 00:15:55,440
client

392
00:15:55,440 --> 00:15:57,660
however you can never really be sure how

393
00:15:57,660 --> 00:15:59,820
long you have to wait so this is not

394
00:15:59,820 --> 00:16:02,100
really a complete defense it's just a

395
00:16:02,100 --> 00:16:04,639
mitigation

396
00:16:05,339 --> 00:16:07,500
another possible defense is to

397
00:16:07,500 --> 00:16:09,779
immediately allow a client to reconnect

398
00:16:09,779 --> 00:16:12,480
as long as you are sure it's the same

399
00:16:12,480 --> 00:16:14,760
user as before

400
00:16:14,760 --> 00:16:17,160
for example if a

401
00:16:17,160 --> 00:16:22,320
Mac address is uh reconnecting and you

402
00:16:22,320 --> 00:16:24,540
can then see oh it's now authenticating

403
00:16:24,540 --> 00:16:26,579
using the same username or client

404
00:16:26,579 --> 00:16:27,720
certificate

405
00:16:27,720 --> 00:16:30,480
or the client is using cached Keys then

406
00:16:30,480 --> 00:16:33,540
you are absolutely sure it's the same uh

407
00:16:33,540 --> 00:16:36,959
actor that is reconnecting and then you

408
00:16:36,959 --> 00:16:40,880
can immediately allow this reconnection

409
00:16:42,240 --> 00:16:45,420
unfortunately this defense is quite hard

410
00:16:45,420 --> 00:16:48,120
to implement because

411
00:16:48,120 --> 00:16:51,120
an access point may not always know the

412
00:16:51,120 --> 00:16:53,880
identity of a client and this is is

413
00:16:53,880 --> 00:16:55,860
especially the case in certain hotspots

414
00:16:55,860 --> 00:16:59,339
certain hotspots do not uh

415
00:16:59,339 --> 00:17:02,040
get to know the real identity of the

416
00:17:02,040 --> 00:17:05,040
client for privacy reasons they are only

417
00:17:05,040 --> 00:17:07,500
given a sort of anonymous chargeable

418
00:17:07,500 --> 00:17:11,819
user identities to track how much uh

419
00:17:11,819 --> 00:17:14,339
data the client is using but they never

420
00:17:14,339 --> 00:17:17,520
really learn the identity so making sure

421
00:17:17,520 --> 00:17:19,799
that the identity of the user stays the

422
00:17:19,799 --> 00:17:21,900
same as a non-trivial problem especially

423
00:17:21,900 --> 00:17:25,919
in complex Wi-Fi networks

424
00:17:25,919 --> 00:17:28,020
so it's currently unclear what vendors

425
00:17:28,020 --> 00:17:29,520
will adopt

426
00:17:29,520 --> 00:17:30,120
um

427
00:17:30,120 --> 00:17:31,980
I would say the takeaway message here

428
00:17:31,980 --> 00:17:34,320
today is you should not rely on Wi-Fi

429
00:17:34,320 --> 00:17:37,380
client isolation for security in the

430
00:17:37,380 --> 00:17:40,440
meantime aren't as an alternative you

431
00:17:40,440 --> 00:17:43,620
can use vlans to properly isolate groups

432
00:17:43,620 --> 00:17:46,080
of users at least because our attack

433
00:17:46,080 --> 00:17:51,139
does not pass bypass VLAN security

434
00:17:51,419 --> 00:17:53,880
so with that I come to the conclusion of

435
00:17:53,880 --> 00:17:55,860
the stat of the stock

436
00:17:55,860 --> 00:17:58,080
in our opinion the Wi-Fi standard is

437
00:17:58,080 --> 00:18:00,179
vague in how to manage the security

438
00:18:00,179 --> 00:18:03,480
context of buffered frames and we have

439
00:18:03,480 --> 00:18:05,760
abused this to leak frames under it

440
00:18:05,760 --> 00:18:07,980
different security context and I think

441
00:18:07,980 --> 00:18:09,720
one lesson here that we can learn is

442
00:18:09,720 --> 00:18:12,840
that it at least seems useful to also

443
00:18:12,840 --> 00:18:15,059
model the transmit queue in formal

444
00:18:15,059 --> 00:18:16,260
models

445
00:18:16,260 --> 00:18:18,360
on the second takeaway message is that

446
00:18:18,360 --> 00:18:21,059
Wi-Fi client isolation should in the

447
00:18:21,059 --> 00:18:23,280
meantime at least not be relied on for

448
00:18:23,280 --> 00:18:25,919
security because it has a design flaw

449
00:18:25,919 --> 00:18:28,559
that seems to be non-trivial to prevent

450
00:18:28,559 --> 00:18:30,480
in practice

451
00:18:30,480 --> 00:18:32,640
so with that I conclude my talk thank

452
00:18:32,640 --> 00:18:34,260
you for your attention on if there are

453
00:18:34,260 --> 00:18:36,720
any questions feel free to ask

454
00:18:36,720 --> 00:18:43,559
[Applause]

455
00:18:43,799 --> 00:18:47,840
thank you Matty are there any questions

456
00:18:49,860 --> 00:18:53,160
in the room or on Zoom

457
00:18:53,160 --> 00:18:55,799
so I have a question matter you say or

458
00:18:55,799 --> 00:18:58,440
this work sort of some of the root cause

459
00:18:58,440 --> 00:19:00,000
or one of them was for the first attack

460
00:19:00,000 --> 00:19:02,580
these standards are vague and not very

461
00:19:02,580 --> 00:19:03,840
well specified

462
00:19:03,840 --> 00:19:05,400
what do you think we should do to

463
00:19:05,400 --> 00:19:08,360
prevent that going forward

464
00:19:09,299 --> 00:19:11,220
that's a good question

465
00:19:11,220 --> 00:19:12,480
um

466
00:19:12,480 --> 00:19:15,960
I would say the initial thing that one

467
00:19:15,960 --> 00:19:18,059
might go to is okay we can try to

468
00:19:18,059 --> 00:19:20,400
formally model it but I think that has

469
00:19:20,400 --> 00:19:22,559
some challenges because you cannot

470
00:19:22,559 --> 00:19:25,260
formally modify model all aspects

471
00:19:25,260 --> 00:19:27,360
because that would take too much time

472
00:19:27,360 --> 00:19:30,059
and effort so I think one open question

473
00:19:30,059 --> 00:19:32,940
is what would be actually useful to

474
00:19:32,940 --> 00:19:35,340
model in our formal models for example

475
00:19:35,340 --> 00:19:37,500
is it useful to model the transmit queue

476
00:19:37,500 --> 00:19:38,760
or not

477
00:19:38,760 --> 00:19:41,760
um I think that's the question so formal

478
00:19:41,760 --> 00:19:44,460
models might help but yeah then you have

479
00:19:44,460 --> 00:19:48,380
a new question what will you then model

480
00:19:49,679 --> 00:19:52,280
any other question

481
00:19:55,030 --> 00:20:03,869
[Applause]

482
00:20:09,020 --> 00:20:12,059
okay so our next talk

483
00:20:12,059 --> 00:20:14,880
is about cellular radio null ciphers and

484
00:20:14,880 --> 00:20:18,059
Android by yomna NASA

485
00:20:18,059 --> 00:20:20,730
please take it away

486
00:20:20,730 --> 00:20:23,859
[Music]

487
00:20:26,220 --> 00:20:29,640
hello uh can you hear me

488
00:20:29,640 --> 00:20:31,200
okay

489
00:20:31,200 --> 00:20:32,940
um hello welcome to my Talk Cellular

490
00:20:32,940 --> 00:20:35,400
radio null Cipher is an Android my name

491
00:20:35,400 --> 00:20:37,620
is yamna I'm an engineer on the Android

492
00:20:37,620 --> 00:20:40,860
connectivity security team

493
00:20:40,860 --> 00:20:43,140
so this talk has three parts how do

494
00:20:43,140 --> 00:20:44,520
cellular networks fail to use

495
00:20:44,520 --> 00:20:46,200
cryptography to protect user

496
00:20:46,200 --> 00:20:48,299
Communications what is Android doing

497
00:20:48,299 --> 00:20:51,660
about it and what kinds of challenges we

498
00:20:51,660 --> 00:20:53,820
faced when doing the Relevant Radio

499
00:20:53,820 --> 00:20:56,240
security improvements

500
00:20:56,240 --> 00:20:59,940
so first let's go over some terminology

501
00:20:59,940 --> 00:21:01,440
um so you all know what cell towers are

502
00:21:01,440 --> 00:21:03,660
people who work on mobile network

503
00:21:03,660 --> 00:21:05,280
adjacent things usually call them base

504
00:21:05,280 --> 00:21:06,960
stations which is how I will be

505
00:21:06,960 --> 00:21:08,280
referring to them throughout this talk

506
00:21:08,280 --> 00:21:10,620
and this talk is primarily concerned

507
00:21:10,620 --> 00:21:13,559
with radio-based attacks so basically

508
00:21:13,559 --> 00:21:16,200
anyone who can set up some radios and

509
00:21:16,200 --> 00:21:17,520
make them look like a cell tower to

510
00:21:17,520 --> 00:21:18,900
trick phones into connecting to them

511
00:21:18,900 --> 00:21:20,760
you've heard of these in the news by

512
00:21:20,760 --> 00:21:23,880
many names such as MC catchers stingrays

513
00:21:23,880 --> 00:21:26,760
cell site simulators Etc I'll mostly be

514
00:21:26,760 --> 00:21:28,440
sticking to calling them fake base

515
00:21:28,440 --> 00:21:31,559
stations or saying the attacker

516
00:21:31,559 --> 00:21:32,580
um and finally there are network

517
00:21:32,580 --> 00:21:36,480
Generations such as 2G 3G Etc the most

518
00:21:36,480 --> 00:21:38,880
popular 2G protocol is gsm and I'll be

519
00:21:38,880 --> 00:21:41,640
using 2G and GSM interchangeably I'll

520
00:21:41,640 --> 00:21:44,460
also be using 4G and LTE interchangeably

521
00:21:44,460 --> 00:21:46,440
and the main attack scenarios I'll be

522
00:21:46,440 --> 00:21:48,659
covering are applicable across

523
00:21:48,659 --> 00:21:53,120
everything from 2G to 5G

524
00:21:54,900 --> 00:21:57,539
so usually in these types of talks there

525
00:21:57,539 --> 00:21:59,220
is a diagram of a phone connecting to a

526
00:21:59,220 --> 00:22:01,200
cell tower but to be a bit more accurate

527
00:22:01,200 --> 00:22:03,240
the physical component of the phone

528
00:22:03,240 --> 00:22:04,980
which handles connecting to cell towers

529
00:22:04,980 --> 00:22:07,140
and facilitating radio communications is

530
00:22:07,140 --> 00:22:09,480
called a modem also known as the radio

531
00:22:09,480 --> 00:22:11,460
the base band or the communications

532
00:22:11,460 --> 00:22:13,260
processor all these terms are

533
00:22:13,260 --> 00:22:15,600
interchangeable modems are produced by

534
00:22:15,600 --> 00:22:17,460
Hardware vendors such as Qualcomm

535
00:22:17,460 --> 00:22:21,360
mediatek Samsung Intel Etc please note

536
00:22:21,360 --> 00:22:23,460
Android is not a modem and Android does

537
00:22:23,460 --> 00:22:25,320
not run on the modem they are separate

538
00:22:25,320 --> 00:22:26,780
components on the phone

539
00:22:26,780 --> 00:22:29,039
so modems are also specifically

540
00:22:29,039 --> 00:22:31,200
responsible for facilitating the

541
00:22:31,200 --> 00:22:32,940
encryption and integrity protection

542
00:22:32,940 --> 00:22:35,820
between a phone and a cell tower this is

543
00:22:35,820 --> 00:22:38,039
what protects your voice calls SMS and

544
00:22:38,039 --> 00:22:39,780
other mobile data from anyone who may be

545
00:22:39,780 --> 00:22:43,520
sniffing radio traffic nearby

546
00:22:43,940 --> 00:22:46,500
so let's say you turn your phone on and

547
00:22:46,500 --> 00:22:48,179
it starts looking for an LTE network to

548
00:22:48,179 --> 00:22:50,220
connect to after identifying the base

549
00:22:50,220 --> 00:22:52,080
station it wants to use it goes through

550
00:22:52,080 --> 00:22:53,220
What's called the initial attach

551
00:22:53,220 --> 00:22:54,480
procedure

552
00:22:54,480 --> 00:22:56,340
so in these connection diagrams it says

553
00:22:56,340 --> 00:22:58,320
UE on the left that refers to user

554
00:22:58,320 --> 00:23:00,960
equipment which is like a catch-all term

555
00:23:00,960 --> 00:23:02,940
for the phone and the modem and it says

556
00:23:02,940 --> 00:23:05,159
mme on the right and that's just the

557
00:23:05,159 --> 00:23:06,840
relevant part of the code Network that

558
00:23:06,840 --> 00:23:08,880
the base station is like passing all the

559
00:23:08,880 --> 00:23:10,980
information from the phone to and from

560
00:23:10,980 --> 00:23:12,960
so Step One is the initial attach

561
00:23:12,960 --> 00:23:14,880
procedure the modem sends what's called

562
00:23:14,880 --> 00:23:16,559
an attached request to the network it

563
00:23:16,559 --> 00:23:18,600
sends the MC which is a sensitive value

564
00:23:18,600 --> 00:23:20,580
used to identify the user to the network

565
00:23:20,580 --> 00:23:23,220
and it also sets sends the set of

566
00:23:23,220 --> 00:23:25,080
security capabilities which includes

567
00:23:25,080 --> 00:23:28,340
what ciphers the phone Sports

568
00:23:28,679 --> 00:23:30,659
so step two the network responds with

569
00:23:30,659 --> 00:23:32,100
the authentication requests and some

570
00:23:32,100 --> 00:23:33,419
parameters

571
00:23:33,419 --> 00:23:35,760
step three the modem does some

572
00:23:35,760 --> 00:23:37,740
computation and sends the authentication

573
00:23:37,740 --> 00:23:39,780
response after this step Mutual

574
00:23:39,780 --> 00:23:42,360
authentication is complete

575
00:23:42,360 --> 00:23:45,600
so step four the network responds with

576
00:23:45,600 --> 00:23:47,820
the security mode command telling the

577
00:23:47,820 --> 00:23:49,200
modem the full list of security

578
00:23:49,200 --> 00:23:51,240
algorithms it supports and It ultimately

579
00:23:51,240 --> 00:23:53,460
selects one Integrity algorithm and one

580
00:23:53,460 --> 00:23:55,080
encryption algorithm that the modem is

581
00:23:55,080 --> 00:23:57,140
instructed to use

582
00:23:57,140 --> 00:24:00,419
then in step five the modem confirms the

583
00:24:00,419 --> 00:24:02,400
selection to the network

584
00:24:02,400 --> 00:24:04,620
and then step six and seven it's

585
00:24:04,620 --> 00:24:06,179
basically done the phone is assigned an

586
00:24:06,179 --> 00:24:08,820
IP address and the user can go online

587
00:24:08,820 --> 00:24:10,020
anyway this is a bit of an

588
00:24:10,020 --> 00:24:12,059
oversimplification as modems can have

589
00:24:12,059 --> 00:24:14,039
simultaneous connections to different

590
00:24:14,039 --> 00:24:16,020
cell towers with each using different

591
00:24:16,020 --> 00:24:17,700
encryption methods for different types

592
00:24:17,700 --> 00:24:19,679
of traffic but this is how it works in

593
00:24:19,679 --> 00:24:22,220
the most basic case

594
00:24:22,220 --> 00:24:25,260
so here's a chart of commonly used

595
00:24:25,260 --> 00:24:27,179
standardized cryptographic algorithms

596
00:24:27,179 --> 00:24:28,860
for use in cellular

597
00:24:28,860 --> 00:24:30,780
historically there have been quite a few

598
00:24:30,780 --> 00:24:32,880
more than these which have mostly been

599
00:24:32,880 --> 00:24:35,760
deprecated this is primarily from Modern

600
00:24:35,760 --> 00:24:38,880
phones if an algorithm has an i in it

601
00:24:38,880 --> 00:24:40,140
that just means it's for integrity

602
00:24:40,140 --> 00:24:42,179
protection it has an e that means it's

603
00:24:42,179 --> 00:24:44,159
for encryption if there's a zero in the

604
00:24:44,159 --> 00:24:45,600
name that means it's the null version

605
00:24:45,600 --> 00:24:47,100
but this chart on the left didn't

606
00:24:47,100 --> 00:24:48,720
include those so I put them in the table

607
00:24:48,720 --> 00:24:51,740
on the right for you to see

608
00:24:52,020 --> 00:24:55,380
you may even recognize the 2G GPRS

609
00:24:55,380 --> 00:24:57,960
ciphers from the news last year when a

610
00:24:57,960 --> 00:25:00,720
paper was published about gea1 and gea2

611
00:25:00,720 --> 00:25:02,340
being broken as well as the high

612
00:25:02,340 --> 00:25:03,720
likelihood that they were backdoored

613
00:25:03,720 --> 00:25:05,640
during their initial design

614
00:25:05,640 --> 00:25:09,299
anyway what's even worse than backdoored

615
00:25:09,299 --> 00:25:12,480
encryption no encryption

616
00:25:12,480 --> 00:25:14,159
it turns out that a significant number

617
00:25:14,159 --> 00:25:16,860
of carriers just don't use encryption or

618
00:25:16,860 --> 00:25:18,539
Integrity protection for parts of their

619
00:25:18,539 --> 00:25:20,940
networks across all Network types or in

620
00:25:20,940 --> 00:25:22,500
Generations even though they're supposed

621
00:25:22,500 --> 00:25:24,900
to Integrity protection is marked as

622
00:25:24,900 --> 00:25:26,159
required

623
00:25:26,159 --> 00:25:27,840
in the standards and encryption is

624
00:25:27,840 --> 00:25:29,340
heavily recommended or required

625
00:25:29,340 --> 00:25:31,679
depending on where you look as far as I

626
00:25:31,679 --> 00:25:33,900
can tell the most common reason for this

627
00:25:33,900 --> 00:25:35,520
is that Network equipment is just

628
00:25:35,520 --> 00:25:37,740
misconfigured many carriers often

629
00:25:37,740 --> 00:25:39,240
purchase Network equipment from

630
00:25:39,240 --> 00:25:41,400
third-party vendors and it seems they

631
00:25:41,400 --> 00:25:43,380
end up having trouble maintaining and

632
00:25:43,380 --> 00:25:45,179
updating the configurations on them

633
00:25:45,179 --> 00:25:47,700
across the large geographic regions in

634
00:25:47,700 --> 00:25:49,559
which they operate

635
00:25:49,559 --> 00:25:51,000
it's also difficult for security

636
00:25:51,000 --> 00:25:53,159
researchers to audit carriers use of

637
00:25:53,159 --> 00:25:55,320
encryption as it requires probing as

638
00:25:55,320 --> 00:25:57,480
their cell towers over radios which is

639
00:25:57,480 --> 00:25:59,159
disallowed in many countries as you

640
00:25:59,159 --> 00:26:01,320
cannot transmit on radio bands reserved

641
00:26:01,320 --> 00:26:03,360
for carriers as a result of this and

642
00:26:03,360 --> 00:26:05,400
some other factors carriers tend to have

643
00:26:05,400 --> 00:26:08,720
lower standards for radio security

644
00:26:10,500 --> 00:26:12,179
so in 2019 a group of researchers

645
00:26:12,179 --> 00:26:14,220
obtained permission to perform live

646
00:26:14,220 --> 00:26:16,200
testing of Lte security features on some

647
00:26:16,200 --> 00:26:18,360
European carrier networks they pointed

648
00:26:18,360 --> 00:26:20,120
out that if a carrier Network accepts

649
00:26:20,120 --> 00:26:22,440
null integrity and null encryption for a

650
00:26:22,440 --> 00:26:24,120
normal for a normal Cellular Connection

651
00:26:24,120 --> 00:26:25,620
then it renders the mutual

652
00:26:25,620 --> 00:26:27,480
authentication between phones and Towers

653
00:26:27,480 --> 00:26:31,220
susceptible to impressed Nation attacks

654
00:26:31,220 --> 00:26:34,020
there are a few legit use cases for not

655
00:26:34,020 --> 00:26:35,460
using any cryptography during normal

656
00:26:35,460 --> 00:26:37,919
operation the first is when carriers are

657
00:26:37,919 --> 00:26:39,320
diagnosing problems with their Network

658
00:26:39,320 --> 00:26:41,700
especially during major changes like

659
00:26:41,700 --> 00:26:43,320
when 5G was initially being deployed

660
00:26:43,320 --> 00:26:45,000
they'll need to be able to capture radio

661
00:26:45,000 --> 00:26:47,520
packets and inspect them

662
00:26:47,520 --> 00:26:49,799
and tools like wire Wireshark to make

663
00:26:49,799 --> 00:26:51,539
sure everything is fine for much of the

664
00:26:51,539 --> 00:26:53,640
data they'll capture it needs to be in

665
00:26:53,640 --> 00:26:55,799
plain text to be usable

666
00:26:55,799 --> 00:26:57,840
the next is that users need to be able

667
00:26:57,840 --> 00:26:59,880
to place emergency calls regardless of

668
00:26:59,880 --> 00:27:01,980
whether they have a SIM card SIM cards

669
00:27:01,980 --> 00:27:03,720
contain the key material required for

670
00:27:03,720 --> 00:27:06,000
setting up authentication encryption and

671
00:27:06,000 --> 00:27:07,860
integrity protection and all of that can

672
00:27:07,860 --> 00:27:09,539
be skipped when trying to set up an

673
00:27:09,539 --> 00:27:10,980
emergency call

674
00:27:10,980 --> 00:27:12,659
and finally historically it's been

675
00:27:12,659 --> 00:27:14,940
considered a best practice to always

676
00:27:14,940 --> 00:27:16,679
have a fallback option in case the

677
00:27:16,679 --> 00:27:18,720
carrier deprecates all other encryption

678
00:27:18,720 --> 00:27:20,279
algorithms your phone is programmed to

679
00:27:20,279 --> 00:27:22,860
use this doesn't seem as relevant these

680
00:27:22,860 --> 00:27:24,840
days as it's easy to get a new SIM card

681
00:27:24,840 --> 00:27:27,360
and modems can and are regularly updated

682
00:27:27,360 --> 00:27:30,659
when the phone receives their OS updates

683
00:27:30,659 --> 00:27:32,400
this is one of the many examples of how

684
00:27:32,400 --> 00:27:34,140
connectivity is prioritized over

685
00:27:34,140 --> 00:27:37,820
Security in the cellular world

686
00:27:41,520 --> 00:27:43,860
so really fundamental cellular security

687
00:27:43,860 --> 00:27:45,900
infrastructure should be as secure as

688
00:27:45,900 --> 00:27:47,279
possible

689
00:27:47,279 --> 00:27:48,659
um even if we view parts of it as

690
00:27:48,659 --> 00:27:51,299
outdated many people still rely on voice

691
00:27:51,299 --> 00:27:53,580
calls and SMS not just for communicating

692
00:27:53,580 --> 00:27:55,679
but also for things like sms-based Bank

693
00:27:55,679 --> 00:27:57,960
transfers in developing countries and

694
00:27:57,960 --> 00:27:59,400
SMS and voice calls are not going away

695
00:27:59,400 --> 00:28:01,100
anytime soon

696
00:28:01,100 --> 00:28:03,059
users should have the option to

697
00:28:03,059 --> 00:28:04,620
guarantee that their data isn't being

698
00:28:04,620 --> 00:28:07,020
transmitted in clear text such that

699
00:28:07,020 --> 00:28:09,000
anyone within a several kilometer radius

700
00:28:09,000 --> 00:28:11,700
with a like homemade Radio setup can

701
00:28:11,700 --> 00:28:13,500
intercept and modify them especially

702
00:28:13,500 --> 00:28:14,940
since fake base station attacks are

703
00:28:14,940 --> 00:28:16,740
becoming more and more common

704
00:28:16,740 --> 00:28:19,080
take for example the recent high profile

705
00:28:19,080 --> 00:28:21,720
case from France a few months ago where

706
00:28:21,720 --> 00:28:23,039
someone was caught being paid to drive

707
00:28:23,039 --> 00:28:24,480
around with a fake base station in the

708
00:28:24,480 --> 00:28:27,539
back of their car sending sms spam to

709
00:28:27,539 --> 00:28:29,520
people nearby and in attempts to

710
00:28:29,520 --> 00:28:31,140
compromise Private health insurance data

711
00:28:31,140 --> 00:28:33,059
as part of a scam

712
00:28:33,059 --> 00:28:35,039
the French police didn't realize it was

713
00:28:35,039 --> 00:28:37,200
just a fake base station for spamming

714
00:28:37,200 --> 00:28:38,820
people and they blew it up thinking it

715
00:28:38,820 --> 00:28:41,178
was a bomb

716
00:28:41,820 --> 00:28:43,500
um

717
00:28:43,500 --> 00:28:45,419
so and variations on these types of

718
00:28:45,419 --> 00:28:46,919
spamming attacks have been going on for

719
00:28:46,919 --> 00:28:48,840
nearly a decade in China where they're

720
00:28:48,840 --> 00:28:50,640
also being used to spread malware and

721
00:28:50,640 --> 00:28:51,779
they're only getting easier and cheaper

722
00:28:51,779 --> 00:28:54,179
to pull off

723
00:28:54,179 --> 00:28:57,299
so newly supported in Android 14 which

724
00:28:57,299 --> 00:28:59,100
is slated for release later this year

725
00:28:59,100 --> 00:29:00,960
users will be able to require their

726
00:29:00,960 --> 00:29:02,880
modems only use non-null encryption for

727
00:29:02,880 --> 00:29:05,100
all connection types for calls and SMS

728
00:29:05,100 --> 00:29:06,720
this includes enforcing mandatory

729
00:29:06,720 --> 00:29:09,000
Integrity protection as well for mobile

730
00:29:09,000 --> 00:29:11,220
data however it turns out that only

731
00:29:11,220 --> 00:29:13,500
encryption is usually implemented nobody

732
00:29:13,500 --> 00:29:15,600
really uses Integrity protection due to

733
00:29:15,600 --> 00:29:17,700
historical and performance issues so as

734
00:29:17,700 --> 00:29:19,440
the modems don't support it carrier

735
00:29:19,440 --> 00:29:21,419
equipment doesn't support it we couldn't

736
00:29:21,419 --> 00:29:23,520
really enforce anything about that

737
00:29:23,520 --> 00:29:25,799
around that on this first release

738
00:29:25,799 --> 00:29:27,299
this does mean that if you have the

739
00:29:27,299 --> 00:29:29,700
toggle enabled and you're in an area

740
00:29:29,700 --> 00:29:30,960
where the cell towers have been

741
00:29:30,960 --> 00:29:32,820
misconfigured they don't use proper

742
00:29:32,820 --> 00:29:34,080
encryption you just won't have

743
00:29:34,080 --> 00:29:38,039
connectivity for normal operations

744
00:29:38,039 --> 00:29:40,320
um there is an exception for user

745
00:29:40,320 --> 00:29:42,240
initiated emergency calls though and

746
00:29:42,240 --> 00:29:44,580
more on that in a second also if you

747
00:29:44,580 --> 00:29:48,000
know anything about 2G in GSM there is

748
00:29:48,000 --> 00:29:50,340
no Integrity of protection so for GSM

749
00:29:50,340 --> 00:29:52,260
only encryption is required

750
00:29:52,260 --> 00:29:54,899
anyway you can see a draft of what the

751
00:29:54,899 --> 00:29:57,120
option will look like in settings please

752
00:29:57,120 --> 00:29:59,279
note this is just a draft it's not

753
00:29:59,279 --> 00:30:00,659
necessarily the final text we will be

754
00:30:00,659 --> 00:30:02,100
using

755
00:30:02,100 --> 00:30:04,799
and as you can see in the last line in

756
00:30:04,799 --> 00:30:06,600
the image there's an exception to let

757
00:30:06,600 --> 00:30:09,360
the user know that even if encryption is

758
00:30:09,360 --> 00:30:11,640
required if the if Android or the modem

759
00:30:11,640 --> 00:30:13,440
detect you're making an emergency call

760
00:30:13,440 --> 00:30:15,659
they will always try everything they can

761
00:30:15,659 --> 00:30:17,340
to let the call through including trying

762
00:30:17,340 --> 00:30:19,260
to fall back to insecure configure

763
00:30:19,260 --> 00:30:22,460
Network configurations if necessary

764
00:30:22,460 --> 00:30:25,860
and just to avoid any confusion this is

765
00:30:25,860 --> 00:30:28,440
not related to how data is protected

766
00:30:28,440 --> 00:30:30,779
once it reaches the core Network this is

767
00:30:30,779 --> 00:30:32,940
just over the radio link between the

768
00:30:32,940 --> 00:30:34,919
network and the phone to protect against

769
00:30:34,919 --> 00:30:37,919
radio eavesdropping

770
00:30:37,919 --> 00:30:40,260
anyway while the earliest you could

771
00:30:40,260 --> 00:30:42,360
possibly see this feature is Android 14.

772
00:30:42,360 --> 00:30:44,399
modem Hardware apis usually don't get

773
00:30:44,399 --> 00:30:46,380
full version updates after they've been

774
00:30:46,380 --> 00:30:47,880
placed in a phone so realistically

775
00:30:47,880 --> 00:30:50,640
phones manufactured prior to 2023 won't

776
00:30:50,640 --> 00:30:51,840
have this feature

777
00:30:51,840 --> 00:30:54,000
additionally we've given modem vendors a

778
00:30:54,000 --> 00:30:55,860
Grace here to implement and test this

779
00:30:55,860 --> 00:30:58,679
before we Mark the apis as required to

780
00:30:58,679 --> 00:31:00,419
implement by Hardware vendors in Android

781
00:31:00,419 --> 00:31:02,520
15 next year

782
00:31:02,520 --> 00:31:04,320
there's a huge potential for

783
00:31:04,320 --> 00:31:06,539
connectivity impact as if part of a

784
00:31:06,539 --> 00:31:08,520
network is misconfigured it's likely to

785
00:31:08,520 --> 00:31:10,320
be a problem across a large geographical

786
00:31:10,320 --> 00:31:12,480
area we also want to be considerate of

787
00:31:12,480 --> 00:31:14,700
implementation complexity

788
00:31:14,700 --> 00:31:16,799
um from the modem Engineers side which

789
00:31:16,799 --> 00:31:19,639
I'll go over in a bit

790
00:31:23,100 --> 00:31:26,159
as a side note a lot of people seem very

791
00:31:26,159 --> 00:31:28,440
confused that phrases like MC catcher

792
00:31:28,440 --> 00:31:30,720
and fake base station attack are really

793
00:31:30,720 --> 00:31:32,820
overloaded and can actually refer to a

794
00:31:32,820 --> 00:31:34,559
wide variety of completely different

795
00:31:34,559 --> 00:31:36,840
types of cellular attacks so I want to

796
00:31:36,840 --> 00:31:38,399
disambiguate and make sure it's clear

797
00:31:38,399 --> 00:31:40,860
that requiring cellular encryption does

798
00:31:40,860 --> 00:31:42,840
not protect you from the often in the

799
00:31:42,840 --> 00:31:45,179
news location tracking attacks

800
00:31:45,179 --> 00:31:47,580
the classic MC catching attack for

801
00:31:47,580 --> 00:31:49,919
tracking a user's location that was

802
00:31:49,919 --> 00:31:52,080
first documented in the 90s takes place

803
00:31:52,080 --> 00:31:53,880
in Step One

804
00:31:53,880 --> 00:31:55,559
before the encryption capability

805
00:31:55,559 --> 00:31:58,140
exchange is fully complete it's the

806
00:31:58,140 --> 00:32:00,360
disclosure of the MC a user's identifier

807
00:32:00,360 --> 00:32:02,940
that the attack relies on and that

808
00:32:02,940 --> 00:32:04,919
attack works because phones will try to

809
00:32:04,919 --> 00:32:07,020
connect to anything that looks like a

810
00:32:07,020 --> 00:32:09,000
cell tower that's advertising itself as

811
00:32:09,000 --> 00:32:10,799
a cell tower and they'll just willingly

812
00:32:10,799 --> 00:32:12,539
disclose their MC before Mutual

813
00:32:12,539 --> 00:32:15,740
authentication is complete

814
00:32:16,559 --> 00:32:18,539
so let's look at some implementation

815
00:32:18,539 --> 00:32:21,419
details this is a high level diagram of

816
00:32:21,419 --> 00:32:22,980
how the Android operating system is

817
00:32:22,980 --> 00:32:25,080
structured at the top is the user facing

818
00:32:25,080 --> 00:32:27,240
stuff and closer to the bottom is where

819
00:32:27,240 --> 00:32:29,159
the lower level Hardware facing code

820
00:32:29,159 --> 00:32:31,799
lives it's at the hall or Hardware

821
00:32:31,799 --> 00:32:34,320
abstraction layer where we specify the

822
00:32:34,320 --> 00:32:36,360
apis between what Android can

823
00:32:36,360 --> 00:32:38,279
communicate to the modem and vice versa

824
00:32:38,279 --> 00:32:40,620
in particular in Android we call the

825
00:32:40,620 --> 00:32:42,539
this particular Hall

826
00:32:42,539 --> 00:32:45,480
iRadio which is short for radio

827
00:32:45,480 --> 00:32:46,620
interface

828
00:32:46,620 --> 00:32:48,899
so after we have an idea for a feature

829
00:32:48,899 --> 00:32:50,580
that should exist in it Android that

830
00:32:50,580 --> 00:32:52,559
requires talking to the modem we come up

831
00:32:52,559 --> 00:32:54,360
with an appropriate API for it and then

832
00:32:54,360 --> 00:32:56,159
we share it with all the major Hardware

833
00:32:56,159 --> 00:32:58,440
vendors to get feedback from them on

834
00:32:58,440 --> 00:33:00,419
like can they support it are they

835
00:33:00,419 --> 00:33:02,220
willing to support it and so on and

836
00:33:02,220 --> 00:33:03,659
there are many different Hardware

837
00:33:03,659 --> 00:33:05,520
vendors we work with and we need to get

838
00:33:05,520 --> 00:33:07,559
input and consensus from all of them

839
00:33:07,559 --> 00:33:09,179
before we before we are able to do

840
00:33:09,179 --> 00:33:11,299
anything

841
00:33:11,360 --> 00:33:14,519
so you can browse the iRadio apis as

842
00:33:14,519 --> 00:33:16,200
they are all open source when the next

843
00:33:16,200 --> 00:33:18,600
AOSP release happens in a few months by

844
00:33:18,600 --> 00:33:20,340
the way AOSP is Android open source

845
00:33:20,340 --> 00:33:22,799
project this is where you'll be able to

846
00:33:22,799 --> 00:33:24,720
see the exact details of the

847
00:33:24,720 --> 00:33:26,640
requirements around disabling null

848
00:33:26,640 --> 00:33:29,039
encryption and null integrity

849
00:33:29,039 --> 00:33:30,960
so I'm not allowed to share unreleased

850
00:33:30,960 --> 00:33:33,539
AOSP code unfortunately so as an example

851
00:33:33,539 --> 00:33:35,399
here's an API we designed a few years

852
00:33:35,399 --> 00:33:37,860
ago to allow users to disable 2G on

853
00:33:37,860 --> 00:33:40,080
their phone because it's so insecure

854
00:33:40,080 --> 00:33:42,000
as you can see it's in the comments

855
00:33:42,000 --> 00:33:44,039
where we mainly specify how modem

856
00:33:44,039 --> 00:33:46,080
Engineers are supposed to implement the

857
00:33:46,080 --> 00:33:48,840
apis on their side this API is a bit

858
00:33:48,840 --> 00:33:50,760
lightweight however they're usually much

859
00:33:50,760 --> 00:33:53,658
more heavily annotated

860
00:33:54,419 --> 00:33:57,539
also I've highlighted the text where we

861
00:33:57,539 --> 00:34:00,059
specified that user user initiated

862
00:34:00,059 --> 00:34:02,779
emergency calls must always be allowed

863
00:34:02,779 --> 00:34:05,820
even if it means reverting to a more

864
00:34:05,820 --> 00:34:07,919
insecure mode the 2G toggle had a

865
00:34:07,919 --> 00:34:10,139
similar exception also please note most

866
00:34:10,139 --> 00:34:11,879
emergency call handling is done by modem

867
00:34:11,879 --> 00:34:13,320
that's right it's done by the modem not

868
00:34:13,320 --> 00:34:15,119
Android

869
00:34:15,119 --> 00:34:19,080
so let's look at some uh let's look at

870
00:34:19,080 --> 00:34:20,460
what makes up some of the implementation

871
00:34:20,460 --> 00:34:23,280
complexity from the modem side going

872
00:34:23,280 --> 00:34:26,219
back to the LTE

873
00:34:26,219 --> 00:34:29,399
initial attached procedure from before

874
00:34:29,399 --> 00:34:31,199
so when you take a look at the details

875
00:34:31,199 --> 00:34:33,179
of cellular standards there's quite a

876
00:34:33,179 --> 00:34:34,560
few ways that they could go about

877
00:34:34,560 --> 00:34:36,480
implementing the requirements we've set

878
00:34:36,480 --> 00:34:38,399
forth around requiring encryption and

879
00:34:38,399 --> 00:34:39,719
integrity protection

880
00:34:39,719 --> 00:34:42,000
so here's one hypothetical example of

881
00:34:42,000 --> 00:34:43,918
what the modified connection flow could

882
00:34:43,918 --> 00:34:45,780
look like if the user has chosen to

883
00:34:45,780 --> 00:34:47,940
require encryption that the network only

884
00:34:47,940 --> 00:34:50,040
supports null encryption

885
00:34:50,040 --> 00:34:52,320
so step one the Moto sends the attached

886
00:34:52,320 --> 00:34:53,879
request to the network they send their

887
00:34:53,879 --> 00:34:56,339
emcee which is their identifier and the

888
00:34:56,339 --> 00:34:58,080
security capabilities which includes

889
00:34:58,080 --> 00:34:59,940
what ciphers they support and in this

890
00:34:59,940 --> 00:35:01,500
case it's the same as a force it still

891
00:35:01,500 --> 00:35:02,700
includes null ciphering and null

892
00:35:02,700 --> 00:35:04,920
Integrity step two the network responds

893
00:35:04,920 --> 00:35:07,500
to the authentication request

894
00:35:07,500 --> 00:35:08,040
um

895
00:35:08,040 --> 00:35:09,780
step three the modem does some

896
00:35:09,780 --> 00:35:11,400
computation and sends the authentication

897
00:35:11,400 --> 00:35:13,140
response up until this point everything

898
00:35:13,140 --> 00:35:17,280
is exactly the same as before step four

899
00:35:17,280 --> 00:35:19,200
authentication is complete the network

900
00:35:19,200 --> 00:35:21,359
responds with the security mode command

901
00:35:21,359 --> 00:35:24,180
telling the modem it only supports null

902
00:35:24,180 --> 00:35:25,920
ciphering and that the modem should

903
00:35:25,920 --> 00:35:28,520
accept this

904
00:35:28,980 --> 00:35:30,359
um and then step five this is where

905
00:35:30,359 --> 00:35:31,800
things get different

906
00:35:31,800 --> 00:35:34,020
instead of accepting the modem sense was

907
00:35:34,020 --> 00:35:35,520
called an attach reject message which

908
00:35:35,520 --> 00:35:36,780
communicates it's ending this connection

909
00:35:36,780 --> 00:35:38,880
attempt then in order to not immediately

910
00:35:38,880 --> 00:35:40,440
retry all this again and end up in a

911
00:35:40,440 --> 00:35:42,180
connection Loop

912
00:35:42,180 --> 00:35:43,680
um it sets a timer for retrying

913
00:35:43,680 --> 00:35:45,540
connecting to that particular Network

914
00:35:45,540 --> 00:35:47,099
after five failed connection attempts

915
00:35:47,099 --> 00:35:49,140
modem places that particular Network on

916
00:35:49,140 --> 00:35:50,400
a ban list and doesn't attempt to

917
00:35:50,400 --> 00:35:51,900
reconnect to it until the phone has

918
00:35:51,900 --> 00:35:53,720
restarted

919
00:35:53,720 --> 00:35:56,160
so that's one hypothetical potential

920
00:35:56,160 --> 00:35:58,560
just to say two minute warning okay so

921
00:35:58,560 --> 00:35:59,820
that's one hypothetical potential

922
00:35:59,820 --> 00:36:02,040
implementation a different one would be

923
00:36:02,040 --> 00:36:04,440
in Step One the modem just drops no

924
00:36:04,440 --> 00:36:06,000
encryption and integrity from its

925
00:36:06,000 --> 00:36:07,800
security capabilities list when it sends

926
00:36:07,800 --> 00:36:09,660
it over to the orally configured Network

927
00:36:09,660 --> 00:36:12,119
and the network is just like sorry I

928
00:36:12,119 --> 00:36:13,440
can't support this don't try again

929
00:36:13,440 --> 00:36:15,660
that's of course an oversimplification

930
00:36:15,660 --> 00:36:18,240
but you get the idea please note we

931
00:36:18,240 --> 00:36:20,160
ultimately do not control what Hardware

932
00:36:20,160 --> 00:36:22,320
vendors Implement these are just two

933
00:36:22,320 --> 00:36:23,820
examples we came up with that we believe

934
00:36:23,820 --> 00:36:25,740
to be spec compliant

935
00:36:25,740 --> 00:36:27,720
ultimately the optimal way to do this

936
00:36:27,720 --> 00:36:29,400
and the pros and cons of different

937
00:36:29,400 --> 00:36:31,560
approaches is an open question so if

938
00:36:31,560 --> 00:36:32,880
anyone would like a free research

939
00:36:32,880 --> 00:36:36,320
project idea here you go

940
00:36:36,599 --> 00:36:38,160
um anyway I've shown just a small part

941
00:36:38,160 --> 00:36:39,300
of what it's like to make a major

942
00:36:39,300 --> 00:36:42,119
connectivity impacting uh radio security

943
00:36:42,119 --> 00:36:44,280
change in a big mobile mobile operating

944
00:36:44,280 --> 00:36:46,020
system but hopefully this was a helpful

945
00:36:46,020 --> 00:36:47,760
primer on how practical radio security

946
00:36:47,760 --> 00:36:50,040
and Android and modems work some

947
00:36:50,040 --> 00:36:51,660
suggested readings if you're interested

948
00:36:51,660 --> 00:36:53,280
in learning more about cellular attacks

949
00:36:53,280 --> 00:36:55,020
I wrote a completely self-contained

950
00:36:55,020 --> 00:36:58,800
technical introduction in 2019 for eff

951
00:36:58,800 --> 00:37:00,000
um yeah and that's all thank you for

952
00:37:00,000 --> 00:37:02,300
listening

953
00:37:09,660 --> 00:37:11,760
thank you yomna um as we are running

954
00:37:11,760 --> 00:37:13,140
tight on time there are no time for

955
00:37:13,140 --> 00:37:15,300
questions so please um speak to you I'm

956
00:37:15,300 --> 00:37:16,920
not offline but can we have the next

957
00:37:16,920 --> 00:37:19,320
speaker please

958
00:37:19,320 --> 00:37:22,140
okay the next talk is about TLS Anvil

959
00:37:22,140 --> 00:37:24,300
this is a test suite for testing TLS

960
00:37:24,300 --> 00:37:26,520
libraries and Marcelo we'll give the

961
00:37:26,520 --> 00:37:28,700
talk

962
00:37:30,780 --> 00:37:32,760
okay uh thank you very much for the

963
00:37:32,760 --> 00:37:34,079
introduction

964
00:37:34,079 --> 00:37:36,420
um I will be presenting results from our

965
00:37:36,420 --> 00:37:39,300
joint work by all University bochum

966
00:37:39,300 --> 00:37:41,520
battleborn University and the Technology

967
00:37:41,520 --> 00:37:43,320
Innovation Institute

968
00:37:43,320 --> 00:37:45,119
as the title already says this

969
00:37:45,119 --> 00:37:47,760
presentation is about TLS and TLS is a

970
00:37:47,760 --> 00:37:49,020
complex protocol

971
00:37:49,020 --> 00:37:51,119
this isn't super obvious at first glance

972
00:37:51,119 --> 00:37:52,500
because there are only four protocol

973
00:37:52,500 --> 00:37:54,300
versions and they have been released

974
00:37:54,300 --> 00:37:57,180
over the course of 20 years but while

975
00:37:57,180 --> 00:37:59,160
these rfcs shown here from the main

976
00:37:59,160 --> 00:38:01,200
protocol specifications they actually

977
00:38:01,200 --> 00:38:03,240
many other rocs that shape the protocol

978
00:38:03,240 --> 00:38:05,640
and its usage over the years

979
00:38:05,640 --> 00:38:08,099
often these RCS introduce new features

980
00:38:08,099 --> 00:38:10,859
to the protocol such as new ciphers but

981
00:38:10,859 --> 00:38:12,599
while doing so they also impose new

982
00:38:12,599 --> 00:38:14,400
restrictions on the implementations and

983
00:38:14,400 --> 00:38:16,619
enforce new requirements implementations

984
00:38:16,619 --> 00:38:18,599
must meet these requirements to ensure

985
00:38:18,599 --> 00:38:21,839
interoperability and security

986
00:38:21,839 --> 00:38:24,000
uh here's an example for a requirement

987
00:38:24,000 --> 00:38:27,180
from the TLs 1.2 RFC and it concerns the

988
00:38:27,180 --> 00:38:29,760
validation of padding for ciphers and

989
00:38:29,760 --> 00:38:31,680
Cipher block chaining mode or CBC mode

990
00:38:31,680 --> 00:38:33,780
and since the receiver must check the

991
00:38:33,780 --> 00:38:35,700
padding I must use the batch record Mac

992
00:38:35,700 --> 00:38:37,980
alert to indicate padding errors

993
00:38:37,980 --> 00:38:39,839
this requirement is actually a security

994
00:38:39,839 --> 00:38:42,240
measure set to avoid padding Oracle

995
00:38:42,240 --> 00:38:44,339
attacks so it's crucial that this

996
00:38:44,339 --> 00:38:46,560
requirement is always met regardless of

997
00:38:46,560 --> 00:38:48,480
the negotiated parameters

998
00:38:48,480 --> 00:38:50,400
so as an example we could establish a

999
00:38:50,400 --> 00:38:51,960
session where we negotiate if you have

1000
00:38:51,960 --> 00:38:54,900
monkey exchange RSA signatures and AES

1001
00:38:54,900 --> 00:38:57,300
as our block Cipher send an invalid

1002
00:38:57,300 --> 00:38:59,880
padding to some TLS Library

1003
00:38:59,880 --> 00:39:02,339
and just observe the response and if the

1004
00:39:02,339 --> 00:39:03,660
library replies with bad record Mac

1005
00:39:03,660 --> 00:39:06,119
alert and terminates the session this is

1006
00:39:06,119 --> 00:39:09,000
exactly what the RFC expects it to do

1007
00:39:09,000 --> 00:39:10,680
now of course we can change parameters

1008
00:39:10,680 --> 00:39:12,660
for example we could negotiate triple

1009
00:39:12,660 --> 00:39:14,579
Dash instead of as send an envelope

1010
00:39:14,579 --> 00:39:16,140
padding and check if the library again

1011
00:39:16,140 --> 00:39:18,420
replies for better record make alert

1012
00:39:18,420 --> 00:39:21,240
and if it does it's great but there may

1013
00:39:21,240 --> 00:39:23,640
be a third set of parameters maybe one

1014
00:39:23,640 --> 00:39:25,859
where we use elliptic curves for the key

1015
00:39:25,859 --> 00:39:27,780
exchange and for the signature algorithm

1016
00:39:27,780 --> 00:39:29,820
where when we send the invalid padding

1017
00:39:29,820 --> 00:39:31,440
the library suddenly replies with a

1018
00:39:31,440 --> 00:39:32,820
different alert something like internal

1019
00:39:32,820 --> 00:39:35,520
error alert maybe and this may lead to a

1020
00:39:35,520 --> 00:39:37,200
padding Oracle attack

1021
00:39:37,200 --> 00:39:39,780
now it may seem unlikely that the

1022
00:39:39,780 --> 00:39:42,420
signature or key exchange algorithm

1023
00:39:42,420 --> 00:39:43,859
um have an effect on this requirement

1024
00:39:43,859 --> 00:39:46,500
because the requirement only concerns uh

1025
00:39:46,500 --> 00:39:48,359
the padding for symmetric encryption

1026
00:39:48,359 --> 00:39:50,040
when you reach the metric encryption you

1027
00:39:50,040 --> 00:39:51,960
already performed the key exchange so it

1028
00:39:51,960 --> 00:39:54,000
really shouldn't make a difference but

1029
00:39:54,000 --> 00:39:55,619
the previous study by Mega that either

1030
00:39:55,619 --> 00:39:58,320
shown that for some TLS libraries it

1031
00:39:58,320 --> 00:40:00,119
actually does make a difference which

1032
00:40:00,119 --> 00:40:02,579
key exchange algorithm or maybe which

1033
00:40:02,579 --> 00:40:05,280
signature algorithm we are using

1034
00:40:05,280 --> 00:40:07,320
um so ideally you want to test if this

1035
00:40:07,320 --> 00:40:09,240
requirement is met for various parameter

1036
00:40:09,240 --> 00:40:10,680
combinations and there are more

1037
00:40:10,680 --> 00:40:12,240
parameters than just the ones shown here

1038
00:40:12,240 --> 00:40:13,680
because all of these are actually

1039
00:40:13,680 --> 00:40:16,079
bundled as a Cypher suite and TLs but

1040
00:40:16,079 --> 00:40:17,280
there are different groups you can use

1041
00:40:17,280 --> 00:40:19,680
for different key exchange and different

1042
00:40:19,680 --> 00:40:21,540
hash algorithms you can use together

1043
00:40:21,540 --> 00:40:24,480
with RSA signatures for example

1044
00:40:24,480 --> 00:40:26,700
unfortunately testing all combinations

1045
00:40:26,700 --> 00:40:28,800
of all parameters quickly leads to

1046
00:40:28,800 --> 00:40:31,320
combinatorial explosion so we need

1047
00:40:31,320 --> 00:40:33,660
techniques that tame the combinatorial

1048
00:40:33,660 --> 00:40:36,480
complexity but also explore parameter

1049
00:40:36,480 --> 00:40:38,520
interactions

1050
00:40:38,520 --> 00:40:40,740
Ty testing is such a technique and it's

1051
00:40:40,740 --> 00:40:42,599
based on the experience that faults are

1052
00:40:42,599 --> 00:40:44,160
usually not the result of an interaction

1053
00:40:44,160 --> 00:40:47,160
of all parameters but only a few of them

1054
00:40:47,160 --> 00:40:48,720
it's consider an example where we have

1055
00:40:48,720 --> 00:40:51,119
three parameters a b and c that each

1056
00:40:51,119 --> 00:40:52,859
have two possible values

1057
00:40:52,859 --> 00:40:55,079
the set of parameters and the values

1058
00:40:55,079 --> 00:40:57,240
also referred to as the input parameter

1059
00:40:57,240 --> 00:40:58,140
model

1060
00:40:58,140 --> 00:41:00,780
now an ideal test would aim to cover all

1061
00:41:00,780 --> 00:41:02,700
combinations which would require these

1062
00:41:02,700 --> 00:41:05,160
eight test inputs overall but what a

1063
00:41:05,160 --> 00:41:06,780
t-way test does it considers

1064
00:41:06,780 --> 00:41:09,060
interactions of up to T parameters so

1065
00:41:09,060 --> 00:41:11,400
for example for T set to 2 the t-way

1066
00:41:11,400 --> 00:41:13,380
test would aim to cover all pairs of A

1067
00:41:13,380 --> 00:41:16,680
and B A and C and B and C which results

1068
00:41:16,680 --> 00:41:19,200
in these 12 TPS overall

1069
00:41:19,200 --> 00:41:21,900
now interestingly we can cover these 12

1070
00:41:21,900 --> 00:41:24,359
T pairs with only four test inputs if we

1071
00:41:24,359 --> 00:41:25,800
choose these test inputs carefully

1072
00:41:25,800 --> 00:41:27,960
because we can choose them in a way that

1073
00:41:27,960 --> 00:41:29,820
basically each test input on the right

1074
00:41:29,820 --> 00:41:32,160
covers three TV pairs on the left so for

1075
00:41:32,160 --> 00:41:33,720
example the first line covers these

1076
00:41:33,720 --> 00:41:36,240
three GPS a third line covers these

1077
00:41:36,240 --> 00:41:38,040
three and it's essentially the same for

1078
00:41:38,040 --> 00:41:39,720
all of these

1079
00:41:39,720 --> 00:41:41,880
so this approach results in a manageable

1080
00:41:41,880 --> 00:41:44,460
number of test inputs and the systematic

1081
00:41:44,460 --> 00:41:46,260
coverage guarantee that is also scalable

1082
00:41:46,260 --> 00:41:48,420
because if the number of parameters in

1083
00:41:48,420 --> 00:41:50,040
our example was higher we could also

1084
00:41:50,040 --> 00:41:52,320
adjust our T value to consider larger

1085
00:41:52,320 --> 00:41:54,240
parameter sets

1086
00:41:54,240 --> 00:41:56,820
now when testing a complex protocol like

1087
00:41:56,820 --> 00:41:59,280
TLS there's another obstacle when using

1088
00:41:59,280 --> 00:42:02,880
t-way testing because in a session there

1089
00:42:02,880 --> 00:42:04,560
are many points where the session could

1090
00:42:04,560 --> 00:42:06,180
just get terminated due to invalid

1091
00:42:06,180 --> 00:42:07,740
parameter choices and specifically

1092
00:42:07,740 --> 00:42:09,300
perimeter combinations

1093
00:42:09,300 --> 00:42:11,700
and this is specifically a problem when

1094
00:42:11,700 --> 00:42:13,260
we want to perform tests at a specific

1095
00:42:13,260 --> 00:42:15,780
point in this session for example we may

1096
00:42:15,780 --> 00:42:17,400
want to test the padding validation once

1097
00:42:17,400 --> 00:42:19,560
the handshake has been completed and we

1098
00:42:19,560 --> 00:42:21,420
want to test if various parameters have

1099
00:42:21,420 --> 00:42:23,220
an effect on the outcome of this test

1100
00:42:23,220 --> 00:42:25,680
but we want to avoid combinations that

1101
00:42:25,680 --> 00:42:27,240
already terminate our session at the

1102
00:42:27,240 --> 00:42:29,160
very start due to invalid combinations

1103
00:42:29,160 --> 00:42:31,560
because these don't contribute anything

1104
00:42:31,560 --> 00:42:33,359
to what we want to test here because we

1105
00:42:33,359 --> 00:42:34,800
never even reached the point where we

1106
00:42:34,800 --> 00:42:37,040
perform the actual test

1107
00:42:37,040 --> 00:42:40,079
so the test inputs we generate with Ty

1108
00:42:40,079 --> 00:42:42,180
testing must be constrained and there

1109
00:42:42,180 --> 00:42:43,920
are basically two important aspects to

1110
00:42:43,920 --> 00:42:46,740
consider here first of all a TLS Library

1111
00:42:46,740 --> 00:42:48,420
isn't forced to implement all features

1112
00:42:48,420 --> 00:42:50,339
of the protocol so for example it may

1113
00:42:50,339 --> 00:42:52,440
support AES but maybe not Triple S and

1114
00:42:52,440 --> 00:42:54,960
it's deprecated or it may support RSA

1115
00:42:54,960 --> 00:42:56,820
certificates but enforce a minimum key

1116
00:42:56,820 --> 00:43:00,240
size so all of these values are valid in

1117
00:43:00,240 --> 00:43:02,579
terms of the protocol specification

1118
00:43:02,579 --> 00:43:04,680
but in the context of a tested Library

1119
00:43:04,680 --> 00:43:06,960
some may be invalid

1120
00:43:06,960 --> 00:43:08,460
another thing we need to consider is

1121
00:43:08,460 --> 00:43:10,500
that we cannot blindly combine all

1122
00:43:10,500 --> 00:43:12,420
parameter values due to restrictions in

1123
00:43:12,420 --> 00:43:13,800
the rocs

1124
00:43:13,800 --> 00:43:16,140
so as an example a server typically has

1125
00:43:16,140 --> 00:43:18,480
to select a cipher Suite a certificate

1126
00:43:18,480 --> 00:43:20,640
with some public key and a signature

1127
00:43:20,640 --> 00:43:21,720
algorithm

1128
00:43:21,720 --> 00:43:24,180
but the cipher Suite already mandates if

1129
00:43:24,180 --> 00:43:27,359
RSA or ecdsa signatures should be used

1130
00:43:27,359 --> 00:43:29,220
so consequently once we choose The

1131
00:43:29,220 --> 00:43:31,440
Cypher Suite our options for the

1132
00:43:31,440 --> 00:43:32,940
certificate and for the signature

1133
00:43:32,940 --> 00:43:35,220
algorithm are already limited and

1134
00:43:35,220 --> 00:43:37,859
depending on the specific type of the

1135
00:43:37,859 --> 00:43:39,900
public key in the certificate our choice

1136
00:43:39,900 --> 00:43:41,880
there may further limit our options for

1137
00:43:41,880 --> 00:43:43,680
the signature algorithm

1138
00:43:43,680 --> 00:43:46,140
if we do not respect these boundaries we

1139
00:43:46,140 --> 00:43:48,180
are again creating invalid test inputs

1140
00:43:48,180 --> 00:43:50,880
that potentially stop our sessions at a

1141
00:43:50,880 --> 00:43:53,099
point where we don't want it to stop

1142
00:43:53,099 --> 00:43:55,380
of course we don't always want to avoid

1143
00:43:55,380 --> 00:43:57,119
these invalid combinations because it's

1144
00:43:57,119 --> 00:43:58,740
also crucial to ensure that an

1145
00:43:58,740 --> 00:44:00,240
implementation rejects invalid

1146
00:44:00,240 --> 00:44:01,800
combinations correctly

1147
00:44:01,800 --> 00:44:04,020
but we only want to test these ones and

1148
00:44:04,020 --> 00:44:05,940
a dedicated set of tests and then

1149
00:44:05,940 --> 00:44:09,000
exclude them from all other tests

1150
00:44:09,000 --> 00:44:11,220
based on these Concepts we built a test

1151
00:44:11,220 --> 00:44:14,099
Suite which we call TLS anvil let's use

1152
00:44:14,099 --> 00:44:15,839
the Black Box approach to evaluate here

1153
00:44:15,839 --> 00:44:17,640
as clients and servers and the

1154
00:44:17,640 --> 00:44:19,500
individual tests are based on mandatory

1155
00:44:19,500 --> 00:44:21,599
RC statements such as the one shown at

1156
00:44:21,599 --> 00:44:22,619
the beginning

1157
00:44:22,619 --> 00:44:24,839
to explore parameter interactions we use

1158
00:44:24,839 --> 00:44:26,880
t-way testing and we consider a rich

1159
00:44:26,880 --> 00:44:28,800
input parameter model with up to 14

1160
00:44:28,800 --> 00:44:30,660
parameters such as different Cypher

1161
00:44:30,660 --> 00:44:33,359
Suites name groups signature algorithms

1162
00:44:33,359 --> 00:44:35,160
certificates with varying public key

1163
00:44:35,160 --> 00:44:37,260
types but also parameters that do not

1164
00:44:37,260 --> 00:44:39,119
directly affect cryptography such as

1165
00:44:39,119 --> 00:44:40,740
record fragmentation

1166
00:44:40,740 --> 00:44:43,800
and in total tlsm will consists of 408

1167
00:44:43,800 --> 00:44:45,780
test templates which are based on 13 TDS

1168
00:44:45,780 --> 00:44:48,359
rvcs

1169
00:44:48,359 --> 00:44:50,760
the execution of tlsm will always starts

1170
00:44:50,760 --> 00:44:52,319
with the creation of the input parameter

1171
00:44:52,319 --> 00:44:53,460
model

1172
00:44:53,460 --> 00:44:55,260
first we perform a feature extraction

1173
00:44:55,260 --> 00:44:57,480
for the tested Library this is an

1174
00:44:57,480 --> 00:44:59,280
important step as it allows us to

1175
00:44:59,280 --> 00:45:01,800
identify applicable tests and necessary

1176
00:45:01,800 --> 00:45:03,359
parameter constraints

1177
00:45:03,359 --> 00:45:05,579
so coming back to RFC I'll see example

1178
00:45:05,579 --> 00:45:07,680
from the beginning to test if a library

1179
00:45:07,680 --> 00:45:10,020
handles padding correctly for CBC Cipher

1180
00:45:10,020 --> 00:45:11,520
Suites the library must obviously

1181
00:45:11,520 --> 00:45:13,260
support a CBC server Suite in the first

1182
00:45:13,260 --> 00:45:15,060
place otherwise we just cannot apply the

1183
00:45:15,060 --> 00:45:17,700
test so we first select a suitable test

1184
00:45:17,700 --> 00:45:20,040
based on the capabilities of the library

1185
00:45:20,040 --> 00:45:22,200
and then we choose suitable parameter

1186
00:45:22,200 --> 00:45:24,180
values for the input parameter model of

1187
00:45:24,180 --> 00:45:26,339
this test and we choose these values

1188
00:45:26,339 --> 00:45:27,839
based on what the test is actually

1189
00:45:27,839 --> 00:45:30,300
testing for and again the capabilities

1190
00:45:30,300 --> 00:45:31,980
of the library

1191
00:45:31,980 --> 00:45:34,319
and then we conclude the input parameter

1192
00:45:34,319 --> 00:45:36,240
model by adding the constraints that

1193
00:45:36,240 --> 00:45:38,160
filter out invalid combinations of these

1194
00:45:38,160 --> 00:45:40,020
values

1195
00:45:40,020 --> 00:45:42,119
we then hand over this input parameter

1196
00:45:42,119 --> 00:45:44,280
model to Coffee 4J coffee 4J is a

1197
00:45:44,280 --> 00:45:46,260
combinatorial testing framework

1198
00:45:46,260 --> 00:45:48,839
developed by the aachen university that

1199
00:45:48,839 --> 00:45:51,119
basically generates the Ty test inputs

1200
00:45:51,119 --> 00:45:53,460
required to achieve the two-way coverage

1201
00:45:53,460 --> 00:45:55,319
we then use these test inputs to

1202
00:45:55,319 --> 00:45:57,900
repeatedly set up TLS connections which

1203
00:45:57,900 --> 00:46:00,020
effectively evaluate the

1204
00:46:00,020 --> 00:46:01,619
requirement across different

1205
00:46:01,619 --> 00:46:03,300
configurations

1206
00:46:03,300 --> 00:46:05,640
and finally TLS envel evaluates all of

1207
00:46:05,640 --> 00:46:08,160
these sessions performed to conclude the

1208
00:46:08,160 --> 00:46:09,599
test result

1209
00:46:09,599 --> 00:46:11,880
and this whole testing process is fully

1210
00:46:11,880 --> 00:46:13,800
automated and gets repeated for each

1211
00:46:13,800 --> 00:46:15,900
test and finally this results in a

1212
00:46:15,900 --> 00:46:18,420
report and due to the constraining steps

1213
00:46:18,420 --> 00:46:20,280
performed for each input parameter model

1214
00:46:20,280 --> 00:46:22,980
and each test this report achieves a low

1215
00:46:22,980 --> 00:46:25,819
false positive rate

1216
00:46:26,220 --> 00:46:29,520
in our evaluation we analyzed 13 open

1217
00:46:29,520 --> 00:46:32,640
source TLS libraries and we tested with

1218
00:46:32,640 --> 00:46:35,400
Ty values of three two and one here you

1219
00:46:35,400 --> 00:46:37,319
can see the execution time and number of

1220
00:46:37,319 --> 00:46:39,839
connections required to evaluate them

1221
00:46:39,839 --> 00:46:41,819
and there are some important difference

1222
00:46:41,819 --> 00:46:45,599
here so for example mrtls had the

1223
00:46:45,599 --> 00:46:47,460
longest execution time with around 67

1224
00:46:47,460 --> 00:46:50,280
hours and more than 180 000 TLS

1225
00:46:50,280 --> 00:46:52,440
connections perform well as to end on

1226
00:46:52,440 --> 00:46:54,780
the other end only took six hours with

1227
00:46:54,780 --> 00:46:59,040
around 27 000 connections and this is an

1228
00:46:59,040 --> 00:47:00,780
important aspect because

1229
00:47:00,780 --> 00:47:04,740
um the there are two aspects which uh

1230
00:47:04,740 --> 00:47:06,960
Define the the runtime to a large extent

1231
00:47:06,960 --> 00:47:09,119
so first of all this is how many tests

1232
00:47:09,119 --> 00:47:11,400
we can apply which depends on the

1233
00:47:11,400 --> 00:47:13,859
capabilities of the library and the

1234
00:47:13,859 --> 00:47:16,140
second aspect which is also important

1235
00:47:16,140 --> 00:47:19,800
um the extent of the input parameter

1236
00:47:19,800 --> 00:47:21,540
models we can build for the library so

1237
00:47:21,540 --> 00:47:23,160
for example how many Cipher suits we can

1238
00:47:23,160 --> 00:47:24,480
use for testing how many name group

1239
00:47:24,480 --> 00:47:26,460
signature algorithms and so on and this

1240
00:47:26,460 --> 00:47:28,740
also depends on the capabilities of the

1241
00:47:28,740 --> 00:47:29,640
library

1242
00:47:29,640 --> 00:47:31,859
so this is mostly what's causing the

1243
00:47:31,859 --> 00:47:33,900
difference here between the these two

1244
00:47:33,900 --> 00:47:35,819
libraries in particular

1245
00:47:35,819 --> 00:47:37,440
for strength two the execution time

1246
00:47:37,440 --> 00:47:40,380
varies between 11.5 and 1.3 hours and

1247
00:47:40,380 --> 00:47:42,119
for strength one most libraries can be

1248
00:47:42,119 --> 00:47:44,839
evaluated within one hour

1249
00:47:44,839 --> 00:47:47,280
our evaluation determines three

1250
00:47:47,280 --> 00:47:49,319
exploitable vulnerabilities one of which

1251
00:47:49,319 --> 00:47:51,359
was a padding Oracle vulnerability in

1252
00:47:51,359 --> 00:47:53,400
The Matrix client

1253
00:47:53,400 --> 00:47:56,760
by default TLS uses the macdon and crypt

1254
00:47:56,760 --> 00:47:59,040
pattern for CBC Cipher Suites which

1255
00:47:59,040 --> 00:48:00,359
basically means when you want to send

1256
00:48:00,359 --> 00:48:02,460
some data you first compute a Mac for

1257
00:48:02,460 --> 00:48:04,740
this data then you add heading as

1258
00:48:04,740 --> 00:48:06,540
required for your block Cipher before

1259
00:48:06,540 --> 00:48:09,060
encrypting the entire construct and

1260
00:48:09,060 --> 00:48:10,859
consequently when the receiver wants to

1261
00:48:10,859 --> 00:48:13,200
check the Mac he first has to decrypt

1262
00:48:13,200 --> 00:48:15,540
this message and remove the padding

1263
00:48:15,540 --> 00:48:17,760
and padding has a specific structure in

1264
00:48:17,760 --> 00:48:20,220
TLS and it's crucial that an invalid

1265
00:48:20,220 --> 00:48:21,960
padding must be indistinguishable from

1266
00:48:21,960 --> 00:48:24,060
an invalid Mac because otherwise an

1267
00:48:24,060 --> 00:48:25,500
attacker may be able to rearrange

1268
00:48:25,500 --> 00:48:27,660
ciphertext blocks and deduce information

1269
00:48:27,660 --> 00:48:29,579
about the plain text based on the

1270
00:48:29,579 --> 00:48:31,560
validity of the created padding this

1271
00:48:31,560 --> 00:48:33,540
essentially the petting orca

1272
00:48:33,540 --> 00:48:35,940
so if the padding is invalid the library

1273
00:48:35,940 --> 00:48:37,920
must not abort the session but must

1274
00:48:37,920 --> 00:48:39,359
continue to perform a dummy Mac

1275
00:48:39,359 --> 00:48:41,400
computation and only then fail the

1276
00:48:41,400 --> 00:48:43,680
session and specifically must fail the

1277
00:48:43,680 --> 00:48:45,839
session with a bad record map

1278
00:48:45,839 --> 00:48:48,240
now the metrics SSL client when

1279
00:48:48,240 --> 00:48:49,800
confronted with an invalid padding

1280
00:48:49,800 --> 00:48:51,780
simply close the TCP connection without

1281
00:48:51,780 --> 00:48:54,420
any alert but specifically only for

1282
00:48:54,420 --> 00:48:58,260
Cipher Suites which use the sha-256 hmac

1283
00:48:58,260 --> 00:49:00,240
this was caused by a segmentation fault

1284
00:49:00,240 --> 00:49:01,920
because when the invalid padding had

1285
00:49:01,920 --> 00:49:03,180
been detected the hmac wasn't

1286
00:49:03,180 --> 00:49:05,280
initialized properly but it was still

1287
00:49:05,280 --> 00:49:06,420
called to perform the dummy Mac

1288
00:49:06,420 --> 00:49:08,579
computation which then ran into the

1289
00:49:08,579 --> 00:49:10,619
segmentation folder and this was

1290
00:49:10,619 --> 00:49:12,180
distinguishable from Mac failures

1291
00:49:12,180 --> 00:49:14,880
because for an invalid Mac and a lot was

1292
00:49:14,880 --> 00:49:16,920
always sent and thus this padding Oracle

1293
00:49:16,920 --> 00:49:19,619
could be exploited

1294
00:49:19,619 --> 00:49:21,720
we also found the denial of service back

1295
00:49:21,720 --> 00:49:23,640
in The Matrix as a client based on

1296
00:49:23,640 --> 00:49:25,200
sending messages with contradicting

1297
00:49:25,200 --> 00:49:26,460
length fields

1298
00:49:26,460 --> 00:49:29,339
so similar as to other protocols TLS has

1299
00:49:29,339 --> 00:49:31,319
nested length Fields so for example

1300
00:49:31,319 --> 00:49:32,940
there's a length field here for the

1301
00:49:32,940 --> 00:49:34,740
entirety of a TLS record

1302
00:49:34,740 --> 00:49:36,420
then within the record there is a

1303
00:49:36,420 --> 00:49:39,000
message which has a length field for its

1304
00:49:39,000 --> 00:49:40,740
contents and within the content there

1305
00:49:40,740 --> 00:49:42,660
can be various other lag fields for

1306
00:49:42,660 --> 00:49:44,160
example down here at the bottom for a

1307
00:49:44,160 --> 00:49:46,099
list of extensions

1308
00:49:46,099 --> 00:49:48,960
now if we modify the length field in the

1309
00:49:48,960 --> 00:49:50,819
middle but leave everything else as it

1310
00:49:50,819 --> 00:49:52,619
is we can create an invalid message

1311
00:49:52,619 --> 00:49:54,960
where basically the extensions length

1312
00:49:54,960 --> 00:49:56,640
field at the bottom now reaches beyond

1313
00:49:56,640 --> 00:49:58,619
the byte range defined above

1314
00:49:58,619 --> 00:50:00,060
so essentially the message becomes

1315
00:50:00,060 --> 00:50:01,319
unpassable

1316
00:50:01,319 --> 00:50:03,960
interestingly when negotiating TLS 1.3

1317
00:50:03,960 --> 00:50:06,180
metrics SSL would start to pass this

1318
00:50:06,180 --> 00:50:08,520
message and run into a loop which would

1319
00:50:08,520 --> 00:50:11,460
become unresponsive and the CPU usage

1320
00:50:11,460 --> 00:50:13,079
would arise and stay on a high level

1321
00:50:13,079 --> 00:50:15,359
indefinitely

1322
00:50:15,359 --> 00:50:17,880
this issue did not quarantee LS 1.2 but

1323
00:50:17,880 --> 00:50:19,680
there was another interesting issue with

1324
00:50:19,680 --> 00:50:21,359
Matrix SSL regarding length field

1325
00:50:21,359 --> 00:50:23,700
because it was possible to send messages

1326
00:50:23,700 --> 00:50:25,980
which stated a Content length of zero

1327
00:50:25,980 --> 00:50:28,380
bytes but still actually contain content

1328
00:50:28,380 --> 00:50:30,780
bytes again this is possible due to the

1329
00:50:30,780 --> 00:50:33,420
nested length Fields so there is this

1330
00:50:33,420 --> 00:50:35,339
record content length field again here

1331
00:50:35,339 --> 00:50:37,319
which states the correct number of bytes

1332
00:50:37,319 --> 00:50:39,119
for the entirety of the message

1333
00:50:39,119 --> 00:50:41,220
and then within the record there's a

1334
00:50:41,220 --> 00:50:42,900
server key exchange message here which

1335
00:50:42,900 --> 00:50:44,579
states a Content length of zero bytes

1336
00:50:44,579 --> 00:50:48,000
but essentially below you could send all

1337
00:50:48,000 --> 00:50:50,819
key exchange information you needed

1338
00:50:50,819 --> 00:50:52,800
and despite this content length field of

1339
00:50:52,800 --> 00:50:55,800
zero Matrix SSL would just proceed to

1340
00:50:55,800 --> 00:50:57,480
pass the entire message with all of the

1341
00:50:57,480 --> 00:51:00,059
key exchange information which of course

1342
00:51:00,059 --> 00:51:02,579
itself is not an issue but the issue was

1343
00:51:02,579 --> 00:51:04,440
that while the length field had been

1344
00:51:04,440 --> 00:51:06,720
ignored for parsing purposes it has been

1345
00:51:06,720 --> 00:51:08,700
used to determine which bytes affect the

1346
00:51:08,700 --> 00:51:10,140
session transcript

1347
00:51:10,140 --> 00:51:12,359
session transcript is used in TLS at the

1348
00:51:12,359 --> 00:51:14,040
end of the handshake where both peers

1349
00:51:14,040 --> 00:51:16,260
exchanged a finished message which

1350
00:51:16,260 --> 00:51:18,059
basically contains an hmac of the

1351
00:51:18,059 --> 00:51:20,700
transcript to ensure that messages that

1352
00:51:20,700 --> 00:51:22,920
were previously sent in plain text were

1353
00:51:22,920 --> 00:51:24,180
on tampered with

1354
00:51:24,180 --> 00:51:27,300
so essentially Matrix SSL would process

1355
00:51:27,300 --> 00:51:29,760
all bytes in the record but everything

1356
00:51:29,760 --> 00:51:31,740
below this content length field would be

1357
00:51:31,740 --> 00:51:35,058
excluded from the transcript

1358
00:51:35,819 --> 00:51:38,040
we also found an authentication bypass

1359
00:51:38,040 --> 00:51:40,680
for Wolf SSL and TLS 1.3

1360
00:51:40,680 --> 00:51:43,680
usually a server authenticates towards a

1361
00:51:43,680 --> 00:51:45,599
client interl 1.3 by sending a

1362
00:51:45,599 --> 00:51:47,579
certificate message which as the name

1363
00:51:47,579 --> 00:51:49,559
implies contains the certificate or a

1364
00:51:49,559 --> 00:51:51,720
chain of certificates and subsequently

1365
00:51:51,720 --> 00:51:53,400
the server sends a certificate verify

1366
00:51:53,400 --> 00:51:55,380
message which essentially contains a

1367
00:51:55,380 --> 00:51:57,300
signature which can be verified using

1368
00:51:57,300 --> 00:52:00,059
the public key from the certificate

1369
00:52:00,059 --> 00:52:03,000
for with SSL when a server send a

1370
00:52:03,000 --> 00:52:04,440
certificate message which was actually

1371
00:52:04,440 --> 00:52:05,579
empty

1372
00:52:05,579 --> 00:52:07,440
uh wolf versus Air just accepted any

1373
00:52:07,440 --> 00:52:09,359
certificate verifier value and always

1374
00:52:09,359 --> 00:52:11,700
concluded the handshake without any

1375
00:52:11,700 --> 00:52:13,500
server Authentication

1376
00:52:13,500 --> 00:52:15,480
now interestingly when we look at the

1377
00:52:15,480 --> 00:52:17,099
message structure of the certificate

1378
00:52:17,099 --> 00:52:18,720
message there are actually two points

1379
00:52:18,720 --> 00:52:20,220
where you could say that the message is

1380
00:52:20,220 --> 00:52:22,500
empty first of all there's this generic

1381
00:52:22,500 --> 00:52:24,420
content length field that all handshake

1382
00:52:24,420 --> 00:52:26,460
messages in TLS have and then there's

1383
00:52:26,460 --> 00:52:29,520
this certificates list length field

1384
00:52:29,520 --> 00:52:31,619
and only setting the letter to zero

1385
00:52:31,619 --> 00:52:33,420
actually caused this bug which is quite

1386
00:52:33,420 --> 00:52:34,920
interesting because there's a hair

1387
00:52:34,920 --> 00:52:37,559
specifically for this length field uh an

1388
00:52:37,559 --> 00:52:39,960
RFC requirement that this must not be

1389
00:52:39,960 --> 00:52:42,240
zero and that it must be rejected if it

1390
00:52:42,240 --> 00:52:45,059
is but only setting this one to zero

1391
00:52:45,059 --> 00:52:47,099
actually caused this bypass and if you

1392
00:52:47,099 --> 00:52:48,900
set the the upper content length field

1393
00:52:48,900 --> 00:52:51,480
to zero which in some case results in a

1394
00:52:51,480 --> 00:52:53,339
even shorter message even emptier

1395
00:52:53,339 --> 00:52:55,260
certificate message

1396
00:52:55,260 --> 00:52:55,859
um

1397
00:52:55,859 --> 00:52:58,380
in this case if I would actually reject

1398
00:52:58,380 --> 00:53:01,280
it then correctly

1399
00:53:01,800 --> 00:53:04,079
okay uh in total our evaluation

1400
00:53:04,079 --> 00:53:07,500
determined 239 RFC violations

1401
00:53:07,500 --> 00:53:09,119
um we analyze failed tests and group

1402
00:53:09,119 --> 00:53:10,440
them based on the impact in the

1403
00:53:10,440 --> 00:53:11,700
following way

1404
00:53:11,700 --> 00:53:13,440
first of all we have the three

1405
00:53:13,440 --> 00:53:15,359
exploitable vulnerabilities I mostly

1406
00:53:15,359 --> 00:53:18,660
talked about just a few seconds ago

1407
00:53:18,660 --> 00:53:21,480
um then we found five cases where

1408
00:53:21,480 --> 00:53:23,160
cryptographic operations have been

1409
00:53:23,160 --> 00:53:25,440
illicitly affected such as a key

1410
00:53:25,440 --> 00:53:27,780
confusion bug in Libre SSL where one

1411
00:53:27,780 --> 00:53:29,640
Keys have been used to decrypt received

1412
00:53:29,640 --> 00:53:32,520
messages under certain circumstances

1413
00:53:32,520 --> 00:53:34,680
we also identified 15 potential

1414
00:53:34,680 --> 00:53:37,319
interoperability issues such as an issue

1415
00:53:37,319 --> 00:53:39,300
and with SSL that prevents proper

1416
00:53:39,300 --> 00:53:42,119
parsing of certain small record sizes

1417
00:53:42,119 --> 00:53:45,420
then we found 116 cases where libraries

1418
00:53:45,420 --> 00:53:47,819
either did not send any alert codes or

1419
00:53:47,819 --> 00:53:49,500
some different alerts they mandated by

1420
00:53:49,500 --> 00:53:52,619
the RC these cases are likely uncritical

1421
00:53:52,619 --> 00:53:54,000
and some would inflate the number of our

1422
00:53:54,000 --> 00:53:56,160
findings but in some cases correct alert

1423
00:53:56,160 --> 00:53:59,280
handling can be crucial for example to

1424
00:53:59,280 --> 00:54:01,619
avoid padding oracles

1425
00:54:01,619 --> 00:54:03,720
and ultimately we found a vast range of

1426
00:54:03,720 --> 00:54:05,940
RFC violations which do not find any of

1427
00:54:05,940 --> 00:54:08,220
the first categories which we just put

1428
00:54:08,220 --> 00:54:09,740
us out on

1429
00:54:09,740 --> 00:54:12,240
now it's important to point out that

1430
00:54:12,240 --> 00:54:14,339
despite the high number of findings most

1431
00:54:14,339 --> 00:54:15,960
well-known libraries still pass the very

1432
00:54:15,960 --> 00:54:18,059
high percentage of tests with around 97

1433
00:54:18,059 --> 00:54:21,680
in our server tests

1434
00:54:22,020 --> 00:54:24,660
so in conclusion we built a TLS test

1435
00:54:24,660 --> 00:54:26,880
Suite called TLS Anvil that evaluates

1436
00:54:26,880 --> 00:54:28,680
clients and servers based on mandatory

1437
00:54:28,680 --> 00:54:31,440
RFC requirements to explore parameter

1438
00:54:31,440 --> 00:54:33,240
interactions we use t-way testing with

1439
00:54:33,240 --> 00:54:35,760
carefully constrained test inputs

1440
00:54:35,760 --> 00:54:38,220
we analyzed 13 open source libraries and

1441
00:54:38,220 --> 00:54:40,859
determined a total of 239 RFC violations

1442
00:54:40,859 --> 00:54:42,300
including three exploitable

1443
00:54:42,300 --> 00:54:44,400
vulnerabilities

1444
00:54:44,400 --> 00:54:45,839
especially these exploitable

1445
00:54:45,839 --> 00:54:47,520
vulnerabilities indicate that they are

1446
00:54:47,520 --> 00:54:48,960
still a blind spot in the tests of the

1447
00:54:48,960 --> 00:54:50,460
affected libraries

1448
00:54:50,460 --> 00:54:53,099
and implementing combinatorial RFC tests

1449
00:54:53,099 --> 00:54:54,540
into the testing pipelines of these

1450
00:54:54,540 --> 00:54:56,819
libraries could help avoid these issues

1451
00:54:56,819 --> 00:54:58,980
before a new library version gets

1452
00:54:58,980 --> 00:55:01,260
released we also think that it may be

1453
00:55:01,260 --> 00:55:03,599
worth to add more tests for other rocs

1454
00:55:03,599 --> 00:55:05,220
to get a better understanding of the

1455
00:55:05,220 --> 00:55:07,859
state of an implementation and it may

1456
00:55:07,859 --> 00:55:09,839
also be worth to apply the same to new

1457
00:55:09,839 --> 00:55:11,700
protocols such as quick to avoid

1458
00:55:11,700 --> 00:55:13,559
interoperability and security issues

1459
00:55:13,559 --> 00:55:15,119
early on

1460
00:55:15,119 --> 00:55:17,099
if you want to learn more about tlsm

1461
00:55:17,099 --> 00:55:18,359
where you can find the source code on

1462
00:55:18,359 --> 00:55:20,460
GitHub we also have some additional

1463
00:55:20,460 --> 00:55:22,980
documentation on tlsmo.com

1464
00:55:22,980 --> 00:55:24,660
and with that I thank you for your

1465
00:55:24,660 --> 00:55:26,280
attention I'd be happy to answer any

1466
00:55:26,280 --> 00:55:28,520
questions

1467
00:55:29,480 --> 00:55:32,480
thank you

1468
00:55:35,339 --> 00:55:38,000
questions

1469
00:55:38,700 --> 00:55:41,900
hey uh Chris Wood this is fantastic work

1470
00:55:41,900 --> 00:55:45,180
it's great to see like TLS really kind

1471
00:55:45,180 --> 00:55:46,680
of hit with a hammer especially all the

1472
00:55:46,680 --> 00:55:48,839
old Legacy versions and whatnot I'm

1473
00:55:48,839 --> 00:55:50,520
wondering two things

1474
00:55:50,520 --> 00:55:52,319
um one if you've looked at applying this

1475
00:55:52,319 --> 00:55:55,260
to encrypted client hello with this it's

1476
00:55:55,260 --> 00:55:57,300
this new sort of emerging and kind of

1477
00:55:57,300 --> 00:55:59,220
complicated extension to TLS which would

1478
00:55:59,220 --> 00:56:01,260
benefit from whacking it with a hammer

1479
00:56:01,260 --> 00:56:03,780
to see if there's any problems with it

1480
00:56:03,780 --> 00:56:06,359
um and my second question is I'm

1481
00:56:06,359 --> 00:56:08,940
wondering how specific it says the TLs

1482
00:56:08,940 --> 00:56:11,339
but quick is you know it shares some

1483
00:56:11,339 --> 00:56:13,200
similarities with the protocol mechanics

1484
00:56:13,200 --> 00:56:14,819
of TLs but there's other protocols in

1485
00:56:14,819 --> 00:56:16,500
the ITF some that we talked about

1486
00:56:16,500 --> 00:56:18,119
earlier which would really benefit from

1487
00:56:18,119 --> 00:56:20,099
testing of this type and I'm wondering

1488
00:56:20,099 --> 00:56:21,359
if you thought about trying to like

1489
00:56:21,359 --> 00:56:23,640
generalize the methodology and the

1490
00:56:23,640 --> 00:56:25,380
mechanism a bit to discover

1491
00:56:25,380 --> 00:56:28,260
vulnerabilities and or you know issues

1492
00:56:28,260 --> 00:56:30,540
of any sort and other types of vertical

1493
00:56:30,540 --> 00:56:31,859
implementations

1494
00:56:31,859 --> 00:56:33,720
so maybe to summarize question two it's

1495
00:56:33,720 --> 00:56:35,700
about how good you could apply it to

1496
00:56:35,700 --> 00:56:38,880
other protocols yeah basically okay

1497
00:56:38,880 --> 00:56:41,339
um so we focused on mandatory

1498
00:56:41,339 --> 00:56:44,280
requirements um the RCs generally use

1499
00:56:44,280 --> 00:56:46,940
these signal words to identify mandatory

1500
00:56:46,940 --> 00:56:50,760
Parts which are absolutely crucial so of

1501
00:56:50,760 --> 00:56:52,619
course we need a specification that has

1502
00:56:52,619 --> 00:56:56,040
these type of signal words and

1503
00:56:56,040 --> 00:56:58,200
um yeah for some for some aspects there

1504
00:56:58,200 --> 00:57:00,960
must also be a the offices must be

1505
00:57:00,960 --> 00:57:02,280
written in a way that you can actually

1506
00:57:02,280 --> 00:57:04,859
test these things or from the RCs for

1507
00:57:04,859 --> 00:57:07,020
TLS for example also state that the

1508
00:57:07,020 --> 00:57:08,880
library must not do something but it

1509
00:57:08,880 --> 00:57:11,220
doesn't say what the the other side must

1510
00:57:11,220 --> 00:57:14,700
do if it if it determines that the other

1511
00:57:14,700 --> 00:57:16,559
side has actually broken this

1512
00:57:16,559 --> 00:57:18,180
requirement so there's nothing to

1513
00:57:18,180 --> 00:57:20,220
enforce there which makes testing

1514
00:57:20,220 --> 00:57:23,339
difficult it tlsrcs are still in a good

1515
00:57:23,339 --> 00:57:25,440
state in this regard but for other

1516
00:57:25,440 --> 00:57:27,900
protocols uh I could imagine that it's

1517
00:57:27,900 --> 00:57:30,500
not as good

1518
00:57:30,720 --> 00:57:32,400
um sometimes that mismatch between

1519
00:57:32,400 --> 00:57:34,380
different uh I guess requirements on

1520
00:57:34,380 --> 00:57:36,180
sender and receiver are kind of

1521
00:57:36,180 --> 00:57:38,339
important in practice so for example uh

1522
00:57:38,339 --> 00:57:40,619
TLS 1.3 has certain requirements on like

1523
00:57:40,619 --> 00:57:43,319
what the sender of like you know data

1524
00:57:43,319 --> 00:57:45,540
should do in terms of like how much data

1525
00:57:45,540 --> 00:57:47,099
can send before it has to initiate a

1526
00:57:47,099 --> 00:57:48,359
re-key because there's like a limit to

1527
00:57:48,359 --> 00:57:49,859
how much data you can send through an

1528
00:57:49,859 --> 00:57:51,420
aad before you need to potentially

1529
00:57:51,420 --> 00:57:54,000
ratchet and move forward but in case

1530
00:57:54,000 --> 00:57:56,460
like new amount analysis emerges such

1531
00:57:56,460 --> 00:57:58,800
that like the limits change we don't

1532
00:57:58,800 --> 00:58:00,420
have a similar requirement on the

1533
00:58:00,420 --> 00:58:01,920
receiver end to say that like if you

1534
00:58:01,920 --> 00:58:03,780
receive a certain amount of data that

1535
00:58:03,780 --> 00:58:05,460
you must like enforce this particular

1536
00:58:05,460 --> 00:58:08,579
thing so sometimes like the I guess

1537
00:58:08,579 --> 00:58:11,579
these discrepancies exist for kind of

1538
00:58:11,579 --> 00:58:13,559
reasonable reasons but I understand how

1539
00:58:13,559 --> 00:58:15,720
it complicates the the testing in this

1540
00:58:15,720 --> 00:58:17,280
particular case I would love to hear

1541
00:58:17,280 --> 00:58:19,020
like how we could improve specifications

1542
00:58:19,020 --> 00:58:20,640
more generally to make this type of

1543
00:58:20,640 --> 00:58:22,680
testing a lot easier

1544
00:58:22,680 --> 00:58:23,940
um like having to go through and

1545
00:58:23,940 --> 00:58:25,559
manually pluck out all these must and

1546
00:58:25,559 --> 00:58:29,220
shows and whatever is uh not great

1547
00:58:29,220 --> 00:58:32,640
um and uh I'll follow you up I'll catch

1548
00:58:32,640 --> 00:58:33,960
you offline so we can perhaps talk about

1549
00:58:33,960 --> 00:58:36,200
that

1550
00:58:37,380 --> 00:58:38,819
um we do actually need to move on to the

1551
00:58:38,819 --> 00:58:39,960
next talk do you have a quick question

1552
00:58:39,960 --> 00:58:42,540
all right one quick question all right I

1553
00:58:42,540 --> 00:58:44,579
just wanted to well more of a comment

1554
00:58:44,579 --> 00:58:47,160
which I sincerely apologize for

1555
00:58:47,160 --> 00:58:48,540
um

1556
00:58:48,540 --> 00:58:51,420
I first thank you this is amazing work I

1557
00:58:51,420 --> 00:58:53,099
just want to say if you're looking at

1558
00:58:53,099 --> 00:58:55,559
current its specs like what Chris was

1559
00:58:55,559 --> 00:58:57,359
talking about like encrypted hello and

1560
00:58:57,359 --> 00:58:59,460
you ever see the bug that you described

1561
00:58:59,460 --> 00:59:01,380
where it says don't do this but it

1562
00:59:01,380 --> 00:59:02,460
doesn't say on the other side what

1563
00:59:02,460 --> 00:59:04,380
you're supposed to do that's a bug in

1564
00:59:04,380 --> 00:59:07,500
the spec and please tell us like ITF

1565
00:59:07,500 --> 00:59:09,180
people that we have bugs so we can fix

1566
00:59:09,180 --> 00:59:11,400
them because it's really valuable the

1567
00:59:11,400 --> 00:59:12,720
work you're doing and if you see their

1568
00:59:12,720 --> 00:59:14,460
bugs let us know so we can work together

1569
00:59:14,460 --> 00:59:18,260
to fix them okay thank you

1570
00:59:18,299 --> 00:59:21,259
thank you Marcel

1571
00:59:27,359 --> 00:59:29,940
okay so moving on to our final talk

1572
00:59:29,940 --> 00:59:31,500
or the session

1573
00:59:31,500 --> 00:59:33,540
which is about a computational analysis

1574
00:59:33,540 --> 00:59:36,660
of the ad hoc protocol and Mark ilunga

1575
00:59:36,660 --> 00:59:38,940
will give the talk

1576
00:59:38,940 --> 00:59:42,000
[Music]

1577
00:59:42,000 --> 00:59:45,319
good can you hear me yeah

1578
00:59:48,180 --> 00:59:49,920
so hi everyone

1579
00:59:49,920 --> 00:59:52,740
this talk is about haddock it's a dock

1580
00:59:52,740 --> 00:59:54,720
is a family of lightweight authenticated

1581
00:59:54,720 --> 00:59:57,240
key exchange protocols for constrained

1582
00:59:57,240 --> 00:59:58,920
environments that is currently being

1583
00:59:58,920 --> 01:00:01,920
standardized by the ATF in this talk

1584
01:00:01,920 --> 01:00:05,099
I'll present our analysis of an

1585
01:00:05,099 --> 01:00:07,319
instantiation of haddock that is based

1586
01:00:07,319 --> 01:00:09,599
on the magnan sign protocol I will

1587
01:00:09,599 --> 01:00:11,220
highlight some of the insights we got

1588
01:00:11,220 --> 01:00:13,619
into the magnan sign protocol and

1589
01:00:13,619 --> 01:00:15,720
conclude with a brief discussion of our

1590
01:00:15,720 --> 01:00:18,420
interactions with the ITF

1591
01:00:18,420 --> 01:00:20,760
this is don't work with Felix kunter and

1592
01:00:20,760 --> 01:00:23,160
I'm Mark ilunga

1593
01:00:23,160 --> 01:00:25,920
all right so very recently I got a

1594
01:00:25,920 --> 01:00:27,960
connected light bulb I'm very late to

1595
01:00:27,960 --> 01:00:29,400
the party this is not me on the picture

1596
01:00:29,400 --> 01:00:32,040
I just want the image on the internet

1597
01:00:32,040 --> 01:00:34,920
but iot devices have been around and

1598
01:00:34,920 --> 01:00:36,660
they are pretty much everywhere and

1599
01:00:36,660 --> 01:00:38,760
sadly we have a very poor security track

1600
01:00:38,760 --> 01:00:39,720
record

1601
01:00:39,720 --> 01:00:41,700
indeed because of their limited

1602
01:00:41,700 --> 01:00:43,500
computing power and the type of

1603
01:00:43,500 --> 01:00:46,260
restricted Network in which they operate

1604
01:00:46,260 --> 01:00:47,700
security consideration variety

1605
01:00:47,700 --> 01:00:49,440
applications are usually out of the

1606
01:00:49,440 --> 01:00:50,460
picture

1607
01:00:50,460 --> 01:00:52,500
you probably heard that the s in iot

1608
01:00:52,500 --> 01:00:54,200
stands for security

1609
01:00:54,200 --> 01:00:57,720
but behind this joke sometimes I very

1610
01:00:57,720 --> 01:00:59,700
serious incident like invasion of

1611
01:00:59,700 --> 01:01:03,420
intimate activities involving iot which

1612
01:01:03,420 --> 01:01:05,640
really puts another perspective on the

1613
01:01:05,640 --> 01:01:07,319
fact that iot devices are really

1614
01:01:07,319 --> 01:01:09,900
everywhere

1615
01:01:09,900 --> 01:01:12,720
anyhow in the last years we've seen lots

1616
01:01:12,720 --> 01:01:15,359
of work trying to provide schemes and

1617
01:01:15,359 --> 01:01:16,859
protocols that would be fit for

1618
01:01:16,859 --> 01:01:19,440
constraint environment however a

1619
01:01:19,440 --> 01:01:21,240
lightweight authenticated key exchange

1620
01:01:21,240 --> 01:01:23,760
protocol is still a missing piece of

1621
01:01:23,760 --> 01:01:25,680
this chain of work

1622
01:01:25,680 --> 01:01:28,140
and this is what edoc and particularly

1623
01:01:28,140 --> 01:01:30,299
the lake working group at the ITF is

1624
01:01:30,299 --> 01:01:31,920
trying to solve

1625
01:01:31,920 --> 01:01:33,839
the main use case for edoc is to

1626
01:01:33,839 --> 01:01:35,640
establish the session key for oscore

1627
01:01:35,640 --> 01:01:37,920
which is a secure transport protocol for

1628
01:01:37,920 --> 01:01:39,839
constrained devices

1629
01:01:39,839 --> 01:01:42,420
haddock provides four mutual

1630
01:01:42,420 --> 01:01:43,619
authentication with four different

1631
01:01:43,619 --> 01:01:45,660
methods and in this talk I'll be

1632
01:01:45,660 --> 01:01:47,520
focusing on the so-called six Sig mode

1633
01:01:47,520 --> 01:01:50,040
where both parts the authenticate with

1634
01:01:50,040 --> 01:01:52,260
signature key pairs

1635
01:01:52,260 --> 01:01:55,140
and in this regard edoc is very similar

1636
01:01:55,140 --> 01:01:57,319
to TLS model 3 that we just heard before

1637
01:01:57,319 --> 01:02:00,720
and both of them are heavily inspired by

1638
01:02:00,720 --> 01:02:03,180
the sigma protocol

1639
01:02:03,180 --> 01:02:05,520
So speaking of 200.3 you may be

1640
01:02:05,520 --> 01:02:08,160
wondering well if we have TLS 1.3 why do

1641
01:02:08,160 --> 01:02:10,319
we need a new key exchange protocol

1642
01:02:10,319 --> 01:02:13,319
and indeed as referred CS model 3 is

1643
01:02:13,319 --> 01:02:15,780
efficient it's secure it's battle tested

1644
01:02:15,780 --> 01:02:17,520
has been hammered to death as we've

1645
01:02:17,520 --> 01:02:18,680
heard before

1646
01:02:18,680 --> 01:02:21,960
uh but the answer would be basically

1647
01:02:21,960 --> 01:02:25,559
that CLS 1.3 is not lightweight enough

1648
01:02:25,559 --> 01:02:28,200
indeed comparing the overhead of

1649
01:02:28,200 --> 01:02:30,119
different key exchange protocol one can

1650
01:02:30,119 --> 01:02:32,339
see that hadock in similar

1651
01:02:32,339 --> 01:02:35,880
configurations as CLS 1.3 or dtls 1.3

1652
01:02:35,880 --> 01:02:39,180
ends up using up to seven times less

1653
01:02:39,180 --> 01:02:41,220
bandwidth than the competitors which is

1654
01:02:41,220 --> 01:02:43,140
a clear Advantage when operating in

1655
01:02:43,140 --> 01:02:46,920
severely restricted Networks

1656
01:02:46,920 --> 01:02:49,460
foreign

1657
01:02:52,040 --> 01:02:55,079
let me now describe edoc in my

1658
01:02:55,079 --> 01:02:57,480
presentation here I will be fairly high

1659
01:02:57,480 --> 01:02:59,280
level I'll be omitting sort of

1660
01:02:59,280 --> 01:03:02,339
irrelevant uh protocol messages and to

1661
01:03:02,339 --> 01:03:04,799
do this I'm going to use an example of a

1662
01:03:04,799 --> 01:03:07,619
iot wallet trying to establish a secure

1663
01:03:07,619 --> 01:03:09,720
Communication channel with a crypto Bank

1664
01:03:09,720 --> 01:03:11,520
I don't know why you would want to do

1665
01:03:11,520 --> 01:03:14,099
that but let's just go with it for

1666
01:03:14,099 --> 01:03:15,540
narrative purposes

1667
01:03:15,540 --> 01:03:17,880
so adult is a protocol that is based on

1668
01:03:17,880 --> 01:03:19,799
the different key exchange protocol that

1669
01:03:19,799 --> 01:03:21,000
is well known

1670
01:03:21,000 --> 01:03:23,940
and so to use haddock here the wallet

1671
01:03:23,940 --> 01:03:26,099
will initiate the protocol by sending a

1672
01:03:26,099 --> 01:03:27,900
different cliche

1673
01:03:27,900 --> 01:03:30,599
the bank will then respond by signing by

1674
01:03:30,599 --> 01:03:32,520
sending its own development key share

1675
01:03:32,520 --> 01:03:35,520
and identity think of it here as a TLS

1676
01:03:35,520 --> 01:03:36,960
certificate for now

1677
01:03:36,960 --> 01:03:39,119
and a signature value for authentication

1678
01:03:39,119 --> 01:03:42,000
and what I mean by authentication is

1679
01:03:42,000 --> 01:03:44,460
that to authenticate itself back to the

1680
01:03:44,460 --> 01:03:46,799
wallet the server will first compute a

1681
01:03:46,799 --> 01:03:49,440
Mac over its identity the sort of TLS

1682
01:03:49,440 --> 01:03:52,260
certificate and then we'll sign this Mac

1683
01:03:52,260 --> 01:03:54,480
which is then sent in the second message

1684
01:03:54,480 --> 01:03:57,119
as we've seen so there's a different key

1685
01:03:57,119 --> 01:03:59,460
share there is an identity and a

1686
01:03:59,460 --> 01:04:01,619
signature of Authentication

1687
01:04:01,619 --> 01:04:04,200
to conclude the protocol flow the wallet

1688
01:04:04,200 --> 01:04:06,960
authenticate itself back to the bank by

1689
01:04:06,960 --> 01:04:09,000
sending its own identity and a signature

1690
01:04:09,000 --> 01:04:12,119
using a similar process as the banks did

1691
01:04:12,119 --> 01:04:14,299
before

1692
01:04:14,700 --> 01:04:16,440
a nice feature of edoc is that it

1693
01:04:16,440 --> 01:04:18,299
provides privacy for the communicating

1694
01:04:18,299 --> 01:04:21,359
Parties by concealing the identities of

1695
01:04:21,359 --> 01:04:23,040
devices communicating with each other

1696
01:04:23,040 --> 01:04:25,859
and this is simply done by encrypting

1697
01:04:25,859 --> 01:04:28,380
the uncheck in a way that's basically

1698
01:04:28,380 --> 01:04:30,059
hide the identities of the communicating

1699
01:04:30,059 --> 01:04:32,599
parties

1700
01:04:33,780 --> 01:04:35,640
was not really the focus of our analysis

1701
01:04:35,640 --> 01:04:37,980
so I will be ignoring that for the

1702
01:04:37,980 --> 01:04:40,260
remaining of the talk

1703
01:04:40,260 --> 01:04:42,960
okay so if we Zoom back what we see is

1704
01:04:42,960 --> 01:04:46,339
that edoc is built out from on one side

1705
01:04:46,339 --> 01:04:49,440
different key exchange and on the other

1706
01:04:49,440 --> 01:04:51,599
side authentication using Macs and

1707
01:04:51,599 --> 01:04:53,760
signatures and if you're familiar you

1708
01:04:53,760 --> 01:04:55,559
probably recognize the shape of the

1709
01:04:55,559 --> 01:04:58,079
sigma protocol which again so uses

1710
01:04:58,079 --> 01:05:00,839
differential man and uses Macs and

1711
01:05:00,839 --> 01:05:04,160
signatures for Authentication

1712
01:05:05,400 --> 01:05:08,880
but however for those familiar with with

1713
01:05:08,880 --> 01:05:10,740
signal protocol or even TLS from three

1714
01:05:10,740 --> 01:05:12,839
you can see that edoc is not quite

1715
01:05:12,839 --> 01:05:17,160
exactly uh Sigma or not exactly ts173

1716
01:05:17,160 --> 01:05:19,440
the first difference that we see is that

1717
01:05:19,440 --> 01:05:22,079
edoc puts the Mac under the signature

1718
01:05:22,079 --> 01:05:26,280
and this is a bandwidth saving measure

1719
01:05:26,280 --> 01:05:28,380
another interesting deviation is that

1720
01:05:28,380 --> 01:05:30,839
recall I was talking about the

1721
01:05:30,839 --> 01:05:33,480
identities as CLS certificates I was

1722
01:05:33,480 --> 01:05:34,859
actually lying these are definitely not

1723
01:05:34,859 --> 01:05:37,859
CLS certificates these are actually what

1724
01:05:37,859 --> 01:05:39,359
are known as short credential

1725
01:05:39,359 --> 01:05:41,520
identifiers and to give some rationale

1726
01:05:41,520 --> 01:05:44,400
for this is that a dog assumes that some

1727
01:05:44,400 --> 01:05:46,440
of the devices will be having local

1728
01:05:46,440 --> 01:05:49,500
copies of of the actual certificates and

1729
01:05:49,500 --> 01:05:51,780
in that setting one doesn't need to send

1730
01:05:51,780 --> 01:05:53,520
a certificate anymore on the wire you

1731
01:05:53,520 --> 01:05:56,099
can just send a short identifier for the

1732
01:05:56,099 --> 01:05:58,200
certificate that will then be used for

1733
01:05:58,200 --> 01:06:00,540
authentication and this is another way

1734
01:06:00,540 --> 01:06:02,040
in which headache serves a lot of

1735
01:06:02,040 --> 01:06:04,020
bandwidth

1736
01:06:04,020 --> 01:06:06,660
however the nice an interesting feature

1737
01:06:06,660 --> 01:06:09,059
of this credential identifiers is that

1738
01:06:09,059 --> 01:06:09,900
they

1739
01:06:09,900 --> 01:06:11,700
don't need to be unique in fact they

1740
01:06:11,700 --> 01:06:13,579
could be referencing multiple

1741
01:06:13,579 --> 01:06:16,260
credentials and this is interesting

1742
01:06:16,260 --> 01:06:17,880
consequences

1743
01:06:17,880 --> 01:06:20,040
first of all in terms of functionality

1744
01:06:20,040 --> 01:06:22,740
here whenever the wallet receives an

1745
01:06:22,740 --> 01:06:25,440
identity as a response to its message

1746
01:06:25,440 --> 01:06:27,059
how does it know

1747
01:06:27,059 --> 01:06:29,640
the identity of the of the devices

1748
01:06:29,640 --> 01:06:32,039
trying to communicate with it what the

1749
01:06:32,039 --> 01:06:34,020
other protocol says is that while here

1750
01:06:34,020 --> 01:06:37,020
the wallet will just try in a loop and

1751
01:06:37,020 --> 01:06:39,720
try and verify for each public keys that

1752
01:06:39,720 --> 01:06:41,579
are referenced with the same credential

1753
01:06:41,579 --> 01:06:44,940
identifier until one verifies

1754
01:06:44,940 --> 01:06:47,940
good but one can then Wonder well what

1755
01:06:47,940 --> 01:06:50,880
are the security implications of such

1756
01:06:50,880 --> 01:06:53,819
non-unique credential antifiers and as

1757
01:06:53,819 --> 01:06:55,920
you can see or you can imagine in an

1758
01:06:55,920 --> 01:06:58,319
adversarial setting some of these public

1759
01:06:58,319 --> 01:07:00,299
Keys may actually be adversarially

1760
01:07:00,299 --> 01:07:02,780
controlled

1761
01:07:02,880 --> 01:07:06,420
and indeed you may probably start saying

1762
01:07:06,420 --> 01:07:08,460
that we have we thought we somehow in

1763
01:07:08,460 --> 01:07:10,740
the context of a duplicate signature key

1764
01:07:10,740 --> 01:07:12,240
selection attack

1765
01:07:12,240 --> 01:07:14,599
to just give some context

1766
01:07:14,599 --> 01:07:17,339
recall that the normal unfortability

1767
01:07:17,339 --> 01:07:19,260
notion of signature scheme does not

1768
01:07:19,260 --> 01:07:22,079
imply that for some signature value that

1769
01:07:22,079 --> 01:07:24,599
was honestly generated on some messages

1770
01:07:24,599 --> 01:07:26,819
it's difficult for an attacker to come

1771
01:07:26,819 --> 01:07:28,920
up with a new public key and message

1772
01:07:28,920 --> 01:07:31,980
such that the public key message and

1773
01:07:31,980 --> 01:07:35,119
signature verify

1774
01:07:35,339 --> 01:07:38,099
and this issue actually was pointed out

1775
01:07:38,099 --> 01:07:41,839
to Let's encrypt by Andrew Ayer in 2015

1776
01:07:41,839 --> 01:07:44,339
when he showed that the use of RSA

1777
01:07:44,339 --> 01:07:46,140
certificates for the acne protocol would

1778
01:07:46,140 --> 01:07:49,319
also be vulnerable to dsks attacks

1779
01:07:49,319 --> 01:07:51,900
but what are the consequences of dsks

1780
01:07:51,900 --> 01:07:54,000
attacks for the protocol that we're

1781
01:07:54,000 --> 01:07:57,000
seeing here if we look at how dsks

1782
01:07:57,000 --> 01:07:59,220
attacks would influence the magnan sign

1783
01:07:59,220 --> 01:08:00,900
protocol here

1784
01:08:00,900 --> 01:08:03,780
let's look again at the case of a wallet

1785
01:08:03,780 --> 01:08:07,200
in the bank running a sigma protocol

1786
01:08:07,200 --> 01:08:10,020
so they wanted to initiate the uncheck

1787
01:08:10,020 --> 01:08:13,200
the bank would respond and imagine now

1788
01:08:13,200 --> 01:08:15,839
that when the

1789
01:08:15,839 --> 01:08:17,759
um while it is sending the third message

1790
01:08:17,759 --> 01:08:21,359
we have an attacker who would create a

1791
01:08:21,359 --> 01:08:23,279
new user and register it under some

1792
01:08:23,279 --> 01:08:24,420
identity

1793
01:08:24,420 --> 01:08:28,439
but also the the in crucial facts here

1794
01:08:28,439 --> 01:08:30,179
is that the identity is the same as the

1795
01:08:30,179 --> 01:08:32,520
one used by the wallet right this is

1796
01:08:32,520 --> 01:08:34,738
allowed in the in the model header

1797
01:08:34,738 --> 01:08:36,839
but the nice property is that the public

1798
01:08:36,839 --> 01:08:38,460
key that the attacker registers is

1799
01:08:38,460 --> 01:08:40,140
basically valid for any message and

1800
01:08:40,140 --> 01:08:42,960
signature pairs that that works

1801
01:08:42,960 --> 01:08:47,279
so one decentric concludes what are the

1802
01:08:47,279 --> 01:08:49,859
consequences from the wallet perspective

1803
01:08:49,859 --> 01:08:52,198
it has authenticated the bank and that's

1804
01:08:52,198 --> 01:08:54,120
the identity it thinks that is talking

1805
01:08:54,120 --> 01:08:55,198
to the bank

1806
01:08:55,198 --> 01:08:58,738
but recall that the bank because the

1807
01:08:58,738 --> 01:09:01,259
credential identifier May reference

1808
01:09:01,259 --> 01:09:04,020
multiple public Keys the bank may

1809
01:09:04,020 --> 01:09:06,060
actually hand up verifying first under

1810
01:09:06,060 --> 01:09:08,000
the attacker choose chosen publicly

1811
01:09:08,000 --> 01:09:10,859
which is made to verify every message

1812
01:09:10,859 --> 01:09:12,960
and signature pair

1813
01:09:12,960 --> 01:09:14,880
so here the bank may be thinking at the

1814
01:09:14,880 --> 01:09:17,759
end that it's talking to the user here a

1815
01:09:17,759 --> 01:09:20,580
which is a adversary controlled while

1816
01:09:20,580 --> 01:09:22,198
the wallet thinks that he's talking to

1817
01:09:22,198 --> 01:09:24,439
the bank

1818
01:09:24,540 --> 01:09:27,000
afterwards if the wallet would for

1819
01:09:27,000 --> 01:09:28,979
example send some kind of a voucher so

1820
01:09:28,979 --> 01:09:31,140
that it would receive some money from

1821
01:09:31,140 --> 01:09:33,660
the bank let's say out of a some kind of

1822
01:09:33,660 --> 01:09:37,259
a competition or something because the

1823
01:09:37,259 --> 01:09:39,120
wallet thinks it's talking to user a

1824
01:09:39,120 --> 01:09:41,759
well then it will be sending this money

1825
01:09:41,759 --> 01:09:46,679
to user a instead of the legitimate user

1826
01:09:46,679 --> 01:09:48,839
maybe to give some Precision here the

1827
01:09:48,839 --> 01:09:51,299
issue that is that we're seeing here is

1828
01:09:51,299 --> 01:09:53,819
not necessarily an issue with the Matlin

1829
01:09:53,819 --> 01:09:56,340
sign protocol this issue arises because

1830
01:09:56,340 --> 01:09:58,020
we're considering a much stronger

1831
01:09:58,020 --> 01:09:59,760
attacker model than is usually

1832
01:09:59,760 --> 01:10:04,080
considered for the Magna Ensign protocol

1833
01:10:04,080 --> 01:10:07,140
but so okay so the question is what

1834
01:10:07,140 --> 01:10:09,660
about adopt and is that also Niche for

1835
01:10:09,660 --> 01:10:10,679
edoc

1836
01:10:10,679 --> 01:10:13,140
so fortunately we're able to show that

1837
01:10:13,140 --> 01:10:15,179
this issue is not a problem for edoc and

1838
01:10:15,179 --> 01:10:16,860
edoc actually provide strong

1839
01:10:16,860 --> 01:10:18,840
authentication guarantees even under

1840
01:10:18,840 --> 01:10:21,060
these colliding identifiers

1841
01:10:21,060 --> 01:10:23,159
but for this we have to assume that the

1842
01:10:23,159 --> 01:10:24,840
signature schemes used in haddock

1843
01:10:24,840 --> 01:10:26,580
provide the so-called Universal

1844
01:10:26,580 --> 01:10:29,460
exclusive ownership property

1845
01:10:29,460 --> 01:10:32,159
at a high level the security notion says

1846
01:10:32,159 --> 01:10:34,440
that for a given key pair that is

1847
01:10:34,440 --> 01:10:36,659
honestly generated we have an attacker

1848
01:10:36,659 --> 01:10:39,239
that can receive signatures on chosen

1849
01:10:39,239 --> 01:10:40,140
messages

1850
01:10:40,140 --> 01:10:42,179
and we ask for the attacker to come up

1851
01:10:42,179 --> 01:10:44,520
with a new public key and message that

1852
01:10:44,520 --> 01:10:46,860
will verify with some signatures that

1853
01:10:46,860 --> 01:10:50,340
was obtained previously and obviously

1854
01:10:50,340 --> 01:10:52,860
the adversarially chosen publicly must

1855
01:10:52,860 --> 01:10:56,820
be different than the uh honest one and

1856
01:10:56,820 --> 01:10:59,159
a signature scheme provide suao here

1857
01:10:59,159 --> 01:11:02,340
that's the strong version of the of the

1858
01:11:02,340 --> 01:11:03,960
security guarantee if the attacker

1859
01:11:03,960 --> 01:11:07,100
cannot win in this game

1860
01:11:07,500 --> 01:11:10,400
so zooming out from the authentication

1861
01:11:10,400 --> 01:11:13,860
properties let's paint them much

1862
01:11:13,860 --> 01:11:15,659
complete picture of the security

1863
01:11:15,659 --> 01:11:18,300
guarantees of haddock and to do so we

1864
01:11:18,300 --> 01:11:20,580
use the multi-stage key exchange model

1865
01:11:20,580 --> 01:11:22,800
to analyze haddock it's a key exchange

1866
01:11:22,800 --> 01:11:25,260
model that is fit to

1867
01:11:25,260 --> 01:11:25,860
um

1868
01:11:25,860 --> 01:11:28,140
capture Advanced properties of key

1869
01:11:28,140 --> 01:11:30,600
exchange protocols in our work however

1870
01:11:30,600 --> 01:11:33,060
we extend the msk model by allowing the

1871
01:11:33,060 --> 01:11:35,280
attacker to register new users with

1872
01:11:35,280 --> 01:11:37,080
chosen public keys so they don't have to

1873
01:11:37,080 --> 01:11:39,780
be honestly generated and even further

1874
01:11:39,780 --> 01:11:41,760
we allow the attacker to also control

1875
01:11:41,760 --> 01:11:44,159
the credential identifiers to model

1876
01:11:44,159 --> 01:11:46,080
exactly what's up what can be

1877
01:11:46,080 --> 01:11:49,400
potentially happening in haddock

1878
01:11:49,440 --> 01:11:51,600
for the security goals we target key

1879
01:11:51,600 --> 01:11:53,580
distinguishability of the different keys

1880
01:11:53,580 --> 01:11:56,400
that are derived in network for secrecy

1881
01:11:56,400 --> 01:12:00,739
and also explicit Authentication

1882
01:12:03,120 --> 01:12:04,860
the result of all this is a security

1883
01:12:04,860 --> 01:12:08,040
theorem that shows the msk security of

1884
01:12:08,040 --> 01:12:10,020
haddock I'm not going into detail but

1885
01:12:10,020 --> 01:12:11,940
essentially a way to read this is that

1886
01:12:11,940 --> 01:12:14,820
we can show adult to be mskv secure and

1887
01:12:14,820 --> 01:12:17,520
this security reduces to the components

1888
01:12:17,520 --> 01:12:19,800
used in edoc namely a collision

1889
01:12:19,800 --> 01:12:22,320
resistance function signature schemes

1890
01:12:22,320 --> 01:12:24,300
that provide strong and for durability

1891
01:12:24,300 --> 01:12:26,400
the Estuary notion that we've seen

1892
01:12:26,400 --> 01:12:31,320
previously the normal unfavorability

1893
01:12:31,500 --> 01:12:33,840
but also we rely on the prf or DS

1894
01:12:33,840 --> 01:12:35,400
assumption and the period of assumption

1895
01:12:35,400 --> 01:12:37,739
for the key derivation functions used in

1896
01:12:37,739 --> 01:12:39,900
edoc

1897
01:12:39,900 --> 01:12:41,699
right but something that jumped out

1898
01:12:41,699 --> 01:12:43,020
before

1899
01:12:43,020 --> 01:12:44,520
um although we've seen that teddock

1900
01:12:44,520 --> 01:12:46,679
instantiate those schemes in the sound

1901
01:12:46,679 --> 01:12:48,960
manner something on jobsite is that edoc

1902
01:12:48,960 --> 01:12:51,480
uses ecdsa which is not known to provide

1903
01:12:51,480 --> 01:12:54,420
neither s3fcma nor

1904
01:12:54,420 --> 01:12:58,320
um s3ao however we think that ecdsa is

1905
01:12:58,320 --> 01:13:00,719
probably likely fine for edoc because

1906
01:13:00,719 --> 01:13:03,840
for the S the question of s3o

1907
01:13:03,840 --> 01:13:06,120
um the one of the details that I missed

1908
01:13:06,120 --> 01:13:07,980
was that edoch actually signed the

1909
01:13:07,980 --> 01:13:09,480
public key

1910
01:13:09,480 --> 01:13:11,520
um along every message that is being

1911
01:13:11,520 --> 01:13:13,140
signed so including the Mac which

1912
01:13:13,140 --> 01:13:15,960
normally should be known to provide srio

1913
01:13:15,960 --> 01:13:19,440
security and for s3fcma probably the

1914
01:13:19,440 --> 01:13:21,239
implementation could be changed to use

1915
01:13:21,239 --> 01:13:23,820
canonical signatures and avoid of

1916
01:13:23,820 --> 01:13:26,900
malleability issues

1917
01:13:27,840 --> 01:13:30,480
good so now let me sort of finish with a

1918
01:13:30,480 --> 01:13:32,580
short discussion of our interaction with

1919
01:13:32,580 --> 01:13:35,340
the working group at the ITF

1920
01:13:35,340 --> 01:13:38,280
the lake working group sent us a call to

1921
01:13:38,280 --> 01:13:40,920
the crypto Community for an analysis of

1922
01:13:40,920 --> 01:13:43,320
the edoc protocol and in doing so they

1923
01:13:43,320 --> 01:13:45,480
created an environment that was really

1924
01:13:45,480 --> 01:13:47,159
hoping for

1925
01:13:47,159 --> 01:13:49,920
um inputs and security analysis and for

1926
01:13:49,920 --> 01:13:52,380
this reason adoc benefited for from

1927
01:13:52,380 --> 01:13:54,719
numerous analysis both in the

1928
01:13:54,719 --> 01:13:57,120
computational but also in the symbolic

1929
01:13:57,120 --> 01:13:58,679
setting

1930
01:13:58,679 --> 01:14:00,659
and this type of Highly collaborative

1931
01:14:00,659 --> 01:14:03,719
environment is really reminiscent of the

1932
01:14:03,719 --> 01:14:06,239
development of CLS 1.3 and it's really

1933
01:14:06,239 --> 01:14:07,640
my hope that

1934
01:14:07,640 --> 01:14:10,980
moving forward all these protocols that

1935
01:14:10,980 --> 01:14:12,480
are widely used can continue being

1936
01:14:12,480 --> 01:14:14,040
developed in such a highly collaborative

1937
01:14:14,040 --> 01:14:16,739
setting

1938
01:14:16,739 --> 01:14:18,659
from our perspective though working on

1939
01:14:18,659 --> 01:14:20,219
network really felt like chasing a

1940
01:14:20,219 --> 01:14:22,860
moving Target so we worked through six

1941
01:14:22,860 --> 01:14:25,020
different drafts um during my master

1942
01:14:25,020 --> 01:14:27,420
thesis and also a bit later

1943
01:14:27,420 --> 01:14:30,179
um and I think in the real world in such

1944
01:14:30,179 --> 01:14:33,060
a fast-moving environment we we would

1945
01:14:33,060 --> 01:14:36,120
really have higher confidence in our in

1946
01:14:36,120 --> 01:14:38,580
our proofs if we also would have

1947
01:14:38,580 --> 01:14:41,640
automated tooling to confirm our

1948
01:14:41,640 --> 01:14:43,679
analysis and I hope these people working

1949
01:14:43,679 --> 01:14:46,920
on the usability of proof tools

1950
01:14:46,920 --> 01:14:49,080
um can really see the incentive of

1951
01:14:49,080 --> 01:14:51,980
continuing doing that

1952
01:14:52,020 --> 01:14:53,940
right and just an overview of our

1953
01:14:53,940 --> 01:14:56,760
contributions that also stem stem from

1954
01:14:56,760 --> 01:14:58,920
the Insight that regards in our analysis

1955
01:14:58,920 --> 01:15:02,460
we first of all recommended that edoc

1956
01:15:02,460 --> 01:15:05,340
would use a dedicated session key and

1957
01:15:05,340 --> 01:15:07,199
this was done in accordance with with

1958
01:15:07,199 --> 01:15:09,239
other team as well who agreed with this

1959
01:15:09,239 --> 01:15:10,400
recommendation

1960
01:15:10,400 --> 01:15:13,080
we proposed that tedock would change the

1961
01:15:13,080 --> 01:15:14,699
way that it's Computing transcript

1962
01:15:14,699 --> 01:15:18,239
hashes both to prevent the type of dsks

1963
01:15:18,239 --> 01:15:19,380
attacks that we've that we've seen

1964
01:15:19,380 --> 01:15:22,020
before but also for provable security

1965
01:15:22,020 --> 01:15:23,280
reasons

1966
01:15:23,280 --> 01:15:25,280
um and for a similar reason we also

1967
01:15:25,280 --> 01:15:28,199
recommended that edoc would separate the

1968
01:15:28,199 --> 01:15:30,780
keys in its key derivation schedule for

1969
01:15:30,780 --> 01:15:35,000
Global security reasons as well

1970
01:15:35,580 --> 01:15:38,040
so in conclusion we've seen that edoc is

1971
01:15:38,040 --> 01:15:39,360
an ambitious

1972
01:15:39,360 --> 01:15:42,780
um answer to a very timely question and

1973
01:15:42,780 --> 01:15:45,360
issue but however edoc in its design

1974
01:15:45,360 --> 01:15:47,400
brings some security challenges

1975
01:15:47,400 --> 01:15:49,920
and for this reason we introduce a

1976
01:15:49,920 --> 01:15:52,400
strong security model that would be

1977
01:15:52,400 --> 01:15:55,500
appropriate for the lake or lightweight

1978
01:15:55,500 --> 01:15:58,500
authenticated exchange setting

1979
01:15:58,500 --> 01:16:02,400
we do a security analysis and show a

1980
01:16:02,400 --> 01:16:04,560
proof that edoc is secure in our strong

1981
01:16:04,560 --> 01:16:06,900
in the strong model that we that we that

1982
01:16:06,900 --> 01:16:07,980
we suggest

1983
01:16:07,980 --> 01:16:10,679
and based on the insights that we

1984
01:16:10,679 --> 01:16:12,239
received from our analysis we also

1985
01:16:12,239 --> 01:16:15,239
propose design changes to to edoc

1986
01:16:15,239 --> 01:16:17,820
and also I've I highlighted how all of

1987
01:16:17,820 --> 01:16:19,320
this was possible thanks to the lake

1988
01:16:19,320 --> 01:16:21,900
working group and their highly welcoming

1989
01:16:21,900 --> 01:16:24,500
environment

1990
01:16:24,960 --> 01:16:27,900
our results how to appear are to use SNP

1991
01:16:27,900 --> 01:16:30,000
this year I have a copy of the papers

1992
01:16:30,000 --> 01:16:32,100
already on aprint and if you have any

1993
01:16:32,100 --> 01:16:34,739
questions for later on uh here's my

1994
01:16:34,739 --> 01:16:37,199
contact and I'm happy to discuss this

1995
01:16:37,199 --> 01:16:38,940
any further

1996
01:16:38,940 --> 01:16:40,860
so with that said thank you for

1997
01:16:40,860 --> 01:16:42,360
attention and I'm happy to take

1998
01:16:42,360 --> 01:16:44,719
questions

1999
01:16:51,719 --> 01:16:54,540
thank you Mark are there any questions

2000
01:16:54,540 --> 01:16:57,140
foreign

2001
01:16:57,940 --> 01:16:59,340
[Music]

2002
01:16:59,340 --> 01:17:01,140
I have a quick question does your

2003
01:17:01,140 --> 01:17:03,360
analysis hold for the latest draft of

2004
01:17:03,360 --> 01:17:05,820
the protocol the the and is this

2005
01:17:05,820 --> 01:17:07,679
protocol close to being finalized or

2006
01:17:07,679 --> 01:17:08,820
published

2007
01:17:08,820 --> 01:17:10,620
that's a good question

2008
01:17:10,620 --> 01:17:12,480
um actually edoc now is in draft version

2009
01:17:12,480 --> 01:17:15,900
17 19 sorry and our work was targeting

2010
01:17:15,900 --> 01:17:18,900
draft 17 which again attest to the fast

2011
01:17:18,900 --> 01:17:22,500
moving development yeah and have there

2012
01:17:22,500 --> 01:17:24,360
been substantial changes between draft

2013
01:17:24,360 --> 01:17:26,100
17 and 19 that you'll have to

2014
01:17:26,100 --> 01:17:29,100
accommodate or not so we haven't uh

2015
01:17:29,100 --> 01:17:31,920
closely looked at the changes yet

2016
01:17:31,920 --> 01:17:35,820
um so I I would not be able to answer

2017
01:17:35,820 --> 01:17:38,219
something

2018
01:17:38,219 --> 01:17:41,040
any other questions

2019
01:17:41,040 --> 01:17:43,699
all right okay

2020
01:17:43,980 --> 01:17:46,519
winmark

2021
01:17:50,580 --> 01:17:52,980
okay go and enjoy a well-deserved coffee

2022
01:17:52,980 --> 01:17:56,718
break and we start again at four

