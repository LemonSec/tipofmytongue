1
00:00:00,000 --> 00:00:03,060
the second last session of real world

2
00:00:03,060 --> 00:00:06,240
crypto this is for threshold

3
00:00:06,240 --> 00:00:08,820
cryptography and we have three talks

4
00:00:08,820 --> 00:00:11,000
here

5
00:00:11,460 --> 00:00:14,240
okay the

6
00:00:14,580 --> 00:00:17,540
let's see

7
00:00:18,960 --> 00:00:21,240
okay the first one is from Theory to

8
00:00:21,240 --> 00:00:23,699
practice to Theory Lessons Learned From

9
00:00:23,699 --> 00:00:26,039
multi-partitional signatures and all

10
00:00:26,039 --> 00:00:29,099
three uh authors co-authors are on stage

11
00:00:29,099 --> 00:00:33,360
and the talk is uh it's a Elizabeth and

12
00:00:33,360 --> 00:00:35,040
Chelsea and Tim

13
00:00:35,040 --> 00:00:38,719
speaks please

14
00:01:00,000 --> 00:01:02,760
so schnur's signatures were invented in

15
00:01:02,760 --> 00:01:06,360
1990 by Klaus Peter Schnur and were

16
00:01:06,360 --> 00:01:09,900
subsequently patented in 1991.

17
00:01:09,900 --> 00:01:12,479
in 2001 we see the first multi-party

18
00:01:12,479 --> 00:01:15,540
Schnur scheme by Stinson and Strobel and

19
00:01:15,540 --> 00:01:17,640
then in 2008 the patent for sure

20
00:01:17,640 --> 00:01:20,280
signatures expired

21
00:01:20,280 --> 00:01:22,799
moving ahead to 2018 we see the first

22
00:01:22,799 --> 00:01:25,920
three round multi-party Schnur schemes

23
00:01:25,920 --> 00:01:29,100
and in 2020 we have two uh round

24
00:01:29,100 --> 00:01:30,960
multi-party snore schemes such as Music

25
00:01:30,960 --> 00:01:34,860
2 dwms and frost

26
00:01:34,860 --> 00:01:38,100
in 2021 we introduced Frost 2 an

27
00:01:38,100 --> 00:01:40,560
improved proof for Frost

28
00:01:40,560 --> 00:01:44,700
also in 2021 they started a frost cfrg

29
00:01:44,700 --> 00:01:48,000
draft and Bitcoin moved away from ecdsa

30
00:01:48,000 --> 00:01:51,299
to Schnur signatures

31
00:01:51,299 --> 00:01:55,140
in August of last year nist standardized

32
00:01:55,140 --> 00:01:58,200
eddsa which is a deterministic version

33
00:01:58,200 --> 00:01:59,700
of schnor

34
00:01:59,700 --> 00:02:02,340
and earlier this year nist put out an

35
00:02:02,340 --> 00:02:05,340
initial public call for threshold

36
00:02:05,340 --> 00:02:07,880
schemes

37
00:02:08,160 --> 00:02:10,258
so let's first recall what a Schnur

38
00:02:10,258 --> 00:02:11,940
signature looks like

39
00:02:11,940 --> 00:02:13,980
so the signer here Alice is going to

40
00:02:13,980 --> 00:02:16,739
form her public key as some generator

41
00:02:16,739 --> 00:02:19,739
raised to a field element which is her

42
00:02:19,739 --> 00:02:21,480
secret key

43
00:02:21,480 --> 00:02:23,400
and in order to sign a message she's

44
00:02:23,400 --> 00:02:25,739
going to sample some nonce uniformly at

45
00:02:25,739 --> 00:02:28,379
random and take the generator raised to

46
00:02:28,379 --> 00:02:30,180
this nonce value here I'm using

47
00:02:30,180 --> 00:02:31,680
multiplicative notation but this would

48
00:02:31,680 --> 00:02:33,780
be an elliptic curve group so additive

49
00:02:33,780 --> 00:02:35,940
is usually common

50
00:02:35,940 --> 00:02:38,040
again it's a nonce so it's a number used

51
00:02:38,040 --> 00:02:40,080
only once you need a fresh nonce for

52
00:02:40,080 --> 00:02:42,420
every message that you sign

53
00:02:42,420 --> 00:02:44,099
at this point you can form the challenge

54
00:02:44,099 --> 00:02:46,860
which is a hash of the public key the

55
00:02:46,860 --> 00:02:49,200
message and the nonce and then the

56
00:02:49,200 --> 00:02:52,019
signature Zed is formed the nonce plus

57
00:02:52,019 --> 00:02:54,599
the challenge times the secret key so

58
00:02:54,599 --> 00:02:58,459
this non's value blinds the secret key

59
00:02:58,500 --> 00:03:00,959
the verifier can also compute this hash

60
00:03:00,959 --> 00:03:04,140
value and then check the verification of

61
00:03:04,140 --> 00:03:06,120
the Schnur signature as follows so you

62
00:03:06,120 --> 00:03:07,800
can see that this is just the same as

63
00:03:07,800 --> 00:03:10,940
the equation for Z

64
00:03:11,340 --> 00:03:13,440
now when I say multi-party Schnur what I

65
00:03:13,440 --> 00:03:15,620
mean is threshold signatures or

66
00:03:15,620 --> 00:03:18,000
multi-signatures and in a threshold

67
00:03:18,000 --> 00:03:20,280
scheme you have t out of n parties who

68
00:03:20,280 --> 00:03:22,620
are jointly signing the message

69
00:03:22,620 --> 00:03:24,360
usually there is a trusted key

70
00:03:24,360 --> 00:03:26,340
generation algorithm which can be Shamir

71
00:03:26,340 --> 00:03:28,560
secret sharing or you could have a

72
00:03:28,560 --> 00:03:32,060
distributed key generation protocol

73
00:03:33,300 --> 00:03:34,920
multi signatures on the other hand

74
00:03:34,920 --> 00:03:37,860
require all end parties to sign but they

75
00:03:37,860 --> 00:03:39,360
have this nice feature in that you can

76
00:03:39,360 --> 00:03:41,220
aggregate the public keys and this

77
00:03:41,220 --> 00:03:43,560
allows the signing set to be formed on

78
00:03:43,560 --> 00:03:45,540
the Fly

79
00:03:45,540 --> 00:03:47,519
foreign

80
00:03:47,519 --> 00:03:50,099
taking a closer look at the signature

81
00:03:50,099 --> 00:03:52,920
scheme looking at the value Z here we

82
00:03:52,920 --> 00:03:55,620
I've talked about ways to share the

83
00:03:55,620 --> 00:03:58,019
secret key amongst a set of parties and

84
00:03:58,019 --> 00:03:59,159
note that these parties never

85
00:03:59,159 --> 00:04:01,680
reconstruct that secret key

86
00:04:01,680 --> 00:04:03,720
but we also need some way to share the

87
00:04:03,720 --> 00:04:06,180
nonce amongst the set of signers no

88
00:04:06,180 --> 00:04:07,799
party individually can know the non so

89
00:04:07,799 --> 00:04:11,060
they can extract the secret key

90
00:04:11,580 --> 00:04:14,099
so what do we want we want a multi-party

91
00:04:14,099 --> 00:04:16,620
scheme that verifies exactly like

92
00:04:16,620 --> 00:04:19,320
standard single party snore and in

93
00:04:19,320 --> 00:04:20,820
particular we want the public key to

94
00:04:20,820 --> 00:04:22,979
look exactly like a standard single

95
00:04:22,979 --> 00:04:25,800
party Schnur public key

96
00:04:25,800 --> 00:04:27,900
we also want few signing rounds and here

97
00:04:27,900 --> 00:04:29,580
we'll be looking at two and three round

98
00:04:29,580 --> 00:04:31,979
schemes we note that the scheme by

99
00:04:31,979 --> 00:04:34,080
Stinson and Strobel used a distributed

100
00:04:34,080 --> 00:04:35,940
key generation protocol to form the

101
00:04:35,940 --> 00:04:38,759
nonce so this added several rounds

102
00:04:38,759 --> 00:04:40,380
we also want reasonable security

103
00:04:40,380 --> 00:04:42,240
assumptions which I'll talk about in a

104
00:04:42,240 --> 00:04:44,340
minute and concurrent security which is

105
00:04:44,340 --> 00:04:46,919
really important in practice because in

106
00:04:46,919 --> 00:04:48,900
practice it's an adversary could

107
00:04:48,900 --> 00:04:50,880
potentially open multiple signing

108
00:04:50,880 --> 00:04:53,780
sessions at once

109
00:04:54,419 --> 00:04:57,360
here's a high level overview of some of

110
00:04:57,360 --> 00:04:59,419
the schemes so we have the three round

111
00:04:59,419 --> 00:05:01,860
multi-signature schemes like music

112
00:05:01,860 --> 00:05:04,020
and then the two round multi-signature

113
00:05:04,020 --> 00:05:06,720
schemes such as Music 2 dwms Speedy

114
00:05:06,720 --> 00:05:07,680
music

115
00:05:07,680 --> 00:05:09,479
we also have three and two round

116
00:05:09,479 --> 00:05:12,780
threshold schemes so sparkle Frost and

117
00:05:12,780 --> 00:05:14,759
frost 2. and what I want to highlight

118
00:05:14,759 --> 00:05:16,979
here is that the two round schemes are

119
00:05:16,979 --> 00:05:19,320
proven under the one more discrete

120
00:05:19,320 --> 00:05:21,780
logarithm assumption which is a strong a

121
00:05:21,780 --> 00:05:23,940
strictly stronger notion than discrete

122
00:05:23,940 --> 00:05:25,139
logarithm so what this means is

123
00:05:25,139 --> 00:05:27,419
potentially it's easier to break omdl

124
00:05:27,419 --> 00:05:29,220
than DL which is a very standard

125
00:05:29,220 --> 00:05:30,240
assumption

126
00:05:30,240 --> 00:05:32,820
however we get a really nice trade-off

127
00:05:32,820 --> 00:05:35,039
here because the two round schemes are

128
00:05:35,039 --> 00:05:37,259
actually essentially non-interactive so

129
00:05:37,259 --> 00:05:39,419
the first round can be pre-processed and

130
00:05:39,419 --> 00:05:42,600
then it's essentially one signing round

131
00:05:42,600 --> 00:05:44,580
all of the schemes I show here are

132
00:05:44,580 --> 00:05:46,199
concurrently secure now what does that

133
00:05:46,199 --> 00:05:48,440
mean

134
00:05:48,660 --> 00:05:51,539
so an adversary could potentially open a

135
00:05:51,539 --> 00:05:52,979
number of different signing sessions

136
00:05:52,979 --> 00:05:54,479
here I'm just considering one

137
00:05:54,479 --> 00:05:56,699
adversarial signer with an honest signer

138
00:05:56,699 --> 00:05:59,220
Alice so they can open k signing

139
00:05:59,220 --> 00:06:01,560
sessions at once what the adversary can

140
00:06:01,560 --> 00:06:04,139
do is they can wait to see Alice's

141
00:06:04,139 --> 00:06:06,600
nonses so Alice outputs her nonses in

142
00:06:06,600 --> 00:06:08,100
each session and then a rushing

143
00:06:08,100 --> 00:06:10,320
adversary can wait and output its

144
00:06:10,320 --> 00:06:12,180
nonsense

145
00:06:12,180 --> 00:06:14,520
this allows the adversary to forge a

146
00:06:14,520 --> 00:06:16,860
signature and these concurrent attacks

147
00:06:16,860 --> 00:06:19,139
affected a number of multi-signatures

148
00:06:19,139 --> 00:06:21,539
threshold signatures and blind signature

149
00:06:21,539 --> 00:06:22,620
schemes

150
00:06:22,620 --> 00:06:24,720
so what we need here is some way for the

151
00:06:24,720 --> 00:06:27,060
adversary to kind of have to commit to

152
00:06:27,060 --> 00:06:29,220
its nonsense this attack relies on the

153
00:06:29,220 --> 00:06:31,020
fact that the adversary sees the honest

154
00:06:31,020 --> 00:06:32,639
nonsense and then can do something

155
00:06:32,639 --> 00:06:35,759
clever to form its own nonses

156
00:06:35,759 --> 00:06:37,740
so this gives some background for uh

157
00:06:37,740 --> 00:06:39,120
what we're going to see is the structure

158
00:06:39,120 --> 00:06:41,759
of the two round scheme so here uh music

159
00:06:41,759 --> 00:06:44,400
2 Speedy music Frost and frost 2 they

160
00:06:44,400 --> 00:06:46,680
all share a similar structure

161
00:06:46,680 --> 00:06:49,259
so first in the key generation you might

162
00:06:49,259 --> 00:06:50,759
have your trusted key generation

163
00:06:50,759 --> 00:06:52,380
distributed key generation key

164
00:06:52,380 --> 00:06:54,300
aggregation depending on the scheme but

165
00:06:54,300 --> 00:06:55,919
everybody's going to have some share of

166
00:06:55,919 --> 00:06:58,020
the overall public key representing the

167
00:06:58,020 --> 00:07:00,720
set of ensigners

168
00:07:00,720 --> 00:07:02,699
in order to sign we're now going to use

169
00:07:02,699 --> 00:07:04,680
two nonses so recall for single party

170
00:07:04,680 --> 00:07:06,840
store we just had the one knots R now

171
00:07:06,840 --> 00:07:08,340
we're going to have s as well so

172
00:07:08,340 --> 00:07:10,740
everybody who's participating outputs

173
00:07:10,740 --> 00:07:13,680
these two nonses

174
00:07:13,680 --> 00:07:15,419
in round two they're now going to form

175
00:07:15,419 --> 00:07:17,940
this hash which takes us and put the

176
00:07:17,940 --> 00:07:19,560
public key that represents all the

177
00:07:19,560 --> 00:07:22,139
signers the message and the entire list

178
00:07:22,139 --> 00:07:24,120
of the nonses for all of the signers

179
00:07:24,120 --> 00:07:26,160
involved so this is what I mean by kind

180
00:07:26,160 --> 00:07:27,660
of committing to the nonses the

181
00:07:27,660 --> 00:07:29,460
adversary can't form that concurrent

182
00:07:29,460 --> 00:07:31,020
attack because everything is getting

183
00:07:31,020 --> 00:07:32,460
hashed

184
00:07:32,460 --> 00:07:34,380
then the aggregate knots representing

185
00:07:34,380 --> 00:07:36,900
the signing set is the product of RS

186
00:07:36,900 --> 00:07:39,120
raised to this hash value a this

187
00:07:39,120 --> 00:07:40,560
non-linearity is important because if

188
00:07:40,560 --> 00:07:42,180
you just had R to the a you could just

189
00:07:42,180 --> 00:07:43,680
cancel it out

190
00:07:43,680 --> 00:07:46,319
now everybody forms the hash of the

191
00:07:46,319 --> 00:07:48,479
public key message and aggregate nonce

192
00:07:48,479 --> 00:07:50,520
which looks exactly like single party

193
00:07:50,520 --> 00:07:52,860
snore and then they output their partial

194
00:07:52,860 --> 00:07:55,139
signatures so it's said I which is the

195
00:07:55,139 --> 00:07:57,599
combination of the nonses plus the

196
00:07:57,599 --> 00:07:59,460
challenge times the secret key so

197
00:07:59,460 --> 00:08:01,860
everybody outputs these values at I and

198
00:08:01,860 --> 00:08:03,960
then you can have a combiner so here I'm

199
00:08:03,960 --> 00:08:05,220
representing the combiner and the

200
00:08:05,220 --> 00:08:07,500
verifier is the same party because the

201
00:08:07,500 --> 00:08:09,599
combiner can be anyone and basically

202
00:08:09,599 --> 00:08:12,419
they just take all of the Z values from

203
00:08:12,419 --> 00:08:14,699
all the parties add them up and then the

204
00:08:14,699 --> 00:08:16,319
final signature consists of this

205
00:08:16,319 --> 00:08:18,960
aggregate value R and z

206
00:08:18,960 --> 00:08:21,539
they compute the hash themselves and we

207
00:08:21,539 --> 00:08:23,160
have standard single party snore

208
00:08:23,160 --> 00:08:25,759
verification

209
00:08:26,160 --> 00:08:28,020
now I talked about concurrent security

210
00:08:28,020 --> 00:08:30,120
but another important aspect of security

211
00:08:30,120 --> 00:08:32,820
is adaptive corruption so usually when

212
00:08:32,820 --> 00:08:34,979
threshold schemes are proven we prove

213
00:08:34,979 --> 00:08:36,599
static security and what this means is

214
00:08:36,599 --> 00:08:38,339
that the adversary has to corrupt

215
00:08:38,339 --> 00:08:39,719
parties at the beginning of the protocol

216
00:08:39,719 --> 00:08:42,599
and then the signing rounds commence but

217
00:08:42,599 --> 00:08:44,820
the stronger adaptive adversary can

218
00:08:44,820 --> 00:08:46,860
actually corrupt parties as the protocol

219
00:08:46,860 --> 00:08:49,560
progresses so here the adversary can

220
00:08:49,560 --> 00:08:51,660
corrupt the third party and then at some

221
00:08:51,660 --> 00:08:53,160
point during signing they can corrupt

222
00:08:53,160 --> 00:08:55,860
the second party Bob here and this is a

223
00:08:55,860 --> 00:08:57,480
really a strong notion of security

224
00:08:57,480 --> 00:09:00,000
because you have to Output that party's

225
00:09:00,000 --> 00:09:01,740
secret key but you also have to Output

226
00:09:01,740 --> 00:09:03,120
the state of everything that has

227
00:09:03,120 --> 00:09:05,160
happened so far

228
00:09:05,160 --> 00:09:07,019
and we were able to show adaptive

229
00:09:07,019 --> 00:09:08,940
security of Sparkle which is our three

230
00:09:08,940 --> 00:09:11,399
round threshold signature and we're also

231
00:09:11,399 --> 00:09:15,300
uh working on the proof for Frost

232
00:09:15,300 --> 00:09:16,740
so now we'll talk about some more

233
00:09:16,740 --> 00:09:18,600
practical aspects of our work and I'll

234
00:09:18,600 --> 00:09:22,459
hand it over to Tim Tim take it away

235
00:09:24,480 --> 00:09:28,560
hey thanks uh this for for the first one

236
00:09:28,560 --> 00:09:30,060
um so um

237
00:09:30,060 --> 00:09:34,440
we've seen all these schemes now and you

238
00:09:34,440 --> 00:09:35,880
presented the list of all these schemes

239
00:09:35,880 --> 00:09:38,220
and now if you if you want to use those

240
00:09:38,220 --> 00:09:40,860
schemes and practice the one of the

241
00:09:40,860 --> 00:09:42,360
obvious questions you can ask us okay

242
00:09:42,360 --> 00:09:44,220
but one of which of these schemes should

243
00:09:44,220 --> 00:09:46,019
I actually use in practice right

244
00:09:46,019 --> 00:09:49,920
and to get an Insight here we have to

245
00:09:49,920 --> 00:09:51,300
look at the properties that we expect

246
00:09:51,300 --> 00:09:53,459
from a multi-party threshold from a

247
00:09:53,459 --> 00:09:55,140
multi-partitional signature scheme so

248
00:09:55,140 --> 00:09:56,940
the first property we obviously want is

249
00:09:56,940 --> 00:09:58,620
unforgibility which just means that you

250
00:09:58,620 --> 00:10:00,779
take account Forge signatures but

251
00:10:00,779 --> 00:10:03,660
there's always a another property that

252
00:10:03,660 --> 00:10:05,940
turns up in some form in your system

253
00:10:05,940 --> 00:10:07,800
which is liveness so you should also be

254
00:10:07,800 --> 00:10:10,100
able to create signatures always

255
00:10:10,100 --> 00:10:12,600
otherwise you just lose functionality

256
00:10:12,600 --> 00:10:14,040
and you can't make progress in your

257
00:10:14,040 --> 00:10:15,180
system

258
00:10:15,180 --> 00:10:17,880
and um with that in mind we can ask the

259
00:10:17,880 --> 00:10:19,440
question

260
00:10:19,440 --> 00:10:19,980
um

261
00:10:19,980 --> 00:10:22,500
should I use a multi-signature schema or

262
00:10:22,500 --> 00:10:24,360
should I use a threshold signature

263
00:10:24,360 --> 00:10:26,100
scheme in practice

264
00:10:26,100 --> 00:10:28,019
and the first observation we can make

265
00:10:28,019 --> 00:10:30,660
here is that multi-signatures do not

266
00:10:30,660 --> 00:10:32,339
guarantee liveness so because it's

267
00:10:32,339 --> 00:10:35,120
inherently an N of n setup

268
00:10:35,120 --> 00:10:37,860
Whenever there is one signer who is

269
00:10:37,860 --> 00:10:39,839
malicious or just not available signing

270
00:10:39,839 --> 00:10:42,740
is not possible so that this looks like

271
00:10:42,740 --> 00:10:44,700
multi-signatures are actually not a good

272
00:10:44,700 --> 00:10:46,740
idea at all but this really depends on

273
00:10:46,740 --> 00:10:47,760
the setting

274
00:10:47,760 --> 00:10:50,880
for example in if in your system where

275
00:10:50,880 --> 00:10:53,519
you use your multi-party signature you

276
00:10:53,519 --> 00:10:54,899
have some other layer where you can

277
00:10:54,899 --> 00:10:58,079
handle this case where you can't make a

278
00:10:58,079 --> 00:10:59,279
signature

279
00:10:59,279 --> 00:11:00,959
then it might be totally okay to use

280
00:11:00,959 --> 00:11:04,019
multi-six and the prime example here is

281
00:11:04,019 --> 00:11:04,980
um

282
00:11:04,980 --> 00:11:08,279
usually in cryptocurrencies where if you

283
00:11:08,279 --> 00:11:10,380
if you want to do Advanced functionality

284
00:11:10,380 --> 00:11:12,180
some people call this a smart contract

285
00:11:12,180 --> 00:11:14,940
for example you usually have the case

286
00:11:14,940 --> 00:11:17,040
that multiple parties commit their funds

287
00:11:17,040 --> 00:11:18,420
to a single output on the blockchain

288
00:11:18,420 --> 00:11:21,240
such that they can only spend the funds

289
00:11:21,240 --> 00:11:22,800
if they all agree and this condition

290
00:11:22,800 --> 00:11:24,720
that they all agree is exactly what we

291
00:11:24,720 --> 00:11:27,240
can express on the multi-sig

292
00:11:27,240 --> 00:11:30,839
and for example this happens in in

293
00:11:30,839 --> 00:11:33,060
Bitcoin in the lightning Network which

294
00:11:33,060 --> 00:11:34,920
is a payment Channel network and the

295
00:11:34,920 --> 00:11:36,000
payment Channel

296
00:11:36,000 --> 00:11:37,920
um is a channel between two parties

297
00:11:37,920 --> 00:11:39,420
where they commit their money and then

298
00:11:39,420 --> 00:11:41,760
they can make faster payments without

299
00:11:41,760 --> 00:11:43,920
hitting the blockchain

300
00:11:43,920 --> 00:11:46,440
and um in such a construction you always

301
00:11:46,440 --> 00:11:48,779
anyway need some fallback mechanism if

302
00:11:48,779 --> 00:11:51,839
one signer disappears or gets malicious

303
00:11:51,839 --> 00:11:53,760
that the other designer is able to get

304
00:11:53,760 --> 00:11:55,440
their money back and because you have

305
00:11:55,440 --> 00:11:58,500
this this fallback mechanism anyway in

306
00:11:58,500 --> 00:11:59,880
your system after some time out the

307
00:11:59,880 --> 00:12:01,740
other party will get the party will get

308
00:12:01,740 --> 00:12:04,019
the funds back it's it's not a problem

309
00:12:04,019 --> 00:12:06,240
that you use multi-6 and you can handle

310
00:12:06,240 --> 00:12:07,800
this case just on a different layer of

311
00:12:07,800 --> 00:12:08,760
the system

312
00:12:08,760 --> 00:12:11,820
and then the advantage is then of course

313
00:12:11,820 --> 00:12:12,899
that you can make use of the

314
00:12:12,899 --> 00:12:14,339
non-interactive key aggregation you

315
00:12:14,339 --> 00:12:16,440
don't have to resort to

316
00:12:16,440 --> 00:12:18,720
um distributed key generation but if you

317
00:12:18,720 --> 00:12:19,980
don't have this fallback in your system

318
00:12:19,980 --> 00:12:22,200
or you just don't want to use it then

319
00:12:22,200 --> 00:12:24,540
you need to use a full threshold

320
00:12:24,540 --> 00:12:26,220
signature scheme and then usually what

321
00:12:26,220 --> 00:12:28,380
you want to do is run it in distributed

322
00:12:28,380 --> 00:12:30,360
key generation algorithm

323
00:12:30,360 --> 00:12:34,140
and one issue is that these tkgs turn

324
00:12:34,140 --> 00:12:37,140
out to be cumbersome in practice

325
00:12:37,140 --> 00:12:40,079
um and there are multiple points where

326
00:12:40,079 --> 00:12:42,180
um they can be complicated but there's

327
00:12:42,180 --> 00:12:43,860
just one point we want to highlight here

328
00:12:43,860 --> 00:12:46,740
is and this is that um dkgs always

329
00:12:46,740 --> 00:12:48,779
require some form of broadcast channel

330
00:12:48,779 --> 00:12:51,240
and often this is kind of very implicit

331
00:12:51,240 --> 00:12:52,860
in the protocol descriptions if you look

332
00:12:52,860 --> 00:12:55,320
at the paper it there's just a sentence

333
00:12:55,320 --> 00:12:57,000
that says okay like every every

334
00:12:57,000 --> 00:12:58,980
communication happens over a reliable

335
00:12:58,980 --> 00:13:01,260
broadcast channel and what they actually

336
00:13:01,260 --> 00:13:03,600
mean here is consensus or bft so very

337
00:13:03,600 --> 00:13:05,459
strong requirement and if you if you

338
00:13:05,459 --> 00:13:07,680
then look at implementations it seems

339
00:13:07,680 --> 00:13:09,660
that they tend to don't understand this

340
00:13:09,660 --> 00:13:12,600
or ignore the suspect and so there is

341
00:13:12,600 --> 00:13:15,120
certainly also much something we could

342
00:13:15,120 --> 00:13:16,680
do on our side to improve those

343
00:13:16,680 --> 00:13:18,540
constructions or maybe give better

344
00:13:18,540 --> 00:13:20,399
guideline to guidelines to implement

345
00:13:20,399 --> 00:13:22,500
this but at the moment

346
00:13:22,500 --> 00:13:24,240
um this is just a point where people

347
00:13:24,240 --> 00:13:26,579
need to be careful

348
00:13:26,579 --> 00:13:29,040
and another another question you can ask

349
00:13:29,040 --> 00:13:31,260
now if you want to use a threshold

350
00:13:31,260 --> 00:13:33,420
signature scheme you have to pick those

351
00:13:33,420 --> 00:13:36,000
parameters nnt right and the good news

352
00:13:36,000 --> 00:13:39,000
here is that so Frost and also Frost 2

353
00:13:39,000 --> 00:13:40,980
so whenever I say Frost I it applies to

354
00:13:40,980 --> 00:13:43,139
both Frost and frost two Frost supports

355
00:13:43,139 --> 00:13:45,240
any choice of nnt but that just makes

356
00:13:45,240 --> 00:13:47,040
our problem harder right so we have to

357
00:13:47,040 --> 00:13:49,760
come up with a choice

358
00:13:49,860 --> 00:13:51,779
um and what people did classically is

359
00:13:51,779 --> 00:13:54,240
look at honest majority settings for

360
00:13:54,240 --> 00:13:57,000
example if you have uh here five signers

361
00:13:57,000 --> 00:13:58,500
just because it fits nicely on the

362
00:13:58,500 --> 00:14:01,680
nicely on the slide you may want to pick

363
00:14:01,680 --> 00:14:05,160
uh T equals three and in that case uh

364
00:14:05,160 --> 00:14:07,980
you can tolerate up to two malicious

365
00:14:07,980 --> 00:14:09,839
signers for unforgibility so that's why

366
00:14:09,839 --> 00:14:11,880
it's honest majority because three of

367
00:14:11,880 --> 00:14:13,560
them are left and three of them honest

368
00:14:13,560 --> 00:14:15,420
and the nice thing in this setting is

369
00:14:15,420 --> 00:14:16,680
that this matches the number of

370
00:14:16,680 --> 00:14:18,360
tolerable bad signers you can have for

371
00:14:18,360 --> 00:14:20,100
liveness for liveness when I say bad

372
00:14:20,100 --> 00:14:21,480
this can mean malicious or either

373
00:14:21,480 --> 00:14:24,120
offline but here we really get the same

374
00:14:24,120 --> 00:14:25,980
number so as long as only two nodes are

375
00:14:25,980 --> 00:14:27,480
bad

376
00:14:27,480 --> 00:14:29,940
um we are fine in that case but that's

377
00:14:29,940 --> 00:14:32,519
not the only uh choice you can make you

378
00:14:32,519 --> 00:14:35,220
can also oh and yeah sorry and

379
00:14:35,220 --> 00:14:37,500
in some systems you anyway have some

380
00:14:37,500 --> 00:14:39,300
maybe some consensus mechanism going on

381
00:14:39,300 --> 00:14:41,100
that usually requires

382
00:14:41,100 --> 00:14:41,880
um

383
00:14:41,880 --> 00:14:44,459
yeah um honest majority anyway or even

384
00:14:44,459 --> 00:14:46,199
on a super majority in that case you

385
00:14:46,199 --> 00:14:47,760
have no choice but if you have a choice

386
00:14:47,760 --> 00:14:49,980
what you can do is you can move to a

387
00:14:49,980 --> 00:14:51,899
higher team maybe you can set T equals

388
00:14:51,899 --> 00:14:52,920
to four

389
00:14:52,920 --> 00:14:56,639
and in that case it means you have more

390
00:14:56,639 --> 00:14:58,500
unforgeability now in a sense and less

391
00:14:58,500 --> 00:15:00,899
liveness and in this setting here for

392
00:15:00,899 --> 00:15:03,060
example you may up end up in a situation

393
00:15:03,060 --> 00:15:05,160
where you have two bad signers which are

394
00:15:05,160 --> 00:15:07,079
malicious so don't

395
00:15:07,079 --> 00:15:09,839
uh respond so you you could get stuck

396
00:15:09,839 --> 00:15:11,639
here but at least you don't get a

397
00:15:11,639 --> 00:15:14,760
forgery so this kind of prefers

398
00:15:14,760 --> 00:15:15,320
um

399
00:15:15,320 --> 00:15:17,339
unfortunatability over liveness and this

400
00:15:17,339 --> 00:15:18,779
is just a trade-off you have to decide

401
00:15:18,779 --> 00:15:20,279
in your application there's no Golden

402
00:15:20,279 --> 00:15:21,899
Rule here I think it really depends on

403
00:15:21,899 --> 00:15:23,220
the specific requirements of your

404
00:15:23,220 --> 00:15:24,240
application

405
00:15:24,240 --> 00:15:25,920
and of course you could take that to the

406
00:15:25,920 --> 00:15:28,920
extreme inside n equal T and basically

407
00:15:28,920 --> 00:15:31,260
give up liveness entirely but then you

408
00:15:31,260 --> 00:15:32,040
are

409
00:15:32,040 --> 00:15:33,420
sorry

410
00:15:33,420 --> 00:15:35,399
ah they should should have put another

411
00:15:35,399 --> 00:15:37,320
comments up but then you're on in a if

412
00:15:37,320 --> 00:15:40,019
you said t equal n then you are again in

413
00:15:40,019 --> 00:15:40,860
the case where you can use

414
00:15:40,860 --> 00:15:42,420
multi-signatures so you probably then

415
00:15:42,420 --> 00:15:43,920
want to use multi-signatures or not

416
00:15:43,920 --> 00:15:45,260
threshold signatures in the first place

417
00:15:45,260 --> 00:15:47,820
but there if if you talk about life

418
00:15:47,820 --> 00:15:49,320
let's say it's another thing we should

419
00:15:49,320 --> 00:15:51,420
talk about so if you if you have just

420
00:15:51,420 --> 00:15:53,519
enough honest participants that doesn't

421
00:15:53,519 --> 00:15:55,019
necessarily mean that you can create a

422
00:15:55,019 --> 00:15:56,519
signature because if you run the signing

423
00:15:56,519 --> 00:15:58,320
protocol there may be honest and

424
00:15:58,320 --> 00:15:59,579
malicious parties in the signing

425
00:15:59,579 --> 00:16:00,959
protocol and the malicious parties could

426
00:16:00,959 --> 00:16:03,180
try to disrupt the signing protocol and

427
00:16:03,180 --> 00:16:04,620
try to prevent the honest signers from

428
00:16:04,620 --> 00:16:07,920
getting a signature and um the property

429
00:16:07,920 --> 00:16:10,440
that avoids this is called robustness

430
00:16:10,440 --> 00:16:11,820
and just means that the signing protocol

431
00:16:11,820 --> 00:16:13,139
always succeeds if you have enough

432
00:16:13,139 --> 00:16:14,639
honors parties

433
00:16:14,639 --> 00:16:17,220
and the Insight here is that Frost

434
00:16:17,220 --> 00:16:19,920
itself is not robust and the reason is

435
00:16:19,920 --> 00:16:22,079
you can think of frost as a protocol

436
00:16:22,079 --> 00:16:24,240
where you first have to pick a subset of

437
00:16:24,240 --> 00:16:27,660
designers and if you picked wrong then

438
00:16:27,660 --> 00:16:30,180
well the session won't work so in that

439
00:16:30,180 --> 00:16:32,399
case for example on the slide here we

440
00:16:32,399 --> 00:16:34,199
have a two of three setup and we pick

441
00:16:34,199 --> 00:16:35,880
two signers and one of them is malicious

442
00:16:35,880 --> 00:16:37,800
the malicious sign and just sent garbage

443
00:16:37,800 --> 00:16:39,660
and then also the protocol which is all

444
00:16:39,660 --> 00:16:41,940
which is outboard garbage

445
00:16:41,940 --> 00:16:44,339
and the only thing we can do then is

446
00:16:44,339 --> 00:16:46,320
actually pick another set and rerun the

447
00:16:46,320 --> 00:16:49,320
protocol so in general to make a frost

448
00:16:49,320 --> 00:16:51,360
robust what you need to do is you have

449
00:16:51,360 --> 00:16:54,180
to in the worst case you have to start

450
00:16:54,180 --> 00:16:56,339
multiple runs of Frost with different

451
00:16:56,339 --> 00:16:59,459
subsets and now I was involved in the

452
00:16:59,459 --> 00:17:02,639
work uh called roast where we propose a

453
00:17:02,639 --> 00:17:03,660
wrapper

454
00:17:03,660 --> 00:17:06,119
that just picks those subsets in a very

455
00:17:06,119 --> 00:17:08,760
clever way such that you only need a

456
00:17:08,760 --> 00:17:10,500
linear number of thrust sessions but you

457
00:17:10,500 --> 00:17:12,480
still get the protocol which is not only

458
00:17:12,480 --> 00:17:14,459
robust but also asynchronous so you

459
00:17:14,459 --> 00:17:16,619
never run into timeouts or the adversary

460
00:17:16,619 --> 00:17:18,059
actually can never force you into a

461
00:17:18,059 --> 00:17:20,459
timeout so that you have a nice small

462
00:17:20,459 --> 00:17:23,839
delay when creating signatures

463
00:17:24,000 --> 00:17:26,359
okay and now if we look at actual

464
00:17:26,359 --> 00:17:29,880
standardization and deployment efforts

465
00:17:29,880 --> 00:17:31,559
um first of all when it comes to

466
00:17:31,559 --> 00:17:33,660
standardization I think the most

467
00:17:33,660 --> 00:17:35,039
important

468
00:17:35,039 --> 00:17:36,960
thing to mention here is that there is

469
00:17:36,960 --> 00:17:39,600
an active internet draft in this efrg

470
00:17:39,600 --> 00:17:42,360
about Frost so there's this ongoing

471
00:17:42,360 --> 00:17:43,200
thing

472
00:17:43,200 --> 00:17:45,900
um but also in in there are some

473
00:17:45,900 --> 00:17:47,940
Community efforts for where again

474
00:17:47,940 --> 00:17:50,660
skipped another slide

475
00:17:50,660 --> 00:17:55,679
so in the ccash ecosystem there is also

476
00:17:55,679 --> 00:17:57,799
a proposal that's currently a draft for

477
00:17:57,799 --> 00:18:01,200
ccash improvement proposal that uses

478
00:18:01,200 --> 00:18:03,660
Frost for wallets so you can imagine for

479
00:18:03,660 --> 00:18:06,120
example this being used in a

480
00:18:06,120 --> 00:18:08,100
in in Hardware wallets where you have

481
00:18:08,100 --> 00:18:10,140
three Hardware wallets and you store

482
00:18:10,140 --> 00:18:12,120
them at different places and and you

483
00:18:12,120 --> 00:18:13,440
need two of them to sign and stuff like

484
00:18:13,440 --> 00:18:15,600
like that setup

485
00:18:15,600 --> 00:18:17,880
um and also in the in the Bitcoin

486
00:18:17,880 --> 00:18:19,980
Community there's a Bitcoin Improvement

487
00:18:19,980 --> 00:18:22,799
proposal that has just been finalized

488
00:18:22,799 --> 00:18:25,080
two days ago

489
00:18:25,080 --> 00:18:26,880
um this is about music and not about for

490
00:18:26,880 --> 00:18:28,760
us so this covers multi-six and

491
00:18:28,760 --> 00:18:31,380
interestingly or ironically uh the

492
00:18:31,380 --> 00:18:33,120
version that got promoted to the final

493
00:18:33,120 --> 00:18:35,100
version was released candidate four so

494
00:18:35,100 --> 00:18:37,080
this is rc4

495
00:18:37,080 --> 00:18:38,460
um I'm not sure if this is a good omen

496
00:18:38,460 --> 00:18:42,480
for for Applied crypto but let's see

497
00:18:42,480 --> 00:18:46,559
and last but not least there's the nist

498
00:18:46,559 --> 00:18:48,900
call or draft of a call currently for

499
00:18:48,900 --> 00:18:51,000
multi-party threshold schemes

500
00:18:51,000 --> 00:18:52,799
um but if you if you're interested in

501
00:18:52,799 --> 00:18:54,780
the details of that just have a look at

502
00:18:54,780 --> 00:18:58,380
the talk by Luis yesterday who covers

503
00:18:58,380 --> 00:19:01,799
all of this in great detail

504
00:19:01,799 --> 00:19:03,419
and uh

505
00:19:03,419 --> 00:19:05,700
now looking at actual implementations

506
00:19:05,700 --> 00:19:08,280
both for Frost and music we see a lot of

507
00:19:08,280 --> 00:19:11,940
projects that are currently implementing

508
00:19:11,940 --> 00:19:14,400
um the algorithms some of them use them

509
00:19:14,400 --> 00:19:16,080
in production already

510
00:19:16,080 --> 00:19:18,299
some of them have draft implementations

511
00:19:18,299 --> 00:19:20,039
are basically just awaiting the

512
00:19:20,039 --> 00:19:21,780
finalization of the sender of the

513
00:19:21,780 --> 00:19:23,940
standards to to move to production I

514
00:19:23,940 --> 00:19:26,400
think in Frost the most notable project

515
00:19:26,400 --> 00:19:30,419
is a c cache and in the music too for

516
00:19:30,419 --> 00:19:32,640
music too I think the the most multiple

517
00:19:32,640 --> 00:19:35,460
project is is one implementation of the

518
00:19:35,460 --> 00:19:37,980
lightning net payment Network that I

519
00:19:37,980 --> 00:19:40,140
mentioned earlier that already uses

520
00:19:40,140 --> 00:19:43,440
music to a b version of it in uh in

521
00:19:43,440 --> 00:19:45,059
production and will now move to the

522
00:19:45,059 --> 00:19:47,580
final standard

523
00:19:47,580 --> 00:19:49,260
okay and

524
00:19:49,260 --> 00:19:51,299
um the main thing I want to convey with

525
00:19:51,299 --> 00:19:52,860
this slide is just that this stuff is

526
00:19:52,860 --> 00:19:55,860
being used in practiced but uh practice

527
00:19:55,860 --> 00:19:57,660
is not everything so we're still open

528
00:19:57,660 --> 00:19:59,400
problems that we need to solve in theory

529
00:19:59,400 --> 00:20:02,700
and I will hand over to Chelsea who will

530
00:20:02,700 --> 00:20:05,419
cover that part

531
00:20:05,880 --> 00:20:08,059
foreign

532
00:20:10,640 --> 00:20:12,600
we're going to look at a range of open

533
00:20:12,600 --> 00:20:14,220
research problems that have been

534
00:20:14,220 --> 00:20:16,799
motivated by the use of these schemes in

535
00:20:16,799 --> 00:20:19,039
practice

536
00:20:19,440 --> 00:20:21,900
so the first uh problem I want to pose

537
00:20:21,900 --> 00:20:23,820
to you uh the first open research

538
00:20:23,820 --> 00:20:25,620
problem is that of creating efficient

539
00:20:25,620 --> 00:20:27,840
deterministic signatures

540
00:20:27,840 --> 00:20:30,539
so as Liz mentioned before

541
00:20:30,539 --> 00:20:33,480
um we have eddsa which is a variant of

542
00:20:33,480 --> 00:20:35,520
Schnur but most importantly it's

543
00:20:35,520 --> 00:20:36,900
deterministic

544
00:20:36,900 --> 00:20:41,280
so in eddsa it's very similar but the

545
00:20:41,280 --> 00:20:43,320
nonce is generated by the hash of the

546
00:20:43,320 --> 00:20:45,179
message and the secret key

547
00:20:45,179 --> 00:20:47,640
uh and the reason why we do this is to

548
00:20:47,640 --> 00:20:49,799
help prevent issues rising from Bad

549
00:20:49,799 --> 00:20:52,020
Randomness so for example if a machine

550
00:20:52,020 --> 00:20:54,720
were to go down and come back up

551
00:20:54,720 --> 00:20:56,700
um you would be able to seed the nonce

552
00:20:56,700 --> 00:21:00,960
using Randomness from the secret key

553
00:21:00,960 --> 00:21:03,299
and then the rest of eddsa is is very

554
00:21:03,299 --> 00:21:05,700
similar to Schnur

555
00:21:05,700 --> 00:21:08,160
so I'm going to stress a very important

556
00:21:08,160 --> 00:21:10,559
point and if you come away with

557
00:21:10,559 --> 00:21:12,419
something from the talk it is well

558
00:21:12,419 --> 00:21:13,440
hopefully you come away with a lot of

559
00:21:13,440 --> 00:21:15,660
things but hopefully it's this if you

560
00:21:15,660 --> 00:21:18,720
were to use that technique for eddsa

561
00:21:18,720 --> 00:21:21,299
style determinism in the two and three

562
00:21:21,299 --> 00:21:22,559
around schemes we've mentioned before

563
00:21:22,559 --> 00:21:24,660
this would not be secure

564
00:21:24,660 --> 00:21:27,240
and I've had people come and talk to me

565
00:21:27,240 --> 00:21:28,919
about can we do this and other

566
00:21:28,919 --> 00:21:31,620
discussions so the answer is no

567
00:21:31,620 --> 00:21:34,860
can't do this so if you need a

568
00:21:34,860 --> 00:21:36,900
deterministic multi-party snore scheme

569
00:21:36,900 --> 00:21:39,299
they exist they're less efficient and

570
00:21:39,299 --> 00:21:40,679
they're more complex but if you need

571
00:21:40,679 --> 00:21:42,840
that today please look at these schemes

572
00:21:42,840 --> 00:21:44,640
please don't take that technique and

573
00:21:44,640 --> 00:21:46,020
apply it directly to the schemes that we

574
00:21:46,020 --> 00:21:48,179
just talked about

575
00:21:48,179 --> 00:21:49,500
I'm going to show you this attack just

576
00:21:49,500 --> 00:21:50,940
in a little bit more detail because it's

577
00:21:50,940 --> 00:21:52,260
interesting

578
00:21:52,260 --> 00:21:54,600
um because it's interesting and also to

579
00:21:54,600 --> 00:21:56,039
sort of dry that point home

580
00:21:56,039 --> 00:21:58,740
so I'm going to show you a very simple

581
00:21:58,740 --> 00:22:01,020
multi-party signature this is insecure

582
00:22:01,020 --> 00:22:03,120
in other ways so also don't use this but

583
00:22:03,120 --> 00:22:04,620
it's going to help simplify this message

584
00:22:04,620 --> 00:22:06,360
of why you don't you don't want to do

585
00:22:06,360 --> 00:22:08,280
this technique

586
00:22:08,280 --> 00:22:10,380
so this attack is going to happen in

587
00:22:10,380 --> 00:22:13,440
exactly two signing rounds so the starts

588
00:22:13,440 --> 00:22:15,059
by the corrupted party is sending a

589
00:22:15,059 --> 00:22:17,460
message the honest party deriving their

590
00:22:17,460 --> 00:22:21,059
nonce as in DSA via the hash in the

591
00:22:21,059 --> 00:22:22,320
secret key

592
00:22:22,320 --> 00:22:24,120
they derive their commitment they send

593
00:22:24,120 --> 00:22:26,039
their commitment to the corrupt party

594
00:22:26,039 --> 00:22:28,740
and in this first signing session the

595
00:22:28,740 --> 00:22:31,260
party follows the protocol honestly so

596
00:22:31,260 --> 00:22:32,640
they derive their nonce and their

597
00:22:32,640 --> 00:22:34,320
commitment they send it back to the

598
00:22:34,320 --> 00:22:36,419
honest party and then the honest party

599
00:22:36,419 --> 00:22:38,220
derives the group commitment as just the

600
00:22:38,220 --> 00:22:40,679
product of both commitments The

601
00:22:40,679 --> 00:22:42,900
Challenge and their response and they

602
00:22:42,900 --> 00:22:46,919
send the response back to the crop party

603
00:22:46,919 --> 00:22:48,419
things get interesting in the second

604
00:22:48,419 --> 00:22:50,159
signing session so in the second signing

605
00:22:50,159 --> 00:22:52,140
session the party again sends the same

606
00:22:52,140 --> 00:22:54,960
message to the honest Party The Honest

607
00:22:54,960 --> 00:22:56,760
party again follows the protocol they

608
00:22:56,760 --> 00:22:58,440
derive their knots honestly

609
00:22:58,440 --> 00:23:01,020
they drive their commitment honestly

610
00:23:01,020 --> 00:23:03,419
they send it back to the corrupt party

611
00:23:03,419 --> 00:23:06,179
and then here the the corrupt party uh

612
00:23:06,179 --> 00:23:08,880
deviates from the protocol so here they

613
00:23:08,880 --> 00:23:10,799
sample their nonce uniformly at random

614
00:23:10,799 --> 00:23:12,720
or they do whatever they sample their

615
00:23:12,720 --> 00:23:15,000
non somehow and then they generate their

616
00:23:15,000 --> 00:23:17,580
commitment following the protocol

617
00:23:17,580 --> 00:23:19,740
they send this different commitment back

618
00:23:19,740 --> 00:23:21,120
to the honest party

619
00:23:21,120 --> 00:23:24,120
who then derives the group commitment

620
00:23:24,120 --> 00:23:26,159
again following the protocol

621
00:23:26,159 --> 00:23:28,080
then they derive The Challenge and the

622
00:23:28,080 --> 00:23:30,360
response and they send this back to the

623
00:23:30,360 --> 00:23:31,980
crop party

624
00:23:31,980 --> 00:23:33,179
so

625
00:23:33,179 --> 00:23:35,520
here the corrupt party does not follow

626
00:23:35,520 --> 00:23:37,740
the protocol but the honest party can't

627
00:23:37,740 --> 00:23:39,120
detect that so to the honest party

628
00:23:39,120 --> 00:23:41,460
everything looks fine they look it looks

629
00:23:41,460 --> 00:23:42,780
like the corrupt party is following the

630
00:23:42,780 --> 00:23:43,919
protocol

631
00:23:43,919 --> 00:23:47,220
but importantly in the second session

632
00:23:47,220 --> 00:23:49,679
the group commitment The Challenge and

633
00:23:49,679 --> 00:23:51,059
the response for the honest party are

634
00:23:51,059 --> 00:23:52,380
different from the first signing session

635
00:23:52,380 --> 00:23:54,480
and you might see where this is going

636
00:23:54,480 --> 00:23:57,539
but if you don't this results exactly in

637
00:23:57,539 --> 00:24:00,179
the secret key recovery attack so

638
00:24:00,179 --> 00:24:01,679
um this is essentially a nonsreuse

639
00:24:01,679 --> 00:24:02,880
attack

640
00:24:02,880 --> 00:24:06,360
and you're dead so

641
00:24:06,360 --> 00:24:11,100
um so yeah don't do this uh and oh

642
00:24:11,100 --> 00:24:13,500
but then we do have a a question here

643
00:24:13,500 --> 00:24:15,780
which is okay we do have deterministic

644
00:24:15,780 --> 00:24:17,400
style schemes which allows the honest

645
00:24:17,400 --> 00:24:19,500
party to detect when the crop party

646
00:24:19,500 --> 00:24:21,419
deviates from the protocol but they're

647
00:24:21,419 --> 00:24:22,679
not very efficient and so the question

648
00:24:22,679 --> 00:24:24,659
is can we build a real world or

649
00:24:24,659 --> 00:24:26,520
efficient deterministic threshold scheme

650
00:24:26,520 --> 00:24:29,299
that solves this problem

651
00:24:29,820 --> 00:24:31,919
all right the next research question I'm

652
00:24:31,919 --> 00:24:33,299
going to pose to you is looking at the

653
00:24:33,299 --> 00:24:34,919
trade-off between efficiency and

654
00:24:34,919 --> 00:24:36,900
security assumptions for signing

655
00:24:36,900 --> 00:24:40,320
so Liz before presented a host of these

656
00:24:40,320 --> 00:24:42,120
two around two and three round schemes

657
00:24:42,120 --> 00:24:45,059
that exist and they really fall into the

658
00:24:45,059 --> 00:24:46,919
the categories of three on schemes

659
00:24:46,919 --> 00:24:49,140
reducing to standard assumptions and two

660
00:24:49,140 --> 00:24:51,299
round schemes reducing to one more

661
00:24:51,299 --> 00:24:53,220
discrete log

662
00:24:53,220 --> 00:24:55,500
and so the question we have here is is

663
00:24:55,500 --> 00:24:57,539
there an impossibility result here so

664
00:24:57,539 --> 00:24:59,400
can we actually prove that these two run

665
00:24:59,400 --> 00:25:02,460
schemes require stronger assumptions or

666
00:25:02,460 --> 00:25:04,679
is it does it impossibility result not

667
00:25:04,679 --> 00:25:06,419
exist which means that maybe we could

668
00:25:06,419 --> 00:25:08,460
get two round schemes with

669
00:25:08,460 --> 00:25:10,799
um with standard assumptions so this

670
00:25:10,799 --> 00:25:12,900
would be useful to to investigate and to

671
00:25:12,900 --> 00:25:15,679
prove more formally

672
00:25:15,679 --> 00:25:18,059
the final research question I'm going to

673
00:25:18,059 --> 00:25:20,159
pose to you is along similar lines so

674
00:25:20,159 --> 00:25:21,780
it's looking again at this trade-off

675
00:25:21,780 --> 00:25:23,280
between efficiency and the security

676
00:25:23,280 --> 00:25:25,980
assumptions but here I'm going to talk

677
00:25:25,980 --> 00:25:28,020
about specifically with respect to key

678
00:25:28,020 --> 00:25:29,880
generation

679
00:25:29,880 --> 00:25:31,679
so before

680
00:25:31,679 --> 00:25:34,080
um both Liz and Tim talked about dkgs

681
00:25:34,080 --> 00:25:36,059
and I'm going to introduce them a little

682
00:25:36,059 --> 00:25:37,559
bit more formally but still at a high

683
00:25:37,559 --> 00:25:40,200
level so what a dkg is is it's a

684
00:25:40,200 --> 00:25:42,419
multi-party at a high level it's a

685
00:25:42,419 --> 00:25:44,760
multi-party computation where all of the

686
00:25:44,760 --> 00:25:46,200
parties communicate and work with each

687
00:25:46,200 --> 00:25:48,600
other and then at the end everyone has a

688
00:25:48,600 --> 00:25:50,400
secret share with respect to the secret

689
00:25:50,400 --> 00:25:53,279
key and the public key is also output

690
00:25:53,279 --> 00:25:55,380
that represents the group

691
00:25:55,380 --> 00:25:57,299
and what's important in these types of

692
00:25:57,299 --> 00:25:59,520
protocols is that no single party knows

693
00:25:59,520 --> 00:26:01,500
the corresponding secret key so at the

694
00:26:01,500 --> 00:26:03,600
end everyone is able to work together to

695
00:26:03,600 --> 00:26:05,100
generate these secret shares but no one

696
00:26:05,100 --> 00:26:07,860
knows the secret key alone and so

697
00:26:07,860 --> 00:26:11,719
everyone's essentially trusted similarly

698
00:26:11,760 --> 00:26:13,320
there's two ways you can prove the

699
00:26:13,320 --> 00:26:17,279
security of dkgs or two main ways so the

700
00:26:17,279 --> 00:26:20,279
first way is to prove the security of

701
00:26:20,279 --> 00:26:22,919
the dkg and the context of some other

702
00:26:22,919 --> 00:26:25,679
scheme so for example in Frost we

703
00:26:25,679 --> 00:26:27,900
introduce a two round dkg and we prove

704
00:26:27,900 --> 00:26:29,340
its security when we are proving the

705
00:26:29,340 --> 00:26:31,679
unforgeability of frost so what we've

706
00:26:31,679 --> 00:26:34,380
said is that this two round EKG is

707
00:26:34,380 --> 00:26:37,620
secure in the context of Frost

708
00:26:37,620 --> 00:26:39,120
another way that you can prove the

709
00:26:39,120 --> 00:26:41,940
security of a dkg is independently and

710
00:26:41,940 --> 00:26:43,380
this is essentially by a proof of

711
00:26:43,380 --> 00:26:46,500
composability and what this means is

712
00:26:46,500 --> 00:26:49,740
what you're saying is any setting that

713
00:26:49,740 --> 00:26:53,400
uh some idealized function is secure for

714
00:26:53,400 --> 00:26:56,159
you can then use the dkg as well

715
00:26:56,159 --> 00:26:57,539
this might sound a little confusing so

716
00:26:57,539 --> 00:26:59,340
what do I mean by that

717
00:26:59,340 --> 00:27:01,679
so here we have some Target key

718
00:27:01,679 --> 00:27:03,299
generation scheme it's a single party

719
00:27:03,299 --> 00:27:05,940
scheme magic happens internally to it

720
00:27:05,940 --> 00:27:07,799
and it outputs a secret key in a public

721
00:27:07,799 --> 00:27:08,700
key

722
00:27:08,700 --> 00:27:11,700
then we have a dkg and stuff happens

723
00:27:11,700 --> 00:27:13,740
inside of it as well and it also outputs

724
00:27:13,740 --> 00:27:16,080
a secret key in public key and so when

725
00:27:16,080 --> 00:27:18,240
we prove the composability of a dkg what

726
00:27:18,240 --> 00:27:19,919
we're saying is that in the setting

727
00:27:19,919 --> 00:27:23,100
where this target qgen is secure this

728
00:27:23,100 --> 00:27:25,500
dkg is also secure and this is a very

729
00:27:25,500 --> 00:27:27,120
nice thing because then essentially of a

730
00:27:27,120 --> 00:27:30,299
dkg which is secure across potentially

731
00:27:30,299 --> 00:27:33,200
many schemes

732
00:27:34,380 --> 00:27:36,900
but then obviously what's nice is that

733
00:27:36,900 --> 00:27:38,760
here in the dkg setting the secret key

734
00:27:38,760 --> 00:27:40,440
is actually a secret shared and so no

735
00:27:40,440 --> 00:27:43,340
one actually knows it

736
00:27:43,740 --> 00:27:45,960
so similarly to the setting that we saw

737
00:27:45,960 --> 00:27:48,480
before these two and three round signing

738
00:27:48,480 --> 00:27:50,640
schemes we have the same kind of

739
00:27:50,640 --> 00:27:52,320
breakdown and two and three round

740
00:27:52,320 --> 00:27:54,960
schemes for distributed key generation

741
00:27:54,960 --> 00:27:56,880
so here I'm talking about distributed Q

742
00:27:56,880 --> 00:28:00,240
generation specifically for the eddsa or

743
00:28:00,240 --> 00:28:03,299
schnor setting there's also dkgs for

744
00:28:03,299 --> 00:28:04,559
ecdsa

745
00:28:04,559 --> 00:28:06,179
um as well but here I'm focusing

746
00:28:06,179 --> 00:28:07,679
specifically on schemes that have been

747
00:28:07,679 --> 00:28:09,900
proven secure in the context of Schnur

748
00:28:09,900 --> 00:28:11,520
and eddsa

749
00:28:11,520 --> 00:28:14,340
so um some some of the ones that I want

750
00:28:14,340 --> 00:28:16,679
to highlight is there's one by Gennaro

751
00:28:16,679 --> 00:28:18,659
at all and it was output it was

752
00:28:18,659 --> 00:28:20,520
published in the 90s so it's been around

753
00:28:20,520 --> 00:28:22,860
for a long time and then another tk2

754
00:28:22,860 --> 00:28:24,779
that recently came out by myself Ian

755
00:28:24,779 --> 00:28:26,640
Goldberg and Douglas doubla is called

756
00:28:26,640 --> 00:28:28,919
storm and these schemes reduce to

757
00:28:28,919 --> 00:28:31,140
standard assumptions and three rounds

758
00:28:31,140 --> 00:28:33,120
but then we also have two round schemes

759
00:28:33,120 --> 00:28:35,520
so there's ped pop which we introduced

760
00:28:35,520 --> 00:28:37,200
in the paper for Frost and then we

761
00:28:37,200 --> 00:28:40,140
proved later in a crypto22 paper

762
00:28:40,140 --> 00:28:42,840
and ped pop is securing the context of

763
00:28:42,840 --> 00:28:45,179
frost but ped pop does require stronger

764
00:28:45,179 --> 00:28:47,100
assumptions

765
00:28:47,100 --> 00:28:48,960
so the question we have here is again

766
00:28:48,960 --> 00:28:51,179
similarly is there an impossibility

767
00:28:51,179 --> 00:28:53,279
result here so are there two round

768
00:28:53,279 --> 00:28:55,380
schemes which we can have proofs of

769
00:28:55,380 --> 00:28:58,020
composability for and then potentially

770
00:28:58,020 --> 00:29:00,659
can we have weaker assumptions for these

771
00:29:00,659 --> 00:29:03,260
dkgs

772
00:29:03,659 --> 00:29:06,179
so we've talked a lot in this talk

773
00:29:06,179 --> 00:29:07,559
there's been a lot of different things

774
00:29:07,559 --> 00:29:09,600
we've gone over and hopefully you have a

775
00:29:09,600 --> 00:29:11,279
better sense of the field now and where

776
00:29:11,279 --> 00:29:12,720
things are going and some of the open

777
00:29:12,720 --> 00:29:14,520
problems that exist

778
00:29:14,520 --> 00:29:16,080
so what are some of the main takeaways

779
00:29:16,080 --> 00:29:17,340
from all of this

780
00:29:17,340 --> 00:29:19,679
first uh schnura multi-party signatures

781
00:29:19,679 --> 00:29:21,419
are being used in practice today and

782
00:29:21,419 --> 00:29:22,679
that's something we're really excited

783
00:29:22,679 --> 00:29:25,380
about and it's really cool to see these

784
00:29:25,380 --> 00:29:27,120
schemes being used and deployed and the

785
00:29:27,120 --> 00:29:28,980
lessons that are being learned so this

786
00:29:28,980 --> 00:29:31,740
is something we're pretty excited about

787
00:29:31,740 --> 00:29:33,539
however there are a lot of questions and

788
00:29:33,539 --> 00:29:35,880
challenges that remain to proving to

789
00:29:35,880 --> 00:29:38,880
improving their usability and security

790
00:29:38,880 --> 00:29:41,340
this is something we all the three of us

791
00:29:41,340 --> 00:29:43,440
are working actively on and if you have

792
00:29:43,440 --> 00:29:45,299
ideas or you'd like to collaborate

793
00:29:45,299 --> 00:29:46,799
please come and talk to us we would love

794
00:29:46,799 --> 00:29:48,240
to work with you

795
00:29:48,240 --> 00:29:51,360
and T of n of us will be involved in the

796
00:29:51,360 --> 00:29:54,659
nist call teas to being determined so

797
00:29:54,659 --> 00:29:56,520
please let us know if you'd like to join

798
00:29:56,520 --> 00:29:58,860
forces and work with us as well

799
00:29:58,860 --> 00:30:01,620
um also Liz is on the job market and

800
00:30:01,620 --> 00:30:04,140
she's excellent to work with so please

801
00:30:04,140 --> 00:30:08,840
talk to her and hire her she's amazing

802
00:30:09,059 --> 00:30:11,580
and that's all so maybe some time for

803
00:30:11,580 --> 00:30:13,820
questions

804
00:30:19,559 --> 00:30:21,919
yeah

805
00:30:21,919 --> 00:30:24,779
just uh sorry a pedantic comment what

806
00:30:24,779 --> 00:30:27,240
you call concurrent security is not the

807
00:30:27,240 --> 00:30:29,640
same notion as what we talk about in

808
00:30:29,640 --> 00:30:32,100
concurrent zero knowledge and things the

809
00:30:32,100 --> 00:30:34,380
reason is because you you have the

810
00:30:34,380 --> 00:30:36,419
Salute Your solution has this hash of

811
00:30:36,419 --> 00:30:37,980
all the

812
00:30:37,980 --> 00:30:39,840
messages which means that you need to

813
00:30:39,840 --> 00:30:41,700
know about all the other concurrent

814
00:30:41,700 --> 00:30:44,220
things I think if you look in that

815
00:30:44,220 --> 00:30:45,960
Goldust book it's called parallel

816
00:30:45,960 --> 00:30:47,159
security

817
00:30:47,159 --> 00:30:49,020
so you know I don't know if the if the

818
00:30:49,020 --> 00:30:50,700
genie is out of the bottle yet but if it

819
00:30:50,700 --> 00:30:53,039
is it still possible to rescind that

820
00:30:53,039 --> 00:30:55,140
term and use the sort of the the more

821
00:30:55,140 --> 00:30:57,600
common one it would be better

822
00:30:57,600 --> 00:30:59,460
um we did not come up with that term but

823
00:30:59,460 --> 00:31:02,100
yeah and the other thing is that

824
00:31:02,100 --> 00:31:05,039
deterministic is obviously uh sort of

825
00:31:05,039 --> 00:31:07,080
resettably secure I mean this is the

826
00:31:07,080 --> 00:31:08,520
context of the context that you wanted

827
00:31:08,520 --> 00:31:11,179
yeah

828
00:31:11,240 --> 00:31:14,340
a really really nice talk so you raised

829
00:31:14,340 --> 00:31:16,080
a lot of interesting open questions but

830
00:31:16,080 --> 00:31:18,179
uh I wonder that there are some existing

831
00:31:18,179 --> 00:31:20,820
solutions for example like deterministic

832
00:31:20,820 --> 00:31:23,460
low round uh threshold signature that

833
00:31:23,460 --> 00:31:25,919
comes into mind is BLS you what's your

834
00:31:25,919 --> 00:31:28,380
take on that and then you mention the

835
00:31:28,380 --> 00:31:30,779
tkg you know some non-interactive dkg I

836
00:31:30,779 --> 00:31:32,039
mean there are some works out there

837
00:31:32,039 --> 00:31:34,260
doing this public key encryption plus

838
00:31:34,260 --> 00:31:35,820
the knowledge proof kind of work so

839
00:31:35,820 --> 00:31:37,799
these two questions

840
00:31:37,799 --> 00:31:39,000
uh

841
00:31:39,000 --> 00:31:41,520
yeah threshold BLS is great and you

842
00:31:41,520 --> 00:31:43,500
should use it if you can

843
00:31:43,500 --> 00:31:44,279
um

844
00:31:44,279 --> 00:31:45,620
but

845
00:31:45,620 --> 00:31:48,059
so how does I mean you have the

846
00:31:48,059 --> 00:31:49,559
comparison with your work like how does

847
00:31:49,559 --> 00:31:51,059
it compare like any pros and cons

848
00:31:51,059 --> 00:31:53,880
compared to these directions

849
00:31:53,880 --> 00:31:55,679
um I think just one more comment about

850
00:31:55,679 --> 00:31:57,779
BLS maybe it's um it's it's always

851
00:31:57,779 --> 00:32:00,240
interesting because it really like the

852
00:32:00,240 --> 00:32:02,640
one-off feature of those schemes is that

853
00:32:02,640 --> 00:32:03,899
you can use them as a drop-in

854
00:32:03,899 --> 00:32:06,419
replacement for existing deployments or

855
00:32:06,419 --> 00:32:08,460
you can even for new deployments you can

856
00:32:08,460 --> 00:32:10,880
maybe decide to specify a

857
00:32:10,880 --> 00:32:13,559
style signature because it's more

858
00:32:13,559 --> 00:32:16,320
efficient in the single signer case and

859
00:32:16,320 --> 00:32:17,880
still make use of those Protocols of

860
00:32:17,880 --> 00:32:19,919
course if you if you can't design your

861
00:32:19,919 --> 00:32:22,260
system from scratch and you

862
00:32:22,260 --> 00:32:25,679
um you you want to use PLS then that's a

863
00:32:25,679 --> 00:32:27,299
good idea there's always this stroke

864
00:32:27,299 --> 00:32:30,000
that I mean I I now complain about in

865
00:32:30,000 --> 00:32:31,440
the sense about the easy this a

866
00:32:31,440 --> 00:32:33,000
threshold work because I say you can

867
00:32:33,000 --> 00:32:34,380
just switch to snore and then there's

868
00:32:34,380 --> 00:32:36,779
always so some other people that tell me

869
00:32:36,779 --> 00:32:38,399
okay we'll just switch to be a lesson

870
00:32:38,399 --> 00:32:40,740
yeah I guess they're right so they do

871
00:32:40,740 --> 00:32:42,600
exist but you know that has some other

872
00:32:42,600 --> 00:32:44,159
disadvantage okay that's cool okay thank

873
00:32:44,159 --> 00:32:46,140
you and you have anything about the dkz

874
00:32:46,140 --> 00:32:49,380
like uh there is this dkg by James Groth

875
00:32:49,380 --> 00:32:51,899
that's been out there for a while uh

876
00:32:51,899 --> 00:32:54,120
non-attractive

877
00:32:54,120 --> 00:32:56,640
it um as I understand it's defined in

878
00:32:56,640 --> 00:32:58,980
the context of pairings but yeah it is

879
00:32:58,980 --> 00:33:00,659
yeah so I think there's work to be done

880
00:33:00,659 --> 00:33:02,580
to Define it not in the context of

881
00:33:02,580 --> 00:33:03,480
parents

882
00:33:03,480 --> 00:33:06,000
um I also specifically have dkgs that

883
00:33:06,000 --> 00:33:07,919
are not publicly verifiable so yeah

884
00:33:07,919 --> 00:33:09,960
there's a whole host but I'm I just put

885
00:33:09,960 --> 00:33:12,120
up tkgs that are three round

886
00:33:12,120 --> 00:33:13,740
um that don't require more complicated

887
00:33:13,740 --> 00:33:15,659
cryptography like public verification

888
00:33:15,659 --> 00:33:18,500
okay thank you

889
00:33:19,080 --> 00:33:20,640
thank you very much for the very nice

890
00:33:20,640 --> 00:33:21,419
talk

891
00:33:21,419 --> 00:33:24,000
um I have a question about security you

892
00:33:24,000 --> 00:33:26,100
mentioned you have underway an effort to

893
00:33:26,100 --> 00:33:27,779
prove adaptive security for the two

894
00:33:27,779 --> 00:33:29,640
round is that something you have on the

895
00:33:29,640 --> 00:33:32,700
horizon or you have no idea how to yeah

896
00:33:32,700 --> 00:33:35,460
so um we put a like an ePrint I don't

897
00:33:35,460 --> 00:33:37,320
know yesterday for Sparkle So This is

898
00:33:37,320 --> 00:33:39,000
the three round scheme

899
00:33:39,000 --> 00:33:40,740
um I will note that in order to prove

900
00:33:40,740 --> 00:33:42,240
adaptive security there you actually

901
00:33:42,240 --> 00:33:43,860
give the message and the signing set in

902
00:33:43,860 --> 00:33:45,480
the first round so it is fully three

903
00:33:45,480 --> 00:33:47,820
rounds and you need that for not Statics

904
00:33:47,820 --> 00:33:49,380
and forgeability which is the usual

905
00:33:49,380 --> 00:33:51,299
notion but you need it for adaptive for

906
00:33:51,299 --> 00:33:52,799
frost we do not suspect that you

907
00:33:52,799 --> 00:33:54,120
actually need the message and signing

908
00:33:54,120 --> 00:33:55,740
set in the in the first round so it can

909
00:33:55,740 --> 00:33:57,659
maintain the pre-processing plus one

910
00:33:57,659 --> 00:33:59,820
signing and is all of this in the

911
00:33:59,820 --> 00:34:01,740
setting of uh regular affordability

912
00:34:01,740 --> 00:34:03,899
rather than strong affordability yeah

913
00:34:03,899 --> 00:34:05,100
it's in the setting of unforgeability

914
00:34:05,100 --> 00:34:06,360
though I think it could be extended to

915
00:34:06,360 --> 00:34:10,040
strong unfortunately thank you very much

916
00:34:10,760 --> 00:34:15,659
uh hello uh I'm dimich uh

917
00:34:15,659 --> 00:34:18,300
very interesting talk things and yeah

918
00:34:18,300 --> 00:34:21,000
From perspective of a person who owed

919
00:34:21,000 --> 00:34:23,639
its third-party code a lot I like to

920
00:34:23,639 --> 00:34:26,339
yeah draw attached to two interesting

921
00:34:26,339 --> 00:34:27,719
things the first of all this

922
00:34:27,719 --> 00:34:29,099
compatibility thing that you mentioned

923
00:34:29,099 --> 00:34:30,540
it's really really important because

924
00:34:30,540 --> 00:34:33,179
people are still using uh in combination

925
00:34:33,179 --> 00:34:35,219
of their kind of they're building their

926
00:34:35,219 --> 00:34:37,500
threshold seams but they often use some

927
00:34:37,500 --> 00:34:40,379
dkgs from 90s and something like this

928
00:34:40,379 --> 00:34:43,080
and they often don't know how to

929
00:34:43,080 --> 00:34:44,520
properly combine them and what security

930
00:34:44,520 --> 00:34:46,739
properties are still are still here and

931
00:34:46,739 --> 00:34:49,080
what are not and and so on the second

932
00:34:49,080 --> 00:34:51,300
thing I think a deterministic part is

933
00:34:51,300 --> 00:34:53,339
very very important because nowadays

934
00:34:53,339 --> 00:34:55,679
with this kind of widespread of

935
00:34:55,679 --> 00:34:58,560
blockchain code and so on people kind of

936
00:34:58,560 --> 00:35:00,900
for some reason stopped using very

937
00:35:00,900 --> 00:35:03,960
reliable crypto libraries they start

938
00:35:03,960 --> 00:35:07,320
again using uh weird and very insecure

939
00:35:07,320 --> 00:35:10,380
random number generators for testing for

940
00:35:10,380 --> 00:35:12,680
example they they first use it like

941
00:35:12,680 --> 00:35:15,660
mercen twister for for testing and then

942
00:35:15,660 --> 00:35:17,280
goes into production that happens very

943
00:35:17,280 --> 00:35:20,400
very often nowadays and yeah if we have

944
00:35:20,400 --> 00:35:22,500
some skim which is deterministic and get

945
00:35:22,500 --> 00:35:24,599
rid of this I think this would be very

946
00:35:24,599 --> 00:35:27,660
very helpful in stopping this sort of

947
00:35:27,660 --> 00:35:29,880
box by spread so yeah thank you for

948
00:35:29,880 --> 00:35:32,420
those efforts

949
00:35:33,960 --> 00:35:36,599
okay so uh let's thank the speakers

950
00:35:36,599 --> 00:35:37,920
again

951
00:35:37,920 --> 00:35:41,110
[Music]

952
00:35:43,859 --> 00:35:46,380
okay so I move on to the second torques

953
00:35:46,380 --> 00:35:49,800
threshold ecdsa towards deployment

954
00:35:49,800 --> 00:35:51,359
nah

955
00:35:51,359 --> 00:35:55,520
Abby will be a speaker

956
00:35:58,500 --> 00:36:00,800
hello

957
00:36:04,619 --> 00:36:06,420
all right

958
00:36:06,420 --> 00:36:08,160
thank you very much committee for

959
00:36:08,160 --> 00:36:10,200
inviting me here this is my daughter's

960
00:36:10,200 --> 00:36:12,660
first crypto conference she is currently

961
00:36:12,660 --> 00:36:13,160
interested

962
00:36:13,160 --> 00:36:18,599
[Applause]

963
00:36:18,599 --> 00:36:20,520
she's currently interested in social

964
00:36:20,520 --> 00:36:22,680
studies and large language models but

965
00:36:22,680 --> 00:36:24,540
I'm trying to convince her to take a

966
00:36:24,540 --> 00:36:26,579
career in security

967
00:36:26,579 --> 00:36:29,220
all right so this uh this works uh on on

968
00:36:29,220 --> 00:36:31,859
our work on threshold ecdsa and it's

969
00:36:31,859 --> 00:36:34,440
with Jack and Josh and Issa and I'll be

970
00:36:34,440 --> 00:36:36,599
the speaker and uh thank you very much

971
00:36:36,599 --> 00:36:37,800
to the previous set of speakers

972
00:36:37,800 --> 00:36:40,260
Elizabeth and co uh for explaining what

973
00:36:40,260 --> 00:36:42,180
threshold signatures are so I will skip

974
00:36:42,180 --> 00:36:44,520
the slide where I explain what exactly a

975
00:36:44,520 --> 00:36:46,320
threshold signature is

976
00:36:46,320 --> 00:36:48,540
uh the one thing I will add to their

977
00:36:48,540 --> 00:36:50,700
definition is what the security notion

978
00:36:50,700 --> 00:36:52,980
is the security model so in this work

979
00:36:52,980 --> 00:36:55,079
the protocols we're talking about are n

980
00:36:55,079 --> 00:36:57,180
minus one secure which means that it

981
00:36:57,180 --> 00:36:59,640
tolerates all but one if there's one on

982
00:36:59,640 --> 00:37:01,260
its party then essentially the protocol

983
00:37:01,260 --> 00:37:02,760
will work

984
00:37:02,760 --> 00:37:04,020
um

985
00:37:04,020 --> 00:37:08,400
and sorry oh okay great there's also

986
00:37:08,400 --> 00:37:10,380
other Notions and over two so there are

987
00:37:10,380 --> 00:37:12,359
many protocols for this threshold ecdsa

988
00:37:12,359 --> 00:37:13,859
in this other model where you assume

989
00:37:13,859 --> 00:37:15,540
that at least uh half of the

990
00:37:15,540 --> 00:37:17,400
participants are honest majority and

991
00:37:17,400 --> 00:37:18,780
Things become a little bit easier in

992
00:37:18,780 --> 00:37:21,540
that model okay so as the previous

993
00:37:21,540 --> 00:37:23,940
speakers talked about uh Schnur

994
00:37:23,940 --> 00:37:25,560
signatures have this very nice feature

995
00:37:25,560 --> 00:37:27,780
which is that the yellow part is very

996
00:37:27,780 --> 00:37:29,339
easy it's sort of a linear operation

997
00:37:29,339 --> 00:37:31,500
there and the signature part s right

998
00:37:31,500 --> 00:37:33,359
there is also a linear operation in the

999
00:37:33,359 --> 00:37:37,500
secret key and the nonce K all right you

1000
00:37:37,500 --> 00:37:40,079
see the essay starts out well it has

1001
00:37:40,079 --> 00:37:41,579
that same sort of structure at the

1002
00:37:41,579 --> 00:37:43,800
beginning but then it becomes a little

1003
00:37:43,800 --> 00:37:46,079
bit odd here s is much different here

1004
00:37:46,079 --> 00:37:47,820
it's non-linear you see it has a

1005
00:37:47,820 --> 00:37:50,400
division of K there uh it has a secret

1006
00:37:50,400 --> 00:37:52,740
key operation and a multiplication by RX

1007
00:37:52,740 --> 00:37:54,660
and in particular this is a very odd

1008
00:37:54,660 --> 00:37:57,420
thing because RX is a point it's in the

1009
00:37:57,420 --> 00:37:59,160
elliptic curve point so it's in sort of

1010
00:37:59,160 --> 00:38:01,619
the base field of the elliptic curve

1011
00:38:01,619 --> 00:38:04,440
whereas you're using it uh in a field

1012
00:38:04,440 --> 00:38:06,359
where you're in in the sort of order

1013
00:38:06,359 --> 00:38:07,859
field the scalar field so there's a

1014
00:38:07,859 --> 00:38:09,300
there's a bunch of things going on here

1015
00:38:09,300 --> 00:38:11,060
and it was done in order to basically

1016
00:38:11,060 --> 00:38:13,500
circumvent some sort of patent

1017
00:38:13,500 --> 00:38:15,480
that's unfortunate but in fact the world

1018
00:38:15,480 --> 00:38:17,339
has adopted to this and this is why we

1019
00:38:17,339 --> 00:38:19,380
study this question of threshold ecdsa

1020
00:38:19,380 --> 00:38:21,839
now as they also mentioned that Ed DSA

1021
00:38:21,839 --> 00:38:24,119
has this similar linear structure on S

1022
00:38:24,119 --> 00:38:26,700
but in fact a problem here with uh with

1023
00:38:26,700 --> 00:38:28,619
with how they pick the knots and so here

1024
00:38:28,619 --> 00:38:30,180
are all the complexities for this

1025
00:38:30,180 --> 00:38:32,460
elliptic curve type of problems we'll

1026
00:38:32,460 --> 00:38:34,380
talk about the middle one here today and

1027
00:38:34,380 --> 00:38:36,180
how to deal with that weird equation

1028
00:38:36,180 --> 00:38:38,220
right there in the red so let's look at

1029
00:38:38,220 --> 00:38:41,880
it a little bit closer so this red part

1030
00:38:41,880 --> 00:38:43,500
right here secret key is going to be in

1031
00:38:43,500 --> 00:38:44,700
a threshold setting it's going to be

1032
00:38:44,700 --> 00:38:47,820
shared among all the parties uh and the

1033
00:38:47,820 --> 00:38:49,440
K value here is going to also be

1034
00:38:49,440 --> 00:38:51,480
selected by all of the parties if you

1035
00:38:51,480 --> 00:38:53,820
give one party a choice of that k then

1036
00:38:53,820 --> 00:38:55,980
obviously you can use this non-3 attacks

1037
00:38:55,980 --> 00:38:58,200
that uh our previous speakers uh talked

1038
00:38:58,200 --> 00:39:00,119
about and that would make the scheme

1039
00:39:00,119 --> 00:39:02,220
insecure so you have this problem of how

1040
00:39:02,220 --> 00:39:04,200
do you compute SK is shared among

1041
00:39:04,200 --> 00:39:06,180
parties K is shared among parties how do

1042
00:39:06,180 --> 00:39:07,859
you compute this particular

1043
00:39:07,859 --> 00:39:09,599
type of equation

1044
00:39:09,599 --> 00:39:12,540
and we proposed a few ways of doing this

1045
00:39:12,540 --> 00:39:14,700
uh in this n minus one security model

1046
00:39:14,700 --> 00:39:16,920
there are many other works in this area

1047
00:39:16,920 --> 00:39:19,079
and so let me try to categorize and

1048
00:39:19,079 --> 00:39:21,599
group these so the gray ones they rely

1049
00:39:21,599 --> 00:39:23,339
on an additive homomorphic encryption

1050
00:39:23,339 --> 00:39:25,200
scheme that uses a different complexity

1051
00:39:25,200 --> 00:39:28,740
assumption like Pi a or class groups and

1052
00:39:28,740 --> 00:39:31,500
in my opinion I don't think we should be

1053
00:39:31,500 --> 00:39:33,720
designing elliptic curve signatures that

1054
00:39:33,720 --> 00:39:36,060
need assumptions like RSA and so forth

1055
00:39:36,060 --> 00:39:38,820
so that's why or or other even more

1056
00:39:38,820 --> 00:39:40,380
esoteric assumptions that's why I put

1057
00:39:40,380 --> 00:39:42,780
those gray out the blue protocols here

1058
00:39:42,780 --> 00:39:44,460
are actually interesting I'm going to

1059
00:39:44,460 --> 00:39:46,500
talk about them in a second

1060
00:39:46,500 --> 00:39:50,040
and they they attempt to use generic NPC

1061
00:39:50,040 --> 00:39:51,660
techniques and sort of refine them for

1062
00:39:51,660 --> 00:39:52,619
the particular case that we're talking

1063
00:39:52,619 --> 00:39:54,180
about and this last one on the red here

1064
00:39:54,180 --> 00:39:55,800
I'm going to talk about that uh this

1065
00:39:55,800 --> 00:39:58,320
latest work by uh Jew at all I'm also

1066
00:39:58,320 --> 00:40:01,079
going to sort of mention that so why do

1067
00:40:01,079 --> 00:40:04,140
I like this type of uh why do I like OT

1068
00:40:04,140 --> 00:40:05,820
based protocols in this particular thing

1069
00:40:05,820 --> 00:40:07,740
the advantage of our particular approach

1070
00:40:07,740 --> 00:40:09,780
here so all of the gray ones here that

1071
00:40:09,780 --> 00:40:12,300
rely on additive homomorphic encryption

1072
00:40:12,300 --> 00:40:14,460
it's a very conceptually elegant way of

1073
00:40:14,460 --> 00:40:17,040
doing this because with additive

1074
00:40:17,040 --> 00:40:18,599
homophomorphic encryption you can do

1075
00:40:18,599 --> 00:40:20,400
this multiplication and this inversion

1076
00:40:20,400 --> 00:40:22,859
in a very clever way very simple elegant

1077
00:40:22,859 --> 00:40:25,079
way but the price that you pay for that

1078
00:40:25,079 --> 00:40:26,339
is that you have to have these extra

1079
00:40:26,339 --> 00:40:28,260
assumptions which maybe you have some

1080
00:40:28,260 --> 00:40:29,940
sort of ethical or philosophical problem

1081
00:40:29,940 --> 00:40:32,040
with that like uh you know global

1082
00:40:32,040 --> 00:40:34,200
warming and also using EC you know Pi a

1083
00:40:34,200 --> 00:40:35,640
when you're doing ecdsa it could be a

1084
00:40:35,640 --> 00:40:38,280
problem uh heavy computation is the big

1085
00:40:38,280 --> 00:40:39,960
practical problem now you're doing

1086
00:40:39,960 --> 00:40:41,640
elliptic curves Were Meant to do

1087
00:40:41,640 --> 00:40:44,280
operations on 256 bits and now all of a

1088
00:40:44,280 --> 00:40:45,540
sudden you're doing operations on four

1089
00:40:45,540 --> 00:40:47,940
or five thousand bit uh integers and so

1090
00:40:47,940 --> 00:40:49,680
forth and they also seem to require

1091
00:40:49,680 --> 00:40:52,079
these very very tricky zero knowledge

1092
00:40:52,079 --> 00:40:53,880
proofs in the middle of the protocol and

1093
00:40:53,880 --> 00:40:55,440
if you try to skip them you get into

1094
00:40:55,440 --> 00:40:57,180
trouble so that's that's the problem

1095
00:40:57,180 --> 00:40:58,079
there

1096
00:40:58,079 --> 00:41:00,180
now Nigel and his student they had a

1097
00:41:00,180 --> 00:41:03,119
very clever way of handling this and

1098
00:41:03,119 --> 00:41:04,859
many other type of classes of problems

1099
00:41:04,859 --> 00:41:07,500
so they came up with NPC that has the

1100
00:41:07,500 --> 00:41:09,300
specific form that for computing

1101
00:41:09,300 --> 00:41:10,260
functions like this and let me explain

1102
00:41:10,260 --> 00:41:12,300
what that is so F let F be in any

1103
00:41:12,300 --> 00:41:14,760
algebraic computation with over x and x

1104
00:41:14,760 --> 00:41:15,780
inverse

1105
00:41:15,780 --> 00:41:18,000
and the output of your MPC has to be G

1106
00:41:18,000 --> 00:41:20,339
to this F value so that's the class of

1107
00:41:20,339 --> 00:41:22,619
NPC problems that they handle and they

1108
00:41:22,619 --> 00:41:24,660
came up with a very elegant idea using

1109
00:41:24,660 --> 00:41:27,240
speeds Max in the exponents very elegant

1110
00:41:27,240 --> 00:41:30,300
way but the way we look at this is uh

1111
00:41:30,300 --> 00:41:32,400
fundamentally it incurs a 2X overhead

1112
00:41:32,400 --> 00:41:34,380
because you're macking every algebraic

1113
00:41:34,380 --> 00:41:36,480
operation you do in F

1114
00:41:36,480 --> 00:41:39,119
and you also when we actually sit and

1115
00:41:39,119 --> 00:41:41,280
count the rounds we actually counted 13

1116
00:41:41,280 --> 00:41:42,960
extra rounds to deal with the

1117
00:41:42,960 --> 00:41:44,400
statistical Mac

1118
00:41:44,400 --> 00:41:46,260
so now let me get to the punch point the

1119
00:41:46,260 --> 00:41:47,880
motivation behind all of this talk right

1120
00:41:47,880 --> 00:41:49,980
here our family of protocols has the

1121
00:41:49,980 --> 00:41:52,079
following set of advantages first we

1122
00:41:52,079 --> 00:41:54,240
relax the statistical Mac to a

1123
00:41:54,240 --> 00:41:56,520
computational map and second of all this

1124
00:41:56,520 --> 00:41:58,800
is really the key Insight which is that

1125
00:41:58,800 --> 00:42:00,540
we realized that in the computation of

1126
00:42:00,540 --> 00:42:03,480
this signature we actually the uh some

1127
00:42:03,480 --> 00:42:04,859
intermediate value in that computation

1128
00:42:04,859 --> 00:42:07,200
actually operates like a Mac so you

1129
00:42:07,200 --> 00:42:09,480
don't have to do any extra work in order

1130
00:42:09,480 --> 00:42:11,579
to do this type of Mac that's really the

1131
00:42:11,579 --> 00:42:13,619
the key Insight of this this class this

1132
00:42:13,619 --> 00:42:15,900
this line of work and that results in a

1133
00:42:15,900 --> 00:42:18,300
faster protocol with fewer routes now

1134
00:42:18,300 --> 00:42:19,859
obviously we implemented this and we

1135
00:42:19,859 --> 00:42:21,900
evaluated it but it's better when I can

1136
00:42:21,900 --> 00:42:23,400
show you evaluations that other people

1137
00:42:23,400 --> 00:42:25,680
did so for example Danvers involved let

1138
00:42:25,680 --> 00:42:27,900
me apologize here to Marcel Keller I've

1139
00:42:27,900 --> 00:42:29,280
misspelled his name there the C should

1140
00:42:29,280 --> 00:42:30,480
be okay

1141
00:42:30,480 --> 00:42:32,880
they re they reevaluated a number of

1142
00:42:32,880 --> 00:42:34,920
threshold ecdsa schemes and I'll point

1143
00:42:34,920 --> 00:42:36,300
you to the yellow one there that's our

1144
00:42:36,300 --> 00:42:38,820
line and I'll also ask you to do the

1145
00:42:38,820 --> 00:42:40,079
math you can sort of see that our

1146
00:42:40,079 --> 00:42:42,300
Protocols are on the order of 10 to 100

1147
00:42:42,300 --> 00:42:44,040
times faster than some of the other

1148
00:42:44,040 --> 00:42:46,320
protocols in that area

1149
00:42:46,320 --> 00:42:48,660
very good now there's another protocol

1150
00:42:48,660 --> 00:42:50,700
is you at all they followed up on our

1151
00:42:50,700 --> 00:42:52,079
line of thinking about how to approach

1152
00:42:52,079 --> 00:42:54,300
this problem they also re-implemented

1153
00:42:54,300 --> 00:42:56,040
and evaluated a number of different

1154
00:42:56,040 --> 00:42:58,619
protocols uh specifically ones that use

1155
00:42:58,619 --> 00:43:00,480
the paella approaches ones that use EC

1156
00:43:00,480 --> 00:43:02,579
Pi a and ones that use class groups and

1157
00:43:02,579 --> 00:43:04,260
so forth again you can sort of see the

1158
00:43:04,260 --> 00:43:06,060
bottom two lines our Protocols are

1159
00:43:06,060 --> 00:43:09,359
actually 10 to 100x more efficient now

1160
00:43:09,359 --> 00:43:11,760
the very interesting point is that their

1161
00:43:11,760 --> 00:43:14,660
protocol that very last line is about

1162
00:43:14,660 --> 00:43:17,220
3.3 milliseconds faster than this and

1163
00:43:17,220 --> 00:43:18,960
they figured out this very clever

1164
00:43:18,960 --> 00:43:20,940
Insight that reduces the number of

1165
00:43:20,940 --> 00:43:22,440
multiplications you need to do this is

1166
00:43:22,440 --> 00:43:24,599
only for the two out of two case from

1167
00:43:24,599 --> 00:43:26,520
two multiplications our protocol to one

1168
00:43:26,520 --> 00:43:28,200
multiplication we think that's a very

1169
00:43:28,200 --> 00:43:30,599
interesting idea but for us to get our

1170
00:43:30,599 --> 00:43:32,819
security proof to work it look took a

1171
00:43:32,819 --> 00:43:35,099
lot of subtle uh sort of work to get our

1172
00:43:35,099 --> 00:43:37,200
security proof working and we have not

1173
00:43:37,200 --> 00:43:39,839
been able to evaluate their results and

1174
00:43:39,839 --> 00:43:41,460
uh and convince ourselves that it works

1175
00:43:41,460 --> 00:43:43,859
in the security way so they save one

1176
00:43:43,859 --> 00:43:45,540
multiplication they gain 0.3

1177
00:43:45,540 --> 00:43:47,819
milliseconds but they lose a little bit

1178
00:43:47,819 --> 00:43:50,460
of verifiability at least from our work

1179
00:43:50,460 --> 00:43:51,839
we're looking forward to seeing a final

1180
00:43:51,839 --> 00:43:53,819
version of their security proof okay so

1181
00:43:53,819 --> 00:43:55,319
that's the end of my motivation my rant

1182
00:43:55,319 --> 00:43:57,060
for why I think this is an important

1183
00:43:57,060 --> 00:43:59,220
area and why this line of work is the uh

1184
00:43:59,220 --> 00:44:01,560
the one to focus on let me talk about

1185
00:44:01,560 --> 00:44:03,900
the learnings that I had in trying to

1186
00:44:03,900 --> 00:44:05,640
build this and deploy this before I can

1187
00:44:05,640 --> 00:44:07,260
do that uh of course there's one

1188
00:44:07,260 --> 00:44:09,839
important uh little measure here so I'm

1189
00:44:09,839 --> 00:44:11,099
going to talk about the rest of the talk

1190
00:44:11,099 --> 00:44:13,740
for two out of two and K out of K which

1191
00:44:13,740 --> 00:44:15,839
is not necessarily a threshold right you

1192
00:44:15,839 --> 00:44:18,180
have to have two out of n but just to

1193
00:44:18,180 --> 00:44:19,859
say that this is the hardest version of

1194
00:44:19,859 --> 00:44:21,240
the problem two out of two or k-5k

1195
00:44:21,240 --> 00:44:23,700
because there is this nice guy uh nice

1196
00:44:23,700 --> 00:44:25,500
handsome guy named LaGrange he has a

1197
00:44:25,500 --> 00:44:27,540
very nice idea there if you know this

1198
00:44:27,540 --> 00:44:28,859
idea it's great if you don't look on the

1199
00:44:28,859 --> 00:44:30,780
Wikipedia page there you just need a

1200
00:44:30,780 --> 00:44:33,300
multiplier uh in order to reduce the two

1201
00:44:33,300 --> 00:44:35,040
out of n case or the K out of n case to

1202
00:44:35,040 --> 00:44:36,300
the two out of two or the K out of K

1203
00:44:36,300 --> 00:44:38,040
case you just use this trick you just

1204
00:44:38,040 --> 00:44:39,540
use a local operation and then you can

1205
00:44:39,540 --> 00:44:42,000
just use one of those protocols above

1206
00:44:42,000 --> 00:44:43,980
okay so now my six learnings from this

1207
00:44:43,980 --> 00:44:45,960
area Okay so these are the improvements

1208
00:44:45,960 --> 00:44:47,400
that we've discovered while implementing

1209
00:44:47,400 --> 00:44:49,079
and helping other teams and this is a

1210
00:44:49,079 --> 00:44:50,700
long list of people who we want to thank

1211
00:44:50,700 --> 00:44:52,740
for giving us a great feedback on how to

1212
00:44:52,740 --> 00:44:53,940
improve our work

1213
00:44:53,940 --> 00:44:57,420
first point from our 2018 paper this was

1214
00:44:57,420 --> 00:44:59,280
the form of our protocol and forget

1215
00:44:59,280 --> 00:45:00,839
about the details just look at the

1216
00:45:00,839 --> 00:45:02,339
direction of the arrows it's actually a

1217
00:45:02,339 --> 00:45:05,099
two round protocol Bob sends a bunch of

1218
00:45:05,099 --> 00:45:07,319
messages to Alice including the

1219
00:45:07,319 --> 00:45:09,480
multiplier the OT multiplier that we use

1220
00:45:09,480 --> 00:45:12,240
and then Alice sends a response back and

1221
00:45:12,240 --> 00:45:14,339
Bob can reconstruct the signature

1222
00:45:14,339 --> 00:45:16,920
this uh if we think about the talk from

1223
00:45:16,920 --> 00:45:19,740
Monday Apple they gave us a very good

1224
00:45:19,740 --> 00:45:21,480
reason for picking a protocol like this

1225
00:45:21,480 --> 00:45:23,640
we wanted this message structure the one

1226
00:45:23,640 --> 00:45:25,440
round message structure for achieving

1227
00:45:25,440 --> 00:45:27,180
this type of thing but it has a natural

1228
00:45:27,180 --> 00:45:30,780
problem which is that in this case there

1229
00:45:30,780 --> 00:45:33,060
is always a bias to the nonce you cannot

1230
00:45:33,060 --> 00:45:36,599
avoid that and the way we the way that

1231
00:45:36,599 --> 00:45:38,520
shows up in the proof is that when we

1232
00:45:38,520 --> 00:45:40,619
identify our ideal functionality we have

1233
00:45:40,619 --> 00:45:42,000
this little blue section right here

1234
00:45:42,000 --> 00:45:44,460
which formally defines the way in which

1235
00:45:44,460 --> 00:45:47,400
Alice can bias the non-stitch using the

1236
00:45:47,400 --> 00:45:48,780
signature and that's obviously not a

1237
00:45:48,780 --> 00:45:51,240
bias in which Alice can pick any nonce

1238
00:45:51,240 --> 00:45:52,500
that she wants that would be insecure

1239
00:45:52,500 --> 00:45:54,660
there's this nice little trick that we

1240
00:45:54,660 --> 00:45:56,460
use in the random Oracle model which

1241
00:45:56,460 --> 00:45:58,740
basically allows Alice to grind so she

1242
00:45:58,740 --> 00:46:00,660
can push a button get a nons look at it

1243
00:46:00,660 --> 00:46:01,800
if she doesn't like it throw it away and

1244
00:46:01,800 --> 00:46:03,180
push another button she can push that

1245
00:46:03,180 --> 00:46:04,440
button polynomial number of times

1246
00:46:04,440 --> 00:46:06,900
because she's polytime bounded and then

1247
00:46:06,900 --> 00:46:08,160
when she gets when she likes she can

1248
00:46:08,160 --> 00:46:10,500
continue the protocol and that is a bias

1249
00:46:10,500 --> 00:46:12,540
that we show does not affect the

1250
00:46:12,540 --> 00:46:13,980
security of the protocol in the generic

1251
00:46:13,980 --> 00:46:14,760
group model

1252
00:46:14,760 --> 00:46:17,040
but yudah Lindell he called us out on

1253
00:46:17,040 --> 00:46:18,839
this he said you know what this is an

1254
00:46:18,839 --> 00:46:21,240
extra you know cognitive overhead that

1255
00:46:21,240 --> 00:46:22,440
you have to think about and you know

1256
00:46:22,440 --> 00:46:24,180
does people does this work in the

1257
00:46:24,180 --> 00:46:25,859
application that you want he said really

1258
00:46:25,859 --> 00:46:28,260
we want clean functionalities he wants

1259
00:46:28,260 --> 00:46:29,640
functionalities that look just like this

1260
00:46:29,640 --> 00:46:32,220
where line 12 it's just what the ideal

1261
00:46:32,220 --> 00:46:33,660
functionality is doing is Computing

1262
00:46:33,660 --> 00:46:36,119
exactly the uh you know the standard

1263
00:46:36,119 --> 00:46:38,220
notion of that signature so we can

1264
00:46:38,220 --> 00:46:40,020
update our protocol to do that and we

1265
00:46:40,020 --> 00:46:42,300
have of course it just requires for

1266
00:46:42,300 --> 00:46:43,800
cartographers it just requires one

1267
00:46:43,800 --> 00:46:45,660
commitment in the first line of the

1268
00:46:45,660 --> 00:46:47,700
protocol and so our new protocol is like

1269
00:46:47,700 --> 00:46:49,680
this it takes three messages but what we

1270
00:46:49,680 --> 00:46:52,140
realized is that actually this this

1271
00:46:52,140 --> 00:46:54,599
comes for free because when you're

1272
00:46:54,599 --> 00:46:55,920
running a threshold signature and you

1273
00:46:55,920 --> 00:46:57,359
need to sign multiple particular

1274
00:46:57,359 --> 00:46:58,560
messages

1275
00:46:58,560 --> 00:47:01,079
you can move the first message and

1276
00:47:01,079 --> 00:47:03,240
pipeline it with the very last message

1277
00:47:03,240 --> 00:47:06,420
of the last protocol and normally you

1278
00:47:06,420 --> 00:47:07,200
wouldn't want to do this in a

1279
00:47:07,200 --> 00:47:08,520
cryptographic protocol because you have

1280
00:47:08,520 --> 00:47:10,800
to keep state but in a threshold key

1281
00:47:10,800 --> 00:47:12,900
setting scenario everybody's keeping

1282
00:47:12,900 --> 00:47:14,220
State already they're keeping their

1283
00:47:14,220 --> 00:47:15,960
threshold key and they're keeping all

1284
00:47:15,960 --> 00:47:17,160
sorts of other state information already

1285
00:47:17,160 --> 00:47:20,339
so we just add this first round to the

1286
00:47:20,339 --> 00:47:23,160
last message and we get back a protocol

1287
00:47:23,160 --> 00:47:25,319
that like apple likes which is basically

1288
00:47:25,319 --> 00:47:28,079
Bob Dallas and Alice to Bob so this was

1289
00:47:28,079 --> 00:47:29,700
thank you though for pushing us to do

1290
00:47:29,700 --> 00:47:30,720
this

1291
00:47:30,720 --> 00:47:33,540
second one key refresh in real life you

1292
00:47:33,540 --> 00:47:35,220
need to be able to refresh your key what

1293
00:47:35,220 --> 00:47:37,200
does that mean that means that this

1294
00:47:37,200 --> 00:47:38,940
group of parties has some key for a

1295
00:47:38,940 --> 00:47:40,440
particular public key they want to push

1296
00:47:40,440 --> 00:47:42,660
a refresh button and each of them wants

1297
00:47:42,660 --> 00:47:45,720
to get a new key for the same public key

1298
00:47:45,720 --> 00:47:48,000
and it turns out my student Yash and his

1299
00:47:48,000 --> 00:47:49,619
co-authors figured out how to do this

1300
00:47:49,619 --> 00:47:51,540
very very efficiently for our particular

1301
00:47:51,540 --> 00:47:54,359
protocol so use these set of ideas and

1302
00:47:54,359 --> 00:47:56,160
when he benchmarked it for our two out

1303
00:47:56,160 --> 00:47:58,260
of n case it actually added one

1304
00:47:58,260 --> 00:48:00,000
millisecond to do this refresh every

1305
00:48:00,000 --> 00:48:02,220
time you sign you the party's refreshed

1306
00:48:02,220 --> 00:48:03,240
now that assumes that all the end

1307
00:48:03,240 --> 00:48:05,040
parties are online but even if you don't

1308
00:48:05,040 --> 00:48:06,599
do that whenever the on parties are

1309
00:48:06,599 --> 00:48:08,819
online it adds one second to the overall

1310
00:48:08,819 --> 00:48:10,980
protocol one millisecond sorry

1311
00:48:10,980 --> 00:48:13,440
roughly 20 percent of uh of the time of

1312
00:48:13,440 --> 00:48:16,859
our protocol great but this really only

1313
00:48:16,859 --> 00:48:19,680
works when you can refresh the key very

1314
00:48:19,680 --> 00:48:21,599
efficiently for the K out of n case so

1315
00:48:21,599 --> 00:48:24,300
for example in a pi a uh setting it's

1316
00:48:24,300 --> 00:48:26,460
really really hard to re-randomize the N

1317
00:48:26,460 --> 00:48:29,339
that you use when you set up a threshold

1318
00:48:29,339 --> 00:48:31,319
key that's based on this Pi a thing it's

1319
00:48:31,319 --> 00:48:33,599
really hard to re-randomize an RSA

1320
00:48:33,599 --> 00:48:35,520
modulus right you have to just come up

1321
00:48:35,520 --> 00:48:36,960
with the new one and that means a whole

1322
00:48:36,960 --> 00:48:38,940
new key setup and in that world it

1323
00:48:38,940 --> 00:48:40,980
basically takes seconds to refresh

1324
00:48:40,980 --> 00:48:42,240
okay

1325
00:48:42,240 --> 00:48:45,119
third thing is performance so this was a

1326
00:48:45,119 --> 00:48:47,040
table of performance for number of

1327
00:48:47,040 --> 00:48:50,640
parties of going from 5 to 128 in 2019

1328
00:48:50,640 --> 00:48:52,440
and you can sort of see take any

1329
00:48:52,440 --> 00:48:53,819
particular line look at the one case

1330
00:48:53,819 --> 00:48:56,099
when we're running in one particular gcp

1331
00:48:56,099 --> 00:48:59,280
Zone and uh that's basically roughly the

1332
00:48:59,280 --> 00:49:01,440
compute bound aspect of the protocol

1333
00:49:01,440 --> 00:49:03,960
using Lan which is inside a data centers

1334
00:49:03,960 --> 00:49:06,660
very fast and the five or 16 Zone ones

1335
00:49:06,660 --> 00:49:08,339
basically reflect the overhead of

1336
00:49:08,339 --> 00:49:09,720
actually communicating across a

1337
00:49:09,720 --> 00:49:11,760
continent or across the world

1338
00:49:11,760 --> 00:49:14,400
and the reason for this basically slow

1339
00:49:14,400 --> 00:49:16,020
down was that we picked a protocol that

1340
00:49:16,020 --> 00:49:17,940
had log T where T was the threshold plus

1341
00:49:17,940 --> 00:49:20,640
six rounds for this and at the time we

1342
00:49:20,640 --> 00:49:22,440
had a 10 round protocol that was also a

1343
00:49:22,440 --> 00:49:25,500
constant round but because we realized

1344
00:49:25,500 --> 00:49:26,819
that this was kind of a bottleneck we'd

1345
00:49:26,819 --> 00:49:28,619
come up with a new version a five round

1346
00:49:28,619 --> 00:49:30,660
protocol it doesn't have any zero

1347
00:49:30,660 --> 00:49:32,280
knowledge proofs it really uses this

1348
00:49:32,280 --> 00:49:34,800
trick that I mentioned about macking and

1349
00:49:34,800 --> 00:49:36,060
so forth and the random Oracle model

1350
00:49:36,060 --> 00:49:38,220
tricks there are no hidden fees it's not

1351
00:49:38,220 --> 00:49:39,960
hiding rounds in pre-processing or

1352
00:49:39,960 --> 00:49:41,400
offline or anything like this this is

1353
00:49:41,400 --> 00:49:43,380
the protocol and all of the operations

1354
00:49:43,380 --> 00:49:45,420
are symmetric operations for signing you

1355
00:49:45,420 --> 00:49:48,119
need 13 elliptic curve operations to

1356
00:49:48,119 --> 00:49:50,220
verify some of the checks but most of it

1357
00:49:50,220 --> 00:49:54,180
is all AES or sha which can be very very

1358
00:49:54,180 --> 00:49:56,339
fast on mobile processors

1359
00:49:56,339 --> 00:49:58,920
okay number four uh and this we want to

1360
00:49:58,920 --> 00:50:00,660
give Lance Roy and Ben Riva some credit

1361
00:50:00,660 --> 00:50:02,640
for this so Lance Roy's show so our

1362
00:50:02,640 --> 00:50:04,920
protocol uses an OT extension in our

1363
00:50:04,920 --> 00:50:06,540
academic implementation we used a

1364
00:50:06,540 --> 00:50:08,520
particular OT extension this Kos

1365
00:50:08,520 --> 00:50:10,619
extension and Lance showed an attack

1366
00:50:10,619 --> 00:50:13,260
against that Kos extension for a

1367
00:50:13,260 --> 00:50:15,480
particular uh set of parameters now

1368
00:50:15,480 --> 00:50:17,280
those parameters don't apply to our

1369
00:50:17,280 --> 00:50:19,859
implementation or sorry to our use of

1370
00:50:19,859 --> 00:50:21,720
Kos so our implementation wasn't

1371
00:50:21,720 --> 00:50:24,599
vulnerable uh but it did identify a gap

1372
00:50:24,599 --> 00:50:26,880
in the Kos proof and so we're moving to

1373
00:50:26,880 --> 00:50:28,200
soft spoken

1374
00:50:28,200 --> 00:50:30,960
a more interesting uh observation Ben

1375
00:50:30,960 --> 00:50:34,140
Riva showed and this was a pure systems

1376
00:50:34,140 --> 00:50:36,240
level fault in our academic

1377
00:50:36,240 --> 00:50:38,460
implementation so when you run many

1378
00:50:38,460 --> 00:50:41,220
sub-protocols and one let's so at one

1379
00:50:41,220 --> 00:50:43,680
point you run 128 of these OT extension

1380
00:50:43,680 --> 00:50:46,800
protocols if one of them fails the

1381
00:50:46,800 --> 00:50:48,900
program should basically filter that

1382
00:50:48,900 --> 00:50:50,579
failure all the way up to the top and we

1383
00:50:50,579 --> 00:50:52,319
weren't handling that case uh properly

1384
00:50:52,319 --> 00:50:54,420
and so Ben Reeve appointed that and we

1385
00:50:54,420 --> 00:50:55,800
fixed it out very very little clever

1386
00:50:55,800 --> 00:50:57,540
observation that he made

1387
00:50:57,540 --> 00:50:59,400
okay the more interesting things we've

1388
00:50:59,400 --> 00:51:01,079
learned are basically the gaps between

1389
00:51:01,079 --> 00:51:03,240
theory and practice and these are three

1390
00:51:03,240 --> 00:51:04,680
of those these that I want to basically

1391
00:51:04,680 --> 00:51:06,960
cover the first one is a very standard

1392
00:51:06,960 --> 00:51:08,819
one we've seen a lot of bug bounties

1393
00:51:08,819 --> 00:51:10,980
recently about improper use of the Fiat

1394
00:51:10,980 --> 00:51:13,079
Shamir transform where you don't include

1395
00:51:13,079 --> 00:51:15,359
the context if you write a full security

1396
00:51:15,359 --> 00:51:18,359
proof where this issue comes up is that

1397
00:51:18,359 --> 00:51:20,220
in a programmable random Oracle model

1398
00:51:20,220 --> 00:51:21,420
you have to assume that every

1399
00:51:21,420 --> 00:51:23,819
subprotocol uses its own random Oracle

1400
00:51:23,819 --> 00:51:25,440
and that's easy to do if you can

1401
00:51:25,440 --> 00:51:27,119
basically include some prefix at the

1402
00:51:27,119 --> 00:51:29,280
beginning of that hash now our academic

1403
00:51:29,280 --> 00:51:32,040
implementation had about 574 lines that

1404
00:51:32,040 --> 00:51:34,020
synchronized this selection of random

1405
00:51:34,020 --> 00:51:35,700
Oracle tags to make sure each random

1406
00:51:35,700 --> 00:51:36,900
Oracle was separate

1407
00:51:36,900 --> 00:51:40,200
and I basically I learned TLA plus which

1408
00:51:40,200 --> 00:51:41,579
is this amazing thing that Leslie

1409
00:51:41,579 --> 00:51:43,920
Lamport has done and I started thinking

1410
00:51:43,920 --> 00:51:46,200
I could do a better version of this 574

1411
00:51:46,200 --> 00:51:48,480
lines and I started working my way to

1412
00:51:48,480 --> 00:51:50,280
this and it came up it basically led me

1413
00:51:50,280 --> 00:51:52,740
exactly how Leslie says which is that if

1414
00:51:52,740 --> 00:51:54,000
you think about this thing you come up

1415
00:51:54,000 --> 00:51:55,440
with a better algorithm we found a much

1416
00:51:55,440 --> 00:51:57,420
simpler way to do this so thank you TLA

1417
00:51:57,420 --> 00:51:58,680
plus people

1418
00:51:58,680 --> 00:52:01,680
the elephant in this room is straight

1419
00:52:01,680 --> 00:52:04,319
line extractability

1420
00:52:04,319 --> 00:52:07,579
slit that hang for a while

1421
00:52:08,339 --> 00:52:09,480
so

1422
00:52:09,480 --> 00:52:11,339
a protocol that uses zero knowledge

1423
00:52:11,339 --> 00:52:14,880
proofs in a concurrent setting basically

1424
00:52:14,880 --> 00:52:16,680
it needs to extract Witnesses without

1425
00:52:16,680 --> 00:52:20,059
rewinding and the Fiat Shamir technique

1426
00:52:20,059 --> 00:52:22,619
does not let you do this it does not let

1427
00:52:22,619 --> 00:52:24,540
you extract Witnesses without rewinding

1428
00:52:24,540 --> 00:52:26,760
so what you needed to use is a straight

1429
00:52:26,760 --> 00:52:29,280
line extractable technique and pass and

1430
00:52:29,280 --> 00:52:32,160
Mark fishelin and then myself and my

1431
00:52:32,160 --> 00:52:34,079
student we came up with different more

1432
00:52:34,079 --> 00:52:36,359
efficient ways to do this but they all

1433
00:52:36,359 --> 00:52:38,280
boil down to running like 10 copies if

1434
00:52:38,280 --> 00:52:40,020
you need to do one proof and you needed

1435
00:52:40,020 --> 00:52:41,460
to be straight line extractable in the

1436
00:52:41,460 --> 00:52:43,500
random Oracle then it roughly takes

1437
00:52:43,500 --> 00:52:45,780
about 10 times running that proof even

1438
00:52:45,780 --> 00:52:47,760
if you use very uh sophisticated

1439
00:52:47,760 --> 00:52:50,099
techniques concurrent means if you are

1440
00:52:50,099 --> 00:52:52,800
using a threshold setting in web 3 or

1441
00:52:52,800 --> 00:52:55,140
actually in web 2 or on the Internet

1442
00:52:55,140 --> 00:52:57,300
then that means you are in a concurrent

1443
00:52:57,300 --> 00:53:00,059
setting and if you're doing this just at

1444
00:53:00,059 --> 00:53:01,559
home then maybe you're not in a

1445
00:53:01,559 --> 00:53:02,880
concurrent setting but so that's that's

1446
00:53:02,880 --> 00:53:04,619
the escape hatch but for all of these

1447
00:53:04,619 --> 00:53:07,260
other deployments this I think is a gap

1448
00:53:07,260 --> 00:53:09,240
so are there concurrent attacks are

1449
00:53:09,240 --> 00:53:11,339
there explicit attacks that use

1450
00:53:11,339 --> 00:53:13,260
concurrency as a way well the Ros

1451
00:53:13,260 --> 00:53:15,420
attacks are in fact one type of

1452
00:53:15,420 --> 00:53:18,359
concurrency attack and this is an attack

1453
00:53:18,359 --> 00:53:21,059
that doesn't have an explicit way to

1454
00:53:21,059 --> 00:53:23,220
break a protocol right now uh you can't

1455
00:53:23,220 --> 00:53:24,900
break Fiat Shamir this way but is in

1456
00:53:24,900 --> 00:53:27,300
fact you know as Humanity We should

1457
00:53:27,300 --> 00:53:29,040
strive for understanding what our Theory

1458
00:53:29,040 --> 00:53:30,420
tells us and our Theory tells us to do

1459
00:53:30,420 --> 00:53:33,300
this so what it told us is that we

1460
00:53:33,300 --> 00:53:34,980
should strive to build a protocol that

1461
00:53:34,980 --> 00:53:37,140
does not need like a Fiat Shamir

1462
00:53:37,140 --> 00:53:39,240
discrete log proof in the middle of it

1463
00:53:39,240 --> 00:53:41,579
and that's what led us to drive us to do

1464
00:53:41,579 --> 00:53:43,440
this five-run protocol where you just

1465
00:53:43,440 --> 00:53:46,079
use commitments and the multiplier

1466
00:53:46,079 --> 00:53:48,300
so we don't have that overhead there Pi

1467
00:53:48,300 --> 00:53:50,520
a on the other hand needs this these are

1468
00:53:50,520 --> 00:53:52,920
just four lines of types of proofs uh

1469
00:53:52,920 --> 00:53:54,660
copied from the paper the most recent

1470
00:53:54,660 --> 00:53:56,520
paper that most correct paper on this

1471
00:53:56,520 --> 00:53:58,020
topic and all of these are zero

1472
00:53:58,020 --> 00:53:59,940
knowledge proofs and of course maybe

1473
00:53:59,940 --> 00:54:01,319
some of them don't need full extraction

1474
00:54:01,319 --> 00:54:03,000
and so forth but it's very very tricky

1475
00:54:03,000 --> 00:54:04,559
to figure out whether this works in a

1476
00:54:04,559 --> 00:54:06,660
concurrent setting or not how do you

1477
00:54:06,660 --> 00:54:08,700
avoid this straight line extraction

1478
00:54:08,700 --> 00:54:10,859
penalty I thought about that if you are

1479
00:54:10,859 --> 00:54:12,420
running threshold signatures just

1480
00:54:12,420 --> 00:54:14,640
between devices like for example to keep

1481
00:54:14,640 --> 00:54:16,380
your key for ethereum or something like

1482
00:54:16,380 --> 00:54:18,180
that and these are devices you all hold

1483
00:54:18,180 --> 00:54:19,140
and you don't think they'll be

1484
00:54:19,140 --> 00:54:21,359
compromised and you do that at home then

1485
00:54:21,359 --> 00:54:23,099
maybe you can serialize your executions

1486
00:54:23,099 --> 00:54:24,780
and never run in a concurrent setting

1487
00:54:24,780 --> 00:54:27,599
but if you're using a company that runs

1488
00:54:27,599 --> 00:54:29,520
a server that is holding half of your

1489
00:54:29,520 --> 00:54:31,440
key like many of the deployments then

1490
00:54:31,440 --> 00:54:32,760
this is an issue that has to be

1491
00:54:32,760 --> 00:54:35,040
basically dealt with

1492
00:54:35,040 --> 00:54:37,800
okay uh now finally the very last

1493
00:54:37,800 --> 00:54:39,059
section the really really really

1494
00:54:39,059 --> 00:54:41,700
difficult issues uh that I basically

1495
00:54:41,700 --> 00:54:44,160
have no knowledge about

1496
00:54:44,160 --> 00:54:46,559
okay great so the environment when we

1497
00:54:46,559 --> 00:54:48,780
write security proofs especially UC

1498
00:54:48,780 --> 00:54:50,760
proofs we talk about this magic entity Z

1499
00:54:50,760 --> 00:54:52,740
called the environment and it gives us

1500
00:54:52,740 --> 00:54:54,839
all the things here the common knowledge

1501
00:54:54,839 --> 00:54:56,160
of the participants of the protocol

1502
00:54:56,160 --> 00:54:58,559
common knowledge of the message a

1503
00:54:58,559 --> 00:55:00,720
session ID as well as authenticated

1504
00:55:00,720 --> 00:55:03,059
channels between all of the parties and

1505
00:55:03,059 --> 00:55:05,579
that's in fact here is how we run our

1506
00:55:05,579 --> 00:55:07,920
protocol and we uh basically uh

1507
00:55:07,920 --> 00:55:09,780
Benchmark it and there you see the hand

1508
00:55:09,780 --> 00:55:11,819
of God giving you all of this

1509
00:55:11,819 --> 00:55:13,079
information about this particular

1510
00:55:13,079 --> 00:55:15,180
protocol and that's how we can Benchmark

1511
00:55:15,180 --> 00:55:17,520
this but where does it come in real life

1512
00:55:17,520 --> 00:55:19,559
where does this setup come in real life

1513
00:55:19,559 --> 00:55:22,260
if uh I've spent my time trying to

1514
00:55:22,260 --> 00:55:24,599
deploy this and how do you basically get

1515
00:55:24,599 --> 00:55:26,819
K devices to know about each other

1516
00:55:26,819 --> 00:55:28,500
common knowledge of each other and all

1517
00:55:28,500 --> 00:55:29,520
the parameters of this particular

1518
00:55:29,520 --> 00:55:32,520
protocol maybe with a QR code where one

1519
00:55:32,520 --> 00:55:34,859
scans right but is that exactly the

1520
00:55:34,859 --> 00:55:36,420
model because do all need to scan each

1521
00:55:36,420 --> 00:55:38,579
other do you need N squared QR scans or

1522
00:55:38,579 --> 00:55:41,339
n scans it's it's uh I don't have a good

1523
00:55:41,339 --> 00:55:43,319
answer to this uh

1524
00:55:43,319 --> 00:55:46,319
um okay other cases growing a

1525
00:55:46,319 --> 00:55:48,240
participant set in the real world you

1526
00:55:48,240 --> 00:55:49,800
don't figure out t and n at the

1527
00:55:49,800 --> 00:55:51,240
beginning of the whole world you need to

1528
00:55:51,240 --> 00:55:53,099
extend it so you start with cat of K

1529
00:55:53,099 --> 00:55:54,720
maybe you want to go to k out of K plus

1530
00:55:54,720 --> 00:55:57,119
one add a device how do you do that well

1531
00:55:57,119 --> 00:55:58,920
there are that's actually not so hard

1532
00:55:58,920 --> 00:56:00,420
that's pretty simple Shamir type of

1533
00:56:00,420 --> 00:56:03,240
trick with LaGrange Etc uh how do you

1534
00:56:03,240 --> 00:56:04,680
change threshold you start with Canada

1535
00:56:04,680 --> 00:56:06,780
you go to K plus one out of K plus one

1536
00:56:06,780 --> 00:56:08,280
how do you do that you have to do a key

1537
00:56:08,280 --> 00:56:10,020
refresh

1538
00:56:10,020 --> 00:56:12,480
and the biggest problem when I started

1539
00:56:12,480 --> 00:56:14,760
trying to implement an iPhone app and an

1540
00:56:14,760 --> 00:56:16,079
Android app that does this like

1541
00:56:16,079 --> 00:56:18,359
basically all three of all these things

1542
00:56:18,359 --> 00:56:20,400
just they're very hard to do when the

1543
00:56:20,400 --> 00:56:22,740
parties aren't local how exactly do you

1544
00:56:22,740 --> 00:56:24,000
deal with this when someone is

1545
00:56:24,000 --> 00:56:25,859
requesting to join a particular set of

1546
00:56:25,859 --> 00:56:27,599
keys do you know this participant you

1547
00:56:27,599 --> 00:56:29,040
require them to be authenticated and log

1548
00:56:29,040 --> 00:56:31,319
in with like Google or Apple first

1549
00:56:31,319 --> 00:56:32,760
before you allow them to do a threshold

1550
00:56:32,760 --> 00:56:35,040
key it's a problem that I would love to

1551
00:56:35,040 --> 00:56:36,660
get some advice on because I'm sure

1552
00:56:36,660 --> 00:56:38,880
there's a smart person in this room that

1553
00:56:38,880 --> 00:56:40,800
knows more about it than me

1554
00:56:40,800 --> 00:56:43,319
finally this is something that also is

1555
00:56:43,319 --> 00:56:45,660
devastating to me so I've set up a two

1556
00:56:45,660 --> 00:56:47,700
out of two key but then I lost my phone

1557
00:56:47,700 --> 00:56:49,980
but again the instructions told me that

1558
00:56:49,980 --> 00:56:51,780
I should you know basically back up or

1559
00:56:51,780 --> 00:56:53,099
do something and I was going to do a two

1560
00:56:53,099 --> 00:56:54,480
out of three but I lost my phone in the

1561
00:56:54,480 --> 00:56:56,160
time between I set it up and right

1562
00:56:56,160 --> 00:56:58,079
everybody understands this scenario what

1563
00:56:58,079 --> 00:57:00,420
do you do in this scenario every company

1564
00:57:00,420 --> 00:57:02,520
that or every

1565
00:57:02,520 --> 00:57:04,380
every real world deployment has to deal

1566
00:57:04,380 --> 00:57:05,579
with this and they have to deal with it

1567
00:57:05,579 --> 00:57:06,780
in a way that doesn't lose the

1568
00:57:06,780 --> 00:57:09,960
customer's wealth or data and so you

1569
00:57:09,960 --> 00:57:11,280
basically have to break the abstraction

1570
00:57:11,280 --> 00:57:13,200
of the whole point of threshold crypto

1571
00:57:13,200 --> 00:57:14,940
is to make sure that no single party has

1572
00:57:14,940 --> 00:57:17,220
all the pieces and this is a real

1573
00:57:17,220 --> 00:57:19,380
problem it's a real philosophical issue

1574
00:57:19,380 --> 00:57:21,359
with this whole area so again I asked

1575
00:57:21,359 --> 00:57:23,579
myself is threshold the idea of

1576
00:57:23,579 --> 00:57:26,220
threshold signing a thing is that 10x

1577
00:57:26,220 --> 00:57:29,040
better Improvement for a user or for an

1578
00:57:29,040 --> 00:57:33,020
organization what do you think

1579
00:57:37,339 --> 00:57:39,720
come on put your philosopher hat on

1580
00:57:39,720 --> 00:57:41,760
Nigel is it better is it 10x better or

1581
00:57:41,760 --> 00:57:43,200
not

1582
00:57:43,200 --> 00:57:45,720
So 2fa my answer to this after thinking

1583
00:57:45,720 --> 00:57:47,640
about this 2fa is a real pain in the ass

1584
00:57:47,640 --> 00:57:49,740
if I have to log into Northeastern I

1585
00:57:49,740 --> 00:57:51,900
have to do this Duo thing or I've you

1586
00:57:51,900 --> 00:57:54,900
know I basically I I'm late on all of my

1587
00:57:54,900 --> 00:57:59,339
submissions because of this 2fa but so

1588
00:57:59,339 --> 00:58:02,280
like my expense reports and stuff but

1589
00:58:02,280 --> 00:58:03,960
so for me it's a little bit of friction

1590
00:58:03,960 --> 00:58:07,980
for the organization 2fa is basically a

1591
00:58:07,980 --> 00:58:10,260
real game changer in terms of their

1592
00:58:10,260 --> 00:58:12,119
operational security so that's my same

1593
00:58:12,119 --> 00:58:14,099
answer for this type of thing I do think

1594
00:58:14,099 --> 00:58:16,859
threshold uh is useful even though it's

1595
00:58:16,859 --> 00:58:18,599
going to put a lot of burden on people

1596
00:58:18,599 --> 00:58:21,180
but it is going to help some sort of

1597
00:58:21,180 --> 00:58:23,460
operational organizational societal type

1598
00:58:23,460 --> 00:58:25,800
of things for example GitHub

1599
00:58:25,800 --> 00:58:28,200
accidentally messed up their key right

1600
00:58:28,200 --> 00:58:31,619
everybody know about this and and if if

1601
00:58:31,619 --> 00:58:33,599
it was a threshold key it might be

1602
00:58:33,599 --> 00:58:35,880
better now do we have threshold SSH uh

1603
00:58:35,880 --> 00:58:39,900
not yet but why not uh and maybe that

1604
00:58:39,900 --> 00:58:41,579
prev prevents that one problem which

1605
00:58:41,579 --> 00:58:43,619
caused a lot of developer friction like

1606
00:58:43,619 --> 00:58:46,140
one day of mess-ups right for you know

1607
00:58:46,140 --> 00:58:48,059
two million developers is a big is a big

1608
00:58:48,059 --> 00:58:50,099
cost in society anyway that's the end of

1609
00:58:50,099 --> 00:58:53,720
my talk appreciate your attention

1610
00:59:02,660 --> 00:59:06,780
is the protocol basically mascot to

1611
00:59:06,780 --> 00:59:08,339
produce Beaver triples then do the

1612
00:59:08,339 --> 00:59:10,020
inversion no we don't do Dr we don't use

1613
00:59:10,020 --> 00:59:12,000
Beaver triples that is that is the

1614
00:59:12,000 --> 00:59:13,920
clever thing we don't do it we do use

1615
00:59:13,920 --> 00:59:16,380
baru barilan uh the beaver barilani

1616
00:59:16,380 --> 00:59:18,780
inversion technique but we we don't use

1617
00:59:18,780 --> 00:59:21,359
triples that's why we avoid the overhead

1618
00:59:21,359 --> 00:59:24,480
uh from from your St but but the Mac is

1619
00:59:24,480 --> 00:59:26,040
done because it's basically it's a

1620
00:59:26,040 --> 00:59:27,660
signature in some sense you don't need

1621
00:59:27,660 --> 00:59:29,819
to also it's self-authenticating it's

1622
00:59:29,819 --> 00:59:33,420
self-authenticating yeah that's yeah

1623
00:59:33,420 --> 00:59:35,640
okay thanks a lot all right Gregory the

1624
00:59:35,640 --> 00:59:39,190
stage is yours okay thanks again

1625
00:59:39,190 --> 00:59:41,160
[Music]

1626
00:59:41,160 --> 00:59:46,200
this is my daughter saber from the llms

1627
00:59:46,200 --> 00:59:48,720
okay the last torque in the session is

1628
00:59:48,720 --> 00:59:50,640
about

1629
00:59:50,640 --> 00:59:52,799
um how a blockchain can keep many

1630
00:59:52,799 --> 00:59:54,200
secrets

1631
00:59:54,200 --> 00:59:58,160
Gregory is the speaker

1632
00:59:58,260 --> 01:00:00,059
thank you very much

1633
01:00:00,059 --> 01:00:02,760
yeah this is uh work with my esteemed

1634
01:00:02,760 --> 01:00:04,920
former colleagues Andrea Shirley Ashling

1635
01:00:04,920 --> 01:00:07,079
Conley Francis and Victor Shoup at

1636
01:00:07,079 --> 01:00:09,359
Infinity I have just left Divinity will

1637
01:00:09,359 --> 01:00:11,400
be taking a new job at chain link lab

1638
01:00:11,400 --> 01:00:12,839
soon that I'm really looking forward to

1639
01:00:12,839 --> 01:00:14,819
but obviously most of this work was done

1640
01:00:14,819 --> 01:00:17,940
while um while I was still at divinity

1641
01:00:17,940 --> 01:00:20,700
yeah so oh yeah and by the way there is

1642
01:00:20,700 --> 01:00:24,020
going to be blockchain in this talk

1643
01:00:24,059 --> 01:00:25,680
um so in case you haven't been following

1644
01:00:25,680 --> 01:00:27,540
up on how blockchain has been evolving

1645
01:00:27,540 --> 01:00:29,220
it of course all started with Bitcoin

1646
01:00:29,220 --> 01:00:32,220
and um similar payment networks um

1647
01:00:32,220 --> 01:00:33,900
whether or not named after a sort of

1648
01:00:33,900 --> 01:00:35,040
animal

1649
01:00:35,040 --> 01:00:37,020
um they were doing mostly or just

1650
01:00:37,020 --> 01:00:40,079
payments soon after that ethereum came

1651
01:00:40,079 --> 01:00:41,819
up realizing that payments is actually

1652
01:00:41,819 --> 01:00:43,380
restricted functionality and this could

1653
01:00:43,380 --> 01:00:45,720
be generalized to small Snippets of code

1654
01:00:45,720 --> 01:00:47,640
the code smart contracts that could

1655
01:00:47,640 --> 01:00:50,160
usefully run in a decentralized

1656
01:00:50,160 --> 01:00:52,680
replicated way across the network the

1657
01:00:52,680 --> 01:00:55,500
nodes in the blockchain this code is

1658
01:00:55,500 --> 01:00:57,660
somewhat limited um Cycles on it are

1659
01:00:57,660 --> 01:01:00,540
somewhat expensive and so the modern

1660
01:01:00,540 --> 01:01:02,579
blockchains have actually made different

1661
01:01:02,579 --> 01:01:04,799
trade-offs and decentralization and have

1662
01:01:04,799 --> 01:01:06,839
used new technology to make This Much

1663
01:01:06,839 --> 01:01:09,119
More Much More performance so that

1664
01:01:09,119 --> 01:01:10,740
instead of just like small Snippets of

1665
01:01:10,740 --> 01:01:13,440
code and and small scripts you can

1666
01:01:13,440 --> 01:01:16,140
actually run full-blown web applications

1667
01:01:16,140 --> 01:01:18,240
on these kind of networks so these are

1668
01:01:18,240 --> 01:01:20,700
called decentralized applications or

1669
01:01:20,700 --> 01:01:23,400
dapps they find applications most famous

1670
01:01:23,400 --> 01:01:24,839
article Finance applications

1671
01:01:24,839 --> 01:01:27,180
decentralized Finance defy there's also

1672
01:01:27,180 --> 01:01:29,160
social networks social fi games online

1673
01:01:29,160 --> 01:01:31,500
games GameFly uh that are that are

1674
01:01:31,500 --> 01:01:33,540
starting to come up now

1675
01:01:33,540 --> 01:01:36,920
now when we're

1676
01:01:36,920 --> 01:01:39,359
considering to move some of our web 2

1677
01:01:39,359 --> 01:01:42,540
applications to a web 3 atmosphere where

1678
01:01:42,540 --> 01:01:44,640
things happen in decentralized way if

1679
01:01:44,640 --> 01:01:46,079
you want to believe the marketing then

1680
01:01:46,079 --> 01:01:47,819
the great Advantage is it's all secure

1681
01:01:47,819 --> 01:01:50,760
by default and in terms of Integrity

1682
01:01:50,760 --> 01:01:53,160
availability and censorship resistance

1683
01:01:53,160 --> 01:01:54,839
there is something to say for that like

1684
01:01:54,839 --> 01:01:57,540
a single node cannot screw up the code

1685
01:01:57,540 --> 01:01:59,040
that is running cannot fool you in

1686
01:01:59,040 --> 01:02:00,599
giving you a view that is that is not

1687
01:02:00,599 --> 01:02:03,960
real that is not that is faked but in

1688
01:02:03,960 --> 01:02:05,520
terms of confidentiality we're actually

1689
01:02:05,520 --> 01:02:07,920
taking a step backwards here when in web

1690
01:02:07,920 --> 01:02:10,619
2 all of your data would be resting in

1691
01:02:10,619 --> 01:02:12,420
the in the world Garden of a single

1692
01:02:12,420 --> 01:02:14,880
service provider in a web 3 scenario

1693
01:02:14,880 --> 01:02:17,099
your data is actually sitting on a whole

1694
01:02:17,099 --> 01:02:19,740
list of of service providers and may

1695
01:02:19,740 --> 01:02:21,240
even be sitting on a public blockchain

1696
01:02:21,240 --> 01:02:22,859
that's publicly verifiable but also

1697
01:02:22,859 --> 01:02:25,200
publicly inspectable

1698
01:02:25,200 --> 01:02:29,040
so how would we want to improve the

1699
01:02:29,040 --> 01:02:31,200
level of confidentiality of applications

1700
01:02:31,200 --> 01:02:34,619
running in on a web 3 Network

1701
01:02:34,619 --> 01:02:36,660
um uh and and make sure that we get a

1702
01:02:36,660 --> 01:02:38,640
better deal out of it here and common

1703
01:02:38,640 --> 01:02:40,740
approach that often gets suggested is to

1704
01:02:40,740 --> 01:02:43,200
have trusted execution platforms like

1705
01:02:43,200 --> 01:02:46,680
Intel sgx or AMD SUV we've seen in a

1706
01:02:46,680 --> 01:02:49,380
talk yesterday that security of those

1707
01:02:49,380 --> 01:02:52,740
platforms is actually not so great um

1708
01:02:52,740 --> 01:02:54,420
they have a port track record especially

1709
01:02:54,420 --> 01:02:56,160
against adversaries of physical access

1710
01:02:56,160 --> 01:02:58,920
in my personal opinion these kind of

1711
01:02:58,920 --> 01:03:01,859
platforms work well enough for working

1712
01:03:01,859 --> 01:03:04,319
against the occasional opportunistic

1713
01:03:04,319 --> 01:03:06,540
adversary but as someone dedicated

1714
01:03:06,540 --> 01:03:08,520
adversary will will probably break that

1715
01:03:08,520 --> 01:03:09,839
system so it doesn't give you a lot of

1716
01:03:09,839 --> 01:03:11,160
security

1717
01:03:11,160 --> 01:03:12,960
another way of doing it would be every

1718
01:03:12,960 --> 01:03:14,220
secret that you want to store in a

1719
01:03:14,220 --> 01:03:16,859
blockchain secret sharing it over the

1720
01:03:16,859 --> 01:03:19,319
nodes in in the blockchain but if you

1721
01:03:19,319 --> 01:03:21,180
have to do that for every single of your

1722
01:03:21,180 --> 01:03:23,099
secrets and it could be billions

1723
01:03:23,099 --> 01:03:25,619
trillions of those whenever nodes join

1724
01:03:25,619 --> 01:03:27,359
and leave the network you have to do a

1725
01:03:27,359 --> 01:03:29,099
resharing of those secrets in order to

1726
01:03:29,099 --> 01:03:31,380
keep the secret alive so that the

1727
01:03:31,380 --> 01:03:33,000
inefficiency is going to kill you for a

1728
01:03:33,000 --> 01:03:34,440
large number of secrets so that is that

1729
01:03:34,440 --> 01:03:36,119
is not a not a good option

1730
01:03:36,119 --> 01:03:38,640
you could take out the big guns

1731
01:03:38,640 --> 01:03:40,260
um bring the best zero knowledge

1732
01:03:40,260 --> 01:03:42,059
multi-party computation or fully

1733
01:03:42,059 --> 01:03:43,680
homomorphic encryption protocols that

1734
01:03:43,680 --> 01:03:44,819
that you do

1735
01:03:44,819 --> 01:03:46,680
um that works actually really well for

1736
01:03:46,680 --> 01:03:48,900
us for small functionalities that are

1737
01:03:48,900 --> 01:03:51,420
critical in security and have a limited

1738
01:03:51,420 --> 01:03:54,059
scope of what they need to protect for a

1739
01:03:54,059 --> 01:03:56,339
general computation the form performance

1740
01:03:56,339 --> 01:03:58,260
penalty for this will will actually be

1741
01:03:58,260 --> 01:03:59,640
too hard

1742
01:03:59,640 --> 01:04:01,380
now then of course there's the option

1743
01:04:01,380 --> 01:04:03,299
why don't you let users manage their own

1744
01:04:03,299 --> 01:04:05,520
encryption keys and in in a crowd that

1745
01:04:05,520 --> 01:04:07,920
that Prides itself on slogans like not

1746
01:04:07,920 --> 01:04:09,660
your key not your crypto you would think

1747
01:04:09,660 --> 01:04:11,460
that user side Key Management should be

1748
01:04:11,460 --> 01:04:13,500
a solved problem now the thing is if you

1749
01:04:13,500 --> 01:04:15,480
want to make this accessible to a wider

1750
01:04:15,480 --> 01:04:18,059
audience and like the security that you

1751
01:04:18,059 --> 01:04:21,180
want from yoloing your life savings on a

1752
01:04:21,180 --> 01:04:22,920
single cryptocurrency is probably

1753
01:04:22,920 --> 01:04:24,420
different from if you want to use the

1754
01:04:24,420 --> 01:04:26,400
social networks and chose social network

1755
01:04:26,400 --> 01:04:28,920
on a web 3 Network so the security

1756
01:04:28,920 --> 01:04:31,380
requirements are very different and um

1757
01:04:31,380 --> 01:04:33,119
the problem is that those things that

1758
01:04:33,119 --> 01:04:35,940
make life easier for authentication are

1759
01:04:35,940 --> 01:04:38,040
not available for encryption so Hardware

1760
01:04:38,040 --> 01:04:40,160
wallets and then specifically also

1761
01:04:40,160 --> 01:04:42,660
trusted Hardware in user devices like

1762
01:04:42,660 --> 01:04:45,059
phones tablets and laptops make it

1763
01:04:45,059 --> 01:04:47,040
actually much easier to do signature

1764
01:04:47,040 --> 01:04:50,579
authentication on um on web3 networks

1765
01:04:50,579 --> 01:04:52,319
for example the small screenshot on the

1766
01:04:52,319 --> 01:04:54,359
right there is the internet identity

1767
01:04:54,359 --> 01:04:55,920
system of the internet computer the

1768
01:04:55,920 --> 01:04:58,740
blockchain produced by Divinity there

1769
01:04:58,740 --> 01:04:59,880
you don't see any crypto cookies

1770
01:04:59,880 --> 01:05:01,380
everything happens in The Trusted

1771
01:05:01,380 --> 01:05:04,319
elements in your Windows laptop in your

1772
01:05:04,319 --> 01:05:07,079
Mac in your iPhone and it works with all

1773
01:05:07,079 --> 01:05:08,400
of that you can just authenticate with

1774
01:05:08,400 --> 01:05:10,319
with fingerprint or face ID and and

1775
01:05:10,319 --> 01:05:12,480
you're logged in that is great the only

1776
01:05:12,480 --> 01:05:13,680
thing is that those Technologies

1777
01:05:13,680 --> 01:05:15,599
typically do not support encryption keys

1778
01:05:15,599 --> 01:05:17,339
they only do signature keys so for

1779
01:05:17,339 --> 01:05:19,500
encryption you actually cannot use this

1780
01:05:19,500 --> 01:05:21,180
the other way to do it would be storing

1781
01:05:21,180 --> 01:05:23,520
crypto Keys encryption keys in browser

1782
01:05:23,520 --> 01:05:25,200
storage now the thing is you want these

1783
01:05:25,200 --> 01:05:26,940
of course to survive the reboot of your

1784
01:05:26,940 --> 01:05:27,960
computer so you have to go into

1785
01:05:27,960 --> 01:05:30,059
permanent storage of of your browser

1786
01:05:30,059 --> 01:05:31,559
meaning they get written to the hard

1787
01:05:31,559 --> 01:05:33,059
drive where they get more exposed to

1788
01:05:33,059 --> 01:05:34,859
malware running on your machine and if

1789
01:05:34,859 --> 01:05:36,180
you ever want to delete cookies on your

1790
01:05:36,180 --> 01:05:37,920
machine this stuff also gets deleted so

1791
01:05:37,920 --> 01:05:40,079
you lose your keys not great user

1792
01:05:40,079 --> 01:05:42,000
experience and in general also managing

1793
01:05:42,000 --> 01:05:44,040
multiple devices with with encryption

1794
01:05:44,040 --> 01:05:45,839
Keys it just doesn't get for a great

1795
01:05:45,839 --> 01:05:47,640
great user experience

1796
01:05:47,640 --> 01:05:49,500
and so that's what this talk is going to

1797
01:05:49,500 --> 01:05:51,780
be about to essentially delegating that

1798
01:05:51,780 --> 01:05:53,220
responsibility of managing your

1799
01:05:53,220 --> 01:05:55,319
encryption Keys delegate delegating it

1800
01:05:55,319 --> 01:05:57,839
to the nodes of the blockchain so what

1801
01:05:57,839 --> 01:05:59,460
we're going to use here is a single

1802
01:05:59,460 --> 01:06:01,440
master key managed by the nodes in the

1803
01:06:01,440 --> 01:06:02,940
blockchain secret shared among those

1804
01:06:02,940 --> 01:06:05,160
nodes and the dapps can

1805
01:06:05,160 --> 01:06:06,839
deterministically derive strong

1806
01:06:06,839 --> 01:06:09,480
cryptographic keys from that master key

1807
01:06:09,480 --> 01:06:12,240
held by the nodes and then users can

1808
01:06:12,240 --> 01:06:14,280
actually use that derived key for

1809
01:06:14,280 --> 01:06:15,900
symmetric encryption asymmetric

1810
01:06:15,900 --> 01:06:17,700
encryption signatures will go into

1811
01:06:17,700 --> 01:06:20,220
applications in a minute and those

1812
01:06:20,220 --> 01:06:22,140
derived keys can not only be derived by

1813
01:06:22,140 --> 01:06:24,059
the dapp so that adapt can use it but

1814
01:06:24,059 --> 01:06:26,579
can also be derived in an encrypted form

1815
01:06:26,579 --> 01:06:28,859
straight to the user so that only on the

1816
01:06:28,859 --> 01:06:30,780
user side this key is visible and that

1817
01:06:30,780 --> 01:06:32,700
none of the nodes in the network are the

1818
01:06:32,700 --> 01:06:34,740
dab that they that they get to see the

1819
01:06:34,740 --> 01:06:36,660
key

1820
01:06:36,660 --> 01:06:38,400
so given that this is a rather

1821
01:06:38,400 --> 01:06:40,260
cryptographic audience here that I'm

1822
01:06:40,260 --> 01:06:43,140
speaking for the easiest way to explain

1823
01:06:43,140 --> 01:06:44,880
how to get to this is starting from

1824
01:06:44,880 --> 01:06:46,859
Identity based encryption most of you

1825
01:06:46,859 --> 01:06:48,660
will be familiar with the concept so you

1826
01:06:48,660 --> 01:06:50,400
have a trusted Authority on the right

1827
01:06:50,400 --> 01:06:52,559
who has a master key pair Master public

1828
01:06:52,559 --> 01:06:55,140
key and a master secret key and

1829
01:06:55,140 --> 01:06:56,819
Alice when she wants to encrypt a

1830
01:06:56,819 --> 01:06:58,680
message to Bob she can do that using

1831
01:06:58,680 --> 01:07:00,119
just the master public key of the

1832
01:07:00,119 --> 01:07:02,940
authority and Bob's identity and Bob of

1833
01:07:02,940 --> 01:07:04,319
course needs to have some sort of secret

1834
01:07:04,319 --> 01:07:06,000
that allows him to decrypt this secret

1835
01:07:06,000 --> 01:07:08,039
is a decryption key for his identity Bob

1836
01:07:08,039 --> 01:07:10,799
that he can obtain from this um from

1837
01:07:10,799 --> 01:07:12,900
this trusted Authority now if you want

1838
01:07:12,900 --> 01:07:14,339
to deploy this in practice then probably

1839
01:07:14,339 --> 01:07:15,780
you're going to put some sort of

1840
01:07:15,780 --> 01:07:17,220
instance in the middle there who

1841
01:07:17,220 --> 01:07:19,920
actually verifies that Bob is the the

1842
01:07:19,920 --> 01:07:22,140
identity that you that that he claims to

1843
01:07:22,140 --> 01:07:24,119
be some sort of vetting system and what

1844
01:07:24,119 --> 01:07:26,160
you would probably do it excuse me is

1845
01:07:26,160 --> 01:07:28,200
setting something up like um the user

1846
01:07:28,200 --> 01:07:31,020
would so Bob would generate a transport

1847
01:07:31,020 --> 01:07:33,240
key pair send like a transport public

1848
01:07:33,240 --> 01:07:35,640
key to that in a vetting system and the

1849
01:07:35,640 --> 01:07:37,140
there would like check yes you are

1850
01:07:37,140 --> 01:07:39,240
indeed Bob and then that that vetting

1851
01:07:39,240 --> 01:07:41,280
Authority would forward it on to the to

1852
01:07:41,280 --> 01:07:43,619
the master Authority and say like okay

1853
01:07:43,619 --> 01:07:45,599
maybe you can deliver this decryption

1854
01:07:45,599 --> 01:07:47,099
key to Bob and encrypt it under this

1855
01:07:47,099 --> 01:07:49,619
transport publicly so that Bob can

1856
01:07:49,619 --> 01:07:51,000
recover that

1857
01:07:51,000 --> 01:07:53,400
now I'm talking here about of course

1858
01:07:53,400 --> 01:07:55,680
like Bob as an identity identity based

1859
01:07:55,680 --> 01:07:56,700
encryption is actually more flexible

1860
01:07:56,700 --> 01:07:58,559
than that it's not just an identity of

1861
01:07:58,559 --> 01:08:00,900
user it could be an attribute a role an

1862
01:08:00,900 --> 01:08:02,700
event that happens so think of it in a

1863
01:08:02,700 --> 01:08:05,460
more more broader sense

1864
01:08:05,460 --> 01:08:08,160
um now if we look at this picture here

1865
01:08:08,160 --> 01:08:09,780
and you're a bit in a decentralized

1866
01:08:09,780 --> 01:08:11,880
mindset there's a couple of things that

1867
01:08:11,880 --> 01:08:13,140
hurt your eyes here right these

1868
01:08:13,140 --> 01:08:15,059
centralized authorities so the idea is

1869
01:08:15,059 --> 01:08:17,520
of course can we replace that

1870
01:08:17,520 --> 01:08:19,319
um Central Authority that derives the

1871
01:08:19,319 --> 01:08:21,899
keys with a network of nodes that secret

1872
01:08:21,899 --> 01:08:22,979
share

1873
01:08:22,979 --> 01:08:25,380
um the the master secret key and can we

1874
01:08:25,380 --> 01:08:27,179
then also replace that vetting Authority

1875
01:08:27,179 --> 01:08:29,100
please by someone who

1876
01:08:29,100 --> 01:08:31,500
um in a more trusted way determines who

1877
01:08:31,500 --> 01:08:33,179
gets access to which key and that could

1878
01:08:33,179 --> 01:08:35,219
actually be adapt a smart contract

1879
01:08:35,219 --> 01:08:37,319
running on on a blockchain who gets to

1880
01:08:37,319 --> 01:08:40,380
decide which user at which point gets uh

1881
01:08:40,380 --> 01:08:43,380
gets access to which decryption key

1882
01:08:43,380 --> 01:08:45,779
and this is essentially the setting that

1883
01:08:45,779 --> 01:08:47,880
verifiably encrypted threshold key

1884
01:08:47,880 --> 01:08:51,299
derivation or vet KD Works in so you

1885
01:08:51,299 --> 01:08:54,179
have a decentralized set of nodes that

1886
01:08:54,179 --> 01:08:56,219
perform a dkg in a first step

1887
01:08:56,219 --> 01:08:58,198
distributed key generation to generate

1888
01:08:58,198 --> 01:08:59,698
the master key pair

1889
01:08:59,698 --> 01:09:02,460
a user who wants to derive a vet key as

1890
01:09:02,460 --> 01:09:04,679
we call it will first generate a

1891
01:09:04,679 --> 01:09:06,299
transport key pair

1892
01:09:06,299 --> 01:09:09,660
send an authenticated message a

1893
01:09:09,660 --> 01:09:11,520
transaction with a transport public key

1894
01:09:11,520 --> 01:09:15,479
to the DAP that is Distributing the keys

1895
01:09:15,479 --> 01:09:17,580
the dab will leave will evaluate which

1896
01:09:17,580 --> 01:09:20,160
key should I be deriving for this user

1897
01:09:20,160 --> 01:09:23,040
and make a query to the network of nodes

1898
01:09:23,040 --> 01:09:24,960
this could be like a system call on the

1899
01:09:24,960 --> 01:09:27,238
blockchain saying I want to derive that

1900
01:09:27,238 --> 01:09:29,580
key for this identity encrypted under

1901
01:09:29,580 --> 01:09:31,859
this transport public key the nodes

1902
01:09:31,859 --> 01:09:33,660
perform a little protocol that consists

1903
01:09:33,660 --> 01:09:36,719
of each node will first generate an

1904
01:09:36,719 --> 01:09:40,080
encrypted key share which is what it

1905
01:09:40,080 --> 01:09:42,660
says it's a share of it's a share of an

1906
01:09:42,660 --> 01:09:44,880
encrypted key these shares can be

1907
01:09:44,880 --> 01:09:46,439
verified it will be verified and sorry

1908
01:09:46,439 --> 01:09:47,939
there will be broadcast to the other

1909
01:09:47,939 --> 01:09:49,679
nodes and can be verified by the other

1910
01:09:49,679 --> 01:09:53,460
nodes once a block sorry once a node has

1911
01:09:53,460 --> 01:09:55,320
sufficiently many of these encrypted key

1912
01:09:55,320 --> 01:09:57,660
shares it can combine them into a

1913
01:09:57,660 --> 01:09:59,280
combined encryption key and that

1914
01:09:59,280 --> 01:10:01,500
encryption key can then be included in a

1915
01:10:01,500 --> 01:10:03,660
block on the blockchain as the approved

1916
01:10:03,660 --> 01:10:06,060
response to the system call from the DAP

1917
01:10:06,060 --> 01:10:08,219
the dab can then forward that encryption

1918
01:10:08,219 --> 01:10:10,860
key to the user and the user can recover

1919
01:10:10,860 --> 01:10:13,140
the decryption key that that's that he

1920
01:10:13,140 --> 01:10:15,360
was looking for so this is how you would

1921
01:10:15,360 --> 01:10:18,060
implement this sort of vet KD system in

1922
01:10:18,060 --> 01:10:20,880
in in a blockchain scenario

1923
01:10:20,880 --> 01:10:22,440
now

1924
01:10:22,440 --> 01:10:25,140
um if we're talking about vet KD for the

1925
01:10:25,140 --> 01:10:26,880
bone Franklin IB which will be the main

1926
01:10:26,880 --> 01:10:28,560
focus of the schemes that we'll be

1927
01:10:28,560 --> 01:10:31,739
looking at as you may know the key

1928
01:10:31,739 --> 01:10:33,120
structure of the Bonnie Franklin

1929
01:10:33,120 --> 01:10:35,280
identity-based encryption scheme are BLS

1930
01:10:35,280 --> 01:10:36,900
signatures so essentially what we're

1931
01:10:36,900 --> 01:10:39,480
looking at is essentially like a vet way

1932
01:10:39,480 --> 01:10:42,659
of deriving BLS signatures I have much

1933
01:10:42,659 --> 01:10:45,360
cooler co-authors than I am who can turn

1934
01:10:45,360 --> 01:10:47,820
this into memes so whenever I'm talking

1935
01:10:47,820 --> 01:10:50,640
about vet KD what is actually happening

1936
01:10:50,640 --> 01:10:54,120
underneath is is threshold BLS credit to

1937
01:10:54,120 --> 01:10:57,620
Ashling for creating that one

1938
01:10:57,659 --> 01:11:00,239
um yes so before we get into the schemes

1939
01:11:00,239 --> 01:11:01,920
let me tell you a bit about the use

1940
01:11:01,920 --> 01:11:03,300
cases that you would actually be able to

1941
01:11:03,300 --> 01:11:06,300
solve with this so a very simple example

1942
01:11:06,300 --> 01:11:08,460
would be end-to-end encrypted storage

1943
01:11:08,460 --> 01:11:11,040
hosted on a blockchain so suppose that

1944
01:11:11,040 --> 01:11:13,320
the DAP is like a storage dab and Alice

1945
01:11:13,320 --> 01:11:15,840
here wants to encrypt her files stored

1946
01:11:15,840 --> 01:11:17,640
on the blockchain what you could do is

1947
01:11:17,640 --> 01:11:19,800
send an authenticated transaction using

1948
01:11:19,800 --> 01:11:22,080
a containing a transfer public key to

1949
01:11:22,080 --> 01:11:25,620
the DAP the DAP will then derive Alice's

1950
01:11:25,620 --> 01:11:27,480
key but in an encrypted way under this

1951
01:11:27,480 --> 01:11:29,760
transport publicly so none of the nodes

1952
01:11:29,760 --> 01:11:31,620
actually sees Alice's key that comes out

1953
01:11:31,620 --> 01:11:34,260
that encrypted key will be decryptable

1954
01:11:34,260 --> 01:11:36,840
by by Alice and that gives her her own

1955
01:11:36,840 --> 01:11:39,000
key this key a in the picture here so

1956
01:11:39,000 --> 01:11:40,739
you can encrypt your file under that key

1957
01:11:40,739 --> 01:11:43,199
and dump it on the blockchain where it

1958
01:11:43,199 --> 01:11:44,820
then gets stored if she wants to later

1959
01:11:44,820 --> 01:11:48,780
recover that that same that same file

1960
01:11:48,780 --> 01:11:51,120
then she will generate a fresh transfer

1961
01:11:51,120 --> 01:11:53,280
public key again send a assigned

1962
01:11:53,280 --> 01:11:55,020
transaction to the blockchain to the dab

1963
01:11:55,020 --> 01:11:56,760
who will then say oh yeah here is your

1964
01:11:56,760 --> 01:11:58,920
do another vet key evaluation and the

1965
01:11:58,920 --> 01:12:01,679
same key will will come out again

1966
01:12:01,679 --> 01:12:03,719
in a similar way you can do end-to-end

1967
01:12:03,719 --> 01:12:05,760
encrypted messaging by the way I'm of

1968
01:12:05,760 --> 01:12:07,440
course simplifying the whole scenario of

1969
01:12:07,440 --> 01:12:09,120
end-to-end encrypted anything there's

1970
01:12:09,120 --> 01:12:10,440
more like if you want forward security

1971
01:12:10,440 --> 01:12:12,600
you'll need more details being added you

1972
01:12:12,600 --> 01:12:14,580
all know more about that and I do this

1973
01:12:14,580 --> 01:12:16,620
is just like proof of concept but so for

1974
01:12:16,620 --> 01:12:18,480
end-to-end encrypted messaging

1975
01:12:18,480 --> 01:12:19,980
um if Alice wants to send a message to

1976
01:12:19,980 --> 01:12:21,960
Bob she could send an encrypt the trend

1977
01:12:21,960 --> 01:12:24,060
sorry a signed transaction containing a

1978
01:12:24,060 --> 01:12:25,560
transfer public key and telling the dab

1979
01:12:25,560 --> 01:12:27,900
I want to talk to Bob the DAP will then

1980
01:12:27,900 --> 01:12:29,820
derive a key for the concatenation of

1981
01:12:29,820 --> 01:12:32,460
Alice and Bob's identities and let Alice

1982
01:12:32,460 --> 01:12:34,620
derive a key that is related to that

1983
01:12:34,620 --> 01:12:37,800
that concatenated identity

1984
01:12:37,800 --> 01:12:40,620
um Bob will then be able to get an

1985
01:12:40,620 --> 01:12:42,900
encrypted message under that derived key

1986
01:12:42,900 --> 01:12:44,940
from the DAP that is the encrypted

1987
01:12:44,940 --> 01:12:46,679
message derived the same Key by doing

1988
01:12:46,679 --> 01:12:49,020
another call to the to the DAP the dab

1989
01:12:49,020 --> 01:12:50,760
does a system call to derive a vet key

1990
01:12:50,760 --> 01:12:53,280
and um and that way Bob can decrypt the

1991
01:12:53,280 --> 01:12:54,780
message

1992
01:12:54,780 --> 01:12:56,820
I'm thinking that you're starting to get

1993
01:12:56,820 --> 01:12:58,620
a principle in a similar way you can

1994
01:12:58,620 --> 01:13:00,000
actually extend this to do a whole

1995
01:13:00,000 --> 01:13:01,980
decentralized end-to-end encrypted

1996
01:13:01,980 --> 01:13:04,800
social network so where every post is

1997
01:13:04,800 --> 01:13:07,560
actually encrypted under an identity ibe

1998
01:13:07,560 --> 01:13:10,380
encrypted on or an identity that um that

1999
01:13:10,380 --> 01:13:12,360
is like a unique identifier of that post

2000
01:13:12,360 --> 01:13:16,040
and The Social Network dap can then

2001
01:13:16,040 --> 01:13:19,500
simply perform like evaluate the access

2002
01:13:19,500 --> 01:13:21,780
policy associated with that post to

2003
01:13:21,780 --> 01:13:23,760
determine which user is allowed to

2004
01:13:23,760 --> 01:13:25,679
derive that key for this post and

2005
01:13:25,679 --> 01:13:27,900
therefore get visibility into this post

2006
01:13:27,900 --> 01:13:30,360
so if if you can actually tell that the

2007
01:13:30,360 --> 01:13:32,940
DAP is now becoming kind of like an

2008
01:13:32,940 --> 01:13:35,580
executor of the access policy and just a

2009
01:13:35,580 --> 01:13:37,440
router of ciphertext and never gets to

2010
01:13:37,440 --> 01:13:39,540
see any plain text that can enforce any

2011
01:13:39,540 --> 01:13:42,480
policy that the the user has set for um

2012
01:13:42,480 --> 01:13:45,140
for his data

2013
01:13:45,140 --> 01:13:47,940
another interesting application is a

2014
01:13:47,940 --> 01:13:50,520
Deadman switch this is something that

2015
01:13:50,520 --> 01:13:52,020
could be useful for journalists

2016
01:13:52,020 --> 01:13:55,080
dissidents whistleblowers so when you

2017
01:13:55,080 --> 01:13:56,719
have a precious piece of information

2018
01:13:56,719 --> 01:13:58,800
that actually could get you into trouble

2019
01:13:58,800 --> 01:14:00,300
and you're even fearing for your life

2020
01:14:00,300 --> 01:14:02,460
because of it you can actually dump it

2021
01:14:02,460 --> 01:14:04,620
onto a Dap that takes this kind of

2022
01:14:04,620 --> 01:14:07,920
information and tell the depth so if I

2023
01:14:07,920 --> 01:14:10,320
don't ping you within this amount of

2024
01:14:10,320 --> 01:14:13,140
time then please reveal this information

2025
01:14:13,140 --> 01:14:15,840
either to the world or to this trusted

2026
01:14:15,840 --> 01:14:18,840
other accomplice of mine and you can do

2027
01:14:18,840 --> 01:14:20,760
this with a vet Key by encrypting the

2028
01:14:20,760 --> 01:14:22,560
data under a vet key for example again

2029
01:14:22,560 --> 01:14:26,219
for the identity Alice and adding a

2030
01:14:26,219 --> 01:14:28,380
policy and a timer to it and so Alice

2031
01:14:28,380 --> 01:14:30,300
will regularly send an authenticated

2032
01:14:30,300 --> 01:14:32,159
ping saying like I'm still alive I'm

2033
01:14:32,159 --> 01:14:34,199
still alive which resets the timer but

2034
01:14:34,199 --> 01:14:36,480
as soon as that those pings are not

2035
01:14:36,480 --> 01:14:38,400
coming anymore at some point adapt will

2036
01:14:38,400 --> 01:14:40,560
then automatically reveal the data

2037
01:14:40,560 --> 01:14:43,260
either to the world or to whoever Alice

2038
01:14:43,260 --> 01:14:45,600
appointed as a people who should be

2039
01:14:45,600 --> 01:14:47,159
receiving this data

2040
01:14:47,159 --> 01:14:49,020
a slight Twist on this idea is actually

2041
01:14:49,020 --> 01:14:50,580
a pretty cool one as well there's a

2042
01:14:50,580 --> 01:14:52,440
project called icycrypt that's actually

2043
01:14:52,440 --> 01:14:53,820
building this or planning to build this

2044
01:14:53,820 --> 01:14:55,679
on the internet computer for digital

2045
01:14:55,679 --> 01:14:57,480
inheritance if you want your social

2046
01:14:57,480 --> 01:14:59,340
network passwords or whatever digital

2047
01:14:59,340 --> 01:15:01,440
information especially cryptocurrency

2048
01:15:01,440 --> 01:15:04,620
keys to be passed on to um to your loved

2049
01:15:04,620 --> 01:15:07,020
ones once once your time has come you

2050
01:15:07,020 --> 01:15:08,400
can actually use this as a sort of

2051
01:15:08,400 --> 01:15:10,920
digital will that secrets are threshold

2052
01:15:10,920 --> 01:15:12,780
kept by the network and will only be

2053
01:15:12,780 --> 01:15:14,699
revealed to the to the users of your

2054
01:15:14,699 --> 01:15:18,980
choice after those pings stop coming in

2055
01:15:19,140 --> 01:15:21,300
um another cool application I'm not sure

2056
01:15:21,300 --> 01:15:22,860
whether you have heard of minor

2057
01:15:22,860 --> 01:15:25,620
extracted value Mev this is a problem on

2058
01:15:25,620 --> 01:15:27,900
on ethereum and other networks where

2059
01:15:27,900 --> 01:15:30,659
essentially the nodes are doing front

2060
01:15:30,659 --> 01:15:32,880
running on any transactions big

2061
01:15:32,880 --> 01:15:34,920
transactions being made and especially

2062
01:15:34,920 --> 01:15:36,780
D5 spaces

2063
01:15:36,780 --> 01:15:38,699
um taking uh taking advantage of the

2064
01:15:38,699 --> 01:15:40,620
price fluctuations from a big

2065
01:15:40,620 --> 01:15:42,300
transaction that they see coming in now

2066
01:15:42,300 --> 01:15:44,520
this actually a reasonably sized problem

2067
01:15:44,520 --> 01:15:46,380
because of around 600 million dollars

2068
01:15:46,380 --> 01:15:49,260
have already been lost since 2020 to

2069
01:15:49,260 --> 01:15:51,060
these kind of attacks the problem is

2070
01:15:51,060 --> 01:15:53,100
that these transactions are visible

2071
01:15:53,100 --> 01:15:55,739
before they get executed with these vet

2072
01:15:55,739 --> 01:15:57,360
Keys you could actually have users

2073
01:15:57,360 --> 01:15:59,699
submit the their transactions in

2074
01:15:59,699 --> 01:16:02,280
encrypted form for example encrypted

2075
01:16:02,280 --> 01:16:04,080
under the identity that is a time slot

2076
01:16:04,080 --> 01:16:06,719
identity of the time slot where they are

2077
01:16:06,719 --> 01:16:09,719
aiming for to get included all users

2078
01:16:09,719 --> 01:16:11,880
submit their encrypted transactions the

2079
01:16:11,880 --> 01:16:13,560
transactions get in encrypted form

2080
01:16:13,560 --> 01:16:15,719
sequence the order gets committed to and

2081
01:16:15,719 --> 01:16:17,820
only then when the time slot happens the

2082
01:16:17,820 --> 01:16:20,460
DAP will actually proceed to Crypt to

2083
01:16:20,460 --> 01:16:22,380
derive the vet key for uh for that time

2084
01:16:22,380 --> 01:16:24,300
slot and decrypt all of the transactions

2085
01:16:24,300 --> 01:16:26,159
and execute them in the order that was

2086
01:16:26,159 --> 01:16:28,080
committed to an encrypted form

2087
01:16:28,080 --> 01:16:29,640
similar way you can do Secret bid

2088
01:16:29,640 --> 01:16:31,980
auctions um so that would be a similar

2089
01:16:31,980 --> 01:16:32,820
approach

2090
01:16:32,820 --> 01:16:34,620
there's more there's time lock

2091
01:16:34,620 --> 01:16:36,000
encryption that you can do I'm not going

2092
01:16:36,000 --> 01:16:37,199
to go much into that the next stock

2093
01:16:37,199 --> 01:16:38,940
after the break will actually go more

2094
01:16:38,940 --> 01:16:40,739
into detail about that witness

2095
01:16:40,739 --> 01:16:42,900
encryption a sort of cryptographic tool

2096
01:16:42,900 --> 01:16:44,219
where you can encrypt to a language

2097
01:16:44,219 --> 01:16:46,440
member and you can only decrypt if you

2098
01:16:46,440 --> 01:16:48,300
have a witness to that if you have adapt

2099
01:16:48,300 --> 01:16:49,860
that actually checks Witnesses you can

2100
01:16:49,860 --> 01:16:51,960
easily Implement that with vet Keys it's

2101
01:16:51,960 --> 01:16:53,460
a bit theoretic but if you think of it

2102
01:16:53,460 --> 01:16:54,719
essentially what it allows you to use

2103
01:16:54,719 --> 01:16:57,600
you can encrypt to any event that can be

2104
01:16:57,600 --> 01:16:59,880
observed by the DAP and let the DAP take

2105
01:16:59,880 --> 01:17:01,980
care of observing the event and allowing

2106
01:17:01,980 --> 01:17:04,380
access to decryption to those selected

2107
01:17:04,380 --> 01:17:06,480
users whenever it happens one-time

2108
01:17:06,480 --> 01:17:08,280
programs another cryptographic Gadget

2109
01:17:08,280 --> 01:17:10,560
that can be only evaluated once on on

2110
01:17:10,560 --> 01:17:13,140
one single input you can dump a garbled

2111
01:17:13,140 --> 01:17:15,060
circuit with wire keys that are actually

2112
01:17:15,060 --> 01:17:18,120
vat keys and let the DAP only evaluate a

2113
01:17:18,120 --> 01:17:20,880
single bit for um for every wire so that

2114
01:17:20,880 --> 01:17:22,560
it can only be evaluated on a single

2115
01:17:22,560 --> 01:17:24,600
input you would almost forget with all

2116
01:17:24,600 --> 01:17:25,860
of that that those wet keys are actually

2117
01:17:25,860 --> 01:17:27,480
BLS signatures so actually can also be

2118
01:17:27,480 --> 01:17:29,760
used as signatures signatures in name of

2119
01:17:29,760 --> 01:17:31,800
the blockchain which can then be used to

2120
01:17:31,800 --> 01:17:33,239
verify information stored on a

2121
01:17:33,239 --> 01:17:34,440
blockchain in a more efficient form on

2122
01:17:34,440 --> 01:17:35,640
other blockchains which gives you

2123
01:17:35,640 --> 01:17:37,860
efficient cross-chain bridging so with

2124
01:17:37,860 --> 01:17:39,540
this fairly simple interface you're

2125
01:17:39,540 --> 01:17:41,940
actually enabling a whole realm of of

2126
01:17:41,940 --> 01:17:44,820
other applications and all of that by

2127
01:17:44,820 --> 01:17:46,860
sharing just a single secret shared key

2128
01:17:46,860 --> 01:17:49,560
on on that network network of the of

2129
01:17:49,560 --> 01:17:51,800
nodes

2130
01:17:53,100 --> 01:17:53,699
um

2131
01:17:53,699 --> 01:17:56,040
let me say a bit about the schemes that

2132
01:17:56,040 --> 01:17:57,900
um that we're looking at we we actually

2133
01:17:57,900 --> 01:17:59,760
we have an upcoming paper that will be

2134
01:17:59,760 --> 01:18:02,820
available on ePrint soon that um there's

2135
01:18:02,820 --> 01:18:04,739
four schemes there's a simple scheme

2136
01:18:04,739 --> 01:18:07,940
where um every node is simply

2137
01:18:07,940 --> 01:18:11,640
encrypts a BLS signature share to the

2138
01:18:11,640 --> 01:18:14,460
transport public key of the user and the

2139
01:18:14,460 --> 01:18:16,380
encrypted key is just a concatenation of

2140
01:18:16,380 --> 01:18:18,480
sufficiently many which is 2T minus 1

2141
01:18:18,480 --> 01:18:20,239
because T minus one of them could be bad

2142
01:18:20,239 --> 01:18:22,500
that is a simple scheme but you can only

2143
01:18:22,500 --> 01:18:24,980
use it if T is smaller than n and half

2144
01:18:24,980 --> 01:18:27,600
because you need to cover for the the

2145
01:18:27,600 --> 01:18:28,800
bad guys

2146
01:18:28,800 --> 01:18:31,320
there's a slightly better scheme where

2147
01:18:31,320 --> 01:18:34,260
the uh every node has to proven zero

2148
01:18:34,260 --> 01:18:36,179
knowledge that the encrypted share is

2149
01:18:36,179 --> 01:18:37,980
correctly encrypted to do that you do

2150
01:18:37,980 --> 01:18:40,739
elgamal encryption of the share in G1

2151
01:18:40,739 --> 01:18:42,360
which works because

2152
01:18:42,360 --> 01:18:43,380
um there you have by the external

2153
01:18:43,380 --> 01:18:45,480
different element security but then

2154
01:18:45,480 --> 01:18:46,920
still your encrypted key will be a

2155
01:18:46,920 --> 01:18:48,540
concatenation of those zero knowledge

2156
01:18:48,540 --> 01:18:50,100
proofs to keep it verifiable because

2157
01:18:50,100 --> 01:18:52,080
those cannot be aggregated you would

2158
01:18:52,080 --> 01:18:54,060
expect better from BLS style signatures

2159
01:18:54,060 --> 01:18:56,219
and of course you can we have two

2160
01:18:56,219 --> 01:18:58,739
versions of aggregatable schemes and

2161
01:18:58,739 --> 01:19:01,080
this is already a second one this is

2162
01:19:01,080 --> 01:19:03,900
essentially the threshold version of the

2163
01:19:03,900 --> 01:19:05,699
verifiably encrypted signature scheme

2164
01:19:05,699 --> 01:19:08,520
that was already in the bgls 2004 paper

2165
01:19:08,520 --> 01:19:10,560
on aggregated signatures

2166
01:19:10,560 --> 01:19:13,199
um just taking to an asymmetric pairing

2167
01:19:13,199 --> 01:19:14,580
setting instead of symmetric and there's

2168
01:19:14,580 --> 01:19:16,260
two different ways of doing that that's

2169
01:19:16,260 --> 01:19:18,600
why there's two variants of the scheme

2170
01:19:18,600 --> 01:19:21,780
here without going into the details

2171
01:19:21,780 --> 01:19:23,760
um so to integrate this onto the

2172
01:19:23,760 --> 01:19:25,560
internet computer I would have wished

2173
01:19:25,560 --> 01:19:26,880
that this talk would have been more real

2174
01:19:26,880 --> 01:19:29,219
world than it is right now and just um

2175
01:19:29,219 --> 01:19:31,199
because I was hoping that we would have

2176
01:19:31,199 --> 01:19:33,480
an implementation ready it is not that

2177
01:19:33,480 --> 01:19:35,219
is how software engineer Works priority

2178
01:19:35,219 --> 01:19:37,380
chain priorities change and uh

2179
01:19:37,380 --> 01:19:40,739
developing software takes time so just

2180
01:19:40,739 --> 01:19:43,560
something that I want to give on to pass

2181
01:19:43,560 --> 01:19:44,820
on to you so the internet computer

2182
01:19:44,820 --> 01:19:46,860
developed by dfinity has different

2183
01:19:46,860 --> 01:19:49,440
subnets the plan is to integrate at

2184
01:19:49,440 --> 01:19:51,239
least one of those subnets with a key

2185
01:19:51,239 --> 01:19:53,040
that is secret shared on it because a

2186
01:19:53,040 --> 01:19:54,360
subnets can talk to each other that

2187
01:19:54,360 --> 01:19:56,100
would be enough to enable all the apps

2188
01:19:56,100 --> 01:19:58,260
to have that key access one interesting

2189
01:19:58,260 --> 01:20:00,540
thing is also that the internet computer

2190
01:20:00,540 --> 01:20:03,060
is efficient enough to certify all of

2191
01:20:03,060 --> 01:20:05,219
the assets stored on it so also the

2192
01:20:05,219 --> 01:20:07,020
JavaScript and wasn't script that is

2193
01:20:07,020 --> 01:20:09,300
downloaded into the user's browser so it

2194
01:20:09,300 --> 01:20:11,880
actually makes sense to to execute the

2195
01:20:11,880 --> 01:20:14,040
client part of this in the browser

2196
01:20:14,040 --> 01:20:15,780
because this part of the code is

2197
01:20:15,780 --> 01:20:17,699
actually threshold certified by a

2198
01:20:17,699 --> 01:20:19,140
network of nodes rather than the

2199
01:20:19,140 --> 01:20:20,940
depending on just the OneNote that you

2200
01:20:20,940 --> 01:20:22,620
connect to

2201
01:20:22,620 --> 01:20:24,900
in the interest of time I'm not going to

2202
01:20:24,900 --> 01:20:26,280
go through these cool graphs that

2203
01:20:26,280 --> 01:20:28,500
describe the performance of it and go

2204
01:20:28,500 --> 01:20:30,420
straight to the conclusion of it so keep

2205
01:20:30,420 --> 01:20:31,980
your eyes open for the research paper

2206
01:20:31,980 --> 01:20:33,840
that we'll be landing on ePrint soon it

2207
01:20:33,840 --> 01:20:37,080
has the detailed evaluation of of the

2208
01:20:37,080 --> 01:20:38,460
efficiency of it

2209
01:20:38,460 --> 01:20:41,280
just roughly um this is a fairly simple

2210
01:20:41,280 --> 01:20:43,380
interface that is efficient uh can be

2211
01:20:43,380 --> 01:20:45,120
efficiently run we're estimating that we

2212
01:20:45,120 --> 01:20:46,739
should be able to do a hundred or a

2213
01:20:46,739 --> 01:20:48,659
couple of hundred vet Keys per second on

2214
01:20:48,659 --> 01:20:50,520
on a single Network

2215
01:20:50,520 --> 01:20:53,460
um and uh it opens up a whole spectrum

2216
01:20:53,460 --> 01:20:57,540
of applications that were previously not

2217
01:20:57,540 --> 01:20:59,760
usefully to be run on on a web 3

2218
01:20:59,760 --> 01:21:01,260
scenario just because of the privacy

2219
01:21:01,260 --> 01:21:03,480
issues with it there's also some

2220
01:21:03,480 --> 01:21:05,820
upcoming work that I'm working on with

2221
01:21:05,820 --> 01:21:07,800
Michelle Abdullah from dfinity that

2222
01:21:07,800 --> 01:21:09,300
actually takes a second version of the

2223
01:21:09,300 --> 01:21:11,340
aggregated scheme and turns it into a

2224
01:21:11,340 --> 01:21:13,080
partially blind signature that gives

2225
01:21:13,080 --> 01:21:15,659
that gives access to yet another list of

2226
01:21:15,659 --> 01:21:18,120
applications on track untraceable token

2227
01:21:18,120 --> 01:21:19,980
transfers please use that one

2228
01:21:19,980 --> 01:21:21,960
responsibly Anonymous credentials

2229
01:21:21,960 --> 01:21:24,420
oblivious transfer oprf like password

2230
01:21:24,420 --> 01:21:26,100
strengthening a whole list of other

2231
01:21:26,100 --> 01:21:27,719
things but I'm afraid I will have to

2232
01:21:27,719 --> 01:21:29,820
keep those for another talk

2233
01:21:29,820 --> 01:21:32,540
thank you

2234
01:21:38,280 --> 01:21:41,280
if you have a short question you can do

2235
01:21:41,280 --> 01:21:42,480
it

2236
01:21:42,480 --> 01:21:44,460
so when the validators of the subnet

2237
01:21:44,460 --> 01:21:46,860
change how does the you just do a key

2238
01:21:46,860 --> 01:21:49,920
refresh yes so um in the internet

2239
01:21:49,920 --> 01:21:51,239
computer that is already going on

2240
01:21:51,239 --> 01:21:52,860
because it already uses threshold BLS

2241
01:21:52,860 --> 01:21:55,140
but indeed when the when the notes um

2242
01:21:55,140 --> 01:21:56,880
when the network topology changes you

2243
01:21:56,880 --> 01:21:58,679
have to do a reshare of that secret key

2244
01:21:58,679 --> 01:22:00,900
but now don't you have this problem

2245
01:22:00,900 --> 01:22:02,640
where like after a bunch of validators

2246
01:22:02,640 --> 01:22:05,760
leave from validation but they you know

2247
01:22:05,760 --> 01:22:07,260
basically have a party and then

2248
01:22:07,260 --> 01:22:09,620
reconstruct their 2018

2249
01:22:09,620 --> 01:22:11,820
once they get corrupted after they leave

2250
01:22:11,820 --> 01:22:13,620
the network then they can you need some

2251
01:22:13,620 --> 01:22:15,420
forward Security in that in order to um

2252
01:22:15,420 --> 01:22:18,960
to to cover for that but yes no

2253
01:22:18,960 --> 01:22:22,140
okay uh I'm sorry but uh other questions

2254
01:22:22,140 --> 01:22:25,320
would be made offline so thanks uh

2255
01:22:25,320 --> 01:22:29,599
Gregory again thank you very much

2256
01:22:30,600 --> 01:22:32,460
Okay cookie break

2257
01:22:32,460 --> 01:22:35,060
and we will gather at uh

2258
01:22:35,060 --> 01:22:37,020
1510.

2259
01:22:37,020 --> 01:22:40,020
foreign

