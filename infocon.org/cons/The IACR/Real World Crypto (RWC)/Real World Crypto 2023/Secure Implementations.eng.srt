1
00:00:00,000 --> 00:00:02,879
day of real world crypto 2023

2
00:00:02,879 --> 00:00:05,279
it's good to see that even in the early

3
00:00:05,279 --> 00:00:07,140
morning hours so many of you made it and

4
00:00:07,140 --> 00:00:09,960
it's my pleasure to announce the first

5
00:00:09,960 --> 00:00:11,580
speakers of the session which is going

6
00:00:11,580 --> 00:00:14,519
to be Francisco schiefer and katake and

7
00:00:14,519 --> 00:00:16,680
bhagavan and they will be speaking about

8
00:00:16,680 --> 00:00:20,340
hexback please the stage is yours

9
00:00:20,340 --> 00:00:22,080
so hi guys I'm Karthik and I and

10
00:00:22,080 --> 00:00:23,580
Franciscus are going to be talking about

11
00:00:23,580 --> 00:00:26,039
this collaborative project between us

12
00:00:26,039 --> 00:00:27,539
and several research groups so we are

13
00:00:27,539 --> 00:00:28,800
trying to bring together a quote from

14
00:00:28,800 --> 00:00:30,779
different verified crypto libraries and

15
00:00:30,779 --> 00:00:33,300
make it more accessible

16
00:00:33,300 --> 00:00:34,559
so if you're in this room you're

17
00:00:34,559 --> 00:00:36,300
probably using and probably even writing

18
00:00:36,300 --> 00:00:38,160
one or more crypto libraries whether

19
00:00:38,160 --> 00:00:40,500
it's on the OS level or for the web

20
00:00:40,500 --> 00:00:44,040
within your favorite language or for iot

21
00:00:44,040 --> 00:00:45,660
so this these crypto libraries are

22
00:00:45,660 --> 00:00:46,920
really part of the trusted Computing

23
00:00:46,920 --> 00:00:48,840
base of the internet but how much trust

24
00:00:48,840 --> 00:00:51,600
should we actually put in them so each

25
00:00:51,600 --> 00:00:53,340
library has good years and bad years but

26
00:00:53,340 --> 00:00:54,600
if I tell you that one of the libraries

27
00:00:54,600 --> 00:00:56,879
you've been using had five bugs in the

28
00:00:56,879 --> 00:00:58,140
last year you shouldn't be particularly

29
00:00:58,140 --> 00:00:59,460
surprised

30
00:00:59,460 --> 00:01:01,500
so how do we reduce or even eliminate

31
00:01:01,500 --> 00:01:03,359
the trust in these libraries

32
00:01:03,359 --> 00:01:05,159
over the last few years there have been

33
00:01:05,159 --> 00:01:06,420
many research groups who have been

34
00:01:06,420 --> 00:01:07,740
really tackling this problem by

35
00:01:07,740 --> 00:01:09,659
developing formally verified crypto

36
00:01:09,659 --> 00:01:12,299
libraries on the one hand you have uh

37
00:01:12,299 --> 00:01:13,920
libraries like Hackle star which are

38
00:01:13,920 --> 00:01:15,540
verified using the f-star verification

39
00:01:15,540 --> 00:01:17,400
framework which try to give a broad

40
00:01:17,400 --> 00:01:19,619
coverage of various algorithms and then

41
00:01:19,619 --> 00:01:21,600
you have tools like Fiat crypto which

42
00:01:21,600 --> 00:01:23,100
you'll be hearing more about later in

43
00:01:23,100 --> 00:01:24,900
the session which is really focused on

44
00:01:24,900 --> 00:01:27,060
trying to make super fast field

45
00:01:27,060 --> 00:01:28,799
arithmetic for elliptic curves and now

46
00:01:28,799 --> 00:01:30,780
some other things as well

47
00:01:30,780 --> 00:01:32,460
but

48
00:01:32,460 --> 00:01:34,080
applications these libraries are really

49
00:01:34,080 --> 00:01:36,000
in high level languages like C if you

50
00:01:36,000 --> 00:01:37,560
want to remove the dependence on the C

51
00:01:37,560 --> 00:01:39,000
compiler completely and write even

52
00:01:39,000 --> 00:01:40,979
faster code you can write code in

53
00:01:40,979 --> 00:01:43,680
assembly in Veil or in Jasmine and then

54
00:01:43,680 --> 00:01:45,420
directly have proofs at the level of

55
00:01:45,420 --> 00:01:46,500
assembly code

56
00:01:46,500 --> 00:01:48,840
so with this plethora of crypto

57
00:01:48,840 --> 00:01:50,880
libraries that are available today the

58
00:01:50,880 --> 00:01:52,920
good news is that if you're actually a

59
00:01:52,920 --> 00:01:54,899
developer and you're relying on some

60
00:01:54,899 --> 00:01:56,880
Modern crypto algorithm there is

61
00:01:56,880 --> 00:01:58,799
probably a verified implementation out

62
00:01:58,799 --> 00:02:00,180
there in one of these libraries for the

63
00:02:00,180 --> 00:02:01,920
algorithm you're using

64
00:02:01,920 --> 00:02:03,840
but there's a caveat this is research

65
00:02:03,840 --> 00:02:06,840
code typically with low level apis and

66
00:02:06,840 --> 00:02:08,459
the specs that describe what this code

67
00:02:08,459 --> 00:02:09,899
actually does and what has actually been

68
00:02:09,899 --> 00:02:12,060
verified is written in formal languages

69
00:02:12,060 --> 00:02:13,739
that may be unfamiliar to you as a

70
00:02:13,739 --> 00:02:15,060
developer

71
00:02:15,060 --> 00:02:16,920
so to give you an idea of why that might

72
00:02:16,920 --> 00:02:18,720
be let's just walk through the workflow

73
00:02:18,720 --> 00:02:21,420
of how crypto was verified in very

74
00:02:21,420 --> 00:02:23,819
various libraries today

75
00:02:23,819 --> 00:02:25,500
to begin with you always start with a

76
00:02:25,500 --> 00:02:27,599
standard like IIT F RFC or in this

77
00:02:27,599 --> 00:02:30,300
standard which describes the the crypto

78
00:02:30,300 --> 00:02:31,800
algorithm in a mixture of English and

79
00:02:31,800 --> 00:02:33,300
pseudo code maybe it has some test

80
00:02:33,300 --> 00:02:34,680
vectors to tell you what the i o

81
00:02:34,680 --> 00:02:36,120
Behavior should be

82
00:02:36,120 --> 00:02:37,800
but the first step before you can do

83
00:02:37,800 --> 00:02:39,599
verification is that you always have to

84
00:02:39,599 --> 00:02:41,819
write a formal spec and the formal spec

85
00:02:41,819 --> 00:02:43,739
language that you choose depends on the

86
00:02:43,739 --> 00:02:44,879
tool you're going to use for the

87
00:02:44,879 --> 00:02:46,379
verification so if you're going to use

88
00:02:46,379 --> 00:02:48,300
 or f-star you write your specs in

89
00:02:48,300 --> 00:02:49,560
Concord F star which would look

90
00:02:49,560 --> 00:02:51,959
something like o camel or Haskell if

91
00:02:51,959 --> 00:02:53,580
you're familiar with those languages

92
00:02:53,580 --> 00:02:55,260
or if you're going to use easycrypt then

93
00:02:55,260 --> 00:02:57,120
you're going to use Easy Crypt spec

94
00:02:57,120 --> 00:02:58,920
language which is a bit more imperative

95
00:02:58,920 --> 00:03:01,080
it's like a wild language but once

96
00:03:01,080 --> 00:03:02,700
you've written this formal spec the next

97
00:03:02,700 --> 00:03:04,500
step is to write the implementation so

98
00:03:04,500 --> 00:03:06,120
you could write the implementation in

99
00:03:06,120 --> 00:03:08,099
for example F star and then compile it

100
00:03:08,099 --> 00:03:10,560
to a portable C code

101
00:03:10,560 --> 00:03:12,360
or if you want to eliminate the

102
00:03:12,360 --> 00:03:13,980
dependence on the C compiler for example

103
00:03:13,980 --> 00:03:17,760
you could write the code in Jasmine and

104
00:03:17,760 --> 00:03:19,860
then compile it down to directly to

105
00:03:19,860 --> 00:03:21,840
Intel assembly

106
00:03:21,840 --> 00:03:23,819
in both cases you end up with a formal

107
00:03:23,819 --> 00:03:25,019
spec which is a nice high level

108
00:03:25,019 --> 00:03:27,300
mathematical spec and an implementation

109
00:03:27,300 --> 00:03:29,400
which is highly optimized which is then

110
00:03:29,400 --> 00:03:30,780
they look quite different so you want to

111
00:03:30,780 --> 00:03:32,400
do a formal verification to prove that

112
00:03:32,400 --> 00:03:33,900
this implementation actually meets the

113
00:03:33,900 --> 00:03:34,739
spec

114
00:03:34,739 --> 00:03:36,780
now each of these proof environments has

115
00:03:36,780 --> 00:03:38,580
different sets of assumptions does it

116
00:03:38,580 --> 00:03:40,200
prove slightly differently the

117
00:03:40,200 --> 00:03:41,879
guarantees it provide they provide a

118
00:03:41,879 --> 00:03:43,379
slightly different but if you want to

119
00:03:43,379 --> 00:03:44,940
abstract away from them and look at it

120
00:03:44,940 --> 00:03:46,379
from a very high level

121
00:03:46,379 --> 00:03:48,120
more or less all of them are proving

122
00:03:48,120 --> 00:03:49,379
similar kinds of things you want to

123
00:03:49,379 --> 00:03:51,480
prove that your implementation is memory

124
00:03:51,480 --> 00:03:53,580
safe that is functionally correct which

125
00:03:53,580 --> 00:03:55,260
means it matches the i o behavior of the

126
00:03:55,260 --> 00:03:57,480
formal spec that you wrote and then it

127
00:03:57,480 --> 00:03:58,799
and that it protects against certain

128
00:03:58,799 --> 00:04:01,200
classes of session vulnerabilities and

129
00:04:01,200 --> 00:04:02,760
that again can differ a lot for example

130
00:04:02,760 --> 00:04:04,799
in Hackle star you would prove that the

131
00:04:04,799 --> 00:04:06,480
code is secret independent at the level

132
00:04:06,480 --> 00:04:08,879
of the C semantics whereas in lib Jade

133
00:04:08,879 --> 00:04:10,620
using Jasmine you would prove you can

134
00:04:10,620 --> 00:04:12,360
even try to prove things that a certain

135
00:04:12,360 --> 00:04:14,099
category of Specter attacks doesn't

136
00:04:14,099 --> 00:04:17,160
doesn't occur

137
00:04:17,160 --> 00:04:19,560
so once the once all of this process is

138
00:04:19,560 --> 00:04:20,459
done you're left with these two

139
00:04:20,459 --> 00:04:22,500
artifacts the formal spec and the

140
00:04:22,500 --> 00:04:24,180
implementation in C or assembly that's

141
00:04:24,180 --> 00:04:25,740
ready to ready to be used in your

142
00:04:25,740 --> 00:04:27,060
project

143
00:04:27,060 --> 00:04:29,400
so using this methodology various

144
00:04:29,400 --> 00:04:31,259
projects have implemented various and

145
00:04:31,259 --> 00:04:33,780
verified various algorithms out there

146
00:04:33,780 --> 00:04:35,340
and these are really ready to use today

147
00:04:35,340 --> 00:04:37,500
they are high performance you don't have

148
00:04:37,500 --> 00:04:39,180
the sacrifice performance at all in fact

149
00:04:39,180 --> 00:04:40,380
sometimes they're even faster than

150
00:04:40,380 --> 00:04:42,479
unverified code you have a mechanized

151
00:04:42,479 --> 00:04:44,520
proof that you can run yourself and if

152
00:04:44,520 --> 00:04:46,020
you kind of make some cosmetic changes

153
00:04:46,020 --> 00:04:47,220
to the code you can rerun the

154
00:04:47,220 --> 00:04:48,479
verification to see if you broke

155
00:04:48,479 --> 00:04:50,639
anything and for the most part you don't

156
00:04:50,639 --> 00:04:52,800
yourself have to go in and look at the

157
00:04:52,800 --> 00:04:54,540
proofs or inspect them because once

158
00:04:54,540 --> 00:04:56,460
they're done they can be checked by the

159
00:04:56,460 --> 00:04:58,220
machine

160
00:04:58,220 --> 00:05:01,139
but you do have to go and carefully

161
00:05:01,139 --> 00:05:03,000
inspect and audit the formal specs

162
00:05:03,000 --> 00:05:04,560
because the formal specs that you wrote

163
00:05:04,560 --> 00:05:06,540
they are the ground truth all the

164
00:05:06,540 --> 00:05:08,340
verification is depending on them if

165
00:05:08,340 --> 00:05:09,660
they are wrong or they don't capture

166
00:05:09,660 --> 00:05:11,220
some feature that you wanted to capture

167
00:05:11,220 --> 00:05:13,080
then your proof is not doing what you

168
00:05:13,080 --> 00:05:15,060
think it's doing and these formal specs

169
00:05:15,060 --> 00:05:16,380
like we discussed before are written in

170
00:05:16,380 --> 00:05:19,320
tool oriented languages which may or may

171
00:05:19,320 --> 00:05:21,540
not be familiar to you

172
00:05:21,540 --> 00:05:23,580
and you need to safely use the low level

173
00:05:23,580 --> 00:05:26,100
apis exposed by the implementation which

174
00:05:26,100 --> 00:05:27,960
often have subtle preconditions and

175
00:05:27,960 --> 00:05:29,280
these preconditions are part of the

176
00:05:29,280 --> 00:05:30,840
correctness proof but you have to go and

177
00:05:30,840 --> 00:05:32,580
look at the main theorem statement and

178
00:05:32,580 --> 00:05:33,960
figure out what these preconditions are

179
00:05:33,960 --> 00:05:35,820
so that your application can satisfy

180
00:05:35,820 --> 00:05:37,560
them before calling this verified code

181
00:05:37,560 --> 00:05:39,900
so even though this code exists actually

182
00:05:39,900 --> 00:05:41,300
using it

183
00:05:41,300 --> 00:05:45,720
safely is not that trivial

184
00:05:45,720 --> 00:05:47,880
so in response to this we have designed

185
00:05:47,880 --> 00:05:49,500
this language called hack spec and we

186
00:05:49,500 --> 00:05:51,900
are actively developing it whose main

187
00:05:51,900 --> 00:05:53,400
design goals are that it should be easy

188
00:05:53,400 --> 00:05:55,500
to use and in a familiar language for

189
00:05:55,500 --> 00:05:57,600
cryptographers and developers it should

190
00:05:57,600 --> 00:05:59,759
enable you to write succinct specs like

191
00:05:59,759 --> 00:06:00,960
pseudocode

192
00:06:00,960 --> 00:06:02,220
but at the same time it should be

193
00:06:02,220 --> 00:06:04,800
executable and testable against RFC test

194
00:06:04,800 --> 00:06:06,600
vectors and of course the main important

195
00:06:06,600 --> 00:06:08,460
thing is it should be translatable to

196
00:06:08,460 --> 00:06:10,080
these all the two languages that you

197
00:06:10,080 --> 00:06:11,759
want so if you want to use different

198
00:06:11,759 --> 00:06:13,139
verification tools you should be able to

199
00:06:13,139 --> 00:06:14,880
translate this one hack spec to the

200
00:06:14,880 --> 00:06:18,120
input languages of different tools

201
00:06:18,120 --> 00:06:19,860
to this end we have designed this

202
00:06:19,860 --> 00:06:21,840
language as a purely functional subset

203
00:06:21,840 --> 00:06:24,300
of rust which means that it's in Rust

204
00:06:24,300 --> 00:06:26,280
but there is no mutable borrow so a lot

205
00:06:26,280 --> 00:06:27,780
of the complexity of rust coding just

206
00:06:27,780 --> 00:06:30,000
goes away all the values that we use

207
00:06:30,000 --> 00:06:31,440
here are copyable

208
00:06:31,440 --> 00:06:33,300
you can just use the standard rust

209
00:06:33,300 --> 00:06:34,800
development environment to write your

210
00:06:34,800 --> 00:06:36,660
hack specs but you get access to a

211
00:06:36,660 --> 00:06:38,639
library of high-level abstractions which

212
00:06:38,639 --> 00:06:42,000
are commonly used in crypto code

213
00:06:42,000 --> 00:06:43,740
so what does the code in hack spec

214
00:06:43,740 --> 00:06:45,479
actually look like what do these specs

215
00:06:45,479 --> 00:06:46,440
look like

216
00:06:46,440 --> 00:06:49,020
well they really look like rust but in a

217
00:06:49,020 --> 00:06:50,819
particular style right

218
00:06:50,819 --> 00:06:52,860
so here's a here's a fragment taken from

219
00:06:52,860 --> 00:06:55,259
the Cha-Cha 20 spec on the left is the

220
00:06:55,259 --> 00:06:57,300
serial code from the RFC and on the

221
00:06:57,300 --> 00:06:58,860
right is the hack spec for it it kind of

222
00:06:58,860 --> 00:07:00,720
looks similar with one difference which

223
00:07:00,720 --> 00:07:02,160
is that if you actually wrote this as

224
00:07:02,160 --> 00:07:04,440
code in Rust you would normally just in

225
00:07:04,440 --> 00:07:06,060
place mutate the state that's the

226
00:07:06,060 --> 00:07:07,860
natural way of implementing it

227
00:07:07,860 --> 00:07:10,139
but in the spec we are doing a purely

228
00:07:10,139 --> 00:07:11,520
functional spec so it's in the written

229
00:07:11,520 --> 00:07:12,960
in a state passing style so the function

230
00:07:12,960 --> 00:07:15,360
takes a state as input and produces a

231
00:07:15,360 --> 00:07:17,160
new state as an output

232
00:07:17,160 --> 00:07:19,259
and every line of this function is

233
00:07:19,259 --> 00:07:20,639
basically doing that it's basically

234
00:07:20,639 --> 00:07:23,400
copying taking uh the Old State doing

235
00:07:23,400 --> 00:07:25,199
some modifications and producing a new

236
00:07:25,199 --> 00:07:26,220
state

237
00:07:26,220 --> 00:07:28,440
for syntactic convenience hackspec does

238
00:07:28,440 --> 00:07:30,060
allow you to have local mutable

239
00:07:30,060 --> 00:07:31,680
variables within functions but the

240
00:07:31,680 --> 00:07:33,660
function as a whole does not have any

241
00:07:33,660 --> 00:07:35,099
external side effects so it is

242
00:07:35,099 --> 00:07:39,120
translatable to a pure pure function

243
00:07:39,120 --> 00:07:40,919
as a second example let's look at a

244
00:07:40,919 --> 00:07:43,979
fragment of the poly1305 spec on top is

245
00:07:43,979 --> 00:07:46,080
the is a fragment of the RFC where this

246
00:07:46,080 --> 00:07:49,139
is the main function in poly1305 Mac

247
00:07:49,139 --> 00:07:51,060
where you're taking a block you convert

248
00:07:51,060 --> 00:07:52,800
it into a field element then you do some

249
00:07:52,800 --> 00:07:54,120
field arithmetic on it and put the

250
00:07:54,120 --> 00:07:55,919
result in an accumulator

251
00:07:55,919 --> 00:07:57,300
okay so you can write it in three lines

252
00:07:57,300 --> 00:08:01,020
it looks pretty compact in in the RFC

253
00:08:01,020 --> 00:08:02,280
now if you were actually going to

254
00:08:02,280 --> 00:08:03,720
implement this you'll think about oh

255
00:08:03,720 --> 00:08:06,000
this is a 130 bit field so I have to

256
00:08:06,000 --> 00:08:07,919
like represent it with three integers or

257
00:08:07,919 --> 00:08:10,440
five U and 32s and do all kinds of big

258
00:08:10,440 --> 00:08:12,419
num stuff but no we are adding a spec

259
00:08:12,419 --> 00:08:14,160
here so in hack spec you can just the

260
00:08:14,160 --> 00:08:16,500
user can define a field of an arbitrary

261
00:08:16,500 --> 00:08:19,680
size modulo and arbitrary size Prime and

262
00:08:19,680 --> 00:08:21,479
then just to field arithmetic as if you

263
00:08:21,479 --> 00:08:23,580
were doing math on integers okay and

264
00:08:23,580 --> 00:08:25,080
this is provided so this is what the

265
00:08:25,080 --> 00:08:27,740
spec looks like

266
00:08:29,340 --> 00:08:32,099
sometimes and this is again we may agree

267
00:08:32,099 --> 00:08:33,479
to disagree on whether this is actually

268
00:08:33,479 --> 00:08:35,399
needed or not but sometimes when you're

269
00:08:35,399 --> 00:08:37,320
specifying a crypto algorithm you may

270
00:08:37,320 --> 00:08:39,299
want to ask the question can this

271
00:08:39,299 --> 00:08:42,899
algorithm be implemented in a constant

272
00:08:42,899 --> 00:08:45,060
time style or a secret independent style

273
00:08:45,060 --> 00:08:48,420
is it does it is it amenable to this

274
00:08:48,420 --> 00:08:51,779
and for this hackspec allows you to

275
00:08:51,779 --> 00:08:53,940
Define both secret integers and public

276
00:08:53,940 --> 00:08:55,500
integers so there is public integers

277
00:08:55,500 --> 00:08:57,060
other than standard integer types of

278
00:08:57,060 --> 00:08:59,880
rust but for like u8 u32 and so on

279
00:08:59,880 --> 00:09:01,980
capital u8 capital u 32 are secret

280
00:09:01,980 --> 00:09:04,260
integers so on secret integers you can

281
00:09:04,260 --> 00:09:05,580
still do some arithmetic operations

282
00:09:05,580 --> 00:09:07,680
bitwise operations but you can't do any

283
00:09:07,680 --> 00:09:09,240
comparisons you can't use them as

284
00:09:09,240 --> 00:09:11,220
indexes into arrays and you can't do

285
00:09:11,220 --> 00:09:12,480
certain kinds of operations like

286
00:09:12,480 --> 00:09:14,160
division which are known to be

287
00:09:14,160 --> 00:09:16,380
problematic for constant time Behavior

288
00:09:16,380 --> 00:09:17,399
Etc

289
00:09:17,399 --> 00:09:19,440
so this enforces the property we call

290
00:09:19,440 --> 00:09:21,480
secret Independence some people like to

291
00:09:21,480 --> 00:09:22,980
call this constant time coding

292
00:09:22,980 --> 00:09:25,440
discipline but that's a misnomer

293
00:09:25,440 --> 00:09:27,959
and this basically allows you to check

294
00:09:27,959 --> 00:09:30,060
whether your algorithm as specified in

295
00:09:30,060 --> 00:09:32,279
your hack spec already is kind of

296
00:09:32,279 --> 00:09:33,660
resistant to certain kinds of such

297
00:09:33,660 --> 00:09:34,920
channels

298
00:09:34,920 --> 00:09:36,360
so on the top right there is this

299
00:09:36,360 --> 00:09:38,519
fragment of the charger 20 spec which is

300
00:09:38,519 --> 00:09:40,800
actually happening on secret unit 32s

301
00:09:40,800 --> 00:09:42,839
okay so all the operations there are

302
00:09:42,839 --> 00:09:44,339
just straight line code there is no

303
00:09:44,339 --> 00:09:46,980
issue there and on the bottom right is a

304
00:09:46,980 --> 00:09:48,660
fragment of the aespeck and hack spec

305
00:09:48,660 --> 00:09:50,640
and of course we know that in AES if

306
00:09:50,640 --> 00:09:52,019
you're going to write a spec that uses

307
00:09:52,019 --> 00:09:54,180
the s-box and you access the s-box at a

308
00:09:54,180 --> 00:09:56,399
secret index then that is actually going

309
00:09:56,399 --> 00:09:57,899
to cause you a side Channel and in this

310
00:09:57,899 --> 00:09:59,700
case it becomes explicit in hexback

311
00:09:59,700 --> 00:10:01,680
because you have a u8 which you have to

312
00:10:01,680 --> 00:10:03,660
declassify explicitly before you can use

313
00:10:03,660 --> 00:10:06,660
it as an index so even for specs which

314
00:10:06,660 --> 00:10:09,360
are actually not secret independent it's

315
00:10:09,360 --> 00:10:11,100
sometimes useful to leave in this kind

316
00:10:11,100 --> 00:10:13,080
of an annotation in there saying hey at

317
00:10:13,080 --> 00:10:14,339
this point in the spec I had to

318
00:10:14,339 --> 00:10:16,560
declassify so when you're implementing

319
00:10:16,560 --> 00:10:18,480
the spec be careful because this is

320
00:10:18,480 --> 00:10:20,100
exactly where you have to make sure that

321
00:10:20,100 --> 00:10:22,980
your code is not going to leak side

322
00:10:22,980 --> 00:10:25,380
channels

323
00:10:25,380 --> 00:10:27,300
so using all these idioms we have

324
00:10:27,300 --> 00:10:28,620
written a whole bunch of specs in hack

325
00:10:28,620 --> 00:10:30,959
spec and in for each of these hack specs

326
00:10:30,959 --> 00:10:32,760
you can press a button and there are

327
00:10:32,760 --> 00:10:35,220
tools that will generate F star and

328
00:10:35,220 --> 00:10:37,380
easy Crypt specs from them this is under

329
00:10:37,380 --> 00:10:39,120
active development in the future we may

330
00:10:39,120 --> 00:10:41,640
add more uh backends to it and we're

331
00:10:41,640 --> 00:10:43,019
trying to capture more and more of the

332
00:10:43,019 --> 00:10:45,300
front-end language of trust in these

333
00:10:45,300 --> 00:10:47,640
kinds of translations

334
00:10:47,640 --> 00:10:50,279
but hackspec itself we see it as a

335
00:10:50,279 --> 00:10:52,560
crucial piece of a larger software

336
00:10:52,560 --> 00:10:55,079
development strategy that we have here

337
00:10:55,079 --> 00:10:57,180
where if you're for example writing a

338
00:10:57,180 --> 00:10:58,860
new cryptographic application we

339
00:10:58,860 --> 00:11:01,140
recommend you write it first in Rust for

340
00:11:01,140 --> 00:11:02,760
all the crypto that you need link it

341
00:11:02,760 --> 00:11:05,040
with the hack specs for those crypto and

342
00:11:05,040 --> 00:11:07,140
this creates for you a first prototype

343
00:11:07,140 --> 00:11:08,459
so you can run this because the hack

344
00:11:08,459 --> 00:11:10,980
specs are executable you can test it you

345
00:11:10,980 --> 00:11:12,540
can run it against various test vectors

346
00:11:12,540 --> 00:11:14,040
be confident that your application is

347
00:11:14,040 --> 00:11:16,019
doing what it's doing and once you're

348
00:11:16,019 --> 00:11:17,579
happy with this with this high level

349
00:11:17,579 --> 00:11:18,899
specs of all the crypto that you're

350
00:11:18,899 --> 00:11:21,360
using you can translate your crypto into

351
00:11:21,360 --> 00:11:23,220
formal specs for whatever language you

352
00:11:23,220 --> 00:11:24,120
like

353
00:11:24,120 --> 00:11:26,640
find some verified implementation or

354
00:11:26,640 --> 00:11:28,980
build a verified implementation for if

355
00:11:28,980 --> 00:11:30,600
this is new crypto and verified against

356
00:11:30,600 --> 00:11:32,640
the formal spec and then you can just

357
00:11:32,640 --> 00:11:35,579
transmit the application over just move

358
00:11:35,579 --> 00:11:38,040
it over to work on top of the verified

359
00:11:38,040 --> 00:11:40,200
crypto and now you have your Deployable

360
00:11:40,200 --> 00:11:43,380
production ready implementation they so

361
00:11:43,380 --> 00:11:45,300
we can provide rust bindings on the

362
00:11:45,300 --> 00:11:46,560
right hand side on top of the verified

363
00:11:46,560 --> 00:11:48,540
crypto which exactly match the hack spec

364
00:11:48,540 --> 00:11:50,519
code on the left hand side and this is

365
00:11:50,519 --> 00:11:52,380
the methodology that we've used to build

366
00:11:52,380 --> 00:11:55,200
a new crypto Library called lib Crux and

367
00:11:55,200 --> 00:11:56,220
that's what I'm going to hand over to

368
00:11:56,220 --> 00:11:59,660
Francisca so we'll describe it to you

369
00:12:01,440 --> 00:12:04,860
thanks so what can we actually do with

370
00:12:04,860 --> 00:12:06,000
uh

371
00:12:06,000 --> 00:12:09,180
hack spec so we can do a lot of things

372
00:12:09,180 --> 00:12:11,160
and I'm talking a little bit about the

373
00:12:11,160 --> 00:12:12,899
different things we have been doing so

374
00:12:12,899 --> 00:12:15,240
far and what we are planning on doing in

375
00:12:15,240 --> 00:12:19,019
future so Karthik Soldier already that

376
00:12:19,019 --> 00:12:20,160
there are formally verified

377
00:12:20,160 --> 00:12:22,440
implementations for most cryptographic

378
00:12:22,440 --> 00:12:25,560
Primitives out there today but they are

379
00:12:25,560 --> 00:12:28,380
still relatively hard to use and that in

380
00:12:28,380 --> 00:12:29,579
general like the entire space is a

381
00:12:29,579 --> 00:12:32,880
little fragmented so we use text back to

382
00:12:32,880 --> 00:12:35,399
create this unified crypto Library

383
00:12:35,399 --> 00:12:38,399
called lip Crux in Rust which uses

384
00:12:38,399 --> 00:12:41,399
hexback as this common trust based so

385
00:12:41,399 --> 00:12:42,959
unlike something like hack of star or

386
00:12:42,959 --> 00:12:45,600
something it's not a silo that's defined

387
00:12:45,600 --> 00:12:48,420
only for this very specific language in

388
00:12:48,420 --> 00:12:51,420
the back end but you can plug in any

389
00:12:51,420 --> 00:12:54,959
verified code that you might have

390
00:12:54,959 --> 00:12:56,940
so how does this look what do we need to

391
00:12:56,940 --> 00:12:59,760
do to get this done so

392
00:12:59,760 --> 00:13:02,700
lip cracks safely wraps formally

393
00:13:02,700 --> 00:13:05,880
verified code if that's in C assembly or

394
00:13:05,880 --> 00:13:08,399
in Rust itself

395
00:13:08,399 --> 00:13:10,680
and it on a high level consists of four

396
00:13:10,680 --> 00:13:13,139
different parts we add a safe defensive

397
00:13:13,139 --> 00:13:16,260
API on top we have new constructions

398
00:13:16,260 --> 00:13:17,940
that are written entirely in hexback

399
00:13:17,940 --> 00:13:19,920
itself I'll talk about that later as

400
00:13:19,920 --> 00:13:20,940
well

401
00:13:20,940 --> 00:13:23,040
and then if you're actually interested

402
00:13:23,040 --> 00:13:25,260
in the formal guarantees you get from

403
00:13:25,260 --> 00:13:27,120
the library they are the actual

404
00:13:27,120 --> 00:13:28,740
specifications written in hexback there

405
00:13:28,740 --> 00:13:30,660
as well and there are reproducible

406
00:13:30,660 --> 00:13:33,000
proofs that you can if you can install

407
00:13:33,000 --> 00:13:36,000
other dependencies can run yourself uh

408
00:13:36,000 --> 00:13:38,220
on lip trucks

409
00:13:38,220 --> 00:13:40,079
on the back end as I said we are

410
00:13:40,079 --> 00:13:42,720
wrapping uh C and assembly code that's

411
00:13:42,720 --> 00:13:44,820
coming from the echo star project from

412
00:13:44,820 --> 00:13:47,639
whale and from the trade and from the Au

413
00:13:47,639 --> 00:13:50,160
curves we even get rust codes directly

414
00:13:50,160 --> 00:13:52,680
that you can wrap

415
00:13:52,680 --> 00:13:56,459
so what do I mean by save apis I mean

416
00:13:56,459 --> 00:13:58,980
you might think that that's a verified

417
00:13:58,980 --> 00:14:01,560
code so we don't have to worry about how

418
00:14:01,560 --> 00:14:02,820
to call the code

419
00:14:02,820 --> 00:14:04,380
but

420
00:14:04,380 --> 00:14:07,560
well mostly we have C apis because we

421
00:14:07,560 --> 00:14:09,899
need them but as we all know C isn't the

422
00:14:09,899 --> 00:14:12,540
safest language in the world so we have

423
00:14:12,540 --> 00:14:14,579
to expect some issues here so this is

424
00:14:14,579 --> 00:14:18,180
the Cha-Cha poly encrypt Junction that

425
00:14:18,180 --> 00:14:21,720
takes pointers to the key and the nons

426
00:14:21,720 --> 00:14:26,399
and the AED the message the cipher and

427
00:14:26,399 --> 00:14:28,620
outputs a Mac

428
00:14:28,620 --> 00:14:32,820
and while it's not in the API we know

429
00:14:32,820 --> 00:14:35,459
that K and N here have to be fixed

430
00:14:35,459 --> 00:14:38,519
length and the Mac as well actually and

431
00:14:38,519 --> 00:14:40,380
the cipher output as well as the Mac

432
00:14:40,380 --> 00:14:42,600
output have to be disjoint

433
00:14:42,600 --> 00:14:44,880
but this is actually nothing we can

434
00:14:44,880 --> 00:14:47,040
check here in the API

435
00:14:47,040 --> 00:14:48,839
so

436
00:14:48,839 --> 00:14:51,540
in the proof that's underlying this if

437
00:14:51,540 --> 00:14:53,519
we actually want to be sure that we call

438
00:14:53,519 --> 00:14:56,279
this code in a way it's intended to be

439
00:14:56,279 --> 00:14:57,240
called

440
00:14:57,240 --> 00:14:59,100
we've we have to make sure these

441
00:14:59,100 --> 00:15:00,779
preconditions that we have in the

442
00:15:00,779 --> 00:15:02,519
underlying proof in f-star actually hold

443
00:15:02,519 --> 00:15:04,260
so here we explicitly see that the key

444
00:15:04,260 --> 00:15:07,139
has to be 32 bytes for example and the

445
00:15:07,139 --> 00:15:09,060
nonce has to be 12 bytes

446
00:15:09,060 --> 00:15:12,000
the same way the F star code underlying

447
00:15:12,000 --> 00:15:12,779
this

448
00:15:12,779 --> 00:15:16,800
ensures that all the inputs and outputs

449
00:15:16,800 --> 00:15:18,959
are disjoint or in this case the input

450
00:15:18,959 --> 00:15:22,638
output might be equal

451
00:15:23,040 --> 00:15:25,800
so how do we ensure this well in Rust we

452
00:15:25,800 --> 00:15:27,899
have a couple more options to actually

453
00:15:27,899 --> 00:15:31,260
ensure that the API is safe and one way

454
00:15:31,260 --> 00:15:34,199
we can do this is by using types

455
00:15:34,199 --> 00:15:35,699
so in this case

456
00:15:35,699 --> 00:15:38,459
we use types for the key the nonce and

457
00:15:38,459 --> 00:15:40,560
the attack and that way ensure that it

458
00:15:40,560 --> 00:15:43,620
can only be called with arrays of this

459
00:15:43,620 --> 00:15:44,880
exact size

460
00:15:44,880 --> 00:15:48,000
and by using an input output parameter

461
00:15:48,000 --> 00:15:50,880
and using the rust compiler there's

462
00:15:50,880 --> 00:15:52,980
compiler ensures that this mutable

463
00:15:52,980 --> 00:15:55,680
variable isn't used in any other place

464
00:15:55,680 --> 00:16:00,480
and on top we can make use of the rust

465
00:16:00,480 --> 00:16:04,199
compiler and consuming the nons here so

466
00:16:04,199 --> 00:16:06,060
the nuns can't be reused unless you

467
00:16:06,060 --> 00:16:08,760
explicitly clone it beforehand that's a

468
00:16:08,760 --> 00:16:11,360
nice add-on

469
00:16:11,399 --> 00:16:15,980
so that's safe API but you might ask

470
00:16:16,560 --> 00:16:17,279
um

471
00:16:17,279 --> 00:16:18,959
wait

472
00:16:18,959 --> 00:16:21,540
so what can we all do with this and is

473
00:16:21,540 --> 00:16:23,880
this any efficient because

474
00:16:23,880 --> 00:16:25,860
well we are wrapping code and it's from

475
00:16:25,860 --> 00:16:27,899
the verified code even if academics

476
00:16:27,899 --> 00:16:29,279
claim this is fast it might not actually

477
00:16:29,279 --> 00:16:31,019
be fast

478
00:16:31,019 --> 00:16:32,100
um

479
00:16:32,100 --> 00:16:33,779
well we I think we have a pretty

480
00:16:33,779 --> 00:16:36,420
complete body of algorithms implemented

481
00:16:36,420 --> 00:16:40,620
uh here that you can use for pretty much

482
00:16:40,620 --> 00:16:42,959
any modern protocol that requires

483
00:16:42,959 --> 00:16:44,759
cryptography

484
00:16:44,759 --> 00:16:47,279
and looking at the performance we

485
00:16:47,279 --> 00:16:50,579
measured this on the Apple M1 chip and

486
00:16:50,579 --> 00:16:55,199
and Intel CPU we are always as fast as

487
00:16:55,199 --> 00:16:59,279
other rust cryptography and we are

488
00:16:59,279 --> 00:17:01,259
usually faster than any cryptography

489
00:17:01,259 --> 00:17:03,600
written purely in Rust so ring and open

490
00:17:03,600 --> 00:17:06,540
SL here are binding to C libraries so C

491
00:17:06,540 --> 00:17:08,880
and assembly and rust crypto is pure

492
00:17:08,880 --> 00:17:11,720
rust crypto

493
00:17:13,020 --> 00:17:16,319
I said there are also new constructions

494
00:17:16,319 --> 00:17:20,299
that are purely written in hexback

495
00:17:20,400 --> 00:17:24,260
so there is the RFC

496
00:17:24,260 --> 00:17:26,939
9180 which is hybrid public key

497
00:17:26,939 --> 00:17:28,740
encryption

498
00:17:28,740 --> 00:17:32,100
which is used for example in MLS or for

499
00:17:32,100 --> 00:17:35,100
the encrypted client hello in TLS

500
00:17:35,100 --> 00:17:38,900
and we wrote a hexback implementation of

501
00:17:38,900 --> 00:17:42,000
hpke in lib Crux that is entirely

502
00:17:42,000 --> 00:17:44,220
written in hexback

503
00:17:44,220 --> 00:17:46,620
so it is not a stateful rust

504
00:17:46,620 --> 00:17:48,000
implementation but instead a

505
00:17:48,000 --> 00:17:50,720
specification

506
00:17:53,760 --> 00:17:54,500
um

507
00:17:54,500 --> 00:17:58,380
okay so okay we're missing a slide here

508
00:17:58,380 --> 00:18:00,500
um

509
00:18:00,780 --> 00:18:02,400
you might think because it's a

510
00:18:02,400 --> 00:18:04,260
specification it's not fast because it's

511
00:18:04,260 --> 00:18:06,080
obviously obviously not optimized code

512
00:18:06,080 --> 00:18:08,940
and we as kartik has shown you earlier

513
00:18:08,940 --> 00:18:11,520
we are using State parsing so we

514
00:18:11,520 --> 00:18:12,539
actually have to copy a little more

515
00:18:12,539 --> 00:18:14,400
memory than we would usually do if we

516
00:18:14,400 --> 00:18:15,960
have state for rest

517
00:18:15,960 --> 00:18:18,660
but we measured this and

518
00:18:18,660 --> 00:18:21,240
as you see lip Crux is like slightly

519
00:18:21,240 --> 00:18:23,760
slower than a generic rust

520
00:18:23,760 --> 00:18:25,260
implementation but this is actually only

521
00:18:25,260 --> 00:18:27,059
due to the fact that the

522
00:18:27,059 --> 00:18:29,220
curved if I have 19 base Point

523
00:18:29,220 --> 00:18:30,720
multiplication is slower if you take

524
00:18:30,720 --> 00:18:33,120
that into account the hexback

525
00:18:33,120 --> 00:18:35,280
implementation is as fast as stateful

526
00:18:35,280 --> 00:18:37,980
rust and I think this is a good

527
00:18:37,980 --> 00:18:40,020
indicator for the fact that if you

528
00:18:40,020 --> 00:18:42,059
implement a mechanism

529
00:18:42,059 --> 00:18:44,940
that is using crypto but is actually

530
00:18:44,940 --> 00:18:46,380
more of a state machine so something

531
00:18:46,380 --> 00:18:48,840
like hpke or something like a like a

532
00:18:48,840 --> 00:18:49,860
protocol

533
00:18:49,860 --> 00:18:54,299
you can use the hexback specification as

534
00:18:54,299 --> 00:18:55,679
actual code

535
00:18:55,679 --> 00:18:57,960
and don't need a separate efficient

536
00:18:57,960 --> 00:18:59,460
implementation so you can save yourself

537
00:18:59,460 --> 00:19:01,679
the effort of doing a correctness proof

538
00:19:01,679 --> 00:19:04,700
for Your Efficient implementation

539
00:19:06,480 --> 00:19:09,419
so that's lip Crux what else can we do

540
00:19:09,419 --> 00:19:12,919
with hexback

541
00:19:13,020 --> 00:19:14,660
in a recent paper

542
00:19:14,660 --> 00:19:19,740
by Lassa and bus and their co-authors

543
00:19:19,740 --> 00:19:22,620
it's called last yard they used hexback

544
00:19:22,620 --> 00:19:26,340
to connect hexback

545
00:19:26,340 --> 00:19:30,240
to Jasmine and in that work they provide

546
00:19:30,240 --> 00:19:33,539
an end-to-end foundational verification

547
00:19:33,539 --> 00:19:36,360
for the correctness and security of the

548
00:19:36,360 --> 00:19:37,860
stressman implementation

549
00:19:37,860 --> 00:19:40,440
so they Translate

550
00:19:40,440 --> 00:19:43,679
Jasmine to the proof implementation that

551
00:19:43,679 --> 00:19:45,539
they use to do the security proof and on

552
00:19:45,539 --> 00:19:47,700
the other hand they use the hexback

553
00:19:47,700 --> 00:19:50,460
specification to do a correctness proof

554
00:19:50,460 --> 00:19:54,799
against the asset proof implementation

555
00:19:56,640 --> 00:19:58,380
already mentioned there are a couple

556
00:19:58,380 --> 00:20:00,000
back end couple different backends and

557
00:20:00,000 --> 00:20:01,440
we're working on integrating more so

558
00:20:01,440 --> 00:20:04,320
here we have a list of actual tools that

559
00:20:04,320 --> 00:20:07,320
we have and that we plan on integrating

560
00:20:07,320 --> 00:20:09,660
So currently as I said there's a

561
00:20:09,660 --> 00:20:10,919
connection to assess proof and easy

562
00:20:10,919 --> 00:20:14,220
Crypt to do cryptographic security

563
00:20:14,220 --> 00:20:17,880
proofs on hexbacks and we plan to add

564
00:20:17,880 --> 00:20:20,039
other tools like proverif cryptovarov or

565
00:20:20,039 --> 00:20:21,120
squirrel

566
00:20:21,120 --> 00:20:23,039
and for program replication on the other

567
00:20:23,039 --> 00:20:26,400
hand we intend to connect to tools like

568
00:20:26,400 --> 00:20:29,340
NES to verify a larger body of rust

569
00:20:29,340 --> 00:20:31,740
applications and we added things like

570
00:20:31,740 --> 00:20:33,539
quick check or cruzo to actually test

571
00:20:33,539 --> 00:20:35,160
the specifications

572
00:20:35,160 --> 00:20:37,799
and if you have any different backend

573
00:20:37,799 --> 00:20:39,600
that you would like to use you can just

574
00:20:39,600 --> 00:20:43,939
bring it and use it

575
00:20:44,640 --> 00:20:46,760
um

576
00:20:47,419 --> 00:20:50,700
so I'm out of time but let's quickly

577
00:20:50,700 --> 00:20:54,480
recap Karthik talked about hexback and

578
00:20:54,480 --> 00:20:57,240
why it's so important that we agree on

579
00:20:57,240 --> 00:20:59,940
specifications and that we have a

580
00:20:59,940 --> 00:21:01,559
language to write these specifications

581
00:21:01,559 --> 00:21:04,200
in that we can all read and write and

582
00:21:04,200 --> 00:21:06,000
not only the verification experts and

583
00:21:06,000 --> 00:21:08,460
that's what hexback is

584
00:21:08,460 --> 00:21:10,559
um if you write specifications or do

585
00:21:10,559 --> 00:21:12,900
proofs come and use it and on the other

586
00:21:12,900 --> 00:21:15,480
hand we have like Crux as like one

587
00:21:15,480 --> 00:21:17,880
example that tries to bring together the

588
00:21:17,880 --> 00:21:20,460
community uh that writes formerly

589
00:21:20,460 --> 00:21:23,460
verified cryptography and gets in gets

590
00:21:23,460 --> 00:21:26,160
it into the hand of users

591
00:21:26,160 --> 00:21:28,550
thank you

592
00:21:28,550 --> 00:21:34,380
[Applause]

593
00:21:34,380 --> 00:21:37,020
thank you very much maybe there's time

594
00:21:37,020 --> 00:21:39,900
for one short question if somebody okay

595
00:21:39,900 --> 00:21:41,400
so Yuval is already

596
00:21:41,400 --> 00:21:43,380
going to the microphone and we take that

597
00:21:43,380 --> 00:21:45,299
one

598
00:21:45,299 --> 00:21:48,480
um thank you for the nice talk um I was

599
00:21:48,480 --> 00:21:50,760
quite intrigued by the decision to put

600
00:21:50,760 --> 00:21:54,299
the uh the classification in the uh in

601
00:21:54,299 --> 00:21:56,940
the uh formal specifications I would

602
00:21:56,940 --> 00:21:58,799
have thought that's a property of the

603
00:21:58,799 --> 00:22:00,120
implementation and not of the

604
00:22:00,120 --> 00:22:01,440
specifications

605
00:22:01,440 --> 00:22:04,500
can you elaborate a bit about that

606
00:22:04,500 --> 00:22:06,659
yeah so let me take that because yeah I

607
00:22:06,659 --> 00:22:08,460
mean this is something that even Peter

608
00:22:08,460 --> 00:22:10,320
and I were discussing this is a constant

609
00:22:10,320 --> 00:22:12,419
question that we ask ourselves and ask

610
00:22:12,419 --> 00:22:15,900
other people as well so there is if

611
00:22:15,900 --> 00:22:19,140
you're writing a spec in math or

612
00:22:19,140 --> 00:22:20,460
and whatever then obviously you would

613
00:22:20,460 --> 00:22:22,679
never even think about doing this kind

614
00:22:22,679 --> 00:22:24,480
of Declassified thing there because he

615
00:22:24,480 --> 00:22:25,860
is trying to capture the functional

616
00:22:25,860 --> 00:22:27,419
properties but when we are doing

617
00:22:27,419 --> 00:22:28,679
something like hack spec there's like

618
00:22:28,679 --> 00:22:31,080
two things one is in some cases the hack

619
00:22:31,080 --> 00:22:33,240
spec code is kind of a reference

620
00:22:33,240 --> 00:22:34,799
implementation you might be tempted to

621
00:22:34,799 --> 00:22:36,000
actually use it as a reference

622
00:22:36,000 --> 00:22:38,460
implementation and in those cases I feel

623
00:22:38,460 --> 00:22:39,900
more comfortable if you actually have

624
00:22:39,900 --> 00:22:41,280
some tools in your hand to make sure

625
00:22:41,280 --> 00:22:44,340
that you're not doing silly things uh in

626
00:22:44,340 --> 00:22:45,960
this code even if it should never be

627
00:22:45,960 --> 00:22:48,000
used in production but even so

628
00:22:48,000 --> 00:22:49,799
the second thing is exactly that kind of

629
00:22:49,799 --> 00:22:52,260
case where if you're writing a new PQ

630
00:22:52,260 --> 00:22:53,640
primitive or whatever and you just want

631
00:22:53,640 --> 00:22:55,440
to you have already have a spec for it

632
00:22:55,440 --> 00:22:56,760
and before writing an implementation you

633
00:22:56,760 --> 00:22:59,340
want to do a very early test as to where

634
00:22:59,340 --> 00:23:01,320
in this implementation this algorithm

635
00:23:01,320 --> 00:23:03,299
I've designed do I have to be a little

636
00:23:03,299 --> 00:23:05,460
bit maybe careful about about side

637
00:23:05,460 --> 00:23:07,620
channels then this kind of tracking the

638
00:23:07,620 --> 00:23:10,200
secrecy values through the spec is I

639
00:23:10,200 --> 00:23:12,600
think a useful thing you may want but in

640
00:23:12,600 --> 00:23:13,799
many specs you don't have to do it you

641
00:23:13,799 --> 00:23:15,240
can just use public integers everywhere

642
00:23:15,240 --> 00:23:17,159
and you're just trying to capture the

643
00:23:17,159 --> 00:23:18,480
functionality and that's completely a

644
00:23:18,480 --> 00:23:20,760
matter of taste in what you want

645
00:23:20,760 --> 00:23:22,679
thank you

646
00:23:22,679 --> 00:23:24,600
yeah thank you very much again I would

647
00:23:24,600 --> 00:23:26,400
suggest we continue with the next talk

648
00:23:26,400 --> 00:23:28,620
in the interest of time and move further

649
00:23:28,620 --> 00:23:31,639
questions to the coffee break

650
00:23:31,679 --> 00:23:32,400
um

651
00:23:32,400 --> 00:23:35,159
so the the next talk is about a code

652
00:23:35,159 --> 00:23:38,159
with fewer bugs

653
00:23:38,159 --> 00:23:41,280
I'll give it another moment until

654
00:23:41,280 --> 00:23:44,299
everything is set up

655
00:23:48,559 --> 00:23:51,059
thank you very much it's about go

656
00:23:51,059 --> 00:23:53,039
cryptography actually by uh Philippe

657
00:23:53,039 --> 00:23:56,700
balzorda so please the stage is yours

658
00:23:56,700 --> 00:23:59,360
thank you

659
00:24:00,360 --> 00:24:02,460
thank you I'm really excited to be

660
00:24:02,460 --> 00:24:04,440
speaking at River crypto almost 10 years

661
00:24:04,440 --> 00:24:07,320
after attending my first one in New York

662
00:24:07,320 --> 00:24:10,080
uh I'm Philippa sorda and I'm a

663
00:24:10,080 --> 00:24:11,700
cryptographic engineer and I'm open

664
00:24:11,700 --> 00:24:14,100
source maintainer I've been maintaining

665
00:24:14,100 --> 00:24:15,720
the I've been a maintainer of the go

666
00:24:15,720 --> 00:24:17,600
cryptography standard Library since 2018

667
00:24:17,600 --> 00:24:20,700
working over the years yeah sorry

668
00:24:20,700 --> 00:24:23,159
working over the years with Katie

669
00:24:23,159 --> 00:24:24,960
Hockman and Roland Shoemaker at Google

670
00:24:24,960 --> 00:24:27,539
initially and then as an independent

671
00:24:27,539 --> 00:24:29,460
maintainer as of last year

672
00:24:29,460 --> 00:24:31,860
I also maintain other open source

673
00:24:31,860 --> 00:24:33,600
cryptography tools like the file

674
00:24:33,600 --> 00:24:36,659
encryption 2 again and mixer a tool to

675
00:24:36,659 --> 00:24:40,440
make locally trusted https certificate

676
00:24:40,440 --> 00:24:42,360
I've been involved in the design of the

677
00:24:42,360 --> 00:24:45,120
checksum database which is a software

678
00:24:45,120 --> 00:24:48,539
supply chain solution based on

679
00:24:48,539 --> 00:24:51,659
transparency trees and TLS 1.3 and

680
00:24:51,659 --> 00:24:53,640
privacy pass which by now I'm going to

681
00:24:53,640 --> 00:24:55,440
assume you're familiar with given the

682
00:24:55,440 --> 00:24:57,480
program this year

683
00:24:57,480 --> 00:25:00,780
now before I start I want to talk about

684
00:25:00,780 --> 00:25:02,880
what the Google cryptography standard

685
00:25:02,880 --> 00:25:05,820
libraries even are because go made a

686
00:25:05,820 --> 00:25:08,820
unconventional Choice it doesn't link uh

687
00:25:08,820 --> 00:25:11,220
existing cryptography toolkit and

688
00:25:11,220 --> 00:25:12,720
instead it implements all its

689
00:25:12,720 --> 00:25:15,419
cryptography in the native language it

690
00:25:15,419 --> 00:25:17,520
has everything from low level Primitives

691
00:25:17,520 --> 00:25:20,580
to high level protocol implementations

692
00:25:20,580 --> 00:25:23,039
originally this Choice was made for

693
00:25:23,039 --> 00:25:25,260
build system reasons and the libraries

694
00:25:25,260 --> 00:25:27,779
were originally designed by Adam Langley

695
00:25:27,779 --> 00:25:31,620
uh in brief the the go compiler is

696
00:25:31,620 --> 00:25:33,240
particularly good and has always been

697
00:25:33,240 --> 00:25:36,059
good at Cross compilation and situle

698
00:25:36,059 --> 00:25:38,159
chains have not

699
00:25:38,159 --> 00:25:41,400
so that's what drove initially the uh

700
00:25:41,400 --> 00:25:43,799
the decision to implement all the

701
00:25:43,799 --> 00:25:45,120
cryptography re-implement all the

702
00:25:45,120 --> 00:25:47,940
cryptography but what it allows us to do

703
00:25:47,940 --> 00:25:50,700
to do is that it gives us a

704
00:25:50,700 --> 00:25:53,580
gives us a wide degree of control that

705
00:25:53,580 --> 00:25:55,140
allows us to apply all the techniques

706
00:25:55,140 --> 00:25:57,179
we're going to talk about today to keep

707
00:25:57,179 --> 00:26:00,200
the libraries safe

708
00:26:00,299 --> 00:26:02,760
so I know that this is the high

709
00:26:02,760 --> 00:26:04,919
Assurance session and I love formal

710
00:26:04,919 --> 00:26:06,840
methods and I would like to use more of

711
00:26:06,840 --> 00:26:09,080
them but

712
00:26:09,080 --> 00:26:12,179
today we're going to talk about the very

713
00:26:12,179 --> 00:26:15,299
day-to-day things that we do to keep our

714
00:26:15,299 --> 00:26:17,159
libraries safe

715
00:26:17,159 --> 00:26:21,000
that includes using reusable uh language

716
00:26:21,000 --> 00:26:23,580
agnostic test vectors domain specific

717
00:26:23,580 --> 00:26:26,640
fuzzing safe interfaces both internal

718
00:26:26,640 --> 00:26:29,460
and external and all the policies that

719
00:26:29,460 --> 00:26:31,500
we apply to reduce the complexity of

720
00:26:31,500 --> 00:26:33,539
this job to make it easier not to make

721
00:26:33,539 --> 00:26:35,960
mistakes

722
00:26:36,179 --> 00:26:38,580
now before we start I want to address

723
00:26:38,580 --> 00:26:40,940
the crab in the room

724
00:26:40,940 --> 00:26:44,100
implementing everything go affords us

725
00:26:44,100 --> 00:26:46,020
very good memory safety guarantees

726
00:26:46,020 --> 00:26:48,539
because go compiles with bounce checks

727
00:26:48,539 --> 00:26:50,880
automatically and manage memory using

728
00:26:50,880 --> 00:26:52,380
the garbage collector

729
00:26:52,380 --> 00:26:54,240
that means that some bugs are simply

730
00:26:54,240 --> 00:26:56,880
impossible and other bugs are going to

731
00:26:56,880 --> 00:26:59,100
be downgraded for what could have been a

732
00:26:59,100 --> 00:27:01,860
memory disclosure or a code execution

733
00:27:01,860 --> 00:27:04,380
vulnerability to simple denial of

734
00:27:04,380 --> 00:27:06,539
service issues

735
00:27:06,539 --> 00:27:09,059
now of course this is not free

736
00:27:09,059 --> 00:27:11,520
let's check have overhead and the

737
00:27:11,520 --> 00:27:13,860
garbage collector has to eat some CPU to

738
00:27:13,860 --> 00:27:15,240
do its job

739
00:27:15,240 --> 00:27:16,559
and

740
00:27:16,559 --> 00:27:18,900
I think it's overwhelmingly clear to us

741
00:27:18,900 --> 00:27:21,720
that the performance cost is definitely

742
00:27:21,720 --> 00:27:22,919
worth it

743
00:27:22,919 --> 00:27:26,100
because the safety advantage that we get

744
00:27:26,100 --> 00:27:28,020
out of it and the maintainability

745
00:27:28,020 --> 00:27:31,020
advantage pays for it with without a

746
00:27:31,020 --> 00:27:32,880
doubt this is something that we're going

747
00:27:32,880 --> 00:27:35,760
to come back to we need to be okay to

748
00:27:35,760 --> 00:27:39,539
take pay the performance cost of making

749
00:27:39,539 --> 00:27:44,880
our uh of making our libraries safer

750
00:27:44,880 --> 00:27:47,279
still even if bugs are limited in their

751
00:27:47,279 --> 00:27:49,919
vulnerable in their severity it's we

752
00:27:49,919 --> 00:27:51,960
still would like to catch them and an

753
00:27:51,960 --> 00:27:54,480
obvious way to do that is tests we like

754
00:27:54,480 --> 00:27:57,539
tests and we especially like reusable

755
00:27:57,539 --> 00:28:00,299
libraries of language agnostic tests

756
00:28:00,299 --> 00:28:03,179
like the widesproof project white proof

757
00:28:03,179 --> 00:28:04,919
If you're not familiar is a project by

758
00:28:04,919 --> 00:28:07,919
Google which essentially is a larger

759
00:28:07,919 --> 00:28:10,980
repository of giant Json files with

760
00:28:10,980 --> 00:28:13,500
inputs and expected outputs both valid

761
00:28:13,500 --> 00:28:16,380
and invalid for various cryptographic

762
00:28:16,380 --> 00:28:18,179
algorithms

763
00:28:18,179 --> 00:28:20,039
it's good it's very good for two things

764
00:28:20,039 --> 00:28:23,100
one is systematically applying certain

765
00:28:23,100 --> 00:28:26,820
tests across every algorithm and the

766
00:28:26,820 --> 00:28:28,980
other thing is figuring out very

767
00:28:28,980 --> 00:28:31,380
specific tests that implementers might

768
00:28:31,380 --> 00:28:33,480
not have thought about about for edge

769
00:28:33,480 --> 00:28:36,480
cases of certain algorithms it has found

770
00:28:36,480 --> 00:28:40,260
for us at least two CVS one in the of

771
00:28:40,260 --> 00:28:42,840
the former category where simply passing

772
00:28:42,840 --> 00:28:44,820
too long a string to a function was

773
00:28:44,820 --> 00:28:47,220
crashing it and we just didn't have a

774
00:28:47,220 --> 00:28:49,740
test for that for that specific function

775
00:28:49,740 --> 00:28:53,640
and one in x509 parsing where the issue

776
00:28:53,640 --> 00:28:56,460
was a very specific asn1 encoding that

777
00:28:56,460 --> 00:29:00,059
we were never going to test ourselves

778
00:29:00,059 --> 00:29:02,039
now

779
00:29:02,039 --> 00:29:04,140
if you get if you take one thing away

780
00:29:04,140 --> 00:29:07,620
from this talk is that I wanted to be

781
00:29:07,620 --> 00:29:09,720
that it's important to make your

782
00:29:09,720 --> 00:29:12,299
specifications if you're a specification

783
00:29:12,299 --> 00:29:14,460
outer and your research if you're a

784
00:29:14,460 --> 00:29:17,220
Searcher available as reusable language

785
00:29:17,220 --> 00:29:20,279
agnostic tests that implementations can

786
00:29:20,279 --> 00:29:22,740
use across the board so that we don't

787
00:29:22,740 --> 00:29:25,159
have to repeat and

788
00:29:25,159 --> 00:29:27,419
duplicate all that effort across

789
00:29:27,419 --> 00:29:28,620
implementations

790
00:29:28,620 --> 00:29:32,100
so again reusable test test test test

791
00:29:32,100 --> 00:29:35,100
tests

792
00:29:35,279 --> 00:29:37,440
but nobody likes writing tests let's be

793
00:29:37,440 --> 00:29:38,520
honest here

794
00:29:38,520 --> 00:29:40,860
so what really works for us has been

795
00:29:40,860 --> 00:29:43,260
writing Frameworks to make the marginal

796
00:29:43,260 --> 00:29:45,659
cost of writing each additional test

797
00:29:45,659 --> 00:29:49,740
Vector so small that it beats inertia

798
00:29:49,740 --> 00:29:52,320
for that's not a new idea I really like

799
00:29:52,320 --> 00:29:55,559
the boring SSL test Suite called BOGO

800
00:29:55,559 --> 00:29:58,559
which is a fork of the go crypto TLS

801
00:29:58,559 --> 00:30:01,320
library that tests in implementations to

802
00:30:01,320 --> 00:30:03,480
Hashem so again reusable across

803
00:30:03,480 --> 00:30:06,179
implementations and allows testing for

804
00:30:06,179 --> 00:30:08,760
many different behaviors

805
00:30:08,760 --> 00:30:10,620
another pattern we took from the

806
00:30:10,620 --> 00:30:13,320
standard library is that of writing

807
00:30:13,320 --> 00:30:15,659
packages specifically to make it easier

808
00:30:15,659 --> 00:30:18,299
to test to their packages like a fake CA

809
00:30:18,299 --> 00:30:20,220
that you can make do weird things to

810
00:30:20,220 --> 00:30:23,760
test a ACME certificate issuance package

811
00:30:23,760 --> 00:30:25,919
and finally I want to take a quick

812
00:30:25,919 --> 00:30:27,659
detour from the go standard library to

813
00:30:27,659 --> 00:30:30,120
talk about ages test kit

814
00:30:30,120 --> 00:30:32,940
age being a file encryption tool you

815
00:30:32,940 --> 00:30:34,980
want to test it with a number of valid

816
00:30:34,980 --> 00:30:38,460
invalid malformed and weird input files

817
00:30:38,460 --> 00:30:41,640
but if you ever tested a protocol or a

818
00:30:41,640 --> 00:30:43,559
file format you know that producing

819
00:30:43,559 --> 00:30:45,720
invalid test vectors with a production

820
00:30:45,720 --> 00:30:48,120
library is actually kind of hard

821
00:30:48,120 --> 00:30:51,419
or at least it should be

822
00:30:51,419 --> 00:30:54,360
now what we did is we wrote a whole

823
00:30:54,360 --> 00:30:57,240
separate library that allows us very low

824
00:30:57,240 --> 00:31:00,840
level access to producing these files at

825
00:31:00,840 --> 00:31:03,539
the same time giving us Little Helpers

826
00:31:03,539 --> 00:31:06,000
to do repetitive things like making sure

827
00:31:06,000 --> 00:31:08,399
that the header hmac is correct because

828
00:31:08,399 --> 00:31:10,500
you want each test Vector to fail for

829
00:31:10,500 --> 00:31:12,899
one specific reason and not just because

830
00:31:12,899 --> 00:31:14,580
the signature is wrong

831
00:31:14,580 --> 00:31:17,460
so what you're seeing here is a file

832
00:31:17,460 --> 00:31:20,100
that generates a test Vector for a valid

833
00:31:20,100 --> 00:31:21,480
age file

834
00:31:21,480 --> 00:31:24,960
and when this is executed it generates a

835
00:31:24,960 --> 00:31:27,720
static asset which is nothing else than

836
00:31:27,720 --> 00:31:30,059
a gefile which is the input of the test

837
00:31:30,059 --> 00:31:32,340
with a little bit of metadata at the top

838
00:31:32,340 --> 00:31:34,200
to tell you whether this is supposed to

839
00:31:34,200 --> 00:31:37,140
fail succeed if it succeeds what it

840
00:31:37,140 --> 00:31:38,820
should decrypt to and what keys you need

841
00:31:38,820 --> 00:31:40,799
to use to decrypt it

842
00:31:40,799 --> 00:31:43,799
now this pattern works very well for us

843
00:31:43,799 --> 00:31:46,980
and it allowed me to write more than 100

844
00:31:46,980 --> 00:31:49,260
tests each manually over a couple of

845
00:31:49,260 --> 00:31:51,720
days because it's honestly kind of

846
00:31:51,720 --> 00:31:54,000
exhilarating not having to write

847
00:31:54,000 --> 00:31:56,820
production quality code because you're

848
00:31:56,820 --> 00:31:59,279
just writing tests and then just copy

849
00:31:59,279 --> 00:32:01,620
pasting files to say yeah we're testing

850
00:32:01,620 --> 00:32:03,480
what happens if a leading zero is

851
00:32:03,480 --> 00:32:04,919
ignored but what if it makes it

852
00:32:04,919 --> 00:32:07,799
interpreted as octal I was never going

853
00:32:07,799 --> 00:32:09,299
to write a test for that if it wasn't

854
00:32:09,299 --> 00:32:13,860
just copy paste 10 becomes 12 moving on

855
00:32:13,860 --> 00:32:17,159
uh we all the vectors we generated with

856
00:32:17,159 --> 00:32:19,440
this I generated with this I published

857
00:32:19,440 --> 00:32:22,440
under the CCTV repository which is the

858
00:32:22,440 --> 00:32:24,179
community cryptography test vectors

859
00:32:24,179 --> 00:32:26,940
repository and it was used by other AG

860
00:32:26,940 --> 00:32:29,520
implementations it found bugs both in my

861
00:32:29,520 --> 00:32:31,260
own implementation and in the rust

862
00:32:31,260 --> 00:32:34,200
implementation thank you

863
00:32:34,200 --> 00:32:36,840
now there is an even faster way to write

864
00:32:36,840 --> 00:32:39,840
test vectors though and that's buzzing

865
00:32:39,840 --> 00:32:42,240
what really worked for us uh has been

866
00:32:42,240 --> 00:32:44,580
two fuzzing techniques one is

867
00:32:44,580 --> 00:32:46,320
differential fuzzing which is the

868
00:32:46,320 --> 00:32:48,360
technique of running two implementations

869
00:32:48,360 --> 00:32:51,120
in a side by side and comparing their

870
00:32:51,120 --> 00:32:53,220
outputs to make sure that they agree on

871
00:32:53,220 --> 00:32:54,899
what their output should be

872
00:32:54,899 --> 00:32:57,600
the cryptofas project by Widow Rankin

873
00:32:57,600 --> 00:33:00,720
has found at least two CVS in the good

874
00:33:00,720 --> 00:33:02,580
cryptography libraries over the years

875
00:33:02,580 --> 00:33:06,899
and many others in other implementations

876
00:33:06,899 --> 00:33:09,960
however general purpose fuzzers really

877
00:33:09,960 --> 00:33:12,000
struggle with cryptography for two

878
00:33:12,000 --> 00:33:14,279
reasons one they can't use coverage

879
00:33:14,279 --> 00:33:17,100
guidance for constant time code constant

880
00:33:17,100 --> 00:33:18,179
time code

881
00:33:18,179 --> 00:33:21,000
old runs the code the coverage is 100

882
00:33:21,000 --> 00:33:23,640
every time which is very pleasing but

883
00:33:23,640 --> 00:33:25,679
kind of misleading

884
00:33:25,679 --> 00:33:27,720
and the other issue is that sometimes

885
00:33:27,720 --> 00:33:29,940
you have a distribution which is uh

886
00:33:29,940 --> 00:33:31,919
hundreds of bits wide and you can't just

887
00:33:31,919 --> 00:33:34,440
hit something randomly so would work for

888
00:33:34,440 --> 00:33:36,299
us here has been

889
00:33:36,299 --> 00:33:38,399
doing weighted fuzzing distributions

890
00:33:38,399 --> 00:33:41,399
what does that mean take for example a

891
00:33:41,399 --> 00:33:44,940
p224 field implementation implemented

892
00:33:44,940 --> 00:33:47,700
with 28-bit limbs we open the files

893
00:33:47,700 --> 00:33:49,140
scroll through it and notice that

894
00:33:49,140 --> 00:33:53,399
there's a lot of masking and shifting by

895
00:33:53,399 --> 00:33:56,820
28 and 12 bits this is not some Advanced

896
00:33:56,820 --> 00:33:58,200
analysis we literally just opened the

897
00:33:58,200 --> 00:34:00,299
file looked at constants so we're going

898
00:34:00,299 --> 00:34:02,700
to make a fuzzer that really likes

899
00:34:02,700 --> 00:34:06,539
producing values like 228 228-1 to the

900
00:34:06,539 --> 00:34:10,679
12 to 12 minus one one zero and maybe

901
00:34:10,679 --> 00:34:13,260
sometimes the sum of them and their

902
00:34:13,260 --> 00:34:16,679
difference and some Randomness thrown in

903
00:34:16,679 --> 00:34:18,659
for an example of how this works let's

904
00:34:18,659 --> 00:34:20,339
look at a vulnerability that was

905
00:34:20,339 --> 00:34:22,619
reported to us there was an issue in

906
00:34:22,619 --> 00:34:25,560
subtraction specifically when the value

907
00:34:25,560 --> 00:34:27,719
was higher than P so most of the top

908
00:34:27,719 --> 00:34:30,000
bits were one but at the same time the

909
00:34:30,000 --> 00:34:32,760
bottom 28 bits were zero anybody who

910
00:34:32,760 --> 00:34:34,260
implements field implementations here is

911
00:34:34,260 --> 00:34:38,699
having sort of moment of yes I know uh

912
00:34:38,699 --> 00:34:41,399
and the chance of hitting that randomly

913
00:34:41,399 --> 00:34:45,179
is 2 to the minus 154 that's the

914
00:34:45,179 --> 00:34:46,918
definition of negligible

915
00:34:46,918 --> 00:34:48,659
however the chance of generating that

916
00:34:48,659 --> 00:34:51,480
with our father distribution that we

917
00:34:51,480 --> 00:34:53,699
just described is 2 to the minus 18

918
00:34:53,699 --> 00:34:56,879
takes one second to find it I was very

919
00:34:56,879 --> 00:34:58,920
happy with that and then we went further

920
00:34:58,920 --> 00:35:01,260
and made this implementation 100 secure

921
00:35:01,260 --> 00:35:03,240
by deleting it because I'm not sure why

922
00:35:03,240 --> 00:35:04,859
we had a specific implementation for

923
00:35:04,859 --> 00:35:08,460
p224 nobody uses p224

924
00:35:08,460 --> 00:35:10,380
anyway

925
00:35:10,380 --> 00:35:13,079
even better than finding bugs is not

926
00:35:13,079 --> 00:35:14,460
being able to write them

927
00:35:14,460 --> 00:35:16,980
and that's why we hear so much about the

928
00:35:16,980 --> 00:35:20,400
interfaces in our code both internal and

929
00:35:20,400 --> 00:35:22,940
external

930
00:35:23,220 --> 00:35:26,220
for for an example here let's

931
00:35:26,220 --> 00:35:29,160
let's elliptic curve interface this was

932
00:35:29,160 --> 00:35:31,500
a public API that you had to use if you

933
00:35:31,500 --> 00:35:34,440
wanted to do things like Divi helmet

934
00:35:34,440 --> 00:35:38,280
you just take X and Y coordinates as big

935
00:35:38,280 --> 00:35:42,180
integers from the Mac big Library which

936
00:35:42,180 --> 00:35:45,060
is a general purpose begin library and

937
00:35:45,060 --> 00:35:47,520
you just stuff them in as X and Y and

938
00:35:47,520 --> 00:35:50,640
now I have a few questions for you what

939
00:35:50,640 --> 00:35:54,420
happens if a point is not on the Curve

940
00:35:54,420 --> 00:35:57,619
what happens if one of the coordinates

941
00:35:57,619 --> 00:36:00,359
overflows the field

942
00:36:00,359 --> 00:36:02,280
what happens if one of the coordinates

943
00:36:02,280 --> 00:36:04,500
is negative

944
00:36:04,500 --> 00:36:06,480
the answer to all of these questions are

945
00:36:06,480 --> 00:36:09,440
in the cve database

946
00:36:09,480 --> 00:36:12,900
so we deprecated all of that and we made

947
00:36:12,900 --> 00:36:15,540
a new high level API which does the one

948
00:36:15,540 --> 00:36:17,400
thing that people actually seemed to

949
00:36:17,400 --> 00:36:19,859
want to do with that API which is ecdh

950
00:36:19,859 --> 00:36:23,040
99 of the users I went through all of

951
00:36:23,040 --> 00:36:25,380
GitHub all of the Google internal code

952
00:36:25,380 --> 00:36:28,619
when I was still there and notice that

953
00:36:28,619 --> 00:36:30,540
everybody was using it for ech so we

954
00:36:30,540 --> 00:36:32,820
gave them an API to do that that takes

955
00:36:32,820 --> 00:36:36,480
bytes and this realizes them into a

956
00:36:36,480 --> 00:36:39,660
private key or a public key or abort and

957
00:36:39,660 --> 00:36:41,339
then takes a private key in a public key

958
00:36:41,339 --> 00:36:43,859
and does ecdh and gives you out the

959
00:36:43,859 --> 00:36:45,300
result

960
00:36:45,300 --> 00:36:48,780
there there is no even no way to ask the

961
00:36:48,780 --> 00:36:50,400
question what happens when one of the

962
00:36:50,400 --> 00:36:52,740
coordinates is negative with this one so

963
00:36:52,740 --> 00:36:55,859
that mistake just can't happen

964
00:36:55,859 --> 00:36:58,200
and even internally to implement that

965
00:36:58,200 --> 00:37:00,060
we're using an internal package which we

966
00:37:00,060 --> 00:37:01,560
don't expose to users because users

967
00:37:01,560 --> 00:37:04,380
mostly don't need it but nevertheless we

968
00:37:04,380 --> 00:37:08,160
made that safe too by using bytes and by

969
00:37:08,160 --> 00:37:10,740
this realizing into our opaque type for

970
00:37:10,740 --> 00:37:14,040
points and then doing things like scalar

971
00:37:14,040 --> 00:37:15,960
multiplication and addition over that

972
00:37:15,960 --> 00:37:17,820
opaque type

973
00:37:17,820 --> 00:37:20,280
one thing that I I want specification

974
00:37:20,280 --> 00:37:22,740
Outdoors to take away from this is that

975
00:37:22,740 --> 00:37:25,320
defining your high level apis in terms

976
00:37:25,320 --> 00:37:27,900
of the bytes really helps implementers

977
00:37:27,900 --> 00:37:30,300
not to expose apis that will cause

978
00:37:30,300 --> 00:37:33,119
issues I think that actually the most

979
00:37:33,119 --> 00:37:36,119
important contribution of x25519 was not

980
00:37:36,119 --> 00:37:38,339
the underlying curve which turned out

981
00:37:38,339 --> 00:37:39,900
ironically to be a little unsafe when

982
00:37:39,900 --> 00:37:42,300
used for their purposes but the fact

983
00:37:42,300 --> 00:37:44,220
that it was defined in terms of bytes

984
00:37:44,220 --> 00:37:47,760
nobody made an API that exposes the unv

985
00:37:47,760 --> 00:37:51,060
coordinate of a 25519 point

986
00:37:51,060 --> 00:37:54,300
instead the new specifications do invite

987
00:37:54,300 --> 00:37:57,300
you to talk in terms of coordinates and

988
00:37:57,300 --> 00:37:59,579
points and field elements and integers

989
00:37:59,579 --> 00:38:01,920
and so we did that

990
00:38:01,920 --> 00:38:06,240
so byte interfaces really help

991
00:38:06,240 --> 00:38:09,960
now you might ask why do you care so

992
00:38:09,960 --> 00:38:11,640
much about internal interfaces though

993
00:38:11,640 --> 00:38:13,200
you're not exposing those to users

994
00:38:13,200 --> 00:38:15,660
you're using them yourself and if I'm

995
00:38:15,660 --> 00:38:17,400
writing something I know I'm using it

996
00:38:17,400 --> 00:38:18,420
right

997
00:38:18,420 --> 00:38:20,339
well I like what Russ Cox says about

998
00:38:20,339 --> 00:38:22,079
software engineering software

999
00:38:22,079 --> 00:38:23,460
engineering is what happens to

1000
00:38:23,460 --> 00:38:25,980
programming when you add time and other

1001
00:38:25,980 --> 00:38:27,599
programmers

1002
00:38:27,599 --> 00:38:31,079
as time passes and yourself or other

1003
00:38:31,079 --> 00:38:33,540
people will move the code in your

1004
00:38:33,540 --> 00:38:36,420
library and will end up reusing those

1005
00:38:36,420 --> 00:38:38,760
interfaces and if those interfaces are

1006
00:38:38,760 --> 00:38:40,200
not safe even if they're internal

1007
00:38:40,200 --> 00:38:42,240
they're going to be used wrong and that

1008
00:38:42,240 --> 00:38:44,700
happened to us just last week when as

1009
00:38:44,700 --> 00:38:47,180
part of that rewrite we reused some old

1010
00:38:47,180 --> 00:38:50,400
assembly because it was really fast and

1011
00:38:50,400 --> 00:38:52,500
it turned out to have an expectation

1012
00:38:52,500 --> 00:38:54,960
that the scalar was reduced because it

1013
00:38:54,960 --> 00:38:57,119
was not using complete formulas

1014
00:38:57,119 --> 00:38:59,820
and the result was that it would fail

1015
00:38:59,820 --> 00:39:02,280
scar multiplication specifically for Q

1016
00:39:02,280 --> 00:39:04,079
Plus 30 which might be the weirdest

1017
00:39:04,079 --> 00:39:06,480
vulnerability I've ever had

1018
00:39:06,480 --> 00:39:09,599
anyway internal interfaces matter just

1019
00:39:09,599 --> 00:39:11,220
as much as the external interface as you

1020
00:39:11,220 --> 00:39:13,578
expose

1021
00:39:13,680 --> 00:39:15,900
still some code is so tricky that you

1022
00:39:15,900 --> 00:39:18,000
don't want to write it yourself

1023
00:39:18,000 --> 00:39:19,859
and we've had good luck with two code

1024
00:39:19,859 --> 00:39:22,200
generators one is the Fiat crypto

1025
00:39:22,200 --> 00:39:24,599
formally verified model and the other is

1026
00:39:24,599 --> 00:39:26,700
the Avo assembly generator by Michael

1027
00:39:26,700 --> 00:39:28,500
mclogan

1028
00:39:28,500 --> 00:39:31,560
Fiat crypto is a generates field

1029
00:39:31,560 --> 00:39:33,540
implementations from a formerly verified

1030
00:39:33,540 --> 00:39:36,119
model what's that Fiat crypto apart from

1031
00:39:36,119 --> 00:39:38,520
other formal verification projects is

1032
00:39:38,520 --> 00:39:41,339
that it generates go code that fits that

1033
00:39:41,339 --> 00:39:43,380
is not unlike the code I could have

1034
00:39:43,380 --> 00:39:44,640
written myself

1035
00:39:44,640 --> 00:39:47,820
it fits right next to my code it builds

1036
00:39:47,820 --> 00:39:50,880
with it it tests the same way and it

1037
00:39:50,880 --> 00:39:53,339
uses go types that I can use across my

1038
00:39:53,339 --> 00:39:55,140
implementation and that I can wrap in

1039
00:39:55,140 --> 00:39:57,240
apis that I like

1040
00:39:57,240 --> 00:40:00,060
and most importantly I understand that

1041
00:40:00,060 --> 00:40:02,520
the high level what its functions do so

1042
00:40:02,520 --> 00:40:04,200
that means that even if it was missing a

1043
00:40:04,200 --> 00:40:06,060
function or if I wanted to write a test

1044
00:40:06,060 --> 00:40:09,420
I could do that myself without relying

1045
00:40:09,420 --> 00:40:12,000
on the Upstream project in perpetuity

1046
00:40:12,000 --> 00:40:14,220
because when as maintainers are

1047
00:40:14,220 --> 00:40:15,900
considering adopting something like this

1048
00:40:15,900 --> 00:40:18,180
we're thinking what happens in 10 years

1049
00:40:18,180 --> 00:40:21,560
when I'm still maintaining this

1050
00:40:21,780 --> 00:40:24,420
Avo instead is something different Avo

1051
00:40:24,420 --> 00:40:27,599
is a way to write assembly in a way that

1052
00:40:27,599 --> 00:40:30,660
is much more ergonomic you can think of

1053
00:40:30,660 --> 00:40:35,520
it as macros but on steroids it allows

1054
00:40:35,520 --> 00:40:38,180
you to Define for example it does a

1055
00:40:38,180 --> 00:40:40,980
virtual register allocation it allows

1056
00:40:40,980 --> 00:40:42,359
you to do things like defining a type

1057
00:40:42,359 --> 00:40:45,240
for you in whether 128 which is to

1058
00:40:45,240 --> 00:40:47,280
register then use together and Define

1059
00:40:47,280 --> 00:40:49,920
functions over that this code when

1060
00:40:49,920 --> 00:40:51,599
you're when I'm using this function it's

1061
00:40:51,599 --> 00:40:53,339
much more readable than just sticking

1062
00:40:53,339 --> 00:40:57,060
more mole add at C in some in some

1063
00:40:57,060 --> 00:40:59,400
assembly file

1064
00:40:59,400 --> 00:41:01,740
so this really helped us with our

1065
00:41:01,740 --> 00:41:03,839
assembly but still the assembly is some

1066
00:41:03,839 --> 00:41:05,400
of the most dangerous code in our code

1067
00:41:05,400 --> 00:41:09,740
base and that's why we have a policy

1068
00:41:09,800 --> 00:41:12,420
and that's why we have a policy for

1069
00:41:12,420 --> 00:41:14,099
assembly that says that we want to

1070
00:41:14,099 --> 00:41:16,380
reduce assembly as much as possible that

1071
00:41:16,380 --> 00:41:18,480
we want assembly to have corresponding

1072
00:41:18,480 --> 00:41:20,400
go code that we can test side by side

1073
00:41:20,400 --> 00:41:23,040
and we want it to be small units that

1074
00:41:23,040 --> 00:41:24,720
can be easily understood and we want

1075
00:41:24,720 --> 00:41:26,160
them to be generated with things like

1076
00:41:26,160 --> 00:41:28,560
apple but that's not the only policy

1077
00:41:28,560 --> 00:41:31,619
that helps us here the reality is that

1078
00:41:31,619 --> 00:41:33,540
we are not 10 times better than anybody

1079
00:41:33,540 --> 00:41:35,839
else at

1080
00:41:36,000 --> 00:41:38,520
we try to reduce the complexity of the

1081
00:41:38,520 --> 00:41:41,400
job to one tenth of it so that we can

1082
00:41:41,400 --> 00:41:43,560
focus our resources on doing that path

1083
00:41:43,560 --> 00:41:44,820
really well

1084
00:41:44,820 --> 00:41:46,680
and that means for example not being

1085
00:41:46,680 --> 00:41:49,200
afraid of deprecating things that are

1086
00:41:49,200 --> 00:41:51,119
either not useful not worth their

1087
00:41:51,119 --> 00:41:54,119
sources anymore or have a dangerous API

1088
00:41:54,119 --> 00:41:57,060
we've recently deprecated our openpgp

1089
00:41:57,060 --> 00:41:58,619
package which is now a third-party

1090
00:41:58,619 --> 00:42:01,380
module much better maintained our DSA

1091
00:42:01,380 --> 00:42:05,820
package and then castified md4 txt two

1092
00:42:05,820 --> 00:42:07,680
fish no idea why some of that was in

1093
00:42:07,680 --> 00:42:08,940
there

1094
00:42:08,940 --> 00:42:11,520
now all of that is deprecated but not

1095
00:42:11,520 --> 00:42:13,560
removed because go has a strict

1096
00:42:13,560 --> 00:42:15,839
compatibility promise that says if a

1097
00:42:15,839 --> 00:42:17,880
program compiled and run correctly in

1098
00:42:17,880 --> 00:42:19,680
one version it will compile and run

1099
00:42:19,680 --> 00:42:21,420
correctly in the next version

1100
00:42:21,420 --> 00:42:24,119
that means that anything we accept we're

1101
00:42:24,119 --> 00:42:25,740
stuck with forever

1102
00:42:25,740 --> 00:42:28,740
I really like what Solomon Heights says

1103
00:42:28,740 --> 00:42:31,260
about open source noise temporary yes

1104
00:42:31,260 --> 00:42:32,880
it's forever

1105
00:42:32,880 --> 00:42:35,579
and that's why we take so much time in

1106
00:42:35,579 --> 00:42:37,260
figuring out what's the right way to add

1107
00:42:37,260 --> 00:42:38,940
something and should we add something

1108
00:42:38,940 --> 00:42:41,700
even when it's clear we should we still

1109
00:42:41,700 --> 00:42:43,560
take our time to figure out how to add

1110
00:42:43,560 --> 00:42:45,420
it correctly

1111
00:42:45,420 --> 00:42:47,700
and how do we decide what to add and

1112
00:42:47,700 --> 00:42:49,880
what to prioritize we've written down

1113
00:42:49,880 --> 00:42:53,040
the the goals of the go-kart standard

1114
00:42:53,040 --> 00:42:55,500
libraries these libraries are not for

1115
00:42:55,500 --> 00:42:57,780
winning benchmarking competitions and

1116
00:42:57,780 --> 00:42:59,280
the goal is not to implement the

1117
00:42:59,280 --> 00:43:01,560
totality of certain races

1118
00:43:01,560 --> 00:43:04,380
our goal is to make a secure tool for go

1119
00:43:04,380 --> 00:43:06,180
applications to write secure

1120
00:43:06,180 --> 00:43:07,740
applications

1121
00:43:07,740 --> 00:43:10,619
so in for that they need to be secure

1122
00:43:10,619 --> 00:43:14,040
safe practical and modern in that order

1123
00:43:14,040 --> 00:43:15,960
you may notice that performance is not

1124
00:43:15,960 --> 00:43:17,940
on there performance is a matter of

1125
00:43:17,940 --> 00:43:20,099
practicality if something is fast enough

1126
00:43:20,099 --> 00:43:21,900
it's practical it doesn't need to be

1127
00:43:21,900 --> 00:43:24,240
faster if it's not fast enough then it's

1128
00:43:24,240 --> 00:43:25,619
not practical then we need to make it

1129
00:43:25,619 --> 00:43:27,960
better but only if we can keep it safe

1130
00:43:27,960 --> 00:43:29,940
and secure

1131
00:43:29,940 --> 00:43:33,060
now finally the last thing which is the

1132
00:43:33,060 --> 00:43:35,460
fuzziest but at the same time the one

1133
00:43:35,460 --> 00:43:37,319
that maybe we invest the most time in

1134
00:43:37,319 --> 00:43:39,900
which is making sure that our call is

1135
00:43:39,900 --> 00:43:42,240
readable and easy to understand for

1136
00:43:42,240 --> 00:43:44,160
ourselves for our reviewers and for

1137
00:43:44,160 --> 00:43:45,720
researchers

1138
00:43:45,720 --> 00:43:47,599
you may think that cryptography is

1139
00:43:47,599 --> 00:43:50,760
complex but that's not an excuse for the

1140
00:43:50,760 --> 00:43:53,640
code itself to be obscure or complex

1141
00:43:53,640 --> 00:43:56,099
quite the opposite we are spending all

1142
00:43:56,099 --> 00:43:58,020
our complexity Budget on the subject

1143
00:43:58,020 --> 00:43:58,920
matter

1144
00:43:58,920 --> 00:44:01,440
so our code has to be exceedingly simple

1145
00:44:01,440 --> 00:44:03,180
and easy to read

1146
00:44:03,180 --> 00:44:05,900
because our subject matter is so complex

1147
00:44:05,900 --> 00:44:09,359
now this is not free this means that

1148
00:44:09,359 --> 00:44:11,460
sometimes it would be faster to unroll a

1149
00:44:11,460 --> 00:44:13,859
loop but more understandable to write it

1150
00:44:13,859 --> 00:44:16,200
as a for Loop and in that case most of

1151
00:44:16,200 --> 00:44:18,480
the time we will write as a for Loop and

1152
00:44:18,480 --> 00:44:20,160
leave five percent of performance on the

1153
00:44:20,160 --> 00:44:22,079
table because it makes it easier to

1154
00:44:22,079 --> 00:44:26,819
review maintain and check the code

1155
00:44:26,819 --> 00:44:28,380
so

1156
00:44:28,380 --> 00:44:31,319
this is what we do day to day to keep

1157
00:44:31,319 --> 00:44:34,619
the cryptography libraries safe but we

1158
00:44:34,619 --> 00:44:35,940
are not done and there are a number of

1159
00:44:35,940 --> 00:44:38,400
techniques we would like to use more

1160
00:44:38,400 --> 00:44:41,400
and we know will never be done I have

1161
00:44:41,400 --> 00:44:44,520
one last uh call for the researchers in

1162
00:44:44,520 --> 00:44:47,040
the room we very much like working with

1163
00:44:47,040 --> 00:44:48,960
researchers so you can reach out to me

1164
00:44:48,960 --> 00:44:51,660
at this email or to security golang.org

1165
00:44:51,660 --> 00:44:56,160
and I'll be happy to to help you get set

1166
00:44:56,160 --> 00:44:58,500
up so that you can test go alongside

1167
00:44:58,500 --> 00:45:00,240
with other libraries when you're doing

1168
00:45:00,240 --> 00:45:01,859
your surveys whether you're testing

1169
00:45:01,859 --> 00:45:04,020
protocols or low level primitive

1170
00:45:04,020 --> 00:45:05,220
implementations

1171
00:45:05,220 --> 00:45:06,480
thank you very much

1172
00:45:06,480 --> 00:45:10,880
[Applause]

1173
00:45:11,640 --> 00:45:14,460
thank you if there's one very quick

1174
00:45:14,460 --> 00:45:16,440
question if somebody's sprinting up to

1175
00:45:16,440 --> 00:45:18,119
the microphone okay then I will take it

1176
00:45:18,119 --> 00:45:20,280
by the way that URL is not live yet I

1177
00:45:20,280 --> 00:45:23,160
promise it will be yes so I just wanted

1178
00:45:23,160 --> 00:45:24,720
to ask something uh given your

1179
00:45:24,720 --> 00:45:26,160
experience with go you mentioned at the

1180
00:45:26,160 --> 00:45:28,619
start that uh the garbage collector

1181
00:45:28,619 --> 00:45:30,119
could actually provide us with more

1182
00:45:30,119 --> 00:45:33,000
guarantees and for safety and maintain

1183
00:45:33,000 --> 00:45:34,380
maintainability could you please

1184
00:45:34,380 --> 00:45:36,900
elaborate on that yes so the garbage

1185
00:45:36,900 --> 00:45:38,880
collector is one solution to temporal

1186
00:45:38,880 --> 00:45:42,420
memory safety so what uh about it is

1187
00:45:42,420 --> 00:45:44,280
what happens if you freeze some memory

1188
00:45:44,280 --> 00:45:46,859
and then try to reuse that pointer with

1189
00:45:46,859 --> 00:45:48,660
a garbage collector you can't have use

1190
00:45:48,660 --> 00:45:50,579
after free vulnerabilities because you

1191
00:45:50,579 --> 00:45:52,440
don't free manually your memory instead

1192
00:45:52,440 --> 00:45:55,200
the garbage collector scans the Heap and

1193
00:45:55,200 --> 00:45:56,760
say oh you're still using that I'm not

1194
00:45:56,760 --> 00:45:58,440
going to touch it and when it gets

1195
00:45:58,440 --> 00:45:59,940
garbage collected it's because nothing

1196
00:45:59,940 --> 00:46:02,940
else is using it anymore so this is one

1197
00:46:02,940 --> 00:46:05,339
way to solve it the other way which is

1198
00:46:05,339 --> 00:46:08,099
what Russ does is with uh borrow

1199
00:46:08,099 --> 00:46:11,640
checking and um uh

1200
00:46:11,640 --> 00:46:14,520
liveness analysis which is of course

1201
00:46:14,520 --> 00:46:17,099
requires more effort on the developer

1202
00:46:17,099 --> 00:46:18,720
side so this is a trade-off in terms of

1203
00:46:18,720 --> 00:46:21,119
developer productivity okay thanks thank

1204
00:46:21,119 --> 00:46:23,940
you all right then you're in the

1205
00:46:23,940 --> 00:46:25,380
interest of time I think we move further

1206
00:46:25,380 --> 00:46:27,119
questions also to the coffee break

1207
00:46:27,119 --> 00:46:28,680
because I'm really failing here to keep

1208
00:46:28,680 --> 00:46:31,560
that session on time

1209
00:46:31,560 --> 00:46:33,599
but

1210
00:46:33,599 --> 00:46:35,819
I tried

1211
00:46:35,819 --> 00:46:38,520
so then it's my my pleasure to announce

1212
00:46:38,520 --> 00:46:40,319
the the third and last speaker of the

1213
00:46:40,319 --> 00:46:41,460
session

1214
00:46:41,460 --> 00:46:43,380
um Joel Cooper who will be speaking

1215
00:46:43,380 --> 00:46:45,599
about cryptopt please drill the state is

1216
00:46:45,599 --> 00:46:47,760
yours thank you for Dean thank you for

1217
00:46:47,760 --> 00:46:48,900
the introduction

1218
00:46:48,900 --> 00:46:51,240
how does that work okay

1219
00:46:51,240 --> 00:46:52,680
um I would like to talk about cryptop

1220
00:46:52,680 --> 00:46:54,540
which is yet another approach or our

1221
00:46:54,540 --> 00:46:56,280
approach to generate high performance

1222
00:46:56,280 --> 00:46:59,579
assembly with machine check proofs this

1223
00:46:59,579 --> 00:47:01,260
is a collaboration across many

1224
00:47:01,260 --> 00:47:03,720
universities you can read them yourself

1225
00:47:03,720 --> 00:47:06,300
okay I would like to start with pointing

1226
00:47:06,300 --> 00:47:08,579
out the challenges challenges that we

1227
00:47:08,579 --> 00:47:11,099
that we face when uh writing

1228
00:47:11,099 --> 00:47:12,599
cryptographic code

1229
00:47:12,599 --> 00:47:14,700
so cryptographic code of course must be

1230
00:47:14,700 --> 00:47:16,740
efficient and secure and the traditional

1231
00:47:16,740 --> 00:47:18,960
approach to do that is to hand optimize

1232
00:47:18,960 --> 00:47:20,760
the core and being super careful that we

1233
00:47:20,760 --> 00:47:23,220
don't introduce any bugs

1234
00:47:23,220 --> 00:47:25,859
now this is bad for two main reasons

1235
00:47:25,859 --> 00:47:28,200
first it's labor intensive work that

1236
00:47:28,200 --> 00:47:30,000
needs to be done by domain experts which

1237
00:47:30,000 --> 00:47:32,520
makes it very expensive and the second

1238
00:47:32,520 --> 00:47:35,280
big problem is that it's Error prone

1239
00:47:35,280 --> 00:47:38,579
and in fact I would like to cite Tomar

1240
00:47:38,579 --> 00:47:42,180
on this one he said in the pqc Forum the

1241
00:47:42,180 --> 00:47:43,859
fact that these bugs existed in the

1242
00:47:43,859 --> 00:47:45,780
first place shows that the traditional

1243
00:47:45,780 --> 00:47:47,640
development mythology that is being

1244
00:47:47,640 --> 00:47:50,040
super careful has failed

1245
00:47:50,040 --> 00:47:52,140
and this is exactly what motivator does

1246
00:47:52,140 --> 00:47:53,700
as well we want

1247
00:47:53,700 --> 00:47:56,280
an automatic way to generate fast code

1248
00:47:56,280 --> 00:47:58,619
and we want machine check proofs for

1249
00:47:58,619 --> 00:48:01,220
their correctness

1250
00:48:02,700 --> 00:48:05,880
let's look at cryptographic code from a

1251
00:48:05,880 --> 00:48:07,980
use reusability and performance

1252
00:48:07,980 --> 00:48:09,660
perspective on the lower right hand

1253
00:48:09,660 --> 00:48:12,119
corner we have just generic C code which

1254
00:48:12,119 --> 00:48:14,220
is rather easy to use but the

1255
00:48:14,220 --> 00:48:16,920
performance is not exactly what we want

1256
00:48:16,920 --> 00:48:19,280
we can improve the performance by

1257
00:48:19,280 --> 00:48:21,900
specifying the C code with some

1258
00:48:21,900 --> 00:48:24,060
parameters that we use for certain use

1259
00:48:24,060 --> 00:48:27,000
cases and we can tune it a little it a

1260
00:48:27,000 --> 00:48:29,040
little bit more if we take into account

1261
00:48:29,040 --> 00:48:31,200
on which CPU it will run

1262
00:48:31,200 --> 00:48:33,000
the highest performance we currently get

1263
00:48:33,000 --> 00:48:36,060
with a handwritten assembly which

1264
00:48:36,060 --> 00:48:38,099
gives us the highest performance but we

1265
00:48:38,099 --> 00:48:40,079
need to do that all over again for every

1266
00:48:40,079 --> 00:48:42,119
architecture that we would like to run

1267
00:48:42,119 --> 00:48:43,380
on

1268
00:48:43,380 --> 00:48:45,660
not only does the first three approaches

1269
00:48:45,660 --> 00:48:47,220
not give us the performance that we want

1270
00:48:47,220 --> 00:48:49,619
we also need to trust the entire C

1271
00:48:49,619 --> 00:48:51,839
compiler tool chain whereas for the

1272
00:48:51,839 --> 00:48:52,920
handwritten assembly we have different

1273
00:48:52,920 --> 00:48:55,140
tools to check their correctness

1274
00:48:55,140 --> 00:48:56,880
with our two equipped opt we're trying

1275
00:48:56,880 --> 00:48:58,740
to push that Pareto front to the upper

1276
00:48:58,740 --> 00:49:00,960
right hand corner and we think that

1277
00:49:00,960 --> 00:49:03,119
we'll land it somewhere here

1278
00:49:03,119 --> 00:49:06,000
generating a code that is comparable

1279
00:49:06,000 --> 00:49:07,680
with handwritten assembly

1280
00:49:07,680 --> 00:49:09,780
rather easy to use and we have a very

1281
00:49:09,780 --> 00:49:12,980
small trusted Computing base

1282
00:49:13,380 --> 00:49:15,540
now our idea is based on two main

1283
00:49:15,540 --> 00:49:17,579
observations compilers are good for

1284
00:49:17,579 --> 00:49:19,440
general purpose code and they're doing a

1285
00:49:19,440 --> 00:49:21,900
great job of that but cryptographic code

1286
00:49:21,900 --> 00:49:24,240
is a little bit of a special snowflake

1287
00:49:24,240 --> 00:49:26,760
and with that I mean that there are not

1288
00:49:26,760 --> 00:49:29,099
more complex than general purpose code

1289
00:49:29,099 --> 00:49:31,920
in fact they're actually much simpler

1290
00:49:31,920 --> 00:49:34,800
and where general purpose code has a lot

1291
00:49:34,800 --> 00:49:36,839
of control flow cryptographic code tends

1292
00:49:36,839 --> 00:49:38,280
to have long stretches of straight line

1293
00:49:38,280 --> 00:49:39,240
code

1294
00:49:39,240 --> 00:49:41,220
which makes it hard for compilers to

1295
00:49:41,220 --> 00:49:42,780
optimize it

1296
00:49:42,780 --> 00:49:44,940
and we would like to use that property

1297
00:49:44,940 --> 00:49:46,920
of large stretches of straight line code

1298
00:49:46,920 --> 00:49:50,220
to our advantage and the idea is instead

1299
00:49:50,220 --> 00:49:52,200
of compiling two a fast implementation

1300
00:49:52,200 --> 00:49:53,940
we want to search for a fast

1301
00:49:53,940 --> 00:49:55,140
implementation

1302
00:49:55,140 --> 00:49:56,579
and once we have found that fast

1303
00:49:56,579 --> 00:49:58,380
implementation we then want to prove it

1304
00:49:58,380 --> 00:49:59,880
correct

1305
00:49:59,880 --> 00:50:02,040
now I'm going into detail on how we find

1306
00:50:02,040 --> 00:50:04,079
that fast solution and how we and then

1307
00:50:04,079 --> 00:50:08,280
quickly sketch how we prove that correct

1308
00:50:08,280 --> 00:50:13,579
so our search is based on a very simple

1309
00:50:13,579 --> 00:50:16,500
simple practice that a first year

1310
00:50:16,500 --> 00:50:18,240
student would do as well we would start

1311
00:50:18,240 --> 00:50:20,280
off writing some code which gets the job

1312
00:50:20,280 --> 00:50:22,740
done correctly and then we start

1313
00:50:22,740 --> 00:50:25,859
randomly modifying the code on uh we're

1314
00:50:25,859 --> 00:50:28,020
trying to achieve better performance

1315
00:50:28,020 --> 00:50:30,480
we then check whether the modification

1316
00:50:30,480 --> 00:50:32,520
did any good whether the result is

1317
00:50:32,520 --> 00:50:34,920
faster and if it is then we continue

1318
00:50:34,920 --> 00:50:37,020
doing that modifying it at different

1319
00:50:37,020 --> 00:50:38,040
spots

1320
00:50:38,040 --> 00:50:40,500
if that modification turned out to be to

1321
00:50:40,500 --> 00:50:42,660
be bad then we undo our last

1322
00:50:42,660 --> 00:50:44,780
modification and

1323
00:50:44,780 --> 00:50:48,180
try modifying somewhere different

1324
00:50:48,180 --> 00:50:49,980
now this approach has a professional

1325
00:50:49,980 --> 00:50:51,599
name and we call it random local search

1326
00:50:51,599 --> 00:50:54,480
we start somewhere random and we then

1327
00:50:54,480 --> 00:50:56,339
randomly explore that neighborhood for

1328
00:50:56,339 --> 00:50:57,839
better implementations

1329
00:50:57,839 --> 00:51:00,180
with our tool cryptopt

1330
00:51:00,180 --> 00:51:02,700
we are automating this approach

1331
00:51:02,700 --> 00:51:04,260
and to

1332
00:51:04,260 --> 00:51:06,059
make it a little bit more tangible on

1333
00:51:06,059 --> 00:51:07,920
how we write and how we modify code I

1334
00:51:07,920 --> 00:51:09,720
brought an example

1335
00:51:09,720 --> 00:51:12,900
in this example we are trying to compute

1336
00:51:12,900 --> 00:51:16,140
the expression above X Plus y times Z

1337
00:51:16,140 --> 00:51:18,359
Plus Z squared

1338
00:51:18,359 --> 00:51:20,280
so we have our Optimizer on the left

1339
00:51:20,280 --> 00:51:22,500
side and the first step is to write some

1340
00:51:22,500 --> 00:51:24,960
code so let's write some code

1341
00:51:24,960 --> 00:51:28,079
we have our values X Y and Z somewhere

1342
00:51:28,079 --> 00:51:31,260
in memory we take X and Y

1343
00:51:31,260 --> 00:51:35,099
add them together and multiply it by Z

1344
00:51:35,099 --> 00:51:37,680
we then compute mult uh we then compute

1345
00:51:37,680 --> 00:51:40,800
Z squared and add all the results or add

1346
00:51:40,800 --> 00:51:43,500
all the results together

1347
00:51:43,500 --> 00:51:47,339
now we have decided on one particular

1348
00:51:47,339 --> 00:51:50,460
order of operations now everybody who

1349
00:51:50,460 --> 00:51:52,559
has ever touched any assembly code for

1350
00:51:52,559 --> 00:51:55,319
Intel knows that there is not only one

1351
00:51:55,319 --> 00:51:57,119
instruction to do anything there's

1352
00:51:57,119 --> 00:51:58,319
multiple

1353
00:51:58,319 --> 00:52:00,660
so we need to decide on which

1354
00:52:00,660 --> 00:52:02,400
instruction we actually want to use to

1355
00:52:02,400 --> 00:52:04,260
implement this operation and we do that

1356
00:52:04,260 --> 00:52:06,540
by attaching these instruction templates

1357
00:52:06,540 --> 00:52:10,279
to the operations that we want to use

1358
00:52:10,319 --> 00:52:12,359
then to actually generate the code we

1359
00:52:12,359 --> 00:52:15,000
just read from top to bottom gluing

1360
00:52:15,000 --> 00:52:16,980
these templates together with some glue

1361
00:52:16,980 --> 00:52:18,720
which glues them into context so for

1362
00:52:18,720 --> 00:52:21,119
example we see that blue adcx template

1363
00:52:21,119 --> 00:52:22,619
and we glue that into the current

1364
00:52:22,619 --> 00:52:24,660
context with the black instructions we

1365
00:52:24,660 --> 00:52:27,420
do the same for the multiplication

1366
00:52:27,420 --> 00:52:31,140
and with the other operations as well so

1367
00:52:31,140 --> 00:52:33,119
now that we have our code our Optimizer

1368
00:52:33,119 --> 00:52:35,220
sets we need to now modify the code

1369
00:52:35,220 --> 00:52:37,619
and we can modify the code in two

1370
00:52:37,619 --> 00:52:40,500
different ways first we can reorder them

1371
00:52:40,500 --> 00:52:43,260
and change the instruction order

1372
00:52:43,260 --> 00:52:46,260
and the second is the is that we can

1373
00:52:46,260 --> 00:52:47,520
change the template that we're using

1374
00:52:47,520 --> 00:52:49,740
let's start with reordering

1375
00:52:49,740 --> 00:52:52,319
we can reorder all the operations when

1376
00:52:52,319 --> 00:52:54,059
they don't have any data dependencies

1377
00:52:54,059 --> 00:52:56,280
and we see that in that graph if there's

1378
00:52:56,280 --> 00:52:58,920
no gray Arrow between them so for

1379
00:52:58,920 --> 00:53:00,540
example we see that these two

1380
00:53:00,540 --> 00:53:02,460
multiplication operations don't share

1381
00:53:02,460 --> 00:53:04,859
any data so we can reorder them so let's

1382
00:53:04,859 --> 00:53:07,079
swap them around such that the red

1383
00:53:07,079 --> 00:53:10,020
multiplication is at the bottom and we

1384
00:53:10,020 --> 00:53:12,300
see that the code changes a little bit

1385
00:53:12,300 --> 00:53:14,760
now or Optimizer on the left side says

1386
00:53:14,760 --> 00:53:16,260
that we now need to check whether it's

1387
00:53:16,260 --> 00:53:18,780
faster and for that we actually run the

1388
00:53:18,780 --> 00:53:20,280
code on the hardware that we're trying

1389
00:53:20,280 --> 00:53:21,660
to optimize for

1390
00:53:21,660 --> 00:53:24,480
and see whether it's faster

1391
00:53:24,480 --> 00:53:26,520
and

1392
00:53:26,520 --> 00:53:29,220
in this case our result says it's faster

1393
00:53:29,220 --> 00:53:31,740
so we can keep modifying the code let's

1394
00:53:31,740 --> 00:53:35,299
now try to change the template

1395
00:53:35,460 --> 00:53:39,059
the optimizer will choose a operation at

1396
00:53:39,059 --> 00:53:41,940
random in this case the the first add

1397
00:53:41,940 --> 00:53:44,220
operation and change that template from

1398
00:53:44,220 --> 00:53:47,220
adcx to the add instruction so we see

1399
00:53:47,220 --> 00:53:49,680
that the assembly code changed a little

1400
00:53:49,680 --> 00:53:52,500
bit and now the next step is to check

1401
00:53:52,500 --> 00:53:55,760
whether it's faster and so on

1402
00:53:57,059 --> 00:53:59,460
if we do that many many times a

1403
00:53:59,460 --> 00:54:00,780
performance graph looks a little bit

1404
00:54:00,780 --> 00:54:03,300
like this we see the attempted

1405
00:54:03,300 --> 00:54:05,640
modifications on the x-axis and the

1406
00:54:05,640 --> 00:54:08,220
speed up of a GCC of the shaft compiler

1407
00:54:08,220 --> 00:54:10,500
on the y-axis we start off a little bit

1408
00:54:10,500 --> 00:54:13,200
slower than the than GCC but we end up

1409
00:54:13,200 --> 00:54:15,480
with a performance speed up of 1.6

1410
00:54:15,480 --> 00:54:17,339
around that

1411
00:54:17,339 --> 00:54:20,099
so now that we have our our Optimizer we

1412
00:54:20,099 --> 00:54:22,559
need to feed feed that with input

1413
00:54:22,559 --> 00:54:24,540
functions and for that I would like to

1414
00:54:24,540 --> 00:54:26,819
go back to the year 2019 as we have

1415
00:54:26,819 --> 00:54:29,099
heard this is not the year before covert

1416
00:54:29,099 --> 00:54:30,420
this is the year in which Fiat

1417
00:54:30,420 --> 00:54:32,640
cryptography got introduced

1418
00:54:32,640 --> 00:54:35,099
via cryptography for the ones that um

1419
00:54:35,099 --> 00:54:38,220
don't know is a framework to generate

1420
00:54:38,220 --> 00:54:39,900
cryptographic proven correct

1421
00:54:39,900 --> 00:54:43,619
cryptographic field arithmetic it does

1422
00:54:43,619 --> 00:54:45,540
that by using a functional program and

1423
00:54:45,540 --> 00:54:47,819
specifying the parameters

1424
00:54:47,819 --> 00:54:49,980
now we have field cryptography on the

1425
00:54:49,980 --> 00:54:51,720
left side and our Optimizer on the right

1426
00:54:51,720 --> 00:54:52,680
side

1427
00:54:52,680 --> 00:54:54,480
we then take the intermediate

1428
00:54:54,480 --> 00:54:56,760
representation from Fiat into our

1429
00:54:56,760 --> 00:54:58,140
optimizer

1430
00:54:58,140 --> 00:55:01,079
and out comes fast assembly

1431
00:55:01,079 --> 00:55:03,900
so Fiat cryptography generates code for

1432
00:55:03,900 --> 00:55:06,059
many different fields so we see them on

1433
00:55:06,059 --> 00:55:08,819
the left side philippo you can just

1434
00:55:08,819 --> 00:55:11,040
cross out the P2 to 4 because no one's

1435
00:55:11,040 --> 00:55:12,480
using it

1436
00:55:12,480 --> 00:55:13,500
um

1437
00:55:13,500 --> 00:55:15,240
so what we've done we've done we have

1438
00:55:15,240 --> 00:55:17,280
generated code for all of these

1439
00:55:17,280 --> 00:55:18,900
Primitives for the multiply and square

1440
00:55:18,900 --> 00:55:21,780
operations and run that on 10 vastly

1441
00:55:21,780 --> 00:55:23,760
different micro architectures

1442
00:55:23,760 --> 00:55:26,220
so if we compare that against Klang and

1443
00:55:26,220 --> 00:55:28,920
GCC we see a couple numbers here and

1444
00:55:28,920 --> 00:55:31,440
1.19 in this case means for example that

1445
00:55:31,440 --> 00:55:34,980
the code that crypto produces

1446
00:55:34,980 --> 00:55:38,040
um only into 100 Cycles whereas code

1447
00:55:38,040 --> 00:55:40,819
that clunk produces uses

1448
00:55:40,819 --> 00:55:44,220
1.19 times as many so 119 if I do the

1449
00:55:44,220 --> 00:55:46,140
math correct if we fill up the rest of

1450
00:55:46,140 --> 00:55:47,460
the table we see that the trend

1451
00:55:47,460 --> 00:55:49,559
continues higher numbers are better and

1452
00:55:49,559 --> 00:55:52,079
crypto can generate faster code for most

1453
00:55:52,079 --> 00:55:55,500
of these functions

1454
00:55:55,500 --> 00:55:56,880
so far we have just talked about the

1455
00:55:56,880 --> 00:55:59,000
field arithmetic but in the real world

1456
00:55:59,000 --> 00:56:02,460
cryptography we actually need a little

1457
00:56:02,460 --> 00:56:04,800
bit more than just feed arithmetic

1458
00:56:04,800 --> 00:56:07,500
a dominant in many cryptographic schemes

1459
00:56:07,500 --> 00:56:09,660
the dominant operation is the scalar

1460
00:56:09,660 --> 00:56:11,700
multiplication which is performance wise

1461
00:56:11,700 --> 00:56:13,619
dominated by the field of arithmetic

1462
00:56:13,619 --> 00:56:15,839
that we have just optimized so let's

1463
00:56:15,839 --> 00:56:17,880
look at the scalar multiplication

1464
00:56:17,880 --> 00:56:21,059
on this graph we see an example for

1465
00:56:21,059 --> 00:56:23,520
curve 25519 we see a bunch of different

1466
00:56:23,520 --> 00:56:25,619
implementations on the x-axis and I

1467
00:56:25,619 --> 00:56:26,880
would like to draw the intention on the

1468
00:56:26,880 --> 00:56:27,960
right hand side

1469
00:56:27,960 --> 00:56:31,020
the black columns are the

1470
00:56:31,020 --> 00:56:32,839
off the shelf

1471
00:56:32,839 --> 00:56:35,099
assembly implementations in Optimus SL

1472
00:56:35,099 --> 00:56:38,760
and the blue columns indicate that we

1473
00:56:38,760 --> 00:56:41,160
have replaced that hand optimized field

1474
00:56:41,160 --> 00:56:45,059
arithmetic field assembly inside of that

1475
00:56:45,059 --> 00:56:47,460
library with the code that we have just

1476
00:56:47,460 --> 00:56:49,859
generated and optimized and we see that

1477
00:56:49,859 --> 00:56:52,380
we are roughly on par

1478
00:56:52,380 --> 00:56:54,540
on top of that chart it says geometric

1479
00:56:54,540 --> 00:56:56,339
mean so this is what we were able to

1480
00:56:56,339 --> 00:56:58,079
generate across all of these

1481
00:56:58,079 --> 00:57:00,359
architectures if we look at just new

1482
00:57:00,359 --> 00:57:02,339
architectures for example the Intel 12th

1483
00:57:02,339 --> 00:57:03,960
generation we see that we're actually

1484
00:57:03,960 --> 00:57:06,780
beating the performance of the hand

1485
00:57:06,780 --> 00:57:08,460
tuned assembly inside of that library

1486
00:57:08,460 --> 00:57:10,920
and that Trend continues for the did you

1487
00:57:10,920 --> 00:57:12,059
see that

1488
00:57:12,059 --> 00:57:14,880
pretty much the same for the 13th

1489
00:57:14,880 --> 00:57:16,980
generation and that actually ties in

1490
00:57:16,980 --> 00:57:20,960
with our with our observation that

1491
00:57:20,960 --> 00:57:23,339
that compilers need to adapt to new

1492
00:57:23,339 --> 00:57:25,440
micro architectures whereas for our

1493
00:57:25,440 --> 00:57:26,760
approach we just run it on the new

1494
00:57:26,760 --> 00:57:28,920
hardware and our Optimizer will then

1495
00:57:28,920 --> 00:57:30,839
randomly find the things that it needs

1496
00:57:30,839 --> 00:57:33,180
to find out in order to generate

1497
00:57:33,180 --> 00:57:35,280
fast code

1498
00:57:35,280 --> 00:57:36,660
so

1499
00:57:36,660 --> 00:57:39,240
now we have our first code but how about

1500
00:57:39,240 --> 00:57:41,220
correctness so if we come back to this

1501
00:57:41,220 --> 00:57:45,059
graph we see that we generated a fast

1502
00:57:45,059 --> 00:57:46,079
assembly

1503
00:57:46,079 --> 00:57:48,540
now part of our work is also a verified

1504
00:57:48,540 --> 00:57:51,240
Checker this Checker gets two inputs

1505
00:57:51,240 --> 00:57:54,359
once on the on the one hand there's the

1506
00:57:54,359 --> 00:57:56,520
Fiat ir and on the other side is the

1507
00:57:56,520 --> 00:57:57,839
assembly

1508
00:57:57,839 --> 00:58:00,059
let's check it now contains two symbolic

1509
00:58:00,059 --> 00:58:02,460
execution engines one for the Fiat ir

1510
00:58:02,460 --> 00:58:04,859
and one for the assembly

1511
00:58:04,859 --> 00:58:07,440
now it's just a matter of symbolically

1512
00:58:07,440 --> 00:58:09,300
executing these two programs and check

1513
00:58:09,300 --> 00:58:11,099
whether the output is equivalent and if

1514
00:58:11,099 --> 00:58:13,020
it is then the assembly indeed

1515
00:58:13,020 --> 00:58:15,359
implements the specification that we've

1516
00:58:15,359 --> 00:58:16,500
started with

1517
00:58:16,500 --> 00:58:18,480
important to note on this slide is that

1518
00:58:18,480 --> 00:58:20,339
everything which is not the optimizer is

1519
00:58:20,339 --> 00:58:22,740
formally verified written in proven

1520
00:58:22,740 --> 00:58:25,459
once and for all

1521
00:58:25,500 --> 00:58:27,720
and this brings me to my little summary

1522
00:58:27,720 --> 00:58:29,940
we started off with the fact that we

1523
00:58:29,940 --> 00:58:31,619
instead of compiling cryptographic code

1524
00:58:31,619 --> 00:58:34,500
we are searching for cryptographic code

1525
00:58:34,500 --> 00:58:37,020
we then use a local random local search

1526
00:58:37,020 --> 00:58:39,480
heuristic and the actual runtime to

1527
00:58:39,480 --> 00:58:40,980
improve the performance

1528
00:58:40,980 --> 00:58:43,920
and it bottoms out at provably correct

1529
00:58:43,920 --> 00:58:45,540
assembly for the field arithmetic that

1530
00:58:45,540 --> 00:58:47,400
Fiat cryptography produces now with

1531
00:58:47,400 --> 00:58:50,520
on-par performance uh on par performance

1532
00:58:50,520 --> 00:58:52,920
to hand optimized assembly

1533
00:58:52,920 --> 00:58:54,540
if that sounds interesting to you and

1534
00:58:54,540 --> 00:58:55,559
you have something that you would like

1535
00:58:55,559 --> 00:58:58,020
to optimize you can

1536
00:58:58,020 --> 00:59:01,260
go ahead to our crypto to our GitHub

1537
00:59:01,260 --> 00:59:03,119
project try it out yourself tell me if

1538
00:59:03,119 --> 00:59:05,460
it's working and if it's not working you

1539
00:59:05,460 --> 00:59:07,619
can find a bug report and with that I

1540
00:59:07,619 --> 00:59:09,420
would like to go on to the questions or

1541
00:59:09,420 --> 00:59:12,619
to the coffee thank you

1542
00:59:16,079 --> 00:59:18,359
thanks thank you so much for bringing us

1543
00:59:18,359 --> 00:59:19,859
back on schedule and there's the first

1544
00:59:19,859 --> 00:59:22,859
question directly by Nigel hi um so your

1545
00:59:22,859 --> 00:59:25,020
example I could see how you could do

1546
00:59:25,020 --> 00:59:27,000
local optimizations on the assembly

1547
00:59:27,000 --> 00:59:28,140
because that would take different

1548
00:59:28,140 --> 00:59:29,880
accounts of the different pipelines on

1549
00:59:29,880 --> 00:59:31,319
the processor and stuff like that but

1550
00:59:31,319 --> 00:59:34,619
the obvious optimization is to work on

1551
00:59:34,619 --> 00:59:36,540
the graph and just put a different

1552
00:59:36,540 --> 00:59:40,380
formula in X Plus z y plus Z times Z

1553
00:59:40,380 --> 00:59:42,720
so it would remove the multiplication in

1554
00:59:42,720 --> 00:59:45,420
Thailand I don't see how your code your

1555
00:59:45,420 --> 00:59:47,220
your local optimization would actually

1556
00:59:47,220 --> 00:59:50,040
remove the the two multiplications down

1557
00:59:50,040 --> 00:59:52,020
to one yes thank you

1558
00:59:52,020 --> 00:59:54,359
um this was just a toy example to

1559
00:59:54,359 --> 00:59:59,040
um to see how we can change the code

1560
00:59:59,040 --> 01:00:00,960
that is we change the operation order

1561
01:00:00,960 --> 01:00:03,299
instruction scheduling and the

1562
01:00:03,299 --> 01:00:04,619
instruction templates that we're using

1563
01:00:04,619 --> 01:00:08,280
in the real world these

1564
01:00:08,280 --> 01:00:09,839
um templates come from Fiat cryptography

1565
01:00:09,839 --> 01:00:12,420
and they are already optimized So

1566
01:00:12,420 --> 01:00:14,040
currently we're just changing these uh

1567
01:00:14,040 --> 01:00:16,140
two things and we experimented a little

1568
01:00:16,140 --> 01:00:18,960
bit with strength strength reduction but

1569
01:00:18,960 --> 01:00:21,480
we don't change the arithmetic

1570
01:00:21,480 --> 01:00:22,859
expression itself

1571
01:00:22,859 --> 01:00:25,880
does that answer the question

1572
01:00:28,200 --> 01:00:32,299
yeah on this toy example yes but

1573
01:00:40,980 --> 01:00:42,960
yes but we're starting already with very

1574
01:00:42,960 --> 01:00:43,920
efficient

1575
01:00:43,920 --> 01:00:45,980
um

1576
01:00:46,140 --> 01:00:47,819
yeah so we have different implementation

1577
01:00:47,819 --> 01:00:50,220
strategies based on the prime which is

1578
01:00:50,220 --> 01:00:53,040
the most sensible Prime

1579
01:00:53,040 --> 01:00:54,839
okay thank you

1580
01:00:54,839 --> 01:00:57,299
I just wanted to ask if the heuristic

1581
01:00:57,299 --> 01:00:59,700
you use to optimize is uh architecture

1582
01:00:59,700 --> 01:01:02,700
specific so does can you plug in another

1583
01:01:02,700 --> 01:01:04,380
architecture with probably different

1584
01:01:04,380 --> 01:01:05,940
instructions and it would work with your

1585
01:01:05,940 --> 01:01:09,119
software or is it just for Intel or yeah

1586
01:01:09,119 --> 01:01:12,299
and so we found that our optimizations

1587
01:01:12,299 --> 01:01:14,460
are very architecture specific which is

1588
01:01:14,460 --> 01:01:16,980
a double-edged sport so we can ex really

1589
01:01:16,980 --> 01:01:19,200
exploit the really micro architectural

1590
01:01:19,200 --> 01:01:21,720
performance whatever they use whatever

1591
01:01:21,720 --> 01:01:23,220
they do

1592
01:01:23,220 --> 01:01:25,140
um but it then will run a little bit

1593
01:01:25,140 --> 01:01:27,240
slower than what we would able would be

1594
01:01:27,240 --> 01:01:29,579
able to optimize however we saw on the

1595
01:01:29,579 --> 01:01:32,040
um on the mean for all the machines that

1596
01:01:32,040 --> 01:01:35,099
we run on we still get hand optimized we

1597
01:01:35,099 --> 01:01:37,799
get performance close to the hand

1598
01:01:37,799 --> 01:01:40,079
optimized versions does that answer the

1599
01:01:40,079 --> 01:01:43,079
question yeah yeah okay thanks

1600
01:01:43,079 --> 01:01:45,299
related to the previous question

1601
01:01:45,299 --> 01:01:48,240
um how many architectures do you support

1602
01:01:48,240 --> 01:01:50,700
like compared to a regular compiler okay

1603
01:01:50,700 --> 01:01:53,819
we currently focus on the Intel x86 and

1604
01:01:53,819 --> 01:01:55,619
that is pretty much it that's it okay

1605
01:01:55,619 --> 01:01:59,640
yeah so that is our Isa where but we

1606
01:01:59,640 --> 01:02:00,839
support every

1607
01:02:00,839 --> 01:02:04,140
um every com every CPU that supports Isa

1608
01:02:04,140 --> 01:02:06,720
X Intel x86 okay

1609
01:02:06,720 --> 01:02:08,880
um can I ask a second question or are we

1610
01:02:08,880 --> 01:02:11,160
gonna go ahead okay how much effort

1611
01:02:11,160 --> 01:02:13,440
would it be to Port a new platform is

1612
01:02:13,440 --> 01:02:16,920
actually D6 baked into cryptopt or is it

1613
01:02:16,920 --> 01:02:20,400
like easy to just say well let's add arm

1614
01:02:20,400 --> 01:02:24,140
cortex M4 for example so

1615
01:02:24,140 --> 01:02:28,260
the main difference is the vast majority

1616
01:02:28,260 --> 01:02:30,480
the vast just Murad of different

1617
01:02:30,480 --> 01:02:33,359
instructions through one thing and they

1618
01:02:33,359 --> 01:02:34,920
we found that many different

1619
01:02:34,920 --> 01:02:36,299
instructions tend to have different

1620
01:02:36,299 --> 01:02:38,460
impacts on the performance for arm we

1621
01:02:38,460 --> 01:02:40,260
don't expect that much of a performance

1622
01:02:40,260 --> 01:02:42,059
boost because there's just an ad

1623
01:02:42,059 --> 01:02:45,200
instruction on ad with carry instruction

1624
01:02:45,200 --> 01:02:47,160
so we

1625
01:02:47,160 --> 01:02:49,799
could implement the arms back into that

1626
01:02:49,799 --> 01:02:52,380
but we don't expect that much of a

1627
01:02:52,380 --> 01:02:54,540
performance increase okay but if you

1628
01:02:54,540 --> 01:02:56,460
want to help doing that then reach out

1629
01:02:56,460 --> 01:02:58,880
thanks

1630
01:02:59,040 --> 01:03:00,839
the uh

1631
01:03:00,839 --> 01:03:02,940
the algorithm you used for whether or

1632
01:03:02,940 --> 01:03:06,359
not you accept a random substitution

1633
01:03:06,359 --> 01:03:08,460
that you've made implies that if there's

1634
01:03:08,460 --> 01:03:10,680
a performance decrease you abandon that

1635
01:03:10,680 --> 01:03:12,720
wouldn't you be hitting a local minimum

1636
01:03:12,720 --> 01:03:14,579
with that can you maybe about the graph

1637
01:03:14,579 --> 01:03:16,680
that you had showed that it went down

1638
01:03:16,680 --> 01:03:18,480
sometimes as well could you maybe expand

1639
01:03:18,480 --> 01:03:21,299
on the uh on the optimization algorithm

1640
01:03:21,299 --> 01:03:25,760
you're using okay so actually we accept

1641
01:03:25,760 --> 01:03:28,200
modifications that do not decrease the

1642
01:03:28,200 --> 01:03:30,059
performance but it was better in the

1643
01:03:30,059 --> 01:03:32,099
slides to say if it's faster

1644
01:03:32,099 --> 01:03:33,599
um in the optimization sphere like

1645
01:03:33,599 --> 01:03:35,040
there's also like simulated annealing

1646
01:03:35,040 --> 01:03:36,960
where sometimes you just accept one even

1647
01:03:36,960 --> 01:03:38,640
though it is worse because maybe it'll

1648
01:03:38,640 --> 01:03:40,440
lead to overall better in the long run

1649
01:03:40,440 --> 01:03:43,319
yes another important thing to say is

1650
01:03:43,319 --> 01:03:45,299
that the performance measurements are

1651
01:03:45,299 --> 01:03:47,400
actually fluctuating based on whatever's

1652
01:03:47,400 --> 01:03:49,380
running on the machine and that if you

1653
01:03:49,380 --> 01:03:51,240
run something now and a second later

1654
01:03:51,240 --> 01:03:53,819
it's not the same so we do have some

1655
01:03:53,819 --> 01:03:57,180
uncertainty in our judgments anyway but

1656
01:03:57,180 --> 01:04:00,000
we saw over time that

1657
01:04:00,000 --> 01:04:02,160
over time the performance increases and

1658
01:04:02,160 --> 01:04:06,359
to exploit the random local the locality

1659
01:04:06,359 --> 01:04:08,520
we actually do a better run technique

1660
01:04:08,520 --> 01:04:10,799
where we see where we just try random

1661
01:04:10,799 --> 01:04:12,780
starting spots

1662
01:04:12,780 --> 01:04:15,480
and then take the best one after some

1663
01:04:15,480 --> 01:04:18,240
some magic number

1664
01:04:18,240 --> 01:04:21,000
um yeah so these these performance drops

1665
01:04:21,000 --> 01:04:23,520
could also be that we did a bad mutation

1666
01:04:23,520 --> 01:04:26,040
but because of some interrupt in

1667
01:04:26,040 --> 01:04:28,920
something else we did not catch that but

1668
01:04:28,920 --> 01:04:31,740
then the optimizer is free to undo that

1669
01:04:31,740 --> 01:04:34,020
modification later or do it again or on

1670
01:04:34,020 --> 01:04:35,819
different spots or whatever thank you

1671
01:04:35,819 --> 01:04:37,319
very much

1672
01:04:37,319 --> 01:04:39,119
all right I think I'll leave the further

1673
01:04:39,119 --> 01:04:40,260
discussion to the coffee break there's

1674
01:04:40,260 --> 01:04:42,119
one more question online which is how

1675
01:04:42,119 --> 01:04:43,680
long does it take to generate a fast

1676
01:04:43,680 --> 01:04:45,599
implementation is it hours is it days is

1677
01:04:45,599 --> 01:04:47,099
it weeks

1678
01:04:47,099 --> 01:04:47,760
um

1679
01:04:47,760 --> 01:04:50,640
good question depends on the machine a

1680
01:04:50,640 --> 01:04:53,400
couple hours around a couple hours so we

1681
01:04:53,400 --> 01:04:55,440
see that um for this one 100 000

1682
01:04:55,440 --> 01:04:56,880
mutation depends on the size of the

1683
01:04:56,880 --> 01:04:58,079
curve depends on a lot of things but

1684
01:04:58,079 --> 01:05:00,119
around hours

1685
01:05:00,119 --> 01:05:02,400
okay thank you very much again and thank

1686
01:05:02,400 --> 01:05:04,020
all speakers of the session

1687
01:05:04,020 --> 01:05:06,559
thank you

1688
01:05:08,640 --> 01:05:12,078
and I guess there's coffee outside

