1
00:00:00,000 --> 00:00:03,659
my name is Elena dubrova and it's

2
00:00:03,659 --> 00:00:06,600
okay yeah welcome everyone to I just

3
00:00:06,600 --> 00:00:07,919
wanted to check if you have already

4
00:00:07,919 --> 00:00:09,840
revealed slides

5
00:00:09,840 --> 00:00:11,820
yeah welcome to the first session of

6
00:00:11,820 --> 00:00:15,299
today and welcome to RWC 2023 I hope

7
00:00:15,299 --> 00:00:17,340
everyone is excited as me for this first

8
00:00:17,340 --> 00:00:19,740
session which will be about postponed

9
00:00:19,740 --> 00:00:22,619
crypto and we will have free talks on

10
00:00:22,619 --> 00:00:25,740
various side Channel attacks on the pqc

11
00:00:25,740 --> 00:00:27,480
candidates

12
00:00:27,480 --> 00:00:30,180
and the first talk will be on on kyber

13
00:00:30,180 --> 00:00:33,540
and the presenter will be Elena du Prova

14
00:00:33,540 --> 00:00:35,000
thank you again

15
00:00:35,000 --> 00:00:37,320
do you hear me will I have a mic

16
00:00:37,320 --> 00:00:39,660
attached to me so that I can wave both

17
00:00:39,660 --> 00:00:42,120
hands thanks so it's a joint work with

18
00:00:42,120 --> 00:00:44,640
Kalyan go and Joel Gardner the PhD

19
00:00:44,640 --> 00:00:46,860
students at kth college is my PhD

20
00:00:46,860 --> 00:00:49,020
student Jules the PHD student of Uconn

21
00:00:49,020 --> 00:00:51,300
Hustler who is a professor at kth in the

22
00:00:51,300 --> 00:00:53,760
Department of Mathematics so Joel's PhD

23
00:00:53,760 --> 00:00:56,160
is in the theoretical aspect of UBC

24
00:00:56,160 --> 00:00:58,079
algorithms

25
00:00:58,079 --> 00:01:00,180
I will start with giving you a brief

26
00:01:00,180 --> 00:01:02,100
background on site Channel analysis I

27
00:01:02,100 --> 00:01:03,660
assume that maybe you don't have a

28
00:01:03,660 --> 00:01:05,880
knowledge on that then I will talk about

29
00:01:05,880 --> 00:01:07,740
countermeasures masking and shuffling

30
00:01:07,740 --> 00:01:10,740
and then give some background on kyber

31
00:01:10,740 --> 00:01:12,360
because again many of you may not know

32
00:01:12,360 --> 00:01:15,180
it details then I will move to the

33
00:01:15,180 --> 00:01:17,760
attack itself tell you our profiling

34
00:01:17,760 --> 00:01:20,040
strategy and the copy paste method and

35
00:01:20,040 --> 00:01:22,259
present your experimental results then I

36
00:01:22,259 --> 00:01:25,020
will finish and uh talk about future

37
00:01:25,020 --> 00:01:27,780
work I will try to live some time for

38
00:01:27,780 --> 00:01:30,479
the question and answer session

39
00:01:30,479 --> 00:01:32,400
let's talk about how side Channel attack

40
00:01:32,400 --> 00:01:35,220
works well all algorithms crypto and

41
00:01:35,220 --> 00:01:38,100
others are implemented in software CPUs

42
00:01:38,100 --> 00:01:41,159
mcus or in Hardware fpga Asic and then

43
00:01:41,159 --> 00:01:42,780
soon or later they run on physical

44
00:01:42,780 --> 00:01:45,320
devices

45
00:01:45,479 --> 00:01:47,820
these physical devices leak some signals

46
00:01:47,820 --> 00:01:49,500
which are measurable power consumption

47
00:01:49,500 --> 00:01:53,399
timing and it is possible to recognize

48
00:01:53,399 --> 00:01:55,860
from the operations from the type of

49
00:01:55,860 --> 00:01:57,840
operations what's happening in the

50
00:01:57,840 --> 00:01:59,460
circuit just by looking at them purely

51
00:01:59,460 --> 00:02:01,799
from the shape it's also possible to

52
00:02:01,799 --> 00:02:03,899
recognize which data is processed in the

53
00:02:03,899 --> 00:02:06,119
devices again from the shape so these

54
00:02:06,119 --> 00:02:07,560
are two parameters

55
00:02:07,560 --> 00:02:10,258
and for example the picture you see on

56
00:02:10,258 --> 00:02:12,180
the slide is the equipment we used to

57
00:02:12,180 --> 00:02:14,640
break a commercial SIM card

58
00:02:14,640 --> 00:02:18,540
it's uh the pink is a SIM card green is

59
00:02:18,540 --> 00:02:21,900
a SIM card reader the red board is Chip

60
00:02:21,900 --> 00:02:23,640
Whisperer motherboard where you plug

61
00:02:23,640 --> 00:02:25,500
your target we use the same one for the

62
00:02:25,500 --> 00:02:28,739
kyber attack and the the little board on

63
00:02:28,739 --> 00:02:30,660
the top is the chip Whisperer light

64
00:02:30,660 --> 00:02:32,220
which you can use it's kind of a

65
00:02:32,220 --> 00:02:33,959
nostaloscope which measures signal for

66
00:02:33,959 --> 00:02:35,879
you and synchronize them if you want to

67
00:02:35,879 --> 00:02:37,860
get started with site Channel analysis I

68
00:02:37,860 --> 00:02:39,480
highly highly recommend this equipment

69
00:02:39,480 --> 00:02:41,459
it's not expensive and it works very

70
00:02:41,459 --> 00:02:45,480
nicely so uh Sideshow analysis when what

71
00:02:45,480 --> 00:02:47,640
was known for a while since 96 when Paul

72
00:02:47,640 --> 00:02:50,400
culture introduced his pay uh it but

73
00:02:50,400 --> 00:02:52,920
what is Twisted now in the last lesson

74
00:02:52,920 --> 00:02:55,200
10 years is that machine learning and

75
00:02:55,200 --> 00:02:57,780
deep learning K as an alley or Sideshow

76
00:02:57,780 --> 00:03:00,000
analysis and that actually I would say

77
00:03:00,000 --> 00:03:02,340
make a revolution in the field because

78
00:03:02,340 --> 00:03:05,540
if earlier you would need roughly 400

79
00:03:05,540 --> 00:03:08,819
trades measurements from this SIM card

80
00:03:08,819 --> 00:03:10,440
to break in the correlation power

81
00:03:10,440 --> 00:03:12,599
analysis guess how much we need with

82
00:03:12,599 --> 00:03:15,300
deep learning we need two power basis on

83
00:03:15,300 --> 00:03:17,640
average to extract the secret key and

84
00:03:17,640 --> 00:03:19,440
this is given that we don't know what is

85
00:03:19,440 --> 00:03:21,300
run on this card we don't have C we

86
00:03:21,300 --> 00:03:23,220
don't have hex we know nothing actually

87
00:03:23,220 --> 00:03:25,080
it's totally proprietary of the design

88
00:03:25,080 --> 00:03:27,780
so in even in these cases two power

89
00:03:27,780 --> 00:03:29,700
Chasers and we're actually working to

90
00:03:29,700 --> 00:03:33,319
make it one but we cannot yet

91
00:03:33,379 --> 00:03:35,940
uh more of you know what is Advanced

92
00:03:35,940 --> 00:03:37,739
encryption standard as compared to to

93
00:03:37,739 --> 00:03:39,599
kyber so to make the learning curve a

94
00:03:39,599 --> 00:03:41,760
bit smoother I'm starting you with adult

95
00:03:41,760 --> 00:03:43,980
ecliptial standard you see some Advanced

96
00:03:43,980 --> 00:03:46,920
encryption started executed with 128-bit

97
00:03:46,920 --> 00:03:49,379
key these are the the bunches on the top

98
00:03:49,379 --> 00:03:51,420
the executions when we zoom in you see

99
00:03:51,420 --> 00:03:53,700
on the second line the 10 Rounds you

100
00:03:53,700 --> 00:03:56,400
have 10 Rounds with 120 APK then when

101
00:03:56,400 --> 00:03:58,799
you zoom in further you can see distinct

102
00:03:58,799 --> 00:04:00,599
buttons you see the first one and the

103
00:04:00,599 --> 00:04:02,700
last one they are similar so you can say

104
00:04:02,700 --> 00:04:04,620
okay this is probably where my key is

105
00:04:04,620 --> 00:04:06,780
added to the plain text and then at the

106
00:04:06,780 --> 00:04:08,700
end it's a state exhort with surround

107
00:04:08,700 --> 00:04:10,260
key one what happened you see they are

108
00:04:10,260 --> 00:04:12,239
identical and then in between you can

109
00:04:12,239 --> 00:04:15,299
guess what happens in it in between

110
00:04:15,299 --> 00:04:17,760
another example it's even more drastic

111
00:04:17,760 --> 00:04:20,699
in the 8-Bit MCU this is a 16 execution

112
00:04:20,699 --> 00:04:23,699
of s-box is processed sequentially you

113
00:04:23,699 --> 00:04:25,259
see the distinct patterns they're all

114
00:04:25,259 --> 00:04:27,900
kind of similar but with UI you cannot

115
00:04:27,900 --> 00:04:30,000
say which byte this process there which

116
00:04:30,000 --> 00:04:32,820
one is 17 which one is 35 you just can't

117
00:04:32,820 --> 00:04:35,100
do that but this is for deploying can do

118
00:04:35,100 --> 00:04:37,320
very nicely because imagery cognition is

119
00:04:37,320 --> 00:04:38,759
a killer application for deep learning

120
00:04:38,759 --> 00:04:41,400
right this is where it's great for so it

121
00:04:41,400 --> 00:04:44,699
can say in fact this MCU it's X mega you

122
00:04:44,699 --> 00:04:47,460
can do extraction from a single trace

123
00:04:47,460 --> 00:04:49,259
from another device

124
00:04:49,259 --> 00:04:52,560
this is quite impressive coming to

125
00:04:52,560 --> 00:04:54,360
masking and traveling counter measure in

126
00:04:54,360 --> 00:04:56,040
masking you split the secret which we

127
00:04:56,040 --> 00:04:58,860
would like to protect in multiple shares

128
00:04:58,860 --> 00:05:00,840
this example is for the first order

129
00:05:00,840 --> 00:05:03,360
masking when you split in two shares and

130
00:05:03,360 --> 00:05:06,720
you have random string and then exalt of

131
00:05:06,720 --> 00:05:08,639
a string with the original secret if you

132
00:05:08,639 --> 00:05:10,800
are doing Boolean masking if it is more

133
00:05:10,800 --> 00:05:13,860
shares then they adjust more and in

134
00:05:13,860 --> 00:05:16,680
kyber we will it's two type of maskings

135
00:05:16,680 --> 00:05:19,020
it is used Boolean masking when it's

136
00:05:19,020 --> 00:05:21,060
message involved an arithmetic masking

137
00:05:21,060 --> 00:05:23,600
when you're working in

138
00:05:23,600 --> 00:05:26,220
and then if it is an arithmetic masking

139
00:05:26,220 --> 00:05:29,160
you have arithmetic plus and then that's

140
00:05:29,160 --> 00:05:31,740
modular queue arithmetic masking is more

141
00:05:31,740 --> 00:05:33,000
difficult so I have forgotten about

142
00:05:33,000 --> 00:05:35,820
traveling uh shuffling I'll just mention

143
00:05:35,820 --> 00:05:38,520
it shuffling is when you execute in a

144
00:05:38,520 --> 00:05:40,380
different order so you will run an

145
00:05:40,380 --> 00:05:41,580
algorithm

146
00:05:41,580 --> 00:05:43,620
Fisheries for example to generate that

147
00:05:43,620 --> 00:05:45,720
permutation which mobs you

148
00:05:45,720 --> 00:05:48,900
and then store it and then use it again

149
00:05:48,900 --> 00:05:51,539
just so in case you don't know so a big

150
00:05:51,539 --> 00:05:53,100
back to deep learning basic Channel

151
00:05:53,100 --> 00:05:54,120
analysis

152
00:05:54,120 --> 00:05:55,860
so basically what we do we will be

153
00:05:55,860 --> 00:05:58,620
attacking decapsulation that's why uh

154
00:05:58,620 --> 00:06:00,479
ciphertext is the input to the device

155
00:06:00,479 --> 00:06:02,820
you have a device you apply some input

156
00:06:02,820 --> 00:06:05,720
you know then you measure power traces

157
00:06:05,720 --> 00:06:09,720
and you label them we are labeling with

158
00:06:09,720 --> 00:06:11,280
message bits because we will be

159
00:06:11,280 --> 00:06:13,380
recovering messages which are encrypted

160
00:06:13,380 --> 00:06:15,479
in the ciphertext they have a secret if

161
00:06:15,479 --> 00:06:18,539
you get them you have a session key

162
00:06:18,539 --> 00:06:21,419
um so in that case where

163
00:06:21,419 --> 00:06:23,940
um labeling with bits and some other

164
00:06:23,940 --> 00:06:26,280
applications better to label with bytes

165
00:06:26,280 --> 00:06:29,639
it depends of what looks stronger and

166
00:06:29,639 --> 00:06:32,699
you can just test both to decide

167
00:06:32,699 --> 00:06:33,960
um

168
00:06:33,960 --> 00:06:37,380
what we notice at some point around 2021

169
00:06:37,380 --> 00:06:41,400
is it is actually possible to give to

170
00:06:41,400 --> 00:06:44,580
the model deploying model both shares so

171
00:06:44,580 --> 00:06:46,979
you don't have to extract shares one by

172
00:06:46,979 --> 00:06:49,319
one which is typically done but you can

173
00:06:49,319 --> 00:06:50,940
give them both Because deep learning not

174
00:06:50,940 --> 00:06:52,800
only can find what is zero what is one

175
00:06:52,800 --> 00:06:55,440
but also to do simple operations xor is

176
00:06:55,440 --> 00:06:57,300
a very simple operation it's local right

177
00:06:57,300 --> 00:06:59,340
you do the bits so that was quite

178
00:06:59,340 --> 00:07:02,460
surprising and why is it important

179
00:07:02,460 --> 00:07:04,860
fact why don't we just do it share by

180
00:07:04,860 --> 00:07:07,319
share it is important because in this

181
00:07:07,319 --> 00:07:09,840
case in public crypto

182
00:07:09,840 --> 00:07:13,020
we can do profiling on the device under

183
00:07:13,020 --> 00:07:16,259
attack because we can take randomly

184
00:07:16,259 --> 00:07:19,199
messages generated at random encrypt

185
00:07:19,199 --> 00:07:21,300
them with a public key and then we know

186
00:07:21,300 --> 00:07:23,280
the cipher text we know the message

187
00:07:23,280 --> 00:07:25,319
contained in the ciphertext which go in

188
00:07:25,319 --> 00:07:27,539
the device during the consolation and

189
00:07:27,539 --> 00:07:29,460
this is good thing because if you don't

190
00:07:29,460 --> 00:07:32,039
know the design because the design is

191
00:07:32,039 --> 00:07:34,080
tweaked there are some organizations who

192
00:07:34,080 --> 00:07:36,419
won't be using standards they might

193
00:07:36,419 --> 00:07:38,400
tweak the design in some way so that

194
00:07:38,400 --> 00:07:39,720
it's sacred

195
00:07:39,720 --> 00:07:42,180
and then in this case you may still be

196
00:07:42,180 --> 00:07:44,280
in this case you can't profile on

197
00:07:44,280 --> 00:07:45,660
another device just because you don't

198
00:07:45,660 --> 00:07:47,220
have it and you don't know the algorithm

199
00:07:47,220 --> 00:07:50,099
so in this case the device under attack

200
00:07:50,099 --> 00:07:52,380
is all you have so in this case you can

201
00:07:52,380 --> 00:07:54,240
still do that

202
00:07:54,240 --> 00:07:56,280
uh another good thing is of course when

203
00:07:56,280 --> 00:07:57,660
you profile on the device under attack

204
00:07:57,660 --> 00:07:59,460
you're reaching best accuracy all four

205
00:07:59,460 --> 00:08:01,199
you can reach pretty good accuracy by

206
00:08:01,199 --> 00:08:04,199
using a set of profiling devices

207
00:08:04,199 --> 00:08:07,080
then during the attack you will take the

208
00:08:07,080 --> 00:08:10,500
device chain device capture some traces

209
00:08:10,500 --> 00:08:12,900
from the device under attack give them a

210
00:08:12,900 --> 00:08:14,819
device will tell you which message bits

211
00:08:14,819 --> 00:08:17,039
are zero and with which message bit so

212
00:08:17,039 --> 00:08:19,440
one as simple as that

213
00:08:19,440 --> 00:08:21,599
now moving to kyber you probably know

214
00:08:21,599 --> 00:08:23,340
that kyber was selected by news for

215
00:08:23,340 --> 00:08:25,620
standardization last year in July and

216
00:08:25,620 --> 00:08:26,940
the first draft of the standards

217
00:08:26,940 --> 00:08:30,240
expected in 2024 and now the fourth

218
00:08:30,240 --> 00:08:32,458
round is ongoing with a selected

219
00:08:32,458 --> 00:08:35,279
candidates all except the 100 type which

220
00:08:35,279 --> 00:08:36,899
was dropped

221
00:08:36,899 --> 00:08:37,500
um

222
00:08:37,500 --> 00:08:40,320
kyber is using Fujisaki yokamoto

223
00:08:40,320 --> 00:08:42,000
transformed to create

224
00:08:42,000 --> 00:08:46,940
um in CCAC to CQ I came from ncpa Secure

225
00:08:46,940 --> 00:08:50,580
Public encryption scheme uh these are

226
00:08:50,580 --> 00:08:52,620
the three algorithms which are used in

227
00:08:52,620 --> 00:08:54,360
public encryption key generation

228
00:08:54,360 --> 00:08:56,100
encryption and decryption and then we

229
00:08:56,100 --> 00:08:57,660
have also key generation encapsulation

230
00:08:57,660 --> 00:09:00,839
detoxillation in the camp park but you

231
00:09:00,839 --> 00:09:03,000
can see the what is annotation we're

232
00:09:03,000 --> 00:09:05,760
using public key for PK secret private

233
00:09:05,760 --> 00:09:10,459
key SK random coin which is used to

234
00:09:10,459 --> 00:09:14,940
sample noise message m ciphertext c m k

235
00:09:14,940 --> 00:09:17,339
is a shared KO after that's what you

236
00:09:17,339 --> 00:09:19,200
want to establish now we'll spend some

237
00:09:19,200 --> 00:09:21,000
time on talking about the protocol we

238
00:09:21,000 --> 00:09:22,800
assume I call this party one party two

239
00:09:22,800 --> 00:09:24,300
because I don't want to save what is

240
00:09:24,300 --> 00:09:26,880
what just two parties one part is

241
00:09:26,880 --> 00:09:30,300
generating the key pair sending public

242
00:09:30,300 --> 00:09:32,640
key to the other party the other part is

243
00:09:32,640 --> 00:09:36,000
doing encapsulation you do it by

244
00:09:36,000 --> 00:09:37,920
taking message generating message

245
00:09:37,920 --> 00:09:39,839
uniformly at random typically using a

246
00:09:39,839 --> 00:09:42,000
true random number generator then you

247
00:09:42,000 --> 00:09:46,019
have a computer PK K hat and a random

248
00:09:46,019 --> 00:09:49,800
coin R uh by hashing then you encrypt

249
00:09:49,800 --> 00:09:52,200
the message based on the public key and

250
00:09:52,200 --> 00:09:54,000
that random coin

251
00:09:54,000 --> 00:09:56,100
you get the cipher text which you send

252
00:09:56,100 --> 00:09:57,839
to the other party and then you compute

253
00:09:57,839 --> 00:10:00,620
the final key from the paykey K and

254
00:10:00,620 --> 00:10:04,019
hashed ciphertext which you concatenate

255
00:10:04,019 --> 00:10:07,399
before you apply key derivation function

256
00:10:07,399 --> 00:10:10,700
the party one is then decapsulating

257
00:10:10,700 --> 00:10:13,260
received ciphertext by running

258
00:10:13,260 --> 00:10:16,200
decryption and then

259
00:10:16,200 --> 00:10:16,860
um

260
00:10:16,860 --> 00:10:19,560
getting the picky in a similar way as

261
00:10:19,560 --> 00:10:22,740
the other party and then the

262
00:10:22,740 --> 00:10:25,260
F4 Transformers apply in January we are

263
00:10:25,260 --> 00:10:27,000
done with the first two steps right but

264
00:10:27,000 --> 00:10:30,560
to achieve NCCA to security we are

265
00:10:30,560 --> 00:10:33,660
re-running re-encrypting the ciphertext

266
00:10:33,660 --> 00:10:37,019
and comparing to this if one only if the

267
00:10:37,019 --> 00:10:38,580
two agree

268
00:10:38,580 --> 00:10:40,920
the right key will be delivered on the

269
00:10:40,920 --> 00:10:43,860
output if they disagree it will be a

270
00:10:43,860 --> 00:10:47,399
pseudorandom noise delivered on the out

271
00:10:47,399 --> 00:10:50,399
and all while transform guarantees you

272
00:10:50,399 --> 00:10:52,860
theoretical in CCNA to security which

273
00:10:52,860 --> 00:10:55,079
means yes you cure against adaptive

274
00:10:55,079 --> 00:10:58,980
ciphertexts it has been shown that by

275
00:10:58,980 --> 00:11:01,260
taking side channels into account

276
00:11:01,260 --> 00:11:05,160
an attacker can break the algorithm

277
00:11:05,160 --> 00:11:07,920
break in a sense extract the message and

278
00:11:07,920 --> 00:11:09,480
you can do it from

279
00:11:09,480 --> 00:11:11,279
several parts of your algorithm it

280
00:11:11,279 --> 00:11:12,839
doesn't have to be the encryption part

281
00:11:12,839 --> 00:11:14,760
there are more papers focusing on the

282
00:11:14,760 --> 00:11:17,220
encryption part you can also do it

283
00:11:17,220 --> 00:11:19,680
during decryption but

284
00:11:19,680 --> 00:11:21,720
and then the assumptions we will be

285
00:11:21,720 --> 00:11:23,579
doing in this attack which I will be

286
00:11:23,579 --> 00:11:25,920
presenting and we can disc discuss with

287
00:11:25,920 --> 00:11:28,680
you how if you agree or disagree but I

288
00:11:28,680 --> 00:11:30,360
mean these are just some assumptions we

289
00:11:30,360 --> 00:11:33,540
will assume that the public key pair is

290
00:11:33,540 --> 00:11:36,600
static needs to recommends

291
00:11:36,600 --> 00:11:38,579
I don't want to say three comments after

292
00:11:38,579 --> 00:11:41,700
two to power 40 uh 64 but you shouldn't

293
00:11:41,700 --> 00:11:44,519
use it for longer than 2 power 64. but

294
00:11:44,519 --> 00:11:47,459
static pair and then we also assume that

295
00:11:47,459 --> 00:11:49,800
attacker has a possibility to decopulate

296
00:11:49,800 --> 00:11:52,560
decapsulate Cipher text of his or her

297
00:11:52,560 --> 00:11:57,120
choice using that device it may be the

298
00:11:57,120 --> 00:11:59,880
valid ciphertext C which comes from

299
00:11:59,880 --> 00:12:02,220
Party 2 where the attacker did some

300
00:12:02,220 --> 00:12:03,720
manipulations I will be talking about

301
00:12:03,720 --> 00:12:05,220
that because you can manipulate

302
00:12:05,220 --> 00:12:08,100
ciphertext by flipping bits or rotating

303
00:12:08,100 --> 00:12:11,899
it in kyber and some other

304
00:12:11,899 --> 00:12:15,079
lvlvr skills and then

305
00:12:15,079 --> 00:12:18,180
or the attacker that attacker would do

306
00:12:18,180 --> 00:12:19,800
if the attack is after the session key

307
00:12:19,800 --> 00:12:22,440
if the attacker is after the secret key

308
00:12:22,440 --> 00:12:25,200
long-term secret key in this case static

309
00:12:25,200 --> 00:12:27,660
assumption then the attacker can apply

310
00:12:27,660 --> 00:12:32,420
some carefully crowd crafted um

311
00:12:32,940 --> 00:12:35,339
sparse they usually they sparse

312
00:12:35,339 --> 00:12:37,860
ciphertext and the way you do it you're

313
00:12:37,860 --> 00:12:40,680
creating ciphertext so that a given

314
00:12:40,680 --> 00:12:43,920
message bit I depends on a given Cipher

315
00:12:43,920 --> 00:12:47,100
text coefficient I and you can do it by

316
00:12:47,100 --> 00:12:49,200
making ciphertext various bars that

317
00:12:49,200 --> 00:12:50,820
chest paper mentioned before gives a

318
00:12:50,820 --> 00:12:54,300
method and then in kyberware we have

319
00:12:54,300 --> 00:12:56,160
five security key coefficients so minus

320
00:12:56,160 --> 00:12:59,399
two two plus two so logarithm base 205

321
00:12:59,399 --> 00:13:00,959
is free

322
00:13:00,959 --> 00:13:04,620
so you need three messages to uniquely

323
00:13:04,620 --> 00:13:07,079
Define one coefficient and that's three

324
00:13:07,079 --> 00:13:10,320
perank of a modular K these experiments

325
00:13:10,320 --> 00:13:14,519
are for Khyber 768 so you will need nine

326
00:13:14,519 --> 00:13:16,260
chosen ciphertext to recover the secret

327
00:13:16,260 --> 00:13:19,019
key if you can recover messages of 100

328
00:13:19,019 --> 00:13:22,019
probability if you cannot do that which

329
00:13:22,019 --> 00:13:24,000
is usually the case because 3 difficult

330
00:13:24,000 --> 00:13:26,760
to recall something 100 probability then

331
00:13:26,760 --> 00:13:31,019
you can redefine these message groups to

332
00:13:31,019 --> 00:13:34,260
to be good words of some code

333
00:13:34,260 --> 00:13:36,060
for example in this paper I mentioned

334
00:13:36,060 --> 00:13:39,300
teachers we gave this several text

335
00:13:39,300 --> 00:13:41,820
mapping tables for extended Heming code

336
00:13:41,820 --> 00:13:44,279
which has a code distance for if you

337
00:13:44,279 --> 00:13:46,320
have a code of code distance 4 you can

338
00:13:46,320 --> 00:13:48,060
correct to an error and detect one

339
00:13:48,060 --> 00:13:49,680
additional error you can have logic

340
00:13:49,680 --> 00:13:52,079
codes with right larger it was working

341
00:13:52,079 --> 00:13:54,540
best with six when we attack Max and

342
00:13:54,540 --> 00:13:57,839
Shuffle cover but you can sometimes in I

343
00:13:57,839 --> 00:13:59,220
mean depends on the noise so I don't

344
00:13:59,220 --> 00:14:01,920
want to say which code is best the way

345
00:14:01,920 --> 00:14:04,200
you check it is you find out what is

346
00:14:04,200 --> 00:14:05,820
your message recovery probability per

347
00:14:05,820 --> 00:14:07,620
bit and then you can do the usual

348
00:14:07,620 --> 00:14:09,240
analysis analysis you do in full to

349
00:14:09,240 --> 00:14:10,620
learn and design where you compute the

350
00:14:10,620 --> 00:14:12,120
probability of recovery a security

351
00:14:12,120 --> 00:14:14,940
coefficient based on your probability of

352
00:14:14,940 --> 00:14:18,920
recovery of that message bit

353
00:14:18,920 --> 00:14:22,139
uh so moving to the attack point in the

354
00:14:22,139 --> 00:14:24,600
presented attack let me just do for one

355
00:14:24,600 --> 00:14:27,300
second as a part of encryption message

356
00:14:27,300 --> 00:14:30,300
encoding is wrong message encoding is

357
00:14:30,300 --> 00:14:34,079
when you convert array of 32 bytes

358
00:14:34,079 --> 00:14:36,180
that's the way message is represented in

359
00:14:36,180 --> 00:14:40,380
keyboard to 256 polynomial coefficients

360
00:14:40,380 --> 00:14:43,500
and this is the procedure which is doing

361
00:14:43,500 --> 00:14:44,940
it I believe it's from the reference

362
00:14:44,940 --> 00:14:46,980
implementation this is not masked yet I

363
00:14:46,980 --> 00:14:48,660
will show mask on the next slide just to

364
00:14:48,660 --> 00:14:51,300
copy it twice let's run so you see what

365
00:14:51,300 --> 00:14:54,420
you do here is you have this Loop to

366
00:14:54,420 --> 00:14:57,060
make 256 coefficients and then if you

367
00:14:57,060 --> 00:14:58,680
look into this mask which has nothing to

368
00:14:58,680 --> 00:14:59,880
do with the masking I talked about

369
00:14:59,880 --> 00:15:02,579
before it's just another mask it's just

370
00:15:02,579 --> 00:15:04,740
a variable call this way

371
00:15:04,740 --> 00:15:06,839
I believe it's probably done to avoid

372
00:15:06,839 --> 00:15:09,019
branching to achieve

373
00:15:09,019 --> 00:15:11,699
constant timing which is which is

374
00:15:11,699 --> 00:15:13,380
wonderful you have to think about that

375
00:15:13,380 --> 00:15:15,540
what happens here unfortunately from the

376
00:15:15,540 --> 00:15:17,339
point of view of power analysis mask

377
00:15:17,339 --> 00:15:20,459
takes two values all zero and left and

378
00:15:20,459 --> 00:15:21,959
the Hamming distance between these two

379
00:15:21,959 --> 00:15:24,480
values is 16 huge

380
00:15:24,480 --> 00:15:27,600
it's very easy to extract to recognize

381
00:15:27,600 --> 00:15:30,060
difference between 0 and of in power

382
00:15:30,060 --> 00:15:32,160
analysis when the Heming weight you can

383
00:15:32,160 --> 00:15:34,800
even recognize the Heming weight one

384
00:15:34,800 --> 00:15:37,860
16 is just very very easy so it's very

385
00:15:37,860 --> 00:15:39,360
unfortunate because overall it's a

386
00:15:39,360 --> 00:15:42,120
beautiful way of avoiding branching but

387
00:15:42,120 --> 00:15:43,980
unfortunately it leaks from a power

388
00:15:43,980 --> 00:15:46,380
consumption point of view and to my best

389
00:15:46,380 --> 00:15:47,820
knowledge first time this type of

390
00:15:47,820 --> 00:15:49,860
leakage the terminal leakage I think is

391
00:15:49,860 --> 00:15:51,899
it was called later was mentioned in the

392
00:15:51,899 --> 00:15:54,240
attack of New Hope and we still have it

393
00:15:54,240 --> 00:15:55,800
in that implementation this is the

394
00:15:55,800 --> 00:15:57,060
implementation which we're using

395
00:15:57,060 --> 00:15:58,820
wonderful implementation

396
00:15:58,820 --> 00:16:01,620
it's a first order masking and you see

397
00:16:01,620 --> 00:16:03,899
you you have twice copy of the code I

398
00:16:03,899 --> 00:16:06,839
just showed you uh we just most to

399
00:16:06,839 --> 00:16:08,639
extend to high orders to try higher

400
00:16:08,639 --> 00:16:10,740
orders we just extend this procedure

401
00:16:10,740 --> 00:16:12,660
that's what we did by then when we

402
00:16:12,660 --> 00:16:14,100
started with this experiment we didn't

403
00:16:14,100 --> 00:16:15,240
know the republicly available

404
00:16:15,240 --> 00:16:17,100
implementations of high order keyboard

405
00:16:17,100 --> 00:16:19,800
when we put this the report on the web

406
00:16:19,800 --> 00:16:23,940
very nice person called Oliver bronze

407
00:16:23,940 --> 00:16:26,160
chain wrote me an email and said they

408
00:16:26,160 --> 00:16:28,260
have uh public uh publicly available

409
00:16:28,260 --> 00:16:30,779
high order cardboard I'm very grateful

410
00:16:30,779 --> 00:16:33,300
to him because we are now working on its

411
00:16:33,300 --> 00:16:35,639
analysis it's almost done and it's not

412
00:16:35,639 --> 00:16:37,620
implemented in this way they did it in a

413
00:16:37,620 --> 00:16:39,300
very smart way they have a bit sliced

414
00:16:39,300 --> 00:16:41,639
implementation highly optimized very

415
00:16:41,639 --> 00:16:44,339
nice and the mask is not anymore 16-bit

416
00:16:44,339 --> 00:16:47,839
Hemingway but just one

417
00:16:48,139 --> 00:16:51,120
I will take it and ask questions and

418
00:16:51,120 --> 00:16:53,160
answer sessions if you're interested so

419
00:16:53,160 --> 00:16:55,860
let me show you the power slide of kyber

420
00:16:55,860 --> 00:16:58,199
here is a part of re-encryption and

421
00:16:58,199 --> 00:17:00,660
encryption is very long uh kyber has

422
00:17:00,660 --> 00:17:02,339
very long traces to capture it we use

423
00:17:02,339 --> 00:17:04,799
cheap Whisperer Pro which has 90k buffer

424
00:17:04,799 --> 00:17:07,199
you see it's larger than 80k and it's

425
00:17:07,199 --> 00:17:08,819
not including completely encryption it's

426
00:17:08,819 --> 00:17:10,380
the end of the encryption because this

427
00:17:10,380 --> 00:17:12,059
message is encoding is towards the end

428
00:17:12,059 --> 00:17:14,099
of the encryption so we zoom in into

429
00:17:14,099 --> 00:17:16,260
this part and you see two shares you

430
00:17:16,260 --> 00:17:17,939
just see it you see the identity is

431
00:17:17,939 --> 00:17:20,220
nothing around looking like this that's

432
00:17:20,220 --> 00:17:22,679
why you know it's shared and this is

433
00:17:22,679 --> 00:17:24,240
mask poly from message I mentioned

434
00:17:24,240 --> 00:17:26,040
before then this procedure so just put

435
00:17:26,040 --> 00:17:27,419
them the way they are in the seq

436
00:17:27,419 --> 00:17:29,580
implementation so that you know what

437
00:17:29,580 --> 00:17:31,980
they are and then if we follow Zoom you

438
00:17:31,980 --> 00:17:34,320
see the bytes you see they are identical

439
00:17:34,320 --> 00:17:35,640
you can measure the distance between

440
00:17:35,640 --> 00:17:36,900
them we're just looking into Power

441
00:17:36,900 --> 00:17:39,419
choice I always joke that the best tool

442
00:17:39,419 --> 00:17:41,100
for site Channel analysis is plot

443
00:17:41,100 --> 00:17:43,700
because you just plot and look

444
00:17:43,700 --> 00:17:46,500
uh that's the bite and then if you look

445
00:17:46,500 --> 00:17:48,299
into the bytes bits are processed within

446
00:17:48,299 --> 00:17:50,340
a bytes but not really uniformly because

447
00:17:50,340 --> 00:17:51,840
you don't have a structure of eight

448
00:17:51,840 --> 00:17:53,880
within a bite and you will see it also

449
00:17:53,880 --> 00:17:56,220
from our experimental results we are

450
00:17:56,220 --> 00:17:57,840
compiling with all three highest

451
00:17:57,840 --> 00:18:00,179
compiler option I guess it does some

452
00:18:00,179 --> 00:18:02,760
optimization that's why just to show you

453
00:18:02,760 --> 00:18:06,360
how it will be extended to more shares

454
00:18:06,360 --> 00:18:09,419
the one I showed you was two shares now

455
00:18:09,419 --> 00:18:11,100
you have free shares you can see them

456
00:18:11,100 --> 00:18:14,700
right four five six you see how the

457
00:18:14,700 --> 00:18:17,400
level jumps this is why I prefer direct

458
00:18:17,400 --> 00:18:19,260
method as compared to the method which

459
00:18:19,260 --> 00:18:21,240
extracted share by share because there

460
00:18:21,240 --> 00:18:23,520
are differences between the shares and

461
00:18:23,520 --> 00:18:25,260
then basically to achieve it with a

462
00:18:25,260 --> 00:18:28,559
non-direct method you will need to get a

463
00:18:28,559 --> 00:18:30,900
template or a model model just a

464
00:18:30,900 --> 00:18:32,220
template another way of building it

465
00:18:32,220 --> 00:18:33,539
right

466
00:18:33,539 --> 00:18:34,320
um

467
00:18:34,320 --> 00:18:38,480
for each of the shares separately

468
00:18:38,700 --> 00:18:42,240
all right so I would like to before I

469
00:18:42,240 --> 00:18:43,799
start presenting the final results I

470
00:18:43,799 --> 00:18:45,360
would like to explain you what we knew

471
00:18:45,360 --> 00:18:47,280
before the start where we were so that

472
00:18:47,280 --> 00:18:48,960
you understand why I focus on this copy

473
00:18:48,960 --> 00:18:51,480
paste so much we knew that we started

474
00:18:51,480 --> 00:18:53,520
with saber that was the only publicly

475
00:18:53,520 --> 00:18:55,860
available implementation of a mask uh

476
00:18:55,860 --> 00:18:58,980
pqc algorithm when we did it it was

477
00:18:58,980 --> 00:19:01,620
presented on the teachers uh it's again

478
00:19:01,620 --> 00:19:03,539
I'm very grateful to the order of sable

479
00:19:03,539 --> 00:19:05,220
because they gave us a version even

480
00:19:05,220 --> 00:19:07,559
before it was publicly released and when

481
00:19:07,559 --> 00:19:08,760
they publicly released they already

482
00:19:08,760 --> 00:19:10,740
fixed some of the vulnerabilities we

483
00:19:10,740 --> 00:19:13,140
found in the first version and then the

484
00:19:13,140 --> 00:19:15,960
master she sees a student kth analyzed

485
00:19:15,960 --> 00:19:17,760
the public religious version in his

486
00:19:17,760 --> 00:19:20,100
business later when we knew that Sabor

487
00:19:20,100 --> 00:19:21,960
and the second and third order that

488
00:19:21,960 --> 00:19:24,120
implementation of undo also can be

489
00:19:24,120 --> 00:19:27,360
broken and we went to third order fourth

490
00:19:27,360 --> 00:19:29,220
we couldn't break with a direct method

491
00:19:29,220 --> 00:19:31,080
it was going directly all the way to

492
00:19:31,080 --> 00:19:33,059
free and then just random yes you don't

493
00:19:33,059 --> 00:19:34,260
learn anything

494
00:19:34,260 --> 00:19:35,220
then

495
00:19:35,220 --> 00:19:35,640
[Music]

496
00:19:35,640 --> 00:19:36,780
um

497
00:19:36,780 --> 00:19:39,720
what we also knew is shuffling shuffling

498
00:19:39,720 --> 00:19:42,860
is also mentioned as a way of saving

499
00:19:42,860 --> 00:19:44,880
implementations from sidechando Attack

500
00:19:44,880 --> 00:19:46,440
was a method of protecting against

501
00:19:46,440 --> 00:19:49,320
simple power analysis unfortunately even

502
00:19:49,320 --> 00:19:52,200
if you combine shuffling with masking we

503
00:19:52,200 --> 00:19:55,140
can still recover messages two methods

504
00:19:55,140 --> 00:19:56,940
we presented in the first method which

505
00:19:56,940 --> 00:20:01,320
were presented in ashes 21 we basically

506
00:20:01,320 --> 00:20:04,200
use bit flipping method where we flip

507
00:20:04,200 --> 00:20:06,539
the message bit imagine you have a

508
00:20:06,539 --> 00:20:08,400
shuffled message you don't know what the

509
00:20:08,400 --> 00:20:10,440
order is but you can still get the beats

510
00:20:10,440 --> 00:20:12,539
and count the Heming weight total number

511
00:20:12,539 --> 00:20:14,880
of ones right now imagine you have a

512
00:20:14,880 --> 00:20:17,039
power of flipping one message bit you

513
00:20:17,039 --> 00:20:18,960
flip it and you see how the Hemingway

514
00:20:18,960 --> 00:20:22,679
changes if it goes down it means that

515
00:20:22,679 --> 00:20:24,360
the message bit was one

516
00:20:24,360 --> 00:20:27,120
if it goes up it means that the message

517
00:20:27,120 --> 00:20:29,940
bit was zero so in that way by flipping

518
00:20:29,940 --> 00:20:32,640
each bit and doing analysis you can

519
00:20:32,640 --> 00:20:35,700
actually find out the order

520
00:20:35,700 --> 00:20:37,799
second method as we were doing it we

521
00:20:37,799 --> 00:20:39,660
were not too happy because you need 61k

522
00:20:39,660 --> 00:20:42,179
traces to break mask and truffle the

523
00:20:42,179 --> 00:20:43,679
second we do it with a smaller number

524
00:20:43,679 --> 00:20:46,020
and then what we say we say is it

525
00:20:46,020 --> 00:20:47,900
possible to recover fissure Gates

526
00:20:47,900 --> 00:20:51,059
indexes when they are generated

527
00:20:51,059 --> 00:20:53,520
when the permutation is generated can we

528
00:20:53,520 --> 00:20:56,160
do that this bites because we have bytes

529
00:20:56,160 --> 00:20:59,160
to represent 256 fermentation indexes

530
00:20:59,160 --> 00:21:01,140
well it's difficult because they're

531
00:21:01,140 --> 00:21:03,059
generated in parallel and we were able

532
00:21:03,059 --> 00:21:05,340
to recognize Heming weight but not the

533
00:21:05,340 --> 00:21:07,380
values themselves it was difficult to

534
00:21:07,380 --> 00:21:08,940
tell apart the value so we did some

535
00:21:08,940 --> 00:21:11,160
trick with cyclic shifting again

536
00:21:11,160 --> 00:21:13,500
and that allows us to reduce the number

537
00:21:13,500 --> 00:21:17,059
of traces two minutes left

538
00:21:18,919 --> 00:21:22,080
so I will skip that one this so question

539
00:21:22,080 --> 00:21:25,620
which we were trying to adjust is how

540
00:21:25,620 --> 00:21:27,299
many shares a direct metal can handle

541
00:21:27,299 --> 00:21:28,620
because it's the only thing we didn't

542
00:21:28,620 --> 00:21:31,380
know so that you understand why this is

543
00:21:31,380 --> 00:21:35,460
our MLPs we just use the Kono free MLP

544
00:21:35,460 --> 00:21:37,020
worse grade because chip was very

545
00:21:37,020 --> 00:21:40,020
synchronizes for us profiling strategy

546
00:21:40,020 --> 00:21:42,299
we capture 30k traces from each device

547
00:21:42,299 --> 00:21:43,620
for each attack

548
00:21:43,620 --> 00:21:45,960
then we expanded them but cut and joined

549
00:21:45,960 --> 00:21:47,940
we cut across by makes a union that's

550
00:21:47,940 --> 00:21:49,380
very good because it helps the model

551
00:21:49,380 --> 00:21:50,880
generalize

552
00:21:50,880 --> 00:21:53,220
message bit values were used as labels

553
00:21:53,220 --> 00:21:55,799
that's the thing you saw before this is

554
00:21:55,799 --> 00:21:57,659
how the batch normalization layer of a

555
00:21:57,659 --> 00:21:59,700
model looks before training just plot

556
00:21:59,700 --> 00:22:01,860
and look you will see where the weights

557
00:22:01,860 --> 00:22:04,200
are high this is the point where the

558
00:22:04,200 --> 00:22:06,840
message yes this is the point which

559
00:22:06,840 --> 00:22:08,580
clicks and then you can cut these things

560
00:22:08,580 --> 00:22:10,440
joined together and retrain and that's

561
00:22:10,440 --> 00:22:13,200
what exactly we did so finally coming to

562
00:22:13,200 --> 00:22:15,240
the copy paste method these are cut

563
00:22:15,240 --> 00:22:17,700
power traces on the intervals of 32

564
00:22:17,700 --> 00:22:18,780
parts

565
00:22:18,780 --> 00:22:21,900
this batch normalization after training

566
00:22:21,900 --> 00:22:24,720
when we went for six shares it stopped

567
00:22:24,720 --> 00:22:26,640
learning all the way to five I believe

568
00:22:26,640 --> 00:22:28,320
it was learning directly but then we

569
00:22:28,320 --> 00:22:29,880
will start and we wanted to know the

570
00:22:29,880 --> 00:22:31,860
truth is how far we can go can we go

571
00:22:31,860 --> 00:22:34,200
further so what we realized it looks so

572
00:22:34,200 --> 00:22:38,039
identical and can we just make a edit of

573
00:22:38,039 --> 00:22:41,280
H5 file which stores the model so we

574
00:22:41,280 --> 00:22:44,460
open H5 file of that train model in text

575
00:22:44,460 --> 00:22:46,860
editor and compute the last batch

576
00:22:46,860 --> 00:22:48,240
normalization you see these two

577
00:22:48,240 --> 00:22:51,059
identical that's what we did and then we

578
00:22:51,059 --> 00:22:52,799
gave that to the model for training that

579
00:22:52,799 --> 00:22:54,360
learned from the beginning it was over

580
00:22:54,360 --> 00:22:56,460
90 from the first attempt first time you

581
00:22:56,460 --> 00:22:58,620
press the button and we spent weeks on

582
00:22:58,620 --> 00:23:00,419
trying to do it in another way so I

583
00:23:00,419 --> 00:23:01,740
actually believe that you cannot do it

584
00:23:01,740 --> 00:23:02,880
in another way because deep learning

585
00:23:02,880 --> 00:23:04,440
just get the most in this huge search

586
00:23:04,440 --> 00:23:06,600
space you have that's why I believe it's

587
00:23:06,600 --> 00:23:08,940
a main contribution of the paper I will

588
00:23:08,940 --> 00:23:10,860
briefly go through them

589
00:23:10,860 --> 00:23:12,900
tables this is what you get on the first

590
00:23:12,900 --> 00:23:15,240
line when you just attack directly in

591
00:23:15,240 --> 00:23:16,980
the second line what you do if you do

592
00:23:16,980 --> 00:23:19,740
four Mega cyclic rotations because you

593
00:23:19,740 --> 00:23:22,980
see in the first and uh zero bit is the

594
00:23:22,980 --> 00:23:25,200
best right then it deteriorates towards

595
00:23:25,200 --> 00:23:27,299
the bit position and a byte so we

596
00:23:27,299 --> 00:23:29,280
decided Well if leakage is non-uniform

597
00:23:29,280 --> 00:23:31,620
with your cycle created and we will move

598
00:23:31,620 --> 00:23:33,780
the bits which lay quick to the bits

599
00:23:33,780 --> 00:23:35,760
which look strong and that's what we did

600
00:23:35,760 --> 00:23:39,900
and then this nice paper presented uh

601
00:23:39,900 --> 00:23:41,340
for the first time I heard that they

602
00:23:41,340 --> 00:23:43,140
presented the messages can actually be

603
00:23:43,140 --> 00:23:45,960
cyclic validated and explain how this is

604
00:23:45,960 --> 00:23:47,820
as we increase the number of shares what

605
00:23:47,820 --> 00:23:50,039
happens of course it goes down yes it

606
00:23:50,039 --> 00:23:51,900
does and then if you take this number

607
00:23:51,900 --> 00:23:54,960
average and take power 256 you get

608
00:23:54,960 --> 00:23:58,440
nothing right it's close to zero however

609
00:23:58,440 --> 00:24:01,799
what we can do we can average and so in

610
00:24:01,799 --> 00:24:03,360
not average we can repeat you cannot

611
00:24:03,360 --> 00:24:05,340
average with masking but you can still

612
00:24:05,340 --> 00:24:06,960
repeat in a sense that you will just

613
00:24:06,960 --> 00:24:09,179
repeat the attack more than once and

614
00:24:09,179 --> 00:24:10,440
here comes the message if you don't

615
00:24:10,440 --> 00:24:12,600
remember member from my talk one thing

616
00:24:12,600 --> 00:24:14,520
and you are designing crypto algorithms

617
00:24:14,520 --> 00:24:16,799
please remember that because it's

618
00:24:16,799 --> 00:24:20,159
amazing random masks are updated of each

619
00:24:20,159 --> 00:24:23,700
execution and that helps making errors

620
00:24:23,700 --> 00:24:25,260
independent

621
00:24:25,260 --> 00:24:28,020
so when you recover things and just do

622
00:24:28,020 --> 00:24:30,299
majority voting because errors are

623
00:24:30,299 --> 00:24:32,700
independent it accuracy increases

624
00:24:32,700 --> 00:24:35,039
drastically you see we can jump from the

625
00:24:35,039 --> 00:24:36,960
zero accuracy you shown on the previous

626
00:24:36,960 --> 00:24:39,900
slide with majority voting of five only

627
00:24:39,900 --> 00:24:43,980
we can jump to 87 probability of message

628
00:24:43,980 --> 00:24:46,320
recovery full message recovery

629
00:24:46,320 --> 00:24:48,840
if you want higher just cycle rotate

630
00:24:48,840 --> 00:24:51,360
eight times to the Bit Zero

631
00:24:51,360 --> 00:24:54,120
good so to summarize I believe copy

632
00:24:54,120 --> 00:24:56,100
paste message is the light in the dark

633
00:24:56,100 --> 00:24:58,380
which helps deep learning to get started

634
00:24:58,380 --> 00:25:00,120
in the rights or part of a search base

635
00:25:00,120 --> 00:25:02,220
and don't forget that cyclic rotations

636
00:25:02,220 --> 00:25:04,740
are repetitions are useful they are

637
00:25:04,740 --> 00:25:06,780
useful for the attacker so if there is a

638
00:25:06,780 --> 00:25:08,580
possibility to design a crypto algorithm

639
00:25:08,580 --> 00:25:10,500
because you see where you cannot do

640
00:25:10,500 --> 00:25:12,659
cyclic rotations and bit flipping please

641
00:25:12,659 --> 00:25:14,520
design one it will be more difficult to

642
00:25:14,520 --> 00:25:16,919
do side Channel values finally about the

643
00:25:16,919 --> 00:25:18,419
future work we need to design deep

644
00:25:18,419 --> 00:25:20,100
learning resist encounter measures I

645
00:25:20,100 --> 00:25:21,840
don't believe they exist at the present

646
00:25:21,840 --> 00:25:23,520
and it's a very difficult problem I mean

647
00:25:23,520 --> 00:25:25,440
for years we already trying and we

648
00:25:25,440 --> 00:25:27,299
believe we did it and then next day we

649
00:25:27,299 --> 00:25:29,220
break it so unfortunately there is

650
00:25:29,220 --> 00:25:30,960
nothing today which I can say Works

651
00:25:30,960 --> 00:25:32,580
we're also looking into the hardware

652
00:25:32,580 --> 00:25:34,559
implementations which are overall more

653
00:25:34,559 --> 00:25:35,940
difficult to attack

654
00:25:35,940 --> 00:25:38,659
uh we have progress with breaking um

655
00:25:38,659 --> 00:25:40,919
masked fpga implementation which was

656
00:25:40,919 --> 00:25:43,860
presented in November last year at the

657
00:25:43,860 --> 00:25:46,260
picture system advertisation conference

658
00:25:46,260 --> 00:25:49,580
we have good results actually

659
00:25:49,580 --> 00:25:53,880
0.996 per bit in fact uh we will we are

660
00:25:53,880 --> 00:25:56,159
working on the paper and we also analyze

661
00:25:56,159 --> 00:25:57,720
our own protected implementation

662
00:25:57,720 --> 00:25:59,700
Hardware is actually easier to protect

663
00:25:59,700 --> 00:26:01,980
the software so we believe we found an

664
00:26:01,980 --> 00:26:04,740
implementation which is good enough but

665
00:26:04,740 --> 00:26:07,140
we don't want to hire but we believe we

666
00:26:07,140 --> 00:26:08,640
have one we will make it public level

667
00:26:08,640 --> 00:26:11,279
well maybe at the end of April

668
00:26:11,279 --> 00:26:13,559
thank you for your attention and I would

669
00:26:13,559 --> 00:26:15,840
like to thank everybody who supports my

670
00:26:15,840 --> 00:26:16,800
research

671
00:26:16,800 --> 00:26:17,730
[Applause]

672
00:26:17,730 --> 00:26:18,840
[Music]

673
00:26:18,840 --> 00:26:25,679
[Applause]

674
00:26:25,679 --> 00:26:28,200
there'll be a bit short on time so let's

675
00:26:28,200 --> 00:26:30,480
take any questions offline

676
00:26:30,480 --> 00:26:34,880
and the next speaker can come up

677
00:26:47,039 --> 00:26:49,940
foreign

678
00:26:55,880 --> 00:26:58,260
can do a key recovery with a roll

679
00:26:58,260 --> 00:27:01,020
hematic and the speaker will be Hunter

680
00:27:01,020 --> 00:27:04,639
kippen and Andrew Kwong

681
00:27:07,559 --> 00:27:09,900
can everyone hear me okay

682
00:27:09,900 --> 00:27:13,440
okay awesome so as

683
00:27:13,440 --> 00:27:15,299
our chair mentioned I'm Hunter kippen

684
00:27:15,299 --> 00:27:18,360
and this is Andrew Huang and we're going

685
00:27:18,360 --> 00:27:20,720
to discuss some of our recent work

686
00:27:20,720 --> 00:27:25,140
that was published in ccs of last year

687
00:27:25,140 --> 00:27:27,299
um this was a really large project and

688
00:27:27,299 --> 00:27:28,500
we want to give thanks to all of our

689
00:27:28,500 --> 00:27:31,080
co-authors on this I can't you know list

690
00:27:31,080 --> 00:27:32,520
out all of these names I'll run out of

691
00:27:32,520 --> 00:27:33,779
time

692
00:27:33,779 --> 00:27:34,380
um

693
00:27:34,380 --> 00:27:36,779
but so with that I think we should get

694
00:27:36,779 --> 00:27:38,279
started

695
00:27:38,279 --> 00:27:40,500
um so the main motivation right for this

696
00:27:40,500 --> 00:27:41,940
attack obviously you know we need

697
00:27:41,940 --> 00:27:44,340
Quantum resistant cryptography and in

698
00:27:44,340 --> 00:27:46,200
particular when we're talking about post

699
00:27:46,200 --> 00:27:47,820
Quantum with the standards it's

700
00:27:47,820 --> 00:27:50,220
important that we need to quantify the

701
00:27:50,220 --> 00:27:53,220
actual deployment risks of deploying

702
00:27:53,220 --> 00:27:53,940
um

703
00:27:53,940 --> 00:27:56,279
these New Primitives before finalizing

704
00:27:56,279 --> 00:27:58,740
the standards parameter sets need to be

705
00:27:58,740 --> 00:28:01,260
set such that we can actually

706
00:28:01,260 --> 00:28:01,919
um

707
00:28:01,919 --> 00:28:03,600
make sure that our deployments are

708
00:28:03,600 --> 00:28:06,720
secure and when we consider security we

709
00:28:06,720 --> 00:28:08,400
need to consider both mathematical

710
00:28:08,400 --> 00:28:10,020
security so that's our underlying

711
00:28:10,020 --> 00:28:12,480
hardness assumptions uh the new you know

712
00:28:12,480 --> 00:28:14,039
especially for like

713
00:28:14,039 --> 00:28:15,720
uh and

714
00:28:15,720 --> 00:28:17,700
side channel security when we consider

715
00:28:17,700 --> 00:28:19,559
side channel security we have passive

716
00:28:19,559 --> 00:28:21,360
side channels so these are things that

717
00:28:21,360 --> 00:28:23,580
uh like in the previous power analysis

718
00:28:23,580 --> 00:28:26,100
or timing analysis attacks

719
00:28:26,100 --> 00:28:27,840
um but when it comes to post Quantum

720
00:28:27,840 --> 00:28:29,460
cryptography not enough is known about

721
00:28:29,460 --> 00:28:32,039
the resistance of these schemes to

722
00:28:32,039 --> 00:28:35,220
active side channels so that includes

723
00:28:35,220 --> 00:28:38,400
glitches uh fault injections and bit

724
00:28:38,400 --> 00:28:39,960
flips

725
00:28:39,960 --> 00:28:43,559
so in this talk We examined frodochem a

726
00:28:43,559 --> 00:28:45,240
reasonable example of a post Quantum

727
00:28:45,240 --> 00:28:47,360
secure key encapsulation mechanism

728
00:28:47,360 --> 00:28:49,679
and we quantify specifically the

729
00:28:49,679 --> 00:28:52,260
vulnerability of photochem to bit flips

730
00:28:52,260 --> 00:28:54,120
and in fact we find that bit flips

731
00:28:54,120 --> 00:28:56,039
enable a full end-to-end key recovery

732
00:28:56,039 --> 00:28:58,740
attack and for us it only took us we

733
00:28:58,740 --> 00:29:00,600
only need to flip seven bits

734
00:29:00,600 --> 00:29:02,940
and we'll with this we're able to Brute

735
00:29:02,940 --> 00:29:04,440
Force session keys in two minutes on a

736
00:29:04,440 --> 00:29:07,380
laptop uh with some pre-processing

737
00:29:07,380 --> 00:29:09,779
and in fact this is actually the first

738
00:29:09,779 --> 00:29:12,179
practical failure boosting instantiation

739
00:29:12,179 --> 00:29:13,679
of a failure boosting attack on a post

740
00:29:13,679 --> 00:29:15,600
Quantum chem

741
00:29:15,600 --> 00:29:16,320
um

742
00:29:16,320 --> 00:29:19,260
and so first uh for the remainder of

743
00:29:19,260 --> 00:29:20,700
this talk I'm going to talk a little bit

744
00:29:20,700 --> 00:29:22,200
about the crypto analysis how we

745
00:29:22,200 --> 00:29:23,880
actually use bitflips to break photochem

746
00:29:23,880 --> 00:29:25,500
and then I will hand it off to Andrew

747
00:29:25,500 --> 00:29:27,120
and he'll talk about the rowheimer

748
00:29:27,120 --> 00:29:29,100
process and actually how

749
00:29:29,100 --> 00:29:29,820
um

750
00:29:29,820 --> 00:29:31,980
the challenges um associated with

751
00:29:31,980 --> 00:29:33,360
actually getting the bit flips that we

752
00:29:33,360 --> 00:29:34,799
need

753
00:29:34,799 --> 00:29:37,380
and so when we're talking about uh chems

754
00:29:37,380 --> 00:29:38,580
first we have to discuss a little bit

755
00:29:38,580 --> 00:29:40,260
about hybrid encryption right so the

756
00:29:40,260 --> 00:29:42,120
idea is that if two parties want to

757
00:29:42,120 --> 00:29:43,559
communicate

758
00:29:43,559 --> 00:29:45,299
um with a symmetric key but they have

759
00:29:45,299 --> 00:29:46,740
access to public key cryptography

760
00:29:46,740 --> 00:29:48,360
usually what they would do is they would

761
00:29:48,360 --> 00:29:50,520
generate their public key and secret key

762
00:29:50,520 --> 00:29:52,380
and then the first party would send the

763
00:29:52,380 --> 00:29:54,899
public key over the second party uh

764
00:29:54,899 --> 00:29:57,419
samples their AES key they

765
00:29:57,419 --> 00:30:00,000
encrypt it and send it back to the first

766
00:30:00,000 --> 00:30:01,140
party

767
00:30:01,140 --> 00:30:03,779
uh and obviously the first party if they

768
00:30:03,779 --> 00:30:05,340
decrypt it they'll get the is key they

769
00:30:05,340 --> 00:30:06,960
have a shared key they're kind of done

770
00:30:06,960 --> 00:30:09,120
here but the thing is is like we can

771
00:30:09,120 --> 00:30:11,580
come you know someone can come around

772
00:30:11,580 --> 00:30:14,100
um and take this ciphertext and and

773
00:30:14,100 --> 00:30:16,380
manipulate it into something that's uh

774
00:30:16,380 --> 00:30:18,539
not usable uh like get the key out

775
00:30:18,539 --> 00:30:21,000
that's different uh and and Frodo and

776
00:30:21,000 --> 00:30:22,320
most of the PQ

777
00:30:22,320 --> 00:30:23,100
um

778
00:30:23,100 --> 00:30:25,740
chem schemes that were introduced in the

779
00:30:25,740 --> 00:30:27,419
nist competition are vulnerable to

780
00:30:27,419 --> 00:30:29,039
ciphertext modeling when operated just

781
00:30:29,039 --> 00:30:31,460
as plain public key encryption

782
00:30:31,460 --> 00:30:35,100
uh so obviously and this has been seen

783
00:30:35,100 --> 00:30:36,360
I'm sure a lot of you have already seen

784
00:30:36,360 --> 00:30:38,399
this uh

785
00:30:38,399 --> 00:30:40,620
you have to operate these schemes as key

786
00:30:40,620 --> 00:30:42,299
encapsulation mechanisms and so that's

787
00:30:42,299 --> 00:30:44,100
the ideas you generate your public key

788
00:30:44,100 --> 00:30:45,840
and secret key as before

789
00:30:45,840 --> 00:30:48,480
but instead you send so when you

790
00:30:48,480 --> 00:30:51,299
actually sample your AES key or whatever

791
00:30:51,299 --> 00:30:53,640
symmetric key you're trying to use uh

792
00:30:53,640 --> 00:30:55,140
you derive some Randomness

793
00:30:55,140 --> 00:30:57,179
deterministically from this key and you

794
00:30:57,179 --> 00:30:59,159
use that in the encryption process which

795
00:30:59,159 --> 00:31:00,840
is now called encapsulation

796
00:31:00,840 --> 00:31:03,779
and you know so once you send the

797
00:31:03,779 --> 00:31:05,820
ciphertext back over like before the

798
00:31:05,820 --> 00:31:08,279
first party can check you know redrive

799
00:31:08,279 --> 00:31:10,620
this Randomness and check whether or not

800
00:31:10,620 --> 00:31:11,700
um

801
00:31:11,700 --> 00:31:14,520
this uh you know they'll re-encrypt and

802
00:31:14,520 --> 00:31:16,080
they'll check and make sure that the

803
00:31:16,080 --> 00:31:17,460
message that they received hasn't been

804
00:31:17,460 --> 00:31:19,320
tampered with and so if this if this

805
00:31:19,320 --> 00:31:21,179
succeeds then you know both parties know

806
00:31:21,179 --> 00:31:22,620
that the key that they've received the

807
00:31:22,620 --> 00:31:25,080
symmetric key that they have it hasn't

808
00:31:25,080 --> 00:31:26,399
been tampered with

809
00:31:26,399 --> 00:31:29,580
and this prevents active adversaries but

810
00:31:29,580 --> 00:31:31,919
we'll note that specifically for a lot

811
00:31:31,919 --> 00:31:35,220
of these uh lattice based schemes you

812
00:31:35,220 --> 00:31:37,020
have this uh you have this a passive

813
00:31:37,020 --> 00:31:39,120
adversary can observe the following

814
00:31:39,120 --> 00:31:41,220
so there's a noisy linear relation

815
00:31:41,220 --> 00:31:42,600
between your secret key and your public

816
00:31:42,600 --> 00:31:44,880
key and in fact you know the public key

817
00:31:44,880 --> 00:31:47,220
in effect acts as a blinding Factor on

818
00:31:47,220 --> 00:31:49,500
on this relation itself noise in the

819
00:31:49,500 --> 00:31:51,740
public key yeah I should say

820
00:31:51,740 --> 00:31:55,559
and if if you get particularly unlucky

821
00:31:55,559 --> 00:31:57,179
when you're actually sampling your as

822
00:31:57,179 --> 00:31:58,679
key and you get some maybe some bad

823
00:31:58,679 --> 00:32:01,380
Randomness that's derived from this

824
00:32:01,380 --> 00:32:03,779
um from this key then it can end up

825
00:32:03,779 --> 00:32:05,340
distorting your ciphertext a little bit

826
00:32:05,340 --> 00:32:07,140
there might be too much noise present in

827
00:32:07,140 --> 00:32:09,539
it and so

828
00:32:09,539 --> 00:32:11,820
that can percolate throughout the the

829
00:32:11,820 --> 00:32:13,200
use of your system and you can actually

830
00:32:13,200 --> 00:32:15,299
fail this re-encryption track despite

831
00:32:15,299 --> 00:32:16,679
the fact that nothing has been tampered

832
00:32:16,679 --> 00:32:18,000
with and you know your message is

833
00:32:18,000 --> 00:32:21,720
received properly and you you the scheme

834
00:32:21,720 --> 00:32:22,860
will abort

835
00:32:22,860 --> 00:32:24,840
and and this abort if you can observe

836
00:32:24,840 --> 00:32:26,520
this this leaks the magnitude of the

837
00:32:26,520 --> 00:32:27,899
inner product between your secret key

838
00:32:27,899 --> 00:32:29,520
and the ciphertext that was sent over

839
00:32:29,520 --> 00:32:31,380
the wire

840
00:32:31,380 --> 00:32:33,419
um but this kind of attack is not very

841
00:32:33,419 --> 00:32:35,340
feasible parameters are usually set such

842
00:32:35,340 --> 00:32:37,020
that the probability of this bad event

843
00:32:37,020 --> 00:32:39,299
happening is

844
00:32:39,299 --> 00:32:42,179
uh so low that finding even one such

845
00:32:42,179 --> 00:32:45,419
event is as hard as brute forcing the

846
00:32:45,419 --> 00:32:46,500
key itself

847
00:32:46,500 --> 00:32:50,240
so usually you can't really do this

848
00:32:50,340 --> 00:32:52,200
um but what we found what we wanted to

849
00:32:52,200 --> 00:32:53,760
ask was well how can we make this

850
00:32:53,760 --> 00:32:55,799
failure event less rare

851
00:32:55,799 --> 00:32:57,960
and our idea was that we could use

852
00:32:57,960 --> 00:33:00,779
bitflips to raise the public key noise

853
00:33:00,779 --> 00:33:03,179
so if we you know take a hammer to Frodo

854
00:33:03,179 --> 00:33:04,620
and in fact

855
00:33:04,620 --> 00:33:08,100
during the key generation phase and

856
00:33:08,100 --> 00:33:09,600
poison this public key adds some

857
00:33:09,600 --> 00:33:12,360
additional noise to the public key this

858
00:33:12,360 --> 00:33:13,740
noise will percolate to wherever the

859
00:33:13,740 --> 00:33:17,460
public key is used in in the protocol

860
00:33:17,460 --> 00:33:21,960
and this reduces our Reliance on any bad

861
00:33:21,960 --> 00:33:23,279
Randomness you can make this failure

862
00:33:23,279 --> 00:33:25,559
event happen more often and so with just

863
00:33:25,559 --> 00:33:27,899
seven bit flips now we can make this

864
00:33:27,899 --> 00:33:29,760
failure event happen often enough that

865
00:33:29,760 --> 00:33:31,080
you know this attack becomes very

866
00:33:31,080 --> 00:33:33,120
feasible rather than you know possibly

867
00:33:33,120 --> 00:33:34,860
plain impossible with our current

868
00:33:34,860 --> 00:33:37,380
computational resources

869
00:33:37,380 --> 00:33:39,360
so then the question is well which seven

870
00:33:39,360 --> 00:33:42,179
bits do we actually need to flip this is

871
00:33:42,179 --> 00:33:43,740
a balancing act on your failure rate

872
00:33:43,740 --> 00:33:45,299
because you want this attack to be

873
00:33:45,299 --> 00:33:46,559
possible Right you want the failure rate

874
00:33:46,559 --> 00:33:47,760
to be high enough that you can actually

875
00:33:47,760 --> 00:33:49,919
get enough failures to recover your key

876
00:33:49,919 --> 00:33:51,899
but you want this attack to be

877
00:33:51,899 --> 00:33:53,640
undetectable to any honest users any

878
00:33:53,640 --> 00:33:54,840
honest users that are using the system

879
00:33:54,840 --> 00:33:57,360
with the poison key will have a higher

880
00:33:57,360 --> 00:33:59,100
observed failure rate and you want them

881
00:33:59,100 --> 00:34:01,919
to maybe dismiss it as network problems

882
00:34:01,919 --> 00:34:03,360
or other those sorts of things so the

883
00:34:03,360 --> 00:34:05,279
failure rate needs to be low enough uh

884
00:34:05,279 --> 00:34:07,679
such that it's undetectable

885
00:34:07,679 --> 00:34:10,260
and also in addition a higher failure

886
00:34:10,260 --> 00:34:11,460
rate also means that we actually get

887
00:34:11,460 --> 00:34:13,020
less information for failure I mean

888
00:34:13,020 --> 00:34:15,659
think about this uh you know the failure

889
00:34:15,659 --> 00:34:17,280
event becomes more more common so

890
00:34:17,280 --> 00:34:18,899
there's less actual information that's

891
00:34:18,899 --> 00:34:21,719
contained in such an event

892
00:34:21,719 --> 00:34:23,580
um but paradoxically actually it means

893
00:34:23,580 --> 00:34:26,219
that it actually takes less time overall

894
00:34:26,219 --> 00:34:28,260
total for us to do the attack the higher

895
00:34:28,260 --> 00:34:29,820
the failure rate is

896
00:34:29,820 --> 00:34:33,060
uh so what we found in in practice was

897
00:34:33,060 --> 00:34:35,760
that adding 256 to each column of the

898
00:34:35,760 --> 00:34:37,500
error increases the failure rate to a

899
00:34:37,500 --> 00:34:40,080
point where we felt comfortable with you

900
00:34:40,080 --> 00:34:42,540
know actually being able to execute the

901
00:34:42,540 --> 00:34:45,300
attack and where the

902
00:34:45,300 --> 00:34:47,699
uh failure rate for honest users is low

903
00:34:47,699 --> 00:34:49,679
enough such that they wouldn't

904
00:34:49,679 --> 00:34:51,899
um be able to detect it on a day-to-day

905
00:34:51,899 --> 00:34:53,699
basis

906
00:34:53,699 --> 00:34:56,820
so with that I you know again this is

907
00:34:56,820 --> 00:34:58,619
kind of the idea of a high level idea of

908
00:34:58,619 --> 00:35:00,420
our attack right so we're taking we're

909
00:35:00,420 --> 00:35:02,940
poising the public key and once we have

910
00:35:02,940 --> 00:35:05,520
done this and the failure decryption

911
00:35:05,520 --> 00:35:07,440
failure event is more common honest

912
00:35:07,440 --> 00:35:09,180
users are still able to communicate

913
00:35:09,180 --> 00:35:11,520
normally right I mean that's the key

914
00:35:11,520 --> 00:35:14,880
point of this this is once we've done

915
00:35:14,880 --> 00:35:16,980
this active um

916
00:35:16,980 --> 00:35:19,339
portion during key gen this now is long

917
00:35:19,339 --> 00:35:22,619
long-lived process and so we can still

918
00:35:22,619 --> 00:35:24,599
come wrong anytime as long as this key

919
00:35:24,599 --> 00:35:27,599
is being used and read off session keys

920
00:35:27,599 --> 00:35:29,280
and so for as long as the public key

921
00:35:29,280 --> 00:35:31,320
lives it's insecure

922
00:35:31,320 --> 00:35:33,300
and that's a really important part so

923
00:35:33,300 --> 00:35:34,560
like

924
00:35:34,560 --> 00:35:36,119
you have to be careful when you're using

925
00:35:36,119 --> 00:35:38,119
you know these long-term keys

926
00:35:38,119 --> 00:35:40,619
and so I will hand it over now to Andrew

927
00:35:40,619 --> 00:35:43,260
and he will discuss the rest

928
00:35:43,260 --> 00:35:45,839
oh thanks uh so for my half of the talk

929
00:35:45,839 --> 00:35:47,579
I'll be talking about um what the real

930
00:35:47,579 --> 00:35:49,380
Hammer effect is and how we use it to

931
00:35:49,380 --> 00:35:52,920
flip the exact bits that we wanted to

932
00:35:52,920 --> 00:35:54,540
so the row Hammer effect is a

933
00:35:54,540 --> 00:35:56,820
reliability bug in dram

934
00:35:56,820 --> 00:35:58,740
um that can potentially result in um

935
00:35:58,740 --> 00:36:01,820
fault injection attacks so uh we can

936
00:36:01,820 --> 00:36:04,200
illustrate it here we have a 2d grid of

937
00:36:04,200 --> 00:36:07,140
cells where each circle is a represents

938
00:36:07,140 --> 00:36:08,160
a single bit

939
00:36:08,160 --> 00:36:11,640
and uh if an attacker repeatedly

940
00:36:11,640 --> 00:36:14,160
accesses rows one and three

941
00:36:14,160 --> 00:36:14,820
um

942
00:36:14,820 --> 00:36:17,040
uh in quick succession this can actually

943
00:36:17,040 --> 00:36:18,599
result in bit flips in the middle around

944
00:36:18,599 --> 00:36:20,820
row two and

945
00:36:20,820 --> 00:36:22,440
um and note that this bit flip occurred

946
00:36:22,440 --> 00:36:24,240
across security domains this means that

947
00:36:24,240 --> 00:36:27,500
an attacker with

948
00:36:27,720 --> 00:36:31,320
with memory and um in rows one and three

949
00:36:31,320 --> 00:36:34,320
uh uh can actually potentially write to

950
00:36:34,320 --> 00:36:35,880
memory in row two which may belong to

951
00:36:35,880 --> 00:36:37,680
another process

952
00:36:37,680 --> 00:36:40,500
and when this corrupted data is

953
00:36:40,500 --> 00:36:41,760
requested

954
00:36:41,760 --> 00:36:43,740
the error percolates upwards and is

955
00:36:43,740 --> 00:36:46,200
visible to Software

956
00:36:46,200 --> 00:36:48,740
and so this is the basis for our uh

957
00:36:48,740 --> 00:36:52,020
poisoning of the photo cam key and a key

958
00:36:52,020 --> 00:36:54,839
property of hammer bit flips is that if

959
00:36:54,839 --> 00:36:57,180
a bit flips once it's likely flip again

960
00:36:57,180 --> 00:36:58,740
in the future upon future real hammering

961
00:36:58,740 --> 00:37:02,339
attempts and moreover uh that bit um

962
00:37:02,339 --> 00:37:03,480
will always flip in the same direction

963
00:37:03,480 --> 00:37:05,040
assuming that the machine has not been

964
00:37:05,040 --> 00:37:07,400
Rebooted

965
00:37:07,859 --> 00:37:09,960
so we called it our goal was to use real

966
00:37:09,960 --> 00:37:12,119
Hammer to increase the decryption

967
00:37:12,119 --> 00:37:14,640
failure rate on photocamp so to do this

968
00:37:14,640 --> 00:37:16,920
we chose to uh flip bits and add

969
00:37:16,920 --> 00:37:18,540
additional noise to an error Matrix

970
00:37:18,540 --> 00:37:21,180
called e used during key generation

971
00:37:21,180 --> 00:37:22,740
and ideally we want to flip a bit in

972
00:37:22,740 --> 00:37:25,260
each of the eight Columns of E

973
00:37:25,260 --> 00:37:27,540
um and and the bit flips need to be in

974
00:37:27,540 --> 00:37:30,240
very specific offsets this is because uh

975
00:37:30,240 --> 00:37:32,099
flipping a bit in the wrong offset will

976
00:37:32,099 --> 00:37:34,320
actually result in a near 100 decryption

977
00:37:34,320 --> 00:37:36,119
failure rate which ruins the attack

978
00:37:36,119 --> 00:37:37,800
so we want to whack all the moles

979
00:37:37,800 --> 00:37:40,740
without hitting any of the bombs

980
00:37:40,740 --> 00:37:42,240
um this is complicated because the bombs

981
00:37:42,240 --> 00:37:43,680
actually outnumber the moles by a factor

982
00:37:43,680 --> 00:37:45,300
of seven

983
00:37:45,300 --> 00:37:49,020
and as a result essentially we require

984
00:37:49,020 --> 00:37:51,060
very precise for hammering

985
00:37:51,060 --> 00:37:53,940
where we hit every mole but but don't

986
00:37:53,940 --> 00:37:56,579
hit a single bomb

987
00:37:56,579 --> 00:37:58,800
so uh to do that we had to First

988
00:37:58,800 --> 00:38:00,780
allocate or um our profile the machine

989
00:38:00,780 --> 00:38:02,880
and look for bit flips so that involves

990
00:38:02,880 --> 00:38:04,859
allocating a large chunk of memory and

991
00:38:04,859 --> 00:38:06,480
then iteratively hammering every row

992
00:38:06,480 --> 00:38:08,220
looking for bit flips and recording

993
00:38:08,220 --> 00:38:11,280
their Direction and their location

994
00:38:11,280 --> 00:38:13,320
uh and we eventually found a set of four

995
00:38:13,320 --> 00:38:16,440
suitable pages with a 256 bit clip and

996
00:38:16,440 --> 00:38:18,300
seven of the eight columns

997
00:38:18,300 --> 00:38:19,500
um eight of the eight would be

998
00:38:19,500 --> 00:38:20,820
preferable but I'll discuss how we

999
00:38:20,820 --> 00:38:23,040
overcame that in a second

1000
00:38:23,040 --> 00:38:24,660
another problem that we had to overcome

1001
00:38:24,660 --> 00:38:28,320
was that uh uh these same four pages

1002
00:38:28,320 --> 00:38:30,359
also had many intolerable bit flips

1003
00:38:30,359 --> 00:38:31,619
these are the bombs that we cannot

1004
00:38:31,619 --> 00:38:33,780
afford to accidentally flip

1005
00:38:33,780 --> 00:38:35,640
and the problem is that these bombs

1006
00:38:35,640 --> 00:38:38,339
actually share the um the same row with

1007
00:38:38,339 --> 00:38:40,200
the the moles that we want to whack so

1008
00:38:40,200 --> 00:38:42,420
when we Hammer the targeted bit flips

1009
00:38:42,420 --> 00:38:43,560
we're going to be unintentionally

1010
00:38:43,560 --> 00:38:45,480
hammering the the bits that we also

1011
00:38:45,480 --> 00:38:48,119
cannot tolerate flipping

1012
00:38:48,119 --> 00:38:50,160
so we overcame this with a bit

1013
00:38:50,160 --> 00:38:52,140
suppression technique which effectively

1014
00:38:52,140 --> 00:38:54,300
prevents bits from flipping even while

1015
00:38:54,300 --> 00:38:55,619
they are hammered

1016
00:38:55,619 --> 00:38:56,940
and in that manner we were able to

1017
00:38:56,940 --> 00:39:00,300
actually suppress 117 dead flips

1018
00:39:00,300 --> 00:39:02,880
so uh now that we have

1019
00:39:02,880 --> 00:39:04,920
um uh found a set of suitable pages with

1020
00:39:04,920 --> 00:39:06,720
big flips in the right locations and all

1021
00:39:06,720 --> 00:39:09,420
the bad bit flips suppressed we now need

1022
00:39:09,420 --> 00:39:11,880
to somehow uh Force the protocon victim

1023
00:39:11,880 --> 00:39:15,000
to use those pages to store its error

1024
00:39:15,000 --> 00:39:16,320
Matrix e

1025
00:39:16,320 --> 00:39:19,500
so it's Illustrated here uh the attacker

1026
00:39:19,500 --> 00:39:21,900
wants the four pages of e to land and

1027
00:39:21,900 --> 00:39:23,099
row two

1028
00:39:23,099 --> 00:39:25,980
so we brought a technique from the

1029
00:39:25,980 --> 00:39:28,200
ramblade paper that attacks the Linux

1030
00:39:28,200 --> 00:39:30,060
page frame cache

1031
00:39:30,060 --> 00:39:32,280
and at a super high level the way the

1032
00:39:32,280 --> 00:39:33,780
way it works is that the attacker first

1033
00:39:33,780 --> 00:39:36,180
deallocates the target pages

1034
00:39:36,180 --> 00:39:37,859
and then manipulates the page frame

1035
00:39:37,859 --> 00:39:39,660
cache and puts it in such a state that

1036
00:39:39,660 --> 00:39:42,900
when the victim makes a request to store

1037
00:39:42,900 --> 00:39:45,240
e it will actually land on the desired

1038
00:39:45,240 --> 00:39:47,479
pages

1039
00:39:47,700 --> 00:39:49,560
and now the attacker can repeatedly

1040
00:39:49,560 --> 00:39:52,740
access rails one and three uh and induce

1041
00:39:52,740 --> 00:39:55,700
bid flips in row two

1042
00:39:56,099 --> 00:39:58,380
so we were able to combine all of these

1043
00:39:58,380 --> 00:40:01,980
hammering techniques to perform a

1044
00:40:01,980 --> 00:40:03,780
successful end-to-end attack

1045
00:40:03,780 --> 00:40:06,000
uh very precise for a hammer attack

1046
00:40:06,000 --> 00:40:08,760
where we put all the bit flips we wanted

1047
00:40:08,760 --> 00:40:11,460
while managing to avoid flipping even a

1048
00:40:11,460 --> 00:40:13,820
single bomb

1049
00:40:13,820 --> 00:40:16,140
and this resulted in a decryption

1050
00:40:16,140 --> 00:40:18,480
failure rate of being about one in 2.7

1051
00:40:18,480 --> 00:40:19,380
million

1052
00:40:19,380 --> 00:40:21,000
which is sufficient that we after

1053
00:40:21,000 --> 00:40:23,640
generating um generate 665 000 failing

1054
00:40:23,640 --> 00:40:26,940
ciphertext uh over the course of 238 000

1055
00:40:26,940 --> 00:40:28,260
core hours

1056
00:40:28,260 --> 00:40:31,440
and by observing all these failures we

1057
00:40:31,440 --> 00:40:32,760
can actually extract seven of the eight

1058
00:40:32,760 --> 00:40:34,680
Columns of the secret

1059
00:40:34,680 --> 00:40:36,420
uh which then allows us to boot for

1060
00:40:36,420 --> 00:40:38,160
session keys in under two minutes on a

1061
00:40:38,160 --> 00:40:40,800
commodity laptop

1062
00:40:40,800 --> 00:40:43,859
great so uh so now I'd like to take a

1063
00:40:43,859 --> 00:40:45,540
second to discuss mitigations

1064
00:40:45,540 --> 00:40:47,579
uh for that attack

1065
00:40:47,579 --> 00:40:49,079
so

1066
00:40:49,079 --> 00:40:51,420
um a uh a key component of our attack

1067
00:40:51,420 --> 00:40:53,220
was that we need to have a long enough

1068
00:40:53,220 --> 00:40:56,760
uh window of time to flip bits and E

1069
00:40:56,760 --> 00:40:58,440
H and to do that we performed a

1070
00:40:58,440 --> 00:41:00,480
performance degradation attack on the

1071
00:41:00,480 --> 00:41:02,339
shake hash function to extend the amount

1072
00:41:02,339 --> 00:41:05,099
of time that the attacker can um a row

1073
00:41:05,099 --> 00:41:07,619
Hammer bit flips so one way to mitigate

1074
00:41:07,619 --> 00:41:10,440
this is actually um uh reduce that

1075
00:41:10,440 --> 00:41:12,480
window by using perhaps a hardware

1076
00:41:12,480 --> 00:41:14,640
accelerator hash function maybe asni

1077
00:41:14,640 --> 00:41:17,339
which is much harder to uh perform to

1078
00:41:17,339 --> 00:41:19,079
perform a performance degree degradation

1079
00:41:19,079 --> 00:41:21,480
attack against

1080
00:41:21,480 --> 00:41:23,760
another option is to actually resequence

1081
00:41:23,760 --> 00:41:26,099
some operations so

1082
00:41:26,099 --> 00:41:28,920
um a can be fully expanded before e and

1083
00:41:28,920 --> 00:41:32,060
s are generated which leaves NS

1084
00:41:32,060 --> 00:41:34,200
vulnerable to hammering for a shorter

1085
00:41:34,200 --> 00:41:35,700
amount of time

1086
00:41:35,700 --> 00:41:37,980
and also uh we want to generate all the

1087
00:41:37,980 --> 00:41:41,040
randomness uh before sampling sne uh

1088
00:41:41,040 --> 00:41:44,579
again uh sne uh the result is that sne

1089
00:41:44,579 --> 00:41:46,560
are vulnerable in memory for a shorter

1090
00:41:46,560 --> 00:41:48,380
period of time

1091
00:41:48,380 --> 00:41:50,520
and then also it would be great if we

1092
00:41:50,520 --> 00:41:52,740
can verify that the public key has been

1093
00:41:52,740 --> 00:41:53,880
uh sampled from the correct

1094
00:41:53,880 --> 00:41:55,680
distributions

1095
00:41:55,680 --> 00:41:58,020
um and and uh so one way to do that is

1096
00:41:58,020 --> 00:41:59,760
we can you know increase the size of the

1097
00:41:59,760 --> 00:42:03,480
secret key uh by storing e as part of it

1098
00:42:03,480 --> 00:42:06,960
um and then uh uh we can verify that e

1099
00:42:06,960 --> 00:42:08,760
has an appropriate amount of noise in it

1100
00:42:08,760 --> 00:42:12,180
another idea is to use Randomness to

1101
00:42:12,180 --> 00:42:15,060
generate the uh the public key twice and

1102
00:42:15,060 --> 00:42:16,920
verify that the outcome is the same both

1103
00:42:16,920 --> 00:42:19,160
times

1104
00:42:19,920 --> 00:42:22,980
so in conclusion uh we showed how um to

1105
00:42:22,980 --> 00:42:24,900
do an internet check that allows the

1106
00:42:24,900 --> 00:42:27,480
attacker to brute force uh session keys

1107
00:42:27,480 --> 00:42:28,740
in under two minutes on a commodity

1108
00:42:28,740 --> 00:42:29,700
laptop

1109
00:42:29,700 --> 00:42:31,800
and the the poisoning is done in a way

1110
00:42:31,800 --> 00:42:33,660
that's actually undetectable after um

1111
00:42:33,660 --> 00:42:36,359
after the key is generated and uh the

1112
00:42:36,359 --> 00:42:38,220
key is compromised for the remainder of

1113
00:42:38,220 --> 00:42:39,359
its life

1114
00:42:39,359 --> 00:42:41,520
and in this way we demonstrated the

1115
00:42:41,520 --> 00:42:43,140
first practical failure boosting attack

1116
00:42:43,140 --> 00:42:45,300
against the post Quantum cam

1117
00:42:45,300 --> 00:42:46,619
and with that we're happy to take

1118
00:42:46,619 --> 00:42:48,800
questions

1119
00:42:49,050 --> 00:42:57,780
[Applause]

1120
00:42:57,780 --> 00:42:59,640
if you have any question please queue up

1121
00:42:59,640 --> 00:43:01,740
to the microphone

1122
00:43:01,740 --> 00:43:05,899
I don't think any question on Zoom

1123
00:43:08,700 --> 00:43:11,160
if the the microphones if you want to

1124
00:43:11,160 --> 00:43:13,440
ask questions in person I think

1125
00:43:13,440 --> 00:43:14,700
yeah you have to walk up to the

1126
00:43:14,700 --> 00:43:17,118
microphone

1127
00:43:25,800 --> 00:43:28,500
ah hello my name is okay

1128
00:43:28,500 --> 00:43:29,760
um thank you very much for the very

1129
00:43:29,760 --> 00:43:32,339
interesting talk I noticed that you

1130
00:43:32,339 --> 00:43:35,700
mentioned uh 380 000 core hours to get

1131
00:43:35,700 --> 00:43:38,160
the errors so I was wondering um how

1132
00:43:38,160 --> 00:43:40,800
that impacts you know

1133
00:43:40,800 --> 00:43:44,160
um the feasibility or the actual

1134
00:43:44,160 --> 00:43:47,400
attack and how you shorten that amount

1135
00:43:47,400 --> 00:43:49,700
of time

1136
00:43:50,060 --> 00:43:52,800
it's a fundamental limitation in terms

1137
00:43:52,800 --> 00:43:53,640
of

1138
00:43:53,640 --> 00:43:55,140
um

1139
00:43:55,140 --> 00:43:57,240
the fact that because of the you know

1140
00:43:57,240 --> 00:43:59,040
Fujisaki okomotive transform the actual

1141
00:43:59,040 --> 00:44:00,780
CCA transform you have to generate all

1142
00:44:00,780 --> 00:44:03,660
of these ciphertexts honestly uh if you

1143
00:44:03,660 --> 00:44:05,160
didn't have to do that you could you

1144
00:44:05,160 --> 00:44:06,119
wouldn't have to do so much

1145
00:44:06,119 --> 00:44:07,859
pre-processing

1146
00:44:07,859 --> 00:44:09,599
um you have to honestly search for

1147
00:44:09,599 --> 00:44:12,720
failing ciphertexts and so

1148
00:44:12,720 --> 00:44:14,660
hey

1149
00:44:14,660 --> 00:44:17,099
the higher the failure rate actually is

1150
00:44:17,099 --> 00:44:18,780
when some of the analysis that we've

1151
00:44:18,780 --> 00:44:22,020
done uh the less time you'll actually

1152
00:44:22,020 --> 00:44:23,940
need to do this pre-processing but then

1153
00:44:23,940 --> 00:44:26,520
the you run the risk of the attack being

1154
00:44:26,520 --> 00:44:30,180
detected okay so it's pre-processing and

1155
00:44:30,180 --> 00:44:32,280
not the actual

1156
00:44:32,280 --> 00:44:34,980
uh correct so like if we were able to

1157
00:44:34,980 --> 00:44:37,800
flip bits in all eight of the columns um

1158
00:44:37,800 --> 00:44:39,300
that just kind of depends on your

1159
00:44:39,300 --> 00:44:41,280
computer uh whatever Target machine that

1160
00:44:41,280 --> 00:44:42,480
you're looking at might have suitable

1161
00:44:42,480 --> 00:44:44,040
Pages where you'll actually have bit

1162
00:44:44,040 --> 00:44:45,480
flips in all of the eight columns that

1163
00:44:45,480 --> 00:44:47,339
you would need and then if you can do

1164
00:44:47,339 --> 00:44:50,220
that then that pre-processing step would

1165
00:44:50,220 --> 00:44:52,740
just recover the master Secret

1166
00:44:52,740 --> 00:44:54,420
um it's we're trying we're recovering

1167
00:44:54,420 --> 00:44:56,160
basically seven of the eight Columns of

1168
00:44:56,160 --> 00:44:57,839
the secret key and then when you use

1169
00:44:57,839 --> 00:45:00,359
that in the decoding process it leaves

1170
00:45:00,359 --> 00:45:02,160
only two to the 16 possible combinations

1171
00:45:02,160 --> 00:45:03,660
for your shared Secret

1172
00:45:03,660 --> 00:45:05,640
and so we're able to Brute Force those

1173
00:45:05,640 --> 00:45:07,380
16 bits

1174
00:45:07,380 --> 00:45:08,940
um but if we had all eight all eight

1175
00:45:08,940 --> 00:45:11,220
columns we could just get the master

1176
00:45:11,220 --> 00:45:13,740
secret key so if it's a long term a

1177
00:45:13,740 --> 00:45:15,780
long-term secret then we can we don't

1178
00:45:15,780 --> 00:45:17,280
have to do anything else

1179
00:45:17,280 --> 00:45:19,079
I think one of the parts maybe you were

1180
00:45:19,079 --> 00:45:19,920
confused about is that the

1181
00:45:19,920 --> 00:45:22,380
pre-processing step only happens once

1182
00:45:22,380 --> 00:45:24,000
um so it's not too much implementation

1183
00:45:24,000 --> 00:45:26,220
because after you do it one time then

1184
00:45:26,220 --> 00:45:28,859
going forward uh you can put for us any

1185
00:45:28,859 --> 00:45:32,420
uh session keys in just two minutes each

1186
00:45:33,260 --> 00:45:36,060
yeah thank you I think I was confused I

1187
00:45:36,060 --> 00:45:37,980
thought that that's how much time you

1188
00:45:37,980 --> 00:45:41,520
needed to inject The Faults so oh okay

1189
00:45:41,520 --> 00:45:43,800
great you know the fault is done in like

1190
00:45:43,800 --> 00:45:45,660
under a second under on during key gen

1191
00:45:45,660 --> 00:45:48,000
so it's okay yeah thank you that was my

1192
00:45:48,000 --> 00:45:50,359
confusion

1193
00:45:54,119 --> 00:45:55,560
oh okay

1194
00:45:55,560 --> 00:45:59,040
um is that distribution of of

1195
00:45:59,040 --> 00:46:01,380
um Ro Hammer I don't know attack ability

1196
00:46:01,380 --> 00:46:03,839
is that common or do you have to look

1197
00:46:03,839 --> 00:46:05,579
through several different laptops to

1198
00:46:05,579 --> 00:46:08,160
find one that was suitable

1199
00:46:08,160 --> 00:46:09,300
um

1200
00:46:09,300 --> 00:46:12,599
it's actually the the large majority of

1201
00:46:12,599 --> 00:46:16,020
um uh DRM uh Hardware reason that we

1202
00:46:16,020 --> 00:46:19,079
inspected do uh yield quite a bit uh

1203
00:46:19,079 --> 00:46:21,000
quite a few bit flips

1204
00:46:21,000 --> 00:46:23,460
um you know the amount that the yield uh

1205
00:46:23,460 --> 00:46:25,800
varies of course

1206
00:46:25,800 --> 00:46:27,800
um

1207
00:46:28,440 --> 00:46:31,560
um yeah it's actually quite uncommon to

1208
00:46:31,560 --> 00:46:33,540
find one that will not yield or Hammer

1209
00:46:33,540 --> 00:46:35,040
bed flips

1210
00:46:35,040 --> 00:46:37,400
thanks

1211
00:46:38,599 --> 00:46:41,880
thanks for your impressive presentation

1212
00:46:41,880 --> 00:46:44,640
um the question what um the dram

1213
00:46:44,640 --> 00:46:46,800
manufacturers tell us that they have now

1214
00:46:46,800 --> 00:46:48,420
counter measures in their memory

1215
00:46:48,420 --> 00:46:51,060
controllers against row Hammer so which

1216
00:46:51,060 --> 00:46:54,240
generation drams do you use

1217
00:46:54,240 --> 00:46:56,280
sure uh so for our experiments we use

1218
00:46:56,280 --> 00:46:57,900
DDR3

1219
00:46:57,900 --> 00:47:00,060
um and yeah it is true that ddr4 uh they

1220
00:47:00,060 --> 00:47:01,859
introduced trr

1221
00:47:01,859 --> 00:47:03,960
um but it's also been demonstrated that

1222
00:47:03,960 --> 00:47:07,260
um uh trr can't be bypassed and uh they

1223
00:47:07,260 --> 00:47:08,700
actually exhibit more bit flips per

1224
00:47:08,700 --> 00:47:11,700
amount of memory than DDR3 did

1225
00:47:11,700 --> 00:47:13,680
um and so ddr5 is you know the newest

1226
00:47:13,680 --> 00:47:16,260
one that has hit the market and it is

1227
00:47:16,260 --> 00:47:18,480
still an open question as to um uh how

1228
00:47:18,480 --> 00:47:21,359
vulnerable ddr5 is to go hammer okay so

1229
00:47:21,359 --> 00:47:22,400
it

1230
00:47:22,400 --> 00:47:25,560
remainski thank you

1231
00:47:25,560 --> 00:47:28,578
very quick question

1232
00:47:29,520 --> 00:47:31,859
um so what kind of attack attack or

1233
00:47:31,859 --> 00:47:33,420
Vantage Point does the attacker have to

1234
00:47:33,420 --> 00:47:35,819
have during key generation like could it

1235
00:47:35,819 --> 00:47:37,260
be a root kit or does it have to be the

1236
00:47:37,260 --> 00:47:39,540
server owner like how much pre like

1237
00:47:39,540 --> 00:47:41,220
pre-profiling of the machine has to

1238
00:47:41,220 --> 00:47:43,399
happen

1239
00:47:43,560 --> 00:47:45,720
um I believe that the attacker just

1240
00:47:45,720 --> 00:47:46,920
needs

1241
00:47:46,920 --> 00:47:48,780
to be able to access the memory space

1242
00:47:48,780 --> 00:47:51,660
wherever the victim process lives so

1243
00:47:51,660 --> 00:47:54,300
they it if you know they're working in

1244
00:47:54,300 --> 00:47:55,800
say a cloud environment and the virtual

1245
00:47:55,800 --> 00:47:56,819
machines are not provisioned

1246
00:47:56,819 --> 00:47:59,480
particularly securely and you know

1247
00:47:59,480 --> 00:48:02,400
multiple host processes can you know mix

1248
00:48:02,400 --> 00:48:04,020
and match in different in the same

1249
00:48:04,020 --> 00:48:06,560
section of ram then you you know

1250
00:48:06,560 --> 00:48:08,640
theoretically speaking you could do it

1251
00:48:08,640 --> 00:48:10,440
across VM boundaries and I think there

1252
00:48:10,440 --> 00:48:12,300
have been some papers that have

1253
00:48:12,300 --> 00:48:14,520
discussed doing such attacks yeah

1254
00:48:14,520 --> 00:48:16,380
well quickly there is no attempt to

1255
00:48:16,380 --> 00:48:18,839
partition dram geometrically separately

1256
00:48:18,839 --> 00:48:19,800
from each other

1257
00:48:19,800 --> 00:48:20,460
um

1258
00:48:20,460 --> 00:48:22,020
and like in a cloud computing

1259
00:48:22,020 --> 00:48:24,800
environment so

1260
00:48:26,520 --> 00:48:28,280
okay let's think the speakers again

1261
00:48:28,280 --> 00:48:37,219
[Applause]

1262
00:48:43,500 --> 00:48:45,240
and we will have the final Talk of the

1263
00:48:45,240 --> 00:48:47,220
session which is about Lessons Learned

1264
00:48:47,220 --> 00:48:49,680
From protecting chrysalis delithium

1265
00:48:49,680 --> 00:48:51,960
and the speaker will be the PS Schneider

1266
00:48:51,960 --> 00:48:56,520
yeah thanks Stefan so

1267
00:48:56,520 --> 00:48:59,579
uh what is this one

1268
00:48:59,579 --> 00:49:01,740
okay perfect so before I go into the

1269
00:49:01,740 --> 00:49:04,680
lessons learned from our case study let

1270
00:49:04,680 --> 00:49:06,720
me start with re-motivation on why you

1271
00:49:06,720 --> 00:49:07,980
want to protect Elysium in the first

1272
00:49:07,980 --> 00:49:09,960
place so it's probably all of you know

1273
00:49:09,960 --> 00:49:12,119
this has chosen Elysium as one of the

1274
00:49:12,119 --> 00:49:14,220
winners of the post Quantum computation

1275
00:49:14,220 --> 00:49:16,440
and among the digital signatures winners

1276
00:49:16,440 --> 00:49:18,839
it's the one more suited for our

1277
00:49:18,839 --> 00:49:21,660
embedded applications so we as an XP and

1278
00:49:21,660 --> 00:49:22,859
others in a semiconductor industry

1279
00:49:22,859 --> 00:49:23,780
already

1280
00:49:23,780 --> 00:49:26,339
looking how we can maybe transition our

1281
00:49:26,339 --> 00:49:28,800
future devices to support Elysium even

1282
00:49:28,800 --> 00:49:30,780
though the standard will only release in

1283
00:49:30,780 --> 00:49:34,079
2024. because any like delay in this in

1284
00:49:34,079 --> 00:49:35,339
this process could like potentially

1285
00:49:35,339 --> 00:49:37,560
impact billions of devices especially in

1286
00:49:37,560 --> 00:49:41,220
industrial iot and in Automotive

1287
00:49:41,220 --> 00:49:43,079
so we have seen in the in the earlier

1288
00:49:43,079 --> 00:49:44,640
two talks that uh yeah cryptograph

1289
00:49:44,640 --> 00:49:46,140
implementations are vulnerable to

1290
00:49:46,140 --> 00:49:49,260
physical attacks so we only we not only

1291
00:49:49,260 --> 00:49:51,000
have to look into how we can run pcno

1292
00:49:51,000 --> 00:49:53,460
devices but how we can run

1293
00:49:53,460 --> 00:49:55,319
um pqc hard and against these physical

1294
00:49:55,319 --> 00:49:57,780
attacks on all devices

1295
00:49:57,780 --> 00:50:00,540
um since deletion is quite new uh this

1296
00:50:00,540 --> 00:50:01,800
protection could actually require a

1297
00:50:01,800 --> 00:50:04,140
significant effort um and then threaten

1298
00:50:04,140 --> 00:50:06,300
to delay this diploma deployment that

1299
00:50:06,300 --> 00:50:08,220
we've seen on the previous slide

1300
00:50:08,220 --> 00:50:10,140
that this is a problem

1301
00:50:10,140 --> 00:50:12,480
um was already shown for for Kaiba

1302
00:50:12,480 --> 00:50:14,099
before so last year we got crypto we had

1303
00:50:14,099 --> 00:50:16,740
a talk uh highlighting the extreme

1304
00:50:16,740 --> 00:50:18,720
attack potential and then in the first

1305
00:50:18,720 --> 00:50:21,300
talk of today A high secure

1306
00:50:21,300 --> 00:50:22,800
implementation of car was broken using

1307
00:50:22,800 --> 00:50:24,240
search contacts

1308
00:50:24,240 --> 00:50:25,079
um

1309
00:50:25,079 --> 00:50:27,240
so yeah there was found to be extremely

1310
00:50:27,240 --> 00:50:29,300
vulnerable

1311
00:50:29,300 --> 00:50:31,560
situations a bit less clear because

1312
00:50:31,560 --> 00:50:32,819
there's been less investigated than

1313
00:50:32,819 --> 00:50:33,839
context

1314
00:50:33,839 --> 00:50:35,339
and that's basically what this talk is

1315
00:50:35,339 --> 00:50:37,619
about uh what kind of lessons did you

1316
00:50:37,619 --> 00:50:40,079
learn from trying to implement the

1317
00:50:40,079 --> 00:50:41,880
lithium hardened against such analysis

1318
00:50:41,880 --> 00:50:45,619
on all embedded devices

1319
00:50:45,660 --> 00:50:47,640
so now that we established if you want

1320
00:50:47,640 --> 00:50:49,380
to implement protected delicium um yeah

1321
00:50:49,380 --> 00:50:51,000
before it has a look had a look at

1322
00:50:51,000 --> 00:50:53,220
literature if it was already known how

1323
00:50:53,220 --> 00:50:55,740
to protect Elysium um and surprisingly

1324
00:50:55,740 --> 00:50:58,140
we found few Publications especially

1325
00:50:58,140 --> 00:51:00,180
compared to kyber so you can see that

1326
00:51:00,180 --> 00:51:02,640
until October 2022 there was basically

1327
00:51:02,640 --> 00:51:04,980
only one publication that dealt with um

1328
00:51:04,980 --> 00:51:07,859
masking the whole delicium which was by

1329
00:51:07,859 --> 00:51:09,960
million

1330
00:51:09,960 --> 00:51:11,819
um just also this is also what we took

1331
00:51:11,819 --> 00:51:13,140
as a starting point

1332
00:51:13,140 --> 00:51:14,700
um to basically look into these

1333
00:51:14,700 --> 00:51:16,859
questions so we wanted to check what

1334
00:51:16,859 --> 00:51:18,240
needs to be protected how that can be

1335
00:51:18,240 --> 00:51:20,280
done and then maybe try to identify the

1336
00:51:20,280 --> 00:51:22,440
bottlenecks and how to fix them

1337
00:51:22,440 --> 00:51:24,240
since this talk is quite brief I cannot

1338
00:51:24,240 --> 00:51:25,920
go into detail on all of these questions

1339
00:51:25,920 --> 00:51:27,359
um but we also have a report on e-print

1340
00:51:27,359 --> 00:51:28,859
together with the team and we used to

1341
00:51:28,859 --> 00:51:31,380
live on if you want more details maybe

1342
00:51:31,380 --> 00:51:33,359
brief note there will be an update in I

1343
00:51:33,359 --> 00:51:34,859
think two to three weeks so maybe if you

1344
00:51:34,859 --> 00:51:38,660
want to read it wait for that

1345
00:51:39,480 --> 00:51:41,400
okay so maybe let's start with the what

1346
00:51:41,400 --> 00:51:43,079
so what needs to be protected so here

1347
00:51:43,079 --> 00:51:45,240
you can see the signing operation of the

1348
00:51:45,240 --> 00:51:47,579
lithium that consists of like multiple

1349
00:51:47,579 --> 00:51:49,260
modules that I work together to produce

1350
00:51:49,260 --> 00:51:51,540
a final signature so it's not important

1351
00:51:51,540 --> 00:51:53,880
what each of these blocks do but maybe

1352
00:51:53,880 --> 00:51:56,099
just to understand that not all of these

1353
00:51:56,099 --> 00:51:57,839
blocks can be attacked equally and

1354
00:51:57,839 --> 00:51:59,819
that's why they also not everything need

1355
00:51:59,819 --> 00:52:03,300
to be protected on on the same level

1356
00:52:03,300 --> 00:52:05,160
so if you look at the sensitivity

1357
00:52:05,160 --> 00:52:07,800
analysis from PI work you can see here

1358
00:52:07,800 --> 00:52:09,960
that the orange boxes indicate the

1359
00:52:09,960 --> 00:52:11,579
modules that are like vulnerable to

1360
00:52:11,579 --> 00:52:13,859
attacks and that needs to be protected

1361
00:52:13,859 --> 00:52:16,440
against Cyclone attacks so in the first

1362
00:52:16,440 --> 00:52:18,180
step we have to look if we can maybe

1363
00:52:18,180 --> 00:52:20,160
verify that mapping and try to improve

1364
00:52:20,160 --> 00:52:22,440
upon it because on the one hand you

1365
00:52:22,440 --> 00:52:23,460
don't want to protect too much because

1366
00:52:23,460 --> 00:52:25,920
then it becomes inefficient you also

1367
00:52:25,920 --> 00:52:27,059
don't want to protect too little because

1368
00:52:27,059 --> 00:52:30,240
then it might become insecure

1369
00:52:30,240 --> 00:52:32,099
and the first thing that we basically

1370
00:52:32,099 --> 00:52:33,960
noticed was um

1371
00:52:33,960 --> 00:52:36,020
that initially W was not protected

1372
00:52:36,020 --> 00:52:38,160
however yeah it can be shown that if you

1373
00:52:38,160 --> 00:52:40,140
know W and a which is part of the public

1374
00:52:40,140 --> 00:52:43,260
key you can recover information about Y

1375
00:52:43,260 --> 00:52:46,980
which makes W sensitive and therefore

1376
00:52:46,980 --> 00:52:50,099
this part also needs to be orange

1377
00:52:50,099 --> 00:52:53,160
then on the other hand we had to look at

1378
00:52:53,160 --> 00:52:55,079
R and the subsequent operations of r

1379
00:52:55,079 --> 00:52:56,640
that are compute the synth at the bottom

1380
00:52:56,640 --> 00:52:58,020
right

1381
00:52:58,020 --> 00:53:00,599
um to maybe understand this reasoning I

1382
00:53:00,599 --> 00:53:02,460
maybe should first introduce that the

1383
00:53:02,460 --> 00:53:04,740
Elysium uses some kind of rejection

1384
00:53:04,740 --> 00:53:06,020
checks

1385
00:53:06,020 --> 00:53:08,880
that kind of influence the sensitivity

1386
00:53:08,880 --> 00:53:10,980
of some internal values so the easiest

1387
00:53:10,980 --> 00:53:12,780
example is that which is initially

1388
00:53:12,780 --> 00:53:14,520
sensitive and needs to be protected

1389
00:53:14,520 --> 00:53:17,880
however after the security critical

1390
00:53:17,880 --> 00:53:19,380
checks have passed it can be made public

1391
00:53:19,380 --> 00:53:21,300
and it's given out as part of the

1392
00:53:21,300 --> 00:53:22,319
signature

1393
00:53:22,319 --> 00:53:24,660
since utility can be derived from that

1394
00:53:24,660 --> 00:53:26,640
using only public values the same should

1395
00:53:26,640 --> 00:53:28,160
hold for r as well

1396
00:53:28,160 --> 00:53:31,260
so we found that once you do the checks

1397
00:53:31,260 --> 00:53:33,000
on that and error you can basically

1398
00:53:33,000 --> 00:53:35,280
unmask that and then do all of these pin

1399
00:53:35,280 --> 00:53:37,140
computations on public values to make it

1400
00:53:37,140 --> 00:53:39,799
a bit more efficient

1401
00:53:39,839 --> 00:53:41,819
so our updated sensitivity analysis

1402
00:53:41,819 --> 00:53:43,260
looks like this so at the top we have

1403
00:53:43,260 --> 00:53:45,240
this additional runs box and at the

1404
00:53:45,240 --> 00:53:48,119
bottom we removed one which makes it a

1405
00:53:48,119 --> 00:53:49,500
bit more efficient

1406
00:53:49,500 --> 00:53:51,420
so if you also notice there's like a

1407
00:53:51,420 --> 00:53:54,240
blue box at top which is about a W1

1408
00:53:54,240 --> 00:53:56,220
so if you were yesterday at Ruble post

1409
00:53:56,220 --> 00:53:57,720
content of crypto you might have already

1410
00:53:57,720 --> 00:54:01,079
heard a badim talk about that so it's

1411
00:54:01,079 --> 00:54:02,420
basically known

1412
00:54:02,420 --> 00:54:05,280
for valid signatures that we can make W1

1413
00:54:05,280 --> 00:54:07,500
public so it's not doesn't need to be

1414
00:54:07,500 --> 00:54:09,359
protected however for rejected

1415
00:54:09,359 --> 00:54:10,680
signatures is less clear and we don't

1416
00:54:10,680 --> 00:54:13,800
have a uh like a proper proof however

1417
00:54:13,800 --> 00:54:16,319
the feeling is that it's um that is not

1418
00:54:16,319 --> 00:54:18,300
as critical and then like no attacks

1419
00:54:18,300 --> 00:54:20,220
possible so it might be okay to just

1420
00:54:20,220 --> 00:54:23,000
leave it unprotected

1421
00:54:23,880 --> 00:54:26,099
so okay now that we established what we

1422
00:54:26,099 --> 00:54:27,240
want to protect

1423
00:54:27,240 --> 00:54:30,359
um yeah the the standard way to protect

1424
00:54:30,359 --> 00:54:32,119
us basically masking

1425
00:54:32,119 --> 00:54:35,880
and as kyber Elysium also requires two

1426
00:54:35,880 --> 00:54:37,980
like two different types of masking so

1427
00:54:37,980 --> 00:54:40,559
Boolean which you can see in red for the

1428
00:54:40,559 --> 00:54:42,359
the catcher operations and then orange

1429
00:54:42,359 --> 00:54:44,640
which is aromatic masking for the for

1430
00:54:44,640 --> 00:54:46,740
the elastic arithmetic

1431
00:54:46,740 --> 00:54:49,140
but maybe important to note here that um

1432
00:54:49,140 --> 00:54:51,900
it uses a prime modulus which in general

1433
00:54:51,900 --> 00:54:54,300
makes masking a bit uh yeah less less

1434
00:54:54,300 --> 00:54:56,400
efficient and it also kind of makes some

1435
00:54:56,400 --> 00:54:58,380
of the internal computation a bit less

1436
00:54:58,380 --> 00:55:00,780
efficient and this was actually already

1437
00:55:00,780 --> 00:55:02,940
benchmarked in Prior work where they

1438
00:55:02,940 --> 00:55:04,319
font by switching from a prime to a

1439
00:55:04,319 --> 00:55:06,720
power to modulus they could gain like

1440
00:55:06,720 --> 00:55:09,000
effect of of seven to nine as a speed up

1441
00:55:09,000 --> 00:55:11,579
but since this would yeah significantly

1442
00:55:11,579 --> 00:55:13,859
out of the the underlying scheme we

1443
00:55:13,859 --> 00:55:17,119
didn't consider this any further

1444
00:55:17,280 --> 00:55:20,280
then the second operation that we found

1445
00:55:20,280 --> 00:55:22,079
is that basically the deterministic

1446
00:55:22,079 --> 00:55:23,400
variant is much more vulnerable than the

1447
00:55:23,400 --> 00:55:25,140
randomized Elysium um

1448
00:55:25,140 --> 00:55:27,359
against physical attacks

1449
00:55:27,359 --> 00:55:30,000
so maybe just for for context or in a

1450
00:55:30,000 --> 00:55:32,700
dynamistic version the

1451
00:55:32,700 --> 00:55:35,280
in the uh

1452
00:55:35,280 --> 00:55:37,559
or prime seed is deterministically

1453
00:55:37,559 --> 00:55:39,000
derived from the message and the

1454
00:55:39,000 --> 00:55:41,460
long-term secret K so for the for fixed

1455
00:55:41,460 --> 00:55:42,660
messaging a fixed key you would always

1456
00:55:42,660 --> 00:55:45,300
get the same valid signature but in the

1457
00:55:45,300 --> 00:55:47,640
randomized case this seed is an true

1458
00:55:47,640 --> 00:55:49,280
randomly generated

1459
00:55:49,280 --> 00:55:51,300
which which has some beneficial

1460
00:55:51,300 --> 00:55:53,160
properties for site General analysis

1461
00:55:53,160 --> 00:55:54,839
so on the one hand we don't have to

1462
00:55:54,839 --> 00:55:56,099
store

1463
00:55:56,099 --> 00:55:59,640
um another long-term secretk which helps

1464
00:55:59,640 --> 00:56:01,980
us to maybe save a bit on on memory and

1465
00:56:01,980 --> 00:56:03,540
also on this protected area where the

1466
00:56:03,540 --> 00:56:04,859
key start

1467
00:56:04,859 --> 00:56:06,900
but more importantly

1468
00:56:06,900 --> 00:56:07,619
um

1469
00:56:07,619 --> 00:56:09,960
since the same message with the same key

1470
00:56:09,960 --> 00:56:11,520
always produces the same signature for

1471
00:56:11,520 --> 00:56:14,000
the legitimacy version we can basically

1472
00:56:14,000 --> 00:56:17,400
repeat all measurements and that helps

1473
00:56:17,400 --> 00:56:19,500
to actually improve the situentext as we

1474
00:56:19,500 --> 00:56:21,720
also saw in the first talk today

1475
00:56:21,720 --> 00:56:23,420
and then maybe

1476
00:56:23,420 --> 00:56:26,220
related to that also the same holes of

1477
00:56:26,220 --> 00:56:27,900
all the texts that yeah certain photo

1478
00:56:27,900 --> 00:56:29,220
texts are only possible on the data

1479
00:56:29,220 --> 00:56:31,440
Mexico variant by the randomized version

1480
00:56:31,440 --> 00:56:33,660
is then inherently protected against

1481
00:56:33,660 --> 00:56:35,960
them

1482
00:56:36,359 --> 00:56:39,000
okay so okay we have established now

1483
00:56:39,000 --> 00:56:40,020
what we want to protect and how do we

1484
00:56:40,020 --> 00:56:41,700
want to protect it

1485
00:56:41,700 --> 00:56:43,440
um now I will give you some performance

1486
00:56:43,440 --> 00:56:44,160
numbers

1487
00:56:44,160 --> 00:56:46,680
so these are the cycles on an M4 for the

1488
00:56:46,680 --> 00:56:48,420
data vanistic and the randomized version

1489
00:56:48,420 --> 00:56:51,900
for increasing security orders

1490
00:56:51,900 --> 00:56:54,420
and on the first look it seems that yeah

1491
00:56:54,420 --> 00:56:56,040
the diminishing randomizes kind of like

1492
00:56:56,040 --> 00:56:57,240
comparable performance for the same

1493
00:56:57,240 --> 00:56:58,380
security order

1494
00:56:58,380 --> 00:57:00,319
but FPS established earlier

1495
00:57:00,319 --> 00:57:02,220
deterministic is more vulnerable so we

1496
00:57:02,220 --> 00:57:04,200
need to go up in in the security order

1497
00:57:04,200 --> 00:57:07,380
so if we want to switch from uh for

1498
00:57:07,380 --> 00:57:09,180
example two to order four that would

1499
00:57:09,180 --> 00:57:13,260
introduce a Slowdown of a factor of 2.8

1500
00:57:13,260 --> 00:57:16,680
note that not only the the yeah the

1501
00:57:16,680 --> 00:57:18,180
runtime is impacted by this change but

1502
00:57:18,180 --> 00:57:19,680
also the memory requirements because you

1503
00:57:19,680 --> 00:57:21,660
need to store my chair need to store

1504
00:57:21,660 --> 00:57:23,640
more shares

1505
00:57:23,640 --> 00:57:25,380
um which makes it actually much more

1506
00:57:25,380 --> 00:57:26,819
difficult because the list even generous

1507
00:57:26,819 --> 00:57:28,800
already quite difficult to implement on

1508
00:57:28,800 --> 00:57:31,880
memory constraint devices

1509
00:57:32,460 --> 00:57:34,260
um yeah so what's the bottleneck so as

1510
00:57:34,260 --> 00:57:35,400
you can see a protected cat track

1511
00:57:35,400 --> 00:57:37,079
basically takes off 50 of the runtime

1512
00:57:37,079 --> 00:57:40,140
that is like uh yeah I'm also used to to

1513
00:57:40,140 --> 00:57:42,119
sample this internal y

1514
00:57:42,119 --> 00:57:44,099
uh yeah doing the signature generation

1515
00:57:44,099 --> 00:57:46,500
so maybe to overcome this here you can

1516
00:57:46,500 --> 00:57:48,059
maybe implement the hardware accelerator

1517
00:57:48,059 --> 00:57:50,420
that implements protected catchlock

1518
00:57:50,420 --> 00:57:52,680
but we also looked into alternative

1519
00:57:52,680 --> 00:57:54,359
approaches where maybe a slight

1520
00:57:54,359 --> 00:57:55,700
algorithmic trick

1521
00:57:55,700 --> 00:57:59,040
would already help

1522
00:57:59,040 --> 00:58:00,780
um and what we looked at is basically at

1523
00:58:00,780 --> 00:58:03,240
the generation of Y itself so that's how

1524
00:58:03,240 --> 00:58:05,040
it done in the in the randomized version

1525
00:58:05,040 --> 00:58:07,319
so we have a true random seed and then

1526
00:58:07,319 --> 00:58:09,000
you use protected catcher to basically

1527
00:58:09,000 --> 00:58:12,240
expand it to get the Y

1528
00:58:12,240 --> 00:58:14,220
uh what we now proposing what was

1529
00:58:14,220 --> 00:58:16,200
already noted in in Prior works is that

1530
00:58:16,200 --> 00:58:18,540
we maybe do not specify how wide

1531
00:58:18,540 --> 00:58:19,619
assembled except for like the

1532
00:58:19,619 --> 00:58:22,819
distribution and that would enable us to

1533
00:58:22,819 --> 00:58:25,200
implement in such a way that each of the

1534
00:58:25,200 --> 00:58:27,599
Spheres of Y are generated independent

1535
00:58:27,599 --> 00:58:29,400
from each other either through random or

1536
00:58:29,400 --> 00:58:31,800
with some some pseudo random function

1537
00:58:31,800 --> 00:58:34,079
a note of course it requires some some

1538
00:58:34,079 --> 00:58:36,540
proper enema Source but um yeah that's

1539
00:58:36,540 --> 00:58:37,619
maybe out of the scope of this

1540
00:58:37,619 --> 00:58:40,040
presentation

1541
00:58:40,740 --> 00:58:42,180
and then you can see here that it

1542
00:58:42,180 --> 00:58:43,440
actually helps quite a lot in terms of

1543
00:58:43,440 --> 00:58:45,420
runtime so for all security orders it's

1544
00:58:45,420 --> 00:58:47,099
not to be reduced

1545
00:58:47,099 --> 00:58:48,359
um compared to the yeah the original

1546
00:58:48,359 --> 00:58:51,119
randomized version so yeah it's pretty

1547
00:58:51,119 --> 00:58:53,280
clear that it helps um with with

1548
00:58:53,280 --> 00:58:55,020
performance

1549
00:58:55,020 --> 00:58:56,220
however

1550
00:58:56,220 --> 00:58:58,079
um yeah physical attacks are not the

1551
00:58:58,079 --> 00:58:58,920
only

1552
00:58:58,920 --> 00:59:00,599
um aspect that need to be considered

1553
00:59:00,599 --> 00:59:01,980
there's also maybe testability and use

1554
00:59:01,980 --> 00:59:03,780
of implementation

1555
00:59:03,780 --> 00:59:06,720
um so in in the final draft the

1556
00:59:06,720 --> 00:59:08,280
generation of Y for the randomized

1557
00:59:08,280 --> 00:59:10,559
version will be actually adapted but not

1558
00:59:10,559 --> 00:59:13,440
make more flexible but rather be adapted

1559
00:59:13,440 --> 00:59:15,780
to be more similar to the deterministic

1560
00:59:15,780 --> 00:59:17,599
version as you can see has this hatched

1561
00:59:17,599 --> 00:59:20,040
proposal so there you just need to

1562
00:59:20,040 --> 00:59:23,059
basically uh switch the row Prime string

1563
00:59:23,059 --> 00:59:25,200
to switch from deterministic to

1564
00:59:25,200 --> 00:59:26,400
randomized so you can use the same code

1565
00:59:26,400 --> 00:59:29,099
based for both of them

1566
00:59:29,099 --> 00:59:30,780
in terms of performance it doesn't

1567
00:59:30,780 --> 00:59:34,319
really yeah hasn't uh is not a lot worse

1568
00:59:34,319 --> 00:59:35,700
than the original system is

1569
00:59:35,700 --> 00:59:38,220
deterministic and randomized version but

1570
00:59:38,220 --> 00:59:39,660
of course it doesn't benefit from this

1571
00:59:39,660 --> 00:59:42,859
flexible sampling approach

1572
00:59:43,140 --> 00:59:45,720
okay so maybe let me summarize what were

1573
00:59:45,720 --> 00:59:47,760
the lessons that we learned during our

1574
00:59:47,760 --> 00:59:49,260
study

1575
00:59:49,260 --> 00:59:51,900
so yeah what we found is that maybe

1576
00:59:51,900 --> 00:59:54,359
randomized uh should be maybe the

1577
00:59:54,359 --> 00:59:55,680
default for any better applications

1578
00:59:55,680 --> 00:59:57,299
where like physical security is a

1579
00:59:57,299 --> 00:59:58,079
concern

1580
00:59:58,079 --> 01:00:00,900
uh it has significant performance and

1581
01:00:00,900 --> 01:00:02,460
memory

1582
01:00:02,460 --> 01:00:04,319
um benefits because you can use a lower

1583
01:00:04,319 --> 01:00:06,660
security order and here the head

1584
01:00:06,660 --> 01:00:09,540
proposes is I think it's a good way

1585
01:00:09,540 --> 01:00:11,040
um as long as we can keep the randomized

1586
01:00:11,040 --> 01:00:12,660
version of it

1587
01:00:12,660 --> 01:00:14,339
of course flexible sampling would be

1588
01:00:14,339 --> 01:00:15,599
even better for us

1589
01:00:15,599 --> 01:00:18,720
um so it was shown that it wouldn't have

1590
01:00:18,720 --> 01:00:20,099
significant speed up so maybe it's not

1591
01:00:20,099 --> 01:00:21,359
that interesting for delicium anymore

1592
01:00:21,359 --> 01:00:23,579
but maybe some of the

1593
01:00:23,579 --> 01:00:25,799
the yeah the new signature algorithms

1594
01:00:25,799 --> 01:00:27,240
that I submitted this year could maybe

1595
01:00:27,240 --> 01:00:29,460
take a lesson there so we don't argue

1596
01:00:29,460 --> 01:00:31,740
that it should be the only variant of

1597
01:00:31,740 --> 01:00:33,780
the specified but maybe as like a at

1598
01:00:33,780 --> 01:00:35,940
your own risk variant um

1599
01:00:35,940 --> 01:00:38,040
for people that maybe want to push it a

1600
01:00:38,040 --> 01:00:39,599
bit further

1601
01:00:39,599 --> 01:00:41,760
and then yeah maybe lastly the overall

1602
01:00:41,760 --> 01:00:43,680
arching messages that hardly the listen

1603
01:00:43,680 --> 01:00:46,740
is still not mature uh it has been much

1604
01:00:46,740 --> 01:00:48,119
less studied than carbos and we expect

1605
01:00:48,119 --> 01:00:50,160
that some attacks will come up in the

1606
01:00:50,160 --> 01:00:52,140
coming years and hopefully also the

1607
01:00:52,140 --> 01:00:55,980
countermeasures will improve as well

1608
01:00:55,980 --> 01:00:58,190
so thank you for your attention

1609
01:00:58,190 --> 01:01:08,160
[Applause]

1610
01:01:08,160 --> 01:01:10,559
yeah one one quick question before the

1611
01:01:10,559 --> 01:01:12,980
coffee break

1612
01:01:13,200 --> 01:01:15,919
foreign

1613
01:01:17,420 --> 01:01:20,119
what kind of memory numbers

1614
01:01:20,119 --> 01:01:23,760
should we expect from order to order for

1615
01:01:23,760 --> 01:01:27,140
hardened implementations

1616
01:01:27,420 --> 01:01:30,240
uh yeah I don't know by heart

1617
01:01:30,240 --> 01:01:32,940
okay it should be in a paper I think

1618
01:01:32,940 --> 01:01:35,880
okay but I mean what I can tell you that

1619
01:01:35,880 --> 01:01:37,619
if I mean for very constrained devices

1620
01:01:37,619 --> 01:01:39,900
it um it could not fit and then you

1621
01:01:39,900 --> 01:01:41,700
would need to maybe regenerate some of

1622
01:01:41,700 --> 01:01:43,319
the intermediates and that then will cut

1623
01:01:43,319 --> 01:01:46,640
a lot in your in your performance

1624
01:01:47,940 --> 01:01:49,859
okay let's thank all the speakers of the

1625
01:01:49,859 --> 01:01:52,819
session again and

1626
01:01:57,420 --> 01:02:00,680
enjoy the coffee break

