1
00:00:00,000 --> 00:00:01,860
do we have in three more presentations

2
00:00:01,860 --> 00:00:03,899
on this session and it's going to be

3
00:00:03,899 --> 00:00:05,940
about post Quantum protocols and Agility

4
00:00:05,940 --> 00:00:08,880
so I invite the first speakers to come

5
00:00:08,880 --> 00:00:10,019
to the

6
00:00:10,019 --> 00:00:12,799
Podium for the presentation

7
00:00:12,799 --> 00:00:16,460
Estefan and Sophie

8
00:00:25,490 --> 00:00:30,890
[Music]

9
00:00:33,420 --> 00:00:37,520
okay let's wait five more minutes

10
00:00:38,720 --> 00:00:42,860
[Music]

11
00:00:42,860 --> 00:00:45,180
we're going to be talking in the session

12
00:00:45,180 --> 00:00:47,640
about post Quantum cryptography in

13
00:00:47,640 --> 00:00:49,980
protocols and Agility and I have the

14
00:00:49,980 --> 00:00:51,780
pleasure to introduce the first speakers

15
00:00:51,780 --> 00:00:54,000
for this session which is Estevan kubel

16
00:00:54,000 --> 00:00:56,940
and Sophie Schmidt so is going to be

17
00:00:56,940 --> 00:00:58,800
talking about cryptographic agility and

18
00:00:58,800 --> 00:01:02,599
post Quantum cryptography at Google

19
00:01:03,199 --> 00:01:08,240
if you can approach for your talk

20
00:01:49,640 --> 00:01:53,280
okay so thank you um we have as I said

21
00:01:53,280 --> 00:01:54,840
Stefan and Sophie who are going to be

22
00:01:54,840 --> 00:01:56,700
talking about cryptographic agility and

23
00:01:56,700 --> 00:01:59,220
post Quantum cryptography at Google so

24
00:01:59,220 --> 00:02:01,200
take it away

25
00:02:01,200 --> 00:02:03,479
yeah thank you and thank you everyone

26
00:02:03,479 --> 00:02:04,920
for coming

27
00:02:04,920 --> 00:02:06,840
in this talk we will talk about two

28
00:02:06,840 --> 00:02:08,758
aspects like one is crypto agility the

29
00:02:08,758 --> 00:02:11,220
other one post Quantum cryptography

30
00:02:11,220 --> 00:02:13,080
and I'd like to start on the crypto

31
00:02:13,080 --> 00:02:14,819
agility part

32
00:02:14,819 --> 00:02:17,400
and look a bit back like what we said

33
00:02:17,400 --> 00:02:21,420
previous rwc's we had various uh talks

34
00:02:21,420 --> 00:02:22,200
on

35
00:02:22,200 --> 00:02:24,360
different aspects of how we do crypto

36
00:02:24,360 --> 00:02:26,520
agility at Google and all of this

37
00:02:26,520 --> 00:02:28,260
together kind of form different puzzle

38
00:02:28,260 --> 00:02:29,099
pieces

39
00:02:29,099 --> 00:02:31,560
on how we do that so we had like a talk

40
00:02:31,560 --> 00:02:34,319
in 2018 on how our internal key

41
00:02:34,319 --> 00:02:36,180
management system works

42
00:02:36,180 --> 00:02:39,420
in 19 we had a talk on our cryptographic

43
00:02:39,420 --> 00:02:40,860
library thing

44
00:02:40,860 --> 00:02:43,319
and in 21 we talked about what's in a

45
00:02:43,319 --> 00:02:44,220
key

46
00:02:44,220 --> 00:02:46,800
and in this talk today I want to

47
00:02:46,800 --> 00:02:48,660
talk a bit more about sharing some

48
00:02:48,660 --> 00:02:50,700
difficulties we have with crypto agility

49
00:02:50,700 --> 00:02:52,620
in practice

50
00:02:52,620 --> 00:02:56,060
and how we'd address them

51
00:02:57,840 --> 00:02:59,700
but first yeah what are like the main

52
00:02:59,700 --> 00:03:02,280
goals for crypto agility for us so one

53
00:03:02,280 --> 00:03:03,180
of them

54
00:03:03,180 --> 00:03:05,099
most important things for us is we want

55
00:03:05,099 --> 00:03:08,220
to enforce best practices so that all

56
00:03:08,220 --> 00:03:09,840
developers at Google can do the right

57
00:03:09,840 --> 00:03:12,000
thing when they use our

58
00:03:12,000 --> 00:03:14,280
a cryptographic libraries and Key

59
00:03:14,280 --> 00:03:15,780
Management Systems

60
00:03:15,780 --> 00:03:17,760
so for instance we don't want people to

61
00:03:17,760 --> 00:03:20,940
to make bad choices on on algorithms

62
00:03:20,940 --> 00:03:25,019
we don't want them to like choose IVs

63
00:03:25,019 --> 00:03:27,180
so there's a lot of different ways we we

64
00:03:27,180 --> 00:03:30,019
try to achieve this

65
00:03:30,239 --> 00:03:31,860
and on the other side yeah we also don't

66
00:03:31,860 --> 00:03:33,900
want to burn the users like to enforce

67
00:03:33,900 --> 00:03:36,060
the best practices we don't want the

68
00:03:36,060 --> 00:03:38,940
users to have to take like for instance

69
00:03:38,940 --> 00:03:40,860
keep track of which keys they are using

70
00:03:40,860 --> 00:03:42,060
or

71
00:03:42,060 --> 00:03:45,720
do key rotation manually so it's really

72
00:03:45,720 --> 00:03:48,299
important with yeah the scale we work at

73
00:03:48,299 --> 00:03:51,480
that developers can

74
00:03:51,480 --> 00:03:53,819
uh use cryptography in the correct way

75
00:03:53,819 --> 00:03:56,879
without too much hassle

76
00:03:56,879 --> 00:04:00,180
and last but not least reliability so

77
00:04:00,180 --> 00:04:03,239
with key management like if if the keys

78
00:04:03,239 --> 00:04:05,220
are not available Services go down so

79
00:04:05,220 --> 00:04:09,260
reliability is is very important here

80
00:04:10,200 --> 00:04:12,120
and today I mostly want to talk about

81
00:04:12,120 --> 00:04:15,540
one best practice which is key rotation

82
00:04:15,540 --> 00:04:18,000
and in particular our goal is the key

83
00:04:18,000 --> 00:04:21,899
rotation happens automatically

84
00:04:21,899 --> 00:04:23,759
so this is a lot of advantages because

85
00:04:23,759 --> 00:04:25,860
if you can do key rotation automatically

86
00:04:25,860 --> 00:04:28,259
yeah you get forward secrecy

87
00:04:28,259 --> 00:04:30,479
but also should a key have a leak in

88
00:04:30,479 --> 00:04:34,440
allows you to recover in a with much

89
00:04:34,440 --> 00:04:36,780
less operational risk because if your

90
00:04:36,780 --> 00:04:39,240
key is already rotate automatically it's

91
00:04:39,240 --> 00:04:40,860
much easier to move away from a

92
00:04:40,860 --> 00:04:43,520
compromise team

93
00:04:43,979 --> 00:04:45,840
and also it becomes much easier to

94
00:04:45,840 --> 00:04:48,060
switch keys so if you can automatically

95
00:04:48,060 --> 00:04:50,580
rotate Keys we can very easily switch to

96
00:04:50,580 --> 00:04:53,580
like different type of algorithms

97
00:04:53,580 --> 00:04:55,139
and this is very important like for

98
00:04:55,139 --> 00:04:56,460
instance if you want to transition to

99
00:04:56,460 --> 00:04:58,680
post Quantum algorithms

100
00:04:58,680 --> 00:05:00,600
like if you have automatic key rotation

101
00:05:00,600 --> 00:05:01,620
in place

102
00:05:01,620 --> 00:05:04,500
rotating the key is mostly about whether

103
00:05:04,500 --> 00:05:08,240
you can take the performance hit

104
00:05:08,340 --> 00:05:10,620
however in practice it's not so easy to

105
00:05:10,620 --> 00:05:12,540
enforce automatic key rotation so

106
00:05:12,540 --> 00:05:15,060
there's a lot of reliability risks

107
00:05:15,060 --> 00:05:17,400
because if you rotate Keys key material

108
00:05:17,400 --> 00:05:19,500
might become unavailable and that can

109
00:05:19,500 --> 00:05:22,320
cause issues in practice

110
00:05:22,320 --> 00:05:23,880
however I would also like to highlight

111
00:05:23,880 --> 00:05:26,759
if you don't do automatic key rotation

112
00:05:26,759 --> 00:05:28,919
you have a much higher risk like for

113
00:05:28,919 --> 00:05:31,440
instance if the key is compromised and

114
00:05:31,440 --> 00:05:32,820
you don't do automatic rotation it

115
00:05:32,820 --> 00:05:35,280
becomes much harder to move away

116
00:05:35,280 --> 00:05:37,500
so by not doing this you basically

117
00:05:37,500 --> 00:05:40,020
you're shifting your problem to a later

118
00:05:40,020 --> 00:05:43,940
stage and accumulating technical depth

119
00:05:44,520 --> 00:05:46,440
so from a user perspective how does this

120
00:05:46,440 --> 00:05:47,340
look like

121
00:05:47,340 --> 00:05:50,340
so our users which typically is our

122
00:05:50,340 --> 00:05:51,840
developers

123
00:05:51,840 --> 00:05:53,639
they have to set up like average key

124
00:05:53,639 --> 00:05:55,440
type to revolve to the one to encrypt

125
00:05:55,440 --> 00:05:57,720
data do they want to sign data

126
00:05:57,720 --> 00:06:00,660
they can specify like key formats

127
00:06:00,660 --> 00:06:02,639
they have to specify like yeah for how

128
00:06:02,639 --> 00:06:04,860
long to delete the cipher texts and also

129
00:06:04,860 --> 00:06:06,300
for how long do they want to Cache the

130
00:06:06,300 --> 00:06:08,520
keys

131
00:06:08,520 --> 00:06:10,380
but for instance they are generating the

132
00:06:10,380 --> 00:06:13,320
scheme material Distributing it and also

133
00:06:13,320 --> 00:06:15,419
rotating the key material is all taken

134
00:06:15,419 --> 00:06:19,039
care of by the key management system

135
00:06:20,880 --> 00:06:23,580
so when a user has set up a key well

136
00:06:23,580 --> 00:06:25,199
they only have to do two simple steps

137
00:06:25,199 --> 00:06:27,780
well first they have to retrieve the key

138
00:06:27,780 --> 00:06:29,580
and when I talk about your key it's

139
00:06:29,580 --> 00:06:31,979
typically a set of keys so it usually

140
00:06:31,979 --> 00:06:34,020
abstract this away for the user

141
00:06:34,020 --> 00:06:35,759
so every time I talk about the key think

142
00:06:35,759 --> 00:06:38,699
about it as a set of keys

143
00:06:38,699 --> 00:06:41,280
and for this yeah there's like the

144
00:06:41,280 --> 00:06:43,020
authorization and authentication is

145
00:06:43,020 --> 00:06:45,720
duplicated based on the service identity

146
00:06:45,720 --> 00:06:47,400
and we also do something binary

147
00:06:47,400 --> 00:06:49,800
authorization which is very interesting

148
00:06:49,800 --> 00:06:52,740
for the topic for another talk

149
00:06:52,740 --> 00:06:54,479
and then they just use the key in the

150
00:06:54,479 --> 00:06:56,599
library

151
00:06:57,600 --> 00:06:59,759
and the nice things are cryptographic

152
00:06:59,759 --> 00:07:02,039
Library think it handles a lot of things

153
00:07:02,039 --> 00:07:03,720
for the user so

154
00:07:03,720 --> 00:07:05,759
the user doesn't need to know which key

155
00:07:05,759 --> 00:07:08,340
inside the keys that they have to use

156
00:07:08,340 --> 00:07:09,539
they don't have to think about

157
00:07:09,539 --> 00:07:11,759
refreshing the key material the library

158
00:07:11,759 --> 00:07:13,680
takes care of this

159
00:07:13,680 --> 00:07:15,360
and the library also supports that you

160
00:07:15,360 --> 00:07:17,639
can have inner key set keys of different

161
00:07:17,639 --> 00:07:20,460
format so you can for instance have

162
00:07:20,460 --> 00:07:23,460
your ecdsa key in there but then also

163
00:07:23,460 --> 00:07:26,900
add your delithium key laner

164
00:07:27,900 --> 00:07:30,660
now I want to do a quick score discourse

165
00:07:30,660 --> 00:07:33,240
to the this scheme management standard

166
00:07:33,240 --> 00:07:36,539
which yeah is a very nice standard on

167
00:07:36,539 --> 00:07:38,280
how to do key management but it's also

168
00:07:38,280 --> 00:07:39,599
fairly complex

169
00:07:39,599 --> 00:07:41,699
so for instance it defines like six

170
00:07:41,699 --> 00:07:44,039
different states and there's 15 possible

171
00:07:44,039 --> 00:07:45,720
transitions between these different

172
00:07:45,720 --> 00:07:47,520
states

173
00:07:47,520 --> 00:07:50,880
so this is a very complex uh process and

174
00:07:50,880 --> 00:07:53,340
I I just want to briefly go over three

175
00:07:53,340 --> 00:07:55,080
steps to to highlight some of the

176
00:07:55,080 --> 00:07:56,699
problems we see

177
00:07:56,699 --> 00:07:58,319
so the first thing is like yeah when you

178
00:07:58,319 --> 00:08:00,300
generate the key material

179
00:08:00,300 --> 00:08:02,340
actually it's not you cannot actively

180
00:08:02,340 --> 00:08:03,900
use it so first you have to ensure this

181
00:08:03,900 --> 00:08:06,419
key material is available everywhere

182
00:08:06,419 --> 00:08:08,400
so you have this problem like yeah when

183
00:08:08,400 --> 00:08:10,380
is it safe to start using this key

184
00:08:10,380 --> 00:08:12,740
material

185
00:08:12,960 --> 00:08:14,880
and in the next stage here now we start

186
00:08:14,880 --> 00:08:17,160
using the scheme material actively

187
00:08:17,160 --> 00:08:20,280
so we use like this golden key for that

188
00:08:20,280 --> 00:08:22,080
and then you really use the key material

189
00:08:22,080 --> 00:08:24,900
for encrypting data or signing data

190
00:08:24,900 --> 00:08:26,160
and it's very important you have to

191
00:08:26,160 --> 00:08:27,539
ensure like

192
00:08:27,539 --> 00:08:31,020
all other parties which process the data

193
00:08:31,020 --> 00:08:33,120
which is encrypted with this key have

194
00:08:33,120 --> 00:08:35,659
this key available

195
00:08:36,839 --> 00:08:38,760
and the next step in the lifetime of a

196
00:08:38,760 --> 00:08:40,260
key is typically that it becomes like

197
00:08:40,260 --> 00:08:43,260
suspended or deactivated

198
00:08:43,260 --> 00:08:45,300
so here the key is not used to actively

199
00:08:45,300 --> 00:08:47,459
encrypt any new data but the only

200
00:08:47,459 --> 00:08:49,800
decrypt data with it

201
00:08:49,800 --> 00:08:51,600
but then there comes the problem here at

202
00:08:51,600 --> 00:08:52,920
some point I would like to delete this

203
00:08:52,920 --> 00:08:55,200
key I I don't want to keep Keys

204
00:08:55,200 --> 00:08:58,260
indefinitely because this will increase

205
00:08:58,260 --> 00:09:00,779
the risk if the keys that should have a

206
00:09:00,779 --> 00:09:02,959
leak

207
00:09:03,540 --> 00:09:06,180
so very simple example let's assume you

208
00:09:06,180 --> 00:09:07,740
have like two locations

209
00:09:07,740 --> 00:09:09,660
so we generate a new key then we have to

210
00:09:09,660 --> 00:09:11,459
ensure it's available in all other

211
00:09:11,459 --> 00:09:13,560
locations

212
00:09:13,560 --> 00:09:17,060
and then we can make it active

213
00:09:17,100 --> 00:09:18,779
so if you then want to rotate the key

214
00:09:18,779 --> 00:09:21,240
again we have to generate a key

215
00:09:21,240 --> 00:09:23,580
in all locations

216
00:09:23,580 --> 00:09:25,800
and then we can make it active and make

217
00:09:25,800 --> 00:09:28,740
the other key inactive

218
00:09:28,740 --> 00:09:31,260
and again we have to propagate this

219
00:09:31,260 --> 00:09:33,060
so this is very simple again we've

220
00:09:33,060 --> 00:09:35,820
rotate the key generate a new key

221
00:09:35,820 --> 00:09:39,600
and at some point we can delete this key

222
00:09:39,600 --> 00:09:41,519
now unfortunately in practice Yeah it's

223
00:09:41,519 --> 00:09:43,380
not that simple and it looks more like

224
00:09:43,380 --> 00:09:44,760
this you have like many many different

225
00:09:44,760 --> 00:09:48,060
locations and at each location many

226
00:09:48,060 --> 00:09:50,100
instances of a service might access this

227
00:09:50,100 --> 00:09:51,420
key

228
00:09:51,420 --> 00:09:53,220
and this might be even more complicated

229
00:09:53,220 --> 00:09:55,800
by for instance public Keys like some

230
00:09:55,800 --> 00:09:57,720
Services might only need a public key

231
00:09:57,720 --> 00:10:00,060
some needs a private key

232
00:10:00,060 --> 00:10:02,519
and overall the whole key manage becomes

233
00:10:02,519 --> 00:10:04,800
a very large-scale distributed systems

234
00:10:04,800 --> 00:10:06,979
problem

235
00:10:08,580 --> 00:10:11,100
so what can go wrong with this so here's

236
00:10:11,100 --> 00:10:14,399
like a very simple we have two services

237
00:10:14,399 --> 00:10:17,519
one is used to sign some urls

238
00:10:17,519 --> 00:10:19,740
which are then given to the user then

239
00:10:19,740 --> 00:10:21,540
the user access this signed URL in the

240
00:10:21,540 --> 00:10:24,420
NATO service verifies this

241
00:10:24,420 --> 00:10:26,459
so like if both Services have the key

242
00:10:26,459 --> 00:10:28,200
set in the same state everything goes

243
00:10:28,200 --> 00:10:29,399
fine

244
00:10:29,399 --> 00:10:31,140
but let's assume you have the service a

245
00:10:31,140 --> 00:10:34,160
now rotates the key

246
00:10:34,680 --> 00:10:36,899
and makes it active then verification

247
00:10:36,899 --> 00:10:38,519
would fail if the other service doesn't

248
00:10:38,519 --> 00:10:41,760
have to keysight in the same state

249
00:10:41,760 --> 00:10:43,620
so this might look very trivial but

250
00:10:43,620 --> 00:10:45,120
actually there's a lot of different root

251
00:10:45,120 --> 00:10:47,880
causes why this verification might fail

252
00:10:47,880 --> 00:10:49,920
so the obvious one is like yeah like

253
00:10:49,920 --> 00:10:52,079
service P fetched the key set in a

254
00:10:52,079 --> 00:10:54,560
different state

255
00:10:54,600 --> 00:10:56,339
but this can happen also because maybe

256
00:10:56,339 --> 00:10:58,800
the KMS didn't propagate this key sets

257
00:10:58,800 --> 00:11:01,019
stayed in the timely fashion

258
00:11:01,019 --> 00:11:04,140
or maybe service p is on a different uh

259
00:11:04,140 --> 00:11:05,880
it's matching the keys at a different

260
00:11:05,880 --> 00:11:10,019
time Point than service a

261
00:11:10,019 --> 00:11:11,579
and it's also not possible for the

262
00:11:11,579 --> 00:11:13,380
service like on each operation to fetch

263
00:11:13,380 --> 00:11:14,880
the key set because this would add a lot

264
00:11:14,880 --> 00:11:17,279
of latency

265
00:11:17,279 --> 00:11:20,100
also maybe the user holds the UL for a

266
00:11:20,100 --> 00:11:21,899
long time and the key sets changed in

267
00:11:21,899 --> 00:11:23,220
the meantime

268
00:11:23,220 --> 00:11:25,440
so a lot of different

269
00:11:25,440 --> 00:11:27,899
possibilities this can go wrong in

270
00:11:27,899 --> 00:11:30,079
practice

271
00:11:30,720 --> 00:11:32,579
and the scale of this problem is huge

272
00:11:32,579 --> 00:11:34,620
yeah so we have like thousands of teams

273
00:11:34,620 --> 00:11:36,600
setting up their keys

274
00:11:36,600 --> 00:11:38,519
they work on different release schedules

275
00:11:38,519 --> 00:11:41,459
they have different use cases and needs

276
00:11:41,459 --> 00:11:44,459
and the use cases they vary from signing

277
00:11:44,459 --> 00:11:46,980
maybe every couple of weeks up to like a

278
00:11:46,980 --> 00:11:48,959
billion times a day

279
00:11:48,959 --> 00:11:51,320
so we kind of need a solution which like

280
00:11:51,320 --> 00:11:55,640
addresses all these different factors

281
00:11:56,279 --> 00:11:58,320
and so one key Improvement we recently

282
00:11:58,320 --> 00:11:59,880
made is that we added like horizontal

283
00:11:59,880 --> 00:12:01,860
monitoring directly in our cryptographic

284
00:12:01,860 --> 00:12:03,360
libraries

285
00:12:03,360 --> 00:12:05,279
so this achieves two things like we can

286
00:12:05,279 --> 00:12:07,079
keep track of like in which state the

287
00:12:07,079 --> 00:12:08,880
key sets are

288
00:12:08,880 --> 00:12:10,500
but at the same time we achieved that

289
00:12:10,500 --> 00:12:12,360
they do not burden our users so the

290
00:12:12,360 --> 00:12:16,040
users do not have to keep track of this

291
00:12:17,880 --> 00:12:20,399
so the challenges here are quite big so

292
00:12:20,399 --> 00:12:22,320
first of all latency like if we do this

293
00:12:22,320 --> 00:12:25,019
directly in the cryptographic library

294
00:12:25,019 --> 00:12:27,720
operations have to be really fast so

295
00:12:27,720 --> 00:12:29,519
imagine you just encrypt a few blocks of

296
00:12:29,519 --> 00:12:30,600
data

297
00:12:30,600 --> 00:12:33,959
you cannot afford any overhead really

298
00:12:33,959 --> 00:12:35,820
at the same time you also have a very

299
00:12:35,820 --> 00:12:37,380
large data volume here

300
00:12:37,380 --> 00:12:39,060
so you really need to carefully think

301
00:12:39,060 --> 00:12:41,519
about how you aggregate the data to make

302
00:12:41,519 --> 00:12:44,279
it handable

303
00:12:44,279 --> 00:12:46,320
and also yeah the integration in the

304
00:12:46,320 --> 00:12:48,120
crypto libraries so the crypto libraries

305
00:12:48,120 --> 00:12:49,980
they are available in many programming

306
00:12:49,980 --> 00:12:52,440
languages and you need to integrate this

307
00:12:52,440 --> 00:12:55,399
monitoring everywhere

308
00:12:57,959 --> 00:13:00,180
so how does this look now yeah from a

309
00:13:00,180 --> 00:13:01,440
user perspective so if you have like

310
00:13:01,440 --> 00:13:03,180
service a and service B

311
00:13:03,180 --> 00:13:04,680
the nice thing is for them nothing

312
00:13:04,680 --> 00:13:06,779
changes so the developers just still

313
00:13:06,779 --> 00:13:10,740
they fetch the key they use the library

314
00:13:10,740 --> 00:13:13,920
and they don't have to make any changes

315
00:13:13,920 --> 00:13:16,200
but on the back end we now get the

316
00:13:16,200 --> 00:13:18,060
information like in which state the the

317
00:13:18,060 --> 00:13:19,860
key set was when they

318
00:13:19,860 --> 00:13:23,600
did a certain cryptographic operation

319
00:13:25,740 --> 00:13:27,600
and this allows us to improve

320
00:13:27,600 --> 00:13:30,060
reliability of key rotation because we

321
00:13:30,060 --> 00:13:32,339
we get like useful signals from this

322
00:13:32,339 --> 00:13:35,940
like for instance when is it uh safe to

323
00:13:35,940 --> 00:13:37,680
make a key active

324
00:13:37,680 --> 00:13:40,019
also when can we delete a key so we know

325
00:13:40,019 --> 00:13:41,220
exactly like

326
00:13:41,220 --> 00:13:43,440
is like this inactive key still being

327
00:13:43,440 --> 00:13:45,480
used anywhere

328
00:13:45,480 --> 00:13:47,820
we can also notify the other teams if

329
00:13:47,820 --> 00:13:50,040
they violate for instance I mentioned

330
00:13:50,040 --> 00:13:52,019
they set up like how long do I need my

331
00:13:52,019 --> 00:13:54,060
ciphertext to be available

332
00:13:54,060 --> 00:13:56,880
but we know we by directly monitoring in

333
00:13:56,880 --> 00:13:58,440
the cryptographic library we can now

334
00:13:58,440 --> 00:14:01,740
know are they holding up this contract

335
00:14:01,740 --> 00:14:04,019
and also we can also Block in the worst

336
00:14:04,019 --> 00:14:06,420
case the key rotation if we know this

337
00:14:06,420 --> 00:14:08,579
someone is still actively using like

338
00:14:08,579 --> 00:14:11,540
this old key material

339
00:14:14,459 --> 00:14:16,260
so apart from this key rotation case

340
00:14:16,260 --> 00:14:18,899
like this horizontal monitoring actually

341
00:14:18,899 --> 00:14:21,420
it gives us a lot of other nice features

342
00:14:21,420 --> 00:14:22,800
we can do now

343
00:14:22,800 --> 00:14:24,660
so it allows us the admin Force best

344
00:14:24,660 --> 00:14:26,100
practices

345
00:14:26,100 --> 00:14:27,320
for instance there are a lot of

346
00:14:27,320 --> 00:14:29,459
encryption modes which have like a very

347
00:14:29,459 --> 00:14:31,920
low bound on the number of queries you

348
00:14:31,920 --> 00:14:33,660
can do on the key

349
00:14:33,660 --> 00:14:35,459
and if you look like at this if you

350
00:14:35,459 --> 00:14:37,740
remember this this world map of like

351
00:14:37,740 --> 00:14:39,540
many many services for instance if you

352
00:14:39,540 --> 00:14:42,240
want to answer is any key used more for

353
00:14:42,240 --> 00:14:44,639
more than two to the 32 queries

354
00:14:44,639 --> 00:14:46,500
this becomes very hard if the services

355
00:14:46,500 --> 00:14:48,600
would have to manage this but by

356
00:14:48,600 --> 00:14:50,339
tracking this directly in the library we

357
00:14:50,339 --> 00:14:52,440
can now answer questions like is anyone

358
00:14:52,440 --> 00:14:55,019
using a GCM key with more than 2 to 32

359
00:14:55,019 --> 00:14:56,880
messages

360
00:14:56,880 --> 00:14:59,279
it's also very nice you have to detect

361
00:14:59,279 --> 00:15:01,980
like usage of Legacy keys or guide

362
00:15:01,980 --> 00:15:04,019
replication because we can exactly see

363
00:15:04,019 --> 00:15:07,260
who is using still which algorithms

364
00:15:07,260 --> 00:15:08,880
and it's also nice like if you're

365
00:15:08,880 --> 00:15:11,519
migrating from one algorithm to another

366
00:15:11,519 --> 00:15:13,260
we can observe this in the monitoring we

367
00:15:13,260 --> 00:15:15,420
can see like Which percentage of a

368
00:15:15,420 --> 00:15:18,120
service already moved to the new key

369
00:15:18,120 --> 00:15:20,519
which brings us to the second part of

370
00:15:20,519 --> 00:15:22,560
this talk which will be about how we

371
00:15:22,560 --> 00:15:24,600
transitioned our one of our protocols to

372
00:15:24,600 --> 00:15:27,260
post quantum

373
00:15:28,440 --> 00:15:30,540
um thank you Stefan and as Stefan

374
00:15:30,540 --> 00:15:34,819
mentioned I will go a bit deeper on how

375
00:15:35,639 --> 00:15:36,360
how

376
00:15:36,360 --> 00:15:38,760
um especially about a specific thing

377
00:15:38,760 --> 00:15:41,399
that we did to our encryption Transit

378
00:15:41,399 --> 00:15:45,000
so why is it important to talk about

379
00:15:45,000 --> 00:15:48,600
um post Quantum cryptography now

380
00:15:48,600 --> 00:15:52,019
um the main risks that we have is uh

381
00:15:52,019 --> 00:15:54,300
like for encryption Transit so now

382
00:15:54,300 --> 00:15:57,420
decrypt later attacks which means that

383
00:15:57,420 --> 00:15:59,160
an adversary doesn't need to have a

384
00:15:59,160 --> 00:16:00,720
quantum computer right now they can

385
00:16:00,720 --> 00:16:03,300
store the ciphertext of something that

386
00:16:03,300 --> 00:16:05,519
they're interested in the future and

387
00:16:05,519 --> 00:16:08,160
decrypt it at a later date

388
00:16:08,160 --> 00:16:11,040
um so this means that uh if you want

389
00:16:11,040 --> 00:16:13,440
something to be kept secret for for 10

390
00:16:13,440 --> 00:16:15,540
to 15 years we need to start on this

391
00:16:15,540 --> 00:16:17,699
migration now

392
00:16:17,699 --> 00:16:21,120
um this gives us the priorities uh to

393
00:16:21,120 --> 00:16:23,639
like if we want to do pqc in practice

394
00:16:23,639 --> 00:16:26,040
the first thing that we need to do is

395
00:16:26,040 --> 00:16:28,440
encryption and Transit the second thing

396
00:16:28,440 --> 00:16:30,779
that we need to do on a fairly similar

397
00:16:30,779 --> 00:16:33,839
Time Square scale is signature schemes

398
00:16:33,839 --> 00:16:36,060
in the case where the public key cannot

399
00:16:36,060 --> 00:16:38,459
be changed the main example there is

400
00:16:38,459 --> 00:16:40,380
Hardware Woods of trust where the

401
00:16:40,380 --> 00:16:42,060
firmware for the hardware route of trust

402
00:16:42,060 --> 00:16:45,360
has a signature on it that was burned

403
00:16:45,360 --> 00:16:48,779
into silicon which will mean that uh

404
00:16:48,779 --> 00:16:51,660
yeah you need to uh

405
00:16:51,660 --> 00:16:53,699
have set now if you want your device to

406
00:16:53,699 --> 00:16:57,540
live for more than 10 to 15 years

407
00:16:57,540 --> 00:17:00,060
profit is all other asymmetric

408
00:17:00,060 --> 00:17:01,860
cryptography mostly meaning signature

409
00:17:01,860 --> 00:17:04,740
schemes signature schemes are not as

410
00:17:04,740 --> 00:17:06,900
vulnerable to this Stone out equipped

411
00:17:06,900 --> 00:17:09,000
later attacks because I can just change

412
00:17:09,000 --> 00:17:11,640
the the scheme when the quantum computer

413
00:17:11,640 --> 00:17:14,760
arrives we also cannot forget about like

414
00:17:14,760 --> 00:17:17,339
the other Primitives that are like the

415
00:17:17,339 --> 00:17:20,220
more fancy asymmetric cryptography uh

416
00:17:20,220 --> 00:17:22,799
SCV see some other talks about this

417
00:17:22,799 --> 00:17:25,020
topic later

418
00:17:25,020 --> 00:17:27,959
um lastly there's also symmetric

419
00:17:27,959 --> 00:17:31,860
cryptography that is uh only attackable

420
00:17:31,860 --> 00:17:34,799
by Grover's algorithm and as the

421
00:17:34,799 --> 00:17:37,980
research right now looks like it's not

422
00:17:37,980 --> 00:17:40,260
likely that symmetric cryptography can

423
00:17:40,260 --> 00:17:42,059
be feasibly attacked by a quantum

424
00:17:42,059 --> 00:17:45,179
computer in a reasonably short time

425
00:17:45,179 --> 00:17:47,940
frame so symmetric cryptography is

426
00:17:47,940 --> 00:17:49,980
somewhat out of scope for us at this

427
00:17:49,980 --> 00:17:52,140
point in time

428
00:17:52,140 --> 00:17:54,539
um so when I talk about

429
00:17:54,539 --> 00:17:55,200
um

430
00:17:55,200 --> 00:17:57,600
about encryption Transit what do I talk

431
00:17:57,600 --> 00:18:00,720
about this is a famous diagram of our

432
00:18:00,720 --> 00:18:02,179
internal

433
00:18:02,179 --> 00:18:05,160
infrastructure that was

434
00:18:05,160 --> 00:18:08,220
um like it is close to us by an external

435
00:18:08,220 --> 00:18:11,280
security researcher and pointed out over

436
00:18:11,280 --> 00:18:13,620
a decade ago that hey some of this

437
00:18:13,620 --> 00:18:16,320
traffic is in clear texts here so what

438
00:18:16,320 --> 00:18:17,940
did we do

439
00:18:17,940 --> 00:18:19,799
um we fixed this problem that was

440
00:18:19,799 --> 00:18:22,559
reported to us and added came up with

441
00:18:22,559 --> 00:18:27,120
our own scheme called alts why not mtls

442
00:18:27,120 --> 00:18:31,620
well a that was over a decade ago and B

443
00:18:31,620 --> 00:18:34,500
A lot of these Services have very strict

444
00:18:34,500 --> 00:18:36,539
requirements for latency so we needed to

445
00:18:36,539 --> 00:18:38,760
have something that is very very

446
00:18:38,760 --> 00:18:41,400
optimized very uh very clear on what it

447
00:18:41,400 --> 00:18:42,120
does

448
00:18:42,120 --> 00:18:46,140
and since we control alts completely in

449
00:18:46,140 --> 00:18:48,539
all its implementations and so on this

450
00:18:48,539 --> 00:18:50,039
is the point where we can start

451
00:18:50,039 --> 00:18:53,100
experimenting with pqc and get to this

452
00:18:53,100 --> 00:18:55,380
state here where all our internal

453
00:18:55,380 --> 00:18:57,559
communication is protected against

454
00:18:57,559 --> 00:18:59,940
Quantum attacks

455
00:18:59,940 --> 00:19:03,900
so how does alts work I want to give a

456
00:19:03,900 --> 00:19:06,419
very quick overview here there is a

457
00:19:06,419 --> 00:19:09,179
white paper on this available if you

458
00:19:09,179 --> 00:19:11,400
want more details

459
00:19:11,400 --> 00:19:14,100
um I will focus on the part of the

460
00:19:14,100 --> 00:19:17,160
protocol that happens when forward

461
00:19:17,160 --> 00:19:19,980
secrecy is not a requirement which is

462
00:19:19,980 --> 00:19:22,760
used for the very latency sensitive

463
00:19:22,760 --> 00:19:26,100
use cases so how does it work

464
00:19:26,100 --> 00:19:29,039
essentially it's a static to static ecdh

465
00:19:29,039 --> 00:19:31,640
key exchange and fairly straightforward

466
00:19:31,640 --> 00:19:34,740
from from that point so in the first

467
00:19:34,740 --> 00:19:38,220
message client init the client sends its

468
00:19:38,220 --> 00:19:40,919
static ecdh key along with its

469
00:19:40,919 --> 00:19:43,260
certificate for this key to the server

470
00:19:43,260 --> 00:19:46,200
the server will then respond with its

471
00:19:46,200 --> 00:19:48,660
own static ecdh key and a certificate

472
00:19:48,660 --> 00:19:52,140
for that static ecdh key and since the

473
00:19:52,140 --> 00:19:54,299
server now has all elements that it

474
00:19:54,299 --> 00:19:56,940
needs it will also send

475
00:19:56,940 --> 00:19:58,500
um

476
00:19:58,500 --> 00:20:00,660
it will also send a secret confirmation

477
00:20:00,660 --> 00:20:04,380
message uh and uh like allow the client

478
00:20:04,380 --> 00:20:08,820
to uh check that the that the shared

479
00:20:08,820 --> 00:20:11,460
secret was computed correctly uh the

480
00:20:11,460 --> 00:20:13,260
client responds to that with its own

481
00:20:13,260 --> 00:20:16,320
secret confirmation message and um since

482
00:20:16,320 --> 00:20:20,460
its own own Mac back to the server uh at

483
00:20:20,460 --> 00:20:22,140
that point both server and client know

484
00:20:22,140 --> 00:20:23,280
that they're talking about the same

485
00:20:23,280 --> 00:20:25,260
shared secrets so there should be no uh

486
00:20:25,260 --> 00:20:27,179
monster in the middle

487
00:20:27,179 --> 00:20:29,400
um a slight variation happens which is

488
00:20:29,400 --> 00:20:31,320
extremely important for the low latency

489
00:20:31,320 --> 00:20:33,960
use cases when the client has a

490
00:20:33,960 --> 00:20:36,419
resumption ticket so when the client has

491
00:20:36,419 --> 00:20:38,580
a resumption ticket the client will just

492
00:20:38,580 --> 00:20:40,080
send this with something ticket to the

493
00:20:40,080 --> 00:20:43,260
server in client in it and the server

494
00:20:43,260 --> 00:20:45,900
can just check it will also still send

495
00:20:45,900 --> 00:20:47,880
the the static credentials just in case

496
00:20:47,880 --> 00:20:50,700
the the ticket is invalid if the server

497
00:20:50,700 --> 00:20:54,000
accepts this ticket it will replace the

498
00:20:54,000 --> 00:20:56,400
the whole shared secret with whatever is

499
00:20:56,400 --> 00:20:59,100
in that ticket so you don't have to do

500
00:20:59,100 --> 00:21:01,500
any asymmetric cryptographic operations

501
00:21:01,500 --> 00:21:03,360
in this case and the whole thing is very

502
00:21:03,360 --> 00:21:06,299
efficient using only uh symmetric

503
00:21:06,299 --> 00:21:08,960
cryptography

504
00:21:10,200 --> 00:21:12,780
um so what are we going to do to this uh

505
00:21:12,780 --> 00:21:15,780
protocol now uh this is like a bit of an

506
00:21:15,780 --> 00:21:18,240
approximation of what the sizes of these

507
00:21:18,240 --> 00:21:20,280
things are you have a key share you have

508
00:21:20,280 --> 00:21:21,660
some protocol overhead you have a

509
00:21:21,660 --> 00:21:24,900
certificate I used a single ecdsa

510
00:21:24,900 --> 00:21:26,520
signature I'm not actually sure if it's

511
00:21:26,520 --> 00:21:28,679
one or multiple or whether there's an

512
00:21:28,679 --> 00:21:31,559
RSA but you can see roughly how large

513
00:21:31,559 --> 00:21:35,159
that thing is on the wire and then uh

514
00:21:35,159 --> 00:21:38,039
well we added an hrss public key or

515
00:21:38,039 --> 00:21:42,059
ciphertext to this message on the wire

516
00:21:42,059 --> 00:21:44,640
um why is it HSS we started the whole

517
00:21:44,640 --> 00:21:48,320
project in 2020 that was long before

518
00:21:48,320 --> 00:21:51,659
nist came up and decided on kyber for

519
00:21:51,659 --> 00:21:54,059
the standard it will eventually migrate

520
00:21:54,059 --> 00:21:56,100
to kyber but for the moment we had an

521
00:21:56,100 --> 00:21:58,500
hlss implementation lying around so we

522
00:21:58,500 --> 00:22:00,960
were just using that

523
00:22:00,960 --> 00:22:01,620
um

524
00:22:01,620 --> 00:22:04,440
yeah so what do we do with that well we

525
00:22:04,440 --> 00:22:08,460
uh um just added ephemeral to the client

526
00:22:08,460 --> 00:22:10,799
in its measures and the server will then

527
00:22:10,799 --> 00:22:14,159
encapsulate to the to this pqc public

528
00:22:14,159 --> 00:22:17,340
key and send the the cipher text along

529
00:22:17,340 --> 00:22:18,900
with it

530
00:22:18,900 --> 00:22:20,880
um the problem is that

531
00:22:20,880 --> 00:22:22,919
um this was a non-starter from the very

532
00:22:22,919 --> 00:22:25,980
beginning because now the client has to

533
00:22:25,980 --> 00:22:28,140
generate this very costly to to

534
00:22:28,140 --> 00:22:31,140
calculate pqc key on every connection

535
00:22:31,140 --> 00:22:33,780
even if the server doesn't even speak

536
00:22:33,780 --> 00:22:35,880
pqc so we can't even start rolling it

537
00:22:35,880 --> 00:22:38,039
out like that so the first modification

538
00:22:38,039 --> 00:22:41,220
was to Cache this client key a bit so

539
00:22:41,220 --> 00:22:43,020
that the client wouldn't need to reuse

540
00:22:43,020 --> 00:22:46,140
it all the time or we compute it all the

541
00:22:46,140 --> 00:22:47,940
time

542
00:22:47,940 --> 00:22:51,000
um then the set changed we were able to

543
00:22:51,000 --> 00:22:54,059
start the roll out and uh

544
00:22:54,059 --> 00:22:57,740
um ran into the first few problems like

545
00:22:57,740 --> 00:23:01,200
the one of the problems was that when

546
00:23:01,200 --> 00:23:07,020
you uh like we initially allocated the

547
00:23:07,020 --> 00:23:11,640
the hrss key and related objects on the

548
00:23:11,640 --> 00:23:14,700
stack that led to some workflows and

549
00:23:14,700 --> 00:23:16,740
architectures having a literal stack

550
00:23:16,740 --> 00:23:20,220
Overflow because it was just too big so

551
00:23:20,220 --> 00:23:22,919
we needed to put that on the Heap but

552
00:23:22,919 --> 00:23:25,679
still our rollout needed to basically

553
00:23:25,679 --> 00:23:28,919
start from the beginning again

554
00:23:28,919 --> 00:23:30,140
um

555
00:23:30,140 --> 00:23:32,400
and uh

556
00:23:32,400 --> 00:23:34,919
the other thing that happens is s is

557
00:23:34,919 --> 00:23:37,080
ramped up uh

558
00:23:37,080 --> 00:23:39,960
um we then get more and more connections

559
00:23:39,960 --> 00:23:42,559
that actually start using this pqc model

560
00:23:42,559 --> 00:23:45,780
and we did Benchmark testing before and

561
00:23:45,780 --> 00:23:48,960
we benchmarked it to and it's set to a

562
00:23:48,960 --> 00:23:51,059
bit of our surprise that we would

563
00:23:51,059 --> 00:23:53,580
actually be in the latency requirements

564
00:23:53,580 --> 00:23:55,799
even in those cases that are supposedly

565
00:23:55,799 --> 00:23:59,039
latency sensitive uh when when doing

566
00:23:59,039 --> 00:24:01,200
that so we just started the whole out

567
00:24:01,200 --> 00:24:03,780
like that this assumption doing the same

568
00:24:03,780 --> 00:24:06,000
kind of ephemeral

569
00:24:06,000 --> 00:24:09,240
um key exchange as well uh it turned out

570
00:24:09,240 --> 00:24:11,940
that the benchmarks were wrong uh the

571
00:24:11,940 --> 00:24:13,980
main reason was that the allocation

572
00:24:13,980 --> 00:24:15,840
behavior of a benchmark is very

573
00:24:15,840 --> 00:24:17,700
different to the allocation behavior of

574
00:24:17,700 --> 00:24:22,080
a fully rolled out system and so the the

575
00:24:22,080 --> 00:24:24,059
problem wasn't actually like the the

576
00:24:24,059 --> 00:24:26,580
actual computation time that we had but

577
00:24:26,580 --> 00:24:29,520
the the other stuff around it uh with

578
00:24:29,520 --> 00:24:32,520
this allocation uh behaviors and so on

579
00:24:32,520 --> 00:24:35,039
making it so that the latency was

580
00:24:35,039 --> 00:24:37,679
substantially higher than what we had

581
00:24:37,679 --> 00:24:39,900
previously thought it would be

582
00:24:39,900 --> 00:24:41,520
uh but that's also somewhat

583
00:24:41,520 --> 00:24:44,220
straightforward to fix you just don't do

584
00:24:44,220 --> 00:24:46,860
that in these cases because the resume

585
00:24:46,860 --> 00:24:49,679
the Assumption secret is derived from a

586
00:24:49,679 --> 00:24:51,659
from a secret of an earlier key exchange

587
00:24:51,659 --> 00:24:54,480
so presumably it's already Quantum

588
00:24:54,480 --> 00:24:57,120
secure so you don't have to do that as

589
00:24:57,120 --> 00:24:58,919
long as you don't care care about

590
00:24:58,919 --> 00:25:02,159
forward secrecy which in these cases we

591
00:25:02,159 --> 00:25:04,380
made the decision to not care about them

592
00:25:04,380 --> 00:25:06,960
to begin with so why would we why would

593
00:25:06,960 --> 00:25:08,640
we do the FM or

594
00:25:08,640 --> 00:25:12,480
um uh Parts here in in this resumption

595
00:25:12,480 --> 00:25:15,360
case so with that fix we then actually

596
00:25:15,360 --> 00:25:17,880
were able to roll it out and not cause

597
00:25:17,880 --> 00:25:20,640
any further production problems

598
00:25:20,640 --> 00:25:23,460
so what are the takeaway takeaways this

599
00:25:23,460 --> 00:25:25,980
um first of all when talking about pqc

600
00:25:25,980 --> 00:25:27,200
in practice

601
00:25:27,200 --> 00:25:29,400
it's very important to threat model

602
00:25:29,400 --> 00:25:31,799
things because these things are

603
00:25:31,799 --> 00:25:33,600
expensive these things take a long time

604
00:25:33,600 --> 00:25:36,600
we need to make sure that we invest our

605
00:25:36,600 --> 00:25:39,659
resources in the best way possible and

606
00:25:39,659 --> 00:25:41,340
that means the highest priority should

607
00:25:41,340 --> 00:25:44,520
be encryption Transit and these

608
00:25:44,520 --> 00:25:47,039
aforementioned uh signature schemes

609
00:25:47,039 --> 00:25:50,159
where the public key cannot be changed

610
00:25:50,159 --> 00:25:51,840
because it's burned into silicon

611
00:25:51,840 --> 00:25:55,020
somewhere and in those cases you can

612
00:25:55,020 --> 00:25:56,760
argue that we are actually a bit late on

613
00:25:56,760 --> 00:25:58,799
the timeline because we actually do care

614
00:25:58,799 --> 00:26:00,600
about some data for more than 10 years

615
00:26:00,600 --> 00:26:03,360
so we should probably get on this did

616
00:26:03,360 --> 00:26:05,880
you see rollout uh the next thing is

617
00:26:05,880 --> 00:26:07,679
that the hybrid deployment method

618
00:26:07,679 --> 00:26:10,320
actually allows us to experiment rather

619
00:26:10,320 --> 00:26:14,100
freely with pqc because in the worst

620
00:26:14,100 --> 00:26:16,080
case well we learned some things

621
00:26:16,080 --> 00:26:17,940
hopefully didn't cause any production

622
00:26:17,940 --> 00:26:20,340
outages but we

623
00:26:20,340 --> 00:26:23,100
didn't do anything of value in the best

624
00:26:23,100 --> 00:26:24,779
case we already mitigated to an audio

625
00:26:24,779 --> 00:26:26,760
equipped later so it's a nice bonus to

626
00:26:26,760 --> 00:26:28,140
have

627
00:26:28,140 --> 00:26:32,159
um and lastly uh rolling out pqc takes a

628
00:26:32,159 --> 00:26:34,320
long time like we started this work in

629
00:26:34,320 --> 00:26:37,200
2020 we are now finally getting to the

630
00:26:37,200 --> 00:26:38,940
position that the the last few jobs

631
00:26:38,940 --> 00:26:42,779
should start using pqc only and there

632
00:26:42,779 --> 00:26:45,419
were many unforeseen obstacles like I

633
00:26:45,419 --> 00:26:47,100
don't think that I expected a stack

634
00:26:47,100 --> 00:26:49,679
Overflow to happen without an array out

635
00:26:49,679 --> 00:26:51,200
of phone Suite

636
00:26:51,200 --> 00:26:54,900
but uh yeah so this migration will take

637
00:26:54,900 --> 00:26:57,419
a long time uh this was like the first

638
00:26:57,419 --> 00:26:59,700
of many uh things that need to migrate

639
00:26:59,700 --> 00:27:02,159
so we should really start with this

640
00:27:02,159 --> 00:27:05,460
migration sooner rather than later

641
00:27:05,460 --> 00:27:07,679
um and we said I would uh like you for

642
00:27:07,679 --> 00:27:09,960
like to thank you for our for your

643
00:27:09,960 --> 00:27:11,820
attention and open the floor for

644
00:27:11,820 --> 00:27:12,940
questions

645
00:27:12,940 --> 00:27:16,180
[Applause]

646
00:27:19,679 --> 00:27:21,419
thank you very much I see you already

647
00:27:21,419 --> 00:27:24,840
Nigel the question

648
00:27:24,840 --> 00:27:27,179
the talk because I understand it

649
00:27:27,179 --> 00:27:28,860
um to do the key management you

650
00:27:28,860 --> 00:27:30,720
basically you're instrumenting when the

651
00:27:30,720 --> 00:27:32,760
users use the crypto and that helps your

652
00:27:32,760 --> 00:27:35,580
key management yeah okay right okay so

653
00:27:35,580 --> 00:27:38,220
let's put aside uh encryption in transit

654
00:27:38,220 --> 00:27:40,860
because that's kind of easy but um for

655
00:27:40,860 --> 00:27:43,620
encryption at rest if I have an

656
00:27:43,620 --> 00:27:46,140
encryption key how do I know how long

657
00:27:46,140 --> 00:27:47,400
the data is going to be there is

658
00:27:47,400 --> 00:27:50,400
deciphertext in some sense do I look to

659
00:27:50,400 --> 00:27:51,960
see whether the ciphertext is still on

660
00:27:51,960 --> 00:27:54,000
the system or do I say when I generate

661
00:27:54,000 --> 00:27:55,980
the key you're only allowed to you can

662
00:27:55,980 --> 00:27:58,320
encrypt stuff but if you try to decrypt

663
00:27:58,320 --> 00:28:00,659
it after three years then that stuff

664
00:28:00,659 --> 00:28:02,340
will just automatically disappear how's

665
00:28:02,340 --> 00:28:05,400
that kind of instrumented yeah so it's a

666
00:28:05,400 --> 00:28:07,919
good point so usually there the services

667
00:28:07,919 --> 00:28:10,440
would re-encrypt on a regular interval

668
00:28:10,440 --> 00:28:13,440
to address this issue but exactly you

669
00:28:13,440 --> 00:28:15,000
have like this issue like if if the

670
00:28:15,000 --> 00:28:17,279
ciphertext is not in your control it

671
00:28:17,279 --> 00:28:19,860
becomes very tricky because maybe a user

672
00:28:19,860 --> 00:28:21,840
presents you a 10 year old ciphertext

673
00:28:21,840 --> 00:28:23,400
and

674
00:28:23,400 --> 00:28:25,620
it depends there what's like how long

675
00:28:25,620 --> 00:28:27,960
you do you want to have the key material

676
00:28:27,960 --> 00:28:30,659
around and what trade-offs do you take

677
00:28:30,659 --> 00:28:32,400
but typically on the services we control

678
00:28:32,400 --> 00:28:34,260
where we have this ciphertext we would

679
00:28:34,260 --> 00:28:37,400
just re-encrypt the data

680
00:28:39,120 --> 00:28:42,900
when still for the uh the same uh

681
00:28:42,900 --> 00:28:46,320
first part when you say that we monitor

682
00:28:46,320 --> 00:28:48,360
it and we know how to do that is this

683
00:28:48,360 --> 00:28:51,539
like a high command type of uh service

684
00:28:51,539 --> 00:28:54,659
that does that is the center point that

685
00:28:54,659 --> 00:28:57,419
makes all this decision is this

686
00:28:57,419 --> 00:29:00,539
is there an agreement to move to the

687
00:29:00,539 --> 00:29:02,279
next key how how does that how any of

688
00:29:02,279 --> 00:29:04,500
that happens I mean basically so this

689
00:29:04,500 --> 00:29:07,140
this happens between so the monetary

690
00:29:07,140 --> 00:29:08,820
happens in the library

691
00:29:08,820 --> 00:29:10,559
and the data which is exported from

692
00:29:10,559 --> 00:29:13,440
there informs the KMS

693
00:29:13,440 --> 00:29:15,659
so the KMS would look at this and see ah

694
00:29:15,659 --> 00:29:17,820
this old key is still used in this

695
00:29:17,820 --> 00:29:20,159
service I cannot delete it

696
00:29:20,159 --> 00:29:22,200
I will check with the service why do you

697
00:29:22,200 --> 00:29:24,000
still use this key

698
00:29:24,000 --> 00:29:25,500
and based on this they would make

699
00:29:25,500 --> 00:29:28,020
informed decision on whether they yeah

700
00:29:28,020 --> 00:29:30,059
can rotate the key or delete a key or

701
00:29:30,059 --> 00:29:33,020
make a key active and

702
00:29:33,620 --> 00:29:38,700
okay I don't see more oh there you go

703
00:29:38,700 --> 00:29:40,440
so maybe a short question about the

704
00:29:40,440 --> 00:29:43,799
actual agility part so I so that you

705
00:29:43,799 --> 00:29:47,399
have hssr in your uh application layer

706
00:29:47,399 --> 00:29:51,000
Transport Security protocol is there any

707
00:29:51,000 --> 00:29:53,520
form of negotiation like can you replace

708
00:29:53,520 --> 00:29:56,159
now that post Quantum algorithm with

709
00:29:56,159 --> 00:29:57,840
something or

710
00:29:57,840 --> 00:30:00,840
yeah like basically there is some form

711
00:30:00,840 --> 00:30:03,980
of like I bent over a lot of the LTS

712
00:30:03,980 --> 00:30:07,559
specifics a bit uh quickly there is a

713
00:30:07,559 --> 00:30:10,140
form of like uh which version of the

714
00:30:10,140 --> 00:30:12,179
protocol is being used so you can change

715
00:30:12,179 --> 00:30:15,179
to to kyber later I hope that that part

716
00:30:15,179 --> 00:30:16,799
is easy so far nothing about this

717
00:30:16,799 --> 00:30:19,020
project has been easy but fingers

718
00:30:19,020 --> 00:30:20,880
crossed it should be should technically

719
00:30:20,880 --> 00:30:25,020
be simple but yeah we'll know soon

720
00:30:25,020 --> 00:30:26,600
thank you

721
00:30:26,600 --> 00:30:29,820
there's a question on the zoom um if the

722
00:30:29,820 --> 00:30:31,740
only TLS ciphers were using a forward

723
00:30:31,740 --> 00:30:34,020
secret Cyprus can we delay the rollout

724
00:30:34,020 --> 00:30:37,580
of pqc implementation

725
00:30:37,980 --> 00:30:41,100
so I'm not sure if I caught them if the

726
00:30:41,100 --> 00:30:43,559
only TLS ciphers we're using are forward

727
00:30:43,559 --> 00:30:46,080
secret ciphers can we delay the rollout

728
00:30:46,080 --> 00:30:50,220
or pkc implementation so I mean that

729
00:30:50,220 --> 00:30:53,039
depends a bit on what your goals are

730
00:30:53,039 --> 00:30:53,640
um

731
00:30:53,640 --> 00:30:56,340
this were jobs that were very very

732
00:30:56,340 --> 00:31:00,000
performance sensitive uh so the if you

733
00:31:00,000 --> 00:31:01,740
look at the actual performance numbers

734
00:31:01,740 --> 00:31:05,279
of these pqc Suites they aren't that bad

735
00:31:05,279 --> 00:31:07,620
compared to like elliptic curves so I

736
00:31:07,620 --> 00:31:10,919
think that in most cases where it's not

737
00:31:10,919 --> 00:31:13,440
like things that have to deal with like

738
00:31:13,440 --> 00:31:16,080
millions of queries in very short

739
00:31:16,080 --> 00:31:18,840
amounts of time you are probably fine

740
00:31:18,840 --> 00:31:22,260
using your perfect forward secret Cipher

741
00:31:22,260 --> 00:31:26,000
as as you used to

742
00:31:28,980 --> 00:31:30,840
questions approach the speakers later

743
00:31:30,840 --> 00:31:34,760
and thank you very much for that talk

744
00:31:48,620 --> 00:31:52,140
next we have Florian Viva talking about

745
00:31:52,140 --> 00:31:54,059
post Quantum noise

746
00:31:54,059 --> 00:31:54,720
um

747
00:31:54,720 --> 00:31:57,779
and your slides already so take it away

748
00:31:57,779 --> 00:32:01,080
hello uh yeah so I'm Florian and I will

749
00:32:01,080 --> 00:32:02,880
be talking about post Quantum noise this

750
00:32:02,880 --> 00:32:05,039
is Joint work with yawning Angel

751
00:32:05,039 --> 00:32:07,140
Benjamin Dowling Andreas Hudson and

752
00:32:07,140 --> 00:32:09,419
Peter schwabe and except for Benjamin

753
00:32:09,419 --> 00:32:12,659
the other authors are also all here

754
00:32:12,659 --> 00:32:15,000
before I start maybe a short background

755
00:32:15,000 --> 00:32:18,120
on noise first so noise is essentially a

756
00:32:18,120 --> 00:32:20,640
framework for among other things key

757
00:32:20,640 --> 00:32:22,440
exchange protocols it also includes the

758
00:32:22,440 --> 00:32:24,659
messaging phase but the part we were

759
00:32:24,659 --> 00:32:26,700
focusing on was the key exchange thing

760
00:32:26,700 --> 00:32:31,679
where noise allows you to Stamp Out key

761
00:32:31,679 --> 00:32:33,840
exchange protocols depending on your use

762
00:32:33,840 --> 00:32:36,659
case in many different ways and has many

763
00:32:36,659 --> 00:32:38,700
well-known users you may have heard of

764
00:32:38,700 --> 00:32:41,340
some of them like WhatsApp or wireguard

765
00:32:41,340 --> 00:32:44,820
lightning i2p and in its original

766
00:32:44,820 --> 00:32:47,760
version It's essentially diffie-hellman

767
00:32:47,760 --> 00:32:50,279
based and this of course has many

768
00:32:50,279 --> 00:32:52,140
advantages but a big disadvantage is

769
00:32:52,140 --> 00:32:53,700
that it's inherently vulnerable to

770
00:32:53,700 --> 00:32:55,640
quantum computers

771
00:32:55,640 --> 00:32:59,100
and so let's still take a short look on

772
00:32:59,100 --> 00:33:01,919
how this works regardless so essentially

773
00:33:01,919 --> 00:33:04,740
Noise We In classical noise we have

774
00:33:04,740 --> 00:33:06,960
static keys and ephemeral Keys a static

775
00:33:06,960 --> 00:33:09,600
key is a long-term secret generally used

776
00:33:09,600 --> 00:33:12,600
to identify yourself and get

777
00:33:12,600 --> 00:33:15,360
authenticity though it can also give you

778
00:33:15,360 --> 00:33:17,820
some kind of confidentiality in the case

779
00:33:17,820 --> 00:33:20,700
of well in this case DV Hammond later on

780
00:33:20,700 --> 00:33:23,460
key encapsulation mechanisms NF America

781
00:33:23,460 --> 00:33:26,159
Keys those are the short-term secrets

782
00:33:26,159 --> 00:33:28,019
that are there to among other things

783
00:33:28,019 --> 00:33:30,240
provide forward secrecy and post

784
00:33:30,240 --> 00:33:31,919
compromise secrecy

785
00:33:31,919 --> 00:33:35,640
and then the idea is to use many of

786
00:33:35,640 --> 00:33:38,279
these exchanges diffie-hellman or camps

787
00:33:38,279 --> 00:33:41,220
uh derive shared secrets and throw them

788
00:33:41,220 --> 00:33:44,700
into a hatch chain and so over at the

789
00:33:44,700 --> 00:33:47,159
handshake it will accumulate the several

790
00:33:47,159 --> 00:33:49,380
secrets in the hash chain and derive

791
00:33:49,380 --> 00:33:51,600
stronger and stronger session keys from

792
00:33:51,600 --> 00:33:56,580
it and then use symmetric crypto to

793
00:33:56,580 --> 00:33:59,460
transport any further payload which can

794
00:33:59,460 --> 00:34:01,260
for example if you have first an

795
00:34:01,260 --> 00:34:03,840
ephemeral exchange be the static public

796
00:34:03,840 --> 00:34:06,600
key in order to protect anonymity or in

797
00:34:06,600 --> 00:34:09,599
some cases you can also send actual

798
00:34:09,599 --> 00:34:12,300
message payload early at review at

799
00:34:12,300 --> 00:34:13,879
reduced security

800
00:34:13,879 --> 00:34:16,679
if you're saying okay this map part of

801
00:34:16,679 --> 00:34:19,619
my interaction doesn't require the full

802
00:34:19,619 --> 00:34:22,500
forward secrecy authenticity or whatever

803
00:34:22,500 --> 00:34:24,719
I'm fine with a reduced level there in

804
00:34:24,719 --> 00:34:26,820
exchange for better performance

805
00:34:26,820 --> 00:34:30,239
and so since I said it's a framework

806
00:34:30,239 --> 00:34:33,599
um you have a lot kind of an infinite

807
00:34:33,599 --> 00:34:36,418
number of possible exchanges there and

808
00:34:36,418 --> 00:34:38,699
they are described as so-called patterns

809
00:34:38,699 --> 00:34:41,879
and patterns you see in simple example

810
00:34:41,879 --> 00:34:43,399
here at the bottom

811
00:34:43,399 --> 00:34:46,320
so at first you have a label in this

812
00:34:46,320 --> 00:34:48,239
case this is the so-called XX exchange

813
00:34:48,239 --> 00:34:50,580
it just means both parties have a

814
00:34:50,580 --> 00:34:52,739
long-term secret and the secret is not

815
00:34:52,739 --> 00:34:54,179
known to the peers

816
00:34:54,179 --> 00:34:56,280
and then with these ASCII errors you

817
00:34:56,280 --> 00:34:58,980
indicate the message flow so the left to

818
00:34:58,980 --> 00:35:01,320
right arrow means from the initiator

819
00:35:01,320 --> 00:35:03,180
which is the first part yes gets actors

820
00:35:03,180 --> 00:35:05,760
active to the responder and the other

821
00:35:05,760 --> 00:35:07,980
error the other direction and then you

822
00:35:07,980 --> 00:35:10,619
have these tokens the e-token indicates

823
00:35:10,619 --> 00:35:13,260
that there that an ephemeral public key

824
00:35:13,260 --> 00:35:15,540
is being transmitted here generally as

825
00:35:15,540 --> 00:35:17,400
plain text

826
00:35:17,400 --> 00:35:20,099
um and with diffie-hellman you can now

827
00:35:20,099 --> 00:35:22,560
combine uh various secrets so for

828
00:35:22,560 --> 00:35:24,720
example the ephemeral token of the

829
00:35:24,720 --> 00:35:27,240
initiator and responder in this ee

830
00:35:27,240 --> 00:35:29,640
exchange the first token identifies the

831
00:35:29,640 --> 00:35:31,680
secret of the initiator the segment of

832
00:35:31,680 --> 00:35:34,320
the responder you derive your key and

833
00:35:34,320 --> 00:35:36,060
then everything that follows is

834
00:35:36,060 --> 00:35:38,640
encrypted under a key that is among

835
00:35:38,640 --> 00:35:41,280
other things derived from that shared

836
00:35:41,280 --> 00:35:43,920
secret and it is a token you then have

837
00:35:43,920 --> 00:35:45,960
the S that's the static or long-term

838
00:35:45,960 --> 00:35:48,480
secret and then you can combine the

839
00:35:48,480 --> 00:35:50,160
initiators ephemeral and the respond

840
00:35:50,160 --> 00:35:52,079
aesthetic secret and so on and you

841
00:35:52,079 --> 00:35:54,599
derive stronger and stronger keys to

842
00:35:54,599 --> 00:35:56,940
protect your interaction

843
00:35:56,940 --> 00:35:59,640
and now our goal was we want to have

844
00:35:59,640 --> 00:36:02,160
essentially the same thing but secure in

845
00:36:02,160 --> 00:36:03,839
a post Quantum setting

846
00:36:03,839 --> 00:36:06,000
and the most obvious idea you could have

847
00:36:06,000 --> 00:36:07,980
is let's just replace all these

848
00:36:07,980 --> 00:36:09,780
different element key exchanges with key

849
00:36:09,780 --> 00:36:11,780
encapsulation mechanisms

850
00:36:11,780 --> 00:36:14,640
and for some parts of this this works

851
00:36:14,640 --> 00:36:17,220
very simply so if you have the ephemeral

852
00:36:17,220 --> 00:36:19,980
token so the E you just send an

853
00:36:19,980 --> 00:36:22,740
ephemeral a public key for a cam or same

854
00:36:22,740 --> 00:36:25,500
for static public keys this all

855
00:36:25,500 --> 00:36:27,359
essentially works as before

856
00:36:27,359 --> 00:36:29,220
and then we introduced two new tokens

857
00:36:29,220 --> 00:36:32,760
here the ecam and the s-cam ecam means

858
00:36:32,760 --> 00:36:35,940
this is a camp ciphertext that's

859
00:36:35,940 --> 00:36:38,160
encapsulated for the ephemeral key and

860
00:36:38,160 --> 00:36:40,140
s-cam means it's encapsulated for the

861
00:36:40,140 --> 00:36:42,420
static key

862
00:36:42,420 --> 00:36:46,140
um and to somehow try to stay consistent

863
00:36:46,140 --> 00:36:48,720
with the noise does ecam tokens are

864
00:36:48,720 --> 00:36:49,740
generally

865
00:36:49,740 --> 00:36:52,079
ecam ciphertext are generally sent

866
00:36:52,079 --> 00:36:55,380
unencrypted and SMR if there is already

867
00:36:55,380 --> 00:36:58,940
a key send encrypted

868
00:36:58,940 --> 00:37:03,180
and if you try this you run into a few

869
00:37:03,180 --> 00:37:04,940
problems so

870
00:37:04,940 --> 00:37:08,700
diffie-hellman is not just a chem it

871
00:37:08,700 --> 00:37:10,760
provides a functionality known as

872
00:37:10,760 --> 00:37:14,579
non-interactive key exchange or Nike

873
00:37:14,579 --> 00:37:17,160
and that is much more powerful

874
00:37:17,160 --> 00:37:19,260
um it can for example be used to

875
00:37:19,260 --> 00:37:22,020
establish bi-directional authenticity if

876
00:37:22,020 --> 00:37:24,660
you combine two static different public

877
00:37:24,660 --> 00:37:27,300
Keys you get bi-directional authenticity

878
00:37:27,300 --> 00:37:29,460
and with a chem it's really not obvious

879
00:37:29,460 --> 00:37:31,200
non-obvious

880
00:37:31,200 --> 00:37:34,140
what to do there you can also combine

881
00:37:34,140 --> 00:37:37,079
these um TV helmet Secrets freely

882
00:37:37,079 --> 00:37:38,880
whereas with a cam you have a public key

883
00:37:38,880 --> 00:37:40,859
and you have a cipher text and if you

884
00:37:40,859 --> 00:37:42,900
try to use the cipher text as a public

885
00:37:42,900 --> 00:37:43,920
key

886
00:37:43,920 --> 00:37:46,140
I don't know what you're supposed to do

887
00:37:46,140 --> 00:37:48,180
there this is there's no clear solution

888
00:37:48,180 --> 00:37:49,380
there

889
00:37:49,380 --> 00:37:50,400
so

890
00:37:50,400 --> 00:37:53,160
let's look at how this turned out for

891
00:37:53,160 --> 00:37:55,260
noise so some cases we're actually still

892
00:37:55,260 --> 00:37:57,599
completely trivial if you had the ee so

893
00:37:57,599 --> 00:38:00,420
combination of ephemeral Keys tokens we

894
00:38:00,420 --> 00:38:01,980
could just replace it with an ecamp

895
00:38:01,980 --> 00:38:05,400
token and similarly if we had a

896
00:38:05,400 --> 00:38:07,920
combination of an ephemeral key and a

897
00:38:07,920 --> 00:38:10,200
static public key and the receiving

898
00:38:10,200 --> 00:38:13,740
party of that interaction so notice the

899
00:38:13,740 --> 00:38:15,079
errors there

900
00:38:15,079 --> 00:38:18,780
is the use of the static key we can also

901
00:38:18,780 --> 00:38:21,540
use the s-cam token there in this case

902
00:38:21,540 --> 00:38:24,000
we view the encryption the encapsulation

903
00:38:24,000 --> 00:38:28,020
Randomness as an ephemeral secret of the

904
00:38:28,020 --> 00:38:30,720
sending party and we get our camera

905
00:38:30,720 --> 00:38:32,940
placement so that works without any

906
00:38:32,940 --> 00:38:34,200
issues

907
00:38:34,200 --> 00:38:37,680
then we have the case where it's being

908
00:38:37,680 --> 00:38:39,960
sent the other way around where the

909
00:38:39,960 --> 00:38:42,900
sending party's static key is used and

910
00:38:42,900 --> 00:38:45,839
the receiving part is ephemeral key and

911
00:38:45,839 --> 00:38:48,359
it turns out that if we try to translate

912
00:38:48,359 --> 00:38:50,099
it into chems

913
00:38:50,099 --> 00:38:52,140
it's really not obvious what to do there

914
00:38:52,140 --> 00:38:54,780
because what this essentially means is I

915
00:38:54,780 --> 00:38:57,180
have my static public key and the other

916
00:38:57,180 --> 00:38:58,740
guy has an ephemeral secret the

917
00:38:58,740 --> 00:39:01,800
randomness intended to encapsulate and

918
00:39:01,800 --> 00:39:04,079
now I'm supposed to create a ciphertext

919
00:39:04,079 --> 00:39:06,420
that can be decrypted with that

920
00:39:06,420 --> 00:39:09,960
Randomness it doesn't add up so solution

921
00:39:09,960 --> 00:39:13,020
that works there is you essentially stop

922
00:39:13,020 --> 00:39:14,940
the pattern at that point and send it

923
00:39:14,940 --> 00:39:17,160
the other direction around it's a bit

924
00:39:17,160 --> 00:39:19,440
brute forcey it adds up to a full round

925
00:39:19,440 --> 00:39:21,660
trip but it works

926
00:39:21,660 --> 00:39:24,599
and then we have the really nasty case

927
00:39:24,599 --> 00:39:27,900
that's the combination of the static

928
00:39:27,900 --> 00:39:30,720
public keys so the first thing you can

929
00:39:30,720 --> 00:39:33,839
do there is you can send an SM in both

930
00:39:33,839 --> 00:39:35,280
directions so that you have a

931
00:39:35,280 --> 00:39:38,760
encapsulation for both static public

932
00:39:38,760 --> 00:39:41,160
Keys which gives you authenticity

933
00:39:41,160 --> 00:39:44,099
but it still fails on one issue

934
00:39:44,099 --> 00:39:46,619
if you're considering cases where the

935
00:39:46,619 --> 00:39:48,540
ephemeral Randomness could be corrupted

936
00:39:48,540 --> 00:39:50,700
for example because you're using a bad

937
00:39:50,700 --> 00:39:52,320
random number generators it's not like

938
00:39:52,320 --> 00:39:54,540
that never happened

939
00:39:54,540 --> 00:39:57,000
um the SS exchange will actually save

940
00:39:57,000 --> 00:39:59,880
you because there is no FML entropy in

941
00:39:59,880 --> 00:40:02,099
there so even if your random number

942
00:40:02,099 --> 00:40:04,260
generator fully leaks everything to the

943
00:40:04,260 --> 00:40:07,260
adversary doesn't help them whereas if

944
00:40:07,260 --> 00:40:10,320
we send the camps both ways

945
00:40:10,320 --> 00:40:12,320
we have an issue there

946
00:40:12,320 --> 00:40:15,540
so we found a solution to cheat there a

947
00:40:15,540 --> 00:40:18,060
little bit and overall though this works

948
00:40:18,060 --> 00:40:19,980
but it's not

949
00:40:19,980 --> 00:40:20,700
um

950
00:40:20,700 --> 00:40:22,680
always the optimal pattern that you can

951
00:40:22,680 --> 00:40:25,380
get so we also designed a couple of

952
00:40:25,380 --> 00:40:29,359
patterns specifically intended to be

953
00:40:29,359 --> 00:40:32,640
usable in the cases for which noise also

954
00:40:32,640 --> 00:40:34,859
gives some base patterns or fundamental

955
00:40:34,859 --> 00:40:36,960
patterns that cover the most common use

956
00:40:36,960 --> 00:40:38,400
cases

957
00:40:38,400 --> 00:40:41,339
so I talked about we need to cheat so

958
00:40:41,339 --> 00:40:44,760
there is this technique of combining the

959
00:40:44,760 --> 00:40:46,500
ephemeral randomness of aesthetic

960
00:40:46,500 --> 00:40:47,760
secrets

961
00:40:47,760 --> 00:40:50,280
I think the first use case where this

962
00:40:50,280 --> 00:40:52,800
was used was the Nexus trick later on

963
00:40:52,800 --> 00:40:54,720
there is a paper where it introduced The

964
00:40:54,720 --> 00:40:57,900
Twisted PF trick to do similar things we

965
00:40:57,900 --> 00:40:59,640
actually have an RFC on a technique that

966
00:40:59,640 --> 00:41:01,740
is based on signatures

967
00:41:01,740 --> 00:41:03,660
interestingly enough though this was

968
00:41:03,660 --> 00:41:06,780
never introduced as its own primitive so

969
00:41:06,780 --> 00:41:09,180
what we did in this place was to say

970
00:41:09,180 --> 00:41:12,119
we introduced this as the Primitive of

971
00:41:12,119 --> 00:41:14,000
static ephemeral entropy combination

972
00:41:14,000 --> 00:41:17,220
provided a security definition there and

973
00:41:17,220 --> 00:41:19,260
we now uh with that security and a

974
00:41:19,260 --> 00:41:20,880
definition we could then analyze the

975
00:41:20,880 --> 00:41:22,800
protocol for the cases where you do use

976
00:41:22,800 --> 00:41:25,079
it and where you do not use it and if

977
00:41:25,079 --> 00:41:27,960
both parties use or if at least one

978
00:41:27,960 --> 00:41:30,119
party uses static ephemeral entropy

979
00:41:30,119 --> 00:41:32,339
combination and you're set in an s-cam

980
00:41:32,339 --> 00:41:34,560
both ways you are actually back to the

981
00:41:34,560 --> 00:41:36,320
point where you have confidentiality

982
00:41:36,320 --> 00:41:38,700
even if

983
00:41:38,700 --> 00:41:40,320
um you have a Corruption of the

984
00:41:40,320 --> 00:41:43,079
ephemeral secrets so ways to achieve

985
00:41:43,079 --> 00:41:44,940
this there are many the simplest one is

986
00:41:44,940 --> 00:41:47,160
you just throw them into a dual prf

987
00:41:47,160 --> 00:41:48,420
function essentially

988
00:41:48,420 --> 00:41:50,640
we picked a slightly weaker notion and

989
00:41:50,640 --> 00:41:53,280
possible that way it's we all the

990
00:41:53,280 --> 00:41:54,900
existing techniques are still applicable

991
00:41:54,900 --> 00:41:55,859
to us

992
00:41:55,859 --> 00:41:59,160
and yeah so that worked and we can now

993
00:41:59,160 --> 00:42:02,339
get to the analysis of our results so

994
00:42:02,339 --> 00:42:05,640
we were using the facce model uh because

995
00:42:05,640 --> 00:42:08,280
uh previous analysis of the noise

996
00:42:08,280 --> 00:42:09,960
framework had used that and it's kind of

997
00:42:09,960 --> 00:42:13,440
designed for noise it's specifically

998
00:42:13,440 --> 00:42:15,599
talking about the several stages in

999
00:42:15,599 --> 00:42:18,180
which the protocol advances and then

1000
00:42:18,180 --> 00:42:22,020
specifies the security guarantees given

1001
00:42:22,020 --> 00:42:23,820
um I think it's fair to say that many

1002
00:42:23,820 --> 00:42:27,300
reviewers dislike this model

1003
00:42:27,300 --> 00:42:30,599
um so anyways in the end we got accepted

1004
00:42:30,599 --> 00:42:31,980
at CCS

1005
00:42:31,980 --> 00:42:34,500
um despite it

1006
00:42:34,500 --> 00:42:37,800
um and the other thing we did uh

1007
00:42:37,800 --> 00:42:39,660
compared to this previous analysis of

1008
00:42:39,660 --> 00:42:42,420
noise so what we had until then was

1009
00:42:42,420 --> 00:42:44,160
essentially an analysis of individual

1010
00:42:44,160 --> 00:42:46,500
noise patterns and a lot of this

1011
00:42:46,500 --> 00:42:48,180
analysis followed the traditional

1012
00:42:48,180 --> 00:42:50,880
approach of we replace each hash call or

1013
00:42:50,880 --> 00:42:53,640
hmac call with a prf call essentially

1014
00:42:53,640 --> 00:42:55,320
and then have a security statement where

1015
00:42:55,320 --> 00:42:58,319
you have this one point in there like

1016
00:42:58,319 --> 00:43:01,680
plus 10 times advantage against prf

1017
00:43:01,680 --> 00:43:04,859
but noise is not just using these hash

1018
00:43:04,859 --> 00:43:06,599
functions randomly there really is

1019
00:43:06,599 --> 00:43:09,060
essentially an ad hoc hash object in

1020
00:43:09,060 --> 00:43:09,900
there

1021
00:43:09,900 --> 00:43:12,780
so what we did there was to define a

1022
00:43:12,780 --> 00:43:15,780
hash object where you can feed values in

1023
00:43:15,780 --> 00:43:17,880
and once you feed uncorrupted Randomness

1024
00:43:17,880 --> 00:43:20,400
in all the outputs are essentially

1025
00:43:20,400 --> 00:43:21,859
random

1026
00:43:21,859 --> 00:43:25,020
and that allowed us to do a truly

1027
00:43:25,020 --> 00:43:27,359
generic analysis of noise

1028
00:43:27,359 --> 00:43:30,540
now one issue we ran into the noise hash

1029
00:43:30,540 --> 00:43:33,660
object does a bit of a weird thing at

1030
00:43:33,660 --> 00:43:34,740
the end

1031
00:43:34,740 --> 00:43:37,079
uh one of the outputs at the last call

1032
00:43:37,079 --> 00:43:39,660
is the thing that until then would have

1033
00:43:39,660 --> 00:43:41,760
essentially been the state so we

1034
00:43:41,760 --> 00:43:44,640
actually introduced a noise pseudorandom

1035
00:43:44,640 --> 00:43:46,760
hash object that has special cases there

1036
00:43:46,760 --> 00:43:50,040
uh I think Trevor already kind of hinted

1037
00:43:50,040 --> 00:43:51,839
that maybe in future version this will

1038
00:43:51,839 --> 00:43:53,880
be changed because I've also heard from

1039
00:43:53,880 --> 00:43:55,380
implementer status like this case

1040
00:43:55,380 --> 00:43:57,359
distinctions

1041
00:43:57,359 --> 00:43:59,640
um so with that we could then analyze

1042
00:43:59,640 --> 00:44:02,579
all arbitrary patterns and we match all

1043
00:44:02,579 --> 00:44:04,740
the previously proven security

1044
00:44:04,740 --> 00:44:07,680
statements in the facce model and we

1045
00:44:07,680 --> 00:44:10,140
match the conjecture at once as I said

1046
00:44:10,140 --> 00:44:12,119
the previous analysis didn't cover all

1047
00:44:12,119 --> 00:44:14,060
possible pattern so there are some

1048
00:44:14,060 --> 00:44:16,680
unproven but very very reasonable

1049
00:44:16,680 --> 00:44:19,020
conjectures in there

1050
00:44:19,020 --> 00:44:21,000
um I'd also like to note we treated all

1051
00:44:21,000 --> 00:44:22,859
the key encapsulation mechanisms

1052
00:44:22,859 --> 00:44:26,040
separately so you don't have to use say

1053
00:44:26,040 --> 00:44:29,099
kyber in every single place you can for

1054
00:44:29,099 --> 00:44:31,440
example use kyber as the ephemeral chem

1055
00:44:31,440 --> 00:44:34,619
and then if you have a situation where

1056
00:44:34,619 --> 00:44:37,800
the static public is already known to

1057
00:44:37,800 --> 00:44:39,900
the peers they can for example use

1058
00:44:39,900 --> 00:44:42,740
classic mcalees which in that setting

1059
00:44:42,740 --> 00:44:44,700
outperforms essentially all the

1060
00:44:44,700 --> 00:44:47,819
competitors and gives you what I'll

1061
00:44:47,819 --> 00:44:50,520
sometimes call a poor man's hybrid

1062
00:44:50,520 --> 00:44:51,920
scheme

1063
00:44:51,920 --> 00:44:54,780
it gives your hybrid Security in a sense

1064
00:44:54,780 --> 00:44:57,180
that if either Kaiba or mcalees gets

1065
00:44:57,180 --> 00:44:59,819
broken you have still security

1066
00:44:59,819 --> 00:45:03,060
but under more restrictive corruption

1067
00:45:03,060 --> 00:45:05,760
scenarios so

1068
00:45:05,760 --> 00:45:07,619
um also you can do it for performance

1069
00:45:07,619 --> 00:45:09,599
reasons or you can do it as like a very

1070
00:45:09,599 --> 00:45:11,640
cheap way to hatch your bets against

1071
00:45:11,640 --> 00:45:13,200
certain schemes

1072
00:45:13,200 --> 00:45:16,560
so slightly more specific to results if

1073
00:45:16,560 --> 00:45:18,960
you use an ephemeral chem so if you have

1074
00:45:18,960 --> 00:45:21,599
the ecam token in your pattern

1075
00:45:21,599 --> 00:45:24,480
then after the ecam token everything

1076
00:45:24,480 --> 00:45:27,900
that is sent is confidential as long as

1077
00:45:27,900 --> 00:45:29,760
the ephemeral keys of both parties are

1078
00:45:29,760 --> 00:45:32,640
uncorrupted assuming you follow basic

1079
00:45:32,640 --> 00:45:34,380
rules about how noise is supposed to be

1080
00:45:34,380 --> 00:45:35,700
implemented

1081
00:45:35,700 --> 00:45:41,400
if you send a s-cam so static chem you

1082
00:45:41,400 --> 00:45:42,980
have a

1083
00:45:42,980 --> 00:45:45,119
confidentiality also from that point

1084
00:45:45,119 --> 00:45:48,420
onward as long as the encapsulating

1085
00:45:48,420 --> 00:45:50,760
party's ephemeral key and the receiving

1086
00:45:50,760 --> 00:45:54,000
party's static key is uncorrupted and

1087
00:45:54,000 --> 00:45:55,859
under the in the same setting you get

1088
00:45:55,859 --> 00:45:58,200
authenticity after one round trip in

1089
00:45:58,200 --> 00:45:59,819
this case your essentially require a key

1090
00:45:59,819 --> 00:46:02,640
confirmation which is the loss which is

1091
00:46:02,640 --> 00:46:05,040
the cause of you sometimes needing an

1092
00:46:05,040 --> 00:46:06,420
additional round trip even with the

1093
00:46:06,420 --> 00:46:09,420
optimal patterns if you run PQ noise

1094
00:46:09,420 --> 00:46:11,819
compared to noise because if peaky noise

1095
00:46:11,819 --> 00:46:14,040
you have to do challenge response with

1096
00:46:14,040 --> 00:46:15,839
Nikes like different helmet you can

1097
00:46:15,839 --> 00:46:17,640
sometimes avoid them

1098
00:46:17,640 --> 00:46:21,300
and then if you decide to use seek or

1099
00:46:21,300 --> 00:46:24,240
static fmr entropy combination then you

1100
00:46:24,240 --> 00:46:26,040
can essentially take these statements

1101
00:46:26,040 --> 00:46:28,920
and everywhere it says that the static

1102
00:46:28,920 --> 00:46:32,960
key needs to be uncorrupted for

1103
00:46:33,060 --> 00:46:34,920
um sorry

1104
00:46:34,920 --> 00:46:36,540
that the ephemera key needs to be

1105
00:46:36,540 --> 00:46:39,060
uncorrupted you can say alternatively

1106
00:46:39,060 --> 00:46:41,780
the static key needs to be uncorrupted

1107
00:46:41,780 --> 00:46:44,220
which gives you the protection against

1108
00:46:44,220 --> 00:46:46,440
the case where ephemeral keys are

1109
00:46:46,440 --> 00:46:48,180
compromised but you have an SS exchange

1110
00:46:48,180 --> 00:46:50,640
India

1111
00:46:50,640 --> 00:46:53,760
um on the performance level uh we are

1112
00:46:53,760 --> 00:46:55,740
yawning did an implementation in

1113
00:46:55,740 --> 00:46:58,339
newquist using level 3 kyber

1114
00:46:58,339 --> 00:47:00,720
and if you're looking at the numbers so

1115
00:47:00,720 --> 00:47:02,520
we have two patterns there the first one

1116
00:47:02,520 --> 00:47:05,099
the KK pattern is kind of the one that I

1117
00:47:05,099 --> 00:47:06,420
described where the aesthetic public

1118
00:47:06,420 --> 00:47:08,880
keys are known to the peers and if

1119
00:47:08,880 --> 00:47:10,980
you're looking at the numbers

1120
00:47:10,980 --> 00:47:14,460
um both on a slow and a fast Network we

1121
00:47:14,460 --> 00:47:17,520
are fully competitive with uh elliptic

1122
00:47:17,520 --> 00:47:20,940
curve based noise in fact in some cases

1123
00:47:20,940 --> 00:47:22,859
on the responder side even faster

1124
00:47:22,859 --> 00:47:25,260
because of how fast kyber is

1125
00:47:25,260 --> 00:47:28,200
and the second example the XX pattern

1126
00:47:28,200 --> 00:47:30,240
that's the one where you have transmit

1127
00:47:30,240 --> 00:47:32,579
the public keys

1128
00:47:32,579 --> 00:47:34,740
um this is also a pattern where you no

1129
00:47:34,740 --> 00:47:36,540
longer can do a trivial replacement but

1130
00:47:36,540 --> 00:47:37,680
where you actually need a full

1131
00:47:37,680 --> 00:47:40,140
additional round trip uh you see still

1132
00:47:40,140 --> 00:47:42,359
on the responder side virtually nothing

1133
00:47:42,359 --> 00:47:45,180
changes on a receipt on the initiator

1134
00:47:45,180 --> 00:47:48,119
side we do get a factor of two overhead

1135
00:47:48,119 --> 00:47:51,300
but still at what I would consider very

1136
00:47:51,300 --> 00:47:53,640
reasonable timings

1137
00:47:53,640 --> 00:47:54,720
um

1138
00:47:54,720 --> 00:47:57,420
and yeah with that I'd like to thank you

1139
00:47:57,420 --> 00:47:59,640
for your attention and also Trevor

1140
00:47:59,640 --> 00:48:02,819
Perrin and Denisa krakonichi for many

1141
00:48:02,819 --> 00:48:06,020
helpful discussions we had

1142
00:48:06,890 --> 00:48:13,760
[Applause]

1143
00:48:13,760 --> 00:48:16,260
representation do we have any question

1144
00:48:16,260 --> 00:48:19,079
from the public I see known in the

1145
00:48:19,079 --> 00:48:21,180
sumchat if you have a question please

1146
00:48:21,180 --> 00:48:23,400
approach the mic

1147
00:48:23,400 --> 00:48:25,980
in the meantime Florian did you also

1148
00:48:25,980 --> 00:48:28,680
Benchmark the performance of the

1149
00:48:28,680 --> 00:48:31,079
protocol with other suits that were not

1150
00:48:31,079 --> 00:48:34,800
kyber did you try other algorithms so I

1151
00:48:34,800 --> 00:48:37,579
was not involved with that part I think

1152
00:48:37,579 --> 00:48:41,040
uh the only numbers we have right now is

1153
00:48:41,040 --> 00:48:44,819
Khyber in that regard but uh I mean

1154
00:48:44,819 --> 00:48:47,760
another aspect is that uh the network in

1155
00:48:47,760 --> 00:48:49,920
many cases of course is a significant

1156
00:48:49,920 --> 00:48:53,540
part of actual performance costs

1157
00:48:54,660 --> 00:48:56,280
um could you clarify what went behind

1158
00:48:56,280 --> 00:48:58,560
the process of choosing to rewrite noise

1159
00:48:58,560 --> 00:49:00,240
with a key encapsulation mechanism

1160
00:49:00,240 --> 00:49:02,400
rather than just giving parameters for a

1161
00:49:02,400 --> 00:49:04,339
key exchange

1162
00:49:04,339 --> 00:49:06,780
but do you mean

1163
00:49:06,780 --> 00:49:09,420
couldn't I just have done lwe key

1164
00:49:09,420 --> 00:49:12,960
exchange with no with uh with noise

1165
00:49:12,960 --> 00:49:15,300
um what what is the problem there so I

1166
00:49:15,300 --> 00:49:17,400
mean the for Stardust in this process

1167
00:49:17,400 --> 00:49:19,619
standardizes pre-encapsulation mechanism

1168
00:49:19,619 --> 00:49:23,099
so that's kind of the Primitive we have

1169
00:49:23,099 --> 00:49:24,000
um

1170
00:49:24,000 --> 00:49:27,140
I'm not sure that the

1171
00:49:27,140 --> 00:49:30,780
rlwe exchanges uh can replace a

1172
00:49:30,780 --> 00:49:32,760
non-interactive key exchange

1173
00:49:32,760 --> 00:49:36,000
Seaside would be able to

1174
00:49:36,000 --> 00:49:38,579
um and I'm told that all the breaks of

1175
00:49:38,579 --> 00:49:41,700
isageny do not affect Seaside on a

1176
00:49:41,700 --> 00:49:43,140
fundamental level

1177
00:49:43,140 --> 00:49:47,339
so if you feel very con confident about

1178
00:49:47,339 --> 00:49:50,040
the security of it you might be able to

1179
00:49:50,040 --> 00:49:52,200
replace it with Seaside

1180
00:49:52,200 --> 00:49:54,480
but I have a feeling you're not going to

1181
00:49:54,480 --> 00:49:56,280
find many friends if that's your

1182
00:49:56,280 --> 00:49:57,480
approach

1183
00:49:57,480 --> 00:49:59,940
night night

1184
00:49:59,940 --> 00:50:03,440
okay thank you

1185
00:50:03,480 --> 00:50:05,940
last there's a question on the chart is

1186
00:50:05,940 --> 00:50:09,119
there any plans to support I guess in

1187
00:50:09,119 --> 00:50:11,760
in world since hybrid class or PQ or

1188
00:50:11,760 --> 00:50:14,760
post Quantum cryptography noise

1189
00:50:14,760 --> 00:50:17,160
so I'm not directly involved with noise

1190
00:50:17,160 --> 00:50:19,440
uh that being said maybe I should have

1191
00:50:19,440 --> 00:50:22,440
stresses a bit more the security results

1192
00:50:22,440 --> 00:50:25,319
I've shown you they really are standing

1193
00:50:25,319 --> 00:50:27,720
on their own it's if you have an s-cam

1194
00:50:27,720 --> 00:50:29,579
or an ecam token there this is the

1195
00:50:29,579 --> 00:50:32,099
guarantee we get we give you this does

1196
00:50:32,099 --> 00:50:34,200
not affect any security guarantees you

1197
00:50:34,200 --> 00:50:36,420
get from also having diffie-hellman

1198
00:50:36,420 --> 00:50:37,920
exchanges in there so if you do

1199
00:50:37,920 --> 00:50:40,200
non-composite

1200
00:50:40,200 --> 00:50:42,960
um hybrid this is completely covered we

1201
00:50:42,960 --> 00:50:44,339
don't talk about it if your helmet

1202
00:50:44,339 --> 00:50:47,220
guarantees but we can fully assure you

1203
00:50:47,220 --> 00:50:49,800
if you do what we are telling you in

1204
00:50:49,800 --> 00:50:52,380
terms of the post Quantum part you're

1205
00:50:52,380 --> 00:50:57,359
getting the security if you run a

1206
00:50:57,359 --> 00:50:59,880
composite hybrid they essentially have a

1207
00:50:59,880 --> 00:51:02,220
where your cam is not kyber but kyber

1208
00:51:02,220 --> 00:51:06,420
plus x2519 let's say of course we only

1209
00:51:06,420 --> 00:51:09,300
talk about it on the Primitive levels so

1210
00:51:09,300 --> 00:51:11,099
that also works

1211
00:51:11,099 --> 00:51:14,040
and if you want to run several cams

1212
00:51:14,040 --> 00:51:16,859
again the statement we have about what

1213
00:51:16,859 --> 00:51:18,480
ecam and S can give you in terms of

1214
00:51:18,480 --> 00:51:21,300
guarantees fully cover also repeated

1215
00:51:21,300 --> 00:51:24,780
uses of these tokens so I think we have

1216
00:51:24,780 --> 00:51:26,640
a pretty strong coverage of hybrid

1217
00:51:26,640 --> 00:51:29,540
security there

1218
00:51:35,040 --> 00:51:38,839
Talk of the session that is

1219
00:51:43,319 --> 00:51:46,140
next we have the the last Talk of the

1220
00:51:46,140 --> 00:51:47,700
session is going to be given by

1221
00:51:47,700 --> 00:51:50,640
gurobansi Poli polichala about post

1222
00:51:50,640 --> 00:51:52,920
Quantum privacy pass via post Quantum

1223
00:51:52,920 --> 00:51:55,020
Anonymous credentials

1224
00:51:55,020 --> 00:51:57,480
thanks for getting my name right okay so

1225
00:51:57,480 --> 00:51:58,920
today I'm going to be talking about post

1226
00:51:58,920 --> 00:52:00,960
Quantum privacy pass via post Quantum

1227
00:52:00,960 --> 00:52:02,640
Anonymous credentials

1228
00:52:02,640 --> 00:52:04,559
okay so I want to start with talking

1229
00:52:04,559 --> 00:52:06,540
about what's the status of post Quantum

1230
00:52:06,540 --> 00:52:08,880
crypto today right if we think about

1231
00:52:08,880 --> 00:52:11,940
encryption and signatures uh people seem

1232
00:52:11,940 --> 00:52:13,920
to be reasonably happy with them nist

1233
00:52:13,920 --> 00:52:15,839
has proposed four algorithms which are

1234
00:52:15,839 --> 00:52:17,760
to be standardized but the second you

1235
00:52:17,760 --> 00:52:19,680
move past this right to a little bit

1236
00:52:19,680 --> 00:52:21,540
more advanced crypto let's think

1237
00:52:21,540 --> 00:52:23,339
something like blind signatures or

1238
00:52:23,339 --> 00:52:25,380
oblivious pseudorandom functions or even

1239
00:52:25,380 --> 00:52:27,059
Anonymous credentials right

1240
00:52:27,059 --> 00:52:29,040
the situation doesn't really look so

1241
00:52:29,040 --> 00:52:30,480
good there

1242
00:52:30,480 --> 00:52:32,520
um so for blind signatures and oblivious

1243
00:52:32,520 --> 00:52:34,079
to the random functions we have what I

1244
00:52:34,079 --> 00:52:35,940
would call semi-practical constructions

1245
00:52:35,940 --> 00:52:37,680
by semi-practical I mean you know you

1246
00:52:37,680 --> 00:52:39,359
can Implement them you can run them you

1247
00:52:39,359 --> 00:52:41,339
can get numbers but there's still orders

1248
00:52:41,339 --> 00:52:43,260
of magnitude worse than their classical

1249
00:52:43,260 --> 00:52:45,300
counterparts and for anonymous

1250
00:52:45,300 --> 00:52:46,859
credentials I would still consider the

1251
00:52:46,859 --> 00:52:48,540
research to be theoretical because

1252
00:52:48,540 --> 00:52:51,480
there's just no implementation

1253
00:52:51,480 --> 00:52:53,220
um okay so what is the need for

1254
00:52:53,220 --> 00:52:54,960
efficient post Quantum Primitives like

1255
00:52:54,960 --> 00:52:57,059
this all of these companies that have

1256
00:52:57,059 --> 00:52:58,319
listed here and even some companies in

1257
00:52:58,319 --> 00:53:00,720
the EU have deployed some variant of

1258
00:53:00,720 --> 00:53:03,059
these Primitives and collectively

1259
00:53:03,059 --> 00:53:04,859
they're effectively impacting billions

1260
00:53:04,859 --> 00:53:07,440
of users so when you have such wide

1261
00:53:07,440 --> 00:53:09,240
impact you know you really want to

1262
00:53:09,240 --> 00:53:11,520
migrate to post Quantum as soon as

1263
00:53:11,520 --> 00:53:13,020
possible

1264
00:53:13,020 --> 00:53:14,819
um so hopefully at the end of this talk

1265
00:53:14,819 --> 00:53:16,200
we'll be able to make some progress

1266
00:53:16,200 --> 00:53:18,839
towards this and for the case of

1267
00:53:18,839 --> 00:53:20,880
anonymous credentials we'll move from a

1268
00:53:20,880 --> 00:53:24,540
theoretical stance to semi-practical

1269
00:53:24,540 --> 00:53:27,480
okay great so let's dive in

1270
00:53:27,480 --> 00:53:29,040
um I'm going to start by defining what a

1271
00:53:29,040 --> 00:53:31,500
blind signature is so let's say Alice

1272
00:53:31,500 --> 00:53:33,839
has a message m a server has a signing

1273
00:53:33,839 --> 00:53:36,240
key SK and now the goal is for Alice to

1274
00:53:36,240 --> 00:53:38,280
obtain a signature such that the server

1275
00:53:38,280 --> 00:53:40,859
learns nothing about the message M and

1276
00:53:40,859 --> 00:53:42,180
Alice should not learn anything about

1277
00:53:42,180 --> 00:53:43,800
the secret key SK

1278
00:53:43,800 --> 00:53:45,240
there's going to be some interactive

1279
00:53:45,240 --> 00:53:47,040
protocol at the end of this Alice is

1280
00:53:47,040 --> 00:53:48,900
going to be a signature which verifies

1281
00:53:48,900 --> 00:53:51,059
under the corresponding verification key

1282
00:53:51,059 --> 00:53:52,619
great

1283
00:53:52,619 --> 00:53:54,359
um so you know suppose you had blind

1284
00:53:54,359 --> 00:53:56,460
signatures how are these companies and

1285
00:53:56,460 --> 00:53:57,839
countries really using these things

1286
00:53:57,839 --> 00:53:59,099
right

1287
00:53:59,099 --> 00:54:01,079
um a very common application is to

1288
00:54:01,079 --> 00:54:02,940
authenticate in a privacy preserving

1289
00:54:02,940 --> 00:54:05,400
manner what do I mean by this I'll go in

1290
00:54:05,400 --> 00:54:07,920
with an example so let's say Alice wants

1291
00:54:07,920 --> 00:54:09,420
to visit a website right she's gonna go

1292
00:54:09,420 --> 00:54:12,000
type in her address but bam she's going

1293
00:54:12,000 --> 00:54:14,099
to get thrown with the captcha Alice is

1294
00:54:14,099 --> 00:54:15,480
going to be angry and frustrated as I

1295
00:54:15,480 --> 00:54:16,920
would be as well

1296
00:54:16,920 --> 00:54:19,680
um and you know we're cryptographers

1297
00:54:19,680 --> 00:54:22,079
right is there a way to avoid catches

1298
00:54:22,079 --> 00:54:24,480
without compromising privacy

1299
00:54:24,480 --> 00:54:25,920
and turns out if you're given blind

1300
00:54:25,920 --> 00:54:28,200
signatures you can so what else is going

1301
00:54:28,200 --> 00:54:30,240
to do is going to go to a server which

1302
00:54:30,240 --> 00:54:32,400
the website trusts so this could be

1303
00:54:32,400 --> 00:54:34,020
cloudflare for example and the reason

1304
00:54:34,020 --> 00:54:36,240
this website would trust cloudflare is

1305
00:54:36,240 --> 00:54:39,720
because uh cloudflare could be its CDN

1306
00:54:39,720 --> 00:54:40,800
um so now what's going to happen is

1307
00:54:40,800 --> 00:54:42,420
Alice is going to sample a random non's

1308
00:54:42,420 --> 00:54:43,980
TK and she's going to get a blind

1309
00:54:43,980 --> 00:54:46,140
signature on this

1310
00:54:46,140 --> 00:54:47,520
um and what she's going to do is she's

1311
00:54:47,520 --> 00:54:49,859
going to give a signature on TK to the

1312
00:54:49,859 --> 00:54:51,480
website and she's going to say hey look

1313
00:54:51,480 --> 00:54:54,119
uh cloudflare would have only issued me

1314
00:54:54,119 --> 00:54:56,099
this blind signature if I proved to it

1315
00:54:56,099 --> 00:54:57,720
that I was human and because you also

1316
00:54:57,720 --> 00:54:59,220
trust cloudflare you should trust that

1317
00:54:59,220 --> 00:55:01,079
I'm human as well and then the websites

1318
00:55:01,079 --> 00:55:03,119
can say okay fine you can access this

1319
00:55:03,119 --> 00:55:06,059
website without solving the captcha

1320
00:55:06,059 --> 00:55:08,400
um an important thing to note here is

1321
00:55:08,400 --> 00:55:10,380
the is that a colluding server and a

1322
00:55:10,380 --> 00:55:11,819
website is not going to be able to track

1323
00:55:11,819 --> 00:55:13,319
a user this would be very bad for

1324
00:55:13,319 --> 00:55:15,240
privacy If instead of blind signatures

1325
00:55:15,240 --> 00:55:17,400
you just use signatures

1326
00:55:17,400 --> 00:55:18,119
um

1327
00:55:18,119 --> 00:55:19,559
another thing that I want to mention is

1328
00:55:19,559 --> 00:55:21,540
that this line signature exchange can

1329
00:55:21,540 --> 00:55:22,559
happen at the beginning of the day

1330
00:55:22,559 --> 00:55:25,500
before you even know what website you're

1331
00:55:25,500 --> 00:55:26,940
trying to visit right so you could just

1332
00:55:26,940 --> 00:55:28,260
start your computer and be like okay let

1333
00:55:28,260 --> 00:55:30,540
me just get a bunch of tokens uh and

1334
00:55:30,540 --> 00:55:31,680
your browsing experience is going to be

1335
00:55:31,680 --> 00:55:34,079
seamless throughout your day

1336
00:55:34,079 --> 00:55:35,400
um there are many Alternatives and

1337
00:55:35,400 --> 00:55:37,260
extensions to what I've described here

1338
00:55:37,260 --> 00:55:39,780
uh the first paper was at pets in 2018

1339
00:55:39,780 --> 00:55:42,059
it was called privacy pass and used

1340
00:55:42,059 --> 00:55:44,099
oblivious pseudorandom functions but

1341
00:55:44,099 --> 00:55:46,260
there have been many extensions and

1342
00:55:46,260 --> 00:55:47,579
alternatively you can also use anonymous

1343
00:55:47,579 --> 00:55:49,140
credentials

1344
00:55:49,140 --> 00:55:50,640
um Anonymous credentials give you a bit

1345
00:55:50,640 --> 00:55:52,200
more I'm not going to go into the

1346
00:55:52,200 --> 00:55:54,180
details of that but uh they're also

1347
00:55:54,180 --> 00:55:55,619
harder to build

1348
00:55:55,619 --> 00:55:57,599
okay so how would you build a post

1349
00:55:57,599 --> 00:55:59,280
Quantum blind signature let's say

1350
00:55:59,280 --> 00:56:00,839
generically right

1351
00:56:00,839 --> 00:56:02,640
this was an approach started by

1352
00:56:02,640 --> 00:56:05,460
officially in 2006 and let's say now

1353
00:56:05,460 --> 00:56:06,900
Alice has their message right so what

1354
00:56:06,900 --> 00:56:07,980
she's going to do is she's going to

1355
00:56:07,980 --> 00:56:09,720
create a commitment to her message and

1356
00:56:09,720 --> 00:56:11,400
she's going to send this to the server

1357
00:56:11,400 --> 00:56:12,960
the server is going to sign this this is

1358
00:56:12,960 --> 00:56:14,280
not a blind signature this is just a

1359
00:56:14,280 --> 00:56:15,839
regular signature

1360
00:56:15,839 --> 00:56:17,040
um and the server is going to sign this

1361
00:56:17,040 --> 00:56:18,540
commitment and send this over

1362
00:56:18,540 --> 00:56:20,099
so what Alice is going to do is she's

1363
00:56:20,099 --> 00:56:21,540
going to generate a proof of knowledge a

1364
00:56:21,540 --> 00:56:22,980
zero knowledge proof of knowledge of the

1365
00:56:22,980 --> 00:56:24,839
following statement which is

1366
00:56:24,839 --> 00:56:26,700
um she knows a signature on some

1367
00:56:26,700 --> 00:56:29,579
commitment see and she knows an opening

1368
00:56:29,579 --> 00:56:31,740
R to this commitment C which opens his

1369
00:56:31,740 --> 00:56:33,839
commitment to M and the final signature

1370
00:56:33,839 --> 00:56:35,579
is just going to be this proof and you

1371
00:56:35,579 --> 00:56:37,800
know she's going to Output the message

1372
00:56:37,800 --> 00:56:39,240
okay and and one thing I want to mention

1373
00:56:39,240 --> 00:56:40,800
here is that using this exact same

1374
00:56:40,800 --> 00:56:42,839
approach uh instead if instead of

1375
00:56:42,839 --> 00:56:44,160
signing your message you sign a bunch of

1376
00:56:44,160 --> 00:56:45,660
attributes you can get Anonymous

1377
00:56:45,660 --> 00:56:48,059
credentials and the advantage of this is

1378
00:56:48,059 --> 00:56:49,500
that you know when you sign a bunch of

1379
00:56:49,500 --> 00:56:50,579
attributes you don't have to reveal all

1380
00:56:50,579 --> 00:56:52,200
of them so for example think you're

1381
00:56:52,200 --> 00:56:54,059
signing your passport right what you

1382
00:56:54,059 --> 00:56:55,440
could do is instead of revealing your

1383
00:56:55,440 --> 00:56:57,660
exact age you could say oh I'm greater

1384
00:56:57,660 --> 00:56:59,640
than 18 so you know I can buy alcohol

1385
00:56:59,640 --> 00:57:01,079
Maybe

1386
00:57:01,079 --> 00:57:03,540
okay so how do you instantiate this

1387
00:57:03,540 --> 00:57:05,099
primitive right now we want to build

1388
00:57:05,099 --> 00:57:07,020
post Quantum line signatures so the

1389
00:57:07,020 --> 00:57:09,480
commitment the signature scheme and the

1390
00:57:09,480 --> 00:57:11,760
proof system has to be post Quantum at

1391
00:57:11,760 --> 00:57:14,160
least to be positively post quantum

1392
00:57:14,160 --> 00:57:16,020
okay so there's been prior work in this

1393
00:57:16,020 --> 00:57:17,460
space we're obviously not the first ones

1394
00:57:17,460 --> 00:57:19,140
to look at this but the general

1395
00:57:19,140 --> 00:57:22,140
consensus was that if you just throw a

1396
00:57:22,140 --> 00:57:23,760
general purpose proof at it right it's

1397
00:57:23,760 --> 00:57:26,280
going to be too big and too slow

1398
00:57:26,280 --> 00:57:27,780
um this is a quote from a paper at

1399
00:57:27,780 --> 00:57:29,640
ccs2022

1400
00:57:29,640 --> 00:57:30,839
um and they said that they expect

1401
00:57:30,839 --> 00:57:32,880
approver runtime to be at least one hour

1402
00:57:32,880 --> 00:57:35,339
if you just throw an off-the-shelf proof

1403
00:57:35,339 --> 00:57:36,839
at it

1404
00:57:36,839 --> 00:57:39,720
um and the strategy in essentially all

1405
00:57:39,720 --> 00:57:40,859
the works that have been in this space

1406
00:57:40,859 --> 00:57:43,079
is to say look there are some expensive

1407
00:57:43,079 --> 00:57:44,640
Parts in the statement this could be

1408
00:57:44,640 --> 00:57:46,140
hashing and a bunch of things that are

1409
00:57:46,140 --> 00:57:48,359
not really conducive to the knowledge

1410
00:57:48,359 --> 00:57:49,859
proofs what we're going to do is move it

1411
00:57:49,859 --> 00:57:51,660
outside the statement and this is quite

1412
00:57:51,660 --> 00:57:53,339
non-trivial uh sometimes you know you

1413
00:57:53,339 --> 00:57:55,740
have to introduce new assumptions or uh

1414
00:57:55,740 --> 00:57:56,579
just

1415
00:57:56,579 --> 00:57:57,839
be very careful with the security

1416
00:57:57,839 --> 00:58:01,380
reductions to really get good parameters

1417
00:58:01,380 --> 00:58:03,119
um but this comes with a caveat which is

1418
00:58:03,119 --> 00:58:05,579
you can't directly use these approaches

1419
00:58:05,579 --> 00:58:07,920
to get Anonymous credentials and

1420
00:58:07,920 --> 00:58:09,660
intuitively you know the reason is

1421
00:58:09,660 --> 00:58:12,000
because in these optimizations what they

1422
00:58:12,000 --> 00:58:13,859
do is they say look if you're anyway

1423
00:58:13,859 --> 00:58:15,599
going to reveal this message to verifier

1424
00:58:15,599 --> 00:58:17,579
you can actually ask the verifier to do

1425
00:58:17,579 --> 00:58:19,440
some of the expensive computation in the

1426
00:58:19,440 --> 00:58:21,720
clear and not actually prove that and

1427
00:58:21,720 --> 00:58:23,339
that allows them to offload a lot of the

1428
00:58:23,339 --> 00:58:25,200
expensive computation outside of the

1429
00:58:25,200 --> 00:58:28,200
proof and essentially you know the

1430
00:58:28,200 --> 00:58:29,940
proofs you need are very simple for

1431
00:58:29,940 --> 00:58:32,280
linear relations and uh you know again

1432
00:58:32,280 --> 00:58:34,200
very impressive works

1433
00:58:34,200 --> 00:58:36,000
but you know let's say you really wanted

1434
00:58:36,000 --> 00:58:38,099
Anonymous credentials

1435
00:58:38,099 --> 00:58:39,240
um so we asked the following question

1436
00:58:39,240 --> 00:58:41,280
right now what if we just carefully

1437
00:58:41,280 --> 00:58:43,619
chose the signature scheme and the proof

1438
00:58:43,619 --> 00:58:45,720
system and we really optimize it to debt

1439
00:58:45,720 --> 00:58:47,579
how expensive are these Anonymous

1440
00:58:47,579 --> 00:58:50,160
credentials really going to be

1441
00:58:50,160 --> 00:58:52,020
turns out you know we were surprised by

1442
00:58:52,020 --> 00:58:53,760
the Numbers ourselves

1443
00:58:53,760 --> 00:58:56,819
um so the prover time in the best case

1444
00:58:56,819 --> 00:58:59,760
can be as low as a third of a second and

1445
00:58:59,760 --> 00:59:02,520
you know uh the proof sizes are actually

1446
00:59:02,520 --> 00:59:04,559
comparable to the best known blind

1447
00:59:04,559 --> 00:59:06,359
signatures or post Quantum blind

1448
00:59:06,359 --> 00:59:07,980
signatures as of today

1449
00:59:07,980 --> 00:59:11,819
um we're in some sense uh 2x worse or

1450
00:59:11,819 --> 00:59:14,579
something uh but you know you're not

1451
00:59:14,579 --> 00:59:16,200
paying for nothing you are getting

1452
00:59:16,200 --> 00:59:18,299
significantly more features through this

1453
00:59:18,299 --> 00:59:20,579
approach

1454
00:59:20,579 --> 00:59:22,380
um and

1455
00:59:22,380 --> 00:59:24,240
um you know you can also put in more

1456
00:59:24,240 --> 00:59:27,119
work to reduce the proof size

1457
00:59:27,119 --> 00:59:29,520
okay so what is the high level overview

1458
00:59:29,520 --> 00:59:30,960
of our strategy

1459
00:59:30,960 --> 00:59:32,760
it's a two-pronged effort what we're

1460
00:59:32,760 --> 00:59:34,200
going to do is say let's just start with

1461
00:59:34,200 --> 00:59:36,299
dilithium it's been uh proposed to be

1462
00:59:36,299 --> 00:59:38,940
standardized so hopefully it's secure

1463
00:59:38,940 --> 00:59:40,440
um and what we're going to do is make it

1464
00:59:40,440 --> 00:59:43,319
zkp friendly and we're also going to use

1465
00:59:43,319 --> 00:59:45,900
zkp friendly hashes uh we use Poseidon

1466
00:59:45,900 --> 00:59:47,760
and we're also going to choose a proof

1467
00:59:47,760 --> 00:59:49,920
system which is post Quantum but we also

1468
00:59:49,920 --> 00:59:51,420
need some properties from this proof

1469
00:59:51,420 --> 00:59:52,680
system which is that we need to be able

1470
00:59:52,680 --> 00:59:55,079
to match the arithmetic in the proof

1471
00:59:55,079 --> 00:59:57,540
system with that of dilithium uh if that

1472
00:59:57,540 --> 00:59:59,040
went over here it's okay it's just we

1473
00:59:59,040 --> 01:00:01,740
need to use a very specific field

1474
01:00:01,740 --> 01:00:03,720
um and what we're also going to do is

1475
01:00:03,720 --> 01:00:05,220
when we're doing the zkidelity

1476
01:00:05,220 --> 01:00:07,200
verification circuit uh we're going to

1477
01:00:07,200 --> 01:00:08,940
reduce it to simpler statements in order

1478
01:00:08,940 --> 01:00:11,099
to reduce the approver work

1479
01:00:11,099 --> 01:00:14,099
okay so let's go over some details uh

1480
01:00:14,099 --> 01:00:15,480
what is the pipeline of these proof

1481
01:00:15,480 --> 01:00:17,520
systems right uh so let's say you have

1482
01:00:17,520 --> 01:00:19,980
your code it's doing some complicated

1483
01:00:19,980 --> 01:00:22,200
stuff uh you're going to translate it

1484
01:00:22,200 --> 01:00:23,700
into what's known as an arithmetic

1485
01:00:23,700 --> 01:00:25,619
intermediate representation think of

1486
01:00:25,619 --> 01:00:27,540
this as just a table of field elements

1487
01:00:27,540 --> 01:00:29,819
and you're going to say oh look every

1488
01:00:29,819 --> 01:00:31,619
row is related to the next row in a very

1489
01:00:31,619 --> 01:00:32,880
specific way

1490
01:00:32,880 --> 01:00:35,160
and what you're going to do is plug in

1491
01:00:35,160 --> 01:00:37,020
this intermediate representation

1492
01:00:37,020 --> 01:00:39,240
to your favorite Stark library and this

1493
01:00:39,240 --> 01:00:40,980
is going to spit out of proof

1494
01:00:40,980 --> 01:00:43,920
the second part of this pipeline is

1495
01:00:43,920 --> 01:00:46,200
actually very nice people have written

1496
01:00:46,200 --> 01:00:47,400
very very nice libraries we use

1497
01:00:47,400 --> 01:00:48,960
Winterfell it's one of my favorites

1498
01:00:48,960 --> 01:00:50,780
quite nice to use

1499
01:00:50,780 --> 01:00:53,339
essentially you would run one command on

1500
01:00:53,339 --> 01:00:54,420
your terminal and this part would get

1501
01:00:54,420 --> 01:00:55,500
over

1502
01:00:55,500 --> 01:00:57,780
but the first part is really what's

1503
01:00:57,780 --> 01:01:00,359
difficult because this is actually at

1504
01:01:00,359 --> 01:01:02,640
the moment crucial for performance you

1505
01:01:02,640 --> 01:01:04,799
need really careful hand optimization at

1506
01:01:04,799 --> 01:01:07,380
this point uh you know strategies are

1507
01:01:07,380 --> 01:01:08,760
you know you reduce the simpler circuits

1508
01:01:08,760 --> 01:01:10,619
and but you know using to maintain same

1509
01:01:10,619 --> 01:01:12,420
soundness guarantees

1510
01:01:12,420 --> 01:01:15,359
okay so let's walk through how uh the

1511
01:01:15,359 --> 01:01:19,319
dilithium uh verification uh happens

1512
01:01:19,319 --> 01:01:19,859
um

1513
01:01:19,859 --> 01:01:22,559
so in the teletim scheme you have a

1514
01:01:22,559 --> 01:01:24,900
public key which is a and t you don't

1515
01:01:24,900 --> 01:01:27,059
really need to know much more than that

1516
01:01:27,059 --> 01:01:29,760
it's a matrix a 4x4 Matrix each entry is

1517
01:01:29,760 --> 01:01:33,059
a polynomial the signature is z and C

1518
01:01:33,059 --> 01:01:36,119
tilde Z is a vector of four entries

1519
01:01:36,119 --> 01:01:37,920
again for polynomials C tilde is just a

1520
01:01:37,920 --> 01:01:39,599
scalar of Lambda bits where Lambda is

1521
01:01:39,599 --> 01:01:41,220
the security parameter let's say

1522
01:01:41,220 --> 01:01:43,260
so the first thing you do in the cada

1523
01:01:43,260 --> 01:01:46,980
lithium is uh you need to map C tilde to

1524
01:01:46,980 --> 01:01:50,040
C where C contains entries uh which are

1525
01:01:50,040 --> 01:01:53,160
minus one zeros and ones and you need uh

1526
01:01:53,160 --> 01:01:54,900
the number of non-zero entries in C to

1527
01:01:54,900 --> 01:01:57,540
be Tau and uh because you want this to

1528
01:01:57,540 --> 01:01:58,859
be a uniformly random mapping you use

1529
01:01:58,859 --> 01:02:01,980
the fishery Aid style uh strategy but

1530
01:02:01,980 --> 01:02:03,599
you know when you use Fisher Yates if

1531
01:02:03,599 --> 01:02:05,339
you're implementing this uh you'll

1532
01:02:05,339 --> 01:02:06,839
remember that typically you use

1533
01:02:06,839 --> 01:02:09,059
rejection sampling uh in the strategy

1534
01:02:09,059 --> 01:02:11,099
but this is just a no-go for xenology

1535
01:02:11,099 --> 01:02:13,619
proof systems so what you do is you can

1536
01:02:13,619 --> 01:02:15,180
actually move the rejection sampling to

1537
01:02:15,180 --> 01:02:17,940
the signing part and avoid it in the

1538
01:02:17,940 --> 01:02:20,880
verification uh circuit

1539
01:02:20,880 --> 01:02:24,000
the second thing you do is uh matrix

1540
01:02:24,000 --> 01:02:27,720
multiplication of these polynomials what

1541
01:02:27,720 --> 01:02:29,160
you do is you just compute a times e

1542
01:02:29,160 --> 01:02:31,380
minus c times D and stored in w

1543
01:02:31,380 --> 01:02:33,780
uh effectively you know you should just

1544
01:02:33,780 --> 01:02:35,099
imagine this as multiplying a bunch of

1545
01:02:35,099 --> 01:02:37,079
polynomials and the stranded strategy is

1546
01:02:37,079 --> 01:02:39,540
let's not compute but verify that the

1547
01:02:39,540 --> 01:02:40,799
computation was done correctly and

1548
01:02:40,799 --> 01:02:41,819
you're just going to reduce it to

1549
01:02:41,819 --> 01:02:43,680
polynomial identity testing this is

1550
01:02:43,680 --> 01:02:44,880
asymptotically even better than

1551
01:02:44,880 --> 01:02:46,680
Computing this because polynomial

1552
01:02:46,680 --> 01:02:48,660
multiplication if you use ffts is going

1553
01:02:48,660 --> 01:02:50,400
to take like o of n log n if n is the

1554
01:02:50,400 --> 01:02:52,559
degree of the polynomial if you just use

1555
01:02:52,559 --> 01:02:53,700
polynomial energy testing you're going

1556
01:02:53,700 --> 01:02:55,680
to do it in n and in fact it's also

1557
01:02:55,680 --> 01:02:58,500
significantly easier to implement the

1558
01:02:58,500 --> 01:03:01,200
translation to aars

1559
01:03:01,200 --> 01:03:02,640
okay

1560
01:03:02,640 --> 01:03:04,140
um then you're going to extract the

1561
01:03:04,140 --> 01:03:06,480
hybrids of this W that you've computed

1562
01:03:06,480 --> 01:03:08,760
again same strategy instead of actually

1563
01:03:08,760 --> 01:03:10,020
Computing you're just going to check

1564
01:03:10,020 --> 01:03:11,520
that the decomposition was carried out

1565
01:03:11,520 --> 01:03:13,280
correctly

1566
01:03:13,280 --> 01:03:16,440
and finally there is a part which is the

1567
01:03:16,440 --> 01:03:19,040
hashing so we use the Poseidon hash here

1568
01:03:19,040 --> 01:03:22,619
again because it's just dkp friendly and

1569
01:03:22,619 --> 01:03:24,359
you hash the public key the message and

1570
01:03:24,359 --> 01:03:26,579
these hybrids that you extracted and you

1571
01:03:26,579 --> 01:03:28,200
check that it's equal to the C tilde

1572
01:03:28,200 --> 01:03:31,079
that appears in the signature

1573
01:03:31,079 --> 01:03:32,700
um okay and finally there's a bunch of

1574
01:03:32,700 --> 01:03:34,380
range proofs and so on that you also

1575
01:03:34,380 --> 01:03:36,420
need to do standard strategies that you

1576
01:03:36,420 --> 01:03:38,819
use in Xerox proofs uh nothing crazy

1577
01:03:38,819 --> 01:03:40,680
there okay

1578
01:03:40,680 --> 01:03:43,799
so this is a high level pictorial

1579
01:03:43,799 --> 01:03:47,700
diagram of how the air looks uh you know

1580
01:03:47,700 --> 01:03:49,140
I've omitted a lot of details because

1581
01:03:49,140 --> 01:03:50,579
it's significantly more complicated than

1582
01:03:50,579 --> 01:03:53,579
this but what happens is uh we have a

1583
01:03:53,579 --> 01:03:55,440
main table and an auxiliary table the

1584
01:03:55,440 --> 01:03:56,760
auxiliary table is on the right side

1585
01:03:56,760 --> 01:03:58,319
I'll get into a moment as to why I've

1586
01:03:58,319 --> 01:04:00,359
separated the two things but the idea is

1587
01:04:00,359 --> 01:04:02,460
you know you do the computation of

1588
01:04:02,460 --> 01:04:04,079
different things in different parts of

1589
01:04:04,079 --> 01:04:05,640
this table the figure is actually

1590
01:04:05,640 --> 01:04:06,960
roughly to scale so you also have an

1591
01:04:06,960 --> 01:04:09,059
idea of how expensive each thing is and

1592
01:04:09,059 --> 01:04:10,380
how much resources you're dedicating to

1593
01:04:10,380 --> 01:04:11,940
each of these things and you know where

1594
01:04:11,940 --> 01:04:13,799
is the bottleneck

1595
01:04:13,799 --> 01:04:16,140
um so the hash and ball turns out is the

1596
01:04:16,140 --> 01:04:19,020
widest thing because you really need

1597
01:04:19,020 --> 01:04:21,420
you know large amount of memory to

1598
01:04:21,420 --> 01:04:23,339
actually implement this

1599
01:04:23,339 --> 01:04:24,780
um we tried but we weren't really able

1600
01:04:24,780 --> 01:04:27,359
to reduce that then you know use in this

1601
01:04:27,359 --> 01:04:29,099
second green phase that I've written

1602
01:04:29,099 --> 01:04:31,740
this is uh this matrix multiplication

1603
01:04:31,740 --> 01:04:33,839
and hashing phase where you're going to

1604
01:04:33,839 --> 01:04:35,400
store your polynomials on the left do a

1605
01:04:35,400 --> 01:04:36,660
bunch of range proofs and you're going

1606
01:04:36,660 --> 01:04:38,220
to check that High bits was decomposed

1607
01:04:38,220 --> 01:04:39,599
correctly and then you're going to do

1608
01:04:39,599 --> 01:04:42,780
the hashing uh in the third column

1609
01:04:42,780 --> 01:04:44,099
um so when you do polynomial energy

1610
01:04:44,099 --> 01:04:46,380
testing you actually need a random coin

1611
01:04:46,380 --> 01:04:48,180
or just a random field element on which

1612
01:04:48,180 --> 01:04:49,680
you evaluate your polynomials so the

1613
01:04:49,680 --> 01:04:50,579
question is how are you going to get

1614
01:04:50,579 --> 01:04:52,619
this uh what's actually happening here

1615
01:04:52,619 --> 01:04:54,660
is in this main table you first commit

1616
01:04:54,660 --> 01:04:56,940
to the polynomials you do Fiat Shamir

1617
01:04:56,940 --> 01:04:58,559
you get a bunch of random coins and then

1618
01:04:58,559 --> 01:05:00,240
that's what you use to do the evaluation

1619
01:05:00,240 --> 01:05:01,980
in this auxiliary table that's why I've

1620
01:05:01,980 --> 01:05:03,780
done the separation so the evaluation of

1621
01:05:03,780 --> 01:05:05,339
these polynomials happens actually in

1622
01:05:05,339 --> 01:05:07,619
this auxiliary table and of course you

1623
01:05:07,619 --> 01:05:09,480
just do the checks on the bottom and

1624
01:05:09,480 --> 01:05:11,760
everything works out

1625
01:05:11,760 --> 01:05:13,980
um and this red areas is because we need

1626
01:05:13,980 --> 01:05:15,480
this table to be a power of two because

1627
01:05:15,480 --> 01:05:18,059
you need to do ffts and those red edges

1628
01:05:18,059 --> 01:05:20,099
just are just unused if you're doing

1629
01:05:20,099 --> 01:05:21,839
more General things you know you can use

1630
01:05:21,839 --> 01:05:24,078
that

1631
01:05:24,119 --> 01:05:26,040
um there's actually a demo that we have

1632
01:05:26,040 --> 01:05:27,440
up running at

1633
01:05:27,440 --> 01:05:29,940
zk.lithium.cloudflare research.com you

1634
01:05:29,940 --> 01:05:32,520
can go try it out scan a QR code Press

1635
01:05:32,520 --> 01:05:34,319
Start and things should work okay if it

1636
01:05:34,319 --> 01:05:35,520
doesn't please let us know we'd like to

1637
01:05:35,520 --> 01:05:37,200
figure out why

1638
01:05:37,200 --> 01:05:41,280
um there's a Code available on GitHub uh

1639
01:05:41,280 --> 01:05:43,559
if you can't remember my name it's in

1640
01:05:43,559 --> 01:05:44,579
the paper

1641
01:05:44,579 --> 01:05:47,460
so takeaways and future work uh this is

1642
01:05:47,460 --> 01:05:48,480
something that I want to spend a little

1643
01:05:48,480 --> 01:05:50,579
bit of time on because with the

1644
01:05:50,579 --> 01:05:52,500
migration to post Quantum I think more

1645
01:05:52,500 --> 01:05:54,180
people should hopefully start looking at

1646
01:05:54,180 --> 01:05:56,040
these things

1647
01:05:56,040 --> 01:05:57,900
um so first okay uh post Quantum and

1648
01:05:57,900 --> 01:05:59,160
Anonymous credentials are now

1649
01:05:59,160 --> 01:06:01,079
semi-practical uh because we were just

1650
01:06:01,079 --> 01:06:03,420
able to throw a proof at it essentially

1651
01:06:03,420 --> 01:06:05,280
um the second point is that you know

1652
01:06:05,280 --> 01:06:07,500
carefully tailoring your xenology proofs

1653
01:06:07,500 --> 01:06:08,819
to the Circuit that you're trying to

1654
01:06:08,819 --> 01:06:12,299
prove can perform surprisingly well

1655
01:06:12,299 --> 01:06:14,400
um and you know it's good to get

1656
01:06:14,400 --> 01:06:16,079
estimates just by saying oh if what

1657
01:06:16,079 --> 01:06:17,579
happens if we just throw a naive proof

1658
01:06:17,579 --> 01:06:19,680
at it but you can't ignore the fact that

1659
01:06:19,680 --> 01:06:21,359
if you put in engineering and time into

1660
01:06:21,359 --> 01:06:23,339
it you will perform significantly well

1661
01:06:23,339 --> 01:06:25,799
and if you want a benchline or a base

1662
01:06:25,799 --> 01:06:27,480
mark you need to put in that work and

1663
01:06:27,480 --> 01:06:28,680
see okay

1664
01:06:28,680 --> 01:06:30,119
if I'm going to design specialized

1665
01:06:30,119 --> 01:06:32,339
protocols this is at least how good they

1666
01:06:32,339 --> 01:06:34,380
should perform

1667
01:06:34,380 --> 01:06:36,119
um and something that I hope people look

1668
01:06:36,119 --> 01:06:38,039
into and hopefully we can look into as

1669
01:06:38,039 --> 01:06:39,960
well is designing post Quantum

1670
01:06:39,960 --> 01:06:42,839
signatures for proof work specifically

1671
01:06:42,839 --> 01:06:44,760
for proof verification you know uh

1672
01:06:44,760 --> 01:06:45,780
because you know we just picked up

1673
01:06:45,780 --> 01:06:47,400
dilithium right and we just picked up ZK

1674
01:06:47,400 --> 01:06:48,599
historics we didn't design these things

1675
01:06:48,599 --> 01:06:51,299
uh we modified them enough to make them

1676
01:06:51,299 --> 01:06:53,099
fit together well but if you could just

1677
01:06:53,099 --> 01:06:55,260
start from scratch and design signature

1678
01:06:55,260 --> 01:06:58,440
schemes uh with proof verification mind

1679
01:06:58,440 --> 01:06:59,760
but you know maybe the trade-off is that

1680
01:06:59,760 --> 01:07:01,799
signing is worse or verification is

1681
01:07:01,799 --> 01:07:03,599
worse but you know you can improve

1682
01:07:03,599 --> 01:07:05,160
knowledge of a signature that'll be very

1683
01:07:05,160 --> 01:07:06,599
very cool

1684
01:07:06,599 --> 01:07:07,920
um and vice versa you know design your

1685
01:07:07,920 --> 01:07:09,720
proof verification with signatures in

1686
01:07:09,720 --> 01:07:10,799
mind

1687
01:07:10,799 --> 01:07:13,200
um we would also at some point like to

1688
01:07:13,200 --> 01:07:15,180
have some formal verification of our air

1689
01:07:15,180 --> 01:07:16,920
translation which translates to ZK

1690
01:07:16,920 --> 01:07:19,500
dilithium code into airs

1691
01:07:19,500 --> 01:07:21,000
um there's more details and new ideas

1692
01:07:21,000 --> 01:07:23,099
for rate limiting that we have in the

1693
01:07:23,099 --> 01:07:26,400
paper you can find it uh on ePrint

1694
01:07:26,400 --> 01:07:28,220
um thank you

1695
01:07:28,220 --> 01:07:31,970
[Applause]

1696
01:07:34,980 --> 01:07:36,780
thank you very much for the presentation

1697
01:07:36,780 --> 01:07:38,760
please go with a question

1698
01:07:38,760 --> 01:07:41,280
yeah so um there was there was a talk

1699
01:07:41,280 --> 01:07:43,440
yesterday that has something about the

1700
01:07:43,440 --> 01:07:45,000
uh the

1701
01:07:45,000 --> 01:07:45,599
um

1702
01:07:45,599 --> 01:07:47,760
lattice based proofs which may be of

1703
01:07:47,760 --> 01:07:49,500
interest but that I don't know anything

1704
01:07:49,500 --> 01:07:51,299
about so my actual question is why do

1705
01:07:51,299 --> 01:07:52,980
you care about post Quantum soundness

1706
01:07:52,980 --> 01:07:55,200
here why not I think I could do this in

1707
01:07:55,200 --> 01:07:58,920
400 constraints in a or an r1cs Route 16

1708
01:07:58,920 --> 01:08:03,480
proof and uh the like hundreds not not

1709
01:08:03,480 --> 01:08:05,819
thousand four hundred

1710
01:08:05,819 --> 01:08:07,740
um so I mean

1711
01:08:07,740 --> 01:08:09,420
the why do you even care about post

1712
01:08:09,420 --> 01:08:11,520
Quantum I mean eventually it might be

1713
01:08:11,520 --> 01:08:14,339
important but but but like now if you

1714
01:08:14,339 --> 01:08:16,198
want to deploy right right I agree so

1715
01:08:16,198 --> 01:08:17,460
obviously we don't have to deploy this

1716
01:08:17,460 --> 01:08:19,259
right now because maybe in the case of

1717
01:08:19,259 --> 01:08:20,819
blind signatures you know you can wait

1718
01:08:20,819 --> 01:08:22,679
to migrate

1719
01:08:22,679 --> 01:08:25,679
um but you know one thing is that if you

1720
01:08:25,679 --> 01:08:27,600
don't start the work now you can't

1721
01:08:27,600 --> 01:08:30,000
really expect to magically

1722
01:08:30,000 --> 01:08:32,640
get really good signatures in the end

1723
01:08:32,640 --> 01:08:35,899
uh hopefully that answers the question

1724
01:08:35,899 --> 01:08:38,698
thanks for your presentation I have

1725
01:08:38,698 --> 01:08:42,960
noticed that you use the range proof I

1726
01:08:42,960 --> 01:08:45,479
guess it is your knowledge too

1727
01:08:45,479 --> 01:08:46,640
so

1728
01:08:46,640 --> 01:08:51,238
you do a post Quantum work but as far as

1729
01:08:51,238 --> 01:08:53,399
I know the most well-known range proof

1730
01:08:53,399 --> 01:08:56,339
blade proofs is not post Quantum so

1731
01:08:56,339 --> 01:08:58,920
what's the concrete windproof protocol

1732
01:08:58,920 --> 01:09:01,738
you use uh we don't do anything smart

1733
01:09:01,738 --> 01:09:03,179
with the range proof we just do a bit

1734
01:09:03,179 --> 01:09:06,179
decomposition and show that uh

1735
01:09:06,179 --> 01:09:08,640
you know you can actually put it in some

1736
01:09:08,640 --> 01:09:10,679
range

1737
01:09:10,679 --> 01:09:12,540
um I think maybe what you're referring

1738
01:09:12,540 --> 01:09:15,479
to is like specialized proofs for the

1739
01:09:15,479 --> 01:09:17,460
specific task of range proofs we can't

1740
01:09:17,460 --> 01:09:19,738
really use those uh because we actually

1741
01:09:19,738 --> 01:09:21,179
have a lot of other complicated stuff

1742
01:09:21,179 --> 01:09:22,500
going on which is like hashing and stuff

1743
01:09:22,500 --> 01:09:24,000
so we really have to use a range proof

1744
01:09:24,000 --> 01:09:26,880
which fits in well with ZK Starks and we

1745
01:09:26,880 --> 01:09:28,140
just do a simple bit decomposition

1746
01:09:28,140 --> 01:09:29,698
because that also didn't seem like the

1747
01:09:29,698 --> 01:09:31,259
bottleneck and everything else that was

1748
01:09:31,259 --> 01:09:33,839
happening so we just uh didn't really

1749
01:09:33,839 --> 01:09:35,819
put too much attention there oh okay

1750
01:09:35,819 --> 01:09:38,698
another question sure

1751
01:09:38,698 --> 01:09:42,500
I noticed your security level is

1752
01:09:42,500 --> 01:09:47,759
115 bit this may not be as common as 128

1753
01:09:47,759 --> 01:09:48,859
bit and

1754
01:09:48,859 --> 01:09:52,020
right right right so what is the reason

1755
01:09:52,020 --> 01:09:55,500
is is the parameters for the historic

1756
01:09:55,500 --> 01:09:58,380
like the number of rungs in the Decay

1757
01:09:58,380 --> 01:10:01,440
protocol or the field choice or some

1758
01:10:01,440 --> 01:10:03,600
other reasons uh-huh

1759
01:10:03,600 --> 01:10:06,360
um so I mean that was just uh a number

1760
01:10:06,360 --> 01:10:07,860
that we chose because it was also

1761
01:10:07,860 --> 01:10:09,900
coinciding with the dilithium uh

1762
01:10:09,900 --> 01:10:11,400
parameters

1763
01:10:11,400 --> 01:10:12,719
um but you know you could just make more

1764
01:10:12,719 --> 01:10:14,520
queries it's going to shoot up the proof

1765
01:10:14,520 --> 01:10:17,219
size by like maybe 10 or 15 you can you

1766
01:10:17,219 --> 01:10:20,100
should be able to get up to 128 uh bits

1767
01:10:20,100 --> 01:10:23,760
as well uh that's that's not uh uh

1768
01:10:23,760 --> 01:10:25,620
bottleneck here you can just change one

1769
01:10:25,620 --> 01:10:29,340
number in the code and shoot up to 128.

1770
01:10:29,340 --> 01:10:31,860
you mentioned the rate limiting can you

1771
01:10:31,860 --> 01:10:33,000
say something about what you're doing

1772
01:10:33,000 --> 01:10:35,100
there right right yeah so details are in

1773
01:10:35,100 --> 01:10:36,120
the paper unfortunately I didn't have

1774
01:10:36,120 --> 01:10:39,320
time to go in uh so there's an ietf uh

1775
01:10:39,320 --> 01:10:41,400
draft or I'm sorry I don't know the

1776
01:10:41,400 --> 01:10:42,360
exact word for it but there's something

1777
01:10:42,360 --> 01:10:44,699
in the ietf about rate limiting uh these

1778
01:10:44,699 --> 01:10:45,600
and this is actually something that's

1779
01:10:45,600 --> 01:10:47,340
going to be deployed by Apple uh

1780
01:10:47,340 --> 01:10:49,020
cloudflare and fastly

1781
01:10:49,020 --> 01:10:50,280
um what they do is to implement rate

1782
01:10:50,280 --> 01:10:51,900
limiting they introduce a third party

1783
01:10:51,900 --> 01:10:54,060
called in a tester when you use

1784
01:10:54,060 --> 01:10:55,860
anonymous credentials we actually show

1785
01:10:55,860 --> 01:10:58,560
that you can remove this third party and

1786
01:10:58,560 --> 01:11:00,540
it's just a significantly better trust

1787
01:11:00,540 --> 01:11:02,100
assumption and when you have these three

1788
01:11:02,100 --> 01:11:03,300
parties you need non-collusion

1789
01:11:03,300 --> 01:11:04,920
assumptions

1790
01:11:04,920 --> 01:11:06,960
um the idea is that you know this a

1791
01:11:06,960 --> 01:11:08,760
tester is going to sort of maintain a

1792
01:11:08,760 --> 01:11:10,760
log of how many queries and how many

1793
01:11:10,760 --> 01:11:13,320
tokens you've obtained uh what you can

1794
01:11:13,320 --> 01:11:15,239
do is with Anonymous credentials the

1795
01:11:15,239 --> 01:11:16,500
client itself is going to maintain a

1796
01:11:16,500 --> 01:11:18,060
table of how many tokens they've

1797
01:11:18,060 --> 01:11:20,699
obtained and give a proof that oh look

1798
01:11:20,699 --> 01:11:22,440
in the last Epoch I only obtained 10

1799
01:11:22,440 --> 01:11:24,900
tokens if it's a 11 token just you know

1800
01:11:24,900 --> 01:11:27,120
you just can't prove uh the constraint

1801
01:11:27,120 --> 01:11:29,580
and that's how we remove this attester

1802
01:11:29,580 --> 01:11:31,620
roughly hopefully that answered the

1803
01:11:31,620 --> 01:11:32,820
question

1804
01:11:32,820 --> 01:11:36,719
we have time for a really small question

1805
01:11:36,719 --> 01:11:39,440
Okay so

1806
01:11:39,980 --> 01:11:42,120
with with

1807
01:11:42,120 --> 01:11:44,760
um with privacy pass in particular it's

1808
01:11:44,760 --> 01:11:48,000
about you know about bot prevention and

1809
01:11:48,000 --> 01:11:49,500
another solution to both prevention is

1810
01:11:49,500 --> 01:11:50,940
kind of like prevent work obviously like

1811
01:11:50,940 --> 01:11:52,860
I said you know have someone USB hash

1812
01:11:52,860 --> 01:11:54,239
and prove that they have some that makes

1813
01:11:54,239 --> 01:11:56,100
it make it costly

1814
01:11:56,100 --> 01:11:58,980
um the I guess uh if someone has a

1815
01:11:58,980 --> 01:11:59,940
quantum computer and they're using the

1816
01:11:59,940 --> 01:12:02,520
quantum computer to produce fake uh

1817
01:12:02,520 --> 01:12:04,260
tokens it seems like they're basically

1818
01:12:04,260 --> 01:12:06,900
doing more work than it would be to like

1819
01:12:06,900 --> 01:12:09,060
cap break the captcha I'm kind of

1820
01:12:09,060 --> 01:12:11,580
serious there's not like obviously not

1821
01:12:11,580 --> 01:12:13,020
as potentials for a lot of things I'm

1822
01:12:13,020 --> 01:12:14,640
just kind of I'm curious about your

1823
01:12:14,640 --> 01:12:16,500
mental model about this particular

1824
01:12:16,500 --> 01:12:18,960
problem or if you think about your work

1825
01:12:18,960 --> 01:12:20,460
in terms of like this particular problem

1826
01:12:20,460 --> 01:12:22,860
or more more broadly

1827
01:12:22,860 --> 01:12:25,679
um I agree uh you know if if breaking

1828
01:12:25,679 --> 01:12:26,940
captures was really all you were

1829
01:12:26,940 --> 01:12:29,219
interested in then maybe you know

1830
01:12:29,219 --> 01:12:31,080
you don't want to use a quantum computer

1831
01:12:31,080 --> 01:12:32,520
for it

1832
01:12:32,520 --> 01:12:33,480
um

1833
01:12:33,480 --> 01:12:35,460
but I think the work in some sense

1834
01:12:35,460 --> 01:12:37,380
privacy pass if you view it as oh the

1835
01:12:37,380 --> 01:12:38,699
problem of captures it's not as

1836
01:12:38,699 --> 01:12:41,159
interesting but I think you know the

1837
01:12:41,159 --> 01:12:43,140
Primitive is interesting outside the

1838
01:12:43,140 --> 01:12:44,940
context of captures as well and so it

1839
01:12:44,940 --> 01:12:47,040
just makes sense to build more efficient

1840
01:12:47,040 --> 01:12:48,719
Primitives just a privacy preservative

1841
01:12:48,719 --> 01:12:51,239
for these broader applications uh you

1842
01:12:51,239 --> 01:12:52,860
know just Anonymous authentication I

1843
01:12:52,860 --> 01:12:55,380
think is just a very cool thing that you

1844
01:12:55,380 --> 01:12:56,880
would want to post Quantum version of

1845
01:12:56,880 --> 01:12:58,980
irrespective whether it's for captures

1846
01:12:58,980 --> 01:13:00,300
or not like maybe you could think of

1847
01:13:00,300 --> 01:13:01,560
something like oh I'm just trying to log

1848
01:13:01,560 --> 01:13:04,920
into my company's uh whatever system

1849
01:13:04,920 --> 01:13:06,540
right you could use potentially

1850
01:13:06,540 --> 01:13:08,040
Anonymous authentication if you want to

1851
01:13:08,040 --> 01:13:10,140
hide the logs and not really check

1852
01:13:10,140 --> 01:13:11,280
whether your employees are doing your

1853
01:13:11,280 --> 01:13:14,100
work and so on but uh that's that's an

1854
01:13:14,100 --> 01:13:15,480
option as well yeah

1855
01:13:15,480 --> 01:13:17,100
yeah this is really cool work thank you

1856
01:13:17,100 --> 01:13:19,280
yeah

1857
01:13:20,390 --> 01:13:26,820
[Applause]

1858
01:13:26,820 --> 01:13:30,799
and now we have the world ceremony

