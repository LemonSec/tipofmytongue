1
00:00:00,080 --> 00:00:02,560
thank you frederick so let's have a look

2
00:00:02,560 --> 00:00:04,799
at the designs that we used in the

3
00:00:04,799 --> 00:00:06,879
private analytics system in exposure

4
00:00:06,879 --> 00:00:08,800
notifications

5
00:00:08,800 --> 00:00:10,800
as we already mentioned it was important

6
00:00:10,800 --> 00:00:13,120
for us to work to use a work that is

7
00:00:13,120 --> 00:00:15,120
well recognized

8
00:00:15,120 --> 00:00:17,840
and meets our privacy and robustness

9
00:00:17,840 --> 00:00:20,560
requirements for the system

10
00:00:20,560 --> 00:00:22,560
for this reason we chose to use the

11
00:00:22,560 --> 00:00:25,359
system prio which is a private robust

12
00:00:25,359 --> 00:00:27,279
and scalable computation of aggregate

13
00:00:27,279 --> 00:00:29,519
statistics and it was introduced by

14
00:00:29,519 --> 00:00:31,920
henry corrigan gibbs and dan bonnet in

15
00:00:31,920 --> 00:00:34,399
nsdi 2017.

16
00:00:34,399 --> 00:00:36,719
this is a multi-party computation system

17
00:00:36,719 --> 00:00:39,600
which distributes the trust among two

18
00:00:39,600 --> 00:00:41,760
parties that are jointly computing the

19
00:00:41,760 --> 00:00:43,120
aggregation

20
00:00:43,120 --> 00:00:44,800
this system protects individual

21
00:00:44,800 --> 00:00:46,879
contributions and guarantees that only

22
00:00:46,879 --> 00:00:50,399
aggregated data is revealed as an output

23
00:00:50,399 --> 00:00:52,640
a useful property for this system was

24
00:00:52,640 --> 00:00:54,480
that it was compatible with various

25
00:00:54,480 --> 00:00:56,719
differential privacy mechanisms which

26
00:00:56,719 --> 00:00:58,879
helped us achieve our goal to provide

27
00:00:58,879 --> 00:01:01,840
differential privacy for the outputs

28
00:01:01,840 --> 00:01:04,319
this system protects against malicious

29
00:01:04,319 --> 00:01:06,799
users that are trying to skew the output

30
00:01:06,799 --> 00:01:09,520
of the computation and render it useless

31
00:01:09,520 --> 00:01:11,439
in particular it guarantees that the

32
00:01:11,439 --> 00:01:14,080
most a malicious user can do is cheat

33
00:01:14,080 --> 00:01:16,159
about their own input within some

34
00:01:16,159 --> 00:01:18,080
allowable range

35
00:01:18,080 --> 00:01:20,560
and if you have been a regular attendee

36
00:01:20,560 --> 00:01:23,280
of real-world crypto you have seen this

37
00:01:23,280 --> 00:01:25,520
system used in another context

38
00:01:25,520 --> 00:01:28,479
in collecting firefox telemetry

39
00:01:28,479 --> 00:01:29,600
for

40
00:01:29,600 --> 00:01:32,479
another application

41
00:01:32,479 --> 00:01:35,600
so the prio system architecture relies

42
00:01:35,600 --> 00:01:38,560
on two aggregation servers that jointly

43
00:01:38,560 --> 00:01:41,360
compute the final outputs

44
00:01:41,360 --> 00:01:43,600
and the privacy guarantees of the system

45
00:01:43,600 --> 00:01:46,240
rely on the assumption of non-collusion

46
00:01:46,240 --> 00:01:48,560
which says that these two servers are

47
00:01:48,560 --> 00:01:51,840
run by two independent parties which

48
00:01:51,840 --> 00:01:54,240
will not put together the data that they

49
00:01:54,240 --> 00:01:56,159
see during the execution of the

50
00:01:56,159 --> 00:01:57,600
computation

51
00:01:57,600 --> 00:02:00,320
we will discuss later in the talk uh who

52
00:02:00,320 --> 00:02:02,799
are the two parties that run the

53
00:02:02,799 --> 00:02:04,960
aggregation servers for exposure

54
00:02:04,960 --> 00:02:08,000
notifications private analytics

55
00:02:08,000 --> 00:02:10,720
so how does a user contribute input in

56
00:02:10,720 --> 00:02:13,760
this aggregate measurement system

57
00:02:13,760 --> 00:02:16,160
in our system the input of a user is a

58
00:02:16,160 --> 00:02:17,760
binary vector

59
00:02:17,760 --> 00:02:20,080
which is split in several fixed length

60
00:02:20,080 --> 00:02:21,840
sub vectors that correspond to the

61
00:02:21,840 --> 00:02:24,480
different metrics that we collect

62
00:02:24,480 --> 00:02:26,800
each sub vector

63
00:02:26,800 --> 00:02:29,520
is a representation of the of a

64
00:02:29,520 --> 00:02:32,080
partition of the range for the value for

65
00:02:32,080 --> 00:02:34,480
this particular metric and the client

66
00:02:34,480 --> 00:02:36,000
contributes in the bucket that

67
00:02:36,000 --> 00:02:37,920
corresponds to their

68
00:02:37,920 --> 00:02:39,440
own value

69
00:02:39,440 --> 00:02:42,640
so in this example we see the metric of

70
00:02:42,640 --> 00:02:43,920
the severity of the exposure

71
00:02:43,920 --> 00:02:46,319
notification and here the client is

72
00:02:46,319 --> 00:02:48,319
contributing input which says that they

73
00:02:48,319 --> 00:02:50,959
have received exposure notification with

74
00:02:50,959 --> 00:02:54,000
severity level three

75
00:02:54,000 --> 00:02:56,319
once the client has prepared their input

76
00:02:56,319 --> 00:02:58,400
to this binary vector what they do is

77
00:02:58,400 --> 00:03:00,640
they compute two cryptographic shares of

78
00:03:00,640 --> 00:03:02,800
this input and the properties of these

79
00:03:02,800 --> 00:03:04,800
cryptographic shares are that if you

80
00:03:04,800 --> 00:03:06,640
look at only one of them it is

81
00:03:06,640 --> 00:03:09,040
indistinguishable from random numbers

82
00:03:09,040 --> 00:03:10,879
and only when you put together these two

83
00:03:10,879 --> 00:03:13,519
shares you can reconstruct the input

84
00:03:13,519 --> 00:03:15,120
in addition to the two cryptographic

85
00:03:15,120 --> 00:03:18,239
shares of its input value the client

86
00:03:18,239 --> 00:03:20,720
also computes a cryptographic a

87
00:03:20,720 --> 00:03:23,599
distributed cryptographic proof which

88
00:03:23,599 --> 00:03:26,799
shows that they provided a valid input

89
00:03:26,799 --> 00:03:28,720
where valid input here is defined as

90
00:03:28,720 --> 00:03:31,360
binary input and the way this proof

91
00:03:31,360 --> 00:03:34,080
works is that it shows that each entry

92
00:03:34,080 --> 00:03:36,720
in this vector satisfies a degree two

93
00:03:36,720 --> 00:03:40,080
polynomial which has roots zero and one

94
00:03:40,080 --> 00:03:42,720
so the client computes the shares of its

95
00:03:42,720 --> 00:03:44,720
input and the shares of this distributed

96
00:03:44,720 --> 00:03:46,560
proof and sends them to the two

97
00:03:46,560 --> 00:03:49,680
aggregation servers

98
00:03:49,680 --> 00:03:51,840
in the aggregation phase the two servers

99
00:03:51,840 --> 00:03:55,280
can jointly verify the range proof and

100
00:03:55,280 --> 00:03:57,439
for all contributions that pass this

101
00:03:57,439 --> 00:03:59,680
verification they can aggregate their

102
00:03:59,680 --> 00:04:02,000
respective shares and thus

103
00:04:02,000 --> 00:04:02,959
obtain

104
00:04:02,959 --> 00:04:04,720
shares of the output which can be

105
00:04:04,720 --> 00:04:07,040
provided to the designated output

106
00:04:07,040 --> 00:04:09,439
receiver

107
00:04:09,439 --> 00:04:11,519
as we also mentioned

108
00:04:11,519 --> 00:04:13,360
our goal was to provide differential

109
00:04:13,360 --> 00:04:16,320
privacy for the final output and the way

110
00:04:16,320 --> 00:04:19,519
we chose to achieve this in our system

111
00:04:19,519 --> 00:04:21,600
is by leveraging a technique that

112
00:04:21,600 --> 00:04:23,759
amplifies the differential privacy

113
00:04:23,759 --> 00:04:25,759
guarantees using the aggregation that's

114
00:04:25,759 --> 00:04:28,960
already happening on the shares

115
00:04:28,960 --> 00:04:31,600
so what happens in this system is that

116
00:04:31,600 --> 00:04:34,479
each client adds a small amount of noise

117
00:04:34,479 --> 00:04:36,639
to their input and in particular when we

118
00:04:36,639 --> 00:04:38,720
have this binary vector input so what

119
00:04:38,720 --> 00:04:40,720
this means is that the client flips with

120
00:04:40,720 --> 00:04:43,199
a small probability each entry of the

121
00:04:43,199 --> 00:04:45,360
vector and then

122
00:04:45,360 --> 00:04:47,759
the aggregation step amplifies this

123
00:04:47,759 --> 00:04:49,199
noise and provides the final

124
00:04:49,199 --> 00:04:51,199
differential privacy properties for the

125
00:04:51,199 --> 00:04:53,199
output

126
00:04:53,199 --> 00:04:56,720
so let's look again at the goals for the

127
00:04:56,720 --> 00:04:58,639
private analytics system and how we

128
00:04:58,639 --> 00:05:01,600
achieve them with this design

129
00:05:01,600 --> 00:05:03,520
so first we minimize the collection of

130
00:05:03,520 --> 00:05:05,910
the data by collecting only metrics that

131
00:05:05,910 --> 00:05:07,440
[Music]

132
00:05:07,440 --> 00:05:09,199
answer specific

133
00:05:09,199 --> 00:05:11,520
health authority questions

134
00:05:11,520 --> 00:05:13,600
in terms of privacy this architecture

135
00:05:13,600 --> 00:05:15,440
guarantees that we release only

136
00:05:15,440 --> 00:05:17,199
aggregate and differentially private

137
00:05:17,199 --> 00:05:18,479
outputs

138
00:05:18,479 --> 00:05:20,400
in terms of

139
00:05:20,400 --> 00:05:22,720
integrity of the data that is provided

140
00:05:22,720 --> 00:05:24,880
we use the range proof that i already

141
00:05:24,880 --> 00:05:27,280
mentioned and also device attestation

142
00:05:27,280 --> 00:05:29,199
techniques which i will describe a

143
00:05:29,199 --> 00:05:32,160
little later in the presentation

144
00:05:32,160 --> 00:05:34,000
of course to scale this system to

145
00:05:34,000 --> 00:05:35,759
millions of users and constantly

146
00:05:35,759 --> 00:05:38,320
streaming data it was very important to

147
00:05:38,320 --> 00:05:41,039
choose an efficient solution and in this

148
00:05:41,039 --> 00:05:43,840
respect this design is a single shot

149
00:05:43,840 --> 00:05:45,440
solution from the perspective of the

150
00:05:45,440 --> 00:05:48,080
clients they contribute only once

151
00:05:48,080 --> 00:05:49,440
in the system and don't need to be

152
00:05:49,440 --> 00:05:52,320
involved any more in the computation all

153
00:05:52,320 --> 00:05:54,400
the heavy lifting of the computation is

154
00:05:54,400 --> 00:05:56,720
performed by these two servers

155
00:05:56,720 --> 00:05:59,280
and even in that aspect this computation

156
00:05:59,280 --> 00:06:01,280
requires only a single communication

157
00:06:01,280 --> 00:06:03,520
round between the servers

158
00:06:03,520 --> 00:06:06,000
last but not least we had this common

159
00:06:06,000 --> 00:06:08,000
solution between google and apple which

160
00:06:08,000 --> 00:06:10,720
was our goal

161
00:06:10,720 --> 00:06:13,759
so now that we have an idea about the

162
00:06:13,759 --> 00:06:15,280
cryptographic

163
00:06:15,280 --> 00:06:18,560
designs behind this protocol let's look

164
00:06:18,560 --> 00:06:21,360
at the specific instantiation of these

165
00:06:21,360 --> 00:06:23,199
designs that we used in our

166
00:06:23,199 --> 00:06:26,240
implementation and deployment

167
00:06:26,240 --> 00:06:29,440
so taking these designs into a system

168
00:06:29,440 --> 00:06:30,240
that

169
00:06:30,240 --> 00:06:32,880
works on constantly streaming data and

170
00:06:32,880 --> 00:06:35,120
serves millions of devices

171
00:06:35,120 --> 00:06:36,720
daily

172
00:06:36,720 --> 00:06:38,880
required coordination of many moving

173
00:06:38,880 --> 00:06:40,000
parts

174
00:06:40,000 --> 00:06:43,280
first we needed to decide who will be

175
00:06:43,280 --> 00:06:45,520
the the parties the independent parties

176
00:06:45,520 --> 00:06:47,440
that will run the two servers that will

177
00:06:47,440 --> 00:06:51,199
satisfy the trust model for our system

178
00:06:51,199 --> 00:06:53,840
we also had to decide how we will enable

179
00:06:53,840 --> 00:06:56,080
health authorities and users to be able

180
00:06:56,080 --> 00:06:57,520
to choose whether they want to

181
00:06:57,520 --> 00:06:59,440
participate in the private analytics

182
00:06:59,440 --> 00:07:00,800
system

183
00:07:00,800 --> 00:07:03,919
we needed to design an architecture that

184
00:07:03,919 --> 00:07:05,039
collects

185
00:07:05,039 --> 00:07:08,960
stores and processes this amount of data

186
00:07:08,960 --> 00:07:11,039
we had to take decisions on whether we

187
00:07:11,039 --> 00:07:13,039
want to do further authentication of the

188
00:07:13,039 --> 00:07:15,520
data that is coming from devices

189
00:07:15,520 --> 00:07:18,080
what parties we needed to require to be

190
00:07:18,080 --> 00:07:20,479
online all of the time and which parts

191
00:07:20,479 --> 00:07:22,720
of the computation could be performed

192
00:07:22,720 --> 00:07:25,120
asynchronously offline

193
00:07:25,120 --> 00:07:27,280
in terms of the aggregation servers

194
00:07:27,280 --> 00:07:28,800
there were requirements for code

195
00:07:28,800 --> 00:07:30,960
development and also choice of

196
00:07:30,960 --> 00:07:32,960
infrastructure on which the protocol

197
00:07:32,960 --> 00:07:34,720
would be executed

198
00:07:34,720 --> 00:07:36,479
we had to make different choices of

199
00:07:36,479 --> 00:07:38,000
concrete parameters for the

200
00:07:38,000 --> 00:07:40,160
instantiations of the different schemes

201
00:07:40,160 --> 00:07:42,560
and consider different tradeoffs related

202
00:07:42,560 --> 00:07:45,840
to the differential privacy tradeoffs

203
00:07:45,840 --> 00:07:47,520
finally when we had

204
00:07:47,520 --> 00:07:49,440
all of the components and an end-to-end

205
00:07:49,440 --> 00:07:52,080
system we had to decide how we will be

206
00:07:52,080 --> 00:07:54,720
able to debug and verify that the system

207
00:07:54,720 --> 00:07:57,280
is working correctly

208
00:07:57,280 --> 00:07:59,919
so let me start by telling you uh who

209
00:07:59,919 --> 00:08:03,199
are the two parties that run this system

210
00:08:03,199 --> 00:08:06,639
in our us deployment the two aggregation

211
00:08:06,639 --> 00:08:09,039
servers are run by the internet security

212
00:08:09,039 --> 00:08:11,280
research group which after this morning

213
00:08:11,280 --> 00:08:14,160
you should be well acquainted with

214
00:08:14,160 --> 00:08:16,240
this is a california public benefit

215
00:08:16,240 --> 00:08:18,720
corporation for digital infrastructure

216
00:08:18,720 --> 00:08:22,560
projects and as we heard isrg operates

217
00:08:22,560 --> 00:08:24,400
let's encrypt

218
00:08:24,400 --> 00:08:26,960
the second aggregation server is run by

219
00:08:26,960 --> 00:08:29,039
the national cancer institute at the

220
00:08:29,039 --> 00:08:31,360
national institutes of health which is

221
00:08:31,360 --> 00:08:33,519
an agency of the us department of health

222
00:08:33,519 --> 00:08:35,200
and human services

223
00:08:35,200 --> 00:08:36,799
these were two parties that are

224
00:08:36,799 --> 00:08:39,200
independent and were already operating

225
00:08:39,200 --> 00:08:42,799
in the public sphere for public benefit

226
00:08:42,799 --> 00:08:45,279
the servers the two aggregation servers

227
00:08:45,279 --> 00:08:47,440
are built on kubernetes and are running

228
00:08:47,440 --> 00:08:50,800
on two distinct cloud providers

229
00:08:50,800 --> 00:08:53,360
in order to facilitate the access of

230
00:08:53,360 --> 00:08:55,839
health authorities to this aggregate and

231
00:08:55,839 --> 00:08:58,000
differentially private data

232
00:08:58,000 --> 00:09:01,040
we also provided a web portal that

233
00:09:01,040 --> 00:09:03,519
gives nice graphical representation of

234
00:09:03,519 --> 00:09:05,279
the final outputs that health

235
00:09:05,279 --> 00:09:07,680
authorities can easily consume

236
00:09:07,680 --> 00:09:10,480
and this web portal is

237
00:09:10,480 --> 00:09:12,800
maintained and run by the mitre

238
00:09:12,800 --> 00:09:15,600
corporation which is a non-for-profit

239
00:09:15,600 --> 00:09:18,320
organization

240
00:09:18,560 --> 00:09:21,279
in our system we added one additional

241
00:09:21,279 --> 00:09:24,320
party which we refer to as an ingestion

242
00:09:24,320 --> 00:09:25,680
server

243
00:09:25,680 --> 00:09:27,600
the need for this party came from the

244
00:09:27,600 --> 00:09:29,760
desire to be able to do additional

245
00:09:29,760 --> 00:09:32,399
authentication on the data coming from

246
00:09:32,399 --> 00:09:34,959
clients and in particular we wanted to

247
00:09:34,959 --> 00:09:37,760
be able to aggregate only data coming

248
00:09:37,760 --> 00:09:40,000
from real devices

249
00:09:40,000 --> 00:09:42,800
in order to achieve this goal we wanted

250
00:09:42,800 --> 00:09:45,440
to use device attestation techniques

251
00:09:45,440 --> 00:09:48,399
which both google and apple offer for

252
00:09:48,399 --> 00:09:51,600
their respective operating systems

253
00:09:51,600 --> 00:09:55,360
so in our architecture google and apple

254
00:09:55,360 --> 00:09:56,800
run their own

255
00:09:56,800 --> 00:09:58,880
ingestion servers these are the only

256
00:09:58,880 --> 00:10:01,360
parties that are required to be online

257
00:10:01,360 --> 00:10:02,720
all the time

258
00:10:02,720 --> 00:10:05,360
this ingestion servers receive encrypted

259
00:10:05,360 --> 00:10:07,279
data under the keys of the two

260
00:10:07,279 --> 00:10:08,480
aggregation

261
00:10:08,480 --> 00:10:09,760
servers

262
00:10:09,760 --> 00:10:11,920
they perform the device attestation

263
00:10:11,920 --> 00:10:14,160
checks and filter data that is coming

264
00:10:14,160 --> 00:10:16,560
from real devices

265
00:10:16,560 --> 00:10:19,440
they additionally remove any metadata

266
00:10:19,440 --> 00:10:23,040
such as ip addresses and time stamps

267
00:10:23,040 --> 00:10:25,519
and then they batch and forward these

268
00:10:25,519 --> 00:10:27,839
authenticated shares to the two

269
00:10:27,839 --> 00:10:30,000
aggregation servers

270
00:10:30,000 --> 00:10:33,120
in our system the ingestion servers also

271
00:10:33,120 --> 00:10:35,360
generate the randomness that is used in

272
00:10:35,360 --> 00:10:38,079
the verification of the distributed

273
00:10:38,079 --> 00:10:40,640
range proofs if you're familiar with the

274
00:10:40,640 --> 00:10:43,519
prio system uh the ingestion server is

275
00:10:43,519 --> 00:10:45,519
generating the random point

276
00:10:45,519 --> 00:10:47,680
that is used for the polynomial identity

277
00:10:47,680 --> 00:10:50,000
test

278
00:10:50,320 --> 00:10:52,240
so thus we

279
00:10:52,240 --> 00:10:54,880
had this design which is of an

280
00:10:54,880 --> 00:10:57,040
asynchronous system that consists of the

281
00:10:57,040 --> 00:10:58,560
three following

282
00:10:58,560 --> 00:10:59,680
stages

283
00:10:59,680 --> 00:11:01,839
the first we have the data collection

284
00:11:01,839 --> 00:11:04,160
where the injection servers receive

285
00:11:04,160 --> 00:11:06,000
encrypted data

286
00:11:06,000 --> 00:11:06,880
run

287
00:11:06,880 --> 00:11:09,760
device attestation strip metadata and

288
00:11:09,760 --> 00:11:12,880
then they periodically write the

289
00:11:12,880 --> 00:11:15,839
authentication batched

290
00:11:15,839 --> 00:11:18,560
batches of contributions to a shared

291
00:11:18,560 --> 00:11:20,399
storage with the

292
00:11:20,399 --> 00:11:22,240
aggregation servers

293
00:11:22,240 --> 00:11:25,120
in the second phase the data aggregation

294
00:11:25,120 --> 00:11:28,000
the two servers read periodically from

295
00:11:28,000 --> 00:11:29,920
this shared storage

296
00:11:29,920 --> 00:11:31,680
they process the data

297
00:11:31,680 --> 00:11:33,040
which includes

298
00:11:33,040 --> 00:11:36,480
decryption verification of the proofs

299
00:11:36,480 --> 00:11:38,399
and then aggregation

300
00:11:38,399 --> 00:11:41,279
and then they forward their aggregate

301
00:11:41,279 --> 00:11:43,040
parts to miter

302
00:11:43,040 --> 00:11:45,279
every eight hours

303
00:11:45,279 --> 00:11:47,920
in the final stage of the computation

304
00:11:47,920 --> 00:11:49,920
which is the data consumption

305
00:11:49,920 --> 00:11:52,720
miter sums up what it has received from

306
00:11:52,720 --> 00:11:55,279
the two aggregation servers and presents

307
00:11:55,279 --> 00:11:58,720
a 24-hour view of the final aggregated

308
00:11:58,720 --> 00:12:00,800
and differentially private data to the

309
00:12:00,800 --> 00:12:03,920
health authorities

310
00:12:04,160 --> 00:12:06,480
now if we want to put all of the parties

311
00:12:06,480 --> 00:12:09,519
involved in the system in the same

312
00:12:09,519 --> 00:12:11,279
figure will have

313
00:12:11,279 --> 00:12:14,399
the ios and the android devices that are

314
00:12:14,399 --> 00:12:16,240
sending data to the two ingestion

315
00:12:16,240 --> 00:12:18,240
servers run by

316
00:12:18,240 --> 00:12:21,279
apple and google respectively and then

317
00:12:21,279 --> 00:12:23,519
those servers are forwarding encrypted

318
00:12:23,519 --> 00:12:26,800
shares to the isrg and the nih

319
00:12:26,800 --> 00:12:29,040
aggregation servers and finally the

320
00:12:29,040 --> 00:12:31,760
outputs are reconstructed by miter and

321
00:12:31,760 --> 00:12:33,040
presented

322
00:12:33,040 --> 00:12:36,839
to the each state health

323
00:12:36,839 --> 00:12:40,399
authority so in our system we have two

324
00:12:40,399 --> 00:12:42,079
levels of consent

325
00:12:42,079 --> 00:12:44,160
first a health authority that wants to

326
00:12:44,160 --> 00:12:46,399
take advantage of the aggregate private

327
00:12:46,399 --> 00:12:50,160
analytics uh needs to opt in into that

328
00:12:50,160 --> 00:12:52,399
and the way they do this is by signing a

329
00:12:52,399 --> 00:12:55,440
contract with mitre who is running uh

330
00:12:55,440 --> 00:12:58,560
the web portal on their behalf

331
00:12:58,560 --> 00:13:01,519
the second level of consent that we do

332
00:13:01,519 --> 00:13:04,800
is for the user each user has the option

333
00:13:04,800 --> 00:13:06,240
to select whether they want to

334
00:13:06,240 --> 00:13:08,880
contribute their inputs in this private

335
00:13:08,880 --> 00:13:11,839
analytics system

336
00:13:12,800 --> 00:13:13,600
so

337
00:13:13,600 --> 00:13:14,480
the

338
00:13:14,480 --> 00:13:16,560
exposure notifications private analytics

339
00:13:16,560 --> 00:13:19,120
system has been deployed since december

340
00:13:19,120 --> 00:13:22,399
2020 and it has been running since then

341
00:13:22,399 --> 00:13:25,120
it is currently operating on four in 14

342
00:13:25,120 --> 00:13:27,200
u.s states and four

343
00:13:27,200 --> 00:13:29,760
mexican states it is collecting nine

344
00:13:29,760 --> 00:13:32,560
distinct metrics and the aggregation

345
00:13:32,560 --> 00:13:34,880
servers are processing millions of

346
00:13:34,880 --> 00:13:38,560
devices contributions every day

347
00:13:38,560 --> 00:13:41,040
the washington state health authority

348
00:13:41,040 --> 00:13:42,639
used the data

349
00:13:42,639 --> 00:13:44,720
produced by the exposure notifications

350
00:13:44,720 --> 00:13:47,440
private analytics to conduct a study

351
00:13:47,440 --> 00:13:49,279
that estimated

352
00:13:49,279 --> 00:13:52,160
the number of lives that were saved and

353
00:13:52,160 --> 00:13:54,000
the number of infections that were

354
00:13:54,000 --> 00:13:55,920
prevented by the exposure notification

355
00:13:55,920 --> 00:13:56,880
system

356
00:13:56,880 --> 00:13:59,199
this was a very gratifying to see the

357
00:13:59,199 --> 00:14:00,560
output of our

358
00:14:00,560 --> 00:14:04,880
system used for this type of study

359
00:14:04,880 --> 00:14:07,360
if you want to learn more about the

360
00:14:07,360 --> 00:14:11,360
specific designs that we used in enpa

361
00:14:11,360 --> 00:14:14,560
you can have a look at our white paper

362
00:14:14,560 --> 00:14:17,680
and now i'm going to pass on to tim who

363
00:14:17,680 --> 00:14:20,079
will tell us more about the challenges

364
00:14:20,079 --> 00:14:22,240
that we faced in the development and

365
00:14:22,240 --> 00:14:25,839
deployment of the system

366
00:14:26,639 --> 00:14:28,160
thank you mariana

367
00:14:28,160 --> 00:14:30,959
okay let's dive right in so the first

368
00:14:30,959 --> 00:14:33,040
problem that we tackled was establishing

369
00:14:33,040 --> 00:14:34,639
uh trusted channels between all the

370
00:14:34,639 --> 00:14:36,639
protocol participants uh there's two

371
00:14:36,639 --> 00:14:38,399
distinct challenges here uh the first is

372
00:14:38,399 --> 00:14:40,240
bootstrapping trust between the servers

373
00:14:40,240 --> 00:14:41,760
and then there's the trickier challenge

374
00:14:41,760 --> 00:14:43,440
of distribution of the aggregator's

375
00:14:43,440 --> 00:14:44,880
encryption keys to the millions of

376
00:14:44,880 --> 00:14:47,440
clients the mobile devices in particular

377
00:14:47,440 --> 00:14:49,120
we wanted to enable revocation of

378
00:14:49,120 --> 00:14:51,199
encryption keys

379
00:14:51,199 --> 00:14:53,360
so the server server case was solved

380
00:14:53,360 --> 00:14:54,800
relatively straightforwardly by

381
00:14:54,800 --> 00:14:56,959
bootstrapping trust from the web pki

382
00:14:56,959 --> 00:14:58,399
each server fetches the security

383
00:14:58,399 --> 00:15:00,480
parameters for all of its peers over

384
00:15:00,480 --> 00:15:02,399
https this is things like mailbox

385
00:15:02,399 --> 00:15:04,800
addresses or public keys

386
00:15:04,800 --> 00:15:07,519
so the web pki gives us well-defined

387
00:15:07,519 --> 00:15:10,079
mechanisms for the issuance revocation

388
00:15:10,079 --> 00:15:11,839
and even transparency of certificates

389
00:15:11,839 --> 00:15:13,760
which bind a public key to some server's

390
00:15:13,760 --> 00:15:16,800
identity so it's very tempting to use it

391
00:15:16,800 --> 00:15:18,480
uh to also solve the problem of

392
00:15:18,480 --> 00:15:20,480
distributing encryption keys

393
00:15:20,480 --> 00:15:22,000
uh we learned that

394
00:15:22,000 --> 00:15:24,720
doing this however is inadvisable

395
00:15:24,720 --> 00:15:26,240
the reason is that if you issue a

396
00:15:26,240 --> 00:15:29,360
certificate whose extended key usage

397
00:15:29,360 --> 00:15:31,519
field says server auth but then you use

398
00:15:31,519 --> 00:15:33,360
it for something that isn't tls such as

399
00:15:33,360 --> 00:15:34,880
the encryption scheme that was used in

400
00:15:34,880 --> 00:15:36,000
the npa

401
00:15:36,000 --> 00:15:37,680
the result is

402
00:15:37,680 --> 00:15:39,519
only borderline acceptable under ca

403
00:15:39,519 --> 00:15:41,360
browser forums baseline requirements

404
00:15:41,360 --> 00:15:43,279
which is the set of standards that

405
00:15:43,279 --> 00:15:44,639
govern the issuance of certificates in

406
00:15:44,639 --> 00:15:45,920
the web pki

407
00:15:45,920 --> 00:15:47,040
um further

408
00:15:47,040 --> 00:15:49,839
this kind of technically okay but now

409
00:15:49,839 --> 00:15:51,839
really intended usage of the web pki

410
00:15:51,839 --> 00:15:53,440
makes it harder for that community to

411
00:15:53,440 --> 00:15:54,959
improve and clarify standards in the

412
00:15:54,959 --> 00:15:55,920
future

413
00:15:55,920 --> 00:15:58,560
to make the web safer for everyone

414
00:15:58,560 --> 00:16:00,880
so in the end we opted to

415
00:16:00,880 --> 00:16:02,800
issue certificates over the over the

416
00:16:02,800 --> 00:16:04,720
encryption keys from an apple controlled

417
00:16:04,720 --> 00:16:06,959
ca that is trusted by mobile devices for

418
00:16:06,959 --> 00:16:08,399
the specific application

419
00:16:08,399 --> 00:16:09,759
but not generally trusted by web

420
00:16:09,759 --> 00:16:11,839
browsers and it's not subject to ca

421
00:16:11,839 --> 00:16:15,199
browser form requirements

422
00:16:15,199 --> 00:16:17,680
um so our recommendations here are to be

423
00:16:17,680 --> 00:16:18,959
very careful when you work with the web

424
00:16:18,959 --> 00:16:21,279
pki uh it and tls are obviously

425
00:16:21,279 --> 00:16:23,519
remarkable achievements but their design

426
00:16:23,519 --> 00:16:24,480
is uh

427
00:16:24,480 --> 00:16:26,800
very much tailored to the to the web and

428
00:16:26,800 --> 00:16:28,720
it's surprisingly easy to find yourself

429
00:16:28,720 --> 00:16:30,240
outside of the use cases that are well

430
00:16:30,240 --> 00:16:32,560
supported by those technologies

431
00:16:32,560 --> 00:16:34,800
fortunately anybody can solicit advice

432
00:16:34,800 --> 00:16:36,240
from the top experts in this field

433
00:16:36,240 --> 00:16:38,480
simply by posting ideas or questions to

434
00:16:38,480 --> 00:16:40,480
the mozilla dev security policy mailing

435
00:16:40,480 --> 00:16:42,320
list which is always a good idea if

436
00:16:42,320 --> 00:16:43,519
you're about to do something a little

437
00:16:43,519 --> 00:16:46,639
bit unusual with the web pki

438
00:16:46,639 --> 00:16:49,120
so going forward it's clear that mpc

439
00:16:49,120 --> 00:16:50,880
systems are going

440
00:16:50,880 --> 00:16:53,680
to want secure and transparent systems

441
00:16:53,680 --> 00:16:54,720
for distribution of keys and other

442
00:16:54,720 --> 00:16:56,480
security parameters and ideally ones

443
00:16:56,480 --> 00:16:58,079
that feature some kind of a parameter

444
00:16:58,079 --> 00:17:00,480
commitment scheme

445
00:17:00,480 --> 00:17:02,560
we can learn we should learn a lot from

446
00:17:02,560 --> 00:17:04,720
the experience of the web pki here but

447
00:17:04,720 --> 00:17:06,880
it may be wise to instantiate distinct

448
00:17:06,880 --> 00:17:09,199
pkis that are tailored to these uh mpc

449
00:17:09,199 --> 00:17:11,599
applications

450
00:17:11,599 --> 00:17:12,480
okay

451
00:17:12,480 --> 00:17:13,679
the next big challenge was deploying

452
00:17:13,679 --> 00:17:15,839
this across multiple clouds

453
00:17:15,839 --> 00:17:17,760
early on in the project we decided that

454
00:17:17,760 --> 00:17:19,679
in order to mitigate the risk of any one

455
00:17:19,679 --> 00:17:22,079
organization being able to see both sets

456
00:17:22,079 --> 00:17:24,319
of input shares and thus defeat privacy

457
00:17:24,319 --> 00:17:26,160
we would run each of the two aggregators

458
00:17:26,160 --> 00:17:28,240
on a distinct public cloud namely amazon

459
00:17:28,240 --> 00:17:29,760
web services and the google cloud

460
00:17:29,760 --> 00:17:31,919
platform so right off the bat that meant

461
00:17:31,919 --> 00:17:33,120
that the aggregation server

462
00:17:33,120 --> 00:17:35,120
implementation had to be portable across

463
00:17:35,120 --> 00:17:36,960
the two clouds which takes non-trivial

464
00:17:36,960 --> 00:17:38,480
extra effort that has to be accounted

465
00:17:38,480 --> 00:17:40,960
for when planning engineering work

466
00:17:40,960 --> 00:17:43,520
um also early on in the project we were

467
00:17:43,520 --> 00:17:45,360
concerned that the batches of inputs

468
00:17:45,360 --> 00:17:46,640
being transmitted from the ingestion

469
00:17:46,640 --> 00:17:48,880
servers to the aggregators would be on

470
00:17:48,880 --> 00:17:50,480
the order of hundreds of megabytes

471
00:17:50,480 --> 00:17:52,160
perhaps too large to fit reasonably in

472
00:17:52,160 --> 00:17:54,640
an http request body

473
00:17:54,640 --> 00:17:55,760
so to make things easier for the

474
00:17:55,760 --> 00:17:57,520
aggregators we decided that we would

475
00:17:57,520 --> 00:18:00,559
instead use aws s3 and google cloud

476
00:18:00,559 --> 00:18:02,799
storage buckets as mailboxes in an

477
00:18:02,799 --> 00:18:04,640
asynchronous messaging scheme now the

478
00:18:04,640 --> 00:18:06,320
trade-off there is that this meant we

479
00:18:06,320 --> 00:18:08,799
had to figure out how to get workloads

480
00:18:08,799 --> 00:18:11,039
running in one cloud to securely access

481
00:18:11,039 --> 00:18:13,200
resources that are hosted in the other

482
00:18:13,200 --> 00:18:14,799
now the good news is that it is possible

483
00:18:14,799 --> 00:18:17,120
to do this and without actually sharing

484
00:18:17,120 --> 00:18:19,360
any secrets between the two deployments

485
00:18:19,360 --> 00:18:21,039
uh and i do think we should you know

486
00:18:21,039 --> 00:18:23,120
acknowledge the this because it had to

487
00:18:23,120 --> 00:18:24,640
have taken a ton of work on the part of

488
00:18:24,640 --> 00:18:26,880
security teams at aws and gcp to make

489
00:18:26,880 --> 00:18:29,039
this possible that being said the

490
00:18:29,039 --> 00:18:30,720
resulting authentication flows can be

491
00:18:30,720 --> 00:18:33,039
pretty complicated so we illustrate this

492
00:18:33,039 --> 00:18:34,400
on the right hand side with a sequence

493
00:18:34,400 --> 00:18:36,000
diagram that shows how a workload

494
00:18:36,000 --> 00:18:38,000
running in amazon's elastic kubernetes

495
00:18:38,000 --> 00:18:39,840
service might go about obtaining a

496
00:18:39,840 --> 00:18:41,679
credential that would let it say

497
00:18:41,679 --> 00:18:43,120
download an object from a google cloud

498
00:18:43,120 --> 00:18:44,320
storage bucket

499
00:18:44,320 --> 00:18:45,600
um we don't have time to get into all

500
00:18:45,600 --> 00:18:47,440
the details of this and it would be cool

501
00:18:47,440 --> 00:18:48,880
of me to expect you to actually read all

502
00:18:48,880 --> 00:18:50,960
the text there but the upshot here is

503
00:18:50,960 --> 00:18:52,400
that in order to get a credential that

504
00:18:52,400 --> 00:18:54,000
ultimately lets you do something like

505
00:18:54,000 --> 00:18:56,080
download an object from a bucket you

506
00:18:56,080 --> 00:18:57,280
have to perform four different

507
00:18:57,280 --> 00:18:58,559
credential exchanges each of which

508
00:18:58,559 --> 00:19:00,320
involves an rpc to some remote identity

509
00:19:00,320 --> 00:19:02,799
service um each one exchanging you know

510
00:19:02,799 --> 00:19:04,320
one identity token for the next in a

511
00:19:04,320 --> 00:19:05,520
chain

512
00:19:05,520 --> 00:19:07,440
now all of those token exchanges those

513
00:19:07,440 --> 00:19:08,960
credential exchanges exist for a good

514
00:19:08,960 --> 00:19:11,360
reason because each represents

515
00:19:11,360 --> 00:19:13,360
a meaningful transition across from one

516
00:19:13,360 --> 00:19:15,520
security domain to another further the

517
00:19:15,520 --> 00:19:17,039
performance overhead from getting all of

518
00:19:17,039 --> 00:19:18,559
these is essentially negligible because

519
00:19:18,559 --> 00:19:20,000
the token that you end up with can be

520
00:19:20,000 --> 00:19:21,440
cached for some configurable period

521
00:19:21,440 --> 00:19:23,360
something on the order of an hour

522
00:19:23,360 --> 00:19:25,120
what's concerning here though is that to

523
00:19:25,120 --> 00:19:26,640
get all this to work properly you're

524
00:19:26,640 --> 00:19:28,320
going to have to go configure i am roles

525
00:19:28,320 --> 00:19:30,559
and service accounts and oidc identity

526
00:19:30,559 --> 00:19:32,320
providers and for each of those things

527
00:19:32,320 --> 00:19:33,760
you have to carefully construct this

528
00:19:33,760 --> 00:19:36,320
magic string that allows a running

529
00:19:36,320 --> 00:19:38,080
application to exchange token n for

530
00:19:38,080 --> 00:19:39,919
token n plus one in the chain

531
00:19:39,919 --> 00:19:41,600
and each one of these is an opportunity

532
00:19:41,600 --> 00:19:43,600
to get something wrong and leave a

533
00:19:43,600 --> 00:19:45,039
security hole in your deployment that

534
00:19:45,039 --> 00:19:47,039
would uh possibly defeat the purpose of

535
00:19:47,039 --> 00:19:48,640
all this uh you know novel privacy

536
00:19:48,640 --> 00:19:52,080
preserving cryptography that we've got

537
00:19:52,080 --> 00:19:54,559
so our recommendations here are um to

538
00:19:54,559 --> 00:19:56,640
try as hard as you can to use simple

539
00:19:56,640 --> 00:19:58,400
synchronous messaging schemes say based

540
00:19:58,400 --> 00:20:01,280
on http request response if as in fact

541
00:20:01,280 --> 00:20:02,960
wound up being the case for us the

542
00:20:02,960 --> 00:20:04,240
availability requirements that are

543
00:20:04,240 --> 00:20:06,159
imposed by message sizes and request

544
00:20:06,159 --> 00:20:07,600
rates make that kind of a design

545
00:20:07,600 --> 00:20:09,600
feasible because if you can do that then

546
00:20:09,600 --> 00:20:10,960
you're going to be in a position to

547
00:20:10,960 --> 00:20:12,799
abstract away all the cloud primitives

548
00:20:12,799 --> 00:20:15,520
used by any given service implementation

549
00:20:15,520 --> 00:20:17,039
which will significantly reduce your

550
00:20:17,039 --> 00:20:18,799
exposed api surface and make your

551
00:20:18,799 --> 00:20:21,280
deployments quite a bit easier

552
00:20:21,280 --> 00:20:23,440
going forward um mpc deployments are

553
00:20:23,440 --> 00:20:26,120
going to continue to be interested in uh

554
00:20:26,120 --> 00:20:27,840
multi-season diversity in cloud

555
00:20:27,840 --> 00:20:29,919
platforms and compute platforms in order

556
00:20:29,919 --> 00:20:31,760
to better uphold the privacy guarantees

557
00:20:31,760 --> 00:20:33,440
based on non-collusion and that's not to

558
00:20:33,440 --> 00:20:35,039
mention all of the other reasons that so

559
00:20:35,039 --> 00:20:36,559
many organizations have an interest in

560
00:20:36,559 --> 00:20:38,720
multi-cloud deployments nowadays so for

561
00:20:38,720 --> 00:20:40,320
that reason uh simpler tools for the

562
00:20:40,320 --> 00:20:42,080
configuration and auditing of

563
00:20:42,080 --> 00:20:43,760
cross-cloud identity federation and

564
00:20:43,760 --> 00:20:44,960
permissions are going to prove quite

565
00:20:44,960 --> 00:20:47,440
valuable

566
00:20:47,520 --> 00:20:48,720
the last challenge that we're going to

567
00:20:48,720 --> 00:20:51,280
discuss today is the testing of such

568
00:20:51,280 --> 00:20:52,400
systems

569
00:20:52,400 --> 00:20:54,080
now end-to-end integration testing and

570
00:20:54,080 --> 00:20:55,840
distributed systems is always very

571
00:20:55,840 --> 00:20:57,760
challenging but it's even harder in an

572
00:20:57,760 --> 00:21:00,480
mpc setting where any test that you run

573
00:21:00,480 --> 00:21:01,520
has to be done across multiple

574
00:21:01,520 --> 00:21:02,400
organizations

575
00:21:02,400 --> 00:21:04,159
that don't share a deploy system or even

576
00:21:04,159 --> 00:21:06,400
a calendar server and then it's even

577
00:21:06,400 --> 00:21:08,000
acutely more difficult than a privacy

578
00:21:08,000 --> 00:21:10,320
preserving system like this because if

579
00:21:10,320 --> 00:21:12,720
you were to have uh invalid or corrupt

580
00:21:12,720 --> 00:21:14,799
intermediate products from the process

581
00:21:14,799 --> 00:21:16,480
they're deliberately indistinguishable

582
00:21:16,480 --> 00:21:18,960
from correct values

583
00:21:18,960 --> 00:21:20,080
so in

584
00:21:20,080 --> 00:21:22,240
mpa setting up an end-to-end integration

585
00:21:22,240 --> 00:21:24,400
test required setting up two devices to

586
00:21:24,400 --> 00:21:25,679
simulate an exposure from one to the

587
00:21:25,679 --> 00:21:27,360
other an ingestion server and two

588
00:21:27,360 --> 00:21:29,760
aggregators so any such test spans at a

589
00:21:29,760 --> 00:21:30,960
minimum three different organizations

590
00:21:30,960 --> 00:21:32,240
that have to coordinate deployments and

591
00:21:32,240 --> 00:21:33,600
verification

592
00:21:33,600 --> 00:21:35,440
um we also found that we had to produce

593
00:21:35,440 --> 00:21:38,320
uh uh special uh builds of the clients

594
00:21:38,320 --> 00:21:39,600
that enabled us to disable certain

595
00:21:39,600 --> 00:21:41,440
features like differential privacy uh in

596
00:21:41,440 --> 00:21:43,440
order to make the outputs predictable in

597
00:21:43,440 --> 00:21:45,440
test or experimental settings

598
00:21:45,440 --> 00:21:47,280
so when working on a system like this

599
00:21:47,280 --> 00:21:49,039
consider that your usual integration

600
00:21:49,039 --> 00:21:51,840
test practices may not be sufficient uh

601
00:21:51,840 --> 00:21:53,360
one thing that may come up is that you

602
00:21:53,360 --> 00:21:54,720
may need to test

603
00:21:54,720 --> 00:21:56,240
the staging instance of your server

604
00:21:56,240 --> 00:21:58,240
against a peer server or against clients

605
00:21:58,240 --> 00:22:00,480
that cannot get on your vpn you're going

606
00:22:00,480 --> 00:22:01,440
to want to start working with your

607
00:22:01,440 --> 00:22:03,039
security and networking teams on this

608
00:22:03,039 --> 00:22:05,520
sooner rather than later

609
00:22:05,520 --> 00:22:07,039
besides that think ahead on your test

610
00:22:07,039 --> 00:22:08,880
plans as we did you're going to want to

611
00:22:08,880 --> 00:22:11,039
create a custom clients that disable

612
00:22:11,039 --> 00:22:12,960
certain privacy features and also

613
00:22:12,960 --> 00:22:14,720
consider driving test inputs from a seed

614
00:22:14,720 --> 00:22:16,240
that you record somewhere so that you

615
00:22:16,240 --> 00:22:18,320
can repeat experiments and predict what

616
00:22:18,320 --> 00:22:20,320
the expected value of an aggregation or

617
00:22:20,320 --> 00:22:22,480
the output of a process will be

618
00:22:22,480 --> 00:22:24,799
um finally consider that your debugging

619
00:22:24,799 --> 00:22:25,840
challenges don't end once you've

620
00:22:25,840 --> 00:22:27,440
deployed the system because when

621
00:22:27,440 --> 00:22:28,799
incidents occur and in distributed

622
00:22:28,799 --> 00:22:31,360
systems incidents always occur

623
00:22:31,360 --> 00:22:32,799
you're going to want to be able to

624
00:22:32,799 --> 00:22:35,360
quickly isolate diagnose and address

625
00:22:35,360 --> 00:22:36,880
problems that arise

626
00:22:36,880 --> 00:22:38,320
so this requires

627
00:22:38,320 --> 00:22:40,159
a robust and principled approach to

628
00:22:40,159 --> 00:22:41,679
continuous verification of correctness

629
00:22:41,679 --> 00:22:43,840
of the system as well as observability

630
00:22:43,840 --> 00:22:45,919
so that's uh metrics and alerting on on

631
00:22:45,919 --> 00:22:47,600
your system to see how they're working

632
00:22:47,600 --> 00:22:49,360
you're also going to want to establish

633
00:22:49,360 --> 00:22:50,799
procedures for responding to incidents

634
00:22:50,799 --> 00:22:52,080
and crucially

635
00:22:52,080 --> 00:22:53,360
good communication channels with all

636
00:22:53,360 --> 00:22:54,640
your partners because dealing with these

637
00:22:54,640 --> 00:22:56,880
problems is usually going to require a

638
00:22:56,880 --> 00:22:59,039
close uh coordination with people who

639
00:22:59,039 --> 00:23:00,080
are outside of your immediate

640
00:23:00,080 --> 00:23:01,600
organization that is you know people who

641
00:23:01,600 --> 00:23:04,480
are not on your own slack

642
00:23:04,480 --> 00:23:05,360
so

643
00:23:05,360 --> 00:23:07,200
to wrap up um

644
00:23:07,200 --> 00:23:08,640
we've presented the exposure

645
00:23:08,640 --> 00:23:10,799
notifications private analytics system

646
00:23:10,799 --> 00:23:12,720
whose purpose is to evaluate the

647
00:23:12,720 --> 00:23:14,880
effectiveness of exposure notification

648
00:23:14,880 --> 00:23:16,559
using privacy-preserving measurement of

649
00:23:16,559 --> 00:23:18,320
epidemiological metrics

650
00:23:18,320 --> 00:23:20,000
we believe that this work demonstrates

651
00:23:20,000 --> 00:23:21,919
the viability of mpc at scales

652
00:23:21,919 --> 00:23:23,200
sufficient to address real world

653
00:23:23,200 --> 00:23:24,240
problems

654
00:23:24,240 --> 00:23:26,240
this project involved about 30 people

655
00:23:26,240 --> 00:23:28,799
across five different institutions

656
00:23:28,799 --> 00:23:29,840
it took about six months from the

657
00:23:29,840 --> 00:23:31,280
initial idea to the first production

658
00:23:31,280 --> 00:23:32,559
deployment which was in the american

659
00:23:32,559 --> 00:23:35,039
state of maryland in december 2020.

660
00:23:35,039 --> 00:23:36,880
since then we've scaled the system to

661
00:23:36,880 --> 00:23:38,640
serve to serve a population of tens of

662
00:23:38,640 --> 00:23:40,159
millions of users across the united

663
00:23:40,159 --> 00:23:42,640
states and internationally

664
00:23:42,640 --> 00:23:44,159
and in the united states alone we've

665
00:23:44,159 --> 00:23:46,000
aggregated over 22 billion individual

666
00:23:46,000 --> 00:23:48,080
metrics

667
00:23:48,080 --> 00:23:50,000
so we've got all this great cryptography

668
00:23:50,000 --> 00:23:51,760
and now we have some actual experience

669
00:23:51,760 --> 00:23:53,120
of building and operating systems but

670
00:23:53,120 --> 00:23:54,080
use it

671
00:23:54,080 --> 00:23:56,640
what remains is challenges of education

672
00:23:56,640 --> 00:23:58,159
we have to figure out how to make the

673
00:23:58,159 --> 00:23:59,600
privacy protecting properties of these

674
00:23:59,600 --> 00:24:01,760
systems cogent to both end users that's

675
00:24:01,760 --> 00:24:02,960
someone whose phone is asking them

676
00:24:02,960 --> 00:24:04,480
whether they want to participate in a

677
00:24:04,480 --> 00:24:06,640
system like enpa as well as potential

678
00:24:06,640 --> 00:24:08,640
adopters uh think here of a regional

679
00:24:08,640 --> 00:24:10,000
public health authority that is

680
00:24:10,000 --> 00:24:12,159
considering whether to offer enpa to the

681
00:24:12,159 --> 00:24:14,159
population that they serve

682
00:24:14,159 --> 00:24:14,880
um

683
00:24:14,880 --> 00:24:16,640
so we believe that this challenge will

684
00:24:16,640 --> 00:24:18,000
be aided although not you know not

685
00:24:18,000 --> 00:24:19,600
completely solved but aided by efforts

686
00:24:19,600 --> 00:24:21,440
to standardize privacy-preserving npc

687
00:24:21,440 --> 00:24:22,880
techniques which will also help with

688
00:24:22,880 --> 00:24:24,720
interoperability of implementations and

689
00:24:24,720 --> 00:24:26,240
transparency

690
00:24:26,240 --> 00:24:28,159
um so there's a number of efforts to

691
00:24:28,159 --> 00:24:29,520
this end going on in a number of

692
00:24:29,520 --> 00:24:31,840
industry bodies uh so there's a

693
00:24:31,840 --> 00:24:34,559
community group a two in w3c there's at

694
00:24:34,559 --> 00:24:36,240
least one competition on going at nist i

695
00:24:36,240 --> 00:24:38,320
believe and if you'd like to learn more

696
00:24:38,320 --> 00:24:40,159
about one such protocol that's currently

697
00:24:40,159 --> 00:24:41,520
being designed through the internet

698
00:24:41,520 --> 00:24:43,120
engineering task force then you can stay

699
00:24:43,120 --> 00:24:44,320
right where you are for the very next

700
00:24:44,320 --> 00:24:46,000
session which we'll get into detail on

701
00:24:46,000 --> 00:24:48,080
the privacy preserving measurements

702
00:24:48,080 --> 00:24:50,000
protocol

703
00:24:50,000 --> 00:24:53,799
that's it thanks very much

704
00:25:01,919 --> 00:25:03,279
thank you very much we're ever so

705
00:25:03,279 --> 00:25:05,200
slightly over time but if there is a

706
00:25:05,200 --> 00:25:06,640
quick question or two i think we can

707
00:25:06,640 --> 00:25:08,240
make time for it so please come to the

708
00:25:08,240 --> 00:25:11,120
mic if you have a question

709
00:25:11,120 --> 00:25:12,799
step right up

710
00:25:12,799 --> 00:25:14,480
please make your question short if you

711
00:25:14,480 --> 00:25:16,640
can yes i was wondering if you guys uh

712
00:25:16,640 --> 00:25:20,080
took stable attacks into account

713
00:25:21,360 --> 00:25:23,679
i think this is uh hand out with the

714
00:25:23,679 --> 00:25:26,080
device attestation that we're doing at

715
00:25:26,080 --> 00:25:28,400
that level we are doing as much as

716
00:25:28,400 --> 00:25:30,720
we can

717
00:25:32,960 --> 00:25:34,640
thanks for the talk uh you mentioned

718
00:25:34,640 --> 00:25:36,240
that there were some issues using the

719
00:25:36,240 --> 00:25:38,400
webpick air for mpc and that you would

720
00:25:38,400 --> 00:25:39,840
like to see something different can you

721
00:25:39,840 --> 00:25:43,639
elaborate a bit on that

722
00:25:43,840 --> 00:25:45,760
well i don't have a design in hand for

723
00:25:45,760 --> 00:25:47,760
you but um you know the idea is that if

724
00:25:47,760 --> 00:25:48,720
you

725
00:25:48,720 --> 00:25:50,080
so you know in this system for instance

726
00:25:50,080 --> 00:25:51,600
this deployment we knew exactly who was

727
00:25:51,600 --> 00:25:52,960
participating right it's apple google

728
00:25:52,960 --> 00:25:56,080
isrg and the nci and miter so it's not

729
00:25:56,080 --> 00:25:58,640
that hard to do like out of band um set

730
00:25:58,640 --> 00:26:01,039
up a basic parameters right but you know

731
00:26:01,039 --> 00:26:02,159
looking forward to the general

732
00:26:02,159 --> 00:26:03,919
deployment of systems like this

733
00:26:03,919 --> 00:26:06,000
uh i think i think an important goal is

734
00:26:06,000 --> 00:26:07,760
going to be interoperability right so

735
00:26:07,760 --> 00:26:09,679
consider like a general purpose privacy

736
00:26:09,679 --> 00:26:11,760
preserving measurements um i don't know

737
00:26:11,760 --> 00:26:13,200
what's called an ecosystem you know if

738
00:26:13,200 --> 00:26:14,000
you're some service and you want to

739
00:26:14,000 --> 00:26:15,279
gather metrics while respecting people's

740
00:26:15,279 --> 00:26:17,120
privacy it's nice to be able to say go

741
00:26:17,120 --> 00:26:18,880
to like a marketplace of a ton of

742
00:26:18,880 --> 00:26:20,400
different aggregator operators you pick

743
00:26:20,400 --> 00:26:22,960
two and you start aggregating metrics

744
00:26:22,960 --> 00:26:24,400
so if you have a space where there's you

745
00:26:24,400 --> 00:26:25,360
know who knows how many different

746
00:26:25,360 --> 00:26:27,120
operators out there um there anything we

747
00:26:27,120 --> 00:26:28,640
can do to make it as easy as possible

748
00:26:28,640 --> 00:26:30,960
for like my implementation of you know

749
00:26:30,960 --> 00:26:32,320
free and other algorithms to

750
00:26:32,320 --> 00:26:34,960
interoperate smoothly with yours um

751
00:26:34,960 --> 00:26:36,960
well yeah i just feel that like some

752
00:26:36,960 --> 00:26:38,960
some pki that addresses this but isn't

753
00:26:38,960 --> 00:26:41,440
as tightly bound to the to the web uh

754
00:26:41,440 --> 00:26:43,440
will be valuable

755
00:26:43,440 --> 00:26:44,559
thank you

756
00:26:44,559 --> 00:26:46,400
okay last question from the room go

757
00:26:46,400 --> 00:26:48,320
ahead uh what epsilon and delta values

758
00:26:48,320 --> 00:26:50,080
did you get for the differential privacy

759
00:26:50,080 --> 00:26:53,080
part

760
00:26:54,480 --> 00:26:56,400
for differential privacy the what

761
00:26:56,400 --> 00:26:58,159
epsilon and delta values did you get

762
00:26:58,159 --> 00:27:00,400
there

763
00:27:01,679 --> 00:27:04,559
uh we were aiming for epsilon one

764
00:27:04,559 --> 00:27:08,159
okay yeah at the final output level

765
00:27:08,159 --> 00:27:09,760
okay thank you

766
00:27:09,760 --> 00:27:11,279
and we have time for one question from

767
00:27:11,279 --> 00:27:14,159
the chat so uh alexander asks is there

768
00:27:14,159 --> 00:27:15,679
any data you can share about the

769
00:27:15,679 --> 00:27:18,159
likelihood of users to voluntarily

770
00:27:18,159 --> 00:27:20,000
participate in such a system so what

771
00:27:20,000 --> 00:27:22,799
kind of user adoption rates do you see

772
00:27:22,799 --> 00:27:25,360
in as much as you can say

773
00:27:25,360 --> 00:27:26,799
maybe apple and google can answer

774
00:27:26,799 --> 00:27:28,000
separately

775
00:27:28,000 --> 00:27:29,200
yeah

776
00:27:29,200 --> 00:27:32,480
we we don't have the numbers here so

777
00:27:32,480 --> 00:27:34,799
can't really uh we can get back to you

778
00:27:34,799 --> 00:27:36,000
on that no problem

779
00:27:36,000 --> 00:27:37,919
22 billion items is significant number

780
00:27:37,919 --> 00:27:39,360
of items so there's obviously some

781
00:27:39,360 --> 00:27:41,760
participation going on i think this was

782
00:27:41,760 --> 00:27:44,000
something that we consider the privacy

783
00:27:44,000 --> 00:27:46,840
uh metric that apple and google do not

784
00:27:46,840 --> 00:27:49,279
know we are not collecting this

785
00:27:49,279 --> 00:27:50,480
information

786
00:27:50,480 --> 00:27:51,919
okay thank you very much let's thank all

787
00:27:51,919 --> 00:27:55,279
the speakers again thank you

788
00:28:01,679 --> 00:28:03,600
and we'll move right on to the next talk

789
00:28:03,600 --> 00:28:05,919
uh which is very much part two

790
00:28:05,919 --> 00:28:07,679
and uh i think the talk is going to be

791
00:28:07,679 --> 00:28:09,600
given by chris patton

792
00:28:09,600 --> 00:28:12,159
from cloudflare if i recall that's right

793
00:28:12,159 --> 00:28:13,440
yep please go ahead chris as soon as

794
00:28:13,440 --> 00:28:14,880
you're ready thanks all right so i'll

795
00:28:14,880 --> 00:28:16,559
try to make this a little short because

796
00:28:16,559 --> 00:28:18,080
i know we're a little short on time for

797
00:28:18,080 --> 00:28:19,760
starters i'm going to

798
00:28:19,760 --> 00:28:22,480
shorten exposure notifications private

799
00:28:22,480 --> 00:28:25,200
analytics to enpa i'm going to just

800
00:28:25,200 --> 00:28:28,000
uh save a bunch of time that way okay

801
00:28:28,000 --> 00:28:29,440
um

802
00:28:29,440 --> 00:28:31,919
so i'm gonna start this off with um what

803
00:28:31,919 --> 00:28:34,799
i think is uh one underlying premise of

804
00:28:34,799 --> 00:28:36,720
the previous talk which is that

805
00:28:36,720 --> 00:28:39,360
operating a large complex service often

806
00:28:39,360 --> 00:28:41,679
requires measuring certain aspects of

807
00:28:41,679 --> 00:28:44,159
user behavior in order to understand how

808
00:28:44,159 --> 00:28:47,200
to make that system better

809
00:28:47,200 --> 00:28:49,120
but in many cases we don't actually use

810
00:28:49,120 --> 00:28:50,799
individual measurements what we care

811
00:28:50,799 --> 00:28:53,919
about is aggregated data

812
00:28:53,919 --> 00:28:55,440
and of course collecting these

813
00:28:55,440 --> 00:28:57,279
individual measurements is dangerous

814
00:28:57,279 --> 00:28:59,600
because they're privacy sensitive often

815
00:28:59,600 --> 00:29:00,640
times

816
00:29:00,640 --> 00:29:02,240
so we want to do anything that we can to

817
00:29:02,240 --> 00:29:04,559
avoid seeing them in the clear

818
00:29:04,559 --> 00:29:06,559
now what the enpa system we just heard

819
00:29:06,559 --> 00:29:08,399
about demonstrates at least one thing

820
00:29:08,399 --> 00:29:10,000
that it demonstrates

821
00:29:10,000 --> 00:29:12,559
is that a practical way to solve this

822
00:29:12,559 --> 00:29:13,840
problem

823
00:29:13,840 --> 00:29:16,320
to improve privacy is to distribute the

824
00:29:16,320 --> 00:29:17,919
computation of the aggregate among

825
00:29:17,919 --> 00:29:20,159
multiple servers using for example the

826
00:29:20,159 --> 00:29:22,960
prio system

827
00:29:24,320 --> 00:29:26,159
but of course empa was designed with a

828
00:29:26,159 --> 00:29:28,799
specific use case in mind stepping aback

829
00:29:28,799 --> 00:29:30,960
a little bit um what it's basically

830
00:29:30,960 --> 00:29:34,320
useful for is aggregating bit vectors

831
00:29:34,320 --> 00:29:36,640
um and that's pretty useful already you

832
00:29:36,640 --> 00:29:38,320
can imagine a lot of different ways of

833
00:29:38,320 --> 00:29:40,640
adapting that system but what about

834
00:29:40,640 --> 00:29:42,640
other types of aggregates things like

835
00:29:42,640 --> 00:29:44,640
simple statistics what's the mean

836
00:29:44,640 --> 00:29:46,799
standard deviation of the distribution

837
00:29:46,799 --> 00:29:48,320
of the input say

838
00:29:48,320 --> 00:29:49,360
um

839
00:29:49,360 --> 00:29:51,039
or you might be other interested in

840
00:29:51,039 --> 00:29:53,600
other related questions so uh what are

841
00:29:53,600 --> 00:29:55,520
the most commonly occurring bit strings

842
00:29:55,520 --> 00:29:57,919
among my set of inputs for example

843
00:29:57,919 --> 00:30:00,000
um and the good news is that we've seen

844
00:30:00,000 --> 00:30:02,960
a lot of uh really great work in the

845
00:30:02,960 --> 00:30:05,760
cryptographic literature

846
00:30:05,760 --> 00:30:09,279
presenting a variety of mpc techniques

847
00:30:09,279 --> 00:30:11,360
for these problems and a lot others like

848
00:30:11,360 --> 00:30:13,600
them

849
00:30:13,919 --> 00:30:15,279
but one thing you notice about this

850
00:30:15,279 --> 00:30:18,080
literature is that the design goals for

851
00:30:18,080 --> 00:30:19,840
these papers often vary quite

852
00:30:19,840 --> 00:30:21,200
significantly

853
00:30:21,200 --> 00:30:23,200
often starting off with different

854
00:30:23,200 --> 00:30:25,360
security objectives and ending up with

855
00:30:25,360 --> 00:30:27,520
very different protocol designs

856
00:30:27,520 --> 00:30:28,799
and having different shapes and

857
00:30:28,799 --> 00:30:31,520
different architectures

858
00:30:31,520 --> 00:30:34,159
what we think is missing is our clearly

859
00:30:34,159 --> 00:30:36,480
defined design criteria that would

860
00:30:36,480 --> 00:30:39,520
provide a roadmap to deployment

861
00:30:39,520 --> 00:30:41,760
so what i want to do today is introduce

862
00:30:41,760 --> 00:30:44,080
you to the ietf's initial attempt to

863
00:30:44,080 --> 00:30:46,960
provide one such roadmap

864
00:30:46,960 --> 00:30:48,480
and this work really began in earnest

865
00:30:48,480 --> 00:30:50,720
earlier this year as we formed a working

866
00:30:50,720 --> 00:30:51,520
group

867
00:30:51,520 --> 00:30:54,640
whose stated objective is to standardize

868
00:30:54,640 --> 00:30:56,799
multi-party computation techniques for

869
00:30:56,799 --> 00:30:58,480
the purpose of privacy preserving

870
00:30:58,480 --> 00:30:59,919
measurement

871
00:30:59,919 --> 00:31:02,720
what we mean here is we want to develop

872
00:31:02,720 --> 00:31:05,519
technologies that allow one to uh

873
00:31:05,519 --> 00:31:07,679
aggregate privacy sensitive data without

874
00:31:07,679 --> 00:31:09,679
seeing individual measurements

875
00:31:09,679 --> 00:31:11,600
and the types of aggregates we're after

876
00:31:11,600 --> 00:31:13,679
are are wide-ranging

877
00:31:13,679 --> 00:31:16,080
from simple statistics to we would very

878
00:31:16,080 --> 00:31:18,159
much like to be able to support machine

879
00:31:18,159 --> 00:31:19,919
learning machine learning applications

880
00:31:19,919 --> 00:31:20,799
that

881
00:31:20,799 --> 00:31:23,519
people need for different purposes

882
00:31:23,519 --> 00:31:25,200
the main criterion here is that what

883
00:31:25,200 --> 00:31:27,039
you're after the aggregation function

884
00:31:27,039 --> 00:31:29,760
you want to compute needs to be specific

885
00:31:29,760 --> 00:31:32,000
and in particular we're not looking to

886
00:31:32,000 --> 00:31:34,159
standardize or we're not looking to just

887
00:31:34,159 --> 00:31:36,399
uh anonymize data without also

888
00:31:36,399 --> 00:31:38,240
aggregating it

889
00:31:38,240 --> 00:31:41,120
and also um we're just as an aside we're

890
00:31:41,120 --> 00:31:43,360
not looking to use some general purpose

891
00:31:43,360 --> 00:31:46,480
mpc technique for this application

892
00:31:46,480 --> 00:31:48,159
so um what i'll do today is give you an

893
00:31:48,159 --> 00:31:50,720
overview how this work has played out so

894
00:31:50,720 --> 00:31:52,880
far we're early on we have a long way to

895
00:31:52,880 --> 00:31:55,120
go but we've made some great progress

896
00:31:55,120 --> 00:31:56,880
and i'm going to start off with by

897
00:31:56,880 --> 00:31:58,640
looking at some of the candidate

898
00:31:58,640 --> 00:32:00,159
constructions that we've been kicking

899
00:32:00,159 --> 00:32:02,320
around and talk about why we think

900
00:32:02,320 --> 00:32:04,240
they're interesting why they make sense

901
00:32:04,240 --> 00:32:06,000
for standardization

902
00:32:06,000 --> 00:32:07,600
and then i'm going to give you a very

903
00:32:07,600 --> 00:32:09,919
brief overview of the sort of of the

904
00:32:09,919 --> 00:32:11,360
framework that we've built up around

905
00:32:11,360 --> 00:32:12,880
these protocols

906
00:32:12,880 --> 00:32:15,120
and the road map to deployment that we

907
00:32:15,120 --> 00:32:16,880
envision

908
00:32:16,880 --> 00:32:18,559
okay

909
00:32:18,559 --> 00:32:20,720
so when we started off uh thinking about

910
00:32:20,720 --> 00:32:23,279
how to do this work uh over a year ago

911
00:32:23,279 --> 00:32:25,919
now our initial goal was to just uh

912
00:32:25,919 --> 00:32:27,840
standardize prio

913
00:32:27,840 --> 00:32:29,679
not just because we've had some

914
00:32:29,679 --> 00:32:32,320
deployment experience with it with enpa

915
00:32:32,320 --> 00:32:34,720
and other applications

916
00:32:34,720 --> 00:32:36,480
but also there's just a ton of different

917
00:32:36,480 --> 00:32:38,480
things you can do with it so what i want

918
00:32:38,480 --> 00:32:40,640
to start off with is

919
00:32:40,640 --> 00:32:42,880
i want to elaborate on the capabilities

920
00:32:42,880 --> 00:32:46,159
of prio going uh beyond what we saw in

921
00:32:46,159 --> 00:32:48,240
the previous talk

922
00:32:48,240 --> 00:32:50,960
so um i want to to make this concrete i

923
00:32:50,960 --> 00:32:52,880
want to have a sort of running example

924
00:32:52,880 --> 00:32:54,480
to to work with

925
00:32:54,480 --> 00:32:56,799
um so let's imagine you're a website

926
00:32:56,799 --> 00:32:58,399
operator and you want to understand

927
00:32:58,399 --> 00:33:00,320
something about the uh

928
00:33:00,320 --> 00:33:02,559
the uh your users experience in

929
00:33:02,559 --> 00:33:05,200
particular uh whether or not users are

930
00:33:05,200 --> 00:33:06,799
experiencing higher than expected

931
00:33:06,799 --> 00:33:09,120
latency when they say load a certain

932
00:33:09,120 --> 00:33:10,559
page

933
00:33:10,559 --> 00:33:11,919
of course there's lots of different ways

934
00:33:11,919 --> 00:33:13,360
to refine this question which we're

935
00:33:13,360 --> 00:33:16,080
going to do as we move along

936
00:33:16,080 --> 00:33:17,600
all right

937
00:33:17,600 --> 00:33:19,360
in so

938
00:33:19,360 --> 00:33:21,519
this is hopefully will look familiar to

939
00:33:21,519 --> 00:33:23,440
all of you who since you just learned a

940
00:33:23,440 --> 00:33:25,200
little bit about prio so i'll go through

941
00:33:25,200 --> 00:33:26,640
this very quickly

942
00:33:26,640 --> 00:33:27,919
so we start off with a bunch of

943
00:33:27,919 --> 00:33:30,320
measurements and in prio our primary

944
00:33:30,320 --> 00:33:32,399
tool for protecting them is simply

945
00:33:32,399 --> 00:33:35,519
additive secret sharing so uh where each

946
00:33:35,519 --> 00:33:37,440
client begins by encoding its

947
00:33:37,440 --> 00:33:40,159
measurement as a vector over some finite

948
00:33:40,159 --> 00:33:42,000
field and then we're going to split that

949
00:33:42,000 --> 00:33:44,799
vector into

950
00:33:44,799 --> 00:33:47,279
multiple secret shares and

951
00:33:47,279 --> 00:33:48,960
distribute these secret shares amongst

952
00:33:48,960 --> 00:33:51,200
the aggregation servers

953
00:33:51,200 --> 00:33:52,720
and what's the aggregation once an

954
00:33:52,720 --> 00:33:54,799
aggregator has received enough input

955
00:33:54,799 --> 00:33:56,799
shares from enough clients it's just

956
00:33:56,799 --> 00:33:58,880
going to sum them up to get a share of

957
00:33:58,880 --> 00:34:01,919
the aggregate result and it'll just send

958
00:34:01,919 --> 00:34:04,240
this to some data collection endpoint

959
00:34:04,240 --> 00:34:07,039
and on all that collector has to do is

960
00:34:07,039 --> 00:34:08,960
sum up the aggregate shares to get the

961
00:34:08,960 --> 00:34:11,760
final aggregate result

962
00:34:11,760 --> 00:34:13,520
so um the thing i want to point out

963
00:34:13,520 --> 00:34:16,719
about prio here is that the aggregation

964
00:34:16,719 --> 00:34:19,599
function that's computed is simply the

965
00:34:19,599 --> 00:34:22,960
sum of the encoded measurements and

966
00:34:22,960 --> 00:34:24,639
it turns out that there's a lot of

967
00:34:24,639 --> 00:34:26,719
useful aggregation functions that can be

968
00:34:26,719 --> 00:34:29,040
expressed in just this way

969
00:34:29,040 --> 00:34:30,159
so

970
00:34:30,159 --> 00:34:32,480
remember that in the enpa system what we

971
00:34:32,480 --> 00:34:34,399
saw is basically

972
00:34:34,399 --> 00:34:35,280
uh

973
00:34:35,280 --> 00:34:37,760
vectors of counter so each user has

974
00:34:37,760 --> 00:34:40,000
either a one or a zero and we want to

975
00:34:40,000 --> 00:34:42,000
just compute the sum

976
00:34:42,000 --> 00:34:44,879
so this already uh gives us one way of

977
00:34:44,879 --> 00:34:47,359
understanding uh our the

978
00:34:47,359 --> 00:34:49,679
the uh the performance of our website

979
00:34:49,679 --> 00:34:52,320
right so you might imagine you just have

980
00:34:52,320 --> 00:34:54,800
each client report after they load a

981
00:34:54,800 --> 00:34:55,760
page

982
00:34:55,760 --> 00:34:58,000
whether or not loading that page took uh

983
00:34:58,000 --> 00:35:00,079
a particularly long time say more than

984
00:35:00,079 --> 00:35:03,200
half a second or something like that

985
00:35:03,200 --> 00:35:04,400
but of course you might want to know

986
00:35:04,400 --> 00:35:06,000
something about the distribution of the

987
00:35:06,000 --> 00:35:07,200
load times

988
00:35:07,200 --> 00:35:08,400
so

989
00:35:08,400 --> 00:35:10,720
prio for example will allow you to

990
00:35:10,720 --> 00:35:13,359
compute simple statistics like the mean

991
00:35:13,359 --> 00:35:16,320
standard deviation and so on um or you

992
00:35:16,320 --> 00:35:18,079
can estimate the distribution more or

993
00:35:18,079 --> 00:35:21,200
less directly using a histogram uh

994
00:35:21,200 --> 00:35:22,480
kind of in the way you would imagine

995
00:35:22,480 --> 00:35:23,920
doing that

996
00:35:23,920 --> 00:35:26,079
and and you could do lots of other

997
00:35:26,079 --> 00:35:29,040
fancier stuff with prio so for example

998
00:35:29,040 --> 00:35:32,240
suppose you wanted to understand the uh

999
00:35:32,240 --> 00:35:35,040
the load time as a function

1000
00:35:35,040 --> 00:35:37,680
of the uh the distance from the client

1001
00:35:37,680 --> 00:35:39,920
to the server um that's something you

1002
00:35:39,920 --> 00:35:41,839
can do with prio you can frame that as a

1003
00:35:41,839 --> 00:35:44,240
linear regression problem so yeah

1004
00:35:44,240 --> 00:35:45,920
there's lots of different possibilities

1005
00:35:45,920 --> 00:35:47,040
here

1006
00:35:47,040 --> 00:35:49,040
it's simply a matter of figuring out how

1007
00:35:49,040 --> 00:35:52,000
to encode your measurements so that the

1008
00:35:52,000 --> 00:35:54,240
aggregation function can be expressed as

1009
00:35:54,240 --> 00:35:57,200
a sum of the encoded measurements

1010
00:35:57,200 --> 00:35:58,640
of course the uh

1011
00:35:58,640 --> 00:36:00,880
key problem that we have to solve and uh

1012
00:36:00,880 --> 00:36:03,119
is deciding whether a set of input

1013
00:36:03,119 --> 00:36:05,280
shares uploaded by a client sum up to

1014
00:36:05,280 --> 00:36:08,560
some valid uh input otherwise it's

1015
00:36:08,560 --> 00:36:11,680
always possible for the uh the client to

1016
00:36:11,680 --> 00:36:13,920
just send secret shared garbage and cr

1017
00:36:13,920 --> 00:36:16,160
and corrupt the entire computation

1018
00:36:16,160 --> 00:36:18,400
um so how do we solve this problem in

1019
00:36:18,400 --> 00:36:20,079
prio while still

1020
00:36:20,079 --> 00:36:20,880
uh

1021
00:36:20,880 --> 00:36:22,480
providing so many

1022
00:36:22,480 --> 00:36:24,480
uh providing support for so many

1023
00:36:24,480 --> 00:36:27,119
different uh aggregation functions

1024
00:36:27,119 --> 00:36:29,200
um well this is where the details really

1025
00:36:29,200 --> 00:36:30,960
get interesting

1026
00:36:30,960 --> 00:36:32,960
as was mentioned in the previous talk

1027
00:36:32,960 --> 00:36:34,560
there's this is going to require some

1028
00:36:34,560 --> 00:36:35,839
amount of interaction among the

1029
00:36:35,839 --> 00:36:38,320
aggregators in order to do this input

1030
00:36:38,320 --> 00:36:40,640
validation and for the sake of time i'm

1031
00:36:40,640 --> 00:36:42,400
going to skip the details i just want to

1032
00:36:42,400 --> 00:36:44,400
note quickly for those familiar with the

1033
00:36:44,400 --> 00:36:46,000
prio system

1034
00:36:46,000 --> 00:36:48,000
we ended up what the proof system that

1035
00:36:48,000 --> 00:36:50,560
we ended up wanting to specify and

1036
00:36:50,560 --> 00:36:52,640
standardize is based on a paper from

1037
00:36:52,640 --> 00:36:55,280
crypto 2019 which improves upon the

1038
00:36:55,280 --> 00:36:56,960
original prio system in many different

1039
00:36:56,960 --> 00:36:58,400
ways

1040
00:36:58,400 --> 00:37:01,280
so um that's prio in a nutshell

1041
00:37:01,280 --> 00:37:02,720
you could use it to solve a lot of

1042
00:37:02,720 --> 00:37:05,119
different data aggregation problems

1043
00:37:05,119 --> 00:37:06,480
but of course it's not going to be well

1044
00:37:06,480 --> 00:37:08,960
suited for every use case

1045
00:37:08,960 --> 00:37:11,280
and i want to give an example

1046
00:37:11,280 --> 00:37:13,280
and to illustrate it let's refine our

1047
00:37:13,280 --> 00:37:16,480
question about latency a little bit

1048
00:37:16,480 --> 00:37:18,400
suppose we now want to know from where

1049
00:37:18,400 --> 00:37:20,880
in the world are users experiencing high

1050
00:37:20,880 --> 00:37:23,280
latency and in particular from which

1051
00:37:23,280 --> 00:37:24,960
autonomous systems

1052
00:37:24,960 --> 00:37:26,000
um

1053
00:37:26,000 --> 00:37:28,480
now uh this question can be framed as an

1054
00:37:28,480 --> 00:37:32,000
instance of the uh heavy hitters problem

1055
00:37:32,000 --> 00:37:34,720
so here we have a multi-set of

1056
00:37:34,720 --> 00:37:36,560
arbitrary bit strings uploaded by

1057
00:37:36,560 --> 00:37:38,960
clients and we want to know how many of

1058
00:37:38,960 --> 00:37:41,040
these strings occurred at least t times

1059
00:37:41,040 --> 00:37:43,520
for some threshold t

1060
00:37:43,520 --> 00:37:45,680
um okay so one way of solving this

1061
00:37:45,680 --> 00:37:48,720
problem is the poplar protocol

1062
00:37:48,720 --> 00:37:51,359
which was presented at ieee snp last

1063
00:37:51,359 --> 00:37:52,480
year

1064
00:37:52,480 --> 00:37:57,040
um so the uh key idea the key uh

1065
00:37:57,040 --> 00:37:59,599
the key to this the popular protocol is

1066
00:37:59,599 --> 00:38:01,440
this new primitive called an incremental

1067
00:38:01,440 --> 00:38:04,480
distributed point function or idpf

1068
00:38:04,480 --> 00:38:06,320
so i want to kind of illustrate how the

1069
00:38:06,320 --> 00:38:09,680
idpf solves this heavy hitter problem

1070
00:38:09,680 --> 00:38:11,119
all right and um

1071
00:38:11,119 --> 00:38:12,720
and to do that let's uh let's pick a

1072
00:38:12,720 --> 00:38:16,000
distribution so let's say that this

1073
00:38:16,000 --> 00:38:17,920
is the distribution of high latency

1074
00:38:17,920 --> 00:38:21,839
pings that you get to uh your website so

1075
00:38:21,839 --> 00:38:24,000
here each red dot represents the

1076
00:38:24,000 --> 00:38:26,400
location of a client uh when they

1077
00:38:26,400 --> 00:38:29,599
reported that uh they loading the page

1078
00:38:29,599 --> 00:38:32,800
took a particularly long time um

1079
00:38:32,800 --> 00:38:34,000
okay

1080
00:38:34,000 --> 00:38:35,119
and let's uh for the sake of

1081
00:38:35,119 --> 00:38:37,359
illustration let's also imagine there

1082
00:38:37,359 --> 00:38:40,800
are just 16 autonomous systems worldwide

1083
00:38:40,800 --> 00:38:42,560
and that they arrange across the globe

1084
00:38:42,560 --> 00:38:44,800
in in roughly this way

1085
00:38:44,800 --> 00:38:46,800
so each cell of this table represents an

1086
00:38:46,800 --> 00:38:48,720
autonomous system uh and you can see

1087
00:38:48,720 --> 00:38:50,800
that we've given each a unique four bit

1088
00:38:50,800 --> 00:38:53,440
identifier so what a client reports is

1089
00:38:53,440 --> 00:38:56,400
basically one of these strings the the

1090
00:38:56,400 --> 00:38:58,560
identity of the as that they were in

1091
00:38:58,560 --> 00:39:00,480
when the bad thing happened that we want

1092
00:39:00,480 --> 00:39:02,880
to measure

1093
00:39:02,960 --> 00:39:04,160
okay

1094
00:39:04,160 --> 00:39:06,960
so idpfs don't solve the heavy headers

1095
00:39:06,960 --> 00:39:09,520
problem directly what they do is do is

1096
00:39:09,520 --> 00:39:11,760
solve a simpler problem

1097
00:39:11,760 --> 00:39:13,280
so

1098
00:39:13,280 --> 00:39:14,720
what it what it allows you to do is

1099
00:39:14,720 --> 00:39:16,240
count the number of strings that begin

1100
00:39:16,240 --> 00:39:18,640
with a given prefix so for example we

1101
00:39:18,640 --> 00:39:21,520
can count how many uh inputs begin with

1102
00:39:21,520 --> 00:39:24,079
a zero or a one which already gives us a

1103
00:39:24,079 --> 00:39:26,880
little bit of insight into our data but

1104
00:39:26,880 --> 00:39:28,480
doesn't uh but you know we're going to

1105
00:39:28,480 --> 00:39:30,079
want to drill down on it a little bit

1106
00:39:30,079 --> 00:39:31,520
further

1107
00:39:31,520 --> 00:39:32,960
and we can naturally extend this of

1108
00:39:32,960 --> 00:39:35,040
course to count the number of strings

1109
00:39:35,040 --> 00:39:37,440
that begin with each 2-bit prefix and

1110
00:39:37,440 --> 00:39:40,320
each 3-bit prefix and so on

1111
00:39:40,320 --> 00:39:42,160
now as we drill down on the data this

1112
00:39:42,160 --> 00:39:44,160
way what we start to realize is we can

1113
00:39:44,160 --> 00:39:46,880
eliminate certain say sets of as's as

1114
00:39:46,880 --> 00:39:49,040
potential sources of heavy hitters and

1115
00:39:49,040 --> 00:39:51,119
that's simply because the hit counts for

1116
00:39:51,119 --> 00:39:53,760
the corresponding prefixes are below our

1117
00:39:53,760 --> 00:39:56,000
target threshold

1118
00:39:56,000 --> 00:39:59,440
so um we can we can extend this idea one

1119
00:39:59,440 --> 00:40:01,040
one bit further

1120
00:40:01,040 --> 00:40:03,440
um and what we end up with at the end of

1121
00:40:03,440 --> 00:40:07,119
the day is the set of uh

1122
00:40:07,119 --> 00:40:08,880
uh strings that occurred at least as

1123
00:40:08,880 --> 00:40:10,720
many times as our target threshold this

1124
00:40:10,720 --> 00:40:12,880
is our heavy hitters

1125
00:40:12,880 --> 00:40:15,040
okay so

1126
00:40:15,040 --> 00:40:18,240
what i want you to notice about this

1127
00:40:18,240 --> 00:40:21,680
idpf evaluation process is that it has a

1128
00:40:21,680 --> 00:40:24,079
remarkably remarkably similar shape to

1129
00:40:24,079 --> 00:40:25,280
prio

1130
00:40:25,280 --> 00:40:26,720
clients begin by splitting their

1131
00:40:26,720 --> 00:40:28,560
measurements into input shares and

1132
00:40:28,560 --> 00:40:29,920
distributing these amongst the

1133
00:40:29,920 --> 00:40:32,640
aggregators the aggregators will query

1134
00:40:32,640 --> 00:40:35,040
these input shares on a set of candidate

1135
00:40:35,040 --> 00:40:36,160
prefixes

1136
00:40:36,160 --> 00:40:39,359
uh getting a set of out of output shares

1137
00:40:39,359 --> 00:40:41,599
um and then uh the aggregators will need

1138
00:40:41,599 --> 00:40:43,359
to interact with one another in order to

1139
00:40:43,359 --> 00:40:45,040
make sure that the output shares are

1140
00:40:45,040 --> 00:40:46,319
well formed

1141
00:40:46,319 --> 00:40:48,880
but once they've done that all all these

1142
00:40:48,880 --> 00:40:51,200
servers collectively have to do is sum

1143
00:40:51,200 --> 00:40:53,200
up these output shares to get the hit

1144
00:40:53,200 --> 00:40:56,240
count for each candidate prefix

1145
00:40:56,240 --> 00:40:58,160
now there's one wrinkle here to solve

1146
00:40:58,160 --> 00:40:59,520
the heavy hitters problem we're going to

1147
00:40:59,520 --> 00:41:01,839
have to allow the collector to interact

1148
00:41:01,839 --> 00:41:03,760
with the aggregators over multiple

1149
00:41:03,760 --> 00:41:05,520
rounds where in each round we compute

1150
00:41:05,520 --> 00:41:08,319
the next set of candidate prefixes

1151
00:41:08,319 --> 00:41:10,560
all right if that didn't make any sense

1152
00:41:10,560 --> 00:41:12,319
don't worry

1153
00:41:12,319 --> 00:41:14,319
this is the point

1154
00:41:14,319 --> 00:41:16,560
where we've arrived is a sort of high

1155
00:41:16,560 --> 00:41:19,280
level architecture for the distributed

1156
00:41:19,280 --> 00:41:21,440
computation of some aggregation function

1157
00:41:21,440 --> 00:41:23,440
where we have some aggregation parameter

1158
00:41:23,440 --> 00:41:26,720
i.e the set of candidate prefixes um a

1159
00:41:26,720 --> 00:41:29,839
set of measurements and um the uh what

1160
00:41:29,839 --> 00:41:31,680
it outputs is the aggregate that we're

1161
00:41:31,680 --> 00:41:33,599
after

1162
00:41:33,599 --> 00:41:35,359
and of course we built this around prio

1163
00:41:35,359 --> 00:41:37,839
in poplar but our hope is that lots of

1164
00:41:37,839 --> 00:41:39,760
interesting and useful papers fit into

1165
00:41:39,760 --> 00:41:41,440
this framework

1166
00:41:41,440 --> 00:41:43,359
now a good example is prio plus which

1167
00:41:43,359 --> 00:41:46,800
fits quite neatly uh and

1168
00:41:46,800 --> 00:41:48,160
you can sort of think of this as an

1169
00:41:48,160 --> 00:41:50,800
alternative to prio that that um uses

1170
00:41:50,800 --> 00:41:53,280
different npc techniques that uh leads

1171
00:41:53,280 --> 00:41:55,280
to different trade-offs that uh for

1172
00:41:55,280 --> 00:41:57,520
deployments um and this is you know the

1173
00:41:57,520 --> 00:41:58,720
sort of the thing that we would

1174
00:41:58,720 --> 00:42:00,480
absolutely want to make room for in a

1175
00:42:00,480 --> 00:42:02,720
standard it should be possible to trade

1176
00:42:02,720 --> 00:42:05,119
uh like client time complexity for

1177
00:42:05,119 --> 00:42:07,599
server communication costs etc

1178
00:42:07,599 --> 00:42:09,119
um

1179
00:42:09,119 --> 00:42:11,760
and uh of course there's uh lots of uh

1180
00:42:11,760 --> 00:42:13,680
interesting papers out there that share

1181
00:42:13,680 --> 00:42:15,599
similar ideas but don't quite fit in

1182
00:42:15,599 --> 00:42:17,839
here and a good example of this is the

1183
00:42:17,839 --> 00:42:19,680
masked lark paper from microsoft

1184
00:42:19,680 --> 00:42:22,319
research that came out last year where

1185
00:42:22,319 --> 00:42:24,160
the goal is to compute gradient descent

1186
00:42:24,160 --> 00:42:26,079
in a privacy preserving manner while

1187
00:42:26,079 --> 00:42:28,000
still being extremely lightweight and

1188
00:42:28,000 --> 00:42:29,359
easy to implement

1189
00:42:29,359 --> 00:42:31,920
um and their their system also uses

1190
00:42:31,920 --> 00:42:33,440
secret sharing but they don't try to

1191
00:42:33,440 --> 00:42:35,200
validate the secret shared data in any

1192
00:42:35,200 --> 00:42:37,599
way um like we would do in prio or

1193
00:42:37,599 --> 00:42:38,640
poplar

1194
00:42:38,640 --> 00:42:40,560
and not all of the the uh privacy

1195
00:42:40,560 --> 00:42:42,079
sensitive data ends up getting secret

1196
00:42:42,079 --> 00:42:44,880
shared so we would like to uh but but it

1197
00:42:44,880 --> 00:42:46,240
raises an interesting question of

1198
00:42:46,240 --> 00:42:49,119
whether gradient descent can be computed

1199
00:42:49,119 --> 00:42:51,119
uh in a way that's fully private and

1200
00:42:51,119 --> 00:42:52,560
verifiable

1201
00:42:52,560 --> 00:42:54,880
and also that fits into this overall

1202
00:42:54,880 --> 00:42:56,400
architecture

1203
00:42:56,400 --> 00:42:58,240
but regardless of the answer here the

1204
00:42:58,240 --> 00:43:00,160
the the thing i want you to take away is

1205
00:43:00,160 --> 00:43:02,240
that there are a lot of different secure

1206
00:43:02,240 --> 00:43:04,000
aggregation problems we can solve in

1207
00:43:04,000 --> 00:43:06,560
this setting um but not every problem is

1208
00:43:06,560 --> 00:43:09,040
going to have the same solution

1209
00:43:09,040 --> 00:43:10,800
what we expect to happen is that

1210
00:43:10,800 --> 00:43:12,880
protocols will continue to be tailored

1211
00:43:12,880 --> 00:43:15,839
to particular problems and that's okay

1212
00:43:15,839 --> 00:43:17,680
but we do need to make sure of a couple

1213
00:43:17,680 --> 00:43:20,640
things one that these schemes all meet

1214
00:43:20,640 --> 00:43:23,280
some baseline security requirements

1215
00:43:23,280 --> 00:43:25,920
and also that they have a similar enough

1216
00:43:25,920 --> 00:43:27,760
shape that it's possible to build

1217
00:43:27,760 --> 00:43:29,760
applications around them

1218
00:43:29,760 --> 00:43:31,680
so in that spirit the name that we've

1219
00:43:31,680 --> 00:43:34,640
given for this uh basic mpc shape is a

1220
00:43:34,640 --> 00:43:36,400
verifiable distributed aggregation

1221
00:43:36,400 --> 00:43:39,760
function or vdf so these are uh these

1222
00:43:39,760 --> 00:43:41,520
are will be specified in this internet

1223
00:43:41,520 --> 00:43:43,359
draft we're working on i've linked it

1224
00:43:43,359 --> 00:43:46,079
here the goal of this draft is basically

1225
00:43:46,079 --> 00:43:49,040
to lay out the design criteria for new

1226
00:43:49,040 --> 00:43:51,680
constructions um and also to kind of

1227
00:43:51,680 --> 00:43:53,680
define the api boundary that

1228
00:43:53,680 --> 00:43:55,760
applications can expect which would

1229
00:43:55,760 --> 00:43:58,720
allow them to build uh application

1230
00:43:58,720 --> 00:44:01,280
allows us to build applications that are

1231
00:44:01,280 --> 00:44:03,280
agnostic to whatever aggregation

1232
00:44:03,280 --> 00:44:06,560
function it is you want to compute

1233
00:44:06,560 --> 00:44:09,280
one such application is the ppm protocol

1234
00:44:09,280 --> 00:44:10,319
the uh

1235
00:44:10,319 --> 00:44:12,319
the namesake of the the ppm working

1236
00:44:12,319 --> 00:44:14,960
group um and the goal of this draft is

1237
00:44:14,960 --> 00:44:17,520
to spell out exactly how one would

1238
00:44:17,520 --> 00:44:20,560
evaluate a vdf over https and along the

1239
00:44:20,560 --> 00:44:23,040
way it has uh it addresses a number of

1240
00:44:23,040 --> 00:44:25,680
operational considerations and we will

1241
00:44:25,680 --> 00:44:27,040
also have additional security

1242
00:44:27,040 --> 00:44:29,440
considerations on top of those for vdas

1243
00:44:29,440 --> 00:44:31,680
including providing uh defenses for

1244
00:44:31,680 --> 00:44:34,079
civil attacks uh and also supporting

1245
00:44:34,079 --> 00:44:36,560
different differential privacy so that's

1246
00:44:36,560 --> 00:44:38,560
the lay of the land thank you all for

1247
00:44:38,560 --> 00:44:41,119
listening uh if you think this work is

1248
00:44:41,119 --> 00:44:43,040
interesting or important we would love

1249
00:44:43,040 --> 00:44:45,040
to have your participation uh for

1250
00:44:45,040 --> 00:44:47,040
starters please join the ppm mailing

1251
00:44:47,040 --> 00:44:49,040
list and get involved

1252
00:44:49,040 --> 00:44:50,400
i there are

1253
00:44:50,400 --> 00:44:52,000
the two drafts that i talked about there

1254
00:44:52,000 --> 00:44:53,920
are currently calls for adoption out for

1255
00:44:53,920 --> 00:44:56,400
both so one thing you can do to help

1256
00:44:56,400 --> 00:44:58,560
with this work is to read these drafts

1257
00:44:58,560 --> 00:45:00,400
and endorse them on the list if indeed

1258
00:45:00,400 --> 00:45:02,319
they're worthy of your endorsement

1259
00:45:02,319 --> 00:45:04,000
thank you very much and i'm happy to

1260
00:45:04,000 --> 00:45:06,510
take questions if i have time

1261
00:45:06,510 --> 00:45:09,689
[Applause]

1262
00:45:11,920 --> 00:45:15,280
[Applause]

1263
00:45:15,280 --> 00:45:17,280
thanks chris i see we have a question

1264
00:45:17,280 --> 00:45:19,920
already go ahead

1265
00:45:19,920 --> 00:45:21,760
hi uh thank you for the really great

1266
00:45:21,760 --> 00:45:23,440
talk um

1267
00:45:23,440 --> 00:45:25,680
i guess i have a question sort of about

1268
00:45:25,680 --> 00:45:30,000
failure so um these proofs are

1269
00:45:30,000 --> 00:45:31,920
basically all the clients upload their

1270
00:45:31,920 --> 00:45:33,839
uh secret shared data and the proof that

1271
00:45:33,839 --> 00:45:36,720
the data is falls within whatever range

1272
00:45:36,720 --> 00:45:39,119
that the data is acceptable for and i

1273
00:45:39,119 --> 00:45:41,760
assume right now uh in the design these

1274
00:45:41,760 --> 00:45:44,640
proofs are verified with every batch

1275
00:45:44,640 --> 00:45:47,520
that's uploaded i'm curious like have

1276
00:45:47,520 --> 00:45:49,599
you considered doing something like

1277
00:45:49,599 --> 00:45:51,680
uh verification and identification of

1278
00:45:51,680 --> 00:45:52,720
cheaters

1279
00:45:52,720 --> 00:45:53,839
uh

1280
00:45:53,839 --> 00:45:54,800
after

1281
00:45:54,800 --> 00:45:56,640
uh identifying that a failure has

1282
00:45:56,640 --> 00:45:58,640
actually occurred so like for example

1283
00:45:58,640 --> 00:45:59,599
you could send all the data to the

1284
00:45:59,599 --> 00:46:01,760
aggregator check to see if it's within

1285
00:46:01,760 --> 00:46:04,400
whatever like global range and then uh

1286
00:46:04,400 --> 00:46:07,359
verify on failure so just to be clear

1287
00:46:07,359 --> 00:46:09,440
the data the thing that we verify is

1288
00:46:09,440 --> 00:46:12,079
whether a single set of input shares is

1289
00:46:12,079 --> 00:46:15,280
valid basically it some if we aggregated

1290
00:46:15,280 --> 00:46:17,760
it would it corrupt the computation so

1291
00:46:17,760 --> 00:46:19,200
the the thing that's proved only

1292
00:46:19,200 --> 00:46:21,440
pertains to one input if that makes

1293
00:46:21,440 --> 00:46:23,440
sense

1294
00:46:23,440 --> 00:46:24,960
right but the question is have you

1295
00:46:24,960 --> 00:46:27,119
thought about uh aggregating everything

1296
00:46:27,119 --> 00:46:30,240
seeing if the if the batch overall is

1297
00:46:30,240 --> 00:46:31,839
correct and then identifying the the

1298
00:46:31,839 --> 00:46:33,040
cheating oh

1299
00:46:33,040 --> 00:46:34,880
yeah um

1300
00:46:34,880 --> 00:46:36,800
yeah i mean uh

1301
00:46:36,800 --> 00:46:38,480
yeah there's that's a whole that's a

1302
00:46:38,480 --> 00:46:40,319
whole bag of worms and i'd like to talk

1303
00:46:40,319 --> 00:46:42,400
to you about it in detail if you if you

1304
00:46:42,400 --> 00:46:45,040
don't mind later

1305
00:46:45,119 --> 00:46:46,960
okay thank you for that question

1306
00:46:46,960 --> 00:46:49,280
um let me ask one more slightly

1307
00:46:49,280 --> 00:46:51,760
provocative um we saw in the previous

1308
00:46:51,760 --> 00:46:53,520
talk that cryptography in the end was a

1309
00:46:53,520 --> 00:46:55,760
very small component of the overall

1310
00:46:55,760 --> 00:46:57,119
functioning system there were so many

1311
00:46:57,119 --> 00:46:58,960
other pieces required

1312
00:46:58,960 --> 00:47:00,319
and to build something that was actually

1313
00:47:00,319 --> 00:47:02,400
useful why do you think a standard in

1314
00:47:02,400 --> 00:47:04,720
this space is going to help

1315
00:47:04,720 --> 00:47:07,439
yeah i mean

1316
00:47:07,920 --> 00:47:09,359
so i think

1317
00:47:09,359 --> 00:47:11,920
i think that there are

1318
00:47:11,920 --> 00:47:12,880
um

1319
00:47:12,880 --> 00:47:14,720
one thing is that i think one of my

1320
00:47:14,720 --> 00:47:16,640
takeaways from the previous talk and

1321
00:47:16,640 --> 00:47:19,280
basically conversations with tim is that

1322
00:47:19,280 --> 00:47:21,680
it's useful to abstract away the cloud

1323
00:47:21,680 --> 00:47:24,319
primitives um and it's useful to build a

1324
00:47:24,319 --> 00:47:26,000
protocol that's sort of agnostic to

1325
00:47:26,000 --> 00:47:27,040
those

1326
00:47:27,040 --> 00:47:28,640
because you don't want to have to just

1327
00:47:28,640 --> 00:47:31,440
rely on gcp or just rely on aws or just

1328
00:47:31,440 --> 00:47:34,160
rely on cloudflare

1329
00:47:34,160 --> 00:47:36,800
and another thing is that

1330
00:47:36,800 --> 00:47:37,760
we

1331
00:47:37,760 --> 00:47:40,240
there's this problem of like

1332
00:47:40,240 --> 00:47:42,960
the the solution is often specific to

1333
00:47:42,960 --> 00:47:44,880
the problem and we need to make room for

1334
00:47:44,880 --> 00:47:47,119
that so i do think it's helpful

1335
00:47:47,119 --> 00:47:49,599
uh that there there be a standard this

1336
00:47:49,599 --> 00:47:51,440
is what the vdf spec is supposed to

1337
00:47:51,440 --> 00:47:53,440
fulfill there should be a standard that

1338
00:47:53,440 --> 00:47:55,680
says this is the shape of the solution

1339
00:47:55,680 --> 00:47:58,000
for those who want to you know go work

1340
00:47:58,000 --> 00:48:01,920
on on this problem that you know yeah

1341
00:48:01,920 --> 00:48:04,240
okay thank you very much

1342
00:48:04,240 --> 00:48:08,078
let's thank the speaker again very good

1343
00:48:13,680 --> 00:48:15,200
and we'll move on now to the third talk

1344
00:48:15,200 --> 00:48:18,240
in the session uh which is a remote talk

1345
00:48:18,240 --> 00:48:20,720
so i think if we can

1346
00:48:20,720 --> 00:48:22,000
get some help from the back of the room

1347
00:48:22,000 --> 00:48:23,920
hopefully we can get some av up and

1348
00:48:23,920 --> 00:48:25,119
running

1349
00:48:25,119 --> 00:48:26,880
so this talk is about oblivious message

1350
00:48:26,880 --> 00:48:29,359
retrieval and uh the speaker is aaron

1351
00:48:29,359 --> 00:48:33,558
tromer who should be online

1352
00:48:39,440 --> 00:48:41,200
do start thinking about your questions

1353
00:48:41,200 --> 00:48:43,359
for the ama session if we can't find

1354
00:48:43,359 --> 00:48:45,440
iran it might be short starting sooner

1355
00:48:45,440 --> 00:48:49,160
than planned

1356
00:49:10,000 --> 00:49:11,599
if someone from the av team could give

1357
00:49:11,599 --> 00:49:13,359
me a wave to indicate that they're

1358
00:49:13,359 --> 00:49:14,880
working on this that would be tremendous

1359
00:49:14,880 --> 00:49:17,839
okay thanks

1360
00:49:18,640 --> 00:49:22,680
here we go here's the slides

1361
00:49:25,270 --> 00:49:30,880
[Music]

1362
00:49:30,880 --> 00:49:34,079
hello am i visible in audible

1363
00:49:34,079 --> 00:49:36,400
uh hello erin um you're not visible yet

1364
00:49:36,400 --> 00:49:38,319
but you're certainly audible

1365
00:49:38,319 --> 00:49:40,800
i'm curious

1366
00:49:40,800 --> 00:49:44,559
i do believe my video is on ah we can

1367
00:49:44,559 --> 00:49:46,720
see

1368
00:49:47,119 --> 00:49:48,640
a little black box at the top of the

1369
00:49:48,640 --> 00:49:51,598
screen i don't know if that's

1370
00:49:51,760 --> 00:49:53,839
the little black box is most likely the

1371
00:49:53,839 --> 00:49:55,760
zoom controls um if you don't have

1372
00:49:55,760 --> 00:49:58,000
anything at the top of your slides it

1373
00:49:58,000 --> 00:50:00,160
should not be an issue

1374
00:50:00,160 --> 00:50:02,800
oh but it's no longer

1375
00:50:02,800 --> 00:50:05,040
okay here he is aaron take it away thank

1376
00:50:05,040 --> 00:50:06,240
you very much

1377
00:50:06,240 --> 00:50:09,280
thank you uh it's uh it's an honor to be

1378
00:50:09,280 --> 00:50:13,440
here both for me and for my antibodies

1379
00:50:13,440 --> 00:50:15,920
and i i'm delighted to be able to tell

1380
00:50:15,920 --> 00:50:17,599
you about the current work that i'm

1381
00:50:17,599 --> 00:50:19,200
doing with my student at columbia

1382
00:50:19,200 --> 00:50:22,000
university zarya neo

1383
00:50:22,000 --> 00:50:25,119
about oblivious message retrieval

1384
00:50:25,119 --> 00:50:26,960
so our work is motivated by the problem

1385
00:50:26,960 --> 00:50:29,440
of anonymous message delivery systems

1386
00:50:29,440 --> 00:50:30,400
like

1387
00:50:30,400 --> 00:50:33,920
a signal and what's up for messages or

1388
00:50:33,920 --> 00:50:36,000
monero and zcash for

1389
00:50:36,000 --> 00:50:37,359
payments

1390
00:50:37,359 --> 00:50:38,960
and more generally systems that try to

1391
00:50:38,960 --> 00:50:40,880
convey some kind of payload for

1392
00:50:40,880 --> 00:50:43,760
recipients to from centers to recipients

1393
00:50:43,760 --> 00:50:45,920
in a privacy-preserving way

1394
00:50:45,920 --> 00:50:48,079
now this is a large well-studied problem

1395
00:50:48,079 --> 00:50:50,480
and it has many facets

1396
00:50:50,480 --> 00:50:53,119
in particular numerous works on

1397
00:50:53,119 --> 00:50:54,960
sending privacy

1398
00:50:54,960 --> 00:50:57,440
how to hide the identity of the standing

1399
00:50:57,440 --> 00:50:58,960
party

1400
00:50:58,960 --> 00:51:01,839
that includes both the content and the

1401
00:51:01,839 --> 00:51:03,440
machinery by which the message is

1402
00:51:03,440 --> 00:51:07,200
appended to some kind of joint ledger

1403
00:51:07,200 --> 00:51:09,280
uh there also works on how to keep the

1404
00:51:09,280 --> 00:51:10,960
ledger itself private and avoiding the

1405
00:51:10,960 --> 00:51:12,720
broadcast of information

1406
00:51:12,720 --> 00:51:15,920
um and uh there are systems like apple

1407
00:51:15,920 --> 00:51:18,800
horn that combine these and show how to

1408
00:51:18,800 --> 00:51:20,240
route messages

1409
00:51:20,240 --> 00:51:21,200
uh

1410
00:51:21,200 --> 00:51:23,280
after a secure connection establishment

1411
00:51:23,280 --> 00:51:24,720
or dialing

1412
00:51:24,720 --> 00:51:26,240
but all of these culminate in a

1413
00:51:26,240 --> 00:51:27,680
situation where you have a large

1414
00:51:27,680 --> 00:51:29,280
bulletin containing all of those

1415
00:51:29,280 --> 00:51:31,680
encrypted messages was route to the

1416
00:51:31,680 --> 00:51:33,920
bulletin was hidden and now the

1417
00:51:33,920 --> 00:51:36,319
recipients need to collect those and the

1418
00:51:36,319 --> 00:51:38,079
question remains how can the recipients

1419
00:51:38,079 --> 00:51:40,880
collect that information without

1420
00:51:40,880 --> 00:51:43,839
leaking what they are retrieving

1421
00:51:43,839 --> 00:51:45,359
so the simplest solution is for the

1422
00:51:45,359 --> 00:51:47,280
recipient to just download the whole

1423
00:51:47,280 --> 00:51:48,400
bulletin

1424
00:51:48,400 --> 00:51:50,640
maybe scan the whole blockchain as is

1425
00:51:50,640 --> 00:51:53,119
customary in some legacy chains and uh

1426
00:51:53,119 --> 00:51:55,440
that is obviously too expensive in

1427
00:51:55,440 --> 00:51:57,440
bandwidth and also in computation

1428
00:51:57,440 --> 00:51:59,440
especially for limited clients and large

1429
00:51:59,440 --> 00:52:01,200
bulletins

1430
00:52:01,200 --> 00:52:02,800
so it seems inevitable that we would

1431
00:52:02,800 --> 00:52:05,119
have a model where there is some kind of

1432
00:52:05,119 --> 00:52:07,839
server let's call it a detector that

1433
00:52:07,839 --> 00:52:10,559
fetches messages from the bulletin

1434
00:52:10,559 --> 00:52:13,599
and somehow produces a digest of those

1435
00:52:13,599 --> 00:52:15,520
messages that are pertinent to the

1436
00:52:15,520 --> 00:52:18,000
recipient or the digest is much much

1437
00:52:18,000 --> 00:52:20,559
smaller than the full bulletin and

1438
00:52:20,559 --> 00:52:24,400
easier to uh to process

1439
00:52:24,640 --> 00:52:26,960
there are several recent works that

1440
00:52:26,960 --> 00:52:30,240
tackle this in concrete applications um

1441
00:52:30,240 --> 00:52:33,200
one widely deployed is the zcash

1442
00:52:33,200 --> 00:52:35,760
lite client protocol that

1443
00:52:35,760 --> 00:52:38,160
basically compresses the full bulletin

1444
00:52:38,160 --> 00:52:39,839
into just the pertinent part of its

1445
00:52:39,839 --> 00:52:42,000
speech transaction for

1446
00:52:42,000 --> 00:52:44,400
what amounts to a trial decryption

1447
00:52:44,400 --> 00:52:47,040
um however that is still linear in the

1448
00:52:47,040 --> 00:52:48,559
size of the bulletin and therefore does

1449
00:52:48,559 --> 00:52:50,880
not scale well and there are there is

1450
00:52:50,880 --> 00:52:53,920
analysis in the z cash community of how

1451
00:52:53,920 --> 00:52:57,520
expensive and impractical this is

1452
00:52:57,520 --> 00:53:00,000
there is a recent work that tackled this

1453
00:53:00,000 --> 00:53:02,000
problem heads on called fuzzy message

1454
00:53:02,000 --> 00:53:03,359
detection

1455
00:53:03,359 --> 00:53:06,240
and that css 21 paper

1456
00:53:06,240 --> 00:53:08,720
after defining the problem uh suggests a

1457
00:53:08,720 --> 00:53:11,040
solution based on decoys basically

1458
00:53:11,040 --> 00:53:12,559
inducing

1459
00:53:12,559 --> 00:53:14,319
a false positives in the trial

1460
00:53:14,319 --> 00:53:16,160
decryption intentionally

1461
00:53:16,160 --> 00:53:18,960
in order for many of the messages that

1462
00:53:18,960 --> 00:53:19,680
are

1463
00:53:19,680 --> 00:53:22,400
detected by the detector

1464
00:53:22,400 --> 00:53:24,400
using the trial decryption done on

1465
00:53:24,400 --> 00:53:26,880
behalf of the recipient making many of

1466
00:53:26,880 --> 00:53:28,559
those be messages that are not truly

1467
00:53:28,559 --> 00:53:29,680
pertinent

1468
00:53:29,680 --> 00:53:31,520
so the detector knows what are the

1469
00:53:31,520 --> 00:53:34,240
messages um that are pertinent to the

1470
00:53:34,240 --> 00:53:36,079
recipient plus a bunch of decoys and

1471
00:53:36,079 --> 00:53:38,319
that provides some level of privacy

1472
00:53:38,319 --> 00:53:40,319
but not very strong privacy because for

1473
00:53:40,319 --> 00:53:42,880
example anything that is not

1474
00:53:42,880 --> 00:53:44,960
detected by the detector is

1475
00:53:44,960 --> 00:53:46,800
automatically ruled out as a pertinent

1476
00:53:46,800 --> 00:53:48,640
message and that by itself already

1477
00:53:48,640 --> 00:53:50,960
allows for fairly devastating active

1478
00:53:50,960 --> 00:53:52,480
attacks

1479
00:53:52,480 --> 00:53:55,200
as well as statistical deductions

1480
00:53:55,200 --> 00:53:58,319
um furthermore this scheme is uh

1481
00:53:58,319 --> 00:54:00,240
implicitly assuming that the

1482
00:54:00,240 --> 00:54:01,839
the senders and the recipients are

1483
00:54:01,839 --> 00:54:04,240
honest in how they generate their keys

1484
00:54:04,240 --> 00:54:05,040
so

1485
00:54:05,040 --> 00:54:08,559
uh the security notion is weak

1486
00:54:08,559 --> 00:54:10,880
furthermore uh another

1487
00:54:10,880 --> 00:54:13,200
recent work uh private signaling

1488
00:54:13,200 --> 00:54:15,760
tackles a similar problem in a slightly

1489
00:54:15,760 --> 00:54:18,960
different model but the differences are

1490
00:54:18,960 --> 00:54:21,280
insignificant in our context

1491
00:54:21,280 --> 00:54:23,599
and we suggest two different schemes

1492
00:54:23,599 --> 00:54:25,680
one is based on

1493
00:54:25,680 --> 00:54:27,839
trusted hardware so the first private

1494
00:54:27,839 --> 00:54:30,800
signaling scheme has a trusted sgx

1495
00:54:30,800 --> 00:54:32,720
enclave run by server

1496
00:54:32,720 --> 00:54:35,359
that is entrusted with users effectively

1497
00:54:35,359 --> 00:54:36,960
trial decryption keys

1498
00:54:36,960 --> 00:54:38,880
and uh

1499
00:54:38,880 --> 00:54:41,760
the as the security model is as you

1500
00:54:41,760 --> 00:54:43,839
would expect from transmit hardware in

1501
00:54:43,839 --> 00:54:46,799
the uh break once

1502
00:54:46,799 --> 00:54:49,839
violate everyone's privacy model

1503
00:54:49,839 --> 00:54:51,839
furthermore it also assumes other

1504
00:54:51,839 --> 00:54:53,839
centers and recipients

1505
00:54:53,839 --> 00:54:55,839
and lastly the other private signaling

1506
00:54:55,839 --> 00:54:57,760
scheme from the same paper

1507
00:54:57,760 --> 00:54:59,520
replaces the sjx enclave by a

1508
00:54:59,520 --> 00:55:01,599
multi-party computation

1509
00:55:01,599 --> 00:55:03,920
which avoids the trust in hard work but

1510
00:55:03,920 --> 00:55:06,640
it does assume that the participants in

1511
00:55:06,640 --> 00:55:09,119
that multi-party detector even though

1512
00:55:09,119 --> 00:55:11,200
they are ongoing in ongoing

1513
00:55:11,200 --> 00:55:13,760
communication they never collude at

1514
00:55:13,760 --> 00:55:16,000
least one of them is not merely honest

1515
00:55:16,000 --> 00:55:17,839
but curious but actually never leaks

1516
00:55:17,839 --> 00:55:18,720
anything

1517
00:55:18,720 --> 00:55:21,119
and that again is a strong assumption uh

1518
00:55:21,119 --> 00:55:23,760
and furthermore uh there is uh the

1519
00:55:23,760 --> 00:55:25,359
assumption that unders

1520
00:55:25,359 --> 00:55:26,960
the recipient

1521
00:55:26,960 --> 00:55:29,839
of honest recipients and senders

1522
00:55:29,839 --> 00:55:32,960
so what we aim to do is to improve the

1523
00:55:32,960 --> 00:55:35,839
efficiency and the privacy properties

1524
00:55:35,839 --> 00:55:37,599
and achieve an oblivious message

1525
00:55:37,599 --> 00:55:39,119
retrieval scheme

1526
00:55:39,119 --> 00:55:40,960
that is fully private

1527
00:55:40,960 --> 00:55:43,599
achieves strong security notions and the

1528
00:55:43,599 --> 00:55:45,280
way we achieve it is using fully

1529
00:55:45,280 --> 00:55:47,920
homomorphic encryption which you might

1530
00:55:47,920 --> 00:55:49,839
think would be completely impractical

1531
00:55:49,839 --> 00:55:52,400
but it turns out that by using carefully

1532
00:55:52,400 --> 00:55:54,640
customized optimizations for this

1533
00:55:54,640 --> 00:55:57,280
specific application scenario uh we can

1534
00:55:57,280 --> 00:55:59,920
achieve a low cost in fact by some

1535
00:55:59,920 --> 00:56:01,839
measures lower than any of the prior

1536
00:56:01,839 --> 00:56:03,040
solutions

1537
00:56:03,040 --> 00:56:04,960
and concrete costs that are quite

1538
00:56:04,960 --> 00:56:07,040
practical even for bitcoin scale private

1539
00:56:07,040 --> 00:56:09,040
messaging

1540
00:56:09,040 --> 00:56:11,040
in the limited time of this talk i will

1541
00:56:11,040 --> 00:56:13,839
try to convey some intuitions about

1542
00:56:13,839 --> 00:56:15,280
how this works

1543
00:56:15,280 --> 00:56:16,880
what we've learned and

1544
00:56:16,880 --> 00:56:19,119
how its case

1545
00:56:19,119 --> 00:56:21,520
let's start with defining uh the system

1546
00:56:21,520 --> 00:56:22,400
model

1547
00:56:22,400 --> 00:56:24,319
just to be on the same page so we have

1548
00:56:24,319 --> 00:56:26,559
the senders we have the recipients we

1549
00:56:26,559 --> 00:56:27,680
have the bulletin and we have the

1550
00:56:27,680 --> 00:56:29,200
detection server

1551
00:56:29,200 --> 00:56:31,599
in our model the recipients will

1552
00:56:31,599 --> 00:56:33,520
create some secret keys

1553
00:56:33,520 --> 00:56:34,640
and

1554
00:56:34,640 --> 00:56:36,720
those would consist of a clue key to be

1555
00:56:36,720 --> 00:56:38,640
shared with all potential senders it's

1556
00:56:38,640 --> 00:56:41,200
effectively part of their public address

1557
00:56:41,200 --> 00:56:43,040
as well as a detection key that they

1558
00:56:43,040 --> 00:56:45,839
will be sharing with the server

1559
00:56:45,839 --> 00:56:47,839
the senders will be using those clue

1560
00:56:47,839 --> 00:56:50,400
keys in order to create uh clues for

1561
00:56:50,400 --> 00:56:51,920
every payload

1562
00:56:51,920 --> 00:56:55,040
uh those are accumulated in the bulletin

1563
00:56:55,040 --> 00:56:56,079
and

1564
00:56:56,079 --> 00:56:59,440
the server fetches the uh sorry the

1565
00:56:59,440 --> 00:57:01,119
server having received the detection key

1566
00:57:01,119 --> 00:57:03,040
from the recipient

1567
00:57:03,040 --> 00:57:04,400
can uh

1568
00:57:04,400 --> 00:57:07,200
fetch all of the bulletin payloads and

1569
00:57:07,200 --> 00:57:10,480
uh close and uh

1570
00:57:10,480 --> 00:57:13,119
digest them on behalf of the recipe and

1571
00:57:13,119 --> 00:57:15,200
into some accumulated digest that

1572
00:57:15,200 --> 00:57:16,960
eventually the recipient would be able

1573
00:57:16,960 --> 00:57:19,520
to decrypt

1574
00:57:20,160 --> 00:57:22,720
um the results of that whole process is

1575
00:57:22,720 --> 00:57:25,440
the plaintext payloads for example

1576
00:57:25,440 --> 00:57:27,520
signal messages or z cache transactions

1577
00:57:27,520 --> 00:57:29,520
which the recipient can then act on in

1578
00:57:29,520 --> 00:57:32,319
an application specific way

1579
00:57:32,319 --> 00:57:35,119
the properties we desire we desire are

1580
00:57:35,119 --> 00:57:36,400
the following

1581
00:57:36,400 --> 00:57:39,119
on the functionality side uh we want uh

1582
00:57:39,119 --> 00:57:41,839
the uh oblivious message retrieval

1583
00:57:41,839 --> 00:57:43,440
functionality where we get the actual

1584
00:57:43,440 --> 00:57:44,559
payloads

1585
00:57:44,559 --> 00:57:46,480
it's also useful to have the weaker

1586
00:57:46,480 --> 00:57:48,160
functionality of oblivious message

1587
00:57:48,160 --> 00:57:49,839
detection which was the one actually

1588
00:57:49,839 --> 00:57:51,760
achieved by some fireworks where you

1589
00:57:51,760 --> 00:57:53,440
only learn the indices of the pertinent

1590
00:57:53,440 --> 00:57:55,520
messages and maybe fetch them by some

1591
00:57:55,520 --> 00:57:57,520
other means that is useful for some

1592
00:57:57,520 --> 00:58:00,319
protocol compositions

1593
00:58:00,319 --> 00:58:01,280
and

1594
00:58:01,280 --> 00:58:03,440
in terms of

1595
00:58:03,440 --> 00:58:04,480
the goals

1596
00:58:04,480 --> 00:58:06,079
we want to

1597
00:58:06,079 --> 00:58:07,760
leak nothing to the detector anywhere

1598
00:58:07,760 --> 00:58:10,240
else in the system about which messages

1599
00:58:10,240 --> 00:58:12,400
are pertinent and which aren't and in

1600
00:58:12,400 --> 00:58:14,400
fact we don't even want to reveal who is

1601
00:58:14,400 --> 00:58:16,799
doing the retrieval

1602
00:58:16,799 --> 00:58:18,880
on their performance size we want the

1603
00:58:18,880 --> 00:58:20,640
digest size to be much smaller than the

1604
00:58:20,640 --> 00:58:22,640
bullet size and also much easier to

1605
00:58:22,640 --> 00:58:26,240
process ideally we want both size and

1606
00:58:26,240 --> 00:58:28,240
processing to be proportional to the

1607
00:58:28,240 --> 00:58:30,160
number of pertinent messages addressed

1608
00:58:30,160 --> 00:58:32,319
to the recipient rather than the much

1609
00:58:32,319 --> 00:58:35,960
larger total bulletin

1610
00:58:36,000 --> 00:58:36,799
so

1611
00:58:36,799 --> 00:58:39,599
our starting point um and our sort of

1612
00:58:39,599 --> 00:58:42,079
proof of theoretical feasibility uses

1613
00:58:42,079 --> 00:58:44,000
fully homomorphic encryption

1614
00:58:44,000 --> 00:58:45,119
let's start

1615
00:58:45,119 --> 00:58:48,480
with this uh strowman solution and uh

1616
00:58:48,480 --> 00:58:50,880
a lot of the actual engineering work uh

1617
00:58:50,880 --> 00:58:53,119
is making it practical

1618
00:58:53,119 --> 00:58:55,440
but at high level uh the idea is pretty

1619
00:58:55,440 --> 00:58:57,680
straightforward using the the

1620
00:58:57,680 --> 00:58:59,280
the full power of full homomorphic

1621
00:58:59,280 --> 00:59:00,400
encryption

1622
00:59:00,400 --> 00:59:02,720
we can uh they have the recipient

1623
00:59:02,720 --> 00:59:05,599
generate generate fhe keeper

1624
00:59:05,599 --> 00:59:06,960
and then

1625
00:59:06,960 --> 00:59:09,359
share that with the senders the centers

1626
00:59:09,359 --> 00:59:11,760
would encrypt a bunch of ones

1627
00:59:11,760 --> 00:59:14,480
to the cloaky of the recipients

1628
00:59:14,480 --> 00:59:17,760
and then the detector would uh for every

1629
00:59:17,760 --> 00:59:20,720
such uh clue simply try to decrypt all

1630
00:59:20,720 --> 00:59:22,720
of them homomorphically under the

1631
00:59:22,720 --> 00:59:25,119
recipient secretly encrypted

1632
00:59:25,119 --> 00:59:27,040
under the fha

1633
00:59:27,040 --> 00:59:29,440
and then compute the end function

1634
00:59:29,440 --> 00:59:32,799
if all the payloads were indeed uh

1635
00:59:32,799 --> 00:59:34,240
sorry for a payload that is indeed

1636
00:59:34,240 --> 00:59:35,760
associated with the clue that contains

1637
00:59:35,760 --> 00:59:37,440
just encryption of ones the result of

1638
00:59:37,440 --> 00:59:39,839
the end would be one the decrypt

1639
00:59:39,839 --> 00:59:41,599
the decryption of that by the recipient

1640
00:59:41,599 --> 00:59:43,280
would be one that is detected as

1641
00:59:43,280 --> 00:59:44,400
pertinent

1642
00:59:44,400 --> 00:59:46,799
for any other clue

1643
00:59:46,799 --> 00:59:48,160
under suitable assumptions that

1644
00:59:48,160 --> 00:59:50,160
decryption is likely to be zero because

1645
00:59:50,160 --> 00:59:52,000
at least one of these ciphertexts would

1646
00:59:52,000 --> 00:59:54,720
be decrypted randomly into a zero and

1647
00:59:54,720 --> 00:59:57,839
that would be detected as non-pertinent

1648
00:59:57,839 --> 00:59:58,880
beautiful

1649
00:59:58,880 --> 01:00:00,880
it actually all works out

1650
01:00:00,880 --> 01:00:02,640
except that it is

1651
01:00:02,640 --> 01:00:05,680
completely impractical

1652
01:00:06,799 --> 01:00:07,680
so

1653
01:00:07,680 --> 01:00:08,559
uh

1654
01:00:08,559 --> 01:00:13,000
oh my gosh excuse me for a second

1655
01:00:20,799 --> 01:00:23,040
okay strangely enough are you missing a

1656
01:00:23,040 --> 01:00:26,480
slide lovely hand-wave

1657
01:00:26,640 --> 01:00:29,640
um

1658
01:00:31,119 --> 01:00:33,440
okay so the um

1659
01:00:33,440 --> 01:00:34,319
the

1660
01:00:34,319 --> 01:00:35,599
the problem with the previous approach

1661
01:00:35,599 --> 01:00:37,839
is that the pertinency vector that we

1662
01:00:37,839 --> 01:00:38,960
created

1663
01:00:38,960 --> 01:00:41,200
was linear in the number of the whole

1664
01:00:41,200 --> 01:00:44,079
bulletin and we can compress that using

1665
01:00:44,079 --> 01:00:46,400
this technique inspired by private

1666
01:00:46,400 --> 01:00:49,040
stream search where we have a bunch of a

1667
01:00:49,040 --> 01:00:51,040
ciphertext serving as accumulators and

1668
01:00:51,040 --> 01:00:52,400
counters

1669
01:00:52,400 --> 01:00:55,200
and we add linear combinations

1670
01:00:55,200 --> 01:00:57,280
to these in a randomized fashion

1671
01:00:57,280 --> 01:00:59,680
concretely we take the pertinent vector

1672
01:00:59,680 --> 01:01:02,319
on the left and we multiply it by the

1673
01:01:02,319 --> 01:01:05,680
indices in order to get a vector that is

1674
01:01:05,680 --> 01:01:07,839
zero for impertinent messages and

1675
01:01:07,839 --> 01:01:10,559
contains the index for pertinent ones

1676
01:01:10,559 --> 01:01:13,680
and then we add each such entry into a

1677
01:01:13,680 --> 01:01:16,640
random counter and accumulator

1678
01:01:16,640 --> 01:01:18,799
so we increment the accumulator by the

1679
01:01:18,799 --> 01:01:21,359
value and the counter by one

1680
01:01:21,359 --> 01:01:23,200
consequentially as long as there are no

1681
01:01:23,200 --> 01:01:26,079
collisions the decryption by the

1682
01:01:26,079 --> 01:01:27,440
recipient can just decrypt they

1683
01:01:27,440 --> 01:01:29,599
accumulate the accumulators and bring

1684
01:01:29,599 --> 01:01:30,799
out the indices and that yields

1685
01:01:30,799 --> 01:01:32,720
detection

1686
01:01:32,720 --> 01:01:34,319
if there are any collisions that these

1687
01:01:34,319 --> 01:01:36,559
counters larger than one then that would

1688
01:01:36,559 --> 01:01:38,079
be detected as well and we can cope with

1689
01:01:38,079 --> 01:01:41,599
that by a variety of techniques

1690
01:01:41,760 --> 01:01:45,359
um finally in order to

1691
01:01:45,359 --> 01:01:48,640
achieve retrieval we need to also handle

1692
01:01:48,640 --> 01:01:50,559
the payloads and we do that by general

1693
01:01:50,559 --> 01:01:52,400
generalization of the previous technique

1694
01:01:52,400 --> 01:01:53,839
this time we take the payloads and

1695
01:01:53,839 --> 01:01:56,640
multiply them by the front lens vector

1696
01:01:56,640 --> 01:01:58,799
and then we accumulate that using a big

1697
01:01:58,799 --> 01:01:59,920
matrix

1698
01:01:59,920 --> 01:02:01,599
and

1699
01:02:01,599 --> 01:02:03,359
we get ciphertext which are linear

1700
01:02:03,359 --> 01:02:06,559
combinations of the pertinent payloads

1701
01:02:06,559 --> 01:02:07,359
and

1702
01:02:07,359 --> 01:02:09,440
if we use a suitable sparse linear

1703
01:02:09,440 --> 01:02:12,319
random code to generate a matrix then we

1704
01:02:12,319 --> 01:02:15,599
have the property that even for a very

1705
01:02:15,599 --> 01:02:17,440
small digest proportional to the number

1706
01:02:17,440 --> 01:02:18,160
of

1707
01:02:18,160 --> 01:02:19,760
pertinent messages or at least quite

1708
01:02:19,760 --> 01:02:22,000
linear in it

1709
01:02:22,000 --> 01:02:23,680
the

1710
01:02:23,680 --> 01:02:25,520
the resulting message can be it can be

1711
01:02:25,520 --> 01:02:27,359
decrypted

1712
01:02:27,359 --> 01:02:28,720
and there are a lot more details in the

1713
01:02:28,720 --> 01:02:31,759
paper that i'm skipping

1714
01:02:32,079 --> 01:02:34,319
so we achieve a scheme that uh

1715
01:02:34,319 --> 01:02:36,160
based on generic fhe gives us a

1716
01:02:36,160 --> 01:02:38,480
functionality and it is asymptotically

1717
01:02:38,480 --> 01:02:40,720
efficient and succinct but of course the

1718
01:02:40,720 --> 01:02:43,359
asymptotics have a high huge constants

1719
01:02:43,359 --> 01:02:45,119
using generic fh

1720
01:02:45,119 --> 01:02:46,480
and uh

1721
01:02:46,480 --> 01:02:48,480
even the state of the art of generic fha

1722
01:02:48,480 --> 01:02:50,240
it would still take

1723
01:02:50,240 --> 01:02:52,240
kilobytes just to represent the

1724
01:02:52,240 --> 01:02:54,240
ciphertext and

1725
01:02:54,240 --> 01:02:56,799
a milliseconds for every end gate so not

1726
01:02:56,799 --> 01:02:59,119
practical by itself

1727
01:02:59,119 --> 01:03:01,280
the key optimization to really make this

1728
01:03:01,280 --> 01:03:03,440
practical is to use a bespoke

1729
01:03:03,440 --> 01:03:05,039
combination of carefully tailored

1730
01:03:05,039 --> 01:03:06,400
encryption schemes

1731
01:03:06,400 --> 01:03:08,960
and specifically the pvw encryption

1732
01:03:08,960 --> 01:03:11,039
scheme based

1733
01:03:11,039 --> 01:03:14,559
on a similar assumptions the lwe to uh

1734
01:03:14,559 --> 01:03:15,920
the full-blown full homomorphic

1735
01:03:15,920 --> 01:03:17,520
encryptions but it's much more

1736
01:03:17,520 --> 01:03:20,319
lightweight in ciphertex size and in its

1737
01:03:20,319 --> 01:03:22,160
uh decryption uh

1738
01:03:22,160 --> 01:03:24,160
when done homomorphically

1739
01:03:24,160 --> 01:03:27,359
so it so happens that uh the inner

1740
01:03:27,359 --> 01:03:29,760
product that dominates the cost of pvw

1741
01:03:29,760 --> 01:03:31,200
decryption

1742
01:03:31,200 --> 01:03:34,000
um it's simply taking the the ciphertext

1743
01:03:34,000 --> 01:03:35,520
and computing its inner product with a

1744
01:03:35,520 --> 01:03:37,359
secret key

1745
01:03:37,359 --> 01:03:39,119
can be plugged into a different fully

1746
01:03:39,119 --> 01:03:42,000
homomorphic schemes say the bfv scheme

1747
01:03:42,000 --> 01:03:45,440
and be executed as a simple the

1748
01:03:45,440 --> 01:03:48,079
circuit of multiplicative depth one

1749
01:03:48,079 --> 01:03:50,559
and the rest of the decryption namely

1750
01:03:50,559 --> 01:03:51,839
range checks can also be done

1751
01:03:51,839 --> 01:03:53,039
efficiently

1752
01:03:53,039 --> 01:03:55,440
and downright this yields a dramatic

1753
01:03:55,440 --> 01:03:58,920
improvement in efficiency

1754
01:03:59,680 --> 01:04:01,520
taken together what we achieve is the

1755
01:04:01,520 --> 01:04:03,280
same system overview that we discussed

1756
01:04:03,280 --> 01:04:06,079
before but uh with

1757
01:04:06,079 --> 01:04:08,079
various encryptions under various

1758
01:04:08,079 --> 01:04:10,319
schemes floating around connected the

1759
01:04:10,319 --> 01:04:12,559
right way and making the best use of the

1760
01:04:12,559 --> 01:04:15,280
properties of each one

1761
01:04:15,280 --> 01:04:16,880
other techniques i will not have time to

1762
01:04:16,880 --> 01:04:19,440
go into is a lot of optimization of the

1763
01:04:19,440 --> 01:04:22,960
way we use the bfv scheme

1764
01:04:22,960 --> 01:04:24,559
and

1765
01:04:24,559 --> 01:04:26,319
combinatorial optimizations for this

1766
01:04:26,319 --> 01:04:29,039
scenario and the trade-offs uh tailoring

1767
01:04:29,039 --> 01:04:29,839
the

1768
01:04:29,839 --> 01:04:31,680
the scheduling of the operations to

1769
01:04:31,680 --> 01:04:34,240
reduce the memory footprint uh reducing

1770
01:04:34,240 --> 01:04:36,480
the key sizes all of this and more in

1771
01:04:36,480 --> 01:04:39,280
our apron paper

1772
01:04:39,599 --> 01:04:41,359
lastly i want to briefly discuss the

1773
01:04:41,359 --> 01:04:43,839
security aspects beside the obvious one

1774
01:04:43,839 --> 01:04:45,920
we've discussed i also alluded to some

1775
01:04:45,920 --> 01:04:47,520
assumptions that previous schemes made

1776
01:04:47,520 --> 01:04:50,160
about honest recipients and cinders and

1777
01:04:50,160 --> 01:04:52,720
this is where that comes in

1778
01:04:52,720 --> 01:04:55,359
in the ideal world uh we just have nice

1779
01:04:55,359 --> 01:04:57,920
senders sending messages and uh they are

1780
01:04:57,920 --> 01:05:00,160
all summarized by detectors on behalf of

1781
01:05:00,160 --> 01:05:02,079
multiple recipients

1782
01:05:02,079 --> 01:05:03,680
however imagine that one of those

1783
01:05:03,680 --> 01:05:05,680
servers is malicious and they inject a

1784
01:05:05,680 --> 01:05:07,280
malicious clue

1785
01:05:07,280 --> 01:05:08,720
into the system

1786
01:05:08,720 --> 01:05:10,799
or maybe they were fooled by a malicious

1787
01:05:10,799 --> 01:05:13,039
recipient to give them a malicious

1788
01:05:13,039 --> 01:05:15,839
cloakie that gen that generates

1789
01:05:15,839 --> 01:05:18,640
malicious clues when used by an honest

1790
01:05:18,640 --> 01:05:19,680
sender

1791
01:05:19,680 --> 01:05:22,000
either way a malicious clue may for all

1792
01:05:22,000 --> 01:05:24,079
we know have the property that once

1793
01:05:24,079 --> 01:05:27,200
injected into the bulletin it infects

1794
01:05:27,200 --> 01:05:28,559
every the

1795
01:05:28,559 --> 01:05:31,039
payload

1796
01:05:31,280 --> 01:05:32,880
sorry it detects it

1797
01:05:32,880 --> 01:05:36,079
it infects every detection process

1798
01:05:36,079 --> 01:05:38,559
such that all the digests are polluted

1799
01:05:38,559 --> 01:05:40,480
with that payload and are basically

1800
01:05:40,480 --> 01:05:41,680
flooded

1801
01:05:41,680 --> 01:05:42,799
with

1802
01:05:42,799 --> 01:05:44,799
arbitrarily many copies of that same

1803
01:05:44,799 --> 01:05:47,039
message causing a denial of service on

1804
01:05:47,039 --> 01:05:48,960
the system and concretely overflow of

1805
01:05:48,960 --> 01:05:50,640
the digests

1806
01:05:50,640 --> 01:05:52,640
uh it turns out that the pyro schemes

1807
01:05:52,640 --> 01:05:54,160
are concretely vulnerable to this this

1808
01:05:54,160 --> 01:05:56,160
was also observed by others and our

1809
01:05:56,160 --> 01:06:00,240
scheme uh explicitly mitigates that

1810
01:06:00,240 --> 01:06:03,200
another issue that prior schemes had is

1811
01:06:03,200 --> 01:06:05,280
an issue of killing ability because even

1812
01:06:05,280 --> 01:06:07,359
if looking at an individual message some

1813
01:06:07,359 --> 01:06:09,680
privacy guarantees are given looking at

1814
01:06:09,680 --> 01:06:11,920
the keys they may be linkable and what

1815
01:06:11,920 --> 01:06:13,760
we want is that the detection key is

1816
01:06:13,760 --> 01:06:15,680
coming from different parties or

1817
01:06:15,680 --> 01:06:18,079
clookies coming from different parties

1818
01:06:18,079 --> 01:06:20,079
or detection includes coming from

1819
01:06:20,079 --> 01:06:21,440
different parties are all

1820
01:06:21,440 --> 01:06:23,119
indistinguishable from the case where

1821
01:06:23,119 --> 01:06:25,200
they came from the same party

1822
01:06:25,200 --> 01:06:27,039
and that means you can create multiple

1823
01:06:27,039 --> 01:06:28,880
keys and give them around use z cash

1824
01:06:28,880 --> 01:06:31,280
diversify addresses have multiple

1825
01:06:31,280 --> 01:06:33,280
detectors serving you all without

1826
01:06:33,280 --> 01:06:34,960
leaking what you're doing in your access

1827
01:06:34,960 --> 01:06:36,799
patterns and this is an additional

1828
01:06:36,799 --> 01:06:38,720
property that we define non-trivially in

1829
01:06:38,720 --> 01:06:41,118
the chip

1830
01:06:42,720 --> 01:06:45,200
performance turns out to be surprisingly

1831
01:06:45,200 --> 01:06:48,160
practical for example for detection the

1832
01:06:48,160 --> 01:06:51,359
digest size is less than a byte per

1833
01:06:51,359 --> 01:06:52,799
message

1834
01:06:52,799 --> 01:06:55,039
the detector's computation

1835
01:06:55,039 --> 01:06:58,319
is about a tenth of a second per message

1836
01:06:58,319 --> 01:07:00,319
the recipient's computation this is all

1837
01:07:00,319 --> 01:07:03,359
for typical parameters uh is uh

1838
01:07:03,359 --> 01:07:05,520
about five milliseconds

1839
01:07:05,520 --> 01:07:06,400
um

1840
01:07:06,400 --> 01:07:10,480
the clue size is less than a kilobyte uh

1841
01:07:10,480 --> 01:07:12,240
the one sticking point is that the

1842
01:07:12,240 --> 01:07:14,400
detection key size uploaded to the

1843
01:07:14,400 --> 01:07:17,520
server for processing is about 100

1844
01:07:17,520 --> 01:07:20,160
megabytes which is awkward but we

1845
01:07:20,160 --> 01:07:23,520
discuss in the paper uh

1846
01:07:23,520 --> 01:07:27,359
the not terrible practicality of this

1847
01:07:27,359 --> 01:07:29,520
uh finally all of this is achieved with

1848
01:07:29,520 --> 01:07:30,640
the

1849
01:07:30,640 --> 01:07:32,880
with the full strongest notion of

1850
01:07:32,880 --> 01:07:35,359
privacy and no assumptions about the

1851
01:07:35,359 --> 01:07:37,680
environment

1852
01:07:37,680 --> 01:07:39,839
likewise for full retrieval uh

1853
01:07:39,839 --> 01:07:41,920
communication for typical parameters

1854
01:07:41,920 --> 01:07:44,559
inspired by zcash and bitcoin is about

1855
01:07:44,559 --> 01:07:47,440
nine bytes per message um

1856
01:07:47,440 --> 01:07:49,359
and um

1857
01:07:49,359 --> 01:07:51,760
the computation is also a deep sub

1858
01:07:51,760 --> 01:07:53,839
millisecond the message process and

1859
01:07:53,839 --> 01:07:56,400
finally the recipients computation is as

1860
01:07:56,400 --> 01:07:58,240
you may notice in fact faster than any

1861
01:07:58,240 --> 01:08:00,160
other scheme including those that rely

1862
01:08:00,160 --> 01:08:02,559
on trusted hardware or make stronger

1863
01:08:02,559 --> 01:08:04,799
assumptions

1864
01:08:04,799 --> 01:08:07,200
um

1865
01:08:07,200 --> 01:08:10,160
sorry i misspoke it no it did not work

1866
01:08:10,160 --> 01:08:12,480
cool uh in terms of scaling uh the

1867
01:08:12,480 --> 01:08:15,599
asymptotics are portrayed here and uh

1868
01:08:15,599 --> 01:08:18,880
um the bottom right parts of every graph

1869
01:08:18,880 --> 01:08:20,479
are basically our schemes so as the

1870
01:08:20,479 --> 01:08:22,640
bulletin size grows our schemes are more

1871
01:08:22,640 --> 01:08:26,080
competitive than any others

1872
01:08:27,198 --> 01:08:30,080
and uh let me conclude with some real

1873
01:08:30,080 --> 01:08:32,479
world considerations um the concrete

1874
01:08:32,479 --> 01:08:34,640
costs in terms of dollars running on the

1875
01:08:34,640 --> 01:08:37,198
cloud expense are less than two dollars

1876
01:08:37,198 --> 01:08:39,520
per million messages scanned

1877
01:08:39,520 --> 01:08:43,520
um the detection costs are a negligible

1878
01:08:43,520 --> 01:08:46,000
for current privacy preserving uh the

1879
01:08:46,000 --> 01:08:47,198
schemes

1880
01:08:47,198 --> 01:08:49,040
and can even be paid for in the

1881
01:08:49,040 --> 01:08:51,120
underlying cryptocurrencies

1882
01:08:51,120 --> 01:08:52,319
there are many integration

1883
01:08:52,319 --> 01:08:53,759
considerations when you look at the

1884
01:08:53,759 --> 01:08:56,000
specific blockchains and uh how you

1885
01:08:56,000 --> 01:08:57,679
would convey the additional information

1886
01:08:57,679 --> 01:08:59,759
these are discussed in the paper but i

1887
01:08:59,759 --> 01:09:01,359
will reveal that

1888
01:09:01,359 --> 01:09:04,880
under gas grant by the z cash foundation

1889
01:09:04,880 --> 01:09:06,719
there is now an ongoing prototype

1890
01:09:06,719 --> 01:09:08,640
implementation showing that all of this

1891
01:09:08,640 --> 01:09:11,040
is workable

1892
01:09:11,040 --> 01:09:15,279
and uh lastly uh while i uh project the

1893
01:09:15,279 --> 01:09:18,080
github url for the the code which is

1894
01:09:18,080 --> 01:09:20,000
rapidly being developed and improved

1895
01:09:20,000 --> 01:09:22,719
i'll mention ongoing work reducing the

1896
01:09:22,719 --> 01:09:24,080
detection cost

1897
01:09:24,080 --> 01:09:27,720
reducing key sizes and communication

1898
01:09:27,720 --> 01:09:29,040
[Music]

1899
01:09:29,040 --> 01:09:31,279
reducing a computational assumption that

1900
01:09:31,279 --> 01:09:32,640
is needed for

1901
01:09:32,640 --> 01:09:34,479
achieving denial of service resistance

1902
01:09:34,479 --> 01:09:36,880
without a performance overhead

1903
01:09:36,880 --> 01:09:37,759
um

1904
01:09:37,759 --> 01:09:40,238
improving the integrity protection

1905
01:09:40,238 --> 01:09:42,399
against malicious detectors privacy is

1906
01:09:42,399 --> 01:09:44,399
already there

1907
01:09:44,399 --> 01:09:46,799
and extending to additional

1908
01:09:46,799 --> 01:09:48,560
functionality like group messaging as

1909
01:09:48,560 --> 01:09:50,080
well as the aforementioned integration

1910
01:09:50,080 --> 01:09:52,560
with concrete systems

1911
01:09:52,560 --> 01:09:54,640
thank you again and i'm

1912
01:09:54,640 --> 01:09:57,190
delighted to take your questions

1913
01:09:57,190 --> 01:10:00,639
[Applause]

1914
01:10:05,840 --> 01:10:07,760
okay uh thank you very much aaron for

1915
01:10:07,760 --> 01:10:09,360
that that talk and thank you for

1916
01:10:09,360 --> 01:10:11,360
fighting through the technology um if

1917
01:10:11,360 --> 01:10:13,040
you want to ask questions of aaron and

1918
01:10:13,040 --> 01:10:14,719
your remote you should use the zulu

1919
01:10:14,719 --> 01:10:17,520
server not the chat feature in zoom i

1920
01:10:17,520 --> 01:10:19,040
saw somebody i think it was dimitri

1921
01:10:19,040 --> 01:10:21,040
posting there dimitri please copy your

1922
01:10:21,040 --> 01:10:23,520
question across to uh to zulip and

1923
01:10:23,520 --> 01:10:25,520
actually we're out of time for questions

1924
01:10:25,520 --> 01:10:27,199
i'm sorry iran you used the full 20

1925
01:10:27,199 --> 01:10:28,400
minutes

1926
01:10:28,400 --> 01:10:30,719
so please join us on zooloop and maybe

1927
01:10:30,719 --> 01:10:32,080
there'll be some questions for you there

1928
01:10:32,080 --> 01:10:33,120
and you'll be able to get some

1929
01:10:33,120 --> 01:10:34,800
interaction going but i think we want to

1930
01:10:34,800 --> 01:10:37,360
move move along and i'll invite to the

1931
01:10:37,360 --> 01:10:39,679
stage now our general chair who's

1932
01:10:39,679 --> 01:10:41,280
carrying a chair this is what a general

1933
01:10:41,280 --> 01:10:43,340
chair does

1934
01:10:43,340 --> 01:10:49,120
[Applause]

1935
01:10:49,120 --> 01:10:51,679
the work the work never stops for peter

1936
01:10:51,679 --> 01:10:53,199
peter you wanted to make an announcement

1937
01:10:53,199 --> 01:10:54,880
of some kind i think

1938
01:10:54,880 --> 01:10:56,159
you'll do that after the third share

1939
01:10:56,159 --> 01:10:58,000
okay so he's building up to an

1940
01:10:58,000 --> 01:11:00,480
announcement

1941
01:11:00,880 --> 01:11:02,400
maybe you can ask people on stage

1942
01:11:02,400 --> 01:11:04,239
already yeah sure so um please welcome

1943
01:11:04,239 --> 01:11:06,880
to the stage our participants in the ama

1944
01:11:06,880 --> 01:11:10,840
uh so we have yuan are you there

1945
01:11:10,840 --> 01:11:15,440
welcome uh and we have yuval yaram

1946
01:11:15,440 --> 01:11:17,120
and last but not least i think we have

1947
01:11:17,120 --> 01:11:18,880
uh kathy if she's there

1948
01:11:18,880 --> 01:11:21,199
great and this is

1949
01:11:21,199 --> 01:11:24,159
maybe the perfect moment for you to clap

1950
01:11:24,159 --> 01:11:27,159
and

1951
01:11:28,450 --> 01:11:30,000
[Music]

1952
01:11:30,000 --> 01:11:31,760
and then for me to make a very short

1953
01:11:31,760 --> 01:11:33,840
announcement so if somebody lost their

1954
01:11:33,840 --> 01:11:36,080
phone uh we have it at the reception

1955
01:11:36,080 --> 01:11:38,560
desk also if somebody who attended the

1956
01:11:38,560 --> 01:11:40,480
hacks workshop before this lost their

1957
01:11:40,480 --> 01:11:44,678
glasses we also have those

