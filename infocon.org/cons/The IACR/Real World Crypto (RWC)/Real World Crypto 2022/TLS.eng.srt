1
00:00:00,160 --> 00:00:02,800
justifying standard

2
00:00:02,800 --> 00:00:05,720
justifying standard parameters in the

3
00:00:05,720 --> 00:00:09,960
tls1.3 handshake

4
00:00:20,640 --> 00:00:23,840
hannah can you hear us

5
00:00:28,640 --> 00:00:30,400
i can hello

6
00:00:30,400 --> 00:00:32,719
hi we can hear you as well

7
00:00:32,719 --> 00:00:34,640
okay can you see my screen

8
00:00:34,640 --> 00:00:38,640
yes we can okay great

9
00:00:40,320 --> 00:00:42,399
hi my name is hannah davis and i'm here

10
00:00:42,399 --> 00:00:44,399
to talk about practical security bounds

11
00:00:44,399 --> 00:00:47,520
for the tls 1.3 handshake protocol and

12
00:00:47,520 --> 00:00:49,280
why it matters to security that the

13
00:00:49,280 --> 00:00:51,520
encoded length of the legacy session id

14
00:00:51,520 --> 00:00:53,600
of a client hello message does not begin

15
00:00:53,600 --> 00:00:56,559
with the bytes 3 6 or 5c

16
00:00:56,559 --> 00:00:58,640
this is based on work by dennis diemer

17
00:00:58,640 --> 00:01:01,440
felix ginther and tibor yager

18
00:01:01,440 --> 00:01:03,520
the tls handshake is a key exchange

19
00:01:03,520 --> 00:01:05,040
protocol that helps two parties

20
00:01:05,040 --> 00:01:07,200
negotiate a secret session key over the

21
00:01:07,200 --> 00:01:10,640
internet the most recent version tls 1.3

22
00:01:10,640 --> 00:01:12,799
is now default for more than half of the

23
00:01:12,799 --> 00:01:15,280
top 1 million servers

24
00:01:15,280 --> 00:01:18,240
most tls 1.3 users including me right

25
00:01:18,240 --> 00:01:20,640
now use the full handshake protocol

26
00:01:20,640 --> 00:01:22,640
which uses public key certificates for

27
00:01:22,640 --> 00:01:24,799
authentication there are also two

28
00:01:24,799 --> 00:01:26,799
pre-shared key modes that use symmetric

29
00:01:26,799 --> 00:01:28,799
key authentication mainly for session

30
00:01:28,799 --> 00:01:31,600
resumption and low power devices

31
00:01:31,600 --> 00:01:35,200
the prior security proof for tls 1.3 by

32
00:01:35,200 --> 00:01:37,759
dowling it all reduces to the security

33
00:01:37,759 --> 00:01:39,600
of its building blocks for the full

34
00:01:39,600 --> 00:01:41,680
handshake these include a diffie-hellman

35
00:01:41,680 --> 00:01:43,840
group a cryptographic hash function and

36
00:01:43,840 --> 00:01:45,759
a digital signature scheme

37
00:01:45,759 --> 00:01:48,159
the tls standard gives several options

38
00:01:48,159 --> 00:01:49,920
for each of these parameters targeting

39
00:01:49,920 --> 00:01:51,759
different levels of efficiency and

40
00:01:51,759 --> 00:01:52,880
security

41
00:01:52,880 --> 00:01:54,960
in this talk we'll measure security in

42
00:01:54,960 --> 00:01:57,439
bits as the ratio of an attacker's run

43
00:01:57,439 --> 00:01:59,280
time to its advantage which is the

44
00:01:59,280 --> 00:02:01,759
probability of successfully breaking the

45
00:02:01,759 --> 00:02:03,360
scheme

46
00:02:03,360 --> 00:02:06,079
so an instance of the tls 1.3 handshake

47
00:02:06,079 --> 00:02:08,720
that prioritizes efficiency might choose

48
00:02:08,720 --> 00:02:11,760
faster components with 128 bit security

49
00:02:11,760 --> 00:02:15,200
like the x25519 elliptic curve a higher

50
00:02:15,200 --> 00:02:17,280
security configuration might instead use

51
00:02:17,280 --> 00:02:18,959
a 192-bit

52
00:02:18,959 --> 00:02:21,440
secure curve like uh

53
00:02:21,440 --> 00:02:23,520
p384

54
00:02:23,520 --> 00:02:25,840
for an arbitrary configuration delling

55
00:02:25,840 --> 00:02:27,920
it all proved this theorem

56
00:02:27,920 --> 00:02:30,000
it says that for any attacker with

57
00:02:30,000 --> 00:02:32,959
limited resources including runtime and

58
00:02:32,959 --> 00:02:35,440
the number of honest sessions and users

59
00:02:35,440 --> 00:02:37,840
that it can see and interact with the

60
00:02:37,840 --> 00:02:40,400
probability of learning anything about

61
00:02:40,400 --> 00:02:43,360
the session key is bounded by the sum of

62
00:02:43,360 --> 00:02:45,120
one term for each underlying

63
00:02:45,120 --> 00:02:47,120
cryptographic primitive and a small

64
00:02:47,120 --> 00:02:48,800
constant term

65
00:02:48,800 --> 00:02:51,680
each term in the bound has two factors

66
00:02:51,680 --> 00:02:53,599
one that bounds the probability of

67
00:02:53,599 --> 00:02:56,319
breaking the underlying primitive

68
00:02:56,319 --> 00:02:58,080
multiplied by a function of the

69
00:02:58,080 --> 00:03:01,120
adversary's resources

70
00:03:01,120 --> 00:03:03,360
because these multipliers are all

71
00:03:03,360 --> 00:03:06,480
polynomials we say that tls 1.3 has

72
00:03:06,480 --> 00:03:09,599
asymptotic security

73
00:03:09,599 --> 00:03:12,879
asymptotic security means in practice

74
00:03:12,879 --> 00:03:14,879
that we can achieve any security level

75
00:03:14,879 --> 00:03:16,959
we desire by using large enough

76
00:03:16,959 --> 00:03:18,800
parameters and scaling them up

77
00:03:18,800 --> 00:03:20,080
appropriately

78
00:03:20,080 --> 00:03:22,879
we can see this in practice by fixing an

79
00:03:22,879 --> 00:03:25,200
adversary a hash function and a

80
00:03:25,200 --> 00:03:27,280
signature scheme and looking at what

81
00:03:27,280 --> 00:03:29,519
happens as we expand the size of the

82
00:03:29,519 --> 00:03:33,640
underlying diffie-hellman group

83
00:03:34,159 --> 00:03:35,840
however

84
00:03:35,840 --> 00:03:38,720
scaling up in practice isn't really a

85
00:03:38,720 --> 00:03:41,920
feasible option because the tls standard

86
00:03:41,920 --> 00:03:44,799
only offers a few choices of group and a

87
00:03:44,799 --> 00:03:46,959
few choices for each parameter

88
00:03:46,959 --> 00:03:49,200
so we're less interested in the slope of

89
00:03:49,200 --> 00:03:52,400
this graph than about its values at five

90
00:03:52,400 --> 00:03:54,400
specific points corresponding to the

91
00:03:54,400 --> 00:03:56,879
five standardized elliptic curves

92
00:03:56,879 --> 00:03:59,120
and even among these curves

93
00:03:59,120 --> 00:04:01,920
a vast majority of users will use the

94
00:04:01,920 --> 00:04:05,200
most efficient options the 128-bit

95
00:04:05,200 --> 00:04:06,879
curves

96
00:04:06,879 --> 00:04:09,599
so we thought it made sense to look at

97
00:04:09,599 --> 00:04:12,239
the concrete security guarantees that

98
00:04:12,239 --> 00:04:14,720
the bounds offer at these specific

99
00:04:14,720 --> 00:04:17,680
configurations

100
00:04:18,079 --> 00:04:20,880
um we start with an example fixing a

101
00:04:20,880 --> 00:04:24,160
specific 128-bit configuration

102
00:04:24,160 --> 00:04:25,280
um

103
00:04:25,280 --> 00:04:28,160
and a specific relatively weak adversary

104
00:04:28,160 --> 00:04:30,560
with two to the sixty runtime two to the

105
00:04:30,560 --> 00:04:32,880
twenty users to interact with and two to

106
00:04:32,880 --> 00:04:34,800
thirty five sessions

107
00:04:34,800 --> 00:04:37,040
um

108
00:04:37,680 --> 00:04:39,520
when we plug these numbers into the

109
00:04:39,520 --> 00:04:42,960
dowling bound um going at all sorry

110
00:04:42,960 --> 00:04:44,560
um

111
00:04:44,560 --> 00:04:46,240
we get an

112
00:04:46,240 --> 00:04:48,400
advantage upper bound a maximum

113
00:04:48,400 --> 00:04:51,520
probability of breaking the protocol

114
00:04:51,520 --> 00:04:53,759
to put this number in context let's set

115
00:04:53,759 --> 00:04:56,960
a security goal with all 128-bit secure

116
00:04:56,960 --> 00:04:58,800
parameters we'd like for the handshake

117
00:04:58,800 --> 00:05:02,080
itself to also have 128-bit security

118
00:05:02,080 --> 00:05:04,160
using our runtime over advantage

119
00:05:04,160 --> 00:05:06,400
definition this translates to a 2 to the

120
00:05:06,400 --> 00:05:09,520
negative 68 advantage mound and we can

121
00:05:09,520 --> 00:05:10,479
see

122
00:05:10,479 --> 00:05:15,120
that we're just barely over the line um

123
00:05:15,120 --> 00:05:17,199
so we're not quite meeting the target

124
00:05:17,199 --> 00:05:18,479
security

125
00:05:18,479 --> 00:05:20,479
as we look at more powerful attackers

126
00:05:20,479 --> 00:05:23,199
the story gets worse

127
00:05:23,199 --> 00:05:26,080
with runtime up to two to the 80 we're

128
00:05:26,080 --> 00:05:27,840
missing the target upper bounds by a

129
00:05:27,840 --> 00:05:30,240
substantial amount and for our most

130
00:05:30,240 --> 00:05:32,320
powerful attacker

131
00:05:32,320 --> 00:05:35,360
uh the bound actually only guarantees

132
00:05:35,360 --> 00:05:36,880
that a break will happen with

133
00:05:36,880 --> 00:05:39,199
probability less than one

134
00:05:39,199 --> 00:05:40,560
um

135
00:05:40,560 --> 00:05:43,919
this is not what we want

136
00:05:43,919 --> 00:05:45,520
we're missing the guarantees that we

137
00:05:45,520 --> 00:05:47,360
want because the reduction to the

138
00:05:47,360 --> 00:05:50,720
diffie-hellman group underlying tls 1.3

139
00:05:50,720 --> 00:05:53,199
isn't tight the s-squared term here

140
00:05:53,199 --> 00:05:55,280
means that we have a quadratic loss in

141
00:05:55,280 --> 00:05:58,319
the total number of tls 1.3 sessions and

142
00:05:58,319 --> 00:06:00,479
there are billions of sessions happening

143
00:06:00,479 --> 00:06:04,880
each day so this loss is substantial

144
00:06:05,520 --> 00:06:07,440
our main contribution was giving a

145
00:06:07,440 --> 00:06:09,360
tighter bound for both the full

146
00:06:09,360 --> 00:06:12,000
handshake and the pre-shared key modes

147
00:06:12,000 --> 00:06:14,560
that reduces this quadratic loss to a

148
00:06:14,560 --> 00:06:16,080
constant loss

149
00:06:16,080 --> 00:06:17,440
and we can see

150
00:06:17,440 --> 00:06:20,240
that for all of our adversaries we are

151
00:06:20,240 --> 00:06:22,880
able to achieve the target 128-bit

152
00:06:22,880 --> 00:06:25,520
security and well under that

153
00:06:25,520 --> 00:06:27,840
um

154
00:06:28,000 --> 00:06:30,560
these uh improvements

155
00:06:30,560 --> 00:06:33,199
extend to all of the other standardized

156
00:06:33,199 --> 00:06:35,199
elliptic curves where we performed the

157
00:06:35,199 --> 00:06:38,080
same type of concrete evaluations

158
00:06:38,080 --> 00:06:41,120
and we can see that even when

159
00:06:41,120 --> 00:06:43,440
even when prior security bounds do meet

160
00:06:43,440 --> 00:06:45,520
the targets and do guarantee the desired

161
00:06:45,520 --> 00:06:48,000
levels of security we can still improve

162
00:06:48,000 --> 00:06:51,199
on them by up to 80 bits of security

163
00:06:51,199 --> 00:06:53,039
uh this is for the full handshake we

164
00:06:53,039 --> 00:06:55,280
also performed the same type of

165
00:06:55,280 --> 00:06:57,440
evaluation for the for the pre-shared

166
00:06:57,440 --> 00:06:59,680
key modes with a diffie-hellman key

167
00:06:59,680 --> 00:07:01,919
exchange and achieved the same caliber

168
00:07:01,919 --> 00:07:04,639
of results across the board

169
00:07:04,639 --> 00:07:07,919
finally we looked at pre-shared key only

170
00:07:07,919 --> 00:07:10,160
configurations which don't involve a

171
00:07:10,160 --> 00:07:11,840
diffie-hellman group

172
00:07:11,840 --> 00:07:13,520
and while we were able to achieve

173
00:07:13,520 --> 00:07:16,639
tighter bounds when the hash function is

174
00:07:16,639 --> 00:07:19,599
uh chosen to be sha-256

175
00:07:19,599 --> 00:07:22,000
for shot 384 our methods failed and

176
00:07:22,000 --> 00:07:24,479
we'll talk about why that happened

177
00:07:24,479 --> 00:07:27,758
closer to the end of the talk

178
00:07:29,680 --> 00:07:31,680
the quadratic loss that the dowling at

179
00:07:31,680 --> 00:07:34,000
altbound has is a common issue in

180
00:07:34,000 --> 00:07:35,840
diffie-hellman-based key exchanges like

181
00:07:35,840 --> 00:07:37,599
the tls 1.3

182
00:07:37,599 --> 00:07:39,360
handshake so let's dive a little more

183
00:07:39,360 --> 00:07:41,759
into that the decisional diffie-hellman

184
00:07:41,759 --> 00:07:42,880
problem

185
00:07:42,880 --> 00:07:45,680
um gives an attacker two

186
00:07:45,680 --> 00:07:48,160
random elements of a cyclic group called

187
00:07:48,160 --> 00:07:50,080
the diffie-hellman shares due to the a

188
00:07:50,080 --> 00:07:52,319
and g to the b here then the attacker

189
00:07:52,319 --> 00:07:53,759
must distinguish between the

190
00:07:53,759 --> 00:07:56,720
diffie-hellman secret g to the a b

191
00:07:56,720 --> 00:08:00,639
and a random third element of the group

192
00:08:00,639 --> 00:08:02,560
to build a key exchange based on this

193
00:08:02,560 --> 00:08:05,520
problem we let a client and server each

194
00:08:05,520 --> 00:08:07,440
sample diffie-hellman shares and

195
00:08:07,440 --> 00:08:10,000
exchange them over a network

196
00:08:10,000 --> 00:08:12,720
they then derive a session key from both

197
00:08:12,720 --> 00:08:15,440
shares and the associated secret using a

198
00:08:15,440 --> 00:08:18,560
key derivation function

199
00:08:18,560 --> 00:08:20,720
in a key exchange model an attacker

200
00:08:20,720 --> 00:08:22,720
doesn't expect to see just one session

201
00:08:22,720 --> 00:08:24,840
but many sessions happening

202
00:08:24,840 --> 00:08:27,199
simultaneously a reduction to the

203
00:08:27,199 --> 00:08:29,120
diffie-hellman problem

204
00:08:29,120 --> 00:08:31,280
therefore has to simulate all of these

205
00:08:31,280 --> 00:08:34,000
sessions at once even though it's still

206
00:08:34,000 --> 00:08:36,559
only being given two shares g to the a

207
00:08:36,559 --> 00:08:38,080
and g to the b

208
00:08:38,080 --> 00:08:41,080
um

209
00:08:41,679 --> 00:08:43,760
historically the only way to do this

210
00:08:43,760 --> 00:08:45,040
that was known

211
00:08:45,040 --> 00:08:47,680
was to pick one random client and one

212
00:08:47,680 --> 00:08:51,680
random server to uh embed the shares in

213
00:08:51,680 --> 00:08:54,080
and hope that these two sessions would

214
00:08:54,080 --> 00:08:57,200
be attacked by the adversary

215
00:08:57,200 --> 00:08:59,040
this is where the quadratic loss comes

216
00:08:59,040 --> 00:09:01,920
in a random factor of over the number of

217
00:09:01,920 --> 00:09:03,839
sessions for picking a client and a

218
00:09:03,839 --> 00:09:06,000
random factor of sessions for picking a

219
00:09:06,000 --> 00:09:08,399
server

220
00:09:08,399 --> 00:09:09,440
um

221
00:09:09,440 --> 00:09:11,600
the issue that leads to this quadratic

222
00:09:11,600 --> 00:09:14,480
loss is called the commitment problem

223
00:09:14,480 --> 00:09:15,360
but in

224
00:09:15,360 --> 00:09:18,480
a crypto paper in 2019 gordon it all

225
00:09:18,480 --> 00:09:21,040
came up with a solution for the crypto

226
00:09:21,040 --> 00:09:22,800
for the commitment problem

227
00:09:22,800 --> 00:09:25,040
that they applied to some specially

228
00:09:25,040 --> 00:09:27,200
designed key exchange protocols that had

229
00:09:27,200 --> 00:09:29,200
three important properties

230
00:09:29,200 --> 00:09:31,360
first they reduced to the strong

231
00:09:31,360 --> 00:09:33,279
diffie-hellman problem instead of the

232
00:09:33,279 --> 00:09:36,080
decisional dipping helmet problem strong

233
00:09:36,080 --> 00:09:37,839
diffie-hellman is an interactive

234
00:09:37,839 --> 00:09:40,480
assumption where an adversary is given

235
00:09:40,480 --> 00:09:42,880
the two different helmet shares and an

236
00:09:42,880 --> 00:09:45,600
oracle for the ddh problem that solves a

237
00:09:45,600 --> 00:09:48,560
restricted variant

238
00:09:48,560 --> 00:09:50,000
it then has to compute the

239
00:09:50,000 --> 00:09:52,720
diffie-hellman secret on its own

240
00:09:52,720 --> 00:09:54,880
changing assumptions to which fever tied

241
00:09:54,880 --> 00:09:56,800
around is generally an ill-advised

242
00:09:56,800 --> 00:09:58,959
strategy but we're not actually doing

243
00:09:58,959 --> 00:10:01,680
that here because the prior bounds for

244
00:10:01,680 --> 00:10:02,839
tls

245
00:10:02,839 --> 00:10:05,760
1.3 depend implicitly on strong

246
00:10:05,760 --> 00:10:08,560
diffie-hellman through the prf odh

247
00:10:08,560 --> 00:10:11,040
assumption

248
00:10:11,120 --> 00:10:12,800
the other two requirements for the cone

249
00:10:12,800 --> 00:10:15,040
gordon method are that

250
00:10:15,040 --> 00:10:17,440
the key derivation function should be

251
00:10:17,440 --> 00:10:20,480
modeled as a random oracle and it should

252
00:10:20,480 --> 00:10:23,200
have both diffie-hellman shares and the

253
00:10:23,200 --> 00:10:25,920
diffie-hellman secret as inputs all at

254
00:10:25,920 --> 00:10:27,440
the same time

255
00:10:27,440 --> 00:10:29,680
these two requirements extend a little

256
00:10:29,680 --> 00:10:33,680
less naturally to tls 1.3

257
00:10:33,680 --> 00:10:37,360
the key schedule for tls 1.3 is not a

258
00:10:37,360 --> 00:10:39,440
single key derivation function but it's

259
00:10:39,440 --> 00:10:42,079
instead used to derive 11 keys using a

260
00:10:42,079 --> 00:10:44,640
series of change calls to the hkdf

261
00:10:44,640 --> 00:10:47,680
extract and expand functions

262
00:10:47,680 --> 00:10:49,760
the diffie-hellman shares and secrets

263
00:10:49,760 --> 00:10:51,680
never enter the key schedule at the same

264
00:10:51,680 --> 00:10:54,160
point so to use the cone gordon methods

265
00:10:54,160 --> 00:10:56,560
we have to abstract this key schedule

266
00:10:56,560 --> 00:10:58,399
into the random oracle model very

267
00:10:58,399 --> 00:10:59,440
carefully

268
00:10:59,440 --> 00:11:01,760
we actually did this twice

269
00:11:01,760 --> 00:11:04,800
in two concurrent analyses of the tls

270
00:11:04,800 --> 00:11:08,000
1.3 full handshake

271
00:11:08,000 --> 00:11:11,279
our first uh way of doing this

272
00:11:11,279 --> 00:11:13,680
by davis and gunther

273
00:11:13,680 --> 00:11:16,320
where to um

274
00:11:16,320 --> 00:11:19,600
model hkdf extract and expand as two

275
00:11:19,600 --> 00:11:22,000
independent random oracles

276
00:11:22,000 --> 00:11:23,600
although we still don't have the shares

277
00:11:23,600 --> 00:11:26,480
and secrets entering at the same point

278
00:11:26,480 --> 00:11:28,160
we connect them in our proof with a

279
00:11:28,160 --> 00:11:30,480
careful lookup strategy that exploits

280
00:11:30,480 --> 00:11:33,040
the uh distinct labels in almost every

281
00:11:33,040 --> 00:11:35,920
call to expand

282
00:11:35,920 --> 00:11:38,240
unfortunately that model is pretty

283
00:11:38,240 --> 00:11:40,240
unrealistic because if we look at the

284
00:11:40,240 --> 00:11:42,959
definitions of extract and expand we'll

285
00:11:42,959 --> 00:11:45,519
see they're both very closely related to

286
00:11:45,519 --> 00:11:47,839
the hmac function and they have highly

287
00:11:47,839 --> 00:11:49,920
correlated outputs so

288
00:11:49,920 --> 00:11:53,120
not independent at all

289
00:11:53,200 --> 00:11:54,240
our

290
00:11:54,240 --> 00:11:55,440
other method

291
00:11:55,440 --> 00:11:58,800
was to um by diemer and jager was to

292
00:11:58,800 --> 00:11:59,760
view

293
00:11:59,760 --> 00:12:02,079
um

294
00:12:02,560 --> 00:12:05,440
to view to uh

295
00:12:05,440 --> 00:12:08,079
the path through the key schedule for

296
00:12:08,079 --> 00:12:10,000
each type of session key has an

297
00:12:10,000 --> 00:12:11,839
independent random oracle so they have

298
00:12:11,839 --> 00:12:14,000
four independent random oracles

299
00:12:14,000 --> 00:12:15,760
um

300
00:12:15,760 --> 00:12:17,839
modeling these overlapping paths through

301
00:12:17,839 --> 00:12:20,000
the key schedule and the advantage of

302
00:12:20,000 --> 00:12:22,399
this method is it's clear how it uh

303
00:12:22,399 --> 00:12:24,320
matches the cone gordon requirements

304
00:12:24,320 --> 00:12:26,399
there's one key derivation function for

305
00:12:26,399 --> 00:12:28,480
each key and the shares and secrets

306
00:12:28,480 --> 00:12:30,399
enter properly

307
00:12:30,399 --> 00:12:32,639
this allows a much simpler proof much

308
00:12:32,639 --> 00:12:34,800
more elegant and it avoids all of the

309
00:12:34,800 --> 00:12:37,760
lookups and dependencies on labels

310
00:12:37,760 --> 00:12:40,320
however it's hard to see why these

311
00:12:40,320 --> 00:12:42,079
overlapping paths are independent

312
00:12:42,079 --> 00:12:43,839
themselves

313
00:12:43,839 --> 00:12:45,600
when we extended our techniques to the

314
00:12:45,600 --> 00:12:47,440
pre-shared key models in an upcoming

315
00:12:47,440 --> 00:12:48,880
paper

316
00:12:48,880 --> 00:12:50,240
we had to pick between these two

317
00:12:50,240 --> 00:12:51,680
abstractions

318
00:12:51,680 --> 00:12:53,600
but while trying to do so we noticed

319
00:12:53,600 --> 00:12:55,760
that they have a common issue

320
00:12:55,760 --> 00:12:58,079
in the random oracle model you should

321
00:12:58,079 --> 00:13:00,959
typically replace one hash function with

322
00:13:00,959 --> 00:13:02,959
a random oracle everywhere that it's

323
00:13:02,959 --> 00:13:06,639
used the tls's single hash function

324
00:13:06,639 --> 00:13:09,600
is used outside the key schedule

325
00:13:09,600 --> 00:13:11,680
and in it as part of

326
00:13:11,680 --> 00:13:14,959
the hkdf functions

327
00:13:14,959 --> 00:13:17,040
to shorten transcripts before they enter

328
00:13:17,040 --> 00:13:19,040
the key schedule and as part of the

329
00:13:19,040 --> 00:13:22,560
message authentication codes

330
00:13:23,920 --> 00:13:26,160
in order to use an abstraction that's

331
00:13:26,160 --> 00:13:28,720
both realistic and gives us tight bounds

332
00:13:28,720 --> 00:13:31,120
we want to replace h with just a single

333
00:13:31,120 --> 00:13:34,000
random oracle everywhere but also

334
00:13:34,000 --> 00:13:36,560
preserve uh these independent key

335
00:13:36,560 --> 00:13:39,040
derivation functions from the d jagger

336
00:13:39,040 --> 00:13:40,000
model

337
00:13:40,000 --> 00:13:41,920
and we want to more carefully justify

338
00:13:41,920 --> 00:13:43,519
our abstraction so these issues don't

339
00:13:43,519 --> 00:13:45,360
pop up again

340
00:13:45,360 --> 00:13:47,519
we can achieve all of this in the

341
00:13:47,519 --> 00:13:49,680
indifferentiability framework

342
00:13:49,680 --> 00:13:52,880
this framework from mar at all

343
00:13:52,880 --> 00:13:55,279
allows us to

344
00:13:55,279 --> 00:13:57,600
give a bound that bounds the difference

345
00:13:57,600 --> 00:14:00,079
between the real tls

346
00:14:00,079 --> 00:14:02,639
protocol and an abstraction of it in the

347
00:14:02,639 --> 00:14:05,519
random oracle model

348
00:14:05,519 --> 00:14:08,000
and we start with a very simple step one

349
00:14:08,000 --> 00:14:10,480
hash function to one random oracle

350
00:14:10,480 --> 00:14:12,480
we then split this random article into

351
00:14:12,480 --> 00:14:15,360
two pieces one for hashing transcripts

352
00:14:15,360 --> 00:14:17,519
and one for doing all of the other hash

353
00:14:17,519 --> 00:14:22,959
operations in tls hmac hkdf etc

354
00:14:22,959 --> 00:14:26,000
um we then treat hmac itself as a single

355
00:14:26,000 --> 00:14:28,079
random oracle relying on some prior work

356
00:14:28,079 --> 00:14:30,800
by notice at all and then we split it

357
00:14:30,800 --> 00:14:33,920
into 11 random oracles 12 in total

358
00:14:33,920 --> 00:14:35,760
including the transcript

359
00:14:35,760 --> 00:14:37,839
uh random oracle

360
00:14:37,839 --> 00:14:39,920
using the same lookup strategy from our

361
00:14:39,920 --> 00:14:42,000
earlier proof the advantage here is that

362
00:14:42,000 --> 00:14:45,199
it's now a stand-alone proof

363
00:14:45,199 --> 00:14:46,959
instead of one that's embedded in a key

364
00:14:46,959 --> 00:14:49,360
exchange proof

365
00:14:49,360 --> 00:14:51,680
the step we didn't justify is a little

366
00:14:51,680 --> 00:14:53,279
bit more subtle

367
00:14:53,279 --> 00:14:56,160
and this is where the legacy session id

368
00:14:56,160 --> 00:14:59,040
comes in to proven differentiability we

369
00:14:59,040 --> 00:15:00,079
need

370
00:15:00,079 --> 00:15:02,240
a rule that determines when a hash

371
00:15:02,240 --> 00:15:04,160
function input is a transcript and when

372
00:15:04,160 --> 00:15:05,199
it's not

373
00:15:05,199 --> 00:15:07,440
so as a quick example

374
00:15:07,440 --> 00:15:09,920
is this a transcript or not

375
00:15:09,920 --> 00:15:12,639
for this one we can tell because it's 71

376
00:15:12,639 --> 00:15:15,760
bytes which is too short to be anything

377
00:15:15,760 --> 00:15:18,160
but a transcript all hmac calls are at

378
00:15:18,160 --> 00:15:20,160
least 96 bytes

379
00:15:20,160 --> 00:15:23,199
in tls 1.3

380
00:15:23,199 --> 00:15:24,639
um

381
00:15:24,639 --> 00:15:27,279
when the hash function is sha 256

382
00:15:27,279 --> 00:15:30,639
transcripts can be at more than 96 bytes

383
00:15:30,639 --> 00:15:33,279
so we need another way to determine

384
00:15:33,279 --> 00:15:34,720
and in this case

385
00:15:34,720 --> 00:15:38,560
we diagram out an hmac call and a client

386
00:15:38,560 --> 00:15:41,680
hello message the start of a transcript

387
00:15:41,680 --> 00:15:45,199
an hmac call starts with 32 bytes of key

388
00:15:45,199 --> 00:15:47,600
and then 32 bytes

389
00:15:47,600 --> 00:15:50,079
that is padded to a specific value

390
00:15:50,079 --> 00:15:53,040
either each byte being fixed to either 3

391
00:15:53,040 --> 00:15:55,920
6 or 5c

392
00:15:55,920 --> 00:15:56,880
um

393
00:15:56,880 --> 00:16:01,360
in a client hello we have 34 bytes of

394
00:16:01,360 --> 00:16:03,759
version number and nonce and the first

395
00:16:03,759 --> 00:16:07,199
non-random byte after this is the length

396
00:16:07,199 --> 00:16:10,639
encoding byte of the legacy session id

397
00:16:10,639 --> 00:16:11,600
um

398
00:16:11,600 --> 00:16:13,920
in order to tell that something is not a

399
00:16:13,920 --> 00:16:15,199
transcript

400
00:16:15,199 --> 00:16:18,480
we need to check this byte by 34 and

401
00:16:18,480 --> 00:16:19,680
verify

402
00:16:19,680 --> 00:16:22,880
does it match 36 or 5c

403
00:16:22,880 --> 00:16:25,279
or not and for a valid transcript it

404
00:16:25,279 --> 00:16:27,839
will never match either of these values

405
00:16:27,839 --> 00:16:29,759
because the legacy session id has a

406
00:16:29,759 --> 00:16:32,079
maximum length of 32 bytes which is

407
00:16:32,079 --> 00:16:35,199
convenient but it's also lucky and we're

408
00:16:35,199 --> 00:16:36,880
only this lucky

409
00:16:36,880 --> 00:16:38,720
for pre-shared key only modes with

410
00:16:38,720 --> 00:16:40,320
sha-256

411
00:16:40,320 --> 00:16:42,959
when the hash function is shot 384

412
00:16:42,959 --> 00:16:44,800
there's no such luck

413
00:16:44,800 --> 00:16:47,600
and we can't find a hard and fast rule

414
00:16:47,600 --> 00:16:49,920
to distinguish between hash function

415
00:16:49,920 --> 00:16:51,680
inputs that are transcripts and that are

416
00:16:51,680 --> 00:16:53,279
not

417
00:16:53,279 --> 00:16:54,959
this is why we weren't able to give

418
00:16:54,959 --> 00:16:57,199
tight bounds for the pre-shared key only

419
00:16:57,199 --> 00:17:00,639
mode with shot 384

420
00:17:01,440 --> 00:17:02,399
we do

421
00:17:02,399 --> 00:17:04,559
give proposals for

422
00:17:04,559 --> 00:17:07,039
potential domain separation fixes for

423
00:17:07,039 --> 00:17:08,959
protocols like tls that use a hash

424
00:17:08,959 --> 00:17:12,400
function in hmac and in other places

425
00:17:12,400 --> 00:17:14,400
and we hope that this will

426
00:17:14,400 --> 00:17:16,640
allow us to eventually

427
00:17:16,640 --> 00:17:18,959
give this type of tighter bound for all

428
00:17:18,959 --> 00:17:20,079
modes

429
00:17:20,079 --> 00:17:22,240
um thanks for listening to this talk and

430
00:17:22,240 --> 00:17:26,199
i'm happy to take any questions

431
00:17:33,440 --> 00:17:36,400
thank you hannah if someone has any

432
00:17:36,400 --> 00:17:39,039
question please come to the mic in the

433
00:17:39,039 --> 00:17:41,440
middle

434
00:17:42,799 --> 00:17:44,160
yeah uh thank you hannah that was a

435
00:17:44,160 --> 00:17:46,720
really cool talk um if you were just

436
00:17:46,720 --> 00:17:49,039
starting from scratch

437
00:17:49,039 --> 00:17:52,160
how would you uh uh redesign tls 1.3 to

438
00:17:52,160 --> 00:17:54,559
get rid of all these kind of weird

439
00:17:54,559 --> 00:17:57,280
rather miracles and and the bad domain

440
00:17:57,280 --> 00:17:58,799
separation what would you do differently

441
00:17:58,799 --> 00:18:01,840
if you're starting today

442
00:18:02,559 --> 00:18:05,039
oh this is uh where i mentioned that we

443
00:18:05,039 --> 00:18:07,679
have proposals there's no perfect answer

444
00:18:07,679 --> 00:18:08,720
because

445
00:18:08,720 --> 00:18:10,000
um

446
00:18:10,000 --> 00:18:12,640
starting completely from scratch would

447
00:18:12,640 --> 00:18:16,000
involve also redesigning hmac um to

448
00:18:16,000 --> 00:18:17,919
allow for some domain separation between

449
00:18:17,919 --> 00:18:20,799
the internal hash function calls of hmac

450
00:18:20,799 --> 00:18:23,760
and then a design of tls would include

451
00:18:23,760 --> 00:18:26,240
labels in these underlying hmac calls as

452
00:18:26,240 --> 00:18:29,120
well um without that

453
00:18:29,120 --> 00:18:31,440
uh being possible

454
00:18:31,440 --> 00:18:34,320
i would probably include some suffix

455
00:18:34,320 --> 00:18:35,360
padding

456
00:18:35,360 --> 00:18:37,200
to each of the um

457
00:18:37,200 --> 00:18:39,440
each of the hash function and hmac and

458
00:18:39,440 --> 00:18:42,080
hkdf calls within the key schedule to

459
00:18:42,080 --> 00:18:44,559
try to separate every single hash

460
00:18:44,559 --> 00:18:47,120
function call um

461
00:18:47,120 --> 00:18:48,160
this would

462
00:18:48,160 --> 00:18:50,080
greatly simplify the domain separation

463
00:18:50,080 --> 00:18:52,080
steps and um the modular

464
00:18:52,080 --> 00:18:53,760
indifferentiability approach really does

465
00:18:53,760 --> 00:18:56,320
simplify the actual key exchange portion

466
00:18:56,320 --> 00:18:57,440
of the proof

467
00:18:57,440 --> 00:18:58,880
could you not get rid of hbac and just

468
00:18:58,880 --> 00:19:02,160
use shard three for everything

469
00:19:02,799 --> 00:19:03,919
um

470
00:19:03,919 --> 00:19:05,919
you could potentially in some cases but

471
00:19:05,919 --> 00:19:07,760
they are using hmac as a message

472
00:19:07,760 --> 00:19:09,679
authentication code

473
00:19:09,679 --> 00:19:11,440
and the key part of that is something

474
00:19:11,440 --> 00:19:13,200
where i'm not sure sha-3 would be a

475
00:19:13,200 --> 00:19:15,440
perfect substitution

476
00:19:15,440 --> 00:19:18,559
thank you thank you very much

477
00:19:19,840 --> 00:19:22,880
hi thanks for your talk um

478
00:19:22,880 --> 00:19:25,440
the

479
00:19:25,440 --> 00:19:27,280
improvement in the tightness that you

480
00:19:27,280 --> 00:19:29,919
did relies very strongly on this strong

481
00:19:29,919 --> 00:19:32,480
decision strongly helmet assumption but

482
00:19:32,480 --> 00:19:34,080
we're trying to move away from the

483
00:19:34,080 --> 00:19:36,160
helmet in a lot of places so you have

484
00:19:36,160 --> 00:19:38,640
any idea if we could

485
00:19:38,640 --> 00:19:40,320
use the same kind of fix with a chem

486
00:19:40,320 --> 00:19:43,439
instead of tiffy helman

487
00:19:44,080 --> 00:19:47,200
i'm i'm not sure the technique does rely

488
00:19:47,200 --> 00:19:49,840
quite heavily on the re-randomization

489
00:19:49,840 --> 00:19:51,520
properties of

490
00:19:51,520 --> 00:19:54,240
strong diffie-hellman i'm not familiar

491
00:19:54,240 --> 00:19:55,840
enough with chemist assumptions

492
00:19:55,840 --> 00:19:57,840
especially for like post-quantum chems

493
00:19:57,840 --> 00:19:59,840
to know if they have similar

494
00:19:59,840 --> 00:20:02,320
randomization properties but

495
00:20:02,320 --> 00:20:04,320
it's always possible

496
00:20:04,320 --> 00:20:07,320
thanks

497
00:20:07,760 --> 00:20:10,960
no other questions so i i don't see any

498
00:20:10,960 --> 00:20:12,480
on the chat

499
00:20:12,480 --> 00:20:15,120
right now so maybe let's thanks hannah

500
00:20:15,120 --> 00:20:16,130
again

501
00:20:16,130 --> 00:20:19,229
[Applause]

502
00:20:22,730 --> 00:20:22,980
[Applause]

503
00:20:22,980 --> 00:20:25,120
[Music]

504
00:20:25,120 --> 00:20:26,000
so

505
00:20:26,000 --> 00:20:31,480
our second speaker is there in person

506
00:20:35,679 --> 00:20:37,440
so his talk is about

507
00:20:37,440 --> 00:20:39,679
alpaca application layer protocol

508
00:20:39,679 --> 00:20:41,200
confusion

509
00:20:41,200 --> 00:20:46,840
and we welcome marcus brinkman on stage

510
00:20:48,320 --> 00:20:51,039
so um how does this work um

511
00:20:51,039 --> 00:20:52,320
i have a

512
00:20:52,320 --> 00:20:53,760
thing here

513
00:20:53,760 --> 00:20:56,000
okay

514
00:20:56,960 --> 00:20:59,360
so um thank you for coming

515
00:20:59,360 --> 00:21:01,919
and this is a joint work with christian

516
00:21:01,919 --> 00:21:04,400
reyson robert margaret who is here

517
00:21:04,400 --> 00:21:07,600
damian podepnia against mueller

518
00:21:07,600 --> 00:21:09,760
and sebastian schinsel

519
00:21:09,760 --> 00:21:11,520
and our research

520
00:21:11,520 --> 00:21:14,320
is in real world protocols like tls and

521
00:21:14,320 --> 00:21:17,360
last year robert gave a talk on a side

522
00:21:17,360 --> 00:21:20,000
channel attack on tls adify hellmann

523
00:21:20,000 --> 00:21:22,080
breaking its confidentiality

524
00:21:22,080 --> 00:21:25,120
and this year we show how gaps in tls

525
00:21:25,120 --> 00:21:27,520
authentication can be used to break

526
00:21:27,520 --> 00:21:30,720
application security

527
00:21:30,720 --> 00:21:32,960
so

528
00:21:33,039 --> 00:21:34,960
tls is the most important protocol to

529
00:21:34,960 --> 00:21:37,280
provide confidentiality integrity and

530
00:21:37,280 --> 00:21:39,120
authenticity for server applications on

531
00:21:39,120 --> 00:21:41,440
the internet here's an example a web

532
00:21:41,440 --> 00:21:43,280
server and a browser

533
00:21:43,280 --> 00:21:44,480
and

534
00:21:44,480 --> 00:21:46,559
it is also used to protect other legacy

535
00:21:46,559 --> 00:21:50,080
protocols such as file servers with ftp

536
00:21:50,080 --> 00:21:54,400
and email servers with pop3 imit smtp

537
00:21:54,400 --> 00:21:56,159
and other protocols

538
00:21:56,159 --> 00:21:59,120
so let's take a closer look at how

539
00:21:59,120 --> 00:22:01,919
tls achieves this portability

540
00:22:01,919 --> 00:22:05,039
fpls is designed as a

541
00:22:05,039 --> 00:22:06,880
transparent layer between the network

542
00:22:06,880 --> 00:22:08,960
layer and the application layer

543
00:22:08,960 --> 00:22:11,039
so the idea is that it is completely

544
00:22:11,039 --> 00:22:13,520
application independent

545
00:22:13,520 --> 00:22:16,080
and in particular

546
00:22:16,080 --> 00:22:18,799
tls does not protect the tcp connection

547
00:22:18,799 --> 00:22:20,720
endpoint such as the ip address or port

548
00:22:20,720 --> 00:22:22,080
number

549
00:22:22,080 --> 00:22:24,640
so an attacker can

550
00:22:24,640 --> 00:22:27,440
first of all redirect the packet to a

551
00:22:27,440 --> 00:22:30,400
different service

552
00:22:30,480 --> 00:22:33,039
excuse me

553
00:22:35,600 --> 00:22:37,919
this can sometimes

554
00:22:37,919 --> 00:22:39,679
enable application layer protocol

555
00:22:39,679 --> 00:22:40,880
confusion

556
00:22:40,880 --> 00:22:41,919
where

557
00:22:41,919 --> 00:22:43,200
the client and the server speak

558
00:22:43,200 --> 00:22:47,200
different protocols via http and ftp

559
00:22:47,200 --> 00:22:48,880
and this can lead to cost protocol

560
00:22:48,880 --> 00:22:50,000
attacks

561
00:22:50,000 --> 00:22:52,240
so in such a cross protocol attack

562
00:22:52,240 --> 00:22:54,240
the client is redirected to a server

563
00:22:54,240 --> 00:22:56,799
speaking an entirely different protocol

564
00:22:56,799 --> 00:22:59,760
and we present these attacks normally

565
00:22:59,760 --> 00:23:00,880
by

566
00:23:00,880 --> 00:23:03,840
relying on tls

567
00:23:03,840 --> 00:23:05,760
domain certificates

568
00:23:05,760 --> 00:23:08,159
who isolate each service from another

569
00:23:08,159 --> 00:23:09,039
right

570
00:23:09,039 --> 00:23:12,159
so um in this case if you have two

571
00:23:12,159 --> 00:23:14,159
completely different services they have

572
00:23:14,159 --> 00:23:16,159
incompatible certificates and the buzzer

573
00:23:16,159 --> 00:23:17,679
will

574
00:23:17,679 --> 00:23:19,120
terminate the

575
00:23:19,120 --> 00:23:21,200
connection after the attacker tries to

576
00:23:21,200 --> 00:23:25,200
redirect it but sometimes there are gaps

577
00:23:25,200 --> 00:23:26,480
and

578
00:23:26,480 --> 00:23:29,520
the men in the middle attack is possible

579
00:23:29,520 --> 00:23:31,120
for example in the case of wildcard

580
00:23:31,120 --> 00:23:33,440
certificates

581
00:23:33,440 --> 00:23:35,440
one certificate can be valid for all

582
00:23:35,440 --> 00:23:37,360
sub-domains of a domain

583
00:23:37,360 --> 00:23:39,120
and there are multi-domain certificates

584
00:23:39,120 --> 00:23:40,640
which are simply valid for many

585
00:23:40,640 --> 00:23:42,080
hostnames

586
00:23:42,080 --> 00:23:44,480
and even on a single hostname if you

587
00:23:44,480 --> 00:23:46,159
have a certificate with a single house

588
00:23:46,159 --> 00:23:48,400
name it can still be used across

589
00:23:48,400 --> 00:23:50,640
multiple services on that same host

590
00:23:50,640 --> 00:23:53,360
using different port numbers

591
00:23:53,360 --> 00:23:55,600
so

592
00:23:56,730 --> 00:23:58,159
[Music]

593
00:23:58,159 --> 00:23:59,760
in this work

594
00:23:59,760 --> 00:24:01,760
we consider only cross protocol attacks

595
00:24:01,760 --> 00:24:03,520
on https

596
00:24:03,520 --> 00:24:05,520
exploiting an application server

597
00:24:05,520 --> 00:24:09,440
speaking smtp imap box 3 or ftp

598
00:24:09,440 --> 00:24:11,200
but i want to make sure that you

599
00:24:11,200 --> 00:24:12,400
understand

600
00:24:12,400 --> 00:24:13,600
that

601
00:24:13,600 --> 00:24:16,640
potentially any tls speaking protocol

602
00:24:16,640 --> 00:24:18,799
can be redirected to any other

603
00:24:18,799 --> 00:24:20,960
so the number of possible course

604
00:24:20,960 --> 00:24:23,840
protocol scenarios across them all

605
00:24:23,840 --> 00:24:26,480
tls protocols and services grows

606
00:24:26,480 --> 00:24:27,919
quadratically

607
00:24:27,919 --> 00:24:32,520
and we have not explored most of them

608
00:24:32,960 --> 00:24:34,960
and we consider three different

609
00:24:34,960 --> 00:24:36,880
exploitation methods

610
00:24:36,880 --> 00:24:39,200
so in a reflection attack the attacker

611
00:24:39,200 --> 00:24:40,000
would

612
00:24:40,000 --> 00:24:43,200
try to attract the client into sending a

613
00:24:43,200 --> 00:24:45,279
malicious payload to

614
00:24:45,279 --> 00:24:47,200
the intended server which is then

615
00:24:47,200 --> 00:24:49,840
redirected to another server and that

616
00:24:49,840 --> 00:24:50,880
server

617
00:24:50,880 --> 00:24:54,240
potentially reflects this payload

618
00:24:54,240 --> 00:24:56,320
for example in an

619
00:24:56,320 --> 00:24:58,720
error message

620
00:24:58,720 --> 00:25:00,720
in the download scenario the attacker

621
00:25:00,720 --> 00:25:02,559
would first prepare the evil payload on

622
00:25:02,559 --> 00:25:03,760
the server

623
00:25:03,760 --> 00:25:05,440
that is redirected to

624
00:25:05,440 --> 00:25:07,200
and then the client would download it

625
00:25:07,200 --> 00:25:08,400
from there

626
00:25:08,400 --> 00:25:10,000
and in an upload attack we try to

627
00:25:10,000 --> 00:25:12,320
extract sensitive data from the client

628
00:25:12,320 --> 00:25:14,960
by redirecting it to a protocol that can

629
00:25:14,960 --> 00:25:16,720
upload data

630
00:25:16,720 --> 00:25:19,120
so to give a more complete example

631
00:25:19,120 --> 00:25:21,679
here's the first um

632
00:25:21,679 --> 00:25:23,200
cross protocol attack on tls

633
00:25:23,200 --> 00:25:26,960
applications by young horn in 2015

634
00:25:26,960 --> 00:25:28,960
and um this is so complicated that we

635
00:25:28,960 --> 00:25:30,159
walk through it

636
00:25:30,159 --> 00:25:31,039
uh

637
00:25:31,039 --> 00:25:33,120
first the attacker lures the victim on

638
00:25:33,120 --> 00:25:35,440
its own website

639
00:25:35,440 --> 00:25:38,799
and then causes the browser to

640
00:25:38,799 --> 00:25:41,279
create a so-called cross-origin http

641
00:25:41,279 --> 00:25:42,720
request

642
00:25:42,720 --> 00:25:43,440
this

643
00:25:43,440 --> 00:25:45,520
does go to a different server than the

644
00:25:45,520 --> 00:25:49,279
attacker server in this example bank.com

645
00:25:49,279 --> 00:25:51,600
and

646
00:25:52,159 --> 00:25:54,080
in this request the attacker can put an

647
00:25:54,080 --> 00:25:56,799
ftp command

648
00:25:56,799 --> 00:25:58,320
so then the men in the middle attacker

649
00:25:58,320 --> 00:26:01,200
redirects that to the banks.com ftp

650
00:26:01,200 --> 00:26:02,480
server

651
00:26:02,480 --> 00:26:04,159
and the browser will accept this

652
00:26:04,159 --> 00:26:05,760
connection because there's a compatible

653
00:26:05,760 --> 00:26:08,000
certificate it thinks it is talking to

654
00:26:08,000 --> 00:26:09,679
the browser

655
00:26:09,679 --> 00:26:11,600
to the web server sorry

656
00:26:11,600 --> 00:26:14,640
and then the ftp server may be error

657
00:26:14,640 --> 00:26:18,080
tolerant ignore the http header and then

658
00:26:18,080 --> 00:26:20,080
find this ftp command

659
00:26:20,080 --> 00:26:22,320
and this ftp command is actually invalid

660
00:26:22,320 --> 00:26:26,399
so it will create an

661
00:26:26,960 --> 00:26:29,200
error message that contains this

662
00:26:29,200 --> 00:26:32,720
javascript from the attacker and if the

663
00:26:32,720 --> 00:26:35,279
browser is also tolerant to protocol

664
00:26:35,279 --> 00:26:37,840
noise it may execute this javascript

665
00:26:37,840 --> 00:26:39,760
thinking it comes from bank.com and in

666
00:26:39,760 --> 00:26:42,799
this case it gives the attacker

667
00:26:42,799 --> 00:26:44,240
access

668
00:26:44,240 --> 00:26:46,480
the attacker can impersonate the bank

669
00:26:46,480 --> 00:26:49,480
basically

670
00:26:53,440 --> 00:26:54,960
so here's another attack this is a

671
00:26:54,960 --> 00:26:57,440
download attack also by anhon

672
00:26:57,440 --> 00:27:00,480
and in which the attacker prepares the

673
00:27:00,480 --> 00:27:03,120
javascript as a stored file on the ftp

674
00:27:03,120 --> 00:27:04,000
server

675
00:27:04,000 --> 00:27:05,919
it's in the bottom right

676
00:27:05,919 --> 00:27:06,960
you

677
00:27:06,960 --> 00:27:09,919
have to have some sort of sort of access

678
00:27:09,919 --> 00:27:11,679
to the content of the ftp server to do

679
00:27:11,679 --> 00:27:12,880
this

680
00:27:12,880 --> 00:27:14,480
and then

681
00:27:14,480 --> 00:27:16,640
in this case the ftp commands contained

682
00:27:16,640 --> 00:27:20,880
in the request will open a data port and

683
00:27:20,880 --> 00:27:22,559
on this data port

684
00:27:22,559 --> 00:27:24,640
there's a second request

685
00:27:24,640 --> 00:27:26,960
caused by changing the url in the

686
00:27:26,960 --> 00:27:28,799
location bar

687
00:27:28,799 --> 00:27:31,120
will actually download this response so

688
00:27:31,120 --> 00:27:32,640
in this case the attacker can prepare a

689
00:27:32,640 --> 00:27:34,880
completely valid http response and

690
00:27:34,880 --> 00:27:37,279
there's no protocol noise and this will

691
00:27:37,279 --> 00:27:39,840
always work

692
00:27:40,799 --> 00:27:44,159
and in this case also the attacker gets

693
00:27:44,159 --> 00:27:48,080
to impersonate the bank completely

694
00:27:48,080 --> 00:27:51,279
um we contributed a third attack method

695
00:27:51,279 --> 00:27:53,039
in this case um

696
00:27:53,039 --> 00:27:55,279
we prepare the ftp server to accept an

697
00:27:55,279 --> 00:27:58,000
uploaded file and this uploaded file

698
00:27:58,000 --> 00:28:00,559
then contains the http header

699
00:28:00,559 --> 00:28:03,279
for any request going to the bank.com

700
00:28:03,279 --> 00:28:06,080
and this can contain sensitive data

701
00:28:06,080 --> 00:28:08,240
such as a session cookie if the user is

702
00:28:08,240 --> 00:28:09,760
logged in

703
00:28:09,760 --> 00:28:10,799
and

704
00:28:10,799 --> 00:28:12,799
this also completely breaks the web

705
00:28:12,799 --> 00:28:15,120
security model

706
00:28:15,120 --> 00:28:16,720
because then the attacker can extract

707
00:28:16,720 --> 00:28:18,240
the cookie and

708
00:28:18,240 --> 00:28:22,399
impersonate the user to the link

709
00:28:22,480 --> 00:28:24,000
so um

710
00:28:24,000 --> 00:28:24,799
we

711
00:28:24,799 --> 00:28:27,120
evaluated all these three

712
00:28:27,120 --> 00:28:29,679
fundamental strategies with all of the

713
00:28:29,679 --> 00:28:31,279
four application protocols that we

714
00:28:31,279 --> 00:28:32,559
looked at

715
00:28:32,559 --> 00:28:35,360
in the context of the browser

716
00:28:35,360 --> 00:28:38,080
and except that doesn't make sense smtp

717
00:28:38,080 --> 00:28:39,760
is an email submission protocol it does

718
00:28:39,760 --> 00:28:41,760
not support downloading at all

719
00:28:41,760 --> 00:28:43,360
and pop3 is an

720
00:28:43,360 --> 00:28:45,279
email retrieval protocol which does not

721
00:28:45,279 --> 00:28:47,360
support uploading so we have to exclude

722
00:28:47,360 --> 00:28:49,679
these scenarios

723
00:28:49,679 --> 00:28:51,520
and we had the following research

724
00:28:51,520 --> 00:28:52,960
questions first

725
00:28:52,960 --> 00:28:55,039
are these attacks still possible i

726
00:28:55,039 --> 00:28:57,440
showed you an older attack from 2015 is

727
00:28:57,440 --> 00:28:59,840
still possible are there more attacks

728
00:28:59,840 --> 00:29:01,600
and how many servers are affected by

729
00:29:01,600 --> 00:29:03,760
cross-protocol attacks on the internet

730
00:29:03,760 --> 00:29:07,200
and can be prevented

731
00:29:07,200 --> 00:29:08,080
so

732
00:29:08,080 --> 00:29:10,080
first we evaluated the browsers for the

733
00:29:10,080 --> 00:29:12,240
tolerance to protocol noise because if

734
00:29:12,240 --> 00:29:13,520
they detect

735
00:29:13,520 --> 00:29:15,679
nftp servers responding

736
00:29:15,679 --> 00:29:18,559
we probably can't do anything further

737
00:29:18,559 --> 00:29:20,320
and we found that internet explorer and

738
00:29:20,320 --> 00:29:22,960
edge legacy are very solvent and

739
00:29:22,960 --> 00:29:24,960
find javascript embedded in a lot of

740
00:29:24,960 --> 00:29:27,679
noise and executed while more modern

741
00:29:27,679 --> 00:29:28,799
browsers

742
00:29:28,799 --> 00:29:31,360
have filters that detect

743
00:29:31,360 --> 00:29:33,279
invalid responses and then they don't

744
00:29:33,279 --> 00:29:35,600
execute the javascript so in this case

745
00:29:35,600 --> 00:29:37,520
we can only work with methods that do

746
00:29:37,520 --> 00:29:39,679
not include noise such as the ftp

747
00:29:39,679 --> 00:29:42,720
uploaded download attack

748
00:29:42,720 --> 00:29:45,679
and we looked at 24 application servers

749
00:29:45,679 --> 00:29:48,240
and speaking one of the four protocols

750
00:29:48,240 --> 00:29:49,279
and

751
00:29:49,279 --> 00:29:51,760
looked for their tolerances as well

752
00:29:51,760 --> 00:29:55,360
and found that in over half of them we

753
00:29:55,360 --> 00:29:57,840
can at least find some attack

754
00:29:57,840 --> 00:29:59,760
a vector that works in one browser at

755
00:29:59,760 --> 00:30:00,640
least

756
00:30:00,640 --> 00:30:02,399
so

757
00:30:02,399 --> 00:30:05,679
in 13 cases we can use download of

758
00:30:05,679 --> 00:30:07,279
reflection attacks

759
00:30:07,279 --> 00:30:08,480
um in

760
00:30:08,480 --> 00:30:10,559
the internet explorer and its legacy and

761
00:30:10,559 --> 00:30:12,559
in four cases we can

762
00:30:12,559 --> 00:30:15,200
do all the attacks um also in

763
00:30:15,200 --> 00:30:19,080
the ftp update and download

764
00:30:22,000 --> 00:30:24,320
then

765
00:30:27,360 --> 00:30:28,640
then we wanted to see if there are

766
00:30:28,640 --> 00:30:30,480
servers on the internet that allow these

767
00:30:30,480 --> 00:30:31,840
attacks

768
00:30:31,840 --> 00:30:34,159
and we have to go backwards first we

769
00:30:34,159 --> 00:30:35,760
have to scan for the application servers

770
00:30:35,760 --> 00:30:37,360
that are vulnerable

771
00:30:37,360 --> 00:30:39,120
and then

772
00:30:39,120 --> 00:30:43,439
try to find the web servers that also

773
00:30:44,240 --> 00:30:46,159
can be accessed with the certificate of

774
00:30:46,159 --> 00:30:48,559
the application server so first we scan

775
00:30:48,559 --> 00:30:50,799
for all application servers

776
00:30:50,799 --> 00:30:53,200
and found 31 million ftp or email

777
00:30:53,200 --> 00:30:55,600
servers that speak tls

778
00:30:55,600 --> 00:30:59,279
and of these about 19.7 million have

779
00:30:59,279 --> 00:31:01,120
valid certificates that are accepted by

780
00:31:01,120 --> 00:31:02,240
browsers

781
00:31:02,240 --> 00:31:05,919
so all these certificates are potential

782
00:31:05,919 --> 00:31:08,159
vectors for exploits

783
00:31:08,159 --> 00:31:09,200
and

784
00:31:09,200 --> 00:31:11,279
we scan these certificates for all the

785
00:31:11,279 --> 00:31:13,840
host names they contain and found 2

786
00:31:13,840 --> 00:31:16,159
million unique hostnames

787
00:31:16,159 --> 00:31:17,760
for wildcard certificates we had to

788
00:31:17,760 --> 00:31:20,880
guest and we guessed www for the sub

789
00:31:20,880 --> 00:31:22,960
domain

790
00:31:22,960 --> 00:31:25,279
and um then we looked for web servers on

791
00:31:25,279 --> 00:31:26,559
zero source

792
00:31:26,559 --> 00:31:29,039
and found 1.4 million web servers so

793
00:31:29,039 --> 00:31:31,360
what this means is for 1.4 million web

794
00:31:31,360 --> 00:31:33,519
servers we can find an application

795
00:31:33,519 --> 00:31:35,440
server that has a certificate which the

796
00:31:35,440 --> 00:31:37,600
browser accepts for the web server so

797
00:31:37,600 --> 00:31:40,240
the men in the middle attack is possible

798
00:31:40,240 --> 00:31:42,159
it does not mean that we can export this

799
00:31:42,159 --> 00:31:43,519
but it means that

800
00:31:43,519 --> 00:31:47,600
tls authentication is already bypass

801
00:31:47,600 --> 00:31:49,200
and then we

802
00:31:49,200 --> 00:31:51,279
try to identify these services if they

803
00:31:51,279 --> 00:31:53,600
are one of the

804
00:31:53,600 --> 00:31:56,159
vulnerable servers that we

805
00:31:56,159 --> 00:31:58,320
analyzed in our lab

806
00:31:58,320 --> 00:32:01,360
and could still identify 114 000 web

807
00:32:01,360 --> 00:32:03,440
servers that we could actually exploit

808
00:32:03,440 --> 00:32:05,840
with one of the uh reflection upload or

809
00:32:05,840 --> 00:32:09,039
download at attacks

810
00:32:09,039 --> 00:32:10,399
and um

811
00:32:10,399 --> 00:32:12,159
now i want to talk about the counter

812
00:32:12,159 --> 00:32:14,000
measures

813
00:32:14,000 --> 00:32:15,600
there are many countermeasures in the

814
00:32:15,600 --> 00:32:18,240
past and often the first idea one has is

815
00:32:18,240 --> 00:32:20,880
to fix this at the application layer

816
00:32:20,880 --> 00:32:23,279
so for example postfix

817
00:32:23,279 --> 00:32:26,159
is an smtp server that actually detects

818
00:32:26,159 --> 00:32:28,960
http requests and will block the

819
00:32:28,960 --> 00:32:31,039
connection and terminated

820
00:32:31,039 --> 00:32:34,159
um and another thing that's often done

821
00:32:34,159 --> 00:32:35,760
is to

822
00:32:35,760 --> 00:32:38,960
rely on syntax errors in the protocol

823
00:32:38,960 --> 00:32:41,679
and then this is some sort of implicit

824
00:32:41,679 --> 00:32:44,399
uh unknown protocol detection and that

825
00:32:44,399 --> 00:32:47,678
can also lead to um

826
00:32:47,840 --> 00:32:48,720
a

827
00:32:48,720 --> 00:32:50,960
determination of the connection

828
00:32:50,960 --> 00:32:53,279
there are also protocols that have our

829
00:32:53,279 --> 00:32:54,880
implementations that have reduced the

830
00:32:54,880 --> 00:32:57,039
number of reflection vectors so a

831
00:32:57,039 --> 00:32:59,120
javascript can't be reflected for

832
00:32:59,120 --> 00:33:02,320
example but all these things

833
00:33:02,320 --> 00:33:04,720
can lead to incompatibilities

834
00:33:04,720 --> 00:33:06,960
they can only prevent non-attacks

835
00:33:06,960 --> 00:33:08,320
and

836
00:33:08,320 --> 00:33:10,799
more importantly they happen after

837
00:33:10,799 --> 00:33:13,039
authentication

838
00:33:13,039 --> 00:33:15,279
after checking the

839
00:33:15,279 --> 00:33:17,200
sorry they happen after the tls and

840
00:33:17,200 --> 00:33:19,679
check so there could be bypasses and tls

841
00:33:19,679 --> 00:33:22,159
can prevent them

842
00:33:22,159 --> 00:33:25,120
so and another idea is to enforce strict

843
00:33:25,120 --> 00:33:27,200
isolation for certificates

844
00:33:27,200 --> 00:33:29,120
and this would mean no more wildcard

845
00:33:29,120 --> 00:33:31,200
certificates and no more multi-domain

846
00:33:31,200 --> 00:33:33,120
certificates and

847
00:33:33,120 --> 00:33:35,679
only a single service on any hostname

848
00:33:35,679 --> 00:33:38,080
and this is just purely impractical and

849
00:33:38,080 --> 00:33:40,880
also expensive for administrative

850
00:33:40,880 --> 00:33:43,360
reasons

851
00:33:46,399 --> 00:33:48,320
so it is unlikely that we will make any

852
00:33:48,320 --> 00:33:49,600
progress

853
00:33:49,600 --> 00:33:51,200
on this front in the

854
00:33:51,200 --> 00:33:52,880
near future

855
00:33:52,880 --> 00:33:54,799
and um

856
00:33:54,799 --> 00:33:57,519
so what we uh

857
00:33:57,519 --> 00:34:00,399
we recommend is actually a cryptographic

858
00:34:00,399 --> 00:34:02,799
countermeasure

859
00:34:02,799 --> 00:34:04,240
in the handshake

860
00:34:04,240 --> 00:34:07,840
and there is already a tls extension

861
00:34:07,840 --> 00:34:09,760
called alpn it's application layer

862
00:34:09,760 --> 00:34:12,879
protocol negotiation and this is almost

863
00:34:12,879 --> 00:34:14,480
the perfect fit

864
00:34:14,480 --> 00:34:16,960
so this was not intended for security or

865
00:34:16,960 --> 00:34:19,040
to prevent protocol attacks it's

866
00:34:19,040 --> 00:34:21,839
intended to de multiplex

867
00:34:21,839 --> 00:34:24,800
multiple protocols on the same endpoint

868
00:34:24,800 --> 00:34:27,119
so for example http 1 and 2 are

869
00:34:27,119 --> 00:34:29,280
incompatible but you can serve them on

870
00:34:29,280 --> 00:34:32,399
the same port because tls allows to

871
00:34:32,399 --> 00:34:35,040
specify a list of supported protocols by

872
00:34:35,040 --> 00:34:36,480
the client and then the server can

873
00:34:36,480 --> 00:34:39,280
select one and

874
00:34:39,280 --> 00:34:42,000
return this and then both ends can agree

875
00:34:42,000 --> 00:34:44,320
on one of the protocols

876
00:34:44,320 --> 00:34:47,520
the problem here is first we have to do

877
00:34:47,520 --> 00:34:48,480
this in

878
00:34:48,480 --> 00:34:50,320
the other server that is redirected to

879
00:34:50,320 --> 00:34:52,159
right it's not the web server that's the

880
00:34:52,159 --> 00:34:55,359
problem here but the ftp server

881
00:34:55,359 --> 00:34:58,160
and these servers um

882
00:34:58,160 --> 00:35:00,560
actually do not need a lpn at the moment

883
00:35:00,560 --> 00:35:01,520
so

884
00:35:01,520 --> 00:35:03,599
it's often unsupported and they simply

885
00:35:03,599 --> 00:35:05,839
ignore this extension

886
00:35:05,839 --> 00:35:08,240
and just continue the handshake ignoring

887
00:35:08,240 --> 00:35:09,359
anything that's

888
00:35:09,359 --> 00:35:11,599
given by the client there so what we

889
00:35:11,599 --> 00:35:14,560
actually need is something called strict

890
00:35:14,560 --> 00:35:16,400
lpn validation

891
00:35:16,400 --> 00:35:18,640
where the server detects that this

892
00:35:18,640 --> 00:35:21,040
client is a web server as a

893
00:35:21,040 --> 00:35:22,240
browser

894
00:35:22,240 --> 00:35:23,599
and then

895
00:35:23,599 --> 00:35:25,359
sees that this web

896
00:35:25,359 --> 00:35:27,599
browser actually wants to speak http and

897
00:35:27,599 --> 00:35:30,160
not ftp and so it terminates the

898
00:35:30,160 --> 00:35:31,680
connection early

899
00:35:31,680 --> 00:35:34,560
and this is our recommendation

900
00:35:34,560 --> 00:35:37,040
we have made some progress um

901
00:35:37,040 --> 00:35:38,560
some of the application servers have

902
00:35:38,560 --> 00:35:40,000
already

903
00:35:40,000 --> 00:35:42,400
implemented this and

904
00:35:42,400 --> 00:35:44,560
are slowly updated on the internet

905
00:35:44,560 --> 00:35:46,960
so um this is my talk um i will

906
00:35:46,960 --> 00:35:49,200
summarize shortly

907
00:35:49,200 --> 00:35:51,599
because protocol effects are possible we

908
00:35:51,599 --> 00:35:54,720
have identified 114 000 servers that can

909
00:35:54,720 --> 00:35:56,400
actually be exploited

910
00:35:56,400 --> 00:35:57,359
and

911
00:35:57,359 --> 00:35:59,520
we have recommended strict lpn and

912
00:35:59,520 --> 00:36:01,119
there's another extension sni that can

913
00:36:01,119 --> 00:36:03,839
help a bit um that can prevent these

914
00:36:03,839 --> 00:36:06,400
attacks um for all protocols and all

915
00:36:06,400 --> 00:36:07,599
scenarios

916
00:36:07,599 --> 00:36:08,960
so um

917
00:36:08,960 --> 00:36:10,640
what's left to do there could be more

918
00:36:10,640 --> 00:36:12,160
horsepower protocol attacks on other

919
00:36:12,160 --> 00:36:16,078
protocols and there are also other

920
00:36:16,160 --> 00:36:18,560
security layers like dtls and ipswick

921
00:36:18,560 --> 00:36:20,079
which you have not looked at

922
00:36:20,079 --> 00:36:21,839
so thank you for listening if you need

923
00:36:21,839 --> 00:36:23,359
more information there's a website i

924
00:36:23,359 --> 00:36:26,000
just posted an update with newer numbers

925
00:36:26,000 --> 00:36:27,850
so check it out thank you

926
00:36:27,850 --> 00:36:30,960
[Applause]

927
00:36:34,400 --> 00:36:36,160
thank you

928
00:36:36,160 --> 00:36:38,079
if you have any questions please come to

929
00:36:38,079 --> 00:36:41,320
the mic

930
00:36:45,599 --> 00:36:46,720
hello

931
00:36:46,720 --> 00:36:48,720
thank you for your talk

932
00:36:48,720 --> 00:36:51,520
i was wondering in the scenario where

933
00:36:51,520 --> 00:36:54,000
the victim is visiting the attacker

934
00:36:54,000 --> 00:36:55,200
website

935
00:36:55,200 --> 00:36:58,560
which seems to me like the most

936
00:36:58,560 --> 00:37:00,079
interesting scenario

937
00:37:00,079 --> 00:37:01,200
isn't

938
00:37:01,200 --> 00:37:04,560
the attack limited by current course

939
00:37:04,560 --> 00:37:07,200
policies i think most banks would not

940
00:37:07,200 --> 00:37:10,640
allow a cross-site request from

941
00:37:10,640 --> 00:37:12,640
right okay thank you for your question

942
00:37:12,640 --> 00:37:15,280
can i go back on that i don't know

943
00:37:15,280 --> 00:37:17,520
i don't know if i can

944
00:37:17,520 --> 00:37:19,280
open this slide again but

945
00:37:19,280 --> 00:37:21,040
so the thing is

946
00:37:21,040 --> 00:37:22,880
and there are some requests which are

947
00:37:22,880 --> 00:37:26,000
cross-origin that are called cause safe

948
00:37:26,000 --> 00:37:28,400
like um they are always and allowed in

949
00:37:28,400 --> 00:37:30,960
current the web technologies

950
00:37:30,960 --> 00:37:32,400
they seem to be very important for

951
00:37:32,400 --> 00:37:34,160
compatibility reasons

952
00:37:34,160 --> 00:37:37,280
and so the initial request

953
00:37:37,280 --> 00:37:39,359
always goes through there are many

954
00:37:39,359 --> 00:37:41,359
limitations around this like for example

955
00:37:41,359 --> 00:37:43,359
it may not contain the cookie

956
00:37:43,359 --> 00:37:45,440
or um and the attacker cannot see the

957
00:37:45,440 --> 00:37:46,560
response

958
00:37:46,560 --> 00:37:47,680
but um

959
00:37:47,680 --> 00:37:50,480
what actually um

960
00:37:50,480 --> 00:37:52,480
happens is that we can deal with these

961
00:37:52,480 --> 00:37:54,000
limitations so

962
00:37:54,000 --> 00:37:56,720
in this case um

963
00:37:56,720 --> 00:37:58,240
the um

964
00:37:58,240 --> 00:38:00,079
for example in the second scenario i

965
00:38:00,079 --> 00:38:02,079
gave the example the the response is

966
00:38:02,079 --> 00:38:03,520
discarded because the attacker cannot

967
00:38:03,520 --> 00:38:04,800
read it anyway

968
00:38:04,800 --> 00:38:07,599
and then um

969
00:38:07,599 --> 00:38:10,000
this works we have to navigate all these

970
00:38:10,000 --> 00:38:10,960
issues

971
00:38:10,960 --> 00:38:13,440
but um there are always some

972
00:38:13,440 --> 00:38:14,960
some scenarios where it works and it

973
00:38:14,960 --> 00:38:16,960
doesn't work in all cws but in fact we

974
00:38:16,960 --> 00:38:19,680
can we can do more in our paper we also

975
00:38:19,680 --> 00:38:21,760
did the complete attack in some cases

976
00:38:21,760 --> 00:38:23,040
without any and

977
00:38:23,040 --> 00:38:24,800
many in the middle at all

978
00:38:24,800 --> 00:38:26,720
so to check it out it depends on the

979
00:38:26,720 --> 00:38:30,160
cookie policies and in many details

980
00:38:30,160 --> 00:38:32,400
okay thank you but in this particular

981
00:38:32,400 --> 00:38:34,560
case it will not work because post is

982
00:38:34,560 --> 00:38:35,520
not

983
00:38:35,520 --> 00:38:37,760
course safe right like it would trigger

984
00:38:37,760 --> 00:38:39,200
a pre-order

985
00:38:39,200 --> 00:38:41,200
yes you can control the header but you

986
00:38:41,200 --> 00:38:42,960
can control the body this is perfectly

987
00:38:42,960 --> 00:38:43,839
fine

988
00:38:43,839 --> 00:38:46,480
if you can get an implementation of this

989
00:38:46,480 --> 00:38:48,240
you get to download the source code and

990
00:38:48,240 --> 00:38:49,920
actually run the attack on locally on

991
00:38:49,920 --> 00:38:50,880
your machine

992
00:38:50,880 --> 00:38:54,079
okay perfect thank you

993
00:38:55,599 --> 00:38:58,560
any other question

994
00:38:59,520 --> 00:39:02,160
okay so i don't see any questions julie

995
00:39:02,160 --> 00:39:04,079
but you can still ask them later if you

996
00:39:04,079 --> 00:39:05,119
want

997
00:39:05,119 --> 00:39:09,880
let's thank marcus again please

998
00:39:14,670 --> 00:39:17,599
[Applause]

999
00:39:17,599 --> 00:39:20,960
so our next talk will be given by mike

1000
00:39:20,960 --> 00:39:22,240
hamburg

1001
00:39:22,240 --> 00:39:25,440
so i don't know if mike is online but i

1002
00:39:25,440 --> 00:39:28,880
think that the thing is

1003
00:39:28,880 --> 00:39:31,440
yeah okay hello everyone and welcome to

1004
00:39:31,440 --> 00:39:33,040
improved certificate revocation list

1005
00:39:33,040 --> 00:39:34,480
compression with structured linear

1006
00:39:34,480 --> 00:39:36,400
functions i'm mike hamberg with rambus

1007
00:39:36,400 --> 00:39:38,400
labs

1008
00:39:38,400 --> 00:39:40,079
so the motivating problem for this talk

1009
00:39:40,079 --> 00:39:42,400
is certificate revocation so we all know

1010
00:39:42,400 --> 00:39:44,079
what a certificate is so this is a

1011
00:39:44,079 --> 00:39:46,079
document that binds some parties

1012
00:39:46,079 --> 00:39:48,079
identifying information to their public

1013
00:39:48,079 --> 00:39:50,640
key for a limited validity period

1014
00:39:50,640 --> 00:39:52,640
and it's all signed by a trusted third

1015
00:39:52,640 --> 00:39:54,880
party called a certificate authority

1016
00:39:54,880 --> 00:39:57,200
so to verify one of these you need to

1017
00:39:57,200 --> 00:39:59,280
know the ca's public key

1018
00:39:59,280 --> 00:40:01,119
you need to know what time it is but

1019
00:40:01,119 --> 00:40:02,880
also you need to know whether the cert

1020
00:40:02,880 --> 00:40:04,880
has been revoked which could happen for

1021
00:40:04,880 --> 00:40:08,160
each cert at any time

1022
00:40:08,400 --> 00:40:10,400
a popular way to do this these days is

1023
00:40:10,400 --> 00:40:12,000
called the online certificate status

1024
00:40:12,000 --> 00:40:14,880
protocol or ocsp where conceptually you

1025
00:40:14,880 --> 00:40:17,040
just ask the ca hey is this still valid

1026
00:40:17,040 --> 00:40:19,119
and they send you a signed response

1027
00:40:19,119 --> 00:40:20,640
if you were to have the client do this

1028
00:40:20,640 --> 00:40:22,720
it would have serious privacy and late

1029
00:40:22,720 --> 00:40:24,640
privacy and latency issues

1030
00:40:24,640 --> 00:40:26,560
but these can be mitigated in the

1031
00:40:26,560 --> 00:40:28,720
context of tls by having the server do

1032
00:40:28,720 --> 00:40:31,119
the lookup instead and cache the result

1033
00:40:31,119 --> 00:40:33,119
it is however a single point of failure

1034
00:40:33,119 --> 00:40:35,040
for establishing secure connections or

1035
00:40:35,040 --> 00:40:36,480
whatever else you are thinking of doing

1036
00:40:36,480 --> 00:40:39,920
with those certs for example in 2020

1037
00:40:39,920 --> 00:40:42,160
apple's ocsp server went down they were

1038
00:40:42,160 --> 00:40:44,160
using it to

1039
00:40:44,160 --> 00:40:46,480
validate code signing certs and as a

1040
00:40:46,480 --> 00:40:48,079
result people couldn't launch apps on

1041
00:40:48,079 --> 00:40:49,920
their own machines

1042
00:40:49,920 --> 00:40:51,440
fundamentally the online certificate

1043
00:40:51,440 --> 00:40:54,240
status protocol also only works if the

1044
00:40:54,240 --> 00:40:55,520
parties that are verifying the

1045
00:40:55,520 --> 00:40:57,599
certificates are online

1046
00:40:57,599 --> 00:40:59,040
so for example if they are something

1047
00:40:59,040 --> 00:41:01,200
like a connected car which may have

1048
00:41:01,200 --> 00:41:03,359
intermittent internet access but might

1049
00:41:03,359 --> 00:41:04,800
for example be going through a tunnel

1050
00:41:04,800 --> 00:41:06,720
and not have it right now

1051
00:41:06,720 --> 00:41:09,119
then you can't easily use this to

1052
00:41:09,119 --> 00:41:11,040
validate the certs

1053
00:41:11,040 --> 00:41:12,000
of

1054
00:41:12,000 --> 00:41:14,890
this car and other cars

1055
00:41:14,890 --> 00:41:16,079
[Music]

1056
00:41:16,079 --> 00:41:17,599
an alternative approach that's much

1057
00:41:17,599 --> 00:41:18,720
older

1058
00:41:18,720 --> 00:41:20,880
and solve some of these problems is

1059
00:41:20,880 --> 00:41:22,640
certificate revocation lists so

1060
00:41:22,640 --> 00:41:24,880
conceptually the ca just publishes a

1061
00:41:24,880 --> 00:41:26,960
list of the certs that they've revoked

1062
00:41:26,960 --> 00:41:28,480
um they don't need to include the

1063
00:41:28,480 --> 00:41:30,400
expired ones and the client keeps this

1064
00:41:30,400 --> 00:41:32,160
list up to date and then when they get

1065
00:41:32,160 --> 00:41:34,480
assert they can check offline and

1066
00:41:34,480 --> 00:41:36,240
privately whether that cert was revoked

1067
00:41:36,240 --> 00:41:37,599
as of the last time they updated the

1068
00:41:37,599 --> 00:41:38,480
list

1069
00:41:38,480 --> 00:41:39,920
the problem of course is that there are

1070
00:41:39,920 --> 00:41:41,520
a lot of certs on the internet so these

1071
00:41:41,520 --> 00:41:43,359
crls are huge and they must also be

1072
00:41:43,359 --> 00:41:45,040
distributed to all the devices on the

1073
00:41:45,040 --> 00:41:46,560
internet

1074
00:41:46,560 --> 00:41:48,240
so you can tackle this problem using

1075
00:41:48,240 --> 00:41:50,240
conventional compression technologies

1076
00:41:50,240 --> 00:41:51,839
but it's still a huge logistical

1077
00:41:51,839 --> 00:41:54,240
challenge

1078
00:41:54,400 --> 00:41:56,240
an approach for improving this that has

1079
00:41:56,240 --> 00:41:58,000
been discussed at real world crypto

1080
00:41:58,000 --> 00:41:59,920
before and has now been deployed in

1081
00:41:59,920 --> 00:42:02,800
mozilla firefox and telemetry mode is cr

1082
00:42:02,800 --> 00:42:03,760
light

1083
00:42:03,760 --> 00:42:05,920
so the key observation of cr light is

1084
00:42:05,920 --> 00:42:08,079
that with a conventional compression

1085
00:42:08,079 --> 00:42:10,160
mechanism the client would get at the

1086
00:42:10,160 --> 00:42:12,640
end of the day a list of all the revoked

1087
00:42:12,640 --> 00:42:14,880
certs from some certificate authority

1088
00:42:14,880 --> 00:42:16,640
but they don't actually need that what

1089
00:42:16,640 --> 00:42:19,760
they need is a way to decide given some

1090
00:42:19,760 --> 00:42:21,680
cert that the ca issued

1091
00:42:21,680 --> 00:42:23,920
whether that cert is revoked or not and

1092
00:42:23,920 --> 00:42:26,240
the ca only issued a limited number of

1093
00:42:26,240 --> 00:42:29,440
certs in a given time period

1094
00:42:29,440 --> 00:42:32,000
so this is in some sense a problem of

1095
00:42:32,000 --> 00:42:35,119
compressing a function that takes a cert

1096
00:42:35,119 --> 00:42:37,440
issued by some ca in a given time period

1097
00:42:37,440 --> 00:42:41,520
and returns either valid or revoked

1098
00:42:41,839 --> 00:42:42,560
so

1099
00:42:42,560 --> 00:42:46,000
if you put suitable metadata on this

1100
00:42:46,000 --> 00:42:48,640
compressed database then the client will

1101
00:42:48,640 --> 00:42:51,040
only query it for

1102
00:42:51,040 --> 00:42:53,119
certificates that the ca actually issued

1103
00:42:53,119 --> 00:42:56,400
in that time period which either the ca

1104
00:42:56,400 --> 00:42:58,720
or an aggregator in the case of firefox

1105
00:42:58,720 --> 00:43:00,560
this is mozilla

1106
00:43:00,560 --> 00:43:03,440
can collect from ct logs or from their

1107
00:43:03,440 --> 00:43:05,839
own logs

1108
00:43:05,839 --> 00:43:07,839
and so as a result you only need to

1109
00:43:07,839 --> 00:43:10,160
build a function that is correct

1110
00:43:10,160 --> 00:43:13,200
when queried on uh elements of a certain

1111
00:43:13,200 --> 00:43:15,040
finite predetermined domain the certs

1112
00:43:15,040 --> 00:43:16,960
that were actually issued

1113
00:43:16,960 --> 00:43:18,560
because queries will not be made outside

1114
00:43:18,560 --> 00:43:20,400
that domain you don't have to care what

1115
00:43:20,400 --> 00:43:21,839
answer the client would get if they did

1116
00:43:21,839 --> 00:43:23,920
that

1117
00:43:23,920 --> 00:43:26,720
this can be more efficient than a crl

1118
00:43:26,720 --> 00:43:28,480
because fundamentally you're conveying

1119
00:43:28,480 --> 00:43:31,359
less information

1120
00:43:32,160 --> 00:43:33,599
in data structures research this is

1121
00:43:33,599 --> 00:43:35,760
called a static function and to the best

1122
00:43:35,760 --> 00:43:37,119
of my knowledge the state of the art in

1123
00:43:37,119 --> 00:43:39,200
this area is what i will call structured

1124
00:43:39,200 --> 00:43:42,000
linear functions

1125
00:43:42,960 --> 00:43:44,640
so here's how a structured linear

1126
00:43:44,640 --> 00:43:47,200
function works the idea is to encode the

1127
00:43:47,200 --> 00:43:50,000
function as a hash function doesn't even

1128
00:43:50,000 --> 00:43:52,160
have to be a cryptographic hash function

1129
00:43:52,160 --> 00:43:55,359
and as a matrix m over some field

1130
00:43:55,359 --> 00:43:56,960
i'll tell you first how to query this

1131
00:43:56,960 --> 00:43:57,760
map

1132
00:43:57,760 --> 00:44:01,359
the idea is that you hash your input

1133
00:44:01,359 --> 00:44:03,119
with the hash function to get a sparse

1134
00:44:03,119 --> 00:44:05,599
vector w over the same field

1135
00:44:05,599 --> 00:44:08,640
then the query result is m times that

1136
00:44:08,640 --> 00:44:10,880
sparse vector you can evaluate this

1137
00:44:10,880 --> 00:44:14,319
quickly because to multiply m by sparse

1138
00:44:14,319 --> 00:44:16,079
vector you only need to look up a few

1139
00:44:16,079 --> 00:44:18,560
coefficients of m

1140
00:44:18,560 --> 00:44:20,800
so if that's how you query this how do

1141
00:44:20,800 --> 00:44:23,280
you do the encoding well we have these

1142
00:44:23,280 --> 00:44:25,599
constraints on

1143
00:44:25,599 --> 00:44:26,880
on the

1144
00:44:26,880 --> 00:44:29,359
on m which is that

1145
00:44:29,359 --> 00:44:32,240
it has to give the right answer for all

1146
00:44:32,240 --> 00:44:34,640
of our predetermined inputs so in other

1147
00:44:34,640 --> 00:44:37,440
words m times each w must be the

1148
00:44:37,440 --> 00:44:39,760
corresponding answer

1149
00:44:39,760 --> 00:44:42,000
we can combine these into one linear

1150
00:44:42,000 --> 00:44:45,440
system m times the matrix of all the w's

1151
00:44:45,440 --> 00:44:48,240
gives the matrix of all the answers

1152
00:44:48,240 --> 00:44:49,839
this is an affine

1153
00:44:49,839 --> 00:44:52,480
equation with respect to m

1154
00:44:52,480 --> 00:44:54,640
so we can solve it

1155
00:44:54,640 --> 00:44:55,599
putting

1156
00:44:55,599 --> 00:44:57,040
m here on the right giving this

1157
00:44:57,040 --> 00:44:58,960
transposed equation

1158
00:44:58,960 --> 00:45:00,400
furthermore

1159
00:45:00,400 --> 00:45:02,800
you can note that if this matrix is

1160
00:45:02,800 --> 00:45:05,440
roughly square then the amount of

1161
00:45:05,440 --> 00:45:07,680
information contained in m

1162
00:45:07,680 --> 00:45:10,240
is going to be almost exactly the same

1163
00:45:10,240 --> 00:45:12,240
as the amount of information contained

1164
00:45:12,240 --> 00:45:14,160
in each of the answers

1165
00:45:14,160 --> 00:45:15,440
in that sense

1166
00:45:15,440 --> 00:45:17,680
the

1167
00:45:17,839 --> 00:45:20,640
this encoding process will be nearly

1168
00:45:20,640 --> 00:45:22,640
perfectly efficient with regard to the

1169
00:45:22,640 --> 00:45:25,040
information content of the mapping

1170
00:45:25,040 --> 00:45:27,920
you're trying to compress

1171
00:45:29,119 --> 00:45:30,839
so how does this work

1172
00:45:30,839 --> 00:45:33,920
so in the original proposal matrix

1173
00:45:33,920 --> 00:45:35,040
filters

1174
00:45:35,040 --> 00:45:37,440
the hash function returns a vector of a

1175
00:45:37,440 --> 00:45:40,720
fixed hemming weight k i.e it's

1176
00:45:40,720 --> 00:45:43,119
1 or non-zero over the field

1177
00:45:43,119 --> 00:45:45,920
in k positions

1178
00:45:45,920 --> 00:45:47,359
in each row

1179
00:45:47,359 --> 00:45:48,560
plus

1180
00:45:48,560 --> 00:45:50,640
there's this these augmented columns

1181
00:45:50,640 --> 00:45:52,240
representing the answer

1182
00:45:52,240 --> 00:45:54,240
and then you solve this matrix using

1183
00:45:54,240 --> 00:45:55,839
gaussian elimination

1184
00:45:55,839 --> 00:45:57,440
unfortunately while the matrix starts

1185
00:45:57,440 --> 00:45:59,200
out sparse

1186
00:45:59,200 --> 00:46:00,400
as you solve it with gaussian

1187
00:46:00,400 --> 00:46:03,760
elimination it fills in and as a result

1188
00:46:03,760 --> 00:46:05,599
the solution process takes approximately

1189
00:46:05,599 --> 00:46:08,240
o of n cubed time and o of n squared

1190
00:46:08,240 --> 00:46:08,900
memory

1191
00:46:08,900 --> 00:46:10,560
[Music]

1192
00:46:10,560 --> 00:46:12,800
if n is the number of certs on the

1193
00:46:12,800 --> 00:46:14,480
internet or even the number of revoked

1194
00:46:14,480 --> 00:46:16,400
certs on the internet say in the

1195
00:46:16,400 --> 00:46:19,680
millions then n cubed time and n cubed n

1196
00:46:19,680 --> 00:46:22,720
squared memory is impractical

1197
00:46:22,720 --> 00:46:24,720
you can mitigate this issue by breaking

1198
00:46:24,720 --> 00:46:26,720
the database into smaller shards that

1199
00:46:26,720 --> 00:46:29,280
can be processed more efficiently

1200
00:46:29,280 --> 00:46:30,880
however this reduces the compression

1201
00:46:30,880 --> 00:46:35,359
efficiency and increases complexity

1202
00:46:35,920 --> 00:46:37,920
an alternative approach

1203
00:46:37,920 --> 00:46:42,400
proposed in 2009 is peeling so using a

1204
00:46:42,400 --> 00:46:45,280
very similar distribution of rows

1205
00:46:45,280 --> 00:46:47,440
but making the rows

1206
00:46:47,440 --> 00:46:50,079
approximately 23 percent longer i.e

1207
00:46:50,079 --> 00:46:51,839
making the the matrix you're trying to

1208
00:46:51,839 --> 00:46:55,440
solve 23 percent wider than it is tall

1209
00:46:55,440 --> 00:46:57,760
it turns out that you can solve such a

1210
00:46:57,760 --> 00:47:00,160
matrix with high probability simply by

1211
00:47:00,160 --> 00:47:02,079
permuting the rows and columns into row

1212
00:47:02,079 --> 00:47:04,960
echelon form this takes only linear time

1213
00:47:04,960 --> 00:47:06,560
and linear memory

1214
00:47:06,560 --> 00:47:08,480
however making the matrix

1215
00:47:08,480 --> 00:47:10,800
wider than it is tall

1216
00:47:10,800 --> 00:47:12,960
means that the encoding that you solve

1217
00:47:12,960 --> 00:47:15,599
for will be longer than

1218
00:47:15,599 --> 00:47:17,680
it would have otherwise been so for

1219
00:47:17,680 --> 00:47:19,520
example with a zoro filter

1220
00:47:19,520 --> 00:47:21,839
you will produce an encoding that's 23

1221
00:47:21,839 --> 00:47:25,599
percent longer than the optimal encoding

1222
00:47:25,599 --> 00:47:27,920
recent research has improved this

1223
00:47:27,920 --> 00:47:30,160
down to as low as seven percent with a

1224
00:47:30,160 --> 00:47:32,640
four-way binary fuse filter but there

1225
00:47:32,640 --> 00:47:36,920
still is this overhead

1226
00:47:38,000 --> 00:47:39,760
alternative approach that trades off

1227
00:47:39,760 --> 00:47:42,559
compression efficiency versus speed is

1228
00:47:42,559 --> 00:47:43,839
ribbon filters

1229
00:47:43,839 --> 00:47:45,760
so the idea of a ribbon filter is that

1230
00:47:45,760 --> 00:47:47,839
instead of hashing to a vector with

1231
00:47:47,839 --> 00:47:49,520
fixed hemming weight you hash to a

1232
00:47:49,520 --> 00:47:51,040
vector which is

1233
00:47:51,040 --> 00:47:53,440
non-zero only in a certain interval that

1234
00:47:53,440 --> 00:47:54,960
is randomly placed or rather

1235
00:47:54,960 --> 00:47:56,559
pseudorandomly placed by the output of

1236
00:47:56,559 --> 00:47:58,720
the hash function and its contents are

1237
00:47:58,720 --> 00:48:00,720
uniformly pseudo-random

1238
00:48:00,720 --> 00:48:03,359
when you sort the rows which doesn't

1239
00:48:03,359 --> 00:48:04,480
change the

1240
00:48:04,480 --> 00:48:07,680
output of the the solution of the matrix

1241
00:48:07,680 --> 00:48:10,480
then you get a matrix that is banded

1242
00:48:10,480 --> 00:48:12,880
and when you solve a banded matrix using

1243
00:48:12,880 --> 00:48:15,040
gaussian elimination it doesn't fill in

1244
00:48:15,040 --> 00:48:17,119
outside the band so this makes the

1245
00:48:17,119 --> 00:48:18,800
solution procedure efficient in terms of

1246
00:48:18,800 --> 00:48:21,200
time and memory

1247
00:48:21,200 --> 00:48:23,520
however there is a catch which is that

1248
00:48:23,520 --> 00:48:25,839
these banded matrices if the band is too

1249
00:48:25,839 --> 00:48:28,960
narrow won't actually have a solution

1250
00:48:28,960 --> 00:48:30,800
this can be mitigated by making the

1251
00:48:30,800 --> 00:48:32,640
matrix slightly wider than it is tall

1252
00:48:32,640 --> 00:48:34,559
enabling a trade-off of the width of the

1253
00:48:34,559 --> 00:48:36,240
band which

1254
00:48:36,240 --> 00:48:38,400
increases the time used to compress the

1255
00:48:38,400 --> 00:48:41,119
matrix against the compression

1256
00:48:41,119 --> 00:48:43,680
efficiency

1257
00:48:43,680 --> 00:48:45,440
today i'm proposing a new solution to

1258
00:48:45,440 --> 00:48:47,200
this problem which is frayed ribbon

1259
00:48:47,200 --> 00:48:50,480
filters so for this you hash each input

1260
00:48:50,480 --> 00:48:52,400
to a row that

1261
00:48:52,400 --> 00:48:54,720
has two blocks of uniformly random

1262
00:48:54,720 --> 00:48:56,880
values the two blocks are usually right

1263
00:48:56,880 --> 00:48:58,240
next to each other but they may have a

1264
00:48:58,240 --> 00:48:59,680
gap between them with decreasing

1265
00:48:59,680 --> 00:49:02,800
probabilities for wider caps if you sort

1266
00:49:02,800 --> 00:49:04,319
such a matrix

1267
00:49:04,319 --> 00:49:06,640
you'll get this blocky because the

1268
00:49:06,640 --> 00:49:09,440
blocks are the intervals are aligned

1269
00:49:09,440 --> 00:49:12,319
blocky frayed looking structure

1270
00:49:12,319 --> 00:49:14,240
it's not obvious that you can solve this

1271
00:49:14,240 --> 00:49:15,760
efficiently and in fact with gaussian

1272
00:49:15,760 --> 00:49:17,760
elimination it would not be fast

1273
00:49:17,760 --> 00:49:19,280
but it turns out that there's a

1274
00:49:19,280 --> 00:49:20,559
specialized

1275
00:49:20,559 --> 00:49:21,920
solution tactic that works for these

1276
00:49:21,920 --> 00:49:24,000
matrices so the idea is to pair up

1277
00:49:24,000 --> 00:49:25,359
adjacent blocks

1278
00:49:25,359 --> 00:49:28,079
and then solve them to systematic form

1279
00:49:28,079 --> 00:49:30,079
and then we can project them out of the

1280
00:49:30,079 --> 00:49:32,160
rest of the matrix and recurse on the

1281
00:49:32,160 --> 00:49:34,400
next size blocks

1282
00:49:34,400 --> 00:49:35,839
as we do this the matrix fills in a

1283
00:49:35,839 --> 00:49:39,119
little bit heuristically it should

1284
00:49:39,119 --> 00:49:40,079
have

1285
00:49:40,079 --> 00:49:42,079
it should enable solution of nearly

1286
00:49:42,079 --> 00:49:45,200
square matrices so nearly optimal

1287
00:49:45,200 --> 00:49:47,280
compression size in time that is around

1288
00:49:47,280 --> 00:49:49,280
o of n to the three halves though in

1289
00:49:49,280 --> 00:49:51,119
practice it's dominated by lower order

1290
00:49:51,119 --> 00:49:54,960
terms such as moving memory around

1291
00:49:55,040 --> 00:49:57,599
so in comparison to previous work

1292
00:49:57,599 --> 00:50:00,240
this is suitable for both static

1293
00:50:00,240 --> 00:50:01,440
functions and something called

1294
00:50:01,440 --> 00:50:03,040
approximate sets that i will get to in a

1295
00:50:03,040 --> 00:50:04,240
second

1296
00:50:04,240 --> 00:50:06,720
it has a much lower overhead than other

1297
00:50:06,720 --> 00:50:08,559
previous work that is suitable for these

1298
00:50:08,559 --> 00:50:09,440
things

1299
00:50:09,440 --> 00:50:11,520
other than the very slow

1300
00:50:11,520 --> 00:50:14,640
sore filters or zorsat filters

1301
00:50:14,640 --> 00:50:15,920
and

1302
00:50:15,920 --> 00:50:18,319
it has a

1303
00:50:18,319 --> 00:50:20,240
about an order of magnitude slower

1304
00:50:20,240 --> 00:50:22,559
builds time than previous work however

1305
00:50:22,559 --> 00:50:24,960
queries are still quite fast the build

1306
00:50:24,960 --> 00:50:27,119
time might seem like a bad thing but if

1307
00:50:27,119 --> 00:50:28,640
you're only doing this a couple of times

1308
00:50:28,640 --> 00:50:30,880
per day then spending 1.3 microseconds

1309
00:50:30,880 --> 00:50:32,200
per item isn't a problem

1310
00:50:32,200 --> 00:50:34,079
[Music]

1311
00:50:34,079 --> 00:50:37,119
so in summary we have an encoding

1312
00:50:37,119 --> 00:50:38,960
for compressing maps

1313
00:50:38,960 --> 00:50:41,440
that has nearly optimal efficiency fast

1314
00:50:41,440 --> 00:50:43,680
queries and fast enough build times and

1315
00:50:43,680 --> 00:50:45,200
it scales to hundreds of millions of

1316
00:50:45,200 --> 00:50:48,720
rows before you run out of memory

1317
00:50:48,960 --> 00:50:50,960
so it would seem

1318
00:50:50,960 --> 00:50:53,680
uh are done in creating a better

1319
00:50:53,680 --> 00:50:56,559
compression function for cr light

1320
00:50:56,559 --> 00:50:59,040
however we still haven't used a key fact

1321
00:50:59,040 --> 00:51:01,680
about crls which is that 99 of certs at

1322
00:51:01,680 --> 00:51:03,839
a given time aren't revoked

1323
00:51:03,839 --> 00:51:06,559
and so actually the crl has less

1324
00:51:06,559 --> 00:51:09,280
information than one bit per

1325
00:51:09,280 --> 00:51:11,280
issued cert the amount of information

1326
00:51:11,280 --> 00:51:13,440
contained in it should be described by

1327
00:51:13,440 --> 00:51:15,520
the shannon entropy

1328
00:51:15,520 --> 00:51:18,240
which is about 12 times smaller so

1329
00:51:18,240 --> 00:51:20,000
we would like to get down closer to the

1330
00:51:20,000 --> 00:51:21,359
shannon entropy

1331
00:51:21,359 --> 00:51:23,119
to do that let's

1332
00:51:23,119 --> 00:51:26,480
see our light compresses its databases

1333
00:51:26,480 --> 00:51:28,480
so crlight uses a primitive called

1334
00:51:28,480 --> 00:51:30,720
approximate set membership

1335
00:51:30,720 --> 00:51:33,040
it uses specifically bloom filters

1336
00:51:33,040 --> 00:51:34,640
and these are closely related to static

1337
00:51:34,640 --> 00:51:35,680
functions

1338
00:51:35,680 --> 00:51:38,480
the idea is that you have a set s of

1339
00:51:38,480 --> 00:51:40,480
objects and you want to compress it so

1340
00:51:40,480 --> 00:51:42,000
that from the compressed form you can

1341
00:51:42,000 --> 00:51:45,200
query whether an object was in the set

1342
00:51:45,200 --> 00:51:47,040
when the when you query it on an object

1343
00:51:47,040 --> 00:51:49,280
that actually was in the set it always

1344
00:51:49,280 --> 00:51:51,280
will return yes

1345
00:51:51,280 --> 00:51:53,200
however there are exponentially more

1346
00:51:53,200 --> 00:51:54,960
objects not in the set and if you query

1347
00:51:54,960 --> 00:51:57,680
on one of those in most cases the the

1348
00:51:57,680 --> 00:52:00,000
query will return no it's not in the set

1349
00:52:00,000 --> 00:52:01,200
but there is a false positive

1350
00:52:01,200 --> 00:52:02,960
probability epsilon

1351
00:52:02,960 --> 00:52:05,040
the size of the approximate set

1352
00:52:05,040 --> 00:52:06,240
structure

1353
00:52:06,240 --> 00:52:07,920
trades off against

1354
00:52:07,920 --> 00:52:10,640
the false positive probability epsilon

1355
00:52:10,640 --> 00:52:12,720
so the trade-off for bloom filters is

1356
00:52:12,720 --> 00:52:15,680
not optimal it uses about 44 percent

1357
00:52:15,680 --> 00:52:17,200
more space

1358
00:52:17,200 --> 00:52:18,559
than what you would get if you

1359
00:52:18,559 --> 00:52:21,200
constructed a an approximate set based

1360
00:52:21,200 --> 00:52:23,599
on freight ribbon filters

1361
00:52:23,599 --> 00:52:25,280
in general you can construct these

1362
00:52:25,280 --> 00:52:27,040
approximate sets using any static

1363
00:52:27,040 --> 00:52:29,359
function

1364
00:52:31,200 --> 00:52:34,400
so how crlight uses these bloom filters

1365
00:52:34,400 --> 00:52:36,960
um is that it stacks them in a cascade

1366
00:52:36,960 --> 00:52:38,640
so the idea is it

1367
00:52:38,640 --> 00:52:40,880
creates at a first level

1368
00:52:40,880 --> 00:52:43,040
um a bloom filter containing all the

1369
00:52:43,040 --> 00:52:45,119
revoked certs in the data set and so

1370
00:52:45,119 --> 00:52:46,960
then when the client gets assert and

1371
00:52:46,960 --> 00:52:48,880
they do a lookup into this

1372
00:52:48,880 --> 00:52:50,640
if it says no this is not revoked then

1373
00:52:50,640 --> 00:52:52,319
because bloom filters have no false

1374
00:52:52,319 --> 00:52:53,839
negatives then the client knows that

1375
00:52:53,839 --> 00:52:55,839
indeed the cert is not revoked or was

1376
00:52:55,839 --> 00:52:57,520
not as of the time that the database was

1377
00:52:57,520 --> 00:53:00,000
compiled however if it says yes this is

1378
00:53:00,000 --> 00:53:01,520
revoked then the client doesn't know if

1379
00:53:01,520 --> 00:53:03,200
it's really revoked or if it's a false

1380
00:53:03,200 --> 00:53:05,119
positive in the bloom filter

1381
00:53:05,119 --> 00:53:07,599
however the aggregator or the ca if the

1382
00:53:07,599 --> 00:53:09,920
ca is doing this compression has a list

1383
00:53:09,920 --> 00:53:11,599
of all valid certs that were issued

1384
00:53:11,599 --> 00:53:13,920
during that period and so they know a

1385
00:53:13,920 --> 00:53:16,720
list of all the false positives

1386
00:53:16,720 --> 00:53:18,240
so they can construct a second bloom

1387
00:53:18,240 --> 00:53:20,079
filter which contains all the false

1388
00:53:20,079 --> 00:53:23,839
positives in the level 1 table so if the

1389
00:53:23,839 --> 00:53:25,280
client gets a positive in the first

1390
00:53:25,280 --> 00:53:26,960
table they can do a lookup into the

1391
00:53:26,960 --> 00:53:28,559
second table to determine whether it was

1392
00:53:28,559 --> 00:53:30,480
a false positive or a true one

1393
00:53:30,480 --> 00:53:32,400
however this second table is also a

1394
00:53:32,400 --> 00:53:33,920
bloom filter

1395
00:53:33,920 --> 00:53:36,240
or an approximate set in general

1396
00:53:36,240 --> 00:53:38,720
and so it also has false positives so we

1397
00:53:38,720 --> 00:53:40,480
need a third level and a fourth one and

1398
00:53:40,480 --> 00:53:43,040
so on these levels become exponentially

1399
00:53:43,040 --> 00:53:45,200
smaller and so you only need log n

1400
00:53:45,200 --> 00:53:47,598
levels

1401
00:53:48,960 --> 00:53:51,119
in this new work i propose using instead

1402
00:53:51,119 --> 00:53:53,200
a two level cascade that takes advantage

1403
00:53:53,200 --> 00:53:55,599
of both static functions and approximate

1404
00:53:55,599 --> 00:53:56,720
sets

1405
00:53:56,720 --> 00:53:58,960
as in cr light at the first level

1406
00:53:58,960 --> 00:54:00,880
you build an approximate set containing

1407
00:54:00,880 --> 00:54:02,880
all the revoked certs

1408
00:54:02,880 --> 00:54:04,640
this gives you some list of false

1409
00:54:04,640 --> 00:54:06,240
positives and of course the true

1410
00:54:06,240 --> 00:54:08,319
positives which is the certs that were

1411
00:54:08,319 --> 00:54:09,680
revoked

1412
00:54:09,680 --> 00:54:12,160
and then at the second level you compile

1413
00:54:12,160 --> 00:54:13,760
a static function that maps the false

1414
00:54:13,760 --> 00:54:15,599
positives to zero and the true positives

1415
00:54:15,599 --> 00:54:17,200
to one

1416
00:54:17,200 --> 00:54:18,960
because the static function always gives

1417
00:54:18,960 --> 00:54:20,640
the correct answer

1418
00:54:20,640 --> 00:54:22,800
you don't need a level three

1419
00:54:22,800 --> 00:54:25,200
by tuning the false positive probability

1420
00:54:25,200 --> 00:54:26,559
of the first level

1421
00:54:26,559 --> 00:54:29,359
you can guarantee that the size of this

1422
00:54:29,359 --> 00:54:32,079
cascade is always asymptotically within

1423
00:54:32,079 --> 00:54:34,480
11 percent of the shannon entropy

1424
00:54:34,480 --> 00:54:38,480
of the distribution of values in the map

1425
00:54:38,480 --> 00:54:40,240
so this is for

1426
00:54:40,240 --> 00:54:42,480
binary maps that is things that output

1427
00:54:42,480 --> 00:54:44,160
zero and one but there's a

1428
00:54:44,160 --> 00:54:46,480
generalization to

1429
00:54:46,480 --> 00:54:49,440
functions with any finite codomain

1430
00:54:49,440 --> 00:54:52,880
that is still guarantees that the

1431
00:54:52,880 --> 00:54:54,880
encoded size is within 11 percent of the

1432
00:54:54,880 --> 00:54:56,960
shannon entropy although it may use more

1433
00:54:56,960 --> 00:54:59,680
than two levels

1434
00:55:01,760 --> 00:55:04,000
i prototyped this system

1435
00:55:04,000 --> 00:55:05,359
using rust

1436
00:55:05,359 --> 00:55:09,040
um and i've published it on github

1437
00:55:09,040 --> 00:55:10,720
the prototype

1438
00:55:10,720 --> 00:55:14,000
is mit licensed and it also uses a new

1439
00:55:14,000 --> 00:55:16,880
research grade matrix solver over gf2

1440
00:55:16,880 --> 00:55:18,880
which is very efficient and maybe of

1441
00:55:18,880 --> 00:55:20,799
independent interest i wrote this

1442
00:55:20,799 --> 00:55:23,359
because i could not find an appropriate

1443
00:55:23,359 --> 00:55:27,280
f2 matrix solver that was mit licensed

1444
00:55:27,280 --> 00:55:29,760
in comparison to cr light

1445
00:55:29,760 --> 00:55:32,240
if you have uh as an example given in

1446
00:55:32,240 --> 00:55:34,799
the cr light paper 100 million certs of

1447
00:55:34,799 --> 00:55:37,440
which 700 000 are revoked and you plug

1448
00:55:37,440 --> 00:55:39,839
this into the new frayed ribbon filter

1449
00:55:39,839 --> 00:55:42,079
then it takes about 12 seconds to

1450
00:55:42,079 --> 00:55:44,400
compress it which is about a quarter of

1451
00:55:44,400 --> 00:55:46,160
the time that it takes to generate that

1452
00:55:46,160 --> 00:55:47,760
many

1453
00:55:47,760 --> 00:55:51,119
fake cert hashes at random

1454
00:55:51,119 --> 00:55:53,520
it takes tens to hundreds of nanoseconds

1455
00:55:53,520 --> 00:55:55,760
to query and produces about 800

1456
00:55:55,760 --> 00:55:57,839
kilobytes of output which is six percent

1457
00:55:57,839 --> 00:55:59,839
over the shannon limit

1458
00:55:59,839 --> 00:56:02,480
by comparison cr light produces

1459
00:56:02,480 --> 00:56:05,760
about 1.3 to 1.4 megabytes of output

1460
00:56:05,760 --> 00:56:07,680
crlight is also much slower to compress

1461
00:56:07,680 --> 00:56:09,040
this database but only because it's

1462
00:56:09,040 --> 00:56:10,799
written in python because it doesn't

1463
00:56:10,799 --> 00:56:12,640
really matter whether it takes a couple

1464
00:56:12,640 --> 00:56:14,000
seconds or a couple minutes for a

1465
00:56:14,000 --> 00:56:15,359
process that you're only doing once or

1466
00:56:15,359 --> 00:56:17,280
twice a day

1467
00:56:17,280 --> 00:56:19,040
in any case the

1468
00:56:19,040 --> 00:56:21,920
frayed ribbon cascade uses approximately

1469
00:56:21,920 --> 00:56:25,520
40 percent less space than cr light

1470
00:56:25,520 --> 00:56:27,119
it accomplishes this

1471
00:56:27,119 --> 00:56:29,599
about 30 percent by using frayed ribbon

1472
00:56:29,599 --> 00:56:31,359
filters instead of bloom filters and

1473
00:56:31,359 --> 00:56:33,920
about 10 from using a two level cascade

1474
00:56:33,920 --> 00:56:37,440
instead of an end level cascade

1475
00:56:37,440 --> 00:56:39,359
there's still plenty of work that could

1476
00:56:39,359 --> 00:56:41,040
be

1477
00:56:41,040 --> 00:56:41,920
so

1478
00:56:41,920 --> 00:56:43,280
one uh

1479
00:56:43,280 --> 00:56:45,280
example that is not addressed here is

1480
00:56:45,280 --> 00:56:46,720
incremental updates

1481
00:56:46,720 --> 00:56:48,799
so um

1482
00:56:48,799 --> 00:56:50,559
this is so far talking about compressing

1483
00:56:50,559 --> 00:56:53,200
an entire crl but in fact only a few

1484
00:56:53,200 --> 00:56:54,880
thousand certificates are revoked each

1485
00:56:54,880 --> 00:56:56,640
day and it doesn't make sense for the

1486
00:56:56,640 --> 00:56:58,880
clients to download an entire new

1487
00:56:58,880 --> 00:57:01,839
freshly compressed filter every day

1488
00:57:01,839 --> 00:57:03,359
it turns out that cr light's bloom

1489
00:57:03,359 --> 00:57:05,280
filter cascade

1490
00:57:05,280 --> 00:57:07,520
can be updated with delta updates but

1491
00:57:07,520 --> 00:57:09,440
the update process is not very efficient

1492
00:57:09,440 --> 00:57:12,880
and is not implemented in firefox

1493
00:57:12,880 --> 00:57:14,720
but linear filters are not updatable at

1494
00:57:14,720 --> 00:57:16,079
all so what do you do

1495
00:57:16,079 --> 00:57:17,760
well there's a generic solution that's

1496
00:57:17,760 --> 00:57:18,880
somewhat

1497
00:57:18,880 --> 00:57:21,359
inelegant but i think good enough

1498
00:57:21,359 --> 00:57:23,839
which is that each day you send down a

1499
00:57:23,839 --> 00:57:26,000
dictionary of certs that were compre

1500
00:57:26,000 --> 00:57:28,400
that were revoked that day

1501
00:57:28,400 --> 00:57:29,680
since this is fundamentally the

1502
00:57:29,680 --> 00:57:31,040
information that you're conveying by a

1503
00:57:31,040 --> 00:57:32,960
daily update system this has nearly

1504
00:57:32,960 --> 00:57:36,240
optimal bandwidth usage about 10k a day

1505
00:57:36,240 --> 00:57:37,839
with these example

1506
00:57:37,839 --> 00:57:39,760
specifications

1507
00:57:39,760 --> 00:57:41,440
the queries are probably also fast

1508
00:57:41,440 --> 00:57:44,799
enough because well it's only taking uh

1509
00:57:44,799 --> 00:57:47,200
hundreds of nanoseconds plus however

1510
00:57:47,200 --> 00:57:49,599
long it takes to fetch a block on

1511
00:57:49,599 --> 00:57:51,680
disk or flash

1512
00:57:51,680 --> 00:57:54,720
per level of this so per

1513
00:57:54,720 --> 00:57:56,480
day since either the cert was issued or

1514
00:57:56,480 --> 00:58:00,640
since you last downloaded a full update

1515
00:58:00,640 --> 00:58:03,040
so this is likely fast enough for tls

1516
00:58:03,040 --> 00:58:04,400
but it would be nice to have a more

1517
00:58:04,400 --> 00:58:06,480
elegant system in the future adam

1518
00:58:06,480 --> 00:58:08,559
langley has proposed golem coded sets

1519
00:58:08,559 --> 00:58:09,760
for this purpose so it would be

1520
00:58:09,760 --> 00:58:12,960
interesting to do a comparison

1521
00:58:12,960 --> 00:58:14,880
we have some ideas for future work in

1522
00:58:14,880 --> 00:58:17,040
this area um a lot of this is just the

1523
00:58:17,040 --> 00:58:19,280
generic stuff like well there's a

1524
00:58:19,280 --> 00:58:21,040
prototype grade implementation and it

1525
00:58:21,040 --> 00:58:22,319
would be better to have a production

1526
00:58:22,319 --> 00:58:23,920
grade implementation or it would be

1527
00:58:23,920 --> 00:58:25,440
better to have formal analysis of the

1528
00:58:25,440 --> 00:58:27,280
whole process in particular a proof that

1529
00:58:27,280 --> 00:58:29,119
the matrices are always soluble with

1530
00:58:29,119 --> 00:58:31,599
high probability

1531
00:58:31,599 --> 00:58:33,839
as well as incremental updates

1532
00:58:33,839 --> 00:58:35,520
there's probably a faster shape that you

1533
00:58:35,520 --> 00:58:37,359
can make these matrices in

1534
00:58:37,359 --> 00:58:38,240
and

1535
00:58:38,240 --> 00:58:40,799
is there any way to get that last 11

1536
00:58:40,799 --> 00:58:43,839
percent of the compression back

1537
00:58:43,839 --> 00:58:46,400
but in conclusion

1538
00:58:46,400 --> 00:58:48,240
i think cr light has demonstrated that

1539
00:58:48,240 --> 00:58:50,079
static functions are a great approach

1540
00:58:50,079 --> 00:58:52,160
for distributing objects like crls and

1541
00:58:52,160 --> 00:58:54,480
possibly also other

1542
00:58:54,480 --> 00:58:56,000
security information like malware

1543
00:58:56,000 --> 00:58:57,680
databases

1544
00:58:57,680 --> 00:58:59,920
and this new work

1545
00:58:59,920 --> 00:59:02,480
improves the efficiency of that by

1546
00:59:02,480 --> 00:59:05,280
approximately 40 percent um and it still

1547
00:59:05,280 --> 00:59:08,319
has fast queries and fast enough build

1548
00:59:08,319 --> 00:59:09,680
times

1549
00:59:09,680 --> 00:59:11,680
and i'm looking forward to future work

1550
00:59:11,680 --> 00:59:14,559
that improves this even further

1551
00:59:14,559 --> 00:59:18,280
that's all any questions

1552
00:59:27,040 --> 00:59:27,839
so

1553
00:59:27,839 --> 00:59:31,119
mike are you online for questions

1554
00:59:31,119 --> 00:59:33,520
yes can you hear me yeah we can hear you

1555
00:59:33,520 --> 00:59:36,000
so if you have questions please come to

1556
00:59:36,000 --> 00:59:38,480
the mic

1557
00:59:40,400 --> 00:59:44,440
a question is coming mike

1558
00:59:53,920 --> 00:59:54,799
test

1559
00:59:54,799 --> 00:59:57,680
hey mike um really really great talk i

1560
00:59:57,680 --> 00:59:59,440
was just wondering um

1561
00:59:59,440 --> 01:00:00,960
a lot of your

1562
01:00:00,960 --> 01:00:03,119
like framing of this problem is sort of

1563
01:00:03,119 --> 01:00:06,319
implicitly as an optimization problem um

1564
01:00:06,319 --> 01:00:09,440
and it seems like since you're you're

1565
01:00:09,440 --> 01:00:11,440
you have this very explicit kind of

1566
01:00:11,440 --> 01:00:13,200
matrix

1567
01:00:13,200 --> 01:00:15,200
formalism like like the formulation of

1568
01:00:15,200 --> 01:00:17,520
this problem have you thought about

1569
01:00:17,520 --> 01:00:19,119
explicitly using some kind of an

1570
01:00:19,119 --> 01:00:21,359
optimization based approach

1571
01:00:21,359 --> 01:00:23,760
to phrase the problem of choosing an

1572
01:00:23,760 --> 01:00:26,240
optimal matrix as some kind of a linear

1573
01:00:26,240 --> 01:00:28,000
program and then you can solve it using

1574
01:00:28,000 --> 01:00:30,960
standard optimization techniques

1575
01:00:30,960 --> 01:00:33,359
yeah so actually so the sub step of

1576
01:00:33,359 --> 01:00:34,559
choosing the false positive

1577
01:00:34,559 --> 01:00:36,559
probabilities or other parameters of

1578
01:00:36,559 --> 01:00:37,920
this cascade

1579
01:00:37,920 --> 01:00:39,680
is a linear program it's a special one

1580
01:00:39,680 --> 01:00:40,640
so you can

1581
01:00:40,640 --> 01:00:42,400
you don't have to do a full lp solution

1582
01:00:42,400 --> 01:00:45,200
on it um as for you know trying to make

1583
01:00:45,200 --> 01:00:46,880
the matrix solver as fast as possible

1584
01:00:46,880 --> 01:00:48,960
the issue is that i don't have a formal

1585
01:00:48,960 --> 01:00:51,280
proof of exactly in what cases the

1586
01:00:51,280 --> 01:00:52,960
matrix um

1587
01:00:52,960 --> 01:00:55,040
will be invertible with high probability

1588
01:00:55,040 --> 01:00:56,400
so what i have instead is you know i

1589
01:00:56,400 --> 01:00:58,079
just like tested it on every block size

1590
01:00:58,079 --> 01:00:59,760
up to several million

1591
01:00:59,760 --> 01:01:03,280
um blocks uh so

1592
01:01:03,280 --> 01:01:05,200
that um

1593
01:01:05,200 --> 01:01:07,200
is not something that i can easily apply

1594
01:01:07,200 --> 01:01:08,720
an lp to

1595
01:01:08,720 --> 01:01:10,240
uh i see actually sorry i have a

1596
01:01:10,240 --> 01:01:12,880
follow-up question um

1597
01:01:12,880 --> 01:01:14,960
why does it matter if the matrix doesn't

1598
01:01:14,960 --> 01:01:17,280
end up being invertible can you not just

1599
01:01:17,280 --> 01:01:19,119
can you use a c to choose a new hash

1600
01:01:19,119 --> 01:01:21,119
function and then try again yeah yeah

1601
01:01:21,119 --> 01:01:22,640
yeah you could do that but it has to be

1602
01:01:22,640 --> 01:01:24,880
invertible like you know most of the

1603
01:01:24,880 --> 01:01:26,799
time or else you take forever to

1604
01:01:26,799 --> 01:01:28,000
compress

1605
01:01:28,000 --> 01:01:30,640
thank you very much

1606
01:01:33,280 --> 01:01:34,079
hi

1607
01:01:34,079 --> 01:01:35,359
so uh

1608
01:01:35,359 --> 01:01:40,319
i noticed that the uh query time

1609
01:01:40,319 --> 01:01:42,160
varied a lot depending on the method

1610
01:01:42,160 --> 01:01:44,319
that was used so the there was the

1611
01:01:44,319 --> 01:01:46,720
uh frayed ribbon method and as compared

1612
01:01:46,720 --> 01:01:48,960
to the ribboning method and and other

1613
01:01:48,960 --> 01:01:51,920
things uh what were the um what were the

1614
01:01:51,920 --> 01:01:54,240
causes for the variance between the

1615
01:01:54,240 --> 01:01:57,039
query times was it just matrix with or

1616
01:01:57,039 --> 01:01:59,520
was it hashing mechanism or well it's a

1617
01:01:59,520 --> 01:02:01,599
bunch it's a couple of things the the

1618
01:02:01,599 --> 01:02:04,240
the biggest reason is that um

1619
01:02:04,240 --> 01:02:07,119
i rewrote this in rust i had an initial

1620
01:02:07,119 --> 01:02:09,119
c prototype and i was like oh rust is

1621
01:02:09,119 --> 01:02:12,559
better for safety and whatever um and i

1622
01:02:12,559 --> 01:02:14,240
was optimizing that on

1623
01:02:14,240 --> 01:02:17,440
an m1 mac but then for consistency with

1624
01:02:17,440 --> 01:02:19,359
the other tests

1625
01:02:19,359 --> 01:02:20,640
with the other filters that are

1626
01:02:20,640 --> 01:02:22,640
optimized for intel i didn't want to be

1627
01:02:22,640 --> 01:02:24,400
like oh on this one thing it's mine's

1628
01:02:24,400 --> 01:02:26,960
much faster and for some reasons like

1629
01:02:26,960 --> 01:02:29,839
rust's sip hasher crate is like

1630
01:02:29,839 --> 01:02:32,480
significantly slower on

1631
01:02:32,480 --> 01:02:34,559
the intel one and not on the mac and i

1632
01:02:34,559 --> 01:02:36,640
didn't get that worked out before making

1633
01:02:36,640 --> 01:02:38,160
the slides so

1634
01:02:38,160 --> 01:02:40,880
uh that is a lot of it um also

1635
01:02:40,880 --> 01:02:44,000
um the uh the second the bigger number

1636
01:02:44,000 --> 01:02:45,680
right has got multiple queries because

1637
01:02:45,680 --> 01:02:48,960
it's got a cascade instead of only one

1638
01:02:48,960 --> 01:02:50,480
[Music]

1639
01:02:50,480 --> 01:02:52,480
instead of only one frayed ribbon filter

1640
01:02:52,480 --> 01:02:55,440
it's doing two of them

1641
01:02:55,599 --> 01:02:57,839
right okay thank you

1642
01:02:57,839 --> 01:03:00,240
welcome

1643
01:03:00,880 --> 01:03:02,880
thank you mike i think there is no more

1644
01:03:02,880 --> 01:03:05,359
questions so can we thank the speaker

1645
01:03:05,359 --> 01:03:08,000
again please

1646
01:03:13,200 --> 01:03:16,000
so this is the end of the tls session

1647
01:03:16,000 --> 01:03:18,079
before leaving for the coffee break

1648
01:03:18,079 --> 01:03:20,790
please thank all the speakers again

1649
01:03:20,790 --> 01:03:23,969
[Music]

1650
01:03:25,580 --> 01:03:29,909
[Applause]

