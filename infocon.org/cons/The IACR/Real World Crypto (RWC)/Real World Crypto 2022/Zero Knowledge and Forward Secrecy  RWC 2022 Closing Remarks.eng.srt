1
00:00:00,240 --> 00:00:02,960
of talks at real world crypto

2
00:00:02,960 --> 00:00:04,640
uh it's been really fun so far it's

3
00:00:04,640 --> 00:00:05,839
great to see

4
00:00:05,839 --> 00:00:09,040
everybody um so we have three great

5
00:00:09,040 --> 00:00:11,120
talks about zero knowledge and forward

6
00:00:11,120 --> 00:00:12,400
secrecy

7
00:00:12,400 --> 00:00:14,400
and um

8
00:00:14,400 --> 00:00:16,480
this will be for the next hour

9
00:00:16,480 --> 00:00:19,119
and uh the first speaker

10
00:00:19,119 --> 00:00:20,320
is

11
00:00:20,320 --> 00:00:23,600
anta nicholas who from

12
00:00:23,600 --> 00:00:25,279
uh protocol labs in the theorem

13
00:00:25,279 --> 00:00:26,400
foundation

14
00:00:26,400 --> 00:00:28,960
uh to talk about snark pack practical

15
00:00:28,960 --> 00:00:31,039
snark aggregation

16
00:00:31,039 --> 00:00:33,439
thank you

17
00:00:34,590 --> 00:00:40,399
[Applause]

18
00:00:40,399 --> 00:00:43,200
okay hi everyone

19
00:00:43,200 --> 00:00:47,200
maybe i can see my slides at some point

20
00:00:47,360 --> 00:00:49,600
here they come yeah great thanks

21
00:00:49,600 --> 00:00:52,000
um so this is a joint work with my

22
00:00:52,000 --> 00:00:53,760
colleague nicola again from protocol

23
00:00:53,760 --> 00:00:55,440
labs and mary malloy from ethereum

24
00:00:55,440 --> 00:00:56,559
foundation

25
00:00:56,559 --> 00:00:58,960
and it's about how to practically

26
00:00:58,960 --> 00:01:00,960
aggregate snarks

27
00:01:00,960 --> 00:01:02,480
um

28
00:01:02,480 --> 00:01:04,720
so in short what we are doing here we

29
00:01:04,720 --> 00:01:06,960
are taking a bunch of snacks many many

30
00:01:06,960 --> 00:01:08,240
many snacks

31
00:01:08,240 --> 00:01:10,560
and we are packing them together into

32
00:01:10,560 --> 00:01:13,360
something light and nice and an

33
00:01:13,360 --> 00:01:16,159
aggregation proof very small compared to

34
00:01:16,159 --> 00:01:18,640
the initial uh snack

35
00:01:18,640 --> 00:01:20,960
so what are snacks we already heard in

36
00:01:20,960 --> 00:01:23,040
the previous session

37
00:01:23,040 --> 00:01:24,960
there are proof systems that allow to

38
00:01:24,960 --> 00:01:27,520
verify np statements and they have nice

39
00:01:27,520 --> 00:01:30,079
properties such as succincts so they are

40
00:01:30,079 --> 00:01:32,400
very short in size

41
00:01:32,400 --> 00:01:34,320
uh they are non-interactive so they are

42
00:01:34,320 --> 00:01:36,640
perfect for decentralized scenarios

43
00:01:36,640 --> 00:01:38,320
where the approval just sends a

44
00:01:38,320 --> 00:01:40,479
statement and the proof there are

45
00:01:40,479 --> 00:01:42,640
arguments in the cryptographic sense

46
00:01:42,640 --> 00:01:45,520
that um the the adversaries are

47
00:01:45,520 --> 00:01:47,680
computational bounded so a cheating

48
00:01:47,680 --> 00:01:51,439
provider doesn't have unbounded power

49
00:01:51,439 --> 00:01:53,200
and their knowledge soundness so we have

50
00:01:53,200 --> 00:01:55,520
an extractor and for each approval we

51
00:01:55,520 --> 00:01:57,920
can extract a witness for the statement

52
00:01:57,920 --> 00:02:00,399
behind and we can add zero knowledge

53
00:02:00,399 --> 00:02:02,960
almost for free and zero knowledge also

54
00:02:02,960 --> 00:02:04,719
reassures us that the proof doesn't

55
00:02:04,719 --> 00:02:07,040
reveal any more sensitive information

56
00:02:07,040 --> 00:02:10,239
than the correctness of the statement

57
00:02:10,239 --> 00:02:13,120
okay so what they are useful for in real

58
00:02:13,120 --> 00:02:14,640
in real world

59
00:02:14,640 --> 00:02:17,360
uh we use them in decentralized story

60
00:02:17,360 --> 00:02:20,080
systems such as file coil

61
00:02:20,080 --> 00:02:23,360
and here we have a a bunch of users some

62
00:02:23,360 --> 00:02:26,560
of them are storage providers so they uh

63
00:02:26,560 --> 00:02:28,879
onboard storage capacity to the network

64
00:02:28,879 --> 00:02:31,200
so everybody can use this storage to put

65
00:02:31,200 --> 00:02:34,400
their data or variable information there

66
00:02:34,400 --> 00:02:36,480
and they are incentivized by some

67
00:02:36,480 --> 00:02:38,879
rewards so this means that they need to

68
00:02:38,879 --> 00:02:41,040
prove that they indeed store the data

69
00:02:41,040 --> 00:02:42,720
and they have that storage capacity to

70
00:02:42,720 --> 00:02:44,000
the network

71
00:02:44,000 --> 00:02:46,239
uh so those are the provers they need to

72
00:02:46,239 --> 00:02:48,480
convince us and other nodes in the in

73
00:02:48,480 --> 00:02:50,160
the network will play the role of the

74
00:02:50,160 --> 00:02:52,160
verifiers which are

75
00:02:52,160 --> 00:02:54,239
ensuring that the data is stored

76
00:02:54,239 --> 00:02:56,879
maintained and secured as as claimed by

77
00:02:56,879 --> 00:02:59,599
the provers so this is done in a

78
00:02:59,599 --> 00:03:02,159
decentralized way by using a public

79
00:03:02,159 --> 00:03:05,440
blockchain where those approvers are

80
00:03:05,440 --> 00:03:06,720
just

81
00:03:06,720 --> 00:03:08,480
onboarding their proofs on the on the

82
00:03:08,480 --> 00:03:10,319
blocks on the chain and then the

83
00:03:10,319 --> 00:03:13,200
verifiers can freely come and publicly

84
00:03:13,200 --> 00:03:15,280
check those proofs

85
00:03:15,280 --> 00:03:18,159
okay and in more detail how falcon

86
00:03:18,159 --> 00:03:22,000
system works for each um

87
00:03:22,000 --> 00:03:24,080
storage capacity we want to prove we

88
00:03:24,080 --> 00:03:26,400
need to split it in sectors of 32

89
00:03:26,400 --> 00:03:28,959
gigabytes and prove them separately and

90
00:03:28,959 --> 00:03:31,599
to prove one sector or 32 gigabytes we

91
00:03:31,599 --> 00:03:33,360
need 10 snacks

92
00:03:33,360 --> 00:03:35,280
so we need to submit all these knives to

93
00:03:35,280 --> 00:03:36,640
the chain

94
00:03:36,640 --> 00:03:39,920
and since blocks are finite uh they will

95
00:03:39,920 --> 00:03:42,640
get filled by snarks very quickly and

96
00:03:42,640 --> 00:03:45,120
there is also the verification time of

97
00:03:45,120 --> 00:03:47,760
this knife so before we go to the next

98
00:03:47,760 --> 00:03:50,239
block we need to verify all the snarks

99
00:03:50,239 --> 00:03:52,959
in the previous one so we take some time

100
00:03:52,959 --> 00:03:55,040
and this sets um

101
00:03:55,040 --> 00:03:56,879
onboarding limit

102
00:03:56,879 --> 00:03:59,680
on on our system so this is this used to

103
00:03:59,680 --> 00:04:02,799
be before snack pack 40 petabytes per

104
00:04:02,799 --> 00:04:04,319
day

105
00:04:04,319 --> 00:04:05,439
okay

106
00:04:05,439 --> 00:04:08,239
we were still helping the the system to

107
00:04:08,239 --> 00:04:10,159
scale by using batching for the

108
00:04:10,159 --> 00:04:12,080
verification so i said

109
00:04:12,080 --> 00:04:14,000
one block full of snacks should be

110
00:04:14,000 --> 00:04:16,079
verified before the next block will come

111
00:04:16,079 --> 00:04:16,798
on

112
00:04:16,798 --> 00:04:19,519
so we can do this by batching multiple

113
00:04:19,519 --> 00:04:21,759
snacks together in the verification

114
00:04:21,759 --> 00:04:25,520
process and this means that we earn some

115
00:04:25,520 --> 00:04:28,320
time in terms of the verification but a

116
00:04:28,320 --> 00:04:30,720
better way to scale this system is to

117
00:04:30,720 --> 00:04:32,960
use aggregations so this is what we will

118
00:04:32,960 --> 00:04:34,800
design in snack pack

119
00:04:34,800 --> 00:04:36,800
aggregation not only

120
00:04:36,800 --> 00:04:39,759
helps in uh faster verification but also

121
00:04:39,759 --> 00:04:42,320
in saves us improved size so the

122
00:04:42,320 --> 00:04:43,759
verification time and proof size are

123
00:04:43,759 --> 00:04:45,040
small

124
00:04:45,040 --> 00:04:46,320
okay

125
00:04:46,320 --> 00:04:48,400
so what do we need to know as a

126
00:04:48,400 --> 00:04:50,400
background before understanding the

127
00:04:50,400 --> 00:04:53,440
techniques we are using in snack bag

128
00:04:53,440 --> 00:04:55,759
some some basic stuff about bilinear

129
00:04:55,759 --> 00:04:57,759
groups so here we will consider two

130
00:04:57,759 --> 00:04:59,919
groups g1 and g2 the source group

131
00:04:59,919 --> 00:05:02,960
generated by g and h this is a

132
00:05:02,960 --> 00:05:05,759
multiplicative notation which i prefer

133
00:05:05,759 --> 00:05:07,199
for this talk

134
00:05:07,199 --> 00:05:10,000
and e is a bilinear map or a pairing

135
00:05:10,000 --> 00:05:12,639
that takes two elements from the source

136
00:05:12,639 --> 00:05:15,840
groups g1 and g2 and gives an element in

137
00:05:15,840 --> 00:05:17,520
the target group

138
00:05:17,520 --> 00:05:19,759
and has this very nice special property

139
00:05:19,759 --> 00:05:20,720
that

140
00:05:20,720 --> 00:05:22,880
all the exponents are multiplied in the

141
00:05:22,880 --> 00:05:24,560
tiger group

142
00:05:24,560 --> 00:05:26,560
okay

143
00:05:26,560 --> 00:05:28,639
so having this in mind we will talk

144
00:05:28,639 --> 00:05:30,560
about girl 16 which is the state of the

145
00:05:30,560 --> 00:05:33,840
art snack that we will aggregate with

146
00:05:33,840 --> 00:05:37,759
snack pack so we start with gold 16

147
00:05:37,759 --> 00:05:40,400
small groups that have these three

148
00:05:40,400 --> 00:05:42,080
algorithms

149
00:05:42,080 --> 00:05:44,639
the setup which generates a trusted

150
00:05:44,639 --> 00:05:46,400
setup

151
00:05:46,400 --> 00:05:49,360
which has some group elements there some

152
00:05:49,360 --> 00:05:50,800
very structured

153
00:05:50,800 --> 00:05:52,800
strategies setup

154
00:05:52,800 --> 00:05:54,320
we will call it

155
00:05:54,320 --> 00:05:55,680
crs

156
00:05:55,680 --> 00:05:59,120
okay then the proof um consists in three

157
00:05:59,120 --> 00:06:01,520
group elements a and c are group

158
00:06:01,520 --> 00:06:04,639
elements for the from the first group g1

159
00:06:04,639 --> 00:06:08,080
and b is an element from the group g2

160
00:06:08,080 --> 00:06:09,440
it's good to keep it in mind but i will

161
00:06:09,440 --> 00:06:11,680
repeat it in this talk

162
00:06:11,680 --> 00:06:14,240
and the verification i'm simplifying

163
00:06:14,240 --> 00:06:15,360
things here

164
00:06:15,360 --> 00:06:17,199
i know jens is in the

165
00:06:17,199 --> 00:06:19,360
in the audience so i don't want to

166
00:06:19,360 --> 00:06:22,479
okay so this is a a pairing check

167
00:06:22,479 --> 00:06:24,080
equation that is needed for the

168
00:06:24,080 --> 00:06:26,560
verification and consider that e a b c

169
00:06:26,560 --> 00:06:28,080
comes from the proof

170
00:06:28,080 --> 00:06:31,120
and d is just a

171
00:06:31,120 --> 00:06:33,440
combination of all the inputs like all

172
00:06:33,440 --> 00:06:35,680
the statements for the proofs for the

173
00:06:35,680 --> 00:06:38,319
proof and some verification key

174
00:06:38,319 --> 00:06:41,199
so this is one check that the verifier

175
00:06:41,199 --> 00:06:42,960
has to do in order to

176
00:06:42,960 --> 00:06:45,680
to see if the proof is correct

177
00:06:45,680 --> 00:06:48,560
so what happens when we have many snacks

178
00:06:48,560 --> 00:06:50,160
so we have this bunch of groups here

179
00:06:50,160 --> 00:06:54,240
with a lot of a abc elements

180
00:06:54,240 --> 00:06:56,960
and we want to verify it using some d

181
00:06:56,960 --> 00:06:58,880
which is the one that the verifier can

182
00:06:58,880 --> 00:07:01,199
compute by itself

183
00:07:01,199 --> 00:07:03,919
so many pairing checks

184
00:07:03,919 --> 00:07:06,479
will be will be done by the verification

185
00:07:06,479 --> 00:07:09,039
and instead of doing this as i said

186
00:07:09,039 --> 00:07:11,360
there are batching techniques that

187
00:07:11,360 --> 00:07:14,800
makes the verification simple and faster

188
00:07:14,800 --> 00:07:17,440
so if we take all these pairing checks

189
00:07:17,440 --> 00:07:20,400
and we just sample a randomness and we

190
00:07:20,400 --> 00:07:22,960
compute a linear random combination of

191
00:07:22,960 --> 00:07:24,160
them

192
00:07:24,160 --> 00:07:25,039
then

193
00:07:25,039 --> 00:07:27,440
because everything is bilinear and nice

194
00:07:27,440 --> 00:07:29,840
the properties are preserved and we can

195
00:07:29,840 --> 00:07:33,120
at the end obtain a single equation so

196
00:07:33,120 --> 00:07:35,440
remember uh multiplicative notation

197
00:07:35,440 --> 00:07:37,360
means that the multiplication by a

198
00:07:37,360 --> 00:07:40,000
randomness r goes into exponent

199
00:07:40,000 --> 00:07:42,080
so this is a single

200
00:07:42,080 --> 00:07:44,560
equation randomized

201
00:07:44,560 --> 00:07:46,960
that checks at once all the left

202
00:07:46,960 --> 00:07:49,199
equations here

203
00:07:49,199 --> 00:07:50,960
so this is what verifier will do for

204
00:07:50,960 --> 00:07:52,720
batching

205
00:07:52,720 --> 00:07:53,759
and

206
00:07:53,759 --> 00:07:56,000
rewriting this equation in a different

207
00:07:56,000 --> 00:07:59,120
way will will lead to to this uh

208
00:07:59,120 --> 00:08:01,759
equation here in the left

209
00:08:01,759 --> 00:08:04,639
and what we'll do for aggregation so the

210
00:08:04,639 --> 00:08:06,720
idea is really simple

211
00:08:06,720 --> 00:08:07,680
when

212
00:08:07,680 --> 00:08:10,639
instead of sending all these a i b icis

213
00:08:10,639 --> 00:08:12,560
to the to the verifier

214
00:08:12,560 --> 00:08:14,319
the prover itself will do this

215
00:08:14,319 --> 00:08:16,720
recombination with a randomness so this

216
00:08:16,720 --> 00:08:19,039
linear random combination will be done

217
00:08:19,039 --> 00:08:20,960
on the side of the approval so the

218
00:08:20,960 --> 00:08:23,120
verifier doesn't have to deal with such

219
00:08:23,120 --> 00:08:25,520
computation never has to read all the

220
00:08:25,520 --> 00:08:26,720
proofs

221
00:08:26,720 --> 00:08:27,520
so

222
00:08:27,520 --> 00:08:29,919
we will compute this value z-a-b which

223
00:08:29,919 --> 00:08:31,919
corresponds to the left part of the

224
00:08:31,919 --> 00:08:33,760
equation to be checked

225
00:08:33,760 --> 00:08:36,320
and z-c which corresponds to the

226
00:08:36,320 --> 00:08:37,679
prover's

227
00:08:37,679 --> 00:08:39,919
contribution to the right part we need

228
00:08:39,919 --> 00:08:41,360
to check here

229
00:08:41,360 --> 00:08:42,320
okay

230
00:08:42,320 --> 00:08:44,800
great sounds good but

231
00:08:44,800 --> 00:08:46,959
who like we will need just to

232
00:08:46,959 --> 00:08:48,880
receive these elements from the approval

233
00:08:48,880 --> 00:08:50,959
and then check it as a verifier but who

234
00:08:50,959 --> 00:08:53,440
will trust that those are correct right

235
00:08:53,440 --> 00:08:56,640
so the approval can introduce uh like a

236
00:08:56,640 --> 00:08:58,000
cheating strategy

237
00:08:58,000 --> 00:09:01,440
like we change some of the proofs and

238
00:09:01,440 --> 00:09:03,760
affect the soundness if just sends these

239
00:09:03,760 --> 00:09:06,000
two values so we need to send these two

240
00:09:06,000 --> 00:09:07,760
values but also prove that they are

241
00:09:07,760 --> 00:09:09,920
correctly computed with respect to the

242
00:09:09,920 --> 00:09:13,279
initial proofs ai bis and cs

243
00:09:13,279 --> 00:09:14,560
okay

244
00:09:14,560 --> 00:09:16,880
so let's go to the actual construction

245
00:09:16,880 --> 00:09:18,320
and how the approval will convince us

246
00:09:18,320 --> 00:09:19,920
for this

247
00:09:19,920 --> 00:09:22,720
and our tools are coming from a previous

248
00:09:22,720 --> 00:09:24,320
result by

249
00:09:24,320 --> 00:09:25,760
boons at all

250
00:09:25,760 --> 00:09:27,680
which are proofs of inner pairing

251
00:09:27,680 --> 00:09:30,160
products and their application

252
00:09:30,160 --> 00:09:32,200
and those inner pairing products are

253
00:09:32,200 --> 00:09:34,480
generalizations of

254
00:09:34,480 --> 00:09:37,519
pairing products of inner products sorry

255
00:09:37,519 --> 00:09:38,560
for

256
00:09:38,560 --> 00:09:41,120
group elements so vectors come with

257
00:09:41,120 --> 00:09:44,320
elements from a group from g1 or g2

258
00:09:44,320 --> 00:09:45,519
and

259
00:09:45,519 --> 00:09:48,800
they come in two playables mipp is the

260
00:09:48,800 --> 00:09:51,360
one in yellow there like we can compute

261
00:09:51,360 --> 00:09:53,120
multi-exponentiations

262
00:09:53,120 --> 00:09:56,320
of a committed vector from the first

263
00:09:56,320 --> 00:09:58,320
group this is a vector a from the first

264
00:09:58,320 --> 00:09:59,200
group

265
00:09:59,200 --> 00:10:01,920
with exponents in the field

266
00:10:01,920 --> 00:10:05,360
okay bis are exponents and the second

267
00:10:05,360 --> 00:10:09,040
type is tipp which computes these

268
00:10:09,040 --> 00:10:10,959
pairing

269
00:10:10,959 --> 00:10:12,240
products

270
00:10:12,240 --> 00:10:15,360
between two vectors of group elements a

271
00:10:15,360 --> 00:10:16,560
is in the first

272
00:10:16,560 --> 00:10:18,880
a comes from the first group and b from

273
00:10:18,880 --> 00:10:20,480
the second one

274
00:10:20,480 --> 00:10:22,720
so those are the tools we have

275
00:10:22,720 --> 00:10:25,440
we know how to prove these two relations

276
00:10:25,440 --> 00:10:27,279
for any vector a

277
00:10:27,279 --> 00:10:30,560
and b committed in some form

278
00:10:30,560 --> 00:10:31,760
okay

279
00:10:31,760 --> 00:10:33,760
and now if we tell a little bit of what

280
00:10:33,760 --> 00:10:35,680
we needed to convince the verifier in

281
00:10:35,680 --> 00:10:37,440
our aggregation

282
00:10:37,440 --> 00:10:38,640
idea

283
00:10:38,640 --> 00:10:41,360
we have the z c and z a b

284
00:10:41,360 --> 00:10:43,839
that should be exactly coming from some

285
00:10:43,839 --> 00:10:47,760
proof elements a i b i n c i

286
00:10:47,760 --> 00:10:50,399
okay if we rewrite it with the notation

287
00:10:50,399 --> 00:10:51,760
we have from

288
00:10:51,760 --> 00:10:54,160
m i p p and t ipp here

289
00:10:54,160 --> 00:10:56,880
like in our pairing products we see that

290
00:10:56,880 --> 00:10:58,959
zc is just an inner period product a

291
00:10:58,959 --> 00:11:00,720
multi-exponentiation of c with some

292
00:11:00,720 --> 00:11:02,880
random vector r

293
00:11:02,880 --> 00:11:05,440
and z a b is the

294
00:11:05,440 --> 00:11:07,200
pairing product

295
00:11:07,200 --> 00:11:09,920
from the vector a which comes from the

296
00:11:09,920 --> 00:11:11,839
first group and b to some randomness

297
00:11:11,839 --> 00:11:15,200
which is a vector in the second group so

298
00:11:15,200 --> 00:11:17,440
it's great we can use this

299
00:11:17,440 --> 00:11:19,360
just to to convince the verifier that

300
00:11:19,360 --> 00:11:21,040
these two values are what they're

301
00:11:21,040 --> 00:11:22,320
supposed to do

302
00:11:22,320 --> 00:11:23,920
to be

303
00:11:23,920 --> 00:11:26,720
so what we have to do is to commit to a

304
00:11:26,720 --> 00:11:29,279
b and c the vectors from the proofs we

305
00:11:29,279 --> 00:11:31,279
we want to aggregate

306
00:11:31,279 --> 00:11:34,480
and then compute the values zc and zab

307
00:11:34,480 --> 00:11:38,560
and use mipp and tipp to prove that

308
00:11:38,560 --> 00:11:41,120
those committed commitments and the

309
00:11:41,120 --> 00:11:43,200
values correspond to the

310
00:11:43,200 --> 00:11:45,200
to what is expected

311
00:11:45,200 --> 00:11:46,880
the problem here is that we want to

312
00:11:46,880 --> 00:11:48,399
deploy this system

313
00:11:48,399 --> 00:11:51,360
as soon as we as as we can in the real

314
00:11:51,360 --> 00:11:54,240
world so in uh in our decentralized

315
00:11:54,240 --> 00:11:57,040
storage to fix the scalability problem

316
00:11:57,040 --> 00:11:59,120
and committing to these

317
00:11:59,120 --> 00:12:01,600
vectors need some public key

318
00:12:01,600 --> 00:12:02,399
which

319
00:12:02,399 --> 00:12:04,880
is a very structured uh

320
00:12:04,880 --> 00:12:06,639
there are structural parameters that

321
00:12:06,639 --> 00:12:08,320
need to be

322
00:12:08,320 --> 00:12:09,440
trusted

323
00:12:09,440 --> 00:12:13,040
so this in real world uh requires a

324
00:12:13,040 --> 00:12:15,120
complicated ceremony

325
00:12:15,120 --> 00:12:17,279
between multiple participants that are

326
00:12:17,279 --> 00:12:20,320
independent and they have to run an mpc

327
00:12:20,320 --> 00:12:23,040
protocol together

328
00:12:23,040 --> 00:12:24,880
in such a way that after the random

329
00:12:24,880 --> 00:12:26,560
protocol they commit to destroy their

330
00:12:26,560 --> 00:12:29,680
machine and all the randomness and the

331
00:12:29,680 --> 00:12:32,320
the secrets they have there so it's not

332
00:12:32,320 --> 00:12:34,560
something we want to repeat

333
00:12:34,560 --> 00:12:35,279
like

334
00:12:35,279 --> 00:12:37,200
often in practice

335
00:12:37,200 --> 00:12:38,399
and the idea

336
00:12:38,399 --> 00:12:42,079
behind our aggregation is to just use

337
00:12:42,079 --> 00:12:44,560
trusted setup from the

338
00:12:44,560 --> 00:12:48,160
got 16 system that we aggregate because

339
00:12:48,160 --> 00:12:50,160
good 16 as we saw

340
00:12:50,160 --> 00:12:52,639
has also some trusted setup so let's

341
00:12:52,639 --> 00:12:54,959
reuse parts of that rusty setup in order

342
00:12:54,959 --> 00:12:56,880
to construct an aggregation scheme in

343
00:12:56,880 --> 00:12:59,279
top on top of it

344
00:12:59,279 --> 00:13:02,160
and the classic setup the

345
00:13:02,160 --> 00:13:03,760
exact part of the drastic setup from

346
00:13:03,760 --> 00:13:07,200
girl 16 we need are these powers of tau

347
00:13:07,200 --> 00:13:08,880
which are

348
00:13:08,880 --> 00:13:12,399
run like powers of a secret element tau

349
00:13:12,399 --> 00:13:14,399
computed in the first group in the

350
00:13:14,399 --> 00:13:16,160
exponent and in the second group in the

351
00:13:16,160 --> 00:13:17,680
exponent

352
00:13:17,680 --> 00:13:19,120
okay

353
00:13:19,120 --> 00:13:22,480
and we have such ceremonies already uh

354
00:13:22,480 --> 00:13:25,360
well established and well recognized uh

355
00:13:25,360 --> 00:13:27,440
that generated trust is set up for for

356
00:13:27,440 --> 00:13:29,600
this and we will need two copies of such

357
00:13:29,600 --> 00:13:31,519
a trusted setup that are compatible in

358
00:13:31,519 --> 00:13:32,880
the sense that they have the same

359
00:13:32,880 --> 00:13:34,320
generator g

360
00:13:34,320 --> 00:13:36,720
and the same generator age for the the

361
00:13:36,720 --> 00:13:39,680
two groups of elliptic cuts and we have

362
00:13:39,680 --> 00:13:42,160
such uh two compatible class this setup

363
00:13:42,160 --> 00:13:43,120
that are

364
00:13:43,120 --> 00:13:44,240
uh

365
00:13:44,240 --> 00:13:46,399
well well established and one is from

366
00:13:46,399 --> 00:13:49,040
file coin and one is from zcash

367
00:13:49,040 --> 00:13:50,480
and we will use this in order to

368
00:13:50,480 --> 00:13:53,120
construct our aggregations so what we we

369
00:13:53,120 --> 00:13:54,800
need to do is to construct new

370
00:13:54,800 --> 00:13:56,160
commitments

371
00:13:56,160 --> 00:13:56,959
uh

372
00:13:56,959 --> 00:13:58,320
with this

373
00:13:58,320 --> 00:14:01,279
trusted setup elements as key commitment

374
00:14:01,279 --> 00:14:04,079
keys so one commitment here for us to

375
00:14:04,079 --> 00:14:05,279
commit to a

376
00:14:05,279 --> 00:14:07,839
group to a vector of group elements in

377
00:14:07,839 --> 00:14:09,120
the first group

378
00:14:09,120 --> 00:14:12,240
we need to use uh the vectors from the

379
00:14:12,240 --> 00:14:14,880
trusted setup in the second group with

380
00:14:14,880 --> 00:14:16,720
the respective

381
00:14:16,720 --> 00:14:19,680
random powers alpha and beta

382
00:14:19,680 --> 00:14:21,360
and the commitment will be two target

383
00:14:21,360 --> 00:14:22,959
group elements

384
00:14:22,959 --> 00:14:26,079
for one committing to one long vector in

385
00:14:26,079 --> 00:14:27,279
one group

386
00:14:27,279 --> 00:14:29,360
and the nice thing about it is that if

387
00:14:29,360 --> 00:14:31,040
we can if we

388
00:14:31,040 --> 00:14:32,800
can combine a

389
00:14:32,800 --> 00:14:34,399
vector from the first group and a vector

390
00:14:34,399 --> 00:14:36,880
from the second group we can uh commit

391
00:14:36,880 --> 00:14:39,120
together to both of them with the same

392
00:14:39,120 --> 00:14:41,120
cost with two target group elements so

393
00:14:41,120 --> 00:14:43,120
we we put together

394
00:14:43,120 --> 00:14:45,120
in two target group elements these

395
00:14:45,120 --> 00:14:46,880
commitments to the vector a and to the

396
00:14:46,880 --> 00:14:48,160
vector b

397
00:14:48,160 --> 00:14:50,480
uh in the first and the second

398
00:14:50,480 --> 00:14:51,680
okay

399
00:14:51,680 --> 00:14:54,399
and now the stark aggregation once we

400
00:14:54,399 --> 00:14:56,079
have these commitments we can

401
00:14:56,079 --> 00:15:00,880
reinstantiate a version of mitp and tipp

402
00:15:00,880 --> 00:15:01,920
and

403
00:15:01,920 --> 00:15:04,720
uh do the the snack pack

404
00:15:04,720 --> 00:15:06,320
final scheme that

405
00:15:06,320 --> 00:15:08,880
consists in taking the vectors of the

406
00:15:08,880 --> 00:15:09,920
proofs

407
00:15:09,920 --> 00:15:10,959
we need to

408
00:15:10,959 --> 00:15:13,519
to aggregate put them into this

409
00:15:13,519 --> 00:15:15,519
commitment so we commit to a and b

410
00:15:15,519 --> 00:15:18,639
together and to see separately so we

411
00:15:18,639 --> 00:15:21,360
have four target group elements

412
00:15:21,360 --> 00:15:24,959
and that and then we run m ipp and tipp

413
00:15:24,959 --> 00:15:27,920
over this and this is a log n

414
00:15:27,920 --> 00:15:30,320
uh long proof that demonstrates that

415
00:15:30,320 --> 00:15:33,519
those commitments and these values here

416
00:15:33,519 --> 00:15:36,880
are are computed as expected

417
00:15:36,880 --> 00:15:39,360
okay so zc and zab are the values we

418
00:15:39,360 --> 00:15:42,480
need for the to give to the verifier as

419
00:15:42,480 --> 00:15:45,120
a batch verification terms

420
00:15:45,120 --> 00:15:47,519
and what's done by the verifier here is

421
00:15:47,519 --> 00:15:49,600
just taking log n

422
00:15:49,600 --> 00:15:50,959
commitments

423
00:15:50,959 --> 00:15:53,839
from this mipp and tipp and those are

424
00:15:53,839 --> 00:15:55,839
target group elements

425
00:15:55,839 --> 00:15:56,720
and

426
00:15:56,720 --> 00:15:57,440
put

427
00:15:57,440 --> 00:16:00,079
check the mipp and tipt relation using

428
00:16:00,079 --> 00:16:02,000
that proof and then check the final

429
00:16:02,000 --> 00:16:05,279
relation between the remember those

430
00:16:05,279 --> 00:16:08,480
z c and z a v can come from the linear

431
00:16:08,480 --> 00:16:11,040
random combination of the initial terms

432
00:16:11,040 --> 00:16:14,320
or initial group elements from the proof

433
00:16:14,320 --> 00:16:16,720
okay and if this equation holds then all

434
00:16:16,720 --> 00:16:19,440
the proofs together hold

435
00:16:19,440 --> 00:16:20,560
great

436
00:16:20,560 --> 00:16:23,759
so we implemented this it's real

437
00:16:23,759 --> 00:16:27,680
it exists it's implemented in rust

438
00:16:27,680 --> 00:16:30,800
open source available on on this

439
00:16:30,800 --> 00:16:32,560
links

440
00:16:32,560 --> 00:16:36,399
so we use the bls 12 cores

441
00:16:36,399 --> 00:16:39,680
and the the library dedicated to this

442
00:16:39,680 --> 00:16:41,839
the crs is a recombination let's say of

443
00:16:41,839 --> 00:16:43,600
filecoin and zcash

444
00:16:43,600 --> 00:16:46,320
and the benchmarks are performed on on

445
00:16:46,320 --> 00:16:48,639
these machines

446
00:16:48,639 --> 00:16:50,480
okay so some some

447
00:16:50,480 --> 00:16:51,759
numbers here

448
00:16:51,759 --> 00:16:54,639
um for the verification we compare with

449
00:16:54,639 --> 00:16:57,040
the batch verification we had before

450
00:16:57,040 --> 00:17:01,199
so it starts to pay off uh at after 32

451
00:17:01,199 --> 00:17:02,240
proofs

452
00:17:02,240 --> 00:17:05,520
uh so that's pretty nice and it also is

453
00:17:05,520 --> 00:17:07,199
a lot more efficient at the batch

454
00:17:07,199 --> 00:17:10,000
verification which is read here

455
00:17:10,000 --> 00:17:12,079
also realizing on parallelism

456
00:17:12,079 --> 00:17:14,480
we have a lot of optimization for this

457
00:17:14,480 --> 00:17:17,119
mipp and tippp

458
00:17:17,119 --> 00:17:19,280
protocols together

459
00:17:19,280 --> 00:17:21,119
we do a lot of patching also for the

460
00:17:21,119 --> 00:17:22,880
pairing checks and other curve

461
00:17:22,880 --> 00:17:24,400
operations

462
00:17:24,400 --> 00:17:26,160
okay

463
00:17:26,160 --> 00:17:28,000
and for the proof size

464
00:17:28,000 --> 00:17:31,600
of course that was the initial initial

465
00:17:31,600 --> 00:17:33,600
challenge to reduce the proof size so

466
00:17:33,600 --> 00:17:35,679
it's logarithmic in in the number of the

467
00:17:35,679 --> 00:17:36,640
proofs

468
00:17:36,640 --> 00:17:39,440
um compared with the linear

469
00:17:39,440 --> 00:17:41,919
like growth of the proofs you know

470
00:17:41,919 --> 00:17:43,840
without any

471
00:17:43,840 --> 00:17:46,320
any aggregation

472
00:17:46,320 --> 00:17:48,960
it's based also because these are target

473
00:17:48,960 --> 00:17:50,400
group elements is based on some

474
00:17:50,400 --> 00:17:52,880
compression techniques that makes them

475
00:17:52,880 --> 00:17:54,960
uh lightweight

476
00:17:54,960 --> 00:17:57,520
also this is inspired by a really cool

477
00:17:57,520 --> 00:17:59,760
library

478
00:17:59,760 --> 00:18:02,080
and for the aggregation time

479
00:18:02,080 --> 00:18:04,240
um this is the overhead approver has to

480
00:18:04,240 --> 00:18:06,720
pay in order to compute the aggregation

481
00:18:06,720 --> 00:18:08,799
so to apply snipe back to the already

482
00:18:08,799 --> 00:18:10,320
existing proofs

483
00:18:10,320 --> 00:18:11,200
um

484
00:18:11,200 --> 00:18:13,760
and that's not too bad like we see that

485
00:18:13,760 --> 00:18:16,480
it's reasonable till 2010 and and then

486
00:18:16,480 --> 00:18:19,039
becomes like minutes in terms of things

487
00:18:19,039 --> 00:18:20,640
but it saves so much time and so much

488
00:18:20,640 --> 00:18:22,960
verification time that it's worth paying

489
00:18:22,960 --> 00:18:24,960
this price

490
00:18:24,960 --> 00:18:27,919
okay so let's go back to our application

491
00:18:27,919 --> 00:18:30,480
and see how it helped

492
00:18:30,480 --> 00:18:34,720
so nowadays we have 1000 more proofs all

493
00:18:34,720 --> 00:18:37,440
on on the chain

494
00:18:37,440 --> 00:18:41,039
due to this sniper optimization so

495
00:18:41,039 --> 00:18:43,440
each sector as i said was consistently

496
00:18:43,440 --> 00:18:45,840
10 snacks so we take many many

497
00:18:45,840 --> 00:18:48,400
sectors provings and we put it together

498
00:18:48,400 --> 00:18:51,360
in a snack so we have light proofs so

499
00:18:51,360 --> 00:18:54,400
the blocks are not getting full so fast

500
00:18:54,400 --> 00:18:57,440
also the verification time is 20

501
00:18:57,440 --> 00:19:00,640
milliseconds for 2 000 snacks so that's

502
00:19:00,640 --> 00:19:04,000
way faster than we had before

503
00:19:04,000 --> 00:19:07,440
in practice in practice we get 200 more

504
00:19:07,440 --> 00:19:10,000
sectors than before

505
00:19:10,000 --> 00:19:13,520
okay so what i presented like our

506
00:19:13,520 --> 00:19:15,280
main motivation was to make this

507
00:19:15,280 --> 00:19:17,760
practical as soon as possible and what

508
00:19:17,760 --> 00:19:20,720
stayed uh uh what was the most difficult

509
00:19:20,720 --> 00:19:22,960
was to get rid of a new trusted setup

510
00:19:22,960 --> 00:19:25,280
that we need to run

511
00:19:25,280 --> 00:19:27,120
but it's still not transparent it still

512
00:19:27,120 --> 00:19:29,840
relies on subtract but strategic setup

513
00:19:29,840 --> 00:19:33,440
so next steps will be to explore other

514
00:19:33,440 --> 00:19:35,200
other ways to aggregate snags maybe in a

515
00:19:35,200 --> 00:19:37,440
transparent manner

516
00:19:37,440 --> 00:19:39,919
we have nice optimization we continue to

517
00:19:39,919 --> 00:19:42,080
optimize this system so there will be a

518
00:19:42,080 --> 00:19:43,679
follow-up work

519
00:19:43,679 --> 00:19:46,799
um and we were focusing only on growth

520
00:19:46,799 --> 00:19:49,679
16 construction but this generically

521
00:19:49,679 --> 00:19:52,480
works for any pairing check equation

522
00:19:52,480 --> 00:19:55,200
so we were wondering are there other

523
00:19:55,200 --> 00:19:57,039
applications in practice that

524
00:19:57,039 --> 00:19:58,880
consist only in pairing check equation

525
00:19:58,880 --> 00:20:01,120
and a lot of them that need aggregation

526
00:20:01,120 --> 00:20:02,480
and that would be a nice

527
00:20:02,480 --> 00:20:05,039
extension for our work

528
00:20:05,039 --> 00:20:08,640
okay that's all i have thank you

529
00:20:12,680 --> 00:20:15,520
[Music]

530
00:20:15,520 --> 00:20:18,400
all right thanks uh any questions we're

531
00:20:18,400 --> 00:20:21,840
right on time

532
00:20:21,919 --> 00:20:23,600
anybody coming to the line

533
00:20:23,600 --> 00:20:25,919
and it seems like there's nothing on

534
00:20:25,919 --> 00:20:28,240
zulu either so thank you so much anka

535
00:20:28,240 --> 00:20:30,660
thanks

536
00:20:30,660 --> 00:20:33,849
[Music]

537
00:20:35,280 --> 00:20:36,880
our next speaker's paul grubbs who's

538
00:20:36,880 --> 00:20:38,159
going to talk about zero knowledge

539
00:20:38,159 --> 00:20:40,700
middle boxes please welcome paul

540
00:20:40,700 --> 00:20:46,640
[Applause]

541
00:20:46,640 --> 00:20:48,720
thanks everybody uh this talk is going

542
00:20:48,720 --> 00:20:50,320
to be about resolving fundamental

543
00:20:50,320 --> 00:20:52,159
tensions between privacy and policy

544
00:20:52,159 --> 00:20:54,320
enforcement and networks

545
00:20:54,320 --> 00:20:55,840
we all know that encryption is becoming

546
00:20:55,840 --> 00:20:58,720
ubiquitous protocols like tls 1.3 where

547
00:20:58,720 --> 00:21:00,880
a client and a server use a handshake to

548
00:21:00,880 --> 00:21:02,480
establish a shared secret and then use

549
00:21:02,480 --> 00:21:04,400
it to encrypt their traffic

550
00:21:04,400 --> 00:21:06,720
improve privacy by hiding the contents

551
00:21:06,720 --> 00:21:10,240
of network traffic uh increasingly

552
00:21:10,240 --> 00:21:12,559
protocols like encrypted dns are hiding

553
00:21:12,559 --> 00:21:14,159
more and more of the metadata of network

554
00:21:14,159 --> 00:21:16,240
traffic as well

555
00:21:16,240 --> 00:21:18,240
this makes the basic task of enforcing

556
00:21:18,240 --> 00:21:19,840
policies in a network much more

557
00:21:19,840 --> 00:21:22,159
difficult today networks rely on middle

558
00:21:22,159 --> 00:21:24,320
boxes to enforce policies by scanning

559
00:21:24,320 --> 00:21:26,240
traffic and in middle boxes you can

560
00:21:26,240 --> 00:21:27,760
think of it as just kind of a router

561
00:21:27,760 --> 00:21:29,280
that can perform some general purpose

562
00:21:29,280 --> 00:21:31,280
computation on the traffic and so if the

563
00:21:31,280 --> 00:21:32,799
middle box detects that the traffic is

564
00:21:32,799 --> 00:21:35,120
compliant it lets the traffic through uh

565
00:21:35,120 --> 00:21:36,960
otherwise if it text detects a sort of

566
00:21:36,960 --> 00:21:38,559
violation of the policy it blocks the

567
00:21:38,559 --> 00:21:39,840
traffic

568
00:21:39,840 --> 00:21:41,600
um middlebox has enforced dozens of

569
00:21:41,600 --> 00:21:43,280
different kinds of policies and networks

570
00:21:43,280 --> 00:21:46,000
everything from like dns filtering to

571
00:21:46,000 --> 00:21:49,280
data loss prevention and many many more

572
00:21:49,280 --> 00:21:50,960
so the motivating question of this work

573
00:21:50,960 --> 00:21:53,520
is really is it possible to resolve this

574
00:21:53,520 --> 00:21:55,440
tension and have both privacy and policy

575
00:21:55,440 --> 00:21:56,960
enforcement

576
00:21:56,960 --> 00:21:58,400
this question itself is a little bit

577
00:21:58,400 --> 00:22:00,640
polarizing i think many network

578
00:22:00,640 --> 00:22:02,400
administrators would argue that in

579
00:22:02,400 --> 00:22:03,760
networks where you need to enforce

580
00:22:03,760 --> 00:22:05,919
policy uh you just simply shouldn't have

581
00:22:05,919 --> 00:22:07,919
encryption whereas many cryptographers

582
00:22:07,919 --> 00:22:10,240
and people in this room might argue that

583
00:22:10,240 --> 00:22:11,840
uh networks should really only enforce

584
00:22:11,840 --> 00:22:14,000
policies that don't require access to

585
00:22:14,000 --> 00:22:16,240
plain text data

586
00:22:16,240 --> 00:22:18,640
and so if we want to uh find a solution

587
00:22:18,640 --> 00:22:19,600
that accommodates both of these

588
00:22:19,600 --> 00:22:22,159
positions uh we can articulate just a

589
00:22:22,159 --> 00:22:24,320
few basic requirements the first is that

590
00:22:24,320 --> 00:22:26,960
we shouldn't have to weaken encryption

591
00:22:26,960 --> 00:22:28,320
we should have the same kind of privacy

592
00:22:28,320 --> 00:22:30,320
guarantees as regular encryption except

593
00:22:30,320 --> 00:22:32,720
uh possibly to reveal to the network

594
00:22:32,720 --> 00:22:34,320
that traffic is policy compliance that's

595
00:22:34,320 --> 00:22:36,080
kind of the only thing we should

596
00:22:36,080 --> 00:22:37,120
reveal

597
00:22:37,120 --> 00:22:38,640
second network should still be able to

598
00:22:38,640 --> 00:22:41,280
enforce policies as they did before

599
00:22:41,280 --> 00:22:43,200
so a corollary of this is that clients

600
00:22:43,200 --> 00:22:46,240
shouldn't be able to unilaterally bypass

601
00:22:46,240 --> 00:22:48,240
the middle box and and sort of send

602
00:22:48,240 --> 00:22:51,120
non-compliant uh traffic

603
00:22:51,120 --> 00:22:53,919
and finally we shouldn't have to uh

604
00:22:53,919 --> 00:22:56,159
change the server but we might uh change

605
00:22:56,159 --> 00:22:59,120
the clients in the middle boxes um

606
00:22:59,120 --> 00:23:00,960
we this is a requirement because there's

607
00:23:00,960 --> 00:23:02,799
a lot of good evidence that clients are

608
00:23:02,799 --> 00:23:04,720
a lot easier and faster to update than

609
00:23:04,720 --> 00:23:07,120
servers for example in january of this

610
00:23:07,120 --> 00:23:10,240
year uh only 51 of tls servers supported

611
00:23:10,240 --> 00:23:13,039
tls 1.3 which is four years old now

612
00:23:13,039 --> 00:23:15,440
whereas 50 of chrome users were already

613
00:23:15,440 --> 00:23:17,039
using a browser version that was only a

614
00:23:17,039 --> 00:23:18,960
month old at the time so it seems like

615
00:23:18,960 --> 00:23:23,360
clients are are easier to to update um

616
00:23:23,360 --> 00:23:24,720
another corollary of this that can no

617
00:23:24,720 --> 00:23:25,679
changes things we don't want to

618
00:23:25,679 --> 00:23:27,200
introduce additional trust assumptions

619
00:23:27,200 --> 00:23:29,360
into the system so like no no new root

620
00:23:29,360 --> 00:23:32,960
cas and no trusted hardware

621
00:23:32,960 --> 00:23:34,400
so there has been some prior work on

622
00:23:34,400 --> 00:23:35,760
this subject but

623
00:23:35,760 --> 00:23:37,120
all of it violates at least one of these

624
00:23:37,120 --> 00:23:39,039
requirements so like multi-context tls

625
00:23:39,039 --> 00:23:40,880
and blind box require weakening

626
00:23:40,880 --> 00:23:43,120
encryption and also server changes

627
00:23:43,120 --> 00:23:45,279
and sgx based solutions require

628
00:23:45,279 --> 00:23:47,440
new trusted hardware

629
00:23:47,440 --> 00:23:49,039
um there's a very

630
00:23:49,039 --> 00:23:51,120
one very important non-requirement that

631
00:23:51,120 --> 00:23:53,039
i th we should articulate which is that

632
00:23:53,039 --> 00:23:56,080
we don't want to prevent circumvention

633
00:23:56,080 --> 00:23:58,400
by by knowledgeable users so what we

634
00:23:58,400 --> 00:23:59,840
would want to do is really maintain the

635
00:23:59,840 --> 00:24:02,080
status quo that exists today where

636
00:24:02,080 --> 00:24:04,400
middle boxes can sort of enforce a safe

637
00:24:04,400 --> 00:24:06,880
default between privacy and policy

638
00:24:06,880 --> 00:24:08,880
compliance but advanced users can sort

639
00:24:08,880 --> 00:24:11,919
of still get around

640
00:24:11,919 --> 00:24:14,559
the middle box if they if they choose so

641
00:24:14,559 --> 00:24:15,919
what we definitely don't want to do is

642
00:24:15,919 --> 00:24:17,120
build

643
00:24:17,120 --> 00:24:18,080
infrastructure that can't be

644
00:24:18,080 --> 00:24:20,320
circumvented and sort of be misused for

645
00:24:20,320 --> 00:24:22,879
censorship

646
00:24:23,039 --> 00:24:25,440
so in short what we want is some sort of

647
00:24:25,440 --> 00:24:26,720
way for the client to convince the

648
00:24:26,720 --> 00:24:28,080
middlebucks that

649
00:24:28,080 --> 00:24:29,760
that their traffic is policy compliant

650
00:24:29,760 --> 00:24:32,320
without revealing anything else about it

651
00:24:32,320 --> 00:24:33,200
so it turns out that there's a

652
00:24:33,200 --> 00:24:35,520
cryptographic um primitive that can

653
00:24:35,520 --> 00:24:36,880
really help us here because this is the

654
00:24:36,880 --> 00:24:38,480
zero knowledge session you can probably

655
00:24:38,480 --> 00:24:40,000
guess what it is this is uh zero

656
00:24:40,000 --> 00:24:41,679
knowledge proofs uh so if you're not

657
00:24:41,679 --> 00:24:45,039
familiar that's okay i'll just quickly

658
00:24:45,039 --> 00:24:46,400
give a basic explanation so is your

659
00:24:46,400 --> 00:24:48,159
knowledge proof is a cryptographic

660
00:24:48,159 --> 00:24:50,240
protocol between approver and a verifier

661
00:24:50,240 --> 00:24:51,760
and it allows the prover to convince the

662
00:24:51,760 --> 00:24:53,919
verifier of the truth of some public

663
00:24:53,919 --> 00:24:56,320
statement with two security requirements

664
00:24:56,320 --> 00:24:59,919
uh that we care about the first is that

665
00:24:59,919 --> 00:25:01,520
the prover shouldn't reveal sort of why

666
00:25:01,520 --> 00:25:03,039
the statement is true to the verifier it

667
00:25:03,039 --> 00:25:04,799
should just convince it that it is true

668
00:25:04,799 --> 00:25:06,240
this is the zero knowledge property and

669
00:25:06,240 --> 00:25:08,240
the second property is that the proofer

670
00:25:08,240 --> 00:25:10,080
can only convince the verifier if the

671
00:25:10,080 --> 00:25:11,360
statement is true so this is the

672
00:25:11,360 --> 00:25:12,960
soundness property of the zero knowledge

673
00:25:12,960 --> 00:25:14,559
proof system so zero knowledge proof we

674
00:25:14,559 --> 00:25:16,159
can think of it in in for this talk is

675
00:25:16,159 --> 00:25:17,360
just being a single message from the

676
00:25:17,360 --> 00:25:18,799
approver to the verifier so the approver

677
00:25:18,799 --> 00:25:20,480
runs some protocol to generate a message

678
00:25:20,480 --> 00:25:21,919
and send it to the verifier and the

679
00:25:21,919 --> 00:25:23,760
verifier checks the message using some

680
00:25:23,760 --> 00:25:26,480
some verification procedure

681
00:25:26,480 --> 00:25:27,919
so we're going to use zero knowledge

682
00:25:27,919 --> 00:25:29,840
proofs to build a new kind of middle box

683
00:25:29,840 --> 00:25:31,200
abstraction we call it zero knowledge

684
00:25:31,200 --> 00:25:32,960
middle box that's going to work as

685
00:25:32,960 --> 00:25:34,799
follows so when a client joins the

686
00:25:34,799 --> 00:25:36,240
network it's going to get a description

687
00:25:36,240 --> 00:25:37,919
of the network split kind of policies

688
00:25:37,919 --> 00:25:39,840
that they want to enforce

689
00:25:39,840 --> 00:25:41,760
the client and the server will use

690
00:25:41,760 --> 00:25:43,520
standard encryption protocols to

691
00:25:43,520 --> 00:25:44,960
establish keys and communicate and

692
00:25:44,960 --> 00:25:47,279
encrypt their traffic um but the client

693
00:25:47,279 --> 00:25:48,799
will in addition to sending its

694
00:25:48,799 --> 00:25:50,799
encrypted traffic to the middle box it

695
00:25:50,799 --> 00:25:52,080
will additionally include a zero

696
00:25:52,080 --> 00:25:54,640
knowledge proof uh roughly of the public

697
00:25:54,640 --> 00:25:56,880
statement that you know this cipher text

698
00:25:56,880 --> 00:26:00,000
contains policy compliant traffic

699
00:26:00,000 --> 00:26:01,919
and the middle box will verify this

700
00:26:01,919 --> 00:26:03,679
proof and in so doing gain and assurance

701
00:26:03,679 --> 00:26:05,679
that the that the

702
00:26:05,679 --> 00:26:07,200
traffic is compliant and if the proof

703
00:26:07,200 --> 00:26:08,720
doesn't verify that it'll just block the

704
00:26:08,720 --> 00:26:11,840
block for traffic

705
00:26:11,919 --> 00:26:13,039
um so

706
00:26:13,039 --> 00:26:14,880
let's just uh review our requirements

707
00:26:14,880 --> 00:26:16,799
again and uh check to make sure that

708
00:26:16,799 --> 00:26:19,120
they um

709
00:26:19,120 --> 00:26:20,640
that our requirements are met so we

710
00:26:20,640 --> 00:26:21,679
didn't

711
00:26:21,679 --> 00:26:22,880
we can conclude that we didn't weaken

712
00:26:22,880 --> 00:26:24,240
encryption because we're sort of using

713
00:26:24,240 --> 00:26:26,159
standard encryption uh and as well the

714
00:26:26,159 --> 00:26:27,360
zero knowledge property of the zero

715
00:26:27,360 --> 00:26:29,520
knowledge proof system hides the the

716
00:26:29,520 --> 00:26:30,799
traffic except for the fact that it's

717
00:26:30,799 --> 00:26:33,120
policy compliant um so the middle box

718
00:26:33,120 --> 00:26:35,600
can still enforce policies because uh

719
00:26:35,600 --> 00:26:36,720
the soundness property of the

720
00:26:36,720 --> 00:26:38,640
zero-knowledge proof system prevents the

721
00:26:38,640 --> 00:26:41,200
client from lying about traffic if it's

722
00:26:41,200 --> 00:26:43,919
if it's not policy compliant and finally

723
00:26:43,919 --> 00:26:45,440
we didn't have any server changes

724
00:26:45,440 --> 00:26:47,679
because uh the middle box doesn't the

725
00:26:47,679 --> 00:26:50,799
middle box strips the proofs out um if

726
00:26:50,799 --> 00:26:51,520
the

727
00:26:51,520 --> 00:26:53,039
if the traffic is compliant it doesn't

728
00:26:53,039 --> 00:26:54,400
forward them to the server so the server

729
00:26:54,400 --> 00:26:56,240
doesn't really even know about this

730
00:26:56,240 --> 00:26:59,200
about this interaction

731
00:26:59,360 --> 00:27:01,520
um so when we first came up with this

732
00:27:01,520 --> 00:27:02,960
basic architecture we weren't even

733
00:27:02,960 --> 00:27:04,640
really sure it would work

734
00:27:04,640 --> 00:27:05,840
and the reason why is because zero

735
00:27:05,840 --> 00:27:07,679
knowledge proof projects that that have

736
00:27:07,679 --> 00:27:09,120
kind of

737
00:27:09,120 --> 00:27:10,960
that are looking to deploy zero

738
00:27:10,960 --> 00:27:11,760
knowledge proofs and practice

739
00:27:11,760 --> 00:27:14,320
efficiently really really heavily rely

740
00:27:14,320 --> 00:27:16,320
on kind of tailoring the computation

741
00:27:16,320 --> 00:27:18,080
approved and zero knowledge to be

742
00:27:18,080 --> 00:27:19,600
amenable to being proven with the

743
00:27:19,600 --> 00:27:20,880
underlying machinery of the zero

744
00:27:20,880 --> 00:27:22,080
knowledge proof system kind of like

745
00:27:22,080 --> 00:27:23,600
howard's nice talk earlier today really

746
00:27:23,600 --> 00:27:25,120
went into detail about how they how they

747
00:27:25,120 --> 00:27:27,200
do this um unfortunately because we want

748
00:27:27,200 --> 00:27:28,880
to maintain uh

749
00:27:28,880 --> 00:27:30,399
sort of compatibility with these legacy

750
00:27:30,399 --> 00:27:32,080
protocols we just have to sort of take

751
00:27:32,080 --> 00:27:34,080
them as they exist today so like

752
00:27:34,080 --> 00:27:36,240
protocols like tls 1.3 this is the the

753
00:27:36,240 --> 00:27:38,640
key schedule of tls 1.3 this like very

754
00:27:38,640 --> 00:27:40,640
very complicated diagram here so we sort

755
00:27:40,640 --> 00:27:42,080
of have to figure out how to adapt the

756
00:27:42,080 --> 00:27:43,520
zero-knowledge proof machinery to be

757
00:27:43,520 --> 00:27:46,559
efficient for very complex um

758
00:27:46,559 --> 00:27:48,080
protocols that weren't designed for for

759
00:27:48,080 --> 00:27:49,679
zero knowledge proofs

760
00:27:49,679 --> 00:27:50,640
and so

761
00:27:50,640 --> 00:27:52,159
what we found to our much to our

762
00:27:52,159 --> 00:27:53,520
surprise is that not only does this

763
00:27:53,520 --> 00:27:55,279
basic architecture work but that zero

764
00:27:55,279 --> 00:27:57,039
knowledge proofs about properties of tls

765
00:27:57,039 --> 00:27:58,960
1.3 traffic are already close to

766
00:27:58,960 --> 00:28:01,440
practical uh today which is a very very

767
00:28:01,440 --> 00:28:03,200
exciting um

768
00:28:03,200 --> 00:28:05,760
outcome of this research

769
00:28:05,760 --> 00:28:07,120
uh so in the remainder of this talk i'm

770
00:28:07,120 --> 00:28:08,240
going to tell you three things about

771
00:28:08,240 --> 00:28:09,679
zero knowledge middle boxes i'm going to

772
00:28:09,679 --> 00:28:11,679
go into a little bit more detail about

773
00:28:11,679 --> 00:28:13,840
the uh the kind of circuit model of the

774
00:28:13,840 --> 00:28:15,279
proofs and then i'm going to explain a

775
00:28:15,279 --> 00:28:16,880
core technical problem that we had to

776
00:28:16,880 --> 00:28:18,159
solve which is building efficient

777
00:28:18,159 --> 00:28:20,720
decryption circuits for tls 1.3

778
00:28:20,720 --> 00:28:22,320
and then i'm going to explain an

779
00:28:22,320 --> 00:28:23,600
application of the zero knowledge middle

780
00:28:23,600 --> 00:28:26,240
box framework to building filtering for

781
00:28:26,240 --> 00:28:27,279
encrypted

782
00:28:27,279 --> 00:28:29,120
dns and then finally i'll speak very

783
00:28:29,120 --> 00:28:31,840
briefly about some some future work

784
00:28:31,840 --> 00:28:34,640
um so before we we talk about um

785
00:28:34,640 --> 00:28:36,320
specific computations i just want to

786
00:28:36,320 --> 00:28:37,679
like fill in a little bit of detail

787
00:28:37,679 --> 00:28:39,679
about the kind of machinery of the zero

788
00:28:39,679 --> 00:28:41,200
knowledge proof so zero knowledge proof

789
00:28:41,200 --> 00:28:43,600
for our purposes uh proves the

790
00:28:43,600 --> 00:28:45,200
satisfiability of some arithmetic

791
00:28:45,200 --> 00:28:46,480
circuit and how this works isn't so

792
00:28:46,480 --> 00:28:47,760
important but what we need to know is

793
00:28:47,760 --> 00:28:49,520
that the arithmetic circuit has public

794
00:28:49,520 --> 00:28:52,480
inputs and private witnesses and in a

795
00:28:52,480 --> 00:28:54,399
zero knowledge proof protocol the prover

796
00:28:54,399 --> 00:28:56,080
will run some prove algorithm that

797
00:28:56,080 --> 00:28:57,760
generates a proof and conceptually it

798
00:28:57,760 --> 00:28:59,440
takes as input the circuit that's being

799
00:28:59,440 --> 00:29:01,440
proven and the inputs and the witnesses

800
00:29:01,440 --> 00:29:03,679
and additionally also a

801
00:29:03,679 --> 00:29:04,960
some zero knowledge proof systems have

802
00:29:04,960 --> 00:29:06,559
trusted as anka just said they have a

803
00:29:06,559 --> 00:29:08,240
trusted preprocessing step that sort of

804
00:29:08,240 --> 00:29:10,799
generates a statement specific proving

805
00:29:10,799 --> 00:29:13,039
key which we'll sort of abstract away in

806
00:29:13,039 --> 00:29:15,360
the talk um so the approver generates

807
00:29:15,360 --> 00:29:16,559
this proof and then sends it to the

808
00:29:16,559 --> 00:29:18,559
verifier and the prover

809
00:29:18,559 --> 00:29:20,880
sorry the verifier takes a runs this

810
00:29:20,880 --> 00:29:22,320
verify algorithm that takes his input

811
00:29:22,320 --> 00:29:24,399
the circuit and the input and the proof

812
00:29:24,399 --> 00:29:26,320
and then outputs a zero or a one and if

813
00:29:26,320 --> 00:29:28,320
verify outputs one the verifier gains an

814
00:29:28,320 --> 00:29:30,240
assurance that the prover knows some

815
00:29:30,240 --> 00:29:31,919
witnesses that caused the circuit to

816
00:29:31,919 --> 00:29:34,480
output um one but zero knowledge sort of

817
00:29:34,480 --> 00:29:35,679
hides

818
00:29:35,679 --> 00:29:37,440
what what those witnesses are from the

819
00:29:37,440 --> 00:29:39,440
from the verifier

820
00:29:39,440 --> 00:29:42,159
so basically with this the building a

821
00:29:42,159 --> 00:29:43,679
zero knowledge middle box kind of boils

822
00:29:43,679 --> 00:29:45,840
down to constructing a circuit that

823
00:29:45,840 --> 00:29:48,000
roughly proves that

824
00:29:48,000 --> 00:29:49,760
when you decrypt the traffic and run

825
00:29:49,760 --> 00:29:51,039
some sort of compliance check on the

826
00:29:51,039 --> 00:29:53,279
underlying plaintext you get a one as

827
00:29:53,279 --> 00:29:55,679
output um so

828
00:29:55,679 --> 00:29:57,200
we can think of the the input as being

829
00:29:57,200 --> 00:29:59,360
the ciphertext that the the

830
00:29:59,360 --> 00:30:00,799
client is sending and the witness being

831
00:30:00,799 --> 00:30:02,720
the key that it's using to encrypt its

832
00:30:02,720 --> 00:30:03,919
traffic

833
00:30:03,919 --> 00:30:06,480
and so we need to uh uh build this kind

834
00:30:06,480 --> 00:30:08,880
of a circuit but because uh this these

835
00:30:08,880 --> 00:30:10,240
circuits are very complex and they're

836
00:30:10,240 --> 00:30:12,240
also like protocol specific in multiple

837
00:30:12,240 --> 00:30:13,919
ways and also sort of policy specific in

838
00:30:13,919 --> 00:30:16,159
the paper we give a sort of like three

839
00:30:16,159 --> 00:30:17,760
step pipeline for building these here

840
00:30:17,760 --> 00:30:18,640
knowledge groups to make it a little

841
00:30:18,640 --> 00:30:20,799
more modular so we have this channel

842
00:30:20,799 --> 00:30:22,559
opening step that just uh decrypts the

843
00:30:22,559 --> 00:30:24,240
message decrypts the cipher text and

844
00:30:24,240 --> 00:30:25,840
outputs the message and then parse and

845
00:30:25,840 --> 00:30:28,399
extract um sort of extracts the policy

846
00:30:28,399 --> 00:30:30,000
relevant data from the underlying plain

847
00:30:30,000 --> 00:30:31,440
text and sort of deals with the network

848
00:30:31,440 --> 00:30:33,120
protocol part of the

849
00:30:33,120 --> 00:30:35,360
of the proof and then finally the policy

850
00:30:35,360 --> 00:30:37,120
check verifies that the data is is

851
00:30:37,120 --> 00:30:39,440
compliant

852
00:30:39,440 --> 00:30:40,799
uh so i just want to zoom in a little

853
00:30:40,799 --> 00:30:43,360
bit on a specific step which is uh

854
00:30:43,360 --> 00:30:44,559
interesting and challenging so it's

855
00:30:44,559 --> 00:30:46,080
building this channel opening circuit

856
00:30:46,080 --> 00:30:48,080
for tls 1.3 so this is the circuit that

857
00:30:48,080 --> 00:30:51,600
decrypts um decrypts the the cipher text

858
00:30:51,600 --> 00:30:53,520
so the question is how do we decrypt a

859
00:30:53,520 --> 00:30:55,200
tls 1.3 ciphertext and so a first

860
00:30:55,200 --> 00:30:57,840
attempt is to just express the tls 1.3

861
00:30:57,840 --> 00:30:59,679
like record layer decryption in an

862
00:30:59,679 --> 00:31:01,440
arithmetic circuit which under the hood

863
00:31:01,440 --> 00:31:02,880
is running some decryption for some kind

864
00:31:02,880 --> 00:31:05,440
of like like aad like like gcm or maybe

865
00:31:05,440 --> 00:31:08,799
cha cha 20 poly 1305 um and then output

866
00:31:08,799 --> 00:31:11,039
the plain text if the uh if the if the

867
00:31:11,039 --> 00:31:12,799
aad decryption succeeds and then if it

868
00:31:12,799 --> 00:31:14,159
fails we sort of short circuit the rest

869
00:31:14,159 --> 00:31:15,840
of the computation then go

870
00:31:15,840 --> 00:31:19,200
and output i'll put a zero so like false

871
00:31:19,200 --> 00:31:20,880
um unfortunately

872
00:31:20,880 --> 00:31:22,399
and interestingly this doesn't work at

873
00:31:22,399 --> 00:31:23,919
all there's a severe problem with this

874
00:31:23,919 --> 00:31:26,880
approach and the problem is that tls 1.3

875
00:31:26,880 --> 00:31:28,720
the record layer decryption isn't

876
00:31:28,720 --> 00:31:30,399
binding in the sense of a cryptographic

877
00:31:30,399 --> 00:31:32,399
commitment and so what this means is

878
00:31:32,399 --> 00:31:34,880
that it's possible to craft ciphertext

879
00:31:34,880 --> 00:31:36,320
that can have multiple different

880
00:31:36,320 --> 00:31:38,320
decryptions under different decryption

881
00:31:38,320 --> 00:31:40,159
keys and so the reason why this is a

882
00:31:40,159 --> 00:31:42,159
problem is because the prover the client

883
00:31:42,159 --> 00:31:43,760
can essentially lie about what it's

884
00:31:43,760 --> 00:31:45,440
sending to the middle box and construct

885
00:31:45,440 --> 00:31:47,039
a cipher text that has one decryption

886
00:31:47,039 --> 00:31:49,600
for the server and one other description

887
00:31:49,600 --> 00:31:50,880
for sort of for the middle box in a

888
00:31:50,880 --> 00:31:53,200
sense like in in the proof so kind of

889
00:31:53,200 --> 00:31:55,200
lie about what what it's sending in the

890
00:31:55,200 --> 00:31:57,519
proof

891
00:31:57,600 --> 00:31:58,720
um so

892
00:31:58,720 --> 00:32:00,399
fixing this was was challenging but the

893
00:32:00,399 --> 00:32:01,840
basic idea of how we're going to be able

894
00:32:01,840 --> 00:32:04,640
to fix this uh is to add an additional

895
00:32:04,640 --> 00:32:06,320
uh constraint to the channel opening

896
00:32:06,320 --> 00:32:08,240
circuit um and what the what the

897
00:32:08,240 --> 00:32:09,519
constraint is going to force the client

898
00:32:09,519 --> 00:32:11,519
to prove is that this the key that it's

899
00:32:11,519 --> 00:32:13,200
inputting to this this arithmetic

900
00:32:13,200 --> 00:32:14,799
circuit was actually output from the

901
00:32:14,799 --> 00:32:17,039
handshake uh that it performed with the

902
00:32:17,039 --> 00:32:19,279
server to set up the key uh so we're

903
00:32:19,279 --> 00:32:21,120
going to have the client give us input

904
00:32:21,120 --> 00:32:22,799
in addition to its ciphertext the

905
00:32:22,799 --> 00:32:24,240
transcript of the handshake that the

906
00:32:24,240 --> 00:32:26,159
middlebox saw when it established this

907
00:32:26,159 --> 00:32:29,200
uh secure session uh and then add this

908
00:32:29,200 --> 00:32:31,279
kind of key consistency check uh to the

909
00:32:31,279 --> 00:32:33,519
proof and then if the key consistency

910
00:32:33,519 --> 00:32:35,919
check fails then that's that's what will

911
00:32:35,919 --> 00:32:37,440
let us short circuit the computation and

912
00:32:37,440 --> 00:32:38,799
go to the end but otherwise if it

913
00:32:38,799 --> 00:32:40,399
succeeds then we just sort of do the tls

914
00:32:40,399 --> 00:32:42,159
decryption and then output the output

915
00:32:42,159 --> 00:32:44,159
the message

916
00:32:44,159 --> 00:32:46,240
so then the question really boils down

917
00:32:46,240 --> 00:32:48,240
to how do we build this key consistency

918
00:32:48,240 --> 00:32:51,039
check uh efficiently uh and because i

919
00:32:51,039 --> 00:32:52,559
only have 20 minutes and not two hours

920
00:32:52,559 --> 00:32:54,320
i'm going to give you the short version

921
00:32:54,320 --> 00:32:56,559
so there's a simple way to build this

922
00:32:56,559 --> 00:32:58,159
key consistency check which is basically

923
00:32:58,159 --> 00:33:00,399
taking the tls 1.3 key schedule that i

924
00:33:00,399 --> 00:33:02,799
showed uh earlier uh and expressing it

925
00:33:02,799 --> 00:33:04,159
all in an arithmetic circuit and then

926
00:33:04,159 --> 00:33:06,640
proving the whole thing uh from the the

927
00:33:06,640 --> 00:33:08,240
input of the handshake

928
00:33:08,240 --> 00:33:09,840
and then basically proving that the key

929
00:33:09,840 --> 00:33:11,120
is equal to the one that you get out of

930
00:33:11,120 --> 00:33:13,679
this key derivation um now this works in

931
00:33:13,679 --> 00:33:15,600
the paper we prove that like it's not so

932
00:33:15,600 --> 00:33:16,480
hard to see because like the

933
00:33:16,480 --> 00:33:18,080
diffie-hellman values in the handshake

934
00:33:18,080 --> 00:33:20,159
are are like binding commitments to the

935
00:33:20,159 --> 00:33:22,320
shared secret like this prevents the

936
00:33:22,320 --> 00:33:23,919
client from lying about the key that it

937
00:33:23,919 --> 00:33:26,080
puts into the proof it but this is like

938
00:33:26,080 --> 00:33:27,760
really hideously slow and i'll show a

939
00:33:27,760 --> 00:33:29,200
number later in the talk but it takes

940
00:33:29,200 --> 00:33:30,720
way too long to do this in the

941
00:33:30,720 --> 00:33:33,279
arithmetic circuit so what we observe in

942
00:33:33,279 --> 00:33:34,880
the paper that lets us kind of get rid

943
00:33:34,880 --> 00:33:37,120
of this inefficiency is that the tls 1.3

944
00:33:37,120 --> 00:33:38,640
handshake is sort of special in the

945
00:33:38,640 --> 00:33:40,640
sense that it has a message in the

946
00:33:40,640 --> 00:33:42,000
handshake if you're familiar with it

947
00:33:42,000 --> 00:33:43,919
it's the server finished value it has

948
00:33:43,919 --> 00:33:45,679
this message that sort of commits to the

949
00:33:45,679 --> 00:33:47,679
intermediate steps of the of the key

950
00:33:47,679 --> 00:33:51,039
schedule of tls 1.3 and so what we do is

951
00:33:51,039 --> 00:33:53,440
sort of repurpose this message to check

952
00:33:53,440 --> 00:33:55,360
uh the correctness of these intermediate

953
00:33:55,360 --> 00:33:57,679
values uh that the client inputs to the

954
00:33:57,679 --> 00:34:00,159
proof and in so doing sort of cut all of

955
00:34:00,159 --> 00:34:02,559
the in the all the expensive part of the

956
00:34:02,559 --> 00:34:04,880
key the key derivation out so we get rid

957
00:34:04,880 --> 00:34:07,600
of the um like the diffie-hellman stuff

958
00:34:07,600 --> 00:34:09,119
and hashing the transcript and that kind

959
00:34:09,119 --> 00:34:10,480
of thing

960
00:34:10,480 --> 00:34:11,839
but uh there's a lot i'm not saying

961
00:34:11,839 --> 00:34:13,359
about this so um please see the paper

962
00:34:13,359 --> 00:34:15,679
and so one thing about this this key

963
00:34:15,679 --> 00:34:16,719
consistent check which is really

964
00:34:16,719 --> 00:34:18,399
interesting that i want to highlight is

965
00:34:18,399 --> 00:34:20,239
that this key consistency check because

966
00:34:20,239 --> 00:34:23,119
tls 1.3 keys are usually

967
00:34:23,119 --> 00:34:24,639
established once for an entire session

968
00:34:24,639 --> 00:34:26,000
the key consistency check can actually

969
00:34:26,000 --> 00:34:28,560
be amortized across all the proofs that

970
00:34:28,560 --> 00:34:31,040
the client sends about a in a session so

971
00:34:31,040 --> 00:34:32,159
what the client can do is at the

972
00:34:32,159 --> 00:34:33,440
beginning of a session before it sends

973
00:34:33,440 --> 00:34:34,639
any traffic is sort of send the middle

974
00:34:34,639 --> 00:34:36,639
box a hash along with the proof and the

975
00:34:36,639 --> 00:34:38,320
proof says that the pre-image of this

976
00:34:38,320 --> 00:34:40,399
hash is consistent with the handshake

977
00:34:40,399 --> 00:34:42,079
that i just performed to set up this

978
00:34:42,079 --> 00:34:44,159
channel and then the middle box can

979
00:34:44,159 --> 00:34:47,280
store the hash and then later when the

980
00:34:47,280 --> 00:34:49,599
client wants to do a channel opening um

981
00:34:49,599 --> 00:34:51,359
rather than redoing the key consistency

982
00:34:51,359 --> 00:34:52,960
check it can just sort of give the hash

983
00:34:52,960 --> 00:34:54,159
that the middle box already knows as

984
00:34:54,159 --> 00:34:56,560
input and say hey middlebox uh the key

985
00:34:56,560 --> 00:34:57,839
that i'm doing is consistent with this

986
00:34:57,839 --> 00:34:59,280
proof that you already checked about the

987
00:34:59,280 --> 00:35:01,920
key consistency so this this can get rid

988
00:35:01,920 --> 00:35:03,839
of the key consistency check in the per

989
00:35:03,839 --> 00:35:06,320
packet proofs uh entirely

990
00:35:06,320 --> 00:35:08,320
so just pop up for a second i just told

991
00:35:08,320 --> 00:35:09,680
you some technical stuff about the way

992
00:35:09,680 --> 00:35:11,280
we build circuits for zero knowledge

993
00:35:11,280 --> 00:35:13,760
middle boxes but i now want to explain

994
00:35:13,760 --> 00:35:15,040
how we actually applies the zero

995
00:35:15,040 --> 00:35:17,119
knowledge middlebox framework to real

996
00:35:17,119 --> 00:35:18,640
applications so i'll talk about

997
00:35:18,640 --> 00:35:20,800
filtering encrypted dns

998
00:35:20,800 --> 00:35:22,720
so if you're not familiar with dns

999
00:35:22,720 --> 00:35:24,720
that's all right dns is basically just a

1000
00:35:24,720 --> 00:35:26,160
phone book for the internet it

1001
00:35:26,160 --> 00:35:28,079
translates uh human readable domain

1002
00:35:28,079 --> 00:35:31,680
names to ip addresses and dns queries

1003
00:35:31,680 --> 00:35:33,520
reveal sort of the full list of domains

1004
00:35:33,520 --> 00:35:34,800
that you visited while you're browsing

1005
00:35:34,800 --> 00:35:36,400
the web so they have huge privacy

1006
00:35:36,400 --> 00:35:37,920
implications so for example if you're

1007
00:35:37,920 --> 00:35:40,320
visiting a political party's website you

1008
00:35:40,320 --> 00:35:41,760
might reveal something about your

1009
00:35:41,760 --> 00:35:43,440
political affiliations from your dns

1010
00:35:43,440 --> 00:35:45,760
queries and because of this a lot of

1011
00:35:45,760 --> 00:35:47,359
people are thinking really hard about

1012
00:35:47,359 --> 00:35:49,680
ways to make dns more private and

1013
00:35:49,680 --> 00:35:51,520
deploying encrypted dns protocols like

1014
00:35:51,520 --> 00:35:55,440
dns over https and dns over tls uh to

1015
00:35:55,440 --> 00:35:57,599
improve the privacy of dns traffic by

1016
00:35:57,599 --> 00:36:00,079
encrypting it uh with a shared key to

1017
00:36:00,079 --> 00:36:01,920
the dns recursive resolver that the

1018
00:36:01,920 --> 00:36:04,560
client contacts and crucially this dns

1019
00:36:04,560 --> 00:36:06,320
recursive resolver is often not the one

1020
00:36:06,320 --> 00:36:08,160
that the network might want the client

1021
00:36:08,160 --> 00:36:10,000
to use it might be a remote resolver

1022
00:36:10,000 --> 00:36:12,560
like from cloudflare or google

1023
00:36:12,560 --> 00:36:14,720
um and this encrypted dns

1024
00:36:14,720 --> 00:36:16,240
in just in the last couple of years has

1025
00:36:16,240 --> 00:36:17,760
become the default

1026
00:36:17,760 --> 00:36:20,400
mode uh for for dns in in major browsers

1027
00:36:20,400 --> 00:36:23,359
like firefox and chrome and edge um

1028
00:36:23,359 --> 00:36:26,000
but because the encrypted dns by design

1029
00:36:26,000 --> 00:36:28,000
hides the dns queries from the network

1030
00:36:28,000 --> 00:36:30,560
it creates a huge huge tension between

1031
00:36:30,560 --> 00:36:33,119
uh policy enforcement of dns filtering

1032
00:36:33,119 --> 00:36:36,880
and and indeed in dns encryption

1033
00:36:36,880 --> 00:36:39,440
so this tension is especially acute in

1034
00:36:39,440 --> 00:36:41,760
in networks where filtering is legally

1035
00:36:41,760 --> 00:36:43,760
required so for example in the united

1036
00:36:43,760 --> 00:36:45,040
states a law exists called the

1037
00:36:45,040 --> 00:36:46,800
children's internet protection law which

1038
00:36:46,800 --> 00:36:49,119
was passed in 2000 that requires the

1039
00:36:49,119 --> 00:36:50,800
administrators of certain educational

1040
00:36:50,800 --> 00:36:52,880
and library networks to filter internet

1041
00:36:52,880 --> 00:36:54,320
access to prevent children from seeing

1042
00:36:54,320 --> 00:36:56,640
obscene content

1043
00:36:56,640 --> 00:36:59,200
and so when firefox was deploying

1044
00:36:59,200 --> 00:37:01,119
encrypted dns this

1045
00:37:01,119 --> 00:37:02,320
in part because of the pressure from

1046
00:37:02,320 --> 00:37:03,760
these groups who needed to filter using

1047
00:37:03,760 --> 00:37:06,880
dns they built a

1048
00:37:06,880 --> 00:37:08,560
they built a sort of

1049
00:37:08,560 --> 00:37:10,320
uh kill switch for the network into

1050
00:37:10,320 --> 00:37:12,800
their browser so firefox when it opens

1051
00:37:12,800 --> 00:37:14,720
up sort of asks the local network if

1052
00:37:14,720 --> 00:37:16,480
it's allowed to do encrypted dns and if

1053
00:37:16,480 --> 00:37:19,200
the local network says no then firefox

1054
00:37:19,200 --> 00:37:21,760
will disable dns disable encrypted dns

1055
00:37:21,760 --> 00:37:24,480
and just do do plain text dns and so i

1056
00:37:24,480 --> 00:37:26,320
think this is a really remarkable thing

1057
00:37:26,320 --> 00:37:28,079
that i just want to dwell on so firefox

1058
00:37:28,079 --> 00:37:29,839
i would say most people would agree is a

1059
00:37:29,839 --> 00:37:32,320
pretty privacy focused browser and

1060
00:37:32,320 --> 00:37:34,240
exactly because of this tension between

1061
00:37:34,240 --> 00:37:36,079
privacy and policy enforcement they were

1062
00:37:36,079 --> 00:37:37,680
forced to build sort of a downgrade

1063
00:37:37,680 --> 00:37:40,800
attack into firefox uh to prevent the

1064
00:37:40,800 --> 00:37:42,640
use of privacy enhancing technologies

1065
00:37:42,640 --> 00:37:45,119
which is a an interesting and i think a

1066
00:37:45,119 --> 00:37:46,560
um

1067
00:37:46,560 --> 00:37:48,160
interesting motivational outcome for for

1068
00:37:48,160 --> 00:37:49,200
this work

1069
00:37:49,200 --> 00:37:51,839
um so to solve problems like this we're

1070
00:37:51,839 --> 00:37:53,440
i'm going to show just briefly how to

1071
00:37:53,440 --> 00:37:54,880
build a xeronaut model box for filtering

1072
00:37:54,880 --> 00:37:57,119
encrypted dns uh so the first thing is

1073
00:37:57,119 --> 00:37:58,320
that the network is going to take its

1074
00:37:58,320 --> 00:38:00,480
block list and build a circuit as i

1075
00:38:00,480 --> 00:38:01,520
described before with the following

1076
00:38:01,520 --> 00:38:02,880
three steps so channel opening is going

1077
00:38:02,880 --> 00:38:04,160
to be the thing i described before for

1078
00:38:04,160 --> 00:38:05,520
tls 1.3

1079
00:38:05,520 --> 00:38:08,000
person extract is going to check the the

1080
00:38:08,000 --> 00:38:09,839
format of the dns query in the in the

1081
00:38:09,839 --> 00:38:11,280
plain text and then extract and

1082
00:38:11,280 --> 00:38:13,920
deserialize the domain name from the dns

1083
00:38:13,920 --> 00:38:15,680
queries wire format to like a human

1084
00:38:15,680 --> 00:38:17,839
readable format and then policy check is

1085
00:38:17,839 --> 00:38:19,920
going to verify that that domain name is

1086
00:38:19,920 --> 00:38:21,599
is not a member of the set of all the

1087
00:38:21,599 --> 00:38:23,200
blocked domains and the way we're going

1088
00:38:23,200 --> 00:38:25,280
to do this i i won't go into detail but

1089
00:38:25,280 --> 00:38:26,800
this is like a really standard technique

1090
00:38:26,800 --> 00:38:28,960
using like a sorted like like verifying

1091
00:38:28,960 --> 00:38:30,839
paths in a sort of merkle

1092
00:38:30,839 --> 00:38:34,160
tree uh so the clients get this circuit

1093
00:38:34,160 --> 00:38:35,599
and the block list when they join the

1094
00:38:35,599 --> 00:38:38,160
network uh and then they use standard

1095
00:38:38,160 --> 00:38:40,480
tls 1.3 to establish a shared key with

1096
00:38:40,480 --> 00:38:43,119
the remote resolver and then when they

1097
00:38:43,119 --> 00:38:44,720
when they want to make a dns query they

1098
00:38:44,720 --> 00:38:46,960
include a sort of proof of the

1099
00:38:46,960 --> 00:38:48,240
that this arithmetic circuit is

1100
00:38:48,240 --> 00:38:50,160
satisfied and they include witnesses for

1101
00:38:50,160 --> 00:38:52,160
the the policy check portion of this

1102
00:38:52,160 --> 00:38:53,440
that proves that their domain name is

1103
00:38:53,440 --> 00:38:56,320
not in the block list

1104
00:38:56,320 --> 00:38:58,720
so i'll defer most of the details to the

1105
00:38:58,720 --> 00:39:00,880
paper but i do want to say just just two

1106
00:39:00,880 --> 00:39:03,839
things the first is that for dot and doh

1107
00:39:03,839 --> 00:39:04,560
uh

1108
00:39:04,560 --> 00:39:06,800
the this basic circuit template uh works

1109
00:39:06,800 --> 00:39:08,560
with with very few modifications the

1110
00:39:08,560 --> 00:39:09,760
only thing that really needs to change

1111
00:39:09,760 --> 00:39:11,599
is the parson extract step so how the

1112
00:39:11,599 --> 00:39:13,760
plain text is processed to extract the

1113
00:39:13,760 --> 00:39:15,839
domain uh the domain name from the dns

1114
00:39:15,839 --> 00:39:17,920
query and the second thing is that we're

1115
00:39:17,920 --> 00:39:19,440
sort of assuming that the block list is

1116
00:39:19,440 --> 00:39:21,280
public and can be given to every client

1117
00:39:21,280 --> 00:39:23,359
here in the paper we show that if you

1118
00:39:23,359 --> 00:39:24,880
don't want to

1119
00:39:24,880 --> 00:39:26,320
give the block list to the client there

1120
00:39:26,320 --> 00:39:28,240
are ways to hide this if you can incur

1121
00:39:28,240 --> 00:39:29,839
additional computational costs for the

1122
00:39:29,839 --> 00:39:31,520
proof and an additional round of

1123
00:39:31,520 --> 00:39:33,599
communication so if if you want you

1124
00:39:33,599 --> 00:39:34,800
could think of this as being some sort

1125
00:39:34,800 --> 00:39:36,800
of private in private set intersection

1126
00:39:36,800 --> 00:39:38,960
like protocol roughly

1127
00:39:38,960 --> 00:39:42,160
but see the paper for more details

1128
00:39:42,160 --> 00:39:43,680
uh so we implemented this zero knowledge

1129
00:39:43,680 --> 00:39:45,839
middle box uh for uh for encrypted dns

1130
00:39:45,839 --> 00:39:47,119
and i'll just briefly go over some

1131
00:39:47,119 --> 00:39:49,839
results so we used the xj snark uh zero

1132
00:39:49,839 --> 00:39:52,320
knowledge proof front end uh to build uh

1133
00:39:52,320 --> 00:39:54,320
arithmetic circuits out of our our zero

1134
00:39:54,320 --> 00:39:56,480
knowledge proof uh sort of like in a

1135
00:39:56,480 --> 00:39:57,760
high-level language and we compiled them

1136
00:39:57,760 --> 00:39:58,960
to an arithmetic circuit and then we

1137
00:39:58,960 --> 00:40:01,040
used the gross 16 um zero knowledge

1138
00:40:01,040 --> 00:40:02,720
proof back end with with eight threads

1139
00:40:02,720 --> 00:40:04,640
for the prover and so what we found is

1140
00:40:04,640 --> 00:40:06,800
that uh first we did a a benchmark like

1141
00:40:06,800 --> 00:40:08,560
a micro benchmark this key consistency

1142
00:40:08,560 --> 00:40:10,400
check and found that the baseline that i

1143
00:40:10,400 --> 00:40:12,240
described is indeed like very

1144
00:40:12,240 --> 00:40:14,960
inefficient it has like 7.5 million

1145
00:40:14,960 --> 00:40:16,319
gates in this circuit so it's quite a

1146
00:40:16,319 --> 00:40:18,560
large circuit and proving takes about 94

1147
00:40:18,560 --> 00:40:20,880
seconds for a key consistency check um

1148
00:40:20,880 --> 00:40:22,560
and it additionally requires the client

1149
00:40:22,560 --> 00:40:25,119
to store about a 1.2 gigabyte proving

1150
00:40:25,119 --> 00:40:27,839
key when it joins the network um but

1151
00:40:27,839 --> 00:40:30,960
because the groth 16 um proofs are are

1152
00:40:30,960 --> 00:40:31,920
quite small and have constant

1153
00:40:31,920 --> 00:40:34,240
verification time um the proof size and

1154
00:40:34,240 --> 00:40:35,680
the verification time here are like

1155
00:40:35,680 --> 00:40:38,400
constant 128 and 5 milliseconds

1156
00:40:38,400 --> 00:40:40,240
um what we found is that this optimized

1157
00:40:40,240 --> 00:40:41,520
circuit that we came up with actually

1158
00:40:41,520 --> 00:40:43,119
improves things quite a bit here it it

1159
00:40:43,119 --> 00:40:45,119
reduces the size of the circuit and by

1160
00:40:45,119 --> 00:40:48,000
7x and the proving time by 6x um so it

1161
00:40:48,000 --> 00:40:50,240
it produces a really important

1162
00:40:50,240 --> 00:40:52,960
improvement although i arguably this

1163
00:40:52,960 --> 00:40:54,560
isn't yet close to practical but this is

1164
00:40:54,560 --> 00:40:56,880
still a pretty big improvement so we

1165
00:40:56,880 --> 00:40:57,839
also

1166
00:40:57,839 --> 00:41:00,480
benchmarked our our dns case studies so

1167
00:41:00,480 --> 00:41:02,640
excluding the cost of the one-time uh

1168
00:41:02,640 --> 00:41:05,280
key like session setup above um we found

1169
00:41:05,280 --> 00:41:07,920
that for doh it takes about 6.8 seconds

1170
00:41:07,920 --> 00:41:10,880
to generate a proof we're for a 500 byte

1171
00:41:10,880 --> 00:41:13,839
cipher text and for the aes

1172
00:41:13,839 --> 00:41:16,480
cipher suite in tls but for dot the

1173
00:41:16,480 --> 00:41:18,839
costs are much less so for dot and

1174
00:41:18,839 --> 00:41:22,079
cha-cha in in tls we found that we can

1175
00:41:22,079 --> 00:41:25,040
generate a proof for this this dot

1176
00:41:25,040 --> 00:41:26,560
filtering functionality in about three

1177
00:41:26,560 --> 00:41:30,480
seconds um which is not practical by any

1178
00:41:30,480 --> 00:41:32,400
means yet because waiting three seconds

1179
00:41:32,400 --> 00:41:34,000
to do a dns query is a little bit

1180
00:41:34,000 --> 00:41:36,160
prohibitive um but this number i think

1181
00:41:36,160 --> 00:41:38,079
for for a first implementation of this

1182
00:41:38,079 --> 00:41:39,520
kind of whole framework i think this is

1183
00:41:39,520 --> 00:41:41,359
a very very exciting uh number and

1184
00:41:41,359 --> 00:41:42,880
there's a lot of tools in our toolbox to

1185
00:41:42,880 --> 00:41:45,760
get this this cost down um so briefly

1186
00:41:45,760 --> 00:41:47,359
with the last like like i don't know how

1187
00:41:47,359 --> 00:41:48,720
many minutes i'm just going to talk

1188
00:41:48,720 --> 00:41:50,480
about some ongoing and future work that

1189
00:41:50,480 --> 00:41:53,280
we plan to do so we took our

1190
00:41:53,280 --> 00:41:54,160
our

1191
00:41:54,160 --> 00:41:55,599
kind of arithmetic circuits and we

1192
00:41:55,599 --> 00:41:56,880
ported them over to a newer

1193
00:41:56,880 --> 00:41:58,079
zero-knowledge proof system called

1194
00:41:58,079 --> 00:41:59,680
spartan and spartan is interesting

1195
00:41:59,680 --> 00:42:01,200
because it has a different trade-off

1196
00:42:01,200 --> 00:42:03,200
between prover time and oops sorry so

1197
00:42:03,200 --> 00:42:05,040
between prover time and

1198
00:42:05,040 --> 00:42:07,359
proof size and verifier time

1199
00:42:07,359 --> 00:42:09,359
so what we found that just by porting to

1200
00:42:09,359 --> 00:42:12,079
spartan the cost the approver's time

1201
00:42:12,079 --> 00:42:13,839
cost of setting up a tls session goes

1202
00:42:13,839 --> 00:42:16,960
down to just 1.7 seconds which is a huge

1203
00:42:16,960 --> 00:42:19,040
like a 10x improvement over the previous

1204
00:42:19,040 --> 00:42:21,440
um over the previous implementation and

1205
00:42:21,440 --> 00:42:23,359
now uh the proof size and the verifier

1206
00:42:23,359 --> 00:42:25,280
timer a little bit higher here

1207
00:42:25,280 --> 00:42:27,280
but i personally i think that because

1208
00:42:27,280 --> 00:42:29,280
this is a one-time setup cost and

1209
00:42:29,280 --> 00:42:31,440
because 49 kilobytes really is pretty

1210
00:42:31,440 --> 00:42:33,520
small in absolute terms i think these

1211
00:42:33,520 --> 00:42:36,319
costs are are still like on the verge of

1212
00:42:36,319 --> 00:42:38,560
practical um feel free to disagree with

1213
00:42:38,560 --> 00:42:40,319
me if you don't believe that um and we

1214
00:42:40,319 --> 00:42:42,480
also haven't yet finished

1215
00:42:42,480 --> 00:42:44,319
implementing all of our dot case study

1216
00:42:44,319 --> 00:42:46,319
in spartan uh but what we found is just

1217
00:42:46,319 --> 00:42:49,040
the the the decryption part of the dot

1218
00:42:49,040 --> 00:42:51,040
circuit which is like what like about

1219
00:42:51,040 --> 00:42:52,480
half the co a little less than half the

1220
00:42:52,480 --> 00:42:55,520
cost overall um doing that takes only

1221
00:42:55,520 --> 00:42:57,040
like two tenths of a second for the

1222
00:42:57,040 --> 00:42:58,880
decryption which is which is a really

1223
00:42:58,880 --> 00:43:00,800
really remarkable thing so you can you

1224
00:43:00,800 --> 00:43:02,319
can imagine that these costs would like

1225
00:43:02,319 --> 00:43:04,400
maybe roughly double for the full

1226
00:43:04,400 --> 00:43:06,079
circuit so it's like think like

1227
00:43:06,079 --> 00:43:07,520
something like four tenths of a second

1228
00:43:07,520 --> 00:43:09,280
for just approver time and then the

1229
00:43:09,280 --> 00:43:11,040
overall end-to-end latency increase of

1230
00:43:11,040 --> 00:43:13,359
this dot could be as low as like like

1231
00:43:13,359 --> 00:43:15,599
like half a second um and again here the

1232
00:43:15,599 --> 00:43:17,359
proofs are larger we have some ideas to

1233
00:43:17,359 --> 00:43:19,599
to get this down so i i maybe this isn't

1234
00:43:19,599 --> 00:43:21,440
like quite practical in terms of the the

1235
00:43:21,440 --> 00:43:23,200
bandwidth overhead yet but i think these

1236
00:43:23,200 --> 00:43:25,680
are really really exciting um initial

1237
00:43:25,680 --> 00:43:28,160
results for this ongoing work

1238
00:43:28,160 --> 00:43:29,920
uh so just in conclusion uh my

1239
00:43:29,920 --> 00:43:31,520
co-authors and i initiated a new line of

1240
00:43:31,520 --> 00:43:33,040
work on xero knowledge middle boxes

1241
00:43:33,040 --> 00:43:34,640
which use zero knowledge proofs to

1242
00:43:34,640 --> 00:43:36,240
resolve tensions between privacy and

1243
00:43:36,240 --> 00:43:38,400
policy enforcement and networks

1244
00:43:38,400 --> 00:43:39,839
i showed you an application of zero

1245
00:43:39,839 --> 00:43:41,760
knowledge metal boxes to dns filtering

1246
00:43:41,760 --> 00:43:44,400
uh for encrypted dns um we designed zero

1247
00:43:44,400 --> 00:43:46,480
knowledge metal boxes for dot and doh

1248
00:43:46,480 --> 00:43:47,920
and in the paper we also described two

1249
00:43:47,920 --> 00:43:49,839
other case studies one is doing a

1250
00:43:49,839 --> 00:43:52,079
resolver allow listing for oblivious doh

1251
00:43:52,079 --> 00:43:54,000
which is sort of like a version of doh

1252
00:43:54,000 --> 00:43:55,920
that has additional client privacy so it

1253
00:43:55,920 --> 00:43:57,200
uses kind of a one hop proxy

1254
00:43:57,200 --> 00:43:58,720
architecture and the other thing that we

1255
00:43:58,720 --> 00:44:00,640
showed is allowing clients to prove that

1256
00:44:00,640 --> 00:44:02,319
the underlying traffic of their tls

1257
00:44:02,319 --> 00:44:04,880
session is hdp

1258
00:44:04,880 --> 00:44:05,839
and

1259
00:44:05,839 --> 00:44:07,359
we are really really excited about zero

1260
00:44:07,359 --> 00:44:09,040
knowledge middle boxes um we think that

1261
00:44:09,040 --> 00:44:10,560
this zero knowledge middlebox framework

1262
00:44:10,560 --> 00:44:12,800
has it has a ton of potential to solve

1263
00:44:12,800 --> 00:44:14,800
really really challenging problems uh

1264
00:44:14,800 --> 00:44:16,720
that exists today in networks and also

1265
00:44:16,720 --> 00:44:19,119
just in for in terms of research raised

1266
00:44:19,119 --> 00:44:21,040
like really fascinating open problems

1267
00:44:21,040 --> 00:44:22,800
and like systems and networking and

1268
00:44:22,800 --> 00:44:25,440
cryptography um so with that i'll i'll

1269
00:44:25,440 --> 00:44:26,960
take any questions and thank you very

1270
00:44:26,960 --> 00:44:27,960
much for listening

1271
00:44:27,960 --> 00:44:28,430
[Applause]

1272
00:44:28,430 --> 00:44:34,480
[Music]

1273
00:44:35,680 --> 00:44:37,839
we're over time so maybe one very quick

1274
00:44:37,839 --> 00:44:39,440
question sorry about that can you

1275
00:44:39,440 --> 00:44:40,480
combine

1276
00:44:40,480 --> 00:44:42,160
on your plan ultimate slide can you

1277
00:44:42,160 --> 00:44:45,359
combine spartan for the it's set up with

1278
00:44:45,359 --> 00:44:47,680
gross 16 for the actual messages can you

1279
00:44:47,680 --> 00:44:49,440
combine the two

1280
00:44:49,440 --> 00:44:51,280
um

1281
00:44:51,280 --> 00:44:53,040
in principle yes but i think the prover

1282
00:44:53,040 --> 00:44:54,560
the concrete prover time might be too

1283
00:44:54,560 --> 00:44:56,480
high um

1284
00:44:56,480 --> 00:44:57,760
but that's an interesting like doing

1285
00:44:57,760 --> 00:44:59,359
some kind of recursion is an interesting

1286
00:44:59,359 --> 00:45:01,119
idea yeah

1287
00:45:01,119 --> 00:45:02,400
okay

1288
00:45:02,400 --> 00:45:05,839
thanks everybody thanks paul

1289
00:45:11,280 --> 00:45:13,359
all right so our final speaker is

1290
00:45:13,359 --> 00:45:14,880
christoph strikes who's going to be

1291
00:45:14,880 --> 00:45:16,160
speaking about

1292
00:45:16,160 --> 00:45:18,960
punctual encryption please welcome the

1293
00:45:18,960 --> 00:45:21,280
speaker

1294
00:45:24,800 --> 00:45:26,240
thanks nick

1295
00:45:26,240 --> 00:45:27,599
and

1296
00:45:27,599 --> 00:45:30,480
from zero knowledge to forward secrecy

1297
00:45:30,480 --> 00:45:32,560
or forward security as our call is in

1298
00:45:32,560 --> 00:45:33,599
the talk

1299
00:45:33,599 --> 00:45:35,839
uh forward security is omnipresent

1300
00:45:35,839 --> 00:45:37,599
nowadays right so

1301
00:45:37,599 --> 00:45:39,839
every day we use it browsing the web and

1302
00:45:39,839 --> 00:45:42,400
also messaging wire signal and so on

1303
00:45:42,400 --> 00:45:44,000
but

1304
00:45:44,000 --> 00:45:46,720
actually when you want to deploy it

1305
00:45:46,720 --> 00:45:49,040
in a non-interactive setting it gets

1306
00:45:49,040 --> 00:45:51,359
kind of hard and currently there's only

1307
00:45:51,359 --> 00:45:53,440
one larger player i will not reveal it

1308
00:45:53,440 --> 00:45:55,920
now but later who is that we're doing

1309
00:45:55,920 --> 00:45:56,720
this

1310
00:45:56,720 --> 00:45:57,520
and

1311
00:45:57,520 --> 00:45:59,680
punctual encryption here comes in so

1312
00:45:59,680 --> 00:46:01,200
this non-interactive setting it's much

1313
00:46:01,200 --> 00:46:03,040
harder to achieve and that's where we

1314
00:46:03,040 --> 00:46:06,000
depart so my name is christoph strix i'm

1315
00:46:06,000 --> 00:46:07,359
from iit austrian institute of

1316
00:46:07,359 --> 00:46:09,040
technology in vienna and this joint work

1317
00:46:09,040 --> 00:46:10,079
with uh

1318
00:46:10,079 --> 00:46:13,040
ramahandani islamonic

1319
00:46:13,040 --> 00:46:15,200
so the cryptographic community has

1320
00:46:15,200 --> 00:46:16,960
developed beautiful tools ranging from

1321
00:46:16,960 --> 00:46:18,560
signatures key exchange secure

1322
00:46:18,560 --> 00:46:20,640
communications computation on data and

1323
00:46:20,640 --> 00:46:24,480
so on but even if built correctly

1324
00:46:24,480 --> 00:46:27,119
all security guarantees rest at least on

1325
00:46:27,119 --> 00:46:28,400
the security and trust of the

1326
00:46:28,400 --> 00:46:30,560
cryptographic keys right so and then

1327
00:46:30,560 --> 00:46:33,200
following i will show you a few slides

1328
00:46:33,200 --> 00:46:35,040
as applications where the security and

1329
00:46:35,040 --> 00:46:37,760
trust where they are exploited

1330
00:46:37,760 --> 00:46:41,680
so most prominent prominently in 2014

1331
00:46:41,680 --> 00:46:42,400
the

1332
00:46:42,400 --> 00:46:44,880
heartbleed bug enabled

1333
00:46:44,880 --> 00:46:47,520
to extract keys usernames credentials

1334
00:46:47,520 --> 00:46:50,240
from servers using an unpatched version

1335
00:46:50,240 --> 00:46:51,839
of openssl

1336
00:46:51,839 --> 00:46:53,599
so this those keys could have been used

1337
00:46:53,599 --> 00:46:55,359
to impersonate users or spine

1338
00:46:55,359 --> 00:46:57,839
communication

1339
00:46:58,800 --> 00:47:02,240
there is so much uh in the cryptographic

1340
00:47:02,240 --> 00:47:03,599
literature on the topic of key

1341
00:47:03,599 --> 00:47:05,760
extraction and just at this symposium

1342
00:47:05,760 --> 00:47:08,000
here yesterday two beautiful works were

1343
00:47:08,000 --> 00:47:09,359
shown and

1344
00:47:09,359 --> 00:47:11,839
presented the left one is on the open

1345
00:47:11,839 --> 00:47:13,839
pgp standard and the encryption

1346
00:47:13,839 --> 00:47:15,839
algorithm alcamar to extract keystone

1347
00:47:15,839 --> 00:47:17,680
across configuration attack and the

1348
00:47:17,680 --> 00:47:20,800
right one exploits uh recent samsung

1349
00:47:20,800 --> 00:47:22,960
phones and the android hardware devices

1350
00:47:22,960 --> 00:47:25,839
to extract keys

1351
00:47:26,160 --> 00:47:28,240
but also we have the human factor right

1352
00:47:28,240 --> 00:47:29,280
so

1353
00:47:29,280 --> 00:47:30,400
usually

1354
00:47:30,400 --> 00:47:32,960
to communicate with security teams you

1355
00:47:32,960 --> 00:47:36,880
publish or you put out public keys right

1356
00:47:36,880 --> 00:47:38,960
on the left you see an example where uh

1357
00:47:38,960 --> 00:47:42,319
and uh adobe security team output or

1358
00:47:42,319 --> 00:47:44,800
puts the public key and this the private

1359
00:47:44,800 --> 00:47:47,119
key uh out

1360
00:47:47,119 --> 00:47:50,160
and even though the secret key was

1361
00:47:50,160 --> 00:47:52,079
encrypted with a passphrase you should

1362
00:47:52,079 --> 00:47:54,319
never never publish the private key

1363
00:47:54,319 --> 00:47:55,680
right

1364
00:47:55,680 --> 00:47:57,839
on the right this is an example when

1365
00:47:57,839 --> 00:47:59,839
amazon engineer

1366
00:47:59,839 --> 00:48:01,040
leaked

1367
00:48:01,040 --> 00:48:04,160
a gigabyte of sensitive data to github

1368
00:48:04,160 --> 00:48:06,800
and the interesting point here is that

1369
00:48:06,800 --> 00:48:09,040
this was discovered within minutes

1370
00:48:09,040 --> 00:48:10,319
yeah so

1371
00:48:10,319 --> 00:48:13,280
and as it turns out leaking

1372
00:48:13,280 --> 00:48:14,400
things or

1373
00:48:14,400 --> 00:48:16,319
private private keys or something like

1374
00:48:16,319 --> 00:48:18,480
that on github is this thing and

1375
00:48:18,480 --> 00:48:20,400
i researched this this project called

1376
00:48:20,400 --> 00:48:22,559
get guardian yeah i was researching the

1377
00:48:22,559 --> 00:48:24,400
topic and

1378
00:48:24,400 --> 00:48:26,079
and yeah you have to you have to think

1379
00:48:26,079 --> 00:48:27,760
that when you're publishing something on

1380
00:48:27,760 --> 00:48:29,200
github it will be there it will be there

1381
00:48:29,200 --> 00:48:30,559
forever

1382
00:48:30,559 --> 00:48:34,240
as it is a version control system

1383
00:48:34,240 --> 00:48:34,960
so

1384
00:48:34,960 --> 00:48:36,880
additionally to security and trust of

1385
00:48:36,880 --> 00:48:37,920
keys

1386
00:48:37,920 --> 00:48:40,240
we should also add we should also think

1387
00:48:40,240 --> 00:48:41,520
of increasing the resilience of

1388
00:48:41,520 --> 00:48:45,440
cryptographics as key leakages happen

1389
00:48:45,440 --> 00:48:46,960
and

1390
00:48:46,960 --> 00:48:49,520
particularly in key establishment this

1391
00:48:49,520 --> 00:48:51,599
can be a severe issue right if a secret

1392
00:48:51,599 --> 00:48:54,240
key leaks all data is immediate in

1393
00:48:54,240 --> 00:48:56,800
danger ever encrypted ever sent over the

1394
00:48:56,800 --> 00:48:58,000
wire

1395
00:48:58,000 --> 00:48:59,440
one mitigation

1396
00:48:59,440 --> 00:49:01,440
strategy is to use forward security

1397
00:49:01,440 --> 00:49:05,040
indeed as this keeps old data safe

1398
00:49:05,040 --> 00:49:07,200
and this is efficient i said in an

1399
00:49:07,200 --> 00:49:08,800
interactive key exchange protocol and

1400
00:49:08,800 --> 00:49:10,880
mandatory and modes which

1401
00:49:10,880 --> 00:49:13,119
which we have seen in tls 1.3

1402
00:49:13,119 --> 00:49:15,599
resulting in over 99 of internet sites

1403
00:49:15,599 --> 00:49:16,640
surveyed

1404
00:49:16,640 --> 00:49:19,200
by uh koalas ssl labs at least

1405
00:49:19,200 --> 00:49:20,480
supporting

1406
00:49:20,480 --> 00:49:22,559
one or at least some form of forward

1407
00:49:22,559 --> 00:49:24,559
security furthermore this is highly

1408
00:49:24,559 --> 00:49:26,480
recognized by industry by the larger

1409
00:49:26,480 --> 00:49:28,640
players google apple meta microsoft and

1410
00:49:28,640 --> 00:49:30,480
cloudflare but as i said in the

1411
00:49:30,480 --> 00:49:31,680
beginning

1412
00:49:31,680 --> 00:49:33,520
in the interactive setting we are fine

1413
00:49:33,520 --> 00:49:36,319
but in a modern maybe more interactive

1414
00:49:36,319 --> 00:49:39,680
setting this is much harder to achieve

1415
00:49:39,680 --> 00:49:41,200
and here comes

1416
00:49:41,200 --> 00:49:42,960
non-attractive forward security so what

1417
00:49:42,960 --> 00:49:46,079
is this the the basic two requirements

1418
00:49:46,079 --> 00:49:48,079
we have in the non-interactive setting

1419
00:49:48,079 --> 00:49:50,240
is that we have a long-term fixed public

1420
00:49:50,240 --> 00:49:51,680
key so

1421
00:49:51,680 --> 00:49:54,079
i will focus on encryption in this talk

1422
00:49:54,079 --> 00:49:56,800
and minimum to no state between entities

1423
00:49:56,800 --> 00:49:58,720
this particularly case

1424
00:49:58,720 --> 00:50:00,240
in distributed setting with many

1425
00:50:00,240 --> 00:50:02,640
decentralized identities and here comes

1426
00:50:02,640 --> 00:50:04,640
the larger player dfinity recently

1427
00:50:04,640 --> 00:50:06,559
deployed the non-integral forward

1428
00:50:06,559 --> 00:50:08,079
security and their non-interactive

1429
00:50:08,079 --> 00:50:09,599
distributed key generation and key

1430
00:50:09,599 --> 00:50:12,319
resharing particle which is quite nice

1431
00:50:12,319 --> 00:50:13,200
and

1432
00:50:13,200 --> 00:50:16,558
but how do we even achieve this

1433
00:50:17,359 --> 00:50:19,280
so what you see here is an

1434
00:50:19,280 --> 00:50:20,800
example of non-interactive forward

1435
00:50:20,800 --> 00:50:22,720
security you see a client on the left

1436
00:50:22,720 --> 00:50:25,200
and the server on the right where the

1437
00:50:25,200 --> 00:50:28,000
client has the public key of the server

1438
00:50:28,000 --> 00:50:29,440
now it's important to note that this is

1439
00:50:29,440 --> 00:50:30,960
epoch based

1440
00:50:30,960 --> 00:50:32,480
meaning that the client and the server

1441
00:50:32,480 --> 00:50:35,760
both then maintain let's say a coupled

1442
00:50:35,760 --> 00:50:37,599
clock something for airports where

1443
00:50:37,599 --> 00:50:39,599
epochs can be from one two three four

1444
00:50:39,599 --> 00:50:40,720
and so on

1445
00:50:40,720 --> 00:50:42,160
and the client now wants to encrypt a

1446
00:50:42,160 --> 00:50:43,760
message

1447
00:50:43,760 --> 00:50:45,920
using using the public key

1448
00:50:45,920 --> 00:50:48,240
and attaching the epoch for example here

1449
00:50:48,240 --> 00:50:51,839
one the server now can use this

1450
00:50:51,839 --> 00:50:54,480
secret key sk1 to decrypt the message

1451
00:50:54,480 --> 00:50:56,960
and after the epoch is over

1452
00:50:56,960 --> 00:50:59,119
this the server can evolve the secret

1453
00:50:59,119 --> 00:51:01,119
key to the second epoch

1454
00:51:01,119 --> 00:51:02,160
meaning or

1455
00:51:02,160 --> 00:51:04,319
guaranteeing that all ciphertexts

1456
00:51:04,319 --> 00:51:06,319
encrypted under epoch 1 are not

1457
00:51:06,319 --> 00:51:08,880
decryptable anymore right so this is a

1458
00:51:08,880 --> 00:51:11,760
reminiscent of canadia levy cuts from

1459
00:51:11,760 --> 00:51:14,319
2003 and it's important to note here

1460
00:51:14,319 --> 00:51:16,319
that we want to have compact parameter

1461
00:51:16,319 --> 00:51:17,839
sizes and indeed it makes the

1462
00:51:17,839 --> 00:51:20,319
construction highly nontrivial

1463
00:51:20,319 --> 00:51:22,160
which the red palm this must be

1464
00:51:22,160 --> 00:51:24,480
independent of the number of epochs so

1465
00:51:24,480 --> 00:51:27,680
but what is the problem here

1466
00:51:28,480 --> 00:51:29,920
so

1467
00:51:29,920 --> 00:51:31,920
actually we have kind of two problems

1468
00:51:31,920 --> 00:51:33,520
the first one is okay we have to agree

1469
00:51:33,520 --> 00:51:35,280
on on some epoch

1470
00:51:35,280 --> 00:51:38,160
how to be how to sync this and the other

1471
00:51:38,160 --> 00:51:40,160
problem much larger is

1472
00:51:40,160 --> 00:51:42,559
that within epochs we do not have

1473
00:51:42,559 --> 00:51:43,839
forward security guarantees of

1474
00:51:43,839 --> 00:51:46,319
ciphertext right

1475
00:51:46,319 --> 00:51:48,558
so

1476
00:51:49,119 --> 00:51:50,880
as it turns out when you want to do it

1477
00:51:50,880 --> 00:51:52,640
in in practice

1478
00:51:52,640 --> 00:51:54,960
you require loose synchronization so

1479
00:51:54,960 --> 00:51:56,800
this epoch should not be seconds or

1480
00:51:56,800 --> 00:51:58,240
minutes but should be maybe days or

1481
00:51:58,240 --> 00:51:59,760
something like this because it's

1482
00:51:59,760 --> 00:52:01,920
required for practicality

1483
00:52:01,920 --> 00:52:04,400
then the problem is that this epoch this

1484
00:52:04,400 --> 00:52:06,480
window is quite open

1485
00:52:06,480 --> 00:52:09,119
so leaving all the data which is sent in

1486
00:52:09,119 --> 00:52:10,400
this epoch

1487
00:52:10,400 --> 00:52:12,079
uh vulnerable

1488
00:52:12,079 --> 00:52:14,480
so the solution is here it was published

1489
00:52:14,480 --> 00:52:15,200
in

1490
00:52:15,200 --> 00:52:18,240
2015 at oakland from green mice and it's

1491
00:52:18,240 --> 00:52:20,160
called punctual encryption with this

1492
00:52:20,160 --> 00:52:21,599
primitive

1493
00:52:21,599 --> 00:52:24,720
you you can now find granularity achieve

1494
00:52:24,720 --> 00:52:26,480
forward security for all data

1495
00:52:26,480 --> 00:52:29,359
non-interactively

1496
00:52:29,599 --> 00:52:31,680
so what is puncture encryption compared

1497
00:52:31,680 --> 00:52:33,520
to the to the slide we've seen before

1498
00:52:33,520 --> 00:52:35,440
compared to the epoch-based approach we

1499
00:52:35,440 --> 00:52:38,720
have now taken a tech based approach

1500
00:52:38,720 --> 00:52:41,680
essentially that you now attach a check

1501
00:52:41,680 --> 00:52:44,240
to a cypher text and you have

1502
00:52:44,240 --> 00:52:47,440
when you have an uh large number of text

1503
00:52:47,440 --> 00:52:49,440
available you can

1504
00:52:49,440 --> 00:52:50,960
you can attach

1505
00:52:50,960 --> 00:52:52,800
though enough text to ciphertext that

1506
00:52:52,800 --> 00:52:54,480
say one which is uniquely defined

1507
00:52:54,480 --> 00:52:57,200
ciphertext and the server now can

1508
00:52:57,200 --> 00:52:59,440
uniquely

1509
00:52:59,440 --> 00:53:01,280
uniquely

1510
00:53:01,280 --> 00:53:03,200
evolved secretly particularly on that

1511
00:53:03,200 --> 00:53:04,720
ciphertext

1512
00:53:04,720 --> 00:53:06,480
for example here there's ciphertext for

1513
00:53:06,480 --> 00:53:08,400
pk understand one

1514
00:53:08,400 --> 00:53:10,480
and the server can after

1515
00:53:10,480 --> 00:53:13,599
decryption it can evolve its secret key

1516
00:53:13,599 --> 00:53:16,319
to a secret key skt one excluding

1517
00:53:16,319 --> 00:53:19,920
particularly that cipher text

1518
00:53:19,920 --> 00:53:22,960
so this is a much more fingered approach

1519
00:53:22,960 --> 00:53:25,040
and it's actually a common encryption

1520
00:53:25,040 --> 00:53:26,800
scheme we've seen

1521
00:53:26,800 --> 00:53:28,720
plus an additional puncture algorithm

1522
00:53:28,720 --> 00:53:29,839
algorithm

1523
00:53:29,839 --> 00:53:32,319
so the key gen outputs a public key the

1524
00:53:32,319 --> 00:53:33,680
long-term fixed public key and the

1525
00:53:33,680 --> 00:53:35,920
initial secret key sk epsilon and

1526
00:53:35,920 --> 00:53:37,599
encryption takes now attack and the

1527
00:53:37,599 --> 00:53:39,119
message and outputs the ciphertext

1528
00:53:39,119 --> 00:53:42,319
associated to in turn to attack t1

1529
00:53:42,319 --> 00:53:44,880
puncturing up on decryption now can

1530
00:53:44,880 --> 00:53:46,079
particularly

1531
00:53:46,079 --> 00:53:48,720
uh modify a secret key such that the

1532
00:53:48,720 --> 00:53:50,400
guarantees are that this

1533
00:53:50,400 --> 00:53:51,680
cipher text

1534
00:53:51,680 --> 00:53:54,640
associated to the to attack t1 cannot be

1535
00:53:54,640 --> 00:53:57,119
decrypted anymore moreover there's a

1536
00:53:57,119 --> 00:53:58,800
distinguishing feature

1537
00:53:58,800 --> 00:54:00,400
here in punctual encryption that you can

1538
00:54:00,400 --> 00:54:02,480
do it repeatedly which essentially means

1539
00:54:02,480 --> 00:54:04,800
that you can add more text secret keys

1540
00:54:04,800 --> 00:54:05,839
and add

1541
00:54:05,839 --> 00:54:07,520
exclude more ciphertext from being

1542
00:54:07,520 --> 00:54:10,520
decryptable

1543
00:54:11,440 --> 00:54:12,400
so

1544
00:54:12,400 --> 00:54:13,839
what has been done in the cryptographic

1545
00:54:13,839 --> 00:54:15,680
literature after the initial

1546
00:54:15,680 --> 00:54:16,559
uh

1547
00:54:16,559 --> 00:54:18,880
introduction 2015

1548
00:54:18,880 --> 00:54:22,000
for asynchronous messaging you see

1549
00:54:22,000 --> 00:54:23,599
over

1550
00:54:23,599 --> 00:54:25,920
over the timeline you see the actually

1551
00:54:25,920 --> 00:54:28,160
application areas where this is

1552
00:54:28,160 --> 00:54:30,720
arranging from zero dtq exchange to

1553
00:54:30,720 --> 00:54:32,880
works on searchable encryption cloud

1554
00:54:32,880 --> 00:54:34,000
backup

1555
00:54:34,000 --> 00:54:36,160
tor

1556
00:54:36,160 --> 00:54:38,480
content delivery networks and so on

1557
00:54:38,480 --> 00:54:40,400
and below the the timeline you see the

1558
00:54:40,400 --> 00:54:42,319
actual works appearing it's interesting

1559
00:54:42,319 --> 00:54:43,280
here that

1560
00:54:43,280 --> 00:54:44,720
there is kind of

1561
00:54:44,720 --> 00:54:46,640
there we have a crypto community papers

1562
00:54:46,640 --> 00:54:48,640
published at eurocrypt and and asia

1563
00:54:48,640 --> 00:54:50,799
group for example and also security

1564
00:54:50,799 --> 00:54:53,920
community papers published ccs or ndss

1565
00:54:53,920 --> 00:54:55,680
particularly i want to mention here to

1566
00:54:55,680 --> 00:54:57,359
work on searchable encryption where they

1567
00:54:57,359 --> 00:55:00,160
have several papers in ccs and ndss

1568
00:55:00,160 --> 00:55:01,839
where punctual encryption is a useful

1569
00:55:01,839 --> 00:55:02,960
tool

1570
00:55:02,960 --> 00:55:06,640
and also a work from osdi

1571
00:55:06,640 --> 00:55:08,799
um on on cloud mobile cloud backup which

1572
00:55:08,799 --> 00:55:10,799
is punctual encryption

1573
00:55:10,799 --> 00:55:12,880
so given those examples

1574
00:55:12,880 --> 00:55:16,400
in the following i want to focus on

1575
00:55:16,400 --> 00:55:18,880
two more and these are zero rtt key

1576
00:55:18,880 --> 00:55:20,240
exchange with forward security and

1577
00:55:20,240 --> 00:55:21,760
replay protection

1578
00:55:21,760 --> 00:55:23,359
and forward security for content

1579
00:55:23,359 --> 00:55:25,920
delivery networks

1580
00:55:25,920 --> 00:55:26,640
so

1581
00:55:26,640 --> 00:55:29,280
for the first application the goal

1582
00:55:29,280 --> 00:55:31,200
is to send cryptographically protected

1583
00:55:31,200 --> 00:55:33,520
data non-interactively meaning in zero

1584
00:55:33,520 --> 00:55:35,280
rtt or zero rounded time just won't

1585
00:55:35,280 --> 00:55:37,280
immediately send the data but want to

1586
00:55:37,280 --> 00:55:38,640
have to guarantee that they are forward

1587
00:55:38,640 --> 00:55:40,880
secure and and replay protected the

1588
00:55:40,880 --> 00:55:42,559
incentive here is you want you want to

1589
00:55:42,559 --> 00:55:45,440
reduce communication cost the problem is

1590
00:55:45,440 --> 00:55:47,359
that conventional key establishing modes

1591
00:55:47,359 --> 00:55:49,280
like tls for example need at least one

1592
00:55:49,280 --> 00:55:50,960
round trip to achieve the forward

1593
00:55:50,960 --> 00:55:53,359
security so let's have a look at tls how

1594
00:55:53,359 --> 00:55:55,200
does how this works we have a client on

1595
00:55:55,200 --> 00:55:57,440
the left server on the right and the

1596
00:55:57,440 --> 00:55:59,040
client starts with sending sending a

1597
00:55:59,040 --> 00:56:01,200
client hello server responds with server

1598
00:56:01,200 --> 00:56:03,680
hello and sending some additional data

1599
00:56:03,680 --> 00:56:05,280
and only then

1600
00:56:05,280 --> 00:56:08,160
the client can send the payload and it

1601
00:56:08,160 --> 00:56:10,079
achieves forward security

1602
00:56:10,079 --> 00:56:10,799
so

1603
00:56:10,799 --> 00:56:13,520
this is necessary

1604
00:56:13,520 --> 00:56:16,960
actually there is a zero idt mode in tls

1605
00:56:16,960 --> 00:56:18,880
which is called early data

1606
00:56:18,880 --> 00:56:20,720
and where this client and server have a

1607
00:56:20,720 --> 00:56:23,760
pre-shared key psk and then the client

1608
00:56:23,760 --> 00:56:24,960
can send

1609
00:56:24,960 --> 00:56:28,319
with the ps key psp psk can send the

1610
00:56:28,319 --> 00:56:31,520
early data encrypted the problem here is

1611
00:56:31,520 --> 00:56:32,880
that we have do not have forward

1612
00:56:32,880 --> 00:56:34,720
security guarantees with the

1613
00:56:34,720 --> 00:56:37,520
with the early data

1614
00:56:37,520 --> 00:56:40,640
so when using puncture encryption and

1615
00:56:40,640 --> 00:56:43,520
there have been several works

1616
00:56:43,520 --> 00:56:44,450
they're using a

1617
00:56:44,450 --> 00:56:46,160
[Music]

1618
00:56:46,160 --> 00:56:48,160
time-based version of that yeah we have

1619
00:56:48,160 --> 00:56:50,000
only a loose synchronization which is

1620
00:56:50,000 --> 00:56:51,040
okay

1621
00:56:51,040 --> 00:56:53,440
and the client can now take

1622
00:56:53,440 --> 00:56:55,200
the public key of the server and check

1623
00:56:55,200 --> 00:56:56,319
it

1624
00:56:56,319 --> 00:56:59,359
and then send send server uh

1625
00:56:59,359 --> 00:57:01,520
uh send it send the ciphertext over to

1626
00:57:01,520 --> 00:57:03,520
the server this achieves forward

1627
00:57:03,520 --> 00:57:05,680
security and repeal protection

1628
00:57:05,680 --> 00:57:08,079
uh in zero rdt and it was done

1629
00:57:08,079 --> 00:57:11,119
first by gunther at all in 2017 and and

1630
00:57:11,119 --> 00:57:12,160
later the

1631
00:57:12,160 --> 00:57:13,680
uh the most efficient version currently

1632
00:57:13,680 --> 00:57:16,079
available is the bloom filter encryption

1633
00:57:16,079 --> 00:57:17,839
scheme

1634
00:57:17,839 --> 00:57:20,400
and there have been some evaluation in

1635
00:57:20,400 --> 00:57:23,839
in the last years uh it constitutes

1636
00:57:23,839 --> 00:57:25,839
2020.

1637
00:57:25,839 --> 00:57:26,799
we had

1638
00:57:26,799 --> 00:57:28,559
where they looked at how to implement

1639
00:57:28,559 --> 00:57:29,760
that in quick

1640
00:57:29,760 --> 00:57:31,839
yeah so how is the

1641
00:57:31,839 --> 00:57:33,680
using punctual encryption or using bloom

1642
00:57:33,680 --> 00:57:36,319
filter encryption particularly how is it

1643
00:57:36,319 --> 00:57:37,920
measured compared to the google quick

1644
00:57:37,920 --> 00:57:39,680
protocol and this is quite

1645
00:57:39,680 --> 00:57:41,599
fairly okay

1646
00:57:41,599 --> 00:57:43,280
so if you want to integrate forward

1647
00:57:43,280 --> 00:57:45,440
security and replay protection uh using

1648
00:57:45,440 --> 00:57:47,680
the bloom filter approach uh to achieve

1649
00:57:47,680 --> 00:57:48,720
forward

1650
00:57:48,720 --> 00:57:50,960
to achieve zero rdt with forward

1651
00:57:50,960 --> 00:57:52,799
security and replay protection this

1652
00:57:52,799 --> 00:57:54,559
could be an option but still i have to

1653
00:57:54,559 --> 00:57:56,480
mention here and be honest that research

1654
00:57:56,480 --> 00:57:58,480
is needed for efficiency okay

1655
00:57:58,480 --> 00:57:59,359
so

1656
00:57:59,359 --> 00:58:00,799
furthermore

1657
00:58:00,799 --> 00:58:01,920
my colleague sebastian ramirez

1658
00:58:01,920 --> 00:58:04,240
integrated this in openssl so

1659
00:58:04,240 --> 00:58:06,720
just go to his github account and

1660
00:58:06,720 --> 00:58:08,720
try it and also just recently

1661
00:58:08,720 --> 00:58:10,079
implemented it on

1662
00:58:10,079 --> 00:58:12,319
the raspberry pi so we also try to do it

1663
00:58:12,319 --> 00:58:14,400
in in that domain

1664
00:58:14,400 --> 00:58:15,839
and

1665
00:58:15,839 --> 00:58:18,960
yeah basically this this sums up

1666
00:58:18,960 --> 00:58:22,000
this use case

1667
00:58:22,000 --> 00:58:24,000
so the second application is for forward

1668
00:58:24,000 --> 00:58:26,319
secure content distribution networks and

1669
00:58:26,319 --> 00:58:28,160
content distribution networks or short

1670
00:58:28,160 --> 00:58:29,680
cdns

1671
00:58:29,680 --> 00:58:32,640
what what is the goal the goal is to

1672
00:58:32,640 --> 00:58:34,640
get the tls secret keys closer to the

1673
00:58:34,640 --> 00:58:37,200
customer to achieve low latency and

1674
00:58:37,200 --> 00:58:38,480
there's actually a nice solution by

1675
00:58:38,480 --> 00:58:40,240
cloudberry out there called geo key

1676
00:58:40,240 --> 00:58:41,760
manager who's

1677
00:58:41,760 --> 00:58:43,040
doing this

1678
00:58:43,040 --> 00:58:44,640
but on the other point also have a nice

1679
00:58:44,640 --> 00:58:46,720
feature of access control so they can

1680
00:58:46,720 --> 00:58:49,040
allow the access to keys for certain

1681
00:58:49,040 --> 00:58:51,440
location while restricting access to

1682
00:58:51,440 --> 00:58:53,440
other to co-locations

1683
00:58:53,440 --> 00:58:55,599
but in any case the problem is that

1684
00:58:55,599 --> 00:58:57,359
conventional ctns do not ensure forward

1685
00:58:57,359 --> 00:59:01,680
security and which means then once a

1686
00:59:01,680 --> 00:59:03,280
location key leaks that the customer

1687
00:59:03,280 --> 00:59:05,680
keys are in danger

1688
00:59:05,680 --> 00:59:08,559
so what we did at financial crypto

1689
00:59:08,559 --> 00:59:11,440
last year we proposed a forward sq

1690
00:59:11,440 --> 00:59:14,799
version for cdns in general and by

1691
00:59:14,799 --> 00:59:16,640
also using an enhanced version of

1692
00:59:16,640 --> 00:59:18,720
punctual encryption where you now have

1693
00:59:18,720 --> 00:59:20,880
something like called a loudless

1694
00:59:20,880 --> 00:59:23,119
denialist encryption where you can put

1695
00:59:23,119 --> 00:59:25,599
something on allow us for example the eu

1696
00:59:25,599 --> 00:59:27,920
here and you put something on the denial

1697
00:59:27,920 --> 00:59:30,960
is london meaning that in stockholm

1698
00:59:30,960 --> 00:59:32,240
the stockholm keys can decrypt the

1699
00:59:32,240 --> 00:59:34,079
ciphertext and get the customer keys on

1700
00:59:34,079 --> 00:59:36,799
rome but in london this is not it's not

1701
00:59:36,799 --> 00:59:38,559
uh cannot be the case the interesting

1702
00:59:38,559 --> 00:59:40,400
point here is using puncture encryption

1703
00:59:40,400 --> 00:59:42,160
directly adds forward secrecy forward

1704
00:59:42,160 --> 00:59:43,920
security on top

1705
00:59:43,920 --> 00:59:44,839
um

1706
00:59:44,839 --> 00:59:49,920
and yeah this essentially sums up this

1707
00:59:49,920 --> 00:59:51,680
application so

1708
00:59:51,680 --> 00:59:53,920
the takeaways here for this talk are

1709
00:59:53,920 --> 00:59:55,520
that we've through the example we've

1710
00:59:55,520 --> 00:59:57,040
seen a high demand in increasing

1711
00:59:57,040 --> 00:59:59,119
resilience of the cryptographic keys in

1712
00:59:59,119 --> 01:00:01,440
addition to the security and trust we

1713
01:00:01,440 --> 01:00:03,680
need for the cryptographic keys

1714
01:00:03,680 --> 01:00:05,359
punctual encryption offers a simple

1715
01:00:05,359 --> 01:00:07,520
solution on the cryptographic level and

1716
01:00:07,520 --> 01:00:09,520
particularly for the modern distributed

1717
01:00:09,520 --> 01:00:12,160
and non-interactive scenarios

1718
01:00:12,160 --> 01:00:13,920
we've seen several applications the zero

1719
01:00:13,920 --> 01:00:15,599
rtt exchange with forward security and

1720
01:00:15,599 --> 01:00:18,000
replay protection and forward secure

1721
01:00:18,000 --> 01:00:19,440
control network beautiful works

1722
01:00:19,440 --> 01:00:21,200
unsearchable encryption and mobile cloud

1723
01:00:21,200 --> 01:00:22,559
backup torah

1724
01:00:22,559 --> 01:00:24,480
and uh also updatable encryption are out

1725
01:00:24,480 --> 01:00:26,400
there and it seems it's gaining a little

1726
01:00:26,400 --> 01:00:28,559
bit of momentum here

1727
01:00:28,559 --> 01:00:29,760
so

1728
01:00:29,760 --> 01:00:30,880
with that

1729
01:00:30,880 --> 01:00:32,880
i want to thank you for listening we

1730
01:00:32,880 --> 01:00:34,319
have written a blog post about puncture

1731
01:00:34,319 --> 01:00:36,319
encryption go ahead and i invite you to

1732
01:00:36,319 --> 01:00:38,480
to to use this link

1733
01:00:38,480 --> 01:00:39,359
and

1734
01:00:39,359 --> 01:00:40,720
yeah

1735
01:00:40,720 --> 01:00:42,400
thank you for that and see you next year

1736
01:00:42,400 --> 01:00:43,550
i guess

1737
01:00:43,550 --> 01:00:47,169
[Applause]

1738
01:00:51,920 --> 01:00:53,200
all right we're a little bit over but if

1739
01:00:53,200 --> 01:00:54,640
somebody has a question i think we can

1740
01:00:54,640 --> 01:00:57,839
do one

1741
01:01:00,079 --> 01:01:02,720
it's a race

1742
01:01:05,040 --> 01:01:06,960
so thank you very much i'm i'm wondering

1743
01:01:06,960 --> 01:01:09,359
what is the current state of scalability

1744
01:01:09,359 --> 01:01:10,880
because every time you puncture a key

1745
01:01:10,880 --> 01:01:13,760
gets bigger and bigger

1746
01:01:13,760 --> 01:01:14,880
yes

1747
01:01:14,880 --> 01:01:16,559
and that's not always the case for

1748
01:01:16,559 --> 01:01:18,000
example using bloom filter encryption

1749
01:01:18,000 --> 01:01:20,799
you just delete keys

1750
01:01:20,799 --> 01:01:22,960
so but in the initial

1751
01:01:22,960 --> 01:01:25,119
work or the work by gunter at all you

1752
01:01:25,119 --> 01:01:27,839
usually at the secret key state gets

1753
01:01:27,839 --> 01:01:29,760
bigger but if you're using

1754
01:01:29,760 --> 01:01:32,319
bloom filter encryption was incentived

1755
01:01:32,319 --> 01:01:34,559
uh to the puncturing is very easy there

1756
01:01:34,559 --> 01:01:36,319
and very efficient you just delete keys

1757
01:01:36,319 --> 01:01:38,480
essentially okay so we can puncture with

1758
01:01:38,480 --> 01:01:40,720
a million of messages

1759
01:01:40,720 --> 01:01:42,720
sorry but you can puncture a million of

1760
01:01:42,720 --> 01:01:44,720
messages on a key

1761
01:01:44,720 --> 01:01:46,400
uh

1762
01:01:46,400 --> 01:01:49,200
it happens interruptively but yes

1763
01:01:49,200 --> 01:01:52,359
thank you

1764
01:01:54,799 --> 01:01:56,880
okay all right let's thank the speaker

1765
01:01:56,880 --> 01:01:57,830
again thanks again

1766
01:01:57,830 --> 01:01:59,800
[Applause]

1767
01:01:59,800 --> 01:02:00,070
[Music]

1768
01:02:00,070 --> 01:02:03,220
[Applause]

1769
01:02:03,220 --> 01:02:05,680
[Music]

1770
01:02:05,680 --> 01:02:09,038
now i'm going to hand off to peter

1771
01:02:11,599 --> 01:02:13,280
all right

1772
01:02:13,280 --> 01:02:15,200
this is pretty much the end so there's

1773
01:02:15,200 --> 01:02:18,319
still a few things to say

1774
01:02:18,319 --> 01:02:20,640
so one thing is that nigel just came

1775
01:02:20,640 --> 01:02:22,240
running over to me and told me that i

1776
01:02:22,240 --> 01:02:23,440
should definitely mention that you will

1777
01:02:23,440 --> 01:02:26,240
all receive a survey so in order to make

1778
01:02:26,240 --> 01:02:29,280
rwc even better next year um we need

1779
01:02:29,280 --> 01:02:30,400
your input

1780
01:02:30,400 --> 01:02:32,160
i will be great if you fill that in so

1781
01:02:32,160 --> 01:02:34,559
that we know what to do differently what

1782
01:02:34,559 --> 01:02:36,480
to do better and what maybe not to do

1783
01:02:36,480 --> 01:02:38,079
anymore

1784
01:02:38,079 --> 01:02:40,720
um then well at the beginning at the

1785
01:02:40,720 --> 01:02:43,280
opening we asked you to follow our

1786
01:02:43,280 --> 01:02:45,119
recommendations for

1787
01:02:45,119 --> 01:02:47,039
keeping the covet cases small at the

1788
01:02:47,039 --> 01:02:48,079
event

1789
01:02:48,079 --> 01:02:51,039
thank you for all of you who did this

1790
01:02:51,039 --> 01:02:53,039
i can say so far we've received two

1791
01:02:53,039 --> 01:02:54,559
reports of people who left early because

1792
01:02:54,559 --> 01:02:56,240
they had positive covet tests i guess

1793
01:02:56,240 --> 01:02:57,920
this is to be expected this is an event

1794
01:02:57,920 --> 01:02:59,520
with 500 people

1795
01:02:59,520 --> 01:03:01,839
but yeah next days when you return when

1796
01:03:01,839 --> 01:03:04,880
you stay keep testing be a bit careful

1797
01:03:04,880 --> 01:03:06,079
um

1798
01:03:06,079 --> 01:03:07,359
all right

1799
01:03:07,359 --> 01:03:10,400
now for a lot of thank yous that i think

1800
01:03:10,400 --> 01:03:12,400
is the the job of the of the general she

1801
01:03:12,400 --> 01:03:14,240
had to say at the end first of all i

1802
01:03:14,240 --> 01:03:16,319
would like to keep thanking all of the

1803
01:03:16,319 --> 01:03:18,160
sponsors of this event and maybe you can

1804
01:03:18,160 --> 01:03:19,680
start clapping while i'm clicking

1805
01:03:19,680 --> 01:03:21,359
through here this is going to continue

1806
01:03:21,359 --> 01:03:23,839
for a while

1807
01:03:23,839 --> 01:03:25,200
so

1808
01:03:25,200 --> 01:03:27,200
this event is really possible because of

1809
01:03:27,200 --> 01:03:28,839
all of these sponsors

1810
01:03:28,839 --> 01:03:32,319
and if you're from industry and if you

1811
01:03:32,319 --> 01:03:34,160
would like to see your logo in these

1812
01:03:34,160 --> 01:03:35,920
final slides next year please go and

1813
01:03:35,920 --> 01:03:38,799
talk to kenny and he will get you set up

1814
01:03:38,799 --> 01:03:41,119
and uh you can oh we're just only at i

1815
01:03:41,119 --> 01:03:42,720
so this is alphabetically sorted right

1816
01:03:42,720 --> 01:03:46,558
so i'll keep clicking here

1817
01:03:56,559 --> 01:03:58,960
all right we're at z now great so now

1818
01:03:58,960 --> 01:04:00,480
there's a few more thank yous that i

1819
01:04:00,480 --> 01:04:02,720
would like to uh like to tell first i

1820
01:04:02,720 --> 01:04:05,520
would like to thank eric riscollar for

1821
01:04:05,520 --> 01:04:07,280
sponsoring additional student stipends

1822
01:04:07,280 --> 01:04:10,920
for for this event

1823
01:04:15,200 --> 01:04:16,720
i would like to thank bart and the

1824
01:04:16,720 --> 01:04:19,359
interface big band for a great concert

1825
01:04:19,359 --> 01:04:21,039
yesterday

1826
01:04:21,039 --> 01:04:23,760
and for making sure that rwc got dancing

1827
01:04:23,760 --> 01:04:25,000
cryptographers

1828
01:04:25,000 --> 01:04:27,359
[Applause]

1829
01:04:27,359 --> 01:04:28,720
then i would like to really thank the

1830
01:04:28,720 --> 01:04:30,960
rwc steering committee for really doing

1831
01:04:30,960 --> 01:04:33,039
half of the work this is a very very

1832
01:04:33,039 --> 01:04:34,799
impressive so thank you to the steering

1833
01:04:34,799 --> 01:04:37,799
committee

1834
01:04:41,359 --> 01:04:42,880
and for the next one i will need you to

1835
01:04:42,880 --> 01:04:45,200
be pretty loud because this is the theme

1836
01:04:45,200 --> 01:04:47,119
of the venue here and okay the av people

1837
01:04:47,119 --> 01:04:48,640
there in the back but everybody else

1838
01:04:48,640 --> 01:04:53,140
needs to hear you now so they

1839
01:04:53,140 --> 01:04:59,500
[Applause]

1840
01:05:04,400 --> 01:05:05,760
so yeah they did the other half of the

1841
01:05:05,760 --> 01:05:07,200
work you can see actually organizing

1842
01:05:07,200 --> 01:05:09,680
this event is totally chill um also

1843
01:05:09,680 --> 01:05:12,000
because really all the people all the

1844
01:05:12,000 --> 01:05:14,079
students the postdocs the admin team

1845
01:05:14,079 --> 01:05:16,160
from radford university and from mpisp

1846
01:05:16,160 --> 01:05:18,160
they did the remaining half of the work

1847
01:05:18,160 --> 01:05:19,359
and

1848
01:05:19,359 --> 01:05:23,720
thank you very very much to all of you

1849
01:05:27,680 --> 01:05:29,760
and those three halves are basically

1850
01:05:29,760 --> 01:05:31,839
only for what you see here but there's

1851
01:05:31,839 --> 01:05:33,599
also of course the the whole event

1852
01:05:33,599 --> 01:05:35,599
happening online as a as a hybrid event

1853
01:05:35,599 --> 01:05:37,680
in zoom and zulip and there's a huge

1854
01:05:37,680 --> 01:05:40,000
thanks to kevin and kay for running this

1855
01:05:40,000 --> 01:05:41,760
and for running night shifts here

1856
01:05:41,760 --> 01:05:43,359
because they're in the us it's not

1857
01:05:43,359 --> 01:05:44,960
exactly the most convenient time for

1858
01:05:44,960 --> 01:05:49,160
them in zoom and zula

1859
01:05:50,319 --> 01:05:52,720
so this is all from me and now there's a

1860
01:05:52,720 --> 01:05:54,000
few more thank yous i think that that

1861
01:05:54,000 --> 01:05:55,440
helena wants to get rid of so i'll hand

1862
01:05:55,440 --> 01:05:58,319
over the ticket to her

1863
01:06:03,599 --> 01:06:06,400
okay so of course we also had a program

1864
01:06:06,400 --> 01:06:08,480
actually at the conference and so there

1865
01:06:08,480 --> 01:06:10,720
were speakers and papers submitted and

1866
01:06:10,720 --> 01:06:14,079
all that and so i would like to thank uh

1867
01:06:14,079 --> 01:06:16,079
all of the members of the program

1868
01:06:16,079 --> 01:06:17,839
committee that we had that helped put

1869
01:06:17,839 --> 01:06:21,520
this beautiful program together

1870
01:06:24,120 --> 01:06:27,259
[Applause]

1871
01:06:31,280 --> 01:06:34,720
um there were submitters to uh this

1872
01:06:34,720 --> 01:06:36,559
conference this symposium and so

1873
01:06:36,559 --> 01:06:38,799
everybody submitted not everybody got

1874
01:06:38,799 --> 01:06:40,319
accepted but

1875
01:06:40,319 --> 01:06:42,319
all these people do a lot of work

1876
01:06:42,319 --> 01:06:44,640
beforehand and then we had external

1877
01:06:44,640 --> 01:06:47,200
reviewers that helped us review all the

1878
01:06:47,200 --> 01:06:48,880
submissions

1879
01:06:48,880 --> 01:06:51,440
at the event here itself we had session

1880
01:06:51,440 --> 01:06:53,520
chairs that helped us a lot get the

1881
01:06:53,520 --> 01:06:55,839
whole thing going

1882
01:06:55,839 --> 01:06:57,599
of course we had all the speakers

1883
01:06:57,599 --> 01:06:59,440
contributed talk speakers but also

1884
01:06:59,440 --> 01:07:02,140
invited speakers

1885
01:07:02,140 --> 01:07:11,029
[Applause]

1886
01:07:11,680 --> 01:07:15,760
and then hang on

1887
01:07:15,760 --> 01:07:18,880
actually we also had attendees

1888
01:07:18,880 --> 01:07:21,599
so thank you all for being here

1889
01:07:21,599 --> 01:07:24,160
and before we move to the really final

1890
01:07:24,160 --> 01:07:26,319
final information of the day which

1891
01:07:26,319 --> 01:07:28,240
kazooie is going to take over i think

1892
01:07:28,240 --> 01:07:30,880
we're missing one more person and that

1893
01:07:30,880 --> 01:07:33,039
might actually be peter schwab right

1894
01:07:33,039 --> 01:07:36,039
here

1895
01:07:40,570 --> 01:07:48,319
[Applause]

1896
01:07:48,319 --> 01:07:51,319
so

1897
01:07:58,400 --> 01:08:03,280
okay and now over to kazooie

1898
01:08:06,799 --> 01:08:10,119
you're on mute

1899
01:08:11,599 --> 01:08:13,039
wow

1900
01:08:13,039 --> 01:08:14,230
okay

1901
01:08:14,230 --> 01:08:24,960
[Applause]

1902
01:08:24,960 --> 01:08:27,600
and so now you hear me

1903
01:08:27,600 --> 01:08:30,960
and you see my slides

1904
01:08:31,040 --> 01:08:32,960
yes

1905
01:08:32,960 --> 01:08:35,120
so uh next year

1906
01:08:35,120 --> 01:08:37,120
for the first time

1907
01:08:37,120 --> 01:08:38,399
rwc

1908
01:08:38,399 --> 01:08:41,198
is coming to asia

1909
01:08:41,198 --> 01:08:43,519
and

1910
01:08:48,560 --> 01:08:49,679
and it's

1911
01:08:49,679 --> 01:08:52,399
going to be cherry blossom season in

1912
01:08:52,399 --> 01:08:54,080
tokyo

1913
01:08:54,080 --> 01:09:00,399
and the dates are march 27 to 29.

1914
01:09:01,279 --> 01:09:03,040
well what you can do in

1915
01:09:03,040 --> 01:09:05,279
[Music]

1916
01:09:05,279 --> 01:09:06,440
i'm tokyo

1917
01:09:09,920 --> 01:09:12,479
it's going to be in the bay area of

1918
01:09:12,479 --> 01:09:13,920
tokyo

1919
01:09:13,920 --> 01:09:16,880
and you know in tokyo or in japan we

1920
01:09:16,880 --> 01:09:19,359
have very good food

1921
01:09:19,359 --> 01:09:23,439
and you can try various ramen

1922
01:09:23,439 --> 01:09:24,719
and

1923
01:09:24,719 --> 01:09:28,158
if you get you can buy some of fake

1924
01:09:28,158 --> 01:09:29,759
foods

1925
01:09:29,759 --> 01:09:34,000
that you might have enjoyed in tokyo

1926
01:09:34,000 --> 01:09:35,439
and the venue

1927
01:09:35,439 --> 01:09:38,560
is called plaza heisei

1928
01:09:38,560 --> 01:09:39,839
in tokyo

1929
01:09:39,839 --> 01:09:42,319
we have two airports

1930
01:09:42,319 --> 01:09:45,679
and plaza heisei is really in center of

1931
01:09:45,679 --> 01:09:47,040
tokyo

1932
01:09:47,040 --> 01:09:50,158
it's 15 minutes taxi ride

1933
01:09:50,158 --> 01:09:52,479
from tokyo station

1934
01:09:52,479 --> 01:09:55,740
and this is how venue looks in night

1935
01:09:55,740 --> 01:09:57,600
[Applause]

1936
01:09:57,600 --> 01:09:59,760
um

1937
01:10:00,320 --> 01:10:02,560
there is a tram

1938
01:10:02,560 --> 01:10:06,320
that walks around in this bay area so

1939
01:10:06,320 --> 01:10:09,040
you can take that also

1940
01:10:09,040 --> 01:10:11,199
and within a walking distance from the

1941
01:10:11,199 --> 01:10:12,560
venue

1942
01:10:12,560 --> 01:10:15,440
you can see a gigantic gundam

1943
01:10:15,440 --> 01:10:18,559
if you know what that is

1944
01:10:20,000 --> 01:10:22,719
and the venue is like this

1945
01:10:22,719 --> 01:10:26,640
we have one big room called main hall

1946
01:10:26,640 --> 01:10:30,960
and we have a medium-sized media hall

1947
01:10:30,960 --> 01:10:34,719
so i hope you can have lots of room

1948
01:10:34,719 --> 01:10:36,960
and feel cozy

1949
01:10:36,960 --> 01:10:39,600
and have a social distance between

1950
01:10:39,600 --> 01:10:42,400
youtube or to new people

1951
01:10:42,400 --> 01:10:46,480
and we have some breakout rooms upstairs

1952
01:10:46,480 --> 01:10:50,000
so i hope you can enjoy the conference

1953
01:10:50,000 --> 01:10:52,800
comfortably

1954
01:10:53,040 --> 01:10:56,000
and that's all i have for today

1955
01:10:56,000 --> 01:10:59,840
my last message is to see you in tokyo

1956
01:10:59,840 --> 01:11:01,199
in japan

1957
01:11:01,199 --> 01:11:07,679
and save the date march 27 to 29 2023

1958
01:11:07,679 --> 01:11:11,000
see you then

1959
01:11:29,440 --> 01:11:31,280
sorry done

1960
01:11:31,280 --> 01:11:32,840
get home safely

1961
01:11:32,840 --> 01:11:41,260
[Applause]

1962
01:11:43,600 --> 01:11:45,679
you

