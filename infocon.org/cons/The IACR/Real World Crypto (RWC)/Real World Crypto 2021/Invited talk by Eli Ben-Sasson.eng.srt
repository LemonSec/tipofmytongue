1
00:00:00,000 --> 00:00:02,639
youtube now and you're welcome to start

2
00:00:02,639 --> 00:00:03,520
fantastic

3
00:00:03,520 --> 00:00:05,600
all right so let's go actually wait a

4
00:00:05,600 --> 00:00:06,799
few seconds because we've got loads of

5
00:00:06,799 --> 00:00:07,919
people joining

6
00:00:07,919 --> 00:00:09,599
the numbers the participants are going

7
00:00:09,599 --> 00:00:10,960
up quite quickly at the moment so just

8
00:00:10,960 --> 00:00:12,160
give it two minutes

9
00:00:12,160 --> 00:00:13,440
okay let's wait up yeah that's a good

10
00:00:13,440 --> 00:00:14,960
idea let's wait let's wait a minute oh

11
00:00:14,960 --> 00:00:16,079
and douglas is

12
00:00:16,079 --> 00:00:19,119
getting the latest figures in the in the

13
00:00:19,119 --> 00:00:31,519
in the chat

14
00:00:31,519 --> 00:00:33,600
thanks for those figures douglas and for

15
00:00:33,600 --> 00:00:34,800
those on the live stream

16
00:00:34,800 --> 00:00:37,360
uh the figures coming in are about the

17
00:00:37,360 --> 00:00:38,719
um

18
00:00:38,719 --> 00:00:41,079
conference uh who's attendings there's

19
00:00:41,079 --> 00:00:43,440
338 people from the u.s

20
00:00:43,440 --> 00:00:46,640
90 from germany 87 from the uk

21
00:00:46,640 --> 00:00:49,039
44 from switzerland and 43 from the

22
00:00:49,039 --> 00:00:51,600
netherlands

23
00:00:53,199 --> 00:00:55,120
okay so we're kind of stabling now i

24
00:00:55,120 --> 00:00:57,440
suggest we start

25
00:00:57,440 --> 00:00:59,120
yeah people are still streaming in but

26
00:00:59,120 --> 00:01:01,280
uh yeah let's uh let's get going

27
00:01:01,280 --> 00:01:04,000
so i see there are over 150 folks on the

28
00:01:04,000 --> 00:01:06,000
on the call which is which is great

29
00:01:06,000 --> 00:01:08,479
okay let's get started so uh welcome

30
00:01:08,479 --> 00:01:11,200
everybody to day four of rwc the last

31
00:01:11,200 --> 00:01:13,040
last day of the conference hope

32
00:01:13,040 --> 00:01:14,720
everybody's having a great time i

33
00:01:14,720 --> 00:01:18,560
am i love the program and uh to start

34
00:01:18,560 --> 00:01:20,560
the day we're starting with a with a

35
00:01:20,560 --> 00:01:21,600
bang and so

36
00:01:21,600 --> 00:01:23,759
uh i'm really really pleased to

37
00:01:23,759 --> 00:01:25,360
introduce ellie bensasson ellie i'm

38
00:01:25,360 --> 00:01:26,640
really looking forward forward to your

39
00:01:26,640 --> 00:01:27,280
talk

40
00:01:27,280 --> 00:01:29,439
uh so ellie is a giant in the area of

41
00:01:29,439 --> 00:01:30,400
proof systems

42
00:01:30,400 --> 00:01:33,439
and snarks really wrote sort of many

43
00:01:33,439 --> 00:01:34,960
many of the core papers

44
00:01:34,960 --> 00:01:36,400
in the area so ellie it's really

45
00:01:36,400 --> 00:01:38,000
wonderful to have you uh

46
00:01:38,000 --> 00:01:40,880
speak ellie is also a founding scientist

47
00:01:40,880 --> 00:01:41,840
of zcash

48
00:01:41,840 --> 00:01:44,720
and co-founder of starkware and

49
00:01:44,720 --> 00:01:45,840
currently is the president

50
00:01:45,840 --> 00:01:48,640
of starkware and has been doing amazing

51
00:01:48,640 --> 00:01:50,560
work in the area on fri

52
00:01:50,560 --> 00:01:52,720
and getting starks deployed and used in

53
00:01:52,720 --> 00:01:53,759
the real world so

54
00:01:53,759 --> 00:01:55,600
i'm really looking forward to your talk

55
00:01:55,600 --> 00:01:57,520
and the floor is yours

56
00:01:57,520 --> 00:01:59,119
oh and before we start just please

57
00:01:59,119 --> 00:02:00,799
everybody remember remember to

58
00:02:00,799 --> 00:02:02,560
post your your questions in the zulu

59
00:02:02,560 --> 00:02:04,079
chat and i'll

60
00:02:04,079 --> 00:02:06,399
ask uh ellie your questions once once

61
00:02:06,399 --> 00:02:09,758
the talk is over ellie all yours exactly

62
00:02:09,758 --> 00:02:12,239
thank you so much uh dan and i thank the

63
00:02:12,239 --> 00:02:13,680
um

64
00:02:13,680 --> 00:02:15,680
program committee for for inviting me to

65
00:02:15,680 --> 00:02:17,920
speak here just to clarify so

66
00:02:17,920 --> 00:02:19,920
i should speak for roughly 25 minutes

67
00:02:19,920 --> 00:02:22,080
and leave five minutes for questions

68
00:02:22,080 --> 00:02:24,480
uh yeah that sounds good absolutely i'm

69
00:02:24,480 --> 00:02:25,760
sure there'll be a lot of questions for

70
00:02:25,760 --> 00:02:26,560
you so if

71
00:02:26,560 --> 00:02:30,319
you want to do 22. in a bit less

72
00:02:30,319 --> 00:02:35,359
and i will share my screen

73
00:02:35,440 --> 00:02:39,440
so here we go can you see it

74
00:02:41,840 --> 00:02:45,280
yep all good okay so i'm gonna talk

75
00:02:45,280 --> 00:02:47,200
about scaling computations on

76
00:02:47,200 --> 00:02:48,840
blockchains with zk

77
00:02:48,840 --> 00:02:51,599
starks my name is ellie ben sasson

78
00:02:51,599 --> 00:02:53,440
and i'm co-founder and president of

79
00:02:53,440 --> 00:02:56,959
starkware a company that currently has

80
00:02:56,959 --> 00:03:00,480
roughly a bit over 40 employees we

81
00:03:00,480 --> 00:03:03,440
we reside in israel and our mission is

82
00:03:03,440 --> 00:03:04,239
to bring

83
00:03:04,239 --> 00:03:07,599
scalability and privacy to blockchains

84
00:03:07,599 --> 00:03:11,280
um so the tldr of my talk is going to be

85
00:03:11,280 --> 00:03:12,879
is going to have three parts the main

86
00:03:12,879 --> 00:03:14,720
part is going to be the second one

87
00:03:14,720 --> 00:03:17,840
um the first one is going to be that you

88
00:03:17,840 --> 00:03:19,040
know just recalling

89
00:03:19,040 --> 00:03:21,040
that blockchains rock they're really

90
00:03:21,040 --> 00:03:22,879
great you all know that

91
00:03:22,879 --> 00:03:25,200
but they lack scale and privacy so we

92
00:03:25,200 --> 00:03:26,799
want to talk a little bit about

93
00:03:26,799 --> 00:03:29,120
mostly the scale why is it that this new

94
00:03:29,120 --> 00:03:31,040
technology

95
00:03:31,040 --> 00:03:33,120
built in the arts and and the teens

96
00:03:33,120 --> 00:03:35,200
doesn't reach the scale of other

97
00:03:35,200 --> 00:03:36,959
more traditional and older systems the

98
00:03:36,959 --> 00:03:38,480
second part is going to be

99
00:03:38,480 --> 00:03:41,519
um you know saying that uh we believe

100
00:03:41,519 --> 00:03:41,840
that

101
00:03:41,840 --> 00:03:44,159
uh our technology is the right one for

102
00:03:44,159 --> 00:03:46,159
solving both of these problems and it's

103
00:03:46,159 --> 00:03:48,080
going to have three parts theoretically

104
00:03:48,080 --> 00:03:50,159
and then practically and then this is

105
00:03:50,159 --> 00:03:52,239
real world crypto so i want to

106
00:03:52,239 --> 00:03:53,840
tell you about something very very

107
00:03:53,840 --> 00:03:55,920
accessible that we just released last

108
00:03:55,920 --> 00:03:56,959
week and i hope

109
00:03:56,959 --> 00:03:58,959
you'll play with it and use it and build

110
00:03:58,959 --> 00:04:00,080
systems with it

111
00:04:00,080 --> 00:04:02,319
um this is a language and a framework

112
00:04:02,319 --> 00:04:03,760
that we call cairo

113
00:04:03,760 --> 00:04:06,080
and hopefully the you know call to

114
00:04:06,080 --> 00:04:07,040
action is gonna be

115
00:04:07,040 --> 00:04:10,159
please come build on cairo and uh that's

116
00:04:10,159 --> 00:04:11,200
the main message

117
00:04:11,200 --> 00:04:13,680
so let's start and you all know about

118
00:04:13,680 --> 00:04:15,439
blockchains and you know that they don't

119
00:04:15,439 --> 00:04:16,478
scale very well but

120
00:04:16,478 --> 00:04:19,519
i i want to you know share my view on

121
00:04:19,519 --> 00:04:22,160
why this is the case so we're all

122
00:04:22,160 --> 00:04:23,520
familiar with the uh

123
00:04:23,520 --> 00:04:25,759
good old uh conventional world that's

124
00:04:25,759 --> 00:04:26,880
been serving us for

125
00:04:26,880 --> 00:04:29,759
millennia and it is based on trusted

126
00:04:29,759 --> 00:04:31,600
parties you know banks financial

127
00:04:31,600 --> 00:04:33,520
institutions uh king

128
00:04:33,520 --> 00:04:36,960
and then the integrity of the system is

129
00:04:36,960 --> 00:04:38,160
held accountable

130
00:04:38,160 --> 00:04:40,560
by humans that we delegate to the

131
00:04:40,560 --> 00:04:42,800
process you know regulators accountant

132
00:04:42,800 --> 00:04:44,560
lawyers they go and inspect the

133
00:04:44,560 --> 00:04:46,960
integrity of the system on our behalf

134
00:04:46,960 --> 00:04:49,040
and this this system works you know more

135
00:04:49,040 --> 00:04:50,080
or less well

136
00:04:50,080 --> 00:04:52,800
um blockchains work very differently

137
00:04:52,800 --> 00:04:54,720
they have a different principle which is

138
00:04:54,720 --> 00:04:56,880
you know much nicer sounding and and

139
00:04:56,880 --> 00:04:58,880
i'll call it inclusive accountability

140
00:04:58,880 --> 00:04:59,520
which

141
00:04:59,520 --> 00:05:02,240
translates to anyone with a laptop and

142
00:05:02,240 --> 00:05:03,680
internet connection

143
00:05:03,680 --> 00:05:06,320
is invited to to come over and help

144
00:05:06,320 --> 00:05:08,240
inspect the full integrity of all the

145
00:05:08,240 --> 00:05:09,120
system

146
00:05:09,120 --> 00:05:12,320
and the i you know the motto is verify

147
00:05:12,320 --> 00:05:14,400
don't trust and i'm saying verify all

148
00:05:14,400 --> 00:05:16,720
transactions you don't want any part

149
00:05:16,720 --> 00:05:18,800
not to be verified so this is a

150
00:05:18,800 --> 00:05:21,199
beautiful principle because of that

151
00:05:21,199 --> 00:05:22,880
you have two problems one is privacy

152
00:05:22,880 --> 00:05:24,400
because everyone is verifying

153
00:05:24,400 --> 00:05:26,160
all your transactions and the second one

154
00:05:26,160 --> 00:05:27,440
is scalability

155
00:05:27,440 --> 00:05:29,280
so i'm going to focus more on

156
00:05:29,280 --> 00:05:31,280
scalability in this part even though the

157
00:05:31,280 --> 00:05:32,479
technology

158
00:05:32,479 --> 00:05:35,680
that i'll be presenting can also

159
00:05:35,680 --> 00:05:38,240
solve privacy and usually when people

160
00:05:38,240 --> 00:05:40,479
talk about zkp so the zero knowledge

161
00:05:40,479 --> 00:05:42,720
aspect of course covers the privacy

162
00:05:42,720 --> 00:05:45,360
aspect and i'm sure the uh attendees

163
00:05:45,360 --> 00:05:47,039
know this but i'm going to focus more

164
00:05:47,039 --> 00:05:47,520
about

165
00:05:47,520 --> 00:05:49,280
on the scalability which is what we're

166
00:05:49,280 --> 00:05:50,720
aiming to solve first

167
00:05:50,720 --> 00:05:52,479
even though our technology can also

168
00:05:52,479 --> 00:05:54,080
address privacy

169
00:05:54,080 --> 00:05:58,319
um so there's a huge explosion you know

170
00:05:58,319 --> 00:06:00,319
zkp's go back to the seminal work of

171
00:06:00,319 --> 00:06:03,360
uh uh gold vaso micalli and rocco from

172
00:06:03,360 --> 00:06:05,520
1985 which spawned

173
00:06:05,520 --> 00:06:08,400
you know a huge field and uh you know

174
00:06:08,400 --> 00:06:09,520
thousands of

175
00:06:09,520 --> 00:06:11,919
theoretical works and in the past 10 to

176
00:06:11,919 --> 00:06:12,960
15 years

177
00:06:12,960 --> 00:06:15,199
there's been a real spirit of uh works

178
00:06:15,199 --> 00:06:16,800
on implementations

179
00:06:16,800 --> 00:06:19,919
of various kinds and this is not a talk

180
00:06:19,919 --> 00:06:22,639
about it so i wrote a blog post titled

181
00:06:22,639 --> 00:06:24,560
the cambrian explosion of zkp's that

182
00:06:24,560 --> 00:06:26,400
tries to make a little bit of sense but

183
00:06:26,400 --> 00:06:28,160
of the diff you know the way i view the

184
00:06:28,160 --> 00:06:30,080
different you know families of practical

185
00:06:30,080 --> 00:06:31,759
implementations the trade-offs between

186
00:06:31,759 --> 00:06:32,240
them

187
00:06:32,240 --> 00:06:34,319
so in these slides that i'll share

188
00:06:34,319 --> 00:06:36,479
there's a link to the post i also gave a

189
00:06:36,479 --> 00:06:39,120
crowdcast on it so all i want to say is

190
00:06:39,120 --> 00:06:40,800
i'm going to be talking only about zk

191
00:06:40,800 --> 00:06:42,639
starks but i just want to acknowledge

192
00:06:42,639 --> 00:06:44,080
that there are a whole bunch of others

193
00:06:44,080 --> 00:06:46,000
and there's amazing research going on

194
00:06:46,000 --> 00:06:47,680
uh the t the reason i'm going to focus

195
00:06:47,680 --> 00:06:49,280
on it other than that that's the

196
00:06:49,280 --> 00:06:51,199
technology that starkwear is

197
00:06:51,199 --> 00:06:53,520
is implementing or the reason why we're

198
00:06:53,520 --> 00:06:55,680
focusing on this particular technology

199
00:06:55,680 --> 00:06:58,240
is this uh you know tldr from from that

200
00:06:58,240 --> 00:06:58,800
talk

201
00:06:58,800 --> 00:07:00,479
that there's a lot of difference between

202
00:07:00,479 --> 00:07:02,160
the different members of this huge

203
00:07:02,160 --> 00:07:02,960
universe

204
00:07:02,960 --> 00:07:04,880
um and they differ by the method the

205
00:07:04,880 --> 00:07:07,039
means they do arithmetization which is

206
00:07:07,039 --> 00:07:08,960
transitioning you know computational

207
00:07:08,960 --> 00:07:10,720
statements to problems about

208
00:07:10,720 --> 00:07:13,199
algebraic structures polynomials usually

209
00:07:13,199 --> 00:07:15,120
uh there's also a lot of differentiation

210
00:07:15,120 --> 00:07:16,080
in the way the

211
00:07:16,080 --> 00:07:19,360
the different systems uh the tackle load

212
00:07:19,360 --> 00:07:20,960
the greenness and you know polynomial

213
00:07:20,960 --> 00:07:22,639
commitment schemes and things like that

214
00:07:22,639 --> 00:07:24,319
and the crypto assumptions that you use

215
00:07:24,319 --> 00:07:26,479
to to build these systems with

216
00:07:26,479 --> 00:07:29,440
uh the tldr that you know we are working

217
00:07:29,440 --> 00:07:31,280
under this premise is that uh currently

218
00:07:31,280 --> 00:07:32,800
the for short proofs you want to use

219
00:07:32,800 --> 00:07:35,120
something called known as graf 16 snarks

220
00:07:35,120 --> 00:07:35,599
that

221
00:07:35,599 --> 00:07:38,240
power zcash and many other systems for

222
00:07:38,240 --> 00:07:39,199
everything else

223
00:07:39,199 --> 00:07:41,280
we think starks are really great so

224
00:07:41,280 --> 00:07:42,880
that's what i'm going to focus on that

225
00:07:42,880 --> 00:07:43,360
and

226
00:07:43,360 --> 00:07:45,680
you know i welcome you to read the blog

227
00:07:45,680 --> 00:07:47,759
post and see why we believe in that

228
00:07:47,759 --> 00:07:50,080
so the next part is gonna be um about

229
00:07:50,080 --> 00:07:51,039
this particular

230
00:07:51,039 --> 00:07:53,840
you know region in the uh space of this

231
00:07:53,840 --> 00:07:56,879
huge space of zero knowledge uh

232
00:07:56,879 --> 00:07:59,840
proof systems and i want to tell you why

233
00:07:59,840 --> 00:08:00,560
theoretically

234
00:08:00,560 --> 00:08:02,879
ak starks are good at solving the scale

235
00:08:02,879 --> 00:08:04,240
and privacy problem

236
00:08:04,240 --> 00:08:06,240
and also about how we practically are

237
00:08:06,240 --> 00:08:08,400
using them to solve scaling problems

238
00:08:08,400 --> 00:08:10,879
and then how we make them accessible for

239
00:08:10,879 --> 00:08:12,720
all of you to come and use

240
00:08:12,720 --> 00:08:15,199
these things even without uh you know

241
00:08:15,199 --> 00:08:17,280
diving deep into all the crypto and math

242
00:08:17,280 --> 00:08:18,960
that underlies it

243
00:08:18,960 --> 00:08:20,639
okay so let's talk about a little bit

244
00:08:20,639 --> 00:08:22,960
about theory so remember that the main

245
00:08:22,960 --> 00:08:23,919
problem we have

246
00:08:23,919 --> 00:08:26,240
is that because we want this inclusive

247
00:08:26,240 --> 00:08:27,360
accountability

248
00:08:27,360 --> 00:08:29,520
we have these nodes you know users with

249
00:08:29,520 --> 00:08:30,639
their laptops

250
00:08:30,639 --> 00:08:32,640
logging in and verifying all the

251
00:08:32,640 --> 00:08:34,479
transactions that are taking place

252
00:08:34,479 --> 00:08:36,320
on the network and this sacrifices

253
00:08:36,320 --> 00:08:37,839
privacy and scalability

254
00:08:37,839 --> 00:08:39,760
i'm reminding you that i'm gonna focus

255
00:08:39,760 --> 00:08:42,080
in this talk only on scalability

256
00:08:42,080 --> 00:08:45,200
um so so what it boils down to is that

257
00:08:45,200 --> 00:08:47,760
um you know each one of these servers or

258
00:08:47,760 --> 00:08:49,440
computers or laptops

259
00:08:49,440 --> 00:08:51,600
has to process all of these uh

260
00:08:51,600 --> 00:08:53,360
transactions so each one of these little

261
00:08:53,360 --> 00:08:54,080
red

262
00:08:54,080 --> 00:08:56,399
squares represents a transaction where

263
00:08:56,399 --> 00:08:58,000
alice is paying bob or

264
00:08:58,000 --> 00:08:59,680
you know maybe they're invoking some

265
00:08:59,680 --> 00:09:02,320
smart contract or doing some trading

266
00:09:02,320 --> 00:09:04,800
or you know playing a game on the

267
00:09:04,800 --> 00:09:06,720
blockchain and then what happens is

268
00:09:06,720 --> 00:09:08,959
is that each one of the nodes that

269
00:09:08,959 --> 00:09:10,959
participates in the blockchain

270
00:09:10,959 --> 00:09:13,200
has to uh process each of the

271
00:09:13,200 --> 00:09:14,640
transactions and then

272
00:09:14,640 --> 00:09:17,279
you know update the accounts or the utxo

273
00:09:17,279 --> 00:09:17,680
set

274
00:09:17,680 --> 00:09:19,600
and update the state of the system so

275
00:09:19,600 --> 00:09:21,360
that you solve a state replication

276
00:09:21,360 --> 00:09:22,240
problem in

277
00:09:22,240 --> 00:09:24,560
in some way and there's the there's a

278
00:09:24,560 --> 00:09:26,640
whole area of consensus how do you know

279
00:09:26,640 --> 00:09:28,880
that all these how do you incentivize

280
00:09:28,880 --> 00:09:30,880
all nodes to reach consensus you know

281
00:09:30,880 --> 00:09:32,080
that's not part of

282
00:09:32,080 --> 00:09:34,399
this talk but i'm just focusing on the

283
00:09:34,399 --> 00:09:35,360
aspect of

284
00:09:35,360 --> 00:09:37,920
verifying transactions so currently the

285
00:09:37,920 --> 00:09:39,760
way the system works is that each one of

286
00:09:39,760 --> 00:09:41,040
these uh you know inclusive

287
00:09:41,040 --> 00:09:42,480
accountability nodes

288
00:09:42,480 --> 00:09:44,160
you come on with your laptop you're

289
00:09:44,160 --> 00:09:46,160
gonna process all the transactions that

290
00:09:46,160 --> 00:09:46,720
go

291
00:09:46,720 --> 00:09:48,800
and check all the signatures update the

292
00:09:48,800 --> 00:09:50,080
accounts and this is of course

293
00:09:50,080 --> 00:09:52,560
this doesn't scale very well and this is

294
00:09:52,560 --> 00:09:54,160
the answer to the question

295
00:09:54,160 --> 00:09:56,880
that i posted at the beginning why is it

296
00:09:56,880 --> 00:09:57,200
that

297
00:09:57,200 --> 00:10:00,800
bitcoin launched in 2008 or ethereum

298
00:10:00,800 --> 00:10:02,880
launched in 2015

299
00:10:02,880 --> 00:10:06,240
do not reach the scale of you know visa

300
00:10:06,240 --> 00:10:08,480
or swift or or phipps or any one of

301
00:10:08,480 --> 00:10:10,399
these older systems that actually you

302
00:10:10,399 --> 00:10:11,519
know

303
00:10:11,519 --> 00:10:14,079
relies on technology from the 70s the

304
00:10:14,079 --> 00:10:15,360
answer to that question

305
00:10:15,360 --> 00:10:18,160
is not because you know there aren't big

306
00:10:18,160 --> 00:10:20,399
enough computers that can process

307
00:10:20,399 --> 00:10:23,120
a thousand transactions per second or 10

308
00:10:23,120 --> 00:10:24,880
000 transactions per second

309
00:10:24,880 --> 00:10:27,680
for ethereum that's not the problem the

310
00:10:27,680 --> 00:10:28,720
problem is

311
00:10:28,720 --> 00:10:31,680
that your laptop can't do it right so

312
00:10:31,680 --> 00:10:32,800
the visa

313
00:10:32,800 --> 00:10:35,839
network has some big servers that you

314
00:10:35,839 --> 00:10:37,600
know it's a trusted party model that can

315
00:10:37,600 --> 00:10:38,160
process

316
00:10:38,160 --> 00:10:40,160
10 000 transactions per second but if

317
00:10:40,160 --> 00:10:41,920
you want all laptops

318
00:10:41,920 --> 00:10:44,320
to do this while you're also tweeting or

319
00:10:44,320 --> 00:10:46,079
you know blogging or doing something

320
00:10:46,079 --> 00:10:48,079
else without your computer heating up

321
00:10:48,079 --> 00:10:50,880
you're going to have to limit the number

322
00:10:50,880 --> 00:10:53,200
of transactions per second or the amount

323
00:10:53,200 --> 00:10:54,399
of computation that

324
00:10:54,399 --> 00:10:56,240
each one of these nodes is doing and

325
00:10:56,240 --> 00:10:58,079
that's the reason they're not

326
00:10:58,079 --> 00:11:01,279
they don't have very high scale okay

327
00:11:01,279 --> 00:11:04,000
so how can zk starks or other you know

328
00:11:04,000 --> 00:11:05,279
scalable zkp's

329
00:11:05,279 --> 00:11:08,160
solve this problem so let's recall

330
00:11:08,160 --> 00:11:08,959
briefly

331
00:11:08,959 --> 00:11:11,440
what what is a proof system so you have

332
00:11:11,440 --> 00:11:13,200
the privacy aspect which means that a

333
00:11:13,200 --> 00:11:14,000
proof

334
00:11:14,000 --> 00:11:16,399
once generated does not reveal anything

335
00:11:16,399 --> 00:11:18,959
about the private inputs that go into it

336
00:11:18,959 --> 00:11:21,440
as as i said the zero knowledge is a

337
00:11:21,440 --> 00:11:23,200
very important aspect of

338
00:11:23,200 --> 00:11:24,959
zkp's but it's not going to be the one

339
00:11:24,959 --> 00:11:26,720
that i'm going to focus on today

340
00:11:26,720 --> 00:11:28,880
let's talk about scalability so

341
00:11:28,880 --> 00:11:29,920
scalability

342
00:11:29,920 --> 00:11:31,440
i'm going to you know mathematically

343
00:11:31,440 --> 00:11:34,000
define it as a proof system

344
00:11:34,000 --> 00:11:37,600
i'll call it scalable if it achieves two

345
00:11:37,600 --> 00:11:40,160
things simultaneously

346
00:11:40,160 --> 00:11:43,519
the proving time scales quasi-linearly

347
00:11:43,519 --> 00:11:46,000
which means like n log n where n is the

348
00:11:46,000 --> 00:11:48,320
amount of computation that is processed

349
00:11:48,320 --> 00:11:52,160
and simultaneously the verification time

350
00:11:52,160 --> 00:11:55,360
scales poly logarithmically within so if

351
00:11:55,360 --> 00:11:56,560
you have a system

352
00:11:56,560 --> 00:11:58,240
that that achieves both of these

353
00:11:58,240 --> 00:12:00,639
properties both quasi-linear

354
00:12:00,639 --> 00:12:03,120
proving time and poly logarithmic

355
00:12:03,120 --> 00:12:04,399
verification time

356
00:12:04,399 --> 00:12:07,120
i'll call it scalable and starks are one

357
00:12:07,120 --> 00:12:08,880
one family of

358
00:12:08,880 --> 00:12:11,600
proof systems that are scalable so if

359
00:12:11,600 --> 00:12:13,519
you have a scalable proof system you can

360
00:12:13,519 --> 00:12:15,200
have your approver

361
00:12:15,200 --> 00:12:18,480
processing uh the transactions

362
00:12:18,480 --> 00:12:20,800
and then generating a proof that is

363
00:12:20,800 --> 00:12:22,639
exponentially smaller

364
00:12:22,639 --> 00:12:24,800
than the amount of computation that

365
00:12:24,800 --> 00:12:27,200
would go into verifying all transactions

366
00:12:27,200 --> 00:12:30,079
and then send this proof to verifiers

367
00:12:30,079 --> 00:12:31,600
that are going to work

368
00:12:31,600 --> 00:12:34,079
exponentially less hard than the prover

369
00:12:34,079 --> 00:12:35,360
works so the proof is going to be some

370
00:12:35,360 --> 00:12:36,240
big machine

371
00:12:36,240 --> 00:12:37,920
but because of the beautiful

372
00:12:37,920 --> 00:12:39,680
cryptography and math and complexity

373
00:12:39,680 --> 00:12:40,720
theory behind it

374
00:12:40,720 --> 00:12:42,560
the prover even if it's malicious cannot

375
00:12:42,560 --> 00:12:44,560
really cheat the verifier right

376
00:12:44,560 --> 00:12:46,480
this won't work right cryptography is

377
00:12:46,480 --> 00:12:47,760
going to prevent that

378
00:12:47,760 --> 00:12:50,240
um so so you don't need to trust the

379
00:12:50,240 --> 00:12:51,279
prover

380
00:12:51,279 --> 00:12:53,120
it doesn't have to be part of the system

381
00:12:53,120 --> 00:12:54,880
of nodes that that is part of your

382
00:12:54,880 --> 00:12:55,519
network

383
00:12:55,519 --> 00:12:57,839
so now let's apply it to blockchain

384
00:12:57,839 --> 00:12:59,519
we're going to take the verifiers

385
00:12:59,519 --> 00:13:02,240
and put them on each one of these

386
00:13:02,240 --> 00:13:03,360
laptops that

387
00:13:03,360 --> 00:13:06,079
participates in in the public blockchain

388
00:13:06,079 --> 00:13:07,920
and now each one of these uh

389
00:13:07,920 --> 00:13:09,920
nodes doesn't have to maintain the whole

390
00:13:09,920 --> 00:13:11,360
set of the accounts it can just

391
00:13:11,360 --> 00:13:13,200
maintain let's say a merkle route for

392
00:13:13,200 --> 00:13:14,720
some other you know hash

393
00:13:14,720 --> 00:13:16,800
of the state of the system and then the

394
00:13:16,800 --> 00:13:18,399
approver is going to be the only one

395
00:13:18,399 --> 00:13:20,399
getting the transactions and processing

396
00:13:20,399 --> 00:13:22,240
them and it will generate

397
00:13:22,240 --> 00:13:24,160
it will also get the previous you know

398
00:13:24,160 --> 00:13:25,680
the current

399
00:13:25,680 --> 00:13:28,399
route of the system and it will generate

400
00:13:28,399 --> 00:13:30,160
you know compute the new route to which

401
00:13:30,160 --> 00:13:30,560
uh

402
00:13:30,560 --> 00:13:34,079
the the system is now transitioning

403
00:13:34,079 --> 00:13:36,079
and generate the proof of computational

404
00:13:36,079 --> 00:13:37,200
integrity and

405
00:13:37,200 --> 00:13:39,040
send it to the blockchain so now what

406
00:13:39,040 --> 00:13:41,040
the verifiers need to do they just need

407
00:13:41,040 --> 00:13:43,360
to take as input the previous route the

408
00:13:43,360 --> 00:13:44,240
current route

409
00:13:44,240 --> 00:13:46,800
sorry the proposed new route and a proof

410
00:13:46,800 --> 00:13:48,079
and if the proof

411
00:13:48,079 --> 00:13:51,120
is is verified correctly and this is

412
00:13:51,120 --> 00:13:52,880
exponentially faster than verifying the

413
00:13:52,880 --> 00:13:53,920
transactions

414
00:13:53,920 --> 00:13:56,079
um each one of these nodes can move on

415
00:13:56,079 --> 00:13:57,440
to the can now

416
00:13:57,440 --> 00:13:59,600
replace the state of the system with a

417
00:13:59,600 --> 00:14:00,639
new state

418
00:14:00,639 --> 00:14:02,720
and thereby exponentially save on the

419
00:14:02,720 --> 00:14:04,240
amount of computation

420
00:14:04,240 --> 00:14:07,360
so if we go this way we can retain

421
00:14:07,360 --> 00:14:09,839
the beautiful principle of inclusive

422
00:14:09,839 --> 00:14:11,040
accountability

423
00:14:11,040 --> 00:14:15,040
but we can exponentially scale the uh

424
00:14:15,040 --> 00:14:16,720
the amount of computation that is

425
00:14:16,720 --> 00:14:18,160
processed by the network

426
00:14:18,160 --> 00:14:21,279
by we are going to offload

427
00:14:21,279 --> 00:14:23,920
the bulk of the work of generating a

428
00:14:23,920 --> 00:14:25,199
proof to the prover

429
00:14:25,199 --> 00:14:28,240
and the verifiers only need to verify

430
00:14:28,240 --> 00:14:29,600
the correctness of the proof which is

431
00:14:29,600 --> 00:14:30,880
which is exponentially

432
00:14:30,880 --> 00:14:35,519
faster so this is the theory okay

433
00:14:35,519 --> 00:14:38,480
now you know you update it from the old

434
00:14:38,480 --> 00:14:40,000
merkle roots which are in blue

435
00:14:40,000 --> 00:14:41,680
you update them to the numerical roots

436
00:14:41,680 --> 00:14:43,040
which are in red and then you repeat

437
00:14:43,040 --> 00:14:45,199
this process

438
00:14:45,199 --> 00:14:46,959
now i just want to go over some other

439
00:14:46,959 --> 00:14:49,360
things that go into a stark

440
00:14:49,360 --> 00:14:52,560
so or sorry that starks

441
00:14:52,560 --> 00:14:55,760
and others ekps share

442
00:14:55,760 --> 00:14:57,680
they're universal and universality is

443
00:14:57,680 --> 00:14:59,440
going to be the main topic of the next

444
00:14:59,440 --> 00:15:00,800
part of the talk

445
00:15:00,800 --> 00:15:02,800
they apply to any computation not just

446
00:15:02,800 --> 00:15:04,320
the payments you're not just

447
00:15:04,320 --> 00:15:05,839
particular protocols you can take any

448
00:15:05,839 --> 00:15:07,760
computer program and prove its

449
00:15:07,760 --> 00:15:10,160
computational integrity

450
00:15:10,160 --> 00:15:13,040
the t in the definition of stark stands

451
00:15:13,040 --> 00:15:14,880
for transparency which means all

452
00:15:14,880 --> 00:15:15,360
messages

453
00:15:15,360 --> 00:15:16,720
from a mathematical point of view it

454
00:15:16,720 --> 00:15:18,639
means that all messages coming from the

455
00:15:18,639 --> 00:15:19,760
um

456
00:15:19,760 --> 00:15:22,880
verifier are basically public randomness

457
00:15:22,880 --> 00:15:24,880
these are also known as arthromerlin

458
00:15:24,880 --> 00:15:27,199
protocols or public coins

459
00:15:27,199 --> 00:15:30,399
um and some starks in particular the one

460
00:15:30,399 --> 00:15:31,279
that

461
00:15:31,279 --> 00:15:34,320
my company is building

462
00:15:34,320 --> 00:15:37,600
rely only on you know the existence of

463
00:15:37,600 --> 00:15:39,920
some collision resistant hash function

464
00:15:39,920 --> 00:15:41,120
um so they're lean

465
00:15:41,120 --> 00:15:43,600
and battle hardened cryptography meaning

466
00:15:43,600 --> 00:15:44,959
that you know they rely on

467
00:15:44,959 --> 00:15:47,040
things like you know the security of

468
00:15:47,040 --> 00:15:49,279
sha-2 or any other hash function which

469
00:15:49,279 --> 00:15:49,839
is uh

470
00:15:49,839 --> 00:15:51,199
pretty much one of the most basic

471
00:15:51,199 --> 00:15:53,120
premises of

472
00:15:53,120 --> 00:15:56,880
security in our world today um

473
00:15:56,880 --> 00:15:59,519
i wanna so i said i'm not gonna go into

474
00:15:59,519 --> 00:16:00,160
uh

475
00:16:00,160 --> 00:16:02,000
you know an exploration of the big

476
00:16:02,000 --> 00:16:03,440
universe of uh

477
00:16:03,440 --> 00:16:07,120
of uh of zkp's uh a very popular

478
00:16:07,120 --> 00:16:09,199
term is snark so i just want to point

479
00:16:09,199 --> 00:16:11,279
out briefly the difference

480
00:16:11,279 --> 00:16:14,639
between the two so the end sorry the s

481
00:16:14,639 --> 00:16:16,000
in snark stands for

482
00:16:16,000 --> 00:16:17,920
succinctness which is not exactly

483
00:16:17,920 --> 00:16:19,360
scalability it means

484
00:16:19,360 --> 00:16:21,279
you want exponentially small verified

485
00:16:21,279 --> 00:16:22,959
running time but you

486
00:16:22,959 --> 00:16:26,240
allow post-processing um sorry

487
00:16:26,240 --> 00:16:28,079
you allow pre-processing that could be

488
00:16:28,079 --> 00:16:29,839
linear in the size of the computation or

489
00:16:29,839 --> 00:16:30,639
even more

490
00:16:30,639 --> 00:16:33,199
in the case of stark this is forbidden

491
00:16:33,199 --> 00:16:34,399
and

492
00:16:34,399 --> 00:16:36,959
the definition of a snark does not uh

493
00:16:36,959 --> 00:16:38,800
necessarily say that the prover must be

494
00:16:38,800 --> 00:16:41,440
efficient it could be quadratic time or

495
00:16:41,440 --> 00:16:43,839
larger even though a lot of the very

496
00:16:43,839 --> 00:16:45,360
efficient snarks are

497
00:16:45,360 --> 00:16:47,279
actually quasi-linear proving time

498
00:16:47,279 --> 00:16:48,399
another thing is that the

499
00:16:48,399 --> 00:16:51,600
n means non-interactive so it's a single

500
00:16:51,600 --> 00:16:53,920
shot proof in the um

501
00:16:53,920 --> 00:16:56,720
common reference string model and uh i

502
00:16:56,720 --> 00:16:58,320
just want to point out that uh one of

503
00:16:58,320 --> 00:16:59,440
the reasons we think

504
00:16:59,440 --> 00:17:01,360
you know starks are slightly better than

505
00:17:01,360 --> 00:17:03,199
snarks is that if you came up with a

506
00:17:03,199 --> 00:17:04,079
stark you can

507
00:17:04,079 --> 00:17:06,880
always apply the fiat chameleo uh you

508
00:17:06,880 --> 00:17:07,439
know

509
00:17:07,439 --> 00:17:08,959
or the mikali and then there's a

510
00:17:08,959 --> 00:17:10,799
transformation um

511
00:17:10,799 --> 00:17:13,359
in in the paper with with kiez and nick

512
00:17:13,359 --> 00:17:15,439
spooner that shows how you can transform

513
00:17:15,439 --> 00:17:16,640
any one of these uh

514
00:17:16,640 --> 00:17:19,760
starks into a snark but not always can

515
00:17:19,760 --> 00:17:21,119
you go in the other direction

516
00:17:21,119 --> 00:17:23,679
so um that's a little bit on the

517
00:17:23,679 --> 00:17:25,280
difference between the two

518
00:17:25,280 --> 00:17:27,439
so now i want to talk a little bit about

519
00:17:27,439 --> 00:17:29,120
practically i talked about the theory

520
00:17:29,120 --> 00:17:32,320
how theoretically zkp's or zk starks

521
00:17:32,320 --> 00:17:33,520
could help

522
00:17:33,520 --> 00:17:35,520
solving the problem uh at hand of

523
00:17:35,520 --> 00:17:37,200
scalability so now i want to talk a

524
00:17:37,200 --> 00:17:39,760
little bit about practically so

525
00:17:39,760 --> 00:17:42,000
you know ethereum and other blockchains

526
00:17:42,000 --> 00:17:43,520
can process

527
00:17:43,520 --> 00:17:45,760
roughly four trades per second and 30

528
00:17:45,760 --> 00:17:47,120
payments per second

529
00:17:47,120 --> 00:17:48,960
our systems that are currently deployed

530
00:17:48,960 --> 00:17:50,960
and serving customers can

531
00:17:50,960 --> 00:17:54,400
reach 9000 trades per second and 18 000

532
00:17:54,400 --> 00:17:56,080
payments per second these are you know

533
00:17:56,080 --> 00:17:58,720
production systems that are now working

534
00:17:58,720 --> 00:18:02,240
um we also went even a bit further

535
00:18:02,240 --> 00:18:05,360
and displayed how you can process

536
00:18:05,360 --> 00:18:08,880
300 000 transactions in a single uh

537
00:18:08,880 --> 00:18:11,520
stark proof that was deployed on mainnet

538
00:18:11,520 --> 00:18:13,679
ethereum that was in the context of

539
00:18:13,679 --> 00:18:15,440
convincing reddit that they can take all

540
00:18:15,440 --> 00:18:17,280
of its point systems and use our system

541
00:18:17,280 --> 00:18:17,840
for it

542
00:18:17,840 --> 00:18:21,120
that's 3000 tps whereas ethereum

543
00:18:21,120 --> 00:18:22,960
even if it would only deal with payments

544
00:18:22,960 --> 00:18:25,280
would only reach 30 dps

545
00:18:25,280 --> 00:18:28,000
and uh yeah so so this is about

546
00:18:28,000 --> 00:18:29,280
practicality

547
00:18:29,280 --> 00:18:31,360
now how do we build such systems and now

548
00:18:31,360 --> 00:18:32,320
i want to go to

549
00:18:32,320 --> 00:18:34,960
accessibility and then you know how we

550
00:18:34,960 --> 00:18:37,120
made it accessible for everyone to start

551
00:18:37,120 --> 00:18:38,320
building starts

552
00:18:38,320 --> 00:18:39,760
so you start with a computational

553
00:18:39,760 --> 00:18:41,760
integrity statement something you want

554
00:18:41,760 --> 00:18:43,520
to prove let's say i processed you know

555
00:18:43,520 --> 00:18:43,919
10

556
00:18:43,919 --> 00:18:46,480
000 trades and now i need to update the

557
00:18:46,480 --> 00:18:48,080
merkle root accordingly

558
00:18:48,080 --> 00:18:50,000
and you're going to transition and move

559
00:18:50,000 --> 00:18:51,440
it into something that we call an

560
00:18:51,440 --> 00:18:52,880
air an algebraic intermediate

561
00:18:52,880 --> 00:18:54,559
representation and from there you're

562
00:18:54,559 --> 00:18:55,200
going to apply

563
00:18:55,200 --> 00:18:56,559
low degree testing and then some

564
00:18:56,559 --> 00:18:58,480
cryptography and make it into a stark

565
00:18:58,480 --> 00:18:59,679
and you get your proof

566
00:18:59,679 --> 00:19:01,440
the main thing i want to point out out

567
00:19:01,440 --> 00:19:03,120
is that the left part

568
00:19:03,120 --> 00:19:05,280
of this picture depends on the ci

569
00:19:05,280 --> 00:19:06,880
statement so if you're talking about

570
00:19:06,880 --> 00:19:07,679
payments

571
00:19:07,679 --> 00:19:09,919
it's one error if you're talking about

572
00:19:09,919 --> 00:19:11,760
trades it's another air and so on and so

573
00:19:11,760 --> 00:19:12,480
forth

574
00:19:12,480 --> 00:19:14,960
and the right most part that has a lot

575
00:19:14,960 --> 00:19:16,720
of algebra and the crypto does not

576
00:19:16,720 --> 00:19:19,120
depend on the statement

577
00:19:19,120 --> 00:19:21,919
so currently uh you know the way we went

578
00:19:21,919 --> 00:19:22,559
about

579
00:19:22,559 --> 00:19:25,120
writing these stark systems is we had to

580
00:19:25,120 --> 00:19:25,919
construct this

581
00:19:25,919 --> 00:19:29,120
error which is a bunch of constraints

582
00:19:29,120 --> 00:19:29,600
that

583
00:19:29,600 --> 00:19:31,600
each one of them is a polynomial and we

584
00:19:31,600 --> 00:19:33,679
need to define some execution trace that

585
00:19:33,679 --> 00:19:35,600
is a table of field elements

586
00:19:35,600 --> 00:19:38,640
and this is very cumbersome here's a

587
00:19:38,640 --> 00:19:39,799
picture of one of the

588
00:19:39,799 --> 00:19:43,120
visualization tools that our engineers

589
00:19:43,120 --> 00:19:45,760
built in order uh to deal with such

590
00:19:45,760 --> 00:19:46,480
things so

591
00:19:46,480 --> 00:19:48,320
you know this sort of shows you the

592
00:19:48,320 --> 00:19:49,840
different trace cells

593
00:19:49,840 --> 00:19:52,160
that we have in a computation and and

594
00:19:52,160 --> 00:19:54,240
shows a particular constraint and

595
00:19:54,240 --> 00:19:56,960
you can write by hand uh constraints for

596
00:19:56,960 --> 00:19:58,480
various computations

597
00:19:58,480 --> 00:20:00,559
so every different computational

598
00:20:00,559 --> 00:20:02,559
integrity statement resulted in a

599
00:20:02,559 --> 00:20:04,720
different error and you had to handwrite

600
00:20:04,720 --> 00:20:06,720
these things and try to minimize the

601
00:20:06,720 --> 00:20:07,919
size of the trace

602
00:20:07,919 --> 00:20:09,520
you know the number of rows the number

603
00:20:09,520 --> 00:20:11,760
of columns the degree of the constraints

604
00:20:11,760 --> 00:20:13,919
and of course as the logic got more and

605
00:20:13,919 --> 00:20:15,840
more complicated you would have to worry

606
00:20:15,840 --> 00:20:16,559
about

607
00:20:16,559 --> 00:20:18,799
debugging how do you document this how

608
00:20:18,799 --> 00:20:20,960
do you audited it what about reusing

609
00:20:20,960 --> 00:20:23,200
pieces of code modifying it making

610
00:20:23,200 --> 00:20:25,760
optimizations it all becomes very hard

611
00:20:25,760 --> 00:20:27,760
it's a little bit like building an asic

612
00:20:27,760 --> 00:20:28,960
right a chip

613
00:20:28,960 --> 00:20:31,200
by hand it's maybe very efficient if you

614
00:20:31,200 --> 00:20:32,640
know how to do it but it doesn't

615
00:20:32,640 --> 00:20:34,880
scale very well in terms of code

616
00:20:34,880 --> 00:20:36,080
complexity

617
00:20:36,080 --> 00:20:39,200
so now we reach cairo which is our

618
00:20:39,200 --> 00:20:41,679
new thing that was released last week so

619
00:20:41,679 --> 00:20:44,159
cairo stands for cpu air

620
00:20:44,159 --> 00:20:46,240
what if you had a compiler that could

621
00:20:46,240 --> 00:20:48,080
take a computational integrity

622
00:20:48,080 --> 00:20:50,559
statement written in a high-level

623
00:20:50,559 --> 00:20:51,919
programming language

624
00:20:51,919 --> 00:20:55,440
and then convert it to input

625
00:20:55,440 --> 00:20:59,200
that always goes to one single air

626
00:20:59,200 --> 00:21:02,240
and the air of cairo has

627
00:21:02,240 --> 00:21:05,919
less than 50 columns or trace cells

628
00:21:05,919 --> 00:21:08,000
that's its w the number of constraints

629
00:21:08,000 --> 00:21:10,080
is well below 100

630
00:21:10,080 --> 00:21:11,440
the degree of each one of these

631
00:21:11,440 --> 00:21:13,440
constraints is two

632
00:21:13,440 --> 00:21:15,440
the length of the trace depends on the

633
00:21:15,440 --> 00:21:16,960
program that you're running

634
00:21:16,960 --> 00:21:19,919
but it's one error to rule them all

635
00:21:19,919 --> 00:21:20,480
meaning

636
00:21:20,480 --> 00:21:23,440
every program you can think about you

637
00:21:23,440 --> 00:21:25,280
can write it in a way that it will be

638
00:21:25,280 --> 00:21:26,159
compiled

639
00:21:26,159 --> 00:21:28,240
and sent to this one algebraic

640
00:21:28,240 --> 00:21:30,960
intermediate representation

641
00:21:30,960 --> 00:21:34,240
so um cairo is the first universal for

642
00:21:34,240 --> 00:21:36,240
neumann stark which means the first

643
00:21:36,240 --> 00:21:38,000
proof system that is scalable

644
00:21:38,000 --> 00:21:39,679
transparent universal

645
00:21:39,679 --> 00:21:43,280
info neumann architecture released it is

646
00:21:43,280 --> 00:21:45,520
also the first universal phenomenon

647
00:21:45,520 --> 00:21:47,120
verifier that actually sits on a

648
00:21:47,120 --> 00:21:49,120
blockchain on the theory of mainnet

649
00:21:49,120 --> 00:21:52,080
so it's one smart contract that verifies

650
00:21:52,080 --> 00:21:52,720
any

651
00:21:52,720 --> 00:21:56,159
computer program written in in cairo and

652
00:21:56,159 --> 00:21:57,679
i just want to mention that there's an

653
00:21:57,679 --> 00:22:00,000
abundance of works on universal zkp's of

654
00:22:00,000 --> 00:22:02,080
various forms there's a good reference

655
00:22:02,080 --> 00:22:03,919
for it on zkp science

656
00:22:03,919 --> 00:22:05,919
i i'm not going to survey all of them

657
00:22:05,919 --> 00:22:08,000
but cairo is the first universal for

658
00:22:08,000 --> 00:22:08,880
neymar and stark

659
00:22:08,880 --> 00:22:10,840
first universal for my verifier on

660
00:22:10,840 --> 00:22:12,400
blockchain um

661
00:22:12,400 --> 00:22:15,600
now i want to get to the meat and tell

662
00:22:15,600 --> 00:22:16,799
you how you can

663
00:22:16,799 --> 00:22:19,360
you know what you should be doing or you

664
00:22:19,360 --> 00:22:21,200
know i hope you'll be doing some of you

665
00:22:21,200 --> 00:22:23,360
so cairo is uh let's call it a minimal

666
00:22:23,360 --> 00:22:24,880
viable language for what

667
00:22:24,880 --> 00:22:27,120
for reaching production grade stark

668
00:22:27,120 --> 00:22:28,080
systems

669
00:22:28,080 --> 00:22:30,799
uh we applied the goldilocks principle

670
00:22:30,799 --> 00:22:31,520
which is

671
00:22:31,520 --> 00:22:35,039
you know not too cold not too hot so

672
00:22:35,039 --> 00:22:38,240
the air oh sorry the virtual machine

673
00:22:38,240 --> 00:22:39,919
underlying cairo only has three

674
00:22:39,919 --> 00:22:42,400
registers a pc an allocation pointer and

675
00:22:42,400 --> 00:22:43,440
a frame pointer

676
00:22:43,440 --> 00:22:45,440
it has a very minimalistic instruction

677
00:22:45,440 --> 00:22:48,080
set but it supports functions recursion

678
00:22:48,080 --> 00:22:49,760
branching conditionals

679
00:22:49,760 --> 00:22:51,919
access to random memory you see here

680
00:22:51,919 --> 00:22:54,240
some snippets and library functions uh

681
00:22:54,240 --> 00:22:58,240
for it and um we actually are building

682
00:22:58,240 --> 00:23:00,720
all of our production systems uh the

683
00:23:00,720 --> 00:23:02,159
ones that are running today the ones

684
00:23:02,159 --> 00:23:03,520
that will be deployed over the next

685
00:23:03,520 --> 00:23:04,799
month or two

686
00:23:04,799 --> 00:23:07,440
using this language and and we released

687
00:23:07,440 --> 00:23:08,000
the cairo

688
00:23:08,000 --> 00:23:11,440
code for them so uh we just released

689
00:23:11,440 --> 00:23:13,200
last week a full tool chain that

690
00:23:13,200 --> 00:23:15,760
includes a compiler a virtual machine

691
00:23:15,760 --> 00:23:18,080
ide extensions tracer which is sort of a

692
00:23:18,080 --> 00:23:18,799
debugger

693
00:23:18,799 --> 00:23:20,640
and we released the source for our

694
00:23:20,640 --> 00:23:22,159
application code the one that we are

695
00:23:22,159 --> 00:23:23,440
running in production

696
00:23:23,440 --> 00:23:26,400
on ethereum today for scaling uh spot

697
00:23:26,400 --> 00:23:28,400
trading and we'll release similarly

698
00:23:28,400 --> 00:23:30,159
codes for margin trading and for

699
00:23:30,159 --> 00:23:31,840
non-fungible tokens

700
00:23:31,840 --> 00:23:34,000
um cairo turns out to be pretty

701
00:23:34,000 --> 00:23:36,400
efficient because

702
00:23:36,400 --> 00:23:38,400
even though a cpu is less efficient than

703
00:23:38,400 --> 00:23:39,919
an asic

704
00:23:39,919 --> 00:23:42,240
the fact that you allow your developers

705
00:23:42,240 --> 00:23:42,960
to write

706
00:23:42,960 --> 00:23:45,200
complex optimizations in a safe way

707
00:23:45,200 --> 00:23:46,320
because they're writing

708
00:23:46,320 --> 00:23:48,159
in a high-level programming language and

709
00:23:48,159 --> 00:23:50,880
not putting constraints by hand

710
00:23:50,880 --> 00:23:52,320
means that you end up with much more

711
00:23:52,320 --> 00:23:54,480
efficient code in practice so it's even

712
00:23:54,480 --> 00:23:56,559
efficient

713
00:23:56,559 --> 00:23:59,760
so the next steps for us uh we're going

714
00:23:59,760 --> 00:24:01,600
to do a lot of cairo education this is

715
00:24:01,600 --> 00:24:02,960
something we started last week we're

716
00:24:02,960 --> 00:24:04,640
going to put a proving service on test

717
00:24:04,640 --> 00:24:06,960
net probably in two to three weeks time

718
00:24:06,960 --> 00:24:09,679
that you can sort of uh write code press

719
00:24:09,679 --> 00:24:10,320
a button

720
00:24:10,320 --> 00:24:13,120
have that appearing and verified on

721
00:24:13,120 --> 00:24:14,000
blockchain

722
00:24:14,000 --> 00:24:15,600
later on we're going to put a proving

723
00:24:15,600 --> 00:24:17,120
service on mainnet maybe

724
00:24:17,120 --> 00:24:18,799
we're going to decentralize the proving

725
00:24:18,799 --> 00:24:20,960
ecosystem so that not only we are the

726
00:24:20,960 --> 00:24:21,679
ones running

727
00:24:21,679 --> 00:24:25,039
our provers um and what you should do

728
00:24:25,039 --> 00:24:26,720
is visit the cairo playground that i'm

729
00:24:26,720 --> 00:24:28,640
now going to show to you

730
00:24:28,640 --> 00:24:30,880
and you should write cairo code and you

731
00:24:30,880 --> 00:24:32,000
should later on deploy

732
00:24:32,000 --> 00:24:34,720
your scalable app with cairo so i just

733
00:24:34,720 --> 00:24:35,200
want to

734
00:24:35,200 --> 00:24:38,080
show you uh the cairo playground it's

735
00:24:38,080 --> 00:24:38,960
accessible

736
00:24:38,960 --> 00:24:41,600
the link is there you can see here

737
00:24:41,600 --> 00:24:43,919
examples of cairo programs

738
00:24:43,919 --> 00:24:45,840
here you know a bunch of challenges that

739
00:24:45,840 --> 00:24:47,120
teach you things

740
00:24:47,120 --> 00:24:51,039
uh you can sort of uh

741
00:24:51,039 --> 00:24:54,880
load a program run it uh okay i got an

742
00:24:54,880 --> 00:24:58,400
error here but uh you know you never use

743
00:24:58,400 --> 00:24:58,799
uh

744
00:24:58,799 --> 00:25:01,520
right never use uh the internet uh or

745
00:25:01,520 --> 00:25:03,200
try to run anything but here's an

746
00:25:03,200 --> 00:25:04,640
example of program

747
00:25:04,640 --> 00:25:07,360
this output you can sort of go over the

748
00:25:07,360 --> 00:25:08,000
various

749
00:25:08,000 --> 00:25:10,240
uh uh steps of the program understand

750
00:25:10,240 --> 00:25:11,440
what's going on

751
00:25:11,440 --> 00:25:15,360
learn it and

752
00:25:15,360 --> 00:25:17,200
i guess the very last thing i just want

753
00:25:17,200 --> 00:25:18,640
to say

754
00:25:18,640 --> 00:25:21,200
is that

755
00:25:24,880 --> 00:25:26,080
you know if there's one thing you should

756
00:25:26,080 --> 00:25:28,880
do you should try out the

757
00:25:28,880 --> 00:25:31,679
cairo playground now for yourself

758
00:25:31,679 --> 00:25:32,480
because again

759
00:25:32,480 --> 00:25:34,720
just to tie the story if you write code

760
00:25:34,720 --> 00:25:35,600
in this system

761
00:25:35,600 --> 00:25:37,679
within two to three weeks you can press

762
00:25:37,679 --> 00:25:39,600
a button and that code will have

763
00:25:39,600 --> 00:25:42,559
star proofs of it generated and placed

764
00:25:42,559 --> 00:25:43,440
and verified

765
00:25:43,440 --> 00:25:45,679
on a blockchain and this will lead the

766
00:25:45,679 --> 00:25:46,880
way for you to build

767
00:25:46,880 --> 00:25:49,200
uh systems like we are building the

768
00:25:49,200 --> 00:25:50,320
systems we are building

769
00:25:50,320 --> 00:25:53,120
are built in cairo written in cairo so

770
00:25:53,120 --> 00:25:55,120
you can write your scalable systems

771
00:25:55,120 --> 00:25:57,279
and then you will have the ability to

772
00:25:57,279 --> 00:25:58,880
reach the scale that currently we are

773
00:25:58,880 --> 00:25:59,919
reaching and that's

774
00:25:59,919 --> 00:26:02,159
something that we very much like to see

775
00:26:02,159 --> 00:26:03,919
so thank you very much happy to answer

776
00:26:03,919 --> 00:26:04,880
any questions

777
00:26:04,880 --> 00:26:06,480
wow awesome thank you thank you ellie

778
00:26:06,480 --> 00:26:08,400
this is this is fantastic

779
00:26:08,400 --> 00:26:10,640
very impressive maybe i could just say

780
00:26:10,640 --> 00:26:12,159
there are a couple of questions uh but

781
00:26:12,159 --> 00:26:13,200
let me uh take my

782
00:26:13,200 --> 00:26:16,400
my uh uh role as a moderator and ask the

783
00:26:16,400 --> 00:26:17,760
first couple of questions

784
00:26:17,760 --> 00:26:19,840
first of all it sounds like uh there's a

785
00:26:19,840 --> 00:26:21,600
really cool deployment scenario here

786
00:26:21,600 --> 00:26:23,600
where the proof where the verifier is

787
00:26:23,600 --> 00:26:23,919
going to

788
00:26:23,919 --> 00:26:27,520
be be deployed as an ethereum library in

789
00:26:27,520 --> 00:26:28,320
effect

790
00:26:28,320 --> 00:26:30,240
and then new contracts i guess wouldn't

791
00:26:30,240 --> 00:26:31,520
even have to implement the verifier

792
00:26:31,520 --> 00:26:32,720
themselves they can just call your

793
00:26:32,720 --> 00:26:33,679
verifier

794
00:26:33,679 --> 00:26:35,840
and verify whatever whatever proofs they

795
00:26:35,840 --> 00:26:37,039
have to verify

796
00:26:37,039 --> 00:26:38,559
that's kind of the the plan of how this

797
00:26:38,559 --> 00:26:40,159
would work that's not just the plan

798
00:26:40,159 --> 00:26:41,679
that's the way we're working right now

799
00:26:41,679 --> 00:26:42,720
there is a single

800
00:26:42,720 --> 00:26:46,320
uh cairo verifier our starkex systems

801
00:26:46,320 --> 00:26:47,360
are currently

802
00:26:47,360 --> 00:26:50,640
basically code uh cairo code and we

803
00:26:50,640 --> 00:26:53,200
send the cairo code along with the uh

804
00:26:53,200 --> 00:26:54,559
you know computational integrity

805
00:26:54,559 --> 00:26:55,520
statement

806
00:26:55,520 --> 00:26:58,240
to this one cairo verifier smart

807
00:26:58,240 --> 00:26:58,960
contract

808
00:26:58,960 --> 00:27:01,600
yes all programs are going to be sent to

809
00:27:01,600 --> 00:27:03,279
it has one single air

810
00:27:03,279 --> 00:27:05,360
and one single smart contract yeah

811
00:27:05,360 --> 00:27:06,640
that's that's fantastic

812
00:27:06,640 --> 00:27:09,919
um so um so first question is uh

813
00:27:09,919 --> 00:27:12,000
cairo is sort of a specific domain

814
00:27:12,000 --> 00:27:13,039
specific language

815
00:27:13,039 --> 00:27:16,480
a specific dsl for uh for uh verifiers

816
00:27:16,480 --> 00:27:18,240
i'm just curious like what's your take

817
00:27:18,240 --> 00:27:20,080
on these languages there are a lot of

818
00:27:20,080 --> 00:27:21,039
there are many uh

819
00:27:21,039 --> 00:27:23,760
uh domain specific languages dsls that

820
00:27:23,760 --> 00:27:24,960
have been developed now for proof

821
00:27:24,960 --> 00:27:26,320
systems you know there's socrates

822
00:27:26,320 --> 00:27:26,720
there's

823
00:27:26,720 --> 00:27:29,840
zinc there's snarky um where does uh

824
00:27:29,840 --> 00:27:31,760
like why did you decide decide to design

825
00:27:31,760 --> 00:27:32,960
a new language why

826
00:27:32,960 --> 00:27:34,640
why not use one of the existing

827
00:27:34,640 --> 00:27:37,279
languages or or where does cairo fit in

828
00:27:37,279 --> 00:27:38,880
all the ecosystem of languages that have

829
00:27:38,880 --> 00:27:40,640
been developed for proof systems

830
00:27:40,640 --> 00:27:43,039
right so i think i i wouldn't treat it

831
00:27:43,039 --> 00:27:45,200
as a dsl it's a little bit more like an

832
00:27:45,200 --> 00:27:47,120
assembly language with a cpu

833
00:27:47,120 --> 00:27:48,640
that that is you know turing complete

834
00:27:48,640 --> 00:27:50,799
and universal it has all the

835
00:27:50,799 --> 00:27:52,480
you know nice attributes that you would

836
00:27:52,480 --> 00:27:53,840
think of a full-blown

837
00:27:53,840 --> 00:27:58,080
uh um uh you know

838
00:27:58,080 --> 00:28:00,720
programming language so um it allows you

839
00:28:00,720 --> 00:28:02,640
memory access you know recursion

840
00:28:02,640 --> 00:28:03,360
branching

841
00:28:03,360 --> 00:28:06,399
uh you can write libraries um i think

842
00:28:06,399 --> 00:28:07,600
dsls are a bit

843
00:28:07,600 --> 00:28:10,320
yeah so i don't know like when i think

844
00:28:10,320 --> 00:28:12,159
of a dsl i think of something that by

845
00:28:12,159 --> 00:28:12,640
design

846
00:28:12,640 --> 00:28:15,200
is not your incomplete cannot process

847
00:28:15,200 --> 00:28:17,039
all programs there are there

848
00:28:17,039 --> 00:28:18,960
uh this this can really you know any

849
00:28:18,960 --> 00:28:20,320
logic that you have

850
00:28:20,320 --> 00:28:22,159
um so in that sense it's a little bit

851
00:28:22,159 --> 00:28:24,000
similar i mean and we saw a few of those

852
00:28:24,000 --> 00:28:24,399
i mean

853
00:28:24,399 --> 00:28:26,399
there's you know tiny ram and then there

854
00:28:26,399 --> 00:28:27,919
are compilers from

855
00:28:27,919 --> 00:28:31,120
um c um to uh various

856
00:28:31,120 --> 00:28:32,640
circuits so it's a bit more similar to

857
00:28:32,640 --> 00:28:34,720
that in this respect it's

858
00:28:34,720 --> 00:28:36,960
i think the main things so you know

859
00:28:36,960 --> 00:28:38,080
there were previously

860
00:28:38,080 --> 00:28:40,480
other universal uh proof systems oh

861
00:28:40,480 --> 00:28:42,320
sorry conversions from

862
00:28:42,320 --> 00:28:45,520
uh universal languages to uh proof

863
00:28:45,520 --> 00:28:46,320
systems

864
00:28:46,320 --> 00:28:49,520
what's most uh

865
00:28:49,520 --> 00:28:52,480
unique about this i think is the sort of

866
00:28:52,480 --> 00:28:53,279
production

867
00:28:53,279 --> 00:28:56,399
grade uh and integration with blockchain

868
00:28:56,399 --> 00:28:57,279
so

869
00:28:57,279 --> 00:28:59,919
it doesn't do you know once you have

870
00:28:59,919 --> 00:29:02,080
universality you can you can process any

871
00:29:02,080 --> 00:29:02,480
uh

872
00:29:02,480 --> 00:29:04,799
uh any problem so it doesn't this is as

873
00:29:04,799 --> 00:29:06,080
a real world as it gets

874
00:29:06,080 --> 00:29:09,360
we have a couple other other questions

875
00:29:09,360 --> 00:29:12,240
yeah systems employing them using this

876
00:29:12,240 --> 00:29:13,760
framework yes yeah for sure for sure

877
00:29:13,760 --> 00:29:14,480
yeah

878
00:29:14,480 --> 00:29:16,880
uh so john is asking uh does this apply

879
00:29:16,880 --> 00:29:18,240
to uh bitcoin in

880
00:29:18,240 --> 00:29:20,559
any way

881
00:29:21,520 --> 00:29:24,880
okay bitcoin uh we'd love to place uh

882
00:29:24,880 --> 00:29:26,880
this capability or any star capability

883
00:29:26,880 --> 00:29:27,919
on bitcoin

884
00:29:27,919 --> 00:29:31,120
that requires uh that would require uh

885
00:29:31,120 --> 00:29:34,320
bitcoin um you know being able to have

886
00:29:34,320 --> 00:29:37,760
uh a stark verifier on on of some sort

887
00:29:37,760 --> 00:29:41,520
and um you know we'd love to work with

888
00:29:41,520 --> 00:29:43,120
the bitcoin community to make that

889
00:29:43,120 --> 00:29:43,600
happen

890
00:29:43,600 --> 00:29:45,039
uh currently i think the bitcoin

891
00:29:45,039 --> 00:29:47,200
community is rather conservative and you

892
00:29:47,200 --> 00:29:47,919
know the

893
00:29:47,919 --> 00:29:50,399
things are deployed rather slowly on it

894
00:29:50,399 --> 00:29:51,440
but there's

895
00:29:51,440 --> 00:29:53,200
so currently no you can't put it on

896
00:29:53,200 --> 00:29:55,600
bitcoin but uh i i

897
00:29:55,600 --> 00:29:57,520
really hope that bitcoin will will

898
00:29:57,520 --> 00:29:58,640
someday uh

899
00:29:58,640 --> 00:30:01,200
adopt uh you know allow a store maybe

900
00:30:01,200 --> 00:30:03,440
it'll be an op code that says verify

901
00:30:03,440 --> 00:30:06,559
verify stark yes yes yeah

902
00:30:06,559 --> 00:30:08,159
that would be the natural way i guess to

903
00:30:08,159 --> 00:30:10,159
incorporate it let's see so jake is

904
00:30:10,159 --> 00:30:10,960
asking

905
00:30:10,960 --> 00:30:13,279
uh how has your view of the differences

906
00:30:13,279 --> 00:30:14,799
between starks and snarks

907
00:30:14,799 --> 00:30:16,880
changed over the last year with the

908
00:30:16,880 --> 00:30:18,559
latest research beginning to allow

909
00:30:18,559 --> 00:30:23,100
transparency for snarks too um

910
00:30:23,100 --> 00:30:24,320
[Music]

911
00:30:24,320 --> 00:30:26,320
i think there's a lot of tremendous

912
00:30:26,320 --> 00:30:28,880
research on on all zkps and it will

913
00:30:28,880 --> 00:30:31,520
continue

914
00:30:32,000 --> 00:30:36,480
i still i still think that in terms

915
00:30:36,480 --> 00:30:38,320
i i still stand by what i said

916
00:30:38,320 --> 00:30:39,600
previously which is that

917
00:30:39,600 --> 00:30:41,919
if you want if if the length of the

918
00:30:41,919 --> 00:30:43,520
argument is the thing you want to

919
00:30:43,520 --> 00:30:44,559
minimize

920
00:30:44,559 --> 00:30:47,919
then uh uh you know roth 16 is is the

921
00:30:47,919 --> 00:30:48,320
king

922
00:30:48,320 --> 00:30:51,760
and uh and maybe other systems that are

923
00:30:51,760 --> 00:30:53,279
some of them transparent are coming

924
00:30:53,279 --> 00:30:56,399
close to that you know and

925
00:30:56,399 --> 00:30:59,120
but then i think that to best of my

926
00:30:59,120 --> 00:31:01,840
knowledge all other aspects which mean

927
00:31:01,840 --> 00:31:05,120
proving time uh verifying time

928
00:31:05,120 --> 00:31:09,039
and uh you know minimality of crypto

929
00:31:09,039 --> 00:31:10,159
assumptions

930
00:31:10,159 --> 00:31:14,000
are are best in in the sort of

931
00:31:14,000 --> 00:31:16,880
what we call their airfry starks but uh

932
00:31:16,880 --> 00:31:18,240
that so so my

933
00:31:18,240 --> 00:31:20,799
you know that's my still yeah that makes

934
00:31:20,799 --> 00:31:21,519
sense basically

935
00:31:21,519 --> 00:31:23,440
yeah that that's a fair that's a fair

936
00:31:23,440 --> 00:31:25,440
answer um so i want to actually end

937
00:31:25,440 --> 00:31:27,039
where actually a time but i want to end

938
00:31:27,039 --> 00:31:28,080
with something that i think is a

939
00:31:28,080 --> 00:31:29,679
research question so let me ask you this

940
00:31:29,679 --> 00:31:31,519
this and uh it's fine to say that there

941
00:31:31,519 --> 00:31:33,279
is no answer

942
00:31:33,279 --> 00:31:35,519
so the prover architecture that you

943
00:31:35,519 --> 00:31:36,399
mentioned

944
00:31:36,399 --> 00:31:38,080
basically allows everybody to submit

945
00:31:38,080 --> 00:31:39,679
their transactions to the approver and

946
00:31:39,679 --> 00:31:41,279
then the approver

947
00:31:41,279 --> 00:31:42,960
submits the basically the log of

948
00:31:42,960 --> 00:31:44,640
transactions and a proof to the

949
00:31:44,640 --> 00:31:46,320
blockchain and now the block changes

950
00:31:46,320 --> 00:31:48,640
verifies the proof rather than verifying

951
00:31:48,640 --> 00:31:50,960
10 000 transactions but this gives the

952
00:31:50,960 --> 00:31:52,320
approver some power and that the

953
00:31:52,320 --> 00:31:54,000
approver can choose the order in which

954
00:31:54,000 --> 00:31:56,000
transactions are submitted to the chain

955
00:31:56,000 --> 00:31:58,720
so for example if um if a bunch of

956
00:31:58,720 --> 00:32:00,000
transactions are submitted

957
00:32:00,000 --> 00:32:01,919
the approver can basically front run all

958
00:32:01,919 --> 00:32:03,760
those transactions by inserting its own

959
00:32:03,760 --> 00:32:05,440
transaction first

960
00:32:05,440 --> 00:32:07,039
right so do you see in this prover

961
00:32:07,039 --> 00:32:08,720
architecture do you see a way to

962
00:32:08,720 --> 00:32:11,360
to uh it seems like front running is

963
00:32:11,360 --> 00:32:12,799
sort of inherent in this transaction do

964
00:32:12,799 --> 00:32:14,880
you see a way to prevent front running

965
00:32:14,880 --> 00:32:18,559
in this environment um

966
00:32:18,559 --> 00:32:20,399
currently the way we think about it

967
00:32:20,399 --> 00:32:22,159
right now is we we're saying there is

968
00:32:22,159 --> 00:32:24,880
a separate question of sequencing and or

969
00:32:24,880 --> 00:32:26,240
you know sequencing

970
00:32:26,240 --> 00:32:29,519
operating which means who who and or how

971
00:32:29,519 --> 00:32:31,919
do you sequence the the transactions

972
00:32:31,919 --> 00:32:32,720
there are many

973
00:32:32,720 --> 00:32:36,000
uh so currently we are not um first of

974
00:32:36,000 --> 00:32:37,600
all we are not solving these problems on

975
00:32:37,600 --> 00:32:39,440
our systems there is an operator so it

976
00:32:39,440 --> 00:32:41,200
is the one that is sequencing

977
00:32:41,200 --> 00:32:44,559
in other variations it's going to be uh

978
00:32:44,559 --> 00:32:46,640
there's the term zk roll up which

979
00:32:46,640 --> 00:32:48,000
basically means

980
00:32:48,000 --> 00:32:49,760
that people are going to submit you're

981
00:32:49,760 --> 00:32:52,399
going to put the sequencing on the

982
00:32:52,399 --> 00:32:54,000
blockchain so it doesn't solve the

983
00:32:54,000 --> 00:32:55,600
problem it just pushes it to some other

984
00:32:55,600 --> 00:32:56,000
area

985
00:32:56,000 --> 00:32:57,600
right now you let the blockchain

986
00:32:57,600 --> 00:32:59,200
sequence it and then you have a prover

987
00:32:59,200 --> 00:33:01,120
just taking the sequence from there

988
00:33:01,120 --> 00:33:03,440
and sort of it's committed to to you

989
00:33:03,440 --> 00:33:05,200
know processing in that order

990
00:33:05,200 --> 00:33:08,480
but to answer your question about

991
00:33:08,480 --> 00:33:10,960
am i aware or are we conducting research

992
00:33:10,960 --> 00:33:12,080
on using

993
00:33:12,080 --> 00:33:15,039
zkp's to solve the sequencing problem or

994
00:33:15,039 --> 00:33:16,799
decentralized sequencing in a better way

995
00:33:16,799 --> 00:33:18,480
the answer to that is no i think it's a

996
00:33:18,480 --> 00:33:20,320
terrific direction but i

997
00:33:20,320 --> 00:33:23,039
and starco we haven't spent any uh you

998
00:33:23,039 --> 00:33:24,000
know any resources

999
00:33:24,000 --> 00:33:26,480
on thinking about it but uh dan is

1000
00:33:26,480 --> 00:33:27,039
usually

1001
00:33:27,039 --> 00:33:28,240
you know you're leading to very

1002
00:33:28,240 --> 00:33:30,240
interesting uh questions so yeah

1003
00:33:30,240 --> 00:33:31,840
yeah that's a great question for the

1004
00:33:31,840 --> 00:33:33,760
community um

1005
00:33:33,760 --> 00:33:35,760
all right so fantastic so we're at time

1006
00:33:35,760 --> 00:33:37,360
thank you so much ellie this was really

1007
00:33:37,360 --> 00:33:38,240
great

1008
00:33:38,240 --> 00:33:41,840
so thank you

