1
00:00:00,719 --> 00:00:03,120
hi everyone and welcome to the talk from

2
00:00:03,120 --> 00:00:05,040
crypto paper to cryptocurrency the

3
00:00:05,040 --> 00:00:07,279
cardano consensus layer

4
00:00:07,279 --> 00:00:09,360
this is an extended version of the talk

5
00:00:09,360 --> 00:00:11,280
that we present at the real world crypto

6
00:00:11,280 --> 00:00:13,440
symposium 2021

7
00:00:13,440 --> 00:00:15,280
my name is christian and this is a joint

8
00:00:15,280 --> 00:00:17,440
talk with philip and duncan

9
00:00:17,440 --> 00:00:19,359
and we were supported by peter garcia

10
00:00:19,359 --> 00:00:22,080
aguilos quies and alexander russell

11
00:00:22,080 --> 00:00:24,240
the talk is roughly structured into four

12
00:00:24,240 --> 00:00:25,359
sections first

13
00:00:25,359 --> 00:00:27,439
i will cover some general aspects from

14
00:00:27,439 --> 00:00:29,199
theory to practice

15
00:00:29,199 --> 00:00:31,199
then we discuss the formal methods and

16
00:00:31,199 --> 00:00:33,120
implementation correctness

17
00:00:33,120 --> 00:00:35,840
aspects that are related to the cardinal

18
00:00:35,840 --> 00:00:37,040
consensus layer

19
00:00:37,040 --> 00:00:38,719
then we discuss what could have gone

20
00:00:38,719 --> 00:00:40,399
wrong if we hadn't followed such a

21
00:00:40,399 --> 00:00:42,800
strict and methodological approach

22
00:00:42,800 --> 00:00:45,600
to the implementation and finally we

23
00:00:45,600 --> 00:00:47,440
discuss some aspects

24
00:00:47,440 --> 00:00:51,599
on our path to decentralization

25
00:00:52,000 --> 00:00:54,960
at its core the cardano consensus layer

26
00:00:54,960 --> 00:00:56,079
is a distributed

27
00:00:56,079 --> 00:00:57,680
computation over a network it's a

28
00:00:57,680 --> 00:01:00,239
cryptographic protocol and as such

29
00:01:00,239 --> 00:01:04,000
we fix in our papers a formal model for

30
00:01:04,000 --> 00:01:05,600
protocol execution

31
00:01:05,600 --> 00:01:07,439
we model the parties that run the

32
00:01:07,439 --> 00:01:10,240
protocol by interactive machines

33
00:01:10,240 --> 00:01:12,640
we formalize the assumed resources that

34
00:01:12,640 --> 00:01:13,520
are available

35
00:01:13,520 --> 00:01:15,759
to the protocol for example we formalize

36
00:01:15,759 --> 00:01:17,040
which type of network

37
00:01:17,040 --> 00:01:19,600
we assume is there a clocks or random

38
00:01:19,600 --> 00:01:20,560
oracle

39
00:01:20,560 --> 00:01:23,040
with formalization i mean to specify

40
00:01:23,040 --> 00:01:23,680
such

41
00:01:23,680 --> 00:01:26,560
assumed real-life objects in a more

42
00:01:26,560 --> 00:01:27,600
abstract manner

43
00:01:27,600 --> 00:01:29,680
that is more friendly for mathematical

44
00:01:29,680 --> 00:01:31,840
proofs we could for example imagine

45
00:01:31,840 --> 00:01:32,479
writing

46
00:01:32,479 --> 00:01:35,280
the specification of a network as a

47
00:01:35,280 --> 00:01:37,520
pseudo code or any other language

48
00:01:37,520 --> 00:01:41,040
that helps us to do the proofs

49
00:01:41,040 --> 00:01:43,920
here we already see a strong interplay

50
00:01:43,920 --> 00:01:44,799
between

51
00:01:44,799 --> 00:01:47,520
theory and engineering an abstraction

52
00:01:47,520 --> 00:01:48,479
must capture

53
00:01:48,479 --> 00:01:51,439
all relevant properties but should not

54
00:01:51,439 --> 00:01:52,320
omit

55
00:01:52,320 --> 00:01:55,439
details that we later deem relevant this

56
00:01:55,439 --> 00:01:58,560
is a very subtle task

57
00:01:58,560 --> 00:02:01,680
part of our execution model is also

58
00:02:01,680 --> 00:02:03,920
an attacker so we must assume that not

59
00:02:03,920 --> 00:02:05,360
all parties

60
00:02:05,360 --> 00:02:08,399
they run in favor of the protocol there

61
00:02:08,399 --> 00:02:09,840
might be a central adversary that

62
00:02:09,840 --> 00:02:11,760
corrupts certain machines

63
00:02:11,760 --> 00:02:13,120
which might then interfere with the

64
00:02:13,120 --> 00:02:15,440
protocol execution in an arbitrary way

65
00:02:15,440 --> 00:02:17,280
so our protocols have to be resilient

66
00:02:17,280 --> 00:02:19,440
against such attacks

67
00:02:19,440 --> 00:02:22,319
we must also keep in mind that parties

68
00:02:22,319 --> 00:02:23,760
might be rational

69
00:02:23,760 --> 00:02:27,280
so we must incentivize honest behavior

70
00:02:27,280 --> 00:02:29,120
we must incentivize the people

71
00:02:29,120 --> 00:02:30,239
participate

72
00:02:30,239 --> 00:02:33,519
for the good of the protocol finally we

73
00:02:33,519 --> 00:02:34,959
also have to deal with machine

74
00:02:34,959 --> 00:02:37,280
failures which means that parties might

75
00:02:37,280 --> 00:02:38,239
disconnect

76
00:02:38,239 --> 00:02:39,920
for a certain amount of time from the

77
00:02:39,920 --> 00:02:42,000
network and later reconnect

78
00:02:42,000 --> 00:02:44,400
and they must be able to to bootstrap

79
00:02:44,400 --> 00:02:46,640
the current state

80
00:02:46,640 --> 00:02:49,200
automatically so other parties might

81
00:02:49,200 --> 00:02:50,800
help to synchronize

82
00:02:50,800 --> 00:02:53,200
but this should be a part of the model

83
00:02:53,200 --> 00:02:56,720
and the protocol must support this

84
00:02:56,720 --> 00:02:58,080
overall this gives us a very

85
00:02:58,080 --> 00:03:00,159
fine-grained security model

86
00:03:00,159 --> 00:03:02,480
coupled with a very strong notion of

87
00:03:02,480 --> 00:03:03,360
security

88
00:03:03,360 --> 00:03:06,159
namely composition where each external

89
00:03:06,159 --> 00:03:06,959
input

90
00:03:06,959 --> 00:03:09,360
such as a transaction might depend on

91
00:03:09,360 --> 00:03:10,640
the entire view

92
00:03:10,640 --> 00:03:12,879
of this and other protocols we get

93
00:03:12,879 --> 00:03:14,640
actually a very meaningful security

94
00:03:14,640 --> 00:03:16,000
statement if you prove security

95
00:03:16,000 --> 00:03:17,840
properties and such

96
00:03:17,840 --> 00:03:21,040
in such a manner why because our model

97
00:03:21,040 --> 00:03:22,239
of security

98
00:03:22,239 --> 00:03:26,000
assumes a lot of very bad actors

99
00:03:26,000 --> 00:03:29,920
and is in this sense worst case

100
00:03:29,920 --> 00:03:34,159
and if we are confident that our model

101
00:03:34,159 --> 00:03:38,080
is like worse than the real life will be

102
00:03:38,080 --> 00:03:40,720
then actually our security proofs is

103
00:03:40,720 --> 00:03:42,239
meaningful to practice if you believe

104
00:03:42,239 --> 00:03:43,519
you have captured all relevant

105
00:03:43,519 --> 00:03:44,640
properties

106
00:03:44,640 --> 00:03:47,680
and is more powerful than in reality

107
00:03:47,680 --> 00:03:50,799
it would be then our security proofs

108
00:03:50,799 --> 00:03:53,439
really mean something

109
00:03:53,439 --> 00:03:54,959
on paper we know what the cardano

110
00:03:54,959 --> 00:03:56,799
consensus layer should implement it

111
00:03:56,799 --> 00:03:57,760
should realize

112
00:03:57,760 --> 00:04:00,640
a lecture that is persistent in life

113
00:04:00,640 --> 00:04:01,599
persistent

114
00:04:01,599 --> 00:04:04,879
means that it records transactions

115
00:04:04,879 --> 00:04:07,519
and smart contract state transitions

116
00:04:07,519 --> 00:04:09,439
that are immutable

117
00:04:09,439 --> 00:04:12,720
it should be live because we want that

118
00:04:12,720 --> 00:04:14,879
transactions get added over time to this

119
00:04:14,879 --> 00:04:16,160
lecture

120
00:04:16,160 --> 00:04:18,399
we also know that uroboros is a nakamoto

121
00:04:18,399 --> 00:04:20,399
style proof of stake blockchain protocol

122
00:04:20,399 --> 00:04:21,600
that realizes

123
00:04:21,600 --> 00:04:25,120
such a ledger to recall a nakamoto-style

124
00:04:25,120 --> 00:04:26,240
blockchain

125
00:04:26,240 --> 00:04:28,560
kicks off with a genesis block then in

126
00:04:28,560 --> 00:04:30,400
each round we have a lottery who the

127
00:04:30,400 --> 00:04:32,400
next block proposal should be

128
00:04:32,400 --> 00:04:36,000
and proposes are elected proportional

129
00:04:36,000 --> 00:04:38,880
to the stake they own this gives rise to

130
00:04:38,880 --> 00:04:40,800
a fork structure or three-star

131
00:04:40,800 --> 00:04:42,960
structure and although we might not

132
00:04:42,960 --> 00:04:44,720
agree on the most

133
00:04:44,720 --> 00:04:48,560
recent few blocks we always know

134
00:04:48,560 --> 00:04:50,800
or we prove that we have always a large

135
00:04:50,800 --> 00:04:52,160
common prefix

136
00:04:52,160 --> 00:04:54,000
we have chain growth so the chain grows

137
00:04:54,000 --> 00:04:55,759
we have chain quality have enough

138
00:04:55,759 --> 00:04:58,720
well-formed blocks and this is all

139
00:04:58,720 --> 00:04:59,440
proven under

140
00:04:59,440 --> 00:05:02,560
an honest majority assumption uh

141
00:05:02,560 --> 00:05:05,280
meaning that this number the stake is

142
00:05:05,280 --> 00:05:07,440
assumed the honest the majority of stake

143
00:05:07,440 --> 00:05:08,560
is assumed to be in

144
00:05:08,560 --> 00:05:11,440
the hands of honest artists uroboros has

145
00:05:11,440 --> 00:05:12,400
developed

146
00:05:12,400 --> 00:05:14,960
over a series of works to achieve the

147
00:05:14,960 --> 00:05:17,280
resilient design it has today

148
00:05:17,280 --> 00:05:19,919
each of the papers you see on the on the

149
00:05:19,919 --> 00:05:20,560
left

150
00:05:20,560 --> 00:05:22,400
had to overcome specific design

151
00:05:22,400 --> 00:05:25,520
challenges as we've seen before

152
00:05:25,520 --> 00:05:26,880
all these papers they leave in an

153
00:05:26,880 --> 00:05:29,440
abstract proof-oriented world

154
00:05:29,440 --> 00:05:31,680
as such they have abstractions of

155
00:05:31,680 --> 00:05:32,800
components

156
00:05:32,800 --> 00:05:34,479
they're written in pseudocode we make

157
00:05:34,479 --> 00:05:35,840
asymptotic statements

158
00:05:35,840 --> 00:05:38,479
hence they're still there is still a

159
00:05:38,479 --> 00:05:40,720
quite large gap to bridge

160
00:05:40,720 --> 00:05:43,360
between any and a theory and an

161
00:05:43,360 --> 00:05:45,440
implementation

162
00:05:45,440 --> 00:05:47,919
from a conceptual point of view also the

163
00:05:47,919 --> 00:05:49,280
sequence of steps

164
00:05:49,280 --> 00:05:52,639
make a lot of sense first

165
00:05:52,639 --> 00:05:54,639
the classic version of uroboros that

166
00:05:54,639 --> 00:05:57,199
appeared in crypto 2017

167
00:05:57,199 --> 00:05:58,720
it assumed the synchronous model of

168
00:05:58,720 --> 00:06:01,280
computation and static corruption

169
00:06:01,280 --> 00:06:04,319
in prows the rigid message passing

170
00:06:04,319 --> 00:06:06,560
ground structure was removed

171
00:06:06,560 --> 00:06:10,960
and adaptive corruptions were tolerated

172
00:06:10,960 --> 00:06:13,360
a reward sharing scheme for stake pools

173
00:06:13,360 --> 00:06:15,280
was added to establish an equilibrium

174
00:06:15,280 --> 00:06:16,960
with a large number of pools

175
00:06:16,960 --> 00:06:19,840
with high commitment to the system in

176
00:06:19,840 --> 00:06:21,840
genesis we dealt with fluctuating

177
00:06:21,840 --> 00:06:23,360
participation

178
00:06:23,360 --> 00:06:25,520
and made it possible that joining after

179
00:06:25,520 --> 00:06:27,120
disk connection

180
00:06:27,120 --> 00:06:30,800
is possible in a decentralized manner

181
00:06:30,800 --> 00:06:34,000
later we improved the resilience by less

182
00:06:34,000 --> 00:06:37,840
dependency on an external timing service

183
00:06:37,840 --> 00:06:41,440
and finally we get more functionality by

184
00:06:41,440 --> 00:06:42,160
privacy

185
00:06:42,160 --> 00:06:46,000
thanks to the design of krypsinos

186
00:06:46,000 --> 00:06:48,800
this looks all so ordered but is that

187
00:06:48,800 --> 00:06:50,560
really the case when we move from

188
00:06:50,560 --> 00:06:53,919
theory to practice with this question

189
00:06:53,919 --> 00:06:56,080
i would like to pass it on to philip

190
00:06:56,080 --> 00:06:57,840
thank you

191
00:06:57,840 --> 00:07:00,479
excellent question christian thank you

192
00:07:00,479 --> 00:07:02,000
the answer is of course that things are

193
00:07:02,000 --> 00:07:03,280
messy in production than they are in a

194
00:07:03,280 --> 00:07:04,880
research paper

195
00:07:04,880 --> 00:07:07,039
after we had the original orborus

196
00:07:07,039 --> 00:07:08,479
version as a preprint

197
00:07:08,479 --> 00:07:10,160
we started an engineering effort to

198
00:07:10,160 --> 00:07:12,240
build a cryptocurrency built upon

199
00:07:12,240 --> 00:07:14,560
that protocol we launched that in

200
00:07:14,560 --> 00:07:16,240
september 2017

201
00:07:16,240 --> 00:07:17,360
and having something running in

202
00:07:17,360 --> 00:07:19,680
production we then realized basically

203
00:07:19,680 --> 00:07:20,319
what was

204
00:07:20,319 --> 00:07:23,599
still missing we um realized pretty

205
00:07:23,599 --> 00:07:24,479
early on that we

206
00:07:24,479 --> 00:07:26,479
couldn't launch that system in a

207
00:07:26,479 --> 00:07:28,080
decentralized manner yet because we

208
00:07:28,080 --> 00:07:29,120
didn't have the

209
00:07:29,120 --> 00:07:30,400
reward schemes and the delegation

210
00:07:30,400 --> 00:07:32,400
mechanism that we needed in order to

211
00:07:32,400 --> 00:07:33,120
have it

212
00:07:33,120 --> 00:07:36,479
running efficiently and we also

213
00:07:36,479 --> 00:07:38,960
realized that certain aspects of the

214
00:07:38,960 --> 00:07:40,160
consensus protocol

215
00:07:40,160 --> 00:07:42,720
needed refinement which then spawned the

216
00:07:42,720 --> 00:07:44,479
the upcoming research papers

217
00:07:44,479 --> 00:07:47,280
it was a a continuous process of getting

218
00:07:47,280 --> 00:07:48,560
an improved understanding of the

219
00:07:48,560 --> 00:07:49,360
requirements

220
00:07:49,360 --> 00:07:52,080
on the system we also realized that the

221
00:07:52,080 --> 00:07:53,280
engineering that we had done for the

222
00:07:53,280 --> 00:07:54,240
first version

223
00:07:54,240 --> 00:07:57,280
was perfect which is basically not the

224
00:07:57,280 --> 00:07:58,560
case

225
00:07:58,560 --> 00:08:01,120
one of the big things that we had in the

226
00:08:01,120 --> 00:08:02,560
first version was that

227
00:08:02,560 --> 00:08:04,560
the whole thing was too tangled so there

228
00:08:04,560 --> 00:08:06,400
was no clear separation between the

229
00:08:06,400 --> 00:08:07,280
different

230
00:08:07,280 --> 00:08:09,919
modules and that made it very hard to

231
00:08:09,919 --> 00:08:11,520
switch from one version of the consensus

232
00:08:11,520 --> 00:08:12,400
protocol

233
00:08:12,400 --> 00:08:14,319
to another or to do changes to the

234
00:08:14,319 --> 00:08:16,160
letter rules and so

235
00:08:16,160 --> 00:08:18,879
we started a re-engineering effort to

236
00:08:18,879 --> 00:08:19,280
get

237
00:08:19,280 --> 00:08:22,080
a version of the system that was much

238
00:08:22,080 --> 00:08:24,879
more modular where you could

239
00:08:24,879 --> 00:08:27,520
make changes to the consensus protocol

240
00:08:27,520 --> 00:08:29,360
or to the ledger independently from one

241
00:08:29,360 --> 00:08:29,919
another

242
00:08:29,919 --> 00:08:31,680
and make a transition and accommodate

243
00:08:31,680 --> 00:08:33,039
basically all these improvements that

244
00:08:33,039 --> 00:08:34,479
the researchers did to the consensus

245
00:08:34,479 --> 00:08:35,440
protocol

246
00:08:35,440 --> 00:08:37,919
so in 2019 that was ready for production

247
00:08:37,919 --> 00:08:38,559
and we

248
00:08:38,559 --> 00:08:40,399
started that alongside the old code and

249
00:08:40,399 --> 00:08:42,640
then afterwards were able to retire the

250
00:08:42,640 --> 00:08:43,839
old code base

251
00:08:43,839 --> 00:08:46,480
and then in summer 2020 finally we were

252
00:08:46,480 --> 00:08:47,360
able to

253
00:08:47,360 --> 00:08:49,040
decentralize the system because all the

254
00:08:49,040 --> 00:08:50,720
components that we needed

255
00:08:50,720 --> 00:08:53,440
were ready and yeah the thing that us

256
00:08:53,440 --> 00:08:54,800
the things that are still to do is like

257
00:08:54,800 --> 00:08:55,600
adding the

258
00:08:55,600 --> 00:08:57,600
the genesis chronos and the upcoming

259
00:08:57,600 --> 00:08:59,279
versions of the consensus protocol

260
00:08:59,279 --> 00:09:00,560
as well as adding new features like

261
00:09:00,560 --> 00:09:03,680
smart contracts to the system

262
00:09:04,399 --> 00:09:06,160
now the next thing that we want to cover

263
00:09:06,160 --> 00:09:08,240
in the presentation uh how

264
00:09:08,240 --> 00:09:10,480
we made sure that all the nice

265
00:09:10,480 --> 00:09:12,080
guarantees that we have from the

266
00:09:12,080 --> 00:09:14,000
research papers that the proofs that we

267
00:09:14,000 --> 00:09:15,120
have on the theory side

268
00:09:15,120 --> 00:09:16,080
actually carry over to the

269
00:09:16,080 --> 00:09:17,920
implementation so that we have something

270
00:09:17,920 --> 00:09:18,560
that

271
00:09:18,560 --> 00:09:19,920
we are confident is correct and that we

272
00:09:19,920 --> 00:09:22,320
can also show evidence that is correct

273
00:09:22,320 --> 00:09:24,320
and when you want to do something like

274
00:09:24,320 --> 00:09:25,600
that there are some

275
00:09:25,600 --> 00:09:27,440
questions that you have to start that

276
00:09:27,440 --> 00:09:28,959
you have to ask yourself before you

277
00:09:28,959 --> 00:09:29,760
start

278
00:09:29,760 --> 00:09:31,360
like what's the required level of

279
00:09:31,360 --> 00:09:32,880
confidence that you want to have in your

280
00:09:32,880 --> 00:09:34,000
in your system

281
00:09:34,000 --> 00:09:35,920
that is correct what time do you have

282
00:09:35,920 --> 00:09:37,120
available to implement it

283
00:09:37,120 --> 00:09:38,240
what about the requirements are they

284
00:09:38,240 --> 00:09:40,000
fixed do they change during the course

285
00:09:40,000 --> 00:09:41,519
of implementing the thing

286
00:09:41,519 --> 00:09:43,519
and what's the difficulty of the whole

287
00:09:43,519 --> 00:09:44,720
thing anyway

288
00:09:44,720 --> 00:09:46,240
and depending on how you answer those

289
00:09:46,240 --> 00:09:47,519
questions you can pick different

290
00:09:47,519 --> 00:09:48,560
approaches

291
00:09:48,560 --> 00:09:50,640
if you don't need much confidence and

292
00:09:50,640 --> 00:09:52,399
correctness and you can like

293
00:09:52,399 --> 00:09:54,640
issue fixes if something goes wrong and

294
00:09:54,640 --> 00:09:55,920
you want to be very quick then

295
00:09:55,920 --> 00:09:58,240
you can do this agile move fast and

296
00:09:58,240 --> 00:09:59,040
break things

297
00:09:59,040 --> 00:10:01,120
um approach but that's not good for a

298
00:10:01,120 --> 00:10:02,480
system where like

299
00:10:02,480 --> 00:10:04,000
having an error in production

300
00:10:04,000 --> 00:10:05,920
compromises it and leads to a lot of

301
00:10:05,920 --> 00:10:06,880
money

302
00:10:06,880 --> 00:10:08,800
on the other hand you have the the full

303
00:10:08,800 --> 00:10:10,320
formal um

304
00:10:10,320 --> 00:10:12,399
approach where you basically specify

305
00:10:12,399 --> 00:10:13,839
everything beforehand

306
00:10:13,839 --> 00:10:16,880
and then prove that that everything is

307
00:10:16,880 --> 00:10:18,640
is right and then once you have done all

308
00:10:18,640 --> 00:10:20,480
the proofs you start implementation

309
00:10:20,480 --> 00:10:23,040
which tends to be slower but um you have

310
00:10:23,040 --> 00:10:24,399
a great degree of confidence in the

311
00:10:24,399 --> 00:10:25,279
correctness

312
00:10:25,279 --> 00:10:27,200
you can also like choose to the middle

313
00:10:27,200 --> 00:10:28,320
way and and

314
00:10:28,320 --> 00:10:31,680
use some methods which we will show you

315
00:10:31,680 --> 00:10:32,320
some

316
00:10:32,320 --> 00:10:35,440
in the the following sections um

317
00:10:35,440 --> 00:10:37,200
that do give you great confidence in the

318
00:10:37,200 --> 00:10:38,480
correctness but that are

319
00:10:38,480 --> 00:10:40,800
quicker and i would argue even quicker

320
00:10:40,800 --> 00:10:42,399
than the startup way because you make

321
00:10:42,399 --> 00:10:44,000
fewer mistakes and those mistakes always

322
00:10:44,000 --> 00:10:46,560
cost you a lot of time

323
00:10:46,560 --> 00:10:49,120
um so the the question is not really do

324
00:10:49,120 --> 00:10:50,640
i want to implement things correctly or

325
00:10:50,640 --> 00:10:51,920
do i want to implement them correctly

326
00:10:51,920 --> 00:10:53,839
but you should really aim for both

327
00:10:53,839 --> 00:10:55,600
because doing them correctly saves you

328
00:10:55,600 --> 00:10:56,880
time because you don't have to

329
00:10:56,880 --> 00:11:00,079
fix bugs that are already in production

330
00:11:00,079 --> 00:11:02,560
there's a variety of tools that you can

331
00:11:02,560 --> 00:11:05,120
use from formal specifications and

332
00:11:05,120 --> 00:11:06,800
proofs about properties of those that

333
00:11:06,800 --> 00:11:09,279
you can either write by hand or even

334
00:11:09,279 --> 00:11:09,839
using

335
00:11:09,839 --> 00:11:13,519
a a theorem prover that can then

336
00:11:13,519 --> 00:11:15,279
check actually that those that you don't

337
00:11:15,279 --> 00:11:17,200
make mistakes in your proofs

338
00:11:17,200 --> 00:11:18,959
you can apply model checking sometimes

339
00:11:18,959 --> 00:11:21,360
and another tool that we use greatly are

340
00:11:21,360 --> 00:11:22,959
property-based tests where you

341
00:11:22,959 --> 00:11:24,320
write down properties that you could

342
00:11:24,320 --> 00:11:27,279
prove but you use the actual code and

343
00:11:27,279 --> 00:11:30,560
generate randomly test data that then um

344
00:11:30,560 --> 00:11:32,160
checks whether those properties are

345
00:11:32,160 --> 00:11:34,240
satisfied for for arbitrary input

346
00:11:34,240 --> 00:11:35,040
basically

347
00:11:35,040 --> 00:11:37,040
and the nice thing about that is that

348
00:11:37,040 --> 00:11:39,760
it's often quicker than doing proofs

349
00:11:39,760 --> 00:11:41,600
and it also is based on the actual

350
00:11:41,600 --> 00:11:42,800
implementation and not just in a

351
00:11:42,800 --> 00:11:44,480
specification and since there can be a

352
00:11:44,480 --> 00:11:45,600
gap between the

353
00:11:45,600 --> 00:11:48,480
specification and the limitation um

354
00:11:48,480 --> 00:11:49,920
checking those properties on the code

355
00:11:49,920 --> 00:11:50,800
itself

356
00:11:50,800 --> 00:11:53,200
is great and which one of those

357
00:11:53,200 --> 00:11:54,160
properties

358
00:11:54,160 --> 00:11:55,920
which one of those tools you can apply

359
00:11:55,920 --> 00:11:57,360
depends on the properties of the system

360
00:11:57,360 --> 00:11:59,600
that you are implementing for instance

361
00:11:59,600 --> 00:12:00,720
do you have determinism do you have

362
00:12:00,720 --> 00:12:02,320
concurrency what about the state space

363
00:12:02,320 --> 00:12:03,760
is it finite then it's

364
00:12:03,760 --> 00:12:05,760
great for model checking otherwise it

365
00:12:05,760 --> 00:12:07,200
might not be so great

366
00:12:07,200 --> 00:12:08,399
and so you have to look at basically

367
00:12:08,399 --> 00:12:10,000
every component that you want to build

368
00:12:10,000 --> 00:12:12,000
and answer those questions about

369
00:12:12,000 --> 00:12:13,600
what is the methodology that i want to

370
00:12:13,600 --> 00:12:16,000
use so um looking at cardano in

371
00:12:16,000 --> 00:12:18,639
particular as a cryptocurrency

372
00:12:18,639 --> 00:12:20,880
the thing looks really quite messy on

373
00:12:20,880 --> 00:12:22,240
first side because you have

374
00:12:22,240 --> 00:12:24,560
this tree structure of blocks and then

375
00:12:24,560 --> 00:12:25,279
you can

376
00:12:25,279 --> 00:12:26,560
revert blocks when you jump to a

377
00:12:26,560 --> 00:12:28,560
different fork so you only have eventual

378
00:12:28,560 --> 00:12:30,079
consistency and

379
00:12:30,079 --> 00:12:31,519
also it's a distributed system so

380
00:12:31,519 --> 00:12:32,880
different nodes might not even be an

381
00:12:32,880 --> 00:12:34,079
agreement about what the current state

382
00:12:34,079 --> 00:12:35,279
of the system is

383
00:12:35,279 --> 00:12:38,560
and that is quite hard to formulate

384
00:12:38,560 --> 00:12:40,480
on the other hand if you look at just

385
00:12:40,480 --> 00:12:41,920
the contents of the thing

386
00:12:41,920 --> 00:12:44,000
at the transaction at the transaction

387
00:12:44,000 --> 00:12:45,040
ledger

388
00:12:45,040 --> 00:12:48,000
then for any given history that is just

389
00:12:48,000 --> 00:12:48,480
a

390
00:12:48,480 --> 00:12:50,399
linear view of one transaction after the

391
00:12:50,399 --> 00:12:51,760
other and so

392
00:12:51,760 --> 00:12:53,760
one of the crucial design decisions that

393
00:12:53,760 --> 00:12:55,760
we made was to cleanly separate those

394
00:12:55,760 --> 00:12:57,360
two so we have

395
00:12:57,360 --> 00:12:59,920
modules that handle the concurrency that

396
00:12:59,920 --> 00:13:01,920
handle like the consensus part and the

397
00:13:01,920 --> 00:13:03,440
networking part

398
00:13:03,440 --> 00:13:05,839
and that is like the messy world of

399
00:13:05,839 --> 00:13:06,639
concurrency

400
00:13:06,639 --> 00:13:08,480
and distributed computing and then we

401
00:13:08,480 --> 00:13:10,480
have the actual transaction ledger

402
00:13:10,480 --> 00:13:12,959
which only ever is presented by the

403
00:13:12,959 --> 00:13:14,240
consensus layer

404
00:13:14,240 --> 00:13:16,720
one linear view of transactions so you

405
00:13:16,720 --> 00:13:18,000
can look at the the

406
00:13:18,000 --> 00:13:21,120
um at the consensus layer

407
00:13:21,120 --> 00:13:23,600
as like picking one chain and then

408
00:13:23,600 --> 00:13:25,279
presenting that one chain

409
00:13:25,279 --> 00:13:27,600
to the transaction ledger and so you

410
00:13:27,600 --> 00:13:29,200
never have when you are thinking

411
00:13:29,200 --> 00:13:30,560
when you are applying transaction you

412
00:13:30,560 --> 00:13:32,320
never have to think about

413
00:13:32,320 --> 00:13:34,160
how do i roll them back what what do i

414
00:13:34,160 --> 00:13:35,360
do there but you have that cleanly

415
00:13:35,360 --> 00:13:36,880
separated and that's something that

416
00:13:36,880 --> 00:13:37,839
wasn't there in the initial

417
00:13:37,839 --> 00:13:39,920
implementation and that

418
00:13:39,920 --> 00:13:42,480
makes this the second version much more

419
00:13:42,480 --> 00:13:43,279
much more

420
00:13:43,279 --> 00:13:46,160
easy to work with talking about the

421
00:13:46,160 --> 00:13:46,639
ledger

422
00:13:46,639 --> 00:13:49,839
um we can formulate that very nicely as

423
00:13:49,839 --> 00:13:53,199
transition rules that go from an initial

424
00:13:53,199 --> 00:13:54,079
state

425
00:13:54,079 --> 00:13:56,720
and then do some modification to that

426
00:13:56,720 --> 00:13:58,560
state for example applying a transaction

427
00:13:58,560 --> 00:13:59,360
which basically

428
00:13:59,360 --> 00:14:02,639
tells us to take the state of the system

429
00:14:02,639 --> 00:14:05,040
remove some from the inputs of that

430
00:14:05,040 --> 00:14:06,880
transaction so some piles of money that

431
00:14:06,880 --> 00:14:08,320
are spent by the transaction

432
00:14:08,320 --> 00:14:10,079
and add some some new piles of money

433
00:14:10,079 --> 00:14:12,079
some new outputs from that transaction

434
00:14:12,079 --> 00:14:14,399
and then above that that bar we have all

435
00:14:14,399 --> 00:14:16,560
the rules that must be satisfied

436
00:14:16,560 --> 00:14:17,680
in order for that transaction to be

437
00:14:17,680 --> 00:14:19,199
valid in the first place so the

438
00:14:19,199 --> 00:14:20,720
transaction inputs that the transaction

439
00:14:20,720 --> 00:14:22,079
uses need to exist

440
00:14:22,079 --> 00:14:24,079
in the initial state the transition

441
00:14:24,079 --> 00:14:25,760
needs to be balanced overall and you

442
00:14:25,760 --> 00:14:26,800
need to have some

443
00:14:26,800 --> 00:14:28,839
some fee that has to be larger than

444
00:14:28,839 --> 00:14:30,720
threshold and

445
00:14:30,720 --> 00:14:33,920
formulating it in in such a way

446
00:14:33,920 --> 00:14:37,839
is possible because we only have one

447
00:14:37,839 --> 00:14:39,440
one state of the system that that

448
00:14:39,440 --> 00:14:41,279
progresses through a fixed

449
00:14:41,279 --> 00:14:43,839
series of state transitions and we don't

450
00:14:43,839 --> 00:14:44,399
have to

451
00:14:44,399 --> 00:14:46,079
yeah we don't have different different

452
00:14:46,079 --> 00:14:47,279
threads that might have a different view

453
00:14:47,279 --> 00:14:48,399
on that but it's just

454
00:14:48,399 --> 00:14:51,839
a single state that um performs some

455
00:14:51,839 --> 00:14:53,440
transitions

456
00:14:53,440 --> 00:14:55,360
and it's very nice because it's

457
00:14:55,360 --> 00:14:57,120
ambiguous and concise

458
00:14:57,120 --> 00:14:59,839
and precise language to to formulate

459
00:14:59,839 --> 00:15:00,880
these things and

460
00:15:00,880 --> 00:15:03,440
um if once once you are clear about

461
00:15:03,440 --> 00:15:04,560
those rules

462
00:15:04,560 --> 00:15:07,279
implementing them is is not that hard so

463
00:15:07,279 --> 00:15:08,800
below is the actual implementation

464
00:15:08,800 --> 00:15:09,440
haskell

465
00:15:09,440 --> 00:15:13,199
and if you look at that um in in some

466
00:15:13,199 --> 00:15:14,720
as you take some time to look at that

467
00:15:14,720 --> 00:15:16,800
you see that it's just a basic

468
00:15:16,800 --> 00:15:18,639
a very verbatim translation so here you

469
00:15:18,639 --> 00:15:20,959
have this is a subset of the current

470
00:15:20,959 --> 00:15:22,800
utxo that's basically that's that

471
00:15:22,800 --> 00:15:25,279
condition here and so then you have this

472
00:15:25,279 --> 00:15:26,959
this transaction this transition here

473
00:15:26,959 --> 00:15:28,560
it's it's exactly the same what is below

474
00:15:28,560 --> 00:15:30,240
that bar you have the utxo

475
00:15:30,240 --> 00:15:31,360
you remove the inputs from the

476
00:15:31,360 --> 00:15:32,639
transaction you add the outputs from the

477
00:15:32,639 --> 00:15:33,360
transaction

478
00:15:33,360 --> 00:15:35,519
and that's that so that's a very nice

479
00:15:35,519 --> 00:15:36,480
way of

480
00:15:36,480 --> 00:15:39,360
writing a system once you have written

481
00:15:39,360 --> 00:15:40,480
it in that way

482
00:15:40,480 --> 00:15:43,360
um you need to make sure that not only

483
00:15:43,360 --> 00:15:43,759
does

484
00:15:43,759 --> 00:15:46,480
that that implementation which is just

485
00:15:46,480 --> 00:15:46,959
another

486
00:15:46,959 --> 00:15:48,880
we call an executable specification

487
00:15:48,880 --> 00:15:50,079
because it is

488
00:15:50,079 --> 00:15:52,480
is that it has the the the same contents

489
00:15:52,480 --> 00:15:54,160
as the specification that we have as a

490
00:15:54,160 --> 00:15:56,079
logic document to talk about and reason

491
00:15:56,079 --> 00:15:56,720
about

492
00:15:56,720 --> 00:15:58,560
but it's executable and it's the basis

493
00:15:58,560 --> 00:16:00,320
for the implementation

494
00:16:00,320 --> 00:16:02,880
but you need to make sure that this

495
00:16:02,880 --> 00:16:04,240
executable specification

496
00:16:04,240 --> 00:16:06,639
and without the implementation itself

497
00:16:06,639 --> 00:16:07,440
that

498
00:16:07,440 --> 00:16:10,320
is defined by like the small steps the

499
00:16:10,320 --> 00:16:11,279
microscopic

500
00:16:11,279 --> 00:16:13,120
transitions that the system can do

501
00:16:13,120 --> 00:16:14,880
actually fulfills all the macroscopic

502
00:16:14,880 --> 00:16:16,480
properties that you want

503
00:16:16,480 --> 00:16:18,560
so that those are things like uh

504
00:16:18,560 --> 00:16:20,160
macroscopic properties are something

505
00:16:20,160 --> 00:16:20,720
like

506
00:16:20,720 --> 00:16:22,880
the money in the system is preserve is

507
00:16:22,880 --> 00:16:24,639
conserved when we apply transactions to

508
00:16:24,639 --> 00:16:26,320
the system

509
00:16:26,320 --> 00:16:27,920
and the way that you ensure that that is

510
00:16:27,920 --> 00:16:29,360
the case is that you

511
00:16:29,360 --> 00:16:32,160
formalize those properties and then you

512
00:16:32,160 --> 00:16:32,720
can

513
00:16:32,720 --> 00:16:35,120
use the quickjack library which is this

514
00:16:35,120 --> 00:16:36,880
property-based testing framework that

515
00:16:36,880 --> 00:16:39,120
generates randomized test data

516
00:16:39,120 --> 00:16:41,440
and then makes sure that for that that

517
00:16:41,440 --> 00:16:42,959
randomized test data

518
00:16:42,959 --> 00:16:45,600
those properties are fulfilled and you

519
00:16:45,600 --> 00:16:46,399
can also

520
00:16:46,399 --> 00:16:47,839
go ahead and prove them based on the

521
00:16:47,839 --> 00:16:49,440
formalization and for the ledger we

522
00:16:49,440 --> 00:16:50,160
could

523
00:16:50,160 --> 00:16:52,160
do both which is very nice because the

524
00:16:52,160 --> 00:16:53,759
proofs are of course

525
00:16:53,759 --> 00:16:56,399
exhaustive and the property-based tests

526
00:16:56,399 --> 00:16:58,880
are tied to the implementation itself

527
00:16:58,880 --> 00:17:02,240
when we go to the consensus part

528
00:17:02,240 --> 00:17:04,000
things are a bit messier so you can't do

529
00:17:04,000 --> 00:17:05,599
this this very nice and

530
00:17:05,599 --> 00:17:07,439
clear style of things and that is

531
00:17:07,439 --> 00:17:09,039
something that duncan will tell us about

532
00:17:09,039 --> 00:17:09,599
now

533
00:17:09,599 --> 00:17:12,400
thank you very much the environment in

534
00:17:12,400 --> 00:17:14,079
which consensus operates is messy

535
00:17:14,079 --> 00:17:16,240
because it is fundamentally concurrent

536
00:17:16,240 --> 00:17:18,480
and concurrency is hard both in practice

537
00:17:18,480 --> 00:17:19,599
and in theory

538
00:17:19,599 --> 00:17:21,359
so when we were thinking about the

539
00:17:21,359 --> 00:17:23,039
design of our new consensus

540
00:17:23,039 --> 00:17:23,919
implementation

541
00:17:23,919 --> 00:17:25,760
we had to think very carefully about

542
00:17:25,760 --> 00:17:28,240
what kind of formalisms or

543
00:17:28,240 --> 00:17:30,880
semi-formal techniques we ought to use

544
00:17:30,880 --> 00:17:32,880
to to give us that balance between

545
00:17:32,880 --> 00:17:35,200
correctness which is really what ensures

546
00:17:35,200 --> 00:17:36,240
security

547
00:17:36,240 --> 00:17:39,280
and uh speed of of development

548
00:17:39,280 --> 00:17:41,760
so is it while it is absolutely possible

549
00:17:41,760 --> 00:17:42,400
to take

550
00:17:42,400 --> 00:17:44,160
a fully formal approach to concurrency

551
00:17:44,160 --> 00:17:45,520
fully mathematically formal

552
00:17:45,520 --> 00:17:48,799
approach it is just harder than

553
00:17:48,799 --> 00:17:51,039
a more mathematically tractable problem

554
00:17:51,039 --> 00:17:52,720
like the the ledger

555
00:17:52,720 --> 00:17:55,200
so the approach we decided to take was

556
00:17:55,200 --> 00:17:56,799
advanced testing techniques

557
00:17:56,799 --> 00:17:58,880
including property-based testing with

558
00:17:58,880 --> 00:18:01,919
deterministic concurrency simulation

559
00:18:01,919 --> 00:18:04,000
and also making use of advanced type

560
00:18:04,000 --> 00:18:05,679
system features to enforce

561
00:18:05,679 --> 00:18:07,760
invariants and then as a completely

562
00:18:07,760 --> 00:18:09,520
separate parallel project

563
00:18:09,520 --> 00:18:12,000
we decided to investigate the the

564
00:18:12,000 --> 00:18:13,280
completely formal approach

565
00:18:13,280 --> 00:18:16,559
and try to make use of results later on

566
00:18:16,559 --> 00:18:18,000
the approach we took to test in the

567
00:18:18,000 --> 00:18:19,679
consensus implementation was to write it

568
00:18:19,679 --> 00:18:20,480
in such a way

569
00:18:20,480 --> 00:18:22,720
that we could run the exact same code

570
00:18:22,720 --> 00:18:24,320
both in production for real

571
00:18:24,320 --> 00:18:26,720
and also in a deterministic concurrency

572
00:18:26,720 --> 00:18:27,600
simulator

573
00:18:27,600 --> 00:18:29,520
and that means that we can write

574
00:18:29,520 --> 00:18:31,679
properties about the concurrent code

575
00:18:31,679 --> 00:18:34,559
which observe the trace of the execution

576
00:18:34,559 --> 00:18:35,679
of the code

577
00:18:35,679 --> 00:18:38,240
and observe interesting events and they

578
00:18:38,240 --> 00:18:38,799
can

579
00:18:38,799 --> 00:18:41,200
write properties that determine that

580
00:18:41,200 --> 00:18:42,240
that can say

581
00:18:42,240 --> 00:18:43,919
whether or not that is a reasonable or

582
00:18:43,919 --> 00:18:46,240
an unreasonable execution of the program

583
00:18:46,240 --> 00:18:47,440
and the way we do that is a simple

584
00:18:47,440 --> 00:18:49,520
mocking technique where we capture

585
00:18:49,520 --> 00:18:51,919
all of the concurrency primitives uh so

586
00:18:51,919 --> 00:18:52,880
application codes

587
00:18:52,880 --> 00:18:54,320
are using concurrency printers such as

588
00:18:54,320 --> 00:18:55,679
you know read queue as in this example

589
00:18:55,679 --> 00:18:56,080
here

590
00:18:56,080 --> 00:18:57,760
it's captured in interface and there's

591
00:18:57,760 --> 00:18:59,360
two implementations of it one

592
00:18:59,360 --> 00:19:02,080
you know the real the real production

593
00:19:02,080 --> 00:19:02,799
version

594
00:19:02,799 --> 00:19:04,480
and a version that runs within the

595
00:19:04,480 --> 00:19:05,919
simulation

596
00:19:05,919 --> 00:19:07,679
and this means that we can use these

597
00:19:07,679 --> 00:19:09,360
property based testing techniques

598
00:19:09,360 --> 00:19:11,200
writing properties about concurrent code

599
00:19:11,200 --> 00:19:13,440
that looks at the trace of execution

600
00:19:13,440 --> 00:19:16,080
and because it's deterministic we get

601
00:19:16,080 --> 00:19:17,360
the brilliant property that these things

602
00:19:17,360 --> 00:19:18,720
are reproducible

603
00:19:18,720 --> 00:19:20,640
and we can shrink to minimal counter

604
00:19:20,640 --> 00:19:22,799
examples which is a fantastic

605
00:19:22,799 --> 00:19:26,000
technique for really understanding

606
00:19:26,000 --> 00:19:28,640
a complicated failure reducing it down

607
00:19:28,640 --> 00:19:29,280
to its

608
00:19:29,280 --> 00:19:31,760
smallest possible example and that very

609
00:19:31,760 --> 00:19:33,679
often shows up what the problem is

610
00:19:33,679 --> 00:19:35,520
straight away one of the other

611
00:19:35,520 --> 00:19:37,280
lightweight fall methods we've used is

612
00:19:37,280 --> 00:19:39,120
to design our application level network

613
00:19:39,120 --> 00:19:39,919
protocols

614
00:19:39,919 --> 00:19:42,240
as very simple state machines state

615
00:19:42,240 --> 00:19:43,760
machines with the property

616
00:19:43,760 --> 00:19:47,039
that in each state there is exactly

617
00:19:47,039 --> 00:19:50,240
one sender and one receiver so only one

618
00:19:50,240 --> 00:19:52,240
peer has agency at once

619
00:19:52,240 --> 00:19:54,320
and this means that we can guarantee

620
00:19:54,320 --> 00:19:55,520
freedom from deadlock

621
00:19:55,520 --> 00:19:57,919
and freedom from race conditions and

622
00:19:57,919 --> 00:19:59,200
we're able to enforce

623
00:19:59,200 --> 00:20:00,960
this property and make sure that we

624
00:20:00,960 --> 00:20:02,720
don't make mistakes

625
00:20:02,720 --> 00:20:05,600
with this property by enforcing this

626
00:20:05,600 --> 00:20:07,440
using the haskell type system

627
00:20:07,440 --> 00:20:08,880
which means that violations are

628
00:20:08,880 --> 00:20:11,039
prevented at compile time

629
00:20:11,039 --> 00:20:13,200
so here's an example of one of the real

630
00:20:13,200 --> 00:20:14,080
protocols

631
00:20:14,080 --> 00:20:15,679
and as you see it fits on one slide it's

632
00:20:15,679 --> 00:20:17,120
really very simple

633
00:20:17,120 --> 00:20:20,559
and we have a number of simple protocols

634
00:20:20,559 --> 00:20:22,240
and we multiplex all of them over a

635
00:20:22,240 --> 00:20:24,880
single tcp connection

636
00:20:24,880 --> 00:20:26,159
now i mentioned that we've taken two

637
00:20:26,159 --> 00:20:27,760
approaches in parallel in parallel to

638
00:20:27,760 --> 00:20:28,559
the existing

639
00:20:28,559 --> 00:20:31,520
development effort we've done an r d

640
00:20:31,520 --> 00:20:32,880
parallel project

641
00:20:32,880 --> 00:20:35,120
to investigate a completely formal

642
00:20:35,120 --> 00:20:36,880
approach to the consensus

643
00:20:36,880 --> 00:20:39,840
concurrency difficulties and i want to

644
00:20:39,840 --> 00:20:40,960
mention briefly

645
00:20:40,960 --> 00:20:43,280
about that project we hope to

646
00:20:43,280 --> 00:20:44,159
incorporate the

647
00:20:44,159 --> 00:20:47,360
the fruits of that project later

648
00:20:47,360 --> 00:20:50,080
the goal is to establish some kind of

649
00:20:50,080 --> 00:20:51,679
equivalence between the high and low

650
00:20:51,679 --> 00:20:52,240
level

651
00:20:52,240 --> 00:20:54,159
designs so the high level design is

652
00:20:54,159 --> 00:20:55,600
exactly as in the paper

653
00:20:55,600 --> 00:20:59,360
exactly figure two in in the paper

654
00:20:59,360 --> 00:21:01,280
and the low level design is a design

655
00:21:01,280 --> 00:21:02,799
that corresponds to you know the real

656
00:21:02,799 --> 00:21:03,760
design that we

657
00:21:03,760 --> 00:21:05,760
that we have come up with and it has to

658
00:21:05,760 --> 00:21:06,960
be a practical design

659
00:21:06,960 --> 00:21:09,200
it has to work in the way that real

660
00:21:09,200 --> 00:21:10,000
networks

661
00:21:10,000 --> 00:21:12,080
really work and crucially it has to

662
00:21:12,080 --> 00:21:14,559
operate in bounded resources

663
00:21:14,559 --> 00:21:17,760
now we don't want to try to establish an

664
00:21:17,760 --> 00:21:19,120
equivalence between

665
00:21:19,120 --> 00:21:21,200
two very different things uh because

666
00:21:21,200 --> 00:21:22,240
that's very difficult

667
00:21:22,240 --> 00:21:23,840
uh you know very a low level design and

668
00:21:23,840 --> 00:21:26,559
a high level design in a monolithic way

669
00:21:26,559 --> 00:21:28,720
that kind of proof is is very hard so

670
00:21:28,720 --> 00:21:30,799
instead we take a modular approach to

671
00:21:30,799 --> 00:21:31,520
the design

672
00:21:31,520 --> 00:21:33,520
and a modular approach to the proof and

673
00:21:33,520 --> 00:21:35,120
these two correspond to each other

674
00:21:35,120 --> 00:21:36,799
so the idea is that we do a series of

675
00:21:36,799 --> 00:21:38,799
design refinements to get us from the

676
00:21:38,799 --> 00:21:40,159
high-level design to the low-level

677
00:21:40,159 --> 00:21:40,960
design

678
00:21:40,960 --> 00:21:42,320
and then the proof is structured in

679
00:21:42,320 --> 00:21:45,039
exactly the same way as a series of

680
00:21:45,039 --> 00:21:46,960
equivalence proofs of an appropriate

681
00:21:46,960 --> 00:21:48,159
notion of equivalence

682
00:21:48,159 --> 00:21:49,760
and these the intention is that these

683
00:21:49,760 --> 00:21:51,760
should be fully machine-checked

684
00:21:51,760 --> 00:21:54,480
formal proofs so the results that we

685
00:21:54,480 --> 00:21:55,360
have

686
00:21:55,360 --> 00:21:59,440
so far is that we have um uh developed a

687
00:21:59,440 --> 00:22:01,120
an asynchronous version of a process

688
00:22:01,120 --> 00:22:02,880
calculus heavily inspired by the

689
00:22:02,880 --> 00:22:05,280
the classic uh pi calculus we've done

690
00:22:05,280 --> 00:22:06,640
that using the isabel

691
00:22:06,640 --> 00:22:08,640
theorem prover we've proved all the

692
00:22:08,640 --> 00:22:09,679
usual properties that you would want

693
00:22:09,679 --> 00:22:11,200
about a process calculus

694
00:22:11,200 --> 00:22:13,919
and we've very nicely we've made a nice

695
00:22:13,919 --> 00:22:15,360
framework within this process calculus

696
00:22:15,360 --> 00:22:16,400
within isabel

697
00:22:16,400 --> 00:22:18,880
for establishing by similarity results

698
00:22:18,880 --> 00:22:20,559
which is the main kind of

699
00:22:20,559 --> 00:22:22,960
equivalence that we are interested in or

700
00:22:22,960 --> 00:22:23,919
at least they're always

701
00:22:23,919 --> 00:22:25,520
they're typically based on uh by

702
00:22:25,520 --> 00:22:27,679
similarity and

703
00:22:27,679 --> 00:22:29,440
in addition to that and that is honestly

704
00:22:29,440 --> 00:22:31,120
the substantial chunk of the work is

705
00:22:31,120 --> 00:22:32,720
simply developed in the process calculus

706
00:22:32,720 --> 00:22:35,120
we've also formalized uh initial

707
00:22:35,120 --> 00:22:36,320
versions of the

708
00:22:36,320 --> 00:22:39,760
um auroboros bft and preos as described

709
00:22:39,760 --> 00:22:40,960
in the papers so those are those

710
00:22:40,960 --> 00:22:43,120
high-level versions

711
00:22:43,120 --> 00:22:46,080
and we've done a proof about one of the

712
00:22:46,080 --> 00:22:47,600
first design refinements

713
00:22:47,600 --> 00:22:49,360
which is showing the equivalence of

714
00:22:49,360 --> 00:22:51,360
message broadcast which is what is used

715
00:22:51,360 --> 00:22:54,880
in the auroboris algorithm descriptions

716
00:22:54,880 --> 00:22:58,000
uh equivalence with relaying over over a

717
00:22:58,000 --> 00:22:58,960
network

718
00:22:58,960 --> 00:23:01,360
and we've also proved another result

719
00:23:01,360 --> 00:23:03,600
about bulk versus incremental

720
00:23:03,600 --> 00:23:06,880
chain selection so in this example we

721
00:23:06,880 --> 00:23:08,000
wanted to prove the

722
00:23:08,000 --> 00:23:09,679
correctness of this design refinement

723
00:23:09,679 --> 00:23:10,960
the refinement that goes from message

724
00:23:10,960 --> 00:23:11,760
broadcast

725
00:23:11,760 --> 00:23:14,080
to message relay over a directed graph

726
00:23:14,080 --> 00:23:15,600
so on the left hand side we have

727
00:23:15,600 --> 00:23:17,679
um four nodes communicating virus

728
00:23:17,679 --> 00:23:18,960
central broadcast channel

729
00:23:18,960 --> 00:23:21,440
in this example and this is asynchronous

730
00:23:21,440 --> 00:23:22,960
with loss and duplication

731
00:23:22,960 --> 00:23:24,880
on the right-hand side we have four

732
00:23:24,880 --> 00:23:26,720
nodes connected via a graph

733
00:23:26,720 --> 00:23:28,400
which is connected but not fully

734
00:23:28,400 --> 00:23:30,159
connected

735
00:23:30,159 --> 00:23:32,400
and we've been able to prove uh that

736
00:23:32,400 --> 00:23:33,440
these two are

737
00:23:33,440 --> 00:23:35,120
bisimilar now these have this nice

738
00:23:35,120 --> 00:23:36,880
graphical uh notation here but they

739
00:23:36,880 --> 00:23:38,400
correspond to

740
00:23:38,400 --> 00:23:40,240
precise statements precise descriptions

741
00:23:40,240 --> 00:23:41,760
uh within the process calculus

742
00:23:41,760 --> 00:23:44,640
now it's actually equivalence with a a

743
00:23:44,640 --> 00:23:45,600
little interesting

744
00:23:45,600 --> 00:23:48,000
uh wrinkle and in fact doing the proof

745
00:23:48,000 --> 00:23:49,600
you know showed up that wrinkle

746
00:23:49,600 --> 00:23:51,760
um and it is is this is the kind of

747
00:23:51,760 --> 00:23:53,360
reason why we want to do these kinds of

748
00:23:53,360 --> 00:23:54,400
proofs to see

749
00:23:54,400 --> 00:23:56,480
if there are you know additional things

750
00:23:56,480 --> 00:23:58,400
that you know slip by when you first

751
00:23:58,400 --> 00:23:59,360
think about it

752
00:23:59,360 --> 00:24:01,679
and so intuition and proof are not the

753
00:24:01,679 --> 00:24:02,640
same thing

754
00:24:02,640 --> 00:24:05,679
so in this example um it turns out that

755
00:24:05,679 --> 00:24:08,080
um if you send if you relay a message

756
00:24:08,080 --> 00:24:09,760
from a to b to c

757
00:24:09,760 --> 00:24:11,840
and it arrives at c so there wasn't it

758
00:24:11,840 --> 00:24:13,120
it happened the case that

759
00:24:13,120 --> 00:24:15,440
there was no last in that case then we

760
00:24:15,440 --> 00:24:16,240
actually know

761
00:24:16,240 --> 00:24:18,000
we can infer that it did in fact arrive

762
00:24:18,000 --> 00:24:20,159
at b whereas you cannot infer that

763
00:24:20,159 --> 00:24:22,960
uh in in the case of uh perfect message

764
00:24:22,960 --> 00:24:24,559
broadcast in that case all the failures

765
00:24:24,559 --> 00:24:25,120
are

766
00:24:25,120 --> 00:24:27,760
uh are independent so we're able to

767
00:24:27,760 --> 00:24:29,279
insert additional loss

768
00:24:29,279 --> 00:24:31,120
into the relay case and then we can show

769
00:24:31,120 --> 00:24:33,679
that they are by similar

770
00:24:33,679 --> 00:24:35,440
so let's take a step back and look at

771
00:24:35,440 --> 00:24:37,120
how are we connecting our papers

772
00:24:37,120 --> 00:24:38,559
with the code that's running on the real

773
00:24:38,559 --> 00:24:40,240
system how do we connect

774
00:24:40,240 --> 00:24:43,279
our intention with you know the real

775
00:24:43,279 --> 00:24:45,440
code that that is running

776
00:24:45,440 --> 00:24:47,760
so it's worth noting that we've taken a

777
00:24:47,760 --> 00:24:48,559
selective

778
00:24:48,559 --> 00:24:51,120
sparing approach to to where we apply

779
00:24:51,120 --> 00:24:52,720
formal and semi-formal

780
00:24:52,720 --> 00:24:55,039
methods and that's really been focused

781
00:24:55,039 --> 00:24:56,000
in the ledger rules

782
00:24:56,000 --> 00:24:57,760
and the consensus where there's really

783
00:24:57,760 --> 00:24:59,440
greatest scope for

784
00:24:59,440 --> 00:25:02,320
expensive mistakes so starting with the

785
00:25:02,320 --> 00:25:03,120
ledger rules

786
00:25:03,120 --> 00:25:05,120
as philip was describing earlier we we

787
00:25:05,120 --> 00:25:06,480
started with

788
00:25:06,480 --> 00:25:09,520
the papers for example the reward scheme

789
00:25:09,520 --> 00:25:11,600
other internal technical reports and

790
00:25:11,600 --> 00:25:13,200
other business requirements

791
00:25:13,200 --> 00:25:15,600
about what a cryptocurrency ledger ought

792
00:25:15,600 --> 00:25:17,760
to be or to be like

793
00:25:17,760 --> 00:25:19,919
and that informed our design of the

794
00:25:19,919 --> 00:25:21,120
formal ledger rules

795
00:25:21,120 --> 00:25:25,440
as philip explained earlier the the pdf

796
00:25:25,440 --> 00:25:28,320
set theory nicely explained presented

797
00:25:28,320 --> 00:25:30,159
description of those rules

798
00:25:30,159 --> 00:25:31,840
and then we establish the connection

799
00:25:31,840 --> 00:25:33,840
between those rules and the

800
00:25:33,840 --> 00:25:36,240
executable version which is really the

801
00:25:36,240 --> 00:25:37,279
thing that's really running on the

802
00:25:37,279 --> 00:25:38,080
system

803
00:25:38,080 --> 00:25:41,440
by careful audit and by checking

804
00:25:41,440 --> 00:25:43,039
the the properties using those

805
00:25:43,039 --> 00:25:45,200
properties as tests on the executable

806
00:25:45,200 --> 00:25:46,400
version of those ledger rules

807
00:25:46,400 --> 00:25:47,919
so that establishes a very strong

808
00:25:47,919 --> 00:25:50,159
connection between what we have intended

809
00:25:50,159 --> 00:25:52,400
in the formal ledger rules and what is

810
00:25:52,400 --> 00:25:53,440
actually running

811
00:25:53,440 --> 00:25:55,440
so the formal ledger rules are the

812
00:25:55,440 --> 00:25:57,520
canonical description of what the system

813
00:25:57,520 --> 00:26:00,640
does informed by the papers but

814
00:26:00,640 --> 00:26:01,600
obviously there's not a

815
00:26:01,600 --> 00:26:03,679
completely formal connection between the

816
00:26:03,679 --> 00:26:05,039
papers and the ledger rules the ledger

817
00:26:05,039 --> 00:26:06,400
rules as described

818
00:26:06,400 --> 00:26:08,480
are the informal description of the

819
00:26:08,480 --> 00:26:09,760
system

820
00:26:09,760 --> 00:26:11,440
then the other side with the consensus

821
00:26:11,440 --> 00:26:13,039
obviously our starting point there is

822
00:26:13,039 --> 00:26:15,840
the oroboros papers and those inform

823
00:26:15,840 --> 00:26:17,360
both the design of our consensus

824
00:26:17,360 --> 00:26:18,400
implementation

825
00:26:18,400 --> 00:26:20,159
and crucially they tell us what

826
00:26:20,159 --> 00:26:21,440
properties to test

827
00:26:21,440 --> 00:26:23,520
and what environment do we test them in

828
00:26:23,520 --> 00:26:25,600
and by environment i mean

829
00:26:25,600 --> 00:26:28,640
failures adversarial behavior etc

830
00:26:28,640 --> 00:26:30,320
um in particular you know we can

831
00:26:30,320 --> 00:26:31,679
construct environments

832
00:26:31,679 --> 00:26:34,400
uh that are so extreme that consensus is

833
00:26:34,400 --> 00:26:35,840
impossible

834
00:26:35,840 --> 00:26:38,480
and or and we need to be able to test

835
00:26:38,480 --> 00:26:40,000
and know whether or not

836
00:26:40,000 --> 00:26:42,080
uh consensus should be achieved so that

837
00:26:42,080 --> 00:26:43,760
we can check uh the property that

838
00:26:43,760 --> 00:26:45,760
is in fact is and that's exactly what we

839
00:26:45,760 --> 00:26:46,960
do the

840
00:26:46,960 --> 00:26:48,960
we we take our real implementation which

841
00:26:48,960 --> 00:26:50,720
we can run in reality and

842
00:26:50,720 --> 00:26:52,960
in simulation as i described earlier and

843
00:26:52,960 --> 00:26:53,840
we apply this

844
00:26:53,840 --> 00:26:56,000
you know systematic randomized property

845
00:26:56,000 --> 00:26:57,120
testing approach

846
00:26:57,120 --> 00:26:58,960
and one of the main properties is you

847
00:26:58,960 --> 00:27:00,640
know do we achieve consensus when we

848
00:27:00,640 --> 00:27:01,520
expect to

849
00:27:01,520 --> 00:27:03,440
and which we know from the environment

850
00:27:03,440 --> 00:27:05,360
that we can construct

851
00:27:05,360 --> 00:27:07,200
you know where we insert delays where we

852
00:27:07,200 --> 00:27:08,880
insert failures etc

853
00:27:08,880 --> 00:27:11,520
and so that tells us you know if we run

854
00:27:11,520 --> 00:27:13,200
it in an environment where a consensus

855
00:27:13,200 --> 00:27:14,640
was expected

856
00:27:14,640 --> 00:27:16,400
did we actually achieve consensus and

857
00:27:16,400 --> 00:27:18,640
that's the main property that

858
00:27:18,640 --> 00:27:20,240
that gives us assurance that our

859
00:27:20,240 --> 00:27:21,919
consensus implementation does what we

860
00:27:21,919 --> 00:27:25,200
think it does so

861
00:27:25,200 --> 00:27:27,200
that's the big picture we have quite

862
00:27:27,200 --> 00:27:29,760
strong but not completely formal

863
00:27:29,760 --> 00:27:31,760
but yet really quite good evidence quite

864
00:27:31,760 --> 00:27:32,880
strong evidence

865
00:27:32,880 --> 00:27:35,200
that connects our intention through to

866
00:27:35,200 --> 00:27:36,720
the real running

867
00:27:36,720 --> 00:27:38,960
code in the system in the remainder of

868
00:27:38,960 --> 00:27:40,159
this talk i want to

869
00:27:40,159 --> 00:27:42,159
present to you things that could go

870
00:27:42,159 --> 00:27:43,919
wrong in such an endeavor

871
00:27:43,919 --> 00:27:45,360
and that includes things that you need

872
00:27:45,360 --> 00:27:47,039
to be aware of when actually

873
00:27:47,039 --> 00:27:50,159
doing the design things like certain

874
00:27:50,159 --> 00:27:51,520
edge cases that we found with

875
00:27:51,520 --> 00:27:52,799
property-based tests

876
00:27:52,799 --> 00:27:54,480
and also operational concerns when

877
00:27:54,480 --> 00:27:56,720
dealing with a decentralized system

878
00:27:56,720 --> 00:27:58,880
so first let me show you an example of

879
00:27:58,880 --> 00:28:01,279
quite a subtle bug that we found with

880
00:28:01,279 --> 00:28:03,360
property-based tests in order to

881
00:28:03,360 --> 00:28:04,640
understand that example

882
00:28:04,640 --> 00:28:07,600
uh you need to know that in order to

883
00:28:07,600 --> 00:28:09,600
operate in a decentralized manner in an

884
00:28:09,600 --> 00:28:11,120
open network where everybody can

885
00:28:11,120 --> 00:28:13,679
post things and send you data but where

886
00:28:13,679 --> 00:28:15,200
you have limited resources we need to do

887
00:28:15,200 --> 00:28:16,640
aggressive filtering of the incoming

888
00:28:16,640 --> 00:28:18,320
data in order not to be overwhelmed

889
00:28:18,320 --> 00:28:20,480
in a denial of service attack and so one

890
00:28:20,480 --> 00:28:22,000
of the things that we do in cardano is

891
00:28:22,000 --> 00:28:22,559
that we

892
00:28:22,559 --> 00:28:25,200
try to select the chain based only on

893
00:28:25,200 --> 00:28:27,039
block headers before downloading any

894
00:28:27,039 --> 00:28:28,240
actual block data

895
00:28:28,240 --> 00:28:30,960
and we can do that because um each block

896
00:28:30,960 --> 00:28:32,559
header contains a signature

897
00:28:32,559 --> 00:28:35,440
and we can check that signature and can

898
00:28:35,440 --> 00:28:36,960
check whether the owner of that key is

899
00:28:36,960 --> 00:28:38,960
actually eligible to produce a block

900
00:28:38,960 --> 00:28:40,799
based on the stake that they have and

901
00:28:40,799 --> 00:28:42,880
that's take a static for some period of

902
00:28:42,880 --> 00:28:43,600
time for

903
00:28:43,600 --> 00:28:46,159
an epoch and so we have that forecast

904
00:28:46,159 --> 00:28:47,840
range we know the ledger state at some

905
00:28:47,840 --> 00:28:48,480
point

906
00:28:48,480 --> 00:28:50,399
then we can say for any block within

907
00:28:50,399 --> 00:28:52,000
that range we know that

908
00:28:52,000 --> 00:28:53,919
we know the stake distribution and so we

909
00:28:53,919 --> 00:28:55,440
can check the headers

910
00:28:55,440 --> 00:28:58,080
now what can happen if if we are in a

911
00:28:58,080 --> 00:28:59,919
bad situation where block production for

912
00:28:59,919 --> 00:29:01,360
some reason or another

913
00:29:01,360 --> 00:29:03,679
holds for for a longer time that we get

914
00:29:03,679 --> 00:29:06,559
a block outside of that forecast range

915
00:29:06,559 --> 00:29:08,720
now in this in this case here where that

916
00:29:08,720 --> 00:29:09,600
block directly

917
00:29:09,600 --> 00:29:12,000
um attaches to to the to the block that

918
00:29:12,000 --> 00:29:13,520
we currently have

919
00:29:13,520 --> 00:29:14,880
that's not a problem because we know

920
00:29:14,880 --> 00:29:16,080
that there's no block in between that

921
00:29:16,080 --> 00:29:17,760
could change the stake distribution

922
00:29:17,760 --> 00:29:19,279
and so we can just use the current stake

923
00:29:19,279 --> 00:29:21,279
distribution but in a more complicated

924
00:29:21,279 --> 00:29:22,080
setting where we

925
00:29:22,080 --> 00:29:23,840
have a block that's not connecting to

926
00:29:23,840 --> 00:29:25,840
our current tip but to the forks of

927
00:29:25,840 --> 00:29:26,799
earlier

928
00:29:26,799 --> 00:29:28,640
we might have to download an earlier

929
00:29:28,640 --> 00:29:30,559
block in that fork

930
00:29:30,559 --> 00:29:32,799
in order to know the stake distribution

931
00:29:32,799 --> 00:29:34,799
that determines whether

932
00:29:34,799 --> 00:29:36,399
who has the rights to to produce their

933
00:29:36,399 --> 00:29:38,000
block in order to check the header so in

934
00:29:38,000 --> 00:29:39,679
that situation we would need to

935
00:29:39,679 --> 00:29:41,760
download another block in order to

936
00:29:41,760 --> 00:29:42,799
change whether a

937
00:29:42,799 --> 00:29:45,039
potential chain is valid or not and

938
00:29:45,039 --> 00:29:47,679
whether we want to switch to that

939
00:29:47,679 --> 00:29:50,559
so the proposal that we had for this is

940
00:29:50,559 --> 00:29:50,880
to

941
00:29:50,880 --> 00:29:53,200
only do that only download actual block

942
00:29:53,200 --> 00:29:54,880
data before deciding on which chain to

943
00:29:54,880 --> 00:29:55,520
follow

944
00:29:55,520 --> 00:29:58,399
if there was no other way to continue

945
00:29:58,399 --> 00:30:00,240
following any of the chain alternatives

946
00:30:00,240 --> 00:30:02,399
that we are presented by our peers

947
00:30:02,399 --> 00:30:04,320
and that's what we implemented but then

948
00:30:04,320 --> 00:30:06,159
we saw that our property-based tests

949
00:30:06,159 --> 00:30:07,039
showed us that

950
00:30:07,039 --> 00:30:08,880
we had disagreement between the nodes on

951
00:30:08,880 --> 00:30:11,679
what the actual best chain was

952
00:30:11,679 --> 00:30:14,240
and the thing to notice here is that we

953
00:30:14,240 --> 00:30:14,880
didn't

954
00:30:14,880 --> 00:30:17,840
write a unit test for specifically um to

955
00:30:17,840 --> 00:30:19,679
see whether that worked but we had just

956
00:30:19,679 --> 00:30:22,159
general tests that produced different

957
00:30:22,159 --> 00:30:23,760
chains and sent them across the network

958
00:30:23,760 --> 00:30:24,159
and then

959
00:30:24,159 --> 00:30:25,919
saw whether the nodes would converge on

960
00:30:25,919 --> 00:30:28,399
one view of the truth or not

961
00:30:28,399 --> 00:30:31,919
and then those tests failed and they

962
00:30:31,919 --> 00:30:33,360
didn't just fail they also gave us a

963
00:30:33,360 --> 00:30:35,039
minimal counter example which is which

964
00:30:35,039 --> 00:30:36,159
looks like this

965
00:30:36,159 --> 00:30:38,080
so in that case we have two possible

966
00:30:38,080 --> 00:30:39,200
chains and

967
00:30:39,200 --> 00:30:40,880
both of them would require us to

968
00:30:40,880 --> 00:30:42,559
download a block in order to validate

969
00:30:42,559 --> 00:30:43,120
the

970
00:30:43,120 --> 00:30:46,640
the last block in that in that chain

971
00:30:46,640 --> 00:30:48,720
the thing is if we implement that rule

972
00:30:48,720 --> 00:30:50,720
that we say we only download blocks

973
00:30:50,720 --> 00:30:52,399
if we can't follow any of the chains

974
00:30:52,399 --> 00:30:53,679
that were presented with other than that

975
00:30:53,679 --> 00:30:55,440
what happens is that

976
00:30:55,440 --> 00:30:57,440
some of the nodes would download that

977
00:30:57,440 --> 00:30:58,799
green block and then

978
00:30:58,799 --> 00:31:00,320
and then at that point they are able to

979
00:31:00,320 --> 00:31:02,240
follow the upper chain and so the

980
00:31:02,240 --> 00:31:03,039
condition

981
00:31:03,039 --> 00:31:05,039
that you need to download block data in

982
00:31:05,039 --> 00:31:06,720
order to follow any chain is no longer

983
00:31:06,720 --> 00:31:07,760
true

984
00:31:07,760 --> 00:31:11,039
and you do not download the blue block

985
00:31:11,039 --> 00:31:12,399
and so you never follow that

986
00:31:12,399 --> 00:31:15,279
chain that lower chain and other nodes

987
00:31:15,279 --> 00:31:16,640
will download the blue

988
00:31:16,640 --> 00:31:18,480
block first because they were presented

989
00:31:18,480 --> 00:31:19,840
with a chain first so they would be

990
00:31:19,840 --> 00:31:21,360
stuck forever with that chain

991
00:31:21,360 --> 00:31:23,840
and so that's why that doesn't work and

992
00:31:23,840 --> 00:31:25,120
what you see here is that

993
00:31:25,120 --> 00:31:27,360
if you were to write a unit test case

994
00:31:27,360 --> 00:31:28,480
for that

995
00:31:28,480 --> 00:31:30,240
you would basically you would test

996
00:31:30,240 --> 00:31:32,399
exactly for for that situation

997
00:31:32,399 --> 00:31:34,080
so you would know what's going wrong and

998
00:31:34,080 --> 00:31:35,360
in hindsight it's pretty obvious what's

999
00:31:35,360 --> 00:31:36,559
going wrong but that's the thing about

1000
00:31:36,559 --> 00:31:37,679
hindsight right

1001
00:31:37,679 --> 00:31:39,760
and the nice thing about those general

1002
00:31:39,760 --> 00:31:41,360
property based tests is

1003
00:31:41,360 --> 00:31:44,159
that you think about very general

1004
00:31:44,159 --> 00:31:45,919
properties like you get agreement you do

1005
00:31:45,919 --> 00:31:47,039
not think about

1006
00:31:47,039 --> 00:31:48,880
this optimization that you are doing you

1007
00:31:48,880 --> 00:31:50,399
do not you think about different

1008
00:31:50,399 --> 00:31:52,320
concerns when writing the code

1009
00:31:52,320 --> 00:31:53,600
then you are when you're writing the

1010
00:31:53,600 --> 00:31:55,519
tests and that makes it

1011
00:31:55,519 --> 00:31:58,559
um that reduces the probability of

1012
00:31:58,559 --> 00:32:01,200
reproducing the same mistakes in your

1013
00:32:01,200 --> 00:32:02,159
code

1014
00:32:02,159 --> 00:32:05,120
that you're in in your tests and thereby

1015
00:32:05,120 --> 00:32:06,799
not not finding the mistakes

1016
00:32:06,799 --> 00:32:08,240
and so that's that's um the real

1017
00:32:08,240 --> 00:32:09,279
powerful thing about those

1018
00:32:09,279 --> 00:32:12,320
property-based tests

1019
00:32:12,320 --> 00:32:14,080
another thing an operational thing that

1020
00:32:14,080 --> 00:32:15,840
often goes wrong with blockchains is

1021
00:32:15,840 --> 00:32:16,240
that

1022
00:32:16,240 --> 00:32:18,880
when you change the rules of the game

1023
00:32:18,880 --> 00:32:21,200
you get disagreement on like which rules

1024
00:32:21,200 --> 00:32:22,880
to follow and you get a fork and this

1025
00:32:22,880 --> 00:32:24,399
has happened with bitcoin many many

1026
00:32:24,399 --> 00:32:26,240
times so in cardano

1027
00:32:26,240 --> 00:32:28,559
we we want to change the rules of the

1028
00:32:28,559 --> 00:32:30,080
game quite frequently when we

1029
00:32:30,080 --> 00:32:31,600
introduce new features on the ledger or

1030
00:32:31,600 --> 00:32:33,600
when we introduce newer versions of our

1031
00:32:33,600 --> 00:32:34,559
boros

1032
00:32:34,559 --> 00:32:36,720
and in order to have that without the

1033
00:32:36,720 --> 00:32:38,320
risk of forks

1034
00:32:38,320 --> 00:32:40,559
we need to have one code base that can

1035
00:32:40,559 --> 00:32:42,000
understand the whole chain

1036
00:32:42,000 --> 00:32:44,000
from from the beginning to the end and

1037
00:32:44,000 --> 00:32:45,519
that evolves over time and we need to

1038
00:32:45,519 --> 00:32:46,640
get agreement on

1039
00:32:46,640 --> 00:32:48,720
when to switch from one set of rules to

1040
00:32:48,720 --> 00:32:50,799
the next

1041
00:32:50,799 --> 00:32:53,440
and that like that that point where we

1042
00:32:53,440 --> 00:32:55,440
transition from one protocol version to

1043
00:32:55,440 --> 00:32:56,240
the next

1044
00:32:56,240 --> 00:32:58,320
can't be hard-coded in the code because

1045
00:32:58,320 --> 00:32:59,360
if we did that

1046
00:32:59,360 --> 00:33:01,840
then um yeah in order to do that we

1047
00:33:01,840 --> 00:33:02,960
would need to know

1048
00:33:02,960 --> 00:33:04,480
when all the operators have updated

1049
00:33:04,480 --> 00:33:06,960
their software and we don't need that

1050
00:33:06,960 --> 00:33:08,720
when we we don't know that when we

1051
00:33:08,720 --> 00:33:10,000
implement the code

1052
00:33:10,000 --> 00:33:13,039
and so we have to have some some signal

1053
00:33:13,039 --> 00:33:14,480
on the chain that tells us

1054
00:33:14,480 --> 00:33:16,799
when we want to do that transition and

1055
00:33:16,799 --> 00:33:18,640
we need to have a software that can

1056
00:33:18,640 --> 00:33:22,080
deal with like transitioning from one

1057
00:33:22,080 --> 00:33:23,919
version of the protocol to the next at a

1058
00:33:23,919 --> 00:33:26,559
time that's not predetermined when we

1059
00:33:26,559 --> 00:33:28,399
produce the code and for that we have

1060
00:33:28,399 --> 00:33:29,840
written a

1061
00:33:29,840 --> 00:33:31,519
a software that is called a hard four

1062
00:33:31,519 --> 00:33:32,960
combinator which

1063
00:33:32,960 --> 00:33:35,840
takes a number of protocols and defines

1064
00:33:35,840 --> 00:33:37,200
a new protocol as a sequential

1065
00:33:37,200 --> 00:33:39,200
composition of those protocols

1066
00:33:39,200 --> 00:33:42,880
and this hard fork combinator avoids us

1067
00:33:42,880 --> 00:33:44,720
having a situation where the system hard

1068
00:33:44,720 --> 00:33:46,240
forks because we have disagreement on

1069
00:33:46,240 --> 00:33:47,600
which rules to follow between the

1070
00:33:47,600 --> 00:33:49,360
operators

1071
00:33:49,360 --> 00:33:51,039
another thing that is quite risky is the

1072
00:33:51,039 --> 00:33:52,960
point at which you decentralize the

1073
00:33:52,960 --> 00:33:53,679
system

1074
00:33:53,679 --> 00:33:55,600
so um at first we had like we had a

1075
00:33:55,600 --> 00:33:57,279
fixed set of nodes that operated the

1076
00:33:57,279 --> 00:33:59,039
system and we had control over those

1077
00:33:59,039 --> 00:34:00,640
but then we want to open that up of

1078
00:34:00,640 --> 00:34:02,159
course to the community

1079
00:34:02,159 --> 00:34:04,000
but that point where you open it up is

1080
00:34:04,000 --> 00:34:06,080
quite risky for two reasons one is that

1081
00:34:06,080 --> 00:34:08,159
the people were operating the new nodes

1082
00:34:08,159 --> 00:34:09,760
they don't have experience with it so

1083
00:34:09,760 --> 00:34:11,440
it's not clear whether they will

1084
00:34:11,440 --> 00:34:14,639
run them in a stable manner um so you

1085
00:34:14,639 --> 00:34:16,560
can have the system go down because

1086
00:34:16,560 --> 00:34:17,918
people just have no experience in

1087
00:34:17,918 --> 00:34:19,040
operating those nodes

1088
00:34:19,040 --> 00:34:22,239
the other one is that in order to to go

1089
00:34:22,239 --> 00:34:22,879
active

1090
00:34:22,879 --> 00:34:24,399
people have to delegate their stake to

1091
00:34:24,399 --> 00:34:26,000
one of those operators

1092
00:34:26,000 --> 00:34:27,599
and at the moment where you do the

1093
00:34:27,599 --> 00:34:29,119
switch most of that stake will not be

1094
00:34:29,119 --> 00:34:30,079
delegated yet

1095
00:34:30,079 --> 00:34:32,480
so you have an increased danger of 51

1096
00:34:32,480 --> 00:34:33,760
attack just because there's so little

1097
00:34:33,760 --> 00:34:34,000
active

1098
00:34:34,000 --> 00:34:36,879
stake in order to mitigate those risks

1099
00:34:36,879 --> 00:34:37,199
or

1100
00:34:37,199 --> 00:34:39,839
de-risk it and remove that risk um we

1101
00:34:39,839 --> 00:34:41,119
introduced a new parameter

1102
00:34:41,119 --> 00:34:44,399
into into the protocol called d and that

1103
00:34:44,399 --> 00:34:45,280
determines the

1104
00:34:45,280 --> 00:34:46,719
fraction of blocks that are still

1105
00:34:46,719 --> 00:34:49,359
produced by by this earlier federation

1106
00:34:49,359 --> 00:34:51,040
and then you can gradually shift from

1107
00:34:51,040 --> 00:34:52,639
from d equals to one to the equals to

1108
00:34:52,639 --> 00:34:54,639
zero where you have fully centralization

1109
00:34:54,639 --> 00:34:56,800
and while you are decreasing that d you

1110
00:34:56,800 --> 00:34:58,480
can monitor system health

1111
00:34:58,480 --> 00:35:00,160
delegated stake and things like that by

1112
00:35:00,160 --> 00:35:02,560
that you remove that that dangerous

1113
00:35:02,560 --> 00:35:04,960
period

1114
00:35:04,960 --> 00:35:07,040
there's other things that can go wrong

1115
00:35:07,040 --> 00:35:08,480
when you go from the

1116
00:35:08,480 --> 00:35:10,800
abstract description of the protocol to

1117
00:35:10,800 --> 00:35:12,160
a more concrete one which you

1118
00:35:12,160 --> 00:35:13,839
need if you're if you're if you want to

1119
00:35:13,839 --> 00:35:16,720
have something running in the real world

1120
00:35:16,720 --> 00:35:20,480
and that is that in the papers you have

1121
00:35:20,480 --> 00:35:22,560
a very abstract view on things like

1122
00:35:22,560 --> 00:35:24,640
the network for example that you need to

1123
00:35:24,640 --> 00:35:26,560
concretize these things and you need to

1124
00:35:26,560 --> 00:35:28,880
refine these things when you go towards

1125
00:35:28,880 --> 00:35:30,720
implementation and while you're doing

1126
00:35:30,720 --> 00:35:31,839
that you could create

1127
00:35:31,839 --> 00:35:33,920
new interactions also for the adversary

1128
00:35:33,920 --> 00:35:35,359
to interact with the system

1129
00:35:35,359 --> 00:35:37,680
and you need to be careful not to

1130
00:35:37,680 --> 00:35:39,440
introduce new interactions

1131
00:35:39,440 --> 00:35:41,680
that compromise the the system and that

1132
00:35:41,680 --> 00:35:42,800
make it more easy

1133
00:35:42,800 --> 00:35:46,160
to attack the system and one of one

1134
00:35:46,160 --> 00:35:47,359
example for that is that

1135
00:35:47,359 --> 00:35:49,040
you have to be very mindful about the

1136
00:35:49,040 --> 00:35:50,960
resource balance between honest nodes

1137
00:35:50,960 --> 00:35:52,480
and adversarial nodes and if you don't

1138
00:35:52,480 --> 00:35:53,599
get that right

1139
00:35:53,599 --> 00:35:55,119
then you create opportunities for

1140
00:35:55,119 --> 00:35:57,040
asymmetric resource attacks and that

1141
00:35:57,040 --> 00:35:59,040
aggressive filtering that i mentioned

1142
00:35:59,040 --> 00:36:00,400
three slides back

1143
00:36:00,400 --> 00:36:02,960
is an example of that and there's many

1144
00:36:02,960 --> 00:36:04,240
more considerations

1145
00:36:04,240 --> 00:36:06,560
like those and i hope that gives you an

1146
00:36:06,560 --> 00:36:07,680
an overview

1147
00:36:07,680 --> 00:36:09,760
and an idea for like how careful you

1148
00:36:09,760 --> 00:36:10,960
have to be in order to

1149
00:36:10,960 --> 00:36:12,720
get an implementation that is that is

1150
00:36:12,720 --> 00:36:16,160
good and faithful to the papers

1151
00:36:16,240 --> 00:36:18,160
thank you for attention um we have lots

1152
00:36:18,160 --> 00:36:20,000
of future work lined up we there are

1153
00:36:20,000 --> 00:36:20,320
still

1154
00:36:20,320 --> 00:36:22,400
some remaining gaps between the theory

1155
00:36:22,400 --> 00:36:24,839
and implementation that we can work on

1156
00:36:24,839 --> 00:36:26,000
closing

1157
00:36:26,000 --> 00:36:27,760
there's also a formalized version of the

1158
00:36:27,760 --> 00:36:29,680
security guarantees of the auroboros

1159
00:36:29,680 --> 00:36:30,480
paper

1160
00:36:30,480 --> 00:36:32,079
there's a phd thesis about that is about

1161
00:36:32,079 --> 00:36:34,079
to be completed using the isabel theorem

1162
00:36:34,079 --> 00:36:35,200
prover to get

1163
00:36:35,200 --> 00:36:38,560
formal proofs of the security guarantees

1164
00:36:38,560 --> 00:36:39,760
we have to implement the newer versions

1165
00:36:39,760 --> 00:36:42,400
of roboros and also add new features to

1166
00:36:42,400 --> 00:36:43,760
the ledger functionality

1167
00:36:43,760 --> 00:36:45,760
smart contracts decentralized software

1168
00:36:45,760 --> 00:36:46,960
updates where

1169
00:36:46,960 --> 00:36:49,440
you where the community itself agrees on

1170
00:36:49,440 --> 00:36:50,079
like

1171
00:36:50,079 --> 00:36:52,320
which future software versions to accept

1172
00:36:52,320 --> 00:36:53,599
or not

1173
00:36:53,599 --> 00:36:57,040
so lots remains to be done and

1174
00:36:57,040 --> 00:36:58,240
we're working on that happily thank you

1175
00:36:58,240 --> 00:37:01,919
for attention

