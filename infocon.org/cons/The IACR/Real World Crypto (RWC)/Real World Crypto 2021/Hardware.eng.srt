1
00:00:00,799 --> 00:00:03,600
and you can go ahead have a good session

2
00:00:03,600 --> 00:00:05,759
welcome everybody to the hardware

3
00:00:05,759 --> 00:00:08,160
session so we have four

4
00:00:08,160 --> 00:00:11,599
exciting talks um i'll be watching the

5
00:00:11,599 --> 00:00:14,400
zulip chat for questions for the

6
00:00:14,400 --> 00:00:16,239
speakers so put your questions there and

7
00:00:16,239 --> 00:00:17,199
make sure that you

8
00:00:17,199 --> 00:00:19,760
say who they are intended for um so our

9
00:00:19,760 --> 00:00:21,680
first talk is going to be

10
00:00:21,680 --> 00:00:24,000
on rosita towards automatic elimination

11
00:00:24,000 --> 00:00:25,840
of power analysis which will be given by

12
00:00:25,840 --> 00:00:28,880
madura and yuval

13
00:00:29,039 --> 00:00:31,760
hey uh good morning everyone yes i

14
00:00:31,760 --> 00:00:33,200
didn't

15
00:00:33,200 --> 00:00:35,840
um i'm yuval and i'm here with the

16
00:00:35,840 --> 00:00:36,559
madura

17
00:00:36,559 --> 00:00:39,680
and this is work that was done with the

18
00:00:39,680 --> 00:00:41,920
neighbor samwell layla battina francesco

19
00:00:41,920 --> 00:00:44,640
roguetzoni and marcus wagner

20
00:00:44,640 --> 00:00:49,280
and uh let's go ahead madura please

21
00:00:49,280 --> 00:00:52,719
okay so in 1996 paul kocher

22
00:00:52,719 --> 00:00:56,000
told us that uh if we have devices that

23
00:00:56,000 --> 00:00:56,840
run

24
00:00:56,840 --> 00:01:00,480
cryptography then the device

25
00:01:00,480 --> 00:01:02,719
interacts with the environment and may

26
00:01:02,719 --> 00:01:04,720
leak information about what's going on

27
00:01:04,720 --> 00:01:06,080
which we can pick up

28
00:01:06,080 --> 00:01:08,720
by uh

29
00:01:09,520 --> 00:01:13,039
using a maduro

30
00:01:17,200 --> 00:01:19,200
and then we analyze the signal and we

31
00:01:19,200 --> 00:01:21,600
can recover the key

32
00:01:21,600 --> 00:01:25,040
and to fight side channels we

33
00:01:25,040 --> 00:01:28,880
use a common technique we just mask up

34
00:01:28,880 --> 00:01:32,799
and we take a value that we want to hide

35
00:01:32,799 --> 00:01:37,600
and we choose a random mask

36
00:01:37,600 --> 00:01:41,040
and when we apply the the mask to the

37
00:01:41,040 --> 00:01:41,600
value

38
00:01:41,600 --> 00:01:44,399
um we hide the value and now we can

39
00:01:44,399 --> 00:01:46,799
process the value and the mask

40
00:01:46,799 --> 00:01:49,439
together oh sorry the value of the mask

41
00:01:49,439 --> 00:01:50,479
separately

42
00:01:50,479 --> 00:01:53,200
and uh as long as only one of them leaks

43
00:01:53,200 --> 00:01:54,960
we don't have any information leaked and

44
00:01:54,960 --> 00:01:55,439
they

45
00:01:55,439 --> 00:01:58,399
and we are secure and that works nice

46
00:01:58,399 --> 00:01:59,600
theoretically but

47
00:01:59,600 --> 00:02:02,640
if we go to the real hardware we have

48
00:02:02,640 --> 00:02:05,759
an issue of unintended interaction so if

49
00:02:05,759 --> 00:02:07,439
we have the computer pipeline and we

50
00:02:07,439 --> 00:02:11,038
have a value going through the pipeline

51
00:02:11,038 --> 00:02:14,720
then this value may be stored in one of

52
00:02:14,720 --> 00:02:16,640
the pipeline registered

53
00:02:16,640 --> 00:02:19,840
and it stays there

54
00:02:19,840 --> 00:02:23,360
and if we later process a related value

55
00:02:23,360 --> 00:02:26,560
for example the mask then

56
00:02:26,560 --> 00:02:30,000
uh when it is stored in the register

57
00:02:30,000 --> 00:02:34,080
uh there is a it to basically remove the

58
00:02:34,080 --> 00:02:35,200
uh

59
00:02:35,200 --> 00:02:39,280
the old value and that leaks uh the uh

60
00:02:39,280 --> 00:02:42,800
originally unmasked value and that's not

61
00:02:42,800 --> 00:02:44,720
good because we don't have any

62
00:02:44,720 --> 00:02:46,800
information from software side

63
00:02:46,800 --> 00:02:49,360
that will tell us that this happens so

64
00:02:49,360 --> 00:02:50,080
the standard

65
00:02:50,080 --> 00:02:53,280
way practitioners use

66
00:02:53,280 --> 00:02:56,319
to work with that is we have our

67
00:02:56,319 --> 00:02:58,000
programmer and she writes

68
00:02:58,000 --> 00:03:01,760
the uh cryptographic software applied to

69
00:03:01,760 --> 00:03:03,680
the device under test

70
00:03:03,680 --> 00:03:07,360
run some tests on that

71
00:03:08,239 --> 00:03:12,159
and analyze the test to apply fixes to

72
00:03:12,159 --> 00:03:13,280
the

73
00:03:13,280 --> 00:03:15,440
software and then the process repeats

74
00:03:15,440 --> 00:03:16,480
and repeats

75
00:03:16,480 --> 00:03:20,640
until there are knowing no more leaks

76
00:03:20,640 --> 00:03:23,040
so uh this is an expensive process

77
00:03:23,040 --> 00:03:24,319
because uh

78
00:03:24,319 --> 00:03:27,760
we need skill tech programmers to do the

79
00:03:27,760 --> 00:03:30,319
work and they need to have a

80
00:03:30,319 --> 00:03:32,319
large number of skills to enable them to

81
00:03:32,319 --> 00:03:33,360
do this process

82
00:03:33,360 --> 00:03:35,360
and it just takes a long time to run and

83
00:03:35,360 --> 00:03:37,200
they iterate between

84
00:03:37,200 --> 00:03:40,720
programming and testing so what we want

85
00:03:40,720 --> 00:03:42,239
to do

86
00:03:42,239 --> 00:03:44,480
in this work is basically to take the

87
00:03:44,480 --> 00:03:47,280
programmer out of the loop

88
00:03:47,280 --> 00:03:49,599
and

89
00:03:50,400 --> 00:03:52,560
automate the process and with that i'll

90
00:03:52,560 --> 00:03:53,439
hand over to

91
00:03:53,439 --> 00:03:56,560
my colleague madura

92
00:03:56,799 --> 00:04:00,159
so basically we need to uh turn

93
00:04:00,159 --> 00:04:03,200
all this into an automated process so to

94
00:04:03,200 --> 00:04:04,239
do that

95
00:04:04,239 --> 00:04:07,519
we use a leakage emu data called elmo

96
00:04:07,519 --> 00:04:10,519
which was presented at usenix security

97
00:04:10,519 --> 00:04:12,159
2017

98
00:04:12,159 --> 00:04:16,000
uh by mccann or at all and

99
00:04:16,000 --> 00:04:19,199
secondly we use rosita which is a tool

100
00:04:19,199 --> 00:04:20,320
that we

101
00:04:20,320 --> 00:04:24,240
wrote that can apply as

102
00:04:24,240 --> 00:04:28,080
patches for the softwares uh

103
00:04:28,080 --> 00:04:30,400
but there's a problem with elmo that we

104
00:04:30,400 --> 00:04:31,840
can't use it as it is

105
00:04:31,840 --> 00:04:35,040
we need to do some changes because uh

106
00:04:35,040 --> 00:04:40,880
original elmo is uh it's only capable of

107
00:04:40,960 --> 00:04:43,919
emulating leakage of neighboring

108
00:04:43,919 --> 00:04:44,800
instructions

109
00:04:44,800 --> 00:04:47,360
any instructions that are far away uh to

110
00:04:47,360 --> 00:04:48,880
the target instruction

111
00:04:48,880 --> 00:04:52,639
uh are not immediate so because of this

112
00:04:52,639 --> 00:04:55,040
uh we we added some modifications to

113
00:04:55,040 --> 00:04:58,400
elmo to make it more realistic

114
00:04:58,400 --> 00:05:01,840
ah so we

115
00:05:01,840 --> 00:05:04,800
uh so this is a this is an example where

116
00:05:04,800 --> 00:05:05,440
we

117
00:05:05,440 --> 00:05:08,880
already found some leakage uh so let's

118
00:05:08,880 --> 00:05:12,880
look at how we set up the experiment

119
00:05:12,880 --> 00:05:16,639
for this experiment we loaded up two

120
00:05:16,639 --> 00:05:20,400
instructions with related shares and

121
00:05:20,400 --> 00:05:23,520
we added some noise in instructions in

122
00:05:23,520 --> 00:05:24,400
the middle

123
00:05:24,400 --> 00:05:27,199
so that these two instructions do not

124
00:05:27,199 --> 00:05:30,880
interact in the cpu pipeline

125
00:05:30,880 --> 00:05:33,120
let's look at the results that we got

126
00:05:33,120 --> 00:05:34,080
from those

127
00:05:34,080 --> 00:05:37,039
that previous experiment so in this

128
00:05:37,039 --> 00:05:40,080
experiment uh what we did was

129
00:05:40,080 --> 00:05:43,360
uh so here uh in the

130
00:05:43,360 --> 00:05:46,880
horizontal axis uh it's the time

131
00:05:46,880 --> 00:05:49,919
and and the vertical axis it's a t

132
00:05:49,919 --> 00:05:52,960
value uh so the t value it shows the

133
00:05:52,960 --> 00:05:55,199
significance of the leakage

134
00:05:55,199 --> 00:05:58,639
and we use the 4.5

135
00:05:58,639 --> 00:06:01,039
the absolute value of 4.5 as the

136
00:06:01,039 --> 00:06:03,360
threshold t value for our

137
00:06:03,360 --> 00:06:07,520
analysis so here you can see that

138
00:06:07,520 --> 00:06:11,759
uh the real

139
00:06:11,759 --> 00:06:14,720
leakage is significant at the second

140
00:06:14,720 --> 00:06:15,840
instruction

141
00:06:15,840 --> 00:06:18,960
and that the original version of elmo

142
00:06:18,960 --> 00:06:22,479
is incapable of uh emulating it

143
00:06:22,479 --> 00:06:23,520
correctly so that

144
00:06:23,520 --> 00:06:26,160
we can see significant leakage and our

145
00:06:26,160 --> 00:06:28,560
modification which is shown in green

146
00:06:28,560 --> 00:06:32,840
uh gives us closer to realistic

147
00:06:32,840 --> 00:06:35,840
uh evaluation

148
00:06:35,840 --> 00:06:38,560
so now that we have a realistic

149
00:06:38,560 --> 00:06:41,120
emulation of the decage

150
00:06:41,120 --> 00:06:43,759
let's look at how we can find the root

151
00:06:43,759 --> 00:06:44,880
causes for this

152
00:06:44,880 --> 00:06:48,319
leakage so we

153
00:06:48,319 --> 00:06:52,000
use the nmos power model

154
00:06:52,000 --> 00:06:54,639
uh which is a combination of variables

155
00:06:54,639 --> 00:06:55,440
that

156
00:06:55,440 --> 00:06:58,639
emulates the differential voltage uh of

157
00:06:58,639 --> 00:06:59,120
a

158
00:06:59,120 --> 00:07:02,160
cpu so the elmo's

159
00:07:02,160 --> 00:07:06,319
analysis generates the t test values for

160
00:07:06,319 --> 00:07:08,960
the differential voltage and what we

161
00:07:08,960 --> 00:07:10,000
additionally do

162
00:07:10,000 --> 00:07:13,039
is that we introduce t test values for

163
00:07:13,039 --> 00:07:13,919
each of

164
00:07:13,919 --> 00:07:16,960
these individual variables so that

165
00:07:16,960 --> 00:07:19,520
whenever these individual variables also

166
00:07:19,520 --> 00:07:20,800
become significant

167
00:07:20,800 --> 00:07:23,599
we know that the cost for the leakage is

168
00:07:23,599 --> 00:07:24,240
coming

169
00:07:24,240 --> 00:07:27,440
through uh this value

170
00:07:27,440 --> 00:07:30,960
let's look at the fix on how we

171
00:07:30,960 --> 00:07:34,000
use this root cause detection to apply

172
00:07:34,000 --> 00:07:35,199
figs

173
00:07:35,199 --> 00:07:39,039
so here we from prior detection we know

174
00:07:39,039 --> 00:07:40,639
that

175
00:07:40,639 --> 00:07:43,759
our the value of r4 and the memory

176
00:07:43,759 --> 00:07:45,199
that's pointed to by

177
00:07:45,199 --> 00:07:48,560
the value of r1 is leaking so to fix

178
00:07:48,560 --> 00:07:49,039
this

179
00:07:49,039 --> 00:07:51,360
uh so actually this is the this leakage

180
00:07:51,360 --> 00:07:53,840
leakage is happening because these two

181
00:07:53,840 --> 00:07:56,319
instructions are neighbors and that's

182
00:07:56,319 --> 00:07:58,319
why they are leaking as we need to break

183
00:07:58,319 --> 00:07:58,879
the

184
00:07:58,879 --> 00:08:01,440
interaction between these two

185
00:08:01,440 --> 00:08:02,160
instructions

186
00:08:02,160 --> 00:08:04,479
to do that we add a dummy instruction

187
00:08:04,479 --> 00:08:05,280
that

188
00:08:05,280 --> 00:08:08,960
processes random information

189
00:08:08,960 --> 00:08:12,160
so that the leakage that we saw before

190
00:08:12,160 --> 00:08:15,199
is cleared out this is just a

191
00:08:15,199 --> 00:08:17,840
single example for more examples like

192
00:08:17,840 --> 00:08:18,400
this

193
00:08:18,400 --> 00:08:21,120
that we use in rosita please read our

194
00:08:21,120 --> 00:08:22,879
paper

195
00:08:22,879 --> 00:08:26,240
so let's look at some results so

196
00:08:26,240 --> 00:08:28,080
we started out with the mask

197
00:08:28,080 --> 00:08:29,360
implementation of

198
00:08:29,360 --> 00:08:32,880
aes so the this is a this should be

199
00:08:32,880 --> 00:08:34,479
theoretically

200
00:08:34,479 --> 00:08:38,240
leakage free but in hardware we see that

201
00:08:38,240 --> 00:08:40,640
there's unintended interactions and

202
00:08:40,640 --> 00:08:41,599
because of those

203
00:08:41,599 --> 00:08:43,679
interactions we see significant leakage

204
00:08:43,679 --> 00:08:45,120
at a

205
00:08:45,120 --> 00:08:48,959
cycle around 500 so

206
00:08:48,959 --> 00:08:52,399
we ran this through rosita and fixed

207
00:08:52,399 --> 00:08:56,320
all leakage we did the same for

208
00:08:56,320 --> 00:08:59,279
a masked version of cha-cha and we did

209
00:08:59,279 --> 00:09:00,560
the same also for

210
00:09:00,560 --> 00:09:03,839
sudo please

211
00:09:03,839 --> 00:09:06,839
refer to our paper for more information

212
00:09:06,839 --> 00:09:09,519
and because we are adding

213
00:09:09,519 --> 00:09:12,480
new uh instructions for these fixes we

214
00:09:12,480 --> 00:09:12,800
are

215
00:09:12,800 --> 00:09:16,399
uh slowing down the uh

216
00:09:16,399 --> 00:09:20,000
implementation so we have to add here

217
00:09:20,000 --> 00:09:24,240
to uh 15 for aes and 64

218
00:09:24,240 --> 00:09:26,959
for charger

219
00:09:27,600 --> 00:09:30,640
in summary we started out by

220
00:09:30,640 --> 00:09:33,600
explaining unintended instructions in

221
00:09:33,600 --> 00:09:35,839
hardware

222
00:09:35,839 --> 00:09:39,279
and why mask implementation stay leak

223
00:09:39,279 --> 00:09:42,320
and then we we explained

224
00:09:42,320 --> 00:09:44,800
how the how tedious the manual process

225
00:09:44,800 --> 00:09:46,320
is and that we need

226
00:09:46,320 --> 00:09:50,640
an automatic fix for this uh we improved

227
00:09:50,640 --> 00:09:51,360
airmo

228
00:09:51,360 --> 00:09:54,160
and then uh explained how root code

229
00:09:54,160 --> 00:09:55,040
detection

230
00:09:55,040 --> 00:09:58,480
uh and how rosita applies fixes

231
00:09:58,480 --> 00:10:02,000
and finally we showed some results

232
00:10:02,000 --> 00:10:05,279
uh uh so please

233
00:10:05,279 --> 00:10:08,880
visit these two links uh to our paper

234
00:10:08,880 --> 00:10:12,079
and uh uh open source version of source

235
00:10:12,079 --> 00:10:12,959
rosita

236
00:10:12,959 --> 00:10:16,839
thank you and i move into four questions

237
00:10:16,839 --> 00:10:18,880
now

238
00:10:18,880 --> 00:10:21,200
so we have several questions in the chat

239
00:10:21,200 --> 00:10:22,320
already

240
00:10:22,320 --> 00:10:24,000
so the first question is from anders

241
00:10:24,000 --> 00:10:25,440
nilsson who asks

242
00:10:25,440 --> 00:10:27,600
is the masking compiler dependent and

243
00:10:27,600 --> 00:10:29,360
will switching compiler optimization

244
00:10:29,360 --> 00:10:32,160
levels matter

245
00:10:32,160 --> 00:10:35,920
ah so for masking it is compiling

246
00:10:35,920 --> 00:10:38,399
independent because you are

247
00:10:38,399 --> 00:10:42,160
the implementation itself is masked so

248
00:10:42,160 --> 00:10:45,279
by switching the compiler optimizations

249
00:10:45,279 --> 00:10:46,079
what you are doing

250
00:10:46,079 --> 00:10:48,560
is basically changing the code

251
00:10:48,560 --> 00:10:49,440
generation

252
00:10:49,440 --> 00:10:51,920
so that is that is not a problem here

253
00:10:51,920 --> 00:10:52,640
because what

254
00:10:52,640 --> 00:10:56,000
we we apply our fixes to the

255
00:10:56,000 --> 00:11:01,839
assembly so it doesn't do any change

256
00:11:02,079 --> 00:11:04,880
so the um the next question is from

257
00:11:04,880 --> 00:11:06,240
jurgen pulkus

258
00:11:06,240 --> 00:11:08,880
who says assuming you're using your

259
00:11:08,880 --> 00:11:10,640
tools on real hardware

260
00:11:10,640 --> 00:11:12,480
when you're porting code from a platform

261
00:11:12,480 --> 00:11:14,240
to a similar new one how do you get the

262
00:11:14,240 --> 00:11:16,240
leakage model of the new platform

263
00:11:16,240 --> 00:11:18,399
do you have some special test code that

264
00:11:18,399 --> 00:11:20,160
you want yes so

265
00:11:20,160 --> 00:11:22,560
this is this is dependent on elmo so you

266
00:11:22,560 --> 00:11:23,600
need to uh

267
00:11:23,600 --> 00:11:26,560
profile elmo before using it so we we

268
00:11:26,560 --> 00:11:28,720
have already profiled it for uh

269
00:11:28,720 --> 00:11:33,200
cortex m0 for uh stm32f030

270
00:11:33,200 --> 00:11:35,839
evaluation board so even when you when

271
00:11:35,839 --> 00:11:36,399
the

272
00:11:36,399 --> 00:11:37,839
when the devices change you have you

273
00:11:37,839 --> 00:11:39,839
have to do a profiling and

274
00:11:39,839 --> 00:11:42,560
it is it doesn't it doesn't take days to

275
00:11:42,560 --> 00:11:43,920
provide it so

276
00:11:43,920 --> 00:11:47,120
also it's amazing

277
00:11:47,519 --> 00:11:50,320
and uh so the next question is from ben

278
00:11:50,320 --> 00:11:51,920
marshall who asked can you identify

279
00:11:51,920 --> 00:11:52,720
patches

280
00:11:52,720 --> 00:11:54,240
where you only need to reorder

281
00:11:54,240 --> 00:11:56,000
instructions rather than add new ones

282
00:11:56,000 --> 00:11:59,120
to save impacting performances etc

283
00:11:59,120 --> 00:12:02,079
that's a good question we haven't uh

284
00:12:02,079 --> 00:12:03,440
find out

285
00:12:03,440 --> 00:12:07,279
ways that we can reorder the

286
00:12:07,279 --> 00:12:09,760
instructions and keep the functionality

287
00:12:09,760 --> 00:12:10,720
the same so

288
00:12:10,720 --> 00:12:12,320
that's uh that's a bit hard thing to

289
00:12:12,320 --> 00:12:14,720
guarantee but what we

290
00:12:14,720 --> 00:12:16,959
do right now is to insert instructions

291
00:12:16,959 --> 00:12:18,160
that do

292
00:12:18,160 --> 00:12:21,200
do nothing but what they do is they

293
00:12:21,200 --> 00:12:24,399
they change the uh

294
00:12:24,399 --> 00:12:27,680
the execution uh to uh one that

295
00:12:27,680 --> 00:12:29,920
doesn't have any unlimited interactions

296
00:12:29,920 --> 00:12:31,279
because these are

297
00:12:31,279 --> 00:12:32,959
uh usually uh happening at the

298
00:12:32,959 --> 00:12:34,399
microarchitecture level and

299
00:12:34,399 --> 00:12:37,440
we do we don't need to change the actual

300
00:12:37,440 --> 00:12:39,120
values of registers

301
00:12:39,120 --> 00:12:41,040
because we assume that the masking is

302
00:12:41,040 --> 00:12:42,880
correct and the implementation is

303
00:12:42,880 --> 00:12:44,160
correct but

304
00:12:44,160 --> 00:12:46,240
what we are erasing off is unintended

305
00:12:46,240 --> 00:12:48,480
ones

306
00:12:49,040 --> 00:12:50,880
so our last question is from tanya langa

307
00:12:50,880 --> 00:12:52,959
who asks can your tool take an unmasked

308
00:12:52,959 --> 00:12:54,560
implementation as input and produce a

309
00:12:54,560 --> 00:12:55,760
masked one

310
00:12:55,760 --> 00:12:57,760
if so how much is the overhead compared

311
00:12:57,760 --> 00:12:59,920
to starting with a manually masked one

312
00:12:59,920 --> 00:13:03,200
on which you then run your tool on

313
00:13:03,200 --> 00:13:06,240
yes so what we what we have to run on

314
00:13:06,240 --> 00:13:09,360
our tool is uh on uh on on a pre-mask

315
00:13:09,360 --> 00:13:10,160
implementation

316
00:13:10,160 --> 00:13:13,120
we don't do any masking automatically so

317
00:13:13,120 --> 00:13:13,920
we

318
00:13:13,920 --> 00:13:16,320
it's a it's a requirement of the system

319
00:13:16,320 --> 00:13:17,440
to

320
00:13:17,440 --> 00:13:21,839
have a mass implementation as input

321
00:13:22,160 --> 00:13:24,000
and okay i guess we have time for one

322
00:13:24,000 --> 00:13:25,440
more question so watsonlad

323
00:13:25,440 --> 00:13:27,279
asks what happens when the cpu gets

324
00:13:27,279 --> 00:13:29,040
smarter and starts reordering the

325
00:13:29,040 --> 00:13:31,360
instruction stream

326
00:13:31,360 --> 00:13:34,399
uh hi so so this is

327
00:13:34,399 --> 00:13:38,079
uh this is uh we we recall this as uh

328
00:13:38,079 --> 00:13:40,720
pipeline instruction so pipelining is

329
00:13:40,720 --> 00:13:41,920
not uh yet

330
00:13:41,920 --> 00:13:45,120
uh baked into rosita so that uh so

331
00:13:45,120 --> 00:13:48,240
this is actually a part of the emulation

332
00:13:48,240 --> 00:13:52,079
so uh for this is uh

333
00:13:52,079 --> 00:13:54,480
that's uh that's regarding so our

334
00:13:54,480 --> 00:13:56,639
specific processor that we are

335
00:13:56,639 --> 00:13:58,880
using right now is the cortex m0 and

336
00:13:58,880 --> 00:14:01,440
it's it's on uh it only has a pipeline

337
00:14:01,440 --> 00:14:04,560
of about three and uh

338
00:14:04,560 --> 00:14:07,600
for that uh that the processor

339
00:14:07,600 --> 00:14:10,079
the the model that's used by elmore

340
00:14:10,079 --> 00:14:12,079
matches perfectly because they

341
00:14:12,079 --> 00:14:15,279
uh use instruction street triplets to uh

342
00:14:15,279 --> 00:14:18,399
model the case but for

343
00:14:18,399 --> 00:14:20,639
anything that's more complex i think we

344
00:14:20,639 --> 00:14:22,480
would need to reevaluate the model

345
00:14:22,480 --> 00:14:23,279
building

346
00:14:23,279 --> 00:14:27,040
and change the model to suit those

347
00:14:28,839 --> 00:14:30,480
processes

348
00:14:30,480 --> 00:14:33,519
thank you i guess um

349
00:14:33,519 --> 00:14:35,600
oh and uh i'm being instructed to

350
00:14:35,600 --> 00:14:37,120
advertise that maduro is soon on the

351
00:14:37,120 --> 00:14:38,079
market

352
00:14:38,079 --> 00:14:40,320
so everybody go talk to him and talk to

353
00:14:40,320 --> 00:14:42,160
him and um there are more questions in

354
00:14:42,160 --> 00:14:42,880
the chat

355
00:14:42,880 --> 00:14:45,279
but we should move on to the next uh

356
00:14:45,279 --> 00:14:46,320
talk in this session

357
00:14:46,320 --> 00:14:49,040
so thank you

358
00:14:50,240 --> 00:14:52,880
so i welcome everybody to um keep

359
00:14:52,880 --> 00:14:53,680
discussing

360
00:14:53,680 --> 00:14:59,839
this in the chat

361
00:15:02,480 --> 00:15:06,399
hello there everything fine

362
00:15:06,399 --> 00:15:08,720
you're seeing my slides yes so our next

363
00:15:08,720 --> 00:15:09,440
talk is

364
00:15:09,440 --> 00:15:12,320
risk v a risk five scalar crypto uh and

365
00:15:12,320 --> 00:15:14,880
will be given by marco and ben

366
00:15:14,880 --> 00:15:18,160
yeah hello there i'm uh marcus aaron um

367
00:15:18,160 --> 00:15:21,120
i'm giving this talk with ben marshall

368
00:15:21,120 --> 00:15:22,000
um

369
00:15:22,000 --> 00:15:25,360
right so this is uh we are basically

370
00:15:25,360 --> 00:15:26,000
representing

371
00:15:26,000 --> 00:15:27,839
risk five which is of course a huge

372
00:15:27,839 --> 00:15:29,920
consortium we have about

373
00:15:29,920 --> 00:15:33,279
more than 200 members these these logos

374
00:15:33,279 --> 00:15:34,079
i put together

375
00:15:34,079 --> 00:15:36,240
in november and this there's already a

376
00:15:36,240 --> 00:15:37,920
few missing

377
00:15:37,920 --> 00:15:40,240
missing in there um basically everyone

378
00:15:40,240 --> 00:15:41,360
except you know

379
00:15:41,360 --> 00:15:44,240
intel and arm are members of of the risk

380
00:15:44,240 --> 00:15:46,000
five consortium it's easy to be a member

381
00:15:46,000 --> 00:15:46,560
because it's

382
00:15:46,560 --> 00:15:48,560
it's free and even if you're not a

383
00:15:48,560 --> 00:15:49,920
member you can you can use this

384
00:15:49,920 --> 00:15:51,440
intellectual property to build

385
00:15:51,440 --> 00:15:55,360
cpus which is of course good fun

386
00:15:55,360 --> 00:15:58,480
um so anyone can create these extensions

387
00:15:58,480 --> 00:15:58,959
but

388
00:15:58,959 --> 00:16:00,880
of course we like to have standard

389
00:16:00,880 --> 00:16:02,480
extensions so so these are the things

390
00:16:02,480 --> 00:16:03,360
that we can

391
00:16:03,360 --> 00:16:06,720
put in a compiler upstream to gcc

392
00:16:06,720 --> 00:16:10,000
uh built into a linux kernel and

393
00:16:10,000 --> 00:16:12,079
and so forth so and actually that sort

394
00:16:12,079 --> 00:16:14,480
of uh standard middleware is is what we

395
00:16:14,480 --> 00:16:16,399
are working on

396
00:16:16,399 --> 00:16:19,120
so there are basically three kinds of

397
00:16:19,120 --> 00:16:21,120
risk five so we have the

398
00:16:21,120 --> 00:16:24,240
32-bit sort of microcontroller thing

399
00:16:24,240 --> 00:16:24,639
here

400
00:16:24,639 --> 00:16:27,920
i've got some some actual silicon off

401
00:16:27,920 --> 00:16:31,040
from uh it's a low five chip which is

402
00:16:31,040 --> 00:16:33,680
basically intended to be

403
00:16:33,680 --> 00:16:36,720
um like replacing these low-end arm cpus

404
00:16:36,720 --> 00:16:37,680
and and actually

405
00:16:37,680 --> 00:16:41,199
like uh um espresso has uh has a version

406
00:16:41,199 --> 00:16:42,480
of esp32

407
00:16:42,480 --> 00:16:44,880
with that the second second version is

408
00:16:44,880 --> 00:16:46,959
uh the 64-bit

409
00:16:46,959 --> 00:16:49,360
general sort of application cpu which is

410
00:16:49,360 --> 00:16:50,800
also available

411
00:16:50,800 --> 00:16:54,320
um on silicon and and that has a

412
00:16:54,320 --> 00:16:55,600
different kind of uh

413
00:16:55,600 --> 00:16:56,800
of course it's a different instruction

414
00:16:56,800 --> 00:16:58,959
set different uh register file so

415
00:16:58,959 --> 00:17:01,839
so it has its own crypto extension and

416
00:17:01,839 --> 00:17:03,040
then there's the

417
00:17:03,040 --> 00:17:06,240
the vector architecture uh

418
00:17:06,240 --> 00:17:10,319
rbv k so it can be 32 or 64 bit

419
00:17:10,319 --> 00:17:12,480
and that's actually how the crypto dash

420
00:17:12,480 --> 00:17:14,160
group started so they uh

421
00:17:14,160 --> 00:17:17,439
basically because intel and arm has sim

422
00:17:17,439 --> 00:17:17,839
d

423
00:17:17,839 --> 00:17:20,559
as extensions and such it was it just

424
00:17:20,559 --> 00:17:21,520
thought that yeah

425
00:17:21,520 --> 00:17:23,119
let's uh let's do a similar thing with

426
00:17:23,119 --> 00:17:24,959
the with the vector

427
00:17:24,959 --> 00:17:29,039
registers but in 2019

428
00:17:29,039 --> 00:17:31,440
um i think it was ben who first showed

429
00:17:31,440 --> 00:17:32,160
that

430
00:17:32,160 --> 00:17:33,919
yeah you can do things with uh with the

431
00:17:33,919 --> 00:17:35,760
microcontroller things as well so you

432
00:17:35,760 --> 00:17:36,880
can you can actually

433
00:17:36,880 --> 00:17:39,360
have 32-bit uh crypto instructions which

434
00:17:39,360 --> 00:17:41,039
are really helpful for

435
00:17:41,039 --> 00:17:44,080
for speed and for contracting attacks

436
00:17:44,080 --> 00:17:47,520
so uh scalar crypto means not vector it

437
00:17:47,520 --> 00:17:49,280
means that you don't have a vector f

438
00:17:49,280 --> 00:17:51,919
register file you are just using the the

439
00:17:51,919 --> 00:17:53,520
32

440
00:17:53,520 --> 00:17:55,760
uh general purpose which is that risk

441
00:17:55,760 --> 00:17:56,640
five has

442
00:17:56,640 --> 00:17:58,799
that's actually quite a quite a good you

443
00:17:58,799 --> 00:18:00,880
know you can you can put secret keys and

444
00:18:00,880 --> 00:18:02,400
things into 32

445
00:18:02,400 --> 00:18:05,919
uh register so so um so that that's a

446
00:18:05,919 --> 00:18:07,600
scalar crypto

447
00:18:07,600 --> 00:18:10,640
so uh i'll advertise this

448
00:18:10,640 --> 00:18:14,320
the repo here uh v actually open source

449
00:18:14,320 --> 00:18:16,640
full open source cores are available

450
00:18:16,640 --> 00:18:19,120
that implement this um

451
00:18:19,120 --> 00:18:22,000
extension and and beef car formal uh

452
00:18:22,000 --> 00:18:23,200
verification

453
00:18:23,200 --> 00:18:24,880
things and and and industry

454
00:18:24,880 --> 00:18:27,600
participation a as well with

455
00:18:27,600 --> 00:18:29,760
that so you can find everything under

456
00:18:29,760 --> 00:18:30,720
that repo

457
00:18:30,720 --> 00:18:32,799
so the test group is pretty happy with

458
00:18:32,799 --> 00:18:34,400
the the current status of

459
00:18:34,400 --> 00:18:37,919
of this thing um and we are currently in

460
00:18:37,919 --> 00:18:40,880
in we've handed it over to opcode and

461
00:18:40,880 --> 00:18:43,679
consistency review so so that means that

462
00:18:43,679 --> 00:18:48,160
uh the other parts of the risk five um

463
00:18:48,160 --> 00:18:50,160
other risks by working groups are

464
00:18:50,160 --> 00:18:51,760
checking that there's no conflicts with

465
00:18:51,760 --> 00:18:54,240
any other instructions extensions and

466
00:18:54,240 --> 00:18:55,280
and such but

467
00:18:55,280 --> 00:18:57,440
the dash group uh has been very active

468
00:18:57,440 --> 00:18:58,880
in in 2020 and

469
00:18:58,880 --> 00:19:00,960
and we are pretty pretty happy with that

470
00:19:00,960 --> 00:19:02,160
of course currently

471
00:19:02,160 --> 00:19:05,360
most implementations of these are on on

472
00:19:05,360 --> 00:19:08,960
fpga but they they exist right

473
00:19:08,960 --> 00:19:11,600
um so so a little bit about the the

474
00:19:11,600 --> 00:19:12,160
whole

475
00:19:12,160 --> 00:19:15,120
whole uh instruction set extension bit

476
00:19:15,120 --> 00:19:18,000
so this is of course a risk instruction

477
00:19:18,000 --> 00:19:20,720
uh set so we don't want to just invent

478
00:19:20,720 --> 00:19:21,679
the instructions

479
00:19:21,679 --> 00:19:25,280
just for fun basically we we studied

480
00:19:25,280 --> 00:19:28,000
uh especially the bitmap extension which

481
00:19:28,000 --> 00:19:28,880
has uh

482
00:19:28,880 --> 00:19:30,799
very helpful things for crypto like

483
00:19:30,799 --> 00:19:32,559
rotations the the base

484
00:19:32,559 --> 00:19:34,320
uh risk five instruction set doesn't

485
00:19:34,320 --> 00:19:36,320
have that on or and

486
00:19:36,320 --> 00:19:39,520
of course uh those make uh chart three

487
00:19:39,520 --> 00:19:40,640
and char charco

488
00:19:40,640 --> 00:19:44,080
go a lot faster and they are essential

489
00:19:44,080 --> 00:19:45,600
for the lightweight crypto competition

490
00:19:45,600 --> 00:19:47,200
candidates that are

491
00:19:47,200 --> 00:19:50,880
are coming up also uh luckily enough

492
00:19:50,880 --> 00:19:53,120
in in bitmap we have carrierless

493
00:19:53,120 --> 00:19:54,320
multiplier that can do

494
00:19:54,320 --> 00:19:58,240
gcm so we did the like evaluation of how

495
00:19:58,240 --> 00:20:00,640
to do gcm on various architectures

496
00:20:00,640 --> 00:20:04,080
on 32-bit 64-bit

497
00:20:04,080 --> 00:20:06,400
and of course it's helpful for for like

498
00:20:06,400 --> 00:20:07,919
code based crypto and some other things

499
00:20:07,919 --> 00:20:08,480
as well

500
00:20:08,480 --> 00:20:11,039
so we took those and made them part of

501
00:20:11,039 --> 00:20:12,000
the

502
00:20:12,000 --> 00:20:14,559
of the crypto extension so if you have

503
00:20:14,559 --> 00:20:15,600
crypto extension

504
00:20:15,600 --> 00:20:17,039
you're using the same op codes and

505
00:20:17,039 --> 00:20:18,880
things same instructions by just a

506
00:20:18,880 --> 00:20:20,480
subset of bit money

507
00:20:20,480 --> 00:20:22,559
so we mandate that for example you'll

508
00:20:22,559 --> 00:20:24,320
always have rotations if

509
00:20:24,320 --> 00:20:27,440
if you you have the crypto extension but

510
00:20:27,440 --> 00:20:29,039
then there's specific things that really

511
00:20:29,039 --> 00:20:31,600
benefit uh from having special purpose

512
00:20:31,600 --> 00:20:34,240
instructions like aes so that you know

513
00:20:34,240 --> 00:20:35,360
your

514
00:20:35,360 --> 00:20:38,000
timing out x and such are are can be

515
00:20:38,000 --> 00:20:39,679
encountered that way

516
00:20:39,679 --> 00:20:42,240
so that that was basically the approach

517
00:20:42,240 --> 00:20:44,000
um

518
00:20:44,000 --> 00:20:46,400
minimal set uh for standard things that

519
00:20:46,400 --> 00:20:49,039
that you can use it at the most

520
00:20:49,039 --> 00:20:51,840
so aes there's two kinds of areas the

521
00:20:51,840 --> 00:20:52,320
the

522
00:20:52,320 --> 00:20:55,440
microcontroller the very lightweight

523
00:20:55,440 --> 00:20:58,480
aes is basically doing t

524
00:20:58,480 --> 00:21:01,600
tables in hardware so

525
00:21:01,600 --> 00:21:04,080
d table of course in assembly would be

526
00:21:04,080 --> 00:21:05,840
five instructions you would have to mask

527
00:21:05,840 --> 00:21:06,400
the

528
00:21:06,400 --> 00:21:07,840
by you would have to do address

529
00:21:07,840 --> 00:21:09,760
calculations do a table look up and sort

530
00:21:09,760 --> 00:21:10,720
that together

531
00:21:10,720 --> 00:21:13,280
so all of that is rolled into this a

532
00:21:13,280 --> 00:21:13,919
single

533
00:21:13,919 --> 00:21:16,960
cycle instruction which is very small so

534
00:21:16,960 --> 00:21:17,360
that

535
00:21:17,360 --> 00:21:20,000
it's about like 1 000 uh gate

536
00:21:20,000 --> 00:21:20,640
equivalents

537
00:21:20,640 --> 00:21:22,400
which means that aes all of the sudden

538
00:21:22,400 --> 00:21:25,200
becomes like a lightweight crypto

539
00:21:25,200 --> 00:21:27,679
this can be implemented on a on a on a

540
00:21:27,679 --> 00:21:29,760
32 bit core that has very little

541
00:21:29,760 --> 00:21:32,880
else than than any other extent this

542
00:21:32,880 --> 00:21:34,880
extension alone this instruction

543
00:21:34,880 --> 00:21:36,480
uh or these instructions here are

544
00:21:36,480 --> 00:21:38,960
sufficient to implement aes

545
00:21:38,960 --> 00:21:42,000
so so that's fun um

546
00:21:42,000 --> 00:21:44,000
for 64 bit there's a little bit

547
00:21:44,000 --> 00:21:45,440
different extension of course the

548
00:21:45,440 --> 00:21:47,440
biggest registers are double the size so

549
00:21:47,440 --> 00:21:48,799
so you can in two

550
00:21:48,799 --> 00:21:51,919
instructions process the 128-bit

551
00:21:51,919 --> 00:21:54,240
bit state you need six instructions per

552
00:21:54,240 --> 00:21:54,960
round

553
00:21:54,960 --> 00:21:59,120
uh that's that's again faster

554
00:21:59,120 --> 00:22:01,200
i mean that was five times faster and

555
00:22:01,200 --> 00:22:02,880
compared to if it's less inflation

556
00:22:02,880 --> 00:22:04,640
required for constant time it's

557
00:22:04,640 --> 00:22:06,640
that was more than ten times faster this

558
00:22:06,640 --> 00:22:07,679
is faster again

559
00:22:07,679 --> 00:22:09,440
but it's a little bit larger because but

560
00:22:09,440 --> 00:22:11,039
you can do these trade-offs

561
00:22:11,039 --> 00:22:14,320
we have a paper uh already on on on

562
00:22:14,320 --> 00:22:16,720
teaches or coming up in chess

563
00:22:16,720 --> 00:22:18,559
later this year about these sort of uh

564
00:22:18,559 --> 00:22:20,720
considerations we did consider quite a

565
00:22:20,720 --> 00:22:23,280
lot of different types of instructions

566
00:22:23,280 --> 00:22:26,080
right there's also a lightweight shot to

567
00:22:26,080 --> 00:22:26,799
support

568
00:22:26,799 --> 00:22:31,840
that that um well it's not so needed for

569
00:22:31,840 --> 00:22:35,600
for uh timing attack countermeasures but

570
00:22:35,600 --> 00:22:37,679
it does uh it's a very simple

571
00:22:37,679 --> 00:22:38,720
instruction it's just

572
00:22:38,720 --> 00:22:41,280
a bunch of constant rotations and uh

573
00:22:41,280 --> 00:22:42,240
source basically

574
00:22:42,240 --> 00:22:43,679
implementing these sum and sigma

575
00:22:43,679 --> 00:22:45,360
functions uh

576
00:22:45,360 --> 00:22:47,760
and similarly for sm3 with the chinese

577
00:22:47,760 --> 00:22:48,480
equivalent

578
00:22:48,480 --> 00:22:51,520
we have uh we have support for that

579
00:22:51,520 --> 00:22:54,559
and well the approach random

580
00:22:54,559 --> 00:22:56,240
is a little bit different so so this is

581
00:22:56,240 --> 00:22:58,799
an um entropy source interface uh

582
00:22:58,799 --> 00:23:01,799
it's it matches basically with the sb

583
00:23:01,799 --> 00:23:03,039
890b

584
00:23:03,039 --> 00:23:06,159
and and an aes31 approach

585
00:23:06,159 --> 00:23:08,960
we already have as4 drbg generation so

586
00:23:08,960 --> 00:23:10,880
so this is simply an entropy source

587
00:23:10,880 --> 00:23:12,720
interface defining the minimum entropy

588
00:23:12,720 --> 00:23:14,320
coming coming in there it's an

589
00:23:14,320 --> 00:23:17,840
it's it's not a user mode uh instruction

590
00:23:17,840 --> 00:23:21,360
intel had had some problems with that um

591
00:23:21,360 --> 00:23:24,480
some um yeah anyway it's a it's a uh

592
00:23:24,480 --> 00:23:26,159
it's a very simple instruction we've

593
00:23:26,159 --> 00:23:28,240
already been in in touch with bsi and

594
00:23:28,240 --> 00:23:28,960
nice you know

595
00:23:28,960 --> 00:23:30,720
hoping that this will actually meet the

596
00:23:30,720 --> 00:23:32,480
certification requirements for

597
00:23:32,480 --> 00:23:35,799
common criteria and uh and and vip spawn

598
00:23:35,799 --> 00:23:38,080
40-3

599
00:23:38,080 --> 00:23:41,360
so um so

600
00:23:41,360 --> 00:23:43,840
10 minutes is up so we got a bunch of

601
00:23:43,840 --> 00:23:44,799
stuff here that

602
00:23:44,799 --> 00:23:48,400
that i collected so how do i do rsa so

603
00:23:48,400 --> 00:23:51,039
um risk 5 is famous for not having a

604
00:23:51,039 --> 00:23:52,000
carry flag

605
00:23:52,000 --> 00:23:55,039
that one would need of course to do

606
00:23:55,039 --> 00:23:57,520
large additions but actually if you look

607
00:23:57,520 --> 00:23:59,440
at common implementations they use this

608
00:23:59,440 --> 00:24:01,279
redundant

609
00:24:01,279 --> 00:24:04,240
representation where you have a

610
00:24:04,240 --> 00:24:05,919
basically carry accumulation within

611
00:24:05,919 --> 00:24:06,640
those

612
00:24:06,640 --> 00:24:09,679
like a small bit of each bird uh this

613
00:24:09,679 --> 00:24:11,840
generic instructions that help with all

614
00:24:11,840 --> 00:24:13,440
kinds of uh things like side channel

615
00:24:13,440 --> 00:24:14,640
countermeasures

616
00:24:14,640 --> 00:24:18,400
table lookups constant time we also have

617
00:24:18,400 --> 00:24:19,120
a

618
00:24:19,120 --> 00:24:20,960
constant time multiplication requirement

619
00:24:20,960 --> 00:24:22,159
there's like an encoding

620
00:24:22,159 --> 00:24:24,720
for so that your rsa will be constant

621
00:24:24,720 --> 00:24:25,840
time

622
00:24:25,840 --> 00:24:29,120
um and uh of course we've um we've run

623
00:24:29,120 --> 00:24:31,440
all the post quantum algorithms on this

624
00:24:31,440 --> 00:24:33,760
just you know they are no surprises they

625
00:24:33,760 --> 00:24:35,360
are really

626
00:24:35,360 --> 00:24:37,600
behavior is like but uh they're similar

627
00:24:37,600 --> 00:24:39,600
similar class cpus

628
00:24:39,600 --> 00:24:42,159
um uh lots of questions about

629
00:24:42,159 --> 00:24:43,840
non-invasive which is the fibs

630
00:24:43,840 --> 00:24:47,919
for side channel uh yeah

631
00:24:47,919 --> 00:24:50,159
we don't have any this is an isa

632
00:24:50,159 --> 00:24:51,760
instruction set architecture

633
00:24:51,760 --> 00:24:53,440
proposal so so it's all up to the

634
00:24:53,440 --> 00:24:54,880
implementation and anyway

635
00:24:54,880 --> 00:24:56,559
if you certify something like that you

636
00:24:56,559 --> 00:24:58,080
are basically certified

637
00:24:58,080 --> 00:25:00,559
a cryptographic module which consists of

638
00:25:00,559 --> 00:25:01,840
um

639
00:25:01,840 --> 00:25:04,960
of um of the hardware and software for

640
00:25:04,960 --> 00:25:06,880
so for very specific hardware

641
00:25:06,880 --> 00:25:08,880
implementation you can probably certify

642
00:25:08,880 --> 00:25:11,039
uh some some such channel resistant

643
00:25:11,039 --> 00:25:12,799
things up to the highest

644
00:25:12,799 --> 00:25:16,320
like common criteria levels

645
00:25:16,320 --> 00:25:19,440
so yes coming to that i have been also

646
00:25:19,440 --> 00:25:21,279
able to answer questions so

647
00:25:21,279 --> 00:25:29,600
um so thank you

648
00:25:29,600 --> 00:25:32,080
so we have uh one question so far in the

649
00:25:32,080 --> 00:25:33,520
chat but i think this came earlier in

650
00:25:33,520 --> 00:25:35,279
the talk so it might need more context

651
00:25:35,279 --> 00:25:37,120
uh richard outer bridge asked what about

652
00:25:37,120 --> 00:25:40,320
apple's arm m1 yeah that's that's

653
00:25:40,320 --> 00:25:42,080
probably related to uh

654
00:25:42,080 --> 00:25:45,279
rosita which is called xm0 thing uh by

655
00:25:45,279 --> 00:25:45,919
the way

656
00:25:45,919 --> 00:25:49,120
we are uh definitely doing emulators on

657
00:25:49,120 --> 00:25:49,440
on

658
00:25:49,440 --> 00:25:51,520
leakage emulators also for risk five but

659
00:25:51,520 --> 00:25:52,799
that's that's that's

660
00:25:52,799 --> 00:25:56,080
you know yeah

661
00:25:56,080 --> 00:25:58,000
um so i have a question about the random

662
00:25:58,000 --> 00:25:59,200
number generation so

663
00:25:59,200 --> 00:26:01,360
um is there any um specification about

664
00:26:01,360 --> 00:26:02,640
the entropy source

665
00:26:02,640 --> 00:26:06,240
um yes there's this paper

666
00:26:06,240 --> 00:26:09,919
that kind of gives the idea about

667
00:26:09,919 --> 00:26:12,080
what the entropy output should be about

668
00:26:12,080 --> 00:26:14,400
so we don't opinionate about the noise

669
00:26:14,400 --> 00:26:15,760
source itself we just

670
00:26:15,760 --> 00:26:17,520
required to have certain amount of

671
00:26:17,520 --> 00:26:19,120
entropy and have the

672
00:26:19,120 --> 00:26:21,760
sort of uh health phase required by for

673
00:26:21,760 --> 00:26:22,799
certification

674
00:26:22,799 --> 00:26:24,480
there's this couple of uh things like

675
00:26:24,480 --> 00:26:26,799
for virtual machines it can be a sort of

676
00:26:26,799 --> 00:26:27,760
virtual

677
00:26:27,760 --> 00:26:30,559
entropy source but in that case we

678
00:26:30,559 --> 00:26:31,200
require

679
00:26:31,200 --> 00:26:33,600
uh it to be secure at least two five six

680
00:26:33,600 --> 00:26:34,799
bit secure

681
00:26:34,799 --> 00:26:38,799
this uh this yeah that paper gives a

682
00:26:38,799 --> 00:26:39,440
pretty big

683
00:26:39,440 --> 00:26:40,799
pretty good outline of the whole thing

684
00:26:40,799 --> 00:26:42,320
and there's also an awful lot of design

685
00:26:42,320 --> 00:26:43,120
rationale

686
00:26:43,120 --> 00:26:45,760
in the spec itself it's it it is

687
00:26:45,760 --> 00:26:47,440
recommendations to implement as

688
00:26:47,440 --> 00:26:50,240
sort of hereby dragons is how everyone

689
00:26:50,240 --> 00:26:51,360
else has gone wrong in the past

690
00:26:51,360 --> 00:26:52,400
implementing their

691
00:26:52,400 --> 00:26:54,159
their random number generator source of

692
00:26:54,159 --> 00:26:55,440
their energy source here's how we're

693
00:26:55,440 --> 00:26:56,159
learning from it

694
00:26:56,159 --> 00:26:58,000
so there's a lot of that yeah our

695
00:26:58,000 --> 00:27:00,240
rational for entropy source is

696
00:27:00,240 --> 00:27:04,240
this big chunk of of the specification

697
00:27:04,240 --> 00:27:06,640
so there's i guess um i failed to scroll

698
00:27:06,640 --> 00:27:07,919
down so now there's uh

699
00:27:07,919 --> 00:27:09,679
lots of discussion and questions in the

700
00:27:09,679 --> 00:27:11,200
chat so um

701
00:27:11,200 --> 00:27:12,960
let's see there's already some answers

702
00:27:12,960 --> 00:27:14,240
so uh jurgen focus

703
00:27:14,240 --> 00:27:15,760
asks uh when designing the crypto

704
00:27:15,760 --> 00:27:16,960
extensions did you also consider

705
00:27:16,960 --> 00:27:18,240
instructions that might be helpful to

706
00:27:18,240 --> 00:27:21,360
implement side channel countermeasures

707
00:27:21,360 --> 00:27:24,799
yes right there have been

708
00:27:24,799 --> 00:27:28,159
several proposals for that well

709
00:27:28,159 --> 00:27:31,440
ben and you yeah so it depends which

710
00:27:31,440 --> 00:27:32,720
kind of side channel countermeasures are

711
00:27:32,720 --> 00:27:34,480
talking about so for timing

712
00:27:34,480 --> 00:27:35,760
the most important one is things like

713
00:27:35,760 --> 00:27:37,840
table lookups in aes and

714
00:27:37,840 --> 00:27:39,760
that problem goes away if you wrap up

715
00:27:39,760 --> 00:27:41,279
that in an instruction so that's sort of

716
00:27:41,279 --> 00:27:42,640
done and out of the way

717
00:27:42,640 --> 00:27:44,159
um there are some general purpose

718
00:27:44,159 --> 00:27:46,480
instructions included in the

719
00:27:46,480 --> 00:27:48,480
proposals that make it really easy to do

720
00:27:48,480 --> 00:27:50,320
constant time s boxes

721
00:27:50,320 --> 00:27:52,480
um for other algorithms like camellia

722
00:27:52,480 --> 00:27:53,760
for example

723
00:27:53,760 --> 00:27:57,200
um for things like power and em um

724
00:27:57,200 --> 00:27:59,279
that's an open research question how do

725
00:27:59,279 --> 00:28:01,279
you give iso level guarantees

726
00:28:01,279 --> 00:28:03,679
about microarchitectural behavior and

727
00:28:03,679 --> 00:28:04,960
the same thing is true for sort of

728
00:28:04,960 --> 00:28:06,000
general purpose

729
00:28:06,000 --> 00:28:08,880
um timing attacks there's an interesting

730
00:28:08,880 --> 00:28:10,240
paper called the

731
00:28:10,240 --> 00:28:12,480
aisa or augmented iso that talks about

732
00:28:12,480 --> 00:28:13,919
it a lot of the timing

733
00:28:13,919 --> 00:28:15,360
but quite early on in the standards

734
00:28:15,360 --> 00:28:17,360
process we decided to sort of put

735
00:28:17,360 --> 00:28:19,440
power and em side channel considerations

736
00:28:19,440 --> 00:28:20,720
to one side

737
00:28:20,720 --> 00:28:23,440
yeah so when isa is a contract between

738
00:28:23,440 --> 00:28:25,120
the hardware and the programmer and

739
00:28:25,120 --> 00:28:27,440
and having having side channel things in

740
00:28:27,440 --> 00:28:29,360
there that would make it a lot

741
00:28:29,360 --> 00:28:31,919
you know a lot completely different

742
00:28:31,919 --> 00:28:34,399
looking thing than an isa specification

743
00:28:34,399 --> 00:28:36,320
the the point of the spec is to make

744
00:28:36,320 --> 00:28:37,440
sure that as

745
00:28:37,440 --> 00:28:39,200
long as you implement it functionally

746
00:28:39,200 --> 00:28:40,640
under the hood you can do all kinds of

747
00:28:40,640 --> 00:28:42,320
crazy clever things to make it

748
00:28:42,320 --> 00:28:44,000
whatever side channel secure that you

749
00:28:44,000 --> 00:28:45,360
care about um

750
00:28:45,360 --> 00:28:46,640
so if you're a specialist shop that

751
00:28:46,640 --> 00:28:48,640
builds risk five cores you know

752
00:28:48,640 --> 00:28:50,320
this should make your life a bit easier

753
00:28:50,320 --> 00:28:54,080
from a supporting software point of view

754
00:28:54,320 --> 00:28:56,480
um and then we also have a question from

755
00:28:56,480 --> 00:28:57,840
watsonlad who asks what

756
00:28:57,840 --> 00:28:59,279
sort of big number assistance is there i

757
00:28:59,279 --> 00:29:01,279
love to have a simple way to do carry

758
00:29:01,279 --> 00:29:02,640
chains and multiply

759
00:29:02,640 --> 00:29:04,080
accumulates with the full width and the

760
00:29:04,080 --> 00:29:08,158
hardware like uml from arm

761
00:29:09,760 --> 00:29:12,960
so risk five or maybe you want to go

762
00:29:12,960 --> 00:29:14,000
marcu

763
00:29:14,000 --> 00:29:16,399
yeah so the recommendation is is to use

764
00:29:16,399 --> 00:29:17,039
this uh

765
00:29:17,039 --> 00:29:20,240
redundant bit representation and

766
00:29:20,240 --> 00:29:23,279
and it works for vector two so so it's

767
00:29:23,279 --> 00:29:25,120
basically where you have

768
00:29:25,120 --> 00:29:27,679
eight bits out of 64 bits as a carry and

769
00:29:27,679 --> 00:29:30,000
then you do a laser reduction on that

770
00:29:30,000 --> 00:29:33,840
and it's it works on the on the scalar

771
00:29:33,840 --> 00:29:36,159
instruction set and also on vector

772
00:29:36,159 --> 00:29:37,919
vectorize

773
00:29:37,919 --> 00:29:42,399
multiplication and big integer but yeah

774
00:29:43,600 --> 00:29:46,320
general recommendation is rbr

775
00:29:46,320 --> 00:29:49,429
[Music]

776
00:29:49,760 --> 00:29:51,840
there are more questions in the chat but

777
00:29:51,840 --> 00:29:53,600
we are at 15 minutes so i guess we

778
00:29:53,600 --> 00:29:54,399
should

779
00:29:54,399 --> 00:29:56,080
get to the next talk so thank you very

780
00:29:56,080 --> 00:29:58,320
much and everybody keep

781
00:29:58,320 --> 00:30:00,720
keep uh keep conversing in the chat but

782
00:30:00,720 --> 00:30:02,080
make sure that you label your questions

783
00:30:02,080 --> 00:30:03,840
for for who they're aimed for so i can i

784
00:30:03,840 --> 00:30:06,159
can tell what's going on

785
00:30:06,159 --> 00:30:09,120
um so our next talk everything

786
00:30:09,120 --> 00:30:10,240
everything works

787
00:30:10,240 --> 00:30:12,640
so our next cut talk is cash out in sga

788
00:30:12,640 --> 00:30:14,960
axe how sgx fails in practice

789
00:30:14,960 --> 00:30:18,480
and it'll be given by stefan and andrew

790
00:30:18,480 --> 00:30:20,799
hello everyone um i'm stefan and

791
00:30:20,799 --> 00:30:22,159
together with andrew we'll be talking

792
00:30:22,159 --> 00:30:25,120
about cash out and his checks today

793
00:30:25,120 --> 00:30:28,399
but first a quick recap so back in 2018

794
00:30:28,399 --> 00:30:30,480
you might remember these logos

795
00:30:30,480 --> 00:30:33,440
back in 2018 we've got a new class of

796
00:30:33,440 --> 00:30:34,960
speculative and transient execution

797
00:30:34,960 --> 00:30:37,520
attacks and we basically saw a text like

798
00:30:37,520 --> 00:30:40,399
meltdown foreshadow inspector

799
00:30:40,399 --> 00:30:42,799
and to

800
00:30:44,480 --> 00:30:47,679
stop working so

801
00:30:47,679 --> 00:30:49,919
how these attacks work basically we have

802
00:30:49,919 --> 00:30:51,440
a basic cache hierarchy here and we have

803
00:30:51,440 --> 00:30:53,120
our execution core

804
00:30:53,120 --> 00:30:55,360
and we have like our l1d cache and

805
00:30:55,360 --> 00:30:57,039
meltdown and ford shadow basically

806
00:30:57,039 --> 00:31:00,640
are able to leak data from the l1d cache

807
00:31:00,640 --> 00:31:02,320
and of course this is very bad so this

808
00:31:02,320 --> 00:31:04,159
prompted the right mitigation efforts

809
00:31:04,159 --> 00:31:06,640
and if you buy it like the cpu you see

810
00:31:06,640 --> 00:31:08,880
here the i9 9900k

811
00:31:08,880 --> 00:31:10,320
it's basically no longer possible to

812
00:31:10,320 --> 00:31:12,159
leak from the caches as you're no longer

813
00:31:12,159 --> 00:31:12,640
able to

814
00:31:12,640 --> 00:31:15,840
use small down unfortunately um

815
00:31:15,840 --> 00:31:18,399
then in 2019 it actually turns out that

816
00:31:18,399 --> 00:31:19,679
there are many more interesting buffers

817
00:31:19,679 --> 00:31:20,640
to use

818
00:31:20,640 --> 00:31:22,559
so if you look closer at the diagram you

819
00:31:22,559 --> 00:31:24,159
see like a field buffer the subwoofer

820
00:31:24,159 --> 00:31:25,519
and the loadport

821
00:31:25,519 --> 00:31:27,840
and in 2019 we actually saw a new clause

822
00:31:27,840 --> 00:31:28,880
of attacks called

823
00:31:28,880 --> 00:31:32,000
mds or microsexual data sampling and

824
00:31:32,000 --> 00:31:34,000
these are basically able to sample data

825
00:31:34,000 --> 00:31:34,320
from

826
00:31:34,320 --> 00:31:35,919
from these buffers as data passes

827
00:31:35,919 --> 00:31:38,000
through so what mds does

828
00:31:38,000 --> 00:31:39,840
it basically targets these internal cpu

829
00:31:39,840 --> 00:31:41,360
buffers

830
00:31:41,360 --> 00:31:44,720
um so basically nds allows you to

831
00:31:44,720 --> 00:31:46,559
use faulting or assisting loads

832
00:31:46,559 --> 00:31:48,080
basically for instance through

833
00:31:48,080 --> 00:31:49,120
speculation

834
00:31:49,120 --> 00:31:50,640
and that way you can access other

835
00:31:50,640 --> 00:31:52,880
people's data and this works across

836
00:31:52,880 --> 00:31:53,760
processes

837
00:31:53,760 --> 00:31:57,039
vms and even intel sgx and basically

838
00:31:57,039 --> 00:31:59,919
what this meant means is that if you

839
00:31:59,919 --> 00:32:01,519
looked at the news

840
00:32:01,519 --> 00:32:03,360
it basically had the same implication as

841
00:32:03,360 --> 00:32:05,120
meltdown and it was also sometimes

842
00:32:05,120 --> 00:32:07,679
dubbed second meltdown

843
00:32:07,679 --> 00:32:09,840
so what nds does is like if we have like

844
00:32:09,840 --> 00:32:11,440
a malicious user

845
00:32:11,440 --> 00:32:13,360
as data passes through the field buffer

846
00:32:13,360 --> 00:32:15,600
and this is basically able to sample it

847
00:32:15,600 --> 00:32:17,440
but as only as long as it passes through

848
00:32:17,440 --> 00:32:19,279
the filter

849
00:32:19,279 --> 00:32:21,120
so what this means is that mds attacks

850
00:32:21,120 --> 00:32:22,640
are basically like drinking from fire

851
00:32:22,640 --> 00:32:23,200
hose

852
00:32:23,200 --> 00:32:24,799
you just get whatever data is in flight

853
00:32:24,799 --> 00:32:26,320
at the time um

854
00:32:26,320 --> 00:32:27,279
and the hands also the name

855
00:32:27,279 --> 00:32:28,880
microstructural data sampling because

856
00:32:28,880 --> 00:32:30,320
you're just sampling data from these

857
00:32:30,320 --> 00:32:32,480
microstructural buffers

858
00:32:32,480 --> 00:32:34,159
but it also means that at the same time

859
00:32:34,159 --> 00:32:35,360
you have no control of what you're

860
00:32:35,360 --> 00:32:36,559
getting as you're just

861
00:32:36,559 --> 00:32:38,000
leaking whatever data is in flight at

862
00:32:38,000 --> 00:32:40,000
the time in those buffers

863
00:32:40,000 --> 00:32:41,760
so how to dental mitigate this well

864
00:32:41,760 --> 00:32:43,360
intel just um

865
00:32:43,360 --> 00:32:45,200
update release a microcode update that

866
00:32:45,200 --> 00:32:46,799
patches the 4w instruction

867
00:32:46,799 --> 00:32:48,720
and the w instruction is used to flash

868
00:32:48,720 --> 00:32:50,399
these internal cpu buffers up on every

869
00:32:50,399 --> 00:32:51,679
context which for instance

870
00:32:51,679 --> 00:32:54,240
when switching between processes and

871
00:32:54,240 --> 00:32:55,919
this actually brings us to part two of

872
00:32:55,919 --> 00:32:57,519
the talk so cash out

873
00:32:57,519 --> 00:32:59,279
so if you look a bit closer at these

874
00:32:59,279 --> 00:33:01,360
mitigations they just flushed internal

875
00:33:01,360 --> 00:33:02,720
cpu buffers

876
00:33:02,720 --> 00:33:04,240
um but this was actually not fixed it

877
00:33:04,240 --> 00:33:06,159
would cause behind mds it just ensures

878
00:33:06,159 --> 00:33:08,559
that the data is no longer present there

879
00:33:08,559 --> 00:33:11,360
but it it doesn't really fix the fact

880
00:33:11,360 --> 00:33:12,880
that you can still leak data from those

881
00:33:12,880 --> 00:33:14,960
buffers so if you somehow can get data

882
00:33:14,960 --> 00:33:16,320
inside of those buffers

883
00:33:16,320 --> 00:33:18,880
you should be able to leak it so this

884
00:33:18,880 --> 00:33:19,679
brings us to

885
00:33:19,679 --> 00:33:21,360
an important question so is flushing

886
00:33:21,360 --> 00:33:24,240
buffer sufficient as a mitigation and

887
00:33:24,240 --> 00:33:27,039
as a bonus um as with nds you get like

888
00:33:27,039 --> 00:33:28,880
whatever data's in flight like you you

889
00:33:28,880 --> 00:33:29,200
see

890
00:33:29,200 --> 00:33:31,519
you saw this girl can we actually be

891
00:33:31,519 --> 00:33:33,679
like this cat and get some more control

892
00:33:33,679 --> 00:33:36,720
over um over the leakage

893
00:33:36,720 --> 00:33:39,360
so if we look at the at the mds works

894
00:33:39,360 --> 00:33:40,880
for instance the real paper

895
00:33:40,880 --> 00:33:43,519
um this code basically mentions that um

896
00:33:43,519 --> 00:33:44,799
if you evac data from the

897
00:33:44,799 --> 00:33:46,559
from the cache it's basically forced

898
00:33:46,559 --> 00:33:47,840
into the fill buffer

899
00:33:47,840 --> 00:33:49,679
and the zombie layer paper also reports

900
00:33:49,679 --> 00:33:51,840
a 0.1 bytes per second leakage despite

901
00:33:51,840 --> 00:33:53,279
the mitigation

902
00:33:53,279 --> 00:33:55,039
um and this residual leakage is actually

903
00:33:55,039 --> 00:33:56,480
worse

904
00:33:56,480 --> 00:33:58,000
so what we found with cash out is that

905
00:33:58,000 --> 00:33:59,919
there is exactly a data pad

906
00:33:59,919 --> 00:34:02,559
um from the l1d cache to the l2 cache

907
00:34:02,559 --> 00:34:03,679
that

908
00:34:03,679 --> 00:34:05,039
gets triggered through eviction so

909
00:34:05,039 --> 00:34:06,640
whenever you evict something from the

910
00:34:06,640 --> 00:34:07,600
l1d cache

911
00:34:07,600 --> 00:34:08,800
it actually passes through the field

912
00:34:08,800 --> 00:34:11,119
buffer before reaching the level two

913
00:34:11,119 --> 00:34:12,159
cache

914
00:34:12,159 --> 00:34:13,599
um but remember that the line field

915
00:34:13,599 --> 00:34:15,440
buffers are still leaking so if

916
00:34:15,440 --> 00:34:17,440
we can actually manage to get data

917
00:34:17,440 --> 00:34:18,719
through the field buffer

918
00:34:18,719 --> 00:34:20,879
we should be able to sample it so how do

919
00:34:20,879 --> 00:34:21,760
we exploit

920
00:34:21,760 --> 00:34:24,800
um evictions so we have a cache which is

921
00:34:24,800 --> 00:34:26,560
fast we have a fill buffer next to it

922
00:34:26,560 --> 00:34:28,159
and we have a dram which is slow

923
00:34:28,159 --> 00:34:30,079
and as the program runs and the victim's

924
00:34:30,079 --> 00:34:31,760
data ends up in the field buffer and the

925
00:34:31,760 --> 00:34:33,119
cache

926
00:34:33,119 --> 00:34:34,800
and now as the operating system switches

927
00:34:34,800 --> 00:34:36,480
to the attacker the 4w instruction

928
00:34:36,480 --> 00:34:38,000
basically ensures that the fill buffer

929
00:34:38,000 --> 00:34:40,079
no longer contains the victim's data

930
00:34:40,079 --> 00:34:42,159
so can we somehow get the data from the

931
00:34:42,159 --> 00:34:44,239
cache into the field buffer

932
00:34:44,239 --> 00:34:46,079
so the cache is divided into different

933
00:34:46,079 --> 00:34:48,159
sets and if you have like the address of

934
00:34:48,159 --> 00:34:49,918
your data determines into which cassette

935
00:34:49,918 --> 00:34:51,440
the data is going to be

936
00:34:51,440 --> 00:34:53,199
so what the attacker does the attacker

937
00:34:53,199 --> 00:34:54,800
just reads addresses that all map to the

938
00:34:54,800 --> 00:34:55,918
same cache set

939
00:34:55,918 --> 00:34:57,680
to basically fill the cache set with its

940
00:34:57,680 --> 00:34:59,440
own data and because there's no room

941
00:34:59,440 --> 00:35:01,280
left for the for the victims data

942
00:35:01,280 --> 00:35:03,760
it has to be evicted so it ends up in

943
00:35:03,760 --> 00:35:04,800
the field buffer

944
00:35:04,800 --> 00:35:06,640
and in the meanwhile the cpu just writes

945
00:35:06,640 --> 00:35:08,560
it back to the dram

946
00:35:08,560 --> 00:35:09,920
and this basically allows the attacker

947
00:35:09,920 --> 00:35:12,160
to perform as an attack simulator mds

948
00:35:12,160 --> 00:35:14,240
where it just performs a faulty load

949
00:35:14,240 --> 00:35:16,320
samples the data from the fill buffer

950
00:35:16,320 --> 00:35:17,839
and then extracts the data

951
00:35:17,839 --> 00:35:21,280
back to the attack so what we found with

952
00:35:21,280 --> 00:35:22,560
cachet is that you're actually able to

953
00:35:22,560 --> 00:35:25,040
link at 2.85 kilobytes per second rather

954
00:35:25,040 --> 00:35:26,880
than the 0.1 bytes per second that

955
00:35:26,880 --> 00:35:28,400
zombielog mentions

956
00:35:28,400 --> 00:35:30,000
and cash out actually targets data at

957
00:35:30,000 --> 00:35:31,920
rest rather than in flight so with mds

958
00:35:31,920 --> 00:35:33,760
you just have to rely on the victim

959
00:35:33,760 --> 00:35:35,359
accessing the data continuously to

960
00:35:35,359 --> 00:35:37,200
ensure that it's in the lightful buffer

961
00:35:37,200 --> 00:35:38,640
and then while the victim is running you

962
00:35:38,640 --> 00:35:40,160
can basically sample the data from the

963
00:35:40,160 --> 00:35:41,200
line folder

964
00:35:41,200 --> 00:35:42,720
with cache out we actually have control

965
00:35:42,720 --> 00:35:44,640
over when the data ends up into the lfb

966
00:35:44,640 --> 00:35:46,400
we just effect like the particular cache

967
00:35:46,400 --> 00:35:47,200
that we want

968
00:35:47,200 --> 00:35:48,560
and we can actually do this long after

969
00:35:48,560 --> 00:35:50,480
the victim access the data

970
00:35:50,480 --> 00:35:52,079
and because we have control over the

971
00:35:52,079 --> 00:35:53,599
particular cache set we can actually

972
00:35:53,599 --> 00:35:56,160
structure data like as and rsa keys

973
00:35:56,160 --> 00:35:58,480
we can leak neural network rates we can

974
00:35:58,480 --> 00:35:59,359
even break hazel

975
00:35:59,359 --> 00:36:01,280
and the kernel data and this works

976
00:36:01,280 --> 00:36:02,560
across vms

977
00:36:02,560 --> 00:36:05,599
as well as including hypervise

978
00:36:05,599 --> 00:36:07,680
so to put it even more to the test we

979
00:36:07,680 --> 00:36:09,520
put the picture of the mona lisa

980
00:36:09,520 --> 00:36:12,400
inside an asgex enclave and we basically

981
00:36:12,400 --> 00:36:13,920
managed to restrict it

982
00:36:13,920 --> 00:36:16,320
using cache and with that andrew is

983
00:36:16,320 --> 00:36:17,680
going to talk to you about

984
00:36:17,680 --> 00:36:19,599
the exact implications of cash out for

985
00:36:19,599 --> 00:36:22,079
sgx

986
00:36:25,040 --> 00:36:27,920
all right thanks stefan so uh intel's

987
00:36:27,920 --> 00:36:30,480
sgx is a set of cpu features that allows

988
00:36:30,480 --> 00:36:31,520
developers to

989
00:36:31,520 --> 00:36:33,520
run code and store secrets inside of

990
00:36:33,520 --> 00:36:35,760
enclaves such that nothing uh

991
00:36:35,760 --> 00:36:37,599
neither the os nor the hypervisor nor

992
00:36:37,599 --> 00:36:38,880
anything but the enclave

993
00:36:38,880 --> 00:36:41,520
can read the enclave's contents sgx also

994
00:36:41,520 --> 00:36:43,040
provides remote antistation

995
00:36:43,040 --> 00:36:44,800
which allows the enclave to prove to a

996
00:36:44,800 --> 00:36:46,960
remote client that the enclave has been

997
00:36:46,960 --> 00:36:48,160
initialized properly

998
00:36:48,160 --> 00:36:52,240
and on genuine sjx hardware to do this

999
00:36:52,240 --> 00:36:54,960
sgx stores a key called the epic key

1000
00:36:54,960 --> 00:36:56,400
enhanced privacy id

1001
00:36:56,400 --> 00:36:59,200
inside each cpu the epic key is used to

1002
00:36:59,200 --> 00:37:00,720
sign the contents of the enclave

1003
00:37:00,720 --> 00:37:03,200
along with a diffie-hellman key exchange

1004
00:37:03,200 --> 00:37:04,880
this produces a quote

1005
00:37:04,880 --> 00:37:06,240
which can be forwarded to the remote

1006
00:37:06,240 --> 00:37:08,880
client as proof

1007
00:37:08,880 --> 00:37:11,520
and the takeaway of all this is that all

1008
00:37:11,520 --> 00:37:13,200
the trust is based on the assumption

1009
00:37:13,200 --> 00:37:14,400
that the fbkey

1010
00:37:14,400 --> 00:37:17,280
cannot be used by an adversary to forge

1011
00:37:17,280 --> 00:37:19,839
arbitrary quotes

1012
00:37:19,839 --> 00:37:21,680
with cash out however we broke this

1013
00:37:21,680 --> 00:37:23,200
assumption by extracting the epic

1014
00:37:23,200 --> 00:37:25,119
private key

1015
00:37:25,119 --> 00:37:26,880
as proof of this we deployed the sgi

1016
00:37:26,880 --> 00:37:28,720
spot on twitter which will attest

1017
00:37:28,720 --> 00:37:31,520
anything tweeted at it using that key

1018
00:37:31,520 --> 00:37:33,119
and back when we first released it in

1019
00:37:33,119 --> 00:37:35,599
june it actually signed over 100 quotes

1020
00:37:35,599 --> 00:37:38,160
within two hours after which it was

1021
00:37:38,160 --> 00:37:40,480
blocked by github

1022
00:37:40,480 --> 00:37:41,920
and after the public release of the

1023
00:37:41,920 --> 00:37:43,599
paper and the bot

1024
00:37:43,599 --> 00:37:45,119
the key that was used by the bot was

1025
00:37:45,119 --> 00:37:46,400
actually still trusted for an entire

1026
00:37:46,400 --> 00:37:47,440
month

1027
00:37:47,440 --> 00:37:50,160
and this is because updating the sjx tcp

1028
00:37:50,160 --> 00:37:51,839
requires users to uh

1029
00:37:51,839 --> 00:37:54,960
install bios updates and not all users

1030
00:37:54,960 --> 00:37:56,720
are tech savvy enough to do that quickly

1031
00:37:56,720 --> 00:37:58,880
and so intel can't invalidate them too

1032
00:37:58,880 --> 00:38:01,040
quickly

1033
00:38:01,040 --> 00:38:03,520
to address this we and to be responsible

1034
00:38:03,520 --> 00:38:05,119
we hard-coded mri signer

1035
00:38:05,119 --> 00:38:09,839
to prevent abuse of the uh of the bot

1036
00:38:10,160 --> 00:38:13,440
so now let's look at a case study uh uh

1037
00:38:13,440 --> 00:38:15,440
using signal as an example to see how

1038
00:38:15,440 --> 00:38:17,040
cash out's extraction of the epic key

1039
00:38:17,040 --> 00:38:18,320
can impact a real world

1040
00:38:18,320 --> 00:38:21,280
application so so back in may sigma

1041
00:38:21,280 --> 00:38:22,960
started prompting users to add pins to

1042
00:38:22,960 --> 00:38:24,400
their account

1043
00:38:24,400 --> 00:38:26,560
and this was to deploy a new technology

1044
00:38:26,560 --> 00:38:29,119
called secure value recovery svr

1045
00:38:29,119 --> 00:38:31,119
and the idea behind that is that it can

1046
00:38:31,119 --> 00:38:33,359
be used to backup contacts in the cloud

1047
00:38:33,359 --> 00:38:34,960
and enable non-phone number based

1048
00:38:34,960 --> 00:38:36,640
addressing

1049
00:38:36,640 --> 00:38:38,400
you may be thinking however isn't the

1050
00:38:38,400 --> 00:38:39,680
selling point of signal that they don't

1051
00:38:39,680 --> 00:38:41,680
store info about users

1052
00:38:41,680 --> 00:38:43,359
well to address this the data is

1053
00:38:43,359 --> 00:38:44,880
encrypted under a key that is derived

1054
00:38:44,880 --> 00:38:46,320
from both the user's pin

1055
00:38:46,320 --> 00:38:48,720
and a random seed and done in such a way

1056
00:38:48,720 --> 00:38:50,240
that signal themselves cannot decrypt

1057
00:38:50,240 --> 00:38:51,520
the data

1058
00:38:51,520 --> 00:38:52,960
the only problem is that the system

1059
00:38:52,960 --> 00:38:54,880
relies on sgx

1060
00:38:54,880 --> 00:38:56,560
so let's look at a simplified overview

1061
00:38:56,560 --> 00:38:58,400
of how sbr works

1062
00:38:58,400 --> 00:39:00,880
the user will first select their pin

1063
00:39:00,880 --> 00:39:02,079
that will get hashed

1064
00:39:02,079 --> 00:39:04,320
and expanded into a value called c2

1065
00:39:04,320 --> 00:39:07,760
which is stored on signal servers

1066
00:39:07,760 --> 00:39:10,800
then c2 will be combined with a 256-bit

1067
00:39:10,800 --> 00:39:11,760
random seed

1068
00:39:11,760 --> 00:39:14,240
to generate an encryption key when the

1069
00:39:14,240 --> 00:39:15,440
user wants to

1070
00:39:15,440 --> 00:39:17,599
store their data it will get encrypted

1071
00:39:17,599 --> 00:39:19,119
under that key

1072
00:39:19,119 --> 00:39:22,240
and finally stored on signal servers

1073
00:39:22,240 --> 00:39:23,599
and so the encryption key is derived

1074
00:39:23,599 --> 00:39:25,440
from both the user's secret pin and a

1075
00:39:25,440 --> 00:39:27,440
random seed

1076
00:39:27,440 --> 00:39:29,440
however the user's pin is likely just a

1077
00:39:29,440 --> 00:39:30,640
four digit number

1078
00:39:30,640 --> 00:39:33,440
which can easily be brute force so to

1079
00:39:33,440 --> 00:39:34,560
solve this

1080
00:39:34,560 --> 00:39:36,320
c2 and the random seed are stored in an

1081
00:39:36,320 --> 00:39:38,240
enclave and the enclave

1082
00:39:38,240 --> 00:39:39,520
rate limits the guessing attempts

1083
00:39:39,520 --> 00:39:41,440
against c2

1084
00:39:41,440 --> 00:39:43,200
so this works properly the user's data

1085
00:39:43,200 --> 00:39:45,040
is still secure even when the user's pin

1086
00:39:45,040 --> 00:39:47,599
is short and memorable

1087
00:39:47,599 --> 00:39:50,720
however uh using cash out

1088
00:39:50,720 --> 00:39:52,240
an attacker with access to the signal

1089
00:39:52,240 --> 00:39:53,920
server storing c2

1090
00:39:53,920 --> 00:39:55,839
can just use cash out to recover c2 from

1091
00:39:55,839 --> 00:39:57,599
the l1 cache

1092
00:39:57,599 --> 00:39:59,119
uh this however requires some side

1093
00:39:59,119 --> 00:40:01,359
channel knowledge alternatively we can

1094
00:40:01,359 --> 00:40:03,040
exploit the trust placed in the epic

1095
00:40:03,040 --> 00:40:06,000
keys that we did that we extracted

1096
00:40:06,000 --> 00:40:08,240
so we just take a closer look at how c2

1097
00:40:08,240 --> 00:40:10,000
and the random seed are stored

1098
00:40:10,000 --> 00:40:13,200
they're actually stored as a distributed

1099
00:40:13,200 --> 00:40:16,960
log using raft where each of the sgx

1100
00:40:16,960 --> 00:40:20,079
replicas is storing c2 and the random

1101
00:40:20,079 --> 00:40:22,319
seed

1102
00:40:22,319 --> 00:40:23,760
however if the cluster's network is

1103
00:40:23,760 --> 00:40:25,599
compromised whether by a subpoena or

1104
00:40:25,599 --> 00:40:28,240
coercion or a hack machine

1105
00:40:28,240 --> 00:40:30,400
an attacker can use the stolen epic keys

1106
00:40:30,400 --> 00:40:31,680
to forge a quote

1107
00:40:31,680 --> 00:40:33,280
proving that the malicious replica is

1108
00:40:33,280 --> 00:40:34,880
running on sgx

1109
00:40:34,880 --> 00:40:38,400
even though it's not then if this quote

1110
00:40:38,400 --> 00:40:39,680
is given to the network it can

1111
00:40:39,680 --> 00:40:42,480
it can um request that the raf network

1112
00:40:42,480 --> 00:40:46,319
replicate the entire log to the fake

1113
00:40:47,359 --> 00:40:49,680
then since it's not running sgx c2 and

1114
00:40:49,680 --> 00:40:50,880
the random seed can be read

1115
00:40:50,880 --> 00:40:53,280
in plain text and and then the user's

1116
00:40:53,280 --> 00:40:56,480
pin can be brought forth from there

1117
00:40:56,480 --> 00:40:59,119
uh so in summary cash out breaches xbx's

1118
00:40:59,119 --> 00:41:00,160
confidentiality

1119
00:41:00,160 --> 00:41:01,680
allowing an attacker to masquerade as a

1120
00:41:01,680 --> 00:41:04,800
legitimate sgx enclave even if it's not

1121
00:41:04,800 --> 00:41:06,319
and and while it's good that signal is

1122
00:41:06,319 --> 00:41:08,160
thinking about side channels against sgx

1123
00:41:08,160 --> 00:41:10,400
by inserting l fences before each branch

1124
00:41:10,400 --> 00:41:11,920
and using red pallenes

1125
00:41:11,920 --> 00:41:14,880
these don't actually mitigate cash out

1126
00:41:14,880 --> 00:41:16,800
and so stx cannot be relied upon to

1127
00:41:16,800 --> 00:41:18,319
limit guessing attempts

1128
00:41:18,319 --> 00:41:19,760
this means that signal should still

1129
00:41:19,760 --> 00:41:22,800
require strong passwords for svr

1130
00:41:22,800 --> 00:41:25,119
and uh and so while we did extract the

1131
00:41:25,119 --> 00:41:27,119
epid key using cash out

1132
00:41:27,119 --> 00:41:28,560
we didn't concretely demonstrate the

1133
00:41:28,560 --> 00:41:30,319
signal attack because it requires

1134
00:41:30,319 --> 00:41:32,000
it assumes a malicious signal server

1135
00:41:32,000 --> 00:41:33,680
with access to the cluster

1136
00:41:33,680 --> 00:41:35,920
so you can't do this at home however

1137
00:41:35,920 --> 00:41:36,800
this is also

1138
00:41:36,800 --> 00:41:38,240
the threat model that signal was built

1139
00:41:38,240 --> 00:41:40,400
with in mind

1140
00:41:40,400 --> 00:41:43,680
so as a counter measure until uh deploy

1141
00:41:43,680 --> 00:41:45,359
a dedicated microcode updates on june

1142
00:41:45,359 --> 00:41:47,040
20th

1143
00:41:47,040 --> 00:41:48,800
and with that i am happy to take

1144
00:41:48,800 --> 00:41:51,119
questions

1145
00:41:56,319 --> 00:41:58,240
so i'll start with one question which is

1146
00:41:58,240 --> 00:41:59,680
um what

1147
00:41:59,680 --> 00:42:01,760
so for the for the signing bot what were

1148
00:42:01,760 --> 00:42:03,280
the counter measures that you took

1149
00:42:03,280 --> 00:42:04,400
against

1150
00:42:04,400 --> 00:42:08,640
abuse yeah um so

1151
00:42:08,640 --> 00:42:10,800
the there's a field that is signed in

1152
00:42:10,800 --> 00:42:11,839
the quote

1153
00:42:11,839 --> 00:42:16,400
that is the mr uh signer

1154
00:42:19,119 --> 00:42:20,960
mr enclave and so you can see that those

1155
00:42:20,960 --> 00:42:23,280
values are hard to sgx how sgx feels in

1156
00:42:23,280 --> 00:42:23,920
practice

1157
00:42:23,920 --> 00:42:25,680
and mron played when good on facebook

1158
00:42:25,680 --> 00:42:28,240
bad so it could only masquerade as

1159
00:42:28,240 --> 00:42:30,720
an enclave that happen to use those same

1160
00:42:30,720 --> 00:42:31,520
fields

1161
00:42:31,520 --> 00:42:34,960
which is um yeah it's unlikely anyone's

1162
00:42:34,960 --> 00:42:37,440
using those

1163
00:42:37,520 --> 00:42:39,599
so did you have any uh evidence of

1164
00:42:39,599 --> 00:42:40,880
people trying to

1165
00:42:40,880 --> 00:42:44,400
misuse this for actual attacks not

1166
00:42:44,400 --> 00:42:47,440
uh no um

1167
00:42:47,440 --> 00:42:50,319
yeah no

1168
00:42:51,760 --> 00:42:54,560
and why why did it get blocked on github

1169
00:42:54,560 --> 00:42:56,839
and not on twitter

1170
00:42:56,839 --> 00:42:59,280
um it was actually it's taken down from

1171
00:42:59,280 --> 00:42:59,920
both

1172
00:42:59,920 --> 00:43:04,960
um yeah

1173
00:43:08,079 --> 00:43:10,560
are there other um threat scenarios

1174
00:43:10,560 --> 00:43:11,200
beyond the

1175
00:43:11,200 --> 00:43:13,760
the signal case that um you could see

1176
00:43:13,760 --> 00:43:14,560
this being

1177
00:43:14,560 --> 00:43:18,960
applied in um

1178
00:43:19,119 --> 00:43:20,720
yeah so so we should signal the case

1179
00:43:20,720 --> 00:43:23,040
study because that's actually um

1180
00:43:23,040 --> 00:43:24,720
a widely deployed application that's

1181
00:43:24,720 --> 00:43:26,079
using sdx

1182
00:43:26,079 --> 00:43:27,920
uh there are a few others that we

1183
00:43:27,920 --> 00:43:29,359
discussed in the paper

1184
00:43:29,359 --> 00:43:32,160
um more sort of experimental sjx use

1185
00:43:32,160 --> 00:43:34,480
cases

1186
00:43:34,880 --> 00:43:38,000
there are some academic works using sgx

1187
00:43:38,000 --> 00:43:42,720
combined with ethereum um such as um

1188
00:43:42,720 --> 00:43:46,720
uh oasis

1189
00:43:46,720 --> 00:43:49,040
um

1190
00:43:50,240 --> 00:43:54,319
yeah then

1191
00:43:54,319 --> 00:43:56,640
uh we have a question i think i think

1192
00:43:56,640 --> 00:43:58,240
this is aimed at at this talk so uh

1193
00:43:58,240 --> 00:43:59,520
richard otterbridge asks which

1194
00:43:59,520 --> 00:44:01,680
mainstream architecture is eg intel amd

1195
00:44:01,680 --> 00:44:05,118
apple have been microcode patched

1196
00:44:06,400 --> 00:44:09,520
you want to take that questions down

1197
00:44:11,280 --> 00:44:14,720
um so basically as it uses uh like

1198
00:44:14,720 --> 00:44:16,800
as skyshark relies heavily on ental tsx

1199
00:44:16,800 --> 00:44:18,400
and sjx which are like intel only

1200
00:44:18,400 --> 00:44:19,440
technologies edges

1201
00:44:19,440 --> 00:44:21,520
until that's basically affected by these

1202
00:44:21,520 --> 00:44:22,560
by these issues

1203
00:44:22,560 --> 00:44:23,839
and we haven't heard from any of the

1204
00:44:23,839 --> 00:44:25,040
other companies if they actually have

1205
00:44:25,040 --> 00:44:26,640
similar issues

1206
00:44:26,640 --> 00:44:29,280
so only intel really world arts

1207
00:44:29,280 --> 00:44:31,200
microcode updates

1208
00:44:31,200 --> 00:44:37,680
back in june basically

1209
00:44:37,680 --> 00:44:40,000
um i guess we are at time so thank you

1210
00:44:40,000 --> 00:44:41,599
very much and and further questions can

1211
00:44:41,599 --> 00:44:44,079
be posted in the zulu chat

1212
00:44:44,079 --> 00:44:46,079
so i guess we should move on to our next

1213
00:44:46,079 --> 00:44:47,359
speakers

1214
00:44:47,359 --> 00:44:51,839
thank you

1215
00:44:53,119 --> 00:44:56,240
so our last talk of the session um is

1216
00:44:56,240 --> 00:44:57,280
going to be

1217
00:44:57,280 --> 00:44:59,280
my car my other car is your car

1218
00:44:59,280 --> 00:45:01,119
compromising the tesla model x keyless

1219
00:45:01,119 --> 00:45:01,920
entry system

1220
00:45:01,920 --> 00:45:05,359
and will be given by linux

1221
00:45:05,359 --> 00:45:07,599
thank you um so this talk is about

1222
00:45:07,599 --> 00:45:09,280
compromising the tesla multi-skills

1223
00:45:09,280 --> 00:45:10,480
entry system

1224
00:45:10,480 --> 00:45:12,400
as this is a very brief talk i will

1225
00:45:12,400 --> 00:45:14,240
mainly cover the issues that we found

1226
00:45:14,240 --> 00:45:16,480
and how we exploited them but not how we

1227
00:45:16,480 --> 00:45:18,640
found these issues exactly

1228
00:45:18,640 --> 00:45:20,400
now this is the hardware attack so we're

1229
00:45:20,400 --> 00:45:21,760
going to start by looking at some

1230
00:45:21,760 --> 00:45:22,880
hardware

1231
00:45:22,880 --> 00:45:25,040
if you want to unlock a car you usually

1232
00:45:25,040 --> 00:45:25,920
use a key fob

1233
00:45:25,920 --> 00:45:27,359
that's not different in the case of the

1234
00:45:27,359 --> 00:45:29,760
tesla model x so if we open up this

1235
00:45:29,760 --> 00:45:32,240
keyfob it looks like this and there's a

1236
00:45:32,240 --> 00:45:33,599
few interesting components we can

1237
00:45:33,599 --> 00:45:34,800
identify

1238
00:45:34,800 --> 00:45:36,240
so first of all we see a texas

1239
00:45:36,240 --> 00:45:37,599
instrument's bluetooth low energy

1240
00:45:37,599 --> 00:45:38,800
microcontroller

1241
00:45:38,800 --> 00:45:41,280
that is packed with a two 2.4 gigahertz

1242
00:45:41,280 --> 00:45:42,800
range extender

1243
00:45:42,800 --> 00:45:44,480
on the other side we see a maximum

1244
00:45:44,480 --> 00:45:46,000
integrated 22 kilohertz

1245
00:45:46,000 --> 00:45:48,160
transponder chip that is not used to do

1246
00:45:48,160 --> 00:45:50,000
any cryptographic operations in this

1247
00:45:50,000 --> 00:45:50,720
case

1248
00:45:50,720 --> 00:45:52,560
it's only used to establish a low

1249
00:45:52,560 --> 00:45:54,960
frequency communication link

1250
00:45:54,960 --> 00:45:56,319
then on the far left we see an

1251
00:45:56,319 --> 00:45:58,160
accelerometer that is likely used to

1252
00:45:58,160 --> 00:46:00,240
prevent relay attacks

1253
00:46:00,240 --> 00:46:02,599
and then finally we see an infineon

1254
00:46:02,599 --> 00:46:04,800
slm-97 secure element

1255
00:46:04,800 --> 00:46:07,760
that is common criteria certified so you

1256
00:46:07,760 --> 00:46:09,680
can likely imagine that this

1257
00:46:09,680 --> 00:46:11,839
secure element is performing all of the

1258
00:46:11,839 --> 00:46:14,000
cryptographic operations

1259
00:46:14,000 --> 00:46:16,160
and would probably be the toughest nut

1260
00:46:16,160 --> 00:46:17,040
to crack

1261
00:46:17,040 --> 00:46:18,960
so from an attacker's point of view it

1262
00:46:18,960 --> 00:46:20,800
makes sense to try and compromise the

1263
00:46:20,800 --> 00:46:22,400
bluetooth energy chip

1264
00:46:22,400 --> 00:46:24,000
because if you're able to do this you

1265
00:46:24,000 --> 00:46:26,839
can send commands directly to the secure

1266
00:46:26,839 --> 00:46:28,319
elements

1267
00:46:28,319 --> 00:46:30,000
now if we take one of these key fobs

1268
00:46:30,000 --> 00:46:31,599
take out the battery and put it back

1269
00:46:31,599 --> 00:46:34,000
in it will actually start advertising

1270
00:46:34,000 --> 00:46:35,520
itself as a bluetooth low energy

1271
00:46:35,520 --> 00:46:36,319
peripheral

1272
00:46:36,319 --> 00:46:38,000
which means we can connect to it and we

1273
00:46:38,000 --> 00:46:39,920
can observe all of these services and

1274
00:46:39,920 --> 00:46:41,599
characteristics that are exposed on the

1275
00:46:41,599 --> 00:46:43,040
device

1276
00:46:43,040 --> 00:46:44,960
now one of the most interesting services

1277
00:46:44,960 --> 00:46:47,040
is related to over air download

1278
00:46:47,040 --> 00:46:49,280
which is basically a way for us to push

1279
00:46:49,280 --> 00:46:51,599
new firmware to the key fob

1280
00:46:51,599 --> 00:46:53,599
and as it turns out tesla modified the

1281
00:46:53,599 --> 00:46:56,079
implementation from the example but

1282
00:46:56,079 --> 00:46:57,440
there was a bug in how they

1283
00:46:57,440 --> 00:47:00,319
validated the signature so this means

1284
00:47:00,319 --> 00:47:02,240
that we can override the firmware on the

1285
00:47:02,240 --> 00:47:03,760
key fob

1286
00:47:03,760 --> 00:47:05,839
a second interesting service related to

1287
00:47:05,839 --> 00:47:08,079
application protocol data units

1288
00:47:08,079 --> 00:47:10,000
which is basically a format of sending

1289
00:47:10,000 --> 00:47:12,079
commands to secure elements

1290
00:47:12,079 --> 00:47:13,760
so this means that to this service you

1291
00:47:13,760 --> 00:47:15,280
could send commands to the secure

1292
00:47:15,280 --> 00:47:15,760
element

1293
00:47:15,760 --> 00:47:18,480
over bluetooth now this is likely a

1294
00:47:18,480 --> 00:47:19,280
security

1295
00:47:19,280 --> 00:47:21,520
issue and so tesla realized this and

1296
00:47:21,520 --> 00:47:22,319
implemented

1297
00:47:22,319 --> 00:47:25,200
some blocks basically on the server so

1298
00:47:25,200 --> 00:47:26,640
that wouldn't allow you to send all of

1299
00:47:26,640 --> 00:47:27,040
the

1300
00:47:27,040 --> 00:47:29,520
possible apd commands and of course they

1301
00:47:29,520 --> 00:47:31,280
blocked the apdu commands that we as an

1302
00:47:31,280 --> 00:47:33,520
attacker would like to use

1303
00:47:33,520 --> 00:47:34,960
now of course if we can override the

1304
00:47:34,960 --> 00:47:36,240
firmware inside of the bluetooth low

1305
00:47:36,240 --> 00:47:37,680
energy chip we can remove these

1306
00:47:37,680 --> 00:47:39,760
instructions

1307
00:47:39,760 --> 00:47:40,960
now at the beginning of this slide i

1308
00:47:40,960 --> 00:47:42,160
told you that i would have to remove the

1309
00:47:42,160 --> 00:47:43,839
battery from the keyfob which of course

1310
00:47:43,839 --> 00:47:46,160
makes the attack quite lame

1311
00:47:46,160 --> 00:47:47,680
and it turns out that we can actually

1312
00:47:47,680 --> 00:47:49,760
circumvent this issue by using a body

1313
00:47:49,760 --> 00:47:51,040
control module

1314
00:47:51,040 --> 00:47:52,800
so this is one of the ecu's that is

1315
00:47:52,800 --> 00:47:55,440
normally located inside the vehicle

1316
00:47:55,440 --> 00:47:57,599
and in this case is responsible for

1317
00:47:57,599 --> 00:48:00,960
among other things unlocking the vehicle

1318
00:48:00,960 --> 00:48:03,920
now as it turns out this body control

1319
00:48:03,920 --> 00:48:04,640
module can

1320
00:48:04,640 --> 00:48:07,040
actually send a wake up command over low

1321
00:48:07,040 --> 00:48:08,720
frequency to the key fob

1322
00:48:08,720 --> 00:48:10,640
which forces the key fob to advertise

1323
00:48:10,640 --> 00:48:12,640
itself as connectable over bluetooth

1324
00:48:12,640 --> 00:48:14,000
energy

1325
00:48:14,000 --> 00:48:16,480
and this is done based on an identifier

1326
00:48:16,480 --> 00:48:18,160
that is derived from the vin

1327
00:48:18,160 --> 00:48:20,319
so the fin is a unique number associated

1328
00:48:20,319 --> 00:48:21,280
to the vehicle

1329
00:48:21,280 --> 00:48:22,960
does in this case also stored in a

1330
00:48:22,960 --> 00:48:24,559
secure element inside of the body

1331
00:48:24,559 --> 00:48:26,319
control module

1332
00:48:26,319 --> 00:48:28,079
now of course if we replace a secure

1333
00:48:28,079 --> 00:48:29,760
element we could take this body control

1334
00:48:29,760 --> 00:48:31,440
module into believing it belongs to a

1335
00:48:31,440 --> 00:48:32,559
different car

1336
00:48:32,559 --> 00:48:34,400
and then use it to wake up a target

1337
00:48:34,400 --> 00:48:35,920
keyfob

1338
00:48:35,920 --> 00:48:37,680
so for now our plan of attack looks

1339
00:48:37,680 --> 00:48:39,119
something like this

1340
00:48:39,119 --> 00:48:41,599
we send a command using a modified bcm

1341
00:48:41,599 --> 00:48:42,720
to the keyfob

1342
00:48:42,720 --> 00:48:44,880
that wakes up the keyfob we now connect

1343
00:48:44,880 --> 00:48:46,400
to it over bluetooth

1344
00:48:46,400 --> 00:48:48,640
we push our own modified firmware to the

1345
00:48:48,640 --> 00:48:50,400
key fob which removes all of these

1346
00:48:50,400 --> 00:48:51,599
restrictions

1347
00:48:51,599 --> 00:48:54,720
on the apdu interface then we can

1348
00:48:54,720 --> 00:48:57,040
request a valid rollout code to this

1349
00:48:57,040 --> 00:48:59,200
interface from the secure element

1350
00:48:59,200 --> 00:49:01,200
and we can then go back to the vehicle

1351
00:49:01,200 --> 00:49:03,920
and use it to unlock the car

1352
00:49:03,920 --> 00:49:05,280
now it's important to realize that we

1353
00:49:05,280 --> 00:49:07,040
can only unlock the car using one of

1354
00:49:07,040 --> 00:49:08,319
these rolling codes and that we would

1355
00:49:08,319 --> 00:49:10,240
not be able to start the vehicle

1356
00:49:10,240 --> 00:49:11,680
and of course it's more fun if we can

1357
00:49:11,680 --> 00:49:14,079
also drive off with the car

1358
00:49:14,079 --> 00:49:16,400
so at this point we have established

1359
00:49:16,400 --> 00:49:17,920
physical

1360
00:49:17,920 --> 00:49:20,160
access to the interior of the vehicle

1361
00:49:20,160 --> 00:49:21,599
and it now makes sense for us to look at

1362
00:49:21,599 --> 00:49:23,760
how tesla would spare a new key fob to

1363
00:49:23,760 --> 00:49:24,960
the car

1364
00:49:24,960 --> 00:49:26,640
and as it turns out tesla uses something

1365
00:49:26,640 --> 00:49:29,200
that's called the tesla toolbox for this

1366
00:49:29,200 --> 00:49:30,960
which is used to service model s and

1367
00:49:30,960 --> 00:49:32,960
model x vehicles by uh

1368
00:49:32,960 --> 00:49:34,960
service technicians basically so the

1369
00:49:34,960 --> 00:49:36,559
tool is not publicly available on the

1370
00:49:36,559 --> 00:49:37,520
internet

1371
00:49:37,520 --> 00:49:40,480
but as with most things leaked versions

1372
00:49:40,480 --> 00:49:41,200
do exist

1373
00:49:41,200 --> 00:49:43,680
on the internet and tesla even briefly

1374
00:49:43,680 --> 00:49:44,720
released

1375
00:49:44,720 --> 00:49:46,640
the tool themselves unintentionally a

1376
00:49:46,640 --> 00:49:48,079
few weeks ago

1377
00:49:48,079 --> 00:49:49,520
now once you install the tool you will

1378
00:49:49,520 --> 00:49:51,119
realize that most of the interesting

1379
00:49:51,119 --> 00:49:53,280
stuff is actually stored encrypted

1380
00:49:53,280 --> 00:49:55,119
but as you can imagine the tool itself

1381
00:49:55,119 --> 00:49:56,800
has to actually decrypt

1382
00:49:56,800 --> 00:49:59,040
these modules before it can use them and

1383
00:49:59,040 --> 00:50:00,559
of course these modules contain a lot of

1384
00:50:00,559 --> 00:50:03,440
interesting information for us

1385
00:50:03,440 --> 00:50:05,359
so normally what would happen is you

1386
00:50:05,359 --> 00:50:07,839
have a service technician with a laptop

1387
00:50:07,839 --> 00:50:09,200
that's running the tesla toolbox

1388
00:50:09,200 --> 00:50:10,400
software

1389
00:50:10,400 --> 00:50:13,200
he has valid tesla credentials and so

1390
00:50:13,200 --> 00:50:16,400
also gets access to a back-end hsm

1391
00:50:16,400 --> 00:50:19,359
or hardware security module the laptop

1392
00:50:19,359 --> 00:50:21,920
also has a usb to com interface

1393
00:50:21,920 --> 00:50:23,760
that allows the toolbox software

1394
00:50:23,760 --> 00:50:25,839
basically to send apdu commands to the

1395
00:50:25,839 --> 00:50:26,800
secure element

1396
00:50:26,800 --> 00:50:29,359
inside of the body control module and on

1397
00:50:29,359 --> 00:50:31,040
the other side it also has a usb to

1398
00:50:31,040 --> 00:50:32,160
bluetooth adapter

1399
00:50:32,160 --> 00:50:34,160
that allows the software to send apdu

1400
00:50:34,160 --> 00:50:36,559
commands to the secure element inside of

1401
00:50:36,559 --> 00:50:37,760
the keyfob

1402
00:50:37,760 --> 00:50:39,520
and in this way the toolbox software can

1403
00:50:39,520 --> 00:50:41,359
communicate with both secure elements

1404
00:50:41,359 --> 00:50:42,960
and basically perform

1405
00:50:42,960 --> 00:50:45,599
the pairing procedure now the actual

1406
00:50:45,599 --> 00:50:47,200
pairing can be split up into

1407
00:50:47,200 --> 00:50:50,240
two parts namely provisioning and then

1408
00:50:50,240 --> 00:50:54,400
actual pairing so as it turns out

1409
00:50:54,400 --> 00:50:57,359
every secure element will have 5 rsa

1410
00:50:57,359 --> 00:50:58,559
slots

1411
00:50:58,559 --> 00:51:00,800
slots 0 and 1 are reserved to store

1412
00:51:00,800 --> 00:51:02,960
tesla specific certificates

1413
00:51:02,960 --> 00:51:04,640
and then the secure elements will

1414
00:51:04,640 --> 00:51:07,680
generate 3 rsa key pairs

1415
00:51:07,680 --> 00:51:09,359
and the idea here now is that the

1416
00:51:09,359 --> 00:51:10,960
backend hsm will

1417
00:51:10,960 --> 00:51:13,040
create certificates for these slots and

1418
00:51:13,040 --> 00:51:14,880
then the certificates get stored inside

1419
00:51:14,880 --> 00:51:16,640
of the secure element

1420
00:51:16,640 --> 00:51:19,200
so presumably here the idea is that if

1421
00:51:19,200 --> 00:51:21,200
you pair this keyfob now to a vehicle

1422
00:51:21,200 --> 00:51:24,000
the vehicle would be able to ensure that

1423
00:51:24,000 --> 00:51:25,839
it's pairing to a legitimate key fob

1424
00:51:25,839 --> 00:51:26,960
that has valid

1425
00:51:26,960 --> 00:51:30,319
certificates signed by tesla

1426
00:51:30,319 --> 00:51:32,000
so at this point we can continue to the

1427
00:51:32,000 --> 00:51:33,760
actual pairing process

1428
00:51:33,760 --> 00:51:36,160
and we could play a little game so if

1429
00:51:36,160 --> 00:51:37,760
someone is able to find these

1430
00:51:37,760 --> 00:51:38,800
certificates back

1431
00:51:38,800 --> 00:51:41,119
in this pairing protocol then i will buy

1432
00:51:41,119 --> 00:51:42,880
them a virtual beer

1433
00:51:42,880 --> 00:51:45,680
later on in the conference so now you

1434
00:51:45,680 --> 00:51:47,920
can see that the properties involved are

1435
00:51:47,920 --> 00:51:48,720
basically

1436
00:51:48,720 --> 00:51:50,800
the card body control module the toolbox

1437
00:51:50,800 --> 00:51:52,079
and the keyfob

1438
00:51:52,079 --> 00:51:54,079
but the keyfob will actually never send

1439
00:51:54,079 --> 00:51:56,000
its certificates to the car

1440
00:51:56,000 --> 00:51:58,400
so the car is not able to verify that

1441
00:51:58,400 --> 00:52:00,720
it's pairing to legitimate keyfob

1442
00:52:00,720 --> 00:52:02,720
so for us from the attacker's point of

1443
00:52:02,720 --> 00:52:06,240
view we can basically modify a keyfob

1444
00:52:06,240 --> 00:52:07,599
and have it skip all of these

1445
00:52:07,599 --> 00:52:09,359
provisioning related steps and

1446
00:52:09,359 --> 00:52:12,319
immediately go for the pairing protocol

1447
00:52:12,319 --> 00:52:14,559
and that's how we basically complete our

1448
00:52:14,559 --> 00:52:15,520
attack

1449
00:52:15,520 --> 00:52:17,280
so we've already established physical

1450
00:52:17,280 --> 00:52:18,880
access to the vehicle

1451
00:52:18,880 --> 00:52:20,480
we now connect to the diagnostic

1452
00:52:20,480 --> 00:52:22,880
interface and start pairing a key fob

1453
00:52:22,880 --> 00:52:24,240
that we have modified

1454
00:52:24,240 --> 00:52:25,920
i'll show you in a bit more detail how

1455
00:52:25,920 --> 00:52:27,839
we modified it

1456
00:52:27,839 --> 00:52:29,359
so to show you how we do this this

1457
00:52:29,359 --> 00:52:32,079
attack in practice we've built a proof

1458
00:52:32,079 --> 00:52:33,680
concept tool that is

1459
00:52:33,680 --> 00:52:35,200
completely battery powered so it's

1460
00:52:35,200 --> 00:52:37,760
mobile and it fits in a backpack

1461
00:52:37,760 --> 00:52:40,720
it consists of a raspberry pi that

1462
00:52:40,720 --> 00:52:41,920
basically controls all of the

1463
00:52:41,920 --> 00:52:43,280
electronics

1464
00:52:43,280 --> 00:52:45,280
and on top of the raspberry pi we have a

1465
00:52:45,280 --> 00:52:46,400
gan shield that

1466
00:52:46,400 --> 00:52:50,319
can send can bus commands basically to

1467
00:52:50,319 --> 00:52:52,240
the body control module that's

1468
00:52:52,240 --> 00:52:54,240
on the other side of this device but you

1469
00:52:54,240 --> 00:52:56,160
can also connect the second interface of

1470
00:52:56,160 --> 00:52:58,160
this module to the diagnostic interface

1471
00:52:58,160 --> 00:53:00,160
inside of the vehicle

1472
00:53:00,160 --> 00:53:01,760
and then finally on top you can see the

1473
00:53:01,760 --> 00:53:03,520
model x key fob that we use

1474
00:53:03,520 --> 00:53:05,520
so this is a standard model x key fob we

1475
00:53:05,520 --> 00:53:07,599
didn't modify any of the firmware

1476
00:53:07,599 --> 00:53:09,599
but what we did is we removed the secure

1477
00:53:09,599 --> 00:53:11,200
element from the board

1478
00:53:11,200 --> 00:53:13,040
and replaced it with a usb to sale

1479
00:53:13,040 --> 00:53:14,240
converter

1480
00:53:14,240 --> 00:53:15,920
and this basically allows us to

1481
00:53:15,920 --> 00:53:17,839
implement our own version of the secure

1482
00:53:17,839 --> 00:53:18,640
element

1483
00:53:18,640 --> 00:53:20,559
in the python script that runs on the

1484
00:53:20,559 --> 00:53:22,640
raspberry pi

1485
00:53:22,640 --> 00:53:24,480
now a similar modification was made to

1486
00:53:24,480 --> 00:53:26,400
the body control module

1487
00:53:26,400 --> 00:53:28,800
so again we remove the secure element we

1488
00:53:28,800 --> 00:53:30,880
replace it with a usb to serial adapter

1489
00:53:30,880 --> 00:53:32,880
and then emulate the secure element in

1490
00:53:32,880 --> 00:53:34,240
python

1491
00:53:34,240 --> 00:53:35,839
and basically what this allows us to do

1492
00:53:35,839 --> 00:53:38,000
is to take this body control module into

1493
00:53:38,000 --> 00:53:39,920
believing it belongs to a specific

1494
00:53:39,920 --> 00:53:40,880
phenomena

1495
00:53:40,880 --> 00:53:42,720
and that then in turn allows us to wake

1496
00:53:42,720 --> 00:53:44,640
up the key folk

1497
00:53:44,640 --> 00:53:46,160
now of course when we found these issues

1498
00:53:46,160 --> 00:53:48,160
we reported them to tesla this was back

1499
00:53:48,160 --> 00:53:50,160
in august of 2020.

1500
00:53:50,160 --> 00:53:52,240
they released a patch by the end of

1501
00:53:52,240 --> 00:53:53,599
november 2020

1502
00:53:53,599 --> 00:53:56,319
basically together with a with making

1503
00:53:56,319 --> 00:53:57,920
this research public

1504
00:53:57,920 --> 00:53:59,599
and they gave us a five thousand dollar

1505
00:53:59,599 --> 00:54:01,119
bounty

1506
00:54:01,119 --> 00:54:02,880
now to end the stock i want to show you

1507
00:54:02,880 --> 00:54:05,040
a video of how we would carry out this

1508
00:54:05,040 --> 00:54:06,960
attack in practice

1509
00:54:06,960 --> 00:54:09,599
i'm gonna switch to vlc i hope this will

1510
00:54:09,599 --> 00:54:10,720
work smoothly

1511
00:54:10,720 --> 00:54:13,599
over zoom but basically the idea is that

1512
00:54:13,599 --> 00:54:14,559
we have someone that

1513
00:54:14,559 --> 00:54:16,880
parked their vehicle and in this case

1514
00:54:16,880 --> 00:54:18,720
they parked it in front of our

1515
00:54:18,720 --> 00:54:20,079
university building

1516
00:54:20,079 --> 00:54:22,640
which was probably not the best decision

1517
00:54:22,640 --> 00:54:23,760
ever

1518
00:54:23,760 --> 00:54:26,000
so now they're maybe going for a walk or

1519
00:54:26,000 --> 00:54:28,000
waiting for the car to charge

1520
00:54:28,000 --> 00:54:29,760
and at this point we can approach the

1521
00:54:29,760 --> 00:54:31,599
vehicle with our tool

1522
00:54:31,599 --> 00:54:33,119
we can reach the vin number from the

1523
00:54:33,119 --> 00:54:35,040
vehicle from the windshield enter this

1524
00:54:35,040 --> 00:54:35,839
into our tool

1525
00:54:35,839 --> 00:54:38,640
and now our modified body control module

1526
00:54:38,640 --> 00:54:40,640
thinks it belongs to that exact same

1527
00:54:40,640 --> 00:54:41,599
vehicle

1528
00:54:41,599 --> 00:54:46,000
and it allows us basically to wake up

1529
00:54:46,000 --> 00:54:48,079
kefobs and force them to advertise

1530
00:54:48,079 --> 00:54:50,240
themselves over bluetooth low energy

1531
00:54:50,240 --> 00:54:52,000
so this initial step has to be done over

1532
00:54:52,000 --> 00:54:53,280
a distance

1533
00:54:53,280 --> 00:54:55,760
of up to about five meters but once

1534
00:54:55,760 --> 00:54:56,480
we're connected

1535
00:54:56,480 --> 00:54:58,319
to bluetooth we can of course extend

1536
00:54:58,319 --> 00:55:00,480
this range so now we're pushing our

1537
00:55:00,480 --> 00:55:01,440
modified

1538
00:55:01,440 --> 00:55:03,760
firmware to the key fob which opens up

1539
00:55:03,760 --> 00:55:05,599
the apdu interface

1540
00:55:05,599 --> 00:55:07,520
and now we can start asking the secure

1541
00:55:07,520 --> 00:55:09,200
elements to provide us with codes to

1542
00:55:09,200 --> 00:55:10,480
unlock the car

1543
00:55:10,480 --> 00:55:12,240
so these codes are rolling codes they're

1544
00:55:12,240 --> 00:55:14,079
one time valid and we have to use them

1545
00:55:14,079 --> 00:55:16,240
in the same order as we receive them

1546
00:55:16,240 --> 00:55:19,359
from the secure element now we can of

1547
00:55:19,359 --> 00:55:20,000
course go back

1548
00:55:20,000 --> 00:55:22,640
to the car and use these rolling codes

1549
00:55:22,640 --> 00:55:23,200
to

1550
00:55:23,200 --> 00:55:26,720
unlock the door and as this is a model x

1551
00:55:26,720 --> 00:55:28,640
we also of course have to open the

1552
00:55:28,640 --> 00:55:30,400
falcon doors

1553
00:55:30,400 --> 00:55:32,000
now as i've explained earlier at this

1554
00:55:32,000 --> 00:55:34,160
point we were able to get inside of the

1555
00:55:34,160 --> 00:55:34,720
car

1556
00:55:34,720 --> 00:55:36,400
and that's basically where the second

1557
00:55:36,400 --> 00:55:38,000
phase of our attack starts because now

1558
00:55:38,000 --> 00:55:38,640
we can start

1559
00:55:38,640 --> 00:55:42,160
pairing our modified key fob

1560
00:55:42,160 --> 00:55:43,839
so we get inside of the vehicle and we

1561
00:55:43,839 --> 00:55:45,760
attach the tool to the diagnostic

1562
00:55:45,760 --> 00:55:47,359
interface which is located

1563
00:55:47,359 --> 00:55:49,200
underneath of the center display in the

1564
00:55:49,200 --> 00:55:50,720
vehicle

1565
00:55:50,720 --> 00:55:52,799
once connected we can start pairing our

1566
00:55:52,799 --> 00:55:54,000
modified keyfob

1567
00:55:54,000 --> 00:55:56,559
and as i explained before we basically

1568
00:55:56,559 --> 00:55:58,400
skip all of the parts of the protocol

1569
00:55:58,400 --> 00:56:00,880
that we don't want to perform

1570
00:56:00,880 --> 00:56:02,799
now the car in a few seconds believes

1571
00:56:02,799 --> 00:56:04,960
that we have a valid key for paired to

1572
00:56:04,960 --> 00:56:06,160
the car

1573
00:56:06,160 --> 00:56:08,319
we start emulating again what a normal

1574
00:56:08,319 --> 00:56:09,839
key fob would do inside of the secure

1575
00:56:09,839 --> 00:56:10,720
element

1576
00:56:10,720 --> 00:56:12,640
the car will send us a challenge we

1577
00:56:12,640 --> 00:56:14,720
compute a valid response

1578
00:56:14,720 --> 00:56:16,880
the car verifies this response and then

1579
00:56:16,880 --> 00:56:20,079
allows us to drive off

1580
00:56:23,119 --> 00:56:25,839
so with that i want to end my

1581
00:56:25,839 --> 00:56:28,000
presentation

1582
00:56:28,000 --> 00:56:29,599
and if there's any questions i would be

1583
00:56:29,599 --> 00:56:31,599
happy to answer them now or later on in

1584
00:56:31,599 --> 00:56:32,319
one of the

1585
00:56:32,319 --> 00:56:34,960
social rooms

1586
00:56:42,839 --> 00:56:45,200
so can you

1587
00:56:45,200 --> 00:56:48,240
um just because i'm slow and i don't see

1588
00:56:48,240 --> 00:56:49,520
questions yet in the in the chat

1589
00:56:49,520 --> 00:56:51,040
everybody post your your questions in

1590
00:56:51,040 --> 00:56:52,079
the uh

1591
00:56:52,079 --> 00:56:55,280
um in the zooloop chat uh which parts of

1592
00:56:55,280 --> 00:56:55,760
the

1593
00:56:55,760 --> 00:56:58,640
the protocol is it able to skip um like

1594
00:56:58,640 --> 00:56:59,359
if there's some

1595
00:56:59,359 --> 00:57:02,480
signature validation that it just

1596
00:57:02,480 --> 00:57:05,280
normally would um normally when you get

1597
00:57:05,280 --> 00:57:07,680
a new key fob

1598
00:57:07,680 --> 00:57:09,760
so you buy a brand new one from from

1599
00:57:09,760 --> 00:57:11,200
tesla basically

1600
00:57:11,200 --> 00:57:14,960
it will it will be in in this state

1601
00:57:14,960 --> 00:57:16,559
where tesla certificates have been

1602
00:57:16,559 --> 00:57:17,839
loaded

1603
00:57:17,839 --> 00:57:19,280
but these slots are locked so you can no

1604
00:57:19,280 --> 00:57:21,040
longer override them

1605
00:57:21,040 --> 00:57:22,480
and then basically what the service

1606
00:57:22,480 --> 00:57:24,640
technician will do is to

1607
00:57:24,640 --> 00:57:26,480
instruct the secure element to generate

1608
00:57:26,480 --> 00:57:27,839
these rsa key pairs

1609
00:57:27,839 --> 00:57:31,200
and then um get the back-end hsm

1610
00:57:31,200 --> 00:57:34,240
basically to create certificates now

1611
00:57:34,240 --> 00:57:35,839
because i'm not a

1612
00:57:35,839 --> 00:57:38,240
service technician okay i'm not that

1613
00:57:38,240 --> 00:57:39,680
yeah i don't have a

1614
00:57:39,680 --> 00:57:41,280
valid credentials to this toolbox

1615
00:57:41,280 --> 00:57:44,640
software i cannot use the backend hsm

1616
00:57:44,640 --> 00:57:46,079
and i wouldn't be able to create

1617
00:57:46,079 --> 00:57:48,160
certificates so i wouldn't be able to

1618
00:57:48,160 --> 00:57:49,359
log the slots

1619
00:57:49,359 --> 00:57:51,680
and i wouldn't be able to go to the to

1620
00:57:51,680 --> 00:57:53,440
the next step which is basically a

1621
00:57:53,440 --> 00:57:55,040
pairing protocol

1622
00:57:55,040 --> 00:57:56,559
and then by basically replacing the

1623
00:57:56,559 --> 00:57:58,160
secure element i can

1624
00:57:58,160 --> 00:57:59,839
basically start at this point in the

1625
00:57:59,839 --> 00:58:02,240
protocol and it's also important to note

1626
00:58:02,240 --> 00:58:03,839
here that in the provisioning the the

1627
00:58:03,839 --> 00:58:06,079
car is not part of the protocol

1628
00:58:06,079 --> 00:58:07,440
so it doesn't realize that something is

1629
00:58:07,440 --> 00:58:10,319
is going wrong

1630
00:58:10,720 --> 00:58:12,240
so we have a couple questions from the

1631
00:58:12,240 --> 00:58:13,760
chat now so uh

1632
00:58:13,760 --> 00:58:16,319
lorenzo martinico asks um once you have

1633
00:58:16,319 --> 00:58:17,839
physical access to the can bus what

1634
00:58:17,839 --> 00:58:20,960
other attacks are possible

1635
00:58:21,040 --> 00:58:22,240
there's all kinds of stuff that's

1636
00:58:22,240 --> 00:58:24,720
possible um

1637
00:58:24,720 --> 00:58:27,680
i think on the diagnostic connector so

1638
00:58:27,680 --> 00:58:29,119
inside of a vehicle there are usually

1639
00:58:29,119 --> 00:58:31,040
multiple can networks

1640
00:58:31,040 --> 00:58:32,720
on the diagnostic connector you can

1641
00:58:32,720 --> 00:58:34,319
access all of them so the one we're

1642
00:58:34,319 --> 00:58:35,599
connecting to specifically is the

1643
00:58:35,599 --> 00:58:36,880
bodycon

1644
00:58:36,880 --> 00:58:38,079
so one other thing that would be

1645
00:58:38,079 --> 00:58:39,680
interesting look to look at for example

1646
00:58:39,680 --> 00:58:40,000
is

1647
00:58:40,000 --> 00:58:41,920
tesla has a second factor of

1648
00:58:41,920 --> 00:58:43,599
authentication where you enter a pin

1649
00:58:43,599 --> 00:58:44,880
before you can actually start the

1650
00:58:44,880 --> 00:58:46,000
vehicle

1651
00:58:46,000 --> 00:58:48,000
now there's only so many ways they can

1652
00:58:48,000 --> 00:58:50,960
implement this and my feeling is that

1653
00:58:50,960 --> 00:58:52,160
the center display would have to

1654
00:58:52,160 --> 00:58:54,799
communicate with the body control module

1655
00:58:54,799 --> 00:58:57,839
and or the um the driving first inside

1656
00:58:57,839 --> 00:58:59,359
of the vehicle and this has to happen

1657
00:58:59,359 --> 00:59:00,799
overcome

1658
00:59:00,799 --> 00:59:03,599
so there's some potential for attack

1659
00:59:03,599 --> 00:59:04,880
there as well

1660
00:59:04,880 --> 00:59:07,599
um so basically bypassing second factor

1661
00:59:07,599 --> 00:59:08,799
the second factor

1662
00:59:08,799 --> 00:59:11,119
but there's all kinds of malicious thing

1663
00:59:11,119 --> 00:59:12,640
someone could do with access to the

1664
00:59:12,640 --> 00:59:15,359
canvas of course

1665
00:59:15,920 --> 00:59:18,640
so cyrus manuela asks in the video why

1666
00:59:18,640 --> 00:59:20,079
does the attack work without power

1667
00:59:20,079 --> 00:59:22,319
cycling the key fob

1668
00:59:22,319 --> 00:59:24,720
so that's basically um what i explained

1669
00:59:24,720 --> 00:59:25,359
here

1670
00:59:25,359 --> 00:59:30,000
so they they have basically um

1671
00:59:30,000 --> 00:59:32,079
maybe i can better show it here so on

1672
00:59:32,079 --> 00:59:33,280
this

1673
00:59:33,280 --> 00:59:34,640
tool i'm not sure if it's visible on

1674
00:59:34,640 --> 00:59:37,119
your end but basically this tool says

1675
00:59:37,119 --> 00:59:39,040
um that it's waking up keefops with a

1676
00:59:39,040 --> 00:59:41,280
specific car identifier

1677
00:59:41,280 --> 00:59:42,960
and that's it's basically to make the

1678
00:59:42,960 --> 00:59:44,799
life of the service technician easier

1679
00:59:44,799 --> 00:59:47,040
so it can they can basically instruct

1680
00:59:47,040 --> 00:59:48,319
the vehicle to do

1681
00:59:48,319 --> 00:59:50,160
the wake up of the key fob instead of

1682
00:59:50,160 --> 00:59:51,599
having the service technician

1683
00:59:51,599 --> 00:59:53,359
having to open the key fob and take out

1684
00:59:53,359 --> 00:59:55,680
the battery and i'm basically using

1685
00:59:55,680 --> 00:59:57,680
a component that's inside of the vehicle

1686
00:59:57,680 --> 01:00:01,839
to to emulate this

1687
01:00:06,720 --> 01:00:09,839
uh your muted mother there are a bunch

1688
01:00:09,839 --> 01:00:11,280
of super interesting questions going on

1689
01:00:11,280 --> 01:00:12,799
in the chat but i feel like we should

1690
01:00:12,799 --> 01:00:14,960
move on to the next session on formal

1691
01:00:14,960 --> 01:00:16,079
analysis since

1692
01:00:16,079 --> 01:00:18,319
we're at time but i encourage everybody

1693
01:00:18,319 --> 01:00:20,400
to go to zulip and

1694
01:00:20,400 --> 01:00:22,559
talk about how to properly design a car

1695
01:00:22,559 --> 01:00:26,880
security system without these um

