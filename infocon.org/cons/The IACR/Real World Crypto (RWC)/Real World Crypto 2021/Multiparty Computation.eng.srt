1
00:00:01,120 --> 00:00:02,879
okay you should be good to start this

2
00:00:02,879 --> 00:00:05,279
session so enjoy

3
00:00:05,279 --> 00:00:07,520
thank you this is dave archer again uh

4
00:00:07,520 --> 00:00:09,599
chairing session three on multi-party

5
00:00:09,599 --> 00:00:11,040
confrontation

6
00:00:11,040 --> 00:00:12,559
in this session we're very fortunate to

7
00:00:12,559 --> 00:00:14,000
have three interesting talks about

8
00:00:14,000 --> 00:00:15,519
secure mpc

9
00:00:15,519 --> 00:00:18,000
uh and they include things such as the

10
00:00:18,000 --> 00:00:19,840
challenges encountered in building mpc

11
00:00:19,840 --> 00:00:21,279
products that have to deal with diverse

12
00:00:21,279 --> 00:00:22,480
environments

13
00:00:22,480 --> 00:00:24,480
challenges in creating secure real world

14
00:00:24,480 --> 00:00:26,160
mpc ceremonies

15
00:00:26,160 --> 00:00:28,400
and the prototype maliciously secure mvc

16
00:00:28,400 --> 00:00:30,880
platform for federated analytics

17
00:00:30,880 --> 00:00:33,120
remember each talk is ten minutes in

18
00:00:33,120 --> 00:00:33,920
length

19
00:00:33,920 --> 00:00:36,399
followed by five minutes for q a i'll

20
00:00:36,399 --> 00:00:38,399
offer an audible two minute warning

21
00:00:38,399 --> 00:00:40,079
uh if you'd like to ask a question of

22
00:00:40,079 --> 00:00:42,239
the presenter please post your question

23
00:00:42,239 --> 00:00:42,960
in the zulu

24
00:00:42,960 --> 00:00:44,879
channel for the session is i won't be

25
00:00:44,879 --> 00:00:46,320
watching the

26
00:00:46,320 --> 00:00:48,640
the chat channel in zoom in the interest

27
00:00:48,640 --> 00:00:50,000
of open discussion

28
00:00:50,000 --> 00:00:51,840
please include your real name in the

29
00:00:51,840 --> 00:00:54,160
question and please preface it with

30
00:00:54,160 --> 00:00:57,600
a question for speaker so that we don't

31
00:00:57,600 --> 00:00:59,120
actually read things or general

32
00:00:59,120 --> 00:01:00,719
discussion there

33
00:01:00,719 --> 00:01:03,120
so with that uh if you're ready uh our

34
00:01:03,120 --> 00:01:04,720
first speaker is yehuda lindelow who's

35
00:01:04,720 --> 00:01:05,680
going to tell us about

36
00:01:05,680 --> 00:01:07,920
lessons learned and challenges overcome

37
00:01:07,920 --> 00:01:11,200
in deploying heavy mpc

38
00:01:11,200 --> 00:01:14,320
in diverse environments

39
00:01:18,320 --> 00:01:20,960
hi thank you very much uh so this is

40
00:01:20,960 --> 00:01:22,080
joint work with

41
00:01:22,080 --> 00:01:24,960
uh valerie oshita and samir and lucci at

42
00:01:24,960 --> 00:01:26,400
unbound tech

43
00:01:26,400 --> 00:01:28,479
so just for some uh background and

44
00:01:28,479 --> 00:01:30,159
context uh context

45
00:01:30,159 --> 00:01:33,119
uh unbound provides uh key management

46
00:01:33,119 --> 00:01:34,159
and key protection

47
00:01:34,159 --> 00:01:36,960
solutions in software uh enterprise

48
00:01:36,960 --> 00:01:39,520
security software that customers run

49
00:01:39,520 --> 00:01:41,680
and it protects keys via npc by

50
00:01:41,680 --> 00:01:43,200
splitting them between

51
00:01:43,200 --> 00:01:45,920
two or more machines so that uh to make

52
00:01:45,920 --> 00:01:47,680
it hard to steal them

53
00:01:47,680 --> 00:01:49,680
the two product lines of relevance to

54
00:01:49,680 --> 00:01:51,280
all discuss today are

55
00:01:51,280 --> 00:01:53,280
a server side protection which functions

56
00:01:53,280 --> 00:01:55,439
like a virtual hsm so you can split keys

57
00:01:55,439 --> 00:01:56,159
between

58
00:01:56,159 --> 00:01:59,520
a data center and uh a cloud or between

59
00:01:59,520 --> 00:02:00,240
clouds

60
00:02:00,240 --> 00:02:02,719
this top up topology here is actually

61
00:02:02,719 --> 00:02:04,320
run by

62
00:02:04,320 --> 00:02:06,719
a real customer and you can also have

63
00:02:06,719 --> 00:02:09,360
like a virtual smart card or token

64
00:02:09,360 --> 00:02:11,920
where you split keys between a mobile

65
00:02:11,920 --> 00:02:13,680
and a laptop and a server

66
00:02:13,680 --> 00:02:18,640
and uh and run all operations in npc

67
00:02:19,040 --> 00:02:22,720
so the uh first important observation is

68
00:02:22,720 --> 00:02:23,599
that many

69
00:02:23,599 --> 00:02:26,640
companies uh offer

70
00:02:26,640 --> 00:02:29,920
uh or run a service they offer

71
00:02:29,920 --> 00:02:31,760
assass solution software as a service

72
00:02:31,760 --> 00:02:33,360
and when when you do that the customer

73
00:02:33,360 --> 00:02:34,800
has an api

74
00:02:34,800 --> 00:02:36,800
to access the server service i don't

75
00:02:36,800 --> 00:02:38,640
really install anything or maybe a most

76
00:02:38,640 --> 00:02:40,400
a small client

77
00:02:40,400 --> 00:02:42,640
and what that means is that in this

78
00:02:42,640 --> 00:02:44,480
setting the sas company runs

79
00:02:44,480 --> 00:02:46,000
in software they know what machines

80
00:02:46,000 --> 00:02:47,519
they're using what network what

81
00:02:47,519 --> 00:02:48,480
environment

82
00:02:48,480 --> 00:02:50,080
what operating system they have full

83
00:02:50,080 --> 00:02:52,080
control over the system

84
00:02:52,080 --> 00:02:54,480
and in contrast when you provide

85
00:02:54,480 --> 00:02:56,800
enterprise software solutions then

86
00:02:56,800 --> 00:02:58,640
the customers run those so you don't

87
00:02:58,640 --> 00:03:00,879
know what type of environment they're

88
00:03:00,879 --> 00:03:02,560
running in what type of machines they're

89
00:03:02,560 --> 00:03:04,000
running in uh

90
00:03:04,000 --> 00:03:06,640
what what network they have and the more

91
00:03:06,640 --> 00:03:08,400
you try to mandate

92
00:03:08,400 --> 00:03:10,560
that the less relevant your solutions

93
00:03:10,560 --> 00:03:11,760
become so if you

94
00:03:11,760 --> 00:03:13,519
require running on very powerful

95
00:03:13,519 --> 00:03:15,599
machines with very high bandwidth

96
00:03:15,599 --> 00:03:17,360
then that's not going to be relevant for

97
00:03:17,360 --> 00:03:19,840
everyone if you are only willing to

98
00:03:19,840 --> 00:03:21,920
run on windows then an organization only

99
00:03:21,920 --> 00:03:23,360
using linux machines

100
00:03:23,360 --> 00:03:25,360
will not buy from you so this means that

101
00:03:25,360 --> 00:03:27,440
we're deploying an npc solution we need

102
00:03:27,440 --> 00:03:28,879
something that

103
00:03:28,879 --> 00:03:30,400
is going to be relevant for everybody

104
00:03:30,400 --> 00:03:31,840
that actually makes it a challenge when

105
00:03:31,840 --> 00:03:32,400
using

106
00:03:32,400 --> 00:03:36,080
heavy mpc solutions so nothing i say

107
00:03:36,080 --> 00:03:37,200
here is going to be

108
00:03:37,200 --> 00:03:40,239
extremely surprising uh but actually i

109
00:03:40,239 --> 00:03:42,400
think there they are interesting uh

110
00:03:42,400 --> 00:03:44,720
observations that help us think about

111
00:03:44,720 --> 00:03:46,480
what we need to do when we design these

112
00:03:46,480 --> 00:03:48,000
types of protocols so this specific

113
00:03:48,000 --> 00:03:50,159
context i'll focus on is rsa key

114
00:03:50,159 --> 00:03:51,280
generation

115
00:03:51,280 --> 00:03:54,080
for malicious adversaries it's a very uh

116
00:03:54,080 --> 00:03:57,200
complex protocol mpc protocol

117
00:03:57,200 --> 00:03:59,599
because of the difficulty of generating

118
00:03:59,599 --> 00:04:02,000
an rsa modulus where nobody knows

119
00:04:02,000 --> 00:04:04,959
the uh the factorization and this paper

120
00:04:04,959 --> 00:04:06,799
from crypto 2018 had an impressive

121
00:04:06,799 --> 00:04:09,280
performance of 35 seconds on average

122
00:04:09,280 --> 00:04:11,439
for malicious parties when generating 20

123
00:04:11,439 --> 00:04:13,040
48-bit keys

124
00:04:13,040 --> 00:04:15,280
uh 35 seconds may sound like a lot but

125
00:04:15,280 --> 00:04:16,560
it's actually

126
00:04:16,560 --> 00:04:18,560
for this type of operation it's it's a

127
00:04:18,560 --> 00:04:20,079
very very good time

128
00:04:20,079 --> 00:04:22,720
and the experimentation was run on

129
00:04:22,720 --> 00:04:24,639
machines in azure

130
00:04:24,639 --> 00:04:28,080
xeon machines 64 gigabytes ram 40

131
00:04:28,080 --> 00:04:30,080
gigabit per second network

132
00:04:30,080 --> 00:04:31,840
that's actually quite standard it's a

133
00:04:31,840 --> 00:04:33,600
strong machine but not an extremely

134
00:04:33,600 --> 00:04:34,720
powerful or

135
00:04:34,720 --> 00:04:36,800
unusual machine and these machines have

136
00:04:36,800 --> 00:04:37,919
have 20 calls

137
00:04:37,919 --> 00:04:39,440
and that was what the experimentation

138
00:04:39,440 --> 00:04:42,160
was done for this paper

139
00:04:42,160 --> 00:04:44,000
the first issue that arises when you

140
00:04:44,000 --> 00:04:45,520
want to actually deploy this

141
00:04:45,520 --> 00:04:48,160
is that these machines are actually very

142
00:04:48,160 --> 00:04:49,360
expensive

143
00:04:49,360 --> 00:04:51,040
and if you think about a deployment for

144
00:04:51,040 --> 00:04:52,639
a large enterprise you

145
00:04:52,639 --> 00:04:54,880
want these virtual hsms for example to

146
00:04:54,880 --> 00:04:56,639
be in three different regions

147
00:04:56,639 --> 00:04:58,479
in each region you want two pairs of

148
00:04:58,479 --> 00:05:00,320
machines for high availability

149
00:05:00,320 --> 00:05:02,320
so now you need 12 machines across the

150
00:05:02,320 --> 00:05:04,080
world uh this can cost

151
00:05:04,080 --> 00:05:05,919
uh for these types of machines between

152
00:05:05,919 --> 00:05:07,360
50 and 100 000

153
00:05:07,360 --> 00:05:10,720
a year and so if you're mandating that

154
00:05:10,720 --> 00:05:12,240
they're the types of machines you need

155
00:05:12,240 --> 00:05:13,680
to run this solution

156
00:05:13,680 --> 00:05:17,039
you're adding between 50 to 100k

157
00:05:17,039 --> 00:05:19,039
to the total cost of ownership of the

158
00:05:19,039 --> 00:05:20,639
solution and that actually

159
00:05:20,639 --> 00:05:22,479
is not very desirable especially when

160
00:05:22,479 --> 00:05:23,919
everything else in the system doesn't

161
00:05:23,919 --> 00:05:24,880
require

162
00:05:24,880 --> 00:05:28,160
such a powerful machine so this is uh

163
00:05:28,160 --> 00:05:29,759
already an issue just straight up

164
00:05:29,759 --> 00:05:31,759
straight away with the cost of these

165
00:05:31,759 --> 00:05:33,919
more powerful machines

166
00:05:33,919 --> 00:05:36,400
the second thing is that i want to

167
00:05:36,400 --> 00:05:38,080
relate to is multi-threading and

168
00:05:38,080 --> 00:05:39,919
and it might seem you know what's the

169
00:05:39,919 --> 00:05:42,639
issue all computers now are multi-core

170
00:05:42,639 --> 00:05:43,680
computers and

171
00:05:43,680 --> 00:05:45,360
we can run everything multi-threaded

172
00:05:45,360 --> 00:05:47,199
there's no real issue

173
00:05:47,199 --> 00:05:49,440
uh and so maybe we should detect the

174
00:05:49,440 --> 00:05:51,120
number of calls and paralyze to that

175
00:05:51,120 --> 00:05:52,400
number or just

176
00:05:52,400 --> 00:05:54,240
use many threads and if we're not using

177
00:05:54,240 --> 00:05:56,000
it using some tens it's not going to be

178
00:05:56,000 --> 00:05:57,680
too much of a penalty

179
00:05:57,680 --> 00:05:59,520
the problem is and again we're running

180
00:05:59,520 --> 00:06:02,560
this solution

181
00:06:02,560 --> 00:06:04,240
in the context of something that the

182
00:06:04,240 --> 00:06:06,319
customer is using so when we think about

183
00:06:06,319 --> 00:06:08,319
mpc protocols we think okay i want to do

184
00:06:08,319 --> 00:06:10,080
rsa key generation

185
00:06:10,080 --> 00:06:11,520
but that's not what a customer wants to

186
00:06:11,520 --> 00:06:13,600
do a customer wants a virtual hsm

187
00:06:13,600 --> 00:06:14,400
solution

188
00:06:14,400 --> 00:06:17,280
that does rsa key generation while doing

189
00:06:17,280 --> 00:06:18,880
database decryption operations

190
00:06:18,880 --> 00:06:21,280
code signing authenticating users and

191
00:06:21,280 --> 00:06:22,639
doing whatever else it needs to what

192
00:06:22,639 --> 00:06:23,280
other

193
00:06:23,280 --> 00:06:25,520
whatever other cryptographic operations

194
00:06:25,520 --> 00:06:27,360
are needed if i choke

195
00:06:27,360 --> 00:06:30,400
those machines by generating rsa key

196
00:06:30,400 --> 00:06:32,479
essentially what happens is that my

197
00:06:32,479 --> 00:06:34,400
usual sla that i have

198
00:06:34,400 --> 00:06:36,160
for response time from my other

199
00:06:36,160 --> 00:06:38,479
operations suddenly slows down

200
00:06:38,479 --> 00:06:39,919
significantly

201
00:06:39,919 --> 00:06:42,000
and uh and then i have a very big

202
00:06:42,000 --> 00:06:44,479
problem i could define that process to

203
00:06:44,479 --> 00:06:46,000
have low priority but that has other

204
00:06:46,000 --> 00:06:48,639
adverse effects and now in general the

205
00:06:48,639 --> 00:06:49,759
amount of time it's going to take to

206
00:06:49,759 --> 00:06:51,440
generate a key becomes completely

207
00:06:51,440 --> 00:06:52,400
unknown

208
00:06:52,400 --> 00:06:54,720
so although something really simple it

209
00:06:54,720 --> 00:06:55,680
actually

210
00:06:55,680 --> 00:06:57,759
can be a problem in in the type of

211
00:06:57,759 --> 00:06:59,759
solution that we're providing

212
00:06:59,759 --> 00:07:02,400
the last one which is the most important

213
00:07:02,400 --> 00:07:03,440
um

214
00:07:03,440 --> 00:07:05,280
the three main issues is that of high

215
00:07:05,280 --> 00:07:06,560
bandwidth

216
00:07:06,560 --> 00:07:09,120
the one of the breakthroughs of this uh

217
00:07:09,120 --> 00:07:11,120
paper in crypto 2018 was that

218
00:07:11,120 --> 00:07:13,360
it's okay to defer an honesty proof to

219
00:07:13,360 --> 00:07:15,759
the end and only prove it about

220
00:07:15,759 --> 00:07:18,479
the candidates actually accepted all the

221
00:07:18,479 --> 00:07:20,400
candidates get thrown away i don't care

222
00:07:20,400 --> 00:07:22,000
and if someone cheated beforehand then

223
00:07:22,000 --> 00:07:23,759
they maybe learned the private the rsa

224
00:07:23,759 --> 00:07:24,960
private key

225
00:07:24,960 --> 00:07:27,120
but if i throw out that key it doesn't

226
00:07:27,120 --> 00:07:28,720
do any damage so i only need to do one

227
00:07:28,720 --> 00:07:30,080
proofing at the end and that's very

228
00:07:30,080 --> 00:07:31,199
advantageous

229
00:07:31,199 --> 00:07:32,880
so this proof is run once it's not

230
00:07:32,880 --> 00:07:35,199
significant because it's only run once

231
00:07:35,199 --> 00:07:37,840
and it turns out though that it requires

232
00:07:37,840 --> 00:07:40,479
uploading and downloading 170 megabytes

233
00:07:40,479 --> 00:07:41,440
per party

234
00:07:41,440 --> 00:07:43,360
100 gigabit per second network that

235
00:07:43,360 --> 00:07:45,440
would take about 15 seconds which is

236
00:07:45,440 --> 00:07:49,120
time but it's okay the problem is

237
00:07:49,120 --> 00:07:50,879
that we we have a solution which is a

238
00:07:50,879 --> 00:07:52,400
virtual smart card setting

239
00:07:52,400 --> 00:07:54,800
i want to generate an rsa key between a

240
00:07:54,800 --> 00:07:56,720
laptop and a server for example

241
00:07:56,720 --> 00:07:58,160
and the laptop could be in someone's

242
00:07:58,160 --> 00:08:00,160
home or it could be in

243
00:08:00,160 --> 00:08:03,199
a work office and typical uploads can be

244
00:08:03,199 --> 00:08:05,280
between 1 megabit and 15 megabits per

245
00:08:05,280 --> 00:08:06,319
second

246
00:08:06,319 --> 00:08:08,800
and that proof alone just uploading the

247
00:08:08,800 --> 00:08:10,800
information nothing else we do

248
00:08:10,800 --> 00:08:13,199
would take 23 minutes in that setting

249
00:08:13,199 --> 00:08:15,039
and probably even longer because

250
00:08:15,039 --> 00:08:16,319
you don't always have a stable

251
00:08:16,319 --> 00:08:18,000
connection and that's before we count

252
00:08:18,000 --> 00:08:20,240
anything else and that's of course just

253
00:08:20,240 --> 00:08:22,879
a huge problem so it's actually

254
00:08:22,879 --> 00:08:24,639
essential to use a shorter proof like

255
00:08:24,639 --> 00:08:26,479
liguero or variants that

256
00:08:26,479 --> 00:08:29,199
are more expensive to compute but have

257
00:08:29,199 --> 00:08:30,639
much lower bandwidth

258
00:08:30,639 --> 00:08:32,479
because just the upload time here is

259
00:08:32,479 --> 00:08:34,320
much much too high

260
00:08:34,320 --> 00:08:35,519
and there are other significant

261
00:08:35,519 --> 00:08:37,519
bandwidth savings like we need private

262
00:08:37,519 --> 00:08:39,599
multiplication and oblivious transfer

263
00:08:39,599 --> 00:08:43,120
it's very fast in payer it's much slower

264
00:08:43,120 --> 00:08:44,959
but the payer version is much better

265
00:08:44,959 --> 00:08:45,839
because

266
00:08:45,839 --> 00:08:47,680
uh it's much less dependent on the

267
00:08:47,680 --> 00:08:50,240
bandwidth that we have available

268
00:08:50,240 --> 00:08:51,680
there are many other optimizations i'm

269
00:08:51,680 --> 00:08:53,040
not going to go into them but one of

270
00:08:53,040 --> 00:08:54,560
them that's just really important is

271
00:08:54,560 --> 00:08:55,440
that

272
00:08:55,440 --> 00:08:57,600
high variance is actually a problem we

273
00:08:57,600 --> 00:08:59,760
probably prefer a protocol

274
00:08:59,760 --> 00:09:02,240
that takes five minutes on average and

275
00:09:02,240 --> 00:09:03,920
has low variance then a protocol it

276
00:09:03,920 --> 00:09:05,360
takes three minutes on average and has

277
00:09:05,360 --> 00:09:06,640
very high variance

278
00:09:06,640 --> 00:09:08,880
because applications don't necessarily

279
00:09:08,880 --> 00:09:10,880
work very well if it could take me

280
00:09:10,880 --> 00:09:12,720
two minutes or 20 minutes to get back an

281
00:09:12,720 --> 00:09:14,720
rsa key

282
00:09:14,720 --> 00:09:16,720
another thing that i want to uh point

283
00:09:16,720 --> 00:09:18,560
out is that often as cryptographers we

284
00:09:18,560 --> 00:09:20,000
think that all the solutions have to be

285
00:09:20,000 --> 00:09:22,000
cryptographic if it's running too long

286
00:09:22,000 --> 00:09:24,240
then we have to make the protocol run uh

287
00:09:24,240 --> 00:09:25,040
faster

288
00:09:25,040 --> 00:09:26,399
that's not always the case so our

289
00:09:26,399 --> 00:09:28,160
implementation takes about five minutes

290
00:09:28,160 --> 00:09:28,640
from

291
00:09:28,640 --> 00:09:31,360
a weak home connection to a server and

292
00:09:31,360 --> 00:09:32,959
there are engineering solutions to make

293
00:09:32,959 --> 00:09:35,200
that five minutes be fine because

294
00:09:35,200 --> 00:09:37,279
in the virtual smart card case we

295
00:09:37,279 --> 00:09:39,279
generate the rsa key upon installation

296
00:09:39,279 --> 00:09:39,519
and

297
00:09:39,519 --> 00:09:41,200
it's like an anti-virus installation

298
00:09:41,200 --> 00:09:43,120
right it runs in the background while

299
00:09:43,120 --> 00:09:44,399
you do other things

300
00:09:44,399 --> 00:09:46,320
after five to seven minutes or so it

301
00:09:46,320 --> 00:09:47,839
will tell you that it's finished

302
00:09:47,839 --> 00:09:49,279
and it's anybody much faster than

303
00:09:49,279 --> 00:09:51,839
delivering a physical smart card

304
00:09:51,839 --> 00:09:54,880
it's a server two minutes

305
00:09:54,880 --> 00:09:57,200
okay and in the server setting uh we can

306
00:09:57,200 --> 00:09:59,279
generate many rsa keys and have them in

307
00:09:59,279 --> 00:10:01,279
reserve and then just provide them

308
00:10:01,279 --> 00:10:03,040
they're always shared and refreshed so

309
00:10:03,040 --> 00:10:04,560
it's proactive security and then provide

310
00:10:04,560 --> 00:10:05,200
them

311
00:10:05,200 --> 00:10:06,640
whenever they're needed and we don't

312
00:10:06,640 --> 00:10:08,320
actually have to generate them on demand

313
00:10:08,320 --> 00:10:09,839
if that's going to be a problem

314
00:10:09,839 --> 00:10:12,160
for the application so these are very

315
00:10:12,160 --> 00:10:13,839
simple engineering solutions i just want

316
00:10:13,839 --> 00:10:15,120
to mention that often

317
00:10:15,120 --> 00:10:17,040
complicated engineering solutions are

318
00:10:17,040 --> 00:10:18,720
actually less desired

319
00:10:18,720 --> 00:10:20,480
like auto detecting bandwidth and

320
00:10:20,480 --> 00:10:22,640
computing power is a problem because

321
00:10:22,640 --> 00:10:24,399
maybe there's big variance in what the

322
00:10:24,399 --> 00:10:26,320
customer is using and now you've started

323
00:10:26,320 --> 00:10:28,480
to do something at a certain

324
00:10:28,480 --> 00:10:31,120
rate and you again slow down and and

325
00:10:31,120 --> 00:10:33,279
harm the rest of the system

326
00:10:33,279 --> 00:10:36,320
so in conclusions uh in non

327
00:10:36,320 --> 00:10:37,600
settings it's actually very hard to

328
00:10:37,600 --> 00:10:39,920
assume anything there are big cost

329
00:10:39,920 --> 00:10:41,760
advantages to running on small and weak

330
00:10:41,760 --> 00:10:42,800
machines

331
00:10:42,800 --> 00:10:44,480
you can have high bandwidth or low

332
00:10:44,480 --> 00:10:46,800
bandwidth so we prefer to have our

333
00:10:46,800 --> 00:10:47,839
solutions have

334
00:10:47,839 --> 00:10:50,880
actually uh work on very small

335
00:10:50,880 --> 00:10:53,279
cheap machines only stability and

336
00:10:53,279 --> 00:10:55,120
predictability are often more important

337
00:10:55,120 --> 00:10:56,240
than speed

338
00:10:56,240 --> 00:10:58,959
uh you don't want high variance and not

339
00:10:58,959 --> 00:11:00,399
all solutions are cryptographic

340
00:11:00,399 --> 00:11:02,480
and that smart engineering is also

341
00:11:02,480 --> 00:11:05,120
important in simple engineering

342
00:11:05,120 --> 00:11:06,399
and i want to stress that this isn't a

343
00:11:06,399 --> 00:11:08,000
critique of academic papers i think the

344
00:11:08,000 --> 00:11:09,440
academic papers need

345
00:11:09,440 --> 00:11:11,920
to push the science forward but in

346
00:11:11,920 --> 00:11:14,320
reality when you need to use

347
00:11:14,320 --> 00:11:16,160
these solutions then often a very

348
00:11:16,160 --> 00:11:18,160
different balance is needed

349
00:11:18,160 --> 00:11:20,560
and that does mean that there there is

350
00:11:20,560 --> 00:11:22,720
room for academic research

351
00:11:22,720 --> 00:11:24,720
that looks at different balances often i

352
00:11:24,720 --> 00:11:26,320
can in an mpc

353
00:11:26,320 --> 00:11:29,200
paper you want to have the fastest uh

354
00:11:29,200 --> 00:11:31,360
paper possible or the lowest bandwidth

355
00:11:31,360 --> 00:11:32,480
possible because you need to compare to

356
00:11:32,480 --> 00:11:33,279
others and

357
00:11:33,279 --> 00:11:36,640
it's not a great sale if my paper is uh

358
00:11:36,640 --> 00:11:39,040
you know twice as slow as the fastest

359
00:11:39,040 --> 00:11:41,120
one and the tenth of the bandwidth

360
00:11:41,120 --> 00:11:42,959
of the lowest bandwidth one so it

361
00:11:42,959 --> 00:11:44,640
strikes a nice balance so the people

362
00:11:44,640 --> 00:11:46,160
don't see that as something which is

363
00:11:46,160 --> 00:11:47,440
very attractive to sell

364
00:11:47,440 --> 00:11:49,279
but in reality these types of trade-offs

365
00:11:49,279 --> 00:11:52,639
are actually very very important

366
00:11:52,639 --> 00:11:56,079
thank you

367
00:11:56,079 --> 00:11:57,760
thanks for the great talks there we have

368
00:11:57,760 --> 00:11:59,680
one question posted

369
00:11:59,680 --> 00:12:02,959
on the chat channel uh so question here

370
00:12:02,959 --> 00:12:04,560
is uh from don beaver

371
00:12:04,560 --> 00:12:07,279
uh about the flexibility of the cloud

372
00:12:07,279 --> 00:12:08,000
services

373
00:12:08,000 --> 00:12:10,160
don't the cloud services provide the

374
00:12:10,160 --> 00:12:11,440
elasticity you need

375
00:12:11,440 --> 00:12:14,480
to overcome things like uh rsa key gen

376
00:12:14,480 --> 00:12:16,000
taking over machines and preventing

377
00:12:16,000 --> 00:12:16,560
other

378
00:12:16,560 --> 00:12:19,279
responses or are cloud sources just too

379
00:12:19,279 --> 00:12:22,399
coarse grained or maybe unresponsive

380
00:12:22,399 --> 00:12:26,160
so um the

381
00:12:26,160 --> 00:12:27,440
first thing not everyone is running this

382
00:12:27,440 --> 00:12:29,839
in the cloud a lot of our customers are

383
00:12:29,839 --> 00:12:30,639
using it

384
00:12:30,639 --> 00:12:32,639
in the data centers as well as in the

385
00:12:32,639 --> 00:12:34,959
cloud and in your data in your own data

386
00:12:34,959 --> 00:12:35,839
center off you don't have that

387
00:12:35,839 --> 00:12:37,519
elasticity

388
00:12:37,519 --> 00:12:40,720
and elasticity isn't always that simple

389
00:12:40,720 --> 00:12:44,079
sometimes to achieve on a very

390
00:12:44,079 --> 00:12:46,320
on such a very fine granular level on or

391
00:12:46,320 --> 00:12:48,399
doing very local operations

392
00:12:48,399 --> 00:12:51,440
and also there can be certain danger in

393
00:12:51,440 --> 00:12:53,600
uh if you're automatically cloning

394
00:12:53,600 --> 00:12:54,959
machines then

395
00:12:54,959 --> 00:12:56,480
are you sure that you have strong

396
00:12:56,480 --> 00:12:58,399
separation between them

397
00:12:58,399 --> 00:12:59,839
we have customers that are running

398
00:12:59,839 --> 00:13:01,760
between two different clouds i'll have a

399
00:13:01,760 --> 00:13:04,160
key shared between azure and aws

400
00:13:04,160 --> 00:13:05,440
in the same regions they have high

401
00:13:05,440 --> 00:13:07,600
bandwidth and everything elasticity

402
00:13:07,600 --> 00:13:09,120
between two different clouds is not

403
00:13:09,120 --> 00:13:10,399
something that you know we're going to

404
00:13:10,399 --> 00:13:11,839
really play around with it's quite

405
00:13:11,839 --> 00:13:13,120
dangerous

406
00:13:13,120 --> 00:13:16,000
if at all possible

407
00:13:18,240 --> 00:13:19,600
great that's the only question that's

408
00:13:19,600 --> 00:13:21,920
posted um there's a question in the chat

409
00:13:21,920 --> 00:13:22,240
which

410
00:13:22,240 --> 00:13:26,160
is uh how fast can an ecd say key pair

411
00:13:26,160 --> 00:13:28,079
be generated using your mobile server

412
00:13:28,079 --> 00:13:30,399
setting i don't have that number

413
00:13:30,399 --> 00:13:34,160
uh on me it's in it's in the uh

414
00:13:34,160 --> 00:13:37,360
uh i think it's in the tens of

415
00:13:37,360 --> 00:13:39,120
milliseconds i don't exactly remember

416
00:13:39,120 --> 00:13:39,760
but it's

417
00:13:39,760 --> 00:13:43,680
uh it's not generating a key is not a

418
00:13:43,680 --> 00:13:44,240
very

419
00:13:44,240 --> 00:13:47,680
uh um it's not operation that you're

420
00:13:47,680 --> 00:13:48,000
doing

421
00:13:48,000 --> 00:13:49,920
at an extremely extremely high rate so

422
00:13:49,920 --> 00:13:51,839
it's not that important if it's 15 or 15

423
00:13:51,839 --> 00:13:55,120
milliseconds but i don't remember

424
00:13:55,600 --> 00:13:58,560
okay yeah thanks for that great talk

425
00:13:58,560 --> 00:13:59,120
next up

426
00:13:59,120 --> 00:14:01,600
um is uh omar schlitz who's going to

427
00:14:01,600 --> 00:14:03,360
talk about the diagnosis paper and

428
00:14:03,360 --> 00:14:04,639
bringing that design

429
00:14:04,639 --> 00:14:07,839
to a production-ready state

430
00:14:09,440 --> 00:14:13,440
hi so this is a joint walk with bernardo

431
00:14:13,440 --> 00:14:16,160
justin dmitry mary hart claudio peter

432
00:14:16,160 --> 00:14:18,480
and riyadh and when i say walk i

433
00:14:18,480 --> 00:14:19,440
actually mean

434
00:14:19,440 --> 00:14:22,720
um this is a joint review so

435
00:14:22,720 --> 00:14:25,360
i want to scope what we've done and from

436
00:14:25,360 --> 00:14:26,639
that point to motivate

437
00:14:26,639 --> 00:14:29,760
our walk so there's a paper published

438
00:14:29,760 --> 00:14:32,880
last year called diagonis it

439
00:14:32,880 --> 00:14:35,600
solves provider solution for the joint

440
00:14:35,600 --> 00:14:37,519
rsa modules generation

441
00:14:37,519 --> 00:14:39,920
same problem as you would just described

442
00:14:39,920 --> 00:14:41,279
and they also provide code

443
00:14:41,279 --> 00:14:44,560
a lot of code c plus plus and our job

444
00:14:44,560 --> 00:14:47,440
uh was to review this paper so maybe the

445
00:14:47,440 --> 00:14:48,800
first point here is that

446
00:14:48,800 --> 00:14:51,199
it is a good opportunity for us to

447
00:14:51,199 --> 00:14:52,240
acknowledge the

448
00:14:52,240 --> 00:14:54,959
complexity and effort that it requires

449
00:14:54,959 --> 00:14:56,639
to actually build such a complex

450
00:14:56,639 --> 00:14:58,880
cryptosystem that is going to be used in

451
00:14:58,880 --> 00:15:00,079
production

452
00:15:00,079 --> 00:15:02,000
and uh the other thing is that our

453
00:15:02,000 --> 00:15:04,320
review process was a bit a bit unique

454
00:15:04,320 --> 00:15:07,199
so we worked as a team we were nine of

455
00:15:07,199 --> 00:15:08,079
viewers

456
00:15:08,079 --> 00:15:10,079
we've met with each other we met with

457
00:15:10,079 --> 00:15:12,320
the authors and we needed to

458
00:15:12,320 --> 00:15:14,800
review the code and the paper and the

459
00:15:14,800 --> 00:15:16,399
security proofs

460
00:15:16,399 --> 00:15:19,279
so this gives us kind of um the second

461
00:15:19,279 --> 00:15:20,320
motivation here

462
00:15:20,320 --> 00:15:23,760
which uh is maybe appreciating

463
00:15:23,760 --> 00:15:27,440
the differences between what is

464
00:15:27,440 --> 00:15:30,560
a review process for uh what we are used

465
00:15:30,560 --> 00:15:32,079
to in in a peer review

466
00:15:32,079 --> 00:15:34,639
and what we might want to aim for in a

467
00:15:34,639 --> 00:15:36,560
production grade

468
00:15:36,560 --> 00:15:40,160
systems so i'm gonna briefly

469
00:15:40,160 --> 00:15:42,000
describe the problem of a joint rsa

470
00:15:42,000 --> 00:15:43,440
modulus generation then

471
00:15:43,440 --> 00:15:46,160
i will highlight uh some of the

472
00:15:46,160 --> 00:15:47,040
innovation in the

473
00:15:47,040 --> 00:15:48,880
the arginine's protocol then i will tell

474
00:15:48,880 --> 00:15:50,959
a few stories about the review process

475
00:15:50,959 --> 00:15:53,920
and uh would end with this attack uh

476
00:15:53,920 --> 00:15:54,959
that is uh

477
00:15:54,959 --> 00:15:56,399
probably the most severe attack that we

478
00:15:56,399 --> 00:15:58,800
found that is also an educational

479
00:15:58,800 --> 00:16:01,199
attack and and then the insights however

480
00:16:01,199 --> 00:16:02,880
because this is a show talk

481
00:16:02,880 --> 00:16:05,519
i would cheat a bit and start with the

482
00:16:05,519 --> 00:16:06,560
with the takeaways

483
00:16:06,560 --> 00:16:08,720
hopefully i will manage to get to the

484
00:16:08,720 --> 00:16:09,680
same

485
00:16:09,680 --> 00:16:11,839
slide at the end of the talk and maybe

486
00:16:11,839 --> 00:16:13,199
drive those points home

487
00:16:13,199 --> 00:16:16,320
but just um to mention those uh very

488
00:16:16,320 --> 00:16:17,440
briefly

489
00:16:17,440 --> 00:16:19,759
so and i'm putting the links for those

490
00:16:19,759 --> 00:16:22,000
that want to to follow up and uh

491
00:16:22,000 --> 00:16:23,759
and learn more we are kind of open

492
00:16:23,759 --> 00:16:25,440
sourcing this process

493
00:16:25,440 --> 00:16:27,360
so first is is that optimizations

494
00:16:27,360 --> 00:16:28,959
requires proof of security we usually

495
00:16:28,959 --> 00:16:30,399
when we write papers

496
00:16:30,399 --> 00:16:33,199
um uh and then when we want to implement

497
00:16:33,199 --> 00:16:33,519
it

498
00:16:33,519 --> 00:16:35,440
in real life we are making all sorts of

499
00:16:35,440 --> 00:16:36,800
optimizations now

500
00:16:36,800 --> 00:16:39,360
even if they sound if they are trivial

501
00:16:39,360 --> 00:16:41,519
or may make a lot of sense intuitively

502
00:16:41,519 --> 00:16:43,360
uh the dog bite attack shows one example

503
00:16:43,360 --> 00:16:45,360
of how two very

504
00:16:45,360 --> 00:16:48,320
common and make sense optimizations

505
00:16:48,320 --> 00:16:49,839
combined together

506
00:16:49,839 --> 00:16:52,240
creating this kind of attack second

507
00:16:52,240 --> 00:16:53,600
point is about the dialogue between

508
00:16:53,600 --> 00:16:55,040
cryptographers and developers so we're

509
00:16:55,040 --> 00:16:55,920
in a

510
00:16:55,920 --> 00:16:58,480
good point of view to kind of see how

511
00:16:58,480 --> 00:17:00,160
this communication was made

512
00:17:00,160 --> 00:17:03,040
and the angle that i'm trying to take

513
00:17:03,040 --> 00:17:04,240
here is about

514
00:17:04,240 --> 00:17:06,079
using some specification document as

515
00:17:06,079 --> 00:17:07,599
kind of a middle ground

516
00:17:07,599 --> 00:17:10,640
so i would mention it later on uh

517
00:17:10,640 --> 00:17:12,799
the next bullet is about a coordinator

518
00:17:12,799 --> 00:17:14,959
model which is something specific to

519
00:17:14,959 --> 00:17:18,240
the the arjuna's paper but might be um

520
00:17:18,240 --> 00:17:20,079
extended and used in in other

521
00:17:20,079 --> 00:17:21,919
cryptographic protocols

522
00:17:21,919 --> 00:17:23,599
however it should be carefully defined

523
00:17:23,599 --> 00:17:25,039
this is kind of you know

524
00:17:25,039 --> 00:17:27,839
something which is an active relay in a

525
00:17:27,839 --> 00:17:28,960
sense

526
00:17:28,960 --> 00:17:30,880
so this is another thing and the last

527
00:17:30,880 --> 00:17:33,120
point is the most obvious about

528
00:17:33,120 --> 00:17:35,039
using cryptography and also using code

529
00:17:35,039 --> 00:17:36,559
and writing good i'm

530
00:17:36,559 --> 00:17:38,480
pouring it out and we also wrote a note

531
00:17:38,480 --> 00:17:40,160
about it just because this is where most

532
00:17:40,160 --> 00:17:41,120
of the issues were found

533
00:17:41,120 --> 00:17:44,320
right now the problem is that we want to

534
00:17:44,320 --> 00:17:45,280
generate

535
00:17:45,280 --> 00:17:46,720
i mean a set of parties want to generate

536
00:17:46,720 --> 00:17:49,200
a by prime n which is a product of two

537
00:17:49,200 --> 00:17:50,400
primes p and q and

538
00:17:50,400 --> 00:17:52,559
we want uh to generate its subject no

539
00:17:52,559 --> 00:17:54,320
part would be able to tell

540
00:17:54,320 --> 00:17:57,679
the prime factors p and q and this

541
00:17:57,679 --> 00:18:00,000
by prime is is uh surprisingly useful it

542
00:18:00,000 --> 00:18:02,000
is used uh it can be used in secure

543
00:18:02,000 --> 00:18:03,440
computation protocols

544
00:18:03,440 --> 00:18:04,960
it can be used to set up public

545
00:18:04,960 --> 00:18:07,039
parameters for some cryptographic

546
00:18:07,039 --> 00:18:08,960
um primitives such as the travel delay

547
00:18:08,960 --> 00:18:10,880
function and also

548
00:18:10,880 --> 00:18:12,160
uh to give some examples strong

549
00:18:12,160 --> 00:18:14,240
randomness which is what brought us

550
00:18:14,240 --> 00:18:14,960
together

551
00:18:14,960 --> 00:18:17,919
and also threshold dc dsa just to name a

552
00:18:17,919 --> 00:18:18,480
few

553
00:18:18,480 --> 00:18:20,080
now this is not a new problem it's been

554
00:18:20,080 --> 00:18:21,760
around for 20 plus years and

555
00:18:21,760 --> 00:18:24,960
um correspondingly there's been quite a

556
00:18:24,960 --> 00:18:25,840
lot of

557
00:18:25,840 --> 00:18:28,480
solutions for different settings to this

558
00:18:28,480 --> 00:18:30,400
problem but you can describe all of them

559
00:18:30,400 --> 00:18:32,640
with a simple blueprint and it's also

560
00:18:32,640 --> 00:18:33,840
very uh

561
00:18:33,840 --> 00:18:35,840
intuitive one because at the end we need

562
00:18:35,840 --> 00:18:37,840
to output a single by prime so we only

563
00:18:37,840 --> 00:18:39,760
care about a single button and it should

564
00:18:39,760 --> 00:18:42,720
be a multiplication of two random primes

565
00:18:42,720 --> 00:18:43,520
so the inputs

566
00:18:43,520 --> 00:18:44,720
is very simple to understand they're

567
00:18:44,720 --> 00:18:46,480
supposed to be randomness so there's

568
00:18:46,480 --> 00:18:46,960
some

569
00:18:46,960 --> 00:18:48,880
uh setup phase because we do need to

570
00:18:48,880 --> 00:18:51,679
work with some encryption scheme

571
00:18:51,679 --> 00:18:53,280
and then the game here is about

572
00:18:53,280 --> 00:18:54,960
generating the primes and then

573
00:18:54,960 --> 00:18:57,440
generating the pipelines in a secure way

574
00:18:57,440 --> 00:18:59,280
and testing them and one easy way to to

575
00:18:59,280 --> 00:19:00,799
think about it is let's say

576
00:19:00,799 --> 00:19:02,799
we want to generate p n and also q but

577
00:19:02,799 --> 00:19:04,320
for p each party would

578
00:19:04,320 --> 00:19:06,720
take some of its randomness and would uh

579
00:19:06,720 --> 00:19:07,360
share it

580
00:19:07,360 --> 00:19:08,559
and then we can add all of the

581
00:19:08,559 --> 00:19:09,919
randomness together to get this

582
00:19:09,919 --> 00:19:10,640
candidate

583
00:19:10,640 --> 00:19:12,240
then we need to do the best we can to

584
00:19:12,240 --> 00:19:14,400
test for primality and then

585
00:19:14,400 --> 00:19:17,039
we can uh move on could be the byproduct

586
00:19:17,039 --> 00:19:18,000
the byproduct

587
00:19:18,000 --> 00:19:20,720
the byprom and test it and and so on so

588
00:19:20,720 --> 00:19:22,320
this kind of a funnel

589
00:19:22,320 --> 00:19:24,160
now the requirements for the arjunas

590
00:19:24,160 --> 00:19:26,080
were um very unique one

591
00:19:26,080 --> 00:19:28,640
is that they needed a large-scale system

592
00:19:28,640 --> 00:19:30,240
so 1000 parties which would

593
00:19:30,240 --> 00:19:33,120
made it one of the largest mpc to date

594
00:19:33,120 --> 00:19:34,320
however it should have been

595
00:19:34,320 --> 00:19:36,000
it should be very efficient in in

596
00:19:36,000 --> 00:19:38,240
communication and also in running time

597
00:19:38,240 --> 00:19:40,160
uh because it's gonna work in real in

598
00:19:40,160 --> 00:19:41,679
real life which is supposed to be

599
00:19:41,679 --> 00:19:43,840
secure against malicious adversaries but

600
00:19:43,840 --> 00:19:45,360
also one interesting point is about the

601
00:19:45,360 --> 00:19:46,880
dishonest majority so it's enough to

602
00:19:46,880 --> 00:19:47,679
have one

603
00:19:47,679 --> 00:19:49,760
uh honest party such that pmq will not

604
00:19:49,760 --> 00:19:52,640
be revealed

605
00:19:52,640 --> 00:19:54,640
diagnosis was published last year it was

606
00:19:54,640 --> 00:19:56,320
accepted into a top-tier

607
00:19:56,320 --> 00:19:59,760
security conference uh coming and they

608
00:19:59,760 --> 00:20:03,600
offer a few interesting um ideas

609
00:20:03,600 --> 00:20:05,600
so they are using this coordinator which

610
00:20:05,600 --> 00:20:07,919
i would show visually how it looks like

611
00:20:07,919 --> 00:20:09,520
in a moment but basically this is kind

612
00:20:09,520 --> 00:20:11,120
of a

613
00:20:11,120 --> 00:20:12,880
a party that is not part of the parties

614
00:20:12,880 --> 00:20:14,159
in the protocol but

615
00:20:14,159 --> 00:20:16,320
it is doing a relay but also an active

616
00:20:16,320 --> 00:20:17,600
relay so it

617
00:20:17,600 --> 00:20:19,360
aggregates results and then show it to

618
00:20:19,360 --> 00:20:20,640
the parties it allows

619
00:20:20,640 --> 00:20:22,240
to save in communication instead of

620
00:20:22,240 --> 00:20:24,080
doing n square to

621
00:20:24,080 --> 00:20:25,840
communicate with all the parties parties

622
00:20:25,840 --> 00:20:27,520
work on it with the coordinator

623
00:20:27,520 --> 00:20:29,840
um the encryption scheme used is based

624
00:20:29,840 --> 00:20:31,760
on ring lw it's additive homomorphic

625
00:20:31,760 --> 00:20:32,640
encryption scheme

626
00:20:32,640 --> 00:20:35,600
threshold variant of it there's the zero

627
00:20:35,600 --> 00:20:37,600
knowledge parts you can basically take

628
00:20:37,600 --> 00:20:40,559
run the protocol as a semi-honest

629
00:20:40,559 --> 00:20:41,520
protocol and then

630
00:20:41,520 --> 00:20:43,520
only at the end for successful candidate

631
00:20:43,520 --> 00:20:44,720
you need to generate this

632
00:20:44,720 --> 00:20:48,159
very big zero knowledge proof and

633
00:20:48,159 --> 00:20:50,880
of course it's uh it maintains high

634
00:20:50,880 --> 00:20:53,200
quality security

635
00:20:53,200 --> 00:20:55,760
now visually explaining so this is the

636
00:20:55,760 --> 00:20:57,440
blueprint now just to give an example

637
00:20:57,440 --> 00:20:58,880
each party communicates only with the

638
00:20:58,880 --> 00:20:59,679
coordinator

639
00:20:59,679 --> 00:21:01,280
then let's say share that we want to

640
00:21:01,280 --> 00:21:03,679
generate this um

641
00:21:03,679 --> 00:21:05,919
prime factor so each party would share

642
00:21:05,919 --> 00:21:07,039
it randomness would then to the

643
00:21:07,039 --> 00:21:07,840
coordinator

644
00:21:07,840 --> 00:21:09,280
it would aggregate it and send it back

645
00:21:09,280 --> 00:21:11,200
to the parties as you can see at the end

646
00:21:11,200 --> 00:21:13,280
there's this zero knowledge proof

647
00:21:13,280 --> 00:21:16,400
where a party it's i can can take only

648
00:21:16,400 --> 00:21:18,240
the successful candidates computer proof

649
00:21:18,240 --> 00:21:19,679
send it to the coordinator and then go

650
00:21:19,679 --> 00:21:21,440
offline then the coordinator can later

651
00:21:21,440 --> 00:21:22,480
on go and

652
00:21:22,480 --> 00:21:25,280
uh distribute it to verifiers okay so

653
00:21:25,280 --> 00:21:26,640
finally i can describe a bit about the

654
00:21:26,640 --> 00:21:27,840
review process

655
00:21:27,840 --> 00:21:30,880
now starting with some tools uh and and

656
00:21:30,880 --> 00:21:31,280
here

657
00:21:31,280 --> 00:21:32,960
i want to mention again the

658
00:21:32,960 --> 00:21:34,559
specification document so we actually

659
00:21:34,559 --> 00:21:36,240
had two one that goes from the paper to

660
00:21:36,240 --> 00:21:37,200
the corner

661
00:21:37,200 --> 00:21:39,280
one that goes from the code to the paper

662
00:21:39,280 --> 00:21:40,559
and this is important because

663
00:21:40,559 --> 00:21:43,360
if you think about it when you write an

664
00:21:43,360 --> 00:21:44,799
academic paper you usually

665
00:21:44,799 --> 00:21:46,640
try to optimize on writing the security

666
00:21:46,640 --> 00:21:48,000
proofs or making them

667
00:21:48,000 --> 00:21:49,600
as easy as possible of the assumption

668
00:21:49,600 --> 00:21:51,520
zone however when you write code you

669
00:21:51,520 --> 00:21:53,039
want to make it as efficient as possible

670
00:21:53,039 --> 00:21:54,000
so those are not

671
00:21:54,000 --> 00:21:56,880
go and any hand and i would in a moment

672
00:21:56,880 --> 00:21:58,159
double click on this

673
00:21:58,159 --> 00:22:00,720
one particular specification to show

674
00:22:00,720 --> 00:22:02,320
what it looked like

675
00:22:02,320 --> 00:22:05,039
um in addition we needed to use the the

676
00:22:05,039 --> 00:22:06,880
user encryption homomorphic encryption

677
00:22:06,880 --> 00:22:08,559
so we need to use the tools for morphic

678
00:22:08,559 --> 00:22:09,200
encryption

679
00:22:09,200 --> 00:22:10,559
it's funny because those are the same

680
00:22:10,559 --> 00:22:12,960
tools they used to build the protocol

681
00:22:12,960 --> 00:22:15,120
but nevertheless it needs to be tested

682
00:22:15,120 --> 00:22:16,080
i'm mentioning

683
00:22:16,080 --> 00:22:17,760
cloud because we dynamically run the

684
00:22:17,760 --> 00:22:19,520
code it's important and it's hard to run

685
00:22:19,520 --> 00:22:22,000
a code for that supposed to

686
00:22:22,000 --> 00:22:25,039
simulate 1000 parties but it was very

687
00:22:25,039 --> 00:22:25,679
helpful

688
00:22:25,679 --> 00:22:27,200
and github to track issues as i would

689
00:22:27,200 --> 00:22:31,840
show immediately specification though

690
00:22:32,880 --> 00:22:35,120
one minute i'm not going to go anywhere

691
00:22:35,120 --> 00:22:37,360
so specification document is that

692
00:22:37,360 --> 00:22:41,120
uh includes the following so there's the

693
00:22:41,120 --> 00:22:43,039
the code the code flow which means that

694
00:22:43,039 --> 00:22:44,400
there's a bunch of applications that

695
00:22:44,400 --> 00:22:45,679
needs to run

696
00:22:45,679 --> 00:22:48,559
and um we need to understand who is

697
00:22:48,559 --> 00:22:49,760
communicating with you and

698
00:22:49,760 --> 00:22:52,080
with what messages however eventually

699
00:22:52,080 --> 00:22:54,320
there's a cryptographic protocol and

700
00:22:54,320 --> 00:22:55,840
within this cryptographic protocol we

701
00:22:55,840 --> 00:22:57,520
need to understand the messages

702
00:22:57,520 --> 00:22:59,280
uh that goes from the clients to the

703
00:22:59,280 --> 00:23:00,799
parties to the coordinator

704
00:23:00,799 --> 00:23:03,120
so for each round we dissected it and

705
00:23:03,120 --> 00:23:04,799
and kind of mentioned the parameters and

706
00:23:04,799 --> 00:23:06,320
the notations

707
00:23:06,320 --> 00:23:09,200
to bridge between the paper and the um

708
00:23:09,200 --> 00:23:10,720
and the code

709
00:23:10,720 --> 00:23:12,799
uh now the pipeline in case we found an

710
00:23:12,799 --> 00:23:14,640
issue with uh

711
00:23:14,640 --> 00:23:16,320
an internal discussion with a telegram

712
00:23:16,320 --> 00:23:18,799
group and uh we tried to figure out

713
00:23:18,799 --> 00:23:20,159
what the root cause if this is the real

714
00:23:20,159 --> 00:23:22,240
issue some suggested solutions

715
00:23:22,240 --> 00:23:24,159
we tracked and tagged this and if anyone

716
00:23:24,159 --> 00:23:25,520
is interested in our tagging

717
00:23:25,520 --> 00:23:27,120
system i'll be happy to share it so

718
00:23:27,120 --> 00:23:28,559
being me later and

719
00:23:28,559 --> 00:23:30,400
and then we do this kind of iteration

720
00:23:30,400 --> 00:23:31,840
with the authors finally

721
00:23:31,840 --> 00:23:34,000
uh within let's say two weeks we got to

722
00:23:34,000 --> 00:23:35,280
some revision

723
00:23:35,280 --> 00:23:37,280
so this is maybe the best way to measure

724
00:23:37,280 --> 00:23:39,760
the output series by way of revisions

725
00:23:39,760 --> 00:23:42,799
as you can see it was uh impactful

726
00:23:42,799 --> 00:23:44,480
now because i don't have much time left

727
00:23:44,480 --> 00:23:46,000
i would not describe the dog bite attack

728
00:23:46,000 --> 00:23:47,279
i would simply go

729
00:23:47,279 --> 00:23:48,880
over it by just mentioning that there is

730
00:23:48,880 --> 00:23:50,240
one optimization around the zero

731
00:23:50,240 --> 00:23:51,120
knowledge proof

732
00:23:51,120 --> 00:23:54,159
one optimization of around depict um

733
00:23:54,159 --> 00:23:56,320
ring a liability encryption that allows

734
00:23:56,320 --> 00:23:57,520
you to basically

735
00:23:57,520 --> 00:24:01,279
have enough equations to extract the

736
00:24:01,279 --> 00:24:04,720
k successful candidates

737
00:24:04,720 --> 00:24:08,000
for pmq and then a passive adversary can

738
00:24:08,000 --> 00:24:09,120
basically

739
00:24:09,120 --> 00:24:10,880
break the protocol so just by looking at

740
00:24:10,880 --> 00:24:13,919
the uh public transcript which is

741
00:24:13,919 --> 00:24:16,480
another part of the protocol of the

742
00:24:16,480 --> 00:24:17,520
diagrams protocol

743
00:24:17,520 --> 00:24:19,919
that is visible to anyone the attacker

744
00:24:19,919 --> 00:24:22,240
can just learn p and q

745
00:24:22,240 --> 00:24:24,320
so again i'm going back to the insights

746
00:24:24,320 --> 00:24:26,240
and would open it for questions

747
00:24:26,240 --> 00:24:33,840
you're out of time yep

748
00:24:35,120 --> 00:24:36,960
i have more time uh no you're out of

749
00:24:36,960 --> 00:24:38,480
time you're at your time limit

750
00:24:38,480 --> 00:24:41,679
um any questions from anyone i just see

751
00:24:41,679 --> 00:24:45,279
one question um post on the channel

752
00:24:45,279 --> 00:24:47,360
um and that's from watson lab he's

753
00:24:47,360 --> 00:24:48,960
saying backing out the details of this

754
00:24:48,960 --> 00:24:50,080
impressive work

755
00:24:50,080 --> 00:24:52,799
for a little while why rsa and not class

756
00:24:52,799 --> 00:24:54,400
groups or genus do curves

757
00:24:54,400 --> 00:24:56,000
from for an unknown order group if you

758
00:24:56,000 --> 00:24:58,559
need high assurance

759
00:24:58,559 --> 00:25:00,480
yeah that's uh that's a good question

760
00:25:00,480 --> 00:25:01,840
and i asked it myself

761
00:25:01,840 --> 00:25:04,480
uh unfortunately here uh the focus was

762
00:25:04,480 --> 00:25:05,840
let's assume that

763
00:25:05,840 --> 00:25:07,120
this is the case this is what you want

764
00:25:07,120 --> 00:25:09,279
so it's out of scope for me to answer it

765
00:25:09,279 --> 00:25:12,880
properly but there is a good um

766
00:25:12,880 --> 00:25:14,320
a good answer to this and i would be

767
00:25:14,320 --> 00:25:16,559
happy to i mean it involves like you

768
00:25:16,559 --> 00:25:18,720
know the economics of of hardware and

769
00:25:18,720 --> 00:25:19,520
and such so

770
00:25:19,520 --> 00:25:22,000
i'll be happy to point you um later on

771
00:25:22,000 --> 00:25:23,760
to the specific details of

772
00:25:23,760 --> 00:25:26,080
why

773
00:25:27,039 --> 00:25:29,120
okay any other questions i don't see any

774
00:25:29,120 --> 00:25:30,159
other questions on the

775
00:25:30,159 --> 00:25:32,880
zulub side or on the uh zoom site at the

776
00:25:32,880 --> 00:25:33,520
moment

777
00:25:33,520 --> 00:25:36,720
uh here's one um ah sorry it's not

778
00:25:36,720 --> 00:25:38,000
really a question for you

779
00:25:38,000 --> 00:25:39,919
okay i think that's it for the talk

780
00:25:39,919 --> 00:25:41,760
thanks very much elmer appreciate this

781
00:25:41,760 --> 00:25:44,480
very nice talk

782
00:25:44,720 --> 00:25:47,120
so there's one more speaker in this

783
00:25:47,120 --> 00:25:48,480
session and that's uh

784
00:25:48,480 --> 00:25:50,960
richard who's going to describe a new

785
00:25:50,960 --> 00:25:51,600
efficient

786
00:25:51,600 --> 00:25:53,840
maliciously secure mpc platform for

787
00:25:53,840 --> 00:25:57,840
federated analytics

788
00:26:17,919 --> 00:26:19,919
okay sorry about that uh i believe i'm

789
00:26:19,919 --> 00:26:22,400
audible now yes you are okay

790
00:26:22,400 --> 00:26:24,799
uh hi i'm rashad and this is joint work

791
00:26:24,799 --> 00:26:25,840
with my colleagues at

792
00:26:25,840 --> 00:26:29,840
berkeley and vmware research

793
00:26:29,840 --> 00:26:31,840
so a large number of applications and

794
00:26:31,840 --> 00:26:32,880
services today

795
00:26:32,880 --> 00:26:34,559
can benefit from sharing their data with

796
00:26:34,559 --> 00:26:36,799
each other and running joint analytics

797
00:26:36,799 --> 00:26:38,240
on their collective data towards a

798
00:26:38,240 --> 00:26:40,240
mutually beneficial aim

799
00:26:40,240 --> 00:26:42,240
and for instance in the medical sector

800
00:26:42,240 --> 00:26:44,080
such collaboration can enable healthcare

801
00:26:44,080 --> 00:26:45,600
institutions to perform better medical

802
00:26:45,600 --> 00:26:46,320
studies

803
00:26:46,320 --> 00:26:48,240
and here's an example of one such

804
00:26:48,240 --> 00:26:50,720
analytical query expressed in sql

805
00:26:50,720 --> 00:26:52,960
that we drew from the literature this

806
00:26:52,960 --> 00:26:55,520
query aims to find the top 10 diseases

807
00:26:55,520 --> 00:26:56,799
contracted by patients

808
00:26:56,799 --> 00:26:58,640
who have been infected by a bacteria

809
00:26:58,640 --> 00:27:00,320
called cdif

810
00:27:00,320 --> 00:27:02,799
and in particular the query can be

811
00:27:02,799 --> 00:27:05,039
expressed as a sequence of operations

812
00:27:05,039 --> 00:27:07,440
where first all the parties combine the

813
00:27:07,440 --> 00:27:08,240
data sets

814
00:27:08,240 --> 00:27:10,880
together they then filter out the rows

815
00:27:10,880 --> 00:27:13,200
where c diff is true

816
00:27:13,200 --> 00:27:14,880
these rows are then grouped together by

817
00:27:14,880 --> 00:27:17,039
the type of disease and the size of each

818
00:27:17,039 --> 00:27:18,559
group is counted

819
00:27:18,559 --> 00:27:20,640
and finally the top 10 groups are

820
00:27:20,640 --> 00:27:21,600
identified

821
00:27:21,600 --> 00:27:24,880
after sorting them by their accounts now

822
00:27:24,880 --> 00:27:26,240
the problem in such collaborative

823
00:27:26,240 --> 00:27:29,039
scenarios of course is privacy

824
00:27:29,039 --> 00:27:30,960
organizations are often unwilling or

825
00:27:30,960 --> 00:27:32,799
unable to share the data with each other

826
00:27:32,799 --> 00:27:33,919
because the data may be highly

827
00:27:33,919 --> 00:27:35,520
confidential and they don't want to

828
00:27:35,520 --> 00:27:37,120
expose it to other parties

829
00:27:37,120 --> 00:27:38,320
and there may even be laws and

830
00:27:38,320 --> 00:27:39,760
regulations that prevent them from

831
00:27:39,760 --> 00:27:42,960
sharing their data in the first place

832
00:27:42,960 --> 00:27:45,039
now secure multi-party computation or

833
00:27:45,039 --> 00:27:47,600
npc enables such scenarios

834
00:27:47,600 --> 00:27:49,760
without revealing the party's data the

835
00:27:49,760 --> 00:27:51,840
parties jointly run a cryptographic

836
00:27:51,840 --> 00:27:53,919
protocol that allows them to compute

837
00:27:53,919 --> 00:27:54,960
directly on

838
00:27:54,960 --> 00:27:57,760
encrypted data and only share encrypted

839
00:27:57,760 --> 00:28:00,080
data with each other

840
00:28:00,080 --> 00:28:02,480
mpc protocols guarantee that no party

841
00:28:02,480 --> 00:28:04,640
learns any other information beyond the

842
00:28:04,640 --> 00:28:05,520
final result

843
00:28:05,520 --> 00:28:08,720
of the computation and in more detail

844
00:28:08,720 --> 00:28:10,240
the threat model for mpc and the

845
00:28:10,240 --> 00:28:11,520
security guarantees that we are

846
00:28:11,520 --> 00:28:12,880
interested in in this work

847
00:28:12,880 --> 00:28:16,399
are as follows each party is allowed to

848
00:28:16,399 --> 00:28:16,880
provide

849
00:28:16,880 --> 00:28:18,480
its input of choice to the competition

850
00:28:18,480 --> 00:28:20,399
that they want to run

851
00:28:20,399 --> 00:28:22,080
from the perspective of an honest party

852
00:28:22,080 --> 00:28:23,760
the protocol should ensure that

853
00:28:23,760 --> 00:28:25,600
even if all other parties collude with

854
00:28:25,600 --> 00:28:26,960
each other

855
00:28:26,960 --> 00:28:28,480
they should still not be able to learn

856
00:28:28,480 --> 00:28:30,240
any information about the honors party's

857
00:28:30,240 --> 00:28:31,760
data

858
00:28:31,760 --> 00:28:34,000
and further the security should halt

859
00:28:34,000 --> 00:28:35,679
even if the adversary is malicious

860
00:28:35,679 --> 00:28:37,120
that is it may deviate from the

861
00:28:37,120 --> 00:28:40,559
prescribed protocol in arbitrary ways

862
00:28:40,559 --> 00:28:42,480
now state-of-the-art protocols for

863
00:28:42,480 --> 00:28:45,200
maliciously secure npc work as follows

864
00:28:45,200 --> 00:28:47,279
suppose we want to run the sql query

865
00:28:47,279 --> 00:28:48,320
shown on the slide

866
00:28:48,320 --> 00:28:50,640
that receives input from four parties

867
00:28:50,640 --> 00:28:52,559
where party one's data is first filtered

868
00:28:52,559 --> 00:28:54,159
using a select operation

869
00:28:54,159 --> 00:28:55,919
and then all the parties data is then

870
00:28:55,919 --> 00:28:57,840
joined together pairwise using a

871
00:28:57,840 --> 00:29:00,159
sequence of joint operations

872
00:29:00,159 --> 00:29:02,880
existing mpc protocols require that the

873
00:29:02,880 --> 00:29:04,240
entire computation

874
00:29:04,240 --> 00:29:07,200
is first represented as a single large

875
00:29:07,200 --> 00:29:08,559
monolithic circuit

876
00:29:08,559 --> 00:29:10,399
and then all the parties jointly

877
00:29:10,399 --> 00:29:11,919
evaluate each and every part of the

878
00:29:11,919 --> 00:29:12,559
circuit

879
00:29:12,559 --> 00:29:14,480
so for instance all four parties will

880
00:29:14,480 --> 00:29:16,480
participate in evaluating the select

881
00:29:16,480 --> 00:29:17,200
operation

882
00:29:17,200 --> 00:29:18,960
even though it only processes party

883
00:29:18,960 --> 00:29:20,799
one's data

884
00:29:20,799 --> 00:29:23,520
but this monolithic execution is a far

885
00:29:23,520 --> 00:29:24,880
cry from how the query would be

886
00:29:24,880 --> 00:29:27,919
evaluated if security was not a concern

887
00:29:27,919 --> 00:29:30,159
and for instance this is how natural

888
00:29:30,159 --> 00:29:31,840
plain text computation of the query

889
00:29:31,840 --> 00:29:32,960
would work

890
00:29:32,960 --> 00:29:34,480
the select operation would be run

891
00:29:34,480 --> 00:29:36,399
locally by party one without involving

892
00:29:36,399 --> 00:29:38,240
any other party

893
00:29:38,240 --> 00:29:39,919
the next pair of joints would be run by

894
00:29:39,919 --> 00:29:41,760
the respective subsets of the parties

895
00:29:41,760 --> 00:29:43,760
and therefore could also proceed in

896
00:29:43,760 --> 00:29:44,960
parallel

897
00:29:44,960 --> 00:29:47,120
and only the final joint operation would

898
00:29:47,120 --> 00:29:49,600
involve all the parties

899
00:29:49,600 --> 00:29:52,000
but existing mpc protocols are not able

900
00:29:52,000 --> 00:29:53,120
to work this way

901
00:29:53,120 --> 00:29:54,559
they cannot take advantage of

902
00:29:54,559 --> 00:29:56,559
parallelism across parties

903
00:29:56,559 --> 00:29:58,240
they can't benefit from offloading a

904
00:29:58,240 --> 00:29:59,600
part of the query circuit to local

905
00:29:59,600 --> 00:30:00,880
computation

906
00:30:00,880 --> 00:30:02,640
and all parties must be involved in

907
00:30:02,640 --> 00:30:04,799
executing the entire circuit

908
00:30:04,799 --> 00:30:06,559
all of this contributes towards the high

909
00:30:06,559 --> 00:30:08,880
performance overhead of these protocols

910
00:30:08,880 --> 00:30:10,799
and the cost only grows with the size of

911
00:30:10,799 --> 00:30:12,480
the circuit and the number of parties

912
00:30:12,480 --> 00:30:14,720
involved in its execution

913
00:30:14,720 --> 00:30:17,520
the question is how can we decompose

914
00:30:17,520 --> 00:30:18,640
mono-effect mpc

915
00:30:18,640 --> 00:30:20,960
so as to mimic plain text execution

916
00:30:20,960 --> 00:30:22,240
because if we could do so

917
00:30:22,240 --> 00:30:24,159
it would lead to significant gains in

918
00:30:24,159 --> 00:30:26,720
performance

919
00:30:27,360 --> 00:30:29,919
now let's take the example of a strawman

920
00:30:29,919 --> 00:30:30,799
approach

921
00:30:30,799 --> 00:30:32,720
that mimics the execution plan of

922
00:30:32,720 --> 00:30:34,320
plaintext computation

923
00:30:34,320 --> 00:30:36,799
the select operation in the straw man is

924
00:30:36,799 --> 00:30:38,640
executed locally as before

925
00:30:38,640 --> 00:30:40,880
and each joint operation is a separate

926
00:30:40,880 --> 00:30:42,159
mpc computation

927
00:30:42,159 --> 00:30:43,919
only involving the respective parties

928
00:30:43,919 --> 00:30:46,960
that provide input to the operation

929
00:30:46,960 --> 00:30:49,600
the first problem is that each npc sub

930
00:30:49,600 --> 00:30:51,440
computation by definition

931
00:30:51,440 --> 00:30:54,000
reveals its output to the parties for

932
00:30:54,000 --> 00:30:54,880
example

933
00:30:54,880 --> 00:30:57,600
if party 4 is malicious it obtains the

934
00:30:57,600 --> 00:30:59,120
output of the intermediate joint

935
00:30:59,120 --> 00:31:00,399
operations mpc

936
00:31:00,399 --> 00:31:02,159
which violates the security guarantee

937
00:31:02,159 --> 00:31:04,159
that we wanted that only the final

938
00:31:04,159 --> 00:31:05,840
result of the overall computation be

939
00:31:05,840 --> 00:31:08,000
publicly revealed

940
00:31:08,000 --> 00:31:10,640
second the adversary can provide invalid

941
00:31:10,640 --> 00:31:12,960
inputs to mpc sub computations higher up

942
00:31:12,960 --> 00:31:14,240
in the plan

943
00:31:14,240 --> 00:31:16,159
even though mpc protocols allow each

944
00:31:16,159 --> 00:31:18,399
party to choose what input it provides

945
00:31:18,399 --> 00:31:20,159
not all inputs may be valid for

946
00:31:20,159 --> 00:31:21,760
intermediate operations

947
00:31:21,760 --> 00:31:24,080
for example if a malicious party 1

948
00:31:24,080 --> 00:31:25,519
executes the select operation

949
00:31:25,519 --> 00:31:26,399
incorrectly

950
00:31:26,399 --> 00:31:28,320
it may try to input the results to the

951
00:31:28,320 --> 00:31:29,760
next joining operation

952
00:31:29,760 --> 00:31:31,279
even though the inputs might not have

953
00:31:31,279 --> 00:31:33,120
been possible had the select operation

954
00:31:33,120 --> 00:31:36,159
been executed correctly

955
00:31:36,159 --> 00:31:38,399
and third the adversary may attempt to

956
00:31:38,399 --> 00:31:40,880
provide inconsistent inputs to different

957
00:31:40,880 --> 00:31:43,039
mpc sub computations

958
00:31:43,039 --> 00:31:45,600
for example in this case party 3 is

959
00:31:45,600 --> 00:31:47,360
supposed to provide the same value

960
00:31:47,360 --> 00:31:49,600
x3 as input to two different join

961
00:31:49,600 --> 00:31:50,720
computations

962
00:31:50,720 --> 00:31:53,200
but if part e3 is malicious it may cheat

963
00:31:53,200 --> 00:31:55,039
by providing different values to the two

964
00:31:55,039 --> 00:31:56,000
joints

965
00:31:56,000 --> 00:31:57,440
now these three problems are not an

966
00:31:57,440 --> 00:31:59,440
issue in monolithic execution

967
00:31:59,440 --> 00:32:01,600
and only arise when one attempts to

968
00:32:01,600 --> 00:32:04,399
decompose the computation

969
00:32:04,399 --> 00:32:07,039
our key contribution in senet is the

970
00:32:07,039 --> 00:32:07,679
design

971
00:32:07,679 --> 00:32:09,919
of an mpc protocol that enables

972
00:32:09,919 --> 00:32:11,360
decomposed execution

973
00:32:11,360 --> 00:32:14,240
while overcoming these three challenges

974
00:32:14,240 --> 00:32:15,200
crucially

975
00:32:15,200 --> 00:32:17,519
not all decompositions are valid and the

976
00:32:17,519 --> 00:32:19,039
decomposition may be different

977
00:32:19,039 --> 00:32:20,880
than in the plaintext case and our

978
00:32:20,880 --> 00:32:22,320
protocol formalizes

979
00:32:22,320 --> 00:32:24,640
the class of decompositions that are in

980
00:32:24,640 --> 00:32:26,640
fact valid

981
00:32:26,640 --> 00:32:28,960
as a result senate significantly

982
00:32:28,960 --> 00:32:30,320
improves the performance of

983
00:32:30,320 --> 00:32:32,559
npc execution while providing the same

984
00:32:32,559 --> 00:32:34,159
security guarantees in the presence of

985
00:32:34,159 --> 00:32:36,399
malicious adversaries

986
00:32:36,399 --> 00:32:38,080
the parties can now offload some

987
00:32:38,080 --> 00:32:40,240
operations to local computation

988
00:32:40,240 --> 00:32:42,320
the execution can be parallelized across

989
00:32:42,320 --> 00:32:43,360
parties

990
00:32:43,360 --> 00:32:45,760
and each sub computation only requires

991
00:32:45,760 --> 00:32:47,600
the necessary subset of parties which

992
00:32:47,600 --> 00:32:48,320
reduces

993
00:32:48,320 --> 00:32:52,000
execution cost overall our system makes

994
00:32:52,000 --> 00:32:53,760
the following contributions

995
00:32:53,760 --> 00:32:57,360
send its mpcd composition protocol

996
00:32:57,360 --> 00:32:59,039
lies at the heart of the system and

997
00:32:59,039 --> 00:33:00,960
formalizes several ideas and develops

998
00:33:00,960 --> 00:33:02,559
new techniques to achieve its goals

999
00:33:02,559 --> 00:33:04,880
the protocol is general purpose and may

1000
00:33:04,880 --> 00:33:07,039
have applications beyond senate and sql

1001
00:33:07,039 --> 00:33:08,159
based analytics

1002
00:33:08,159 --> 00:33:10,000
though it is particularly well suited

1003
00:33:10,000 --> 00:33:12,080
for the latter

1004
00:33:12,080 --> 00:33:14,240
we then turn to the matter of designing

1005
00:33:14,240 --> 00:33:16,080
efficient circuit representations for

1006
00:33:16,080 --> 00:33:17,679
sql operations

1007
00:33:17,679 --> 00:33:19,840
in particular we develop a small set of

1008
00:33:19,840 --> 00:33:21,360
efficient circuit primitives

1009
00:33:21,360 --> 00:33:23,120
and then show how to express higher

1010
00:33:23,120 --> 00:33:24,799
level sql operations

1011
00:33:24,799 --> 00:33:27,440
as a composition of these primitives

1012
00:33:27,440 --> 00:33:28,159
finally

1013
00:33:28,159 --> 00:33:30,320
we put the above pieces together and

1014
00:33:30,320 --> 00:33:31,440
show how to execute

1015
00:33:31,440 --> 00:33:34,080
analytical sql queries using senate to

1016
00:33:34,080 --> 00:33:34,640
do so

1017
00:33:34,640 --> 00:33:36,720
we develop new query planning algorithms

1018
00:33:36,720 --> 00:33:38,399
that determine how to decompose the

1019
00:33:38,399 --> 00:33:39,200
query circuits

1020
00:33:39,200 --> 00:33:41,360
and execute them using senate's mpc

1021
00:33:41,360 --> 00:33:42,559
protocol

1022
00:33:42,559 --> 00:33:44,640
in particular we develop a cost model

1023
00:33:44,640 --> 00:33:45,600
for our protocol

1024
00:33:45,600 --> 00:33:47,279
and the query planner uses this cost

1025
00:33:47,279 --> 00:33:49,039
model to identify the optimal

1026
00:33:49,039 --> 00:33:50,960
decomposition

1027
00:33:50,960 --> 00:33:52,960
i will now give you a closer look at how

1028
00:33:52,960 --> 00:33:54,559
we develop our protocol

1029
00:33:54,559 --> 00:33:56,320
for the other aspects of the overall

1030
00:33:56,320 --> 00:33:57,840
system i would encourage you

1031
00:33:57,840 --> 00:33:59,360
to read our paper which is available

1032
00:33:59,360 --> 00:34:01,760
online

1033
00:34:02,240 --> 00:34:04,399
so to understand the steps that we take

1034
00:34:04,399 --> 00:34:06,240
to develop our protocol

1035
00:34:06,240 --> 00:34:08,320
let's start with the straw man mpc

1036
00:34:08,320 --> 00:34:10,079
decomposition that mimics plaintext

1037
00:34:10,079 --> 00:34:11,760
execution

1038
00:34:11,760 --> 00:34:13,280
the first challenge that we needed to

1039
00:34:13,280 --> 00:34:15,679
overcome was we wanted to ensure that

1040
00:34:15,679 --> 00:34:17,599
intermediate mpc computations do not

1041
00:34:17,599 --> 00:34:18,960
reveal the output

1042
00:34:18,960 --> 00:34:21,679
to the parties to prevent this leakage

1043
00:34:21,679 --> 00:34:23,760
we develop a technique that stitches two

1044
00:34:23,760 --> 00:34:25,440
different npcs together

1045
00:34:25,440 --> 00:34:28,079
this approach is called soldering the

1046
00:34:28,079 --> 00:34:30,320
soldering protocol securely transfers

1047
00:34:30,320 --> 00:34:32,399
the output of one sub computation to the

1048
00:34:32,399 --> 00:34:32,879
next

1049
00:34:32,879 --> 00:34:35,199
without decrypting it two minutes

1050
00:34:35,199 --> 00:34:37,760
importantly

1051
00:34:37,760 --> 00:34:40,320
yes importantly our soldering protocol

1052
00:34:40,320 --> 00:34:41,280
is very lightweight

1053
00:34:41,280 --> 00:34:42,879
and works even when the parties in the

1054
00:34:42,879 --> 00:34:46,000
first circuit the subject of the second

1055
00:34:46,000 --> 00:34:47,599
the second challenge was to ensure that

1056
00:34:47,599 --> 00:34:49,199
the adversary is not able to provide

1057
00:34:49,199 --> 00:34:51,040
invalid inputs

1058
00:34:51,040 --> 00:34:53,199
this means that given a sub computation

1059
00:34:53,199 --> 00:34:54,879
we need to be able to deduce

1060
00:34:54,879 --> 00:34:57,119
what possible outputs are valid and then

1061
00:34:57,119 --> 00:34:58,800
the parent mpc must be able to

1062
00:34:58,800 --> 00:35:00,000
efficiently verify

1063
00:35:00,000 --> 00:35:01,680
that the received inputs belong to the

1064
00:35:01,680 --> 00:35:04,079
range of possible values

1065
00:35:04,079 --> 00:35:06,400
this verification is only possible if

1066
00:35:06,400 --> 00:35:08,160
each sub-computation can be efficiently

1067
00:35:08,160 --> 00:35:08,880
inverted

1068
00:35:08,880 --> 00:35:09,839
and we say that a particular

1069
00:35:09,839 --> 00:35:11,760
decomposition is admissible only if

1070
00:35:11,760 --> 00:35:13,359
every sub-computation is efficiently

1071
00:35:13,359 --> 00:35:15,520
invertible

1072
00:35:15,520 --> 00:35:17,359
finally if a party provides the same

1073
00:35:17,359 --> 00:35:19,040
input to two different sub computations

1074
00:35:19,040 --> 00:35:20,480
we need to make sure the inputs are

1075
00:35:20,480 --> 00:35:22,079
consistent and

1076
00:35:22,079 --> 00:35:24,480
for this purpose we limit the admissible

1077
00:35:24,480 --> 00:35:26,720
decompositions to three structures alone

1078
00:35:26,720 --> 00:35:27,200
and not

1079
00:35:27,200 --> 00:35:30,240
graphs now let me uh

1080
00:35:30,240 --> 00:35:31,599
give you a glimpse at how senate

1081
00:35:31,599 --> 00:35:33,200
improves the performance of an mpc

1082
00:35:33,200 --> 00:35:36,160
compared to monolithic circuit execution

1083
00:35:36,160 --> 00:35:37,680
so we evaluated the performance of

1084
00:35:37,680 --> 00:35:39,839
senate on the tpch benchmark which is an

1085
00:35:39,839 --> 00:35:41,440
industry standard benchmark for sql

1086
00:35:41,440 --> 00:35:42,079
analytics

1087
00:35:42,079 --> 00:35:44,720
that consists of 22 complex queries on

1088
00:35:44,720 --> 00:35:46,320
data across eight tables

1089
00:35:46,320 --> 00:35:48,320
and in our experiments we assume that

1090
00:35:48,320 --> 00:35:51,119
each party held a single table

1091
00:35:51,119 --> 00:35:52,640
we compared the performance of senate

1092
00:35:52,640 --> 00:35:54,720
against a baseline implementation of the

1093
00:35:54,720 --> 00:35:56,480
state-of-the-art wrk protocol for

1094
00:35:56,480 --> 00:35:58,160
monolithic npc execution

1095
00:35:58,160 --> 00:36:02,000
as implemented by the agmpc framework

1096
00:36:02,000 --> 00:36:04,160
and this plot shows how the performance

1097
00:36:04,160 --> 00:36:05,760
shows the performance gain offered by

1098
00:36:05,760 --> 00:36:07,520
senate against the baseline

1099
00:36:07,520 --> 00:36:09,680
we find that finite can support 13 out

1100
00:36:09,680 --> 00:36:10,800
of the 22 queries

1101
00:36:10,800 --> 00:36:13,599
which shows its expressiveness and

1102
00:36:13,599 --> 00:36:16,079
importantly senate is up to 145 times

1103
00:36:16,079 --> 00:36:16,800
faster

1104
00:36:16,800 --> 00:36:18,960
bringing mpc deployments for analytics

1105
00:36:18,960 --> 00:36:21,920
that much closer to being a reality

1106
00:36:21,920 --> 00:36:24,480
so in summary senate is a platform that

1107
00:36:24,480 --> 00:36:26,640
enables collaborative execution of sql

1108
00:36:26,640 --> 00:36:27,760
based analytics

1109
00:36:27,760 --> 00:36:29,200
even in the presence of malicious

1110
00:36:29,200 --> 00:36:31,680
adversaries it is up to 145 times faster

1111
00:36:31,680 --> 00:36:32,800
than the state of the art

1112
00:36:32,800 --> 00:36:34,720
by combining a novel protocol for mpc

1113
00:36:34,720 --> 00:36:36,720
decomposition with efficient query

1114
00:36:36,720 --> 00:36:38,320
planning algorithms based on a cost

1115
00:36:38,320 --> 00:36:39,520
model

1116
00:36:39,520 --> 00:36:42,000
with that i will conclude and thank you

1117
00:36:42,000 --> 00:36:43,920
for your attention

1118
00:36:43,920 --> 00:36:46,400
i'm happy to take questions now thank

1119
00:36:46,400 --> 00:36:46,960
you so

1120
00:36:46,960 --> 00:36:49,040
i don't see any questions at the moment

1121
00:36:49,040 --> 00:36:51,359
posted on the zulu side

1122
00:36:51,359 --> 00:36:55,520
or on the zoom side

1123
00:36:55,520 --> 00:36:56,800
and wait a minute here just to make sure

1124
00:36:56,800 --> 00:37:00,079
nobody's posting at the moment

1125
00:37:00,240 --> 00:37:02,640
there's a thing on the chat which is uh

1126
00:37:02,640 --> 00:37:04,640
is is there an implementation

1127
00:37:04,640 --> 00:37:08,400
yes yes there is an implementation so we

1128
00:37:08,400 --> 00:37:10,640
we designed and implemented the system

1129
00:37:10,640 --> 00:37:12,079
and evaluated it

1130
00:37:12,079 --> 00:37:13,680
and a related question is how many

1131
00:37:13,680 --> 00:37:15,440
parties are used by senate and what's

1132
00:37:15,440 --> 00:37:18,720
what is the trust model reinforced

1133
00:37:18,720 --> 00:37:21,599
so um the number of parties that can use

1134
00:37:21,599 --> 00:37:22,320
senate are

1135
00:37:22,320 --> 00:37:25,839
available as many parties as required we

1136
00:37:25,839 --> 00:37:28,160
have experimented with up to 16 parties

1137
00:37:28,160 --> 00:37:29,760
and the threat model is that we want to

1138
00:37:29,760 --> 00:37:32,160
protect against malicious adversaries

1139
00:37:32,160 --> 00:37:35,599
in the presence of a dishonest majority

1140
00:37:35,599 --> 00:37:37,599
i have a question on the zulu side from

1141
00:37:37,599 --> 00:37:38,640
edwardo's story of us

1142
00:37:38,640 --> 00:37:41,280
is uh he says are you dealing only with

1143
00:37:41,280 --> 00:37:43,040
full threshold adversaries

1144
00:37:43,040 --> 00:37:44,320
otherwise how do you deal with the

1145
00:37:44,320 --> 00:37:45,359
relation between the atmospheric

1146
00:37:45,359 --> 00:37:48,839
structure and the party parallelism

1147
00:37:48,839 --> 00:37:50,720
structure sorry could you repeat the

1148
00:37:50,720 --> 00:37:51,440
question please

1149
00:37:51,440 --> 00:37:54,480
sure um are you dealing only with full

1150
00:37:54,480 --> 00:37:56,480
threshold adversaries

1151
00:37:56,480 --> 00:37:58,160
otherwise how do you deal with the

1152
00:37:58,160 --> 00:38:00,400
relation between adversary structure and

1153
00:38:00,400 --> 00:38:06,240
party parallelism structure um

1154
00:38:09,040 --> 00:38:10,720
uh i'm not entirely sure what the

1155
00:38:10,720 --> 00:38:13,040
question means so maybe we could take

1156
00:38:13,040 --> 00:38:14,240
this offline

1157
00:38:14,240 --> 00:38:15,839
yeah let's take that one offline because

1158
00:38:15,839 --> 00:38:17,119
i'm not going to be sure what that

1159
00:38:17,119 --> 00:38:19,040
question means either

1160
00:38:19,040 --> 00:38:21,040
another question from jonathan hoyland

1161
00:38:21,040 --> 00:38:22,800
how do you ensure that decompositions

1162
00:38:22,800 --> 00:38:23,760
are valid

1163
00:38:23,760 --> 00:38:25,599
uh for example what's the mathematical

1164
00:38:25,599 --> 00:38:26,800
framework you used

1165
00:38:26,800 --> 00:38:29,839
and to define developers invalid

1166
00:38:29,839 --> 00:38:32,079
right so uh we re so for a valid

1167
00:38:32,079 --> 00:38:33,119
decomposition

1168
00:38:33,119 --> 00:38:36,079
we require that each uh each sub

1169
00:38:36,079 --> 00:38:37,760
computation that is not the root

1170
00:38:37,760 --> 00:38:39,680
is efficiently invertible which means

1171
00:38:39,680 --> 00:38:41,520
that it should be easy to find

1172
00:38:41,520 --> 00:38:44,160
um a possible set of inputs given an

1173
00:38:44,160 --> 00:38:44,640
output

1174
00:38:44,640 --> 00:38:46,960
that the sub vibration produces and as a

1175
00:38:46,960 --> 00:38:48,160
result we can embed

1176
00:38:48,160 --> 00:38:50,400
a verification check in the parent

1177
00:38:50,400 --> 00:38:52,000
circuit that the sub combination feeds

1178
00:38:52,000 --> 00:38:52,800
into

1179
00:38:52,800 --> 00:38:54,640
so invertibility is the key requirement

1180
00:38:54,640 --> 00:38:56,400
here

1181
00:38:56,400 --> 00:38:59,359
okay i think that is all the questions

1182
00:38:59,359 --> 00:39:00,000
posted

1183
00:39:00,000 --> 00:39:02,720
and we are close on out of time here uh

1184
00:39:02,720 --> 00:39:03,119
so

1185
00:39:03,119 --> 00:39:06,160
thank you for a great talk thank you

1186
00:39:06,160 --> 00:39:08,320
um with that that concludes session

1187
00:39:08,320 --> 00:39:10,079
number three uh mpc for

1188
00:39:10,079 --> 00:39:13,119
rdbc 2021 and concludes the formal

1189
00:39:13,119 --> 00:39:14,720
sessions for today feels please feel

1190
00:39:14,720 --> 00:39:16,160
free to continue

1191
00:39:16,160 --> 00:39:18,480
using the zulu channel for this session

1192
00:39:18,480 --> 00:39:20,240
uh to continue discussions

1193
00:39:20,240 --> 00:39:21,680
and please come join the social hour

1194
00:39:21,680 --> 00:39:23,599
that starts just about now

1195
00:39:23,599 --> 00:39:26,880
yep stop we're going to go

