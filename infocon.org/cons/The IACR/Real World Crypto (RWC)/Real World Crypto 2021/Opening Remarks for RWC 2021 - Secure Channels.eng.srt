1
00:00:00,640 --> 00:00:04,240
now we are live on youtube so enjoy

2
00:00:04,240 --> 00:00:08,080
doing opening remarks what again

3
00:00:09,200 --> 00:00:12,320
all right then hi

4
00:00:12,320 --> 00:00:14,240
i'm tom shrimpton the contributed talks

5
00:00:14,240 --> 00:00:16,800
chair and on behalf of the rwc steering

6
00:00:16,800 --> 00:00:17,520
committee

7
00:00:17,520 --> 00:00:19,920
let me be the first to welcome you to

8
00:00:19,920 --> 00:00:21,119
amsterdam

9
00:00:21,119 --> 00:00:24,720
for rwc 2021 now i know we're all really

10
00:00:24,720 --> 00:00:26,400
excited about the program

11
00:00:26,400 --> 00:00:28,240
the contributor talks the invited talks

12
00:00:28,240 --> 00:00:29,519
the lightning round and certainly for

13
00:00:29,519 --> 00:00:31,039
the legend ceremony

14
00:00:31,039 --> 00:00:32,640
but you're probably also really excited

15
00:00:32,640 --> 00:00:34,480
to get out there and take in some of the

16
00:00:34,480 --> 00:00:36,640
culture and the sights and sounds

17
00:00:36,640 --> 00:00:38,559
that make amsterdam the really great

18
00:00:38,559 --> 00:00:40,160
city that it is

19
00:00:40,160 --> 00:00:41,360
maybe you have your mind to go check out

20
00:00:41,360 --> 00:00:43,600
the reich museum they have some amazing

21
00:00:43,600 --> 00:00:45,760
art there you should go

22
00:00:45,760 --> 00:00:47,120
maybe you want to go check out some

23
00:00:47,120 --> 00:00:49,520
tulips hey

24
00:00:49,520 --> 00:00:52,480
that was fun maybe you're here for some

25
00:00:52,480 --> 00:00:54,399
authentic dutch food like some puffa

26
00:00:54,399 --> 00:00:55,440
juice

27
00:00:55,440 --> 00:00:57,600
or to have a cup of coffee with a friend

28
00:00:57,600 --> 00:01:00,719
and something slightly more adult to eat

29
00:01:00,719 --> 00:01:03,600
sadly i at least can't do any of this

30
00:01:03,600 --> 00:01:05,600
because i'm sitting in the 4x6 rear

31
00:01:05,600 --> 00:01:07,520
corner of my master bedroom here in

32
00:01:07,520 --> 00:01:08,799
florida

33
00:01:08,799 --> 00:01:11,040
in any case i am really excited to

34
00:01:11,040 --> 00:01:12,640
welcome you to rwc

35
00:01:12,640 --> 00:01:16,320
2021 now the good news is that

36
00:01:16,320 --> 00:01:18,240
even though we can't be together this

37
00:01:18,240 --> 00:01:19,680
year in amsterdam

38
00:01:19,680 --> 00:01:23,200
we can be fingers crossed next year

39
00:01:23,200 --> 00:01:26,400
so the plan is to have rdbc 2022

40
00:01:26,400 --> 00:01:28,400
in amsterdam as we have planned for this

41
00:01:28,400 --> 00:01:29,840
year

42
00:01:29,840 --> 00:01:33,439
helping us to pull off both rwc

43
00:01:33,439 --> 00:01:36,720
2021 and 2022 are

44
00:01:36,720 --> 00:01:39,280
a bunch of really generous sponsors we'd

45
00:01:39,280 --> 00:01:41,439
like to take a moment to recognize them

46
00:01:41,439 --> 00:01:44,240
and thank them for uh in many cases

47
00:01:44,240 --> 00:01:45,520
their continued support

48
00:01:45,520 --> 00:01:48,000
this event they've helped us to grow it

49
00:01:48,000 --> 00:01:49,040
from

50
00:01:49,040 --> 00:01:50,880
uh you know 100 people the first year to

51
00:01:50,880 --> 00:01:53,119
this year well over 700 people

52
00:01:53,119 --> 00:01:54,640
one of the things these funds do is

53
00:01:54,640 --> 00:01:56,320
allow us to

54
00:01:56,320 --> 00:01:57,759
offer support to students to be able to

55
00:01:57,759 --> 00:01:59,520
attend rwbc

56
00:01:59,520 --> 00:02:02,079
and we also have a special rwbc fund

57
00:02:02,079 --> 00:02:03,600
just for this that was set up by a

58
00:02:03,600 --> 00:02:05,360
generous donation from eric scola who

59
00:02:05,360 --> 00:02:06,960
was their previous legend prize winner

60
00:02:06,960 --> 00:02:07,280
so

61
00:02:07,280 --> 00:02:10,479
special thanks to eric uh that said of

62
00:02:10,479 --> 00:02:11,760
course i'd be remiss

63
00:02:11,760 --> 00:02:13,200
and nigel would definitely get on my

64
00:02:13,200 --> 00:02:14,480
case if i didn't mention that we're

65
00:02:14,480 --> 00:02:15,280
always looking

66
00:02:15,280 --> 00:02:17,200
for new sponsors so if you're listening

67
00:02:17,200 --> 00:02:18,959
out there and you feel like you want to

68
00:02:18,959 --> 00:02:20,879
become a more active part of the rdbc

69
00:02:20,879 --> 00:02:22,319
sponsorship community

70
00:02:22,319 --> 00:02:24,319
get in touch with nigel smart it's a

71
00:02:24,319 --> 00:02:25,920
little odd to have the program

72
00:02:25,920 --> 00:02:27,520
chair give the opening remarks usually

73
00:02:27,520 --> 00:02:29,200
that's the general chair or the local

74
00:02:29,200 --> 00:02:30,800
organizer that does that

75
00:02:30,800 --> 00:02:32,480
and they would tell you logistical

76
00:02:32,480 --> 00:02:34,160
things like uh

77
00:02:34,160 --> 00:02:36,000
you know when the food will be served

78
00:02:36,000 --> 00:02:38,080
and where and where the restrooms are

79
00:02:38,080 --> 00:02:39,519
and where to hang your coats and things

80
00:02:39,519 --> 00:02:40,560
of that nature

81
00:02:40,560 --> 00:02:42,319
so let's go ahead and say that i'm

82
00:02:42,319 --> 00:02:44,400
assuming that food will be available

83
00:02:44,400 --> 00:02:45,920
wherever it's typically available

84
00:02:45,920 --> 00:02:47,440
at your place and it's probably

85
00:02:47,440 --> 00:02:48,840
available whenever you want it to be

86
00:02:48,840 --> 00:02:50,080
available

87
00:02:50,080 --> 00:02:51,920
and i'm going to guess that you know

88
00:02:51,920 --> 00:02:55,519
where the restrooms are in your house

89
00:02:55,519 --> 00:02:58,080
i do want to thank the the program

90
00:02:58,080 --> 00:02:59,440
committee that i had this

91
00:02:59,440 --> 00:03:02,400
they were fantastic and this was a very

92
00:03:02,400 --> 00:03:03,920
trying time

93
00:03:03,920 --> 00:03:05,840
to be on a program committee i imagine

94
00:03:05,840 --> 00:03:07,680
many of you in the audience

95
00:03:07,680 --> 00:03:09,599
have served on program committees uh

96
00:03:09,599 --> 00:03:11,360
during 2020 and you know how difficult

97
00:03:11,360 --> 00:03:14,400
it is to try to balance all the things

98
00:03:14,400 --> 00:03:16,000
that come with having kids who are home

99
00:03:16,000 --> 00:03:17,680
schooled and what not

100
00:03:17,680 --> 00:03:19,680
and and serving on our program committee

101
00:03:19,680 --> 00:03:20,879
so i do want to

102
00:03:20,879 --> 00:03:22,720
just thank you to all the members of the

103
00:03:22,720 --> 00:03:24,640
program committee who worked very hard

104
00:03:24,640 --> 00:03:27,200
to pick the contributed talks for this

105
00:03:27,200 --> 00:03:28,239
year

106
00:03:28,239 --> 00:03:31,360
special thanks to uh demonet and

107
00:03:31,360 --> 00:03:33,920
mahir balari and martin albrecht all of

108
00:03:33,920 --> 00:03:35,120
them went

109
00:03:35,120 --> 00:03:37,440
really above and beyond in terms of not

110
00:03:37,440 --> 00:03:38,959
just finishing their own load quickly

111
00:03:38,959 --> 00:03:40,159
but then picking up

112
00:03:40,159 --> 00:03:41,920
you know other papers and and just doing

113
00:03:41,920 --> 00:03:43,440
lots i want to say a special thank you

114
00:03:43,440 --> 00:03:44,720
to them

115
00:03:44,720 --> 00:03:47,760
read 101 submissions this year which

116
00:03:47,760 --> 00:03:49,920
is a significant increase over the

117
00:03:49,920 --> 00:03:50,799
previous year

118
00:03:50,799 --> 00:03:53,360
and we were already on a steady climb

119
00:03:53,360 --> 00:03:55,200
101 i think is about 30

120
00:03:55,200 --> 00:03:58,480
papers submitted beyond last year's

121
00:03:58,480 --> 00:04:00,560
from those the program committee worked

122
00:04:00,560 --> 00:04:02,879
very hard and picked out 36 which are

123
00:04:02,879 --> 00:04:04,640
the papers that you will see

124
00:04:04,640 --> 00:04:06,720
over the next four days in addition to

125
00:04:06,720 --> 00:04:09,280
that we have six invited talks

126
00:04:09,280 --> 00:04:11,360
the overall format of the talks is that

127
00:04:11,360 --> 00:04:12,959
the contributed talks that were accepted

128
00:04:12,959 --> 00:04:14,720
into the program will have 15 minutes in

129
00:04:14,720 --> 00:04:15,760
total

130
00:04:15,760 --> 00:04:18,079
10 minutes of live presentation followed

131
00:04:18,079 --> 00:04:20,320
by five minutes of question and answer

132
00:04:20,320 --> 00:04:23,199
and if the authors chose to they also

133
00:04:23,199 --> 00:04:25,040
had the option of providing us with a

134
00:04:25,040 --> 00:04:25,680
longer

135
00:04:25,680 --> 00:04:29,440
format talk recorded in video so you can

136
00:04:29,440 --> 00:04:30,800
think of this as kind of being like the

137
00:04:30,800 --> 00:04:32,320
the camera ready version of the paper

138
00:04:32,320 --> 00:04:32,960
versus the

139
00:04:32,960 --> 00:04:35,199
the full version of the paper and then

140
00:04:35,199 --> 00:04:36,960
for the invited talks

141
00:04:36,960 --> 00:04:39,759
they have a total of uh 30 minutes which

142
00:04:39,759 --> 00:04:41,520
we're imagining is something like 25

143
00:04:41,520 --> 00:04:42,880
minutes of presentation and five minutes

144
00:04:42,880 --> 00:04:45,280
a question answer following

145
00:04:45,280 --> 00:04:47,600
uh just before i wrap this up i want to

146
00:04:47,600 --> 00:04:48,960
make uh

147
00:04:48,960 --> 00:04:52,080
really give a special special thank you

148
00:04:52,080 --> 00:04:55,440
to kevin mccurley and k mckelly

149
00:04:55,440 --> 00:04:58,160
who you all don't know this in the

150
00:04:58,160 --> 00:05:00,560
audience but these two people

151
00:05:00,560 --> 00:05:04,080
have worked countless hours behind the

152
00:05:04,080 --> 00:05:04,800
scenes

153
00:05:04,800 --> 00:05:08,479
preparing the rdbc website the social

154
00:05:08,479 --> 00:05:09,360
app

155
00:05:09,360 --> 00:05:11,759
all of the sort of internet related

156
00:05:11,759 --> 00:05:12,880
stuff

157
00:05:12,880 --> 00:05:15,440
that is happening is really all due to

158
00:05:15,440 --> 00:05:15,919
them

159
00:05:15,919 --> 00:05:18,720
they have worked a huge number of hours

160
00:05:18,720 --> 00:05:19,840
and

161
00:05:19,840 --> 00:05:21,440
were we there in person at this point i

162
00:05:21,440 --> 00:05:22,880
would ask you to stop and give a round

163
00:05:22,880 --> 00:05:24,560
of applause to them because

164
00:05:24,560 --> 00:05:26,320
they really deserve it so if you're

165
00:05:26,320 --> 00:05:27,600
sitting there in your room and you and

166
00:05:27,600 --> 00:05:28,160
you

167
00:05:28,160 --> 00:05:29,759
feel motivated to clap then i strongly

168
00:05:29,759 --> 00:05:31,039
encourage you to do so because they have

169
00:05:31,039 --> 00:05:33,039
worked super hard on your behalf

170
00:05:33,039 --> 00:05:35,600
try to make this event which you know is

171
00:05:35,600 --> 00:05:36,560
our first virtual

172
00:05:36,560 --> 00:05:40,000
uh conference um try to make it

173
00:05:40,000 --> 00:05:42,960
really uh as close as one can make it to

174
00:05:42,960 --> 00:05:43,199
an

175
00:05:43,199 --> 00:05:45,759
actual in-person event while still um

176
00:05:45,759 --> 00:05:48,479
being virtual so special thanks to them

177
00:05:48,479 --> 00:05:49,680
that's going to do it for me i've

178
00:05:49,680 --> 00:05:50,960
already taken up five minutes of your

179
00:05:50,960 --> 00:05:51,919
time

180
00:05:51,919 --> 00:05:54,199
i just want to say again welcome to

181
00:05:54,199 --> 00:05:55,520
rdbc2021

182
00:05:55,520 --> 00:05:57,759
i can't wait to see all of you in person

183
00:05:57,759 --> 00:05:59,919
in amsterdam next year

184
00:05:59,919 --> 00:06:02,639
um if you do happen to run into a member

185
00:06:02,639 --> 00:06:04,319
of the program committee in one of the

186
00:06:04,319 --> 00:06:05,840
chat rooms please do thank them for all

187
00:06:05,840 --> 00:06:08,560
their work likewise for kevin and kay

188
00:06:08,560 --> 00:06:10,240
if you happen to see a sponsor thank

189
00:06:10,240 --> 00:06:12,639
them for their support of this event

190
00:06:12,639 --> 00:06:21,840
and um yeah i hope you enjoy the program

191
00:06:26,080 --> 00:06:28,000
hopefully that came off okay it's the

192
00:06:28,000 --> 00:06:29,759
first time i've tried to do a video of

193
00:06:29,759 --> 00:06:33,440
zoom uh i don't know if any other

194
00:06:33,440 --> 00:06:34,720
steering committee members have anything

195
00:06:34,720 --> 00:06:36,240
they want to add or peter if there's

196
00:06:36,240 --> 00:06:38,960
anything you want to add

197
00:06:39,280 --> 00:06:41,680
well you didn't leave much for me to say

198
00:06:41,680 --> 00:06:42,960
there's uh

199
00:06:42,960 --> 00:06:44,479
just two things that i think i should

200
00:06:44,479 --> 00:06:46,319
announce one thing is a technical thing

201
00:06:46,319 --> 00:06:47,680
that we just noticed

202
00:06:47,680 --> 00:06:50,319
so if you've been at iscr conferences

203
00:06:50,319 --> 00:06:52,880
virtual icr conferences before

204
00:06:52,880 --> 00:06:54,800
then when you're opening the chat you

205
00:06:54,800 --> 00:06:55,919
may not see

206
00:06:55,919 --> 00:06:59,360
immediately the rwc 2021 chat so you

207
00:06:59,360 --> 00:07:01,120
need to add that stream on the left side

208
00:07:01,120 --> 00:07:02,880
by clicking on add stream and then

209
00:07:02,880 --> 00:07:06,319
rwc 2021 and then the second remark

210
00:07:06,319 --> 00:07:08,639
is that even with global warming you

211
00:07:08,639 --> 00:07:10,639
would be very lucky to see tulip fields

212
00:07:10,639 --> 00:07:12,479
in january in the netherlands

213
00:07:12,479 --> 00:07:13,919
so if you want to experience those

214
00:07:13,919 --> 00:07:15,360
you'll have to stay around for a little

215
00:07:15,360 --> 00:07:16,000
bit longer

216
00:07:16,000 --> 00:07:19,440
next year in 2010 too so that's all

217
00:07:19,440 --> 00:07:21,759
from my side and also from the general

218
00:07:21,759 --> 00:07:23,280
chairs i'm also speaking i think for

219
00:07:23,280 --> 00:07:27,359
leila and yoan welcome to the conference

220
00:07:28,400 --> 00:07:29,759
hey you did you want to say something

221
00:07:29,759 --> 00:07:32,880
about the social app

222
00:07:34,080 --> 00:07:37,759
uh yes um

223
00:07:37,759 --> 00:07:40,080
there's uh i just said kenny but cave

224
00:07:40,080 --> 00:07:44,240
you wanted

225
00:07:44,240 --> 00:07:46,240
let me let me introduce uh kay who was

226
00:07:46,240 --> 00:07:47,280
mentioned before

227
00:07:47,280 --> 00:07:50,479
by tom uh kay and uh kevin mccarthy

228
00:07:50,479 --> 00:07:51,759
working together have done an amazing

229
00:07:51,759 --> 00:07:53,840
job building an entire app just for this

230
00:07:53,840 --> 00:07:55,919
conference with lots of new features

231
00:07:55,919 --> 00:07:57,840
uh okay i don't wanna we have time if

232
00:07:57,840 --> 00:07:59,199
you wanna take a minute just to

233
00:07:59,199 --> 00:08:01,360
mention a couple of the highlights of

234
00:08:01,360 --> 00:08:02,639
the features that you've built

235
00:08:02,639 --> 00:08:04,879
it'd be really cool to hear about them

236
00:08:04,879 --> 00:08:05,840
uh

237
00:08:05,840 --> 00:08:09,280
yes now actually me um so

238
00:08:09,280 --> 00:08:12,160
i will uh encourage you to check out the

239
00:08:12,160 --> 00:08:13,680
social app you can find it

240
00:08:13,680 --> 00:08:16,400
from the conference program um we will

241
00:08:16,400 --> 00:08:17,440
be running our

242
00:08:17,440 --> 00:08:19,599
social hours through that as well as

243
00:08:19,599 --> 00:08:20,960
through zoom

244
00:08:20,960 --> 00:08:23,440
with having um hangouts which are sort

245
00:08:23,440 --> 00:08:26,080
of like really casual amas

246
00:08:26,080 --> 00:08:28,560
through zoom during the social hours

247
00:08:28,560 --> 00:08:30,960
those will change each day

248
00:08:30,960 --> 00:08:33,519
and the only other things i would like

249
00:08:33,519 --> 00:08:34,080
to say

250
00:08:34,080 --> 00:08:37,839
are there may be during the conference

251
00:08:37,839 --> 00:08:40,080
a slightly weird different thing from

252
00:08:40,080 --> 00:08:41,200
when you've gone to

253
00:08:41,200 --> 00:08:44,159
uh virtual conferences with iacr before

254
00:08:44,159 --> 00:08:46,320
we will be using breakout rooms to

255
00:08:46,320 --> 00:08:48,399
diagnose technical issues address code

256
00:08:48,399 --> 00:08:50,399
of conduct anything like that

257
00:08:50,399 --> 00:08:52,399
so if you see during the talks that

258
00:08:52,399 --> 00:08:53,680
breakout rooms have opened

259
00:08:53,680 --> 00:08:55,279
please ignore that it's not for you

260
00:08:55,279 --> 00:08:56,880
unless you were automatically moved into

261
00:08:56,880 --> 00:08:58,399
the breakout room in which case it is

262
00:08:58,399 --> 00:08:59,279
for you

263
00:08:59,279 --> 00:09:02,480
um and i think that's it

264
00:09:02,480 --> 00:09:05,920
kevin is that right yeah i'll just make

265
00:09:05,920 --> 00:09:07,760
one comment that i discovered i was

266
00:09:07,760 --> 00:09:09,200
reminded this weekend

267
00:09:09,200 --> 00:09:11,760
that uh safari is the new internet

268
00:09:11,760 --> 00:09:12,880
explorer

269
00:09:12,880 --> 00:09:14,480
and i had to rewrite the distributed

270
00:09:14,480 --> 00:09:16,080
protocol for the social app

271
00:09:16,080 --> 00:09:18,240
to keep the server from melting down

272
00:09:18,240 --> 00:09:20,959
from safari's inability to keep a

273
00:09:20,959 --> 00:09:23,839
websocket open

274
00:09:24,080 --> 00:09:28,240
so use safari with caution

275
00:09:30,880 --> 00:09:32,560
all right well that's it then i guess we

276
00:09:32,560 --> 00:09:34,800
can turn it over to dave to

277
00:09:34,800 --> 00:09:37,839
start the first session

278
00:09:39,519 --> 00:09:41,760
hi everyone this is dave archer um

279
00:09:41,760 --> 00:09:43,200
chairing the session for

280
00:09:43,200 --> 00:09:45,200
secure channels so in this first session

281
00:09:45,200 --> 00:09:48,000
of rwc 2021 we're very fortunate to have

282
00:09:48,000 --> 00:09:48,720
four

283
00:09:48,720 --> 00:09:50,080
exciting talks about secure

284
00:09:50,080 --> 00:09:52,000
communication channels on untrustworthy

285
00:09:52,000 --> 00:09:52,880
networks

286
00:09:52,880 --> 00:09:55,279
uh the topics range from formal notions

287
00:09:55,279 --> 00:09:57,040
of channel robustness and their impact

288
00:09:57,040 --> 00:09:58,160
on security

289
00:09:58,160 --> 00:10:00,080
to side channel attacks against tls

290
00:10:00,080 --> 00:10:02,000
deputy helman to attacks against

291
00:10:02,000 --> 00:10:04,079
authenticated encryption schemes all the

292
00:10:04,079 --> 00:10:06,079
way to resource efficient post quantum

293
00:10:06,079 --> 00:10:08,160
tls handshake protocols

294
00:10:08,160 --> 00:10:11,600
so as tom said each talk is 10 minutes

295
00:10:11,600 --> 00:10:13,519
followed by five minutes of q a

296
00:10:13,519 --> 00:10:16,079
i'll offer an audible two-minute warning

297
00:10:16,079 --> 00:10:17,519
if you would like to ask a question of

298
00:10:17,519 --> 00:10:19,360
the presenter please post your questions

299
00:10:19,360 --> 00:10:20,640
in the zoolip channel

300
00:10:20,640 --> 00:10:24,240
not the chat channel here and zoom

301
00:10:24,240 --> 00:10:26,160
and i'll relay them to the speaker once

302
00:10:26,160 --> 00:10:27,440
speaker's done

303
00:10:27,440 --> 00:10:29,600
so with that i'd like to introduce our

304
00:10:29,600 --> 00:10:31,360
first speaker phoenix gunther

305
00:10:31,360 --> 00:10:32,720
who will be telling us about new

306
00:10:32,720 --> 00:10:34,959
robustness notions

307
00:10:34,959 --> 00:10:38,560
for secured channels

308
00:10:41,760 --> 00:10:46,240
felix your arm

309
00:10:46,240 --> 00:10:50,000
see now how do you hear me now yes

310
00:10:50,000 --> 00:10:51,360
okay thank you very much for the

311
00:10:51,360 --> 00:10:53,440
introduction i want to talk to you about

312
00:10:53,440 --> 00:10:55,600
uh joint work today with mark fischling

313
00:10:55,600 --> 00:10:56,880
and christian janssen

314
00:10:56,880 --> 00:10:58,880
from theod armstead where we're

315
00:10:58,880 --> 00:11:00,160
interested in how

316
00:11:00,160 --> 00:11:03,680
quick and dtls1 1.3 behave

317
00:11:03,680 --> 00:11:06,880
over and in an unreliable network so

318
00:11:06,880 --> 00:11:09,360
as you may recall quicken dtls run over

319
00:11:09,360 --> 00:11:10,000
udp

320
00:11:10,000 --> 00:11:13,120
to protect application level data and we

321
00:11:13,120 --> 00:11:14,079
were asking ourselves

322
00:11:14,079 --> 00:11:15,519
what does this mean in terms of the

323
00:11:15,519 --> 00:11:17,519
secure channel guarantees that quick and

324
00:11:17,519 --> 00:11:18,800
detailers provide

325
00:11:18,800 --> 00:11:21,680
running over this unreliable network so

326
00:11:21,680 --> 00:11:23,839
just to briefly recap

327
00:11:23,839 --> 00:11:25,440
generally in crypto we think of secure

328
00:11:25,440 --> 00:11:28,079
channels as like tls running over a

329
00:11:28,079 --> 00:11:30,079
reliable transport like tcp so you would

330
00:11:30,079 --> 00:11:30,640
have

331
00:11:30,640 --> 00:11:32,480
a sender alice sending a bunch of

332
00:11:32,480 --> 00:11:35,200
messages and then bob would receive them

333
00:11:35,200 --> 00:11:38,880
in order guaranteed by tcp or if not

334
00:11:38,880 --> 00:11:40,959
there might be an active adversary

335
00:11:40,959 --> 00:11:42,320
interfering and

336
00:11:42,320 --> 00:11:44,399
can tell this and will reject any

337
00:11:44,399 --> 00:11:45,680
non-inorder packets and

338
00:11:45,680 --> 00:11:48,720
tear down the connection right away

339
00:11:48,720 --> 00:11:50,160
now of course this picture is different

340
00:11:50,160 --> 00:11:51,360
if we're running over unreliable

341
00:11:51,360 --> 00:11:53,279
transport like udp because the network

342
00:11:53,279 --> 00:11:54,160
itself

343
00:11:54,160 --> 00:11:56,000
might reorder packets sometimes even

344
00:11:56,000 --> 00:11:57,279
duplicate things

345
00:11:57,279 --> 00:11:58,880
stuff may get lost and of course we

346
00:11:58,880 --> 00:12:00,320
still have potentially an

347
00:12:00,320 --> 00:12:02,800
active adversary that we might want to

348
00:12:02,800 --> 00:12:05,360
protect against on that secure channel

349
00:12:05,360 --> 00:12:06,959
so the question is how should the

350
00:12:06,959 --> 00:12:09,440
receiver handle that kind of

351
00:12:09,440 --> 00:12:13,120
incoming messages there's many choices

352
00:12:13,120 --> 00:12:15,120
uh i said there is replays duplicates

353
00:12:15,120 --> 00:12:16,480
you have to decide whether you want to

354
00:12:16,480 --> 00:12:17,279
prevent them

355
00:12:17,279 --> 00:12:18,800
quick says you must prevent them for

356
00:12:18,800 --> 00:12:20,480
detail as it's optional

357
00:12:20,480 --> 00:12:23,120
you can't do this generally you have to

358
00:12:23,120 --> 00:12:24,320
decide which kind of

359
00:12:24,320 --> 00:12:26,720
window you want to check for replace

360
00:12:26,720 --> 00:12:28,959
usually you use a sliding anti-replica

361
00:12:28,959 --> 00:12:30,079
window here

362
00:12:30,079 --> 00:12:31,760
there is reordering well should you

363
00:12:31,760 --> 00:12:33,440
permit this if you're running over udp

364
00:12:33,440 --> 00:12:35,680
you have to handle it one way or another

365
00:12:35,680 --> 00:12:38,000
and quicken dtls settle for a dynamic

366
00:12:38,000 --> 00:12:40,399
sliding window where you would accept

367
00:12:40,399 --> 00:12:42,079
incoming packets around a cert in a

368
00:12:42,079 --> 00:12:43,760
certain window around the last package

369
00:12:43,760 --> 00:12:44,720
you received

370
00:12:44,720 --> 00:12:46,560
and the size of that window is

371
00:12:46,560 --> 00:12:47,839
determined on the sender side

372
00:12:47,839 --> 00:12:50,000
dynamically actually

373
00:12:50,000 --> 00:12:51,200
of course there's still adversarial

374
00:12:51,200 --> 00:12:52,800
interaction you want to maintain

375
00:12:52,800 --> 00:12:53,680
integrity

376
00:12:53,680 --> 00:12:55,680
and reject non-genuine packets both

377
00:12:55,680 --> 00:12:58,000
protocols resort to the aad pro to an

378
00:12:58,000 --> 00:12:58,959
aad

379
00:12:58,959 --> 00:13:01,839
building block for that now we were

380
00:13:01,839 --> 00:13:03,200
interested in the question how

381
00:13:03,200 --> 00:13:05,920
you formally guarantee that those kind

382
00:13:05,920 --> 00:13:07,920
of replays reorderings or adversary

383
00:13:07,920 --> 00:13:08,560
interaction

384
00:13:08,560 --> 00:13:10,880
don't affect the processing of other

385
00:13:10,880 --> 00:13:12,240
genuine packets

386
00:13:12,240 --> 00:13:14,560
and for this we coin the new the notion

387
00:13:14,560 --> 00:13:17,920
of robustness of a channel

388
00:13:17,920 --> 00:13:19,519
now before we can go into the security

389
00:13:19,519 --> 00:13:21,600
part of that uh let me first give you a

390
00:13:21,600 --> 00:13:23,200
flavor a feeling of like

391
00:13:23,200 --> 00:13:25,920
what we use to frame uh these kind of

392
00:13:25,920 --> 00:13:27,519
channels in a new

393
00:13:27,519 --> 00:13:30,000
type of formalism that goes beyond prior

394
00:13:30,000 --> 00:13:31,120
hierarchies

395
00:13:31,120 --> 00:13:32,720
so we want to parameterize the channel

396
00:13:32,720 --> 00:13:34,240
definition with

397
00:13:34,240 --> 00:13:36,320
the notion of what a channel supports in

398
00:13:36,320 --> 00:13:38,959
terms of receiving ciphertext

399
00:13:38,959 --> 00:13:41,440
so for that we use introduce a support

400
00:13:41,440 --> 00:13:43,199
predicate which kind of takes a network

401
00:13:43,199 --> 00:13:44,720
view on the connection

402
00:13:44,720 --> 00:13:47,040
and gets this input the send sequence of

403
00:13:47,040 --> 00:13:48,639
ciphertext

404
00:13:48,639 --> 00:13:51,120
the received sequence on the receiver's

405
00:13:51,120 --> 00:13:51,920
end

406
00:13:51,920 --> 00:13:53,519
including those ciphertexts which have

407
00:13:53,519 --> 00:13:55,760
been supported so far

408
00:13:55,760 --> 00:13:58,399
and the next ciphertext arriving and the

409
00:13:58,399 --> 00:13:59,680
support predicate is supposed to

410
00:13:59,680 --> 00:14:01,199
determine whether this next

411
00:14:01,199 --> 00:14:04,079
text for this particular channel should

412
00:14:04,079 --> 00:14:06,480
be accepted or not

413
00:14:06,480 --> 00:14:08,240
now correctness for now only demands

414
00:14:08,240 --> 00:14:10,079
that if you have genuine ciphertext

415
00:14:10,079 --> 00:14:10,959
being sent

416
00:14:10,959 --> 00:14:12,160
which are supported they should

417
00:14:12,160 --> 00:14:14,880
correctly be decrypted

418
00:14:14,880 --> 00:14:17,680
so what is robustness about well with

419
00:14:17,680 --> 00:14:19,199
robustness we want to capture this

420
00:14:19,199 --> 00:14:20,399
intuition to say that

421
00:14:20,399 --> 00:14:22,320
malicious packets shouldn't or cannot

422
00:14:22,320 --> 00:14:24,959
disturb the expected channel behavior

423
00:14:24,959 --> 00:14:27,279
so if bob the receiver determined a

424
00:14:27,279 --> 00:14:28,079
certain

425
00:14:28,079 --> 00:14:30,079
pattern of accepting packets then

426
00:14:30,079 --> 00:14:31,920
whether there is an adversarial packet

427
00:14:31,920 --> 00:14:33,440
coming in between those

428
00:14:33,440 --> 00:14:36,880
shouldn't affect those decisions

429
00:14:36,880 --> 00:14:38,320
now of course today i don't have the

430
00:14:38,320 --> 00:14:40,560
time to give you a full

431
00:14:40,560 --> 00:14:42,880
definition of how we frame that but to

432
00:14:42,880 --> 00:14:44,160
give you an idea of what

433
00:14:44,160 --> 00:14:46,800
how we formalize robustness um let's

434
00:14:46,800 --> 00:14:47,519
look at

435
00:14:47,519 --> 00:14:50,079
a certain um like a receiver in the

436
00:14:50,079 --> 00:14:50,800
network

437
00:14:50,800 --> 00:14:53,440
and now we define the correct supported

438
00:14:53,440 --> 00:14:54,320
sub trace

439
00:14:54,320 --> 00:14:56,720
of whatever this receiver gets to see

440
00:14:56,720 --> 00:14:58,800
and we feed that sub trace into

441
00:14:58,800 --> 00:15:01,600
a kind of local shadow copy a shadow

442
00:15:01,600 --> 00:15:02,560
receiver

443
00:15:02,560 --> 00:15:04,639
and by correctness now we're guaranteed

444
00:15:04,639 --> 00:15:06,639
that this shadow receiver

445
00:15:06,639 --> 00:15:08,720
will properly decrypt all these messages

446
00:15:08,720 --> 00:15:10,240
because all these ciphertexts into

447
00:15:10,240 --> 00:15:11,839
proper messages

448
00:15:11,839 --> 00:15:13,199
as they have been supported by the

449
00:15:13,199 --> 00:15:14,800
channel and there is no adversary

450
00:15:14,800 --> 00:15:16,480
interaction

451
00:15:16,480 --> 00:15:18,800
now robustness essentially demands that

452
00:15:18,800 --> 00:15:20,079
the actual receiver

453
00:15:20,079 --> 00:15:22,320
comes to the same conclusions for

454
00:15:22,320 --> 00:15:24,160
decrypting those messages as the shadow

455
00:15:24,160 --> 00:15:25,680
receiver without any

456
00:15:25,680 --> 00:15:27,760
adversarial tempering would would come

457
00:15:27,760 --> 00:15:29,199
to you

458
00:15:29,199 --> 00:15:30,959
of course you may ask what about those

459
00:15:30,959 --> 00:15:32,800
gaps what about the non-supported cipher

460
00:15:32,800 --> 00:15:33,360
text

461
00:15:33,360 --> 00:15:35,279
and this is exactly where robustness is

462
00:15:35,279 --> 00:15:36,880
complemented by integrity

463
00:15:36,880 --> 00:15:39,759
those two are orthogonal actually and so

464
00:15:39,759 --> 00:15:41,279
integrity would demand that

465
00:15:41,279 --> 00:15:43,279
beyond those robust decryptions of

466
00:15:43,279 --> 00:15:45,040
supported ciphertext

467
00:15:45,040 --> 00:15:48,399
the channels should reject any uh

468
00:15:48,399 --> 00:15:49,920
of the like all the other ciphertexts

469
00:15:49,920 --> 00:15:52,839
which are not supported giving you

470
00:15:52,839 --> 00:15:54,000
integrity

471
00:15:54,000 --> 00:15:55,920
very briefly with that we can form a

472
00:15:55,920 --> 00:15:57,040
hierarchy where

473
00:15:57,040 --> 00:15:58,399
beyond the classical notions of

474
00:15:58,399 --> 00:16:00,720
integrity and confidentiality

475
00:16:00,720 --> 00:16:02,880
we can place robustness combine this

476
00:16:02,880 --> 00:16:04,079
with integrity

477
00:16:04,079 --> 00:16:06,320
or all together having a robust

478
00:16:06,320 --> 00:16:07,120
confidential

479
00:16:07,120 --> 00:16:09,839
and integrity combining notion which we

480
00:16:09,839 --> 00:16:10,320
can

481
00:16:10,320 --> 00:16:12,959
arrive at by either combining passive

482
00:16:12,959 --> 00:16:15,440
confidentiality with robust integrity

483
00:16:15,440 --> 00:16:17,199
or if you happen to have already a

484
00:16:17,199 --> 00:16:19,440
security result in the classical

485
00:16:19,440 --> 00:16:21,040
sense giving you confidentiality and

486
00:16:21,040 --> 00:16:22,639
integrity and you can also add

487
00:16:22,639 --> 00:16:23,839
robustness to that

488
00:16:23,839 --> 00:16:25,759
to end up at the strongest highest

489
00:16:25,759 --> 00:16:28,079
notion

490
00:16:28,240 --> 00:16:30,240
okay so with this hierarchy let's go

491
00:16:30,240 --> 00:16:31,440
back and come back to

492
00:16:31,440 --> 00:16:33,759
quick just to give you a glance of our

493
00:16:33,759 --> 00:16:35,199
results

494
00:16:35,199 --> 00:16:37,759
for the matter of the talk today you can

495
00:16:37,759 --> 00:16:38,639
consider the

496
00:16:38,639 --> 00:16:41,600
quick packets to be consisting of an aad

497
00:16:41,600 --> 00:16:43,199
ciphertext and a header and in this

498
00:16:43,199 --> 00:16:43,759
header

499
00:16:43,759 --> 00:16:45,680
we're particularly considering or

500
00:16:45,680 --> 00:16:47,759
interested in the packet number which

501
00:16:47,759 --> 00:16:50,000
enters as a sequence number the nonce

502
00:16:50,000 --> 00:16:52,639
for the aad encryption and decryption

503
00:16:52,639 --> 00:16:53,279
now

504
00:16:53,279 --> 00:16:55,600
quick only sends a partial packet number

505
00:16:55,600 --> 00:16:56,720
so the few

506
00:16:56,720 --> 00:16:59,440
a few trailing bits are that packet

507
00:16:59,440 --> 00:17:00,399
number

508
00:17:00,399 --> 00:17:02,880
which defines on the receiver side

509
00:17:02,880 --> 00:17:04,480
dynamic sliding window

510
00:17:04,480 --> 00:17:08,400
in which packets are accepted

511
00:17:08,400 --> 00:17:10,319
quick also as said checks for replay so

512
00:17:10,319 --> 00:17:11,679
there will be a certain replay check

513
00:17:11,679 --> 00:17:12,240
window

514
00:17:12,240 --> 00:17:13,919
and now if you have a package like the

515
00:17:13,919 --> 00:17:15,359
one here arriving

516
00:17:15,359 --> 00:17:17,439
with three zero last zero bits this is

517
00:17:17,439 --> 00:17:19,039
of course a toy example

518
00:17:19,039 --> 00:17:20,799
then you would sort this in as packet

519
00:17:20,799 --> 00:17:22,640
number eight and if decryption works

520
00:17:22,640 --> 00:17:23,439
properly

521
00:17:23,439 --> 00:17:25,599
we can proceed to the next packet and

522
00:17:25,599 --> 00:17:28,399
everything is fine

523
00:17:28,960 --> 00:17:32,080
now our formalism of support predicates

524
00:17:32,080 --> 00:17:34,000
without going into details

525
00:17:34,000 --> 00:17:36,320
supports this behavior of having dynamic

526
00:17:36,320 --> 00:17:37,840
sliding windows which are defined on the

527
00:17:37,840 --> 00:17:38,880
center side

528
00:17:38,880 --> 00:17:42,000
and these replay windows and i won't go

529
00:17:42,000 --> 00:17:43,679
into the details here but you can find

530
00:17:43,679 --> 00:17:47,039
the formalism for that in our paper

531
00:17:47,039 --> 00:17:49,200
now that we can look at what kind of so

532
00:17:49,200 --> 00:17:50,880
now that we have it as a kind of formal

533
00:17:50,880 --> 00:17:52,960
model in our in our setting what is the

534
00:17:52,960 --> 00:17:54,960
security we can establish

535
00:17:54,960 --> 00:17:56,960
we actually show that quick the quick

536
00:17:56,960 --> 00:17:58,480
record protocol gives you

537
00:17:58,480 --> 00:18:01,200
robust confidentiality and integrity for

538
00:18:01,200 --> 00:18:04,880
the support predicate we just saw

539
00:18:04,880 --> 00:18:07,280
and for that result we use our hierarchy

540
00:18:07,280 --> 00:18:08,640
so we combine

541
00:18:08,640 --> 00:18:11,440
passive confidentiality cpa security

542
00:18:11,440 --> 00:18:12,559
which comes from the

543
00:18:12,559 --> 00:18:14,720
privacy guarantees of the underlying aed

544
00:18:14,720 --> 00:18:15,840
scheme

545
00:18:15,840 --> 00:18:18,320
with robust integrity which we can prove

546
00:18:18,320 --> 00:18:19,919
based on the authenticity

547
00:18:19,919 --> 00:18:22,720
of the underlying ad scheme there is one

548
00:18:22,720 --> 00:18:24,640
important point here

549
00:18:24,640 --> 00:18:26,400
namely that because of the unreliable

550
00:18:26,400 --> 00:18:28,720
transport an adversary is not restricted

551
00:18:28,720 --> 00:18:29,840
to a single forgery

552
00:18:29,840 --> 00:18:32,240
like on tls for example but can make

553
00:18:32,240 --> 00:18:33,840
multiple forgeries because quick

554
00:18:33,840 --> 00:18:35,840
will throw away a packet that it can't

555
00:18:35,840 --> 00:18:37,200
decrypt properly but it doesn't know

556
00:18:37,200 --> 00:18:38,960
whether this was adversarial

557
00:18:38,960 --> 00:18:43,200
or actually just a network

558
00:18:43,200 --> 00:18:46,000
hiccup kind of so it will throw away the

559
00:18:46,000 --> 00:18:47,520
packet but continue which means the

560
00:18:47,520 --> 00:18:49,120
adversary if it's actually trying to

561
00:18:49,120 --> 00:18:52,000
forge packets can also continue to do so

562
00:18:52,000 --> 00:18:54,160
which means in our security reduction to

563
00:18:54,160 --> 00:18:57,200
plain authenticity of aad schemes

564
00:18:57,200 --> 00:18:58,960
we lose a factor in the number of

565
00:18:58,960 --> 00:19:00,400
received cipher attacks or forgery

566
00:19:00,400 --> 00:19:02,400
attempts

567
00:19:02,400 --> 00:19:05,120
now this might to some of you at least

568
00:19:05,120 --> 00:19:07,039
on second or third thought not

569
00:19:07,039 --> 00:19:10,320
seems extremely surprising however it

570
00:19:10,320 --> 00:19:12,000
wasn't considered so far when we looked

571
00:19:12,000 --> 00:19:12,640
at the

572
00:19:12,640 --> 00:19:16,640
quick and dtls drafts uh back a year ago

573
00:19:16,640 --> 00:19:18,480
while confidentiality limits had been in

574
00:19:18,480 --> 00:19:20,160
place there was nothing about

575
00:19:20,160 --> 00:19:21,520
like doing something special about

576
00:19:21,520 --> 00:19:24,960
integrity so

577
00:19:25,360 --> 00:19:28,480
thanks so in response to our

578
00:19:28,480 --> 00:19:31,039
work the iatf working groups updated the

579
00:19:31,039 --> 00:19:33,280
quick and etlas 1.3 drafts

580
00:19:33,280 --> 00:19:34,960
in order to mandate concrete forger

581
00:19:34,960 --> 00:19:36,640
limits so now it says you have to count

582
00:19:36,640 --> 00:19:37,360
the number

583
00:19:37,360 --> 00:19:39,840
of forgery attempts and if this crosses

584
00:19:39,840 --> 00:19:40,559
a certain

585
00:19:40,559 --> 00:19:42,720
limit and you have to tear down the

586
00:19:42,720 --> 00:19:43,919
connection in order to not

587
00:19:43,919 --> 00:19:46,000
get the have the security margin you

588
00:19:46,000 --> 00:19:48,880
have become too small

589
00:19:48,880 --> 00:19:50,559
extracting the precise limits for that

590
00:19:50,559 --> 00:19:52,720
wasn't always extremely easy let's say

591
00:19:52,720 --> 00:19:55,600
um so following that chris wood martin

592
00:19:55,600 --> 00:19:56,720
something and i

593
00:19:56,720 --> 00:19:59,840
um started to look into a cfrg

594
00:19:59,840 --> 00:20:02,240
document draft where we want to talk

595
00:20:02,240 --> 00:20:04,400
about when we want to document the usage

596
00:20:04,400 --> 00:20:06,320
limits for a certain aad algorithms

597
00:20:06,320 --> 00:20:09,039
the idea being to provide user guidance

598
00:20:09,039 --> 00:20:10,320
on those limits

599
00:20:10,320 --> 00:20:12,480
for both confidentiality and integrity

600
00:20:12,480 --> 00:20:13,440
in a single and

601
00:20:13,440 --> 00:20:15,520
multi-key setting and for a number of

602
00:20:15,520 --> 00:20:19,520
different standardized aad algorithms

603
00:20:19,679 --> 00:20:22,320
all right so to conclude in summary um

604
00:20:22,320 --> 00:20:24,320
we introduce robustness as a new

605
00:20:24,320 --> 00:20:26,159
first-class security property for

606
00:20:26,159 --> 00:20:27,280
channels

607
00:20:27,280 --> 00:20:29,919
where we want to capture this idea of

608
00:20:29,919 --> 00:20:31,200
having a guarantee that malicious

609
00:20:31,200 --> 00:20:32,799
packets cannot disturb

610
00:20:32,799 --> 00:20:36,400
the expected channel behavior we analyze

611
00:20:36,400 --> 00:20:39,200
the quick and dtls 1.3 protocols

612
00:20:39,200 --> 00:20:41,440
capturing both their dynamic sliding

613
00:20:41,440 --> 00:20:42,480
window

614
00:20:42,480 --> 00:20:44,240
component as well as replay tracking and

615
00:20:44,240 --> 00:20:46,559
other things we confirm that they

616
00:20:46,559 --> 00:20:47,919
achieve the intended robust

617
00:20:47,919 --> 00:20:49,679
confidentiality and integrity

618
00:20:49,679 --> 00:20:52,640
however add a certain non-tight security

619
00:20:52,640 --> 00:20:53,120
loss

620
00:20:53,120 --> 00:20:56,880
namely loss linear in the number of

621
00:20:56,880 --> 00:20:58,799
received cipher attacks and potential

622
00:20:58,799 --> 00:20:59,919
forgeries

623
00:20:59,919 --> 00:21:02,480
this led the working groups to update

624
00:21:02,480 --> 00:21:05,200
quick and dtls 1.3 in the draft versions

625
00:21:05,200 --> 00:21:07,440
to mandate concrete forgery limits

626
00:21:07,440 --> 00:21:09,440
upholding integrity

627
00:21:09,440 --> 00:21:11,200
you can find all details in our full

628
00:21:11,200 --> 00:21:12,960
version at eprint

629
00:21:12,960 --> 00:21:14,880
and i'm happy to take any questions that

630
00:21:14,880 --> 00:21:16,000
you might have now online

631
00:21:16,000 --> 00:21:19,520
or in the chat later thank you very much

632
00:21:19,520 --> 00:21:21,120
thanks very much felix that was a great

633
00:21:21,120 --> 00:21:22,880
talk um

634
00:21:22,880 --> 00:21:25,919
i have one question posted in the xero

635
00:21:25,919 --> 00:21:27,919
channel so far i'll read it out here

636
00:21:27,919 --> 00:21:30,240
from watson ladd who says in your

637
00:21:30,240 --> 00:21:31,679
definition of robustness i think

638
00:21:31,679 --> 00:21:33,760
reordered packets get dropped

639
00:21:33,760 --> 00:21:35,679
i'm curious how your work would apply to

640
00:21:35,679 --> 00:21:37,760
something like an encrypted tcp

641
00:21:37,760 --> 00:21:39,760
that fixes reordering by releasing data

642
00:21:39,760 --> 00:21:42,480
in the right order

643
00:21:42,720 --> 00:21:46,080
well so um so in that uh

644
00:21:46,080 --> 00:21:47,520
definition essentially the support

645
00:21:47,520 --> 00:21:49,520
predicates are something you would

646
00:21:49,520 --> 00:21:50,400
specify

647
00:21:50,400 --> 00:21:52,880
for the individual protocol that you're

648
00:21:52,880 --> 00:21:54,000
looking at

649
00:21:54,000 --> 00:21:56,559
so the example i i gave you was for

650
00:21:56,559 --> 00:21:57,280
quick

651
00:21:57,280 --> 00:21:59,120
and dtls which works relatively similar

652
00:21:59,120 --> 00:22:00,799
i should say

653
00:22:00,799 --> 00:22:02,720
but actually in our paper we give a

654
00:22:02,720 --> 00:22:04,080
range of

655
00:22:04,080 --> 00:22:06,159
different support predicates which

656
00:22:06,159 --> 00:22:07,520
capture basically

657
00:22:07,520 --> 00:22:10,559
everything from classical tls

658
00:22:10,559 --> 00:22:13,440
to dtls 1.2 or under other versions

659
00:22:13,440 --> 00:22:14,320
where you have different

660
00:22:14,320 --> 00:22:16,000
mechanisms in place so i guess the

661
00:22:16,000 --> 00:22:18,000
answer here would be

662
00:22:18,000 --> 00:22:19,679
that if the underlying transport does

663
00:22:19,679 --> 00:22:21,760
something specific for you in terms of

664
00:22:21,760 --> 00:22:22,880
reordering stuff

665
00:22:22,880 --> 00:22:25,520
then you might have a diff you will end

666
00:22:25,520 --> 00:22:27,120
up with a different support predicate

667
00:22:27,120 --> 00:22:28,559
for the cryptographic channel

668
00:22:28,559 --> 00:22:30,159
where you say even if there's more

669
00:22:30,159 --> 00:22:31,679
reordering going on

670
00:22:31,679 --> 00:22:33,200
because this is kind of solved on an

671
00:22:33,200 --> 00:22:34,720
underlying layer

672
00:22:34,720 --> 00:22:36,799
uh the channel would support more in

673
00:22:36,799 --> 00:22:40,000
that sense

674
00:22:40,000 --> 00:22:42,880
you uh see no other questions uh for no

675
00:22:42,880 --> 00:22:44,000
others then i think

676
00:22:44,000 --> 00:22:46,720
we're all set here i appreciate your

677
00:22:46,720 --> 00:22:49,120
talk very much

678
00:22:49,120 --> 00:22:51,760
uh let's move on to the next talk ah

679
00:22:51,760 --> 00:22:52,799
wait there's another question just

680
00:22:52,799 --> 00:22:54,799
coming up from darcy witzenberger

681
00:22:54,799 --> 00:22:56,799
who says does your notion of robustness

682
00:22:56,799 --> 00:22:58,799
account for at all for scenarios where

683
00:22:58,799 --> 00:23:02,720
an attacker selectively drops packets

684
00:23:02,720 --> 00:23:05,520
yes so in our model uh the adversary is

685
00:23:05,520 --> 00:23:06,480
basically

686
00:23:06,480 --> 00:23:08,720
controlling the communication between

687
00:23:08,720 --> 00:23:11,120
sender and receiver completely so it's

688
00:23:11,120 --> 00:23:14,240
fully capable of of doing any kind of

689
00:23:14,240 --> 00:23:16,240
modifications to the send

690
00:23:16,240 --> 00:23:18,159
ciphertext so you can particularly

691
00:23:18,159 --> 00:23:19,600
adaptively drop

692
00:23:19,600 --> 00:23:22,799
packages out of what is what is sent yes

693
00:23:22,799 --> 00:23:25,440
wonderful okay thanks very much i think

694
00:23:25,440 --> 00:23:27,200
if we're ready uh if robert is ready

695
00:23:27,200 --> 00:23:28,799
we're all ready to move on to the second

696
00:23:28,799 --> 00:23:29,600
talk

697
00:23:29,600 --> 00:23:32,720
now so our second speaker is robert

698
00:23:32,720 --> 00:23:33,840
murgan merger

699
00:23:33,840 --> 00:23:35,760
who will explore with us a novel side

700
00:23:35,760 --> 00:23:37,919
channel attack called the raccoon attack

701
00:23:37,919 --> 00:23:41,120
that exploits a timing

702
00:23:43,840 --> 00:23:45,760
a timing vulnerability in tls dippy

703
00:23:45,760 --> 00:23:48,080
helmet

704
00:23:48,240 --> 00:23:50,920
go ahead um

705
00:23:50,920 --> 00:23:52,559
[Music]

706
00:23:52,559 --> 00:23:56,799
okay you can hear me and see my slides

707
00:23:56,799 --> 00:24:00,000
yes yes yes okay great so

708
00:24:00,000 --> 00:24:01,919
hi my name is robert merget and today

709
00:24:01,919 --> 00:24:02,960
i'm here to present you a new

710
00:24:02,960 --> 00:24:05,520
vulnerability in the tls specification

711
00:24:05,520 --> 00:24:08,000
we which we will exploit in the raccoon

712
00:24:08,000 --> 00:24:08,640
attack

713
00:24:08,640 --> 00:24:10,720
this work is a joint research effort

714
00:24:10,720 --> 00:24:12,880
with marcus brinkmann nimrod aviram

715
00:24:12,880 --> 00:24:14,720
jorah zamorowski johannes mittman and

716
00:24:14,720 --> 00:24:16,880
yorkshwink

717
00:24:16,880 --> 00:24:18,720
for this audience i don't think ts needs

718
00:24:18,720 --> 00:24:20,000
much of an introduction

719
00:24:20,000 --> 00:24:22,000
ts is the defective standard protocol to

720
00:24:22,000 --> 00:24:23,760
establish a secured channel

721
00:24:23,760 --> 00:24:27,039
oops sorry a secure channel on the

722
00:24:27,039 --> 00:24:27,840
internet

723
00:24:27,840 --> 00:24:29,840
tsx is the many versions but we will

724
00:24:29,840 --> 00:24:31,760
focus on ts102 and older versions for

725
00:24:31,760 --> 00:24:32,000
this

726
00:24:32,000 --> 00:24:34,480
talk we will also focus on cypher suits

727
00:24:34,480 --> 00:24:36,159
which negotiate a finite field if you

728
00:24:36,159 --> 00:24:37,679
have a key exchange

729
00:24:37,679 --> 00:24:39,440
ts uses a handshake to negotiate with

730
00:24:39,440 --> 00:24:41,600
cryptographic algorithms and keys

731
00:24:41,600 --> 00:24:44,000
when we look into the tls handshake in

732
00:24:44,000 --> 00:24:45,440
detail

733
00:24:45,440 --> 00:24:47,039
we see that the handshake starts with a

734
00:24:47,039 --> 00:24:49,440
client and server exchanging nonsense

735
00:24:49,440 --> 00:24:51,360
after that the server is choosing a

736
00:24:51,360 --> 00:24:53,120
private key and sends the iffy hammer

737
00:24:53,120 --> 00:24:54,720
parameters and this public key together

738
00:24:54,720 --> 00:24:57,039
with the signature to the client

739
00:24:57,039 --> 00:24:58,480
the client then chooses the private key

740
00:24:58,480 --> 00:25:00,720
itself and responds with its own divi

741
00:25:00,720 --> 00:25:02,000
here and public key

742
00:25:02,000 --> 00:25:03,760
and with that both parties computer

743
00:25:03,760 --> 00:25:06,159
shared secret gta power of av

744
00:25:06,159 --> 00:25:08,559
once the secret is computed both parties

745
00:25:08,559 --> 00:25:09,919
can use with shared secret

746
00:25:09,919 --> 00:25:11,600
the nonsense and the labor to rewrite a

747
00:25:11,600 --> 00:25:14,080
master secret this master secret is when

748
00:25:14,080 --> 00:25:15,600
used to arrive for keys for the metric

749
00:25:15,600 --> 00:25:16,720
ciphers

750
00:25:16,720 --> 00:25:18,240
if you look at this design from this

751
00:25:18,240 --> 00:25:20,080
high-level view the design looks fine at

752
00:25:20,080 --> 00:25:20,960
first glance

753
00:25:20,960 --> 00:25:23,279
but vedava is always in the detail for

754
00:25:23,279 --> 00:25:24,720
our raccoon attack we will take

755
00:25:24,720 --> 00:25:26,400
advantage of two things

756
00:25:26,400 --> 00:25:28,000
firstly and what is missing in this kind

757
00:25:28,000 --> 00:25:30,640
of depiction is the fact that the shared

758
00:25:30,640 --> 00:25:32,320
secret is converted from a number

759
00:25:32,320 --> 00:25:34,559
to a byte sequence and leading bytes

760
00:25:34,559 --> 00:25:36,320
that contain only zeroes are stripped

761
00:25:36,320 --> 00:25:38,000
from the shared secret before they enter

762
00:25:38,000 --> 00:25:39,760
the solid random function

763
00:25:39,760 --> 00:25:41,120
the second thing that raccoon attack

764
00:25:41,120 --> 00:25:43,360
takes advantage of is that some servers

765
00:25:43,360 --> 00:25:43,919
reuse

766
00:25:43,919 --> 00:25:45,679
their diffie-helm and public key for

767
00:25:45,679 --> 00:25:47,120
multiple connections

768
00:25:47,120 --> 00:25:48,720
this can either be the case because of

769
00:25:48,720 --> 00:25:50,159
performance optimizations

770
00:25:50,159 --> 00:25:51,679
or due to a static diffie-herman

771
00:25:51,679 --> 00:25:53,279
handshake

772
00:25:53,279 --> 00:25:54,880
but why is it problematic that leading

773
00:25:54,880 --> 00:25:56,159
zeroes are stripped from the shared

774
00:25:56,159 --> 00:25:57,760
secret before it enters website a random

775
00:25:57,760 --> 00:25:58,960
function

776
00:25:58,960 --> 00:26:00,960
the core of a problem is that the solid

777
00:26:00,960 --> 00:26:02,480
random function is based on hash

778
00:26:02,480 --> 00:26:04,159
functions and these hash functions have

779
00:26:04,159 --> 00:26:04,880
a runtime of

780
00:26:04,880 --> 00:26:07,520
o of n and not o of 1. this means that

781
00:26:07,520 --> 00:26:08,960
the runtime of a hash function is

782
00:26:08,960 --> 00:26:10,000
dependent on the input

783
00:26:10,000 --> 00:26:11,919
length we all know that this is

784
00:26:11,919 --> 00:26:13,919
intuitively true as hashing a gigabyte

785
00:26:13,919 --> 00:26:15,760
of data is much slower when hashing only

786
00:26:15,760 --> 00:26:17,520
a few kilobytes

787
00:26:17,520 --> 00:26:20,320
however since the shared secret is not

788
00:26:20,320 --> 00:26:22,240
of constant length the execution time of

789
00:26:22,240 --> 00:26:23,520
a pif may vary

790
00:26:23,520 --> 00:26:24,880
depending on the leading bytes of a

791
00:26:24,880 --> 00:26:27,200
shared secret this timing side channel

792
00:26:27,200 --> 00:26:29,039
may arise from the number of invocate

793
00:26:29,039 --> 00:26:31,440
invoked compression functions if a hash

794
00:26:31,440 --> 00:26:32,559
function is used at all

795
00:26:32,559 --> 00:26:34,720
the padding or may even arise from buxom

796
00:26:34,720 --> 00:26:36,320
implementations

797
00:26:36,320 --> 00:26:37,760
these timing sections are similar to

798
00:26:37,760 --> 00:26:39,679
what was exploited in previous lucky 13

799
00:26:39,679 --> 00:26:42,480
style attacks on the record layer

800
00:26:42,480 --> 00:26:44,080
on a high level the attack now works as

801
00:26:44,080 --> 00:26:46,159
follows the attacker first has to

802
00:26:46,159 --> 00:26:47,600
observe a finite fear to fight

803
00:26:47,600 --> 00:26:49,679
handshake he then extracts the client's

804
00:26:49,679 --> 00:26:51,440
public key g to the power of a and

805
00:26:51,440 --> 00:26:53,279
multiplies it with g to the power of

806
00:26:53,279 --> 00:26:55,200
r where r is a random attacker chosen

807
00:26:55,200 --> 00:26:56,320
number

808
00:26:56,320 --> 00:26:58,000
advanced sends this new number to the

809
00:26:58,000 --> 00:26:59,919
server as part of an attacker-initiated

810
00:26:59,919 --> 00:27:01,360
connection together with an invalid

811
00:27:01,360 --> 00:27:02,559
finished message

812
00:27:02,559 --> 00:27:04,400
the server which receives this public

813
00:27:04,400 --> 00:27:06,480
key will compute the shared secret

814
00:27:06,480 --> 00:27:08,880
as g to the power of a b times g to the

815
00:27:08,880 --> 00:27:10,240
power of rb

816
00:27:10,240 --> 00:27:11,679
and as you might have noticed g to the

817
00:27:11,679 --> 00:27:13,520
power of a b is the original pre-master

818
00:27:13,520 --> 00:27:14,080
secret

819
00:27:14,080 --> 00:27:15,840
and g to the power of rb is a factor of

820
00:27:15,840 --> 00:27:18,720
attacker compute can compute itself

821
00:27:18,720 --> 00:27:20,559
the server will then try to decrypt the

822
00:27:20,559 --> 00:27:22,240
message from the attacker and notice

823
00:27:22,240 --> 00:27:23,919
that it's not encrypted correctly

824
00:27:23,919 --> 00:27:25,360
the server will then close the

825
00:27:25,360 --> 00:27:30,158
connection and or send an alert message

826
00:27:32,840 --> 00:27:35,440
um yeah

827
00:27:35,440 --> 00:27:39,440
uh oops sorry um

828
00:27:39,600 --> 00:27:41,760
okay in return the attacker measures the

829
00:27:41,760 --> 00:27:43,279
time it took the server to process the

830
00:27:43,279 --> 00:27:45,120
public key sent by the attacker

831
00:27:45,120 --> 00:27:46,640
if the attacker thinks that the message

832
00:27:46,640 --> 00:27:48,480
was processed faster than usual the

833
00:27:48,480 --> 00:27:49,919
attacker can conclude that the shared

834
00:27:49,919 --> 00:27:51,919
secrets started with a zero byte

835
00:27:51,919 --> 00:27:54,640
while if a server took a little longer

836
00:27:54,640 --> 00:27:56,240
vertica concludes that the shared secret

837
00:27:56,240 --> 00:27:58,960
did not start with a leading zero byte

838
00:27:58,960 --> 00:28:00,799
to compute the original shared secret

839
00:28:00,799 --> 00:28:02,159
the attacker needs to perform the same

840
00:28:02,159 --> 00:28:04,080
measurement multiple times to find many

841
00:28:04,080 --> 00:28:04,720
values for

842
00:28:04,720 --> 00:28:07,200
r for which the resulting shared secret

843
00:28:07,200 --> 00:28:09,360
starts with the leading zero byte

844
00:28:09,360 --> 00:28:11,200
once the attacker has collected enough r

845
00:28:11,200 --> 00:28:13,520
values verteca can construct an equation

846
00:28:13,520 --> 00:28:15,520
system which can be interpreted as an

847
00:28:15,520 --> 00:28:17,039
instance of a hidden number problem

848
00:28:17,039 --> 00:28:18,880
where g to the power of a b is the

849
00:28:18,880 --> 00:28:20,880
hidden number and g to the power of rb

850
00:28:20,880 --> 00:28:22,559
is a patrick factor

851
00:28:22,559 --> 00:28:24,880
verteca can then surface equation system

852
00:28:24,880 --> 00:28:26,880
with an hmp solver to retrieve a shared

853
00:28:26,880 --> 00:28:28,960
secret g to the power of a b

854
00:28:28,960 --> 00:28:30,559
with this shared secret verteca can

855
00:28:30,559 --> 00:28:32,159
compute with the metro keys and break

856
00:28:32,159 --> 00:28:34,399
the tis connection

857
00:28:34,399 --> 00:28:36,080
due to time constraints i will not go

858
00:28:36,080 --> 00:28:37,600
into the details of a performance of

859
00:28:37,600 --> 00:28:38,240
attack

860
00:28:38,240 --> 00:28:40,000
but let me say this the runtime of

861
00:28:40,000 --> 00:28:41,760
attack varies depending on the length of

862
00:28:41,760 --> 00:28:43,440
a diffie-hellman keys and the number of

863
00:28:43,440 --> 00:28:45,200
leading zero bytes for tekken needs to

864
00:28:45,200 --> 00:28:47,039
collect the number of handshake the

865
00:28:47,039 --> 00:28:48,720
attacker has to perform also varies

866
00:28:48,720 --> 00:28:50,799
heavily depending on the size inequality

867
00:28:50,799 --> 00:28:52,960
the pro the proximity of attacker to the

868
00:28:52,960 --> 00:28:53,840
target server

869
00:28:53,840 --> 00:28:55,279
and the number of leading zero bites for

870
00:28:55,279 --> 00:28:57,440
tekken needs to solve a number problem

871
00:28:57,440 --> 00:28:59,279
generally speaking the attacker needs to

872
00:28:59,279 --> 00:29:01,440
collect roughly 200 equations which may

873
00:29:01,440 --> 00:29:03,039
require millions of connections to the

874
00:29:03,039 --> 00:29:03,919
server

875
00:29:03,919 --> 00:29:06,159
for our parameters the hmp server then

876
00:29:06,159 --> 00:29:07,600
requires up to three hours to find a

877
00:29:07,600 --> 00:29:08,240
solution to

878
00:29:08,240 --> 00:29:10,880
the number problem to estimate the

879
00:29:10,880 --> 00:29:12,399
impact of a vulnerability

880
00:29:12,399 --> 00:29:14,240
we analyzed the alexa top 100 thousand

881
00:29:14,240 --> 00:29:15,919
servers on the internet for their dhe

882
00:29:15,919 --> 00:29:17,520
support and whether we reused their

883
00:29:17,520 --> 00:29:19,120
ephemeral keys or not

884
00:29:19,120 --> 00:29:20,640
we found that roughly one third of a

885
00:29:20,640 --> 00:29:22,720
server supported at least one dhe cipher

886
00:29:22,720 --> 00:29:24,000
suit and that 11

887
00:29:24,000 --> 00:29:25,919
of those servers were reusing verify

888
00:29:25,919 --> 00:29:27,120
hammer keys

889
00:29:27,120 --> 00:29:28,720
but to exploit for vulnerability is

890
00:29:28,720 --> 00:29:30,480
generally not enough for server supports

891
00:29:30,480 --> 00:29:31,440
for cypher suit

892
00:29:31,440 --> 00:29:33,039
but connection you want to attack also

893
00:29:33,039 --> 00:29:35,039
has to naturally negotiate a winnable

894
00:29:35,039 --> 00:29:36,159
cypher suit

895
00:29:36,159 --> 00:29:38,480
firefox was the last browser to support

896
00:29:38,480 --> 00:29:40,880
to drop support for dhe cipher suits as

897
00:29:40,880 --> 00:29:43,919
and as of to 2021 no significant browser

898
00:29:43,919 --> 00:29:45,440
supports dhg anymore

899
00:29:45,440 --> 00:29:47,120
the attack is therefore mostly mitigated

900
00:29:47,120 --> 00:29:48,559
for browsers

901
00:29:48,559 --> 00:29:51,039
as of counter measures there are general

902
00:29:51,039 --> 00:29:52,320
lessons to be learned

903
00:29:52,320 --> 00:29:53,919
as the attack technique is not tls

904
00:29:53,919 --> 00:29:56,960
specific generally it is a good idea to

905
00:29:56,960 --> 00:29:58,559
avoid leaking partial information about

906
00:29:58,559 --> 00:29:59,679
secret values

907
00:29:59,679 --> 00:30:01,120
a good design approach to achieve this

908
00:30:01,120 --> 00:30:02,880
is to ensure that all secret values are

909
00:30:02,880 --> 00:30:04,799
of constant size within memory

910
00:30:04,799 --> 00:30:07,200
this avoids all kinds of shenanigans

911
00:30:07,200 --> 00:30:08,559
that can happen when variable length

912
00:30:08,559 --> 00:30:09,279
secrets are

913
00:30:09,279 --> 00:30:12,240
used within computations for tls clients

914
00:30:12,240 --> 00:30:14,080
should avoid using dhe cipher suits from

915
00:30:14,080 --> 00:30:16,000
now on as they cannot know if a server

916
00:30:16,000 --> 00:30:16,799
they are connecting

917
00:30:16,799 --> 00:30:19,679
to is reusing very familiar keys or not

918
00:30:19,679 --> 00:30:21,600
furthermore we recommend that servers do

919
00:30:21,600 --> 00:30:22,960
not reuse ephemera keys

920
00:30:22,960 --> 00:30:24,240
most implementations offer a

921
00:30:24,240 --> 00:30:26,880
configuration option for this purpose

922
00:30:26,880 --> 00:30:28,880
finally the already unused static

923
00:30:28,880 --> 00:30:30,960
different handshake should be

924
00:30:30,960 --> 00:30:32,880
should not be used anymore as reuse of

925
00:30:32,880 --> 00:30:34,559
the fehrman keys is a key part of the

926
00:30:34,559 --> 00:30:37,520
design of those surface suits

927
00:30:37,520 --> 00:30:39,120
a big question which often comes up in

928
00:30:39,120 --> 00:30:41,440
this context is if this also affects the

929
00:30:41,440 --> 00:30:43,360
elliptic curve if you have in handshakes

930
00:30:43,360 --> 00:30:45,600
and luckily this is not really the case

931
00:30:45,600 --> 00:30:47,360
as for the elliptic curve handshake tls

932
00:30:47,360 --> 00:30:49,200
preserves using zero bytes of a shared

933
00:30:49,200 --> 00:30:50,080
secret

934
00:30:50,080 --> 00:30:52,080
but this does not necessarily mean that

935
00:30:52,080 --> 00:30:53,679
no side channel for leading zero bytes

936
00:30:53,679 --> 00:30:55,120
is present as a lot of big number

937
00:30:55,120 --> 00:30:56,720
libraries do not maintain a fixed size

938
00:30:56,720 --> 00:30:58,000
during computation

939
00:30:58,000 --> 00:30:59,519
and leading zero bytes have to be added

940
00:30:59,519 --> 00:31:01,600
back in afterwards which can create a

941
00:31:01,600 --> 00:31:02,720
small sub

942
00:31:02,720 --> 00:31:05,039
timing side channel however this is not

943
00:31:05,039 --> 00:31:07,200
a problem in the specification anymore

944
00:31:07,200 --> 00:31:09,679
but an implementation specific one but

945
00:31:09,679 --> 00:31:11,440
even if this leading zero byte is

946
00:31:11,440 --> 00:31:13,840
a leaked uh in an elliptic curve if your

947
00:31:13,840 --> 00:31:14,880
hammer handshake

948
00:31:14,880 --> 00:31:16,320
it is an open question if this is

949
00:31:16,320 --> 00:31:18,320
actually exploitable as a resulting

950
00:31:18,320 --> 00:31:19,279
equation system

951
00:31:19,279 --> 00:31:21,200
as far as we know currently not so well

952
00:31:21,200 --> 00:31:24,399
solvable with the given parameters

953
00:31:24,399 --> 00:31:25,919
last but not least i would like to talk

954
00:31:25,919 --> 00:31:27,440
about how the raccoon attack interacts

955
00:31:27,440 --> 00:31:29,919
with the newest tls version ts1.3

956
00:31:29,919 --> 00:31:32,080
fortunately tls103 preserves leading

957
00:31:32,080 --> 00:31:34,080
zero bytes for ecdh as well as for

958
00:31:34,080 --> 00:31:35,039
finite

959
00:31:35,039 --> 00:31:36,960
field diffie-hellman therefore only

960
00:31:36,960 --> 00:31:38,640
implementation specific side chains may

961
00:31:38,640 --> 00:31:40,159
leak for leading zero bytes

962
00:31:40,159 --> 00:31:41,919
david benjamin introduced this change in

963
00:31:41,919 --> 00:31:43,840
draft 13 which prevented for protocol

964
00:31:43,840 --> 00:31:45,039
from breaking

965
00:31:45,039 --> 00:31:47,039
additionally ephemeral kiris is less

966
00:31:47,039 --> 00:31:49,279
prevalent in ts103 when it was in tls

967
00:31:49,279 --> 00:31:49,840
1.2

968
00:31:49,840 --> 00:31:52,720
and before however they exist variations

969
00:31:52,720 --> 00:31:54,000
of tiers 1.3

970
00:31:54,000 --> 00:31:56,000
which explicitly encourage kirius and

971
00:31:56,000 --> 00:31:57,279
therefore make their implementation

972
00:31:57,279 --> 00:31:58,840
potentially affected by the raccoon

973
00:31:58,840 --> 00:32:00,880
attack

974
00:32:00,880 --> 00:32:02,880
to conclude we found another flaw in the

975
00:32:02,880 --> 00:32:04,480
tls specification which has been

976
00:32:04,480 --> 00:32:06,159
unnoticed in the specification for over

977
00:32:06,159 --> 00:32:07,360
20 years

978
00:32:07,360 --> 00:32:09,039
since the flaws in this specification it

979
00:32:09,039 --> 00:32:10,000
is safe to assume that all

980
00:32:10,000 --> 00:32:12,000
implementation of tlsdhe which reuse

981
00:32:12,000 --> 00:32:14,559
ephemeral keys are affected

982
00:32:14,559 --> 00:32:16,000
but there's no need to panic although

983
00:32:16,000 --> 00:32:17,600
the recruit attack uses a cool another

984
00:32:17,600 --> 00:32:18,159
technique

985
00:32:18,159 --> 00:32:19,679
exploitation is very difficult and the

986
00:32:19,679 --> 00:32:21,600
circumstances for the attack are

987
00:32:21,600 --> 00:32:24,399
to succeed are not commonly met however

988
00:32:24,399 --> 00:32:26,159
the attack is not tls specific so we

989
00:32:26,159 --> 00:32:27,519
will probably see the same technique

990
00:32:27,519 --> 00:32:29,039
applied to other applications in the

991
00:32:29,039 --> 00:32:30,000
future

992
00:32:30,000 --> 00:32:32,000
furthermore the racuna's tech is as far

993
00:32:32,000 --> 00:32:33,760
as we know the first practical direct

994
00:32:33,760 --> 00:32:34,559
application

995
00:32:34,559 --> 00:32:36,159
of a hidden number problem as a crypto

996
00:32:36,159 --> 00:32:37,519
analytic tool against final field

997
00:32:37,519 --> 00:32:38,559
diffie-herman

998
00:32:38,559 --> 00:32:40,240
this is mostly because no sidechainer

999
00:32:40,240 --> 00:32:41,760
was known which allowed an attacker to

1000
00:32:41,760 --> 00:32:43,679
access to the leading bytes

1001
00:32:43,679 --> 00:32:44,720
if you want to learn more about

1002
00:32:44,720 --> 00:32:46,720
furikunatek you can find the paper as

1003
00:32:46,720 --> 00:32:48,120
well as a q a on our website

1004
00:32:48,120 --> 00:32:49,840
raccoonatech.com

1005
00:32:49,840 --> 00:32:51,360
if you want to find out if your own

1006
00:32:51,360 --> 00:32:53,760
servers are vulnerable to raccoon attack

1007
00:32:53,760 --> 00:32:55,600
you can use our tool tls scanner which

1008
00:32:55,600 --> 00:32:57,120
can also check for some implementation

1009
00:32:57,120 --> 00:32:58,640
specific bugs

1010
00:32:58,640 --> 00:33:00,799
which make the attack more exploitable

1011
00:33:00,799 --> 00:33:02,640
finally if you want to contact me you

1012
00:33:02,640 --> 00:33:04,480
can send me a dm on twitter or write me

1013
00:33:04,480 --> 00:33:06,559
an email and use this address

1014
00:33:06,559 --> 00:33:08,799
thanks for listening and with that i'm

1015
00:33:08,799 --> 00:33:10,880
ready to answer any questions

1016
00:33:10,880 --> 00:33:13,519
thank you robert so there are a few

1017
00:33:13,519 --> 00:33:14,960
questions posted in the channel

1018
00:33:14,960 --> 00:33:17,840
i'll walk through them for you jonathan

1019
00:33:17,840 --> 00:33:19,919
hoyland asks did anyone ever check

1020
00:33:19,919 --> 00:33:22,000
whether post handshake messages could be

1021
00:33:22,000 --> 00:33:25,840
reordered in dtls 1.3

1022
00:33:26,159 --> 00:33:31,279
for dtls103 i have no clue okay

1023
00:33:31,919 --> 00:33:33,919
i think there are no implementations of

1024
00:33:33,919 --> 00:33:35,440
details one or three yet

1025
00:33:35,440 --> 00:33:38,720
right kenny tyerson asks um

1026
00:33:38,720 --> 00:33:40,399
oh my gosh kenny federer said no it's a

1027
00:33:40,399 --> 00:33:41,600
collision terminology but there's a

1028
00:33:41,600 --> 00:33:42,399
question

1029
00:33:42,399 --> 00:33:44,080
what's the genesis of this security

1030
00:33:44,080 --> 00:33:45,919
issue

1031
00:33:45,919 --> 00:33:48,559
so um there's actually a interesting

1032
00:33:48,559 --> 00:33:49,279
story so

1033
00:33:49,279 --> 00:33:51,519
i was not aware when the specification

1034
00:33:51,519 --> 00:33:53,039
was written but

1035
00:33:53,039 --> 00:33:56,559
according to a buck in

1036
00:33:56,559 --> 00:34:00,559
mozilla wiki it says that

1037
00:34:00,559 --> 00:34:02,480
the servers actually wanted to implement

1038
00:34:02,480 --> 00:34:03,840
pkcs3

1039
00:34:03,840 --> 00:34:06,240
which is the standard on how to

1040
00:34:06,240 --> 00:34:08,480
implement the vm key exchange

1041
00:34:08,480 --> 00:34:11,599
and uh the ssl free specification said

1042
00:34:11,599 --> 00:34:13,760
implement a standard the vehement key

1043
00:34:13,760 --> 00:34:15,760
exchange and did not explicitly mention

1044
00:34:15,760 --> 00:34:16,960
if you should keep

1045
00:34:16,960 --> 00:34:19,839
are not all script leading zero bytes

1046
00:34:19,839 --> 00:34:20,719
but they

1047
00:34:20,719 --> 00:34:25,199
implicitly assumed that you should

1048
00:34:25,839 --> 00:34:27,520
keep the leading zero bytes because they

1049
00:34:27,520 --> 00:34:30,159
intended pkc is free

1050
00:34:30,159 --> 00:34:33,199
but apparently a different

1051
00:34:33,199 --> 00:34:36,000
ts implementers or implemented wave

1052
00:34:36,000 --> 00:34:37,679
added strips leading zero bytes

1053
00:34:37,679 --> 00:34:40,320
and then for tls 1.0 they changed the

1054
00:34:40,320 --> 00:34:42,159
specification to explicitly mention

1055
00:34:42,159 --> 00:34:44,079
that uh leading zero bytes should be

1056
00:34:44,079 --> 00:34:45,599
stripped so that

1057
00:34:45,599 --> 00:34:47,280
you can mostly copy paste the code from

1058
00:34:47,280 --> 00:34:50,800
ss3 to tls10

1059
00:34:50,800 --> 00:34:53,359
okay very good so another another

1060
00:34:53,359 --> 00:34:55,280
question from james muir a good one has

1061
00:34:55,280 --> 00:34:55,760
a cd

1062
00:34:55,760 --> 00:34:58,800
been published for this vulnerability

1063
00:34:58,800 --> 00:35:01,599
yeah i think there are multiple cve so

1064
00:35:01,599 --> 00:35:02,400
there's one for

1065
00:35:02,400 --> 00:35:05,359
from openmess and i think uh there's

1066
00:35:05,359 --> 00:35:07,520
also another one from f5 and

1067
00:35:07,520 --> 00:35:09,280
i think there's another one from mozilla

1068
00:35:09,280 --> 00:35:11,040
which is i'm not sure if it's published

1069
00:35:11,040 --> 00:35:11,839
yet but

1070
00:35:11,839 --> 00:35:13,760
uh you can find for details on both cvs

1071
00:35:13,760 --> 00:35:17,119
on our website raccoonatek.com

1072
00:35:17,119 --> 00:35:19,119
looks like nigel smart posted a question

1073
00:35:19,119 --> 00:35:21,040
over in the low topic channel as well

1074
00:35:21,040 --> 00:35:25,440
um thanks for watching this one

1075
00:35:25,440 --> 00:35:27,440
uh question is how many bytes need to be

1076
00:35:27,440 --> 00:35:28,640
stripped for you

1077
00:35:28,640 --> 00:35:30,880
for you to detect a slight channel is a

1078
00:35:30,880 --> 00:35:32,480
lot or just enough or what

1079
00:35:32,480 --> 00:35:35,520
this is just one yeah that's an

1080
00:35:35,520 --> 00:35:36,800
interesting question so

1081
00:35:36,800 --> 00:35:40,000
it depends on the modulus length so some

1082
00:35:40,000 --> 00:35:42,480
modular lengths are more exploitable

1083
00:35:42,480 --> 00:35:44,000
than others because they are closer

1084
00:35:44,000 --> 00:35:46,400
to the critical block borders within the

1085
00:35:46,400 --> 00:35:47,760
hash functions

1086
00:35:47,760 --> 00:35:50,800
and for those you can usually

1087
00:35:50,800 --> 00:35:53,760
detect it with one byte easily over the

1088
00:35:53,760 --> 00:35:54,320
network

1089
00:35:54,320 --> 00:35:57,280
but we were also able to detect a single

1090
00:35:57,280 --> 00:35:58,160
byte leak

1091
00:35:58,160 --> 00:36:01,520
in the network for 1024-bit

1092
00:36:01,520 --> 00:36:04,880
uh modulus but it's in our net in our

1093
00:36:04,880 --> 00:36:05,839
lab setting

1094
00:36:05,839 --> 00:36:07,760
essay would say so in a real-world

1095
00:36:07,760 --> 00:36:09,280
exploit it's

1096
00:36:09,280 --> 00:36:10,839
not easy to say if it's really

1097
00:36:10,839 --> 00:36:12,880
exploitable because there's a lot of

1098
00:36:12,880 --> 00:36:14,079
noise on the network

1099
00:36:14,079 --> 00:36:15,680
the server is doing other stuff where

1100
00:36:15,680 --> 00:36:17,599
you try to measure the side channel

1101
00:36:17,599 --> 00:36:20,640
so it's not really clear if it's

1102
00:36:20,640 --> 00:36:24,160
actually exploitable in the real world

1103
00:36:25,200 --> 00:36:27,040
thank you one other question came on the

1104
00:36:27,040 --> 00:36:28,960
channel actually a couple of things here

1105
00:36:28,960 --> 00:36:32,160
uh andrew cunningham asks uh if the dx

1106
00:36:32,160 --> 00:36:34,640
uh if the dh exponent private key is

1107
00:36:34,640 --> 00:36:36,240
blinded with a random number

1108
00:36:36,240 --> 00:36:39,119
does that close the attack uh especially

1109
00:36:39,119 --> 00:36:40,079
if that random number

1110
00:36:40,079 --> 00:36:43,440
is uh per invitation uh i don't think so

1111
00:36:43,440 --> 00:36:45,119
no

1112
00:36:45,119 --> 00:36:49,440
okay and andrew nielsen asks um

1113
00:36:49,440 --> 00:36:51,680
what did constantly remove this timing

1114
00:36:51,680 --> 00:36:53,359
leak

1115
00:36:53,359 --> 00:36:55,760
can you repeat sorry sorry the question

1116
00:36:55,760 --> 00:36:58,480
was uh would a constant time hash

1117
00:36:58,480 --> 00:37:02,800
remove this yeah so um

1118
00:37:02,800 --> 00:37:06,160
it's a little bit tricky so um generally

1119
00:37:06,160 --> 00:37:06,800
you do

1120
00:37:06,800 --> 00:37:09,119
you cannot make a hash function constant

1121
00:37:09,119 --> 00:37:10,960
time so you would need to know

1122
00:37:10,960 --> 00:37:13,760
how much uh bytes from how long the

1123
00:37:13,760 --> 00:37:15,119
modulus is and you wouldn't need to pass

1124
00:37:15,119 --> 00:37:17,440
that to a hash function interface

1125
00:37:17,440 --> 00:37:19,680
but also um it's a little bit tricky

1126
00:37:19,680 --> 00:37:20,560
because

1127
00:37:20,560 --> 00:37:23,359
inside the prf is the hash function is

1128
00:37:23,359 --> 00:37:24,000
used within

1129
00:37:24,000 --> 00:37:27,040
hmac and uh the

1130
00:37:27,040 --> 00:37:28,560
shared sql is actually the key for the

1131
00:37:28,560 --> 00:37:30,800
hmac function and the key has

1132
00:37:30,800 --> 00:37:34,240
for example for sha 384

1133
00:37:34,240 --> 00:37:37,119
it has to be hashed if it's bigger when

1134
00:37:37,119 --> 00:37:37,520
uh

1135
00:37:37,520 --> 00:37:41,359
when uh 1024 bits and it does not have

1136
00:37:41,359 --> 00:37:42,880
to be hashed when it's below

1137
00:37:42,880 --> 00:37:46,000
1024 bits so

1138
00:37:46,000 --> 00:37:49,200
here a constant time hash function would

1139
00:37:49,200 --> 00:37:51,200
not solve a problem entirely

1140
00:37:51,200 --> 00:37:54,800
but it's certain certainly possible to

1141
00:37:54,800 --> 00:37:57,520
write some code which can fix this issue

1142
00:37:57,520 --> 00:37:58,160
but

1143
00:37:58,160 --> 00:37:59,760
i do not think it's a good idea to

1144
00:37:59,760 --> 00:38:01,839
tackle this issue on an implementation

1145
00:38:01,839 --> 00:38:02,800
level

1146
00:38:02,800 --> 00:38:05,520
because dhe is not commonly used anymore

1147
00:38:05,520 --> 00:38:06,000
and it's

1148
00:38:06,000 --> 00:38:08,079
uh really hard to write this code in

1149
00:38:08,079 --> 00:38:09,040
constant time

1150
00:38:09,040 --> 00:38:11,440
so i would just just suggest to turn off

1151
00:38:11,440 --> 00:38:14,000
dhe and move to tls103 or

1152
00:38:14,000 --> 00:38:17,520
move to uh elliptic curve different

1153
00:38:17,520 --> 00:38:19,440
okay robert thank you very much for a

1154
00:38:19,440 --> 00:38:21,599
great talk appreciate it very much

1155
00:38:21,599 --> 00:38:24,000
um i think we're off then to the third

1156
00:38:24,000 --> 00:38:25,200
speaker

1157
00:38:25,200 --> 00:38:27,839
uh ah wait there is uh oh there's a

1158
00:38:27,839 --> 00:38:29,440
question for felix i won't try to bring

1159
00:38:29,440 --> 00:38:30,480
it up here

1160
00:38:30,480 --> 00:38:32,800
um so i'd like to introduce our third

1161
00:38:32,800 --> 00:38:34,640
speaker of julia is ready

1162
00:38:34,640 --> 00:38:36,320
uh julia lamb is going to introduce the

1163
00:38:36,320 --> 00:38:38,240
notion of partitioning oracles a new

1164
00:38:38,240 --> 00:38:40,720
class of

1165
00:38:42,160 --> 00:38:44,160
decryption error oracles and then we'll

1166
00:38:44,160 --> 00:38:45,920
discuss cca exploits using this

1167
00:38:45,920 --> 00:38:48,560
construction

1168
00:38:53,440 --> 00:38:55,920
okay can you hear me yes yes and see the

1169
00:38:55,920 --> 00:38:56,480
slides

1170
00:38:56,480 --> 00:38:59,839
yes okay great okay so today i'm going

1171
00:38:59,839 --> 00:39:01,440
to be talking about

1172
00:39:01,440 --> 00:39:03,359
partitioning oracle tax and this is

1173
00:39:03,359 --> 00:39:05,119
joint work with paul grubbs

1174
00:39:05,119 --> 00:39:08,160
and thomas jim part

1175
00:39:10,480 --> 00:39:13,040
so at a high level this talk will be

1176
00:39:13,040 --> 00:39:15,040
about why certain kinds of authenticated

1177
00:39:15,040 --> 00:39:16,400
encryption can be dangerous

1178
00:39:16,400 --> 00:39:18,880
and lead to vulnerabilities we'll start

1179
00:39:18,880 --> 00:39:20,640
by giving an overview of authenticated

1180
00:39:20,640 --> 00:39:22,800
encryption in general

1181
00:39:22,800 --> 00:39:25,520
here we have two parties in this case a

1182
00:39:25,520 --> 00:39:26,880
client and a server

1183
00:39:26,880 --> 00:39:29,599
and they share a key the client wants to

1184
00:39:29,599 --> 00:39:30,720
send

1185
00:39:30,720 --> 00:39:33,599
an encrypted message to the server so

1186
00:39:33,599 --> 00:39:35,440
the client chooses a nonce and encrypts

1187
00:39:35,440 --> 00:39:37,119
the plaintext message with the key to

1188
00:39:37,119 --> 00:39:40,160
produce ciphertext

1189
00:39:40,800 --> 00:39:43,440
then sends the cipher text to the server

1190
00:39:43,440 --> 00:39:45,200
who can then decrypt to recover the

1191
00:39:45,200 --> 00:39:47,119
plaintext message and of course we

1192
00:39:47,119 --> 00:39:48,960
expect that the

1193
00:39:48,960 --> 00:39:51,280
an attacker who gets the ciphertext

1194
00:39:51,280 --> 00:39:52,480
won't be able to

1195
00:39:52,480 --> 00:39:54,400
recover the underlying plaintext without

1196
00:39:54,400 --> 00:39:56,240
the key

1197
00:39:56,240 --> 00:39:58,400
and authenticate encryption also called

1198
00:39:58,400 --> 00:39:59,440
aad

1199
00:39:59,440 --> 00:40:02,160
has many popular schemes out there such

1200
00:40:02,160 --> 00:40:03,680
as aes gcm

1201
00:40:03,680 --> 00:40:06,480
x-alpha 20 poly 1305 and cha-cha 20 poly

1202
00:40:06,480 --> 00:40:07,599
1305

1203
00:40:07,599 --> 00:40:10,480
as well as aes gcm sib and they're

1204
00:40:10,480 --> 00:40:12,160
popular for many reasons

1205
00:40:12,160 --> 00:40:14,400
they're efficient they're standardized

1206
00:40:14,400 --> 00:40:16,960
and they have library implementations

1207
00:40:16,960 --> 00:40:18,720
they also guarantee many security

1208
00:40:18,720 --> 00:40:21,119
properties such as confidentiality and

1209
00:40:21,119 --> 00:40:22,160
integrity

1210
00:40:22,160 --> 00:40:25,200
as well as being proven cca secure

1211
00:40:25,200 --> 00:40:27,440
however all of these aad schemes listed

1212
00:40:27,440 --> 00:40:28,720
here

1213
00:40:28,720 --> 00:40:32,480
um don't target one security property

1214
00:40:32,480 --> 00:40:34,560
and that is robustness which is also

1215
00:40:34,560 --> 00:40:38,480
called committing aad

1216
00:40:38,480 --> 00:40:41,119
in a non-committing aad scheme if you

1217
00:40:41,119 --> 00:40:42,000
have two keys

1218
00:40:42,000 --> 00:40:43,760
you can produce a ciphertext that can

1219
00:40:43,760 --> 00:40:45,200
successfully decrypt

1220
00:40:45,200 --> 00:40:48,640
under both keys so here we have a client

1221
00:40:48,640 --> 00:40:51,440
who now knows two keys and might not

1222
00:40:51,440 --> 00:40:52,000
know which

1223
00:40:52,000 --> 00:40:54,160
key the server has which it will use to

1224
00:40:54,160 --> 00:40:55,760
decrypt

1225
00:40:55,760 --> 00:40:57,520
but the client can simply send the

1226
00:40:57,520 --> 00:41:00,160
ciphertext that decrypts under both keys

1227
00:41:00,160 --> 00:41:02,240
and now the server will be able to

1228
00:41:02,240 --> 00:41:04,720
successfully decrypt

1229
00:41:04,720 --> 00:41:06,800
notice that this means that in

1230
00:41:06,800 --> 00:41:08,480
non-committing aad

1231
00:41:08,480 --> 00:41:10,240
there's no guarantee the sender actually

1232
00:41:10,240 --> 00:41:12,160
knows the exact key the recipient will

1233
00:41:12,160 --> 00:41:13,839
use to decrypt

1234
00:41:13,839 --> 00:41:15,520
and for the most part this hasn't been

1235
00:41:15,520 --> 00:41:17,839
considered an essential security goal

1236
00:41:17,839 --> 00:41:20,319
except in settings like uh moderation

1237
00:41:20,319 --> 00:41:22,400
for encrypted messaging

1238
00:41:22,400 --> 00:41:24,160
but today we'll talk about why

1239
00:41:24,160 --> 00:41:26,800
non-committing aad can be dangerous

1240
00:41:26,800 --> 00:41:28,800
and that's because of something we call

1241
00:41:28,800 --> 00:41:31,440
partitioning oracle attack

1242
00:41:31,440 --> 00:41:33,200
in this setting we have a server when

1243
00:41:33,200 --> 00:41:35,359
with an associated password

1244
00:41:35,359 --> 00:41:37,680
and the server accepts encrypted queries

1245
00:41:37,680 --> 00:41:39,200
which it then decrypts using a

1246
00:41:39,200 --> 00:41:40,000
password-based

1247
00:41:40,000 --> 00:41:42,160
non-committing aad scheme something like

1248
00:41:42,160 --> 00:41:44,240
asgcm

1249
00:41:44,240 --> 00:41:45,760
the attacker wants to recover the

1250
00:41:45,760 --> 00:41:48,480
server's password and to help with this

1251
00:41:48,480 --> 00:41:50,160
the attacker has access to a password

1252
00:41:50,160 --> 00:41:52,000
dictionary which they could have gotten

1253
00:41:52,000 --> 00:41:54,079
from leaked password data

1254
00:41:54,079 --> 00:41:55,760
and the server's password is a member of

1255
00:41:55,760 --> 00:41:57,119
the password dictionary

1256
00:41:57,119 --> 00:41:58,319
although of course the attacker doesn't

1257
00:41:58,319 --> 00:42:00,480
know which one and the attacker could

1258
00:42:00,480 --> 00:42:02,240
make a single query for each password in

1259
00:42:02,240 --> 00:42:03,280
the dictionary

1260
00:42:03,280 --> 00:42:05,040
but this could be prohibitively large

1261
00:42:05,040 --> 00:42:06,480
and inefficient

1262
00:42:06,480 --> 00:42:08,560
so instead the attacker can split the

1263
00:42:08,560 --> 00:42:11,520
password dictionary into two sets

1264
00:42:11,520 --> 00:42:12,880
and then the attacker can create a

1265
00:42:12,880 --> 00:42:14,720
ciphertext such that it can decrypt

1266
00:42:14,720 --> 00:42:17,040
successfully under all passwords in one

1267
00:42:17,040 --> 00:42:18,880
set but not in the other

1268
00:42:18,880 --> 00:42:21,119
we call this ciphertext a splitting

1269
00:42:21,119 --> 00:42:22,079
ciphertext

1270
00:42:22,079 --> 00:42:23,440
because it splits the password

1271
00:42:23,440 --> 00:42:25,119
dictionary into two sets

1272
00:42:25,119 --> 00:42:26,960
and we say that has an associated value

1273
00:42:26,960 --> 00:42:28,640
of k equal to 4

1274
00:42:28,640 --> 00:42:31,680
because it can decrypt under 4 keys

1275
00:42:31,680 --> 00:42:33,599
now the attacker queries the cipher text

1276
00:42:33,599 --> 00:42:35,359
to the server the server

1277
00:42:35,359 --> 00:42:38,720
fails to decrypt so sends back to the

1278
00:42:38,720 --> 00:42:40,319
attacker that there is a decryption

1279
00:42:40,319 --> 00:42:42,720
error now the attacker knows

1280
00:42:42,720 --> 00:42:44,400
that the server's password can't have

1281
00:42:44,400 --> 00:42:46,160
been in this first set

1282
00:42:46,160 --> 00:42:47,760
and therefore can completely eliminate

1283
00:42:47,760 --> 00:42:49,680
this first set of passwords

1284
00:42:49,680 --> 00:42:51,599
thereby reducing the password dictionary

1285
00:42:51,599 --> 00:42:54,079
by half

1286
00:42:54,079 --> 00:42:56,240
this means that with each query the

1287
00:42:56,240 --> 00:42:57,680
attacker can eliminate half of the

1288
00:42:57,680 --> 00:42:59,040
password dictionary

1289
00:42:59,040 --> 00:43:01,680
every time the attacker can continue

1290
00:43:01,680 --> 00:43:03,760
with this binary searchlike technique

1291
00:43:03,760 --> 00:43:06,640
until they recover the target password

1292
00:43:06,640 --> 00:43:07,359
this means

1293
00:43:07,359 --> 00:43:09,200
only big o of login the size of the

1294
00:43:09,200 --> 00:43:11,200
password dictionary number of queries

1295
00:43:11,200 --> 00:43:13,280
is needed to learn the password this is

1296
00:43:13,280 --> 00:43:15,280
an exponential speed up over a brute

1297
00:43:15,280 --> 00:43:17,440
force dictionary attack

1298
00:43:17,440 --> 00:43:19,359
of course password dictionaries can be

1299
00:43:19,359 --> 00:43:20,560
extremely large

1300
00:43:20,560 --> 00:43:22,000
and it might not be practical to make

1301
00:43:22,000 --> 00:43:24,319
such a query but if we consider a more

1302
00:43:24,319 --> 00:43:27,119
practical value such as k equal 5000

1303
00:43:27,119 --> 00:43:29,359
we see that for every query the attacker

1304
00:43:29,359 --> 00:43:31,839
can still eliminate 5000 passwords every

1305
00:43:31,839 --> 00:43:32,720
time

1306
00:43:32,720 --> 00:43:34,319
until the attacker reaches the correct

1307
00:43:34,319 --> 00:43:36,160
set of 5000 passwords

1308
00:43:36,160 --> 00:43:37,680
after which the attacker can proceed

1309
00:43:37,680 --> 00:43:39,599
with the binary searchlike technique

1310
00:43:39,599 --> 00:43:41,760
this still offers a good speed up over

1311
00:43:41,760 --> 00:43:44,160
brute force

1312
00:43:44,160 --> 00:43:46,240
partitioning oracle attacks rely on two

1313
00:43:46,240 --> 00:43:47,520
things one

1314
00:43:47,520 --> 00:43:49,040
building is splitting ciphertext that

1315
00:43:49,040 --> 00:43:51,119
can decrypt under k different keys

1316
00:43:51,119 --> 00:43:53,359
and two having access to partitioning

1317
00:43:53,359 --> 00:43:54,720
oracle

1318
00:43:54,720 --> 00:43:56,640
we'll start with this first point which

1319
00:43:56,640 --> 00:43:59,040
we call key multi-collision attacks

1320
00:43:59,040 --> 00:44:01,359
glr first showed an attack against aes

1321
00:44:01,359 --> 00:44:03,280
gcm for k equals 2

1322
00:44:03,280 --> 00:44:05,040
and we'll generalize this attack against

1323
00:44:05,040 --> 00:44:08,800
asgcm for any value k

1324
00:44:08,800 --> 00:44:11,599
aes gcm is really encrypt than mac for

1325
00:44:11,599 --> 00:44:13,200
encryption it uses counter mode

1326
00:44:13,200 --> 00:44:14,640
encryption of aes

1327
00:44:14,640 --> 00:44:17,359
and for the mac it uses a g it uses g

1328
00:44:17,359 --> 00:44:19,920
hash which is a polynomial mac

1329
00:44:19,920 --> 00:44:22,560
the attack algorithm itself will take k

1330
00:44:22,560 --> 00:44:23,680
different keys

1331
00:44:23,680 --> 00:44:25,040
and we'll output a ciphertext that

1332
00:44:25,040 --> 00:44:26,720
decrypts under all k keys

1333
00:44:26,720 --> 00:44:28,640
the length of the ciphertext will be k

1334
00:44:28,640 --> 00:44:30,880
16 byte blocks

1335
00:44:30,880 --> 00:44:32,800
and the tech algorithm will run in time

1336
00:44:32,800 --> 00:44:35,119
big o of k squared

1337
00:44:35,119 --> 00:44:37,760
what makes this attack algorithm work is

1338
00:44:37,760 --> 00:44:40,079
that g hash is a polynomial mac

1339
00:44:40,079 --> 00:44:42,000
this reduces finding the ciphertext to

1340
00:44:42,000 --> 00:44:44,800
solving a set of linear equations

1341
00:44:44,800 --> 00:44:47,599
we'll run through a small example now so

1342
00:44:47,599 --> 00:44:49,040
let's say we take in as input and

1343
00:44:49,040 --> 00:44:50,240
arbitrary nonce

1344
00:44:50,240 --> 00:44:53,680
an authentication tag and three keys

1345
00:44:53,680 --> 00:44:55,440
our goal is to compute a ciphertext that

1346
00:44:55,440 --> 00:44:57,359
decrypts under all three keys

1347
00:44:57,359 --> 00:44:59,760
we'll pre-compute values h sub i p sub i

1348
00:44:59,760 --> 00:45:00,400
and l

1349
00:45:00,400 --> 00:45:02,079
these are constants in our system of

1350
00:45:02,079 --> 00:45:04,319
equations and the ciphertext blocks will

1351
00:45:04,319 --> 00:45:05,359
be our variables

1352
00:45:05,359 --> 00:45:07,119
here you can see we've set up a system

1353
00:45:07,119 --> 00:45:09,440
of three equations

1354
00:45:09,440 --> 00:45:12,720
with three unknowns when we reduce

1355
00:45:12,720 --> 00:45:15,520
we get this system of equations you'll

1356
00:45:15,520 --> 00:45:17,040
see on the left-hand

1357
00:45:17,040 --> 00:45:19,040
coefficient matrix is a special kind of

1358
00:45:19,040 --> 00:45:21,599
matrix called a van der maan matrix

1359
00:45:21,599 --> 00:45:23,040
this means we can use polynomial

1360
00:45:23,040 --> 00:45:25,040
interpolation to solve which is much

1361
00:45:25,040 --> 00:45:26,880
more efficient

1362
00:45:26,880 --> 00:45:29,040
when we implemented this using sagemath

1363
00:45:29,040 --> 00:45:30,560
and magma

1364
00:45:30,560 --> 00:45:32,640
we perform timing experiments on a linux

1365
00:45:32,640 --> 00:45:34,480
desktop the results of what you can see

1366
00:45:34,480 --> 00:45:36,400
here in this table

1367
00:45:36,400 --> 00:45:38,560
we found that we could make a ciphertext

1368
00:45:38,560 --> 00:45:39,680
that decrypts under

1369
00:45:39,680 --> 00:45:42,400
greater than 4000 keys and less than 30

1370
00:45:42,400 --> 00:45:44,160
seconds

1371
00:45:44,160 --> 00:45:46,240
and there do exist faster algorithms out

1372
00:45:46,240 --> 00:45:48,000
there that do polynomial interpolation

1373
00:45:48,000 --> 00:45:50,000
and big o of k log squared k time

1374
00:45:50,000 --> 00:45:51,599
instead of big o of k square time

1375
00:45:51,599 --> 00:45:53,760
so we could create multi collisions much

1376
00:45:53,760 --> 00:45:56,800
faster than this too

1377
00:45:57,119 --> 00:46:00,160
we also found that x also 20 poly 1305

1378
00:46:00,160 --> 00:46:03,440
cha cha 20 poly 1305 and asgcm siv

1379
00:46:03,440 --> 00:46:04,960
were all also vulnerable to key

1380
00:46:04,960 --> 00:46:07,040
multi-collision attacks however these

1381
00:46:07,040 --> 00:46:07,599
attacks

1382
00:46:07,599 --> 00:46:09,440
are more complex and less scalable than

1383
00:46:09,440 --> 00:46:12,560
those for aes gcm

1384
00:46:12,560 --> 00:46:13,599
now that we've covered key

1385
00:46:13,599 --> 00:46:15,599
multi-collision attacks we'll move on

1386
00:46:15,599 --> 00:46:17,599
to talking about getting access to

1387
00:46:17,599 --> 00:46:18,640
partitioning oracle

1388
00:46:18,640 --> 00:46:20,240
in other words where do partitioning

1389
00:46:20,240 --> 00:46:23,118
oracles arise

1390
00:46:23,359 --> 00:46:25,760
we looked at two schemes in depth one

1391
00:46:25,760 --> 00:46:28,640
was shadowsox proxy servers for udp

1392
00:46:28,640 --> 00:46:30,560
here we showed a proof of concept attack

1393
00:46:30,560 --> 00:46:32,240
against the shadowstock server

1394
00:46:32,240 --> 00:46:33,839
where we successfully recovered its

1395
00:46:33,839 --> 00:46:35,599
password using a partitioning oracle

1396
00:46:35,599 --> 00:46:36,880
attack

1397
00:46:36,880 --> 00:46:38,880
the second was early implementations of

1398
00:46:38,880 --> 00:46:41,359
the opaque asymmetric peak protocol

1399
00:46:41,359 --> 00:46:42,800
we found that many of these early

1400
00:46:42,800 --> 00:46:44,560
implementations went against the

1401
00:46:44,560 --> 00:46:46,240
protocol specification to use a

1402
00:46:46,240 --> 00:46:48,319
non-committing aad scheme

1403
00:46:48,319 --> 00:46:49,839
mainly because of the ease of use of

1404
00:46:49,839 --> 00:46:51,359
non-committing aed schemes that i

1405
00:46:51,359 --> 00:46:52,960
mentioned earlier

1406
00:46:52,960 --> 00:46:54,560
this left these schemes vulnerable to

1407
00:46:54,560 --> 00:46:56,720
partitioning oracle attacks

1408
00:46:56,720 --> 00:46:57,760
and there are other possible

1409
00:46:57,760 --> 00:46:59,839
partitioning oracles out there such as

1410
00:46:59,839 --> 00:47:01,119
in hybrid encryption

1411
00:47:01,119 --> 00:47:02,480
for instance we found that the hybrid

1412
00:47:02,480 --> 00:47:04,240
public key encryption scheme could be

1413
00:47:04,240 --> 00:47:05,680
vulnerable which has now since been

1414
00:47:05,680 --> 00:47:06,319
updated

1415
00:47:06,319 --> 00:47:08,079
as well as our gate file encryption tool

1416
00:47:08,079 --> 00:47:10,000
which has also since been updated in

1417
00:47:10,000 --> 00:47:10,560
addition

1418
00:47:10,560 --> 00:47:12,400
some kerberos drafts which haven't been

1419
00:47:12,400 --> 00:47:14,800
adopted as well as javascript object

1420
00:47:14,800 --> 00:47:16,160
signing and encryption

1421
00:47:16,160 --> 00:47:18,880
and potentially anonymity systems for

1422
00:47:18,880 --> 00:47:20,240
instance an attacker could use

1423
00:47:20,240 --> 00:47:21,680
partitioning oracles to learn which

1424
00:47:21,680 --> 00:47:23,359
public key a recipient is using

1425
00:47:23,359 --> 00:47:25,440
from a set of public keys therefore

1426
00:47:25,440 --> 00:47:26,559
learning the identity

1427
00:47:26,559 --> 00:47:29,760
of the recipient to manage julia

1428
00:47:29,760 --> 00:47:33,920
okay so the question is what do we do

1429
00:47:33,920 --> 00:47:36,319
our paper is the latest in a growing

1430
00:47:36,319 --> 00:47:37,520
body of evidence

1431
00:47:37,520 --> 00:47:40,960
that non-committing aad can be dangerous

1432
00:47:40,960 --> 00:47:43,440
in fact after we published our results

1433
00:47:43,440 --> 00:47:44,880
there was another paper that

1434
00:47:44,880 --> 00:47:47,599
came to the same conclusion but when we

1435
00:47:47,599 --> 00:47:49,520
ask which committing aad scheme do we

1436
00:47:49,520 --> 00:47:49,920
use

1437
00:47:49,920 --> 00:47:52,480
there's no easy answer because currently

1438
00:47:52,480 --> 00:47:56,000
no committing aad scheme is standardized

1439
00:47:56,000 --> 00:47:58,160
ultimately the conclusion here is we

1440
00:47:58,160 --> 00:48:00,079
need a committing aad standard

1441
00:48:00,079 --> 00:48:01,839
and it should be the it should be the

1442
00:48:01,839 --> 00:48:07,200
default choice for aad

1443
00:48:07,200 --> 00:48:09,440
so to conclude we described partitioning

1444
00:48:09,440 --> 00:48:11,040
oracle attacks which exploit

1445
00:48:11,040 --> 00:48:14,079
non-committing aad to recover secrets

1446
00:48:14,079 --> 00:48:16,240
and we discussed how widely used aad

1447
00:48:16,240 --> 00:48:19,040
schemes are not committing

1448
00:48:19,040 --> 00:48:20,480
this means that partitioning oracle

1449
00:48:20,480 --> 00:48:22,720
attacks can be used to recover passwords

1450
00:48:22,720 --> 00:48:25,440
from real schemes and protocols out

1451
00:48:25,440 --> 00:48:26,319
there

1452
00:48:26,319 --> 00:48:28,319
and ultimately our recommendation is to

1453
00:48:28,319 --> 00:48:30,319
design and standardize committing aad

1454
00:48:30,319 --> 00:48:31,440
for deployment

1455
00:48:31,440 --> 00:48:33,119
if you'd like to read more details the

1456
00:48:33,119 --> 00:48:35,680
full paper is up on eprint

1457
00:48:35,680 --> 00:48:37,680
and i'd like to thank my co-authors as

1458
00:48:37,680 --> 00:48:40,160
well as all those named here

1459
00:48:40,160 --> 00:48:41,839
who provided helpful feedback on our

1460
00:48:41,839 --> 00:48:43,760
paper thank you for listening and i'll

1461
00:48:43,760 --> 00:48:46,000
now take questions

1462
00:48:46,000 --> 00:48:47,359
thank you julia there are a few

1463
00:48:47,359 --> 00:48:49,200
questions on the channel let me

1464
00:48:49,200 --> 00:48:52,800
relay those to you uh one is uh

1465
00:48:52,800 --> 00:48:54,480
kenny patterson asks does the magic

1466
00:48:54,480 --> 00:48:56,559
ciphertext need to need to be computed

1467
00:48:56,559 --> 00:48:58,319
in an online manner for the attacks you

1468
00:48:58,319 --> 00:49:00,079
have in mind

1469
00:49:00,079 --> 00:49:02,000
no they can be competed offline uh for

1470
00:49:02,000 --> 00:49:03,760
instance in our shadow socks

1471
00:49:03,760 --> 00:49:06,160
attack we complete we computed all of

1472
00:49:06,160 --> 00:49:07,839
the cipher text in advance and then

1473
00:49:07,839 --> 00:49:10,880
online we queried later

1474
00:49:10,880 --> 00:49:13,920
great uh question from james muir is

1475
00:49:13,920 --> 00:49:17,760
does aes ccm uh show vulnerability to

1476
00:49:17,760 --> 00:49:20,160
these same multi-key attacks

1477
00:49:20,160 --> 00:49:22,720
um we haven't looked at that um

1478
00:49:22,720 --> 00:49:24,079
[Music]

1479
00:49:24,079 --> 00:49:26,559
we haven't looked at aes ccm yet but we

1480
00:49:26,559 --> 00:49:28,839
could certainly look at that in the

1481
00:49:28,839 --> 00:49:30,240
future

1482
00:49:30,240 --> 00:49:31,920
those are the only questions i see

1483
00:49:31,920 --> 00:49:33,760
asking for audio relay on the chat

1484
00:49:33,760 --> 00:49:37,680
side and so i believe that uh

1485
00:49:37,680 --> 00:49:40,079
finishes this talk thank you very much

1486
00:49:40,079 --> 00:49:41,839
if there's a question from search for

1487
00:49:41,839 --> 00:49:43,119
any in the

1488
00:49:43,119 --> 00:49:45,359
in the zoom chat um so maybe this is a

1489
00:49:45,359 --> 00:49:46,960
point worth reminding everybody please

1490
00:49:46,960 --> 00:49:48,400
use the social app if you can for

1491
00:49:48,400 --> 00:49:50,000
posting your questions

1492
00:49:50,000 --> 00:49:51,599
uh but maybe we can take sergio's

1493
00:49:51,599 --> 00:49:53,839
question if we have time

1494
00:49:53,839 --> 00:49:56,078
sure

1495
00:49:57,520 --> 00:49:58,960
oh there's one more question here for

1496
00:49:58,960 --> 00:50:00,800
from uh sadie g for julia

1497
00:50:00,800 --> 00:50:02,240
have you considered reaching out to

1498
00:50:02,240 --> 00:50:03,920
standards bodies like nist about the

1499
00:50:03,920 --> 00:50:05,040
lack of uh

1500
00:50:05,040 --> 00:50:08,720
guidance on this problem um we've been

1501
00:50:08,720 --> 00:50:12,559
uh speaking with the cfrg about this and

1502
00:50:12,559 --> 00:50:14,880
we hope to communicate more with these

1503
00:50:14,880 --> 00:50:16,720
bodies about uh proceeding with

1504
00:50:16,720 --> 00:50:18,400
committing aad

1505
00:50:18,400 --> 00:50:21,040
okay and one more question are there any

1506
00:50:21,040 --> 00:50:21,839
common

1507
00:50:21,839 --> 00:50:25,040
adid schemes here today that appear to

1508
00:50:25,040 --> 00:50:27,119
be committing

1509
00:50:27,119 --> 00:50:29,839
uh one is for instance encrypt an hmac

1510
00:50:29,839 --> 00:50:31,839
we found that this didn't have a formal

1511
00:50:31,839 --> 00:50:32,720
standard

1512
00:50:32,720 --> 00:50:34,559
um there were some informal standards

1513
00:50:34,559 --> 00:50:37,440
out there this also doesn't have a nice

1514
00:50:37,440 --> 00:50:41,680
implementation such as aes gcm

1515
00:50:41,680 --> 00:50:45,200
um so certainly in many of these

1516
00:50:45,200 --> 00:50:46,400
libraries they lack

1517
00:50:46,400 --> 00:50:48,160
a committing aad scheme you could simply

1518
00:50:48,160 --> 00:50:50,319
call such as that nowadays you can call

1519
00:50:50,319 --> 00:50:55,280
for excels at 20 poly 1305 okay

1520
00:50:55,280 --> 00:50:57,680
cool uh let's see another question from

1521
00:50:57,680 --> 00:50:59,119
uh sophie

1522
00:50:59,119 --> 00:51:02,480
uh aes gcm sib needs uh just one bit to

1523
00:51:02,480 --> 00:51:03,760
be brute force for this

1524
00:51:03,760 --> 00:51:08,400
is that enough to prevent it

1525
00:51:08,400 --> 00:51:10,720
um

1526
00:51:12,240 --> 00:51:14,160
what or what do you mean by one b is one

1527
00:51:14,160 --> 00:51:15,280
bit to be brute forced

1528
00:51:15,280 --> 00:51:23,839
could you want to speak to them

1529
00:51:24,640 --> 00:51:26,559
uh well i guess i'll say that for asg

1530
00:51:26,559 --> 00:51:28,079
cmsiv um

1531
00:51:28,079 --> 00:51:32,559
it's uh it it does have uh this

1532
00:51:32,559 --> 00:51:34,480
uh one bit when you decrypt that it

1533
00:51:34,480 --> 00:51:36,319
checks um this

1534
00:51:36,319 --> 00:51:37,920
still enables the attack because you

1535
00:51:37,920 --> 00:51:40,400
could uh in an untargeted way split the

1536
00:51:40,400 --> 00:51:42,079
ciphertext based off of whether the

1537
00:51:42,079 --> 00:51:42,640
correct

1538
00:51:42,640 --> 00:51:45,200
bit is decrypted i'm not sure if that

1539
00:51:45,200 --> 00:51:46,400
addresses the question

1540
00:51:46,400 --> 00:51:49,440
anyways follow that one crossline um

1541
00:51:49,440 --> 00:51:51,200
one more question from marcus brinkman

1542
00:51:51,200 --> 00:51:53,200
um so a question about

1543
00:51:53,200 --> 00:51:55,040
why would we use an active partition of

1544
00:51:55,040 --> 00:51:56,480
partitioning attack if we can do a

1545
00:51:56,480 --> 00:51:58,000
passive exhaustive search

1546
00:51:58,000 --> 00:52:02,079
instead you could in some of these cases

1547
00:52:02,079 --> 00:52:04,079
uh you could do a passive attack but for

1548
00:52:04,079 --> 00:52:05,440
instance if you

1549
00:52:05,440 --> 00:52:07,839
aren't able to perform the passive

1550
00:52:07,839 --> 00:52:08,720
attack for instance

1551
00:52:08,720 --> 00:52:10,319
you need to listen on the network to

1552
00:52:10,319 --> 00:52:11,839
grab the cypher text

1553
00:52:11,839 --> 00:52:13,200
in some of these contexts it might be

1554
00:52:13,200 --> 00:52:15,440
easier to perform an active query such

1555
00:52:15,440 --> 00:52:17,839
as with shadow socks

1556
00:52:17,839 --> 00:52:19,440
in which case the partitioning oracle

1557
00:52:19,440 --> 00:52:22,000
attack would be better than this offline

1558
00:52:22,000 --> 00:52:24,319
attack

1559
00:52:24,400 --> 00:52:26,800
okay and one last last comment in our

1560
00:52:26,800 --> 00:52:28,079
question was that

1561
00:52:28,079 --> 00:52:29,680
it might be worth looking at the nist

1562
00:52:29,680 --> 00:52:31,760
lwc candidates

1563
00:52:31,760 --> 00:52:34,960
as options here okay that's great i'll

1564
00:52:34,960 --> 00:52:36,640
take a look at that

1565
00:52:36,640 --> 00:52:38,880
okay i think that's all we have on the

1566
00:52:38,880 --> 00:52:39,920
channel

1567
00:52:39,920 --> 00:52:42,559
um thank you again julia great to talk

1568
00:52:42,559 --> 00:52:44,800
thank you

1569
00:52:44,800 --> 00:52:46,640
let's move on to the last talk of our

1570
00:52:46,640 --> 00:52:48,079
final speaker in this session is tom

1571
00:52:48,079 --> 00:52:48,800
wiggers

1572
00:52:48,800 --> 00:52:51,760
and he's going to present ken tls which

1573
00:52:51,760 --> 00:52:52,720
is an alternative

1574
00:52:52,720 --> 00:52:54,960
to the tls 1.3 handshake that uses key

1575
00:52:54,960 --> 00:52:58,480
encapsulation mechanisms

1576
00:52:58,720 --> 00:53:00,240
instead of signatures for a server

1577
00:53:00,240 --> 00:53:02,000
authentication uh

1578
00:53:02,000 --> 00:53:05,359
tom uh we can see your slides yeah

1579
00:53:05,359 --> 00:53:07,280
i had to figure out where the mute

1580
00:53:07,280 --> 00:53:08,720
button went if you

1581
00:53:08,720 --> 00:53:13,200
start sharing your screen um

1582
00:53:13,200 --> 00:53:14,880
okay you can see my slide but where are

1583
00:53:14,880 --> 00:53:17,359
my slides on my laptop

1584
00:53:17,359 --> 00:53:21,040
there we go okay um it seems uh that we

1585
00:53:21,040 --> 00:53:22,720
are slightly ahead of schedule

1586
00:53:22,720 --> 00:53:25,440
so uh if you want to ask extra questions

1587
00:53:25,440 --> 00:53:27,599
you can do so on

1588
00:53:27,599 --> 00:53:30,480
uh my co-authors are also there uh so

1589
00:53:30,480 --> 00:53:30,960
they

1590
00:53:30,960 --> 00:53:34,079
can join in into this discussion uh and

1591
00:53:34,079 --> 00:53:35,760
with that i'd like to open this talk

1592
00:53:35,760 --> 00:53:36,079
about

1593
00:53:36,079 --> 00:53:38,000
the post quantum tls but we're going to

1594
00:53:38,000 --> 00:53:40,160
do tls without handshake signatures so

1595
00:53:40,160 --> 00:53:41,599
that's a bit of a weird thing for a lot

1596
00:53:41,599 --> 00:53:43,040
of people

1597
00:53:43,040 --> 00:53:47,040
and yeah we have had a few talks about

1598
00:53:47,040 --> 00:53:48,480
tls already

1599
00:53:48,480 --> 00:53:50,400
and you all know that it sort of looks

1600
00:53:50,400 --> 00:53:52,880
like this so you have a key exchange

1601
00:53:52,880 --> 00:53:56,559
with some g2xs and stuff like that

1602
00:53:56,559 --> 00:54:00,559
and then you send over a signature

1603
00:54:00,559 --> 00:54:03,839
that's been produced by

1604
00:54:03,839 --> 00:54:05,680
the secret key that corresponds to a

1605
00:54:05,680 --> 00:54:08,319
public key and a certificate

1606
00:54:08,319 --> 00:54:09,760
how do you make this post quantum

1607
00:54:09,760 --> 00:54:11,520
because obviously we want to protect

1608
00:54:11,520 --> 00:54:13,119
ourselves from the quantum monster

1609
00:54:13,119 --> 00:54:14,319
that's going to eat us all

1610
00:54:14,319 --> 00:54:16,240
in a few years if you don't do anything

1611
00:54:16,240 --> 00:54:17,599
about this well

1612
00:54:17,599 --> 00:54:19,680
you could just write quantum in front of

1613
00:54:19,680 --> 00:54:21,040
everything post quantum in front of

1614
00:54:21,040 --> 00:54:21,920
everything

1615
00:54:21,920 --> 00:54:23,839
so you could replace the key exchange by

1616
00:54:23,839 --> 00:54:26,880
a chem a key encapsulation mechanism

1617
00:54:26,880 --> 00:54:28,640
many of which are proposed in the nist

1618
00:54:28,640 --> 00:54:30,160
competition

1619
00:54:30,160 --> 00:54:31,520
and you could use a post quantum

1620
00:54:31,520 --> 00:54:33,280
signature scheme for

1621
00:54:33,280 --> 00:54:36,400
the signature in the handshake

1622
00:54:36,400 --> 00:54:40,559
this is all good right um it's also been

1623
00:54:40,559 --> 00:54:43,680
studied in the literature a few times um

1624
00:54:43,680 --> 00:54:46,240
but there are some problems with this

1625
00:54:46,240 --> 00:54:47,440
approach

1626
00:54:47,440 --> 00:54:50,880
so post-quantum signatures are

1627
00:54:50,880 --> 00:54:53,680
both quite a bit big often they are a

1628
00:54:53,680 --> 00:54:54,880
bit slower than

1629
00:54:54,880 --> 00:54:58,000
chems or they require

1630
00:54:58,000 --> 00:55:00,720
your a bit of extra code because

1631
00:55:00,720 --> 00:55:02,640
entities need to be bespoke for every

1632
00:55:02,640 --> 00:55:04,240
algorithm for example

1633
00:55:04,240 --> 00:55:08,000
stuff like that so there is some

1634
00:55:08,000 --> 00:55:10,960
uh some motivation to try to get rid of

1635
00:55:10,960 --> 00:55:12,400
them

1636
00:55:12,400 --> 00:55:14,799
so what we are proposing is to use chems

1637
00:55:14,799 --> 00:55:16,720
for authentication instead so what is a

1638
00:55:16,720 --> 00:55:18,160
chem for those that haven't seen it

1639
00:55:18,160 --> 00:55:20,559
before it's a primitive that

1640
00:55:20,559 --> 00:55:22,240
has a few functions so you have a key

1641
00:55:22,240 --> 00:55:24,880
gen and then an encapsulate operation

1642
00:55:24,880 --> 00:55:27,599
that gives you a cipher text and the

1643
00:55:27,599 --> 00:55:28,640
other party

1644
00:55:28,640 --> 00:55:30,559
uh with the secret key can use that

1645
00:55:30,559 --> 00:55:31,680
cipher text to

1646
00:55:31,680 --> 00:55:33,920
retrieve the same shared secret and you

1647
00:55:33,920 --> 00:55:35,280
could use that to create an

1648
00:55:35,280 --> 00:55:37,280
authentication protocol if you know

1649
00:55:37,280 --> 00:55:40,240
the other party's secret key and then

1650
00:55:40,240 --> 00:55:40,799
both

1651
00:55:40,799 --> 00:55:43,599
because you can both derive the same

1652
00:55:43,599 --> 00:55:44,640
shared secret

1653
00:55:44,640 --> 00:55:46,319
uh peter in this example knows that

1654
00:55:46,319 --> 00:55:48,720
douglas has access to that secret key

1655
00:55:48,720 --> 00:55:50,480
and you know that douglas is who he

1656
00:55:50,480 --> 00:55:52,160
claims to be

1657
00:55:52,160 --> 00:55:53,920
the problem with doing this in tls is

1658
00:55:53,920 --> 00:55:56,079
that the server

1659
00:55:56,079 --> 00:55:58,640
has a public key that the client doesn't

1660
00:55:58,640 --> 00:55:59,839
already know

1661
00:55:59,839 --> 00:56:01,839
so if you would just want to do this

1662
00:56:01,839 --> 00:56:03,920
negatively you need an extra round trip

1663
00:56:03,920 --> 00:56:06,640
and that was what the tls 1.3 proposal

1664
00:56:06,640 --> 00:56:07,520
was all about

1665
00:56:07,520 --> 00:56:11,040
fewer round trips but we can solve this

1666
00:56:11,040 --> 00:56:12,880
problem if we instead of an

1667
00:56:12,880 --> 00:56:14,880
explicitly authenticated key exchanges

1668
00:56:14,880 --> 00:56:16,960
implicitly authenticated key exchange

1669
00:56:16,960 --> 00:56:18,720
we can have the server encapsulate to

1670
00:56:18,720 --> 00:56:20,720
this the client encapsulate to the

1671
00:56:20,720 --> 00:56:23,040
server's long-term public key

1672
00:56:23,040 --> 00:56:25,040
but it does not need to wait until they

1673
00:56:25,040 --> 00:56:26,480
get the mac

1674
00:56:26,480 --> 00:56:28,240
to confirm before they start sending

1675
00:56:28,240 --> 00:56:29,920
data that's been done before in a bunch

1676
00:56:29,920 --> 00:56:31,040
of protocols

1677
00:56:31,040 --> 00:56:34,160
both in literature and in practice

1678
00:56:34,160 --> 00:56:36,000
so let's look at our proposal in some

1679
00:56:36,000 --> 00:56:37,200
detail

1680
00:56:37,200 --> 00:56:39,520
so we started out with an ephemeral key

1681
00:56:39,520 --> 00:56:40,799
exchange with a chem

1682
00:56:40,799 --> 00:56:44,160
a post quantum chem and the server sends

1683
00:56:44,160 --> 00:56:44,960
over

1684
00:56:44,960 --> 00:56:47,920
uh its certificate for privacy reasons

1685
00:56:47,920 --> 00:56:49,200
because it says what

1686
00:56:49,200 --> 00:56:53,119
the server is etc uh encrypted over

1687
00:56:53,119 --> 00:56:56,400
this uh ephemeral public key and then we

1688
00:56:56,400 --> 00:56:58,480
do the authentication by encapsulating

1689
00:56:58,480 --> 00:57:00,079
to that certificate public key

1690
00:57:00,079 --> 00:57:02,880
and then decapsulating uh on the server

1691
00:57:02,880 --> 00:57:03,520
side and

1692
00:57:03,520 --> 00:57:05,280
because then they can both derive that

1693
00:57:05,280 --> 00:57:06,799
same shared secret

1694
00:57:06,799 --> 00:57:08,400
we know that the server is who they

1695
00:57:08,400 --> 00:57:10,400
claim to be

1696
00:57:10,400 --> 00:57:13,280
and this allows the client still to send

1697
00:57:13,280 --> 00:57:13,839
data

1698
00:57:13,839 --> 00:57:15,119
before receiving the service key

1699
00:57:15,119 --> 00:57:17,359
confirmation because this client knows

1700
00:57:17,359 --> 00:57:17,680
that

1701
00:57:17,680 --> 00:57:20,160
only the real server can decrypt what

1702
00:57:20,160 --> 00:57:22,960
i'm sending to you

1703
00:57:22,960 --> 00:57:24,559
we need to pick some algorithms to do

1704
00:57:24,559 --> 00:57:26,000
this so we need chems

1705
00:57:26,000 --> 00:57:28,960
and they should be fast ideally and they

1706
00:57:28,960 --> 00:57:30,480
should also have small public keys and

1707
00:57:30,480 --> 00:57:32,240
ciphertext

1708
00:57:32,240 --> 00:57:34,000
root certificates are a bit interesting

1709
00:57:34,000 --> 00:57:35,520
because they are already present on the

1710
00:57:35,520 --> 00:57:36,880
client and we only care about the

1711
00:57:36,880 --> 00:57:38,559
signature size

1712
00:57:38,559 --> 00:57:41,200
the public key is already there and for

1713
00:57:41,200 --> 00:57:42,880
intermediate certificates we need

1714
00:57:42,880 --> 00:57:45,520
both the public key and signature to be

1715
00:57:45,520 --> 00:57:46,799
reasonable

1716
00:57:46,799 --> 00:57:49,920
because we need to send that over we did

1717
00:57:49,920 --> 00:57:50,720
measurements

1718
00:57:50,720 --> 00:57:53,760
this is on an emulated network and you

1719
00:57:53,760 --> 00:57:54,000
see

1720
00:57:54,000 --> 00:57:57,280
here that the

1721
00:57:57,280 --> 00:57:59,359
it's slightly hard to read i apologize

1722
00:57:59,359 --> 00:58:00,559
but the

1723
00:58:00,559 --> 00:58:03,280
uh this one uses the lithium for

1724
00:58:03,280 --> 00:58:05,040
authentication this one uses kyber

1725
00:58:05,040 --> 00:58:06,799
authentication and you can see that the

1726
00:58:06,799 --> 00:58:09,119
kyber variant is quite a bit smaller

1727
00:58:09,119 --> 00:58:12,720
than the lithium variant similarly with

1728
00:58:12,720 --> 00:58:14,880
this version that uses entro instead of

1729
00:58:14,880 --> 00:58:16,240
falcon

1730
00:58:16,240 --> 00:58:18,640
and they also save a bit of time this is

1731
00:58:18,640 --> 00:58:20,839
an interesting counter example because

1732
00:58:20,839 --> 00:58:25,200
psyc became is so slow that

1733
00:58:25,200 --> 00:58:27,920
if you swap out psych for a signature

1734
00:58:27,920 --> 00:58:28,400
scheme

1735
00:58:28,400 --> 00:58:30,240
you actually get faster but that's a

1736
00:58:30,240 --> 00:58:32,240
psych-specific problem in general we see

1737
00:58:32,240 --> 00:58:33,040
that we get a bit

1738
00:58:33,040 --> 00:58:36,480
faster size optimized variants uh

1739
00:58:36,480 --> 00:58:39,599
require a lot fewer communication and

1740
00:58:39,599 --> 00:58:40,960
something that was less visible in this

1741
00:58:40,960 --> 00:58:43,359
graph but is still true is that

1742
00:58:43,359 --> 00:58:44,640
because canons are a lot more

1743
00:58:44,640 --> 00:58:46,720
computationally efficient they we

1744
00:58:46,720 --> 00:58:49,359
use a lot fewer cpu cycles while not

1745
00:58:49,359 --> 00:58:50,000
needing extra

1746
00:58:50,000 --> 00:58:54,000
round trips but there was

1747
00:58:54,000 --> 00:58:56,880
measurements on a server with emulation

1748
00:58:56,880 --> 00:58:57,599
and

1749
00:58:57,599 --> 00:58:59,680
cloudflare contacted us can we help you

1750
00:58:59,680 --> 00:59:01,760
and we said well we might be able to

1751
00:59:01,760 --> 00:59:05,359
do something here we have started effort

1752
00:59:05,359 --> 00:59:06,319
with cloudflare

1753
00:59:06,319 --> 00:59:08,960
to start doing measurements in the real

1754
00:59:08,960 --> 00:59:09,599
world

1755
00:59:09,599 --> 00:59:12,480
for that effort we have a implementation

1756
00:59:12,480 --> 00:59:14,559
now of camtls

1757
00:59:14,559 --> 00:59:17,680
in the go standard library that lives at

1758
00:59:17,680 --> 00:59:20,799
cloudflare's fork of uh

1759
00:59:20,799 --> 00:59:24,559
of the go uh stuff

1760
00:59:24,559 --> 00:59:25,839
uh this is based on dedicated

1761
00:59:25,839 --> 00:59:28,720
credentials because we couldn't find a

1762
00:59:28,720 --> 00:59:30,480
certificate authority that was crazy

1763
00:59:30,480 --> 00:59:32,000
enough to give us a camp public key

1764
00:59:32,000 --> 00:59:34,480
and a certificate yet so instead we are

1765
00:59:34,480 --> 00:59:35,280
using this

1766
00:59:35,280 --> 00:59:38,480
uh draft that proposes to allow you to

1767
00:59:38,480 --> 00:59:39,599
delegate

1768
00:59:39,599 --> 00:59:43,200
from normal tls certificates and then we

1769
00:59:43,200 --> 00:59:45,040
can put whatever papa key in there what

1770
00:59:45,040 --> 00:59:46,000
we want

1771
00:59:46,000 --> 00:59:47,520
and we've also implemented client

1772
00:59:47,520 --> 00:59:49,520
authentication and we

1773
00:59:49,520 --> 00:59:52,640
intend to use this implementation to do

1774
00:59:52,640 --> 00:59:53,680
measurements on real

1775
00:59:53,680 --> 00:59:56,000
networks so for example between

1776
00:59:56,000 --> 00:59:57,119
cloudflare

1777
00:59:57,119 --> 01:00:00,000
data centers and we want to measure more

1778
01:00:00,000 --> 01:00:01,920
aspects than what we've shown before so

1779
01:00:01,920 --> 01:00:03,760
handshake time is fun but there's also

1780
01:00:03,760 --> 01:00:05,119
other things that are interesting for

1781
01:00:05,119 --> 01:00:07,200
example

1782
01:00:07,200 --> 01:00:09,040
how many connections can you run in

1783
01:00:09,040 --> 01:00:12,319
parallel if you have a server

1784
01:00:12,319 --> 01:00:15,760
that runs a popular website um

1785
01:00:15,760 --> 01:00:17,599
you want to be able to handle a lot of

1786
01:00:17,599 --> 01:00:19,680
connections at the same time

1787
01:00:19,680 --> 01:00:21,839
and it would be annoying if going post

1788
01:00:21,839 --> 01:00:23,280
quantum means you need to buy 10 more

1789
01:00:23,280 --> 01:00:24,720
servers

1790
01:00:24,720 --> 01:00:27,280
so we want to look at stuff like that

1791
01:00:27,280 --> 01:00:28,000
and we really

1792
01:00:28,000 --> 01:00:31,520
hope to be able to report more results

1793
01:00:31,520 --> 01:00:33,839
soon

1794
01:00:36,240 --> 01:00:39,680
this was uh this

1795
01:00:39,680 --> 01:00:42,079
talk we hope that this interests you to

1796
01:00:42,079 --> 01:00:44,960
go read our paper

1797
01:00:44,960 --> 01:00:47,920
we can tell us allows you to

1798
01:00:47,920 --> 01:00:49,680
authenticate via chems and we do this

1799
01:00:49,680 --> 01:00:51,440
implicitly while preserving

1800
01:00:51,440 --> 01:00:53,040
the ability of the client to do a

1801
01:00:53,040 --> 01:00:56,400
request after a single round trip

1802
01:00:56,400 --> 01:00:58,720
the paper was presented at ccs you can

1803
01:00:58,720 --> 01:01:00,480
find it here

1804
01:01:00,480 --> 01:01:02,319
and the full version with proofs and i

1805
01:01:02,319 --> 01:01:04,559
also put it in my username for zoom

1806
01:01:04,559 --> 01:01:08,480
is at iscr eprint at this location

1807
01:01:08,480 --> 01:01:10,960
and we're very happy to say that

1808
01:01:10,960 --> 01:01:12,640
cloudflare is helping us investigate how

1809
01:01:12,640 --> 01:01:14,880
chemtiles will work in the real world

1810
01:01:14,880 --> 01:01:17,920
and the experimental implementation

1811
01:01:17,920 --> 01:01:20,960
and uh i'm sure we are happy to also

1812
01:01:20,960 --> 01:01:22,480
receive feedback

1813
01:01:22,480 --> 01:01:25,200
uh lives in this branch at the

1814
01:01:25,200 --> 01:01:27,040
cloudflare fork of go

1815
01:01:27,040 --> 01:01:30,319
we hope to have results soon uh tm

1816
01:01:30,319 --> 01:01:32,720
um so keep an eye on the cloudflare

1817
01:01:32,720 --> 01:01:34,079
research blog

1818
01:01:34,079 --> 01:01:36,720
and with that i think that i can answer

1819
01:01:36,720 --> 01:01:39,520
hopefully a lot of questions

1820
01:01:39,520 --> 01:01:41,760
thank you tom um so we do have one

1821
01:01:41,760 --> 01:01:43,280
question on the on the zoo

1822
01:01:43,280 --> 01:01:46,480
side uh so far um so question is

1823
01:01:46,480 --> 01:01:48,319
uh from chelsea colombo who asks have

1824
01:01:48,319 --> 01:01:50,319
you thought about applications of these

1825
01:01:50,319 --> 01:01:51,280
results to other

1826
01:01:51,280 --> 01:01:53,119
protocols not just two-party key

1827
01:01:53,119 --> 01:01:55,520
exchange

1828
01:01:56,240 --> 01:01:59,280
in principle the idea of uh cantiless is

1829
01:01:59,280 --> 01:02:01,359
of course very simple

1830
01:02:01,359 --> 01:02:04,880
you prove possession of a

1831
01:02:04,880 --> 01:02:06,640
secret key that corresponds to a public

1832
01:02:06,640 --> 01:02:08,319
key that is known

1833
01:02:08,319 --> 01:02:11,839
um so yes this is applicable

1834
01:02:11,839 --> 01:02:14,079
the general idea at least is applicable

1835
01:02:14,079 --> 01:02:15,039
to a lot of

1836
01:02:15,039 --> 01:02:17,039
different protocols in fact you might

1837
01:02:17,039 --> 01:02:18,720
even

1838
01:02:18,720 --> 01:02:21,200
in most key exchange protocols that rely

1839
01:02:21,200 --> 01:02:22,559
on uh elliptic

1840
01:02:22,559 --> 01:02:24,720
if you haven't or normal diffie-hellman

1841
01:02:24,720 --> 01:02:26,319
but not a non-interactive

1842
01:02:26,319 --> 01:02:30,000
variant of it you could use similar

1843
01:02:30,000 --> 01:02:32,440
strategies to use chems for

1844
01:02:32,440 --> 01:02:33,770
authentication

1845
01:02:33,770 --> 01:02:36,720
[Music]

1846
01:02:36,720 --> 01:02:39,599
in general i haven't written anything

1847
01:02:39,599 --> 01:02:42,400
down on it but

1848
01:02:42,799 --> 01:02:45,119
yeah i think that there are a lot of

1849
01:02:45,119 --> 01:02:47,359
applications where you could

1850
01:02:47,359 --> 01:02:50,480
use chems instead of signatures

1851
01:02:50,480 --> 01:02:53,680
as long as both parties are online

1852
01:02:53,680 --> 01:02:56,559
it is possible and especially if you're

1853
01:02:56,559 --> 01:02:57,200
not

1854
01:02:57,200 --> 01:02:59,680
bound to doing a single round trip the

1855
01:02:59,680 --> 01:03:01,760
only problem is if you have an interac a

1856
01:03:01,760 --> 01:03:03,920
non-interactive key exchange

1857
01:03:03,920 --> 01:03:05,359
because then you need seaside and

1858
01:03:05,359 --> 01:03:08,720
seaside is complicated

1859
01:03:08,720 --> 01:03:11,839
okay thank you for that james muir asks

1860
01:03:11,839 --> 01:03:13,839
what post-quantum kdm scheme

1861
01:03:13,839 --> 01:03:16,079
seems to best fit your application in

1862
01:03:16,079 --> 01:03:17,680
tls

1863
01:03:17,680 --> 01:03:22,319
um so this is based on our

1864
01:03:22,319 --> 01:03:25,039
measurements on a server that had quite

1865
01:03:25,039 --> 01:03:26,079
a bit of data

1866
01:03:26,079 --> 01:03:29,119
a nice cpu

1867
01:03:29,119 --> 01:03:32,319
all that stuff so this is not a

1868
01:03:32,319 --> 01:03:34,160
full answer because this doesn't cover

1869
01:03:34,160 --> 01:03:37,119
any embedded stuff or whatever at all

1870
01:03:37,119 --> 01:03:40,480
but i would say that um

1871
01:03:40,480 --> 01:03:45,039
psych is too slow um and

1872
01:03:45,039 --> 01:03:48,640
that uh the most promising candidates

1873
01:03:48,640 --> 01:03:49,680
are probably

1874
01:03:49,680 --> 01:03:52,799
uh the lithium and falcon um because you

1875
01:03:52,799 --> 01:03:54,559
still need some post quantum

1876
01:03:54,559 --> 01:03:56,079
signature scheme for the certificate

1877
01:03:56,079 --> 01:03:58,240
chain uh for that part

1878
01:03:58,240 --> 01:04:02,079
and then most cams are fast enough

1879
01:04:02,079 --> 01:04:05,760
so falcon is nice on servers that

1880
01:04:05,760 --> 01:04:07,359
have hardware acceleration because you

1881
01:04:07,359 --> 01:04:09,839
kind of need that with falcon

1882
01:04:09,839 --> 01:04:13,280
to use as sorry and true is

1883
01:04:13,280 --> 01:04:16,319
fast kyber is fast they are equally fast

1884
01:04:16,319 --> 01:04:18,799
more or less the difference there is so

1885
01:04:18,799 --> 01:04:20,640
marginal that you can use either they

1886
01:04:20,640 --> 01:04:21,680
are

1887
01:04:21,680 --> 01:04:25,119
slightly different in size um

1888
01:04:25,119 --> 01:04:28,720
yeah the paper has an overview

1889
01:04:28,720 --> 01:04:30,880
of a bunch of algorithms that we

1890
01:04:30,880 --> 01:04:31,839
measured

1891
01:04:31,839 --> 01:04:33,119
more or less you can just go for the

1892
01:04:33,119 --> 01:04:35,599
smallest ones

1893
01:04:35,599 --> 01:04:37,520
and if you have optimized

1894
01:04:37,520 --> 01:04:39,440
implementations they

1895
01:04:39,440 --> 01:04:41,119
usually perform more or less the same

1896
01:04:41,119 --> 01:04:42,480
because you shouldn't forget that

1897
01:04:42,480 --> 01:04:44,480
if you have a network latency of a few

1898
01:04:44,480 --> 01:04:46,000
milliseconds

1899
01:04:46,000 --> 01:04:48,799
then differences in nanoseconds in terms

1900
01:04:48,799 --> 01:04:50,160
of the computation time for most of

1901
01:04:50,160 --> 01:04:51,359
these primitives are

1902
01:04:51,359 --> 01:04:55,680
fairly okay um

1903
01:04:55,680 --> 01:04:59,839
yeah the the so my

1904
01:04:59,839 --> 01:05:02,079
my advisor is peter schwab so i should

1905
01:05:02,079 --> 01:05:03,920
probably now say that kyber is the best

1906
01:05:03,920 --> 01:05:04,640
chem but

1907
01:05:04,640 --> 01:05:09,839
uh yeah

1908
01:05:15,440 --> 01:05:19,440
what about um sqla signs plus fiber

1909
01:05:19,440 --> 01:05:21,039
um how was that how long would that work

1910
01:05:21,039 --> 01:05:22,799
in this application

1911
01:05:22,799 --> 01:05:26,000
um so i this is the part where i admit

1912
01:05:26,000 --> 01:05:28,240
that i don't know what sqi sign

1913
01:05:28,240 --> 01:05:31,599
is so i'm should probably go look into

1914
01:05:31,599 --> 01:05:33,200
that

1915
01:05:33,200 --> 01:05:34,480
it might be good to follow that one up

1916
01:05:34,480 --> 01:05:36,880
false line then okay yeah

1917
01:05:36,880 --> 01:05:40,160
okay thank you but

1918
01:05:40,160 --> 01:05:44,319
yeah i am

1919
01:05:44,640 --> 01:05:46,740
not sure what that is so

1920
01:05:46,740 --> 01:05:48,079
[Music]

1921
01:05:48,079 --> 01:05:50,160
it would be nice if you have something

1922
01:05:50,160 --> 01:05:51,440
that you can sort of

1923
01:05:51,440 --> 01:05:54,240
add on to existing tls uh for a

1924
01:05:54,240 --> 01:05:55,839
practical point of view

1925
01:05:55,839 --> 01:05:59,359
um so we that's also why in our paper we

1926
01:05:59,359 --> 01:05:59,680
stay

1927
01:05:59,680 --> 01:06:03,599
close to the original tls 1.3 stuff

1928
01:06:03,599 --> 01:06:09,039
as much as possible but yeah

1929
01:06:10,799 --> 01:06:13,520
okay that's one of the questions here uh

1930
01:06:13,520 --> 01:06:15,359
from britta hale

1931
01:06:15,359 --> 01:06:17,920
looks like for tom your protocol uses a

1932
01:06:17,920 --> 01:06:19,280
server certificate

1933
01:06:19,280 --> 01:06:21,920
as well as the delegated kdm certificate

1934
01:06:21,920 --> 01:06:23,599
as part of post quantum security on the

1935
01:06:23,599 --> 01:06:25,680
certificate chains are you proposing

1936
01:06:25,680 --> 01:06:27,520
that the entire chain would use a post

1937
01:06:27,520 --> 01:06:28,960
quantum ktm

1938
01:06:28,960 --> 01:06:30,960
or would for example the server search

1939
01:06:30,960 --> 01:06:34,319
still be a post quantum signature

1940
01:06:34,319 --> 01:06:37,119
yeah so the um with delegated

1941
01:06:37,119 --> 01:06:38,160
credentials

1942
01:06:38,160 --> 01:06:40,240
uh that is mainly just to power our

1943
01:06:40,240 --> 01:06:42,319
experiment right now

1944
01:06:42,319 --> 01:06:45,440
because if you start sending over both a

1945
01:06:45,440 --> 01:06:48,799
cam public key and a

1946
01:06:48,799 --> 01:06:50,799
leaf certificate and an intermediate

1947
01:06:50,799 --> 01:06:53,280
certificate

1948
01:06:53,280 --> 01:06:55,920
then you still need both the leaf and

1949
01:06:55,920 --> 01:06:57,440
the

1950
01:06:57,440 --> 01:07:00,000
intermediate certificate to be signature

1951
01:07:00,000 --> 01:07:03,280
schemes because they need to certify the

1952
01:07:03,280 --> 01:07:05,680
delegate credential in the end so that's

1953
01:07:05,680 --> 01:07:07,839
not the most efficient option

1954
01:07:07,839 --> 01:07:08,590
but

1955
01:07:08,590 --> 01:07:11,359
[Music]

1956
01:07:11,359 --> 01:07:15,839
if you want to go forward with mtls

1957
01:07:15,839 --> 01:07:17,760
into the future then it would be

1958
01:07:17,760 --> 01:07:20,000
necessary to get

1959
01:07:20,000 --> 01:07:22,559
ca certified chem public keys in

1960
01:07:22,559 --> 01:07:23,680
certificates

1961
01:07:23,680 --> 01:07:25,440
which actually is a very interesting

1962
01:07:25,440 --> 01:07:27,200
problem because there's a lot of things

1963
01:07:27,200 --> 01:07:28,000
about the

1964
01:07:28,000 --> 01:07:31,520
way that the tls pki works that rely

1965
01:07:31,520 --> 01:07:35,359
on the certificate being able to

1966
01:07:35,359 --> 01:07:39,280
sign things so for example revocation

1967
01:07:39,280 --> 01:07:42,880
or even just the certificate request uh

1968
01:07:42,880 --> 01:07:45,839
package is also signed by the public key

1969
01:07:45,839 --> 01:07:46,400
so if you

1970
01:07:46,400 --> 01:07:49,200
use public keys that cannot sign things

1971
01:07:49,200 --> 01:07:50,319
uh you need to

1972
01:07:50,319 --> 01:07:52,640
solve a few problems there and that's

1973
01:07:52,640 --> 01:07:54,400
also something that i

1974
01:07:54,400 --> 01:07:56,960
haven't had time to really figure out

1975
01:07:56,960 --> 01:07:58,799
yet but it's definitely interesting

1976
01:07:58,799 --> 01:08:01,599
for future work

1977
01:08:01,920 --> 01:08:04,079
okay that's the last question post on

1978
01:08:04,079 --> 01:08:06,000
the channel thanks very much tom

1979
01:08:06,000 --> 01:08:08,880
um looks like at this point we are done

1980
01:08:08,880 --> 01:08:10,000
with uh

1981
01:08:10,000 --> 01:08:11,760
session one on secure channels i think

1982
01:08:11,760 --> 01:08:14,079
next up in about five minutes time

1983
01:08:14,079 --> 01:08:16,000
is election award ceremony and i think

1984
01:08:16,000 --> 01:08:18,719
uh dan bonnet is sharing that one

1985
01:08:18,719 --> 01:08:21,439
yeah with that we'll close out session

1986
01:08:21,439 --> 01:08:22,479
one of rwc

1987
01:08:22,479 --> 01:08:26,879
2021. thanks everyone

