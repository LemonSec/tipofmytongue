1
00:00:03,280 --> 00:00:04,720
and you're ready to go have a good

2
00:00:04,720 --> 00:00:06,720
session

3
00:00:06,720 --> 00:00:08,960
okay hello everybody and welcome to the

4
00:00:08,960 --> 00:00:10,320
crypto in the cloud session of real

5
00:00:10,320 --> 00:00:11,759
world cryptography

6
00:00:11,759 --> 00:00:14,960
we have three excellent talks that i'm

7
00:00:14,960 --> 00:00:16,079
happy to

8
00:00:16,079 --> 00:00:18,560
introduce the speakers for uh today

9
00:00:18,560 --> 00:00:20,640
first we have kenny patterson

10
00:00:20,640 --> 00:00:22,800
speaking about system-wide security for

11
00:00:22,800 --> 00:00:24,080
searchable symmetric

12
00:00:24,080 --> 00:00:27,599
encryption which um shortens to swiss

13
00:00:27,599 --> 00:00:29,039
i believe it's how it's pronounced so

14
00:00:29,039 --> 00:00:31,599
penny i'll let you take it away

15
00:00:31,599 --> 00:00:33,120
thank you nick hopefully you can see my

16
00:00:33,120 --> 00:00:36,399
slides and everybody can hear me

17
00:00:36,640 --> 00:00:39,120
all good

18
00:00:40,320 --> 00:00:42,239
yeah okay so this is a joint work with

19
00:00:42,239 --> 00:00:43,440
uh

20
00:00:43,440 --> 00:00:44,960
from university of bristol shikhar

21
00:00:44,960 --> 00:00:47,120
panchanavis who was with each other

22
00:00:47,120 --> 00:00:49,840
and now his visa research and bogdan

23
00:00:49,840 --> 00:00:51,520
verinsky from university of bristol and

24
00:00:51,520 --> 00:00:53,920
dfinity uh based in zurich

25
00:00:53,920 --> 00:00:55,840
and uh all this work was done while we

26
00:00:55,840 --> 00:00:57,280
were all in

27
00:00:57,280 --> 00:00:59,920
zurich last year and so that's why we

28
00:00:59,920 --> 00:01:01,280
came up with the

29
00:01:01,280 --> 00:01:03,520
outstanding acronym of swissa

30
00:01:03,520 --> 00:01:05,119
system-wide security for searchable

31
00:01:05,119 --> 00:01:07,280
symmetric encryption

32
00:01:07,280 --> 00:01:09,439
our work is on eprint and you can find

33
00:01:09,439 --> 00:01:11,760
the link there at the bottom of the page

34
00:01:11,760 --> 00:01:13,040
so let me begin by introducing

35
00:01:13,040 --> 00:01:14,720
searchable encryption here we have a

36
00:01:14,720 --> 00:01:16,159
client who wants to outsource the

37
00:01:16,159 --> 00:01:17,600
storage of some large collection of

38
00:01:17,600 --> 00:01:21,040
documents here we only have three d0d122

39
00:01:21,040 --> 00:01:24,320
to a server providing cloud services

40
00:01:24,320 --> 00:01:26,159
and these documents have some keywords

41
00:01:26,159 --> 00:01:27,520
and the client wants to retain the

42
00:01:27,520 --> 00:01:28,960
capability to

43
00:01:28,960 --> 00:01:31,119
uh search over the documents for the

44
00:01:31,119 --> 00:01:32,960
keywords of course in practice we have

45
00:01:32,960 --> 00:01:34,320
much larger systems than this we might

46
00:01:34,320 --> 00:01:35,600
have hundreds of thousands or even

47
00:01:35,600 --> 00:01:37,040
millions of documents

48
00:01:37,040 --> 00:01:38,880
and hundreds of thousands or millions of

49
00:01:38,880 --> 00:01:40,479
keywords

50
00:01:40,479 --> 00:01:43,119
we want to outsource our storage and of

51
00:01:43,119 --> 00:01:44,560
course we may be in a situation where we

52
00:01:44,560 --> 00:01:44,880
don't

53
00:01:44,880 --> 00:01:46,479
want to trust the server to have access

54
00:01:46,479 --> 00:01:48,000
to all of our plaintext data

55
00:01:48,000 --> 00:01:51,119
and so we'd like to use encryption

56
00:01:51,119 --> 00:01:54,159
uh to to provide this capability but

57
00:01:54,159 --> 00:01:56,079
still providing the ability to perform

58
00:01:56,079 --> 00:01:57,759
searches over the data for

59
00:01:57,759 --> 00:02:00,479
keywords in the simplest kind of form we

60
00:02:00,479 --> 00:02:02,479
would have single keyword searches where

61
00:02:02,479 --> 00:02:04,000
the client can send some kind of

62
00:02:04,000 --> 00:02:05,360
encrypted version

63
00:02:05,360 --> 00:02:07,840
of a keyword alice in this case to the

64
00:02:07,840 --> 00:02:08,399
server

65
00:02:08,399 --> 00:02:09,679
the server would perform some

66
00:02:09,679 --> 00:02:11,760
computation over the encrypted data

67
00:02:11,760 --> 00:02:13,280
and send back the relevant list of

68
00:02:13,280 --> 00:02:15,280
documents here d0 d1

69
00:02:15,280 --> 00:02:17,599
because uh both documents d0 and d1

70
00:02:17,599 --> 00:02:19,360
contain the keyword alice and no other

71
00:02:19,360 --> 00:02:20,800
documents do

72
00:02:20,800 --> 00:02:22,640
more generally um you might imagine

73
00:02:22,640 --> 00:02:24,560
being able to do

74
00:02:24,560 --> 00:02:27,040
conjunctive or more complex keyword

75
00:02:27,040 --> 00:02:27,920
searches and

76
00:02:27,920 --> 00:02:29,840
ultimately be able to do some kind of

77
00:02:29,840 --> 00:02:31,920
form of sql queries over your encrypted

78
00:02:31,920 --> 00:02:34,238
data

79
00:02:35,040 --> 00:02:37,200
okay uh what does symmetric or

80
00:02:37,200 --> 00:02:39,120
searchable symmetric encryption mean

81
00:02:39,120 --> 00:02:41,440
sse it just means that in this in

82
00:02:41,440 --> 00:02:42,800
building this encrypted system

83
00:02:42,800 --> 00:02:44,239
we're only allowed to use symmetric

84
00:02:44,239 --> 00:02:46,720
techniques uh ostensibly for efficiency

85
00:02:46,720 --> 00:02:48,239
reasons okay so that introduces the

86
00:02:48,239 --> 00:02:51,360
concept of sse

87
00:02:51,360 --> 00:02:54,080
um let me start now um getting into the

88
00:02:54,080 --> 00:02:56,400
idea of system-wide security for sse

89
00:02:56,400 --> 00:02:58,959
by introducing a very simple searchable

90
00:02:58,959 --> 00:02:59,920
symmetric encryption

91
00:02:59,920 --> 00:03:02,640
scheme um that is sort of a toy example

92
00:03:02,640 --> 00:03:04,000
that we can use to understand why

93
00:03:04,000 --> 00:03:05,680
we need to consider system-wide security

94
00:03:05,680 --> 00:03:07,440
so we have our same set of documents as

95
00:03:07,440 --> 00:03:08,400
before

96
00:03:08,400 --> 00:03:10,720
and in this toy system we're going to

97
00:03:10,720 --> 00:03:13,360
use just a pseudo-random function fk

98
00:03:13,360 --> 00:03:15,840
and an ncpa secure symmetric encryption

99
00:03:15,840 --> 00:03:18,080
scheme which i'll denote by nkk of

100
00:03:18,080 --> 00:03:19,360
course here one should use different

101
00:03:19,360 --> 00:03:20,720
keys for the different functions and the

102
00:03:20,720 --> 00:03:21,680
different schemes

103
00:03:21,680 --> 00:03:23,360
but for simplicity of notation we just

104
00:03:23,360 --> 00:03:25,120
have a single key

105
00:03:25,120 --> 00:03:27,840
the scheme here is built by using two

106
00:03:27,840 --> 00:03:29,519
data structures at the server

107
00:03:29,519 --> 00:03:31,599
a search index which is just a key value

108
00:03:31,599 --> 00:03:33,440
store in which we

109
00:03:33,440 --> 00:03:36,319
represent the uh keywords by

110
00:03:36,319 --> 00:03:38,239
pseudorandom functions of those keywords

111
00:03:38,239 --> 00:03:39,760
that gives us our first column here so

112
00:03:39,760 --> 00:03:42,959
we have fk of alice fk bob and fk crypto

113
00:03:42,959 --> 00:03:44,319
and then the values corresponding to

114
00:03:44,319 --> 00:03:45,840
those keywords are just encrypted

115
00:03:45,840 --> 00:03:47,120
versions

116
00:03:47,120 --> 00:03:48,879
of the document identifiers which

117
00:03:48,879 --> 00:03:50,239
contain those keywords so this is like

118
00:03:50,239 --> 00:03:52,000
an inverted search index

119
00:03:52,000 --> 00:03:54,480
uh in the encrypted domain and an

120
00:03:54,480 --> 00:03:56,000
important point here for later is to see

121
00:03:56,000 --> 00:03:56,720
that these

122
00:03:56,720 --> 00:04:00,239
encrypted lists of documents are padded

123
00:04:00,239 --> 00:04:02,720
with uh hash values meaning just uh you

124
00:04:02,720 --> 00:04:04,480
know random nonsense

125
00:04:04,480 --> 00:04:06,799
uh to make sure that all of the entries

126
00:04:06,799 --> 00:04:09,680
in this table have the same length

127
00:04:09,680 --> 00:04:11,920
and this is to limit the possibility for

128
00:04:11,920 --> 00:04:12,959
things like

129
00:04:12,959 --> 00:04:16,639
frequency analysis attacks and similarly

130
00:04:16,639 --> 00:04:18,160
the second component of the system is a

131
00:04:18,160 --> 00:04:19,918
document array in which we just have the

132
00:04:19,918 --> 00:04:22,000
ncpa encrypted documents

133
00:04:22,000 --> 00:04:23,360
and now when a client wants to make a

134
00:04:23,360 --> 00:04:25,040
query to such a system

135
00:04:25,040 --> 00:04:26,960
uh suppose the client wants to find all

136
00:04:26,960 --> 00:04:28,720
the documents containing

137
00:04:28,720 --> 00:04:31,520
the keyboard alice then the client will

138
00:04:31,520 --> 00:04:32,400
create the

139
00:04:32,400 --> 00:04:35,600
search token fk of alice and send that

140
00:04:35,600 --> 00:04:37,520
to the server the server will do a

141
00:04:37,520 --> 00:04:39,199
lookup in his key value store and send

142
00:04:39,199 --> 00:04:40,639
back the encrypted list of all of the

143
00:04:40,639 --> 00:04:42,000
relevant documents

144
00:04:42,000 --> 00:04:44,080
and then in a second phase the client

145
00:04:44,080 --> 00:04:46,080
goes back to the now to the second data

146
00:04:46,080 --> 00:04:47,440
structure the document array

147
00:04:47,440 --> 00:04:49,199
and says please give me back the first

148
00:04:49,199 --> 00:04:51,040
and second documents these come back now

149
00:04:51,040 --> 00:04:52,479
again in encrypted form

150
00:04:52,479 --> 00:04:54,560
and finally the client can do perform

151
00:04:54,560 --> 00:04:55,840
client-side decryption

152
00:04:55,840 --> 00:04:57,280
under the key key to obtain the two

153
00:04:57,280 --> 00:04:59,759
documents d0 and d1 and now the

154
00:04:59,759 --> 00:05:02,639
the search is completed and now what we

155
00:05:02,639 --> 00:05:03,440
have to think about

156
00:05:03,440 --> 00:05:05,759
is the security of this kind of system

157
00:05:05,759 --> 00:05:06,720
and

158
00:05:06,720 --> 00:05:09,199
in most of the current literature the

159
00:05:09,199 --> 00:05:10,000
current security

160
00:05:10,000 --> 00:05:12,080
notions that we have only addressed the

161
00:05:12,080 --> 00:05:13,600
components of the system that are inside

162
00:05:13,600 --> 00:05:15,520
the red box here

163
00:05:15,520 --> 00:05:18,160
in particular they would uh try to

164
00:05:18,160 --> 00:05:19,280
protect

165
00:05:19,280 --> 00:05:22,800
leakage of sensitive data from

166
00:05:22,800 --> 00:05:25,520
the lookups to the search index in the

167
00:05:25,520 --> 00:05:26,720
top part here

168
00:05:26,720 --> 00:05:29,360
and also prevent an analysis of the the

169
00:05:29,360 --> 00:05:30,960
static document array just through

170
00:05:30,960 --> 00:05:32,800
normal and cpa encryption

171
00:05:32,800 --> 00:05:35,440
but importantly those existing security

172
00:05:35,440 --> 00:05:36,720
notions that are very common in

173
00:05:36,720 --> 00:05:38,400
literature do not address the second

174
00:05:38,400 --> 00:05:40,000
part of the system where we actually go

175
00:05:40,000 --> 00:05:42,639
and fetch the documents

176
00:05:42,639 --> 00:05:45,759
and um what we would really like to have

177
00:05:45,759 --> 00:05:47,520
is a stronger security notion that

178
00:05:47,520 --> 00:05:48,240
caters for

179
00:05:48,240 --> 00:05:50,240
the entire system so a system-wide

180
00:05:50,240 --> 00:05:51,280
security notion

181
00:05:51,280 --> 00:05:52,800
so we'd like to have security notions

182
00:05:52,800 --> 00:05:54,240
that consider the leakage from the

183
00:05:54,240 --> 00:05:55,520
entire system

184
00:05:55,520 --> 00:05:58,880
uh here uh surrounding both phases uh

185
00:05:58,880 --> 00:06:00,639
both online phases of the

186
00:06:00,639 --> 00:06:02,880
system and actually this example really

187
00:06:02,880 --> 00:06:03,919
clearly illustrates why

188
00:06:03,919 --> 00:06:06,319
we want to do this so this system is

189
00:06:06,319 --> 00:06:08,080
designed so that we have the padding

190
00:06:08,080 --> 00:06:09,919
on the encrypted responses the encrypted

191
00:06:09,919 --> 00:06:11,600
lists of document identifiers

192
00:06:11,600 --> 00:06:12,880
and so it looks like from the

193
00:06:12,880 --> 00:06:14,960
perspective of the red box that all of

194
00:06:14,960 --> 00:06:16,639
the frequency analysis attacks that are

195
00:06:16,639 --> 00:06:18,400
quite obvious here are prevented

196
00:06:18,400 --> 00:06:19,919
because we have the padding so all of

197
00:06:19,919 --> 00:06:21,840
the responses have the same length

198
00:06:21,840 --> 00:06:23,280
but when you look at the system from the

199
00:06:23,280 --> 00:06:25,520
system y perspective inside the green

200
00:06:25,520 --> 00:06:26,400
box

201
00:06:26,400 --> 00:06:28,479
we see that we actually make a number of

202
00:06:28,479 --> 00:06:30,400
queries to the document array we ask for

203
00:06:30,400 --> 00:06:32,000
the first and second documents

204
00:06:32,000 --> 00:06:33,600
that reveals the frequency of the

205
00:06:33,600 --> 00:06:35,120
keyword so when we look from a

206
00:06:35,120 --> 00:06:36,479
system-wide perspective there are

207
00:06:36,479 --> 00:06:37,120
actually very

208
00:06:37,120 --> 00:06:40,319
simple attacks against this toy and sse

209
00:06:40,319 --> 00:06:42,639
system but what i want to tell you is

210
00:06:42,639 --> 00:06:43,360
that in fact

211
00:06:43,360 --> 00:06:44,720
many many schemes in the literature

212
00:06:44,720 --> 00:06:46,319
including state-of-the-art schemes are

213
00:06:46,319 --> 00:06:47,520
vulnerable to attack

214
00:06:47,520 --> 00:06:49,120
when you look at them from a system-wide

215
00:06:49,120 --> 00:06:50,560
perspective

216
00:06:50,560 --> 00:06:53,039
and so we're in a situation currently

217
00:06:53,039 --> 00:06:54,240
where there is a very

218
00:06:54,240 --> 00:06:56,240
significant mismatch between the models

219
00:06:56,240 --> 00:06:57,840
and the schemes for sse

220
00:06:57,840 --> 00:06:58,800
that are being developed in the

221
00:06:58,800 --> 00:07:00,880
scientific community and the real world

222
00:07:00,880 --> 00:07:02,560
threats that such schemes should be

223
00:07:02,560 --> 00:07:03,840
addressing

224
00:07:03,840 --> 00:07:05,360
this is the first key takeaway i would

225
00:07:05,360 --> 00:07:08,960
like to give you for the talk

226
00:07:09,199 --> 00:07:10,319
so at this point i would like to

227
00:07:10,319 --> 00:07:12,479
introduce swissa

228
00:07:12,479 --> 00:07:14,720
and this is our attempt to try to close

229
00:07:14,720 --> 00:07:16,080
this gap between

230
00:07:16,080 --> 00:07:18,080
the current state of the art and what we

231
00:07:18,080 --> 00:07:19,360
should really be doing

232
00:07:19,360 --> 00:07:21,759
in this system-wide view of security for

233
00:07:21,759 --> 00:07:24,080
searchable symmetric encryption

234
00:07:24,080 --> 00:07:26,479
and so what we provide is a pair of

235
00:07:26,479 --> 00:07:28,479
schemes a static scheme a dynamic scheme

236
00:07:28,479 --> 00:07:29,680
the difference here is the dynamic

237
00:07:29,680 --> 00:07:31,360
scheme allows you to do

238
00:07:31,360 --> 00:07:33,280
insertion and deletion queries as well

239
00:07:33,280 --> 00:07:35,680
as searches over the encrypted data

240
00:07:35,680 --> 00:07:37,919
and swiss schemes are designed to

241
00:07:37,919 --> 00:07:39,759
minimize the system wide leakage and

242
00:07:39,759 --> 00:07:42,479
also achieve good performance

243
00:07:42,479 --> 00:07:44,639
we do this at the same time as providing

244
00:07:44,639 --> 00:07:46,639
broader stronger security definitions

245
00:07:46,639 --> 00:07:47,280
that model

246
00:07:47,280 --> 00:07:49,280
the system-wide security leakage the

247
00:07:49,280 --> 00:07:50,720
system-wide leakage

248
00:07:50,720 --> 00:07:52,400
and these are in the style of ideal

249
00:07:52,400 --> 00:07:54,080
world real-world security definitions

250
00:07:54,080 --> 00:07:56,160
which identify leakage functions

251
00:07:56,160 --> 00:07:57,919
in a similar style to what's already

252
00:07:57,919 --> 00:08:00,560
been done in the sse procedure

253
00:08:00,560 --> 00:08:02,560
we also provide security proofs for the

254
00:08:02,560 --> 00:08:03,919
swiss schemes

255
00:08:03,919 --> 00:08:05,840
and finally we do benchmarking for a

256
00:08:05,840 --> 00:08:07,680
realistic data set so we use the enron

257
00:08:07,680 --> 00:08:08,879
email corpus

258
00:08:08,879 --> 00:08:11,199
which has around 400 000 or 500 000

259
00:08:11,199 --> 00:08:13,520
documents

260
00:08:13,520 --> 00:08:14,960
some of the core techniques that we use

261
00:08:14,960 --> 00:08:17,599
in solicit involve again using key value

262
00:08:17,599 --> 00:08:19,919
stores again using two key value stores

263
00:08:19,919 --> 00:08:21,520
which means the client server

264
00:08:21,520 --> 00:08:24,400
interactions involve two round trips we

265
00:08:24,400 --> 00:08:26,240
use bucketization which is a padding

266
00:08:26,240 --> 00:08:27,039
technique

267
00:08:27,039 --> 00:08:28,879
to even out the frequencies of keywords

268
00:08:28,879 --> 00:08:30,479
and documents

269
00:08:30,479 --> 00:08:32,799
we also use here importantly inspired by

270
00:08:32,799 --> 00:08:34,159
oran techniques

271
00:08:34,159 --> 00:08:36,559
a client-side stash and pseudorandom

272
00:08:36,559 --> 00:08:37,839
writebacks

273
00:08:37,839 --> 00:08:39,360
what this means is that each search

274
00:08:39,360 --> 00:08:41,200
operation performed by a client

275
00:08:41,200 --> 00:08:43,599
results in deleting the index and the

276
00:08:43,599 --> 00:08:45,360
document data on the server

277
00:08:45,360 --> 00:08:46,800
once they have been returned to the

278
00:08:46,800 --> 00:08:49,760
client stashing freshly randomized

279
00:08:49,760 --> 00:08:50,959
encryptions

280
00:08:50,959 --> 00:08:53,920
of the the tokens and the the relevant

281
00:08:53,920 --> 00:08:55,680
data and the document the data documents

282
00:08:55,680 --> 00:08:57,760
themselves at the client

283
00:08:57,760 --> 00:08:59,200
and then performing pseudorandom

284
00:08:59,200 --> 00:09:01,200
writebacks of some of the data

285
00:09:01,200 --> 00:09:04,959
at each operation from the stash to the

286
00:09:04,959 --> 00:09:05,839
server

287
00:09:05,839 --> 00:09:08,160
what this does is it mixes data over

288
00:09:08,160 --> 00:09:09,839
time from different reads from the

289
00:09:09,839 --> 00:09:10,959
database

290
00:09:10,959 --> 00:09:12,480
from the encrypted database or the

291
00:09:12,480 --> 00:09:14,720
encrypted document store

292
00:09:14,720 --> 00:09:16,560
we also achieve oblivion oblivious

293
00:09:16,560 --> 00:09:18,160
operations for the dynamic case which

294
00:09:18,160 --> 00:09:19,519
means that you cannot

295
00:09:19,519 --> 00:09:22,080
tell apart the search operations and the

296
00:09:22,080 --> 00:09:24,480
addition and deletion operations

297
00:09:24,480 --> 00:09:26,399
and this actually very quickly enables

298
00:09:26,399 --> 00:09:27,760
us to prove things like forward and

299
00:09:27,760 --> 00:09:29,440
backward security which are standard

300
00:09:29,440 --> 00:09:30,959
security properties for symmetric

301
00:09:30,959 --> 00:09:33,839
searchable encryptions

302
00:09:35,279 --> 00:09:37,200
um there is a leakage profiles though

303
00:09:37,200 --> 00:09:39,040
from the swiss scheme in common with all

304
00:09:39,040 --> 00:09:42,320
uh practical sse schemes and uh so we

305
00:09:42,320 --> 00:09:44,080
reduce but we don't eliminate completely

306
00:09:44,080 --> 00:09:45,200
the leakage

307
00:09:45,200 --> 00:09:47,279
and to do this one would need worst case

308
00:09:47,279 --> 00:09:49,200
padding and full aura which leads to

309
00:09:49,200 --> 00:09:52,000
release significant overheads to

310
00:09:52,000 --> 00:09:52,880
completely remove

311
00:09:52,880 --> 00:09:55,680
all of the leakage the swiss scheme

312
00:09:55,680 --> 00:09:57,440
unfortunately does have a complex and

313
00:09:57,440 --> 00:09:59,200
stateful leakage profile

314
00:09:59,200 --> 00:10:00,880
so one might wonder what are the

315
00:10:00,880 --> 00:10:02,399
security implications of this how can

316
00:10:02,399 --> 00:10:04,160
one judge what security you actually

317
00:10:04,160 --> 00:10:04,959
achieve from

318
00:10:04,959 --> 00:10:07,200
a scheme like ours and the only way to

319
00:10:07,200 --> 00:10:08,560
find this out currently is to do

320
00:10:08,560 --> 00:10:10,000
cryptanalysis

321
00:10:10,000 --> 00:10:11,760
so we did that we did the best script

322
00:10:11,760 --> 00:10:13,519
analysis we could we tried to break our

323
00:10:13,519 --> 00:10:14,160
scheme

324
00:10:14,160 --> 00:10:16,079
we tried very hard and in doing that we

325
00:10:16,079 --> 00:10:17,440
actually improved the state of the art

326
00:10:17,440 --> 00:10:19,279
of attacks on sse

327
00:10:19,279 --> 00:10:21,360
and we plan to produce a separate paper

328
00:10:21,360 --> 00:10:23,040
that describes those attacks in detail

329
00:10:23,040 --> 00:10:24,320
and shows how to break

330
00:10:24,320 --> 00:10:26,480
a number of schemes in the literature

331
00:10:26,480 --> 00:10:27,839
which have

332
00:10:27,839 --> 00:10:30,079
which are vulnerable to our new attacks

333
00:10:30,079 --> 00:10:31,600
we were able to design our schemes

334
00:10:31,600 --> 00:10:33,360
that resist these attacks but i would

335
00:10:33,360 --> 00:10:35,440
say this is only friendly cryptanalysis

336
00:10:35,440 --> 00:10:36,880
and of course we would then encourage

337
00:10:36,880 --> 00:10:37,839
the community to

338
00:10:37,839 --> 00:10:39,279
take a look at what we're doing and see

339
00:10:39,279 --> 00:10:41,920
if it can be broken

340
00:10:41,920 --> 00:10:45,120
finally the swiss implementation

341
00:10:45,120 --> 00:10:46,480
uses standard cryptographic

342
00:10:46,480 --> 00:10:48,640
off-the-shelf components implemented in

343
00:10:48,640 --> 00:10:51,200
on the client side in java and jce

344
00:10:51,200 --> 00:10:52,880
on the server side we just use our redis

345
00:10:52,880 --> 00:10:54,880
server straight out of the box just a

346
00:10:54,880 --> 00:10:56,480
redis key value store and nothing else

347
00:10:56,480 --> 00:10:57,600
is needed

348
00:10:57,600 --> 00:11:00,800
and we did experiments in a local lan

349
00:11:00,800 --> 00:11:02,640
environment and just to give you a

350
00:11:02,640 --> 00:11:04,480
flavor of the kind of benchmarks that we

351
00:11:04,480 --> 00:11:05,040
have

352
00:11:05,040 --> 00:11:07,360
this graph is showing the query response

353
00:11:07,360 --> 00:11:09,040
time in milliseconds on the on the

354
00:11:09,040 --> 00:11:10,240
y-axis

355
00:11:10,240 --> 00:11:13,440
against the query response size for

356
00:11:13,440 --> 00:11:16,640
different sizes of document stores

357
00:11:16,640 --> 00:11:19,600
and so the the yellow or green line here

358
00:11:19,600 --> 00:11:20,560
on the bottom

359
00:11:20,560 --> 00:11:22,399
is just raw plain text that you would

360
00:11:22,399 --> 00:11:24,160
get from looking up a standard key value

361
00:11:24,160 --> 00:11:26,160
store doing document searches

362
00:11:26,160 --> 00:11:28,160
and so the gap between the green line

363
00:11:28,160 --> 00:11:29,760
and the other line shows the overhead of

364
00:11:29,760 --> 00:11:30,640
our approach

365
00:11:30,640 --> 00:11:32,800
we have a logarithmic scale here and the

366
00:11:32,800 --> 00:11:35,200
gap is something like a 6x overhead in

367
00:11:35,200 --> 00:11:36,399
query response time

368
00:11:36,399 --> 00:11:38,480
compared to doing things in plain text

369
00:11:38,480 --> 00:11:39,760
that corresponds to

370
00:11:39,760 --> 00:11:42,160
uh in a full orange solution the

371
00:11:42,160 --> 00:11:43,519
overhead might be something

372
00:11:43,519 --> 00:11:45,839
around a million or 10 million compared

373
00:11:45,839 --> 00:11:47,519
to a factor of six or seven here

374
00:11:47,519 --> 00:11:49,760
so we are making a huge improvement over

375
00:11:49,760 --> 00:11:51,920
oram at the cost of having imperfect

376
00:11:51,920 --> 00:11:52,720
security

377
00:11:52,720 --> 00:11:54,240
which has to be evaluated by

378
00:11:54,240 --> 00:11:57,360
cryptanalyzing leakage profile

379
00:11:57,360 --> 00:11:59,839
so to summarize um there's a mismatch

380
00:11:59,839 --> 00:12:01,839
between the scientific literature

381
00:12:01,839 --> 00:12:03,920
and the real world threats that are

382
00:12:03,920 --> 00:12:05,519
actually pertinent to

383
00:12:05,519 --> 00:12:08,800
symmetric surgical encryption um we

384
00:12:08,800 --> 00:12:11,200
introduce swissa a pair of schemes which

385
00:12:11,200 --> 00:12:12,959
aim to close that gap

386
00:12:12,959 --> 00:12:15,279
and you can find all the details in our

387
00:12:15,279 --> 00:12:17,440
e-print on istr and also our code is

388
00:12:17,440 --> 00:12:18,959
available on github if you want to take

389
00:12:18,959 --> 00:12:20,160
a look at it

390
00:12:20,160 --> 00:12:22,320
and we welcome cryptanalysis of our

391
00:12:22,320 --> 00:12:23,360
scheme

392
00:12:23,360 --> 00:12:25,200
so and at the end of the session uh

393
00:12:25,200 --> 00:12:27,600
please come say hi in the rwc social app

394
00:12:27,600 --> 00:12:29,360
we'll set up a room there

395
00:12:29,360 --> 00:12:31,440
a breakout room where we can very

396
00:12:31,440 --> 00:12:32,399
happily talk to you

397
00:12:32,399 --> 00:12:34,560
um as much as you like about the details

398
00:12:34,560 --> 00:12:35,600
of switzerland

399
00:12:35,600 --> 00:12:37,200
that's everything from me thank you very

400
00:12:37,200 --> 00:12:39,839
much for your attention

401
00:12:40,240 --> 00:12:43,040
great thanks kenny um there are no

402
00:12:43,040 --> 00:12:44,160
questions here

403
00:12:44,160 --> 00:12:47,680
so i have one quick question is can you

404
00:12:47,680 --> 00:12:49,519
help provide a little bit of um

405
00:12:49,519 --> 00:12:50,959
intuition about what an

406
00:12:50,959 --> 00:12:52,720
attack on this type of system would look

407
00:12:52,720 --> 00:12:54,160
like um what

408
00:12:54,160 --> 00:12:55,760
sort of access would attacker need to

409
00:12:55,760 --> 00:12:57,760
have what would the sequence of events

410
00:12:57,760 --> 00:12:58,160
look

411
00:12:58,160 --> 00:13:00,480
look like in a in a practical

412
00:13:00,480 --> 00:13:01,440
description

413
00:13:01,440 --> 00:13:03,920
okay in a general setting we i didn't

414
00:13:03,920 --> 00:13:05,440
say this explicitly but we consider the

415
00:13:05,440 --> 00:13:07,440
server to be adversarial so the server

416
00:13:07,440 --> 00:13:09,120
is interested in learning as much as it

417
00:13:09,120 --> 00:13:10,720
can from observing the queries

418
00:13:10,720 --> 00:13:13,760
that are made by looking at what um you

419
00:13:13,760 --> 00:13:15,440
know areas of memory or areas of hard

420
00:13:15,440 --> 00:13:16,959
disk it looks at which documents are

421
00:13:16,959 --> 00:13:18,880
returned and so on

422
00:13:18,880 --> 00:13:20,959
and so we're really here thinking about

423
00:13:20,959 --> 00:13:23,360
for the most part um an attacker who is

424
00:13:23,360 --> 00:13:25,519
really the server providing the service

425
00:13:25,519 --> 00:13:27,200
you can also consider a network attacker

426
00:13:27,200 --> 00:13:28,959
who might uh observes

427
00:13:28,959 --> 00:13:31,120
the the encrypted communications between

428
00:13:31,120 --> 00:13:32,240
the client and the server so you can

429
00:13:32,240 --> 00:13:33,600
assume everything is running over tls

430
00:13:33,600 --> 00:13:34,560
for example

431
00:13:34,560 --> 00:13:36,639
and such an attacker might be limited to

432
00:13:36,639 --> 00:13:37,760
seeing um

433
00:13:37,760 --> 00:13:40,800
the um

434
00:13:40,800 --> 00:13:43,680
being able to do uh analysis of volumes

435
00:13:43,680 --> 00:13:44,959
of data being exchanged or

436
00:13:44,959 --> 00:13:47,120
directionality of traffic so identifying

437
00:13:47,120 --> 00:13:48,480
you know when are queries being made

438
00:13:48,480 --> 00:13:49,760
whenever a response is being returned

439
00:13:49,760 --> 00:13:50,959
and so on

440
00:13:50,959 --> 00:13:53,120
does that is that the kind of answer you

441
00:13:53,120 --> 00:13:55,040
were looking for yeah absolutely there's

442
00:13:55,040 --> 00:13:56,079
um a few

443
00:13:56,079 --> 00:13:58,160
questions that have just popped up after

444
00:13:58,160 --> 00:14:00,240
that that answer so dennis jackson

445
00:14:00,240 --> 00:14:02,480
asks if data is deleted from the server

446
00:14:02,480 --> 00:14:04,560
mixed by the clients and written back

447
00:14:04,560 --> 00:14:06,399
does the client have to be trusted to

448
00:14:06,399 --> 00:14:08,160
write the write back the correct data

449
00:14:08,160 --> 00:14:08,639
i.e

450
00:14:08,639 --> 00:14:11,040
must every client write permissions to

451
00:14:11,040 --> 00:14:13,040
anything they can read

452
00:14:13,040 --> 00:14:14,959
yes and it's the client's data so that

453
00:14:14,959 --> 00:14:16,079
makes perfect sense

454
00:14:16,079 --> 00:14:17,839
the client has a strong incentivization

455
00:14:17,839 --> 00:14:19,680
to write back the data

456
00:14:19,680 --> 00:14:21,120
in a reasonable amount of time from the

457
00:14:21,120 --> 00:14:22,880
stash

458
00:14:22,880 --> 00:14:25,839
okay a question from syria ryan what

459
00:14:25,839 --> 00:14:27,519
client storage is necessary for this

460
00:14:27,519 --> 00:14:29,120
scheme can multiple clients with the

461
00:14:29,120 --> 00:14:30,160
same key access

462
00:14:30,160 --> 00:14:34,079
the same database do they share stash

463
00:14:34,079 --> 00:14:36,959
okay um so let me take the second part

464
00:14:36,959 --> 00:14:38,880
first no this is a single user

465
00:14:38,880 --> 00:14:40,959
scheme uh it's a great question to think

466
00:14:40,959 --> 00:14:42,399
about extending these techniques to

467
00:14:42,399 --> 00:14:44,240
multi-writer systems

468
00:14:44,240 --> 00:14:46,639
we haven't done that yet um interesting

469
00:14:46,639 --> 00:14:48,320
topic to explore

470
00:14:48,320 --> 00:14:51,040
on the first question there is a stash

471
00:14:51,040 --> 00:14:51,519
size

472
00:14:51,519 --> 00:14:53,920
and we have figures in the paper i don't

473
00:14:53,920 --> 00:14:55,199
have them off the top of my head but as

474
00:14:55,199 --> 00:14:56,399
far as i recall

475
00:14:56,399 --> 00:14:59,519
the stash stays small except when you

476
00:14:59,519 --> 00:15:01,279
when you make queries that involve many

477
00:15:01,279 --> 00:15:02,720
many documents being returned because

478
00:15:02,720 --> 00:15:04,160
then you have to stash them and then

479
00:15:04,160 --> 00:15:06,320
write them back over time

480
00:15:06,320 --> 00:15:08,399
and so in the paper we give kind of

481
00:15:08,399 --> 00:15:10,399
worst case estimates for the stash size

482
00:15:10,399 --> 00:15:11,519
and also

483
00:15:11,519 --> 00:15:12,800
the results of running practical

484
00:15:12,800 --> 00:15:15,040
experiments or standard tweeties

485
00:15:15,040 --> 00:15:16,560
so please see the paper for for full

486
00:15:16,560 --> 00:15:18,880
details on that okay we have a few

487
00:15:18,880 --> 00:15:20,160
more questions i'm going to cut off the

488
00:15:20,160 --> 00:15:22,320
line because we are already quite behind

489
00:15:22,320 --> 00:15:23,040
but um

490
00:15:23,040 --> 00:15:25,600
one from joaquin shipper he says what

491
00:15:25,600 --> 00:15:27,199
happens if a client crashes while

492
00:15:27,199 --> 00:15:28,959
processing writing back a query

493
00:15:28,959 --> 00:15:32,079
does the system stay available secure

494
00:15:32,079 --> 00:15:34,240
right so there's no impact on security

495
00:15:34,240 --> 00:15:35,759
if the client crashes but of course if

496
00:15:35,759 --> 00:15:37,920
the client crashes without having uh

497
00:15:37,920 --> 00:15:40,399
maybe written the stash to disk then

498
00:15:40,399 --> 00:15:41,759
it's going to lose that data

499
00:15:41,759 --> 00:15:43,279
so there is a there's definitely an

500
00:15:43,279 --> 00:15:45,120
issue there uh in

501
00:15:45,120 --> 00:15:46,880
deleting data on the server and not

502
00:15:46,880 --> 00:15:48,240
having it available on the client

503
00:15:48,240 --> 00:15:49,920
because of client-side failure

504
00:15:49,920 --> 00:15:52,959
one way to handle that is to

505
00:15:52,959 --> 00:15:54,639
not immediately delete data from the

506
00:15:54,639 --> 00:15:56,240
server and

507
00:15:56,240 --> 00:15:58,480
uh i think that has no effect on

508
00:15:58,480 --> 00:16:00,160
security except that the client would

509
00:16:00,160 --> 00:16:01,120
need to

510
00:16:01,120 --> 00:16:04,000
maintain a snapshot of its current

511
00:16:04,000 --> 00:16:05,600
operating state to know which documents

512
00:16:05,600 --> 00:16:07,759
to refetch in order to rewrite them

513
00:16:07,759 --> 00:16:10,800
so um i i would hope that standard

514
00:16:10,800 --> 00:16:12,320
transactional database techniques and

515
00:16:12,320 --> 00:16:13,759
key value store techniques would enable

516
00:16:13,759 --> 00:16:14,800
you to avoid

517
00:16:14,800 --> 00:16:17,199
the worst aspects of that kind of crash

518
00:16:17,199 --> 00:16:18,240
but clearly

519
00:16:18,240 --> 00:16:19,920
in practice you need to clearly you need

520
00:16:19,920 --> 00:16:22,079
to carefully architect your system to

521
00:16:22,079 --> 00:16:23,360
deal with that kind of issue

522
00:16:23,360 --> 00:16:25,360
thanks for the question okay last

523
00:16:25,360 --> 00:16:26,880
question alexandra

524
00:16:26,880 --> 00:16:30,240
anzala yamayako asks does your model

525
00:16:30,240 --> 00:16:32,399
provide insight as to how to deal with

526
00:16:32,399 --> 00:16:35,199
fancier query types i.e conjunctive

527
00:16:35,199 --> 00:16:36,160
conjunctive or

528
00:16:36,160 --> 00:16:39,199
range et cetera not

529
00:16:39,199 --> 00:16:42,639
yet and so uh i should uh perhaps

530
00:16:42,639 --> 00:16:44,560
emphasize this that the swiss as it's

531
00:16:44,560 --> 00:16:45,920
currently designed

532
00:16:45,920 --> 00:16:47,920
only caters for single keyword search

533
00:16:47,920 --> 00:16:48,959
queries which of course is a very

534
00:16:48,959 --> 00:16:52,160
limited class of queries in practice

535
00:16:52,160 --> 00:16:55,040
and again it's a really interesting and

536
00:16:55,040 --> 00:16:56,560
maybe quite tough open question to

537
00:16:56,560 --> 00:16:58,000
extend these kinds of techniques to

538
00:16:58,000 --> 00:16:59,759
handle more complex query classes that's

539
00:16:59,759 --> 00:17:03,120
certainly something we intend to do

540
00:17:03,199 --> 00:17:05,039
okay thank you so much kenny for the

541
00:17:05,039 --> 00:17:07,199
talk and

542
00:17:07,199 --> 00:17:10,400
we're off to the next one so um up next

543
00:17:10,400 --> 00:17:12,720
is sophie sophie schmidt who's going to

544
00:17:12,720 --> 00:17:13,599
be speaking about

545
00:17:13,599 --> 00:17:16,559
in-band key negotiation trusting the

546
00:17:16,559 --> 00:17:18,319
attacker

547
00:17:18,319 --> 00:17:21,520
which is really exciting sophie

548
00:17:21,520 --> 00:17:23,918
you're up

549
00:17:26,400 --> 00:17:30,000
okay um

550
00:17:31,440 --> 00:17:34,880
hello my name is i'm from google's

551
00:17:34,880 --> 00:17:37,760
icee crypto team and i'm here today to

552
00:17:37,760 --> 00:17:38,640
talk about

553
00:17:38,640 --> 00:17:41,280
keys and specifically negotiating key

554
00:17:41,280 --> 00:17:42,400
parameters

555
00:17:42,400 --> 00:17:45,919
uh what problems can arise there and how

556
00:17:45,919 --> 00:17:46,320
we

557
00:17:46,320 --> 00:17:48,799
solve these problems within a tank uh

558
00:17:48,799 --> 00:17:49,360
the

559
00:17:49,360 --> 00:17:52,080
open source crypto library that my team

560
00:17:52,080 --> 00:17:53,120
maintains for

561
00:17:53,120 --> 00:17:56,960
the use of google and industry

562
00:17:56,960 --> 00:18:00,400
um first off i will talk a bit about

563
00:18:00,400 --> 00:18:04,080
jwt uh generally he is

564
00:18:04,080 --> 00:18:07,120
somewhat famous for its difficulty to

565
00:18:07,120 --> 00:18:08,880
implement it

566
00:18:08,880 --> 00:18:12,320
is one of the common issues being

567
00:18:12,320 --> 00:18:15,280
access tokens uh that can be accepted

568
00:18:15,280 --> 00:18:17,600
without any problem of authenticity

569
00:18:17,600 --> 00:18:21,039
because you can change the algorithm as

570
00:18:21,039 --> 00:18:24,240
to none and this issue is so

571
00:18:24,240 --> 00:18:26,240
common that there is a website out there

572
00:18:26,240 --> 00:18:29,200
that counts

573
00:18:40,840 --> 00:18:43,840
um so how does this work normally with a

574
00:18:43,840 --> 00:18:47,039
charity uh you prove that you're

575
00:18:47,039 --> 00:18:48,480
authorized to access

576
00:18:48,480 --> 00:18:52,160
some resources by having some sensible

577
00:18:52,160 --> 00:18:55,360
choice and in case of a valid token

578
00:18:55,360 --> 00:18:57,919
you have an attached signature however

579
00:18:57,919 --> 00:18:59,760
the standard allows you to set this

580
00:18:59,760 --> 00:19:01,520
algorithm to none

581
00:19:01,520 --> 00:19:04,000
uh which then results in a token that is

582
00:19:04,000 --> 00:19:06,160
valid without any signature

583
00:19:06,160 --> 00:19:11,840
and you recommend any controls

584
00:19:20,799 --> 00:19:22,400
the fact that there is an algorithm

585
00:19:22,400 --> 00:19:24,080
field at all

586
00:19:24,080 --> 00:19:25,679
because you can also switch this

587
00:19:25,679 --> 00:19:29,039
algorithm field to

588
00:19:29,120 --> 00:19:32,160
some symmetric scheme at which point the

589
00:19:32,160 --> 00:19:34,240
implementation will just take the public

590
00:19:34,240 --> 00:19:37,280
key and interpret that as a secret key

591
00:19:37,280 --> 00:19:38,160
material

592
00:19:38,160 --> 00:19:41,120
in a lot of cases and that means that

593
00:19:41,120 --> 00:19:43,280
anyone can meet a valid token

594
00:19:43,280 --> 00:19:47,200
uh without a problem uh sophie

595
00:19:47,200 --> 00:19:49,520
sorry to interrupt but um there is some

596
00:19:49,520 --> 00:19:50,240
feedback

597
00:19:50,240 --> 00:19:51,919
happening um from your talk it's very

598
00:19:51,919 --> 00:19:53,440
echo-y i'm not sure if it's coming from

599
00:19:53,440 --> 00:19:54,160
you or from

600
00:19:54,160 --> 00:19:57,200
someone else um

601
00:19:57,200 --> 00:20:01,520
let me check set up to use the

602
00:20:01,520 --> 00:20:03,918
right

603
00:20:04,720 --> 00:20:09,679
does this work this is better

604
00:20:11,280 --> 00:20:12,960
there's still some echo it's a different

605
00:20:12,960 --> 00:20:15,679
kind of echo

606
00:20:18,840 --> 00:20:21,840
okay

607
00:20:24,000 --> 00:20:27,840
everyone else mute that often helps

608
00:20:27,840 --> 00:20:29,520
there's a couple of people who still got

609
00:20:29,520 --> 00:20:35,840
open mics

610
00:20:36,960 --> 00:20:41,760
okay now

611
00:20:42,240 --> 00:20:45,600
no it's still the same i think um

612
00:20:45,600 --> 00:20:48,720
if not worse we're seeing in the chat um

613
00:20:48,720 --> 00:20:51,840
you may be playing back the zoom audio

614
00:20:51,840 --> 00:20:53,919
uh on your own speakers so you may want

615
00:20:53,919 --> 00:20:55,280
to mute

616
00:20:55,280 --> 00:20:57,280
that um because i think we're getting

617
00:20:57,280 --> 00:20:59,360
like a double

618
00:20:59,360 --> 00:21:01,280
yeah i'm not using speakers and i'm

619
00:21:01,280 --> 00:21:02,799
going to

620
00:21:02,799 --> 00:21:05,919
make it so that it makes no sound i hope

621
00:21:05,919 --> 00:21:07,200
that it works

622
00:21:07,200 --> 00:21:08,530
better now

623
00:21:08,530 --> 00:21:11,120
[Music]

624
00:21:11,120 --> 00:21:14,640
uh unfortunately not

625
00:21:14,640 --> 00:21:17,919
um if if you have

626
00:21:17,919 --> 00:21:21,280
uh are you using the speaker um or the

627
00:21:21,280 --> 00:21:23,440
uh microphone connected to your

628
00:21:23,440 --> 00:21:25,360
headphones

629
00:21:25,360 --> 00:21:31,280
so i can't hear anyone anymore but um

630
00:21:31,280 --> 00:21:34,320
hang tight everybody sorry uh that's

631
00:21:34,320 --> 00:21:36,879
strange

632
00:21:42,799 --> 00:21:47,760
i'm going to try and reload uh zoom

633
00:21:51,840 --> 00:21:56,320
one more microphone to test is this

634
00:21:56,840 --> 00:21:59,840
is

635
00:22:06,000 --> 00:22:13,840
i'm so sorry about this

636
00:22:24,240 --> 00:22:26,480
well um we can understand you it's just

637
00:22:26,480 --> 00:22:28,080
a little bit different

638
00:22:28,080 --> 00:22:31,360
i just continue and i'm i'm very sorry i

639
00:22:31,360 --> 00:22:34,720
had no idea what was happening here

640
00:22:34,720 --> 00:22:37,600
before my computer this morning decided

641
00:22:37,600 --> 00:22:37,919
to

642
00:22:37,919 --> 00:22:41,120
knock me out everything

643
00:22:54,090 --> 00:22:57,159
[Music]

644
00:23:03,760 --> 00:23:05,679
my apologies that's my fault i'm so

645
00:23:05,679 --> 00:23:07,919
sorry

646
00:23:08,600 --> 00:23:11,709
[Music]

647
00:23:20,880 --> 00:23:23,840
um

648
00:23:35,120 --> 00:23:41,120
example because it is used in this

649
00:23:41,120 --> 00:23:44,000
specific way

650
00:23:48,840 --> 00:23:50,559
um

651
00:23:50,559 --> 00:23:55,520
this type of issue isn't um

652
00:23:55,520 --> 00:23:59,120
but that is unfortunately quite a common

653
00:23:59,120 --> 00:24:02,240
issue the basic weakness is

654
00:24:02,240 --> 00:24:05,360
attaching metadata information

655
00:24:05,360 --> 00:24:07,360
that you need to authenticate and

656
00:24:07,360 --> 00:24:11,678
decrypt to the ciphertext itself

657
00:24:16,840 --> 00:24:19,840
um

658
00:24:38,700 --> 00:24:41,759
[Music]

659
00:24:44,840 --> 00:24:47,840
um

660
00:24:58,880 --> 00:25:01,039
to

661
00:25:12,840 --> 00:25:15,840
um

662
00:25:19,120 --> 00:25:21,120
trying to reduce this kind of problem

663
00:25:21,120 --> 00:25:24,719
within google products

664
00:25:26,840 --> 00:25:29,840
um

665
00:26:36,799 --> 00:26:40,480
but all keys can be used to verify

666
00:26:40,480 --> 00:26:44,000
um these could be simply implementing

667
00:26:44,000 --> 00:26:44,559
ids

668
00:26:44,559 --> 00:26:47,520
or in this case they are just random but

669
00:26:47,520 --> 00:26:50,000
many individuals

670
00:26:50,000 --> 00:26:54,320
um so with all this information

671
00:26:54,320 --> 00:26:57,360
how does a psychiatric signature now

672
00:26:57,360 --> 00:26:59,120
look like how does the performance look

673
00:26:59,120 --> 00:27:01,279
like um

674
00:27:01,279 --> 00:27:06,559
the psychic text now has three parts

675
00:27:18,840 --> 00:27:21,840
uh so far we didn't have to do that

676
00:27:21,840 --> 00:27:23,840
and for our purposes we can always

677
00:27:23,840 --> 00:27:26,080
assume that that is just

678
00:27:26,080 --> 00:27:29,440
one and you can recognize that some

679
00:27:29,440 --> 00:27:35,840
google products because it has

680
00:27:46,840 --> 00:27:49,840
is

681
00:28:28,840 --> 00:28:31,840
is

682
00:28:42,840 --> 00:28:45,840
um

683
00:29:11,120 --> 00:29:13,440
off um you should never trust the cyber

684
00:29:13,440 --> 00:29:14,720
text uh at least

685
00:29:14,720 --> 00:29:16,320
not until you know that it wasn't

686
00:29:16,320 --> 00:29:18,240
provided by the attacker

687
00:29:18,240 --> 00:29:23,520
um that that usually means uh

688
00:29:23,520 --> 00:29:27,840
at that point you're pretty much

689
00:29:38,840 --> 00:29:41,840
is

690
00:29:48,159 --> 00:29:50,559
um

691
00:29:53,679 --> 00:29:55,679
it doesn't have to be kept secretly like

692
00:29:55,679 --> 00:29:57,200
the key has

693
00:29:57,200 --> 00:30:00,880
but uh authenticating something is

694
00:30:00,880 --> 00:30:04,799
often quite hard so that you can just

695
00:30:04,799 --> 00:30:07,120
put it into the key itself and you know

696
00:30:07,120 --> 00:30:07,840
that uh

697
00:30:07,840 --> 00:30:11,360
everything is synthetic and it's uh

698
00:30:11,360 --> 00:30:13,200
interpreted in english

699
00:30:13,200 --> 00:30:16,399
um as a last take away

700
00:30:16,399 --> 00:30:18,880
uh pieces have to be used quite

701
00:30:18,880 --> 00:30:20,080
carefully

702
00:30:20,080 --> 00:30:22,960
uh they cannot be authenticated because

703
00:30:22,960 --> 00:30:24,399
they have to be attached to the

704
00:30:24,399 --> 00:30:25,440
ciphertext to

705
00:30:25,440 --> 00:30:28,799
actually do everything uh so

706
00:30:28,799 --> 00:30:31,440
you have to have some switch between

707
00:30:31,440 --> 00:30:33,120
keys

708
00:30:33,120 --> 00:30:37,120
and you cannot assume that uh

709
00:30:37,120 --> 00:30:39,520
just by rotating into a different

710
00:30:39,520 --> 00:30:40,880
primary key

711
00:30:40,880 --> 00:30:43,919
you're already uh you have to actually

712
00:30:43,919 --> 00:30:46,320
be at the point where you remove the

713
00:30:46,320 --> 00:30:48,960
remove the old keys in order to

714
00:30:48,960 --> 00:30:53,760
have a full uh fully restored in case of

715
00:30:53,760 --> 00:30:56,399
compromise

716
00:31:03,120 --> 00:31:05,840
are some good um

717
00:31:07,519 --> 00:31:10,399
okay thanks sophie um are there any

718
00:31:10,399 --> 00:31:11,039
questions

719
00:31:11,039 --> 00:31:13,519
on the zulip i'm still looking here um

720
00:31:13,519 --> 00:31:14,960
in in the meantime

721
00:31:14,960 --> 00:31:18,159
i have a question um you've studied

722
00:31:18,159 --> 00:31:21,200
these sort of signed objects uh how does

723
00:31:21,200 --> 00:31:22,559
this research apply to

724
00:31:22,559 --> 00:31:25,120
say interactive protocols uh like

725
00:31:25,120 --> 00:31:26,399
transport protocols have you seen

726
00:31:26,399 --> 00:31:28,159
anything similar

727
00:31:28,159 --> 00:31:30,640
yeah so for transport protocols it's a

728
00:31:30,640 --> 00:31:31,360
similar

729
00:31:31,360 --> 00:31:34,159
thing like in heart the problem that

730
00:31:34,159 --> 00:31:37,600
happens here is that

731
00:31:44,840 --> 00:31:47,840
uh

732
00:32:12,840 --> 00:32:15,840
is

733
00:32:24,720 --> 00:32:28,080
okay one question from the chat um

734
00:32:28,080 --> 00:32:29,760
to what degree could vulnerability

735
00:32:29,760 --> 00:32:31,760
discovery of these types of issues be

736
00:32:31,760 --> 00:32:33,840
automated any plans to do such

737
00:32:33,840 --> 00:32:36,559
automation at google

738
00:32:36,559 --> 00:32:40,480
um we have some plans of that it's

739
00:32:40,480 --> 00:32:43,840
somewhat hard to like uh

740
00:32:43,840 --> 00:32:47,440
discover like things outside of uh

741
00:32:47,440 --> 00:32:49,679
your actual graphic life like what

742
00:32:49,679 --> 00:32:52,720
usually happens is

743
00:32:53,840 --> 00:32:56,399
like you ask it for a certain algorithm

744
00:32:56,399 --> 00:32:57,440
you ask it

745
00:32:57,440 --> 00:33:01,919
to use this key and then the

746
00:33:01,919 --> 00:33:04,399
vulnerability comes from the fact that

747
00:33:04,399 --> 00:33:08,239
the library is perfectly fine

748
00:33:08,840 --> 00:33:11,840
somehow

749
00:33:22,960 --> 00:33:25,919
uh you have to be very careful that you

750
00:33:25,919 --> 00:33:26,960
have to

751
00:33:26,960 --> 00:33:30,080
uh maybe set the scope of things

752
00:33:30,080 --> 00:33:33,840
um because if uh you have

753
00:33:33,840 --> 00:33:39,840
too much uh

754
00:33:43,039 --> 00:33:45,760
okay one um last question here is so how

755
00:33:45,760 --> 00:33:48,159
does tink handle prf outputs just raw

756
00:33:48,159 --> 00:33:50,480
bytes

757
00:33:50,840 --> 00:33:53,840
yes

758
00:34:04,840 --> 00:34:06,000
uh

759
00:34:06,000 --> 00:34:07,760
okay um there's one more question this

760
00:34:07,760 --> 00:34:09,199
came in last second

761
00:34:09,199 --> 00:34:10,719
could you give an example of what you

762
00:34:10,719 --> 00:34:12,239
mean by key metadata

763
00:34:12,239 --> 00:34:14,800
in the expression key metadata is part

764
00:34:14,800 --> 00:34:16,639
of the key

765
00:34:16,639 --> 00:34:20,000
um yeah i mean the algorithm the

766
00:34:20,000 --> 00:34:22,079
parameters of the algorithm

767
00:34:22,079 --> 00:34:25,760
uh things like key is uh everything

768
00:34:25,760 --> 00:34:28,639
that you need to actually like the

769
00:34:28,639 --> 00:34:29,679
oftentimes

770
00:34:29,679 --> 00:34:32,560
when people talk about the keys about

771
00:34:32,560 --> 00:34:34,960
the key

772
00:34:46,800 --> 00:34:49,119
okay thank you for the talk sophie um

773
00:34:49,119 --> 00:34:50,159
that was great

774
00:34:50,159 --> 00:34:53,119
uh up next is paul grubbs who's going to

775
00:34:53,119 --> 00:34:54,320
be talking about

776
00:34:54,320 --> 00:34:56,000
pancake frequency smoothing for

777
00:34:56,000 --> 00:34:58,000
encrypted data stores

778
00:34:58,000 --> 00:35:00,960
paul take it away thanks i'm going to

779
00:35:00,960 --> 00:35:03,200
try to share my screen

780
00:35:03,200 --> 00:35:06,880
um i think this is going to work

781
00:35:06,880 --> 00:35:12,160
uh can you can you see a powerpoint

782
00:35:12,480 --> 00:35:14,480
yes you'll just need to put it into

783
00:35:14,480 --> 00:35:16,640
presentation mode which is perfect

784
00:35:16,640 --> 00:35:19,280
okay is that good yes and you can't see

785
00:35:19,280 --> 00:35:21,119
the zoom bar can you

786
00:35:21,119 --> 00:35:24,320
no not at all okay great

787
00:35:24,320 --> 00:35:26,400
okay uh well thanks you thank you nick

788
00:35:26,400 --> 00:35:28,000
for that introduction um

789
00:35:28,000 --> 00:35:29,920
so i'm going to be talking today about a

790
00:35:29,920 --> 00:35:31,040
work that i presented along with all

791
00:35:31,040 --> 00:35:32,800
these fabulous co-authors at the

792
00:35:32,800 --> 00:35:36,079
uh music security 2020. so the saying

793
00:35:36,079 --> 00:35:37,839
we're interested in this talk is cloud

794
00:35:37,839 --> 00:35:39,200
storage systems

795
00:35:39,200 --> 00:35:40,960
many many applications are migrating

796
00:35:40,960 --> 00:35:43,040
their key value store back ends to cloud

797
00:35:43,040 --> 00:35:44,000
managed key value

798
00:35:44,000 --> 00:35:45,760
storage in this setup a number of

799
00:35:45,760 --> 00:35:47,520
trusted clients all make key value

800
00:35:47,520 --> 00:35:49,200
queries to a not necessarily trusted

801
00:35:49,200 --> 00:35:50,880
cloud provider that hosts the actual key

802
00:35:50,880 --> 00:35:52,079
value pairs

803
00:35:52,079 --> 00:35:53,359
because we don't necessarily trust the

804
00:35:53,359 --> 00:35:55,040
cloud provider with the data itself it's

805
00:35:55,040 --> 00:35:56,560
common practice to encrypt the key value

806
00:35:56,560 --> 00:35:58,079
pairs before they're uploaded by

807
00:35:58,079 --> 00:36:00,240
for example applying a prf to the key

808
00:36:00,240 --> 00:36:02,000
and an aud encryption scheme to the

809
00:36:02,000 --> 00:36:02,880
value

810
00:36:02,880 --> 00:36:04,800
and to perform queries directly on these

811
00:36:04,800 --> 00:36:07,119
encrypted pairs

812
00:36:07,119 --> 00:36:08,400
unfortunately we know that simply

813
00:36:08,400 --> 00:36:10,240
encrypting the data can't guarantee its

814
00:36:10,240 --> 00:36:11,920
security because of access pattern

815
00:36:11,920 --> 00:36:13,200
attacks where the cloud provider

816
00:36:13,200 --> 00:36:15,200
passively monitors the accesses made by

817
00:36:15,200 --> 00:36:16,000
clients

818
00:36:16,000 --> 00:36:17,599
and uses the information it gains in

819
00:36:17,599 --> 00:36:19,119
tandem with auxiliary knowledge of the

820
00:36:19,119 --> 00:36:20,720
distribution of accesses

821
00:36:20,720 --> 00:36:22,960
to break security for example imagine

822
00:36:22,960 --> 00:36:24,839
medical data is indexed by patient

823
00:36:24,839 --> 00:36:27,440
condition the adversarial cloud provider

824
00:36:27,440 --> 00:36:27,920
can

825
00:36:27,920 --> 00:36:29,520
observe how frequently different keys

826
00:36:29,520 --> 00:36:31,040
are accessed and

827
00:36:31,040 --> 00:36:32,480
may have some prior knowledge about the

828
00:36:32,480 --> 00:36:33,599
overall prevalence of different

829
00:36:33,599 --> 00:36:35,520
conditions in the population

830
00:36:35,520 --> 00:36:37,440
so this cloud provider can use frequency

831
00:36:37,440 --> 00:36:38,880
analysis or

832
00:36:38,880 --> 00:36:40,320
in this case simply mapping the most

833
00:36:40,320 --> 00:36:41,839
frequently accessed key to cancer the

834
00:36:41,839 --> 00:36:43,359
second most frequently accessed key to

835
00:36:43,359 --> 00:36:45,359
epilepsy et cetera et cetera

836
00:36:45,359 --> 00:36:47,920
to basically invert the mapping of prf

837
00:36:47,920 --> 00:36:49,440
values to plaintext keys

838
00:36:49,440 --> 00:36:51,920
and learn uh for example when the

839
00:36:51,920 --> 00:36:53,520
hospital is cancering

840
00:36:53,520 --> 00:36:56,160
sorry querying for a cancer patient in

841
00:36:56,160 --> 00:36:57,119
the last few years

842
00:36:57,119 --> 00:36:58,560
many different access pattern attacks

843
00:36:58,560 --> 00:37:00,320
like this have been uh demonstrated in a

844
00:37:00,320 --> 00:37:02,400
variety of settings

845
00:37:02,400 --> 00:37:04,079
so the question is can existing

846
00:37:04,079 --> 00:37:06,079
cryptographic tools prevent access

847
00:37:06,079 --> 00:37:08,079
pattern attacks on key value stores

848
00:37:08,079 --> 00:37:09,920
so basically two classes of existing

849
00:37:09,920 --> 00:37:11,599
solutions the first is based on

850
00:37:11,599 --> 00:37:13,440
theoretical tools like oblivious ram or

851
00:37:13,440 --> 00:37:15,119
private information retrieval and

852
00:37:15,119 --> 00:37:16,720
it prevents access pattern attacks like

853
00:37:16,720 --> 00:37:18,640
the one we just saw in fact it

854
00:37:18,640 --> 00:37:20,960
prevents much stronger attacks which are

855
00:37:20,960 --> 00:37:22,960
mounted by an active adversary that

856
00:37:22,960 --> 00:37:24,640
makes its own accesses in addition to

857
00:37:24,640 --> 00:37:26,640
monitoring honest client accesses

858
00:37:26,640 --> 00:37:27,920
so this kind of attack and practice

859
00:37:27,920 --> 00:37:29,680
would correspond to a cloud provider

860
00:37:29,680 --> 00:37:32,400
that actively attacks its own customers

861
00:37:32,400 --> 00:37:34,240
so the strong security provided by these

862
00:37:34,240 --> 00:37:36,160
primitives uh incurs uh

863
00:37:36,160 --> 00:37:37,839
incurs overheads we know that in theory

864
00:37:37,839 --> 00:37:39,440
there must be at least a logarithmic

865
00:37:39,440 --> 00:37:41,520
blow up and bandwidth uh for using these

866
00:37:41,520 --> 00:37:43,280
primitives and that in practice uh

867
00:37:43,280 --> 00:37:45,280
this this theoretical inefficiency

868
00:37:45,280 --> 00:37:46,800
translates to overheads of as much as

869
00:37:46,800 --> 00:37:48,160
1600x

870
00:37:48,160 --> 00:37:52,000
for real workloads so another class of

871
00:37:52,000 --> 00:37:53,440
solution is searchable

872
00:37:53,440 --> 00:37:55,359
symmetric encryption or ssc which offers

873
00:37:55,359 --> 00:37:56,640
pretty good performance but

874
00:37:56,640 --> 00:37:58,160
can really only prevent access pattern

875
00:37:58,160 --> 00:37:59,839
attacks against a very weak snapshot

876
00:37:59,839 --> 00:38:00,880
adversary that

877
00:38:00,880 --> 00:38:03,119
can't see any queries so this attack

878
00:38:03,119 --> 00:38:04,480
would arise in practice only if the

879
00:38:04,480 --> 00:38:05,520
cloud provider

880
00:38:05,520 --> 00:38:07,119
ignored the query information it was

881
00:38:07,119 --> 00:38:09,520
receiving from the clients

882
00:38:09,520 --> 00:38:11,760
so in in this uh in this work we

883
00:38:11,760 --> 00:38:13,040
basically explore a new

884
00:38:13,040 --> 00:38:14,640
uh a threat model and try to ask the

885
00:38:14,640 --> 00:38:17,200
question of can we purpose build a

886
00:38:17,200 --> 00:38:18,880
counter measure for these persistent

887
00:38:18,880 --> 00:38:19,359
passive

888
00:38:19,359 --> 00:38:21,040
access pattern attacks like the one i

889
00:38:21,040 --> 00:38:22,720
described in the previous slide

890
00:38:22,720 --> 00:38:24,240
where the adversary can see the accesses

891
00:38:24,240 --> 00:38:27,200
but doesn't necessarily inject its own

892
00:38:27,200 --> 00:38:28,960
we think this persistent passive threat

893
00:38:28,960 --> 00:38:31,359
model meaningfully captures a lot of

894
00:38:31,359 --> 00:38:32,720
threats that are faced by real

895
00:38:32,720 --> 00:38:34,800
deployments of cloud cloud storage

896
00:38:34,800 --> 00:38:35,680
systems

897
00:38:35,680 --> 00:38:37,520
uh so so the question is uh can we

898
00:38:37,520 --> 00:38:39,520
achieve good security and low

899
00:38:39,520 --> 00:38:41,440
uh performance overhead uh in this

900
00:38:41,440 --> 00:38:43,119
persistent passive adversary so how can

901
00:38:43,119 --> 00:38:45,040
we build an approach that does that

902
00:38:45,040 --> 00:38:47,040
so the way we're going to take advantage

903
00:38:47,040 --> 00:38:48,320
of this fret model is

904
00:38:48,320 --> 00:38:51,359
by having all the clients make

905
00:38:51,359 --> 00:38:52,720
their accesses through a trusted

906
00:38:52,720 --> 00:38:55,280
client-side proxy and by giving the

907
00:38:55,280 --> 00:38:57,440
by giving the proxy the same access to

908
00:38:57,440 --> 00:38:59,280
the same distribution that the

909
00:38:59,280 --> 00:39:01,440
that we assume the adversary has this is

910
00:39:01,440 --> 00:39:02,880
quite a natural assumption actually

911
00:39:02,880 --> 00:39:05,200
because in practice key value store

912
00:39:05,200 --> 00:39:08,000
key value stores already implicitly

913
00:39:08,000 --> 00:39:09,599
maintain a lot of information about the

914
00:39:09,599 --> 00:39:11,200
axis distribution to do things like

915
00:39:11,200 --> 00:39:13,520
caching and load balancing

916
00:39:13,520 --> 00:39:15,280
so this work has three main

917
00:39:15,280 --> 00:39:16,720
contributions we show that

918
00:39:16,720 --> 00:39:18,720
uh with with this information in this

919
00:39:18,720 --> 00:39:20,480
model uh we show a novel frequency

920
00:39:20,480 --> 00:39:21,920
smoothing algorithm

921
00:39:21,920 --> 00:39:25,280
uh that uh that the proxy can use to

922
00:39:25,280 --> 00:39:27,599
smooth the ac the access is made by

923
00:39:27,599 --> 00:39:28,480
clients to the

924
00:39:28,480 --> 00:39:31,599
outsourced key value store so this this

925
00:39:31,599 --> 00:39:32,800
attack prevents

926
00:39:32,800 --> 00:39:34,640
this sorry this algorithm prevents

927
00:39:34,640 --> 00:39:36,079
access pattern attacks by ensuring that

928
00:39:36,079 --> 00:39:37,760
all accesses made to the key value store

929
00:39:37,760 --> 00:39:39,520
are uniformly random

930
00:39:39,520 --> 00:39:41,119
but it also incurs only a constant

931
00:39:41,119 --> 00:39:42,960
server storage and constant bandwidth

932
00:39:42,960 --> 00:39:45,040
overhead

933
00:39:45,040 --> 00:39:47,280
our algorithm forms the core of a built

934
00:39:47,280 --> 00:39:49,119
proxy system for doing frequency

935
00:39:49,119 --> 00:39:51,920
which we call pancake we also provided a

936
00:39:51,920 --> 00:39:53,920
formal security analysis

937
00:39:53,920 --> 00:39:55,920
where we formulated a novel security

938
00:39:55,920 --> 00:39:57,680
goal for the security that we want to

939
00:39:57,680 --> 00:39:59,119
achieve in the setting we proved that

940
00:39:59,119 --> 00:40:00,720
our our frequency smoothing algorithm

941
00:40:00,720 --> 00:40:02,400
achieves it in this persistent passive

942
00:40:02,400 --> 00:40:03,280
threat model

943
00:40:03,280 --> 00:40:05,359
and finally we showed uh an extensive

944
00:40:05,359 --> 00:40:07,040
evaluation of the pancake system and

945
00:40:07,040 --> 00:40:07,920
demonstrated that

946
00:40:07,920 --> 00:40:10,079
pancake pancakes throughput is more than

947
00:40:10,079 --> 00:40:11,599
two orders of magnitude higher than the

948
00:40:11,599 --> 00:40:12,400
state of the art

949
00:40:12,400 --> 00:40:14,560
patho ram not two times two orders of

950
00:40:14,560 --> 00:40:16,480
magnitude

951
00:40:16,480 --> 00:40:17,920
so just to reiterate and establish a

952
00:40:17,920 --> 00:40:19,599
little bit of notation our system model

953
00:40:19,599 --> 00:40:21,280
is one in which key value queries

954
00:40:21,280 --> 00:40:23,040
are all independent samples according to

955
00:40:23,040 --> 00:40:24,560
a distribution pi known

956
00:40:24,560 --> 00:40:27,280
both to the adversary and to our proxy

957
00:40:27,280 --> 00:40:28,880
so the approach of frequency smoothing

958
00:40:28,880 --> 00:40:30,240
our our goal is to

959
00:40:30,240 --> 00:40:32,160
try to transform the distribution of

960
00:40:32,160 --> 00:40:34,240
plain text accesses made by clients

961
00:40:34,240 --> 00:40:36,079
into a smoother distribution over a

962
00:40:36,079 --> 00:40:37,599
potentially larger set of encrypted

963
00:40:37,599 --> 00:40:38,079
items

964
00:40:38,079 --> 00:40:40,720
stored at the server so there's

965
00:40:40,720 --> 00:40:42,079
basically two tools we're going to use

966
00:40:42,079 --> 00:40:42,800
to do this

967
00:40:42,800 --> 00:40:46,000
the first is replication where we make

968
00:40:46,000 --> 00:40:47,839
multiple copies of the popular items in

969
00:40:47,839 --> 00:40:49,280
this distribution pi

970
00:40:49,280 --> 00:40:51,119
uh and when we want to query one of them

971
00:40:51,119 --> 00:40:52,319
we sample one of them uniformly at

972
00:40:52,319 --> 00:40:54,480
random and access that one

973
00:40:54,480 --> 00:40:58,000
so this method of replication can smooth

974
00:40:58,000 --> 00:40:59,599
completely any distribution

975
00:40:59,599 --> 00:41:01,119
but it may require a lot of server-side

976
00:41:01,119 --> 00:41:03,520
storage overhead

977
00:41:03,520 --> 00:41:04,880
another idea that we're going to use

978
00:41:04,880 --> 00:41:06,560
here is fake accesses

979
00:41:06,560 --> 00:41:08,640
where when a client wants to make a

980
00:41:08,640 --> 00:41:10,800
query it sends its real query along with

981
00:41:10,800 --> 00:41:12,560
some number of other fake queries

982
00:41:12,560 --> 00:41:15,359
which are sampled according to some

983
00:41:15,359 --> 00:41:16,720
distribution which is complementary in

984
00:41:16,720 --> 00:41:17,599
some sense to the

985
00:41:17,599 --> 00:41:19,599
to this distribution pi that makes the

986
00:41:19,599 --> 00:41:21,119
overall access probabilities to all the

987
00:41:21,119 --> 00:41:22,800
keys uniform

988
00:41:22,800 --> 00:41:24,640
again here the problem is that using

989
00:41:24,640 --> 00:41:26,480
these fake axes in isolation

990
00:41:26,480 --> 00:41:28,000
may lead to a lot of bandwidth overheads

991
00:41:28,000 --> 00:41:29,359
because you need to send a lot of fake

992
00:41:29,359 --> 00:41:30,880
queries to make the

993
00:41:30,880 --> 00:41:34,160
access probabilities uniform so neither

994
00:41:34,160 --> 00:41:35,440
of these tools really give us what we

995
00:41:35,440 --> 00:41:36,000
want

996
00:41:36,000 --> 00:41:38,319
by themselves so in pancake what we do

997
00:41:38,319 --> 00:41:40,240
is use them in tandem as follows

998
00:41:40,240 --> 00:41:42,720
uh first we use replication to partially

999
00:41:42,720 --> 00:41:44,640
smooth out the distribution of replicas

1000
00:41:44,640 --> 00:41:46,560
subject to a bounded overhead on the

1001
00:41:46,560 --> 00:41:48,240
server-side storage

1002
00:41:48,240 --> 00:41:50,560
um and then we use fake accesses to

1003
00:41:50,560 --> 00:41:52,560
smooth out the remaining non-uniformity

1004
00:41:52,560 --> 00:41:54,000
basically we define a fake axis

1005
00:41:54,000 --> 00:41:55,119
distribution pi sub

1006
00:41:55,119 --> 00:41:58,000
f uh which we can over the the set of

1007
00:41:58,000 --> 00:41:59,680
replicated key value pairs which we can

1008
00:41:59,680 --> 00:42:02,000
sample to

1009
00:42:02,000 --> 00:42:05,200
smooth out the distribution totally so

1010
00:42:05,200 --> 00:42:06,480
with a bit of math and i'm waving my

1011
00:42:06,480 --> 00:42:07,599
hands a little bit here because i don't

1012
00:42:07,599 --> 00:42:08,880
have time to explain

1013
00:42:08,880 --> 00:42:10,880
the details but what we can show is that

1014
00:42:10,880 --> 00:42:12,240
uh for a single axis

1015
00:42:12,240 --> 00:42:13,920
in expectation we only need one fake

1016
00:42:13,920 --> 00:42:16,800
access per real access

1017
00:42:16,800 --> 00:42:18,640
uh but we're not actually done uh

1018
00:42:18,640 --> 00:42:20,000
because if we sample

1019
00:42:20,000 --> 00:42:21,680
in our in our fake access protocol if we

1020
00:42:21,680 --> 00:42:23,359
sample a fake access instead of a real

1021
00:42:23,359 --> 00:42:24,960
one we won't actually be able to service

1022
00:42:24,960 --> 00:42:26,240
the client's query

1023
00:42:26,240 --> 00:42:27,920
so we need some more logic around this

1024
00:42:27,920 --> 00:42:29,520
basic frequency smoothing protocol to

1025
00:42:29,520 --> 00:42:30,880
ensure client queries are actually

1026
00:42:30,880 --> 00:42:32,160
answered

1027
00:42:32,160 --> 00:42:33,760
the core difficulty in doing this is

1028
00:42:33,760 --> 00:42:34,960
ensuring that the adversary can't

1029
00:42:34,960 --> 00:42:37,040
distinguish real and fake accesses

1030
00:42:37,040 --> 00:42:38,400
our first couple attempts in building

1031
00:42:38,400 --> 00:42:39,760
this logic actually didn't ensure this

1032
00:42:39,760 --> 00:42:40,800
and were insecure

1033
00:42:40,800 --> 00:42:43,520
so what we eventually came up with is an

1034
00:42:43,520 --> 00:42:45,440
approach that uses fixed size batches of

1035
00:42:45,440 --> 00:42:46,880
accesses in response to each

1036
00:42:46,880 --> 00:42:48,960
client generated access so what we do

1037
00:42:48,960 --> 00:42:50,400
basically is when a client query comes

1038
00:42:50,400 --> 00:42:51,839
in we put it in some kind of pending

1039
00:42:51,839 --> 00:42:52,960
query queue

1040
00:42:52,960 --> 00:42:56,160
and then we flip uh b fair coins

1041
00:42:56,160 --> 00:42:58,240
so we use b equals three in pancake and

1042
00:42:58,240 --> 00:43:00,079
if one of those coins comes up heads

1043
00:43:00,079 --> 00:43:02,240
we dequeue a real query from the pending

1044
00:43:02,240 --> 00:43:03,839
query queue or we sample from the true

1045
00:43:03,839 --> 00:43:05,359
query distribution pi

1046
00:43:05,359 --> 00:43:06,960
uh otherwise if it comes up tails we

1047
00:43:06,960 --> 00:43:08,720
sample from our fake query distribution

1048
00:43:08,720 --> 00:43:09,599
pi sub f

1049
00:43:09,599 --> 00:43:12,880
uh and send uh send this whole batch of

1050
00:43:12,880 --> 00:43:15,359
accesses to the server

1051
00:43:15,359 --> 00:43:16,800
so it's essentially hard to see that

1052
00:43:16,800 --> 00:43:18,800
this method this fixed size batching

1053
00:43:18,800 --> 00:43:19,200
method

1054
00:43:19,200 --> 00:43:21,359
results in at most 3x bandwidth overhead

1055
00:43:21,359 --> 00:43:23,359
and at most 2x storage overhead over the

1056
00:43:23,359 --> 00:43:25,119
kind of insecure baseline key value

1057
00:43:25,119 --> 00:43:27,200
store

1058
00:43:27,200 --> 00:43:29,520
so we analyzed the security of this

1059
00:43:29,520 --> 00:43:31,200
frequency smoothing approach

1060
00:43:31,200 --> 00:43:32,400
under a couple of assumptions the first

1061
00:43:32,400 --> 00:43:33,839
is our persistent passive adversary that

1062
00:43:33,839 --> 00:43:35,280
we talked about before

1063
00:43:35,280 --> 00:43:37,040
the second is that the pancake proxy has

1064
00:43:37,040 --> 00:43:38,560
a reasonable estimate of the true query

1065
00:43:38,560 --> 00:43:39,760
distribution pi

1066
00:43:39,760 --> 00:43:42,000
and the third is that the server can't

1067
00:43:42,000 --> 00:43:43,520
distinguish between real and fake

1068
00:43:43,520 --> 00:43:44,960
accesses by for example using some kind

1069
00:43:44,960 --> 00:43:47,440
of timing analysis

1070
00:43:47,440 --> 00:43:49,839
so we'll be what we prove we formulate a

1071
00:43:49,839 --> 00:43:50,640
security goal

1072
00:43:50,640 --> 00:43:52,400
called real random indistinguishability

1073
00:43:52,400 --> 00:43:54,319
under chosen distribution attack or ror

1074
00:43:54,319 --> 00:43:56,319
cda and what this says is that

1075
00:43:56,319 --> 00:43:58,319
uh pancake guarantees that two different

1076
00:43:58,319 --> 00:43:59,680
worlds are indistinguishable the first

1077
00:43:59,680 --> 00:44:01,359
is the real world where the adversary

1078
00:44:01,359 --> 00:44:03,520
receives the set of replicated encrypted

1079
00:44:03,520 --> 00:44:05,440
key value pairs and a transcript of t

1080
00:44:05,440 --> 00:44:07,839
encrypted accesses to these key value

1081
00:44:07,839 --> 00:44:09,280
pairs that were generated by the real

1082
00:44:09,280 --> 00:44:10,720
pancake proxy

1083
00:44:10,720 --> 00:44:12,640
and in the the other world is the ideal

1084
00:44:12,640 --> 00:44:14,480
world in which the adversary receives

1085
00:44:14,480 --> 00:44:16,319
random bit strings and basically a set

1086
00:44:16,319 --> 00:44:18,640
of t uniformly random accesses

1087
00:44:18,640 --> 00:44:20,800
to these random bit strings so what we

1088
00:44:20,800 --> 00:44:22,000
prove is that pancake

1089
00:44:22,000 --> 00:44:23,839
ensures that for any distribution these

1090
00:44:23,839 --> 00:44:27,119
two worlds are indistinguishable

1091
00:44:27,119 --> 00:44:28,319
so there are several additional

1092
00:44:28,319 --> 00:44:30,160
challenges which i don't have very much

1093
00:44:30,160 --> 00:44:31,440
to talk about but i'll touch on

1094
00:44:31,440 --> 00:44:34,240
very briefly here um the the first is

1095
00:44:34,240 --> 00:44:35,760
how do we update key value pairs that

1096
00:44:35,760 --> 00:44:37,680
have multiple replicas uh well what we

1097
00:44:37,680 --> 00:44:38,000
do

1098
00:44:38,000 --> 00:44:39,839
is to take a kind of similar stashing

1099
00:44:39,839 --> 00:44:41,520
approach that kenny described in his

1100
00:44:41,520 --> 00:44:42,240
present

1101
00:44:42,240 --> 00:44:44,000
his presentation where we kind of buffer

1102
00:44:44,000 --> 00:44:45,520
those updates at the proxy

1103
00:44:45,520 --> 00:44:47,440
until we make an access to the correct

1104
00:44:47,440 --> 00:44:49,280
um to the correct replica

1105
00:44:49,280 --> 00:44:51,680
uh to handle uh changing axis patterns

1106
00:44:51,680 --> 00:44:52,880
uh we can

1107
00:44:52,880 --> 00:44:54,880
assign we can adjust our fake

1108
00:44:54,880 --> 00:44:56,160
distribution to uh

1109
00:44:56,160 --> 00:44:57,760
to compensate for the kind of difference

1110
00:44:57,760 --> 00:44:59,359
between the old and the new

1111
00:44:59,359 --> 00:45:01,359
distribution and then reassign replicas

1112
00:45:01,359 --> 00:45:02,880
if necessary using a replica swapping

1113
00:45:02,880 --> 00:45:03,760
protocol

1114
00:45:03,760 --> 00:45:05,359
and finally to estimate the axis

1115
00:45:05,359 --> 00:45:07,040
distribution itself and to detect

1116
00:45:07,040 --> 00:45:09,359
changes in the axis distribution uh we

1117
00:45:09,359 --> 00:45:10,240
use basically

1118
00:45:10,240 --> 00:45:11,839
off-the-shelf tools more or less from

1119
00:45:11,839 --> 00:45:14,000
statistics so like histograms and like a

1120
00:45:14,000 --> 00:45:16,000
two-sample ks test to detect changes in

1121
00:45:16,000 --> 00:45:17,680
distribution

1122
00:45:17,680 --> 00:45:19,280
and there there are a lot more details

1123
00:45:19,280 --> 00:45:20,720
in the paper and i encourage you to read

1124
00:45:20,720 --> 00:45:21,680
the paper if you are

1125
00:45:21,680 --> 00:45:24,880
interested uh so finally i'll describe

1126
00:45:24,880 --> 00:45:27,920
our evaluation uh so this

1127
00:45:27,920 --> 00:45:29,440
in this experiment i'll describe we use

1128
00:45:29,440 --> 00:45:31,520
ycsb workload a which is a very standard

1129
00:45:31,520 --> 00:45:32,000
benchmark

1130
00:45:32,000 --> 00:45:34,079
workload for key value store performance

1131
00:45:34,079 --> 00:45:35,760
and we used a data a data set of a

1132
00:45:35,760 --> 00:45:38,640
million one kilobyte key value pairs

1133
00:45:38,640 --> 00:45:40,160
so the takeaway from these numbers is

1134
00:45:40,160 --> 00:45:42,240
that the server storage for pancake is

1135
00:45:42,240 --> 00:45:43,920
four times lower than path o ram and the

1136
00:45:43,920 --> 00:45:45,440
proxy storage is still quite low it's

1137
00:45:45,440 --> 00:45:47,520
only about one percent of server storage

1138
00:45:47,520 --> 00:45:50,240
but the throughput is 220 times higher

1139
00:45:50,240 --> 00:45:50,640
than

1140
00:45:50,640 --> 00:45:52,800
patho ram for pancake and the latency is

1141
00:45:52,800 --> 00:45:55,839
12 times lower than patho ram

1142
00:45:55,839 --> 00:45:57,440
so this isn't the only experiment we did

1143
00:45:57,440 --> 00:45:59,760
there's a very very extensive evaluation

1144
00:45:59,760 --> 00:46:02,800
in the paper so just to wrap up and give

1145
00:46:02,800 --> 00:46:03,680
you summary so

1146
00:46:03,680 --> 00:46:05,200
pancake is the first system that

1147
00:46:05,200 --> 00:46:06,640
protects data stores against access

1148
00:46:06,640 --> 00:46:07,599
pattern attacks

1149
00:46:07,599 --> 00:46:09,200
with only a constant factor server

1150
00:46:09,200 --> 00:46:11,520
storage and constant bandwidth overhead

1151
00:46:11,520 --> 00:46:13,359
we perform a formal security analysis

1152
00:46:13,359 --> 00:46:14,880
establishing the persistent passive

1153
00:46:14,880 --> 00:46:16,079
security of

1154
00:46:16,079 --> 00:46:17,680
the pancake protocol establishing that

1155
00:46:17,680 --> 00:46:19,760
it resists these access pattern attacks

1156
00:46:19,760 --> 00:46:21,040
and finally we perform an extensive

1157
00:46:21,040 --> 00:46:22,400
evaluation that demonstrates that

1158
00:46:22,400 --> 00:46:24,160
pancakes throughput is more than two

1159
00:46:24,160 --> 00:46:25,440
orders of magnitude higher than the

1160
00:46:25,440 --> 00:46:27,200
state-of-the-art pathogram

1161
00:46:27,200 --> 00:46:28,800
thank you very much and i'll take any

1162
00:46:28,800 --> 00:46:30,880
questions

1163
00:46:30,880 --> 00:46:32,720
thanks paul um seeing how we're a little

1164
00:46:32,720 --> 00:46:34,800
bit over um let's take the questions in

1165
00:46:34,800 --> 00:46:35,839
the chat room

1166
00:46:35,839 --> 00:46:39,119
and give folks a break and so we'll see

1167
00:46:39,119 --> 00:46:42,160
everyone back here in 20 minutes for the

1168
00:46:42,160 --> 00:46:43,839
next invited talk

1169
00:46:43,839 --> 00:46:46,880
thanks everyone

