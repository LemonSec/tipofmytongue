1
00:00:00,780 --> 00:00:05,600
uh what do I do

2
00:00:07,919 --> 00:00:10,260
uh-huh

3
00:00:10,260 --> 00:00:14,000
click again like what

4
00:00:14,299 --> 00:00:18,560
okay can we get rid of that part

5
00:00:19,020 --> 00:00:22,260
okay all right so with the property that

6
00:00:22,260 --> 00:00:23,820
a users

7
00:00:23,820 --> 00:00:25,920
uh users whose keys do not satisfy the

8
00:00:25,920 --> 00:00:27,660
challenge policy should not be able to

9
00:00:27,660 --> 00:00:29,640
decrypt and in fact this property should

10
00:00:29,640 --> 00:00:31,740
hold even if users are colluding namely

11
00:00:31,740 --> 00:00:33,600
if I set up users who individually are

12
00:00:33,600 --> 00:00:35,579
not able to decrypt the ciphertext they

13
00:00:35,579 --> 00:00:36,719
should not be able to combine their

14
00:00:36,719 --> 00:00:39,300
teeth together color and decrypt the

15
00:00:39,300 --> 00:00:40,680
challenge type or text

16
00:00:40,680 --> 00:00:42,780
as I have described it here there is a

17
00:00:42,780 --> 00:00:44,640
single Authority that is responsible for

18
00:00:44,640 --> 00:00:46,860
issuing fees uh to all the different

19
00:00:46,860 --> 00:00:49,379
users in the system however in a

20
00:00:49,379 --> 00:00:50,820
practice and in the real world things

21
00:00:50,820 --> 00:00:52,980
are oftentimes more fragmented it might

22
00:00:52,980 --> 00:00:54,300
make more sense for different

23
00:00:54,300 --> 00:00:56,160
authorities to come through different

24
00:00:56,160 --> 00:00:58,440
attributes in a university-based example

25
00:00:58,440 --> 00:01:00,539
that I'm just that I've described here

26
00:01:00,539 --> 00:01:01,980
it might make sense for different

27
00:01:01,980 --> 00:01:03,780
universities to manage the attributes

28
00:01:03,780 --> 00:01:05,400
for the different users within their

29
00:01:05,400 --> 00:01:07,860
respective domain this is the notion of

30
00:01:07,860 --> 00:01:09,299
multi-authority attribute-based

31
00:01:09,299 --> 00:01:11,580
encryption or multi Authority Abe for

32
00:01:11,580 --> 00:01:12,600
short

33
00:01:12,600 --> 00:01:15,180
uh so in a multi-authority Abe scheme

34
00:01:15,180 --> 00:01:17,939
anyone can become an authority uh and

35
00:01:17,939 --> 00:01:21,180
when an authority uh comes online they

36
00:01:21,180 --> 00:01:23,040
basically publish a public key along

37
00:01:23,040 --> 00:01:24,600
with a set of attributes that it

38
00:01:24,600 --> 00:01:26,700
controls and importantly in these

39
00:01:26,700 --> 00:01:28,439
systems we require that there is no

40
00:01:28,439 --> 00:01:30,360
interaction or coordination between

41
00:01:30,360 --> 00:01:33,540
individual Authority ciphertexts are

42
00:01:33,540 --> 00:01:35,159
still associated with different policies

43
00:01:35,159 --> 00:01:37,200
where here the policy is expressed as a

44
00:01:37,200 --> 00:01:39,960
function of a set of attributes and the

45
00:01:39,960 --> 00:01:43,020
authorities that manage them

46
00:01:43,020 --> 00:01:45,780
so a recent line of work have shown how

47
00:01:45,780 --> 00:01:47,700
to construct multi-authority Abe for

48
00:01:47,700 --> 00:01:49,439
different policy families as well as

49
00:01:49,439 --> 00:01:50,880
different cryptographic assumptions

50
00:01:50,880 --> 00:01:52,740
starting from the work of you cooling

51
00:01:52,740 --> 00:01:54,720
waters for instance we have construction

52
00:01:54,720 --> 00:01:57,479
for Boolean formulas from bilinear map

53
00:01:57,479 --> 00:02:00,000
assumptions and very recently a work of

54
00:02:00,000 --> 00:02:02,280
data at komorgotsky and Waters shows how

55
00:02:02,280 --> 00:02:04,560
to construct multi-authority Abe for the

56
00:02:04,560 --> 00:02:06,780
class of conjunction policies from the

57
00:02:06,780 --> 00:02:08,399
plane learning with errors assumption

58
00:02:08,399 --> 00:02:10,500
and we look at all of these existing

59
00:02:10,500 --> 00:02:12,959
constructions however all of them are in

60
00:02:12,959 --> 00:02:15,480
a random Oracle model and so the natural

61
00:02:15,480 --> 00:02:17,520
question that we ask in this work is

62
00:02:17,520 --> 00:02:18,840
whether we can hope to construct

63
00:02:18,840 --> 00:02:21,000
multi-authority Abe scheme without

64
00:02:21,000 --> 00:02:23,459
relying on random oracles and here I'll

65
00:02:23,459 --> 00:02:26,640
preface that we also will also avoid uh

66
00:02:26,640 --> 00:02:28,260
strong general purpose assumptions like

67
00:02:28,260 --> 00:02:30,060
extractable witness encryption or

68
00:02:30,060 --> 00:02:32,520
indistinguishability application in fact

69
00:02:32,520 --> 00:02:34,440
we ask can we show that one of these

70
00:02:34,440 --> 00:02:36,060
existing constructions is actually

71
00:02:36,060 --> 00:02:38,640
secure in a plane model with a suitable

72
00:02:38,640 --> 00:02:40,739
instantiation of the underlying hash

73
00:02:40,739 --> 00:02:42,540
function and that's exactly what we do

74
00:02:42,540 --> 00:02:44,640
in this work that we show that if we

75
00:02:44,640 --> 00:02:46,560
take the construction of data commodity

76
00:02:46,560 --> 00:02:48,780
and Waters and we instantiate the hash

77
00:02:48,780 --> 00:02:50,879
function with a concrete function we

78
00:02:50,879 --> 00:02:52,800
actually can argue Security in a plane

79
00:02:52,800 --> 00:02:55,140
model but under a stronger version of

80
00:02:55,140 --> 00:02:56,940
the lwe Assumption this recently

81
00:02:56,940 --> 00:02:59,700
introduced evasive lwe assumption

82
00:02:59,700 --> 00:03:01,620
I think an interesting property of our

83
00:03:01,620 --> 00:03:03,780
particular construction is that the hash

84
00:03:03,780 --> 00:03:05,519
function that we use here is actually

85
00:03:05,519 --> 00:03:07,860
not a random looking function at all the

86
00:03:07,860 --> 00:03:10,140
function is actually a subset product of

87
00:03:10,140 --> 00:03:13,980
low Norm matrices so here at b0 and D1

88
00:03:13,980 --> 00:03:16,500
our our public Matrix States and just by

89
00:03:16,500 --> 00:03:18,360
taking a subset product we can show that

90
00:03:18,360 --> 00:03:20,099
this scheme is actually provably secure

91
00:03:20,099 --> 00:03:22,940
under this evasive lwe assumption

92
00:03:22,940 --> 00:03:25,800
now granted evasive lwe is not a

93
00:03:25,800 --> 00:03:27,599
standard assumption but I think it still

94
00:03:27,599 --> 00:03:30,300
provides a useful evidence uh under that

95
00:03:30,300 --> 00:03:32,640
shows that this uh that this approach is

96
00:03:32,640 --> 00:03:34,980
still sound and possibly gives a secure

97
00:03:34,980 --> 00:03:37,379
instantiation and it leaves open the

98
00:03:37,379 --> 00:03:39,360
very intriguing problem whether we can

99
00:03:39,360 --> 00:03:40,860
hope to prove the security of this

100
00:03:40,860 --> 00:03:42,180
construction with this particular

101
00:03:42,180 --> 00:03:44,220
instantiation of the hash function from

102
00:03:44,220 --> 00:03:47,280
the standard lwe assumption

103
00:03:47,280 --> 00:03:49,260
so before I launch into the details of

104
00:03:49,260 --> 00:03:50,879
our construction let me give you a

105
00:03:50,879 --> 00:03:52,739
flavor for why the random Oracle has

106
00:03:52,739 --> 00:03:54,180
been helpful in constructing

107
00:03:54,180 --> 00:03:56,940
multi-authority AB East Kings the key

108
00:03:56,940 --> 00:03:58,980
challenge improving the security of

109
00:03:58,980 --> 00:04:01,019
multi-authority ABD is handling

110
00:04:01,019 --> 00:04:03,840
collusions uh namely how do we ensure

111
00:04:03,840 --> 00:04:05,580
that different users who have different

112
00:04:05,580 --> 00:04:07,260
sets of keys that are individually not

113
00:04:07,260 --> 00:04:09,239
able to decrypt the cipher text cannot

114
00:04:09,239 --> 00:04:11,819
somehow combine them together to decrypt

115
00:04:11,819 --> 00:04:14,819
uh in a single Authority setting this is

116
00:04:14,819 --> 00:04:16,858
handled by using correlated randomnesses

117
00:04:16,858 --> 00:04:19,079
to uh to generate the keys associated

118
00:04:19,079 --> 00:04:20,940
with a particular user so the same

119
00:04:20,940 --> 00:04:22,740
Authority when it gives out the keys for

120
00:04:22,740 --> 00:04:24,600
a particular user they're going to use a

121
00:04:24,600 --> 00:04:26,580
common Randomness to prevent mixty and

122
00:04:26,580 --> 00:04:28,380
mashing of keys across different users

123
00:04:28,380 --> 00:04:31,800
this kind of uh approach is difficult to

124
00:04:31,800 --> 00:04:33,660
implement in the multi-authority setting

125
00:04:33,660 --> 00:04:35,220
because different authorities have to

126
00:04:35,220 --> 00:04:37,080
act independently when generating the

127
00:04:37,080 --> 00:04:39,960
keys for a particular user so what is

128
00:04:39,960 --> 00:04:41,280
done there

129
00:04:41,280 --> 00:04:44,100
is that we associate each user with a

130
00:04:44,100 --> 00:04:47,340
global identifier to know the GID and

131
00:04:47,340 --> 00:04:50,040
the keys are generated using correlated

132
00:04:50,040 --> 00:04:52,139
Randomness and the correlated Randomness

133
00:04:52,139 --> 00:04:55,259
is derived by the Thunder uh it's

134
00:04:55,259 --> 00:04:58,259
derived by hashing the GID using some

135
00:04:58,259 --> 00:05:01,199
hash function H and in a security proof

136
00:05:01,199 --> 00:05:03,840
we actually need a Model H as a random

137
00:05:03,840 --> 00:05:04,919
Oracle

138
00:05:04,919 --> 00:05:07,380
so now let's talk about our particular

139
00:05:07,380 --> 00:05:09,840
construction so let me start by

140
00:05:09,840 --> 00:05:12,000
describing a simple construction uh this

141
00:05:12,000 --> 00:05:13,800
is a simplified version of the

142
00:05:13,800 --> 00:05:15,240
construction of data comma guard skin

143
00:05:15,240 --> 00:05:17,040
workers and for Simplicity of

144
00:05:17,040 --> 00:05:18,900
acquisition I'm going to assume that

145
00:05:18,900 --> 00:05:20,580
every Authority just controls a single

146
00:05:20,580 --> 00:05:22,800
attribute in the scheme so we have three

147
00:05:22,800 --> 00:05:24,300
authorities each of the three

148
00:05:24,300 --> 00:05:26,460
authorities will publish a public key uh

149
00:05:26,460 --> 00:05:27,720
the public key in this case just

150
00:05:27,720 --> 00:05:29,880
includes uh oops

151
00:05:29,880 --> 00:05:33,120
two random matrices A and B as well as a

152
00:05:33,120 --> 00:05:35,039
random Vector p

153
00:05:35,039 --> 00:05:37,380
each Authority will also have a trapdoor

154
00:05:37,380 --> 00:05:38,880
associated with it this will be a

155
00:05:38,880 --> 00:05:41,039
trapdoor for the Matrix a and if you're

156
00:05:41,039 --> 00:05:42,419
not familiar with latticecraft course

157
00:05:42,419 --> 00:05:44,520
that's perfectly fine all you need to

158
00:05:44,520 --> 00:05:46,740
know is that a lattice trap War allows

159
00:05:46,740 --> 00:05:48,600
us to sample short solutions to the

160
00:05:48,600 --> 00:05:50,639
linear system defined by a so if you

161
00:05:50,639 --> 00:05:52,500
have a trapdoor for a and a Target value

162
00:05:52,500 --> 00:05:55,020
y you can sample a short F such that a

163
00:05:55,020 --> 00:05:57,539
times x is equal to one

164
00:05:57,539 --> 00:06:00,240
so now let me tell you how the secret

165
00:06:00,240 --> 00:06:01,919
keys are generated in our particular

166
00:06:01,919 --> 00:06:04,380
scheme so when the user with a

167
00:06:04,380 --> 00:06:06,539
particular GID goes to Authority one and

168
00:06:06,539 --> 00:06:08,340
request a secret key for their attribute

169
00:06:08,340 --> 00:06:10,500
what the authority will do is they will

170
00:06:10,500 --> 00:06:13,020
first hash the GID to obtain some random

171
00:06:13,020 --> 00:06:15,600
Vector R and then it's going to use this

172
00:06:15,600 --> 00:06:19,020
trapdoor to sample a pre-image k so a

173
00:06:19,020 --> 00:06:21,060
sample a short solution K such that a

174
00:06:21,060 --> 00:06:24,479
times K is equal to P plus b times R so

175
00:06:24,479 --> 00:06:26,039
this is the key equation or the key

176
00:06:26,039 --> 00:06:28,080
invariant that we will use in our

177
00:06:28,080 --> 00:06:30,419
particular construction if the user now

178
00:06:30,419 --> 00:06:32,280
goes to Authority two they do exactly

179
00:06:32,280 --> 00:06:33,780
the same thing but with respect to

180
00:06:33,780 --> 00:06:37,139
Authority two's public key the key idea

181
00:06:37,139 --> 00:06:39,840
or the key Insight is that R here is the

182
00:06:39,840 --> 00:06:41,520
thing that's derived by hash in the GID

183
00:06:41,520 --> 00:06:43,740
is the common Randomness that is tying

184
00:06:43,740 --> 00:06:45,960
together the different keys to this

185
00:06:45,960 --> 00:06:48,479
particular user

186
00:06:48,479 --> 00:06:50,400
next let me tell you what the ciphertext

187
00:06:50,400 --> 00:06:52,319
looked like so suppose I want to encrypt

188
00:06:52,319 --> 00:06:55,259
to the policy that's authored that you

189
00:06:55,259 --> 00:06:57,300
have the key for Authority one and for

190
00:06:57,300 --> 00:06:59,580
Authority two what the ciphertext

191
00:06:59,580 --> 00:07:02,460
structure is as follows first we're

192
00:07:02,460 --> 00:07:06,180
going to sample our lwe secrets

193
00:07:06,180 --> 00:07:08,520
and just compute an lwe instance with

194
00:07:08,520 --> 00:07:10,380
respect to each of these public matrices

195
00:07:10,380 --> 00:07:12,720
and again for ease of exposition I'm

196
00:07:12,720 --> 00:07:14,220
going to use this quickly underline to

197
00:07:14,220 --> 00:07:16,139
denote the error so I won't have error

198
00:07:16,139 --> 00:07:17,819
terms floating around hopefully this

199
00:07:17,819 --> 00:07:19,620
will simplify the description

200
00:07:19,620 --> 00:07:21,660
and I'm going to do the same thing with

201
00:07:21,660 --> 00:07:24,660
the second set of matrices B1 and B2

202
00:07:24,660 --> 00:07:27,000
except instead of publishing them uh

203
00:07:27,000 --> 00:07:28,860
directly I'm going to sum those two

204
00:07:28,860 --> 00:07:30,720
together and I'm also going to do the

205
00:07:30,720 --> 00:07:32,759
same thing for p so I'm going to sample

206
00:07:32,759 --> 00:07:34,680
lwe secret and just compute lwe

207
00:07:34,680 --> 00:07:36,599
instances with respect to all of these

208
00:07:36,599 --> 00:07:38,759
components why I do this will hopefully

209
00:07:38,759 --> 00:07:40,199
become clear when I talk about

210
00:07:40,199 --> 00:07:41,940
correctness

211
00:07:41,940 --> 00:07:44,400
so let's see how we can decrypt so here

212
00:07:44,400 --> 00:07:46,979
we have our user user has a has a secret

213
00:07:46,979 --> 00:07:48,840
key associated with authorities one and

214
00:07:48,840 --> 00:07:51,840
two we can view this vector k the

215
00:07:51,840 --> 00:07:54,479
speaker key as a way to recode the RW

216
00:07:54,479 --> 00:07:56,940
instance with respect to a to an lwe

217
00:07:56,940 --> 00:08:00,120
instance with respect to B plus p

218
00:08:00,120 --> 00:08:01,800
so that's exactly what we're going to do

219
00:08:01,800 --> 00:08:03,479
first we're going to take the part of

220
00:08:03,479 --> 00:08:05,400
the ciphertext multiplied by the key and

221
00:08:05,400 --> 00:08:07,259
then we get an lwe instance with respect

222
00:08:07,259 --> 00:08:10,560
to BR plus p now notice that what the

223
00:08:10,560 --> 00:08:12,599
user can do is it can take the other

224
00:08:12,599 --> 00:08:14,400
components of the ciphertext combine

225
00:08:14,400 --> 00:08:16,979
them together and subtract and recover

226
00:08:16,979 --> 00:08:19,500
an encoded version of the message

227
00:08:19,500 --> 00:08:21,960
okay so this is how we can argue

228
00:08:21,960 --> 00:08:23,639
correctness of this construction what's

229
00:08:23,639 --> 00:08:24,960
more interesting is the security

230
00:08:24,960 --> 00:08:27,479
analysis so let's see what uh what we

231
00:08:27,479 --> 00:08:29,160
want to show so we have a collection of

232
00:08:29,160 --> 00:08:31,379
public Keys we have a set of we have a

233
00:08:31,379 --> 00:08:33,120
sniper text that's associated with some

234
00:08:33,120 --> 00:08:35,520
policy here the policy is Authority one

235
00:08:35,520 --> 00:08:37,620
and Authority two

236
00:08:37,620 --> 00:08:40,559
and the strategy in arguing Security in

237
00:08:40,559 --> 00:08:42,779
many lattice based Ade schemes is we're

238
00:08:42,779 --> 00:08:43,919
basically going to argue that this

239
00:08:43,919 --> 00:08:46,380
ciphertext here is pseudo is

240
00:08:46,380 --> 00:08:48,600
pseudorandom provided at none of the

241
00:08:48,600 --> 00:08:50,399
keys here actually satisfy the

242
00:08:50,399 --> 00:08:52,140
decryption policy

243
00:08:52,140 --> 00:08:53,820
uh so this is easy to do with the

244
00:08:53,820 --> 00:08:55,680
adversary has no secret fees then this

245
00:08:55,680 --> 00:08:58,500
is just pseudo-random by train lwe but

246
00:08:58,500 --> 00:09:01,380
if we also have to stimulate teeth for

247
00:09:01,380 --> 00:09:03,779
certain attributes that do not satisfy

248
00:09:03,779 --> 00:09:05,700
the policy Things become more difficult

249
00:09:05,700 --> 00:09:08,160
so in order to stimulate these Keys we

250
00:09:08,160 --> 00:09:09,959
typically need a trapdoor for a but then

251
00:09:09,959 --> 00:09:12,120
we kind of feel the lwe with respect to

252
00:09:12,120 --> 00:09:12,980
a

253
00:09:12,980 --> 00:09:16,380
so previously uh Dr komodoxy and Waters

254
00:09:16,380 --> 00:09:18,180
what they show is they Model H as a

255
00:09:18,180 --> 00:09:19,980
random Oracle and relying on a limited

256
00:09:19,980 --> 00:09:22,140
software sampling Lemma to argue

257
00:09:22,140 --> 00:09:23,880
security here uh we can do something

258
00:09:23,880 --> 00:09:25,620
similar in our work we have a more

259
00:09:25,620 --> 00:09:27,779
modular approach that allows us to base

260
00:09:27,779 --> 00:09:30,060
uh it on lwe with a polynomial

261
00:09:30,060 --> 00:09:32,100
approximation Factor rather than and

262
00:09:32,100 --> 00:09:33,360
they go back to the Natural one I won't

263
00:09:33,360 --> 00:09:34,980
delve into the details because this is

264
00:09:34,980 --> 00:09:37,279
what talking what I want to say today

265
00:09:37,279 --> 00:09:40,920
uh what I do want to tell you is uh how

266
00:09:40,920 --> 00:09:43,019
we can use the evasive lwe assumption to

267
00:09:43,019 --> 00:09:45,000
prove security of this Construction in a

268
00:09:45,000 --> 00:09:46,740
plane model without modeling H as a

269
00:09:46,740 --> 00:09:49,200
random Oracle so the evasive lwe

270
00:09:49,200 --> 00:09:51,660
assumption recently introduced by we and

271
00:09:51,660 --> 00:09:54,660
zabri basically said the following if

272
00:09:54,660 --> 00:09:56,940
lwe holds with respect to a matrix a

273
00:09:56,940 --> 00:10:00,480
concatenated with the Matrix P then LW

274
00:10:00,480 --> 00:10:03,240
E4 with respect to the Matrix a even if

275
00:10:03,240 --> 00:10:05,100
you're given a short pre-image of P

276
00:10:05,100 --> 00:10:07,320
under a so essentially what this is

277
00:10:07,320 --> 00:10:09,779
saying is that if I give you this a

278
00:10:09,779 --> 00:10:11,399
inverse of P thing the only thing that

279
00:10:11,399 --> 00:10:12,720
you can really do with it is you can

280
00:10:12,720 --> 00:10:14,940
multiply with a and if you do that then

281
00:10:14,940 --> 00:10:16,080
you're going to get something that still

282
00:10:16,080 --> 00:10:17,700
looks pseudo-random so this is the

283
00:10:17,700 --> 00:10:20,339
evasive lwe assumption and let's see why

284
00:10:20,339 --> 00:10:23,100
this is helpful for us well if you look

285
00:10:23,100 --> 00:10:24,540
at the things in the security reduction

286
00:10:24,540 --> 00:10:26,519
that we have trouble simulating it was

287
00:10:26,519 --> 00:10:28,440
these three images well the event that

288
00:10:28,440 --> 00:10:30,360
lwe assumption says well I will just

289
00:10:30,360 --> 00:10:31,680
give you these three images for free

290
00:10:31,680 --> 00:10:34,140
provided that you can reason about the

291
00:10:34,140 --> 00:10:35,820
distribution were multiplied by the

292
00:10:35,820 --> 00:10:37,680
secret s so instead of reasoning about

293
00:10:37,680 --> 00:10:39,839
how the sample preamps short pre-images

294
00:10:39,839 --> 00:10:41,640
I now only have this reason about

295
00:10:41,640 --> 00:10:43,500
pseudorandinism of a particular

296
00:10:43,500 --> 00:10:44,700
distribution

297
00:10:44,700 --> 00:10:47,640
uh so it's now suffices to show that s

298
00:10:47,640 --> 00:10:50,519
times uh this P plus b r curve is

299
00:10:50,519 --> 00:10:52,680
pseudo-random so the question then is

300
00:10:52,680 --> 00:10:54,720
how do we design a hash function H to

301
00:10:54,720 --> 00:10:57,240
ensure this property and here the main

302
00:10:57,240 --> 00:10:59,160
idea is quite simple uh we're going to

303
00:10:59,160 --> 00:11:01,740
Define H to basically compute a subset

304
00:11:01,740 --> 00:11:04,320
product a public node Norm matrices why

305
00:11:04,320 --> 00:11:06,300
do we do this well a very classic and

306
00:11:06,300 --> 00:11:07,740
beautiful result by phone Louis

307
00:11:07,740 --> 00:11:09,839
Montgomery and ragunathan show that this

308
00:11:09,839 --> 00:11:12,060
is actually a pseudorandom function and

309
00:11:12,060 --> 00:11:14,940
so uh by the blmr analysis we can show

310
00:11:14,940 --> 00:11:17,339
that the Evita lwe pre-condition holds

311
00:11:17,339 --> 00:11:19,500
and so now under the evasive lwe ass

312
00:11:19,500 --> 00:11:21,180
solution we can stimulate the secret

313
00:11:21,180 --> 00:11:24,120
heat in our security reduction

314
00:11:24,120 --> 00:11:26,519
uh so to just to summarize in this work

315
00:11:26,519 --> 00:11:28,260
we show how to construct multi-authority

316
00:11:28,260 --> 00:11:31,740
Abe for uh asset conjunction policies we

317
00:11:31,740 --> 00:11:34,980
can prove security under lwe plain lwe

318
00:11:34,980 --> 00:11:37,680
with a polynomial modulus uh if the H is

319
00:11:37,680 --> 00:11:40,740
modeled as a random Oracle And if H is

320
00:11:40,740 --> 00:11:42,540
not a random Oracle but the product of

321
00:11:42,540 --> 00:11:44,160
short matrices we can prove security

322
00:11:44,160 --> 00:11:46,140
under the stronger evasive lwe

323
00:11:46,140 --> 00:11:48,300
assumption but in a plane model so let

324
00:11:48,300 --> 00:11:50,579
me leave you with two open questions uh

325
00:11:50,579 --> 00:11:52,079
one is can we try and improve security

326
00:11:52,079 --> 00:11:54,300
of this construction just from plane lwe

327
00:11:54,300 --> 00:11:56,640
without relying on random oracles and

328
00:11:56,640 --> 00:11:59,399
without relying on evasive lwe and more

329
00:11:59,399 --> 00:12:01,140
generally can we try and get lattice

330
00:12:01,140 --> 00:12:03,420
based multi-authority Abe for policy

331
00:12:03,420 --> 00:12:04,860
families that are more expressive than

332
00:12:04,860 --> 00:12:06,839
conjunctions from bilinear map we can

333
00:12:06,839 --> 00:12:08,760
support General Boolean formulas but

334
00:12:08,760 --> 00:12:09,959
here we only know how to support

335
00:12:09,959 --> 00:12:11,940
conjunctions at the moment and with that

336
00:12:11,940 --> 00:12:13,800
I'll conclude thank you

337
00:12:13,800 --> 00:12:16,800
foreign

338
00:12:19,820 --> 00:12:23,160
for the wonderful talk so are there any

339
00:12:23,160 --> 00:12:26,060
questions in the audience

340
00:12:28,260 --> 00:12:30,540
um so is the security equivalent to

341
00:12:30,540 --> 00:12:33,360
evasive lwe you can can you show that's

342
00:12:33,360 --> 00:12:36,180
necessary uh no that's a great question

343
00:12:36,180 --> 00:12:38,160
but uh we don't have any implication in

344
00:12:38,160 --> 00:12:40,260
Reverse Direction so it is possible that

345
00:12:40,260 --> 00:12:41,579
this construction you can actually prove

346
00:12:41,579 --> 00:12:43,680
secure from LW this does not imply a big

347
00:12:43,680 --> 00:12:45,180
without WWE I'll leave that part I

348
00:12:45,180 --> 00:12:48,120
understand okay thanks

349
00:12:48,120 --> 00:12:50,519
more questions

350
00:12:50,519 --> 00:12:52,320
if not maybe meanwhile I can ask a

351
00:12:52,320 --> 00:12:54,000
question so from my understanding for

352
00:12:54,000 --> 00:12:56,519
bilinear maps uh it's really important

353
00:12:56,519 --> 00:12:58,980
to have to model HSN random Oracle so

354
00:12:58,980 --> 00:13:00,420
have you guys given a thought that maybe

355
00:13:00,420 --> 00:13:02,579
you can modify the construction slightly

356
00:13:02,579 --> 00:13:04,920
wrinkle my linear maps and prove those

357
00:13:04,920 --> 00:13:06,899
to be secure without using random

358
00:13:06,899 --> 00:13:09,180
articles but using these evasive lwe

359
00:13:09,180 --> 00:13:10,800
type hash functions yeah that's a great

360
00:13:10,800 --> 00:13:12,420
question whether we can try and combine

361
00:13:12,420 --> 00:13:13,920
The Best of Both Worlds so using

362
00:13:13,920 --> 00:13:15,779
bilinear math plus lattices to give us

363
00:13:15,779 --> 00:13:17,220
instructions so I don't have any

364
00:13:17,220 --> 00:13:18,540
thoughts on that at the moment so it's

365
00:13:18,540 --> 00:13:19,620
not something we've considered but I

366
00:13:19,620 --> 00:13:21,060
think it's a fascinating direction to

367
00:13:21,060 --> 00:13:24,000
explore great any other questions if not

368
00:13:24,000 --> 00:13:26,100
then we'll thank David again all right

369
00:13:26,100 --> 00:13:28,579
thank you David

370
00:13:29,880 --> 00:13:33,260
let's get to the next talk

371
00:14:17,279 --> 00:14:19,880
foreign

372
00:14:27,139 --> 00:14:29,880
so the next talk is about lower bounds

373
00:14:29,880 --> 00:14:31,980
for the number of decryption updates in

374
00:14:31,980 --> 00:14:34,200
registration based encryption and the

375
00:14:34,200 --> 00:14:36,959
talk is by a way is going to give the

376
00:14:36,959 --> 00:14:39,180
talk and the paper is by Muhammad and uh

377
00:14:39,180 --> 00:14:41,959
Ahmed Raza

378
00:14:42,000 --> 00:14:45,300
okay so hello everyone my name is Wei

379
00:14:45,300 --> 00:14:47,339
welcome to my talk today I'm going to

380
00:14:47,339 --> 00:14:49,079
talk about lower bounds for the number

381
00:14:49,079 --> 00:14:51,180
of decryption updates in registration

382
00:14:51,180 --> 00:14:53,040
based encryption

383
00:14:53,040 --> 00:14:54,959
um this is Joint work with my advisor

384
00:14:54,959 --> 00:14:57,440
Professor muhammadi who is sitting there

385
00:14:57,440 --> 00:15:02,100
and I'm rahimi who is a

386
00:15:02,100 --> 00:15:04,079
of his city in Europe

387
00:15:04,079 --> 00:15:06,240
sorry

388
00:15:06,240 --> 00:15:08,279
so our Story begins with the classic

389
00:15:08,279 --> 00:15:10,560
public key encryption we all know how

390
00:15:10,560 --> 00:15:12,839
public encryption Works

391
00:15:12,839 --> 00:15:14,519
um suppose Bob wants to include the

392
00:15:14,519 --> 00:15:16,980
message and send it to Alice and this

393
00:15:16,980 --> 00:15:19,139
will generate two keys a public key and

394
00:15:19,139 --> 00:15:21,899
secret key then Bob will use additives

395
00:15:21,899 --> 00:15:24,300
publicly to encrypt the message and send

396
00:15:24,300 --> 00:15:26,579
it to edits and this will then be able

397
00:15:26,579 --> 00:15:29,160
to use this her secret key to decrypt

398
00:15:29,160 --> 00:15:30,060
message

399
00:15:30,060 --> 00:15:32,940
now suppose Bob wants to talk to other

400
00:15:32,940 --> 00:15:34,740
people include messages to all the

401
00:15:34,740 --> 00:15:36,660
people as well it will do the same thing

402
00:15:36,660 --> 00:15:39,180
but with different people's public keys

403
00:15:39,180 --> 00:15:40,560
for example greetings quiz things

404
00:15:40,560 --> 00:15:42,720
publicly to include message to quisting

405
00:15:42,720 --> 00:15:44,880
and students publicly to input message

406
00:15:44,880 --> 00:15:48,120
to sue them as we can already observe on

407
00:15:48,120 --> 00:15:50,579
this picture a problem about public key

408
00:15:50,579 --> 00:15:53,279
encryption is that every time Bob wants

409
00:15:53,279 --> 00:15:55,380
to encrypt the message for a new person

410
00:15:55,380 --> 00:15:57,959
he needs to get another public key and

411
00:15:57,959 --> 00:16:01,380
this is just too many public keys so in

412
00:16:01,380 --> 00:16:03,779
order to solve this problem a new

413
00:16:03,779 --> 00:16:05,639
primitive called identity based

414
00:16:05,639 --> 00:16:07,680
encryption was proposed in

415
00:16:07,680 --> 00:16:09,480
identity-based encryption there is a

416
00:16:09,480 --> 00:16:12,300
third party called Central Authority who

417
00:16:12,300 --> 00:16:14,940
generates a master's security and a

418
00:16:14,940 --> 00:16:18,120
public parameter now suppose Bob wants

419
00:16:18,120 --> 00:16:20,639
to include message to Alice we will get

420
00:16:20,639 --> 00:16:23,040
the public parameter it will then use

421
00:16:23,040 --> 00:16:24,899
this public parameter together with

422
00:16:24,899 --> 00:16:27,480
Alice's name to encrypt the message and

423
00:16:27,480 --> 00:16:30,360
send to edits Alice will send her name

424
00:16:30,360 --> 00:16:32,519
to the central Authority who will use

425
00:16:32,519 --> 00:16:35,100
this Master's secret key to generate a

426
00:16:35,100 --> 00:16:37,620
decryption key for Alice Alice will then

427
00:16:37,620 --> 00:16:39,480
be able to use his decryption key to

428
00:16:39,480 --> 00:16:41,459
decode any messages encrypted to her

429
00:16:41,459 --> 00:16:44,880
using this public parameter now suppose

430
00:16:44,880 --> 00:16:47,880
Bob wants to send encrypt messages for

431
00:16:47,880 --> 00:16:49,440
other people as well

432
00:16:49,440 --> 00:16:52,079
he will use this same public parameter

433
00:16:52,079 --> 00:16:54,120
here with different names to include

434
00:16:54,120 --> 00:16:56,699
messages for different people

435
00:16:56,699 --> 00:16:59,220
and the advantage of identity based

436
00:16:59,220 --> 00:17:01,800
encryption is obvious as

437
00:17:01,800 --> 00:17:04,140
there is only one compact public

438
00:17:04,140 --> 00:17:06,959
parameter for all users instead of end

439
00:17:06,959 --> 00:17:09,419
users sorry and public key is for in

440
00:17:09,419 --> 00:17:10,859
users

441
00:17:10,859 --> 00:17:12,900
um however there is a problem in

442
00:17:12,900 --> 00:17:14,819
identity based encryption

443
00:17:14,819 --> 00:17:17,880
which is known as the ks group problem

444
00:17:17,880 --> 00:17:19,980
as we can see from this picture the

445
00:17:19,980 --> 00:17:22,079
central Authority who has the master

446
00:17:22,079 --> 00:17:25,079
Secret Key by definition can generate

447
00:17:25,079 --> 00:17:27,660
decryption keys for every user which

448
00:17:27,660 --> 00:17:29,880
give him the power to decrypt everything

449
00:17:29,880 --> 00:17:32,760
and this is just bad

450
00:17:32,760 --> 00:17:36,480
so in order to address this problem a

451
00:17:36,480 --> 00:17:38,460
new primitive called registration based

452
00:17:38,460 --> 00:17:41,640
encryption was proposed and roughly

453
00:17:41,640 --> 00:17:43,620
speaking in registration-based

454
00:17:43,620 --> 00:17:46,140
encryption every user will generate

455
00:17:46,140 --> 00:17:48,900
their own public key and secret key they

456
00:17:48,900 --> 00:17:50,940
will then send the public key together

457
00:17:50,940 --> 00:17:54,179
with their identity to this third-party

458
00:17:54,179 --> 00:17:57,419
calculator who will then publish a

459
00:17:57,419 --> 00:17:59,400
compact public parameter which will

460
00:17:59,400 --> 00:18:01,500
function in a similar way as the public

461
00:18:01,500 --> 00:18:05,340
parameter in identity-based encryption

462
00:18:05,340 --> 00:18:08,220
um note that in rbe every identity will

463
00:18:08,220 --> 00:18:10,320
generate their own secret key which

464
00:18:10,320 --> 00:18:11,900
makes the third party calculator

465
00:18:11,900 --> 00:18:14,880
basically a public calling algorithm

466
00:18:14,880 --> 00:18:18,960
that has no secret state okay so more

467
00:18:18,960 --> 00:18:22,260
formally in rbe users will come one by

468
00:18:22,260 --> 00:18:26,039
one and after each user after each user

469
00:18:26,039 --> 00:18:28,260
is registered the public parameter will

470
00:18:28,260 --> 00:18:32,340
be updated so for example let id1 be the

471
00:18:32,340 --> 00:18:35,160
first user after id1 is registered

472
00:18:35,160 --> 00:18:37,140
public parameter one will be generated

473
00:18:37,140 --> 00:18:39,480
and then more users will come and be

474
00:18:39,480 --> 00:18:42,960
registered then user IDI will be

475
00:18:42,960 --> 00:18:45,419
registered and the public parameter I

476
00:18:45,419 --> 00:18:47,640
minus 1 will be updated to public

477
00:18:47,640 --> 00:18:51,780
parameter I now suppose a user has

478
00:18:51,780 --> 00:18:54,480
public parameter K which is basically

479
00:18:54,480 --> 00:18:57,179
the public parameter generated after K

480
00:18:57,179 --> 00:19:00,299
users have been registered to be able to

481
00:19:00,299 --> 00:19:03,059
use this topic parameter K to encrypt

482
00:19:03,059 --> 00:19:07,080
messages for any identity that have has

483
00:19:07,080 --> 00:19:09,660
been registered until this moment so

484
00:19:09,660 --> 00:19:12,480
basically any IDI where I is smaller

485
00:19:12,480 --> 00:19:16,140
than or equal to K and then this IDI

486
00:19:16,140 --> 00:19:18,780
should be able to use the secret key to

487
00:19:18,780 --> 00:19:21,559
decrypt the message

488
00:19:21,600 --> 00:19:23,880
however one time two times the

489
00:19:23,880 --> 00:19:26,039
decryption algorithm might actually fail

490
00:19:26,039 --> 00:19:28,260
and when it does fail

491
00:19:28,260 --> 00:19:31,200
rbe allows its identity to get a

492
00:19:31,200 --> 00:19:33,720
decryption update from calculator which

493
00:19:33,720 --> 00:19:35,880
will help her decrypt the message

494
00:19:35,880 --> 00:19:37,140
successfully

495
00:19:37,140 --> 00:19:40,559
this is not ideal so it is important for

496
00:19:40,559 --> 00:19:42,419
us to know how many times this will

497
00:19:42,419 --> 00:19:43,740
happen

498
00:19:43,740 --> 00:19:46,620
now before I turn to other properties of

499
00:19:46,620 --> 00:19:49,679
rbe let me just briefly mention that the

500
00:19:49,679 --> 00:19:52,799
security of rbe is defined in a similar

501
00:19:52,799 --> 00:19:56,220
way as that of IDE that is no colluding

502
00:19:56,220 --> 00:19:59,580
parties can decrypt others messages

503
00:19:59,580 --> 00:20:02,880
okay now there are some efficiency and

504
00:20:02,880 --> 00:20:05,700
compactness requirements of rbe that are

505
00:20:05,700 --> 00:20:07,020
important to us

506
00:20:07,020 --> 00:20:09,419
that aimed the number of registered

507
00:20:09,419 --> 00:20:12,240
identities we need two properties to

508
00:20:12,240 --> 00:20:15,120
hold first we want the public parameter

509
00:20:15,120 --> 00:20:17,460
to be compact because if we allow the

510
00:20:17,460 --> 00:20:19,799
public parameter to be long then there

511
00:20:19,799 --> 00:20:21,660
is this trivial construction where you

512
00:20:21,660 --> 00:20:23,760
just concatenate the public use of every

513
00:20:23,760 --> 00:20:26,580
user and more formally we want the

514
00:20:26,580 --> 00:20:28,580
length of the public parameter to be

515
00:20:28,580 --> 00:20:30,780
polynomialismic again

516
00:20:30,780 --> 00:20:33,720
secondly we want the updates to be rare

517
00:20:33,720 --> 00:20:36,299
because if we have too many updates then

518
00:20:36,299 --> 00:20:38,580
this RPS game will be two cumbersome to

519
00:20:38,580 --> 00:20:41,520
use more formally we want the number of

520
00:20:41,520 --> 00:20:44,640
updates for any user to build order of

521
00:20:44,640 --> 00:20:45,600
login

522
00:20:45,600 --> 00:20:47,820
note that here we are ignoring the

523
00:20:47,820 --> 00:20:49,919
security parameter even though

524
00:20:49,919 --> 00:20:52,160
everything can depend on it polynomially

525
00:20:52,160 --> 00:20:54,539
instead we are focused on how things

526
00:20:54,539 --> 00:20:56,520
depend on the number of registered

527
00:20:56,520 --> 00:20:57,900
identities

528
00:20:57,900 --> 00:21:00,360
there are also some other requirements

529
00:21:00,360 --> 00:21:01,860
of rbe

530
00:21:01,860 --> 00:21:04,860
uh we want the updates to be compact we

531
00:21:04,860 --> 00:21:07,500
want the update generation algorithm and

532
00:21:07,500 --> 00:21:09,240
the registration algorithm to be

533
00:21:09,240 --> 00:21:12,240
efficient but for the sake of this talk

534
00:21:12,240 --> 00:21:14,340
these two can be ignored

535
00:21:14,340 --> 00:21:16,799
okay so the main question of this talk

536
00:21:16,799 --> 00:21:18,960
is about the number of decryption

537
00:21:18,960 --> 00:21:20,960
updates in rbe

538
00:21:20,960 --> 00:21:23,940
how many updates do we actually need our

539
00:21:23,940 --> 00:21:25,440
login description updates really

540
00:21:25,440 --> 00:21:26,640
necessary

541
00:21:26,640 --> 00:21:29,039
note that in all knowing constructions

542
00:21:29,039 --> 00:21:31,559
of rbe logging updates are actually

543
00:21:31,559 --> 00:21:33,059
required

544
00:21:33,059 --> 00:21:36,780
so our result is that we have found an

545
00:21:36,780 --> 00:21:38,520
almost tight lower Bound for the number

546
00:21:38,520 --> 00:21:41,220
of decryption updates in rbe most

547
00:21:41,220 --> 00:21:44,220
formally we prove that log n by log log

548
00:21:44,220 --> 00:21:47,159
in updates are needed in rbe

549
00:21:47,159 --> 00:21:50,760
however there is a cache here we need to

550
00:21:50,760 --> 00:21:53,220
assume that updates arrive at fixed

551
00:21:53,220 --> 00:21:56,940
times so for example assume exactly one

552
00:21:56,940 --> 00:21:59,940
identity is registered every day then

553
00:21:59,940 --> 00:22:02,340
after this identity has been registered

554
00:22:02,340 --> 00:22:06,000
it knows exactly at what days in the

555
00:22:06,000 --> 00:22:08,880
future an update is needed

556
00:22:08,880 --> 00:22:11,760
and however this property is Satisfied

557
00:22:11,760 --> 00:22:14,100
by all knowing constructions which makes

558
00:22:14,100 --> 00:22:16,320
it a natural and reasonable assumption

559
00:22:16,320 --> 00:22:17,400
to make

560
00:22:17,400 --> 00:22:20,460
and more generally we prove that if the

561
00:22:20,460 --> 00:22:22,860
number of identities is larger than or

562
00:22:22,860 --> 00:22:25,860
equal to this binomial coefficient L

563
00:22:25,860 --> 00:22:28,799
plus b choose D plus 1 and there are at

564
00:22:28,799 --> 00:22:32,460
most D updates for any user then the

565
00:22:32,460 --> 00:22:34,980
length of the public parameter has to be

566
00:22:34,980 --> 00:22:37,740
Omega FL one can check by calculation

567
00:22:37,740 --> 00:22:39,840
that our lower bound actually follows

568
00:22:39,840 --> 00:22:42,360
from this result

569
00:22:42,360 --> 00:22:43,580
foreign

570
00:22:43,580 --> 00:22:46,860
also I like to remark that this without

571
00:22:46,860 --> 00:22:49,080
actually holds even if some parties get

572
00:22:49,080 --> 00:22:51,900
many updates as long as sufficiently

573
00:22:51,900 --> 00:22:54,840
many parties get rare updates we want to

574
00:22:54,840 --> 00:22:56,700
thank the reviewers for asking about the

575
00:22:56,700 --> 00:22:58,380
extension without during the review

576
00:22:58,380 --> 00:23:00,980
possess

577
00:23:02,159 --> 00:23:04,620
okay now let me talk about some ideas

578
00:23:04,620 --> 00:23:06,720
using a crew

579
00:23:06,720 --> 00:23:09,419
so the highlight of steps of the proof

580
00:23:09,419 --> 00:23:12,240
are the following first we Define a DAC

581
00:23:12,240 --> 00:23:15,120
based on sorry Define attack based on

582
00:23:15,120 --> 00:23:16,860
the times of updates

583
00:23:16,860 --> 00:23:19,500
then we prove there exists a structure

584
00:23:19,500 --> 00:23:22,679
in such tags and finally we show how to

585
00:23:22,679 --> 00:23:24,000
use this structure to attack

586
00:23:24,000 --> 00:23:26,400
successfully using some basic

587
00:23:26,400 --> 00:23:29,100
information theoretical tools

588
00:23:29,100 --> 00:23:32,760
so step one we Define a dag based on

589
00:23:32,760 --> 00:23:34,919
times of updates since there are end

590
00:23:34,919 --> 00:23:37,760
users we will Define a dag on N vertices

591
00:23:37,760 --> 00:23:41,039
and the ice user will be represented by

592
00:23:41,039 --> 00:23:42,840
the ice vertex

593
00:23:42,840 --> 00:23:44,820
so where you have it back on vertices

594
00:23:44,820 --> 00:23:47,640
one two three if you're in and there is

595
00:23:47,640 --> 00:23:51,000
an edge from I to J if and only if the

596
00:23:51,000 --> 00:23:54,480
ice user needs an update after the JS

597
00:23:54,480 --> 00:23:57,419
user has been registered note that we

598
00:23:57,419 --> 00:23:59,400
know this information because we assume

599
00:23:59,400 --> 00:24:02,580
that we know when users need an update

600
00:24:02,580 --> 00:24:05,580
also note that since our user can only

601
00:24:05,580 --> 00:24:08,039
get an update after it has been

602
00:24:08,039 --> 00:24:10,320
registered so the edges can only go from

603
00:24:10,320 --> 00:24:12,320
left to right

604
00:24:12,320 --> 00:24:15,539
okay so step two we Define a useful

605
00:24:15,539 --> 00:24:17,700
structure called skipping sequence in

606
00:24:17,700 --> 00:24:19,679
such Stacks where the edges are from

607
00:24:19,679 --> 00:24:22,260
left to right we call a sequence of

608
00:24:22,260 --> 00:24:25,559
vertices as one as Q to SL a skipping

609
00:24:25,559 --> 00:24:29,220
sequence if for any outgoing Edge as I T

610
00:24:29,220 --> 00:24:32,400
either T is close enough which means it

611
00:24:32,400 --> 00:24:34,500
is smaller than the next vertex in the

612
00:24:34,500 --> 00:24:37,860
sequence or it is long as it is falling

613
00:24:37,860 --> 00:24:40,799
down namely it is larger than the last

614
00:24:40,799 --> 00:24:43,500
vertex of the sequence

615
00:24:43,500 --> 00:24:46,200
now that we have a skipping sequence we

616
00:24:46,200 --> 00:24:49,620
can remove all these long edges and then

617
00:24:49,620 --> 00:24:52,260
divide and then divide this vertices

618
00:24:52,260 --> 00:24:55,740
into blocks and we can show we can

619
00:24:55,740 --> 00:24:58,200
observe that vertical edges from the

620
00:24:58,200 --> 00:25:01,020
first vertex of every block is contained

621
00:25:01,020 --> 00:25:02,460
in this block

622
00:25:02,460 --> 00:25:07,500
and then we proved that if G has uh L

623
00:25:07,500 --> 00:25:09,720
plus d issues D plus one vertices and

624
00:25:09,720 --> 00:25:12,539
out degrees are smaller than D then

625
00:25:12,539 --> 00:25:15,299
there is a skipping sequence of lens l

626
00:25:15,299 --> 00:25:18,240
and the proof is based on reduction on D

627
00:25:18,240 --> 00:25:21,179
which is really written in the paper so

628
00:25:21,179 --> 00:25:22,679
the last step we show how to use the

629
00:25:22,679 --> 00:25:24,779
skipping sequence to attack we first

630
00:25:24,779 --> 00:25:27,720
divide the vertices into blocks and

631
00:25:27,720 --> 00:25:29,580
recall that every vertex represents a

632
00:25:29,580 --> 00:25:32,340
user then we call block good if all the

633
00:25:32,340 --> 00:25:34,559
keys of users in this block are almost

634
00:25:34,559 --> 00:25:36,840
dependent of the public parameter SL

635
00:25:36,840 --> 00:25:39,600
which is generated after user SL has

636
00:25:39,600 --> 00:25:41,400
been registered

637
00:25:41,400 --> 00:25:43,500
and we can use information theoretical

638
00:25:43,500 --> 00:25:46,140
argument to show that if L is larger

639
00:25:46,140 --> 00:25:47,820
than the length of the public parameter

640
00:25:47,820 --> 00:25:50,700
SL then a good block always this which

641
00:25:50,700 --> 00:25:52,860
means that if we resemble fetch keys for

642
00:25:52,860 --> 00:25:55,440
identities in this good block and put it

643
00:25:55,440 --> 00:25:58,080
next to the public parameter SL the

644
00:25:58,080 --> 00:26:00,240
distribution will be statistically close

645
00:26:00,240 --> 00:26:03,299
to the real distribution where you

646
00:26:03,299 --> 00:26:05,880
sample everything jointly

647
00:26:05,880 --> 00:26:09,000
and finally assume block I is good we

648
00:26:09,000 --> 00:26:12,120
can attack on identity s i which is the

649
00:26:12,120 --> 00:26:14,580
first vertex inside its block how do we

650
00:26:14,580 --> 00:26:16,980
do that we first sample the keys for all

651
00:26:16,980 --> 00:26:19,559
identities inside the school block

652
00:26:19,559 --> 00:26:22,799
then since we know that updates for this

653
00:26:22,799 --> 00:26:25,440
user SI will be generated by case inside

654
00:26:25,440 --> 00:26:27,480
this block we can then generate all

655
00:26:27,480 --> 00:26:30,240
decryption candidates for this user SI

656
00:26:30,240 --> 00:26:33,059
and finally we'll be able to decrease

657
00:26:33,059 --> 00:26:35,700
the challenge encrypted for SI using

658
00:26:35,700 --> 00:26:38,100
public parameter SL with probability

659
00:26:38,100 --> 00:26:40,799
close to that using real keys and real

660
00:26:40,799 --> 00:26:42,960
update

661
00:26:42,960 --> 00:26:45,360
so inclusion we have found an almost

662
00:26:45,360 --> 00:26:47,100
tight lower bounds for the number of

663
00:26:47,100 --> 00:26:50,159
decryption updates in rbe and the key

664
00:26:50,159 --> 00:26:53,279
idea is the characterization of a

665
00:26:53,279 --> 00:26:55,200
structure called skipping sequence index

666
00:26:55,200 --> 00:26:57,360
and there is the main question to be

667
00:26:57,360 --> 00:26:59,220
answered can we actually break this

668
00:26:59,220 --> 00:27:01,799
barrier using Dynamic update times that

669
00:27:01,799 --> 00:27:03,900
actually depend on the value of the

670
00:27:03,900 --> 00:27:05,820
registered public keys

671
00:27:05,820 --> 00:27:08,820
thanks

672
00:27:11,820 --> 00:27:13,320
yeah

673
00:27:13,320 --> 00:27:15,299
thank you very much for the wonderful

674
00:27:15,299 --> 00:27:18,379
talk so any questions

675
00:27:26,100 --> 00:27:28,500
so I assumes that you said Logan has

676
00:27:28,500 --> 00:27:30,179
died in existing constructions you have

677
00:27:30,179 --> 00:27:32,460
login assuming it is tight I'm just

678
00:27:32,460 --> 00:27:34,380
curious what do the graphs this update

679
00:27:34,380 --> 00:27:35,700
graphs look like in existing

680
00:27:35,700 --> 00:27:37,559
constructions I mean this dependency

681
00:27:37,559 --> 00:27:39,779
graph from I to J I mean that's like

682
00:27:39,779 --> 00:27:42,720
really simple graphs yeah I'm sorry um

683
00:27:42,720 --> 00:27:44,700
well I'm just curious well I assume this

684
00:27:44,700 --> 00:27:46,559
Logan is tight right the slogans that

685
00:27:46,559 --> 00:27:49,559
you proved uh it is tight right so the

686
00:27:49,559 --> 00:27:51,000
existing constructions achieve Logan

687
00:27:51,000 --> 00:27:53,700
right yeah so what are the graphs uh I

688
00:27:53,700 --> 00:27:55,260
just out of curiosity I'm just curious

689
00:27:55,260 --> 00:27:57,840
what are the graphs that achieve Logan

690
00:27:57,840 --> 00:27:59,880
and for which your thing is tight this

691
00:27:59,880 --> 00:28:01,380
update graphs

692
00:28:01,380 --> 00:28:03,480
how does it look like

693
00:28:03,480 --> 00:28:05,520
you know this i2j it's like when do I

694
00:28:05,520 --> 00:28:08,120
have to update

695
00:28:17,580 --> 00:28:19,200
oh so it's not a fixed graph I would

696
00:28:19,200 --> 00:28:20,580
imagine it's like simple graph you're

697
00:28:20,580 --> 00:28:21,720
saying it depends on some kind of

698
00:28:21,720 --> 00:28:23,039
Miracle tree

699
00:28:23,039 --> 00:28:26,419
I don't look nice

700
00:28:31,559 --> 00:28:33,179
just

701
00:28:33,179 --> 00:28:33,960
um

702
00:28:33,960 --> 00:28:35,779
yeah

703
00:28:35,779 --> 00:28:39,360
all right any good questions

704
00:28:39,360 --> 00:28:41,580
so let me just a quick question uh the

705
00:28:41,580 --> 00:28:43,559
way you guys are assuming things what

706
00:28:43,559 --> 00:28:46,260
about uh if updates come in batches I

707
00:28:46,260 --> 00:28:48,240
mean can has them be modeled or can that

708
00:28:48,240 --> 00:28:50,159
be modeled as like a separate problem uh

709
00:28:50,159 --> 00:28:52,620
I think that's a separate problem so I

710
00:28:52,620 --> 00:28:53,940
mean basically that means that size of

711
00:28:53,940 --> 00:28:55,320
each of the nodes that changes it's not

712
00:28:55,320 --> 00:28:56,880
just one user it'll do multiple users

713
00:28:56,880 --> 00:28:59,580
yeah so even then it is possible that

714
00:28:59,580 --> 00:29:00,659
there might be a different lower bound

715
00:29:00,659 --> 00:29:02,100
depending upon what batch size you're

716
00:29:02,100 --> 00:29:04,320
working with

717
00:29:04,320 --> 00:29:08,960
actually no what is it

718
00:29:08,960 --> 00:29:12,179
yeah yeah I'm saying it's like maybe the

719
00:29:12,179 --> 00:29:15,380
number of parties that you want to

720
00:29:19,020 --> 00:29:21,240
so the same normal hold okay the batch

721
00:29:21,240 --> 00:29:22,620
size

722
00:29:22,620 --> 00:29:24,539
no no I'm saying that there will be

723
00:29:24,539 --> 00:29:26,399
multiple updates but each update can

724
00:29:26,399 --> 00:29:28,559
have a different batch size like D1 the

725
00:29:28,559 --> 00:29:30,480
first number of times the D2 and so on

726
00:29:30,480 --> 00:29:32,760
like typically you grow an array if you

727
00:29:32,760 --> 00:29:34,620
want have like a fixed size you sort of

728
00:29:34,620 --> 00:29:35,940
just double its size each time you want

729
00:29:35,940 --> 00:29:37,620
more populated with more entry something

730
00:29:37,620 --> 00:29:39,600
like that so how does different batch

731
00:29:39,600 --> 00:29:41,399
sizes and different updates might affect

732
00:29:41,399 --> 00:29:43,580
the total number of updates potentially

733
00:29:43,580 --> 00:29:48,260
okay okay thanks again for the question

734
00:29:51,659 --> 00:29:54,260
foreign

735
00:30:22,559 --> 00:30:24,799
foreign

736
00:30:40,820 --> 00:30:43,320
with incompressible Master secret key

737
00:30:43,320 --> 00:30:45,059
and small identity secrets and the talk

738
00:30:45,059 --> 00:30:46,380
is by Shruti

739
00:30:46,380 --> 00:30:49,080
for the introduction uh so this is Joint

740
00:30:49,080 --> 00:30:52,580
work with the nicodotnings

741
00:30:53,640 --> 00:30:55,740
um the motivation for this work comes

742
00:30:55,740 --> 00:30:57,299
from the bigger area of the E

743
00:30:57,299 --> 00:30:59,700
cryptography uh which is in itself is

744
00:30:59,700 --> 00:31:01,440
motivated through this class of attacks

745
00:31:01,440 --> 00:31:03,120
called exploitation attack so what are

746
00:31:03,120 --> 00:31:06,059
these uh it comes from the fact that uh

747
00:31:06,059 --> 00:31:07,500
you may have like several security

748
00:31:07,500 --> 00:31:09,480
stored on your computer system if you

749
00:31:09,480 --> 00:31:12,840
use for your uh crypto Graphics thing uh

750
00:31:12,840 --> 00:31:14,700
and they are prone to some form of

751
00:31:14,700 --> 00:31:16,440
exfiltration by an external adversity

752
00:31:16,440 --> 00:31:18,539
which leads to essentially leaking out

753
00:31:18,539 --> 00:31:20,460
the entirety you lose all the security

754
00:31:20,460 --> 00:31:24,539
to its attacks uh and this in itself is

755
00:31:24,539 --> 00:31:26,279
the general thread which is recognized

756
00:31:26,279 --> 00:31:28,740
as advanced process right uh it could be

757
00:31:28,740 --> 00:31:30,779
that some malware is launched by an

758
00:31:30,779 --> 00:31:32,159
adversity it could be running in the

759
00:31:32,159 --> 00:31:34,200
background in your computer and that may

760
00:31:34,200 --> 00:31:36,419
lead to essentially him on a prolonged

761
00:31:36,419 --> 00:31:37,860
basis getting information from your

762
00:31:37,860 --> 00:31:40,260
system that leads leaks to the uh League

763
00:31:40,260 --> 00:31:41,640
office

764
00:31:41,640 --> 00:31:44,100
so a solution proposed for this through

765
00:31:44,100 --> 00:31:45,720
this literature of weekly cryptography

766
00:31:45,720 --> 00:31:47,940
which is to make the secret intake okay

767
00:31:47,940 --> 00:31:49,980
so let's say it's a terabyte long then

768
00:31:49,980 --> 00:31:51,659
The Roastery can no longer get the whole

769
00:31:51,659 --> 00:31:53,880
CPT just because of how restricted it is

770
00:31:53,880 --> 00:31:56,100
and with time this is not possible

771
00:31:56,100 --> 00:32:00,659
so and indeed at RFA 2013 like uh uh

772
00:32:00,659 --> 00:32:03,360
shami did mention you know uh of the

773
00:32:03,360 --> 00:32:05,039
whole flock basically what he what he

774
00:32:05,039 --> 00:32:07,260
wants to say is I don't want to have

775
00:32:07,260 --> 00:32:09,539
tiny secret Keys uh because the apts are

776
00:32:09,539 --> 00:32:11,640
in general like well well known threats

777
00:32:11,640 --> 00:32:13,980
and so I want my file to be a terabyte

778
00:32:13,980 --> 00:32:15,659
wrong which cannot be now easy to see

779
00:32:15,659 --> 00:32:17,580
mixed filtration that's the model for

780
00:32:17,580 --> 00:32:20,100
the wiki system and this is what led to

781
00:32:20,100 --> 00:32:22,740
the advance of like several crypto

782
00:32:22,740 --> 00:32:23,820
systems that were built in this

783
00:32:23,820 --> 00:32:26,100
literature uh and the model that's used

784
00:32:26,100 --> 00:32:28,740
to actually capture this is known as the

785
00:32:28,740 --> 00:32:31,260
well studied bounded retrieval model so

786
00:32:31,260 --> 00:32:33,299
now the adversary is not getting the

787
00:32:33,299 --> 00:32:35,880
whole tricky but instead getting some

788
00:32:35,880 --> 00:32:38,279
part of the security model and that is

789
00:32:38,279 --> 00:32:40,559
the boundary decision model so it's able

790
00:32:40,559 --> 00:32:43,559
to let's say even get 99 of secret keys

791
00:32:43,559 --> 00:32:45,360
uh and that we modeled through the

792
00:32:45,360 --> 00:32:47,880
leakage but in order to do so the second

793
00:32:47,880 --> 00:32:49,740
key feature these crypto systems must

794
00:32:49,740 --> 00:32:52,080
retain is efficiency so now I've blown

795
00:32:52,080 --> 00:32:54,360
up the key uh but of course I don't want

796
00:32:54,360 --> 00:32:56,940
my other uh algorithms that use the key

797
00:32:56,940 --> 00:32:58,500
to be affected by it so you want to

798
00:32:58,500 --> 00:33:00,240
retain the efficiency of those

799
00:33:00,240 --> 00:33:02,340
algorithms and that's precisely what

800
00:33:02,340 --> 00:33:04,320
this is and that's ensured by uh

801
00:33:04,320 --> 00:33:05,880
basically making them locally access

802
00:33:05,880 --> 00:33:07,980
some parts of the team and not not use

803
00:33:07,980 --> 00:33:09,299
the whole piece

804
00:33:09,299 --> 00:33:11,880
so these are the two key features uh

805
00:33:11,880 --> 00:33:13,679
several Primitives have been built in

806
00:33:13,679 --> 00:33:15,059
this picky system

807
00:33:15,059 --> 00:33:16,740
um and that includes symmetrical

808
00:33:16,740 --> 00:33:18,480
encryption publicly encryption and

809
00:33:18,480 --> 00:33:21,019
authentically agreement

810
00:33:21,019 --> 00:33:23,580
uh coming to the model that we are

811
00:33:23,580 --> 00:33:25,019
interested in today would be the public

812
00:33:25,019 --> 00:33:27,120
encryption Center that we're going to

813
00:33:27,120 --> 00:33:29,700
look at so particularly

814
00:33:29,700 --> 00:33:31,500
um just like regular public encryption

815
00:33:31,500 --> 00:33:34,380
you have for the key or CPP

816
00:33:34,380 --> 00:33:35,700
um and the public key in itself is

817
00:33:35,700 --> 00:33:38,279
usually small so this is something uh we

818
00:33:38,279 --> 00:33:39,539
don't need to worry about but the secret

819
00:33:39,539 --> 00:33:42,059
key now is going to be the key that's

820
00:33:42,059 --> 00:33:43,919
prone to the excitation so the red

821
00:33:43,919 --> 00:33:45,600
components Mark basically the leakage

822
00:33:45,600 --> 00:33:47,039
that you allow on it

823
00:33:47,039 --> 00:33:50,340
and uh as the second key feature we

824
00:33:50,340 --> 00:33:51,840
wanted really recall was the efficiency

825
00:33:51,840 --> 00:33:53,760
right so if you look at the algorithms

826
00:33:53,760 --> 00:33:55,620
here the encryption algorithm itself is

827
00:33:55,620 --> 00:33:57,960
okay it just uses the public key so this

828
00:33:57,960 --> 00:33:59,940
is going to be efficient but now the

829
00:33:59,940 --> 00:34:01,559
decryption algorithm leads to access the

830
00:34:01,559 --> 00:34:03,779
security and it cannot just plain access

831
00:34:03,779 --> 00:34:05,820
the entire security that would make it

832
00:34:05,820 --> 00:34:08,760
uh inefficient so what we do is

833
00:34:08,760 --> 00:34:11,520
essentially allow some local ciphertext

834
00:34:11,520 --> 00:34:13,800
dependent queries so these are the black

835
00:34:13,800 --> 00:34:15,540
chunks are basically the parts that the

836
00:34:15,540 --> 00:34:16,739
decryption are

837
00:34:16,739 --> 00:34:19,739
and uh this would be small number of

838
00:34:19,739 --> 00:34:21,659
query so essentially you would ensure

839
00:34:21,659 --> 00:34:22,918
that the decryption algorithm is

840
00:34:22,918 --> 00:34:24,780
efficient

841
00:34:24,780 --> 00:34:26,760
okay and note these are ciphertext

842
00:34:26,760 --> 00:34:28,980
dependencies

843
00:34:28,980 --> 00:34:31,020
okay and the security in this model

844
00:34:31,020 --> 00:34:32,460
would just say that the semantic

845
00:34:32,460 --> 00:34:34,020
security should hold for the crash type

846
00:34:34,020 --> 00:34:36,540
attack that are generated generated post

847
00:34:36,540 --> 00:34:39,359
arbitrary leakage on the sk1 why is this

848
00:34:39,359 --> 00:34:41,940
like uh if you don't assume truly for

849
00:34:41,940 --> 00:34:43,918
freshly say ciphertext that you can get

850
00:34:43,918 --> 00:34:46,139
because the older ciphertext you can

851
00:34:46,139 --> 00:34:48,300
always get a leakage of a single bit

852
00:34:48,300 --> 00:34:50,159
that helps you distinguish so so the

853
00:34:50,159 --> 00:34:51,780
oldest architect you can't guarantee in

854
00:34:51,780 --> 00:34:54,359
security if you allow leakage prone uh

855
00:34:54,359 --> 00:34:58,920
post post uh yeah giving packet text

856
00:34:58,920 --> 00:35:01,020
but there are certain cabinets that

857
00:35:01,020 --> 00:35:03,420
naturally this model has and uh let's

858
00:35:03,420 --> 00:35:05,820
look at them so in these days like

859
00:35:05,820 --> 00:35:07,440
nobody throws secretly in one system

860
00:35:07,440 --> 00:35:10,800
there are multiple devices a user has uh

861
00:35:10,800 --> 00:35:12,960
you could have an iPad a smart watch and

862
00:35:12,960 --> 00:35:14,400
let's say I want to use this for

863
00:35:14,400 --> 00:35:16,440
decrypting emails and if it have

864
00:35:16,440 --> 00:35:18,599
encrypted so you would have to store

865
00:35:18,599 --> 00:35:21,119
your secret key essentially on all the

866
00:35:21,119 --> 00:35:23,820
devices because uh you don't know in

867
00:35:23,820 --> 00:35:25,740
advance which part of the secret is

868
00:35:25,740 --> 00:35:28,980
accessed by the decryption the recall it

869
00:35:28,980 --> 00:35:31,020
made ciphertext dependent access to the

870
00:35:31,020 --> 00:35:33,240
PPT so you need to store them all and

871
00:35:33,240 --> 00:35:35,339
this naturally leads to two issues the

872
00:35:35,339 --> 00:35:37,440
first one is of course the natural thing

873
00:35:37,440 --> 00:35:39,660
that you see is to lead to wastage of

874
00:35:39,660 --> 00:35:41,280
limited storage on smaller mobile

875
00:35:41,280 --> 00:35:42,300
devices

876
00:35:42,300 --> 00:35:44,760
but the second issue that it leads to is

877
00:35:44,760 --> 00:35:47,280
even more uh

878
00:35:47,280 --> 00:35:49,500
like a bigger problem which is it leads

879
00:35:49,500 --> 00:35:51,660
to additional susceptibilities due to

880
00:35:51,660 --> 00:35:53,700
leakage uh that happens through this

881
00:35:53,700 --> 00:35:56,160
replication so particularly one of my

882
00:35:56,160 --> 00:35:59,099
mobile devices lost you essentially lose

883
00:35:59,099 --> 00:36:00,660
the entire security and there's no

884
00:36:00,660 --> 00:36:03,300
Refugee from it so these are like uh

885
00:36:03,300 --> 00:36:06,000
major issues of this model that you can

886
00:36:06,000 --> 00:36:08,180
see

887
00:36:09,079 --> 00:36:11,520
proposal to resolve this issue is uh

888
00:36:11,520 --> 00:36:14,400
adapt to the ID setup for this

889
00:36:14,400 --> 00:36:17,160
um by which I mean that now instead of

890
00:36:17,160 --> 00:36:19,020
using just the publicly secret key

891
00:36:19,020 --> 00:36:21,780
Paradigm of the PK literature I bring in

892
00:36:21,780 --> 00:36:24,240
my usual standard IB setup where you

893
00:36:24,240 --> 00:36:26,099
have this public parameter which is

894
00:36:26,099 --> 00:36:28,140
short and the master secret key of the

895
00:36:28,140 --> 00:36:31,140
IV would be would be the large uh key

896
00:36:31,140 --> 00:36:32,880
that is prone to exfiltration so this is

897
00:36:32,880 --> 00:36:35,280
where I allow my leakage

898
00:36:35,280 --> 00:36:37,560
um the encryption as before only relies

899
00:36:37,560 --> 00:36:40,380
on a public identity it relies on this

900
00:36:40,380 --> 00:36:42,599
public parameter and and message them so

901
00:36:42,599 --> 00:36:45,359
this is going to be a system and uh

902
00:36:45,359 --> 00:36:46,800
we have to worry about now the

903
00:36:46,800 --> 00:36:48,540
decryption right so instead of in the

904
00:36:48,540 --> 00:36:50,280
public key setup it was using the whole

905
00:36:50,280 --> 00:36:53,220
big secret team but now naturally the IB

906
00:36:53,220 --> 00:36:55,980
setup provides something uh in the form

907
00:36:55,980 --> 00:36:58,320
of these ID specific activities so you

908
00:36:58,320 --> 00:37:00,720
would have some specific Securities that

909
00:37:00,720 --> 00:37:02,640
are generated according to your ID let's

910
00:37:02,640 --> 00:37:04,920
say for our example of email my

911
00:37:04,920 --> 00:37:08,160
identities are dates so the if you keep

912
00:37:08,160 --> 00:37:10,320
the identities at States these would be

913
00:37:10,320 --> 00:37:12,960
my essentially ID specific secret tools

914
00:37:12,960 --> 00:37:15,839
that are generated and recall with our

915
00:37:15,839 --> 00:37:18,359
goals we wanted them to be the short

916
00:37:18,359 --> 00:37:20,940
small ethml right we don't want to blow

917
00:37:20,940 --> 00:37:23,579
them up so this results essentially at

918
00:37:23,579 --> 00:37:25,859
least in terms of the model uh both the

919
00:37:25,859 --> 00:37:27,900
issues that I spoke of like the each of

920
00:37:27,900 --> 00:37:29,579
the device would not have to store the

921
00:37:29,579 --> 00:37:32,640
entire big ticket and secondly like if

922
00:37:32,640 --> 00:37:35,460
you if one of the devices you lose out

923
00:37:35,460 --> 00:37:37,619
you're essentially using a specific date

924
00:37:37,619 --> 00:37:40,920
so you can always refresh security uh

925
00:37:40,920 --> 00:37:43,140
for potentially the next thing possible

926
00:37:43,140 --> 00:37:46,200
so that comes to that you get to in the

927
00:37:46,200 --> 00:37:48,119
security model but essentially as a

928
00:37:48,119 --> 00:37:49,980
model this this resolves the two issues

929
00:37:49,980 --> 00:37:52,140
that I spoke of

930
00:37:52,140 --> 00:37:54,180
so there are certain challenges when

931
00:37:54,180 --> 00:37:57,119
defining security uh in this model and

932
00:37:57,119 --> 00:37:59,099
uh before heading into that let's recall

933
00:37:59,099 --> 00:38:01,200
for a quick recap for everyone to be on

934
00:38:01,200 --> 00:38:04,440
same page the standard ID security so uh

935
00:38:04,440 --> 00:38:06,180
remember here the adversity gets

936
00:38:06,180 --> 00:38:08,940
essentially the public key the public

937
00:38:08,940 --> 00:38:11,940
parameter gets some ID specific secret

938
00:38:11,940 --> 00:38:14,339
keys of its joint which it can query at

939
00:38:14,339 --> 00:38:17,339
any instance and in addition it's for a

940
00:38:17,339 --> 00:38:19,020
challenge identity of its Choice which

941
00:38:19,020 --> 00:38:20,700
is different from all the identities

942
00:38:20,700 --> 00:38:22,920
that it created this evening Oracle it

943
00:38:22,920 --> 00:38:24,780
would get the ciphertext c-star which is

944
00:38:24,780 --> 00:38:27,180
which basically hides the message so

945
00:38:27,180 --> 00:38:29,339
that's the security guarantee and

946
00:38:29,339 --> 00:38:30,780
depending on whether the challenge

947
00:38:30,780 --> 00:38:33,060
identity is given before seeing the

948
00:38:33,060 --> 00:38:34,920
public parameter or after you Define

949
00:38:34,920 --> 00:38:36,900
selective Auto security

950
00:38:36,900 --> 00:38:39,420
and uh the definition that we will look

951
00:38:39,420 --> 00:38:41,460
at in our setup would be a selective

952
00:38:41,460 --> 00:38:44,940
security measure not the full security

953
00:38:44,940 --> 00:38:48,960
okay so in our setup now Recall now

954
00:38:48,960 --> 00:38:51,540
you're allowing this big Master CPT and

955
00:38:51,540 --> 00:38:53,820
you're giving out leakage on it right so

956
00:38:53,820 --> 00:38:56,760
the adversary gets this leakage in

957
00:38:56,760 --> 00:38:58,920
addition uh so throughout this I have I

958
00:38:58,920 --> 00:39:00,599
would not list you would also get to

959
00:39:00,599 --> 00:39:03,780
create an oracle uh but to begin with it

960
00:39:03,780 --> 00:39:06,060
gets this leakage folder right and then

961
00:39:06,060 --> 00:39:08,160
in addition it would get these uh

962
00:39:08,160 --> 00:39:10,680
additional secret identities that are uh

963
00:39:10,680 --> 00:39:13,500
it can query from The Cure articles but

964
00:39:13,500 --> 00:39:14,880
the first problem that you can notice

965
00:39:14,880 --> 00:39:17,640
one of the key challenge that arises is

966
00:39:17,640 --> 00:39:20,220
this leakage is unrestricted right it's

967
00:39:20,220 --> 00:39:22,680
just bounded in terms of bits but it can

968
00:39:22,680 --> 00:39:24,920
ask any part of the secret key and

969
00:39:24,920 --> 00:39:27,960
potentially even like I said 99 of the

970
00:39:27,960 --> 00:39:30,119
teeth would be leaked so in particular

971
00:39:30,119 --> 00:39:31,980
this could also contain information

972
00:39:31,980 --> 00:39:35,180
about the challenge ID

973
00:39:35,300 --> 00:39:37,859
you cannot hope for any security of the

974
00:39:37,859 --> 00:39:40,020
challenge type of text so this is like a

975
00:39:40,020 --> 00:39:41,940
immediate issue if you consider the

976
00:39:41,940 --> 00:39:44,579
leakage uh I mean in a crude form if you

977
00:39:44,579 --> 00:39:46,200
look at it this would be a problem in

978
00:39:46,200 --> 00:39:49,079
defining security and uh prior leakage

979
00:39:49,079 --> 00:39:51,839
within it IBC that have defined security

980
00:39:51,839 --> 00:39:55,020
Notions consider actually large ID

981
00:39:55,020 --> 00:39:57,300
specific security to handle and allow

982
00:39:57,300 --> 00:39:59,700
leakage on them uh and in addition we'll

983
00:39:59,700 --> 00:40:01,619
assume either no leakage on the master

984
00:40:01,619 --> 00:40:04,440
secret or some scheme assumes like the

985
00:40:04,440 --> 00:40:06,720
Mass Effect is itself large and use a

986
00:40:06,720 --> 00:40:09,060
lot of communicate on it but our goal

987
00:40:09,060 --> 00:40:12,060
recall is to retain the feature that the

988
00:40:12,060 --> 00:40:14,220
ID specific Securities are short and SML

989
00:40:14,220 --> 00:40:16,680
so even if you lose out on them you want

990
00:40:16,680 --> 00:40:19,140
to be able to refresh security so

991
00:40:19,140 --> 00:40:21,319
foreign

992
00:40:23,040 --> 00:40:25,920
towards defining security uh what do we

993
00:40:25,920 --> 00:40:28,980
observe here so essentially if you note

994
00:40:28,980 --> 00:40:30,780
here let's say the leakage that is

995
00:40:30,780 --> 00:40:32,280
allowed is from Elven

996
00:40:32,280 --> 00:40:35,040
and uh each of this IDs that's exceeded

997
00:40:35,040 --> 00:40:37,260
keys on Lambda bit then if you note here

998
00:40:37,260 --> 00:40:39,660
through this leakage an adversity can

999
00:40:39,660 --> 00:40:41,940
essentially get up to L over Lambda

1000
00:40:41,940 --> 00:40:43,740
which is Theta L of the secret identity

1001
00:40:43,740 --> 00:40:45,720
right if I truly calculate these many

1002
00:40:45,720 --> 00:40:47,760
IDs it can definitely get through the

1003
00:40:47,760 --> 00:40:50,339
leakage uh what I would want or the

1004
00:40:50,339 --> 00:40:51,839
intuition for the definition that we

1005
00:40:51,839 --> 00:40:54,119
would adapt is that essentially this is

1006
00:40:54,119 --> 00:40:56,099
the best or information that the

1007
00:40:56,099 --> 00:40:58,020
advocacy could get so the adversary

1008
00:40:58,020 --> 00:41:00,119
should not get any more information than

1009
00:41:00,119 --> 00:41:01,560
what we would get through this trivial

1010
00:41:01,560 --> 00:41:03,000
exploitation attack because this is

1011
00:41:03,000 --> 00:41:05,160
simply possible like if I just query my

1012
00:41:05,160 --> 00:41:07,020
leakage function I can query these many

1013
00:41:07,020 --> 00:41:09,240
secret identities and get them and this

1014
00:41:09,240 --> 00:41:10,740
is the best that you want to say that

1015
00:41:10,740 --> 00:41:12,119
Lucy can do

1016
00:41:12,119 --> 00:41:14,700
so in particular I would want my

1017
00:41:14,700 --> 00:41:17,520
definition to say that given a LBT

1018
00:41:17,520 --> 00:41:19,560
leakage you want the adversity to not

1019
00:41:19,560 --> 00:41:21,359
break security for

1020
00:41:21,359 --> 00:41:24,180
um uh at least L plus one ID

1021
00:41:24,180 --> 00:41:25,320
okay

1022
00:41:25,320 --> 00:41:28,380
and uh just uh for a complete mistakes

1023
00:41:28,380 --> 00:41:30,960
uh mention the security model but what

1024
00:41:30,960 --> 00:41:33,480
it essentially captures is as before now

1025
00:41:33,480 --> 00:41:35,520
now you have like in the IB model you

1026
00:41:35,520 --> 00:41:38,520
get the public parameter it also gets

1027
00:41:38,520 --> 00:41:40,560
the median Oracle as not listed as a

1028
00:41:40,560 --> 00:41:43,560
single definition here uh and it

1029
00:41:43,560 --> 00:41:45,240
mentions let's say alphabet one album

1030
00:41:45,240 --> 00:41:46,500
right for which you want to Define

1031
00:41:46,500 --> 00:41:48,839
security recall you want to say if you

1032
00:41:48,839 --> 00:41:51,180
get help with linkage uh you want like

1033
00:41:51,180 --> 00:41:53,820
security for L plus L plus one ID

1034
00:41:53,820 --> 00:41:55,680
correct one more security you want in

1035
00:41:55,680 --> 00:41:57,480
concept so that's what the game captures

1036
00:41:57,480 --> 00:41:59,099
let's say you define the experiment for

1037
00:41:59,099 --> 00:42:01,200
each identity which is like the IB

1038
00:42:01,200 --> 00:42:04,140
experiment uh what my definition would

1039
00:42:04,140 --> 00:42:06,960
capture is that uh the probability that

1040
00:42:06,960 --> 00:42:09,000
for all identities you break the

1041
00:42:09,000 --> 00:42:11,280
security is negligible

1042
00:42:11,280 --> 00:42:13,079
so there would at least be one identity

1043
00:42:13,079 --> 00:42:14,820
for which you retain the security

1044
00:42:14,820 --> 00:42:16,619
that's the selective security motion

1045
00:42:16,619 --> 00:42:19,079
that we adapt in the stakehold

1046
00:42:19,079 --> 00:42:21,359
so I won't have time to go into the Full

1047
00:42:21,359 --> 00:42:23,400
Construction it is the kind of complex

1048
00:42:23,400 --> 00:42:25,380
but I can give you kind of a high level

1049
00:42:25,380 --> 00:42:27,599
picture of what we do the goal was to

1050
00:42:27,599 --> 00:42:30,119
start with uh something that's known and

1051
00:42:30,119 --> 00:42:31,980
adapted in the details in public

1052
00:42:31,980 --> 00:42:34,380
encryption literature which is of this

1053
00:42:34,380 --> 00:42:37,440
encrypt twice forget one key Paradigm uh

1054
00:42:37,440 --> 00:42:39,540
which is used in the uh literature but

1055
00:42:39,540 --> 00:42:41,099
that cannot be directly unfortunately

1056
00:42:41,099 --> 00:42:43,859
adapted to the ID setup so we had to

1057
00:42:43,859 --> 00:42:46,560
build a new primitive and Define it uh

1058
00:42:46,560 --> 00:42:48,300
which is a big key pseudo entity

1059
00:42:48,300 --> 00:42:50,460
function which is our key building block

1060
00:42:50,460 --> 00:42:53,160
and on top of it we rely on techniques

1061
00:42:53,160 --> 00:42:55,500
from prior works on little encryption

1062
00:42:55,500 --> 00:42:58,319
and reusable to run everything and this

1063
00:42:58,319 --> 00:43:00,900
gives us our big eib with the large with

1064
00:43:00,900 --> 00:43:03,900
the large from the parameter actually uh

1065
00:43:03,900 --> 00:43:06,119
but we want that to be short and that we

1066
00:43:06,119 --> 00:43:07,800
can use tricks from electronic code

1067
00:43:07,800 --> 00:43:09,780
illustrator and essentially get our

1068
00:43:09,780 --> 00:43:11,339
triangles

1069
00:43:11,339 --> 00:43:12,839
okay so this is essentially the roadmap

1070
00:43:12,839 --> 00:43:14,520
for our construction and the security

1071
00:43:14,520 --> 00:43:16,619
relies on hardness of standard

1072
00:43:16,619 --> 00:43:18,720
assumption on groups with value your

1073
00:43:18,720 --> 00:43:20,160
pairing

1074
00:43:20,160 --> 00:43:22,020
so I would like to conclude with some

1075
00:43:22,020 --> 00:43:24,359
open problems uh that that are obvious

1076
00:43:24,359 --> 00:43:26,819
so first our construction is non-black

1077
00:43:26,819 --> 00:43:28,619
box unfortunately in the underlying

1078
00:43:28,619 --> 00:43:30,960
Primitives so a natural question is to

1079
00:43:30,960 --> 00:43:32,819
make uh essentially this a black box

1080
00:43:32,819 --> 00:43:35,400
construction in the online term it is a

1081
00:43:35,400 --> 00:43:38,460
little bit uh to make it efficient uh

1082
00:43:38,460 --> 00:43:39,660
and the second question which is

1083
00:43:39,660 --> 00:43:41,819
interesting is comes from a recent work

1084
00:43:41,819 --> 00:43:44,339
on incompressible encoding which is to

1085
00:43:44,339 --> 00:43:46,319
make these Keys actually useful we have

1086
00:43:46,319 --> 00:43:47,640
these big keys they are essentially

1087
00:43:47,640 --> 00:43:49,020
there in the system and not really

1088
00:43:49,020 --> 00:43:51,420
useful so this work essentially shows

1089
00:43:51,420 --> 00:43:53,640
how to make them catalytic so if you

1090
00:43:53,640 --> 00:43:55,980
adapting them to this work would be an

1091
00:43:55,980 --> 00:43:57,599
interesting open problem

1092
00:43:57,599 --> 00:44:00,800
oh thank you

1093
00:44:04,380 --> 00:44:06,599
so first of all thank you for the

1094
00:44:06,599 --> 00:44:08,160
wonderful dog and there's a question of

1095
00:44:08,160 --> 00:44:11,240
Muhammad already sir

1096
00:44:15,540 --> 00:44:18,599
so how tights are your results because

1097
00:44:18,599 --> 00:44:21,599
you say that if we if the adversary gets

1098
00:44:21,599 --> 00:44:23,520
L bits of leakage he cannot break

1099
00:44:23,520 --> 00:44:26,099
security for L plus one but L plus one

1100
00:44:26,099 --> 00:44:29,520
is not very tight given that uh we we

1101
00:44:29,520 --> 00:44:32,640
might hope to be able to argue it for L

1102
00:44:32,640 --> 00:44:35,940
over Lambda plus one so uh can you uh

1103
00:44:35,940 --> 00:44:38,359
fill this Gap

1104
00:44:38,359 --> 00:44:40,980
that's right like it's not tied to that

1105
00:44:40,980 --> 00:44:43,920
extent uh okay we prove it for else was

1106
00:44:43,920 --> 00:44:45,839
one uh our team is able to achieve but

1107
00:44:45,839 --> 00:44:48,859
you're right like it's not right

1108
00:44:49,800 --> 00:44:52,700
okay any more questions

1109
00:44:55,980 --> 00:44:57,720
yeah I'm just curious syntactical it

1110
00:44:57,720 --> 00:44:59,880
probably will not work but uh curious if

1111
00:44:59,880 --> 00:45:01,560
you can see that that um so there is

1112
00:45:01,560 --> 00:45:03,060
like earlier work on what is called

1113
00:45:03,060 --> 00:45:05,640
insulated crypto which

1114
00:45:05,640 --> 00:45:09,480
kind of is similar except uh there is no

1115
00:45:09,480 --> 00:45:13,079
I guess additional leakage allowed on uh

1116
00:45:13,079 --> 00:45:14,819
um on I guess a master keyboard specific

1117
00:45:14,819 --> 00:45:16,740
scheme to use kind of polynomials and

1118
00:45:16,740 --> 00:45:19,740
things like Shamir secret sharing and

1119
00:45:19,740 --> 00:45:22,380
now recently those Sameer secret sharing

1120
00:45:22,380 --> 00:45:24,540
scheme session to some extent to be

1121
00:45:24,540 --> 00:45:26,760
leakage resilient have you tried an

1122
00:45:26,760 --> 00:45:30,000
approached of adapting insulated schemes

1123
00:45:30,000 --> 00:45:32,339
to your setting or things kind of don't

1124
00:45:32,339 --> 00:45:35,760
work out I think we haven't explicitly

1125
00:45:35,760 --> 00:45:37,980
thought it through but uh I don't know

1126
00:45:37,980 --> 00:45:39,599
actually maybe I can discuss the model

1127
00:45:39,599 --> 00:45:42,000
that you're offline uh to figure out if

1128
00:45:42,000 --> 00:45:44,160
it fits into our work yeah sounds good

1129
00:45:44,160 --> 00:45:45,900
thanks

1130
00:45:45,900 --> 00:45:47,760
so I also have a very quick question so

1131
00:45:47,760 --> 00:45:50,400
have people also studied like block wise

1132
00:45:50,400 --> 00:45:52,440
infiltration attacks infiltration attack

1133
00:45:52,440 --> 00:45:53,819
as I understand it's just you can

1134
00:45:53,819 --> 00:45:55,560
infiltrate any part of it but maybe like

1135
00:45:55,560 --> 00:45:57,960
a clockwise either you infiltrate a

1136
00:45:57,960 --> 00:45:59,400
complete block or you don't it's like

1137
00:45:59,400 --> 00:46:01,140
divide the entire secret key memory into

1138
00:46:01,140 --> 00:46:04,098
blocks people

1139
00:46:04,339 --> 00:46:07,619
yeah I haven't seen any such a model for

1140
00:46:07,619 --> 00:46:09,060
expectation yourself okay no problem

1141
00:46:09,060 --> 00:46:10,740
thank you so much yeah and thanks David

1142
00:46:10,740 --> 00:46:13,020
the way and Shruti for the wonderful

1143
00:46:13,020 --> 00:46:16,280
talks all right see you guys

1144
00:46:16,500 --> 00:46:19,099
foreign

