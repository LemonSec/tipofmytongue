1
00:00:00,000 --> 00:00:02,840
today on multi-party computation

2
00:00:02,840 --> 00:00:06,359
we have the first Speaker up uh on he's

3
00:00:06,359 --> 00:00:07,980
going to present on how to obfuscate

4
00:00:07,980 --> 00:00:11,580
mpcm inputs the speaker is uh Ian McCoy

5
00:00:11,580 --> 00:00:14,660
uh take it away

6
00:00:14,700 --> 00:00:17,699
okay great so hello everybody

7
00:00:17,699 --> 00:00:19,980
um I'm doing I'm presenting a joint work

8
00:00:19,980 --> 00:00:22,560
with my two co-authors Mike rosalik and

9
00:00:22,560 --> 00:00:25,680
Joe yushu on Port as you said how to

10
00:00:25,680 --> 00:00:27,660
obscate NPC inputs

11
00:00:27,660 --> 00:00:29,220
so let's start off with something we're

12
00:00:29,220 --> 00:00:30,660
all familiar with just two-party

13
00:00:30,660 --> 00:00:32,759
computation so in this setting we have

14
00:00:32,759 --> 00:00:34,860
two parties Alice and Bob they both have

15
00:00:34,860 --> 00:00:36,300
their own inputs and they want to

16
00:00:36,300 --> 00:00:38,160
jointly compute some function on their

17
00:00:38,160 --> 00:00:39,239
inputs

18
00:00:39,239 --> 00:00:41,399
now of course their inputs are private

19
00:00:41,399 --> 00:00:43,200
so we want each party to learn the

20
00:00:43,200 --> 00:00:44,700
minimal amounts of information about the

21
00:00:44,700 --> 00:00:47,100
others in this case Bob learns nothing

22
00:00:47,100 --> 00:00:48,960
from the interaction and Alice learns

23
00:00:48,960 --> 00:00:50,100
the output of the function on their

24
00:00:50,100 --> 00:00:51,420
joint inputs

25
00:00:51,420 --> 00:00:53,760
but of course Bob spent a lot of time

26
00:00:53,760 --> 00:00:55,440
finding his inputs and he's worried

27
00:00:55,440 --> 00:00:57,480
about server compromise he's provided

28
00:00:57,480 --> 00:00:58,680
this service but he's worried about

29
00:00:58,680 --> 00:01:00,840
somebody compromising his server and

30
00:01:00,840 --> 00:01:03,120
learning his input so instead of

31
00:01:03,120 --> 00:01:06,420
inputting his uh X directly into the

32
00:01:06,420 --> 00:01:09,000
protocol he inputs some encoding of X

33
00:01:09,000 --> 00:01:10,920
that prevents

34
00:01:10,920 --> 00:01:12,479
um the adversary from immediately

35
00:01:12,479 --> 00:01:14,700
learning his output I mean sorry his

36
00:01:14,700 --> 00:01:16,140
input

37
00:01:16,140 --> 00:01:17,939
so what does this look like for

38
00:01:17,939 --> 00:01:19,860
something simple like a point function

39
00:01:19,860 --> 00:01:22,799
well in this case the online steps are

40
00:01:22,799 --> 00:01:25,740
the exact same as we'd see in 2pc

41
00:01:25,740 --> 00:01:28,439
but on compromise the adversary only

42
00:01:28,439 --> 00:01:30,540
learns Oracle access to the function

43
00:01:30,540 --> 00:01:33,360
computed by the 2pc interaction

44
00:01:33,360 --> 00:01:37,439
and as Bob only inputs this encoding of

45
00:01:37,439 --> 00:01:40,920
his uh of X into the protocol then an

46
00:01:40,920 --> 00:01:42,960
adversary upon compromising Bob's

47
00:01:42,960 --> 00:01:45,299
service can always evaluate the online

48
00:01:45,299 --> 00:01:47,759
protocol in their head using Bob's

49
00:01:47,759 --> 00:01:51,540
encoding to gain access Oracle access to

50
00:01:51,540 --> 00:01:55,320
this equality Oracle so indeed this is

51
00:01:55,320 --> 00:01:57,720
the smallest amount of information that

52
00:01:57,720 --> 00:02:00,119
we are able to leak upon compromise of

53
00:02:00,119 --> 00:02:02,600
Bob's service

54
00:02:02,700 --> 00:02:05,579
and of course so we want it so that uh

55
00:02:05,579 --> 00:02:07,680
access to this equality Oracle can only

56
00:02:07,680 --> 00:02:11,280
be gained upon after compromising Bob's

57
00:02:11,280 --> 00:02:13,200
service

58
00:02:13,200 --> 00:02:15,360
well generally speaking

59
00:02:15,360 --> 00:02:17,819
and we what we call input obfuscated to

60
00:02:17,819 --> 00:02:19,980
PC is exactly what we've seen earlier

61
00:02:19,980 --> 00:02:21,900
except for instead of having the

62
00:02:21,900 --> 00:02:24,000
specific case of inequality Oracle upon

63
00:02:24,000 --> 00:02:26,520
compromise we have access to this

64
00:02:26,520 --> 00:02:30,480
residual Oracle F which is the function

65
00:02:30,480 --> 00:02:33,420
computed in the interaction primed on

66
00:02:33,420 --> 00:02:36,120
Bob's input

67
00:02:36,120 --> 00:02:39,180
so what we show and what we hope to show

68
00:02:39,180 --> 00:02:41,280
you today is that you can achieve this

69
00:02:41,280 --> 00:02:44,099
strong notion of input obfuscated 2pc

70
00:02:44,099 --> 00:02:47,040
for any function which is which has a

71
00:02:47,040 --> 00:02:49,560
vbb or a virtual Black Box obfuscation

72
00:02:49,560 --> 00:02:52,500
in either the random Oracle model or in

73
00:02:52,500 --> 00:02:54,840
the generic group model

74
00:02:54,840 --> 00:02:57,900
and we achieved this by replacing the

75
00:02:57,900 --> 00:03:00,599
normally in uh non-interactive Oracle

76
00:03:00,599 --> 00:03:02,700
queries to the random Oracle and to the

77
00:03:02,700 --> 00:03:04,980
generic group with an interactive

78
00:03:04,980 --> 00:03:08,459
protocol run between Alice and Bob

79
00:03:08,459 --> 00:03:11,580
so what exactly is BVB well in a

80
00:03:11,580 --> 00:03:14,580
nutshell it consists of two um two steps

81
00:03:14,580 --> 00:03:18,540
an obfuscation step where we uh compute

82
00:03:18,540 --> 00:03:20,640
some obfuscation of a function after

83
00:03:20,640 --> 00:03:22,260
interaction with with possibly

84
00:03:22,260 --> 00:03:24,120
interaction with some Oracle and an

85
00:03:24,120 --> 00:03:26,459
obfuscation step where we're able to

86
00:03:26,459 --> 00:03:29,340
evaluate an obfuscation on some

87
00:03:29,340 --> 00:03:30,840
secondary input

88
00:03:30,840 --> 00:03:33,300
and of course uh this obfuscation that

89
00:03:33,300 --> 00:03:35,760
we provide can be simulated with only

90
00:03:35,760 --> 00:03:40,399
Oracle access to the underlying function

91
00:03:40,680 --> 00:03:42,540
so back to what we were talking about

92
00:03:42,540 --> 00:03:45,299
earlier with um Point functions uh two

93
00:03:45,299 --> 00:03:48,720
PC for using BBB from a for a point

94
00:03:48,720 --> 00:03:50,640
function looks what we see here

95
00:03:50,640 --> 00:03:53,099
basically in the obfuscation step Bob

96
00:03:53,099 --> 00:03:54,659
sends his input to the random Oracle and

97
00:03:54,659 --> 00:03:57,120
gets back a handle and this handle uh

98
00:03:57,120 --> 00:03:59,400
represents the obfuscation he sends this

99
00:03:59,400 --> 00:04:01,860
obfuscation to Alice who then queries

100
00:04:01,860 --> 00:04:04,080
the random Oracle she has all of this of

101
00:04:04,080 --> 00:04:05,940
course done locally

102
00:04:05,940 --> 00:04:07,799
um and then just just string comparison

103
00:04:07,799 --> 00:04:09,599
against the handle she received from Bob

104
00:04:09,599 --> 00:04:12,659
and the handle she received from her

105
00:04:12,659 --> 00:04:14,760
random Oracle query

106
00:04:14,760 --> 00:04:18,358
now what we want is we want this random

107
00:04:18,358 --> 00:04:20,579
Oracle query that Alice makes to be

108
00:04:20,579 --> 00:04:22,860
interactive we want her forced to

109
00:04:22,860 --> 00:04:24,540
interact with Bob whenever she wants to

110
00:04:24,540 --> 00:04:27,139
make this query

111
00:04:27,360 --> 00:04:29,280
well as it turns out we know how to

112
00:04:29,280 --> 00:04:30,960
construct this already

113
00:04:30,960 --> 00:04:33,600
um directly at all show that it's

114
00:04:33,600 --> 00:04:35,100
possible to construct such an

115
00:04:35,100 --> 00:04:38,160
interactive random Oracle in a oblivious

116
00:04:38,160 --> 00:04:41,340
pseudorandom function in this case

117
00:04:41,340 --> 00:04:44,460
Bob inputs a key to the pseudorendum to

118
00:04:44,460 --> 00:04:46,620
the oblivious to random function and

119
00:04:46,620 --> 00:04:49,139
Alice only learns interactively the

120
00:04:49,139 --> 00:04:52,080
output of the query and of course

121
00:04:52,080 --> 00:04:54,600
directly at all show that this achieves

122
00:04:54,600 --> 00:04:56,220
the same programmability and

123
00:04:56,220 --> 00:04:58,320
observability properties required from a

124
00:04:58,320 --> 00:05:00,780
random Oracle

125
00:05:00,780 --> 00:05:03,600
and as we saw earlier here's our Point

126
00:05:03,600 --> 00:05:05,639
function and what we want to do is want

127
00:05:05,639 --> 00:05:07,680
we want to apply this uh intuitive

128
00:05:07,680 --> 00:05:10,680
compiler basically what we do is

129
00:05:10,680 --> 00:05:13,440
we replace the non-interactive Oracle

130
00:05:13,440 --> 00:05:15,540
queries to the random Oracle with now

131
00:05:15,540 --> 00:05:20,460
interactive queries to Bob's oprf

132
00:05:20,460 --> 00:05:23,220
and indeed this achieves uh input

133
00:05:23,220 --> 00:05:26,759
obscata 2pc as upon compromise of Bob's

134
00:05:26,759 --> 00:05:27,660
service

135
00:05:27,660 --> 00:05:30,780
uh the adversary learns Bob's input K

136
00:05:30,780 --> 00:05:34,020
which now allows them to compute the

137
00:05:34,020 --> 00:05:36,780
random the interactive random Oracle

138
00:05:36,780 --> 00:05:40,620
locally but since Bob Only Stores a vbb

139
00:05:40,620 --> 00:05:43,080
obfuscation the adversary only gains

140
00:05:43,080 --> 00:05:46,259
access to this obfuscation which is

141
00:05:46,259 --> 00:05:49,080
indeed Oracle access to this residual

142
00:05:49,080 --> 00:05:51,500
function

143
00:05:52,160 --> 00:05:55,139
so in the general case just as we saw

144
00:05:55,139 --> 00:05:57,360
with the point function we have two

145
00:05:57,360 --> 00:06:00,120
steps for a vvb obfuscation obfuscation

146
00:06:00,120 --> 00:06:01,919
interacting with the random Oracle and

147
00:06:01,919 --> 00:06:03,979
evaluation interact with random Oracle

148
00:06:03,979 --> 00:06:06,960
and all that we do is we replace the

149
00:06:06,960 --> 00:06:08,880
random Oracle queries with now

150
00:06:08,880 --> 00:06:12,240
interactive random Oracle queries AKA

151
00:06:12,240 --> 00:06:15,240
we've replaced with the oprf

152
00:06:15,240 --> 00:06:17,820
now why isn't this trivial why can't we

153
00:06:17,820 --> 00:06:21,120
just run all of these steps into PC

154
00:06:21,120 --> 00:06:23,759
well the thing is is these uh this

155
00:06:23,759 --> 00:06:26,220
obfuscation requires interaction with an

156
00:06:26,220 --> 00:06:29,160
idealized object and this idealized

157
00:06:29,160 --> 00:06:31,680
object the random Oracle is exponential

158
00:06:31,680 --> 00:06:33,419
in size and so we can't just run it

159
00:06:33,419 --> 00:06:36,660
generically inside of 2pc

160
00:06:36,660 --> 00:06:39,240
well if we can also construct such an

161
00:06:39,240 --> 00:06:40,740
interactive version of an idealized

162
00:06:40,740 --> 00:06:43,259
primitive in other models maybe we can

163
00:06:43,259 --> 00:06:45,840
achieve I O2 PC in those models such as

164
00:06:45,840 --> 00:06:48,780
the generic graded encodings model or

165
00:06:48,780 --> 00:06:50,880
the generic group model

166
00:06:50,880 --> 00:06:52,500
well as it turns out we can at least

167
00:06:52,500 --> 00:06:55,139
achieve this in the generic group model

168
00:06:55,139 --> 00:06:57,660
so we just in the last session I believe

169
00:06:57,660 --> 00:07:00,600
we learned about uh generic groups but

170
00:07:00,600 --> 00:07:03,180
just really fast uh just as a random

171
00:07:03,180 --> 00:07:04,979
Oracle is an idealized version of a hash

172
00:07:04,979 --> 00:07:07,199
function a generic group is an idealized

173
00:07:07,199 --> 00:07:10,319
version of a mathematical group

174
00:07:10,319 --> 00:07:13,560
and on top of uh multiplication since we

175
00:07:13,560 --> 00:07:16,259
consider generic groups for uniform

176
00:07:16,259 --> 00:07:18,539
encodings of the group elements we also

177
00:07:18,539 --> 00:07:21,199
provide an identity test which allows

178
00:07:21,199 --> 00:07:24,120
an interactor to learn if their given

179
00:07:24,120 --> 00:07:27,440
element is an identity element

180
00:07:27,539 --> 00:07:31,139
so what we do is we just as uh an oprf

181
00:07:31,139 --> 00:07:32,880
is an interactive version of a random

182
00:07:32,880 --> 00:07:34,680
Oracle we construct an interactive

183
00:07:34,680 --> 00:07:37,199
version of a generic group

184
00:07:37,199 --> 00:07:40,880
in this case Bob holds a key which is a

185
00:07:40,880 --> 00:07:43,620
pseudorandom permutation key along with

186
00:07:43,620 --> 00:07:47,639
a new generator in the public generic

187
00:07:47,639 --> 00:07:49,380
group since we're since we're compiling

188
00:07:49,380 --> 00:07:50,819
from a public generic group to an

189
00:07:50,819 --> 00:07:52,199
interactive protocol we still have

190
00:07:52,199 --> 00:07:54,840
access to this public generic group so

191
00:07:54,840 --> 00:07:57,060
we sample a new uh generator for that

192
00:07:57,060 --> 00:07:59,460
group and a key to a pseudorandom

193
00:07:59,460 --> 00:08:01,340
permutation

194
00:08:01,340 --> 00:08:05,520
then elements in our new private or

195
00:08:05,520 --> 00:08:09,240
interactive generic group are uh

196
00:08:09,240 --> 00:08:12,840
masked elements in the public group in

197
00:08:12,840 --> 00:08:15,000
this case this m here this G to the m is

198
00:08:15,000 --> 00:08:17,580
a multiplicative mask on the underlying

199
00:08:17,580 --> 00:08:19,940
elements and then we store the mask

200
00:08:19,940 --> 00:08:23,099
under a pseudorandom permutation keyed

201
00:08:23,099 --> 00:08:26,099
on Bob's input

202
00:08:26,099 --> 00:08:27,900
in this case multiplication although

203
00:08:27,900 --> 00:08:30,539
this looks a bit odd at first glance is

204
00:08:30,539 --> 00:08:32,880
actually exactly what we'd expect we

205
00:08:32,880 --> 00:08:35,339
multiply so the second elements being

206
00:08:35,339 --> 00:08:37,200
just group elements in the public group

207
00:08:37,200 --> 00:08:39,120
we just multiply them together and

208
00:08:39,120 --> 00:08:41,880
provide a fresh mask and then since we

209
00:08:41,880 --> 00:08:44,159
want to keep everything consistent we

210
00:08:44,159 --> 00:08:46,500
store that fresh mask under the

211
00:08:46,500 --> 00:08:48,779
pseudorandom permutation just as we did

212
00:08:48,779 --> 00:08:52,040
in the base elements

213
00:08:52,200 --> 00:08:54,899
and one thing if you guys remember we

214
00:08:54,899 --> 00:08:57,240
still want everything to be interactive

215
00:08:57,240 --> 00:08:59,880
now the second part can be computed in

216
00:08:59,880 --> 00:09:01,980
the public group so non-interactively

217
00:09:01,980 --> 00:09:04,320
everything here can be computed locally

218
00:09:04,320 --> 00:09:07,140
but in order to

219
00:09:07,140 --> 00:09:09,480
um store the new fresh mask under

220
00:09:09,480 --> 00:09:12,120
pseudonym permutation we require access

221
00:09:12,120 --> 00:09:14,820
to Bob's key and so Alice and Bob can

222
00:09:14,820 --> 00:09:15,839
run

223
00:09:15,839 --> 00:09:19,880
um we can they can run a remaster a

224
00:09:19,880 --> 00:09:21,839
re-integration of the Mask into the

225
00:09:21,839 --> 00:09:24,000
pseudo render permutation interactively

226
00:09:24,000 --> 00:09:27,480
using generic 2pc

227
00:09:27,480 --> 00:09:30,180
then finally we have to consider the

228
00:09:30,180 --> 00:09:31,620
case of the identity test since we

229
00:09:31,620 --> 00:09:35,279
provide two uh two oracles to our uh

230
00:09:35,279 --> 00:09:36,839
generic group

231
00:09:36,839 --> 00:09:38,880
and then the second one of the identity

232
00:09:38,880 --> 00:09:41,459
test this is the case where X is just

233
00:09:41,459 --> 00:09:44,459
equal to zero right so uh looking at our

234
00:09:44,459 --> 00:09:46,680
group elements we have G hat to the zero

235
00:09:46,680 --> 00:09:49,019
is the identity element and so we are

236
00:09:49,019 --> 00:09:52,140
interested in if Alice's element is just

237
00:09:52,140 --> 00:09:54,300
G to the M for whatever m is stored

238
00:09:54,300 --> 00:09:57,420
within the pseudorandom permutation

239
00:09:57,420 --> 00:10:00,600
well this equality can be done locally

240
00:10:00,600 --> 00:10:02,160
this equality check can be done locally

241
00:10:02,160 --> 00:10:05,100
and they're in the public group

242
00:10:05,100 --> 00:10:07,500
so what we do is is we have it so that

243
00:10:07,500 --> 00:10:11,160
Alice only learns a blinding a um in

244
00:10:11,160 --> 00:10:14,100
this case a exponential blinding of her

245
00:10:14,100 --> 00:10:16,500
element that she holds and she can now

246
00:10:16,500 --> 00:10:21,240
compare that to uh G to the blinded M

247
00:10:21,240 --> 00:10:23,580
that she gets from Bob this step is done

248
00:10:23,580 --> 00:10:26,459
interactively and so can't be

249
00:10:26,459 --> 00:10:29,899
um computed by Alice locally

250
00:10:30,180 --> 00:10:33,600
and as we saw earlier uh

251
00:10:33,600 --> 00:10:35,940
in the random Oracle case for a vvb

252
00:10:35,940 --> 00:10:37,860
obfuscation we just wanted to replace

253
00:10:37,860 --> 00:10:40,980
the random Oracle with a keyed and

254
00:10:40,980 --> 00:10:44,399
interactive version of the random Oracle

255
00:10:44,399 --> 00:10:46,560
well in this case we do the exact same

256
00:10:46,560 --> 00:10:49,500
thing we replace the ggm queries the

257
00:10:49,500 --> 00:10:52,620
multiplication query and these identity

258
00:10:52,620 --> 00:10:55,680
tests query with interactive versions

259
00:10:55,680 --> 00:11:01,200
inside a personalized generic group

260
00:11:01,200 --> 00:11:04,140
and indeed this allows us to achieve uh

261
00:11:04,140 --> 00:11:06,360
input obfuscated to PC in the generic

262
00:11:06,360 --> 00:11:07,920
group model

263
00:11:07,920 --> 00:11:10,200
now uh for what we what we've done in

264
00:11:10,200 --> 00:11:11,760
our paper and I really suggest reading

265
00:11:11,760 --> 00:11:13,260
it because it's quite a bit longer than

266
00:11:13,260 --> 00:11:15,420
the proceedings version

267
00:11:15,420 --> 00:11:18,779
um we introduce the idea of and study of

268
00:11:18,779 --> 00:11:21,540
input obfuscation for two PC

269
00:11:21,540 --> 00:11:24,000
we also provide a compiler from virtual

270
00:11:24,000 --> 00:11:26,040
Black Box obfuscation in the generic

271
00:11:26,040 --> 00:11:29,399
group and random Oracle models to io2pc

272
00:11:29,399 --> 00:11:30,899
in those models

273
00:11:30,899 --> 00:11:34,260
and to uh to construct the latter we

274
00:11:34,260 --> 00:11:36,060
construct an interactive version of the

275
00:11:36,060 --> 00:11:38,459
generic Group which is analogous to a an

276
00:11:38,459 --> 00:11:40,800
oblivious pseudorandom function to a

277
00:11:40,800 --> 00:11:42,180
random Oracle

278
00:11:42,180 --> 00:11:45,540
and we provide explicit iotpc protocols

279
00:11:45,540 --> 00:11:47,160
um for Point functions and for

280
00:11:47,160 --> 00:11:50,459
hyperplane membership using our compiler

281
00:11:50,459 --> 00:11:52,440
and for an interesting

282
00:11:52,440 --> 00:11:55,200
um open uh question we pose we believe

283
00:11:55,200 --> 00:11:58,079
that an interactive version of a generic

284
00:11:58,079 --> 00:12:00,839
graded encodings is possible and with

285
00:12:00,839 --> 00:12:03,060
that in hand using this uh General

286
00:12:03,060 --> 00:12:05,220
technique you would be able to construct

287
00:12:05,220 --> 00:12:12,560
io2 PC for all of P thank you

288
00:12:14,519 --> 00:12:16,740
thank you

289
00:12:16,740 --> 00:12:19,740
questions

290
00:12:22,740 --> 00:12:24,720
okay if not I just had a quick question

291
00:12:24,720 --> 00:12:27,000
while the next speaker sets up

292
00:12:27,000 --> 00:12:28,680
um I just wanted to clarify what do you

293
00:12:28,680 --> 00:12:30,540
mean by generic grading encodings like

294
00:12:30,540 --> 00:12:32,040
what would it mean here in the

295
00:12:32,040 --> 00:12:35,399
conjecture yeah so uh so inside the

296
00:12:35,399 --> 00:12:37,740
generic created using a generic graded

297
00:12:37,740 --> 00:12:40,860
encodings model uh if we're able to uh

298
00:12:40,860 --> 00:12:42,839
construct an interactive version of a

299
00:12:42,839 --> 00:12:45,839
generic graded encodings then we could

300
00:12:45,839 --> 00:12:49,139
uh for all since we have BBB for all p

301
00:12:49,139 --> 00:12:51,360
in the generic grade encodings model we

302
00:12:51,360 --> 00:12:53,160
just replace the generic rated encodings

303
00:12:53,160 --> 00:12:55,260
queries with interactive versions which

304
00:12:55,260 --> 00:12:56,339
would then

305
00:12:56,339 --> 00:12:58,740
um uh construct

306
00:12:58,740 --> 00:13:00,660
um since we have vbb and we compile BBB

307
00:13:00,660 --> 00:13:03,240
in title 2pc we get l2pc for everything

308
00:13:03,240 --> 00:13:06,300
uh in P in the generic graded encodings

309
00:13:06,300 --> 00:13:07,860
model um if that if that answers your

310
00:13:07,860 --> 00:13:09,300
question yeah that answers thank you

311
00:13:09,300 --> 00:13:12,240
let's thank you and once again

312
00:13:12,240 --> 00:13:15,200
don't touch

313
00:13:27,779 --> 00:13:30,600
so our next talk is on fully secure MPC

314
00:13:30,600 --> 00:13:32,820
with minimal trust uh and the where are

315
00:13:32,820 --> 00:13:35,660
we would be giving the talk

316
00:13:42,779 --> 00:13:45,060
everyone uh so this talk is on fully

317
00:13:45,060 --> 00:13:47,279
secure NPC with minimal trust and it's

318
00:13:47,279 --> 00:13:48,899
based on a joint work with you while

319
00:13:48,899 --> 00:13:51,899
srinivasa

320
00:13:54,060 --> 00:13:57,120
so let me uh quickly begin with what

321
00:13:57,120 --> 00:13:59,160
secure multi-party computation or NPC

322
00:13:59,160 --> 00:14:01,260
means suppose you have n mutually

323
00:14:01,260 --> 00:14:03,300
distrusting parties out of which T are

324
00:14:03,300 --> 00:14:05,160
corrupt and the goal is that they want

325
00:14:05,160 --> 00:14:07,079
to compute some combined function on

326
00:14:07,079 --> 00:14:09,540
their private inputs MPC gives them a

327
00:14:09,540 --> 00:14:11,700
way to do so while ensuring that they

328
00:14:11,700 --> 00:14:13,800
get the correct output and that nothing

329
00:14:13,800 --> 00:14:16,380
beyond the function output is revealed

330
00:14:16,380 --> 00:14:18,899
now you can have different types of MPC

331
00:14:18,899 --> 00:14:20,459
protocols with different types of

332
00:14:20,459 --> 00:14:22,860
guarantees and two of the strongest

333
00:14:22,860 --> 00:14:24,779
guarantees are fairness and full

334
00:14:24,779 --> 00:14:25,980
security

335
00:14:25,980 --> 00:14:28,680
so fair Protocols are fair in the sense

336
00:14:28,680 --> 00:14:30,660
that if the adversary gets the output

337
00:14:30,660 --> 00:14:33,180
then so do the honest parties but it may

338
00:14:33,180 --> 00:14:34,860
happen that in such protocols nobody

339
00:14:34,860 --> 00:14:37,019
gets the output but there is a stronger

340
00:14:37,019 --> 00:14:39,000
guarantee called the full security or

341
00:14:39,000 --> 00:14:41,160
guaranteed output delivery in which no

342
00:14:41,160 --> 00:14:43,260
matter what the adversary does he cannot

343
00:14:43,260 --> 00:14:44,760
prevent the honest parties from

344
00:14:44,760 --> 00:14:46,440
obtaining the output

345
00:14:46,440 --> 00:14:48,240
so if you're designing protocols you

346
00:14:48,240 --> 00:14:50,399
will try to get these strong guarantees

347
00:14:50,399 --> 00:14:52,860
but unfortunately there is a classic

348
00:14:52,860 --> 00:14:55,440
impossibility result by cleave which

349
00:14:55,440 --> 00:14:57,120
said that you cannot get these

350
00:14:57,120 --> 00:14:58,980
guarantees if you assume that the

351
00:14:58,980 --> 00:15:01,079
adversary is corrupting a majority of

352
00:15:01,079 --> 00:15:02,100
the parties

353
00:15:02,100 --> 00:15:04,980
so now how do you bypass this if you

354
00:15:04,980 --> 00:15:07,139
still want to get these guarantees so

355
00:15:07,139 --> 00:15:09,899
one obvious option is that you assume an

356
00:15:09,899 --> 00:15:11,579
honest majority setting

357
00:15:11,579 --> 00:15:13,380
and in fact in such a setting you can

358
00:15:13,380 --> 00:15:15,360
get these guarantees and it has been

359
00:15:15,360 --> 00:15:17,339
very well explored in the MPC literature

360
00:15:17,339 --> 00:15:20,339
and there is also another option which

361
00:15:20,339 --> 00:15:22,620
has been relatively less explored

362
00:15:22,620 --> 00:15:24,420
in which you continue to be in the

363
00:15:24,420 --> 00:15:26,579
dishonest majority setting but still you

364
00:15:26,579 --> 00:15:28,860
get these guarantees by assuming some

365
00:15:28,860 --> 00:15:30,540
sort of external help

366
00:15:30,540 --> 00:15:33,660
so you can imagine such protocols as

367
00:15:33,660 --> 00:15:36,240
being like a regular MPC protocol except

368
00:15:36,240 --> 00:15:38,459
that occasionally from time to time you

369
00:15:38,459 --> 00:15:40,680
have access to this Genie who is doing

370
00:15:40,680 --> 00:15:43,620
some computation for you and then uh

371
00:15:43,620 --> 00:15:46,740
helping you get these strong guarantees

372
00:15:46,740 --> 00:15:49,079
so let's try to understand how to model

373
00:15:49,079 --> 00:15:52,320
this trusted party or this external help

374
00:15:52,320 --> 00:15:54,480
so in our work we mainly focused on two

375
00:15:54,480 --> 00:15:57,540
main Dimensions one is about what kind

376
00:15:57,540 --> 00:15:59,399
of computation we make this trusted

377
00:15:59,399 --> 00:16:02,639
party do because we may want to post

378
00:16:02,639 --> 00:16:04,500
some restrictions on the kind of wishes

379
00:16:04,500 --> 00:16:07,500
that the genie is granting us and

380
00:16:07,500 --> 00:16:10,740
um the other dimension was that how many

381
00:16:10,740 --> 00:16:13,199
times do we use this trusted party how

382
00:16:13,199 --> 00:16:14,820
many wishes are we getting

383
00:16:14,820 --> 00:16:17,639
so um let's analyze the existing

384
00:16:17,639 --> 00:16:20,639
Solutions based on these two dimensions

385
00:16:20,639 --> 00:16:23,100
so one trivial way to get full security

386
00:16:23,100 --> 00:16:25,500
would be that you just make the genie

387
00:16:25,500 --> 00:16:28,320
compute the function itself directly and

388
00:16:28,320 --> 00:16:30,240
this would need just one call because

389
00:16:30,240 --> 00:16:32,459
all of the parties can simply send their

390
00:16:32,459 --> 00:16:34,320
inputs to the genie that would be

391
00:16:34,320 --> 00:16:37,199
counted as one call who computes the

392
00:16:37,199 --> 00:16:39,240
function and gives you the output back

393
00:16:39,240 --> 00:16:41,519
so this is great in terms of the number

394
00:16:41,519 --> 00:16:43,740
of calls because one is just the minimum

395
00:16:43,740 --> 00:16:46,860
that you can use but if your circuit is

396
00:16:46,860 --> 00:16:48,839
large then maybe you don't want to do

397
00:16:48,839 --> 00:16:51,000
such type of heavy computation using

398
00:16:51,000 --> 00:16:53,699
this external TP

399
00:16:53,699 --> 00:16:56,399
next there was this work by Isha and

400
00:16:56,399 --> 00:16:59,399
others in 2012 and they managed to get

401
00:16:59,399 --> 00:17:02,579
full security by making the TP do some

402
00:17:02,579 --> 00:17:05,040
small and lightweight work and by this I

403
00:17:05,040 --> 00:17:06,780
mean that it was independent of the

404
00:17:06,780 --> 00:17:08,939
function being computed so that's great

405
00:17:08,939 --> 00:17:13,199
but um on the downside this was using

406
00:17:13,199 --> 00:17:15,480
the trusted Party N number of times

407
00:17:15,480 --> 00:17:17,880
where n is your number of parties so

408
00:17:17,880 --> 00:17:19,439
this is something that you want to avoid

409
00:17:19,439 --> 00:17:21,299
if you are in a setting where the number

410
00:17:21,299 --> 00:17:23,699
of parties is large

411
00:17:23,699 --> 00:17:26,160
and in the same paper they also had a

412
00:17:26,160 --> 00:17:27,900
solution with one call that is the

413
00:17:27,900 --> 00:17:30,540
optimal number of calls but here the

414
00:17:30,540 --> 00:17:32,580
amount of work that they were making the

415
00:17:32,580 --> 00:17:35,160
trusted party do was exponential in the

416
00:17:35,160 --> 00:17:37,140
number of parties so maybe you also want

417
00:17:37,140 --> 00:17:38,760
to avoid this if your number of parties

418
00:17:38,760 --> 00:17:40,919
is large

419
00:17:40,919 --> 00:17:43,440
so the ideal goal would be if you could

420
00:17:43,440 --> 00:17:46,020
get full security with just one single

421
00:17:46,020 --> 00:17:49,620
call to a small TP and by small I mean

422
00:17:49,620 --> 00:17:52,380
that the complexity is polynomial in the

423
00:17:52,380 --> 00:17:53,640
number of parties and the security

424
00:17:53,640 --> 00:17:56,100
parameter and in particular it's

425
00:17:56,100 --> 00:17:57,720
independent of the function that you're

426
00:17:57,720 --> 00:17:59,880
trying to compute

427
00:17:59,880 --> 00:18:02,400
so now if you imagine that this trusted

428
00:18:02,400 --> 00:18:04,320
party is going to be realized by some

429
00:18:04,320 --> 00:18:06,660
cloud service provider who is charging

430
00:18:06,660 --> 00:18:09,299
you some fees for a computation or you

431
00:18:09,299 --> 00:18:10,860
are going to use instances of a

432
00:18:10,860 --> 00:18:13,020
large-scale honest majority MPC to do

433
00:18:13,020 --> 00:18:15,780
this uh functionality related to the

434
00:18:15,780 --> 00:18:18,179
external help then it makes sense that

435
00:18:18,179 --> 00:18:20,760
the TP is an expensive resource and you

436
00:18:20,760 --> 00:18:22,980
want to try to minimize how much you use

437
00:18:22,980 --> 00:18:25,080
it in terms of how many times you're

438
00:18:25,080 --> 00:18:27,120
using it and what type of computation

439
00:18:27,120 --> 00:18:29,580
you're making it to so that's why we

440
00:18:29,580 --> 00:18:32,880
wanted to achieve this goal

441
00:18:32,880 --> 00:18:35,400
so again our goal is to try to get full

442
00:18:35,400 --> 00:18:38,580
security with one call to a small TP but

443
00:18:38,580 --> 00:18:40,620
we started on a very negative note

444
00:18:40,620 --> 00:18:43,380
because uh for a large class of

445
00:18:43,380 --> 00:18:46,980
protocols we showed that in fact you you

446
00:18:46,980 --> 00:18:48,840
have to make the TP do work that is

447
00:18:48,840 --> 00:18:51,059
exponential in the number of parties if

448
00:18:51,059 --> 00:18:54,059
your decoder is universal so what I mean

449
00:18:54,059 --> 00:18:56,760
by the decoder being Universal is that

450
00:18:56,760 --> 00:18:58,799
once you invoke the DP you're just

451
00:18:58,799 --> 00:19:00,480
allowed to invoke it one time and you

452
00:19:00,480 --> 00:19:02,460
get a response then the kind of

453
00:19:02,460 --> 00:19:04,620
computation that you are doing to derive

454
00:19:04,620 --> 00:19:07,020
the output from this response if we

455
00:19:07,020 --> 00:19:08,640
assume that it's independent of the

456
00:19:08,640 --> 00:19:10,799
function to be computed then we showed

457
00:19:10,799 --> 00:19:13,500
that exponential size is inherent and we

458
00:19:13,500 --> 00:19:15,059
were particularly interested in this

459
00:19:15,059 --> 00:19:17,220
class because the one called solution of

460
00:19:17,220 --> 00:19:19,380
Isha and others was fitting into these

461
00:19:19,380 --> 00:19:21,840
class of protocols so what we are saying

462
00:19:21,840 --> 00:19:23,880
is that since they are having a

463
00:19:23,880 --> 00:19:25,799
universal decoder they could not have

464
00:19:25,799 --> 00:19:28,080
done better than making the TP do work

465
00:19:28,080 --> 00:19:31,380
exponential in the number of parties

466
00:19:31,380 --> 00:19:33,360
and this negative results holds

467
00:19:33,360 --> 00:19:35,280
irrespective of the computational

468
00:19:35,280 --> 00:19:37,559
assumptions or the setup

469
00:19:37,559 --> 00:19:41,280
so now if you want to uh any hope of a

470
00:19:41,280 --> 00:19:43,080
positive result then you have to allow

471
00:19:43,080 --> 00:19:46,080
this decoding to depend on the function

472
00:19:46,080 --> 00:19:48,299
so that's exactly what we do we allow

473
00:19:48,299 --> 00:19:50,580
the function dependent decoding but here

474
00:19:50,580 --> 00:19:54,240
we got another negative result which um

475
00:19:54,240 --> 00:19:55,860
showed that you cannot get information

476
00:19:55,860 --> 00:19:59,039
theoretic Security in the plane model

477
00:19:59,039 --> 00:20:01,020
so this means that we have to either

478
00:20:01,020 --> 00:20:03,419
switch to the computational setting or

479
00:20:03,419 --> 00:20:04,500
we could consider the information

480
00:20:04,500 --> 00:20:07,020
theoretic setting with setup

481
00:20:07,020 --> 00:20:09,059
and in the computational setting we

482
00:20:09,059 --> 00:20:11,460
finally had a positive result in which

483
00:20:11,460 --> 00:20:13,679
we showed that you can get full security

484
00:20:13,679 --> 00:20:16,320
by making just a single call to a small

485
00:20:16,320 --> 00:20:18,720
TP and this is a very simple

486
00:20:18,720 --> 00:20:20,340
construction based on functional

487
00:20:20,340 --> 00:20:21,480
encryption

488
00:20:21,480 --> 00:20:23,880
and this other

489
00:20:23,880 --> 00:20:25,740
um direction is still open so we still

490
00:20:25,740 --> 00:20:27,059
don't know what happens in the

491
00:20:27,059 --> 00:20:30,000
information theoretic setting with setup

492
00:20:30,000 --> 00:20:31,679
so for the rest of the talk I will just

493
00:20:31,679 --> 00:20:33,720
elaborate on the positive result based

494
00:20:33,720 --> 00:20:36,539
on functional encryption

495
00:20:36,539 --> 00:20:39,419
um but before that let me recap the

496
00:20:39,419 --> 00:20:41,520
syntax of a functional encryption scheme

497
00:20:41,520 --> 00:20:43,740
so first you have the setup algorithm

498
00:20:43,740 --> 00:20:46,020
which sets up your master public key and

499
00:20:46,020 --> 00:20:48,480
the master secret key then you have the

500
00:20:48,480 --> 00:20:50,220
key generation that takes in the master

501
00:20:50,220 --> 00:20:52,799
secret key and the function f and it

502
00:20:52,799 --> 00:20:54,780
would give you a functional secret key

503
00:20:54,780 --> 00:20:56,340
say SKF

504
00:20:56,340 --> 00:20:58,980
and encryption takes in the master

505
00:20:58,980 --> 00:21:01,620
public key and your input plain text X

506
00:21:01,620 --> 00:21:04,140
and it gives you the ciphertext C

507
00:21:04,140 --> 00:21:06,179
and decryption would take in the

508
00:21:06,179 --> 00:21:08,100
ciphertext and this functional secret

509
00:21:08,100 --> 00:21:10,140
key and it would give you an output and

510
00:21:10,140 --> 00:21:12,539
if everything is good then the output is

511
00:21:12,539 --> 00:21:14,940
nothing but the function f evaluated on

512
00:21:14,940 --> 00:21:16,919
this plain text input X

513
00:21:16,919 --> 00:21:19,260
so this is just a recap of water

514
00:21:19,260 --> 00:21:21,480
functional encryption scheme looks like

515
00:21:21,480 --> 00:21:24,539
so now let's see our uh fully secured

516
00:21:24,539 --> 00:21:28,080
MPC with one call to a small TP

517
00:21:28,080 --> 00:21:30,179
so what we do in this construction is

518
00:21:30,179 --> 00:21:33,059
that first we run an instance of an MPC

519
00:21:33,059 --> 00:21:35,640
protocol with identifiable award now

520
00:21:35,640 --> 00:21:37,260
this is the best type of guarantee that

521
00:21:37,260 --> 00:21:39,059
you can get in a dishonest majority

522
00:21:39,059 --> 00:21:42,000
setting and the guarantee is that it may

523
00:21:42,000 --> 00:21:43,919
happen that the honest parties don't get

524
00:21:43,919 --> 00:21:46,020
the output but in such a case they would

525
00:21:46,020 --> 00:21:49,380
identify at least one corrupt cheetah so

526
00:21:49,380 --> 00:21:51,480
we use an instance of this but we don't

527
00:21:51,480 --> 00:21:53,520
use it to compute the original function

528
00:21:53,520 --> 00:21:55,440
because if we used it to compute the

529
00:21:55,440 --> 00:21:57,000
original function then you would violate

530
00:21:57,000 --> 00:21:58,740
fairness because the adversary would get

531
00:21:58,740 --> 00:22:00,900
the output and not the honest people

532
00:22:00,900 --> 00:22:03,720
so instead of using it to compute F we

533
00:22:03,720 --> 00:22:05,940
use it to set up these keys for our

534
00:22:05,940 --> 00:22:07,679
functional encryption scheme

535
00:22:07,679 --> 00:22:10,140
so this outputs the master public key

536
00:22:10,140 --> 00:22:12,780
and the functional secret key uh the

537
00:22:12,780 --> 00:22:15,480
idea is that if a run of this results in

538
00:22:15,480 --> 00:22:17,820
a bot then you eliminate the cheetah and

539
00:22:17,820 --> 00:22:19,559
you keep re-running this until it is

540
00:22:19,559 --> 00:22:21,179
successful at some point all the

541
00:22:21,179 --> 00:22:22,799
cheaters will be eliminated and you're

542
00:22:22,799 --> 00:22:24,900
sure that it will be successful

543
00:22:24,900 --> 00:22:27,059
so the parties do this until it's

544
00:22:27,059 --> 00:22:28,980
successful and then they move on to the

545
00:22:28,980 --> 00:22:30,419
next phase

546
00:22:30,419 --> 00:22:32,820
so in the next phase what the parties

547
00:22:32,820 --> 00:22:35,159
would do is they would simply send their

548
00:22:35,159 --> 00:22:36,900
this master public key that was the

549
00:22:36,900 --> 00:22:39,179
output of the MPC and their inputs to

550
00:22:39,179 --> 00:22:40,919
this Genie

551
00:22:40,919 --> 00:22:43,440
now note that the corrupt person can of

552
00:22:43,440 --> 00:22:45,179
course misbehave for example this

553
00:22:45,179 --> 00:22:47,400
adversary is sending the correct Master

554
00:22:47,400 --> 00:22:49,860
public key on behalf of P2 but on behalf

555
00:22:49,860 --> 00:22:52,679
of P4 it's sending a different one

556
00:22:52,679 --> 00:22:55,500
but from the point of view of the genie

557
00:22:55,500 --> 00:22:58,559
he has no idea about who is lying or who

558
00:22:58,559 --> 00:23:00,480
is honest because we are in the

559
00:23:00,480 --> 00:23:02,400
dishonest majority setting so for all

560
00:23:02,400 --> 00:23:04,380
the genie knows the Red Master public

561
00:23:04,380 --> 00:23:06,480
key could be the correct one and maybe

562
00:23:06,480 --> 00:23:09,600
the first three are corrupt so the genie

563
00:23:09,600 --> 00:23:11,520
cannot really identify who is good and

564
00:23:11,520 --> 00:23:13,559
who is bad the best thing that he can do

565
00:23:13,559 --> 00:23:15,659
is he can just try to create a partition

566
00:23:15,659 --> 00:23:17,820
based on whoever is sending him

567
00:23:17,820 --> 00:23:19,620
consistent information

568
00:23:19,620 --> 00:23:22,020
so that's exactly what the genie does

569
00:23:22,020 --> 00:23:25,020
that he just creates a partition uh with

570
00:23:25,020 --> 00:23:26,700
a set of people who sent him the blue

571
00:23:26,700 --> 00:23:28,799
master public key and the set of people

572
00:23:28,799 --> 00:23:30,900
sending him the red one so for the set

573
00:23:30,900 --> 00:23:32,880
of people sending him the blue one he

574
00:23:32,880 --> 00:23:35,159
would prepare a cipher text using this

575
00:23:35,159 --> 00:23:37,620
master public key and he will use the

576
00:23:37,620 --> 00:23:40,260
inputs just sent by them and a default

577
00:23:40,260 --> 00:23:42,480
input by the fourth one

578
00:23:42,480 --> 00:23:43,799
and similarly he will create another

579
00:23:43,799 --> 00:23:45,900
Cipher text using the Red Master public

580
00:23:45,900 --> 00:23:48,000
key but in this case he would use only

581
00:23:48,000 --> 00:23:51,000
p4's input and then he would use default

582
00:23:51,000 --> 00:23:52,679
inputs for the others

583
00:23:52,679 --> 00:23:55,919
and now he just simply Returns the

584
00:23:55,919 --> 00:23:58,860
ciphertext to the relevant parties

585
00:23:58,860 --> 00:24:01,080
the point here is that we are sure that

586
00:24:01,080 --> 00:24:02,640
the honest parties will always be in the

587
00:24:02,640 --> 00:24:04,559
same set because they would be sending

588
00:24:04,559 --> 00:24:07,020
consistent information to the genie so

589
00:24:07,020 --> 00:24:09,299
now as an honest party if I get a cipher

590
00:24:09,299 --> 00:24:11,580
text I just from the genie I just

591
00:24:11,580 --> 00:24:14,400
decoded using my um functional secret

592
00:24:14,400 --> 00:24:17,700
key and I get this particular output

593
00:24:17,700 --> 00:24:19,980
now of course the adversary can be a

594
00:24:19,980 --> 00:24:22,020
have corrupt parties in different sets

595
00:24:22,020 --> 00:24:24,539
so he can get multiple outputs but note

596
00:24:24,539 --> 00:24:26,940
that all the outputs would be except the

597
00:24:26,940 --> 00:24:28,860
one in which was belonging to the set of

598
00:24:28,860 --> 00:24:31,080
honest people all the others would be on

599
00:24:31,080 --> 00:24:32,820
default inputs of the honest parties

600
00:24:32,820 --> 00:24:36,000
that's why it does not violate security

601
00:24:36,000 --> 00:24:38,340
so it's clear that this construction is

602
00:24:38,340 --> 00:24:41,100
using just one call uh but let's analyze

603
00:24:41,100 --> 00:24:43,679
what work we are making this uh Genie do

604
00:24:43,679 --> 00:24:46,380
so we mainly made it compute these

605
00:24:46,380 --> 00:24:49,679
ciphertexts so now the size of these

606
00:24:49,679 --> 00:24:51,659
ciphertexts would depend on the type of

607
00:24:51,659 --> 00:24:54,299
Fe scheme that you're considering so if

608
00:24:54,299 --> 00:24:56,039
you take one that is based on

609
00:24:56,039 --> 00:24:58,320
sub-exponential dot lwe then the

610
00:24:58,320 --> 00:25:00,480
complexity would be polynomial in the

611
00:25:00,480 --> 00:25:01,799
number of parties and the security

612
00:25:01,799 --> 00:25:04,140
parameter but it would depend on the

613
00:25:04,140 --> 00:25:06,360
depth of the circuit but if you wanted

614
00:25:06,360 --> 00:25:08,580
it to be ideally small not depend on the

615
00:25:08,580 --> 00:25:11,159
circuit at all then you could use the

616
00:25:11,159 --> 00:25:12,720
functional encryption scheme that is

617
00:25:12,720 --> 00:25:14,220
based on IO

618
00:25:14,220 --> 00:25:16,679
so this is our construction and note

619
00:25:16,679 --> 00:25:18,840
that this is not violating our negative

620
00:25:18,840 --> 00:25:20,940
result because the decoding that the

621
00:25:20,940 --> 00:25:22,860
parties are doing to derive the output

622
00:25:22,860 --> 00:25:25,020
from the response of the genie is

623
00:25:25,020 --> 00:25:26,520
depending on the function that's why

624
00:25:26,520 --> 00:25:28,679
it's not uh violating our negative

625
00:25:28,679 --> 00:25:30,720
result

626
00:25:30,720 --> 00:25:31,799
so

627
00:25:31,799 --> 00:25:32,820
um

628
00:25:32,820 --> 00:25:34,620
so in the last construction we are just

629
00:25:34,620 --> 00:25:36,360
sending the inputs on clear to the genie

630
00:25:36,360 --> 00:25:37,980
and this is maybe something that people

631
00:25:37,980 --> 00:25:40,020
are not comfortable with and you want to

632
00:25:40,020 --> 00:25:41,220
try to

633
00:25:41,220 --> 00:25:41,940
um

634
00:25:41,940 --> 00:25:44,640
assume that the TP is at least semi

635
00:25:44,640 --> 00:25:47,279
honest not completely honest so that's

636
00:25:47,279 --> 00:25:49,679
why we looked at these other models

637
00:25:49,679 --> 00:25:52,020
which um in which the adversary could

638
00:25:52,020 --> 00:25:53,460
corrupt a majority of the parties

639
00:25:53,460 --> 00:25:55,799
actively and also it could corrupt the

640
00:25:55,799 --> 00:25:58,140
TP in a semi-honest manner so we refer

641
00:25:58,140 --> 00:26:00,120
to this as the colluding model but here

642
00:26:00,120 --> 00:26:02,100
we showed that you cannot circumvent

643
00:26:02,100 --> 00:26:04,559
Cleaves impossibility and that fairness

644
00:26:04,559 --> 00:26:07,380
continues to remain impossible

645
00:26:07,380 --> 00:26:09,900
we also consider this other next best

646
00:26:09,900 --> 00:26:12,179
option of the non-cluding model in which

647
00:26:12,179 --> 00:26:14,220
it can perform only one type of these

648
00:26:14,220 --> 00:26:16,799
two Corruptions and here we found that

649
00:26:16,799 --> 00:26:18,059
whatever was the previous construction

650
00:26:18,059 --> 00:26:20,700
you could make some modifications to it

651
00:26:20,700 --> 00:26:23,460
to get security against a semi honest TP

652
00:26:23,460 --> 00:26:25,080
so he now you will not be sending your

653
00:26:25,080 --> 00:26:27,179
inputs on clear to the TP but doing

654
00:26:27,179 --> 00:26:29,340
something slightly different to get

655
00:26:29,340 --> 00:26:32,820
security against a semi honest DP

656
00:26:32,820 --> 00:26:35,100
so this is basically a summary of our

657
00:26:35,100 --> 00:26:37,260
results and I already mentioned one of

658
00:26:37,260 --> 00:26:39,480
the open questions but there are plenty

659
00:26:39,480 --> 00:26:41,220
of future directions like we don't know

660
00:26:41,220 --> 00:26:43,919
if we need something like I O for this

661
00:26:43,919 --> 00:26:46,740
ideal small solution and also we

662
00:26:46,740 --> 00:26:48,960
restricted ourselves to one call and the

663
00:26:48,960 --> 00:26:50,760
work efficient others was end call but

664
00:26:50,760 --> 00:26:52,440
there's nothing known in between maybe

665
00:26:52,440 --> 00:26:55,200
there are much more uh Simple Solutions

666
00:26:55,200 --> 00:26:57,620
based on simpler assumptions if we say

667
00:26:57,620 --> 00:26:59,820
consider two calls instead of one call

668
00:26:59,820 --> 00:27:02,279
or anything in between one to n

669
00:27:02,279 --> 00:27:05,460
so that's basically it thank you thank

670
00:27:05,460 --> 00:27:07,580
you

671
00:27:10,260 --> 00:27:14,360
uh does anyone have questions

672
00:27:25,100 --> 00:27:27,659
compile this with like a

673
00:27:27,659 --> 00:27:28,440
um

674
00:27:28,440 --> 00:27:31,919
honest majority uh protocol way the

675
00:27:31,919 --> 00:27:35,340
honest majority protocol runs this um

676
00:27:35,340 --> 00:27:38,159
this trusted party and then you have a

677
00:27:38,159 --> 00:27:41,580
like a very uh the honest majority is

678
00:27:41,580 --> 00:27:43,440
only for the very limited functionality

679
00:27:43,440 --> 00:27:46,880
and the dishonest majority for the rest

680
00:27:46,880 --> 00:27:49,559
so I mean the way that we were trying to

681
00:27:49,559 --> 00:27:51,120
think that if it's a large scale one

682
00:27:51,120 --> 00:27:52,380
then maybe you're assuming that it's

683
00:27:52,380 --> 00:27:53,760
honest majority but are you saying that

684
00:27:53,760 --> 00:27:56,100
the functionality is in a way that you

685
00:27:56,100 --> 00:27:58,200
can do it or not you can get fairness

686
00:27:58,200 --> 00:28:00,000
even in that or maybe I'm not getting

687
00:28:00,000 --> 00:28:02,940
your question so whatever the TP is

688
00:28:02,940 --> 00:28:05,700
doing we want to realize it using just

689
00:28:05,700 --> 00:28:08,279
for those type of that part of the

690
00:28:08,279 --> 00:28:10,620
computation we may consider like involve

691
00:28:10,620 --> 00:28:12,779
more parties we consider like more

692
00:28:12,779 --> 00:28:14,159
number of parties so that we are now

693
00:28:14,159 --> 00:28:15,779
hoping to have honest majority in the

694
00:28:15,779 --> 00:28:17,940
bigger set and then we are realizing it

695
00:28:17,940 --> 00:28:20,159
through that

696
00:28:20,159 --> 00:28:22,200
but are you suggesting uh something

697
00:28:22,200 --> 00:28:25,260
different uh I might not understanding I

698
00:28:25,260 --> 00:28:26,400
might not be understanding it okay

699
00:28:26,400 --> 00:28:29,520
correctly no no I think it's better if

700
00:28:29,520 --> 00:28:31,020
you take it offline I think there is

701
00:28:31,020 --> 00:28:33,659
this will take too long

702
00:28:33,659 --> 00:28:37,400
okay let's thank the way again

703
00:28:46,799 --> 00:28:49,520
all right Alex

704
00:28:55,380 --> 00:28:58,380
somebody

705
00:28:59,880 --> 00:29:03,000
hello okay so the next talk is on

706
00:29:03,000 --> 00:29:04,980
statistical Security in two-party

707
00:29:04,980 --> 00:29:07,500
computation Revisited uh given by pratik

708
00:29:07,500 --> 00:29:08,520
sarkar

709
00:29:08,520 --> 00:29:10,740
hi everyone uh so my name is pratik

710
00:29:10,740 --> 00:29:12,360
today I'm gonna talk about statistical

711
00:29:12,360 --> 00:29:14,880
Security in the two-party setting this

712
00:29:14,880 --> 00:29:16,679
is a joint work with Sai Krishna badri

713
00:29:16,679 --> 00:29:19,200
Narayan none from snap and Shikhar

714
00:29:19,200 --> 00:29:22,440
patnabis from IBM research India so

715
00:29:22,440 --> 00:29:23,399
today we are going to talk about

716
00:29:23,399 --> 00:29:25,919
two-party competition so here there are

717
00:29:25,919 --> 00:29:27,480
two parties who have private inputs X

718
00:29:27,480 --> 00:29:29,580
and Y and they want to compute a

719
00:29:29,580 --> 00:29:32,039
function f so for that they run a

720
00:29:32,039 --> 00:29:34,140
protocol Pi on their function and the

721
00:29:34,140 --> 00:29:35,700
correctness is that the protocol output

722
00:29:35,700 --> 00:29:37,980
is same as the function output and

723
00:29:37,980 --> 00:29:40,740
security says that the protocol output

724
00:29:40,740 --> 00:29:42,419
does not leak anything about X and Y

725
00:29:42,419 --> 00:29:45,059
beyond the protocol output

726
00:29:45,059 --> 00:29:47,220
and we designate the right hand side

727
00:29:47,220 --> 00:29:48,899
party as a receiver and the left hand

728
00:29:48,899 --> 00:29:51,240
side party as the sender and in our

729
00:29:51,240 --> 00:29:53,399
setting if one party gets the output we

730
00:29:53,399 --> 00:29:54,899
consider it's a receiver who gets the

731
00:29:54,899 --> 00:29:56,760
output and if both parties get the

732
00:29:56,760 --> 00:29:58,500
output we consider that is the receiver

733
00:29:58,500 --> 00:30:00,960
who receives the output first

734
00:30:00,960 --> 00:30:02,880
and in this talk we are going to focus

735
00:30:02,880 --> 00:30:04,559
on two-party competition in the plane

736
00:30:04,559 --> 00:30:07,020
model there are no setup assumptions

737
00:30:07,020 --> 00:30:09,779
and we are going to consider uh one

738
00:30:09,779 --> 00:30:11,880
message exchange model where in every

739
00:30:11,880 --> 00:30:14,460
round only one party is supposed to send

740
00:30:14,460 --> 00:30:17,220
a message so we do not consider uh

741
00:30:17,220 --> 00:30:21,059
simultaneous messaging so our uh results

742
00:30:21,059 --> 00:30:22,980
are in the non simultaneous messaging

743
00:30:22,980 --> 00:30:24,120
model

744
00:30:24,120 --> 00:30:26,100
so in this talk we are going to focus on

745
00:30:26,100 --> 00:30:27,960
round optimal 2pc in the plane model

746
00:30:27,960 --> 00:30:30,600
where one of the parties are is

747
00:30:30,600 --> 00:30:32,640
computationally unbounded we consider

748
00:30:32,640 --> 00:30:34,559
security against malicious Corruptions

749
00:30:34,559 --> 00:30:36,539
and we consider polytime Black Box

750
00:30:36,539 --> 00:30:38,520
simulation-based security

751
00:30:38,520 --> 00:30:40,860
so why do we care about round complexity

752
00:30:40,860 --> 00:30:44,279
because of like fewer rounds impose less

753
00:30:44,279 --> 00:30:46,620
Network latency so it's always ideal to

754
00:30:46,620 --> 00:30:49,559
have like the round optimal protocols

755
00:30:49,559 --> 00:30:51,299
and also round optimal protocols have

756
00:30:51,299 --> 00:30:52,919
other useful applications in

757
00:30:52,919 --> 00:30:54,360
cryptography

758
00:30:54,360 --> 00:30:56,580
so let's revisit some of the lower

759
00:30:56,580 --> 00:30:59,520
bounds in the 2pc domain so it's known

760
00:30:59,520 --> 00:31:02,399
by uh due to the seminal work by carts

761
00:31:02,399 --> 00:31:04,260
and ostrovsky that four rounds are

762
00:31:04,260 --> 00:31:06,179
necessary if only one party wishes to

763
00:31:06,179 --> 00:31:08,100
get the output and five rounds are

764
00:31:08,100 --> 00:31:09,779
necessary if both parties wish to get

765
00:31:09,779 --> 00:31:12,179
the output uh remember that this is the

766
00:31:12,179 --> 00:31:14,700
non-simultaneous message exchange model

767
00:31:14,700 --> 00:31:17,580
there's also another work by cards which

768
00:31:17,580 --> 00:31:19,919
shows that five rounds are necessary for

769
00:31:19,919 --> 00:31:22,679
zero knowledge proofs uh for NP

770
00:31:22,679 --> 00:31:24,779
statements with black box simulation

771
00:31:24,779 --> 00:31:27,779
so if we consider this in our setting

772
00:31:27,779 --> 00:31:30,120
this means that the unbounded prover is

773
00:31:30,120 --> 00:31:32,039
the information theoretic sender and the

774
00:31:32,039 --> 00:31:33,480
computational verified is a

775
00:31:33,480 --> 00:31:36,179
computational receiver in our setting so

776
00:31:36,179 --> 00:31:38,460
this kind of rules out around uh four

777
00:31:38,460 --> 00:31:40,440
rounds protocol when the sender is

778
00:31:40,440 --> 00:31:42,539
computationally unbounded

779
00:31:42,539 --> 00:31:44,640
so this is like the summary of the lower

780
00:31:44,640 --> 00:31:47,399
bounds that means we cannot get a

781
00:31:47,399 --> 00:31:50,820
protocol which is like four rounds uh I

782
00:31:50,820 --> 00:31:52,320
mean which is like five rounds where

783
00:31:52,320 --> 00:31:54,299
both parties get the output so four

784
00:31:54,299 --> 00:31:55,860
rounds are necessary when the receiver

785
00:31:55,860 --> 00:31:57,419
runs the output five runs are necessary

786
00:31:57,419 --> 00:31:59,460
when both parties receive the output and

787
00:31:59,460 --> 00:32:01,500
five runs are also necessary when the

788
00:32:01,500 --> 00:32:03,779
sender is completionally unbounded so

789
00:32:03,779 --> 00:32:05,520
then what can we achieve in four rounds

790
00:32:05,520 --> 00:32:07,620
so the optimal two PC that we can

791
00:32:07,620 --> 00:32:09,299
achieve in four rounds is against a

792
00:32:09,299 --> 00:32:11,279
computationally unbounded receiver and

793
00:32:11,279 --> 00:32:13,140
computationally bounded sender so this

794
00:32:13,140 --> 00:32:15,240
was studied by the work by khurana and

795
00:32:15,240 --> 00:32:18,720
mogis in TCC 2020 paper and this turned

796
00:32:18,720 --> 00:32:21,659
this uh the coined this term as uh

797
00:32:21,659 --> 00:32:24,240
one-sided statistical security so we are

798
00:32:24,240 --> 00:32:26,100
going to focus on this setting

799
00:32:26,100 --> 00:32:28,320
so now let's see uh the results in the

800
00:32:28,320 --> 00:32:31,140
one-sided statistically secured to PC so

801
00:32:31,140 --> 00:32:33,360
what do we know about this so the

802
00:32:33,360 --> 00:32:35,580
paperback came to like the km20 paper

803
00:32:35,580 --> 00:32:37,919
they obtained a protocol which is round

804
00:32:37,919 --> 00:32:40,260
optimal and they constructed this

805
00:32:40,260 --> 00:32:42,659
protocol from basically this ingredient

806
00:32:42,659 --> 00:32:44,760
called two round statistically sender

807
00:32:44,760 --> 00:32:47,760
private OT this means that uh it's a two

808
00:32:47,760 --> 00:32:50,279
round OT protocol where the receiver is

809
00:32:50,279 --> 00:32:52,799
statistically uh like receiver is

810
00:32:52,799 --> 00:32:54,960
computationally unmounded and the sender

811
00:32:54,960 --> 00:32:57,120
is computationally bounded and here the

812
00:32:57,120 --> 00:32:58,679
sender's message one of the sender's

813
00:32:58,679 --> 00:33:00,539
message is statistically hidden from a

814
00:33:00,539 --> 00:33:03,960
corrupt receiver and the receiver Choice

815
00:33:03,960 --> 00:33:06,000
bit is competitionally hidden from a

816
00:33:06,000 --> 00:33:08,820
sender so this is like a two round sspot

817
00:33:08,820 --> 00:33:11,279
and they instantiate their compiler by

818
00:33:11,279 --> 00:33:12,659
instantiating the underlying two round

819
00:33:12,659 --> 00:33:14,760
SSP OT from decisional hardness

820
00:33:14,760 --> 00:33:17,700
assumption assumptions like dth QR DCR

821
00:33:17,700 --> 00:33:20,460
lwe divisional Seaside and recently from

822
00:33:20,460 --> 00:33:22,740
LPN plus d randomization style

823
00:33:22,740 --> 00:33:24,779
assumptions

824
00:33:24,779 --> 00:33:27,659
um but the problem is like can we want

825
00:33:27,659 --> 00:33:29,399
to instantiate this compiler from like

826
00:33:29,399 --> 00:33:31,440
obtain this compiler from computational

827
00:33:31,440 --> 00:33:34,559
assumptions like CDH but we do not know

828
00:33:34,559 --> 00:33:37,380
two rounds sspot constructions from CDH

829
00:33:37,380 --> 00:33:41,760
so our work basically uh constructs a

830
00:33:41,760 --> 00:33:43,740
new generic compiler for one-sided

831
00:33:43,740 --> 00:33:46,080
statistically secured to PC and we

832
00:33:46,080 --> 00:33:48,059
obtain this result from weaker

833
00:33:48,059 --> 00:33:50,519
ingredients uh mainly a three round

834
00:33:50,519 --> 00:33:53,159
Elementary OT which uh with its

835
00:33:53,159 --> 00:33:54,720
statistical receiver privacy and

836
00:33:54,720 --> 00:33:56,820
non-interactive commitment scheme so

837
00:33:56,820 --> 00:33:58,980
what we do is we relax the round

838
00:33:58,980 --> 00:34:01,500
requirement from two to three and this

839
00:34:01,500 --> 00:34:03,240
kind of allows us to obtain new

840
00:34:03,240 --> 00:34:05,039
instantiations from computational

841
00:34:05,039 --> 00:34:06,600
hardness assumptions

842
00:34:06,600 --> 00:34:08,940
mainly we obtain the first instantiation

843
00:34:08,940 --> 00:34:11,639
from CDH and the first instantiation of

844
00:34:11,639 --> 00:34:14,219
uh from reciprocal Seaside which is

845
00:34:14,219 --> 00:34:15,960
weaker than decisional Seaside so these

846
00:34:15,960 --> 00:34:18,000
are like isogenic assumptions

847
00:34:18,000 --> 00:34:20,940
and we also reobtained the result by

848
00:34:20,940 --> 00:34:24,780
km20 by uh showing that cool round sspot

849
00:34:24,780 --> 00:34:27,179
actually implies our weaker ingredients

850
00:34:27,179 --> 00:34:29,040
you can construct our ingredients from

851
00:34:29,040 --> 00:34:31,260
200 sspot so we already obtain the

852
00:34:31,260 --> 00:34:32,399
results

853
00:34:32,399 --> 00:34:34,980
so now let me briefly Define like this

854
00:34:34,980 --> 00:34:37,020
Elementary OT protocol

855
00:34:37,020 --> 00:34:38,940
so it's a three round OT protocol where

856
00:34:38,940 --> 00:34:41,399
the sender sends the first message of

857
00:34:41,399 --> 00:34:44,580
the OT protocol the sender has two input

858
00:34:44,580 --> 00:34:46,980
messages x0 X1 and the receiver has

859
00:34:46,980 --> 00:34:49,980
Choice bit comma and the sender is

860
00:34:49,980 --> 00:34:51,780
computationally unbounded while the

861
00:34:51,780 --> 00:34:53,460
receiver is computationally bounded so

862
00:34:53,460 --> 00:34:56,219
it's like the role has switched and now

863
00:34:56,219 --> 00:34:58,020
the properties that we need from this

864
00:34:58,020 --> 00:35:00,180
eot protocol is that the receiver

865
00:35:00,180 --> 00:35:02,820
outputs X gamma and

866
00:35:02,820 --> 00:35:05,040
we need statistical receiver privacy

867
00:35:05,040 --> 00:35:07,020
that is gamma is statistically hidden

868
00:35:07,020 --> 00:35:09,180
from a computationally unbounded sender

869
00:35:09,180 --> 00:35:11,520
and we need this Elementary sender

870
00:35:11,520 --> 00:35:14,040
privacy which is uh the computationally

871
00:35:14,040 --> 00:35:16,920
bounded receiver cannot compute both x0

872
00:35:16,920 --> 00:35:19,079
and X1 so this is the elementary sender

873
00:35:19,079 --> 00:35:20,760
privacy property

874
00:35:20,760 --> 00:35:24,180
so using the eot with SRP property we

875
00:35:24,180 --> 00:35:26,400
are gonna check out how do we build this

876
00:35:26,400 --> 00:35:28,079
compiler for one-sided so it's equal to

877
00:35:28,079 --> 00:35:29,280
PC

878
00:35:29,280 --> 00:35:32,099
so I'm not going to go into the compiler

879
00:35:32,099 --> 00:35:34,500
construction but I'm just gonna briefly

880
00:35:34,500 --> 00:35:38,099
uh highlight uh the result by km20 and

881
00:35:38,099 --> 00:35:40,020
what changes we make in it so they

882
00:35:40,020 --> 00:35:42,960
obtained this uh round optimal one-sided

883
00:35:42,960 --> 00:35:45,599
60 called secure two PC from four

884
00:35:45,599 --> 00:35:48,240
Primitives so the first primitive is a

885
00:35:48,240 --> 00:35:49,859
two round uh statistically send a

886
00:35:49,859 --> 00:35:51,780
private conditional disclosure of

887
00:35:51,780 --> 00:35:53,940
Secrets then they have like two proof

888
00:35:53,940 --> 00:35:55,980
systems and they also have this called

889
00:35:55,980 --> 00:35:58,440
round optimal uh one-sided statistical

890
00:35:58,440 --> 00:36:00,720
explainable to PC

891
00:36:00,720 --> 00:36:03,420
and they basically built all of these

892
00:36:03,420 --> 00:36:07,079
four Primitives from two round sspot uh

893
00:36:07,079 --> 00:36:09,119
so the proof systems are built from this

894
00:36:09,119 --> 00:36:10,579
two down statistically hiding commitment

895
00:36:10,579 --> 00:36:14,040
and this round optimal uh statistical

896
00:36:14,040 --> 00:36:16,260
explainable two PC is built from three

897
00:36:16,260 --> 00:36:17,760
Primitives which are instantiated from

898
00:36:17,760 --> 00:36:20,099
two round sspot and ultimately you can

899
00:36:20,099 --> 00:36:21,720
see like everything is built from this

900
00:36:21,720 --> 00:36:24,000
two round sspot which they instantiate

901
00:36:24,000 --> 00:36:27,119
from a variety of decisional assumptions

902
00:36:27,119 --> 00:36:29,579
so let us focus on this two round SSP

903
00:36:29,579 --> 00:36:31,740
CDs uh

904
00:36:31,740 --> 00:36:34,440
so what we do is we show that you don't

905
00:36:34,440 --> 00:36:37,200
need a two round SSP CDs rather you can

906
00:36:37,200 --> 00:36:39,720
work with a four round SSP CDs where the

907
00:36:39,720 --> 00:36:40,980
first two rounds are basically like

908
00:36:40,980 --> 00:36:43,200
pre-processing or you can also call this

909
00:36:43,200 --> 00:36:46,320
as delayed input and we show that you

910
00:36:46,320 --> 00:36:48,420
can build this three round I mean the

911
00:36:48,420 --> 00:36:52,440
four round SSP CDs from our eot and you

912
00:36:52,440 --> 00:36:54,780
can also build the other Primitives from

913
00:36:54,780 --> 00:36:56,820
this eot and non-interactive commitment

914
00:36:56,820 --> 00:37:00,180
schemes so essentially we show that this

915
00:37:00,180 --> 00:37:01,980
three round SRP eot and the

916
00:37:01,980 --> 00:37:03,300
non-interactive commitment scheme

917
00:37:03,300 --> 00:37:06,720
suffices to obtain the final result this

918
00:37:06,720 --> 00:37:09,780
round optimal one-sided secure to PC

919
00:37:09,780 --> 00:37:13,560
and to talk about instantiations we

920
00:37:13,560 --> 00:37:16,020
built this free round eot from the two

921
00:37:16,020 --> 00:37:18,720
round sspot and we also show I mean you

922
00:37:18,720 --> 00:37:20,220
can also build non-interactive

923
00:37:20,220 --> 00:37:21,780
commitment scheme from two round sspot

924
00:37:21,780 --> 00:37:25,320
this re-obtains the result of km20 but

925
00:37:25,320 --> 00:37:27,240
we also obtain new instantiation from

926
00:37:27,240 --> 00:37:29,640
CDH and reciprocal C site by

927
00:37:29,640 --> 00:37:31,440
constructing eot and non-injective

928
00:37:31,440 --> 00:37:33,300
commitment scheme from this

929
00:37:33,300 --> 00:37:37,200
so let's like see this CDs protocol a

930
00:37:37,200 --> 00:37:40,260
little bit so this is uh like what is a

931
00:37:40,260 --> 00:37:43,260
SSP CDs uh so in an SSP condition or

932
00:37:43,260 --> 00:37:45,720
this secret for a language L the sender

933
00:37:45,720 --> 00:37:48,060
has an NP statement X and a private

934
00:37:48,060 --> 00:37:49,920
message M and the receiver has an NP

935
00:37:49,920 --> 00:37:52,920
statement X and A Witness W so in the

936
00:37:52,920 --> 00:37:53,900
protocol

937
00:37:53,900 --> 00:37:56,940
the the sender sends X comma M the

938
00:37:56,940 --> 00:37:58,680
receiver sends X comma W and the

939
00:37:58,680 --> 00:38:01,140
protocol sends M Prime to receiver so

940
00:38:01,140 --> 00:38:02,880
correctness says that M Prime should be

941
00:38:02,880 --> 00:38:06,240
M if x and W is in the language and the

942
00:38:06,240 --> 00:38:07,500
series protocol should satisfy

943
00:38:07,500 --> 00:38:09,660
computational receiver privacy that is

944
00:38:09,660 --> 00:38:12,420
the witness W is hidden from the

945
00:38:12,420 --> 00:38:14,940
computationally bounded sender and the

946
00:38:14,940 --> 00:38:17,460
statistical sender privacy says that if

947
00:38:17,460 --> 00:38:18,780
the statement is not in the language

948
00:38:18,780 --> 00:38:21,060
that is X comma W is not in the language

949
00:38:21,060 --> 00:38:24,839
for any a for all W then the sender's

950
00:38:24,839 --> 00:38:26,640
private message is hidden from the

951
00:38:26,640 --> 00:38:28,740
receiver so it's like the receiver is

952
00:38:28,740 --> 00:38:31,140
able to decrypt the sender's message

953
00:38:31,140 --> 00:38:33,960
from the CDs protocol messages only if

954
00:38:33,960 --> 00:38:35,579
it knows a valid Witness

955
00:38:35,579 --> 00:38:38,460
so let's briefly see like how the

956
00:38:38,460 --> 00:38:41,160
construction of uh CDs protocol SSP CDs

957
00:38:41,160 --> 00:38:43,920
protocol happens in km20 so they

958
00:38:43,920 --> 00:38:46,140
basically construct this protocol from

959
00:38:46,140 --> 00:38:48,839
two round sspot and information Theory

960
00:38:48,839 --> 00:38:51,000
gobbling so on the first round of the

961
00:38:51,000 --> 00:38:54,000
CDs protocol the receiver invokes the

962
00:38:54,000 --> 00:38:56,400
SSP OT uh with Choice bits as the

963
00:38:56,400 --> 00:38:59,460
witness bits then the sender uh

964
00:38:59,460 --> 00:39:02,520
basically gobbles a circuit which has M

965
00:39:02,520 --> 00:39:04,740
like the private message M hard-coded

966
00:39:04,740 --> 00:39:07,740
inside it and the NP statement X so this

967
00:39:07,740 --> 00:39:11,040
garbage circuit uh takes as input the

968
00:39:11,040 --> 00:39:14,280
witness and it verifies the X comma W

969
00:39:14,280 --> 00:39:16,619
like whether X and W is in the language

970
00:39:16,619 --> 00:39:19,200
if it is then it outputs M else it

971
00:39:19,200 --> 00:39:22,619
outputs uh zero and it also encrypts the

972
00:39:22,619 --> 00:39:25,140
wire labels for the witness inside the

973
00:39:25,140 --> 00:39:27,000
OT sender message as a what you send a

974
00:39:27,000 --> 00:39:29,940
message so the sender sends this CDs to

975
00:39:29,940 --> 00:39:32,940
uh consider which consists of the SSP OT

976
00:39:32,940 --> 00:39:34,859
sender message and the gobble circuit to

977
00:39:34,859 --> 00:39:36,900
the receiver now the receiver obtains

978
00:39:36,900 --> 00:39:38,700
the wire labels corresponding to the

979
00:39:38,700 --> 00:39:40,740
witness and then it evaluates the gobble

980
00:39:40,740 --> 00:39:43,760
circuit to obtain the message m

981
00:39:43,760 --> 00:39:45,839
circuit has to be information theoretic

982
00:39:45,839 --> 00:39:47,820
and these are SSP so that's why this is

983
00:39:47,820 --> 00:39:51,000
uh secure against a statistical receiver

984
00:39:51,000 --> 00:39:53,760
so in our paper we show that you don't

985
00:39:53,760 --> 00:39:55,920
really need two round you can also work

986
00:39:55,920 --> 00:40:00,060
with a four round CDs more so in this uh

987
00:40:00,060 --> 00:40:03,060
so in our paper we Define this uh four

988
00:40:03,060 --> 00:40:05,940
round CDs protocol where cds1 and cds2

989
00:40:05,940 --> 00:40:08,780
are independent of the inputs x m and W

990
00:40:08,780 --> 00:40:11,220
and the receiver here is statistical

991
00:40:11,220 --> 00:40:12,780
while the sender is computationally

992
00:40:12,780 --> 00:40:15,480
bounded so our protocol is kind of

993
00:40:15,480 --> 00:40:18,720
similar to uh the km20 protocol we just

994
00:40:18,720 --> 00:40:21,420
replace the two round sspot with our

995
00:40:21,420 --> 00:40:23,820
four round SSP OT in which I which is

996
00:40:23,820 --> 00:40:26,280
delayed input so if you see the

997
00:40:26,280 --> 00:40:28,079
structure it's exactly same so that's

998
00:40:28,079 --> 00:40:30,300
how we construct our four round SSP OT

999
00:40:30,300 --> 00:40:32,700
protocol so this kind of allows us to

1000
00:40:32,700 --> 00:40:35,160
get new instantiations of SSP

1001
00:40:35,160 --> 00:40:37,560
conditional display of Secrets From CDH

1002
00:40:37,560 --> 00:40:41,099
and reciprocal C site so uh to summarize

1003
00:40:41,099 --> 00:40:44,339
uh we build the round optimal one-sided

1004
00:40:44,339 --> 00:40:47,400
statistically secure to PC from these

1005
00:40:47,400 --> 00:40:48,660
two ingredients these are our

1006
00:40:48,660 --> 00:40:51,180
ingredients and we instantiate them from

1007
00:40:51,180 --> 00:40:53,400
CDH and reciprocal Seaside and we also

1008
00:40:53,400 --> 00:40:54,960
instantiate them from the previous

1009
00:40:54,960 --> 00:40:57,420
decisional assumptions and this is the

1010
00:40:57,420 --> 00:40:59,339
K20 result

1011
00:40:59,339 --> 00:41:02,400
so to conclude we can we obtained a

1012
00:41:02,400 --> 00:41:04,859
round optimal one-sided secure2pc from

1013
00:41:04,859 --> 00:41:06,900
most concrete assumptions we also

1014
00:41:06,900 --> 00:41:09,720
proposed a delayed input SSP CDs which

1015
00:41:09,720 --> 00:41:11,760
has a pre-processing stage and to

1016
00:41:11,760 --> 00:41:13,800
conclude with some open questions uh it

1017
00:41:13,800 --> 00:41:15,359
would be interesting to study the round

1018
00:41:15,359 --> 00:41:18,119
optimal optimality of one-sided

1019
00:41:18,119 --> 00:41:20,339
statistical to PC where you only use

1020
00:41:20,339 --> 00:41:22,859
Black Box uh where you only have black

1021
00:41:22,859 --> 00:41:25,740
box usage of cryptography Primitives and

1022
00:41:25,740 --> 00:41:27,060
finally one more interesting open

1023
00:41:27,060 --> 00:41:29,880
question is to extend our result in the

1024
00:41:29,880 --> 00:41:31,740
multi-party setting where at least one

1025
00:41:31,740 --> 00:41:32,880
of the parties is computationally

1026
00:41:32,880 --> 00:41:36,980
unbounded so thank you

1027
00:41:40,560 --> 00:41:44,119
uh thank you questions

1028
00:41:50,520 --> 00:41:52,880
could you clarify the modeling for the

1029
00:41:52,880 --> 00:41:55,560
unbounded receiver in the deleted but

1030
00:41:55,560 --> 00:41:57,180
serious thing is it are you split

1031
00:41:57,180 --> 00:42:01,020
staging the before in the CDs yeah

1032
00:42:01,020 --> 00:42:01,700
yeah

1033
00:42:01,700 --> 00:42:04,740
so here this uh the receiver is uh

1034
00:42:04,740 --> 00:42:08,220
statistically like it's unbounded so and

1035
00:42:08,220 --> 00:42:11,339
malicious like both yeah but uh if it

1036
00:42:11,339 --> 00:42:12,900
were unwanted without the witness it

1037
00:42:12,900 --> 00:42:15,119
could compute so so it can compute the

1038
00:42:15,119 --> 00:42:17,880
cds1 and cds2 message even without the

1039
00:42:17,880 --> 00:42:20,820
witness so uh if you see the protocol uh

1040
00:42:20,820 --> 00:42:23,400
it doesn't depend on the inputs so the

1041
00:42:23,400 --> 00:42:24,900
first and second round message is like

1042
00:42:24,900 --> 00:42:27,180
pre-processing so yeah it only depends

1043
00:42:27,180 --> 00:42:28,920
on the security parameter

1044
00:42:28,920 --> 00:42:31,260
I see thanks

1045
00:42:31,260 --> 00:42:35,240
let's thank pratik once again

1046
00:43:20,359 --> 00:43:23,760
okay so we have the last Talk of the day

1047
00:43:23,760 --> 00:43:26,220
uh on perfectly secure two-party

1048
00:43:26,220 --> 00:43:27,480
computation for symmetric

1049
00:43:27,480 --> 00:43:28,980
functionalities with correlated

1050
00:43:28,980 --> 00:43:31,319
Randomness uh the talk would be given by

1051
00:43:31,319 --> 00:43:33,960
Barrel on okay so thank you and today

1052
00:43:33,960 --> 00:43:35,520
I'm going to talk about perfectly secure

1053
00:43:35,520 --> 00:43:37,319
to public computation and we'll call it

1054
00:43:37,319 --> 00:43:39,359
at Randomness and this is Joint work

1055
00:43:39,359 --> 00:43:42,540
with organisms

1056
00:43:44,880 --> 00:43:47,880
okay so in this uh in this work we

1057
00:43:47,880 --> 00:43:49,859
consider secure two-party computation

1058
00:43:49,859 --> 00:43:52,440
here we have two parties uh Homer and

1059
00:43:52,440 --> 00:43:54,900
March each holding his own input

1060
00:43:54,900 --> 00:43:57,240
they interact in some protocol until the

1061
00:43:57,240 --> 00:44:00,420
the plane an output

1062
00:44:00,420 --> 00:44:03,180
and we want this protocol to be secure

1063
00:44:03,180 --> 00:44:05,460
specifically in this uh in our work we

1064
00:44:05,460 --> 00:44:07,740
consider perfect security and to Define

1065
00:44:07,740 --> 00:44:11,099
it we compare the real world to an

1066
00:44:11,099 --> 00:44:13,319
idealized version of the computation

1067
00:44:13,319 --> 00:44:15,780
where the parties have access to a

1068
00:44:15,780 --> 00:44:17,280
trusted party that does the computation

1069
00:44:17,280 --> 00:44:19,260
for them so they send the The Trusted

1070
00:44:19,260 --> 00:44:22,140
party their inputs and receive an output

1071
00:44:22,140 --> 00:44:23,819
and we said that the protocol is

1072
00:44:23,819 --> 00:44:25,800
perfectly secure for any adversary

1073
00:44:25,800 --> 00:44:27,780
corrupting uh one of the parties in the

1074
00:44:27,780 --> 00:44:29,599
real world there exists simulator

1075
00:44:29,599 --> 00:44:32,940
corrupting uh one of the same party in

1076
00:44:32,940 --> 00:44:35,520
the ideal World such that the tools are

1077
00:44:35,520 --> 00:44:37,680
identically distributed

1078
00:44:37,680 --> 00:44:39,240
so this seems like a very strong

1079
00:44:39,240 --> 00:44:41,099
definition we we don't have enough

1080
00:44:41,099 --> 00:44:43,740
majority we require perfect security

1081
00:44:43,740 --> 00:44:47,520
so we consider an augmentation of the

1082
00:44:47,520 --> 00:44:49,740
real world where the parties have access

1083
00:44:49,740 --> 00:44:52,859
to another access to the correlated

1084
00:44:52,859 --> 00:44:54,119
randomness

1085
00:44:54,119 --> 00:44:57,300
so here uh before the parties receive

1086
00:44:57,300 --> 00:44:58,500
their inputs

1087
00:44:58,500 --> 00:45:01,200
they receive correlated Randomness R1

1088
00:45:01,200 --> 00:45:04,319
and R2 that are currently in some way

1089
00:45:04,319 --> 00:45:06,060
that are completely independent of their

1090
00:45:06,060 --> 00:45:08,579
inputs but may depend on the function

1091
00:45:08,579 --> 00:45:10,680
after they receive the randomness the

1092
00:45:10,680 --> 00:45:13,200
parties received their inputs then then

1093
00:45:13,200 --> 00:45:15,180
they interact in some way and obtain an

1094
00:45:15,180 --> 00:45:16,740
output

1095
00:45:16,740 --> 00:45:18,359
so this is the model that we consider

1096
00:45:18,359 --> 00:45:20,819
and we want to figure out which

1097
00:45:20,819 --> 00:45:22,800
functionalities can be computed with

1098
00:45:22,800 --> 00:45:24,839
perfect security given some qualitative

1099
00:45:24,839 --> 00:45:26,760
randomness

1100
00:45:26,760 --> 00:45:28,680
let me talk about some previous results

1101
00:45:28,680 --> 00:45:31,260
so if we had the multiple in the

1102
00:45:31,260 --> 00:45:33,420
multi-parties I think if there was a lot

1103
00:45:33,420 --> 00:45:35,940
of honest part specifically more than

1104
00:45:35,940 --> 00:45:37,260
two-thirds of the parties are honest

1105
00:45:37,260 --> 00:45:39,839
then classical result of bjw and CCD

1106
00:45:39,839 --> 00:45:41,460
shows that everything can be computed

1107
00:45:41,460 --> 00:45:43,079
with perfect security

1108
00:45:43,079 --> 00:45:45,119
and then this is it can this has been

1109
00:45:45,119 --> 00:45:47,220
holding the plane model without quality

1110
00:45:47,220 --> 00:45:49,440
abundance

1111
00:45:49,440 --> 00:45:51,720
and in the two parties we have the

1112
00:45:51,720 --> 00:45:54,420
result by with melgarian passing

1113
00:45:54,420 --> 00:45:56,579
chernowski and they showed the two

1114
00:45:56,579 --> 00:45:57,359
results

1115
00:45:57,359 --> 00:46:00,000
the first result shows that if only one

1116
00:46:00,000 --> 00:46:02,040
of the parties is supposed to receive

1117
00:46:02,040 --> 00:46:04,260
the output then any functionality can be

1118
00:46:04,260 --> 00:46:06,540
computed given the appropriate called

1119
00:46:06,540 --> 00:46:08,819
randomness

1120
00:46:08,819 --> 00:46:10,980
however if both part is supposed to

1121
00:46:10,980 --> 00:46:13,319
receive the output then Excel cannot be

1122
00:46:13,319 --> 00:46:14,819
computed regardless of the correlation

1123
00:46:14,819 --> 00:46:16,020
that they have

1124
00:46:16,020 --> 00:46:18,359
and in fact the the impossibility even

1125
00:46:18,359 --> 00:46:20,160
rules out the weaker security notion

1126
00:46:20,160 --> 00:46:22,280
called security with about where the

1127
00:46:22,280 --> 00:46:24,780
adversary May abroad we allow it to

1128
00:46:24,780 --> 00:46:26,400
abort and prevent the uncertainty from

1129
00:46:26,400 --> 00:46:28,319
receiving the output

1130
00:46:28,319 --> 00:46:29,540
because

1131
00:46:29,540 --> 00:46:32,460
so this was the this is what was known

1132
00:46:32,460 --> 00:46:34,920
so let me talk about what we do in this

1133
00:46:34,920 --> 00:46:37,020
work we have two main results

1134
00:46:37,020 --> 00:46:38,579
the first result is the complete

1135
00:46:38,579 --> 00:46:40,500
characterization of which symmetric

1136
00:46:40,500 --> 00:46:42,780
functionality is with up to four outputs

1137
00:46:42,780 --> 00:46:46,140
can be computed with perfect security

1138
00:46:46,140 --> 00:46:48,720
and in fact a positive results of the

1139
00:46:48,720 --> 00:46:50,339
without quality Randomness and the

1140
00:46:50,339 --> 00:46:52,740
negative results similarly to the Ishita

1141
00:46:52,740 --> 00:46:54,540
result called regardless of the

1142
00:46:54,540 --> 00:46:56,220
correlation and it falls out security

1143
00:46:56,220 --> 00:46:58,500
with a boat

1144
00:46:58,500 --> 00:47:00,420
so now I want to talk about which

1145
00:47:00,420 --> 00:47:02,640
functions can be character can be

1146
00:47:02,640 --> 00:47:05,880
computed so I'm going to view a function

1147
00:47:05,880 --> 00:47:07,800
as the Matrix where one part is chooses

1148
00:47:07,800 --> 00:47:10,380
a row the other particles is a column

1149
00:47:10,380 --> 00:47:12,060
so the first cluster functionality is

1150
00:47:12,060 --> 00:47:13,619
the computer this is the trivial one

1151
00:47:13,619 --> 00:47:16,200
when uh only one penalty can affect the

1152
00:47:16,200 --> 00:47:17,819
output

1153
00:47:17,819 --> 00:47:19,619
the second class is what we call the

1154
00:47:19,619 --> 00:47:21,300
spinal functionalities and the reason we

1155
00:47:21,300 --> 00:47:22,680
call them spiral is because they have

1156
00:47:22,680 --> 00:47:25,200
this nice spiral structure inside the

1157
00:47:25,200 --> 00:47:27,060
Matrix

1158
00:47:27,060 --> 00:47:29,339
and finally we have the function the

1159
00:47:29,339 --> 00:47:30,900
function that is given by this Matrix

1160
00:47:30,900 --> 00:47:32,880
which we call transparent transfer and

1161
00:47:32,880 --> 00:47:34,800
the reason for this naming is because it

1162
00:47:34,800 --> 00:47:36,359
can be defined very similarly to

1163
00:47:36,359 --> 00:47:38,579
oblivious transfer however here the

1164
00:47:38,579 --> 00:47:40,200
choice bit of the receiver is is

1165
00:47:40,200 --> 00:47:42,000
revealed to the Sandal

1166
00:47:42,000 --> 00:47:44,579
so we showed that only these three types

1167
00:47:44,579 --> 00:47:46,859
of functions can be computed with

1168
00:47:46,859 --> 00:47:48,900
perfect security

1169
00:47:48,900 --> 00:47:52,140
our second result we showed that if a

1170
00:47:52,140 --> 00:47:54,119
function contains an embedded X or an

1171
00:47:54,119 --> 00:47:56,099
embedded end then it cannot be computed

1172
00:47:56,099 --> 00:47:58,020
with perfect security and this solves

1173
00:47:58,020 --> 00:47:59,579
regardless of the number of inputs and

1174
00:47:59,579 --> 00:48:01,380
just to exemplify what an embedded and

1175
00:48:01,380 --> 00:48:04,079
an xor means it just means that you we

1176
00:48:04,079 --> 00:48:06,359
can find two input two rows and two

1177
00:48:06,359 --> 00:48:08,040
common factors of the four and output

1178
00:48:08,040 --> 00:48:11,480
correspond to an Excel over net

1179
00:48:11,700 --> 00:48:13,140
all right so now I want to talk about

1180
00:48:13,140 --> 00:48:16,619
the impossibility before going to our

1181
00:48:16,619 --> 00:48:18,420
own possibility as a warm-up I'm going

1182
00:48:18,420 --> 00:48:21,839
to talk about the proof of impossibility

1183
00:48:21,839 --> 00:48:24,440
of EXO

1184
00:48:24,560 --> 00:48:26,520
contradiction that there exists a

1185
00:48:26,520 --> 00:48:28,440
protocol Computing it and let's consider

1186
00:48:28,440 --> 00:48:30,119
an execution where the inputs of both

1187
00:48:30,119 --> 00:48:33,420
parties are sample uniform near trend

1188
00:48:33,420 --> 00:48:36,119
so the main observation in the proof is

1189
00:48:36,119 --> 00:48:38,700
to notice that there exists this first

1190
00:48:38,700 --> 00:48:42,000
round where the Homer knows the output

1191
00:48:42,000 --> 00:48:44,040
regardless of the input X and Y and

1192
00:48:44,040 --> 00:48:46,440
regardless of the randomness R1 and R2

1193
00:48:46,440 --> 00:48:47,940
and the reason there exists this round

1194
00:48:47,940 --> 00:48:49,619
is because the last round is an example

1195
00:48:49,619 --> 00:48:51,960
of such Ram so there must have been this

1196
00:48:51,960 --> 00:48:54,260
first time where this happens

1197
00:48:54,260 --> 00:48:56,760
and similarly there exists this first

1198
00:48:56,760 --> 00:48:59,940
round will merge knows the the output

1199
00:48:59,940 --> 00:49:01,140
regardless of all the inputs and

1200
00:49:01,140 --> 00:49:02,579
randomness

1201
00:49:02,579 --> 00:49:04,740
and let's assume that the owner learns

1202
00:49:04,740 --> 00:49:06,660
first for this case

1203
00:49:06,660 --> 00:49:10,140
so how do we Define the attacker so he

1204
00:49:10,140 --> 00:49:11,760
will play honestly according to the

1205
00:49:11,760 --> 00:49:13,980
specifications of the protocol until he

1206
00:49:13,980 --> 00:49:16,500
learns the apple and this is what we use

1207
00:49:16,500 --> 00:49:18,359
the fact that this is perfect security

1208
00:49:18,359 --> 00:49:20,700
and not computational because owner can

1209
00:49:20,700 --> 00:49:23,040
actually know that he knows the output

1210
00:49:23,040 --> 00:49:25,020
and the reason is that because we're

1211
00:49:25,020 --> 00:49:27,420
dealing with profit security there is no

1212
00:49:27,420 --> 00:49:29,099
security parameter the real and Ideal

1213
00:49:29,099 --> 00:49:31,500
World are identically distributed so we

1214
00:49:31,500 --> 00:49:33,000
can just go over all possible honest

1215
00:49:33,000 --> 00:49:34,920
continuations of the protocol and figure

1216
00:49:34,920 --> 00:49:37,440
out the the output so see if all of them

1217
00:49:37,440 --> 00:49:41,640
all of the possible outputs are the same

1218
00:49:41,640 --> 00:49:42,960
but what it does with this information

1219
00:49:42,960 --> 00:49:45,540
if the output is clue is lagging so it

1220
00:49:45,540 --> 00:49:48,060
wants zero then it will send the real

1221
00:49:48,060 --> 00:49:49,619
message and they continue to play

1222
00:49:49,619 --> 00:49:51,359
honestly until the end

1223
00:49:51,359 --> 00:49:53,700
and if it says that the output is one

1224
00:49:53,700 --> 00:49:55,560
then it will say then it will send only

1225
00:49:55,560 --> 00:49:58,099
random messages

1226
00:49:58,140 --> 00:50:00,740
so why does this work well intuitively

1227
00:50:00,740 --> 00:50:03,660
uh Marge still doesn't know the output

1228
00:50:03,660 --> 00:50:05,880
for some choice of Y and out also the

1229
00:50:05,880 --> 00:50:07,260
existing probability that she haven't

1230
00:50:07,260 --> 00:50:09,119
learned the output yet

1231
00:50:09,119 --> 00:50:11,220
this means that if the output is

1232
00:50:11,220 --> 00:50:13,500
supposed to be one then there exists a

1233
00:50:13,500 --> 00:50:14,819
continuation that will cause it to

1234
00:50:14,819 --> 00:50:16,560
Output zero

1235
00:50:16,560 --> 00:50:18,300
and because I want to send the messages

1236
00:50:18,300 --> 00:50:19,859
that are completely random this means

1237
00:50:19,859 --> 00:50:21,240
that there exists some non-zero

1238
00:50:21,240 --> 00:50:23,700
probability of increasing the chance of

1239
00:50:23,700 --> 00:50:25,680
margin putting zero

1240
00:50:25,680 --> 00:50:27,240
so overall when you do the computation

1241
00:50:27,240 --> 00:50:28,619
we can see that merge output zero

1242
00:50:28,619 --> 00:50:30,180
probability that is slightly more than

1243
00:50:30,180 --> 00:50:31,920
one half

1244
00:50:31,920 --> 00:50:33,660
and when we compare to the ideal world

1245
00:50:33,660 --> 00:50:36,300
we can say that there is no Simulator

1246
00:50:36,300 --> 00:50:38,220
for this attacker because the output in

1247
00:50:38,220 --> 00:50:39,839
the ideal world is just a uniform random

1248
00:50:39,839 --> 00:50:41,099
beat

1249
00:50:41,099 --> 00:50:42,300
later

1250
00:50:42,300 --> 00:50:44,760
all right so why does this fail for end

1251
00:50:44,760 --> 00:50:46,500
why can't we just simply take this and

1252
00:50:46,500 --> 00:50:48,540
apply it for any other function so as an

1253
00:50:48,540 --> 00:50:50,640
example let's consider and if we do the

1254
00:50:50,640 --> 00:50:52,140
exactly the same computation in the real

1255
00:50:52,140 --> 00:50:53,700
world we can see that Mouse will output

1256
00:50:53,700 --> 00:50:55,200
zero of probability that is slightly

1257
00:50:55,200 --> 00:50:57,300
more than three quarters

1258
00:50:57,300 --> 00:50:59,880
however in the ideal world the malicious

1259
00:50:59,880 --> 00:51:02,339
simulator can change its input

1260
00:51:02,339 --> 00:51:04,559
so this means that he might be able to

1261
00:51:04,559 --> 00:51:07,020
send zero with certain probabilities

1262
00:51:07,020 --> 00:51:09,480
such that the output in in the ideal one

1263
00:51:09,480 --> 00:51:10,920
will be zero with exactly the same

1264
00:51:10,920 --> 00:51:12,420
probability as in the ideal world you

1265
00:51:12,420 --> 00:51:13,920
can just increase the probability of

1266
00:51:13,920 --> 00:51:15,900
zero

1267
00:51:15,900 --> 00:51:19,380
and considering the same with the same

1268
00:51:19,380 --> 00:51:21,000
argument with an adversary that tries to

1269
00:51:21,000 --> 00:51:23,460
bias clothes one or you can also do the

1270
00:51:23,460 --> 00:51:25,740
same argument and see that there might

1271
00:51:25,740 --> 00:51:27,480
exist a simulator

1272
00:51:27,480 --> 00:51:29,400
so this uh completely first so we need

1273
00:51:29,400 --> 00:51:30,839
something else

1274
00:51:30,839 --> 00:51:32,700
and what we do is make the following

1275
00:51:32,700 --> 00:51:35,700
observation and it's that sending zero

1276
00:51:35,700 --> 00:51:37,079
in the ideal wall

1277
00:51:37,079 --> 00:51:39,960
reveals no information to the simulator

1278
00:51:39,960 --> 00:51:41,700
so this suggests that we should also let

1279
00:51:41,700 --> 00:51:43,680
the adversary to try and guess the input

1280
00:51:43,680 --> 00:51:45,300
of the other party

1281
00:51:45,300 --> 00:51:47,280
and indeed when we do the computation

1282
00:51:47,280 --> 00:51:49,380
this time we can see that the output of

1283
00:51:49,380 --> 00:51:51,300
merge is zero and the adversary is

1284
00:51:51,300 --> 00:51:54,599
successfully gets gas their input is uh

1285
00:51:54,599 --> 00:51:55,980
the probability of this happening is

1286
00:51:55,980 --> 00:51:57,839
slightly more than one half

1287
00:51:57,839 --> 00:51:59,400
and on the other hand in the ideal World

1288
00:51:59,400 --> 00:52:02,099
sending zero with no information so the

1289
00:52:02,099 --> 00:52:03,599
adversary will guess for probability it

1290
00:52:03,599 --> 00:52:05,880
most on half and sending one will cause

1291
00:52:05,880 --> 00:52:08,220
the output to be a uniform randomly so

1292
00:52:08,220 --> 00:52:10,859
overall no simulator will be able to go

1293
00:52:10,859 --> 00:52:14,099
past one half in the ideal world

1294
00:52:14,099 --> 00:52:16,859
and we use this idea in order to

1295
00:52:16,859 --> 00:52:19,200
generalize this to other functions but I

1296
00:52:19,200 --> 00:52:21,119
won't go into all the details but

1297
00:52:21,119 --> 00:52:23,660
generally we consider

1298
00:52:23,660 --> 00:52:26,339
the parties using inputs that are chosen

1299
00:52:26,339 --> 00:52:28,859
uniformly at random from some subsets of

1300
00:52:28,859 --> 00:52:31,559
their domains and we consider investors

1301
00:52:31,559 --> 00:52:34,619
that try to buy us towards a subset of

1302
00:52:34,619 --> 00:52:36,240
the Apple jet Prime so if this is that

1303
00:52:36,240 --> 00:52:37,380
the output is supposed to be in that

1304
00:52:37,380 --> 00:52:38,880
Prime he will continue to play honestly

1305
00:52:38,880 --> 00:52:41,040
from that special one from before and

1306
00:52:41,040 --> 00:52:42,780
otherwise you will send completely

1307
00:52:42,780 --> 00:52:44,300
random messages

1308
00:52:44,300 --> 00:52:47,099
and we use this attack and we then

1309
00:52:47,099 --> 00:52:49,079
identify where this when this attack

1310
00:52:49,079 --> 00:52:50,579
actually works because it doesn't block

1311
00:52:50,579 --> 00:52:52,319
all the time and figure out when there

1312
00:52:52,319 --> 00:52:54,420
exists this subset X Prime y Prime and Z

1313
00:52:54,420 --> 00:52:56,940
Prime such that the attacker actually

1314
00:52:56,940 --> 00:52:59,339
works

1315
00:52:59,339 --> 00:53:01,680
so to summarize we consider perfect

1316
00:53:01,680 --> 00:53:04,140
security for two parties with quarter

1317
00:53:04,140 --> 00:53:05,819
Randomness we gave a complete

1318
00:53:05,819 --> 00:53:07,319
characterization for functionalities

1319
00:53:07,319 --> 00:53:10,920
with up to four outputs and all of our

1320
00:53:10,920 --> 00:53:12,720
negative results came from a more

1321
00:53:12,720 --> 00:53:15,300
General impossibility which also from

1322
00:53:15,300 --> 00:53:17,280
which we also got our embedded Excel and

1323
00:53:17,280 --> 00:53:19,440
embedded and to be impossible to compute

1324
00:53:19,440 --> 00:53:21,000
with perfect security

1325
00:53:21,000 --> 00:53:22,920
I haven't talked about it but uh just

1326
00:53:22,920 --> 00:53:26,160
like each other our negative results uh

1327
00:53:26,160 --> 00:53:28,619
world world without security with a boat

1328
00:53:28,619 --> 00:53:30,660
and we also showed that there are some

1329
00:53:30,660 --> 00:53:33,180
interesting functions that can be

1330
00:53:33,180 --> 00:53:35,400
computed with perfect security and in

1331
00:53:35,400 --> 00:53:37,559
fact a positive result holds even in the

1332
00:53:37,559 --> 00:53:40,319
plane model without correct advantages

1333
00:53:40,319 --> 00:53:43,520
and that's it thank you

1334
00:53:47,220 --> 00:53:51,680
thank you uh does anyone have questions

1335
00:53:57,540 --> 00:53:59,700
thanks for the talk

1336
00:53:59,700 --> 00:54:01,980
um so this seems pretty similar to all

1337
00:54:01,980 --> 00:54:03,119
this work on like for which

1338
00:54:03,119 --> 00:54:04,859
functionalities can you get fairness

1339
00:54:04,859 --> 00:54:06,540
even with the business majority setting

1340
00:54:06,540 --> 00:54:07,559
right you have I don't know if you're

1341
00:54:07,559 --> 00:54:09,000
familiar with this works that if you

1342
00:54:09,000 --> 00:54:10,680
have an embedded text or you can also

1343
00:54:10,680 --> 00:54:13,020
not achieve fairness and so on so yeah

1344
00:54:13,020 --> 00:54:15,000
if we're talking about the computational

1345
00:54:15,000 --> 00:54:17,460
settings so in those the computational

1346
00:54:17,460 --> 00:54:19,319
setting it's a bit different because in

1347
00:54:19,319 --> 00:54:21,119
the computational setting the adversary

1348
00:54:21,119 --> 00:54:23,940
it's not doesn't necessarily know that

1349
00:54:23,940 --> 00:54:25,980
he knows the output here we use the fact

1350
00:54:25,980 --> 00:54:28,500
that imperfect security can know that

1351
00:54:28,500 --> 00:54:31,200
okay so it's slightly different okay

1352
00:54:31,200 --> 00:54:31,980
okay

1353
00:54:31,980 --> 00:54:33,960
um could you provide I mean I maybe miss

1354
00:54:33,960 --> 00:54:36,720
this but why the limitation on four uh

1355
00:54:36,720 --> 00:54:40,559
outputs uh uh because when we try to

1356
00:54:40,559 --> 00:54:43,380
identify when this attack Works uh it

1357
00:54:43,380 --> 00:54:45,359
turns out to be much harder to analyze

1358
00:54:45,359 --> 00:54:48,720
for more than four outputs okay yeah

1359
00:54:48,720 --> 00:54:50,220
thank you

1360
00:54:50,220 --> 00:54:53,118
any other questions

1361
00:54:53,640 --> 00:54:56,099
I just had a quick one uh about the

1362
00:54:56,099 --> 00:54:58,260
corruption model like is it adaptive

1363
00:54:58,260 --> 00:55:00,900
corruption or no just the two party One

1364
00:55:00,900 --> 00:55:04,079
Core option oh okay testing

1365
00:55:04,079 --> 00:55:07,260
all right yeah if not uh let's thank bar

1366
00:55:07,260 --> 00:55:10,579
and all the speakers of the session

