1
00:00:00,000 --> 00:00:03,300
and on OT peer and secret sharing our

2
00:00:03,300 --> 00:00:04,740
first speaker will be Shani van David

3
00:00:04,740 --> 00:00:06,839
telling us about verifiable private

4
00:00:06,839 --> 00:00:08,460
information retrieval whenever you're

5
00:00:08,460 --> 00:00:09,540
ready

6
00:00:09,540 --> 00:00:11,580
okay hi I'm going to talk about

7
00:00:11,580 --> 00:00:13,759
verifiable private information

8
00:00:13,759 --> 00:00:16,560
David and this is Joint work with uh

9
00:00:16,560 --> 00:00:18,740
yeah

10
00:00:19,140 --> 00:00:21,180
so uh the entire talk is about

11
00:00:21,180 --> 00:00:23,760
strengthening the the standard pill that

12
00:00:23,760 --> 00:00:25,800
we all know so I will start by defining

13
00:00:25,800 --> 00:00:27,900
fear and emphasizing the properties that

14
00:00:27,900 --> 00:00:29,039
we care about

15
00:00:29,039 --> 00:00:31,500
so in a style of field protocol we have

16
00:00:31,500 --> 00:00:33,840
a client and a server and the server

17
00:00:33,840 --> 00:00:36,239
holds some database and the client holds

18
00:00:36,239 --> 00:00:38,940
an index to a role in the database now

19
00:00:38,940 --> 00:00:40,620
at the beginning of the protocol the

20
00:00:40,620 --> 00:00:42,780
client generates some query and a

21
00:00:42,780 --> 00:00:45,180
decryption key and send the query to the

22
00:00:45,180 --> 00:00:47,579
server the server sends back some answer

23
00:00:47,579 --> 00:00:51,120
and the client equipped the answer using

24
00:00:51,120 --> 00:00:53,340
his decryption key and gets the relevant

25
00:00:53,340 --> 00:00:56,100
role now uh the properties that we care

26
00:00:56,100 --> 00:00:59,460
about is a sub linear Communications so

27
00:00:59,460 --> 00:01:01,500
we want the answer to be sub linear in

28
00:01:01,500 --> 00:01:04,379
the size of the database this property

29
00:01:04,379 --> 00:01:06,780
makes appear non-trivial otherwise the

30
00:01:06,780 --> 00:01:09,600
server congestions entire database

31
00:01:09,600 --> 00:01:11,700
and the second property that we care

32
00:01:11,700 --> 00:01:15,180
about is client privacy so uh we want Q

33
00:01:15,180 --> 00:01:17,880
to hide I uh this was the pure

34
00:01:17,880 --> 00:01:19,799
definition and now we will see some

35
00:01:19,799 --> 00:01:22,619
usage of Peel and let's say that we have

36
00:01:22,619 --> 00:01:25,680
a Wikipedia page and our client wants to

37
00:01:25,680 --> 00:01:27,240
get some information about the moon

38
00:01:27,240 --> 00:01:29,520
landing well it's clear why we can use

39
00:01:29,520 --> 00:01:31,259
peer in order to protect the client

40
00:01:31,259 --> 00:01:33,780
privacy so that the server holding a

41
00:01:33,780 --> 00:01:35,939
database with articles will not be able

42
00:01:35,939 --> 00:01:38,460
to detect which article the client would

43
00:01:38,460 --> 00:01:41,700
like to get uh but what is missing from

44
00:01:41,700 --> 00:01:44,040
this example well

45
00:01:44,040 --> 00:01:44,939
um

46
00:01:44,939 --> 00:01:48,060
what about a malicious server serving a

47
00:01:48,060 --> 00:01:50,220
fake article about the moon landing

48
00:01:50,220 --> 00:01:52,740
being a conspiracy well the rest of the

49
00:01:52,740 --> 00:01:54,600
talk is going to be about how to protect

50
00:01:54,600 --> 00:01:57,180
the client from a malicious server using

51
00:01:57,180 --> 00:01:59,820
a bad database so before we introduce

52
00:01:59,820 --> 00:02:01,979
the new notion of peer

53
00:02:01,979 --> 00:02:04,079
um we will observe two use cases that

54
00:02:04,079 --> 00:02:05,759
will help us understand which properties

55
00:02:05,759 --> 00:02:07,439
we would like to achieve in our new

56
00:02:07,439 --> 00:02:09,119
notion of Peel

57
00:02:09,119 --> 00:02:12,060
so before we can talk about how to

58
00:02:12,060 --> 00:02:13,560
protect the client from a malicious

59
00:02:13,560 --> 00:02:16,739
server using a bad database we need to

60
00:02:16,739 --> 00:02:18,959
Define what is a good or bad database

61
00:02:18,959 --> 00:02:20,940
well this depend on on the application

62
00:02:20,940 --> 00:02:25,080
now back to our Wikipedia example let's

63
00:02:25,080 --> 00:02:27,000
say that the president of Wikipedia is

64
00:02:27,000 --> 00:02:28,980
reading and signing all the articles in

65
00:02:28,980 --> 00:02:31,260
the database in this case we will say

66
00:02:31,260 --> 00:02:33,120
that a good database is a database

67
00:02:33,120 --> 00:02:36,900
containing 100 signed articles now let's

68
00:02:36,900 --> 00:02:39,020
imagine that we have a malicious server

69
00:02:39,020 --> 00:02:41,040
holding a bad

70
00:02:41,040 --> 00:02:43,319
um a database with exactly one fake

71
00:02:43,319 --> 00:02:44,340
article

72
00:02:44,340 --> 00:02:46,560
now let's say that this is exactly the

73
00:02:46,560 --> 00:02:49,019
article that our client would like to

74
00:02:49,019 --> 00:02:51,540
get now it's clear why after uh

75
00:02:51,540 --> 00:02:54,239
decrypting the answer our call can

76
00:02:54,239 --> 00:02:56,580
detect that you got a fake article but

77
00:02:56,580 --> 00:02:58,800
what can he do it about it the client

78
00:02:58,800 --> 00:03:00,720
would like to tell the word that this

79
00:03:00,720 --> 00:03:03,000
server is bad and serving fake articles

80
00:03:03,000 --> 00:03:05,879
but even just saying that he got some

81
00:03:05,879 --> 00:03:08,640
fake article will uh will reveal his

82
00:03:08,640 --> 00:03:10,620
query to the server and the server will

83
00:03:10,620 --> 00:03:13,739
be able to detect which article the

84
00:03:13,739 --> 00:03:15,900
client requested

85
00:03:15,900 --> 00:03:18,420
so this leads us to our first goal which

86
00:03:18,420 --> 00:03:20,040
is being able to publish the

87
00:03:20,040 --> 00:03:21,900
verification results without

88
00:03:21,900 --> 00:03:24,720
compromising the client's privacy

89
00:03:24,720 --> 00:03:27,540
now this in this example the client

90
00:03:27,540 --> 00:03:29,879
could verify his answer but in the next

91
00:03:29,879 --> 00:03:31,920
example the client will not be able to

92
00:03:31,920 --> 00:03:33,720
verify his answer

93
00:03:33,720 --> 00:03:35,280
um since we would like to have some

94
00:03:35,280 --> 00:03:37,260
Global property on the entire database

95
00:03:37,260 --> 00:03:39,540
that do not depend only on the role that

96
00:03:39,540 --> 00:03:41,400
the client requested

97
00:03:41,400 --> 00:03:43,920
so back to our Wikipedia example we

98
00:03:43,920 --> 00:03:46,379
would like to have 100 signed articles

99
00:03:46,379 --> 00:03:48,180
but let's say that the president of

100
00:03:48,180 --> 00:03:50,580
Wikipedia is busy and can sign articles

101
00:03:50,580 --> 00:03:53,220
new articles right away in this case we

102
00:03:53,220 --> 00:03:55,319
would say that a good database is a

103
00:03:55,319 --> 00:03:58,080
database containing at least 99 signed

104
00:03:58,080 --> 00:04:00,599
articles now let's imagine that we have

105
00:04:00,599 --> 00:04:02,060
a malicious server

106
00:04:02,060 --> 00:04:04,739
server only fake articles in this case

107
00:04:04,739 --> 00:04:08,340
the client can't verify his answer then

108
00:04:08,340 --> 00:04:11,220
the server can always can always argue

109
00:04:11,220 --> 00:04:13,560
that the client asked for the one

110
00:04:13,560 --> 00:04:16,260
percent which is unsigned so this leads

111
00:04:16,260 --> 00:04:17,880
us to our second goal which is being

112
00:04:17,880 --> 00:04:21,000
able to verify some Global property that

113
00:04:21,000 --> 00:04:22,919
depends on the entire database and not

114
00:04:22,919 --> 00:04:24,300
only on the role that the client

115
00:04:24,300 --> 00:04:26,220
requested

116
00:04:26,220 --> 00:04:28,860
now our contribution in a nutshell uh

117
00:04:28,860 --> 00:04:30,840
the first contribution is that we

118
00:04:30,840 --> 00:04:32,880
introduced a new notion of peer which is

119
00:04:32,880 --> 00:04:35,540
very fiber appeal and the second

120
00:04:35,540 --> 00:04:37,440
contribution is that we give

121
00:04:37,440 --> 00:04:39,600
construction based on only on standard

122
00:04:39,600 --> 00:04:40,800
assumptions

123
00:04:40,800 --> 00:04:42,660
so in this talk I'm going to focus on

124
00:04:42,660 --> 00:04:45,600
the new notion of the refiable period

125
00:04:45,600 --> 00:04:47,639
um the syntax of verifiable private

126
00:04:47,639 --> 00:04:49,860
information retrieval or vpu is as

127
00:04:49,860 --> 00:04:52,259
follows we have a property on the entire

128
00:04:52,259 --> 00:04:54,720
database we have a client in a Cell well

129
00:04:54,720 --> 00:04:58,080
now the server holds a database that

130
00:04:58,080 --> 00:04:59,940
satisfies the property and the Clones

131
00:04:59,940 --> 00:05:02,040
hold some index to a row in the database

132
00:05:02,040 --> 00:05:04,860
at the beginning of the protocol the

133
00:05:04,860 --> 00:05:07,259
client generates some query decryption

134
00:05:07,259 --> 00:05:10,080
key and verification key and send the

135
00:05:10,080 --> 00:05:12,600
query to the server now the server sends

136
00:05:12,600 --> 00:05:15,720
back some answer and the client verifies

137
00:05:15,720 --> 00:05:17,780
the answer using his verification key

138
00:05:17,780 --> 00:05:20,759
and if the verification passes the

139
00:05:20,759 --> 00:05:22,860
clients decrypt the answer using his

140
00:05:22,860 --> 00:05:24,060
decryption key

141
00:05:24,060 --> 00:05:26,820
we have two Notions of security we have

142
00:05:26,820 --> 00:05:29,220
publicly verifiable deeper which means

143
00:05:29,220 --> 00:05:32,100
that the security still holds even given

144
00:05:32,100 --> 00:05:33,780
the verification key and we have

145
00:05:33,780 --> 00:05:36,060
privately verifiable VP which means that

146
00:05:36,060 --> 00:05:37,919
the verification key must be kept a

147
00:05:37,919 --> 00:05:40,740
secret in order for the security to hold

148
00:05:40,740 --> 00:05:42,720
now we are ready to talk about our

149
00:05:42,720 --> 00:05:45,720
requirements from the VP protocol so uh

150
00:05:45,720 --> 00:05:47,940
we want sublimear communication this is

151
00:05:47,940 --> 00:05:50,699
the same from the starter so from the I

152
00:05:50,699 --> 00:05:52,919
think the standard peer and we want

153
00:05:52,919 --> 00:05:55,139
client privacy we want you to hide I

154
00:05:55,139 --> 00:05:58,139
even given as a verification key this

155
00:05:58,139 --> 00:05:59,699
property allows us to publish the

156
00:05:59,699 --> 00:06:01,380
verification results without

157
00:06:01,380 --> 00:06:04,440
compromising the client privacy and the

158
00:06:04,440 --> 00:06:07,020
third property is security we would like

159
00:06:07,020 --> 00:06:09,000
to protect the client from a malicious

160
00:06:09,000 --> 00:06:11,759
server using a bad database but the

161
00:06:11,759 --> 00:06:13,500
problem with this approach is that

162
00:06:13,500 --> 00:06:15,900
malicious server does not necessarily

163
00:06:15,900 --> 00:06:18,600
hold a database for example a malicious

164
00:06:18,600 --> 00:06:20,639
server might do a mailing attack where

165
00:06:20,639 --> 00:06:22,620
he serves the client where he answers

166
00:06:22,620 --> 00:06:24,840
the client adaptively according to the

167
00:06:24,840 --> 00:06:27,539
query of the client now in order to

168
00:06:27,539 --> 00:06:29,460
solve the pro this problem we use the

169
00:06:29,460 --> 00:06:31,259
real ideal Paradigm that we all know

170
00:06:31,259 --> 00:06:34,259
from the MPC definition with some minor

171
00:06:34,259 --> 00:06:35,660
changes

172
00:06:35,660 --> 00:06:38,400
so I'm on I'm only going to introduce

173
00:06:38,400 --> 00:06:40,560
the idea words and the real world has

174
00:06:40,560 --> 00:06:43,440
the same flavor as in the standard MPC

175
00:06:43,440 --> 00:06:46,020
definition so in the real the ideal word

176
00:06:46,020 --> 00:06:48,360
I'm sorry we have a trusted party we

177
00:06:48,360 --> 00:06:50,699
have a client in a simulator and the

178
00:06:50,699 --> 00:06:53,039
client sends some index I to the tested

179
00:06:53,039 --> 00:06:55,139
party and the simulator send an entire

180
00:06:55,139 --> 00:06:57,840
database to The Trusted party now The

181
00:06:57,840 --> 00:07:00,120
Trusted party sends back to the client

182
00:07:00,120 --> 00:07:03,000
the database at location I if and only

183
00:07:03,000 --> 00:07:05,460
if the database satisfies the

184
00:07:05,460 --> 00:07:06,419
probability

185
00:07:06,419 --> 00:07:09,780
now the client outputs the input from

186
00:07:09,780 --> 00:07:11,580
The Trusted party and the simulator

187
00:07:11,580 --> 00:07:14,639
outputs that which should simulate

188
00:07:14,639 --> 00:07:17,460
um the view of the stairwell and now in

189
00:07:17,460 --> 00:07:19,860
the standard MPC definition we then have

190
00:07:19,860 --> 00:07:21,960
this joint distribution as the ideal

191
00:07:21,960 --> 00:07:24,000
distribution and in the video definition

192
00:07:24,000 --> 00:07:26,880
we then add the client output as the

193
00:07:26,880 --> 00:07:28,259
ideal distribution

194
00:07:28,259 --> 00:07:30,660
now this relaxation is necessary for us

195
00:07:30,660 --> 00:07:32,400
to achieve our results from kind of

196
00:07:32,400 --> 00:07:35,759
assumptions and it's not how to say that

197
00:07:35,759 --> 00:07:36,300
um

198
00:07:36,300 --> 00:07:38,520
this definition still captures all the

199
00:07:38,520 --> 00:07:40,380
standard use cases that we can think of

200
00:07:40,380 --> 00:07:43,800
regarding pill functionality and in

201
00:07:43,800 --> 00:07:45,960
order to get some intuition let's go

202
00:07:45,960 --> 00:07:47,880
back to our Wikipedia example where we

203
00:07:47,880 --> 00:07:51,240
want to add 99 signed articles in this

204
00:07:51,240 --> 00:07:54,120
case in these settings if the clients

205
00:07:54,120 --> 00:07:56,280
send some random query to The Trusted

206
00:07:56,280 --> 00:07:59,639
party he will get back a random it will

207
00:07:59,639 --> 00:08:01,139
get back a signed article with

208
00:08:01,139 --> 00:08:04,560
probability at least 0.99 and the same

209
00:08:04,560 --> 00:08:07,020
happens in the real world so the server

210
00:08:07,020 --> 00:08:09,479
can't serve a only fake articles anymore

211
00:08:09,479 --> 00:08:12,539
as we just saw

212
00:08:12,539 --> 00:08:14,520
um now this definition is still too

213
00:08:14,520 --> 00:08:16,860
strong and can be achieved using uh

214
00:08:16,860 --> 00:08:18,599
non-standard assumptions but we want to

215
00:08:18,599 --> 00:08:21,720
get people from standard assumptions so

216
00:08:21,720 --> 00:08:23,340
um and the reason why I say that this

217
00:08:23,340 --> 00:08:25,620
definition is too strong is that the The

218
00:08:25,620 --> 00:08:27,479
Vapor definitions that we just saw

219
00:08:27,479 --> 00:08:30,419
implies stocks for npn stocks for NPR

220
00:08:30,419 --> 00:08:31,919
are only known for non-standards

221
00:08:31,919 --> 00:08:34,440
assumptions such as heuristics and

222
00:08:34,440 --> 00:08:36,419
non-classifiable assumptions so we can't

223
00:08:36,419 --> 00:08:38,458
expect to get VP from standard

224
00:08:38,458 --> 00:08:39,479
assumptions

225
00:08:39,479 --> 00:08:41,159
now in order to make this definition

226
00:08:41,159 --> 00:08:43,620
work we need another relaxation and the

227
00:08:43,620 --> 00:08:45,540
next relaxation is about the class of

228
00:08:45,540 --> 00:08:48,000
properties that we are handling and the

229
00:08:48,000 --> 00:08:49,560
class of properties that we are handling

230
00:08:49,560 --> 00:08:52,380
is properties decidable on small state

231
00:08:52,380 --> 00:08:55,320
now we stay in the focus property Peak

232
00:08:55,320 --> 00:08:58,019
is decidable with state of size at most

233
00:08:58,019 --> 00:09:01,019
L if it is decidable using a turing

234
00:09:01,019 --> 00:09:03,180
machine M that treats the database once

235
00:09:03,180 --> 00:09:06,180
and maintains a state of size L between

236
00:09:06,180 --> 00:09:08,940
the rows now intuitively we have M steps

237
00:09:08,940 --> 00:09:11,100
and on each step the turing machine

238
00:09:11,100 --> 00:09:14,580
takes this input a state and one row and

239
00:09:14,580 --> 00:09:18,000
output the state and after M steps the

240
00:09:18,000 --> 00:09:20,160
last state will be accepting if and only

241
00:09:20,160 --> 00:09:22,920
if the database satisfies the property

242
00:09:22,920 --> 00:09:25,740
now is it this kind of properties is

243
00:09:25,740 --> 00:09:27,779
expressive and meaningful and let's see

244
00:09:27,779 --> 00:09:30,360
some examples on that uh so the first

245
00:09:30,360 --> 00:09:32,760
example that we saw was 100 sign

246
00:09:32,760 --> 00:09:35,160
articles in this case the only state

247
00:09:35,160 --> 00:09:37,260
that we need to maintain between the

248
00:09:37,260 --> 00:09:39,720
rows is the state indicating if we've

249
00:09:39,720 --> 00:09:42,360
already seen an unsigned article well

250
00:09:42,360 --> 00:09:44,040
this state is really small we can do it

251
00:09:44,040 --> 00:09:46,500
with just one bit and the second example

252
00:09:46,500 --> 00:09:49,459
that we saw is a uh that we wanted 99

253
00:09:49,459 --> 00:09:52,140
signed article and in all and in order

254
00:09:52,140 --> 00:09:54,959
to to verify this property the only

255
00:09:54,959 --> 00:09:56,760
state we need to maintain between the

256
00:09:56,760 --> 00:09:59,519
rows is a counter saying how many time

257
00:09:59,519 --> 00:10:01,860
or unsigned article we've already seen

258
00:10:01,860 --> 00:10:05,279
so this state is also small and is a

259
00:10:05,279 --> 00:10:07,560
logarithmic in the number of rows

260
00:10:07,560 --> 00:10:09,180
now we are ready to talk about our

261
00:10:09,180 --> 00:10:10,500
results

262
00:10:10,500 --> 00:10:13,200
so uh the first theorem says that for

263
00:10:13,200 --> 00:10:15,779
any L assuming two to there is the cure

264
00:10:15,779 --> 00:10:17,459
appear there exists a privately

265
00:10:17,459 --> 00:10:19,620
verifiable VP for every property

266
00:10:19,620 --> 00:10:22,580
decidable with state of size that's most

267
00:10:22,580 --> 00:10:25,260
simulation running time is 2 to the ol

268
00:10:25,260 --> 00:10:28,320
now the cool thing about this theorem is

269
00:10:28,320 --> 00:10:30,300
that we just we start with just the

270
00:10:30,300 --> 00:10:31,860
standard field and we get privately

271
00:10:31,860 --> 00:10:33,540
verifiable VP which is the stronger

272
00:10:33,540 --> 00:10:36,120
notion of peer and the thing to note

273
00:10:36,120 --> 00:10:38,459
about ethereum is that the security

274
00:10:38,459 --> 00:10:40,800
assumption every simulation running time

275
00:10:40,800 --> 00:10:44,160
of both depends exponentially on the

276
00:10:44,160 --> 00:10:48,060
size of the state so this term is great

277
00:10:48,060 --> 00:10:50,760
for a property is decidable in small

278
00:10:50,760 --> 00:10:53,339
state as we just saw now the second

279
00:10:53,339 --> 00:10:54,959
theorem

280
00:10:54,959 --> 00:10:58,140
so we say that for any L assuming 22's L

281
00:10:58,140 --> 00:11:01,200
hardness of dealing or lwe there exists

282
00:11:01,200 --> 00:11:03,360
a publicly verifiable VPN for every

283
00:11:03,360 --> 00:11:05,579
property decidable with state of size at

284
00:11:05,579 --> 00:11:07,320
most L where the stimulation running

285
00:11:07,320 --> 00:11:09,660
time is 2 to the ol now the difference

286
00:11:09,660 --> 00:11:11,640
between the two steerings is that before

287
00:11:11,640 --> 00:11:13,800
we started with spear and now we start

288
00:11:13,800 --> 00:11:16,860
with dealing or lwa and we get a

289
00:11:16,860 --> 00:11:19,440
stronger a security notion of VP which

290
00:11:19,440 --> 00:11:21,660
is publicly verifiable vapor

291
00:11:21,660 --> 00:11:24,600
now let's look at our Construction in a

292
00:11:24,600 --> 00:11:27,660
bear's eye view so we start with peer or

293
00:11:27,660 --> 00:11:30,360
dealing or lwe and we get back this we

294
00:11:30,360 --> 00:11:33,300
know from previous works so in our work

295
00:11:33,300 --> 00:11:35,880
we start from Bugs and we get VP

296
00:11:35,880 --> 00:11:38,399
and in the middle we actually go through

297
00:11:38,399 --> 00:11:42,000
a new object called local VP and we use

298
00:11:42,000 --> 00:11:44,640
this object as a step Stone to get to VP

299
00:11:44,640 --> 00:11:46,740
but we found that this object is

300
00:11:46,740 --> 00:11:49,560
Meaningful and useful on its own and I

301
00:11:49,560 --> 00:11:51,300
refer to the pen to the paper for

302
00:11:51,300 --> 00:11:53,040
further reading on the definition of

303
00:11:53,040 --> 00:11:55,079
local VPR

304
00:11:55,079 --> 00:11:55,980
um

305
00:11:55,980 --> 00:11:58,700
and now for our for our open questions

306
00:11:58,700 --> 00:12:03,480
okay so we would like to identify

307
00:12:03,480 --> 00:12:05,160
um other interesting class of global

308
00:12:05,160 --> 00:12:07,140
properties that can be proved based on

309
00:12:07,140 --> 00:12:09,079
standard assumptions

310
00:12:09,079 --> 00:12:12,060
and I would like to be able to simulate

311
00:12:12,060 --> 00:12:13,620
the view of the client and the server

312
00:12:13,620 --> 00:12:15,600
together as in the standout MPC

313
00:12:15,600 --> 00:12:16,860
definition

314
00:12:16,860 --> 00:12:20,540
so uh thank you

315
00:12:24,019 --> 00:12:28,339
questions sorry questions yeah

316
00:12:33,440 --> 00:12:36,120
is there a way to characterize the

317
00:12:36,120 --> 00:12:38,279
property class with respect to the

318
00:12:38,279 --> 00:12:40,800
snarks that will be implied like so if

319
00:12:40,800 --> 00:12:42,720
you have like vpa for a certain class of

320
00:12:42,720 --> 00:12:44,399
properties that it implies knocks for

321
00:12:44,399 --> 00:12:47,550
some restricted class of relations

322
00:12:47,550 --> 00:12:48,120
[Music]

323
00:12:48,120 --> 00:12:50,120
um

324
00:12:50,220 --> 00:12:53,279
well I need to think about it in general

325
00:12:53,279 --> 00:12:56,519
way but uh for the properties that like

326
00:12:56,519 --> 00:12:58,079
the class of properties that I described

327
00:12:58,079 --> 00:13:00,540
now we can know which class of

328
00:13:00,540 --> 00:13:03,000
properties we get in there in stock yeah

329
00:13:03,000 --> 00:13:05,100
I guess I'm asking if it is a way to get

330
00:13:05,100 --> 00:13:07,560
snacks for yeah for special cases like

331
00:13:07,560 --> 00:13:11,479
that's a good question thank you

332
00:13:11,519 --> 00:13:14,040
yes uh I had a similar question actually

333
00:13:14,040 --> 00:13:16,800
it's uh the Restriction that you placed

334
00:13:16,800 --> 00:13:18,839
in the theorem statement or the or the

335
00:13:18,839 --> 00:13:21,720
definition looks a lot like snarks for

336
00:13:21,720 --> 00:13:24,360
abounded non-deterministic space so I

337
00:13:24,360 --> 00:13:26,880
was wondering if maybe there would maybe

338
00:13:26,880 --> 00:13:28,139
you could even show a tight connection

339
00:13:28,139 --> 00:13:29,700
between snarks for Band The

340
00:13:29,700 --> 00:13:31,380
non-deterministic Space and this object

341
00:13:31,380 --> 00:13:33,899
can you start again oh sorry it's just

342
00:13:33,899 --> 00:13:35,579
the Restriction you placed in the

343
00:13:35,579 --> 00:13:37,320
definition that made it constructible

344
00:13:37,320 --> 00:13:39,000
based on standard assumptions it looked

345
00:13:39,000 --> 00:13:41,279
like if you thought about which snarks

346
00:13:41,279 --> 00:13:42,480
that implied it would basically shoot

347
00:13:42,480 --> 00:13:44,399
Starks for bounded non-deterministic

348
00:13:44,399 --> 00:13:46,579
space computation

349
00:13:46,579 --> 00:13:49,139
uh right you restricted the the

350
00:13:49,139 --> 00:13:51,120
properties to being properties where you

351
00:13:51,120 --> 00:13:53,579
read once and you have bounded memory

352
00:13:53,579 --> 00:13:56,820
this looks looks exactly like snarks for

353
00:13:56,820 --> 00:13:59,339
bounded non-deterministic space yeah the

354
00:13:59,339 --> 00:14:01,339
replacement on the ntisp right yeah yeah

355
00:14:01,339 --> 00:14:03,899
and so I was looking at the same results

356
00:14:03,899 --> 00:14:06,600
it's not better than that right but I

357
00:14:06,600 --> 00:14:08,100
was wondering if maybe

358
00:14:08,100 --> 00:14:11,820
I maybe they're maybe the right way to

359
00:14:11,820 --> 00:14:14,519
view this object is like is through the

360
00:14:14,519 --> 00:14:15,720
lens of snarks for bounded

361
00:14:15,720 --> 00:14:17,459
non-deterministic space Maybe instead of

362
00:14:17,459 --> 00:14:18,959
going through these other Notions there

363
00:14:18,959 --> 00:14:21,839
might be a tighter connection oh

364
00:14:21,839 --> 00:14:23,399
just just something to think about I'm

365
00:14:23,399 --> 00:14:26,839
not sure thank you other questions

366
00:14:28,079 --> 00:14:31,459
all right let's thank the speaker again

367
00:14:43,639 --> 00:14:47,220
so the next talk will be online uh gilad

368
00:14:47,220 --> 00:14:50,240
are you there hi yeah

369
00:14:50,240 --> 00:14:53,279
can you hear me yes

370
00:14:53,279 --> 00:14:56,339
okay great okay so uh next we'll have uh

371
00:14:56,339 --> 00:14:58,800
asharov speaking on asymptotically free

372
00:14:58,800 --> 00:15:01,260
broadcast and constant expected time via

373
00:15:01,260 --> 00:15:03,480
Pax VSS

374
00:15:03,480 --> 00:15:06,360
thank you so um I'm going to talk about

375
00:15:06,360 --> 00:15:08,100
a symptomatically free broadcast to

376
00:15:08,100 --> 00:15:11,339
constant expected time by Apache PSS

377
00:15:11,339 --> 00:15:13,680
um this is a joint walk with utaya Brahm

378
00:15:13,680 --> 00:15:16,139
and shravani shravani patil and Arpita

379
00:15:16,139 --> 00:15:17,339
Patra

380
00:15:17,339 --> 00:15:20,880
so the takeaway message of this talk

381
00:15:20,880 --> 00:15:22,199
thank you

382
00:15:22,199 --> 00:15:25,620
is that uh broadcast for perfect NPC is

383
00:15:25,620 --> 00:15:28,019
essentially free with some Styles over

384
00:15:28,019 --> 00:15:32,040
there so what we do is that we identify

385
00:15:32,040 --> 00:15:34,860
some specific communication pattern that

386
00:15:34,860 --> 00:15:37,440
is common in perfect NPC and we

387
00:15:37,440 --> 00:15:39,839
identified it actually a bottleneck and

388
00:15:39,839 --> 00:15:42,540
we're going to remove this backlink now

389
00:15:42,540 --> 00:15:44,940
this takeaway message already tells us

390
00:15:44,940 --> 00:15:48,120
what is our what is our setting cell

391
00:15:48,120 --> 00:15:49,639
setting is perfect and PC

392
00:15:49,639 --> 00:15:52,800
computationally unbounded adversary zero

393
00:15:52,800 --> 00:15:55,500
probability of Arrow and optimal

394
00:15:55,500 --> 00:15:57,420
resilience namely the number of

395
00:15:57,420 --> 00:16:00,180
Corruptions is at most one-third of the

396
00:16:00,180 --> 00:16:01,760
participants

397
00:16:01,760 --> 00:16:05,459
so uh let's take a look at the protocol

398
00:16:05,459 --> 00:16:08,100
in this uh in this setting let's take a

399
00:16:08,100 --> 00:16:11,100
look at vgw so we have in parties and

400
00:16:11,100 --> 00:16:12,180
each party

401
00:16:12,180 --> 00:16:15,060
at the first round is gonna secretary's

402
00:16:15,060 --> 00:16:17,279
inputs to all other parties because we

403
00:16:17,279 --> 00:16:19,139
are in the militia setting I'm gonna

404
00:16:19,139 --> 00:16:21,360
secretary my input using a verifiable

405
00:16:21,360 --> 00:16:24,120
secretary the cost of verifiable secret

406
00:16:24,120 --> 00:16:26,519
sharing is like I have this bivaric

407
00:16:26,519 --> 00:16:28,279
polynomial I'm sending each party

408
00:16:28,279 --> 00:16:31,079
shelled by valid polynomials about this

409
00:16:31,079 --> 00:16:33,899
exchanged uh complain on each other the

410
00:16:33,899 --> 00:16:37,139
broadcast the the dealer has to like uh

411
00:16:37,139 --> 00:16:40,079
publicly reveal shells of others so the

412
00:16:40,079 --> 00:16:42,959
cost is N squared messages although the

413
00:16:42,959 --> 00:16:45,839
point of point-to-point channels and the

414
00:16:45,839 --> 00:16:47,820
dealer might need to broadcast also N

415
00:16:47,820 --> 00:16:49,920
squared messages out of the broadcast

416
00:16:49,920 --> 00:16:50,940
channel

417
00:16:50,940 --> 00:16:53,880
now we have each part is going to do it

418
00:16:53,880 --> 00:16:57,720
in parallel so what we have in fact is

419
00:16:57,720 --> 00:17:00,839
that total communication is NQ point to

420
00:17:00,839 --> 00:17:03,300
point plus NQ broadcast

421
00:17:03,300 --> 00:17:06,000
now I want to implement this broadcast

422
00:17:06,000 --> 00:17:08,040
I want to simulate it using the

423
00:17:08,040 --> 00:17:10,319
point-to-point channels so because each

424
00:17:10,319 --> 00:17:13,199
part is supposed to receive n Cube

425
00:17:13,199 --> 00:17:16,980
message the best the most ideal if I had

426
00:17:16,980 --> 00:17:18,660
a trusted body that implements for me

427
00:17:18,660 --> 00:17:21,240
the broadcast the best we can hope for

428
00:17:21,240 --> 00:17:23,459
is n to the four if each part is

429
00:17:23,459 --> 00:17:25,380
supposed to receiving Cube and we are n

430
00:17:25,380 --> 00:17:27,299
part is the total communication is then

431
00:17:27,299 --> 00:17:29,880
to the fourth now

432
00:17:29,880 --> 00:17:31,980
um this communication pattern that we

433
00:17:31,980 --> 00:17:34,440
see here I'm going to denote it as n

434
00:17:34,440 --> 00:17:36,840
broadcast N squared so we have

435
00:17:36,840 --> 00:17:40,620
10 parties that in parallel each one of

436
00:17:40,620 --> 00:17:42,480
them broadcast the message of size n

437
00:17:42,480 --> 00:17:44,940
square and we're going to study this

438
00:17:44,940 --> 00:17:48,419
specific uh communication pattern

439
00:17:48,419 --> 00:17:50,700
so what is the state of the out

440
00:17:50,700 --> 00:17:52,980
so if I want to implement this broadcast

441
00:17:52,980 --> 00:17:54,960
using point-to-point channels there are

442
00:17:54,960 --> 00:17:57,600
two classes of protocols one is

443
00:17:57,600 --> 00:18:00,600
efficient but slow and another one is

444
00:18:00,600 --> 00:18:03,780
fast but inefficient let's explain so

445
00:18:03,780 --> 00:18:05,660
the first class of

446
00:18:05,660 --> 00:18:08,940
protocols actually achieve the best that

447
00:18:08,940 --> 00:18:10,620
we can hope for in terms of

448
00:18:10,620 --> 00:18:12,600
communication complexity it's going to

449
00:18:12,600 --> 00:18:15,480
be n to deform but the round complexity

450
00:18:15,480 --> 00:18:17,400
is going to be very slow it's going to

451
00:18:17,400 --> 00:18:19,320
be linear in the number of puppies

452
00:18:19,320 --> 00:18:21,600
on the other end the fast between

453
00:18:21,600 --> 00:18:23,280
efficients those are the works of

454
00:18:23,280 --> 00:18:25,260
federal and mikali and Captain Cook

455
00:18:25,260 --> 00:18:27,960
they're gonna run in expected constant

456
00:18:27,960 --> 00:18:30,539
number of rounds but the communication

457
00:18:30,539 --> 00:18:32,400
complexity is going to be high it's

458
00:18:32,400 --> 00:18:34,799
going to be m to the sixth

459
00:18:34,799 --> 00:18:36,419
um I just want to mention that having

460
00:18:36,419 --> 00:18:39,419
string strict constant number of rounds

461
00:18:39,419 --> 00:18:42,120
is impossible to achieve uh there is

462
00:18:42,120 --> 00:18:43,500
some lower bound that tells us that

463
00:18:43,500 --> 00:18:45,539
every protocol there will be an

464
00:18:45,539 --> 00:18:48,179
execution that will have around a linear

465
00:18:48,179 --> 00:18:51,419
number of fronts

466
00:18:51,419 --> 00:18:53,880
um so with those two protocols that we

467
00:18:53,880 --> 00:18:57,120
have let's see oh uh so this is the the

468
00:18:57,120 --> 00:18:59,880
communication pattern and broadcast and

469
00:18:59,880 --> 00:19:02,520
square if we care about one sender

470
00:19:02,520 --> 00:19:05,100
broadcasting a message of size L those

471
00:19:05,100 --> 00:19:07,740
are the costs it's uh NL percent squared

472
00:19:07,740 --> 00:19:10,500
or N squared Del plus n to the six again

473
00:19:10,500 --> 00:19:13,440
those translate to n to the sixth and do

474
00:19:13,440 --> 00:19:15,000
the four in the specific communication

475
00:19:15,000 --> 00:19:19,140
pattern that we care about okay so what

476
00:19:19,140 --> 00:19:21,120
are the ramifications of this two

477
00:19:21,120 --> 00:19:24,360
protocols so in fact in each run of bgw

478
00:19:24,360 --> 00:19:27,960
you have to round to round parallel VSS

479
00:19:27,960 --> 00:19:30,360
so if you added circuit that has like

480
00:19:30,360 --> 00:19:34,820
tips uh 10 and you have 300 participants

481
00:19:34,820 --> 00:19:38,460
you expected to have a protocol after

482
00:19:38,460 --> 00:19:40,080
you implement the broadcast of something

483
00:19:40,080 --> 00:19:43,260
like 10 Rounds 20 rounds 30 rounds

484
00:19:43,260 --> 00:19:44,880
instead what you're gonna get is

485
00:19:44,880 --> 00:19:47,580
something like 3 000 logs okay so this

486
00:19:47,580 --> 00:19:49,740
is completely slow

487
00:19:49,740 --> 00:19:52,919
and the other class of protocols

488
00:19:52,919 --> 00:19:55,440
um I expected to have something like n

489
00:19:55,440 --> 00:19:57,480
to the four total communication

490
00:19:57,480 --> 00:19:59,580
complexity which means that each party

491
00:19:59,580 --> 00:20:02,700
has to send or receive and Cube and cube

492
00:20:02,700 --> 00:20:05,220
when you put n as 300

493
00:20:05,220 --> 00:20:07,200
uh you're gonna get something like 27

494
00:20:07,200 --> 00:20:10,320
megabytes and instead you have to run

495
00:20:10,320 --> 00:20:12,480
into the sixth into the sixth if it's

496
00:20:12,480 --> 00:20:14,640
actually balanced and everyone really

497
00:20:14,640 --> 00:20:17,820
sends uh roughly the same amount of uh

498
00:20:17,820 --> 00:20:20,940
communication same amount of Beats it's

499
00:20:20,940 --> 00:20:22,679
gonna be n to the five and enter the

500
00:20:22,679 --> 00:20:25,380
fight is 2.4 terabytes okay so there's

501
00:20:25,380 --> 00:20:29,039
gonna be very very inefficient

502
00:20:29,039 --> 00:20:31,799
um so this is our goal to have a better

503
00:20:31,799 --> 00:20:33,480
broadcast

504
00:20:33,480 --> 00:20:36,720
so uh our main result we show a parallel

505
00:20:36,720 --> 00:20:38,520
broadcast protocol with perfect security

506
00:20:38,520 --> 00:20:40,260
and optimal resilience

507
00:20:40,260 --> 00:20:43,440
for the specific uh n parallel

508
00:20:43,440 --> 00:20:45,900
broadcasts of each poverty broadcasting

509
00:20:45,900 --> 00:20:49,080
a message of size L the best look we can

510
00:20:49,080 --> 00:20:51,600
hope to achieve is N squared L plus

511
00:20:51,600 --> 00:20:54,059
expected constant number of rounds the

512
00:20:54,059 --> 00:20:55,620
expected is because of the lower bound

513
00:20:55,620 --> 00:20:56,820
dimension

514
00:20:56,820 --> 00:20:59,820
and what we do achieve is N squared L

515
00:20:59,820 --> 00:21:01,320
plus n to the four communication

516
00:21:01,320 --> 00:21:04,260
complexity with constant number of from

517
00:21:04,260 --> 00:21:07,440
expected constant number of phones

518
00:21:07,440 --> 00:21:09,299
um the protocol is balanced so each part

519
00:21:09,299 --> 00:21:11,460
is roughly sets the same amount of

520
00:21:11,460 --> 00:21:13,620
information so what they actually send

521
00:21:13,620 --> 00:21:17,100
is something like n Cube uh and what it

522
00:21:17,100 --> 00:21:19,320
means that the specific communication

523
00:21:19,320 --> 00:21:21,299
pattern that we mentioned and parallel

524
00:21:21,299 --> 00:21:23,340
broadcast of n Square

525
00:21:23,340 --> 00:21:25,679
this is essentially free it's like an

526
00:21:25,679 --> 00:21:28,440
ideal invocation if I then I did trusted

527
00:21:28,440 --> 00:21:31,400
party that helps me

528
00:21:31,679 --> 00:21:34,440
um and if we care about one Center

529
00:21:34,440 --> 00:21:36,840
broadcasting the message of seizel uh

530
00:21:36,840 --> 00:21:38,880
what we get is NL plus n to the phone

531
00:21:38,880 --> 00:21:41,039
communication with constant expected

532
00:21:41,039 --> 00:21:43,860
number of funds okay so what the

533
00:21:43,860 --> 00:21:46,140
ramifications of this protocol if we go

534
00:21:46,140 --> 00:21:46,980
back

535
00:21:46,980 --> 00:21:49,500
total communication complexity of n to

536
00:21:49,500 --> 00:21:52,500
the six with 300 participants it means

537
00:21:52,500 --> 00:21:54,120
that each party has to send a receive

538
00:21:54,120 --> 00:21:56,159
something like n to the five as I

539
00:21:56,159 --> 00:21:58,799
mentioned this is 2.4 terabytes if I

540
00:21:58,799 --> 00:22:00,720
have let's say a channel which is one

541
00:22:00,720 --> 00:22:03,900
gigabit per second and I want to uh

542
00:22:03,900 --> 00:22:06,659
transmit 2.4 terabyte it's going to cost

543
00:22:06,659 --> 00:22:08,820
me five hours

544
00:22:08,820 --> 00:22:11,159
and in our protocol when you reduce it

545
00:22:11,159 --> 00:22:12,900
to them to default what it means that

546
00:22:12,900 --> 00:22:14,940
each party sends a receiver and Cube

547
00:22:14,940 --> 00:22:17,820
this is 27 megabytes you have one

548
00:22:17,820 --> 00:22:20,940
gigabit per second you can complete it

549
00:22:20,940 --> 00:22:23,159
in 200 milliseconds so the Improvement

550
00:22:23,159 --> 00:22:26,179
is really significant

551
00:22:26,179 --> 00:22:31,140
now given that uh broadcast let's take a

552
00:22:31,140 --> 00:22:33,360
look at other MPC protocols in the

553
00:22:33,360 --> 00:22:36,659
perfect setting and see how its affects

554
00:22:36,659 --> 00:22:40,140
uh the running times so interestingly

555
00:22:40,140 --> 00:22:43,620
again when you look at NPC protocols uh

556
00:22:43,620 --> 00:22:46,200
MPC protocols in this regime

557
00:22:46,200 --> 00:22:48,360
I'm looking only on a control depth

558
00:22:48,360 --> 00:22:50,000
circuits

559
00:22:50,000 --> 00:22:53,039
we have two classes of protocols one is

560
00:22:53,039 --> 00:22:55,500
efficient but slow and one is fast but

561
00:22:55,500 --> 00:22:56,640
inefficient

562
00:22:56,640 --> 00:22:59,100
uh we have very famous protocols over

563
00:22:59,100 --> 00:23:03,600
here like BDW CCD BH got the TCC test of

564
00:23:03,600 --> 00:23:06,059
time award last year and those are those

565
00:23:06,059 --> 00:23:08,100
are the communications as we can see

566
00:23:08,100 --> 00:23:10,980
again uh there is uh

567
00:23:10,980 --> 00:23:14,280
a trade-off if you get more rounds you

568
00:23:14,280 --> 00:23:16,200
need to pay other than rounds and you

569
00:23:16,200 --> 00:23:18,360
get better communication complexity or

570
00:23:18,360 --> 00:23:20,179
you're running constant number of runs

571
00:23:20,179 --> 00:23:22,559
uh and you pay a lot of communication

572
00:23:22,559 --> 00:23:25,140
and this is in the broadcast hybrid

573
00:23:25,140 --> 00:23:26,100
model

574
00:23:26,100 --> 00:23:28,559
now what happens if you come to

575
00:23:28,559 --> 00:23:30,240
implement the broadcast

576
00:23:30,240 --> 00:23:33,720
so before I walk I mean nothing is so

577
00:23:33,720 --> 00:23:34,440
great

578
00:23:34,440 --> 00:23:36,840
if you take an efficient but slow NPC

579
00:23:36,840 --> 00:23:38,340
and you add an efficient but slow

580
00:23:38,340 --> 00:23:39,900
broadcast but you're gonna get this very

581
00:23:39,900 --> 00:23:42,600
slow MPC efficient but slow with fast

582
00:23:42,600 --> 00:23:44,520
but inefficient you go slow and

583
00:23:44,520 --> 00:23:46,980
inefficient and inefficient with

584
00:23:46,980 --> 00:23:48,299
inefficient it's going to be very

585
00:23:48,299 --> 00:23:50,280
inefficient those are the complexities

586
00:23:50,280 --> 00:23:52,679
here we're going to see something like n

587
00:23:52,679 --> 00:23:55,559
Square rounds n Square rounds uh I think

588
00:23:55,559 --> 00:23:59,400
like 300 participants 20 000 rounds

589
00:23:59,400 --> 00:24:02,039
um sorry uh here we have a tell like n

590
00:24:02,039 --> 00:24:04,080
to the seven which is very expensive and

591
00:24:04,080 --> 00:24:05,700
it will have entered the six which is

592
00:24:05,700 --> 00:24:07,679
for every gate You're Gonna Pay n to the

593
00:24:07,679 --> 00:24:10,140
sixth this is very expensive

594
00:24:10,140 --> 00:24:13,080
using our broadcast the communication

595
00:24:13,080 --> 00:24:16,440
already improved and because we have

596
00:24:16,440 --> 00:24:19,200
this specific communication pattern that

597
00:24:19,200 --> 00:24:22,020
we know that this is for free we can now

598
00:24:22,020 --> 00:24:24,840
design better protocols in the follow-up

599
00:24:24,840 --> 00:24:27,720
papers uh we we designed a protocol that

600
00:24:27,720 --> 00:24:29,159
you know Target the specific

601
00:24:29,159 --> 00:24:30,780
communication platform

602
00:24:30,780 --> 00:24:34,860
and we got we got a result that is in

603
00:24:34,860 --> 00:24:37,020
submission that actually gets those

604
00:24:37,020 --> 00:24:40,020
linear uh Fair gate plus one-time

605
00:24:40,020 --> 00:24:42,299
processing pre-processing of n to the

606
00:24:42,299 --> 00:24:44,520
four with constant expected number of

607
00:24:44,520 --> 00:24:45,600
thoughts

608
00:24:45,600 --> 00:24:47,700
okay so

609
00:24:47,700 --> 00:24:50,100
um for the rest of my time I'm gonna

610
00:24:50,100 --> 00:24:52,260
tell you a little bit about how these

611
00:24:52,260 --> 00:24:55,620
things work so to implement broadcast we

612
00:24:55,620 --> 00:24:58,380
essentially have two uh building blocks

613
00:24:58,380 --> 00:25:00,600
that we care about one is great cast

614
00:25:00,600 --> 00:25:02,580
which is a relaxation of broadcasts

615
00:25:02,580 --> 00:25:04,980
where we have a sender it sent a message

616
00:25:04,980 --> 00:25:08,280
to everyone and all the parties together

617
00:25:08,280 --> 00:25:10,679
with the message also output some gray

618
00:25:10,679 --> 00:25:13,500
and the grade is like I believe that

619
00:25:13,500 --> 00:25:15,240
everyone actually got the same message

620
00:25:15,240 --> 00:25:16,940
or not

621
00:25:16,940 --> 00:25:20,100
and um and then

622
00:25:20,100 --> 00:25:23,940
if if it indeed like everyone got the

623
00:25:23,940 --> 00:25:26,220
same message everyone gonna have high

624
00:25:26,220 --> 00:25:28,200
grade we're gonna run a Byzantine

625
00:25:28,200 --> 00:25:30,419
agreement only on the grades

626
00:25:30,419 --> 00:25:32,400
and then using this grade we're gonna

627
00:25:32,400 --> 00:25:34,380
understand like answer the byzantino

628
00:25:34,380 --> 00:25:36,240
agreements will understand whether we

629
00:25:36,240 --> 00:25:38,039
need to Output the message of the great

630
00:25:38,039 --> 00:25:42,120
cast or just I'll put some default value

631
00:25:42,120 --> 00:25:44,580
to run Byzantine agreement we need to

632
00:25:44,580 --> 00:25:46,679
have an oblivious leader election and

633
00:25:46,679 --> 00:25:49,020
obliviously the election is going to run

634
00:25:49,020 --> 00:25:51,539
n square invocations of the Revival

635
00:25:51,539 --> 00:25:52,679
secretary

636
00:25:52,679 --> 00:25:56,520
where instead of using broadcasts in the

637
00:25:56,520 --> 00:25:58,559
verifiable secret sharing we're going to

638
00:25:58,559 --> 00:26:01,140
use this relaxation of great cast it's

639
00:26:01,140 --> 00:26:03,299
in it introduces some technicalities

640
00:26:03,299 --> 00:26:07,440
which I'm not gonna uh describe but this

641
00:26:07,440 --> 00:26:09,539
already gives us the structure of our

642
00:26:09,539 --> 00:26:12,120
broadcast uh looks like

643
00:26:12,120 --> 00:26:15,179
now moderated VSS as I said it's a VSS

644
00:26:15,179 --> 00:26:17,460
when you replace the broadcast with the

645
00:26:17,460 --> 00:26:19,799
gray cast so

646
00:26:19,799 --> 00:26:22,320
um the communication complexity is n

647
00:26:22,320 --> 00:26:24,419
Square point to point plus N squared

648
00:26:24,419 --> 00:26:27,419
great cast if we use this cost of gray

649
00:26:27,419 --> 00:26:30,059
cast uh as in Cutting Crew

650
00:26:30,059 --> 00:26:33,000
what you're gonna get uh because your

651
00:26:33,000 --> 00:26:36,120
message is your L is N squared when you

652
00:26:36,120 --> 00:26:38,580
put it over here it means that moderated

653
00:26:38,580 --> 00:26:41,760
VSS cost you into the phone because you

654
00:26:41,760 --> 00:26:44,640
have N squared of those this comes to

655
00:26:44,640 --> 00:26:48,600
the N to the six that uh we had in cuts

656
00:26:48,600 --> 00:26:49,559
and cool

657
00:26:49,559 --> 00:26:52,799
now our improvements so first of all we

658
00:26:52,799 --> 00:26:55,020
showed a better a great class protocol

659
00:26:55,020 --> 00:26:58,740
which I'm not gonna uh talk about so we

660
00:26:58,740 --> 00:27:01,919
reduce it from N squared L to n l plus n

661
00:27:01,919 --> 00:27:05,760
cubed and it's already uh reduces the

662
00:27:05,760 --> 00:27:08,640
cost of moderated VSS to NQ

663
00:27:08,640 --> 00:27:10,860
which goes out the way to enter the Five

664
00:27:10,860 --> 00:27:12,000
Below here

665
00:27:12,000 --> 00:27:15,120
and our second Improvement is a packed

666
00:27:15,120 --> 00:27:18,240
verifiable signal sharing protocol so

667
00:27:18,240 --> 00:27:20,220
practically fabulously for sharing we

668
00:27:20,220 --> 00:27:22,260
show a novel verifiable signature and

669
00:27:22,260 --> 00:27:25,380
protocols such that if previously secret

670
00:27:25,380 --> 00:27:28,320
sharing we could just have one secret

671
00:27:28,320 --> 00:27:31,260
and pay this cost of N squared plus N

672
00:27:31,260 --> 00:27:34,380
squared broadcast now we can have pack

673
00:27:34,380 --> 00:27:36,720
all the real secrets in one invocation

674
00:27:36,720 --> 00:27:37,980
of VSS

675
00:27:37,980 --> 00:27:42,600
and get uh exactly the same same cost

676
00:27:42,600 --> 00:27:45,480
the key idea is that instead of choosing

677
00:27:45,480 --> 00:27:48,000
of of like having a bivalent polynomial

678
00:27:48,000 --> 00:27:51,360
of the great team in X and Y we're going

679
00:27:51,360 --> 00:27:53,340
to have a bivariate polynomial of degree

680
00:27:53,340 --> 00:27:57,120
2T and x and degree T and Y and this

681
00:27:57,120 --> 00:27:59,100
back to BSS is essentially in order then

682
00:27:59,100 --> 00:28:01,860
Improvement of the classic verifiable

683
00:28:01,860 --> 00:28:04,320
signaturing of bgw

684
00:28:04,320 --> 00:28:06,960
or Feldman

685
00:28:06,960 --> 00:28:11,279
um okay so uh what does it mean to us so

686
00:28:11,279 --> 00:28:13,500
instead of having moderated v n n

687
00:28:13,500 --> 00:28:15,779
squared invocation of moderated BSS

688
00:28:15,779 --> 00:28:18,000
we're going to have just n invocations

689
00:28:18,000 --> 00:28:21,299
of moderated packed VSS and then we're

690
00:28:21,299 --> 00:28:23,700
gonna get the complexity all over it's

691
00:28:23,700 --> 00:28:27,179
like shaving another folder them

692
00:28:27,179 --> 00:28:29,700
so to conclude

693
00:28:29,700 --> 00:28:31,860
um what we show what we showed is n

694
00:28:31,860 --> 00:28:34,080
broadcast N squared is essentially free

695
00:28:34,080 --> 00:28:37,440
now about the start so uh the start is

696
00:28:37,440 --> 00:28:39,659
expected constant number of rounds as I

697
00:28:39,659 --> 00:28:41,279
mentioned you cannot have

698
00:28:41,279 --> 00:28:43,799
strict constant number of rounds and

699
00:28:43,799 --> 00:28:47,279
there is another another you know caveat

700
00:28:47,279 --> 00:28:48,919
that's there is no simultaneous

701
00:28:48,919 --> 00:28:52,260
determination this is also inherent what

702
00:28:52,260 --> 00:28:53,880
it means that the parties will also have

703
00:28:53,880 --> 00:28:56,100
to synchronize after running the

704
00:28:56,100 --> 00:28:59,159
broadcast which just it adds most to the

705
00:28:59,159 --> 00:29:02,340
constants but it's still constant

706
00:29:02,340 --> 00:29:04,020
um if you have one Center there of

707
00:29:04,020 --> 00:29:06,480
broadcast L bits then it's NL plus n to

708
00:29:06,480 --> 00:29:09,539
the four and back to VSS we showed uh

709
00:29:09,539 --> 00:29:12,179
how you can pack and secrets maliciously

710
00:29:12,179 --> 00:29:15,240
at the cost of just one signal with that

711
00:29:15,240 --> 00:29:15,960
uh

712
00:29:15,960 --> 00:29:18,500
thank you

713
00:29:22,500 --> 00:29:25,860
yes definitely be one quick question

714
00:29:25,860 --> 00:29:27,440
uh

715
00:29:27,440 --> 00:29:29,880
uh I'll ask one while the next speaker

716
00:29:29,880 --> 00:29:32,100
is setting up uh

717
00:29:32,100 --> 00:29:35,820
sorry if I missed it but the like the

718
00:29:35,820 --> 00:29:39,419
the thresholds for number of uh

719
00:29:39,419 --> 00:29:41,760
malicious parties is it is it the

720
00:29:41,760 --> 00:29:43,140
optimal threshold in all of these

721
00:29:43,140 --> 00:29:45,179
results or do you have to pay yes and

722
00:29:45,179 --> 00:29:46,820
and over three

723
00:29:46,820 --> 00:29:48,840
like uh

724
00:29:48,840 --> 00:29:50,520
great thank you all right let's thank

725
00:29:50,520 --> 00:29:53,120
the speaker again

726
00:29:53,159 --> 00:29:55,399
thank you

727
00:30:15,559 --> 00:30:19,158
it'll be okay okay

728
00:30:21,059 --> 00:30:23,120
um

729
00:30:24,500 --> 00:30:28,580
so what what's the point

730
00:30:29,120 --> 00:30:30,860
yeah

731
00:30:30,860 --> 00:30:35,539
okay excellent okay all right thanks

732
00:30:35,700 --> 00:30:38,279
all right our next speaker is Reya

733
00:30:38,279 --> 00:30:40,740
ariguchi speaking on uh on the optimal

734
00:30:40,740 --> 00:30:42,179
communication complexity of error

735
00:30:42,179 --> 00:30:44,520
correcting multi-server pure

736
00:30:44,520 --> 00:30:46,320
uh thank you for introduction hello

737
00:30:46,320 --> 00:30:49,320
everyone I'm Ro elegucci today I talk

738
00:30:49,320 --> 00:30:51,840
about our paper entitled on the optimal

739
00:30:51,840 --> 00:30:53,700
communication complexity of error

740
00:30:53,700 --> 00:30:55,919
correcting multi-server PIR this is a

741
00:30:55,919 --> 00:30:58,260
joint work with coworkurusawa and kojo

742
00:30:58,260 --> 00:31:00,120
Noida

743
00:31:00,120 --> 00:31:02,520
first we recall uh private information

744
00:31:02,520 --> 00:31:05,399
retrieval or PIR for short in this

745
00:31:05,399 --> 00:31:08,279
setting L servers have L copies of a

746
00:31:08,279 --> 00:31:11,580
database a which consists of n items on

747
00:31:11,580 --> 00:31:13,799
the other hand the client has indexed

748
00:31:13,799 --> 00:31:16,080
how and she wants to retrieve the third

749
00:31:16,080 --> 00:31:20,039
item of of the database then the PIR

750
00:31:20,039 --> 00:31:23,279
enables that client to retrieve the item

751
00:31:23,279 --> 00:31:25,320
of her choice without revealing any

752
00:31:25,320 --> 00:31:28,200
information on that index so now there

753
00:31:28,200 --> 00:31:30,000
is a trivial solution to realize PIR

754
00:31:30,000 --> 00:31:33,960
it's to download a whole database then

755
00:31:33,960 --> 00:31:36,240
clearly um this solution is secure

756
00:31:36,240 --> 00:31:38,760
because the client never reveals her

757
00:31:38,760 --> 00:31:41,159
index that its communication cost is

758
00:31:41,159 --> 00:31:43,620
proportional to the database size M so

759
00:31:43,620 --> 00:31:45,840
therefore this solution is secure web

760
00:31:45,840 --> 00:31:47,640
inefficient

761
00:31:47,640 --> 00:31:51,240
sorry a line of research to achieve um

762
00:31:51,240 --> 00:31:54,120
sub-linear communication cost is

763
00:31:54,120 --> 00:31:56,340
um under in the information theoretic

764
00:31:56,340 --> 00:31:58,260
Security is to construct a multi-server

765
00:31:58,260 --> 00:32:00,899
PIR uh where more than one servers are

766
00:32:00,899 --> 00:32:02,039
available

767
00:32:02,039 --> 00:32:04,020
first uh if there are at least two

768
00:32:04,020 --> 00:32:06,539
servers and um

769
00:32:06,539 --> 00:32:09,059
and uh this utmost T server is collude

770
00:32:09,059 --> 00:32:11,399
then we can achieve a communication cost

771
00:32:11,399 --> 00:32:14,760
of uh n into T over L which is sublinear

772
00:32:14,760 --> 00:32:18,600
if T is sufficiently smaller than l next

773
00:32:18,600 --> 00:32:21,720
we um if there are at most at least

774
00:32:21,720 --> 00:32:23,700
three servers and they do not collude

775
00:32:23,700 --> 00:32:27,059
that is we consider our one privacy then

776
00:32:27,059 --> 00:32:28,919
we can achieve a much smaller

777
00:32:28,919 --> 00:32:30,720
communication cost which is

778
00:32:30,720 --> 00:32:34,580
sub-polynomial in the database size

779
00:32:34,860 --> 00:32:37,919
um sorry we know that these prr schemes

780
00:32:37,919 --> 00:32:40,679
assume that servers are semi honest that

781
00:32:40,679 --> 00:32:41,580
is

782
00:32:41,580 --> 00:32:43,980
um all servers always return correct

783
00:32:43,980 --> 00:32:45,960
answers however

784
00:32:45,960 --> 00:32:47,580
um this may not be the case in the real

785
00:32:47,580 --> 00:32:50,039
world situation for example a servers

786
00:32:50,039 --> 00:32:52,799
may be malicious and they try to make

787
00:32:52,799 --> 00:32:55,860
the client output and incorrect value

788
00:32:55,860 --> 00:32:58,500
also they may return nothing if they are

789
00:32:58,500 --> 00:33:00,840
faulty and then we can also consider a

790
00:33:00,840 --> 00:33:03,240
scenario where servers have inconsistent

791
00:33:03,240 --> 00:33:06,779
databases for example if um server has

792
00:33:06,779 --> 00:33:09,240
an old database and then our client will

793
00:33:09,240 --> 00:33:12,840
receive inconsistent answers

794
00:33:12,840 --> 00:33:15,659
so to deal with and malicious servers

795
00:33:15,659 --> 00:33:17,940
um the email and store introduced the

796
00:33:17,940 --> 00:33:20,760
notion of error correcting PIR in which

797
00:33:20,760 --> 00:33:23,279
a client can obtain a correct results

798
00:33:23,279 --> 00:33:26,340
even if some malicious servers are

799
00:33:26,340 --> 00:33:28,980
returned in correct answers

800
00:33:28,980 --> 00:33:30,720
so in this work we consider the

801
00:33:30,720 --> 00:33:33,059
following problem what is the optimal

802
00:33:33,059 --> 00:33:35,460
communication complexity of T private

803
00:33:35,460 --> 00:33:38,700
the b error correcting L server PIR

804
00:33:38,700 --> 00:33:41,700
a personal answer is was also given by

805
00:33:41,700 --> 00:33:44,760
the Amazon store they first show that b

806
00:33:44,760 --> 00:33:47,640
error correction is Possible only an F L

807
00:33:47,640 --> 00:33:50,340
is greater than the two times B no

808
00:33:50,340 --> 00:33:52,799
matter how much communication we allow

809
00:33:52,799 --> 00:33:54,840
they also proposed a generic

810
00:33:54,840 --> 00:33:56,760
construction of the error correcting

811
00:33:56,760 --> 00:33:59,940
also the PIR from any regular L minus

812
00:33:59,940 --> 00:34:02,519
two times B server PIR

813
00:34:02,519 --> 00:34:04,740
ate construction gives the following

814
00:34:04,740 --> 00:34:06,720
upper bound and the optimal

815
00:34:06,720 --> 00:34:08,460
communication complexity of error

816
00:34:08,460 --> 00:34:11,159
correcting PIR is upper bounded by that

817
00:34:11,159 --> 00:34:13,560
of regular L minus two times B server

818
00:34:13,560 --> 00:34:16,560
PIR so we know that um

819
00:34:16,560 --> 00:34:21,119
uh communication overhead is uh so it is

820
00:34:21,119 --> 00:34:22,800
exponential in the number of servers

821
00:34:22,800 --> 00:34:24,839
that it is independent of the database

822
00:34:24,839 --> 00:34:26,280
size n so

823
00:34:26,280 --> 00:34:29,280
um uh so therefore as a function of n

824
00:34:29,280 --> 00:34:31,560
the the optimal communication cost of

825
00:34:31,560 --> 00:34:33,599
error connected plr is asymptotically

826
00:34:33,599 --> 00:34:36,899
upper bounded by that of regular PIR

827
00:34:36,899 --> 00:34:39,359
we know that there are also non-generic

828
00:34:39,359 --> 00:34:43,139
constructions available PIR but they

829
00:34:43,139 --> 00:34:44,760
um they improved the computational

830
00:34:44,760 --> 00:34:47,159
complexity of the construction by the ml

831
00:34:47,159 --> 00:34:49,800
install and so uh they do not give any

832
00:34:49,800 --> 00:34:52,020
better upper bound on communication

833
00:34:52,020 --> 00:34:53,820
complexity

834
00:34:53,820 --> 00:34:56,339
so now we show our results we first

835
00:34:56,339 --> 00:34:58,680
obtain a low amount on the FC model

836
00:34:58,680 --> 00:35:00,060
communication cost of the internet

837
00:35:00,060 --> 00:35:02,880
predicting API that asyntically matches

838
00:35:02,880 --> 00:35:06,119
the previous upper bound so

839
00:35:06,119 --> 00:35:08,339
um as we said there is still a

840
00:35:08,339 --> 00:35:11,579
exponential gap between uh lower and

841
00:35:11,579 --> 00:35:14,099
upper balance bats it is it only depends

842
00:35:14,099 --> 00:35:15,300
on the number of servers and the

843
00:35:15,300 --> 00:35:18,240
independent of the database size

844
00:35:18,240 --> 00:35:20,460
uh we also consider the statistical

845
00:35:20,460 --> 00:35:22,560
variant of error correcting PIR in which

846
00:35:22,560 --> 00:35:25,500
a client fails to correct errors with

847
00:35:25,500 --> 00:35:28,740
negligible bad non-zero probability

848
00:35:28,740 --> 00:35:31,020
um in this setting we also obtain a

849
00:35:31,020 --> 00:35:32,940
similar upper and lower bounds and

850
00:35:32,940 --> 00:35:36,119
especially as specifically we show that

851
00:35:36,119 --> 00:35:37,680
um the optimal communication complexity

852
00:35:37,680 --> 00:35:40,740
of statistical error correcting PIR is

853
00:35:40,740 --> 00:35:44,339
characterized by that of regular PIR a

854
00:35:44,339 --> 00:35:47,339
regular L minus V server PIR

855
00:35:47,339 --> 00:35:50,160
so here are the asterisk indicates that

856
00:35:50,160 --> 00:35:52,320
the statistical variance of the error

857
00:35:52,320 --> 00:35:54,599
correcting or regular PIR

858
00:35:54,599 --> 00:35:57,540
so um again there is still a gap between

859
00:35:57,540 --> 00:35:59,940
the upper and lower bounds that they um

860
00:35:59,940 --> 00:36:03,000
are Depends only on the number of

861
00:36:03,000 --> 00:36:04,500
servers and the security parameter and

862
00:36:04,500 --> 00:36:06,660
the independent of the database size so

863
00:36:06,660 --> 00:36:09,599
therefore in conclusion our results show

864
00:36:09,599 --> 00:36:10,380
that

865
00:36:10,380 --> 00:36:13,440
um uh the the problem of determining the

866
00:36:13,440 --> 00:36:15,119
optimal communication complexity of

867
00:36:15,119 --> 00:36:17,880
error predicting PIR as a function of n

868
00:36:17,880 --> 00:36:21,720
is now reduced to that reduced to the

869
00:36:21,720 --> 00:36:25,459
determining that of regular PIR

870
00:36:25,619 --> 00:36:27,839
so are we obtained some Coral is it from

871
00:36:27,839 --> 00:36:30,300
our characterization now first we can

872
00:36:30,300 --> 00:36:32,280
see that uh there is a separation

873
00:36:32,280 --> 00:36:34,440
between the perfect and the statistical

874
00:36:34,440 --> 00:36:36,359
error correcting PIR

875
00:36:36,359 --> 00:36:39,000
our roller balance implies that uh L

876
00:36:39,000 --> 00:36:42,060
minus 2 times b a private perfect error

877
00:36:42,060 --> 00:36:44,579
correcting PIR requires the same amount

878
00:36:44,579 --> 00:36:47,880
of communication at the database size uh

879
00:36:47,880 --> 00:36:50,579
this is because uh it implies uh

880
00:36:50,579 --> 00:36:54,300
PIR scheme uh that protects the client's

881
00:36:54,300 --> 00:36:57,060
privacy even if all server is glued or

882
00:36:57,060 --> 00:36:59,520
it is equivalent to a single server

883
00:36:59,520 --> 00:37:01,200
information or theoretical uh

884
00:37:01,200 --> 00:37:03,900
theoretical PIR so which

885
00:37:03,900 --> 00:37:06,119
um which has to download the whole

886
00:37:06,119 --> 00:37:08,880
database because of uh the previous uh

887
00:37:08,880 --> 00:37:11,220
classical or impossibility result

888
00:37:11,220 --> 00:37:12,780
on the other hand

889
00:37:12,780 --> 00:37:15,599
um our upper bands are so it showed that

890
00:37:15,599 --> 00:37:17,940
a statistical area working PIR with the

891
00:37:17,940 --> 00:37:20,099
same level of privacy can achieve

892
00:37:20,099 --> 00:37:22,980
sublinear communication because

893
00:37:22,980 --> 00:37:26,099
um so our upper bounds imply that

894
00:37:26,099 --> 00:37:28,920
um the the optimal communication

895
00:37:28,920 --> 00:37:31,859
complexity of um error operating PIR is

896
00:37:31,859 --> 00:37:35,400
not higher than that of um L minus two

897
00:37:35,400 --> 00:37:37,680
times V private L minus B server regular

898
00:37:37,680 --> 00:37:41,040
PIR which can be a sublinear because of

899
00:37:41,040 --> 00:37:43,320
the previous Construction

900
00:37:43,320 --> 00:37:45,960
uh the next quarterly is that we can

901
00:37:45,960 --> 00:37:47,940
obtain a more communication efficient

902
00:37:47,940 --> 00:37:51,240
error collecting PIR schemes for example

903
00:37:51,240 --> 00:37:54,000
um the first row shows that the previous

904
00:37:54,000 --> 00:37:56,040
construction instantiated with an

905
00:37:56,040 --> 00:37:58,800
existing regular PIR with subpolynomial

906
00:37:58,800 --> 00:38:01,380
communication on the other hand if we

907
00:38:01,380 --> 00:38:03,480
instantiate our construction with the

908
00:38:03,480 --> 00:38:06,060
same scheme then we can achieve a better

909
00:38:06,060 --> 00:38:08,520
communication complexity at the cost of

910
00:38:08,520 --> 00:38:11,040
allowing for a small failure probability

911
00:38:11,040 --> 00:38:15,359
and here um in this L notation uh the

912
00:38:15,359 --> 00:38:17,339
communication cost is smaller becomes

913
00:38:17,339 --> 00:38:20,040
smaller as the parameter R becomes

914
00:38:20,040 --> 00:38:22,020
larger

915
00:38:22,020 --> 00:38:24,540
so now a week now explain our technical

916
00:38:24,540 --> 00:38:28,560
details focusing on the statistical case

917
00:38:28,560 --> 00:38:30,960
so we first show a generic

918
00:38:30,960 --> 00:38:33,960
transformation from regular PIR to error

919
00:38:33,960 --> 00:38:35,579
detecting PIR

920
00:38:35,579 --> 00:38:38,160
um which has a weaker weaker property

921
00:38:38,160 --> 00:38:40,040
than error correct PIR

922
00:38:40,040 --> 00:38:43,740
ically in error detecting PIR clients

923
00:38:43,740 --> 00:38:45,960
can only detect the presence of Errors

924
00:38:45,960 --> 00:38:49,320
he cannot correct them

925
00:38:49,320 --> 00:38:51,900
so this transformation implies that the

926
00:38:51,900 --> 00:38:53,760
optimal communication complexity of

927
00:38:53,760 --> 00:38:56,460
error detecting PIR is now upper bounded

928
00:38:56,460 --> 00:38:59,700
by that regular PIR

929
00:38:59,700 --> 00:39:02,760
so next we also show the transformation

930
00:39:02,760 --> 00:39:05,280
from error detecting PIR to error

931
00:39:05,280 --> 00:39:08,280
correcting PIR or with overhead of l2b

932
00:39:08,280 --> 00:39:11,579
so now we obtain upper bound on the

933
00:39:11,579 --> 00:39:13,560
optimal communication complexity of

934
00:39:13,560 --> 00:39:17,160
error correcting PIR in terms of that of

935
00:39:17,160 --> 00:39:19,560
error detecting PIR which will then

936
00:39:19,560 --> 00:39:22,800
upper bounded by that or regular PIR

937
00:39:22,800 --> 00:39:25,560
we note that the total communication

938
00:39:25,560 --> 00:39:27,240
overhead is now

939
00:39:27,240 --> 00:39:30,119
um uh exponential in the number of

940
00:39:30,119 --> 00:39:33,060
servers but it is independent of the

941
00:39:33,060 --> 00:39:38,220
numbers the data data database size yeah

942
00:39:38,220 --> 00:39:41,240
so finally we show that um

943
00:39:41,240 --> 00:39:43,200
so at the optimal communication

944
00:39:43,200 --> 00:39:45,660
complexity of error correcting PR is at

945
00:39:45,660 --> 00:39:48,480
least that or a regular PIR so now we

946
00:39:48,480 --> 00:39:51,060
thus obtain a characterization of the

947
00:39:51,060 --> 00:39:52,619
optimal communication complexity of

948
00:39:52,619 --> 00:39:55,200
error collecting PIR in terms of the

949
00:39:55,200 --> 00:39:57,420
regular PIR

950
00:39:57,420 --> 00:40:00,480
so uh two of our Transformations are

951
00:40:00,480 --> 00:40:02,880
somewhat straightforward uh indeed the

952
00:40:02,880 --> 00:40:05,880
second transformation

953
00:40:05,880 --> 00:40:08,760
um simply executes independent instances

954
00:40:08,760 --> 00:40:11,700
of error detecting a PIR for all sets of

955
00:40:11,700 --> 00:40:14,160
L minus B servers and the final

956
00:40:14,160 --> 00:40:16,859
transformation also easily follows from

957
00:40:16,859 --> 00:40:19,200
the error production capability so in

958
00:40:19,200 --> 00:40:21,720
the rest of our presentation we focus on

959
00:40:21,720 --> 00:40:24,720
the transformation from regular to error

960
00:40:24,720 --> 00:40:27,439
detecting PIR

961
00:40:27,660 --> 00:40:30,180
so um for Simplicity we consider the two

962
00:40:30,180 --> 00:40:32,820
server case a two construct two server

963
00:40:32,820 --> 00:40:35,640
PIR schemes which can detect one

964
00:40:35,640 --> 00:40:38,460
malicious server we assume for now that

965
00:40:38,460 --> 00:40:40,680
a client knowed the first server is

966
00:40:40,680 --> 00:40:42,420
honest and the second server is

967
00:40:42,420 --> 00:40:44,579
malicious the problem is still

968
00:40:44,579 --> 00:40:46,680
non-trivial because the client should

969
00:40:46,680 --> 00:40:49,440
detect it exactly when the second server

970
00:40:49,440 --> 00:40:51,839
submits an incorrect answer

971
00:40:51,839 --> 00:40:53,339
so to do that

972
00:40:53,339 --> 00:40:56,339
um in our schema Client First executes

973
00:40:56,339 --> 00:40:57,540
the

974
00:40:57,540 --> 00:41:00,180
um the the uh the the query algorithm of

975
00:41:00,180 --> 00:41:04,140
the given regular PIR twice then um he

976
00:41:04,140 --> 00:41:05,940
distributes on the

977
00:41:05,940 --> 00:41:09,839
query for computation as usual

978
00:41:09,839 --> 00:41:12,420
um but to verify the answer from the

979
00:41:12,420 --> 00:41:15,420
second server uh he gave the second

980
00:41:15,420 --> 00:41:18,660
query of the query for verification to

981
00:41:18,660 --> 00:41:20,339
both servers

982
00:41:20,339 --> 00:41:21,480
then

983
00:41:21,480 --> 00:41:24,060
the honest server uh computes its answer

984
00:41:24,060 --> 00:41:26,579
as usual but also

985
00:41:26,579 --> 00:41:28,740
um simulates the answer of the second

986
00:41:28,740 --> 00:41:31,260
server on the other hand the malicious

987
00:41:31,260 --> 00:41:33,660
server May return arbitrarily incorrect

988
00:41:33,660 --> 00:41:35,339
answer

989
00:41:35,339 --> 00:41:37,740
so then after receiving the answers that

990
00:41:37,740 --> 00:41:40,680
the client checks if the second server's

991
00:41:40,680 --> 00:41:43,380
answer to the query for verification is

992
00:41:43,380 --> 00:41:46,440
equal to that from their honest server

993
00:41:46,440 --> 00:41:48,900
if so they run the Reconstruction

994
00:41:48,900 --> 00:41:50,520
algorithm

995
00:41:50,520 --> 00:41:52,740
um clearly it doesn't work by itself

996
00:41:52,740 --> 00:41:56,400
because the malicious server knows which

997
00:41:56,400 --> 00:41:59,460
query is uh for verification so

998
00:41:59,460 --> 00:42:00,540
therefore

999
00:42:00,540 --> 00:42:04,020
um the malicious server can behave on it

1000
00:42:04,020 --> 00:42:06,740
honestly for the verification that

1001
00:42:06,740 --> 00:42:09,780
behaves maliciously for the first query

1002
00:42:09,780 --> 00:42:12,900
which cannot be detected so to overcome

1003
00:42:12,900 --> 00:42:15,660
it we let the clients shuffled to

1004
00:42:15,660 --> 00:42:18,180
carries then the malicious server cannot

1005
00:42:18,180 --> 00:42:20,099
distinguish between the queries for

1006
00:42:20,099 --> 00:42:21,720
verification and the query for

1007
00:42:21,720 --> 00:42:24,240
computation so therefore the probability

1008
00:42:24,240 --> 00:42:26,339
that the Malaysia server can

1009
00:42:26,339 --> 00:42:28,440
successfully submit an incorrect answer

1010
00:42:28,440 --> 00:42:31,380
without being detected is at most one

1011
00:42:31,380 --> 00:42:33,300
over two

1012
00:42:33,300 --> 00:42:36,359
so now we show our final construction

1013
00:42:36,359 --> 00:42:39,240
um as we said uh Client First executes

1014
00:42:39,240 --> 00:42:40,079
the

1015
00:42:40,079 --> 00:42:42,780
um the query algorithm twice

1016
00:42:42,780 --> 00:42:45,839
so we now the client also randomly

1017
00:42:45,839 --> 00:42:48,599
guesses which server is honest for

1018
00:42:48,599 --> 00:42:51,240
example uh the support that the first uh

1019
00:42:51,240 --> 00:42:52,859
he guessed it the first server is

1020
00:42:52,859 --> 00:42:54,240
honeste

1021
00:42:54,240 --> 00:42:58,319
then um he shuffles the two queries and

1022
00:42:58,319 --> 00:43:01,619
left the first server simulate the

1023
00:43:01,619 --> 00:43:04,200
um the answer from the second server

1024
00:43:04,200 --> 00:43:06,180
the rest of the protocol is almost

1025
00:43:06,180 --> 00:43:08,700
similar to the previous one so after

1026
00:43:08,700 --> 00:43:10,260
receiving the answers

1027
00:43:10,260 --> 00:43:12,960
um client checks the consistency and

1028
00:43:12,960 --> 00:43:16,260
decide to upload the protocol I was

1029
00:43:16,260 --> 00:43:17,839
protocol or

1030
00:43:17,839 --> 00:43:21,000
run the Reconstruction algorithm so

1031
00:43:21,000 --> 00:43:23,280
so then that protocol fails only and if

1032
00:43:23,280 --> 00:43:27,420
the underlying regular um PIR fails or

1033
00:43:27,420 --> 00:43:30,119
um the client who fails to Guess that on

1034
00:43:30,119 --> 00:43:32,819
a server or he guesses exactly that the

1035
00:43:32,819 --> 00:43:35,040
verification fails so then the

1036
00:43:35,040 --> 00:43:36,839
probability of failure is at most

1037
00:43:36,839 --> 00:43:38,940
three-fourths plus negligible which can

1038
00:43:38,940 --> 00:43:41,339
be made arbitrally small by Superior

1039
00:43:41,339 --> 00:43:42,540
execution

1040
00:43:42,540 --> 00:43:45,839
so now I will conclude on the this talk

1041
00:43:45,839 --> 00:43:47,700
but we are running out of time so um

1042
00:43:47,700 --> 00:43:49,619
this is the end of my talk that's all

1043
00:43:49,619 --> 00:43:51,920
thank you

1044
00:44:02,160 --> 00:44:04,140
all right we're low on time so let's get

1045
00:44:04,140 --> 00:44:05,520
the next speaker set up let's thank the

1046
00:44:05,520 --> 00:44:07,220
speaker again

1047
00:44:07,220 --> 00:44:10,410
[Music]

1048
00:44:10,680 --> 00:44:13,460
oh sorry

1049
00:44:41,819 --> 00:44:44,420
foreign

1050
00:44:50,579 --> 00:44:52,819
foreign

1051
00:44:56,660 --> 00:44:58,859
speaking on the oblivious transfer

1052
00:44:58,859 --> 00:45:00,900
complexity of noisy coin toss via secure

1053
00:45:00,900 --> 00:45:03,540
zero communication reductions

1054
00:45:03,540 --> 00:45:05,760
um hi uh I'm Samuel thanks for the

1055
00:45:05,760 --> 00:45:07,319
introduction I would presenting joint

1056
00:45:07,319 --> 00:45:09,720
work with Varun Narayanan and uh manush

1057
00:45:09,720 --> 00:45:10,980
prabhakaran

1058
00:45:10,980 --> 00:45:12,960
um on devotee complexity the oblivious

1059
00:45:12,960 --> 00:45:15,000
transfer complexity of the noisy contact

1060
00:45:15,000 --> 00:45:17,160
functionality using sdcr or the

1061
00:45:17,160 --> 00:45:19,920
psychological communication reductions

1062
00:45:19,920 --> 00:45:21,180
um so first I'll start by defining the

1063
00:45:21,180 --> 00:45:22,680
terminology

1064
00:45:22,680 --> 00:45:24,359
um so Define the OT complexity concept

1065
00:45:24,359 --> 00:45:25,800
of the simple two-party computation

1066
00:45:25,800 --> 00:45:27,599
setting in which Alice and Bob receive

1067
00:45:27,599 --> 00:45:29,160
inputs X and Y and they want to compute

1068
00:45:29,160 --> 00:45:30,420
outputs A and B According to some

1069
00:45:30,420 --> 00:45:32,640
functionality F to assist in this

1070
00:45:32,640 --> 00:45:34,440
computation we give them a correlated

1071
00:45:34,440 --> 00:45:36,720
Randomness PSI and after receiving this

1072
00:45:36,720 --> 00:45:38,160
correlated Randomness they communicate

1073
00:45:38,160 --> 00:45:39,480
with each other and produce a transcript

1074
00:45:39,480 --> 00:45:40,680
queue

1075
00:45:40,680 --> 00:45:43,380
um I replace this PSI by m instances of

1076
00:45:43,380 --> 00:45:45,660
OT where an OT gives Theta naught Theta

1077
00:45:45,660 --> 00:45:48,480
1 to Alice and a b Theta B to Bob and I

1078
00:45:48,480 --> 00:45:50,160
Define the OT complexity to be the

1079
00:45:50,160 --> 00:45:52,020
minimum number of 40s I need so that

1080
00:45:52,020 --> 00:45:53,819
this computation is perfectly secure in

1081
00:45:53,819 --> 00:45:55,980
a semi honest setting

1082
00:45:55,980 --> 00:45:58,140
um devotee complexity is a medical study

1083
00:45:58,140 --> 00:46:01,020
problem and uh super linear lower bound

1084
00:46:01,020 --> 00:46:02,880
on the OT complexity implies super

1085
00:46:02,880 --> 00:46:04,200
linear lower bounds on circuit

1086
00:46:04,200 --> 00:46:06,060
complexity and so it is in general hard

1087
00:46:06,060 --> 00:46:07,859
to prove for deterministic functions

1088
00:46:07,859 --> 00:46:09,480
however for randomized functions we

1089
00:46:09,480 --> 00:46:11,520
actually do not face such barriers and

1090
00:46:11,520 --> 00:46:12,960
that is what we'll be talking about

1091
00:46:12,960 --> 00:46:15,000
today in particular the randomized

1092
00:46:15,000 --> 00:46:16,140
function I'll be talking about is the

1093
00:46:16,140 --> 00:46:18,720
noisy coin toss so the P noise the coin

1094
00:46:18,720 --> 00:46:20,760
test is defined as follows so Alice and

1095
00:46:20,760 --> 00:46:22,619
Bob both receive a uniform bed but with

1096
00:46:22,619 --> 00:46:24,720
probability P they get different bits so

1097
00:46:24,720 --> 00:46:27,180
with probability uh 1 minus P by 2 uh

1098
00:46:27,180 --> 00:46:28,800
they are both getting a zero both

1099
00:46:28,800 --> 00:46:30,359
getting a 1 and with probability P by 2

1100
00:46:30,359 --> 00:46:32,339
they are getting different widths

1101
00:46:32,339 --> 00:46:33,000
um

1102
00:46:33,000 --> 00:46:34,680
now I can simulate this computation

1103
00:46:34,680 --> 00:46:36,900
using a circuit with uh Theta log 1 over

1104
00:46:36,900 --> 00:46:39,720
P Gates so the gmw protocol will give

1105
00:46:39,720 --> 00:46:40,859
you an upper bound on the vertical

1106
00:46:40,859 --> 00:46:43,200
complexity to be uh o log 1 over P the

1107
00:46:43,200 --> 00:46:44,700
question we want to ask is can we use

1108
00:46:44,700 --> 00:46:47,339
fewer Otis to compute this function the

1109
00:46:47,339 --> 00:46:48,720
main result of the stock is that we

1110
00:46:48,720 --> 00:46:50,940
cannot and the OD complexities in Theta

1111
00:46:50,940 --> 00:46:53,040
log 1 over p uh this is interesting

1112
00:46:53,040 --> 00:46:55,200
because firstly this is a super linear

1113
00:46:55,200 --> 00:46:57,180
lower bound on the OT complexity but

1114
00:46:57,180 --> 00:46:59,160
secondly uh this is not limited by input

1115
00:46:59,160 --> 00:47:01,260
output size uh so most common

1116
00:47:01,260 --> 00:47:02,880
information theoretic techniques would

1117
00:47:02,880 --> 00:47:04,380
actually give you a bounce that depend

1118
00:47:04,380 --> 00:47:05,880
on input output size and so they would

1119
00:47:05,880 --> 00:47:08,400
give you a bound of one secondly uh this

1120
00:47:08,400 --> 00:47:11,520
Bond increases as p goes to uh but when

1121
00:47:11,520 --> 00:47:13,859
p is 0 this is o one and we do not

1122
00:47:13,859 --> 00:47:15,300
expect information theoretic techniques

1123
00:47:15,300 --> 00:47:17,579
to be able to derive such a bomb

1124
00:47:17,579 --> 00:47:18,720
um so the techniques that we use to

1125
00:47:18,720 --> 00:47:21,000
derive this bound are the sdcr and the

1126
00:47:21,000 --> 00:47:22,560
balance them building complexity there's

1127
00:47:22,560 --> 00:47:24,119
this year or the security communication

1128
00:47:24,119 --> 00:47:26,339
reductions were defined by NPP in 2020

1129
00:47:26,339 --> 00:47:28,619
and I'll be defining balance embedding

1130
00:47:28,619 --> 00:47:29,940
complexity here which is a

1131
00:47:29,940 --> 00:47:32,040
simplification of the sgcr uh which

1132
00:47:32,040 --> 00:47:34,319
makes the analysis simpler

1133
00:47:34,319 --> 00:47:35,760
um and we find that the balance limiting

1134
00:47:35,760 --> 00:47:37,319
complexity lower bounds the sdcr

1135
00:47:37,319 --> 00:47:38,760
complexity which in turn lower boundary

1136
00:47:38,760 --> 00:47:40,560
complexity

1137
00:47:40,560 --> 00:47:42,599
um so a quick refresh it for the htcr is

1138
00:47:42,599 --> 00:47:44,940
defined by NPP in 2020 so the sdca looks

1139
00:47:44,940 --> 00:47:47,160
a lot like uh the two PC settings the

1140
00:47:47,160 --> 00:47:48,300
only difference between that Alice and

1141
00:47:48,300 --> 00:47:49,440
Bob are not communicating with each

1142
00:47:49,440 --> 00:47:51,060
other directly they are both inter

1143
00:47:51,060 --> 00:47:53,160
sampling a u and a V and which they are

1144
00:47:53,160 --> 00:47:54,900
sending to a trusted Oracle file

1145
00:47:54,900 --> 00:47:57,180
condition on this file accepting the

1146
00:47:57,180 --> 00:47:58,800
outputs of Alice and Bob are supposed to

1147
00:47:58,800 --> 00:48:01,140
be corrected now in the OT complexity

1148
00:48:01,140 --> 00:48:02,400
case I replace this correlated

1149
00:48:02,400 --> 00:48:04,680
Randomness by m instances of 40. here I

1150
00:48:04,680 --> 00:48:06,119
am replacing the trusted Oracle by m

1151
00:48:06,119 --> 00:48:08,339
instances of OT and I'm asking uh I'm

1152
00:48:08,339 --> 00:48:10,020
defining sdcr complexity to be the

1153
00:48:10,020 --> 00:48:11,579
minimum number of hotels that I need so

1154
00:48:11,579 --> 00:48:12,900
that this computation is perfectly

1155
00:48:12,900 --> 00:48:15,599
secured in the semi anesthetic

1156
00:48:15,599 --> 00:48:17,400
um so now naturally we want to ask

1157
00:48:17,400 --> 00:48:18,839
what's the relation between exercise and

1158
00:48:18,839 --> 00:48:20,520
the OT complexity

1159
00:48:20,520 --> 00:48:21,960
um and you find that the SDF complexity

1160
00:48:21,960 --> 00:48:24,240
lower bonds rotate complexity nvp showed

1161
00:48:24,240 --> 00:48:25,680
this result for deterministic functions

1162
00:48:25,680 --> 00:48:27,240
in 2020 and I'll be extending it to

1163
00:48:27,240 --> 00:48:28,980
randomized functions

1164
00:48:28,980 --> 00:48:31,079
um so here is the reduction from a two

1165
00:48:31,079 --> 00:48:33,599
PC to sdcr for deterministic functions

1166
00:48:33,599 --> 00:48:35,520
that they had shown uh which goes as

1167
00:48:35,520 --> 00:48:37,020
follows so Alice and Bob received their

1168
00:48:37,020 --> 00:48:38,700
inputs X and Y

1169
00:48:38,700 --> 00:48:40,560
um then they receive a transcript Q star

1170
00:48:40,560 --> 00:48:43,020
from a correlated Randomness they then

1171
00:48:43,020 --> 00:48:45,119
check if this transcript is compatible

1172
00:48:45,119 --> 00:48:46,920
with their inputs this means that they

1173
00:48:46,920 --> 00:48:48,780
check if this transcript is something

1174
00:48:48,780 --> 00:48:51,119
that they could have generated when they

1175
00:48:51,119 --> 00:48:52,920
received input X and Y in the two PC

1176
00:48:52,920 --> 00:48:55,619
that they were given and if it is indeed

1177
00:48:55,619 --> 00:48:57,300
compatible then they sample their

1178
00:48:57,300 --> 00:48:59,160
outputs and the sample a view of the OT

1179
00:48:59,160 --> 00:49:01,140
now you can visualize this as doing the

1180
00:49:01,140 --> 00:49:02,819
exact reverse of what was happening in

1181
00:49:02,819 --> 00:49:04,619
the two PC case where Alice and Bob

1182
00:49:04,619 --> 00:49:06,119
received the unv and then they generated

1183
00:49:06,119 --> 00:49:08,460
the Q star here they're doing the exact

1184
00:49:08,460 --> 00:49:10,440
opposite they're getting a q star and

1185
00:49:10,440 --> 00:49:11,880
they're sampling a unv that was

1186
00:49:11,880 --> 00:49:13,740
compatible with Q star they obviously

1187
00:49:13,740 --> 00:49:14,940
want to check if this event we are

1188
00:49:14,940 --> 00:49:17,040
compatible so they send it to a Oracle

1189
00:49:17,040 --> 00:49:19,440
file and conditions on this Oracle

1190
00:49:19,440 --> 00:49:21,000
accepting they know that their views are

1191
00:49:21,000 --> 00:49:22,680
compatible with each other and so their

1192
00:49:22,680 --> 00:49:24,780
outputs are also correct by correctness

1193
00:49:24,780 --> 00:49:27,180
of the two PC uh to extend this to

1194
00:49:27,180 --> 00:49:29,160
randomized functions uh the first notice

1195
00:49:29,160 --> 00:49:31,319
that they cannot compute compatibility

1196
00:49:31,319 --> 00:49:33,780
with just inputs so they need both the

1197
00:49:33,780 --> 00:49:35,339
input and the output to check if the

1198
00:49:35,339 --> 00:49:37,680
transcript is compatible or not so the

1199
00:49:37,680 --> 00:49:39,300
first step will be to sample the outputs

1200
00:49:39,300 --> 00:49:40,859
so Alice involve get the inputs the

1201
00:49:40,859 --> 00:49:42,599
sample their outputs they receive a

1202
00:49:42,599 --> 00:49:43,920
transcript and they check that if this

1203
00:49:43,920 --> 00:49:45,119
transcript is compatible with their

1204
00:49:45,119 --> 00:49:47,400
input output pair if it is then they

1205
00:49:47,400 --> 00:49:49,200
will sample the view of the OT and

1206
00:49:49,200 --> 00:49:51,060
condition on this article accepting they

1207
00:49:51,060 --> 00:49:53,940
know that their outputs are correct

1208
00:49:53,940 --> 00:49:55,079
um

1209
00:49:55,079 --> 00:49:57,180
okay so this reduction will basically

1210
00:49:57,180 --> 00:49:59,460
tell you that um sdcr complexity lower

1211
00:49:59,460 --> 00:50:01,319
bound zot complexity for randomized and

1212
00:50:01,319 --> 00:50:03,599
deterministic functions and uh quick

1213
00:50:03,599 --> 00:50:04,920
remark is that I have not used any

1214
00:50:04,920 --> 00:50:06,599
specific properties of the OT so you

1215
00:50:06,599 --> 00:50:07,619
could have replaced it with any

1216
00:50:07,619 --> 00:50:10,319
Randomness by P

1217
00:50:10,319 --> 00:50:11,339
um now I'll be defining the balance

1218
00:50:11,339 --> 00:50:12,780
embedding which is a simplification of

1219
00:50:12,780 --> 00:50:14,220
dsvcr

1220
00:50:14,220 --> 00:50:15,480
um and to develop an intuition for

1221
00:50:15,480 --> 00:50:16,740
balance embedding I'll be referring to

1222
00:50:16,740 --> 00:50:18,839
the evaluation graph of a function which

1223
00:50:18,839 --> 00:50:20,760
is defined as follows so for a function

1224
00:50:20,760 --> 00:50:22,560
extra of Y to a cross b i define the

1225
00:50:22,560 --> 00:50:25,260
evaluation graph to be a bipartite graph

1226
00:50:25,260 --> 00:50:27,300
on the input output pair of RS to the

1227
00:50:27,300 --> 00:50:29,339
input output pair of Bob such that the

1228
00:50:29,339 --> 00:50:31,800
weight on the edge x a y b is the

1229
00:50:31,800 --> 00:50:33,720
probability of sampling a b as outputs

1230
00:50:33,720 --> 00:50:35,520
when given X y's inputs to the function

1231
00:50:35,520 --> 00:50:36,780
s

1232
00:50:36,780 --> 00:50:38,579
um so this is just a demograph for the

1233
00:50:38,579 --> 00:50:41,819
Pinoy coin toss and first I want to

1234
00:50:41,819 --> 00:50:43,440
convince you that sdcr is in graph

1235
00:50:43,440 --> 00:50:45,900
embedding how to do that so given an

1236
00:50:45,900 --> 00:50:48,660
sdcr uh given input X and Y what the

1237
00:50:48,660 --> 00:50:50,339
sdcr protocol will give you the

1238
00:50:50,339 --> 00:50:52,319
probability that Alice samples this view

1239
00:50:52,319 --> 00:50:54,660
of the otu and it samples the output a

1240
00:50:54,660 --> 00:50:56,460
now I can visualize this as a

1241
00:50:56,460 --> 00:50:58,619
probabilistic map from nodes in the

1242
00:50:58,619 --> 00:51:00,000
evaluation graph to node in the

1243
00:51:00,000 --> 00:51:03,359
predicate graph and um why am I calling

1244
00:51:03,359 --> 00:51:05,160
this probabilistic map and embedding

1245
00:51:05,160 --> 00:51:07,440
because each Edge in the evaluation

1246
00:51:07,440 --> 00:51:09,540
graph corresponds to the bunch of edges

1247
00:51:09,540 --> 00:51:11,700
in the predicate graph of the between

1248
00:51:11,700 --> 00:51:13,619
the map nodes so this blue edge

1249
00:51:13,619 --> 00:51:15,660
corresponds to this bunch of blue edges

1250
00:51:15,660 --> 00:51:17,520
in the predicate graph because this is

1251
00:51:17,520 --> 00:51:19,500
what these nodes are mapping to and so

1252
00:51:19,500 --> 00:51:21,480
because I'm embedding I'm mapping each

1253
00:51:21,480 --> 00:51:23,700
single edge to a bunch of edges in the

1254
00:51:23,700 --> 00:51:24,660
predicated graph I am essentially

1255
00:51:24,660 --> 00:51:27,720
embedding this into this graph

1256
00:51:27,720 --> 00:51:29,880
um now we want to consider that Alice is

1257
00:51:29,880 --> 00:51:31,680
semi honest so what is what information

1258
00:51:31,680 --> 00:51:34,740
can Alice get from of the input input

1259
00:51:34,740 --> 00:51:36,240
output of Bob using the information it

1260
00:51:36,240 --> 00:51:38,460
gets from YouTube now there are there

1261
00:51:38,460 --> 00:51:40,020
are two ways that Alice can get from U2

1262
00:51:40,020 --> 00:51:42,599
to Y and B1 in this graph the first is

1263
00:51:42,599 --> 00:51:44,520
using the protocol so it crosses the

1264
00:51:44,520 --> 00:51:46,800
predicate graph from left to right uh in

1265
00:51:46,800 --> 00:51:48,900
the it crosses the critical graph and

1266
00:51:48,900 --> 00:51:50,520
then goes on the predicated graph to the

1267
00:51:50,520 --> 00:51:51,720
evaluation graph of the function using

1268
00:51:51,720 --> 00:51:54,720
box protocol or it could go from the

1269
00:51:54,720 --> 00:51:56,339
predicate graph to the evaluation graph

1270
00:51:56,339 --> 00:51:58,319
using its simulator and then cross the

1271
00:51:58,319 --> 00:51:59,819
evaluation graph of the function because

1272
00:51:59,819 --> 00:52:01,800
it knows the function already

1273
00:52:01,800 --> 00:52:04,680
um and for security we basically wanted

1274
00:52:04,680 --> 00:52:05,940
this

1275
00:52:05,940 --> 00:52:08,579
uh green blue path should be the same as

1276
00:52:08,579 --> 00:52:10,680
this blue Orange Path I'll be referring

1277
00:52:10,680 --> 00:52:12,240
to this figure soon enough when uh to

1278
00:52:12,240 --> 00:52:13,380
develop intuition for the balanced

1279
00:52:13,380 --> 00:52:14,579
embedding

1280
00:52:14,579 --> 00:52:16,500
um so the balance embedding between a

1281
00:52:16,500 --> 00:52:19,079
bipartite graph g into another bipartite

1282
00:52:19,079 --> 00:52:21,900
graph H is defined as follows it is a

1283
00:52:21,900 --> 00:52:24,180
tuple of two maps Pi n Theta that

1284
00:52:24,180 --> 00:52:25,680
balance each other

1285
00:52:25,680 --> 00:52:28,140
um what is this balancing so consider

1286
00:52:28,140 --> 00:52:29,760
the fccr case when I said that this

1287
00:52:29,760 --> 00:52:31,079
green blue edge should be equal to the

1288
00:52:31,079 --> 00:52:33,240
blue orange Edge I just call this a

1289
00:52:33,240 --> 00:52:36,180
replace this green Edge by Theta I

1290
00:52:36,180 --> 00:52:38,819
relabel this oriented as Y and I said

1291
00:52:38,819 --> 00:52:40,319
that the balancing is similar to the

1292
00:52:40,319 --> 00:52:42,359
security condition in sgcr that the

1293
00:52:42,359 --> 00:52:43,859
green blue X should be equal to the blue

1294
00:52:43,859 --> 00:52:46,319
Orange Path which I can represent by

1295
00:52:46,319 --> 00:52:48,599
this equation now uh this is a super

1296
00:52:48,599 --> 00:52:49,980
formalized definition of the balance

1297
00:52:49,980 --> 00:52:51,660
embedding uh where the first two

1298
00:52:51,660 --> 00:52:53,220
equations are just The Balancing Act of

1299
00:52:53,220 --> 00:52:54,480
prime Theta and the other two equations

1300
00:52:54,480 --> 00:52:56,940
are just normalization uh similar to the

1301
00:52:56,940 --> 00:52:58,319
svcr case now we want to define the

1302
00:52:58,319 --> 00:53:00,480
complexity so I replace the lower thing

1303
00:53:00,480 --> 00:53:03,059
the H graph with M and switches of 40

1304
00:53:03,059 --> 00:53:04,800
and Define the balance emitting

1305
00:53:04,800 --> 00:53:06,300
complexity to the smallest number of OT

1306
00:53:06,300 --> 00:53:08,400
so that I can embed the graph for GF

1307
00:53:08,400 --> 00:53:09,180
into

1308
00:53:09,180 --> 00:53:11,280
Otis to n

1309
00:53:11,280 --> 00:53:13,020
um now I move on to the main result of

1310
00:53:13,020 --> 00:53:14,640
the stock that is bounding the balance

1311
00:53:14,640 --> 00:53:16,440
limiting complexity of the pinosity

1312
00:53:16,440 --> 00:53:18,800
pointers

1313
00:53:19,520 --> 00:53:22,079
where the thick edges correspond to an

1314
00:53:22,079 --> 00:53:24,119
increased probability so when p is small

1315
00:53:24,119 --> 00:53:26,819
uh the edges between same output for RNs

1316
00:53:26,819 --> 00:53:29,099
and Bob is higher than the thickness for

1317
00:53:29,099 --> 00:53:32,160
them getting different outputs and now I

1318
00:53:32,160 --> 00:53:34,319
want to embed this into OT raised to m

1319
00:53:34,319 --> 00:53:36,480
so given a balance I'm building

1320
00:53:36,480 --> 00:53:38,880
um let's just assume that this um 0 a

1321
00:53:38,880 --> 00:53:40,559
marks to this bunch of yellow nodes in

1322
00:53:40,559 --> 00:53:42,300
the predicted graph the 1A maps to this

1323
00:53:42,300 --> 00:53:44,040
bunch of orange inverse in the predicate

1324
00:53:44,040 --> 00:53:46,380
graph we are able to show that there is

1325
00:53:46,380 --> 00:53:47,280
a v

1326
00:53:47,280 --> 00:53:49,980
which which gets marked from 1B such

1327
00:53:49,980 --> 00:53:52,500
that the number of edges to any group of

1328
00:53:52,500 --> 00:53:53,400
nodes

1329
00:53:53,400 --> 00:53:54,780
corresponds to the thickness of the

1330
00:53:54,780 --> 00:53:57,000
identity evaluation graph so the orange

1331
00:53:57,000 --> 00:54:00,059
degree of this V3 node curve is

1332
00:54:00,059 --> 00:54:01,740
proportional to the thickness of this

1333
00:54:01,740 --> 00:54:03,839
node this Edge and the yellow degree is

1334
00:54:03,839 --> 00:54:05,099
proportion to the thickness of this Edge

1335
00:54:05,099 --> 00:54:07,740
now so as you can see this is thicker

1336
00:54:07,740 --> 00:54:09,420
than this so the number of oranges

1337
00:54:09,420 --> 00:54:10,619
should be more than the number of yellow

1338
00:54:10,619 --> 00:54:14,040
is how much more uh 1 over 1 minus P by

1339
00:54:14,040 --> 00:54:16,380
P and the number of the ratio of the

1340
00:54:16,380 --> 00:54:17,819
number of edges is definitely upper

1341
00:54:17,819 --> 00:54:19,260
bounded by the total number of vertices

1342
00:54:19,260 --> 00:54:21,119
in the left hand side of the graph which

1343
00:54:21,119 --> 00:54:22,800
is 2 raised to M this gives you the

1344
00:54:22,800 --> 00:54:24,599
linear bound on the uh balanced

1345
00:54:24,599 --> 00:54:28,260
embedding complexity as log 1 over p

1346
00:54:28,260 --> 00:54:30,300
um so I showed that uh we showed that

1347
00:54:30,300 --> 00:54:31,740
the balance embedding complexity is

1348
00:54:31,740 --> 00:54:33,599
Omega log 1 over p and we've already

1349
00:54:33,599 --> 00:54:35,400
shown that this complexity lower bounds

1350
00:54:35,400 --> 00:54:37,800
the OT complexity so basically we now

1351
00:54:37,800 --> 00:54:40,140
know that deota complexity is tight and

1352
00:54:40,140 --> 00:54:42,420
it's Theta log 1 by P

1353
00:54:42,420 --> 00:54:44,280
um in this talk I focus mostly on

1354
00:54:44,280 --> 00:54:46,500
randomized functions but uh it Still

1355
00:54:46,500 --> 00:54:48,359
Remains open to see if we can get super

1356
00:54:48,359 --> 00:54:50,099
linear balance embedding complexity for

1357
00:54:50,099 --> 00:54:52,079
deterministic functions or not

1358
00:54:52,079 --> 00:54:53,760
um if if we wanted to prove something

1359
00:54:53,760 --> 00:54:55,319
for an explicit function then we would

1360
00:54:55,319 --> 00:54:57,359
face circuit complexity barriers but

1361
00:54:57,359 --> 00:54:59,640
perhaps it is uh easier to show the

1362
00:54:59,640 --> 00:55:02,099
balance embedding complexity um it is

1363
00:55:02,099 --> 00:55:03,240
easier to show that there exist

1364
00:55:03,240 --> 00:55:04,980
functions that have super linear balance

1365
00:55:04,980 --> 00:55:06,599
limiting complexity

1366
00:55:06,599 --> 00:55:09,500
um that's it thank you

1367
00:55:12,000 --> 00:55:14,599
foreign

1368
00:55:21,180 --> 00:55:23,720
yeah so I guess I have I have questions

1369
00:55:23,720 --> 00:55:27,119
mainly about the open the open stuff

1370
00:55:27,119 --> 00:55:29,040
that you wrote down here like so you're

1371
00:55:29,040 --> 00:55:32,700
saying uh like probabilistic method pick

1372
00:55:32,700 --> 00:55:37,500
a random function uh like it's not clear

1373
00:55:37,500 --> 00:55:39,599
whether you can show a lower bound on

1374
00:55:39,599 --> 00:55:41,760
this embedding complexity because that

1375
00:55:41,760 --> 00:55:43,440
that would suffice that that's what you

1376
00:55:43,440 --> 00:55:44,460
said right

1377
00:55:44,460 --> 00:55:45,079
um

1378
00:55:45,079 --> 00:55:47,160
to say that if you've picked a function

1379
00:55:47,160 --> 00:55:50,280
at random and and and were able to bound

1380
00:55:50,280 --> 00:55:52,680
this embedding complexity measure the

1381
00:55:52,680 --> 00:55:55,319
here was a lower bounded than this would

1382
00:55:55,319 --> 00:55:56,579
then this would answer this question

1383
00:55:56,579 --> 00:55:59,339
right uh no I'm thinking that uh for the

1384
00:55:59,339 --> 00:56:01,440
randomized function so that the outputs

1385
00:56:01,440 --> 00:56:03,660
are not deterministic for Alpha and Bob

1386
00:56:03,660 --> 00:56:06,059
uh we already have approved a super

1387
00:56:06,059 --> 00:56:09,540
linear lower bound right but a a

1388
00:56:09,540 --> 00:56:11,460
deterministic function selects it at

1389
00:56:11,460 --> 00:56:13,859
random that's what this is here so

1390
00:56:13,859 --> 00:56:15,480
you're saying it's not clear it's not

1391
00:56:15,480 --> 00:56:17,720
clear what the embedding complexity of a

1392
00:56:17,720 --> 00:56:20,099
random deterministic function looks like

1393
00:56:20,099 --> 00:56:22,619
yeah so I mean all we know is that it's

1394
00:56:22,619 --> 00:56:24,420
more than linear but we don't we cannot

1395
00:56:24,420 --> 00:56:25,859
we don't have a proof that there are

1396
00:56:25,859 --> 00:56:27,300
super linear value limiting complexities

1397
00:56:27,300 --> 00:56:31,460
got it thanks other questions

1398
00:56:31,980 --> 00:56:35,300
all right let's thank the speaker again

1399
00:56:36,200 --> 00:56:39,180
now we'll resume in a little over 30

1400
00:56:39,180 --> 00:56:41,480
minutes

