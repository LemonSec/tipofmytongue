1
00:00:00,000 --> 00:00:01,620
and Parish

2
00:00:01,620 --> 00:00:03,899
and we're looking at this problem of

3
00:00:03,899 --> 00:00:07,200
forward secrecy for encryption so

4
00:00:07,200 --> 00:00:10,620
forward secrecy just to recap is the

5
00:00:10,620 --> 00:00:13,440
property that the compromise of a party

6
00:00:13,440 --> 00:00:17,039
today should not affect negatively what

7
00:00:17,039 --> 00:00:19,020
happened in the past

8
00:00:19,020 --> 00:00:22,199
and over the past couple of years sort

9
00:00:22,199 --> 00:00:25,019
of forward secrecy generally moves

10
00:00:25,019 --> 00:00:27,960
towards sort of from this course grind

11
00:00:27,960 --> 00:00:30,779
notion like key exchange where you say

12
00:00:30,779 --> 00:00:33,480
one secession is done

13
00:00:33,480 --> 00:00:35,820
you can delete everything and then it

14
00:00:35,820 --> 00:00:38,040
shouldn't affect anymore towards a more

15
00:00:38,040 --> 00:00:41,100
fine-grained notion and a prominent

16
00:00:41,100 --> 00:00:44,640
example that sort of also was the basis

17
00:00:44,640 --> 00:00:47,520
for the motivation for this work was

18
00:00:47,520 --> 00:00:49,800
Secure messaging where you think of a

19
00:00:49,800 --> 00:00:53,039
very long running session and you expect

20
00:00:53,039 --> 00:00:55,739
that compromises might happen at any

21
00:00:55,739 --> 00:00:58,039
time

22
00:00:58,039 --> 00:01:01,140
and such Notions usually involve some

23
00:01:01,140 --> 00:01:03,500
kind of an epoch

24
00:01:03,500 --> 00:01:07,560
and what we realized is sort of the none

25
00:01:07,560 --> 00:01:09,659
of those Notions really considers the

26
00:01:09,659 --> 00:01:11,760
fact that you might have turned off your

27
00:01:11,760 --> 00:01:13,680
phone for a very prolonged time maybe

28
00:01:13,680 --> 00:01:15,600
it's like your secondary phone or

29
00:01:15,600 --> 00:01:18,180
something and then this device is like

30
00:01:18,180 --> 00:01:21,299
stuck in a very oldy Pock and might now

31
00:01:21,299 --> 00:01:23,220
want to catch up

32
00:01:23,220 --> 00:01:26,340
and it seems that many of the forward

33
00:01:26,340 --> 00:01:28,500
secure primitive essentially then

34
00:01:28,500 --> 00:01:31,860
required a device to process all the

35
00:01:31,860 --> 00:01:33,780
message they missed when it was turned

36
00:01:33,780 --> 00:01:36,479
off or didn't receive message in

37
00:01:36,479 --> 00:01:39,600
sequence and like why is this bad well

38
00:01:39,600 --> 00:01:41,939
think of secure messaging you're

39
00:01:41,939 --> 00:01:43,619
probably more

40
00:01:43,619 --> 00:01:45,900
interested in receiving and being able

41
00:01:45,900 --> 00:01:48,240
to read the most recent message than

42
00:01:48,240 --> 00:01:51,119
something that was sent to you like a

43
00:01:51,119 --> 00:01:52,740
month ago

44
00:01:52,740 --> 00:01:56,460
and also for instance if you look at the

45
00:01:56,460 --> 00:02:00,000
MLS group messaging standard there you

46
00:02:00,000 --> 00:02:01,680
being able to send a message actually

47
00:02:01,680 --> 00:02:04,439
requires you to have the latest key

48
00:02:04,439 --> 00:02:06,420
because otherwise the other people would

49
00:02:06,420 --> 00:02:09,479
no longer be able to decrypt so you

50
00:02:09,479 --> 00:02:12,720
probably don't want to have to decrypt

51
00:02:12,720 --> 00:02:14,580
everything in sequence just to be able

52
00:02:14,580 --> 00:02:17,400
to send a message

53
00:02:17,400 --> 00:02:21,060
so in this paper we consider this novel

54
00:02:21,060 --> 00:02:23,280
dimension of what we call fast

55
00:02:23,280 --> 00:02:26,160
forwarding that's just you being able to

56
00:02:26,160 --> 00:02:28,739
jump to sort of the latest state in

57
00:02:28,739 --> 00:02:30,480
sub-linear time

58
00:02:30,480 --> 00:02:32,520
and we consider it for two settings

59
00:02:32,520 --> 00:02:35,000
first in the symmetric

60
00:02:35,000 --> 00:02:37,379
encryption setting where we look at

61
00:02:37,379 --> 00:02:39,480
actually a prg from which you then

62
00:02:39,480 --> 00:02:41,340
somehow can build

63
00:02:41,340 --> 00:02:44,280
a forward secure streaming site for

64
00:02:44,280 --> 00:02:47,099
Trivium and second a bit more

65
00:02:47,099 --> 00:02:49,080
interesting in the asymmetric setting

66
00:02:49,080 --> 00:02:50,640
where we look at

67
00:02:50,640 --> 00:02:53,760
what we call updatable public encryption

68
00:02:53,760 --> 00:02:55,440
and they will introduce the Primitive

69
00:02:55,440 --> 00:02:57,420
play too

70
00:02:57,420 --> 00:03:00,120
okay so first let's briefly look at the

71
00:03:00,120 --> 00:03:02,819
symmetric setting and there we sort of

72
00:03:02,819 --> 00:03:04,860
started by realizing that even though

73
00:03:04,860 --> 00:03:07,800
nobody ever formalized this property of

74
00:03:07,800 --> 00:03:09,480
fast forwarding there's a folklore

75
00:03:09,480 --> 00:03:11,040
Construction

76
00:03:11,040 --> 00:03:14,519
more concretely if you take the GTM

77
00:03:14,519 --> 00:03:17,340
prf construction and you adapt sort of

78
00:03:17,340 --> 00:03:20,280
the templates people came up to get

79
00:03:20,280 --> 00:03:22,680
forward secure signature schemes to it

80
00:03:22,680 --> 00:03:26,280
then you get a forward secure PRT that

81
00:03:26,280 --> 00:03:28,860
allows you to fast forward

82
00:03:28,860 --> 00:03:31,560
so take the GTM tree

83
00:03:31,560 --> 00:03:34,500
and you say that the epoch keys are

84
00:03:34,500 --> 00:03:38,280
actually the the key the leaf case

85
00:03:38,280 --> 00:03:40,980
and then in Epoch one you would store

86
00:03:40,980 --> 00:03:44,220
like the blue since here in Epoch 2 you

87
00:03:44,220 --> 00:03:47,040
would store those in impoke free so on

88
00:03:47,040 --> 00:03:50,400
so all of the future keys at any point

89
00:03:50,400 --> 00:03:52,500
you will be able to derive in locator

90
00:03:52,500 --> 00:03:54,360
implemented

91
00:03:54,360 --> 00:03:58,680
um PRT derivations but at the same time

92
00:03:58,680 --> 00:04:02,180
you get forward secrecy

93
00:04:02,340 --> 00:04:06,360
so but one thing we can observe is that

94
00:04:06,360 --> 00:04:08,760
this requires logarithmic local storage

95
00:04:08,760 --> 00:04:12,659
and local Richmond computation even if

96
00:04:12,659 --> 00:04:15,000
you sort of iterate through the epochs

97
00:04:15,000 --> 00:04:17,820
sequentially and sort of wearing

98
00:04:17,820 --> 00:04:20,699
authorizations hat we think okay can we

99
00:04:20,699 --> 00:04:22,380
do better

100
00:04:22,380 --> 00:04:25,199
and why we don't have like a

101
00:04:25,199 --> 00:04:27,900
clear answer to that what we do is we

102
00:04:27,900 --> 00:04:31,259
consider an alternative model where we

103
00:04:31,259 --> 00:04:32,940
assume that there's some kind of public

104
00:04:32,940 --> 00:04:35,580
bulletin board where you can store and

105
00:04:35,580 --> 00:04:36,740
retrieve

106
00:04:36,740 --> 00:04:40,139
values and then which it seems we can do

107
00:04:40,139 --> 00:04:42,780
better now obviously this introduces

108
00:04:42,780 --> 00:04:45,060
like a communication overhead and for

109
00:04:45,060 --> 00:04:46,740
many applications you probably would

110
00:04:46,740 --> 00:04:48,540
rather do logarithmic many local

111
00:04:48,540 --> 00:04:50,940
computation than even one round of

112
00:04:50,940 --> 00:04:53,580
communication but

113
00:04:53,580 --> 00:04:55,740
there are applications where you anyway

114
00:04:55,740 --> 00:04:58,259
need to do a lot of communications or

115
00:04:58,259 --> 00:05:01,860
maybe that's not the fact there

116
00:05:01,860 --> 00:05:04,919
okay so what do we do

117
00:05:04,919 --> 00:05:07,979
we construct a fast forwardable forward

118
00:05:07,979 --> 00:05:10,620
secure prg that has local

119
00:05:10,620 --> 00:05:13,740
that has constant local storage constant

120
00:05:13,740 --> 00:05:16,380
sequential updates and logarithmic fast

121
00:05:16,380 --> 00:05:18,120
forwarding both in terms of

122
00:05:18,120 --> 00:05:20,340
communication and

123
00:05:20,340 --> 00:05:22,560
computation

124
00:05:22,560 --> 00:05:24,900
and what we do is essentially we

125
00:05:24,900 --> 00:05:30,240
amortize the GTM construction by storing

126
00:05:30,240 --> 00:05:33,120
um encryptions on this bulletin board so

127
00:05:33,120 --> 00:05:35,340
each of the arrows here

128
00:05:35,340 --> 00:05:37,560
sort of

129
00:05:37,560 --> 00:05:38,160
um

130
00:05:38,160 --> 00:05:42,060
is an encryption so you would take

131
00:05:42,060 --> 00:05:45,479
like the key here and you would encrypt

132
00:05:45,479 --> 00:05:47,699
it under the key here and store that

133
00:05:47,699 --> 00:05:50,160
encryption on the bulletin board and

134
00:05:50,160 --> 00:05:52,440
then locally you would just store like

135
00:05:52,440 --> 00:05:53,580
the blue

136
00:05:53,580 --> 00:05:56,699
seeds using the bulletin board you can

137
00:05:56,699 --> 00:05:58,919
retrieve the green ones and that still

138
00:05:58,919 --> 00:06:01,620
gives you logarithmic fast forwarding

139
00:06:01,620 --> 00:06:05,400
for all the future epochs

140
00:06:05,400 --> 00:06:08,820
so for Epoch two this situation would

141
00:06:08,820 --> 00:06:11,759
look something like this and

142
00:06:11,759 --> 00:06:14,699
without going too much into detail you

143
00:06:14,699 --> 00:06:16,500
can see that we actually store like two

144
00:06:16,500 --> 00:06:18,479
elements locally

145
00:06:18,479 --> 00:06:21,259
one of them is like the current element

146
00:06:21,259 --> 00:06:24,060
and the other one is what we call the

147
00:06:24,060 --> 00:06:26,280
frontier which is sort of the place

148
00:06:26,280 --> 00:06:28,680
where you will do the next expansions

149
00:06:28,680 --> 00:06:31,259
for because due to the amortization

150
00:06:31,259 --> 00:06:34,199
process you sort of expands a bit faster

151
00:06:34,199 --> 00:06:36,720
than you need more concretely you do

152
00:06:36,720 --> 00:06:39,300
like two expansion step for every Epoch

153
00:06:39,300 --> 00:06:41,340
change so this starts to run ahead and

154
00:06:41,340 --> 00:06:44,880
ahead and so storing this one additional

155
00:06:44,880 --> 00:06:47,699
local node allows you to nevertheless do

156
00:06:47,699 --> 00:06:50,819
everything efficient

157
00:06:50,819 --> 00:06:56,039
okay so much about the symmetric case I

158
00:06:56,039 --> 00:06:58,620
mean if you want to look at the details

159
00:06:58,620 --> 00:07:01,280
feel free to look at the paper on ePrint

160
00:07:01,280 --> 00:07:04,560
it was slightly tricky to get like the

161
00:07:04,560 --> 00:07:07,380
details correct but I think overall the

162
00:07:07,380 --> 00:07:10,280
idea is sort of quite simple you just

163
00:07:10,280 --> 00:07:13,319
amortize this GTM construction by

164
00:07:13,319 --> 00:07:15,720
storing encryptions online on this

165
00:07:15,720 --> 00:07:18,440
bulletin board

166
00:07:18,900 --> 00:07:21,539
so with that out of the way let's look

167
00:07:21,539 --> 00:07:23,819
at the asymmetric setting which was

168
00:07:23,819 --> 00:07:26,460
actually sort of the motivation for this

169
00:07:26,460 --> 00:07:28,319
work to begin with

170
00:07:28,319 --> 00:07:31,860
and there we realized that essentially

171
00:07:31,860 --> 00:07:35,220
the only known fast forward no the only

172
00:07:35,220 --> 00:07:37,199
known forward Secure Public encryption

173
00:07:37,199 --> 00:07:39,240
actually is sort of this generic

174
00:07:39,240 --> 00:07:41,940
construction from hierarchical Identity

175
00:07:41,940 --> 00:07:44,160
based encryption or higher

176
00:07:44,160 --> 00:07:47,880
and this sort of really mean mirrors

177
00:07:47,880 --> 00:07:49,860
what the teaching construction does

178
00:07:49,860 --> 00:07:54,979
anyway so are we done well not exactly

179
00:07:54,979 --> 00:07:58,080
on the one hand

180
00:07:58,080 --> 00:08:00,660
if we talk to more of the Practical

181
00:08:00,660 --> 00:08:02,900
people that are maybe not here at TCC

182
00:08:02,900 --> 00:08:05,759
they will tell you that

183
00:08:05,759 --> 00:08:08,099
even though there has been like a lot of

184
00:08:08,099 --> 00:08:10,440
great progress in making hype more and

185
00:08:10,440 --> 00:08:13,139
more efficient it's still sort of less

186
00:08:13,139 --> 00:08:16,259
efficient than what they would like

187
00:08:16,259 --> 00:08:19,500
moreover this amortization process with

188
00:08:19,500 --> 00:08:21,599
the bulletin board doesn't really

189
00:08:21,599 --> 00:08:24,660
doesn't work as nicely in this setting

190
00:08:24,660 --> 00:08:26,819
as it did in the symmetric

191
00:08:26,819 --> 00:08:29,780
because now the people

192
00:08:29,780 --> 00:08:33,179
decrypting can sort of not help

193
00:08:33,179 --> 00:08:35,279
the you know the people encrypting

194
00:08:35,279 --> 00:08:37,500
cannot help the decrypting party to

195
00:08:37,500 --> 00:08:40,799
maintain the bulletin board because only

196
00:08:40,799 --> 00:08:43,320
the decrypting party obviously know the

197
00:08:43,320 --> 00:08:45,240
secret keys so

198
00:08:45,240 --> 00:08:48,120
if the encrypting party runs way ahead

199
00:08:48,120 --> 00:08:50,220
of the deep and the decrypting one is

200
00:08:50,220 --> 00:08:54,360
dark then we don't get as nice

201
00:08:54,360 --> 00:08:57,720
properties as in the symmetric case so

202
00:08:57,720 --> 00:09:00,899
we thought okay what can we do well we

203
00:09:00,899 --> 00:09:04,140
can simply look at another primitive and

204
00:09:04,140 --> 00:09:06,779
the Primitive we look at is this

205
00:09:06,779 --> 00:09:11,839
updatable public encryption or upke

206
00:09:11,839 --> 00:09:16,360
which we introduced so this is

207
00:09:16,360 --> 00:09:19,040
[Music]

208
00:09:19,040 --> 00:09:21,540
introduced that in the context of secure

209
00:09:21,540 --> 00:09:24,480
messaging a couple of years ago

210
00:09:24,480 --> 00:09:28,019
and this primitive on the one hand is

211
00:09:28,019 --> 00:09:30,600
sort of like a regular public encryption

212
00:09:30,600 --> 00:09:32,880
and on the other hand it comes with like

213
00:09:32,880 --> 00:09:35,940
an explicit updating mechanism where you

214
00:09:35,940 --> 00:09:38,160
can generate an update and apply it to

215
00:09:38,160 --> 00:09:40,920
the public key and the secret key

216
00:09:40,920 --> 00:09:44,399
the upside of that primitive is that at

217
00:09:44,399 --> 00:09:46,740
least in the ROM you can get it

218
00:09:46,740 --> 00:09:49,680
essentially as efficient as public

219
00:09:49,680 --> 00:09:54,360
encryption the downside is that it

220
00:09:54,360 --> 00:09:55,260
doesn't

221
00:09:55,260 --> 00:09:58,260
that on the one hand it requires some

222
00:09:58,260 --> 00:10:01,019
synchronization on the other hand you

223
00:10:01,019 --> 00:10:03,480
don't get any fast forwarding at all so

224
00:10:03,480 --> 00:10:05,640
all the known construction that are

225
00:10:05,640 --> 00:10:07,740
efficient sort of you need now really

226
00:10:07,740 --> 00:10:09,959
this sequential processing of all the

227
00:10:09,959 --> 00:10:13,160
updates you missed

228
00:10:13,380 --> 00:10:17,220
okay so in this paper what we do is we

229
00:10:17,220 --> 00:10:19,560
give a generic construction of a

230
00:10:19,560 --> 00:10:21,920
duplicate scheme with fast forwarding

231
00:10:21,920 --> 00:10:25,500
Pro math very much related primitive

232
00:10:25,500 --> 00:10:29,700
which we call update homomorphic UK

233
00:10:29,700 --> 00:10:32,660
update homomorphic APK essentially

234
00:10:32,660 --> 00:10:36,300
augments this primitive with one more

235
00:10:36,300 --> 00:10:38,760
algorithm which is an update combined

236
00:10:38,760 --> 00:10:42,120
algorithm and the intuitive property you

237
00:10:42,120 --> 00:10:45,779
want is that whether you update to

238
00:10:45,779 --> 00:10:47,459
whether you apply to updates

239
00:10:47,459 --> 00:10:49,860
individually or you first combine them

240
00:10:49,860 --> 00:10:52,560
and then apply the combined update gives

241
00:10:52,560 --> 00:10:55,019
you the same thing

242
00:10:55,019 --> 00:10:58,380
and we can observe that actually there

243
00:10:58,380 --> 00:11:01,200
already exists schemes that satisfy this

244
00:11:01,200 --> 00:11:04,260
notion which are the one the standard

245
00:11:04,260 --> 00:11:06,959
model uppercase came recently introduced

246
00:11:06,959 --> 00:11:09,480
by Dotties weeks

247
00:11:09,480 --> 00:11:12,779
so we can just use those

248
00:11:12,779 --> 00:11:15,540
given this primitive we can then build

249
00:11:15,540 --> 00:11:20,279
fast forward the upk sort of with the

250
00:11:20,279 --> 00:11:23,279
idea of just storing what we call

251
00:11:23,279 --> 00:11:26,040
cumulative updates on the bulletin board

252
00:11:26,040 --> 00:11:28,800
so in each step

253
00:11:28,800 --> 00:11:30,980
the sending party would

254
00:11:30,980 --> 00:11:34,380
store an update and then once in a while

255
00:11:34,380 --> 00:11:36,660
they would also fetch all the updates

256
00:11:36,660 --> 00:11:39,779
and sort of aggregate them such that the

257
00:11:39,779 --> 00:11:42,680
party that the decrypting party can then

258
00:11:42,680 --> 00:11:47,220
apply them like in one step and the

259
00:11:47,220 --> 00:11:49,079
remaining question is sort of which of

260
00:11:49,079 --> 00:11:51,839
those updates to generate and this

261
00:11:51,839 --> 00:11:54,660
rephrase as a graph theoretic problem

262
00:11:54,660 --> 00:11:56,660
and

263
00:11:56,660 --> 00:11:59,820
propose a very nice craft that has some

264
00:11:59,820 --> 00:12:01,620
nice properties

265
00:12:01,620 --> 00:12:04,320
because what we observe is sort of what

266
00:12:04,320 --> 00:12:07,200
we need is a graph with flow diameter

267
00:12:07,200 --> 00:12:10,260
because that is directly relates to the

268
00:12:10,260 --> 00:12:12,120
efficiency of the updating

269
00:12:12,120 --> 00:12:15,839
then we want what we call a low cut so

270
00:12:15,839 --> 00:12:18,180
the shots just shouldn't be like too

271
00:12:18,180 --> 00:12:21,120
many updates in flight parallely and

272
00:12:21,120 --> 00:12:23,640
finally we want low in degrees for other

273
00:12:23,640 --> 00:12:26,579
efficiency reasons with that because I'm

274
00:12:26,579 --> 00:12:29,220
running out of time let me tell you

275
00:12:29,220 --> 00:12:31,079
about the open problems

276
00:12:31,079 --> 00:12:34,079
because the real problem is really that

277
00:12:34,079 --> 00:12:36,779
we don't have anything efficient so we

278
00:12:36,779 --> 00:12:39,660
need this update from a morphe qpke

279
00:12:39,660 --> 00:12:43,920
and right now the best we know sort of

280
00:12:43,920 --> 00:12:46,019
has like an overhead that's essentially

281
00:12:46,019 --> 00:12:49,040
linear in the security parameter so

282
00:12:49,040 --> 00:12:51,060
whereas normally you pick Keys

283
00:12:51,060 --> 00:12:53,459
essentially as efficient as public key

284
00:12:53,459 --> 00:12:56,820
and Corruption we now have to pay this

285
00:12:56,820 --> 00:12:59,700
price and it would really be amazing if

286
00:12:59,700 --> 00:13:01,740
any of you can come up with something

287
00:13:01,740 --> 00:13:04,860
that's more efficient maybe using this

288
00:13:04,860 --> 00:13:07,680
generic construction we use or maybe

289
00:13:07,680 --> 00:13:10,920
just do something completely else

290
00:13:10,920 --> 00:13:13,519
okay

291
00:13:13,860 --> 00:13:18,320
yeah so thank you for attention

292
00:13:40,260 --> 00:13:43,920
so we have two constructions so

293
00:13:43,920 --> 00:13:47,160
essentially it relates to the Assumption

294
00:13:47,160 --> 00:13:49,380
under which we one can build this update

295
00:13:49,380 --> 00:13:51,300
homomorphic APK

296
00:13:51,300 --> 00:13:54,360
and there exists currently like two

297
00:13:54,360 --> 00:13:57,360
construction one is based on ddh and one

298
00:13:57,360 --> 00:14:00,860
is based on lwe

299
00:14:04,160 --> 00:14:07,139
yeah so we need some kind of linear

300
00:14:07,139 --> 00:14:10,019
homomorphism the biggest caveat is sort

301
00:14:10,019 --> 00:14:12,420
of that we need linear homomorphism for

302
00:14:12,420 --> 00:14:15,000
message that roughly correspond to like

303
00:14:15,000 --> 00:14:18,600
secret keys whereas most efficient

304
00:14:18,600 --> 00:14:21,060
homomorphic public key encryption scheme

305
00:14:21,060 --> 00:14:23,339
give you a message space that

306
00:14:23,339 --> 00:14:25,560
corresponds to the public key spaces

307
00:14:25,560 --> 00:14:28,099
essentially

308
00:14:29,519 --> 00:14:32,880
so that's why we have this

309
00:14:32,880 --> 00:14:35,519
this overhead linear in the in the

310
00:14:35,519 --> 00:14:37,980
security parameter because we end up

311
00:14:37,980 --> 00:14:42,440
essentially sending updates bit by bit

312
00:14:43,980 --> 00:14:45,980
s

313
00:14:47,960 --> 00:14:51,830
[Laughter]

314
00:15:33,060 --> 00:15:35,719
foreign

315
00:15:37,279 --> 00:15:39,779
incompressible encryption from standard

316
00:15:39,779 --> 00:15:40,920
assumptions

317
00:15:40,920 --> 00:15:45,680
and Jessica is giving the talk

318
00:16:04,019 --> 00:16:07,699
we don't have sound on Zoom

319
00:16:40,220 --> 00:16:43,560
hello okay I'm louder now

320
00:16:43,560 --> 00:16:44,779
um

321
00:16:44,779 --> 00:16:48,060
okay uh again we have this scenario

322
00:16:48,060 --> 00:16:50,759
where Alice has this huge database let's

323
00:16:50,759 --> 00:16:53,100
say 500 terabytes and she wants to send

324
00:16:53,100 --> 00:16:55,019
it to Bob so

325
00:16:55,019 --> 00:16:57,899
um as cryptographers do they she

326
00:16:57,899 --> 00:17:00,720
encrypts the database and sends it to

327
00:17:00,720 --> 00:17:02,940
Bob so

328
00:17:02,940 --> 00:17:06,599
um now uh usually we model an adversary

329
00:17:06,599 --> 00:17:09,059
that gets access to the public key and

330
00:17:09,059 --> 00:17:11,400
to the ciphertext but

331
00:17:11,400 --> 00:17:16,140
um now uh now Bob is very prone to

332
00:17:16,140 --> 00:17:18,859
losing his keys and the adversaries

333
00:17:18,859 --> 00:17:21,780
might might pick up his secret key at

334
00:17:21,780 --> 00:17:24,500
some point so this is kind of an

335
00:17:24,500 --> 00:17:26,699
exploration of what we can still

336
00:17:26,699 --> 00:17:28,620
guarantee if the adversary get it at

337
00:17:28,620 --> 00:17:30,720
some point gets access to the secret key

338
00:17:30,720 --> 00:17:33,780
okay so yeah the adversary also gets

339
00:17:33,780 --> 00:17:36,059
access to the secret key and uh this

340
00:17:36,059 --> 00:17:38,640
obviously cannot happen unconditionally

341
00:17:38,640 --> 00:17:40,559
because then the adversary can just

342
00:17:40,559 --> 00:17:44,039
decrypt so let's get into what

343
00:17:44,039 --> 00:17:47,100
incompressible encryption is

344
00:17:47,100 --> 00:17:48,919
um this is uh

345
00:17:48,919 --> 00:17:51,120
indistinguishability against an

346
00:17:51,120 --> 00:17:52,679
eavesdropper

347
00:17:52,679 --> 00:17:54,360
um experiment

348
00:17:54,360 --> 00:17:56,700
um most of you might are familiar with

349
00:17:56,700 --> 00:18:00,840
it but it works this way the adversary

350
00:18:00,840 --> 00:18:04,020
has uh chooses two messages m0 and M1

351
00:18:04,020 --> 00:18:06,720
and then one one of the two is randomly

352
00:18:06,720 --> 00:18:09,059
encrypted and the adversary gets back

353
00:18:09,059 --> 00:18:11,700
the ciphertext and then

354
00:18:11,700 --> 00:18:12,360
um

355
00:18:12,360 --> 00:18:14,940
the adversary has to uh

356
00:18:14,940 --> 00:18:17,220
guess which of the two messages were

357
00:18:17,220 --> 00:18:19,080
encrypted this is like very standard

358
00:18:19,080 --> 00:18:23,700
notion and uh we we extend this where

359
00:18:23,700 --> 00:18:27,059
um instead of the adversary outputting a

360
00:18:27,059 --> 00:18:31,919
uh I guess it outputs a a state which is

361
00:18:31,919 --> 00:18:34,860
shorter than this ciphertext

362
00:18:34,860 --> 00:18:35,460
um

363
00:18:35,460 --> 00:18:38,100
and the state is forwarded to a second

364
00:18:38,100 --> 00:18:40,320
stage adversary in this second stage

365
00:18:40,320 --> 00:18:43,380
adversary gets access to this uh to the

366
00:18:43,380 --> 00:18:47,960
secret key so now now there is a way

367
00:18:47,960 --> 00:18:50,640
that we can actually guarantee something

368
00:18:50,640 --> 00:18:51,679
because

369
00:18:51,679 --> 00:18:55,320
this C might be much bigger than the

370
00:18:55,320 --> 00:18:57,240
ciphertext so

371
00:18:57,240 --> 00:19:00,240
um maybe we can guarantee that this

372
00:19:00,240 --> 00:19:02,220
adversary cannot guess which ciphertext

373
00:19:02,220 --> 00:19:04,260
was encrypted even though it has access

374
00:19:04,260 --> 00:19:06,000
to the key

375
00:19:06,000 --> 00:19:07,620
okay

376
00:19:07,620 --> 00:19:08,700
okay

377
00:19:08,700 --> 00:19:10,679
um to get you familiar with the notion

378
00:19:10,679 --> 00:19:12,320
I'll first show you what doesn't work

379
00:19:12,320 --> 00:19:16,020
and it is uh just xoring your message

380
00:19:16,020 --> 00:19:20,940
with a uh prg with using it putting your

381
00:19:20,940 --> 00:19:23,940
key into a PNG and then xoring it with

382
00:19:23,940 --> 00:19:25,799
the message

383
00:19:25,799 --> 00:19:28,740
um okay and here the I'm gonna like have

384
00:19:28,740 --> 00:19:31,200
things big that are supposed to be big

385
00:19:31,200 --> 00:19:34,799
and small that are small so this is a

386
00:19:34,799 --> 00:19:38,880
uh there's gonna be a continuous thing

387
00:19:38,880 --> 00:19:39,780
um

388
00:19:39,780 --> 00:19:41,820
not in the mathematical sense

389
00:19:41,820 --> 00:19:42,900
um

390
00:19:42,900 --> 00:19:45,360
okay so this doesn't work uh what

391
00:19:45,360 --> 00:19:46,679
happens

392
00:19:46,679 --> 00:19:49,440
um the adversary can just choose or a

393
00:19:49,440 --> 00:19:51,900
Zero's message or one's message gets

394
00:19:51,900 --> 00:19:54,360
back the cipher text and then it it just

395
00:19:54,360 --> 00:19:56,600
takes the zeroth bit of the ciphertext

396
00:19:56,600 --> 00:19:58,500
forwards this to the second stage

397
00:19:58,500 --> 00:20:00,480
adversary and now the second stage

398
00:20:00,480 --> 00:20:02,960
adversary can like

399
00:20:02,960 --> 00:20:06,059
expand the prg and just look at the

400
00:20:06,059 --> 00:20:08,160
zeroth bit of the prg and the zeroth of

401
00:20:08,160 --> 00:20:10,440
the ciphertext and can just know which

402
00:20:10,440 --> 00:20:13,020
of the two messages it was so this is

403
00:20:13,020 --> 00:20:14,580
not incompressible

404
00:20:14,580 --> 00:20:18,179
so the problem here is that a single bit

405
00:20:18,179 --> 00:20:20,700
of the mess of the ciphertext only

406
00:20:20,700 --> 00:20:23,640
relies on a single bit of the ciphertext

407
00:20:23,640 --> 00:20:27,120
so in an attempt to tie tie the entire

408
00:20:27,120 --> 00:20:29,400
ciphertext together

409
00:20:29,400 --> 00:20:32,340
um we do basically the same construction

410
00:20:32,340 --> 00:20:36,360
but instead uh again

411
00:20:36,360 --> 00:20:39,480
uh we choose we choose a okay now now we

412
00:20:39,480 --> 00:20:42,299
put a random seed into the prg

413
00:20:42,299 --> 00:20:44,700
and I saw this with the message

414
00:20:44,700 --> 00:20:48,179
and now we get this C1 this means we get

415
00:20:48,179 --> 00:20:50,520
two parts of the ciphertext now has two

416
00:20:50,520 --> 00:20:52,740
parts and now we throw a strong

417
00:20:52,740 --> 00:20:55,200
Randomness extractor on this in the Hope

418
00:20:55,200 --> 00:20:57,600
like this is this is our attempt to tie

419
00:20:57,600 --> 00:20:59,520
tie everything together

420
00:20:59,520 --> 00:21:02,940
and um the the the randomness of the

421
00:21:02,940 --> 00:21:05,039
randomness extractor so the uniform

422
00:21:05,039 --> 00:21:06,660
randomness of the randomness extract is

423
00:21:06,660 --> 00:21:08,580
the key now

424
00:21:08,580 --> 00:21:12,720
um and now we use this to mask the seed

425
00:21:12,720 --> 00:21:14,700
um which is used to

426
00:21:14,700 --> 00:21:17,280
uh produce this pseudorandom string and

427
00:21:17,280 --> 00:21:19,559
then we also and then the second part of

428
00:21:19,559 --> 00:21:21,780
osfetics is this C2 so now we have two

429
00:21:21,780 --> 00:21:22,740
parts

430
00:21:22,740 --> 00:21:26,120
and we can decrypt by

431
00:21:26,120 --> 00:21:28,880
extracting uh

432
00:21:28,880 --> 00:21:31,799
throwing the randomness extract on this

433
00:21:31,799 --> 00:21:35,299
and then removing this mask we get S

434
00:21:35,299 --> 00:21:39,240
expand the prg and we retrieve M but now

435
00:21:39,240 --> 00:21:42,000
if we try to prove this security what

436
00:21:42,000 --> 00:21:45,240
happens or let's let's assume let's

437
00:21:45,240 --> 00:21:47,400
let's start here assume this is

438
00:21:47,400 --> 00:21:49,679
perfectly hidden then uh

439
00:21:49,679 --> 00:21:53,220
then this prg is pseudo random now this

440
00:21:53,220 --> 00:21:55,260
thing is pseudo-random and

441
00:21:55,260 --> 00:21:57,299
from this we can prove that this is

442
00:21:57,299 --> 00:22:00,000
perfectly hidden but now we've like have

443
00:22:00,000 --> 00:22:03,059
a cycle and uh we have we have nowhere

444
00:22:03,059 --> 00:22:06,179
to get into this cycle and in fact for

445
00:22:06,179 --> 00:22:08,159
certain choices of extractor and prg

446
00:22:08,159 --> 00:22:10,200
this is um

447
00:22:10,200 --> 00:22:12,900
this is broken so

448
00:22:12,900 --> 00:22:17,220
um again doesn't work sadly

449
00:22:17,220 --> 00:22:21,020
um so now we have we have to

450
00:22:21,020 --> 00:22:24,620
use another notion that was uh

451
00:22:24,620 --> 00:22:28,200
that's called entropic encoding this is

452
00:22:28,200 --> 00:22:30,179
from other work and

453
00:22:30,179 --> 00:22:33,720
um what does it do it it encodes a

454
00:22:33,720 --> 00:22:34,559
message

455
00:22:34,559 --> 00:22:35,400
um

456
00:22:35,400 --> 00:22:37,559
into a codeword

457
00:22:37,559 --> 00:22:41,760
and and uses a CIS not very big but I

458
00:22:41,760 --> 00:22:43,740
hope you can see this and

459
00:22:43,740 --> 00:22:47,360
um it can again be decoded using the CIS

460
00:22:47,360 --> 00:22:51,120
now it has some properties

461
00:22:51,120 --> 00:22:54,179
um you can simulate you can simulate

462
00:22:54,179 --> 00:22:56,520
this encoding by just putting in a

463
00:22:56,520 --> 00:22:58,500
message in and this will output

464
00:22:58,500 --> 00:22:59,880
uh

465
00:22:59,880 --> 00:23:02,280
an encoding and a CRS

466
00:23:02,280 --> 00:23:05,520
and they are indistinguishable from

467
00:23:05,520 --> 00:23:07,340
things that are

468
00:23:07,340 --> 00:23:10,740
output honestly so this still doesn't

469
00:23:10,740 --> 00:23:13,679
really have any properties um but the

470
00:23:13,679 --> 00:23:15,500
the big deal is that

471
00:23:15,500 --> 00:23:20,220
c Prime has so here the simulated C code

472
00:23:20,220 --> 00:23:24,059
word has big entropy conditioned on this

473
00:23:24,059 --> 00:23:27,360
simulated CIS and this basically means

474
00:23:27,360 --> 00:23:30,960
that for any M this C has a

475
00:23:30,960 --> 00:23:33,539
pseudoentropy

476
00:23:33,539 --> 00:23:37,620
um even even seeing this uh CIS so you

477
00:23:37,620 --> 00:23:39,900
you might uh be able to guess where this

478
00:23:39,900 --> 00:23:43,740
is going but uh oh uh hard to see here

479
00:23:43,740 --> 00:23:46,620
because of the Sun but um previous work

480
00:23:46,620 --> 00:23:49,440
does this in the plane model from lwe or

481
00:23:49,440 --> 00:23:50,880
DCR

482
00:23:50,880 --> 00:23:53,640
um and we focus on the plane model here

483
00:23:53,640 --> 00:23:55,140
so

484
00:23:55,140 --> 00:23:56,280
okay

485
00:23:56,280 --> 00:23:59,100
now we now let's let's use this

486
00:23:59,100 --> 00:24:02,520
uh we use the we do pretty much the same

487
00:24:02,520 --> 00:24:05,940
thing but this time we encode this this

488
00:24:05,940 --> 00:24:07,820
x odd message

489
00:24:07,820 --> 00:24:11,640
uh and get again C1

490
00:24:11,640 --> 00:24:14,220
um we ex we extract

491
00:24:14,220 --> 00:24:18,059
um from C1 and we we actually do need

492
00:24:18,059 --> 00:24:21,900
this thing to get the another random

493
00:24:21,900 --> 00:24:24,480
string to get this proof through but um

494
00:24:24,480 --> 00:24:26,400
when you can safely acknowledge for the

495
00:24:26,400 --> 00:24:27,659
talk

496
00:24:27,659 --> 00:24:28,380
um

497
00:24:28,380 --> 00:24:33,000
and mask this seed and um yeah this is

498
00:24:33,000 --> 00:24:35,640
the same seat as used in the PFG and

499
00:24:35,640 --> 00:24:37,980
encryption also works pretty much the

500
00:24:37,980 --> 00:24:41,820
same thing uh same way we extract remove

501
00:24:41,820 --> 00:24:43,100
the mask

502
00:24:43,100 --> 00:24:46,980
decode remove this pseudo-random string

503
00:24:46,980 --> 00:24:50,520
get the message and now uh I'm gonna

504
00:24:50,520 --> 00:24:54,000
sketch supersketch the proof that's uh

505
00:24:54,000 --> 00:24:59,039
okay C has pseudo entropy thanks to uh

506
00:24:59,039 --> 00:25:01,740
entropic encodings

507
00:25:01,740 --> 00:25:04,919
um thanks to the pseudo entropy s is

508
00:25:04,919 --> 00:25:05,820
hidden

509
00:25:05,820 --> 00:25:11,340
uh and now SS since s is hidden uh this

510
00:25:11,340 --> 00:25:15,299
G of s is pseudorandom and the messages

511
00:25:15,299 --> 00:25:16,740
hit

512
00:25:16,740 --> 00:25:19,320
uh so this is our symmetric Key

513
00:25:19,320 --> 00:25:23,220
Construction and this is only in a

514
00:25:23,220 --> 00:25:24,679
kind of

515
00:25:24,679 --> 00:25:26,400
indistinguishability against an

516
00:25:26,400 --> 00:25:28,620
eavesdropper kind of way not uh so this

517
00:25:28,620 --> 00:25:32,039
is one time basically one-time use

518
00:25:32,039 --> 00:25:33,419
um

519
00:25:33,419 --> 00:25:34,799
so

520
00:25:34,799 --> 00:25:37,020
uh yeah this is this is kind of the

521
00:25:37,020 --> 00:25:40,380
former statement and uh so for a message

522
00:25:40,380 --> 00:25:44,100
of length L and N sorry we get a

523
00:25:44,100 --> 00:25:47,580
ciphertext of length n plus some uh plus

524
00:25:47,580 --> 00:25:50,340
some poly blower

525
00:25:50,340 --> 00:25:53,279
and the keys are also pretty huge this

526
00:25:53,279 --> 00:25:55,880
comes from the size of the CIS of the

527
00:25:55,880 --> 00:25:59,039
entropic encoding and

528
00:25:59,039 --> 00:26:02,400
um also sadly this cannot really be

529
00:26:02,400 --> 00:26:05,640
improved in the I I believe cannot be

530
00:26:05,640 --> 00:26:07,620
improved in the plane model because uh

531
00:26:07,620 --> 00:26:10,919
there's a black box impossibility

532
00:26:10,919 --> 00:26:14,279
um but my like my my favorite open

533
00:26:14,279 --> 00:26:16,080
question for this for this kind of work

534
00:26:16,080 --> 00:26:17,460
is

535
00:26:17,460 --> 00:26:18,240
um

536
00:26:18,240 --> 00:26:21,360
why do we need uh public key assumptions

537
00:26:21,360 --> 00:26:23,159
to build something that is

538
00:26:23,159 --> 00:26:25,520
uh kind of seems like

539
00:26:25,520 --> 00:26:27,299
indistinguishability and against an

540
00:26:27,299 --> 00:26:30,659
eavesdropper because in in like if we

541
00:26:30,659 --> 00:26:32,460
leave if we leave away this in

542
00:26:32,460 --> 00:26:35,279
incompressibility then this is this is

543
00:26:35,279 --> 00:26:37,620
done just one time pad we don't need any

544
00:26:37,620 --> 00:26:40,559
assumptions but suddenly uh sudden we

545
00:26:40,559 --> 00:26:43,440
need we need the we and DCR to do this

546
00:26:43,440 --> 00:26:46,980
symmetric key thing this is seems not uh

547
00:26:46,980 --> 00:26:50,159
not necessary but I haven't found any

548
00:26:50,159 --> 00:26:52,260
other way to prove it

549
00:26:52,260 --> 00:26:55,500
um okay then um I I can't get into this

550
00:26:55,500 --> 00:26:58,980
too much right now but we extend this uh

551
00:26:58,980 --> 00:27:00,000
to

552
00:27:00,000 --> 00:27:03,659
um to the public key setting using some

553
00:27:03,659 --> 00:27:05,880
version of hash proof systems

554
00:27:05,880 --> 00:27:07,799
uh

555
00:27:07,799 --> 00:27:10,140
yeah and this I mean this automatically

556
00:27:10,140 --> 00:27:13,500
this also it extends to CCA security so

557
00:27:13,500 --> 00:27:14,820
here we have our

558
00:27:14,820 --> 00:27:17,940
next theorem um we we have we have more

559
00:27:17,940 --> 00:27:20,100
constructions but these have the best

560
00:27:20,100 --> 00:27:23,039
parameters if we if we use the hash

561
00:27:23,039 --> 00:27:25,380
proof system from ddh we get the best

562
00:27:25,380 --> 00:27:28,200
parameters uh but they are still very

563
00:27:28,200 --> 00:27:31,080
bad so here we have a

564
00:27:31,080 --> 00:27:35,520
the public key is is bad it's I mean

565
00:27:35,520 --> 00:27:37,679
every every parameter here is not really

566
00:27:37,679 --> 00:27:39,120
good

567
00:27:39,120 --> 00:27:40,200
um

568
00:27:40,200 --> 00:27:43,620
uh so my my next my next my next open

569
00:27:43,620 --> 00:27:47,400
question is is it um possible to achieve

570
00:27:47,400 --> 00:27:49,320
um best possible parameters without

571
00:27:49,320 --> 00:27:53,159
assuming IO uh this is a caveat because

572
00:27:53,159 --> 00:27:55,919
this has already been done in previous

573
00:27:55,919 --> 00:27:59,279
work so uh using IO you can you can get

574
00:27:59,279 --> 00:28:02,159
way better parameters here

575
00:28:02,159 --> 00:28:03,480
um

576
00:28:03,480 --> 00:28:07,380
yeah okay to summarize I showed you how

577
00:28:07,380 --> 00:28:09,659
uh we turn entropic encodings into

578
00:28:09,659 --> 00:28:11,240
incompressible

579
00:28:11,240 --> 00:28:14,580
symmetric key encryption in our ePrint

580
00:28:14,580 --> 00:28:16,919
version of the paper and no so in the

581
00:28:16,919 --> 00:28:18,659
TCC version of the paper you can also

582
00:28:18,659 --> 00:28:20,100
find how we extend this to

583
00:28:20,100 --> 00:28:22,860
incompressible CCA public key encryption

584
00:28:22,860 --> 00:28:28,320
and how we how we use ddh to um to make

585
00:28:28,320 --> 00:28:29,820
these kinds of

586
00:28:29,820 --> 00:28:32,460
oh yeah okay we need oh sorry I should

587
00:28:32,460 --> 00:28:35,640
have done this around we uh in the TCC

588
00:28:35,640 --> 00:28:39,360
version of the paper we have ddh and

589
00:28:39,360 --> 00:28:41,700
turn this into programming the hash

590
00:28:41,700 --> 00:28:45,299
proof systems and then use those to

591
00:28:45,299 --> 00:28:48,120
um produce a CCA uh public key

592
00:28:48,120 --> 00:28:49,620
encryption scheme

593
00:28:49,620 --> 00:28:52,679
and in the in the ePrint version we also

594
00:28:52,679 --> 00:28:55,320
have constructions from lwe and group

595
00:28:55,320 --> 00:28:59,400
actions and also I think a very nice um

596
00:28:59,400 --> 00:29:01,980
an instantiability result of the random

597
00:29:01,980 --> 00:29:05,700
Oracle model which I uh which sadly I

598
00:29:05,700 --> 00:29:08,100
was we didn't get ready for the TCC

599
00:29:08,100 --> 00:29:09,779
deadline so it's only in the ecrate

600
00:29:09,779 --> 00:29:12,679
version okay

601
00:29:19,500 --> 00:29:23,460
we're a bit short in time okay maybe a

602
00:29:23,460 --> 00:29:25,679
quick question yeah please

603
00:29:25,679 --> 00:29:27,720
and maybe the next speaker can start

604
00:29:27,720 --> 00:29:30,539
setting up at the same time okay this is

605
00:29:30,539 --> 00:29:32,279
something I have to ask so what is a

606
00:29:32,279 --> 00:29:34,080
programmable hash proof system I worked

607
00:29:34,080 --> 00:29:36,140
on both properties

608
00:29:36,140 --> 00:29:38,640
what is it in one sentence it's

609
00:29:38,640 --> 00:29:40,080
something we made up but it basically

610
00:29:40,080 --> 00:29:43,460
means that uh

611
00:29:44,240 --> 00:29:47,100
it basically means that you

612
00:29:47,100 --> 00:29:50,700
um after seeing a bad input into the

613
00:29:50,700 --> 00:29:53,220
into the hash into the hash function you

614
00:29:53,220 --> 00:29:56,039
can afterwards choose what the output of

615
00:29:56,039 --> 00:30:00,720
the uh secret key of the decapsulation

616
00:30:00,720 --> 00:30:02,419
would be uh

617
00:30:02,419 --> 00:30:04,620
I don't have a good way to describe it

618
00:30:04,620 --> 00:30:06,240
I'm sorry you can take it offline yes

619
00:30:06,240 --> 00:30:07,880
thanks

620
00:30:07,880 --> 00:30:11,480
oh turn it off

621
00:30:15,659 --> 00:30:19,440
hey our next speaker is she

622
00:30:19,440 --> 00:30:22,159
shy

623
00:30:24,080 --> 00:30:27,240
is shy Halloween and he will tell us

624
00:30:27,240 --> 00:30:30,899
about achievable cca2 relaxation for

625
00:30:30,899 --> 00:30:34,459
homomorphic encryption

626
00:30:39,360 --> 00:30:43,320
yeah so sadly I'm not a d uh she was

627
00:30:43,320 --> 00:30:45,299
supposed to give the talk about uh her

628
00:30:45,299 --> 00:30:46,980
flight got canceled so she's still in

629
00:30:46,980 --> 00:30:48,360
Israel

630
00:30:48,360 --> 00:30:52,080
um so I'll talk about achievable cca2

631
00:30:52,080 --> 00:30:55,080
relaxation from morphic encryption uh

632
00:30:55,080 --> 00:30:56,460
and that's joined to work with the

633
00:30:56,460 --> 00:30:59,580
akariac Gentry and Margarita box

634
00:30:59,580 --> 00:31:01,639
um

635
00:31:01,740 --> 00:31:03,539
so we're talking about homorphic

636
00:31:03,539 --> 00:31:07,200
encryption and perhaps the most obvious

637
00:31:07,200 --> 00:31:09,179
application of homorphic encryption is

638
00:31:09,179 --> 00:31:10,980
to Outsource computation we have a

639
00:31:10,980 --> 00:31:13,440
client we want to compute something they

640
00:31:13,440 --> 00:31:15,299
don't want to compute them themselves

641
00:31:15,299 --> 00:31:17,760
they'll encrypted ship it to a server

642
00:31:17,760 --> 00:31:19,380
the server will compute it for them send

643
00:31:19,380 --> 00:31:21,860
back the results uh they can decrypt

644
00:31:21,860 --> 00:31:25,080
uh but if the computation is deep if

645
00:31:25,080 --> 00:31:27,899
it's a one computation then the server

646
00:31:27,899 --> 00:31:30,899
needs to work hard uh in particular the

647
00:31:30,899 --> 00:31:33,360
thing that makes it hard is I need to do

648
00:31:33,360 --> 00:31:34,860
refreshing or bootstrapping in the

649
00:31:34,860 --> 00:31:37,100
middle and that's an expensive operation

650
00:31:37,100 --> 00:31:41,039
so what if the uh client can stick

651
00:31:41,039 --> 00:31:42,659
around and just do these little

652
00:31:42,659 --> 00:31:44,880
refreshing every so often that might

653
00:31:44,880 --> 00:31:48,179
make the thing a little a lot faster uh

654
00:31:48,179 --> 00:31:50,940
so it could be uh an idea you know the

655
00:31:50,940 --> 00:31:54,720
server will ever so often send the uh

656
00:31:54,720 --> 00:31:57,000
ciphertext back to the client the client

657
00:31:57,000 --> 00:31:59,039
will decrypt or encrypts are sent back

658
00:31:59,039 --> 00:32:00,419
to the server

659
00:32:00,419 --> 00:32:02,580
um so that could be a useful thing to do

660
00:32:02,580 --> 00:32:06,240
uh the question is is that safe is this

661
00:32:06,240 --> 00:32:09,480
is this secure so on one hand it seems

662
00:32:09,480 --> 00:32:11,700
that what would the server do I mean the

663
00:32:11,700 --> 00:32:13,740
server only sees ciphertext in this game

664
00:32:13,740 --> 00:32:16,140
it's not a CCA type of a thing because

665
00:32:16,140 --> 00:32:18,840
it never see plain text so maybe that is

666
00:32:18,840 --> 00:32:19,760
safe

667
00:32:19,760 --> 00:32:24,539
uh but it turns out that not really so

668
00:32:24,539 --> 00:32:27,360
the we have two types of results the

669
00:32:27,360 --> 00:32:28,919
first result just say that this is not

670
00:32:28,919 --> 00:32:29,720
safe

671
00:32:29,720 --> 00:32:33,240
uh CPA security does not guarantee

672
00:32:33,240 --> 00:32:36,179
privacy uh if the server is malicious

673
00:32:36,179 --> 00:32:38,460
even if you only showed ciphertext in

674
00:32:38,460 --> 00:32:40,320
this in this game where the client can

675
00:32:40,320 --> 00:32:42,419
every so often decrypt something and

676
00:32:42,419 --> 00:32:44,220
then re-encrypt it

677
00:32:44,220 --> 00:32:46,980
um so we Define a new notion what's

678
00:32:46,980 --> 00:32:50,580
called func CPA uh that lies somewhere

679
00:32:50,580 --> 00:32:52,860
between CPA and and chosen ciphertext

680
00:32:52,860 --> 00:32:55,080
security and show that it's sufficient

681
00:32:55,080 --> 00:32:58,980
for privacy in this context that I will

682
00:32:58,980 --> 00:33:00,720
we have a name fragment paper that

683
00:33:00,720 --> 00:33:02,399
currently escapes me I think like a

684
00:33:02,399 --> 00:33:03,539
client

685
00:33:03,539 --> 00:33:06,659
um Outsourcing protocol or whatever

686
00:33:06,659 --> 00:33:09,720
um and it's safe in this context

687
00:33:09,720 --> 00:33:11,880
and it's also achievable from our

688
00:33:11,880 --> 00:33:14,340
circuit privacy and and other things as

689
00:33:14,340 --> 00:33:17,580
well so let me start by oh the second

690
00:33:17,580 --> 00:33:20,700
part of the result is uh

691
00:33:20,700 --> 00:33:22,860
can we prove existing homorphic

692
00:33:22,860 --> 00:33:26,760
encryption are already that and it turns

693
00:33:26,760 --> 00:33:30,360
out that yes for level encryption

694
00:33:30,360 --> 00:33:32,159
homomorphic encryption contemporary

695
00:33:32,159 --> 00:33:34,260
things uh you can show that they're

696
00:33:34,260 --> 00:33:37,740
already Funk CPA is secure and level

697
00:33:37,740 --> 00:33:41,220
this just means that whenever the uh you

698
00:33:41,220 --> 00:33:42,720
want you want to refresh something you

699
00:33:42,720 --> 00:33:44,340
get an encryption of it but under the

700
00:33:44,340 --> 00:33:47,460
next key so there is a if the depth of

701
00:33:47,460 --> 00:33:49,380
your computation is seven you have seven

702
00:33:49,380 --> 00:33:51,179
different keys and every time you

703
00:33:51,179 --> 00:33:53,659
refresh it and you get the next key

704
00:33:53,659 --> 00:33:57,419
uh if you are not in this level thing

705
00:33:57,419 --> 00:33:59,760
then we don't know how to prove it

706
00:33:59,760 --> 00:34:01,980
essentially if we were able to prove it

707
00:34:01,980 --> 00:34:04,919
uh then that would already show that

708
00:34:04,919 --> 00:34:07,620
these schemes are secure even in the

709
00:34:07,620 --> 00:34:10,500
context of having circular security so

710
00:34:10,500 --> 00:34:12,239
we don't expect to be able to show it

711
00:34:12,239 --> 00:34:14,940
from things like lwe or or any of those

712
00:34:14,940 --> 00:34:17,399
because we don't know how to prove

713
00:34:17,399 --> 00:34:19,800
circle of security

714
00:34:19,800 --> 00:34:22,379
um for these homomorphic encryption I'll

715
00:34:22,379 --> 00:34:24,119
talk a little bit about it maybe at the

716
00:34:24,119 --> 00:34:25,440
end

717
00:34:25,440 --> 00:34:26,760
um

718
00:34:26,760 --> 00:34:29,879
so let's start with the attack uh it's a

719
00:34:29,879 --> 00:34:32,580
very simple version of it so again the

720
00:34:32,580 --> 00:34:34,379
question is why you would sing

721
00:34:34,379 --> 00:34:36,719
ciphertext help the server attack

722
00:34:36,719 --> 00:34:39,719
anything and the answer is well you know

723
00:34:39,719 --> 00:34:42,239
uh the server can send invalid

724
00:34:42,239 --> 00:34:44,879
ciphertext so let's take a stock from uh

725
00:34:44,879 --> 00:34:47,820
a CPA secure scheme and just modify it

726
00:34:47,820 --> 00:34:51,540
so that uh encryption normally work just

727
00:34:51,540 --> 00:34:53,699
like encryption of uh of the underlying

728
00:34:53,699 --> 00:34:55,859
scheme except you concatenate one to the

729
00:34:55,859 --> 00:34:57,540
ciphertext to denote that this is a good

730
00:34:57,540 --> 00:34:59,820
ciphertext uh

731
00:34:59,820 --> 00:35:01,619
except in the case where you want to

732
00:35:01,619 --> 00:35:03,300
group The Secret Key itself in which

733
00:35:03,300 --> 00:35:05,460
case you just send it in the clear uh

734
00:35:05,460 --> 00:35:07,580
well of course that doesn't hurt the uh

735
00:35:07,580 --> 00:35:10,560
CPA security because the adversary never

736
00:35:10,560 --> 00:35:12,960
can do that anyways

737
00:35:12,960 --> 00:35:16,320
um and on the other hand

738
00:35:16,320 --> 00:35:19,740
you modify decryption so that if it gets

739
00:35:19,740 --> 00:35:22,320
anything that starts with a zero then it

740
00:35:22,320 --> 00:35:24,119
decrypts it to the secret key

741
00:35:24,119 --> 00:35:27,300
so well you can see what happens uh a

742
00:35:27,300 --> 00:35:28,859
malicious server just send some

743
00:35:28,859 --> 00:35:31,320
ciphertext that begins with a zero the

744
00:35:31,320 --> 00:35:32,940
decryption algorithm will decrypt it to

745
00:35:32,940 --> 00:35:34,320
the secret key and then the encryption

746
00:35:34,320 --> 00:35:35,760
algorithm will send the secret key in

747
00:35:35,760 --> 00:35:38,460
the clear that breaks the skill so you

748
00:35:38,460 --> 00:35:42,119
know it's not always that CPA secure uh

749
00:35:42,119 --> 00:35:45,619
implies Security in this context

750
00:35:45,720 --> 00:35:49,560
uh let's talk about what is it that you

751
00:35:49,560 --> 00:35:52,800
need well it seems sort of obvious what

752
00:35:52,800 --> 00:35:54,839
you need is for the thing to remain

753
00:35:54,839 --> 00:35:57,240
secure even if you have a refresh even

754
00:35:57,240 --> 00:35:58,680
if you have an oracle that refresh

755
00:35:58,680 --> 00:36:01,440
ciphertexts for you so you have a new

756
00:36:01,440 --> 00:36:03,720
game where the uh it's exactly the same

757
00:36:03,720 --> 00:36:06,180
except you have this refresh Oracle a

758
00:36:06,180 --> 00:36:07,859
little more generally than that you can

759
00:36:07,859 --> 00:36:10,260
refresh it not just decrypt and then

760
00:36:10,260 --> 00:36:12,780
re-encrypt you can have an oracle that

761
00:36:12,780 --> 00:36:15,180
does decrypt apply any function of your

762
00:36:15,180 --> 00:36:17,400
choice and then re-encrypt this function

763
00:36:17,400 --> 00:36:19,380
of your chest doesn't matter all that

764
00:36:19,380 --> 00:36:20,760
much in this context because we're

765
00:36:20,760 --> 00:36:22,320
talking about homorphic encryption you

766
00:36:22,320 --> 00:36:24,420
could have computed it yourself really

767
00:36:24,420 --> 00:36:27,960
most times uh so and then you show that

768
00:36:27,960 --> 00:36:30,300
in this thing if you have a scheme that

769
00:36:30,300 --> 00:36:33,180
remains secure when you have that Oracle

770
00:36:33,180 --> 00:36:35,820
well then it's secure also in the

771
00:36:35,820 --> 00:36:39,000
context of this client uh based uh

772
00:36:39,000 --> 00:36:40,980
protocols

773
00:36:40,980 --> 00:36:41,180
um

774
00:36:41,180 --> 00:36:42,780
[Music]

775
00:36:42,780 --> 00:36:46,020
even if the server is malicious

776
00:36:46,020 --> 00:36:48,440
uh just a pictorial the

777
00:36:48,440 --> 00:36:51,119
picture of the definitions of this is

778
00:36:51,119 --> 00:36:53,940
the normal CPA security game you have a

779
00:36:53,940 --> 00:36:56,220
challenger it produces Keys it gives the

780
00:36:56,220 --> 00:36:57,960
address the public key the adversary

781
00:36:57,960 --> 00:37:00,300
sends to messages one of them gets

782
00:37:00,300 --> 00:37:02,280
encrypted the adversar needs to change

783
00:37:02,280 --> 00:37:06,300
to figure out which one and the CPA just

784
00:37:06,300 --> 00:37:08,579
adds to it this refresh Cycles well the

785
00:37:08,579 --> 00:37:11,760
adversary can send a cipher text and get

786
00:37:11,760 --> 00:37:15,480
it refreshed uh and you still require

787
00:37:15,480 --> 00:37:17,339
the same thing that the adversary cannot

788
00:37:17,339 --> 00:37:19,079
guess which of the two messages when

789
00:37:19,079 --> 00:37:20,160
encrypted

790
00:37:20,160 --> 00:37:21,900
if you want to talk about the leveled

791
00:37:21,900 --> 00:37:24,000
version the level version is the same

792
00:37:24,000 --> 00:37:25,800
thing except whenever you refresh you

793
00:37:25,800 --> 00:37:28,880
get an encryption under the next uh

794
00:37:28,880 --> 00:37:32,400
level and the adversaries for you to

795
00:37:32,400 --> 00:37:35,220
choose the uh the level

796
00:37:35,220 --> 00:37:37,440
um in any way it wants I mean for the

797
00:37:37,440 --> 00:37:40,400
challenge that it is

798
00:37:42,320 --> 00:37:44,820
next we ask

799
00:37:44,820 --> 00:37:45,660
um

800
00:37:45,660 --> 00:37:49,020
do existing schemes have this uh have

801
00:37:49,020 --> 00:37:52,800
this property so every level scheme has

802
00:37:52,800 --> 00:37:55,140
that property as long as the keys for

803
00:37:55,140 --> 00:37:57,740
the different levels are

804
00:37:57,740 --> 00:37:59,599
chosen

805
00:37:59,599 --> 00:38:02,099
independently then every scheme that is

806
00:38:02,099 --> 00:38:04,980
CPA secure will also be banked CPA

807
00:38:04,980 --> 00:38:06,380
secure

808
00:38:06,380 --> 00:38:09,420
and in particular all the level schemes

809
00:38:09,420 --> 00:38:10,859
that you see in the Liberty it's always

810
00:38:10,859 --> 00:38:12,720
I mean leveled is always done with

811
00:38:12,720 --> 00:38:14,940
independencies so

812
00:38:14,940 --> 00:38:18,720
um and the idea in why that is is well

813
00:38:18,720 --> 00:38:20,940
you know these are new keys I mean what

814
00:38:20,940 --> 00:38:23,099
can you do yeah

815
00:38:23,099 --> 00:38:25,200
you simulate the answer to the Frank

816
00:38:25,200 --> 00:38:26,880
Oracle but just encrypting random

817
00:38:26,880 --> 00:38:28,140
messages you don't need to encrypt

818
00:38:28,140 --> 00:38:29,700
anything else these are just side

819
00:38:29,700 --> 00:38:32,099
effects this intuition of server only

820
00:38:32,099 --> 00:38:33,960
see just ciphertext works perfectly well

821
00:38:33,960 --> 00:38:36,420
here because you never get to to encrypt

822
00:38:36,420 --> 00:38:38,099
something under itself or you never get

823
00:38:38,099 --> 00:38:41,660
to refresh something with the same key

824
00:38:43,380 --> 00:38:46,079
uh the other thing is if the scheme is

825
00:38:46,079 --> 00:38:49,320
circuit private uh then it Banks CPA

826
00:38:49,320 --> 00:38:52,880
secure so circuit private schemes mean

827
00:38:52,880 --> 00:38:57,980
uh when you get an evaluated ciphertext

828
00:38:57,980 --> 00:39:02,460
uh or when you get a fresh encryption of

829
00:39:02,460 --> 00:39:04,940
the functioning um

830
00:39:04,940 --> 00:39:07,440
apply to that uh these look

831
00:39:07,440 --> 00:39:09,240
indistinguishable even given the secret

832
00:39:09,240 --> 00:39:11,160
key actually

833
00:39:11,160 --> 00:39:12,599
um it's not well

834
00:39:12,599 --> 00:39:14,220
here we I think we just write this

835
00:39:14,220 --> 00:39:15,480
statistically close but I think

836
00:39:15,480 --> 00:39:16,800
indistinguishable given the security

837
00:39:16,800 --> 00:39:18,060
should be enough

838
00:39:18,060 --> 00:39:20,160
uh the one thing that's a little

839
00:39:20,160 --> 00:39:23,460
different in this notion is in this case

840
00:39:23,460 --> 00:39:26,099
what we need it's still okay that the

841
00:39:26,099 --> 00:39:28,500
keys are produced uh honestly but the

842
00:39:28,500 --> 00:39:31,980
ciphertexts are uh generated by a

843
00:39:31,980 --> 00:39:34,140
malicious class server whereas usually

844
00:39:34,140 --> 00:39:36,540
when you talk about circuit privacy you

845
00:39:36,540 --> 00:39:38,460
talk about either they're both honest or

846
00:39:38,460 --> 00:39:40,260
they're both malicious so in this case

847
00:39:40,260 --> 00:39:41,940
the the thing that we need and that's

848
00:39:41,940 --> 00:39:43,320
actually the easy case I mean it's

849
00:39:43,320 --> 00:39:46,380
harder to deal with malicious uh public

850
00:39:46,380 --> 00:39:49,440
Keys than it is to deal with malicious

851
00:39:49,440 --> 00:39:51,599
uh and then the theorem is that if the

852
00:39:51,599 --> 00:39:54,000
scheme scheme is CPA secure and circuit

853
00:39:54,000 --> 00:39:56,180
private then it's also Funk CPS secure

854
00:39:56,180 --> 00:39:59,040
and uh and the way to do that

855
00:39:59,040 --> 00:40:01,980
essentially is is you well its own

856
00:40:01,980 --> 00:40:03,180
morphic encryption you use the

857
00:40:03,180 --> 00:40:06,119
evaluation in order to uh to do the the

858
00:40:06,119 --> 00:40:07,740
thing and because it's sort of private

859
00:40:07,740 --> 00:40:09,420
then you cannot tell that it was

860
00:40:09,420 --> 00:40:11,640
evaluated you can uh

861
00:40:11,640 --> 00:40:14,160
um might have been just as well been uh

862
00:40:14,160 --> 00:40:15,960
answered by an oracle that decrypt and

863
00:40:15,960 --> 00:40:17,700
re-encrypt

864
00:40:17,700 --> 00:40:20,700
uh

865
00:40:21,540 --> 00:40:25,140
and then well if you wanted your scheme

866
00:40:25,140 --> 00:40:26,940
to be circuit private what would you do

867
00:40:26,940 --> 00:40:31,140
you can use uh sanitization

868
00:40:31,140 --> 00:40:34,320
um and you can do it uh I mean these are

869
00:40:34,320 --> 00:40:36,119
typically done with uh bootstrapping

870
00:40:36,119 --> 00:40:38,220
techniques but uh essentially the the

871
00:40:38,220 --> 00:40:41,760
idea is you uh you sanitize uh the

872
00:40:41,760 --> 00:40:44,599
output so that it looks like a random um

873
00:40:44,599 --> 00:40:48,180
encryption uh this is a little bit off

874
00:40:48,180 --> 00:40:50,820
because if the original ciphertext that

875
00:40:50,820 --> 00:40:52,740
you got as an input to this thing was

876
00:40:52,740 --> 00:40:55,859
already not valid or uh if you think I

877
00:40:55,859 --> 00:40:57,300
want to think about it in the terms of

878
00:40:57,300 --> 00:40:59,640
contemporary it would already already

879
00:40:59,640 --> 00:41:02,400
very noisy then maybe you evaluated and

880
00:41:02,400 --> 00:41:05,099
then who knows what happens uh so you

881
00:41:05,099 --> 00:41:07,020
also need to sanitize it before you

882
00:41:07,020 --> 00:41:08,820
start the the

883
00:41:08,820 --> 00:41:10,619
um homorphic evaluation but other than

884
00:41:10,619 --> 00:41:13,220
that it's fine

885
00:41:14,339 --> 00:41:18,119
so to conclude uh we proposed this new

886
00:41:18,119 --> 00:41:21,780
notion of punk CPA security and show

887
00:41:21,780 --> 00:41:25,160
that it's related to Circular security

888
00:41:25,160 --> 00:41:28,020
uh it's not we actually don't know to

889
00:41:28,020 --> 00:41:30,180
show that they're equivalent what we

890
00:41:30,180 --> 00:41:34,200
know is that uh for schemes that have

891
00:41:34,200 --> 00:41:36,839
some property that sort of shared by all

892
00:41:36,839 --> 00:41:39,900
the current schemes which is uh you can

893
00:41:39,900 --> 00:41:41,880
well maybe I'll talk about it in a

894
00:41:41,880 --> 00:41:43,440
minute let me finish the slide and then

895
00:41:43,440 --> 00:41:45,300
I'll go back to it for schemes that have

896
00:41:45,300 --> 00:41:50,400
some property uh if they are uh Funk CPA

897
00:41:50,400 --> 00:41:55,920
secure then they also are circular so

898
00:41:55,920 --> 00:41:58,500
um and it said the notion of function PA

899
00:41:58,500 --> 00:42:01,339
security is achievable uh either via

900
00:42:01,339 --> 00:42:05,460
generic transformation uh to um circuit

901
00:42:05,460 --> 00:42:09,060
privacy or by uh level skills any level

902
00:42:09,060 --> 00:42:10,859
skin

903
00:42:10,859 --> 00:42:13,619
and uh this notion is sufficient uh for

904
00:42:13,619 --> 00:42:15,540
privacy and client or client-aided

905
00:42:15,540 --> 00:42:17,220
protocol yeah I knew there was a name

906
00:42:17,220 --> 00:42:19,280
for it

907
00:42:19,280 --> 00:42:23,339
against malicious servers so you know if

908
00:42:23,339 --> 00:42:25,880
you have just um

909
00:42:25,880 --> 00:42:28,440
uh if you have just a CPS secure

910
00:42:28,440 --> 00:42:31,020
encryption then you need the client to

911
00:42:31,020 --> 00:42:33,960
be uh semi honest uh whereas if the

912
00:42:33,960 --> 00:42:36,060
scheme is leveled or it's a Frank CPA

913
00:42:36,060 --> 00:42:39,540
then uh you can have this server being

914
00:42:39,540 --> 00:42:41,339
malicious and as long as it only sees

915
00:42:41,339 --> 00:42:43,859
ciphertext you'd be fine

916
00:42:43,859 --> 00:42:45,720
um

917
00:42:45,720 --> 00:42:48,060
one thing that we don't know how to do

918
00:42:48,060 --> 00:42:50,460
is if you look at contemporary schemes

919
00:42:50,460 --> 00:42:53,820
like that with the added thing that you

920
00:42:53,820 --> 00:42:56,820
need to to do bootstrapping uh we would

921
00:42:56,820 --> 00:42:59,099
like to say that the funk CPA secure but

922
00:42:59,099 --> 00:43:01,619
we don't know how to prove it

923
00:43:01,619 --> 00:43:02,579
um

924
00:43:02,579 --> 00:43:04,380
so oh and I wanted to say something

925
00:43:04,380 --> 00:43:06,599
about what the scheme needs to have in

926
00:43:06,599 --> 00:43:09,540
order for this connection to Circle uh

927
00:43:09,540 --> 00:43:11,720
circle of security

928
00:43:11,720 --> 00:43:13,980
essentially in all of these schemes if

929
00:43:13,980 --> 00:43:16,200
you just see the public key you can

930
00:43:16,200 --> 00:43:18,720
generate a cipher text such that if you

931
00:43:18,720 --> 00:43:20,579
decrypt that Cipher text you will be

932
00:43:20,579 --> 00:43:23,280
able to figure out from the decryption

933
00:43:23,280 --> 00:43:26,160
of it what the secret key is essentially

934
00:43:26,160 --> 00:43:28,680
given the public key you can generate an

935
00:43:28,680 --> 00:43:31,319
encryption of some sort of the secret

936
00:43:31,319 --> 00:43:33,780
key it's just not the sort that you need

937
00:43:33,780 --> 00:43:37,800
to do with traveling uh so uh if a

938
00:43:37,800 --> 00:43:41,160
scheme has this this property and is

939
00:43:41,160 --> 00:43:43,920
Fung CPA secure then you can generate it

940
00:43:43,920 --> 00:43:45,900
something that's really bootstrapable

941
00:43:45,900 --> 00:43:48,000
and since we don't know how to do things

942
00:43:48,000 --> 00:43:49,560
that are bootstrappable for normal

943
00:43:49,560 --> 00:43:51,960
assumptions without explicitly assuming

944
00:43:51,960 --> 00:43:54,300
circular security uh that it means that

945
00:43:54,300 --> 00:43:57,420
it's hard for these schemes to prove

946
00:43:57,420 --> 00:43:59,880
that they are function CPA secure

947
00:43:59,880 --> 00:44:02,420
that's

948
00:44:09,780 --> 00:44:12,859
one quick question

949
00:44:18,359 --> 00:44:21,480
so maybe I mean but at least for the

950
00:44:21,480 --> 00:44:23,160
basic definition but the only query is

951
00:44:23,160 --> 00:44:24,720
like ciphertext and you decrypt and

952
00:44:24,720 --> 00:44:27,599
re-encrypt exactly the same thing are

953
00:44:27,599 --> 00:44:29,400
you saying even for this you don't have

954
00:44:29,400 --> 00:44:31,440
equivalence with public encryption or

955
00:44:31,440 --> 00:44:33,180
something like where is that given any

956
00:44:33,180 --> 00:44:34,819
public encryption I can build another

957
00:44:34,819 --> 00:44:36,960
encryption which is secure with respect

958
00:44:36,960 --> 00:44:39,000
to the three encryption queries

959
00:44:39,000 --> 00:44:40,560
or maybe it's not interesting for

960
00:44:40,560 --> 00:44:42,980
Publications

961
00:44:47,220 --> 00:44:50,880
I didn't I didn't think about that

962
00:44:50,880 --> 00:44:54,420
without the evaluation if you have uh

963
00:44:54,420 --> 00:44:56,700
sanitization then sure you can do it

964
00:44:56,700 --> 00:44:58,500
without centralization I didn't think

965
00:44:58,500 --> 00:45:00,359
about it and I don't see off the top of

966
00:45:00,359 --> 00:45:02,099
my head how to do that

967
00:45:02,099 --> 00:45:03,720
I mean maybe there are no applications

968
00:45:03,720 --> 00:45:05,040
just yeah kind of ignored the

969
00:45:05,040 --> 00:45:08,359
homomorphic aspect but

970
00:45:09,599 --> 00:45:12,599
okay so let's keep the questions offline

971
00:45:12,599 --> 00:45:14,760
and let's thank all the speakers in this

972
00:45:14,760 --> 00:45:16,319
session again for their wonderful

973
00:45:16,319 --> 00:45:18,740
thoughts

