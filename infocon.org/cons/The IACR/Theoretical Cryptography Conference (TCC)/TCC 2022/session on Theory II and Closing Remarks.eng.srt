1
00:00:00,000 --> 00:00:01,560
two

2
00:00:01,560 --> 00:00:03,480
not sure what else was happening in this

3
00:00:03,480 --> 00:00:04,940
conference but

4
00:00:04,940 --> 00:00:09,960
so our first speaker is remote uh the

5
00:00:09,960 --> 00:00:11,820
speaker is yuchen telling us about

6
00:00:11,820 --> 00:00:13,740
permissionless clock synchronization

7
00:00:13,740 --> 00:00:16,759
with public setup

8
00:00:17,520 --> 00:00:21,180
yeah thanks for the introduction

9
00:00:21,180 --> 00:00:25,080
hi everyone uh I'm yushin and uh I'm

10
00:00:25,080 --> 00:00:27,119
going to present our paper permission

11
00:00:27,119 --> 00:00:28,920
let's close synchronization with public

12
00:00:28,920 --> 00:00:31,380
Step Up This is a joint walk with

13
00:00:31,380 --> 00:00:35,360
huangarai and aglos Kia

14
00:00:35,399 --> 00:00:38,640
so clock synchronization has been a

15
00:00:38,640 --> 00:00:40,739
fundamental problem in the distributed

16
00:00:40,739 --> 00:00:43,800
systems and yet many asks if a set of

17
00:00:43,800 --> 00:00:46,559
the processes can realize logical clocks

18
00:00:46,559 --> 00:00:48,719
that satisfy two synchronization

19
00:00:48,719 --> 00:00:50,219
conditions

20
00:00:50,219 --> 00:00:53,460
the first one is called precision and it

21
00:00:53,460 --> 00:00:55,860
mainly asks that honest parties can

22
00:00:55,860 --> 00:00:59,180
maintain closed logical clocks or say

23
00:00:59,180 --> 00:01:01,559
the skills among these parties are

24
00:01:01,559 --> 00:01:03,600
bonded and the second condition is

25
00:01:03,600 --> 00:01:06,840
called accuracy accuracy requires that

26
00:01:06,840 --> 00:01:10,500
honest parties can report a time that is

27
00:01:10,500 --> 00:01:12,720
Meaningful with respect to the real time

28
00:01:12,720 --> 00:01:15,000
or in other words it should stay in a

29
00:01:15,000 --> 00:01:17,400
linear envelope of the real time

30
00:01:17,400 --> 00:01:19,740
so this problem has been started for

31
00:01:19,740 --> 00:01:23,400
more than 40 years and there are some

32
00:01:23,400 --> 00:01:25,439
protocols that can achieve this optimal

33
00:01:25,439 --> 00:01:28,140
skill and optimal linear envelope

34
00:01:28,140 --> 00:01:30,659
however we highlight here that also the

35
00:01:30,659 --> 00:01:33,479
protocols are listed in this slide are

36
00:01:33,479 --> 00:01:35,340
actually they run a permission

37
00:01:35,340 --> 00:01:37,979
environment which means that parties

38
00:01:37,979 --> 00:01:40,560
have some knowledge a prior like they

39
00:01:40,560 --> 00:01:42,540
know the number of the parties or they

40
00:01:42,540 --> 00:01:45,600
know a pki so if a new party wants to

41
00:01:45,600 --> 00:01:48,360
join actually only one paper here

42
00:01:48,360 --> 00:01:50,820
considers the newly joined parties if a

43
00:01:50,820 --> 00:01:53,040
new party wants to join that party has

44
00:01:53,040 --> 00:01:54,840
to gain sufficiently many permission

45
00:01:54,840 --> 00:01:58,140
from the existing parties and after the

46
00:01:58,140 --> 00:02:00,540
drawing uh all the parties they need to

47
00:02:00,540 --> 00:02:02,820
update their internal State like they

48
00:02:02,820 --> 00:02:04,259
need to update the total number of the

49
00:02:04,259 --> 00:02:06,680
parties

50
00:02:06,840 --> 00:02:09,660
however with the emergence of Bitcoin

51
00:02:09,660 --> 00:02:11,640
and its underlying blockchain protocol

52
00:02:11,640 --> 00:02:13,500
which runs in an environment that

53
00:02:13,500 --> 00:02:15,480
parties can join and live by their will

54
00:02:15,480 --> 00:02:18,060
this classical synchronization Protocols

55
00:02:18,060 --> 00:02:19,920
are challenged by such a permissionless

56
00:02:19,920 --> 00:02:23,220
environment so here you can see that in

57
00:02:23,220 --> 00:02:25,080
this new environment the number of the

58
00:02:25,080 --> 00:02:27,599
parties can be dynamic and they can come

59
00:02:27,599 --> 00:02:30,239
and go without notifying anyone else

60
00:02:30,239 --> 00:02:32,340
also in this new environment we have

61
00:02:32,340 --> 00:02:34,980
different setups like for public setup

62
00:02:34,980 --> 00:02:38,099
we have common reference string or say a

63
00:02:38,099 --> 00:02:40,200
Genesis Block in the blockchain context

64
00:02:40,200 --> 00:02:43,500
we also have private data black proof of

65
00:02:43,500 --> 00:02:45,959
stick which is different from the

66
00:02:45,959 --> 00:02:48,840
previous pki setup mainly because in

67
00:02:48,840 --> 00:02:51,480
proof of stake parties will not know the

68
00:02:51,480 --> 00:02:53,879
activation level of all the things

69
00:02:53,879 --> 00:02:56,819
so for permissionless protocols they can

70
00:02:56,819 --> 00:02:58,560
no longer use the number of the parties

71
00:02:58,560 --> 00:03:00,959
or say the number of the corrupted ones

72
00:03:00,959 --> 00:03:03,000
in the protocol logic and that's because

73
00:03:03,000 --> 00:03:05,459
they completely lose the ability to

74
00:03:05,459 --> 00:03:08,519
count they lose this ability to count

75
00:03:08,519 --> 00:03:10,980
due to the fact that the number of the

76
00:03:10,980 --> 00:03:12,060
parties

77
00:03:12,060 --> 00:03:14,519
will be will never be known to the the

78
00:03:14,519 --> 00:03:16,379
number of the parties when never be

79
00:03:16,379 --> 00:03:17,400
known to

80
00:03:17,400 --> 00:03:20,040
the honest ones and we have a different

81
00:03:20,040 --> 00:03:22,080
way to authenticate messages like by

82
00:03:22,080 --> 00:03:24,360
using proof proof of work or proof of

83
00:03:24,360 --> 00:03:25,800
stake

84
00:03:25,800 --> 00:03:28,860
so we conclude here that almost all the

85
00:03:28,860 --> 00:03:30,659
existing synchronization protocols were

86
00:03:30,659 --> 00:03:32,459
not worked in this new environment

87
00:03:32,459 --> 00:03:34,440
without with Y exception which is

88
00:03:34,440 --> 00:03:36,840
uraborous Chronos and I will go through

89
00:03:36,840 --> 00:03:38,099
it later

90
00:03:38,099 --> 00:03:40,319
so before we proceed let's first take a

91
00:03:40,319 --> 00:03:42,720
look at clocks in Bitcoin so in Bitcoin

92
00:03:42,720 --> 00:03:44,940
the timestamp of a block mainly comes

93
00:03:44,940 --> 00:03:46,920
from three different sources the first

94
00:03:46,920 --> 00:03:49,920
one is the minus local system clock it

95
00:03:49,920 --> 00:03:52,500
is usually a digestive adjusted via the

96
00:03:52,500 --> 00:03:54,480
ntp protocol which is a centralized

97
00:03:54,480 --> 00:03:56,280
service and can suffer from the single

98
00:03:56,280 --> 00:03:58,500
point failure and the Second Source is

99
00:03:58,500 --> 00:04:00,659
from the median of the clocks from peers

100
00:04:00,659 --> 00:04:03,000
however in the protocol in Bitcoin

101
00:04:03,000 --> 00:04:04,739
protocol it allows for some amount of

102
00:04:04,739 --> 00:04:07,680
the deviation and if they do not agree

103
00:04:07,680 --> 00:04:09,360
then it will ask for the human operator

104
00:04:09,360 --> 00:04:11,760
so if you take a take a look at the

105
00:04:11,760 --> 00:04:13,379
Bitcoin blockchain then you can find

106
00:04:13,379 --> 00:04:16,019
that many blocks they report timestamps

107
00:04:16,019 --> 00:04:18,540
that are earlier than their ancestors

108
00:04:18,540 --> 00:04:20,459
which means that the clocks in the

109
00:04:20,459 --> 00:04:24,000
Bitcoin Network are not synchronized

110
00:04:24,000 --> 00:04:25,860
however we highlight here that this

111
00:04:25,860 --> 00:04:28,020
observation is actually not in line with

112
00:04:28,020 --> 00:04:30,000
the current understanding of nakamadok

113
00:04:30,000 --> 00:04:32,340
sensors where you can see that here in

114
00:04:32,340 --> 00:04:34,620
all the previous analysis zero Zoom

115
00:04:34,620 --> 00:04:36,660
parties have access to synchronized

116
00:04:36,660 --> 00:04:38,759
blocks also there is a publicly

117
00:04:38,759 --> 00:04:41,040
accessible Global clock

118
00:04:41,040 --> 00:04:44,520
so why it is still good to ask if

119
00:04:44,520 --> 00:04:46,979
Nakamoto consensus is secure with the

120
00:04:46,979 --> 00:04:49,380
existing scheme in Bitcoin we are more

121
00:04:49,380 --> 00:04:51,240
interested in if we can completely

122
00:04:51,240 --> 00:04:52,500
remove the

123
00:04:52,500 --> 00:04:53,940
global

124
00:04:53,940 --> 00:04:56,940
the global clock assumption here yeah

125
00:04:56,940 --> 00:04:59,520
so this asks for a permissionless clock

126
00:04:59,520 --> 00:05:02,040
synchronization protocol so here we have

127
00:05:02,040 --> 00:05:04,500
y success board fire it has the reverse

128
00:05:04,500 --> 00:05:06,840
Chronos protocol which is the first

129
00:05:06,840 --> 00:05:09,000
permissionless protocol that can do

130
00:05:09,000 --> 00:05:11,040
clock synchronization by using proof of

131
00:05:11,040 --> 00:05:12,139
stick

132
00:05:12,139 --> 00:05:14,100
however

133
00:05:14,100 --> 00:05:15,960
uh the baddest thing here is that the

134
00:05:15,960 --> 00:05:17,759
construction from Chronos cannot be

135
00:05:17,759 --> 00:05:19,560
directly applied in the proof of work

136
00:05:19,560 --> 00:05:22,199
context and that's mainly because for

137
00:05:22,199 --> 00:05:24,240
proof of work it has a different way to

138
00:05:24,240 --> 00:05:27,180
react to the party fluctuation so if you

139
00:05:27,180 --> 00:05:29,340
directly run Chronos then the protocol

140
00:05:29,340 --> 00:05:31,560
will eventually become insecure while

141
00:05:31,560 --> 00:05:33,240
the number of the parties keeps

142
00:05:33,240 --> 00:05:35,220
increasing or decreasing

143
00:05:35,220 --> 00:05:37,440
so here we are mainly interested in

144
00:05:37,440 --> 00:05:40,020
these two curve strings first by

145
00:05:40,020 --> 00:05:42,000
assuming a public setup and proof of

146
00:05:42,000 --> 00:05:45,539
work is there a permissionless clock

147
00:05:45,539 --> 00:05:48,780
synchronization protocol and is there a

148
00:05:48,780 --> 00:05:51,300
proof of work protocol that does not

149
00:05:51,300 --> 00:05:54,060
have any dependency on public resources

150
00:05:54,060 --> 00:05:56,699
on the external resources to help adjust

151
00:05:56,699 --> 00:05:58,740
its clocks

152
00:05:58,740 --> 00:06:01,919
so in our paper we provide a positive

153
00:06:01,919 --> 00:06:04,740
answer to these two questions we present

154
00:06:04,740 --> 00:06:07,020
the first proof of work based protocol

155
00:06:07,020 --> 00:06:10,139
which we call its timekeeper and this

156
00:06:10,139 --> 00:06:12,360
this protocol stops the permission list

157
00:06:12,360 --> 00:06:14,880
clock synchronization problem we can

158
00:06:14,880 --> 00:06:17,100
achieve precision and accuracy by

159
00:06:17,100 --> 00:06:18,840
assuming the bond data Dynamic

160
00:06:18,840 --> 00:06:21,780
participation and honest maturity which

161
00:06:21,780 --> 00:06:23,940
is defined in terms of the number of the

162
00:06:23,940 --> 00:06:26,639
random Oracle queries

163
00:06:26,639 --> 00:06:28,800
so in the rest part of the talk I will

164
00:06:28,800 --> 00:06:31,500
present a high level overview of our

165
00:06:31,500 --> 00:06:34,080
protocol so in the timekeeper protocol

166
00:06:34,080 --> 00:06:36,180
what the part is we are doing that they

167
00:06:36,180 --> 00:06:38,100
were you they were mining a proof of

168
00:06:38,100 --> 00:06:40,860
work for 10. this part is travel

169
00:06:40,860 --> 00:06:42,840
alongside with the mining process of

170
00:06:42,840 --> 00:06:44,759
this blockchain they will use two for

171
00:06:44,759 --> 00:06:47,039
one proof of work to mine and diffuse

172
00:06:47,039 --> 00:06:48,479
sync messages

173
00:06:48,479 --> 00:06:50,940
which are a special type of the blocks

174
00:06:50,940 --> 00:06:53,639
that will contain miners local time

175
00:06:53,639 --> 00:06:56,580
so let me firstly explain what is 241

176
00:06:56,580 --> 00:06:58,199
proof of work

177
00:06:58,199 --> 00:07:01,139
so this is a technique that can compose

178
00:07:01,139 --> 00:07:04,139
multiple proof of work mining processes

179
00:07:04,139 --> 00:07:07,020
with access to a single random Oracle

180
00:07:07,020 --> 00:07:09,360
so here we have an illustration of the

181
00:07:09,360 --> 00:07:11,940
most simple case where you want to bind

182
00:07:11,940 --> 00:07:14,220
the mining process of Taiwan and Pi put

183
00:07:14,220 --> 00:07:15,000
together

184
00:07:15,000 --> 00:07:17,759
so we prepare the lungs and the input

185
00:07:17,759 --> 00:07:19,919
for pi Y and Pi 2 together to the random

186
00:07:19,919 --> 00:07:22,560
Oracle and after you get the output you

187
00:07:22,560 --> 00:07:25,259
check if this output and the reverse the

188
00:07:25,259 --> 00:07:27,419
string of this output will satisfy

189
00:07:27,419 --> 00:07:30,000
certain conditions if they do satisfy

190
00:07:30,000 --> 00:07:32,639
then you successfully mine a blocking

191
00:07:32,639 --> 00:07:34,860
the corresponding protocol

192
00:07:34,860 --> 00:07:36,960
this primitive has many applications

193
00:07:36,960 --> 00:07:40,199
like in the original work it can help to

194
00:07:40,199 --> 00:07:42,419
improve the Corruptions threshold in the

195
00:07:42,419 --> 00:07:44,819
presenting in the proof of work based

196
00:07:44,819 --> 00:07:46,979
designing agreements from weather to

197
00:07:46,979 --> 00:07:50,220
honest majority and it can be useful if

198
00:07:50,220 --> 00:07:51,900
you want to build a parallel chance or

199
00:07:51,900 --> 00:07:54,479
to achieve very worth sharing

200
00:07:54,479 --> 00:07:57,479
so back to our timekeeper protocol after

201
00:07:57,479 --> 00:08:00,780
we bind the mining process of this proof

202
00:08:00,780 --> 00:08:02,520
of proof of work blockchain and the

203
00:08:02,520 --> 00:08:04,340
mining process of sync messages together

204
00:08:04,340 --> 00:08:07,380
what parties were doing that they will

205
00:08:07,380 --> 00:08:09,180
include distinct messages into this

206
00:08:09,180 --> 00:08:11,819
blockchain like the regular transactions

207
00:08:11,819 --> 00:08:14,400
and periodically they will use this

208
00:08:14,400 --> 00:08:16,740
blockchain to reach consensus of the set

209
00:08:16,740 --> 00:08:18,840
of the sync messages

210
00:08:18,840 --> 00:08:20,660
so here you can see that

211
00:08:20,660 --> 00:08:23,639
and we call this a synchronization

212
00:08:23,639 --> 00:08:24,900
interval

213
00:08:24,900 --> 00:08:27,180
at the end of the synchronization

214
00:08:27,180 --> 00:08:29,819
interval uh parties will have a

215
00:08:29,819 --> 00:08:31,860
consistent view of the set of the sync

216
00:08:31,860 --> 00:08:34,140
messages and they will do some

217
00:08:34,140 --> 00:08:36,899
adjustments on their local clocks so

218
00:08:36,899 --> 00:08:38,520
what they were doing that they were

219
00:08:38,520 --> 00:08:40,320
compute the delay of the sync messages

220
00:08:40,320 --> 00:08:43,200
and the delay of a sync message can be

221
00:08:43,200 --> 00:08:45,779
extracted by comparing the time recorded

222
00:08:45,779 --> 00:08:48,120
in this message and its local arrival

223
00:08:48,120 --> 00:08:51,420
time so after each party compares the

224
00:08:51,420 --> 00:08:53,820
delay for each sync messages they will

225
00:08:53,820 --> 00:08:55,980
pick the median value of these delays

226
00:08:55,980 --> 00:08:58,440
and add it to their local clock we can

227
00:08:58,440 --> 00:09:00,899
prove that by doing so parties can

228
00:09:00,899 --> 00:09:02,040
maintain

229
00:09:02,040 --> 00:09:04,500
clocks that can satisfy precision and

230
00:09:04,500 --> 00:09:06,180
accuracy

231
00:09:06,180 --> 00:09:08,339
and the things this is a permissionless

232
00:09:08,339 --> 00:09:11,160
protocol parties can join and live yeah

233
00:09:11,160 --> 00:09:13,800
so for the joining parties we provide a

234
00:09:13,800 --> 00:09:15,660
mechanic system for them to sync with

235
00:09:15,660 --> 00:09:17,940
honest parties and we also note here

236
00:09:17,940 --> 00:09:21,300
that for the newly joint parties they do

237
00:09:21,300 --> 00:09:22,860
not have any knowledge about the

238
00:09:22,860 --> 00:09:25,080
protocol time what they know is that

239
00:09:25,080 --> 00:09:27,899
they only know the CRS or say the

240
00:09:27,899 --> 00:09:29,940
Genesis block so after they join this

241
00:09:29,940 --> 00:09:31,800
protocol they can bootstrap the

242
00:09:31,800 --> 00:09:34,380
blockchain from this Genesis block and

243
00:09:34,380 --> 00:09:37,740
they will listen passively to they will

244
00:09:37,740 --> 00:09:39,839
passively listened to this protocol so

245
00:09:39,839 --> 00:09:41,880
after they observe a complete

246
00:09:41,880 --> 00:09:43,980
synchronization interval they can have

247
00:09:43,980 --> 00:09:45,959
some information on the blockchain and

248
00:09:45,959 --> 00:09:47,519
also they can book keep the local

249
00:09:47,519 --> 00:09:50,399
arrival time of all the sync messages so

250
00:09:50,399 --> 00:09:52,140
they can do some similar adjustments

251
00:09:52,140 --> 00:09:55,080
like the honest parties and by doing so

252
00:09:55,080 --> 00:09:56,580
they can

253
00:09:56,580 --> 00:09:58,680
to say catch up and think with all the

254
00:09:58,680 --> 00:10:00,660
honest parties and we also highlight

255
00:10:00,660 --> 00:10:03,420
here that this joining process is

256
00:10:03,420 --> 00:10:05,760
passive which means that after new

257
00:10:05,760 --> 00:10:08,339
parties drawing there's no need to

258
00:10:08,339 --> 00:10:10,260
update to the internal state of any

259
00:10:10,260 --> 00:10:12,540
other classes

260
00:10:12,540 --> 00:10:15,660
and also finally uh you know in the

261
00:10:15,660 --> 00:10:17,700
timekeeper protocol we provide a new way

262
00:10:17,700 --> 00:10:20,820
to react to the party fluctuation and

263
00:10:20,820 --> 00:10:21,959
here

264
00:10:21,959 --> 00:10:24,540
you know uh since we want to do the

265
00:10:24,540 --> 00:10:26,279
clock synchronization it actually

266
00:10:26,279 --> 00:10:29,519
requires a secure permission list proof

267
00:10:29,519 --> 00:10:32,100
of work blockchain however to get the

268
00:10:32,100 --> 00:10:34,980
secure proof of work blockchain then you

269
00:10:34,980 --> 00:10:38,760
need a an appropriate mining difficulty

270
00:10:38,760 --> 00:10:41,279
so the problem here is that for all the

271
00:10:41,279 --> 00:10:44,640
existing ways to to say recalculate this

272
00:10:44,640 --> 00:10:47,820
mining difficulty it requires a somewhat

273
00:10:47,820 --> 00:10:50,160
accurate timestamp so you can see that

274
00:10:50,160 --> 00:10:52,380
here we have something that looks

275
00:10:52,380 --> 00:10:54,779
circular at the first glance you want

276
00:10:54,779 --> 00:10:57,660
you want to get a good mining difficulty

277
00:10:57,660 --> 00:11:00,720
but it requires the accurate timestamp

278
00:11:00,720 --> 00:11:03,480
then if we want to get the accurate

279
00:11:03,480 --> 00:11:06,000
timestamp it requires a good mining

280
00:11:06,000 --> 00:11:08,459
difficulty so we solve this problem by

281
00:11:08,459 --> 00:11:10,079
introducing a novel Target to a

282
00:11:10,079 --> 00:11:12,060
calculation function which can be viewed

283
00:11:12,060 --> 00:11:14,459
as the reverse the version of bitcoin's

284
00:11:14,459 --> 00:11:16,440
original function and in this new

285
00:11:16,440 --> 00:11:18,839
function we completely remove the usage

286
00:11:18,839 --> 00:11:21,360
of timestamps and then we can prove that

287
00:11:21,360 --> 00:11:24,120
this new function it can help to the

288
00:11:24,120 --> 00:11:26,220
blockchain to react to the party

289
00:11:26,220 --> 00:11:28,920
fluctuate party fluctuation without

290
00:11:28,920 --> 00:11:31,560
hurting the synchronization mechanisms

291
00:11:31,560 --> 00:11:34,560
yeah and this is a very high level

292
00:11:34,560 --> 00:11:36,899
overview of our protocol

293
00:11:36,899 --> 00:11:39,240
so since I do not have time to go

294
00:11:39,240 --> 00:11:40,380
through the models and the protocol

295
00:11:40,380 --> 00:11:42,839
details let me just some uh sum up all

296
00:11:42,839 --> 00:11:45,420
the things here so in our paper we

297
00:11:45,420 --> 00:11:47,519
present the first proof of work based

298
00:11:47,519 --> 00:11:49,920
protocol timekeeper which can solve this

299
00:11:49,920 --> 00:11:51,420
permissionless clock synchronization

300
00:11:51,420 --> 00:11:54,000
problem and we can achieve those two

301
00:11:54,000 --> 00:11:56,220
conditions two conditions precision and

302
00:11:56,220 --> 00:11:58,079
accuracy which is

303
00:11:58,079 --> 00:12:00,180
by assuming the bank data Dynamic

304
00:12:00,180 --> 00:12:02,160
participation and honest maturity in

305
00:12:02,160 --> 00:12:04,740
terms of the random Oracle queries and

306
00:12:04,740 --> 00:12:07,380
this fits to the end of my talk and

307
00:12:07,380 --> 00:12:10,399
thank you for paying attention

308
00:12:17,700 --> 00:12:20,480
questions

309
00:12:28,380 --> 00:12:30,600
so sorry if I missed some of the

310
00:12:30,600 --> 00:12:32,820
motivation but can you can you talk a

311
00:12:32,820 --> 00:12:35,760
little bit about like what uh like if

312
00:12:35,760 --> 00:12:37,260
you want to use a protocol like this

313
00:12:37,260 --> 00:12:39,839
what you gain from having this uh like

314
00:12:39,839 --> 00:12:42,839
permission list synchronization yes yes

315
00:12:42,839 --> 00:12:45,180
so what you what you get is that you

316
00:12:45,180 --> 00:12:47,220
have a protocol that does not rely on

317
00:12:47,220 --> 00:12:49,620
any external resources which means that

318
00:12:49,620 --> 00:12:53,060
it can be its own synchronizer

319
00:12:53,060 --> 00:12:55,079
last part again

320
00:12:55,079 --> 00:12:57,959
yes so it can become it's unsynchronizer

321
00:12:57,959 --> 00:12:59,820
which means that you can synchronize The

322
00:12:59,820 --> 00:13:04,380
Clocks by the by the protocol itself

323
00:13:04,380 --> 00:13:07,200
yes yes I yes I understand that but like

324
00:13:07,200 --> 00:13:09,959
uh like do you know if there's some like

325
00:13:09,959 --> 00:13:11,579
if there's some practical motivation

326
00:13:11,579 --> 00:13:13,380
where people wants to be synchronizing

327
00:13:13,380 --> 00:13:16,019
within the protocol yes yes because uh

328
00:13:16,019 --> 00:13:19,620
time step manipulation can be you know a

329
00:13:19,620 --> 00:13:21,420
way to attack the the permissionless

330
00:13:21,420 --> 00:13:23,700
blockchain protocols so if you can still

331
00:13:23,700 --> 00:13:26,579
synchronize then you can remove the the

332
00:13:26,579 --> 00:13:28,800
vector of the timestamps from the

333
00:13:28,800 --> 00:13:31,380
possible attack and so and so how do

334
00:13:31,380 --> 00:13:33,240
protocols that don't have this property

335
00:13:33,240 --> 00:13:34,800
how do they mitigate against this kind

336
00:13:34,800 --> 00:13:35,880
of problem

337
00:13:35,880 --> 00:13:38,459
uh they have the waste their their own

338
00:13:38,459 --> 00:13:41,820
ways to adjust the their timestamps like

339
00:13:41,820 --> 00:13:44,279
what I said in Bitcoin they were used up

340
00:13:44,279 --> 00:13:46,800
here the the values from the clocks from

341
00:13:46,800 --> 00:13:48,899
peers or say that they rely on some

342
00:13:48,899 --> 00:13:52,260
third-party services yeah got it thank

343
00:13:52,260 --> 00:13:54,060
you and so that makes sense thanks a lot

344
00:13:54,060 --> 00:13:55,860
all right uh let's thank the speaker

345
00:13:55,860 --> 00:13:58,160
again

346
00:14:18,740 --> 00:14:22,579
oh wait a minute to start

347
00:14:43,100 --> 00:14:46,139
okay our next speaker is Harry Eldridge

348
00:14:46,139 --> 00:14:47,579
he'll be telling us about one-time

349
00:14:47,579 --> 00:14:50,160
programs from commodity Hardware

350
00:14:50,160 --> 00:14:52,699
all right

351
00:14:56,160 --> 00:14:58,260
my am I on not yet I am okay great

352
00:14:58,260 --> 00:15:00,000
perfect okay all right thank you so much

353
00:15:00,000 --> 00:15:02,880
for the introduction uh so this is a

354
00:15:02,880 --> 00:15:04,920
joint work between myself or she goal

355
00:15:04,920 --> 00:15:07,160
Matt Greene Abhishek Jen and Max incus

356
00:15:07,160 --> 00:15:11,459
so what on one-time programs one-time

357
00:15:11,459 --> 00:15:14,699
programs are a sort of limited use uh

358
00:15:14,699 --> 00:15:16,740
obfuscation first put forward by

359
00:15:16,740 --> 00:15:19,260
Goldwater Kawaii and rough bloom in 2008

360
00:15:19,260 --> 00:15:20,880
and the idea is that it is a program

361
00:15:20,880 --> 00:15:24,240
that you can only run once so Alice has

362
00:15:24,240 --> 00:15:25,500
some program that she wants to send to

363
00:15:25,500 --> 00:15:27,540
Bob so that Bob can execute it on a

364
00:15:27,540 --> 00:15:29,160
single input of his choice

365
00:15:29,160 --> 00:15:31,800
so she process it it in some way to make

366
00:15:31,800 --> 00:15:33,899
it one time she then sends the one-time

367
00:15:33,899 --> 00:15:36,660
program to Bob who can now execute it on

368
00:15:36,660 --> 00:15:39,240
a single input and get some output now

369
00:15:39,240 --> 00:15:40,980
the key property here is that at a later

370
00:15:40,980 --> 00:15:42,720
time Bob's tries to execute this program

371
00:15:42,720 --> 00:15:44,760
on some other input he gets nothing

372
00:15:44,760 --> 00:15:46,380
right the program has sort of

373
00:15:46,380 --> 00:15:48,779
self-destructed in some way

374
00:15:48,779 --> 00:15:50,699
so I'm going to try and motivate my why

375
00:15:50,699 --> 00:15:51,839
we might want to build these with a

376
00:15:51,839 --> 00:15:53,519
couple of applications so a really

377
00:15:53,519 --> 00:15:55,440
natural application is limited attempt

378
00:15:55,440 --> 00:15:58,019
authentication so say Alice has some

379
00:15:58,019 --> 00:15:59,279
sort of file that he wants to send to

380
00:15:59,279 --> 00:16:00,540
Bob but she wants the file to be

381
00:16:00,540 --> 00:16:03,000
protected by a sort right we have sort

382
00:16:03,000 --> 00:16:04,440
of standard ways to do this but many of

383
00:16:04,440 --> 00:16:06,300
them are vulnerable to Brute Force

384
00:16:06,300 --> 00:16:08,399
attacks right somebody may just guess a

385
00:16:08,399 --> 00:16:09,779
bunch of very common passwords and if

386
00:16:09,779 --> 00:16:11,160
Alice uses a particularly terrible one

387
00:16:11,160 --> 00:16:13,320
then they can you know extract the file

388
00:16:13,320 --> 00:16:15,120
from whatever sort of protection she

389
00:16:15,120 --> 00:16:17,519
uses right but with one-time programs we

390
00:16:17,519 --> 00:16:19,380
can get around this right Alice could

391
00:16:19,380 --> 00:16:21,000
say write a program that takes a

392
00:16:21,000 --> 00:16:22,560
password guess as input and if it

393
00:16:22,560 --> 00:16:24,000
happens to be correct outputs the file

394
00:16:24,000 --> 00:16:25,980
right she could now make this program

395
00:16:25,980 --> 00:16:28,680
one time and send that to Bob Bob can

396
00:16:28,680 --> 00:16:30,959
input his password into the program as

397
00:16:30,959 --> 00:16:33,300
usual and get the file back but if you

398
00:16:33,300 --> 00:16:34,860
know someone intercepted this in transit

399
00:16:34,860 --> 00:16:37,019
they only have a single attempt to guess

400
00:16:37,019 --> 00:16:39,120
the password right so in this case

401
00:16:39,120 --> 00:16:40,620
particularly weak passwords can actually

402
00:16:40,620 --> 00:16:43,199
offer a pretty decent amount of security

403
00:16:43,199 --> 00:16:45,899
okay so a couple of other applications

404
00:16:45,899 --> 00:16:47,639
real quick here one is something like

405
00:16:47,639 --> 00:16:49,980
differentially private data analysis so

406
00:16:49,980 --> 00:16:51,480
say that I have some data set that I've

407
00:16:51,480 --> 00:16:54,600
added some noise to such that it's uh

408
00:16:54,600 --> 00:16:57,120
it's retains privacy up to like n

409
00:16:57,120 --> 00:16:58,980
aggregation queries and I want the

410
00:16:58,980 --> 00:16:59,940
journalists to be able to make some

411
00:16:59,940 --> 00:17:01,620
queries against this data set I could

412
00:17:01,620 --> 00:17:03,540
send them n different or n one-time

413
00:17:03,540 --> 00:17:05,280
programs Each of which allows a single

414
00:17:05,280 --> 00:17:07,260
query against the data right now the

415
00:17:07,260 --> 00:17:08,579
journalists can make their queries on

416
00:17:08,579 --> 00:17:10,199
their own time and I get to sleep

417
00:17:10,199 --> 00:17:11,459
soundly at night knowing that the

418
00:17:11,459 --> 00:17:13,859
privacy of my data won't be violated

419
00:17:13,859 --> 00:17:15,240
um another sort of scary application is

420
00:17:15,240 --> 00:17:17,459
autonomous ransomware so in a typical

421
00:17:17,459 --> 00:17:19,619
ransomware attack a uh some sort of

422
00:17:19,619 --> 00:17:21,299
perpetrating group get some malware on a

423
00:17:21,299 --> 00:17:22,980
machine that then encrypts all the files

424
00:17:22,980 --> 00:17:25,079
on that machine and they require some

425
00:17:25,079 --> 00:17:26,640
sort of bounty to be paid before giving

426
00:17:26,640 --> 00:17:28,740
the uh the victim the decryption key

427
00:17:28,740 --> 00:17:30,540
this requires this communication between

428
00:17:30,540 --> 00:17:33,480
the uh perpetrating group and the uh the

429
00:17:33,480 --> 00:17:34,740
machine which is maybe a little bit more

430
00:17:34,740 --> 00:17:36,720
dangerous for the the group or it's also

431
00:17:36,720 --> 00:17:37,679
just a hassle right it means they

432
00:17:37,679 --> 00:17:38,880
essentially need like a customer service

433
00:17:38,880 --> 00:17:41,400
department but with a with a one-time

434
00:17:41,400 --> 00:17:43,140
program we can make ransomware fully

435
00:17:43,140 --> 00:17:45,480
autonomous we could ship along with the

436
00:17:45,480 --> 00:17:47,039
uh the ransomware a one-time program

437
00:17:47,039 --> 00:17:48,539
that takes a proof that some amount of

438
00:17:48,539 --> 00:17:49,860
cryptocurrency has been paid to some

439
00:17:49,860 --> 00:17:51,720
address on a blockchain and then it

440
00:17:51,720 --> 00:17:53,220
verifies the proof is correct and then

441
00:17:53,220 --> 00:17:55,020
if so we'll output the degree encryption

442
00:17:55,020 --> 00:17:57,120
key so now it's fully set and forget

443
00:17:57,120 --> 00:17:59,460
okay so hopefully I've convinced you

444
00:17:59,460 --> 00:18:01,919
that one-time programs are useful or at

445
00:18:01,919 --> 00:18:03,539
least interesting so can we actually

446
00:18:03,539 --> 00:18:05,760
build them well unfortunately in the

447
00:18:05,760 --> 00:18:06,900
original paper that put them forward

448
00:18:06,900 --> 00:18:09,000
they showed that you can't be realized

449
00:18:09,000 --> 00:18:10,380
only in software right the reasons for

450
00:18:10,380 --> 00:18:11,580
this should be fairly clear right

451
00:18:11,580 --> 00:18:13,440
software can be copied it can be

452
00:18:13,440 --> 00:18:15,059
executed in a virtual machine and then

453
00:18:15,059 --> 00:18:16,980
rewound both of which would immediately

454
00:18:16,980 --> 00:18:18,780
destroy the one-time property that we

455
00:18:18,780 --> 00:18:20,580
want so we need to change the model

456
00:18:20,580 --> 00:18:22,140
somehow right there are a couple

457
00:18:22,140 --> 00:18:23,340
different approaches to this there have

458
00:18:23,340 --> 00:18:25,080
been works that look at doing this with

459
00:18:25,080 --> 00:18:26,760
blockchains we saw yesterday you can do

460
00:18:26,760 --> 00:18:28,620
this with proteins in uh you know in

461
00:18:28,620 --> 00:18:31,200
test tubes but what gkr do and what we

462
00:18:31,200 --> 00:18:33,059
continue with is using secure Hardware

463
00:18:33,059 --> 00:18:35,280
specifically some very very simple

464
00:18:35,280 --> 00:18:38,280
secure Hardware the way GTR gkr do this

465
00:18:38,280 --> 00:18:39,600
is they use something known as a

466
00:18:39,600 --> 00:18:42,179
one-time memory token so a one-time

467
00:18:42,179 --> 00:18:44,460
memory here we have Alice and Bob Alice

468
00:18:44,460 --> 00:18:46,799
has her two uh two values A and B and

469
00:18:46,799 --> 00:18:48,419
she'd like Bob to learn exactly one of

470
00:18:48,419 --> 00:18:51,179
them so she puts a and b into a token

471
00:18:51,179 --> 00:18:53,460
and she sends the token to Bob Bob can

472
00:18:53,460 --> 00:18:54,840
now choose to get one of these two

473
00:18:54,840 --> 00:18:56,280
values either you know the left or the

474
00:18:56,280 --> 00:18:58,559
right the zero or the one index and say

475
00:18:58,559 --> 00:19:00,120
he wants the zero index he puts that

476
00:19:00,120 --> 00:19:02,760
into the token he gets spec A and B is

477
00:19:02,760 --> 00:19:04,140
permanently destroyed right the other

478
00:19:04,140 --> 00:19:06,120
half is completely gone this is sort of

479
00:19:06,120 --> 00:19:08,640
a non-interactive OT via secure Hardware

480
00:19:08,640 --> 00:19:11,280
right and so they jumped to one-time

481
00:19:11,280 --> 00:19:12,660
programs from these are actually fairly

482
00:19:12,660 --> 00:19:14,400
fairly straightforward Alice would

483
00:19:14,400 --> 00:19:16,799
garble the circuit and then take the two

484
00:19:16,799 --> 00:19:18,539
uh two labels for each input wire and

485
00:19:18,539 --> 00:19:20,100
put them into a one-time memory and then

486
00:19:20,100 --> 00:19:21,299
ship that collection of one-time

487
00:19:21,299 --> 00:19:23,160
memories off to Bob who can get exactly

488
00:19:23,160 --> 00:19:24,660
one label and then execute the garbled

489
00:19:24,660 --> 00:19:27,000
circuit but can't get any more right

490
00:19:27,000 --> 00:19:29,460
okay so that uses exactly one one-time

491
00:19:29,460 --> 00:19:31,440
memory token per input wire of the

492
00:19:31,440 --> 00:19:34,500
circuit okay so despite the fact that we

493
00:19:34,500 --> 00:19:36,600
know how to do this right we still don't

494
00:19:36,600 --> 00:19:38,340
see one-time programs actually out in

495
00:19:38,340 --> 00:19:40,080
the world right so why might that be

496
00:19:40,080 --> 00:19:42,539
well one-time memory is while simple are

497
00:19:42,539 --> 00:19:44,160
sort of non-standard right there are no

498
00:19:44,160 --> 00:19:46,080
Cloud providers that allow access to

499
00:19:46,080 --> 00:19:47,580
this if somebody wanted to make like a

500
00:19:47,580 --> 00:19:49,679
smart card that implemented this that

501
00:19:49,679 --> 00:19:50,820
would maybe require some development

502
00:19:50,820 --> 00:19:52,440
costs but in general right one-time

503
00:19:52,440 --> 00:19:54,299
memories don't actually exist in the

504
00:19:54,299 --> 00:19:56,100
world so this leads to the main question

505
00:19:56,100 --> 00:19:58,380
of our paper can we build one-time

506
00:19:58,380 --> 00:20:00,059
programs from Hardware that is already

507
00:20:00,059 --> 00:20:02,100
widely available right Hardware that

508
00:20:02,100 --> 00:20:03,000
already exists in the world that

509
00:20:03,000 --> 00:20:05,039
consumers have access to right now

510
00:20:05,039 --> 00:20:06,720
and we answer this question in the

511
00:20:06,720 --> 00:20:09,120
affirmative and our Hardware of choice

512
00:20:09,120 --> 00:20:12,000
is the counter lock box

513
00:20:12,000 --> 00:20:14,220
so what is a counter lock box counter

514
00:20:14,220 --> 00:20:16,020
lock box is a piece of secure Hardware

515
00:20:16,020 --> 00:20:17,820
that has three things inside of it it

516
00:20:17,820 --> 00:20:21,419
has a secret it has a password and it

517
00:20:21,419 --> 00:20:23,400
has an attempt counter

518
00:20:23,400 --> 00:20:26,280
and to use one you input a guess at the

519
00:20:26,280 --> 00:20:28,260
password and if your guess is correct it

520
00:20:28,260 --> 00:20:29,880
will output the secret

521
00:20:29,880 --> 00:20:31,740
however if you wouldn't put the wrong

522
00:20:31,740 --> 00:20:33,960
guess you get nothing and the attempt

523
00:20:33,960 --> 00:20:35,900
counter goes down by one

524
00:20:35,900 --> 00:20:38,640
finally if you make a wrong guess when

525
00:20:38,640 --> 00:20:40,020
the attempt counter is already at one

526
00:20:40,020 --> 00:20:42,600
you again get nothing and as the attempt

527
00:20:42,600 --> 00:20:44,280
counter goes to zero the secret is

528
00:20:44,280 --> 00:20:46,080
permanently deleted right so it's now

529
00:20:46,080 --> 00:20:47,820
irrecoverable

530
00:20:47,820 --> 00:20:49,620
and so the brilliant thing about counter

531
00:20:49,620 --> 00:20:51,900
lock boxes is that they already exist

532
00:20:51,900 --> 00:20:54,480
right they exist inside of the secure

533
00:20:54,480 --> 00:20:56,820
co-processors and our smartphones right

534
00:20:56,820 --> 00:20:58,320
Apple has this thing called the secure

535
00:20:58,320 --> 00:21:00,840
Enclave processor or SCP where when your

536
00:21:00,840 --> 00:21:02,880
iPhone is sort of in a locked down state

537
00:21:02,880 --> 00:21:04,919
all the things on the file system are

538
00:21:04,919 --> 00:21:06,539
encrypted under some key that you need

539
00:21:06,539 --> 00:21:08,640
to get by inputting the right passcode

540
00:21:08,640 --> 00:21:10,919
and just as in the lockbox way you have

541
00:21:10,919 --> 00:21:12,179
a few attempts at guessing the right

542
00:21:12,179 --> 00:21:14,160
password if you do you get the key back

543
00:21:14,160 --> 00:21:16,020
to decrypt all of your files and if you

544
00:21:16,020 --> 00:21:17,340
guessed it wrong too many times you get

545
00:21:17,340 --> 00:21:18,720
permanently locked out right this is

546
00:21:18,720 --> 00:21:20,520
exactly the sort of lockbox

547
00:21:20,520 --> 00:21:22,440
functionality implemented by secure

548
00:21:22,440 --> 00:21:24,539
Hardware that consumers have access to

549
00:21:24,539 --> 00:21:27,000
so additionally these exist in many sort

550
00:21:27,000 --> 00:21:28,919
of cloud backup Services right I have

551
00:21:28,919 --> 00:21:31,260
all my data stored in the cloud and I

552
00:21:31,260 --> 00:21:32,760
you know I lose my smartphone and I want

553
00:21:32,760 --> 00:21:35,100
to recover it somehow well I can again

554
00:21:35,100 --> 00:21:37,260
make a few attempts at a guess of my

555
00:21:37,260 --> 00:21:38,640
password to the cloud if I get it right

556
00:21:38,640 --> 00:21:40,440
I'll get my data back and if I get it

557
00:21:40,440 --> 00:21:41,520
wrong too many times I did it gets

558
00:21:41,520 --> 00:21:42,840
deleted right these are actually

559
00:21:42,840 --> 00:21:44,820
oftentimes implemented on secure

560
00:21:44,820 --> 00:21:46,799
Hardware but notably right these Cloud

561
00:21:46,799 --> 00:21:48,419
these providers they won't let you run

562
00:21:48,419 --> 00:21:49,860
anything you want on their secure

563
00:21:49,860 --> 00:21:51,179
Hardware in the cloud right the access

564
00:21:51,179 --> 00:21:53,280
they give you is exactly something that

565
00:21:53,280 --> 00:21:54,480
looks like the counter lockbox

566
00:21:54,480 --> 00:21:56,640
functionality so this already exists in

567
00:21:56,640 --> 00:21:57,900
several ways which is why we'd like to

568
00:21:57,900 --> 00:21:59,820
build one-time programs out of it

569
00:21:59,820 --> 00:22:01,740
so here now we can get to the main

570
00:22:01,740 --> 00:22:03,240
results of our paper

571
00:22:03,240 --> 00:22:05,039
first we show that you can indeed build

572
00:22:05,039 --> 00:22:06,419
one-time programs out of Counter lock

573
00:22:06,419 --> 00:22:08,880
boxes and the number of lock boxes per

574
00:22:08,880 --> 00:22:10,080
input bit of the circuit actually

575
00:22:10,080 --> 00:22:11,580
asymptotically matches the previous

576
00:22:11,580 --> 00:22:12,900
result right we only need a constant

577
00:22:12,900 --> 00:22:15,419
number of lock boxes per input wire

578
00:22:15,419 --> 00:22:17,700
uh we also show that with some stronger

579
00:22:17,700 --> 00:22:19,559
assumptions specifically a malicious

580
00:22:19,559 --> 00:22:21,659
receiver laconic OT which can be built

581
00:22:21,659 --> 00:22:24,539
using laconic OT and snarks then we can

582
00:22:24,539 --> 00:22:25,980
actually create one-time programs with a

583
00:22:25,980 --> 00:22:28,200
number of lock boxes uh doesn't depend

584
00:22:28,200 --> 00:22:29,700
on the input length of the circuit in

585
00:22:29,700 --> 00:22:30,600
fact only depends on the security

586
00:22:30,600 --> 00:22:32,159
parameter this is a pretty interesting

587
00:22:32,159 --> 00:22:34,080
construction but fortunately I only had

588
00:22:34,080 --> 00:22:35,280
time to go over the the first result

589
00:22:35,280 --> 00:22:36,720
here read the paper for the second one

590
00:22:36,720 --> 00:22:38,280
it's very cool

591
00:22:38,280 --> 00:22:39,840
um okay so here's our approach to the

592
00:22:39,840 --> 00:22:42,780
nutshell so we start by using counter

593
00:22:42,780 --> 00:22:44,460
lock boxes to build a form of leaky

594
00:22:44,460 --> 00:22:46,440
one-time memory right so in one time

595
00:22:46,440 --> 00:22:47,940
memory the receiver gets to learn

596
00:22:47,940 --> 00:22:50,400
exactly one of two values in leaky

597
00:22:50,400 --> 00:22:51,720
one-time memory there's a chance that

598
00:22:51,720 --> 00:22:53,520
they can learn both right it's maybe a

599
00:22:53,520 --> 00:22:55,200
low chance but they can possibly learn

600
00:22:55,200 --> 00:22:56,220
both

601
00:22:56,220 --> 00:22:58,919
so we then so if we're using the

602
00:22:58,919 --> 00:23:00,059
approach with garbled circuits right

603
00:23:00,059 --> 00:23:01,440
we're already sort of shot here right

604
00:23:01,440 --> 00:23:03,240
because if you learn both wire labels

605
00:23:03,240 --> 00:23:05,220
for some wire in a garbled circuit your

606
00:23:05,220 --> 00:23:07,559
security completely collapses right so

607
00:23:07,559 --> 00:23:09,780
we then use some OT combiner techniques

608
00:23:09,780 --> 00:23:11,340
along with these leaky one-time memories

609
00:23:11,340 --> 00:23:12,480
to actually get the full one-time

610
00:23:12,480 --> 00:23:14,700
program construction uh sort of in a

611
00:23:14,700 --> 00:23:16,620
nutshell OT combiner techniques is you

612
00:23:16,620 --> 00:23:19,080
have a bunch of bad OTS you can combine

613
00:23:19,080 --> 00:23:21,059
them all into one good OT right so we

614
00:23:21,059 --> 00:23:23,520
have a bunch of these bad leakyots we

615
00:23:23,520 --> 00:23:25,740
can combine them to make one good OT and

616
00:23:25,740 --> 00:23:27,120
then get sort of the same one-time

617
00:23:27,120 --> 00:23:29,159
program construction as a gkr with the

618
00:23:29,159 --> 00:23:30,960
garbled circuit

619
00:23:30,960 --> 00:23:32,640
um the downside to this construction is

620
00:23:32,640 --> 00:23:35,039
that it actually requires a number of

621
00:23:35,039 --> 00:23:37,260
lock boxes that is too many or Too Much

622
00:23:37,260 --> 00:23:39,720
Too way more than we want it requires a

623
00:23:39,720 --> 00:23:41,100
number of block boxes equal to the

624
00:23:41,100 --> 00:23:43,440
security parameter for each bit of the

625
00:23:43,440 --> 00:23:44,940
uh each input bit of the circuit so

626
00:23:44,940 --> 00:23:45,960
that's too many

627
00:23:45,960 --> 00:23:48,120
so we then use some additional

628
00:23:48,120 --> 00:23:49,860
techniques uh specifically robust

629
00:23:49,860 --> 00:23:52,200
garbling which this really cool uh

630
00:23:52,200 --> 00:23:54,059
technique introduced by Alma shukba at

631
00:23:54,059 --> 00:23:56,940
all in uh 2021 in which you have a

632
00:23:56,940 --> 00:23:59,400
coupled circuit where it's actually no

633
00:23:59,400 --> 00:24:01,260
longer catastrophic if the evaluator

634
00:24:01,260 --> 00:24:03,179
learns both wire labels for some number

635
00:24:03,179 --> 00:24:05,940
of input wires you can actually still uh

636
00:24:05,940 --> 00:24:08,159
your security is still retained so this

637
00:24:08,159 --> 00:24:11,100
lets us essentially use leakier one-time

638
00:24:11,100 --> 00:24:12,720
one-time memories which lets us use

639
00:24:12,720 --> 00:24:14,880
fewer lock boxes which gets us to the

640
00:24:14,880 --> 00:24:16,860
asymptotic result we saw earlier

641
00:24:16,860 --> 00:24:20,940
okay so here's sort of the core of our

642
00:24:20,940 --> 00:24:22,380
um our result how we end up building

643
00:24:22,380 --> 00:24:24,059
these one-time memories from counter

644
00:24:24,059 --> 00:24:26,460
lock boxes so we again join Alice and

645
00:24:26,460 --> 00:24:28,919
Bob Alice has two values A and B she'd

646
00:24:28,919 --> 00:24:31,080
like Bob's learn exactly one of them so

647
00:24:31,080 --> 00:24:33,480
first Alice secret shares for values A

648
00:24:33,480 --> 00:24:36,360
and B into two shares each right she

649
00:24:36,360 --> 00:24:37,799
then creates a couple of counter lock

650
00:24:37,799 --> 00:24:40,679
boxes she builds two one of which has

651
00:24:40,679 --> 00:24:42,659
each secret share of a inside of it and

652
00:24:42,659 --> 00:24:45,000
has the password set to zero for uh for

653
00:24:45,000 --> 00:24:46,200
this construction we assume that the

654
00:24:46,200 --> 00:24:48,000
attempt counter on every lock box is one

655
00:24:48,000 --> 00:24:49,679
so you have exactly one attempt to guess

656
00:24:49,679 --> 00:24:50,760
the secret and then you're locked out

657
00:24:50,760 --> 00:24:52,080
forever so I'm just not going to show

658
00:24:52,080 --> 00:24:54,179
the attempt counter for the second space

659
00:24:54,179 --> 00:24:56,280
so all right Alex has two lock boxes one

660
00:24:56,280 --> 00:24:58,260
has a share of a in it the a one each

661
00:24:58,260 --> 00:24:59,460
has a share of a in it and their

662
00:24:59,460 --> 00:25:01,919
passwords are both zero great so she now

663
00:25:01,919 --> 00:25:04,200
does the same for the shares of B except

664
00:25:04,200 --> 00:25:06,179
she sets the passwords to one

665
00:25:06,179 --> 00:25:07,500
right

666
00:25:07,500 --> 00:25:10,080
okay so she now has four lock boxes she

667
00:25:10,080 --> 00:25:12,179
shuffles them together and she gets some

668
00:25:12,179 --> 00:25:14,100
random permutation of the lock boxes all

669
00:25:14,100 --> 00:25:15,240
right so it's just a collection of four

670
00:25:15,240 --> 00:25:17,760
lock boxes now to Bob these four lock

671
00:25:17,760 --> 00:25:19,799
boxes actually look like uh black boxes

672
00:25:19,799 --> 00:25:21,659
right you can't see inside of them so

673
00:25:21,659 --> 00:25:23,820
I'm just going to label them one through

674
00:25:23,820 --> 00:25:25,559
l03 L3

675
00:25:25,559 --> 00:25:27,720
so Alice now sends this collection of

676
00:25:27,720 --> 00:25:29,760
four lock boxes to Bob and he needs to

677
00:25:29,760 --> 00:25:31,559
decide whether he wants to retrieve uh

678
00:25:31,559 --> 00:25:32,700
you know the left value or the root

679
00:25:32,700 --> 00:25:35,340
value the zero index or the one index so

680
00:25:35,340 --> 00:25:38,039
let's say Bob wants to learn the uh

681
00:25:38,039 --> 00:25:40,740
the uh the zero index value right he

682
00:25:40,740 --> 00:25:42,659
doesn't know which lock boxes contained

683
00:25:42,659 --> 00:25:44,940
the shares of that value right and but

684
00:25:44,940 --> 00:25:46,380
he needs to recover both shares in order

685
00:25:46,380 --> 00:25:48,360
to recover it however what Bob does know

686
00:25:48,360 --> 00:25:50,520
is that the password to those lock boxes

687
00:25:50,520 --> 00:25:53,039
is going to be zero right and so he can

688
00:25:53,039 --> 00:25:55,140
just guess zero as the password to every

689
00:25:55,140 --> 00:25:57,720
lockbox this guarantees that he gets the

690
00:25:57,720 --> 00:25:59,279
shares he wants while permanently

691
00:25:59,279 --> 00:26:01,320
deleting the shares for the other value

692
00:26:01,320 --> 00:26:03,840
right and so Bob will always be able to

693
00:26:03,840 --> 00:26:05,460
recover you know the value that he wants

694
00:26:05,460 --> 00:26:07,260
if Bob were behaving maliciously he

695
00:26:07,260 --> 00:26:08,940
could try and guess sort of the order of

696
00:26:08,940 --> 00:26:10,679
the lock boxes and maybe retrieve both

697
00:26:10,679 --> 00:26:13,320
but if you increase the number of shares

698
00:26:13,320 --> 00:26:15,059
here you eventually get to a point where

699
00:26:15,059 --> 00:26:16,320
the chances that Bob can actually

700
00:26:16,320 --> 00:26:18,900
recover both Shares are is uh negligible

701
00:26:18,900 --> 00:26:20,820
right and so this is sort of our leaky

702
00:26:20,820 --> 00:26:22,380
construction and then we combine this

703
00:26:22,380 --> 00:26:24,299
with robust garbling to eventually get

704
00:26:24,299 --> 00:26:25,799
the asymptotic result that you saw

705
00:26:25,799 --> 00:26:27,000
earlier

706
00:26:27,000 --> 00:26:29,940
okay so just sort of a quick summary

707
00:26:29,940 --> 00:26:31,980
here we show that you can indeed build

708
00:26:31,980 --> 00:26:33,600
one-time programs out of Hardware that's

709
00:26:33,600 --> 00:26:35,460
already widely available and sort of an

710
00:26:35,460 --> 00:26:37,380
open question here is can the number of

711
00:26:37,380 --> 00:26:39,480
lock boxes be reduced we already sort of

712
00:26:39,480 --> 00:26:42,120
you know got to constant right a

713
00:26:42,120 --> 00:26:43,620
constant number of lock boxes per input

714
00:26:43,620 --> 00:26:45,480
bit which is pretty good but our

715
00:26:45,480 --> 00:26:47,400
constants are not amazing in our

716
00:26:47,400 --> 00:26:49,100
construction for instance for like a

717
00:26:49,100 --> 00:26:51,900
256-bit uh input will require somewhere

718
00:26:51,900 --> 00:26:53,700
in the vicinity of 10 000 lock boxes

719
00:26:53,700 --> 00:26:55,860
which is quite a few we also have a

720
00:26:55,860 --> 00:26:57,659
brief analysis about how you can how

721
00:26:57,659 --> 00:26:59,580
much a lockbox actually costs right like

722
00:26:59,580 --> 00:27:01,020
you can buy an iPhone that has a lot of

723
00:27:01,020 --> 00:27:03,299
lock boxes on it you can uh you know pay

724
00:27:03,299 --> 00:27:04,620
for a phone number that will then get

725
00:27:04,620 --> 00:27:06,419
you access to like a cloud service and

726
00:27:06,419 --> 00:27:08,100
it turns out a lockbox costs around one

727
00:27:08,100 --> 00:27:10,080
dollar so you know ten thousand dollars

728
00:27:10,080 --> 00:27:11,820
for a girl for a single one-time program

729
00:27:11,820 --> 00:27:13,500
is a little bit financially infeasible

730
00:27:13,500 --> 00:27:15,179
so it would be very interesting to uh

731
00:27:15,179 --> 00:27:16,380
see if we can cut down the number of

732
00:27:16,380 --> 00:27:18,900
lock boxes that we actually need and uh

733
00:27:18,900 --> 00:27:21,799
that's it thank you very much

734
00:27:25,140 --> 00:27:27,679
questions

735
00:27:30,360 --> 00:27:33,419
is it easy to see that if you wanted to

736
00:27:33,419 --> 00:27:37,140
directly Implement uh a one-time memory

737
00:27:37,140 --> 00:27:39,720
that the number of uh

738
00:27:39,720 --> 00:27:41,700
the number of lock boxes you need would

739
00:27:41,700 --> 00:27:43,740
be super constant

740
00:27:43,740 --> 00:27:45,600
super constant

741
00:27:45,600 --> 00:27:48,299
I guess yeah because you want to you

742
00:27:48,299 --> 00:27:51,179
want to ensure that you know Bob has

743
00:27:51,179 --> 00:27:53,400
like a negligible chance of I understand

744
00:27:53,400 --> 00:27:56,039
for this construction but have you

745
00:27:56,039 --> 00:27:57,960
thought about it like a general yeah a

746
00:27:57,960 --> 00:28:00,240
general lower bounds that is a good

747
00:28:00,240 --> 00:28:03,799
question yeah I uh

748
00:28:04,200 --> 00:28:05,340
I don't think we've thought too much

749
00:28:05,340 --> 00:28:06,659
about General load around there there

750
00:28:06,659 --> 00:28:08,580
has to be some amount of lower bounds

751
00:28:08,580 --> 00:28:09,960
where like you only have two lock boxes

752
00:28:09,960 --> 00:28:12,000
you can't do much more than putting you

753
00:28:12,000 --> 00:28:14,340
know only A and B inside each one right

754
00:28:14,340 --> 00:28:16,440
so there are basically some sort of like

755
00:28:16,440 --> 00:28:17,880
practical lower bounds there but we

756
00:28:17,880 --> 00:28:19,260
don't we don't investigate the uh the

757
00:28:19,260 --> 00:28:22,039
lower bounds too much

758
00:28:23,400 --> 00:28:24,779
all right let's thank you speaker again

759
00:28:24,779 --> 00:28:27,720
oh sorry question yeah this may be uh um

760
00:28:27,720 --> 00:28:30,720
a basic question but uh for these lock

761
00:28:30,720 --> 00:28:34,440
boxes uh right if if you use it and it

762
00:28:34,440 --> 00:28:38,039
expires uh right the secrets lost can

763
00:28:38,039 --> 00:28:40,200
you then restore it or is that kind of

764
00:28:40,200 --> 00:28:43,440
just a broken lock box uh from here on

765
00:28:43,440 --> 00:28:45,779
out uh yeah we uh

766
00:28:45,779 --> 00:28:47,700
we model it as the ability to sort of

767
00:28:47,700 --> 00:28:48,960
restore it again where you could then

768
00:28:48,960 --> 00:28:50,820
you know runs rerun sort of the

769
00:28:50,820 --> 00:28:52,740
initialization procedure and have a you

770
00:28:52,740 --> 00:28:54,600
know store a new Secret inside of it but

771
00:28:54,600 --> 00:28:58,320
yeah in general uh we assume that

772
00:28:58,320 --> 00:28:59,940
yeah whatever the original secret was is

773
00:28:59,940 --> 00:29:01,559
gone forever but maybe it's sort of a

774
00:29:01,559 --> 00:29:03,240
reusable box or something yeah that we

775
00:29:03,240 --> 00:29:06,140
don't investigate that too much

776
00:29:08,940 --> 00:29:12,260
okay let's thank the speaker again

777
00:29:23,880 --> 00:29:26,880
foreign

778
00:29:52,580 --> 00:29:56,880
don't press this button yeah okay

779
00:29:56,880 --> 00:30:00,200
we're going there

780
00:30:03,659 --> 00:30:05,340
okay

781
00:30:05,340 --> 00:30:08,460
um uh our next speaker is uh is Benjamin

782
00:30:08,460 --> 00:30:10,080
Chan he'll be telling us about Universal

783
00:30:10,080 --> 00:30:12,419
reductions and indeed I will um thank

784
00:30:12,419 --> 00:30:13,799
you for sticking around because uh

785
00:30:13,799 --> 00:30:16,620
Rafael Cody and I have we what we think

786
00:30:16,620 --> 00:30:19,080
is a very cool notion for you today

787
00:30:19,080 --> 00:30:20,760
um it's called Universal reductions

788
00:30:20,760 --> 00:30:22,260
we're going to be looking at security

789
00:30:22,260 --> 00:30:25,020
reductions and uh well whether we have

790
00:30:25,020 --> 00:30:26,159
the right model

791
00:30:26,159 --> 00:30:28,980
is be called Cosmic security I hope you

792
00:30:28,980 --> 00:30:30,600
appreciate the name change

793
00:30:30,600 --> 00:30:32,700
um okay so let's Jump Right In with an

794
00:30:32,700 --> 00:30:35,100
example suppose we had a weak one-way

795
00:30:35,100 --> 00:30:36,720
function and we want to build a strong

796
00:30:36,720 --> 00:30:39,419
only function f Prime based on F and we

797
00:30:39,419 --> 00:30:40,799
have some construction in mind that's

798
00:30:40,799 --> 00:30:43,260
much harder to inverse how do we prove

799
00:30:43,260 --> 00:30:45,779
the security of f Prime currently well

800
00:30:45,779 --> 00:30:48,179
by security reduction uh we can go back

801
00:30:48,179 --> 00:30:50,100
to the textbook and say hey suppose for

802
00:30:50,100 --> 00:30:51,720
the sake of contradiction that F Prime

803
00:30:51,720 --> 00:30:53,940
is not secure that there's some attacker

804
00:30:53,940 --> 00:30:55,500
that breaks that Prime with some

805
00:30:55,500 --> 00:30:58,140
noticeable probability uh then a

806
00:30:58,140 --> 00:31:00,179
reduction says that there exists a prime

807
00:31:00,179 --> 00:31:02,399
that inverts F our assumption with

808
00:31:02,399 --> 00:31:04,320
probability large

809
00:31:04,320 --> 00:31:05,880
and this is a contradiction and

810
00:31:05,880 --> 00:31:08,220
therefore F Prime is secure right

811
00:31:08,220 --> 00:31:10,980
but observe that this proof is only

812
00:31:10,980 --> 00:31:14,580
useful to us uh if our model for

813
00:31:14,580 --> 00:31:16,919
attackers in the real world

814
00:31:16,919 --> 00:31:18,480
um correctly captures

815
00:31:18,480 --> 00:31:21,000
well real world attackers right if we

816
00:31:21,000 --> 00:31:22,500
model attackers the wrong way or

817
00:31:22,500 --> 00:31:24,240
security proof is broken our assumption

818
00:31:24,240 --> 00:31:26,159
is broken we had better be modeling

819
00:31:26,159 --> 00:31:28,260
attackers the right way

820
00:31:28,260 --> 00:31:31,559
and currently we assume what we call the

821
00:31:31,559 --> 00:31:33,419
extended physical Church turning thesis

822
00:31:33,419 --> 00:31:35,460
which is that all real life attackers

823
00:31:35,460 --> 00:31:37,919
can be captured by PPT Turing machines

824
00:31:37,919 --> 00:31:40,440
okay and what this allows us to do

825
00:31:40,440 --> 00:31:42,120
classically is that we can write these

826
00:31:42,120 --> 00:31:44,580
black box reductions are that can query

827
00:31:44,580 --> 00:31:46,620
the original attacker a many many times

828
00:31:46,620 --> 00:31:48,600
for instance when doing this hardness

829
00:31:48,600 --> 00:31:50,279
amplification proof we might send a

830
00:31:50,279 --> 00:31:53,100
bunch of queries trying to invert some y

831
00:31:53,100 --> 00:31:55,080
so the takeaway here is that our Black

832
00:31:55,080 --> 00:31:57,000
Box reduction utilizes many independent

833
00:31:57,000 --> 00:32:00,120
copies of a currently and that this is

834
00:32:00,120 --> 00:32:02,760
Possible only because we Model A as an

835
00:32:02,760 --> 00:32:04,740
algorithm which can be copied and run

836
00:32:04,740 --> 00:32:07,200
again and this is an implicit assumption

837
00:32:07,200 --> 00:32:08,460
that we're making in a lot of our

838
00:32:08,460 --> 00:32:10,380
classical security groups

839
00:32:10,380 --> 00:32:13,679
in this talk we ask what if we can't run

840
00:32:13,679 --> 00:32:15,840
a many many times

841
00:32:15,840 --> 00:32:17,520
we're going to challenge this physical

842
00:32:17,520 --> 00:32:21,240
just turning thesis assumption maybe a

843
00:32:21,240 --> 00:32:23,460
is a next door neighbor Cody uh who

844
00:32:23,460 --> 00:32:25,080
happens to be able to break F Prime like

845
00:32:25,080 --> 00:32:26,760
maybe you can embed puzzles in like

846
00:32:26,760 --> 00:32:28,080
crossword puzzles or something I don't

847
00:32:28,080 --> 00:32:29,760
know uh but maybe you only have interact

848
00:32:29,760 --> 00:32:31,980
interactive access to coding okay you

849
00:32:31,980 --> 00:32:33,480
have to like cross the fence give him a

850
00:32:33,480 --> 00:32:35,220
puzzle and then he breaks it

851
00:32:35,220 --> 00:32:37,919
um you have no clue how Cody works uh

852
00:32:37,919 --> 00:32:40,080
you don't know like Cody's code like is

853
00:32:40,080 --> 00:32:42,419
the Mind dictated by code I don't know

854
00:32:42,419 --> 00:32:45,120
um you can't copy your neighbor uh you

855
00:32:45,120 --> 00:32:47,460
can't rewind your neighbor your neighbor

856
00:32:47,460 --> 00:32:48,960
might have access to like alien

857
00:32:48,960 --> 00:32:50,640
technology as far as they're concerned

858
00:32:50,640 --> 00:32:52,980
we need to revisit classical proofs

859
00:32:52,980 --> 00:32:55,200
right classical proofs will break down

860
00:32:55,200 --> 00:32:56,760
in this regime when we only have

861
00:32:56,760 --> 00:32:58,980
interactive access and looking forward

862
00:32:58,980 --> 00:33:01,080
even the simple Act of sending two

863
00:33:01,080 --> 00:33:02,880
queries or correlated queries to Cody

864
00:33:02,880 --> 00:33:05,580
will be problematic because Cody is

865
00:33:05,580 --> 00:33:07,860
stateful you can remember things you can

866
00:33:07,860 --> 00:33:09,840
say hey I only respond to the first

867
00:33:09,840 --> 00:33:12,480
query you send me or maybe I'll respond

868
00:33:12,480 --> 00:33:14,700
to correlated queries in a different way

869
00:33:14,700 --> 00:33:16,860
so looking forward we will have to

870
00:33:16,860 --> 00:33:19,019
assume that the adversary wins

871
00:33:19,019 --> 00:33:21,120
repeatedly when given fresh challenges

872
00:33:21,120 --> 00:33:23,039
from the security game this sounds like

873
00:33:23,039 --> 00:33:25,440
a very reasonable assumption to make but

874
00:33:25,440 --> 00:33:27,659
even this will be non-trivial to exploit

875
00:33:27,659 --> 00:33:29,700
as we'll see later

876
00:33:29,700 --> 00:33:32,159
okay but let's take a step back and

877
00:33:32,159 --> 00:33:34,260
argue that stateful attackers are

878
00:33:34,260 --> 00:33:36,659
already very well motivated in practice

879
00:33:36,659 --> 00:33:38,760
and in theory right quantum computers

880
00:33:38,760 --> 00:33:41,580
are stateful attackers because if you

881
00:33:41,580 --> 00:33:43,860
use qubits and do measurements the no

882
00:33:43,860 --> 00:33:45,480
cloning theorem says that we can't even

883
00:33:45,480 --> 00:33:47,279
copy Quantum advice

884
00:33:47,279 --> 00:33:49,500
um so we can't rewind quantum computers

885
00:33:49,500 --> 00:33:50,940
when we play these interactive security

886
00:33:50,940 --> 00:33:51,960
games

887
00:33:51,960 --> 00:33:54,840
and theoretically we would prefer a

888
00:33:54,840 --> 00:33:57,299
theory of cryptography that doesn't make

889
00:33:57,299 --> 00:33:59,760
this implicit territory hypothesis

890
00:33:59,760 --> 00:34:02,039
assumption like can we get by without

891
00:34:02,039 --> 00:34:04,200
assuming that the attackers we are

892
00:34:04,200 --> 00:34:06,179
dealing with are algorithmic and can be

893
00:34:06,179 --> 00:34:08,040
copied or restarted or rewinded in

894
00:34:08,040 --> 00:34:09,359
nature

895
00:34:09,359 --> 00:34:12,239
and in this talk we propose that the

896
00:34:12,239 --> 00:34:14,219
answer is yes we have hope that we can

897
00:34:14,219 --> 00:34:16,020
build a reduction based theory of

898
00:34:16,020 --> 00:34:18,540
cryptography uh that makes minimal

899
00:34:18,540 --> 00:34:20,520
assumptions on the nature of real life

900
00:34:20,520 --> 00:34:23,399
attackers and we hope you're on board

901
00:34:23,399 --> 00:34:26,040
okay next up we're going to define the

902
00:34:26,040 --> 00:34:27,659
framework we propose and then we'll see

903
00:34:27,659 --> 00:34:32,280
uh later uh whether it's useful okay

904
00:34:32,280 --> 00:34:33,899
let's Jump Right In

905
00:34:33,899 --> 00:34:36,540
so Universal reductions are going to

906
00:34:36,540 --> 00:34:38,820
center around what we call augmented

907
00:34:38,820 --> 00:34:40,800
adversaries this is our new model for

908
00:34:40,800 --> 00:34:43,139
what a real life attacker is it's just

909
00:34:43,139 --> 00:34:45,899
going to be a topple a comma T and sorry

910
00:34:45,899 --> 00:34:48,179
a common Nats and this Nat is some

911
00:34:48,179 --> 00:34:50,219
nature machine that corresponds to some

912
00:34:50,219 --> 00:34:52,440
unknown power in the cosmos to which we

913
00:34:52,440 --> 00:34:54,418
only only have interactive access right

914
00:34:54,418 --> 00:34:56,580
it might be unbounded we don't know what

915
00:34:56,580 --> 00:34:59,099
the choice of run time is a on the other

916
00:34:59,099 --> 00:35:00,599
hand is some classical attacker that

917
00:35:00,599 --> 00:35:03,000
uses nature to break some scheme okay

918
00:35:03,000 --> 00:35:05,099
and our augmented security game is now

919
00:35:05,099 --> 00:35:08,280
well C A and that so our Challenger C is

920
00:35:08,280 --> 00:35:09,900
going to be our security game it's PPT

921
00:35:09,900 --> 00:35:12,359
it's going to Output win or lose I'm

922
00:35:12,359 --> 00:35:14,280
going to observe that the attacker in

923
00:35:14,280 --> 00:35:16,500
this execution can alter the states of

924
00:35:16,500 --> 00:35:18,540
nature during the interaction and that

925
00:35:18,540 --> 00:35:20,460
this is very intentional on a key

926
00:35:20,460 --> 00:35:22,859
property and also note that in our model

927
00:35:22,859 --> 00:35:24,180
all the communication is going to be

928
00:35:24,180 --> 00:35:26,160
classical and CNA are going to be PPT

929
00:35:26,160 --> 00:35:28,500
machines because we want our Universal

930
00:35:28,500 --> 00:35:30,359
reductions to still work in a classical

931
00:35:30,359 --> 00:35:32,220
world okay

932
00:35:32,220 --> 00:35:34,800
and recall that we want a next-door

933
00:35:34,800 --> 00:35:37,020
neighbor who wins repeatedly on Fresh

934
00:35:37,020 --> 00:35:39,480
challenges so let's define this now we

935
00:35:39,480 --> 00:35:41,940
call this robust winning and to this end

936
00:35:41,940 --> 00:35:43,560
we Define what we call an interaction

937
00:35:43,560 --> 00:35:45,660
prefix which is just a transcript of

938
00:35:45,660 --> 00:35:47,160
messages and coins that nature

939
00:35:47,160 --> 00:35:50,160
previously saw okay that's all and we

940
00:35:50,160 --> 00:35:52,380
say that our augmented adversary a comma

941
00:35:52,380 --> 00:35:55,500
Nats has robust Advantage a if for all

942
00:35:55,500 --> 00:35:57,300
of these interaction prefixes no matter

943
00:35:57,300 --> 00:35:59,040
what it's on the past

944
00:35:59,040 --> 00:36:00,780
um the probability of wins a new

945
00:36:00,780 --> 00:36:03,000
resistance of our security game on Fresh

946
00:36:03,000 --> 00:36:06,480
coins is greater than or equal to a

947
00:36:06,480 --> 00:36:08,579
and robust winning to us seems like a

948
00:36:08,579 --> 00:36:11,160
very natural uh notion of winning uh and

949
00:36:11,160 --> 00:36:13,619
this is why we uh we we examine it in

950
00:36:13,619 --> 00:36:16,619
our in our paper okay so here's the main

951
00:36:16,619 --> 00:36:18,119
notion in our paper

952
00:36:18,119 --> 00:36:20,640
Universal reductions we're going to say

953
00:36:20,640 --> 00:36:22,560
there exists an Epsilon Universal

954
00:36:22,560 --> 00:36:25,260
reduction from two security from C to C

955
00:36:25,260 --> 00:36:28,980
Prime if for all PPT attackers a there

956
00:36:28,980 --> 00:36:31,740
exists a PPT attacker a prime such that

957
00:36:31,740 --> 00:36:33,480
for all natures

958
00:36:33,480 --> 00:36:36,240
suppose that a common nuts has robust

959
00:36:36,240 --> 00:36:39,480
Advantage a for the security game c so

960
00:36:39,480 --> 00:36:41,099
it kind of wins on demand whenever you

961
00:36:41,099 --> 00:36:43,200
send it an instance of c

962
00:36:43,200 --> 00:36:46,079
um then a prime common Nats has robust

963
00:36:46,079 --> 00:36:48,740
Advantage Epsilon for C Prime

964
00:36:48,740 --> 00:36:51,660
notice that it's the same that's the top

965
00:36:51,660 --> 00:36:54,359
and the bottom and that a prime can now

966
00:36:54,359 --> 00:36:56,160
use the fact that a comma not wins on

967
00:36:56,160 --> 00:36:58,800
demand and this is the central notion in

968
00:36:58,800 --> 00:37:00,619
our paper

969
00:37:00,619 --> 00:37:03,000
our Universal reduction is universal

970
00:37:03,000 --> 00:37:05,040
well certainly Universal reductions

971
00:37:05,040 --> 00:37:07,380
imply reductions with respect to PPT and

972
00:37:07,380 --> 00:37:09,540
qpt and hopefully this is not too hard

973
00:37:09,540 --> 00:37:10,680
to see

974
00:37:10,680 --> 00:37:13,020
okay so some quick comparisons relative

975
00:37:13,020 --> 00:37:15,300
wise reductions uh well relative size

976
00:37:15,300 --> 00:37:17,040
reductions give attackers Oracle access

977
00:37:17,040 --> 00:37:19,140
to some arbitrary Oracle uh if you're

978
00:37:19,140 --> 00:37:20,880
familiar so we can kind of view

979
00:37:20,880 --> 00:37:23,099
Universal reductions as relative wise

980
00:37:23,099 --> 00:37:24,540
reductions for staple interactive

981
00:37:24,540 --> 00:37:26,220
oracles okay as opposed to State less

982
00:37:26,220 --> 00:37:27,839
and non-interactive ones

983
00:37:27,839 --> 00:37:29,700
and let's talk about UC very quickly

984
00:37:29,700 --> 00:37:31,440
which seems very syntactically similar

985
00:37:31,440 --> 00:37:33,000
to our notion um we're just going to

986
00:37:33,000 --> 00:37:34,980
mention that this is some semantically

987
00:37:34,980 --> 00:37:37,500
very different because out of notion is

988
00:37:37,500 --> 00:37:40,079
reduction based and computational uh and

989
00:37:40,079 --> 00:37:41,579
for instance UC security proofs can

990
00:37:41,579 --> 00:37:43,500
rewind the environment

991
00:37:43,500 --> 00:37:44,820
um I I think they're a little bit

992
00:37:44,820 --> 00:37:46,200
incomparable but we can talk about it

993
00:37:46,200 --> 00:37:49,320
later but the main question I want to

994
00:37:49,320 --> 00:37:51,780
get to is this what can we do with

995
00:37:51,780 --> 00:37:54,240
universal reductions

996
00:37:54,240 --> 00:37:55,560
okay

997
00:37:55,560 --> 00:37:58,800
ready okay uh warm up a basic

998
00:37:58,800 --> 00:38:01,280
feasibility result

999
00:38:01,280 --> 00:38:03,420
single shot straight line Black Box

1000
00:38:03,420 --> 00:38:06,060
reductions imply Universal reductions

1001
00:38:06,060 --> 00:38:07,800
these are just classical reductions that

1002
00:38:07,800 --> 00:38:09,540
run the attacker ones

1003
00:38:09,540 --> 00:38:10,619
and hopefully it should be

1004
00:38:10,619 --> 00:38:12,599
straightforward to see that you know we

1005
00:38:12,599 --> 00:38:14,460
only need to use nature once so we can

1006
00:38:14,460 --> 00:38:15,839
just you know plug in the classical

1007
00:38:15,839 --> 00:38:17,220
reduction and we get a universal

1008
00:38:17,220 --> 00:38:19,260
reduction straight out of the box and as

1009
00:38:19,260 --> 00:38:22,380
correlates we get WWI prg length

1010
00:38:22,380 --> 00:38:25,140
extension prf's ske commitments from

1011
00:38:25,140 --> 00:38:29,520
prgs but not only functions so what

1012
00:38:29,520 --> 00:38:30,960
about problems that have classical

1013
00:38:30,960 --> 00:38:33,780
reductions that invoke the attacker many

1014
00:38:33,780 --> 00:38:35,820
many times like what we saw in the

1015
00:38:35,820 --> 00:38:36,859
beginning

1016
00:38:36,859 --> 00:38:39,540
and unfortunately the picture here is

1017
00:38:39,540 --> 00:38:41,520
less clear because not everything is

1018
00:38:41,520 --> 00:38:43,500
going to be possible we're going to

1019
00:38:43,500 --> 00:38:45,300
revisit two textbook proofs hardness

1020
00:38:45,300 --> 00:38:47,040
amplification and the go right 11

1021
00:38:47,040 --> 00:38:48,900
theorem and say that hey

1022
00:38:48,900 --> 00:38:50,220
let's just focus on hardness

1023
00:38:50,220 --> 00:38:52,260
amplification for now um we're going to

1024
00:38:52,260 --> 00:38:53,400
say that hey

1025
00:38:53,400 --> 00:38:55,980
it's impossible to write a universal

1026
00:38:55,980 --> 00:38:58,680
reduction uh for the runway function

1027
00:38:58,680 --> 00:39:01,619
security of the uh block sorry of the

1028
00:39:01,619 --> 00:39:03,839
direct product construction to the

1029
00:39:03,839 --> 00:39:06,300
runway function security of G of X that

1030
00:39:06,300 --> 00:39:09,180
uses only black box access to the runway

1031
00:39:09,180 --> 00:39:11,520
function uh in question and that works

1032
00:39:11,520 --> 00:39:14,359
for any such function

1033
00:39:14,700 --> 00:39:16,440
um so basically some sort of harness

1034
00:39:16,440 --> 00:39:18,180
amplification style theorem is going to

1035
00:39:18,180 --> 00:39:20,760
be impossible if the reduction is

1036
00:39:20,760 --> 00:39:22,380
agnostic about how the function actually

1037
00:39:22,380 --> 00:39:24,000
works

1038
00:39:24,000 --> 00:39:25,800
so let's go over the intuition of this

1039
00:39:25,800 --> 00:39:27,839
proof to kind of understand Universal

1040
00:39:27,839 --> 00:39:29,280
reductions better

1041
00:39:29,280 --> 00:39:31,920
okay so we recall that like in the

1042
00:39:31,920 --> 00:39:34,020
classical proof and yells proof like you

1043
00:39:34,020 --> 00:39:35,940
let G be a weak wallowing function we

1044
00:39:35,940 --> 00:39:37,859
want to argue that this G to the N this

1045
00:39:37,859 --> 00:39:39,660
direct product is a strong wave function

1046
00:39:39,660 --> 00:39:41,520
so assume for the sake of contradiction

1047
00:39:41,520 --> 00:39:44,040
G to the N is not a strong wave of

1048
00:39:44,040 --> 00:39:46,800
function then we have some attacker that

1049
00:39:46,800 --> 00:39:48,359
inverts it with some noticeable

1050
00:39:48,359 --> 00:39:49,560
probability

1051
00:39:49,560 --> 00:39:51,480
okay and we're going to use this

1052
00:39:51,480 --> 00:39:54,000
attacker many many times uh saying we

1053
00:39:54,000 --> 00:39:56,339
want to invert some y equals g of X some

1054
00:39:56,339 --> 00:39:58,440
weak one-way function image we're going

1055
00:39:58,440 --> 00:40:00,359
to send many queries with the same y

1056
00:40:00,359 --> 00:40:02,700
embedded in random locations over and

1057
00:40:02,700 --> 00:40:04,200
over and over again and hopefully by

1058
00:40:04,200 --> 00:40:06,480
doing this and getting many responses we

1059
00:40:06,480 --> 00:40:08,220
can amplify the wind probability of the

1060
00:40:08,220 --> 00:40:10,079
original attacker

1061
00:40:10,079 --> 00:40:12,480
now can we write a universal reduction

1062
00:40:12,480 --> 00:40:14,640
in this setting

1063
00:40:14,640 --> 00:40:17,520
well I claim that problems are going to

1064
00:40:17,520 --> 00:40:19,560
happen right so instead of a classical

1065
00:40:19,560 --> 00:40:21,660
attacker that wins on our strong wave

1066
00:40:21,660 --> 00:40:23,940
function now we get a augmented

1067
00:40:23,940 --> 00:40:26,520
adversary that robustly wins with some

1068
00:40:26,520 --> 00:40:28,020
small probability

1069
00:40:28,020 --> 00:40:31,320
but now consider the following augmented

1070
00:40:31,320 --> 00:40:32,700
adversary

1071
00:40:32,700 --> 00:40:34,800
so aim's just going to forward messages

1072
00:40:34,800 --> 00:40:36,900
to not and what Nat is going to do is

1073
00:40:36,900 --> 00:40:39,359
it's going to keep a list of sub queries

1074
00:40:39,359 --> 00:40:41,760
why that it's previously seen

1075
00:40:41,760 --> 00:40:44,040
and as soon as it sees the same Y the

1076
00:40:44,040 --> 00:40:46,140
second time it's just going to say hey I

1077
00:40:46,140 --> 00:40:48,420
reject your query I sing your query

1078
00:40:48,420 --> 00:40:50,280
before

1079
00:40:50,280 --> 00:40:51,960
I claim that this is going to be a

1080
00:40:51,960 --> 00:40:53,520
problem and the intuition is that

1081
00:40:53,520 --> 00:40:56,520
because nature is now stateful if it

1082
00:40:56,520 --> 00:40:58,800
previously saw y it can just reject

1083
00:40:58,800 --> 00:41:01,680
future correlated queries that contain y

1084
00:41:01,680 --> 00:41:04,020
so only the first query in Yale's

1085
00:41:04,020 --> 00:41:05,940
reduction will be useful and we have no

1086
00:41:05,940 --> 00:41:08,640
hope of amplifying the win probability

1087
00:41:08,640 --> 00:41:12,420
okay observe that this uh adversary is

1088
00:41:12,420 --> 00:41:13,859
still robustly winning

1089
00:41:13,859 --> 00:41:16,140
because our only constraints the only

1090
00:41:16,140 --> 00:41:18,060
thing we get is that it wins on a fresh

1091
00:41:18,060 --> 00:41:20,339
Challenge and the probability a fresh

1092
00:41:20,339 --> 00:41:22,200
challenge coincides with a set of string

1093
00:41:22,200 --> 00:41:25,140
scene strains is going to be tiny

1094
00:41:25,140 --> 00:41:27,420
okay and in the full proof we show that

1095
00:41:27,420 --> 00:41:30,240
any reduction not just the owls

1096
00:41:30,240 --> 00:41:33,480
that uses G in this black box way we'll

1097
00:41:33,480 --> 00:41:34,920
have to send some sort of correlated

1098
00:41:34,920 --> 00:41:38,220
queries to a common map and that uh this

1099
00:41:38,220 --> 00:41:39,780
is similarly broken and this is a

1100
00:41:39,780 --> 00:41:41,700
non-trivial proof but I'll leave it uh

1101
00:41:41,700 --> 00:41:44,660
for future uh it's for the paper okay

1102
00:41:44,660 --> 00:41:47,760
but the question is hey is this Black

1103
00:41:47,760 --> 00:41:50,520
Box G uh in G is that inherence

1104
00:41:50,520 --> 00:41:52,859
um and the answer is yes because we can

1105
00:41:52,859 --> 00:41:55,140
in fact do hardness amplification in our

1106
00:41:55,140 --> 00:41:57,780
Universal framework for specific Runway

1107
00:41:57,780 --> 00:42:01,140
functions right in fact if your only

1108
00:42:01,140 --> 00:42:03,060
function is re-randomizable then what do

1109
00:42:03,060 --> 00:42:04,920
I mean by that well basically you can

1110
00:42:04,920 --> 00:42:07,260
take some image and re-randomize it to

1111
00:42:07,260 --> 00:42:09,540
look like a fresh image but still have I

1112
00:42:09,540 --> 00:42:12,180
mean you can rederive the same solution

1113
00:42:12,180 --> 00:42:13,680
um we say that hey if f is

1114
00:42:13,680 --> 00:42:16,320
re-randomizable then we can do hardness

1115
00:42:16,320 --> 00:42:17,760
amplification using the direct product

1116
00:42:17,760 --> 00:42:19,560
construction and

1117
00:42:19,560 --> 00:42:22,140
for intuition uh this is because we can

1118
00:42:22,140 --> 00:42:23,700
kind of fool nature into thinking it's

1119
00:42:23,700 --> 00:42:25,320
playing Fresh instances of our security

1120
00:42:25,320 --> 00:42:26,460
game

1121
00:42:26,460 --> 00:42:28,920
okay so writing Universal reductions

1122
00:42:28,920 --> 00:42:31,079
requires new techniques it's kind of

1123
00:42:31,079 --> 00:42:33,960
hard this is all we got so let's try to

1124
00:42:33,960 --> 00:42:35,579
climb a different Mountain for now to

1125
00:42:35,579 --> 00:42:38,339
have some results you know so I think uh

1126
00:42:38,339 --> 00:42:40,500
I'm a little short on time but briefly

1127
00:42:40,500 --> 00:42:42,839
that is considered a setting where hey

1128
00:42:42,839 --> 00:42:45,780
can we get non-trivial results by

1129
00:42:45,780 --> 00:42:49,260
imposing restrictions on nature

1130
00:42:49,260 --> 00:42:51,599
maybe presumptuous to think that nature

1131
00:42:51,599 --> 00:42:53,339
actually cares about what happens in

1132
00:42:53,339 --> 00:42:55,560
previous security games right maybe I

1133
00:42:55,560 --> 00:42:57,859
don't know we're tiny like I don't know

1134
00:42:57,859 --> 00:43:00,540
maybe these Cosmic adversaries just

1135
00:43:00,540 --> 00:43:01,800
don't care you know

1136
00:43:01,800 --> 00:43:03,599
um maybe it just evolves over time over

1137
00:43:03,599 --> 00:43:05,700
the number of queries it's received but

1138
00:43:05,700 --> 00:43:07,260
has a short-term memory and behaves

1139
00:43:07,260 --> 00:43:10,220
independently of Prior interactions

1140
00:43:10,220 --> 00:43:12,540
I don't know I hope this sounds

1141
00:43:12,540 --> 00:43:15,000
reasonable so maybe we can think of this

1142
00:43:15,000 --> 00:43:17,760
uh augmented adversary as a sequence of

1143
00:43:17,760 --> 00:43:21,540
attackers A1 A2 A3 right same sequence

1144
00:43:21,540 --> 00:43:23,520
of attackers uh each subsequent one

1145
00:43:23,520 --> 00:43:26,220
doesn't depend on a previous outcome

1146
00:43:26,220 --> 00:43:28,380
um but it evolves over time and the

1147
00:43:28,380 --> 00:43:30,780
question is can we uh do anything in

1148
00:43:30,780 --> 00:43:33,060
this setting and our theorem says that

1149
00:43:33,060 --> 00:43:35,099
hey if you have a classical non-adaptive

1150
00:43:35,099 --> 00:43:37,319
reduction

1151
00:43:37,319 --> 00:43:39,599
um then indeed it does give us Universal

1152
00:43:39,599 --> 00:43:41,099
reductions with respect to these time

1153
00:43:41,099 --> 00:43:42,660
evolving natures

1154
00:43:42,660 --> 00:43:45,180
okay and

1155
00:43:45,180 --> 00:43:47,040
I'm going to briefly describe what's

1156
00:43:47,040 --> 00:43:48,540
going on so on the left side you have a

1157
00:43:48,540 --> 00:43:50,099
classical non-adaptive reduction it

1158
00:43:50,099 --> 00:43:52,500
sends queries q1 through Q5 and because

1159
00:43:52,500 --> 00:43:53,880
it's non-adaptive the order doesn't

1160
00:43:53,880 --> 00:43:55,800
matter now on the right side we have a

1161
00:43:55,800 --> 00:43:57,359
sequence of attackers that we have to

1162
00:43:57,359 --> 00:43:58,619
query in order

1163
00:43:58,619 --> 00:44:00,240
that we want to make work in this

1164
00:44:00,240 --> 00:44:02,160
classical setting and the question is

1165
00:44:02,160 --> 00:44:04,740
how do we emulate a classical attacker a

1166
00:44:04,740 --> 00:44:06,240
star in the view of our classical

1167
00:44:06,240 --> 00:44:10,440
reduction using our augmented adversary

1168
00:44:10,440 --> 00:44:12,240
and I claim that this is pretty

1169
00:44:12,240 --> 00:44:13,980
straightforward you just send each query

1170
00:44:13,980 --> 00:44:16,920
to a random a sub I and even though we

1171
00:44:16,920 --> 00:44:19,319
have to query these a sub I in order it

1172
00:44:19,319 --> 00:44:21,119
doesn't matter because our non-adaptive

1173
00:44:21,119 --> 00:44:22,560
production doesn't depend on the order

1174
00:44:22,560 --> 00:44:24,420
of queries

1175
00:44:24,420 --> 00:44:25,380
um of course they might get some

1176
00:44:25,380 --> 00:44:26,819
collisions so we have to make the

1177
00:44:26,819 --> 00:44:29,579
sequence of attackers really large

1178
00:44:29,579 --> 00:44:30,900
but

1179
00:44:30,900 --> 00:44:32,700
generally I just want to say hey it's

1180
00:44:32,700 --> 00:44:34,440
rather surprising that we can deal with

1181
00:44:34,440 --> 00:44:36,119
these stateful Natures that evolve over

1182
00:44:36,119 --> 00:44:37,140
time

1183
00:44:37,140 --> 00:44:39,240
uh even classically

1184
00:44:39,240 --> 00:44:42,599
okay so time's up in conclusion there's

1185
00:44:42,599 --> 00:44:44,099
a lot to unpack

1186
00:44:44,099 --> 00:44:45,960
but the takeaway for you is that we can

1187
00:44:45,960 --> 00:44:47,819
write meaningful security proofs with

1188
00:44:47,819 --> 00:44:50,760
respect to staple attackers and at the

1189
00:44:50,760 --> 00:44:52,740
same time new techniques are clearly

1190
00:44:52,740 --> 00:44:54,540
necessary we don't know how to do prgs

1191
00:44:54,540 --> 00:44:56,579
from only functions or MPC

1192
00:44:56,579 --> 00:44:58,980
but we do have hope uh for a

1193
00:44:58,980 --> 00:45:01,200
future-proof notion of cryptography and

1194
00:45:01,200 --> 00:45:05,118
I hope uh you do too thank you

1195
00:45:08,640 --> 00:45:10,740
uh let's start getting the next speaker

1196
00:45:10,740 --> 00:45:12,300
set up in the meantime are there any

1197
00:45:12,300 --> 00:45:14,220
questions

1198
00:45:14,220 --> 00:45:16,700
thanks

1199
00:45:18,420 --> 00:45:20,460
hi there so are we considered what

1200
00:45:20,460 --> 00:45:22,980
happened when you start from Primitives

1201
00:45:22,980 --> 00:45:25,140
that are for example secure against the

1202
00:45:25,140 --> 00:45:27,000
Quasi polynomial time adversaries or

1203
00:45:27,000 --> 00:45:30,540
sub-exponential time adversaries and try

1204
00:45:30,540 --> 00:45:31,920
to construct the Primitive that is only

1205
00:45:31,920 --> 00:45:33,119
secure against

1206
00:45:33,119 --> 00:45:36,720
I mean this type of adversity

1207
00:45:36,720 --> 00:45:39,660
would that make uh I'm not so much the

1208
00:45:39,660 --> 00:45:41,220
running time of the attackers that we

1209
00:45:41,220 --> 00:45:42,359
were I don't know it depends on the

1210
00:45:42,359 --> 00:45:43,619
reductions and I'm not super familiar

1211
00:45:43,619 --> 00:45:45,359
with reductions for these exponential

1212
00:45:45,359 --> 00:45:47,579
time mappers areas for instance

1213
00:45:47,579 --> 00:45:51,200
um okay cheers

1214
00:45:54,900 --> 00:45:58,280
all right let's take this occur again

1215
00:46:02,520 --> 00:46:05,520
foreign

1216
00:46:30,980 --> 00:46:33,660
talking us about talking to us about

1217
00:46:33,660 --> 00:46:36,180
Beyond Uber instantiating generic groups

1218
00:46:36,180 --> 00:46:38,000
via pggs

1219
00:46:38,000 --> 00:46:40,560
yeah this works um thank you very much

1220
00:46:40,560 --> 00:46:41,940
for the introduction

1221
00:46:41,940 --> 00:46:43,319
um thank you all for staying till the

1222
00:46:43,319 --> 00:46:44,339
very end

1223
00:46:44,339 --> 00:46:46,800
so um I'm going to be talking about a

1224
00:46:46,800 --> 00:46:48,359
new definitional framework for

1225
00:46:48,359 --> 00:46:50,160
assumptions on groups uh called

1226
00:46:50,160 --> 00:46:53,400
pseudogeneric groups or pggs for short

1227
00:46:53,400 --> 00:46:55,260
which allows to instantiate generic

1228
00:46:55,260 --> 00:46:56,940
groups in a fairly broad range of

1229
00:46:56,940 --> 00:46:59,220
applications and this is Joint work with

1230
00:46:59,220 --> 00:47:01,859
baltazab work we have arshim and Adam

1231
00:47:01,859 --> 00:47:04,079
O'Neill

1232
00:47:04,079 --> 00:47:06,900
so um the starting point of this work is

1233
00:47:06,900 --> 00:47:09,300
the observation that very often

1234
00:47:09,300 --> 00:47:11,280
cryptographic schemes with some sort of

1235
00:47:11,280 --> 00:47:13,319
security guarantee are designed in a

1236
00:47:13,319 --> 00:47:16,200
two-step process so the first step you

1237
00:47:16,200 --> 00:47:18,180
design and improve security of the

1238
00:47:18,180 --> 00:47:20,760
scheme in an idealized model where some

1239
00:47:20,760 --> 00:47:22,440
component of the scheme is taken to be

1240
00:47:22,440 --> 00:47:23,460
random

1241
00:47:23,460 --> 00:47:25,680
and then later on when the scheme is to

1242
00:47:25,680 --> 00:47:27,900
be deployed in practice you replace the

1243
00:47:27,900 --> 00:47:29,579
random component with a public and

1244
00:47:29,579 --> 00:47:32,940
efficiently computable instantiation

1245
00:47:32,940 --> 00:47:35,280
um although very attractive powerful and

1246
00:47:35,280 --> 00:47:37,200
popular unfortunately we know that this

1247
00:47:37,200 --> 00:47:39,599
Paradigm is not sound in general

1248
00:47:39,599 --> 00:47:41,640
um which means which motivates the

1249
00:47:41,640 --> 00:47:43,800
question of finding assumptions on these

1250
00:47:43,800 --> 00:47:45,960
building blocks which at the same time

1251
00:47:45,960 --> 00:47:47,940
can be satisfied by the real world

1252
00:47:47,940 --> 00:47:49,560
candidates that we have

1253
00:47:49,560 --> 00:47:52,260
and which allow to prove interesting

1254
00:47:52,260 --> 00:47:54,140
applications and this will sort of be

1255
00:47:54,140 --> 00:47:57,660
the backdrop question for this talk

1256
00:47:57,660 --> 00:48:00,000
now um if you have a look at the

1257
00:48:00,000 --> 00:48:02,099
landscape of assumptions that we make

1258
00:48:02,099 --> 00:48:03,960
about this building blocks these very

1259
00:48:03,960 --> 00:48:05,220
much depend on the building blocks

1260
00:48:05,220 --> 00:48:06,960
themselves so let me quickly run for a

1261
00:48:06,960 --> 00:48:08,819
few examples

1262
00:48:08,819 --> 00:48:10,560
um the one component that is probably

1263
00:48:10,560 --> 00:48:12,900
best understood in this regard is Hash

1264
00:48:12,900 --> 00:48:14,579
functions so on one side we have the

1265
00:48:14,579 --> 00:48:16,020
idevice model which is the random Market

1266
00:48:16,020 --> 00:48:19,200
model but over time there's plenty of

1267
00:48:19,200 --> 00:48:21,300
assumptions that have emerged which we

1268
00:48:21,300 --> 00:48:23,819
think can be satisfied by the by our

1269
00:48:23,819 --> 00:48:25,560
concrete hash functions that we have and

1270
00:48:25,560 --> 00:48:26,819
I've turned out to be useful in

1271
00:48:26,819 --> 00:48:29,300
improving interesting applications

1272
00:48:29,300 --> 00:48:33,180
so another example is permutations

1273
00:48:33,180 --> 00:48:35,819
um up until not too long ago we had no

1274
00:48:35,819 --> 00:48:38,400
assumptions on permutations so groups

1275
00:48:38,400 --> 00:48:40,260
would automatically be carried out in

1276
00:48:40,260 --> 00:48:42,540
the random permutation model until the

1277
00:48:42,540 --> 00:48:45,240
work of Sony and tesaro adopted the uce

1278
00:48:45,240 --> 00:48:46,980
notion of security for hash functions to

1279
00:48:46,980 --> 00:48:49,440
the case of permutations

1280
00:48:49,440 --> 00:48:52,140
now for the case of groups the situation

1281
00:48:52,140 --> 00:48:54,540
is again a bit different so we have a

1282
00:48:54,540 --> 00:48:56,940
lot of uh well-known assumptions that we

1283
00:48:56,940 --> 00:48:59,040
know and love there's also some

1284
00:48:59,040 --> 00:49:00,960
generalizations thereof here I'm

1285
00:49:00,960 --> 00:49:02,700
thinking about the Uber assumption which

1286
00:49:02,700 --> 00:49:04,079
speaks to the indistinguishability

1287
00:49:04,079 --> 00:49:05,099
between

1288
00:49:05,099 --> 00:49:07,560
um a random group element and one that

1289
00:49:07,560 --> 00:49:10,319
has a polynomial induced exponent but we

1290
00:49:10,319 --> 00:49:12,420
claim that even this generalization is

1291
00:49:12,420 --> 00:49:14,760
insufficient when you want to prove

1292
00:49:14,760 --> 00:49:16,859
security of certain applications notably

1293
00:49:16,859 --> 00:49:19,020
think of those where

1294
00:49:19,020 --> 00:49:21,540
um group exponents might not be

1295
00:49:21,540 --> 00:49:23,700
uniformly random or polynomially

1296
00:49:23,700 --> 00:49:26,099
correlated but um just simply High

1297
00:49:26,099 --> 00:49:28,560
entropy but in that case even the Uber

1298
00:49:28,560 --> 00:49:30,540
assumption falls short of of providing

1299
00:49:30,540 --> 00:49:33,240
the means to improve security to prove

1300
00:49:33,240 --> 00:49:35,099
security of the applications

1301
00:49:35,099 --> 00:49:37,740
so the goal of this work is to um to

1302
00:49:37,740 --> 00:49:39,420
address this issue

1303
00:49:39,420 --> 00:49:42,839
and given the success that the uce style

1304
00:49:42,839 --> 00:49:45,420
of defining security has had in the case

1305
00:49:45,420 --> 00:49:47,220
of hash functions and permutations our

1306
00:49:47,220 --> 00:49:50,040
approach was to take this Paradigm and

1307
00:49:50,040 --> 00:49:51,900
to try and adapt it to the setting of

1308
00:49:51,900 --> 00:49:54,000
groups

1309
00:49:54,000 --> 00:49:55,260
um so I plan for the next couple of

1310
00:49:55,260 --> 00:49:57,720
slides is to briefly recall what uces

1311
00:49:57,720 --> 00:49:59,579
are and then show you how one can do

1312
00:49:59,579 --> 00:50:02,220
this adaptation

1313
00:50:02,220 --> 00:50:05,339
so um UC security is a security notion

1314
00:50:05,339 --> 00:50:07,260
for hash functions introduced by bilara

1315
00:50:07,260 --> 00:50:09,839
Hong and kelvedi and the starting point

1316
00:50:09,839 --> 00:50:12,960
for defining uces is prf security so you

1317
00:50:12,960 --> 00:50:15,420
see here the games the classical game

1318
00:50:15,420 --> 00:50:17,880
um on the left so a distinguisher should

1319
00:50:17,880 --> 00:50:19,260
not be able to distinguish between two

1320
00:50:19,260 --> 00:50:21,359
worlds on the left sample a random hash

1321
00:50:21,359 --> 00:50:22,980
key and then answer Oracle queries with

1322
00:50:22,980 --> 00:50:25,440
hash evaluations on the right Ideal

1323
00:50:25,440 --> 00:50:27,900
World pick a random function and answer

1324
00:50:27,900 --> 00:50:31,560
queries with random function evaluations

1325
00:50:31,560 --> 00:50:34,020
now when you try to apply this security

1326
00:50:34,020 --> 00:50:36,000
notion to Hash functions you run into a

1327
00:50:36,000 --> 00:50:38,460
problem which is that prf security

1328
00:50:38,460 --> 00:50:40,619
immediately breaks down if the seed

1329
00:50:40,619 --> 00:50:41,819
which here is the hash key is made

1330
00:50:41,819 --> 00:50:43,980
public and the problem is precisely that

1331
00:50:43,980 --> 00:50:45,540
in hash function applications the hash

1332
00:50:45,540 --> 00:50:47,579
key is public

1333
00:50:47,579 --> 00:50:51,540
so the inside of bhk was to split the

1334
00:50:51,540 --> 00:50:54,119
distinguisher into two parts

1335
00:50:54,119 --> 00:50:56,280
um the algorithm here at the top which

1336
00:50:56,280 --> 00:50:58,020
is called source and the distinguisher

1337
00:50:58,020 --> 00:50:59,160
at the bottom

1338
00:50:59,160 --> 00:51:01,680
so Source still plays the prf security

1339
00:51:01,680 --> 00:51:03,960
game so it has access to one of two

1340
00:51:03,960 --> 00:51:05,760
oracles but no hash key

1341
00:51:05,760 --> 00:51:07,859
then can pass some leakage onto the

1342
00:51:07,859 --> 00:51:09,720
distinguisher who gets the leakage the

1343
00:51:09,720 --> 00:51:12,359
hash key but no Oracle and must decide

1344
00:51:12,359 --> 00:51:14,940
which world the two are playing in

1345
00:51:14,940 --> 00:51:16,440
now you might think that the natural

1346
00:51:16,440 --> 00:51:19,200
requirement would be to ask for this to

1347
00:51:19,200 --> 00:51:20,819
hold for every Source distinguisher pair

1348
00:51:20,819 --> 00:51:22,500
but you see right away that that's

1349
00:51:22,500 --> 00:51:24,599
that's a bit too strong

1350
00:51:24,599 --> 00:51:27,000
um so for example The Source could just

1351
00:51:27,000 --> 00:51:29,160
query any fixed x to the Oracle get

1352
00:51:29,160 --> 00:51:31,740
answer Y and then leak the pair XY to

1353
00:51:31,740 --> 00:51:33,300
the distinguisher who then has the hash

1354
00:51:33,300 --> 00:51:35,040
key and then can perform this check here

1355
00:51:35,040 --> 00:51:36,420
on the right so it can distinguish right

1356
00:51:36,420 --> 00:51:38,400
away

1357
00:51:38,400 --> 00:51:40,079
um bhk suggests various way around

1358
00:51:40,079 --> 00:51:42,300
various ways ways around this problem so

1359
00:51:42,300 --> 00:51:43,940
for the purpose of this talk I'm gonna

1360
00:51:43,940 --> 00:51:46,260
focus on a notion that's called

1361
00:51:46,260 --> 00:51:48,599
statistical algebraic contradictability

1362
00:51:48,599 --> 00:51:50,220
which is the game here to the right

1363
00:51:50,220 --> 00:51:53,520
which essentially says that no unbounded

1364
00:51:53,520 --> 00:51:56,339
predictor should be able to guess

1365
00:51:56,339 --> 00:51:58,140
um any of the sources queries giving

1366
00:51:58,140 --> 00:52:00,480
leakage when the source interacts with

1367
00:52:00,480 --> 00:52:03,240
with the ideal Oracle

1368
00:52:03,240 --> 00:52:06,000
okay so this is uce now let me show you

1369
00:52:06,000 --> 00:52:08,640
how you can Port this definition to the

1370
00:52:08,640 --> 00:52:10,200
setting of groups and let's start with

1371
00:52:10,200 --> 00:52:12,059
the game to the left which is again the

1372
00:52:12,059 --> 00:52:15,300
game here okay so um we replace hash

1373
00:52:15,300 --> 00:52:18,480
parameters with group parameters

1374
00:52:18,480 --> 00:52:19,980
um group parameters in in our

1375
00:52:19,980 --> 00:52:21,960
formalization are just a description of

1376
00:52:21,960 --> 00:52:22,920
the

1377
00:52:22,920 --> 00:52:25,440
of the group operation a fixed group

1378
00:52:25,440 --> 00:52:27,720
generator and the group order

1379
00:52:27,720 --> 00:52:31,200
now um hash key generation is replaced

1380
00:52:31,200 --> 00:52:33,720
with a re-randomization of of the group

1381
00:52:33,720 --> 00:52:35,940
generator so um

1382
00:52:35,940 --> 00:52:39,599
the equivalent of the hash key is a new

1383
00:52:39,599 --> 00:52:41,339
random group generator which you see

1384
00:52:41,339 --> 00:52:43,380
also here is given in place of the hash

1385
00:52:43,380 --> 00:52:45,420
key to the distinguisher

1386
00:52:45,420 --> 00:52:47,339
and then in the real world

1387
00:52:47,339 --> 00:52:49,980
um we replace the hashing Oracle with

1388
00:52:49,980 --> 00:52:51,780
exponentiation with respect to this

1389
00:52:51,780 --> 00:52:53,819
unknown group generator

1390
00:52:53,819 --> 00:52:56,220
now to the ideal World well um the

1391
00:52:56,220 --> 00:52:58,559
analog of group exponentiation in the

1392
00:52:58,559 --> 00:53:01,800
ideal world is just a a random injection

1393
00:53:01,800 --> 00:53:04,500
from that ptg so so we'll use that in

1394
00:53:04,500 --> 00:53:07,200
place of a random function

1395
00:53:07,200 --> 00:53:09,839
so these are already the changes to the

1396
00:53:09,839 --> 00:53:11,880
uce game the game we end up with we call

1397
00:53:11,880 --> 00:53:13,559
the the PGG game

1398
00:53:13,559 --> 00:53:15,300
the question now is

1399
00:53:15,300 --> 00:53:16,920
um what's the right notion of of

1400
00:53:16,920 --> 00:53:18,359
unpredictability

1401
00:53:18,359 --> 00:53:19,859
now of course the source must be

1402
00:53:19,859 --> 00:53:21,420
statistically unpredictable again

1403
00:53:21,420 --> 00:53:23,040
because otherwise you can mount the same

1404
00:53:23,040 --> 00:53:25,380
attack as for UC sources but we claim

1405
00:53:25,380 --> 00:53:27,420
that that's not enough because there's

1406
00:53:27,420 --> 00:53:28,859
additional structure here that wasn't

1407
00:53:28,859 --> 00:53:31,079
present in the case of hash functions

1408
00:53:31,079 --> 00:53:32,460
and permutations

1409
00:53:32,460 --> 00:53:34,079
so let me give you an example of an

1410
00:53:34,079 --> 00:53:34,920
attack

1411
00:53:34,920 --> 00:53:36,720
um suppose

1412
00:53:36,720 --> 00:53:39,540
um Source uh picks X1 X2 at random and

1413
00:53:39,540 --> 00:53:43,020
then queries X1 X2 and X1 plus X2

1414
00:53:43,020 --> 00:53:46,319
it gets these three elements as uh as

1415
00:53:46,319 --> 00:53:48,000
Oracle replies

1416
00:53:48,000 --> 00:53:50,220
and then I claim that already The Source

1417
00:53:50,220 --> 00:53:52,920
can can figure out which word it's

1418
00:53:52,920 --> 00:53:55,200
playing in but just performing this

1419
00:53:55,200 --> 00:53:57,240
check over here and you see that if the

1420
00:53:57,240 --> 00:53:58,859
source is playing in in the in the real

1421
00:53:58,859 --> 00:54:00,480
world well this will always check out

1422
00:54:00,480 --> 00:54:03,000
and in the ideal world this album works

1423
00:54:03,000 --> 00:54:04,980
so the source just passes this one bit

1424
00:54:04,980 --> 00:54:07,559
of leakage to the extinguisher and of

1425
00:54:07,559 --> 00:54:08,520
course the three queries are

1426
00:54:08,520 --> 00:54:10,079
unpredictable because you cannot predict

1427
00:54:10,079 --> 00:54:13,140
a random number based on only one bit

1428
00:54:13,140 --> 00:54:14,880
so this is an attack that that wasn't

1429
00:54:14,880 --> 00:54:19,859
there in the case of UCS and psprps

1430
00:54:19,859 --> 00:54:21,839
um because those Primitives don't have

1431
00:54:21,839 --> 00:54:24,859
any like homomorphic property which this

1432
00:54:24,859 --> 00:54:27,660
Oracle here has

1433
00:54:27,660 --> 00:54:29,940
So to avoid this attack we suggest to

1434
00:54:29,940 --> 00:54:31,680
extend the notion of unpredictability

1435
00:54:31,680 --> 00:54:35,160
and we call our extension um algebraic

1436
00:54:35,160 --> 00:54:36,680
unpredictability

1437
00:54:36,680 --> 00:54:39,540
what we do is we require that no

1438
00:54:39,540 --> 00:54:41,760
predictor be able not to guess even a

1439
00:54:41,760 --> 00:54:43,619
linear combination of the queries made

1440
00:54:43,619 --> 00:54:47,099
by the adversary so not only it should

1441
00:54:47,099 --> 00:54:49,380
not only not be able to guess any single

1442
00:54:49,380 --> 00:54:51,780
query but not even a linear combination

1443
00:54:51,780 --> 00:54:54,200
thereof

1444
00:54:54,480 --> 00:54:55,740
um now it turns out that even this

1445
00:54:55,740 --> 00:54:57,480
restriction unfortunately is is not

1446
00:54:57,480 --> 00:54:59,280
enough and there's two attacks to take

1447
00:54:59,280 --> 00:55:00,599
care of

1448
00:55:00,599 --> 00:55:01,920
um in interest of time I'm going to skip

1449
00:55:01,920 --> 00:55:03,480
the details but let me just tell you

1450
00:55:03,480 --> 00:55:05,640
that we address these issues by um

1451
00:55:05,640 --> 00:55:07,800
imposing a syntactic restriction on the

1452
00:55:07,800 --> 00:55:10,440
source so sources can still be unbounded

1453
00:55:10,440 --> 00:55:13,800
but we require them to be non-adaptive

1454
00:55:13,800 --> 00:55:15,240
so they must declare

1455
00:55:15,240 --> 00:55:16,920
all the queries they want to make first

1456
00:55:16,920 --> 00:55:19,819
and then have only very limited

1457
00:55:19,819 --> 00:55:22,880
post-processing on the outputs

1458
00:55:22,880 --> 00:55:26,700
okay so this is the PGG notion

1459
00:55:26,700 --> 00:55:29,280
um now whenever you define a framework

1460
00:55:29,280 --> 00:55:31,200
like this there's at least two questions

1461
00:55:31,200 --> 00:55:33,599
that one needs to take care of uh the

1462
00:55:33,599 --> 00:55:36,359
first one is do pggs actually exist and

1463
00:55:36,359 --> 00:55:38,460
if they do wonder what assumptions

1464
00:55:38,460 --> 00:55:40,559
and then the second would be um well

1465
00:55:40,559 --> 00:55:42,420
what interesting applications does the

1466
00:55:42,420 --> 00:55:44,520
new framework enable

1467
00:55:44,520 --> 00:55:47,760
so for the first question we show that a

1468
00:55:47,760 --> 00:55:51,359
generic group satisfies this notion

1469
00:55:51,359 --> 00:55:53,640
um I can't get into too many details

1470
00:55:53,640 --> 00:55:55,260
here but I would like to highlight the

1471
00:55:55,260 --> 00:55:56,760
two important parts

1472
00:55:56,760 --> 00:55:59,280
so one concern is the modeling of

1473
00:55:59,280 --> 00:56:01,680
sources so in in our treatment sources

1474
00:56:01,680 --> 00:56:04,140
can be unbounded which means that the

1475
00:56:04,140 --> 00:56:06,180
right way of modeling them in the ggm is

1476
00:56:06,180 --> 00:56:07,680
to give them

1477
00:56:07,680 --> 00:56:09,240
full access to the generic group

1478
00:56:09,240 --> 00:56:11,460
encoding and not just uh not just Oracle

1479
00:56:11,460 --> 00:56:12,599
access to it

1480
00:56:12,599 --> 00:56:14,640
this allows us to capture more

1481
00:56:14,640 --> 00:56:16,319
applications and also pre-processing

1482
00:56:16,319 --> 00:56:17,760
attacks but but of course comes with

1483
00:56:17,760 --> 00:56:19,440
some technical challenges

1484
00:56:19,440 --> 00:56:22,380
and the right tool to address these

1485
00:56:22,380 --> 00:56:24,720
issues is the bit fixing technique by

1486
00:56:24,720 --> 00:56:27,780
corrected or this and Google

1487
00:56:27,780 --> 00:56:29,040
um second thing I would like to mention

1488
00:56:29,040 --> 00:56:31,380
is that the proof is carried out in a

1489
00:56:31,380 --> 00:56:33,240
slightly different way than usual DGM

1490
00:56:33,240 --> 00:56:34,980
proof so normally in a ggm proof you

1491
00:56:34,980 --> 00:56:37,740
would appeal to the short simple Lemma

1492
00:56:37,740 --> 00:56:40,980
to ensure that you have that your lazy

1493
00:56:40,980 --> 00:56:44,099
sampling is is consistent we do not do

1494
00:56:44,099 --> 00:56:46,220
this in in our proof but instead use

1495
00:56:46,220 --> 00:56:49,380
algebraic unpredictability on sources to

1496
00:56:49,380 --> 00:56:51,780
uh to ensure that the lazy sampling was

1497
00:56:51,780 --> 00:56:54,180
consistent so in some sense we we

1498
00:56:54,180 --> 00:56:56,520
reinterpret the short simple Lemma which

1499
00:56:56,520 --> 00:56:59,040
holds us a CRM for sources that output

1500
00:56:59,040 --> 00:57:00,960
random elements we will interpret that

1501
00:57:00,960 --> 00:57:02,819
as an assumption on the sources which is

1502
00:57:02,819 --> 00:57:04,680
exactly the assumption that allows us to

1503
00:57:04,680 --> 00:57:08,359
carry out the proof basically

1504
00:57:08,940 --> 00:57:11,099
um as for applications let me give you a

1505
00:57:11,099 --> 00:57:14,099
quick overview so um the first one the

1506
00:57:14,099 --> 00:57:16,440
easiest one is the Uber assumption we

1507
00:57:16,440 --> 00:57:19,800
recover that via a direct reduction

1508
00:57:19,800 --> 00:57:21,420
um we also get generalizations of the

1509
00:57:21,420 --> 00:57:24,420
Uber assumptions where exponents are

1510
00:57:24,420 --> 00:57:26,700
independent but High entropy and

1511
00:57:26,700 --> 00:57:28,260
restricted versions of these assumptions

1512
00:57:28,260 --> 00:57:30,300
have been studied before so for example

1513
00:57:30,300 --> 00:57:32,640
a connect SD gh2 assumption is of this

1514
00:57:32,640 --> 00:57:33,800
form

1515
00:57:33,800 --> 00:57:36,599
but we also have quite a few

1516
00:57:36,599 --> 00:57:38,460
applications that do not seem to fall

1517
00:57:38,460 --> 00:57:40,260
under the umbrella of the Uber

1518
00:57:40,260 --> 00:57:42,599
assumptions so for example we construct

1519
00:57:42,599 --> 00:57:45,480
uces for so-called simple split sources

1520
00:57:45,480 --> 00:57:48,180
and by doing that we recover all the

1521
00:57:48,180 --> 00:57:51,000
applications in the original UC paper

1522
00:57:51,000 --> 00:57:52,980
that can be proven using using this

1523
00:57:52,980 --> 00:57:55,260
class of sources

1524
00:57:55,260 --> 00:57:57,420
we also show that

1525
00:57:57,420 --> 00:57:59,520
um minor variants of the algomal

1526
00:57:59,520 --> 00:58:03,000
encryption scheme satisfy forms of KDM

1527
00:58:03,000 --> 00:58:04,920
deterministic encryption and RKA

1528
00:58:04,920 --> 00:58:05,819
security

1529
00:58:05,819 --> 00:58:08,339
and we believe that um especially these

1530
00:58:08,339 --> 00:58:09,240
latter

1531
00:58:09,240 --> 00:58:11,099
um these last applications here um

1532
00:58:11,099 --> 00:58:13,260
showcase the power of the PGG notion

1533
00:58:13,260 --> 00:58:16,079
because it allows one to prove

1534
00:58:16,079 --> 00:58:18,000
um security of simple and practical

1535
00:58:18,000 --> 00:58:20,579
schemes in very Advanced security models

1536
00:58:20,579 --> 00:58:23,099
as opposed to more complex constructions

1537
00:58:23,099 --> 00:58:27,020
that are known in the literature

1538
00:58:27,180 --> 00:58:29,640
um as a corollary of our DGM visibility

1539
00:58:29,640 --> 00:58:32,460
results we can also show that all our

1540
00:58:32,460 --> 00:58:34,200
applications are secure against

1541
00:58:34,200 --> 00:58:37,619
pre-processing attacks foreign

1542
00:58:37,619 --> 00:58:40,160
now the applications that you see

1543
00:58:40,160 --> 00:58:43,380
highlighted here in some form one form

1544
00:58:43,380 --> 00:58:46,500
or another use a hash function

1545
00:58:46,500 --> 00:58:47,819
and

1546
00:58:47,819 --> 00:58:49,440
um if you go through the proof you see

1547
00:58:49,440 --> 00:58:51,059
that it is Hash function evaluations

1548
00:58:51,059 --> 00:58:53,040
that the security

1549
00:58:53,040 --> 00:58:54,720
um that the security reduction queries

1550
00:58:54,720 --> 00:58:57,059
to the PGG Oracle so what we need for

1551
00:58:57,059 --> 00:59:00,119
the proof to go through is that um

1552
00:59:00,119 --> 00:59:02,040
hash function evaluations are

1553
00:59:02,040 --> 00:59:04,440
algebraically unpredictable if the hash

1554
00:59:04,440 --> 00:59:06,240
function is queried on unpredictable

1555
00:59:06,240 --> 00:59:08,160
sources so in some sense the hash

1556
00:59:08,160 --> 00:59:09,980
function has the role of linking

1557
00:59:09,980 --> 00:59:12,299
traditional unpredictability to

1558
00:59:12,299 --> 00:59:15,299
algebraic unpredictability

1559
00:59:15,299 --> 00:59:17,099
um we formalized this as a new security

1560
00:59:17,099 --> 00:59:19,140
requirement for hash functions which we

1561
00:59:19,140 --> 00:59:21,240
call linear dependence destroyers or

1562
00:59:21,240 --> 00:59:23,160
ldds

1563
00:59:23,160 --> 00:59:24,900
um the game is basically what you see

1564
00:59:24,900 --> 00:59:26,880
here so Source outputs

1565
00:59:26,880 --> 00:59:29,400
um some hash inputs and some leakage and

1566
00:59:29,400 --> 00:59:32,099
then an adversary gets the hash key and

1567
00:59:32,099 --> 00:59:33,839
must come up with a linear combination

1568
00:59:33,839 --> 00:59:38,040
of um of the hash evaluations

1569
00:59:38,040 --> 00:59:41,579
our results on LEDs are as follows we

1570
00:59:41,579 --> 00:59:43,920
provide instantiations for so-called low

1571
00:59:43,920 --> 00:59:45,540
leak resources

1572
00:59:45,540 --> 00:59:49,140
and we show that a random function is an

1573
00:59:49,140 --> 00:59:51,480
ldd for certain parameter ranges and we

1574
00:59:51,480 --> 00:59:54,780
prove this via by a compression argument

1575
00:59:54,780 --> 00:59:58,079
okay so let me conclude by quickly

1576
00:59:58,079 --> 01:00:00,059
recapping what happens in a paper and I

1577
01:00:00,059 --> 01:00:01,980
mentioned some open problems

1578
01:00:01,980 --> 01:00:05,520
so um we provide we provide a new

1579
01:00:05,520 --> 01:00:07,079
definitional framework for assumptions

1580
01:00:07,079 --> 01:00:08,280
on groups

1581
01:00:08,280 --> 01:00:11,040
we showed that the definition is void

1582
01:00:11,040 --> 01:00:13,559
for tribute of trivial attacks by

1583
01:00:13,559 --> 01:00:16,680
showing that a that the ggm the generic

1584
01:00:16,680 --> 01:00:18,900
group satisfies this notion and we

1585
01:00:18,900 --> 01:00:19,799
showed that some interesting

1586
01:00:19,799 --> 01:00:22,140
applications follow from our notion

1587
01:00:22,140 --> 01:00:25,200
as for open questions there's several

1588
01:00:25,200 --> 01:00:28,260
ways to build on our work we think

1589
01:00:28,260 --> 01:00:29,520
um it would be interesting to maybe

1590
01:00:29,520 --> 01:00:32,040
increase adaptivity of our notion or to

1591
01:00:32,040 --> 01:00:33,780
capture fixed generator no um

1592
01:00:33,780 --> 01:00:35,040
assumptions

1593
01:00:35,040 --> 01:00:37,500
on the ldd side it will be interesting

1594
01:00:37,500 --> 01:00:40,859
to see if the candidate construction

1595
01:00:40,859 --> 01:00:44,640
that we that we provide is is an ldd for

1596
01:00:44,640 --> 01:00:46,200
the whole class of statistically

1597
01:00:46,200 --> 01:00:48,240
unpredictable sources

1598
01:00:48,240 --> 01:00:51,420
and finally I guess the big question in

1599
01:00:51,420 --> 01:00:54,240
the background that this work is just a

1600
01:00:54,240 --> 01:00:57,000
small part of is how far can we push

1601
01:00:57,000 --> 01:01:00,119
this High entropy approach to connect

1602
01:01:00,119 --> 01:01:02,339
um uh real the real world and and

1603
01:01:02,339 --> 01:01:04,440
idealized models for example can we

1604
01:01:04,440 --> 01:01:06,180
capture new models or can capture more

1605
01:01:06,180 --> 01:01:08,339
assumptions can we connect models

1606
01:01:08,339 --> 01:01:10,920
insert your favorite question here

1607
01:01:10,920 --> 01:01:15,440
so yeah that's it thank you very much

1608
01:01:19,200 --> 01:01:21,919
any questions

1609
01:01:27,780 --> 01:01:30,420
uh I have a maybe silly question but um

1610
01:01:30,420 --> 01:01:31,980
so remember in the original definition

1611
01:01:31,980 --> 01:01:34,559
of uce or hash functions there was some

1612
01:01:34,559 --> 01:01:36,420
there was a later verb that showed that

1613
01:01:36,420 --> 01:01:38,700
if you had IO it's sort of a break all

1614
01:01:38,700 --> 01:01:41,760
the definitions of uh Lucy

1615
01:01:41,760 --> 01:01:43,980
uh do you have similar uh problems here

1616
01:01:43,980 --> 01:01:46,740
or can you avoid that okay so the

1617
01:01:46,740 --> 01:01:49,140
original work on uce is considered a

1618
01:01:49,140 --> 01:01:50,839
computational notion of unpredictability

1619
01:01:50,839 --> 01:01:54,059
and that was exactly the problem so the

1620
01:01:54,059 --> 01:01:56,040
the i o based attacks are enabled by the

1621
01:01:56,040 --> 01:01:57,960
fact that you consider a comp to Only

1622
01:01:57,960 --> 01:02:00,299
computational predictors We directly go

1623
01:02:00,299 --> 01:02:02,160
to the statistical version so all

1624
01:02:02,160 --> 01:02:05,540
predictors here are unbounded

1625
01:02:10,559 --> 01:02:13,319
um do you happen to know if there are

1626
01:02:13,319 --> 01:02:15,480
other idealized models that implied

1627
01:02:15,480 --> 01:02:17,579
things like the KDM security of element

1628
01:02:17,579 --> 01:02:19,079
encryption because I mean obviously the

1629
01:02:19,079 --> 01:02:21,000
generic group model does and then maybe

1630
01:02:21,000 --> 01:02:23,640
is that it do you know

1631
01:02:23,640 --> 01:02:26,700
I don't answer that's fine

1632
01:02:26,700 --> 01:02:30,078
all right let's thank the speaker again

1633
01:02:35,119 --> 01:02:39,480
help okay uh so there is apparently

1634
01:02:39,480 --> 01:02:41,520
going to be some closing remarks right

1635
01:02:41,520 --> 01:02:44,540
now and then we'll be done

1636
01:02:55,859 --> 01:02:59,160
everybody so um that's everything I just

1637
01:02:59,160 --> 01:03:00,480
want to close the conference by

1638
01:03:00,480 --> 01:03:02,220
acknowledging all the work that went

1639
01:03:02,220 --> 01:03:05,160
into us uh first starting with Ikea and

1640
01:03:05,160 --> 01:03:07,260
vinod for their leadership as program uh

1641
01:03:07,260 --> 01:03:08,339
chairs

1642
01:03:08,339 --> 01:03:11,900
I guess we could do random replies

1643
01:03:12,839 --> 01:03:14,760
to uh everybody who helped on the

1644
01:03:14,760 --> 01:03:16,200
program committee everyone who wrote a

1645
01:03:16,200 --> 01:03:17,940
review externally there are hundreds of

1646
01:03:17,940 --> 01:03:19,200
reviews that went into selecting these

1647
01:03:19,200 --> 01:03:21,720
great papers thanks to them

1648
01:03:21,720 --> 01:03:24,240
thank you

1649
01:03:24,240 --> 01:03:26,220
uh thank you to everybody who submitted

1650
01:03:26,220 --> 01:03:27,839
a paper who authored a paper here uh

1651
01:03:27,839 --> 01:03:29,760
thank you to the speakers especially the

1652
01:03:29,760 --> 01:03:31,260
student speakers especially the student

1653
01:03:31,260 --> 01:03:32,760
speakers bravely giving their first

1654
01:03:32,760 --> 01:03:33,920
talks in front of the community

1655
01:03:33,920 --> 01:03:37,700
congratulations to all of you

1656
01:03:38,700 --> 01:03:42,960
and um I'll acknowledge Uh Kevin and Kay

1657
01:03:42,960 --> 01:03:45,839
have been in that Zoom room all week uh

1658
01:03:45,839 --> 01:03:47,700
and we'll make sure that these videos

1659
01:03:47,700 --> 01:03:49,200
make it onto YouTube they're also

1660
01:03:49,200 --> 01:03:50,819
helping us before the conference thanks

1661
01:03:50,819 --> 01:03:53,660
Kevin thanks okay

1662
01:03:55,500 --> 01:03:57,000
um and the other people at the icr who

1663
01:03:57,000 --> 01:03:58,500
aren't here like Brian lamakia Michelle

1664
01:03:58,500 --> 01:04:00,839
Abdallah really do a ton of work that

1665
01:04:00,839 --> 01:04:03,420
isn't very visible but it they're doing

1666
01:04:03,420 --> 01:04:05,040
good work because you don't hear about

1667
01:04:05,040 --> 01:04:06,960
everything they're doing uh they're not

1668
01:04:06,960 --> 01:04:09,000
here to hear us but thanks you know out

1669
01:04:09,000 --> 01:04:10,740
there to Michelle and Brian

1670
01:04:10,740 --> 01:04:13,920
and um and then thanks to everybody

1671
01:04:13,920 --> 01:04:15,900
who's physically here Sandy and Jay

1672
01:04:15,900 --> 01:04:17,700
around the desk out oh they're here

1673
01:04:17,700 --> 01:04:20,940
thanks Sandy thanks Jay uh

1674
01:04:20,940 --> 01:04:22,740
they did

1675
01:04:22,740 --> 01:04:24,720
they both did so much work uh in helping

1676
01:04:24,720 --> 01:04:26,339
us and finally um to our student

1677
01:04:26,339 --> 01:04:29,640
volunteers uh Alex uh was running this

1678
01:04:29,640 --> 01:04:31,319
laptop and making sure it didn't fall

1679
01:04:31,319 --> 01:04:33,960
apart all week uh Jesse and Sam were

1680
01:04:33,960 --> 01:04:36,420
running microphones around and JN

1681
01:04:36,420 --> 01:04:39,900
um uh was also helping us at the desk so

1682
01:04:39,900 --> 01:04:42,960
um thanks to them thank you

1683
01:04:42,960 --> 01:04:45,299
and uh finally

1684
01:04:45,299 --> 01:04:47,220
thanks to all of you I mean if you all

1685
01:04:47,220 --> 01:04:48,780
didn't attend the conference there

1686
01:04:48,780 --> 01:04:50,520
wouldn't be any reason to have it so I

1687
01:04:50,520 --> 01:04:51,599
hope you get something out of it but

1688
01:04:51,599 --> 01:04:52,920
your presence actually benefits

1689
01:04:52,920 --> 01:04:55,559
everybody else so uh thank you and uh

1690
01:04:55,559 --> 01:04:57,180
safe travels

1691
01:04:57,180 --> 01:04:59,160
um back home uh to wherever you are

1692
01:04:59,160 --> 01:05:02,420
going okay bye

