1
00:00:01,040 --> 00:00:02,960
hello today i will tell you about a new

2
00:00:02,960 --> 00:00:04,240
universal framework for function

3
00:00:04,240 --> 00:00:06,080
encryption that we call multi-party

4
00:00:06,080 --> 00:00:07,520
functional encryption

5
00:00:07,520 --> 00:00:09,120
goal of multiparty function encryption

6
00:00:09,120 --> 00:00:11,040
is to encapsulate all existing function

7
00:00:11,040 --> 00:00:12,719
encryption schemes under a single

8
00:00:12,719 --> 00:00:16,320
umbrella even in the multi-user setting

9
00:00:16,320 --> 00:00:18,400
the starting point of this talk is the

10
00:00:18,400 --> 00:00:19,920
notion of function encryption itself

11
00:00:19,920 --> 00:00:22,000
whose roots can be traced as

12
00:00:22,000 --> 00:00:25,039
can can be traced back as early as 2005.

13
00:00:25,039 --> 00:00:26,880
fe is a powerful notion of encryption

14
00:00:26,880 --> 00:00:28,720
with the goal of enabling fine grain

15
00:00:28,720 --> 00:00:31,119
decryption access over encrypted data

16
00:00:31,119 --> 00:00:32,479
pictorially the intuition behind

17
00:00:32,479 --> 00:00:33,840
function encryption can be understood

18
00:00:33,840 --> 00:00:35,840
using the following example

19
00:00:35,840 --> 00:00:37,760
suppose we have three parties alice bob

20
00:00:37,760 --> 00:00:40,480
and charlie alice has a sensitive data m

21
00:00:40,480 --> 00:00:42,960
pop has the secret key and charlie wants

22
00:00:42,960 --> 00:00:44,559
to learn the evaluation of a function

23
00:00:44,559 --> 00:00:46,960
map on the secret data

24
00:00:46,960 --> 00:00:49,120
in order to compute this what bob can do

25
00:00:49,120 --> 00:00:50,640
is that bob can simply give the secret

26
00:00:50,640 --> 00:00:52,800
key to charlie charlie can decrypt it

27
00:00:52,800 --> 00:00:55,360
compute f and learn f of m

28
00:00:55,360 --> 00:00:57,120
but what if we want charlie to only

29
00:00:57,120 --> 00:00:58,800
learn ffm and nothing else about the

30
00:00:58,800 --> 00:01:00,800
underlying message

31
00:01:00,800 --> 00:01:02,640
and what if charlie doesn't want to

32
00:01:02,640 --> 00:01:04,879
outsource this competition to bob or it

33
00:01:04,879 --> 00:01:06,799
does not want bob to be online for this

34
00:01:06,799 --> 00:01:08,080
competition

35
00:01:08,080 --> 00:01:09,520
to capture all such interesting

36
00:01:09,520 --> 00:01:11,200
scenarios that go beyond the traditional

37
00:01:11,200 --> 00:01:13,280
definition of encryption the notion of

38
00:01:13,280 --> 00:01:15,840
functional encryption is devised

39
00:01:15,840 --> 00:01:18,159
in function encryption pop can actually

40
00:01:18,159 --> 00:01:20,479
decrypt or can create some partial

41
00:01:20,479 --> 00:01:22,479
decryption keys for a function f such

42
00:01:22,479 --> 00:01:24,720
that given this partial decryption keys

43
00:01:24,720 --> 00:01:26,560
these functional keys charlie can

44
00:01:26,560 --> 00:01:28,400
perform this computation on its own and

45
00:01:28,400 --> 00:01:30,240
learn only f of m

46
00:01:30,240 --> 00:01:33,119
nothing else about the message scan

47
00:01:33,119 --> 00:01:35,360
abstractly a function encryption scheme

48
00:01:35,360 --> 00:01:37,040
is parametrized by two classes a

49
00:01:37,040 --> 00:01:39,600
function class and an input class

50
00:01:39,600 --> 00:01:41,680
here we are viewing fe as a scheme in

51
00:01:41,680 --> 00:01:43,920
which messages in the input class can be

52
00:01:43,920 --> 00:01:45,119
encrypted

53
00:01:45,119 --> 00:01:46,560
and partial decryption keys or

54
00:01:46,560 --> 00:01:48,479
functional keys for functions in the

55
00:01:48,479 --> 00:01:50,960
function plus can be computed such that

56
00:01:50,960 --> 00:01:53,360
combining a single soft text secret key

57
00:01:53,360 --> 00:01:55,600
pair you get the desired function

58
00:01:55,600 --> 00:01:58,000
evaluation that is f

59
00:01:58,000 --> 00:01:59,600
and the intuition behind security for

60
00:01:59,600 --> 00:02:01,360
function encryption is that given an

61
00:02:01,360 --> 00:02:04,000
encryption of input x

62
00:02:04,000 --> 00:02:06,079
and polynomially many secret keys say

63
00:02:06,079 --> 00:02:08,720
for functions f1 to fq the adversary

64
00:02:08,720 --> 00:02:10,800
only learns the evaluations of all those

65
00:02:10,800 --> 00:02:12,640
functions that it has a key for

66
00:02:12,640 --> 00:02:15,200
for the underlying message x and nothing

67
00:02:15,200 --> 00:02:17,440
else

68
00:02:18,000 --> 00:02:21,040
and as i was alluding to earlier fe has

69
00:02:21,040 --> 00:02:23,520
been a grand unifier wherein it enabled

70
00:02:23,520 --> 00:02:25,840
placing all previously known encryption

71
00:02:25,840 --> 00:02:27,920
systems at that time under a single

72
00:02:27,920 --> 00:02:29,120
umbrella

73
00:02:29,120 --> 00:02:30,959
for illustrated purposes let us consider

74
00:02:30,959 --> 00:02:32,640
the simple example of identity based

75
00:02:32,640 --> 00:02:36,319
encryption which was introduced in 1984

76
00:02:36,319 --> 00:02:38,560
by adi shamir

77
00:02:38,560 --> 00:02:40,239
the goal of identity-based encryption is

78
00:02:40,239 --> 00:02:42,480
to let the entrepreneur

79
00:02:42,480 --> 00:02:44,319
only be aware of the recipient's

80
00:02:44,319 --> 00:02:46,319
identity instead of their exact public

81
00:02:46,319 --> 00:02:47,280
key

82
00:02:47,280 --> 00:02:49,440
now ibe can also be captured by function

83
00:02:49,440 --> 00:02:51,920
encryption by this simple equality check

84
00:02:51,920 --> 00:02:53,200
class

85
00:02:53,200 --> 00:02:55,920
similarly you can also capture attribute

86
00:02:55,920 --> 00:02:57,760
based encryption which is much more fine

87
00:02:57,760 --> 00:03:00,239
when accessing a control system by

88
00:03:00,239 --> 00:03:02,080
function encryption by using appropriate

89
00:03:02,080 --> 00:03:04,560
function classes as well and there's so

90
00:03:04,560 --> 00:03:07,040
many more encryption concepts that are

91
00:03:07,040 --> 00:03:08,879
special place of cases of function

92
00:03:08,879 --> 00:03:10,800
encryption

93
00:03:10,800 --> 00:03:12,640
now since it's formalization over a

94
00:03:12,640 --> 00:03:15,599
decade ago fe has turned out to be a

95
00:03:15,599 --> 00:03:16,800
very meaningful and powerful

96
00:03:16,800 --> 00:03:19,760
cryptographic concept as it unified not

97
00:03:19,760 --> 00:03:22,480
only at all at that time all existing

98
00:03:22,480 --> 00:03:24,640
encryption functionalities but it helped

99
00:03:24,640 --> 00:03:27,200
in predicting new concepts and also

100
00:03:27,200 --> 00:03:29,519
served as the right abstraction to study

101
00:03:29,519 --> 00:03:31,440
relationships between numerous

102
00:03:31,440 --> 00:03:33,680
cryptographic objects including program

103
00:03:33,680 --> 00:03:35,680
obfuscation

104
00:03:35,680 --> 00:03:38,000
it has been a radical concept such that

105
00:03:38,000 --> 00:03:40,239
it has been further generalized to many

106
00:03:40,239 --> 00:03:43,200
more general multi-user models

107
00:03:43,200 --> 00:03:44,799
now some of you might be wondering what

108
00:03:44,799 --> 00:03:48,000
do i mean by a multi-user model

109
00:03:48,000 --> 00:03:50,080
wasn't fe already defined for multiple

110
00:03:50,080 --> 00:03:52,159
users and even my simple example i had

111
00:03:52,159 --> 00:03:53,680
already three parties alice webb and

112
00:03:53,680 --> 00:03:54,799
charlie

113
00:03:54,799 --> 00:03:56,640
well that is true the point is that

114
00:03:56,640 --> 00:03:58,720
despite the incredible expressiveness of

115
00:03:58,720 --> 00:03:59,599
fe

116
00:03:59,599 --> 00:04:01,599
the decryption still takes as input the

117
00:04:01,599 --> 00:04:03,680
single ciphtex and secret key pair as

118
00:04:03,680 --> 00:04:05,439
input

119
00:04:05,439 --> 00:04:07,439
thus the question becomes what happens

120
00:04:07,439 --> 00:04:09,360
if there are multiple different data

121
00:04:09,360 --> 00:04:10,799
sources

122
00:04:10,799 --> 00:04:12,480
or what if there are multiple

123
00:04:12,480 --> 00:04:14,799
independent key holders

124
00:04:14,799 --> 00:04:17,199
or maybe there is a mixture of both

125
00:04:17,199 --> 00:04:19,358
there are multiple keys multiple saftix

126
00:04:19,358 --> 00:04:21,199
and we want to learn computation about

127
00:04:21,199 --> 00:04:23,600
all of them at the same time

128
00:04:23,600 --> 00:04:25,440
it turns out that this goes beyond the

129
00:04:25,440 --> 00:04:27,360
abstraction of regular single party

130
00:04:27,360 --> 00:04:29,040
functional encryption

131
00:04:29,040 --> 00:04:31,040
and to that and numerous generalizations

132
00:04:31,040 --> 00:04:32,800
have been proposed

133
00:04:32,800 --> 00:04:35,600
let me elaborate on them

134
00:04:35,600 --> 00:04:37,680
the earliest work was by called warsaw

135
00:04:37,680 --> 00:04:40,400
at all where they proposed something

136
00:04:40,400 --> 00:04:42,960
called multi-input function encryption

137
00:04:42,960 --> 00:04:45,040
which was in the domain of multiple data

138
00:04:45,040 --> 00:04:46,320
sources

139
00:04:46,320 --> 00:04:49,600
where the ciphertext can be computed for

140
00:04:49,600 --> 00:04:51,840
different independently chosen message

141
00:04:51,840 --> 00:04:54,160
values x1 up to xn

142
00:04:54,160 --> 00:04:56,880
and the decryption can combine multiple

143
00:04:56,880 --> 00:04:58,639
different soft text given a single

144
00:04:58,639 --> 00:05:00,639
secret key and learn the corresponding

145
00:05:00,639 --> 00:05:04,560
value f of x one of the x n

146
00:05:04,560 --> 00:05:07,440
recently the notion of uh mifv was

147
00:05:07,440 --> 00:05:09,039
further generalized to the notion of

148
00:05:09,039 --> 00:05:11,039
multi-client function encryption

149
00:05:11,039 --> 00:05:12,960
where the point is that instead of

150
00:05:12,960 --> 00:05:15,120
having just uh

151
00:05:15,120 --> 00:05:16,240
basically in

152
00:05:16,240 --> 00:05:18,240
multi-client function encryption the

153
00:05:18,240 --> 00:05:20,479
inputs x1 also contains some public

154
00:05:20,479 --> 00:05:23,120
labels and the computation only succeeds

155
00:05:23,120 --> 00:05:25,120
in the public labels for all the input

156
00:05:25,120 --> 00:05:27,680
subjects they match

157
00:05:27,680 --> 00:05:29,600
similarly there has been much progress

158
00:05:29,600 --> 00:05:31,120
in the domain of distributing secret

159
00:05:31,120 --> 00:05:32,720
keys as well

160
00:05:32,720 --> 00:05:33,840
but it's been mostly from the

161
00:05:33,840 --> 00:05:35,840
perspective of either escrow or adding

162
00:05:35,840 --> 00:05:37,440
extra functionality

163
00:05:37,440 --> 00:05:39,039
the earliest works were referred to as

164
00:05:39,039 --> 00:05:41,120
multi-authority encryption where there

165
00:05:41,120 --> 00:05:43,360
are multiple sources and ciphertexts

166
00:05:43,360 --> 00:05:46,080
contain a secret function instead

167
00:05:46,080 --> 00:05:47,520
so here you can see the site text

168
00:05:47,520 --> 00:05:49,199
contains a function g

169
00:05:49,199 --> 00:05:51,360
and secret keys contain some attributes

170
00:05:51,360 --> 00:05:54,160
or some input values y1 yn

171
00:05:54,160 --> 00:05:56,160
and the evaluation of this decryption

172
00:05:56,160 --> 00:05:57,919
functionality is going to give me the

173
00:05:57,919 --> 00:05:59,120
output of the

174
00:05:59,120 --> 00:06:01,600
secret function g on these particular

175
00:06:01,600 --> 00:06:03,600
input values

176
00:06:03,600 --> 00:06:05,280
recently most such notions such as

177
00:06:05,280 --> 00:06:06,720
decentralized function encryption has

178
00:06:06,720 --> 00:06:08,800
also been started

179
00:06:08,800 --> 00:06:10,319
lastly as i was alluding to earlier

180
00:06:10,319 --> 00:06:12,240
there has been a lot of recent progress

181
00:06:12,240 --> 00:06:14,400
on distributing both ciphertext and

182
00:06:14,400 --> 00:06:15,840
secret keys

183
00:06:15,840 --> 00:06:17,600
the first work in this line was by

184
00:06:17,600 --> 00:06:19,440
chorale and all who defined what they

185
00:06:19,440 --> 00:06:21,680
described as decentralized version of

186
00:06:21,680 --> 00:06:23,680
multi-client functional encryption

187
00:06:23,680 --> 00:06:26,639
combining these two previously defined

188
00:06:26,639 --> 00:06:28,319
multi-user systems

189
00:06:28,319 --> 00:06:31,280
briefly in such systems we have suppose

190
00:06:31,280 --> 00:06:32,319
an n

191
00:06:32,319 --> 00:06:34,080
a polynomial number of soft text and a

192
00:06:34,080 --> 00:06:36,080
polynomial number of secret keys

193
00:06:36,080 --> 00:06:37,919
and these ciphers and security keys can

194
00:06:37,919 --> 00:06:40,080
be combined to learn the evaluation of a

195
00:06:40,080 --> 00:06:41,520
function f

196
00:06:41,520 --> 00:06:44,080
on inputs x 1 up to x and where x 1 up

197
00:06:44,080 --> 00:06:46,639
to x n are encoded in the soft text and

198
00:06:46,639 --> 00:06:48,800
function f encoded inside the secret

199
00:06:48,800 --> 00:06:51,039
keys all these independent secret keys

200
00:06:51,039 --> 00:06:54,000
as long as the labels of the ciphertext

201
00:06:54,000 --> 00:06:56,479
they match

202
00:06:56,479 --> 00:06:58,800
very recently there have been further

203
00:06:58,800 --> 00:07:01,039
extend these these notions of

204
00:07:01,039 --> 00:07:02,319
decentralized multi-client function

205
00:07:02,319 --> 00:07:04,160
encryption has been further extended and

206
00:07:04,160 --> 00:07:06,400
generalized to give concepts of add-on

207
00:07:06,400 --> 00:07:08,720
multi uh input function encryption as

208
00:07:08,720 --> 00:07:10,319
well as dynamic decentralized function

209
00:07:10,319 --> 00:07:11,440
encryption

210
00:07:11,440 --> 00:07:13,120
where add-on multi-input function

211
00:07:13,120 --> 00:07:14,160
encryption

212
00:07:14,160 --> 00:07:15,680
it generalized the concept of

213
00:07:15,680 --> 00:07:18,560
decentralized mcfe to remove labels and

214
00:07:18,560 --> 00:07:21,199
add unbounded additive and very recently

215
00:07:21,199 --> 00:07:22,479
dynamic decentralized function

216
00:07:22,479 --> 00:07:24,960
encryption it generalized anarch mi f

217
00:07:24,960 --> 00:07:27,680
even further to have the concept of

218
00:07:27,680 --> 00:07:30,160
totally dynamic and local setup and

219
00:07:30,160 --> 00:07:32,639
allowed key combination across different

220
00:07:32,639 --> 00:07:35,120
inputs and the secret keys do not have

221
00:07:35,120 --> 00:07:38,800
the same function encoded inside of them

222
00:07:38,800 --> 00:07:41,199
overall this shows that there is a fast

223
00:07:41,199 --> 00:07:43,199
unexplored universe of encryption

224
00:07:43,199 --> 00:07:46,240
functionality that has yet to be started

225
00:07:46,240 --> 00:07:47,840
additionally the study of functional

226
00:07:47,840 --> 00:07:49,840
encryption in the multi-user setting has

227
00:07:49,840 --> 00:07:51,199
been similar to

228
00:07:51,199 --> 00:07:53,599
the pre-single user these pre single

229
00:07:53,599 --> 00:07:56,319
user uh function encryption days where

230
00:07:56,319 --> 00:07:58,160
many new models were proposed and

231
00:07:58,160 --> 00:08:00,639
studied and it seemed that they were

232
00:08:00,639 --> 00:08:02,400
quite related

233
00:08:02,400 --> 00:08:04,479
and but it was often difficult to

234
00:08:04,479 --> 00:08:06,240
understand how they compare to each

235
00:08:06,240 --> 00:08:08,160
other and whether they use related

236
00:08:08,160 --> 00:08:09,520
techniques

237
00:08:09,520 --> 00:08:10,879
and even what is known in terms of

238
00:08:10,879 --> 00:08:12,479
feasibility for different encryption

239
00:08:12,479 --> 00:08:14,560
functionalities and this has been going

240
00:08:14,560 --> 00:08:17,120
on as well in the multi-user setting

241
00:08:17,120 --> 00:08:19,440
today because we have these amazing

242
00:08:19,440 --> 00:08:20,400
different

243
00:08:20,400 --> 00:08:23,039
models of multi-user encryption systems

244
00:08:23,039 --> 00:08:24,240
for function encryption systems like

245
00:08:24,240 --> 00:08:26,639
distributed soft text distributed keys

246
00:08:26,639 --> 00:08:28,639
and both of them and they have different

247
00:08:28,639 --> 00:08:31,520
applications and it's it's bit

248
00:08:31,520 --> 00:08:34,159
inconvenient that how can we try to

249
00:08:34,159 --> 00:08:35,839
compare them

250
00:08:35,839 --> 00:08:37,120
while they all were designed for

251
00:08:37,120 --> 00:08:38,640
different applications different user

252
00:08:38,640 --> 00:08:41,279
models the process of studying new

253
00:08:41,279 --> 00:08:42,880
notions and comparing the techniques

254
00:08:42,880 --> 00:08:44,480
that we already have has become very

255
00:08:44,480 --> 00:08:46,399
infeasible

256
00:08:46,399 --> 00:08:48,640
to that in this work we study the notion

257
00:08:48,640 --> 00:08:51,680
of or the question of encapsulating

258
00:08:51,680 --> 00:08:53,920
multi-user function encryption function

259
00:08:53,920 --> 00:08:55,680
encryption multi-user models in a more

260
00:08:55,680 --> 00:08:57,279
systematic framework

261
00:08:57,279 --> 00:08:58,800
similar to what was done by bernie

262
00:08:58,800 --> 00:09:01,360
sanders over a decade ago for single

263
00:09:01,360 --> 00:09:03,519
user model

264
00:09:03,519 --> 00:09:05,519
now

265
00:09:05,519 --> 00:09:06,240
in

266
00:09:06,240 --> 00:09:08,320
the main contributions of our work is

267
00:09:08,320 --> 00:09:09,839
that

268
00:09:09,839 --> 00:09:12,000
we introduce this notion of multi-party

269
00:09:12,000 --> 00:09:13,839
functional encryption that is meant to

270
00:09:13,839 --> 00:09:16,399
capture and unify all notion of function

271
00:09:16,399 --> 00:09:18,640
encryption in these multi-user models

272
00:09:18,640 --> 00:09:21,120
we also propose a new um we also propose

273
00:09:21,120 --> 00:09:22,240
new multi-user encryption

274
00:09:22,240 --> 00:09:24,480
functionalities that go beyond what has

275
00:09:24,480 --> 00:09:26,560
been previously studied and we also give

276
00:09:26,560 --> 00:09:29,360
some interesting new uh instantiations

277
00:09:29,360 --> 00:09:30,959
for these functionalities from standard

278
00:09:30,959 --> 00:09:32,880
assumptions

279
00:09:32,880 --> 00:09:34,880
now moving on i will define the notion

280
00:09:34,880 --> 00:09:37,040
of define the framework of multi-party

281
00:09:37,040 --> 00:09:39,440
function encryption

282
00:09:39,440 --> 00:09:42,000
now in order to jointly capture uh the

283
00:09:42,000 --> 00:09:44,000
notion of scythe text policy and key

284
00:09:44,000 --> 00:09:45,200
policy

285
00:09:45,200 --> 00:09:46,320
uh

286
00:09:46,320 --> 00:09:48,320
systems in function encryption more

287
00:09:48,320 --> 00:09:50,800
holistically we define the input spaces

288
00:09:50,800 --> 00:09:53,040
for both ciphertext and secret keys

289
00:09:53,040 --> 00:09:55,200
instead of defining them a function

290
00:09:55,200 --> 00:09:58,160
space for each of them individually

291
00:09:58,160 --> 00:10:00,000
now jumping a little bit ahead the main

292
00:10:00,000 --> 00:10:01,279
point in multi-party functional

293
00:10:01,279 --> 00:10:02,800
encryption is the possibility of

294
00:10:02,800 --> 00:10:05,040
combining multiple subjects and secret

295
00:10:05,040 --> 00:10:06,640
keys at the same time

296
00:10:06,640 --> 00:10:08,160
you need decryption in order to learn

297
00:10:08,160 --> 00:10:10,720
interesting functional values

298
00:10:10,720 --> 00:10:12,560
a natural question would be how would

299
00:10:12,560 --> 00:10:14,240
this or what would this combination look

300
00:10:14,240 --> 00:10:16,079
like i mean how can we combine these

301
00:10:16,079 --> 00:10:17,440
things

302
00:10:17,440 --> 00:10:19,600
now our suggestion is to define two

303
00:10:19,600 --> 00:10:21,839
aggregation functions

304
00:10:21,839 --> 00:10:23,760
each for the ciphtex and secret key

305
00:10:23,760 --> 00:10:25,839
input spaces separately

306
00:10:25,839 --> 00:10:27,279
and these

307
00:10:27,279 --> 00:10:28,800
aggregation functions are going to be

308
00:10:28,800 --> 00:10:31,200
tied to the underlying encryption system

309
00:10:31,200 --> 00:10:32,880
and now the decryption algorithm is

310
00:10:32,880 --> 00:10:34,800
going to compute the universal circuit

311
00:10:34,800 --> 00:10:37,920
on the individually aggregated input and

312
00:10:37,920 --> 00:10:40,000
uh function values or it's like the key

313
00:10:40,000 --> 00:10:43,360
values as well as the side text values

314
00:10:43,360 --> 00:10:45,279
now pictorially this could be visualized

315
00:10:45,279 --> 00:10:47,680
as follows you have these uh input

316
00:10:47,680 --> 00:10:49,680
values stored inside the ciphertext and

317
00:10:49,680 --> 00:10:51,360
you have we have these y values these

318
00:10:51,360 --> 00:10:53,920
input values inside the secret keys

319
00:10:53,920 --> 00:10:55,920
now multiparty function encryption says

320
00:10:55,920 --> 00:10:58,480
that these input values can be

321
00:10:58,480 --> 00:11:00,399
aggregated first using the corresponding

322
00:11:00,399 --> 00:11:02,320
aggregation functions and then after

323
00:11:02,320 --> 00:11:04,079
applying the universal circuit we learn

324
00:11:04,079 --> 00:11:05,600
the corresponding value of the

325
00:11:05,600 --> 00:11:06,800
underlying function that we want to

326
00:11:06,800 --> 00:11:08,480
learn using the multi-party functional

327
00:11:08,480 --> 00:11:10,720
crypto system

328
00:11:10,720 --> 00:11:13,120
now a little more syntactically

329
00:11:13,120 --> 00:11:14,880
in functional encryption systems we

330
00:11:14,880 --> 00:11:17,760
would have a setup algorithm

331
00:11:17,760 --> 00:11:19,920
in which the setup algorithm would take

332
00:11:19,920 --> 00:11:22,160
as input the aggregation functions

333
00:11:22,160 --> 00:11:25,600
association associated with the function

334
00:11:25,600 --> 00:11:27,600
functional group system it also takes us

335
00:11:27,600 --> 00:11:29,920
input the attitude of the scifix and the

336
00:11:29,920 --> 00:11:31,519
secret keys that we also considered in

337
00:11:31,519 --> 00:11:34,000
this uh concern in this model

338
00:11:34,000 --> 00:11:35,760
now the arity of the secret key and the

339
00:11:35,760 --> 00:11:38,079
ciphertext could be optional suppose in

340
00:11:38,079 --> 00:11:41,200
the case we want to have totally dynamic

341
00:11:41,200 --> 00:11:42,880
functional condition systems in that

342
00:11:42,880 --> 00:11:44,800
case these will not be given as input to

343
00:11:44,800 --> 00:11:47,040
the setup algorithm

344
00:11:47,040 --> 00:11:48,720
now in addition to these inputs the

345
00:11:48,720 --> 00:11:50,720
setup algorithm also takes this input

346
00:11:50,720 --> 00:11:53,200
the mode of the computation whether it's

347
00:11:53,200 --> 00:11:55,279
performing the central mode or a local

348
00:11:55,279 --> 00:11:57,040
motor in attractive mode and what do i

349
00:11:57,040 --> 00:11:58,160
mean by that

350
00:11:58,160 --> 00:11:59,680
so first let us imagine that the setup

351
00:11:59,680 --> 00:12:01,680
algorithm generates a sequence of public

352
00:12:01,680 --> 00:12:03,360
parameters encryption keys and master

353
00:12:03,360 --> 00:12:04,720
secret keys

354
00:12:04,720 --> 00:12:06,720
now if i s

355
00:12:06,720 --> 00:12:08,720
if i input the central mode to the setup

356
00:12:08,720 --> 00:12:11,279
algorithm then this setup algorithm is

357
00:12:11,279 --> 00:12:13,040
being performed by a trusted party which

358
00:12:13,040 --> 00:12:14,560
generates all these parameters in a

359
00:12:14,560 --> 00:12:16,079
trusted manner and then it distributes

360
00:12:16,079 --> 00:12:17,600
to the all corresponding users in the

361
00:12:17,600 --> 00:12:19,279
system

362
00:12:19,279 --> 00:12:21,200
in the local mode

363
00:12:21,200 --> 00:12:23,279
this setup algorithm is performed in a

364
00:12:23,279 --> 00:12:25,360
non-interactive and totally independent

365
00:12:25,360 --> 00:12:28,160
way by all users independently

366
00:12:28,160 --> 00:12:30,000
lastly in the interactive mode it is a

367
00:12:30,000 --> 00:12:31,760
protocol between all the users at the

368
00:12:31,760 --> 00:12:34,160
input time and during that mode

369
00:12:34,160 --> 00:12:35,600
interaction can happen but after that

370
00:12:35,600 --> 00:12:37,760
there is no interaction going on further

371
00:12:37,760 --> 00:12:40,720
during the encryption system

372
00:12:40,720 --> 00:12:42,560
so in summary

373
00:12:42,560 --> 00:12:44,240
in multi-party function encryption just

374
00:12:44,240 --> 00:12:45,839
like function encryption we have a setup

375
00:12:45,839 --> 00:12:47,760
mode but setup mode can be done in now

376
00:12:47,760 --> 00:12:49,200
one of three modes

377
00:12:49,200 --> 00:12:52,800
local interactive or trusted

378
00:12:52,800 --> 00:12:54,880
and samples all the public keys the

379
00:12:54,880 --> 00:12:56,639
encryption keys and the master keys for

380
00:12:56,639 --> 00:12:57,920
the corresponding function encryption

381
00:12:57,920 --> 00:12:59,440
system

382
00:12:59,440 --> 00:13:01,440
and given the encryption case one can

383
00:13:01,440 --> 00:13:04,399
encrypt encode the input the message

384
00:13:04,399 --> 00:13:07,120
inputs or the ciphtex inputs into our

385
00:13:07,120 --> 00:13:09,600
ciphtx and using the master secret keys

386
00:13:09,600 --> 00:13:11,519
one can create some partial decryption

387
00:13:11,519 --> 00:13:14,000
keys for these function inputs or these

388
00:13:14,000 --> 00:13:16,079
ciphertext secret key inputs and

389
00:13:16,079 --> 00:13:18,320
decryption algorithm can take as input

390
00:13:18,320 --> 00:13:19,920
arbitrary number of these or just a

391
00:13:19,920 --> 00:13:21,360
predefined number of site text and

392
00:13:21,360 --> 00:13:23,519
secret keys and combine them to learn

393
00:13:23,519 --> 00:13:26,240
appropriate function values allowed by

394
00:13:26,240 --> 00:13:27,920
the underlying multi-party functional

395
00:13:27,920 --> 00:13:29,839
system

396
00:13:29,839 --> 00:13:32,240
now the security since these functional

397
00:13:32,240 --> 00:13:33,760
encryption systems are very powerful the

398
00:13:33,760 --> 00:13:35,839
security for these systems can also be

399
00:13:35,839 --> 00:13:37,920
very complicated to state now i am going

400
00:13:37,920 --> 00:13:39,839
to give you a very high level brief

401
00:13:39,839 --> 00:13:42,240
intuition or what's the intuition behind

402
00:13:42,240 --> 00:13:43,680
security for multi-party function

403
00:13:43,680 --> 00:13:44,639
encryption

404
00:13:44,639 --> 00:13:46,560
so suppose an adversary is given a

405
00:13:46,560 --> 00:13:48,560
polynomial number of ciphertext

406
00:13:48,560 --> 00:13:50,800
which contain encryptions of different

407
00:13:50,800 --> 00:13:52,720
inputs for different under different

408
00:13:52,720 --> 00:13:54,959
encryption on a different encryption

409
00:13:54,959 --> 00:13:56,720
keys for different

410
00:13:56,720 --> 00:13:59,519
inputs and we also given

411
00:13:59,519 --> 00:14:02,000
encoding of different inputs the secret

412
00:14:02,000 --> 00:14:03,760
keys for these inputs under the

413
00:14:03,760 --> 00:14:06,079
corresponding master secret keys

414
00:14:06,079 --> 00:14:08,079
now we say the scheme is secure as long

415
00:14:08,079 --> 00:14:10,720
as the adversary only learns

416
00:14:10,720 --> 00:14:12,639
the evaluation values that it can learn

417
00:14:12,639 --> 00:14:14,240
by performing the decryption algorithm

418
00:14:14,240 --> 00:14:15,440
by running the decryption algorithm

419
00:14:15,440 --> 00:14:17,760
honestly so it can take any combination

420
00:14:17,760 --> 00:14:19,760
of the ciphertext and secret keys run

421
00:14:19,760 --> 00:14:21,920
the decryption algorithm and whatever

422
00:14:21,920 --> 00:14:23,519
the output of the decryption algorithm

423
00:14:23,519 --> 00:14:26,079
is that's all the adversary can learn

424
00:14:26,079 --> 00:14:27,680
nothing else

425
00:14:27,680 --> 00:14:29,040
now this can be formalized by

426
00:14:29,040 --> 00:14:30,800
indistinguishability game and this is

427
00:14:30,800 --> 00:14:33,440
what we formally do in our paper and you

428
00:14:33,440 --> 00:14:35,279
also allow corrupting master keys or

429
00:14:35,279 --> 00:14:37,199
encryption keys and we have to define

430
00:14:37,199 --> 00:14:39,360
the leakage corresponding that are

431
00:14:39,360 --> 00:14:41,120
allowed leakage to the adversary in that

432
00:14:41,120 --> 00:14:43,120
case and for more details i refer you to

433
00:14:43,120 --> 00:14:45,199
the paper

434
00:14:45,199 --> 00:14:48,399
and just uh to give a little bit of more

435
00:14:48,399 --> 00:14:50,399
uh

436
00:14:50,399 --> 00:14:52,639
input how we actually do it in the paper

437
00:14:52,639 --> 00:14:55,360
we actually also break uh the inputs in

438
00:14:55,360 --> 00:14:57,600
the ciphertext and the secret keys into

439
00:14:57,600 --> 00:15:00,000
two domains where we have like a public

440
00:15:00,000 --> 00:15:01,600
depart and a private part which

441
00:15:01,600 --> 00:15:04,160
basically makes a cleaner app

442
00:15:04,160 --> 00:15:05,680
which makes a cleaner framework for

443
00:15:05,680 --> 00:15:07,360
eventual applications suppose you want

444
00:15:07,360 --> 00:15:09,120
to define the notion of partially hiding

445
00:15:09,120 --> 00:15:11,440
function encryption it becomes easier

446
00:15:11,440 --> 00:15:13,120
when we sort of define we split our

447
00:15:13,120 --> 00:15:14,880
inputs into two domains into two

448
00:15:14,880 --> 00:15:16,240
components public and a private

449
00:15:16,240 --> 00:15:18,720
component

450
00:15:19,040 --> 00:15:21,279
now before proceeding further let me

451
00:15:21,279 --> 00:15:23,199
actually show you the expressiveness of

452
00:15:23,199 --> 00:15:26,160
multi-party function encryption

453
00:15:26,160 --> 00:15:28,720
and let me tell you why mpfe actually

454
00:15:28,720 --> 00:15:30,880
unifies all existing notions of

455
00:15:30,880 --> 00:15:31,839
functional encryption that we have

456
00:15:31,839 --> 00:15:33,360
studied so far

457
00:15:33,360 --> 00:15:34,800
for starters let us consider a simple

458
00:15:34,800 --> 00:15:36,160
example of multi-input function

459
00:15:36,160 --> 00:15:37,920
encryption

460
00:15:37,920 --> 00:15:39,839
now recall that in multi input function

461
00:15:39,839 --> 00:15:41,199
encryption

462
00:15:41,199 --> 00:15:43,199
we have say a polynomial number of

463
00:15:43,199 --> 00:15:45,759
ciphers that can be jointly decrypted

464
00:15:45,759 --> 00:15:48,000
using a single function of uh

465
00:15:48,000 --> 00:15:49,920
decryption key

466
00:15:49,920 --> 00:15:51,920
f of the valid from the function f on

467
00:15:51,920 --> 00:15:55,680
the all the inputs at the same time

468
00:15:55,680 --> 00:15:58,320
now in order to instantiate this using

469
00:15:58,320 --> 00:15:59,839
multi-party function encryption the idea

470
00:15:59,839 --> 00:16:01,920
is that we will run the setup in the

471
00:16:01,920 --> 00:16:03,839
central trusted mode

472
00:16:03,839 --> 00:16:06,399
we will substitute the number of uh

473
00:16:06,399 --> 00:16:09,199
addition of the seated key to be one

474
00:16:09,199 --> 00:16:11,360
the aggregation function to be one

475
00:16:11,360 --> 00:16:14,160
the arity of the side of the ciphertext

476
00:16:14,160 --> 00:16:16,480
to be m the number of messages that we

477
00:16:16,480 --> 00:16:18,079
want to or the number of slots

478
00:16:18,079 --> 00:16:19,680
encryption slots that we want and the

479
00:16:19,680 --> 00:16:21,199
aggregation function to be the identity

480
00:16:21,199 --> 00:16:22,560
function again

481
00:16:22,560 --> 00:16:23,759
this is going to generate the key

482
00:16:23,759 --> 00:16:24,880
material

483
00:16:24,880 --> 00:16:27,040
and using the schematic we can encrypt

484
00:16:27,040 --> 00:16:29,440
all these inputs x 1 up to x m

485
00:16:29,440 --> 00:16:30,800
using the corresponding encryption

486
00:16:30,800 --> 00:16:34,160
values we can we can encode the function

487
00:16:34,160 --> 00:16:36,560
using the master secret key and finally

488
00:16:36,560 --> 00:16:37,759
trying to decrypt this using the

489
00:16:37,759 --> 00:16:38,959
multi-party function encryption

490
00:16:38,959 --> 00:16:40,639
decryption algorithm you're going to

491
00:16:40,639 --> 00:16:42,720
learn the universal circuit on the

492
00:16:42,720 --> 00:16:44,720
aggregated values since the application

493
00:16:44,720 --> 00:16:47,040
is just the identity function and we

494
00:16:47,040 --> 00:16:49,040
apply the universal circuit on top of it

495
00:16:49,040 --> 00:16:50,639
that's why we will learn the evaluation

496
00:16:50,639 --> 00:16:52,240
of the function f on the underlying

497
00:16:52,240 --> 00:16:54,160
message values

498
00:16:54,160 --> 00:16:56,480
this basically matches what multi-input

499
00:16:56,480 --> 00:16:57,759
function encryption is trying to do in a

500
00:16:57,759 --> 00:16:59,839
more general manner

501
00:16:59,839 --> 00:17:01,839
now let us also look at the distributed

502
00:17:01,839 --> 00:17:03,279
security setting this was the

503
00:17:03,279 --> 00:17:05,439
distributed cyclic setting

504
00:17:05,439 --> 00:17:07,039
now in the distributed security setting

505
00:17:07,039 --> 00:17:08,480
let us look at the multi-authority

506
00:17:08,480 --> 00:17:10,160
function encryption systems

507
00:17:10,160 --> 00:17:11,599
now multi-authority functional group

508
00:17:11,599 --> 00:17:14,000
systems as i referred to previously the

509
00:17:14,000 --> 00:17:16,319
functions are encoded in the site text

510
00:17:16,319 --> 00:17:18,160
and secret keys have these partial

511
00:17:18,160 --> 00:17:20,240
inputs that we want to encode in the

512
00:17:20,240 --> 00:17:22,079
secret keys such that decryption is

513
00:17:22,079 --> 00:17:23,919
going to learn the evaluation of the

514
00:17:23,919 --> 00:17:25,199
secret g

515
00:17:25,199 --> 00:17:27,679
on these values y one until y n

516
00:17:27,679 --> 00:17:29,200
now as you probably would have guessed

517
00:17:29,200 --> 00:17:32,000
in order to instantiate this using our

518
00:17:32,000 --> 00:17:34,240
multi-party function encryption system

519
00:17:34,240 --> 00:17:36,799
now we substitute n to be the addition

520
00:17:36,799 --> 00:17:39,200
of the secret keys m to be the m is

521
00:17:39,200 --> 00:17:41,840
equal to the one to be the addity of the

522
00:17:41,840 --> 00:17:44,240
sap text and identity be the aggregate

523
00:17:44,240 --> 00:17:46,400
functions in both cases

524
00:17:46,400 --> 00:17:48,480
and now we're going to select the local

525
00:17:48,480 --> 00:17:51,280
mode because it's a multi-authority mode

526
00:17:51,280 --> 00:17:52,480
the setup is going to be formed in a

527
00:17:52,480 --> 00:17:54,559
local mode and this is going to generate

528
00:17:54,559 --> 00:17:56,080
the public keys in the master security

529
00:17:56,080 --> 00:17:57,440
keys for all of these authorities

530
00:17:57,440 --> 00:17:59,200
individually

531
00:17:59,200 --> 00:18:01,200
and the idea is that using all the

532
00:18:01,200 --> 00:18:04,000
master public keys together

533
00:18:04,000 --> 00:18:07,600
uh user can encrypt the uh policy g on

534
00:18:07,600 --> 00:18:08,799
its own

535
00:18:08,799 --> 00:18:10,960
and using all these master secret keys

536
00:18:10,960 --> 00:18:12,320
individually

537
00:18:12,320 --> 00:18:14,480
the authority can generate these partial

538
00:18:14,480 --> 00:18:18,080
decryption keys for inputs y 1 upon y n

539
00:18:18,080 --> 00:18:20,160
and the idea is that the decryption

540
00:18:20,160 --> 00:18:22,559
algorithm combine all these elements and

541
00:18:22,559 --> 00:18:24,559
that will sort of give us the universal

542
00:18:24,559 --> 00:18:26,799
function again on this identity

543
00:18:26,799 --> 00:18:29,360
aggregated function of g and y one of

544
00:18:29,360 --> 00:18:31,679
the y n which can be simplified to be

545
00:18:31,679 --> 00:18:33,440
the evaluation of the function g the

546
00:18:33,440 --> 00:18:35,200
secret function g on the inputs y one

547
00:18:35,200 --> 00:18:36,720
upon i

548
00:18:36,720 --> 00:18:38,640
thereby again matching the syntax of

549
00:18:38,640 --> 00:18:40,080
multi authority actual function

550
00:18:40,080 --> 00:18:42,640
encryption

551
00:18:42,640 --> 00:18:44,000
now

552
00:18:44,000 --> 00:18:46,080
this basically shows that multi-party

553
00:18:46,080 --> 00:18:48,240
function encryption can actually be used

554
00:18:48,240 --> 00:18:50,480
to unify all these extreme encryption

555
00:18:50,480 --> 00:18:51,760
systems

556
00:18:51,760 --> 00:18:52,720
and

557
00:18:52,720 --> 00:18:54,160
looking ahead

558
00:18:54,160 --> 00:18:55,679
can we use multi-party function

559
00:18:55,679 --> 00:18:57,520
encryption to even forecast something

560
00:18:57,520 --> 00:19:01,440
predict new interesting functionalities

561
00:19:01,440 --> 00:19:03,120
now

562
00:19:03,120 --> 00:19:04,880
in this work we actually show that we

563
00:19:04,880 --> 00:19:06,640
can compose function encryption for

564
00:19:06,640 --> 00:19:07,919
different functionalities and user

565
00:19:07,919 --> 00:19:09,600
models to come up with some very

566
00:19:09,600 --> 00:19:11,600
interesting functional functionalities

567
00:19:11,600 --> 00:19:13,039
for example

568
00:19:13,039 --> 00:19:15,120
previously we have only studied multi

569
00:19:15,120 --> 00:19:16,480
authority attribute based encryption

570
00:19:16,480 --> 00:19:18,320
systems or attribute based encryption

571
00:19:18,320 --> 00:19:20,240
systems in which the function spaces

572
00:19:20,240 --> 00:19:22,480
were inner product functionalities now

573
00:19:22,480 --> 00:19:24,320
in this work we say we can actually

574
00:19:24,320 --> 00:19:26,320
combine all of these together to define

575
00:19:26,320 --> 00:19:27,919
something called multi-authority

576
00:19:27,919 --> 00:19:29,360
attribute based inner product functional

577
00:19:29,360 --> 00:19:31,360
encryption systems we can also define

578
00:19:31,360 --> 00:19:33,440
decentralized notions of predicate

579
00:19:33,440 --> 00:19:34,480
encryption

580
00:19:34,480 --> 00:19:36,320
where the message functionality is the

581
00:19:36,320 --> 00:19:37,760
inner product function encryption

582
00:19:37,760 --> 00:19:39,280
functionality

583
00:19:39,280 --> 00:19:40,559
additionally

584
00:19:40,559 --> 00:19:43,120
as i were referring to previously the

585
00:19:43,120 --> 00:19:45,280
notion of dynamic decentralized function

586
00:19:45,280 --> 00:19:47,200
encryption has been defined as very

587
00:19:47,200 --> 00:19:49,120
powerful but unfortunately that notion

588
00:19:49,120 --> 00:19:51,200
does not provide function hiding so we

589
00:19:51,200 --> 00:19:52,880
say that multi-party function encryption

590
00:19:52,880 --> 00:19:55,600
says that ddfe can be extended to define

591
00:19:55,600 --> 00:19:57,280
the function hiding course

592
00:19:57,280 --> 00:19:59,039
counterparts for that

593
00:19:59,039 --> 00:20:00,799
lastly we can also sort of

594
00:20:00,799 --> 00:20:03,840
ask that typically when we look at into

595
00:20:03,840 --> 00:20:06,240
distributed secret key setting for multi

596
00:20:06,240 --> 00:20:06,960
or

597
00:20:06,960 --> 00:20:08,880
for function encryption then in that

598
00:20:08,880 --> 00:20:11,760
case all these different key materials

599
00:20:11,760 --> 00:20:14,240
are typically intended for a single user

600
00:20:14,240 --> 00:20:16,159
it's a single user secret key that is

601
00:20:16,159 --> 00:20:17,600
spread that is generated by multiple

602
00:20:17,600 --> 00:20:18,880
authorities

603
00:20:18,880 --> 00:20:21,120
but what if we want to combine key

604
00:20:21,120 --> 00:20:22,640
materials for different users for

605
00:20:22,640 --> 00:20:24,720
totally different independent users

606
00:20:24,720 --> 00:20:26,559
this is totally unlike multi authority

607
00:20:26,559 --> 00:20:28,240
or decentralized encryption

608
00:20:28,240 --> 00:20:29,840
and this is something that you sort of

609
00:20:29,840 --> 00:20:30,960
formalize

610
00:20:30,960 --> 00:20:33,039
using reputation based encryption and we

611
00:20:33,039 --> 00:20:34,720
show that these are interesting models

612
00:20:34,720 --> 00:20:36,400
that has not been previously studied but

613
00:20:36,400 --> 00:20:37,840
they make sense just because we are

614
00:20:37,840 --> 00:20:39,120
visualizing functional encryption in a

615
00:20:39,120 --> 00:20:42,320
totally multi-party setting

616
00:20:42,400 --> 00:20:45,120
now in this work we also give many new

617
00:20:45,120 --> 00:20:47,679
interesting positive results by giving

618
00:20:47,679 --> 00:20:50,240
new uh function encryption systems

619
00:20:50,240 --> 00:20:52,240
for in them in the multi-user setting

620
00:20:52,240 --> 00:20:54,400
for interesting functionalities from

621
00:20:54,400 --> 00:20:55,760
standards options

622
00:20:55,760 --> 00:20:57,679
just as a quick summary we built

623
00:20:57,679 --> 00:20:59,679
multi-authority attribute based in the

624
00:20:59,679 --> 00:21:01,760
product function encryption systems

625
00:21:01,760 --> 00:21:03,440
where the predicate class is monotone

626
00:21:03,440 --> 00:21:05,360
spam programs and they just rely on

627
00:21:05,360 --> 00:21:08,240
bi-linear groups for uh building such

628
00:21:08,240 --> 00:21:09,520
function classes

629
00:21:09,520 --> 00:21:11,039
we also show that we can build

630
00:21:11,039 --> 00:21:12,640
decentralized attribute based in a

631
00:21:12,640 --> 00:21:14,240
product function encryption systems but

632
00:21:14,240 --> 00:21:16,400
now we also can hide the policy in one

633
00:21:16,400 --> 00:21:18,799
side but then we can only guarantee it

634
00:21:18,799 --> 00:21:20,960
for inner product functionalities in

635
00:21:20,960 --> 00:21:23,360
terms of predicates but again we only

636
00:21:23,360 --> 00:21:25,919
show this by relying on pioneer groups

637
00:21:25,919 --> 00:21:28,320
and you also show that we can lift

638
00:21:28,320 --> 00:21:30,559
the the ddit construction for inner

639
00:21:30,559 --> 00:21:31,760
products

640
00:21:31,760 --> 00:21:33,440
and make it function hiding by just

641
00:21:33,440 --> 00:21:35,039
relying biliary groups in the random

642
00:21:35,039 --> 00:21:37,679
oracle model and lastly we also give how

643
00:21:37,679 --> 00:21:39,200
to distribute ciphertext policy

644
00:21:39,200 --> 00:21:40,960
attribute based encryption systems that

645
00:21:40,960 --> 00:21:43,600
have been recently studied by relying on

646
00:21:43,600 --> 00:21:45,120
assumptions such as learning with errors

647
00:21:45,120 --> 00:21:48,000
and the binding a generic group model

648
00:21:48,000 --> 00:21:49,520
and we additionally also show that we

649
00:21:49,520 --> 00:21:52,799
give interesting feasible results for uh

650
00:21:52,799 --> 00:21:54,480
multi-party function encryptions by

651
00:21:54,480 --> 00:21:55,919
relying on the minimal assumption of

652
00:21:55,919 --> 00:21:57,840
multi-input functional encryptions and i

653
00:21:57,840 --> 00:21:59,039
would just advise you to look at the

654
00:21:59,039 --> 00:22:01,039
paper for all these details because i'm

655
00:22:01,039 --> 00:22:03,039
going to only summarize what we sort of

656
00:22:03,039 --> 00:22:04,559
show in this work

657
00:22:04,559 --> 00:22:06,320
but there are so many interesting

658
00:22:06,320 --> 00:22:08,960
results in our paper

659
00:22:08,960 --> 00:22:11,280
so moving on i'm only going to focus on

660
00:22:11,280 --> 00:22:13,440
the first part of the result and where i

661
00:22:13,440 --> 00:22:15,840
will tell you how to design this multi

662
00:22:15,840 --> 00:22:17,760
authority attribute based inner product

663
00:22:17,760 --> 00:22:19,520
function encryption system for more

664
00:22:19,520 --> 00:22:22,559
return span programs

665
00:22:22,880 --> 00:22:25,039
now moving ahead in order to actually

666
00:22:25,039 --> 00:22:27,200
construct it i have to first define what

667
00:22:27,200 --> 00:22:30,000
multi-authority attribute based ipfe is

668
00:22:30,000 --> 00:22:31,120
because this has not been defined

669
00:22:31,120 --> 00:22:32,320
previously

670
00:22:32,320 --> 00:22:34,159
so first let us recall saftix policy

671
00:22:34,159 --> 00:22:35,760
attribute based encryption and inner

672
00:22:35,760 --> 00:22:37,840
product function encryption

673
00:22:37,840 --> 00:22:39,600
now in a

674
00:22:39,600 --> 00:22:40,799
policy attribute based function

675
00:22:40,799 --> 00:22:42,960
encryption system

676
00:22:42,960 --> 00:22:45,039
we have input spaces in which input

677
00:22:45,039 --> 00:22:48,480
spaces encode a policy circuit phi a

678
00:22:48,480 --> 00:22:50,799
predicated a policy circuit fi and some

679
00:22:50,799 --> 00:22:52,880
payload messages m

680
00:22:52,880 --> 00:22:55,280
and we also have these function spaces

681
00:22:55,280 --> 00:22:58,240
this uh these key spaces which are going

682
00:22:58,240 --> 00:23:00,320
to encode some strings y some input

683
00:23:00,320 --> 00:23:01,440
strings y

684
00:23:01,440 --> 00:23:04,080
and the idea is that the functionality

685
00:23:04,080 --> 00:23:06,080
that attribute-based encryption systems

686
00:23:06,080 --> 00:23:08,640
they compute it is the evaluating the

687
00:23:08,640 --> 00:23:09,919
function f

688
00:23:09,919 --> 00:23:10,720
on

689
00:23:10,720 --> 00:23:11,919
the function f corresponding to the

690
00:23:11,919 --> 00:23:14,960
input y on the input x which encodes

691
00:23:14,960 --> 00:23:18,080
this predicate fee and the payload m

692
00:23:18,080 --> 00:23:20,240
then it's going to give us the message m

693
00:23:20,240 --> 00:23:22,320
the corresponding payload and the

694
00:23:22,320 --> 00:23:24,640
predicate fee as long as

695
00:23:24,640 --> 00:23:27,200
the predicate fee is satisfied on the

696
00:23:27,200 --> 00:23:29,679
key input key attribute y so the key

697
00:23:29,679 --> 00:23:31,760
contains some inputs and the key input

698
00:23:31,760 --> 00:23:33,760
is satisfied on the

699
00:23:33,760 --> 00:23:35,679
on the

700
00:23:35,679 --> 00:23:37,280
predicate then we basically learn the

701
00:23:37,280 --> 00:23:40,240
messaging otherwise we do not

702
00:23:40,240 --> 00:23:43,279
now ipfv simply says that you always

703
00:23:43,279 --> 00:23:45,679
learn something suppose i give you an

704
00:23:45,679 --> 00:23:48,880
encryption of a vector x and then key

705
00:23:48,880 --> 00:23:51,520
for a vector y then ipfv allows

706
00:23:51,520 --> 00:23:54,960
computing inner target of x and y but

707
00:23:54,960 --> 00:23:56,960
nothing else about the

708
00:23:56,960 --> 00:23:58,400
vector x

709
00:23:58,400 --> 00:24:00,159
and that's the notion of identity based

710
00:24:00,159 --> 00:24:02,400
function encryption in abe

711
00:24:02,400 --> 00:24:04,000
there is a notion of fine-grained access

712
00:24:04,000 --> 00:24:05,679
if you satisfy predicate then only you

713
00:24:05,679 --> 00:24:07,840
learn some information in ipfe you

714
00:24:07,840 --> 00:24:09,679
always learn some information but some

715
00:24:09,679 --> 00:24:11,840
partial functional information about the

716
00:24:11,840 --> 00:24:14,080
underlying message space which is uh or

717
00:24:14,080 --> 00:24:17,440
the input space which is x in this case

718
00:24:17,440 --> 00:24:19,520
now a natural question is that okay what

719
00:24:19,520 --> 00:24:22,799
happens if we combine abe and ipfe

720
00:24:22,799 --> 00:24:24,799
now combining a b and ipf we get

721
00:24:24,799 --> 00:24:27,600
attribute based ipfe an attribute based

722
00:24:27,600 --> 00:24:31,600
ipfe now instead of having a message m

723
00:24:31,600 --> 00:24:33,760
as part of the input space as part of

724
00:24:33,760 --> 00:24:35,919
the inputs the ciphertext input space we

725
00:24:35,919 --> 00:24:38,559
have a vector y

726
00:24:38,559 --> 00:24:39,520
and

727
00:24:39,520 --> 00:24:42,480
as part of the uh soft as one of the key

728
00:24:42,480 --> 00:24:45,360
inputs we're going to have this

729
00:24:45,360 --> 00:24:48,960
input w again this input attribute w and

730
00:24:48,960 --> 00:24:51,279
also a key vector v

731
00:24:51,279 --> 00:24:53,279
and the idea is that evaluating this

732
00:24:53,279 --> 00:24:54,880
function f

733
00:24:54,880 --> 00:24:55,760
uh

734
00:24:55,760 --> 00:24:57,520
w and comma v

735
00:24:57,520 --> 00:25:00,240
on the input phi comma u is going to

736
00:25:00,240 --> 00:25:02,559
give us the inner product between u and

737
00:25:02,559 --> 00:25:05,360
vector v so the vector v in the key the

738
00:25:05,360 --> 00:25:07,840
message u the message vector in these in

739
00:25:07,840 --> 00:25:09,200
the scythe text

740
00:25:09,200 --> 00:25:12,480
as long as the predicate is satisfied on

741
00:25:12,480 --> 00:25:14,799
the input attribute on the key attribute

742
00:25:14,799 --> 00:25:17,440
w otherwise we do not learn anything so

743
00:25:17,440 --> 00:25:19,360
if the attribute is satisfied then you

744
00:25:19,360 --> 00:25:21,919
learn some partial evaluation of the

745
00:25:21,919 --> 00:25:24,080
function of the message vector

746
00:25:24,080 --> 00:25:26,080
otherwise you don't learn anything so

747
00:25:26,080 --> 00:25:27,600
this is more powerful than

748
00:25:27,600 --> 00:25:28,960
attribute-based encryption systems

749
00:25:28,960 --> 00:25:30,240
because an attribute in the asymptote

750
00:25:30,240 --> 00:25:32,080
system it is an all-or-nothing

751
00:25:32,080 --> 00:25:34,000
encryption primitive you either learn

752
00:25:34,000 --> 00:25:36,159
everything or you learn nothing in ipfe

753
00:25:36,159 --> 00:25:38,240
you always learn something combine both

754
00:25:38,240 --> 00:25:39,440
of these things you have a more

755
00:25:39,440 --> 00:25:41,360
fine-grained access structure you you

756
00:25:41,360 --> 00:25:43,600
will all you might not learn anything

757
00:25:43,600 --> 00:25:45,039
but even if you might learn something

758
00:25:45,039 --> 00:25:46,240
you might learn just some partial

759
00:25:46,240 --> 00:25:48,240
information

760
00:25:48,240 --> 00:25:50,400
so we can equivalently say that the

761
00:25:50,400 --> 00:25:52,559
function that is being computed here is

762
00:25:52,559 --> 00:25:53,279
the

763
00:25:53,279 --> 00:25:54,799
evaluate is the inner product between

764
00:25:54,799 --> 00:25:57,200
the message vector and the key vector

765
00:25:57,200 --> 00:25:59,120
multiplied by the predicate value

766
00:25:59,120 --> 00:26:00,480
whether the predicate is satisfied or

767
00:26:00,480 --> 00:26:01,360
not

768
00:26:01,360 --> 00:26:02,960
and this notion was very recently

769
00:26:02,960 --> 00:26:05,039
studied by abdallah at all where they

770
00:26:05,039 --> 00:26:07,600
proposed a b ipfe for monotone spam

771
00:26:07,600 --> 00:26:10,320
programs just from bilingual maps and

772
00:26:10,320 --> 00:26:12,559
this was a very interesting result

773
00:26:12,559 --> 00:26:15,600
now in this work we say that's great but

774
00:26:15,600 --> 00:26:17,279
attribute-based encryption systems are

775
00:26:17,279 --> 00:26:18,960
very meaningful in the multi-authority

776
00:26:18,960 --> 00:26:21,600
setting then can we try to decentralize

777
00:26:21,600 --> 00:26:24,400
a b ipfe this notion of fine grain

778
00:26:24,400 --> 00:26:26,000
access structure of attribute based

779
00:26:26,000 --> 00:26:27,919
structure to decent to the

780
00:26:27,919 --> 00:26:29,600
multi-authority setting

781
00:26:29,600 --> 00:26:31,760
and the idea is that we will take this

782
00:26:31,760 --> 00:26:34,320
input this key space these key inputs

783
00:26:34,320 --> 00:26:36,320
and try to distribute them into multiple

784
00:26:36,320 --> 00:26:37,200
keys

785
00:26:37,200 --> 00:26:39,840
now each key vector is going to consist

786
00:26:39,840 --> 00:26:40,559
of

787
00:26:40,559 --> 00:26:43,120
a portion of the key of the of the

788
00:26:43,120 --> 00:26:45,360
keyboard uh a portion of the

789
00:26:45,360 --> 00:26:47,919
of the attribute that we want to satisfy

790
00:26:47,919 --> 00:26:50,080
and the input key vector

791
00:26:50,080 --> 00:26:53,120
and the idea is that combining

792
00:26:53,120 --> 00:26:55,120
the aggregation function will combine

793
00:26:55,120 --> 00:26:58,000
all of these different key inputs

794
00:26:58,000 --> 00:27:00,320
such that it will append simply all the

795
00:27:00,320 --> 00:27:03,279
inputs w1 up to wn into a single input

796
00:27:03,279 --> 00:27:05,279
string into a single attributes based

797
00:27:05,279 --> 00:27:06,480
attribute string

798
00:27:06,480 --> 00:27:08,559
and it basically checks whether the the

799
00:27:08,559 --> 00:27:10,880
key vector that is associated with the

800
00:27:10,880 --> 00:27:13,279
function class that is actually the same

801
00:27:13,279 --> 00:27:15,279
it basically copies the same vector the

802
00:27:15,279 --> 00:27:17,200
key vector and it

803
00:27:17,200 --> 00:27:18,880
appends all the

804
00:27:18,880 --> 00:27:21,120
all the input attributes as which are

805
00:27:21,120 --> 00:27:23,440
part of the different uh different key

806
00:27:23,440 --> 00:27:25,520
inputs

807
00:27:25,520 --> 00:27:27,279
and once you aggregate them then this

808
00:27:27,279 --> 00:27:29,360
basically is just the aggregate function

809
00:27:29,360 --> 00:27:30,880
and since there's only a single

810
00:27:30,880 --> 00:27:33,200
ciphertext you evaluate there's a single

811
00:27:33,200 --> 00:27:35,120
ciphertext on this particular aggregated

812
00:27:35,120 --> 00:27:37,520
function

813
00:27:37,840 --> 00:27:40,080
now how to actually construct go about

814
00:27:40,080 --> 00:27:41,360
constructing such multi-authority

815
00:27:41,360 --> 00:27:44,080
attribute based ipfe schemes

816
00:27:44,080 --> 00:27:46,000
now one could actually start with the

817
00:27:46,000 --> 00:27:48,080
aptly at all construction but due to

818
00:27:48,080 --> 00:27:49,679
some technical reasons you're not able

819
00:27:49,679 --> 00:27:51,600
to make it multi-authority scheme

820
00:27:51,600 --> 00:27:53,840
directly but instead we look back at a

821
00:27:53,840 --> 00:27:56,320
much older scheme of luco and motors

822
00:27:56,320 --> 00:27:58,159
which built multi-authority attribute

823
00:27:58,159 --> 00:27:59,919
based encryption schemes

824
00:27:59,919 --> 00:28:01,039
which don't have any functional

825
00:28:01,039 --> 00:28:03,520
encryption property but it they do have

826
00:28:03,520 --> 00:28:05,440
multi-authority property from bilinear

827
00:28:05,440 --> 00:28:08,320
maps for monotone span programs

828
00:28:08,320 --> 00:28:10,480
and we try to sort of

829
00:28:10,480 --> 00:28:12,559
just move around this uh construction

830
00:28:12,559 --> 00:28:14,720
just to work with it and modify it such

831
00:28:14,720 --> 00:28:17,200
that we can add this ipfe capability to

832
00:28:17,200 --> 00:28:17,919
it

833
00:28:17,919 --> 00:28:19,440
so in order to explain our construction

834
00:28:19,440 --> 00:28:21,600
let me just give you a much simplified

835
00:28:21,600 --> 00:28:24,720
overview of local borders construction

836
00:28:24,720 --> 00:28:26,480
so the look over this construction each

837
00:28:26,480 --> 00:28:29,200
authority it samples a random

838
00:28:29,200 --> 00:28:31,919
a random exponent alpha i

839
00:28:31,919 --> 00:28:34,559
and it sets the encoding of alpha i this

840
00:28:34,559 --> 00:28:36,720
bracket means the encoding of alpha in

841
00:28:36,720 --> 00:28:38,960
the base group as the public key and the

842
00:28:38,960 --> 00:28:40,720
secret key is going to be the

843
00:28:40,720 --> 00:28:43,520
corresponding secret key alpha i

844
00:28:43,520 --> 00:28:46,240
uh corresponding exponent alpha

845
00:28:46,240 --> 00:28:48,320
now in order to generate a secret key

846
00:28:48,320 --> 00:28:51,520
for a attribute bit wi since it's a

847
00:28:51,520 --> 00:28:52,799
multi authority attribute based

848
00:28:52,799 --> 00:28:55,120
encryption scheme we only generate a

849
00:28:55,120 --> 00:28:57,360
secret keys for attribute bits

850
00:28:57,360 --> 00:28:59,600
we don't have any key vectors associated

851
00:28:59,600 --> 00:29:01,200
so recall no key vectors on the

852
00:29:01,200 --> 00:29:02,960
attribute base

853
00:29:02,960 --> 00:29:04,720
and the secret key this partial security

854
00:29:04,720 --> 00:29:06,640
is simply going to be the product of

855
00:29:06,640 --> 00:29:07,840
this

856
00:29:07,840 --> 00:29:11,600
exponent along with the bit wi so if you

857
00:29:11,600 --> 00:29:13,120
satisfy the attribute then you will

858
00:29:13,120 --> 00:29:15,120
learn alpha otherwise you will not learn

859
00:29:15,120 --> 00:29:17,120
alpha i

860
00:29:17,120 --> 00:29:19,120
now let us see how to perform encryption

861
00:29:19,120 --> 00:29:22,080
in this simplified lw11 scheme

862
00:29:22,080 --> 00:29:23,520
the idea is that

863
00:29:23,520 --> 00:29:24,240
the

864
00:29:24,240 --> 00:29:26,880
encryption algorithm takes this input an

865
00:29:26,880 --> 00:29:29,120
access structure a monotone access

866
00:29:29,120 --> 00:29:30,559
structure

867
00:29:30,559 --> 00:29:32,080
which can be which is represented as a

868
00:29:32,080 --> 00:29:34,240
linear secret shading scheme because

869
00:29:34,240 --> 00:29:35,679
this corresponds to the monotone span

870
00:29:35,679 --> 00:29:36,799
programs

871
00:29:36,799 --> 00:29:39,440
and i'm going to simply consider that

872
00:29:39,440 --> 00:29:41,039
it's a very simple active structure a

873
00:29:41,039 --> 00:29:44,480
read once uh a monotone access structure

874
00:29:44,480 --> 00:29:46,159
and the scifix is going to consist of

875
00:29:46,159 --> 00:29:48,640
three components a chem key

876
00:29:48,640 --> 00:29:50,799
and two different scientix components

877
00:29:50,799 --> 00:29:52,399
the first ciphertext component which is

878
00:29:52,399 --> 00:29:55,039
cd2 that's going to simply contain an

879
00:29:55,039 --> 00:29:57,840
encryption of a large vector

880
00:29:57,840 --> 00:30:00,399
uh of random of just random exponents r

881
00:30:00,399 --> 00:30:02,559
one up till rn

882
00:30:02,559 --> 00:30:04,880
and then we will also have the second

883
00:30:04,880 --> 00:30:07,360
component of c ciphertext components and

884
00:30:07,360 --> 00:30:08,880
these second ciphertext components are

885
00:30:08,880 --> 00:30:10,080
going to be

886
00:30:10,080 --> 00:30:12,640
you first we sample a secret vector a

887
00:30:12,640 --> 00:30:14,799
random secret vector s

888
00:30:14,799 --> 00:30:18,000
and we use this access structure a to

889
00:30:18,000 --> 00:30:19,840
secret share this uh

890
00:30:19,840 --> 00:30:22,080
secret share this vector s so this is

891
00:30:22,080 --> 00:30:24,399
our secret and we try to secret shader

892
00:30:24,399 --> 00:30:25,840
using the access structure because the

893
00:30:25,840 --> 00:30:27,679
access structure can be imagined like a

894
00:30:27,679 --> 00:30:29,919
secret sharing scheme

895
00:30:29,919 --> 00:30:32,000
and we basically

896
00:30:32,000 --> 00:30:34,559
encrypt we basically encrypt this

897
00:30:34,559 --> 00:30:36,399
as like an elgamal encryption

898
00:30:36,399 --> 00:30:39,679
where we use the ith user's public key

899
00:30:39,679 --> 00:30:43,520
as the ith public key here and the uh

900
00:30:43,520 --> 00:30:45,600
the randomness exponent ri will be the

901
00:30:45,600 --> 00:30:47,679
randomness of the l comma encryption so

902
00:30:47,679 --> 00:30:50,080
the ith uses public key and the i

903
00:30:50,080 --> 00:30:51,520
randomness coefficient is going to be

904
00:30:51,520 --> 00:30:55,279
used as a masking term for masking the

905
00:30:55,279 --> 00:30:57,440
secret share for the secret s

906
00:30:57,440 --> 00:30:59,279
corresponding to the i th row of the

907
00:30:59,279 --> 00:31:01,519
secret sharing matrix

908
00:31:01,519 --> 00:31:04,640
now the the chem value the capsulation

909
00:31:04,640 --> 00:31:06,320
value of this encryption system is going

910
00:31:06,320 --> 00:31:09,919
to be simply the first element of the

911
00:31:09,919 --> 00:31:12,480
secret s that i sampled randomly

912
00:31:12,480 --> 00:31:14,480
that's going to be the chem value in the

913
00:31:14,480 --> 00:31:16,320
target crew

914
00:31:16,320 --> 00:31:17,600
okay

915
00:31:17,600 --> 00:31:19,760
so now let me actually explain how to

916
00:31:19,760 --> 00:31:21,360
perform decryption and that's going to

917
00:31:21,360 --> 00:31:23,440
clarify all this magic of pioneer maps

918
00:31:23,440 --> 00:31:26,000
now all this magic of algebra

919
00:31:26,000 --> 00:31:28,000
so during decryption we have a cypher

920
00:31:28,000 --> 00:31:28,880
text

921
00:31:28,880 --> 00:31:31,120
and we have a bunch of secret keys for

922
00:31:31,120 --> 00:31:34,559
these different input values

923
00:31:34,559 --> 00:31:36,000
now suppose

924
00:31:36,000 --> 00:31:37,120
we have

925
00:31:37,120 --> 00:31:39,200
now since we have like an accepting

926
00:31:39,200 --> 00:31:41,360
input then there must be a vector a

927
00:31:41,360 --> 00:31:43,760
reconstruction vector such that

928
00:31:43,760 --> 00:31:46,480
we can use this reconstruction vector

929
00:31:46,480 --> 00:31:48,799
take linear combinations of the rows of

930
00:31:48,799 --> 00:31:50,399
the axis structure a

931
00:31:50,399 --> 00:31:52,080
and come up with the

932
00:31:52,080 --> 00:31:54,480
row vector such that the first column

933
00:31:54,480 --> 00:31:56,320
the first vector the first element of

934
00:31:56,320 --> 00:31:58,240
that row vector is going to be a one

935
00:31:58,240 --> 00:32:00,399
this is the property of linear uh secret

936
00:32:00,399 --> 00:32:02,080
sharing schemes that linearly we can

937
00:32:02,080 --> 00:32:04,720
combine these secret sharing schemes

938
00:32:04,720 --> 00:32:07,279
to come up with the the

939
00:32:07,279 --> 00:32:08,880
to come up with the first basis vector

940
00:32:08,880 --> 00:32:11,360
in the canonical basis vector

941
00:32:11,360 --> 00:32:13,200
now once we compute

942
00:32:13,200 --> 00:32:15,440
such a reconstruction vector the idea is

943
00:32:15,440 --> 00:32:16,960
as follows

944
00:32:16,960 --> 00:32:20,159
we first compute some term k1 this k1

945
00:32:20,159 --> 00:32:22,720
term is basically we take all these key

946
00:32:22,720 --> 00:32:23,760
terms

947
00:32:23,760 --> 00:32:25,200
these key terms for these different

948
00:32:25,200 --> 00:32:27,200
users which are l gamma encryptions

949
00:32:27,200 --> 00:32:29,440
basically for these different users

950
00:32:29,440 --> 00:32:30,320
and we

951
00:32:30,320 --> 00:32:31,519
align them in

952
00:32:31,519 --> 00:32:34,320
a in a in a row vector and take the

953
00:32:34,320 --> 00:32:36,559
inner product of this row vector

954
00:32:36,559 --> 00:32:38,640
with our secret sharing terms with our

955
00:32:38,640 --> 00:32:41,120
with our reconstruction terms

956
00:32:41,120 --> 00:32:43,120
now these are in the target group so we

957
00:32:43,120 --> 00:32:44,640
basically raise it to the exponents and

958
00:32:44,640 --> 00:32:46,159
perform the multiplication the data

959
00:32:46,159 --> 00:32:47,600
group

960
00:32:47,600 --> 00:32:49,679
next we also have these reconstruction

961
00:32:49,679 --> 00:32:50,720
vectors

962
00:32:50,720 --> 00:32:53,600
we multiply each reconstruction vector

963
00:32:53,600 --> 00:32:55,840
individually to the corresponding secret

964
00:32:55,840 --> 00:32:56,960
key

965
00:32:56,960 --> 00:32:59,360
we raise it to that exponent

966
00:32:59,360 --> 00:33:01,519
and then we basically

967
00:33:01,519 --> 00:33:04,399
uh compute this we basically take the

968
00:33:04,399 --> 00:33:06,559
inner product between this vector the

969
00:33:06,559 --> 00:33:08,159
secret key vector

970
00:33:08,159 --> 00:33:09,360
and this

971
00:33:09,360 --> 00:33:11,200
and the ciphertext vector which encodes

972
00:33:11,200 --> 00:33:12,799
these randomness coefficients for the

973
00:33:12,799 --> 00:33:15,200
corresponding l command integrations

974
00:33:15,200 --> 00:33:17,840
and finally my claim is that if i just

975
00:33:17,840 --> 00:33:20,320
uh divide the k1 term by the k2 term

976
00:33:20,320 --> 00:33:21,919
then that's going to give me the gain

977
00:33:21,919 --> 00:33:23,279
encapsulation

978
00:33:23,279 --> 00:33:24,399
vector

979
00:33:24,399 --> 00:33:26,640
now let me actually show it to you

980
00:33:26,640 --> 00:33:28,960
so first if we try to simplify the k1

981
00:33:28,960 --> 00:33:30,960
term then we are going to resolve in

982
00:33:30,960 --> 00:33:32,559
this following value because i'm

983
00:33:32,559 --> 00:33:34,080
multiplying this i'm taking the inner

984
00:33:34,080 --> 00:33:35,440
product of the vector z construction

985
00:33:35,440 --> 00:33:36,880
vector z w

986
00:33:36,880 --> 00:33:39,360
with cti uh

987
00:33:39,360 --> 00:33:42,720
ct 1 comma i for all i in that case i'll

988
00:33:42,720 --> 00:33:45,440
multiply these zwi coefficients with the

989
00:33:45,440 --> 00:33:48,960
corresponding cdi ct1i terms and that's

990
00:33:48,960 --> 00:33:50,720
going to give me this term

991
00:33:50,720 --> 00:33:53,919
similarly i compute uh this simplifies

992
00:33:53,919 --> 00:33:55,760
this key to term and this keto term can

993
00:33:55,760 --> 00:33:58,159
also be satisfied k2 term can also be

994
00:33:58,159 --> 00:34:00,159
satisfied uh can be simplified as

995
00:34:00,159 --> 00:34:01,279
follows

996
00:34:01,279 --> 00:34:03,600
a linear combination of uh these

997
00:34:03,600 --> 00:34:05,360
reconstruction vectors using these

998
00:34:05,360 --> 00:34:06,799
linear reconstruction vectors as

999
00:34:06,799 --> 00:34:08,159
coefficients

1000
00:34:08,159 --> 00:34:11,839
of the terms these alpha iri because

1001
00:34:11,839 --> 00:34:14,399
ri is the these are randomness terms

1002
00:34:14,399 --> 00:34:16,560
that are computed using this that are

1003
00:34:16,560 --> 00:34:19,440
present in the soft text and alphas are

1004
00:34:19,440 --> 00:34:23,679
the secret terms that are given to me

1005
00:34:23,679 --> 00:34:26,079
once i compute this i can basically just

1006
00:34:26,079 --> 00:34:27,918
divide them out and that's going to give

1007
00:34:27,918 --> 00:34:30,239
me the term zwi

1008
00:34:30,239 --> 00:34:31,760
inner product with the

1009
00:34:31,760 --> 00:34:33,040
uh just

1010
00:34:33,040 --> 00:34:35,040
multiplied with

1011
00:34:35,040 --> 00:34:35,760
the

1012
00:34:35,760 --> 00:34:38,159
uh the inner product of the row vector

1013
00:34:38,159 --> 00:34:40,560
the i throw vector and the uh secret

1014
00:34:40,560 --> 00:34:41,520
vector

1015
00:34:41,520 --> 00:34:43,119
and by the linear secret shading

1016
00:34:43,119 --> 00:34:44,960
properties we get that this is going to

1017
00:34:44,960 --> 00:34:47,440
give me the first element

1018
00:34:47,440 --> 00:34:49,199
of the secret vector s

1019
00:34:49,199 --> 00:34:51,520
and which is exactly my chem value

1020
00:34:51,520 --> 00:34:54,480
so basically the idea is that

1021
00:34:54,480 --> 00:34:57,599
you have to view the scifix as

1022
00:34:57,599 --> 00:35:00,079
elgamal encryptions of the ith secret

1023
00:35:00,079 --> 00:35:01,280
share

1024
00:35:01,280 --> 00:35:04,400
th row of this axis structure is enables

1025
00:35:04,400 --> 00:35:06,480
us the computing the secret share of the

1026
00:35:06,480 --> 00:35:08,079
secret vector s

1027
00:35:08,079 --> 00:35:10,720
we perform the l gamma encryption

1028
00:35:10,720 --> 00:35:13,520
and the chem value is simply the first

1029
00:35:13,520 --> 00:35:15,680
element of the secret shared value it's

1030
00:35:15,680 --> 00:35:17,359
this first element just because we're

1031
00:35:17,359 --> 00:35:18,880
computing our reconstruction vector in

1032
00:35:18,880 --> 00:35:20,400
this following way so that we can

1033
00:35:20,400 --> 00:35:22,720
compute the first uh the first basis

1034
00:35:22,720 --> 00:35:25,839
vector in the canonical vector

1035
00:35:25,920 --> 00:35:28,320
and that's the high level idea behind

1036
00:35:28,320 --> 00:35:30,000
the the of what it's construction now

1037
00:35:30,000 --> 00:35:32,160
i'm actually really uh throwing a lot of

1038
00:35:32,160 --> 00:35:33,599
details under the drug but i'm not

1039
00:35:33,599 --> 00:35:35,040
talking about the global identifier

1040
00:35:35,040 --> 00:35:36,560
model or a lot of other technical

1041
00:35:36,560 --> 00:35:38,400
details but this more or less captures

1042
00:35:38,400 --> 00:35:39,200
the

1043
00:35:39,200 --> 00:35:40,960
the core construction the core ideas

1044
00:35:40,960 --> 00:35:44,000
behind the what is construction

1045
00:35:44,000 --> 00:35:45,280
now

1046
00:35:45,280 --> 00:35:47,920
our idea trying to so we want to take

1047
00:35:47,920 --> 00:35:49,520
this multi authority attribute based

1048
00:35:49,520 --> 00:35:52,480
nutrition scheme and add ipfe flamework

1049
00:35:52,480 --> 00:35:55,119
to it ipf flavor to it so how to upgrade

1050
00:35:55,119 --> 00:35:56,160
it

1051
00:35:56,160 --> 00:35:58,400
and then a natural first thought is to

1052
00:35:58,400 --> 00:36:00,240
use ideas that have been developed in

1053
00:36:00,240 --> 00:36:02,400
the literature already

1054
00:36:02,400 --> 00:36:05,119
just show us that we can def we can lift

1055
00:36:05,119 --> 00:36:06,880
any public encryption scheme which has

1056
00:36:06,880 --> 00:36:09,280
some nice homomorphic properties to any

1057
00:36:09,280 --> 00:36:10,960
identity to any inner product function

1058
00:36:10,960 --> 00:36:12,960
encryption scheme

1059
00:36:12,960 --> 00:36:14,560
and the crux in those constructions will

1060
00:36:14,560 --> 00:36:16,320
rely on the homophilic structure of the

1061
00:36:16,320 --> 00:36:18,400
pk public encryption schemes

1062
00:36:18,400 --> 00:36:20,800
and the point is that each vector bit

1063
00:36:20,800 --> 00:36:23,040
will be encoded using independent public

1064
00:36:23,040 --> 00:36:24,240
key

1065
00:36:24,240 --> 00:36:26,880
and now encryption for a vector is

1066
00:36:26,880 --> 00:36:29,119
simply a linear combination of all these

1067
00:36:29,119 --> 00:36:31,359
underlying pkgs

1068
00:36:31,359 --> 00:36:33,200
so we have these underlying pk secret

1069
00:36:33,200 --> 00:36:34,960
keys you linearly combine them and

1070
00:36:34,960 --> 00:36:36,480
that's going to be a decryption key for

1071
00:36:36,480 --> 00:36:38,800
that particular uh secret vector that

1072
00:36:38,800 --> 00:36:42,000
you have and now during decryption the

1073
00:36:42,000 --> 00:36:44,480
user is going to homomorphically compute

1074
00:36:44,480 --> 00:36:46,720
just homophobic compute these different

1075
00:36:46,720 --> 00:36:49,599
individual pk keys pksiph text into a

1076
00:36:49,599 --> 00:36:52,320
single pke ciphertext and that single p

1077
00:36:52,320 --> 00:36:54,800
key ciphers can be decrypted using its

1078
00:36:54,800 --> 00:36:58,000
linearly combined uh pk key that

1079
00:36:58,000 --> 00:37:01,599
received as part of its decryption key

1080
00:37:01,760 --> 00:37:02,520
and

1081
00:37:02,520 --> 00:37:04,880
unfortunately this idea does not work

1082
00:37:04,880 --> 00:37:07,119
it's a very clean and elegant idea but

1083
00:37:07,119 --> 00:37:08,880
it does not seem to work for current

1084
00:37:08,880 --> 00:37:10,240
multi-authority attribute-based

1085
00:37:10,240 --> 00:37:12,079
encryption schemes that we have

1086
00:37:12,079 --> 00:37:13,760
or let me add a little bit of well let

1087
00:37:13,760 --> 00:37:16,560
me see with the caviar

1088
00:37:16,560 --> 00:37:18,480
we actually show it on paper that we can

1089
00:37:18,480 --> 00:37:20,800
use this framework this other framework

1090
00:37:20,800 --> 00:37:23,599
this abdallah doll framework to go from

1091
00:37:23,599 --> 00:37:25,359
multi authority ap to multi authority

1092
00:37:25,359 --> 00:37:27,920
attribute based ipfe but only for the

1093
00:37:27,920 --> 00:37:30,480
classes of inner product predicates

1094
00:37:30,480 --> 00:37:32,160
but if you want to go to monotone spam

1095
00:37:32,160 --> 00:37:34,079
programs then we have to rely on some

1096
00:37:34,079 --> 00:37:36,640
other cool ideas

1097
00:37:36,640 --> 00:37:38,400
and very briefly the problem here is

1098
00:37:38,400 --> 00:37:39,200
that

1099
00:37:39,200 --> 00:37:41,200
typically in the above idea in the above

1100
00:37:41,200 --> 00:37:43,760
pk to ibf lifting theorem idea

1101
00:37:43,760 --> 00:37:45,119
the chem key

1102
00:37:45,119 --> 00:37:46,800
the the chem key is the underlying

1103
00:37:46,800 --> 00:37:48,880
decryption key that is actually chosen

1104
00:37:48,880 --> 00:37:50,880
during decryption encryption time

1105
00:37:50,880 --> 00:37:53,119
thus it can be linearly combined

1106
00:37:53,119 --> 00:37:54,560
when you have to give that particular

1107
00:37:54,560 --> 00:37:56,800
linear combination to a particular user

1108
00:37:56,800 --> 00:37:58,560
as its partial key

1109
00:37:58,560 --> 00:38:00,320
but the chem key in the local orders

1110
00:38:00,320 --> 00:38:01,920
construction if you look at the chem key

1111
00:38:01,920 --> 00:38:03,760
in the local waters construction that is

1112
00:38:03,760 --> 00:38:06,320
chosen during encryption time not at

1113
00:38:06,320 --> 00:38:07,520
setup time

1114
00:38:07,520 --> 00:38:10,240
thus it is unclear how to actually give

1115
00:38:10,240 --> 00:38:13,040
linear combinations of the chem key

1116
00:38:13,040 --> 00:38:15,520
as part of the partial as part of the

1117
00:38:15,520 --> 00:38:16,880
key generation process because that's

1118
00:38:16,880 --> 00:38:20,160
chosen during the encryption time

1119
00:38:20,640 --> 00:38:22,000
now with that

1120
00:38:22,000 --> 00:38:23,599
let us just here look at the simple

1121
00:38:23,599 --> 00:38:24,880
trigger that we came from this work and

1122
00:38:24,880 --> 00:38:26,480
the idea is very simple

1123
00:38:26,480 --> 00:38:27,760
the idea is that

1124
00:38:27,760 --> 00:38:29,680
if we look very closely at the lugorus

1125
00:38:29,680 --> 00:38:30,960
construction then we will observe that

1126
00:38:30,960 --> 00:38:33,040
the chem terms are actually masked with

1127
00:38:33,040 --> 00:38:34,880
each authority's master secret key using

1128
00:38:34,880 --> 00:38:37,520
the algamal encryption

1129
00:38:37,520 --> 00:38:38,400
and

1130
00:38:38,400 --> 00:38:40,720
we simply have to give a projection of

1131
00:38:40,720 --> 00:38:42,400
these unmasking terms instead of a

1132
00:38:42,400 --> 00:38:44,400
projection of the chem terms and linear

1133
00:38:44,400 --> 00:38:45,920
combination can be regarded as a

1134
00:38:45,920 --> 00:38:47,040
projection

1135
00:38:47,040 --> 00:38:48,160
and previously we were giving a

1136
00:38:48,160 --> 00:38:50,480
projection of the pkgs now we only have

1137
00:38:50,480 --> 00:38:51,599
to give out a projection of these

1138
00:38:51,599 --> 00:38:53,200
unmasking terms

1139
00:38:53,200 --> 00:38:54,800
which the authority each authority does

1140
00:38:54,800 --> 00:38:56,079
know

1141
00:38:56,079 --> 00:38:58,480
and now the lss reconstruction these

1142
00:38:58,480 --> 00:39:00,160
linear secret shielding reconstruction

1143
00:39:00,160 --> 00:39:01,920
they only touch the rows of the

1144
00:39:01,920 --> 00:39:04,000
matrix a now we can perform the

1145
00:39:04,000 --> 00:39:05,760
projection on the columns so that there

1146
00:39:05,760 --> 00:39:07,040
won't be any

1147
00:39:07,040 --> 00:39:09,119
uh mandling that's going to happen the

1148
00:39:09,119 --> 00:39:10,880
reconstruction happens on the row side

1149
00:39:10,880 --> 00:39:12,480
the projection happens on the column

1150
00:39:12,480 --> 00:39:14,880
side so that's why these comp these

1151
00:39:14,880 --> 00:39:16,400
these operations these algebraic

1152
00:39:16,400 --> 00:39:18,160
operations are totally independent and

1153
00:39:18,160 --> 00:39:20,640
do not affect each other

1154
00:39:20,640 --> 00:39:22,320
and a very crucial important fact is

1155
00:39:22,320 --> 00:39:24,000
that we have to rely on the fact that

1156
00:39:24,000 --> 00:39:25,440
the randomness for the underlying

1157
00:39:25,440 --> 00:39:28,000
encryption systems has to be used across

1158
00:39:28,000 --> 00:39:29,599
different masking terms

1159
00:39:29,599 --> 00:39:31,760
otherwise uh the entire framework

1160
00:39:31,760 --> 00:39:33,119
doesn't work and you have to be very

1161
00:39:33,119 --> 00:39:35,440
careful with this i'll elaborate more on

1162
00:39:35,440 --> 00:39:38,000
that in the coming few slides

1163
00:39:38,000 --> 00:39:40,000
but let me just give you a very high

1164
00:39:40,000 --> 00:39:41,839
level overview of how to actually

1165
00:39:41,839 --> 00:39:44,160
upgrade this loop what is construction

1166
00:39:44,160 --> 00:39:47,119
to when i do a multi-authority abi pfv

1167
00:39:47,119 --> 00:39:48,079
scheme

1168
00:39:48,079 --> 00:39:50,800
so this is the luca orders construction

1169
00:39:50,800 --> 00:39:52,640
i'm just copying this from two slides

1170
00:39:52,640 --> 00:39:53,680
ago

1171
00:39:53,680 --> 00:39:56,880
and let's just update it step by step

1172
00:39:56,880 --> 00:39:58,720
following the intuition that i said that

1173
00:39:58,720 --> 00:40:01,440
you're going to sort of give projections

1174
00:40:01,440 --> 00:40:03,760
of the masking terms that each authority

1175
00:40:03,760 --> 00:40:05,520
computes and each authorities masking

1176
00:40:05,520 --> 00:40:07,520
terms are these

1177
00:40:07,520 --> 00:40:10,400
as these random exponents

1178
00:40:10,400 --> 00:40:11,440
so first

1179
00:40:11,440 --> 00:40:13,359
we switch out the setup algorithm

1180
00:40:13,359 --> 00:40:16,240
instead of sampling a single uh exponent

1181
00:40:16,240 --> 00:40:18,640
we sample us a sequence of exponents a

1182
00:40:18,640 --> 00:40:20,160
large vector of exponents where the

1183
00:40:20,160 --> 00:40:22,400
number of exponents is the same

1184
00:40:22,400 --> 00:40:23,760
is the length of the vectors that we

1185
00:40:23,760 --> 00:40:25,760
want to actually give out an ipefe you

1186
00:40:25,760 --> 00:40:28,240
want to design an ipv system for

1187
00:40:28,240 --> 00:40:30,400
so we'd have those many exponents each

1188
00:40:30,400 --> 00:40:32,480
authority sample so many exponents and

1189
00:40:32,480 --> 00:40:34,640
now the secret key

1190
00:40:34,640 --> 00:40:36,960
is going to be instead of

1191
00:40:36,960 --> 00:40:38,640
that particular secret key given out in

1192
00:40:38,640 --> 00:40:41,200
public if you satisfy the attribute it's

1193
00:40:41,200 --> 00:40:44,160
the inner product of your masking term

1194
00:40:44,160 --> 00:40:46,319
with the key term with the key vector w

1195
00:40:46,319 --> 00:40:48,160
in the top of your secret key and the

1196
00:40:48,160 --> 00:40:49,280
inner product

1197
00:40:49,280 --> 00:40:51,760
and then multiplied by whether you are

1198
00:40:51,760 --> 00:40:53,280
satisfied that particular attribute or

1199
00:40:53,280 --> 00:40:55,520
not

1200
00:40:56,240 --> 00:40:58,640
now pretty natural so far

1201
00:40:58,640 --> 00:41:00,319
now let's see how to actually perform

1202
00:41:00,319 --> 00:41:02,720
encryption during encryption we now also

1203
00:41:02,720 --> 00:41:04,400
have this message vector this message

1204
00:41:04,400 --> 00:41:07,520
vector u and instead of now having a

1205
00:41:07,520 --> 00:41:08,319
chem

1206
00:41:08,319 --> 00:41:10,480
mechanism because it's no longer an uh

1207
00:41:10,480 --> 00:41:12,160
all or nothing encryption system it's an

1208
00:41:12,160 --> 00:41:13,760
functional encryption system it's an ipf

1209
00:41:13,760 --> 00:41:15,680
encryption system we have to actually

1210
00:41:15,680 --> 00:41:18,160
encrypt the message vector itself

1211
00:41:18,160 --> 00:41:20,960
so our id is as follows

1212
00:41:20,960 --> 00:41:22,480
we will keep the second component of the

1213
00:41:22,480 --> 00:41:24,720
ciphertext as before the cd2 is going to

1214
00:41:24,720 --> 00:41:27,119
stay the same but now the first formula

1215
00:41:27,119 --> 00:41:29,839
ciphertext the ct1com i components

1216
00:41:29,839 --> 00:41:31,440
previously you are sampling just a

1217
00:41:31,440 --> 00:41:34,079
single secret vector and performing the

1218
00:41:34,079 --> 00:41:36,079
secret shading just once

1219
00:41:36,079 --> 00:41:38,000
for each row now we're going to perform

1220
00:41:38,000 --> 00:41:40,720
the secret shading n times

1221
00:41:40,720 --> 00:41:43,359
for each row n times and basically we

1222
00:41:43,359 --> 00:41:45,920
need to sample a secret matrix x

1223
00:41:45,920 --> 00:41:49,119
multiply a i times with s and just we're

1224
00:41:49,119 --> 00:41:52,160
going to use all our uh elgamal secrets

1225
00:41:52,160 --> 00:41:54,640
elgamal public keys for the i throw in

1226
00:41:54,640 --> 00:41:56,720
order to mask this particular secret

1227
00:41:56,720 --> 00:41:58,560
value the crucial part is that we have

1228
00:41:58,560 --> 00:42:01,200
to rely on the same randomness for all

1229
00:42:01,200 --> 00:42:03,119
these independent l command values and

1230
00:42:03,119 --> 00:42:04,800
common encryptions

1231
00:42:04,800 --> 00:42:07,119
pretty cool so that seems to fit like

1232
00:42:07,119 --> 00:42:10,160
the absolute all translation great

1233
00:42:10,160 --> 00:42:12,240
and now just to actually tie things up

1234
00:42:12,240 --> 00:42:15,119
we have to uh do the following now this

1235
00:42:15,119 --> 00:42:17,040
third side compromise text that's going

1236
00:42:17,040 --> 00:42:20,160
to be the one-time pad basically we hide

1237
00:42:20,160 --> 00:42:22,000
the message vector using a one-time pad

1238
00:42:22,000 --> 00:42:24,400
where the one-time pad key is the first

1239
00:42:24,400 --> 00:42:26,319
row of the secret vector

1240
00:42:26,319 --> 00:42:27,839
of the secret matrix previously we were

1241
00:42:27,839 --> 00:42:30,160
using the first element of the secret

1242
00:42:30,160 --> 00:42:32,240
matrix of the secret vector now we're

1243
00:42:32,240 --> 00:42:33,839
going to use the entire secret the first

1244
00:42:33,839 --> 00:42:36,160
row of the secret secret matrix in order

1245
00:42:36,160 --> 00:42:38,720
to mask this term

1246
00:42:38,720 --> 00:42:41,119
and naturally the idea is for decryption

1247
00:42:41,119 --> 00:42:43,280
is also pretty similar we basically

1248
00:42:43,280 --> 00:42:45,920
update the k1 first step where

1249
00:42:45,920 --> 00:42:47,920
previously we just taking the inner

1250
00:42:47,920 --> 00:42:49,440
product between the

1251
00:42:49,440 --> 00:42:51,200
the ciphertext vectors

1252
00:42:51,200 --> 00:42:53,440
and the reconstruction vector now we are

1253
00:42:53,440 --> 00:42:55,520
also going to take the the the right

1254
00:42:55,520 --> 00:42:57,200
multiply with the reconstruction vectors

1255
00:42:57,200 --> 00:42:59,440
but we left multiply with the key vector

1256
00:42:59,440 --> 00:43:01,599
that we have

1257
00:43:01,599 --> 00:43:02,319
so

1258
00:43:02,319 --> 00:43:04,400
on the right side on the basically the

1259
00:43:04,400 --> 00:43:05,839
row side of the matrix we're going to

1260
00:43:05,839 --> 00:43:07,280
perform reconstruction and the on the

1261
00:43:07,280 --> 00:43:08,720
column side of the matrix we're going to

1262
00:43:08,720 --> 00:43:12,480
perform this projection

1263
00:43:12,480 --> 00:43:14,000
in order to compute the output we're

1264
00:43:14,000 --> 00:43:15,599
basically going to first compute the

1265
00:43:15,599 --> 00:43:16,720
inner product between the third

1266
00:43:16,720 --> 00:43:19,040
component of the ciphertext with the key

1267
00:43:19,040 --> 00:43:21,599
vector and just uh come up with these

1268
00:43:21,599 --> 00:43:24,000
masking terms appropriately multiply and

1269
00:43:24,000 --> 00:43:25,839
divide them and then that will give you

1270
00:43:25,839 --> 00:43:28,000
the inner product of the message vector

1271
00:43:28,000 --> 00:43:31,200
u with your key vector w with your key

1272
00:43:31,200 --> 00:43:32,240
vector v

1273
00:43:32,240 --> 00:43:34,480
as soon as long as you actually satisfy

1274
00:43:34,480 --> 00:43:36,960
uh as as long as you sort of satisfy

1275
00:43:36,960 --> 00:43:38,400
your attribute satisfy the access

1276
00:43:38,400 --> 00:43:39,680
structure

1277
00:43:39,680 --> 00:43:41,440
and mathematically we can sort of just

1278
00:43:41,440 --> 00:43:43,920
uh check again the same math works out

1279
00:43:43,920 --> 00:43:45,760
the algebra works out

1280
00:43:45,760 --> 00:43:47,680
and it's not a very interesting thing to

1281
00:43:47,680 --> 00:43:48,720
look at

1282
00:43:48,720 --> 00:43:50,560
but what is more crucial is that the

1283
00:43:50,560 --> 00:43:53,200
science text here actually shares the

1284
00:43:53,200 --> 00:43:55,119
randomness coefficients across all these

1285
00:43:55,119 --> 00:43:58,720
different uh all these different

1286
00:43:58,720 --> 00:44:01,760
algorithms or these encrypt binary terms

1287
00:44:01,760 --> 00:44:03,920
and typically this was not a problem in

1288
00:44:03,920 --> 00:44:07,680
the the pke to ipfe lifting theorems

1289
00:44:07,680 --> 00:44:08,960
but

1290
00:44:08,960 --> 00:44:10,319
it turns out to be a little bit of a

1291
00:44:10,319 --> 00:44:11,280
problem

1292
00:44:11,280 --> 00:44:12,800
in the case of attribute-based

1293
00:44:12,800 --> 00:44:14,720
encryption systems and the ideology as

1294
00:44:14,720 --> 00:44:16,240
follows

1295
00:44:16,240 --> 00:44:17,520
so the first drive would be trying to

1296
00:44:17,520 --> 00:44:18,960
just simply merge the loop overs

1297
00:44:18,960 --> 00:44:21,440
constructions and the pka to ipf lifting

1298
00:44:21,440 --> 00:44:22,720
theorems these transformations and

1299
00:44:22,720 --> 00:44:24,400
trying to combine these proofs in an

1300
00:44:24,400 --> 00:44:25,680
almost

1301
00:44:25,680 --> 00:44:28,000
black box way i'm just trying to combine

1302
00:44:28,000 --> 00:44:29,599
these proofs and just being done with

1303
00:44:29,599 --> 00:44:30,480
that

1304
00:44:30,480 --> 00:44:32,480
unfortunately that does not work the

1305
00:44:32,480 --> 00:44:34,720
reason is that lucoris relies on these

1306
00:44:34,720 --> 00:44:36,480
dual system techniques these dual system

1307
00:44:36,480 --> 00:44:37,920
paradigms

1308
00:44:37,920 --> 00:44:40,560
and this dual system paradigms relies on

1309
00:44:40,560 --> 00:44:42,560
the notion of semi-functional ciphertex

1310
00:44:42,560 --> 00:44:45,280
distributions where the ciphertext no

1311
00:44:45,280 --> 00:44:47,520
longer work for basically the challenge

1312
00:44:47,520 --> 00:44:49,440
ciphertext when you switch it to a

1313
00:44:49,440 --> 00:44:51,359
semi-functional circuit it is no longer

1314
00:44:51,359 --> 00:44:52,800
a good ciphertext for all the secret

1315
00:44:52,800 --> 00:44:54,960
keys that you have to give it out for

1316
00:44:54,960 --> 00:44:56,400
and uh

1317
00:44:56,400 --> 00:44:58,880
ideas from pka to ipfree are no longer

1318
00:44:58,880 --> 00:45:01,200
applicable because we cannot switch i

1319
00:45:01,200 --> 00:45:02,720
challenge soft text to a completely

1320
00:45:02,720 --> 00:45:04,400
semi-functional ciphertext

1321
00:45:04,400 --> 00:45:06,800
because our scifix can potentially be

1322
00:45:06,800 --> 00:45:08,400
decrypted

1323
00:45:08,400 --> 00:45:10,240
on a large number of

1324
00:45:10,240 --> 00:45:12,720
it is possible we allow decrypting our

1325
00:45:12,720 --> 00:45:14,240
challenge soft text on a large number of

1326
00:45:14,240 --> 00:45:15,599
keys and learning some partial

1327
00:45:15,599 --> 00:45:17,599
information about the message vector if

1328
00:45:17,599 --> 00:45:19,920
you're only trying to say that uh if you

1329
00:45:19,920 --> 00:45:21,920
don't have any distinguishing keys then

1330
00:45:21,920 --> 00:45:23,359
you should not be able to learn the

1331
00:45:23,359 --> 00:45:25,040
underlying message the underlying you

1332
00:45:25,040 --> 00:45:25,920
should not be able to distinguish the

1333
00:45:25,920 --> 00:45:28,400
underlying message vector

1334
00:45:28,400 --> 00:45:30,640
but you do have accepting keys in

1335
00:45:30,640 --> 00:45:32,000
traditional multi-authority attribute

1336
00:45:32,000 --> 00:45:33,839
based encryption systems you do not have

1337
00:45:33,839 --> 00:45:36,240
any accepting keys here we do have

1338
00:45:36,240 --> 00:45:38,319
accepting keys because the accepting

1339
00:45:38,319 --> 00:45:40,240
keys have the property that the

1340
00:45:40,240 --> 00:45:42,319
evaluation of both the challenge

1341
00:45:42,319 --> 00:45:44,160
messages is going to be the same the

1342
00:45:44,160 --> 00:45:45,440
challenge vectors the two challenge

1343
00:45:45,440 --> 00:45:47,280
vectors are going to give the same inner

1344
00:45:47,280 --> 00:45:49,760
product to the key vector if you have an

1345
00:45:49,760 --> 00:45:52,880
accepting key and that causes a problem

1346
00:45:52,880 --> 00:45:54,079
now i don't have enough time to actually

1347
00:45:54,079 --> 00:45:55,680
tell you how to get around this problem

1348
00:45:55,680 --> 00:45:58,319
but the main idea in a nutshell is uh

1349
00:45:58,319 --> 00:45:59,520
simple again

1350
00:45:59,520 --> 00:46:01,200
so to that end we actually introduce a

1351
00:46:01,200 --> 00:46:03,599
new notion of semi-functional soft text

1352
00:46:03,599 --> 00:46:05,520
that we call partial semi-functional

1353
00:46:05,520 --> 00:46:08,079
soft text which is very crucial to

1354
00:46:08,079 --> 00:46:09,760
extend the notion of semi-functional

1355
00:46:09,760 --> 00:46:11,599
scientists to this function encryption

1356
00:46:11,599 --> 00:46:12,720
regime

1357
00:46:12,720 --> 00:46:15,119
where the idea is that these scythe

1358
00:46:15,119 --> 00:46:18,000
texts are going to be nominally semi

1359
00:46:18,000 --> 00:46:19,680
semi-functional across all but one

1360
00:46:19,680 --> 00:46:22,160
projected subspace so there are so many

1361
00:46:22,160 --> 00:46:24,000
different subspace in the underlying

1362
00:46:24,000 --> 00:46:26,319
message indian like science text right

1363
00:46:26,319 --> 00:46:28,560
and it's only one particular subspace

1364
00:46:28,560 --> 00:46:30,319
where we have to perform the

1365
00:46:30,319 --> 00:46:31,200
the

1366
00:46:31,200 --> 00:46:33,040
the magic of dual systems paradigm but

1367
00:46:33,040 --> 00:46:34,560
for all the other subspaces we don't

1368
00:46:34,560 --> 00:46:36,079
have to perform the magic of dual

1369
00:46:36,079 --> 00:46:38,480
systems paradigm but over there we can't

1370
00:46:38,480 --> 00:46:40,480
treat them as independent subspaces

1371
00:46:40,480 --> 00:46:42,000
because all these are tied using the

1372
00:46:42,000 --> 00:46:44,079
same random terms same randomness

1373
00:46:44,079 --> 00:46:45,760
coefficients so we have to actually

1374
00:46:45,760 --> 00:46:47,200
define something called nominal

1375
00:46:47,200 --> 00:46:49,440
semi-functional semi-functionality for

1376
00:46:49,440 --> 00:46:50,880
all these other

1377
00:46:50,880 --> 00:46:53,119
uh inputs all these other projection

1378
00:46:53,119 --> 00:46:55,280
spaces but for the challenge projection

1379
00:46:55,280 --> 00:46:57,119
space we have to actually rely on this

1380
00:46:57,119 --> 00:46:59,520
make it completely semi-functional and i

1381
00:46:59,520 --> 00:47:00,800
refer you to look at the paper for

1382
00:47:00,800 --> 00:47:02,720
interesting details it's a pretty uh

1383
00:47:02,720 --> 00:47:05,440
it's a pretty neat notion of uh

1384
00:47:05,440 --> 00:47:07,599
partial semi-functional security and i

1385
00:47:07,599 --> 00:47:09,119
believe it's going to be very meaningful

1386
00:47:09,119 --> 00:47:11,839
if we sort of try to push this forward

1387
00:47:11,839 --> 00:47:13,520
and try to come up with more interesting

1388
00:47:13,520 --> 00:47:16,240
uh notions in trying to combine

1389
00:47:16,240 --> 00:47:17,680
multi authority or attribute for your

1390
00:47:17,680 --> 00:47:19,280
function encryption systems with other

1391
00:47:19,280 --> 00:47:21,119
type of functional systems because this

1392
00:47:21,119 --> 00:47:24,079
is going to appear again again

1393
00:47:24,079 --> 00:47:26,000
now just trying to summarize in this

1394
00:47:26,000 --> 00:47:27,599
work we gave a lot of

1395
00:47:27,599 --> 00:47:29,760
we proposed this incredible notion of

1396
00:47:29,760 --> 00:47:30,960
multi-party functional encryption

1397
00:47:30,960 --> 00:47:32,960
systems and we gave these amazing new

1398
00:47:32,960 --> 00:47:35,040
positive results and i was able to only

1399
00:47:35,040 --> 00:47:36,880
describe to you this multi authority a b

1400
00:47:36,880 --> 00:47:39,359
ipf systems compliant by linear groups

1401
00:47:39,359 --> 00:47:41,520
but we also have a bunch of other

1402
00:47:41,520 --> 00:47:43,119
interesting function classes that we

1403
00:47:43,119 --> 00:47:45,440
show that we can realize that we can

1404
00:47:45,440 --> 00:47:47,280
actually instantiate very simply using

1405
00:47:47,280 --> 00:47:49,440
multi-party function encryption systems

1406
00:47:49,440 --> 00:47:51,040
this framework of mpfe and we can

1407
00:47:51,040 --> 00:47:52,400
actually give new constructions for

1408
00:47:52,400 --> 00:47:54,079
these things

1409
00:47:54,079 --> 00:47:56,480
finally trying to include this uh

1410
00:47:56,480 --> 00:47:58,400
talk i described the notion of

1411
00:47:58,400 --> 00:48:01,119
multi-party functional encryption system

1412
00:48:01,119 --> 00:48:02,079
and

1413
00:48:02,079 --> 00:48:03,920
the multi-party functionalism system is

1414
00:48:03,920 --> 00:48:05,920
a universal is an amazing framework it's

1415
00:48:05,920 --> 00:48:08,319
a univ in is a unifier which comes with

1416
00:48:08,319 --> 00:48:10,319
this simple framework trying to come up

1417
00:48:10,319 --> 00:48:12,400
with a framework for all multi-user

1418
00:48:12,400 --> 00:48:13,599
encryption systems in the function

1419
00:48:13,599 --> 00:48:14,960
encryption energy

1420
00:48:14,960 --> 00:48:17,440
it enables abstraction technical ideas

1421
00:48:17,440 --> 00:48:19,760
across user models so we developed some

1422
00:48:19,760 --> 00:48:22,079
use some nice ideas in the ipfv

1423
00:48:22,079 --> 00:48:23,599
landscape we developed some interesting

1424
00:48:23,599 --> 00:48:25,200
ideas in the multi-authority landscape

1425
00:48:25,200 --> 00:48:27,280
as we saw and we were able to sort of

1426
00:48:27,280 --> 00:48:29,119
abstract these ideas in a more coherent

1427
00:48:29,119 --> 00:48:31,280
way and use them

1428
00:48:31,280 --> 00:48:34,160
to get something more out of it and it

1429
00:48:34,160 --> 00:48:36,400
also this mpfe it also makes it easier

1430
00:48:36,400 --> 00:48:38,240
to interpolate the space of unexplored

1431
00:48:38,240 --> 00:48:40,480
functionalities like we were able to say

1432
00:48:40,480 --> 00:48:42,240
okay hey we can combine multi authority

1433
00:48:42,240 --> 00:48:44,000
attribute based encryption and ipf you

1434
00:48:44,000 --> 00:48:46,000
can come up with a totally new uh

1435
00:48:46,000 --> 00:48:48,400
primitive we can combine the

1436
00:48:48,400 --> 00:48:50,079
decentralized critical encryption or

1437
00:48:50,079 --> 00:48:52,240
ipfe you can combine policy hiding

1438
00:48:52,240 --> 00:48:54,319
encryption or we can combine distributed

1439
00:48:54,319 --> 00:48:56,160
uh dynamic decentralized functional

1440
00:48:56,160 --> 00:48:58,000
encryption systems and to get something

1441
00:48:58,000 --> 00:49:00,079
more so there are so many interesting

1442
00:49:00,079 --> 00:49:02,000
unexplored functionalities that are out

1443
00:49:02,000 --> 00:49:05,040
there and uh yeah it would be wonderful

1444
00:49:05,040 --> 00:49:06,480
if you can actually just come with a

1445
00:49:06,480 --> 00:49:08,000
more systematic approach of trying to

1446
00:49:08,000 --> 00:49:09,119
sort of come up with those

1447
00:49:09,119 --> 00:49:10,720
functionalities

1448
00:49:10,720 --> 00:49:12,319
and there's so many fascinating open

1449
00:49:12,319 --> 00:49:13,280
questions

1450
00:49:13,280 --> 00:49:15,440
and as i was listening to earlier we

1451
00:49:15,440 --> 00:49:17,359
built some natural functionalities from

1452
00:49:17,359 --> 00:49:19,359
assumptions and with that i would like

1453
00:49:19,359 --> 00:49:20,960
to take a leave thank you for listening

1454
00:49:20,960 --> 00:49:23,040
and the paper is online and the apron

1455
00:49:23,040 --> 00:49:25,520
number is 20 20 1 2 6 6. thank you for

1456
00:49:25,520 --> 00:49:28,520
listening

