1
00:00:00,080 --> 00:00:02,480
hello this is myanmarana and i'm going

2
00:00:02,480 --> 00:00:04,640
to talk about our work title asyclicity

3
00:00:04,640 --> 00:00:06,720
programming for sigma protocols

4
00:00:06,720 --> 00:00:08,960
this is joint work with massive ave

5
00:00:08,960 --> 00:00:12,320
andrey bogdanov alon rosen and miyako

6
00:00:12,320 --> 00:00:13,599
okubo

7
00:00:13,599 --> 00:00:15,360
in his work we present a new technique

8
00:00:15,360 --> 00:00:17,279
for combining sigma protocols

9
00:00:17,279 --> 00:00:19,119
three move protocols that can be used to

10
00:00:19,119 --> 00:00:20,720
obtain very performance your knowledge

11
00:00:20,720 --> 00:00:22,000
proof systems

12
00:00:22,000 --> 00:00:23,600
zero knowledge proof systems were

13
00:00:23,600 --> 00:00:25,840
devised by goldbazzer michallian rakkov

14
00:00:25,840 --> 00:00:27,920
in 1985.

15
00:00:27,920 --> 00:00:30,240
they allow a particle prover to convince

16
00:00:30,240 --> 00:00:32,479
a possibly skeptical verifier

17
00:00:32,479 --> 00:00:33,920
of the validity of a certain

18
00:00:33,920 --> 00:00:36,640
mathematical theorem

19
00:00:36,640 --> 00:00:39,040
the prover has a proof of the theorem

20
00:00:39,040 --> 00:00:40,719
but she does not want to share it with

21
00:00:40,719 --> 00:00:41,920
the ray fire

22
00:00:41,920 --> 00:00:44,000
instead she wants to convince him of the

23
00:00:44,000 --> 00:00:46,239
ability of the statement that is of the

24
00:00:46,239 --> 00:00:48,160
fact that the theorem is true

25
00:00:48,160 --> 00:00:49,920
but without revealing any information

26
00:00:49,920 --> 00:00:51,360
about her proof

27
00:00:51,360 --> 00:00:52,879
as your knowledge brief system is

28
00:00:52,879 --> 00:00:54,800
essentially a protocol that allows them

29
00:00:54,800 --> 00:00:56,480
to achieve this goal

30
00:00:56,480 --> 00:00:58,160
after changing a few messages the

31
00:00:58,160 --> 00:01:00,239
verifier will be convinced about the

32
00:01:00,239 --> 00:01:02,239
validity of the statement

33
00:01:02,239 --> 00:01:04,239
or even about the fact that the approver

34
00:01:04,239 --> 00:01:06,000
knows a proof

35
00:01:06,000 --> 00:01:07,920
but will have not learned anything in

36
00:01:07,920 --> 00:01:10,560
this process

37
00:01:10,640 --> 00:01:12,400
only that fact

38
00:01:12,400 --> 00:01:14,960
in this stock we will use x to refer to

39
00:01:14,960 --> 00:01:16,640
theorems or statements

40
00:01:16,640 --> 00:01:19,600
and we will use w to refer to proofs or

41
00:01:19,600 --> 00:01:20,880
witnesses

42
00:01:20,880 --> 00:01:22,799
we use an empiriculation r to express

43
00:01:22,799 --> 00:01:25,439
the fact that the certain witness w is

44
00:01:25,439 --> 00:01:26,720
valid with respect to a certain

45
00:01:26,720 --> 00:01:28,960
statement x

46
00:01:28,960 --> 00:01:30,479
zero knowledge proof system is said to

47
00:01:30,479 --> 00:01:31,680
be complete

48
00:01:31,680 --> 00:01:34,880
if an honest verifier always accepts

49
00:01:34,880 --> 00:01:36,720
after interacting with an honest prover

50
00:01:36,720 --> 00:01:39,439
who really knows a proof

51
00:01:39,439 --> 00:01:41,360
and it must also satisfy two other

52
00:01:41,360 --> 00:01:43,200
properties called soundness and zero

53
00:01:43,200 --> 00:01:46,079
knowledge roughly soundness protects the

54
00:01:46,079 --> 00:01:48,000
verifier in the sense that it is

55
00:01:48,000 --> 00:01:50,720
impossible or extremely unlikely that he

56
00:01:50,720 --> 00:01:52,840
will accept the proof of a false

57
00:01:52,840 --> 00:01:54,960
statement on the other hand serial

58
00:01:54,960 --> 00:01:57,040
knowledge protects the approver in the

59
00:01:57,040 --> 00:01:58,799
sense that the verifier will not learn

60
00:01:58,799 --> 00:02:01,520
any information about her proof

61
00:02:01,520 --> 00:02:03,439
a sigma protocol is a three-move

62
00:02:03,439 --> 00:02:05,520
protocol that can be used to obtain very

63
00:02:05,520 --> 00:02:07,680
efficiency or knowledge proof systems

64
00:02:07,680 --> 00:02:10,160
remarkably a signal protocol must

65
00:02:10,160 --> 00:02:12,800
satisfy two very simple properties that

66
00:02:12,800 --> 00:02:15,360
could be seen as simpler versions of

67
00:02:15,360 --> 00:02:17,520
soundness and sheer knowledge

68
00:02:17,520 --> 00:02:19,200
they are called spatial soundness and

69
00:02:19,200 --> 00:02:21,520
honest verifies your knowledge

70
00:02:21,520 --> 00:02:23,040
we are going to illustrate what a sigma

71
00:02:23,040 --> 00:02:25,440
protocol is with a classical example of

72
00:02:25,440 --> 00:02:28,400
proven knowledge of a discrete logarithm

73
00:02:28,400 --> 00:02:31,519
this is the celebrated protocol by snore

74
00:02:31,519 --> 00:02:34,000
consider group of prime order p

75
00:02:34,000 --> 00:02:36,640
generated by a certain element key

76
00:02:36,640 --> 00:02:38,879
and consider relation r

77
00:02:38,879 --> 00:02:41,200
the following protocol will allow prover

78
00:02:41,200 --> 00:02:42,879
to argue knowledge of the discrete

79
00:02:42,879 --> 00:02:46,640
logarithm w of x in base g

80
00:02:46,640 --> 00:02:48,640
the protocol works as follows

81
00:02:48,640 --> 00:02:50,319
the proof first commits to some

82
00:02:50,319 --> 00:02:51,920
relevance r

83
00:02:51,920 --> 00:02:53,040
that is

84
00:02:53,040 --> 00:02:56,319
prover samples are uniformly from set p

85
00:02:56,319 --> 00:02:58,000
and sends a

86
00:02:58,000 --> 00:03:00,319
computed as g to the power of r to the

87
00:03:00,319 --> 00:03:01,920
verifier

88
00:03:01,920 --> 00:03:05,040
the verifier then samples a challenge e

89
00:03:05,040 --> 00:03:07,440
uniformly from set b

90
00:03:07,440 --> 00:03:09,120
finally the proof of response with the

91
00:03:09,120 --> 00:03:11,519
valued set which will be computed as

92
00:03:11,519 --> 00:03:14,800
shown in picture if the river is honest

93
00:03:14,800 --> 00:03:17,680
the verifier will accept the proof if g

94
00:03:17,680 --> 00:03:21,519
to the power of the received c equals a

95
00:03:21,519 --> 00:03:24,720
times x to the power of e

96
00:03:24,720 --> 00:03:27,360
this protocol is to special sound

97
00:03:27,360 --> 00:03:28,879
because after

98
00:03:28,879 --> 00:03:32,239
a is transmitted approver who does not

99
00:03:32,239 --> 00:03:34,799
know w will only be able to answer

100
00:03:34,799 --> 00:03:36,159
correctly

101
00:03:36,159 --> 00:03:39,120
to one value of e among all the values

102
00:03:39,120 --> 00:03:41,120
in set p in other words and more

103
00:03:41,120 --> 00:03:43,200
formally this protocol is two special

104
00:03:43,200 --> 00:03:45,599
sound because given two transcripts

105
00:03:45,599 --> 00:03:48,319
with the same first message a

106
00:03:48,319 --> 00:03:51,040
that satisfy the verification equation

107
00:03:51,040 --> 00:03:52,799
the witness can be extracted in

108
00:03:52,799 --> 00:03:55,680
polynomial time

109
00:03:57,920 --> 00:03:59,360
this protocol

110
00:03:59,360 --> 00:04:01,120
is also

111
00:04:01,120 --> 00:04:03,439
honest verifier zero knowledge because

112
00:04:03,439 --> 00:04:06,959
given an instance x and a challenge e

113
00:04:06,959 --> 00:04:10,319
one can efficiently produce a transcript

114
00:04:10,319 --> 00:04:13,680
that is valid with respect to x

115
00:04:13,680 --> 00:04:15,680
and identically distributed to the

116
00:04:15,680 --> 00:04:18,399
transcript that two honest parties would

117
00:04:18,399 --> 00:04:19,918
produce

118
00:04:19,918 --> 00:04:22,240
in the rest of this stock we will denote

119
00:04:22,240 --> 00:04:24,639
by capital c and set

120
00:04:24,639 --> 00:04:27,680
the algorithms run by the prover

121
00:04:27,680 --> 00:04:29,919
and we will denote by v

122
00:04:29,919 --> 00:04:33,040
the final check by the verifier

123
00:04:33,040 --> 00:04:35,040
we also denote by s

124
00:04:35,040 --> 00:04:37,360
which stands for simulator

125
00:04:37,360 --> 00:04:39,120
the algorithm that produces a valid

126
00:04:39,120 --> 00:04:42,479
transcript from x and e

127
00:04:42,479 --> 00:04:44,560
in general the syntax of these

128
00:04:44,560 --> 00:04:47,040
algorithms is as follows

129
00:04:47,040 --> 00:04:49,520
note that algorithm c

130
00:04:49,520 --> 00:04:52,320
is allowed to use x and w in general

131
00:04:52,320 --> 00:04:54,400
although in the example these values

132
00:04:54,400 --> 00:04:56,639
were not used to compute a

133
00:04:56,639 --> 00:04:58,320
the properties that the sigma protocol

134
00:04:58,320 --> 00:05:00,720
must satisfy are weaker than those of as

135
00:05:00,720 --> 00:05:02,479
your knowledge-proof system

136
00:05:02,479 --> 00:05:04,479
this makes it much easier to build and

137
00:05:04,479 --> 00:05:06,560
reasonable sigma protocols

138
00:05:06,560 --> 00:05:07,600
however

139
00:05:07,600 --> 00:05:09,440
without much effort

140
00:05:09,440 --> 00:05:11,960
they can be transformed into actual

141
00:05:11,960 --> 00:05:13,520
serializations

142
00:05:13,520 --> 00:05:15,440
or arguments of knowledge

143
00:05:15,440 --> 00:05:17,600
one way to do so is to use the fiat

144
00:05:17,600 --> 00:05:19,360
shimmer heuristic

145
00:05:19,360 --> 00:05:21,360
which consists of replacing the very

146
00:05:21,360 --> 00:05:25,440
fire by a hash function in particular

147
00:05:25,440 --> 00:05:26,800
affiliate proof

148
00:05:26,800 --> 00:05:28,400
consists

149
00:05:28,400 --> 00:05:31,840
of an accepting transcript a e and z

150
00:05:31,840 --> 00:05:33,919
where e is equal to the hash function

151
00:05:33,919 --> 00:05:37,600
evaluated on x concatenated with a

152
00:05:37,600 --> 00:05:39,759
if the hash function h is modeled as a

153
00:05:39,759 --> 00:05:41,600
programmable random article the

154
00:05:41,600 --> 00:05:43,840
resulting protocol is an uninteractive

155
00:05:43,840 --> 00:05:47,039
knowledge argument of knowledge

156
00:05:47,039 --> 00:05:49,759
it is a natural question to ask whether

157
00:05:49,759 --> 00:05:51,680
it is possible to compose several sigma

158
00:05:51,680 --> 00:05:53,199
protocols together

159
00:05:53,199 --> 00:05:56,000
the cds 94 composition technique

160
00:05:56,000 --> 00:05:58,400
provides very good tools to do so by

161
00:05:58,400 --> 00:06:01,199
manipulating the challenge string

162
00:06:01,199 --> 00:06:02,240
suppose

163
00:06:02,240 --> 00:06:04,560
that we are given two sigma protocols

164
00:06:04,560 --> 00:06:06,319
the first one with respect to a certain

165
00:06:06,319 --> 00:06:08,560
relation r1 and the second one with

166
00:06:08,560 --> 00:06:10,960
respect to r2

167
00:06:10,960 --> 00:06:12,960
we can form a new sigma protocol for the

168
00:06:12,960 --> 00:06:15,520
predicate that joins in conjunction r1

169
00:06:15,520 --> 00:06:16,800
and r2

170
00:06:16,800 --> 00:06:18,720
by running both sigma protocols in

171
00:06:18,720 --> 00:06:22,400
parallel with the same challenge

172
00:06:27,360 --> 00:06:28,639
if instead

173
00:06:28,639 --> 00:06:31,039
we want to combine the relations in this

174
00:06:31,039 --> 00:06:34,000
junction

175
00:06:34,000 --> 00:06:36,160
it is enough to run parallel copies of

176
00:06:36,160 --> 00:06:37,840
the protocols

177
00:06:37,840 --> 00:06:40,319
this time with individual charges e1 and

178
00:06:40,319 --> 00:06:41,280
e2

179
00:06:41,280 --> 00:06:43,759
that can be chosen by the prover but are

180
00:06:43,759 --> 00:06:45,919
bound to satisfy the following equation

181
00:06:45,919 --> 00:06:47,680
with respect to the verifier's challenge

182
00:06:47,680 --> 00:06:49,280
e

183
00:06:49,280 --> 00:06:50,720
this way

184
00:06:50,720 --> 00:06:52,160
it is enough to know one of the

185
00:06:52,160 --> 00:06:54,639
witnesses in order to complete a proof

186
00:06:54,639 --> 00:06:56,479
for example if the approver does not

187
00:06:56,479 --> 00:06:58,400
know a witness for x2

188
00:06:58,400 --> 00:07:01,199
she can choose e2 first and simulate the

189
00:07:01,199 --> 00:07:03,280
second transcript with it

190
00:07:03,280 --> 00:07:07,039
she will then compute a1 normally

191
00:07:07,039 --> 00:07:09,440
when challenge e is known she will set

192
00:07:09,440 --> 00:07:12,560
e1 to be e x4 e2

193
00:07:12,560 --> 00:07:14,319
and complete the first trash card using

194
00:07:14,319 --> 00:07:16,720
the witness w1

195
00:07:16,720 --> 00:07:19,360
this idea generalizes to compositions

196
00:07:19,360 --> 00:07:22,080
and their more complex predicates as

197
00:07:22,080 --> 00:07:24,400
long as there exists a suitable sharing

198
00:07:24,400 --> 00:07:26,000
of the challenge string

199
00:07:26,000 --> 00:07:28,240
indeed it is known that the cds

200
00:07:28,240 --> 00:07:30,400
composition can be used to compose

201
00:07:30,400 --> 00:07:32,160
single protocols in a pretty in a

202
00:07:32,160 --> 00:07:34,800
predicate expressed as mono as a molar

203
00:07:34,800 --> 00:07:36,479
transparent program on the atomic

204
00:07:36,479 --> 00:07:38,400
predicates

205
00:07:38,400 --> 00:07:41,120
it is remarkable that the cds-94

206
00:07:41,120 --> 00:07:43,919
technique is a real composition in the

207
00:07:43,919 --> 00:07:46,400
sense that it maps sigma protocols to

208
00:07:46,400 --> 00:07:47,919
signal protocols

209
00:07:47,919 --> 00:07:50,240
or to a signal protocol

210
00:07:50,240 --> 00:07:51,840
furthermore it needs no extra

211
00:07:51,840 --> 00:07:55,039
assumptions like random oracles

212
00:07:55,039 --> 00:07:56,960
on the other hand this technique is

213
00:07:56,960 --> 00:07:59,039
limited in the sense that the new sigma

214
00:07:59,039 --> 00:08:01,440
protocol size is proportional

215
00:08:01,440 --> 00:08:04,080
to the formula size or marginally

216
00:08:04,080 --> 00:08:06,319
to the spam program size of the

217
00:08:06,319 --> 00:08:08,560
composing predicate

218
00:08:08,560 --> 00:08:10,160
note that the representation of some

219
00:08:10,160 --> 00:08:12,800
anatom predicates as a spawn program can

220
00:08:12,800 --> 00:08:15,520
be large an example is directed

221
00:08:15,520 --> 00:08:18,160
connectivity as we will see later

222
00:08:18,160 --> 00:08:20,720
another very important disjunctive

223
00:08:20,720 --> 00:08:23,440
composition technique is als

224
00:08:23,440 --> 00:08:26,720
also known as sequential composition

225
00:08:26,720 --> 00:08:29,120
it can be seen as a generalized version

226
00:08:29,120 --> 00:08:31,280
of the fiat sharing heuristic in this

227
00:08:31,280 --> 00:08:32,320
case

228
00:08:32,320 --> 00:08:34,880
challenge e2 will be computed as the

229
00:08:34,880 --> 00:08:36,479
hash of a1

230
00:08:36,479 --> 00:08:38,640
and channel g1 will be computed as a

231
00:08:38,640 --> 00:08:41,039
hash of a2

232
00:08:41,039 --> 00:08:42,799
for security

233
00:08:42,799 --> 00:08:44,240
one may also need to include the

234
00:08:44,240 --> 00:08:47,360
statements x1 and x2 inside both hashes

235
00:08:47,360 --> 00:08:48,720
but we've made these values for

236
00:08:48,720 --> 00:08:51,839
simplicity and for highlighting the r1

237
00:08:51,839 --> 00:08:53,839
and a2 in each hash

238
00:08:53,839 --> 00:08:57,120
again this induces a proof of system

239
00:08:57,120 --> 00:08:59,279
for the disjunction of the original

240
00:08:59,279 --> 00:09:01,600
predicates in particular knowing one

241
00:09:01,600 --> 00:09:03,519
witness is enough to officially produce

242
00:09:03,519 --> 00:09:05,120
a valid proof

243
00:09:05,120 --> 00:09:07,120
suppose that the prover only knows i

244
00:09:07,120 --> 00:09:08,880
wouldn't ask for

245
00:09:08,880 --> 00:09:12,320
x1 i want this double and one for x1

246
00:09:12,320 --> 00:09:14,320
she can compute the first message a1

247
00:09:14,320 --> 00:09:15,600
normally

248
00:09:15,600 --> 00:09:18,880
and this will unlock the value of e2

249
00:09:18,880 --> 00:09:20,720
from e2 the prover can simulate the

250
00:09:20,720 --> 00:09:22,480
second transcript without knowing the

251
00:09:22,480 --> 00:09:23,920
witness for it

252
00:09:23,920 --> 00:09:27,600
and this will set the value for a2

253
00:09:27,600 --> 00:09:29,839
which unlocks c1 now the prover can

254
00:09:29,839 --> 00:09:31,680
complete the first transcript by using

255
00:09:31,680 --> 00:09:33,360
w1

256
00:09:33,360 --> 00:09:35,440
this protocol can proven to be

257
00:09:35,440 --> 00:09:37,760
an interactive serial knowledge argument

258
00:09:37,760 --> 00:09:39,839
of knowledge in the programmable random

259
00:09:39,839 --> 00:09:41,440
oracle model

260
00:09:41,440 --> 00:09:43,920
observe that the aos technique can be

261
00:09:43,920 --> 00:09:46,480
generalized to cycles of other lengths

262
00:09:46,480 --> 00:09:48,320
not just two

263
00:09:48,320 --> 00:09:50,160
we can join three sigma protocols in

264
00:09:50,160 --> 00:09:52,000
this junction with the following

265
00:09:52,000 --> 00:09:55,200
challenge dependencies

266
00:09:58,800 --> 00:10:00,880
this approach leads to a ring signature

267
00:10:00,880 --> 00:10:01,839
scheme

268
00:10:01,839 --> 00:10:03,920
that can be used to combine schnorr and

269
00:10:03,920 --> 00:10:05,440
rsa signatures

270
00:10:05,440 --> 00:10:07,600
one of the main applications mentioned

271
00:10:07,600 --> 00:10:10,959
in the work by abeoku and suzuki

272
00:10:10,959 --> 00:10:12,640
furthermore this technique has been

273
00:10:12,640 --> 00:10:14,800
recently revisited and shown to be

274
00:10:14,800 --> 00:10:17,279
useful for proving affordability in the

275
00:10:17,279 --> 00:10:20,800
non-programmable random oracle model

276
00:10:20,800 --> 00:10:23,200
in this work we extend the aos technique

277
00:10:23,200 --> 00:10:25,120
to and consider more general structures

278
00:10:25,120 --> 00:10:26,720
than just a circle

279
00:10:26,720 --> 00:10:28,399
for example say we have four sigma

280
00:10:28,399 --> 00:10:29,600
protocols

281
00:10:29,600 --> 00:10:31,440
each of them represented by a node in

282
00:10:31,440 --> 00:10:33,200
the following graph

283
00:10:33,200 --> 00:10:34,880
where arrows represent challenge

284
00:10:34,880 --> 00:10:37,519
dependencies

285
00:10:38,079 --> 00:10:40,480
if there is an arrow from node i to node

286
00:10:40,480 --> 00:10:41,519
j

287
00:10:41,519 --> 00:10:44,160
we can say that j depends on i in the

288
00:10:44,160 --> 00:10:47,279
sense that a i the first message of the

289
00:10:47,279 --> 00:10:50,000
transcript for single protocol i

290
00:10:50,000 --> 00:10:52,160
must be included in the elements that

291
00:10:52,160 --> 00:10:55,120
are hashed to compute challenge ej

292
00:10:55,120 --> 00:10:58,079
corresponding to signal protocol j

293
00:10:58,079 --> 00:11:00,399
for example given that node 3

294
00:11:00,399 --> 00:11:03,360
has incoming edges from node 1 and node

295
00:11:03,360 --> 00:11:04,399
4

296
00:11:04,399 --> 00:11:07,360
challenge e3 is computed as the hash of

297
00:11:07,360 --> 00:11:09,760
a1 and a4

298
00:11:09,760 --> 00:11:12,320
it turns out that doing so will give us

299
00:11:12,320 --> 00:11:14,000
a proving system for a composed

300
00:11:14,000 --> 00:11:16,079
statement of the sigma protocol

301
00:11:16,079 --> 00:11:17,360
predicates

302
00:11:17,360 --> 00:11:19,760
but what compost terminates

303
00:11:19,760 --> 00:11:21,680
in this example the compost segment is

304
00:11:21,680 --> 00:11:22,720
exactly

305
00:11:22,720 --> 00:11:25,440
this monotone formula

306
00:11:25,440 --> 00:11:27,360
note that the formula is expressed in

307
00:11:27,360 --> 00:11:29,920
conjunctive normal form or cnf

308
00:11:29,920 --> 00:11:32,560
and each disjunctive clause involves

309
00:11:32,560 --> 00:11:35,360
literals whose associated nodes form a

310
00:11:35,360 --> 00:11:38,399
cycle in the graph

311
00:11:38,720 --> 00:11:40,640
to illustrate the probing process

312
00:11:40,640 --> 00:11:44,480
suppose approver holds a witness w1

313
00:11:44,480 --> 00:11:47,920
and also w3 for statements x1 and x3

314
00:11:47,920 --> 00:11:50,640
respectively

315
00:11:50,880 --> 00:11:51,760
note

316
00:11:51,760 --> 00:11:53,600
that this set of witnesses represents a

317
00:11:53,600 --> 00:11:56,800
satisfying assignment of the formula

318
00:11:56,800 --> 00:11:58,959
the approval will proceed as follows it

319
00:11:58,959 --> 00:12:01,040
will first start normally the

320
00:12:01,040 --> 00:12:03,120
transcripts for sigma protocol 1 and

321
00:12:03,120 --> 00:12:05,760
second protocol 3.

322
00:12:05,760 --> 00:12:07,920
this will relax all dependencies that

323
00:12:07,920 --> 00:12:11,120
involve a1 or a3 so let's remove all

324
00:12:11,120 --> 00:12:13,920
outgoing edges from nodes 1 and

325
00:12:13,920 --> 00:12:16,240
3.

326
00:12:16,880 --> 00:12:20,000
now observe that that node 2 has no

327
00:12:20,000 --> 00:12:21,839
incoming edges

328
00:12:21,839 --> 00:12:24,480
this means that its challenge can be

329
00:12:24,480 --> 00:12:27,120
already computed

330
00:12:27,120 --> 00:12:29,600
certainly as you can see e2 should be

331
00:12:29,600 --> 00:12:30,880
the hash

332
00:12:30,880 --> 00:12:33,920
of a1 concatenated with a3 values that

333
00:12:33,920 --> 00:12:36,720
have already been set

334
00:12:36,720 --> 00:12:38,560
the brewer can therefore

335
00:12:38,560 --> 00:12:41,200
compute e2 and use it to simulate the

336
00:12:41,200 --> 00:12:42,959
second

337
00:12:42,959 --> 00:12:46,319
sigma protocols transcript

338
00:12:46,560 --> 00:12:48,800
but this will set a value for e2 so all

339
00:12:48,800 --> 00:12:50,720
dependencies from

340
00:12:50,720 --> 00:12:53,279
a2 are now relaxed

341
00:12:53,279 --> 00:12:55,279
let's remove all outgoing edges from

342
00:12:55,279 --> 00:12:57,920
node 2.

343
00:12:57,920 --> 00:13:00,079
finally note that node 4

344
00:13:00,079 --> 00:13:02,880
has no incoming ages now

345
00:13:02,880 --> 00:13:05,040
so at this point the brewer can compute

346
00:13:05,040 --> 00:13:08,000
e4 and use it to simulate transcript for

347
00:13:08,000 --> 00:13:11,040
single protocol 4.

348
00:13:11,519 --> 00:13:14,399
finally this will unlock the value

349
00:13:14,399 --> 00:13:17,440
of challenges e1 and e3

350
00:13:17,440 --> 00:13:18,839
and the prover can finish the

351
00:13:18,839 --> 00:13:22,000
transcripts 1 and 3 by using witnesses

352
00:13:22,000 --> 00:13:24,959
w1 and w3

353
00:13:24,959 --> 00:13:26,480
on the other hand

354
00:13:26,480 --> 00:13:28,880
let's see how approver without enough

355
00:13:28,880 --> 00:13:30,959
witnesses to satisfy formula will have a

356
00:13:30,959 --> 00:13:32,720
problem to complete the proof

357
00:13:32,720 --> 00:13:35,040
consider approver who has witnesses w2

358
00:13:35,040 --> 00:13:37,200
and w3

359
00:13:37,200 --> 00:13:38,560
and note that these witnesses don't

360
00:13:38,560 --> 00:13:40,160
satisfy the formula

361
00:13:40,160 --> 00:13:43,120
if we proceed as before removing edges

362
00:13:43,120 --> 00:13:46,399
of transcripts whose value a

363
00:13:46,399 --> 00:13:48,399
is already chosen

364
00:13:48,399 --> 00:13:51,360
we will end up in this situation

365
00:13:51,360 --> 00:13:53,760
where i note that all nodes have

366
00:13:53,760 --> 00:13:55,360
incoming edges

367
00:13:55,360 --> 00:13:57,760
so the prover has a problem now because

368
00:13:57,760 --> 00:14:01,600
without witnesses x 4x1 or x4

369
00:14:01,600 --> 00:14:04,320
the prover cannot start transcripts 1

370
00:14:04,320 --> 00:14:05,440
nor 4

371
00:14:05,440 --> 00:14:07,120
because with overwhelming probability

372
00:14:07,120 --> 00:14:09,760
she will not be able to complete them

373
00:14:09,760 --> 00:14:12,639
one may think that any monotone formula

374
00:14:12,639 --> 00:14:15,839
in cnf can be translated into a graph by

375
00:14:15,839 --> 00:14:18,160
having one note per statement

376
00:14:18,160 --> 00:14:20,880
and including cycles in the graph

377
00:14:20,880 --> 00:14:23,680
for every disjunctive clause

378
00:14:23,680 --> 00:14:26,160
unfortunately this is not always true

379
00:14:26,160 --> 00:14:29,600
consider the following formula

380
00:14:29,600 --> 00:14:32,079
we can add a cycle between nodes one two

381
00:14:32,079 --> 00:14:34,160
and three

382
00:14:34,160 --> 00:14:36,160
we then include the cycle between nodes

383
00:14:36,160 --> 00:14:39,199
one two and four

384
00:14:39,760 --> 00:14:41,519
and we need to include now a cycle

385
00:14:41,519 --> 00:14:44,880
between nodes one 3 and 4.

386
00:14:44,880 --> 00:14:46,480
however

387
00:14:46,480 --> 00:14:49,360
note that with the new two arrows that

388
00:14:49,360 --> 00:14:50,959
we have introduced

389
00:14:50,959 --> 00:14:53,360
we have also introduced an unintended

390
00:14:53,360 --> 00:14:56,480
cycle unintended cycle between nodes 1

391
00:14:56,480 --> 00:14:59,279
and 3. in fact

392
00:14:59,279 --> 00:15:01,040
no matter

393
00:15:01,040 --> 00:15:03,440
how we add the cycles in this graph now

394
00:15:03,440 --> 00:15:05,120
that there could be several valid

395
00:15:05,120 --> 00:15:06,720
choices

396
00:15:06,720 --> 00:15:08,959
we will always introduce an unintended

397
00:15:08,959 --> 00:15:10,160
cycle

398
00:15:10,160 --> 00:15:12,720
to really model this formula we would

399
00:15:12,720 --> 00:15:14,639
need to duplicate one of the nodes for

400
00:15:14,639 --> 00:15:15,920
example

401
00:15:15,920 --> 00:15:18,639
node number three to be able to add the

402
00:15:18,639 --> 00:15:21,360
intended cycle without introducing

403
00:15:21,360 --> 00:15:24,560
introducing unintended ones

404
00:15:24,560 --> 00:15:27,120
in this case the proof would count

405
00:15:27,120 --> 00:15:29,519
with two different transcripts for for

406
00:15:29,519 --> 00:15:31,839
sigma protocol 3.

407
00:15:31,839 --> 00:15:33,759
it is interesting to observe that in the

408
00:15:33,759 --> 00:15:36,720
previous example

409
00:15:36,800 --> 00:15:39,680
which you can see now on the right

410
00:15:39,680 --> 00:15:41,759
there there also exists unintended

411
00:15:41,759 --> 00:15:42,959
cycles

412
00:15:42,959 --> 00:15:45,440
in the sense that they don't explicitly

413
00:15:45,440 --> 00:15:48,720
appear in the cnn formula

414
00:15:48,720 --> 00:15:51,040
but this is not a problem so for example

415
00:15:51,040 --> 00:15:53,680
know that we we can cycle between nodes

416
00:15:53,680 --> 00:15:54,480
two

417
00:15:54,480 --> 00:15:56,720
four and one and this does not appear in

418
00:15:56,720 --> 00:15:58,000
the formula

419
00:15:58,000 --> 00:16:00,480
as an explicit clause however in this

420
00:16:00,480 --> 00:16:02,959
case every unintended cycle contains the

421
00:16:02,959 --> 00:16:04,000
nodes

422
00:16:04,000 --> 00:16:05,279
of

423
00:16:05,279 --> 00:16:07,759
an intended one

424
00:16:07,759 --> 00:16:10,399
so the graph actually models the formula

425
00:16:10,399 --> 00:16:11,920
one may wonder

426
00:16:11,920 --> 00:16:14,399
what axis structures

427
00:16:14,399 --> 00:16:17,279
a cyclic graph captures in general or in

428
00:16:17,279 --> 00:16:19,360
other words world classes of one of

429
00:16:19,360 --> 00:16:21,199
monotone predicates can be efficiently

430
00:16:21,199 --> 00:16:23,279
expressed in this model

431
00:16:23,279 --> 00:16:25,279
the answer is that our technique can

432
00:16:25,279 --> 00:16:27,600
capture any predicate that can be

433
00:16:27,600 --> 00:16:29,680
efficiently expressed as an

434
00:16:29,680 --> 00:16:31,440
eclicity program

435
00:16:31,440 --> 00:16:34,079
a simplicity programming is a new model

436
00:16:34,079 --> 00:16:36,639
of computation introduced in this work

437
00:16:36,639 --> 00:16:39,360
that we define as follows a monotone a

438
00:16:39,360 --> 00:16:42,399
simplicity program a is a directed graph

439
00:16:42,399 --> 00:16:43,120
g

440
00:16:43,120 --> 00:16:45,600
whose nodes are labeled by variables 1

441
00:16:45,600 --> 00:16:49,120
to n along repetitions

442
00:16:49,120 --> 00:16:52,399
program a accepts a subset of variables

443
00:16:52,399 --> 00:16:55,440
s if and only if every directed cycle in

444
00:16:55,440 --> 00:16:58,560
g contains at least one node whose

445
00:16:58,560 --> 00:17:01,839
corresponding variable is in s

446
00:17:01,839 --> 00:17:03,920
this is equivalent to saying that a set

447
00:17:03,920 --> 00:17:06,240
s is accepted by a

448
00:17:06,240 --> 00:17:08,559
if the graph resulting from removing all

449
00:17:08,559 --> 00:17:12,000
the nodes in s contains no cycles

450
00:17:12,000 --> 00:17:14,480
this is the description of our

451
00:17:14,480 --> 00:17:16,880
acp composition prover

452
00:17:16,880 --> 00:17:18,799
we just want to highlight that the

453
00:17:18,799 --> 00:17:20,640
general algorithm is essentially the

454
00:17:20,640 --> 00:17:22,640
same that we have described

455
00:17:22,640 --> 00:17:24,799
in our previous example

456
00:17:24,799 --> 00:17:27,199
the prover will start all transcripts

457
00:17:27,199 --> 00:17:30,240
for which she knows witness

458
00:17:30,240 --> 00:17:32,400
this will relax some dependencies

459
00:17:32,400 --> 00:17:34,880
and will allow her to simulate those

460
00:17:34,880 --> 00:17:37,200
transcripts whose dependencies have

461
00:17:37,200 --> 00:17:39,600
disappeared

462
00:17:39,600 --> 00:17:41,600
if the set of weaknesses satisfies the

463
00:17:41,600 --> 00:17:43,919
eclicity program this process is

464
00:17:43,919 --> 00:17:46,160
guaranteed to finish

465
00:17:46,160 --> 00:17:48,799
by simulating all transcribe transcripts

466
00:17:48,799 --> 00:17:52,080
for which a witness is not known

467
00:17:52,080 --> 00:17:53,760
finally the prover can completely

468
00:17:53,760 --> 00:17:56,320
initially start the transcripts by using

469
00:17:56,320 --> 00:17:58,880
the corresponding witnesses

470
00:17:58,880 --> 00:18:01,760
for proving that acp composition

471
00:18:01,760 --> 00:18:03,200
leads to a valid serial knowledge

472
00:18:03,200 --> 00:18:05,200
argument of knowledge we need to show

473
00:18:05,200 --> 00:18:08,960
knowledge soundness and zero knowledge

474
00:18:08,960 --> 00:18:10,880
consider a prior machine that takes an

475
00:18:10,880 --> 00:18:12,960
encyclicity program a

476
00:18:12,960 --> 00:18:16,880
an output statement x and a proof pi

477
00:18:16,880 --> 00:18:18,559
note that this machine has access to the

478
00:18:18,559 --> 00:18:20,720
random article h

479
00:18:20,720 --> 00:18:23,039
and can potentially be malicious

480
00:18:23,039 --> 00:18:24,960
in the sense that it may deviate from

481
00:18:24,960 --> 00:18:28,600
the protocol specification

482
00:18:29,200 --> 00:18:31,520
in order to argue soundness

483
00:18:31,520 --> 00:18:33,520
nordic soundness

484
00:18:33,520 --> 00:18:35,679
we will show that if p

485
00:18:35,679 --> 00:18:36,799
star

486
00:18:36,799 --> 00:18:40,000
so this machine runs in time t has

487
00:18:40,000 --> 00:18:42,400
square complexity q and produces the

488
00:18:42,400 --> 00:18:44,080
value to proof

489
00:18:44,080 --> 00:18:46,000
on the chosen statement with probability

490
00:18:46,000 --> 00:18:47,200
delta

491
00:18:47,200 --> 00:18:49,600
then we can build an extractor that uses

492
00:18:49,600 --> 00:18:52,159
p star

493
00:18:52,320 --> 00:18:54,640
in order to produce a witness with

494
00:18:54,640 --> 00:18:58,480
probability at least delta divided by 2

495
00:18:58,480 --> 00:19:00,720
and running in this expected

496
00:19:00,720 --> 00:19:02,480
time

497
00:19:02,480 --> 00:19:04,240
here kappa is the special soundness

498
00:19:04,240 --> 00:19:05,520
parameter

499
00:19:05,520 --> 00:19:07,360
so it's two in the case of two special

500
00:19:07,360 --> 00:19:08,960
soundness

501
00:19:08,960 --> 00:19:10,559
observe that is if delta is

502
00:19:10,559 --> 00:19:12,799
non-negligible then the extractor's

503
00:19:12,799 --> 00:19:15,679
running time is polynomial

504
00:19:15,679 --> 00:19:17,440
we refer to the paper for details about

505
00:19:17,440 --> 00:19:18,400
the proof

506
00:19:18,400 --> 00:19:20,240
but the main idea is that we can

507
00:19:20,240 --> 00:19:22,720
leverage the forking lemma to extract at

508
00:19:22,720 --> 00:19:24,720
least one witness from every cycle in

509
00:19:24,720 --> 00:19:28,400
the graph induced by program a

510
00:19:28,400 --> 00:19:31,200
finally we will need to show

511
00:19:31,200 --> 00:19:34,000
that the acp composition satisfies the

512
00:19:34,000 --> 00:19:36,160
zero knowledge property but this can

513
00:19:36,160 --> 00:19:39,440
easily be done by leveraging

514
00:19:39,440 --> 00:19:40,960
the programmability of the random

515
00:19:40,960 --> 00:19:42,640
article

516
00:19:42,640 --> 00:19:44,799
from a theoretical point of view

517
00:19:44,799 --> 00:19:46,880
we study the expressivity of our new

518
00:19:46,880 --> 00:19:48,640
model of computation

519
00:19:48,640 --> 00:19:50,400
and conclude that the cyclicity

520
00:19:50,400 --> 00:19:52,960
programming is polynomially equivalent

521
00:19:52,960 --> 00:19:55,120
to branching programs

522
00:19:55,120 --> 00:19:58,320
this diagram shows polynomial time

523
00:19:58,320 --> 00:20:00,640
simulatability relations among different

524
00:20:00,640 --> 00:20:03,360
predicate representations

525
00:20:03,360 --> 00:20:05,840
this makes our acp composition in

526
00:20:05,840 --> 00:20:09,280
comparable to the cds 94 composition

527
00:20:09,280 --> 00:20:11,120
because there exist languages that can

528
00:20:11,120 --> 00:20:14,000
be efficiently described by simplicity

529
00:20:14,000 --> 00:20:15,280
programs

530
00:20:15,280 --> 00:20:17,360
but whose monotone span program

531
00:20:17,360 --> 00:20:20,000
representation is super polynomial

532
00:20:20,000 --> 00:20:22,240
and vice versa

533
00:20:22,240 --> 00:20:25,520
both my thoughts are orthogonal in terms

534
00:20:25,520 --> 00:20:27,600
of the complexity

535
00:20:27,600 --> 00:20:29,679
and they complement each other

536
00:20:29,679 --> 00:20:32,400
a major difference is that cts 94

537
00:20:32,400 --> 00:20:34,880
preserves the signal protocol structure

538
00:20:34,880 --> 00:20:37,600
while our acp composition

539
00:20:37,600 --> 00:20:40,559
leads inherently to a non-interactive

540
00:20:40,559 --> 00:20:41,840
brief system

541
00:20:41,840 --> 00:20:44,720
which requires the random article model

542
00:20:44,720 --> 00:20:47,200
in this work we also propose a variant

543
00:20:47,200 --> 00:20:50,400
of our previous results that allows us

544
00:20:50,400 --> 00:20:52,000
to compose sigma protocols and

545
00:20:52,000 --> 00:20:54,559
predicates expressed as monotone

546
00:20:54,559 --> 00:20:56,720
circuits

547
00:20:56,720 --> 00:20:57,919
note

548
00:20:57,919 --> 00:20:58,720
that

549
00:20:58,720 --> 00:21:00,799
direct simulation of monotone circuits

550
00:21:00,799 --> 00:21:03,440
by esqc programs is

551
00:21:03,440 --> 00:21:05,440
inherently inefficient

552
00:21:05,440 --> 00:21:08,320
that is why this new method leverages

553
00:21:08,320 --> 00:21:09,840
the extra assumption

554
00:21:09,840 --> 00:21:11,840
assumption of an available common

555
00:21:11,840 --> 00:21:14,080
reference string that allows one to

556
00:21:14,080 --> 00:21:16,640
produce one out of two proofs for some

557
00:21:16,640 --> 00:21:19,120
auxiliary statements

558
00:21:19,120 --> 00:21:21,600
remarkably this crs can just be a group

559
00:21:21,600 --> 00:21:23,760
element h with a known discrete

560
00:21:23,760 --> 00:21:26,320
logarithm

561
00:21:26,320 --> 00:21:27,679
this method

562
00:21:27,679 --> 00:21:30,799
transforms a monotone circuit into

563
00:21:30,799 --> 00:21:34,080
an encyclicity graph by translating and

564
00:21:34,080 --> 00:21:36,320
gates into false statements

565
00:21:36,320 --> 00:21:38,720
and or gates

566
00:21:38,720 --> 00:21:41,840
into a triple of statements connected as

567
00:21:41,840 --> 00:21:43,760
shown in the picture

568
00:21:43,760 --> 00:21:46,400
so we have two schnorr statements y and

569
00:21:46,400 --> 00:21:47,360
set

570
00:21:47,360 --> 00:21:50,559
that point to a false statement

571
00:21:50,559 --> 00:21:52,240
with the extra condition

572
00:21:52,240 --> 00:21:54,480
that y temp set must be equal to the

573
00:21:54,480 --> 00:21:57,200
common reference string

574
00:21:57,200 --> 00:21:59,200
in the case of and

575
00:21:59,200 --> 00:22:01,840
the false statement cannot be proven so

576
00:22:01,840 --> 00:22:03,760
it must be simulated

577
00:22:03,760 --> 00:22:06,240
for that it is necessary to have relaxed

578
00:22:06,240 --> 00:22:09,280
both both of its dependencies

579
00:22:09,280 --> 00:22:12,080
in the case of or it is enough to have

580
00:22:12,080 --> 00:22:14,159
relaxed the dependency of y

581
00:22:14,159 --> 00:22:17,679
or the dependence dependency of zed

582
00:22:17,679 --> 00:22:19,120
before the full statement can be

583
00:22:19,120 --> 00:22:20,880
simulated

584
00:22:20,880 --> 00:22:22,640
for example

585
00:22:22,640 --> 00:22:24,640
if the dependency of said has been

586
00:22:24,640 --> 00:22:27,039
relaxed one can choose y

587
00:22:27,039 --> 00:22:28,640
with a known

588
00:22:28,640 --> 00:22:30,240
discrete logarithm

589
00:22:30,240 --> 00:22:33,600
and simulate the transcript for itself

590
00:22:33,600 --> 00:22:36,000
so this translation on a circuit would

591
00:22:36,000 --> 00:22:38,080
look like this

592
00:22:38,080 --> 00:22:40,720
by placing the lookback edge from the

593
00:22:40,720 --> 00:22:42,880
node associated to the output gate of

594
00:22:42,880 --> 00:22:45,520
the circuit to all nodes associated to

595
00:22:45,520 --> 00:22:47,840
input gates we have an simplicity

596
00:22:47,840 --> 00:22:49,760
program for the circuit

597
00:22:49,760 --> 00:22:52,840
we'll refer to our paper for more

598
00:22:52,840 --> 00:22:56,159
details to sum up we have presented a

599
00:22:56,159 --> 00:22:58,320
novel technique for combining sigma

600
00:22:58,320 --> 00:22:59,840
protocols

601
00:22:59,840 --> 00:23:01,520
into a non-interactive serial knowledge

602
00:23:01,520 --> 00:23:02,960
proof system

603
00:23:02,960 --> 00:23:05,120
that can be proven

604
00:23:05,120 --> 00:23:08,559
in the programmable run markov model our

605
00:23:08,559 --> 00:23:10,400
model allows us to combine signal

606
00:23:10,400 --> 00:23:12,559
protocols and the predicates

607
00:23:12,559 --> 00:23:14,720
expressed in a new model of computation

608
00:23:14,720 --> 00:23:16,559
that is not comparable to existing

609
00:23:16,559 --> 00:23:18,240
techniques

610
00:23:18,240 --> 00:23:19,520
furthermore

611
00:23:19,520 --> 00:23:21,520
it is not limited to two special sound

612
00:23:21,520 --> 00:23:24,640
protocols unlike cds 94

613
00:23:24,640 --> 00:23:27,039
and it can lead to more compact proofs

614
00:23:27,039 --> 00:23:29,120
in some cases

615
00:23:29,120 --> 00:23:33,320
thank you very much for your attention

