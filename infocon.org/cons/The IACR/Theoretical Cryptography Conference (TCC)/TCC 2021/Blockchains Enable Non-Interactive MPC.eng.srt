1
00:00:00,799 --> 00:00:03,439
hi i'm lisa and i will be talking about

2
00:00:03,439 --> 00:00:05,359
our work blockchains enable

3
00:00:05,359 --> 00:00:07,520
non-interactive npc

4
00:00:07,520 --> 00:00:09,840
this is a joint work with repo goyal

5
00:00:09,840 --> 00:00:13,679
bryan partner and evan song

6
00:00:14,080 --> 00:00:16,239
first let us briefly talk about what is

7
00:00:16,239 --> 00:00:17,359
npc

8
00:00:17,359 --> 00:00:19,119
it stands for secure multipatter

9
00:00:19,119 --> 00:00:20,320
computation

10
00:00:20,320 --> 00:00:22,080
imagine four parties

11
00:00:22,080 --> 00:00:25,840
brian efan repo and lisa wish the

12
00:00:25,840 --> 00:00:27,920
computer function f on their private

13
00:00:27,920 --> 00:00:32,399
inputs x1 x2 x3 and x4

14
00:00:32,399 --> 00:00:34,320
however the parties do not trust each

15
00:00:34,320 --> 00:00:35,440
other

16
00:00:35,440 --> 00:00:37,680
npc provides a solution to this problem

17
00:00:37,680 --> 00:00:39,440
allowing the parties to compute the

18
00:00:39,440 --> 00:00:41,680
output of the function while ensuring

19
00:00:41,680 --> 00:00:43,920
that nothing besides this output is

20
00:00:43,920 --> 00:00:46,239
leaked

21
00:00:47,039 --> 00:00:49,200
since its formal introduction in the 80s

22
00:00:49,200 --> 00:00:51,680
there has been a lot of research on mpc

23
00:00:51,680 --> 00:00:53,600
on its assumptions its communication

24
00:00:53,600 --> 00:00:56,399
complexity and important for us its

25
00:00:56,399 --> 00:00:58,480
round complexity

26
00:00:58,480 --> 00:01:00,879
now we know that four rounds are

27
00:01:00,879 --> 00:01:03,760
necessary and sufficient for npc in the

28
00:01:03,760 --> 00:01:08,000
fully malicious case in the plane model

29
00:01:09,760 --> 00:01:12,159
unfortunately even the protocols which

30
00:01:12,159 --> 00:01:14,720
satisfy this optimal round complexity

31
00:01:14,720 --> 00:01:16,560
are sometimes problematic as they

32
00:01:16,560 --> 00:01:18,320
typically assume synchronous

33
00:01:18,320 --> 00:01:21,280
communication from the participants

34
00:01:21,280 --> 00:01:22,960
why is this a problem

35
00:01:22,960 --> 00:01:25,439
well imagine a voting process in some

36
00:01:25,439 --> 00:01:27,040
large country

37
00:01:27,040 --> 00:01:28,960
if the voting is conducted by an

38
00:01:28,960 --> 00:01:31,600
off-the-shelf mpc protocol

39
00:01:31,600 --> 00:01:34,000
all voters of that country must be

40
00:01:34,000 --> 00:01:36,400
online at the same time which seems like

41
00:01:36,400 --> 00:01:40,600
a very unrealistic assumption

42
00:01:41,119 --> 00:01:44,000
in our work we attempt to alleviate this

43
00:01:44,000 --> 00:01:45,119
problem

44
00:01:45,119 --> 00:01:47,600
for this we will rely on public bulletin

45
00:01:47,600 --> 00:01:49,600
boards and we will assume that these

46
00:01:49,600 --> 00:01:52,000
bulletin boards provide an unforgeable

47
00:01:52,000 --> 00:01:54,640
proof of publication

48
00:01:54,640 --> 00:01:57,040
as multiple prior works noted site

49
00:01:57,040 --> 00:01:59,439
bulletin boards exist in real life with

50
00:01:59,439 --> 00:02:01,280
the most notable example being the

51
00:02:01,280 --> 00:02:03,920
blockchains

52
00:02:04,960 --> 00:02:06,880
in addition to the bulletin boards we

53
00:02:06,880 --> 00:02:08,959
will assume something which we call

54
00:02:08,959 --> 00:02:11,120
conditional storage and retrieval

55
00:02:11,120 --> 00:02:13,280
systems csars

56
00:02:13,280 --> 00:02:15,280
intuitively they allow parties to

57
00:02:15,280 --> 00:02:17,360
securely store a secret under a release

58
00:02:17,360 --> 00:02:19,680
condition which can be basically an enp

59
00:02:19,680 --> 00:02:21,120
statement

60
00:02:21,120 --> 00:02:23,120
then if some party shows that it can

61
00:02:23,120 --> 00:02:25,360
satisfy this release condition the

62
00:02:25,360 --> 00:02:27,280
secret is privately released to that

63
00:02:27,280 --> 00:02:28,480
party

64
00:02:28,480 --> 00:02:31,040
recently um a few works appeared that

65
00:02:31,040 --> 00:02:33,360
provide similar functionalities based on

66
00:02:33,360 --> 00:02:35,440
blockchains and we showed that one of

67
00:02:35,440 --> 00:02:37,920
them indeed satisfies our security

68
00:02:37,920 --> 00:02:40,560
definition for csir

69
00:02:40,560 --> 00:02:43,680
since both bulletin boards and csirs can

70
00:02:43,680 --> 00:02:46,000
be instantiated using blockchains

71
00:02:46,000 --> 00:02:47,760
in the following for simplicity we will

72
00:02:47,760 --> 00:02:52,399
say that we work in the blockchain model

73
00:02:52,959 --> 00:02:55,120
note that there are two kinds of mpc

74
00:02:55,120 --> 00:02:57,360
participants in our work

75
00:02:57,360 --> 00:02:59,360
we will refer to the parties who provide

76
00:02:59,360 --> 00:03:02,400
inputs as contributors and we will refer

77
00:03:02,400 --> 00:03:04,159
to the parties who wish to receive the

78
00:03:04,159 --> 00:03:06,800
output as evaluators

79
00:03:06,800 --> 00:03:09,040
note that some parties might be both

80
00:03:09,040 --> 00:03:11,680
contributors and evaluators but this is

81
00:03:11,680 --> 00:03:13,120
not a requirement

82
00:03:13,120 --> 00:03:14,720
in fact these two groups can be

83
00:03:14,720 --> 00:03:17,120
completely destroyed

84
00:03:17,120 --> 00:03:19,200
in this model our goal will be to

85
00:03:19,200 --> 00:03:21,920
provide a solution for mpc which

86
00:03:21,920 --> 00:03:24,159
satisfies the property that mpc

87
00:03:24,159 --> 00:03:26,400
participants are not required to

88
00:03:26,400 --> 00:03:28,239
interact with each other

89
00:03:28,239 --> 00:03:30,480
and mpc contributors who are not

90
00:03:30,480 --> 00:03:33,040
interested in learning the output can go

91
00:03:33,040 --> 00:03:36,640
offline after a single round

92
00:03:38,400 --> 00:03:40,799
more formally we show that any npc

93
00:03:40,799 --> 00:03:42,159
protocol pi

94
00:03:42,159 --> 00:03:44,239
which is secure against fully malicious

95
00:03:44,239 --> 00:03:46,799
adversaries can be transformed into

96
00:03:46,799 --> 00:03:49,360
another mpc protocol by prime in the

97
00:03:49,360 --> 00:03:51,760
blockchain model which is also secure

98
00:03:51,760 --> 00:03:54,480
against fully malicious adversaries and

99
00:03:54,480 --> 00:03:56,400
does not require participants to

100
00:03:56,400 --> 00:03:58,480
interact with each other

101
00:03:58,480 --> 00:04:00,640
npc contributors are required to

102
00:04:00,640 --> 00:04:03,439
participate for only a single round the

103
00:04:03,439 --> 00:04:05,760
evaluators might need to participate for

104
00:04:05,760 --> 00:04:07,680
multiple rounds

105
00:04:07,680 --> 00:04:10,080
the adversary is allowed to corrupt as

106
00:04:10,080 --> 00:04:13,519
many mpc contributors in pi prime as it

107
00:04:13,519 --> 00:04:15,760
can corrupt mpc participants in the

108
00:04:15,760 --> 00:04:18,399
original protocol pi

109
00:04:18,399 --> 00:04:20,798
additionally the adversary is allowed to

110
00:04:20,798 --> 00:04:24,880
corrupt all of the evaluators

111
00:04:26,479 --> 00:04:28,800
in addition to our main result we

112
00:04:28,800 --> 00:04:31,120
provide further variations

113
00:04:31,120 --> 00:04:33,280
in the first one we show that in our

114
00:04:33,280 --> 00:04:35,919
scheme the communication and state

115
00:04:35,919 --> 00:04:38,160
complexity of the underlying mpc

116
00:04:38,160 --> 00:04:41,040
protocol are very important as they have

117
00:04:41,040 --> 00:04:43,120
implications for the number of csa

118
00:04:43,120 --> 00:04:45,360
alcohols that we make in our resulting

119
00:04:45,360 --> 00:04:46,960
construction

120
00:04:46,960 --> 00:04:49,840
to improve the efficiency of our scheme

121
00:04:49,840 --> 00:04:52,240
we propose an mpc protocol which

122
00:04:52,240 --> 00:04:54,400
achieves the property that its combined

123
00:04:54,400 --> 00:04:56,960
communication and state complexity are

124
00:04:56,960 --> 00:04:58,960
independent of the function f that we

125
00:04:58,960 --> 00:05:01,120
are trying to compute

126
00:05:01,120 --> 00:05:03,440
using this new protocol as the base of

127
00:05:03,440 --> 00:05:05,919
our transformation we achieve a result

128
00:05:05,919 --> 00:05:07,520
similar to our non-interactive

129
00:05:07,520 --> 00:05:10,160
construction which now additionally has

130
00:05:10,160 --> 00:05:14,720
an improved number of csir calls

131
00:05:16,720 --> 00:05:19,199
finally in the other variation of our

132
00:05:19,199 --> 00:05:22,000
main construction we show how a similar

133
00:05:22,000 --> 00:05:24,080
non-interactive transformation can be

134
00:05:24,080 --> 00:05:26,400
achieved with the property that the

135
00:05:26,400 --> 00:05:28,800
resulting protocol additionally provides

136
00:05:28,800 --> 00:05:31,199
guaranteed output delivery

137
00:05:31,199 --> 00:05:33,120
for this we will require that the

138
00:05:33,120 --> 00:05:35,280
original protocol provides guaranteed

139
00:05:35,280 --> 00:05:39,479
output delivery as well

140
00:05:40,479 --> 00:05:42,160
in the following we will start by

141
00:05:42,160 --> 00:05:44,080
discussing the main ideas of our

142
00:05:44,080 --> 00:05:45,600
construction

143
00:05:45,600 --> 00:05:47,680
next i will provide an overview of the

144
00:05:47,680 --> 00:05:49,840
challenges that we encounter and the

145
00:05:49,840 --> 00:05:51,600
ways we solve them

146
00:05:51,600 --> 00:05:53,520
we will finish by discussing the

147
00:05:53,520 --> 00:05:55,360
variants of our construction that

148
00:05:55,360 --> 00:05:59,280
provide further desirable properties

149
00:06:00,560 --> 00:06:03,360
okay so let's dive right in

150
00:06:03,360 --> 00:06:05,919
the main idea in our construction is

151
00:06:05,919 --> 00:06:07,360
fairly simple

152
00:06:07,360 --> 00:06:10,160
given an interactive mpc protocol pi

153
00:06:10,160 --> 00:06:12,880
each npc contributor gobbles the next

154
00:06:12,880 --> 00:06:15,680
message function for each round of pi

155
00:06:15,680 --> 00:06:18,960
while hard coding its private inputs

156
00:06:18,960 --> 00:06:21,280
then each contributor simply stores each

157
00:06:21,280 --> 00:06:23,600
of its goblet circuits and wire keys

158
00:06:23,600 --> 00:06:26,400
with the csr

159
00:06:26,400 --> 00:06:28,639
the evaluators can then retrieve the

160
00:06:28,639 --> 00:06:30,720
garbage circuits of all the participants

161
00:06:30,720 --> 00:06:35,840
from the csar and just execute these

162
00:06:37,280 --> 00:06:39,199
well this sounds fairly simple and

163
00:06:39,199 --> 00:06:40,479
straightforward

164
00:06:40,479 --> 00:06:42,160
in the construction one must be very

165
00:06:42,160 --> 00:06:44,479
careful since there are multiple issues

166
00:06:44,479 --> 00:06:46,720
that arise due to its non-attractive

167
00:06:46,720 --> 00:06:50,319
nature note that the goblet circuits of

168
00:06:50,319 --> 00:06:52,400
the parties do not have access to the

169
00:06:52,400 --> 00:06:54,479
same information as the parties in the

170
00:06:54,479 --> 00:06:56,639
original interactive protocol in the

171
00:06:56,639 --> 00:06:59,199
sense that the goblet circuit only knows

172
00:06:59,199 --> 00:07:01,680
the inputs given to the circuit it does

173
00:07:01,680 --> 00:07:03,680
not know for example what inputs have

174
00:07:03,680 --> 00:07:06,240
been fed into other gable circuit and it

175
00:07:06,240 --> 00:07:08,479
doesn't know whether it has been maybe

176
00:07:08,479 --> 00:07:10,880
already executed multiple times on

177
00:07:10,880 --> 00:07:13,360
different inputs and so on

178
00:07:13,360 --> 00:07:15,440
this certainly cannot happen during the

179
00:07:15,440 --> 00:07:18,080
interactive protocol parties see all the

180
00:07:18,080 --> 00:07:20,160
broadcasted messages and they know in

181
00:07:20,160 --> 00:07:22,639
which round of the protocol they are at

182
00:07:22,639 --> 00:07:25,520
any given time and cannot be forced into

183
00:07:25,520 --> 00:07:29,599
executing the same round twice

184
00:07:29,599 --> 00:07:31,199
there are multiple challenges that we

185
00:07:31,199 --> 00:07:33,520
had to overcome in our construction due

186
00:07:33,520 --> 00:07:36,400
to such issues and i will now introduce

187
00:07:36,400 --> 00:07:39,440
you to a few of them

188
00:07:41,680 --> 00:07:43,919
first note that we are using yao's cable

189
00:07:43,919 --> 00:07:46,080
circuits and there are a few issues that

190
00:07:46,080 --> 00:07:48,080
arise because of their use in our

191
00:07:48,080 --> 00:07:50,639
non-attractive setting

192
00:07:50,639 --> 00:07:52,400
first of all yao's construction

193
00:07:52,400 --> 00:07:55,360
satisfies the selective security notion

194
00:07:55,360 --> 00:07:57,440
which in particular assumes that the

195
00:07:57,440 --> 00:08:00,000
adversarial input is known before the

196
00:08:00,000 --> 00:08:01,599
governed circuit is revealed to the

197
00:08:01,599 --> 00:08:03,440
adversary

198
00:08:03,440 --> 00:08:06,240
and second of all the security proof of

199
00:08:06,240 --> 00:08:09,120
the um of yaw's construction crucially

200
00:08:09,120 --> 00:08:11,280
relies on the fact that only a single

201
00:08:11,280 --> 00:08:14,560
wire key is revealed for each wire

202
00:08:14,560 --> 00:08:17,360
however in our case partly store the

203
00:08:17,360 --> 00:08:19,280
wire keys before the evaluator even

204
00:08:19,280 --> 00:08:20,960
starts the execution

205
00:08:20,960 --> 00:08:23,280
and so it is not known which wire keys

206
00:08:23,280 --> 00:08:27,559
will be needed during the execution

207
00:08:28,000 --> 00:08:30,000
effectively this means that before a

208
00:08:30,000 --> 00:08:32,559
goblet circuit and its fire keys are

209
00:08:32,559 --> 00:08:35,519
obtained by an evaluator the evaluator

210
00:08:35,519 --> 00:08:38,000
must fix the input it will be feeding

211
00:08:38,000 --> 00:08:39,839
into the

212
00:08:39,839 --> 00:08:43,039
goblet circuit and we must ensure that

213
00:08:43,039 --> 00:08:45,040
it receives only the wire keys for that

214
00:08:45,040 --> 00:08:48,079
particular input

215
00:08:49,519 --> 00:08:52,000
we achieve this by having the evaluator

216
00:08:52,000 --> 00:08:54,080
commit to its execution on the public

217
00:08:54,080 --> 00:08:55,920
bulletin board

218
00:08:55,920 --> 00:08:58,320
in each round i the evaluator will

219
00:08:58,320 --> 00:09:00,560
execute the coupled circuits for this

220
00:09:00,560 --> 00:09:03,680
round i and post m i which is the

221
00:09:03,680 --> 00:09:06,000
concatenation of the outputs of all

222
00:09:06,000 --> 00:09:09,839
gable circuits of round i

223
00:09:09,839 --> 00:09:12,240
only after this commitment mi is posted

224
00:09:12,240 --> 00:09:14,320
will the csir release the govern

225
00:09:14,320 --> 00:09:16,959
circuits of the next round

226
00:09:16,959 --> 00:09:19,839
specifically the existence of message mi

227
00:09:19,839 --> 00:09:22,560
is checked as a part of the csir release

228
00:09:22,560 --> 00:09:25,040
condition

229
00:09:25,120 --> 00:09:27,440
this solves the selective security issue

230
00:09:27,440 --> 00:09:30,240
as the evaluator is now fixing its input

231
00:09:30,240 --> 00:09:34,080
before it obtains the garble circuit

232
00:09:34,720 --> 00:09:37,120
as for the wire keys recall that at the

233
00:09:37,120 --> 00:09:40,480
time the parties store those with csr

234
00:09:40,480 --> 00:09:42,160
the input which will be used by the

235
00:09:42,160 --> 00:09:44,560
evaluator is not known

236
00:09:44,560 --> 00:09:46,880
so the parties must store both the key

237
00:09:46,880 --> 00:09:50,640
for 0 and 1 for each wire

238
00:09:50,640 --> 00:09:53,040
the crucial idea here is that the party

239
00:09:53,040 --> 00:09:56,240
store these keys in two separate csr

240
00:09:56,240 --> 00:09:57,760
requests

241
00:09:57,760 --> 00:10:00,800
then the release condition for bit b

242
00:10:00,800 --> 00:10:04,399
on some via x in particular demands that

243
00:10:04,399 --> 00:10:06,880
the message mi

244
00:10:06,880 --> 00:10:11,839
contains exactly bit b on the position x

245
00:10:11,839 --> 00:10:13,839
this solves the problem of revealing

246
00:10:13,839 --> 00:10:18,680
only a single var key for each wire

247
00:10:19,760 --> 00:10:21,360
another challenge that you had to

248
00:10:21,360 --> 00:10:23,600
overcome in our construction is the

249
00:10:23,600 --> 00:10:26,560
issue of input custom consistency

250
00:10:26,560 --> 00:10:29,600
note that if say vpol broadcasts a

251
00:10:29,600 --> 00:10:31,760
message in the original interactive

252
00:10:31,760 --> 00:10:34,959
protocol both brian and ethan see this

253
00:10:34,959 --> 00:10:37,120
message

254
00:10:37,120 --> 00:10:39,440
while wipo's message is part of the

255
00:10:39,440 --> 00:10:42,480
input to both brian's and ifan's cable

256
00:10:42,480 --> 00:10:45,600
circuits by itself these circuits cannot

257
00:10:45,600 --> 00:10:48,560
verify that the exact same message was

258
00:10:48,560 --> 00:10:50,800
used in the input to the other circuit

259
00:10:50,800 --> 00:10:52,560
as well

260
00:10:52,560 --> 00:10:55,040
so we must somehow prevent a dishonest

261
00:10:55,040 --> 00:10:57,680
evaluator from using inconsistent inputs

262
00:10:57,680 --> 00:11:00,800
to the garbled circuits

263
00:11:00,800 --> 00:11:03,279
this is again solved using the public

264
00:11:03,279 --> 00:11:05,200
bulletin board commitments to the course

265
00:11:05,200 --> 00:11:07,279
of execution

266
00:11:07,279 --> 00:11:09,760
specifically in the release condition

267
00:11:09,760 --> 00:11:12,320
for the goblet circuits and fire keys we

268
00:11:12,320 --> 00:11:14,800
will accept only the very first message

269
00:11:14,800 --> 00:11:17,200
published by an evaluator as a

270
00:11:17,200 --> 00:11:20,880
commitment to a certain round

271
00:11:20,880 --> 00:11:23,120
this ensures that there is only a single

272
00:11:23,120 --> 00:11:25,519
message for which any evaluator will

273
00:11:25,519 --> 00:11:28,480
receive the keys

274
00:11:28,480 --> 00:11:30,560
another issue which is again related to

275
00:11:30,560 --> 00:11:32,240
the non-attractive nature of our

276
00:11:32,240 --> 00:11:35,120
protocol is a problem that the evaluator

277
00:11:35,120 --> 00:11:37,760
could retrieve the garbage circuits and

278
00:11:37,760 --> 00:11:40,480
execute these out of order

279
00:11:40,480 --> 00:11:42,640
this is clearly something that would not

280
00:11:42,640 --> 00:11:44,320
happen in the original interactive

281
00:11:44,320 --> 00:11:46,640
protocol where honest parties follow

282
00:11:46,640 --> 00:11:48,399
exactly the predefined order of

283
00:11:48,399 --> 00:11:50,320
execution

284
00:11:50,320 --> 00:11:53,120
so we must ensure that the evaluator

285
00:11:53,120 --> 00:11:55,760
does not see the output for some round i

286
00:11:55,760 --> 00:11:58,320
before it fixes its execution for all

287
00:11:58,320 --> 00:12:02,399
rounds j which come before i

288
00:12:02,880 --> 00:12:05,279
this is again solved using the

289
00:12:05,279 --> 00:12:07,200
commitments and carefully constructing

290
00:12:07,200 --> 00:12:10,079
the csr release conditions

291
00:12:10,079 --> 00:12:12,639
in particular to release carbon circuits

292
00:12:12,639 --> 00:12:14,160
of a certain round

293
00:12:14,160 --> 00:12:16,880
the evaluator must prove that it already

294
00:12:16,880 --> 00:12:19,839
committed to the outputs of all prior

295
00:12:19,839 --> 00:12:21,120
rounds

296
00:12:21,120 --> 00:12:24,000
this is ensured by the csir release

297
00:12:24,000 --> 00:12:26,880
condition which checks that the output

298
00:12:26,880 --> 00:12:28,880
outputs for all prior rounds have been

299
00:12:28,880 --> 00:12:31,519
posted

300
00:12:32,480 --> 00:12:34,800
finally note that typically a protocol

301
00:12:34,800 --> 00:12:37,040
pi would use some data across multiple

302
00:12:37,040 --> 00:12:40,399
rounds a party pj's

303
00:12:40,399 --> 00:12:43,120
next message function of round i

304
00:12:43,120 --> 00:12:46,959
will output as state as ji

305
00:12:46,959 --> 00:12:50,399
and the state will be used as part of

306
00:12:50,399 --> 00:12:53,120
the input to the next message function

307
00:12:53,120 --> 00:12:54,160
of

308
00:12:54,160 --> 00:12:56,959
the next round

309
00:12:58,320 --> 00:13:00,399
this state cannot be precomputed before

310
00:13:00,399 --> 00:13:03,120
the protocol execution and it is assumed

311
00:13:03,120 --> 00:13:05,360
to be kept private

312
00:13:05,360 --> 00:13:07,839
so in our case we would need to ensure

313
00:13:07,839 --> 00:13:10,000
that the state cannot be viewed by the

314
00:13:10,000 --> 00:13:11,360
evaluator

315
00:13:11,360 --> 00:13:13,200
but can still be used by the party's

316
00:13:13,200 --> 00:13:16,959
garbage circuit for the next round

317
00:13:18,079 --> 00:13:20,399
we solve this problem by modifying the

318
00:13:20,399 --> 00:13:23,279
original next message function

319
00:13:23,279 --> 00:13:26,240
specifically we encrypt the state under

320
00:13:26,240 --> 00:13:28,800
the public key of the party pj who is

321
00:13:28,800 --> 00:13:31,040
doing the goblin and output the

322
00:13:31,040 --> 00:13:33,200
encryption of the state instead of the

323
00:13:33,200 --> 00:13:34,399
instead of the

324
00:13:34,399 --> 00:13:36,880
state itself

325
00:13:36,880 --> 00:13:39,360
in the next round we simply decrypt this

326
00:13:39,360 --> 00:13:41,920
ciphertext to obtain the state and then

327
00:13:41,920 --> 00:13:44,160
continue with the original next message

328
00:13:44,160 --> 00:13:46,560
function

329
00:13:46,800 --> 00:13:49,120
this allows contributors to use state

330
00:13:49,120 --> 00:13:51,440
across multiple rounds while ensuring

331
00:13:51,440 --> 00:13:55,279
that the state is still kept private

332
00:13:56,800 --> 00:13:58,800
hopefully this gave you some idea of

333
00:13:58,800 --> 00:14:00,720
what challenges we encountered and what

334
00:14:00,720 --> 00:14:03,360
approaches we took to solve these

335
00:14:03,360 --> 00:14:05,440
as a recap in our main result we

336
00:14:05,440 --> 00:14:07,680
provided a construction which given a

337
00:14:07,680 --> 00:14:10,160
protocol pi in a fully malicious model

338
00:14:10,160 --> 00:14:12,399
transforms it into another protocol pi

339
00:14:12,399 --> 00:14:15,040
prime in the blockchain model which does

340
00:14:15,040 --> 00:14:17,120
not require interaction between the abc

341
00:14:17,120 --> 00:14:19,600
participants and requires only a single

342
00:14:19,600 --> 00:14:21,199
round of interaction from the

343
00:14:21,199 --> 00:14:23,920
contributors

344
00:14:25,920 --> 00:14:28,079
in addition to this main construction we

345
00:14:28,079 --> 00:14:30,880
provide two variations one is the

346
00:14:30,880 --> 00:14:33,040
protocol which focuses on improving the

347
00:14:33,040 --> 00:14:36,639
number of csir calls of our construction

348
00:14:36,639 --> 00:14:38,880
the other is the protocol which achieves

349
00:14:38,880 --> 00:14:40,800
guaranteed output delivery

350
00:14:40,800 --> 00:14:42,560
meaning that the dishonest parties

351
00:14:42,560 --> 00:14:44,720
cannot prevent honest parties from

352
00:14:44,720 --> 00:14:47,600
learning the output

353
00:14:48,720 --> 00:14:51,040
we start with improving the number of

354
00:14:51,040 --> 00:14:54,160
csi alcohols of our construction

355
00:14:54,160 --> 00:14:57,440
note that the csir storage requests

356
00:14:57,440 --> 00:14:59,920
consist of each contributor storing a

357
00:14:59,920 --> 00:15:01,760
goblet circuit for each round of the

358
00:15:01,760 --> 00:15:04,480
construction as well as storing two wire

359
00:15:04,480 --> 00:15:06,240
keys for each wire of each cardboard

360
00:15:06,240 --> 00:15:07,920
circuit

361
00:15:07,920 --> 00:15:10,639
similarly the release requests each

362
00:15:10,639 --> 00:15:13,040
evaluator will perform consists of

363
00:15:13,040 --> 00:15:15,120
retrieving

364
00:15:15,120 --> 00:15:17,839
all garbled circuits as well as a single

365
00:15:17,839 --> 00:15:20,079
via key for each wire of each carbon

366
00:15:20,079 --> 00:15:22,160
circuit

367
00:15:22,160 --> 00:15:24,480
so as you can see the number of input

368
00:15:24,480 --> 00:15:26,639
wires in our construction is the

369
00:15:26,639 --> 00:15:29,040
dominant factor in the number of csir

370
00:15:29,040 --> 00:15:31,599
requests

371
00:15:32,320 --> 00:15:34,560
at the same time we know that the inputs

372
00:15:34,560 --> 00:15:36,800
to each cable circuit are messages

373
00:15:36,800 --> 00:15:38,720
exchanged by the parties in the previous

374
00:15:38,720 --> 00:15:41,120
round plus the state passed from the

375
00:15:41,120 --> 00:15:43,120
garbage circuit of the same party from

376
00:15:43,120 --> 00:15:45,600
the previous round

377
00:15:45,600 --> 00:15:47,920
together this means that the number of

378
00:15:47,920 --> 00:15:51,040
csir requests is approximately the same

379
00:15:51,040 --> 00:15:53,519
as the combined communication and state

380
00:15:53,519 --> 00:15:57,839
complexity of the underlying protocol by

381
00:15:57,920 --> 00:16:00,000
to reduce this combined communication

382
00:16:00,000 --> 00:16:02,240
and state complexity we propose a

383
00:16:02,240 --> 00:16:04,160
protocol which is the cue against fully

384
00:16:04,160 --> 00:16:06,560
malicious adversaries and which combined

385
00:16:06,560 --> 00:16:08,560
complexity is independent of the

386
00:16:08,560 --> 00:16:11,440
function being computed

387
00:16:11,440 --> 00:16:13,920
to achieve this we start with an mpc

388
00:16:13,920 --> 00:16:16,959
protocol by brackets carol

389
00:16:16,959 --> 00:16:18,639
this protocol is secure against

390
00:16:18,639 --> 00:16:21,040
semi-malicious adversaries and its

391
00:16:21,040 --> 00:16:22,800
combine communication and state

392
00:16:22,800 --> 00:16:25,440
complexity depend only on security

393
00:16:25,440 --> 00:16:28,639
parameters number of parties and input

394
00:16:28,639 --> 00:16:30,720
and output sizes

395
00:16:30,720 --> 00:16:33,279
note that this satisfies our requirement

396
00:16:33,279 --> 00:16:35,519
of combined complexity being independent

397
00:16:35,519 --> 00:16:38,639
of the function f

398
00:16:38,959 --> 00:16:41,360
to achieve a similar result in a fully

399
00:16:41,360 --> 00:16:43,600
malicious setting we extend the same

400
00:16:43,600 --> 00:16:46,000
malicious construction by killian's pcp

401
00:16:46,000 --> 00:16:48,160
based zero knowledge protocol

402
00:16:48,160 --> 00:16:50,079
which is executed after each round of

403
00:16:50,079 --> 00:16:52,160
the same malicious construction to

404
00:16:52,160 --> 00:16:53,600
ensure the correct behavior of the

405
00:16:53,600 --> 00:16:55,199
parties

406
00:16:55,199 --> 00:16:57,199
here are minor tweaks are needed in

407
00:16:57,199 --> 00:16:58,720
order to ensure that the combined

408
00:16:58,720 --> 00:17:00,800
complexity of the resulting protocol

409
00:17:00,800 --> 00:17:02,839
still satisfies our

410
00:17:02,839 --> 00:17:05,280
requirements specifically in keelan's

411
00:17:05,280 --> 00:17:07,760
construction the pcb is used across

412
00:17:07,760 --> 00:17:09,760
multiple rounds and so typically it

413
00:17:09,760 --> 00:17:12,559
would be stored as part of the state

414
00:17:12,559 --> 00:17:14,319
however we can easily remove this

415
00:17:14,319 --> 00:17:16,559
requirement by simply recomputing the

416
00:17:16,559 --> 00:17:20,399
pcb whenever it is needed

417
00:17:21,760 --> 00:17:23,760
building up on this new protocol as well

418
00:17:23,760 --> 00:17:26,000
as our main result we are able to

419
00:17:26,000 --> 00:17:28,319
achieve a protocol in a blockchain model

420
00:17:28,319 --> 00:17:30,080
which is secure against fully malicious

421
00:17:30,080 --> 00:17:32,320
adversaries does not require interaction

422
00:17:32,320 --> 00:17:35,120
between the npc participants is sitting

423
00:17:35,120 --> 00:17:37,440
around for the parties who supply inputs

424
00:17:37,440 --> 00:17:39,840
but are not interested in the output

425
00:17:39,840 --> 00:17:41,440
and um

426
00:17:41,440 --> 00:17:43,840
the number of csai requests in this

427
00:17:43,840 --> 00:17:46,320
protocol is independent of the function

428
00:17:46,320 --> 00:17:49,918
f which is being computed

429
00:17:51,600 --> 00:17:54,080
our final result is a non-attractive

430
00:17:54,080 --> 00:17:55,760
construction which provides the

431
00:17:55,760 --> 00:17:58,880
guaranteed output delivery property

432
00:17:58,880 --> 00:18:01,280
it might seem like using an underlying

433
00:18:01,280 --> 00:18:03,039
protocol which provides guaranteed

434
00:18:03,039 --> 00:18:05,440
output delivery is enough to ensure that

435
00:18:05,440 --> 00:18:06,640
the same

436
00:18:06,640 --> 00:18:08,960
property holds after our non-attractive

437
00:18:08,960 --> 00:18:11,679
transformation

438
00:18:11,679 --> 00:18:14,160
however this is not the case as i

439
00:18:14,160 --> 00:18:16,240
mentioned earlier in our original

440
00:18:16,240 --> 00:18:19,039
construction the csir release condition

441
00:18:19,039 --> 00:18:21,760
considers only the very first message

442
00:18:21,760 --> 00:18:24,000
published as the output of some round to

443
00:18:24,000 --> 00:18:25,280
be valid

444
00:18:25,280 --> 00:18:27,600
this needs to be done to ensure that

445
00:18:27,600 --> 00:18:29,600
only a single via key is revealed for

446
00:18:29,600 --> 00:18:32,640
each wire of each cable circuit

447
00:18:32,640 --> 00:18:35,200
this a dishonest evaluator can always

448
00:18:35,200 --> 00:18:38,160
disrupt execution of an honest evaluator

449
00:18:38,160 --> 00:18:40,720
by publishing a wrong message on the

450
00:18:40,720 --> 00:18:43,840
bulletin board

451
00:18:44,559 --> 00:18:47,039
we solved this issue by first of all

452
00:18:47,039 --> 00:18:49,520
introducing a deadline by which all

453
00:18:49,520 --> 00:18:53,039
goblet circuits and keys must be stored

454
00:18:53,039 --> 00:18:56,240
then we switch to csr which releases the

455
00:18:56,240 --> 00:18:58,240
secrets publicly after a release

456
00:18:58,240 --> 00:19:01,200
condition has been satisfied

457
00:19:01,200 --> 00:19:03,520
note that already in the original

458
00:19:03,520 --> 00:19:05,280
construction all of the outputs of the

459
00:19:05,280 --> 00:19:07,360
goblet circuits are signed by those

460
00:19:07,360 --> 00:19:10,559
carbon circuits

461
00:19:10,559 --> 00:19:13,360
now if an evaluator attempts to commit

462
00:19:13,360 --> 00:19:15,919
to an output when checking the release

463
00:19:15,919 --> 00:19:19,120
condition the csar can use the now

464
00:19:19,120 --> 00:19:21,039
public information about the previous

465
00:19:21,039 --> 00:19:23,919
round so garbage circuits and fire keys

466
00:19:23,919 --> 00:19:26,480
and can verify whether the evaluator was

467
00:19:26,480 --> 00:19:28,640
behaving honestly

468
00:19:28,640 --> 00:19:31,520
if this is the case even if the output

469
00:19:31,520 --> 00:19:33,440
is malformed for example has some

470
00:19:33,440 --> 00:19:36,240
invalid signatures the evaluator is not

471
00:19:36,240 --> 00:19:39,200
at fault and the malformed output is the

472
00:19:39,200 --> 00:19:42,000
result of some malicious mpc contributor

473
00:19:42,000 --> 00:19:45,280
providing an invalid goblet circuit

474
00:19:45,280 --> 00:19:47,760
obviously in this case the evaluator is

475
00:19:47,760 --> 00:19:50,799
allowed to proceed

476
00:19:51,120 --> 00:19:53,360
since the evaluator can now always

477
00:19:53,360 --> 00:19:56,160
advance in its execution we can conclude

478
00:19:56,160 --> 00:19:58,640
that if the original protocol satisfies

479
00:19:58,640 --> 00:20:00,640
the guaranteed output delivery

480
00:20:00,640 --> 00:20:02,559
our new protocol has this property as

481
00:20:02,559 --> 00:20:05,559
well

482
00:20:06,960 --> 00:20:09,200
to conclude i would like to elaborate on

483
00:20:09,200 --> 00:20:11,840
how our work fits into the existing

484
00:20:11,840 --> 00:20:14,000
embassy literature

485
00:20:14,000 --> 00:20:16,240
the line of work which is very relevant

486
00:20:16,240 --> 00:20:18,559
to ours are the works on non-interactive

487
00:20:18,559 --> 00:20:21,840
npc these works typically consider a

488
00:20:21,840 --> 00:20:24,159
setting where a number of parties submit

489
00:20:24,159 --> 00:20:26,720
a single message to a server essentially

490
00:20:26,720 --> 00:20:28,240
an evaluator

491
00:20:28,240 --> 00:20:30,559
that upon receiving all of the messages

492
00:20:30,559 --> 00:20:33,440
computes the output of the function

493
00:20:33,440 --> 00:20:35,600
our work differs from the line of work

494
00:20:35,600 --> 00:20:38,080
on non-interactive mpc in several

495
00:20:38,080 --> 00:20:39,440
aspects

496
00:20:39,440 --> 00:20:41,919
first in our work parties do not need to

497
00:20:41,919 --> 00:20:44,400
communicate directly with the evaluators

498
00:20:44,400 --> 00:20:46,720
so there is one additional level of

499
00:20:46,720 --> 00:20:48,240
non-attractiveness

500
00:20:48,240 --> 00:20:50,720
second in those works the adversary is

501
00:20:50,720 --> 00:20:52,559
typically allowed to learn the so-called

502
00:20:52,559 --> 00:20:55,120
residual function which is the original

503
00:20:55,120 --> 00:20:57,280
function restricted to the inputs of the

504
00:20:57,280 --> 00:20:59,039
honest parties

505
00:20:59,039 --> 00:21:00,640
this in particular means that the

506
00:21:00,640 --> 00:21:02,320
adversary can learn the outcome of the

507
00:21:02,320 --> 00:21:04,559
original function on every possible

508
00:21:04,559 --> 00:21:07,280
choice of adversarial inputs

509
00:21:07,280 --> 00:21:11,440
this is not the case in our construction

510
00:21:12,320 --> 00:21:14,240
another very interesting line of works

511
00:21:14,240 --> 00:21:16,159
are those on reusable non-interactive

512
00:21:16,159 --> 00:21:18,320
secure computation

513
00:21:18,320 --> 00:21:20,640
intuitively nisk typically consider two

514
00:21:20,640 --> 00:21:22,080
parties

515
00:21:22,080 --> 00:21:24,400
a sender and a receiver

516
00:21:24,400 --> 00:21:26,320
a receiver starts by publishing a

517
00:21:26,320 --> 00:21:29,440
reusable encoding of its input x

518
00:21:29,440 --> 00:21:32,640
this allows any sender with input y to

519
00:21:32,640 --> 00:21:34,960
let the receiver obtain the output of

520
00:21:34,960 --> 00:21:38,320
any function f computed on x and y by

521
00:21:38,320 --> 00:21:41,840
sending a single message to the receiver

522
00:21:41,840 --> 00:21:43,520
this setting is slightly different from

523
00:21:43,520 --> 00:21:45,840
ours where we aim to ensure that parties

524
00:21:45,840 --> 00:21:48,080
do not need to interact with each other

525
00:21:48,080 --> 00:21:49,679
and can leave after the first round if

526
00:21:49,679 --> 00:21:51,200
they are not interested in learning the

527
00:21:51,200 --> 00:21:53,520
output

528
00:21:53,840 --> 00:21:56,000
finally several works appeared quite

529
00:21:56,000 --> 00:21:58,159
recently that similar to us aim to

530
00:21:58,159 --> 00:22:00,000
improve the flexibility of the mpc

531
00:22:00,000 --> 00:22:01,440
protocols

532
00:22:01,440 --> 00:22:03,520
gate mpc for example focuses on

533
00:22:03,520 --> 00:22:06,080
designing non-interactive mpc protocols

534
00:22:06,080 --> 00:22:07,679
which use blockchains to provide

535
00:22:07,679 --> 00:22:09,760
short-term security without residual

536
00:22:09,760 --> 00:22:11,039
leakage

537
00:22:11,039 --> 00:22:13,679
this work uses an incentive based notion

538
00:22:13,679 --> 00:22:15,600
of security

539
00:22:15,600 --> 00:22:17,919
fluid mpc allows parties to dynamically

540
00:22:17,919 --> 00:22:20,559
join and leave the computation

541
00:22:20,559 --> 00:22:23,360
and he also focuses on status bodies

542
00:22:23,360 --> 00:22:25,840
which can only send a single message

543
00:22:25,840 --> 00:22:28,640
similar to us user and fluid mpc allow

544
00:22:28,640 --> 00:22:30,559
the mbc participants to leave after the

545
00:22:30,559 --> 00:22:32,400
first round if they are not interested

546
00:22:32,400 --> 00:22:34,240
in learning the output

547
00:22:34,240 --> 00:22:37,120
however to execute the mpc protocol both

548
00:22:37,120 --> 00:22:39,679
schemes rely on

549
00:22:39,679 --> 00:22:41,280
number of committees of different

550
00:22:41,280 --> 00:22:44,159
parties which interact with each other

551
00:22:44,159 --> 00:22:45,840
and each committee must provide honest

552
00:22:45,840 --> 00:22:47,360
majority

553
00:22:47,360 --> 00:22:49,679
in our case there is no need for such an

554
00:22:49,679 --> 00:22:52,240
assumption on the evaluator's side even

555
00:22:52,240 --> 00:22:54,320
if there is a single evaluator who is

556
00:22:54,320 --> 00:22:56,880
dishonest our protocol still preserves

557
00:22:56,880 --> 00:23:01,280
input privacy of the honest contributors

558
00:23:03,919 --> 00:23:06,080
i thank you for your attention and if

559
00:23:06,080 --> 00:23:07,919
you have any questions please feel free

560
00:23:07,919 --> 00:23:12,679
to send me an email thank you

