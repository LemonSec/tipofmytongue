1
00:00:00,960 --> 00:00:03,199
hey my name is rachel and today i'll be

2
00:00:03,199 --> 00:00:05,680
talking about joint work with yao tom

3
00:00:05,680 --> 00:00:08,000
and kalai and the notification nathan

4
00:00:08,000 --> 00:00:10,080
called somewhere statistical soundness

5
00:00:10,080 --> 00:00:12,559
post quantum security and snarks

6
00:00:12,559 --> 00:00:14,559
so today i'll start by talking about the

7
00:00:14,559 --> 00:00:17,359
last of these three things

8
00:00:17,359 --> 00:00:19,199
a snark is succinct not an attractive

9
00:00:19,199 --> 00:00:20,480
argument

10
00:00:20,480 --> 00:00:22,560
the idea is that approver wants to prove

11
00:00:22,560 --> 00:00:24,720
to a verifier some statement x is in a

12
00:00:24,720 --> 00:00:25,760
language

13
00:00:25,760 --> 00:00:27,840
um she's gonna do this

14
00:00:27,840 --> 00:00:29,359
um so they're gonna have both parties

15
00:00:29,359 --> 00:00:30,800
going to have this common random string

16
00:00:30,800 --> 00:00:32,800
that deserved by the third trusted party

17
00:00:32,800 --> 00:00:34,640
um and they both know it the proof will

18
00:00:34,640 --> 00:00:36,719
generate the certificate pi in response

19
00:00:36,719 --> 00:00:38,879
to the common random string um and the

20
00:00:38,879 --> 00:00:42,000
verifier upon receiving pi and x will

21
00:00:42,000 --> 00:00:44,000
verify them jointly with the common

22
00:00:44,000 --> 00:00:45,840
random string

23
00:00:45,840 --> 00:00:46,879
there's a few additional properties

24
00:00:46,879 --> 00:00:48,320
we're going to want

25
00:00:48,320 --> 00:00:50,719
the first is succinctness which is that

26
00:00:50,719 --> 00:00:53,600
if a language takes time t to compute

27
00:00:53,600 --> 00:00:55,199
then verifying it should take time way

28
00:00:55,199 --> 00:00:56,879
less than t

29
00:00:56,879 --> 00:00:58,719
the second property is soundness which

30
00:00:58,719 --> 00:00:59,920
is that

31
00:00:59,920 --> 00:01:03,039
um for any polyt size g improver

32
00:01:03,039 --> 00:01:05,760
um they shouldn't be able to generate

33
00:01:05,760 --> 00:01:08,640
both x and the proof pi

34
00:01:08,640 --> 00:01:10,720
um so that the variable would accept if

35
00:01:10,720 --> 00:01:12,400
x is not actually in the language so

36
00:01:12,400 --> 00:01:13,840
they shouldn't be able to convince a

37
00:01:13,840 --> 00:01:17,200
verifier of any false statement

38
00:01:17,200 --> 00:01:19,439
there's been a lot of works on trying to

39
00:01:19,439 --> 00:01:22,000
construct snards um so

40
00:01:22,000 --> 00:01:23,680
for a long time all the efforts were

41
00:01:23,680 --> 00:01:25,840
directed at constructing synthetics for

42
00:01:25,840 --> 00:01:26,880
mp

43
00:01:26,880 --> 00:01:28,640
and this is only done under really

44
00:01:28,640 --> 00:01:30,479
strong assumptions such as the random

45
00:01:30,479 --> 00:01:32,720
oracle model or knowledge assumptions

46
00:01:32,720 --> 00:01:34,000
more recently there's an effort

47
00:01:34,000 --> 00:01:35,680
dedicated towards constructing snarks

48
00:01:35,680 --> 00:01:37,680
for deterministic languages

49
00:01:37,680 --> 00:01:39,840
so for p those two constructed under

50
00:01:39,840 --> 00:01:42,560
substantial io um or under this

51
00:01:42,560 --> 00:01:44,560
assumption on bilinear groups

52
00:01:44,560 --> 00:01:48,000
um recently yes um a work constructed

53
00:01:48,000 --> 00:01:49,680
snare active branding dips computations

54
00:01:49,680 --> 00:01:51,840
based on some exponential rwe

55
00:01:51,840 --> 00:01:53,600
we also want to mention a concurrent

56
00:01:53,600 --> 00:01:56,000
work by chad harry jaden jin which

57
00:01:56,000 --> 00:01:58,240
constructs natural batch mpnp

58
00:01:58,240 --> 00:01:59,360
um

59
00:01:59,360 --> 00:02:01,840
which does it under lwe

60
00:02:01,840 --> 00:02:04,399
so in our work today we're going to

61
00:02:04,399 --> 00:02:06,640
investigate this connection between

62
00:02:06,640 --> 00:02:08,560
selector batch and pmp

63
00:02:08,560 --> 00:02:10,160
so in particular we're going to show

64
00:02:10,160 --> 00:02:12,000
that there's a snark for p

65
00:02:12,000 --> 00:02:13,760
or more generally any language that has

66
00:02:13,760 --> 00:02:16,560
a computational non-signaling pcp

67
00:02:16,560 --> 00:02:18,000
assuming that there's a snark for batch

68
00:02:18,000 --> 00:02:19,040
np

69
00:02:19,040 --> 00:02:21,040
i just want to mention that the set of

70
00:02:21,040 --> 00:02:22,800
languages that have competition also

71
00:02:22,800 --> 00:02:25,360
nothing with bcps includes p

72
00:02:25,360 --> 00:02:27,680
but also classes such as batch np which

73
00:02:27,680 --> 00:02:29,840
we've done this year but um

74
00:02:29,840 --> 00:02:31,680
we're assuming it and but also it's

75
00:02:31,680 --> 00:02:34,160
class ntisp which is a which is a

76
00:02:34,160 --> 00:02:36,400
subclass of mp um that consists of all

77
00:02:36,400 --> 00:02:38,400
non-deterministic computations done in

78
00:02:38,400 --> 00:02:40,879
time t and space s

79
00:02:40,879 --> 00:02:41,140
um

80
00:02:41,140 --> 00:02:44,230
[Music]

81
00:02:44,640 --> 00:02:46,480
and we will also talk about some

82
00:02:46,480 --> 00:02:48,000
statistical soundness and post quantum

83
00:02:48,000 --> 00:02:50,319
sound is but we won't get to that yet so

84
00:02:50,319 --> 00:02:51,680
first we'll start out by this connection

85
00:02:51,680 --> 00:02:53,120
between snarks four languages and

86
00:02:53,120 --> 00:02:55,519
calculations with pcps from sniper batch

87
00:02:55,519 --> 00:02:57,840
mp

88
00:02:58,080 --> 00:02:59,040
so

89
00:02:59,040 --> 00:03:00,080
to

90
00:03:00,080 --> 00:03:02,400
just to start um let's talk about

91
00:03:02,400 --> 00:03:04,159
instead of publicly verified with snarks

92
00:03:04,159 --> 00:03:05,760
which we want to get we'll talk about

93
00:03:05,760 --> 00:03:07,599
existing work on privately verifiable

94
00:03:07,599 --> 00:03:10,319
snarks um so the works of kalai ross and

95
00:03:10,319 --> 00:03:12,400
ross bloom and breikerski hunger and

96
00:03:12,400 --> 00:03:14,400
collage showed that there exists a

97
00:03:14,400 --> 00:03:16,480
privately verifiable snark for any

98
00:03:16,480 --> 00:03:17,599
language how the computer not

99
00:03:17,599 --> 00:03:20,959
non-signaling pcp i'm assuming fhe or

100
00:03:20,959 --> 00:03:23,040
like instead of a pr scheme

101
00:03:23,040 --> 00:03:25,519
and once again um

102
00:03:25,519 --> 00:03:27,120
like the set of languages that have

103
00:03:27,120 --> 00:03:29,840
computed non-signaling pcps include p

104
00:03:29,840 --> 00:03:30,840
bash and

105
00:03:30,840 --> 00:03:32,480
pntsp

106
00:03:32,480 --> 00:03:34,000
so let me tell you how this privately

107
00:03:34,000 --> 00:03:36,319
verifiable stuff works

108
00:03:36,319 --> 00:03:38,720
um so we have a program and a verifier

109
00:03:38,720 --> 00:03:41,120
the verifier is going to compute a set

110
00:03:41,120 --> 00:03:43,760
of pcp queries along with a set of

111
00:03:43,760 --> 00:03:46,879
public and secret keys um for for the

112
00:03:46,879 --> 00:03:49,280
 scheme so one for each of the query

113
00:03:49,280 --> 00:03:51,280
locations

114
00:03:51,280 --> 00:03:54,400
um they're going to send encryptions

115
00:03:54,400 --> 00:03:57,120
of um each of the query locations under

116
00:03:57,120 --> 00:03:59,040
just like fhe scheme so

117
00:03:59,040 --> 00:04:02,959
q1 is um the encryption of sorry q1 hat

118
00:04:02,959 --> 00:04:05,519
is the encryption of q1 with the public

119
00:04:05,519 --> 00:04:08,799
key pk1 and so on um and the very heart

120
00:04:08,799 --> 00:04:10,720
is also going to keep in his head this

121
00:04:10,720 --> 00:04:12,239
trap door which is because of all the

122
00:04:12,239 --> 00:04:14,080
secret keys

123
00:04:14,080 --> 00:04:15,280
the approver

124
00:04:15,280 --> 00:04:17,519
is going to

125
00:04:17,519 --> 00:04:20,478
compute the pcp pi

126
00:04:20,478 --> 00:04:22,560
and then send back

127
00:04:22,560 --> 00:04:25,199
the encryptions of the answers at the

128
00:04:25,199 --> 00:04:27,759
location of q1 to ql which they are able

129
00:04:27,759 --> 00:04:29,520
to compute under the hood so they're

130
00:04:29,520 --> 00:04:31,840
able to take these encrypted queries um

131
00:04:31,840 --> 00:04:33,759
and compute these encrypted answers um

132
00:04:33,759 --> 00:04:36,080
the verifier then takes the trapdoor

133
00:04:36,080 --> 00:04:37,919
which you know he has kept secret in the

134
00:04:37,919 --> 00:04:41,040
brain um and will invert the encrypted

135
00:04:41,040 --> 00:04:43,759
answers um and then check the resulting

136
00:04:43,759 --> 00:04:46,639
plaintext answers

137
00:04:46,880 --> 00:04:49,900
so this is known as a bmw heuristic

138
00:04:49,900 --> 00:04:51,600
[Music]

139
00:04:51,600 --> 00:04:52,880
and

140
00:04:52,880 --> 00:04:55,199
so the question of whether about this um

141
00:04:55,199 --> 00:04:56,639
this paradigm is sound in general for an

142
00:04:56,639 --> 00:04:59,040
arbitrary pcp was open for a while

143
00:04:59,040 --> 00:05:00,320
actually it was known that it was not

144
00:05:00,320 --> 00:05:02,000
sound for an arbitrary pcp and there's a

145
00:05:02,000 --> 00:05:03,759
question like you know which pieces it's

146
00:05:03,759 --> 00:05:06,080
actually stand for um and it turns out

147
00:05:06,080 --> 00:05:06,960
that

148
00:05:06,960 --> 00:05:10,720
the condition that is in theory is um if

149
00:05:10,720 --> 00:05:12,400
um it's like the that the pcp is

150
00:05:12,400 --> 00:05:14,479
computational non-signaling so i won't

151
00:05:14,479 --> 00:05:16,080
tell you what computational heavily

152
00:05:16,080 --> 00:05:17,680
means um the only important thing for

153
00:05:17,680 --> 00:05:19,919
this talk is that this is like the

154
00:05:19,919 --> 00:05:22,960
property we need for this bmw paradigm

155
00:05:22,960 --> 00:05:25,840
to be sound

156
00:05:27,440 --> 00:05:29,520
so today we're going to get rid of a

157
00:05:29,520 --> 00:05:32,160
pair of privately verifiable applause

158
00:05:32,160 --> 00:05:33,600
and hopefully get just publicly

159
00:05:33,600 --> 00:05:36,160
verifiable

160
00:05:36,160 --> 00:05:38,080
so to do this we're going to depart from

161
00:05:38,080 --> 00:05:39,520
this like privately verifiable

162
00:05:39,520 --> 00:05:42,400
non-interactive argument and go to and

163
00:05:42,400 --> 00:05:44,720
talk a little bit about a publicly

164
00:05:44,720 --> 00:05:47,440
verifiable interactive argument

165
00:05:47,440 --> 00:05:49,360
so that is you know the famous killian

166
00:05:49,360 --> 00:05:50,479
protocol

167
00:05:50,479 --> 00:05:51,280
so

168
00:05:51,280 --> 00:05:53,360
um killian's protocol works as follows

169
00:05:53,360 --> 00:05:56,960
um the basic idea is that um the proofer

170
00:05:56,960 --> 00:05:59,039
is going to compute this route which is

171
00:05:59,039 --> 00:06:01,680
a commitment to pcp pi send it over to

172
00:06:01,680 --> 00:06:05,039
the verifier who then sends over um you

173
00:06:05,039 --> 00:06:05,919
know

174
00:06:05,919 --> 00:06:08,960
picks a random pcp query and ask the pc

175
00:06:08,960 --> 00:06:11,680
of approver to reply with the answers to

176
00:06:11,680 --> 00:06:14,400
those locations along with openings to

177
00:06:14,400 --> 00:06:16,160
the commitment to show that they were in

178
00:06:16,160 --> 00:06:18,479
fact the pcp answers the approver had

179
00:06:18,479 --> 00:06:21,360
committed to previously um and so in

180
00:06:21,360 --> 00:06:22,960
order for there to be these local

181
00:06:22,960 --> 00:06:25,280
openings um we'll need like a hash

182
00:06:25,280 --> 00:06:27,039
function a commitment scheme which

183
00:06:27,039 --> 00:06:30,240
allows for local openings or just like

184
00:06:30,240 --> 00:06:32,880
um it's like to open to like give the

185
00:06:32,880 --> 00:06:34,720
value of a location and

186
00:06:34,720 --> 00:06:35,680
have

187
00:06:35,680 --> 00:06:37,360
it be verifiable without having to open

188
00:06:37,360 --> 00:06:39,520
everything um because pc pi might be

189
00:06:39,520 --> 00:06:42,160
very long and this is um so this exists

190
00:06:42,160 --> 00:06:43,919
and is known as a tree commitment scheme

191
00:06:43,919 --> 00:06:45,039
and i won't go back to see how that

192
00:06:45,039 --> 00:06:46,800
works but just know that it's a scheme

193
00:06:46,800 --> 00:06:49,360
with a local opening

194
00:06:49,360 --> 00:06:51,440
so our observation is that the first two

195
00:06:51,440 --> 00:06:53,120
rounds of the killian protocol look a

196
00:06:53,120 --> 00:06:55,840
lot like an instantiation of prr if the

197
00:06:55,840 --> 00:06:58,560
pcp is completely not signaling and if

198
00:06:58,560 --> 00:07:03,120
the h is a tree hatched pr scheme

199
00:07:03,120 --> 00:07:05,440
um

200
00:07:05,440 --> 00:07:06,960
and so the question then is like you

201
00:07:06,960 --> 00:07:08,960
know does this tree hashed peers game

202
00:07:08,960 --> 00:07:11,840
exist and the answer is yes it does um

203
00:07:11,840 --> 00:07:12,720
it's something called a summer

204
00:07:12,720 --> 00:07:14,800
statistically binding hash

205
00:07:14,800 --> 00:07:16,800
so let's talk about that

206
00:07:16,800 --> 00:07:19,120
um so somewhere statistically binding

207
00:07:19,120 --> 00:07:21,199
hash is a hash function with local

208
00:07:21,199 --> 00:07:22,639
opening

209
00:07:22,639 --> 00:07:24,319
that can be binding on an index of your

210
00:07:24,319 --> 00:07:26,400
choice um so here we're going to be

211
00:07:26,400 --> 00:07:30,080
running on the nxi to get a hash key for

212
00:07:30,080 --> 00:07:33,039
the binding on i along with the trapdoor

213
00:07:33,039 --> 00:07:34,479
and you have the property that is

214
00:07:34,479 --> 00:07:35,680
possible

215
00:07:35,680 --> 00:07:36,800
to

216
00:07:36,800 --> 00:07:40,800
um take a hash of your of x

217
00:07:40,800 --> 00:07:43,360
and which is binding on index i and

218
00:07:43,360 --> 00:07:45,039
invert it using the trapdoor to get the

219
00:07:45,039 --> 00:07:46,560
location x i

220
00:07:46,560 --> 00:07:47,759
um

221
00:07:47,759 --> 00:07:48,879
and the second property we're going to

222
00:07:48,879 --> 00:07:51,680
want is that for any two possible

223
00:07:51,680 --> 00:07:53,599
locations that you're binding

224
00:07:53,599 --> 00:07:55,759
is you can't tell which of the two

225
00:07:55,759 --> 00:07:57,360
locations your hash function is binding

226
00:07:57,360 --> 00:07:58,720
on

227
00:07:58,720 --> 00:08:00,479
i mean so these are like you know um

228
00:08:00,479 --> 00:08:02,160
these are the properties of a pure

229
00:08:02,160 --> 00:08:04,400
scheme in the sense that a pure scheme

230
00:08:04,400 --> 00:08:06,080
has privacy which means that you can't

231
00:08:06,080 --> 00:08:07,599
tell which location

232
00:08:07,599 --> 00:08:09,680
you're finding on um which

233
00:08:09,680 --> 00:08:11,440
location you're asking and that's

234
00:08:11,440 --> 00:08:13,680
exactly the second property here

235
00:08:13,680 --> 00:08:16,080
it also has a property that you can

236
00:08:16,080 --> 00:08:18,960
invert any possible response to figure

237
00:08:18,960 --> 00:08:20,560
out what

238
00:08:20,560 --> 00:08:22,560
the other person was sending you under

239
00:08:22,560 --> 00:08:24,080
the hood and that's the first property

240
00:08:24,080 --> 00:08:24,879
here

241
00:08:24,879 --> 00:08:28,000
so extractable and private

242
00:08:28,000 --> 00:08:30,879
and these ssb hash functions are known

243
00:08:30,879 --> 00:08:35,039
to exist assuming the hardness of lwe

244
00:08:36,240 --> 00:08:38,240
so let's return again to the claim

245
00:08:38,240 --> 00:08:40,880
protocol where we have used these ssb

246
00:08:40,880 --> 00:08:43,599
hash functions um so now our

247
00:08:43,599 --> 00:08:45,200
hash keys that the creator is going to

248
00:08:45,200 --> 00:08:47,920
have to use to compute the commitment is

249
00:08:47,920 --> 00:08:50,480
a sequence of hash keys um one for each

250
00:08:50,480 --> 00:08:52,959
pcp query um so it's going to be binding

251
00:08:52,959 --> 00:08:54,800
on each of the pcp queries that's a ver

252
00:08:54,800 --> 00:08:57,760
um that you know the verifier chooses

253
00:08:57,760 --> 00:09:00,320
um now to compute the

254
00:09:00,320 --> 00:09:02,880
commitment they're going to compute

255
00:09:02,880 --> 00:09:06,240
each hash individually and send over all

256
00:09:06,240 --> 00:09:07,440
l hashes

257
00:09:07,440 --> 00:09:08,720
um and then

258
00:09:08,720 --> 00:09:10,080
you know for the rest of the protocol

259
00:09:10,080 --> 00:09:12,399
verifier is going to ask for a query the

260
00:09:12,399 --> 00:09:14,080
approver is going to

261
00:09:14,080 --> 00:09:16,000
send back the answers along with

262
00:09:16,000 --> 00:09:17,839
openings um

263
00:09:17,839 --> 00:09:19,839
for each of the l hash functions in each

264
00:09:19,839 --> 00:09:21,519
of the

265
00:09:21,519 --> 00:09:24,160
um answers

266
00:09:24,160 --> 00:09:25,279
and

267
00:09:25,279 --> 00:09:27,360
so this is this is a sensation of kr is

268
00:09:27,360 --> 00:09:29,519
sound um

269
00:09:29,519 --> 00:09:31,040
and

270
00:09:31,040 --> 00:09:33,600
the point is that you know in these

271
00:09:33,600 --> 00:09:35,519
first two rounds um the verifiers

272
00:09:35,519 --> 00:09:38,160
actually asked approver for an encrypted

273
00:09:38,160 --> 00:09:41,120
and encrypted answers to the pcp queries

274
00:09:41,120 --> 00:09:42,720
at q star

275
00:09:42,720 --> 00:09:44,640
um and if only they could actually

276
00:09:44,640 --> 00:09:46,560
invert that and figure out you know what

277
00:09:46,560 --> 00:09:48,640
the proverb had sent then this would be

278
00:09:48,640 --> 00:09:49,680
sound

279
00:09:49,680 --> 00:09:53,279
so we note that if um you know this next

280
00:09:53,279 --> 00:09:55,839
query that the verifier asks is equal to

281
00:09:55,839 --> 00:09:58,399
q star the encrypted queries then even

282
00:09:58,399 --> 00:10:00,880
an all powerful adversary cannot find

283
00:10:00,880 --> 00:10:04,720
accepting answers and openings um

284
00:10:04,720 --> 00:10:07,279
it's a kr

285
00:10:07,279 --> 00:10:09,040
so this is like the key point that we

286
00:10:09,040 --> 00:10:12,719
will be using throughout the talk

287
00:10:13,200 --> 00:10:15,200
so this leads us to a new perspective on

288
00:10:15,200 --> 00:10:18,079
the killian protocol which is that we

289
00:10:18,079 --> 00:10:20,640
start with a privately verifiable

290
00:10:20,640 --> 00:10:23,600
instantiation of krr

291
00:10:23,600 --> 00:10:24,399
um

292
00:10:24,399 --> 00:10:27,040
and we want to ask how do we make this

293
00:10:27,040 --> 00:10:29,839
protocol publicly verifiable

294
00:10:29,839 --> 00:10:31,120
so

295
00:10:31,120 --> 00:10:33,440
killian's answer is interaction

296
00:10:33,440 --> 00:10:35,279
um for us we are interested in

297
00:10:35,279 --> 00:10:36,800
constructing non-interactive arguments

298
00:10:36,800 --> 00:10:39,360
so that's not gonna work um

299
00:10:39,360 --> 00:10:42,240
here's a paper that actually achieves um

300
00:10:42,240 --> 00:10:44,560
non-interactive argument

301
00:10:44,560 --> 00:10:46,720
um by collide pannettes and yang which

302
00:10:46,720 --> 00:10:48,640
uses geotestical encryption which is

303
00:10:48,640 --> 00:10:50,560
assumption of bilinear maps

304
00:10:50,560 --> 00:10:51,839
um

305
00:10:51,839 --> 00:10:54,000
we sort of a non-standard assumption not

306
00:10:54,000 --> 00:10:56,000
not sure how to instantiate it

307
00:10:56,000 --> 00:10:57,040
so

308
00:10:57,040 --> 00:10:59,200
um in our work we propose this

309
00:10:59,200 --> 00:11:02,240
alternative idea which is to add an

310
00:11:02,240 --> 00:11:05,680
additional snark that for all possible

311
00:11:05,680 --> 00:11:07,120
questions that the verifier could ask

312
00:11:07,120 --> 00:11:08,959
well for all possible queue which is a

313
00:11:08,959 --> 00:11:10,320
pcp query

314
00:11:10,320 --> 00:11:12,079
um there exists some answers and

315
00:11:12,079 --> 00:11:15,360
openings that the approver could send so

316
00:11:15,360 --> 00:11:17,760
that the verify would accept so in one

317
00:11:17,760 --> 00:11:20,079
shot we're asking approver to convince a

318
00:11:20,079 --> 00:11:21,760
verifier that you know no matter his

319
00:11:21,760 --> 00:11:23,600
next message no matter which queue he

320
00:11:23,600 --> 00:11:24,560
wants

321
00:11:24,560 --> 00:11:26,000
um

322
00:11:26,000 --> 00:11:28,399
you know there will always be an answer

323
00:11:28,399 --> 00:11:29,680
that the proverbial could give that verb

324
00:11:29,680 --> 00:11:31,120
accept another very harder than would

325
00:11:31,120 --> 00:11:32,640
have to ask you anymore because the

326
00:11:32,640 --> 00:11:34,399
proofer has proved to him that

327
00:11:34,399 --> 00:11:35,519
you know it would all he would always

328
00:11:35,519 --> 00:11:37,600
help for any queue

329
00:11:37,600 --> 00:11:39,680
um and we note that this is precisely a

330
00:11:39,680 --> 00:11:42,800
batch mp statement um because it's for

331
00:11:42,800 --> 00:11:45,519
all q so for many possible values of q

332
00:11:45,519 --> 00:11:47,040
um there's this empty statement which is

333
00:11:47,040 --> 00:11:48,320
that there exists

334
00:11:48,320 --> 00:11:50,320
um just like witness w

335
00:11:50,320 --> 00:11:52,240
that v accepts

336
00:11:52,240 --> 00:11:53,680
um so this is about the empty statement

337
00:11:53,680 --> 00:11:56,720
and this force is following language lv

338
00:11:56,720 --> 00:11:57,680
which

339
00:11:57,680 --> 00:12:00,480
is basically that an instance xh root

340
00:12:00,480 --> 00:12:03,360
and query q is in lv

341
00:12:03,360 --> 00:12:05,839
if there exists a witness so answers and

342
00:12:05,839 --> 00:12:07,279
openings i decided the verifier would

343
00:12:07,279 --> 00:12:10,399
accept it

344
00:12:10,399 --> 00:12:12,240
so now let's

345
00:12:12,240 --> 00:12:14,480
see what our stark looks like

346
00:12:14,480 --> 00:12:16,639
um we have the pyramid and verifier

347
00:12:16,639 --> 00:12:18,079
there's gonna the common random string

348
00:12:18,079 --> 00:12:20,079
will consist of

349
00:12:20,079 --> 00:12:23,360
um all l hashes so binding on the q of

350
00:12:23,360 --> 00:12:26,240
the l locations of the pcb query along

351
00:12:26,240 --> 00:12:30,800
with a crs for the batch and p8 snart

352
00:12:30,800 --> 00:12:33,680
um the preview computes the commitment

353
00:12:33,680 --> 00:12:35,680
and within over the

354
00:12:35,680 --> 00:12:39,279
resulting commitment along with a snark

355
00:12:39,279 --> 00:12:42,480
that for all q for all question queries

356
00:12:42,480 --> 00:12:44,240
um the resulting

357
00:12:44,240 --> 00:12:47,519
um statement is in the language lv

358
00:12:47,519 --> 00:12:50,320
um so yeah this is basically our snark

359
00:12:50,320 --> 00:12:53,040
um we're almost done um so basically the

360
00:12:53,040 --> 00:12:55,920
point is that um if x is not in the

361
00:12:55,920 --> 00:12:57,839
language l then

362
00:12:57,839 --> 00:13:00,720
python is a kr and bhk and this is false

363
00:13:00,720 --> 00:13:02,240
in particular for the special q star

364
00:13:02,240 --> 00:13:03,600
that was encrypted

365
00:13:03,600 --> 00:13:04,480
so

366
00:13:04,480 --> 00:13:06,399
then you know so if x is not in a

367
00:13:06,399 --> 00:13:09,440
language then this statement has to be

368
00:13:09,440 --> 00:13:10,399
false because this is false in

369
00:13:10,399 --> 00:13:13,519
particular for q plus q star

370
00:13:13,519 --> 00:13:15,360
um and then the previous should not be

371
00:13:15,360 --> 00:13:16,720
generated as proof successfully so the

372
00:13:16,720 --> 00:13:18,560
variable except so that's argue

373
00:13:18,560 --> 00:13:19,680
soundness

374
00:13:19,680 --> 00:13:21,440
so okay anyway so we're basically done

375
00:13:21,440 --> 00:13:22,800
now

376
00:13:22,800 --> 00:13:26,240
there is one technicality which is that

377
00:13:26,240 --> 00:13:28,399
um the number of statements is very

378
00:13:28,399 --> 00:13:31,920
large um and so in particular

379
00:13:31,920 --> 00:13:35,200
um if you consider a time t computation

380
00:13:35,200 --> 00:13:38,320
the pcp pi will be size at least like on

381
00:13:38,320 --> 00:13:39,519
poly t

382
00:13:39,519 --> 00:13:42,000
um and for a nonsense pcp

383
00:13:42,000 --> 00:13:45,440
the size of a pcp query is poly log t

384
00:13:45,440 --> 00:13:47,199
which means that the number of possible

385
00:13:47,199 --> 00:13:49,760
queries is t to the point log t so now

386
00:13:49,760 --> 00:13:51,360
for the privilege p which generates this

387
00:13:51,360 --> 00:13:53,600
batch mp proof they're going to have to

388
00:13:53,600 --> 00:13:56,560
run in time t to the poly log t which is

389
00:13:56,560 --> 00:13:58,880
pretty large um ideally we would have

390
00:13:58,880 --> 00:14:00,639
poly t

391
00:14:00,639 --> 00:14:02,480
um so turn on this affix to this

392
00:14:02,480 --> 00:14:04,639
um so for all non-technical pcps that we

393
00:14:04,639 --> 00:14:06,480
know of they have the same structure

394
00:14:06,480 --> 00:14:07,920
which is that

395
00:14:07,920 --> 00:14:09,120
there is

396
00:14:09,120 --> 00:14:11,279
um that you can partition any

397
00:14:11,279 --> 00:14:14,079
query into a bunch of tests then you're

398
00:14:14,079 --> 00:14:16,079
checking each test individually and

399
00:14:16,079 --> 00:14:18,720
taking the end of all the tests

400
00:14:18,720 --> 00:14:20,959
um so now we can just replace

401
00:14:20,959 --> 00:14:23,279
this for all q clause with a for all

402
00:14:23,279 --> 00:14:25,760
test clause um so

403
00:14:25,760 --> 00:14:28,720
we're going to check every single test

404
00:14:28,720 --> 00:14:30,720
which there's our only polyt of them

405
00:14:30,720 --> 00:14:31,920
um

406
00:14:31,920 --> 00:14:34,639
and this suffices to check any possible

407
00:14:34,639 --> 00:14:37,120
query queue because a query queue is the

408
00:14:37,120 --> 00:14:39,760
end of a bunch of tests

409
00:14:39,760 --> 00:14:40,959
um and now the number of statements is

410
00:14:40,959 --> 00:14:44,079
poly t and the prover can generate says

411
00:14:44,079 --> 00:14:46,560
bastion p proof and time quality

412
00:14:46,560 --> 00:14:50,720
um so he runs time polyt and we're done

413
00:14:50,720 --> 00:14:53,120
um so that wraps up our construction of

414
00:14:53,120 --> 00:14:54,480
a snark for any language of the

415
00:14:54,480 --> 00:14:58,199
competition officially pcp

416
00:14:59,600 --> 00:15:01,360
i want to return once again to our

417
00:15:01,360 --> 00:15:02,880
earlier discussion of the kilian

418
00:15:02,880 --> 00:15:04,560
protocol as

419
00:15:04,560 --> 00:15:05,920
with the first two rounds be an

420
00:15:05,920 --> 00:15:08,079
instantiation of the krr

421
00:15:08,079 --> 00:15:10,560
vertical

422
00:15:10,560 --> 00:15:13,040
um and just recall once again that this

423
00:15:13,040 --> 00:15:14,800
has a property that is the third message

424
00:15:14,800 --> 00:15:17,120
from the verifier is q star

425
00:15:17,120 --> 00:15:19,040
then even an all-powerful adversary

426
00:15:19,040 --> 00:15:20,959
cannot find existing i'm accepting

427
00:15:20,959 --> 00:15:24,839
answers and openings since i don't exist

428
00:15:24,839 --> 00:15:28,480
um and so and like so since this holds

429
00:15:28,480 --> 00:15:31,519
for q sq star um to argue soundness what

430
00:15:31,519 --> 00:15:34,320
you want to do is just say that if you

431
00:15:34,320 --> 00:15:36,000
set as a written q

432
00:15:36,000 --> 00:15:36,959
um

433
00:15:36,959 --> 00:15:39,680
well you can't tell what was hash or

434
00:15:39,680 --> 00:15:41,040
what was hidden

435
00:15:41,040 --> 00:15:44,959
um in these like hash functions h of q i

436
00:15:44,959 --> 00:15:45,920
star

437
00:15:45,920 --> 00:15:48,160
by this soundness probably like the

438
00:15:48,160 --> 00:15:50,160
privacy and distinguishability of ssb

439
00:15:50,160 --> 00:15:53,279
hash functions so for a random queue

440
00:15:53,279 --> 00:15:54,720
um well you couldn't tell what was in

441
00:15:54,720 --> 00:15:56,240
the hash function so it might as well

442
00:15:56,240 --> 00:15:57,600
happen q

443
00:15:57,600 --> 00:16:00,320
and then it just sound um so that's sort

444
00:16:00,320 --> 00:16:01,279
of like the there's an

445
00:16:01,279 --> 00:16:02,880
indistinguishability that this entire

446
00:16:02,880 --> 00:16:05,040
security is relying on

447
00:16:05,040 --> 00:16:06,320
and turn out this is precisely a

448
00:16:06,320 --> 00:16:08,399
straight line proof of status

449
00:16:08,399 --> 00:16:09,920
so more precisely a straight flying

450
00:16:09,920 --> 00:16:13,120
proof of soundness is a reduction um in

451
00:16:13,120 --> 00:16:14,240
this case is to this

452
00:16:14,240 --> 00:16:16,160
indistinguishability assumption

453
00:16:16,160 --> 00:16:17,279
um

454
00:16:17,279 --> 00:16:19,199
that runs by interacting with the

455
00:16:19,199 --> 00:16:22,800
cheating prover exactly once um so just

456
00:16:22,800 --> 00:16:24,560
sends a message to the approver

457
00:16:24,560 --> 00:16:26,639
versus the answer to another question

458
00:16:26,639 --> 00:16:28,880
and receives an answer

459
00:16:28,880 --> 00:16:30,639
um and

460
00:16:30,639 --> 00:16:32,639
it does not involve any of your bonding

461
00:16:32,639 --> 00:16:34,480
so if you know about existing like this

462
00:16:34,480 --> 00:16:36,720
improve

463
00:16:37,600 --> 00:16:40,320
you might know that the proof involves

464
00:16:40,320 --> 00:16:42,560
running the first two rounds um putting

465
00:16:42,560 --> 00:16:44,160
a bookmark there and then running the

466
00:16:44,160 --> 00:16:45,920
next two rounds and rewinding back to

467
00:16:45,920 --> 00:16:48,720
the to that bookmark many many times and

468
00:16:48,720 --> 00:16:51,519
each time you get a new answer um

469
00:16:51,519 --> 00:16:54,240
which you can then eventually use to

470
00:16:54,240 --> 00:16:56,560
extract the entire pcb uh it's also

471
00:16:56,560 --> 00:16:58,880
rewinding and rewinding is generally

472
00:16:58,880 --> 00:17:01,680
known not to be sound

473
00:17:01,680 --> 00:17:04,640
against quantum adversaries so now that

474
00:17:04,640 --> 00:17:06,880
we are only running

475
00:17:06,880 --> 00:17:09,119
our protocol exactly once no rewinding

476
00:17:09,119 --> 00:17:11,119
um it turns out this is actually this

477
00:17:11,119 --> 00:17:12,480
reduction actually holds for quantum

478
00:17:12,480 --> 00:17:16,120
advertising as well

479
00:17:16,790 --> 00:17:18,640
[Music]

480
00:17:18,640 --> 00:17:21,199
um so we have to prove that which is

481
00:17:21,199 --> 00:17:23,439
that any argument system that is proven

482
00:17:23,439 --> 00:17:25,599
sound via straight line react reduction

483
00:17:25,599 --> 00:17:27,760
it's also post-quantum sound assuming

484
00:17:27,760 --> 00:17:28,880
that the underlying assumption is just

485
00:17:28,880 --> 00:17:31,120
like quantum sound

486
00:17:31,120 --> 00:17:34,480
um and at the corollary we get that

487
00:17:34,480 --> 00:17:35,520
killian

488
00:17:35,520 --> 00:17:37,840
with computational non-significantly pcp

489
00:17:37,840 --> 00:17:40,400
and a parallel ssb hash family is

490
00:17:40,400 --> 00:17:42,320
postponed

491
00:17:42,320 --> 00:17:44,080
um and so this is like a pretty simple

492
00:17:44,080 --> 00:17:47,039
proof of um the fact that killian is

493
00:17:47,039 --> 00:17:48,880
quantum sound this was done

494
00:17:48,880 --> 00:17:50,960
independently in a work by chief moss

495
00:17:50,960 --> 00:17:52,640
booner and d'andry which shows that

496
00:17:52,640 --> 00:17:54,880
killian is post quantum sun for any pcp

497
00:17:54,880 --> 00:17:56,960
and ssb hash function

498
00:17:56,960 --> 00:17:58,400
but they do this using advanced quantum

499
00:17:58,400 --> 00:18:00,960
techniques so the benefit of our

500
00:18:00,960 --> 00:18:03,200
corollary is that

501
00:18:03,200 --> 00:18:04,960
this is understandable for people who

502
00:18:04,960 --> 00:18:05,919
don't have very much affordable

503
00:18:05,919 --> 00:18:06,880
background

504
00:18:06,880 --> 00:18:07,919
um

505
00:18:07,919 --> 00:18:09,280
because all you have to do is witness a

506
00:18:09,280 --> 00:18:10,960
reduction that

507
00:18:10,960 --> 00:18:13,440
um you know quantum health for quantum

508
00:18:13,440 --> 00:18:16,240
adversaries as well

509
00:18:16,640 --> 00:18:18,799
um so i just want to finish by

510
00:18:18,799 --> 00:18:21,360
generalizing this argument for a smaller

511
00:18:21,360 --> 00:18:22,960
class of protocols

512
00:18:22,960 --> 00:18:26,080
um called somewhat cysticly sound

513
00:18:26,080 --> 00:18:27,039
so

514
00:18:27,039 --> 00:18:28,640
somewhere we defined so some artistic

515
00:18:28,640 --> 00:18:29,840
sound arguments are essentially a

516
00:18:29,840 --> 00:18:31,360
generalization of this idea that for the

517
00:18:31,360 --> 00:18:34,960
kilian protocol it's a third message um

518
00:18:34,960 --> 00:18:36,960
there's just a third message such as the

519
00:18:36,960 --> 00:18:38,960
resulting protocol is statistically

520
00:18:38,960 --> 00:18:40,720
sound um

521
00:18:40,720 --> 00:18:43,280
so that's actually what the first um

522
00:18:43,280 --> 00:18:45,200
with the first condition says that there

523
00:18:45,200 --> 00:18:46,960
exists a certain message such that

524
00:18:46,960 --> 00:18:48,000
everything else after that is

525
00:18:48,000 --> 00:18:49,280
statistically sound so the proofer can't

526
00:18:49,280 --> 00:18:51,200
see no matter what

527
00:18:51,200 --> 00:18:54,080
um the second condition is that

528
00:18:54,080 --> 00:18:55,280
um

529
00:18:55,280 --> 00:18:56,240
the certain message is basically

530
00:18:56,240 --> 00:18:58,080
indistinguishable from random um and

531
00:18:58,080 --> 00:19:00,240
that held for our case as well by the

532
00:19:00,240 --> 00:19:02,240
security ssb hash function you can't

533
00:19:02,240 --> 00:19:04,559
tell whether the q or q star was

534
00:19:04,559 --> 00:19:07,360
encrypted in the hash function

535
00:19:07,360 --> 00:19:09,919
um but this allows you to

536
00:19:09,919 --> 00:19:12,559
argue security in general

537
00:19:12,559 --> 00:19:14,480
so as we just sort of showed with the

538
00:19:14,480 --> 00:19:17,039
killian protocol um someone particularly

539
00:19:17,039 --> 00:19:18,480
sound gives you straight line soundness

540
00:19:18,480 --> 00:19:20,799
which gives you both quantum sinus

541
00:19:20,799 --> 00:19:22,880
and we additionally conjecture bacterial

542
00:19:22,880 --> 00:19:25,360
scenarios again that any sss interactive

543
00:19:25,360 --> 00:19:28,160
argument is the actual mirror friendly

544
00:19:28,160 --> 00:19:30,799
um if you don't know what vhbr is um

545
00:19:30,799 --> 00:19:32,799
it's a paradigm which allows you to turn

546
00:19:32,799 --> 00:19:34,400
any interactive argument or any

547
00:19:34,400 --> 00:19:36,240
interactive protocol into a

548
00:19:36,240 --> 00:19:38,000
non-attractive one and you do this by

549
00:19:38,000 --> 00:19:40,000
replacing every verifier message with a

550
00:19:40,000 --> 00:19:42,000
hash of everything so far so a hash of

551
00:19:42,000 --> 00:19:42,880
the

552
00:19:42,880 --> 00:19:45,840
all the prerequisites of references

553
00:19:45,840 --> 00:19:47,760
um and so all the works updating this

554
00:19:47,760 --> 00:19:48,960
talk that i mentioned constructing

555
00:19:48,960 --> 00:19:51,760
snarks um most of them did sewed through

556
00:19:51,760 --> 00:19:54,400
the fiasco mirror paragon um and proving

557
00:19:54,400 --> 00:19:55,760
that it is sound

558
00:19:55,760 --> 00:19:58,000
so fioshamir is known to be

559
00:19:58,000 --> 00:20:00,320
unsound in general for arguments but is

560
00:20:00,320 --> 00:20:02,880
known to be sound for some

561
00:20:02,880 --> 00:20:06,080
like many um proofs and so there's a

562
00:20:06,080 --> 00:20:08,159
question which is like which which which

563
00:20:08,159 --> 00:20:10,640
protocols is the action mirror actually

564
00:20:10,640 --> 00:20:12,640
signed for

565
00:20:12,640 --> 00:20:14,000
um and so i guess what we're doing in

566
00:20:14,000 --> 00:20:16,000
this work is that we're conjecturing

567
00:20:16,000 --> 00:20:17,039
that

568
00:20:17,039 --> 00:20:17,919
um

569
00:20:17,919 --> 00:20:20,159
that there's that the idea of being so

570
00:20:20,159 --> 00:20:21,520
much statistically sound is enough to be

571
00:20:21,520 --> 00:20:23,679
fashionable friendly or for a fiasco

572
00:20:23,679 --> 00:20:25,520
should be sound

573
00:20:25,520 --> 00:20:27,360
um and so the idea is

574
00:20:27,360 --> 00:20:29,440
there exists a message for which the

575
00:20:29,440 --> 00:20:31,440
protocol is the food sound and in

576
00:20:31,440 --> 00:20:32,960
general um there's an

577
00:20:32,960 --> 00:20:36,320
indistinguishability as an argument

578
00:20:36,320 --> 00:20:38,960
um and so i guess essentially what a

579
00:20:38,960 --> 00:20:40,559
statistic some more statistically sound

580
00:20:40,559 --> 00:20:43,440
argument is is a hybrid between a four

581
00:20:43,440 --> 00:20:45,919
argument on which everything is you know

582
00:20:45,919 --> 00:20:47,280
just an argument

583
00:20:47,280 --> 00:20:49,919
and a proof on in which is something

584
00:20:49,919 --> 00:20:52,640
specifically sound so somewhere a proof

585
00:20:52,640 --> 00:20:54,799
and it's an argument and we can make

586
00:20:54,799 --> 00:20:57,120
sure this is the right property for

587
00:20:57,120 --> 00:21:00,879
an argument to be fashionably

588
00:21:01,200 --> 00:21:03,600
so to summarize um our key contribution

589
00:21:03,600 --> 00:21:05,039
is a new perspective on killian's

590
00:21:05,039 --> 00:21:07,280
protocol as a publicly verifiable and

591
00:21:07,280 --> 00:21:10,000
interactive variant of kr

592
00:21:10,000 --> 00:21:12,159
um and we have a few

593
00:21:12,159 --> 00:21:14,000
few different branchings out of that

594
00:21:14,000 --> 00:21:16,799
that would um that we um

595
00:21:16,799 --> 00:21:18,080
explore

596
00:21:18,080 --> 00:21:20,000
so the first is we are able to construct

597
00:21:20,000 --> 00:21:21,440
a snark for any language that has a

598
00:21:21,440 --> 00:21:23,840
computational non-signaling tcp pretty

599
00:21:23,840 --> 00:21:26,559
much not preventing p

600
00:21:26,559 --> 00:21:27,840
um we also define this notion of

601
00:21:27,840 --> 00:21:29,360
somewhere histogram soundness and we

602
00:21:29,360 --> 00:21:30,640
show that this implies treatment

603
00:21:30,640 --> 00:21:33,039
soundness which then implies quantum

604
00:21:33,039 --> 00:21:34,720
zones

605
00:21:34,720 --> 00:21:36,960
and we also conjecture that any sss

606
00:21:36,960 --> 00:21:38,559
interactive argument it's judgement

607
00:21:38,559 --> 00:21:40,159
friendly

608
00:21:40,159 --> 00:21:42,799
um so that concludes my talk um thank

609
00:21:42,799 --> 00:21:45,840
you for listening

