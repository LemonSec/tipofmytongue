1
00:00:01,280 --> 00:00:03,760
hi i'm arushi i'm going to present this

2
00:00:03,760 --> 00:00:06,000
joint work with benny applebaum on

3
00:00:06,000 --> 00:00:08,400
actively secure elementary nbc

4
00:00:08,400 --> 00:00:10,400
reductions

5
00:00:10,400 --> 00:00:13,040
secure multiparty computation is an

6
00:00:13,040 --> 00:00:15,280
interactive protocol that allows a group

7
00:00:15,280 --> 00:00:17,600
of mutually distrusting parties to

8
00:00:17,600 --> 00:00:19,520
jointly compute a function on their

9
00:00:19,520 --> 00:00:21,359
private inputs

10
00:00:21,359 --> 00:00:24,480
the security of mpc guarantees that an

11
00:00:24,480 --> 00:00:26,560
adversary who corrupts a subset of the

12
00:00:26,560 --> 00:00:29,199
parties does not learn anything beyond

13
00:00:29,199 --> 00:00:32,238
the output of the function

14
00:00:32,238 --> 00:00:34,640
since its inception the design of mpc

15
00:00:34,640 --> 00:00:37,600
protocols have quite heavily relied on

16
00:00:37,600 --> 00:00:40,160
the notion of secure reductions

17
00:00:40,160 --> 00:00:42,239
we say that a problem of securely

18
00:00:42,239 --> 00:00:45,280
computing a function f reduces to the

19
00:00:45,280 --> 00:00:48,480
task of computing a simpler function g

20
00:00:48,480 --> 00:00:51,039
if there exists an interactive protocol

21
00:00:51,039 --> 00:00:53,520
for computing f where the parties have

22
00:00:53,520 --> 00:00:56,160
access to an oracle implementing the

23
00:00:56,160 --> 00:00:59,680
function g given such a reduction the

24
00:00:59,680 --> 00:01:02,559
original task is now reduced to simply

25
00:01:02,559 --> 00:01:04,799
designing a secure protocol for the

26
00:01:04,799 --> 00:01:07,040
function g

27
00:01:07,040 --> 00:01:09,840
classical examples of protocols

28
00:01:09,840 --> 00:01:13,280
by yao and goldrich at all can be viewed

29
00:01:13,280 --> 00:01:15,520
as secure reductions to the two-party

30
00:01:15,520 --> 00:01:19,360
oblivious transfer functionality

31
00:01:19,360 --> 00:01:21,960
going a step ahead we see that if

32
00:01:21,960 --> 00:01:24,400
non-interactively reduces to a function

33
00:01:24,400 --> 00:01:27,680
g if the parties in the protocol only

34
00:01:27,680 --> 00:01:30,320
send single queries to the oracle g and

35
00:01:30,320 --> 00:01:33,600
do not interact with each other at all

36
00:01:33,600 --> 00:01:35,840
before moving ahead let me emphasize on

37
00:01:35,840 --> 00:01:37,360
a key point here

38
00:01:37,360 --> 00:01:39,759
the function g is allowed to have its

39
00:01:39,759 --> 00:01:42,240
own internal randomness and need not

40
00:01:42,240 --> 00:01:44,479
necessarily be deterministic

41
00:01:44,479 --> 00:01:46,399
in fact there exists general

42
00:01:46,399 --> 00:01:48,720
non-interactive reductions from such

43
00:01:48,720 --> 00:01:52,720
functionalities to deterministic ones

44
00:01:52,720 --> 00:01:54,799
in this work we consider the notion of

45
00:01:54,799 --> 00:01:56,640
elementary reductions

46
00:01:56,640 --> 00:01:58,880
these are non-interactive reductions

47
00:01:58,880 --> 00:02:00,960
where the function g is a constant

48
00:02:00,960 --> 00:02:02,479
degree function

49
00:02:02,479 --> 00:02:05,119
moreover the reduction is only allowed

50
00:02:05,119 --> 00:02:08,479
to make use of a prg in a black box way

51
00:02:08,479 --> 00:02:11,120
this additionally means that g is

52
00:02:11,120 --> 00:02:14,879
independent of the prg

53
00:02:14,879 --> 00:02:17,120
such black box restrictions typically

54
00:02:17,120 --> 00:02:19,680
make things highly efficient

55
00:02:19,680 --> 00:02:22,000
and this notion of elementary reduction

56
00:02:22,000 --> 00:02:24,879
also captures many classical reductions

57
00:02:24,879 --> 00:02:28,239
as we will see going forward

58
00:02:28,239 --> 00:02:30,640
pictorially an elementary reduction

59
00:02:30,640 --> 00:02:32,239
looks like the following

60
00:02:32,239 --> 00:02:33,920
the parties run some local

61
00:02:33,920 --> 00:02:36,400
pre-processing on their inputs

62
00:02:36,400 --> 00:02:38,720
this preprocessing function can make

63
00:02:38,720 --> 00:02:41,360
oracle queries to a prg

64
00:02:41,360 --> 00:02:43,440
the parties then send the output of the

65
00:02:43,440 --> 00:02:47,519
preprocessing functions to the oracle g

66
00:02:47,519 --> 00:02:49,680
given the output of g the parties do

67
00:02:49,680 --> 00:02:52,400
some local post processing to learn the

68
00:02:52,400 --> 00:02:54,080
final output

69
00:02:54,080 --> 00:02:56,080
note that while the pre-processing and

70
00:02:56,080 --> 00:02:57,920
post-processing functions in this

71
00:02:57,920 --> 00:03:00,640
protocol are allowed to make oracle

72
00:03:00,640 --> 00:03:02,720
queries to the prg

73
00:03:02,720 --> 00:03:05,360
oracle g or the functionality g is

74
00:03:05,360 --> 00:03:09,040
completely independent of it

75
00:03:09,440 --> 00:03:11,360
several existing non-interactive

76
00:03:11,360 --> 00:03:13,680
reductions in literature are in fact

77
00:03:13,680 --> 00:03:15,599
elementary reductions

78
00:03:15,599 --> 00:03:17,519
in the semionis setting the two-party

79
00:03:17,519 --> 00:03:20,480
protocol of yao and the constant round

80
00:03:20,480 --> 00:03:23,280
multi-party protocol of beaver mikali in

81
00:03:23,280 --> 00:03:26,000
rokuway is an elementary reduction for

82
00:03:26,000 --> 00:03:28,480
all efficiently computable functions in

83
00:03:28,480 --> 00:03:31,040
the dishonest majority setting

84
00:03:31,040 --> 00:03:34,959
in fact the bmi protocol also has an

85
00:03:34,959 --> 00:03:37,280
actively secure version based on zero

86
00:03:37,280 --> 00:03:38,239
knowledge

87
00:03:38,239 --> 00:03:40,879
but that protocol is interactive and

88
00:03:40,879 --> 00:03:45,200
non-black box with respect to a brg

89
00:03:45,280 --> 00:03:47,280
in the malicious setting however we

90
00:03:47,280 --> 00:03:49,760
either know of elementary reductions

91
00:03:49,760 --> 00:03:51,760
with full security in the honest

92
00:03:51,760 --> 00:03:54,560
majority setting or only for nc1

93
00:03:54,560 --> 00:03:56,159
functionalities in the dishonest

94
00:03:56,159 --> 00:03:57,840
majority setting

95
00:03:57,840 --> 00:04:00,239
existing elementary reductions for all

96
00:04:00,239 --> 00:04:02,640
efficiently computable functions in the

97
00:04:02,640 --> 00:04:04,959
dishonest majority setting are only

98
00:04:04,959 --> 00:04:08,159
known to achieve security with a bot

99
00:04:08,159 --> 00:04:10,319
we do not know of any elementary

100
00:04:10,319 --> 00:04:12,319
reduction in the setting that achieves

101
00:04:12,319 --> 00:04:15,280
full security

102
00:04:15,280 --> 00:04:17,120
apple bomb at all showed that a

103
00:04:17,120 --> 00:04:19,600
non-elementary non-interactive reduction

104
00:04:19,600 --> 00:04:21,440
in this setting

105
00:04:21,440 --> 00:04:24,000
to a constant degree function g where g

106
00:04:24,000 --> 00:04:27,360
depends on the prg

107
00:04:27,360 --> 00:04:28,960
therefore the main question that we

108
00:04:28,960 --> 00:04:31,120
consider in this setting is whether

109
00:04:31,120 --> 00:04:33,600
there exists an elementary reduction

110
00:04:33,600 --> 00:04:35,840
that achieves full security against a

111
00:04:35,840 --> 00:04:37,600
dishonest majority

112
00:04:37,600 --> 00:04:40,160
in this setting

113
00:04:40,160 --> 00:04:42,639
we show that while an elementary

114
00:04:42,639 --> 00:04:45,199
reduction with full security is unlikely

115
00:04:45,199 --> 00:04:47,759
to exist in this setting it is possible

116
00:04:47,759 --> 00:04:49,759
to design a reduction that achieves

117
00:04:49,759 --> 00:04:51,520
identifiable bond

118
00:04:51,520 --> 00:04:55,040
let me now elaborate on these results

119
00:04:55,040 --> 00:04:57,680
to establish our low amount we show that

120
00:04:57,680 --> 00:04:59,680
for two parties existence of an

121
00:04:59,680 --> 00:05:02,400
elementary reduction for all efficiently

122
00:05:02,400 --> 00:05:04,720
computable functions with partial

123
00:05:04,720 --> 00:05:07,280
fairness that is where fairness is only

124
00:05:07,280 --> 00:05:09,520
guaranteed when one of the parties is

125
00:05:09,520 --> 00:05:10,400
corrupt

126
00:05:10,400 --> 00:05:12,880
implies existence of an information

127
00:05:12,880 --> 00:05:15,759
theoretic reduction for any efficiently

128
00:05:15,759 --> 00:05:18,400
computable function in the crs model

129
00:05:18,400 --> 00:05:20,560
with inverse polynomial average case

130
00:05:20,560 --> 00:05:23,199
privacy against passive adversaries

131
00:05:23,199 --> 00:05:25,680
here by information theoretic reduction

132
00:05:25,680 --> 00:05:27,919
we mean that the parties are not allowed

133
00:05:27,919 --> 00:05:30,880
to make black box calls to a prg

134
00:05:30,880 --> 00:05:32,479
even though we don't prove an

135
00:05:32,479 --> 00:05:34,320
unconditional impossibility in the

136
00:05:34,320 --> 00:05:36,960
setting the implications of this result

137
00:05:36,960 --> 00:05:38,880
are highly non-trivial

138
00:05:38,880 --> 00:05:41,919
this is because this implication implies

139
00:05:41,919 --> 00:05:44,639
constant round information theoretic mpc

140
00:05:44,639 --> 00:05:46,960
protocols that are far beyond the

141
00:05:46,960 --> 00:05:50,159
current state of the art

142
00:05:50,720 --> 00:05:52,960
for instance existence of such an

143
00:05:52,960 --> 00:05:54,560
information theoretic elementary

144
00:05:54,560 --> 00:05:57,039
reduction implies existence of a

145
00:05:57,039 --> 00:05:59,600
constant round two party protocol for

146
00:05:59,600 --> 00:06:01,680
efficiently computable functions with

147
00:06:01,680 --> 00:06:04,240
inverse polynomial average case

148
00:06:04,240 --> 00:06:06,479
information theoretic security in the ot

149
00:06:06,479 --> 00:06:08,400
hybrid model

150
00:06:08,400 --> 00:06:11,039
this in turn implies a constant round

151
00:06:11,039 --> 00:06:13,600
protocol for all three party efficiently

152
00:06:13,600 --> 00:06:15,280
computable functions

153
00:06:15,280 --> 00:06:17,680
with inverse polynomial average case

154
00:06:17,680 --> 00:06:20,639
information theoretic security existence

155
00:06:20,639 --> 00:06:23,039
of a such a protocol is a well-known

156
00:06:23,039 --> 00:06:26,479
three-decade open problem

157
00:06:26,960 --> 00:06:29,039
while the original question formulated

158
00:06:29,039 --> 00:06:31,440
in the work of beaver mikali in rokubay

159
00:06:31,440 --> 00:06:34,080
is with respect to standard security the

160
00:06:34,080 --> 00:06:36,720
relaxation to inverse polynomial average

161
00:06:36,720 --> 00:06:38,880
case security does not seem to make it

162
00:06:38,880 --> 00:06:41,280
any more tractable

163
00:06:41,280 --> 00:06:44,240
as for our positive result we show that

164
00:06:44,240 --> 00:06:45,680
an elementary reduction with

165
00:06:45,680 --> 00:06:47,759
identifiable abort does exist in this

166
00:06:47,759 --> 00:06:50,479
setting a similar reduction is also

167
00:06:50,479 --> 00:06:53,199
implicit in a recent concurrent work

168
00:06:53,199 --> 00:06:55,120
we additionally show that it is possible

169
00:06:55,120 --> 00:06:57,199
to achieve fairness if the parties are

170
00:06:57,199 --> 00:06:59,199
allowed to interact more than once with

171
00:06:59,199 --> 00:07:00,720
the oracle g

172
00:07:00,720 --> 00:07:03,280
and moreover if g is allowed to depend

173
00:07:03,280 --> 00:07:05,039
on the prg

174
00:07:05,039 --> 00:07:06,800
then it is also possible to get full

175
00:07:06,800 --> 00:07:09,680
security in fact any passively secure

176
00:07:09,680 --> 00:07:11,840
elementary reduction can be transformed

177
00:07:11,840 --> 00:07:14,319
into an actively secure one which is

178
00:07:14,319 --> 00:07:17,199
non-interactive but does depend on the

179
00:07:17,199 --> 00:07:20,639
prg in a non-black box way

180
00:07:20,639 --> 00:07:22,720
let me now elaborate on the main ideas

181
00:07:22,720 --> 00:07:25,039
used in our lower bound result

182
00:07:25,039 --> 00:07:27,280
to build intuition i will begin with by

183
00:07:27,280 --> 00:07:29,520
showing why existing passively secure

184
00:07:29,520 --> 00:07:32,639
elementary reductions fail to achieve

185
00:07:32,639 --> 00:07:35,199
full security against active adversaries

186
00:07:35,199 --> 00:07:39,120
and then prove our general theorem

187
00:07:39,840 --> 00:07:42,160
all existing passively secure elementary

188
00:07:42,160 --> 00:07:44,160
reductions can be viewed as a

189
00:07:44,160 --> 00:07:46,960
distributed variant of karbling where in

190
00:07:46,960 --> 00:07:48,960
the pre-processing phase the parties

191
00:07:48,960 --> 00:07:52,000
sample random keys corresponding to each

192
00:07:52,000 --> 00:07:54,080
wire in the circuit representing the

193
00:07:54,080 --> 00:07:55,599
function f

194
00:07:55,599 --> 00:07:57,840
these keys are then sent to to the

195
00:07:57,840 --> 00:07:59,360
function g

196
00:07:59,360 --> 00:08:02,080
function g computes and outputs a

197
00:08:02,080 --> 00:08:04,720
garbling of the circuit representing the

198
00:08:04,720 --> 00:08:07,440
function f using these keys

199
00:08:07,440 --> 00:08:09,599
and finally in the post processing phase

200
00:08:09,599 --> 00:08:12,319
the parties evaluate the kabul circuit

201
00:08:12,319 --> 00:08:14,319
to learn the output

202
00:08:14,319 --> 00:08:16,879
but so far i haven't addressed what the

203
00:08:16,879 --> 00:08:19,840
prg is used for or if it is even used at

204
00:08:19,840 --> 00:08:21,360
all

205
00:08:21,360 --> 00:08:23,919
recall that in the distributed gobbling

206
00:08:23,919 --> 00:08:26,800
the parties sample random keys for every

207
00:08:26,800 --> 00:08:28,400
wire in the circuit

208
00:08:28,400 --> 00:08:30,639
at a very high level each gate of the

209
00:08:30,639 --> 00:08:33,039
circuit is individually coupled where

210
00:08:33,039 --> 00:08:35,200
gobbling of each gate corresponds to

211
00:08:35,200 --> 00:08:37,839
four randomly permuted ciphertexts

212
00:08:37,839 --> 00:08:39,360
each of these ciphertexts is a

213
00:08:39,360 --> 00:08:41,839
distributed encryption where the keys

214
00:08:41,839 --> 00:08:43,919
correspond to the keys associated with

215
00:08:43,919 --> 00:08:46,080
the incoming wires of the gates and the

216
00:08:46,080 --> 00:08:48,160
message that is encrypted corresponds to

217
00:08:48,160 --> 00:08:50,399
the keys associated with the outgoing

218
00:08:50,399 --> 00:08:53,120
wires of the gate

219
00:08:53,120 --> 00:08:54,800
for circuits with more than poly

220
00:08:54,800 --> 00:08:56,320
logarithmic depth

221
00:08:56,320 --> 00:08:58,560
the keys are required to be shorter than

222
00:08:58,560 --> 00:09:00,160
the messages

223
00:09:00,160 --> 00:09:02,240
therefore the distributed encryption

224
00:09:02,240 --> 00:09:04,880
algorithm first expands the keys using

225
00:09:04,880 --> 00:09:07,600
prgs and then uses them to encrypt the

226
00:09:07,600 --> 00:09:08,800
messages

227
00:09:08,800 --> 00:09:11,120
this key expansion can also be moved

228
00:09:11,120 --> 00:09:13,440
outside of the encryption algorithm and

229
00:09:13,440 --> 00:09:16,720
can be done by the parties locally

230
00:09:16,720 --> 00:09:19,200
so going back the parties sample random

231
00:09:19,200 --> 00:09:21,760
keys for every wire in the circuit and

232
00:09:21,760 --> 00:09:24,480
also expand them using the prg

233
00:09:24,480 --> 00:09:26,399
they then send both the original and

234
00:09:26,399 --> 00:09:28,800
expanded keys to the function g

235
00:09:28,800 --> 00:09:30,880
and g now implements the distributed

236
00:09:30,880 --> 00:09:34,959
encryption algorithm using these keys

237
00:09:34,959 --> 00:09:37,839
the original keys in this distributed

238
00:09:37,839 --> 00:09:39,920
encryption

239
00:09:39,920 --> 00:09:42,800
act as messages and the expanded keys

240
00:09:42,800 --> 00:09:45,279
act as encryption keys

241
00:09:45,279 --> 00:09:47,519
while this reduction achieves privacy

242
00:09:47,519 --> 00:09:50,399
against passive adversaries it fails to

243
00:09:50,399 --> 00:09:52,880
achieve full security against active

244
00:09:52,880 --> 00:09:54,800
adversaries

245
00:09:54,800 --> 00:09:57,279
this is because an active adversary may

246
00:09:57,279 --> 00:10:00,080
send inconsistent original and expanded

247
00:10:00,080 --> 00:10:02,320
key pairs to the function g

248
00:10:02,320 --> 00:10:05,519
since g is independent of the prg it

249
00:10:05,519 --> 00:10:07,360
will be unable to detect such

250
00:10:07,360 --> 00:10:09,920
inconsistencies and will proceed to

251
00:10:09,920 --> 00:10:12,560
implement the distributed encryption

252
00:10:12,560 --> 00:10:13,839
normally

253
00:10:13,839 --> 00:10:16,320
upon receiving the gable circuit

254
00:10:16,320 --> 00:10:18,800
uh from this function g the honest

255
00:10:18,800 --> 00:10:21,360
parties will be unable to decrypt the

256
00:10:21,360 --> 00:10:23,519
ciphertext or in other words evaluate

257
00:10:23,519 --> 00:10:25,440
the kabul circuit because they are

258
00:10:25,440 --> 00:10:27,760
unaware of the quote-unquote new mapping

259
00:10:27,760 --> 00:10:30,839
between the original and expanded

260
00:10:30,839 --> 00:10:33,519
keys but the corrupt parties who are

261
00:10:33,519 --> 00:10:35,680
aware of this mapping can still evaluate

262
00:10:35,680 --> 00:10:37,200
the carpal circuit

263
00:10:37,200 --> 00:10:39,839
as a result they can obtain the output

264
00:10:39,839 --> 00:10:41,839
and this protocol does not achieve

265
00:10:41,839 --> 00:10:45,519
fairness or full security

266
00:10:45,519 --> 00:10:47,680
so far we discussed why existing

267
00:10:47,680 --> 00:10:50,000
elementary reductions are unlikely to

268
00:10:50,000 --> 00:10:52,079
achieve full security against active

269
00:10:52,079 --> 00:10:53,360
adversaries

270
00:10:53,360 --> 00:10:55,120
let me now elaborate on how we

271
00:10:55,120 --> 00:10:57,839
generalize this idea to show that any

272
00:10:57,839 --> 00:11:00,480
such fully secure elementary reduction

273
00:11:00,480 --> 00:11:03,839
is unlikely to exist

274
00:11:04,880 --> 00:11:07,440
to quickly recap we show that for two

275
00:11:07,440 --> 00:11:09,760
parties existence of such an elementary

276
00:11:09,760 --> 00:11:12,160
reduction with partial fairness

277
00:11:12,160 --> 00:11:14,320
implies existence of an information

278
00:11:14,320 --> 00:11:16,560
theoretic elementary reduction

279
00:11:16,560 --> 00:11:18,959
for efficiently computable functions in

280
00:11:18,959 --> 00:11:21,360
the crs model with a weak form of

281
00:11:21,360 --> 00:11:24,320
privacy against passive adversaries

282
00:11:24,320 --> 00:11:26,320
this implication holds even when the

283
00:11:26,320 --> 00:11:28,880
parties have access to a random oracle

284
00:11:28,880 --> 00:11:30,800
which only makes our result statement

285
00:11:30,800 --> 00:11:32,800
stronger

286
00:11:32,800 --> 00:11:34,959
also note that a multi-party fair

287
00:11:34,959 --> 00:11:37,920
elementary reduction implies a two-party

288
00:11:37,920 --> 00:11:40,480
fair elementary reduction which in turn

289
00:11:40,480 --> 00:11:42,800
implies a two party partially fair

290
00:11:42,800 --> 00:11:44,560
elementary reduction

291
00:11:44,560 --> 00:11:46,959
therefore if we rule out a two party

292
00:11:46,959 --> 00:11:48,720
elementary reduction with partial

293
00:11:48,720 --> 00:11:50,800
fairness we can also rule out a

294
00:11:50,800 --> 00:11:54,320
multi-party fair elementary reduction

295
00:11:54,320 --> 00:11:56,880
as a result this restriction to partial

296
00:11:56,880 --> 00:11:59,200
fairness again only makes our theorem

297
00:11:59,200 --> 00:12:01,040
statement stronger

298
00:12:01,040 --> 00:12:03,519
finally this caveat of weak privacy in

299
00:12:03,519 --> 00:12:06,160
our implementation in our implication

300
00:12:06,160 --> 00:12:08,639
can be removed if the parties are only

301
00:12:08,639 --> 00:12:10,399
allowed to make random queries to the

302
00:12:10,399 --> 00:12:13,120
random article

303
00:12:13,440 --> 00:12:16,240
let us now prove this main theorem

304
00:12:16,240 --> 00:12:20,240
we consider two parties alice and bob

305
00:12:20,240 --> 00:12:21,519
let's assume for the sake of

306
00:12:21,519 --> 00:12:23,200
contradiction that there exists an

307
00:12:23,200 --> 00:12:25,040
elementary reduction from every

308
00:12:25,040 --> 00:12:27,839
polynomial size two-party function with

309
00:12:27,839 --> 00:12:29,519
partial fairness

310
00:12:29,519 --> 00:12:32,079
uh against active adversaries and here

311
00:12:32,079 --> 00:12:33,920
we assume that we have partial fairness

312
00:12:33,920 --> 00:12:36,480
against a corrupt bob

313
00:12:36,480 --> 00:12:39,200
for simplicity we assume that the prg is

314
00:12:39,200 --> 00:12:42,240
instantiated with a random oracle each

315
00:12:42,240 --> 00:12:44,160
and for now let us further assume that

316
00:12:44,160 --> 00:12:46,240
the parties invoke the oracle on

317
00:12:46,240 --> 00:12:48,079
randomly chosen seats

318
00:12:48,079 --> 00:12:49,920
i will later elaborate on how the

319
00:12:49,920 --> 00:12:53,839
simplifying assumption can be removed

320
00:12:56,399 --> 00:12:59,120
we consider a corrupt bob that lazy

321
00:12:59,120 --> 00:13:02,560
samples its own oracle g and uses that

322
00:13:02,560 --> 00:13:04,639
in the pre-processing phase instead of

323
00:13:04,639 --> 00:13:07,040
the common random oracle each

324
00:13:07,040 --> 00:13:09,279
in the post processing phase is used it

325
00:13:09,279 --> 00:13:11,680
uses both g and h

326
00:13:11,680 --> 00:13:14,000
in particular it uses each in the post

327
00:13:14,000 --> 00:13:16,639
processing phase for queries that alice

328
00:13:16,639 --> 00:13:18,959
made in its pre-processing phase and it

329
00:13:18,959 --> 00:13:22,320
uses g for the queries that it made on

330
00:13:22,320 --> 00:13:26,560
its uh in during the preprocessing phase

331
00:13:26,560 --> 00:13:28,560
since we assume that the parties query

332
00:13:28,560 --> 00:13:31,519
the oracle on randomly chosen seeds with

333
00:13:31,519 --> 00:13:33,600
a very high probability the set of

334
00:13:33,600 --> 00:13:36,320
inputs on which alice and bob query the

335
00:13:36,320 --> 00:13:38,720
random oracle will be different with a

336
00:13:38,720 --> 00:13:40,639
very high probability

337
00:13:40,639 --> 00:13:42,959
as a result we can pretend that alice

338
00:13:42,959 --> 00:13:45,920
and bob honestly invoked the protocol on

339
00:13:45,920 --> 00:13:49,360
a new random oracle which is obtained by

340
00:13:49,360 --> 00:13:52,880
combining g and h

341
00:13:53,680 --> 00:13:56,240
both oracles are available to bob who

342
00:13:56,240 --> 00:13:58,480
can then use them in the post processing

343
00:13:58,480 --> 00:14:01,839
phase to correctly recover the output

344
00:14:01,839 --> 00:14:04,320
from our original assumption since the

345
00:14:04,320 --> 00:14:07,279
protocol is fair against corrupt bomb

346
00:14:07,279 --> 00:14:09,360
in this case since bob can recover the

347
00:14:09,360 --> 00:14:10,639
output

348
00:14:10,639 --> 00:14:12,480
alice should also be able to recover the

349
00:14:12,480 --> 00:14:14,639
output as a result correctness of this

350
00:14:14,639 --> 00:14:17,839
modified protocol holds

351
00:14:17,839 --> 00:14:20,560
moreover since alice's view in this

352
00:14:20,560 --> 00:14:23,360
modified protocol remains unchanged if

353
00:14:23,360 --> 00:14:25,279
the original protocol was private

354
00:14:25,279 --> 00:14:27,839
against a semi honest alice this

355
00:14:27,839 --> 00:14:30,000
modified protocol is also private

356
00:14:30,000 --> 00:14:32,880
against alice

357
00:14:32,880 --> 00:14:35,279
we can further modify this protocol such

358
00:14:35,279 --> 00:14:38,240
that only alice gets an output by simply

359
00:14:38,240 --> 00:14:40,160
removing the post-processing phase of

360
00:14:40,160 --> 00:14:41,680
bob

361
00:14:41,680 --> 00:14:44,160
since alice's post-processing algorithm

362
00:14:44,160 --> 00:14:46,639
is independent of g we can further

363
00:14:46,639 --> 00:14:49,040
modify the protocol and ask alice to

364
00:14:49,040 --> 00:14:52,959
lazy sample its own oracle h and ask pop

365
00:14:52,959 --> 00:14:57,120
to sample its own oracle g

366
00:14:57,120 --> 00:14:59,360
this gives us an information theoretic

367
00:14:59,360 --> 00:15:01,199
passively secured non-interactive

368
00:15:01,199 --> 00:15:03,760
reduction that delivers an output only

369
00:15:03,760 --> 00:15:06,800
to the first party

370
00:15:07,279 --> 00:15:09,519
to get a protocol that delivers outputs

371
00:15:09,519 --> 00:15:11,920
to both parties we can simply run two

372
00:15:11,920 --> 00:15:14,320
copies of this reduction in parallel

373
00:15:14,320 --> 00:15:16,480
where alice acts as the receiver in one

374
00:15:16,480 --> 00:15:18,959
copy and bob in the other

375
00:15:18,959 --> 00:15:21,199
as a result we obtain an information

376
00:15:21,199 --> 00:15:23,519
theoretic elementary reduction

377
00:15:23,519 --> 00:15:26,160
for all efficiently computable to input

378
00:15:26,160 --> 00:15:27,600
functionalities

379
00:15:27,600 --> 00:15:29,040
but as

380
00:15:29,040 --> 00:15:31,519
discussed earlier such a reduction

381
00:15:31,519 --> 00:15:34,959
implies constant round protocols

382
00:15:34,959 --> 00:15:37,279
whose existence is a long-standing open

383
00:15:37,279 --> 00:15:40,800
problem in information theory

384
00:15:40,800 --> 00:15:42,399
although we have discussed the main

385
00:15:42,399 --> 00:15:44,240
ideas that we use to prove our low

386
00:15:44,240 --> 00:15:46,560
amount we did make some certain

387
00:15:46,560 --> 00:15:48,240
simplifying assumptions

388
00:15:48,240 --> 00:15:50,240
i am now going to briefly discuss how

389
00:15:50,240 --> 00:15:52,079
those simplifying assumptions can be

390
00:15:52,079 --> 00:15:55,199
removed and what technicalities arise as

391
00:15:55,199 --> 00:15:57,360
a result of that

392
00:15:57,360 --> 00:15:59,440
the first assumption that we make is

393
00:15:59,440 --> 00:16:01,279
that the simulation based definition of

394
00:16:01,279 --> 00:16:03,920
fairness implies that if a corrupt bob

395
00:16:03,920 --> 00:16:06,639
gets the output then so should alice

396
00:16:06,639 --> 00:16:08,560
which in fact is not true

397
00:16:08,560 --> 00:16:11,360
instead it only ensures that alice can

398
00:16:11,360 --> 00:16:13,440
generate an output with respect to some

399
00:16:13,440 --> 00:16:16,079
effective input of bob and not

400
00:16:16,079 --> 00:16:17,920
necessarily with respect to the real

401
00:16:17,920 --> 00:16:20,480
input that is given to bob

402
00:16:20,480 --> 00:16:22,320
in order to remove the simplifying

403
00:16:22,320 --> 00:16:24,560
assumption we work with an authenticated

404
00:16:24,560 --> 00:16:27,440
functionality that delivers to bob an

405
00:16:27,440 --> 00:16:30,160
authenticated version of his input

406
00:16:30,160 --> 00:16:33,199
under the key that is chosen by alice

407
00:16:33,199 --> 00:16:34,720
fairness with respect to such

408
00:16:34,720 --> 00:16:37,040
functionalities implies a notion that is

409
00:16:37,040 --> 00:16:40,639
being used in the above argument

410
00:16:40,639 --> 00:16:43,360
the second assumption that we make is

411
00:16:43,360 --> 00:16:45,920
that alice and bob's queries to the prg

412
00:16:45,920 --> 00:16:47,519
do not intersect

413
00:16:47,519 --> 00:16:49,440
to avoid this

414
00:16:49,440 --> 00:16:52,560
we use standard approach of identifying

415
00:16:52,560 --> 00:16:56,160
heavy queries by barack and modi and let

416
00:16:56,160 --> 00:16:59,360
bob use its local oracle g only on the

417
00:16:59,360 --> 00:17:01,040
non heavy queries

418
00:17:01,040 --> 00:17:03,279
this modification introduces several

419
00:17:03,279 --> 00:17:05,520
technicalities that only allows us to

420
00:17:05,520 --> 00:17:07,760
achieve inverse polynomial average case

421
00:17:07,760 --> 00:17:09,119
security

422
00:17:09,119 --> 00:17:11,439
to make sure that this does not affect

423
00:17:11,439 --> 00:17:14,319
correctness of the protocol

424
00:17:14,319 --> 00:17:17,359
we add to the functionality g a detect

425
00:17:17,359 --> 00:17:19,919
and reveal mechanism that identifies a

426
00:17:19,919 --> 00:17:22,480
collision event and reveals the private

427
00:17:22,480 --> 00:17:25,039
in and reveals the private inputs of bob

428
00:17:25,039 --> 00:17:27,679
in case such an event occurs

429
00:17:27,679 --> 00:17:30,000
therefore even if such an event occurs

430
00:17:30,000 --> 00:17:33,840
the correctness remains unaffected

431
00:17:37,120 --> 00:17:39,120
before concluding the discussion on our

432
00:17:39,120 --> 00:17:40,960
lower bound i want to mention an

433
00:17:40,960 --> 00:17:42,720
interesting observation about our mean

434
00:17:42,720 --> 00:17:43,919
theorem

435
00:17:43,919 --> 00:17:46,400
our main theorem shows that the task of

436
00:17:46,400 --> 00:17:48,640
designing an elementary reduction for

437
00:17:48,640 --> 00:17:51,120
all efficiently computable functions

438
00:17:51,120 --> 00:17:53,360
with full security in the dishonest

439
00:17:53,360 --> 00:17:54,880
majority setting

440
00:17:54,880 --> 00:17:57,440
is an example of a cryptographic problem

441
00:17:57,440 --> 00:17:58,720
for which

442
00:17:58,720 --> 00:18:00,960
an information theoretic solution cannot

443
00:18:00,960 --> 00:18:02,480
be ruled out

444
00:18:02,480 --> 00:18:04,880
black box use of a given primitive is

445
00:18:04,880 --> 00:18:07,200
useless for solving the problem

446
00:18:07,200 --> 00:18:09,520
a non-black box use of the primitive

447
00:18:09,520 --> 00:18:12,960
allows us to solve the problem

448
00:18:13,440 --> 00:18:15,679
this combination seems rather unique to

449
00:18:15,679 --> 00:18:16,720
our setting

450
00:18:16,720 --> 00:18:18,960
since we are only aware of examples that

451
00:18:18,960 --> 00:18:22,400
satisfy at most two of these conditions

452
00:18:22,400 --> 00:18:23,679
for example

453
00:18:23,679 --> 00:18:25,919
heightener at all and mahmoody at all

454
00:18:25,919 --> 00:18:28,080
showed an example that satisfies the

455
00:18:28,080 --> 00:18:29,679
first two conditions

456
00:18:29,679 --> 00:18:30,559
while

457
00:18:30,559 --> 00:18:32,799
apple bomb it all gave an example where

458
00:18:32,799 --> 00:18:36,639
the last two conditions are satisfied

459
00:18:37,120 --> 00:18:40,240
moving on to our positive result now

460
00:18:40,240 --> 00:18:42,400
as mentioned earlier we show that there

461
00:18:42,400 --> 00:18:44,720
exists an elementary reduction with

462
00:18:44,720 --> 00:18:47,039
identifiable abort against a dishonest

463
00:18:47,039 --> 00:18:49,760
majority of parties for all efficiently

464
00:18:49,760 --> 00:18:51,679
computable functions

465
00:18:51,679 --> 00:18:53,840
to construct such a reduction we first

466
00:18:53,840 --> 00:18:55,840
define a notion of distributed

467
00:18:55,840 --> 00:18:58,480
encryption with identifiable award and

468
00:18:58,480 --> 00:19:00,400
propose a construction

469
00:19:00,400 --> 00:19:03,280
of such a scheme we then show that this

470
00:19:03,280 --> 00:19:05,760
distributed encryption when combined

471
00:19:05,760 --> 00:19:07,919
with the standard goblin protocol

472
00:19:07,919 --> 00:19:11,840
achieves security with the bot

473
00:19:12,640 --> 00:19:14,880
distributed encryption is a primitive

474
00:19:14,880 --> 00:19:16,960
involving multiple parties

475
00:19:16,960 --> 00:19:19,039
each party locally runs the key

476
00:19:19,039 --> 00:19:21,679
generation algorithm to generate its

477
00:19:21,679 --> 00:19:24,559
encryption and decryption keys all the

478
00:19:24,559 --> 00:19:26,799
encryption keys are used for encrypting

479
00:19:26,799 --> 00:19:29,440
a message and all the decryption keys

480
00:19:29,440 --> 00:19:31,520
are used for decrypting the ciphertext

481
00:19:31,520 --> 00:19:33,520
that was encrypted using the encryption

482
00:19:33,520 --> 00:19:34,559
case

483
00:19:34,559 --> 00:19:36,960
the decryption algorithm either outputs

484
00:19:36,960 --> 00:19:39,600
the correctly decrypted message or it

485
00:19:39,600 --> 00:19:41,760
output spot along with a subset of

486
00:19:41,760 --> 00:19:43,840
corrupt parties who were responsible for

487
00:19:43,840 --> 00:19:46,640
the decryption failure

488
00:19:46,640 --> 00:19:48,080
although this is a symmetric key

489
00:19:48,080 --> 00:19:50,640
primitive we distinguish between two

490
00:19:50,640 --> 00:19:52,720
types of keys the encryption keys and

491
00:19:52,720 --> 00:19:54,240
the decryption keys

492
00:19:54,240 --> 00:19:56,160
this will allow us to define the

493
00:19:56,160 --> 00:19:58,559
encryption algorithm in a way that is

494
00:19:58,559 --> 00:20:02,080
independent of the underlying prg

495
00:20:02,080 --> 00:20:04,400
also as discussed earlier for gobbling

496
00:20:04,400 --> 00:20:06,480
circuits with more than poly logarithmic

497
00:20:06,480 --> 00:20:09,360
depth we require decryption keys whose

498
00:20:09,360 --> 00:20:11,360
bit length is shorter than the message

499
00:20:11,360 --> 00:20:13,440
length

500
00:20:13,440 --> 00:20:16,000
we need one time security as long as at

501
00:20:16,000 --> 00:20:18,640
least one of the key pairs is honestly

502
00:20:18,640 --> 00:20:21,640
generated

503
00:20:24,320 --> 00:20:26,320
in addition to privacy we require

504
00:20:26,320 --> 00:20:28,720
different flavors of correctness which

505
00:20:28,720 --> 00:20:31,360
hold even against active adversaries

506
00:20:31,360 --> 00:20:33,440
that corrupt some of the case

507
00:20:33,440 --> 00:20:35,440
the first one is security weatherbot

508
00:20:35,440 --> 00:20:37,600
where the decryption algorithm either

509
00:20:37,600 --> 00:20:40,080
outputs the correctly decrypted message

510
00:20:40,080 --> 00:20:42,000
or it outputs a bot

511
00:20:42,000 --> 00:20:44,159
in this case we want that just by

512
00:20:44,159 --> 00:20:46,320
looking at the keepers we should be able

513
00:20:46,320 --> 00:20:48,159
to predict whether the outcome of the

514
00:20:48,159 --> 00:20:50,080
decryption algorithm will be a valid

515
00:20:50,080 --> 00:20:53,200
message or part

516
00:20:53,200 --> 00:20:55,440
similarly for security with identifiable

517
00:20:55,440 --> 00:20:58,000
abort we want that given only the key

518
00:20:58,000 --> 00:21:00,000
pairs we should be able to predict

519
00:21:00,000 --> 00:21:01,840
whether the outcome of the decryption

520
00:21:01,840 --> 00:21:04,320
algorithm will be a valid message

521
00:21:04,320 --> 00:21:07,280
or or if it will be bought along with

522
00:21:07,280 --> 00:21:10,159
the correctly identified subset of bad

523
00:21:10,159 --> 00:21:12,240
parties

524
00:21:12,240 --> 00:21:14,240
for constructing distributed encryption

525
00:21:14,240 --> 00:21:16,240
with these properties we first design a

526
00:21:16,240 --> 00:21:18,080
scheme that achieves security with the

527
00:21:18,080 --> 00:21:21,039
bot and then show how we can use cut and

528
00:21:21,039 --> 00:21:23,120
choose to amplify its security to

529
00:21:23,120 --> 00:21:26,158
identifiable abort

530
00:21:26,640 --> 00:21:28,799
our distributed encryption with abort

531
00:21:28,799 --> 00:21:32,080
uses standard mac then encrypt idea

532
00:21:32,080 --> 00:21:34,320
in particular the parties sample random

533
00:21:34,320 --> 00:21:36,880
decryption keys and encryption keys are

534
00:21:36,880 --> 00:21:40,320
prg evaluations of these decryption keys

535
00:21:40,320 --> 00:21:42,559
the encryption algorithm samples a

536
00:21:42,559 --> 00:21:45,200
random mac key and then implements the

537
00:21:45,200 --> 00:21:48,799
standard mac then encrypt up idea

538
00:21:48,799 --> 00:21:50,960
while the decryption algorithm evaluates

539
00:21:50,960 --> 00:21:54,960
the prg on all the decryption keys

540
00:21:54,960 --> 00:21:56,960
in order to obtain the corresponding

541
00:21:56,960 --> 00:21:59,039
encryption keys and then uses them to

542
00:21:59,039 --> 00:22:01,280
decrypt the message and the tag

543
00:22:01,280 --> 00:22:03,679
it then checks if the tag is a valid mac

544
00:22:03,679 --> 00:22:05,760
on the message using the mac key that

545
00:22:05,760 --> 00:22:08,799
was output by the encryption algorithm

546
00:22:08,799 --> 00:22:10,240
for predicting the outcome of the

547
00:22:10,240 --> 00:22:12,240
decryption algorithm we can simply

548
00:22:12,240 --> 00:22:14,400
compute an xor of all the encryption

549
00:22:14,400 --> 00:22:15,280
keys

550
00:22:15,280 --> 00:22:17,760
and of the prg evaluations of all the

551
00:22:17,760 --> 00:22:19,200
decryption keys

552
00:22:19,200 --> 00:22:21,280
if the result is a non-zero string then

553
00:22:21,280 --> 00:22:23,200
the output of the decryption algorithm

554
00:22:23,200 --> 00:22:25,200
will be bought otherwise it will be a

555
00:22:25,200 --> 00:22:27,840
valid message

556
00:22:27,840 --> 00:22:29,440
for upgrading to security with

557
00:22:29,440 --> 00:22:32,000
identifiable abort the key generation

558
00:22:32,000 --> 00:22:34,559
algorithm samples multiple key pairs of

559
00:22:34,559 --> 00:22:36,720
the distributed encryption scheme that

560
00:22:36,720 --> 00:22:39,039
achieves security for the bot

561
00:22:39,039 --> 00:22:41,440
during encryption we sample a subset of

562
00:22:41,440 --> 00:22:44,559
the keys and use it for validation by

563
00:22:44,559 --> 00:22:46,720
outputting the encryption keys and using

564
00:22:46,720 --> 00:22:49,440
the remaining keys in a redundant way by

565
00:22:49,440 --> 00:22:51,280
re-encrypting multiple copies of the

566
00:22:51,280 --> 00:22:53,760
message under these keys

567
00:22:53,760 --> 00:22:55,919
the decryption algorithm checks if the

568
00:22:55,919 --> 00:22:57,440
revealed keys

569
00:22:57,440 --> 00:22:59,600
are consistent with the corresponding

570
00:22:59,600 --> 00:23:01,200
decryption case

571
00:23:01,200 --> 00:23:03,919
and identifies any bad keepers it

572
00:23:03,919 --> 00:23:05,919
decrypts the ciphertext using the

573
00:23:05,919 --> 00:23:07,679
remaining keys

574
00:23:07,679 --> 00:23:09,840
for predicting the outcome of decryption

575
00:23:09,840 --> 00:23:12,240
we can simply sample a random subset of

576
00:23:12,240 --> 00:23:14,559
the encryption keys and check whether

577
00:23:14,559 --> 00:23:15,840
they are consistent with the

578
00:23:15,840 --> 00:23:18,080
corresponding decryption keys and

579
00:23:18,080 --> 00:23:22,159
identify any bad keepers

580
00:23:22,159 --> 00:23:24,159
finally we show that when such a

581
00:23:24,159 --> 00:23:26,720
distributed encryption scheme is used

582
00:23:26,720 --> 00:23:28,400
along with the standard gobbling

583
00:23:28,400 --> 00:23:31,039
approach the resulting protocol achieves

584
00:23:31,039 --> 00:23:34,240
security with a bird

585
00:23:34,320 --> 00:23:36,320
unfortunately due to time constraints i

586
00:23:36,320 --> 00:23:37,840
won't be able to get

587
00:23:37,840 --> 00:23:40,320
into the details

588
00:23:40,320 --> 00:23:43,360
of this construction

589
00:23:43,919 --> 00:23:46,720
but to conclude we show that elementary

590
00:23:46,720 --> 00:23:49,120
reductions for efficiently computable

591
00:23:49,120 --> 00:23:51,200
functions that achieve full security

592
00:23:51,200 --> 00:23:53,840
against a dishonest majority of parties

593
00:23:53,840 --> 00:23:56,080
is unlikely to exist

594
00:23:56,080 --> 00:23:59,039
while elementary reductions

595
00:23:59,039 --> 00:24:01,360
that achieve identifiable abort against

596
00:24:01,360 --> 00:24:04,080
a dishonest majority of parties does

597
00:24:04,080 --> 00:24:06,000
exist

598
00:24:06,000 --> 00:24:09,240
thank you

