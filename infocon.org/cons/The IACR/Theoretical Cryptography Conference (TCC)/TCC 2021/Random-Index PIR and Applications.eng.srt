1
00:00:01,280 --> 00:00:03,520
i am shaya levi and i will talk about

2
00:00:03,520 --> 00:00:05,359
random index private information

3
00:00:05,359 --> 00:00:07,520
retrieval and application this is joint

4
00:00:07,520 --> 00:00:10,639
work with craig gentry bernardo margheri

5
00:00:10,639 --> 00:00:13,759
jesper milson and sophia yakubov

6
00:00:13,759 --> 00:00:15,759
let's jump right in remind us of what

7
00:00:15,759 --> 00:00:18,880
private information retrieval is here

8
00:00:18,880 --> 00:00:20,720
here we have a client that wants to

9
00:00:20,720 --> 00:00:23,199
fetch an entry from some public database

10
00:00:23,199 --> 00:00:24,720
but the server that's holding the

11
00:00:24,720 --> 00:00:27,279
database shouldn't learn what entry the

12
00:00:27,279 --> 00:00:29,439
client is interested in

13
00:00:29,439 --> 00:00:32,640
so of course one way to do that is for

14
00:00:32,640 --> 00:00:34,320
the client to just download the entire

15
00:00:34,320 --> 00:00:37,360
database and the whole point of peer is

16
00:00:37,360 --> 00:00:40,000
to do better than this trivial solution

17
00:00:40,000 --> 00:00:43,120
meaning to have the server send less

18
00:00:43,120 --> 00:00:45,920
to the client than the entire database

19
00:00:45,920 --> 00:00:48,480
this was introduced by a show called

20
00:00:48,480 --> 00:00:50,480
kushilevits in sudan

21
00:00:50,480 --> 00:00:52,000
in the 90s

22
00:00:52,000 --> 00:00:53,680
and the first solutions that they gave

23
00:00:53,680 --> 00:00:56,879
relied on multiple non-colluding servers

24
00:00:56,879 --> 00:00:59,680
but later on uh kush levitz and ostovsky

25
00:00:59,680 --> 00:01:01,359
show that you can do that also when

26
00:01:01,359 --> 00:01:03,199
there's a single server

27
00:01:03,199 --> 00:01:05,438
and there's been a very large body of

28
00:01:05,438 --> 00:01:07,600
research on pill and it's useful for

29
00:01:07,600 --> 00:01:10,000
many different things

30
00:01:10,000 --> 00:01:12,159
in this work we look at a peer with a

31
00:01:12,159 --> 00:01:14,799
twist and that twist is the client is

32
00:01:14,799 --> 00:01:16,960
not interested in any one particular

33
00:01:16,960 --> 00:01:18,799
index you just want to get

34
00:01:18,799 --> 00:01:20,720
one index a random index from the

35
00:01:20,720 --> 00:01:23,280
database and the point is without the

36
00:01:23,280 --> 00:01:26,479
server knowing which one it got so you

37
00:01:26,479 --> 00:01:28,159
should think of a lottery for example

38
00:01:28,159 --> 00:01:30,000
where people sign up with the server and

39
00:01:30,000 --> 00:01:31,600
give their personal details then the

40
00:01:31,600 --> 00:01:34,320
client chooses a random person

41
00:01:34,320 --> 00:01:36,720
to get the jackpot but the server should

42
00:01:36,720 --> 00:01:39,280
know who was chosen before you announce

43
00:01:39,280 --> 00:01:42,079
the winner because then the server can

44
00:01:42,079 --> 00:01:45,360
i don't know uh extort them or do some

45
00:01:45,360 --> 00:01:46,880
other nasty thing

46
00:01:46,880 --> 00:01:49,280
we call this a primitive a random index

47
00:01:49,280 --> 00:01:52,880
spear or an rpr for short

48
00:01:52,880 --> 00:01:54,720
why looking at it

49
00:01:54,720 --> 00:01:56,479
so one thing that should be obvious is

50
00:01:56,479 --> 00:01:58,799
that rp is a weaker primitive than peer

51
00:01:58,799 --> 00:02:00,560
because um

52
00:02:00,560 --> 00:02:02,960
if you could uh

53
00:02:02,960 --> 00:02:03,680
do

54
00:02:03,680 --> 00:02:06,079
peer then you can definitely

55
00:02:06,079 --> 00:02:08,399
do i'll appeal just by the client

56
00:02:08,399 --> 00:02:10,318
choosing a random index and then you run

57
00:02:10,318 --> 00:02:12,239
your peer protocol

58
00:02:12,239 --> 00:02:13,520
and

59
00:02:13,520 --> 00:02:16,160
we can hope therefore that rpg is easier

60
00:02:16,160 --> 00:02:18,800
to build than uh pier for example maybe

61
00:02:18,800 --> 00:02:21,040
you can make it more efficient maybe you

62
00:02:21,040 --> 00:02:23,680
can use weaker assumptions maybe you can

63
00:02:23,680 --> 00:02:25,360
run it in more settings or appear as

64
00:02:25,360 --> 00:02:27,760
impossible et cetera so that's on one

65
00:02:27,760 --> 00:02:29,680
hand on the other hand rpg is sufficient

66
00:02:29,680 --> 00:02:31,920
for some applications so i already gave

67
00:02:31,920 --> 00:02:33,440
you the example of the lottery from

68
00:02:33,440 --> 00:02:34,480
before

69
00:02:34,480 --> 00:02:36,239
the thing that motivated us to look at

70
00:02:36,239 --> 00:02:38,319
that is an application to the secrets

71
00:02:38,319 --> 00:02:40,800
and block on the blockchain architecture

72
00:02:40,800 --> 00:02:42,560
of manhattan

73
00:02:42,560 --> 00:02:45,040
from tccf last year

74
00:02:45,040 --> 00:02:47,599
and i will spend the end of this talk

75
00:02:47,599 --> 00:02:49,440
talking about that application

76
00:02:49,440 --> 00:02:51,440
and also during this course of this work

77
00:02:51,440 --> 00:02:54,080
we find a nice little uh application of

78
00:02:54,080 --> 00:02:55,920
it to appear with pre-processing and

79
00:02:55,920 --> 00:02:57,599
i'll spend one slide talking about that

80
00:02:57,599 --> 00:03:00,480
as well later on

81
00:03:01,360 --> 00:03:03,920
this walk has two mostly orthogonal

82
00:03:03,920 --> 00:03:05,519
threads of work one of them is just

83
00:03:05,519 --> 00:03:07,920
looking at alpine as a primitive so

84
00:03:07,920 --> 00:03:10,159
defining it looking at the variations

85
00:03:10,159 --> 00:03:12,319
how it relates to peers how to construct

86
00:03:12,319 --> 00:03:14,800
it and then the application that i

87
00:03:14,800 --> 00:03:16,840
talked about to appear with

88
00:03:16,840 --> 00:03:19,440
pre-processing and the second line of

89
00:03:19,440 --> 00:03:21,680
work is the application to the secrets

90
00:03:21,680 --> 00:03:23,200
of blockchain that was our motivation

91
00:03:23,200 --> 00:03:25,519
for this work with some optimization

92
00:03:25,519 --> 00:03:27,120
specific in the context of that

93
00:03:27,120 --> 00:03:28,879
application

94
00:03:28,879 --> 00:03:32,560
so let's start from the rp as

95
00:03:32,560 --> 00:03:34,879
and we'll begin with trying to define it

96
00:03:34,879 --> 00:03:37,120
now in this work we only looked at the

97
00:03:37,120 --> 00:03:39,440
semi honest case so the server is honest

98
00:03:39,440 --> 00:03:41,680
but wants to learn the the index of the

99
00:03:41,680 --> 00:03:44,080
uh client

100
00:03:44,080 --> 00:03:46,720
and this particular definition is for

101
00:03:46,720 --> 00:03:49,760
the single server

102
00:03:49,760 --> 00:03:52,000
protocol so it's a two-party protocol

103
00:03:52,000 --> 00:03:53,760
there's a client with

104
00:03:53,760 --> 00:03:54,959
no uh

105
00:03:54,959 --> 00:03:57,280
input and there's a server that has the

106
00:03:57,280 --> 00:03:59,040
database which is more than just as an

107
00:03:59,040 --> 00:04:01,360
ambit string the server will have no

108
00:04:01,360 --> 00:04:04,319
output the client output is an index and

109
00:04:04,319 --> 00:04:07,120
the corresponding database bit

110
00:04:07,120 --> 00:04:08,959
if both of them are honest then the

111
00:04:08,959 --> 00:04:11,280
index that the client gets is uniform or

112
00:04:11,280 --> 00:04:13,120
close to it

113
00:04:13,120 --> 00:04:14,720
in terms of what we need well we need

114
00:04:14,720 --> 00:04:17,120
correctness that is the bit that the

115
00:04:17,120 --> 00:04:19,519
client learns is indeed the bit of the

116
00:04:19,519 --> 00:04:21,839
database we need non-triviality which

117
00:04:21,839 --> 00:04:23,520
means that the server sends less than n

118
00:04:23,520 --> 00:04:26,400
bits and we need privacy for the client

119
00:04:26,400 --> 00:04:28,720
which means that uh even with the

120
00:04:28,720 --> 00:04:32,000
server's view the index that the client

121
00:04:32,000 --> 00:04:34,960
got is indistinguishable from another

122
00:04:34,960 --> 00:04:37,040
index that was chosen uniformly at

123
00:04:37,040 --> 00:04:42,040
random in irrespective of the protocol

124
00:04:42,080 --> 00:04:43,680
some variations that

125
00:04:43,680 --> 00:04:45,360
would be used for one of them is just

126
00:04:45,360 --> 00:04:47,440
batch instead of a single index you want

127
00:04:47,440 --> 00:04:49,680
multiple one the definition is identical

128
00:04:49,680 --> 00:04:51,520
except instead of a single index there

129
00:04:51,520 --> 00:04:53,440
is a vector of indexes that the client

130
00:04:53,440 --> 00:04:55,280
gets

131
00:04:55,280 --> 00:04:56,720
and then

132
00:04:56,720 --> 00:04:58,960
in the context of batch rp you can even

133
00:04:58,960 --> 00:05:01,039
look at weaker security

134
00:05:01,039 --> 00:05:04,479
so instead of the indexes the vector of

135
00:05:04,479 --> 00:05:06,440
indexes that the client gets being

136
00:05:06,440 --> 00:05:08,840
indistinguishable from uniform it's

137
00:05:08,840 --> 00:05:10,639
indistinguishable from some other

138
00:05:10,639 --> 00:05:12,880
distribution d which is random enough

139
00:05:12,880 --> 00:05:15,440
what random enough is might depend on

140
00:05:15,440 --> 00:05:17,199
your application

141
00:05:17,199 --> 00:05:18,720
but a

142
00:05:18,720 --> 00:05:20,880
reasonable general purpose definition of

143
00:05:20,880 --> 00:05:23,120
what it means to be random enough is

144
00:05:23,120 --> 00:05:26,479
that for every subset of vectors of n to

145
00:05:26,479 --> 00:05:27,360
the k

146
00:05:27,360 --> 00:05:29,120
if that subset has a negligible

147
00:05:29,120 --> 00:05:30,479
probability mass according to the

148
00:05:30,479 --> 00:05:32,800
uniform distribution then it also has a

149
00:05:32,800 --> 00:05:34,639
negligible probability means according

150
00:05:34,639 --> 00:05:37,680
to the distribution d that we want here

151
00:05:37,680 --> 00:05:41,039
and that definition says that any bad

152
00:05:41,039 --> 00:05:42,800
event that happens with negligible

153
00:05:42,800 --> 00:05:45,680
probability uh in the strong sense if

154
00:05:45,680 --> 00:05:48,240
you had random indexes will also happen

155
00:05:48,240 --> 00:05:50,400
with negligible probability in this

156
00:05:50,400 --> 00:05:52,639
protocol so that's a useful definition

157
00:05:52,639 --> 00:05:54,960
to have

158
00:05:55,680 --> 00:05:58,639
as i said here we only treat honest but

159
00:05:58,639 --> 00:06:01,039
curious it actually is an open problem

160
00:06:01,039 --> 00:06:03,919
even to just define what rpr means in

161
00:06:03,919 --> 00:06:06,160
the malicious setting it's not trivial

162
00:06:06,160 --> 00:06:09,440
and we did not try to do it

163
00:06:09,520 --> 00:06:10,960
the first result that i want to tell you

164
00:06:10,960 --> 00:06:13,759
about is a theorem that says that rp as

165
00:06:13,759 --> 00:06:15,919
a primitive is equivalent to peel up to

166
00:06:15,919 --> 00:06:18,160
a small increase in the communication

167
00:06:18,160 --> 00:06:19,680
and around

168
00:06:19,680 --> 00:06:21,840
on one hand that means that you cannot

169
00:06:21,840 --> 00:06:23,840
hope for too much in terms of alpha

170
00:06:23,840 --> 00:06:27,039
being easier to build than pier because

171
00:06:27,039 --> 00:06:29,199
they're equivalent but we will still

172
00:06:29,199 --> 00:06:31,120
show that there are gains that can be

173
00:06:31,120 --> 00:06:32,560
made and it's still interesting enough

174
00:06:32,560 --> 00:06:35,280
to look at but let's for now prove that

175
00:06:35,280 --> 00:06:37,199
alpine as a primitive is equivalent to

176
00:06:37,199 --> 00:06:39,680
pl one direction is true one direction

177
00:06:39,680 --> 00:06:41,759
we already show if you had peer you can

178
00:06:41,759 --> 00:06:44,240
definitely implement output trivially so

179
00:06:44,240 --> 00:06:46,080
let's try the other direction

180
00:06:46,080 --> 00:06:47,280
let's say that you have an

181
00:06:47,280 --> 00:06:49,680
implementation of a non-trivial up here

182
00:06:49,680 --> 00:06:51,520
and let's try to build out of it and

183
00:06:51,520 --> 00:06:53,440
implementation of pr

184
00:06:53,440 --> 00:06:55,199
so i'm going to start with a very simple

185
00:06:55,199 --> 00:06:57,120
appeal protocol it's a full-blown peer

186
00:06:57,120 --> 00:06:59,520
so the client has a particular index i

187
00:06:59,520 --> 00:07:01,120
that it wants to get the server has a

188
00:07:01,120 --> 00:07:02,880
database and what they do is the

189
00:07:02,880 --> 00:07:03,919
following

190
00:07:03,919 --> 00:07:06,400
first they will run an rpa protocol

191
00:07:06,400 --> 00:07:08,240
where the client will get from the

192
00:07:08,240 --> 00:07:11,120
server just a random index j not

193
00:07:11,120 --> 00:07:12,880
necessarily the index that it wants to

194
00:07:12,880 --> 00:07:14,080
get

195
00:07:14,080 --> 00:07:16,240
then the client sends to the server

196
00:07:16,240 --> 00:07:18,800
delta which is an exclusive of the index

197
00:07:18,800 --> 00:07:21,199
that it wants and the index that it got

198
00:07:21,199 --> 00:07:23,759
you think of all these two are log n bit

199
00:07:23,759 --> 00:07:26,960
strings and you just send in the

200
00:07:26,960 --> 00:07:29,280
axle of the two

201
00:07:29,280 --> 00:07:30,960
the server will partition the set of

202
00:07:30,960 --> 00:07:34,800
indexes n into n over two pairs k and k

203
00:07:34,800 --> 00:07:37,840
x or delta and notice that one of these

204
00:07:37,840 --> 00:07:40,319
pairs will be i comma j

205
00:07:40,319 --> 00:07:42,720
and then for every pair it computes the

206
00:07:42,720 --> 00:07:45,919
xor of the two database bits

207
00:07:45,919 --> 00:07:48,240
in these two indexes and it sends these

208
00:07:48,240 --> 00:07:50,879
two and over these n over two bits to

209
00:07:50,879 --> 00:07:53,280
the client now the client already know

210
00:07:53,280 --> 00:07:55,520
database at point j and now it knows the

211
00:07:55,520 --> 00:07:58,000
exclusive all of it with the database at

212
00:07:58,000 --> 00:07:59,680
point i so now it can compute the

213
00:07:59,680 --> 00:08:04,000
database bit at position i

214
00:08:04,960 --> 00:08:08,240
now if the rp takes rounds and has

215
00:08:08,240 --> 00:08:10,560
certain communication c sub c for the

216
00:08:10,560 --> 00:08:14,000
client and c sub s for the server

217
00:08:14,000 --> 00:08:16,080
then the simple protocol that i just

218
00:08:16,080 --> 00:08:18,240
described take out last two rounds

219
00:08:18,240 --> 00:08:20,319
because you first run rp and then two

220
00:08:20,319 --> 00:08:21,360
more rounds

221
00:08:21,360 --> 00:08:23,440
and the communication those additional

222
00:08:23,440 --> 00:08:25,680
log n bits that the client sends and n

223
00:08:25,680 --> 00:08:27,919
over two bits that the server sends n

224
00:08:27,919 --> 00:08:29,599
over two being less than n this is a

225
00:08:29,599 --> 00:08:31,360
non-trivial protocol

226
00:08:31,360 --> 00:08:33,279
but it's not great and over two is still

227
00:08:33,279 --> 00:08:34,320
a lot

228
00:08:34,320 --> 00:08:36,159
so we wanna do better

229
00:08:36,159 --> 00:08:38,719
and can we do better so it turns out yes

230
00:08:38,719 --> 00:08:40,958
and the observation here is look at the

231
00:08:40,958 --> 00:08:43,519
last two steps in this protocol the last

232
00:08:43,519 --> 00:08:45,600
two steps is just a trivial peer

233
00:08:45,600 --> 00:08:47,519
protocol for a database of size n over

234
00:08:47,519 --> 00:08:49,600
two right the server sends the n over

235
00:08:49,600 --> 00:08:51,839
two bits the client lookup one of them

236
00:08:51,839 --> 00:08:54,640
so instead of that how about we replace

237
00:08:54,640 --> 00:08:56,720
this right this trivial peer with a

238
00:08:56,720 --> 00:08:58,720
recursive call for the same protocol

239
00:08:58,720 --> 00:09:01,680
itself so that gives us a cursive appeal

240
00:09:01,680 --> 00:09:03,200
um

241
00:09:03,200 --> 00:09:05,360
every level what happens is one appeal

242
00:09:05,360 --> 00:09:07,440
protocol on a database of size n over

243
00:09:07,440 --> 00:09:10,320
two to the i then the client sends log n

244
00:09:10,320 --> 00:09:12,800
minus i beats which is the delta at that

245
00:09:12,800 --> 00:09:14,800
level and then you make the recursive

246
00:09:14,800 --> 00:09:17,040
call all the way down until you get to a

247
00:09:17,040 --> 00:09:18,959
database of size one and then the server

248
00:09:18,959 --> 00:09:23,120
just sends that one bit to the client

249
00:09:23,120 --> 00:09:26,480
so if the rpl protocol takes rounds and

250
00:09:26,480 --> 00:09:29,200
has communication c sub c and c sub s

251
00:09:29,200 --> 00:09:31,519
then the recursive uh protocol here

252
00:09:31,519 --> 00:09:34,800
takes at most the r plus one times log n

253
00:09:34,800 --> 00:09:36,800
rounds of communication and the

254
00:09:36,800 --> 00:09:39,120
communication is at most login times the

255
00:09:39,120 --> 00:09:41,839
outfield protocol plus this

256
00:09:41,839 --> 00:09:44,160
the client sends

257
00:09:44,160 --> 00:09:47,360
log and choose two bits and the server

258
00:09:47,360 --> 00:09:50,640
sends one more bit

259
00:09:50,640 --> 00:09:52,320
so that's nice

260
00:09:52,320 --> 00:09:53,279
uh

261
00:09:53,279 --> 00:09:54,959
but there is still a question of the

262
00:09:54,959 --> 00:09:57,360
number of rounds i mean we multiply the

263
00:09:57,360 --> 00:09:59,440
number of rounds by log n which is not

264
00:09:59,440 --> 00:10:01,920
great can we do something better than

265
00:10:01,920 --> 00:10:05,040
that can we have a a protocol that has

266
00:10:05,040 --> 00:10:07,279
fewer alarms and it turns out that in

267
00:10:07,279 --> 00:10:09,120
some sense we can

268
00:10:09,120 --> 00:10:10,880
uh and that's

269
00:10:10,880 --> 00:10:12,880
just a generalization of the simple peel

270
00:10:12,880 --> 00:10:14,000
protocol

271
00:10:14,000 --> 00:10:18,079
but instead of just a single rpl run uh

272
00:10:18,079 --> 00:10:20,560
the client and server will now run t

273
00:10:20,560 --> 00:10:22,640
minus one of them so the client will get

274
00:10:22,640 --> 00:10:24,720
t minus one indexes

275
00:10:24,720 --> 00:10:26,320
random indexes that the server doesn't

276
00:10:26,320 --> 00:10:29,120
know then the client will partition this

277
00:10:29,120 --> 00:10:32,079
index set instead of in two pairs into t

278
00:10:32,079 --> 00:10:34,880
tuples one of these tuples includes the

279
00:10:34,880 --> 00:10:37,760
index either at once and all the j sub

280
00:10:37,760 --> 00:10:39,519
case that it got

281
00:10:39,519 --> 00:10:42,079
and all the other

282
00:10:42,079 --> 00:10:45,040
sets there are just random

283
00:10:45,040 --> 00:10:48,000
and then for every t tuple the server

284
00:10:48,000 --> 00:10:50,640
sends the xor of all these t bits in the

285
00:10:50,640 --> 00:10:52,959
database and the client again

286
00:10:52,959 --> 00:10:56,800
knows all the bits at position j sub k

287
00:10:56,800 --> 00:10:59,360
and it knows the xor of everything so

288
00:10:59,360 --> 00:11:02,240
now it can compute the beat at position

289
00:11:02,240 --> 00:11:04,480
9.

290
00:11:04,959 --> 00:11:07,279
this is outlast round two rounds the

291
00:11:07,279 --> 00:11:08,880
server communications and over two the

292
00:11:08,880 --> 00:11:11,040
client communication is long because

293
00:11:11,040 --> 00:11:13,040
sending a random partition takes many

294
00:11:13,040 --> 00:11:15,279
beats and maybe you can improve it but

295
00:11:15,279 --> 00:11:19,360
we didn't quite find a way to do that

296
00:11:19,600 --> 00:11:20,720
okay

297
00:11:20,720 --> 00:11:22,959
uh an obvious open question is to find

298
00:11:22,959 --> 00:11:25,519
better reductions so better tighter

299
00:11:25,519 --> 00:11:29,480
reductions from our people

300
00:11:30,240 --> 00:11:31,760
the next thing that i want to show you

301
00:11:31,760 --> 00:11:34,800
is that you can actually use rpl in a

302
00:11:34,800 --> 00:11:37,360
setting where peer is not applicable and

303
00:11:37,360 --> 00:11:38,959
that setting is a non-interactive

304
00:11:38,959 --> 00:11:41,839
setting you may have an initial setup

305
00:11:41,839 --> 00:11:45,120
phase that irrespective of both database

306
00:11:45,120 --> 00:11:47,360
and

307
00:11:48,800 --> 00:11:50,560
index of the client

308
00:11:50,560 --> 00:11:53,440
and after that every time the

309
00:11:53,440 --> 00:11:56,639
server wants to convey a random index to

310
00:11:56,639 --> 00:11:58,880
this client it just sends to it a single

311
00:11:58,880 --> 00:12:01,120
message the client never speaks again

312
00:12:01,120 --> 00:12:02,880
clearly you cannot appear this way

313
00:12:02,880 --> 00:12:06,240
because the client has no chance of

314
00:12:06,240 --> 00:12:08,560
inputting the input index that it wants

315
00:12:08,560 --> 00:12:10,959
so you cannot do other people you kind

316
00:12:10,959 --> 00:12:12,800
of do peel this way but you can do

317
00:12:12,800 --> 00:12:14,800
arpier

318
00:12:14,800 --> 00:12:16,959
one very simple example is doing it with

319
00:12:16,959 --> 00:12:18,880
fhe right so

320
00:12:18,880 --> 00:12:20,560
you have a setup phase where the clients

321
00:12:20,560 --> 00:12:22,480
and the public key and an encryption of

322
00:12:22,480 --> 00:12:25,600
a prf seed and then in the online phase

323
00:12:25,600 --> 00:12:27,760
every time the server wants to send a

324
00:12:27,760 --> 00:12:30,480
random beat to the client it just

325
00:12:30,480 --> 00:12:35,000
chooses a nonce computed homomorphically

326
00:12:35,120 --> 00:12:38,240
i which is a prf of the noise with this

327
00:12:38,240 --> 00:12:39,839
seed and

328
00:12:39,839 --> 00:12:41,600
you get an encryption of i and then

329
00:12:41,600 --> 00:12:44,079
continue to compute homomorphically the

330
00:12:44,079 --> 00:12:46,079
database at that position and sent to

331
00:12:46,079 --> 00:12:48,800
the client so this is a very easy

332
00:12:48,800 --> 00:12:51,279
protocol in the paper we also have a

333
00:12:51,279 --> 00:12:54,000
more complicated non-interactive schemes

334
00:12:54,000 --> 00:12:56,160
which is based on uh just pseudorandom

335
00:12:56,160 --> 00:12:58,320
permutation and this is essentially the

336
00:12:58,320 --> 00:13:00,160
protocol of kosher levitz and ostrovsky

337
00:13:00,160 --> 00:13:02,720
from 2000 but adapted to be

338
00:13:02,720 --> 00:13:05,720
non-interactive

339
00:13:06,480 --> 00:13:09,279
let me also take a small detour and talk

340
00:13:09,279 --> 00:13:12,399
about the multi-server rpa case and it

341
00:13:12,399 --> 00:13:13,920
turns out that in a multi-server you

342
00:13:13,920 --> 00:13:15,839
also can do this non-interactive and in

343
00:13:15,839 --> 00:13:18,000
fact you can do slightly better in some

344
00:13:18,000 --> 00:13:20,160
sense because we have two construction

345
00:13:20,160 --> 00:13:22,079
one construction is an information

346
00:13:22,079 --> 00:13:24,079
theoretic construction

347
00:13:24,079 --> 00:13:24,880
where

348
00:13:24,880 --> 00:13:27,440
it doesn't even have a setup phase

349
00:13:27,440 --> 00:13:30,560
when just two servers both of them have

350
00:13:30,560 --> 00:13:33,040
uh the database and every time they want

351
00:13:33,040 --> 00:13:35,120
the client to get a random index then

352
00:13:35,120 --> 00:13:37,279
each of them send the message to the

353
00:13:37,279 --> 00:13:39,440
client the client gets a random index

354
00:13:39,440 --> 00:13:43,440
and they both send less than and beats

355
00:13:43,440 --> 00:13:44,320
so

356
00:13:44,320 --> 00:13:45,760
that's nice

357
00:13:45,760 --> 00:13:47,519
the thing that's not so nice about it is

358
00:13:47,519 --> 00:13:49,360
one of them has to send half the bits of

359
00:13:49,360 --> 00:13:50,880
the database and we actually don't know

360
00:13:50,880 --> 00:13:53,199
how to do better than that

361
00:13:53,199 --> 00:13:55,120
then we have another approach sort of

362
00:13:55,120 --> 00:13:56,240
generic

363
00:13:56,240 --> 00:13:58,560
for converting m server peer to an m

364
00:13:58,560 --> 00:14:01,600
server non-interactive output using uh

365
00:14:01,600 --> 00:14:03,920
pseudonym functions

366
00:14:03,920 --> 00:14:05,839
uh put generic in quotations because

367
00:14:05,839 --> 00:14:07,360
really we only have one example where

368
00:14:07,360 --> 00:14:08,800
this transform and we know how to make

369
00:14:08,800 --> 00:14:10,240
this transformation work but it's

370
00:14:10,240 --> 00:14:13,279
plausible that there are others

371
00:14:13,279 --> 00:14:14,560
so let's start with the information

372
00:14:14,560 --> 00:14:16,240
theoretical construction this is very

373
00:14:16,240 --> 00:14:18,959
similar to the simple peer reduction

374
00:14:18,959 --> 00:14:20,720
that i described before

375
00:14:20,720 --> 00:14:23,199
server one will choose just a random

376
00:14:23,199 --> 00:14:24,240
index

377
00:14:24,240 --> 00:14:26,720
j and send j and the database at

378
00:14:26,720 --> 00:14:28,639
position j to the client

379
00:14:28,639 --> 00:14:32,240
server 2 will choose at random delta in

380
00:14:32,240 --> 00:14:34,720
0 1 to the log n

381
00:14:34,720 --> 00:14:37,120
and we'll partition n

382
00:14:37,120 --> 00:14:40,639
into n over 2 pairs k and k x or delta

383
00:14:40,639 --> 00:14:42,720
so again in a particular one of these

384
00:14:42,720 --> 00:14:48,399
pair is j x or j comma j x or delta

385
00:14:48,399 --> 00:14:50,399
and then it computes for each pair the

386
00:14:50,399 --> 00:14:53,440
exclusive o of the two database bits it

387
00:14:53,440 --> 00:14:55,680
sends delta and the n over two bits to

388
00:14:55,680 --> 00:14:59,519
the client and the client recover i as j

389
00:14:59,519 --> 00:15:02,399
xo delta and recover the database at

390
00:15:02,399 --> 00:15:03,600
position i

391
00:15:03,600 --> 00:15:05,680
as the bit that it knows

392
00:15:05,680 --> 00:15:06,959
xor

393
00:15:06,959 --> 00:15:10,399
sigma for the pair ij

394
00:15:10,399 --> 00:15:13,279
and just uh i didn't say it before but

395
00:15:13,279 --> 00:15:15,360
uh you need to handle the case of delta

396
00:15:15,360 --> 00:15:17,600
equals zero then in that case servers to

397
00:15:17,600 --> 00:15:20,160
just send delta there's no point in

398
00:15:20,160 --> 00:15:22,000
partitioning anything there and the

399
00:15:22,000 --> 00:15:24,560
client just output the database position

400
00:15:24,560 --> 00:15:26,880
beta position j and you can check that

401
00:15:26,880 --> 00:15:28,560
the probability distribution is the one

402
00:15:28,560 --> 00:15:30,880
it should be

403
00:15:30,880 --> 00:15:32,079
um

404
00:15:32,079 --> 00:15:34,240
it would be really nice to be able to

405
00:15:34,240 --> 00:15:36,320
extend it in some way and get a

406
00:15:36,320 --> 00:15:38,160
construction where the server can send

407
00:15:38,160 --> 00:15:40,320
less than and over two bits we were not

408
00:15:40,320 --> 00:15:42,320
able to find one you cannot do the

409
00:15:42,320 --> 00:15:44,160
recursive things because it interactive

410
00:15:44,160 --> 00:15:46,160
you cannot do the partition one because

411
00:15:46,160 --> 00:15:48,000
describing the partition take too many

412
00:15:48,000 --> 00:15:51,920
bits so it is an open problem

413
00:15:51,920 --> 00:15:53,920
moving on to the transformation let me

414
00:15:53,920 --> 00:15:56,079
try to describe how to transfer a

415
00:15:56,079 --> 00:15:57,759
multi-server private information

416
00:15:57,759 --> 00:16:00,480
retrieval into a non-interactive rpg so

417
00:16:00,480 --> 00:16:02,639
look at the typical multi-server pl

418
00:16:02,639 --> 00:16:04,720
protocol will has only two rounds of

419
00:16:04,720 --> 00:16:06,800
communication in this case

420
00:16:06,800 --> 00:16:09,759
the client will send to the servers

421
00:16:09,759 --> 00:16:12,399
queries that are individually random but

422
00:16:12,399 --> 00:16:13,600
correlated

423
00:16:13,600 --> 00:16:16,399
and the servers will each of them and

424
00:16:16,399 --> 00:16:18,399
have the database answer its own queries

425
00:16:18,399 --> 00:16:20,720
and they answer back to the client and

426
00:16:20,720 --> 00:16:22,560
the client will reconstruct the bit that

427
00:16:22,560 --> 00:16:23,680
it wants the

428
00:16:23,680 --> 00:16:26,240
random bit that it wants also the bit

429
00:16:26,240 --> 00:16:28,720
that it wants

430
00:16:29,120 --> 00:16:31,279
so the question is is there a way where

431
00:16:31,279 --> 00:16:33,360
the servers can generate the random

432
00:16:33,360 --> 00:16:35,360
correlated queries themselves without

433
00:16:35,360 --> 00:16:37,199
any interaction with the

434
00:16:37,199 --> 00:16:39,440
client and actually we can hope that the

435
00:16:39,440 --> 00:16:41,759
reason because there's a lot of walk in

436
00:16:41,759 --> 00:16:44,800
the recent years about uh

437
00:16:44,800 --> 00:16:46,720
pseudorandom

438
00:16:46,720 --> 00:16:48,399
randomness correlate correlated

439
00:16:48,399 --> 00:16:50,639
randomness generation so maybe some of

440
00:16:50,639 --> 00:16:52,399
this technology can be

441
00:16:52,399 --> 00:16:54,639
used here and indeed there is one

442
00:16:54,639 --> 00:16:56,880
example where we know where that thing

443
00:16:56,880 --> 00:16:57,920
works

444
00:16:57,920 --> 00:17:00,639
and that example you uh uses the reed

445
00:17:00,639 --> 00:17:02,880
salomon peer protocol that was from the

446
00:17:02,880 --> 00:17:04,720
original cg

447
00:17:04,720 --> 00:17:06,240
ks

448
00:17:06,240 --> 00:17:08,240
paper

449
00:17:08,240 --> 00:17:10,480
in that protocol the database is encoded

450
00:17:10,480 --> 00:17:13,119
by a multivariate polynomial

451
00:17:13,119 --> 00:17:15,599
with v variables degree d and a

452
00:17:15,599 --> 00:17:18,400
polynomial over some zq

453
00:17:18,400 --> 00:17:21,679
and the way it's encoded is that

454
00:17:21,679 --> 00:17:23,679
inside of some cube

455
00:17:23,679 --> 00:17:26,319
of size d plus 1 to the v

456
00:17:26,319 --> 00:17:28,480
every entry the evaluation of the

457
00:17:28,480 --> 00:17:30,799
polynomial at every entry contains some

458
00:17:30,799 --> 00:17:32,480
bits of the database so it's the

459
00:17:32,480 --> 00:17:34,960
evaluation at every point is an element

460
00:17:34,960 --> 00:17:36,400
of zq so it

461
00:17:36,400 --> 00:17:38,160
contains log queue

462
00:17:38,160 --> 00:17:40,559
bits from the database

463
00:17:40,559 --> 00:17:43,760
and this screen uses d plus one server

464
00:17:43,760 --> 00:17:45,600
and each server is holding the database

465
00:17:45,600 --> 00:17:48,320
and therefore knows the polynomial f sub

466
00:17:48,320 --> 00:17:50,240
db

467
00:17:50,240 --> 00:17:52,559
the client has a particular part of the

468
00:17:52,559 --> 00:17:54,000
database that it wants to recover in

469
00:17:54,000 --> 00:17:56,000
particular it wants to to get the

470
00:17:56,000 --> 00:17:59,120
evaluation of f sub db at a particular

471
00:17:59,120 --> 00:18:02,000
point a inside of that cube

472
00:18:02,000 --> 00:18:04,720
so it's going to choose a random line

473
00:18:04,720 --> 00:18:08,000
in zq to the v that passes

474
00:18:08,000 --> 00:18:10,559
via the point that it's interested in so

475
00:18:10,559 --> 00:18:11,919
l sub x

476
00:18:11,919 --> 00:18:15,120
is a plus x times b where a is the point

477
00:18:15,120 --> 00:18:17,440
that it wants b is a random point and x

478
00:18:17,440 --> 00:18:20,320
is a variable that ranges over z q it's

479
00:18:20,320 --> 00:18:21,840
a scalar

480
00:18:21,840 --> 00:18:24,799
it sends to the j server the j's point

481
00:18:24,799 --> 00:18:27,280
on the on the line l sub j

482
00:18:27,280 --> 00:18:29,840
and the server replies with uh the

483
00:18:29,840 --> 00:18:33,360
evaluation of the

484
00:18:33,360 --> 00:18:36,640
database polynomial at that point so yj

485
00:18:36,640 --> 00:18:37,840
is f

486
00:18:37,840 --> 00:18:40,559
at c sub j

487
00:18:40,559 --> 00:18:43,679
and note that uh the y's are just a

488
00:18:43,679 --> 00:18:45,919
polynomial and computed by a polynomial

489
00:18:45,919 --> 00:18:48,080
which is the um composition of the

490
00:18:48,080 --> 00:18:50,720
database polynomial and the linear line

491
00:18:50,720 --> 00:18:53,039
polynomial so the yjs are just

492
00:18:53,039 --> 00:18:56,559
evaluation of some degree d polynomial g

493
00:18:56,559 --> 00:18:58,000
on x

494
00:18:58,000 --> 00:19:02,240
and since the d plus one server then the

495
00:19:02,240 --> 00:19:04,720
client now knows d plus one evaluation

496
00:19:04,720 --> 00:19:06,720
point of this degree d polynomial so it

497
00:19:06,720 --> 00:19:08,400
can recover the entire degree d

498
00:19:08,400 --> 00:19:11,360
polynomial and then it finds

499
00:19:11,360 --> 00:19:13,679
the point that it's interested is as

500
00:19:13,679 --> 00:19:15,200
just g

501
00:19:15,200 --> 00:19:17,600
evaluated at zero so this is how the

502
00:19:17,600 --> 00:19:20,160
client recovers the point that it's

503
00:19:20,160 --> 00:19:22,720
interested in

504
00:19:22,720 --> 00:19:25,120
converting this to a non-interactive up

505
00:19:25,120 --> 00:19:26,799
here we're going to use a pseudorandom

506
00:19:26,799 --> 00:19:28,400
secret sharing techniques this is the

507
00:19:28,400 --> 00:19:30,880
techniques that date back to gilbaisha

508
00:19:30,880 --> 00:19:32,679
and then

509
00:19:32,679 --> 00:19:34,960
kramerdamgardishai later on

510
00:19:34,960 --> 00:19:36,320
i'm not going to tell you how those

511
00:19:36,320 --> 00:19:38,400
works exactly but

512
00:19:38,400 --> 00:19:42,720
the main thing is uh you in a pre

513
00:19:42,720 --> 00:19:44,720
in a pre-computation in a setup phase

514
00:19:44,720 --> 00:19:46,799
you will distribute prf seeds among the

515
00:19:46,799 --> 00:19:48,880
servers and different subsets of server

516
00:19:48,880 --> 00:19:51,120
will get different plf seeds

517
00:19:51,120 --> 00:19:52,640
and then the servals can generate

518
00:19:52,640 --> 00:19:54,720
pseudorandom degree t

519
00:19:54,720 --> 00:19:56,720
shamir sharing locally without any

520
00:19:56,720 --> 00:19:59,600
interaction every server just uses the

521
00:19:59,600 --> 00:20:01,360
prf seeds that

522
00:20:01,360 --> 00:20:04,240
they know so the first shamil sharing

523
00:20:04,240 --> 00:20:08,000
they all uh evaluate the plfc the prfs

524
00:20:08,000 --> 00:20:10,080
at one the second one they all evaluated

525
00:20:10,080 --> 00:20:11,919
the two et cetera so they can generate

526
00:20:11,919 --> 00:20:12,559
an

527
00:20:12,559 --> 00:20:15,360
unlimited number of uh pseudorandom

528
00:20:15,360 --> 00:20:18,400
seeds without talking to each other at

529
00:20:18,400 --> 00:20:20,000
all

530
00:20:20,000 --> 00:20:23,280
without talking to each other at all

531
00:20:23,440 --> 00:20:25,360
uh here we're going to use prss for

532
00:20:25,360 --> 00:20:27,520
random lines so this is degree 1

533
00:20:27,520 --> 00:20:28,960
polynomials

534
00:20:28,960 --> 00:20:31,840
and the servers just generate the

535
00:20:31,840 --> 00:20:33,440
query the thing that they would have

536
00:20:33,440 --> 00:20:35,200
received from the

537
00:20:35,200 --> 00:20:37,760
client by themselves right they just

538
00:20:37,760 --> 00:20:42,240
compute cj equals lj for a random line l

539
00:20:42,240 --> 00:20:43,840
that they generate themselves using

540
00:20:43,840 --> 00:20:45,440
their surrounding

541
00:20:45,440 --> 00:20:47,919
seeds and then the lines are therefore

542
00:20:47,919 --> 00:20:50,960
pseudorandom lines

543
00:20:50,960 --> 00:20:53,200
now there is a point here that

544
00:20:53,200 --> 00:20:54,880
the what the client needs to get

545
00:20:54,880 --> 00:20:57,520
eventually is the evaluation of f on a

546
00:20:57,520 --> 00:20:59,600
random point but a random point inside

547
00:20:59,600 --> 00:21:01,120
of the cube

548
00:21:01,120 --> 00:21:03,760
it's not guaranteed that the line which

549
00:21:03,760 --> 00:21:05,679
is just a random line will intersect

550
00:21:05,679 --> 00:21:07,600
that cube if it does then the client

551
00:21:07,600 --> 00:21:09,440
learns a random database entry it just

552
00:21:09,440 --> 00:21:11,600
chooses maybe a random if you intersect

553
00:21:11,600 --> 00:21:13,679
more than one point it shows a random

554
00:21:13,679 --> 00:21:15,679
one of them

555
00:21:15,679 --> 00:21:18,720
but uh if the line doesn't intersect the

556
00:21:18,720 --> 00:21:20,240
cube then we're stuck

557
00:21:20,240 --> 00:21:22,000
so you actually the servers actually

558
00:21:22,000 --> 00:21:25,120
need to send multiple lines so that we

559
00:21:25,120 --> 00:21:26,799
get that with high probability at least

560
00:21:26,799 --> 00:21:31,840
one of them will intersect the cube

561
00:21:31,919 --> 00:21:33,919
what kind of parameters do you get so

562
00:21:33,919 --> 00:21:35,600
you have a database of size n you need

563
00:21:35,600 --> 00:21:38,640
to find the parameters d q and v and the

564
00:21:38,640 --> 00:21:41,280
constraints are first of all you need to

565
00:21:41,280 --> 00:21:44,080
be able to encode the entire database so

566
00:21:44,080 --> 00:21:45,840
if you look at all the evaluation inside

567
00:21:45,840 --> 00:21:47,520
of the cube there are d plus one to the

568
00:21:47,520 --> 00:21:49,919
v of them each one of them can hold log

569
00:21:49,919 --> 00:21:52,320
q bits so the total number of bits that

570
00:21:52,320 --> 00:21:53,919
you can encode this way has to be at

571
00:21:53,919 --> 00:21:56,400
least n

572
00:21:56,559 --> 00:21:59,039
q has to be bigger than d plus 1 because

573
00:21:59,039 --> 00:22:00,640
you need to interpolate a degree t

574
00:22:00,640 --> 00:22:03,280
polynomial

575
00:22:03,840 --> 00:22:06,320
and the last thing is that d plus 1 to

576
00:22:06,320 --> 00:22:08,320
the power v the size of this cube has to

577
00:22:08,320 --> 00:22:10,240
be a large enough fraction of the entire

578
00:22:10,240 --> 00:22:12,559
space so that random lines will

579
00:22:12,559 --> 00:22:14,480
intersect cube with noticeable

580
00:22:14,480 --> 00:22:15,600
probability

581
00:22:15,600 --> 00:22:17,919
and in fact you can see that

582
00:22:17,919 --> 00:22:19,520
the number of

583
00:22:19,520 --> 00:22:22,159
lines that the servers need to send

584
00:22:22,159 --> 00:22:24,640
is something like q over d to the power

585
00:22:24,640 --> 00:22:26,880
v in order to get uh intersection with

586
00:22:26,880 --> 00:22:28,400
high probability

587
00:22:28,400 --> 00:22:30,960
uh and for each line we have uh

588
00:22:30,960 --> 00:22:32,799
communication

589
00:22:32,799 --> 00:22:35,760
which is essentially d points t plus one

590
00:22:35,760 --> 00:22:38,400
point or two d plus one point whatever

591
00:22:38,400 --> 00:22:40,880
so roughly d low key bits

592
00:22:40,880 --> 00:22:43,120
so the total communication of this

593
00:22:43,120 --> 00:22:46,400
protocol is d log q times q over d to

594
00:22:46,400 --> 00:22:48,240
the power v now we can set the

595
00:22:48,240 --> 00:22:51,120
parameters to get various tradeoffs so

596
00:22:51,120 --> 00:22:52,720
we will always say

597
00:22:52,720 --> 00:22:55,120
set q equals d plus 2 because it's the

598
00:22:55,120 --> 00:22:56,799
smallest possible

599
00:22:56,799 --> 00:22:58,480
now if you want the minimum amount of

600
00:22:58,480 --> 00:23:01,440
communication you'll set both d and v

601
00:23:01,440 --> 00:23:02,320
to be

602
00:23:02,320 --> 00:23:04,080
log n and then you get a polylog

603
00:23:04,080 --> 00:23:05,440
communication

604
00:23:05,440 --> 00:23:07,280
and if you add a constant number of

605
00:23:07,280 --> 00:23:10,000
servers then you get end to the epsilon

606
00:23:10,000 --> 00:23:11,919
communication the more servers the less

607
00:23:11,919 --> 00:23:15,360
communication obviously

608
00:23:18,000 --> 00:23:19,840
an obvious open problem here is find

609
00:23:19,840 --> 00:23:21,039
other instances where this

610
00:23:21,039 --> 00:23:23,600
transformation works i mean this one was

611
00:23:23,600 --> 00:23:25,919
very very simple using prsss maybe there

612
00:23:25,919 --> 00:23:28,559
are other ways to get the correlation

613
00:23:28,559 --> 00:23:32,080
that you need for peer protocols

614
00:23:32,960 --> 00:23:34,320
okay the next thing that i want to tell

615
00:23:34,320 --> 00:23:37,520
you a little bit is how to uh just one

616
00:23:37,520 --> 00:23:39,520
slide of how to apply the ideas that we

617
00:23:39,520 --> 00:23:41,440
had so far for to appear with

618
00:23:41,440 --> 00:23:43,120
pre-processing

619
00:23:43,120 --> 00:23:45,200
and here we notice that the simple peer

620
00:23:45,200 --> 00:23:47,039
and partition peer product calls that i

621
00:23:47,039 --> 00:23:48,960
described below how the following

622
00:23:48,960 --> 00:23:50,400
structure well

623
00:23:50,400 --> 00:23:53,440
first the client and server run some rp

624
00:23:53,440 --> 00:23:55,200
protocol on the original database and

625
00:23:55,200 --> 00:23:57,200
the client learns some bits

626
00:23:57,200 --> 00:24:00,000
then once the client knows what index

627
00:24:00,000 --> 00:24:01,440
it's interested in

628
00:24:01,440 --> 00:24:02,960
then it sends a single message to the

629
00:24:02,960 --> 00:24:05,600
server and then the client and server

630
00:24:05,600 --> 00:24:07,679
will run a peer protocol on the smaller

631
00:24:07,679 --> 00:24:10,159
database of size n over two or n over t

632
00:24:10,159 --> 00:24:12,159
if it's the partition one

633
00:24:12,159 --> 00:24:14,559
that means that step one you can do the

634
00:24:14,559 --> 00:24:17,279
pre-processing so step two and three are

635
00:24:17,279 --> 00:24:20,240
done online but the work here is reduced

636
00:24:20,240 --> 00:24:22,559
by a factor of two or a factor of t so

637
00:24:22,559 --> 00:24:24,799
this is a very very light weight of

638
00:24:24,799 --> 00:24:27,918
doing pre-processing

639
00:24:28,080 --> 00:24:30,559
okay and with that i told you all i

640
00:24:30,559 --> 00:24:32,799
wanted to tell you about rpr as a

641
00:24:32,799 --> 00:24:35,120
primitive so let's spend a few minutes

642
00:24:35,120 --> 00:24:38,320
talking about application of rper to the

643
00:24:38,320 --> 00:24:40,559
secret on the blockchain architecture

644
00:24:40,559 --> 00:24:42,320
and in this context when i say

645
00:24:42,320 --> 00:24:44,000
blockchain what i really mean as a

646
00:24:44,000 --> 00:24:46,000
system with many nodes most of them are

647
00:24:46,000 --> 00:24:47,360
student awareness there is nothing

648
00:24:47,360 --> 00:24:49,120
blockchainy about it

649
00:24:49,120 --> 00:24:51,360
um the motivation slides that i'm going

650
00:24:51,360 --> 00:24:53,600
to go through now are the courtesy of

651
00:24:53,600 --> 00:24:55,919
sophia

652
00:24:55,919 --> 00:24:58,799
so think of a secure mpc as a service we

653
00:24:58,799 --> 00:25:00,480
have clients they want to compute some

654
00:25:00,480 --> 00:25:02,480
function and they want to send it to the

655
00:25:02,480 --> 00:25:03,919
cloud that

656
00:25:03,919 --> 00:25:05,600
will compute it for them

657
00:25:05,600 --> 00:25:08,400
but for privacy reasons for

658
00:25:08,400 --> 00:25:10,720
resilience reasons you want the cloud to

659
00:25:10,720 --> 00:25:13,360
be implemented as a secure npc so that

660
00:25:13,360 --> 00:25:15,760
it will give you both guarantee that you

661
00:25:15,760 --> 00:25:17,440
get the correct output with guaranteed

662
00:25:17,440 --> 00:25:19,919
output delivery and privacy now of

663
00:25:19,919 --> 00:25:22,720
course that only happens as long as some

664
00:25:22,720 --> 00:25:24,320
less than some t

665
00:25:24,320 --> 00:25:27,360
of the servers that make up this cloud

666
00:25:27,360 --> 00:25:29,520
are corrupt so that's nice i mean you

667
00:25:29,520 --> 00:25:33,200
get uh additional benefits

668
00:25:33,279 --> 00:25:34,960
to the clients

669
00:25:34,960 --> 00:25:37,200
but now think of doing the same thing

670
00:25:37,200 --> 00:25:38,799
with millions of parties so you have a

671
00:25:38,799 --> 00:25:40,640
blockchain and you want the blockchain

672
00:25:40,640 --> 00:25:42,960
to compute that thing for you

673
00:25:42,960 --> 00:25:45,760
so the entire system consists of god

674
00:25:45,760 --> 00:25:48,159
only knows how many nodes now need to

675
00:25:48,159 --> 00:25:49,760
compute and you can do the exact same

676
00:25:49,760 --> 00:25:51,520
thing right i mean they could in

677
00:25:51,520 --> 00:25:53,840
principle run a secure mpc protocol and

678
00:25:53,840 --> 00:25:56,080
give you correct output and privacy as

679
00:25:56,080 --> 00:25:58,159
long as not too many are corrupted

680
00:25:58,159 --> 00:25:59,919
but there is an efficiency issue here

681
00:25:59,919 --> 00:26:02,240
right a run-of-the-mill mpc protocol

682
00:26:02,240 --> 00:26:05,919
typically have every server every node

683
00:26:05,919 --> 00:26:07,919
talked to every other node and that's

684
00:26:07,919 --> 00:26:09,840
very very expensive when there are many

685
00:26:09,840 --> 00:26:11,039
nodes

686
00:26:11,039 --> 00:26:13,039
so in addition to security goals that we

687
00:26:13,039 --> 00:26:14,159
had from before now we have an

688
00:26:14,159 --> 00:26:15,919
efficiency goal and the goal that we

689
00:26:15,919 --> 00:26:18,720
want to focus here is sub-linear

690
00:26:18,720 --> 00:26:20,559
communication in the number of parties

691
00:26:20,559 --> 00:26:22,240
we do not want

692
00:26:22,240 --> 00:26:26,799
every party to talk to every other party

693
00:26:28,320 --> 00:26:30,960
an obvious way to try to do that

694
00:26:30,960 --> 00:26:32,880
is use a small committee so choose a

695
00:26:32,880 --> 00:26:34,720
random committee to represent the entire

696
00:26:34,720 --> 00:26:37,120
thing if a majority of parties in the

697
00:26:37,120 --> 00:26:39,200
overall population are honest then

698
00:26:39,200 --> 00:26:41,760
hopefully with some high probability the

699
00:26:41,760 --> 00:26:43,279
majority of parties also in the

700
00:26:43,279 --> 00:26:45,200
committee will be uh honest and then you

701
00:26:45,200 --> 00:26:47,120
can just run as a regular secure mpc

702
00:26:47,120 --> 00:26:48,880
protocol here

703
00:26:48,880 --> 00:26:50,799
the problem with that is what happens if

704
00:26:50,799 --> 00:26:52,799
the adversary is adaptive as soon as

705
00:26:52,799 --> 00:26:54,960
these nodes start talking they adversely

706
00:26:54,960 --> 00:26:56,480
know who the committee is and then it

707
00:26:56,480 --> 00:26:58,240
just goes and corrupt them

708
00:26:58,240 --> 00:26:59,840
or maybe not corrupt them maybe the

709
00:26:59,840 --> 00:27:01,600
other side is not all that powerful but

710
00:27:01,600 --> 00:27:03,520
it can at least detox them it just

711
00:27:03,520 --> 00:27:05,279
knocks them off and your entire

712
00:27:05,279 --> 00:27:07,039
computation all the state that you built

713
00:27:07,039 --> 00:27:09,120
so far is dead

714
00:27:09,120 --> 00:27:11,918
so what do we do

715
00:27:12,320 --> 00:27:14,320
one thing that we'll do is we'll switch

716
00:27:14,320 --> 00:27:16,400
to a yoso style

717
00:27:16,400 --> 00:27:18,480
secure computation protocol this is a

718
00:27:18,480 --> 00:27:20,640
style of protocol that was studies uh

719
00:27:20,640 --> 00:27:23,600
encrypt studied in crypto this year by

720
00:27:23,600 --> 00:27:25,440
gentile

721
00:27:25,440 --> 00:27:27,440
and the type of protocol that we're

722
00:27:27,440 --> 00:27:29,440
talking about we have evolving committee

723
00:27:29,440 --> 00:27:32,159
each active for just one step as soon as

724
00:27:32,159 --> 00:27:35,200
you say something your role is over so

725
00:27:35,200 --> 00:27:36,960
after the first step the adversary

726
00:27:36,960 --> 00:27:38,480
corrupt may be the first committee but

727
00:27:38,480 --> 00:27:40,080
now there's a whole new committee that

728
00:27:40,080 --> 00:27:43,039
needs to talk and after the adversary

729
00:27:43,039 --> 00:27:44,960
may be corrupt then there's a new

730
00:27:44,960 --> 00:27:46,399
committee every time by the time that

731
00:27:46,399 --> 00:27:48,640
the adversary learns who the committee

732
00:27:48,640 --> 00:27:49,679
is

733
00:27:49,679 --> 00:27:52,080
this committee is no longer active and

734
00:27:52,080 --> 00:27:54,159
there's nothing to be gained by killing

735
00:27:54,159 --> 00:27:57,039
it detoxing it or or corrupting it

736
00:27:57,039 --> 00:27:59,279
so this is the style of protocols that

737
00:27:59,279 --> 00:28:01,279
we would like to use here

738
00:28:01,279 --> 00:28:02,399
and

739
00:28:02,399 --> 00:28:05,360
gently i'll show that essentially every

740
00:28:05,360 --> 00:28:06,320
uh

741
00:28:06,320 --> 00:28:08,320
function you can compute

742
00:28:08,320 --> 00:28:10,960
in this style of protocols

743
00:28:10,960 --> 00:28:13,279
even if you want things like guaranteed

744
00:28:13,279 --> 00:28:15,039
delivery etc

745
00:28:15,039 --> 00:28:16,559
as long as

746
00:28:16,559 --> 00:28:18,480
you have honest majority among the

747
00:28:18,480 --> 00:28:21,440
entire population

748
00:28:21,440 --> 00:28:23,120
but there is a problem and the problem

749
00:28:23,120 --> 00:28:24,960
is how to forward state between

750
00:28:24,960 --> 00:28:26,880
committees so

751
00:28:26,880 --> 00:28:29,440
in this setting we want the committees

752
00:28:29,440 --> 00:28:31,120
to be hidden from the adversary so that

753
00:28:31,120 --> 00:28:33,919
they will not be corrupted or ddosed

754
00:28:33,919 --> 00:28:35,440
but then if nobody knows who the

755
00:28:35,440 --> 00:28:37,120
committee is how do you send them the

756
00:28:37,120 --> 00:28:39,360
messages that they need to see in order

757
00:28:39,360 --> 00:28:40,159
to

758
00:28:40,159 --> 00:28:42,880
participate in the computation

759
00:28:42,880 --> 00:28:44,960
and this thing was actually considered

760
00:28:44,960 --> 00:28:47,120
by benham

761
00:28:47,120 --> 00:28:49,440
and they talked about the notion of

762
00:28:49,440 --> 00:28:51,440
target anonymous channels to send

763
00:28:51,440 --> 00:28:53,760
messages so everybody would be able to

764
00:28:53,760 --> 00:28:56,080
send message to party i in the next

765
00:28:56,080 --> 00:28:58,720
committee without knowing who that party

766
00:28:58,720 --> 00:28:59,600
is

767
00:28:59,600 --> 00:29:02,720
uh how to implement those was left

768
00:29:02,720 --> 00:29:05,360
explicitly out of scope uh in the yoso

769
00:29:05,360 --> 00:29:08,159
paper of gentritar but it was addressed

770
00:29:08,159 --> 00:29:10,399
by benham and they gave some solution

771
00:29:10,399 --> 00:29:11,919
i'll talk about it a bit in the next

772
00:29:11,919 --> 00:29:12,799
slide

773
00:29:12,799 --> 00:29:14,559
but that solution is a little defective

774
00:29:14,559 --> 00:29:17,039
i mean it can only withstand corruptions

775
00:29:17,039 --> 00:29:19,840
of up to about roughly a quarter of the

776
00:29:19,840 --> 00:29:21,760
overall population

777
00:29:21,760 --> 00:29:24,480
uh and not more than that

778
00:29:24,480 --> 00:29:27,360
so the goal here is to construct target

779
00:29:27,360 --> 00:29:29,760
anonymous channels so first of all we're

780
00:29:29,760 --> 00:29:31,840
going to assume pki and authenticated

781
00:29:31,840 --> 00:29:33,520
broadcast the reason i'm don't have a

782
00:29:33,520 --> 00:29:35,279
problem assuming that is we're thinking

783
00:29:35,279 --> 00:29:36,799
of blockchains and blockchain give you

784
00:29:36,799 --> 00:29:38,559
that sort of for free as long as the

785
00:29:38,559 --> 00:29:40,960
blockchain works you have that

786
00:29:40,960 --> 00:29:43,200
uh and if you have pki and authenticated

787
00:29:43,200 --> 00:29:45,520
broadcast that really all you need

788
00:29:45,520 --> 00:29:47,600
is some way to re-randomize the public

789
00:29:47,600 --> 00:29:50,880
keys of parties so if by some chance

790
00:29:50,880 --> 00:29:53,520
a re-randomized version of my public key

791
00:29:53,520 --> 00:29:55,679
appears on the on the broadcast channel

792
00:29:55,679 --> 00:29:58,240
then everybody can send me um now

793
00:29:58,240 --> 00:29:59,760
messages and they don't need to know who

794
00:29:59,760 --> 00:30:02,399
i am all they need to know is well this

795
00:30:02,399 --> 00:30:04,320
is the public key of party number five

796
00:30:04,320 --> 00:30:06,480
in the next committee let's encrypt it

797
00:30:06,480 --> 00:30:07,600
and i

798
00:30:07,600 --> 00:30:09,840
know that this is my uh public key and i

799
00:30:09,840 --> 00:30:12,240
can decrypt it

800
00:30:12,240 --> 00:30:14,799
so it sort of boils down to the question

801
00:30:14,799 --> 00:30:16,640
is how do you choose and re-randomize

802
00:30:16,640 --> 00:30:18,640
the key without the adversary learning

803
00:30:18,640 --> 00:30:20,480
who that key belongs to

804
00:30:20,480 --> 00:30:21,600
and then

805
00:30:21,600 --> 00:30:23,440
actually did offer a solution in their

806
00:30:23,440 --> 00:30:26,080
case there was another auxiliary

807
00:30:26,080 --> 00:30:29,039
committee that chose the committee that

808
00:30:29,039 --> 00:30:30,960
is going to get here we're going to

809
00:30:30,960 --> 00:30:33,120
participate in the computation

810
00:30:33,120 --> 00:30:35,039
uh and then each member of this

811
00:30:35,039 --> 00:30:37,279
auxiliary committee chose one member of

812
00:30:37,279 --> 00:30:39,360
the secretary and committee and

813
00:30:39,360 --> 00:30:41,360
re-randomized its key but that has a

814
00:30:41,360 --> 00:30:43,039
problem of a double dipping attack

815
00:30:43,039 --> 00:30:44,799
because now the adversary knows who is

816
00:30:44,799 --> 00:30:47,520
in the committee if either that

817
00:30:47,520 --> 00:30:50,320
person itself wasn't corrupted all the

818
00:30:50,320 --> 00:30:52,399
person that nominated the committee was

819
00:30:52,399 --> 00:30:53,919
corrupted so there's a double dipping

820
00:30:53,919 --> 00:30:55,600
which is why

821
00:30:55,600 --> 00:30:58,320
we cannot get better than resilience

822
00:30:58,320 --> 00:31:00,080
against a quarter of corruptions by the

823
00:31:00,080 --> 00:31:02,080
adversary

824
00:31:02,080 --> 00:31:04,320
the idea that we want to explore here is

825
00:31:04,320 --> 00:31:06,080
we already have committees they are

826
00:31:06,080 --> 00:31:08,559
already running secure npc protocol how

827
00:31:08,559 --> 00:31:10,399
about these previous committees will

828
00:31:10,399 --> 00:31:13,200
also do the work that's needed in order

829
00:31:13,200 --> 00:31:15,039
to uh

830
00:31:15,039 --> 00:31:16,880
establish the target anonymous channel

831
00:31:16,880 --> 00:31:18,880
we will bootstrap these things off of

832
00:31:18,880 --> 00:31:20,720
the previous committees

833
00:31:20,720 --> 00:31:23,039
and that works

834
00:31:23,039 --> 00:31:26,320
so think of the target anonymous channel

835
00:31:26,320 --> 00:31:29,039
function it takes n public keys this is

836
00:31:29,039 --> 00:31:31,360
a public input and it takes randomness

837
00:31:31,360 --> 00:31:32,480
this is a

838
00:31:32,480 --> 00:31:34,960
private input for the n parties

839
00:31:34,960 --> 00:31:36,880
or for the k parties whatever and it

840
00:31:36,880 --> 00:31:40,320
outputs scaly randomized keys out

841
00:31:40,320 --> 00:31:42,399
and that works i mean this from security

842
00:31:42,399 --> 00:31:43,760
point of view this is exactly what you

843
00:31:43,760 --> 00:31:46,240
want but it does have a problem uh in

844
00:31:46,240 --> 00:31:48,399
that it's not scalable our point was to

845
00:31:48,399 --> 00:31:51,519
use less than n bits of communications

846
00:31:51,519 --> 00:31:53,840
here and this definitely doesn't do that

847
00:31:53,840 --> 00:31:55,600
i mean if you think of the

848
00:31:55,600 --> 00:31:57,600
circuit that computes that function that

849
00:31:57,600 --> 00:32:00,799
circuit has long input in particular the

850
00:32:00,799 --> 00:32:03,360
end public keys so if you want to just

851
00:32:03,360 --> 00:32:06,960
apply a run-of-the-mill mpc protocols uh

852
00:32:06,960 --> 00:32:08,640
you will get at least 10 bits of

853
00:32:08,640 --> 00:32:10,720
communication so we want to do better

854
00:32:10,720 --> 00:32:12,159
and we're going to here is where we're

855
00:32:12,159 --> 00:32:15,200
going to use rpg how do we use rp we can

856
00:32:15,200 --> 00:32:17,120
break the computation of the target

857
00:32:17,120 --> 00:32:20,960
anonymous channel function into first do

858
00:32:20,960 --> 00:32:23,360
batch rpl to

859
00:32:23,360 --> 00:32:24,960
fetch

860
00:32:24,960 --> 00:32:28,720
k random public keys from the pki

861
00:32:28,720 --> 00:32:32,000
and then re-randomize these k-run clubs

862
00:32:32,000 --> 00:32:34,399
now for the batch appeal the previous

863
00:32:34,399 --> 00:32:37,039
committees will just simulate the rpl

864
00:32:37,039 --> 00:32:38,720
client

865
00:32:38,720 --> 00:32:41,039
and since the database is public then

866
00:32:41,039 --> 00:32:42,960
each member can individually play the

867
00:32:42,960 --> 00:32:44,720
server in its head

868
00:32:44,720 --> 00:32:46,880
the communication here is a little off n

869
00:32:46,880 --> 00:32:48,720
because up here is not real but notice

870
00:32:48,720 --> 00:32:51,679
that this is a really weird use of of

871
00:32:51,679 --> 00:32:53,519
piro out there

872
00:32:53,519 --> 00:32:55,120
because you don't

873
00:32:55,120 --> 00:32:57,200
need to broadcast the thing that the

874
00:32:57,200 --> 00:32:59,279
server says everybody plays the server

875
00:32:59,279 --> 00:33:01,440
in their head and they can imagine

876
00:33:01,440 --> 00:33:02,799
what the server would say without

877
00:33:02,799 --> 00:33:04,159
needing to

878
00:33:04,159 --> 00:33:06,320
broadcast it the thing that you really

879
00:33:06,320 --> 00:33:08,960
care about is to have a

880
00:33:08,960 --> 00:33:10,960
very short communication for the client

881
00:33:10,960 --> 00:33:13,679
so it is a weird use of peer

882
00:33:13,679 --> 00:33:15,840
the other thing to notice is that since

883
00:33:15,840 --> 00:33:17,760
we have a committee that implements the

884
00:33:17,760 --> 00:33:20,559
secure computation the output of it that

885
00:33:20,559 --> 00:33:23,440
is the k public keys are

886
00:33:23,440 --> 00:33:25,279
shared among this committee at the end

887
00:33:25,279 --> 00:33:27,519
of this step so the others still doesn't

888
00:33:27,519 --> 00:33:28,559
know them

889
00:33:28,559 --> 00:33:30,720
and then you run the randomized path

890
00:33:30,720 --> 00:33:32,240
this is a function that doesn't depend

891
00:33:32,240 --> 00:33:34,320
on n so it's scalable and then you

892
00:33:34,320 --> 00:33:36,559
reconstruct the randomized public keys

893
00:33:36,559 --> 00:33:38,000
and broadcast them to the broadcast

894
00:33:38,000 --> 00:33:40,559
channel and this is how you establish

895
00:33:40,559 --> 00:33:43,840
the target anonymous challenge

896
00:33:43,840 --> 00:33:45,919
so if this is what we want to do what do

897
00:33:45,919 --> 00:33:48,399
we need from the rpa protocol so we need

898
00:33:48,399 --> 00:33:49,679
it to be very efficient small

899
00:33:49,679 --> 00:33:51,519
communication silicon processing and

900
00:33:51,519 --> 00:33:53,760
because we are

901
00:33:53,760 --> 00:33:56,720
simulating the client with a secure

902
00:33:56,720 --> 00:33:58,720
computation and also secure computation

903
00:33:58,720 --> 00:34:01,279
like that these are typically heavier

904
00:34:01,279 --> 00:34:03,840
mpc then it better be the case that what

905
00:34:03,840 --> 00:34:05,440
the client computes in this output

906
00:34:05,440 --> 00:34:07,919
workflow is very very very simple

907
00:34:07,919 --> 00:34:09,359
um

908
00:34:09,359 --> 00:34:11,839
and from security we want to make sure

909
00:34:11,839 --> 00:34:13,199
that the other side doesn't learn who's

910
00:34:13,199 --> 00:34:15,440
on the next committee which means that

911
00:34:15,440 --> 00:34:17,520
uh the next committee should be at least

912
00:34:17,520 --> 00:34:20,320
unpredictable in the sense that the

913
00:34:20,320 --> 00:34:22,719
adversary cannot guess more than half of

914
00:34:22,719 --> 00:34:25,440
the members of it to corrupt

915
00:34:25,440 --> 00:34:28,079
uh so we can use the batch rpa with

916
00:34:28,079 --> 00:34:30,239
weaker security because all we want here

917
00:34:30,239 --> 00:34:32,159
is unpredictability and not so

918
00:34:32,159 --> 00:34:35,918
randomness and that helps a little bit

919
00:34:35,918 --> 00:34:38,800
let me just show you one very very

920
00:34:38,800 --> 00:34:40,879
simple thing that we can do just because

921
00:34:40,879 --> 00:34:41,918
we can

922
00:34:41,918 --> 00:34:43,599
use the uh

923
00:34:43,599 --> 00:34:45,679
unpredictability version of this instead

924
00:34:45,679 --> 00:34:48,639
of the randomness so instead of choosing

925
00:34:48,639 --> 00:34:50,560
at random k entries from the entire

926
00:34:50,560 --> 00:34:52,800
database we just partition the database

927
00:34:52,800 --> 00:34:55,918
into m bins m is some parameter and we

928
00:34:55,918 --> 00:34:58,560
choose a random k over m for each

929
00:34:58,560 --> 00:34:59,520
bin

930
00:34:59,520 --> 00:35:02,320
so now

931
00:35:03,440 --> 00:35:05,599
you know clearly there are many subsets

932
00:35:05,599 --> 00:35:08,079
that cannot be chosen this way because

933
00:35:08,079 --> 00:35:10,880
many subsets don't have exactly k over m

934
00:35:10,880 --> 00:35:14,160
from each b in many k subsets but

935
00:35:14,160 --> 00:35:17,359
you can see that um

936
00:35:17,359 --> 00:35:20,480
at least it saves an m factor in server

937
00:35:20,480 --> 00:35:21,520
work

938
00:35:21,520 --> 00:35:24,160
because uh now you fetch the same number

939
00:35:24,160 --> 00:35:26,319
of

940
00:35:26,400 --> 00:35:28,400
points you said you fetch k points but

941
00:35:28,400 --> 00:35:31,359
you fetch them from databases of size k

942
00:35:31,359 --> 00:35:33,119
over m instead of

943
00:35:33,119 --> 00:35:35,040
size n over m instead of databases of

944
00:35:35,040 --> 00:35:36,560
size n

945
00:35:36,560 --> 00:35:38,640
uh so definitely you save at least a

946
00:35:38,640 --> 00:35:41,119
factor of m in a server work and whether

947
00:35:41,119 --> 00:35:43,200
or not to how much you send in client

948
00:35:43,200 --> 00:35:45,760
work depends really on on what peer

949
00:35:45,760 --> 00:35:48,720
protocol you're using underlying it

950
00:35:48,720 --> 00:35:51,200
and in terms of probability so yeah as i

951
00:35:51,200 --> 00:35:53,280
said many subsystems can no longer

952
00:35:53,280 --> 00:35:55,359
appear but the subset that can appear

953
00:35:55,359 --> 00:35:57,680
are distributed uniformly and in fact

954
00:35:57,680 --> 00:35:59,680
the fraction of subsets that can appear

955
00:35:59,680 --> 00:36:01,599
is not too tiny

956
00:36:01,599 --> 00:36:03,839
it's a fraction that's exponentially an

957
00:36:03,839 --> 00:36:06,640
m and polynomial in n small so if you

958
00:36:06,640 --> 00:36:10,079
set m to be log then you know the

959
00:36:10,079 --> 00:36:12,400
you still have a polynomial fraction of

960
00:36:12,400 --> 00:36:13,599
the uh

961
00:36:13,599 --> 00:36:15,760
subsets that can appear

962
00:36:15,760 --> 00:36:17,200
and uh

963
00:36:17,200 --> 00:36:18,880
therefore the probability mass of each

964
00:36:18,880 --> 00:36:20,960
one of them grows by at most a

965
00:36:20,960 --> 00:36:23,200
polynomial factor and therefore you have

966
00:36:23,200 --> 00:36:25,280
this definition that anything that was

967
00:36:25,280 --> 00:36:27,920
uh any bad event that happened with

968
00:36:27,920 --> 00:36:30,000
negligible probability

969
00:36:30,000 --> 00:36:32,320
when you just use the completely random

970
00:36:32,320 --> 00:36:34,560
peer will still happen with negligible

971
00:36:34,560 --> 00:36:38,079
probability even in this case

972
00:36:38,079 --> 00:36:39,920
so that's all i wanted to tell you today

973
00:36:39,920 --> 00:36:42,480
uh we introduced the random pier it's a

974
00:36:42,480 --> 00:36:44,320
weaker valentine

975
00:36:44,320 --> 00:36:46,560
it can be somewhat more efficient than

976
00:36:46,560 --> 00:36:48,720
peer but not too much because the

977
00:36:48,720 --> 00:36:50,800
equivalent was primitives still there

978
00:36:50,800 --> 00:36:52,240
are gains to be had

979
00:36:52,240 --> 00:36:54,480
and it's motivated by our application to

980
00:36:54,480 --> 00:36:56,960
very large scale and pc

981
00:36:56,960 --> 00:36:59,599
which we call secrets on the blockchain

982
00:36:59,599 --> 00:37:01,440
and it allows us in particular to

983
00:37:01,440 --> 00:37:03,839
construct target anonymous channels

984
00:37:03,839 --> 00:37:05,839
which are resilient to compromise of up

985
00:37:05,839 --> 00:37:08,320
to half minus epsilon of the party as

986
00:37:08,320 --> 00:37:10,240
opposed to the solution

987
00:37:10,240 --> 00:37:12,400
of the model that can only tolerate

988
00:37:12,400 --> 00:37:15,119
about a quarter of the parties corrupted

989
00:37:15,119 --> 00:37:17,040
and that's all i wanted to tell you

990
00:37:17,040 --> 00:37:20,320
thank you very much

