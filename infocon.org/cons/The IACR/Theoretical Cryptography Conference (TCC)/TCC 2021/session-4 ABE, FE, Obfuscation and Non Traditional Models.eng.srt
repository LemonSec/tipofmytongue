1
00:00:00,399 --> 00:00:01,760
about

2
00:00:01,760 --> 00:00:03,840
um

3
00:00:03,840 --> 00:00:07,120
a multi-party functional encryption good

4
00:00:07,120 --> 00:00:10,160
and so this is the work by schweitzer

5
00:00:10,160 --> 00:00:13,599
rishab goel and junichi tamida and

6
00:00:13,599 --> 00:00:14,920
michelle will give

7
00:00:14,920 --> 00:00:18,320
talk thanks and welcome back everyone to

8
00:00:18,320 --> 00:00:21,039
the in-person session so okay

9
00:00:21,039 --> 00:00:22,560
so this talk should could be a nice

10
00:00:22,560 --> 00:00:24,160
segue between the embassy session and

11
00:00:24,160 --> 00:00:25,519
the function encryption setting a

12
00:00:25,519 --> 00:00:28,320
function encryption session so the talk

13
00:00:28,320 --> 00:00:30,160
is on multi-party function encryption

14
00:00:30,160 --> 00:00:31,439
and the starting point of this talk is

15
00:00:31,439 --> 00:00:34,000
the notion of function encryption

16
00:00:34,000 --> 00:00:36,000
i apologize the font is bad maybe it's

17
00:00:36,000 --> 00:00:38,000
like the the powerpoint in the system is

18
00:00:38,000 --> 00:00:40,000
a little bit old one or not okay so the

19
00:00:40,000 --> 00:00:41,440
notion of function encryption is a very

20
00:00:41,440 --> 00:00:42,559
powerful notion of encryption which

21
00:00:42,559 --> 00:00:44,320
allows fine-tuned decryption access over

22
00:00:44,320 --> 00:00:46,559
encrypted data and it saw its roots as

23
00:00:46,559 --> 00:00:49,360
early as back in 2005. and pictorially

24
00:00:49,360 --> 00:00:50,960
functional encryption can be understood

25
00:00:50,960 --> 00:00:52,559
here the following picture we have said

26
00:00:52,559 --> 00:00:54,719
three parties alice bob and charlie

27
00:00:54,719 --> 00:00:56,800
alice has some private data m

28
00:00:56,800 --> 00:00:59,199
bob has the secret key and what charlie

29
00:00:59,199 --> 00:01:00,399
wants to know is that charlie wants to

30
00:01:00,399 --> 00:01:02,399
learn the evaluation of the function f

31
00:01:02,399 --> 00:01:03,920
on the message m

32
00:01:03,920 --> 00:01:07,360
now given encryption of uh alice's data

33
00:01:07,360 --> 00:01:08,720
what bob could do is that bob could

34
00:01:08,720 --> 00:01:10,560
simply supply charlie with the master

35
00:01:10,560 --> 00:01:12,320
secret key charlie can decrypt the

36
00:01:12,320 --> 00:01:14,560
ciphertext evaluate the function

37
00:01:14,560 --> 00:01:16,799
and uh learn the corresponding value f

38
00:01:16,799 --> 00:01:18,720
of m that's great but that leaks the

39
00:01:18,720 --> 00:01:21,040
entire plaintext value what if

40
00:01:21,040 --> 00:01:22,960
alice only wants charlie to learn f of m

41
00:01:22,960 --> 00:01:24,640
and nothing else

42
00:01:24,640 --> 00:01:26,000
so function encryption basically was

43
00:01:26,000 --> 00:01:27,200
devised to sort of capture this

44
00:01:27,200 --> 00:01:28,960
intuition where the idea was that bob

45
00:01:28,960 --> 00:01:30,079
can actually create some partial

46
00:01:30,079 --> 00:01:31,680
decryption keys called function secret

47
00:01:31,680 --> 00:01:33,200
keys such that given the function of

48
00:01:33,200 --> 00:01:35,520
secret key charlie can actually compute

49
00:01:35,520 --> 00:01:37,680
this on its own without outsourcing this

50
00:01:37,680 --> 00:01:39,600
computation to pop or with even bob

51
00:01:39,600 --> 00:01:41,840
being offline and function encryption

52
00:01:41,840 --> 00:01:43,840
lets us solve this problem

53
00:01:43,840 --> 00:01:45,439
the intuition behind function encryption

54
00:01:45,439 --> 00:01:47,040
is basically given a ciphertext that

55
00:01:47,040 --> 00:01:49,119
encrypts some data x and polynomial

56
00:01:49,119 --> 00:01:50,880
secret keys all the adversary can learn

57
00:01:50,880 --> 00:01:52,799
is by running the decryption algorithm

58
00:01:52,799 --> 00:01:54,240
and the evaluation of the functions on

59
00:01:54,240 --> 00:01:57,200
that particular secret value x

60
00:01:57,200 --> 00:01:58,799
now functional encryption has been a

61
00:01:58,799 --> 00:02:00,960
grand genophile and has been able to

62
00:02:00,960 --> 00:02:03,280
sort of unify all existing encryption

63
00:02:03,280 --> 00:02:04,880
functionalities device at the time such

64
00:02:04,880 --> 00:02:06,560
as identity-based encryption

65
00:02:06,560 --> 00:02:08,399
activity-based encryption in a product

66
00:02:08,399 --> 00:02:10,239
function encryption and much more

67
00:02:10,239 --> 00:02:11,038
and

68
00:02:11,038 --> 00:02:13,120
even beyond that just unifying it has

69
00:02:13,120 --> 00:02:14,879
been able to even focus interesting

70
00:02:14,879 --> 00:02:16,800
encryption models such as partially

71
00:02:16,800 --> 00:02:18,560
hiding functional encryption and also

72
00:02:18,560 --> 00:02:19,840
has been used as an interesting

73
00:02:19,840 --> 00:02:21,840
abstraction to get to study more

74
00:02:21,840 --> 00:02:23,520
fundamental cryptographic objects such

75
00:02:23,520 --> 00:02:26,000
as also using as an abstraction to study

76
00:02:26,000 --> 00:02:28,319
uh program opposition and more

77
00:02:28,319 --> 00:02:29,840
and it has been so powerful that

78
00:02:29,840 --> 00:02:31,040
function description has even been

79
00:02:31,040 --> 00:02:33,120
studied in more powerful models of

80
00:02:33,120 --> 00:02:35,040
multiple users now at this point you

81
00:02:35,040 --> 00:02:36,319
might be wondering okay hey isn't

82
00:02:36,319 --> 00:02:37,280
function encryption already like a

83
00:02:37,280 --> 00:02:39,280
multi-user model even in my simple

84
00:02:39,280 --> 00:02:41,200
example i had like three different users

85
00:02:41,200 --> 00:02:42,480
why do i feel like function encryption

86
00:02:42,480 --> 00:02:44,400
tradition is like a single user model

87
00:02:44,400 --> 00:02:45,840
the point is that over here if you

88
00:02:45,840 --> 00:02:47,519
really look at the digital algorithm it

89
00:02:47,519 --> 00:02:49,360
takes us input a single ciphertext and a

90
00:02:49,360 --> 00:02:50,959
single secret key pair

91
00:02:50,959 --> 00:02:52,480
but what if the number of scientists

92
00:02:52,480 --> 00:02:53,440
could be multiple there could be

93
00:02:53,440 --> 00:02:55,200
multiple different sources of ciphers or

94
00:02:55,200 --> 00:02:56,400
what if there are multiple different

95
00:02:56,400 --> 00:02:58,159
sources of secret keys or maybe both

96
00:02:58,159 --> 00:02:59,680
multiple science texts multiple secret

97
00:02:59,680 --> 00:03:01,280
keys traditionally the notion of

98
00:03:01,280 --> 00:03:02,560
function encryption does not capture

99
00:03:02,560 --> 00:03:04,400
these scenarios and to sort of study

100
00:03:04,400 --> 00:03:05,920
these scenarios the notion of function

101
00:03:05,920 --> 00:03:07,280
encryption was studied in sort of these

102
00:03:07,280 --> 00:03:09,680
multi-user motors so for example one of

103
00:03:09,680 --> 00:03:11,440
the earliest works by moscow they

104
00:03:11,440 --> 00:03:13,120
proposed the notion of multi-input

105
00:03:13,120 --> 00:03:14,640
function encryption where as the name

106
00:03:14,640 --> 00:03:15,920
suggests we have multiple different

107
00:03:15,920 --> 00:03:18,080
input sources you interpret systems for

108
00:03:18,080 --> 00:03:19,599
these these cyclics independently for

109
00:03:19,599 --> 00:03:21,120
these different inputs and using a

110
00:03:21,120 --> 00:03:22,640
single function secret key you can learn

111
00:03:22,640 --> 00:03:24,480
the evaluation of function f on the

112
00:03:24,480 --> 00:03:26,640
joint inputs together and this has been

113
00:03:26,640 --> 00:03:27,840
recently extended to the notion of

114
00:03:27,840 --> 00:03:29,920
multiclient function encryption similar

115
00:03:29,920 --> 00:03:31,519
progress has been done in the notion of

116
00:03:31,519 --> 00:03:32,959
uh

117
00:03:32,959 --> 00:03:34,560
distributed secret keys that you have

118
00:03:34,560 --> 00:03:36,159
studied multi authority uh function

119
00:03:36,159 --> 00:03:37,840
encryption decentralized function

120
00:03:37,840 --> 00:03:39,440
encryption and much more

121
00:03:39,440 --> 00:03:41,599
and so much so that we've also studied

122
00:03:41,599 --> 00:03:43,040
function encryption in more powerful

123
00:03:43,040 --> 00:03:44,560
models where you can distribute site

124
00:03:44,560 --> 00:03:46,319
text as well as secret keys and the

125
00:03:46,319 --> 00:03:47,920
notions of decentralized multi-client

126
00:03:47,920 --> 00:03:50,400
function encryption arab mifv dynamic

127
00:03:50,400 --> 00:03:51,840
decentralized function encryption a lot

128
00:03:51,840 --> 00:03:53,599
of such notions have been uh studied in

129
00:03:53,599 --> 00:03:54,720
the

130
00:03:54,720 --> 00:03:57,120
literature and uh basically the point is

131
00:03:57,120 --> 00:03:59,040
that you have so many you have so many

132
00:03:59,040 --> 00:04:00,879
different models where we sort of model

133
00:04:00,879 --> 00:04:02,159
function encryption these multi-user

134
00:04:02,159 --> 00:04:04,400
models and all of these different models

135
00:04:04,400 --> 00:04:05,599
have been subject because we have

136
00:04:05,599 --> 00:04:07,120
different applications today with

137
00:04:07,120 --> 00:04:09,200
different security models so thus for

138
00:04:09,200 --> 00:04:10,560
these different goals we sort of come up

139
00:04:10,560 --> 00:04:11,840
with a different notion of functional

140
00:04:11,840 --> 00:04:13,200
encryption primitive for these

141
00:04:13,200 --> 00:04:14,400
particular models

142
00:04:14,400 --> 00:04:16,160
while this is quite great it seems

143
00:04:16,160 --> 00:04:18,000
somewhat similar to what the story

144
00:04:18,000 --> 00:04:19,519
looked like in the pre-functional

145
00:04:19,519 --> 00:04:21,358
encryption days where we studied an

146
00:04:21,358 --> 00:04:23,120
encryption for different users of

147
00:04:23,120 --> 00:04:24,800
different models and we sort of built a

148
00:04:24,800 --> 00:04:26,240
new encryption primitive for each of

149
00:04:26,240 --> 00:04:27,360
these models

150
00:04:27,360 --> 00:04:30,000
but it turns out in these multi-user

151
00:04:30,000 --> 00:04:31,120
models

152
00:04:31,120 --> 00:04:33,360
it's hard to compare which results are

153
00:04:33,360 --> 00:04:35,120
known under what models what are the

154
00:04:35,120 --> 00:04:36,240
feasible results from standard

155
00:04:36,240 --> 00:04:37,919
assumptions what functionalities are

156
00:04:37,919 --> 00:04:39,759
easy to do or how can we sort of compare

157
00:04:39,759 --> 00:04:41,040
techniques across these different

158
00:04:41,040 --> 00:04:43,199
domains to that end we sort of try to

159
00:04:43,199 --> 00:04:44,720
make progress and trying to understand

160
00:04:44,720 --> 00:04:46,479
can we sort of unify all these results

161
00:04:46,479 --> 00:04:48,320
and visualize function encryption even

162
00:04:48,320 --> 00:04:50,160
these multi-user models in a single

163
00:04:50,160 --> 00:04:52,240
framework and that's basically our quest

164
00:04:52,240 --> 00:04:54,080
trying to unify and sort of forecast

165
00:04:54,080 --> 00:04:55,199
interesting functionalities in the

166
00:04:55,199 --> 00:04:57,440
multi-user environments and to that in

167
00:04:57,440 --> 00:04:59,840
this work we introduce the concept of

168
00:04:59,840 --> 00:05:01,600
multi-party functional encryption as a

169
00:05:01,600 --> 00:05:03,919
broad unifier over all these encryption

170
00:05:03,919 --> 00:05:05,520
functionalities we propose some

171
00:05:05,520 --> 00:05:06,960
interesting multi-user encryption

172
00:05:06,960 --> 00:05:08,560
functionalities which which had not been

173
00:05:08,560 --> 00:05:10,160
previously considered but seemed very

174
00:05:10,160 --> 00:05:11,680
meaningful and we also give new

175
00:05:11,680 --> 00:05:13,360
constructions from some standard from a

176
00:05:13,360 --> 00:05:15,440
lot of sun assumptions

177
00:05:15,440 --> 00:05:18,320
so uh just quickly before uh uh i'll

178
00:05:18,320 --> 00:05:20,000
just tell you how we actually formalize

179
00:05:20,000 --> 00:05:21,199
the notion of multi-party function

180
00:05:21,199 --> 00:05:23,280
prevention to give you some intuition so

181
00:05:23,280 --> 00:05:24,720
the point is that we will have sort of

182
00:05:24,720 --> 00:05:26,960
two classes of inputs and ciphertext and

183
00:05:26,960 --> 00:05:29,039
sort of uh in each secret key and each

184
00:05:29,039 --> 00:05:31,520
affix we encrypt or encode inputs and

185
00:05:31,520 --> 00:05:32,479
the point is that the decryption

186
00:05:32,479 --> 00:05:34,160
algorithm mistake is going to take us

187
00:05:34,160 --> 00:05:36,080
input a polynomial number of text and

188
00:05:36,080 --> 00:05:37,680
secret keys and the question would be

189
00:05:37,680 --> 00:05:38,960
how can we potentially the decryption

190
00:05:38,960 --> 00:05:40,479
algorithm how will it combine the

191
00:05:40,479 --> 00:05:41,680
algorithm there is no notion of

192
00:05:41,680 --> 00:05:44,080
functions existing anywhere so simply we

193
00:05:44,080 --> 00:05:45,759
say okay hey imagine that the scheme is

194
00:05:45,759 --> 00:05:47,520
associated with an aggregation function

195
00:05:47,520 --> 00:05:49,840
with the input class as well as

196
00:05:49,840 --> 00:05:50,960
with the ciphertext classes of the

197
00:05:50,960 --> 00:05:52,960
secret key plus and the point will be

198
00:05:52,960 --> 00:05:54,639
the aggregation functions are tied to

199
00:05:54,639 --> 00:05:56,400
the scheme and the decryption function

200
00:05:56,400 --> 00:05:57,600
is going to evaluate the following

201
00:05:57,600 --> 00:05:59,120
function it's going to aggregate the

202
00:05:59,120 --> 00:06:00,800
ciphertext first using the aggregation

203
00:06:00,800 --> 00:06:02,240
function it's going to aggregate the

204
00:06:02,240 --> 00:06:04,080
secret keys using c functions and then

205
00:06:04,080 --> 00:06:05,919
apply the universal circuit so trying to

206
00:06:05,919 --> 00:06:07,440
capture all possible functionality it

207
00:06:07,440 --> 00:06:08,800
doesn't matter if you're working the

208
00:06:08,800 --> 00:06:10,720
text policy key policy domain whether

209
00:06:10,720 --> 00:06:13,120
you have multiple inputs multiple keys

210
00:06:13,120 --> 00:06:14,479
whatever you should be able to sort of

211
00:06:14,479 --> 00:06:16,080
capture all these different notions

212
00:06:16,080 --> 00:06:18,319
under a single unified framework

213
00:06:18,319 --> 00:06:20,479
and so pictorially this is basically you

214
00:06:20,479 --> 00:06:22,479
apply you pass the inputs so the cyclic

215
00:06:22,479 --> 00:06:24,560
inputs to the aggregation function x the

216
00:06:24,560 --> 00:06:26,319
y inputs to the aggregation y and apply

217
00:06:26,319 --> 00:06:27,600
the universal circuit and that's

218
00:06:27,600 --> 00:06:28,800
basically equal to applying the

219
00:06:28,800 --> 00:06:30,720
decryption circuit on the encoded

220
00:06:30,720 --> 00:06:32,080
values

221
00:06:32,080 --> 00:06:33,919
and syntactically this basically means

222
00:06:33,919 --> 00:06:35,440
that the setup algorithm is going to

223
00:06:35,440 --> 00:06:37,919
take as input these circuits the which

224
00:06:37,919 --> 00:06:39,680
specify the particular scheme and now

225
00:06:39,680 --> 00:06:41,360
the setup algorithm can also be done in

226
00:06:41,360 --> 00:06:43,840
three modes a central mode and a local

227
00:06:43,840 --> 00:06:45,360
mode in interactive mode and generate

228
00:06:45,360 --> 00:06:47,120
these encryption keys and the idea is

229
00:06:47,120 --> 00:06:48,880
that the central node is going to

230
00:06:48,880 --> 00:06:50,720
dictate whether this setup is being done

231
00:06:50,720 --> 00:06:52,720
by a single trusted party a local mode

232
00:06:52,720 --> 00:06:53,440
is going to say okay it's a

233
00:06:53,440 --> 00:06:55,120
non-interactive thing done by everyone

234
00:06:55,120 --> 00:06:56,639
independently and interactive it could

235
00:06:56,639 --> 00:06:58,319
be a protocol between users so depending

236
00:06:58,319 --> 00:07:00,400
upon that you can appropriately capture

237
00:07:00,400 --> 00:07:02,960
all encryption functionalities and uh

238
00:07:02,960 --> 00:07:04,479
the security can also be intuitively

239
00:07:04,479 --> 00:07:06,000
captured by saying you cannot learn

240
00:07:06,000 --> 00:07:07,440
anything beyond what you can learn by

241
00:07:07,440 --> 00:07:09,039
running the decryption algorithm i'll

242
00:07:09,039 --> 00:07:11,039
sort of refer you uh the paper for more

243
00:07:11,039 --> 00:07:14,160
details but basically uh in sort of to

244
00:07:14,160 --> 00:07:15,759
supplement that you also sort of

245
00:07:15,759 --> 00:07:17,599
proposed some interesting new results

246
00:07:17,599 --> 00:07:20,319
such as we built a multi-authority

247
00:07:20,319 --> 00:07:22,000
attribute based in our product function

248
00:07:22,000 --> 00:07:23,919
encryption scheme so this is not a

249
00:07:23,919 --> 00:07:25,120
non-trivial combination of a

250
00:07:25,120 --> 00:07:26,639
multi-authority attribute disencryption

251
00:07:26,639 --> 00:07:27,919
scheme and an inner product function

252
00:07:27,919 --> 00:07:29,759
encryption scheme typically attributed

253
00:07:29,759 --> 00:07:31,120
based encryption is just like an all or

254
00:07:31,120 --> 00:07:32,560
nothing primitive and then product

255
00:07:32,560 --> 00:07:33,680
function encryption is like a functional

256
00:07:33,680 --> 00:07:35,440
encryption primitive trying to combine

257
00:07:35,440 --> 00:07:36,720
these things and also working in a

258
00:07:36,720 --> 00:07:38,000
decentralized model where we can

259
00:07:38,000 --> 00:07:39,599
actually have multiple authorities this

260
00:07:39,599 --> 00:07:40,960
was not previously studied and we were

261
00:07:40,960 --> 00:07:42,880
able to build new constructions for this

262
00:07:42,880 --> 00:07:44,879
in the uh using binding groups and we

263
00:07:44,879 --> 00:07:46,319
were able to also provide some other

264
00:07:46,319 --> 00:07:48,080
interesting results in the paper and i

265
00:07:48,080 --> 00:07:49,840
sort of lead you to sort of look at the

266
00:07:49,840 --> 00:07:51,520
paper for these interesting results but

267
00:07:51,520 --> 00:07:53,520
just trying to conclude so in this work

268
00:07:53,520 --> 00:07:55,360
we propose this notion of multi-party

269
00:07:55,360 --> 00:07:56,879
function encryption and our goal is just

270
00:07:56,879 --> 00:07:58,560
to understand function encryption the

271
00:07:58,560 --> 00:08:00,879
multi-user models and trying to compare

272
00:08:00,879 --> 00:08:02,319
different techniques and different ideas

273
00:08:02,319 --> 00:08:03,840
and trying to sort of juxtapose them so

274
00:08:03,840 --> 00:08:05,360
that we can uh build new interesting

275
00:08:05,360 --> 00:08:06,800
functionalities which should be feasible

276
00:08:06,800 --> 00:08:08,960
but have not been studied so far

277
00:08:08,960 --> 00:08:11,280
and uh we sort of this raises many

278
00:08:11,280 --> 00:08:12,879
fascinating open questions which we also

279
00:08:12,879 --> 00:08:14,720
had in the paper and this will build

280
00:08:14,720 --> 00:08:16,080
some interesting functionalities from

281
00:08:16,080 --> 00:08:19,599
fans options so thanks for your time

282
00:08:23,120 --> 00:08:26,440
any questions

283
00:08:27,919 --> 00:08:31,599
there appear to be no questions online

284
00:08:31,599 --> 00:08:33,919
um quick question so is there inherent

285
00:08:33,919 --> 00:08:35,839
possibilities if you instead of having

286
00:08:35,839 --> 00:08:37,760
aggregation of the

287
00:08:37,760 --> 00:08:39,279
the two pieces separately and then

288
00:08:39,279 --> 00:08:40,640
combined if you wanted to do something

289
00:08:40,640 --> 00:08:41,760
even more

290
00:08:41,760 --> 00:08:43,120
so the question

291
00:08:43,120 --> 00:08:44,720
is asking is that we had like this

292
00:08:44,720 --> 00:08:45,920
aggregation function working

293
00:08:45,920 --> 00:08:47,440
independently of the text and secret

294
00:08:47,440 --> 00:08:49,200
inputs and then applying the universal

295
00:08:49,200 --> 00:08:50,720
circuit but she's saying what if you

296
00:08:50,720 --> 00:08:51,920
sort of try to imagine that the

297
00:08:51,920 --> 00:08:53,360
ciphertext and secret keys are first

298
00:08:53,360 --> 00:08:54,720
aggregated together and then something

299
00:08:54,720 --> 00:08:57,440
else is happening uh all of those can be

300
00:08:57,440 --> 00:08:59,040
captured by this framework itself

301
00:08:59,040 --> 00:09:00,320
because you can imagine the application

302
00:09:00,320 --> 00:09:02,240
function can simply copy one of the

303
00:09:02,240 --> 00:09:04,000
inputs as part of the aggregate function

304
00:09:04,000 --> 00:09:05,440
and then you can apply something on top

305
00:09:05,440 --> 00:09:07,600
of it so that's why it's like it's going

306
00:09:07,600 --> 00:09:09,519
to capture also basically the idea is

307
00:09:09,519 --> 00:09:11,040
trying to capture everything and then

308
00:09:11,040 --> 00:09:12,320
trying to see can you come up with

309
00:09:12,320 --> 00:09:13,920
interesting functionalities which might

310
00:09:13,920 --> 00:09:15,360
be interesting for applications and then

311
00:09:15,360 --> 00:09:17,120
try to see whether we have techniques to

312
00:09:17,120 --> 00:09:18,080
actually build this critical

313
00:09:18,080 --> 00:09:20,839
functionality or not thanks for the

314
00:09:20,839 --> 00:09:25,040
question further questions

315
00:09:25,760 --> 00:09:29,959
okay let's thank yourself again

316
00:09:42,640 --> 00:09:45,640
so

317
00:09:58,959 --> 00:10:01,040
okay and the next presentation is about

318
00:10:01,040 --> 00:10:03,839
succinct lwe sampling random polynomials

319
00:10:03,839 --> 00:10:06,320
and obfuscation this is a work by vinod

320
00:10:06,320 --> 00:10:09,360
vacuum tonight willie quash daniel wicks

321
00:10:09,360 --> 00:10:11,839
and hotek we together with

322
00:10:11,839 --> 00:10:16,279
us and i will be giving the presentation

323
00:10:20,160 --> 00:10:21,680
i'll start by defining the notion of

324
00:10:21,680 --> 00:10:23,440
indistinguishability obfuscation we

325
00:10:23,440 --> 00:10:25,279
think of an io scheme as some randomized

326
00:10:25,279 --> 00:10:26,959
compiler that takes a circuit c and

327
00:10:26,959 --> 00:10:28,959
produces an obfuscation of that circuit

328
00:10:28,959 --> 00:10:30,480
uh we want that the obfuscation will

329
00:10:30,480 --> 00:10:31,760
compute the same function as the

330
00:10:31,760 --> 00:10:33,440
original circuit and also that for any

331
00:10:33,440 --> 00:10:35,120
two functional equivalent circuits i

332
00:10:35,120 --> 00:10:37,040
service the same truth table we have it

333
00:10:37,040 --> 00:10:38,720
that that their obfuscations are

334
00:10:38,720 --> 00:10:40,560
computationally indistinguishable

335
00:10:40,560 --> 00:10:42,240
we've seen in recent years many many

336
00:10:42,240 --> 00:10:44,320
applications of io leading us to believe

337
00:10:44,320 --> 00:10:45,519
that it might be some sort of central

338
00:10:45,519 --> 00:10:47,600
hub for cryptography in any case it

339
00:10:47,600 --> 00:10:49,120
become very important for us to

340
00:10:49,120 --> 00:10:50,560
understand exactly which assumptions are

341
00:10:50,560 --> 00:10:53,120
needed in order to build io

342
00:10:53,120 --> 00:10:54,640
currently we have some state-of-the-art

343
00:10:54,640 --> 00:10:56,320
ios schemes which are based on bi-linear

344
00:10:56,320 --> 00:10:58,320
maps in addition to other assumptions um

345
00:10:58,320 --> 00:11:00,240
these are not quantum secure also as i

346
00:11:00,240 --> 00:11:01,600
said we do want to understand exactly

347
00:11:01,600 --> 00:11:03,680
which assumptions are necessary uh which

348
00:11:03,680 --> 00:11:05,040
leads to another line of work on

349
00:11:05,040 --> 00:11:07,120
possibly post quantum secure i o uh

350
00:11:07,120 --> 00:11:09,920
based on lwb ish assumptions um there's

351
00:11:09,920 --> 00:11:11,680
initially some work uh that was up for

352
00:11:11,680 --> 00:11:12,959
here so you constructed without a proof

353
00:11:12,959 --> 00:11:15,040
of security more recently we've seen

354
00:11:15,040 --> 00:11:16,640
some works that do have security proofs

355
00:11:16,640 --> 00:11:18,240
but based on interactive and or

356
00:11:18,240 --> 00:11:20,720
non-falsifiable and particularly uh

357
00:11:20,720 --> 00:11:23,279
complicated lw like assumptions these

358
00:11:23,279 --> 00:11:24,959
assumptions are broken for specific

359
00:11:24,959 --> 00:11:26,880
implementations depending on the way

360
00:11:26,880 --> 00:11:28,640
that they're shown which is why we're

361
00:11:28,640 --> 00:11:30,240
basically motivated to try to clean up

362
00:11:30,240 --> 00:11:32,160
these assumptions as much as possible

363
00:11:32,160 --> 00:11:34,000
the point of this work is to try to base

364
00:11:34,000 --> 00:11:36,640
io on an lw like assumption that is

365
00:11:36,640 --> 00:11:38,640
non-interactive that is falsifiable and

366
00:11:38,640 --> 00:11:41,120
as simple as possible

367
00:11:41,120 --> 00:11:42,720
in our work we'll define a new primitive

368
00:11:42,720 --> 00:11:44,800
which we call a succinct lwd sampler

369
00:11:44,800 --> 00:11:46,640
this is a weaker security notion than

370
00:11:46,640 --> 00:11:49,279
the notion of ww21 of the oblivious lwd

371
00:11:49,279 --> 00:11:50,720
sampler

372
00:11:50,720 --> 00:11:52,160
we'll also show a local to global

373
00:11:52,160 --> 00:11:54,639
security amplification theorem this is

374
00:11:54,639 --> 00:11:55,760
our main theorem which shows that to

375
00:11:55,760 --> 00:11:57,360
protect arbitrary computation it's

376
00:11:57,360 --> 00:11:58,639
actually enough to check one in

377
00:11:58,639 --> 00:11:59,760
operation and i'll go into a little bit

378
00:11:59,760 --> 00:12:01,360
more detail about what this means later

379
00:12:01,360 --> 00:12:02,480
in the talk

380
00:12:02,480 --> 00:12:03,760
and lastly we showed him the

381
00:12:03,760 --> 00:12:06,000
construction of assisting lw sampler uh

382
00:12:06,000 --> 00:12:07,200
with the security based on random

383
00:12:07,200 --> 00:12:11,160
polynomials and we

384
00:12:20,079 --> 00:12:22,639
excuse me tcc i believe you have lost

385
00:12:22,639 --> 00:12:25,040
your internet connection um the speaker

386
00:12:25,040 --> 00:12:28,480
has frozen on our end

387
00:12:29,519 --> 00:12:31,040
thanks keith i thought i didn't know it

388
00:12:31,040 --> 00:12:33,279
was me or or was some you know on the

389
00:12:33,279 --> 00:12:36,000
far end i also wondered if it was me we

390
00:12:36,000 --> 00:12:39,839
have really high winds today

391
00:12:48,480 --> 00:12:50,160
just hang tight everybody hopefully

392
00:12:50,160 --> 00:12:53,800
we'll be back soon

393
00:13:15,680 --> 00:13:17,839
is the connection back

394
00:13:17,839 --> 00:13:21,279
yes it is

395
00:13:21,279 --> 00:13:22,000
okay

396
00:13:22,000 --> 00:13:23,839
so at a very high level we're going to

397
00:13:23,839 --> 00:13:25,680
encrypt the program with something more

398
00:13:25,680 --> 00:13:27,680
description please forgive me uh you'll

399
00:13:27,680 --> 00:13:29,279
you've lost your screen share so you're

400
00:13:29,279 --> 00:13:33,240
going to share screen again

401
00:13:44,720 --> 00:13:48,440
yes that's good

402
00:13:48,720 --> 00:13:51,440
uh then to evaluate the

403
00:13:51,440 --> 00:13:54,160
the program on uh to retrieve the truth

404
00:13:54,160 --> 00:13:54,959
table of the program we'll

405
00:13:54,959 --> 00:13:57,120
homomorphically compute um basically

406
00:13:57,120 --> 00:13:59,519
using fhe evaluation on the ciphertext

407
00:13:59,519 --> 00:14:01,360
um evaluating being the function f which

408
00:14:01,360 --> 00:14:03,600
takes some program and output value to

409
00:14:03,600 --> 00:14:04,959
program in all possible inputs and

410
00:14:04,959 --> 00:14:06,959
outputs of choose table

411
00:14:06,959 --> 00:14:08,720
lastly we'll just decrypt to recover the

412
00:14:08,720 --> 00:14:10,320
truth table of the function

413
00:14:10,320 --> 00:14:12,240
um how do we do this so one idea that

414
00:14:12,240 --> 00:14:13,680
seems good at first is to release the

415
00:14:13,680 --> 00:14:15,440
randomness that was used in the fh

416
00:14:15,440 --> 00:14:17,760
encryption of the truth table of high as

417
00:14:17,760 --> 00:14:19,120
opposed to revealing the secret key

418
00:14:19,120 --> 00:14:20,880
which is obviously not secure however

419
00:14:20,880 --> 00:14:23,440
this is also actually not secure um

420
00:14:23,440 --> 00:14:24,959
so much with all in a recent work you

421
00:14:24,959 --> 00:14:25,920
can actually

422
00:14:25,920 --> 00:14:27,760
retrieve uh

423
00:14:27,760 --> 00:14:30,399
you can if you look at the way that the

424
00:14:30,399 --> 00:14:32,079
basically you can retrieve the the

425
00:14:32,079 --> 00:14:33,600
original um things and learn something

426
00:14:33,600 --> 00:14:34,880
about the original function pi i'm

427
00:14:34,880 --> 00:14:36,160
solely from the randomness using this

428
00:14:36,160 --> 00:14:37,920
encryption

429
00:14:37,920 --> 00:14:39,440
uh to solve this problem we'll introduce

430
00:14:39,440 --> 00:14:41,040
our new notions succinct of the

431
00:14:41,040 --> 00:14:43,120
resampler um the idea behind this is

432
00:14:43,120 --> 00:14:44,560
intuitively just that we should be able

433
00:14:44,560 --> 00:14:47,360
to sample some short seed um and then

434
00:14:47,360 --> 00:14:49,519
later expand the seed using including

435
00:14:49,519 --> 00:14:52,560
using the crs um into a larger ld sample

436
00:14:52,560 --> 00:14:54,959
for some matrix a

437
00:14:54,959 --> 00:14:56,800
the the way that this solves our problem

438
00:14:56,800 --> 00:14:59,120
is that then we can now still using this

439
00:14:59,120 --> 00:15:02,079
regular uh fha encryption at first um

440
00:15:02,079 --> 00:15:04,000
again regular homomorphic evaluation to

441
00:15:04,000 --> 00:15:05,199
compute the encryption of the truth

442
00:15:05,199 --> 00:15:06,320
table of pi

443
00:15:06,320 --> 00:15:08,399
um but then to decrypt we'll include

444
00:15:08,399 --> 00:15:11,199
expanding the c to v uh to

445
00:15:11,199 --> 00:15:13,839
re-sample b star um and then we'll add

446
00:15:13,839 --> 00:15:16,320
in this lw sample b star um in order to

447
00:15:16,320 --> 00:15:18,560
mask the the randomness r pi which

448
00:15:18,560 --> 00:15:20,079
originally was what was the problem uh

449
00:15:20,079 --> 00:15:21,600
revealing our pi was not semantically

450
00:15:21,600 --> 00:15:23,519
secure um now we can mask it with some

451
00:15:23,519 --> 00:15:26,480
truly uniform s star um and so

452
00:15:26,480 --> 00:15:29,120
eventually we'll just get out um pi uh

453
00:15:29,120 --> 00:15:31,120
the truth table for pi um with the the

454
00:15:31,120 --> 00:15:34,160
error e pi and plus e star which will be

455
00:15:34,160 --> 00:15:35,759
basically the security notion that we

456
00:15:35,759 --> 00:15:37,440
need later on e-star is that it's big

457
00:15:37,440 --> 00:15:39,360
enough to flood

458
00:15:39,360 --> 00:15:40,959
and then finally finished around to

459
00:15:40,959 --> 00:15:44,000
recover the truth table of the program

460
00:15:44,000 --> 00:15:45,440
uh let's think about exactly what we

461
00:15:45,440 --> 00:15:48,320
need of the security notion um so

462
00:15:48,320 --> 00:15:50,000
starting from ww and their oblivious

463
00:15:50,000 --> 00:15:52,000
elite sampler they require that given

464
00:15:52,000 --> 00:15:54,399
the c for b star and the matrix a

465
00:15:54,399 --> 00:15:55,920
b star should look indistinguishable

466
00:15:55,920 --> 00:15:58,160
from fresh algae samples which by fresh

467
00:15:58,160 --> 00:15:59,680
alduis samples would mean where s star

468
00:15:59,680 --> 00:16:01,360
is truly random and these stars gaussian

469
00:16:01,360 --> 00:16:03,279
like you would want um when sampling

470
00:16:03,279 --> 00:16:05,120
an lw sample for a

471
00:16:05,120 --> 00:16:07,199
however this requires a simulator

472
00:16:07,199 --> 00:16:08,800
and like i said before

473
00:16:08,800 --> 00:16:10,320
specific implementations um of the

474
00:16:10,320 --> 00:16:12,320
homomorphic description circuit and so

475
00:16:12,320 --> 00:16:13,839
that's why we're going to look at a

476
00:16:13,839 --> 00:16:15,519
different security notion um what we

477
00:16:15,519 --> 00:16:17,040
really need is just that e-star is a

478
00:16:17,040 --> 00:16:19,360
good flooding distribution um to

479
00:16:19,360 --> 00:16:21,360
quantify this more formally this means

480
00:16:21,360 --> 00:16:22,800
that for all functions and inputs such

481
00:16:22,800 --> 00:16:24,240
as the output of the function on both

482
00:16:24,240 --> 00:16:26,639
inputs is the same we want that it's

483
00:16:26,639 --> 00:16:28,560
indistinguishable even given the c for b

484
00:16:28,560 --> 00:16:31,279
star encryption of the input and then so

485
00:16:31,279 --> 00:16:34,959
here we can go so e sub fx 0x1 is the

486
00:16:34,959 --> 00:16:36,880
error that results from homomorphically

487
00:16:36,880 --> 00:16:39,600
evaluating f on the encryption of x and

488
00:16:39,600 --> 00:16:41,759
so we want that e star is enough to

489
00:16:41,759 --> 00:16:42,560
flood

490
00:16:42,560 --> 00:16:44,560
the error stream here however we're

491
00:16:44,560 --> 00:16:45,920
still not really happy with the security

492
00:16:45,920 --> 00:16:47,519
notion because it quantifies overall f

493
00:16:47,519 --> 00:16:49,519
and it's not falsifiable

494
00:16:49,519 --> 00:16:51,040
so the main theorem as i mentioned in

495
00:16:51,040 --> 00:16:53,120
our paper is a local to global theorem

496
00:16:53,120 --> 00:16:54,639
which shows that it suffices to protect

497
00:16:54,639 --> 00:16:56,959
a single and this means that we can just

498
00:16:56,959 --> 00:16:59,040
look at the case where the f that we're

499
00:16:59,040 --> 00:17:00,320
considering is n

500
00:17:00,320 --> 00:17:02,320
um and the inputs are zero one and zero

501
00:17:02,320 --> 00:17:03,279
zero

502
00:17:03,279 --> 00:17:04,559
so again these are the resulting errors

503
00:17:04,559 --> 00:17:06,079
from homomorphically evaluating enemy

504
00:17:06,079 --> 00:17:07,280
ciphertexts

505
00:17:07,280 --> 00:17:09,119
um we show that we can upgrade this to

506
00:17:09,119 --> 00:17:10,400
strong security which is what i

507
00:17:10,400 --> 00:17:11,679
mentioned before

508
00:17:11,679 --> 00:17:13,280
the trick that we use here is implicitly

509
00:17:13,280 --> 00:17:16,400
used in ww but here we abstract it out

510
00:17:16,400 --> 00:17:17,839
and show a hybrid argument to actually

511
00:17:17,839 --> 00:17:19,839
upgrade um security for a single and to

512
00:17:19,839 --> 00:17:21,919
fully strong security

513
00:17:21,919 --> 00:17:23,839
uh so the actual construction of our

514
00:17:23,839 --> 00:17:25,359
scheme as i mentioned relies on random

515
00:17:25,359 --> 00:17:27,280
polynomials um the big question that we

516
00:17:27,280 --> 00:17:28,960
have is how do we generate e-star from a

517
00:17:28,960 --> 00:17:30,320
sync description to still have enough

518
00:17:30,320 --> 00:17:32,799
entropy to be able to flood we have the

519
00:17:32,799 --> 00:17:34,400
idea to use random polynomials that are

520
00:17:34,400 --> 00:17:36,559
seemingly similar to jlmf19 if you're

521
00:17:36,559 --> 00:17:38,000
familiar with that work however our

522
00:17:38,000 --> 00:17:39,280
parameter settings are actually quite

523
00:17:39,280 --> 00:17:41,039
different which makes um

524
00:17:41,039 --> 00:17:43,120
our uses random polynomials uh different

525
00:17:43,120 --> 00:17:45,280
here intuitively speaking we just want

526
00:17:45,280 --> 00:17:47,600
that you know the tensor of some smaller

527
00:17:47,600 --> 00:17:50,559
matrices e uh one through d um but if we

528
00:17:50,559 --> 00:17:51,840
take that to the e star we should hope

529
00:17:51,840 --> 00:17:53,520
that this looks pseudorandom how does

530
00:17:53,520 --> 00:17:55,120
this actually work in our construction

531
00:17:55,120 --> 00:17:57,120
um i'll just briefly give the idea that

532
00:17:57,120 --> 00:17:59,200
we will generate more lw samples by

533
00:17:59,200 --> 00:18:01,600
tensoring so we think about the c for b

534
00:18:01,600 --> 00:18:03,440
star being two

535
00:18:03,440 --> 00:18:05,280
matrices um

536
00:18:05,280 --> 00:18:07,679
uh basically uh lw samples for smaller

537
00:18:07,679 --> 00:18:10,080
matrices a1 a2 this is a small example

538
00:18:10,080 --> 00:18:12,480
for d equals two um if we tensor these

539
00:18:12,480 --> 00:18:14,240
together we can rearrange change the

540
00:18:14,240 --> 00:18:16,400
mixed product property um

541
00:18:16,400 --> 00:18:17,919
so then basically have some a which

542
00:18:17,919 --> 00:18:20,880
depends only on the ai's and um some s

543
00:18:20,880 --> 00:18:22,960
star which depends on both the si the

544
00:18:22,960 --> 00:18:25,520
bis and the eis and finally our e star

545
00:18:25,520 --> 00:18:26,960
term will depend just on the e i from

546
00:18:26,960 --> 00:18:28,480
the adventure of these um this is not

547
00:18:28,480 --> 00:18:29,520
dropping away a lot we're actually

548
00:18:29,520 --> 00:18:30,880
multiplying on either side by large

549
00:18:30,880 --> 00:18:32,480
matrices that we keep in the crs and

550
00:18:32,480 --> 00:18:34,160
also doing some re-randomizing but this

551
00:18:34,160 --> 00:18:35,600
is a little bit of intuition for how

552
00:18:35,600 --> 00:18:37,039
we're actually able to construct this

553
00:18:37,039 --> 00:18:39,200
candidate construction um where the

554
00:18:39,200 --> 00:18:40,640
terms of e-star are going to be random

555
00:18:40,640 --> 00:18:43,840
polynomials in the terms of ei

556
00:18:43,840 --> 00:18:46,240
thank you

557
00:18:51,039 --> 00:18:54,039
questions

558
00:18:57,980 --> 00:19:01,919
[Music]

559
00:19:01,919 --> 00:19:03,520
apologies for the delay there do not

560
00:19:03,520 --> 00:19:07,720
appear to be any questions online

561
00:19:18,559 --> 00:19:20,160
but would it make sense to sort of start

562
00:19:20,160 --> 00:19:21,840
with simple functions like these

563
00:19:21,840 --> 00:19:25,039
function classes like

564
00:19:34,240 --> 00:19:35,280
that's definitely something we're

565
00:19:35,280 --> 00:19:36,720
looking at in terms of future directions

566
00:19:36,720 --> 00:19:37,600
especially because you know there's a

567
00:19:37,600 --> 00:19:38,960
lot of applications for i o for

568
00:19:38,960 --> 00:19:40,480
restricted function classes things like

569
00:19:40,480 --> 00:19:42,160
quantum money and so on and so forth so

570
00:19:42,160 --> 00:19:43,280
that's definitely something that we're

571
00:19:43,280 --> 00:19:44,880
looking to if we can like simplify these

572
00:19:44,880 --> 00:19:46,000
yeah in

573
00:19:46,000 --> 00:19:47,520
the case of just like a simpler function

574
00:19:47,520 --> 00:19:49,360
app instead of just all programs

575
00:19:49,360 --> 00:19:51,440
um but we haven't done that we're still

576
00:19:51,440 --> 00:19:53,840
like working on that so that means of

577
00:19:53,840 --> 00:19:55,200
changing the distribution of how we sort

578
00:19:55,200 --> 00:19:58,240
of sample these uh

579
00:19:59,520 --> 00:20:00,960
so it's more than i think we would hope

580
00:20:00,960 --> 00:20:02,720
to be able to actually prove that this

581
00:20:02,720 --> 00:20:04,400
uh we would be able to like simplify the

582
00:20:04,400 --> 00:20:05,919
assumption more given with the same

583
00:20:05,919 --> 00:20:07,360
construction be able to simplify the

584
00:20:07,360 --> 00:20:08,880
assumption that we're making um based on

585
00:20:08,880 --> 00:20:10,480
the fact that we're just you know only

586
00:20:10,480 --> 00:20:11,840
doing observations for subjective

587
00:20:11,840 --> 00:20:13,520
function class we'd be able to actually

588
00:20:13,520 --> 00:20:14,799
do like a little bit more work to

589
00:20:14,799 --> 00:20:16,159
simplify the assumption more and maybe

590
00:20:16,159 --> 00:20:18,320
make it more like um like well studying

591
00:20:18,320 --> 00:20:19,840
assumptions rather than something that's

592
00:20:19,840 --> 00:20:22,159
you know still like quite it's it's not

593
00:20:22,159 --> 00:20:23,760
as ugly as it has been before but we

594
00:20:23,760 --> 00:20:25,280
still already know like dealing with

595
00:20:25,280 --> 00:20:26,640
some polynomials that we're not as

596
00:20:26,640 --> 00:20:29,840
familiar with in the mathematics

597
00:20:29,840 --> 00:20:32,000
and i gather that was a rather in-depth

598
00:20:32,000 --> 00:20:33,440
question but if you could give those of

599
00:20:33,440 --> 00:20:35,840
us uh online a little bit of context for

600
00:20:35,840 --> 00:20:37,760
it we i think had a little bit of

601
00:20:37,760 --> 00:20:39,760
trouble hearing the question

602
00:20:39,760 --> 00:20:41,280
oh

603
00:20:41,280 --> 00:20:43,919
can we repeat the question

604
00:20:43,919 --> 00:20:46,919
um

605
00:20:48,080 --> 00:20:49,919
so i guess the question i was just the

606
00:20:49,919 --> 00:20:51,360
question was basically trying to

607
00:20:51,360 --> 00:20:54,240
understand uh this sort of uh

608
00:20:54,240 --> 00:20:56,159
assumption is about if you want to prove

609
00:20:56,159 --> 00:20:58,000
security of the full obfuscation scheme

610
00:20:58,000 --> 00:20:59,200
but if you're sort of interested in the

611
00:20:59,200 --> 00:21:00,880
obfuscation for a very restricted class

612
00:21:00,880 --> 00:21:02,720
for example you already know from lwe

613
00:21:02,720 --> 00:21:04,559
logical application point obfuscation

614
00:21:04,559 --> 00:21:05,919
then how does this assumption can be

615
00:21:05,919 --> 00:21:07,760
simplified and what hope is there to

616
00:21:07,760 --> 00:21:09,120
actually use this framework to prove

617
00:21:09,120 --> 00:21:10,320
security of

618
00:21:10,320 --> 00:21:12,080
uh obfuscation for those specific

619
00:21:12,080 --> 00:21:13,600
function classes and whether this

620
00:21:13,600 --> 00:21:15,280
framework this idea of flooding could be

621
00:21:15,280 --> 00:21:17,200
used to put security in that case i

622
00:21:17,200 --> 00:21:20,080
think that's what really sort of uh

623
00:21:20,080 --> 00:21:23,439
fear elaborating on

624
00:21:24,960 --> 00:21:28,480
right any further questions

625
00:21:28,799 --> 00:21:32,918
matt let's thank the speaker again

626
00:21:42,150 --> 00:21:44,240
[Music]

627
00:21:44,240 --> 00:21:47,240
okay

628
00:21:48,210 --> 00:21:51,359
[Music]

629
00:22:03,679 --> 00:22:06,559
excellent okay the next talk will be abe

630
00:22:06,559 --> 00:22:09,840
for dfa from lwe

631
00:22:09,840 --> 00:22:13,280
against bounded collusion

632
00:22:13,280 --> 00:22:16,000
this is worked by hotend

633
00:22:16,000 --> 00:22:18,080
we will be giving the presentation

634
00:22:18,080 --> 00:22:20,240
thanks to that um let me just make sure

635
00:22:20,240 --> 00:22:23,600
this works oops

636
00:22:24,880 --> 00:22:27,600
okay great all right so um right so let

637
00:22:27,600 --> 00:22:29,360
me start by uh talking about abe

638
00:22:29,360 --> 00:22:31,120
actually based encryption

639
00:22:31,120 --> 00:22:32,880
so basic encryption you have a

640
00:22:32,880 --> 00:22:34,480
ciphertext is associated with the

641
00:22:34,480 --> 00:22:35,840
attribute x

642
00:22:35,840 --> 00:22:38,159
and a message mu and secret keys

643
00:22:38,159 --> 00:22:40,400
associated with functions and the basic

644
00:22:40,400 --> 00:22:42,240
correctness requirement is that you can

645
00:22:42,240 --> 00:22:44,960
decrypt and recover the message mean

646
00:22:44,960 --> 00:22:47,120
whenever f of x is equal to one

647
00:22:47,120 --> 00:22:49,679
and um security says that if f of x is

648
00:22:49,679 --> 00:22:51,280
zero the message neo should be

649
00:22:51,280 --> 00:22:53,360
maintained and this should hold even in

650
00:22:53,360 --> 00:22:55,120
the presence of collusions where the

651
00:22:55,120 --> 00:22:57,039
adversary may be able to get hold of

652
00:22:57,039 --> 00:22:58,480
multiple secret keys for different

653
00:22:58,480 --> 00:23:00,799
functions as long as they all correspond

654
00:23:00,799 --> 00:23:02,880
to uh zero

655
00:23:02,880 --> 00:23:04,799
all right so the main result of this

656
00:23:04,799 --> 00:23:07,120
work is in the title a new attribute

657
00:23:07,120 --> 00:23:09,200
encryption scheme for dfa's

658
00:23:09,200 --> 00:23:11,600
deterministic finite automaton from the

659
00:23:11,600 --> 00:23:14,719
uh learning references

660
00:23:15,039 --> 00:23:17,679
right so the uh our construction is new

661
00:23:17,679 --> 00:23:19,520
and says uh it's somewhat different from

662
00:23:19,520 --> 00:23:21,440
prior constructions

663
00:23:21,440 --> 00:23:24,159
in that it's actually inspired by

664
00:23:24,159 --> 00:23:25,679
pairing-based

665
00:23:25,679 --> 00:23:27,679
abe skins for the fa

666
00:23:27,679 --> 00:23:29,840
and compared to previous algebra ebay

667
00:23:29,840 --> 00:23:31,679
schemes such as simpler and algebraic

668
00:23:31,679 --> 00:23:35,360
and avoids the use of av for circuits

669
00:23:35,360 --> 00:23:38,240
right so um right in particular uh this

670
00:23:38,240 --> 00:23:39,679
is the parameters that we our

671
00:23:39,679 --> 00:23:41,440
construction achieves so the scheme is

672
00:23:41,440 --> 00:23:42,880
actually for the setting of our boundary

673
00:23:42,880 --> 00:23:44,799
conditions so there's an a prior rebound

674
00:23:44,799 --> 00:23:46,159
beyond the number of collusions number

675
00:23:46,159 --> 00:23:48,159
secret keys we can see these are the

676
00:23:48,159 --> 00:23:50,480
parameters that which are our ski

677
00:23:50,480 --> 00:23:52,880
machines and the thing to bear in mind

678
00:23:52,880 --> 00:23:54,799
is that how it compares to our prior

679
00:23:54,799 --> 00:23:57,120
construction so we improve on the cyber

680
00:23:57,120 --> 00:23:59,120
text size so we have a better dependency

681
00:23:59,120 --> 00:24:00,799
on the length attribute and the

682
00:24:00,799 --> 00:24:02,640
collision size the secret key size

683
00:24:02,640 --> 00:24:04,400
remains the same and then we get

684
00:24:04,400 --> 00:24:06,480
qualitatively quantificatively better

685
00:24:06,480 --> 00:24:08,159
hardness assumptions in that our

686
00:24:08,159 --> 00:24:10,960
construction relies only on a slightly

687
00:24:10,960 --> 00:24:13,120
superpolynomial uh modulus knowledge

688
00:24:13,120 --> 00:24:15,279
ratio for lwe as opposed to a

689
00:24:15,279 --> 00:24:18,279
quasi-polynomial

690
00:24:19,360 --> 00:24:20,880
and what's so nice here i think in the

691
00:24:20,880 --> 00:24:22,720
construction it's along the way we

692
00:24:22,720 --> 00:24:24,960
introduced a new lattice tractor

693
00:24:24,960 --> 00:24:27,039
and finally our construction also

694
00:24:27,039 --> 00:24:29,679
exercised naturally to give us a to the

695
00:24:29,679 --> 00:24:31,520
best of my knowledge the first candidate

696
00:24:31,520 --> 00:24:34,720
for a post quantum ape for dfa uh for

697
00:24:34,720 --> 00:24:36,960
our mother college

698
00:24:36,960 --> 00:24:38,159
so for this talk i'm going to

699
00:24:38,159 --> 00:24:39,840
essentially going to only focus on the

700
00:24:39,840 --> 00:24:41,760
first two bullets so let me give you a

701
00:24:41,760 --> 00:24:44,559
quick sense of how escape looks like

702
00:24:44,559 --> 00:24:46,240
so all right so we're going to focus on

703
00:24:46,240 --> 00:24:48,720
our dfa for the binary alphabet switch

704
00:24:48,720 --> 00:24:52,000
once the input is a lb string okay so

705
00:24:52,000 --> 00:24:54,400
the input x so that's the attribute also

706
00:24:54,400 --> 00:24:55,919
the input of the f a

707
00:24:55,919 --> 00:24:58,480
and now we are going to specify dfa by a

708
00:24:58,480 --> 00:25:01,200
pair of transition matrices uh so if q

709
00:25:01,200 --> 00:25:03,200
is the number of sigma dfa then the

710
00:25:03,200 --> 00:25:05,440
transition matrix is just a q by two

711
00:25:05,440 --> 00:25:08,159
matrix one for the alphabet zero and one

712
00:25:08,159 --> 00:25:09,200
one

713
00:25:09,200 --> 00:25:11,360
all right so uh our second algorithm is

714
00:25:11,360 --> 00:25:12,720
going to generate a pair of all the

715
00:25:12,720 --> 00:25:13,520
video

716
00:25:13,520 --> 00:25:16,240
a0 and a1 uh it's going to be double the

717
00:25:16,240 --> 00:25:17,520
height of where you are

718
00:25:17,520 --> 00:25:19,840
images

719
00:25:20,320 --> 00:25:22,240
uh basically when you encrypt you're

720
00:25:22,240 --> 00:25:23,760
going to pick a magnet out of the

721
00:25:23,760 --> 00:25:25,679
sequence basically one out of three

722
00:25:25,679 --> 00:25:28,559
secret for every bit of the input x

723
00:25:28,559 --> 00:25:31,760
uh key generation were big uh

724
00:25:31,760 --> 00:25:32,720
q

725
00:25:32,720 --> 00:25:35,600
vectors one for uh one vector for every

726
00:25:35,600 --> 00:25:37,200
state in the dfa

727
00:25:37,200 --> 00:25:39,120
so the basic decryption invariant is

728
00:25:39,120 --> 00:25:42,559
going to be the case that uh for every i

729
00:25:42,559 --> 00:25:44,480
if uh after reading the first eye this

730
00:25:44,480 --> 00:25:46,799
is the input you reach the state u sub i

731
00:25:46,799 --> 00:25:48,159
you're going to be able to compute an

732
00:25:48,159 --> 00:25:51,360
approximation of s of i times g sub i oh

733
00:25:51,360 --> 00:25:53,200
sorry these two uh

734
00:25:53,200 --> 00:25:54,400
uh

735
00:25:54,400 --> 00:25:56,960
so the states called the the d state the

736
00:25:56,960 --> 00:25:58,960
d vector is going to state ui and then

737
00:25:58,960 --> 00:25:59,919
the uh

738
00:25:59,919 --> 00:26:03,520
the uh the i secret uh correspondingly

739
00:26:03,520 --> 00:26:04,640
and the way we'll achieve this in

740
00:26:04,640 --> 00:26:05,840
variance is that we're going to

741
00:26:05,840 --> 00:26:07,120
essentially only just compute the

742
00:26:07,120 --> 00:26:08,880
subjective differences between these

743
00:26:08,880 --> 00:26:10,960
values and then you can just essentially

744
00:26:10,960 --> 00:26:13,200
do a telescoping stuff right so that's

745
00:26:13,200 --> 00:26:15,039
basically what we're going to do and to

746
00:26:15,039 --> 00:26:16,480
compute this successive difference what

747
00:26:16,480 --> 00:26:17,520
we're going to do is that in the

748
00:26:17,520 --> 00:26:19,679
ciphertext we're going to publish the lw

749
00:26:19,679 --> 00:26:21,679
sample so here the squiggly underline

750
00:26:21,679 --> 00:26:24,799
corresponds to adding noise

751
00:26:25,600 --> 00:26:27,919
where the secret is the concatenation of

752
00:26:27,919 --> 00:26:29,919
s of i minus one and s

753
00:26:29,919 --> 00:26:32,159
all right so this this explains why our

754
00:26:32,159 --> 00:26:34,159
the height of our matrix is to n

755
00:26:34,159 --> 00:26:35,760
and in the secret key we're going to

756
00:26:35,760 --> 00:26:38,080
give our short gaussian vectors so that

757
00:26:38,080 --> 00:26:40,000
the product of this algebraic sample and

758
00:26:40,000 --> 00:26:42,400
destroy gaussian vectors um is this

759
00:26:42,400 --> 00:26:45,120
successive difference

760
00:26:45,120 --> 00:26:46,480
so this is basically what our scheme

761
00:26:46,480 --> 00:26:48,400
looks like now in the key generation

762
00:26:48,400 --> 00:26:49,760
when we generate a secret key we're not

763
00:26:49,760 --> 00:26:51,679
going to know what use is going to be so

764
00:26:51,679 --> 00:26:53,039
we're going to give out this short

765
00:26:53,039 --> 00:26:54,799
nausea vectors for all possible use of

766
00:26:54,799 --> 00:26:56,880
ice which can be described similarly by

767
00:26:56,880 --> 00:26:58,559
this expression and we actually don't

768
00:26:58,559 --> 00:27:00,159
know what x of r is going to be so we're

769
00:27:00,159 --> 00:27:02,320
going to give our discussion vectors for

770
00:27:02,320 --> 00:27:04,320
every possible x right so for zero and

771
00:27:04,320 --> 00:27:06,159
for one so this is basically what our

772
00:27:06,159 --> 00:27:08,799
scheme looks like um ignoring any point

773
00:27:08,799 --> 00:27:10,799
conditions of how you do the

774
00:27:10,799 --> 00:27:12,640
initialization factor and how you mask

775
00:27:12,640 --> 00:27:15,279
the message right so uh right so what

776
00:27:15,279 --> 00:27:17,039
does the security look like so basically

777
00:27:17,039 --> 00:27:19,600
now security proof we're going to show

778
00:27:19,600 --> 00:27:21,360
that this algorithm samples are

779
00:27:21,360 --> 00:27:23,279
pseudo-random even given these short

780
00:27:23,279 --> 00:27:25,200
gaussian vectors

781
00:27:25,200 --> 00:27:27,440
okay so to do this uh first we're going

782
00:27:27,440 --> 00:27:30,320
to expand the lw sample so uh we're

783
00:27:30,320 --> 00:27:31,840
going to use uh

784
00:27:31,840 --> 00:27:34,480
baba hey to denote the top half of the

785
00:27:34,480 --> 00:27:37,039
matrix a and underline a to denote the

786
00:27:37,039 --> 00:27:39,520
bottom part of the matrix a then this

787
00:27:39,520 --> 00:27:41,279
algebraic sample can be written as

788
00:27:41,279 --> 00:27:42,960
essentially the difference of the b

789
00:27:42,960 --> 00:27:44,240
cells

790
00:27:44,240 --> 00:27:45,520
all right now i want to show that the

791
00:27:45,520 --> 00:27:47,120
difference of these two lw samples is

792
00:27:47,120 --> 00:27:49,200
pseudorandom it suffices basically to

793
00:27:49,200 --> 00:27:50,880
show that the first term in this

794
00:27:50,880 --> 00:27:53,120
difference is random so it boils down to

795
00:27:53,120 --> 00:27:54,159
showing the

796
00:27:54,159 --> 00:27:55,440
following lambda which we're going to

797
00:27:55,440 --> 00:27:57,200
show from the out of the assumption

798
00:27:57,200 --> 00:28:00,480
namely that if you have this matrix a

799
00:28:00,480 --> 00:28:02,240
of dimensions to n times m if you're

800
00:28:02,240 --> 00:28:03,679
going to look at the top half of a which

801
00:28:03,679 --> 00:28:06,399
we call a over line if we take uh s

802
00:28:06,399 --> 00:28:08,080
times the top part of a is going to be

803
00:28:08,080 --> 00:28:10,960
pseudo-random even given an oracle

804
00:28:10,960 --> 00:28:13,039
that's uh given the matrix n computes

805
00:28:13,039 --> 00:28:15,120
this gaussian three images for a random

806
00:28:15,120 --> 00:28:16,480
matrix

807
00:28:16,480 --> 00:28:18,000
okay so this is roughly what we're going

808
00:28:18,000 --> 00:28:19,919
to show from the lw

809
00:28:19,919 --> 00:28:22,000
all right i'm going to actually show our

810
00:28:22,000 --> 00:28:23,679
proof gives you something stronger we're

811
00:28:23,679 --> 00:28:26,240
actually able to handle an oracle that

812
00:28:26,240 --> 00:28:28,559
looks just like a matrix m but also at

813
00:28:28,559 --> 00:28:30,720
the additional matrix c that's like an

814
00:28:30,720 --> 00:28:32,799
offset matrix where so that the bottom

815
00:28:32,799 --> 00:28:34,159
half of the pre-image is going to be

816
00:28:34,159 --> 00:28:35,200
enhanced

817
00:28:35,200 --> 00:28:36,559
and this is going to be the this is

818
00:28:36,559 --> 00:28:38,399
actually a generalization of the

819
00:28:38,399 --> 00:28:40,640
previous uh

820
00:28:40,640 --> 00:28:44,640
computational lemma or target something

821
00:28:44,640 --> 00:28:46,799
about some fireworks which corresponds

822
00:28:46,799 --> 00:28:48,880
to the special case when the m equals

823
00:28:48,880 --> 00:28:51,279
zero right so the main complication in

824
00:28:51,279 --> 00:28:53,520
our setting is the fact that this bottom

825
00:28:53,520 --> 00:28:55,279
house the pre-image could depend on the

826
00:28:55,279 --> 00:28:57,440
top half of the bridge

827
00:28:57,440 --> 00:29:00,080
all right and the pro basically uh to

828
00:29:00,080 --> 00:29:01,919
prove this statement uh we're going to

829
00:29:01,919 --> 00:29:03,600
introduce a new notion of a half trap

830
00:29:03,600 --> 00:29:06,240
door by lwd so a half trap number l2p is

831
00:29:06,240 --> 00:29:08,480
actually a low normal matrix such as a

832
00:29:08,480 --> 00:29:11,440
times this trapdoor matrix is a 0 on top

833
00:29:11,440 --> 00:29:14,080
set on top of the schedule matrix okay

834
00:29:14,080 --> 00:29:15,600
and basically the

835
00:29:15,600 --> 00:29:17,520
the key nominating the proof likes to

836
00:29:17,520 --> 00:29:19,600
ensure that given this tough trap door

837
00:29:19,600 --> 00:29:21,440
you can simulate

838
00:29:21,440 --> 00:29:23,760
so we would give a new sampling a word

839
00:29:23,760 --> 00:29:25,279
and the way this sampling algorithm

840
00:29:25,279 --> 00:29:27,600
works basically in two steps first we

841
00:29:27,600 --> 00:29:30,880
show how to sample a related uh

842
00:29:30,880 --> 00:29:33,360
distribution where instead of d times m

843
00:29:33,360 --> 00:29:35,679
at the bottom you have n times d

844
00:29:35,679 --> 00:29:37,840
right this distribution turns out not to

845
00:29:37,840 --> 00:29:39,840
be too hard to do if you sort of know

846
00:29:39,840 --> 00:29:41,520
this is your goal in mind then it

847
00:29:41,520 --> 00:29:43,440
basically follows

848
00:29:43,440 --> 00:29:45,760
more or less than the lw technique so

849
00:29:45,760 --> 00:29:48,480
let's keep this part uh and then the uh

850
00:29:48,480 --> 00:29:50,880
the second step uh lies instead of uh

851
00:29:50,880 --> 00:29:52,960
sort of bridging this gap between

852
00:29:52,960 --> 00:29:55,600
m times d and d times m and the way we

853
00:29:55,600 --> 00:29:57,760
do this is we use this vectorization

854
00:29:57,760 --> 00:30:00,000
operator from uh

855
00:30:00,000 --> 00:30:02,159
from our linear algebra that essentially

856
00:30:02,159 --> 00:30:04,960
allows us to switch the

857
00:30:04,960 --> 00:30:06,880
the order of multiplication from d times

858
00:30:06,880 --> 00:30:08,960
m to l n times c and then we can reduce

859
00:30:08,960 --> 00:30:11,360
to the previous case

860
00:30:11,360 --> 00:30:12,880
all right so let me now summarize the

861
00:30:12,880 --> 00:30:15,039
main result of this look we get a new

862
00:30:15,039 --> 00:30:17,760
abe from dfa from lwe with improved

863
00:30:17,760 --> 00:30:19,520
parameters along the way we have this

864
00:30:19,520 --> 00:30:23,039
new half triple idea and we

865
00:30:24,720 --> 00:30:27,600
so couple open problems one is uh we'll

866
00:30:27,600 --> 00:30:29,760
do a prep analysis of our new candidate

867
00:30:29,760 --> 00:30:32,000
for embodied collusion that'll be nice

868
00:30:32,000 --> 00:30:33,679
another as you see

869
00:30:33,679 --> 00:30:36,480
all techniques can be extended to give a

870
00:30:36,480 --> 00:30:38,960
similar construction

871
00:30:38,960 --> 00:30:41,279
thank you

872
00:30:45,520 --> 00:30:48,520
questions

873
00:30:49,840 --> 00:30:54,520
there appear to be no questions online

874
00:31:05,919 --> 00:31:07,519
can you say something about like how

875
00:31:07,519 --> 00:31:08,880
much more complicated do you think it

876
00:31:08,880 --> 00:31:10,720
will be to extend the touring machines

877
00:31:10,720 --> 00:31:12,720
how how much complicated it would be to

878
00:31:12,720 --> 00:31:13,919
get into your machines right so the

879
00:31:13,919 --> 00:31:15,360
question is how much complicated how

880
00:31:15,360 --> 00:31:16,640
much more complicated it would be to get

881
00:31:16,640 --> 00:31:19,120
to your machines um so it depends so

882
00:31:19,120 --> 00:31:21,279
basically if you have a boundary space

883
00:31:21,279 --> 00:31:23,519
turing machines then i think it's not so

884
00:31:23,519 --> 00:31:26,159
hard because you can basically um if you

885
00:31:26,159 --> 00:31:27,679
have boundary spectrum machine unlock

886
00:31:27,679 --> 00:31:29,919
special machines and you allow your

887
00:31:29,919 --> 00:31:31,600
cypher text size

888
00:31:31,600 --> 00:31:33,279
in this space and that's a little bit

889
00:31:33,279 --> 00:31:35,039
easier because you can essentially

890
00:31:35,039 --> 00:31:38,320
enumerate overall space configuration it

891
00:31:38,320 --> 00:31:40,559
sort of looks like sticks in the dfa so

892
00:31:40,559 --> 00:31:43,200
the hardest setting is sort of to get uh

893
00:31:43,200 --> 00:31:45,760
material machines for uh you know bound

894
00:31:45,760 --> 00:31:47,200
to space but with a point of view

895
00:31:47,200 --> 00:31:49,760
dependency on the space requirements and

896
00:31:49,760 --> 00:31:52,159
uh this seems a bit hard from uh

897
00:31:52,159 --> 00:31:53,679
with our current framework although such

898
00:31:53,679 --> 00:31:55,679
a scale is known in the prior work of

899
00:31:55,679 --> 00:31:57,519
agrawal i'm saying but the construction

900
00:31:57,519 --> 00:31:59,200
is a bit more complicated and passes

901
00:31:59,200 --> 00:32:01,679
through abd circuits and it doesn't lend

902
00:32:01,679 --> 00:32:03,360
itself to a natural candidate for the

903
00:32:03,360 --> 00:32:04,880
amount of closure

904
00:32:04,880 --> 00:32:06,480
um so at the bank minimum will that

905
00:32:06,480 --> 00:32:07,600
actually should become really really

906
00:32:07,600 --> 00:32:09,840
nice in there so at the bare minimum we

907
00:32:09,840 --> 00:32:11,440
need to marry

908
00:32:11,440 --> 00:32:13,600
our construction with some of these

909
00:32:13,600 --> 00:32:16,959
ideas in india

910
00:32:19,200 --> 00:32:23,399
okay let's tank again

911
00:32:58,320 --> 00:33:00,720
okay uh so we saw yesterday i guess a

912
00:33:00,720 --> 00:33:03,760
long teaser that referred to this work

913
00:33:03,760 --> 00:33:05,360
um but today we'll see an additional

914
00:33:05,360 --> 00:33:07,519
five minutes about it about disappearing

915
00:33:07,519 --> 00:33:09,039
cryptography and the bounded storage

916
00:33:09,039 --> 00:33:10,880
model this is a joint work between

917
00:33:10,880 --> 00:33:12,080
justin

918
00:33:12,080 --> 00:33:14,480
guam and mark zandri and jose we'll give

919
00:33:14,480 --> 00:33:17,440
this a talk

920
00:33:17,679 --> 00:33:19,360
thank you chair for the introduction so

921
00:33:19,360 --> 00:33:21,279
my name is joshing guan and today i'll

922
00:33:21,279 --> 00:33:23,760
be talking again about uh disappearance

923
00:33:23,760 --> 00:33:25,919
cryptography in a boundary storage model

924
00:33:25,919 --> 00:33:27,919
this is a joint work with mark sandri

925
00:33:27,919 --> 00:33:29,440
both of us are from princeton university

926
00:33:29,440 --> 00:33:31,360
and entity research

927
00:33:31,360 --> 00:33:32,399
so

928
00:33:32,399 --> 00:33:34,000
as you can probably tell the title

929
00:33:34,000 --> 00:33:35,440
consists of two parts the first part

930
00:33:35,440 --> 00:33:36,880
being disappearing

931
00:33:36,880 --> 00:33:38,399
so what do we mean by disappearing

932
00:33:38,399 --> 00:33:40,559
cryptography uh well let's see this

933
00:33:40,559 --> 00:33:43,039
through two motivating examples

934
00:33:43,039 --> 00:33:44,799
so in the first example we have alice

935
00:33:44,799 --> 00:33:46,799
and bob and alice is standing over some

936
00:33:46,799 --> 00:33:48,880
encrypted document over this file and

937
00:33:48,880 --> 00:33:50,799
here comes our youtuber eve who comes

938
00:33:50,799 --> 00:33:52,880
and makes a copy of the document and

939
00:33:52,880 --> 00:33:55,760
then at a later time maybe a week a year

940
00:33:55,760 --> 00:33:58,480
10 years later eve is able to somehow

941
00:33:58,480 --> 00:34:00,799
extract the private key from bob either

942
00:34:00,799 --> 00:34:02,640
through social engineering interrogation

943
00:34:02,640 --> 00:34:04,720
or security breaches and then what you

944
00:34:04,720 --> 00:34:06,480
can do is to simply use the key to

945
00:34:06,480 --> 00:34:08,079
decrypt the document and obtain the

946
00:34:08,079 --> 00:34:09,679
original message

947
00:34:09,679 --> 00:34:11,679
so to prevent against these sort of

948
00:34:11,679 --> 00:34:14,000
attacks what we want is what we call

949
00:34:14,000 --> 00:34:16,239
forward secrecy uh essentially saying

950
00:34:16,239 --> 00:34:18,320
that a secret key leak in the future

951
00:34:18,320 --> 00:34:21,040
should not compromise the security of

952
00:34:21,040 --> 00:34:22,079
the

953
00:34:22,079 --> 00:34:24,480
messages that are sent before however in

954
00:34:24,480 --> 00:34:27,040
the standard model in order to

955
00:34:27,040 --> 00:34:29,599
have our secrecy we will either require

956
00:34:29,599 --> 00:34:32,000
constant key updates or we will require

957
00:34:32,000 --> 00:34:34,079
the two parties to have interaction and

958
00:34:34,079 --> 00:34:35,839
both of these could be undesirable in

959
00:34:35,839 --> 00:34:37,359
many scenarios

960
00:34:37,359 --> 00:34:39,280
the second the second example is also

961
00:34:39,280 --> 00:34:40,800
quite similar alice is over in

962
00:34:40,800 --> 00:34:42,639
privileged documents that each docker

963
00:34:42,639 --> 00:34:45,440
makes us happy then at a later time eve

964
00:34:45,440 --> 00:34:48,320
is going to ask bob for a private key

965
00:34:48,320 --> 00:34:50,399
however instead of providing the actual

966
00:34:50,399 --> 00:34:52,560
private key what bob can do is to

967
00:34:52,560 --> 00:34:55,679
provide a fake private key which will

968
00:34:55,679 --> 00:34:57,839
still allow you to decrypt the document

969
00:34:57,839 --> 00:34:59,760
but this time to a fake message for

970
00:34:59,760 --> 00:35:02,480
example a picture of a cat

971
00:35:02,480 --> 00:35:03,200
so

972
00:35:03,200 --> 00:35:05,520
what we refer to this is receiver

973
00:35:05,520 --> 00:35:07,200
deniable encryption

974
00:35:07,200 --> 00:35:08,880
essentially saying that the receiver can

975
00:35:08,880 --> 00:35:11,280
provide a fake key to have it decrypt to

976
00:35:11,280 --> 00:35:13,280
a fake message

977
00:35:13,280 --> 00:35:14,800
again in the standard model do you

978
00:35:14,800 --> 00:35:16,640
achieve receiver denial encryption we

979
00:35:16,640 --> 00:35:19,359
would require a multi-round interactive

980
00:35:19,359 --> 00:35:22,560
protocol between honest parties so with

981
00:35:22,560 --> 00:35:24,480
disappearing cryptography we aim to

982
00:35:24,480 --> 00:35:26,400
solve these two problems all together

983
00:35:26,400 --> 00:35:27,839
but how exactly

984
00:35:27,839 --> 00:35:30,079
imagine this so suppose alice sends over

985
00:35:30,079 --> 00:35:32,240
the document over to bob and eve comes

986
00:35:32,240 --> 00:35:33,599
and makes a copy

987
00:35:33,599 --> 00:35:36,240
then through some magic

988
00:35:36,240 --> 00:35:38,160
this cipher text just

989
00:35:38,160 --> 00:35:40,480
just magically disappears then at a

990
00:35:40,480 --> 00:35:42,720
later time even if eve is given the

991
00:35:42,720 --> 00:35:44,880
actual private key there's nothing he

992
00:35:44,880 --> 00:35:46,880
can do there is no cipher text for him

993
00:35:46,880 --> 00:35:50,400
to decrypt so by default this is uh has

994
00:35:50,400 --> 00:35:52,880
forward secrecy and it is also vacuously

995
00:35:52,880 --> 00:35:55,119
receiver design

996
00:35:55,119 --> 00:35:57,440
but how exactly do we make the magic

997
00:35:57,440 --> 00:35:59,280
happen so we resolved to the boundary

998
00:35:59,280 --> 00:36:01,280
storage model first put forward by yuri

999
00:36:01,280 --> 00:36:03,359
mara in 1992.

1000
00:36:03,359 --> 00:36:05,440
what does the bounded storage model say

1001
00:36:05,440 --> 00:36:07,200
well traditionally in cryptography when

1002
00:36:07,200 --> 00:36:09,200
we talk about an adversary we imagine

1003
00:36:09,200 --> 00:36:11,599
the adversary to be time-bounded so

1004
00:36:11,599 --> 00:36:13,280
namely the adversary needs to finish

1005
00:36:13,280 --> 00:36:15,280
attacks within time polynomial in the

1006
00:36:15,280 --> 00:36:17,599
security parameter however in a boundary

1007
00:36:17,599 --> 00:36:19,599
storage model the adversary can take as

1008
00:36:19,599 --> 00:36:22,079
long as much time as he wants

1009
00:36:22,079 --> 00:36:23,839
but the adversary is bounded by the

1010
00:36:23,839 --> 00:36:25,599
total number of memory bits that he can

1011
00:36:25,599 --> 00:36:28,960
ever use and usually we will have the

1012
00:36:28,960 --> 00:36:30,880
bound to be a fixed polynomial on the

1013
00:36:30,880 --> 00:36:33,680
security parameter so the idea that we

1014
00:36:33,680 --> 00:36:34,960
take is

1015
00:36:34,960 --> 00:36:37,119
imagine if we set the size of the

1016
00:36:37,119 --> 00:36:39,119
ciphertext to be way larger than the

1017
00:36:39,119 --> 00:36:41,599
atmospheric storage bound then there's

1018
00:36:41,599 --> 00:36:43,760
when the message when the cipher text is

1019
00:36:43,760 --> 00:36:45,440
being sent there is no way that the

1020
00:36:45,440 --> 00:36:47,760
adversary can write down the cycle text

1021
00:36:47,760 --> 00:36:49,760
therefore for the for the atmosphere the

1022
00:36:49,760 --> 00:36:52,800
cipher test effectively just disappears

1023
00:36:52,800 --> 00:36:55,200
right after the transmission ends

1024
00:36:55,200 --> 00:36:57,040
using that intuition we initiate the

1025
00:36:57,040 --> 00:36:59,280
study of disappearing cryptography

1026
00:36:59,280 --> 00:37:01,280
by investigating four different schemes

1027
00:37:01,280 --> 00:37:03,760
so we start off with a disappearing pku

1028
00:37:03,760 --> 00:37:05,359
scheme corresponding to the example that

1029
00:37:05,359 --> 00:37:07,520
we have just seen and we further extend

1030
00:37:07,520 --> 00:37:09,760
it to disappearing functional encryption

1031
00:37:09,760 --> 00:37:11,520
we also study disappearance signatures

1032
00:37:11,520 --> 00:37:13,200
where the signatures are too large to

1033
00:37:13,200 --> 00:37:16,480
store for the absolute as well as online

1034
00:37:16,480 --> 00:37:18,880
authorization where we imagine we stream

1035
00:37:18,880 --> 00:37:20,640
programs that are too large for the apps

1036
00:37:20,640 --> 00:37:23,119
recent store and in fact we showed that

1037
00:37:23,119 --> 00:37:25,200
online authentication can be a useful

1038
00:37:25,200 --> 00:37:27,040
tool by showing how to construct the

1039
00:37:27,040 --> 00:37:29,119
previous three using online presentation

1040
00:37:29,119 --> 00:37:31,200
as a building block so the security

1041
00:37:31,200 --> 00:37:33,200
definition that we adopt for online

1042
00:37:33,200 --> 00:37:35,680
frustration is a flavor of virtual grey

1043
00:37:35,680 --> 00:37:38,240
box vgb obfuscation which is a middle

1044
00:37:38,240 --> 00:37:40,000
ground between indistinguishability

1045
00:37:40,000 --> 00:37:43,200
alpha station io and vbp obfuscation a

1046
00:37:43,200 --> 00:37:45,520
virtual black box notification we have

1047
00:37:45,520 --> 00:37:48,400
also have similar definitions for

1048
00:37:48,400 --> 00:37:50,560
an online affiliation with i o and bbe

1049
00:37:50,560 --> 00:37:53,119
security and we have shown that bbb

1050
00:37:53,119 --> 00:37:55,520
office station is also impossible for

1051
00:37:55,520 --> 00:37:57,520
online authentication

1052
00:37:57,520 --> 00:38:00,160
furthermore we provide two different

1053
00:38:00,160 --> 00:38:01,760
candidate constructions for an online

1054
00:38:01,760 --> 00:38:04,240
office creator with bgb security the

1055
00:38:04,240 --> 00:38:06,400
first construction is based on large

1056
00:38:06,400 --> 00:38:08,400
matrix branching programs which is a

1057
00:38:08,400 --> 00:38:11,040
common technique used in constructing io

1058
00:38:11,040 --> 00:38:12,800
and the second candidate construction is

1059
00:38:12,800 --> 00:38:15,040
based on the time stamping scheme in the

1060
00:38:15,040 --> 00:38:16,880
boundary storage model

1061
00:38:16,880 --> 00:38:19,760
so in terms of future directions so

1062
00:38:19,760 --> 00:38:21,920
usually the way people use solid storage

1063
00:38:21,920 --> 00:38:24,160
model is to prove things information

1064
00:38:24,160 --> 00:38:26,480
radically however in this paper what we

1065
00:38:26,480 --> 00:38:28,720
did is we combined computational

1066
00:38:28,720 --> 00:38:30,240
assumptions together with the boundary

1067
00:38:30,240 --> 00:38:32,800
storage model and this allows us to

1068
00:38:32,800 --> 00:38:35,280
achieve never before possible results uh

1069
00:38:35,280 --> 00:38:37,200
effectively having these different

1070
00:38:37,200 --> 00:38:39,680
schemes in the disappearing cryptography

1071
00:38:39,680 --> 00:38:41,440
so we think it will be an interesting

1072
00:38:41,440 --> 00:38:43,280
problem to explore what other

1073
00:38:43,280 --> 00:38:45,520
classically impossible results can be

1074
00:38:45,520 --> 00:38:46,560
overcome

1075
00:38:46,560 --> 00:38:48,560
by combining the boundary storage model

1076
00:38:48,560 --> 00:38:51,599
together with computational assumptions

1077
00:38:51,599 --> 00:38:53,680
and secondly we initiate the study of

1078
00:38:53,680 --> 00:38:55,680
online authentication and just as

1079
00:38:55,680 --> 00:38:57,599
standard model officiation turns out to

1080
00:38:57,599 --> 00:39:00,240
be a very powerful tool in the study of

1081
00:39:00,240 --> 00:39:02,160
standard model cryptography

1082
00:39:02,160 --> 00:39:04,320
we have shown that online implementation

1083
00:39:04,320 --> 00:39:06,400
is also a central tool in the study of

1084
00:39:06,400 --> 00:39:08,160
disappearing cryptography in the body

1085
00:39:08,160 --> 00:39:09,359
storage model

1086
00:39:09,359 --> 00:39:10,880
although our

1087
00:39:10,880 --> 00:39:12,800
our constructions are only candidate

1088
00:39:12,800 --> 00:39:14,480
constructions and do not have full

1089
00:39:14,480 --> 00:39:17,040
security proofs we want to mention that

1090
00:39:17,040 --> 00:39:18,880
the standard model observation also

1091
00:39:18,880 --> 00:39:22,079
started out as security conjectures

1092
00:39:22,079 --> 00:39:24,320
so we so we hope that future work will

1093
00:39:24,320 --> 00:39:27,040
be able to improve the state of the

1094
00:39:27,040 --> 00:39:29,040
candidate construction

1095
00:39:29,040 --> 00:39:30,800
and that's it for the talk thank you for

1096
00:39:30,800 --> 00:39:31,760
your time

1097
00:39:31,760 --> 00:39:35,109
[Applause]

1098
00:39:36,640 --> 00:39:39,118
questions

1099
00:39:39,839 --> 00:39:42,560
no questions currently online

1100
00:39:42,560 --> 00:39:45,680
once again i have a question

1101
00:39:45,920 --> 00:39:47,440
can you say a little bit about the the

1102
00:39:47,440 --> 00:39:49,839
syntax of online obfuscation how does it

1103
00:39:49,839 --> 00:39:52,560
compare to standard example oh yeah the

1104
00:39:52,560 --> 00:39:54,480
syntax of the online application is

1105
00:39:54,480 --> 00:39:56,800
essentially we imagine

1106
00:39:56,800 --> 00:39:59,760
the security game having uh having two

1107
00:39:59,760 --> 00:40:01,520
types of rounds so there's interaction

1108
00:40:01,520 --> 00:40:03,599
around where we have the so essentially

1109
00:40:03,599 --> 00:40:05,040
there's two games in the first game the

1110
00:40:05,040 --> 00:40:07,680
challenger interacts with the adversary

1111
00:40:07,680 --> 00:40:10,240
and in the second game the uh challenger

1112
00:40:10,240 --> 00:40:11,920
interacts with the simulator so we want

1113
00:40:11,920 --> 00:40:13,440
the challenger to be unable to

1114
00:40:13,440 --> 00:40:15,359
distinguish between the whether it's

1115
00:40:15,359 --> 00:40:16,960
interacting with the challenge of

1116
00:40:16,960 --> 00:40:18,319
interacting with the adversary or the

1117
00:40:18,319 --> 00:40:20,720
simulator and what the atmospheric at is

1118
00:40:20,720 --> 00:40:23,040
the atmospheric is to get a stream of of

1119
00:40:23,040 --> 00:40:26,079
the actual uh alpha alpha scada program

1120
00:40:26,079 --> 00:40:28,400
uh what the semi-simulator gets is to

1121
00:40:28,400 --> 00:40:30,240
actually get queries to the original

1122
00:40:30,240 --> 00:40:31,520
surface

1123
00:40:31,520 --> 00:40:34,000
so uh yeah so that's sort of how we how

1124
00:40:34,000 --> 00:40:35,920
we imagine we define things so

1125
00:40:35,920 --> 00:40:37,200
essentially instead of getting the

1126
00:40:37,200 --> 00:40:38,720
stream program

1127
00:40:38,720 --> 00:40:41,599
the simulator only gets to query the

1128
00:40:41,599 --> 00:40:43,920
audio

1129
00:40:44,079 --> 00:40:46,000
yeah there's the full there's a full

1130
00:40:46,000 --> 00:40:47,920
security definition in the

1131
00:40:47,920 --> 00:40:50,720
in the recorded video

1132
00:40:50,720 --> 00:40:52,800
right there's a question here from brent

1133
00:40:52,800 --> 00:40:54,079
i'm not sure if they hear this

1134
00:40:54,079 --> 00:40:56,400
microphone go i'll try it out well you

1135
00:40:56,400 --> 00:40:58,480
can repeat it or sure

1136
00:40:58,480 --> 00:41:00,319
i'll try this um

1137
00:41:00,319 --> 00:41:01,839
so do you have any sense of the numbers

1138
00:41:01,839 --> 00:41:03,359
needed for the balanced storage model

1139
00:41:03,359 --> 00:41:04,079
like

1140
00:41:04,079 --> 00:41:05,359
just

1141
00:41:05,359 --> 00:41:06,960
like what what type of what type of

1142
00:41:06,960 --> 00:41:08,560
speed of internet connection and how

1143
00:41:08,560 --> 00:41:10,480
limited would the storage have to be

1144
00:41:10,480 --> 00:41:12,400
okay yeah so the question is about like

1145
00:41:12,400 --> 00:41:13,359
the

1146
00:41:13,359 --> 00:41:15,520
the the size of the in terms of the

1147
00:41:15,520 --> 00:41:16,720
numbers

1148
00:41:16,720 --> 00:41:18,720
like what's the bandwidth requirements

1149
00:41:18,720 --> 00:41:21,118
in terms

1150
00:41:29,200 --> 00:41:31,040
for example think about the honest

1151
00:41:31,040 --> 00:41:35,560
parties space being 10 um

1152
00:41:41,040 --> 00:41:42,960
so that's like a huge amount

1153
00:41:42,960 --> 00:41:44,720
uh although like we do want to point out

1154
00:41:44,720 --> 00:41:46,959
that

1155
00:41:47,040 --> 00:41:49,520
have a uh communication cost because the

1156
00:41:49,520 --> 00:41:51,920
whole idea is to send a huge amount of

1157
00:41:51,920 --> 00:41:54,319
information that exceeds our storage so

1158
00:41:54,319 --> 00:41:56,240
the communication cost is time but as

1159
00:41:56,240 --> 00:41:58,800
you can see this is already really

1160
00:41:58,800 --> 00:42:01,280
intimidating because i only need 10

1161
00:42:01,280 --> 00:42:04,079
gigabytes of storage but if you swear

1162
00:42:04,079 --> 00:42:06,800
it's going to be a huge amount that is

1163
00:42:06,800 --> 00:42:11,520
almost impossible for any normal person

1164
00:42:15,520 --> 00:42:17,200
here we're assuming computational

1165
00:42:17,200 --> 00:42:21,000
assumptions uh

1166
00:42:35,920 --> 00:42:38,079
which is not a

1167
00:42:38,079 --> 00:42:41,960
desirable thing

1168
00:42:44,160 --> 00:42:47,119
any further questions

1169
00:42:47,119 --> 00:42:50,839
not to thank the speaker

1170
00:43:25,520 --> 00:43:27,599
okay great the next presentation will be

1171
00:43:27,599 --> 00:43:29,680
about direct hardness a direct product

1172
00:43:29,680 --> 00:43:32,160
hardness amplification this is a work by

1173
00:43:32,160 --> 00:43:34,720
david lazenberger and orley marlow and

1174
00:43:34,720 --> 00:43:37,839
david will be giving the talk

1175
00:43:38,960 --> 00:43:41,839
thank you

1176
00:43:42,160 --> 00:43:44,800
so yeah i'll be presenting our paper

1177
00:43:44,800 --> 00:43:48,640
very product and specification

1178
00:43:49,440 --> 00:43:51,520
ah okay

1179
00:43:51,520 --> 00:43:52,400
is it

1180
00:43:52,400 --> 00:43:53,599
is it okay

1181
00:43:53,599 --> 00:43:55,200
yes

1182
00:43:55,200 --> 00:43:56,240
um

1183
00:43:56,240 --> 00:43:58,160
so i start to explain the setting we are

1184
00:43:58,160 --> 00:44:00,000
interested in

1185
00:44:00,000 --> 00:44:02,880
how do i continue

1186
00:44:04,640 --> 00:44:08,520
yeah okay perfect

1187
00:44:08,800 --> 00:44:10,960
so we are interested in in this kind of

1188
00:44:10,960 --> 00:44:14,160
direct product uh construction

1189
00:44:14,160 --> 00:44:16,400
so the end of multiple games so if you

1190
00:44:16,400 --> 00:44:18,240
have a game think of as you know

1191
00:44:18,240 --> 00:44:20,240
cryptographic games say signature

1192
00:44:20,240 --> 00:44:22,480
reporter game or something similar

1193
00:44:22,480 --> 00:44:24,880
you can take the direct product say the

1194
00:44:24,880 --> 00:44:27,359
end of two such games g and h

1195
00:44:27,359 --> 00:44:28,880
and then

1196
00:44:28,880 --> 00:44:30,720
a winner can can interact with these two

1197
00:44:30,720 --> 00:44:32,560
games in parallel

1198
00:44:32,560 --> 00:44:33,520
and then

1199
00:44:33,520 --> 00:44:34,960
so this is a natural construction you

1200
00:44:34,960 --> 00:44:36,720
try to amplify the hardness of the game

1201
00:44:36,720 --> 00:44:39,040
the hope is that it's harder to win the

1202
00:44:39,040 --> 00:44:41,040
end of two games than you know to win

1203
00:44:41,040 --> 00:44:44,560
just one of the games individually

1204
00:44:45,440 --> 00:44:47,440
and and this is a natural construction

1205
00:44:47,440 --> 00:44:50,240
of course obviously this desires relates

1206
00:44:50,240 --> 00:44:52,480
to the actual security of the underlying

1207
00:44:52,480 --> 00:44:53,920
sort of the primitives you're trying to

1208
00:44:53,920 --> 00:44:56,000
build so this if you can do this you can

1209
00:44:56,000 --> 00:44:57,119
basically

1210
00:44:57,119 --> 00:44:58,480
you know you can you can take a weak

1211
00:44:58,480 --> 00:45:00,160
primitive say we want a function or

1212
00:45:00,160 --> 00:45:01,359
something like this and you can

1213
00:45:01,359 --> 00:45:03,200
basically

1214
00:45:03,200 --> 00:45:05,040
get a strong one-way function or say a

1215
00:45:05,040 --> 00:45:07,119
strong signature scheme

1216
00:45:07,119 --> 00:45:09,359
so the natural thing you do

1217
00:45:09,359 --> 00:45:10,319
so

1218
00:45:10,319 --> 00:45:12,160
the obvious question is somehow i said

1219
00:45:12,160 --> 00:45:13,599
okay you take these games they're

1220
00:45:13,599 --> 00:45:15,119
independent

1221
00:45:15,119 --> 00:45:17,040
you would hope you would

1222
00:45:17,040 --> 00:45:18,960
intuitively expect that the highness

1223
00:45:18,960 --> 00:45:21,440
amplifies uh yeah i miss amplifies and

1224
00:45:21,440 --> 00:45:24,640
then in the natural way it multiplies

1225
00:45:24,640 --> 00:45:26,480
highness multiplies because the games

1226
00:45:26,480 --> 00:45:28,560
are independent

1227
00:45:28,560 --> 00:45:30,000
now

1228
00:45:30,000 --> 00:45:32,079
uh in an information theoretic setting

1229
00:45:32,079 --> 00:45:34,560
this is no it's not it's not trivial but

1230
00:45:34,560 --> 00:45:37,440
but it's it's pretty easy to prove that

1231
00:45:37,440 --> 00:45:39,280
actually it doesn't multiply in a

1232
00:45:39,280 --> 00:45:42,640
perfect way okay for any such games

1233
00:45:42,640 --> 00:45:45,040
it's exactly what you would expect

1234
00:45:45,040 --> 00:45:46,800
um but here we are interested in the

1235
00:45:46,800 --> 00:45:48,079
more difficult

1236
00:45:48,079 --> 00:45:50,079
computational setting where

1237
00:45:50,079 --> 00:45:52,079
what what would you need to show so when

1238
00:45:52,079 --> 00:45:54,000
you basically need a reduction and it's

1239
00:45:54,000 --> 00:45:55,839
a bit more it's a bit more tricky you

1240
00:45:55,839 --> 00:45:57,599
need to assume it's only true for

1241
00:45:57,599 --> 00:45:59,839
certain kinds of games it's only true in

1242
00:45:59,839 --> 00:46:01,520
an approximate sense

1243
00:46:01,520 --> 00:46:03,520
you lose something you lose actually

1244
00:46:03,520 --> 00:46:06,000
quite a lot but the talk is somehow this

1245
00:46:06,000 --> 00:46:08,000
works somehow about this like how do you

1246
00:46:08,000 --> 00:46:10,319
do this like this reduction

1247
00:46:10,319 --> 00:46:11,680
and before i

1248
00:46:11,680 --> 00:46:13,359
before i show some more about how this

1249
00:46:13,359 --> 00:46:14,880
reduction looks like

1250
00:46:14,880 --> 00:46:19,040
i i state our main results so we prove a

1251
00:46:19,040 --> 00:46:21,119
an abstract simplification theorem that

1252
00:46:21,119 --> 00:46:22,480
is simpler

1253
00:46:22,480 --> 00:46:24,480
uh more general and stronger than

1254
00:46:24,480 --> 00:46:26,880
previous theorems of the same kind of

1255
00:46:26,880 --> 00:46:28,400
similar kind

1256
00:46:28,400 --> 00:46:29,359
and

1257
00:46:29,359 --> 00:46:31,359
our focus is twofold so first we try to

1258
00:46:31,359 --> 00:46:34,880
provide close optimal concrete bounds as

1259
00:46:34,880 --> 00:46:37,280
opposed to just asymptotic ones but the

1260
00:46:37,280 --> 00:46:39,599
idea is that you know these asymptotic

1261
00:46:39,599 --> 00:46:41,200
results just follow as simple

1262
00:46:41,200 --> 00:46:42,640
corollaries to

1263
00:46:42,640 --> 00:46:46,560
to these uh concrete bounds that we give

1264
00:46:46,560 --> 00:46:47,920
and then second

1265
00:46:47,920 --> 00:46:49,760
in the spirit of abstraction or we try

1266
00:46:49,760 --> 00:46:51,680
to distill out the essence of you know

1267
00:46:51,680 --> 00:46:52,880
the typical

1268
00:46:52,880 --> 00:46:54,560
simplification

1269
00:46:54,560 --> 00:46:56,800
statement of the argument that is made

1270
00:46:56,800 --> 00:46:58,079
and to get

1271
00:46:58,079 --> 00:47:00,400
a simple and abstract sort of theorem

1272
00:47:00,400 --> 00:47:01,920
that you can reuse

1273
00:47:01,920 --> 00:47:03,359
and we then show this in the second part

1274
00:47:03,359 --> 00:47:05,040
and apply sort of by applying our

1275
00:47:05,040 --> 00:47:07,200
theorem to some some non-trivial

1276
00:47:07,200 --> 00:47:09,920
interactive cryptographic games we can

1277
00:47:09,920 --> 00:47:11,680
show that actually you can have a more

1278
00:47:11,680 --> 00:47:13,680
modular kind of analysis this kind of

1279
00:47:13,680 --> 00:47:14,640
statement

1280
00:47:14,640 --> 00:47:16,800
you can basically inherit the actual

1281
00:47:16,800 --> 00:47:20,160
amplification from such a theorem

1282
00:47:20,160 --> 00:47:21,040
and then

1283
00:47:21,040 --> 00:47:22,960
this is basically for free

1284
00:47:22,960 --> 00:47:26,000
okay so let's look at how this reduction

1285
00:47:26,000 --> 00:47:29,599
that i mentioned before looks like

1286
00:47:29,599 --> 00:47:31,280
so here on the left you have the the end

1287
00:47:31,280 --> 00:47:32,960
of two games g and h and the winner can

1288
00:47:32,960 --> 00:47:34,960
interact in parallel and now the

1289
00:47:34,960 --> 00:47:36,800
reduction would try to turn such a

1290
00:47:36,800 --> 00:47:40,000
winner for for the end gh into winner

1291
00:47:40,000 --> 00:47:41,280
for just g

1292
00:47:41,280 --> 00:47:44,400
uh and into a winner for just age right

1293
00:47:44,400 --> 00:47:46,480
so the the the only black box way you

1294
00:47:46,480 --> 00:47:48,400
can basically do this at first sort of

1295
00:47:48,400 --> 00:47:50,000
you just say okay we simulate an

1296
00:47:50,000 --> 00:47:51,680
instance of age towards towards the

1297
00:47:51,680 --> 00:47:56,640
winner to get this winner wh for g and

1298
00:47:56,640 --> 00:47:58,720
and then we can do the opposite somehow

1299
00:47:58,720 --> 00:48:00,400
for for h right so basically we get

1300
00:48:00,400 --> 00:48:02,319
actually two reductions but it's just

1301
00:48:02,319 --> 00:48:04,400
you know one for towards h and one

1302
00:48:04,400 --> 00:48:06,880
towards g right but now of course

1303
00:48:06,880 --> 00:48:07,839
remember that we are talking about

1304
00:48:07,839 --> 00:48:09,520
amplification so we would now like to

1305
00:48:09,520 --> 00:48:10,240
say

1306
00:48:10,240 --> 00:48:12,160
actually it's easier to win just c or

1307
00:48:12,160 --> 00:48:14,079
it's easier to win just h than to win

1308
00:48:14,079 --> 00:48:15,599
the end of the two games of course this

1309
00:48:15,599 --> 00:48:17,520
is what we wanted to say but now if you

1310
00:48:17,520 --> 00:48:20,000
look at this of course you see that okay

1311
00:48:20,000 --> 00:48:21,520
if you just assume any winner any game

1312
00:48:21,520 --> 00:48:23,599
somehow this can be that the winning

1313
00:48:23,599 --> 00:48:25,119
probability here on the right might

1314
00:48:25,119 --> 00:48:27,520
might be just the same as as on the left

1315
00:48:27,520 --> 00:48:29,040
okay so

1316
00:48:29,040 --> 00:48:30,800
in any such setting somehow you need to

1317
00:48:30,800 --> 00:48:32,559
boost the winning probability of these

1318
00:48:32,559 --> 00:48:35,280
winners wh wwg here on the right somehow

1319
00:48:35,280 --> 00:48:37,200
so this is where you now need to assume

1320
00:48:37,200 --> 00:48:39,680
very strong structure on the game or for

1321
00:48:39,680 --> 00:48:41,440
example you need to assume

1322
00:48:41,440 --> 00:48:43,280
that you can somehow you can boost the

1323
00:48:43,280 --> 00:48:44,559
winner say

1324
00:48:44,559 --> 00:48:45,440
say

1325
00:48:45,440 --> 00:48:46,400
bye

1326
00:48:46,400 --> 00:48:48,079
this is really a standard way to do this

1327
00:48:48,079 --> 00:48:49,680
you can basically repeat the winner

1328
00:48:49,680 --> 00:48:51,280
independently two times and it's such

1329
00:48:51,280 --> 00:48:53,280
that you know you repeat two times if

1330
00:48:53,280 --> 00:48:55,040
you you win at least one of your two

1331
00:48:55,040 --> 00:48:57,359
attempts then you the one say signature

1332
00:48:57,359 --> 00:48:59,440
forgery is like this you can basically

1333
00:48:59,440 --> 00:49:01,119
attempt many times before the signature

1334
00:49:01,119 --> 00:49:02,960
and then you you're good at some point

1335
00:49:02,960 --> 00:49:04,319
right so this is

1336
00:49:04,319 --> 00:49:05,440
so now

1337
00:49:05,440 --> 00:49:06,800
let's let's make an example say we have

1338
00:49:06,800 --> 00:49:08,800
a winner w right

1339
00:49:08,800 --> 00:49:11,920
this and here with one percent say delta

1340
00:49:11,920 --> 00:49:14,319
winning probability

1341
00:49:14,319 --> 00:49:16,240
and now the question is if we do this

1342
00:49:16,240 --> 00:49:20,078
boosting right we repeat fewer times

1343
00:49:20,880 --> 00:49:23,040
how often do we need to do this

1344
00:49:23,040 --> 00:49:24,480
so that we get

1345
00:49:24,480 --> 00:49:27,040
expected winning probability of close to

1346
00:49:27,040 --> 00:49:29,119
the square root of delta say close to 10

1347
00:49:29,119 --> 00:49:31,680
say 9.9 percent how often do we need to

1348
00:49:31,680 --> 00:49:33,520
do this to actually get this guarantee

1349
00:49:33,520 --> 00:49:35,440
right

1350
00:49:35,440 --> 00:49:37,599
so this is sort of there's a classical

1351
00:49:37,599 --> 00:49:40,720
way of of of doing this

1352
00:49:40,720 --> 00:49:42,160
and if you run the number somewhere you

1353
00:49:42,160 --> 00:49:43,839
see that you need around 76 000

1354
00:49:43,839 --> 00:49:45,119
repetitions

1355
00:49:45,119 --> 00:49:46,720
seems to be

1356
00:49:46,720 --> 00:49:48,240
quite a lot for such a basic

1357
00:49:48,240 --> 00:49:51,119
amplification and the consequence of our

1358
00:49:51,119 --> 00:49:52,960
new result is that actually 90

1359
00:49:52,960 --> 00:49:54,960
repetitions are sufficient and easy to

1360
00:49:54,960 --> 00:49:55,839
see that

1361
00:49:55,839 --> 00:49:59,920
44 unnecessary okay

1362
00:49:59,920 --> 00:50:00,720
so

1363
00:50:00,720 --> 00:50:02,559
there's no time to actually show the

1364
00:50:02,559 --> 00:50:05,760
actual result but it's just displayed to

1365
00:50:05,760 --> 00:50:07,680
get you somehow

1366
00:50:07,680 --> 00:50:10,240
the idea of on the level of where we

1367
00:50:10,240 --> 00:50:12,880
phrased the result and it's

1368
00:50:12,880 --> 00:50:15,440
the main message is that it's just about

1369
00:50:15,440 --> 00:50:17,839
your expectations over probability

1370
00:50:17,839 --> 00:50:20,720
distributions

1371
00:50:22,640 --> 00:50:25,040
and then some functions mu and psi here

1372
00:50:25,040 --> 00:50:27,040
where psi corresponds to the boosting

1373
00:50:27,040 --> 00:50:29,040
and mu corresponds to basically the

1374
00:50:29,040 --> 00:50:30,960
winning structure of this this winner

1375
00:50:30,960 --> 00:50:33,040
for that for the product that gives

1376
00:50:33,040 --> 00:50:35,280
assumed but then we basically relate

1377
00:50:35,280 --> 00:50:36,800
these two

1378
00:50:36,800 --> 00:50:39,359
basically these three expectations here

1379
00:50:39,359 --> 00:50:41,760
where we somehow nest a different way

1380
00:50:41,760 --> 00:50:43,119
somehow this would correspond to the

1381
00:50:43,119 --> 00:50:45,359
wing probability of the g of of g

1382
00:50:45,359 --> 00:50:47,359
somehow the reduction that towards g and

1383
00:50:47,359 --> 00:50:50,880
this towards h and this here um is is

1384
00:50:50,880 --> 00:50:52,400
the winning probability of the of the

1385
00:50:52,400 --> 00:50:54,480
end some of the two games somehow

1386
00:50:54,480 --> 00:50:57,040
showing that this is smaller than these

1387
00:50:57,040 --> 00:50:58,400
individuals

1388
00:50:58,400 --> 00:51:00,160
and then so this is the classical way of

1389
00:51:00,160 --> 00:51:01,920
analyzing this we notice that actually a

1390
00:51:01,920 --> 00:51:04,480
typical way to amplify here is this

1391
00:51:04,480 --> 00:51:06,480
boosting function psi would be this this

1392
00:51:06,480 --> 00:51:08,480
function here one minus one is minus x

1393
00:51:08,480 --> 00:51:10,160
to the fuel

1394
00:51:10,160 --> 00:51:11,760
is it just because you repeat few times

1395
00:51:11,760 --> 00:51:13,599
it's actually a concave a function if

1396
00:51:13,599 --> 00:51:14,960
you exploit this in an

1397
00:51:14,960 --> 00:51:17,040
analysis then you can actually get a

1398
00:51:17,040 --> 00:51:19,359
stronger result okay

1399
00:51:19,359 --> 00:51:21,040
and this is basically where the improved

1400
00:51:21,040 --> 00:51:22,960
numbers come from right so this is you

1401
00:51:22,960 --> 00:51:24,960
just take something sorry but the main

1402
00:51:24,960 --> 00:51:26,319
point is someone really that you know

1403
00:51:26,319 --> 00:51:28,319
everything that happens is is at this

1404
00:51:28,319 --> 00:51:30,480
basic level just expectations over

1405
00:51:30,480 --> 00:51:31,920
probability distributions or some

1406
00:51:31,920 --> 00:51:33,280
functions

1407
00:51:33,280 --> 00:51:34,079
okay

1408
00:51:34,079 --> 00:51:35,680
so then obviously we have much more we

1409
00:51:35,680 --> 00:51:37,119
discuss the tightness you can you can

1410
00:51:37,119 --> 00:51:38,720
see that what we do is sort of close to

1411
00:51:38,720 --> 00:51:40,960
optimal but not quite perfect somehow

1412
00:51:40,960 --> 00:51:42,000
there's still

1413
00:51:42,000 --> 00:51:43,680
some small gap left

1414
00:51:43,680 --> 00:51:45,920
and actually we yeah we have we have a

1415
00:51:45,920 --> 00:51:48,640
we have a conjecture of what what is

1416
00:51:48,640 --> 00:51:50,240
what this problem what seems to be

1417
00:51:50,240 --> 00:51:52,079
optimal at least for certain boosting

1418
00:51:52,079 --> 00:51:53,119
functions

1419
00:51:53,119 --> 00:51:54,079
which is

1420
00:51:54,079 --> 00:51:56,400
basically very rude very loosely

1421
00:51:56,400 --> 00:51:58,559
speaking somehow saying that either the

1422
00:51:58,559 --> 00:52:00,319
winning probability or the losing

1423
00:52:00,319 --> 00:52:02,960
probability of a winner is is somehow

1424
00:52:02,960 --> 00:52:05,599
maximally concentrated

1425
00:52:05,599 --> 00:52:07,200
and we would be quite excited to prove

1426
00:52:07,200 --> 00:52:08,800
this we think it's doable

1427
00:52:08,800 --> 00:52:11,200
um and then lastly obviously

1428
00:52:11,200 --> 00:52:12,880
as we said somehow we have these

1429
00:52:12,880 --> 00:52:14,720
applications where

1430
00:52:14,720 --> 00:52:16,079
the details are not

1431
00:52:16,079 --> 00:52:17,839
that that important but but the main

1432
00:52:17,839 --> 00:52:19,200
point we try to convey is really that

1433
00:52:19,200 --> 00:52:21,200
you can modularize such an analysis

1434
00:52:21,200 --> 00:52:23,119
basically the actual amplification to

1435
00:52:23,119 --> 00:52:26,319
inherit just for free from from our

1436
00:52:26,319 --> 00:52:28,400
amplification theorem so if you are

1437
00:52:28,400 --> 00:52:31,040
interested in any of this you can

1438
00:52:31,040 --> 00:52:32,800
check out our paper it's on april thank

1439
00:52:32,800 --> 00:52:34,880
you

1440
00:52:44,559 --> 00:52:46,079
actually for lack of time i'm not going

1441
00:52:46,079 --> 00:52:48,960
to ask a question

1442
00:52:50,160 --> 00:52:54,440
okay so let's thank the speaker again

1443
00:53:10,400 --> 00:53:12,960
okay the next presentation

1444
00:53:12,960 --> 00:53:15,839
will be

1445
00:53:19,200 --> 00:53:21,359
non-valuable time lock puzzles and

1446
00:53:21,359 --> 00:53:24,160
applications

1447
00:53:25,280 --> 00:53:29,079
this is the work by cody

1448
00:53:33,119 --> 00:53:34,559
thanks

1449
00:53:34,559 --> 00:53:35,760
so yeah i'll be talking about

1450
00:53:35,760 --> 00:53:37,599
non-valuable timeline puzzles and this

1451
00:53:37,599 --> 00:53:39,359
is joint work with cody fair tag ilan

1452
00:53:39,359 --> 00:53:43,480
kamagoski and rafael pass

1453
00:53:51,119 --> 00:53:53,359
so the focus of this work is the notion

1454
00:53:53,359 --> 00:53:55,920
of timelock puzzles and

1455
00:53:55,920 --> 00:53:57,680
basically what a timelock puzzle allows

1456
00:53:57,680 --> 00:54:00,240
you to do is hide some value for some

1457
00:54:00,240 --> 00:54:01,760
amount of time

1458
00:54:01,760 --> 00:54:02,480
so

1459
00:54:02,480 --> 00:54:04,880
given some secret s that we want to hide

1460
00:54:04,880 --> 00:54:07,680
and some amount of time t

1461
00:54:07,680 --> 00:54:10,319
we can efficiently encode s into a

1462
00:54:10,319 --> 00:54:11,839
puzzle

1463
00:54:11,839 --> 00:54:14,079
and this puzzle can be solved in time t

1464
00:54:14,079 --> 00:54:15,599
but not faster

1465
00:54:15,599 --> 00:54:18,000
and by efficiently in code i mean in

1466
00:54:18,000 --> 00:54:20,880
time much much less than t

1467
00:54:20,880 --> 00:54:22,319
one way to think about a time lock

1468
00:54:22,319 --> 00:54:24,640
puzzle is just as a fine-grained analog

1469
00:54:24,640 --> 00:54:28,000
of a commitment so encoding is quick

1470
00:54:28,000 --> 00:54:30,160
it's fully binding but then it's only

1471
00:54:30,160 --> 00:54:32,000
hiding until time t

1472
00:54:32,000 --> 00:54:35,040
rather than indefinitely

1473
00:54:35,040 --> 00:54:36,640
so the reason that we're looking at

1474
00:54:36,640 --> 00:54:38,480
time-lapse puzzles is because they

1475
00:54:38,480 --> 00:54:40,400
actually give this very

1476
00:54:40,400 --> 00:54:43,040
simple to state and non-trivial coin

1477
00:54:43,040 --> 00:54:44,880
flipping protocol

1478
00:54:44,880 --> 00:54:47,200
so the setting here is where we have n

1479
00:54:47,200 --> 00:54:49,200
parties and they have access to some

1480
00:54:49,200 --> 00:54:51,680
public bulletin board and the goal is

1481
00:54:51,680 --> 00:54:54,880
just to flip an unbiased coin

1482
00:54:54,880 --> 00:54:57,359
and the protocol is really simple

1483
00:54:57,359 --> 00:54:58,319
so

1484
00:54:58,319 --> 00:55:00,720
first they each sample a uniformly

1485
00:55:00,720 --> 00:55:02,480
random value

1486
00:55:02,480 --> 00:55:04,559
they commit to their values using a

1487
00:55:04,559 --> 00:55:06,720
timelock puzzle and post the puzzle on

1488
00:55:06,720 --> 00:55:08,960
the bulletin board

1489
00:55:08,960 --> 00:55:10,799
when all the puzzles have been posted

1490
00:55:10,799 --> 00:55:12,640
they can open their values

1491
00:55:12,640 --> 00:55:15,520
and then just set the output to the xor

1492
00:55:15,520 --> 00:55:18,000
so this is just commit and reveal but

1493
00:55:18,000 --> 00:55:20,000
using timelock puzzles instead of

1494
00:55:20,000 --> 00:55:21,680
commitments

1495
00:55:21,680 --> 00:55:22,559
um

1496
00:55:22,559 --> 00:55:25,040
and when everyone is honest this is

1497
00:55:25,040 --> 00:55:27,200
going to be unbiased right because we're

1498
00:55:27,200 --> 00:55:29,520
just taking the xor of uniformly random

1499
00:55:29,520 --> 00:55:31,760
and independent this

1500
00:55:31,760 --> 00:55:33,920
but actually this gives something more

1501
00:55:33,920 --> 00:55:35,040
which is that

1502
00:55:35,040 --> 00:55:37,920
even an adversary who tries to abort

1503
00:55:37,920 --> 00:55:41,440
early or doesn't open its puzzle

1504
00:55:41,440 --> 00:55:43,920
won't impact the output

1505
00:55:43,920 --> 00:55:46,559
in particular at the end of the protocol

1506
00:55:46,559 --> 00:55:50,079
this is timed um we can just solve any

1507
00:55:50,079 --> 00:55:51,599
unopened puzzle

1508
00:55:51,599 --> 00:55:54,000
so refusing to open doesn't bias the

1509
00:55:54,000 --> 00:55:55,040
output

1510
00:55:55,040 --> 00:55:57,440
and in general without these timing

1511
00:55:57,440 --> 00:55:59,520
assumptions this is actually not

1512
00:55:59,520 --> 00:56:01,520
possible to achieve

1513
00:56:01,520 --> 00:56:03,760
so this is a great starting point

1514
00:56:03,760 --> 00:56:06,319
fairness against aborting adversaries

1515
00:56:06,319 --> 00:56:08,720
and in this work we extend this to

1516
00:56:08,720 --> 00:56:10,559
fairness against fully malicious

1517
00:56:10,559 --> 00:56:13,040
adversaries that behave arbitrarily in

1518
00:56:13,040 --> 00:56:15,200
the protocol

1519
00:56:15,200 --> 00:56:17,119
so let me just give you the high level

1520
00:56:17,119 --> 00:56:19,119
idea of this

1521
00:56:19,119 --> 00:56:20,799
so um

1522
00:56:20,799 --> 00:56:22,960
for the output to be unbiased what we

1523
00:56:22,960 --> 00:56:24,960
really need is the values on the board

1524
00:56:24,960 --> 00:56:26,480
to be independent

1525
00:56:26,480 --> 00:56:28,960
so we need to see how an adversary can

1526
00:56:28,960 --> 00:56:31,359
sample value dishonestly to try and make

1527
00:56:31,359 --> 00:56:32,960
these dependent

1528
00:56:32,960 --> 00:56:34,000
um

1529
00:56:34,000 --> 00:56:35,839
so let's suppose we have one party here

1530
00:56:35,839 --> 00:56:38,240
that's the adversary and let's say the

1531
00:56:38,240 --> 00:56:40,240
adversary waits until everyone else has

1532
00:56:40,240 --> 00:56:42,480
posted their puzzle so this is the point

1533
00:56:42,480 --> 00:56:44,559
where we're at in the protocol

1534
00:56:44,559 --> 00:56:47,119
and let's see what we can do

1535
00:56:47,119 --> 00:56:49,280
so even taking this out of the context

1536
00:56:49,280 --> 00:56:50,799
of the protocol

1537
00:56:50,799 --> 00:56:53,040
basically we have an adversary that is

1538
00:56:53,040 --> 00:56:56,000
receiving or seeing a bunch of puzzles

1539
00:56:56,000 --> 00:56:58,880
and is trying to output his own puzzle

1540
00:56:58,880 --> 00:57:01,119
and i want to ensure that his puzzle

1541
00:57:01,119 --> 00:57:03,200
will be to a value that's independent of

1542
00:57:03,200 --> 00:57:04,880
the input ones

1543
00:57:04,880 --> 00:57:05,760
but

1544
00:57:05,760 --> 00:57:06,640
that's

1545
00:57:06,640 --> 00:57:08,559
not necessarily the case right he could

1546
00:57:08,559 --> 00:57:10,400
just copy the puzzle that's not

1547
00:57:10,400 --> 00:57:13,440
independent um or maybe there's a much

1548
00:57:13,440 --> 00:57:15,200
more complex attack where he could

1549
00:57:15,200 --> 00:57:17,359
combine the input puzzles in different

1550
00:57:17,359 --> 00:57:19,680
ways to get a value that's related to

1551
00:57:19,680 --> 00:57:20,799
all of them

1552
00:57:20,799 --> 00:57:22,400
um

1553
00:57:22,400 --> 00:57:24,240
the point here is that even though the

1554
00:57:24,240 --> 00:57:26,799
security of time-like puzzles hides the

1555
00:57:26,799 --> 00:57:29,440
underlying values it doesn't

1556
00:57:29,440 --> 00:57:31,280
ensure that you can't combine the

1557
00:57:31,280 --> 00:57:34,720
puzzles themselves to one that is uh to

1558
00:57:34,720 --> 00:57:37,200
a related value

1559
00:57:37,200 --> 00:57:39,680
and going back to our protocol if you

1560
00:57:39,680 --> 00:57:42,319
can do this you can clearly always bias

1561
00:57:42,319 --> 00:57:44,240
that output

1562
00:57:44,240 --> 00:57:46,160
so the security notion that prevents

1563
00:57:46,160 --> 00:57:48,040
against this type of attack is called

1564
00:57:48,040 --> 00:57:50,480
non-malleability it's studied in many

1565
00:57:50,480 --> 00:57:53,280
contexts and captures all of these types

1566
00:57:53,280 --> 00:57:55,440
of maybe very complex or arbitrary

1567
00:57:55,440 --> 00:57:56,720
attacks

1568
00:57:56,720 --> 00:57:58,559
and in this work what we do is we

1569
00:57:58,559 --> 00:58:00,640
formalize and construct non-malleable

1570
00:58:00,640 --> 00:58:03,040
timeline puzzles and we show that they

1571
00:58:03,040 --> 00:58:06,480
do give fairness in this protocol

1572
00:58:06,480 --> 00:58:08,160
so my last minute or two i'm just going

1573
00:58:08,160 --> 00:58:10,240
to tell you about our results

1574
00:58:10,240 --> 00:58:12,160
so we give two constructions of time log

1575
00:58:12,160 --> 00:58:14,720
puzzles the first is practically

1576
00:58:14,720 --> 00:58:15,920
efficient

1577
00:58:15,920 --> 00:58:18,799
and it only relies on any underlying

1578
00:58:18,799 --> 00:58:21,599
timelock puzzle in a black box way

1579
00:58:21,599 --> 00:58:24,000
and it's in the random oracle model

1580
00:58:24,000 --> 00:58:26,160
the second one is in the play model but

1581
00:58:26,160 --> 00:58:28,000
it relies on strongest of exponential

1582
00:58:28,000 --> 00:58:29,680
style assumptions so it's really a

1583
00:58:29,680 --> 00:58:31,599
trade-off here between what you want

1584
00:58:31,599 --> 00:58:33,760
assume and what model you want to be in

1585
00:58:33,760 --> 00:58:35,680
um i will emphasize that we don't have

1586
00:58:35,680 --> 00:58:36,880
any setup

1587
00:58:36,880 --> 00:58:39,040
and in particular for our protocol in

1588
00:58:39,040 --> 00:58:41,359
the random oracle model um

1589
00:58:41,359 --> 00:58:43,680
the adversary might receive or is

1590
00:58:43,680 --> 00:58:45,680
allowed to receive non-uniform advice

1591
00:58:45,680 --> 00:58:47,280
about the oracle this is called the

1592
00:58:47,280 --> 00:58:49,839
auxiliary input random oracle model um

1593
00:58:49,839 --> 00:58:52,880
so that's the model that we're in

1594
00:58:52,880 --> 00:58:55,920
and we use these uh constructions to get

1595
00:58:55,920 --> 00:58:58,400
coin multi-party coin flipping against

1596
00:58:58,400 --> 00:59:00,559
malicious adversaries

1597
00:59:00,559 --> 00:59:03,359
in particular our protocol has fairness

1598
00:59:03,359 --> 00:59:05,760
even against parties that adversaries

1599
00:59:05,760 --> 00:59:08,160
that control all but one party

1600
00:59:08,160 --> 00:59:10,720
it also has this really nice efficiency

1601
00:59:10,720 --> 00:59:13,440
property knows as optimistic efficiency

1602
00:59:13,440 --> 00:59:15,520
where if everyone is honest they don't

1603
00:59:15,520 --> 00:59:17,520
need to solve any puzzles

1604
00:59:17,520 --> 00:59:20,000
so in the honest setting we sort of get

1605
00:59:20,000 --> 00:59:22,160
the best type of efficiency for our

1606
00:59:22,160 --> 00:59:23,680
protocol

1607
00:59:23,680 --> 00:59:25,520
we also have a public verifiability

1608
00:59:25,520 --> 00:59:27,440
property so the output can be publicly

1609
00:59:27,440 --> 00:59:29,599
and efficiently verified

1610
00:59:29,599 --> 00:59:31,280
and lastly

1611
00:59:31,280 --> 00:59:32,720
we can also make our protocol

1612
00:59:32,720 --> 00:59:35,280
non-interactive so just you know one

1613
00:59:35,280 --> 00:59:37,440
round of posting puzzles on the board

1614
00:59:37,440 --> 00:59:39,839
just by having everyone solve everyone's

1615
00:59:39,839 --> 00:59:41,599
puzzle so

1616
00:59:41,599 --> 00:59:42,799
depending on what you want it can be

1617
00:59:42,799 --> 00:59:44,319
interactive or not interactive with

1618
00:59:44,319 --> 00:59:46,799
different efficiency trade-offs

1619
00:59:46,799 --> 00:59:48,960
um lastly i'll just note that this is

1620
00:59:48,960 --> 00:59:51,280
the first protocol under any assumption

1621
00:59:51,280 --> 00:59:53,280
that satisfies this combination of

1622
00:59:53,280 --> 00:59:55,760
fairness and optimistic efficiency for

1623
00:59:55,760 --> 00:59:58,400
this incredibly fundamental task of coin

1624
00:59:58,400 --> 01:00:00,160
flipping

1625
01:00:00,160 --> 01:00:02,480
um so we have a bunch of other results

1626
01:00:02,480 --> 01:00:05,119
feel free to see the paper for those or

1627
01:00:05,119 --> 01:00:06,640
come talk to me

1628
01:00:06,640 --> 01:00:08,400
and that's it so thank you for listening

1629
01:00:08,400 --> 01:00:12,680
and i'm happy to take any questions

1630
01:00:15,520 --> 01:00:18,559
questions for naomi

1631
01:00:20,799 --> 01:00:22,960
i believe there is a question online

1632
01:00:22,960 --> 01:00:25,520
although forgive me if it's not for this

1633
01:00:25,520 --> 01:00:27,760
talk um

1634
01:00:27,760 --> 01:00:29,920
i think uh it's from richard outer

1635
01:00:29,920 --> 01:00:32,480
bridge and it is for this talk

1636
01:00:32,480 --> 01:00:34,720
it is great thank you

1637
01:00:34,720 --> 01:00:37,040
would you like to ask it verbally

1638
01:00:37,040 --> 01:00:38,400
yes

1639
01:00:38,400 --> 01:00:40,480
if i can remember it with regard to

1640
01:00:40,480 --> 01:00:42,400
timing

1641
01:00:42,400 --> 01:00:44,319
where do each

1642
01:00:44,319 --> 01:00:46,000
or even all

1643
01:00:46,000 --> 01:00:47,920
of the participants

1644
01:00:47,920 --> 01:00:49,920
get their

1645
01:00:49,920 --> 01:00:52,160
trusted or secure

1646
01:00:52,160 --> 01:00:54,799
time from

1647
01:00:54,799 --> 01:00:56,480
so that's definitely up to the

1648
01:00:56,480 --> 01:00:58,480
application and how this protocol is

1649
01:00:58,480 --> 01:01:01,599
being used we do need you know some sort

1650
01:01:01,599 --> 01:01:04,799
of shared clock or a way to uh you know

1651
01:01:04,799 --> 01:01:07,040
no elapsed time so that is the model

1652
01:01:07,040 --> 01:01:09,920
that we're in um we don't deal with the

1653
01:01:09,920 --> 01:01:11,680
details of that in this works because

1654
01:01:11,680 --> 01:01:14,880
it's really up to the application

1655
01:01:14,880 --> 01:01:17,200
okay

1656
01:01:19,839 --> 01:01:22,319
further questions

1657
01:01:22,319 --> 01:01:25,319
um

1658
01:01:40,720 --> 01:01:42,799
um that's definitely a great question

1659
01:01:42,799 --> 01:01:45,119
and an open question and hopefully

1660
01:01:45,119 --> 01:01:46,799
future work for this the question was

1661
01:01:46,799 --> 01:01:49,440
whether you could extend beyond uh

1662
01:01:49,440 --> 01:01:52,240
applications to fully secure a secure

1663
01:01:52,240 --> 01:01:55,240
competition

1664
01:02:11,200 --> 01:02:13,119
so the question was what do you do if

1665
01:02:13,119 --> 01:02:16,880
someone just copies the puzzle um so we

1666
01:02:16,880 --> 01:02:19,280
can just disallow that by you know

1667
01:02:19,280 --> 01:02:22,240
replacing any copied puzzle with a dummy

1668
01:02:22,240 --> 01:02:23,920
value um

1669
01:02:23,920 --> 01:02:26,559
in general in non-malleability you

1670
01:02:26,559 --> 01:02:29,760
almost always have this

1671
01:02:30,240 --> 01:02:33,280
this like setting where if the adversary

1672
01:02:33,280 --> 01:02:35,839
copies we ignore what he did

1673
01:02:35,839 --> 01:02:38,000
but otherwise he's allowed to do any

1674
01:02:38,000 --> 01:02:40,720
sort of attack

1675
01:02:41,920 --> 01:02:46,200
all right let's thank you again

1676
01:03:08,160 --> 01:03:09,839
okay we are now ready for the final talk

1677
01:03:09,839 --> 01:03:12,240
in this session um about rate one

1678
01:03:12,240 --> 01:03:14,400
quantum fully homomorphic encryption

1679
01:03:14,400 --> 01:03:16,480
this is a joint work between arresters

1680
01:03:16,480 --> 01:03:18,400
charges

1681
01:03:18,400 --> 01:03:21,440
nico dotling and julio malatova and

1682
01:03:21,440 --> 01:03:25,119
westeros will be giving the presentation

1683
01:03:25,440 --> 01:03:28,240
uh thank you for the introduction so

1684
01:03:28,240 --> 01:03:31,839
this is the work with nicodemus

1685
01:03:31,839 --> 01:03:33,599
titled rate one point two three four

1686
01:03:33,599 --> 01:03:36,400
more from encryption

1687
01:03:39,119 --> 01:03:42,400
i'm not sure what i did sorry

1688
01:03:42,400 --> 01:03:45,400
um

1689
01:03:54,000 --> 01:03:56,640
okay sure that makes sense um okay to

1690
01:03:56,640 --> 01:03:58,640
begin with i'm gonna define free

1691
01:03:58,640 --> 01:04:01,200
homework encryption or an fht scheme and

1692
01:04:01,200 --> 01:04:02,799
what basically is it's an encryption

1693
01:04:02,799 --> 01:04:04,880
scheme where if we have values involved

1694
01:04:04,880 --> 01:04:07,280
alice can send an encrypted message such

1695
01:04:07,280 --> 01:04:09,359
that later bob can compute the

1696
01:04:09,359 --> 01:04:11,680
encryption of f of m for an arbitrary

1697
01:04:11,680 --> 01:04:13,119
function and

1698
01:04:13,119 --> 01:04:14,160
yeah

1699
01:04:14,160 --> 01:04:16,160
so basically bob can uh perform

1700
01:04:16,160 --> 01:04:18,319
computations under encryption

1701
01:04:18,319 --> 01:04:19,599
and the setting where this is very

1702
01:04:19,599 --> 01:04:22,559
interesting is useful if we if we have

1703
01:04:22,559 --> 01:04:24,880
a client a weaker client that wants to

1704
01:04:24,880 --> 01:04:26,400
outsource computations to a more

1705
01:04:26,400 --> 01:04:28,079
powerful server that's why in the figure

1706
01:04:28,079 --> 01:04:29,680
clark ken is supposed to be the weaker

1707
01:04:29,680 --> 01:04:33,039
client and superman more powerful server

1708
01:04:33,039 --> 01:04:34,720
of course in a setting like this we want

1709
01:04:34,720 --> 01:04:36,720
to achieve security so first of all we

1710
01:04:36,720 --> 01:04:38,799
want security for alice which means that

1711
01:04:38,799 --> 01:04:40,960
her message m must remain hidden from

1712
01:04:40,960 --> 01:04:43,039
bob so both given encryptions of two

1713
01:04:43,039 --> 01:04:44,240
different messages cannot tell them

1714
01:04:44,240 --> 01:04:45,599
apart

1715
01:04:45,599 --> 01:04:48,319
but we also want security for bob or the

1716
01:04:48,319 --> 01:04:49,520
server

1717
01:04:49,520 --> 01:04:52,079
which translates into circuit privacy so

1718
01:04:52,079 --> 01:04:54,799
this means that we want for the circuit

1719
01:04:54,799 --> 01:04:57,200
used for the homework computation

1720
01:04:57,200 --> 01:05:00,960
to be um hidden from ios

1721
01:05:00,960 --> 01:05:02,720
when talking about circuit privacy we

1722
01:05:02,720 --> 01:05:04,960
can refer to either semi on a circuit

1723
01:05:04,960 --> 01:05:06,799
privacy which is basically circuit

1724
01:05:06,799 --> 01:05:09,520
privacy for only one for messages from

1725
01:05:09,520 --> 01:05:12,160
alice or to this stronger notion of

1726
01:05:12,160 --> 01:05:14,720
monolith's circuit privacy where circuit

1727
01:05:14,720 --> 01:05:16,640
privacy holds for any arbitrary message

1728
01:05:16,640 --> 01:05:18,079
provides

1729
01:05:18,079 --> 01:05:20,240
for classical efficiency schemes

1730
01:05:20,240 --> 01:05:22,960
uh in this paper by a source can always

1731
01:05:22,960 --> 01:05:23,760
so

1732
01:05:23,760 --> 01:05:25,839
how to convert any seminars or private

1733
01:05:25,839 --> 01:05:27,680
efficiency into analysis over private

1734
01:05:27,680 --> 01:05:29,200
land

1735
01:05:29,200 --> 01:05:31,119
now apart from security we also want to

1736
01:05:31,119 --> 01:05:33,119
achieve efficiency especially if we want

1737
01:05:33,119 --> 01:05:35,520
to use these uh protocols into relax

1738
01:05:35,520 --> 01:05:37,440
systems and the problem is that because

1739
01:05:37,440 --> 01:05:39,440
of security reasons there is a

1740
01:05:39,440 --> 01:05:41,920
communication overhead it reduced

1741
01:05:41,920 --> 01:05:44,000
to the messaging from the server to the

1742
01:05:44,000 --> 01:05:46,240
client and we want for this overhead to

1743
01:05:46,240 --> 01:05:48,079
not be too big so as to notify the

1744
01:05:48,079 --> 01:05:49,440
efficiency of outsourcing the

1745
01:05:49,440 --> 01:05:52,000
computations in the first place

1746
01:05:52,000 --> 01:05:54,000
so usually what we need is communication

1747
01:05:54,000 --> 01:05:55,520
complex to be compact which means

1748
01:05:55,520 --> 01:05:57,359
independent of the size of the circuit

1749
01:05:57,359 --> 01:06:00,079
so as not to get exponentially bigger

1750
01:06:00,079 --> 01:06:02,400
and this is usually enough and

1751
01:06:02,400 --> 01:06:04,240
thus efficiency schemes are useful in

1752
01:06:04,240 --> 01:06:06,559
many applications that are secure

1753
01:06:06,559 --> 01:06:07,839
function evaluation or accepted

1754
01:06:07,839 --> 01:06:09,200
databases

1755
01:06:09,200 --> 01:06:11,119
and the best communication complexity of

1756
01:06:11,119 --> 01:06:13,039
an fat scheme was constructed in this

1757
01:06:13,039 --> 01:06:15,359
paper by process canal

1758
01:06:15,359 --> 01:06:16,799
where they

1759
01:06:16,799 --> 01:06:18,720
their complex approach is the one of the

1760
01:06:18,720 --> 01:06:20,720
insecure protocol where alice would just

1761
01:06:20,720 --> 01:06:23,520
send her message in plain

1762
01:06:23,520 --> 01:06:24,799
now a metric that we use for

1763
01:06:24,799 --> 01:06:26,960
communication complexity is rage rate is

1764
01:06:26,960 --> 01:06:29,520
basically the message to ciphertex ratio

1765
01:06:29,520 --> 01:06:32,079
or to be a bit more technical it's the

1766
01:06:32,079 --> 01:06:34,240
size of the uh

1767
01:06:34,240 --> 01:06:36,160
computed data in plane over the size of

1768
01:06:36,160 --> 01:06:38,880
the homework of the data

1769
01:06:38,880 --> 01:06:40,960
and when we refer to a rate 1 scheme

1770
01:06:40,960 --> 01:06:42,880
like i did in the title we refer to

1771
01:06:42,880 --> 01:06:45,359
skins that asymptotically approach rate

1772
01:06:45,359 --> 01:06:46,880
one

1773
01:06:46,880 --> 01:06:49,359
just like we want from requesting now so

1774
01:06:49,359 --> 01:06:53,359
we have a minimal communication complex

1775
01:06:53,359 --> 01:06:55,440
now if we move into the quantum stating

1776
01:06:55,440 --> 01:06:57,599
we also have quantum physical encryption

1777
01:06:57,599 --> 01:06:59,039
schemes which are basically the same

1778
01:06:59,039 --> 01:07:00,559
thing but instead of classical messages

1779
01:07:00,559 --> 01:07:03,119
so we have quantum messages and both

1780
01:07:03,119 --> 01:07:05,280
having both kind of big quantum

1781
01:07:05,280 --> 01:07:06,880
mass lessons is known for the quantum

1782
01:07:06,880 --> 01:07:08,960
setting but we think that it's even more

1783
01:07:08,960 --> 01:07:10,400
interesting

1784
01:07:10,400 --> 01:07:12,400
due to the large gap between the quantum

1785
01:07:12,400 --> 01:07:15,039
capabilities of regular users and

1786
01:07:15,039 --> 01:07:17,520
servers on the cloud in the future

1787
01:07:17,520 --> 01:07:20,400
and the more interesting case is if

1788
01:07:20,400 --> 01:07:22,400
the reality with the final output from

1789
01:07:22,400 --> 01:07:24,640
the server is a quantum state because if

1790
01:07:24,640 --> 01:07:25,920
it's classical maybe we can use

1791
01:07:25,920 --> 01:07:27,839
classical techniques to get minimal

1792
01:07:27,839 --> 01:07:29,039
communication complexity about what

1793
01:07:29,039 --> 01:07:31,440
happens if it's quantum and the question

1794
01:07:31,440 --> 01:07:34,000
is can we get magnesium to secure fht

1795
01:07:34,000 --> 01:07:35,440
schemes in the quantum setting with

1796
01:07:35,440 --> 01:07:37,599
minimal communication complexity

1797
01:07:37,599 --> 01:07:40,000
and that's exactly what we answer

1798
01:07:40,000 --> 01:07:42,400
in this paper and what we construct in

1799
01:07:42,400 --> 01:07:45,280
order to do this we have two

1800
01:07:45,280 --> 01:07:47,359
main technical steps first we construct

1801
01:07:47,359 --> 01:07:49,599
a monolithic circuit private quantum

1802
01:07:49,599 --> 01:07:51,920
field t and we also construct a rate one

1803
01:07:51,920 --> 01:07:53,599
quantum method see this can be of

1804
01:07:53,599 --> 01:07:56,079
individual interest but they are

1805
01:07:56,079 --> 01:07:58,000
compatible we can combine them for final

1806
01:07:58,000 --> 01:07:59,039
result

1807
01:07:59,039 --> 01:08:01,280
and to do this we assume only standard

1808
01:08:01,280 --> 01:08:04,079
lwe with a polynomial modulus in noise

1809
01:08:04,079 --> 01:08:05,839
ratio

1810
01:08:05,839 --> 01:08:06,720
and

1811
01:08:06,720 --> 01:08:09,560
that's it thank you

1812
01:08:09,560 --> 01:08:12,710
[Applause]

1813
01:08:14,480 --> 01:08:17,038
questions

1814
01:08:19,600 --> 01:08:23,439
any thoughts on what the next step is

1815
01:08:23,439 --> 01:08:25,839
um

1816
01:08:28,960 --> 01:08:31,439
so the like this

1817
01:08:31,439 --> 01:08:33,040
we have a specific application in mind

1818
01:08:33,040 --> 01:08:35,279
this is basically to match

1819
01:08:35,279 --> 01:08:37,040
the communication flex of the classical

1820
01:08:37,040 --> 01:08:39,679
counterpart in the quantum setting but i

1821
01:08:39,679 --> 01:08:41,198
think that this can have many

1822
01:08:41,198 --> 01:08:42,880
applications especially

1823
01:08:42,880 --> 01:08:44,799
in the future where it could be used for

1824
01:08:44,799 --> 01:08:47,519
in real life

1825
01:08:49,120 --> 01:08:51,520
okay so no further questions and we'll

1826
01:08:51,520 --> 01:08:55,080
conclude this

