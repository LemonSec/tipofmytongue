1
00:00:01,040 --> 00:00:02,480
hi

2
00:00:02,480 --> 00:00:04,319
i'm joseph

3
00:00:04,319 --> 00:00:06,399
and i'll be talking about some work i

4
00:00:06,399 --> 00:00:08,400
did with the fang song and stefano

5
00:00:08,400 --> 00:00:09,760
tesaro

6
00:00:09,760 --> 00:00:11,920
trying to understand the security of key

7
00:00:11,920 --> 00:00:14,400
length extension techniques against

8
00:00:14,400 --> 00:00:17,440
quantum attackers

9
00:00:17,440 --> 00:00:19,520
so

10
00:00:19,520 --> 00:00:21,840
quantum computers

11
00:00:21,840 --> 00:00:23,199
lots of money

12
00:00:23,199 --> 00:00:25,840
time and other resources are being spent

13
00:00:25,840 --> 00:00:28,720
these days trying to build computers

14
00:00:28,720 --> 00:00:32,000
which exploit quantum physics

15
00:00:32,000 --> 00:00:35,040
should these become a usable reality

16
00:00:35,040 --> 00:00:36,960
they'll really be introducing a form of

17
00:00:36,960 --> 00:00:38,800
computation which is fundamentally

18
00:00:38,800 --> 00:00:41,040
different than what we're used to

19
00:00:41,040 --> 00:00:43,120
which will have various implications for

20
00:00:43,120 --> 00:00:47,360
the security of cryptographic algorithms

21
00:00:47,360 --> 00:00:49,520
perhaps the most commonly discussed of

22
00:00:49,520 --> 00:00:50,640
these

23
00:00:50,640 --> 00:00:53,120
is that shaw's algorithm for factoring

24
00:00:53,120 --> 00:00:54,640
in discrete log

25
00:00:54,640 --> 00:00:57,039
will completely break the security

26
00:00:57,039 --> 00:00:59,359
of much of today's public key

27
00:00:59,359 --> 00:01:02,160
cryptography

28
00:01:03,039 --> 00:01:04,720
grover's search

29
00:01:04,720 --> 00:01:07,200
is a second important algorithm

30
00:01:07,200 --> 00:01:09,360
which will effectively reduce the key

31
00:01:09,360 --> 00:01:12,640
size of various secret key cryptographic

32
00:01:12,640 --> 00:01:15,200
algorithms by half

33
00:01:15,200 --> 00:01:17,600
the point here is that if we have a key

34
00:01:17,600 --> 00:01:19,439
of length k

35
00:01:19,439 --> 00:01:21,920
a kind of classical brute force attack

36
00:01:21,920 --> 00:01:24,479
will take time 2 to the k

37
00:01:24,479 --> 00:01:26,159
while in the quantum setting we can do

38
00:01:26,159 --> 00:01:28,080
this sort of attack in time 2 to the k

39
00:01:28,080 --> 00:01:29,759
over 2

40
00:01:29,759 --> 00:01:31,360
meaning that something which provided

41
00:01:31,360 --> 00:01:34,000
128 bits of security may now only

42
00:01:34,000 --> 00:01:36,960
provide 64 bits of security which might

43
00:01:36,960 --> 00:01:40,199
be insufficient

44
00:01:40,240 --> 00:01:41,200
so

45
00:01:41,200 --> 00:01:43,759
if we find ourselves using a scheme

46
00:01:43,759 --> 00:01:45,600
with keys that are too short there are

47
00:01:45,600 --> 00:01:48,159
two approaches we might use

48
00:01:48,159 --> 00:01:50,640
to deal with this the first is to design

49
00:01:50,640 --> 00:01:53,360
new schemes which just inherently have

50
00:01:53,360 --> 00:01:55,600
longer keys

51
00:01:55,600 --> 00:01:57,040
the second approach which will be the

52
00:01:57,040 --> 00:01:58,719
focus of this paper

53
00:01:58,719 --> 00:02:01,040
is designing key lathe extension

54
00:02:01,040 --> 00:02:02,399
techniques

55
00:02:02,399 --> 00:02:04,719
where we take a given scheme and apply

56
00:02:04,719 --> 00:02:06,880
some sort of transform

57
00:02:06,880 --> 00:02:09,199
which uses the scheme with more keying

58
00:02:09,199 --> 00:02:12,799
material to encrypt our data

59
00:02:13,840 --> 00:02:16,160
we ran into this previously with des

60
00:02:16,160 --> 00:02:18,400
that had very short keys

61
00:02:18,400 --> 00:02:21,280
and led to the design of a variety of

62
00:02:21,280 --> 00:02:23,920
algorithms that use longer keys

63
00:02:23,920 --> 00:02:26,480
as well as the analysis of various key

64
00:02:26,480 --> 00:02:28,319
length extension techniques which would

65
00:02:28,319 --> 00:02:31,280
let us keep using des but augmenting it

66
00:02:31,280 --> 00:02:34,480
to have longer keys

67
00:02:34,560 --> 00:02:36,400
if we want to analyze the security of

68
00:02:36,400 --> 00:02:38,160
these things what we'll be focusing on

69
00:02:38,160 --> 00:02:40,800
this paper is pseudorandom permutations

70
00:02:40,800 --> 00:02:42,400
and prfs

71
00:02:42,400 --> 00:02:44,560
so just to remind you in this setting

72
00:02:44,560 --> 00:02:46,560
we're thinking of an adversary which has

73
00:02:46,560 --> 00:02:48,000
oracle access

74
00:02:48,000 --> 00:02:51,120
either to the actual scheme in question

75
00:02:51,120 --> 00:02:54,080
or to a random permutation

76
00:02:54,080 --> 00:02:56,640
or in the case of prf security a random

77
00:02:56,640 --> 00:02:58,959
function

78
00:02:58,959 --> 00:03:00,800
the advantage of the adversary is just

79
00:03:00,800 --> 00:03:02,480
the difference in the probability that

80
00:03:02,480 --> 00:03:07,040
it outputs one in these two settings

81
00:03:08,959 --> 00:03:10,879
and you know since in this work we'll be

82
00:03:10,879 --> 00:03:13,760
working in ideal models which means that

83
00:03:13,760 --> 00:03:16,000
the adversary will also have oracle

84
00:03:16,000 --> 00:03:16,959
access

85
00:03:16,959 --> 00:03:19,840
to some random oracle or ideal cipher or

86
00:03:19,840 --> 00:03:22,640
something like that

87
00:03:22,800 --> 00:03:24,560
it's useful to remember

88
00:03:24,560 --> 00:03:27,920
that the adversaries code as well as all

89
00:03:27,920 --> 00:03:30,480
of its queries to the ideal primitive

90
00:03:30,480 --> 00:03:32,480
are thought of as local computation

91
00:03:32,480 --> 00:03:35,680
occurring on the adversary's computer

92
00:03:35,680 --> 00:03:37,599
whereas the other oracle queries are

93
00:03:37,599 --> 00:03:39,840
kind of external computation

94
00:03:39,840 --> 00:03:42,959
being performed by whoever the adversary

95
00:03:42,959 --> 00:03:45,519
is attacking

96
00:03:45,519 --> 00:03:46,799
with this perspective when we're

97
00:03:46,799 --> 00:03:48,959
thinking about quantum security there's

98
00:03:48,959 --> 00:03:51,200
really three levels of security we might

99
00:03:51,200 --> 00:03:52,400
think about

100
00:03:52,400 --> 00:03:54,319
the first is normal class of social

101
00:03:54,319 --> 00:03:55,519
security

102
00:03:55,519 --> 00:03:57,599
we're both the adversary and the honest

103
00:03:57,599 --> 00:04:00,480
users computers are completely classical

104
00:04:00,480 --> 00:04:02,560
nothing quantum is happening here this

105
00:04:02,560 --> 00:04:05,599
is the typical model

106
00:04:05,760 --> 00:04:07,519
a second model that people consider is

107
00:04:07,519 --> 00:04:09,120
what i'll call the partially quantum

108
00:04:09,120 --> 00:04:12,159
model here the adversary has access to

109
00:04:12,159 --> 00:04:14,799
some quantum computer meaning that its

110
00:04:14,799 --> 00:04:16,880
local computation is quantum

111
00:04:16,880 --> 00:04:19,440
including superposition queries to this

112
00:04:19,440 --> 00:04:21,440
ideal primitive

113
00:04:21,440 --> 00:04:24,240
but that the user's honest computation

114
00:04:24,240 --> 00:04:28,080
is still being done classically

115
00:04:28,080 --> 00:04:29,520
in the short term

116
00:04:29,520 --> 00:04:31,680
this security notion seems sufficient

117
00:04:31,680 --> 00:04:36,400
for any practical uses of cryptography

118
00:04:36,400 --> 00:04:38,800
and then going beyond that we obtain the

119
00:04:38,800 --> 00:04:40,960
fully quantum model where all of the

120
00:04:40,960 --> 00:04:43,600
computation is quantum meaning that all

121
00:04:43,600 --> 00:04:46,320
of the queries made by the adversary can

122
00:04:46,320 --> 00:04:49,840
be done in superposition

123
00:04:50,800 --> 00:04:52,639
throughout the rest of the talk i'll be

124
00:04:52,639 --> 00:04:55,199
using q to denote the number of queries

125
00:04:55,199 --> 00:04:57,199
that the attacker makes to the external

126
00:04:57,199 --> 00:04:58,800
computation

127
00:04:58,800 --> 00:05:01,600
p to denote its

128
00:05:01,600 --> 00:05:04,320
internal queries to ideal primitives

129
00:05:04,320 --> 00:05:05,840
and when i need to write advantage

130
00:05:05,840 --> 00:05:08,320
functions i will prefix them with a c or

131
00:05:08,320 --> 00:05:11,440
p q or q to denote which sort of

132
00:05:11,440 --> 00:05:14,400
security that advantage is with respect

133
00:05:14,400 --> 00:05:16,560
to

134
00:05:17,600 --> 00:05:18,880
given this

135
00:05:18,880 --> 00:05:20,320
let me kind of give you the brief

136
00:05:20,320 --> 00:05:22,320
overview of the different techniques we

137
00:05:22,320 --> 00:05:24,880
consider in our paper the first is

138
00:05:24,880 --> 00:05:27,680
called fx

139
00:05:27,680 --> 00:05:30,000
and this augments a block cipher

140
00:05:30,000 --> 00:05:32,240
with an extra key k2

141
00:05:32,240 --> 00:05:34,400
which gets xored into the input of the

142
00:05:34,400 --> 00:05:37,440
block cipher and into its output

143
00:05:37,440 --> 00:05:39,360
this was analyzed in the classical

144
00:05:39,360 --> 00:05:41,680
setting by killian and ragaway who

145
00:05:41,680 --> 00:05:44,320
showed that it was indeed a sound

146
00:05:44,320 --> 00:05:48,320
technique for key length extension

147
00:05:48,320 --> 00:05:49,840
however if we go all the way to the

148
00:05:49,840 --> 00:05:51,440
fully quantum

149
00:05:51,440 --> 00:05:52,720
setting

150
00:05:52,720 --> 00:05:55,919
some clever attacks combining

151
00:05:55,919 --> 00:05:58,319
multiple different quantum algorithms

152
00:05:58,319 --> 00:06:00,240
so that this is actually

153
00:06:00,240 --> 00:06:02,400
not a sound key length extension

154
00:06:02,400 --> 00:06:03,520
technique

155
00:06:03,520 --> 00:06:05,520
it's no more secure than if we were just

156
00:06:05,520 --> 00:06:06,720
using

157
00:06:06,720 --> 00:06:10,240
e by itself without this extra xoring

158
00:06:10,240 --> 00:06:12,800
however these techniques seem to in some

159
00:06:12,800 --> 00:06:15,440
sense fundamentally require quantum

160
00:06:15,440 --> 00:06:18,319
access to all of the adversaries oracles

161
00:06:18,319 --> 00:06:20,479
which raises an obvious question what

162
00:06:20,479 --> 00:06:23,680
happens at a partially quantum setting

163
00:06:23,680 --> 00:06:26,000
we address this in our work

164
00:06:26,000 --> 00:06:29,280
giving a proof that it is indeed a sound

165
00:06:29,280 --> 00:06:31,120
key length extension technique in this

166
00:06:31,120 --> 00:06:33,039
setting

167
00:06:33,039 --> 00:06:35,039
though for technical reasons due to the

168
00:06:35,039 --> 00:06:37,199
difficulty of quantum analysis of

169
00:06:37,199 --> 00:06:39,680
schemes based on random permutations we

170
00:06:39,680 --> 00:06:41,440
were only able to show this against

171
00:06:41,440 --> 00:06:43,199
non-adaptive attacks

172
00:06:43,199 --> 00:06:46,080
which decide all of their queries

173
00:06:46,080 --> 00:06:50,719
to the external function ahead of time

174
00:06:51,120 --> 00:06:53,199
to kind of pick away at how we might

175
00:06:53,199 --> 00:06:55,680
analyze the adaptive setting

176
00:06:55,680 --> 00:06:57,680
we looked at a related key length

177
00:06:57,680 --> 00:06:59,840
extension technique which we call

178
00:06:59,840 --> 00:07:01,599
function f x

179
00:07:01,599 --> 00:07:03,120
which just

180
00:07:03,120 --> 00:07:06,080
replaces the block cipher with instead a

181
00:07:06,080 --> 00:07:08,319
random function and we consider prf

182
00:07:08,319 --> 00:07:10,240
security

183
00:07:10,240 --> 00:07:11,919
and here because you can only evaluate

184
00:07:11,919 --> 00:07:13,759
things in one direction we only need to

185
00:07:13,759 --> 00:07:16,400
do the xor of k2 to the input and not

186
00:07:16,400 --> 00:07:18,960
the output

187
00:07:20,000 --> 00:07:22,400
for this scheme we give a proof that it

188
00:07:22,400 --> 00:07:25,120
has fully adaptive security in the

189
00:07:25,120 --> 00:07:28,720
partially quantum setting

190
00:07:29,120 --> 00:07:31,440
the final technique that we consider is

191
00:07:31,440 --> 00:07:33,120
double encryption

192
00:07:33,120 --> 00:07:34,880
where you just apply your block cipher

193
00:07:34,880 --> 00:07:38,719
twice with independent keys

194
00:07:39,039 --> 00:07:40,880
you may be aware that in the classical

195
00:07:40,880 --> 00:07:44,240
setting this is actually no more secure

196
00:07:44,240 --> 00:07:46,400
than single encryption because of the me

197
00:07:46,400 --> 00:07:48,639
in the middle attack

198
00:07:48,639 --> 00:07:50,479
given that it might be surprising to

199
00:07:50,479 --> 00:07:51,440
hear

200
00:07:51,440 --> 00:07:54,400
that despite this in the quantum setting

201
00:07:54,400 --> 00:07:56,960
it actually is a sound

202
00:07:56,960 --> 00:07:58,960
kinetic extension technique

203
00:07:58,960 --> 00:08:01,440
the kind of high level idea of why this

204
00:08:01,440 --> 00:08:02,800
is possible

205
00:08:02,800 --> 00:08:04,639
is that the savings from a meat in the

206
00:08:04,639 --> 00:08:06,160
middle attack and the savings from

207
00:08:06,160 --> 00:08:08,720
grover search in some senses can't be

208
00:08:08,720 --> 00:08:10,960
combined together

209
00:08:10,960 --> 00:08:14,080
so either one lets you have the key

210
00:08:14,080 --> 00:08:16,639
length of double encryption

211
00:08:16,639 --> 00:08:20,879
but you can't combine them to quarter it

212
00:08:22,319 --> 00:08:24,879
more concretely

213
00:08:24,879 --> 00:08:28,879
these three proofs are the contributions

214
00:08:28,879 --> 00:08:30,400
of our paper

215
00:08:30,400 --> 00:08:32,559
the security bounds we prove

216
00:08:32,559 --> 00:08:34,240
look like this

217
00:08:34,240 --> 00:08:36,159
i won't be kind of delving into the

218
00:08:36,159 --> 00:08:39,120
details of exactly what they say but the

219
00:08:39,120 --> 00:08:40,799
high level takeaway

220
00:08:40,799 --> 00:08:41,839
is that

221
00:08:41,839 --> 00:08:45,200
the insides of these various routes

222
00:08:45,200 --> 00:08:48,160
are what we expect based on the best

223
00:08:48,160 --> 00:08:50,080
known attacks

224
00:08:50,080 --> 00:08:51,279
they kind of give us the right

225
00:08:51,279 --> 00:08:54,080
parameters for achieving a security of

226
00:08:54,080 --> 00:08:56,399
around one

227
00:08:56,399 --> 00:08:58,080
there would be an interesting direction

228
00:08:58,080 --> 00:09:00,720
for future research to see if these

229
00:09:00,720 --> 00:09:02,560
various routes could be improved and

230
00:09:02,560 --> 00:09:04,240
gotten rid of

231
00:09:04,240 --> 00:09:06,800
in terms of techniques

232
00:09:06,800 --> 00:09:09,519
our first non-adaptive proof

233
00:09:09,519 --> 00:09:12,160
relies just on a careful application of

234
00:09:12,160 --> 00:09:15,440
so-called one way to hiding results

235
00:09:15,440 --> 00:09:18,320
our adapter proof for ffx

236
00:09:18,320 --> 00:09:20,560
uses both one way to hiding

237
00:09:20,560 --> 00:09:22,640
and xander's technique for lazily

238
00:09:22,640 --> 00:09:26,640
sampling a random function

239
00:09:26,720 --> 00:09:29,279
finally our fully quantum proof for

240
00:09:29,279 --> 00:09:30,959
double encryption

241
00:09:30,959 --> 00:09:33,760
relies on a recently discovered

242
00:09:33,760 --> 00:09:36,320
reduction to a worst list disjointness

243
00:09:36,320 --> 00:09:37,600
problem

244
00:09:37,600 --> 00:09:39,920
and then quantum analysis of the

245
00:09:39,920 --> 00:09:43,599
hardness of list destroying this

246
00:09:44,640 --> 00:09:46,800
i'll delve into these one at a time in

247
00:09:46,800 --> 00:09:49,440
slightly more detail

248
00:09:49,440 --> 00:09:52,320
starting with fx recall fx was the

249
00:09:52,320 --> 00:09:54,640
construction where we xor into the input

250
00:09:54,640 --> 00:09:57,600
and the output of the block cipher

251
00:09:57,600 --> 00:10:00,399
this was originally proposed for des by

252
00:10:00,399 --> 00:10:02,480
reversed

253
00:10:02,480 --> 00:10:04,959
and generalized and proven sound in the

254
00:10:04,959 --> 00:10:06,800
classical setting by kellyanne and right

255
00:10:06,800 --> 00:10:09,200
away

256
00:10:09,200 --> 00:10:11,680
if we consider the special case

257
00:10:11,680 --> 00:10:13,839
where the key length of the block cipher

258
00:10:13,839 --> 00:10:15,519
is zero meaning it's really just a

259
00:10:15,519 --> 00:10:17,519
random permutation

260
00:10:17,519 --> 00:10:19,920
this is the evan mansour construction of

261
00:10:19,920 --> 00:10:23,279
a block cipher from a random permutation

262
00:10:23,279 --> 00:10:25,040
and when i discuss the proof in the next

263
00:10:25,040 --> 00:10:27,519
slides i'll just be focusing on this

264
00:10:27,519 --> 00:10:28,720
case

265
00:10:28,720 --> 00:10:30,959
adding in also this key of the block

266
00:10:30,959 --> 00:10:32,880
cipher doesn't

267
00:10:32,880 --> 00:10:34,880
add anything too interesting to the

268
00:10:34,880 --> 00:10:36,959
analysis

269
00:10:36,959 --> 00:10:39,600
so like i said this analysis is based on

270
00:10:39,600 --> 00:10:41,760
one way to hiding results the kind of

271
00:10:41,760 --> 00:10:44,160
high level takeaway of these theorems

272
00:10:44,160 --> 00:10:46,000
is that if you can distinguish between

273
00:10:46,000 --> 00:10:48,640
two oracles you must be able to find

274
00:10:48,640 --> 00:10:52,319
inputs where they differ

275
00:10:52,480 --> 00:10:54,320
which is formalized by considering an

276
00:10:54,320 --> 00:10:57,200
adversary which has either oracle access

277
00:10:57,200 --> 00:11:01,519
right permutation g or a permutation h

278
00:11:01,519 --> 00:11:03,440
it outputs a bit and its advantage is

279
00:11:03,440 --> 00:11:05,200
the difference in the probability that

280
00:11:05,200 --> 00:11:06,959
it outputs one

281
00:11:06,959 --> 00:11:09,680
we also associate to g and h

282
00:11:09,680 --> 00:11:12,160
some auxiliary string z which is given

283
00:11:12,160 --> 00:11:13,680
to the adversary

284
00:11:13,680 --> 00:11:15,440
and i set s

285
00:11:15,440 --> 00:11:18,000
where the guarantee is that g

286
00:11:18,000 --> 00:11:19,519
and h

287
00:11:19,519 --> 00:11:24,800
agree on all points x that are not in s

288
00:11:25,760 --> 00:11:28,959
then given some distinguishing adversary

289
00:11:28,959 --> 00:11:30,320
a

290
00:11:30,320 --> 00:11:33,360
we can design a new algorithm b

291
00:11:33,360 --> 00:11:35,839
which picks a random index

292
00:11:35,839 --> 00:11:38,800
runs the attack a

293
00:11:38,800 --> 00:11:41,600
and then halts after the ith query

294
00:11:41,600 --> 00:11:44,160
and measures what a

295
00:11:44,160 --> 00:11:46,640
queried

296
00:11:48,320 --> 00:11:50,000
the version of the

297
00:11:50,000 --> 00:11:52,320
one-way de-hiding resource that we use

298
00:11:52,320 --> 00:11:54,480
tells us that if a makes the most q

299
00:11:54,480 --> 00:11:56,800
quantum is to its oracle

300
00:11:56,800 --> 00:11:58,639
then its distinguishing advantage is

301
00:11:58,639 --> 00:12:01,600
bounded by 2 times q times the square

302
00:12:01,600 --> 00:12:02,480
root

303
00:12:02,480 --> 00:12:04,160
of the probability

304
00:12:04,160 --> 00:12:06,720
that this algorithm b

305
00:12:06,720 --> 00:12:09,440
outputs some x which is in the set s

306
00:12:09,440 --> 00:12:13,040
where g and h differ

307
00:12:15,440 --> 00:12:18,079
then to kind of apply this analysis to

308
00:12:18,079 --> 00:12:20,000
some security result we want the first

309
00:12:20,000 --> 00:12:23,120
step is to rewrite the result

310
00:12:23,120 --> 00:12:25,920
in a way fitting this setting of g and h

311
00:12:25,920 --> 00:12:28,320
that differ on s

312
00:12:28,320 --> 00:12:30,880
and then we apply this theorem and then

313
00:12:30,880 --> 00:12:32,320
we have to bound

314
00:12:32,320 --> 00:12:34,639
this probability that b is outputting

315
00:12:34,639 --> 00:12:36,240
something in s

316
00:12:36,240 --> 00:12:38,560
the most common way this happens which

317
00:12:38,560 --> 00:12:40,800
is what we'll use for our non-adaptive

318
00:12:40,800 --> 00:12:44,800
proof is a kind of structure agnostic

319
00:12:44,800 --> 00:12:46,000
setting

320
00:12:46,000 --> 00:12:47,200
where it actually

321
00:12:47,200 --> 00:12:49,760
we don't care what b looked like and we

322
00:12:49,760 --> 00:12:51,680
just say that the probability that any

323
00:12:51,680 --> 00:12:53,360
algorithm c

324
00:12:53,360 --> 00:12:56,160
making q queries to rhetorical outputs

325
00:12:56,160 --> 00:12:57,120
something

326
00:12:57,120 --> 00:12:58,240
in s

327
00:12:58,240 --> 00:13:02,399
can be bounded by some known quantity

328
00:13:02,720 --> 00:13:04,320
and our second proof our adaptive

329
00:13:04,320 --> 00:13:07,440
security proof for fx ffx we'll actually

330
00:13:07,440 --> 00:13:09,600
have to use the structure of b

331
00:13:09,600 --> 00:13:11,760
we'll have to use knowledge of the fact

332
00:13:11,760 --> 00:13:14,240
that b was constructed from a

333
00:13:14,240 --> 00:13:16,320
and the a we give will be kind of the

334
00:13:16,320 --> 00:13:19,120
combination of an adversary

335
00:13:19,120 --> 00:13:22,560
and a security game

336
00:13:22,560 --> 00:13:24,560
we need to do this because the oracles

337
00:13:24,560 --> 00:13:26,240
we'll give there

338
00:13:26,240 --> 00:13:28,880
if we didn't insist on any structure are

339
00:13:28,880 --> 00:13:31,279
actually quite fine quite easy to find

340
00:13:31,279 --> 00:13:32,639
where they differ

341
00:13:32,639 --> 00:13:34,320
it's only because of the particular

342
00:13:34,320 --> 00:13:35,920
structure of our

343
00:13:35,920 --> 00:13:38,320
adversary that we can say it's difficult

344
00:13:38,320 --> 00:13:42,000
for b to output something in s

345
00:13:43,920 --> 00:13:46,160
to apply this technique for our

346
00:13:46,160 --> 00:13:48,959
non-adaptive security proof of fx

347
00:13:48,959 --> 00:13:51,120
it really just boils down to kind of

348
00:13:51,120 --> 00:13:53,199
finding the right way to express the

349
00:13:53,199 --> 00:13:55,040
security of fx

350
00:13:55,040 --> 00:13:58,320
so that we can apply this result

351
00:13:58,320 --> 00:14:00,399
so here it's non-adaptive attack we're

352
00:14:00,399 --> 00:14:02,320
thinking of the adversary fixing ahead

353
00:14:02,320 --> 00:14:06,399
of time it's queries x1 through xq

354
00:14:06,399 --> 00:14:07,920
to

355
00:14:07,920 --> 00:14:11,040
its fx oracle

356
00:14:11,199 --> 00:14:12,720
then in our sampling we're going to

357
00:14:12,720 --> 00:14:15,120
first just randomly sample without

358
00:14:15,120 --> 00:14:16,399
repetition

359
00:14:16,399 --> 00:14:20,720
the responses to the adversary's queries

360
00:14:21,839 --> 00:14:24,880
for the ideal world

361
00:14:25,199 --> 00:14:26,959
its

362
00:14:26,959 --> 00:14:29,120
ideal permutation should be completely

363
00:14:29,120 --> 00:14:30,800
independent of these queries so we just

364
00:14:30,800 --> 00:14:32,560
sample a completely independent

365
00:14:32,560 --> 00:14:36,479
permutation to use there

366
00:14:37,279 --> 00:14:39,279
then to start building towards uh

367
00:14:39,279 --> 00:14:41,519
constructing our real world we're going

368
00:14:41,519 --> 00:14:44,079
to pick the random key k which is what

369
00:14:44,079 --> 00:14:45,519
we're going to think of as being the key

370
00:14:45,519 --> 00:14:47,920
that was used for fx

371
00:14:47,920 --> 00:14:49,519
and then we're going to find what i'm

372
00:14:49,519 --> 00:14:51,519
calling partner points

373
00:14:51,519 --> 00:14:54,480
by which i mean the image of all the x's

374
00:14:54,480 --> 00:14:56,399
xor with k

375
00:14:56,399 --> 00:14:59,199
and the pre-images of all the y's

376
00:14:59,199 --> 00:15:01,760
accelerate with k

377
00:15:01,760 --> 00:15:03,519
then to construct

378
00:15:03,519 --> 00:15:06,000
our ideal permutation for the real world

379
00:15:06,000 --> 00:15:08,000
which should be consistent

380
00:15:08,000 --> 00:15:10,480
with these responses to adversaries

381
00:15:10,480 --> 00:15:13,040
queries we picked earlier we just do a

382
00:15:13,040 --> 00:15:14,160
swap

383
00:15:14,160 --> 00:15:15,920
where we swap the

384
00:15:15,920 --> 00:15:19,760
y i's and the y stars that we found

385
00:15:19,760 --> 00:15:22,959
in the previous

386
00:15:24,839 --> 00:15:27,440
step once we've done this we're able to

387
00:15:27,440 --> 00:15:30,480
apply the one-way dehiding result

388
00:15:30,480 --> 00:15:32,480
where our g oracle is the real world

389
00:15:32,480 --> 00:15:35,199
permutation our h oracle is the ideal

390
00:15:35,199 --> 00:15:36,800
world permutation

391
00:15:36,800 --> 00:15:38,880
the auxiliary string z

392
00:15:38,880 --> 00:15:40,880
is the responses to the adversary's

393
00:15:40,880 --> 00:15:43,360
queries y1 through yq

394
00:15:43,360 --> 00:15:45,839
and the set of points where our oracles

395
00:15:45,839 --> 00:15:47,360
differ

396
00:15:47,360 --> 00:15:50,639
is just all the different x's x with k y

397
00:15:50,639 --> 00:15:52,160
xored with k

398
00:15:52,160 --> 00:15:56,079
the x stars and the y stars

399
00:15:56,800 --> 00:15:59,279
and then in a structural agnostic sense

400
00:15:59,279 --> 00:16:02,240
we can argue that that algorithm b

401
00:16:02,240 --> 00:16:03,920
is unlikely

402
00:16:03,920 --> 00:16:06,639
to output something in this set because

403
00:16:06,639 --> 00:16:09,839
of the way that this set depends on the

404
00:16:09,839 --> 00:16:12,480
randomly sampled k which is independent

405
00:16:12,480 --> 00:16:15,759
of its view in the ideal world

406
00:16:15,759 --> 00:16:18,160
i should note down this slide i'm kind

407
00:16:18,160 --> 00:16:20,320
of simplifying things and ignoring the

408
00:16:20,320 --> 00:16:22,240
fact that it's non-adaptive queries

409
00:16:22,240 --> 00:16:24,320
might involve inverse queries

410
00:16:24,320 --> 00:16:26,560
and ignoring the possibility of some

411
00:16:26,560 --> 00:16:28,959
incidental collisions between various

412
00:16:28,959 --> 00:16:31,279
values we sample here

413
00:16:31,279 --> 00:16:33,440
handling these is quite straightforward

414
00:16:33,440 --> 00:16:36,920
in the for proof

415
00:16:38,240 --> 00:16:40,320
next let's look at the

416
00:16:40,320 --> 00:16:42,480
ffx construction for which we gave an

417
00:16:42,480 --> 00:16:45,440
adaptive security proof

418
00:16:45,440 --> 00:16:47,519
again for this construction it's

419
00:16:47,519 --> 00:16:49,680
fairly straightforward to use

420
00:16:49,680 --> 00:16:51,680
classical techniques to give a security

421
00:16:51,680 --> 00:16:53,920
proof

422
00:16:54,480 --> 00:16:56,240
and we're going to focus on the setting

423
00:16:56,240 --> 00:16:58,320
where we kind of ignore the initial key

424
00:16:58,320 --> 00:16:59,600
for f

425
00:16:59,600 --> 00:17:01,360
and think if f is just being a random

426
00:17:01,360 --> 00:17:03,920
function adding back in that

427
00:17:03,920 --> 00:17:05,199
key to f

428
00:17:05,199 --> 00:17:09,199
is a straightforward in the analysis

429
00:17:10,160 --> 00:17:11,919
so to kind of give the intuition for

430
00:17:11,919 --> 00:17:13,359
this i'm actually first going to talk

431
00:17:13,359 --> 00:17:15,280
through how we would think about it

432
00:17:15,280 --> 00:17:17,119
classically using classical lazy

433
00:17:17,119 --> 00:17:18,400
sampling

434
00:17:18,400 --> 00:17:20,480
so for this we can think of our random

435
00:17:20,480 --> 00:17:23,199
functions as these really large tables

436
00:17:23,199 --> 00:17:26,799
which are initialized they're random

437
00:17:27,199 --> 00:17:28,880
then whenever a

438
00:17:28,880 --> 00:17:31,600
query for x is made we just look into

439
00:17:31,600 --> 00:17:33,919
the x entry of the table

440
00:17:33,919 --> 00:17:35,840
and respond to the adversary with

441
00:17:35,840 --> 00:17:38,959
whatever stored there

442
00:17:39,280 --> 00:17:41,120
to do lazy sampling then in the

443
00:17:41,120 --> 00:17:43,679
classical setting we instead initialize

444
00:17:43,679 --> 00:17:46,880
our table with bot everywhere

445
00:17:46,880 --> 00:17:49,120
when the adversary makes a query

446
00:17:49,120 --> 00:17:51,679
for x we looks in x

447
00:17:51,679 --> 00:17:54,799
if it stores but we first sample a

448
00:17:54,799 --> 00:17:56,960
random value for the table there and

449
00:17:56,960 --> 00:17:59,120
return it to the adversary

450
00:17:59,120 --> 00:18:01,200
if when we looked at x we saw that

451
00:18:01,200 --> 00:18:02,720
something was already there wasn't

452
00:18:02,720 --> 00:18:04,720
bought then we just returned the thing

453
00:18:04,720 --> 00:18:07,600
that was already there

454
00:18:08,559 --> 00:18:10,799
to apply this to a security proof

455
00:18:10,799 --> 00:18:13,280
the first step is to rewrite our oracles

456
00:18:13,280 --> 00:18:16,320
as lazy oracles so in the ideal world

457
00:18:16,320 --> 00:18:18,000
when the random function and the ideal

458
00:18:18,000 --> 00:18:19,600
primitive are completely separate from

459
00:18:19,600 --> 00:18:20,720
each other

460
00:18:20,720 --> 00:18:22,240
this means they're just completely

461
00:18:22,240 --> 00:18:23,840
separate

462
00:18:23,840 --> 00:18:25,919
random function tables which were lazily

463
00:18:25,919 --> 00:18:28,240
sampling

464
00:18:28,240 --> 00:18:31,039
in the real world there's a single

465
00:18:31,039 --> 00:18:32,880
random function table which is accessed

466
00:18:32,880 --> 00:18:34,799
directly

467
00:18:34,799 --> 00:18:37,360
by the ideal primitive

468
00:18:37,360 --> 00:18:39,360
but when you make a query to ffx on

469
00:18:39,360 --> 00:18:41,440
point say x prime

470
00:18:41,440 --> 00:18:44,320
we index into the location x prime x or

471
00:18:44,320 --> 00:18:46,480
k

472
00:18:49,039 --> 00:18:51,360
to write our security proof

473
00:18:51,360 --> 00:18:52,799
what we're going to do is kind of

474
00:18:52,799 --> 00:18:55,039
rewrite this real world to make it look

475
00:18:55,039 --> 00:18:57,919
more like the ideal

476
00:18:57,919 --> 00:18:59,520
in particular we're going to try to

477
00:18:59,520 --> 00:19:01,600
express it as two tables which are kind

478
00:19:01,600 --> 00:19:04,080
of linked to each other

479
00:19:04,080 --> 00:19:05,440
what that means

480
00:19:05,440 --> 00:19:08,480
is when we say query x to the ideal

481
00:19:08,480 --> 00:19:09,679
primitive

482
00:19:09,679 --> 00:19:12,400
we look both in the x location of the x

483
00:19:12,400 --> 00:19:16,080
table and the x x or k location of the

484
00:19:16,080 --> 00:19:19,039
ffx table

485
00:19:19,600 --> 00:19:21,200
if

486
00:19:21,200 --> 00:19:23,120
the ffx table

487
00:19:23,120 --> 00:19:26,080
there is not bot then we use ffx if it

488
00:19:26,080 --> 00:19:28,080
is bot we use

489
00:19:28,080 --> 00:19:29,440
a local

490
00:19:29,440 --> 00:19:31,760
table

491
00:19:32,880 --> 00:19:34,640
this logic about checking the other

492
00:19:34,640 --> 00:19:35,600
table

493
00:19:35,600 --> 00:19:37,440
is the only place

494
00:19:37,440 --> 00:19:39,520
that this oracle differs from the

495
00:19:39,520 --> 00:19:43,039
corresponding oracle in the ideal world

496
00:19:43,039 --> 00:19:46,080
similarly when you make a query to ffx

497
00:19:46,080 --> 00:19:48,559
we look

498
00:19:49,039 --> 00:19:51,760
in the corresponding spot in our ideal

499
00:19:51,760 --> 00:19:52,880
functions

500
00:19:52,880 --> 00:19:54,720
table

501
00:19:54,720 --> 00:19:56,559
and then we use that if it's not bought

502
00:19:56,559 --> 00:19:58,400
otherwise we use f

503
00:19:58,400 --> 00:20:00,960
and again we have this bit of where this

504
00:20:00,960 --> 00:20:02,080
oracle

505
00:20:02,080 --> 00:20:04,240
differs from the corresponding oracle in

506
00:20:04,240 --> 00:20:07,720
the ideal world

507
00:20:09,679 --> 00:20:11,600
these differences are on kind of hard to

508
00:20:11,600 --> 00:20:13,120
find inputs

509
00:20:13,120 --> 00:20:15,039
and then by using so-called identical

510
00:20:15,039 --> 00:20:16,880
and tobacco arguments which are kind of

511
00:20:16,880 --> 00:20:18,480
the classical version of one-way

512
00:20:18,480 --> 00:20:21,679
dividing arguments we're able to kind of

513
00:20:21,679 --> 00:20:23,760
lift this into giving us our security

514
00:20:23,760 --> 00:20:26,080
bound

515
00:20:27,440 --> 00:20:30,240
to try to follow this blueprint for our

516
00:20:30,240 --> 00:20:32,400
quantum proof we need to understand how

517
00:20:32,400 --> 00:20:36,240
lazy sampling works in the quantum realm

518
00:20:36,240 --> 00:20:38,240
we can't do exactly what we did in the

519
00:20:38,240 --> 00:20:40,880
previous slides for lazy sampling

520
00:20:40,880 --> 00:20:43,919
because superposition queries allow the

521
00:20:43,919 --> 00:20:46,000
adversary to touch all of the table at

522
00:20:46,000 --> 00:20:49,840
once with a single query

523
00:20:49,919 --> 00:20:52,480
but again we can start by just thinking

524
00:20:52,480 --> 00:20:54,880
of our random functions as large tables

525
00:20:54,880 --> 00:20:56,400
which are

526
00:20:56,400 --> 00:20:58,960
initialized at random

527
00:20:58,960 --> 00:21:00,799
now for the quantum setting to make

528
00:21:00,799 --> 00:21:03,360
oracles kind of valid unitaries

529
00:21:03,360 --> 00:21:04,960
we have to have our queries be at the

530
00:21:04,960 --> 00:21:07,200
form x comma y

531
00:21:07,200 --> 00:21:09,840
and now we look into location x

532
00:21:09,840 --> 00:21:11,840
and we take the result and we xor it

533
00:21:11,840 --> 00:21:14,399
into y

534
00:21:14,799 --> 00:21:17,280
xandri beautiful result

535
00:21:17,280 --> 00:21:20,240
so that we can get nice things if we

536
00:21:20,240 --> 00:21:21,919
instead look at things in the fourier

537
00:21:21,919 --> 00:21:23,039
domain

538
00:21:23,039 --> 00:21:25,200
this allows us to think of our function

539
00:21:25,200 --> 00:21:28,840
table as being initialized with all

540
00:21:28,840 --> 00:21:32,720
zeros then when we make a query x comma

541
00:21:32,720 --> 00:21:34,000
y

542
00:21:34,000 --> 00:21:37,120
all this does is that it xors the value

543
00:21:37,120 --> 00:21:38,000
y

544
00:21:38,000 --> 00:21:39,679
into the table

545
00:21:39,679 --> 00:21:41,520
and it doesn't return anything back to

546
00:21:41,520 --> 00:21:45,039
the adversary really

547
00:21:45,039 --> 00:21:46,880
doing this one at a time

548
00:21:46,880 --> 00:21:48,640
the adversary

549
00:21:48,640 --> 00:21:50,400
will be interacting with the table which

550
00:21:50,400 --> 00:21:52,880
is mostly zeros

551
00:21:52,880 --> 00:21:55,440
and after two queries

552
00:21:55,440 --> 00:22:00,559
is a non zero at at most queue locations

553
00:22:00,559 --> 00:22:02,720
zendri's technique is also

554
00:22:02,720 --> 00:22:04,320
commonly referred to as compressed

555
00:22:04,320 --> 00:22:06,000
oracle techniques

556
00:22:06,000 --> 00:22:08,080
because in most uses of this technique

557
00:22:08,080 --> 00:22:09,600
people have needed to go one step

558
00:22:09,600 --> 00:22:12,000
further where they compress the table to

559
00:22:12,000 --> 00:22:13,440
only store the entries which are

560
00:22:13,440 --> 00:22:15,840
non-zero for the purposes of our proof

561
00:22:15,840 --> 00:22:17,360
we don't need to do that at all we can

562
00:22:17,360 --> 00:22:19,120
keep our tables large

563
00:22:19,120 --> 00:22:22,799
and all we need is that they're sparse

564
00:22:24,559 --> 00:22:26,960
so for a quantum proof we want to kind

565
00:22:26,960 --> 00:22:29,520
of start it the same way we just did in

566
00:22:29,520 --> 00:22:31,520
the classical setting rewriting things

567
00:22:31,520 --> 00:22:35,760
as lazy oracles using zander's technique

568
00:22:35,760 --> 00:22:37,760
which gives us two separate tables being

569
00:22:37,760 --> 00:22:40,799
written into in the ideal world

570
00:22:40,799 --> 00:22:43,520
and a single table being written into

571
00:22:43,520 --> 00:22:46,159
in the real world

572
00:22:46,159 --> 00:22:48,799
however we can't do this immediately we

573
00:22:48,799 --> 00:22:50,720
have an issue because the external

574
00:22:50,720 --> 00:22:52,480
queries the queries to f of x of the

575
00:22:52,480 --> 00:22:53,760
random function are supposed to be

576
00:22:53,760 --> 00:22:55,200
classical

577
00:22:55,200 --> 00:22:56,960
and zendri's technique is supposed to be

578
00:22:56,960 --> 00:23:00,880
applied to quantum access to an oracle

579
00:23:00,880 --> 00:23:02,720
however this is actually kind of simple

580
00:23:02,720 --> 00:23:04,320
enough to

581
00:23:04,320 --> 00:23:05,840
handle for us

582
00:23:05,840 --> 00:23:07,440
all we do

583
00:23:07,440 --> 00:23:09,600
is we have this kind of step 0 we're

584
00:23:09,600 --> 00:23:12,159
going to express these classical queries

585
00:23:12,159 --> 00:23:14,320
as being quantum queries

586
00:23:14,320 --> 00:23:16,720
which is done by allowing the adversary

587
00:23:16,720 --> 00:23:19,120
now to make fully quantum access to this

588
00:23:19,120 --> 00:23:21,360
oracle

589
00:23:21,360 --> 00:23:23,679
but with every query it makes

590
00:23:23,679 --> 00:23:25,360
after the oracle is supposed to be

591
00:23:25,360 --> 00:23:27,760
classical we just write down what it

592
00:23:27,760 --> 00:23:31,840
queried in what i'll call a query log

593
00:23:31,840 --> 00:23:33,440
that we just keep storing throughout the

594
00:23:33,440 --> 00:23:36,080
whole game

595
00:23:36,080 --> 00:23:38,640
we've done that we can do this rewriting

596
00:23:38,640 --> 00:23:41,520
as lazy oracles giving us kind of what

597
00:23:41,520 --> 00:23:43,520
was shown here

598
00:23:43,520 --> 00:23:45,679
and then again the next step is to try

599
00:23:45,679 --> 00:23:47,919
to express the real world as two length

600
00:23:47,919 --> 00:23:50,720
tables

601
00:23:50,720 --> 00:23:53,279
when you access location x in one of the

602
00:23:53,279 --> 00:23:54,720
tables

603
00:23:54,720 --> 00:23:57,600
we need to first make sure if x x or k

604
00:23:57,600 --> 00:24:00,480
in the other table had a non-zero value

605
00:24:00,480 --> 00:24:02,720
in it

606
00:24:02,880 --> 00:24:04,720
doing this carefully

607
00:24:04,720 --> 00:24:06,960
we can again bind our oracle

608
00:24:06,960 --> 00:24:09,120
in a way where the real world and the

609
00:24:09,120 --> 00:24:13,120
ideal world only differ on code

610
00:24:14,000 --> 00:24:16,240
that's hard to find inputs which trigger

611
00:24:16,240 --> 00:24:18,640
it

612
00:24:18,640 --> 00:24:20,880
this gives us a setting for applying one

613
00:24:20,880 --> 00:24:23,120
way to hiding results giving our

614
00:24:23,120 --> 00:24:25,760
security bound

615
00:24:25,760 --> 00:24:27,600
so i'm kind of slightly lying to you on

616
00:24:27,600 --> 00:24:28,960
this slide there are some additional

617
00:24:28,960 --> 00:24:30,960
subtleties

618
00:24:30,960 --> 00:24:33,360
first is that the classical way

619
00:24:33,360 --> 00:24:35,200
of linking tables

620
00:24:35,200 --> 00:24:37,600
doesn't give a valid unitary operation

621
00:24:37,600 --> 00:24:39,440
so we can't use it in the quantum

622
00:24:39,440 --> 00:24:40,960
setting

623
00:24:40,960 --> 00:24:42,720
instead what we had to do is kind of

624
00:24:42,720 --> 00:24:44,960
very carefully design new ways of

625
00:24:44,960 --> 00:24:46,480
linking the tables

626
00:24:46,480 --> 00:24:48,320
in the quantum setting and here we kind

627
00:24:48,320 --> 00:24:50,640
of crucially had to make use of that

628
00:24:50,640 --> 00:24:53,200
query log we introduced before

629
00:24:53,200 --> 00:24:56,159
for the oracle which was being accessed

630
00:24:56,159 --> 00:24:59,159
classically

631
00:25:00,000 --> 00:25:01,919
the second piece is that the oracles as

632
00:25:01,919 --> 00:25:03,360
i've been discussing them are kind of

633
00:25:03,360 --> 00:25:05,840
stateful oracles and that's not the sort

634
00:25:05,840 --> 00:25:08,159
of oracle that one way to hiding results

635
00:25:08,159 --> 00:25:09,840
work with

636
00:25:09,840 --> 00:25:11,440
the way we address this

637
00:25:11,440 --> 00:25:13,440
is rather than thinking of our oracles

638
00:25:13,440 --> 00:25:16,320
as oracles which take in x and y

639
00:25:16,320 --> 00:25:18,400
we're going to think of them as oracles

640
00:25:18,400 --> 00:25:20,640
which take in x and y provided by the

641
00:25:20,640 --> 00:25:21,760
attacker

642
00:25:21,760 --> 00:25:23,120
and

643
00:25:23,120 --> 00:25:26,880
take in the f table the pi table the key

644
00:25:26,880 --> 00:25:27,600
k

645
00:25:27,600 --> 00:25:32,480
and the query log provided by the game

646
00:25:32,480 --> 00:25:34,080
and that is we're thinking of kind of

647
00:25:34,080 --> 00:25:36,720
combining the attacker and the game

648
00:25:36,720 --> 00:25:39,120
as a single algorithm for the purposes

649
00:25:39,120 --> 00:25:41,279
of the one weight hiding

650
00:25:41,279 --> 00:25:42,559
result

651
00:25:42,559 --> 00:25:44,080
and it's through this that we get that

652
00:25:44,080 --> 00:25:46,480
kind of

653
00:25:47,039 --> 00:25:49,520
non-structure agnostic use of one way to

654
00:25:49,520 --> 00:25:53,120
hiding that i was mentioning before

655
00:25:55,200 --> 00:25:57,440
our final result was analyzing double

656
00:25:57,440 --> 00:25:59,440
encryption

657
00:25:59,440 --> 00:26:01,679
as we mentioned double encryption

658
00:26:01,679 --> 00:26:02,880
which uses

659
00:26:02,880 --> 00:26:06,080
two k length keys

660
00:26:06,080 --> 00:26:08,320
falls victim in the classical setting to

661
00:26:08,320 --> 00:26:10,480
a time 2 to the k meet in the middle

662
00:26:10,480 --> 00:26:12,880
attack

663
00:26:12,880 --> 00:26:15,039
however we're still able to provide

664
00:26:15,039 --> 00:26:16,640
quantum security

665
00:26:16,640 --> 00:26:18,320
because there's still this 2 to the

666
00:26:18,320 --> 00:26:20,799
k-mean in the middle attack

667
00:26:20,799 --> 00:26:22,720
there's still grove research which can

668
00:26:22,720 --> 00:26:24,640
do attacks in time k

669
00:26:24,640 --> 00:26:26,880
but we can't combine them together

670
00:26:26,880 --> 00:26:29,760
to attack the length 2k scheme

671
00:26:29,760 --> 00:26:33,840
in time much less than k

672
00:26:35,039 --> 00:26:37,760
for a security result we do reductions

673
00:26:37,760 --> 00:26:40,240
to these worst case problems which isn't

674
00:26:40,240 --> 00:26:41,520
something we commonly see in

675
00:26:41,520 --> 00:26:42,799
cryptography

676
00:26:42,799 --> 00:26:44,400
in particular the problems we need are

677
00:26:44,400 --> 00:26:47,279
an element distinctness problem

678
00:26:47,279 --> 00:26:49,760
which asks an algorithm to determine

679
00:26:49,760 --> 00:26:52,240
if a list that's given has any repeated

680
00:26:52,240 --> 00:26:54,960
values in it

681
00:26:54,960 --> 00:26:56,640
and we look at a list distortions

682
00:26:56,640 --> 00:26:57,679
problem

683
00:26:57,679 --> 00:26:59,279
where an algorithm is given two

684
00:26:59,279 --> 00:27:01,919
different lists and has to determine if

685
00:27:01,919 --> 00:27:06,039
they have any values in common

686
00:27:06,159 --> 00:27:08,640
the first third of our proof

687
00:27:08,640 --> 00:27:10,480
is taking a proof which was previously

688
00:27:10,480 --> 00:27:11,919
done classically

689
00:27:11,919 --> 00:27:13,840
and showing that it applies in the

690
00:27:13,840 --> 00:27:15,679
quantum setting too that we can reduce

691
00:27:15,679 --> 00:27:17,760
double encryption security

692
00:27:17,760 --> 00:27:20,000
to a decision version of the list

693
00:27:20,000 --> 00:27:23,039
destroying this problem

694
00:27:23,520 --> 00:27:26,640
then we had to analyze these worst case

695
00:27:26,640 --> 00:27:28,720
list disjointness problem

696
00:27:28,720 --> 00:27:30,960
we did this through a flow of results

697
00:27:30,960 --> 00:27:32,799
when we first reduced from decision

698
00:27:32,799 --> 00:27:34,399
version to the search version of the

699
00:27:34,399 --> 00:27:36,480
problem and then the search version of

700
00:27:36,480 --> 00:27:38,159
the problem to the search version of

701
00:27:38,159 --> 00:27:40,080
element distinctness

702
00:27:40,080 --> 00:27:42,720
which we're then able to analyze using a

703
00:27:42,720 --> 00:27:45,440
proof technique that zenry used to

704
00:27:45,440 --> 00:27:47,440
analyze a slightly different version of

705
00:27:47,440 --> 00:27:49,679
element distinctness

706
00:27:49,679 --> 00:27:51,279
also it's worth noting that kind of

707
00:27:51,279 --> 00:27:54,159
inside of this decision there's an

708
00:27:54,159 --> 00:27:55,600
additional step where we're kind of

709
00:27:55,600 --> 00:27:57,600
stepping between different notions of

710
00:27:57,600 --> 00:28:00,159
what it means for a problem to be hard

711
00:28:00,159 --> 00:28:03,320
to decide

712
00:28:04,080 --> 00:28:05,760
if you want to kind of dig into the

713
00:28:05,760 --> 00:28:08,000
details of this i'll refer you to our

714
00:28:08,000 --> 00:28:10,399
paper

715
00:28:11,039 --> 00:28:12,799
to start concluding i'll mention two

716
00:28:12,799 --> 00:28:14,640
open problems that are requested that

717
00:28:14,640 --> 00:28:16,399
our paper leaves

718
00:28:16,399 --> 00:28:18,080
the first of these

719
00:28:18,080 --> 00:28:21,120
is analyzing the adaptive security

720
00:28:21,120 --> 00:28:23,840
of fx

721
00:28:24,720 --> 00:28:26,720
the kind of fundamental difficulty at

722
00:28:26,720 --> 00:28:28,720
least for trying to apply our proof

723
00:28:28,720 --> 00:28:29,760
technique

724
00:28:29,760 --> 00:28:31,679
is finding ways to do quantum lazy

725
00:28:31,679 --> 00:28:35,279
sampling for permutations

726
00:28:35,279 --> 00:28:36,720
there have been prior papers that

727
00:28:36,720 --> 00:28:38,159
attempt to do this

728
00:28:38,159 --> 00:28:39,840
and then were later shown to have proof

729
00:28:39,840 --> 00:28:41,440
errors in them

730
00:28:41,440 --> 00:28:43,279
there's a more recent paper which claims

731
00:28:43,279 --> 00:28:46,399
to do this for analyzing sha-3

732
00:28:46,399 --> 00:28:48,799
however they give a imperfect form of

733
00:28:48,799 --> 00:28:50,320
lazy sampling

734
00:28:50,320 --> 00:28:52,640
whose concrete security is kind of not

735
00:28:52,640 --> 00:28:54,799
good enough to be of any use for fx

736
00:28:54,799 --> 00:28:56,480
construction

737
00:28:56,480 --> 00:29:00,799
it would override any benefit of fx

738
00:29:01,520 --> 00:29:03,440
the second problem that would be

739
00:29:03,440 --> 00:29:05,200
interesting to consider

740
00:29:05,200 --> 00:29:07,120
is improving our quantum analysis of

741
00:29:07,120 --> 00:29:09,760
list destroyness

742
00:29:09,760 --> 00:29:12,080
we kind of saw before this root

743
00:29:12,080 --> 00:29:13,520
where the inside of the root is

744
00:29:13,520 --> 00:29:15,200
something that we're reasonably happy

745
00:29:15,200 --> 00:29:16,080
with

746
00:29:16,080 --> 00:29:18,799
but it's a sixth root

747
00:29:18,799 --> 00:29:21,039
and the sixth root is really bad for

748
00:29:21,039 --> 00:29:23,120
security for anything that's not really

749
00:29:23,120 --> 00:29:26,159
in the parameter of the same kind of

750
00:29:26,159 --> 00:29:28,960
consonant or one

751
00:29:28,960 --> 00:29:30,880
so it'd be interesting if our flow of

752
00:29:30,880 --> 00:29:32,799
worst case analysis of these problems

753
00:29:32,799 --> 00:29:35,039
could be somehow improved to give a

754
00:29:35,039 --> 00:29:37,760
better result

755
00:29:38,000 --> 00:29:39,840
and with that i've reached the end of my

756
00:29:39,840 --> 00:29:40,960
talk

757
00:29:40,960 --> 00:29:42,640
i'll leave you here on this slide

758
00:29:42,640 --> 00:29:44,880
summarizing our contributions

759
00:29:44,880 --> 00:29:48,159
and the open problems

760
00:29:48,960 --> 00:29:50,399
thanks for watching

761
00:29:50,399 --> 00:29:54,360
i hope you have a good day

