1
00:00:00,719 --> 00:00:04,000
hi everyone i am miguel champion and i'm

2
00:00:04,000 --> 00:00:06,480
going to talk about oblivious transfer

3
00:00:06,480 --> 00:00:09,200
from chapter permutations in minimal

4
00:00:09,200 --> 00:00:10,400
rounds

5
00:00:10,400 --> 00:00:14,400
this is a joint work with arka rajanduri

6
00:00:14,400 --> 00:00:17,200
vipugayal

7
00:00:20,640 --> 00:00:23,920
with secure multi-party computation what

8
00:00:23,920 --> 00:00:26,560
we want to do is

9
00:00:26,560 --> 00:00:29,439
evaluating a two input function in a

10
00:00:29,439 --> 00:00:31,359
secure way

11
00:00:31,359 --> 00:00:33,760
more precisely we consider the general

12
00:00:33,760 --> 00:00:35,840
setting where we have two parties alice

13
00:00:35,840 --> 00:00:37,040
and bob

14
00:00:37,040 --> 00:00:40,320
which have a private input

15
00:00:40,320 --> 00:00:42,239
and they want to evaluate the function f

16
00:00:42,239 --> 00:00:44,640
over this private input

17
00:00:44,640 --> 00:00:46,960
they don't trust each other and they do

18
00:00:46,960 --> 00:00:49,600
not want to give this input

19
00:00:49,600 --> 00:00:51,840
and each party does not want to give his

20
00:00:51,840 --> 00:00:54,480
own input to the other party

21
00:00:54,480 --> 00:00:56,559
so one trivial way to solve this problem

22
00:00:56,559 --> 00:00:59,199
would be to say and assume that there is

23
00:00:59,199 --> 00:01:01,440
a trusted party

24
00:01:01,440 --> 00:01:03,920
to which both alice and bob can send

25
00:01:03,920 --> 00:01:05,600
their own input

26
00:01:05,600 --> 00:01:08,000
and this trusted party then is delegated

27
00:01:08,000 --> 00:01:11,520
to compute function f over those inputs

28
00:01:11,520 --> 00:01:13,360
and give back

29
00:01:13,360 --> 00:01:15,520
the output of the computation to alice

30
00:01:15,520 --> 00:01:17,600
and bob

31
00:01:17,600 --> 00:01:20,479
but it's not

32
00:01:21,280 --> 00:01:24,080
realistic to assume the existence of

33
00:01:24,080 --> 00:01:27,360
such a trusted parties is i mean this

34
00:01:27,360 --> 00:01:30,240
central node might fail or might collude

35
00:01:30,240 --> 00:01:31,439
with either

36
00:01:31,439 --> 00:01:32,880
ali serval

37
00:01:32,880 --> 00:01:34,479
so what we want to do

38
00:01:34,479 --> 00:01:38,079
is we want to design a protocol

39
00:01:38,079 --> 00:01:40,799
which is described by a set of messages

40
00:01:40,799 --> 00:01:42,960
that alice and bob exchange over a

41
00:01:42,960 --> 00:01:45,520
communication channel in such a way that

42
00:01:45,520 --> 00:01:48,560
at the end of this communication

43
00:01:48,560 --> 00:01:50,880
alice and bob get the correct output of

44
00:01:50,880 --> 00:01:53,520
the of the computation

45
00:01:53,520 --> 00:01:55,280
and moreover

46
00:01:55,280 --> 00:01:58,719
in the case where one of the two parties

47
00:01:58,719 --> 00:02:01,360
is corrupted the corrupted party should

48
00:02:01,360 --> 00:02:04,640
not learn more than what can be inferred

49
00:02:04,640 --> 00:02:08,720
from the output of the function itself

50
00:02:08,720 --> 00:02:11,120
all the protocols we propose in our

51
00:02:11,120 --> 00:02:13,200
paper that are secure

52
00:02:13,200 --> 00:02:15,599
in the simulation base paradigm are

53
00:02:15,599 --> 00:02:18,560
proven secure with respect to

54
00:02:18,560 --> 00:02:20,959
black box adversaries so the simulator

55
00:02:20,959 --> 00:02:22,319
can only

56
00:02:22,319 --> 00:02:23,120
um

57
00:02:23,120 --> 00:02:25,760
the adversary and he does not know uh

58
00:02:25,760 --> 00:02:28,800
the code of the adversaries

59
00:02:28,800 --> 00:02:32,319
in the first part and in the main

60
00:02:32,319 --> 00:02:35,040
part of the talk uh we will be focusing

61
00:02:35,040 --> 00:02:36,720
on a very specific

62
00:02:36,720 --> 00:02:39,680
uh functionality this is called the

63
00:02:39,680 --> 00:02:42,400
oblivious transfer functionality

64
00:02:42,400 --> 00:02:44,239
uh the idea here is that the input of

65
00:02:44,239 --> 00:02:47,840
bob is made of two uh strings or two

66
00:02:47,840 --> 00:02:50,160
bits for simplicity

67
00:02:50,160 --> 00:02:54,640
and input values is just one bit

68
00:02:54,959 --> 00:02:56,720
the

69
00:02:56,720 --> 00:02:58,560
functionality that we want to compute

70
00:02:58,560 --> 00:03:01,680
will return to l is just the string of

71
00:03:01,680 --> 00:03:05,200
pop with index b in this case

72
00:03:05,200 --> 00:03:07,200
cb

73
00:03:07,200 --> 00:03:09,920
unfortunately we know that we

74
00:03:09,920 --> 00:03:12,239
cannot realize in the play model this

75
00:03:12,239 --> 00:03:15,440
functionality uh with uh

76
00:03:15,440 --> 00:03:18,720
information theoretic security

77
00:03:18,720 --> 00:03:19,760
so

78
00:03:19,760 --> 00:03:22,640
we need to rely on computational

79
00:03:22,640 --> 00:03:25,760
assumptions so to be precise we can have

80
00:03:25,760 --> 00:03:28,080
um statistical security only against one

81
00:03:28,080 --> 00:03:29,760
party but if but we cannot get

82
00:03:29,760 --> 00:03:32,080
statistical security against against

83
00:03:32,080 --> 00:03:33,680
both parties

84
00:03:33,680 --> 00:03:36,959
so one way to to circumvent these

85
00:03:36,959 --> 00:03:39,599
impossibility results is to again rely

86
00:03:39,599 --> 00:03:41,840
on computational assumptions

87
00:03:41,840 --> 00:03:44,400
and what we consider in this work is the

88
00:03:44,400 --> 00:03:45,680
assumption that what one-way

89
00:03:45,680 --> 00:03:48,480
permutations exist

90
00:03:48,480 --> 00:03:50,400
so one-way permutation is first of all a

91
00:03:50,400 --> 00:03:52,799
permutation as you can imagine

92
00:03:52,799 --> 00:03:54,959
and it's described by a set of

93
00:03:54,959 --> 00:03:57,360
algorithms the first is just generation

94
00:03:57,360 --> 00:03:59,519
algorithm that takes this input the

95
00:03:59,519 --> 00:04:01,120
unary description of the security

96
00:04:01,120 --> 00:04:04,159
parameter and it returns um the

97
00:04:04,159 --> 00:04:06,080
description of a function g and the

98
00:04:06,080 --> 00:04:10,400
value t which we will call the trapdoor

99
00:04:10,400 --> 00:04:12,640
uh the properties of

100
00:04:12,640 --> 00:04:14,799
a one-way traffic permutations are that

101
00:04:14,799 --> 00:04:19,358
given a function a g and given a value x

102
00:04:19,358 --> 00:04:23,040
it's easy to uh compute the g of x

103
00:04:23,040 --> 00:04:26,639
but it's hard to invert a randomly

104
00:04:26,639 --> 00:04:28,400
sampled element

105
00:04:28,400 --> 00:04:30,638
y

106
00:04:30,880 --> 00:04:32,400
in addition

107
00:04:32,400 --> 00:04:35,040
our one way uh trapezoidal permutation

108
00:04:35,040 --> 00:04:38,160
is equipped by a special algorithm that

109
00:04:38,160 --> 00:04:39,600
we call trap

110
00:04:39,600 --> 00:04:40,479
which

111
00:04:40,479 --> 00:04:42,880
on input any value y

112
00:04:42,880 --> 00:04:47,520
and the traptor can easily invert

113
00:04:47,600 --> 00:04:50,880
can easily find the play image of

114
00:04:50,880 --> 00:04:52,400
y

115
00:04:52,400 --> 00:04:56,639
in the work of even at all in 1982 the

116
00:04:56,639 --> 00:05:00,400
orders show how to obtain a three-round

117
00:05:00,400 --> 00:05:03,520
oblivious transfer protocol to secure

118
00:05:03,520 --> 00:05:06,960
against semi-honest adversaries

119
00:05:06,960 --> 00:05:09,440
moreover this protocol can be proven

120
00:05:09,440 --> 00:05:13,199
secure against malicious senders under

121
00:05:13,199 --> 00:05:15,520
the assumption that the function the

122
00:05:15,520 --> 00:05:17,039
traptor function

123
00:05:17,039 --> 00:05:20,800
is certifiable that is it is required

124
00:05:20,800 --> 00:05:23,680
that any party by just inspecting the

125
00:05:23,680 --> 00:05:26,000
description of the function can claim

126
00:05:26,000 --> 00:05:28,320
whether the function is indeed a

127
00:05:28,320 --> 00:05:31,440
permutation or not

128
00:05:31,440 --> 00:05:34,479
katsustrovsky in 2004

129
00:05:34,479 --> 00:05:36,240
proved that

130
00:05:36,240 --> 00:05:38,479
five rounds are necessary

131
00:05:38,479 --> 00:05:41,600
to realize an interval functionality and

132
00:05:41,600 --> 00:05:44,800
they match this lower bound by proposing

133
00:05:44,800 --> 00:05:47,759
a two-party competition protocol relying

134
00:05:47,759 --> 00:05:50,800
only on certifiable traptor permutations

135
00:05:50,800 --> 00:05:53,360
in the work of a source capital in 2015

136
00:05:53,360 --> 00:05:55,440
the orders show

137
00:05:55,440 --> 00:05:57,759
how to achieve the same result but this

138
00:05:57,759 --> 00:05:59,199
time relying

139
00:05:59,199 --> 00:06:02,560
on the underlying crypto primitive in a

140
00:06:02,560 --> 00:06:04,400
black box way

141
00:06:04,400 --> 00:06:06,560
drop their permutations have been used

142
00:06:06,560 --> 00:06:08,639
also to realize other interesting

143
00:06:08,639 --> 00:06:10,479
primitives like non-interactive zero

144
00:06:10,479 --> 00:06:12,319
knowledge and

145
00:06:12,319 --> 00:06:14,880
bellardium in 1993 showed how to

146
00:06:14,880 --> 00:06:16,319
construct

147
00:06:16,319 --> 00:06:18,479
an interactive zero knowledge relying on

148
00:06:18,479 --> 00:06:20,479
chapter permutations without requiring

149
00:06:20,479 --> 00:06:21,280
this

150
00:06:21,280 --> 00:06:25,280
form of certifiability and this uh work

151
00:06:25,280 --> 00:06:27,280
was later

152
00:06:27,280 --> 00:06:29,600
improved at the extent

153
00:06:29,600 --> 00:06:31,759
by the work of canada tal in this issue

154
00:06:31,759 --> 00:06:34,759
2018.

155
00:06:34,880 --> 00:06:38,720
and so what we do in uh in this work is

156
00:06:38,720 --> 00:06:41,120
to try to understand whether we can do

157
00:06:41,120 --> 00:06:42,240
the same

158
00:06:42,240 --> 00:06:44,560
uh for the case of oblivious transport

159
00:06:44,560 --> 00:06:46,840
and more in general to party

160
00:06:46,840 --> 00:06:50,240
competition that is going to show

161
00:06:50,240 --> 00:06:52,160
how to obtain

162
00:06:52,160 --> 00:06:54,000
a round optimal two-party competition

163
00:06:54,000 --> 00:06:55,520
protocol

164
00:06:55,520 --> 00:06:57,759
without requiring the traptor

165
00:06:57,759 --> 00:07:00,840
permutation to be

166
00:07:00,840 --> 00:07:02,880
certifiable so

167
00:07:02,880 --> 00:07:05,039
assuming that we know how to generate a

168
00:07:05,039 --> 00:07:09,360
trapdoor permutation egl82 showed that

169
00:07:09,360 --> 00:07:12,639
you can realize the oblivious transfer

170
00:07:12,639 --> 00:07:14,639
functionality

171
00:07:14,639 --> 00:07:16,400
in the following way

172
00:07:16,400 --> 00:07:18,080
so

173
00:07:18,080 --> 00:07:21,360
bob which will act as the sender will

174
00:07:21,360 --> 00:07:23,039
sample uh

175
00:07:23,039 --> 00:07:25,759
a chapter permutation uh together with

176
00:07:25,759 --> 00:07:27,440
with the tractor and it will send the

177
00:07:27,440 --> 00:07:32,240
description of the function to alice

178
00:07:32,240 --> 00:07:34,400
so for simplicity here in this example

179
00:07:34,400 --> 00:07:36,240
i'm assuming that the input of values is

180
00:07:36,240 --> 00:07:38,800
one but you will see that it's it's

181
00:07:38,800 --> 00:07:40,560
it's basically the same thing when the

182
00:07:40,560 --> 00:07:43,199
impulse of is is zero so given that the

183
00:07:43,199 --> 00:07:44,960
input of values is one

184
00:07:44,960 --> 00:07:47,120
what alice will do well it will sample a

185
00:07:47,120 --> 00:07:49,120
random element x1

186
00:07:49,120 --> 00:07:51,280
from the domain of the one of the of the

187
00:07:51,280 --> 00:07:55,199
permutation and she will evaluate

188
00:07:55,199 --> 00:07:55,919
g

189
00:07:55,919 --> 00:07:56,840
of

190
00:07:56,840 --> 00:07:58,400
x1

191
00:07:58,400 --> 00:08:01,120
and she will sample another element and

192
00:08:01,120 --> 00:08:05,039
she will send to bob uh white 0 and y1

193
00:08:05,039 --> 00:08:06,400
so the observation here is that

194
00:08:06,400 --> 00:08:09,280
basically alice has sampled this element

195
00:08:09,280 --> 00:08:12,160
in such a way that she knows the

196
00:08:12,160 --> 00:08:16,000
pre-image of only one of those

197
00:08:16,000 --> 00:08:19,599
at this point uh bob which has the

198
00:08:19,599 --> 00:08:22,160
tractor can invert both

199
00:08:22,160 --> 00:08:24,240
y 0 and y 1

200
00:08:24,240 --> 00:08:27,120
he will get x x0 and x1 and he will

201
00:08:27,120 --> 00:08:29,759
compute a one-time bet of his own

202
00:08:29,759 --> 00:08:30,960
secrets

203
00:08:30,960 --> 00:08:32,000
um

204
00:08:32,000 --> 00:08:33,679
the first secret

205
00:08:33,679 --> 00:08:36,320
is encrypted let's say using x0 and the

206
00:08:36,320 --> 00:08:39,599
second secret using x1 and he will send

207
00:08:39,599 --> 00:08:42,479
back to alice these encryptions now the

208
00:08:42,479 --> 00:08:44,560
observation here is that since alice

209
00:08:44,560 --> 00:08:46,080
knows

210
00:08:46,080 --> 00:08:50,000
uh x1 she can compute c1 because she can

211
00:08:50,000 --> 00:08:52,720
just remove the

212
00:08:52,720 --> 00:08:56,880
the key from this encryption and get c1

213
00:08:56,880 --> 00:08:58,080
now of course

214
00:08:58,080 --> 00:09:01,200
uh it's easy to see that if

215
00:09:01,200 --> 00:09:04,480
uh l is the receiver is corrupted then

216
00:09:04,480 --> 00:09:06,959
like this protocol isn't secure anymore

217
00:09:06,959 --> 00:09:08,959
because nothing in this protocol

218
00:09:08,959 --> 00:09:11,360
prevents alice from just

219
00:09:11,360 --> 00:09:14,399
sampling xc and x1 and then evaluating

220
00:09:14,399 --> 00:09:16,640
the function over g and this does

221
00:09:16,640 --> 00:09:18,959
getting weighted and y1 so that she can

222
00:09:18,959 --> 00:09:22,640
then get both secrets from both the nice

223
00:09:22,640 --> 00:09:25,519
thing about this protocol is that if bob

224
00:09:25,519 --> 00:09:28,880
instead is corrupted then he cannot get

225
00:09:28,880 --> 00:09:31,920
any information about alice's input

226
00:09:31,920 --> 00:09:35,360
indeed if g is a permutation

227
00:09:35,360 --> 00:09:38,000
the only information that adversary sees

228
00:09:38,000 --> 00:09:42,480
is y 0 and y 1 and y 0 and y 1 they have

229
00:09:42,480 --> 00:09:44,880
distributed exactly the same way so

230
00:09:44,880 --> 00:09:47,279
their distribution is independent from

231
00:09:47,279 --> 00:09:49,120
the input values

232
00:09:49,120 --> 00:09:51,519
so a corrupted bob cannot infer anything

233
00:09:51,519 --> 00:09:54,320
about alice in it

234
00:09:54,320 --> 00:09:56,560
but what we should observe here is that

235
00:09:56,560 --> 00:10:00,640
this claim is true only if g is a

236
00:10:00,640 --> 00:10:02,839
permutation

237
00:10:02,839 --> 00:10:05,200
indeed it might be

238
00:10:05,200 --> 00:10:07,200
that

239
00:10:07,200 --> 00:10:09,839
if g is not a permutation

240
00:10:09,839 --> 00:10:10,959
then

241
00:10:10,959 --> 00:10:12,880
uh

242
00:10:12,880 --> 00:10:14,320
we might be in this situation where

243
00:10:14,320 --> 00:10:16,399
alice might figure this out so she could

244
00:10:16,399 --> 00:10:18,320
refuse to participate to the property

245
00:10:18,320 --> 00:10:19,600
okay so

246
00:10:19,600 --> 00:10:21,839
and if a tropical permutation is this

247
00:10:21,839 --> 00:10:23,200
property we say that the traptor

248
00:10:23,200 --> 00:10:25,680
permutation is self-certifiable

249
00:10:25,680 --> 00:10:28,240
because just by inspection alice can

250
00:10:28,240 --> 00:10:29,839
efficiently say whether it's a

251
00:10:29,839 --> 00:10:31,680
permutation

252
00:10:31,680 --> 00:10:33,200
but

253
00:10:33,200 --> 00:10:35,279
what if instead the

254
00:10:35,279 --> 00:10:39,680
the function does not have this property

255
00:10:40,160 --> 00:10:41,760
and indeed we know that there are

256
00:10:41,760 --> 00:10:44,480
permutations that are uh that are not

257
00:10:44,480 --> 00:10:46,800
self-certifiable

258
00:10:46,800 --> 00:10:48,160
so

259
00:10:48,160 --> 00:10:49,600
as i said

260
00:10:49,600 --> 00:10:51,839
in the case where jesus permutation we

261
00:10:51,839 --> 00:10:55,120
are good and so in this example here

262
00:10:55,120 --> 00:10:58,839
g is a permutation okay and as i argue

263
00:10:58,839 --> 00:11:00,480
before

264
00:11:00,480 --> 00:11:04,480
there is nothing uh the adversary can do

265
00:11:04,480 --> 00:11:07,839
to infer the invertebrates in this case

266
00:11:07,839 --> 00:11:09,440
but now consider the following so

267
00:11:09,440 --> 00:11:11,200
consider the case where

268
00:11:11,200 --> 00:11:13,200
there are collisions let's say so a

269
00:11:13,200 --> 00:11:16,560
collision it's where for example b2 has

270
00:11:16,560 --> 00:11:19,279
two play images okay and we have a

271
00:11:19,279 --> 00:11:21,360
second collision which is a

272
00:11:21,360 --> 00:11:24,240
b3 because b3 has two collisions so

273
00:11:24,240 --> 00:11:25,839
collisions like

274
00:11:25,839 --> 00:11:28,399
when two or more elements

275
00:11:28,399 --> 00:11:30,880
evaluated on g

276
00:11:30,880 --> 00:11:33,839
are mapped to the same element of the of

277
00:11:33,839 --> 00:11:36,240
the domain okay

278
00:11:36,240 --> 00:11:38,720
now we can observe the following

279
00:11:38,720 --> 00:11:39,519
so

280
00:11:39,519 --> 00:11:41,760
if alice

281
00:11:41,760 --> 00:11:44,240
wants to get

282
00:11:44,240 --> 00:11:45,040
the

283
00:11:45,040 --> 00:11:48,079
input of bob with index 1

284
00:11:48,079 --> 00:11:51,120
then she will take x1

285
00:11:51,120 --> 00:11:54,399
and then she will evaluate g on x1

286
00:11:54,399 --> 00:11:57,200
but now observe that

287
00:11:57,200 --> 00:12:00,399
this means that y1

288
00:12:00,399 --> 00:12:02,399
can only be equal

289
00:12:02,399 --> 00:12:03,279
to

290
00:12:03,279 --> 00:12:04,320
b2

291
00:12:04,320 --> 00:12:08,240
b3 and b5 so y1

292
00:12:08,240 --> 00:12:11,920
will never be equal to b1 for example

293
00:12:11,920 --> 00:12:14,800
because there is no element that from

294
00:12:14,800 --> 00:12:16,320
um

295
00:12:16,320 --> 00:12:18,720
that from the

296
00:12:18,720 --> 00:12:22,079
domain is mapped to

297
00:12:22,079 --> 00:12:23,200
b1

298
00:12:23,200 --> 00:12:25,360
on the other hand

299
00:12:25,360 --> 00:12:26,720
for the

300
00:12:26,720 --> 00:12:27,680
uh

301
00:12:27,680 --> 00:12:30,800
input that uh alice does not want to get

302
00:12:30,800 --> 00:12:33,839
which is in this case the input that the

303
00:12:33,839 --> 00:12:36,160
the the input with with the index is

304
00:12:36,160 --> 00:12:38,399
zero she will pick a random

305
00:12:38,399 --> 00:12:42,800
uh a random y from the from the domain

306
00:12:42,800 --> 00:12:45,040
and in this case i mean she is just

307
00:12:45,040 --> 00:12:46,720
sampling a random value so this means

308
00:12:46,720 --> 00:12:49,920
that y zero might be equal to one two to

309
00:12:49,920 --> 00:12:53,040
five to any of these ones right so

310
00:12:53,040 --> 00:12:55,920
now the distribution of y 0 and y 1 it's

311
00:12:55,920 --> 00:12:58,079
really dependent on what is the input of

312
00:12:58,079 --> 00:13:00,399
alice right and so in this case

313
00:13:00,399 --> 00:13:02,160
malicious adversity might be able to

314
00:13:02,160 --> 00:13:04,399
distinguish easily by just looking at 1

315
00:13:04,399 --> 00:13:08,480
0 and y 1. what is the input of alice

316
00:13:08,480 --> 00:13:10,800
so how do we solve this problem

317
00:13:10,800 --> 00:13:11,839
um

318
00:13:11,839 --> 00:13:13,680
a candidate solution would be to say

319
00:13:13,680 --> 00:13:15,839
well let's use zero knowledge because

320
00:13:15,839 --> 00:13:18,480
what we can do is that we can force bob

321
00:13:18,480 --> 00:13:20,880
to provide the knowledge proof that

322
00:13:20,880 --> 00:13:24,160
shows that g is indeed sampled using the

323
00:13:24,160 --> 00:13:26,079
generation algorithm and then we would

324
00:13:26,079 --> 00:13:27,360
be fine

325
00:13:27,360 --> 00:13:29,920
one problem of this approach is that if

326
00:13:29,920 --> 00:13:31,920
we don't want to increase the run

327
00:13:31,920 --> 00:13:34,079
complexity of this protocol here which

328
00:13:34,079 --> 00:13:36,880
consists of just three rounds

329
00:13:36,880 --> 00:13:39,279
then we we have a problem because either

330
00:13:39,279 --> 00:13:42,800
we rely on heuristic assumptions and we

331
00:13:42,800 --> 00:13:44,639
obtain to obtain non-interactive zero

332
00:13:44,639 --> 00:13:45,680
knowledge

333
00:13:45,680 --> 00:13:48,079
or if you want to stay in the play model

334
00:13:48,079 --> 00:13:50,240
we need at least four rounds to compute

335
00:13:50,240 --> 00:13:52,079
the zero knowledge until knowledge proof

336
00:13:52,079 --> 00:13:54,720
so the overall random complexity

337
00:13:54,720 --> 00:13:57,120
in the best case we can hope for to you

338
00:13:57,120 --> 00:14:00,079
by using this zero knowledge approach is

339
00:14:00,079 --> 00:14:03,040
um six uh rounds

340
00:14:03,040 --> 00:14:04,480
another approach would be to use

341
00:14:04,480 --> 00:14:06,880
contentious where

342
00:14:06,880 --> 00:14:08,399
the um

343
00:14:08,399 --> 00:14:10,240
party the receiver

344
00:14:10,240 --> 00:14:13,519
challenges the the sender by for example

345
00:14:13,519 --> 00:14:16,079
sampling multiple elements from the from

346
00:14:16,079 --> 00:14:18,480
the codomain and asking the the the

347
00:14:18,480 --> 00:14:21,680
sender pop to to invert those

348
00:14:21,680 --> 00:14:23,600
and so that

349
00:14:23,600 --> 00:14:25,680
alice can get a level of confidence

350
00:14:25,680 --> 00:14:26,959
about

351
00:14:26,959 --> 00:14:30,079
how good this uh this permutation is the

352
00:14:30,079 --> 00:14:31,680
problem is that again

353
00:14:31,680 --> 00:14:34,480
this would require some additional

354
00:14:34,480 --> 00:14:37,120
rounds because like alice

355
00:14:37,120 --> 00:14:40,079
needs to make sure that g is a

356
00:14:40,079 --> 00:14:42,800
permutation before she's ends uh y d and

357
00:14:42,800 --> 00:14:45,360
y one and as you can imagine here

358
00:14:45,360 --> 00:14:47,600
there is no room um

359
00:14:47,600 --> 00:14:49,199
to do the cutting juice unless we

360
00:14:49,199 --> 00:14:50,880
increase the number of rounds of the

361
00:14:50,880 --> 00:14:53,360
protocol

362
00:14:53,600 --> 00:14:55,279
so what we do

363
00:14:55,279 --> 00:14:58,560
we take a completely different approach

364
00:14:58,560 --> 00:15:00,959
in the sense that

365
00:15:00,959 --> 00:15:03,920
the observation here is that

366
00:15:03,920 --> 00:15:05,199
bob

367
00:15:05,199 --> 00:15:06,320
can

368
00:15:06,320 --> 00:15:09,279
get something about alice's input by

369
00:15:09,279 --> 00:15:10,560
inspecting

370
00:15:10,560 --> 00:15:14,399
y0 and y one when g is not a permutation

371
00:15:14,399 --> 00:15:17,120
so the idea would be to do the following

372
00:15:17,120 --> 00:15:20,079
to encrypt to keep hidden the second

373
00:15:20,079 --> 00:15:22,079
round of values

374
00:15:22,079 --> 00:15:24,480
for the case where g is not a

375
00:15:24,480 --> 00:15:27,440
permutation so the idea is to put us

376
00:15:27,440 --> 00:15:30,079
ourselves in a win-win situation where

377
00:15:30,079 --> 00:15:31,040
either

378
00:15:31,040 --> 00:15:31,839
the

379
00:15:31,839 --> 00:15:34,240
function is a permutation

380
00:15:34,240 --> 00:15:37,360
so and university can see what is

381
00:15:37,360 --> 00:15:39,680
encrypted in the second round

382
00:15:39,680 --> 00:15:41,920
but but in this case it's okay if the

383
00:15:41,920 --> 00:15:43,600
adversary can see what is encrypted

384
00:15:43,600 --> 00:15:46,399
because well this is a permutation so y

385
00:15:46,399 --> 00:15:48,560
zero and y one does not give away

386
00:15:48,560 --> 00:15:50,800
anything about lg's input

387
00:15:50,800 --> 00:15:53,040
on the other hand if g is not a

388
00:15:53,040 --> 00:15:55,360
permutation then this encryption should

389
00:15:55,360 --> 00:15:57,120
retain um

390
00:15:57,120 --> 00:16:00,320
the the secrecy of y 0.1

391
00:16:00,320 --> 00:16:02,160
to be more precise

392
00:16:02,160 --> 00:16:04,320
what we want

393
00:16:04,320 --> 00:16:07,040
to design is an encryption

394
00:16:07,040 --> 00:16:08,560
scheme

395
00:16:08,560 --> 00:16:10,160
that is

396
00:16:10,160 --> 00:16:13,120
defined by the algorithm

397
00:16:13,120 --> 00:16:15,279
encryption and decryption where the

398
00:16:15,279 --> 00:16:17,600
encryption algorithm just takes a simple

399
00:16:17,600 --> 00:16:20,000
description of the chapter permutation

400
00:16:20,000 --> 00:16:22,480
and the message you want to encrypt

401
00:16:22,480 --> 00:16:24,320
whereas the decryption algorithm takes

402
00:16:24,320 --> 00:16:25,920
as input again

403
00:16:25,920 --> 00:16:28,720
the description of the function

404
00:16:28,720 --> 00:16:30,320
the thruster t

405
00:16:30,320 --> 00:16:34,639
and the ciphertext we want to decrypt

406
00:16:35,120 --> 00:16:38,000
and the idea is that again if g is a

407
00:16:38,000 --> 00:16:40,959
permutation then we can like always

408
00:16:40,959 --> 00:16:42,240
decrypt k

409
00:16:42,240 --> 00:16:45,920
the cyber text using the chapter

410
00:16:45,920 --> 00:16:48,639
if instead g is not a permutation

411
00:16:48,639 --> 00:16:50,959
and to be precise what you will prove is

412
00:16:50,959 --> 00:16:53,600
that if there are g has a lot of

413
00:16:53,600 --> 00:16:56,240
collision so for example

414
00:16:56,240 --> 00:16:57,920
2 to the

415
00:16:57,920 --> 00:17:00,320
n minus 1

416
00:17:00,320 --> 00:17:03,600
collisions so then m remains it hidden

417
00:17:03,600 --> 00:17:05,359
so the message

418
00:17:05,359 --> 00:17:07,359
that you want to protect is protected

419
00:17:07,359 --> 00:17:11,280
but we need a lot of collision

420
00:17:11,359 --> 00:17:13,359
so this is how

421
00:17:13,359 --> 00:17:14,640
the final

422
00:17:14,640 --> 00:17:18,240
protocol would look like so instead of

423
00:17:18,240 --> 00:17:21,679
alice sending in the clear y1 and y0 she

424
00:17:21,679 --> 00:17:24,480
will encrypt y2 and y1

425
00:17:24,480 --> 00:17:25,520
using

426
00:17:25,520 --> 00:17:29,280
this a special encryption scheme

427
00:17:29,919 --> 00:17:31,520
and now because of the properties of

428
00:17:31,520 --> 00:17:33,120
this encryption scheme

429
00:17:33,120 --> 00:17:36,080
like we can get some stronger security

430
00:17:36,080 --> 00:17:39,120
guarantee where if the function has a

431
00:17:39,120 --> 00:17:40,880
lot of collision then the security of

432
00:17:40,880 --> 00:17:42,799
this encryption scheme will not disclose

433
00:17:42,799 --> 00:17:45,039
anything about why zero by one and the

434
00:17:45,039 --> 00:17:47,200
input of l is predicted

435
00:17:47,200 --> 00:17:48,880
we need to discuss what happens in the

436
00:17:48,880 --> 00:17:51,039
case where there are not that many

437
00:17:51,039 --> 00:17:52,559
collision so

438
00:17:52,559 --> 00:17:54,480
where the function g is still not a

439
00:17:54,480 --> 00:17:56,240
permutation but

440
00:17:56,240 --> 00:17:58,320
we have less than two to the n minus one

441
00:17:58,320 --> 00:18:01,120
collisions but we will do later on i

442
00:18:01,120 --> 00:18:03,440
just want to show you now first how this

443
00:18:03,440 --> 00:18:05,120
encryption

444
00:18:05,120 --> 00:18:07,120
scheme works

445
00:18:07,120 --> 00:18:09,600
to encrypt a message m we just sample a

446
00:18:09,600 --> 00:18:12,160
random element from the domain

447
00:18:12,160 --> 00:18:14,640
and we compute the one template i mean

448
00:18:14,640 --> 00:18:16,000
what we do

449
00:18:16,000 --> 00:18:18,720
precisely is to use the hardcore the um

450
00:18:18,720 --> 00:18:20,400
predicate of the of the dropdown

451
00:18:20,400 --> 00:18:22,080
function but for simplicity let's say

452
00:18:22,080 --> 00:18:23,840
that we just sample the random element

453
00:18:23,840 --> 00:18:25,200
and we we do

454
00:18:25,200 --> 00:18:27,200
like we use it as a key of one timepad

455
00:18:27,200 --> 00:18:29,840
to encrypt them

456
00:18:29,919 --> 00:18:30,880
then

457
00:18:30,880 --> 00:18:33,200
we evaluate

458
00:18:33,200 --> 00:18:34,799
g of a

459
00:18:34,799 --> 00:18:37,520
in the cyber text it's simply just these

460
00:18:37,520 --> 00:18:40,320
two elements so the one time head of

461
00:18:40,320 --> 00:18:42,400
the message using a and the evaluation

462
00:18:42,400 --> 00:18:45,039
of a over g

463
00:18:45,039 --> 00:18:47,919
for the decryption

464
00:18:48,000 --> 00:18:49,600
first of all

465
00:18:49,600 --> 00:18:50,799
we can

466
00:18:50,799 --> 00:18:52,559
invert

467
00:18:52,559 --> 00:18:54,960
the second element

468
00:18:54,960 --> 00:18:57,360
of these cyber texts that we denoted

469
00:18:57,360 --> 00:19:00,480
with k2 and we can retrieve a

470
00:19:00,480 --> 00:19:03,679
and once that we f have a we can just

471
00:19:03,679 --> 00:19:06,400
um remove the one template key of from

472
00:19:06,400 --> 00:19:08,080
this encryption let's say

473
00:19:08,080 --> 00:19:09,919
and we can get the message that you want

474
00:19:09,919 --> 00:19:14,080
to compute it's very very simple

475
00:19:14,080 --> 00:19:16,160
you know of course like when you is a

476
00:19:16,160 --> 00:19:18,640
permutation

477
00:19:18,640 --> 00:19:21,039
well we have uh

478
00:19:21,039 --> 00:19:22,720
no problems at all right so in this

479
00:19:22,720 --> 00:19:23,679
example

480
00:19:23,679 --> 00:19:25,120
during the encryption let's say that the

481
00:19:25,120 --> 00:19:27,520
random element is a3 so we can compute

482
00:19:27,520 --> 00:19:29,280
a3 plus m

483
00:19:29,280 --> 00:19:32,000
and then we follow eight a3 over over

484
00:19:32,000 --> 00:19:34,720
the over the traffic repetition g and we

485
00:19:34,720 --> 00:19:38,480
get b3 and the output of our

486
00:19:38,480 --> 00:19:42,400
um of our encryption is just m x plus uh

487
00:19:42,400 --> 00:19:44,000
c3 comma

488
00:19:44,000 --> 00:19:45,520
comma b3

489
00:19:45,520 --> 00:19:47,600
and we can decrypt uh the reason why we

490
00:19:47,600 --> 00:19:50,559
can decrypt is that like b3 has exactly

491
00:19:50,559 --> 00:19:53,200
one pre-image so there is no ambiguity

492
00:19:53,200 --> 00:19:55,760
in the decryption

493
00:19:55,760 --> 00:19:58,080
on the other hand if we

494
00:19:58,080 --> 00:20:00,000
are in the case where g is not a

495
00:20:00,000 --> 00:20:03,120
permutation and has a lot of collisions

496
00:20:03,120 --> 00:20:05,760
and let's say that again like we are

497
00:20:05,760 --> 00:20:08,320
during the encryption we sample a3 but

498
00:20:08,320 --> 00:20:11,440
now observe that a3 maps to b3 which has

499
00:20:11,440 --> 00:20:13,280
two play images

500
00:20:13,280 --> 00:20:14,480
so now

501
00:20:14,480 --> 00:20:18,559
even if the decrypter has the uh traptor

502
00:20:18,559 --> 00:20:20,400
he doesn't know

503
00:20:20,400 --> 00:20:21,600
whether

504
00:20:21,600 --> 00:20:23,360
during the encryption

505
00:20:23,360 --> 00:20:27,200
a3 or a4 was used to compute

506
00:20:27,200 --> 00:20:29,200
the ciphertext so this creates an

507
00:20:29,200 --> 00:20:32,720
ambiguity that keeps hidden the message

508
00:20:32,720 --> 00:20:34,960
m

509
00:20:34,960 --> 00:20:38,400
okay so let's see what we we have now

510
00:20:38,400 --> 00:20:41,039
again we are in the situation where

511
00:20:41,039 --> 00:20:42,799
alice does not just stand in the

512
00:20:42,799 --> 00:20:45,120
clearwater one but she encrypts those

513
00:20:45,120 --> 00:20:47,280
using this encryption scheme we've just

514
00:20:47,280 --> 00:20:48,400
described

515
00:20:48,400 --> 00:20:50,960
and if bob is

516
00:20:50,960 --> 00:20:53,200
honest then he can

517
00:20:53,200 --> 00:20:55,520
compute the decryption using the

518
00:20:55,520 --> 00:20:57,919
knowledge of the tractor

519
00:20:57,919 --> 00:20:59,760
we said that

520
00:20:59,760 --> 00:21:02,880
in two situations this scheme is secure

521
00:21:02,880 --> 00:21:05,520
the first is where g is a permutation

522
00:21:05,520 --> 00:21:08,080
and the second is where g is not a

523
00:21:08,080 --> 00:21:10,080
permutation and it has a lot of

524
00:21:10,080 --> 00:21:11,919
collisions right because we can prove

525
00:21:11,919 --> 00:21:13,120
that if

526
00:21:13,120 --> 00:21:15,679
uh half of the domain has collisions

527
00:21:15,679 --> 00:21:16,640
then

528
00:21:16,640 --> 00:21:18,320
the encryption scheme is semantically

529
00:21:18,320 --> 00:21:19,200
secure

530
00:21:19,200 --> 00:21:21,200
but what happens for example in this

531
00:21:21,200 --> 00:21:22,640
case where

532
00:21:22,640 --> 00:21:25,840
there are just a few collisions right

533
00:21:25,840 --> 00:21:28,159
i mean the problem here is that

534
00:21:28,159 --> 00:21:31,200
we might be in this situation where

535
00:21:31,200 --> 00:21:33,600
the adversary can successfully decrypt

536
00:21:33,600 --> 00:21:35,679
the second round

537
00:21:35,679 --> 00:21:37,360
but

538
00:21:37,360 --> 00:21:40,559
on the other hand maybe

539
00:21:40,559 --> 00:21:42,640
because of these

540
00:21:42,640 --> 00:21:45,600
few collisions alice was lucky and she

541
00:21:45,600 --> 00:21:46,880
got

542
00:21:46,880 --> 00:21:48,640
some of those

543
00:21:48,640 --> 00:21:52,240
and then like diversity can again invert

544
00:21:52,240 --> 00:21:54,480
something by just inspect inspecting why

545
00:21:54,480 --> 00:21:56,320
didn't you one

546
00:21:56,320 --> 00:21:57,520
but

547
00:21:57,520 --> 00:21:59,760
the observation here is that there

548
00:21:59,760 --> 00:22:02,159
aren't many collisions so we are finding

549
00:22:02,159 --> 00:22:05,600
in in the in the two extreme cases where

550
00:22:05,600 --> 00:22:07,520
g is a permutation where g has a lot of

551
00:22:07,520 --> 00:22:10,240
collisions but if we are in this middle

552
00:22:10,240 --> 00:22:11,360
ground

553
00:22:11,360 --> 00:22:13,120
it means that there are not that many

554
00:22:13,120 --> 00:22:15,120
conditions so it means that let's say

555
00:22:15,120 --> 00:22:17,760
the pro the number of collisions is less

556
00:22:17,760 --> 00:22:19,760
than two to the n minus one

557
00:22:19,760 --> 00:22:21,039
so we can argue that then the

558
00:22:21,039 --> 00:22:23,679
probability that white zero and y one

559
00:22:23,679 --> 00:22:28,080
sampled by ellis using either of

560
00:22:28,080 --> 00:22:30,559
the two procedures

561
00:22:30,559 --> 00:22:33,120
they are good so they have no collisions

562
00:22:33,120 --> 00:22:34,960
and the probability that this happens in

563
00:22:34,960 --> 00:22:36,480
this case for example is at least one

564
00:22:36,480 --> 00:22:39,039
over four

565
00:22:39,200 --> 00:22:41,120
because like

566
00:22:41,120 --> 00:22:44,960
half of the domain has collisions so

567
00:22:44,960 --> 00:22:47,120
with probability one over two

568
00:22:47,120 --> 00:22:50,080
alice will get what a value that uh

569
00:22:50,080 --> 00:22:52,840
has exactly one

570
00:22:52,840 --> 00:22:55,520
print but we want to get two of these

571
00:22:55,520 --> 00:22:58,240
values so the probability becomes one

572
00:22:58,240 --> 00:23:00,080
one over four

573
00:23:00,080 --> 00:23:02,240
so

574
00:23:03,360 --> 00:23:06,080
what we can do then

575
00:23:06,080 --> 00:23:07,440
is the following

576
00:23:07,440 --> 00:23:09,600
so we can try to amplify this

577
00:23:09,600 --> 00:23:11,200
probability

578
00:23:11,200 --> 00:23:13,200
that alice gets

579
00:23:13,200 --> 00:23:14,159
good

580
00:23:14,159 --> 00:23:16,400
let's say values in the in the second

581
00:23:16,400 --> 00:23:17,919
round of the protocol

582
00:23:17,919 --> 00:23:20,000
and one way to amplify this type of

583
00:23:20,000 --> 00:23:21,760
probabilities is by just repeating the

584
00:23:21,760 --> 00:23:23,840
protocol many times so if we repeat this

585
00:23:23,840 --> 00:23:26,080
protocol many many times

586
00:23:26,080 --> 00:23:27,840
um some

587
00:23:27,840 --> 00:23:30,320
lambda square times where the

588
00:23:30,320 --> 00:23:32,559
lambda is the security parameter

589
00:23:32,559 --> 00:23:33,840
then we know

590
00:23:33,840 --> 00:23:34,960
that

591
00:23:34,960 --> 00:23:37,600
at least in one of these execution of

592
00:23:37,600 --> 00:23:40,240
the protocol we will have

593
00:23:40,240 --> 00:23:41,919
like good

594
00:23:41,919 --> 00:23:44,720
values of yt and y1 so

595
00:23:44,720 --> 00:23:46,720
we will end up in this situation wherein

596
00:23:46,720 --> 00:23:47,919
at least

597
00:23:47,919 --> 00:23:50,400
in one of these execution we will have

598
00:23:50,400 --> 00:23:52,159
yg and y1

599
00:23:52,159 --> 00:23:56,080
with exactly one play image each

600
00:23:56,480 --> 00:23:58,320
unfortunately this approach doesn't work

601
00:23:58,320 --> 00:23:59,600
because

602
00:23:59,600 --> 00:24:01,440
yeah it's true that we will have one

603
00:24:01,440 --> 00:24:02,960
execution where

604
00:24:02,960 --> 00:24:04,720
that will be somehow

605
00:24:04,720 --> 00:24:06,720
we can say it's secure in the sense that

606
00:24:06,720 --> 00:24:08,960
it will protect the input of alice but

607
00:24:08,960 --> 00:24:10,400
on the other hand there are other

608
00:24:10,400 --> 00:24:12,880
executions that are not like that and so

609
00:24:12,880 --> 00:24:14,640
given that we are just repeating the

610
00:24:14,640 --> 00:24:16,000
protocol

611
00:24:16,000 --> 00:24:17,919
and alice is using the same input in all

612
00:24:17,919 --> 00:24:19,760
the protocols well

613
00:24:19,760 --> 00:24:21,440
the fact that one only one of these

614
00:24:21,440 --> 00:24:25,200
executions uh it's fine it's not broken

615
00:24:25,200 --> 00:24:27,360
it doesn't really help

616
00:24:27,360 --> 00:24:30,159
so what we can do is that we can rely on

617
00:24:30,159 --> 00:24:32,720
an idea similar to

618
00:24:32,720 --> 00:24:34,240
ot combiners

619
00:24:34,240 --> 00:24:36,240
let me give you a brief recap of what a

620
00:24:36,240 --> 00:24:38,640
naughty combiner is let's say that we

621
00:24:38,640 --> 00:24:40,480
have

622
00:24:40,480 --> 00:24:41,919
different

623
00:24:41,919 --> 00:24:43,840
realization different protocol

624
00:24:43,840 --> 00:24:46,640
realizations of the oblivious transfer

625
00:24:46,640 --> 00:24:48,799
functionality so in this case let's say

626
00:24:48,799 --> 00:24:51,360
we have m protocols they use different

627
00:24:51,360 --> 00:24:54,000
assumptions they have different

628
00:24:54,000 --> 00:24:56,320
procedures for the receiver for the

629
00:24:56,320 --> 00:24:57,279
sender

630
00:24:57,279 --> 00:24:58,840
they differ in some

631
00:24:58,840 --> 00:25:02,720
way and what an honor t combiner does

632
00:25:02,720 --> 00:25:04,880
more precisely what one

633
00:25:04,880 --> 00:25:08,159
one out of m or t combiner does is to

634
00:25:08,159 --> 00:25:10,320
take all these instances

635
00:25:10,320 --> 00:25:13,440
and construct one

636
00:25:13,440 --> 00:25:15,600
protocol that again realizes the

637
00:25:15,600 --> 00:25:17,919
oblivious transfer functionality

638
00:25:17,919 --> 00:25:21,520
so the property of the combiner is that

639
00:25:21,520 --> 00:25:22,799
as long as

640
00:25:22,799 --> 00:25:25,360
in this specific example here there is

641
00:25:25,360 --> 00:25:26,320
one

642
00:25:26,320 --> 00:25:29,279
oblivious transfer instantiation that is

643
00:25:29,279 --> 00:25:32,480
secure that is not that is not broken

644
00:25:32,480 --> 00:25:34,720
then the overall

645
00:25:34,720 --> 00:25:36,799
protocol that we get the overall ot

646
00:25:36,799 --> 00:25:39,679
protocol that your t combiner gives us

647
00:25:39,679 --> 00:25:41,279
is secure

648
00:25:41,279 --> 00:25:44,480
so we do not need to know which of the

649
00:25:44,480 --> 00:25:48,640
ot protocol is is secure

650
00:25:48,880 --> 00:25:52,400
and we can still get an overall protocol

651
00:25:52,400 --> 00:25:53,279
that

652
00:25:53,279 --> 00:25:55,600
that is secure

653
00:25:55,600 --> 00:25:58,400
by just combining these multiple uh of

654
00:25:58,400 --> 00:26:01,679
the ot protocols okay in some way

655
00:26:01,679 --> 00:26:04,240
our approach is to look at the specific

656
00:26:04,240 --> 00:26:07,679
instantiation of a t combiner and apply

657
00:26:07,679 --> 00:26:10,640
it to our case in order to

658
00:26:10,640 --> 00:26:12,799
amplify the probability that at least

659
00:26:12,799 --> 00:26:16,240
one execution will be fine

660
00:26:16,240 --> 00:26:18,240
and at the same time protecting the

661
00:26:18,240 --> 00:26:20,480
input of that is even if

662
00:26:20,480 --> 00:26:22,400
the remaining two executions are

663
00:26:22,400 --> 00:26:23,440
completely

664
00:26:23,440 --> 00:26:27,039
broken because of the uh

665
00:26:27,039 --> 00:26:29,440
of the choice of the of the function

666
00:26:29,440 --> 00:26:32,559
made by the sender

667
00:26:32,559 --> 00:26:34,720
and the idea is pretty simple as you can

668
00:26:34,720 --> 00:26:38,000
imagine so instead of requiring alice to

669
00:26:38,000 --> 00:26:40,720
use the same input in all the executions

670
00:26:40,720 --> 00:26:43,360
alice will secret share in in some way i

671
00:26:43,360 --> 00:26:47,360
mean it's a meaningful way um her input

672
00:26:47,360 --> 00:26:49,440
among these many executions and

673
00:26:49,440 --> 00:26:52,559
bob also does something similar he he

674
00:26:52,559 --> 00:26:55,039
does some type of secret sharing

675
00:26:55,039 --> 00:26:56,559
in such a way

676
00:26:56,559 --> 00:26:57,520
that

677
00:26:57,520 --> 00:27:01,440
at the end of these many executions

678
00:27:01,440 --> 00:27:03,760
she can combine the outputs received

679
00:27:03,760 --> 00:27:06,159
from these many ot executions and she

680
00:27:06,159 --> 00:27:08,960
will be able to to reconstruct the final

681
00:27:08,960 --> 00:27:10,159
output

682
00:27:10,159 --> 00:27:13,039
and the nice thing is that

683
00:27:13,039 --> 00:27:14,720
because of the security that the

684
00:27:14,720 --> 00:27:16,480
combiner gives you

685
00:27:16,480 --> 00:27:17,919
it doesn't matter

686
00:27:17,919 --> 00:27:20,799
if there are other executions that are

687
00:27:20,799 --> 00:27:21,760
broken

688
00:27:21,760 --> 00:27:24,320
as long as there is one that is good and

689
00:27:24,320 --> 00:27:26,960
that where we know that the y values has

690
00:27:26,960 --> 00:27:28,640
one brain image each

691
00:27:28,640 --> 00:27:31,200
so just to summarize

692
00:27:31,200 --> 00:27:33,679
to argue that our product was secure we

693
00:27:33,679 --> 00:27:35,919
can distinguish between

694
00:27:35,919 --> 00:27:37,679
three different main cases that can

695
00:27:37,679 --> 00:27:39,360
happen so the first

696
00:27:39,360 --> 00:27:41,279
is the case where

697
00:27:41,279 --> 00:27:44,240
in one of these executions the

698
00:27:44,240 --> 00:27:45,600
um

699
00:27:45,600 --> 00:27:48,399
the sender uses a traptor function

700
00:27:48,399 --> 00:27:50,559
that has at least two to the n minus one

701
00:27:50,559 --> 00:27:52,960
collisions so

702
00:27:52,960 --> 00:27:55,679
in this case we will be fine because

703
00:27:55,679 --> 00:27:57,360
like the

704
00:27:57,360 --> 00:27:59,840
one share of alice will be protected

705
00:27:59,840 --> 00:28:01,600
because of the semantic security of the

706
00:28:01,600 --> 00:28:05,440
encryption scheme we have designed

707
00:28:05,440 --> 00:28:08,720
if such an execution does not exist

708
00:28:08,720 --> 00:28:11,520
then we can say that well this means

709
00:28:11,520 --> 00:28:12,640
that

710
00:28:12,640 --> 00:28:14,640
each function that adverse that

711
00:28:14,640 --> 00:28:16,960
adversary uses that the sender uses

712
00:28:16,960 --> 00:28:19,760
contains at most to the n minus one

713
00:28:19,760 --> 00:28:22,000
minus one collisions okay if the number

714
00:28:22,000 --> 00:28:24,640
of repetition now is big enough we can

715
00:28:24,640 --> 00:28:26,880
argue that with overwhelming probability

716
00:28:26,880 --> 00:28:29,200
one of the execution will have what's

717
00:28:29,200 --> 00:28:30,880
your name well one with exactly one

718
00:28:30,880 --> 00:28:33,520
premier each

719
00:28:33,840 --> 00:28:34,960
so

720
00:28:34,960 --> 00:28:35,760
okay

721
00:28:35,760 --> 00:28:38,720
and this basically gives us a

722
00:28:38,720 --> 00:28:40,320
three-round

723
00:28:40,320 --> 00:28:42,399
ot protocol

724
00:28:42,399 --> 00:28:45,279
that doesn't require the function g to

725
00:28:45,279 --> 00:28:47,679
be self-certifiable so we remove the

726
00:28:47,679 --> 00:28:50,159
certifiability property and we keep the

727
00:28:50,159 --> 00:28:52,399
run complexity of the protocol down to

728
00:28:52,399 --> 00:28:54,720
three

729
00:28:54,720 --> 00:28:55,760
as i

730
00:28:55,760 --> 00:28:58,559
mentioned at the beginning of this talk

731
00:28:58,559 --> 00:29:01,120
the protocol unfortunately remains

732
00:29:01,120 --> 00:29:05,039
insecure in the case where the

733
00:29:05,039 --> 00:29:08,080
the receiver is not semi honest if the

734
00:29:08,080 --> 00:29:11,039
receiver is corrupted this malicious

735
00:29:11,039 --> 00:29:13,840
then he can always get

736
00:29:13,840 --> 00:29:15,360
both secrets

737
00:29:15,360 --> 00:29:17,039
and to solve this issue we need to add

738
00:29:17,039 --> 00:29:20,240
another round to the protocol and um

739
00:29:20,240 --> 00:29:23,279
our approach will follow the

740
00:29:23,279 --> 00:29:25,679
approach used in the workhorse get all

741
00:29:25,679 --> 00:29:27,600
of crypto 2015

742
00:29:27,600 --> 00:29:28,799
um

743
00:29:28,799 --> 00:29:31,679
but we need to do it with some some care

744
00:29:31,679 --> 00:29:35,279
um because we also want to

745
00:29:35,279 --> 00:29:37,679
keep the protocol

746
00:29:37,679 --> 00:29:40,320
uh black box in the use of the

747
00:29:40,320 --> 00:29:42,399
underlying chapter permutation so this

748
00:29:42,399 --> 00:29:43,200
is

749
00:29:43,200 --> 00:29:44,559
um

750
00:29:44,559 --> 00:29:46,559
another challenge that that we need to

751
00:29:46,559 --> 00:29:48,000
overcome but

752
00:29:48,000 --> 00:29:51,679
uh we uh we managed to do that and

753
00:29:51,679 --> 00:29:54,480
for this i will refer to

754
00:29:54,480 --> 00:29:56,960
to the paper for for more details

755
00:29:56,960 --> 00:29:59,279
just to conclude so what we do in this

756
00:29:59,279 --> 00:30:00,640
paper

757
00:30:00,640 --> 00:30:02,880
is to

758
00:30:02,880 --> 00:30:04,720
circumvent

759
00:30:04,720 --> 00:30:06,720
the needs of

760
00:30:06,720 --> 00:30:09,440
proving something about a statement that

761
00:30:09,440 --> 00:30:11,760
we care about in this case

762
00:30:11,760 --> 00:30:14,480
the the trivial solution would have been

763
00:30:14,480 --> 00:30:15,520
to

764
00:30:15,520 --> 00:30:16,559
force

765
00:30:16,559 --> 00:30:18,640
the sender bob to

766
00:30:18,640 --> 00:30:20,480
prove that the function

767
00:30:20,480 --> 00:30:21,360
was

768
00:30:21,360 --> 00:30:23,919
a permutation in some way

769
00:30:23,919 --> 00:30:27,279
and instead of doing that we use a

770
00:30:27,279 --> 00:30:30,080
witness encryption like approach

771
00:30:30,080 --> 00:30:32,240
where

772
00:30:32,240 --> 00:30:34,960
if the sender is honest in some sense he

773
00:30:34,960 --> 00:30:37,840
can actually conclude the protocol

774
00:30:37,840 --> 00:30:39,679
successfully

775
00:30:39,679 --> 00:30:41,120
if it's not

776
00:30:41,120 --> 00:30:44,000
honest then he will be stuck at some

777
00:30:44,000 --> 00:30:47,279
point and all the information of the

778
00:30:47,279 --> 00:30:48,880
honest party will be

779
00:30:48,880 --> 00:30:51,520
protected

780
00:30:51,520 --> 00:30:54,320
the first result that we get is this

781
00:30:54,320 --> 00:30:56,960
three-round protocol that relies only on

782
00:30:56,960 --> 00:30:59,120
raptor permutations and offers security

783
00:30:59,120 --> 00:31:01,600
against malicious senders

784
00:31:01,600 --> 00:31:04,320
and what we show is that this protocol

785
00:31:04,320 --> 00:31:06,080
can be extended

786
00:31:06,080 --> 00:31:06,880
to

787
00:31:06,880 --> 00:31:08,399
the case where

788
00:31:08,399 --> 00:31:10,640
we also tolerate security against

789
00:31:10,640 --> 00:31:12,720
corrupt receivers

790
00:31:12,720 --> 00:31:14,880
on top of that we show how to turn our

791
00:31:14,880 --> 00:31:19,039
protocol into a two-party competition

792
00:31:19,039 --> 00:31:20,640
protocol that realizes any any

793
00:31:20,640 --> 00:31:22,960
functionality and that uses the

794
00:31:22,960 --> 00:31:24,960
underlying chapter permutation in a

795
00:31:24,960 --> 00:31:26,399
blackbox way

796
00:31:26,399 --> 00:31:27,919
so

797
00:31:27,919 --> 00:31:29,919
and also in this case

798
00:31:29,919 --> 00:31:30,799
no

799
00:31:30,799 --> 00:31:32,559
certifiability properties required on

800
00:31:32,559 --> 00:31:34,480
the tractor premium dish

801
00:31:34,480 --> 00:31:35,919
okay and with this

802
00:31:35,919 --> 00:31:40,279
i conclude thank you very much

