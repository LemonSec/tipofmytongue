1
00:00:00,240 --> 00:00:02,639
carry on have a good session

2
00:00:02,639 --> 00:00:04,879
okay

3
00:00:06,960 --> 00:00:10,320
so um welcome to the second session on

4
00:00:10,320 --> 00:00:12,639
secure multiplier computation

5
00:00:12,639 --> 00:00:14,559
uh we have six stocks

6
00:00:14,559 --> 00:00:16,480
600 sessions

7
00:00:16,480 --> 00:00:18,000
and the first one is on the fish

8
00:00:18,000 --> 00:00:19,760
incentive agreement and multiply the

9
00:00:19,760 --> 00:00:22,640
competition with a synchronous fallback

10
00:00:22,640 --> 00:00:25,680
by giovanni the religious smart martin

11
00:00:25,680 --> 00:00:27,439
here and chanda

12
00:00:27,439 --> 00:00:30,000
design and giovanni will give the

13
00:00:30,000 --> 00:00:32,079
presentation

14
00:00:32,079 --> 00:00:33,920
hello everyone thank you very much for

15
00:00:33,920 --> 00:00:35,600
the introduction

16
00:00:35,600 --> 00:00:37,760
um and it's a pleasure to be here

17
00:00:37,760 --> 00:00:38,879
presenting

18
00:00:38,879 --> 00:00:40,800
this work i carried out jointly with

19
00:00:40,800 --> 00:00:43,280
chandler and martin and eth

20
00:00:43,280 --> 00:00:44,960
and as we said i'm going to be talking

21
00:00:44,960 --> 00:00:45,920
about

22
00:00:45,920 --> 00:00:47,680
round efficient byzantine implemented

23
00:00:47,680 --> 00:00:49,600
multi-party computation protocols with

24
00:00:49,600 --> 00:00:51,760
asynchronous fallback

25
00:00:51,760 --> 00:00:52,879
so

26
00:00:52,879 --> 00:00:53,760
um

27
00:00:53,760 --> 00:00:56,000
maybe i'll save the usual introduction

28
00:00:56,000 --> 00:00:58,079
about what mdc and using agreement

29
00:00:58,079 --> 00:01:00,320
protocols are and i'll talk a bit more

30
00:01:00,320 --> 00:01:02,480
in general about the fact that when one

31
00:01:02,480 --> 00:01:04,640
is designing distributed protocols in

32
00:01:04,640 --> 00:01:06,000
general

33
00:01:06,000 --> 00:01:07,920
then one is to make assumptions about

34
00:01:07,920 --> 00:01:09,520
the network infrastructure that is

35
00:01:09,520 --> 00:01:12,560
available to the parties communicating

36
00:01:12,560 --> 00:01:15,200
and typically two main models in the

37
00:01:15,200 --> 00:01:16,720
literature about this are the

38
00:01:16,720 --> 00:01:18,400
synchronous model of communication and

39
00:01:18,400 --> 00:01:20,320
the asynchronous model

40
00:01:20,320 --> 00:01:22,159
and these models different are very

41
00:01:22,159 --> 00:01:23,759
different in nature in the synchronous

42
00:01:23,759 --> 00:01:26,720
model we assume that parties have access

43
00:01:26,720 --> 00:01:28,960
to synchronized clocks

44
00:01:28,960 --> 00:01:30,640
and protocols typically proceed in

45
00:01:30,640 --> 00:01:32,960
rounds and we assume an upper bound

46
00:01:32,960 --> 00:01:34,159
delay

47
00:01:34,159 --> 00:01:36,720
on the delivery time of messages between

48
00:01:36,720 --> 00:01:39,200
parties while in the asynchronous model

49
00:01:39,200 --> 00:01:41,759
both of these assumptions are dropped

50
00:01:41,759 --> 00:01:44,479
and the adversary we allow the adversary

51
00:01:44,479 --> 00:01:46,159
to schedule delivery of messages

52
00:01:46,159 --> 00:01:49,200
arbitrarily so unsurprisingly

53
00:01:49,200 --> 00:01:51,200
what can be achieved in these two models

54
00:01:51,200 --> 00:01:53,759
is quite different and typically for

55
00:01:53,759 --> 00:01:56,240
distributed protocols for example ba and

56
00:01:56,240 --> 00:01:58,880
mpc and asynchronous models

57
00:01:58,880 --> 00:02:01,600
one can achieve security up to

58
00:02:01,600 --> 00:02:04,000
um and have corruptions roughly speaking

59
00:02:04,000 --> 00:02:06,399
while in the asynchronous model

60
00:02:06,399 --> 00:02:08,080
secure protocols can only be achieved

61
00:02:08,080 --> 00:02:11,520
typically up to n third corruptions

62
00:02:11,520 --> 00:02:14,080
and so this kind of creates a problem

63
00:02:14,080 --> 00:02:16,319
when deploying protocols in kind of

64
00:02:16,319 --> 00:02:18,480
let's say real life networks which have

65
00:02:18,480 --> 00:02:20,640
the property of usually being pretty

66
00:02:20,640 --> 00:02:22,400
fast but can

67
00:02:22,400 --> 00:02:24,640
occasionally maybe experience delays or

68
00:02:24,640 --> 00:02:27,040
bottlenecks that cause some messages to

69
00:02:27,040 --> 00:02:29,760
be delayed for longer than expected

70
00:02:29,760 --> 00:02:30,879
then

71
00:02:30,879 --> 00:02:33,120
one needs to decide whether to use

72
00:02:33,120 --> 00:02:34,400
protocols that are designed in the

73
00:02:34,400 --> 00:02:37,680
synchronous model thus risking very bad

74
00:02:37,680 --> 00:02:40,160
security failures when even just one

75
00:02:40,160 --> 00:02:41,680
message is delayed for longer than

76
00:02:41,680 --> 00:02:44,480
expected or whether to deploy protocols

77
00:02:44,480 --> 00:02:46,640
there are asynchronous in nature

78
00:02:46,640 --> 00:02:48,480
and not to take advantage of the fact

79
00:02:48,480 --> 00:02:50,720
that you know usually you can assume

80
00:02:50,720 --> 00:02:54,319
upper bound on the delay of messages

81
00:02:54,319 --> 00:02:55,120
so

82
00:02:55,120 --> 00:02:56,800
it's not surprising that people have

83
00:02:56,800 --> 00:02:59,680
tried to kind of come up with protocols

84
00:02:59,680 --> 00:03:02,080
that exploit best support worlds meaning

85
00:03:02,080 --> 00:03:03,760
that we are looking for protocols that

86
00:03:03,760 --> 00:03:05,519
are secure both when the network is

87
00:03:05,519 --> 00:03:06,720
synchronous and when the network is

88
00:03:06,720 --> 00:03:08,800
asynchronous maybe up to some different

89
00:03:08,800 --> 00:03:10,800
threshold of corruptions and in

90
00:03:10,800 --> 00:03:13,120
particular two works in 2019 published

91
00:03:13,120 --> 00:03:15,840
at tcc by blue cats and dos and one

92
00:03:15,840 --> 00:03:18,480
published in 2020 at crypto by new

93
00:03:18,480 --> 00:03:19,680
zealand

94
00:03:19,680 --> 00:03:21,599
they showed feasibility results in this

95
00:03:21,599 --> 00:03:23,760
sense for both byzantine agreement and

96
00:03:23,760 --> 00:03:25,599
multi-party computation where they

97
00:03:25,599 --> 00:03:26,959
showed that you can actually achieve

98
00:03:26,959 --> 00:03:29,760
protocols that are secure when run both

99
00:03:29,760 --> 00:03:31,519
over synchronous and asynchronous

100
00:03:31,519 --> 00:03:32,720
networks

101
00:03:32,720 --> 00:03:34,959
and

102
00:03:36,879 --> 00:03:38,159
yeah i think

103
00:03:38,159 --> 00:03:39,760
and exactly

104
00:03:39,760 --> 00:03:42,720
under some optimal trade-offs on these

105
00:03:42,720 --> 00:03:44,400
threshold of corruptions that is the

106
00:03:44,400 --> 00:03:45,680
corruptions when the network is

107
00:03:45,680 --> 00:03:47,440
asynchronous plus two times the

108
00:03:47,440 --> 00:03:49,440
corruption the network is synchronous

109
00:03:49,440 --> 00:03:50,959
must be smaller than that and this is

110
00:03:50,959 --> 00:03:53,920
probably optimal in this setting

111
00:03:53,920 --> 00:03:54,959
and

112
00:03:54,959 --> 00:03:56,640
um there have been many follow-ups to

113
00:03:56,640 --> 00:03:59,040
this work protocols

114
00:03:59,040 --> 00:03:59,680
protocols that exploring

115
00:03:59,680 --> 00:04:01,360
secure in synchronous networks and

116
00:04:01,360 --> 00:04:03,280
achieving responsiveness

117
00:04:03,280 --> 00:04:04,799
and stuff like this

118
00:04:04,799 --> 00:04:06,720
but we mostly follow up on these two

119
00:04:06,720 --> 00:04:09,280
works and our focus in our work is

120
00:04:09,280 --> 00:04:10,799
improving the route complexity of this

121
00:04:10,799 --> 00:04:13,040
protocol so quickly i made this this

122
00:04:13,040 --> 00:04:15,280
chart pointing out that there is quite a

123
00:04:15,280 --> 00:04:16,399
difference between the protocol

124
00:04:16,399 --> 00:04:18,079
presented in these papers and

125
00:04:18,079 --> 00:04:19,759
state-of-the-art purely synchronous

126
00:04:19,759 --> 00:04:21,040
protocols when it comes to round

127
00:04:21,040 --> 00:04:23,840
complexity for example va protocols that

128
00:04:23,840 --> 00:04:26,080
come in two flavors when talking about

129
00:04:26,080 --> 00:04:27,919
constant round protocols there are

130
00:04:27,919 --> 00:04:29,759
purely synchronous typically require a

131
00:04:29,759 --> 00:04:32,000
constant number of rounds and mpc

132
00:04:32,000 --> 00:04:33,199
protocols

133
00:04:33,199 --> 00:04:34,800
have a number of rounds which doesn't

134
00:04:34,800 --> 00:04:37,440
depend on the depth of the circuit to

135
00:04:37,440 --> 00:04:39,919
evaluate so we're trying to fill the gap

136
00:04:39,919 --> 00:04:41,680
here and this is going to be our

137
00:04:41,680 --> 00:04:43,120
contribution

138
00:04:43,120 --> 00:04:44,479
and

139
00:04:44,479 --> 00:04:46,960
our positive results in this sense are a

140
00:04:46,960 --> 00:04:49,360
byzantine agreement protocol that is

141
00:04:49,360 --> 00:04:51,840
achieved the same optimal trade-offs as

142
00:04:51,840 --> 00:04:53,759
the protocols presented before but is

143
00:04:53,759 --> 00:04:55,919
also rounded efficient in the sense that

144
00:04:55,919 --> 00:04:59,040
it matches the round complexity of

145
00:04:59,040 --> 00:05:00,800
the most efficient known at the time

146
00:05:00,800 --> 00:05:02,479
purely synchronous protocols when the

147
00:05:02,479 --> 00:05:04,160
network is synchronous and for

148
00:05:04,160 --> 00:05:06,880
multi-party computation we provided

149
00:05:06,880 --> 00:05:09,280
an mpc protocol whose number of all to

150
00:05:09,280 --> 00:05:11,840
all broadcast rounds only is constant in

151
00:05:11,840 --> 00:05:14,160
the depth of the circuit to evaluate and

152
00:05:14,160 --> 00:05:15,840
it's not linear in the depth of the

153
00:05:15,840 --> 00:05:17,360
circuit to evaluate

154
00:05:17,360 --> 00:05:19,199
so to quickly wrap this up i would just

155
00:05:19,199 --> 00:05:21,600
like to give an idea of how one of these

156
00:05:21,600 --> 00:05:24,320
construction looks on a high level so

157
00:05:24,320 --> 00:05:26,560
the idea to achieve va which is secure

158
00:05:26,560 --> 00:05:28,160
both in synchronous and asynchronous

159
00:05:28,160 --> 00:05:29,680
networks due to

160
00:05:29,680 --> 00:05:31,840
bloom cuts and loss is to compile two

161
00:05:31,840 --> 00:05:33,520
different protocols a synchronous one

162
00:05:33,520 --> 00:05:36,320
and an asynchronous one in succession

163
00:05:36,320 --> 00:05:38,720
and let's say roughly the security of

164
00:05:38,720 --> 00:05:40,080
the construction when the network is

165
00:05:40,080 --> 00:05:41,440
synchronous falls mostly on the

166
00:05:41,440 --> 00:05:42,960
synchronous protocol and the security of

167
00:05:42,960 --> 00:05:44,320
the construction when the network is

168
00:05:44,320 --> 00:05:46,320
facing us falls mostly on the

169
00:05:46,320 --> 00:05:48,400
asynchronous protocols and since our

170
00:05:48,400 --> 00:05:51,840
focus is around efficiency

171
00:05:51,840 --> 00:05:53,520
and we observed that the asynchronous

172
00:05:53,520 --> 00:05:55,120
protocols they employ

173
00:05:55,120 --> 00:05:57,759
in this setting were already

174
00:05:57,759 --> 00:06:00,160
brown efficient when the network is

175
00:06:00,160 --> 00:06:02,560
synchronous our focus is improving the

176
00:06:02,560 --> 00:06:04,240
round efficiency of the synchronous

177
00:06:04,240 --> 00:06:06,720
component of this compiler

178
00:06:06,720 --> 00:06:08,800
which also requires some extra property

179
00:06:08,800 --> 00:06:10,960
when the network is asynchronous

180
00:06:10,960 --> 00:06:13,199
and uh so the way we do this is

181
00:06:13,199 --> 00:06:14,720
exploiting your own construction into

182
00:06:14,720 --> 00:06:17,280
fedman and mikali which runs iterations

183
00:06:17,280 --> 00:06:19,520
of a weaker consensus protocol called

184
00:06:19,520 --> 00:06:21,520
known as weak consensus

185
00:06:21,520 --> 00:06:23,199
or crusaders agreement in some other

186
00:06:23,199 --> 00:06:25,600
work followed by common

187
00:06:25,600 --> 00:06:28,000
coin toss functionality

188
00:06:28,000 --> 00:06:30,400
and by iterating this protocol many

189
00:06:30,400 --> 00:06:32,560
times one can kind of

190
00:06:32,560 --> 00:06:34,400
reach security up to a negligible

191
00:06:34,400 --> 00:06:35,600
probability

192
00:06:35,600 --> 00:06:37,440
and one of our contributions is

193
00:06:37,440 --> 00:06:38,960
providing construction of this

194
00:06:38,960 --> 00:06:40,880
synchronous weak consensus protocol with

195
00:06:40,880 --> 00:06:43,440
these extra properties

196
00:06:43,440 --> 00:06:44,560
that i

197
00:06:44,560 --> 00:06:46,800
mentioned here and

198
00:06:46,800 --> 00:06:48,400
so the main challenge in this setting is

199
00:06:48,400 --> 00:06:49,759
that when a party doesn't receive a

200
00:06:49,759 --> 00:06:52,160
message from some other party one cannot

201
00:06:52,160 --> 00:06:54,479
know if this message was dropped by the

202
00:06:54,479 --> 00:06:55,919
adversary because the network is

203
00:06:55,919 --> 00:06:58,000
asynchronous or if this messaging is

204
00:06:58,000 --> 00:07:00,479
simply not delivered because it wasn't

205
00:07:00,479 --> 00:07:02,960
sent in the

206
00:07:05,440 --> 00:07:06,800
is corrupted

207
00:07:06,800 --> 00:07:08,560
so yeah this is one high-level overview

208
00:07:08,560 --> 00:07:10,240
of one technical contribution we have

209
00:07:10,240 --> 00:07:12,800
many other impossibility results and

210
00:07:12,800 --> 00:07:14,960
uh also the results for npc as i stated

211
00:07:14,960 --> 00:07:16,240
but

212
00:07:16,240 --> 00:07:18,000
there's no time to talk about anything

213
00:07:18,000 --> 00:07:19,840
so this is it thank you very much for

214
00:07:19,840 --> 00:07:21,520
your attention and

215
00:07:21,520 --> 00:07:23,360
i'm happy to take any questions if you

216
00:07:23,360 --> 00:07:26,360
haven't

217
00:07:42,880 --> 00:07:45,840
thank you

218
00:08:00,639 --> 00:08:04,759
and remember to write down

219
00:08:15,039 --> 00:08:18,039
right

220
00:08:31,039 --> 00:08:32,240
that's better

221
00:08:32,240 --> 00:08:34,559
okay so our next uh presentation is two

222
00:08:34,559 --> 00:08:36,640
round maliciously secure communication

223
00:08:36,640 --> 00:08:38,320
with super cool

224
00:08:38,320 --> 00:08:40,799
simulation by amit agrawal

225
00:08:40,799 --> 00:08:43,519
james batusek the purgojan the cheetah

226
00:08:43,519 --> 00:08:49,640
corana julio malvolta and amir

227
00:08:56,480 --> 00:08:58,160
hello everyone today i'd like to present

228
00:08:58,160 --> 00:08:59,920
my work on two round maliciously secure

229
00:08:59,920 --> 00:09:02,080
fpc with super polynomial simulation and

230
00:09:02,080 --> 00:09:03,200
this is joint work with james

231
00:09:03,200 --> 00:09:05,170
waterslight

232
00:09:05,170 --> 00:09:06,320
[Music]

233
00:09:06,320 --> 00:09:08,959
so let me start by

234
00:09:08,959 --> 00:09:10,959
describing the setting of mpc so here we

235
00:09:10,959 --> 00:09:12,880
have a set of parties each with their

236
00:09:12,880 --> 00:09:14,320
private inputs and their goal is to

237
00:09:14,320 --> 00:09:16,160
compute some function c on their inputs

238
00:09:16,160 --> 00:09:18,160
so i interact with each other the

239
00:09:18,160 --> 00:09:19,760
adversary might have some subset of

240
00:09:19,760 --> 00:09:21,600
these parties and we want the security

241
00:09:21,600 --> 00:09:24,000
that adversary shouldn't learn anything

242
00:09:24,000 --> 00:09:25,680
about honest parties input apart from

243
00:09:25,680 --> 00:09:27,120
what it can learn from the output of the

244
00:09:27,120 --> 00:09:28,000
function

245
00:09:28,000 --> 00:09:29,600
and the identity that we are considering

246
00:09:29,600 --> 00:09:31,200
is polynomial time adversaries with

247
00:09:31,200 --> 00:09:33,120
arbitrary static corruptions malicious

248
00:09:33,120 --> 00:09:36,000
behavior and disconnect

249
00:09:48,399 --> 00:09:50,160
and there have been possibility vessels

250
00:09:50,160 --> 00:09:51,760
about two round and three non-npc

251
00:09:51,760 --> 00:09:53,360
protocols

252
00:09:53,360 --> 00:09:55,120
on the positive side we know of constant

253
00:09:55,120 --> 00:09:57,040
round and even four round mvc protocols

254
00:09:57,040 --> 00:09:59,440
receiving 40. given these results it's

255
00:09:59,440 --> 00:10:01,040
natural to ask can we go below four

256
00:10:01,040 --> 00:10:02,399
rounds by relaxing some of the

257
00:10:02,399 --> 00:10:03,680
parameters

258
00:10:03,680 --> 00:10:08,079
indeed in 2018 these uh works like uh

259
00:10:08,079 --> 00:10:10,320
showed how to do two-round mpc assuming

260
00:10:10,320 --> 00:10:12,160
ot but the security was only against

261
00:10:12,160 --> 00:10:14,320
semi-malicious adversities

262
00:10:14,320 --> 00:10:17,120
in 2017 these works showed that we can

263
00:10:17,120 --> 00:10:19,040
do two run maliciously secure and pc

264
00:10:19,040 --> 00:10:21,120
using super polynomial simulation but

265
00:10:21,120 --> 00:10:22,800
the restriction was that only one of the

266
00:10:22,800 --> 00:10:24,880
parties can risk the output

267
00:10:24,880 --> 00:10:26,720
in our work we show how to do two round

268
00:10:26,720 --> 00:10:29,200
militias mpc using super polynomial

269
00:10:29,200 --> 00:10:31,360
simulation where all parties can see the

270
00:10:31,360 --> 00:10:33,600
output at the end of the round

271
00:10:33,600 --> 00:10:35,760
with that let me just give a give a

272
00:10:35,760 --> 00:10:37,920
description of what super polynomial is

273
00:10:37,920 --> 00:10:39,440
so here we describe security in the

274
00:10:39,440 --> 00:10:41,760
usual reality pattern saying that the

275
00:10:41,760 --> 00:10:43,440
real world protocol is secure if there

276
00:10:43,440 --> 00:10:45,360
is an old simulator which can produce a

277
00:10:45,360 --> 00:10:47,760
computation in this especially

278
00:10:47,760 --> 00:10:49,440
but the relaxation here is that we allow

279
00:10:49,440 --> 00:10:51,360
the simulator to run in super polynomial

280
00:10:51,360 --> 00:10:52,240
time

281
00:10:52,240 --> 00:10:53,760
and this makes sense in scenarios

282
00:10:53,760 --> 00:10:55,200
because in most cases the ideal

283
00:10:55,200 --> 00:10:56,959
functionality itself is in super

284
00:10:56,959 --> 00:10:58,959
polynomial

285
00:10:58,959 --> 00:11:01,040
so with that let me describe uh like

286
00:11:01,040 --> 00:11:03,680
into in any tour on npc protocols

287
00:11:03,680 --> 00:11:05,279
parties exchange their first round

288
00:11:05,279 --> 00:11:06,800
message and then the round two message

289
00:11:06,800 --> 00:11:08,720
and at the end retrieve the output of

290
00:11:08,720 --> 00:11:11,200
the function on the private inputs but

291
00:11:11,200 --> 00:11:14,959
if bob is malicious he can send a

292
00:11:16,640 --> 00:11:18,480
bob can not just learn the output of the

293
00:11:18,480 --> 00:11:20,399
function but also clean some information

294
00:11:20,399 --> 00:11:22,959
about private input of alice so what we

295
00:11:22,959 --> 00:11:24,959
need here is that it should do some form

296
00:11:24,959 --> 00:11:26,560
of validation before sending our own

297
00:11:26,560 --> 00:11:28,880
round to message

298
00:11:28,880 --> 00:11:30,240
one straightforward solution is to

299
00:11:30,240 --> 00:11:31,760
attach zero knowledge proofs are testing

300
00:11:31,760 --> 00:11:33,680
the validity of round one message and

301
00:11:33,680 --> 00:11:35,920
have the parties check each other before

302
00:11:35,920 --> 00:11:37,760
sending the round to message

303
00:11:37,760 --> 00:11:39,279
this ensures that the parties only

304
00:11:39,279 --> 00:11:40,640
receive the output of the function and

305
00:11:40,640 --> 00:11:43,200
nothing else but uh these form of

306
00:11:43,200 --> 00:11:45,040
non-interactive zero noise proves us you

307
00:11:45,040 --> 00:11:47,120
require a crs which is a trusted set of

308
00:11:47,120 --> 00:11:48,560
assumptions and in this work we were

309
00:11:48,560 --> 00:11:50,000
trying to construct two round energy

310
00:11:50,000 --> 00:11:52,000
protocols in the play model which is

311
00:11:52,000 --> 00:11:53,680
maliciously secure

312
00:11:53,680 --> 00:11:56,959
so with that we asked whether

313
00:11:58,800 --> 00:12:00,959
for example intuitively can we have it

314
00:12:00,959 --> 00:12:03,040
so that alice can lock her second round

315
00:12:03,040 --> 00:12:05,279
message in a box and send it over so

316
00:12:05,279 --> 00:12:08,720
that the box is decryptable by bob olaf

317
00:12:08,720 --> 00:12:10,959
bob

318
00:12:23,680 --> 00:12:25,680
which is a two-party protocol between

319
00:12:25,680 --> 00:12:27,680
the sender and receiver sender

320
00:12:27,680 --> 00:12:30,000
having a secret message m and receiver

321
00:12:30,000 --> 00:12:33,200
having a secret fitness w and it allows

322
00:12:33,200 --> 00:12:34,639
the sender to transmit them

323
00:12:34,639 --> 00:12:36,480
conditionally to the receiver if the

324
00:12:36,480 --> 00:12:38,880
instance witness player is valid and it

325
00:12:38,880 --> 00:12:40,800
also uh hides the weakness from the

326
00:12:40,800 --> 00:12:42,399
verbs in this view

327
00:12:42,399 --> 00:12:44,720
but this form of two partitions doesn't

328
00:12:44,720 --> 00:12:46,720
directly work in the setting because an

329
00:12:46,720 --> 00:12:48,160
adversary which is corrupting two

330
00:12:48,160 --> 00:12:49,760
possible receivers

331
00:12:49,760 --> 00:12:51,519
sending valid message on behalf of one

332
00:12:51,519 --> 00:12:53,600
receiver an invalid message on behalf of

333
00:12:53,600 --> 00:12:55,920
other receivers can still

334
00:12:55,920 --> 00:12:57,920
retrieve alice's second round message

335
00:12:57,920 --> 00:12:59,920
and we do not want this discipline as

336
00:12:59,920 --> 00:13:02,000
majority second what we want is that the

337
00:13:02,000 --> 00:13:04,639
second round message of alice should be

338
00:13:04,639 --> 00:13:07,200
delivered only if all round one messages

339
00:13:07,200 --> 00:13:09,200
from all other parties were valid

340
00:13:09,200 --> 00:13:10,959
so with that we formalized the notion of

341
00:13:10,959 --> 00:13:13,360
multi-party version of cds where we have

342
00:13:13,360 --> 00:13:15,440
a sender and multiple possible receivers

343
00:13:15,440 --> 00:13:18,160
each with the instructions

344
00:13:18,160 --> 00:13:20,959
and we want to achieve the functionality

345
00:13:20,959 --> 00:13:23,079
that the sender secret message should be

346
00:13:23,079 --> 00:13:25,920
transferred to all receivers if all

347
00:13:25,920 --> 00:13:28,240
instance witness players were valid

348
00:13:28,240 --> 00:13:29,920
so our approach for constructing this

349
00:13:29,920 --> 00:13:31,920
multi-party cts is the following so we

350
00:13:31,920 --> 00:13:32,959
start with

351
00:13:32,959 --> 00:13:34,800
this primitive called witness encryption

352
00:13:34,800 --> 00:13:36,320
foreign

353
00:13:36,320 --> 00:13:40,160
in the crs model given in this paper

354
00:13:40,160 --> 00:13:42,320
this is based on ssds assumption on my

355
00:13:42,320 --> 00:13:44,720
linear groups we remove the crs in the

356
00:13:44,720 --> 00:13:47,120
protocol using newbies and what we get

357
00:13:47,120 --> 00:13:49,360
in the end is two party cts with a

358
00:13:49,360 --> 00:13:50,639
special property called public

359
00:13:50,639 --> 00:13:52,880
reconstruction in the plain water

360
00:13:52,880 --> 00:13:54,880
and this public reconstruction allows

361
00:13:54,880 --> 00:13:57,839
the ciphertext of witness encrypted

362
00:13:57,839 --> 00:14:00,160
plaintext to be decryptable using public

363
00:14:00,160 --> 00:14:02,639
groups and by relying on this public

364
00:14:02,639 --> 00:14:04,320
reconstruction property we extend it to

365
00:14:04,320 --> 00:14:06,480
multi-party serious in the plane model

366
00:14:06,480 --> 00:14:08,079
by just secret sharing the sender's

367
00:14:08,079 --> 00:14:10,079
message across multiple

368
00:14:10,079 --> 00:14:12,320
two-party serious sessions

369
00:14:12,320 --> 00:14:14,320
so finally we get a multi-party cps

370
00:14:14,320 --> 00:14:15,519
protocol which has the following

371
00:14:15,519 --> 00:14:17,839
interaction pattern in round one

372
00:14:17,839 --> 00:14:20,079
receivers send some encodings of the

373
00:14:20,079 --> 00:14:22,399
input to the senders and in round two

374
00:14:22,399 --> 00:14:24,320
senders and ciphertext to the receivers

375
00:14:24,320 --> 00:14:26,240
and receivers at the same time can

376
00:14:26,240 --> 00:14:28,959
exchange proofs with each other and what

377
00:14:28,959 --> 00:14:30,639
happens at the end of round two is all

378
00:14:30,639 --> 00:14:32,240
receivers

379
00:14:32,240 --> 00:14:34,040
is the correctness property so if all

380
00:14:34,040 --> 00:14:36,800
instances were valid then all receivers

381
00:14:36,800 --> 00:14:39,040
can retrieve the center's message at the

382
00:14:39,040 --> 00:14:41,120
end of round two center security says

383
00:14:41,120 --> 00:14:42,880
that if any of the instances were

384
00:14:42,880 --> 00:14:44,880
invalid then the sender's message m is

385
00:14:44,880 --> 00:14:46,720
written from all the receivers and

386
00:14:46,720 --> 00:14:48,480
receiver security says that sender's

387
00:14:48,480 --> 00:14:49,519
view is computationally

388
00:14:49,519 --> 00:14:51,120
indistinguishable between two possible

389
00:14:51,120 --> 00:14:52,800
choices or witnesses used by the

390
00:14:52,800 --> 00:14:54,240
receiver

391
00:14:54,240 --> 00:14:56,320
sender security should hold even if some

392
00:14:56,320 --> 00:14:58,000
subset of receivers are polluting and

393
00:14:58,000 --> 00:14:59,760
receiver security should hold even a

394
00:14:59,760 --> 00:15:01,839
sender and some set of receivers are

395
00:15:01,839 --> 00:15:03,120
valid

396
00:15:03,120 --> 00:15:05,279
so with that we use this mcds product

397
00:15:05,279 --> 00:15:07,440
mcgs primitive to combine any general

398
00:15:07,440 --> 00:15:09,360
two rounds any maliciously secure nbc

399
00:15:09,360 --> 00:15:10,959
protocol into a two round fully

400
00:15:10,959 --> 00:15:14,079
malicious said lee secure mpc protocol

401
00:15:14,079 --> 00:15:16,320
in the following way so note that in any

402
00:15:16,320 --> 00:15:18,560
two round semi-malicious mtc protocol

403
00:15:18,560 --> 00:15:20,320
part is exchanged around one message and

404
00:15:20,320 --> 00:15:22,720
round two messages

405
00:15:22,720 --> 00:15:24,560
now what we do as a first step is just

406
00:15:24,560 --> 00:15:26,560
condition the transfer of second non-mpc

407
00:15:26,560 --> 00:15:28,160
message on an np statement which

408
00:15:28,160 --> 00:15:30,399
captures the validity of round one and

409
00:15:30,399 --> 00:15:33,279
pc matches messages of other parties

410
00:15:33,279 --> 00:15:35,199
this is not sufficient because the mcds

411
00:15:35,199 --> 00:15:37,040
that we construct only provides a wi

412
00:15:37,040 --> 00:15:38,880
style kind of id

413
00:15:38,880 --> 00:15:42,320
so what we do is uh we resort we add

414
00:15:42,320 --> 00:15:44,160
attend the round one message to include

415
00:15:44,160 --> 00:15:46,399
commitments to some traveler values and

416
00:15:46,399 --> 00:15:48,320
commitments to potential guests to those

417
00:15:48,320 --> 00:15:49,920
trapper values and this is the

418
00:15:49,920 --> 00:15:52,880
reminiscent of the vibration

419
00:15:52,880 --> 00:15:56,399
so and we then modify the mcds statement

420
00:15:56,399 --> 00:15:57,360
to

421
00:15:57,360 --> 00:15:59,040
have the following condition so the

422
00:15:59,040 --> 00:16:00,959
round to mpc message will be transferred

423
00:16:00,959 --> 00:16:03,519
if around one mpc message of all other

424
00:16:03,519 --> 00:16:05,600
parties were valid or

425
00:16:05,600 --> 00:16:07,519
the other party successfully guessed the

426
00:16:07,519 --> 00:16:10,320
trapdoor values

427
00:16:10,480 --> 00:16:12,240
and we require some form of special

428
00:16:12,240 --> 00:16:14,160
non-malignant property to hold between

429
00:16:14,160 --> 00:16:16,639
these blue and yellow commitments

430
00:16:16,639 --> 00:16:18,160
which for which i'll refer you to the

431
00:16:18,160 --> 00:16:20,000
paper so our final result is the

432
00:16:20,000 --> 00:16:21,519
following there exists a two-round

433
00:16:21,519 --> 00:16:23,360
maliciously secure mpc protocol in the

434
00:16:23,360 --> 00:16:24,880
plane model with super polynomial

435
00:16:24,880 --> 00:16:27,199
simulation assuming a bilinear group in

436
00:16:27,199 --> 00:16:29,759
which gillin and ssdf sub exponentially

437
00:16:29,759 --> 00:16:31,920
are and we use the string strand sheets

438
00:16:31,920 --> 00:16:34,399
of exponential secure versions of gos

439
00:16:34,399 --> 00:16:36,560
naming and memo development with the

440
00:16:36,560 --> 00:16:38,399
subscription scheme we also require two

441
00:16:38,399 --> 00:16:40,160
rounds of exponentially secured mpc

442
00:16:40,160 --> 00:16:42,320
against semi-malicious adversaries

443
00:16:42,320 --> 00:16:44,000
this follows by instantiating known

444
00:16:44,000 --> 00:16:46,959
works of exponential security

445
00:16:46,959 --> 00:16:48,560
for the special non-interactive non-male

446
00:16:48,560 --> 00:16:50,720
level commitments we require we have two

447
00:16:50,720 --> 00:16:52,639
possible instantiations for constant

448
00:16:52,639 --> 00:16:54,560
number of parties this follows from sub

449
00:16:54,560 --> 00:16:56,560
exponentially secure time numbers and

450
00:16:56,560 --> 00:16:59,040
sub exponential quantum parts of l

451
00:16:59,040 --> 00:17:00,560
but bounded by the normal number of

452
00:17:00,560 --> 00:17:02,560
parties we require sub exponential

453
00:17:02,560 --> 00:17:04,319
quantum hardware hardness amplitude of

454
00:17:04,319 --> 00:17:06,079
lw sub exponential hardness

455
00:17:06,079 --> 00:17:07,760
amplifiability of dth and sub

456
00:17:07,760 --> 00:17:11,959
exponentially secure one must

457
00:17:26,240 --> 00:17:28,559
i have a question like did you look for

458
00:17:28,559 --> 00:17:30,880
other places for this idea

459
00:17:30,880 --> 00:17:32,960
of

460
00:17:33,120 --> 00:17:36,280
[Music]

461
00:17:39,760 --> 00:17:42,760
uh

462
00:17:56,750 --> 00:18:00,430
[Music]

463
00:18:08,200 --> 00:18:11,319
[Music]

464
00:18:13,440 --> 00:18:16,480
so this kind of uh

465
00:18:16,480 --> 00:18:18,720
guarantee is not what is

466
00:18:18,720 --> 00:18:21,280
in previous

467
00:18:21,679 --> 00:18:24,679
questions

468
00:18:34,160 --> 00:18:36,880
uh so when whenever you have like some

469
00:18:36,880 --> 00:18:38,880
threshold number of corruptions you have

470
00:18:38,880 --> 00:18:41,360
kind of guaranteed artillery no no we

471
00:18:41,360 --> 00:18:42,720
don't focus on guaranteed output

472
00:18:42,720 --> 00:18:44,240
delivery so just

473
00:18:44,240 --> 00:18:45,039
this one

474
00:18:45,039 --> 00:18:47,360
if you have one rupture yeah

475
00:18:47,360 --> 00:18:49,200
yeah even if there's one corruption the

476
00:18:49,200 --> 00:18:50,799
party can send invalid messages and

477
00:18:50,799 --> 00:18:54,480
avoid the protocol yeah

478
00:18:55,200 --> 00:18:59,720
all right so let's find it again

479
00:19:29,120 --> 00:19:31,679
this one our next

480
00:19:31,679 --> 00:19:33,120
should remember to take the software on

481
00:19:33,120 --> 00:19:34,080
sp

482
00:19:34,080 --> 00:19:36,080
this is our next presentation adaptive

483
00:19:36,080 --> 00:19:37,919
security of multi-party product forms is

484
00:19:37,919 --> 00:19:38,960
visited

485
00:19:38,960 --> 00:19:42,000
by martin herritt chandler zhang and

486
00:19:42,000 --> 00:19:43,360
julie maurer

487
00:19:43,360 --> 00:19:46,000
and chanda will give the presentation we

488
00:19:46,000 --> 00:19:48,160
already heard

489
00:19:48,160 --> 00:19:52,400
in this session about another world

490
00:19:52,400 --> 00:19:55,039
so thanks for for the introduction so

491
00:19:55,039 --> 00:19:57,360
this paper is on security definitions

492
00:19:57,360 --> 00:20:00,000
for npc protocols

493
00:20:00,000 --> 00:20:02,080
well we already know what npc is about

494
00:20:02,080 --> 00:20:04,799
right parties have computed devices some

495
00:20:04,799 --> 00:20:06,960
can be hacked and so on and the goal is

496
00:20:06,960 --> 00:20:09,919
to construct an ideal

497
00:20:09,919 --> 00:20:12,240
secure distributed system even when some

498
00:20:12,240 --> 00:20:15,280
of the devices can be hacked

499
00:20:15,280 --> 00:20:17,200
and in this work we consider the setting

500
00:20:17,200 --> 00:20:19,120
of adaptive corruption where the

501
00:20:19,120 --> 00:20:21,200
corruption choice can be made during the

502
00:20:21,200 --> 00:20:23,760
protocol execution and based on any

503
00:20:23,760 --> 00:20:25,600
information that has been gathered so

504
00:20:25,600 --> 00:20:27,760
far

505
00:20:28,080 --> 00:20:29,919
so the standard adaptive security

506
00:20:29,919 --> 00:20:32,720
definition kind of says that we obtain

507
00:20:32,720 --> 00:20:35,520
an ideal system that consists of this

508
00:20:35,520 --> 00:20:37,679
npc system this is kind of the trusted

509
00:20:37,679 --> 00:20:38,720
party

510
00:20:38,720 --> 00:20:40,559
and we also have a simulator that is

511
00:20:40,559 --> 00:20:41,760
supposed to

512
00:20:41,760 --> 00:20:44,320
to simulate anything that is linked to

513
00:20:44,320 --> 00:20:46,559
the adversary in the real world

514
00:20:46,559 --> 00:20:48,559
the simulator has to come up with this

515
00:20:48,559 --> 00:20:51,280
uh using only the data of the corrupted

516
00:20:51,280 --> 00:20:53,760
parties at any point in time

517
00:20:53,760 --> 00:20:55,600
so for example if parties three and four

518
00:20:55,600 --> 00:20:57,919
are corrupted we have to generate this

519
00:20:57,919 --> 00:20:59,679
view based on

520
00:20:59,679 --> 00:21:03,840
the inputs and outputs of partisan

521
00:21:04,240 --> 00:21:06,720
while this definition is very intuitive

522
00:21:06,720 --> 00:21:08,880
right like anything that happens in

523
00:21:08,880 --> 00:21:10,799
the real world i can reproduce in the

524
00:21:10,799 --> 00:21:13,440
ideal world

525
00:21:13,440 --> 00:21:15,760
it seems to be apparently technically

526
00:21:15,760 --> 00:21:17,840
too strong and one of the

527
00:21:17,840 --> 00:21:20,480
main challenges is the so-called

528
00:21:20,480 --> 00:21:22,320
commitment problem

529
00:21:22,320 --> 00:21:24,320
so let me try to explain it with a very

530
00:21:24,320 --> 00:21:26,240
simple example so imagine that there are

531
00:21:26,240 --> 00:21:28,720
two parties c one p two

532
00:21:28,720 --> 00:21:31,600
party one gives an input and commits to

533
00:21:31,600 --> 00:21:34,480
its input using some perfectly hiding

534
00:21:34,480 --> 00:21:36,960
commitment scheme let's say

535
00:21:36,960 --> 00:21:38,880
and because the channel is authenticated

536
00:21:38,880 --> 00:21:41,600
the adversary sees this block e

537
00:21:41,600 --> 00:21:43,600
and therefore the simulator has to come

538
00:21:43,600 --> 00:21:46,640
up with a fake block b prime

539
00:21:46,640 --> 00:21:48,720
without knowing what the input is

540
00:21:48,720 --> 00:21:51,679
because party one is on this right

541
00:21:51,679 --> 00:21:53,919
the problem now is that if that bursary

542
00:21:53,919 --> 00:21:57,280
adaptively corrupts rtp1 it learns its

543
00:21:57,280 --> 00:21:59,200
internal state and therefore the

544
00:21:59,200 --> 00:22:01,360
simulator cannot explain the internal

545
00:22:01,360 --> 00:22:04,000
state it cannot open the fake commitment

546
00:22:04,000 --> 00:22:08,400
b prime with respect to the input x1

547
00:22:08,400 --> 00:22:10,240
and what does this mean right the first

548
00:22:10,240 --> 00:22:12,240
thing we can ask is whether this is like

549
00:22:12,240 --> 00:22:15,440
a real problem or not maybe yes maybe

550
00:22:15,440 --> 00:22:16,480
not

551
00:22:16,480 --> 00:22:18,320
so imagine that we are given this super

552
00:22:18,320 --> 00:22:20,640
secure protocol someone very smart gave

553
00:22:20,640 --> 00:22:22,720
us this protocol

554
00:22:22,720 --> 00:22:24,640
and he promises us that this is super

555
00:22:24,640 --> 00:22:27,360
secure right

556
00:22:27,360 --> 00:22:29,200
but we just do some random stuff in the

557
00:22:29,200 --> 00:22:31,280
beginning we get an input we commit to

558
00:22:31,280 --> 00:22:32,000
it

559
00:22:32,000 --> 00:22:34,320
and the overall protocol is

560
00:22:34,320 --> 00:22:36,080
at least we cannot prove that the

561
00:22:36,080 --> 00:22:38,320
overall protocol is secure under the

562
00:22:38,320 --> 00:22:40,799
current adaptive notion

563
00:22:40,799 --> 00:22:42,720
which means that

564
00:22:42,720 --> 00:22:44,799
the fact that we publish this commitment

565
00:22:44,799 --> 00:22:47,120
scheme makes the overall protocol

566
00:22:47,120 --> 00:22:48,240
insecure

567
00:22:48,240 --> 00:22:49,760
or at least we don't know how to prove

568
00:22:49,760 --> 00:22:51,039
it secure

569
00:22:51,039 --> 00:22:53,840
and even when the commitment is or even

570
00:22:53,840 --> 00:22:55,760
when the block is

571
00:22:55,760 --> 00:22:58,640
perfectly hiding right even when the

572
00:22:58,640 --> 00:22:59,840
string b

573
00:22:59,840 --> 00:23:02,159
is statistically independent of the

574
00:23:02,159 --> 00:23:06,000
input x1 and no matter how secure

575
00:23:06,000 --> 00:23:06,720
the

576
00:23:06,720 --> 00:23:10,240
the following protocol is

577
00:23:10,559 --> 00:23:14,400
um and as a result typically we

578
00:23:14,400 --> 00:23:16,640
we use things like security ratios

579
00:23:16,640 --> 00:23:19,679
incurring an additional assumption or we

580
00:23:19,679 --> 00:23:21,919
or we make use of other primitives like

581
00:23:21,919 --> 00:23:23,679
non-committing encryption

582
00:23:23,679 --> 00:23:25,120
which incur

583
00:23:25,120 --> 00:23:28,240
an important efficiency loss

584
00:23:28,240 --> 00:23:30,400
so in this paper we basically ask is

585
00:23:30,400 --> 00:23:32,720
there a natural definition for adaptive

586
00:23:32,720 --> 00:23:34,080
security

587
00:23:34,080 --> 00:23:36,720
that is not subject to this commitment

588
00:23:36,720 --> 00:23:38,159
problem

589
00:23:38,159 --> 00:23:39,200
um

590
00:23:39,200 --> 00:23:40,960
the answer is yes

591
00:23:40,960 --> 00:23:43,440
and the idea is basically

592
00:23:43,440 --> 00:23:45,919
our solution is basically we make a

593
00:23:45,919 --> 00:23:47,120
security

594
00:23:47,120 --> 00:23:48,320
statement

595
00:23:48,320 --> 00:23:51,200
for each possible set of parties

596
00:23:51,200 --> 00:23:53,760
and the statement holds as long as

597
00:23:53,760 --> 00:23:56,880
the set of parties honest so for example

598
00:23:56,880 --> 00:23:58,640
in the case where we have these three

599
00:23:58,640 --> 00:24:00,880
parties p1 to p3

600
00:24:00,880 --> 00:24:03,279
in the beginning we make all this

601
00:24:03,279 --> 00:24:05,919
number of statements as soon as p1 is

602
00:24:05,919 --> 00:24:07,039
corrupted

603
00:24:07,039 --> 00:24:09,360
some of the statements do not need to

604
00:24:09,360 --> 00:24:11,039
hold anymore but

605
00:24:11,039 --> 00:24:13,039
but all those statements that correspond

606
00:24:13,039 --> 00:24:13,840
to

607
00:24:13,840 --> 00:24:17,679
sets of so far honest parties still hold

608
00:24:17,679 --> 00:24:20,320
and so on and so forth

609
00:24:20,320 --> 00:24:21,760
and we will

610
00:24:21,760 --> 00:24:23,919
give an instantiation where the

611
00:24:23,919 --> 00:24:26,000
guarantee will ensure the following

612
00:24:26,000 --> 00:24:28,080
somehow like intuitively what we are

613
00:24:28,080 --> 00:24:30,640
saying is that any information that is

614
00:24:30,640 --> 00:24:32,720
leaked up to time t

615
00:24:32,720 --> 00:24:35,600
i can explain uh with the data of

616
00:24:35,600 --> 00:24:37,919
corrupted parties at that specific point

617
00:24:37,919 --> 00:24:40,559
in time and this holds for any point in

618
00:24:40,559 --> 00:24:42,159
time

619
00:24:42,159 --> 00:24:44,640
and technically the guarantee for asset

620
00:24:44,640 --> 00:24:47,200
excess um

621
00:24:47,200 --> 00:24:49,520
the data that has been linked to the

622
00:24:49,520 --> 00:24:52,960
adversary so far depends only on the

623
00:24:52,960 --> 00:24:55,840
data of artists that are not indexed

624
00:24:55,840 --> 00:24:57,520
irrespective of whether they are

625
00:24:57,520 --> 00:24:59,919
corrupted or not so technically we're

626
00:24:59,919 --> 00:25:02,480
saying the simulator can read the inputs

627
00:25:02,480 --> 00:25:05,919
of any party that is not in x

628
00:25:05,919 --> 00:25:08,640
and this guarantee has to hold for any

629
00:25:08,640 --> 00:25:13,279
set x as long as the set x is honest

630
00:25:13,279 --> 00:25:16,000
and here are some lemons about our

631
00:25:16,000 --> 00:25:19,039
proposed definition so our definition is

632
00:25:19,039 --> 00:25:21,120
kind of strictly in the middle of the

633
00:25:21,120 --> 00:25:22,320
current

634
00:25:22,320 --> 00:25:23,520
adaptive

635
00:25:23,520 --> 00:25:25,840
standard adaptive definition that that

636
00:25:25,840 --> 00:25:29,919
exists and static it overcomes the type

637
00:25:29,919 --> 00:25:31,919
of commitment problem that i told you

638
00:25:31,919 --> 00:25:32,880
before

639
00:25:32,880 --> 00:25:35,120
and as a result many of these protocols

640
00:25:35,120 --> 00:25:36,640
that are believed to be secure in

641
00:25:36,640 --> 00:25:39,840
practice like cdn based on threshold

642
00:25:39,840 --> 00:25:41,679
homomorphic encryption and also the

643
00:25:41,679 --> 00:25:43,840
clause protocol the one that

644
00:25:43,840 --> 00:25:46,400
doesn't use non-committing encryption

645
00:25:46,400 --> 00:25:48,559
these two protocols are can be proven

646
00:25:48,559 --> 00:25:52,080
secure under the new notion

647
00:25:52,080 --> 00:25:54,000
and also on the other hand we also

648
00:25:54,000 --> 00:25:56,799
believe that this security definition

649
00:25:56,799 --> 00:25:58,799
gives strong adaptive security

650
00:25:58,799 --> 00:26:00,880
guarantees in the sense that

651
00:26:00,880 --> 00:26:03,200
many of the examples that separate

652
00:26:03,200 --> 00:26:06,080
static from standard adaptive actually

653
00:26:06,080 --> 00:26:08,000
also separate static

654
00:26:08,000 --> 00:26:10,559
from our new notion

655
00:26:10,559 --> 00:26:12,880
yeah so for more details i can refer you

656
00:26:12,880 --> 00:26:16,960
to the aprilian version of the paper

657
00:26:21,520 --> 00:26:24,760
thank you

658
00:26:33,840 --> 00:26:36,680
okay so let's say i think china again

659
00:26:36,680 --> 00:26:39,839
[Applause]

660
00:27:12,320 --> 00:27:13,600
okay

661
00:27:13,600 --> 00:27:14,480
so

662
00:27:14,480 --> 00:27:15,919
in the next presentation we'll hear

663
00:27:15,919 --> 00:27:17,760
about dory efficient transparent

664
00:27:17,760 --> 00:27:19,919
arguments for generalized inner products

665
00:27:19,919 --> 00:27:22,080
and polynomial commitments

666
00:27:22,080 --> 00:27:24,880
and jonathan lee will give a talk well

667
00:27:24,880 --> 00:27:26,720
thank you for introduction

668
00:27:26,720 --> 00:27:28,960
so

669
00:27:31,279 --> 00:27:32,960
if this works

670
00:27:32,960 --> 00:27:34,880
go um so right so what what's the

671
00:27:34,880 --> 00:27:36,559
efficient transparent item we've seen

672
00:27:36,559 --> 00:27:37,840
enough argument protocols in the last

673
00:27:37,840 --> 00:27:39,440
couple of days so we have approver

674
00:27:39,440 --> 00:27:40,720
verifiers

675
00:27:40,720 --> 00:27:41,440
l

676
00:27:41,440 --> 00:27:43,520
um and basically the approver has to try

677
00:27:43,520 --> 00:27:45,520
to demonstrate to the verifier that they

678
00:27:45,520 --> 00:27:48,559
know somewhere else for x being an l um

679
00:27:48,559 --> 00:27:50,159
now in this talk we're going to be

680
00:27:50,159 --> 00:27:51,360
thinking about some sort of

681
00:27:51,360 --> 00:27:53,279
computational sentence

682
00:27:53,279 --> 00:27:55,679
so p is going to accept if and only if

683
00:27:55,679 --> 00:27:57,600
it does know someone witness modulo as i

684
00:27:57,600 --> 00:27:59,840
say some computation or something

685
00:27:59,840 --> 00:28:01,760
um now the two interesting things we're

686
00:28:01,760 --> 00:28:03,840
going to require is one we want these

687
00:28:03,840 --> 00:28:05,840
things to be efficient so what that's

688
00:28:05,840 --> 00:28:07,919
going to mean in getting this context is

689
00:28:07,919 --> 00:28:10,240
that the setup stage there is one and

690
00:28:10,240 --> 00:28:11,760
proving uh

691
00:28:11,760 --> 00:28:12,960
are going to be

692
00:28:12,960 --> 00:28:15,120
on the order of the witness site

693
00:28:15,120 --> 00:28:16,640
and verification proof sites are going

694
00:28:16,640 --> 00:28:20,000
to be uh ordered a lot of the witnesses

695
00:28:20,000 --> 00:28:21,039
throughout there's going to be some sort

696
00:28:21,039 --> 00:28:22,320
of dependence on what the concrete

697
00:28:22,320 --> 00:28:23,520
security level is i'm going to suppress

698
00:28:23,520 --> 00:28:24,559
that

699
00:28:24,559 --> 00:28:26,399
and the other segment is that we need

700
00:28:26,399 --> 00:28:28,480
these systems to be transparent that

701
00:28:28,480 --> 00:28:30,320
means that the setup can't have success

702
00:28:30,320 --> 00:28:31,919
so for example you can't use content

703
00:28:31,919 --> 00:28:33,760
style commitments where there's some koe

704
00:28:33,760 --> 00:28:36,880
and uh some some secret uh

705
00:28:36,880 --> 00:28:39,360
so what's the setting um field skaters

706
00:28:39,360 --> 00:28:40,880
we're gonna have some curve

707
00:28:40,880 --> 00:28:42,960
uh we're gonna need a parent and the two

708
00:28:42,960 --> 00:28:43,919
kinds of arguments we're going to be

709
00:28:43,919 --> 00:28:45,440
interested in are generalizes in a

710
00:28:45,440 --> 00:28:47,520
product documents so here i've written

711
00:28:47,520 --> 00:28:49,360
this in a slightly abstract form but

712
00:28:49,360 --> 00:28:50,720
we've got some vector spaces we've got

713
00:28:50,720 --> 00:28:53,200
some pairing

714
00:28:54,159 --> 00:28:57,440
and the notion is that if you commit to

715
00:28:57,440 --> 00:28:58,799
these inputs into the output then you

716
00:28:58,799 --> 00:29:00,240
can make some argument that you have no

717
00:29:00,240 --> 00:29:02,000
openings consistent with the inner

718
00:29:02,000 --> 00:29:03,440
provider

719
00:29:03,440 --> 00:29:05,120
and then this very naturally gives you a

720
00:29:05,120 --> 00:29:07,440
polynomial command so in this context

721
00:29:07,440 --> 00:29:09,200
you fix some degree sequence

722
00:29:09,200 --> 00:29:11,039
and now much as before you would come to

723
00:29:11,039 --> 00:29:12,240
a polynomial you connect with an

724
00:29:12,240 --> 00:29:14,320
evaluation of that following angle uh

725
00:29:14,320 --> 00:29:15,760
and there's some argument that allows

726
00:29:15,760 --> 00:29:18,159
you to prove that you can uh

727
00:29:18,159 --> 00:29:20,000
open that commitment to a polynomial to

728
00:29:20,000 --> 00:29:21,200
something which is consistent with

729
00:29:21,200 --> 00:29:22,799
evaluations

730
00:29:22,799 --> 00:29:24,320
um i should note that polynomial

731
00:29:24,320 --> 00:29:25,600
commitments are obviously a

732
00:29:25,600 --> 00:29:27,440
specialization of uh inner product

733
00:29:27,440 --> 00:29:30,720
arguments because you can uh just take x

734
00:29:30,720 --> 00:29:32,480
multiply it out and then look at the

735
00:29:32,480 --> 00:29:34,559
monomials one by one

736
00:29:34,559 --> 00:29:36,080
so why would you care about this thing

737
00:29:36,080 --> 00:29:37,840
other than it maybe being intrinsically

738
00:29:37,840 --> 00:29:41,039
interesting um mostly the there are some

739
00:29:41,039 --> 00:29:43,600
nice ways of building z case marks for

740
00:29:43,600 --> 00:29:45,440
empty complete languages out of polymer

741
00:29:45,440 --> 00:29:46,640
documents

742
00:29:46,640 --> 00:29:48,720
so there's a many prior works that show

743
00:29:48,720 --> 00:29:50,559
you how to do some purely information

744
00:29:50,559 --> 00:29:54,640
theoretic reduction um with um log size

745
00:29:54,640 --> 00:29:57,440
proofs and lots of verifies um but you

746
00:29:57,440 --> 00:29:58,799
need to be able to you know do these

747
00:29:58,799 --> 00:30:01,120
polynomial commitment operations

748
00:30:01,120 --> 00:30:04,240
um and many works have sort of bundled

749
00:30:04,240 --> 00:30:06,159
particular ways of doing that reduction

750
00:30:06,159 --> 00:30:08,960
with particular

751
00:30:16,960 --> 00:30:18,240
[Music]

752
00:30:18,240 --> 00:30:19,600
irritating technical implications for

753
00:30:19,600 --> 00:30:22,879
the security definitions for which

754
00:30:23,120 --> 00:30:25,360
um so again given that we care about

755
00:30:25,360 --> 00:30:27,279
applications every once in a while we

756
00:30:27,279 --> 00:30:28,480
would like to have concretely small

757
00:30:28,480 --> 00:30:31,840
constants um and also in practice you

758
00:30:31,840 --> 00:30:34,240
will find that uh many of these

759
00:30:34,240 --> 00:30:36,159
applications will produce several

760
00:30:36,159 --> 00:30:38,399
polynomials and maybe evaluate them in a

761
00:30:38,399 --> 00:30:41,360
few places um so it would be quite nice

762
00:30:41,360 --> 00:30:43,120
uh if you could evaluate batch of

763
00:30:43,120 --> 00:30:44,799
polynomials at some factual places and

764
00:30:44,799 --> 00:30:47,760
do that more efficiently

765
00:30:48,399 --> 00:30:49,200
um

766
00:30:49,200 --> 00:30:51,520
so this is by no means an exhaustive

767
00:30:51,520 --> 00:30:53,600
list of all private work but uh there

768
00:30:53,600 --> 00:30:56,080
are here three examples of

769
00:30:56,080 --> 00:30:57,279
um

770
00:30:57,279 --> 00:30:59,440
i will say like best in class ways of

771
00:30:59,440 --> 00:31:01,519
doing this so uh you think have things

772
00:31:01,519 --> 00:31:04,000
like hyrax which are based on uh no

773
00:31:04,000 --> 00:31:06,640
patterns um you have things like fractal

774
00:31:06,640 --> 00:31:09,519
which are based on uh typically um

775
00:31:09,519 --> 00:31:11,279
interactive uh

776
00:31:11,279 --> 00:31:12,480
interactive proximity proof through

777
00:31:12,480 --> 00:31:14,480
retirement codes and so ultimately on

778
00:31:14,480 --> 00:31:17,200
hashing and you have some new and as

779
00:31:17,200 --> 00:31:19,840
best i understand not yet uh concretely

780
00:31:19,840 --> 00:31:22,240
implemented uh schemes like supersonic

781
00:31:22,240 --> 00:31:23,600
which are based on groups of unknown

782
00:31:23,600 --> 00:31:25,360
order and has some really interesting

783
00:31:25,360 --> 00:31:27,679
effects so you know at a fixed security

784
00:31:27,679 --> 00:31:31,039
level uh just concretely 128 bits um

785
00:31:31,039 --> 00:31:33,039
what does this look like practically

786
00:31:33,039 --> 00:31:34,480
like what are the sort of hidden

787
00:31:34,480 --> 00:31:35,919
constants you might see in these kinds

788
00:31:35,919 --> 00:31:36,960
of schemes

789
00:31:36,960 --> 00:31:38,080
well

790
00:31:38,080 --> 00:31:40,240
so again we have some concrete sizes

791
00:31:40,240 --> 00:31:41,919
between depending on scheme you might

792
00:31:41,919 --> 00:31:43,919
lose maybe an order of magnitude there

793
00:31:43,919 --> 00:31:45,039
and similarly when you look at the

794
00:31:45,039 --> 00:31:46,799
actual time it takes to do these things

795
00:31:46,799 --> 00:31:48,159
you can lose

796
00:31:48,159 --> 00:31:49,519
anything between three and six orders of

797
00:31:49,519 --> 00:31:51,200
magnitude so it's like these are

798
00:31:51,200 --> 00:31:54,480
in sometimes just constants

799
00:31:54,480 --> 00:31:55,360
um

800
00:31:55,360 --> 00:31:56,880
and you know like given that you might

801
00:31:56,880 --> 00:31:58,320
have to transmit a commitment and then

802
00:31:58,320 --> 00:32:00,559
open it there are some things which get

803
00:32:00,559 --> 00:32:02,960
a little trouble in here so uh pyrex has

804
00:32:02,960 --> 00:32:04,480
quite large commitments that's pretty

805
00:32:04,480 --> 00:32:07,360
unavoidable um things like frankfurt

806
00:32:07,360 --> 00:32:09,519
thought uh an extra strategy factor that

807
00:32:09,519 --> 00:32:11,360
we don't really like uh and things like

808
00:32:11,360 --> 00:32:13,679
supersonic again log factors and also

809
00:32:13,679 --> 00:32:16,320
concretely very slow

810
00:32:16,320 --> 00:32:17,840
um so yeah as it's traditional i have a

811
00:32:17,840 --> 00:32:19,760
table that looks like this and you know

812
00:32:19,760 --> 00:32:20,880
i'm gonna have to tell you what this

813
00:32:20,880 --> 00:32:22,159
works

814
00:32:22,159 --> 00:32:23,840
so the main difference is we're gonna

815
00:32:23,840 --> 00:32:26,399
require a pair um but once you give me

816
00:32:26,399 --> 00:32:28,080
that pairing everything else cleans up

817
00:32:28,080 --> 00:32:30,080
so we have uh logarithmic time to

818
00:32:30,080 --> 00:32:32,880
evaluate space uh set up and evaluation

819
00:32:32,880 --> 00:32:34,880
on improve side are running in square

820
00:32:34,880 --> 00:32:36,559
root which is quite nice

821
00:32:36,559 --> 00:32:38,559
and the concrete constants are a little

822
00:32:38,559 --> 00:32:40,480
worse than they would be in something

823
00:32:40,480 --> 00:32:42,080
like pirates basically because we've

824
00:32:42,080 --> 00:32:44,080
moved from just a curve when they're

825
00:32:44,080 --> 00:32:46,480
pairing like curve 25519 up to a curve

826
00:32:46,480 --> 00:32:48,559
where they have a concrete ebl s12 for

827
00:32:48,559 --> 00:32:49,760
81.

828
00:32:49,760 --> 00:32:50,640
um

829
00:32:50,640 --> 00:32:52,960
but yeah we'll see what this is

830
00:32:52,960 --> 00:32:54,640
practically useful later

831
00:32:54,640 --> 00:32:56,640
so what is actually what is actually

832
00:32:56,640 --> 00:32:58,240
going on here so it's a new journalist

833
00:32:58,240 --> 00:33:00,000
and a product argument and so we get a

834
00:33:00,000 --> 00:33:00,799
porn

835
00:33:00,799 --> 00:33:03,200
scheme um it's morally very similar to

836
00:33:03,200 --> 00:33:06,080
bulletproofs uh or the uh more recent

837
00:33:06,080 --> 00:33:08,880
generalization of product documents um

838
00:33:08,880 --> 00:33:10,320
and like the easiest way to think about

839
00:33:10,320 --> 00:33:12,240
this is multilingual polynomials but

840
00:33:12,240 --> 00:33:13,760
yeah the paper has details on how to do

841
00:33:13,760 --> 00:33:15,679
anything so what do we need we need ssdh

842
00:33:15,679 --> 00:33:18,880
so no not nothing too unusual um

843
00:33:18,880 --> 00:33:20,000
and the

844
00:33:20,000 --> 00:33:22,320
basic point here is that we're going to

845
00:33:22,320 --> 00:33:24,480
uh in the setup stage we sample some

846
00:33:24,480 --> 00:33:26,159
large number of elements and then we

847
00:33:26,159 --> 00:33:28,240
compute a very small number of

848
00:33:28,240 --> 00:33:30,480
structured commitments to those elements

849
00:33:30,480 --> 00:33:32,799
um and the verifier in a slightly clever

850
00:33:32,799 --> 00:33:34,399
way is going to use those commitments to

851
00:33:34,399 --> 00:33:35,440
be able to offload a bunch of this

852
00:33:35,440 --> 00:33:37,039
computation so whereas in something like

853
00:33:37,039 --> 00:33:38,320
bullet proofs you end up with some

854
00:33:38,320 --> 00:33:40,159
linear computation on verifier here

855
00:33:40,159 --> 00:33:42,559
we're going to get the privilege

856
00:33:42,559 --> 00:33:44,399
um and then we have to do some extra

857
00:33:44,399 --> 00:33:45,919
tricks to get that valve again by

858
00:33:45,919 --> 00:33:47,600
default square

859
00:33:47,600 --> 00:33:48,640
so

860
00:33:48,640 --> 00:33:50,480
just unpacking that why could this

861
00:33:50,480 --> 00:33:51,679
happen at all

862
00:33:51,679 --> 00:33:53,360
so we're really going to be working with

863
00:33:53,360 --> 00:33:55,360
peterson the generation of

864
00:33:55,360 --> 00:33:58,640
generalization afghan commands so here

865
00:33:58,640 --> 00:33:59,919
uh groups are going to be written

866
00:33:59,919 --> 00:34:01,200
additively

867
00:34:01,200 --> 00:34:02,720
uh if you want to commit some vector v

868
00:34:02,720 --> 00:34:04,559
with some blind r you have some

869
00:34:04,559 --> 00:34:06,159
generators gamma and you take some sort

870
00:34:06,159 --> 00:34:08,079
of inner product here which could just

871
00:34:08,079 --> 00:34:09,520
be uh

872
00:34:09,520 --> 00:34:12,560
scalars multiplied by group elements

873
00:34:12,560 --> 00:34:14,239
or this could be some

874
00:34:14,239 --> 00:34:16,560
vector of elements in g1

875
00:34:16,560 --> 00:34:18,560
uh and the generators being g table vice

876
00:34:18,560 --> 00:34:21,760
versa uh this is not quite the afghan

877
00:34:21,760 --> 00:34:24,320
definition but it's it's poisonous

878
00:34:24,320 --> 00:34:25,199
um

879
00:34:25,199 --> 00:34:26,320
the key thing about these is they're

880
00:34:26,320 --> 00:34:27,760
structure preserving so you can do

881
00:34:27,760 --> 00:34:29,359
ethylene operations

882
00:34:29,359 --> 00:34:31,679
um and one particularly nice thing for

883
00:34:31,679 --> 00:34:33,440
afghan in particular is there's a

884
00:34:33,440 --> 00:34:35,199
symmetry between messages that you're

885
00:34:35,199 --> 00:34:36,960
committing like these vectors in g1 and

886
00:34:36,960 --> 00:34:39,040
the generators right which are another

887
00:34:39,040 --> 00:34:41,679
vector in two so can swap those over

888
00:34:41,679 --> 00:34:42,480
um

889
00:34:42,480 --> 00:34:45,359
and what that basically means is that uh

890
00:34:45,359 --> 00:34:47,520
yeah we're going to be able to recurse

891
00:34:47,520 --> 00:34:48,960
so just sketching what goes on in

892
00:34:48,960 --> 00:34:50,719
bulletproofs um the key point is you've

893
00:34:50,719 --> 00:34:53,199
got some inner product um and you can

894
00:34:53,199 --> 00:34:54,960
break uh an inner product between two

895
00:34:54,960 --> 00:34:57,520
large vectors into a bunch of smaller

896
00:34:57,520 --> 00:34:58,800
inner products and combine them with

897
00:34:58,800 --> 00:35:00,640
some verifier challenges

898
00:35:00,640 --> 00:35:02,720
um and you know if you actually go and

899
00:35:02,720 --> 00:35:04,720
look at the arguments of what you'll end

900
00:35:04,720 --> 00:35:06,000
up with there's some sort of commitment

901
00:35:06,000 --> 00:35:08,480
to a inappropriate use of commitment to

902
00:35:08,480 --> 00:35:10,720
individual vectors uh you use this kind

903
00:35:10,720 --> 00:35:12,480
of folding recursively and you end up

904
00:35:12,480 --> 00:35:15,280
with some very structured effects

905
00:35:15,280 --> 00:35:17,760
built up as a tensor product um and

906
00:35:17,760 --> 00:35:19,280
there's some eventual claim about some

907
00:35:19,280 --> 00:35:21,359
scalars c1 prime v2

908
00:35:21,359 --> 00:35:23,520
um such as this is what's called

909
00:35:23,520 --> 00:35:25,599
traditionally the verifier then has to

910
00:35:25,599 --> 00:35:27,839
go and compute something like these x

911
00:35:27,839 --> 00:35:30,160
plus minus uh inner

912
00:35:30,160 --> 00:35:31,359
and that's where the linear verifier

913
00:35:31,359 --> 00:35:32,640
comes from

914
00:35:32,640 --> 00:35:35,040
um so how might we try and upload that

915
00:35:35,040 --> 00:35:38,240
uh so again the key point is that these

916
00:35:38,240 --> 00:35:41,040
x vectors uh have tensorflow structure

917
00:35:41,040 --> 00:35:43,760
so um if we split the generators into

918
00:35:43,760 --> 00:35:45,359
the left half and the right half then

919
00:35:45,359 --> 00:35:47,359
you can actually rewrite this thing as

920
00:35:47,359 --> 00:35:49,359
some shorter inner program

921
00:35:49,359 --> 00:35:51,119
um and

922
00:35:51,119 --> 00:35:52,560
you know this is what we're going to do

923
00:35:52,560 --> 00:35:53,920
in the

924
00:35:53,920 --> 00:35:55,520
setup stage is the verifier's going to

925
00:35:55,520 --> 00:35:58,079
pre-computed some commitments to those

926
00:35:58,079 --> 00:36:00,079
generators so it knows what gamma 1 l

927
00:36:00,079 --> 00:36:02,640
and m 1 are in some sort of abstract way

928
00:36:02,640 --> 00:36:04,480
under the commitment and it can combine

929
00:36:04,480 --> 00:36:05,359
them

930
00:36:05,359 --> 00:36:08,480
um now this is a little tricky to do by

931
00:36:08,480 --> 00:36:09,760
default you would expect that you still

932
00:36:09,760 --> 00:36:11,760
have this x plus prime which is still

933
00:36:11,760 --> 00:36:13,359
linearly long so how we're getting

934
00:36:13,359 --> 00:36:15,440
saving um and it turns out that this is

935
00:36:15,440 --> 00:36:16,800
okay because

936
00:36:16,800 --> 00:36:17,599
um

937
00:36:17,599 --> 00:36:19,920
essentially it's got a tensorflow still

938
00:36:19,920 --> 00:36:22,240
um and at the end at the end of the

939
00:36:22,240 --> 00:36:23,280
protocol you're going to have to take

940
00:36:23,280 --> 00:36:24,960
some inner products with another vector

941
00:36:24,960 --> 00:36:26,800
with tensor product structure that turns

942
00:36:26,800 --> 00:36:28,160
out to go nicely

943
00:36:28,160 --> 00:36:31,680
um and you can request this g1 and g2

944
00:36:31,680 --> 00:36:33,680
um you then have to do some you know

945
00:36:33,680 --> 00:36:35,920
irritating boring details in order to

946
00:36:35,920 --> 00:36:37,280
actually make this work for polynomial

947
00:36:37,280 --> 00:36:38,880
commitment not just a

948
00:36:38,880 --> 00:36:40,480
bulletproof type of argument

949
00:36:40,480 --> 00:36:42,880
um so we have to add some public scalars

950
00:36:42,880 --> 00:36:44,960
and again you could get a linear verify

951
00:36:44,960 --> 00:36:46,160
time here but we don't for the

952
00:36:46,160 --> 00:36:47,520
polynomial

953
00:36:47,520 --> 00:36:48,320
um

954
00:36:48,320 --> 00:36:50,560
and then you know much as in prior words

955
00:36:50,560 --> 00:36:51,599
we build a

956
00:36:51,599 --> 00:36:55,160
polynomial commandments

957
00:36:59,200 --> 00:37:01,440
um so practically what does this mean

958
00:37:01,440 --> 00:37:03,599
well so here we're comparing with uh

959
00:37:03,599 --> 00:37:06,400
spartan which is a hyrax like

960
00:37:06,400 --> 00:37:08,320
uh polynomial commitment

961
00:37:08,320 --> 00:37:10,960
um and i mean the key point here is you

962
00:37:10,960 --> 00:37:12,960
know you lose a small factor approver

963
00:37:12,960 --> 00:37:15,280
but a small constant factor uh but your

964
00:37:15,280 --> 00:37:17,200
commitment sizes are very small um your

965
00:37:17,200 --> 00:37:20,400
evaluation again is worse time constant

966
00:37:20,400 --> 00:37:23,920
but the evaluation of the proofs uh goes

967
00:37:23,920 --> 00:37:25,440
logarithmically rather than square root

968
00:37:25,440 --> 00:37:27,680
so practically this works quite well for

969
00:37:27,680 --> 00:37:29,200
the polymer will degrees above like two

970
00:37:29,200 --> 00:37:31,599
to twenty two to twenty and then in

971
00:37:31,599 --> 00:37:33,280
practice you often see two to twenty two

972
00:37:33,280 --> 00:37:36,720
to the thirteen showing up here so

973
00:37:44,640 --> 00:37:45,920
assumptions you could do things like

974
00:37:45,920 --> 00:37:48,720
graph where proof verification is maybe

975
00:37:48,720 --> 00:37:50,879
one

976
00:37:58,800 --> 00:38:02,040
thank you

977
00:38:16,000 --> 00:38:21,000
i guess to the next presentation

978
00:38:40,160 --> 00:38:43,160
uh

979
00:38:47,250 --> 00:38:50,489
[Music]

980
00:38:54,560 --> 00:38:57,920
we have a question in the chat uh

981
00:38:57,920 --> 00:38:59,599
that we did not notice we'll return to

982
00:38:59,599 --> 00:39:02,000
that at the end of the session

983
00:39:02,000 --> 00:39:03,359
um

984
00:39:03,359 --> 00:39:06,320
the next uh talk is about multi-party

985
00:39:06,320 --> 00:39:08,640
psn revisited

986
00:39:08,640 --> 00:39:10,640
improved communication and unbalanced

987
00:39:10,640 --> 00:39:13,760
communication by learning the

988
00:39:13,760 --> 00:39:17,520
can renew and leonard will give

989
00:39:17,520 --> 00:39:20,000
a talk

990
00:39:20,000 --> 00:39:23,359
could you find the presentation

991
00:39:25,200 --> 00:39:26,079
can you

992
00:39:26,079 --> 00:39:28,000
can you confirm that you're seeing the

993
00:39:28,000 --> 00:39:31,920
right time yes we are

994
00:39:39,440 --> 00:39:41,520
thank you for the introduction

995
00:39:41,520 --> 00:39:43,599
i'm going to talk about multi-party psm

996
00:39:43,599 --> 00:39:45,280
representative improved communication

997
00:39:45,280 --> 00:39:47,520
and balanced communication this is joint

998
00:39:47,520 --> 00:39:50,880
work with tian renu

999
00:39:54,480 --> 00:39:55,599
so

1000
00:39:55,599 --> 00:39:58,160
in private simultaneous messages

1001
00:39:58,160 --> 00:39:59,359
we have

1002
00:39:59,359 --> 00:40:00,880
parties so i'm going to start by

1003
00:40:00,880 --> 00:40:02,560
explaining in the two-party case where

1004
00:40:02,560 --> 00:40:05,440
alice and bob each have inputs

1005
00:40:05,440 --> 00:40:08,160
and we have a referee which is another

1006
00:40:08,160 --> 00:40:09,280
party

1007
00:40:09,280 --> 00:40:10,560
and the referee

1008
00:40:10,560 --> 00:40:13,200
wants to learn the function f of x1 and

1009
00:40:13,200 --> 00:40:14,160
x2

1010
00:40:14,160 --> 00:40:17,119
and f is some public functionality

1011
00:40:17,119 --> 00:40:19,280
to do that alice and bob are going to

1012
00:40:19,280 --> 00:40:21,839
send messages non-interactively so one

1013
00:40:21,839 --> 00:40:24,880
round to the referee

1014
00:40:24,880 --> 00:40:27,200
and we have the correctness condition

1015
00:40:27,200 --> 00:40:30,160
when the referee learns that function

1016
00:40:30,160 --> 00:40:32,160
and it is secure if

1017
00:40:32,160 --> 00:40:33,920
the unbounded referee learns nothing

1018
00:40:33,920 --> 00:40:35,760
else so we are

1019
00:40:35,760 --> 00:40:37,599
concerned about information politics

1020
00:40:37,599 --> 00:40:39,839
security

1021
00:40:40,079 --> 00:40:41,839
and alice and bob are going to share

1022
00:40:41,839 --> 00:40:43,839
some random bits

1023
00:40:43,839 --> 00:40:47,760
that the referee does not have access to

1024
00:40:47,760 --> 00:40:49,440
the important measure here is the

1025
00:40:49,440 --> 00:40:51,440
communication complexity so that is how

1026
00:40:51,440 --> 00:40:54,800
many bits alice and bob send and we can

1027
00:40:54,800 --> 00:40:56,880
generalize this setting to the

1028
00:40:56,880 --> 00:41:01,119
multi-party case with key parties

1029
00:41:01,520 --> 00:41:02,480
so

1030
00:41:02,480 --> 00:41:05,839
the the relevant previous works for our

1031
00:41:05,839 --> 00:41:07,520
paper are

1032
00:41:07,520 --> 00:41:09,839
so first this uh

1033
00:41:09,839 --> 00:41:11,680
concept was introduced by fedele kilian

1034
00:41:11,680 --> 00:41:13,359
and nar

1035
00:41:13,359 --> 00:41:17,760
and they show a first non-trivial psm

1036
00:41:17,760 --> 00:41:18,720
and

1037
00:41:18,720 --> 00:41:21,839
then this result has been improved by uh

1038
00:41:21,839 --> 00:41:25,040
by male kushilevit and nissim

1039
00:41:25,040 --> 00:41:27,040
uh in

1040
00:41:27,040 --> 00:41:28,000
with

1041
00:41:28,000 --> 00:41:29,680
the square root of the total input space

1042
00:41:29,680 --> 00:41:31,280
size

1043
00:41:31,280 --> 00:41:33,280
and for small k

1044
00:41:33,280 --> 00:41:35,920
there has been some other results

1045
00:41:35,920 --> 00:41:39,760
with the nice complexities in this work

1046
00:41:39,760 --> 00:41:42,079
we improve the complexity for infinitely

1047
00:41:42,079 --> 00:41:44,480
many k

1048
00:41:44,480 --> 00:41:45,839
of

1049
00:41:45,839 --> 00:41:49,359
n to the power of k minus one over two

1050
00:41:49,359 --> 00:41:50,400
uh

1051
00:41:50,400 --> 00:41:52,560
we prove this for so infinitely many k

1052
00:41:52,560 --> 00:41:54,319
and uh all k

1053
00:41:54,319 --> 00:41:56,640
less than twenty

1054
00:41:56,640 --> 00:41:58,400
we also have new results on two party

1055
00:41:58,400 --> 00:41:59,760
psm

1056
00:41:59,760 --> 00:42:02,560
uh the best known about bsm

1057
00:42:02,560 --> 00:42:04,160
is from b i k k

1058
00:42:04,160 --> 00:42:07,280
where is square root of n the complexity

1059
00:42:07,280 --> 00:42:10,640
in fkn they chose our first uh

1060
00:42:10,640 --> 00:42:13,040
trivial one but also it's possible to

1061
00:42:13,040 --> 00:42:15,040
have one parties and n bits and another

1062
00:42:15,040 --> 00:42:17,680
ones and log n bits and here we have

1063
00:42:17,680 --> 00:42:19,359
what we call unbalanced

1064
00:42:19,359 --> 00:42:22,560
psm where one part is going to send

1065
00:42:22,560 --> 00:42:24,319
uh something of size eta and another the

1066
00:42:24,319 --> 00:42:27,359
one of size one minus eta

1067
00:42:27,359 --> 00:42:30,079
uh we prove this for

1068
00:42:30,079 --> 00:42:33,200
many rational etas

1069
00:42:33,200 --> 00:42:36,240
so let's look at our technique now

1070
00:42:36,240 --> 00:42:37,040
we

1071
00:42:37,040 --> 00:42:40,640
consider f to be its truth table and the

1072
00:42:40,640 --> 00:42:42,319
vectors are going to be represented by

1073
00:42:42,319 --> 00:42:44,720
the index vectors

1074
00:42:44,720 --> 00:42:46,079
and we're interested in learning the

1075
00:42:46,079 --> 00:42:48,400
inner product of

1076
00:42:48,400 --> 00:42:51,040
the the truth table of f

1077
00:42:51,040 --> 00:42:54,560
and the tensoring of all of the inputs

1078
00:42:54,560 --> 00:42:57,359
so if f is represented as

1079
00:42:57,359 --> 00:42:59,520
this matrix we can represent the

1080
00:42:59,520 --> 00:43:00,960
transferring of

1081
00:43:00,960 --> 00:43:02,160
two inputs

1082
00:43:02,160 --> 00:43:03,520
as

1083
00:43:03,520 --> 00:43:05,359
this matrix and

1084
00:43:05,359 --> 00:43:07,760
the this gives the the index of the

1085
00:43:07,760 --> 00:43:09,280
correct output

1086
00:43:09,280 --> 00:43:13,119
in the truth table of the function

1087
00:43:13,119 --> 00:43:14,800
with this representation

1088
00:43:14,800 --> 00:43:18,560
we can first show a naive to party psn

1089
00:43:18,560 --> 00:43:21,440
so alice and bob have their input x1 and

1090
00:43:21,440 --> 00:43:23,839
x2

1091
00:43:23,839 --> 00:43:25,040
of

1092
00:43:25,040 --> 00:43:28,240
n bits and they are going to share some

1093
00:43:28,240 --> 00:43:31,680
random values r1 and r2

1094
00:43:31,680 --> 00:43:33,920
uh they are going to mask their inputs

1095
00:43:33,920 --> 00:43:35,520
with those random values and send them

1096
00:43:35,520 --> 00:43:37,200
to the referee

1097
00:43:37,200 --> 00:43:39,359
the referee needs to learn f of x1 and

1098
00:43:39,359 --> 00:43:40,480
x2

1099
00:43:40,480 --> 00:43:44,240
so with what the referee just got

1100
00:43:44,240 --> 00:43:47,520
this is the equation that is written uh

1101
00:43:47,520 --> 00:43:50,800
here and so the green values

1102
00:43:50,800 --> 00:43:54,960
alice and bob need to send them to so

1103
00:43:54,960 --> 00:43:57,440
since r1 and r2 are shared alice and bob

1104
00:43:57,440 --> 00:44:00,079
can actually just send those values and

1105
00:44:00,079 --> 00:44:03,119
we one timepad them with uh some bit s

1106
00:44:03,119 --> 00:44:04,960
that is also shared

1107
00:44:04,960 --> 00:44:07,359
this is the communication complexity of

1108
00:44:07,359 --> 00:44:09,839
big o of n this is not the best

1109
00:44:09,839 --> 00:44:11,760
possible but it's a first introduction

1110
00:44:11,760 --> 00:44:13,280
to psm

1111
00:44:13,280 --> 00:44:17,040
now in our method we have k parties

1112
00:44:17,040 --> 00:44:20,240
and instead of having each party send

1113
00:44:20,240 --> 00:44:21,760
an input

1114
00:44:21,760 --> 00:44:23,040
themselves

1115
00:44:23,040 --> 00:44:24,880
they are going to actually be

1116
00:44:24,880 --> 00:44:27,040
we are going to combine many subset of

1117
00:44:27,040 --> 00:44:28,240
parties

1118
00:44:28,240 --> 00:44:31,440
uh and so these subsets are going to

1119
00:44:31,440 --> 00:44:33,520
act as big parties that are going to

1120
00:44:33,520 --> 00:44:36,319
send some inputs

1121
00:44:36,319 --> 00:44:38,079
of course without interacting with each

1122
00:44:38,079 --> 00:44:39,119
other

1123
00:44:39,119 --> 00:44:40,720
but this is explained in further detail

1124
00:44:40,720 --> 00:44:42,960
in the paper

1125
00:44:42,960 --> 00:44:45,520
and to learn the correct value the

1126
00:44:45,520 --> 00:44:46,800
referee

1127
00:44:46,800 --> 00:44:49,280
will compute so f of all the messages

1128
00:44:49,280 --> 00:44:51,359
this is the target term what we want the

1129
00:44:51,359 --> 00:44:53,280
referee to learn then we have some easy

1130
00:44:53,280 --> 00:44:56,400
terms those are referee computable uh

1131
00:44:56,400 --> 00:44:58,160
that is

1132
00:44:58,160 --> 00:45:01,200
we can have the parties send information

1133
00:45:01,200 --> 00:45:03,119
for the referee to compute them but then

1134
00:45:03,119 --> 00:45:05,040
we have what we call hard terms

1135
00:45:05,040 --> 00:45:07,760
and this it would require uh too high of

1136
00:45:07,760 --> 00:45:09,839
a communication complexity

1137
00:45:09,839 --> 00:45:11,839
so the technique is to cancel those hard

1138
00:45:11,839 --> 00:45:13,839
terms we can do it two ways the first

1139
00:45:13,839 --> 00:45:15,520
one is by doing

1140
00:45:15,520 --> 00:45:17,760
uh elimination

1141
00:45:17,760 --> 00:45:20,480
so gaussian elimination with a

1142
00:45:20,480 --> 00:45:21,599
well-chosen

1143
00:45:21,599 --> 00:45:24,000
subset of parties but we don't have a

1144
00:45:24,000 --> 00:45:26,240
generic method for that so we have to

1145
00:45:26,240 --> 00:45:29,040
verify it experimentally but we have a

1146
00:45:29,040 --> 00:45:32,240
generic method for something uh more

1147
00:45:32,240 --> 00:45:33,920
subtle where if we perform the

1148
00:45:33,920 --> 00:45:35,680
computation in a well-chosen finite

1149
00:45:35,680 --> 00:45:38,240
field the hard terms are going to

1150
00:45:38,240 --> 00:45:41,280
evaluate to zero modulo uh

1151
00:45:41,280 --> 00:45:44,640
k plus one when k plus one is a prime

1152
00:45:44,640 --> 00:45:47,520
power

1153
00:45:47,520 --> 00:45:49,839
so to summarize our contribution we have

1154
00:45:49,839 --> 00:45:51,920
a new framework for k-p-r-t psn where

1155
00:45:51,920 --> 00:45:53,760
the previous upper bound hall

1156
00:45:53,760 --> 00:45:55,599
we have a new technique that yields a

1157
00:45:55,599 --> 00:45:57,280
better communication complexity for

1158
00:45:57,280 --> 00:45:58,720
infinitely many k

1159
00:45:58,720 --> 00:46:01,040
and for balance to cardi psn

1160
00:46:01,040 --> 00:46:03,440
uh we have new results for example we

1161
00:46:03,440 --> 00:46:05,440
can have alice send n to the one third

1162
00:46:05,440 --> 00:46:09,520
bits and bobs and end to the two thirds

1163
00:46:09,520 --> 00:46:11,440
there are still remains of any question

1164
00:46:11,440 --> 00:46:14,160
so the first two ones are can we expand

1165
00:46:14,160 --> 00:46:16,880
and generalize our result so our new

1166
00:46:16,880 --> 00:46:19,359
complexity for okay

1167
00:46:19,359 --> 00:46:21,280
and on your imbalance complex on your

1168
00:46:21,280 --> 00:46:23,680
imbalance psm for all eta

1169
00:46:23,680 --> 00:46:26,319
and then the moonshot is to find

1170
00:46:26,319 --> 00:46:28,000
a better communication complexity all in

1171
00:46:28,000 --> 00:46:29,839
all because we are still far away from

1172
00:46:29,839 --> 00:46:31,680
the theoretical best

1173
00:46:31,680 --> 00:46:34,640
which is in the bigger vlog

1174
00:46:34,640 --> 00:46:36,160
thank you

1175
00:46:36,160 --> 00:46:39,250
[Applause]

1176
00:46:53,200 --> 00:46:54,630
thank you again

1177
00:46:54,630 --> 00:46:57,889
[Music]

1178
00:47:06,240 --> 00:47:10,079
blockchains enable non-interactive npc

1179
00:47:10,079 --> 00:47:12,800
by victor goyal

1180
00:47:12,800 --> 00:47:16,640
elizabetha massolva brian panno and ifan

1181
00:47:16,640 --> 00:47:19,119
song and elizabeta

1182
00:47:19,119 --> 00:47:23,000
will give the presentation

1183
00:47:28,800 --> 00:47:30,180
if it works

1184
00:47:30,180 --> 00:47:33,310
[Music]

1185
00:47:38,800 --> 00:47:43,319
i'll just do this

1186
00:47:44,210 --> 00:47:49,459
[Music]

1187
00:48:01,920 --> 00:48:03,760
okay um thank you for the introduction

1188
00:48:03,760 --> 00:48:06,800
uh hi everyone i'm lisa and to start

1189
00:48:06,800 --> 00:48:09,200
things off

1190
00:48:09,680 --> 00:48:12,160
let us briefly recall what npc is it

1191
00:48:12,160 --> 00:48:13,359
stands for secure multipatter

1192
00:48:13,359 --> 00:48:14,960
computation and allows mutually

1193
00:48:14,960 --> 00:48:16,800
distrusting parties to perform

1194
00:48:16,800 --> 00:48:19,200
computations on their private inputs

1195
00:48:19,200 --> 00:48:20,960
while ensuring that nothing besides the

1196
00:48:20,960 --> 00:48:24,480
output of the computation is

1197
00:48:25,599 --> 00:48:27,599
since introduction in the 80s there has

1198
00:48:27,599 --> 00:48:29,920
been a lot of research on mpc and now we

1199
00:48:29,920 --> 00:48:32,000
know that four rounds are both necessary

1200
00:48:32,000 --> 00:48:34,480
and sufficient for mpc in the fully

1201
00:48:34,480 --> 00:48:38,000
malicious case in the plain model

1202
00:48:38,559 --> 00:48:40,079
however ideally we would like to get

1203
00:48:40,079 --> 00:48:41,760
something better than four outs possibly

1204
00:48:41,760 --> 00:48:43,440
by changing the model i will now

1205
00:48:43,440 --> 00:48:46,319
introduce you to ours

1206
00:48:46,319 --> 00:48:49,359
first we assume public bulletin boards

1207
00:48:49,359 --> 00:48:51,200
and we require an unportable proof of

1208
00:48:51,200 --> 00:48:52,480
publication

1209
00:48:52,480 --> 00:48:54,480
as multiple priorities noted site button

1210
00:48:54,480 --> 00:48:56,480
boards exist in real life but the most

1211
00:48:56,480 --> 00:49:00,240
notable example being the blockchains

1212
00:49:00,800 --> 00:49:02,319
next we assume something which we call

1213
00:49:02,319 --> 00:49:04,319
conditional storage and retrieval

1214
00:49:04,319 --> 00:49:06,640
systems csars

1215
00:49:06,640 --> 00:49:10,480
intuitively accir allows a

1216
00:49:10,480 --> 00:49:12,559
party to store a secret along with a

1217
00:49:12,559 --> 00:49:14,079
release condition

1218
00:49:14,079 --> 00:49:16,079
then if some other party um shows that

1219
00:49:16,079 --> 00:49:18,079
it can satisfy this release condition

1220
00:49:18,079 --> 00:49:20,160
the secret is privately released to that

1221
00:49:20,160 --> 00:49:22,079
party

1222
00:49:22,079 --> 00:49:25,119
note that um as um in the recent um

1223
00:49:25,119 --> 00:49:27,440
years there have been multiple proposals

1224
00:49:27,440 --> 00:49:28,960
for similar functionalities and they

1225
00:49:28,960 --> 00:49:30,640
typically have been based on blockchains

1226
00:49:30,640 --> 00:49:32,960
as well

1227
00:49:33,520 --> 00:49:35,520
finally in our work there are two kinds

1228
00:49:35,520 --> 00:49:36,559
of

1229
00:49:36,559 --> 00:49:38,079
participants um

1230
00:49:38,079 --> 00:49:40,079
we have npc contributors literally

1231
00:49:40,079 --> 00:49:42,400
parties who supply inputs and we have

1232
00:49:42,400 --> 00:49:44,559
evaluators literally parties who wish to

1233
00:49:44,559 --> 00:49:47,280
receive the output

1234
00:49:47,920 --> 00:49:50,319
in this model our goal is to provide an

1235
00:49:50,319 --> 00:49:52,319
mpc protocol which does not require

1236
00:49:52,319 --> 00:49:54,720
interaction between the participants and

1237
00:49:54,720 --> 00:49:56,800
requires only a single round of

1238
00:49:56,800 --> 00:50:01,440
participation from the npc contributors

1239
00:50:02,240 --> 00:50:04,319
more formally given an uh possibly

1240
00:50:04,319 --> 00:50:06,160
interactive mbc protocol file which is

1241
00:50:06,160 --> 00:50:07,359
secure against fully malicious

1242
00:50:07,359 --> 00:50:09,520
adversaries we can transform it into

1243
00:50:09,520 --> 00:50:12,000
another protocol pi prime which is also

1244
00:50:12,000 --> 00:50:13,359
secure against fully religious

1245
00:50:13,359 --> 00:50:15,520
adversaries and now in the blockchain

1246
00:50:15,520 --> 00:50:17,839
model which does not require interaction

1247
00:50:17,839 --> 00:50:19,680
between the participants

1248
00:50:19,680 --> 00:50:21,040
the contributors are required to

1249
00:50:21,040 --> 00:50:23,920
participate for only a single round

1250
00:50:23,920 --> 00:50:25,920
the evaluators might need to participate

1251
00:50:25,920 --> 00:50:28,079
for multiple routes

1252
00:50:28,079 --> 00:50:29,920
the adversary is allowed to corrupt as

1253
00:50:29,920 --> 00:50:31,359
many mpc

1254
00:50:31,359 --> 00:50:33,440
contributors in my prime as it can

1255
00:50:33,440 --> 00:50:35,520
corrupt npc participants in the original

1256
00:50:35,520 --> 00:50:37,440
protocol pack

1257
00:50:37,440 --> 00:50:39,280
the adversary is also allowed to corrupt

1258
00:50:39,280 --> 00:50:42,319
all of the evaluators

1259
00:50:43,920 --> 00:50:45,920
how do we do it well the main idea is

1260
00:50:45,920 --> 00:50:47,680
the following the contributors start by

1261
00:50:47,680 --> 00:50:50,240
coupling the next message function for

1262
00:50:50,240 --> 00:50:52,400
each round of pipe while hardcoding

1263
00:50:52,400 --> 00:50:54,319
their private inputs then the

1264
00:50:54,319 --> 00:50:56,079
contributors store the covered circuits

1265
00:50:56,079 --> 00:50:59,760
and fire keys with csiro

1266
00:50:59,920 --> 00:51:01,680
the evaluators can then retrieve the

1267
00:51:01,680 --> 00:51:03,760
circuits and via keys from the csir and

1268
00:51:03,760 --> 00:51:07,880
just executive output circuits

1269
00:51:08,319 --> 00:51:10,480
while this um high level overview is

1270
00:51:10,480 --> 00:51:12,079
pretty simple the

1271
00:51:12,079 --> 00:51:13,760
actual transfection is a little bit more

1272
00:51:13,760 --> 00:51:16,720
tricky due to the non-attractive setting

1273
00:51:16,720 --> 00:51:18,640
for example um the coupled circuits are

1274
00:51:18,640 --> 00:51:21,520
secure only if at most a single variety

1275
00:51:21,520 --> 00:51:24,000
is revealed for each wire

1276
00:51:24,000 --> 00:51:25,920
however the issue is that at the time

1277
00:51:25,920 --> 00:51:29,119
departure so those um y keys with csr

1278
00:51:29,119 --> 00:51:30,720
the inputs of other parties are not

1279
00:51:30,720 --> 00:51:32,319
known so there is no way to predict

1280
00:51:32,319 --> 00:51:33,680
which variation will be needed during

1281
00:51:33,680 --> 00:51:35,680
the computation

1282
00:51:35,680 --> 00:51:37,200
and so effectively we need to store both

1283
00:51:37,200 --> 00:51:38,720
the key for zero and the key for one for

1284
00:51:38,720 --> 00:51:41,118
each y

1285
00:51:41,920 --> 00:51:44,079
the idea that we had here was the

1286
00:51:44,079 --> 00:51:45,040
following

1287
00:51:45,040 --> 00:51:47,920
first um the parties store the y keys

1288
00:51:47,920 --> 00:51:50,160
for zero and one in two separate csir

1289
00:51:50,160 --> 00:51:52,160
requests

1290
00:51:52,160 --> 00:51:54,480
and then the evaluator sort of needs to

1291
00:51:54,480 --> 00:51:57,040
commit to the course of execution what i

1292
00:51:57,040 --> 00:51:58,960
mean by that is the home

1293
00:51:58,960 --> 00:52:01,200
the evaluator executes the gallbladder

1294
00:52:01,200 --> 00:52:03,760
circuits of a certain branch and then

1295
00:52:03,760 --> 00:52:05,920
publishes the outputs of those cable

1296
00:52:05,920 --> 00:52:09,119
circuits on developing board

1297
00:52:09,119 --> 00:52:11,520
the csir release condition for bit b on

1298
00:52:11,520 --> 00:52:14,319
via x for around five plus one

1299
00:52:14,319 --> 00:52:16,160
requires then that there is a proof of

1300
00:52:16,160 --> 00:52:17,440
publish of

1301
00:52:17,440 --> 00:52:19,599
evaluator's commitment mi

1302
00:52:19,599 --> 00:52:22,800
such that mi has exactly the b on

1303
00:52:22,800 --> 00:52:24,400
position x

1304
00:52:24,400 --> 00:52:26,319
this ensures that we are revealing only

1305
00:52:26,319 --> 00:52:27,760
those fire keys that are actually needed

1306
00:52:27,760 --> 00:52:30,720
during the execution

1307
00:52:31,359 --> 00:52:33,359
there were a lot of further challenges

1308
00:52:33,359 --> 00:52:35,119
we had to overcome for example we had to

1309
00:52:35,119 --> 00:52:36,880
ensure that the inputs that the

1310
00:52:36,880 --> 00:52:38,559
evaluators feed into the garbage

1311
00:52:38,559 --> 00:52:40,720
circuits are consistent with each other

1312
00:52:40,720 --> 00:52:43,040
and that the evaluators cannot sort of

1313
00:52:43,040 --> 00:52:45,440
reorder the uh double circuits for the

1314
00:52:45,440 --> 00:52:48,240
different routes

1315
00:52:49,760 --> 00:52:51,760
um to summarize in our main result we

1316
00:52:51,760 --> 00:52:53,440
showed that it is possible to provide

1317
00:52:53,440 --> 00:52:55,200
nbc which does not require interaction

1318
00:52:55,200 --> 00:52:57,280
between the participants and requires

1319
00:52:57,280 --> 00:52:59,680
only one round um

1320
00:52:59,680 --> 00:53:01,839
participation from the c contributors

1321
00:53:01,839 --> 00:53:04,079
this is in the blockchain model

1322
00:53:04,079 --> 00:53:05,680
we additionally have a protocol which

1323
00:53:05,680 --> 00:53:07,920
provides guaranteed output delivery

1324
00:53:07,920 --> 00:53:10,240
and in our final results we were able to

1325
00:53:10,240 --> 00:53:12,000
improve the number of csi alcohols that

1326
00:53:12,000 --> 00:53:14,800
you make in our construction

1327
00:53:14,800 --> 00:53:16,240
this is all i have thank you so much for

1328
00:53:16,240 --> 00:53:18,799
your attention

1329
00:53:24,079 --> 00:53:27,559
do we have questions

1330
00:53:39,150 --> 00:53:42,280
[Music]

1331
00:53:43,839 --> 00:53:46,559
please repeat the question

1332
00:53:46,559 --> 00:53:49,520
um is the protocol reusable

1333
00:53:49,520 --> 00:53:52,720
um so um no the parties would need to do

1334
00:53:52,720 --> 00:53:56,279
that for a new function

1335
00:54:09,599 --> 00:54:13,839
so uh let's thank melissa again

1336
00:54:16,160 --> 00:54:20,079
uh we have a question for chen da

1337
00:54:20,079 --> 00:54:21,520
is it still here

1338
00:54:21,520 --> 00:54:23,119
oh yeah so

1339
00:54:23,119 --> 00:54:24,720
what do you want to read uh your

1340
00:54:24,720 --> 00:54:27,118
question

1341
00:54:27,359 --> 00:54:29,119
uh

1342
00:54:29,119 --> 00:54:32,000
sure thanks uh uh sorry about that uh

1343
00:54:32,000 --> 00:54:34,000
so the the question is for channel but

1344
00:54:34,000 --> 00:54:36,400
just uh you mentioned in your talk that

1345
00:54:36,400 --> 00:54:37,839
your definition

1346
00:54:37,839 --> 00:54:39,680
is an alternative to using erasures and

1347
00:54:39,680 --> 00:54:42,640
non-committee encryption uh so

1348
00:54:42,640 --> 00:54:44,720
does it mean that you really your

1349
00:54:44,720 --> 00:54:46,480
definition obvious the need to raise

1350
00:54:46,480 --> 00:54:49,040
data in the sense that the ratio data

1351
00:54:49,040 --> 00:54:50,960
will not help towards satisfying your

1352
00:54:50,960 --> 00:54:55,119
definition or your misunderstanding

1353
00:54:55,359 --> 00:54:58,319
yeah that's a that's a great question

1354
00:54:58,319 --> 00:55:00,558
um

1355
00:55:00,720 --> 00:55:03,760
i think actually it might still help in

1356
00:55:03,760 --> 00:55:05,599
some contexts

1357
00:55:05,599 --> 00:55:07,760
um

1358
00:55:07,760 --> 00:55:09,440
like like

1359
00:55:09,440 --> 00:55:11,599
like the the concrete definition that we

1360
00:55:11,599 --> 00:55:13,599
give in the paper allows to overcome

1361
00:55:13,599 --> 00:55:15,760
this specific type of commitment problem

1362
00:55:15,760 --> 00:55:17,359
right the one where you

1363
00:55:17,359 --> 00:55:19,280
like that is provoked when you commit to

1364
00:55:19,280 --> 00:55:21,119
your input and then you get corrupted

1365
00:55:21,119 --> 00:55:23,839
right but this doesn't mean that

1366
00:55:23,839 --> 00:55:25,680
this is not the only instance right of

1367
00:55:25,680 --> 00:55:27,119
the commitment problem commitment

1368
00:55:27,119 --> 00:55:30,240
problem can arise in many

1369
00:55:30,240 --> 00:55:32,000
parts of the protocol and i believe that

1370
00:55:32,000 --> 00:55:34,240
the use of erasures can still help in

1371
00:55:34,240 --> 00:55:37,359
satisfying the definition

1372
00:55:37,359 --> 00:55:39,760
i see okay

1373
00:55:39,760 --> 00:55:41,920
i have to get into it more even more

1374
00:55:41,920 --> 00:55:43,920
deeply thank you yeah

1375
00:55:43,920 --> 00:55:45,520
thank you

1376
00:55:45,520 --> 00:55:48,759
thank you

1377
00:55:51,599 --> 00:55:53,920
thanks for the speakers and we have the

1378
00:55:53,920 --> 00:55:57,559
coffee break now

