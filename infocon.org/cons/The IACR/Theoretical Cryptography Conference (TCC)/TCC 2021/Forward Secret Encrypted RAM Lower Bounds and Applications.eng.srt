1
00:00:05,200 --> 00:00:08,800
hello everyone uh i'm alex beanstalk and

2
00:00:08,800 --> 00:00:11,519
i'll be presenting our work uh forward

3
00:00:11,519 --> 00:00:14,240
secret and encrypted ram lower bounds

4
00:00:14,240 --> 00:00:16,640
and applications and this is a joint

5
00:00:16,640 --> 00:00:20,640
work with the evgenia dodis and kevin yo

6
00:00:21,520 --> 00:00:24,400
okay so uh what is forward secret

7
00:00:24,400 --> 00:00:27,840
encrypted ram or fse-ram as we call it

8
00:00:27,840 --> 00:00:31,279
uh well it was a extensively studied for

9
00:00:31,279 --> 00:00:32,719
a long time

10
00:00:32,719 --> 00:00:35,440
and the goal was to privately and

11
00:00:35,440 --> 00:00:37,920
forward secretly outsource the storage

12
00:00:37,920 --> 00:00:40,719
of a large data array using small client

13
00:00:40,719 --> 00:00:42,719
storage

14
00:00:42,719 --> 00:00:45,760
okay uh and the adversarial model is

15
00:00:45,760 --> 00:00:48,239
that uh the adversary always sees the

16
00:00:48,239 --> 00:00:49,840
server storage

17
00:00:49,840 --> 00:00:53,280
uh and also we want forward secrecy

18
00:00:53,280 --> 00:00:56,559
uh meaning that the adversary can leak

19
00:00:56,559 --> 00:01:00,000
the client storage and in this case

20
00:01:00,000 --> 00:01:01,920
of course everything that is currently

21
00:01:01,920 --> 00:01:03,120
stored

22
00:01:03,120 --> 00:01:04,080
uh

23
00:01:04,080 --> 00:01:07,200
in the ram is uh no longer secure

24
00:01:07,200 --> 00:01:09,520
but we want everything that has since

25
00:01:09,520 --> 00:01:12,400
been deleted or overwritten

26
00:01:12,400 --> 00:01:15,200
to be secure

27
00:01:15,280 --> 00:01:18,159
okay and we also want efficient reads

28
00:01:18,159 --> 00:01:20,720
and writes and for this

29
00:01:20,720 --> 00:01:22,799
work we'll assume a static number of

30
00:01:22,799 --> 00:01:25,280
entries n

31
00:01:25,280 --> 00:01:28,560
okay and of course uh we want to use

32
00:01:28,560 --> 00:01:29,759
practical

33
00:01:29,759 --> 00:01:30,799
uh

34
00:01:30,799 --> 00:01:34,880
uh namely symmetric crypto

35
00:01:35,040 --> 00:01:37,680
okay so what's the trivial solution

36
00:01:37,680 --> 00:01:40,479
well let's say we have these eight

37
00:01:40,479 --> 00:01:43,360
data items making up our data array

38
00:01:43,360 --> 00:01:45,280
what we'll do is we'll just encrypt

39
00:01:45,280 --> 00:01:48,479
every entry with a single key

40
00:01:48,479 --> 00:01:51,520
okay so we have this key k

41
00:01:51,520 --> 00:01:54,240
in our local client storage and on the

42
00:01:54,240 --> 00:01:55,840
server we have

43
00:01:55,840 --> 00:01:57,680
the encryption of each data item under

44
00:01:57,680 --> 00:02:00,320
this key k

45
00:02:00,479 --> 00:02:02,159
okay but

46
00:02:02,159 --> 00:02:03,840
for security then

47
00:02:03,840 --> 00:02:06,560
we need to refresh the key after each

48
00:02:06,560 --> 00:02:09,119
write

49
00:02:09,119 --> 00:02:10,878
okay but of course then this is

50
00:02:10,878 --> 00:02:12,400
inefficient

51
00:02:12,400 --> 00:02:14,080
because we will need to re-encrypt

52
00:02:14,080 --> 00:02:16,640
everything

53
00:02:17,760 --> 00:02:19,440
okay so

54
00:02:19,440 --> 00:02:22,000
there is also a folklore solution that's

55
00:02:22,000 --> 00:02:23,840
a tree-based

56
00:02:23,840 --> 00:02:24,879
scheme

57
00:02:24,879 --> 00:02:27,920
this is how it works

58
00:02:28,239 --> 00:02:30,560
and the client side we again have one

59
00:02:30,560 --> 00:02:33,200
key k-epsilon

60
00:02:33,200 --> 00:02:34,879
and it

61
00:02:34,879 --> 00:02:38,480
it uh it's the root of this tree and it

62
00:02:38,480 --> 00:02:41,440
encrypts its two children k zero and k

63
00:02:41,440 --> 00:02:42,319
one

64
00:02:42,319 --> 00:02:44,800
and we store these ciphertexts uh on the

65
00:02:44,800 --> 00:02:46,319
server

66
00:02:46,319 --> 00:02:49,040
then each of k zero and k one encrypt

67
00:02:49,040 --> 00:02:51,519
their children

68
00:02:51,519 --> 00:02:52,480
and

69
00:02:52,480 --> 00:02:53,519
uh

70
00:02:53,519 --> 00:02:55,920
at the end we have the leaves are

71
00:02:55,920 --> 00:02:58,560
encrypt encryptions

72
00:02:58,560 --> 00:03:00,879
of the eight data items under their

73
00:03:00,879 --> 00:03:03,280
parents

74
00:03:03,840 --> 00:03:04,959
okay

75
00:03:04,959 --> 00:03:07,280
so how do we read well let's say we want

76
00:03:07,280 --> 00:03:09,840
to read the fourth theta item

77
00:03:09,840 --> 00:03:13,760
then we take k epsilon

78
00:03:13,760 --> 00:03:16,560
decrypt k zero

79
00:03:16,560 --> 00:03:19,920
then using k0 decrypt k01

80
00:03:19,920 --> 00:03:23,360
and finally decrypt d4

81
00:03:23,360 --> 00:03:26,799
okay so this was a login overhead as you

82
00:03:26,799 --> 00:03:29,680
may have realized

83
00:03:30,239 --> 00:03:33,040
okay how do we write

84
00:03:33,040 --> 00:03:34,480
to a cell

85
00:03:34,480 --> 00:03:36,640
well let's say we want to write to cell

86
00:03:36,640 --> 00:03:40,560
for new data d4 prime

87
00:03:40,560 --> 00:03:42,159
then what we'll do is

88
00:03:42,159 --> 00:03:45,200
in addition to the direct decrypting the

89
00:03:45,200 --> 00:03:47,040
direct path

90
00:03:47,040 --> 00:03:49,840
to the fourth cell like we did for reads

91
00:03:49,840 --> 00:03:52,319
we'll also decrypt the copath

92
00:03:52,319 --> 00:03:55,120
okay so in addition to decrypting k0

93
00:03:55,120 --> 00:03:57,680
we'll also decrypt k1

94
00:03:57,680 --> 00:04:00,480
in addition to decrypting k01 we'll also

95
00:04:00,480 --> 00:04:02,879
decrypt k00

96
00:04:02,879 --> 00:04:05,519
uh and in addition to

97
00:04:05,519 --> 00:04:09,200
uh well we actually won't decrypt d4

98
00:04:09,200 --> 00:04:10,640
we'll just

99
00:04:10,640 --> 00:04:12,560
sort of get rid of it

100
00:04:12,560 --> 00:04:15,599
and decrypt d3

101
00:04:15,599 --> 00:04:20,160
and we're left with uh d3 k1 k0 we'll

102
00:04:20,160 --> 00:04:22,400
just forget about everything else

103
00:04:22,400 --> 00:04:26,160
and we'll re uh generate a new key k01

104
00:04:26,160 --> 00:04:29,360
prime uh for the parent of d3

105
00:04:29,360 --> 00:04:31,120
and also

106
00:04:31,120 --> 00:04:34,560
encrypt d3 and this new data d4 prime

107
00:04:34,560 --> 00:04:36,720
under k01 prime

108
00:04:36,720 --> 00:04:39,840
okay then we'll generate a new key at

109
00:04:39,840 --> 00:04:42,639
the parent of k01 prime

110
00:04:42,639 --> 00:04:44,880
encrypt both of its children

111
00:04:44,880 --> 00:04:46,800
and finally

112
00:04:46,800 --> 00:04:49,520
generate the new k epsilon prime and

113
00:04:49,520 --> 00:04:52,800
encrypt both of its children

114
00:04:52,800 --> 00:04:55,520
okay and so you'll notice now

115
00:04:55,520 --> 00:04:57,680
we have forward secrecy because

116
00:04:57,680 --> 00:05:00,800
all information about d4 is gone now

117
00:05:00,800 --> 00:05:03,919
okay so even if uh

118
00:05:03,919 --> 00:05:08,160
the adversary corrupts k epsilon prime

119
00:05:08,160 --> 00:05:09,039
well

120
00:05:09,039 --> 00:05:12,320
uh k epsilon prime and everything that

121
00:05:12,320 --> 00:05:14,720
we can decrypt with it

122
00:05:14,720 --> 00:05:17,440
is totally independent of d4 or anything

123
00:05:17,440 --> 00:05:22,240
that could have previously decrypted d4

124
00:05:22,840 --> 00:05:24,479
okay

125
00:05:24,479 --> 00:05:26,639
uh so what was the efficiency of this

126
00:05:26,639 --> 00:05:27,919
scheme

127
00:05:27,919 --> 00:05:29,360
well we had

128
00:05:29,360 --> 00:05:31,840
uh big o of one client storage we go

129
00:05:31,840 --> 00:05:32,639
then

130
00:05:32,639 --> 00:05:34,960
uh sorry that should be server storage

131
00:05:34,960 --> 00:05:36,240
uh and

132
00:05:36,240 --> 00:05:39,199
we go of n uh overhead for reads and

133
00:05:39,199 --> 00:05:41,520
writes

134
00:05:42,240 --> 00:05:43,199
okay

135
00:05:43,199 --> 00:05:45,120
but we can also further extend this to

136
00:05:45,120 --> 00:05:48,639
have big o of s client storage uh

137
00:05:48,639 --> 00:05:50,720
you know for some s that's not too big

138
00:05:50,720 --> 00:05:52,720
still sublinear

139
00:05:52,720 --> 00:05:55,759
big o of n server storage again

140
00:05:55,759 --> 00:06:00,639
and big o of log n over s overhead

141
00:06:01,919 --> 00:06:04,800
and this is done by just creating

142
00:06:04,800 --> 00:06:06,479
s different trees

143
00:06:06,479 --> 00:06:09,440
and storing in each tree and over s of

144
00:06:09,440 --> 00:06:12,479
the data items

145
00:06:12,960 --> 00:06:14,800
okay now the main question that we have

146
00:06:14,800 --> 00:06:17,440
in this work is

147
00:06:17,440 --> 00:06:18,840
is this scheme

148
00:06:18,840 --> 00:06:22,240
optimal and maybe surprisingly this has

149
00:06:22,240 --> 00:06:26,240
been unknown for two plus decades

150
00:06:26,240 --> 00:06:29,199
and in fact in our work uh we answer

151
00:06:29,199 --> 00:06:30,319
that yes

152
00:06:30,319 --> 00:06:34,160
this is the optimal scheme

153
00:06:34,160 --> 00:06:36,800
okay so for the rest of the talk uh

154
00:06:36,800 --> 00:06:38,960
first i'll give you uh some intuition

155
00:06:38,960 --> 00:06:41,360
for the lower bound that we prove

156
00:06:41,360 --> 00:06:43,440
uh and i'll talk about the model in

157
00:06:43,440 --> 00:06:45,440
which we prove it which is called the

158
00:06:45,440 --> 00:06:46,880
symbolic model

159
00:06:46,880 --> 00:06:49,360
and give you the proof intuition in this

160
00:06:49,360 --> 00:06:51,280
model

161
00:06:51,280 --> 00:06:54,319
okay then i'll give some applications of

162
00:06:54,319 --> 00:06:57,919
fs eram where we sort of circumvent the

163
00:06:57,919 --> 00:07:00,639
lower bound

164
00:07:00,639 --> 00:07:02,960
okay and these applications are forward

165
00:07:02,960 --> 00:07:04,960
secret memory checkers

166
00:07:04,960 --> 00:07:08,000
oblivious forward secret encrypted ram

167
00:07:08,000 --> 00:07:12,160
and forward secret multicast encryption

168
00:07:12,639 --> 00:07:15,759
okay so first let me present to you the

169
00:07:15,759 --> 00:07:17,759
model

170
00:07:17,759 --> 00:07:19,440
before i do that

171
00:07:19,440 --> 00:07:21,360
i just want to mention that the cell

172
00:07:21,360 --> 00:07:22,720
probe model

173
00:07:22,720 --> 00:07:25,520
is considered the holy grail

174
00:07:25,520 --> 00:07:26,400
for

175
00:07:26,400 --> 00:07:29,199
private data structure lower bounds

176
00:07:29,199 --> 00:07:30,960
okay but in this case

177
00:07:30,960 --> 00:07:34,639
it turned out to be too powerful

178
00:07:34,639 --> 00:07:37,680
okay so the cell probe model only counts

179
00:07:37,680 --> 00:07:39,919
cell probes towards the cost

180
00:07:39,919 --> 00:07:41,919
of the protocol itself

181
00:07:41,919 --> 00:07:45,440
so not any other computation just uh

182
00:07:45,440 --> 00:07:46,639
how many

183
00:07:46,639 --> 00:07:50,319
uh server cells that you touch

184
00:07:50,319 --> 00:07:52,879
okay but on the other hand it still

185
00:07:52,879 --> 00:07:55,599
requires any adversary attacking the

186
00:07:55,599 --> 00:07:59,039
protocol to be ppt

187
00:07:59,039 --> 00:08:02,720
uh so in fact there is a trivial uh big

188
00:08:02,720 --> 00:08:05,199
o of one cell probe solution

189
00:08:05,199 --> 00:08:08,479
and this is done using authentic uh uh

190
00:08:08,479 --> 00:08:10,720
sorry authenticated encryption

191
00:08:10,720 --> 00:08:14,400
and the the scheme unfortunately uh for

192
00:08:14,400 --> 00:08:17,440
the upper bound will not be pp uh ppt

193
00:08:17,440 --> 00:08:21,280
itself uh but basically what we'll do is

194
00:08:21,280 --> 00:08:24,960
uh when we go to do a new write

195
00:08:24,960 --> 00:08:27,280
uh we'll just choose a random

196
00:08:27,280 --> 00:08:30,000
authenticated encryption key and encrypt

197
00:08:30,000 --> 00:08:32,559
the data under this key

198
00:08:32,559 --> 00:08:34,240
store the encryption on the server and

199
00:08:34,240 --> 00:08:36,958
just forget the key

200
00:08:36,958 --> 00:08:37,919
okay

201
00:08:37,919 --> 00:08:40,880
now any ppt adversary clearly can't

202
00:08:40,880 --> 00:08:42,399
break this scheme

203
00:08:42,399 --> 00:08:44,640
uh

204
00:08:44,640 --> 00:08:46,320
but

205
00:08:46,320 --> 00:08:48,640
when when the protocol goes to read a

206
00:08:48,640 --> 00:08:50,240
data item

207
00:08:50,240 --> 00:08:52,480
it'll just try all authenticated

208
00:08:52,480 --> 00:08:55,120
encryption keys uh which it can do

209
00:08:55,120 --> 00:08:57,360
because it's it has unbounded

210
00:08:57,360 --> 00:09:00,399
computation and only needs to download

211
00:09:00,399 --> 00:09:02,720
or probe the single cell with the data

212
00:09:02,720 --> 00:09:03,600
item

213
00:09:03,600 --> 00:09:06,080
uh and it'll just uh yeah try all these

214
00:09:06,080 --> 00:09:08,320
keys until it succeeds

215
00:09:08,320 --> 00:09:10,160
okay so

216
00:09:10,160 --> 00:09:12,640
here we've shown that the basic cell

217
00:09:12,640 --> 00:09:16,160
probe model is too strong

218
00:09:16,160 --> 00:09:18,480
and what about other models well there's

219
00:09:18,480 --> 00:09:20,800
also the balls and bins model that has

220
00:09:20,800 --> 00:09:23,200
been used to improve some private data

221
00:09:23,200 --> 00:09:25,040
structure lower bounds

222
00:09:25,040 --> 00:09:27,920
but in this case it's actually too weak

223
00:09:27,920 --> 00:09:30,240
and this is because in this model server

224
00:09:30,240 --> 00:09:32,480
cells can only hold encrypted array

225
00:09:32,480 --> 00:09:35,120
contents and nothing else

226
00:09:35,120 --> 00:09:37,920
okay so namely even the folklore

227
00:09:37,920 --> 00:09:40,399
construction for fseram is not captured

228
00:09:40,399 --> 00:09:42,000
in this model

229
00:09:42,000 --> 00:09:44,320
okay this is because we have uh

230
00:09:44,320 --> 00:09:46,880
encryptions of keys on the server as

231
00:09:46,880 --> 00:09:48,959
well

232
00:09:48,959 --> 00:09:50,800
so the model that we do use in the end

233
00:09:50,800 --> 00:09:53,120
is called the symbolic model

234
00:09:53,120 --> 00:09:55,680
and it's been used uh recently in other

235
00:09:55,680 --> 00:09:57,200
works as well

236
00:09:57,200 --> 00:09:59,040
and it's actually the perfect in-between

237
00:09:59,040 --> 00:10:02,000
of these two models

238
00:10:02,079 --> 00:10:03,600
that i mentioned before

239
00:10:03,600 --> 00:10:07,440
okay so what is a symbolic model

240
00:10:07,440 --> 00:10:09,920
well in the symbolic model server cells

241
00:10:09,920 --> 00:10:12,000
hold strings that are arbitrarily

242
00:10:12,000 --> 00:10:14,320
derived derived from some structured

243
00:10:14,320 --> 00:10:16,079
grammar

244
00:10:16,079 --> 00:10:19,920
okay and so in our work uh we allow for

245
00:10:19,920 --> 00:10:23,600
encryption and possibly dual prf keys

246
00:10:23,600 --> 00:10:25,120
which are basically just

247
00:10:25,120 --> 00:10:27,519
uh random coins

248
00:10:27,519 --> 00:10:28,800
uh

249
00:10:28,800 --> 00:10:31,839
also ciphertext from this encryption

250
00:10:31,839 --> 00:10:33,360
scheme

251
00:10:33,360 --> 00:10:34,959
secret shares

252
00:10:34,959 --> 00:10:38,560
and data entries themselves

253
00:10:38,959 --> 00:10:41,920
now uh note that strings can be

254
00:10:41,920 --> 00:10:44,000
arbitrarily nested combinations of the

255
00:10:44,000 --> 00:10:46,480
above

256
00:10:46,480 --> 00:10:49,920
so here's our grammar

257
00:10:50,480 --> 00:10:52,880
uh yeah it incumb

258
00:10:52,880 --> 00:10:55,440
encompasses uh all the things i said

259
00:10:55,440 --> 00:10:56,959
before so like

260
00:10:56,959 --> 00:11:00,560
keys cipher texts

261
00:11:00,560 --> 00:11:03,200
yeah data items secret shares

262
00:11:03,200 --> 00:11:05,920
all this stuff and in a nested

263
00:11:05,920 --> 00:11:07,839
nature

264
00:11:07,839 --> 00:11:10,720
okay so some examples

265
00:11:10,720 --> 00:11:14,000
well we could have uh random coins drawn

266
00:11:14,000 --> 00:11:16,079
from our uh

267
00:11:16,079 --> 00:11:16,959
uh

268
00:11:16,959 --> 00:11:18,640
set of random strings which is

269
00:11:18,640 --> 00:11:21,279
represented by capital r

270
00:11:21,279 --> 00:11:24,880
uh so we could have random coin little r

271
00:11:24,880 --> 00:11:26,720
or little r prime

272
00:11:26,720 --> 00:11:30,079
uh we could have some encryption uh

273
00:11:30,079 --> 00:11:31,360
under some

274
00:11:31,360 --> 00:11:33,440
prf computation

275
00:11:33,440 --> 00:11:35,360
of some secret share of another

276
00:11:35,360 --> 00:11:38,720
encryption of some data item d1

277
00:11:38,720 --> 00:11:42,800
uh yeah and maybe the other secret share

278
00:11:42,800 --> 00:11:46,079
of this encryption as well

279
00:11:46,800 --> 00:11:49,440
okay so now i'll talk about the allowed

280
00:11:49,440 --> 00:11:51,760
derivations in this model

281
00:11:51,760 --> 00:11:54,240
and what i mean by that is

282
00:11:54,240 --> 00:11:55,839
the strings that are derived from this

283
00:11:55,839 --> 00:11:56,800
grammar

284
00:11:56,800 --> 00:11:59,680
don't actually have any meaning uh so

285
00:11:59,680 --> 00:12:01,279
really like

286
00:12:01,279 --> 00:12:03,040
no meaning and also sort of no

287
00:12:03,040 --> 00:12:04,720
representation

288
00:12:04,720 --> 00:12:05,519
uh

289
00:12:05,519 --> 00:12:08,240
beyond just uh being some abstract

290
00:12:08,240 --> 00:12:09,920
symbol

291
00:12:09,920 --> 00:12:11,600
so for example

292
00:12:11,600 --> 00:12:14,240
there's no bits in this model

293
00:12:14,240 --> 00:12:17,680
it's just uh yeah each symbol is its own

294
00:12:17,680 --> 00:12:20,560
distinct abstract symbol with

295
00:12:20,560 --> 00:12:23,440
no exact meaning on its own

296
00:12:23,440 --> 00:12:25,839
okay but this so-called entailment

297
00:12:25,839 --> 00:12:27,920
relation is what actually captures their

298
00:12:27,920 --> 00:12:29,440
meaning

299
00:12:29,440 --> 00:12:32,000
and it's quite intuitive basically for

300
00:12:32,000 --> 00:12:34,959
example uh you can only decrypt a cipher

301
00:12:34,959 --> 00:12:36,079
text

302
00:12:36,079 --> 00:12:37,279
if and only if you have its

303
00:12:37,279 --> 00:12:40,160
corresponding key

304
00:12:40,160 --> 00:12:43,600
uh with a prf key you can compute that

305
00:12:43,600 --> 00:12:46,959
any output of that prf

306
00:12:46,959 --> 00:12:50,000
uh and so going back to the examples of

307
00:12:50,000 --> 00:12:52,480
the symbols that we had on our last

308
00:12:52,480 --> 00:12:54,160
slide

309
00:12:54,160 --> 00:12:56,639
assuming 2 out of 2

310
00:12:56,639 --> 00:12:58,639
secret sharing

311
00:12:58,639 --> 00:13:01,360
we can derive d1

312
00:13:01,360 --> 00:13:03,279
if and only if we have the following

313
00:13:03,279 --> 00:13:05,440
string strings

314
00:13:05,440 --> 00:13:07,120
r r prime

315
00:13:07,120 --> 00:13:09,279
uh this first encryption

316
00:13:09,279 --> 00:13:10,959
and this uh

317
00:13:10,959 --> 00:13:14,240
secret chair right so what we can do is

318
00:13:14,240 --> 00:13:15,839
we'll uh

319
00:13:15,839 --> 00:13:19,839
compute the prf of r and

320
00:13:19,839 --> 00:13:22,560
decrypt this first ciphertext

321
00:13:22,560 --> 00:13:24,000
to get

322
00:13:24,000 --> 00:13:26,000
now both shares

323
00:13:26,000 --> 00:13:29,440
of the encryption of d1

324
00:13:29,440 --> 00:13:31,519
so we get this encryption and then use r

325
00:13:31,519 --> 00:13:34,800
prime to decrypt it okay

326
00:13:34,800 --> 00:13:38,320
but if for example we were missing uh

327
00:13:38,320 --> 00:13:41,040
the second share of this ciphertext

328
00:13:41,040 --> 00:13:42,000
uh

329
00:13:42,000 --> 00:13:44,480
or maybe our prime then we would not be

330
00:13:44,480 --> 00:13:48,680
able to derive d1

331
00:13:49,360 --> 00:13:53,040
okay so as part of our lower bound uh we

332
00:13:53,040 --> 00:13:55,680
define this key data graph

333
00:13:55,680 --> 00:13:58,240
and this key data graph uh abstracts

334
00:13:58,240 --> 00:14:00,959
encodings of the client and server cells

335
00:14:00,959 --> 00:14:04,000
and the data array itself

336
00:14:04,000 --> 00:14:06,560
okay so for this talk i'll only consider

337
00:14:06,560 --> 00:14:07,760
prf

338
00:14:07,760 --> 00:14:10,800
and encryption for simplicity

339
00:14:10,800 --> 00:14:12,959
so what is the key data graph well it's

340
00:14:12,959 --> 00:14:14,800
a directed

341
00:14:14,800 --> 00:14:17,199
graph at time t

342
00:14:17,199 --> 00:14:20,240
such that its vertices vt are keys that

343
00:14:20,240 --> 00:14:23,040
are sampled and still accessible by the

344
00:14:23,040 --> 00:14:24,639
protocol

345
00:14:24,639 --> 00:14:27,360
as well as the data entries at time t

346
00:14:27,360 --> 00:14:30,800
and then for the edges uh we have one

347
00:14:30,800 --> 00:14:32,880
case in which uh

348
00:14:32,880 --> 00:14:35,680
so for an edge from u to v

349
00:14:35,680 --> 00:14:37,600
it could exist if

350
00:14:37,600 --> 00:14:39,199
v

351
00:14:39,199 --> 00:14:40,240
is

352
00:14:40,240 --> 00:14:43,360
corresponds to some prf computation on

353
00:14:43,360 --> 00:14:45,199
you

354
00:14:45,199 --> 00:14:46,000
okay

355
00:14:46,000 --> 00:14:48,720
or also

356
00:14:48,880 --> 00:14:50,639
it could be that

357
00:14:50,639 --> 00:14:51,600
u

358
00:14:51,600 --> 00:14:56,000
is part of some nested encryption of v

359
00:14:56,000 --> 00:14:57,440
okay

360
00:14:57,440 --> 00:15:00,560
so if we have you know uh encryption of

361
00:15:00,560 --> 00:15:02,160
k1

362
00:15:02,160 --> 00:15:04,880
uh sorry encryption under k1

363
00:15:04,880 --> 00:15:07,360
of encryption under k2 of encryption

364
00:15:07,360 --> 00:15:09,040
under k3

365
00:15:09,040 --> 00:15:10,880
of k uh

366
00:15:10,880 --> 00:15:14,399
of k4 uh then for example we'd have

367
00:15:14,399 --> 00:15:17,600
edges from each of k1 k2 k3

368
00:15:17,600 --> 00:15:20,240
to k4

369
00:15:20,320 --> 00:15:23,680
okay uh and also uh

370
00:15:23,680 --> 00:15:26,959
this edge will exist if

371
00:15:26,959 --> 00:15:28,639
such a cipher text was stored in a

372
00:15:28,639 --> 00:15:32,720
server cell at any time in the past

373
00:15:33,839 --> 00:15:35,440
okay

374
00:15:35,440 --> 00:15:37,600
so of course the folklore construction

375
00:15:37,600 --> 00:15:40,000
is easily captured but it's really much

376
00:15:40,000 --> 00:15:42,480
more general

377
00:15:42,480 --> 00:15:44,720
this data graph

378
00:15:44,720 --> 00:15:48,560
okay so here's an example

379
00:15:49,040 --> 00:15:51,759
we have that k1

380
00:15:51,759 --> 00:15:54,560
is stored in a secret cell

381
00:15:54,560 --> 00:15:57,120
and we also have the encryption of k2

382
00:15:57,120 --> 00:16:00,560
under k1 k3 under k1

383
00:16:00,560 --> 00:16:04,639
of d1 under k2 d2 under k2

384
00:16:04,639 --> 00:16:06,399
d4 under k3

385
00:16:06,399 --> 00:16:08,560
and also the nested encryption

386
00:16:08,560 --> 00:16:09,920
of uh

387
00:16:09,920 --> 00:16:11,839
so the ciphertext

388
00:16:11,839 --> 00:16:15,920
which is the encryption of d3 under k3

389
00:16:15,920 --> 00:16:19,360
which is then uh encrypted under k2

390
00:16:19,360 --> 00:16:21,279
okay so this is what our key data graph

391
00:16:21,279 --> 00:16:24,000
would look like for this example

392
00:16:24,000 --> 00:16:26,399
and you know maybe we also have some

393
00:16:26,399 --> 00:16:29,440
other stuff as well

394
00:16:30,800 --> 00:16:33,360
okay so what happens

395
00:16:33,360 --> 00:16:35,040
if

396
00:16:35,040 --> 00:16:37,759
the protocol needs to overwrite d3 in

397
00:16:37,759 --> 00:16:40,079
this case

398
00:16:40,079 --> 00:16:42,720
well it must forget k1 for forward

399
00:16:42,720 --> 00:16:44,079
secrecy

400
00:16:44,079 --> 00:16:47,680
and then it must also forget either k2

401
00:16:47,680 --> 00:16:48,839
or

402
00:16:48,839 --> 00:16:50,399
k3

403
00:16:50,399 --> 00:16:51,279
right

404
00:16:51,279 --> 00:16:54,000
uh because if one of them is gone then

405
00:16:54,000 --> 00:16:55,199
this the

406
00:16:55,199 --> 00:16:56,560
the

407
00:16:56,560 --> 00:16:59,600
ciphertex encrypting d3

408
00:16:59,600 --> 00:17:02,720
cannot be decrypted

409
00:17:02,839 --> 00:17:07,199
okay so let's say we forget k1 k3

410
00:17:07,199 --> 00:17:10,319
that means that the encryption

411
00:17:10,319 --> 00:17:13,839
of uh d4 under k3

412
00:17:13,839 --> 00:17:18,480
as well as well as k2 and k3 under k1

413
00:17:18,480 --> 00:17:20,799
and finally this nested crypt encryption

414
00:17:20,799 --> 00:17:23,839
of d3 all become useless right because

415
00:17:23,839 --> 00:17:25,199
the protocol

416
00:17:25,199 --> 00:17:28,559
itself also will never be able to uh

417
00:17:28,559 --> 00:17:30,000
decrypt

418
00:17:30,000 --> 00:17:31,760
the ciphertext

419
00:17:31,760 --> 00:17:34,960
since these keys are gone

420
00:17:35,440 --> 00:17:38,160
okay so yeah correspond the the

421
00:17:38,160 --> 00:17:40,400
ciphertext corresponding to these edges

422
00:17:40,400 --> 00:17:43,280
are all gone now

423
00:17:43,600 --> 00:17:46,000
okay so now what's the intuition for the

424
00:17:46,000 --> 00:17:47,520
main theorem

425
00:17:47,520 --> 00:17:50,720
well we have this first lemma

426
00:17:50,720 --> 00:17:53,679
where we say that each data entry

427
00:17:53,679 --> 00:17:55,840
must have a path in gt

428
00:17:55,840 --> 00:17:58,000
from a vertex representing an encryption

429
00:17:58,000 --> 00:18:00,720
key in a secret cell right and this is

430
00:18:00,720 --> 00:18:02,960
because of correctness

431
00:18:02,960 --> 00:18:05,679
we must somehow be able to derive all

432
00:18:05,679 --> 00:18:08,640
data entries and also privacy

433
00:18:08,640 --> 00:18:11,200
uh data entries or keys that encrypt

434
00:18:11,200 --> 00:18:12,960
them can't just be stored in the clear

435
00:18:12,960 --> 00:18:15,760
on the server so there must be

436
00:18:15,760 --> 00:18:17,200
something

437
00:18:17,200 --> 00:18:20,400
in the client storage

438
00:18:20,640 --> 00:18:21,919
okay

439
00:18:21,919 --> 00:18:24,240
and now here's lemma 2.

440
00:18:24,240 --> 00:18:26,400
so this is just a general graph

441
00:18:26,400 --> 00:18:31,919
theoretic lemma if we take any graph gt

442
00:18:32,240 --> 00:18:35,120
satisfying some requirements but very

443
00:18:35,120 --> 00:18:37,600
basic requirements and we randomly

444
00:18:37,600 --> 00:18:38,559
choose

445
00:18:38,559 --> 00:18:40,960
a data entry

446
00:18:40,960 --> 00:18:43,760
then the corresponding path from the

447
00:18:43,760 --> 00:18:45,360
secret cell key

448
00:18:45,360 --> 00:18:49,679
has expected out degree log n over s

449
00:18:49,679 --> 00:18:52,240
and this expectation

450
00:18:52,240 --> 00:18:56,320
is just uh over uh the random choice of

451
00:18:56,320 --> 00:18:59,280
cell to overwrite

452
00:18:59,600 --> 00:19:00,960
okay

453
00:19:00,960 --> 00:19:03,360
and finally

454
00:19:03,360 --> 00:19:04,400
we

455
00:19:04,400 --> 00:19:06,080
have our theorem

456
00:19:06,080 --> 00:19:07,120
where

457
00:19:07,120 --> 00:19:08,080
yeah

458
00:19:08,080 --> 00:19:10,400
just like lemma two if we choose a data

459
00:19:10,400 --> 00:19:12,480
entry randomly to overwrite in each

460
00:19:12,480 --> 00:19:13,679
operation

461
00:19:13,679 --> 00:19:16,400
then an expectation the contents of log

462
00:19:16,400 --> 00:19:18,240
n over s server cells

463
00:19:18,240 --> 00:19:21,760
become useless like in the previous

464
00:19:21,760 --> 00:19:23,360
example

465
00:19:23,360 --> 00:19:29,039
okay and uh yeah the the uh

466
00:19:29,039 --> 00:19:32,240
the contents that become useless

467
00:19:32,240 --> 00:19:34,960
each operation uh are unique across

468
00:19:34,960 --> 00:19:37,280
operations so we're never double

469
00:19:37,280 --> 00:19:39,679
counting anything

470
00:19:39,679 --> 00:19:43,520
and i just want to emphasize that

471
00:19:43,520 --> 00:19:46,240
this this is agnostic to

472
00:19:46,240 --> 00:19:47,120
any

473
00:19:47,120 --> 00:19:50,240
random choices that a protocol makes

474
00:19:50,240 --> 00:19:55,120
because lemma two holds for any graph

475
00:19:55,679 --> 00:19:57,919
okay

476
00:19:59,280 --> 00:20:02,720
uh so yeah uh we can just

477
00:20:02,720 --> 00:20:04,720
uh also to take care of nested

478
00:20:04,720 --> 00:20:07,679
encryptions just take the graph with

479
00:20:07,679 --> 00:20:09,840
minimum out degree paths to each data

480
00:20:09,840 --> 00:20:10,960
entry

481
00:20:10,960 --> 00:20:14,720
and apply lemma2 to this

482
00:20:15,760 --> 00:20:17,760
okay so

483
00:20:17,760 --> 00:20:19,200
now

484
00:20:19,200 --> 00:20:21,600
the main intuition uh for some

485
00:20:21,600 --> 00:20:23,280
applications

486
00:20:23,280 --> 00:20:26,559
uh well we'll just focus on primitives

487
00:20:26,559 --> 00:20:28,880
that already have efficient

488
00:20:28,880 --> 00:20:31,679
uh meaning uh big o of log n

489
00:20:31,679 --> 00:20:34,480
tree based constructions

490
00:20:34,480 --> 00:20:38,320
okay and if we naively compose the

491
00:20:38,320 --> 00:20:42,080
folklore fse ram solution with them

492
00:20:42,080 --> 00:20:44,080
we'd get log squared and

493
00:20:44,080 --> 00:20:46,320
overhead

494
00:20:46,320 --> 00:20:49,600
but instead what we do is we overlay the

495
00:20:49,600 --> 00:20:52,640
fse ram tree with these constructions

496
00:20:52,640 --> 00:20:55,679
uh the trees in these constructions to

497
00:20:55,679 --> 00:20:58,559
retain big o of log n overhead

498
00:20:58,559 --> 00:21:01,520
okay so it looks something like this

499
00:21:01,520 --> 00:21:03,280
maybe this is the

500
00:21:03,280 --> 00:21:04,400
uh

501
00:21:04,400 --> 00:21:06,559
other primitive scheme

502
00:21:06,559 --> 00:21:09,039
and this is fse ram and we just combine

503
00:21:09,039 --> 00:21:11,200
them

504
00:21:11,200 --> 00:21:12,400
okay

505
00:21:12,400 --> 00:21:15,120
so the first application uh

506
00:21:15,120 --> 00:21:19,840
is on forward secret memory checkers

507
00:21:20,000 --> 00:21:20,880
so

508
00:21:20,880 --> 00:21:22,320
recall that for

509
00:21:22,320 --> 00:21:25,280
ford's secret encrypted ram we assumed

510
00:21:25,280 --> 00:21:27,440
that the server always returned the

511
00:21:27,440 --> 00:21:30,240
correct stored cells to the client for

512
00:21:30,240 --> 00:21:33,520
read and write operations

513
00:21:34,640 --> 00:21:36,240
on the other hand

514
00:21:36,240 --> 00:21:39,440
memory checkers which have also been

515
00:21:39,440 --> 00:21:41,440
very heavily studied in the past

516
00:21:41,440 --> 00:21:44,799
guarantee integrity of uh the outsource

517
00:21:44,799 --> 00:21:47,200
data array

518
00:21:47,200 --> 00:21:49,760
okay and for fs memory checkers we

519
00:21:49,760 --> 00:21:51,200
require both

520
00:21:51,200 --> 00:21:52,400
so fs

521
00:21:52,400 --> 00:21:54,159
of the data still holds

522
00:21:54,159 --> 00:21:56,640
and also uh the protocol should output

523
00:21:56,640 --> 00:21:58,880
some error

524
00:21:58,880 --> 00:22:01,440
if some tampering has occurred you know

525
00:22:01,440 --> 00:22:04,240
if the server returns uh

526
00:22:04,240 --> 00:22:05,440
incorrect

527
00:22:05,440 --> 00:22:07,039
server cells

528
00:22:07,039 --> 00:22:08,799
and this should happen even

529
00:22:08,799 --> 00:22:12,080
with client state leakages

530
00:22:12,080 --> 00:22:13,840
and what's the intuition

531
00:22:13,840 --> 00:22:16,559
well we'll just simply overlay classical

532
00:22:16,559 --> 00:22:20,000
merkle tree with our uh folklore fse ram

533
00:22:20,000 --> 00:22:22,080
construction

534
00:22:22,080 --> 00:22:24,720
okay so we'll retain uh big o of log n

535
00:22:24,720 --> 00:22:27,840
overhead which is optimal with respect

536
00:22:27,840 --> 00:22:28,960
to both

537
00:22:28,960 --> 00:22:31,679
our fse ram lower bound of this work

538
00:22:31,679 --> 00:22:34,159
and the most optimal memory checker

539
00:22:34,159 --> 00:22:35,919
construction

540
00:22:35,919 --> 00:22:38,000
and yeah the best known memory checker

541
00:22:38,000 --> 00:22:40,400
lower bound is actually big omega of log

542
00:22:40,400 --> 00:22:42,400
n over log log n so

543
00:22:42,400 --> 00:22:45,200
yeah not not quite tight with respect to

544
00:22:45,200 --> 00:22:48,799
that but it is tight with respect to

545
00:22:48,799 --> 00:22:51,918
the best construction

546
00:22:52,559 --> 00:22:55,039
okay so here's what a merkle tree looks

547
00:22:55,039 --> 00:22:56,400
like

548
00:22:56,400 --> 00:22:59,200
basically we we have the data cells at

549
00:22:59,200 --> 00:23:00,480
as the leaves

550
00:23:00,480 --> 00:23:02,080
uh and

551
00:23:02,080 --> 00:23:04,559
each of their parents stores a hash of

552
00:23:04,559 --> 00:23:05,679
them

553
00:23:05,679 --> 00:23:08,240
uh and we sort of recursively carry this

554
00:23:08,240 --> 00:23:09,679
through to the root

555
00:23:09,679 --> 00:23:12,480
okay so each node stores a hash of its

556
00:23:12,480 --> 00:23:15,039
two children

557
00:23:15,520 --> 00:23:16,880
okay

558
00:23:16,880 --> 00:23:20,880
so how do we combine this with fse ram

559
00:23:20,880 --> 00:23:22,799
well if we look at these two children

560
00:23:22,799 --> 00:23:23,679
here

561
00:23:23,679 --> 00:23:26,320
we store uh an encrypted

562
00:23:26,320 --> 00:23:27,200
uh

563
00:23:27,200 --> 00:23:29,600
sorry to ciphertext encrypting these

564
00:23:29,600 --> 00:23:31,280
data items

565
00:23:31,280 --> 00:23:34,480
and at its parent uh we'll start by

566
00:23:34,480 --> 00:23:36,240
storing the hash of these two

567
00:23:36,240 --> 00:23:38,799
ciphertexts

568
00:23:38,799 --> 00:23:40,880
okay and we'll do the same thing for d3

569
00:23:40,880 --> 00:23:43,440
and d4

570
00:23:44,080 --> 00:23:45,840
and then

571
00:23:45,840 --> 00:23:47,600
what we'll do at

572
00:23:47,600 --> 00:23:50,480
node zero zero and zero one uh

573
00:23:50,480 --> 00:23:53,600
excuse me at node uh

574
00:23:53,600 --> 00:23:56,400
yes sorry at zero zero and zero one is

575
00:23:56,400 --> 00:23:57,919
uh

576
00:23:57,919 --> 00:23:59,279
will have

577
00:23:59,279 --> 00:24:00,799
uh

578
00:24:00,799 --> 00:24:03,200
some key so the key

579
00:24:03,200 --> 00:24:04,080
that

580
00:24:04,080 --> 00:24:06,159
decrypts the leaves

581
00:24:06,159 --> 00:24:09,120
uh encrypted under its parent just as an

582
00:24:09,120 --> 00:24:11,360
fse ram

583
00:24:11,360 --> 00:24:13,840
okay and then at the parent of these two

584
00:24:13,840 --> 00:24:16,000
nodes zero zero and zero one

585
00:24:16,000 --> 00:24:17,760
we'll store a hash of both the

586
00:24:17,760 --> 00:24:20,559
ciphertext of the children

587
00:24:20,559 --> 00:24:22,080
and uh

588
00:24:22,080 --> 00:24:24,640
the hashes of the children

589
00:24:24,640 --> 00:24:26,080
okay and we'll just carry this through

590
00:24:26,080 --> 00:24:28,960
to the rest of the tree

591
00:24:28,960 --> 00:24:31,440
okay and for this hash you can just use

592
00:24:31,440 --> 00:24:34,000
collision resistant hash functions

593
00:24:34,000 --> 00:24:35,840
or if you want to avoid the random

594
00:24:35,840 --> 00:24:39,120
oracle model then you can use woofs

595
00:24:39,120 --> 00:24:41,360
but then yeah you need to also include

596
00:24:41,360 --> 00:24:43,200
the description of the hash function at

597
00:24:43,200 --> 00:24:44,400
each node

598
00:24:44,400 --> 00:24:46,400
and also uh the

599
00:24:46,400 --> 00:24:49,679
word size must be polynomial

600
00:24:49,679 --> 00:24:52,480
okay and also note that uh instead of

601
00:24:52,480 --> 00:24:54,000
using hashes

602
00:24:54,000 --> 00:24:55,120
uh

603
00:24:55,120 --> 00:24:58,240
we can just use fsaad

604
00:24:58,240 --> 00:24:59,279
uh

605
00:24:59,279 --> 00:25:00,960
but then uh

606
00:25:00,960 --> 00:25:03,679
we give up on integrity after some

607
00:25:03,679 --> 00:25:07,840
leakage occurs right because then the uh

608
00:25:07,840 --> 00:25:08,880
the

609
00:25:08,880 --> 00:25:10,880
uh basically the mac key

610
00:25:10,880 --> 00:25:11,760
uh

611
00:25:11,760 --> 00:25:14,559
is obtained by the adversary and so

612
00:25:14,559 --> 00:25:16,080
she can

613
00:25:16,080 --> 00:25:19,678
tamper with anything she wants

614
00:25:20,240 --> 00:25:22,559
okay

615
00:25:23,360 --> 00:25:24,720
so uh

616
00:25:24,720 --> 00:25:27,039
yeah how do readin reads and writes work

617
00:25:27,039 --> 00:25:29,679
well for reads it's just the same as in

618
00:25:29,679 --> 00:25:32,320
the fse ram construction but we just

619
00:25:32,320 --> 00:25:33,360
make sure

620
00:25:33,360 --> 00:25:35,679
the hashes of everything we download is

621
00:25:35,679 --> 00:25:37,760
okay and if not

622
00:25:37,760 --> 00:25:40,880
then we output error

623
00:25:40,880 --> 00:25:43,279
okay and then for writes it's also the

624
00:25:43,279 --> 00:25:46,320
same uh but when we download again we

625
00:25:46,320 --> 00:25:47,919
check the hashes

626
00:25:47,919 --> 00:25:49,679
uh and then when we

627
00:25:49,679 --> 00:25:52,159
uh write the the the new keys and

628
00:25:52,159 --> 00:25:54,799
ciphertext to the server we also

629
00:25:54,799 --> 00:25:57,679
regenerate the hashes

630
00:25:57,679 --> 00:26:00,080
okay so efficiency is nice

631
00:26:00,080 --> 00:26:02,880
uh asymptotically the same as before log

632
00:26:02,880 --> 00:26:04,000
n

633
00:26:04,000 --> 00:26:06,880
and for the security intuition well if

634
00:26:06,880 --> 00:26:09,840
we look at the root key in the hash

635
00:26:09,840 --> 00:26:11,919
then uh

636
00:26:11,919 --> 00:26:13,120
the hash

637
00:26:13,120 --> 00:26:15,039
ensures that we have the right cipher

638
00:26:15,039 --> 00:26:16,000
text

639
00:26:16,000 --> 00:26:19,679
uh so we correctly decrypt uh the the

640
00:26:19,679 --> 00:26:22,159
keys at the children

641
00:26:22,159 --> 00:26:25,520
and we still of course have privacy

642
00:26:25,520 --> 00:26:27,360
okay and then we can inductively carry

643
00:26:27,360 --> 00:26:30,000
out through this same argument uh the

644
00:26:30,000 --> 00:26:32,640
keys in the hash decrypted at level i

645
00:26:32,640 --> 00:26:34,559
uh will ensure that the cipher text at

646
00:26:34,559 --> 00:26:37,600
level i plus one decrypt correctly

647
00:26:37,600 --> 00:26:41,840
and we'll still have privacy

648
00:26:41,919 --> 00:26:43,120
okay

649
00:26:43,120 --> 00:26:47,200
so that's it for uh fs memory checkers

650
00:26:47,200 --> 00:26:49,520
now let's talk about oblivious

651
00:26:49,520 --> 00:26:50,840
fse

652
00:26:50,840 --> 00:26:53,840
ram so fs eram

653
00:26:53,840 --> 00:26:56,480
on its own does not require patterns of

654
00:26:56,480 --> 00:26:58,720
reads and writes to be hidden

655
00:26:58,720 --> 00:27:01,520
but of course oblivious ram does require

656
00:27:01,520 --> 00:27:03,279
this

657
00:27:03,279 --> 00:27:05,679
okay but oblivious ram does not allow

658
00:27:05,679 --> 00:27:08,000
for leakage of client state

659
00:27:08,000 --> 00:27:10,320
so the question we ask is can we combine

660
00:27:10,320 --> 00:27:13,039
these notions

661
00:27:13,120 --> 00:27:15,760
well the strongest notion which

662
00:27:15,760 --> 00:27:16,640
gives

663
00:27:16,640 --> 00:27:21,440
fs and obliviousness after corruptions

664
00:27:21,440 --> 00:27:24,080
unfortunately is inefficient

665
00:27:24,080 --> 00:27:26,720
and we in fact show an omega and cell

666
00:27:26,720 --> 00:27:28,640
probe lower bound

667
00:27:28,640 --> 00:27:30,559
which basically means the

668
00:27:30,559 --> 00:27:32,840
trivial solution of

669
00:27:32,840 --> 00:27:35,919
uh decrypting and re-encrypting

670
00:27:35,919 --> 00:27:38,399
everything on every read and write

671
00:27:38,399 --> 00:27:41,039
is optimal

672
00:27:41,039 --> 00:27:42,640
but

673
00:27:42,640 --> 00:27:45,360
we can achieve both modulo client

674
00:27:45,360 --> 00:27:46,559
leakage

675
00:27:46,559 --> 00:27:49,679
and what i mean is if leakage occurs

676
00:27:49,679 --> 00:27:53,039
then we have fs as an fse ram

677
00:27:53,039 --> 00:27:57,120
but the access pattern is not hidden

678
00:27:57,520 --> 00:28:00,080
if there is no leakage then we still

679
00:28:00,080 --> 00:28:02,559
have that our axis pattern is hidden

680
00:28:02,559 --> 00:28:04,000
and of course we have

681
00:28:04,000 --> 00:28:06,960
vacuous fs

682
00:28:07,279 --> 00:28:10,399
okay and we do this with o big o of log

683
00:28:10,399 --> 00:28:12,640
n times f of n over head

684
00:28:12,640 --> 00:28:15,200
for any function that is little omega of

685
00:28:15,200 --> 00:28:17,440
one

686
00:28:17,440 --> 00:28:19,600
okay and this is almost optimal with

687
00:28:19,600 --> 00:28:20,880
respect to

688
00:28:20,880 --> 00:28:23,760
the o ram lower bound and the fse ram

689
00:28:23,760 --> 00:28:26,399
lower bound

690
00:28:27,600 --> 00:28:29,440
okay so what's the intuition for our

691
00:28:29,440 --> 00:28:31,279
construction

692
00:28:31,279 --> 00:28:34,399
well if we use tree based orams then we

693
00:28:34,399 --> 00:28:37,360
can overlay the fse ram construction on

694
00:28:37,360 --> 00:28:38,880
this tree

695
00:28:38,880 --> 00:28:41,760
uh but of course uh tree based orams

696
00:28:41,760 --> 00:28:44,080
unfortunately require log squared and

697
00:28:44,080 --> 00:28:45,919
overhead

698
00:28:45,919 --> 00:28:47,919
on the other hand

699
00:28:47,919 --> 00:28:50,240
hierarchical orms have recently been

700
00:28:50,240 --> 00:28:51,840
shown to achieve

701
00:28:51,840 --> 00:28:55,360
optimal log n overhead

702
00:28:55,600 --> 00:28:57,600
okay but we can't of course easily

703
00:28:57,600 --> 00:29:00,000
overlay the tree-based fse ram

704
00:29:00,000 --> 00:29:01,600
construction

705
00:29:01,600 --> 00:29:05,120
on these hierarchical orams

706
00:29:05,120 --> 00:29:08,399
so what do we do well we just compose

707
00:29:08,399 --> 00:29:12,159
tree-based orms with hierarchical oorams

708
00:29:12,159 --> 00:29:15,600
we'll use uh tree based orams and

709
00:29:15,600 --> 00:29:18,000
replace the position map in these uh

710
00:29:18,000 --> 00:29:21,840
treebase orms with hierarchical oran

711
00:29:21,840 --> 00:29:23,360
okay so i'll show what i mean on this

712
00:29:23,360 --> 00:29:24,840
next

713
00:29:24,840 --> 00:29:29,039
slide uh so yeah first we have the

714
00:29:29,039 --> 00:29:30,640
position map

715
00:29:30,640 --> 00:29:33,600
uh which uh stores a map

716
00:29:33,600 --> 00:29:37,679
of each data cell uh to the leaf in the

717
00:29:37,679 --> 00:29:39,039
uh

718
00:29:39,039 --> 00:29:41,600
tree-based oram that we use

719
00:29:41,600 --> 00:29:44,559
okay and we store this in

720
00:29:44,559 --> 00:29:47,679
a hierarchical oram

721
00:29:47,679 --> 00:29:50,240
okay and we do this because yeah this

722
00:29:50,240 --> 00:29:53,760
this this position map is what causes a

723
00:29:53,760 --> 00:29:55,440
tree-based oram

724
00:29:55,440 --> 00:29:58,799
to have the extra log factor

725
00:29:58,799 --> 00:30:00,799
okay so then we have our tree where we

726
00:30:00,799 --> 00:30:04,320
have k epsilon stored at the root

727
00:30:04,320 --> 00:30:07,760
and in each interior node

728
00:30:07,760 --> 00:30:11,360
we store encryptions uh under the node

729
00:30:11,360 --> 00:30:13,200
at the parent

730
00:30:13,200 --> 00:30:15,679
of data items uh

731
00:30:15,679 --> 00:30:18,080
whose leaf is in the corresponding

732
00:30:18,080 --> 00:30:19,279
subtree

733
00:30:19,279 --> 00:30:20,840
okay and we

734
00:30:20,840 --> 00:30:25,120
uh pad with dummies if needed so that

735
00:30:25,120 --> 00:30:27,039
every every

736
00:30:27,039 --> 00:30:28,960
bucket has the same number of nodes

737
00:30:28,960 --> 00:30:31,360
always

738
00:30:31,440 --> 00:30:33,679
okay and each of these nodes will have a

739
00:30:33,679 --> 00:30:38,320
bucket with a constant many entries

740
00:30:39,520 --> 00:30:40,559
okay

741
00:30:40,559 --> 00:30:42,799
and yeah so to augment

742
00:30:42,799 --> 00:30:45,520
the tree based orm in the literature

743
00:30:45,520 --> 00:30:48,159
with our fse ram construction

744
00:30:48,159 --> 00:30:50,880
in each of these nodes we also store uh

745
00:30:50,880 --> 00:30:52,159
the the

746
00:30:52,159 --> 00:30:54,799
an encryption of the key at this node

747
00:30:54,799 --> 00:30:57,679
under its parent

748
00:30:58,000 --> 00:31:00,559
okay then we also have a stash

749
00:31:00,559 --> 00:31:01,360
which

750
00:31:01,360 --> 00:31:04,720
stores encryptions also under k epsilon

751
00:31:04,720 --> 00:31:06,320
of at most

752
00:31:06,320 --> 00:31:10,399
little omega login data items

753
00:31:11,200 --> 00:31:14,159
okay so how do we read and write

754
00:31:14,159 --> 00:31:16,480
let's say we're reading or writing

755
00:31:16,480 --> 00:31:19,840
cell i first we just look up i in the

756
00:31:19,840 --> 00:31:21,840
position map which because of our

757
00:31:21,840 --> 00:31:25,039
hierarchical realm has a lot uh big o of

758
00:31:25,039 --> 00:31:27,279
log n overhead

759
00:31:27,279 --> 00:31:29,600
then we retrieve the direct path and

760
00:31:29,600 --> 00:31:34,080
copath of i's leaf and decrypt them

761
00:31:34,080 --> 00:31:36,960
as in fse ram which of course is big o

762
00:31:36,960 --> 00:31:39,200
of log n overhead

763
00:31:39,200 --> 00:31:41,440
and then we retrieve and decrypt the

764
00:31:41,440 --> 00:31:43,840
stash which is that most little omega

765
00:31:43,840 --> 00:31:45,679
login overhead

766
00:31:45,679 --> 00:31:49,440
and if it's a read operation we just

767
00:31:49,440 --> 00:31:51,679
return data di

768
00:31:51,679 --> 00:31:53,120
and then continue

769
00:31:53,120 --> 00:31:54,480
along

770
00:31:54,480 --> 00:31:56,480
the next steps

771
00:31:56,480 --> 00:31:58,080
and if it's a

772
00:31:58,080 --> 00:32:02,000
write operation uh then we update

773
00:32:02,000 --> 00:32:03,360
the data

774
00:32:03,360 --> 00:32:07,279
uh at at i so we we

775
00:32:07,279 --> 00:32:11,760
we say we're going to now store di prime

776
00:32:11,760 --> 00:32:13,519
then

777
00:32:13,519 --> 00:32:15,440
in both cases

778
00:32:15,440 --> 00:32:18,159
we pick a new leaf at random for i

779
00:32:18,159 --> 00:32:20,320
and store it in the position map which

780
00:32:20,320 --> 00:32:21,919
of course is log n because of our

781
00:32:21,919 --> 00:32:24,559
hierarchical ram

782
00:32:24,559 --> 00:32:27,840
then we put it back in the stash

783
00:32:27,840 --> 00:32:31,120
with its corresponding leaf

784
00:32:31,120 --> 00:32:34,399
so the label for its leaf

785
00:32:34,399 --> 00:32:35,440
and

786
00:32:35,440 --> 00:32:38,320
then we greedily evict items from the

787
00:32:38,320 --> 00:32:40,240
stash

788
00:32:40,240 --> 00:32:43,440
to the nodes on the direct path of cell

789
00:32:43,440 --> 00:32:45,200
i in the tree

790
00:32:45,200 --> 00:32:48,399
uh sorry it's it's old leaf in the tree

791
00:32:48,399 --> 00:32:51,360
uh where we put a knight an item in the

792
00:32:51,360 --> 00:32:52,320
node

793
00:32:52,320 --> 00:32:54,480
only if its leaf is in the subtree of

794
00:32:54,480 --> 00:32:57,840
the node okay and since there is log n

795
00:32:57,840 --> 00:32:59,679
such nodes of course this is log n

796
00:32:59,679 --> 00:33:01,919
overhead

797
00:33:01,919 --> 00:33:04,480
and then finally we regenerate keys for

798
00:33:04,480 --> 00:33:05,519
the tree

799
00:33:05,519 --> 00:33:08,640
and re-encrypt the nodes as an fse ram

800
00:33:08,640 --> 00:33:11,600
and re-encrypt the stash which is uh log

801
00:33:11,600 --> 00:33:13,600
n overhead

802
00:33:13,600 --> 00:33:14,960
okay

803
00:33:14,960 --> 00:33:17,679
uh so yeah and then uh obliviousness

804
00:33:17,679 --> 00:33:21,279
follows from previous analyses of the

805
00:33:21,279 --> 00:33:24,480
tree based and hierarchical rims uh

806
00:33:24,480 --> 00:33:26,559
but you know basically of course for the

807
00:33:26,559 --> 00:33:29,840
pmap uh we have obliviousness from the

808
00:33:29,840 --> 00:33:31,840
hierarchical rem

809
00:33:31,840 --> 00:33:34,159
and then for the tree

810
00:33:34,159 --> 00:33:36,399
well we we just

811
00:33:36,399 --> 00:33:39,440
decrypt and re-encrypt a random

812
00:33:39,440 --> 00:33:41,440
root-to-leaf path and copath for each

813
00:33:41,440 --> 00:33:42,640
operation

814
00:33:42,640 --> 00:33:46,320
uh and uh also the whole stash okay so

815
00:33:46,320 --> 00:33:51,799
basically every operation looks the same

816
00:33:52,159 --> 00:33:55,679
okay now for our final application we

817
00:33:55,679 --> 00:33:58,320
have uh forward secret multicast

818
00:33:58,320 --> 00:34:00,240
encryption

819
00:34:00,240 --> 00:34:02,880
uh so what is multicast

820
00:34:02,880 --> 00:34:05,279
well multicast a group manager

821
00:34:05,279 --> 00:34:08,879
distributes keys to a group of end users

822
00:34:08,879 --> 00:34:11,520
and these users can be replaced

823
00:34:11,520 --> 00:34:12,800
at which point

824
00:34:12,800 --> 00:34:14,960
the group manager distributes a fresh

825
00:34:14,960 --> 00:34:18,239
key to the current users in the group

826
00:34:18,239 --> 00:34:20,480
such that the key is private to everyone

827
00:34:20,480 --> 00:34:22,399
else so namely

828
00:34:22,399 --> 00:34:24,639
everybody that was

829
00:34:24,639 --> 00:34:26,960
removed from the group previously and

830
00:34:26,960 --> 00:34:29,199
anybody who will be added to the group

831
00:34:29,199 --> 00:34:31,440
in the future

832
00:34:31,440 --> 00:34:33,440
okay so there's a classical tree based

833
00:34:33,440 --> 00:34:35,040
construction

834
00:34:35,040 --> 00:34:37,119
that achieves log n communication and

835
00:34:37,119 --> 00:34:39,760
computation

836
00:34:39,760 --> 00:34:41,918
okay so our application hopes for

837
00:34:41,918 --> 00:34:44,480
stronger security

838
00:34:44,480 --> 00:34:47,199
and recently

839
00:34:47,199 --> 00:34:48,560
there has

840
00:34:48,560 --> 00:34:51,760
the the community has has desired

841
00:34:51,760 --> 00:34:54,560
stronger security notions regarding

842
00:34:54,560 --> 00:34:56,159
state leakage

843
00:34:56,159 --> 00:34:58,960
uh so for example in continuous group

844
00:34:58,960 --> 00:35:00,720
key agreement

845
00:35:00,720 --> 00:35:04,480
we have the same setting as multicast

846
00:35:04,480 --> 00:35:06,640
but there's no group manager

847
00:35:06,640 --> 00:35:09,119
and this serves as the core of secure

848
00:35:09,119 --> 00:35:11,599
group messaging protocols

849
00:35:11,599 --> 00:35:14,480
and in continuous group key agreement

850
00:35:14,480 --> 00:35:17,599
user states might be leaked and we still

851
00:35:17,599 --> 00:35:20,880
want uh fs and what's called as uh

852
00:35:20,880 --> 00:35:24,480
what's known as post compromise security

853
00:35:24,480 --> 00:35:26,720
okay but unfortunately this primitive

854
00:35:26,720 --> 00:35:29,119
can be very inefficient

855
00:35:29,119 --> 00:35:31,440
big omega event communication and

856
00:35:31,440 --> 00:35:32,960
computation

857
00:35:32,960 --> 00:35:36,480
per operation in the worst case

858
00:35:36,800 --> 00:35:38,320
so multicast

859
00:35:38,320 --> 00:35:40,960
can be useful for the sgm setting

860
00:35:40,960 --> 00:35:44,000
where there's only one administrator

861
00:35:44,000 --> 00:35:45,920
who adds and removes users

862
00:35:45,920 --> 00:35:47,920
because you know of course we retain

863
00:35:47,920 --> 00:35:50,160
this nice login

864
00:35:50,160 --> 00:35:52,799
efficiency

865
00:35:53,200 --> 00:35:56,640
okay so in this talk uh we'll just focus

866
00:35:56,640 --> 00:35:59,680
on forward secrecy for

867
00:35:59,680 --> 00:36:02,000
the multicast group manager state

868
00:36:02,000 --> 00:36:04,240
leakages only and

869
00:36:04,240 --> 00:36:06,079
disregard

870
00:36:06,079 --> 00:36:09,359
user leakages for now

871
00:36:09,599 --> 00:36:12,720
okay and as i just said we'll retain log

872
00:36:12,720 --> 00:36:15,119
n communication and computation

873
00:36:15,119 --> 00:36:17,119
and also uh

874
00:36:17,119 --> 00:36:20,720
aim for small group manager secret state

875
00:36:20,720 --> 00:36:23,119
okay and so the for the security what

876
00:36:23,119 --> 00:36:25,119
what we want is if the group manager is

877
00:36:25,119 --> 00:36:28,720
corrupted uh all previous keys

878
00:36:28,720 --> 00:36:32,399
so group keys should remain secure

879
00:36:32,480 --> 00:36:34,480
okay and this is optimal with respect to

880
00:36:34,480 --> 00:36:37,119
both our fse ram lower bound and

881
00:36:37,119 --> 00:36:41,560
previous multicast lower bounds

882
00:36:41,599 --> 00:36:44,079
okay so yeah here's the folklore

883
00:36:44,079 --> 00:36:46,400
multicast construction

884
00:36:46,400 --> 00:36:49,200
we have a tree of keys

885
00:36:49,200 --> 00:36:51,440
user keys are at the leaves and the

886
00:36:51,440 --> 00:36:53,839
invariant that we want is that users

887
00:36:53,839 --> 00:36:56,400
only know the keys at the nodes on their

888
00:36:56,400 --> 00:36:59,520
direct path from their leaf to the root

889
00:36:59,520 --> 00:37:01,599
okay and the group manager stores the

890
00:37:01,599 --> 00:37:04,000
whole tree

891
00:37:04,000 --> 00:37:06,640
so what happens when we we replace user

892
00:37:06,640 --> 00:37:09,839
3 with user 9

893
00:37:09,839 --> 00:37:12,079
well we put user

894
00:37:12,079 --> 00:37:14,960
user 9's key in the old

895
00:37:14,960 --> 00:37:16,240
leaf

896
00:37:16,240 --> 00:37:19,359
then we generate a new key for its

897
00:37:19,359 --> 00:37:20,560
parent

898
00:37:20,560 --> 00:37:23,119
and encrypt this key to both children so

899
00:37:23,119 --> 00:37:24,000
both

900
00:37:24,000 --> 00:37:27,040
uh to id9 and id4

901
00:37:27,040 --> 00:37:28,720
then uh

902
00:37:28,720 --> 00:37:30,800
sample a new key for the parent of zero

903
00:37:30,800 --> 00:37:32,160
one prime

904
00:37:32,160 --> 00:37:34,480
and encrypt to both children and finally

905
00:37:34,480 --> 00:37:38,640
a sample a new root key which serves as

906
00:37:38,640 --> 00:37:40,160
the group secret

907
00:37:40,160 --> 00:37:41,760
uh

908
00:37:41,760 --> 00:37:43,760
yeah and uh

909
00:37:43,760 --> 00:37:46,480
the users uh that that are in the

910
00:37:46,480 --> 00:37:47,839
subtrees

911
00:37:47,839 --> 00:37:50,400
just decrypt uh

912
00:37:50,400 --> 00:37:52,480
whichever cipher text

913
00:37:52,480 --> 00:37:55,280
comes first along their direct path

914
00:37:55,280 --> 00:37:56,400
uh

915
00:37:56,400 --> 00:37:59,359
to to acquire uh the proper keys that it

916
00:37:59,359 --> 00:38:03,119
needs uh to to maintain this invariant i

917
00:38:03,119 --> 00:38:06,400
mentioned on the last slide

918
00:38:06,720 --> 00:38:08,640
okay so our first step in making this

919
00:38:08,640 --> 00:38:09,920
construction

920
00:38:09,920 --> 00:38:11,680
forward secret

921
00:38:11,680 --> 00:38:14,480
uh is the following let's say we do the

922
00:38:14,480 --> 00:38:16,880
same thing replace user three with user

923
00:38:16,880 --> 00:38:20,720
nine and then uh

924
00:38:20,720 --> 00:38:21,520
yeah

925
00:38:21,520 --> 00:38:25,119
at each node we have in addition to a

926
00:38:25,119 --> 00:38:25,920
key

927
00:38:25,920 --> 00:38:28,000
also a prg seed

928
00:38:28,000 --> 00:38:30,160
and the key will actually be a one-time

929
00:38:30,160 --> 00:38:32,560
pad key

930
00:38:32,560 --> 00:38:35,440
okay uh and so

931
00:38:35,440 --> 00:38:38,079
uh yeah when we replace

932
00:38:38,079 --> 00:38:39,440
nine

933
00:38:39,440 --> 00:38:41,839
uh we have a

934
00:38:41,839 --> 00:38:47,200
new seat and key s3 prime and k3 prime

935
00:38:47,200 --> 00:38:48,160
and

936
00:38:48,160 --> 00:38:50,880
we sample a new

937
00:38:50,880 --> 00:38:53,839
seed and key at the parent

938
00:38:53,839 --> 00:38:57,920
and then we just do a one-time pad of

939
00:38:57,920 --> 00:38:59,599
the new key

940
00:38:59,599 --> 00:39:02,079
at the parent under both children

941
00:39:02,079 --> 00:39:04,960
so really also

942
00:39:04,960 --> 00:39:08,640
we want to be able to uh

943
00:39:08,640 --> 00:39:11,359
obtain s1 prime from these

944
00:39:11,359 --> 00:39:13,520
encryptions as well and i sort of just

945
00:39:13,520 --> 00:39:15,440
swept that under the rug but basically

946
00:39:15,440 --> 00:39:18,320
you just encrypt a seed that derives

947
00:39:18,320 --> 00:39:19,119
both

948
00:39:19,119 --> 00:39:23,040
s1 prime and k1 prime

949
00:39:23,040 --> 00:39:26,400
okay but now importantly

950
00:39:26,400 --> 00:39:29,200
every user in the subtree as well as the

951
00:39:29,200 --> 00:39:30,560
group manager

952
00:39:30,560 --> 00:39:32,800
will just uh

953
00:39:32,800 --> 00:39:35,359
ratchet forward uh

954
00:39:35,359 --> 00:39:37,440
the two children here the keys at the

955
00:39:37,440 --> 00:39:40,560
two children uh using a prg computation

956
00:39:40,560 --> 00:39:43,839
on s2 and s3 prime

957
00:39:43,839 --> 00:39:44,800
okay

958
00:39:44,800 --> 00:39:47,200
and so as soon as a key is used we

959
00:39:47,200 --> 00:39:50,960
delete it so we have forward secrecy

960
00:39:50,960 --> 00:39:51,920
okay

961
00:39:51,920 --> 00:39:54,400
because if a group manager is corrupted

962
00:39:54,400 --> 00:39:55,760
then

963
00:39:55,760 --> 00:39:59,040
all all the adversary sees is uh keys

964
00:39:59,040 --> 00:40:02,480
that have never been used before

965
00:40:02,560 --> 00:40:04,800
okay but unfortunately the group manager

966
00:40:04,800 --> 00:40:08,079
still stores the whole tree

967
00:40:08,079 --> 00:40:11,040
so what we do to remedy this is just

968
00:40:11,040 --> 00:40:12,720
overlay our

969
00:40:12,720 --> 00:40:14,800
fs eram construction

970
00:40:14,800 --> 00:40:16,960
uh on the multicast tree which the group

971
00:40:16,960 --> 00:40:18,960
manager stores

972
00:40:18,960 --> 00:40:20,160
okay so

973
00:40:20,160 --> 00:40:23,440
let's say we have n equals four

974
00:40:23,440 --> 00:40:26,079
so four users in our group

975
00:40:26,079 --> 00:40:29,119
well we have a ram key in the group

976
00:40:29,119 --> 00:40:31,599
manager's secret state so it's client

977
00:40:31,599 --> 00:40:32,800
storage

978
00:40:32,800 --> 00:40:35,520
and this ram key encrypts

979
00:40:35,520 --> 00:40:36,480
both

980
00:40:36,480 --> 00:40:39,760
the ram key at its children as in rfs

981
00:40:39,760 --> 00:40:41,920
erim folklore construction

982
00:40:41,920 --> 00:40:45,359
uh but also uh the seed and key for the

983
00:40:45,359 --> 00:40:48,240
multicast construction

984
00:40:48,240 --> 00:40:50,160
okay and we just carry this through to

985
00:40:50,160 --> 00:40:50,880
the

986
00:40:50,880 --> 00:40:54,160
to the leaves

987
00:40:54,160 --> 00:40:57,440
okay so how does a replace work now

988
00:40:57,440 --> 00:41:01,520
well if we want to replace id2 with id5

989
00:41:01,520 --> 00:41:04,240
uh we just download and decrypt

990
00:41:04,240 --> 00:41:07,040
the direct path and co-path of id2 as in

991
00:41:07,040 --> 00:41:09,920
our fse ram construction

992
00:41:09,920 --> 00:41:12,720
then we generate the new multicast keys

993
00:41:12,720 --> 00:41:14,720
and cipher text for this path and

994
00:41:14,720 --> 00:41:16,720
co-path

995
00:41:16,720 --> 00:41:17,760
and then

996
00:41:17,760 --> 00:41:20,240
we just

997
00:41:20,560 --> 00:41:22,079
do the same

998
00:41:22,079 --> 00:41:25,119
for our fse ram component

999
00:41:25,119 --> 00:41:28,160
where we replace the ram keys on the

1000
00:41:28,160 --> 00:41:31,040
direct path and regenerate encryptions

1001
00:41:31,040 --> 00:41:34,400
of the new keys so both the new uh ram

1002
00:41:34,400 --> 00:41:35,680
keys

1003
00:41:35,680 --> 00:41:38,640
and also the new seed key pairs

1004
00:41:38,640 --> 00:41:39,520
okay

1005
00:41:39,520 --> 00:41:43,760
and uh yeah basically security composes

1006
00:41:43,760 --> 00:41:45,920
uh

1007
00:41:45,920 --> 00:41:49,040
because yeah so

1008
00:41:49,040 --> 00:41:50,640
we have

1009
00:41:50,640 --> 00:41:54,319
uh forward secrecy with respect to our

1010
00:41:54,319 --> 00:41:56,800
fse ram part of the scheme

1011
00:41:56,800 --> 00:42:00,000
meaning that none of the keys at the old

1012
00:42:00,000 --> 00:42:02,400
sorry none of the old keys at the nodes

1013
00:42:02,400 --> 00:42:05,839
of the fse ram tree can be obtained

1014
00:42:05,839 --> 00:42:08,240
meaning when a corruption happens only

1015
00:42:08,240 --> 00:42:10,319
the current seed key pairs at the

1016
00:42:10,319 --> 00:42:13,119
multicast tree can be obtained

1017
00:42:13,119 --> 00:42:16,240
and as i said on the last slide

1018
00:42:16,240 --> 00:42:18,160
because the keys

1019
00:42:18,160 --> 00:42:19,920
will have never been used that are

1020
00:42:19,920 --> 00:42:21,359
corrupted

1021
00:42:21,359 --> 00:42:23,520
then we get forward secrecy with respect

1022
00:42:23,520 --> 00:42:24,400
to

1023
00:42:24,400 --> 00:42:27,920
previous group keys

1024
00:42:28,160 --> 00:42:29,200
okay

1025
00:42:29,200 --> 00:42:33,040
thanks that's it uh here's a link to our

1026
00:42:33,040 --> 00:42:34,079
uh

1027
00:42:34,079 --> 00:42:36,720
eprint paper and uh

1028
00:42:36,720 --> 00:42:39,359
yeah i'm happy to ask uh answer any

1029
00:42:39,359 --> 00:42:42,960
questions over email or in the live talk

1030
00:42:42,960 --> 00:42:45,839
all right bye

