1
00:00:03,040 --> 00:00:05,200
hi this video is on dory efficient

2
00:00:05,200 --> 00:00:06,879
transparent arguments for generalized

3
00:00:06,879 --> 00:00:08,720
products and polynomial commitments i'm

4
00:00:08,720 --> 00:00:10,559
jonathan lee the vp of r d at natural

5
00:00:10,559 --> 00:00:12,480
trance uh but most of this work happened

6
00:00:12,480 --> 00:00:13,840
whilst i was a senior researcher at

7
00:00:13,840 --> 00:00:16,079
microsoft research

8
00:00:16,079 --> 00:00:17,440
so what's an efficient transparent

9
00:00:17,440 --> 00:00:19,199
background well an argument some

10
00:00:19,199 --> 00:00:21,359
protocol between proof of p and verify v

11
00:00:21,359 --> 00:00:23,840
that's an np language l the cool notion

12
00:00:23,840 --> 00:00:26,320
here is that the prover has some there's

13
00:00:26,320 --> 00:00:27,359
some public

14
00:00:27,359 --> 00:00:29,199
instance x and l and the prover has some

15
00:00:29,199 --> 00:00:31,519
witness w for that instance

16
00:00:31,519 --> 00:00:33,280
and the proof was to show to verify that

17
00:00:33,280 --> 00:00:34,880
they know that witness possibly without

18
00:00:34,880 --> 00:00:36,480
revealing anything about her the

19
00:00:36,480 --> 00:00:37,760
verifier ultimately is going to accept

20
00:00:37,760 --> 00:00:39,680
his proof if and only if the group does

21
00:00:39,680 --> 00:00:41,520
have such a witness modulo some

22
00:00:41,520 --> 00:00:42,640
negligible

23
00:00:42,640 --> 00:00:44,239
error probabilities or the proof of

24
00:00:44,239 --> 00:00:45,440
being able to break some computational

25
00:00:45,440 --> 00:00:46,960
assumption

26
00:00:46,960 --> 00:00:48,960
so what do we mean by efficiency well

27
00:00:48,960 --> 00:00:50,640
for our purposes that means that set up

28
00:00:50,640 --> 00:00:52,239
and proving are both going to be linear

29
00:00:52,239 --> 00:00:53,600
in the size of the witness and the

30
00:00:53,600 --> 00:00:54,879
verification and proof size are both

31
00:00:54,879 --> 00:00:56,160
going to be logarithmic inside the

32
00:00:56,160 --> 00:00:57,520
witness

33
00:00:57,520 --> 00:00:58,879
in applications you can think of the

34
00:00:58,879 --> 00:01:00,559
witness sizes here being maybe two to

35
00:01:00,559 --> 00:01:02,640
twenty two thirty so you really don't

36
00:01:02,640 --> 00:01:03,760
wanna find yourself doing something

37
00:01:03,760 --> 00:01:05,438
quadratic for example in the size of the

38
00:01:05,438 --> 00:01:07,280
witness and you're certainly convenient

39
00:01:07,280 --> 00:01:09,520
for the verifier if all the operations

40
00:01:09,520 --> 00:01:12,080
they have to do are very small

41
00:01:12,080 --> 00:01:13,680
the other thing we need is transparency

42
00:01:13,680 --> 00:01:15,759
so again transparency means that you

43
00:01:15,759 --> 00:01:17,680
know if there's any set up places that

44
00:01:17,680 --> 00:01:18,640
can be

45
00:01:18,640 --> 00:01:20,479
anything from selecting fields selecting

46
00:01:20,479 --> 00:01:22,560
some groups um choosing a hashing

47
00:01:22,560 --> 00:01:24,479
algorithm whatever it might be so that

48
00:01:24,479 --> 00:01:26,320
can be done without embedding any

49
00:01:26,320 --> 00:01:28,720
secrets so for example

50
00:01:28,720 --> 00:01:30,240
it would be uh troubling if there was

51
00:01:30,240 --> 00:01:32,000
some particular element that you needed

52
00:01:32,000 --> 00:01:33,759
to know the log of in order to compute

53
00:01:33,759 --> 00:01:35,759
secret uh to compute the setup but if

54
00:01:35,759 --> 00:01:37,119
you need the logarithm that element that

55
00:01:37,119 --> 00:01:38,000
you could

56
00:01:38,000 --> 00:01:41,400
break into tasking

57
00:01:41,439 --> 00:01:43,040
so and the other question is what's a

58
00:01:43,040 --> 00:01:44,320
generalized inner product and what's a

59
00:01:44,320 --> 00:01:46,399
polynomial well for that we're going to

60
00:01:46,399 --> 00:01:48,560
have to fix some yellow scales f and

61
00:01:48,560 --> 00:01:50,399
we're going to introduce some uh pairing

62
00:01:50,399 --> 00:01:52,720
friendly curve so we've got two curves

63
00:01:52,720 --> 00:01:55,280
g1 g2 they're not that exogenous uh and

64
00:01:55,280 --> 00:01:59,119
some map g1 cross g2 to g2

65
00:01:59,360 --> 00:02:01,759
so in this context a generalized inner

66
00:02:01,759 --> 00:02:03,840
product argument is really about three

67
00:02:03,840 --> 00:02:05,600
back spaces uvw and some some air

68
00:02:05,600 --> 00:02:07,840
priority crossfit w so in the simplest

69
00:02:07,840 --> 00:02:09,440
case you could think of u and v both

70
00:02:09,440 --> 00:02:11,920
being vectors and f uh and w being

71
00:02:11,920 --> 00:02:13,120
scalable from ash

72
00:02:13,120 --> 00:02:15,280
but you could also take you know u or v

73
00:02:15,280 --> 00:02:16,720
individually to be

74
00:02:16,720 --> 00:02:18,080
one of the two source groups in which

75
00:02:18,080 --> 00:02:21,040
case you might have something from

76
00:02:21,040 --> 00:02:22,640
something like a multi-exponentiation

77
00:02:22,640 --> 00:02:25,200
would be a bilinear map from a vector of

78
00:02:25,200 --> 00:02:27,040
scale as an f and a vector of elements

79
00:02:27,040 --> 00:02:29,200
from g1 to a scale into a single element

80
00:02:29,200 --> 00:02:30,239
of g1

81
00:02:30,239 --> 00:02:32,640
um or you could even take u and b to the

82
00:02:32,640 --> 00:02:34,239
effects of elements of g1 and g2

83
00:02:34,239 --> 00:02:37,440
respectively and wp an element of gt

84
00:02:37,440 --> 00:02:39,360
the key point is however you do this you

85
00:02:39,360 --> 00:02:42,000
have some commitments to d1 d2 as the

86
00:02:42,000 --> 00:02:43,920
commitment to elements of uv and w and

87
00:02:43,920 --> 00:02:45,519
you want to give some argument that you

88
00:02:45,519 --> 00:02:47,840
know some openings of those commandments

89
00:02:47,840 --> 00:02:48,800
um

90
00:02:48,800 --> 00:02:50,080
and that if you would take the inner

91
00:02:50,080 --> 00:02:51,840
product between those openings you would

92
00:02:51,840 --> 00:02:54,959
get the uh the results that you expect

93
00:02:54,959 --> 00:02:56,800
so what would you care about a

94
00:02:56,800 --> 00:02:58,319
generalized and a product argument does

95
00:02:58,319 --> 00:03:00,000
that certainly intrinsic interest of

96
00:03:00,000 --> 00:03:02,400
being able to argue about it well

97
00:03:02,400 --> 00:03:03,519
basically you can use these things to

98
00:03:03,519 --> 00:03:05,760
build polynomial elements so

99
00:03:05,760 --> 00:03:07,440
for polynomial commitment we fix some

100
00:03:07,440 --> 00:03:09,280
sequence of degrees uh we now have a

101
00:03:09,280 --> 00:03:11,760
commitment to some f some possibly

102
00:03:11,760 --> 00:03:14,480
multivariate polynomial uh and some

103
00:03:14,480 --> 00:03:15,519
scalar

104
00:03:15,519 --> 00:03:18,319
uh and then the notion is that if we fix

105
00:03:18,319 --> 00:03:19,680
some

106
00:03:19,680 --> 00:03:22,159
some public x1 through xn that you can

107
00:03:22,159 --> 00:03:24,879
make some argument that uh you can open

108
00:03:24,879 --> 00:03:27,599
a particular commitment to f and commit

109
00:03:27,599 --> 00:03:29,440
some potential evaluation you could

110
00:03:29,440 --> 00:03:31,040
prove that the

111
00:03:31,040 --> 00:03:33,040
f evaluates that x is that evaluation

112
00:03:33,040 --> 00:03:35,840
and in the implicitly you can check that

113
00:03:35,840 --> 00:03:37,280
f has a degree sequence expanded by the

114
00:03:37,280 --> 00:03:38,239
d is

115
00:03:38,239 --> 00:03:39,519
now this differs slightly from the

116
00:03:39,519 --> 00:03:41,599
traditional definition of uh a

117
00:03:41,599 --> 00:03:42,879
polynomial commitment in the sense of

118
00:03:42,879 --> 00:03:45,280
cutting because we're committing to the

119
00:03:45,280 --> 00:03:46,720
evaluation rather than having to be in

120
00:03:46,720 --> 00:03:47,840
the play

121
00:03:47,840 --> 00:03:49,599
and we're allowing the

122
00:03:49,599 --> 00:03:51,760
general argument to take place so maybe

123
00:03:51,760 --> 00:03:52,799
it's uh interactive rather than

124
00:03:52,799 --> 00:03:55,200
non-interactive

125
00:03:55,200 --> 00:03:56,319
so

126
00:03:56,319 --> 00:03:57,599
why would you care about data live at

127
00:03:57,599 --> 00:03:59,280
these days well fundamentally if you go

128
00:03:59,280 --> 00:04:01,040
and you look at uh

129
00:04:01,040 --> 00:04:02,159
much of the existing literature for

130
00:04:02,159 --> 00:04:04,000
building case studies so succinct

131
00:04:04,000 --> 00:04:05,439
non-interactive items and knowledge for

132
00:04:05,439 --> 00:04:06,959
mp3 languages

133
00:04:06,959 --> 00:04:08,799
this proceeds in a sequence of steps so

134
00:04:08,799 --> 00:04:10,400
typically the non-interactivity isn't

135
00:04:10,400 --> 00:04:13,680
quite under theatre many compile some

136
00:04:13,680 --> 00:04:14,959
um

137
00:04:14,959 --> 00:04:16,000
but

138
00:04:16,000 --> 00:04:17,759
then there's some decomposition of many

139
00:04:17,759 --> 00:04:18,959
of these algorithms many of these

140
00:04:18,959 --> 00:04:20,720
arguments into two phases

141
00:04:20,720 --> 00:04:22,800
first there's some poly logarithmic

142
00:04:22,800 --> 00:04:24,720
purely information theoretic production

143
00:04:24,720 --> 00:04:28,160
uh from the full ck snark or some

144
00:04:28,160 --> 00:04:30,080
generic language to specifically doing

145
00:04:30,080 --> 00:04:32,960
polynomial commands so um this is you

146
00:04:32,960 --> 00:04:34,800
know using tricks like some check and

147
00:04:34,800 --> 00:04:35,840
you know other other interesting

148
00:04:35,840 --> 00:04:36,800
techniques

149
00:04:36,800 --> 00:04:39,680
um and then separately you then have to

150
00:04:39,680 --> 00:04:42,400
actually evaluate these polynomials

151
00:04:42,400 --> 00:04:43,520
under some commandments you might have

152
00:04:43,520 --> 00:04:44,880
to send certain commitments from the

153
00:04:44,880 --> 00:04:47,040
approval to verify and it's very natural

154
00:04:47,040 --> 00:04:48,720
to you split those two things apart look

155
00:04:48,720 --> 00:04:50,800
at the reductions one one thing to study

156
00:04:50,800 --> 00:04:52,000
individually and the polynomial

157
00:04:52,000 --> 00:04:54,160
commitment is something in

158
00:04:54,160 --> 00:04:55,600
much of the literature this is not done

159
00:04:55,600 --> 00:04:57,120
and uh inside those two things are

160
00:04:57,120 --> 00:04:58,960
bundled together which you know will

161
00:04:58,960 --> 00:05:00,160
make it a little challenging to compare

162
00:05:00,160 --> 00:05:01,600
dory with some some

163
00:05:01,600 --> 00:05:04,560
with some other words

164
00:05:04,639 --> 00:05:06,240
and so you know what do we what do we

165
00:05:06,240 --> 00:05:09,120
want uh

166
00:05:09,280 --> 00:05:11,440
building um science well you know it

167
00:05:11,440 --> 00:05:12,720
needs to be concretely efficient it

168
00:05:12,720 --> 00:05:14,720
needs to be passed um it's helpful if it

169
00:05:14,720 --> 00:05:16,479
is transparent that's a nice feature to

170
00:05:16,479 --> 00:05:18,639
have music it's not um also you know

171
00:05:18,639 --> 00:05:21,360
you'll note that we have some

172
00:05:21,360 --> 00:05:23,440
01 collection of polynomials that might

173
00:05:23,440 --> 00:05:24,960
be evaluated as somehow one collection

174
00:05:24,960 --> 00:05:27,680
of points it will be convenient

175
00:05:27,680 --> 00:05:29,280
if it turns out that you can take that

176
00:05:29,280 --> 00:05:30,800
batch of polynomials and some faction

177
00:05:30,800 --> 00:05:32,560
points and maybe combine the evaluations

178
00:05:32,560 --> 00:05:34,880
in some efficient way

179
00:05:34,880 --> 00:05:35,600
so

180
00:05:35,600 --> 00:05:37,840
given this background schematically no

181
00:05:37,840 --> 00:05:39,199
what are some previous works that have

182
00:05:39,199 --> 00:05:40,639
been in space

183
00:05:40,639 --> 00:05:42,479
so we're going to compare the three

184
00:05:42,479 --> 00:05:44,720
works of these schematically so we have

185
00:05:44,720 --> 00:05:46,400
hyrax fractal and supersonic they're

186
00:05:46,400 --> 00:05:48,400
based on different assumptions so pyrex

187
00:05:48,400 --> 00:05:50,880
is just based on some curve with a rd

188
00:05:50,880 --> 00:05:52,479
lock so you can think of concrete e

189
00:05:52,479 --> 00:05:54,479
curve 255.9

190
00:05:54,479 --> 00:05:57,280
um fractal is based on b cell and iops

191
00:05:57,280 --> 00:05:59,600
so again you know you can you need a

192
00:05:59,600 --> 00:06:01,199
hash function but that's it uh and

193
00:06:01,199 --> 00:06:03,280
supersonic is based on groups of unknown

194
00:06:03,280 --> 00:06:04,639
order so

195
00:06:04,639 --> 00:06:06,319
uh these are

196
00:06:06,319 --> 00:06:07,680
an interesting kind of group where you

197
00:06:07,680 --> 00:06:10,160
somehow can't figure out their size um

198
00:06:10,160 --> 00:06:12,319
and as you can see you've got some some

199
00:06:12,319 --> 00:06:14,000
really interesting qualities so

200
00:06:14,000 --> 00:06:15,520
you know fire axe is concretely

201
00:06:15,520 --> 00:06:17,759
efficient for the prover to well

202
00:06:17,759 --> 00:06:19,360
parax is pretty efficient for the proof

203
00:06:19,360 --> 00:06:21,039
to evaluate

204
00:06:21,039 --> 00:06:22,560
but you know the commitment sizes and

205
00:06:22,560 --> 00:06:24,319
the evaluations are a little large uh

206
00:06:24,319 --> 00:06:25,919
for fractal you know across the board

207
00:06:25,919 --> 00:06:27,919
things look to be pretty good but the uh

208
00:06:27,919 --> 00:06:29,280
amount of

209
00:06:29,280 --> 00:06:30,960
communication required to an evaluation

210
00:06:30,960 --> 00:06:33,600
is larger than might be linked as is the

211
00:06:33,600 --> 00:06:35,199
complexity of the prover to work out

212
00:06:35,199 --> 00:06:36,639
right um

213
00:06:36,639 --> 00:06:38,319
and for something like supersonic it's

214
00:06:38,319 --> 00:06:39,919
uh at least naively a little tricky it

215
00:06:39,919 --> 00:06:41,360
looks like both the setup and the

216
00:06:41,360 --> 00:06:44,479
evaluation take one wouldn't be ideal

217
00:06:44,479 --> 00:06:45,280
uh

218
00:06:45,280 --> 00:06:47,440
now these are very essential comparisons

219
00:06:47,440 --> 00:06:49,280
you know we want to again understand

220
00:06:49,280 --> 00:06:50,880
this a little concretely that's

221
00:06:50,880 --> 00:06:52,240
challenging because it's momentation

222
00:06:52,240 --> 00:06:53,680
dependent but you know

223
00:06:53,680 --> 00:06:56,000
if we just fix a concrete security level

224
00:06:56,000 --> 00:06:57,680
and we get some concrete numbers that

225
00:06:57,680 --> 00:06:59,440
are you know more significant than they

226
00:06:59,440 --> 00:07:00,720
they happen to be what my laptop spit

227
00:07:00,720 --> 00:07:02,479
out um then you know we can get some

228
00:07:02,479 --> 00:07:03,919
some concrete numbers to attach to this

229
00:07:03,919 --> 00:07:05,120
so

230
00:07:05,120 --> 00:07:07,360
uh benchmarking with the fastest code i

231
00:07:07,360 --> 00:07:09,599
could find um you know we see that

232
00:07:09,599 --> 00:07:11,280
something like higher x uh to do an

233
00:07:11,280 --> 00:07:13,360
exponentiation in curve two five five

234
00:07:13,360 --> 00:07:15,440
one nine takes maybe a few tens of

235
00:07:15,440 --> 00:07:17,360
microseconds uh doing a hashing

236
00:07:17,360 --> 00:07:21,360
operation in of 64 bytes uh in

237
00:07:21,360 --> 00:07:22,880
you know using using uh the hash

238
00:07:22,880 --> 00:07:25,120
functions used in the uh

239
00:07:25,120 --> 00:07:26,639
in the live iop implementation of

240
00:07:26,639 --> 00:07:29,520
fractal takes a few tens of nanoseconds

241
00:07:29,520 --> 00:07:30,800
supersonic's a little more challenging

242
00:07:30,800 --> 00:07:31,599
because there isn't a concrete

243
00:07:31,599 --> 00:07:33,759
implementation of it um and there's been

244
00:07:33,759 --> 00:07:35,520
some uh

245
00:07:35,520 --> 00:07:37,440
substantial dispute in the literature uh

246
00:07:37,440 --> 00:07:39,039
about how large the parameters need to

247
00:07:39,039 --> 00:07:40,800
be for a particular concrete security

248
00:07:40,800 --> 00:07:43,199
level for these groups of unknown order

249
00:07:43,199 --> 00:07:46,560
but taking uh the current as best i can

250
00:07:46,560 --> 00:07:48,000
tell best estimates for how large these

251
00:07:48,000 --> 00:07:49,680
parameters need to be you end up with

252
00:07:49,680 --> 00:07:51,039
something where you know you need a few

253
00:07:51,039 --> 00:07:54,319
hundred bytes for an element of gu and

254
00:07:54,319 --> 00:07:56,960
doing an exponentiation racing to an

255
00:07:56,960 --> 00:07:59,199
exponent of 128 bits it's going to take

256
00:07:59,199 --> 00:08:01,680
you a few tens of milliseconds

257
00:08:01,680 --> 00:08:03,039
so

258
00:08:03,039 --> 00:08:04,720
that sort of makes all of this structure

259
00:08:04,720 --> 00:08:06,800
a little more tricky right so uh for

260
00:08:06,800 --> 00:08:08,240
higher x what's the concrete numbers are

261
00:08:08,240 --> 00:08:10,479
pretty good and most of these steps are

262
00:08:10,479 --> 00:08:12,319
fine in practice uh both the size of the

263
00:08:12,319 --> 00:08:14,240
commitments and the verify what to do

264
00:08:14,240 --> 00:08:15,680
the evaluation got to verify the

265
00:08:15,680 --> 00:08:17,199
evaluation proofs are a little larger

266
00:08:17,199 --> 00:08:18,319
than you might like

267
00:08:18,319 --> 00:08:20,960
um for a fractal you know there's uh

268
00:08:20,960 --> 00:08:22,319
there are these straight logs floating

269
00:08:22,319 --> 00:08:24,160
around that you know maybe would be fine

270
00:08:24,160 --> 00:08:25,520
if we really could say three watts of

271
00:08:25,520 --> 00:08:27,680
magnitudes concretely uh and for

272
00:08:27,680 --> 00:08:29,680
supersonic it's it's very challenging to

273
00:08:29,680 --> 00:08:32,479
see how you can concretely deal with the

274
00:08:32,479 --> 00:08:35,839
uh very slow operations in these groups

275
00:08:35,839 --> 00:08:37,919
now i mentioned that fractal would be

276
00:08:37,919 --> 00:08:39,760
resolving iops

277
00:08:39,760 --> 00:08:41,120
great if you could

278
00:08:41,120 --> 00:08:43,200
really get away with using these uh

279
00:08:43,200 --> 00:08:45,440
these concrete constants um but there's

280
00:08:45,440 --> 00:08:47,200
a small asterisk

281
00:08:47,200 --> 00:08:48,720
um which is that

282
00:08:48,720 --> 00:08:50,560
was for things like hydraulics or

283
00:08:50,560 --> 00:08:52,480
supersonic the expected soundness error

284
00:08:52,480 --> 00:08:53,839
of the underlying arguments is very

285
00:08:53,839 --> 00:08:54,640
small

286
00:08:54,640 --> 00:08:56,959
exponentially small uh for resultant

287
00:08:56,959 --> 00:09:00,480
iops the best proved uh

288
00:09:00,480 --> 00:09:02,959
soundness errors are order one and that

289
00:09:02,959 --> 00:09:05,040
means that you end up having to repeat

290
00:09:05,040 --> 00:09:08,080
uh the underlying arguments some large

291
00:09:08,080 --> 00:09:11,200
number of types so uh again the uh lib

292
00:09:11,200 --> 00:09:12,880
iop implementation of fractal if you ask

293
00:09:12,880 --> 00:09:15,519
it to give you 128 bits of security

294
00:09:15,519 --> 00:09:18,160
repeats this item about 500 times so now

295
00:09:18,160 --> 00:09:19,839
that's that's starting to get you know

296
00:09:19,839 --> 00:09:23,839
substantial it makes the uh the apparent

297
00:09:23,839 --> 00:09:25,839
fast concrete constants

298
00:09:25,839 --> 00:09:27,920
not really quite so fast

299
00:09:27,920 --> 00:09:30,800
now obviously uh this is a talk so you

300
00:09:30,800 --> 00:09:32,800
know we've got some some table with all

301
00:09:32,800 --> 00:09:34,880
prior work in it and so now naturally we

302
00:09:34,880 --> 00:09:36,800
introduce what this work do

303
00:09:36,800 --> 00:09:39,360
um so unlike the previous works this is

304
00:09:39,360 --> 00:09:43,519
um it already requires a parenthrap so

305
00:09:43,519 --> 00:09:44,640
concretely all these numbers are going

306
00:09:44,640 --> 00:09:46,800
to be about the bls 12 381

307
00:09:46,800 --> 00:09:49,440
implementation given blasters um

308
00:09:49,440 --> 00:09:50,560
so that's

309
00:09:50,560 --> 00:09:52,560
uh yeah that's what we get uh you'll

310
00:09:52,560 --> 00:09:54,160
note that uh

311
00:09:54,160 --> 00:09:56,880
we get some linear time to commit we get

312
00:09:56,880 --> 00:09:59,760
logarithmic evaluation uh and both the

313
00:09:59,760 --> 00:10:01,760
time taken to do the actual approval

314
00:10:01,760 --> 00:10:03,200
work to

315
00:10:03,200 --> 00:10:04,959
the evaluation or to do the setup are

316
00:10:04,959 --> 00:10:07,440
both square root n which is quite nice

317
00:10:07,440 --> 00:10:11,839
um this 192 bytes to get a uh serialized

318
00:10:11,839 --> 00:10:13,839
gt is a little challenging you need to

319
00:10:13,839 --> 00:10:14,800
go and do

320
00:10:14,800 --> 00:10:16,079
you need to use a few tricks in order to

321
00:10:16,079 --> 00:10:17,279
serialize elements if you see that

322
00:10:17,279 --> 00:10:21,360
efficiently but that's again a proud one

323
00:10:21,519 --> 00:10:22,560
so

324
00:10:22,560 --> 00:10:24,560
what is right well fundamentally it's a

325
00:10:24,560 --> 00:10:26,000
new generalized and product arguments

326
00:10:26,000 --> 00:10:27,600
and so once you compile it down you get

327
00:10:27,600 --> 00:10:30,079
a new equivalent document as well

328
00:10:30,079 --> 00:10:31,519
conceptually it's most similar to

329
00:10:31,519 --> 00:10:33,920
bulletproofs uh or the generalized ipa

330
00:10:33,920 --> 00:10:36,800
of bmn tv 19.

331
00:10:36,800 --> 00:10:38,880
um and you know it's easiest to really

332
00:10:38,880 --> 00:10:40,480
present this from linear polynomials

333
00:10:40,480 --> 00:10:42,240
that's not a fundamental restriction the

334
00:10:42,240 --> 00:10:43,839
paper goes into the details of how you

335
00:10:43,839 --> 00:10:45,760
can handle arbitrary polynomial degree

336
00:10:45,760 --> 00:10:47,680
sequences

337
00:10:47,680 --> 00:10:49,600
so as i said we need a curve for the

338
00:10:49,600 --> 00:10:51,680
pair um and the security assumption

339
00:10:51,680 --> 00:10:53,360
we're going to use is sxdh so what does

340
00:10:53,360 --> 00:10:54,640
that mean it means diffie-hellman in

341
00:10:54,640 --> 00:10:57,040
both source groups uh and it means this

342
00:10:57,040 --> 00:10:59,600
c code is high between g1 and g2 so if

343
00:10:59,600 --> 00:11:01,680
you give me essentially a scale i

344
00:11:01,680 --> 00:11:03,360
specified it as the ratio of the

345
00:11:03,360 --> 00:11:05,360
logarithms of two elements in one group

346
00:11:05,360 --> 00:11:07,360
and you get an element from the second i

347
00:11:07,360 --> 00:11:10,640
can't find uh that second element

348
00:11:10,640 --> 00:11:12,399
element from the second group uh raised

349
00:11:12,399 --> 00:11:13,839
to

350
00:11:13,839 --> 00:11:15,519
baseball scale

351
00:11:15,519 --> 00:11:17,920
um so you know it's a

352
00:11:17,920 --> 00:11:19,440
very crude level what are we actually

353
00:11:19,440 --> 00:11:20,720
going to do inside dory why why is

354
00:11:20,720 --> 00:11:22,160
dorian advance why couldn't you done

355
00:11:22,160 --> 00:11:23,600
dory five years

356
00:11:23,600 --> 00:11:24,399
well

357
00:11:24,399 --> 00:11:27,360
so the the key idea here is that we have

358
00:11:27,360 --> 00:11:28,640
the ability to take structure preserving

359
00:11:28,640 --> 00:11:30,240
compounds

360
00:11:30,240 --> 00:11:32,240
and when we you know in a setup we

361
00:11:32,240 --> 00:11:34,959
sample some polynomial and square root n

362
00:11:34,959 --> 00:11:36,480
uh elements and we're going to compute a

363
00:11:36,480 --> 00:11:37,600
logarithmic number of structure

364
00:11:37,600 --> 00:11:38,880
preservatives

365
00:11:38,880 --> 00:11:40,399
um and those are actually the only

366
00:11:40,399 --> 00:11:41,600
things that verifier is ever going to

367
00:11:41,600 --> 00:11:43,600
use going forward so they have this

368
00:11:43,600 --> 00:11:45,839
algorithmic collection of some parallel

369
00:11:45,839 --> 00:11:47,680
um structure commitments to some

370
00:11:47,680 --> 00:11:49,600
instruction later

371
00:11:49,600 --> 00:11:51,279
um and the verifier is going to use

372
00:11:51,279 --> 00:11:53,120
those in an interesting way so basically

373
00:11:53,120 --> 00:11:56,639
these are uh not just um

374
00:11:56,639 --> 00:11:57,600
when we've done the sampling we've

375
00:11:57,600 --> 00:11:59,200
sampled some generators for some some

376
00:11:59,200 --> 00:12:00,240
other command schemes and we've then

377
00:12:00,240 --> 00:12:01,920
somehow generated commitments to those

378
00:12:01,920 --> 00:12:03,920
commands um the the reason why we do

379
00:12:03,920 --> 00:12:06,160
that is a verifier can offload a bunch

380
00:12:06,160 --> 00:12:07,519
of computations they would always have

381
00:12:07,519 --> 00:12:09,040
to themselves to approve

382
00:12:09,040 --> 00:12:11,200
so in a bulletproof type scheme you

383
00:12:11,200 --> 00:12:12,480
generate some challenges and then at the

384
00:12:12,480 --> 00:12:14,639
end the verify normally has to a linear

385
00:12:14,639 --> 00:12:16,320
time computation

386
00:12:16,320 --> 00:12:17,440
instead we're going to upload that to

387
00:12:17,440 --> 00:12:18,399
the group

388
00:12:18,399 --> 00:12:19,200
um

389
00:12:19,200 --> 00:12:21,440
if you see this in a naive way you get

390
00:12:21,440 --> 00:12:22,320
some

391
00:12:22,320 --> 00:12:24,720
extra some extra plain interest in every

392
00:12:24,720 --> 00:12:26,720
brand bulletproof like folding and so

393
00:12:26,720 --> 00:12:28,079
now even you would have with some like

394
00:12:28,079 --> 00:12:29,839
log squared arguments uh

395
00:12:29,839 --> 00:12:31,200
instead we you know

396
00:12:31,200 --> 00:12:32,720
in some sense do the natural thing we

397
00:12:32,720 --> 00:12:34,079
pull these things together to keep the

398
00:12:34,079 --> 00:12:35,279
number of times constant and that's how

399
00:12:35,279 --> 00:12:38,560
we get to work

400
00:12:38,560 --> 00:12:40,079
now let's go through that in a little

401
00:12:40,079 --> 00:12:41,600
more detail to do that we need to

402
00:12:41,600 --> 00:12:42,560
actually introduce some some

403
00:12:42,560 --> 00:12:44,560
preliminaries first so

404
00:12:44,560 --> 00:12:45,600
first things first we're not going to

405
00:12:45,600 --> 00:12:47,120
worry about hiding if you want to see

406
00:12:47,120 --> 00:12:49,120
how we do that just go into the paper

407
00:12:49,120 --> 00:12:50,480
but fundamentally you know we're just

408
00:12:50,480 --> 00:12:51,279
going to

409
00:12:51,279 --> 00:12:53,200
get hiding um you just add random

410
00:12:53,200 --> 00:12:54,959
multiples of your favorite base point to

411
00:12:54,959 --> 00:12:56,480
everything uh and then you need to do

412
00:12:56,480 --> 00:12:57,839
some like very small number of segment

413
00:12:57,839 --> 00:12:59,200
groups at the end just to prove that you

414
00:12:59,200 --> 00:13:00,959
could open things correctly

415
00:13:00,959 --> 00:13:02,000
um

416
00:13:02,000 --> 00:13:03,200
as a standard we're gonna start with

417
00:13:03,200 --> 00:13:05,440
some public coins verify statistical zk

418
00:13:05,440 --> 00:13:06,880
arguments and you can compile those to

419
00:13:06,880 --> 00:13:08,880
see his narrative there

420
00:13:08,880 --> 00:13:11,040
now nordstrom is actually important and

421
00:13:11,040 --> 00:13:12,079
the way we're going to get that thread

422
00:13:12,079 --> 00:13:13,600
is the women's extent of the emulation

423
00:13:13,600 --> 00:13:15,760
so this is uh again for people who've

424
00:13:15,760 --> 00:13:17,440
seen bullet proofs this is very much how

425
00:13:17,440 --> 00:13:19,360
it's done across the board

426
00:13:19,360 --> 00:13:20,959
so the notion here is that we have some

427
00:13:20,959 --> 00:13:23,120
polynomial large tree

428
00:13:23,120 --> 00:13:24,399
uh where

429
00:13:24,399 --> 00:13:26,240
each of the paths through this tree is

430
00:13:26,240 --> 00:13:27,680
labeled essentially with the transcript

431
00:13:27,680 --> 00:13:29,680
or a potential transcript

432
00:13:29,680 --> 00:13:30,959
of an argument that ends up convincing

433
00:13:30,959 --> 00:13:32,000
to verify

434
00:13:32,000 --> 00:13:32,880
um

435
00:13:32,880 --> 00:13:35,279
and

436
00:13:35,279 --> 00:13:37,519
when they you know if you're given such

437
00:13:37,519 --> 00:13:39,920
a large troop then you can somehow

438
00:13:39,920 --> 00:13:42,160
mechanically go through and extract the

439
00:13:42,160 --> 00:13:44,000
uh awareness now this is quite

440
00:13:44,000 --> 00:13:45,440
convenient because if you have witness

441
00:13:45,440 --> 00:13:47,040
extended emulation for a whole sequence

442
00:13:47,040 --> 00:13:48,240
of arguments and you chain them one

443
00:13:48,240 --> 00:13:49,600
after another then it's very easy to

444
00:13:49,600 --> 00:13:51,360
combine those and say well if each of my

445
00:13:51,360 --> 00:13:52,880
individual reigns have witnessed that

446
00:13:52,880 --> 00:13:55,519
emulation then the whole thing

447
00:13:55,519 --> 00:13:56,639
um

448
00:13:56,639 --> 00:13:58,880
and i mean how we're going to get this

449
00:13:58,880 --> 00:14:01,440
well um the key which we do again and

450
00:14:01,440 --> 00:14:03,760
again in all the proofs um is that we

451
00:14:03,760 --> 00:14:06,079
have some boundary degree or polynomials

452
00:14:06,079 --> 00:14:08,480
in one or two variables um

453
00:14:08,480 --> 00:14:11,040
and from looking at some small tree of

454
00:14:11,040 --> 00:14:13,199
exception transcripts we're able to

455
00:14:13,199 --> 00:14:15,680
argue that uh some polynomial of this

456
00:14:15,680 --> 00:14:18,320
form is zero a large number of places

457
00:14:18,320 --> 00:14:20,480
and then in a completely unconditional

458
00:14:20,480 --> 00:14:22,320
way if it's zero in unlargely places

459
00:14:22,320 --> 00:14:25,199
then it has to be zero uniformly um and

460
00:14:25,199 --> 00:14:27,040
this allows you to then essentially take

461
00:14:27,040 --> 00:14:29,120
some interpolation extract the

462
00:14:29,120 --> 00:14:30,160
underlying coefficients of this

463
00:14:30,160 --> 00:14:32,880
polynomial and use that to build

464
00:14:32,880 --> 00:14:36,160
um witnesses on stage overall

465
00:14:36,160 --> 00:14:37,120
so

466
00:14:37,120 --> 00:14:38,880
you know having having sort of mentioned

467
00:14:38,880 --> 00:14:39,839
all these things

468
00:14:39,839 --> 00:14:41,519
like why can something like already work

469
00:14:41,519 --> 00:14:42,639
in the first place

470
00:14:42,639 --> 00:14:44,320
so you know what's our commitment scheme

471
00:14:44,320 --> 00:14:45,440
it's going to be basically pizza

472
00:14:45,440 --> 00:14:47,199
commitment or um

473
00:14:47,199 --> 00:14:48,480
the generalization of interesting

474
00:14:48,480 --> 00:14:50,399
commitments to working in it by living

475
00:14:50,399 --> 00:14:53,279
assessing which is the uh afghan

476
00:14:53,279 --> 00:14:56,399
which is done by fjord jesus

477
00:14:56,399 --> 00:14:59,440
uh so what's that look like well you

478
00:14:59,440 --> 00:15:00,800
know you pick some

479
00:15:00,800 --> 00:15:03,680
has some generators gamma and some h uh

480
00:15:03,680 --> 00:15:04,880
and if you want to commit some some

481
00:15:04,880 --> 00:15:06,399
vector v then you take the inner product

482
00:15:06,399 --> 00:15:08,880
of the gammas and you add some random

483
00:15:08,880 --> 00:15:10,959
multiple of

484
00:15:10,959 --> 00:15:12,800
for h know written like this this is

485
00:15:12,800 --> 00:15:14,320
just a pieces and comments if you

486
00:15:14,320 --> 00:15:15,680
substitute things incorrectly you can

487
00:15:15,680 --> 00:15:17,920
also get rb commitments out uh you know

488
00:15:17,920 --> 00:15:20,240
picking different um

489
00:15:20,240 --> 00:15:22,079
essentially different modules for where

490
00:15:22,079 --> 00:15:24,800
you're taking camera

491
00:15:24,880 --> 00:15:26,240
so one interesting thing about both

492
00:15:26,240 --> 00:15:28,079
these is their structure preserving so

493
00:15:28,079 --> 00:15:29,360
that means that you know if i have a

494
00:15:29,360 --> 00:15:31,120
commitment to a vector however if i have

495
00:15:31,120 --> 00:15:33,600
two elements two factors i uh multiply

496
00:15:33,600 --> 00:15:35,600
them by scalars i can add them up and so

497
00:15:35,600 --> 00:15:38,880
i have uh f linear operations on my

498
00:15:38,880 --> 00:15:42,320
modules and particularly important for

499
00:15:42,320 --> 00:15:44,959
abe at owl in particular um is that

500
00:15:44,959 --> 00:15:47,279
there is a symmetry between the kind of

501
00:15:47,279 --> 00:15:48,320
thing that you're committing and the

502
00:15:48,320 --> 00:15:50,560
kind of thing that is used to generate

503
00:15:50,560 --> 00:15:51,680
so

504
00:15:51,680 --> 00:15:53,120
a

505
00:15:53,120 --> 00:15:54,399
set of generators that would use for a

506
00:15:54,399 --> 00:15:56,800
commitment to a vector of g1 elements is

507
00:15:56,800 --> 00:15:58,720
a vector of g two elements and vice

508
00:15:58,720 --> 00:15:59,680
versa

509
00:15:59,680 --> 00:16:00,800
um

510
00:16:00,800 --> 00:16:02,480
and that commitment is very small it's

511
00:16:02,480 --> 00:16:04,959
order one so what we can do and what we

512
00:16:04,959 --> 00:16:07,839
do pretty routinely um is that we find

513
00:16:07,839 --> 00:16:10,000
that we have some verified computation

514
00:16:10,000 --> 00:16:12,480
that needs to be done using the public

515
00:16:12,480 --> 00:16:14,560
generators for some components uh and

516
00:16:14,560 --> 00:16:16,560
some other public data

517
00:16:16,560 --> 00:16:18,240
and instead of actually having to verify

518
00:16:18,240 --> 00:16:20,959
do that which you know

519
00:16:20,959 --> 00:16:22,320
the generators might be quite large

520
00:16:22,320 --> 00:16:24,560
because everyone's doing that the uh

521
00:16:24,560 --> 00:16:26,320
verifying the previous have already

522
00:16:26,320 --> 00:16:28,320
computed some commitment to

523
00:16:28,320 --> 00:16:30,079
those generators with respect to a

524
00:16:30,079 --> 00:16:32,079
second set of generators and we're going

525
00:16:32,079 --> 00:16:33,839
to offload the entire computation onto

526
00:16:33,839 --> 00:16:34,959
the group that approve is going to come

527
00:16:34,959 --> 00:16:36,399
and give us an auxiliary argument that

528
00:16:36,399 --> 00:16:38,720
tells us that if we were to have done

529
00:16:38,720 --> 00:16:40,320
this particular operation on this public

530
00:16:40,320 --> 00:16:42,880
data then we would have got the values

531
00:16:42,880 --> 00:16:44,959
um this this can be quite convenient for

532
00:16:44,959 --> 00:16:47,120
us because the commitment is small uh

533
00:16:47,120 --> 00:16:48,160
the

534
00:16:48,160 --> 00:16:49,759
all the data is public the prover can

535
00:16:49,759 --> 00:16:51,440
actually just you know in principle at

536
00:16:51,440 --> 00:16:53,040
least do this

537
00:16:53,040 --> 00:16:55,040
um you can sort of see this as being uh

538
00:16:55,040 --> 00:16:56,399
kind of like computational comments if

539
00:16:56,399 --> 00:16:58,720
you've read the uh spartan paper on uh

540
00:16:58,720 --> 00:17:00,079
which was one of the first places to

541
00:17:00,079 --> 00:17:01,680
really use cleanly to give this

542
00:17:01,680 --> 00:17:03,440
delineation into a information

543
00:17:03,440 --> 00:17:04,959
theoretical part in a computational

544
00:17:04,959 --> 00:17:07,119
polynomial document

545
00:17:07,119 --> 00:17:08,959
so let's dig into the bulletproof level

546
00:17:08,959 --> 00:17:10,880
just so we can have some sense for what

547
00:17:10,880 --> 00:17:13,199
we're doing how it works

548
00:17:13,199 --> 00:17:14,480
so

549
00:17:14,480 --> 00:17:15,679
this is certainly like how i would

550
00:17:15,679 --> 00:17:17,679
present all the proofs if i had to the

551
00:17:17,679 --> 00:17:19,760
notion here is that you really look at

552
00:17:19,760 --> 00:17:20,799
uh

553
00:17:20,799 --> 00:17:22,400
folding an inner product into an inner

554
00:17:22,400 --> 00:17:24,559
product of half the length so on the

555
00:17:24,559 --> 00:17:26,400
right you see we have two vectors a b we

556
00:17:26,400 --> 00:17:28,400
have their inner products we have some

557
00:17:28,400 --> 00:17:30,799
some extra stuff some like alphas and

558
00:17:30,799 --> 00:17:32,480
alpha inverses multiplied by some

559
00:17:32,480 --> 00:17:34,160
seemingly arbitrary things and on the

560
00:17:34,160 --> 00:17:36,640
left we have some like

561
00:17:36,640 --> 00:17:38,000
shorter inner products so here the

562
00:17:38,000 --> 00:17:39,760
notion is that a l and a r are the left

563
00:17:39,760 --> 00:17:41,760
and right halves of vector b l and b are

564
00:17:41,760 --> 00:17:43,280
also the left and right halves of vector

565
00:17:43,280 --> 00:17:45,280
b and if you just take this thing on the

566
00:17:45,280 --> 00:17:46,720
left and multiply it out you find that

567
00:17:46,720 --> 00:17:48,400
you get you know alpha times alpha

568
00:17:48,400 --> 00:17:51,760
inverse a lbl and just a rbi that adds

569
00:17:51,760 --> 00:17:53,679
up to a b

570
00:17:53,679 --> 00:17:54,799
so

571
00:17:54,799 --> 00:17:56,799
why is that useful to us well it means

572
00:17:56,799 --> 00:17:59,360
that if we have uh some claim that we

573
00:17:59,360 --> 00:18:01,760
know what the inner product of amd is

574
00:18:01,760 --> 00:18:03,600
then the approver can actually send he

575
00:18:03,600 --> 00:18:04,400
is

576
00:18:04,400 --> 00:18:06,559
nominal alpha and alpha investors proof

577
00:18:06,559 --> 00:18:07,600
is ultimately going to have to compute

578
00:18:07,600 --> 00:18:10,720
arbl and aldr um and then

579
00:18:10,720 --> 00:18:13,200
the verifier can sample alpha

580
00:18:13,200 --> 00:18:15,280
okay can now uh

581
00:18:15,280 --> 00:18:17,039
you know evaluate

582
00:18:17,039 --> 00:18:19,200
uh this right hand side given the claim

583
00:18:19,200 --> 00:18:20,960
about what a b is and these claims about

584
00:18:20,960 --> 00:18:23,120
aibl and albr and they end up with some

585
00:18:23,120 --> 00:18:24,960
claim about some inner product half-life

586
00:18:24,960 --> 00:18:26,960
factors

587
00:18:26,960 --> 00:18:29,280
uh and if you sort of inspect this there

588
00:18:29,280 --> 00:18:30,720
are no comments here but if you just

589
00:18:30,720 --> 00:18:32,799
sort of think about uh you know given

590
00:18:32,799 --> 00:18:34,480
this these facts as a prime b prime for

591
00:18:34,480 --> 00:18:37,039
a variety of alpha and values of alpha

592
00:18:37,039 --> 00:18:39,600
uh you can interpolate and extract out

593
00:18:39,600 --> 00:18:40,799
what ale and

594
00:18:40,799 --> 00:18:43,760
all

595
00:18:48,960 --> 00:18:50,400
so what's this call well you know if you

596
00:18:50,400 --> 00:18:51,600
started with some factor of length 2 to

597
00:18:51,600 --> 00:18:52,960
the m you could run this

598
00:18:52,960 --> 00:18:55,280
m times with some challenges uh and he

599
00:18:55,280 --> 00:18:56,480
would ultimately end up with some claim

600
00:18:56,480 --> 00:18:58,880
about two length one vexed skateboards

601
00:18:58,880 --> 00:18:59,840
um

602
00:18:59,840 --> 00:19:01,440
and some you know claim for their what

603
00:19:01,440 --> 00:19:03,280
their product is and that you can prove

604
00:19:03,280 --> 00:19:05,919
with a standard second proof

605
00:19:05,919 --> 00:19:07,520
um

606
00:19:07,520 --> 00:19:09,679
so look at this you know you end up

607
00:19:09,679 --> 00:19:11,520
finding that there are these these two

608
00:19:11,520 --> 00:19:13,200
vectors um

609
00:19:13,200 --> 00:19:16,160
of scalars uh which are being got by uh

610
00:19:16,160 --> 00:19:17,520
taking the chronicle products of a whole

611
00:19:17,520 --> 00:19:19,600
bunch of short vectors you know a one

612
00:19:19,600 --> 00:19:21,600
one a two one and a one inverse one a

613
00:19:21,600 --> 00:19:24,320
two in this one um

614
00:19:24,320 --> 00:19:25,679
and like the final claim you'll end up

615
00:19:25,679 --> 00:19:28,320
having is that the final product y finn

616
00:19:28,320 --> 00:19:31,919
uh is this this bizarre product of an

617
00:19:31,919 --> 00:19:33,120
inner product of

618
00:19:33,120 --> 00:19:34,320
uh

619
00:19:34,320 --> 00:19:36,960
of x plus with a and explains with b

620
00:19:36,960 --> 00:19:38,480
now

621
00:19:38,480 --> 00:19:40,799
why this you know this is

622
00:19:40,799 --> 00:19:42,240
you know so far so it's so irritating

623
00:19:42,240 --> 00:19:43,520
like this is this is not really uh

624
00:19:43,520 --> 00:19:44,559
working with commitments or anything

625
00:19:44,559 --> 00:19:46,799
else so suppose you wanted to you know

626
00:19:46,799 --> 00:19:48,799
somehow take this kind of argument such

627
00:19:48,799 --> 00:19:50,000
as this and turn it into something that

628
00:19:50,000 --> 00:19:52,240
works with

629
00:19:52,240 --> 00:19:53,039
well

630
00:19:53,039 --> 00:19:55,840
uh you would fix some generators ml 1

631
00:19:55,840 --> 00:19:58,400
and gamma 2 for commitments to

632
00:19:58,400 --> 00:20:00,640
activate 1 v2 and the proof would be

633
00:20:00,640 --> 00:20:02,400
claiming to know these vectors and

634
00:20:02,400 --> 00:20:03,840
following the same kind of problem

635
00:20:03,840 --> 00:20:05,760
procedure and just keeping track of what

636
00:20:05,760 --> 00:20:08,880
you know um you would end up reducing to

637
00:20:08,880 --> 00:20:10,720
some claim that approving those two

638
00:20:10,720 --> 00:20:12,640
particular elements v1 prime v2 prime

639
00:20:12,640 --> 00:20:14,080
such that their product is one

640
00:20:14,080 --> 00:20:16,720
particular thing and the product of v1

641
00:20:16,720 --> 00:20:18,480
with x minus

642
00:20:18,480 --> 00:20:20,880
inner product gamma 2 is something and x

643
00:20:20,880 --> 00:20:22,400
plus inner product with gamma 1

644
00:20:22,400 --> 00:20:24,240
multiplied by v2 is something else so

645
00:20:24,240 --> 00:20:25,360
these are sort of like the commitments

646
00:20:25,360 --> 00:20:27,600
you have to evaluate to the end

647
00:20:27,600 --> 00:20:29,440
and then you know finally what would

648
00:20:29,440 --> 00:20:31,120
prove to do again if you don't care

649
00:20:31,120 --> 00:20:32,240
about zero knowledge you're hiding you

650
00:20:32,240 --> 00:20:33,679
know the proof could just send you b1

651
00:20:33,679 --> 00:20:36,240
prime v2 prime uh and the verifier has

652
00:20:36,240 --> 00:20:38,720
to then go and check these uh these

653
00:20:38,720 --> 00:20:40,880
inner products of these probably factors

654
00:20:40,880 --> 00:20:43,120
of x with these public vectors gamma and

655
00:20:43,120 --> 00:20:45,200
gamma 2.

656
00:20:45,200 --> 00:20:47,039
now naturally this is still order n for

657
00:20:47,039 --> 00:20:48,480
the for the verifier which is a level

658
00:20:48,480 --> 00:20:50,320
drop link um

659
00:20:50,320 --> 00:20:51,679
in the context of polynomials there are

660
00:20:51,679 --> 00:20:53,679
some tricks you can use to really

661
00:20:53,679 --> 00:20:56,559
split the um split polynomial

662
00:20:56,559 --> 00:20:58,320
evaluation into a into a matrix product

663
00:20:58,320 --> 00:21:00,320
so this is what hydrax does uh this

664
00:21:00,320 --> 00:21:02,080
basically means you only need to do some

665
00:21:02,080 --> 00:21:04,080
sort of square root n work and but you

666
00:21:04,080 --> 00:21:05,360
do actually send some sort of square

667
00:21:05,360 --> 00:21:08,000
root of recommends around

668
00:21:08,000 --> 00:21:10,480
so you know let's first like dig into

669
00:21:10,480 --> 00:21:12,240
this a little bit further you know we

670
00:21:12,240 --> 00:21:13,600
have something here which is is

671
00:21:13,600 --> 00:21:15,280
logarithmic

672
00:21:15,280 --> 00:21:17,919
but for the fact that right at the end

673
00:21:17,919 --> 00:21:19,280
verifier has to do this apparently

674
00:21:19,280 --> 00:21:21,360
linear type occupation

675
00:21:21,360 --> 00:21:23,280
uh between some public vector scales and

676
00:21:23,280 --> 00:21:25,919
some public vector of generators so you

677
00:21:25,919 --> 00:21:28,080
know how could we try and offload this

678
00:21:28,080 --> 00:21:30,000
well we go back to thinking about what

679
00:21:30,000 --> 00:21:32,320
the what the structure of these uh

680
00:21:32,320 --> 00:21:34,240
scalars are so we have this vector

681
00:21:34,240 --> 00:21:36,880
scalar x plus say uh and that's been

682
00:21:36,880 --> 00:21:38,080
constructed as a kind of product like

683
00:21:38,080 --> 00:21:40,240
this and so you know if we split gamma

684
00:21:40,240 --> 00:21:42,240
one into a left path and radar then what

685
00:21:42,240 --> 00:21:43,919
you'll end up finding is that this inner

686
00:21:43,919 --> 00:21:46,799
product of s x plus with gamma one is

687
00:21:46,799 --> 00:21:48,799
some uh inner product of a slightly

688
00:21:48,799 --> 00:21:52,159
shorter vector x uh plus prime say it's

689
00:21:52,159 --> 00:21:55,840
the product from uh at one up to a m one

690
00:21:55,840 --> 00:21:57,280
with this

691
00:21:57,280 --> 00:21:59,840
alternate factor on the right like um

692
00:21:59,840 --> 00:22:01,120
half of my gamble went out and scanned

693
00:22:01,120 --> 00:22:03,760
one up so this is a shorter shorter

694
00:22:03,760 --> 00:22:04,720
product

695
00:22:04,720 --> 00:22:05,840
um

696
00:22:05,840 --> 00:22:07,520
and you might have got here so what like

697
00:22:07,520 --> 00:22:08,960
this is it's slightly shorter than a

698
00:22:08,960 --> 00:22:10,320
broker you saw it's all in here in

699
00:22:10,320 --> 00:22:12,320
length um but you can afford this to

700
00:22:12,320 --> 00:22:13,919
prove it so

701
00:22:13,919 --> 00:22:15,760
if the verifier knew

702
00:22:15,760 --> 00:22:17,600
some pre-computed commitments to gamma

703
00:22:17,600 --> 00:22:19,120
one l and gamma one r with respect to

704
00:22:19,120 --> 00:22:21,760
some arbitrary other generators then you

705
00:22:21,760 --> 00:22:23,039
could combine those commitments and that

706
00:22:23,039 --> 00:22:24,640
would give you a commitment to this this

707
00:22:24,640 --> 00:22:26,080
right hand part this alpha one camera

708
00:22:26,080 --> 00:22:28,000
one l plus camera one r

709
00:22:28,000 --> 00:22:28,960
um

710
00:22:28,960 --> 00:22:31,039
and x plus doesn't matter but you know

711
00:22:31,039 --> 00:22:33,520
it turns out that uh that's fine because

712
00:22:33,520 --> 00:22:34,960
it's big structures chronic products you

713
00:22:34,960 --> 00:22:36,080
want you need to keep track of these

714
00:22:36,080 --> 00:22:37,520
logarithmic number of scales you never

715
00:22:37,520 --> 00:22:39,440
actually have to instantiate x

716
00:22:39,440 --> 00:22:41,039
um

717
00:22:41,039 --> 00:22:42,240
and

718
00:22:42,240 --> 00:22:44,640
it you know sort of as a corollary that

719
00:22:44,640 --> 00:22:45,760
it turns out that you can take the inner

720
00:22:45,760 --> 00:22:48,000
products of uh vectors that are built up

721
00:22:48,000 --> 00:22:49,440
with critical products and short vectors

722
00:22:49,440 --> 00:22:52,559
in in the logarithmic time

723
00:22:52,559 --> 00:22:54,559
so what's this so tell me you're telling

724
00:22:54,559 --> 00:22:56,480
me that if you tried to sort of offload

725
00:22:56,480 --> 00:22:59,600
this right hand the inner product of x x

726
00:22:59,600 --> 00:23:02,000
plus prime uh with alpha one gamma one l

727
00:23:02,000 --> 00:23:04,720
plus gamma one r uh to the prover that

728
00:23:04,720 --> 00:23:06,240
you know after some logarithmic matter

729
00:23:06,240 --> 00:23:07,600
works you would be able to half the

730
00:23:07,600 --> 00:23:09,760
length and then you'd have a half length

731
00:23:09,760 --> 00:23:12,080
generalization product to prove again

732
00:23:12,080 --> 00:23:13,919
try doing it again

733
00:23:13,919 --> 00:23:14,960
um

734
00:23:14,960 --> 00:23:16,720
and you know to do this you need to be

735
00:23:16,720 --> 00:23:18,080
able to recurse but you can recurse

736
00:23:18,080 --> 00:23:20,080
because commitments elements of g1 are

737
00:23:20,080 --> 00:23:21,200
given by

738
00:23:21,200 --> 00:23:23,440
factors in g2 and commitments to

739
00:23:23,440 --> 00:23:24,320
uh

740
00:23:24,320 --> 00:23:26,559
g2 were given by vectors in g1

741
00:23:26,559 --> 00:23:27,440
so

742
00:23:27,440 --> 00:23:28,640
you just did this naively you end up

743
00:23:28,640 --> 00:23:30,400
with some log squared precise and

744
00:23:30,400 --> 00:23:32,960
verified compute which is a good

745
00:23:32,960 --> 00:23:34,720
operator

746
00:23:34,720 --> 00:23:36,080
we can have a little further than that

747
00:23:36,080 --> 00:23:37,840
so you know we can combine these things

748
00:23:37,840 --> 00:23:39,679
so again just

749
00:23:39,679 --> 00:23:42,240
an equality about inappropriate factors

750
00:23:42,240 --> 00:23:44,480
uh is that if you have uh

751
00:23:44,480 --> 00:23:47,039
four vectors a b c d uh then if you

752
00:23:47,039 --> 00:23:49,520
combine a and c with some beta and some

753
00:23:49,520 --> 00:23:52,000
b and d with the beta then you get uh

754
00:23:52,000 --> 00:23:53,200
some

755
00:23:53,200 --> 00:23:54,640
you know some nonsense uh but you know

756
00:23:54,640 --> 00:23:56,080
when you look at this you see that abe

757
00:23:56,080 --> 00:23:58,320
shows up as uh the beta independent term

758
00:23:58,320 --> 00:24:00,559
and cd shows up as the b square term and

759
00:24:00,559 --> 00:24:02,000
then the only thing that's left is this

760
00:24:02,000 --> 00:24:03,600
beta

761
00:24:03,600 --> 00:24:05,600
you can if the if the approval wants to

762
00:24:05,600 --> 00:24:06,799
claim that they know

763
00:24:06,799 --> 00:24:09,600
some abcd with given enterprise s u then

764
00:24:09,600 --> 00:24:11,600
you know the crypto contenders crosstalk

765
00:24:11,600 --> 00:24:13,440
just some claim for it the verifier can

766
00:24:13,440 --> 00:24:15,279
sample these are uniformly at random and

767
00:24:15,279 --> 00:24:16,640
and uh

768
00:24:16,640 --> 00:24:18,320
then require the proof of your knowledge

769
00:24:18,320 --> 00:24:20,720
of vectors whose inner product is s plus

770
00:24:20,720 --> 00:24:22,559
b to t because b squared here and again

771
00:24:22,559 --> 00:24:24,559
like in exactly the same way

772
00:24:24,559 --> 00:24:25,600
if the proof can do this for a whole

773
00:24:25,600 --> 00:24:27,120
bunch of beta then

774
00:24:27,120 --> 00:24:28,960
you can interpolate out uh that they

775
00:24:28,960 --> 00:24:30,880
must have had these vectors and the

776
00:24:30,880 --> 00:24:33,279
uh the verify can reconstruct those

777
00:24:33,279 --> 00:24:34,480
fixes

778
00:24:34,480 --> 00:24:35,760
so

779
00:24:35,760 --> 00:24:36,799
this is interesting because it means

780
00:24:36,799 --> 00:24:38,480
that if i've got two inner products that

781
00:24:38,480 --> 00:24:39,679
i want to keep

782
00:24:39,679 --> 00:24:41,200
uh then there's some sort of two to one

783
00:24:41,200 --> 00:24:42,559
reduction so if the prover has two

784
00:24:42,559 --> 00:24:43,919
columns they can reduce them tomorrow

785
00:24:43,919 --> 00:24:46,159
and some slightly probable

786
00:24:46,159 --> 00:24:47,200
and you know if the vectors are

787
00:24:47,200 --> 00:24:48,720
committed then the verifier is actually

788
00:24:48,720 --> 00:24:50,880
going to have some commitments here and

789
00:24:50,880 --> 00:24:52,400
they're going to have to do

790
00:24:52,400 --> 00:24:53,679
so you're going to have to have some

791
00:24:53,679 --> 00:24:56,000
commitments uh to be inappropriate and

792
00:24:56,000 --> 00:24:58,240
maybe a commitment to the cnt and just

793
00:24:58,240 --> 00:25:00,320
do this linear combination uh that's

794
00:25:00,320 --> 00:25:02,960
before it will be fine

795
00:25:02,960 --> 00:25:04,320
so

796
00:25:04,320 --> 00:25:05,360
so

797
00:25:05,360 --> 00:25:06,880
what does this look like in practice

798
00:25:06,880 --> 00:25:08,159
well

799
00:25:08,159 --> 00:25:10,720
if we take uh what would have previously

800
00:25:10,720 --> 00:25:12,080
been an inner product between two

801
00:25:12,080 --> 00:25:13,440
committed axes and we run one round of

802
00:25:13,440 --> 00:25:15,840
bulletproofs on it so we've just done a

803
00:25:15,840 --> 00:25:18,080
simple simple halving of the lens

804
00:25:18,080 --> 00:25:20,320
then we have some

805
00:25:20,320 --> 00:25:23,760
u1 which is this uh combination from the

806
00:25:23,760 --> 00:25:26,000
the generators like gamma one and some

807
00:25:26,000 --> 00:25:27,919
u2 which is a combination of the

808
00:25:27,919 --> 00:25:29,600
generator counter too

809
00:25:29,600 --> 00:25:32,400
uh the claim is that the verifier

810
00:25:32,400 --> 00:25:33,919
uh so that should be the proven the

811
00:25:33,919 --> 00:25:36,400
proof is let's know so c prime uh so

812
00:25:36,400 --> 00:25:38,400
verify no c for n d prime is d prime

813
00:25:38,400 --> 00:25:40,480
since s um

814
00:25:40,480 --> 00:25:41,760
such that

815
00:25:41,760 --> 00:25:43,440
you have these five clips so essentially

816
00:25:43,440 --> 00:25:45,679
the uh c has been replaced by c prime

817
00:25:45,679 --> 00:25:47,360
because we have sort of half the length

818
00:25:47,360 --> 00:25:48,720
um

819
00:25:48,720 --> 00:25:50,880
and these u1 u2

820
00:25:50,880 --> 00:25:53,440
are these folded generators so in this

821
00:25:53,440 --> 00:25:55,919
case the verifier is able to compute f1

822
00:25:55,919 --> 00:25:58,159
and f2 because they know

823
00:25:58,159 --> 00:26:00,240
uh commitments of gamma 1 l gamma 1 r

824
00:26:00,240 --> 00:26:02,080
gamma 2 l gamma 2

825
00:26:02,080 --> 00:26:04,480
and uh c prime d one prime t prime comes

826
00:26:04,480 --> 00:26:06,480
straight out of the bullet proof

827
00:26:06,480 --> 00:26:08,080
so you've got five claims you want

828
00:26:08,080 --> 00:26:10,480
somehow reduce them uh you can always

829
00:26:10,480 --> 00:26:12,320
just do this in the most native way the

830
00:26:12,320 --> 00:26:14,080
proverb can make additional claims about

831
00:26:14,080 --> 00:26:15,840
the cross terms uh

832
00:26:15,840 --> 00:26:18,159
the verifier can pre-compute

833
00:26:18,159 --> 00:26:19,840
some of these some of these questions if

834
00:26:19,840 --> 00:26:22,400
they're purely about public data

835
00:26:22,400 --> 00:26:24,240
and then that means you can combine

836
00:26:24,240 --> 00:26:26,240
those claims about c prime d one prime

837
00:26:26,240 --> 00:26:27,919
and d prime

838
00:26:27,919 --> 00:26:29,520
uh and update all the numbers as

839
00:26:29,520 --> 00:26:31,600
appropriate

840
00:26:31,600 --> 00:26:34,480
this would give you a lot size proof um

841
00:26:34,480 --> 00:26:36,640
and corollary give you logarithmic

842
00:26:36,640 --> 00:26:38,159
graphite computation the constant's

843
00:26:38,159 --> 00:26:39,520
horrible they're like 20 or 30

844
00:26:39,520 --> 00:26:41,840
operations per round it's it's quite bad

845
00:26:41,840 --> 00:26:44,480
um so you know

846
00:26:44,480 --> 00:26:47,039
what is dory story is this but like

847
00:26:47,039 --> 00:26:48,720
slightly pronounced so that we have

848
00:26:48,720 --> 00:26:50,559
placed more concrete constants

849
00:26:50,559 --> 00:26:51,440
so

850
00:26:51,440 --> 00:26:53,039
very concretely this is this will be the

851
00:26:53,039 --> 00:26:55,840
only special line of crimson filming um

852
00:26:55,840 --> 00:26:57,840
what is the dory reduction so this is

853
00:26:57,840 --> 00:27:00,159
the analog of the of the volatile threat

854
00:27:00,159 --> 00:27:03,360
of the bulletproof reduction

855
00:27:04,640 --> 00:27:05,760
so

856
00:27:05,760 --> 00:27:07,679
we start with proof of knowing some v1

857
00:27:07,679 --> 00:27:09,760
and g1m v2 and p2m

858
00:27:09,760 --> 00:27:13,200
uh such that you know that uh

859
00:27:13,200 --> 00:27:14,880
their inner product is c

860
00:27:14,880 --> 00:27:16,799
uh the commitment of v1 is d1 and the

861
00:27:16,799 --> 00:27:20,399
commitments of g2 is up to v2 is t2

862
00:27:20,399 --> 00:27:22,159
so the first thing that prover actually

863
00:27:22,159 --> 00:27:26,080
is going to do is they're going to uh

864
00:27:28,159 --> 00:27:29,120
first thing the proof is actually going

865
00:27:29,120 --> 00:27:30,960
to do is they're going to send

866
00:27:30,960 --> 00:27:31,840
some

867
00:27:31,840 --> 00:27:34,000
commitments to the left and right halves

868
00:27:34,000 --> 00:27:35,679
of v1 and to the left and right halves

869
00:27:35,679 --> 00:27:37,679
of v2 with respect to some new all

870
00:27:37,679 --> 00:27:39,679
singing all that's in generators

871
00:27:39,679 --> 00:27:40,960
and the verifier is going to sample some

872
00:27:40,960 --> 00:27:42,799
pizza this is formerly doing exactly

873
00:27:42,799 --> 00:27:44,880
what peter was doing a few slides ago

874
00:27:44,880 --> 00:27:47,360
and the proof was going to update v1 and

875
00:27:47,360 --> 00:27:50,880
v2 by adding some multiples of gamma 1 2

876
00:27:50,880 --> 00:27:53,520
with with these directions

877
00:27:53,520 --> 00:27:55,200
and then once that happened uh the proof

878
00:27:55,200 --> 00:27:56,320
was going to send a whole bunch of cross

879
00:27:56,320 --> 00:27:57,279
terms

880
00:27:57,279 --> 00:27:58,080
so

881
00:27:58,080 --> 00:28:01,200
these these new modified v1s b2s what's

882
00:28:01,200 --> 00:28:02,880
their cross-product across turn between

883
00:28:02,880 --> 00:28:04,480
the left class and the red dots and

884
00:28:04,480 --> 00:28:05,919
verify effects and alpha and now the

885
00:28:05,919 --> 00:28:07,679
proof it does this folding operation so

886
00:28:07,679 --> 00:28:09,760
v1 get is replaced by alpha times its

887
00:28:09,760 --> 00:28:11,360
left half versus right half and vice

888
00:28:11,360 --> 00:28:13,760
versa v2

889
00:28:13,760 --> 00:28:15,440
uh and what's to verify how to do well

890
00:28:15,440 --> 00:28:17,360
they have to do these slightly messy

891
00:28:17,360 --> 00:28:19,840
looking computations in order to update

892
00:28:19,840 --> 00:28:22,480
c prime d1 prime d2 prime uh you'll

893
00:28:22,480 --> 00:28:25,039
notice that d1 and l1 and d2l and other

894
00:28:25,039 --> 00:28:26,240
commitments that were sent in the first

895
00:28:26,240 --> 00:28:27,600
stage are really only being used to

896
00:28:27,600 --> 00:28:29,360
construct new commandments the

897
00:28:29,360 --> 00:28:31,440
u cross term is constructed entirely

898
00:28:31,440 --> 00:28:33,440
from the old cross term the old

899
00:28:33,440 --> 00:28:36,399
commitments uh d1 d2 and these these

900
00:28:36,399 --> 00:28:39,679
cross terms c plus and c minus

901
00:28:39,679 --> 00:28:41,919
now this looks a little bit messy uh

902
00:28:41,919 --> 00:28:43,520
some sense it is when you look at this

903
00:28:43,520 --> 00:28:45,360
in detail you find that there are six

904
00:28:45,360 --> 00:28:47,840
gts being sent to each round uh

905
00:28:47,840 --> 00:28:50,080
and if you take this verify from the end

906
00:28:50,080 --> 00:28:52,399
and you do usual tricks to defer it out

907
00:28:52,399 --> 00:28:54,080
then there are only nine exponentiations

908
00:28:54,080 --> 00:28:56,480
program

909
00:28:56,480 --> 00:28:58,880
so at the end of this there's some claim

910
00:28:58,880 --> 00:29:01,200
that the prover knows v1 prime v2 prime

911
00:29:01,200 --> 00:29:02,720
both of half the length they work for

912
00:29:02,720 --> 00:29:05,440
such that you know c prime d prime and c

913
00:29:05,440 --> 00:29:07,279
prime is a commitment to the inner

914
00:29:07,279 --> 00:29:09,679
product and d1 and d2 prime server

915
00:29:09,679 --> 00:29:11,200
connects today

916
00:29:11,200 --> 00:29:13,120
to the half-life vectors with respect to

917
00:29:13,120 --> 00:29:15,120
the generators so you'll notice this is

918
00:29:15,120 --> 00:29:17,200
exactly lining up with the initial stage

919
00:29:17,200 --> 00:29:19,279
of derivatives but with m replaced by n

920
00:29:19,279 --> 00:29:21,440
over two so we can iterate it uh and

921
00:29:21,440 --> 00:29:23,840
then you know once we get into n this is

922
00:29:23,840 --> 00:29:24,880
something which you have to prove with

923
00:29:24,880 --> 00:29:27,360
that slightly irritating but essentially

924
00:29:27,360 --> 00:29:29,760
straightforward

925
00:29:30,080 --> 00:29:31,039
so

926
00:29:31,039 --> 00:29:33,279
now that we sort of sketch this out

927
00:29:33,279 --> 00:29:34,480
you know this is

928
00:29:34,480 --> 00:29:36,240
interesting i mean this is a some sort

929
00:29:36,240 --> 00:29:38,720
of uh inner product arguments in a sense

930
00:29:38,720 --> 00:29:40,880
but it's not um generalized in full

931
00:29:40,880 --> 00:29:42,960
right we're relying here on v1 and v2

932
00:29:42,960 --> 00:29:45,279
being in g1 g2 um

933
00:29:45,279 --> 00:29:47,120
and it's certainly not a problem

934
00:29:47,120 --> 00:29:49,440
so you know in the interest of of some

935
00:29:49,440 --> 00:29:51,120
time um

936
00:29:51,120 --> 00:29:54,559
you know we'll we'll uh defer most of

937
00:29:54,559 --> 00:29:57,440
this to the paper uh so you know what we

938
00:29:57,440 --> 00:29:58,960
fundamentally do well we add some public

939
00:29:58,960 --> 00:30:01,600
effects of scalars s1 and s2 so it's

940
00:30:01,600 --> 00:30:03,120
basically just adding some more

941
00:30:03,120 --> 00:30:05,600
enterprise between v1 and s2 and v2 and

942
00:30:05,600 --> 00:30:06,880
s1

943
00:30:06,880 --> 00:30:09,039
um and actually we're going to prove a

944
00:30:09,039 --> 00:30:10,240
full segment of

945
00:30:10,240 --> 00:30:12,000
this form so

946
00:30:12,000 --> 00:30:14,240
uh vectors in g1 and g2 and electro

947
00:30:14,240 --> 00:30:16,480
scalars and two vector scales prove

948
00:30:16,480 --> 00:30:18,159
everything um

949
00:30:18,159 --> 00:30:19,120
for

950
00:30:19,120 --> 00:30:21,279
general vectors s1 s2 there's

951
00:30:21,279 --> 00:30:22,720
very little way to do this in less than

952
00:30:22,720 --> 00:30:23,679
any time because you actually have to

953
00:30:23,679 --> 00:30:26,159
read these as part of the statement um

954
00:30:26,159 --> 00:30:27,840
but for polynomial commitments it'll

955
00:30:27,840 --> 00:30:30,480
turn out that s1 and s2 again have this

956
00:30:30,480 --> 00:30:31,600
very explicit chronicle product

957
00:30:31,600 --> 00:30:33,440
structure and already specified by a

958
00:30:33,440 --> 00:30:37,159
logarithmic number of

959
00:30:41,919 --> 00:30:43,279
but it is convenient to do it with the

960
00:30:43,279 --> 00:30:44,880
two-tier trek the same sort of way the

961
00:30:44,880 --> 00:30:47,919
higher acts or uh the ones that will do

962
00:30:47,919 --> 00:30:50,240
uh so here the notion to replace the

963
00:30:50,240 --> 00:30:52,159
evaluation of f as in point x with some

964
00:30:52,159 --> 00:30:54,159
product of a vector on the left and a

965
00:30:54,159 --> 00:30:56,480
vector on the right with some matrix m

966
00:30:56,480 --> 00:30:58,159
uh where these left and right vectors

967
00:30:58,159 --> 00:30:59,600
are both the length of x squared n

968
00:30:59,600 --> 00:31:02,000
that's kind of convenient

969
00:31:02,000 --> 00:31:02,799
um

970
00:31:02,799 --> 00:31:04,559
and again what's convenient about this

971
00:31:04,559 --> 00:31:07,279
particularly for us is that uh

972
00:31:07,279 --> 00:31:09,200
this directly codes up as one and a

973
00:31:09,200 --> 00:31:11,519
product in g1 one and products in g2 and

974
00:31:11,519 --> 00:31:13,840
across term uh which means we get a half

975
00:31:13,840 --> 00:31:16,080
number of rams

976
00:31:16,080 --> 00:31:16,960
and

977
00:31:16,960 --> 00:31:18,159
sort of in the same way that we're able

978
00:31:18,159 --> 00:31:19,600
to batch individual inner products it

979
00:31:19,600 --> 00:31:21,279
turns out you can track that through the

980
00:31:21,279 --> 00:31:23,120
entire process so we can do batching at

981
00:31:23,120 --> 00:31:24,960
every possible size um this is

982
00:31:24,960 --> 00:31:26,000
particularly nice because it means that

983
00:31:26,000 --> 00:31:28,320
if we uh find a guesswork polynomial we

984
00:31:28,320 --> 00:31:30,480
have some batch of them uh the marginal

985
00:31:30,480 --> 00:31:31,760
cost of doing

986
00:31:31,760 --> 00:31:32,960
one more

987
00:31:32,960 --> 00:31:34,799
uh for the verifier at least is just a

988
00:31:34,799 --> 00:31:37,440
one exponentiations and uh a logarithmic

989
00:31:37,440 --> 00:31:39,600
number of field operations

990
00:31:39,600 --> 00:31:41,360
for the proof assembly it's a

991
00:31:41,360 --> 00:31:43,279
square root n uh

992
00:31:43,279 --> 00:31:46,159
to do it it's basically straightforward

993
00:31:46,159 --> 00:31:47,440
though so there are various entry

994
00:31:47,440 --> 00:31:50,559
optimizations to this um first

995
00:31:50,559 --> 00:31:53,360
as i mentioned uh

996
00:31:53,360 --> 00:31:55,120
the argument with public schools is

997
00:31:55,120 --> 00:31:56,480
actually giving two

998
00:31:56,480 --> 00:31:59,279
generalized enterprise at the same time

999
00:31:59,279 --> 00:32:00,880
and that's convenient it turns out that

1000
00:32:00,880 --> 00:32:02,880
you had to do again one small extra

1001
00:32:02,880 --> 00:32:04,720
signal protocol just to

1002
00:32:04,720 --> 00:32:06,720
be able to transfer from a commitment to

1003
00:32:06,720 --> 00:32:08,799
g2 through to

1004
00:32:08,799 --> 00:32:10,799
something that's committing to a vector

1005
00:32:10,799 --> 00:32:13,600
but this is basically

1006
00:32:13,600 --> 00:32:15,440
also as i mentioned way back at the

1007
00:32:15,440 --> 00:32:17,840
start uh we do some optimizations for

1008
00:32:17,840 --> 00:32:20,159
serialization of gt um for something

1009
00:32:20,159 --> 00:32:24,559
like the bls 12381 curve gt is naively

1010
00:32:24,559 --> 00:32:27,360
naively is some element of fp to 12. so

1011
00:32:27,360 --> 00:32:29,600
this gt would be

1012
00:32:29,600 --> 00:32:32,399
12 scales to encode um it turns out that

1013
00:32:32,399 --> 00:32:34,320
you can get that answer for scalars by

1014
00:32:34,320 --> 00:32:37,200
just a little bit of work um and the

1015
00:32:37,200 --> 00:32:38,559
formula are actually pretty quite nice

1016
00:32:38,559 --> 00:32:41,519
they're generic but essentially

1017
00:32:41,519 --> 00:32:42,799
of the standard pairing friendly

1018
00:32:42,799 --> 00:32:44,000
families

1019
00:32:44,000 --> 00:32:45,519
um this also conveniently gives you a

1020
00:32:45,519 --> 00:32:47,039
very fast double information

1021
00:32:47,039 --> 00:32:47,840
which

1022
00:32:47,840 --> 00:32:49,679
it's it's good for

1023
00:32:49,679 --> 00:32:51,279
i think recollection says it was good

1024
00:32:51,279 --> 00:32:53,200
for 30 or 40 percent uh speed ups on

1025
00:32:53,200 --> 00:32:54,559
verify

1026
00:32:54,559 --> 00:32:55,919
and then we do the usual tricks you're

1027
00:32:55,919 --> 00:32:57,519
going to batch all depends though your

1028
00:32:57,519 --> 00:33:00,559
exponentiations combine every verified

1029
00:33:00,559 --> 00:33:01,840
check that has happened with some

1030
00:33:01,840 --> 00:33:04,080
independent scalars um

1031
00:33:04,080 --> 00:33:05,760
on the previous slide we do a certain

1032
00:33:05,760 --> 00:33:08,159
amount of work because uh it will turn

1033
00:33:08,159 --> 00:33:10,960
out the polynomial members in particular

1034
00:33:10,960 --> 00:33:13,200
this

1035
00:33:13,440 --> 00:33:16,080
sorry for the

1036
00:33:19,440 --> 00:33:21,279
yeah we'll turn up for the polynomial

1037
00:33:21,279 --> 00:33:24,480
commitments in particular uh that

1038
00:33:24,480 --> 00:33:25,600
the

1039
00:33:25,600 --> 00:33:28,080
substance of the proof of computation uh

1040
00:33:28,080 --> 00:33:29,840
is that they have to do

1041
00:33:29,840 --> 00:33:31,760
uh many multi-exponentiations with

1042
00:33:31,760 --> 00:33:33,440
respect to the same base points they

1043
00:33:33,440 --> 00:33:36,080
have essentially uh something like n

1044
00:33:36,080 --> 00:33:37,760
scalars and some vector of length

1045
00:33:37,760 --> 00:33:40,640
through 10 and for each uh for each root

1046
00:33:40,640 --> 00:33:42,559
n scales in this thing they need to

1047
00:33:42,559 --> 00:33:46,399
multiply by the same um same factor

1048
00:33:46,399 --> 00:33:48,240
uh so what's the implementation of this

1049
00:33:48,240 --> 00:33:50,240
look like well we're based on blasters

1050
00:33:50,240 --> 00:33:51,440
which is a fast thrust library for the

1051
00:33:51,440 --> 00:33:53,440
bls 12 threading one curve uh internally

1052
00:33:53,440 --> 00:33:55,360
that's on some c back end

1053
00:33:55,360 --> 00:33:58,159
um the baseline that we compared to was

1054
00:33:58,159 --> 00:34:00,159
the apollo movement

1055
00:34:00,159 --> 00:34:02,720
that's implicit in sparsely which is uh

1056
00:34:02,720 --> 00:34:04,240
optimized the relative of the scheme in

1057
00:34:04,240 --> 00:34:06,960
hyrax based on co25519 dalek which is a

1058
00:34:06,960 --> 00:34:09,918
very fast implementation of 550 online

1059
00:34:09,918 --> 00:34:11,760
uh to do this it was about 1600 lines of

1060
00:34:11,760 --> 00:34:13,440
code blasters to do the tour space

1061
00:34:13,440 --> 00:34:15,199
serialization gt and to completely

1062
00:34:15,199 --> 00:34:17,199
implement the paper implementation to

1063
00:34:17,199 --> 00:34:19,280
really support

1064
00:34:19,280 --> 00:34:22,079
these like very large multi-explanations

1065
00:34:22,079 --> 00:34:23,839
um and then it's about another 3 400

1066
00:34:23,839 --> 00:34:26,239
lines of code

1067
00:34:26,239 --> 00:34:27,359
so

1068
00:34:27,359 --> 00:34:29,839
what's the performance like well

1069
00:34:29,839 --> 00:34:31,119
in a lot of ways it's sort of what you

1070
00:34:31,119 --> 00:34:33,119
would expect so uh the prover you know

1071
00:34:33,119 --> 00:34:35,599
it turns out that the dominant cost is

1072
00:34:35,599 --> 00:34:38,639
order n operations in g1 well

1073
00:34:38,639 --> 00:34:41,918
in g1 d1 in blasters in

1074
00:34:41,918 --> 00:34:45,440
mbls 12 381 is a bit slower than uh the

1075
00:34:45,440 --> 00:34:47,199
curve 25.519 is but that's essentially a

1076
00:34:47,199 --> 00:34:49,839
constant factor as we can see um

1077
00:34:49,839 --> 00:34:51,599
the evaluation proof that the size of

1078
00:34:51,599 --> 00:34:54,079
the evaluation proves similarly um it's

1079
00:34:54,079 --> 00:34:55,599
logarithmic in both cases the constants

1080
00:34:55,599 --> 00:34:57,599
are a little bit worse where should be

1081
00:34:57,599 --> 00:34:59,680
worshipping a couple of elements of gt

1082
00:34:59,680 --> 00:35:01,599
per round whereas in spartan you get to

1083
00:35:01,599 --> 00:35:04,320
send only two elements of g which again

1084
00:35:04,320 --> 00:35:05,440
still small because the scale is

1085
00:35:05,440 --> 00:35:06,640
different

1086
00:35:06,640 --> 00:35:08,320
uh where things get really interesting

1087
00:35:08,320 --> 00:35:09,839
however is the size of the commitments

1088
00:35:09,839 --> 00:35:11,680
and the time it takes for the verifier

1089
00:35:11,680 --> 00:35:14,160
to evaluate

1090
00:35:14,160 --> 00:35:15,040
so

1091
00:35:15,040 --> 00:35:17,200
the commitment size for us is constant

1092
00:35:17,200 --> 00:35:18,960
whereas for something like hyrax it goes

1093
00:35:18,960 --> 00:35:20,960
like square root 10 um and our

1094
00:35:20,960 --> 00:35:22,480
verification is logarithmic rather than

1095
00:35:22,480 --> 00:35:24,079
square root so the crossover point here

1096
00:35:24,079 --> 00:35:26,400
is about 2 to the 22 it depends a little

1097
00:35:26,400 --> 00:35:27,760
on on

1098
00:35:27,760 --> 00:35:29,520
concrete machine performance

1099
00:35:29,520 --> 00:35:32,000
um and as you can see the evaluations

1100
00:35:32,000 --> 00:35:34,000
are concretely slower

1101
00:35:34,000 --> 00:35:35,760
uh across the board

1102
00:35:35,760 --> 00:35:37,440
but actually it turns out that you know

1103
00:35:37,440 --> 00:35:38,720
at least for large things you know two

1104
00:35:38,720 --> 00:35:40,640
to 22 to 24

1105
00:35:40,640 --> 00:35:43,040
this starts to disappear essentially the

1106
00:35:43,040 --> 00:35:44,800
linear cost of just evaluating the

1107
00:35:44,800 --> 00:35:46,000
polynomial once starts to become

1108
00:35:46,000 --> 00:35:47,040
dominant

1109
00:35:47,040 --> 00:35:49,200
and the cryptography kind of fades into

1110
00:35:49,200 --> 00:35:50,560
background

1111
00:35:50,560 --> 00:35:53,040
what's been pretty interesting for

1112
00:35:53,040 --> 00:35:54,400
applications

1113
00:35:54,400 --> 00:35:57,280
is how we behave on the matching so

1114
00:35:57,280 --> 00:35:59,119
here this is you're showing some data

1115
00:35:59,119 --> 00:36:01,520
with a straightforward linear affair so

1116
00:36:01,520 --> 00:36:04,960
uh what is the you know what are they

1117
00:36:04,960 --> 00:36:06,640
the concrete times and essentially but

1118
00:36:06,640 --> 00:36:08,000
for a lot of absolute sizes we find that

1119
00:36:08,000 --> 00:36:10,000
it takes the approver well under a

1120
00:36:10,000 --> 00:36:12,480
second for nsu 20 to generate one more

1121
00:36:12,480 --> 00:36:14,400
proof this is uh most kind of order of

1122
00:36:14,400 --> 00:36:15,839
magnitude better than it would be

1123
00:36:15,839 --> 00:36:18,320
naively um the size of the proof

1124
00:36:18,320 --> 00:36:19,839
similarly is reduced by about an order

1125
00:36:19,839 --> 00:36:20,800
of packet

1126
00:36:20,800 --> 00:36:22,400
um and for

1127
00:36:22,400 --> 00:36:23,119
uh

1128
00:36:23,119 --> 00:36:26,560
for the verifier again we save quite

1129
00:36:26,560 --> 00:36:28,240
substantially

1130
00:36:28,240 --> 00:36:30,800
uh so concretely we end up pushing down

1131
00:36:30,800 --> 00:36:32,960
close to one millisecond of proof uh

1132
00:36:32,960 --> 00:36:34,960
which is competitive with some um at

1133
00:36:34,960 --> 00:36:37,200
least in this large patch context is

1134
00:36:37,200 --> 00:36:39,280
competitive with

1135
00:36:39,280 --> 00:36:40,480
which intellectual

1136
00:36:40,480 --> 00:36:42,000
stronger assumptions

1137
00:36:42,000 --> 00:36:45,040
so i mean very true summary

1138
00:36:45,040 --> 00:36:46,400
story seems to be an interesting view in

1139
00:36:46,400 --> 00:36:48,560
a product document uh obviously it can

1140
00:36:48,560 --> 00:36:50,560
be integrated into other systems to make

1141
00:36:50,560 --> 00:36:53,839
case numbers um and that's so that's

1142
00:36:53,839 --> 00:36:55,200
essentially it

1143
00:36:55,200 --> 00:36:58,598
thank you very much

