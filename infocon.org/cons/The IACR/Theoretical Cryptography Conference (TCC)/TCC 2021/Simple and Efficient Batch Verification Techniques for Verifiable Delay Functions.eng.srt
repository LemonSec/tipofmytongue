1
00:00:00,719 --> 00:00:03,520
hi i'm lior and this is a talk about

2
00:00:03,520 --> 00:00:05,120
simple and efficient batterification

3
00:00:05,120 --> 00:00:06,640
techniques for verifiable delay

4
00:00:06,640 --> 00:00:08,000
functions

5
00:00:08,000 --> 00:00:09,760
so let's start by defining delay

6
00:00:09,760 --> 00:00:11,280
functions and then talk about

7
00:00:11,280 --> 00:00:12,799
verifiability

8
00:00:12,799 --> 00:00:14,639
roughly speaking a delay function is a

9
00:00:14,639 --> 00:00:16,720
function which is efficiently computable

10
00:00:16,720 --> 00:00:18,400
but only in a manner which is inherited

11
00:00:18,400 --> 00:00:19,840
sequential

12
00:00:19,840 --> 00:00:21,279
one way to capture this is by

13
00:00:21,279 --> 00:00:23,600
introducing the delay parameter t

14
00:00:23,600 --> 00:00:25,279
then the function should be computable

15
00:00:25,279 --> 00:00:27,359
on every input in some time polynomial

16
00:00:27,359 --> 00:00:30,560
in t so for example 40 or t squared but

17
00:00:30,560 --> 00:00:32,079
on the other hand it should not be

18
00:00:32,079 --> 00:00:33,840
possible to evaluate the function on a

19
00:00:33,840 --> 00:00:36,239
randomly chosen input in time less than

20
00:00:36,239 --> 00:00:38,640
t even with preprocessing and many

21
00:00:38,640 --> 00:00:41,200
parallel processors

22
00:00:41,200 --> 00:00:43,760
a verifiable delay function or vdf for

23
00:00:43,760 --> 00:00:45,840
short is a delay function which allows

24
00:00:45,840 --> 00:00:47,600
for fast verification

25
00:00:47,600 --> 00:00:49,920
so when computing the output f x of the

26
00:00:49,920 --> 00:00:51,920
function on input x it should be

27
00:00:51,920 --> 00:00:53,840
possible to produce alongside the output

28
00:00:53,840 --> 00:00:55,760
a short proof pi asserting the validity

29
00:00:55,760 --> 00:00:57,360
of this output

30
00:00:57,360 --> 00:01:00,480
then given x f x and pi

31
00:01:00,480 --> 00:01:02,719
one can verify that f of x is indeed the

32
00:01:02,719 --> 00:01:04,879
output of the function on input x and

33
00:01:04,879 --> 00:01:06,640
this verification should be much quicker

34
00:01:06,640 --> 00:01:09,040
than computing the function and u

35
00:01:09,040 --> 00:01:10,799
though this is a recent notion

36
00:01:10,799 --> 00:01:12,720
vdfs have proven to be extremely useful

37
00:01:12,720 --> 00:01:15,119
for a wide array of applications so just

38
00:01:15,119 --> 00:01:16,960
to name a few we have time-based proofs

39
00:01:16,960 --> 00:01:19,119
of replication verifiable randomness

40
00:01:19,119 --> 00:01:21,360
beacons computational timestamping

41
00:01:21,360 --> 00:01:23,439
resource-efficient blockchains and much

42
00:01:23,439 --> 00:01:25,119
more

43
00:01:25,119 --> 00:01:26,560
the main candidates that we currently

44
00:01:26,560 --> 00:01:28,560
have for vdfs are based on the repeated

45
00:01:28,560 --> 00:01:30,560
squaring delay function put forth by

46
00:01:30,560 --> 00:01:33,759
rivest chameleon wagner back in 96.

47
00:01:33,759 --> 00:01:35,439
this function is defined with respect to

48
00:01:35,439 --> 00:01:37,200
a cryptographic group g

49
00:01:37,200 --> 00:01:39,680
and on input x the output is x raised to

50
00:01:39,680 --> 00:01:41,840
the power of 2 to the t

51
00:01:41,840 --> 00:01:43,360
the fact that this is indeed the delay

52
00:01:43,360 --> 00:01:45,759
function is based on the assumption that

53
00:01:45,759 --> 00:01:47,200
there are groups in which this

54
00:01:47,200 --> 00:01:48,960
computation cannot be significantly

55
00:01:48,960 --> 00:01:51,439
speed up even with preprocessing and the

56
00:01:51,439 --> 00:01:54,479
polynomial number of parallel processors

57
00:01:54,479 --> 00:01:56,479
it's not hard to see that for this

58
00:01:56,479 --> 00:01:58,560
assumption to be plausible in some group

59
00:01:58,560 --> 00:02:00,000
it should be hard to compute the group's

60
00:02:00,000 --> 00:02:02,399
order from its representation

61
00:02:02,399 --> 00:02:04,000
we currently have two main family of

62
00:02:04,000 --> 00:02:06,159
candidates for such groups

63
00:02:06,159 --> 00:02:08,479
the first is the family of rsa groups

64
00:02:08,479 --> 00:02:11,520
and specific subgroups of rsa groups

65
00:02:11,520 --> 00:02:13,200
for this family of groups a recent

66
00:02:13,200 --> 00:02:16,080
result of gilsage and myself showed an

67
00:02:16,080 --> 00:02:18,080
equivalence in the generic ring model

68
00:02:18,080 --> 00:02:19,840
between the sequentiality of repeated

69
00:02:19,840 --> 00:02:22,959
querying and the factoring assumption

70
00:02:22,959 --> 00:02:24,800
the second candidate family of groups is

71
00:02:24,800 --> 00:02:26,480
the family of class groups of imaginary

72
00:02:26,480 --> 00:02:28,959
quadratic number fields

73
00:02:28,959 --> 00:02:30,959
indeed several works starting with the

74
00:02:30,959 --> 00:02:32,959
works of piezza and vezolovsky

75
00:02:32,959 --> 00:02:35,040
constructed vdfs based on the repeated

76
00:02:35,040 --> 00:02:36,800
squaring delay function

77
00:02:36,800 --> 00:02:38,640
the basic idea in all of them is to

78
00:02:38,640 --> 00:02:40,400
augment this function with efficient

79
00:02:40,400 --> 00:02:42,640
proofs of correct exponentiation on

80
00:02:42,640 --> 00:02:45,680
which we will focus later in this talk

81
00:02:45,680 --> 00:02:47,599
now in some scenarios

82
00:02:47,599 --> 00:02:49,760
one might need to verify not just one

83
00:02:49,760 --> 00:02:52,720
but many vdf outputs at the same time

84
00:02:52,720 --> 00:02:54,959
as an example consider verifying using

85
00:02:54,959 --> 00:02:57,920
vdf based proof of replication that some

86
00:02:57,920 --> 00:03:00,159
storage service maintains many copies of

87
00:03:00,159 --> 00:03:01,840
the same file

88
00:03:01,840 --> 00:03:04,000
or verifying the randomness generated by

89
00:03:04,000 --> 00:03:06,319
some vdf based randomness beacon over

90
00:03:06,319 --> 00:03:08,319
many epochs

91
00:03:08,319 --> 00:03:10,400
the naive solution is to simply use the

92
00:03:10,400 --> 00:03:12,319
per instance verification procedure of

93
00:03:12,319 --> 00:03:15,120
the vdf and to verify the outputs one by

94
00:03:15,120 --> 00:03:16,400
one

95
00:03:16,400 --> 00:03:18,159
the downside of this approach of course

96
00:03:18,159 --> 00:03:20,159
is that it incurs a blow up in both the

97
00:03:20,159 --> 00:03:22,319
proof size and the verification time

98
00:03:22,319 --> 00:03:24,159
which is linear in the number of outputs

99
00:03:24,159 --> 00:03:25,920
to be verified

100
00:03:25,920 --> 00:03:27,760
the question is can we do better than

101
00:03:27,760 --> 00:03:29,200
that

102
00:03:29,200 --> 00:03:31,360
before going back to verification of pdf

103
00:03:31,360 --> 00:03:33,599
outputs i want to take a little detour

104
00:03:33,599 --> 00:03:35,360
and to talk about the related work from

105
00:03:35,360 --> 00:03:38,480
over 20 years ago by belarus and robin

106
00:03:38,480 --> 00:03:40,239
that deals with batterification of

107
00:03:40,239 --> 00:03:42,879
exponentiations but in cyclic groups of

108
00:03:42,879 --> 00:03:44,560
prime order

109
00:03:44,560 --> 00:03:46,560
so the setting is the following

110
00:03:46,560 --> 00:03:50,159
we have n exponents x1 to xn and n group

111
00:03:50,159 --> 00:03:52,720
elements h1 to hn

112
00:03:52,720 --> 00:03:55,280
and we wish to verify that h i is equal

113
00:03:55,280 --> 00:03:57,920
to g raised to the power of x i for each

114
00:03:57,920 --> 00:03:59,680
index i and for a publicly known

115
00:03:59,680 --> 00:04:01,920
generator g of the group

116
00:04:01,920 --> 00:04:04,000
belargar and rabin presented several

117
00:04:04,000 --> 00:04:05,280
batching techniques to solve this

118
00:04:05,280 --> 00:04:07,680
problem and some of their ideas are

119
00:04:07,680 --> 00:04:09,599
actually implicit in some of the recent

120
00:04:09,599 --> 00:04:11,680
works even on single instance video

121
00:04:11,680 --> 00:04:13,760
verification

122
00:04:13,760 --> 00:04:15,920
explicitly observe this connection and

123
00:04:15,920 --> 00:04:17,839
build upon it for the sake of

124
00:04:17,839 --> 00:04:19,918
batterification of pdfs

125
00:04:19,918 --> 00:04:21,759
but in order to do so we need to

126
00:04:21,759 --> 00:04:23,840
overcome two issues

127
00:04:23,840 --> 00:04:25,600
the first is that they consider the

128
00:04:25,600 --> 00:04:28,000
setting with no additional proofs all

129
00:04:28,000 --> 00:04:30,240
you have are the xi's and the agis and

130
00:04:30,240 --> 00:04:31,759
you want to verify that they indeed

131
00:04:31,759 --> 00:04:34,000
satisfy a certain relation

132
00:04:34,000 --> 00:04:36,240
in the vdf setting we are in a setting

133
00:04:36,240 --> 00:04:38,320
of an external prover proving that the

134
00:04:38,320 --> 00:04:40,880
shared input satisfies some relation

135
00:04:40,880 --> 00:04:42,960
so we also need to account for the proof

136
00:04:42,960 --> 00:04:44,880
length or the communication complexity

137
00:04:44,880 --> 00:04:47,440
in the interactive setting

138
00:04:47,440 --> 00:04:49,280
the second issue is that the more

139
00:04:49,280 --> 00:04:52,160
efficient procedure of bgl relies on the

140
00:04:52,160 --> 00:04:54,560
group being of prime order which is not

141
00:04:54,560 --> 00:04:55,840
the case for the candidates that we

142
00:04:55,840 --> 00:04:57,520
currently have for groups of unknown

143
00:04:57,520 --> 00:04:59,120
auto

144
00:04:59,120 --> 00:05:01,680
going back to vdfs vesilowski in an

145
00:05:01,680 --> 00:05:03,759
update to his original work already

146
00:05:03,759 --> 00:05:05,520
presented the batch version of his proof

147
00:05:05,520 --> 00:05:07,280
of correct exponentiation

148
00:05:07,280 --> 00:05:09,759
so this batch protocol implicitly relies

149
00:05:09,759 --> 00:05:12,240
on ideas from vgr and instead of

150
00:05:12,240 --> 00:05:13,919
producing a separate proof for each

151
00:05:13,919 --> 00:05:16,320
output it produces a single shorter

152
00:05:16,320 --> 00:05:18,560
proof for all outputs which is also

153
00:05:18,560 --> 00:05:20,479
quicker to verify

154
00:05:20,479 --> 00:05:22,400
unfortunately this batch protocol was

155
00:05:22,400 --> 00:05:24,479
presented not as a modular compiler that

156
00:05:24,479 --> 00:05:25,840
works with any proof of correct

157
00:05:25,840 --> 00:05:28,320
exponentiation but rather as a direct

158
00:05:28,320 --> 00:05:30,320
generalization of zelowsky's single

159
00:05:30,320 --> 00:05:32,400
instance protocol

160
00:05:32,400 --> 00:05:34,160
the more serious issue is that this

161
00:05:34,160 --> 00:05:36,160
protocol is proven secure based on the

162
00:05:36,160 --> 00:05:38,639
adaptive route assumption this is not an

163
00:05:38,639 --> 00:05:40,080
issue when compared to vezilovski's

164
00:05:40,080 --> 00:05:42,000
single instance protocol since it

165
00:05:42,000 --> 00:05:44,240
already relies on this assumption

166
00:05:44,240 --> 00:05:46,479
however the adaptive route assumption is

167
00:05:46,479 --> 00:05:48,160
stronger than those needed to prove the

168
00:05:48,160 --> 00:05:50,840
security of other proofs of correct

169
00:05:50,840 --> 00:05:53,280
exponentiation the soundness of beatax

170
00:05:53,280 --> 00:05:55,039
protocol is based on the low order

171
00:05:55,039 --> 00:05:56,960
assumption which is seemingly weaker

172
00:05:56,960 --> 00:05:59,360
than the adaptive root assumption

173
00:05:59,360 --> 00:06:01,600
and moreover a very recent work by

174
00:06:01,600 --> 00:06:04,639
blockatal modifies psx protocol and

175
00:06:04,639 --> 00:06:06,400
obtains an information theoretically

176
00:06:06,400 --> 00:06:09,120
sound proof of correct exponentiation

177
00:06:09,120 --> 00:06:11,199
so this raises the question of whether

178
00:06:11,199 --> 00:06:12,639
we can apply the techniques from the

179
00:06:12,639 --> 00:06:14,800
zelowski's batch protocol to these

180
00:06:14,800 --> 00:06:16,400
protocols as well

181
00:06:16,400 --> 00:06:18,080
and must we introduce additional

182
00:06:18,080 --> 00:06:21,360
assumptions in order to do so

183
00:06:21,360 --> 00:06:23,360
so what we do in this work is to present

184
00:06:23,360 --> 00:06:25,120
general and modular batch verification

185
00:06:25,120 --> 00:06:27,199
techniques for vdfs that are based on a

186
00:06:27,199 --> 00:06:29,120
proof of correct exponentiation or a

187
00:06:29,120 --> 00:06:30,800
poce for short

188
00:06:30,800 --> 00:06:32,800
first of all we define soundness notions

189
00:06:32,800 --> 00:06:34,639
for patch pocs

190
00:06:34,639 --> 00:06:36,960
and then we present two compilers that

191
00:06:36,960 --> 00:06:39,919
take any single instance poc and compile

192
00:06:39,919 --> 00:06:42,160
it into a batch plc

193
00:06:42,160 --> 00:06:44,000
the first compiler doesn't make any

194
00:06:44,000 --> 00:06:46,240
group specific assumptions and can be

195
00:06:46,240 --> 00:06:48,720
applied in any group and the second

196
00:06:48,720 --> 00:06:51,280
compiler has better parameters but it

197
00:06:51,280 --> 00:06:53,120
relies on the low order assumption that

198
00:06:53,120 --> 00:06:55,599
we will describe later in the talk

199
00:06:55,599 --> 00:06:57,599
both of these compilers extend the ideas

200
00:06:57,599 --> 00:06:59,840
of bgr to the vdf setting

201
00:06:59,840 --> 00:07:01,759
and improve on the naive approach for

202
00:07:01,759 --> 00:07:03,440
batch verification that we described

203
00:07:03,440 --> 00:07:04,720
before

204
00:07:04,720 --> 00:07:06,720
additionally we also have two specific

205
00:07:06,720 --> 00:07:08,720
protocols in rsi groups where the

206
00:07:08,720 --> 00:07:10,319
modulus is the product of two safe

207
00:07:10,319 --> 00:07:11,440
primes

208
00:07:11,440 --> 00:07:13,680
first as we will discuss the low order

209
00:07:13,680 --> 00:07:15,680
assumption doesn't hold in these groups

210
00:07:15,680 --> 00:07:17,440
so we show how to extend the second

211
00:07:17,440 --> 00:07:19,759
compiler to these groups as well

212
00:07:19,759 --> 00:07:21,919
and secondly to complete the picture we

213
00:07:21,919 --> 00:07:24,160
present a single instance poc which is

214
00:07:24,160 --> 00:07:25,919
information theoretically sound in these

215
00:07:25,919 --> 00:07:27,440
groups

216
00:07:27,440 --> 00:07:29,039
this is a table summarizing the

217
00:07:29,039 --> 00:07:31,440
parameters achieved by our compilers

218
00:07:31,440 --> 00:07:33,280
let's assume that we want to verify n

219
00:07:33,280 --> 00:07:34,400
instances

220
00:07:34,400 --> 00:07:36,880
and we start with a single instance poce

221
00:07:36,880 --> 00:07:39,360
with proof size lpi and verification

222
00:07:39,360 --> 00:07:41,199
time t pi

223
00:07:41,199 --> 00:07:43,039
in this case the naive solution gives

224
00:07:43,039 --> 00:07:45,520
you a proof of size n times l pi and

225
00:07:45,520 --> 00:07:48,400
verification time n times t pi

226
00:07:48,400 --> 00:07:50,800
our compiler in general groups gives you

227
00:07:50,800 --> 00:07:53,680
a proof of size lambda times l pi and

228
00:07:53,680 --> 00:07:57,520
verification time lambda times n times t

229
00:07:57,520 --> 00:07:59,360
g plus t pi

230
00:07:59,360 --> 00:08:01,599
where lambda is the security parameter

231
00:08:01,599 --> 00:08:04,080
and tg is the time it takes to compute

232
00:08:04,080 --> 00:08:05,919
the group operation in the underlying

233
00:08:05,919 --> 00:08:07,440
group

234
00:08:07,440 --> 00:08:09,360
our improved compiler which is based on

235
00:08:09,360 --> 00:08:11,280
the low order assumption doesn't add

236
00:08:11,280 --> 00:08:12,960
anything to the proof size

237
00:08:12,960 --> 00:08:15,440
and its verification time is n times

238
00:08:15,440 --> 00:08:19,280
lambda times tg plus t pi

239
00:08:19,280 --> 00:08:21,680
note that in both of our compilers the

240
00:08:21,680 --> 00:08:23,759
proof size is completely independent of

241
00:08:23,759 --> 00:08:26,879
the number n of instances to be verified

242
00:08:26,879 --> 00:08:29,039
when it comes to verification time there

243
00:08:29,039 --> 00:08:31,680
is still a linear dependence on n

244
00:08:31,680 --> 00:08:33,919
but it is decoupled from the dependence

245
00:08:33,919 --> 00:08:36,000
on the verification time t pi of the

246
00:08:36,000 --> 00:08:38,000
underlying poc

247
00:08:38,000 --> 00:08:40,640
so even if the poce is very expensive in

248
00:08:40,640 --> 00:08:43,279
terms of verification time we still only

249
00:08:43,279 --> 00:08:45,920
pay for it essentially once and not once

250
00:08:45,920 --> 00:08:48,720
per every vdf output

251
00:08:48,720 --> 00:08:50,880
now it should be mentioned that vdf

252
00:08:50,880 --> 00:08:52,959
proofs for repeated querying are

253
00:08:52,959 --> 00:08:54,480
typically obtained by applying the

254
00:08:54,480 --> 00:08:56,480
feature mirroristic to an interactive

255
00:08:56,480 --> 00:08:58,240
protocol

256
00:08:58,240 --> 00:08:59,760
if one doesn't want to assume the

257
00:08:59,760 --> 00:09:02,399
soundness of yhamil our compilers can be

258
00:09:02,399 --> 00:09:04,880
instantiated as an additional message to

259
00:09:04,880 --> 00:09:07,279
the underlying interactive protocol

260
00:09:07,279 --> 00:09:08,959
and in this case the communication

261
00:09:08,959 --> 00:09:10,640
complexity and verification time are

262
00:09:10,640 --> 00:09:12,880
essentially those listed on the slide

263
00:09:12,880 --> 00:09:14,480
and we will see this in more detail

264
00:09:14,480 --> 00:09:16,320
later on

265
00:09:16,320 --> 00:09:18,160
so the talk outline from now on is the

266
00:09:18,160 --> 00:09:19,279
following

267
00:09:19,279 --> 00:09:22,240
we'll start by defining batch pocs

268
00:09:22,240 --> 00:09:24,720
then we'll present our two compilers

269
00:09:24,720 --> 00:09:26,480
and we'll move on to talk about our

270
00:09:26,480 --> 00:09:28,880
protocols in cef prime's rsa groups and

271
00:09:28,880 --> 00:09:30,640
then we'll conclude

272
00:09:30,640 --> 00:09:34,399
so let's start by defining batch pocs

273
00:09:34,399 --> 00:09:36,800
first we'll define single instance poc

274
00:09:36,800 --> 00:09:39,120
is and the setting is this

275
00:09:39,120 --> 00:09:41,519
we have some underlying group g

276
00:09:41,519 --> 00:09:44,080
two group elements x and y and an

277
00:09:44,080 --> 00:09:45,920
exponent e

278
00:09:45,920 --> 00:09:47,440
the prover wishes to convince the

279
00:09:47,440 --> 00:09:50,160
verifier that y is equal to x raised to

280
00:09:50,160 --> 00:09:51,920
the power of e

281
00:09:51,920 --> 00:09:54,320
so a poce is a possibly interactive

282
00:09:54,320 --> 00:09:56,880
protocol between the two parties and the

283
00:09:56,880 --> 00:09:58,800
completeness requirement is that if

284
00:09:58,800 --> 00:10:01,519
indeed y is equal to x to the e then the

285
00:10:01,519 --> 00:10:04,800
verifier accepts with probability 1.

286
00:10:04,800 --> 00:10:06,640
security is captured by the delta

287
00:10:06,640 --> 00:10:08,079
soundness property

288
00:10:08,079 --> 00:10:10,640
which states that if y is not equal to x

289
00:10:10,640 --> 00:10:11,600
to the e

290
00:10:11,600 --> 00:10:13,600
then the probability of acceptance is

291
00:10:13,600 --> 00:10:15,760
bounded by delta plus some negligible

292
00:10:15,760 --> 00:10:17,200
function of the security parameter

293
00:10:17,200 --> 00:10:18,640
lambda

294
00:10:18,640 --> 00:10:20,160
in the paper we actually consider an

295
00:10:20,160 --> 00:10:22,399
adaptive notion of soundness allowing

296
00:10:22,399 --> 00:10:25,200
the malicious prover to choose x y and e

297
00:10:25,200 --> 00:10:26,800
but for ease of presentation we'll

298
00:10:26,800 --> 00:10:30,240
forget about adaptivity in this talk

299
00:10:30,240 --> 00:10:32,079
now obviously this completeness and

300
00:10:32,079 --> 00:10:33,680
soundness properties are trivial to

301
00:10:33,680 --> 00:10:35,760
satisfy on their own by simply having

302
00:10:35,760 --> 00:10:38,800
the verifier compute x to the e

303
00:10:38,800 --> 00:10:41,680
so the non-triviality of pocs is that

304
00:10:41,680 --> 00:10:43,440
the running time of the verifier needs

305
00:10:43,440 --> 00:10:45,200
to be much shorter than the time

306
00:10:45,200 --> 00:10:48,399
required for this trivial verification

307
00:10:48,399 --> 00:10:50,320
as mentioned before a non-interactive

308
00:10:50,320 --> 00:10:52,480
poc can be obtained from an interactive

309
00:10:52,480 --> 00:10:55,519
poc using the fiat amir transform and

310
00:10:55,519 --> 00:10:57,680
this is of course assuming that this poc

311
00:10:57,680 --> 00:11:00,160
is indeed compatible with chamier as is

312
00:11:00,160 --> 00:11:02,880
the case for existing pocs

313
00:11:02,880 --> 00:11:05,680
in a batch poc we have amperes of group

314
00:11:05,680 --> 00:11:07,839
elements and the prover tries to

315
00:11:07,839 --> 00:11:10,560
convince the verifier that y i is equal

316
00:11:10,560 --> 00:11:12,640
to x i raised to the power of e for

317
00:11:12,640 --> 00:11:15,760
every i as before if this is indeed the

318
00:11:15,760 --> 00:11:18,000
case the verifier should accept with

319
00:11:18,000 --> 00:11:19,519
probability 1

320
00:11:19,519 --> 00:11:21,839
and the delta soundness requirement is

321
00:11:21,839 --> 00:11:23,680
that if this is not the case then the

322
00:11:23,680 --> 00:11:25,680
verifier accepts with probability at

323
00:11:25,680 --> 00:11:27,839
most delta plus some negligible function

324
00:11:27,839 --> 00:11:30,720
of the security parameter lambda

325
00:11:30,720 --> 00:11:32,720
now in the batch setting we want to

326
00:11:32,720 --> 00:11:34,399
achieve verification time which is

327
00:11:34,399 --> 00:11:36,720
non-trivial and not only with respect to

328
00:11:36,720 --> 00:11:38,399
verifying the statement by direct

329
00:11:38,399 --> 00:11:39,680
computation

330
00:11:39,680 --> 00:11:41,279
but also with respect to the naive

331
00:11:41,279 --> 00:11:43,200
approach that simply applies a separate

332
00:11:43,200 --> 00:11:46,800
poc to each pair xi yi

333
00:11:46,800 --> 00:11:48,800
we also want the overall communication

334
00:11:48,800 --> 00:11:51,760
to be non-trivial in the same respect

335
00:11:51,760 --> 00:11:54,560
as before a non-interactive batch plc

336
00:11:54,560 --> 00:11:56,560
can be obtained from an interactive one

337
00:11:56,560 --> 00:11:58,720
using the fiat mule transform

338
00:11:58,720 --> 00:12:01,279
and as we will see all of our compilers

339
00:12:01,279 --> 00:12:04,800
preserve compatibility with viachamil

340
00:12:04,800 --> 00:12:06,480
we can now move on to considerable

341
00:12:06,480 --> 00:12:07,680
compilers

342
00:12:07,680 --> 00:12:09,760
and as a warm-up consider the following

343
00:12:09,760 --> 00:12:12,959
simple compiler for transforming a poc

344
00:12:12,959 --> 00:12:17,200
pi with delta soundness into a batch poc

345
00:12:17,200 --> 00:12:19,519
first the verifier sends to the prover a

346
00:12:19,519 --> 00:12:22,160
uniformly random subset i of the indices

347
00:12:22,160 --> 00:12:23,600
from 1 to n

348
00:12:23,600 --> 00:12:26,079
both parties then locally compute x

349
00:12:26,079 --> 00:12:28,639
prime which is the product of all the x

350
00:12:28,639 --> 00:12:32,079
i's for little i in the subset capital i

351
00:12:32,079 --> 00:12:35,600
and y prime which is defined similarly

352
00:12:35,600 --> 00:12:38,160
then the part is simply execute the poc

353
00:12:38,160 --> 00:12:41,279
pi on the joint input x prime y prime

354
00:12:41,279 --> 00:12:42,399
and e

355
00:12:42,399 --> 00:12:44,880
this is the entire compiler

356
00:12:44,880 --> 00:12:46,720
the main observation underlying the

357
00:12:46,720 --> 00:12:48,959
soundness guarantee of this compiler is

358
00:12:48,959 --> 00:12:51,920
that if y i is not equal to x i to the e

359
00:12:51,920 --> 00:12:53,120
for sum i

360
00:12:53,120 --> 00:12:55,440
then the probability that y prime is

361
00:12:55,440 --> 00:12:57,680
equal to x prime to the e is at most one

362
00:12:57,680 --> 00:12:58,800
half

363
00:12:58,800 --> 00:13:00,639
this immediately implies that the

364
00:13:00,639 --> 00:13:03,440
compiler yields a batch poce which is

365
00:13:03,440 --> 00:13:06,160
one half plus delta sound the

366
00:13:06,160 --> 00:13:08,480
communication complexity is n bits

367
00:13:08,480 --> 00:13:10,880
needed to represent the subset i

368
00:13:10,880 --> 00:13:12,959
plus the communication required for a

369
00:13:12,959 --> 00:13:15,200
single execution of pi

370
00:13:15,200 --> 00:13:17,680
and the verification time is roughly n

371
00:13:17,680 --> 00:13:21,519
times tg plus t pi where tg is the time

372
00:13:21,519 --> 00:13:23,440
required for a single multiplication in

373
00:13:23,440 --> 00:13:26,399
the group and t pi is the verification

374
00:13:26,399 --> 00:13:29,040
time of pi

375
00:13:29,200 --> 00:13:30,959
obviously we're not happy with soundness

376
00:13:30,959 --> 00:13:33,040
error of one half and we wish to reduce

377
00:13:33,040 --> 00:13:35,360
it naturally this is done by parallel

378
00:13:35,360 --> 00:13:36,959
repetition

379
00:13:36,959 --> 00:13:38,880
so now the verifier chooses m

380
00:13:38,880 --> 00:13:41,360
independent random subsets of indices

381
00:13:41,360 --> 00:13:44,320
i1 to im where m is the parameter of our

382
00:13:44,320 --> 00:13:45,519
compiler

383
00:13:45,519 --> 00:13:48,800
and sends these subsets to the prover

384
00:13:48,800 --> 00:13:49,920
the two parties compute the

385
00:13:49,920 --> 00:13:52,480
corresponding amperes of group elements

386
00:13:52,480 --> 00:13:55,760
x prime j and y prime j for each j from

387
00:13:55,760 --> 00:13:57,120
1 to m

388
00:13:57,120 --> 00:14:00,320
and then run m parallel executions of pi

389
00:14:00,320 --> 00:14:03,279
one for each computed pair of elements

390
00:14:03,279 --> 00:14:05,360
by the independence of the subsets we

391
00:14:05,360 --> 00:14:08,240
can show that if y i is not equal to x i

392
00:14:08,240 --> 00:14:10,000
to the e for some i

393
00:14:10,000 --> 00:14:12,560
then the probability that y prime j is

394
00:14:12,560 --> 00:14:15,279
equal to x prime j to the e for every j

395
00:14:15,279 --> 00:14:17,199
is at most one half raised to the power

396
00:14:17,199 --> 00:14:18,720
of m

397
00:14:18,720 --> 00:14:20,639
this implies that the result of the

398
00:14:20,639 --> 00:14:22,079
batch protocol

399
00:14:22,079 --> 00:14:24,959
is 2 to the minus m plus delta sound

400
00:14:24,959 --> 00:14:27,519
and for example setting m to be equal to

401
00:14:27,519 --> 00:14:29,680
the security parameter lambda or even

402
00:14:29,680 --> 00:14:31,920
anything super logarithmic in lambda we

403
00:14:31,920 --> 00:14:33,839
get a protocol which is delta sound

404
00:14:33,839 --> 00:14:35,920
which is the best we can hope for

405
00:14:35,920 --> 00:14:37,760
the problem that remains is that the

406
00:14:37,760 --> 00:14:39,839
communication added by the compiler is

407
00:14:39,839 --> 00:14:41,680
linear in n

408
00:14:41,680 --> 00:14:43,360
this is not a problem with the fiat

409
00:14:43,360 --> 00:14:45,760
mirror heuristic is applied since all of

410
00:14:45,760 --> 00:14:47,680
this added communication is from the

411
00:14:47,680 --> 00:14:49,839
verifier to the approver so it will be

412
00:14:49,839 --> 00:14:52,240
locally computed by the parties

413
00:14:52,240 --> 00:14:54,320
if one wishes not to rely on the fiatum

414
00:14:54,320 --> 00:14:56,560
heuristic and to retain an interactive

415
00:14:56,560 --> 00:14:57,839
protocol

416
00:14:57,839 --> 00:14:59,600
then this first message from the

417
00:14:59,600 --> 00:15:01,760
verifier to the approver can be

418
00:15:01,760 --> 00:15:04,720
derandomized and made much shorter

419
00:15:04,720 --> 00:15:06,560
for example this can be done by having

420
00:15:06,560 --> 00:15:08,320
the verifier send the c to a pseudo

421
00:15:08,320 --> 00:15:10,079
random generator

422
00:15:10,079 --> 00:15:12,639
this results in communication complexity

423
00:15:12,639 --> 00:15:14,480
which is m times the communication

424
00:15:14,480 --> 00:15:16,000
complexity of pi

425
00:15:16,000 --> 00:15:18,800
since we run m executions of pi plus the

426
00:15:18,800 --> 00:15:21,519
seed length of the prg

427
00:15:21,519 --> 00:15:24,399
the verification time is now m times n

428
00:15:24,399 --> 00:15:27,120
times tg plus t pi

429
00:15:27,120 --> 00:15:29,279
plus whatever time it takes to evaluate

430
00:15:29,279 --> 00:15:31,040
the plg

431
00:15:31,040 --> 00:15:33,040
it should be mentioned that one can also

432
00:15:33,040 --> 00:15:35,680
derandomize the verifier's message using

433
00:15:35,680 --> 00:15:38,079
combinatorial non-cryptographic tools

434
00:15:38,079 --> 00:15:40,639
like epsilon biased sets but this would

435
00:15:40,639 --> 00:15:42,399
incur a slightly larger communication

436
00:15:42,399 --> 00:15:44,639
overhead

437
00:15:44,639 --> 00:15:46,160
okay so let's move to consider our

438
00:15:46,160 --> 00:15:48,480
second compiler and to do that we first

439
00:15:48,480 --> 00:15:50,639
need to recall the low order assumption

440
00:15:50,639 --> 00:15:52,639
this assumption is parameterized by some

441
00:15:52,639 --> 00:15:55,040
integer s and is captured by the

442
00:15:55,040 --> 00:15:57,360
following experiment

443
00:15:57,360 --> 00:15:59,360
first we sample a group g according to

444
00:15:59,360 --> 00:16:01,199
some underlying distribution

445
00:16:01,199 --> 00:16:02,959
and give the description of g to the

446
00:16:02,959 --> 00:16:04,560
adversary a

447
00:16:04,560 --> 00:16:06,399
the adversary then needs to output a

448
00:16:06,399 --> 00:16:09,440
group element x and an integer omega

449
00:16:09,440 --> 00:16:12,079
such that x is not the identity element

450
00:16:12,079 --> 00:16:14,880
omega is smaller than the parameter s

451
00:16:14,880 --> 00:16:16,959
and omega is a multiple of the order of

452
00:16:16,959 --> 00:16:18,720
x in g

453
00:16:18,720 --> 00:16:20,639
we say that the slow order assumption

454
00:16:20,639 --> 00:16:23,279
holds if the probability that a succeeds

455
00:16:23,279 --> 00:16:26,480
is negligible in the security parameter

456
00:16:26,480 --> 00:16:28,079
candidates in which this assumption

457
00:16:28,079 --> 00:16:30,240
might hold for superpolynomial values of

458
00:16:30,240 --> 00:16:30,959
s

459
00:16:30,959 --> 00:16:33,199
are the group qrn of quadratic residues

460
00:16:33,199 --> 00:16:35,759
model when and its isomorphic group qrn

461
00:16:35,759 --> 00:16:38,320
plus of sine quadratic residues

462
00:16:38,320 --> 00:16:40,720
the quotient group zn star over plus

463
00:16:40,720 --> 00:16:42,000
minus 1

464
00:16:42,000 --> 00:16:43,920
and class groups of imaginary quadratic

465
00:16:43,920 --> 00:16:45,759
number fields for certain parameter

466
00:16:45,759 --> 00:16:47,759
choices

467
00:16:47,759 --> 00:16:50,000
in some of these cases the s low order

468
00:16:50,000 --> 00:16:52,160
assumption even holds unconditionally

469
00:16:52,160 --> 00:16:54,800
for s which is exponential in lambda and

470
00:16:54,800 --> 00:16:56,160
you can see the paper for a more

471
00:16:56,160 --> 00:16:59,040
exhaustive discussion

472
00:16:59,040 --> 00:17:00,880
the second compiler is defined as

473
00:17:00,880 --> 00:17:02,079
follows

474
00:17:02,079 --> 00:17:04,720
the verifier first samples n independent

475
00:17:04,720 --> 00:17:08,480
integers a 1 to a n from the set 1 to s

476
00:17:08,480 --> 00:17:11,039
where s is the parameter of the compiler

477
00:17:11,039 --> 00:17:12,720
you can already understand that it's not

478
00:17:12,720 --> 00:17:14,720
a coincidence that we use the same

479
00:17:14,720 --> 00:17:16,079
letter that we use to define the

480
00:17:16,079 --> 00:17:18,559
parameter of the low order assumption

481
00:17:18,559 --> 00:17:20,959
the verifier then sends these ai's to

482
00:17:20,959 --> 00:17:24,000
the prover and the two parties compute x

483
00:17:24,000 --> 00:17:26,799
prime as the product of x i raised to

484
00:17:26,799 --> 00:17:28,319
the power of a i

485
00:17:28,319 --> 00:17:30,960
and y prime which is defined similarly

486
00:17:30,960 --> 00:17:33,440
the parties then execute pi on the input

487
00:17:33,440 --> 00:17:35,840
x prime y prime and e

488
00:17:35,840 --> 00:17:37,520
the soundness of the resulted batch

489
00:17:37,520 --> 00:17:39,200
protocol is based on the following

490
00:17:39,200 --> 00:17:42,000
dilemma that states at least informally

491
00:17:42,000 --> 00:17:44,720
that if y i is not equal to x i to the e

492
00:17:44,720 --> 00:17:47,679
for some i and the probability that y

493
00:17:47,679 --> 00:17:50,320
prime is equal to x prime to the e is at

494
00:17:50,320 --> 00:17:52,640
least one over s plus epsilon

495
00:17:52,640 --> 00:17:54,320
then we can break the s low order

496
00:17:54,320 --> 00:17:56,160
assumption in the group with probability

497
00:17:56,160 --> 00:17:58,640
which is at least epsilon squared

498
00:17:58,640 --> 00:18:00,880
at a high level the proof of dilemma is

499
00:18:00,880 --> 00:18:02,720
by a rewinding reduction

500
00:18:02,720 --> 00:18:05,520
observe that if we have integers a1 to a

501
00:18:05,520 --> 00:18:08,320
n such that the induced y prime is equal

502
00:18:08,320 --> 00:18:10,080
to the induced x prime raised to the

503
00:18:10,080 --> 00:18:11,200
power of e

504
00:18:11,200 --> 00:18:13,679
and the same holds when we change ai to

505
00:18:13,679 --> 00:18:15,840
some other ai prime

506
00:18:15,840 --> 00:18:18,320
then we can divide the two equalities

507
00:18:18,320 --> 00:18:21,760
and conclude that y i over x i to the e

508
00:18:21,760 --> 00:18:24,799
is a group element whose order divides a

509
00:18:24,799 --> 00:18:28,000
i minus a i prime

510
00:18:28,000 --> 00:18:31,200
since y i is not equal to x i to the e

511
00:18:31,200 --> 00:18:33,360
this group element is not the identity

512
00:18:33,360 --> 00:18:34,640
element

513
00:18:34,640 --> 00:18:38,080
and since a i and a i prime are between

514
00:18:38,080 --> 00:18:40,799
1 and s their difference is less than s

515
00:18:40,799 --> 00:18:42,240
and so we break the slow order

516
00:18:42,240 --> 00:18:44,240
assumption

517
00:18:44,240 --> 00:18:46,240
so this lemma immediately implies that

518
00:18:46,240 --> 00:18:49,039
the resulting batch protocol is 1 over s

519
00:18:49,039 --> 00:18:50,640
delta sound

520
00:18:50,640 --> 00:18:53,039
note that the reduction is not tight as

521
00:18:53,039 --> 00:18:55,520
we move from epsilon to epsilon squared

522
00:18:55,520 --> 00:18:57,280
and so it's worth mentioning that we do

523
00:18:57,280 --> 00:18:59,039
have tight reductions for specific

524
00:18:59,039 --> 00:19:00,960
groups and you can see the paper for

525
00:19:00,960 --> 00:19:03,440
more details on that

526
00:19:03,440 --> 00:19:05,520
also recall that as we mentioned we do

527
00:19:05,520 --> 00:19:07,679
have candidates for groups in which we

528
00:19:07,679 --> 00:19:09,360
believe that the slow order assumption

529
00:19:09,360 --> 00:19:12,240
holds for super polynomial's values of s

530
00:19:12,240 --> 00:19:14,559
in this case when instantiated in these

531
00:19:14,559 --> 00:19:16,799
groups our compilers yields a delta

532
00:19:16,799 --> 00:19:18,640
sound batch protocol which is the best

533
00:19:18,640 --> 00:19:20,400
we can hope for

534
00:19:20,400 --> 00:19:22,000
the communication complexity of the

535
00:19:22,000 --> 00:19:24,480
resulted protocol is n times log s for

536
00:19:24,480 --> 00:19:26,799
the first message of the verifier plus

537
00:19:26,799 --> 00:19:29,120
the communication complexity of pi

538
00:19:29,120 --> 00:19:31,520
and the verification time is roughly n

539
00:19:31,520 --> 00:19:33,679
times log s times tg

540
00:19:33,679 --> 00:19:36,000
since each exponentiation takes roughly

541
00:19:36,000 --> 00:19:38,400
log as group operations plus the

542
00:19:38,400 --> 00:19:40,720
verification time of pi

543
00:19:40,720 --> 00:19:42,640
as before we can get rid of the added

544
00:19:42,640 --> 00:19:45,200
message of the verifier using viachamir

545
00:19:45,200 --> 00:19:47,120
or we can derandomize it for example

546
00:19:47,120 --> 00:19:49,440
using a prg

547
00:19:49,440 --> 00:19:50,960
now let's move on to discuss our

548
00:19:50,960 --> 00:19:54,559
protocols in safe prime's rsa groups

549
00:19:54,559 --> 00:19:56,320
just to be on the same page we're now

550
00:19:56,320 --> 00:19:58,720
considering the rsa group zn star of

551
00:19:58,720 --> 00:20:01,440
integers module n where the modulus n is

552
00:20:01,440 --> 00:20:04,400
the product of two primes p and q

553
00:20:04,400 --> 00:20:06,400
note that the slow order assumption

554
00:20:06,400 --> 00:20:08,080
cannot hold in this group for any

555
00:20:08,080 --> 00:20:09,919
non-trivial value of s

556
00:20:09,919 --> 00:20:12,799
since -1 model 1 is always an element of

557
00:20:12,799 --> 00:20:14,799
order 2 in this group

558
00:20:14,799 --> 00:20:16,799
this is not just a problem in the proofs

559
00:20:16,799 --> 00:20:19,840
but indeed the protocols of pieza and

560
00:20:19,840 --> 00:20:22,080
can only make sure that y is equal to

561
00:20:22,080 --> 00:20:24,559
plus minus x to d and the same problem

562
00:20:24,559 --> 00:20:26,640
arises in the random exponents compiler

563
00:20:26,640 --> 00:20:28,320
that we just saw

564
00:20:28,320 --> 00:20:29,919
a possible solution that has been

565
00:20:29,919 --> 00:20:32,320
suggested is to quotient out plus minus

566
00:20:32,320 --> 00:20:33,679
one from the group

567
00:20:33,679 --> 00:20:36,000
but in some cases one might want to

568
00:20:36,000 --> 00:20:38,080
stick with the group z and star for

569
00:20:38,080 --> 00:20:40,159
example due to implementation issues or

570
00:20:40,159 --> 00:20:41,840
compatibility with other cryptographic

571
00:20:41,840 --> 00:20:42,799
schemes

572
00:20:42,799 --> 00:20:45,039
in this case one can consider settling

573
00:20:45,039 --> 00:20:46,880
for the above mentioned wiki security

574
00:20:46,880 --> 00:20:49,280
guarantee as it might be sufficient for

575
00:20:49,280 --> 00:20:51,200
some applications

576
00:20:51,200 --> 00:20:53,600
another possibility that we will now see

577
00:20:53,600 --> 00:20:55,520
is to have the prover prove that we are

578
00:20:55,520 --> 00:20:57,679
not settling for this week of security

579
00:20:57,679 --> 00:21:00,880
or in other words that y i is not equal

580
00:21:00,880 --> 00:21:04,000
to minus x i to the e for every i

581
00:21:04,000 --> 00:21:05,919
and we do that for the special case in

582
00:21:05,919 --> 00:21:09,520
which p and q are safe primes

583
00:21:09,760 --> 00:21:11,760
as a first step let's see how to prove

584
00:21:11,760 --> 00:21:14,320
that y is not equal to minus x to the e

585
00:21:14,320 --> 00:21:16,960
for a single pair of elements x and y

586
00:21:16,960 --> 00:21:18,799
and we'll do this by generalizing an

587
00:21:18,799 --> 00:21:21,919
idea by decreasing zoetal

588
00:21:21,919 --> 00:21:25,200
so the prover computes e plus 1 over 2

589
00:21:25,200 --> 00:21:27,600
rounds it up raises x to the power of

590
00:21:27,600 --> 00:21:30,320
the result and sends the result group

591
00:21:30,320 --> 00:21:32,880
element u to the verifier

592
00:21:32,880 --> 00:21:36,000
the verifier then computes z as y times

593
00:21:36,000 --> 00:21:39,120
x raised to the power of 1 plus e plus 1

594
00:21:39,120 --> 00:21:40,480
modulo 2

595
00:21:40,480 --> 00:21:43,760
and accepts if and only if z is equal to

596
00:21:43,760 --> 00:21:46,159
u squared

597
00:21:46,159 --> 00:21:48,720
the main observation is that if y is

598
00:21:48,720 --> 00:21:50,880
equal to minus x to the e

599
00:21:50,880 --> 00:21:53,120
then z must be a quadratic non-residue

600
00:21:53,120 --> 00:21:55,039
modulu n

601
00:21:55,039 --> 00:21:57,440
this is true since in this case we can

602
00:21:57,440 --> 00:22:00,960
write z as minus 1 times x raised to the

603
00:22:00,960 --> 00:22:04,080
power of e plus 1 plus e plus 1 modulo

604
00:22:04,080 --> 00:22:05,360
2.

605
00:22:05,360 --> 00:22:07,679
when p and q are safe primes

606
00:22:07,679 --> 00:22:09,679
minus 1 is always a quadratic known

607
00:22:09,679 --> 00:22:10,880
residue

608
00:22:10,880 --> 00:22:13,840
on the other hand e plus 1 plus e plus 1

609
00:22:13,840 --> 00:22:17,440
modulo 2 is always an even integer so z

610
00:22:17,440 --> 00:22:18,960
is the product of a quadratic

611
00:22:18,960 --> 00:22:21,600
non-residue and a quadratic residue

612
00:22:21,600 --> 00:22:23,679
which means that z is indeed a quadratic

613
00:22:23,679 --> 00:22:25,039
known residue

614
00:22:25,039 --> 00:22:27,440
hence it cannot be equal to u squared

615
00:22:27,440 --> 00:22:29,120
regardless of what element you the

616
00:22:29,120 --> 00:22:31,440
approval sends

617
00:22:31,440 --> 00:22:33,120
now we want to generalize the same

618
00:22:33,120 --> 00:22:35,840
approach to prove that y i is not equal

619
00:22:35,840 --> 00:22:37,760
to minus x i to the e

620
00:22:37,760 --> 00:22:41,200
for n pairs x i and y i

621
00:22:41,200 --> 00:22:43,760
the way the crescenzoital did this is by

622
00:22:43,760 --> 00:22:45,440
repeating the protocol from before and

623
00:22:45,440 --> 00:22:46,559
times over

624
00:22:46,559 --> 00:22:48,320
which results in a proof size which is

625
00:22:48,320 --> 00:22:50,400
linear in n and this is exactly what

626
00:22:50,400 --> 00:22:52,559
we're trying to avoid

627
00:22:52,559 --> 00:22:54,400
so the solution will be to apply the

628
00:22:54,400 --> 00:22:56,480
same ideas as in the random subsets

629
00:22:56,480 --> 00:22:57,919
compiler

630
00:22:57,919 --> 00:23:00,559
for each i the prover computes ui from x

631
00:23:00,559 --> 00:23:03,120
i and the verifier computes z i from x i

632
00:23:03,120 --> 00:23:05,360
and y i as before

633
00:23:05,360 --> 00:23:07,440
but instead of having the prover send

634
00:23:07,440 --> 00:23:09,919
all of these uis to the verifier

635
00:23:09,919 --> 00:23:13,280
the verifier now samples m subsets i1 to

636
00:23:13,280 --> 00:23:17,200
im and sends them to the prover

637
00:23:17,200 --> 00:23:20,320
for each j the approver computes wj as

638
00:23:20,320 --> 00:23:23,039
the product of all of the uis for little

639
00:23:23,039 --> 00:23:25,039
i in ij

640
00:23:25,039 --> 00:23:28,799
and sends the wjs to the verifier

641
00:23:28,799 --> 00:23:31,200
finally the verifier computes for every

642
00:23:31,200 --> 00:23:34,640
j an element tj as the product of all of

643
00:23:34,640 --> 00:23:38,080
the zi's for little i in ij

644
00:23:38,080 --> 00:23:41,520
and accepts if and only if tj is equal

645
00:23:41,520 --> 00:23:45,360
to wj squared for every j

646
00:23:45,360 --> 00:23:47,600
incorporating the ideas from before with

647
00:23:47,600 --> 00:23:50,159
the ideas of the random subsets compiler

648
00:23:50,159 --> 00:23:52,480
one can show that the soundness arrow of

649
00:23:52,480 --> 00:23:55,279
this protocol is at most 2 to the minus

650
00:23:55,279 --> 00:23:56,240
m

651
00:23:56,240 --> 00:23:57,760
as before we can get rid of the

652
00:23:57,760 --> 00:23:59,279
verifier's first message using

653
00:23:59,279 --> 00:24:01,600
fiatchamir or they randomize it to make

654
00:24:01,600 --> 00:24:03,440
it shorter

655
00:24:03,440 --> 00:24:04,960
the last protocol that we will see in

656
00:24:04,960 --> 00:24:06,559
this talk is an information

657
00:24:06,559 --> 00:24:09,520
theoretically sound poce in rsi groups

658
00:24:09,520 --> 00:24:12,159
that are defined by two safe primes

659
00:24:12,159 --> 00:24:14,400
so the only poc that we know of that is

660
00:24:14,400 --> 00:24:16,880
securing z and star is the recent

661
00:24:16,880 --> 00:24:19,200
protocol of blockatal extending the

662
00:24:19,200 --> 00:24:21,120
protocol of pietzock

663
00:24:21,120 --> 00:24:23,360
the upside of their protocol is that it

664
00:24:23,360 --> 00:24:25,120
works in any group

665
00:24:25,120 --> 00:24:27,279
but the downside is that it incurs a

666
00:24:27,279 --> 00:24:28,799
blow-up of factor lambda in

667
00:24:28,799 --> 00:24:30,400
communication when compared to the

668
00:24:30,400 --> 00:24:32,480
protocol of pietsock

669
00:24:32,480 --> 00:24:34,400
what we will see now is a protocol that

670
00:24:34,400 --> 00:24:37,200
incurs a blow up of factor only 2.

671
00:24:37,200 --> 00:24:38,640
it can be proven to be information

672
00:24:38,640 --> 00:24:40,640
theoretically sound in rsa groups that

673
00:24:40,640 --> 00:24:43,039
are defined by two safe primes but it

674
00:24:43,039 --> 00:24:44,799
can also be assumed sound for other

675
00:24:44,799 --> 00:24:47,760
reasonable choices of modulae

676
00:24:47,760 --> 00:24:49,520
we start by describing the protocol of

677
00:24:49,520 --> 00:24:51,679
piezak and for with the presentation we

678
00:24:51,679 --> 00:24:53,679
focus on the case where the exponent is

679
00:24:53,679 --> 00:24:55,760
2 to the t and the prover wishes to

680
00:24:55,760 --> 00:24:57,679
prove that y is equal to x raised to the

681
00:24:57,679 --> 00:25:00,240
power of 2 to the t model when

682
00:25:00,240 --> 00:25:02,960
psx protocol proceeds in iterations

683
00:25:02,960 --> 00:25:04,720
where in each iteration the prover

684
00:25:04,720 --> 00:25:07,440
computes z as x raised to the power of 2

685
00:25:07,440 --> 00:25:09,760
to the t over 2 and sends z to the

686
00:25:09,760 --> 00:25:11,200
verifier

687
00:25:11,200 --> 00:25:13,120
and the verifier replies with a random

688
00:25:13,120 --> 00:25:17,360
integer r between 1 and 2 to the lambda

689
00:25:17,360 --> 00:25:19,840
the input to the next iteration is then

690
00:25:19,840 --> 00:25:22,240
x prime which is x raised to the power

691
00:25:22,240 --> 00:25:23,919
of r times z

692
00:25:23,919 --> 00:25:26,240
y prime which is z raised to the power

693
00:25:26,240 --> 00:25:29,679
of r times y and t prime which is t over

694
00:25:29,679 --> 00:25:30,720
two

695
00:25:30,720 --> 00:25:33,600
after log t iterations we get to t

696
00:25:33,600 --> 00:25:35,600
equals one and then the verifier can

697
00:25:35,600 --> 00:25:38,320
verify that y is equal to x squared on

698
00:25:38,320 --> 00:25:39,600
their own

699
00:25:39,600 --> 00:25:41,520
as we mentioned before this protocol is

700
00:25:41,520 --> 00:25:44,080
insecure in rsa groups since in each

701
00:25:44,080 --> 00:25:46,400
iteration it might be the case that y is

702
00:25:46,400 --> 00:25:48,320
equal to minus x raised to the power of

703
00:25:48,320 --> 00:25:50,640
2 to the t

704
00:25:50,640 --> 00:25:52,320
to make sure that this is not the case

705
00:25:52,320 --> 00:25:53,919
we ask the prover to additionally

706
00:25:53,919 --> 00:25:56,799
compute in each iteration the element u

707
00:25:56,799 --> 00:25:59,760
as x raised to the power of 2 to the t

708
00:25:59,760 --> 00:26:01,919
minus 1 plus 1

709
00:26:01,919 --> 00:26:04,320
and send u to the verifier

710
00:26:04,320 --> 00:26:06,880
and the verifier then rejects if x

711
00:26:06,880 --> 00:26:09,120
squared times z is not equal to u

712
00:26:09,120 --> 00:26:10,559
squared

713
00:26:10,559 --> 00:26:12,000
we will not see the proof for the

714
00:26:12,000 --> 00:26:14,159
soundness of the spark on this talk but

715
00:26:14,159 --> 00:26:16,320
it relies on similar ideas to those we

716
00:26:16,320 --> 00:26:18,400
saw before and the fact that all

717
00:26:18,400 --> 00:26:20,480
elements in z and star when n is the

718
00:26:20,480 --> 00:26:22,799
product of two safe primes are either of

719
00:26:22,799 --> 00:26:24,720
order two or for there at least two to

720
00:26:24,720 --> 00:26:26,720
the lambda

721
00:26:26,720 --> 00:26:28,640
okay so let's conclude

722
00:26:28,640 --> 00:26:30,799
what we saw in this talk are simple and

723
00:26:30,799 --> 00:26:32,640
efficient batch verification techniques

724
00:26:32,640 --> 00:26:35,360
for verification of vdfs

725
00:26:35,360 --> 00:26:37,039
while focusing on proofs of correct

726
00:26:37,039 --> 00:26:38,880
exponentiation

727
00:26:38,880 --> 00:26:41,360
concretely we saw two compilers that

728
00:26:41,360 --> 00:26:44,400
take any poce and turn it into a batch

729
00:26:44,400 --> 00:26:47,840
poc that improve upon the naive solution

730
00:26:47,840 --> 00:26:50,000
of simply repeating the poc and times

731
00:26:50,000 --> 00:26:51,039
over

732
00:26:51,039 --> 00:26:52,799
we saw the random subset compiler which

733
00:26:52,799 --> 00:26:55,039
works in any group and we saw the random

734
00:26:55,039 --> 00:26:57,120
exponents compiler that assumes the

735
00:26:57,120 --> 00:26:59,440
lower the assumption in the group

736
00:26:59,440 --> 00:27:02,080
we also specifically saw how to import

737
00:27:02,080 --> 00:27:04,400
the random exponents compiler to rsa

738
00:27:04,400 --> 00:27:06,240
groups where the modulus n is the

739
00:27:06,240 --> 00:27:08,799
product of two safe primes and we also

740
00:27:08,799 --> 00:27:10,880
saw an information theoretically sound

741
00:27:10,880 --> 00:27:13,919
poc in these groups as well

742
00:27:13,919 --> 00:27:16,080
an interesting open question is to

743
00:27:16,080 --> 00:27:18,000
devise batch verification techniques for

744
00:27:18,000 --> 00:27:20,320
other vdfs that do not rely on repeated

745
00:27:20,320 --> 00:27:22,000
querying and batch proofs of correct

746
00:27:22,000 --> 00:27:24,559
exponentiation like isogeny based

747
00:27:24,559 --> 00:27:26,559
constructions or constructions in prime

748
00:27:26,559 --> 00:27:27,679
fields

749
00:27:27,679 --> 00:27:29,600
ok so that's the end of the talk and

750
00:27:29,600 --> 00:27:32,959
thank you for listening

