1
00:00:02,960 --> 00:00:05,359
hello my name is sebastian lord and i'm

2
00:00:05,359 --> 00:00:07,600
happy to present secure software leasing

3
00:00:07,600 --> 00:00:09,760
without assumptions in the context of

4
00:00:09,760 --> 00:00:12,000
the theory of cryptography conference or

5
00:00:12,000 --> 00:00:14,480
tcc 2021

6
00:00:14,480 --> 00:00:16,239
this is joint work with my wonderful

7
00:00:16,239 --> 00:00:19,039
co-authors and broadband stacey jeffrey

8
00:00:19,039 --> 00:00:21,760
super the potter and arty sunderer

9
00:00:21,760 --> 00:00:25,119
let's jump right into it

10
00:00:25,119 --> 00:00:26,000
so

11
00:00:26,000 --> 00:00:27,519
one of my main interests in quantum

12
00:00:27,519 --> 00:00:29,439
cryptography is where we can apply the

13
00:00:29,439 --> 00:00:31,519
no cloning principle to achieve things

14
00:00:31,519 --> 00:00:33,600
that would otherwise be impossible using

15
00:00:33,600 --> 00:00:36,000
only classical tools

16
00:00:36,000 --> 00:00:37,760
succinctly the no cloning principle

17
00:00:37,760 --> 00:00:39,440
states that it is impossible to create

18
00:00:39,440 --> 00:00:41,600
perfect copies of arbitrary quantum

19
00:00:41,600 --> 00:00:42,719
states

20
00:00:42,719 --> 00:00:44,640
and this is the pillar of many quantum

21
00:00:44,640 --> 00:00:46,719
cryptographic primitives that achieve

22
00:00:46,719 --> 00:00:48,000
things that would be impossible with

23
00:00:48,000 --> 00:00:50,320
only classical means right and the idea

24
00:00:50,320 --> 00:00:51,840
here is that the no cloning principle is

25
00:00:51,840 --> 00:00:53,760
quite a quantum phenomena in the

26
00:00:53,760 --> 00:00:56,320
classical setting adversaries

27
00:00:56,320 --> 00:00:58,640
uh and eavesdroppers and any party can

28
00:00:58,640 --> 00:01:00,559
just keep copies of classical

29
00:01:00,559 --> 00:01:02,239
information that is exchanged back and

30
00:01:02,239 --> 00:01:04,799
forth this is not quite true in the

31
00:01:04,799 --> 00:01:06,479
quantum setting

32
00:01:06,479 --> 00:01:09,040
and this gives rise to a whole lot of

33
00:01:09,040 --> 00:01:11,520
unclonable cryptography some of which

34
00:01:11,520 --> 00:01:13,920
i'm sure you've already heard of perhaps

35
00:01:13,920 --> 00:01:16,159
the most famous examples are unclonable

36
00:01:16,159 --> 00:01:18,240
tokens so includable tokens are

37
00:01:18,240 --> 00:01:20,159
essentially quantum states that contain

38
00:01:20,159 --> 00:01:22,240
no meaningful information

39
00:01:22,240 --> 00:01:24,320
just enough so that a receiver can

40
00:01:24,320 --> 00:01:27,840
either accept or reject the token

41
00:01:27,840 --> 00:01:29,759
we can also talk about unclonable

42
00:01:29,759 --> 00:01:32,079
information these are encryption-like

43
00:01:32,079 --> 00:01:34,400
schemes that achieve some extra security

44
00:01:34,400 --> 00:01:36,720
notion where this extra security notion

45
00:01:36,720 --> 00:01:40,000
is tied into the no cloning principle

46
00:01:40,000 --> 00:01:42,079
this is something that myself and some

47
00:01:42,079 --> 00:01:43,840
of my colleagues are quite interested in

48
00:01:43,840 --> 00:01:45,439
and we have some previous work on things

49
00:01:45,439 --> 00:01:48,240
like concludable encryption and

50
00:01:48,240 --> 00:01:51,680
encryption of the certified deletion

51
00:01:51,680 --> 00:01:53,920
we also have unclonable functionalities

52
00:01:53,920 --> 00:01:55,920
and that's really the topic of this talk

53
00:01:55,920 --> 00:01:57,200
and in this talk we're going to cover

54
00:01:57,200 --> 00:01:58,719
two different types of unclonable

55
00:01:58,719 --> 00:02:00,159
functionalities we're going to talk

56
00:02:00,159 --> 00:02:03,040
about copy protection as well as secure

57
00:02:03,040 --> 00:02:04,799
software leasing

58
00:02:04,799 --> 00:02:06,399
and one of the ideas that we're trying

59
00:02:06,399 --> 00:02:08,080
to promote here is that all of these

60
00:02:08,080 --> 00:02:10,080
three notions can be seen as part of a

61
00:02:10,080 --> 00:02:11,920
hierarchy where at the top of the

62
00:02:11,920 --> 00:02:14,080
hierarchy you have the functionalities

63
00:02:14,080 --> 00:02:15,840
followed by includable information

64
00:02:15,840 --> 00:02:18,560
followed by unclutterable token the idea

65
00:02:18,560 --> 00:02:20,080
being that at every level of the

66
00:02:20,080 --> 00:02:22,400
hierarchy these are more and more

67
00:02:22,400 --> 00:02:24,720
complex

68
00:02:24,720 --> 00:02:26,319
things if you will that are rendered

69
00:02:26,319 --> 00:02:28,560
unclonable by using the node cloning

70
00:02:28,560 --> 00:02:31,040
principle

71
00:02:31,360 --> 00:02:34,239
okay so where does the story of

72
00:02:34,239 --> 00:02:36,720
unclonable functionalities begin well it

73
00:02:36,720 --> 00:02:38,879
begins with a question by scott aronson

74
00:02:38,879 --> 00:02:41,200
in 2009 and this question is quite

75
00:02:41,200 --> 00:02:42,239
simple

76
00:02:42,239 --> 00:02:44,800
it asks can quantum states be used as

77
00:02:44,800 --> 00:02:47,120
copy protected programs which let the

78
00:02:47,120 --> 00:02:49,680
user evaluate some function f but not

79
00:02:49,680 --> 00:02:52,720
create more programs for f

80
00:02:52,720 --> 00:02:55,120
so let's sketch out the idea

81
00:02:55,120 --> 00:02:56,959
that's wanted here so what's the basic

82
00:02:56,959 --> 00:02:59,120
idea behind copy protection

83
00:02:59,120 --> 00:03:00,159
well we're going to have a pair of

84
00:03:00,159 --> 00:03:02,800
procedures protecting the vowel

85
00:03:02,800 --> 00:03:04,959
such that we can feed some function f

86
00:03:04,959 --> 00:03:07,040
taken from a larger family of functions

87
00:03:07,040 --> 00:03:08,640
into the protection

88
00:03:08,640 --> 00:03:10,080
procedure

89
00:03:10,080 --> 00:03:11,840
this is going to yield some quantum

90
00:03:11,840 --> 00:03:14,800
state row f and row f can be used in the

91
00:03:14,800 --> 00:03:17,040
evaluation procedure

92
00:03:17,040 --> 00:03:20,720
with a an input x to produce the output

93
00:03:20,720 --> 00:03:23,519
of the function f of x

94
00:03:23,519 --> 00:03:25,519
now there's been a lot of recent

95
00:03:25,519 --> 00:03:26,959
activity right erinson asked this

96
00:03:26,959 --> 00:03:29,280
question in 2009 and for about 10 years

97
00:03:29,280 --> 00:03:30,799
there hasn't been a whole lot of

98
00:03:30,799 --> 00:03:32,799
progress on the question but over the

99
00:03:32,799 --> 00:03:34,799
past two years there's been

100
00:03:34,799 --> 00:03:36,159
multiple different works multiple

101
00:03:36,159 --> 00:03:38,159
different publications including other

102
00:03:38,159 --> 00:03:40,080
work that will be presented at this

103
00:03:40,080 --> 00:03:42,319
conference

104
00:03:42,319 --> 00:03:43,920
i want to highlight at this point that

105
00:03:43,920 --> 00:03:45,760
all of these other works they use either

106
00:03:45,760 --> 00:03:47,200
some standard assumptions right we're

107
00:03:47,200 --> 00:03:49,040
talking one-way functions

108
00:03:49,040 --> 00:03:50,400
or things like that

109
00:03:50,400 --> 00:03:51,200
or

110
00:03:51,200 --> 00:03:53,760
quantum oracles or set up assumptions to

111
00:03:53,760 --> 00:03:57,599
achieve the security of their protocols

112
00:03:58,000 --> 00:04:00,319
this is where our contribution comes in

113
00:04:00,319 --> 00:04:02,560
so the main contribution in this work is

114
00:04:02,560 --> 00:04:04,319
that we construct a secure software

115
00:04:04,319 --> 00:04:06,319
leasing scheme specifically for point

116
00:04:06,319 --> 00:04:07,439
functions

117
00:04:07,439 --> 00:04:09,840
which is provably secure without any

118
00:04:09,840 --> 00:04:12,400
assumptions at all and against unbounded

119
00:04:12,400 --> 00:04:14,560
adversaries

120
00:04:14,560 --> 00:04:15,439
so

121
00:04:15,439 --> 00:04:17,759
our construction can be instantiated by

122
00:04:17,759 --> 00:04:19,440
any total authentication scheme we'll

123
00:04:19,440 --> 00:04:22,240
get into those details in a bit

124
00:04:22,240 --> 00:04:24,240
and we obtain our secure software

125
00:04:24,240 --> 00:04:26,720
leasing scheme by passing via this novel

126
00:04:26,720 --> 00:04:29,120
security notion of honest malicious copy

127
00:04:29,120 --> 00:04:31,199
protection so we're going to define this

128
00:04:31,199 --> 00:04:33,199
security notion we're going to show how

129
00:04:33,199 --> 00:04:34,639
we achieve it

130
00:04:34,639 --> 00:04:36,160
if we were to sketch out the results of

131
00:04:36,160 --> 00:04:38,000
this work look a bit like this you take

132
00:04:38,000 --> 00:04:39,919
a total authentication scheme

133
00:04:39,919 --> 00:04:42,400
you use this to construct a copy an

134
00:04:42,400 --> 00:04:44,240
honest malicious copy protection scheme

135
00:04:44,240 --> 00:04:46,800
for point functions we then show that

136
00:04:46,800 --> 00:04:48,479
honest malicious copy protection for

137
00:04:48,479 --> 00:04:51,040
point function implies secure software

138
00:04:51,040 --> 00:04:53,199
releasing for point functions

139
00:04:53,199 --> 00:04:54,720
and i want to highlight this result i

140
00:04:54,720 --> 00:04:56,880
call it angelo mayans in paramba which

141
00:04:56,880 --> 00:04:58,800
states that if you have ssl for point

142
00:04:58,800 --> 00:05:01,199
functions you can also obtain ssl for

143
00:05:01,199 --> 00:05:03,440
compute and compare functions

144
00:05:03,440 --> 00:05:04,880
and our construction

145
00:05:04,880 --> 00:05:08,280
follows through

146
00:05:10,720 --> 00:05:11,600
okay

147
00:05:11,600 --> 00:05:14,800
let's formally define copy protection

148
00:05:14,800 --> 00:05:16,560
so as mentioned we're going to start off

149
00:05:16,560 --> 00:05:18,160
with a pair of procedures protecting the

150
00:05:18,160 --> 00:05:19,759
valve and this is going to be a copy

151
00:05:19,759 --> 00:05:21,520
protection scheme for a certain family

152
00:05:21,520 --> 00:05:23,600
of circuits now throughout the talk we

153
00:05:23,600 --> 00:05:25,360
go back and forth between functions and

154
00:05:25,360 --> 00:05:28,479
circuits it's not particularly important

155
00:05:28,479 --> 00:05:30,560
for this work formally the definitions

156
00:05:30,560 --> 00:05:32,560
are given at the level of circuits but

157
00:05:32,560 --> 00:05:34,240
uh for the level of this talk it's

158
00:05:34,240 --> 00:05:37,600
easier to reset about functions at times

159
00:05:37,600 --> 00:05:38,479
so

160
00:05:38,479 --> 00:05:40,000
the security of our scheme is going to

161
00:05:40,000 --> 00:05:42,080
be parametrized by a bunch of different

162
00:05:42,080 --> 00:05:43,840
distributions and this starts off with

163
00:05:43,840 --> 00:05:46,000
the distribution d on the family of

164
00:05:46,000 --> 00:05:48,400
circuits which we are copy protecting as

165
00:05:48,400 --> 00:05:51,039
well as a set of distribution on pairs

166
00:05:51,039 --> 00:05:53,280
of inputs to the circuit and every

167
00:05:53,280 --> 00:05:55,440
single circuit c has its particular

168
00:05:55,440 --> 00:06:00,080
distribution on pairs of inputs tc

169
00:06:00,080 --> 00:06:02,240
and we're going to analyze the security

170
00:06:02,240 --> 00:06:04,160
via a game that's going to be played by

171
00:06:04,160 --> 00:06:07,360
a referee against a collaborating pirate

172
00:06:07,360 --> 00:06:09,440
and two evaluators so the pirate and two

173
00:06:09,440 --> 00:06:11,840
evaluators get to set a

174
00:06:11,840 --> 00:06:13,440
strategy ahead of time but the

175
00:06:13,440 --> 00:06:15,600
communication that they have during the

176
00:06:15,600 --> 00:06:16,960
run of the game

177
00:06:16,960 --> 00:06:19,520
is going to be quite limited

178
00:06:19,520 --> 00:06:21,759
so let's put up our referee let's put up

179
00:06:21,759 --> 00:06:23,680
our pirate and our two malicious

180
00:06:23,680 --> 00:06:26,000
malicious evaluators i want to highlight

181
00:06:26,000 --> 00:06:27,440
here that

182
00:06:27,440 --> 00:06:29,840
the two evaluators are distinct they can

183
00:06:29,840 --> 00:06:32,840
behave in completely different

184
00:06:32,840 --> 00:06:35,600
ways the game starts off with the

185
00:06:35,600 --> 00:06:38,240
referee sampling a circuit c according

186
00:06:38,240 --> 00:06:41,759
to the distribution d and producing the

187
00:06:41,759 --> 00:06:44,319
copy protected program row

188
00:06:44,319 --> 00:06:46,479
that results from protecting the circuit

189
00:06:46,479 --> 00:06:47,680
c

190
00:06:47,680 --> 00:06:49,599
this state row is handed off to the

191
00:06:49,599 --> 00:06:51,360
pirate who can do

192
00:06:51,360 --> 00:06:53,599
arbitrary computation but at the end of

193
00:06:53,599 --> 00:06:56,160
this the pirate has to hand off one

194
00:06:56,160 --> 00:06:59,199
register to malicious evaluator zero and

195
00:06:59,199 --> 00:07:04,000
one register to malicious evaluator 1.

196
00:07:04,880 --> 00:07:05,919
once

197
00:07:05,919 --> 00:07:07,680
the program state is split between both

198
00:07:07,680 --> 00:07:10,240
evaluators the referee will sample two

199
00:07:10,240 --> 00:07:13,120
inputs to the circuit x0 and x1

200
00:07:13,120 --> 00:07:17,039
hand off x0 to evaluate the 0 handoff x1

201
00:07:17,039 --> 00:07:20,000
to evaluator 1 and both evaluators

202
00:07:20,000 --> 00:07:23,120
attempt to compute the value of cx for

203
00:07:23,120 --> 00:07:26,240
their respective x so they output sum y

204
00:07:26,240 --> 00:07:30,160
0 y 1 and they win if and only if both

205
00:07:30,160 --> 00:07:33,280
correctly compute the value of

206
00:07:33,280 --> 00:07:36,400
the circuit on their inputs

207
00:07:36,400 --> 00:07:37,759
formally we're going to say that the

208
00:07:37,759 --> 00:07:40,639
scheme is epsilon copy protecting if the

209
00:07:40,639 --> 00:07:43,120
probability that both evaluators

210
00:07:43,120 --> 00:07:46,160
correctly outputs is at most some

211
00:07:46,160 --> 00:07:48,240
trivial guessing probability plus

212
00:07:48,240 --> 00:07:49,440
epsilon

213
00:07:49,440 --> 00:07:50,960
so where does this trivial guessing

214
00:07:50,960 --> 00:07:53,599
probability come comes from well there's

215
00:07:53,599 --> 00:07:55,120
one attack that we can't prevent the

216
00:07:55,120 --> 00:07:57,120
pirate and the militias evaluated so

217
00:07:57,120 --> 00:07:58,960
implementing and this is simply the

218
00:07:58,960 --> 00:08:00,720
attack where the pirate hands off the

219
00:08:00,720 --> 00:08:02,639
program completely unchanged to one

220
00:08:02,639 --> 00:08:05,039
evaluator and the other evaluator

221
00:08:05,039 --> 00:08:07,759
guesses their value of y simply based on

222
00:08:07,759 --> 00:08:10,639
their value of x and we optimize over

223
00:08:10,639 --> 00:08:12,479
this guessing to obtain the trivial

224
00:08:12,479 --> 00:08:15,520
guessing probability

225
00:08:15,680 --> 00:08:16,720
okay

226
00:08:16,720 --> 00:08:18,639
so that was copy protection but we

227
00:08:18,639 --> 00:08:20,000
mentioned that we're going to achieve

228
00:08:20,000 --> 00:08:21,840
honest malicious copy protection which

229
00:08:21,840 --> 00:08:24,080
is a slightly weaker version of this

230
00:08:24,080 --> 00:08:26,479
more general idea

231
00:08:26,479 --> 00:08:28,400
so i want to highlight that in the game

232
00:08:28,400 --> 00:08:30,000
that we just studied malicious

233
00:08:30,000 --> 00:08:32,559
evaluators are completely unconstrained

234
00:08:32,559 --> 00:08:33,760
we have

235
00:08:33,760 --> 00:08:36,000
no guarantees on their behavior they can

236
00:08:36,000 --> 00:08:38,399
do whatever they want

237
00:08:38,399 --> 00:08:40,240
in the honest malicious setting we're

238
00:08:40,240 --> 00:08:42,719
going to force one of the evaluators to

239
00:08:42,719 --> 00:08:44,640
behave honestly

240
00:08:44,640 --> 00:08:47,040
so if we put up the same diagram as last

241
00:08:47,040 --> 00:08:49,120
slide it's going to look quite similar

242
00:08:49,120 --> 00:08:51,200
with the only difference being that one

243
00:08:51,200 --> 00:08:54,000
of the evaluators must behave honestly

244
00:08:54,000 --> 00:08:56,160
they must use the evaluation procedure

245
00:08:56,160 --> 00:08:58,000
that is prescribed by the copy

246
00:08:58,000 --> 00:08:59,680
protection scheme

247
00:08:59,680 --> 00:09:01,440
but other than this the setup is

248
00:09:01,440 --> 00:09:03,360
essentially the same

249
00:09:03,360 --> 00:09:04,720
we're going to say that the scheme is

250
00:09:04,720 --> 00:09:07,120
epsilon honest malicious copy protecting

251
00:09:07,120 --> 00:09:09,680
if the probability that both the honest

252
00:09:09,680 --> 00:09:11,519
and malicious evaluator correctly

253
00:09:11,519 --> 00:09:13,120
compute the value of the circuit on

254
00:09:13,120 --> 00:09:15,279
their input is at most some trivial

255
00:09:15,279 --> 00:09:17,040
guessing probability

256
00:09:17,040 --> 00:09:19,279
plus epsilon where the trivial guessing

257
00:09:19,279 --> 00:09:21,519
probability follows from simply giving

258
00:09:21,519 --> 00:09:23,519
the unchanged program state to the

259
00:09:23,519 --> 00:09:25,600
honest evaluator and having the

260
00:09:25,600 --> 00:09:27,760
malicious evaluator guess

261
00:09:27,760 --> 00:09:33,560
the possible outcome based only on x1

262
00:09:36,399 --> 00:09:38,640
okay

263
00:09:39,200 --> 00:09:41,040
so we're going to achieve this idea of

264
00:09:41,040 --> 00:09:42,880
honest malicious copy protection by

265
00:09:42,880 --> 00:09:44,480
using quantum authentication so let's

266
00:09:44,480 --> 00:09:46,080
talk about the general idea behind

267
00:09:46,080 --> 00:09:48,480
quantum authentication

268
00:09:48,480 --> 00:09:50,240
at the level of syntax a quantum

269
00:09:50,240 --> 00:09:51,680
authentication scheme for some

270
00:09:51,680 --> 00:09:53,839
particular space m is just a collection

271
00:09:53,839 --> 00:09:55,279
of pairs of quantum channels

272
00:09:55,279 --> 00:09:58,560
authenticate and verify indexed by keys

273
00:09:58,560 --> 00:09:59,279
k

274
00:09:59,279 --> 00:10:00,800
and they satisfy this correctness

275
00:10:00,800 --> 00:10:02,800
guarantee that if you verify an

276
00:10:02,800 --> 00:10:04,800
authenticated state by using the correct

277
00:10:04,800 --> 00:10:07,360
key you get precisely that state that

278
00:10:07,360 --> 00:10:10,720
same state back as well as a flag qubit

279
00:10:10,720 --> 00:10:13,440
in the a register and this flag register

280
00:10:13,440 --> 00:10:15,760
is spanned by either the a state or r

281
00:10:15,760 --> 00:10:19,200
state for accept or reject

282
00:10:19,200 --> 00:10:21,120
now security is a bit more technical to

283
00:10:21,120 --> 00:10:22,480
define

284
00:10:22,480 --> 00:10:24,240
but kind of the intuitive idea that you

285
00:10:24,240 --> 00:10:26,560
would want to have in head is that if

286
00:10:26,560 --> 00:10:28,880
you had some attack that interacted with

287
00:10:28,880 --> 00:10:30,720
the state between the authentication and

288
00:10:30,720 --> 00:10:32,640
the verification procedure

289
00:10:32,640 --> 00:10:34,320
you want to make sure that you never

290
00:10:34,320 --> 00:10:36,959
output the reject flag if you don't

291
00:10:36,959 --> 00:10:39,600
obtain the initial state back now this

292
00:10:39,600 --> 00:10:41,680
is not a formal definition and in fact

293
00:10:41,680 --> 00:10:42,720
there might be some issues in

294
00:10:42,720 --> 00:10:44,800
formalizing precisely this but it's

295
00:10:44,800 --> 00:10:46,240
about the intuition that you would want

296
00:10:46,240 --> 00:10:49,360
for a quantum authentication scheme

297
00:10:49,360 --> 00:10:51,760
but we're going to need a more precise

298
00:10:51,760 --> 00:10:53,920
security definition and the security

299
00:10:53,920 --> 00:10:55,519
notion that we're going to pick among

300
00:10:55,519 --> 00:10:57,839
the various ones in the literature is

301
00:10:57,839 --> 00:10:59,760
total authentication and this is a

302
00:10:59,760 --> 00:11:01,360
notion that was first introduced in

303
00:11:01,360 --> 00:11:04,360
2017.

304
00:11:05,519 --> 00:11:07,440
to properly talk about total

305
00:11:07,440 --> 00:11:10,000
authentication we need a slight

306
00:11:10,000 --> 00:11:12,000
variation on the verification map which

307
00:11:12,000 --> 00:11:14,959
is this verification with a overline and

308
00:11:14,959 --> 00:11:16,880
this is simply verification conditioned

309
00:11:16,880 --> 00:11:18,640
on acceptance so

310
00:11:18,640 --> 00:11:20,320
we check to make sure that the flag is

311
00:11:20,320 --> 00:11:22,640
in the accept state and we just reject

312
00:11:22,640 --> 00:11:23,920
if it is

313
00:11:23,920 --> 00:11:25,519
we just reject the state if it's in the

314
00:11:25,519 --> 00:11:26,839
reject

315
00:11:26,839 --> 00:11:28,399
flag

316
00:11:28,399 --> 00:11:30,320
so i i want to highlight that this is

317
00:11:30,320 --> 00:11:33,360
not a trace preserving map uh the trace

318
00:11:33,360 --> 00:11:36,560
of the state following this overline

319
00:11:36,560 --> 00:11:38,240
verification is precisely the

320
00:11:38,240 --> 00:11:40,560
probability that it accepts

321
00:11:40,560 --> 00:11:41,760
and what we're going to do is a bit of

322
00:11:41,760 --> 00:11:44,079
an ideal versus real set

323
00:11:44,079 --> 00:11:44,800
so

324
00:11:44,800 --> 00:11:47,920
in the real setting some adversary

325
00:11:47,920 --> 00:11:49,839
can pick a state row that's going to be

326
00:11:49,839 --> 00:11:53,360
authenticated as well as living on some

327
00:11:53,360 --> 00:11:56,000
memory register that the adversary holds

328
00:11:56,000 --> 00:11:58,160
the message register gets authenticated

329
00:11:58,160 --> 00:12:00,399
the adversary can attack

330
00:12:00,399 --> 00:12:03,120
both the authenticated state and

331
00:12:03,120 --> 00:12:05,839
interact based on their

332
00:12:05,839 --> 00:12:07,839
own memory register followed by

333
00:12:07,839 --> 00:12:09,680
verification and once again we're going

334
00:12:09,680 --> 00:12:10,800
to

335
00:12:10,800 --> 00:12:13,519
condition on acceptance by this overlap

336
00:12:13,519 --> 00:12:16,639
so we get some state sigma

337
00:12:16,639 --> 00:12:18,399
in the real setting that depends on a

338
00:12:18,399 --> 00:12:19,920
key k

339
00:12:19,920 --> 00:12:21,600
but what's an ideal adversary for

340
00:12:21,600 --> 00:12:23,200
quantum authentication well we could

341
00:12:23,200 --> 00:12:25,040
think that the ideal adversary is an

342
00:12:25,040 --> 00:12:26,959
adversary that just does not interact

343
00:12:26,959 --> 00:12:29,519
with the authenticated state

344
00:12:29,519 --> 00:12:30,240
so

345
00:12:30,240 --> 00:12:33,120
here we have uh an ideal it's a bursary

346
00:12:33,120 --> 00:12:35,680
side that simply interacts on their own

347
00:12:35,680 --> 00:12:37,519
memory register they cannot touch the

348
00:12:37,519 --> 00:12:38,720
authenticated state between the

349
00:12:38,720 --> 00:12:41,040
authentication and the verification

350
00:12:41,040 --> 00:12:42,720
and we're going to say that this

351
00:12:42,720 --> 00:12:44,800
authentication scheme is epsilon secure

352
00:12:44,800 --> 00:12:46,399
if for all

353
00:12:46,399 --> 00:12:48,880
state sigma sorry if for all initial

354
00:12:48,880 --> 00:12:51,120
states row the final states in both of

355
00:12:51,120 --> 00:12:53,680
these dashed red boxes

356
00:12:53,680 --> 00:12:55,680
are epsilon close and trace distance and

357
00:12:55,680 --> 00:12:58,880
note that this includes the

358
00:12:58,880 --> 00:13:01,440
the key k

359
00:13:01,440 --> 00:13:02,959
and i also want to highlight here that

360
00:13:02,959 --> 00:13:05,279
in the ideal scenario the adversary

361
00:13:05,279 --> 00:13:07,279
and their memory register zed they have

362
00:13:07,279 --> 00:13:09,200
no information on the key that is used

363
00:13:09,200 --> 00:13:11,440
right they don't actually find a way to

364
00:13:11,440 --> 00:13:14,320
interact with the key

365
00:13:14,800 --> 00:13:16,639
okay

366
00:13:16,639 --> 00:13:18,320
so how can we use a total quantum

367
00:13:18,320 --> 00:13:20,320
authentication scheme to construct a

368
00:13:20,320 --> 00:13:21,760
copy protection scheme for point

369
00:13:21,760 --> 00:13:23,839
functions so let's recall that a point

370
00:13:23,839 --> 00:13:25,519
function is a function that takes as

371
00:13:25,519 --> 00:13:28,240
input a bit string of length n and

372
00:13:28,240 --> 00:13:30,480
outputs a single bit

373
00:13:30,480 --> 00:13:32,000
now every point function is

374
00:13:32,000 --> 00:13:33,680
characterized by precisely one bit

375
00:13:33,680 --> 00:13:34,399
string

376
00:13:34,399 --> 00:13:37,120
it's point we're going to denote it p

377
00:13:37,120 --> 00:13:38,880
and the function is such that it outputs

378
00:13:38,880 --> 00:13:41,519
one if and only if the argument is its

379
00:13:41,519 --> 00:13:43,760
point

380
00:13:43,760 --> 00:13:46,000
so now we're going to take some epsilon

381
00:13:46,000 --> 00:13:47,600
total authentication scheme we're going

382
00:13:47,600 --> 00:13:50,240
to fix an arbitrary state psi

383
00:13:50,240 --> 00:13:52,079
on the message space

384
00:13:52,079 --> 00:13:54,000
and the idea is to

385
00:13:54,000 --> 00:13:55,600
build on this correspondence that we can

386
00:13:55,600 --> 00:13:57,199
have between inputs to the point

387
00:13:57,199 --> 00:13:59,680
function and keys to the authentication

388
00:13:59,680 --> 00:14:00,639
scheme

389
00:14:00,639 --> 00:14:02,880
so our protection algorithm

390
00:14:02,880 --> 00:14:04,880
our protection procedure on input of a

391
00:14:04,880 --> 00:14:06,880
point function delta p is simply going

392
00:14:06,880 --> 00:14:08,720
to output the authentication of the

393
00:14:08,720 --> 00:14:12,800
fixed state using the point as the key

394
00:14:12,800 --> 00:14:15,199
so if we authenticate

395
00:14:15,199 --> 00:14:17,120
sorry if we protect using authenticate

396
00:14:17,120 --> 00:14:18,480
we're going to evaluate using

397
00:14:18,480 --> 00:14:19,920
verification

398
00:14:19,920 --> 00:14:22,320
so an input of a candidate program sigma

399
00:14:22,320 --> 00:14:24,480
and some argument x

400
00:14:24,480 --> 00:14:26,560
our evaluation procedure is simply going

401
00:14:26,560 --> 00:14:31,120
to verify sigma using x as the key

402
00:14:31,120 --> 00:14:33,040
the evaluation procedure then outputs

403
00:14:33,040 --> 00:14:35,360
one if and only if the verification

404
00:14:35,360 --> 00:14:37,040
accepts

405
00:14:37,040 --> 00:14:39,040
so ideally we would achieve uh

406
00:14:39,040 --> 00:14:40,480
correctness in the following way we

407
00:14:40,480 --> 00:14:42,079
would say that we have an ita correct

408
00:14:42,079 --> 00:14:44,240
scheme if for all possible arguments x

409
00:14:44,240 --> 00:14:46,880
and all possible point functions delta p

410
00:14:46,880 --> 00:14:48,880
the probability over the randomness of

411
00:14:48,880 --> 00:14:50,880
the evaluation and protection procedure

412
00:14:50,880 --> 00:14:53,199
that you obtain the correct outcome

413
00:14:53,199 --> 00:14:57,839
is greater or equal to one minus eta

414
00:14:57,839 --> 00:15:00,480
we don't achieve the above correctness

415
00:15:00,480 --> 00:15:01,920
instead we're going to have correctness

416
00:15:01,920 --> 00:15:04,079
with respect to certain distributions so

417
00:15:04,079 --> 00:15:06,880
what do we mean by this we mean that uh

418
00:15:06,880 --> 00:15:08,560
we're going to define and achieve data

419
00:15:08,560 --> 00:15:10,399
correctness with respect to a family of

420
00:15:10,399 --> 00:15:12,399
distributions indexed by

421
00:15:12,399 --> 00:15:15,279
by potential functions

422
00:15:15,279 --> 00:15:17,600
more precisely for all possible point

423
00:15:17,600 --> 00:15:19,600
functions the probability that the

424
00:15:19,600 --> 00:15:21,440
evaluation

425
00:15:21,440 --> 00:15:23,519
correctly outputs

426
00:15:23,519 --> 00:15:24,959
taken over the randomness of the

427
00:15:24,959 --> 00:15:27,040
evaluation and protection procedure as

428
00:15:27,040 --> 00:15:30,000
well as the sampling of the input

429
00:15:30,000 --> 00:15:31,279
is

430
00:15:31,279 --> 00:15:34,000
at least one minus beta

431
00:15:34,000 --> 00:15:35,440
right so we don't necessarily have

432
00:15:35,440 --> 00:15:37,680
correctness for all possible inputs we

433
00:15:37,680 --> 00:15:40,160
obtain correctness averaged or taken out

434
00:15:40,160 --> 00:15:41,360
of sorry

435
00:15:41,360 --> 00:15:43,360
we obtained correctness with probability

436
00:15:43,360 --> 00:15:46,639
over the possible inputs

437
00:15:46,959 --> 00:15:49,199
okay

438
00:15:50,000 --> 00:15:52,880
so let's uh bring up the scheme here so

439
00:15:52,880 --> 00:15:55,279
recall that we protect by authenticating

440
00:15:55,279 --> 00:15:57,360
and evaluate by verifying

441
00:15:57,360 --> 00:15:59,120
so we're going to show correctness with

442
00:15:59,120 --> 00:16:04,079
respect to a very specific distribution

443
00:16:04,079 --> 00:16:06,959
this is the distribution that

444
00:16:06,959 --> 00:16:08,880
sorry so the distribution is indexed by

445
00:16:08,880 --> 00:16:12,800
the point function delta p and for

446
00:16:12,800 --> 00:16:15,600
every possible bit string it's going to

447
00:16:15,600 --> 00:16:18,800
be p with probability one half and not p

448
00:16:18,800 --> 00:16:20,639
with probability one half and in this

449
00:16:20,639 --> 00:16:23,040
case it is sampled uniformly at random

450
00:16:23,040 --> 00:16:24,880
over all possible bit strings that are

451
00:16:24,880 --> 00:16:27,439
not p

452
00:16:28,240 --> 00:16:29,920
to properly show correctness we actually

453
00:16:29,920 --> 00:16:31,680
show this following theorem which states

454
00:16:31,680 --> 00:16:32,800
that for

455
00:16:32,800 --> 00:16:35,040
any epsilon total authentication scheme

456
00:16:35,040 --> 00:16:37,600
for any state row if you sample a random

457
00:16:37,600 --> 00:16:40,320
tk the probability that you accept is at

458
00:16:40,320 --> 00:16:43,120
most two to the epsilon

459
00:16:43,120 --> 00:16:44,800
so the theorem follows from the security

460
00:16:44,800 --> 00:16:46,240
of the authentication scheme you can

461
00:16:46,240 --> 00:16:48,079
kind of the the argument essentially

462
00:16:48,079 --> 00:16:49,680
says that if there was a state that was

463
00:16:49,680 --> 00:16:51,759
excited that was accepted

464
00:16:51,759 --> 00:16:53,519
with higher probability

465
00:16:53,519 --> 00:16:54,959
you could use the state to construct an

466
00:16:54,959 --> 00:16:56,480
attack against the authentication

467
00:16:56,480 --> 00:16:59,440
verification scheme

468
00:17:00,320 --> 00:17:02,000
so by correctness of the authentication

469
00:17:02,000 --> 00:17:04,720
scheme for all points p we have that we

470
00:17:04,720 --> 00:17:06,880
correctly evaluate on the point p with

471
00:17:06,880 --> 00:17:09,359
probability one and this theorem will

472
00:17:09,359 --> 00:17:11,359
allow us to make a statement for what

473
00:17:11,359 --> 00:17:12,959
happens when you try to evaluate with

474
00:17:12,959 --> 00:17:14,959
the wrong key

475
00:17:14,959 --> 00:17:17,039
you combine all of the above

476
00:17:17,039 --> 00:17:18,559
and you show that when you start with an

477
00:17:18,559 --> 00:17:20,480
epsilon total authentication scheme the

478
00:17:20,480 --> 00:17:22,799
probability that you correctly evaluate

479
00:17:22,799 --> 00:17:26,319
is at least one minus epsilon

480
00:17:26,319 --> 00:17:27,679
all right let's move on to the honest

481
00:17:27,679 --> 00:17:29,840
malicious security let's refresh our

482
00:17:29,840 --> 00:17:31,360
memory just a bit

483
00:17:31,360 --> 00:17:33,440
so our scheme is here once again we

484
00:17:33,440 --> 00:17:34,960
protect by authenticating and we

485
00:17:34,960 --> 00:17:38,160
evaluate by verifying

486
00:17:38,160 --> 00:17:39,679
more precisely we're going to prove

487
00:17:39,679 --> 00:17:42,240
security uh when depth one the point

488
00:17:42,240 --> 00:17:44,240
function is sampled uniformly at random

489
00:17:44,240 --> 00:17:46,160
from all possible point functions and

490
00:17:46,160 --> 00:17:48,080
where each challenge is sampled

491
00:17:48,080 --> 00:17:51,039
according to this

492
00:17:51,039 --> 00:17:53,039
distribution that is p with probability

493
00:17:53,039 --> 00:17:55,039
one half and not p with probability one

494
00:17:55,039 --> 00:17:57,200
half both challenges are going to be

495
00:17:57,200 --> 00:18:00,080
sampled uh independently

496
00:18:00,080 --> 00:18:02,240
from each other

497
00:18:02,240 --> 00:18:04,160
so let's recall the security game so we

498
00:18:04,160 --> 00:18:05,919
have our referee our pirate both

499
00:18:05,919 --> 00:18:07,679
evaluators

500
00:18:07,679 --> 00:18:08,880
and we check whether or not the

501
00:18:08,880 --> 00:18:11,600
evaluators correctly compute

502
00:18:11,600 --> 00:18:14,400
the value of the point function

503
00:18:14,400 --> 00:18:15,600
okay

504
00:18:15,600 --> 00:18:16,880
so

505
00:18:16,880 --> 00:18:20,080
let's sketch our proof of security

506
00:18:20,080 --> 00:18:21,120
essentially we're making a

507
00:18:21,120 --> 00:18:22,640
correspondence between the honest

508
00:18:22,640 --> 00:18:25,280
evaluator correctly evaluating delta p

509
00:18:25,280 --> 00:18:27,280
on the point p with accepting

510
00:18:27,280 --> 00:18:29,360
authenticated state

511
00:18:29,360 --> 00:18:31,280
and we recall from total authentication

512
00:18:31,280 --> 00:18:33,679
that conditioned on acceptance

513
00:18:33,679 --> 00:18:35,360
the attacker will know essentially

514
00:18:35,360 --> 00:18:37,600
nothing on the key

515
00:18:37,600 --> 00:18:39,760
now we play this correspondence more we

516
00:18:39,760 --> 00:18:41,600
say that oh the authentication key

517
00:18:41,600 --> 00:18:42,799
actually corresponds to the copy

518
00:18:42,799 --> 00:18:44,640
protected function the authentication

519
00:18:44,640 --> 00:18:46,080
attack corresponds to the copy

520
00:18:46,080 --> 00:18:48,640
protection adversaries so conditioned on

521
00:18:48,640 --> 00:18:49,760
acceptance the attacker knows

522
00:18:49,760 --> 00:18:51,280
essentially nothing on the key they know

523
00:18:51,280 --> 00:18:53,679
essentially nothing on the function on

524
00:18:53,679 --> 00:18:54,880
the point function that was copy

525
00:18:54,880 --> 00:18:56,720
protected that's going to limit their

526
00:18:56,720 --> 00:18:59,679
ability to correctly compute

527
00:18:59,679 --> 00:19:01,440
the circuit

528
00:19:01,440 --> 00:19:03,039
right so if the honest evaluator is

529
00:19:03,039 --> 00:19:04,880
correct then the malicious evaluator

530
00:19:04,880 --> 00:19:06,720
knows essentially nothing on the point

531
00:19:06,720 --> 00:19:09,280
of the point function

532
00:19:09,280 --> 00:19:10,880
we also need to analyze the case where

533
00:19:10,880 --> 00:19:13,120
the honest evaluator is challenged with

534
00:19:13,120 --> 00:19:14,880
something that is not the point of the

535
00:19:14,880 --> 00:19:17,120
point function that is authenticated

536
00:19:17,120 --> 00:19:20,000
but we leave that for the paper

537
00:19:20,000 --> 00:19:21,600
formally the theorem that we show is

538
00:19:21,600 --> 00:19:22,840
that with this scheme and these

539
00:19:22,840 --> 00:19:25,280
distributions the probability that both

540
00:19:25,280 --> 00:19:27,679
that the adversaries win is at most this

541
00:19:27,679 --> 00:19:30,320
trivial guessing probability and this uh

542
00:19:30,320 --> 00:19:32,880
fairly nice function of epsilon we also

543
00:19:32,880 --> 00:19:34,000
show that the trivial guessing

544
00:19:34,000 --> 00:19:35,760
probability in this case is precisely

545
00:19:35,760 --> 00:19:38,000
one half

546
00:19:38,000 --> 00:19:40,960
okay so we've obtained a scheme for copy

547
00:19:40,960 --> 00:19:43,120
protecting point functions in the honest

548
00:19:43,120 --> 00:19:45,039
malicious setting let's finally talk

549
00:19:45,039 --> 00:19:47,200
about secure software lisa

550
00:19:47,200 --> 00:19:49,120
so secure software leasing is similar to

551
00:19:49,120 --> 00:19:50,960
copy protection in the sense that it

552
00:19:50,960 --> 00:19:54,240
prevents uh copying of programs but it

553
00:19:54,240 --> 00:19:56,160
is a bit different in the sense that

554
00:19:56,160 --> 00:19:58,720
there will be no second evaluation we're

555
00:19:58,720 --> 00:20:00,720
going to have a verification procedure

556
00:20:00,720 --> 00:20:02,240
instead

557
00:20:02,240 --> 00:20:04,480
so security is also parameterized by

558
00:20:04,480 --> 00:20:08,000
distribution over circuits and inputs

559
00:20:08,000 --> 00:20:09,280
much in the same way that copy

560
00:20:09,280 --> 00:20:12,320
protection was so let's sketch this ssl

561
00:20:12,320 --> 00:20:13,679
game

562
00:20:13,679 --> 00:20:15,120
so we're going to have a referee and a

563
00:20:15,120 --> 00:20:17,360
pirate in this case the pirate is also

564
00:20:17,360 --> 00:20:19,520
going to play the role of the single

565
00:20:19,520 --> 00:20:21,760
evaluator there is no second evaluator

566
00:20:21,760 --> 00:20:24,080
as previously mentioned

567
00:20:24,080 --> 00:20:25,679
the referee is going to sample a circuit

568
00:20:25,679 --> 00:20:27,679
c according to the distribution d

569
00:20:27,679 --> 00:20:30,000
produce some state row that essentially

570
00:20:30,000 --> 00:20:31,840
encodes the circuit and that state row

571
00:20:31,840 --> 00:20:33,919
off to the pirate the pirate does some

572
00:20:33,919 --> 00:20:35,679
computation they can hold on to some

573
00:20:35,679 --> 00:20:37,600
quantum information but eventually they

574
00:20:37,600 --> 00:20:39,440
have to return some state sigma to the

575
00:20:39,440 --> 00:20:40,720
referee

576
00:20:40,720 --> 00:20:42,880
the referee will then verify the state

577
00:20:42,880 --> 00:20:44,880
sigma and either accept the return or

578
00:20:44,880 --> 00:20:46,880
reject it

579
00:20:46,880 --> 00:20:48,400
assuming they accept they're going to

580
00:20:48,400 --> 00:20:50,400
sample some argument x

581
00:20:50,400 --> 00:20:52,559
according to the distribution tc that

582
00:20:52,559 --> 00:20:54,880
can depend on the circuit c hand x off

583
00:20:54,880 --> 00:20:57,039
to the pirate and the pirate wins if and

584
00:20:57,039 --> 00:21:00,320
only if they correctly compute

585
00:21:00,320 --> 00:21:01,520
the value

586
00:21:01,520 --> 00:21:04,480
of the the point function on x

587
00:21:04,480 --> 00:21:06,240
so very similarly we're going to say

588
00:21:06,240 --> 00:21:07,919
that the scheme is epsilon secure if the

589
00:21:07,919 --> 00:21:10,320
probability that the referee accepts and

590
00:21:10,320 --> 00:21:12,320
that the pirate correctly computes uh

591
00:21:12,320 --> 00:21:15,039
the outcome is at most the trivial

592
00:21:15,039 --> 00:21:18,400
guessing probability plus epsilon

593
00:21:18,400 --> 00:21:21,200
and finally we emphasize that uh in this

594
00:21:21,200 --> 00:21:22,799
setting the pirate can evaluate

595
00:21:22,799 --> 00:21:25,600
maliciously so we don't control any

596
00:21:25,600 --> 00:21:29,280
of the computation that the pirate does

597
00:21:29,360 --> 00:21:30,880
so how do we obtain secure software

598
00:21:30,880 --> 00:21:32,400
leasing from honest malicious copy

599
00:21:32,400 --> 00:21:34,240
protection well the idea is quite simple

600
00:21:34,240 --> 00:21:36,159
you can verify a return program by

601
00:21:36,159 --> 00:21:39,600
honestly evaluating it on an input

602
00:21:39,600 --> 00:21:41,679
the protection and evaluation procedures

603
00:21:41,679 --> 00:21:43,600
in this setting are unchanged we just

604
00:21:43,600 --> 00:21:45,520
construct the verify

605
00:21:45,520 --> 00:21:48,240
from the honest evaluation right so how

606
00:21:48,240 --> 00:21:51,039
do you verify on input of some circuit c

607
00:21:51,039 --> 00:21:54,000
and a candidate program sigma right that

608
00:21:54,000 --> 00:21:55,919
the pirate claims

609
00:21:55,919 --> 00:21:59,039
uh was the program for c you sample some

610
00:21:59,039 --> 00:22:01,360
argument x prime according to the sum

611
00:22:01,360 --> 00:22:04,159
distribution t prime c you compute and

612
00:22:04,159 --> 00:22:06,320
you verify whether or not this is the

613
00:22:06,320 --> 00:22:08,640
correct outcome

614
00:22:08,640 --> 00:22:10,559
if you plug this into the game you get

615
00:22:10,559 --> 00:22:12,720
this figure here where we just kind of

616
00:22:12,720 --> 00:22:14,480
expand a verification procedure to

617
00:22:14,480 --> 00:22:16,320
include and you see that this

618
00:22:16,320 --> 00:22:18,559
essentially simulates the honest

619
00:22:18,559 --> 00:22:20,559
evaluator

620
00:22:20,559 --> 00:22:22,960
of the honest malicious copy protection

621
00:22:22,960 --> 00:22:23,230
game

622
00:22:23,230 --> 00:22:24,480
[Music]

623
00:22:24,480 --> 00:22:26,159
so the theorem that we show is that if

624
00:22:26,159 --> 00:22:28,000
the copy protection scheme is epsilon

625
00:22:28,000 --> 00:22:30,320
honestly secure with respect to some

626
00:22:30,320 --> 00:22:31,760
distribution d

627
00:22:31,760 --> 00:22:34,480
and this distribution on challenges

628
00:22:34,480 --> 00:22:36,880
uh then the derived ssl scheme is going

629
00:22:36,880 --> 00:22:38,799
to be epsilon secure with respect to the

630
00:22:38,799 --> 00:22:40,720
same distribution

631
00:22:40,720 --> 00:22:43,120
on the circuits and just the singular

632
00:22:43,120 --> 00:22:45,520
distribution on the challenges to the

633
00:22:45,520 --> 00:22:47,760
pirate

634
00:22:47,760 --> 00:22:50,240
okay so in conclusion

635
00:22:50,240 --> 00:22:51,840
what do we have as results in this work

636
00:22:51,840 --> 00:22:53,360
well we define and achieve honest

637
00:22:53,360 --> 00:22:54,799
malicious copy protection with no

638
00:22:54,799 --> 00:22:56,960
assumptions i also want to put up this

639
00:22:56,960 --> 00:22:58,960
figure here that kind of sketches how we

640
00:22:58,960 --> 00:23:01,440
do this

641
00:23:01,520 --> 00:23:03,200
we show that honest malicious copy

642
00:23:03,200 --> 00:23:05,600
protection yields ssl

643
00:23:05,600 --> 00:23:07,360
and we can contrast this for up with

644
00:23:07,360 --> 00:23:09,039
other works where we do not need any

645
00:23:09,039 --> 00:23:11,039
assumptions we have no setups and no

646
00:23:11,039 --> 00:23:13,120
oracles

647
00:23:13,120 --> 00:23:15,120
finally but kind of the trade-off here

648
00:23:15,120 --> 00:23:16,559
is that for copy protection we only

649
00:23:16,559 --> 00:23:18,000
consider a restricted class of

650
00:23:18,000 --> 00:23:19,440
adversaries right we have honest

651
00:23:19,440 --> 00:23:21,440
malicious copy protection which is a bit

652
00:23:21,440 --> 00:23:22,640
weaker

653
00:23:22,640 --> 00:23:24,320
than the more general malicious

654
00:23:24,320 --> 00:23:26,640
malicious copy copy protection if you

655
00:23:26,640 --> 00:23:28,400
will

656
00:23:28,400 --> 00:23:29,679
so there's two

657
00:23:29,679 --> 00:23:32,080
main open questions for future work

658
00:23:32,080 --> 00:23:33,280
first of all can we improve the

659
00:23:33,280 --> 00:23:34,640
correctness of our scheme right so

660
00:23:34,640 --> 00:23:38,000
currently we have correctness over

661
00:23:38,000 --> 00:23:40,159
with a probability over possible inputs

662
00:23:40,159 --> 00:23:41,600
we would like to have correctness for

663
00:23:41,600 --> 00:23:43,360
all possible inputs

664
00:23:43,360 --> 00:23:45,679
and perhaps the main question is can we

665
00:23:45,679 --> 00:23:48,320
achieve copy protection against

666
00:23:48,320 --> 00:23:50,640
two malicious evaluators without any

667
00:23:50,640 --> 00:23:52,400
assumptions at all and i think this is a

668
00:23:52,400 --> 00:23:54,960
question that is

669
00:23:54,960 --> 00:23:56,480
gathering quite a lot of interest in the

670
00:23:56,480 --> 00:23:57,919
field right now

671
00:23:57,919 --> 00:24:02,120
and with that thank you very much

